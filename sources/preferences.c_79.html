
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika, Tobias Ellinghaus.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln20">#include &lt;strings.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln23">#include &quot;common/darktable.h&quot;</a>
<a name="ln24">#include &quot;common/debug.h&quot;</a>
<a name="ln25">#include &quot;common/file_location.h&quot;</a>
<a name="ln26">#include &quot;common/l10n.h&quot;</a>
<a name="ln27">#include &quot;common/presets.h&quot;</a>
<a name="ln28">#include &quot;control/control.h&quot;</a>
<a name="ln29">#include &quot;develop/imageop.h&quot;</a>
<a name="ln30">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln31">#include &quot;gui/draw.h&quot;</a>
<a name="ln32">#include &quot;gui/gtk.h&quot;</a>
<a name="ln33">#include &quot;gui/preferences.h&quot;</a>
<a name="ln34">#include &quot;gui/presets.h&quot;</a>
<a name="ln35">#include &quot;libs/lib.h&quot;</a>
<a name="ln36">#include &quot;preferences_gen.h&quot;</a>
<a name="ln37">#ifdef USE_LUA</a>
<a name="ln38">#include &quot;lua/preferences.h&quot;</a>
<a name="ln39">#endif</a>
<a name="ln40">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln41">#include &quot;osx/osx.h&quot;</a>
<a name="ln42">#endif</a>
<a name="ln43">#define ICON_SIZE 13</a>
<a name="ln44"> </a>
<a name="ln45">typedef struct dt_gui_presets_edit_dialog_t</a>
<a name="ln46">{</a>
<a name="ln47">  GtkTreeView *tree; // CHANGED!</a>
<a name="ln48">  gint rowid;        // CHANGED!</a>
<a name="ln49">  GtkLabel *name;</a>
<a name="ln50">  GtkEntry *description;</a>
<a name="ln51">  GtkCheckButton *autoapply, *filter;</a>
<a name="ln52">  GtkWidget *details;</a>
<a name="ln53">  GtkEntry *model, *maker, *lens;</a>
<a name="ln54">  GtkSpinButton *iso_min, *iso_max;</a>
<a name="ln55">  GtkWidget *exposure_min, *exposure_max;</a>
<a name="ln56">  GtkWidget *aperture_min, *aperture_max;</a>
<a name="ln57">  GtkSpinButton *focal_length_min, *focal_length_max;</a>
<a name="ln58">  GtkWidget *format_btn[3];</a>
<a name="ln59">} dt_gui_presets_edit_dialog_t;</a>
<a name="ln60"> </a>
<a name="ln61">// FIXME: this is copypasta from gui/presets.c. better put these somewhere so that all places can access the</a>
<a name="ln62">// same data.</a>
<a name="ln63">static const int dt_gui_presets_exposure_value_cnt = 24;</a>
<a name="ln64">static const float dt_gui_presets_exposure_value[]</a>
<a name="ln65">    = { 0.,       1. / 8000, 1. / 4000, 1. / 2000, 1. / 1000, 1. / 1000, 1. / 500, 1. / 250,</a>
<a name="ln66">        1. / 125, 1. / 60,   1. / 30,   1. / 15,   1. / 15,   1. / 8,    1. / 4,   1. / 2,</a>
<a name="ln67">        1,        2,         4,         8,         15,        30,        60,       FLT_MAX };</a>
<a name="ln68">static const char *dt_gui_presets_exposure_value_str[]</a>
<a name="ln69">    = { &quot;0&quot;,     &quot;1/8000&quot;, &quot;1/4000&quot;, &quot;1/2000&quot;, &quot;1/1000&quot;, &quot;1/1000&quot;, &quot;1/500&quot;, &quot;1/250&quot;,</a>
<a name="ln70">        &quot;1/125&quot;, &quot;1/60&quot;,   &quot;1/30&quot;,   &quot;1/15&quot;,   &quot;1/15&quot;,   &quot;1/8&quot;,    &quot;1/4&quot;,   &quot;1/2&quot;,</a>
<a name="ln71">        &quot;1\&quot;&quot;,   &quot;2\&quot;&quot;,    &quot;4\&quot;&quot;,    &quot;8\&quot;&quot;,    &quot;15\&quot;&quot;,   &quot;30\&quot;&quot;,   &quot;60\&quot;&quot;,  &quot;+&quot; };</a>
<a name="ln72">static const int dt_gui_presets_aperture_value_cnt = 19;</a>
<a name="ln73">static const float dt_gui_presets_aperture_value[]</a>
<a name="ln74">    = { 0,    0.5,  0.7,  1.0,  1.4,  2.0,  2.8,  4.0,   5.6,    8.0,</a>
<a name="ln75">        11.0, 16.0, 22.0, 32.0, 45.0, 64.0, 90.0, 128.0, FLT_MAX };</a>
<a name="ln76">static const char *dt_gui_presets_aperture_value_str[]</a>
<a name="ln77">    = { &quot;f/0&quot;,  &quot;f/0.5&quot;, &quot;f/0.7&quot;, &quot;f/1.0&quot;, &quot;f/1.4&quot;, &quot;f/2&quot;,  &quot;f/2.8&quot;, &quot;f/4&quot;,   &quot;f/5.6&quot;, &quot;f/8&quot;,</a>
<a name="ln78">        &quot;f/11&quot;, &quot;f/16&quot;,  &quot;f/22&quot;,  &quot;f/32&quot;,  &quot;f/45&quot;,  &quot;f/64&quot;, &quot;f/90&quot;,  &quot;f/128&quot;, &quot;f/+&quot; };</a>
<a name="ln79"> </a>
<a name="ln80">// format string and corresponding flag stored into the database</a>
<a name="ln81">static const char *dt_gui_presets_format_value_str[3] = { N_(&quot;normal images&quot;),</a>
<a name="ln82">                                                          N_(&quot;raw&quot;),</a>
<a name="ln83">                                                          N_(&quot;HDR&quot;)};</a>
<a name="ln84">static const int dt_gui_presets_format_flag[3] = { FOR_LDR, FOR_RAW, FOR_HDR };</a>
<a name="ln85"> </a>
<a name="ln86">// Values for the accelerators/presets treeview</a>
<a name="ln87"> </a>
<a name="ln88">enum</a>
<a name="ln89">{</a>
<a name="ln90">  A_ACCEL_COLUMN,</a>
<a name="ln91">  A_BINDING_COLUMN,</a>
<a name="ln92">  A_TRANS_COLUMN,</a>
<a name="ln93">  A_N_COLUMNS</a>
<a name="ln94">};</a>
<a name="ln95">enum</a>
<a name="ln96">{</a>
<a name="ln97">  P_ROWID_COLUMN,</a>
<a name="ln98">  P_OPERATION_COLUMN,</a>
<a name="ln99">  P_MODULE_COLUMN,</a>
<a name="ln100">  P_EDITABLE_COLUMN,</a>
<a name="ln101">  P_NAME_COLUMN,</a>
<a name="ln102">  P_MODEL_COLUMN,</a>
<a name="ln103">  P_MAKER_COLUMN,</a>
<a name="ln104">  P_LENS_COLUMN,</a>
<a name="ln105">  P_ISO_COLUMN,</a>
<a name="ln106">  P_EXPOSURE_COLUMN,</a>
<a name="ln107">  P_APERTURE_COLUMN,</a>
<a name="ln108">  P_FOCAL_LENGTH_COLUMN,</a>
<a name="ln109">  P_AUTOAPPLY_COLUMN,</a>
<a name="ln110">  P_N_COLUMNS</a>
<a name="ln111">};</a>
<a name="ln112"> </a>
<a name="ln113">static void init_tab_presets(GtkWidget *book);</a>
<a name="ln114">static void init_tab_accels(GtkWidget *book);</a>
<a name="ln115">static void tree_insert_accel(gpointer accel_struct, gpointer model_link);</a>
<a name="ln116">static void tree_insert_rec(GtkTreeStore *model, GtkTreeIter *parent, const gchar *accel_path,</a>
<a name="ln117">                            const gchar *translated_path, guint accel_key, GdkModifierType accel_mods);</a>
<a name="ln118">static void path_to_accel(GtkTreeModel *model, GtkTreePath *path, gchar *str, size_t str_len);</a>
<a name="ln119">static void update_accels_model(gpointer widget, gpointer data);</a>
<a name="ln120">static void update_accels_model_rec(GtkTreeModel *model, GtkTreeIter *parent, gchar *path, size_t path_len);</a>
<a name="ln121">static void delete_matching_accels(gpointer path, gpointer key_event);</a>
<a name="ln122">static void import_export(GtkButton *button, gpointer data);</a>
<a name="ln123">static void restore_defaults(GtkButton *button, gpointer data);</a>
<a name="ln124">static gint compare_rows_accels(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data);</a>
<a name="ln125">static gint compare_rows_presets(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data);</a>
<a name="ln126">static void import_preset(GtkButton *button, gpointer data);</a>
<a name="ln127"> </a>
<a name="ln128">// Signal handlers</a>
<a name="ln129">static void tree_row_activated_accels(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln130">                                      gpointer data);</a>
<a name="ln131">static void tree_row_activated_presets(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln132">                                       gpointer data);</a>
<a name="ln133">static void tree_selection_changed(GtkTreeSelection *selection, gpointer data);</a>
<a name="ln134">static gboolean tree_key_press(GtkWidget *widget, GdkEventKey *event, gpointer data);</a>
<a name="ln135">static gboolean tree_key_press_presets(GtkWidget *widget, GdkEventKey *event, gpointer data);</a>
<a name="ln136">static gboolean prefix_search(GtkTreeModel *model, gint column, const gchar *key, GtkTreeIter *iter,</a>
<a name="ln137">                              gpointer d);</a>
<a name="ln138"> </a>
<a name="ln139">static void edit_preset(GtkTreeView *tree, const gint rowid, const gchar *name, const gchar *module);</a>
<a name="ln140">static void edit_preset_response(GtkDialog *dialog, gint response_id, dt_gui_presets_edit_dialog_t *g);</a>
<a name="ln141"> </a>
<a name="ln142">static GtkWidget *_preferences_dialog;</a>
<a name="ln143"> </a>
<a name="ln144">///////////// gui theme selection</a>
<a name="ln145"> </a>
<a name="ln146">static void load_themes_dir(const char *basedir)</a>
<a name="ln147">{</a>
<a name="ln148">  char *themes_dir = g_build_filename(basedir, &quot;themes&quot;, NULL);</a>
<a name="ln149">  GDir *dir = g_dir_open(themes_dir, 0, NULL);</a>
<a name="ln150">  if(dir)</a>
<a name="ln151">  {</a>
<a name="ln152">    const gchar *d_name;</a>
<a name="ln153">    while((d_name = g_dir_read_name(dir)))</a>
<a name="ln154">      darktable.themes = g_list_append(darktable.themes, g_strdup(d_name));</a>
<a name="ln155">    g_dir_close(dir);</a>
<a name="ln156">  }</a>
<a name="ln157">  g_free(themes_dir);</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160">static void load_themes(void)</a>
<a name="ln161">{</a>
<a name="ln162">  // Clear theme list...</a>
<a name="ln163">  g_list_free_full(darktable.themes, g_free);</a>
<a name="ln164">  darktable.themes = NULL;</a>
<a name="ln165"> </a>
<a name="ln166">  // check themes dirs</a>
<a name="ln167">  gchar configdir[PATH_MAX] = { 0 };</a>
<a name="ln168">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln169">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln170">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln171"> </a>
<a name="ln172">  load_themes_dir(datadir);</a>
<a name="ln173">  load_themes_dir(configdir);</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">static void theme_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln177">{</a>
<a name="ln178">  const int selected = gtk_combo_box_get_active(GTK_COMBO_BOX(widget));</a>
<a name="ln179">  gchar *theme = g_list_nth(darktable.themes, selected)-&gt;data;</a>
<a name="ln180">  gchar *i = g_strrstr(theme, &quot;.&quot;);</a>
<a name="ln181">  if(i) *i = '\0';</a>
<a name="ln182">  dt_gui_load_theme(theme);</a>
<a name="ln183">  dt_bauhaus_load_theme();</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">///////////// gui language selection</a>
<a name="ln187"> </a>
<a name="ln188">static void language_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln189">{</a>
<a name="ln190">  int selected = gtk_combo_box_get_active(GTK_COMBO_BOX(widget));</a>
<a name="ln191">  dt_l10n_language_t *language = (dt_l10n_language_t *)g_list_nth(darktable.l10n-&gt;languages, selected)-&gt;data;</a>
<a name="ln192">  if(darktable.l10n-&gt;sys_default == selected)</a>
<a name="ln193">  {</a>
<a name="ln194">    dt_conf_set_string(&quot;ui_last/gui_language&quot;, &quot;&quot;);</a>
<a name="ln195">    darktable.l10n-&gt;selected = darktable.l10n-&gt;sys_default;</a>
<a name="ln196">  }</a>
<a name="ln197">  else</a>
<a name="ln198">  {</a>
<a name="ln199">    dt_conf_set_string(&quot;ui_last/gui_language&quot;, language-&gt;code);</a>
<a name="ln200">    darktable.l10n-&gt;selected = selected;</a>
<a name="ln201">  }</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">static gboolean reset_language_widget(GtkWidget *label, GdkEventButton *event, GtkWidget *widget)</a>
<a name="ln205">{</a>
<a name="ln206">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln207">  {</a>
<a name="ln208">    gtk_combo_box_set_active(GTK_COMBO_BOX(widget), darktable.l10n-&gt;sys_default);</a>
<a name="ln209">    return TRUE;</a>
<a name="ln210">  }</a>
<a name="ln211">  return FALSE;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">static void hardcoded_gui(GtkWidget *grid, int *line)</a>
<a name="ln215">{</a>
<a name="ln216"> </a>
<a name="ln217">  GtkWidget *seclabel = gtk_label_new(_(&quot;general&quot;));</a>
<a name="ln218">  GtkWidget *lbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln219">  gtk_box_pack_start(GTK_BOX(lbox), seclabel, FALSE, FALSE, 0);</a>
<a name="ln220">  gtk_widget_set_hexpand(lbox, TRUE);</a>
<a name="ln221">  gtk_widget_set_name(lbox, &quot;pref_section&quot;);</a>
<a name="ln222">  gtk_grid_attach(GTK_GRID(grid), lbox, 0, (*line)++, 2, 1);</a>
<a name="ln223"> </a>
<a name="ln224"> </a>
<a name="ln225">  // language</a>
<a name="ln226"> </a>
<a name="ln227">  GtkWidget *label = gtk_label_new(_(&quot;interface language&quot;));</a>
<a name="ln228">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln229">  GtkWidget *labelev = gtk_event_box_new();</a>
<a name="ln230">  gtk_widget_add_events(labelev, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln231">  gtk_container_add(GTK_CONTAINER(labelev), label);</a>
<a name="ln232">  GtkWidget *widget = gtk_combo_box_text_new();</a>
<a name="ln233"> </a>
<a name="ln234">  for(GList *iter = darktable.l10n-&gt;languages; iter; iter = g_list_next(iter))</a>
<a name="ln235">  {</a>
<a name="ln236">    const char *name = dt_l10n_get_name(iter-&gt;data);</a>
<a name="ln237">    gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(widget), name);</a>
<a name="ln238">  }</a>
<a name="ln239"> </a>
<a name="ln240">  gtk_combo_box_set_active(GTK_COMBO_BOX(widget), darktable.l10n-&gt;selected);</a>
<a name="ln241">  g_signal_connect(G_OBJECT(widget), &quot;changed&quot;, G_CALLBACK(language_callback), 0);</a>
<a name="ln242">  gtk_widget_set_tooltip_text(labelev,  _(&quot;double click to reset to the system language&quot;));</a>
<a name="ln243">  gtk_event_box_set_visible_window(GTK_EVENT_BOX(labelev), FALSE);</a>
<a name="ln244">  gtk_widget_set_tooltip_text(widget, _(&quot;set the language of the user interface. the system default is marked with an * (needs a restart)&quot;));</a>
<a name="ln245">  gtk_grid_attach(GTK_GRID(grid), labelev, 0, (*line)++, 1, 1);</a>
<a name="ln246">  gtk_grid_attach_next_to(GTK_GRID(grid), widget, labelev, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln247">  g_signal_connect(G_OBJECT(labelev), &quot;button-press-event&quot;, G_CALLBACK(reset_language_widget), (gpointer)widget);</a>
<a name="ln248"> </a>
<a name="ln249">  // theme</a>
<a name="ln250"> </a>
<a name="ln251">  load_themes();</a>
<a name="ln252"> </a>
<a name="ln253">  label = gtk_label_new(_(&quot;theme&quot;));</a>
<a name="ln254">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln255">  gtk_widget_add_events(labelev, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln256">  widget = gtk_combo_box_text_new();</a>
<a name="ln257"> </a>
<a name="ln258">  // read all themes</a>
<a name="ln259">  char *theme_name = dt_conf_get_string(&quot;ui_last/theme&quot;);</a>
<a name="ln260">  int selected = 0;</a>
<a name="ln261">  int k = 0;</a>
<a name="ln262">  for(GList *iter = darktable.themes; iter; iter = g_list_next(iter))</a>
<a name="ln263">  {</a>
<a name="ln264">    gchar *name = g_strdup((gchar*)(iter-&gt;data));</a>
<a name="ln265">    // remove extension</a>
<a name="ln266">    gchar *i = g_strrstr(name, &quot;.&quot;);</a>
<a name="ln267">    if(i) *i = '\0';</a>
<a name="ln268">    gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(widget), name);</a>
<a name="ln269">    if(!g_strcmp0(name, theme_name)) selected = k;</a>
<a name="ln270">    k++;</a>
<a name="ln271">  }</a>
<a name="ln272">  g_free(theme_name);</a>
<a name="ln273"> </a>
<a name="ln274">  gtk_combo_box_set_active(GTK_COMBO_BOX(widget), selected);</a>
<a name="ln275"> </a>
<a name="ln276">  g_signal_connect(G_OBJECT(widget), &quot;changed&quot;, G_CALLBACK(theme_callback), 0);</a>
<a name="ln277">  gtk_widget_set_tooltip_text(widget, _(&quot;set the theme for the user interface&quot;));</a>
<a name="ln278">  gtk_grid_attach(GTK_GRID(grid), label, 0, (*line)++, 1, 1);</a>
<a name="ln279">  gtk_grid_attach_next_to(GTK_GRID(grid), widget, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">///////////// end of gui language selection</a>
<a name="ln283"> </a>
<a name="ln284"> </a>
<a name="ln285">void dt_gui_preferences_show()</a>
<a name="ln286">{</a>
<a name="ln287">  GtkWindow *win = GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui));</a>
<a name="ln288">  _preferences_dialog = gtk_dialog_new_with_buttons(_(&quot;darktable preferences&quot;), win,</a>
<a name="ln289">                                                    GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,</a>
<a name="ln290">                                                    _(&quot;close&quot;), GTK_RESPONSE_ACCEPT, NULL);</a>
<a name="ln291">  gtk_window_set_default_size(GTK_WINDOW(_preferences_dialog), DT_PIXEL_APPLY_DPI(800), DT_PIXEL_APPLY_DPI(800));</a>
<a name="ln292">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln293">  dt_osx_disallow_fullscreen(_preferences_dialog);</a>
<a name="ln294">#endif</a>
<a name="ln295">  gtk_window_set_position(GTK_WINDOW(_preferences_dialog), GTK_WIN_POS_CENTER_ON_PARENT);</a>
<a name="ln296">  GtkWidget *content = gtk_dialog_get_content_area(GTK_DIALOG(_preferences_dialog));</a>
<a name="ln297">  GtkWidget *notebook = gtk_notebook_new();</a>
<a name="ln298">  gtk_widget_set_size_request(notebook, DT_PIXEL_APPLY_DPI(500), DT_PIXEL_APPLY_DPI(500));</a>
<a name="ln299">  gtk_widget_set_name(notebook, &quot;preferences_notebook&quot;);</a>
<a name="ln300">  gtk_box_pack_start(GTK_BOX(content), notebook, TRUE, TRUE, 0);</a>
<a name="ln301"> </a>
<a name="ln302">  // Make sure remap mode is off initially</a>
<a name="ln303">  darktable.control-&gt;accel_remap_str = NULL;</a>
<a name="ln304">  darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln305"> </a>
<a name="ln306">  init_tab_gui(_preferences_dialog, notebook, &amp;hardcoded_gui);</a>
<a name="ln307">  init_tab_core(_preferences_dialog, notebook, NULL);</a>
<a name="ln308">  init_tab_session(_preferences_dialog, notebook, NULL);</a>
<a name="ln309">  init_tab_accels(notebook);</a>
<a name="ln310">  init_tab_presets(notebook);</a>
<a name="ln311">#ifdef USE_LUA</a>
<a name="ln312">  GtkGrid* lua_grid = init_tab_lua(_preferences_dialog, notebook);</a>
<a name="ln313">#endif</a>
<a name="ln314">  gtk_widget_show_all(_preferences_dialog);</a>
<a name="ln315">  (void)gtk_dialog_run(GTK_DIALOG(_preferences_dialog));</a>
<a name="ln316">#ifdef USE_LUA</a>
<a name="ln317">  destroy_tab_lua(lua_grid);</a>
<a name="ln318">#endif</a>
<a name="ln319">  gtk_widget_destroy(_preferences_dialog);</a>
<a name="ln320"> </a>
<a name="ln321">  // Cleaning up any memory still allocated for remapping</a>
<a name="ln322">  if(darktable.control-&gt;accel_remap_path)</a>
<a name="ln323">  {</a>
<a name="ln324">    gtk_tree_path_free(darktable.control-&gt;accel_remap_path);</a>
<a name="ln325">    darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln326">  }</a>
<a name="ln327"> </a>
<a name="ln328">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_PREFERENCES_CHANGE);</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">static void cairo_destroy_from_pixbuf(guchar *pixels, gpointer data)</a>
<a name="ln332">{</a>
<a name="ln333">  cairo_destroy((cairo_t *)data);</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">static void tree_insert_presets(GtkTreeStore *tree_model)</a>
<a name="ln337">{</a>
<a name="ln338">  GtkTreeIter iter, parent;</a>
<a name="ln339">  sqlite3_stmt *stmt;</a>
<a name="ln340">  gchar *last_module = NULL;</a>
<a name="ln341"> </a>
<a name="ln342">  // Create a GdkPixbuf with a cairo drawing.</a>
<a name="ln343">  // lock</a>
<a name="ln344">  cairo_surface_t *lock_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln345">                                                         DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln346">  cairo_t *lock_cr = cairo_create(lock_cst);</a>
<a name="ln347">  cairo_set_source_rgb(lock_cr, 0.7, 0.7, 0.7);</a>
<a name="ln348">  dtgtk_cairo_paint_lock(lock_cr, 0, 0, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE), 0, NULL);</a>
<a name="ln349">  cairo_surface_flush(lock_cst);</a>
<a name="ln350">  guchar *data = cairo_image_surface_get_data(lock_cst);</a>
<a name="ln351">  dt_draw_cairo_to_gdk_pixbuf(data, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln352">  GdkPixbuf *lock_pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,</a>
<a name="ln353">                                                    DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln354">                                                    cairo_image_surface_get_stride(lock_cst),</a>
<a name="ln355">                                                    cairo_destroy_from_pixbuf, lock_cr);</a>
<a name="ln356"> </a>
<a name="ln357">  // check mark</a>
<a name="ln358">  cairo_surface_t *check_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln359">                                                          DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln360">  cairo_t *check_cr = cairo_create(check_cst);</a>
<a name="ln361">  cairo_set_source_rgb(check_cr, 0.7, 0.7, 0.7);</a>
<a name="ln362">  dtgtk_cairo_paint_check_mark(check_cr, 0, 0, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE), 0, NULL);</a>
<a name="ln363">  cairo_surface_flush(check_cst);</a>
<a name="ln364">  data = cairo_image_surface_get_data(check_cst);</a>
<a name="ln365">  dt_draw_cairo_to_gdk_pixbuf(data, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln366">  GdkPixbuf *check_pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,</a>
<a name="ln367">                                                     DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln368">                                                     cairo_image_surface_get_stride(check_cst),</a>
<a name="ln369">                                                     cairo_destroy_from_pixbuf, check_cr);</a>
<a name="ln370"> </a>
<a name="ln371">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln372">                              &quot;SELECT rowid, name, operation, autoapply, model, maker, lens, iso_min, &quot;</a>
<a name="ln373">                              &quot;iso_max, exposure_min, exposure_max, aperture_min, aperture_max, &quot;</a>
<a name="ln374">                              &quot;focal_length_min, focal_length_max, writeprotect FROM data.presets ORDER BY &quot;</a>
<a name="ln375">                              &quot;operation, name&quot;,</a>
<a name="ln376">                              -1, &amp;stmt, NULL);</a>
<a name="ln377">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln378">  {</a>
<a name="ln379">    const gint rowid = sqlite3_column_int(stmt, 0);</a>
<a name="ln380">    const gchar *name = (gchar *)sqlite3_column_text(stmt, 1);</a>
<a name="ln381">    const gchar *operation = (gchar *)sqlite3_column_text(stmt, 2);</a>
<a name="ln382">    const gboolean autoapply = (sqlite3_column_int(stmt, 3) == 0 ? FALSE : TRUE);</a>
<a name="ln383">    const gchar *model = (gchar *)sqlite3_column_text(stmt, 4);</a>
<a name="ln384">    const gchar *maker = (gchar *)sqlite3_column_text(stmt, 5);</a>
<a name="ln385">    const gchar *lens = (gchar *)sqlite3_column_text(stmt, 6);</a>
<a name="ln386">    const float iso_min = sqlite3_column_double(stmt, 7);</a>
<a name="ln387">    const float iso_max = sqlite3_column_double(stmt, 8);</a>
<a name="ln388">    const float exposure_min = sqlite3_column_double(stmt, 9);</a>
<a name="ln389">    const float exposure_max = sqlite3_column_double(stmt, 10);</a>
<a name="ln390">    const float aperture_min = sqlite3_column_double(stmt, 11);</a>
<a name="ln391">    const float aperture_max = sqlite3_column_double(stmt, 12);</a>
<a name="ln392">    const int focal_length_min = sqlite3_column_double(stmt, 13);</a>
<a name="ln393">    const int focal_length_max = sqlite3_column_double(stmt, 14);</a>
<a name="ln394">    const gboolean writeprotect = (sqlite3_column_int(stmt, 15) == 0 ? FALSE : TRUE);</a>
<a name="ln395"> </a>
<a name="ln396">    gchar *iso = NULL, *exposure = NULL, *aperture = NULL, *focal_length = NULL;</a>
<a name="ln397">    int min, max;</a>
<a name="ln398"> </a>
<a name="ln399">    gchar *module = g_strdup(dt_iop_get_localized_name(operation));</a>
<a name="ln400">    if(module == NULL) module = g_strdup(dt_lib_get_localized_name(operation));</a>
<a name="ln401">    if(module == NULL) module = g_strdup(operation);</a>
<a name="ln402"> </a>
<a name="ln403">    if(iso_min == 0.0 &amp;&amp; iso_max == FLT_MAX)</a>
<a name="ln404">      iso = g_strdup(&quot;%&quot;);</a>
<a name="ln405">    else</a>
<a name="ln406">      iso = g_strdup_printf(&quot;%zu – %zu&quot;, (size_t)iso_min, (size_t)iso_max);</a>
<a name="ln407"> </a>
<a name="ln408">    min = 0, max = 0;</a>
<a name="ln409">    for(; min &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; exposure_min &gt; dt_gui_presets_exposure_value[min]; min++)</a>
<a name="ln410">      ;</a>
<a name="ln411">    for(; max &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; exposure_max &gt; dt_gui_presets_exposure_value[max]; max++)</a>
<a name="ln412">      ;</a>
<a name="ln413">    if(min == 0 &amp;&amp; max == dt_gui_presets_exposure_value_cnt - 1)</a>
<a name="ln414">      exposure = g_strdup(&quot;%&quot;);</a>
<a name="ln415">    else</a>
<a name="ln416">      exposure = g_strdup_printf(&quot;%s – %s&quot;, dt_gui_presets_exposure_value_str[min],</a>
<a name="ln417">                                 dt_gui_presets_exposure_value_str[max]);</a>
<a name="ln418"> </a>
<a name="ln419">    min = 0, max = 0;</a>
<a name="ln420">    for(; min &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; aperture_min &gt; dt_gui_presets_aperture_value[min]; min++)</a>
<a name="ln421">      ;</a>
<a name="ln422">    for(; max &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; aperture_max &gt; dt_gui_presets_aperture_value[max]; max++)</a>
<a name="ln423">      ;</a>
<a name="ln424">    if(min == 0 &amp;&amp; max == dt_gui_presets_aperture_value_cnt - 1)</a>
<a name="ln425">      aperture = g_strdup(&quot;%&quot;);</a>
<a name="ln426">    else</a>
<a name="ln427">      aperture = g_strdup_printf(&quot;%s – %s&quot;, dt_gui_presets_aperture_value_str[min],</a>
<a name="ln428">                                 dt_gui_presets_aperture_value_str[max]);</a>
<a name="ln429"> </a>
<a name="ln430">    if(focal_length_min == 0.0 &amp;&amp; focal_length_max == 1000.0)</a>
<a name="ln431">      focal_length = g_strdup(&quot;%&quot;);</a>
<a name="ln432">    else</a>
<a name="ln433">      focal_length = g_strdup_printf(&quot;%d – %d&quot;, focal_length_min, focal_length_max);</a>
<a name="ln434"> </a>
<a name="ln435">    if(g_strcmp0(last_module, operation) != 0)</a>
<a name="ln436">    {</a>
<a name="ln437">      gtk_tree_store_append(tree_model, &amp;iter, NULL);</a>
<a name="ln438">      gtk_tree_store_set(tree_model, &amp;iter, P_ROWID_COLUMN, 0, P_OPERATION_COLUMN, &quot;&quot;, P_MODULE_COLUMN,</a>
<a name="ln439">                         _(module), P_EDITABLE_COLUMN, NULL, P_NAME_COLUMN, &quot;&quot;, P_MODEL_COLUMN, &quot;&quot;,</a>
<a name="ln440">                         P_MAKER_COLUMN, &quot;&quot;, P_LENS_COLUMN, &quot;&quot;, P_ISO_COLUMN, &quot;&quot;, P_EXPOSURE_COLUMN, &quot;&quot;,</a>
<a name="ln441">                         P_APERTURE_COLUMN, &quot;&quot;, P_FOCAL_LENGTH_COLUMN, &quot;&quot;, P_AUTOAPPLY_COLUMN, NULL, -1);</a>
<a name="ln442">      g_free(last_module);</a>
<a name="ln443">      last_module = g_strdup(operation);</a>
<a name="ln444">      parent = iter;</a>
<a name="ln445">    }</a>
<a name="ln446"> </a>
<a name="ln447">    gtk_tree_store_append(tree_model, &amp;iter, &amp;parent);</a>
<a name="ln448">    gtk_tree_store_set(tree_model, &amp;iter, P_ROWID_COLUMN, rowid, P_OPERATION_COLUMN, operation,</a>
<a name="ln449">                       P_MODULE_COLUMN, &quot;&quot;, P_EDITABLE_COLUMN, writeprotect ? lock_pixbuf : NULL,</a>
<a name="ln450">                       P_NAME_COLUMN, name, P_MODEL_COLUMN, model, P_MAKER_COLUMN, maker, P_LENS_COLUMN, lens,</a>
<a name="ln451">                       P_ISO_COLUMN, iso, P_EXPOSURE_COLUMN, exposure, P_APERTURE_COLUMN, aperture,</a>
<a name="ln452">                       P_FOCAL_LENGTH_COLUMN, focal_length, P_AUTOAPPLY_COLUMN,</a>
<a name="ln453">                       autoapply ? check_pixbuf : NULL, -1);</a>
<a name="ln454"> </a>
<a name="ln455">    g_free(focal_length);</a>
<a name="ln456">    g_free(aperture);</a>
<a name="ln457">    g_free(exposure);</a>
<a name="ln458">    g_free(iso);</a>
<a name="ln459">    g_free(module);</a>
<a name="ln460">  }</a>
<a name="ln461">  g_free(last_module);</a>
<a name="ln462">  sqlite3_finalize(stmt);</a>
<a name="ln463"> </a>
<a name="ln464">  g_object_unref(lock_pixbuf);</a>
<a name="ln465">  cairo_surface_destroy(lock_cst);</a>
<a name="ln466">  g_object_unref(check_pixbuf);</a>
<a name="ln467">  cairo_surface_destroy(check_cst);</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">static void init_tab_presets(GtkWidget *book)</a>
<a name="ln471">{</a>
<a name="ln472">  GtkWidget *container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln473">  GtkWidget *scroll = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln474">  GtkWidget *tree = gtk_tree_view_new();</a>
<a name="ln475">  GtkTreeStore *model = gtk_tree_store_new(</a>
<a name="ln476">      P_N_COLUMNS, G_TYPE_INT /*rowid*/, G_TYPE_STRING /*operation*/, G_TYPE_STRING /*module*/,</a>
<a name="ln477">      GDK_TYPE_PIXBUF /*editable*/, G_TYPE_STRING /*name*/, G_TYPE_STRING /*model*/, G_TYPE_STRING /*maker*/,</a>
<a name="ln478">      G_TYPE_STRING /*lens*/, G_TYPE_STRING /*iso*/, G_TYPE_STRING /*exposure*/, G_TYPE_STRING /*aperture*/,</a>
<a name="ln479">      G_TYPE_STRING /*focal length*/, GDK_TYPE_PIXBUF /*auto*/);</a>
<a name="ln480">  GtkCellRenderer *renderer;</a>
<a name="ln481">  GtkTreeViewColumn *column;</a>
<a name="ln482"> </a>
<a name="ln483">  // Adding the outer container</a>
<a name="ln484">  gtk_notebook_append_page(GTK_NOTEBOOK(book), container, gtk_label_new(_(&quot;presets&quot;)));</a>
<a name="ln485"> </a>
<a name="ln486">  tree_insert_presets(model);</a>
<a name="ln487"> </a>
<a name="ln488">  // Setting a custom sort functions so expandable groups rise to the top</a>
<a name="ln489">  gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(model), P_MODULE_COLUMN, GTK_SORT_ASCENDING);</a>
<a name="ln490">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model), P_MODULE_COLUMN, compare_rows_presets, NULL, NULL);</a>
<a name="ln491"> </a>
<a name="ln492">  // Setting up the cell renderers</a>
<a name="ln493">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln494">  column = gtk_tree_view_column_new_with_attributes(_(&quot;module&quot;), renderer, &quot;text&quot;, P_MODULE_COLUMN, NULL);</a>
<a name="ln495">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln496"> </a>
<a name="ln497">  renderer = gtk_cell_renderer_pixbuf_new();</a>
<a name="ln498">  column = gtk_tree_view_column_new_with_attributes(&quot;&quot;, renderer, &quot;pixbuf&quot;, P_EDITABLE_COLUMN, NULL);</a>
<a name="ln499">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln500"> </a>
<a name="ln501">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln502">  column = gtk_tree_view_column_new_with_attributes(_(&quot;name&quot;), renderer, &quot;text&quot;, P_NAME_COLUMN, NULL);</a>
<a name="ln503">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln504"> </a>
<a name="ln505">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln506">  column = gtk_tree_view_column_new_with_attributes(_(&quot;model&quot;), renderer, &quot;text&quot;, P_MODEL_COLUMN, NULL);</a>
<a name="ln507">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln508"> </a>
<a name="ln509">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln510">  column = gtk_tree_view_column_new_with_attributes(_(&quot;maker&quot;), renderer, &quot;text&quot;, P_MAKER_COLUMN, NULL);</a>
<a name="ln511">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln512"> </a>
<a name="ln513">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln514">  column = gtk_tree_view_column_new_with_attributes(_(&quot;lens&quot;), renderer, &quot;text&quot;, P_LENS_COLUMN, NULL);</a>
<a name="ln515">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln516"> </a>
<a name="ln517">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln518">  column = gtk_tree_view_column_new_with_attributes(_(&quot;ISO&quot;), renderer, &quot;text&quot;, P_ISO_COLUMN, NULL);</a>
<a name="ln519">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln520"> </a>
<a name="ln521">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln522">  column = gtk_tree_view_column_new_with_attributes(_(&quot;exposure&quot;), renderer, &quot;text&quot;, P_EXPOSURE_COLUMN, NULL);</a>
<a name="ln523">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln524"> </a>
<a name="ln525">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln526">  column = gtk_tree_view_column_new_with_attributes(_(&quot;aperture&quot;), renderer, &quot;text&quot;, P_APERTURE_COLUMN, NULL);</a>
<a name="ln527">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln528"> </a>
<a name="ln529">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln530">  column = gtk_tree_view_column_new_with_attributes(_(&quot;focal length&quot;), renderer, &quot;text&quot;,</a>
<a name="ln531">                                                    P_FOCAL_LENGTH_COLUMN, NULL);</a>
<a name="ln532">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln533"> </a>
<a name="ln534">  renderer = gtk_cell_renderer_pixbuf_new();</a>
<a name="ln535">  column = gtk_tree_view_column_new_with_attributes(_(&quot;auto&quot;), renderer, &quot;pixbuf&quot;, P_AUTOAPPLY_COLUMN, NULL);</a>
<a name="ln536">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln537"> </a>
<a name="ln538">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln539">  gtk_box_pack_start(GTK_BOX(container), scroll, TRUE, TRUE, 0);</a>
<a name="ln540"> </a>
<a name="ln541">  // Adding the import/export buttons</a>
<a name="ln542">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln543"> </a>
<a name="ln544">  GtkWidget *button = gtk_button_new_with_label(C_(&quot;preferences&quot;, &quot;import&quot;));</a>
<a name="ln545">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln546">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_preset), (gpointer)model);</a>
<a name="ln547"> </a>
<a name="ln548">  gtk_box_pack_start(GTK_BOX(container), hbox, FALSE, FALSE, 0);</a>
<a name="ln549"> </a>
<a name="ln550">  // Attaching treeview signals</a>
<a name="ln551"> </a>
<a name="ln552">  // row-activated either expands/collapses a row or activates editing</a>
<a name="ln553">  g_signal_connect(G_OBJECT(tree), &quot;row-activated&quot;, G_CALLBACK(tree_row_activated_presets), NULL);</a>
<a name="ln554"> </a>
<a name="ln555">  // A keypress may delete preset</a>
<a name="ln556">  g_signal_connect(G_OBJECT(tree), &quot;key-press-event&quot;, G_CALLBACK(tree_key_press_presets), (gpointer)model);</a>
<a name="ln557"> </a>
<a name="ln558">  // Setting up the search functionality</a>
<a name="ln559">  gtk_tree_view_set_search_column(GTK_TREE_VIEW(tree), P_NAME_COLUMN);</a>
<a name="ln560">  gtk_tree_view_set_enable_search(GTK_TREE_VIEW(tree), TRUE);</a>
<a name="ln561"> </a>
<a name="ln562">  // Attaching the model to the treeview</a>
<a name="ln563">  gtk_tree_view_set_model(GTK_TREE_VIEW(tree), GTK_TREE_MODEL(model));</a>
<a name="ln564"> </a>
<a name="ln565">  // Adding the treeview to its containers</a>
<a name="ln566">  gtk_container_add(GTK_CONTAINER(scroll), tree);</a>
<a name="ln567">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln568"> </a>
<a name="ln569">  g_object_unref(G_OBJECT(model));</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">static void init_tab_accels(GtkWidget *book)</a>
<a name="ln573">{</a>
<a name="ln574">  GtkWidget *container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln575">  GtkWidget *scroll = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln576">  GtkWidget *tree = gtk_tree_view_new();</a>
<a name="ln577">  GtkWidget *button;</a>
<a name="ln578">  GtkWidget *hbox;</a>
<a name="ln579">  GtkTreeStore *model = gtk_tree_store_new(A_N_COLUMNS, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);</a>
<a name="ln580">  GtkCellRenderer *renderer;</a>
<a name="ln581">  GtkTreeViewColumn *column;</a>
<a name="ln582"> </a>
<a name="ln583">  // Adding the outer container</a>
<a name="ln584">  gtk_notebook_append_page(GTK_NOTEBOOK(book), container, gtk_label_new(_(&quot;shortcuts&quot;)));</a>
<a name="ln585"> </a>
<a name="ln586">  // Building the accelerator tree</a>
<a name="ln587">  g_slist_foreach(darktable.control-&gt;accelerator_list, tree_insert_accel, (gpointer)model);</a>
<a name="ln588"> </a>
<a name="ln589">  // Setting a custom sort functions so expandable groups rise to the top</a>
<a name="ln590">  gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(model), A_TRANS_COLUMN, GTK_SORT_ASCENDING);</a>
<a name="ln591">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model), A_TRANS_COLUMN, compare_rows_accels, NULL, NULL);</a>
<a name="ln592"> </a>
<a name="ln593">  // Setting up the cell renderers</a>
<a name="ln594">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln595">  column = gtk_tree_view_column_new_with_attributes(_(&quot;shortcut&quot;), renderer, &quot;text&quot;, A_TRANS_COLUMN, NULL);</a>
<a name="ln596">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln597"> </a>
<a name="ln598">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln599">  column = gtk_tree_view_column_new_with_attributes(_(&quot;binding&quot;), renderer, &quot;text&quot;, A_BINDING_COLUMN, NULL);</a>
<a name="ln600">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln601"> </a>
<a name="ln602">  // Attaching treeview signals</a>
<a name="ln603"> </a>
<a name="ln604">  // row-activated either expands/collapses a row or activates remapping</a>
<a name="ln605">  g_signal_connect(G_OBJECT(tree), &quot;row-activated&quot;, G_CALLBACK(tree_row_activated_accels), NULL);</a>
<a name="ln606"> </a>
<a name="ln607">  // A selection change will cancel a currently active remapping</a>
<a name="ln608">  g_signal_connect(G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(tree))), &quot;changed&quot;,</a>
<a name="ln609">                   G_CALLBACK(tree_selection_changed), NULL);</a>
<a name="ln610"> </a>
<a name="ln611">  // A keypress may remap an accel or delete one</a>
<a name="ln612">  g_signal_connect(G_OBJECT(tree), &quot;key-press-event&quot;, G_CALLBACK(tree_key_press), (gpointer)model);</a>
<a name="ln613"> </a>
<a name="ln614">  // Setting up the search functionality</a>
<a name="ln615">  gtk_tree_view_set_search_column(GTK_TREE_VIEW(tree), A_TRANS_COLUMN);</a>
<a name="ln616">  gtk_tree_view_set_search_equal_func(GTK_TREE_VIEW(tree), prefix_search, NULL, NULL);</a>
<a name="ln617">  gtk_tree_view_set_enable_search(GTK_TREE_VIEW(tree), TRUE);</a>
<a name="ln618"> </a>
<a name="ln619">  // Attaching the model to the treeview</a>
<a name="ln620">  gtk_tree_view_set_model(GTK_TREE_VIEW(tree), GTK_TREE_MODEL(model));</a>
<a name="ln621"> </a>
<a name="ln622">  // Adding the treeview to its containers</a>
<a name="ln623">  gtk_container_add(GTK_CONTAINER(scroll), tree);</a>
<a name="ln624">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln625">  gtk_box_pack_start(GTK_BOX(container), scroll, TRUE, TRUE, 0);</a>
<a name="ln626"> </a>
<a name="ln627">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln628"> </a>
<a name="ln629">  // Adding the restore defaults button</a>
<a name="ln630">  button = gtk_button_new_with_label(C_(&quot;preferences&quot;, &quot;default&quot;));</a>
<a name="ln631">  gtk_box_pack_end(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln632">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(restore_defaults), NULL);</a>
<a name="ln633">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(update_accels_model), (gpointer)model);</a>
<a name="ln634"> </a>
<a name="ln635">  // Adding the import/export buttons</a>
<a name="ln636"> </a>
<a name="ln637">  button = gtk_button_new_with_label(C_(&quot;preferences&quot;, &quot;import&quot;));</a>
<a name="ln638">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln639">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_export), (gpointer)0);</a>
<a name="ln640">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(update_accels_model), (gpointer)model);</a>
<a name="ln641"> </a>
<a name="ln642">  button = gtk_button_new_with_label(_(&quot;export&quot;));</a>
<a name="ln643">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln644">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_export), (gpointer)1);</a>
<a name="ln645"> </a>
<a name="ln646">  gtk_box_pack_start(GTK_BOX(container), hbox, FALSE, FALSE, 0);</a>
<a name="ln647"> </a>
<a name="ln648">  g_object_unref(G_OBJECT(model));</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651">static void tree_insert_accel(gpointer accel_struct, gpointer model_link)</a>
<a name="ln652">{</a>
<a name="ln653">  GtkTreeStore *model = (GtkTreeStore *)model_link;</a>
<a name="ln654">  dt_accel_t *accel = (dt_accel_t *)accel_struct;</a>
<a name="ln655">  GtkAccelKey key;</a>
<a name="ln656"> </a>
<a name="ln657">  // Getting the first significant parts of the paths</a>
<a name="ln658">  const char *accel_path = accel-&gt;path;</a>
<a name="ln659">  const char *translated_path = accel-&gt;translated_path;</a>
<a name="ln660"> </a>
<a name="ln661">  /* if prefixed lets forward pointer */</a>
<a name="ln662">  if(!strncmp(accel_path, &quot;&lt;Darktable&gt;&quot;, strlen(&quot;&lt;Darktable&gt;&quot;)))</a>
<a name="ln663">  {</a>
<a name="ln664">    accel_path += strlen(&quot;&lt;Darktable&gt;&quot;) + 1;</a>
<a name="ln665">    translated_path += strlen(&quot;&lt;Darktable&gt;&quot;) + 1;</a>
<a name="ln666">  }</a>
<a name="ln667"> </a>
<a name="ln668">  // Getting the accelerator keys</a>
<a name="ln669">  gtk_accel_map_lookup_entry(accel-&gt;path, &amp;key);</a>
<a name="ln670"> </a>
<a name="ln671">  /* lets recurse path */</a>
<a name="ln672">  tree_insert_rec(model, NULL, accel_path, translated_path, key.accel_key, key.accel_mods);</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">static void tree_insert_rec(GtkTreeStore *model, GtkTreeIter *parent, const gchar *accel_path,</a>
<a name="ln676">                            const gchar *translated_path, guint accel_key, GdkModifierType accel_mods)</a>
<a name="ln677">{</a>
<a name="ln678">  int i;</a>
<a name="ln679">  gboolean found = FALSE;</a>
<a name="ln680">  gchar *val_str;</a>
<a name="ln681">  GtkTreeIter iter;</a>
<a name="ln682"> </a>
<a name="ln683">  /* if we are on end of path lets bail out of recursive insert */</a>
<a name="ln684">  if(*accel_path == 0) return;</a>
<a name="ln685"> </a>
<a name="ln686">  /* check if we are on a leaf or a branch  */</a>
<a name="ln687">  if(!g_strrstr(accel_path, &quot;/&quot;))</a>
<a name="ln688">  {</a>
<a name="ln689">    /* we are on a leaf lets add */</a>
<a name="ln690">    gchar *name = gtk_accelerator_get_label(accel_key, accel_mods);</a>
<a name="ln691">    gtk_tree_store_append(model, &amp;iter, parent);</a>
<a name="ln692">    gtk_tree_store_set(model, &amp;iter, A_ACCEL_COLUMN, accel_path, A_BINDING_COLUMN,</a>
<a name="ln693">                       g_dpgettext2(&quot;gtk30&quot;, &quot;keyboard label&quot;, name), A_TRANS_COLUMN, translated_path, -1);</a>
<a name="ln694">    g_free(name);</a>
<a name="ln695">  }</a>
<a name="ln696">  else</a>
<a name="ln697">  {</a>
<a name="ln698">    /* we are on a branch let's get the node name */</a>
<a name="ln699">    const gchar *end = g_strstr_len(accel_path, strlen(accel_path), &quot;/&quot;);</a>
<a name="ln700">    const gchar *trans_end = g_strstr_len(translated_path, strlen(translated_path), &quot;/&quot;);</a>
<a name="ln701">    gchar *node = g_strndup(accel_path, end - accel_path);</a>
<a name="ln702">    gchar *trans_node;</a>
<a name="ln703">    // safeguard against broken translations</a>
<a name="ln704">    if(trans_end)</a>
<a name="ln705">      trans_node = g_strndup(translated_path, trans_end - translated_path);</a>
<a name="ln706">    else</a>
<a name="ln707">    {</a>
<a name="ln708">      fprintf(stderr, &quot;error: translation mismatch: `%s' vs. `%s'\n&quot;, accel_path, translated_path);</a>
<a name="ln709">      trans_node = g_strdup(node);</a>
<a name="ln710">      translated_path = accel_path;</a>
<a name="ln711">    }</a>
<a name="ln712"> </a>
<a name="ln713">    /* search the tree if we already have a sibling with node name */</a>
<a name="ln714">    int siblings = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(model), parent);</a>
<a name="ln715">    for(i = 0; i &lt; siblings; i++)</a>
<a name="ln716">    {</a>
<a name="ln717">      gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(model), &amp;iter, parent, i);</a>
<a name="ln718">      gtk_tree_model_get(GTK_TREE_MODEL(model), &amp;iter, A_ACCEL_COLUMN, &amp;val_str, -1);</a>
<a name="ln719"> </a>
<a name="ln720">      /* do we match current sibling */</a>
<a name="ln721">      if(!strcmp(val_str, node)) found = TRUE;</a>
<a name="ln722"> </a>
<a name="ln723">      g_free(val_str);</a>
<a name="ln724"> </a>
<a name="ln725">      /* if we found a matching node let's break out */</a>
<a name="ln726">      if(found) break;</a>
<a name="ln727">    }</a>
<a name="ln728"> </a>
<a name="ln729">    /* if not found let's add a branch */</a>
<a name="ln730">    if(!found)</a>
<a name="ln731">    {</a>
<a name="ln732">      gtk_tree_store_append(model, &amp;iter, parent);</a>
<a name="ln733">      gtk_tree_store_set(model, &amp;iter, A_ACCEL_COLUMN, node, A_BINDING_COLUMN, &quot;&quot;, A_TRANS_COLUMN, trans_node,</a>
<a name="ln734">                         -1);</a>
<a name="ln735">    }</a>
<a name="ln736"> </a>
<a name="ln737">    /* recurse further down the path */</a>
<a name="ln738">    tree_insert_rec(model, &amp;iter, accel_path + strlen(node) + 1, translated_path + strlen(trans_node) + 1,</a>
<a name="ln739">                    accel_key, accel_mods);</a>
<a name="ln740"> </a>
<a name="ln741">    /* free up data */</a>
<a name="ln742">    g_free(node);</a>
<a name="ln743">    g_free(trans_node);</a>
<a name="ln744">  }</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">static void path_to_accel(GtkTreeModel *model, GtkTreePath *path, gchar *str, size_t str_len)</a>
<a name="ln748">{</a>
<a name="ln749">  gint depth;</a>
<a name="ln750">  gint *indices;</a>
<a name="ln751">  GtkTreeIter parent;</a>
<a name="ln752">  GtkTreeIter child;</a>
<a name="ln753">  gint i;</a>
<a name="ln754">  gchar *data_str;</a>
<a name="ln755"> </a>
<a name="ln756">  // Start out with the base &lt;Darktable&gt;</a>
<a name="ln757">  g_strlcpy(str, &quot;&lt;Darktable&gt;&quot;, str_len);</a>
<a name="ln758"> </a>
<a name="ln759">  // For each index in the path, append a '/' and that section of the path</a>
<a name="ln760">  depth = gtk_tree_path_get_depth(path);</a>
<a name="ln761">  indices = gtk_tree_path_get_indices(path);</a>
<a name="ln762">  for(i = 0; i &lt; depth; i++)</a>
<a name="ln763">  {</a>
<a name="ln764">    g_strlcat(str, &quot;/&quot;, str_len);</a>
<a name="ln765">    gtk_tree_model_iter_nth_child(model, &amp;child, i == 0 ? NULL : &amp;parent, indices[i]);</a>
<a name="ln766">    gtk_tree_model_get(model, &amp;child, A_ACCEL_COLUMN, &amp;data_str, -1);</a>
<a name="ln767">    g_strlcat(str, data_str, str_len);</a>
<a name="ln768">    g_free(data_str);</a>
<a name="ln769">    parent = child;</a>
<a name="ln770">  }</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">static void update_accels_model(gpointer widget, gpointer data)</a>
<a name="ln774">{</a>
<a name="ln775">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln776">  GtkTreeIter iter;</a>
<a name="ln777">  gchar path[256];</a>
<a name="ln778">  gchar *end;</a>
<a name="ln779">  gint i;</a>
<a name="ln780"> </a>
<a name="ln781">  g_strlcpy(path, &quot;&lt;Darktable&gt;&quot;, sizeof(path));</a>
<a name="ln782">  end = path + strlen(path);</a>
<a name="ln783"> </a>
<a name="ln784">  for(i = 0; i &lt; gtk_tree_model_iter_n_children(model, NULL); i++)</a>
<a name="ln785">  {</a>
<a name="ln786">    gtk_tree_model_iter_nth_child(model, &amp;iter, NULL, i);</a>
<a name="ln787">    update_accels_model_rec(model, &amp;iter, path, sizeof(path));</a>
<a name="ln788">    *end = '\0'; // Trimming the string back to the base for the next iteration</a>
<a name="ln789">  }</a>
<a name="ln790">}</a>
<a name="ln791"> </a>
<a name="ln792">static void update_accels_model_rec(GtkTreeModel *model, GtkTreeIter *parent, gchar *path, size_t path_len)</a>
<a name="ln793">{</a>
<a name="ln794">  GtkAccelKey key;</a>
<a name="ln795">  GtkTreeIter iter;</a>
<a name="ln796">  gchar *str_data;</a>
<a name="ln797">  gchar *end;</a>
<a name="ln798">  gint i;</a>
<a name="ln799"> </a>
<a name="ln800">  // First concatenating this part of the key</a>
<a name="ln801">  g_strlcat(path, &quot;/&quot;, path_len);</a>
<a name="ln802">  gtk_tree_model_get(model, parent, A_ACCEL_COLUMN, &amp;str_data, -1);</a>
<a name="ln803">  g_strlcat(path, str_data, path_len);</a>
<a name="ln804">  g_free(str_data);</a>
<a name="ln805"> </a>
<a name="ln806">  if(gtk_tree_model_iter_has_child(model, parent))</a>
<a name="ln807">  {</a>
<a name="ln808">    // Branch node, carry on with recursion</a>
<a name="ln809">    end = path + strlen(path);</a>
<a name="ln810"> </a>
<a name="ln811">    for(i = 0; i &lt; gtk_tree_model_iter_n_children(model, parent); i++)</a>
<a name="ln812">    {</a>
<a name="ln813">      gtk_tree_model_iter_nth_child(model, &amp;iter, parent, i);</a>
<a name="ln814">      update_accels_model_rec(model, &amp;iter, path, path_len);</a>
<a name="ln815">      *end = '\0';</a>
<a name="ln816">    }</a>
<a name="ln817">  }</a>
<a name="ln818">  else</a>
<a name="ln819">  {</a>
<a name="ln820">    // Leaf node, update the text</a>
<a name="ln821"> </a>
<a name="ln822">    gtk_accel_map_lookup_entry(path, &amp;key);</a>
<a name="ln823">    gchar *name = gtk_accelerator_get_label(key.accel_key, key.accel_mods);</a>
<a name="ln824">    gtk_tree_store_set(GTK_TREE_STORE(model), parent, A_BINDING_COLUMN, name, -1);</a>
<a name="ln825">    g_free(name);</a>
<a name="ln826">  }</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829">static void delete_matching_accels(gpointer current, gpointer mapped)</a>
<a name="ln830">{</a>
<a name="ln831">  const dt_accel_t *current_accel = (dt_accel_t *)current;</a>
<a name="ln832">  const dt_accel_t *mapped_accel = (dt_accel_t *)mapped;</a>
<a name="ln833">  GtkAccelKey current_key;</a>
<a name="ln834">  GtkAccelKey mapped_key;</a>
<a name="ln835"> </a>
<a name="ln836">  // Make sure we're not deleting the key we just remapped</a>
<a name="ln837">  if(!strcmp(current_accel-&gt;path, mapped_accel-&gt;path)) return;</a>
<a name="ln838"> </a>
<a name="ln839">  // Finding the relevant keyboard shortcuts</a>
<a name="ln840">  gtk_accel_map_lookup_entry(current_accel-&gt;path, &amp;current_key);</a>
<a name="ln841">  gtk_accel_map_lookup_entry(mapped_accel-&gt;path, &amp;mapped_key);</a>
<a name="ln842"> </a>
<a name="ln843">  if(current_key.accel_key == mapped_key.accel_key                 // Key code matches</a>
<a name="ln844">     &amp;&amp; current_key.accel_mods == mapped_key.accel_mods            // Key state matches</a>
<a name="ln845">     &amp;&amp; !(current_accel-&gt;local &amp;&amp; mapped_accel-&gt;local              // Not both local to</a>
<a name="ln846">          &amp;&amp; strcmp(current_accel-&gt;module, mapped_accel-&gt;module))</a>
<a name="ln847">     &amp;&amp; (current_accel-&gt;views &amp; mapped_accel-&gt;views) != 0) // diff mods</a>
<a name="ln848">    gtk_accel_map_change_entry(current_accel-&gt;path, 0, 0, TRUE);</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851">static gint _accelcmp(gconstpointer a, gconstpointer b)</a>
<a name="ln852">{</a>
<a name="ln853">  return (gint)(strcmp(((dt_accel_t *)a)-&gt;path, ((dt_accel_t *)b)-&gt;path));</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">// TODO: remember which sections were collapsed/expanded and where the view was scrolled to and restore that</a>
<a name="ln857">// after editing is done</a>
<a name="ln858">//      Alternative: change edit_preset_response to not clear+refill the tree, but to update the single row</a>
<a name="ln859">//      which changed.</a>
<a name="ln860">static void tree_row_activated_presets(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln861">                                       gpointer data)</a>
<a name="ln862">{</a>
<a name="ln863">  GtkTreeIter iter;</a>
<a name="ln864">  GtkTreeModel *model = gtk_tree_view_get_model(tree);</a>
<a name="ln865"> </a>
<a name="ln866">  gtk_tree_model_get_iter(model, &amp;iter, path);</a>
<a name="ln867"> </a>
<a name="ln868">  if(gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln869">  {</a>
<a name="ln870">    // For branch nodes, toggle expansion on activation</a>
<a name="ln871">    if(gtk_tree_view_row_expanded(tree, path))</a>
<a name="ln872">      gtk_tree_view_collapse_row(tree, path);</a>
<a name="ln873">    else</a>
<a name="ln874">      gtk_tree_view_expand_row(tree, path, FALSE);</a>
<a name="ln875">  }</a>
<a name="ln876">  else</a>
<a name="ln877">  {</a>
<a name="ln878">    // For leaf nodes, open editing window if the preset is not writeprotected</a>
<a name="ln879">    gint rowid;</a>
<a name="ln880">    gchar *name, *operation;</a>
<a name="ln881">    GdkPixbuf *editable;</a>
<a name="ln882">    gtk_tree_model_get(model, &amp;iter, P_ROWID_COLUMN, &amp;rowid, P_NAME_COLUMN, &amp;name, P_OPERATION_COLUMN,</a>
<a name="ln883">                       &amp;operation, P_EDITABLE_COLUMN, &amp;editable, -1);</a>
<a name="ln884">    if(editable == NULL)</a>
<a name="ln885">      edit_preset(tree, rowid, name, operation);</a>
<a name="ln886">    else</a>
<a name="ln887">      g_object_unref(editable);</a>
<a name="ln888">    g_free(name);</a>
<a name="ln889">    g_free(operation);</a>
<a name="ln890">  }</a>
<a name="ln891">}</a>
<a name="ln892"> </a>
<a name="ln893">static void tree_row_activated_accels(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln894">                                      gpointer data)</a>
<a name="ln895">{</a>
<a name="ln896">  GtkTreeIter iter;</a>
<a name="ln897">  GtkTreeModel *model = gtk_tree_view_get_model(tree);</a>
<a name="ln898"> </a>
<a name="ln899">  static gchar accel_path[256];</a>
<a name="ln900"> </a>
<a name="ln901">  gtk_tree_model_get_iter(model, &amp;iter, path);</a>
<a name="ln902"> </a>
<a name="ln903">  if(gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln904">  {</a>
<a name="ln905">    // For branch nodes, toggle expansion on activation</a>
<a name="ln906">    if(gtk_tree_view_row_expanded(tree, path))</a>
<a name="ln907">      gtk_tree_view_collapse_row(tree, path);</a>
<a name="ln908">    else</a>
<a name="ln909">      gtk_tree_view_expand_row(tree, path, FALSE);</a>
<a name="ln910">  }</a>
<a name="ln911">  else</a>
<a name="ln912">  {</a>
<a name="ln913">    // For leaf nodes, enter remapping mode</a>
<a name="ln914"> </a>
<a name="ln915">    // Assembling the full accelerator path</a>
<a name="ln916">    path_to_accel(model, path, accel_path, sizeof(accel_path));</a>
<a name="ln917"> </a>
<a name="ln918">    // Setting the notification text</a>
<a name="ln919">    gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, A_BINDING_COLUMN, _(&quot;press key combination to remap...&quot;),</a>
<a name="ln920">                       -1);</a>
<a name="ln921"> </a>
<a name="ln922">    // Activating remapping</a>
<a name="ln923">    darktable.control-&gt;accel_remap_str = accel_path;</a>
<a name="ln924">    darktable.control-&gt;accel_remap_path = gtk_tree_path_copy(path);</a>
<a name="ln925">  }</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">static void tree_selection_changed(GtkTreeSelection *selection, gpointer data)</a>
<a name="ln929">{</a>
<a name="ln930">  GtkTreeModel *model;</a>
<a name="ln931">  GtkTreeIter iter;</a>
<a name="ln932"> </a>
<a name="ln933">  GtkAccelKey key;</a>
<a name="ln934"> </a>
<a name="ln935">  // If remapping is currently activated, it needs to be deactivated</a>
<a name="ln936">  if(!darktable.control-&gt;accel_remap_str) return;</a>
<a name="ln937"> </a>
<a name="ln938">  model = gtk_tree_view_get_model(gtk_tree_selection_get_tree_view(selection));</a>
<a name="ln939">  gtk_tree_model_get_iter(model, &amp;iter, darktable.control-&gt;accel_remap_path);</a>
<a name="ln940"> </a>
<a name="ln941">  // Restoring the A_BINDING_COLUMN text</a>
<a name="ln942">  gtk_accel_map_lookup_entry(darktable.control-&gt;accel_remap_str, &amp;key);</a>
<a name="ln943">  gchar *name = gtk_accelerator_get_label(key.accel_key, key.accel_mods);</a>
<a name="ln944">  gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, A_BINDING_COLUMN, name, -1);</a>
<a name="ln945">  g_free(name);</a>
<a name="ln946"> </a>
<a name="ln947">  // Cleaning up the darktable.gui info</a>
<a name="ln948">  darktable.control-&gt;accel_remap_str = NULL;</a>
<a name="ln949">  gtk_tree_path_free(darktable.control-&gt;accel_remap_path);</a>
<a name="ln950">  darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953">static gboolean tree_key_press(GtkWidget *widget, GdkEventKey *event, gpointer data)</a>
<a name="ln954">{</a>
<a name="ln955">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln956">  GtkTreeIter iter;</a>
<a name="ln957">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(widget));</a>
<a name="ln958">  GtkTreePath *path;</a>
<a name="ln959">  GSList *remapped;</a>
<a name="ln960">  dt_accel_t query;</a>
<a name="ln961"> </a>
<a name="ln962">  gchar accel[256];</a>
<a name="ln963">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln964">  gchar accelpath[PATH_MAX] = { 0 };</a>
<a name="ln965"> </a>
<a name="ln966">  // We can just ignore mod key presses outright</a>
<a name="ln967">  if(event-&gt;is_modifier) return FALSE;</a>
<a name="ln968"> </a>
<a name="ln969">  dt_loc_get_user_config_dir(datadir, sizeof(datadir));</a>
<a name="ln970">  snprintf(accelpath, sizeof(accelpath), &quot;%s/keyboardrc&quot;, datadir);</a>
<a name="ln971"> </a>
<a name="ln972">  // Otherwise, determine whether we're in remap mode or not</a>
<a name="ln973">  if(darktable.control-&gt;accel_remap_str)</a>
<a name="ln974">  {</a>
<a name="ln975">    // First locate the accel list entry</a>
<a name="ln976">    g_strlcpy(query.path, darktable.control-&gt;accel_remap_str, sizeof(query.path));</a>
<a name="ln977">    remapped = g_slist_find_custom(darktable.control-&gt;accelerator_list, (gpointer)&amp;query, _accelcmp);</a>
<a name="ln978">    const dt_accel_t *accel_current = (dt_accel_t *)remapped-&gt;data;</a>
<a name="ln979"> </a>
<a name="ln980">    // let's search for conflicts</a>
<a name="ln981">    dt_accel_t *accel_conflict = NULL;</a>
<a name="ln982">    GSList *l = darktable.control-&gt;accelerator_list;</a>
<a name="ln983">    while (l)</a>
<a name="ln984">    {</a>
<a name="ln985">      dt_accel_t *a = (dt_accel_t *)l-&gt;data;</a>
<a name="ln986">      GtkAccelKey key;</a>
<a name="ln987">      if (a != accel_current &amp;&amp; gtk_accel_map_lookup_entry(a-&gt;path, &amp;key))</a>
<a name="ln988">      {</a>
<a name="ln989">        if (key.accel_key == gdk_keyval_to_lower(event-&gt;keyval) &amp;&amp;</a>
<a name="ln990">            key.accel_mods == (event-&gt;state &amp; KEY_STATE_MASK) &amp;&amp;</a>
<a name="ln991">            !(a-&gt;local &amp;&amp; accel_current-&gt;local &amp;&amp; strcmp(a-&gt;module, accel_current-&gt;module)) &amp;&amp;</a>
<a name="ln992">            (a-&gt;views &amp; accel_current-&gt;views) != 0)</a>
<a name="ln993">        {</a>
<a name="ln994">          accel_conflict = a;</a>
<a name="ln995">          break;</a>
<a name="ln996">        }</a>
<a name="ln997">      }</a>
<a name="ln998">      l = g_slist_next(l);</a>
<a name="ln999">    }</a>
<a name="ln1000"> </a>
<a name="ln1001">    if(!accel_conflict)</a>
<a name="ln1002">    {</a>
<a name="ln1003">      // no conflict</a>
<a name="ln1004">      gtk_accel_map_change_entry(darktable.control-&gt;accel_remap_str, gdk_keyval_to_lower(event-&gt;keyval),</a>
<a name="ln1005">                                 event-&gt;state &amp; KEY_STATE_MASK, TRUE);</a>
<a name="ln1006">    }</a>
<a name="ln1007">    else</a>
<a name="ln1008">    {</a>
<a name="ln1009">      // we ask for confirmation</a>
<a name="ln1010">      GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1011">      gchar *accel_txt</a>
<a name="ln1012">          = gtk_accelerator_get_label(gdk_keyval_to_lower(event-&gt;keyval), event-&gt;state &amp; KEY_STATE_MASK);</a>
<a name="ln1013">      gchar txt[512] = { 0 };</a>
<a name="ln1014">      if(g_str_has_prefix(accel_conflict-&gt;translated_path, &quot;&lt;Darktable&gt;/&quot;))</a>
<a name="ln1015">        g_strlcpy(txt, accel_conflict-&gt;translated_path + 12, sizeof(txt));</a>
<a name="ln1016">      else</a>
<a name="ln1017">        g_strlcpy(txt, accel_conflict-&gt;translated_path, sizeof(txt));</a>
<a name="ln1018">      GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln1019">          GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1020">          _(&quot;%s accel is already mapped to\n%s.\ndo you want to replace it ?&quot;), accel_txt, txt);</a>
<a name="ln1021">      g_free(accel_txt);</a>
<a name="ln1022">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1023">      dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1024">#endif</a>
<a name="ln1025"> </a>
<a name="ln1026">      gtk_window_set_title(GTK_WINDOW(dialog), _(&quot;accel conflict&quot;));</a>
<a name="ln1027">      gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1028">      gtk_widget_destroy(dialog);</a>
<a name="ln1029">      if(res == GTK_RESPONSE_YES)</a>
<a name="ln1030">      {</a>
<a name="ln1031">        // Change the accel map entry</a>
<a name="ln1032">        if(gtk_accel_map_change_entry(darktable.control-&gt;accel_remap_str, gdk_keyval_to_lower(event-&gt;keyval),</a>
<a name="ln1033">                                      event-&gt;state &amp; KEY_STATE_MASK, TRUE))</a>
<a name="ln1034">        {</a>
<a name="ln1035">          // Then remove conflicts</a>
<a name="ln1036">          g_slist_foreach(darktable.control-&gt;accelerator_list, delete_matching_accels, (gpointer)(accel_current));</a>
<a name="ln1037">        }</a>
<a name="ln1038">      }</a>
<a name="ln1039">    }</a>
<a name="ln1040"> </a>
<a name="ln1041">    // Then update the text in the A_BINDING_COLUMN of each row</a>
<a name="ln1042">    update_accels_model(NULL, model);</a>
<a name="ln1043"> </a>
<a name="ln1044">    // Finally clear the remap state</a>
<a name="ln1045">    darktable.control-&gt;accel_remap_str = NULL;</a>
<a name="ln1046">    gtk_tree_path_free(darktable.control-&gt;accel_remap_path);</a>
<a name="ln1047">    darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln1048"> </a>
<a name="ln1049">    // Save the changed keybindings</a>
<a name="ln1050">    gtk_accel_map_save(accelpath);</a>
<a name="ln1051"> </a>
<a name="ln1052">    return TRUE;</a>
<a name="ln1053">  }</a>
<a name="ln1054">  else if(event-&gt;keyval == GDK_KEY_BackSpace)</a>
<a name="ln1055">  {</a>
<a name="ln1056">    // If a leaf node is selected, clear that accelerator</a>
<a name="ln1057"> </a>
<a name="ln1058">    // If nothing is selected, or branch node selected, just return</a>
<a name="ln1059">    if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)</a>
<a name="ln1060">       || gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln1061">      return FALSE;</a>
<a name="ln1062"> </a>
<a name="ln1063">    // Otherwise, construct the proper accelerator path and delete its entry</a>
<a name="ln1064">    g_strlcpy(accel, &quot;&lt;Darktable&gt;&quot;, sizeof(accel));</a>
<a name="ln1065">    path = gtk_tree_model_get_path(model, &amp;iter);</a>
<a name="ln1066">    path_to_accel(model, path, accel, sizeof(accel));</a>
<a name="ln1067">    gtk_tree_path_free(path);</a>
<a name="ln1068"> </a>
<a name="ln1069">    gtk_accel_map_change_entry(accel, 0, 0, TRUE);</a>
<a name="ln1070">    update_accels_model(NULL, model);</a>
<a name="ln1071"> </a>
<a name="ln1072">    // Saving the changed bindings</a>
<a name="ln1073">    gtk_accel_map_save(accelpath);</a>
<a name="ln1074"> </a>
<a name="ln1075">    return TRUE;</a>
<a name="ln1076">  }</a>
<a name="ln1077">  else</a>
<a name="ln1078">  {</a>
<a name="ln1079">    return FALSE;</a>
<a name="ln1080">  }</a>
<a name="ln1081">}</a>
<a name="ln1082"> </a>
<a name="ln1083">static gboolean tree_key_press_presets(GtkWidget *widget, GdkEventKey *event, gpointer data)</a>
<a name="ln1084">{</a>
<a name="ln1085"> </a>
<a name="ln1086">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln1087">  GtkTreeIter iter;</a>
<a name="ln1088">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(widget));</a>
<a name="ln1089"> </a>
<a name="ln1090">  // We can just ignore mod key presses outright</a>
<a name="ln1091">  if(event-&gt;is_modifier) return FALSE;</a>
<a name="ln1092"> </a>
<a name="ln1093">  if(event-&gt;keyval == GDK_KEY_Delete || event-&gt;keyval == GDK_KEY_BackSpace)</a>
<a name="ln1094">  {</a>
<a name="ln1095">    // If a leaf node is selected, delete that preset</a>
<a name="ln1096"> </a>
<a name="ln1097">    // If nothing is selected, or branch node selected, just return</a>
<a name="ln1098">    if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)</a>
<a name="ln1099">       || gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln1100">      return FALSE;</a>
<a name="ln1101"> </a>
<a name="ln1102">    // For leaf nodes, open delete confirmation window if the preset is not writeprotected</a>
<a name="ln1103">    gint rowid;</a>
<a name="ln1104">    gchar *name;</a>
<a name="ln1105">    GdkPixbuf *editable;</a>
<a name="ln1106">    gtk_tree_model_get(model, &amp;iter, P_ROWID_COLUMN, &amp;rowid, P_NAME_COLUMN, &amp;name, P_EDITABLE_COLUMN,</a>
<a name="ln1107">                       &amp;editable, -1);</a>
<a name="ln1108">    if(editable == NULL)</a>
<a name="ln1109">    {</a>
<a name="ln1110">      sqlite3_stmt *stmt;</a>
<a name="ln1111"> </a>
<a name="ln1112">      GtkWidget *window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1113">      GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(window), GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln1114">                                                 GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1115">                                                 _(&quot;do you really want to delete the preset `%s'?&quot;), name);</a>
<a name="ln1116">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1117">      dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1118">#endif</a>
<a name="ln1119">      gtk_window_set_title(GTK_WINDOW(dialog), _(&quot;delete preset?&quot;));</a>
<a name="ln1120">      if(gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_YES)</a>
<a name="ln1121">      {</a>
<a name="ln1122">        // TODO: remove accel</a>
<a name="ln1123">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1124">                                    &quot;DELETE FROM data.presets WHERE rowid=?1 AND writeprotect=0&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1125">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, rowid);</a>
<a name="ln1126">        sqlite3_step(stmt);</a>
<a name="ln1127">        sqlite3_finalize(stmt);</a>
<a name="ln1128">        GtkTreeStore *tree_store = GTK_TREE_STORE(model);</a>
<a name="ln1129">        gtk_tree_store_clear(tree_store);</a>
<a name="ln1130">        tree_insert_presets(tree_store);</a>
<a name="ln1131">      }</a>
<a name="ln1132">      gtk_widget_destroy(dialog);</a>
<a name="ln1133">    }</a>
<a name="ln1134">    else</a>
<a name="ln1135">      g_object_unref(editable);</a>
<a name="ln1136">    g_free(name);</a>
<a name="ln1137"> </a>
<a name="ln1138">    return TRUE;</a>
<a name="ln1139">  }</a>
<a name="ln1140">  else</a>
<a name="ln1141">  {</a>
<a name="ln1142">    return FALSE;</a>
<a name="ln1143">  }</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146">static void import_export(GtkButton *button, gpointer data)</a>
<a name="ln1147">{</a>
<a name="ln1148">  GtkWidget *chooser;</a>
<a name="ln1149">  gchar confdir[PATH_MAX] = { 0 };</a>
<a name="ln1150">  gchar accelpath[PATH_MAX] = { 0 };</a>
<a name="ln1151"> </a>
<a name="ln1152">  if(data)</a>
<a name="ln1153">  {</a>
<a name="ln1154">    // Non-zero value indicates export</a>
<a name="ln1155">    chooser = gtk_file_chooser_dialog_new(_(&quot;select file to export&quot;), NULL, GTK_FILE_CHOOSER_ACTION_SAVE,</a>
<a name="ln1156">                                          _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL, _(&quot;_save&quot;), GTK_RESPONSE_ACCEPT,</a>
<a name="ln1157">                                          NULL);</a>
<a name="ln1158">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1159">    dt_osx_disallow_fullscreen(chooser);</a>
<a name="ln1160">#endif</a>
<a name="ln1161">    gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(chooser), TRUE);</a>
<a name="ln1162">    gchar *exported_path = dt_conf_get_string(&quot;ui_last/exported_path&quot;);</a>
<a name="ln1163">    if(exported_path != NULL)</a>
<a name="ln1164">    {</a>
<a name="ln1165">      gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), exported_path);</a>
<a name="ln1166">      g_free(exported_path);</a>
<a name="ln1167">    }</a>
<a name="ln1168">    gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(chooser), &quot;keyboardrc&quot;);</a>
<a name="ln1169">    if(gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1170">    {</a>
<a name="ln1171">      gtk_accel_map_save(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)));</a>
<a name="ln1172">      gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(chooser));</a>
<a name="ln1173">      dt_conf_set_string(&quot;ui_last/export_path&quot;, folder);</a>
<a name="ln1174">      g_free(folder);</a>
<a name="ln1175">    }</a>
<a name="ln1176">    gtk_widget_destroy(chooser);</a>
<a name="ln1177">  }</a>
<a name="ln1178">  else</a>
<a name="ln1179">  {</a>
<a name="ln1180">    // Zero value indicates import</a>
<a name="ln1181">    chooser = gtk_file_chooser_dialog_new(_(&quot;select file to import&quot;), NULL, GTK_FILE_CHOOSER_ACTION_OPEN,</a>
<a name="ln1182">                                          _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT,</a>
<a name="ln1183">                                          NULL);</a>
<a name="ln1184">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1185">    dt_osx_disallow_fullscreen(chooser);</a>
<a name="ln1186">#endif</a>
<a name="ln1187"> </a>
<a name="ln1188">    gchar *import_path = dt_conf_get_string(&quot;ui_last/import_path&quot;);</a>
<a name="ln1189">    if(import_path != NULL)</a>
<a name="ln1190">    {</a>
<a name="ln1191">      gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), import_path);</a>
<a name="ln1192">      g_free(import_path);</a>
<a name="ln1193">    }</a>
<a name="ln1194">    if(gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1195">    {</a>
<a name="ln1196">      if(g_file_test(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)), G_FILE_TEST_EXISTS))</a>
<a name="ln1197">      {</a>
<a name="ln1198">        // Loading the file</a>
<a name="ln1199">        gtk_accel_map_load(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)));</a>
<a name="ln1200"> </a>
<a name="ln1201">        // Saving to the permanent keyboardrc</a>
<a name="ln1202">        dt_loc_get_user_config_dir(confdir, sizeof(confdir));</a>
<a name="ln1203">        snprintf(accelpath, sizeof(accelpath), &quot;%s/keyboardrc&quot;, confdir);</a>
<a name="ln1204">        gtk_accel_map_save(accelpath);</a>
<a name="ln1205"> </a>
<a name="ln1206">        gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(chooser));</a>
<a name="ln1207">        dt_conf_set_string(&quot;ui_last/import_path&quot;, folder);</a>
<a name="ln1208">        g_free(folder);</a>
<a name="ln1209">      }</a>
<a name="ln1210">    }</a>
<a name="ln1211">    gtk_widget_destroy(chooser);</a>
<a name="ln1212">  }</a>
<a name="ln1213">}</a>
<a name="ln1214"> </a>
<a name="ln1215">static void restore_defaults(GtkButton *button, gpointer data)</a>
<a name="ln1216">{</a>
<a name="ln1217">  GList *ops;</a>
<a name="ln1218">  dt_iop_module_so_t *op;</a>
<a name="ln1219">  gchar accelpath[256];</a>
<a name="ln1220">  gchar dir[PATH_MAX] = { 0 };</a>
<a name="ln1221">  gchar path[PATH_MAX] = { 0 };</a>
<a name="ln1222"> </a>
<a name="ln1223">  GtkWidget *message</a>
<a name="ln1224">      = gtk_message_dialog_new(NULL, GTK_DIALOG_MODAL, GTK_MESSAGE_WARNING, GTK_BUTTONS_OK_CANCEL,</a>
<a name="ln1225">                               _(&quot;are you sure you want to restore the default keybindings?  this will &quot;</a>
<a name="ln1226">                                 &quot;erase any modifications you have made.&quot;));</a>
<a name="ln1227">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1228">  dt_osx_disallow_fullscreen(message);</a>
<a name="ln1229">#endif</a>
<a name="ln1230">  if(gtk_dialog_run(GTK_DIALOG(message)) == GTK_RESPONSE_OK)</a>
<a name="ln1231">  {</a>
<a name="ln1232">    // First load the default keybindings for immediate effect</a>
<a name="ln1233">    dt_loc_get_user_config_dir(dir, sizeof(dir));</a>
<a name="ln1234">    snprintf(path, sizeof(path), &quot;%s/keyboardrc_default&quot;, dir);</a>
<a name="ln1235">    gtk_accel_map_load(path);</a>
<a name="ln1236"> </a>
<a name="ln1237">    // Now deleting any iop show shortcuts</a>
<a name="ln1238">    ops = darktable.iop;</a>
<a name="ln1239">    while(ops)</a>
<a name="ln1240">    {</a>
<a name="ln1241">      op = (dt_iop_module_so_t *)ops-&gt;data;</a>
<a name="ln1242">      snprintf(accelpath, sizeof(accelpath), &quot;&lt;Darktable&gt;/darkroom/modules/%s/show&quot;, op-&gt;op);</a>
<a name="ln1243">      gtk_accel_map_change_entry(accelpath, 0, 0, TRUE);</a>
<a name="ln1244">      ops = g_list_next(ops);</a>
<a name="ln1245">    }</a>
<a name="ln1246"> </a>
<a name="ln1247">    // Then delete any changes to the user's keyboardrc so it gets reset</a>
<a name="ln1248">    // on next startup</a>
<a name="ln1249">    dt_loc_get_user_config_dir(dir, sizeof(dir));</a>
<a name="ln1250">    snprintf(path, sizeof(path), &quot;%s/keyboardrc&quot;, dir);</a>
<a name="ln1251"> </a>
<a name="ln1252">    GFile *gpath = g_file_new_for_path(path);</a>
<a name="ln1253">    g_file_delete(gpath, NULL, NULL);</a>
<a name="ln1254">    g_object_unref(gpath);</a>
<a name="ln1255">  }</a>
<a name="ln1256">  gtk_widget_destroy(message);</a>
<a name="ln1257">}</a>
<a name="ln1258"> </a>
<a name="ln1259">static void import_preset(GtkButton *button, gpointer data)</a>
<a name="ln1260">{</a>
<a name="ln1261">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln1262">  GtkWidget *chooser;</a>
<a name="ln1263"> </a>
<a name="ln1264">  // Zero value indicates import</a>
<a name="ln1265">  chooser = gtk_file_chooser_dialog_new(_(&quot;select preset to import&quot;), NULL, GTK_FILE_CHOOSER_ACTION_OPEN,</a>
<a name="ln1266">                                        _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT,</a>
<a name="ln1267">                                        NULL);</a>
<a name="ln1268">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1269">  dt_osx_disallow_fullscreen(chooser);</a>
<a name="ln1270">#endif</a>
<a name="ln1271"> </a>
<a name="ln1272">  gchar *import_path = dt_conf_get_string(&quot;ui_last/import_path&quot;);</a>
<a name="ln1273">  if(import_path != NULL)</a>
<a name="ln1274">  {</a>
<a name="ln1275">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), import_path);</a>
<a name="ln1276">    g_free(import_path);</a>
<a name="ln1277">  }</a>
<a name="ln1278">  if(gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1279">  {</a>
<a name="ln1280">    if(g_file_test(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)), G_FILE_TEST_EXISTS))</a>
<a name="ln1281">    {</a>
<a name="ln1282">      if(dt_presets_import_from_file(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser))))</a>
<a name="ln1283">      {</a>
<a name="ln1284">        dt_control_log(_(&quot;failed to import preset&quot;));</a>
<a name="ln1285">      }</a>
<a name="ln1286">      else</a>
<a name="ln1287">      {</a>
<a name="ln1288">        GtkTreeStore *tree_store = GTK_TREE_STORE(model);</a>
<a name="ln1289">        gtk_tree_store_clear(tree_store);</a>
<a name="ln1290">        tree_insert_presets(tree_store);</a>
<a name="ln1291">      }</a>
<a name="ln1292"> </a>
<a name="ln1293">      gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(chooser));</a>
<a name="ln1294">      dt_conf_set_string(&quot;ui_last/import_path&quot;, folder);</a>
<a name="ln1295">      g_free(folder);</a>
<a name="ln1296">    }</a>
<a name="ln1297">  }</a>
<a name="ln1298">  gtk_widget_destroy(chooser);</a>
<a name="ln1299">}</a>
<a name="ln1300"> </a>
<a name="ln1301">static gboolean prefix_search(GtkTreeModel *model, gint column, const gchar *key, GtkTreeIter *iter,</a>
<a name="ln1302">                              gpointer d)</a>
<a name="ln1303">{</a>
<a name="ln1304">  gchar *row_data;</a>
<a name="ln1305"> </a>
<a name="ln1306">  gtk_tree_model_get(model, iter, A_TRANS_COLUMN, &amp;row_data, -1);</a>
<a name="ln1307">  while(*key != '\0')</a>
<a name="ln1308">  {</a>
<a name="ln1309">    if(*row_data != *key) return TRUE;</a>
<a name="ln1310">    key++;</a>
<a name="ln1311">    row_data++;</a>
<a name="ln1312">  }</a>
<a name="ln1313">  return FALSE;</a>
<a name="ln1314">}</a>
<a name="ln1315"> </a>
<a name="ln1316">// Custom sort function for TreeModel entries for accels list</a>
<a name="ln1317">static gint compare_rows_accels(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data)</a>
<a name="ln1318">{</a>
<a name="ln1319">  gchar *a_text;</a>
<a name="ln1320">  gchar *b_text;</a>
<a name="ln1321"> </a>
<a name="ln1322">  // First prioritize branch nodes over leaves</a>
<a name="ln1323">  if(gtk_tree_model_iter_has_child(model, a) &amp;&amp; !gtk_tree_model_iter_has_child(model, b)) return -1;</a>
<a name="ln1324"> </a>
<a name="ln1325">  if(gtk_tree_model_iter_has_child(model, b) &amp;&amp; !gtk_tree_model_iter_has_child(model, a)) return 1;</a>
<a name="ln1326"> </a>
<a name="ln1327">  // Otherwise just return alphabetical order</a>
<a name="ln1328">  gtk_tree_model_get(model, a, A_TRANS_COLUMN, &amp;a_text, -1);</a>
<a name="ln1329">  gtk_tree_model_get(model, b, A_TRANS_COLUMN, &amp;b_text, -1);</a>
<a name="ln1330"> </a>
<a name="ln1331">  const int res = strcasecmp(a_text, b_text);</a>
<a name="ln1332"> </a>
<a name="ln1333">  g_free(a_text);</a>
<a name="ln1334">  g_free(b_text);</a>
<a name="ln1335"> </a>
<a name="ln1336">  return res;</a>
<a name="ln1337">}</a>
<a name="ln1338"> </a>
<a name="ln1339">// Custom sort function for TreeModel entries for presets list</a>
<a name="ln1340">static gint compare_rows_presets(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data)</a>
<a name="ln1341">{</a>
<a name="ln1342">  gchar *a_text;</a>
<a name="ln1343">  gchar *b_text;</a>
<a name="ln1344"> </a>
<a name="ln1345">  gtk_tree_model_get(model, a, P_MODULE_COLUMN, &amp;a_text, -1);</a>
<a name="ln1346">  gtk_tree_model_get(model, b, P_MODULE_COLUMN, &amp;b_text, -1);</a>
<a name="ln1347">  if(*a_text == '\0' &amp;&amp; *b_text == '\0')</a>
<a name="ln1348">  {</a>
<a name="ln1349">    g_free(a_text);</a>
<a name="ln1350">    g_free(b_text);</a>
<a name="ln1351"> </a>
<a name="ln1352">    gtk_tree_model_get(model, a, P_NAME_COLUMN, &amp;a_text, -1);</a>
<a name="ln1353">    gtk_tree_model_get(model, b, P_NAME_COLUMN, &amp;b_text, -1);</a>
<a name="ln1354">  }</a>
<a name="ln1355"> </a>
<a name="ln1356">  const int res = strcasecmp(a_text, b_text);</a>
<a name="ln1357"> </a>
<a name="ln1358">  g_free(a_text);</a>
<a name="ln1359">  g_free(b_text);</a>
<a name="ln1360"> </a>
<a name="ln1361">  return res;</a>
<a name="ln1362">}</a>
<a name="ln1363"> </a>
<a name="ln1364">// FIXME: Mostly c&amp;p from gui/presets.c</a>
<a name="ln1365">static void check_buttons_activated(GtkCheckButton *button, dt_gui_presets_edit_dialog_t *g)</a>
<a name="ln1366">{</a>
<a name="ln1367">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;autoapply))</a>
<a name="ln1368">     || gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;filter)))</a>
<a name="ln1369">  {</a>
<a name="ln1370">    gtk_widget_set_visible(GTK_WIDGET(g-&gt;details), TRUE);</a>
<a name="ln1371">    gtk_widget_set_no_show_all(GTK_WIDGET(g-&gt;details), FALSE);</a>
<a name="ln1372">    gtk_widget_show_all(GTK_WIDGET(g-&gt;details));</a>
<a name="ln1373">    gtk_widget_set_no_show_all(GTK_WIDGET(g-&gt;details), TRUE);</a>
<a name="ln1374">  }</a>
<a name="ln1375">  else</a>
<a name="ln1376">    gtk_widget_set_visible(GTK_WIDGET(g-&gt;details), FALSE);</a>
<a name="ln1377">}</a>
<a name="ln1378"> </a>
<a name="ln1379">static void edit_preset(GtkTreeView *tree, const gint rowid, const gchar *name, const gchar *module)</a>
<a name="ln1380">{</a>
<a name="ln1381">  GtkWidget *dialog;</a>
<a name="ln1382">  /* Create the widgets */</a>
<a name="ln1383">  char title[1024];</a>
<a name="ln1384">  snprintf(title, sizeof(title), _(&quot;edit `%s' for module `%s'&quot;), name, module);</a>
<a name="ln1385">  dialog = gtk_dialog_new_with_buttons(title, GTK_WINDOW(_preferences_dialog),</a>
<a name="ln1386">                                       GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,</a>
<a name="ln1387">                                       _(&quot;_save&quot;), GTK_RESPONSE_YES,</a>
<a name="ln1388">                                       _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL,</a>
<a name="ln1389">                                       _(&quot;_ok&quot;), GTK_RESPONSE_OK, NULL);</a>
<a name="ln1390">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1391">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1392">#endif</a>
<a name="ln1393">  GtkContainer *content_area = GTK_CONTAINER(gtk_dialog_get_content_area(GTK_DIALOG(dialog)));</a>
<a name="ln1394">  GtkBox *box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));</a>
<a name="ln1395">  gtk_container_add(content_area, GTK_WIDGET(box));</a>
<a name="ln1396">  GtkWidget *label;</a>
<a name="ln1397"> </a>
<a name="ln1398">  dt_gui_presets_edit_dialog_t *g</a>
<a name="ln1399">      = (dt_gui_presets_edit_dialog_t *)malloc(sizeof(dt_gui_presets_edit_dialog_t));</a>
<a name="ln1400">  g-&gt;rowid = rowid;</a>
<a name="ln1401">  g-&gt;tree = tree;</a>
<a name="ln1402">  g-&gt;name = GTK_LABEL(gtk_label_new(name));</a>
<a name="ln1403">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;name), FALSE, FALSE, 0);</a>
<a name="ln1404"> </a>
<a name="ln1405">  g-&gt;description = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1406">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;description), FALSE, FALSE, 0);</a>
<a name="ln1407">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;description), _(&quot;description or further information&quot;));</a>
<a name="ln1408"> </a>
<a name="ln1409">  g-&gt;autoapply</a>
<a name="ln1410">      = GTK_CHECK_BUTTON(gtk_check_button_new_with_label(_(&quot;auto apply this preset to matching images&quot;)));</a>
<a name="ln1411">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;autoapply), FALSE, FALSE, 0);</a>
<a name="ln1412">  g-&gt;filter</a>
<a name="ln1413">      = GTK_CHECK_BUTTON(gtk_check_button_new_with_label(_(&quot;only show this preset for matching images&quot;)));</a>
<a name="ln1414">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;filter),</a>
<a name="ln1415">                              _(&quot;be very careful with this option. this might be the last time you see your preset.&quot;));</a>
<a name="ln1416">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;filter), FALSE, FALSE, 0);</a>
<a name="ln1417">  g_signal_connect(G_OBJECT(g-&gt;autoapply), &quot;toggled&quot;, G_CALLBACK(check_buttons_activated), g);</a>
<a name="ln1418">  g_signal_connect(G_OBJECT(g-&gt;filter), &quot;toggled&quot;, G_CALLBACK(check_buttons_activated), g);</a>
<a name="ln1419"> </a>
<a name="ln1420">  int line = 0;</a>
<a name="ln1421">  g-&gt;details = gtk_grid_new();</a>
<a name="ln1422">  gtk_grid_set_row_spacing(GTK_GRID(g-&gt;details), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln1423">  gtk_grid_set_column_spacing(GTK_GRID(g-&gt;details), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln1424">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;details), FALSE, FALSE, 0);</a>
<a name="ln1425"> </a>
<a name="ln1426">  // model, maker, lens</a>
<a name="ln1427">  g-&gt;model = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1428">  /* xgettext:no-c-format */</a>
<a name="ln1429">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;model), _(&quot;string to match model (use % as wildcard)&quot;));</a>
<a name="ln1430">  label = gtk_label_new(_(&quot;model&quot;));</a>
<a name="ln1431">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1432">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1433">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;model), label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1434"> </a>
<a name="ln1435">  g-&gt;maker = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1436">  /* xgettext:no-c-format */</a>
<a name="ln1437">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;maker), _(&quot;string to match maker (use % as wildcard)&quot;));</a>
<a name="ln1438">  label = gtk_label_new(_(&quot;maker&quot;));</a>
<a name="ln1439">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1440">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1441">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;maker), label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1442"> </a>
<a name="ln1443">  g-&gt;lens = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1444">  /* xgettext:no-c-format */</a>
<a name="ln1445">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;lens), _(&quot;string to match lens (use % as wildcard)&quot;));</a>
<a name="ln1446">  label = gtk_label_new(_(&quot;lens&quot;));</a>
<a name="ln1447">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1448">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1449">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;lens), label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1450"> </a>
<a name="ln1451">  // iso</a>
<a name="ln1452">  label = gtk_label_new(_(&quot;ISO&quot;));</a>
<a name="ln1453">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1454">  g-&gt;iso_min = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, FLT_MAX, 100));</a>
<a name="ln1455">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;iso_min), _(&quot;minimum ISO value&quot;));</a>
<a name="ln1456">  gtk_spin_button_set_digits(g-&gt;iso_min, 0);</a>
<a name="ln1457">  g-&gt;iso_max = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, FLT_MAX, 100));</a>
<a name="ln1458">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;iso_max), _(&quot;maximum ISO value&quot;));</a>
<a name="ln1459">  gtk_spin_button_set_digits(g-&gt;iso_max, 0);</a>
<a name="ln1460">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1461">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;iso_min), label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1462">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;iso_max), GTK_WIDGET(g-&gt;iso_min), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1463"> </a>
<a name="ln1464">  // exposure</a>
<a name="ln1465">  label = gtk_label_new(_(&quot;exposure&quot;));</a>
<a name="ln1466">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1467">  g-&gt;exposure_min = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1468">  g-&gt;exposure_max = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1469">  gtk_widget_set_tooltip_text(g-&gt;exposure_min, _(&quot;minimum exposure time&quot;));</a>
<a name="ln1470">  gtk_widget_set_tooltip_text(g-&gt;exposure_max, _(&quot;maximum exposure time&quot;));</a>
<a name="ln1471">  for(int k = 0; k &lt; dt_gui_presets_exposure_value_cnt; k++)</a>
<a name="ln1472">    dt_bauhaus_combobox_add(g-&gt;exposure_min, dt_gui_presets_exposure_value_str[k]);</a>
<a name="ln1473">  for(int k = 0; k &lt; dt_gui_presets_exposure_value_cnt; k++)</a>
<a name="ln1474">    dt_bauhaus_combobox_add(g-&gt;exposure_max, dt_gui_presets_exposure_value_str[k]);</a>
<a name="ln1475">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1476">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;exposure_min, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1477">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;exposure_max, g-&gt;exposure_min, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1478"> </a>
<a name="ln1479">  // aperture</a>
<a name="ln1480">  label = gtk_label_new(_(&quot;aperture&quot;));</a>
<a name="ln1481">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1482">  g-&gt;aperture_min = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1483">  g-&gt;aperture_max = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1484">  gtk_widget_set_tooltip_text(g-&gt;aperture_min, _(&quot;minimum aperture value&quot;));</a>
<a name="ln1485">  gtk_widget_set_tooltip_text(g-&gt;aperture_max, _(&quot;maximum aperture value&quot;));</a>
<a name="ln1486">  for(int k = 0; k &lt; dt_gui_presets_aperture_value_cnt; k++)</a>
<a name="ln1487">    dt_bauhaus_combobox_add(g-&gt;aperture_min, dt_gui_presets_aperture_value_str[k]);</a>
<a name="ln1488">  for(int k = 0; k &lt; dt_gui_presets_aperture_value_cnt; k++)</a>
<a name="ln1489">    dt_bauhaus_combobox_add(g-&gt;aperture_max, dt_gui_presets_aperture_value_str[k]);</a>
<a name="ln1490">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1491">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;aperture_min, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1492">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;aperture_max, g-&gt;aperture_min, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1493"> </a>
<a name="ln1494">  // focal length</a>
<a name="ln1495">  label = gtk_label_new(_(&quot;focal length&quot;));</a>
<a name="ln1496">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1497">  g-&gt;focal_length_min = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, 1000, 10));</a>
<a name="ln1498">  gtk_spin_button_set_digits(g-&gt;focal_length_min, 0);</a>
<a name="ln1499">  g-&gt;focal_length_max = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, 1000, 10));</a>
<a name="ln1500">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;focal_length_min), _(&quot;minimum focal length&quot;));</a>
<a name="ln1501">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;focal_length_max), _(&quot;maximum focal length&quot;));</a>
<a name="ln1502">  gtk_spin_button_set_digits(g-&gt;focal_length_max, 0);</a>
<a name="ln1503">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1504">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;focal_length_min), label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1505">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;focal_length_max), GTK_WIDGET(g-&gt;focal_length_min), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1506">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;focal_length_min), TRUE);</a>
<a name="ln1507">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;focal_length_max), TRUE);</a>
<a name="ln1508"> </a>
<a name="ln1509">  // raw/hdr/ldr</a>
<a name="ln1510">  label = gtk_label_new(_(&quot;format&quot;));</a>
<a name="ln1511">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1512">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line, 1, 1);</a>
<a name="ln1513"> </a>
<a name="ln1514">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1515">  {</a>
<a name="ln1516">    g-&gt;format_btn[i] = gtk_check_button_new_with_label(_(dt_gui_presets_format_value_str[i]));</a>
<a name="ln1517">    gtk_grid_attach(GTK_GRID(g-&gt;details), g-&gt;format_btn[i], 1, line + i, 2, 1);</a>
<a name="ln1518">  }</a>
<a name="ln1519"> </a>
<a name="ln1520">  gtk_widget_set_no_show_all(GTK_WIDGET(g-&gt;details), TRUE);</a>
<a name="ln1521"> </a>
<a name="ln1522">  sqlite3_stmt *stmt;</a>
<a name="ln1523">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1524">                              &quot;SELECT description, model, maker, lens, iso_min, iso_max, exposure_min, &quot;</a>
<a name="ln1525">                              &quot;exposure_max, aperture_min, aperture_max, focal_length_min, focal_length_max, &quot;</a>
<a name="ln1526">                              &quot;autoapply, filter, format FROM data.presets WHERE rowid = ?1&quot;,</a>
<a name="ln1527">                              -1, &amp;stmt, NULL);</a>
<a name="ln1528">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, rowid);</a>
<a name="ln1529">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1530">  {</a>
<a name="ln1531">    gtk_entry_set_text(g-&gt;description, (const char *)sqlite3_column_text(stmt, 0));</a>
<a name="ln1532">    gtk_entry_set_text(g-&gt;model, (const char *)sqlite3_column_text(stmt, 1));</a>
<a name="ln1533">    gtk_entry_set_text(g-&gt;maker, (const char *)sqlite3_column_text(stmt, 2));</a>
<a name="ln1534">    gtk_entry_set_text(g-&gt;lens, (const char *)sqlite3_column_text(stmt, 3));</a>
<a name="ln1535">    gtk_spin_button_set_value(g-&gt;iso_min, sqlite3_column_double(stmt, 4));</a>
<a name="ln1536">    gtk_spin_button_set_value(g-&gt;iso_max, sqlite3_column_double(stmt, 5));</a>
<a name="ln1537"> </a>
<a name="ln1538">    float val = sqlite3_column_double(stmt, 6);</a>
<a name="ln1539">    int k = 0;</a>
<a name="ln1540">    for(; k &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; val &gt; dt_gui_presets_exposure_value[k]; k++)</a>
<a name="ln1541">      ;</a>
<a name="ln1542">    dt_bauhaus_combobox_set(g-&gt;exposure_min, k);</a>
<a name="ln1543">    val = sqlite3_column_double(stmt, 7);</a>
<a name="ln1544">    for(k = 0; k &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; val &gt; dt_gui_presets_exposure_value[k]; k++)</a>
<a name="ln1545">      ;</a>
<a name="ln1546">    dt_bauhaus_combobox_set(g-&gt;exposure_max, k);</a>
<a name="ln1547">    val = sqlite3_column_double(stmt, 8);</a>
<a name="ln1548">    for(k = 0; k &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; val &gt; dt_gui_presets_aperture_value[k]; k++)</a>
<a name="ln1549">      ;</a>
<a name="ln1550">    dt_bauhaus_combobox_set(g-&gt;aperture_min, k);</a>
<a name="ln1551">    val = sqlite3_column_double(stmt, 9);</a>
<a name="ln1552">    for(k = 0; k &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; val &gt; dt_gui_presets_aperture_value[k]; k++)</a>
<a name="ln1553">      ;</a>
<a name="ln1554">    dt_bauhaus_combobox_set(g-&gt;aperture_max, k);</a>
<a name="ln1555">    gtk_spin_button_set_value(g-&gt;focal_length_min, sqlite3_column_double(stmt, 10));</a>
<a name="ln1556">    gtk_spin_button_set_value(g-&gt;focal_length_max, sqlite3_column_double(stmt, 11));</a>
<a name="ln1557">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;autoapply), sqlite3_column_int(stmt, 12));</a>
<a name="ln1558">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;filter), sqlite3_column_int(stmt, 13));</a>
<a name="ln1559">    const int format = sqlite3_column_int(stmt, 14);</a>
<a name="ln1560">    for(k = 0; k &lt; 3; k++)</a>
<a name="ln1561">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;format_btn[k]), format &amp; (dt_gui_presets_format_flag[k]));</a>
<a name="ln1562">  }</a>
<a name="ln1563">  sqlite3_finalize(stmt);</a>
<a name="ln1564"> </a>
<a name="ln1565">  g_signal_connect(dialog, &quot;response&quot;, G_CALLBACK(edit_preset_response), g);</a>
<a name="ln1566">  gtk_widget_show_all(dialog);</a>
<a name="ln1567">}</a>
<a name="ln1568"> </a>
<a name="ln1569">static void edit_preset_response(GtkDialog *dialog, gint response_id, dt_gui_presets_edit_dialog_t *g)</a>
<a name="ln1570">{</a>
<a name="ln1571">  // commit all the user input fields</a>
<a name="ln1572">  if(response_id == GTK_RESPONSE_OK)</a>
<a name="ln1573">  {</a>
<a name="ln1574">    sqlite3_stmt *stmt;</a>
<a name="ln1575">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1576">                                &quot;UPDATE data.presets SET description = ?1, model = ?2, maker = ?3, lens = ?4, &quot;</a>
<a name="ln1577">                                &quot;iso_min = ?5, iso_max = ?6, exposure_min = ?7, exposure_max = ?8, &quot;</a>
<a name="ln1578">                                &quot;aperture_min = ?9, aperture_max = ?10, focal_length_min = ?11, &quot;</a>
<a name="ln1579">                                &quot;focal_length_max = ?12, autoapply = ?13, filter = ?14, def = 0, format = ?15 &quot;</a>
<a name="ln1580">                                &quot;WHERE rowid = ?16&quot;,</a>
<a name="ln1581">                                -1, &amp;stmt, NULL);</a>
<a name="ln1582">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, gtk_entry_get_text(g-&gt;description), -1, SQLITE_TRANSIENT);</a>
<a name="ln1583">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, gtk_entry_get_text(g-&gt;model), -1, SQLITE_TRANSIENT);</a>
<a name="ln1584">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 3, gtk_entry_get_text(g-&gt;maker), -1, SQLITE_TRANSIENT);</a>
<a name="ln1585">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, gtk_entry_get_text(g-&gt;lens), -1, SQLITE_TRANSIENT);</a>
<a name="ln1586">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 5, gtk_spin_button_get_value(g-&gt;iso_min));</a>
<a name="ln1587">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 6, gtk_spin_button_get_value(g-&gt;iso_max));</a>
<a name="ln1588">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 7,</a>
<a name="ln1589">                                 dt_gui_presets_exposure_value[dt_bauhaus_combobox_get(g-&gt;exposure_min)]);</a>
<a name="ln1590">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 8,</a>
<a name="ln1591">                                 dt_gui_presets_exposure_value[dt_bauhaus_combobox_get(g-&gt;exposure_max)]);</a>
<a name="ln1592">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 9,</a>
<a name="ln1593">                                 dt_gui_presets_aperture_value[dt_bauhaus_combobox_get(g-&gt;aperture_min)]);</a>
<a name="ln1594">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 10,</a>
<a name="ln1595">                                 dt_gui_presets_aperture_value[dt_bauhaus_combobox_get(g-&gt;aperture_max)]);</a>
<a name="ln1596">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 11, gtk_spin_button_get_value(g-&gt;focal_length_min));</a>
<a name="ln1597">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 12, gtk_spin_button_get_value(g-&gt;focal_length_max));</a>
<a name="ln1598">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 13, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;autoapply)));</a>
<a name="ln1599">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 14, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;filter)));</a>
<a name="ln1600">    int format = 0;</a>
<a name="ln1601">    for(int k = 0; k &lt; 3; k++)</a>
<a name="ln1602">      format += gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;format_btn[k])) * dt_gui_presets_format_flag[k];</a>
<a name="ln1603">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 15, format);</a>
<a name="ln1604">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 16, g-&gt;rowid);</a>
<a name="ln1605">    sqlite3_step(stmt);</a>
<a name="ln1606">    sqlite3_finalize(stmt);</a>
<a name="ln1607">  }</a>
<a name="ln1608">  else if(response_id == GTK_RESPONSE_YES)</a>
<a name="ln1609">  {</a>
<a name="ln1610">    const gchar *name = gtk_label_get_text(g-&gt;name);</a>
<a name="ln1611"> </a>
<a name="ln1612">    // ask for destination directory</a>
<a name="ln1613"> </a>
<a name="ln1614">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1615">    GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1616">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1617">      GTK_RESPONSE_CANCEL, _(&quot;_select as output destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1618">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1619">    dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1620">#endif</a>
<a name="ln1621"> </a>
<a name="ln1622">    // save if accepted</a>
<a name="ln1623"> </a>
<a name="ln1624">    if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1625">    {</a>
<a name="ln1626">      char *filedir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1627">      dt_presets_save_to_file(g-&gt;rowid, name, filedir);</a>
<a name="ln1628">      dt_control_log(_(&quot;preset %s was successfully saved&quot;), name);</a>
<a name="ln1629">      g_free(filedir);</a>
<a name="ln1630">    }</a>
<a name="ln1631"> </a>
<a name="ln1632">    gtk_widget_destroy(GTK_WIDGET(filechooser));</a>
<a name="ln1633">  }</a>
<a name="ln1634"> </a>
<a name="ln1635">  GtkTreeStore *tree_store = GTK_TREE_STORE(gtk_tree_view_get_model(g-&gt;tree));</a>
<a name="ln1636">  gtk_tree_store_clear(tree_store);</a>
<a name="ln1637">  tree_insert_presets(tree_store);</a>
<a name="ln1638"> </a>
<a name="ln1639">  gtk_widget_destroy(GTK_WIDGET(dialog));</a>
<a name="ln1640">  free(g);</a>
<a name="ln1641">}</a>
<a name="ln1642"> </a>
<a name="ln1643">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1644">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1645">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1400"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 1400, 1399.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
