
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  This file is part of darktable,</a>
<a name="ln3">  copyright (c) 2016 Ulrich Pegelow.</a>
<a name="ln4"> </a>
<a name="ln5">  darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">  GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#ifdef HAVE_CONFIG_H</a>
<a name="ln20">#include &quot;config.h&quot;</a>
<a name="ln21">#endif</a>
<a name="ln22">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln23">#include &quot;common/bilateral.h&quot;</a>
<a name="ln24">#include &quot;common/colorspaces_inline_conversions.h&quot;</a>
<a name="ln25">#include &quot;common/debug.h&quot;</a>
<a name="ln26">#include &quot;common/interpolation.h&quot;</a>
<a name="ln27">#include &quot;common/opencl.h&quot;</a>
<a name="ln28">#include &quot;control/control.h&quot;</a>
<a name="ln29">#include &quot;develop/develop.h&quot;</a>
<a name="ln30">#include &quot;develop/imageop.h&quot;</a>
<a name="ln31">#include &quot;develop/tiling.h&quot;</a>
<a name="ln32">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln33">#include &quot;dtgtk/resetlabel.h&quot;</a>
<a name="ln34">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln35">#include &quot;gui/draw.h&quot;</a>
<a name="ln36">#include &quot;gui/gtk.h&quot;</a>
<a name="ln37">#include &quot;gui/guides.h&quot;</a>
<a name="ln38">#include &quot;gui/presets.h&quot;</a>
<a name="ln39">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;assert.h&gt;</a>
<a name="ln42">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln43">#include &lt;inttypes.h&gt;</a>
<a name="ln44">#include &lt;math.h&gt;</a>
<a name="ln45">#include &lt;stdlib.h&gt;</a>
<a name="ln46">#include &lt;string.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">// Inspiration to this module comes from the program ShiftN (http://www.shiftn.de) by</a>
<a name="ln49">// Marcus Hebel.</a>
<a name="ln50"> </a>
<a name="ln51">// Thanks to Marcus for his support when implementing part of the ShiftN functionality</a>
<a name="ln52">// to darktable.</a>
<a name="ln53"> </a>
<a name="ln54">#define ROTATION_RANGE 10                   // allowed min/max default range for rotation parameter</a>
<a name="ln55">#define ROTATION_RANGE_SOFT 20              // allowed min/max range for rotation parameter with manual adjustment</a>
<a name="ln56">#define LENSSHIFT_RANGE 0.5                 // allowed min/max default range for lensshift parameters</a>
<a name="ln57">#define LENSSHIFT_RANGE_SOFT 1              // allowed min/max range for lensshift parameters with manual adjustment</a>
<a name="ln58">#define SHEAR_RANGE 0.2                     // allowed min/max range for shear parameter</a>
<a name="ln59">#define SHEAR_RANGE_SOFT 0.5                // allowed min/max range for shear parameter with manual adjustment</a>
<a name="ln60">#define MIN_LINE_LENGTH 5                   // the minimum length of a line in pixels to be regarded as relevant</a>
<a name="ln61">#define MAX_TANGENTIAL_DEVIATION 30         // by how many degrees a line may deviate from the +/-180 and +/-90 to be regarded as relevant</a>
<a name="ln62">#define LSD_SCALE 0.99                      // LSD: scaling factor for line detection</a>
<a name="ln63">#define LSD_SIGMA_SCALE 0.6                 // LSD: sigma for Gaussian filter is computed as sigma = sigma_scale/scale</a>
<a name="ln64">#define LSD_QUANT 2.0                       // LSD: bound to the quantization error on the gradient norm</a>
<a name="ln65">#define LSD_ANG_TH 22.5                     // LSD: gradient angle tolerance in degrees</a>
<a name="ln66">#define LSD_LOG_EPS 0.0                     // LSD: detection threshold: -log10(NFA) &gt; log_eps</a>
<a name="ln67">#define LSD_DENSITY_TH 0.7                  // LSD: minimal density of region points in rectangle</a>
<a name="ln68">#define LSD_N_BINS 1024                     // LSD: number of bins in pseudo-ordering of gradient modulus</a>
<a name="ln69">#define LSD_GAMMA 0.45                      // gamma correction to apply on raw images prior to line detection</a>
<a name="ln70">#define RANSAC_RUNS 400                     // how many iterations to run in ransac</a>
<a name="ln71">#define RANSAC_EPSILON 2                    // starting value for ransac epsilon (in -log10 units)</a>
<a name="ln72">#define RANSAC_EPSILON_STEP 1               // step size of epsilon optimization (log10 units)</a>
<a name="ln73">#define RANSAC_ELIMINATION_RATIO 60         // percentage of lines we try to eliminate as outliers</a>
<a name="ln74">#define RANSAC_OPTIMIZATION_STEPS 5         // home many steps to optimize epsilon</a>
<a name="ln75">#define RANSAC_OPTIMIZATION_DRY_RUNS 50     // how man runs per optimization steps</a>
<a name="ln76">#define RANSAC_HURDLE 5                     // hurdle rate: the number of lines below which we do a complete permutation instead of random sampling</a>
<a name="ln77">#define MINIMUM_FITLINES 4                  // minimum number of lines needed for automatic parameter fit</a>
<a name="ln78">#define NMS_EPSILON 1e-3                    // break criterion for Nelder-Mead simplex</a>
<a name="ln79">#define NMS_SCALE 1.0                       // scaling factor for Nelder-Mead simplex</a>
<a name="ln80">#define NMS_ITERATIONS 400                  // number of iterations for Nelder-Mead simplex</a>
<a name="ln81">#define NMS_CROP_EPSILON 100.0              // break criterion for Nelder-Mead simplex on crop fitting</a>
<a name="ln82">#define NMS_CROP_SCALE 0.5                  // scaling factor for Nelder-Mead simplex on crop fitting</a>
<a name="ln83">#define NMS_CROP_ITERATIONS 100             // number of iterations for Nelder-Mead simplex on crop fitting</a>
<a name="ln84">#define NMS_ALPHA 1.0                       // reflection coefficient for Nelder-Mead simplex</a>
<a name="ln85">#define NMS_BETA 0.5                        // contraction coefficient for Nelder-Mead simplex</a>
<a name="ln86">#define NMS_GAMMA 2.0                       // expansion coefficient for Nelder-Mead simplex</a>
<a name="ln87">#define DEFAULT_F_LENGTH 28.0               // focal length we assume if no exif data are available</a>
<a name="ln88"> </a>
<a name="ln89">// define to get debugging output</a>
<a name="ln90">#undef ASHIFT_DEBUG</a>
<a name="ln91"> </a>
<a name="ln92">#define SQR(a) ((a) * (a))</a>
<a name="ln93"> </a>
<a name="ln94">// For line detection we use the LSD algorithm as published by Rafael Grompone:</a>
<a name="ln95">//</a>
<a name="ln96">//  &quot;LSD: a Line Segment Detector&quot; by Rafael Grompone von Gioi,</a>
<a name="ln97">//  Jeremie Jakubowicz, Jean-Michel Morel, and Gregory Randall,</a>
<a name="ln98">//  Image Processing On Line, 2012. DOI:10.5201/ipol.2012.gjmr-lsd</a>
<a name="ln99">//  http://dx.doi.org/10.5201/ipol.2012.gjmr-lsd</a>
<a name="ln100">#include &quot;ashift_lsd.c&quot;</a>
<a name="ln101"> </a>
<a name="ln102">// For parameter optimization we are using the Nelder-Mead simplex method</a>
<a name="ln103">// implemented by Michael F. Hutt.</a>
<a name="ln104">#include &quot;ashift_nmsimplex.c&quot;</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">DT_MODULE_INTROSPECTION(4, dt_iop_ashift_params_t)</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110">const char *name()</a>
<a name="ln111">{</a>
<a name="ln112">  return _(&quot;perspective correction&quot;);</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">int flags()</a>
<a name="ln116">{</a>
<a name="ln117">  return IOP_FLAGS_ALLOW_TILING | IOP_FLAGS_TILING_FULL_ROI | IOP_FLAGS_ONE_INSTANCE;</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">int default_group()</a>
<a name="ln121">{</a>
<a name="ln122">  return IOP_GROUP_CORRECT;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">int operation_tags()</a>
<a name="ln126">{</a>
<a name="ln127">  return IOP_TAG_DISTORT;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">int operation_tags_filter()</a>
<a name="ln131">{</a>
<a name="ln132">  // switch off clipping and decoration, we want to see the full image.</a>
<a name="ln133">  return IOP_TAG_DECORATION | IOP_TAG_CLIPPING;</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">typedef enum dt_iop_ashift_homodir_t</a>
<a name="ln137">{</a>
<a name="ln138">  ASHIFT_HOMOGRAPH_FORWARD,</a>
<a name="ln139">  ASHIFT_HOMOGRAPH_INVERTED</a>
<a name="ln140">} dt_iop_ashift_homodir_t;</a>
<a name="ln141"> </a>
<a name="ln142">typedef enum dt_iop_ashift_linetype_t</a>
<a name="ln143">{</a>
<a name="ln144">  ASHIFT_LINE_IRRELEVANT   = 0,       // the line is found to be not interesting</a>
<a name="ln145">                                      // eg. too short, or not horizontal or vertical</a>
<a name="ln146">  ASHIFT_LINE_RELEVANT     = 1 &lt;&lt; 0,  // the line is relevant for us</a>
<a name="ln147">  ASHIFT_LINE_DIRVERT      = 1 &lt;&lt; 1,  // the line is (mostly) vertical, else (mostly) horizontal</a>
<a name="ln148">  ASHIFT_LINE_SELECTED     = 1 &lt;&lt; 2,  // the line is selected for fitting</a>
<a name="ln149">  ASHIFT_LINE_VERTICAL_NOT_SELECTED   = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_DIRVERT,</a>
<a name="ln150">  ASHIFT_LINE_HORIZONTAL_NOT_SELECTED = ASHIFT_LINE_RELEVANT,</a>
<a name="ln151">  ASHIFT_LINE_VERTICAL_SELECTED = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_DIRVERT | ASHIFT_LINE_SELECTED,</a>
<a name="ln152">  ASHIFT_LINE_HORIZONTAL_SELECTED = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED,</a>
<a name="ln153">  ASHIFT_LINE_MASK = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_DIRVERT | ASHIFT_LINE_SELECTED</a>
<a name="ln154">} dt_iop_ashift_linetype_t;</a>
<a name="ln155"> </a>
<a name="ln156">typedef enum dt_iop_ashift_linecolor_t</a>
<a name="ln157">{</a>
<a name="ln158">  ASHIFT_LINECOLOR_GREY    = 0,</a>
<a name="ln159">  ASHIFT_LINECOLOR_GREEN   = 1,</a>
<a name="ln160">  ASHIFT_LINECOLOR_RED     = 2,</a>
<a name="ln161">  ASHIFT_LINECOLOR_BLUE    = 3,</a>
<a name="ln162">  ASHIFT_LINECOLOR_YELLOW  = 4</a>
<a name="ln163">} dt_iop_ashift_linecolor_t;</a>
<a name="ln164"> </a>
<a name="ln165">typedef enum dt_iop_ashift_fitaxis_t</a>
<a name="ln166">{</a>
<a name="ln167">  ASHIFT_FIT_NONE          = 0,       // none</a>
<a name="ln168">  ASHIFT_FIT_ROTATION      = 1 &lt;&lt; 0,  // flag indicates to fit rotation angle</a>
<a name="ln169">  ASHIFT_FIT_LENS_VERT     = 1 &lt;&lt; 1,  // flag indicates to fit vertical lens shift</a>
<a name="ln170">  ASHIFT_FIT_LENS_HOR      = 1 &lt;&lt; 2,  // flag indicates to fit horizontal lens shift</a>
<a name="ln171">  ASHIFT_FIT_SHEAR         = 1 &lt;&lt; 3,  // flag indicates to fit shear parameter</a>
<a name="ln172">  ASHIFT_FIT_LINES_VERT    = 1 &lt;&lt; 4,  // use vertical lines for fitting</a>
<a name="ln173">  ASHIFT_FIT_LINES_HOR     = 1 &lt;&lt; 5,  // use horizontal lines for fitting</a>
<a name="ln174">  ASHIFT_FIT_LENS_BOTH = ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR,</a>
<a name="ln175">  ASHIFT_FIT_LINES_BOTH = ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln176">  ASHIFT_FIT_VERTICALLY = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LINES_VERT,</a>
<a name="ln177">  ASHIFT_FIT_HORIZONTALLY = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LENS_HOR | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln178">  ASHIFT_FIT_BOTH = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR |</a>
<a name="ln179">                    ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln180">  ASHIFT_FIT_VERTICALLY_NO_ROTATION = ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LINES_VERT,</a>
<a name="ln181">  ASHIFT_FIT_HORIZONTALLY_NO_ROTATION = ASHIFT_FIT_LENS_HOR | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln182">  ASHIFT_FIT_BOTH_NO_ROTATION = ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR |</a>
<a name="ln183">                                ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln184">  ASHIFT_FIT_BOTH_SHEAR = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR |</a>
<a name="ln185">                    ASHIFT_FIT_SHEAR | ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln186">  ASHIFT_FIT_ROTATION_VERTICAL_LINES = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LINES_VERT,</a>
<a name="ln187">  ASHIFT_FIT_ROTATION_HORIZONTAL_LINES = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln188">  ASHIFT_FIT_ROTATION_BOTH_LINES = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln189">  ASHIFT_FIT_FLIP = ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR | ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR</a>
<a name="ln190">} dt_iop_ashift_fitaxis_t;</a>
<a name="ln191"> </a>
<a name="ln192">typedef enum dt_iop_ashift_nmsresult_t</a>
<a name="ln193">{</a>
<a name="ln194">  NMS_SUCCESS = 0,</a>
<a name="ln195">  NMS_NOT_ENOUGH_LINES = 1,</a>
<a name="ln196">  NMS_DID_NOT_CONVERGE = 2,</a>
<a name="ln197">  NMS_INSANE = 3</a>
<a name="ln198">} dt_iop_ashift_nmsresult_t;</a>
<a name="ln199"> </a>
<a name="ln200">typedef enum dt_iop_ashift_enhance_t</a>
<a name="ln201">{</a>
<a name="ln202">  ASHIFT_ENHANCE_NONE       = 0,</a>
<a name="ln203">  ASHIFT_ENHANCE_EDGES      = 1 &lt;&lt; 0,</a>
<a name="ln204">  ASHIFT_ENHANCE_DETAIL     = 1 &lt;&lt; 1,</a>
<a name="ln205">  ASHIFT_ENHANCE_HORIZONTAL = 0x100,</a>
<a name="ln206">  ASHIFT_ENHANCE_VERTICAL   = 0x200</a>
<a name="ln207">} dt_iop_ashift_enhance_t;</a>
<a name="ln208"> </a>
<a name="ln209">typedef enum dt_iop_ashift_mode_t</a>
<a name="ln210">{</a>
<a name="ln211">  ASHIFT_MODE_GENERIC = 0,</a>
<a name="ln212">  ASHIFT_MODE_SPECIFIC = 1</a>
<a name="ln213">} dt_iop_ashift_mode_t;</a>
<a name="ln214"> </a>
<a name="ln215">typedef enum dt_iop_ashift_crop_t</a>
<a name="ln216">{</a>
<a name="ln217">  ASHIFT_CROP_OFF = 0,</a>
<a name="ln218">  ASHIFT_CROP_LARGEST = 1,</a>
<a name="ln219">  ASHIFT_CROP_ASPECT = 2</a>
<a name="ln220">} dt_iop_ashift_crop_t;</a>
<a name="ln221"> </a>
<a name="ln222">typedef enum dt_iop_ashift_bounding_t</a>
<a name="ln223">{</a>
<a name="ln224">  ASHIFT_BOUNDING_OFF = 0,</a>
<a name="ln225">  ASHIFT_BOUNDING_SELECT = 1,</a>
<a name="ln226">  ASHIFT_BOUNDING_DESELECT = 2</a>
<a name="ln227">} dt_iop_ashift_bounding_t;</a>
<a name="ln228"> </a>
<a name="ln229">typedef enum dt_iop_ashift_jobcode_t</a>
<a name="ln230">{</a>
<a name="ln231">  ASHIFT_JOBCODE_NONE = 0,</a>
<a name="ln232">  ASHIFT_JOBCODE_GET_STRUCTURE = 1,</a>
<a name="ln233">  ASHIFT_JOBCODE_FIT = 2</a>
<a name="ln234">} dt_iop_ashift_jobcode_t;</a>
<a name="ln235"> </a>
<a name="ln236">typedef struct dt_iop_ashift_params1_t</a>
<a name="ln237">{</a>
<a name="ln238">  float rotation;</a>
<a name="ln239">  float lensshift_v;</a>
<a name="ln240">  float lensshift_h;</a>
<a name="ln241">  int toggle;</a>
<a name="ln242">} dt_iop_ashift_params1_t;</a>
<a name="ln243"> </a>
<a name="ln244">typedef struct dt_iop_ashift_params2_t</a>
<a name="ln245">{</a>
<a name="ln246">  float rotation;</a>
<a name="ln247">  float lensshift_v;</a>
<a name="ln248">  float lensshift_h;</a>
<a name="ln249">  float f_length;</a>
<a name="ln250">  float crop_factor;</a>
<a name="ln251">  float orthocorr;</a>
<a name="ln252">  float aspect;</a>
<a name="ln253">  dt_iop_ashift_mode_t mode;</a>
<a name="ln254">  int toggle;</a>
<a name="ln255">} dt_iop_ashift_params2_t;</a>
<a name="ln256"> </a>
<a name="ln257">typedef struct dt_iop_ashift_params3_t</a>
<a name="ln258">{</a>
<a name="ln259">  float rotation;</a>
<a name="ln260">  float lensshift_v;</a>
<a name="ln261">  float lensshift_h;</a>
<a name="ln262">  float f_length;</a>
<a name="ln263">  float crop_factor;</a>
<a name="ln264">  float orthocorr;</a>
<a name="ln265">  float aspect;</a>
<a name="ln266">  dt_iop_ashift_mode_t mode;</a>
<a name="ln267">  int toggle;</a>
<a name="ln268">  dt_iop_ashift_crop_t cropmode;</a>
<a name="ln269">  float cl;</a>
<a name="ln270">  float cr;</a>
<a name="ln271">  float ct;</a>
<a name="ln272">  float cb;</a>
<a name="ln273">} dt_iop_ashift_params3_t;</a>
<a name="ln274"> </a>
<a name="ln275">typedef struct dt_iop_ashift_params_t</a>
<a name="ln276">{</a>
<a name="ln277">  float rotation;</a>
<a name="ln278">  float lensshift_v;</a>
<a name="ln279">  float lensshift_h;</a>
<a name="ln280">  float shear;</a>
<a name="ln281">  float f_length;</a>
<a name="ln282">  float crop_factor;</a>
<a name="ln283">  float orthocorr;</a>
<a name="ln284">  float aspect;</a>
<a name="ln285">  dt_iop_ashift_mode_t mode;</a>
<a name="ln286">  int toggle;</a>
<a name="ln287">  dt_iop_ashift_crop_t cropmode;</a>
<a name="ln288">  float cl;</a>
<a name="ln289">  float cr;</a>
<a name="ln290">  float ct;</a>
<a name="ln291">  float cb;</a>
<a name="ln292">} dt_iop_ashift_params_t;</a>
<a name="ln293"> </a>
<a name="ln294">typedef struct dt_iop_ashift_line_t</a>
<a name="ln295">{</a>
<a name="ln296">  float p1[3];</a>
<a name="ln297">  float p2[3];</a>
<a name="ln298">  float length;</a>
<a name="ln299">  float width;</a>
<a name="ln300">  float weight;</a>
<a name="ln301">  dt_iop_ashift_linetype_t type;</a>
<a name="ln302">  // homogeneous coordinates:</a>
<a name="ln303">  float L[3];</a>
<a name="ln304">} dt_iop_ashift_line_t;</a>
<a name="ln305"> </a>
<a name="ln306">typedef struct dt_iop_ashift_points_idx_t</a>
<a name="ln307">{</a>
<a name="ln308">  size_t offset;</a>
<a name="ln309">  int length;</a>
<a name="ln310">  int near;</a>
<a name="ln311">  int bounded;</a>
<a name="ln312">  dt_iop_ashift_linetype_t type;</a>
<a name="ln313">  dt_iop_ashift_linecolor_t color;</a>
<a name="ln314">  // bounding box:</a>
<a name="ln315">  float bbx, bby, bbX, bbY;</a>
<a name="ln316">} dt_iop_ashift_points_idx_t;</a>
<a name="ln317"> </a>
<a name="ln318">typedef struct dt_iop_ashift_fit_params_t</a>
<a name="ln319">{</a>
<a name="ln320">  int params_count;</a>
<a name="ln321">  dt_iop_ashift_linetype_t linetype;</a>
<a name="ln322">  dt_iop_ashift_linetype_t linemask;</a>
<a name="ln323">  dt_iop_ashift_line_t *lines;</a>
<a name="ln324">  int lines_count;</a>
<a name="ln325">  int width;</a>
<a name="ln326">  int height;</a>
<a name="ln327">  float weight;</a>
<a name="ln328">  float f_length_kb;</a>
<a name="ln329">  float orthocorr;</a>
<a name="ln330">  float aspect;</a>
<a name="ln331">  float rotation;</a>
<a name="ln332">  float lensshift_v;</a>
<a name="ln333">  float lensshift_h;</a>
<a name="ln334">  float shear;</a>
<a name="ln335">  float rotation_range;</a>
<a name="ln336">  float lensshift_v_range;</a>
<a name="ln337">  float lensshift_h_range;</a>
<a name="ln338">  float shear_range;</a>
<a name="ln339">} dt_iop_ashift_fit_params_t;</a>
<a name="ln340"> </a>
<a name="ln341">typedef struct dt_iop_ashift_cropfit_params_t</a>
<a name="ln342">{</a>
<a name="ln343">  int width;</a>
<a name="ln344">  int height;</a>
<a name="ln345">  float x;</a>
<a name="ln346">  float y;</a>
<a name="ln347">  float alpha;</a>
<a name="ln348">  float homograph[3][3];</a>
<a name="ln349">  float edges[4][3];</a>
<a name="ln350">} dt_iop_ashift_cropfit_params_t;</a>
<a name="ln351"> </a>
<a name="ln352">typedef struct dt_iop_ashift_gui_data_t</a>
<a name="ln353">{</a>
<a name="ln354">  GtkWidget *rotation;</a>
<a name="ln355">  GtkWidget *lensshift_v;</a>
<a name="ln356">  GtkWidget *lensshift_h;</a>
<a name="ln357">  GtkWidget *shear;</a>
<a name="ln358">  GtkWidget *guide_lines;</a>
<a name="ln359">  GtkWidget *cropmode;</a>
<a name="ln360">  GtkWidget *mode;</a>
<a name="ln361">  GtkWidget *f_length;</a>
<a name="ln362">  GtkWidget *crop_factor;</a>
<a name="ln363">  GtkWidget *orthocorr;</a>
<a name="ln364">  GtkWidget *aspect;</a>
<a name="ln365">  GtkWidget *fit_v;</a>
<a name="ln366">  GtkWidget *fit_h;</a>
<a name="ln367">  GtkWidget *fit_both;</a>
<a name="ln368">  GtkWidget *structure;</a>
<a name="ln369">  GtkWidget *clean;</a>
<a name="ln370">  GtkWidget *eye;</a>
<a name="ln371">  int lines_suppressed;</a>
<a name="ln372">  int fitting;</a>
<a name="ln373">  int isflipped;</a>
<a name="ln374">  int show_guides;</a>
<a name="ln375">  int isselecting;</a>
<a name="ln376">  int isdeselecting;</a>
<a name="ln377">  dt_iop_ashift_bounding_t isbounding;</a>
<a name="ln378">  float near_delta;</a>
<a name="ln379">  int selecting_lines_version;</a>
<a name="ln380">  float rotation_range;</a>
<a name="ln381">  float lensshift_v_range;</a>
<a name="ln382">  float lensshift_h_range;</a>
<a name="ln383">  float shear_range;</a>
<a name="ln384">  dt_iop_ashift_line_t *lines;</a>
<a name="ln385">  int lines_in_width;</a>
<a name="ln386">  int lines_in_height;</a>
<a name="ln387">  int lines_x_off;</a>
<a name="ln388">  int lines_y_off;</a>
<a name="ln389">  int lines_count;</a>
<a name="ln390">  int vertical_count;</a>
<a name="ln391">  int horizontal_count;</a>
<a name="ln392">  int lines_version;</a>
<a name="ln393">  float vertical_weight;</a>
<a name="ln394">  float horizontal_weight;</a>
<a name="ln395">  float *points;</a>
<a name="ln396">  dt_iop_ashift_points_idx_t *points_idx;</a>
<a name="ln397">  int points_lines_count;</a>
<a name="ln398">  int points_version;</a>
<a name="ln399">  float *buf;</a>
<a name="ln400">  int buf_width;</a>
<a name="ln401">  int buf_height;</a>
<a name="ln402">  int buf_x_off;</a>
<a name="ln403">  int buf_y_off;</a>
<a name="ln404">  float buf_scale;</a>
<a name="ln405">  uint64_t lines_hash;</a>
<a name="ln406">  uint64_t grid_hash;</a>
<a name="ln407">  uint64_t buf_hash;</a>
<a name="ln408">  dt_iop_ashift_fitaxis_t lastfit;</a>
<a name="ln409">  float lastx;</a>
<a name="ln410">  float lasty;</a>
<a name="ln411">  float crop_cx;</a>
<a name="ln412">  float crop_cy;</a>
<a name="ln413">  dt_iop_ashift_jobcode_t jobcode;</a>
<a name="ln414">  int jobparams;</a>
<a name="ln415">  dt_pthread_mutex_t lock;</a>
<a name="ln416">  gboolean adjust_crop;</a>
<a name="ln417">} dt_iop_ashift_gui_data_t;</a>
<a name="ln418"> </a>
<a name="ln419">typedef struct dt_iop_ashift_data_t</a>
<a name="ln420">{</a>
<a name="ln421">  float rotation;</a>
<a name="ln422">  float lensshift_v;</a>
<a name="ln423">  float lensshift_h;</a>
<a name="ln424">  float shear;</a>
<a name="ln425">  float f_length_kb;</a>
<a name="ln426">  float orthocorr;</a>
<a name="ln427">  float aspect;</a>
<a name="ln428">  float cl;</a>
<a name="ln429">  float cr;</a>
<a name="ln430">  float ct;</a>
<a name="ln431">  float cb;</a>
<a name="ln432">} dt_iop_ashift_data_t;</a>
<a name="ln433"> </a>
<a name="ln434">typedef struct dt_iop_ashift_global_data_t</a>
<a name="ln435">{</a>
<a name="ln436">  int kernel_ashift_bilinear;</a>
<a name="ln437">  int kernel_ashift_bicubic;</a>
<a name="ln438">  int kernel_ashift_lanczos2;</a>
<a name="ln439">  int kernel_ashift_lanczos3;</a>
<a name="ln440">} dt_iop_ashift_global_data_t;</a>
<a name="ln441"> </a>
<a name="ln442">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln443">                  void *new_params, const int new_version)</a>
<a name="ln444">{</a>
<a name="ln445">  if(old_version == 1 &amp;&amp; new_version == 4)</a>
<a name="ln446">  {</a>
<a name="ln447">    const dt_iop_ashift_params1_t *old = old_params;</a>
<a name="ln448">    dt_iop_ashift_params_t *new = new_params;</a>
<a name="ln449">    new-&gt;rotation = old-&gt;rotation;</a>
<a name="ln450">    new-&gt;lensshift_v = old-&gt;lensshift_v;</a>
<a name="ln451">    new-&gt;lensshift_h = old-&gt;lensshift_h;</a>
<a name="ln452">    new-&gt;shear = 0.0f;</a>
<a name="ln453">    new-&gt;toggle = old-&gt;toggle;</a>
<a name="ln454">    new-&gt;f_length = DEFAULT_F_LENGTH;</a>
<a name="ln455">    new-&gt;crop_factor = 1.0f;</a>
<a name="ln456">    new-&gt;orthocorr = 100.0f;</a>
<a name="ln457">    new-&gt;aspect = 1.0f;</a>
<a name="ln458">    new-&gt;mode = ASHIFT_MODE_GENERIC;</a>
<a name="ln459">    new-&gt;cropmode = ASHIFT_CROP_OFF;</a>
<a name="ln460">    new-&gt;cl = 0.0f;</a>
<a name="ln461">    new-&gt;cr = 1.0f;</a>
<a name="ln462">    new-&gt;ct = 0.0f;</a>
<a name="ln463">    new-&gt;cb = 1.0f;</a>
<a name="ln464">    return 0;</a>
<a name="ln465">  }</a>
<a name="ln466">  if(old_version == 2 &amp;&amp; new_version == 4)</a>
<a name="ln467">  {</a>
<a name="ln468">    const dt_iop_ashift_params2_t *old = old_params;</a>
<a name="ln469">    dt_iop_ashift_params_t *new = new_params;</a>
<a name="ln470">    new-&gt;rotation = old-&gt;rotation;</a>
<a name="ln471">    new-&gt;lensshift_v = old-&gt;lensshift_v;</a>
<a name="ln472">    new-&gt;lensshift_h = old-&gt;lensshift_h;</a>
<a name="ln473">    new-&gt;shear = 0.0f;</a>
<a name="ln474">    new-&gt;toggle = old-&gt;toggle;</a>
<a name="ln475">    new-&gt;f_length = old-&gt;f_length;</a>
<a name="ln476">    new-&gt;crop_factor = old-&gt;crop_factor;</a>
<a name="ln477">    new-&gt;orthocorr = old-&gt;orthocorr;</a>
<a name="ln478">    new-&gt;aspect = old-&gt;aspect;</a>
<a name="ln479">    new-&gt;mode = old-&gt;mode;</a>
<a name="ln480">    new-&gt;cropmode = ASHIFT_CROP_OFF;</a>
<a name="ln481">    new-&gt;cl = 0.0f;</a>
<a name="ln482">    new-&gt;cr = 1.0f;</a>
<a name="ln483">    new-&gt;ct = 0.0f;</a>
<a name="ln484">    new-&gt;cb = 1.0f;</a>
<a name="ln485">    return 0;</a>
<a name="ln486">  }</a>
<a name="ln487">  if(old_version == 3 &amp;&amp; new_version == 4)</a>
<a name="ln488">  {</a>
<a name="ln489">    const dt_iop_ashift_params3_t *old = old_params;</a>
<a name="ln490">    dt_iop_ashift_params_t *new = new_params;</a>
<a name="ln491">    new-&gt;rotation = old-&gt;rotation;</a>
<a name="ln492">    new-&gt;lensshift_v = old-&gt;lensshift_v;</a>
<a name="ln493">    new-&gt;lensshift_h = old-&gt;lensshift_h;</a>
<a name="ln494">    new-&gt;shear = 0.0f;</a>
<a name="ln495">    new-&gt;toggle = old-&gt;toggle;</a>
<a name="ln496">    new-&gt;f_length = old-&gt;f_length;</a>
<a name="ln497">    new-&gt;crop_factor = old-&gt;crop_factor;</a>
<a name="ln498">    new-&gt;orthocorr = old-&gt;orthocorr;</a>
<a name="ln499">    new-&gt;aspect = old-&gt;aspect;</a>
<a name="ln500">    new-&gt;mode = old-&gt;mode;</a>
<a name="ln501">    new-&gt;cropmode = old-&gt;cropmode;</a>
<a name="ln502">    new-&gt;cl = old-&gt;cl;</a>
<a name="ln503">    new-&gt;cr = old-&gt;cr;</a>
<a name="ln504">    new-&gt;ct = old-&gt;ct;</a>
<a name="ln505">    new-&gt;cb = old-&gt;cb;</a>
<a name="ln506">    return 0;</a>
<a name="ln507">  }</a>
<a name="ln508"> </a>
<a name="ln509">  return 1;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln513">{</a>
<a name="ln514">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;rotation&quot;));</a>
<a name="ln515">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;lens shift (v)&quot;));</a>
<a name="ln516">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;lens shift (h)&quot;));</a>
<a name="ln517">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;shear&quot;));</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln521">{</a>
<a name="ln522">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln523"> </a>
<a name="ln524">  dt_accel_connect_slider_iop(self, &quot;rotation&quot;, GTK_WIDGET(g-&gt;rotation));</a>
<a name="ln525">  dt_accel_connect_slider_iop(self, &quot;lens shift (v)&quot;, GTK_WIDGET(g-&gt;lensshift_v));</a>
<a name="ln526">  dt_accel_connect_slider_iop(self, &quot;lens shift (h)&quot;, GTK_WIDGET(g-&gt;lensshift_h));</a>
<a name="ln527">  dt_accel_connect_slider_iop(self, &quot;shear&quot;, GTK_WIDGET(g-&gt;shear));</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530">// multiply 3x3 matrix with 3x1 vector</a>
<a name="ln531">// dst needs to be different from v</a>
<a name="ln532">static inline void mat3mulv(float *dst, const float *const mat, const float *const v)</a>
<a name="ln533">{</a>
<a name="ln534">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln535">  {</a>
<a name="ln536">    float x = 0.0f;</a>
<a name="ln537">    for(int i = 0; i &lt; 3; i++) x += mat[3 * k + i] * v[i];</a>
<a name="ln538">    dst[k] = x;</a>
<a name="ln539">  }</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">// multiply two 3x3 matrices</a>
<a name="ln543">// dst needs to be different from m1 and m2</a>
<a name="ln544">static inline void mat3mul(float *dst, const float *const m1, const float *const m2)</a>
<a name="ln545">{</a>
<a name="ln546">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln547">  {</a>
<a name="ln548">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln549">    {</a>
<a name="ln550">      float x = 0.0f;</a>
<a name="ln551">      for(int j = 0; j &lt; 3; j++) x += m1[3 * k + j] * m2[3 * j + i];</a>
<a name="ln552">      dst[3 * k + i] = x;</a>
<a name="ln553">    }</a>
<a name="ln554">  }</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">// normalized product of two 3x1 vectors</a>
<a name="ln558">// dst needs to be different from v1 and v2</a>
<a name="ln559">static inline void vec3prodn(float *dst, const float *const v1, const float *const v2)</a>
<a name="ln560">{</a>
<a name="ln561">  const float l1 = v1[1] * v2[2] - v1[2] * v2[1];</a>
<a name="ln562">  const float l2 = v1[2] * v2[0] - v1[0] * v2[2];</a>
<a name="ln563">  const float l3 = v1[0] * v2[1] - v1[1] * v2[0];</a>
<a name="ln564"> </a>
<a name="ln565">  // normalize so that l1^2 + l2^2 + l3^3 = 1</a>
<a name="ln566">  const float sq = sqrt(l1 * l1 + l2 * l2 + l3 * l3);</a>
<a name="ln567"> </a>
<a name="ln568">  const float f = sq &gt; 0.0f ? 1.0f / sq : 1.0f;</a>
<a name="ln569"> </a>
<a name="ln570">  dst[0] = l1 * f;</a>
<a name="ln571">  dst[1] = l2 * f;</a>
<a name="ln572">  dst[2] = l3 * f;</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">// normalize a 3x1 vector so that x^2 + y^2 + z^2 = 1</a>
<a name="ln576">// dst and v may be the same</a>
<a name="ln577">static inline void vec3norm(float *dst, const float *const v)</a>
<a name="ln578">{</a>
<a name="ln579">  const float sq = sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);</a>
<a name="ln580"> </a>
<a name="ln581">  // special handling for an all-zero vector</a>
<a name="ln582">  const float f = sq &gt; 0.0f ? 1.0f / sq : 1.0f;</a>
<a name="ln583"> </a>
<a name="ln584">  dst[0] = v[0] * f;</a>
<a name="ln585">  dst[1] = v[1] * f;</a>
<a name="ln586">  dst[2] = v[2] * f;</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">// normalize a 3x1 vector so that x^2 + y^2 = 1; a useful normalization for</a>
<a name="ln590">// lines in homogeneous coordinates</a>
<a name="ln591">// dst and v may be the same</a>
<a name="ln592">static inline void vec3lnorm(float *dst, const float *const v)</a>
<a name="ln593">{</a>
<a name="ln594">  const float sq = sqrt(v[0] * v[0] + v[1] * v[1]);</a>
<a name="ln595"> </a>
<a name="ln596">  // special handling for a point vector of the image center</a>
<a name="ln597">  const float f = sq &gt; 0.0f ? 1.0f / sq : 1.0f;</a>
<a name="ln598"> </a>
<a name="ln599">  dst[0] = v[0] * f;</a>
<a name="ln600">  dst[1] = v[1] * f;</a>
<a name="ln601">  dst[2] = v[2] * f;</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604"> </a>
<a name="ln605">// scalar product of two 3x1 vectors</a>
<a name="ln606">static inline float vec3scalar(const float *const v1, const float *const v2)</a>
<a name="ln607">{</a>
<a name="ln608">  return (v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">// check if 3x1 vector is (very close to) null</a>
<a name="ln612">static inline int vec3isnull(const float *const v)</a>
<a name="ln613">{</a>
<a name="ln614">  const float eps = 1e-10f;</a>
<a name="ln615">  return (fabs(v[0]) &lt; eps &amp;&amp; fabs(v[1]) &lt; eps &amp;&amp; fabs(v[2]) &lt; eps);</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">#ifdef ASHIFT_DEBUG</a>
<a name="ln619">static void print_roi(const dt_iop_roi_t *roi, const char *label)</a>
<a name="ln620">{</a>
<a name="ln621">  printf(&quot;{ %5d  %5d  %5d  %5d  %.6f } %s\n&quot;, roi-&gt;x, roi-&gt;y, roi-&gt;width, roi-&gt;height, roi-&gt;scale, label);</a>
<a name="ln622">}</a>
<a name="ln623">#endif</a>
<a name="ln624"> </a>
<a name="ln625">#define MAT3SWAP(a, b) { float (*tmp)[3] = (a); (a) = (b); (b) = tmp; }</a>
<a name="ln626"> </a>
<a name="ln627">static void homography(float *homograph, const float angle, const float shift_v, const float shift_h,</a>
<a name="ln628">                       const float shear, const float f_length_kb, const float orthocorr, const float aspect,</a>
<a name="ln629">                       const int width, const int height, dt_iop_ashift_homodir_t dir)</a>
<a name="ln630">{</a>
<a name="ln631">  // calculate homograph that combines all translations, rotations</a>
<a name="ln632">  // and warping into one single matrix operation.</a>
<a name="ln633">  // this is heavily leaning on ShiftN where the homographic matrix expects</a>
<a name="ln634">  // input in (y : x : 1) format. in the darktable world we want to keep the</a>
<a name="ln635">  // (x : y : 1) convention. therefore we need to flip coordinates first and</a>
<a name="ln636">  // make sure that output is in correct format after corrections are applied.</a>
<a name="ln637"> </a>
<a name="ln638">  const float u = width;</a>
<a name="ln639">  const float v = height;</a>
<a name="ln640"> </a>
<a name="ln641">  const float phi = M_PI * angle / 180.0f;</a>
<a name="ln642">  const float cosi = cos(phi);</a>
<a name="ln643">  const float sini = sin(phi);</a>
<a name="ln644">  const float ascale = sqrt(aspect);</a>
<a name="ln645"> </a>
<a name="ln646">  // most of this comes from ShiftN</a>
<a name="ln647">  const float f_global = f_length_kb;</a>
<a name="ln648">  const float horifac = 1.0f - orthocorr / 100.0f;</a>
<a name="ln649">  const float exppa_v = exp(shift_v);</a>
<a name="ln650">  const float fdb_v = f_global / (14.4f + (v / u - 1) * 7.2f);</a>
<a name="ln651">  const float rad_v = fdb_v * (exppa_v - 1.0f) / (exppa_v + 1.0f);</a>
<a name="ln652">  const float alpha_v = CLAMP(atan(rad_v), -1.5f, 1.5f);</a>
<a name="ln653">  const float rt_v = sin(0.5f * alpha_v);</a>
<a name="ln654">  const float r_v = fmax(0.1f, 2.0f * (horifac - 1.0f) * rt_v * rt_v + 1.0f);</a>
<a name="ln655"> </a>
<a name="ln656">  const float vertifac = 1.0f - orthocorr / 100.0f;</a>
<a name="ln657">  const float exppa_h = exp(shift_h);</a>
<a name="ln658">  const float fdb_h = f_global / (14.4f + (u / v - 1) * 7.2f);</a>
<a name="ln659">  const float rad_h = fdb_h * (exppa_h - 1.0f) / (exppa_h + 1.0f);</a>
<a name="ln660">  const float alpha_h = CLAMP(atan(rad_h), -1.5f, 1.5f);</a>
<a name="ln661">  const float rt_h = sin(0.5f * alpha_h);</a>
<a name="ln662">  const float r_h = fmax(0.1f, 2.0f * (vertifac - 1.0f) * rt_h * rt_h + 1.0f);</a>
<a name="ln663"> </a>
<a name="ln664"> </a>
<a name="ln665">  // three intermediate buffers for matrix calculation ...</a>
<a name="ln666">  float m1[3][3], m2[3][3], m3[3][3];</a>
<a name="ln667"> </a>
<a name="ln668">  // ... and some pointers to handle them more intuitively</a>
<a name="ln669">  float (*mwork)[3] = m1;</a>
<a name="ln670">  float (*minput)[3] = m2;</a>
<a name="ln671">  float (*moutput)[3] = m3;</a>
<a name="ln672"> </a>
<a name="ln673">  // Step 1: flip x and y coordinates (see above)</a>
<a name="ln674">  memset(minput, 0, 9 * sizeof(float));</a>
<a name="ln675">  minput[0][1] = 1.0f;</a>
<a name="ln676">  minput[1][0] = 1.0f;</a>
<a name="ln677">  minput[2][2] = 1.0f;</a>
<a name="ln678"> </a>
<a name="ln679"> </a>
<a name="ln680">  // Step 2: rotation of image around its center</a>
<a name="ln681">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln682">  mwork[0][0] = cosi;</a>
<a name="ln683">  mwork[0][1] = -sini;</a>
<a name="ln684">  mwork[1][0] = sini;</a>
<a name="ln685">  mwork[1][1] = cosi;</a>
<a name="ln686">  mwork[0][2] = -0.5f * v * cosi + 0.5f * u * sini + 0.5f * v;</a>
<a name="ln687">  mwork[1][2] = -0.5f * v * sini - 0.5f * u * cosi + 0.5f * u;</a>
<a name="ln688">  mwork[2][2] = 1.0f;</a>
<a name="ln689"> </a>
<a name="ln690">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln691">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln692"> </a>
<a name="ln693"> </a>
<a name="ln694">  // Step 3: apply shearing</a>
<a name="ln695">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln696">  mwork[0][0] = 1.0f;</a>
<a name="ln697">  mwork[0][1] = shear;</a>
<a name="ln698">  mwork[1][1] = 1.0f;</a>
<a name="ln699">  mwork[1][0] = shear;</a>
<a name="ln700">  mwork[2][2] = 1.0f;</a>
<a name="ln701"> </a>
<a name="ln702">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln703">  MAT3SWAP(minput, moutput);</a>
<a name="ln704">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln705">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln706"> </a>
<a name="ln707"> </a>
<a name="ln708">  // Step 4: apply vertical lens shift effect</a>
<a name="ln709">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln710">  mwork[0][0] = exppa_v;</a>
<a name="ln711">  mwork[1][0] = 0.5f * ((exppa_v - 1.0f) * u) / v;</a>
<a name="ln712">  mwork[1][1] = 2.0f * exppa_v / (exppa_v + 1.0f);</a>
<a name="ln713">  mwork[1][2] = -0.5f * ((exppa_v - 1.0f) * u) / (exppa_v + 1.0f);</a>
<a name="ln714">  mwork[2][0] = (exppa_v - 1.0f) / v;</a>
<a name="ln715">  mwork[2][2] = 1.0f;</a>
<a name="ln716"> </a>
<a name="ln717">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln718">  MAT3SWAP(minput, moutput);</a>
<a name="ln719">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln720">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln721"> </a>
<a name="ln722"> </a>
<a name="ln723">  // Step 5: horizontal compression</a>
<a name="ln724">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln725">  mwork[0][0] = 1.0f;</a>
<a name="ln726">  mwork[1][1] = r_v;</a>
<a name="ln727">  mwork[1][2] = 0.5f * u * (1.0f - r_v);</a>
<a name="ln728">  mwork[2][2] = 1.0f;</a>
<a name="ln729"> </a>
<a name="ln730">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln731">  MAT3SWAP(minput, moutput);</a>
<a name="ln732">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln733">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln734"> </a>
<a name="ln735"> </a>
<a name="ln736">  // Step 6: flip x and y back again</a>
<a name="ln737">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln738">  mwork[0][1] = 1.0f;</a>
<a name="ln739">  mwork[1][0] = 1.0f;</a>
<a name="ln740">  mwork[2][2] = 1.0f;</a>
<a name="ln741"> </a>
<a name="ln742">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln743">  MAT3SWAP(minput, moutput);</a>
<a name="ln744">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln745">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln746"> </a>
<a name="ln747"> </a>
<a name="ln748">  // from here output vectors would be in (x : y : 1) format</a>
<a name="ln749"> </a>
<a name="ln750">  // Step 7: now we can apply horizontal lens shift with the same matrix format as above</a>
<a name="ln751">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln752">  mwork[0][0] = exppa_h;</a>
<a name="ln753">  mwork[1][0] = 0.5f * ((exppa_h - 1.0f) * v) / u;</a>
<a name="ln754">  mwork[1][1] = 2.0f * exppa_h / (exppa_h + 1.0f);</a>
<a name="ln755">  mwork[1][2] = -0.5f * ((exppa_h - 1.0f) * v) / (exppa_h + 1.0f);</a>
<a name="ln756">  mwork[2][0] = (exppa_h - 1.0f) / u;</a>
<a name="ln757">  mwork[2][2] = 1.0f;</a>
<a name="ln758"> </a>
<a name="ln759">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln760">  MAT3SWAP(minput, moutput);</a>
<a name="ln761">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln762">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln763"> </a>
<a name="ln764"> </a>
<a name="ln765">  // Step 8: vertical compression</a>
<a name="ln766">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln767">  mwork[0][0] = 1.0f;</a>
<a name="ln768">  mwork[1][1] = r_h;</a>
<a name="ln769">  mwork[1][2] = 0.5f * v * (1.0f - r_h);</a>
<a name="ln770">  mwork[2][2] = 1.0f;</a>
<a name="ln771"> </a>
<a name="ln772">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln773">  MAT3SWAP(minput, moutput);</a>
<a name="ln774">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln775">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln776"> </a>
<a name="ln777"> </a>
<a name="ln778">  // Step 9: apply aspect ratio scaling</a>
<a name="ln779">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln780">  mwork[0][0] = 1.0f * ascale;</a>
<a name="ln781">  mwork[1][1] = 1.0f / ascale;</a>
<a name="ln782">  mwork[2][2] = 1.0f;</a>
<a name="ln783"> </a>
<a name="ln784">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln785">  MAT3SWAP(minput, moutput);</a>
<a name="ln786">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln787">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln788"> </a>
<a name="ln789"> </a>
<a name="ln790">  // Step 10: find x/y offsets and apply according correction so that</a>
<a name="ln791">  // no negative coordinates occur in output vector</a>
<a name="ln792">  float umin = FLT_MAX, vmin = FLT_MAX;</a>
<a name="ln793">  // visit all four corners</a>
<a name="ln794">  for(int y = 0; y &lt; height; y += height - 1)</a>
<a name="ln795">    for(int x = 0; x &lt; width; x += width - 1)</a>
<a name="ln796">    {</a>
<a name="ln797">      float pi[3], po[3];</a>
<a name="ln798">      pi[0] = x;</a>
<a name="ln799">      pi[1] = y;</a>
<a name="ln800">      pi[2] = 1.0f;</a>
<a name="ln801">      // moutput expects input in (x:y:1) format and gives output as (x:y:1)</a>
<a name="ln802">      mat3mulv(po, (float *)moutput, pi);</a>
<a name="ln803">      umin = fmin(umin, po[0] / po[2]);</a>
<a name="ln804">      vmin = fmin(vmin, po[1] / po[2]);</a>
<a name="ln805">    }</a>
<a name="ln806"> </a>
<a name="ln807">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln808">  mwork[0][0] = 1.0f;</a>
<a name="ln809">  mwork[1][1] = 1.0f;</a>
<a name="ln810">  mwork[2][2] = 1.0f;</a>
<a name="ln811">  mwork[0][2] = -umin;</a>
<a name="ln812">  mwork[1][2] = -vmin;</a>
<a name="ln813"> </a>
<a name="ln814">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln815">  MAT3SWAP(minput, moutput);</a>
<a name="ln816">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln817">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln818"> </a>
<a name="ln819"> </a>
<a name="ln820">  // on request we either keep the final matrix for forward conversions</a>
<a name="ln821">  // or produce an inverted matrix for backward conversions</a>
<a name="ln822">  if(dir == ASHIFT_HOMOGRAPH_FORWARD)</a>
<a name="ln823">  {</a>
<a name="ln824">    // we have what we need -&gt; copy it to the right place</a>
<a name="ln825">    memcpy(homograph, moutput, 9 * sizeof(float));</a>
<a name="ln826">  }</a>
<a name="ln827">  else</a>
<a name="ln828">  {</a>
<a name="ln829">    // generate inverted homograph (mat3inv function defined in colorspaces.c)</a>
<a name="ln830">    if(mat3inv((float *)homograph, (float *)moutput))</a>
<a name="ln831">    {</a>
<a name="ln832">      // in case of error we set to unity matrix</a>
<a name="ln833">      memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln834">      mwork[0][0] = 1.0f;</a>
<a name="ln835">      mwork[1][1] = 1.0f;</a>
<a name="ln836">      mwork[2][2] = 1.0f;</a>
<a name="ln837">      memcpy(homograph, mwork, 9 * sizeof(float));</a>
<a name="ln838">    }</a>
<a name="ln839">  }</a>
<a name="ln840">}</a>
<a name="ln841">#undef MAT3SWAP</a>
<a name="ln842"> </a>
<a name="ln843"> </a>
<a name="ln844">// check if module parameters are set to all neutral values in which case the module's</a>
<a name="ln845">// output is identical to its input</a>
<a name="ln846">static inline int isneutral(dt_iop_ashift_data_t *data)</a>
<a name="ln847">{</a>
<a name="ln848">  // values lower than this have no visible effect</a>
<a name="ln849">  const float eps = 1.0e-4f;</a>
<a name="ln850"> </a>
<a name="ln851">  return(fabs(data-&gt;rotation) &lt; eps &amp;&amp;</a>
<a name="ln852">         fabs(data-&gt;lensshift_v) &lt; eps &amp;&amp;</a>
<a name="ln853">         fabs(data-&gt;lensshift_h) &lt; eps &amp;&amp;</a>
<a name="ln854">         fabs(data-&gt;shear) &lt; eps &amp;&amp;</a>
<a name="ln855">         fabs(data-&gt;aspect - 1.0f) &lt; eps &amp;&amp;</a>
<a name="ln856">         data-&gt;cl &lt; eps &amp;&amp;</a>
<a name="ln857">         1.0f - data-&gt;cr &lt; eps &amp;&amp;</a>
<a name="ln858">         data-&gt;ct &lt; eps &amp;&amp;</a>
<a name="ln859">         1.0f - data-&gt;cb &lt; eps);</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862"> </a>
<a name="ln863">int distort_transform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points, size_t points_count)</a>
<a name="ln864">{</a>
<a name="ln865">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln866"> </a>
<a name="ln867">  // nothing to be done if parameters are set to neutral values</a>
<a name="ln868">  if(isneutral(data)) return 1;</a>
<a name="ln869"> </a>
<a name="ln870">  float homograph[3][3];</a>
<a name="ln871">  homography((float *)homograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln872">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln873"> </a>
<a name="ln874">  // clipping offset</a>
<a name="ln875">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln876">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln877">  const float cx = fullwidth * data-&gt;cl;</a>
<a name="ln878">  const float cy = fullheight * data-&gt;ct;</a>
<a name="ln879"> </a>
<a name="ln880">#ifdef _OPENMP</a>
<a name="ln881">#pragma omp parallel for schedule(static) default(none) shared(points, points_count, homograph)</a>
<a name="ln882">#endif</a>
<a name="ln883">  for(size_t i = 0; i &lt; points_count * 2; i += 2)</a>
<a name="ln884">  {</a>
<a name="ln885">    float pi[3] = { points[i], points[i + 1], 1.0f };</a>
<a name="ln886">    float po[3];</a>
<a name="ln887">    mat3mulv(po, (float *)homograph, pi);</a>
<a name="ln888">    points[i] = po[0] / po[2] - cx;</a>
<a name="ln889">    points[i + 1] = po[1] / po[2] - cy;</a>
<a name="ln890">  }</a>
<a name="ln891"> </a>
<a name="ln892">  return 1;</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895"> </a>
<a name="ln896">int distort_backtransform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points,</a>
<a name="ln897">                          size_t points_count)</a>
<a name="ln898">{</a>
<a name="ln899">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln900"> </a>
<a name="ln901">  // nothing to be done if parameters are set to neutral values</a>
<a name="ln902">  if(isneutral(data)) return 1;</a>
<a name="ln903"> </a>
<a name="ln904">  float ihomograph[3][3];</a>
<a name="ln905">  homography((float *)ihomograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln906">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln907"> </a>
<a name="ln908">  // clipping offset</a>
<a name="ln909">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln910">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln911">  const float cx = fullwidth * data-&gt;cl;</a>
<a name="ln912">  const float cy = fullheight * data-&gt;ct;</a>
<a name="ln913"> </a>
<a name="ln914">#ifdef _OPENMP</a>
<a name="ln915">#pragma omp parallel for schedule(static) default(none) shared(points, points_count, ihomograph)</a>
<a name="ln916">#endif</a>
<a name="ln917">  for(size_t i = 0; i &lt; points_count * 2; i += 2)</a>
<a name="ln918">  {</a>
<a name="ln919">    float pi[3] = { points[i] + cx, points[i + 1] + cy, 1.0f };</a>
<a name="ln920">    float po[3];</a>
<a name="ln921">    mat3mulv(po, (float *)ihomograph, pi);</a>
<a name="ln922">    points[i] = po[0] / po[2];</a>
<a name="ln923">    points[i + 1] = po[1] / po[2];</a>
<a name="ln924">  }</a>
<a name="ln925"> </a>
<a name="ln926">  return 1;</a>
<a name="ln927">}</a>
<a name="ln928"> </a>
<a name="ln929">void distort_mask(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln930">                  float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln931">{</a>
<a name="ln932">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln933"> </a>
<a name="ln934">  // if module is set to neutral parameters we just copy input-&gt;output and are done</a>
<a name="ln935">  if(isneutral(data))</a>
<a name="ln936">  {</a>
<a name="ln937">    memcpy(out, in, (size_t)roi_out-&gt;width * roi_out-&gt;height * sizeof(float));</a>
<a name="ln938">    return;</a>
<a name="ln939">  }</a>
<a name="ln940"> </a>
<a name="ln941">  const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln942"> </a>
<a name="ln943">  float ihomograph[3][3];</a>
<a name="ln944">  homography((float *)ihomograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln945">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln946"> </a>
<a name="ln947">  // clipping offset</a>
<a name="ln948">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln949">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln950">  const float cx = roi_out-&gt;scale * fullwidth * data-&gt;cl;</a>
<a name="ln951">  const float cy = roi_out-&gt;scale * fullheight * data-&gt;ct;</a>
<a name="ln952"> </a>
<a name="ln953"> </a>
<a name="ln954">#ifdef _OPENMP</a>
<a name="ln955">#pragma omp parallel for schedule(static) default(none) shared(ihomograph, interpolation)</a>
<a name="ln956">#endif</a>
<a name="ln957">  // go over all pixels of output image</a>
<a name="ln958">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln959">  {</a>
<a name="ln960">    float *_out = out + (size_t)j * roi_out-&gt;width;</a>
<a name="ln961">    for(int i = 0; i &lt; roi_out-&gt;width; i++, _out++)</a>
<a name="ln962">    {</a>
<a name="ln963">      float pin[3], pout[3];</a>
<a name="ln964"> </a>
<a name="ln965">      // convert output pixel coordinates to original image coordinates</a>
<a name="ln966">      pout[0] = roi_out-&gt;x + i + cx;</a>
<a name="ln967">      pout[1] = roi_out-&gt;y + j + cy;</a>
<a name="ln968">      pout[0] /= roi_out-&gt;scale;</a>
<a name="ln969">      pout[1] /= roi_out-&gt;scale;</a>
<a name="ln970">      pout[2] = 1.0f;</a>
<a name="ln971"> </a>
<a name="ln972">      // apply homograph</a>
<a name="ln973">      mat3mulv(pin, (float *)ihomograph, pout);</a>
<a name="ln974"> </a>
<a name="ln975">      // convert to input pixel coordinates</a>
<a name="ln976">      pin[0] /= pin[2];</a>
<a name="ln977">      pin[1] /= pin[2];</a>
<a name="ln978">      pin[0] *= roi_in-&gt;scale;</a>
<a name="ln979">      pin[1] *= roi_in-&gt;scale;</a>
<a name="ln980">      pin[0] -= roi_in-&gt;x;</a>
<a name="ln981">      pin[1] -= roi_in-&gt;y;</a>
<a name="ln982"> </a>
<a name="ln983">      // get output values by interpolation from input image</a>
<a name="ln984">      dt_interpolation_compute_pixel1c(interpolation, in, _out, pin[0], pin[1], roi_in-&gt;width,</a>
<a name="ln985">                                       roi_in-&gt;height, roi_in-&gt;width);</a>
<a name="ln986">    }</a>
<a name="ln987">  }</a>
<a name="ln988">}</a>
<a name="ln989"> </a>
<a name="ln990">void modify_roi_out(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, dt_iop_roi_t *roi_out,</a>
<a name="ln991">                    const dt_iop_roi_t *roi_in)</a>
<a name="ln992">{</a>
<a name="ln993">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln994">  *roi_out = *roi_in;</a>
<a name="ln995"> </a>
<a name="ln996">  // nothing more to be done if parameters are set to neutral values</a>
<a name="ln997">  if(isneutral(data)) return;</a>
<a name="ln998"> </a>
<a name="ln999">  float homograph[3][3];</a>
<a name="ln1000">  homography((float *)homograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln1001">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln1002"> </a>
<a name="ln1003">  float xm = FLT_MAX, xM = -FLT_MAX, ym = FLT_MAX, yM = -FLT_MAX;</a>
<a name="ln1004"> </a>
<a name="ln1005">  // go through all four vertices of input roi and convert coordinates to output</a>
<a name="ln1006">  for(int y = 0; y &lt; roi_in-&gt;height; y += roi_in-&gt;height - 1)</a>
<a name="ln1007">  {</a>
<a name="ln1008">    for(int x = 0; x &lt; roi_in-&gt;width; x += roi_in-&gt;width - 1)</a>
<a name="ln1009">    {</a>
<a name="ln1010">      float pin[3], pout[3];</a>
<a name="ln1011"> </a>
<a name="ln1012">      // convert from input coordinates to original image coordinates</a>
<a name="ln1013">      pin[0] = roi_in-&gt;x + x;</a>
<a name="ln1014">      pin[1] = roi_in-&gt;y + y;</a>
<a name="ln1015">      pin[0] /= roi_in-&gt;scale;</a>
<a name="ln1016">      pin[1] /= roi_in-&gt;scale;</a>
<a name="ln1017">      pin[2] = 1.0f;</a>
<a name="ln1018"> </a>
<a name="ln1019">      // apply homograph</a>
<a name="ln1020">      mat3mulv(pout, (float *)homograph, pin);</a>
<a name="ln1021"> </a>
<a name="ln1022">      // convert to output image coordinates</a>
<a name="ln1023">      pout[0] /= pout[2];</a>
<a name="ln1024">      pout[1] /= pout[2];</a>
<a name="ln1025">      pout[0] *= roi_out-&gt;scale;</a>
<a name="ln1026">      pout[1] *= roi_out-&gt;scale;</a>
<a name="ln1027">      xm = MIN(xm, pout[0]);</a>
<a name="ln1028">      xM = MAX(xM, pout[0]);</a>
<a name="ln1029">      ym = MIN(ym, pout[1]);</a>
<a name="ln1030">      yM = MAX(yM, pout[1]);</a>
<a name="ln1031">    }</a>
<a name="ln1032">  }</a>
<a name="ln1033">  float width = xM - xm + 1;</a>
<a name="ln1034">  float height = yM - ym + 1;</a>
<a name="ln1035"> </a>
<a name="ln1036">  // clipping adjustments</a>
<a name="ln1037">  width *= data-&gt;cr - data-&gt;cl;</a>
<a name="ln1038">  height *= data-&gt;cb - data-&gt;ct;</a>
<a name="ln1039"> </a>
<a name="ln1040">  roi_out-&gt;width = floorf(width);</a>
<a name="ln1041">  roi_out-&gt;height = floorf(height);</a>
<a name="ln1042"> </a>
<a name="ln1043">#ifdef ASHIFT_DEBUG</a>
<a name="ln1044">  print_roi(roi_in, &quot;roi_in (going into modify_roi_out)&quot;);</a>
<a name="ln1045">  print_roi(roi_out, &quot;roi_out (after modify_roi_out)&quot;);</a>
<a name="ln1046">#endif</a>
<a name="ln1047">}</a>
<a name="ln1048"> </a>
<a name="ln1049">void modify_roi_in(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1050">                   const dt_iop_roi_t *const roi_out, dt_iop_roi_t *roi_in)</a>
<a name="ln1051">{</a>
<a name="ln1052">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln1053">  *roi_in = *roi_out;</a>
<a name="ln1054"> </a>
<a name="ln1055">  // nothing more to be done if parameters are set to neutral values</a>
<a name="ln1056">  if(isneutral(data)) return;</a>
<a name="ln1057"> </a>
<a name="ln1058">  float ihomograph[3][3];</a>
<a name="ln1059">  homography((float *)ihomograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln1060">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln1061"> </a>
<a name="ln1062">  const float orig_w = roi_in-&gt;scale * piece-&gt;buf_in.width;</a>
<a name="ln1063">  const float orig_h = roi_in-&gt;scale * piece-&gt;buf_in.height;</a>
<a name="ln1064"> </a>
<a name="ln1065">  // clipping offset</a>
<a name="ln1066">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln1067">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln1068">  const float cx = roi_out-&gt;scale * fullwidth * data-&gt;cl;</a>
<a name="ln1069">  const float cy = roi_out-&gt;scale * fullheight * data-&gt;ct;</a>
<a name="ln1070"> </a>
<a name="ln1071">  float xm = FLT_MAX, xM = -FLT_MAX, ym = FLT_MAX, yM = -FLT_MAX;</a>
<a name="ln1072"> </a>
<a name="ln1073">  // go through all four vertices of output roi and convert coordinates to input</a>
<a name="ln1074">  for(int y = 0; y &lt; roi_out-&gt;height; y += roi_out-&gt;height - 1)</a>
<a name="ln1075">  {</a>
<a name="ln1076">    for(int x = 0; x &lt; roi_out-&gt;width; x += roi_out-&gt;width - 1)</a>
<a name="ln1077">    {</a>
<a name="ln1078">      float pin[3], pout[3];</a>
<a name="ln1079"> </a>
<a name="ln1080">      // convert from output image coordinates to original image coordinates</a>
<a name="ln1081">      pout[0] = roi_out-&gt;x + x + cx;</a>
<a name="ln1082">      pout[1] = roi_out-&gt;y + y + cy;</a>
<a name="ln1083">      pout[0] /= roi_out-&gt;scale;</a>
<a name="ln1084">      pout[1] /= roi_out-&gt;scale;</a>
<a name="ln1085">      pout[2] = 1.0f;</a>
<a name="ln1086"> </a>
<a name="ln1087">      // apply homograph</a>
<a name="ln1088">      mat3mulv(pin, (float *)ihomograph, pout);</a>
<a name="ln1089"> </a>
<a name="ln1090">      // convert to input image coordinates</a>
<a name="ln1091">      pin[0] /= pin[2];</a>
<a name="ln1092">      pin[1] /= pin[2];</a>
<a name="ln1093">      pin[0] *= roi_in-&gt;scale;</a>
<a name="ln1094">      pin[1] *= roi_in-&gt;scale;</a>
<a name="ln1095">      xm = MIN(xm, pin[0]);</a>
<a name="ln1096">      xM = MAX(xM, pin[0]);</a>
<a name="ln1097">      ym = MIN(ym, pin[1]);</a>
<a name="ln1098">      yM = MAX(yM, pin[1]);</a>
<a name="ln1099">    }</a>
<a name="ln1100">  }</a>
<a name="ln1101"> </a>
<a name="ln1102">  const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln1103">  roi_in-&gt;x = fmaxf(0.0f, xm - interpolation-&gt;width);</a>
<a name="ln1104">  roi_in-&gt;y = fmaxf(0.0f, ym - interpolation-&gt;width);</a>
<a name="ln1105">  roi_in-&gt;width = fminf(ceilf(orig_w) - roi_in-&gt;x, xM - roi_in-&gt;x + 1 + interpolation-&gt;width);</a>
<a name="ln1106">  roi_in-&gt;height = fminf(ceilf(orig_h) - roi_in-&gt;y, yM - roi_in-&gt;y + 1 + interpolation-&gt;width);</a>
<a name="ln1107"> </a>
<a name="ln1108">  // sanity check.</a>
<a name="ln1109">  roi_in-&gt;x = CLAMP(roi_in-&gt;x, 0, (int)floorf(orig_w));</a>
<a name="ln1110">  roi_in-&gt;y = CLAMP(roi_in-&gt;y, 0, (int)floorf(orig_h));</a>
<a name="ln1111">  roi_in-&gt;width = CLAMP(roi_in-&gt;width, 1, (int)floorf(orig_w) - roi_in-&gt;x);</a>
<a name="ln1112">  roi_in-&gt;height = CLAMP(roi_in-&gt;height, 1, (int)floorf(orig_h) - roi_in-&gt;y);</a>
<a name="ln1113">#ifdef ASHIFT_DEBUG</a>
<a name="ln1114">  print_roi(roi_out, &quot;roi_out (going into modify_roi_in)&quot;);</a>
<a name="ln1115">  print_roi(roi_in, &quot;roi_in (after modify_roi_in)&quot;);</a>
<a name="ln1116">#endif</a>
<a name="ln1117">}</a>
<a name="ln1118"> </a>
<a name="ln1119">// simple conversion of rgb image into greyscale variant suitable for line segment detection</a>
<a name="ln1120">// the lsd routines expect input as *double, roughly in the range [0.0; 256.0]</a>
<a name="ln1121">static void rgb2grey256(const float *in, double *out, const int width, const int height)</a>
<a name="ln1122">{</a>
<a name="ln1123">  const int ch = 4;</a>
<a name="ln1124"> </a>
<a name="ln1125">#ifdef _OPENMP</a>
<a name="ln1126">#pragma omp parallel for schedule(static) default(none) shared(in, out)</a>
<a name="ln1127">#endif</a>
<a name="ln1128">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1129">  {</a>
<a name="ln1130">    const float *inp = in + (size_t)ch * j * width;</a>
<a name="ln1131">    double *outp = out + (size_t)j * width;</a>
<a name="ln1132">    for(int i = 0; i &lt; width; i++, inp += ch, outp++)</a>
<a name="ln1133">    {</a>
<a name="ln1134">      *outp = (0.3f * inp[0] + 0.59f * inp[1] + 0.11f * inp[2]) * 256.0;</a>
<a name="ln1135">    }</a>
<a name="ln1136">  }</a>
<a name="ln1137">}</a>
<a name="ln1138"> </a>
<a name="ln1139">// sobel edge enhancement in one direction</a>
<a name="ln1140">static void edge_enhance_1d(const double *in, double *out, const int width, const int height,</a>
<a name="ln1141">                            dt_iop_ashift_enhance_t dir)</a>
<a name="ln1142">{</a>
<a name="ln1143">  // Sobel kernels for both directions</a>
<a name="ln1144">  const double hkernel[3][3] = { { 1.0, 0.0, -1.0 }, { 2.0, 0.0, -2.0 }, { 1.0, 0.0, -1.0 } };</a>
<a name="ln1145">  const double vkernel[3][3] = { { 1.0, 2.0, 1.0 }, { 0.0, 0.0, 0.0 }, { -1.0, -2.0, -1.0 } };</a>
<a name="ln1146">  const int kwidth = 3;</a>
<a name="ln1147">  const int khwidth = kwidth / 2;</a>
<a name="ln1148"> </a>
<a name="ln1149">  // select kernel</a>
<a name="ln1150">  const double *kernel = (dir == ASHIFT_ENHANCE_HORIZONTAL) ? (const double *)hkernel : (const double *)vkernel;</a>
<a name="ln1151"> </a>
<a name="ln1152">#ifdef _OPENMP</a>
<a name="ln1153">#pragma omp parallel for schedule(static) default(none) shared(in, out, kernel)</a>
<a name="ln1154">#endif</a>
<a name="ln1155">  // loop over image pixels and perform sobel convolution</a>
<a name="ln1156">  for(int j = khwidth; j &lt; height - khwidth; j++)</a>
<a name="ln1157">  {</a>
<a name="ln1158">    const double *inp = in + (size_t)j * width + khwidth;</a>
<a name="ln1159">    double *outp = out + (size_t)j * width + khwidth;</a>
<a name="ln1160">    for(int i = khwidth; i &lt; width - khwidth; i++, inp++, outp++)</a>
<a name="ln1161">    {</a>
<a name="ln1162">      double sum = 0.0f;</a>
<a name="ln1163">      for(int jj = 0; jj &lt; kwidth; jj++)</a>
<a name="ln1164">      {</a>
<a name="ln1165">        const int k = jj * kwidth;</a>
<a name="ln1166">        const int l = (jj - khwidth) * width;</a>
<a name="ln1167">        for(int ii = 0; ii &lt; kwidth; ii++)</a>
<a name="ln1168">        {</a>
<a name="ln1169">          sum += inp[l + ii - khwidth] * kernel[k + ii];</a>
<a name="ln1170">        }</a>
<a name="ln1171">      }</a>
<a name="ln1172">      *outp = sum;</a>
<a name="ln1173">    }</a>
<a name="ln1174">  }</a>
<a name="ln1175"> </a>
<a name="ln1176">#ifdef _OPENMP</a>
<a name="ln1177">#pragma omp parallel for schedule(static) default(none) shared(out)</a>
<a name="ln1178">#endif</a>
<a name="ln1179">  // border fill in output buffer, so we don't get pseudo lines at image frame</a>
<a name="ln1180">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1181">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln1182">    {</a>
<a name="ln1183">      double val = out[j * width + i];</a>
<a name="ln1184"> </a>
<a name="ln1185">      if(j &lt; khwidth)</a>
<a name="ln1186">        val = out[(khwidth - j) * width + i];</a>
<a name="ln1187">      else if(j &gt;= height - khwidth)</a>
<a name="ln1188">        val = out[(j - khwidth) * width + i];</a>
<a name="ln1189">      else if(i &lt; khwidth)</a>
<a name="ln1190">        val = out[j * width + (khwidth - i)];</a>
<a name="ln1191">      else if(i &gt;= width - khwidth)</a>
<a name="ln1192">        val = out[j * width + (i - khwidth)];</a>
<a name="ln1193"> </a>
<a name="ln1194">      out[j * width + i] = val;</a>
<a name="ln1195"> </a>
<a name="ln1196">      // jump over center of image</a>
<a name="ln1197">      if(i == khwidth &amp;&amp; j &gt;= khwidth &amp;&amp; j &lt; height - khwidth) i = width - khwidth;</a>
<a name="ln1198">    }</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201">// edge enhancement in both directions</a>
<a name="ln1202">static int edge_enhance(const double *in, double *out, const int width, const int height)</a>
<a name="ln1203">{</a>
<a name="ln1204">  double *Gx = NULL;</a>
<a name="ln1205">  double *Gy = NULL;</a>
<a name="ln1206"> </a>
<a name="ln1207">  Gx = malloc((size_t)width * height * sizeof(double));</a>
<a name="ln1208">  if(Gx == NULL) goto error;</a>
<a name="ln1209"> </a>
<a name="ln1210">  Gy = malloc((size_t)width * height * sizeof(double));</a>
<a name="ln1211">  if(Gy == NULL) goto error;</a>
<a name="ln1212"> </a>
<a name="ln1213">  // perform edge enhancement in both directions</a>
<a name="ln1214">  edge_enhance_1d(in, Gx, width, height, ASHIFT_ENHANCE_HORIZONTAL);</a>
<a name="ln1215">  edge_enhance_1d(in, Gy, width, height, ASHIFT_ENHANCE_VERTICAL);</a>
<a name="ln1216"> </a>
<a name="ln1217">// calculate absolute values</a>
<a name="ln1218">#ifdef _OPENMP</a>
<a name="ln1219">#pragma omp parallel for schedule(static) default(none) shared(Gx, Gy, out)</a>
<a name="ln1220">#endif</a>
<a name="ln1221">  for(size_t k = 0; k &lt; (size_t)width * height; k++)</a>
<a name="ln1222">  {</a>
<a name="ln1223">    out[k] = sqrt(Gx[k] * Gx[k] + Gy[k] * Gy[k]);</a>
<a name="ln1224">  }</a>
<a name="ln1225"> </a>
<a name="ln1226">  free(Gx);</a>
<a name="ln1227">  free(Gy);</a>
<a name="ln1228">  return TRUE;</a>
<a name="ln1229"> </a>
<a name="ln1230">error:</a>
<a name="ln1231">  if(Gx) free(Gx);</a>
<a name="ln1232">  if(Gy) free(Gy);</a>
<a name="ln1233">  return FALSE;</a>
<a name="ln1234">}</a>
<a name="ln1235"> </a>
<a name="ln1236">// XYZ -&gt; sRGB matrix</a>
<a name="ln1237">static void XYZ_to_sRGB(const float *XYZ, float *sRGB)</a>
<a name="ln1238">{</a>
<a name="ln1239">  sRGB[0] =  3.1338561f * XYZ[0] - 1.6168667f * XYZ[1] - 0.4906146f * XYZ[2];</a>
<a name="ln1240">  sRGB[1] = -0.9787684f * XYZ[0] + 1.9161415f * XYZ[1] + 0.0334540f * XYZ[2];</a>
<a name="ln1241">  sRGB[2] =  0.0719453f * XYZ[0] - 0.2289914f * XYZ[1] + 1.4052427f * XYZ[2];</a>
<a name="ln1242">}</a>
<a name="ln1243"> </a>
<a name="ln1244">// sRGB -&gt; XYZ matrix</a>
<a name="ln1245">static void sRGB_to_XYZ(const float *sRGB, float *XYZ)</a>
<a name="ln1246">{</a>
<a name="ln1247">  XYZ[0] = 0.4360747f * sRGB[0] + 0.3850649f * sRGB[1] + 0.1430804f * sRGB[2];</a>
<a name="ln1248">  XYZ[1] = 0.2225045f * sRGB[0] + 0.7168786f * sRGB[1] + 0.0606169f * sRGB[2];</a>
<a name="ln1249">  XYZ[2] = 0.0139322f * sRGB[0] + 0.0971045f * sRGB[1] + 0.7141733f * sRGB[2];</a>
<a name="ln1250">}</a>
<a name="ln1251"> </a>
<a name="ln1252">// detail enhancement via bilateral grid (function arguments in and out may represent identical buffers)</a>
<a name="ln1253">static int detail_enhance(const float *in, float *out, const int width, const int height)</a>
<a name="ln1254">{</a>
<a name="ln1255">  const float sigma_r = 5.0f;</a>
<a name="ln1256">  const float sigma_s = fminf(width, height) * 0.02f;</a>
<a name="ln1257">  const float detail = 10.0f;</a>
<a name="ln1258"> </a>
<a name="ln1259">  int success = TRUE;</a>
<a name="ln1260"> </a>
<a name="ln1261">  // we need to convert from RGB to Lab first;</a>
<a name="ln1262">  // as colors don't matter we are safe to assume data to be sRGB</a>
<a name="ln1263"> </a>
<a name="ln1264">  // convert RGB input to Lab, use output buffer for intermediate storage</a>
<a name="ln1265">#ifdef _OPENMP</a>
<a name="ln1266">#pragma omp parallel for schedule(static) default(none) shared(in, out)</a>
<a name="ln1267">#endif</a>
<a name="ln1268">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1269">  {</a>
<a name="ln1270">    const float *inp = in + (size_t)4 * j * width;</a>
<a name="ln1271">    float *outp = out + (size_t)4 * j * width;</a>
<a name="ln1272">    for(int i = 0; i &lt; width; i++, inp += 4, outp += 4)</a>
<a name="ln1273">    {</a>
<a name="ln1274">      float XYZ[3];</a>
<a name="ln1275">      sRGB_to_XYZ(inp, XYZ);</a>
<a name="ln1276">      dt_XYZ_to_Lab(XYZ, outp);</a>
<a name="ln1277">    }</a>
<a name="ln1278">  }</a>
<a name="ln1279"> </a>
<a name="ln1280">  // bilateral grid detail enhancement</a>
<a name="ln1281">  dt_bilateral_t *b = dt_bilateral_init(width, height, sigma_s, sigma_r);</a>
<a name="ln1282"> </a>
<a name="ln1283">  if(b != NULL)</a>
<a name="ln1284">  {</a>
<a name="ln1285">    dt_bilateral_splat(b, out);</a>
<a name="ln1286">    dt_bilateral_blur(b);</a>
<a name="ln1287">    dt_bilateral_slice_to_output(b, out, out, detail);</a>
<a name="ln1288">    dt_bilateral_free(b);</a>
<a name="ln1289">  }</a>
<a name="ln1290">  else</a>
<a name="ln1291">    success = FALSE;</a>
<a name="ln1292"> </a>
<a name="ln1293">  // convert resulting Lab to RGB output</a>
<a name="ln1294">#ifdef _OPENMP</a>
<a name="ln1295">#pragma omp parallel for schedule(static) default(none) shared(out)</a>
<a name="ln1296">#endif</a>
<a name="ln1297">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1298">  {</a>
<a name="ln1299">    float *outp = out + (size_t)4 * j * width;</a>
<a name="ln1300">    for(int i = 0; i &lt; width; i++, outp += 4)</a>
<a name="ln1301">    {</a>
<a name="ln1302">      float XYZ[3];</a>
<a name="ln1303">      dt_Lab_to_XYZ(outp, XYZ);</a>
<a name="ln1304">      XYZ_to_sRGB(XYZ, outp);</a>
<a name="ln1305">    }</a>
<a name="ln1306">  }</a>
<a name="ln1307"> </a>
<a name="ln1308">  return success;</a>
<a name="ln1309">}</a>
<a name="ln1310"> </a>
<a name="ln1311">// apply gamma correction to RGB buffer (function arguments in and out may represent identical buffers)</a>
<a name="ln1312">static void gamma_correct(const float *in, float *out, const int width, const int height)</a>
<a name="ln1313">{</a>
<a name="ln1314">#ifdef _OPENMP</a>
<a name="ln1315">#pragma omp parallel for schedule(static) default(none) shared(in, out)</a>
<a name="ln1316">#endif</a>
<a name="ln1317">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1318">  {</a>
<a name="ln1319">    const float *inp = in + (size_t)4 * j * width;</a>
<a name="ln1320">    float *outp = out + (size_t)4 * j * width;</a>
<a name="ln1321">    for(int i = 0; i &lt; width; i++, inp += 4, outp += 4)</a>
<a name="ln1322">    {</a>
<a name="ln1323">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1324">        outp[c] = powf(inp[c], LSD_GAMMA);</a>
<a name="ln1325">    }</a>
<a name="ln1326">  }</a>
<a name="ln1327">}</a>
<a name="ln1328"> </a>
<a name="ln1329">// do actual line_detection based on LSD algorithm and return results according</a>
<a name="ln1330">// to this module's conventions</a>
<a name="ln1331">static int line_detect(float *in, const int width, const int height, const int x_off, const int y_off,</a>
<a name="ln1332">                       const float scale, dt_iop_ashift_line_t **alines, int *lcount, int *vcount, int *hcount,</a>
<a name="ln1333">                       float *vweight, float *hweight, dt_iop_ashift_enhance_t enhance, const int is_raw)</a>
<a name="ln1334">{</a>
<a name="ln1335">  double *greyscale = NULL;</a>
<a name="ln1336">  double *lsd_lines = NULL;</a>
<a name="ln1337">  dt_iop_ashift_line_t *ashift_lines = NULL;</a>
<a name="ln1338"> </a>
<a name="ln1339">  int vertical_count = 0;</a>
<a name="ln1340">  int horizontal_count = 0;</a>
<a name="ln1341">  float vertical_weight = 0.0f;</a>
<a name="ln1342">  float horizontal_weight = 0.0f;</a>
<a name="ln1343"> </a>
<a name="ln1344">  // apply gamma correction if image is raw</a>
<a name="ln1345">  if(is_raw)</a>
<a name="ln1346">  {</a>
<a name="ln1347">    gamma_correct(in, in, width, height);</a>
<a name="ln1348">  }</a>
<a name="ln1349"> </a>
<a name="ln1350">  // if requested perform an additional detail enhancement step</a>
<a name="ln1351">  if(enhance &amp; ASHIFT_ENHANCE_DETAIL)</a>
<a name="ln1352">  {</a>
<a name="ln1353">    (void)detail_enhance(in, in, width, height);</a>
<a name="ln1354">  }</a>
<a name="ln1355"> </a>
<a name="ln1356">  // allocate intermediate buffers</a>
<a name="ln1357">  greyscale = malloc((size_t)width * height * sizeof(double));</a>
<a name="ln1358">  if(greyscale == NULL) goto error;</a>
<a name="ln1359"> </a>
<a name="ln1360">  // convert to greyscale image</a>
<a name="ln1361">  rgb2grey256(in, greyscale, width, height);</a>
<a name="ln1362"> </a>
<a name="ln1363">  // if requested perform an additional edge enhancement step</a>
<a name="ln1364">  if(enhance &amp; ASHIFT_ENHANCE_EDGES)</a>
<a name="ln1365">  {</a>
<a name="ln1366">    (void)edge_enhance(greyscale, greyscale, width, height);</a>
<a name="ln1367">  }</a>
<a name="ln1368"> </a>
<a name="ln1369">  // call the line segment detector LSD;</a>
<a name="ln1370">  // LSD stores the number of found lines in lines_count.</a>
<a name="ln1371">  // it returns structural details as vector 'double lines[7 * lines_count]'</a>
<a name="ln1372">  int lines_count;</a>
<a name="ln1373">  lsd_lines = LineSegmentDetection(&amp;lines_count, greyscale, width, height,</a>
<a name="ln1374">                                   LSD_SCALE, LSD_SIGMA_SCALE, LSD_QUANT,</a>
<a name="ln1375">                                   LSD_ANG_TH, LSD_LOG_EPS, LSD_DENSITY_TH,</a>
<a name="ln1376">                                   LSD_N_BINS, NULL, NULL, NULL);</a>
<a name="ln1377"> </a>
<a name="ln1378">  // we count the lines that we really want to use</a>
<a name="ln1379">  int lct = 0;</a>
<a name="ln1380"> </a>
<a name="ln1381">  if(lines_count &gt; 0)</a>
<a name="ln1382">  {</a>
<a name="ln1383">    // aggregate lines data into our own structures</a>
<a name="ln1384">    ashift_lines = (dt_iop_ashift_line_t *)malloc((size_t)lines_count * sizeof(dt_iop_ashift_line_t));</a>
<a name="ln1385">    if(ashift_lines == NULL) goto error;</a>
<a name="ln1386"> </a>
<a name="ln1387">    for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln1388">    {</a>
<a name="ln1389">      float x1 = lsd_lines[n * 7 + 0];</a>
<a name="ln1390">      float y1 = lsd_lines[n * 7 + 1];</a>
<a name="ln1391">      float x2 = lsd_lines[n * 7 + 2];</a>
<a name="ln1392">      float y2 = lsd_lines[n * 7 + 3];</a>
<a name="ln1393"> </a>
<a name="ln1394">      // check for lines running along image borders and skip them.</a>
<a name="ln1395">      // these would likely be false-positives which could result</a>
<a name="ln1396">      // from any kind of processing artifacts</a>
<a name="ln1397">      if((fabs(x1 - x2) &lt; 1 &amp;&amp; fmax(x1, x2) &lt; 2) ||</a>
<a name="ln1398">         (fabs(x1 - x2) &lt; 1 &amp;&amp; fmin(x1, x2) &gt; width - 3) ||</a>
<a name="ln1399">         (fabs(y1 - y2) &lt; 1 &amp;&amp; fmax(y1, y2) &lt; 2) ||</a>
<a name="ln1400">         (fabs(y1 - y2) &lt; 1 &amp;&amp; fmin(y1, y2) &gt; height - 3))</a>
<a name="ln1401">        continue;</a>
<a name="ln1402"> </a>
<a name="ln1403">      // line position in absolute coordinates</a>
<a name="ln1404">      float px1 = x_off + x1;</a>
<a name="ln1405">      float py1 = y_off + y1;</a>
<a name="ln1406">      float px2 = x_off + x2;</a>
<a name="ln1407">      float py2 = y_off + y2;</a>
<a name="ln1408"> </a>
<a name="ln1409">      // scale back to input buffer</a>
<a name="ln1410">      px1 /= scale;</a>
<a name="ln1411">      py1 /= scale;</a>
<a name="ln1412">      px2 /= scale;</a>
<a name="ln1413">      py2 /= scale;</a>
<a name="ln1414"> </a>
<a name="ln1415">      // store as homogeneous coordinates</a>
<a name="ln1416">      ashift_lines[lct].p1[0] = px1;</a>
<a name="ln1417">      ashift_lines[lct].p1[1] = py1;</a>
<a name="ln1418">      ashift_lines[lct].p1[2] = 1.0f;</a>
<a name="ln1419">      ashift_lines[lct].p2[0] = px2;</a>
<a name="ln1420">      ashift_lines[lct].p2[1] = py2;</a>
<a name="ln1421">      ashift_lines[lct].p2[2] = 1.0f;</a>
<a name="ln1422"> </a>
<a name="ln1423">      // calculate homogeneous coordinates of connecting line (defined by the two points)</a>
<a name="ln1424">      vec3prodn(ashift_lines[lct].L, ashift_lines[lct].p1, ashift_lines[lct].p2);</a>
<a name="ln1425"> </a>
<a name="ln1426">      // normalaze line coordinates so that x^2 + y^2 = 1</a>
<a name="ln1427">      // (this will always succeed as L is a real line connecting two real points)</a>
<a name="ln1428">      vec3lnorm(ashift_lines[lct].L, ashift_lines[lct].L);</a>
<a name="ln1429"> </a>
<a name="ln1430">      // length and width of rectangle (see LSD)</a>
<a name="ln1431">      ashift_lines[lct].length = sqrt((px2 - px1) * (px2 - px1) + (py2 - py1) * (py2 - py1));</a>
<a name="ln1432">      ashift_lines[lct].width = lsd_lines[n * 7 + 4] / scale;</a>
<a name="ln1433"> </a>
<a name="ln1434">      // ...  and weight (= length * width * angle precision)</a>
<a name="ln1435">      const float weight = ashift_lines[lct].length * ashift_lines[lct].width * lsd_lines[n * 7 + 5];</a>
<a name="ln1436">      ashift_lines[lct].weight = weight;</a>
<a name="ln1437"> </a>
<a name="ln1438"> </a>
<a name="ln1439">      const float angle = atan2(py2 - py1, px2 - px1) / M_PI * 180.0f;</a>
<a name="ln1440">      const int vertical = fabs(fabs(angle) - 90.0f) &lt; MAX_TANGENTIAL_DEVIATION ? 1 : 0;</a>
<a name="ln1441">      const int horizontal = fabs(fabs(fabs(angle) - 90.0f) - 90.0f) &lt; MAX_TANGENTIAL_DEVIATION ? 1 : 0;</a>
<a name="ln1442"> </a>
<a name="ln1443">      const int relevant = ashift_lines[lct].length &gt; MIN_LINE_LENGTH ? 1 : 0;</a>
<a name="ln1444"> </a>
<a name="ln1445">      // register type of line</a>
<a name="ln1446">      dt_iop_ashift_linetype_t type = ASHIFT_LINE_IRRELEVANT;</a>
<a name="ln1447">      if(vertical &amp;&amp; relevant)</a>
<a name="ln1448">      {</a>
<a name="ln1449">        type = ASHIFT_LINE_VERTICAL_SELECTED;</a>
<a name="ln1450">        vertical_count++;</a>
<a name="ln1451">        vertical_weight += weight;</a>
<a name="ln1452">      }</a>
<a name="ln1453">      else if(horizontal &amp;&amp; relevant)</a>
<a name="ln1454">      {</a>
<a name="ln1455">        type = ASHIFT_LINE_HORIZONTAL_SELECTED;</a>
<a name="ln1456">        horizontal_count++;</a>
<a name="ln1457">        horizontal_weight += weight;</a>
<a name="ln1458">      }</a>
<a name="ln1459">      ashift_lines[lct].type = type;</a>
<a name="ln1460"> </a>
<a name="ln1461">      // the next valid line</a>
<a name="ln1462">      lct++;</a>
<a name="ln1463">    }</a>
<a name="ln1464">  }</a>
<a name="ln1465">#ifdef ASHIFT_DEBUG</a>
<a name="ln1466">    printf(&quot;%d lines (vertical %d, horizontal %d, not relevant %d)\n&quot;, lines_count, vertical_count,</a>
<a name="ln1467">           horizontal_count, lct - vertical_count - horizontal_count);</a>
<a name="ln1468">    float xmin = FLT_MAX, xmax = FLT_MIN, ymin = FLT_MAX, ymax = FLT_MIN;</a>
<a name="ln1469">    for(int n = 0; n &lt; lct; n++)</a>
<a name="ln1470">    {</a>
<a name="ln1471">      xmin = fmin(xmin, fmin(ashift_lines[n].p1[0], ashift_lines[n].p2[0]));</a>
<a name="ln1472">      xmax = fmax(xmax, fmax(ashift_lines[n].p1[0], ashift_lines[n].p2[0]));</a>
<a name="ln1473">      ymin = fmin(ymin, fmin(ashift_lines[n].p1[1], ashift_lines[n].p2[1]));</a>
<a name="ln1474">      ymax = fmax(ymax, fmax(ashift_lines[n].p1[1], ashift_lines[n].p2[1]));</a>
<a name="ln1475">      printf(&quot;x1 %.0f, y1 %.0f, x2 %.0f, y2 %.0f, length %.0f, width %f, X %f, Y %f, Z %f, type %d, scalars %f %f\n&quot;,</a>
<a name="ln1476">             ashift_lines[n].p1[0], ashift_lines[n].p1[1], ashift_lines[n].p2[0], ashift_lines[n].p2[1],</a>
<a name="ln1477">             ashift_lines[n].length, ashift_lines[n].width,</a>
<a name="ln1478">             ashift_lines[n].L[0], ashift_lines[n].L[1], ashift_lines[n].L[2], ashift_lines[n].type,</a>
<a name="ln1479">             vec3scalar(ashift_lines[n].p1, ashift_lines[n].L),</a>
<a name="ln1480">             vec3scalar(ashift_lines[n].p2, ashift_lines[n].L));</a>
<a name="ln1481">    }</a>
<a name="ln1482">    printf(&quot;xmin %.0f, xmax %.0f, ymin %.0f, ymax %.0f\n&quot;, xmin, xmax, ymin, ymax);</a>
<a name="ln1483">#endif</a>
<a name="ln1484"> </a>
<a name="ln1485">  // store results in provided locations</a>
<a name="ln1486">  *lcount = lct;</a>
<a name="ln1487">  *vcount = vertical_count;</a>
<a name="ln1488">  *vweight = vertical_weight;</a>
<a name="ln1489">  *hcount = horizontal_count;</a>
<a name="ln1490">  *hweight = horizontal_weight;</a>
<a name="ln1491">  *alines = ashift_lines;</a>
<a name="ln1492"> </a>
<a name="ln1493">  // free intermediate buffers</a>
<a name="ln1494">  free(lsd_lines);</a>
<a name="ln1495">  free(greyscale);</a>
<a name="ln1496">  return lct &gt; 0 ? TRUE : FALSE;</a>
<a name="ln1497"> </a>
<a name="ln1498">error:</a>
<a name="ln1499">  free(lsd_lines);</a>
<a name="ln1500">  free(greyscale);</a>
<a name="ln1501">  return FALSE;</a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>
<a name="ln1504">// get image from buffer, analyze for structure and save results</a>
<a name="ln1505">static int get_structure(dt_iop_module_t *module, dt_iop_ashift_enhance_t enhance)</a>
<a name="ln1506">{</a>
<a name="ln1507">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln1508"> </a>
<a name="ln1509">  float *buffer = NULL;</a>
<a name="ln1510">  int width = 0;</a>
<a name="ln1511">  int height = 0;</a>
<a name="ln1512">  int x_off = 0;</a>
<a name="ln1513">  int y_off = 0;</a>
<a name="ln1514">  float scale = 0.0f;</a>
<a name="ln1515"> </a>
<a name="ln1516">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln1517">  // read buffer data if they are available</a>
<a name="ln1518">  if(g-&gt;buf != NULL)</a>
<a name="ln1519">  {</a>
<a name="ln1520">    width = g-&gt;buf_width;</a>
<a name="ln1521">    height = g-&gt;buf_height;</a>
<a name="ln1522">    x_off = g-&gt;buf_x_off;</a>
<a name="ln1523">    y_off = g-&gt;buf_y_off;</a>
<a name="ln1524">    scale = g-&gt;buf_scale;</a>
<a name="ln1525"> </a>
<a name="ln1526">    // create a temporary buffer to hold image data</a>
<a name="ln1527">    buffer = malloc((size_t)width * height * 4 * sizeof(float));</a>
<a name="ln1528">    if(buffer != NULL)</a>
<a name="ln1529">      memcpy(buffer, g-&gt;buf, (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln1530">  }</a>
<a name="ln1531">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln1532"> </a>
<a name="ln1533">  if(buffer == NULL) goto error;</a>
<a name="ln1534"> </a>
<a name="ln1535">  // get rid of old structural data</a>
<a name="ln1536">  g-&gt;lines_count = 0;</a>
<a name="ln1537">  g-&gt;vertical_count = 0;</a>
<a name="ln1538">  g-&gt;horizontal_count = 0;</a>
<a name="ln1539">  free(g-&gt;lines);</a>
<a name="ln1540">  g-&gt;lines = NULL;</a>
<a name="ln1541"> </a>
<a name="ln1542">  dt_iop_ashift_line_t *lines;</a>
<a name="ln1543">  int lines_count;</a>
<a name="ln1544">  int vertical_count;</a>
<a name="ln1545">  int horizontal_count;</a>
<a name="ln1546">  float vertical_weight;</a>
<a name="ln1547">  float horizontal_weight;</a>
<a name="ln1548"> </a>
<a name="ln1549">  // get new structural data</a>
<a name="ln1550">  if(!line_detect(buffer, width, height, x_off, y_off, scale, &amp;lines, &amp;lines_count,</a>
<a name="ln1551">                  &amp;vertical_count, &amp;horizontal_count, &amp;vertical_weight, &amp;horizontal_weight,</a>
<a name="ln1552">                  enhance, dt_image_is_raw(&amp;module-&gt;dev-&gt;image_storage)))</a>
<a name="ln1553">    goto error;</a>
<a name="ln1554"> </a>
<a name="ln1555">  // save new structural data</a>
<a name="ln1556">  g-&gt;lines_in_width = width;</a>
<a name="ln1557">  g-&gt;lines_in_height = height;</a>
<a name="ln1558">  g-&gt;lines_x_off = x_off;</a>
<a name="ln1559">  g-&gt;lines_y_off = y_off;</a>
<a name="ln1560">  g-&gt;lines_count = lines_count;</a>
<a name="ln1561">  g-&gt;vertical_count = vertical_count;</a>
<a name="ln1562">  g-&gt;horizontal_count = horizontal_count;</a>
<a name="ln1563">  g-&gt;vertical_weight = vertical_weight;</a>
<a name="ln1564">  g-&gt;horizontal_weight = horizontal_weight;</a>
<a name="ln1565">  g-&gt;lines_version++;</a>
<a name="ln1566">  g-&gt;lines_suppressed = 0;</a>
<a name="ln1567">  g-&gt;lines = lines;</a>
<a name="ln1568"> </a>
<a name="ln1569">  free(buffer);</a>
<a name="ln1570">  return TRUE;</a>
<a name="ln1571"> </a>
<a name="ln1572">error:</a>
<a name="ln1573">  free(buffer);</a>
<a name="ln1574">  return FALSE;</a>
<a name="ln1575">}</a>
<a name="ln1576"> </a>
<a name="ln1577"> </a>
<a name="ln1578">// swap two integer values</a>
<a name="ln1579">static inline void swap(int *a, int *b)</a>
<a name="ln1580">{</a>
<a name="ln1581">  int tmp = *a;</a>
<a name="ln1582">  *a = *b;</a>
<a name="ln1583">  *b = tmp;</a>
<a name="ln1584">}</a>
<a name="ln1585"> </a>
<a name="ln1586">// do complete permutations</a>
<a name="ln1587">static int quickperm(int *a, int *p, const int N, int *i)</a>
<a name="ln1588">{</a>
<a name="ln1589">  if(*i &gt;= N) return FALSE;</a>
<a name="ln1590"> </a>
<a name="ln1591">  p[*i]--;</a>
<a name="ln1592">  int j = (*i % 2 == 1) ? p[*i] : 0;</a>
<a name="ln1593">  swap(&amp;a[j], &amp;a[*i]);</a>
<a name="ln1594">  *i = 1;</a>
<a name="ln1595">  while(p[*i] == 0)</a>
<a name="ln1596">  {</a>
<a name="ln1597">    p[*i] = *i;</a>
<a name="ln1598">    (*i)++;</a>
<a name="ln1599">  }</a>
<a name="ln1600">  return TRUE;</a>
<a name="ln1601">}</a>
<a name="ln1602"> </a>
<a name="ln1603">// Fisher-Yates shuffle</a>
<a name="ln1604">static void shuffle(int *a, const int N)</a>
<a name="ln1605">{</a>
<a name="ln1606">  for(int i = 0; i &lt; N; i++)</a>
<a name="ln1607">  {</a>
<a name="ln1608">    int j = i + rand() % (N - i);</a>
<a name="ln1609">    swap(&amp;a[j], &amp;a[i]);</a>
<a name="ln1610">  }</a>
<a name="ln1611">}</a>
<a name="ln1612"> </a>
<a name="ln1613">// factorial function</a>
<a name="ln1614">static int fact(const int n)</a>
<a name="ln1615">{</a>
<a name="ln1616">  return (n == 1 ? 1 : n * fact(n - 1));</a>
<a name="ln1617">}</a>
<a name="ln1618"> </a>
<a name="ln1619">// We use a pseudo-RANSAC algorithm to elminiate ouliers from our set of lines. The</a>
<a name="ln1620">// original RANSAC works on linear optimization problems. Our model is nonlinear. We</a>
<a name="ln1621">// take advantage of the fact that lines interesting for our model are vantage lines</a>
<a name="ln1622">// that meet in one vantage point for each subset of lines (vertical/horizontal).</a>
<a name="ln1623">// Stragegy: we construct a model by (random) sampling within the subset of lines and</a>
<a name="ln1624">// calculate the vantage point. Then we check the &quot;distance&quot; of all other lines to the</a>
<a name="ln1625">// vantage point. The model that gives highest number of lines combined with the highest</a>
<a name="ln1626">// total weight and lowest overall &quot;distance&quot; wins.</a>
<a name="ln1627">// Disadvantage: compared to the original RANSAC we don't get any model parameters that</a>
<a name="ln1628">// we could use for the following NMS fit.</a>
<a name="ln1629">// Self-tuning: we optimize &quot;epsilon&quot;, the hurdle rate to reject a line as an outlier,</a>
<a name="ln1630">// by a number of dry runs first. The target average percentage value of lines to eliminate as</a>
<a name="ln1631">// outliers (without judging on the quality of the model) is given by RANSAC_ELIMINATION_RATIO,</a>
<a name="ln1632">// note: the actual percentage of outliers removed in the final run will be lower because we</a>
<a name="ln1633">// will finally look for the best quality model with the optimized epsilon and that quality value also</a>
<a name="ln1634">// encloses the number of good lines</a>
<a name="ln1635">static void ransac(const dt_iop_ashift_line_t *lines, int *index_set, int *inout_set,</a>
<a name="ln1636">                  const int set_count, const float total_weight, const int xmin, const int xmax,</a>
<a name="ln1637">                  const int ymin, const int ymax)</a>
<a name="ln1638">{</a>
<a name="ln1639">  if(set_count &lt; 3) return;</a>
<a name="ln1640"> </a>
<a name="ln1641">  const size_t set_size = set_count * sizeof(int);</a>
<a name="ln1642">  int *best_set = malloc(set_size);</a>
<a name="ln1643">  memcpy(best_set, index_set, set_size);</a>
<a name="ln1644">  int *best_inout = calloc(1, set_size);</a>
<a name="ln1645"> </a>
<a name="ln1646">  float best_quality = 0.0f;</a>
<a name="ln1647"> </a>
<a name="ln1648">  // hurdle value epsilon for rejecting a line as an outlier will be self-tuning</a>
<a name="ln1649">  // in a number of dry runs</a>
<a name="ln1650">  float epsilon = pow(10.0f, -RANSAC_EPSILON);</a>
<a name="ln1651">  float epsilon_step = RANSAC_EPSILON_STEP;</a>
<a name="ln1652">  // some accounting variables for self-tuning</a>
<a name="ln1653">  int lines_eliminated = 0;</a>
<a name="ln1654">  int valid_runs = 0;</a>
<a name="ln1655"> </a>
<a name="ln1656">  // number of runs to optimize epsilon</a>
<a name="ln1657">  const int optiruns = RANSAC_OPTIMIZATION_STEPS * RANSAC_OPTIMIZATION_DRY_RUNS;</a>
<a name="ln1658">  // go for complete permutations on small set sizes, else for random sample consensus</a>
<a name="ln1659">  const int riter = (set_count &gt; RANSAC_HURDLE) ? RANSAC_RUNS : fact(set_count);</a>
<a name="ln1660"> </a>
<a name="ln1661">  // some data needed for quickperm</a>
<a name="ln1662">  int *perm = malloc((set_count + 1) * sizeof(int));</a>
<a name="ln1663">  for(int n = 0; n &lt; set_count + 1; n++) perm[n] = n;</a>
<a name="ln1664">  int piter = 1;</a>
<a name="ln1665"> </a>
<a name="ln1666">  // inout holds good/bad qualification for each line</a>
<a name="ln1667">  int *inout = malloc(set_size);</a>
<a name="ln1668"> </a>
<a name="ln1669">  for(int r = 0; r &lt; optiruns + riter; r++)</a>
<a name="ln1670">  {</a>
<a name="ln1671">    // get random or systematic variation of index set</a>
<a name="ln1672">    if(set_count &gt; RANSAC_HURDLE || r &lt; optiruns)</a>
<a name="ln1673">      shuffle(index_set, set_count);</a>
<a name="ln1674">    else</a>
<a name="ln1675">      (void)quickperm(index_set, perm, set_count, &amp;piter);</a>
<a name="ln1676"> </a>
<a name="ln1677">    // summed quality evaluation of this run</a>
<a name="ln1678">    float quality = 0.0f;</a>
<a name="ln1679"> </a>
<a name="ln1680">    // we build a model ouf of the first two lines</a>
<a name="ln1681">    const float *L1 = lines[index_set[0]].L;</a>
<a name="ln1682">    const float *L2 = lines[index_set[1]].L;</a>
<a name="ln1683"> </a>
<a name="ln1684">    // get intersection point (ideally a vantage point)</a>
<a name="ln1685">    float V[3];</a>
<a name="ln1686">    vec3prodn(V, L1, L2);</a>
<a name="ln1687"> </a>
<a name="ln1688">    // catch special cases:</a>
<a name="ln1689">    // a) L1 and L2 are identical -&gt; V is NULL -&gt; no valid vantage point</a>
<a name="ln1690">    // b) vantage point lies inside image frame (no chance to correct for this case)</a>
<a name="ln1691">    if(vec3isnull(V) ||</a>
<a name="ln1692">       (fabs(V[2]) &gt; 0.0f &amp;&amp;</a>
<a name="ln1693">        V[0]/V[2] &gt;= xmin &amp;&amp;</a>
<a name="ln1694">        V[1]/V[2] &gt;= ymin &amp;&amp;</a>
<a name="ln1695">        V[0]/V[2] &lt;= xmax &amp;&amp;</a>
<a name="ln1696">        V[1]/V[2] &lt;= ymax))</a>
<a name="ln1697">    {</a>
<a name="ln1698">      // no valid model</a>
<a name="ln1699">      quality = 0.0f;</a>
<a name="ln1700">    }</a>
<a name="ln1701">    else</a>
<a name="ln1702">    {</a>
<a name="ln1703">      // valid model</a>
<a name="ln1704"> </a>
<a name="ln1705">      // normalize V so that x^2 + y^2 + z^2 = 1</a>
<a name="ln1706">      vec3norm(V, V);</a>
<a name="ln1707"> </a>
<a name="ln1708">      // the two lines constituting the model are part of the set</a>
<a name="ln1709">      inout[0] = 1;</a>
<a name="ln1710">      inout[1] = 1;</a>
<a name="ln1711"> </a>
<a name="ln1712">      // go through all remaining lines, check if they are within the model, and</a>
<a name="ln1713">      // mark that fact in inout[].</a>
<a name="ln1714">      // summarize a quality parameter for all lines within the model</a>
<a name="ln1715">      for(int n = 2; n &lt; set_count; n++)</a>
<a name="ln1716">      {</a>
<a name="ln1717">        // L is normalized so that x^2 + y^2 = 1</a>
<a name="ln1718">        const float *L3 = lines[index_set[n]].L;</a>
<a name="ln1719"> </a>
<a name="ln1720">        // we take the absolute value of the dot product of V and L as a measure</a>
<a name="ln1721">        // of the &quot;distance&quot; between point and line. Note that this is not the real euclidian</a>
<a name="ln1722">        // distance but - with the given normalization - just a pragmatically selected number</a>
<a name="ln1723">        // that goes to zero if V lies on L and increases the more V and L are apart</a>
<a name="ln1724">        const float d = fabs(vec3scalar(V, L3));</a>
<a name="ln1725"> </a>
<a name="ln1726">        // depending on d we either include or exclude the point from the set</a>
<a name="ln1727">        inout[n] = (d &lt; epsilon) ? 1 : 0;</a>
<a name="ln1728"> </a>
<a name="ln1729">        float q;</a>
<a name="ln1730"> </a>
<a name="ln1731">        if(inout[n] == 1)</a>
<a name="ln1732">        {</a>
<a name="ln1733">          // a quality parameter that depends 1/3 on the number of lines within the model,</a>
<a name="ln1734">          // 1/3 on their weight, and 1/3 on their weighted distance d to the vantage point</a>
<a name="ln1735">          q = 0.33f / (float)set_count</a>
<a name="ln1736">              + 0.33f * lines[index_set[n]].weight / total_weight</a>
<a name="ln1737">              + 0.33f * (1.0f - d / epsilon) * (float)set_count * lines[index_set[n]].weight / total_weight;</a>
<a name="ln1738">        }</a>
<a name="ln1739">        else</a>
<a name="ln1740">        {</a>
<a name="ln1741">          q = 0.0f;</a>
<a name="ln1742">          lines_eliminated++;</a>
<a name="ln1743">        }</a>
<a name="ln1744"> </a>
<a name="ln1745">        quality += q;</a>
<a name="ln1746">      }</a>
<a name="ln1747">      valid_runs++;</a>
<a name="ln1748">    }</a>
<a name="ln1749"> </a>
<a name="ln1750">    if(r &lt; optiruns)</a>
<a name="ln1751">    {</a>
<a name="ln1752">      // on last run of each self-tuning step</a>
<a name="ln1753">      if((r % RANSAC_OPTIMIZATION_DRY_RUNS) == (RANSAC_OPTIMIZATION_DRY_RUNS - 1) &amp;&amp; (valid_runs &gt; 0))</a>
<a name="ln1754">      {</a>
<a name="ln1755">#ifdef ASHIFT_DEBUG</a>
<a name="ln1756">        printf(&quot;ransac self-tuning (run %d): epsilon %f&quot;, r, epsilon);</a>
<a name="ln1757">#endif</a>
<a name="ln1758">        // average ratio of lines that we eliminated with the given epsilon</a>
<a name="ln1759">        float ratio = 100.0f * (float)lines_eliminated / ((float)set_count * valid_runs);</a>
<a name="ln1760">        // adjust epsilon accordingly</a>
<a name="ln1761">        if(ratio &lt; RANSAC_ELIMINATION_RATIO)</a>
<a name="ln1762">          epsilon = pow(10.0f, log10(epsilon) - epsilon_step);</a>
<a name="ln1763">        else if(ratio &gt; RANSAC_ELIMINATION_RATIO)</a>
<a name="ln1764">          epsilon = pow(10.0f, log10(epsilon) + epsilon_step);</a>
<a name="ln1765">#ifdef ASHIFT_DEBUG</a>
<a name="ln1766">        printf(&quot; (elimination ratio %f) -&gt; %f\n&quot;, ratio, epsilon);</a>
<a name="ln1767">#endif</a>
<a name="ln1768">        // reduce step-size for next optimization round</a>
<a name="ln1769">        epsilon_step /= 2.0f;</a>
<a name="ln1770">        lines_eliminated = 0;</a>
<a name="ln1771">        valid_runs = 0;</a>
<a name="ln1772">      }</a>
<a name="ln1773">    }</a>
<a name="ln1774">    else</a>
<a name="ln1775">    {</a>
<a name="ln1776">      // in the &quot;real&quot; runs check against the best model found so far</a>
<a name="ln1777">      if(quality &gt; best_quality)</a>
<a name="ln1778">      {</a>
<a name="ln1779">        memcpy(best_set, index_set, set_size);</a>
<a name="ln1780">        memcpy(best_inout, inout, set_size);</a>
<a name="ln1781">        best_quality = quality;</a>
<a name="ln1782">      }</a>
<a name="ln1783">    }</a>
<a name="ln1784"> </a>
<a name="ln1785">#ifdef ASHIFT_DEBUG</a>
<a name="ln1786">    // report some statistics</a>
<a name="ln1787">    int count = 0, lastcount = 0;</a>
<a name="ln1788">    for(int n = 0; n &lt; set_count; n++) count += best_inout[n];</a>
<a name="ln1789">    for(int n = 0; n &lt; set_count; n++) lastcount += inout[n];</a>
<a name="ln1790">    printf(&quot;ransac run %d: best qual %.6f, eps %.6f, line count %d of %d (this run: qual %.5f, count %d (%2f%%))\n&quot;, r,</a>
<a name="ln1791">           best_quality, epsilon, count, set_count, quality, lastcount, 100.0f * lastcount / (float)set_count);</a>
<a name="ln1792">#endif</a>
<a name="ln1793">  }</a>
<a name="ln1794"> </a>
<a name="ln1795">  // store back best set</a>
<a name="ln1796">  memcpy(index_set, best_set, set_size);</a>
<a name="ln1797">  memcpy(inout_set, best_inout, set_size);</a>
<a name="ln1798"> </a>
<a name="ln1799">  free(inout);</a>
<a name="ln1800">  free(perm);</a>
<a name="ln1801">  free(best_inout);</a>
<a name="ln1802">  free(best_set);</a>
<a name="ln1803">}</a>
<a name="ln1804"> </a>
<a name="ln1805"> </a>
<a name="ln1806">// try to clean up structural data by eliminating outliers and thereby increasing</a>
<a name="ln1807">// the chance of a convergent fitting</a>
<a name="ln1808">static int remove_outliers(dt_iop_module_t *module)</a>
<a name="ln1809">{</a>
<a name="ln1810">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln1811"> </a>
<a name="ln1812">  const int width = g-&gt;lines_in_width;</a>
<a name="ln1813">  const int height = g-&gt;lines_in_height;</a>
<a name="ln1814">  const int xmin = g-&gt;lines_x_off;</a>
<a name="ln1815">  const int ymin = g-&gt;lines_y_off;</a>
<a name="ln1816">  const int xmax = xmin + width;</a>
<a name="ln1817">  const int ymax = ymin + height;</a>
<a name="ln1818"> </a>
<a name="ln1819">  // holds the index set of lines we want to work on</a>
<a name="ln1820">  int *lines_set = malloc(g-&gt;lines_count * sizeof(int));</a>
<a name="ln1821">  // holds the result of ransac</a>
<a name="ln1822">  int *inout_set = malloc(g-&gt;lines_count * sizeof(int));</a>
<a name="ln1823"> </a>
<a name="ln1824">  // some accounting variables</a>
<a name="ln1825">  int vnb = 0, vcount = 0;</a>
<a name="ln1826">  int hnb = 0, hcount = 0;</a>
<a name="ln1827"> </a>
<a name="ln1828">  // just to be on the safe side</a>
<a name="ln1829">  if(g-&gt;lines == NULL) goto error;</a>
<a name="ln1830"> </a>
<a name="ln1831">  // generate index list for the vertical lines</a>
<a name="ln1832">  for(int n = 0; n &lt; g-&gt;lines_count; n++)</a>
<a name="ln1833">  {</a>
<a name="ln1834">    // is this a selected vertical line?</a>
<a name="ln1835">    if((g-&gt;lines[n].type &amp; ASHIFT_LINE_MASK) != ASHIFT_LINE_VERTICAL_SELECTED)</a>
<a name="ln1836">      continue;</a>
<a name="ln1837"> </a>
<a name="ln1838">    lines_set[vnb] = n;</a>
<a name="ln1839">    inout_set[vnb] = 0;</a>
<a name="ln1840">    vnb++;</a>
<a name="ln1841">  }</a>
<a name="ln1842"> </a>
<a name="ln1843">  // it only makes sense to call ransac if we have more than two lines</a>
<a name="ln1844">  if(vnb &gt; 2)</a>
<a name="ln1845">    ransac(g-&gt;lines, lines_set, inout_set, vnb, g-&gt;vertical_weight,</a>
<a name="ln1846">           xmin, xmax, ymin, ymax);</a>
<a name="ln1847"> </a>
<a name="ln1848">  // adjust line selected flag according to the ransac results</a>
<a name="ln1849">  for(int n = 0; n &lt; vnb; n++)</a>
<a name="ln1850">  {</a>
<a name="ln1851">    const int m = lines_set[n];</a>
<a name="ln1852">    if(inout_set[n] == 1)</a>
<a name="ln1853">    {</a>
<a name="ln1854">      g-&gt;lines[m].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln1855">      vcount++;</a>
<a name="ln1856">    }</a>
<a name="ln1857">    else</a>
<a name="ln1858">      g-&gt;lines[m].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln1859">  }</a>
<a name="ln1860">  // update number of vertical lines</a>
<a name="ln1861">  g-&gt;vertical_count = vcount;</a>
<a name="ln1862">  g-&gt;lines_version++;</a>
<a name="ln1863"> </a>
<a name="ln1864">  // now generate index list for the horizontal lines</a>
<a name="ln1865">  for(int n = 0; n &lt; g-&gt;lines_count; n++)</a>
<a name="ln1866">  {</a>
<a name="ln1867">    // is this a selected horizontal line?</a>
<a name="ln1868">    if((g-&gt;lines[n].type &amp; ASHIFT_LINE_MASK) != ASHIFT_LINE_HORIZONTAL_SELECTED)</a>
<a name="ln1869">      continue;</a>
<a name="ln1870"> </a>
<a name="ln1871">    lines_set[hnb] = n;</a>
<a name="ln1872">    inout_set[hnb] = 0;</a>
<a name="ln1873">    hnb++;</a>
<a name="ln1874">  }</a>
<a name="ln1875"> </a>
<a name="ln1876">  // it only makes sense to call ransac if we have more than two lines</a>
<a name="ln1877">  if(hnb &gt; 2)</a>
<a name="ln1878">    ransac(g-&gt;lines, lines_set, inout_set, hnb, g-&gt;horizontal_weight,</a>
<a name="ln1879">           xmin, xmax, ymin, ymax);</a>
<a name="ln1880"> </a>
<a name="ln1881">  // adjust line selected flag according to the ransac results</a>
<a name="ln1882">  for(int n = 0; n &lt; hnb; n++)</a>
<a name="ln1883">  {</a>
<a name="ln1884">    const int m = lines_set[n];</a>
<a name="ln1885">    if(inout_set[n] == 1)</a>
<a name="ln1886">    {</a>
<a name="ln1887">      g-&gt;lines[m].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln1888">      hcount++;</a>
<a name="ln1889">    }</a>
<a name="ln1890">    else</a>
<a name="ln1891">      g-&gt;lines[m].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln1892">  }</a>
<a name="ln1893">  // update number of horizontal lines</a>
<a name="ln1894">  g-&gt;horizontal_count = hcount;</a>
<a name="ln1895">  g-&gt;lines_version++;</a>
<a name="ln1896"> </a>
<a name="ln1897">  free(inout_set);</a>
<a name="ln1898">  free(lines_set);</a>
<a name="ln1899"> </a>
<a name="ln1900">  return TRUE;</a>
<a name="ln1901"> </a>
<a name="ln1902">error:</a>
<a name="ln1903">  free(inout_set);</a>
<a name="ln1904">  free(lines_set);</a>
<a name="ln1905">  return FALSE;</a>
<a name="ln1906">}</a>
<a name="ln1907"> </a>
<a name="ln1908">// utility function to map a variable in [min; max] to [-INF; + INF]</a>
<a name="ln1909">static inline double logit(double x, double min, double max)</a>
<a name="ln1910">{</a>
<a name="ln1911">  const double eps = 1.0e-6;</a>
<a name="ln1912">  // make sure p does not touch the borders of its definition area,</a>
<a name="ln1913">  // not critical for data accuracy as logit() is only used on initial fit parameters</a>
<a name="ln1914">  double p = CLAMP((x - min) / (max - min), eps, 1.0 - eps);</a>
<a name="ln1915"> </a>
<a name="ln1916">  return (2.0 * atanh(2.0 * p - 1.0));</a>
<a name="ln1917">}</a>
<a name="ln1918"> </a>
<a name="ln1919">// inverted function to logit()</a>
<a name="ln1920">static inline double ilogit(double L, double min, double max)</a>
<a name="ln1921">{</a>
<a name="ln1922">  double p = 0.5 * (1.0 + tanh(0.5 * L));</a>
<a name="ln1923"> </a>
<a name="ln1924">  return (p * (max - min) + min);</a>
<a name="ln1925">}</a>
<a name="ln1926"> </a>
<a name="ln1927">// helper function for simplex() return quality parameter for the given model</a>
<a name="ln1928">// strategy:</a>
<a name="ln1929">//    * generate homography matrix out of fixed parameters and fitting parameters</a>
<a name="ln1930">//    * apply homography to all end points of affected lines</a>
<a name="ln1931">//    * generate new line out of transformed end points</a>
<a name="ln1932">//    * calculate scalar product s of line with perpendicular axis</a>
<a name="ln1933">//    * sum over weighted s^2 values</a>
<a name="ln1934">static double model_fitness(double *params, void *data)</a>
<a name="ln1935">{</a>
<a name="ln1936">  dt_iop_ashift_fit_params_t *fit = (dt_iop_ashift_fit_params_t *)data;</a>
<a name="ln1937"> </a>
<a name="ln1938">  // just for convenience: get shorter names</a>
<a name="ln1939">  dt_iop_ashift_line_t *lines = fit-&gt;lines;</a>
<a name="ln1940">  const int lines_count = fit-&gt;lines_count;</a>
<a name="ln1941">  const int width = fit-&gt;width;</a>
<a name="ln1942">  const int height = fit-&gt;height;</a>
<a name="ln1943">  const float f_length_kb = fit-&gt;f_length_kb;</a>
<a name="ln1944">  const float orthocorr = fit-&gt;orthocorr;</a>
<a name="ln1945">  const float aspect = fit-&gt;aspect;</a>
<a name="ln1946"> </a>
<a name="ln1947">  float rotation = fit-&gt;rotation;</a>
<a name="ln1948">  float lensshift_v = fit-&gt;lensshift_v;</a>
<a name="ln1949">  float lensshift_h = fit-&gt;lensshift_h;</a>
<a name="ln1950">  float shear = fit-&gt;shear;</a>
<a name="ln1951">  float rotation_range = fit-&gt;rotation_range;</a>
<a name="ln1952">  float lensshift_v_range = fit-&gt;lensshift_v_range;</a>
<a name="ln1953">  float lensshift_h_range = fit-&gt;lensshift_h_range;</a>
<a name="ln1954">  float shear_range = fit-&gt;shear_range;</a>
<a name="ln1955"> </a>
<a name="ln1956">  int pcount = 0;</a>
<a name="ln1957"> </a>
<a name="ln1958">  // fill in fit parameters from params[]. Attention: order matters!!!</a>
<a name="ln1959">  if(isnan(rotation))</a>
<a name="ln1960">  {</a>
<a name="ln1961">    rotation = ilogit(params[pcount], -rotation_range, rotation_range);</a>
<a name="ln1962">    pcount++;</a>
<a name="ln1963">  }</a>
<a name="ln1964"> </a>
<a name="ln1965">  if(isnan(lensshift_v))</a>
<a name="ln1966">  {</a>
<a name="ln1967">    lensshift_v = ilogit(params[pcount], -lensshift_v_range, lensshift_v_range);</a>
<a name="ln1968">    pcount++;</a>
<a name="ln1969">  }</a>
<a name="ln1970"> </a>
<a name="ln1971">  if(isnan(lensshift_h))</a>
<a name="ln1972">  {</a>
<a name="ln1973">    lensshift_h = ilogit(params[pcount], -lensshift_h_range, lensshift_h_range);</a>
<a name="ln1974">    pcount++;</a>
<a name="ln1975">  }</a>
<a name="ln1976"> </a>
<a name="ln1977">  if(isnan(shear))</a>
<a name="ln1978">  {</a>
<a name="ln1979">    shear = ilogit(params[pcount], -shear_range, shear_range);</a>
<a name="ln1980">    pcount++;</a>
<a name="ln1981">  }</a>
<a name="ln1982"> </a>
<a name="ln1983">  assert(pcount == fit-&gt;params_count);</a>
<a name="ln1984"> </a>
<a name="ln1985">  // the possible reference axes</a>
<a name="ln1986">  const float Av[3] = { 1.0f, 0.0f, 0.0f };</a>
<a name="ln1987">  const float Ah[3] = { 0.0f, 1.0f, 0.0f };</a>
<a name="ln1988"> </a>
<a name="ln1989">  // generate homograph out of the parameters</a>
<a name="ln1990">  float homograph[3][3];</a>
<a name="ln1991">  homography((float *)homograph, rotation, lensshift_v, lensshift_h, shear, f_length_kb,</a>
<a name="ln1992">             orthocorr, aspect, width, height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln1993"> </a>
<a name="ln1994">  // accounting variables</a>
<a name="ln1995">  double sumsq_v = 0.0;</a>
<a name="ln1996">  double sumsq_h = 0.0;</a>
<a name="ln1997">  double weight_v = 0.0;</a>
<a name="ln1998">  double weight_h = 0.0;</a>
<a name="ln1999">  int count_v = 0;</a>
<a name="ln2000">  int count_h = 0;</a>
<a name="ln2001">  int count = 0;</a>
<a name="ln2002"> </a>
<a name="ln2003">  // iterate over all lines</a>
<a name="ln2004">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln2005">  {</a>
<a name="ln2006">    // check if this is a line which we must skip</a>
<a name="ln2007">    if((lines[n].type &amp; fit-&gt;linemask) != fit-&gt;linetype)</a>
<a name="ln2008">      continue;</a>
<a name="ln2009"> </a>
<a name="ln2010">    // the direction of this line (vertical?)</a>
<a name="ln2011">    const int isvertical = lines[n].type &amp; ASHIFT_LINE_DIRVERT;</a>
<a name="ln2012"> </a>
<a name="ln2013">    // select the perpendicular reference axis</a>
<a name="ln2014">    const float *A = isvertical ? Ah : Av;</a>
<a name="ln2015"> </a>
<a name="ln2016">    // apply homographic transformation to the end points</a>
<a name="ln2017">    float P1[3], P2[3];</a>
<a name="ln2018">    mat3mulv(P1, (float *)homograph, lines[n].p1);</a>
<a name="ln2019">    mat3mulv(P2, (float *)homograph, lines[n].p2);</a>
<a name="ln2020"> </a>
<a name="ln2021">    // get line connecting the two points</a>
<a name="ln2022">    float L[3];</a>
<a name="ln2023">    vec3prodn(L, P1, P2);</a>
<a name="ln2024"> </a>
<a name="ln2025">    // normalize L so that x^2 + y^2 = 1; makes sure that</a>
<a name="ln2026">    // y^2 = 1 / (1 + m^2) and x^2 = m^2 / (1 + m^2) with m defining the slope of the line</a>
<a name="ln2027">    vec3lnorm(L, L);</a>
<a name="ln2028"> </a>
<a name="ln2029">    // get scalar product of line L with orthogonal axis A -&gt; gives 0 if line is perpendicular</a>
<a name="ln2030">    float s = vec3scalar(L, A);</a>
<a name="ln2031"> </a>
<a name="ln2032">    // sum up weighted s^2 for both directions individually</a>
<a name="ln2033">    sumsq_v += isvertical ? s * s * lines[n].weight : 0.0;</a>
<a name="ln2034">    weight_v  += isvertical ? lines[n].weight : 0.0;</a>
<a name="ln2035">    count_v += isvertical ? 1 : 0;</a>
<a name="ln2036">    sumsq_h += !isvertical ? s * s * lines[n].weight : 0.0;</a>
<a name="ln2037">    weight_h  += !isvertical ? lines[n].weight : 0.0;</a>
<a name="ln2038">    count_h += !isvertical ? 1 : 0;</a>
<a name="ln2039">    count++;</a>
<a name="ln2040">  }</a>
<a name="ln2041"> </a>
<a name="ln2042">  const double v = weight_v &gt; 0.0f &amp;&amp; count &gt; 0 ? sumsq_v / weight_v * (float)count_v / count : 0.0;</a>
<a name="ln2043">  const double h = weight_h &gt; 0.0f &amp;&amp; count &gt; 0 ? sumsq_h / weight_h * (float)count_h / count : 0.0;</a>
<a name="ln2044"> </a>
<a name="ln2045">  double sum = sqrt(1.0 - (1.0 - v) * (1.0 - h)) * 1.0e6;</a>
<a name="ln2046">  //double sum = sqrt(v + h) * 1.0e6;</a>
<a name="ln2047"> </a>
<a name="ln2048">#ifdef ASHIFT_DEBUG</a>
<a name="ln2049">  printf(&quot;fitness with rotation %f, lensshift_v %f, lensshift_h %f, shear %f -&gt; lines %d, quality %10f\n&quot;,</a>
<a name="ln2050">         rotation, lensshift_v, lensshift_h, shear, count, sum);</a>
<a name="ln2051">#endif</a>
<a name="ln2052"> </a>
<a name="ln2053">  return sum;</a>
<a name="ln2054">}</a>
<a name="ln2055"> </a>
<a name="ln2056">// setup all data structures for fitting and call NM simplex</a>
<a name="ln2057">static dt_iop_ashift_nmsresult_t nmsfit(dt_iop_module_t *module, dt_iop_ashift_params_t *p, dt_iop_ashift_fitaxis_t dir)</a>
<a name="ln2058">{</a>
<a name="ln2059">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2060"> </a>
<a name="ln2061">  if(!g-&gt;lines) return NMS_NOT_ENOUGH_LINES;</a>
<a name="ln2062">  if(dir == ASHIFT_FIT_NONE) return NMS_SUCCESS;</a>
<a name="ln2063"> </a>
<a name="ln2064">  double params[4];</a>
<a name="ln2065">  int pcount = 0;</a>
<a name="ln2066">  int enough_lines = TRUE;</a>
<a name="ln2067"> </a>
<a name="ln2068">  // initialize fit parameters</a>
<a name="ln2069">  dt_iop_ashift_fit_params_t fit;</a>
<a name="ln2070">  fit.lines = g-&gt;lines;</a>
<a name="ln2071">  fit.lines_count = g-&gt;lines_count;</a>
<a name="ln2072">  fit.width = g-&gt;lines_in_width;</a>
<a name="ln2073">  fit.height = g-&gt;lines_in_height;</a>
<a name="ln2074">  fit.f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln2075">  fit.orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln2076">  fit.aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln2077">  fit.rotation = p-&gt;rotation;</a>
<a name="ln2078">  fit.lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln2079">  fit.lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln2080">  fit.shear = p-&gt;shear;</a>
<a name="ln2081">  fit.rotation_range = g-&gt;rotation_range;</a>
<a name="ln2082">  fit.lensshift_v_range = g-&gt;lensshift_v_range;</a>
<a name="ln2083">  fit.lensshift_h_range = g-&gt;lensshift_h_range;</a>
<a name="ln2084">  fit.shear_range = g-&gt;shear_range;</a>
<a name="ln2085">  fit.linetype = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2086">  fit.linemask = ASHIFT_LINE_MASK;</a>
<a name="ln2087">  fit.params_count = 0;</a>
<a name="ln2088">  fit.weight = 0.0f;</a>
<a name="ln2089"> </a>
<a name="ln2090">  // if the image is flipped and if we do not want to fit both lens shift</a>
<a name="ln2091">  // directions or none at all, then we need to change direction</a>
<a name="ln2092">  dt_iop_ashift_fitaxis_t mdir = dir;</a>
<a name="ln2093">  if((mdir &amp; ASHIFT_FIT_LENS_BOTH) != ASHIFT_FIT_LENS_BOTH &amp;&amp;</a>
<a name="ln2094">     (mdir &amp; ASHIFT_FIT_LENS_BOTH) != 0)</a>
<a name="ln2095">  {</a>
<a name="ln2096">    // flip all directions</a>
<a name="ln2097">    mdir ^= g-&gt;isflipped ? ASHIFT_FIT_FLIP : 0;</a>
<a name="ln2098">    // special case that needs to be corrected</a>
<a name="ln2099">    mdir |= (mdir &amp; ASHIFT_FIT_LINES_BOTH) == 0 ? ASHIFT_FIT_LINES_BOTH : 0;</a>
<a name="ln2100">  }</a>
<a name="ln2101"> </a>
<a name="ln2102"> </a>
<a name="ln2103">  // prepare fit structure and starting parameters for simplex fit.</a>
<a name="ln2104">  // note: the sequence of parameters in params[] needs to match the</a>
<a name="ln2105">  // respective order in dt_iop_ashift_fit_params_t. Parameters which are</a>
<a name="ln2106">  // to be fittet are marked with NAN in the fit structure. Non-NAN</a>
<a name="ln2107">  // parameters are assumed to be constant.</a>
<a name="ln2108">  if(mdir &amp; ASHIFT_FIT_ROTATION)</a>
<a name="ln2109">  {</a>
<a name="ln2110">    // we fit rotation</a>
<a name="ln2111">    fit.params_count++;</a>
<a name="ln2112">    params[pcount] = logit(fit.rotation, -fit.rotation_range, fit.rotation_range);</a>
<a name="ln2113">    pcount++;</a>
<a name="ln2114">    fit.rotation = NAN;</a>
<a name="ln2115">  }</a>
<a name="ln2116"> </a>
<a name="ln2117">  if(mdir &amp; ASHIFT_FIT_LENS_VERT)</a>
<a name="ln2118">  {</a>
<a name="ln2119">    // we fit vertical lens shift</a>
<a name="ln2120">    fit.params_count++;</a>
<a name="ln2121">    params[pcount] = logit(fit.lensshift_v, -fit.lensshift_v_range, fit.lensshift_v_range);</a>
<a name="ln2122">    pcount++;</a>
<a name="ln2123">    fit.lensshift_v = NAN;</a>
<a name="ln2124">  }</a>
<a name="ln2125"> </a>
<a name="ln2126">  if(mdir &amp; ASHIFT_FIT_LENS_HOR)</a>
<a name="ln2127">  {</a>
<a name="ln2128">    // we fit horizontal lens shift</a>
<a name="ln2129">    fit.params_count++;</a>
<a name="ln2130">    params[pcount] = logit(fit.lensshift_h, -fit.lensshift_h_range, fit.lensshift_h_range);</a>
<a name="ln2131">    pcount++;</a>
<a name="ln2132">    fit.lensshift_h = NAN;</a>
<a name="ln2133">  }</a>
<a name="ln2134"> </a>
<a name="ln2135">  if(mdir &amp; ASHIFT_FIT_SHEAR)</a>
<a name="ln2136">  {</a>
<a name="ln2137">    // we fit the shear parameter</a>
<a name="ln2138">    fit.params_count++;</a>
<a name="ln2139">    params[pcount] = logit(fit.shear, -fit.shear_range, fit.shear_range);</a>
<a name="ln2140">    pcount++;</a>
<a name="ln2141">    fit.shear = NAN;</a>
<a name="ln2142">  }</a>
<a name="ln2143"> </a>
<a name="ln2144">  if(mdir &amp; ASHIFT_FIT_LINES_VERT)</a>
<a name="ln2145">  {</a>
<a name="ln2146">    // we use vertical lines for fitting</a>
<a name="ln2147">    fit.linetype |= ASHIFT_LINE_DIRVERT;</a>
<a name="ln2148">    fit.weight += g-&gt;vertical_weight;</a>
<a name="ln2149">    enough_lines = enough_lines &amp;&amp; (g-&gt;vertical_count &gt;= MINIMUM_FITLINES);</a>
<a name="ln2150">  }</a>
<a name="ln2151"> </a>
<a name="ln2152">  if(mdir &amp; ASHIFT_FIT_LINES_HOR)</a>
<a name="ln2153">  {</a>
<a name="ln2154">    // we use horizontal lines for fitting</a>
<a name="ln2155">    fit.linetype |= 0;</a>
<a name="ln2156">    fit.weight += g-&gt;horizontal_weight;</a>
<a name="ln2157">    enough_lines = enough_lines &amp;&amp; (g-&gt;horizontal_count &gt;= MINIMUM_FITLINES);</a>
<a name="ln2158">  }</a>
<a name="ln2159"> </a>
<a name="ln2160">  // this needs to come after ASHIFT_FIT_LINES_VERT and ASHIFT_FIT_LINES_HOR</a>
<a name="ln2161">  if((mdir &amp; ASHIFT_FIT_LINES_BOTH) == ASHIFT_FIT_LINES_BOTH)</a>
<a name="ln2162">  {</a>
<a name="ln2163">    // if we use fitting in both directions we need to</a>
<a name="ln2164">    // adjust fit.linetype and fit.linemask to match all selected lines</a>
<a name="ln2165">    fit.linetype = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2166">    fit.linemask = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2167">  }</a>
<a name="ln2168"> </a>
<a name="ln2169">  // error case: we do not run simplex if there are not enough lines</a>
<a name="ln2170">  if(!enough_lines)</a>
<a name="ln2171">  {</a>
<a name="ln2172">#ifdef ASHIFT_DEBUG</a>
<a name="ln2173">    printf(&quot;optimization not possible: insufficient number of lines\n&quot;);</a>
<a name="ln2174">#endif</a>
<a name="ln2175">    return NMS_NOT_ENOUGH_LINES;</a>
<a name="ln2176">  }</a>
<a name="ln2177"> </a>
<a name="ln2178">  // start the simplex fit</a>
<a name="ln2179">  int iter = simplex(model_fitness, params, fit.params_count, NMS_EPSILON, NMS_SCALE, NMS_ITERATIONS, NULL, (void*)&amp;fit);</a>
<a name="ln2180"> </a>
<a name="ln2181">  // error case: the fit did not converge</a>
<a name="ln2182">  if(iter &gt;= NMS_ITERATIONS)</a>
<a name="ln2183">  {</a>
<a name="ln2184">#ifdef ASHIFT_DEBUG</a>
<a name="ln2185">    printf(&quot;optimization not successful: maximum number of iterations reached (%d)\n&quot;, iter);</a>
<a name="ln2186">#endif</a>
<a name="ln2187">    return NMS_DID_NOT_CONVERGE;</a>
<a name="ln2188">  }</a>
<a name="ln2189"> </a>
<a name="ln2190">  // fit was successful: now consolidate the results (order matters!!!)</a>
<a name="ln2191">  pcount = 0;</a>
<a name="ln2192">  fit.rotation = isnan(fit.rotation) ? ilogit(params[pcount++], -fit.rotation_range, fit.rotation_range) : fit.rotation;</a>
<a name="ln2193">  fit.lensshift_v = isnan(fit.lensshift_v) ? ilogit(params[pcount++], -fit.lensshift_v_range, fit.lensshift_v_range) : fit.lensshift_v;</a>
<a name="ln2194">  fit.lensshift_h = isnan(fit.lensshift_h) ? ilogit(params[pcount++], -fit.lensshift_h_range, fit.lensshift_h_range) : fit.lensshift_h;</a>
<a name="ln2195">  fit.shear = isnan(fit.shear) ? ilogit(params[pcount++], -fit.shear_range, fit.shear_range) : fit.shear;</a>
<a name="ln2196">#ifdef ASHIFT_DEBUG</a>
<a name="ln2197">  printf(&quot;params after optimization (%d iterations): rotation %f, lensshift_v %f, lensshift_h %f, shear %f\n&quot;,</a>
<a name="ln2198">         iter, fit.rotation, fit.lensshift_v, fit.lensshift_h, fit.shear);</a>
<a name="ln2199">#endif</a>
<a name="ln2200"> </a>
<a name="ln2201">  // sanity check: in case of extreme values the image gets distorted so strongly that it spans an insanely huge area. we check that</a>
<a name="ln2202">  // case and assume values that increase the image area by more than a factor of 4 as being insane.</a>
<a name="ln2203">  float homograph[3][3];</a>
<a name="ln2204">  homography((float *)homograph, fit.rotation, fit.lensshift_v, fit.lensshift_h, fit.shear, fit.f_length_kb,</a>
<a name="ln2205">             fit.orthocorr, fit.aspect, fit.width, fit.height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln2206"> </a>
<a name="ln2207">  // visit all four corners and find maximum span</a>
<a name="ln2208">  float xm = FLT_MAX, xM = -FLT_MAX, ym = FLT_MAX, yM = -FLT_MAX;</a>
<a name="ln2209">  for(int y = 0; y &lt; fit.height; y += fit.height - 1)</a>
<a name="ln2210">    for(int x = 0; x &lt; fit.width; x += fit.width - 1)</a>
<a name="ln2211">    {</a>
<a name="ln2212">      float pi[3], po[3];</a>
<a name="ln2213">      pi[0] = x;</a>
<a name="ln2214">      pi[1] = y;</a>
<a name="ln2215">      pi[2] = 1.0f;</a>
<a name="ln2216">      mat3mulv(po, (float *)homograph, pi);</a>
<a name="ln2217">      po[0] /= po[2];</a>
<a name="ln2218">      po[1] /= po[2];</a>
<a name="ln2219">      xm = fmin(xm, po[0]);</a>
<a name="ln2220">      ym = fmin(ym, po[1]);</a>
<a name="ln2221">      xM = fmax(xM, po[0]);</a>
<a name="ln2222">      yM = fmax(yM, po[1]);</a>
<a name="ln2223">    }</a>
<a name="ln2224"> </a>
<a name="ln2225">  if((xM - xm) * (yM - ym) &gt; 4.0f * fit.width * fit.height)</a>
<a name="ln2226">  {</a>
<a name="ln2227">#ifdef ASHIFT_DEBUG</a>
<a name="ln2228">    printf(&quot;optimization not successful: degenerate case with area growth factor (%f) exceeding limits\n&quot;,</a>
<a name="ln2229">           (xM - xm) * (yM - ym) / (fit.width * fit.height));</a>
<a name="ln2230">#endif</a>
<a name="ln2231">    return NMS_INSANE;</a>
<a name="ln2232">  }</a>
<a name="ln2233"> </a>
<a name="ln2234">  // now write the results into structure p</a>
<a name="ln2235">  p-&gt;rotation = fit.rotation;</a>
<a name="ln2236">  p-&gt;lensshift_v = fit.lensshift_v;</a>
<a name="ln2237">  p-&gt;lensshift_h = fit.lensshift_h;</a>
<a name="ln2238">  p-&gt;shear = fit.shear;</a>
<a name="ln2239">  return NMS_SUCCESS;</a>
<a name="ln2240">}</a>
<a name="ln2241"> </a>
<a name="ln2242">#ifdef ASHIFT_DEBUG</a>
<a name="ln2243">// only used in development phase. call model_fitness() with current parameters and</a>
<a name="ln2244">// print some useful information</a>
<a name="ln2245">static void model_probe(dt_iop_module_t *module, dt_iop_ashift_params_t *p, dt_iop_ashift_fitaxis_t dir)</a>
<a name="ln2246">{</a>
<a name="ln2247">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2248"> </a>
<a name="ln2249">  if(!g-&gt;lines) return;</a>
<a name="ln2250">  if(dir == ASHIFT_FIT_NONE) return;</a>
<a name="ln2251"> </a>
<a name="ln2252">  double params[4];</a>
<a name="ln2253">  int enough_lines = TRUE;</a>
<a name="ln2254"> </a>
<a name="ln2255">  // initialize fit parameters</a>
<a name="ln2256">  dt_iop_ashift_fit_params_t fit;</a>
<a name="ln2257">  fit.lines = g-&gt;lines;</a>
<a name="ln2258">  fit.lines_count = g-&gt;lines_count;</a>
<a name="ln2259">  fit.width = g-&gt;lines_in_width;</a>
<a name="ln2260">  fit.height = g-&gt;lines_in_height;</a>
<a name="ln2261">  fit.f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln2262">  fit.orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln2263">  fit.aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln2264">  fit.rotation = p-&gt;rotation;</a>
<a name="ln2265">  fit.lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln2266">  fit.lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln2267">  fit.shear = p-&gt;shear;</a>
<a name="ln2268">  fit.linetype = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2269">  fit.linemask = ASHIFT_LINE_MASK;</a>
<a name="ln2270">  fit.params_count = 0;</a>
<a name="ln2271">  fit.weight = 0.0f;</a>
<a name="ln2272"> </a>
<a name="ln2273">  // if the image is flipped and if we do not want to fit both lens shift</a>
<a name="ln2274">  // directions or none at all, then we need to change direction</a>
<a name="ln2275">  dt_iop_ashift_fitaxis_t mdir = dir;</a>
<a name="ln2276">  if((mdir &amp; ASHIFT_FIT_LENS_BOTH) != ASHIFT_FIT_LENS_BOTH &amp;&amp;</a>
<a name="ln2277">     (mdir &amp; ASHIFT_FIT_LENS_BOTH) != 0)</a>
<a name="ln2278">  {</a>
<a name="ln2279">    // flip all directions</a>
<a name="ln2280">    mdir ^= g-&gt;isflipped ? ASHIFT_FIT_FLIP : 0;</a>
<a name="ln2281">    // special case that needs to be corrected</a>
<a name="ln2282">    mdir |= (mdir &amp; ASHIFT_FIT_LINES_BOTH) == 0 ? ASHIFT_FIT_LINES_BOTH : 0;</a>
<a name="ln2283">  }</a>
<a name="ln2284"> </a>
<a name="ln2285">  if(mdir &amp; ASHIFT_FIT_LINES_VERT)</a>
<a name="ln2286">  {</a>
<a name="ln2287">    // we use vertical lines for fitting</a>
<a name="ln2288">    fit.linetype |= ASHIFT_LINE_DIRVERT;</a>
<a name="ln2289">    fit.weight += g-&gt;vertical_weight;</a>
<a name="ln2290">    enough_lines = enough_lines &amp;&amp; (g-&gt;vertical_count &gt;= MINIMUM_FITLINES);</a>
<a name="ln2291">  }</a>
<a name="ln2292"> </a>
<a name="ln2293">  if(mdir &amp; ASHIFT_FIT_LINES_HOR)</a>
<a name="ln2294">  {</a>
<a name="ln2295">    // we use horizontal lines for fitting</a>
<a name="ln2296">    fit.linetype |= 0;</a>
<a name="ln2297">    fit.weight += g-&gt;horizontal_weight;</a>
<a name="ln2298">    enough_lines = enough_lines &amp;&amp; (g-&gt;horizontal_count &gt;= MINIMUM_FITLINES);</a>
<a name="ln2299">  }</a>
<a name="ln2300"> </a>
<a name="ln2301">  // this needs to come after ASHIFT_FIT_LINES_VERT and ASHIFT_FIT_LINES_HOR</a>
<a name="ln2302">  if((mdir &amp; ASHIFT_FIT_LINES_BOTH) == ASHIFT_FIT_LINES_BOTH)</a>
<a name="ln2303">  {</a>
<a name="ln2304">    // if we use fitting in both directions we need to</a>
<a name="ln2305">    // adjust fit.linetype and fit.linemask to match all selected lines</a>
<a name="ln2306">    fit.linetype = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2307">    fit.linemask = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2308">  }</a>
<a name="ln2309"> </a>
<a name="ln2310">  double quality = model_fitness(params, (void *)&amp;fit);</a>
<a name="ln2311"> </a>
<a name="ln2312">  printf(&quot;model fitness: %.8f (rotation %f, lensshift_v %f, lensshift_h %f, shear %f)\n&quot;,</a>
<a name="ln2313">         quality, p-&gt;rotation, p-&gt;lensshift_v, p-&gt;lensshift_h, p-&gt;shear);</a>
<a name="ln2314">}</a>
<a name="ln2315">#endif</a>
<a name="ln2316"> </a>
<a name="ln2317">// function to keep crop fitting parameters within constraints</a>
<a name="ln2318">static void crop_constraint(double *params, int pcount)</a>
<a name="ln2319">{</a>
<a name="ln2320">  if(pcount &gt; 0) params[0] = fabs(params[0]);</a>
<a name="ln2321">  if(pcount &gt; 1) params[1] = fabs(params[1]);</a>
<a name="ln2322">  if(pcount &gt; 2) params[2] = fabs(params[2]);</a>
<a name="ln2323"> </a>
<a name="ln2324">  if(pcount &gt; 0 &amp;&amp; params[0] &gt; 1.0) params[0] = 1.0 - params[0];</a>
<a name="ln2325">  if(pcount &gt; 1 &amp;&amp; params[1] &gt; 1.0) params[1] = 1.0 - params[1];</a>
<a name="ln2326">  if(pcount &gt; 2 &amp;&amp; params[2] &gt; 0.5*M_PI) params[2] = 0.5*M_PI - params[2];</a>
<a name="ln2327">}</a>
<a name="ln2328"> </a>
<a name="ln2329">// helper function for getting the best fitting crop area;</a>
<a name="ln2330">// returns the negative area of the largest rectangle that fits within the</a>
<a name="ln2331">// defined image with a given rectangle's center and its aspect angle;</a>
<a name="ln2332">// the trick: the rectangle center coordinates are given in the input</a>
<a name="ln2333">// image coordinates so we know for sure that it also lies within the image after</a>
<a name="ln2334">// conversion to the output coordinates</a>
<a name="ln2335">static double crop_fitness(double *params, void *data)</a>
<a name="ln2336">{</a>
<a name="ln2337">  dt_iop_ashift_cropfit_params_t *cropfit = (dt_iop_ashift_cropfit_params_t *)data;</a>
<a name="ln2338"> </a>
<a name="ln2339">  const float wd = cropfit-&gt;width;</a>
<a name="ln2340">  const float ht = cropfit-&gt;height;</a>
<a name="ln2341"> </a>
<a name="ln2342">  // get variable and constant parameters, respectively</a>
<a name="ln2343">  const float x = isnan(cropfit-&gt;x) ? params[0] : cropfit-&gt;x;</a>
<a name="ln2344">  const float y = isnan(cropfit-&gt;y) ? params[1] : cropfit-&gt;y;</a>
<a name="ln2345">  const float alpha = isnan(cropfit-&gt;alpha) ? params[2] : cropfit-&gt;alpha;</a>
<a name="ln2346"> </a>
<a name="ln2347">  // the center of the rectangle in input image coordinates</a>
<a name="ln2348">  const float Pc[3] = { x * wd, y * ht, 1.0f };</a>
<a name="ln2349"> </a>
<a name="ln2350">  // convert to the output image coordinates and normalize</a>
<a name="ln2351">  float P[3];</a>
<a name="ln2352">  mat3mulv(P, (float *)cropfit-&gt;homograph, Pc);</a>
<a name="ln2353">  P[0] /= P[2];</a>
<a name="ln2354">  P[1] /= P[2];</a>
<a name="ln2355">  P[2] = 1.0f;</a>
<a name="ln2356"> </a>
<a name="ln2357">  // two auxiliary points (some arbitrary distance away from P) to construct the diagonals</a>
<a name="ln2358">  const float Pa[2][3] = { { P[0] + 10.0f * cos(alpha), P[1] + 10.0f * sin(alpha), 1.0f },</a>
<a name="ln2359">                           { P[0] + 10.0f * cos(alpha), P[1] - 10.0f * sin(alpha), 1.0f } };</a>
<a name="ln2360"> </a>
<a name="ln2361">  // the two diagonals: D = P x Pa</a>
<a name="ln2362">  float D[2][3];</a>
<a name="ln2363">  vec3prodn(D[0], P, Pa[0]);</a>
<a name="ln2364">  vec3prodn(D[1], P, Pa[1]);</a>
<a name="ln2365"> </a>
<a name="ln2366">  // find all intersection points of all four edges with both diagonals (I = E x D);</a>
<a name="ln2367">  // the shortest distance d2min of the intersection point I to the crop area center P determines</a>
<a name="ln2368">  // the size of the crop area that still fits into the image (for the given center and aspect angle)</a>
<a name="ln2369">  float d2min = FLT_MAX;</a>
<a name="ln2370">  for(int k = 0; k &lt; 4; k++)</a>
<a name="ln2371">    for(int l = 0; l &lt; 2; l++)</a>
<a name="ln2372">    {</a>
<a name="ln2373">      // the intersection point</a>
<a name="ln2374">      float I[3];</a>
<a name="ln2375">      vec3prodn(I, cropfit-&gt;edges[k], D[l]);</a>
<a name="ln2376"> </a>
<a name="ln2377">      // special case: I is all null -&gt; E and D are identical -&gt; P lies on E -&gt; d2min = 0</a>
<a name="ln2378">      if(vec3isnull(I))</a>
<a name="ln2379">      {</a>
<a name="ln2380">        d2min = 0.0f;</a>
<a name="ln2381">        break;</a>
<a name="ln2382">      }</a>
<a name="ln2383"> </a>
<a name="ln2384">      // special case: I[2] is 0.0f -&gt; E and D are parallel and intersect at infinity -&gt; no relevant point</a>
<a name="ln2385">      if(I[2] == 0.0f)</a>
<a name="ln2386">        continue;</a>
<a name="ln2387"> </a>
<a name="ln2388">      // the default case -&gt; normalize I</a>
<a name="ln2389">      I[0] /= I[2];</a>
<a name="ln2390">      I[1] /= I[2];</a>
<a name="ln2391"> </a>
<a name="ln2392">      // calculate distance from I to P</a>
<a name="ln2393">      const float d2 = SQR(P[0] - I[0]) + SQR(P[1] - I[1]);</a>
<a name="ln2394"> </a>
<a name="ln2395">      // the minimum distance over all intersection points</a>
<a name="ln2396">      d2min = MIN(d2min, d2);</a>
<a name="ln2397">    }</a>
<a name="ln2398"> </a>
<a name="ln2399">  // calculate the area of the rectangle</a>
<a name="ln2400">  const float A = 2.0f * d2min * sin(2.0f * alpha);</a>
<a name="ln2401"> </a>
<a name="ln2402">#ifdef ASHIFT_DEBUG</a>
<a name="ln2403">  printf(&quot;crop fitness with x %f, y %f, angle %f -&gt; distance %f, area %f\n&quot;,</a>
<a name="ln2404">         x, y, alpha, d2min, A);</a>
<a name="ln2405">#endif</a>
<a name="ln2406">  // and return -A to allow Nelder-Mead simplex to search for the minimum</a>
<a name="ln2407">  return -A;</a>
<a name="ln2408">}</a>
<a name="ln2409"> </a>
<a name="ln2410">// strategy: for a given center of the crop area and a specific aspect angle</a>
<a name="ln2411">// we calculate the largest crop area that still lies within the output image;</a>
<a name="ln2412">// now we allow a Nelder-Mead simplex to search for the center coordinates</a>
<a name="ln2413">// (and optionally the aspect angle) that delivers the largest overall crop area.</a>
<a name="ln2414">static void do_crop(dt_iop_module_t *module, dt_iop_ashift_params_t *p)</a>
<a name="ln2415">{</a>
<a name="ln2416">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2417"> </a>
<a name="ln2418">  // skip if fitting is still running</a>
<a name="ln2419">  if(g-&gt;fitting) return;</a>
<a name="ln2420"> </a>
<a name="ln2421">  // reset fit margins if auto-cropping is off</a>
<a name="ln2422">  if(p-&gt;cropmode == ASHIFT_CROP_OFF)</a>
<a name="ln2423">  {</a>
<a name="ln2424">    p-&gt;cl = 0.0f;</a>
<a name="ln2425">    p-&gt;cr = 1.0f;</a>
<a name="ln2426">    p-&gt;ct = 0.0f;</a>
<a name="ln2427">    p-&gt;cb = 1.0f;</a>
<a name="ln2428">    return;</a>
<a name="ln2429">  }</a>
<a name="ln2430"> </a>
<a name="ln2431">  g-&gt;fitting = 1;</a>
<a name="ln2432"> </a>
<a name="ln2433">  double params[3];</a>
<a name="ln2434">  int pcount;</a>
<a name="ln2435"> </a>
<a name="ln2436">  // get parameters for the homograph</a>
<a name="ln2437">  const float f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln2438">  const float orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln2439">  const float aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln2440">  const float rotation = p-&gt;rotation;</a>
<a name="ln2441">  const float lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln2442">  const float lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln2443">  const float shear = p-&gt;shear;</a>
<a name="ln2444"> </a>
<a name="ln2445">  // prepare structure of constant parameters</a>
<a name="ln2446">  dt_iop_ashift_cropfit_params_t cropfit;</a>
<a name="ln2447">  cropfit.width = g-&gt;buf_width;</a>
<a name="ln2448">  cropfit.height = g-&gt;buf_height;</a>
<a name="ln2449">  homography((float *)cropfit.homograph, rotation, lensshift_v, lensshift_h, shear, f_length_kb,</a>
<a name="ln2450">             orthocorr, aspect, cropfit.width, cropfit.height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln2451"> </a>
<a name="ln2452">  const float wd = cropfit.width;</a>
<a name="ln2453">  const float ht = cropfit.height;</a>
<a name="ln2454"> </a>
<a name="ln2455">  // the four vertices of the image in input image coordinates</a>
<a name="ln2456">  const float Vc[4][3] = { { 0.0f, 0.0f, 1.0f },</a>
<a name="ln2457">                           { 0.0f,   ht, 1.0f },</a>
<a name="ln2458">                           {   wd,   ht, 1.0f },</a>
<a name="ln2459">                           {   wd, 0.0f, 1.0f } };</a>
<a name="ln2460"> </a>
<a name="ln2461">  // convert the vertices to output image coordinates</a>
<a name="ln2462">  float V[4][3];</a>
<a name="ln2463">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2464">    mat3mulv(V[n], (float *)cropfit.homograph, Vc[n]);</a>
<a name="ln2465"> </a>
<a name="ln2466">  // get width and height of output image for later use</a>
<a name="ln2467">  float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN;</a>
<a name="ln2468">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2469">  {</a>
<a name="ln2470">    // normalize V</a>
<a name="ln2471">    V[n][0] /= V[n][2];</a>
<a name="ln2472">    V[n][1] /= V[n][2];</a>
<a name="ln2473">    V[n][2] = 1.0f;</a>
<a name="ln2474">    xmin = MIN(xmin, V[n][0]);</a>
<a name="ln2475">    xmax = MAX(xmax, V[n][0]);</a>
<a name="ln2476">    ymin = MIN(ymin, V[n][1]);</a>
<a name="ln2477">    ymax = MAX(ymax, V[n][1]);</a>
<a name="ln2478">  }</a>
<a name="ln2479">  const float owd = xmax - xmin;</a>
<a name="ln2480">  const float oht = ymax - ymin;</a>
<a name="ln2481"> </a>
<a name="ln2482">  // calculate the lines defining the four edges of the image area: E = V[n] x V[n+1]</a>
<a name="ln2483">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2484">    vec3prodn(cropfit.edges[n], V[n], V[(n + 1) % 4]);</a>
<a name="ln2485"> </a>
<a name="ln2486">  // initial fit parameters: crop area is centered and aspect angle is that of the original image</a>
<a name="ln2487">  // number of parameters: fit only crop center coordinates with a fixed aspect ratio, or fit all three variables</a>
<a name="ln2488">  if(p-&gt;cropmode == ASHIFT_CROP_LARGEST)</a>
<a name="ln2489">  {</a>
<a name="ln2490">    params[0] = 0.5;</a>
<a name="ln2491">    params[1] = 0.5;</a>
<a name="ln2492">    params[2] = atan2((float)cropfit.height, (float)cropfit.width);</a>
<a name="ln2493">    cropfit.x = NAN;</a>
<a name="ln2494">    cropfit.y = NAN;</a>
<a name="ln2495">    cropfit.alpha = NAN;</a>
<a name="ln2496">    pcount = 3;</a>
<a name="ln2497">  }</a>
<a name="ln2498">  else //(p-&gt;cropmode == ASHIFT_CROP_ASPECT)</a>
<a name="ln2499">  {</a>
<a name="ln2500">    params[0] = 0.5;</a>
<a name="ln2501">    params[1] = 0.5;</a>
<a name="ln2502">    cropfit.x = NAN;</a>
<a name="ln2503">    cropfit.y = NAN;</a>
<a name="ln2504">    cropfit.alpha = atan2((float)cropfit.height, (float)cropfit.width);</a>
<a name="ln2505">    pcount = 2;</a>
<a name="ln2506">  }</a>
<a name="ln2507"> </a>
<a name="ln2508">  // start the simplex fit</a>
<a name="ln2509">  const int iter = simplex(crop_fitness, params, pcount, NMS_CROP_EPSILON, NMS_CROP_SCALE, NMS_CROP_ITERATIONS,</a>
<a name="ln2510">                           crop_constraint, (void*)&amp;cropfit);</a>
<a name="ln2511"> </a>
<a name="ln2512">  // in case the fit did not converge -&gt; failed</a>
<a name="ln2513">  if(iter &gt;= NMS_CROP_ITERATIONS) goto failed;</a>
<a name="ln2514"> </a>
<a name="ln2515">  // the fit did converge -&gt; get clipping margins out of params:</a>
<a name="ln2516">  cropfit.x = isnan(cropfit.x) ? params[0] : cropfit.x;</a>
<a name="ln2517">  cropfit.y = isnan(cropfit.y) ? params[1] : cropfit.y;</a>
<a name="ln2518">  cropfit.alpha = isnan(cropfit.alpha) ? params[2] : cropfit.alpha;</a>
<a name="ln2519"> </a>
<a name="ln2520">  // the area of the best fitting rectangle</a>
<a name="ln2521">  const float A = fabs(crop_fitness(params, (void*)&amp;cropfit));</a>
<a name="ln2522"> </a>
<a name="ln2523">  // unlikely to happen but we need to catch this case</a>
<a name="ln2524">  if(A == 0.0f) goto failed;</a>
<a name="ln2525"> </a>
<a name="ln2526">  // we need the half diagonal of that rectangle (this is in output image dimensions);</a>
<a name="ln2527">  // no need to check for division by zero here as this case implies A == 0.0f, caught above</a>
<a name="ln2528">  const float d = sqrt(A / (2.0f * sin(2.0f * cropfit.alpha)));</a>
<a name="ln2529"> </a>
<a name="ln2530">  // the rectangle's center in input image (homogeneous) coordinates</a>
<a name="ln2531">  const float Pc[3] = { cropfit.x * wd, cropfit.y * ht, 1.0f };</a>
<a name="ln2532"> </a>
<a name="ln2533">  // convert rectangle center to output image coordinates and normalize</a>
<a name="ln2534">  float P[3];</a>
<a name="ln2535">  mat3mulv(P, (float *)cropfit.homograph, Pc);</a>
<a name="ln2536">  P[0] /= P[2];</a>
<a name="ln2537">  P[1] /= P[2];</a>
<a name="ln2538"> </a>
<a name="ln2539">  // calculate clipping margins relative to output image dimensions</a>
<a name="ln2540">  p-&gt;cl = CLAMP((P[0] - d * cos(cropfit.alpha)) / owd, 0.0f, 1.0f);</a>
<a name="ln2541">  p-&gt;cr = CLAMP((P[0] + d * cos(cropfit.alpha)) / owd, 0.0f, 1.0f);</a>
<a name="ln2542">  p-&gt;ct = CLAMP((P[1] - d * sin(cropfit.alpha)) / oht, 0.0f, 1.0f);</a>
<a name="ln2543">  p-&gt;cb = CLAMP((P[1] + d * sin(cropfit.alpha)) / oht, 0.0f, 1.0f);</a>
<a name="ln2544"> </a>
<a name="ln2545">  // final sanity check</a>
<a name="ln2546">  if(p-&gt;cr - p-&gt;cl &lt;= 0.0f || p-&gt;cb - p-&gt;ct &lt;= 0.0f) goto failed;</a>
<a name="ln2547"> </a>
<a name="ln2548">  g-&gt;fitting = 0;</a>
<a name="ln2549"> </a>
<a name="ln2550">#ifdef ASHIFT_DEBUG</a>
<a name="ln2551">  printf(&quot;margins after crop fitting: iter %d, x %f, y %f, angle %f, crop area (%f %f %f %f), width %f, height %f\n&quot;,</a>
<a name="ln2552">         iter, cropfit.x, cropfit.y, cropfit.alpha, p-&gt;cl, p-&gt;cr, p-&gt;ct, p-&gt;cb, wd, ht);</a>
<a name="ln2553">#endif</a>
<a name="ln2554">  dt_control_queue_redraw_center();</a>
<a name="ln2555">  return;</a>
<a name="ln2556"> </a>
<a name="ln2557">failed:</a>
<a name="ln2558">  // in case of failure: reset clipping margins, set &quot;automatic cropping&quot; parameter</a>
<a name="ln2559">  // to &quot;off&quot; state, and display warning message</a>
<a name="ln2560">  p-&gt;cl = 0.0f;</a>
<a name="ln2561">  p-&gt;cr = 1.0f;</a>
<a name="ln2562">  p-&gt;ct = 0.0f;</a>
<a name="ln2563">  p-&gt;cb = 1.0f;</a>
<a name="ln2564">  p-&gt;cropmode = ASHIFT_CROP_OFF;</a>
<a name="ln2565">  dt_bauhaus_combobox_set(g-&gt;cropmode, p-&gt;cropmode);</a>
<a name="ln2566">  g-&gt;fitting = 0;</a>
<a name="ln2567">  dt_control_log(_(&quot;automatic cropping failed&quot;));</a>
<a name="ln2568">  return;</a>
<a name="ln2569">}</a>
<a name="ln2570"> </a>
<a name="ln2571">// manually adjust crop area by shifting its center</a>
<a name="ln2572">static void crop_adjust(dt_iop_module_t *module, dt_iop_ashift_params_t *p, const float newx, const float newy)</a>
<a name="ln2573">{</a>
<a name="ln2574">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2575"> </a>
<a name="ln2576">  // skip if fitting is still running</a>
<a name="ln2577">  if(g-&gt;fitting) return;</a>
<a name="ln2578"> </a>
<a name="ln2579">  // get parameters for the homograph</a>
<a name="ln2580">  const float f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln2581">  const float orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln2582">  const float aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln2583">  const float rotation = p-&gt;rotation;</a>
<a name="ln2584">  const float lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln2585">  const float lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln2586">  const float shear = p-&gt;shear;</a>
<a name="ln2587"> </a>
<a name="ln2588">  const float wd = g-&gt;buf_width;</a>
<a name="ln2589">  const float ht = g-&gt;buf_height;</a>
<a name="ln2590"> </a>
<a name="ln2591">  const float alpha = atan2(ht, wd);</a>
<a name="ln2592"> </a>
<a name="ln2593">  float homograph[3][3];</a>
<a name="ln2594">  homography((float *)homograph, rotation, lensshift_v, lensshift_h, shear, f_length_kb,</a>
<a name="ln2595">             orthocorr, aspect, wd, ht, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln2596"> </a>
<a name="ln2597">  // the four vertices of the image in input image coordinates</a>
<a name="ln2598">  const float Vc[4][3] = { { 0.0f, 0.0f, 1.0f },</a>
<a name="ln2599">                           { 0.0f,   ht, 1.0f },</a>
<a name="ln2600">                           {   wd,   ht, 1.0f },</a>
<a name="ln2601">                           {   wd, 0.0f, 1.0f } };</a>
<a name="ln2602"> </a>
<a name="ln2603">  // convert the vertices to output image coordinates</a>
<a name="ln2604">  float V[4][3];</a>
<a name="ln2605">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2606">    mat3mulv(V[n], (float *)homograph, Vc[n]);</a>
<a name="ln2607"> </a>
<a name="ln2608">  // get width and height of output image</a>
<a name="ln2609">  float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN;</a>
<a name="ln2610">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2611">  {</a>
<a name="ln2612">    // normalize V</a>
<a name="ln2613">    V[n][0] /= V[n][2];</a>
<a name="ln2614">    V[n][1] /= V[n][2];</a>
<a name="ln2615">    V[n][2] = 1.0f;</a>
<a name="ln2616">    xmin = MIN(xmin, V[n][0]);</a>
<a name="ln2617">    xmax = MAX(xmax, V[n][0]);</a>
<a name="ln2618">    ymin = MIN(ymin, V[n][1]);</a>
<a name="ln2619">    ymax = MAX(ymax, V[n][1]);</a>
<a name="ln2620">  }</a>
<a name="ln2621">  const float owd = xmax - xmin;</a>
<a name="ln2622">  const float oht = ymax - ymin;</a>
<a name="ln2623"> </a>
<a name="ln2624">  // calculate the lines defining the four edges of the image area: E = V[n] x V[n+1]</a>
<a name="ln2625">  float E[4][3];</a>
<a name="ln2626">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2627">    vec3prodn(E[n], V[n], V[(n + 1) % 4]);</a>
<a name="ln2628"> </a>
<a name="ln2629">  // the center of the rectangle in output image coordinates</a>
<a name="ln2630">  const float P[3] = { newx * owd, newy * oht, 1.0f };</a>
<a name="ln2631"> </a>
<a name="ln2632">  // two auxiliary points (some arbitrary distance away from P) to construct the diagonals</a>
<a name="ln2633">  const float Pa[2][3] = { { P[0] + 10.0f * cos(alpha), P[1] + 10.0f * sin(alpha), 1.0f },</a>
<a name="ln2634">                           { P[0] + 10.0f * cos(alpha), P[1] - 10.0f * sin(alpha), 1.0f } };</a>
<a name="ln2635"> </a>
<a name="ln2636">  // the two diagonals: D = P x Pa</a>
<a name="ln2637">  float D[2][3];</a>
<a name="ln2638">  vec3prodn(D[0], P, Pa[0]);</a>
<a name="ln2639">  vec3prodn(D[1], P, Pa[1]);</a>
<a name="ln2640"> </a>
<a name="ln2641">  // find all intersection points of all four edges with both diagonals (I = E x D);</a>
<a name="ln2642">  // the shortest distance d2min of the intersection point I to the crop area center P determines</a>
<a name="ln2643">  // the size of the crop area that still fits into the image (for the given center and aspect angle)</a>
<a name="ln2644">  float d2min = FLT_MAX;</a>
<a name="ln2645">  for(int k = 0; k &lt; 4; k++)</a>
<a name="ln2646">    for(int l = 0; l &lt; 2; l++)</a>
<a name="ln2647">    {</a>
<a name="ln2648">      // the intersection point</a>
<a name="ln2649">      float I[3];</a>
<a name="ln2650">      vec3prodn(I, E[k], D[l]);</a>
<a name="ln2651"> </a>
<a name="ln2652">      // special case: I is all null -&gt; E and D are identical -&gt; P lies on E -&gt; d2min = 0</a>
<a name="ln2653">      if(vec3isnull(I))</a>
<a name="ln2654">      {</a>
<a name="ln2655">        d2min = 0.0f;</a>
<a name="ln2656">        break;</a>
<a name="ln2657">      }</a>
<a name="ln2658"> </a>
<a name="ln2659">      // special case: I[2] is 0.0f -&gt; E and D are parallel and intersect at infinity -&gt; no relevant point</a>
<a name="ln2660">      if(I[2] == 0.0f)</a>
<a name="ln2661">        continue;</a>
<a name="ln2662"> </a>
<a name="ln2663">      // the default case -&gt; normalize I</a>
<a name="ln2664">      I[0] /= I[2];</a>
<a name="ln2665">      I[1] /= I[2];</a>
<a name="ln2666"> </a>
<a name="ln2667">      // calculate distance from I to P</a>
<a name="ln2668">      const float d2 = SQR(P[0] - I[0]) + SQR(P[1] - I[1]);</a>
<a name="ln2669"> </a>
<a name="ln2670">      // the minimum distance over all intersection points</a>
<a name="ln2671">      d2min = MIN(d2min, d2);</a>
<a name="ln2672">    }</a>
<a name="ln2673"> </a>
<a name="ln2674">  const float d = sqrt(d2min);</a>
<a name="ln2675"> </a>
<a name="ln2676">  // do not allow crop area to drop below 1% of input image area</a>
<a name="ln2677">  const float A = 2.0f * d * d * sin(2.0f * alpha);</a>
<a name="ln2678">  if(A &lt; 0.01f * wd * ht) return;</a>
<a name="ln2679"> </a>
<a name="ln2680">  // calculate clipping margins relative to output image dimensions</a>
<a name="ln2681">  p-&gt;cl = CLAMP((P[0] - d * cos(alpha)) / owd, 0.0f, 1.0f);</a>
<a name="ln2682">  p-&gt;cr = CLAMP((P[0] + d * cos(alpha)) / owd, 0.0f, 1.0f);</a>
<a name="ln2683">  p-&gt;ct = CLAMP((P[1] - d * sin(alpha)) / oht, 0.0f, 1.0f);</a>
<a name="ln2684">  p-&gt;cb = CLAMP((P[1] + d * sin(alpha)) / oht, 0.0f, 1.0f);</a>
<a name="ln2685"> </a>
<a name="ln2686">#ifdef ASHIFT_DEBUG</a>
<a name="ln2687">  printf(&quot;margins after crop adjustment: x %f, y %f, angle %f, crop area (%f %f %f %f), width %f, height %f\n&quot;,</a>
<a name="ln2688">         0.5f * (p-&gt;cl + p-&gt;cr), 0.5f * (p-&gt;ct + p-&gt;cb), alpha, p-&gt;cl, p-&gt;cr, p-&gt;ct, p-&gt;cb, wd, ht);</a>
<a name="ln2689">#endif</a>
<a name="ln2690">  dt_control_queue_redraw_center();</a>
<a name="ln2691">  return;</a>
<a name="ln2692">}</a>
<a name="ln2693"> </a>
<a name="ln2694"> </a>
<a name="ln2695">// helper function to start analysis for structural data and report about errors</a>
<a name="ln2696">static int do_get_structure(dt_iop_module_t *module, dt_iop_ashift_params_t *p,</a>
<a name="ln2697">                            dt_iop_ashift_enhance_t enhance)</a>
<a name="ln2698">{</a>
<a name="ln2699">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2700"> </a>
<a name="ln2701">  if(g-&gt;fitting) return FALSE;</a>
<a name="ln2702"> </a>
<a name="ln2703">  g-&gt;fitting = 1;</a>
<a name="ln2704"> </a>
<a name="ln2705">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2706">  float *b = g-&gt;buf;</a>
<a name="ln2707">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2708"> </a>
<a name="ln2709">  if(b == NULL)</a>
<a name="ln2710">  {</a>
<a name="ln2711">    dt_control_log(_(&quot;data pending - please repeat&quot;));</a>
<a name="ln2712">    goto error;</a>
<a name="ln2713">  }</a>
<a name="ln2714"> </a>
<a name="ln2715">  if(!get_structure(module, enhance))</a>
<a name="ln2716">  {</a>
<a name="ln2717">    dt_control_log(_(&quot;could not detect structural data in image&quot;));</a>
<a name="ln2718">#ifdef ASHIFT_DEBUG</a>
<a name="ln2719">    // find out more</a>
<a name="ln2720">    printf(&quot;do_get_structure: buf %p, buf_hash %lu, buf_width %d, buf_height %d, lines %p, lines_count %d\n&quot;,</a>
<a name="ln2721">           g-&gt;buf, g-&gt;buf_hash, g-&gt;buf_width, g-&gt;buf_height, g-&gt;lines, g-&gt;lines_count);</a>
<a name="ln2722">#endif</a>
<a name="ln2723">    goto error;</a>
<a name="ln2724">  }</a>
<a name="ln2725"> </a>
<a name="ln2726">  if(!remove_outliers(module))</a>
<a name="ln2727">  {</a>
<a name="ln2728">    dt_control_log(_(&quot;could not run outlier removal&quot;));</a>
<a name="ln2729">#ifdef ASHIFT_DEBUG</a>
<a name="ln2730">    // find out more</a>
<a name="ln2731">    printf(&quot;remove_outliers: buf %p, buf_hash %lu, buf_width %d, buf_height %d, lines %p, lines_count %d\n&quot;,</a>
<a name="ln2732">           g-&gt;buf, g-&gt;buf_hash, g-&gt;buf_width, g-&gt;buf_height, g-&gt;lines, g-&gt;lines_count);</a>
<a name="ln2733">#endif</a>
<a name="ln2734">    goto error;</a>
<a name="ln2735">  }</a>
<a name="ln2736"> </a>
<a name="ln2737">  g-&gt;fitting = 0;</a>
<a name="ln2738">  return TRUE;</a>
<a name="ln2739"> </a>
<a name="ln2740">error:</a>
<a name="ln2741">  g-&gt;fitting = 0;</a>
<a name="ln2742">  return FALSE;</a>
<a name="ln2743">}</a>
<a name="ln2744"> </a>
<a name="ln2745">// helper function to clean structural data</a>
<a name="ln2746">static int do_clean_structure(dt_iop_module_t *module, dt_iop_ashift_params_t *p)</a>
<a name="ln2747">{</a>
<a name="ln2748">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2749"> </a>
<a name="ln2750">  if(g-&gt;fitting) return FALSE;</a>
<a name="ln2751"> </a>
<a name="ln2752">  g-&gt;fitting = 1;</a>
<a name="ln2753">  g-&gt;lines_count = 0;</a>
<a name="ln2754">  g-&gt;vertical_count = 0;</a>
<a name="ln2755">  g-&gt;horizontal_count = 0;</a>
<a name="ln2756">  free(g-&gt;lines);</a>
<a name="ln2757">  g-&gt;lines = NULL;</a>
<a name="ln2758">  g-&gt;lines_version++;</a>
<a name="ln2759">  g-&gt;lines_suppressed = 0;</a>
<a name="ln2760">  g-&gt;fitting = 0;</a>
<a name="ln2761">  return TRUE;</a>
<a name="ln2762">}</a>
<a name="ln2763"> </a>
<a name="ln2764">// helper function to start parameter fit and report about errors</a>
<a name="ln2765">static int do_fit(dt_iop_module_t *module, dt_iop_ashift_params_t *p, dt_iop_ashift_fitaxis_t dir)</a>
<a name="ln2766">{</a>
<a name="ln2767">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2768"> </a>
<a name="ln2769">  if(g-&gt;fitting) return FALSE;</a>
<a name="ln2770"> </a>
<a name="ln2771">  // if no structure available get it</a>
<a name="ln2772">  if(g-&gt;lines == NULL)</a>
<a name="ln2773">    if(!do_get_structure(module, p, ASHIFT_ENHANCE_NONE)) goto error;</a>
<a name="ln2774"> </a>
<a name="ln2775">  g-&gt;fitting = 1;</a>
<a name="ln2776"> </a>
<a name="ln2777">  dt_iop_ashift_nmsresult_t res = nmsfit(module, p, dir);</a>
<a name="ln2778"> </a>
<a name="ln2779">  switch(res)</a>
<a name="ln2780">  {</a>
<a name="ln2781">    case NMS_NOT_ENOUGH_LINES:</a>
<a name="ln2782">      dt_control_log(_(&quot;not enough structure for automatic correction&quot;));</a>
<a name="ln2783">      goto error;</a>
<a name="ln2784">      break;</a>
<a name="ln2785">    case NMS_DID_NOT_CONVERGE:</a>
<a name="ln2786">    case NMS_INSANE:</a>
<a name="ln2787">      dt_control_log(_(&quot;automatic correction failed, please correct manually&quot;));</a>
<a name="ln2788">      goto error;</a>
<a name="ln2789">      break;</a>
<a name="ln2790">    case NMS_SUCCESS:</a>
<a name="ln2791">    default:</a>
<a name="ln2792">      break;</a>
<a name="ln2793">  }</a>
<a name="ln2794"> </a>
<a name="ln2795">  g-&gt;fitting = 0;</a>
<a name="ln2796"> </a>
<a name="ln2797">  // finally apply cropping</a>
<a name="ln2798">  do_crop(module, p);</a>
<a name="ln2799"> </a>
<a name="ln2800">  return TRUE;</a>
<a name="ln2801"> </a>
<a name="ln2802">error:</a>
<a name="ln2803">  g-&gt;fitting = 0;</a>
<a name="ln2804">  return FALSE;</a>
<a name="ln2805">}</a>
<a name="ln2806"> </a>
<a name="ln2807"> </a>
<a name="ln2808">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln2809">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2810">{</a>
<a name="ln2811">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln2812">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2813"> </a>
<a name="ln2814">  const int ch = piece-&gt;colors;</a>
<a name="ln2815">  const int ch_width = ch * roi_in-&gt;width;</a>
<a name="ln2816"> </a>
<a name="ln2817">  // only for preview pipe: collect input buffer data and do some other evaluations</a>
<a name="ln2818">  if(self-&gt;dev-&gt;gui_attached &amp;&amp; g &amp;&amp; piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln2819">  {</a>
<a name="ln2820">    // we want to find out if the final output image is flipped in relation to this iop</a>
<a name="ln2821">    // so we can adjust the gui labels accordingly</a>
<a name="ln2822"> </a>
<a name="ln2823">    const int width = roi_in-&gt;width;</a>
<a name="ln2824">    const int height = roi_in-&gt;height;</a>
<a name="ln2825">    const int x_off = roi_in-&gt;x;</a>
<a name="ln2826">    const int y_off = roi_in-&gt;y;</a>
<a name="ln2827">    const float scale = roi_in-&gt;scale;</a>
<a name="ln2828"> </a>
<a name="ln2829">    // origin of image and opposite corner as reference points</a>
<a name="ln2830">    float points[4] = { 0.0f, 0.0f, (float)piece-&gt;buf_in.width, (float)piece-&gt;buf_in.height };</a>
<a name="ln2831">    float ivec[2] = { points[2] - points[0], points[3] - points[1] };</a>
<a name="ln2832">    float ivecl = sqrt(ivec[0] * ivec[0] + ivec[1] * ivec[1]);</a>
<a name="ln2833"> </a>
<a name="ln2834">    // where do they go?</a>
<a name="ln2835">    dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;priority + 1, 9999999, points,</a>
<a name="ln2836">                                      2);</a>
<a name="ln2837"> </a>
<a name="ln2838">    float ovec[2] = { points[2] - points[0], points[3] - points[1] };</a>
<a name="ln2839">    float ovecl = sqrt(ovec[0] * ovec[0] + ovec[1] * ovec[1]);</a>
<a name="ln2840"> </a>
<a name="ln2841">    // angle between input vector and output vector</a>
<a name="ln2842">    float alpha = acos(CLAMP((ivec[0] * ovec[0] + ivec[1] * ovec[1]) / (ivecl * ovecl), -1.0f, 1.0f));</a>
<a name="ln2843"> </a>
<a name="ln2844">    // we are interested if |alpha| is in the range of 90° +/- 45° -&gt; we assume the image is flipped</a>
<a name="ln2845">    int isflipped = fabs(fmod(alpha + M_PI, M_PI) - M_PI / 2.0f) &lt; M_PI / 4.0f ? 1 : 0;</a>
<a name="ln2846"> </a>
<a name="ln2847">    // did modules prior to this one in pixelpipe have changed? -&gt; check via hash value</a>
<a name="ln2848">    uint64_t hash = dt_dev_hash_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, 0, self-&gt;priority - 1);</a>
<a name="ln2849"> </a>
<a name="ln2850">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2851">    g-&gt;isflipped = isflipped;</a>
<a name="ln2852"> </a>
<a name="ln2853">    // save a copy of preview input buffer for parameter fitting</a>
<a name="ln2854">    if(g-&gt;buf == NULL || (size_t)g-&gt;buf_width * g-&gt;buf_height &lt; (size_t)width * height)</a>
<a name="ln2855">    {</a>
<a name="ln2856">      // if needed allocate buffer</a>
<a name="ln2857">      free(g-&gt;buf); // a no-op if g-&gt;buf is NULL</a>
<a name="ln2858">      // only get new buffer if no old buffer available or old buffer does not fit in terms of size</a>
<a name="ln2859">      g-&gt;buf = malloc((size_t)width * height * 4 * sizeof(float));</a>
<a name="ln2860">    }</a>
<a name="ln2861"> </a>
<a name="ln2862">    if(g-&gt;buf /* &amp;&amp; hash != g-&gt;buf_hash */)</a>
<a name="ln2863">    {</a>
<a name="ln2864">      // copy data</a>
<a name="ln2865">      memcpy(g-&gt;buf, ivoid, (size_t)width * height * ch * sizeof(float));</a>
<a name="ln2866"> </a>
<a name="ln2867">      g-&gt;buf_width = width;</a>
<a name="ln2868">      g-&gt;buf_height = height;</a>
<a name="ln2869">      g-&gt;buf_x_off = x_off;</a>
<a name="ln2870">      g-&gt;buf_y_off = y_off;</a>
<a name="ln2871">      g-&gt;buf_scale = scale;</a>
<a name="ln2872">      g-&gt;buf_hash = hash;</a>
<a name="ln2873">    }</a>
<a name="ln2874"> </a>
<a name="ln2875">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2876">  }</a>
<a name="ln2877"> </a>
<a name="ln2878">  // if module is set to neutral parameters we just copy input-&gt;output and are done</a>
<a name="ln2879">  if(isneutral(data))</a>
<a name="ln2880">  {</a>
<a name="ln2881">    memcpy(ovoid, ivoid, (size_t)roi_out-&gt;width * roi_out-&gt;height * ch * sizeof(float));</a>
<a name="ln2882">    return;</a>
<a name="ln2883">  }</a>
<a name="ln2884"> </a>
<a name="ln2885">  const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln2886"> </a>
<a name="ln2887">  float ihomograph[3][3];</a>
<a name="ln2888">  homography((float *)ihomograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln2889">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln2890"> </a>
<a name="ln2891">  // clipping offset</a>
<a name="ln2892">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln2893">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln2894">  const float cx = roi_out-&gt;scale * fullwidth * data-&gt;cl;</a>
<a name="ln2895">  const float cy = roi_out-&gt;scale * fullheight * data-&gt;ct;</a>
<a name="ln2896"> </a>
<a name="ln2897"> </a>
<a name="ln2898">#ifdef _OPENMP</a>
<a name="ln2899">#pragma omp parallel for schedule(static) default(none) shared(ihomograph, interpolation)</a>
<a name="ln2900">#endif</a>
<a name="ln2901">  // go over all pixels of output image</a>
<a name="ln2902">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln2903">  {</a>
<a name="ln2904">    float *out = ((float *)ovoid) + (size_t)ch * j * roi_out-&gt;width;</a>
<a name="ln2905">    for(int i = 0; i &lt; roi_out-&gt;width; i++, out += ch)</a>
<a name="ln2906">    {</a>
<a name="ln2907">      float pin[3], pout[3];</a>
<a name="ln2908"> </a>
<a name="ln2909">      // convert output pixel coordinates to original image coordinates</a>
<a name="ln2910">      pout[0] = roi_out-&gt;x + i + cx;</a>
<a name="ln2911">      pout[1] = roi_out-&gt;y + j + cy;</a>
<a name="ln2912">      pout[0] /= roi_out-&gt;scale;</a>
<a name="ln2913">      pout[1] /= roi_out-&gt;scale;</a>
<a name="ln2914">      pout[2] = 1.0f;</a>
<a name="ln2915"> </a>
<a name="ln2916">      // apply homograph</a>
<a name="ln2917">      mat3mulv(pin, (float *)ihomograph, pout);</a>
<a name="ln2918"> </a>
<a name="ln2919">      // convert to input pixel coordinates</a>
<a name="ln2920">      pin[0] /= pin[2];</a>
<a name="ln2921">      pin[1] /= pin[2];</a>
<a name="ln2922">      pin[0] *= roi_in-&gt;scale;</a>
<a name="ln2923">      pin[1] *= roi_in-&gt;scale;</a>
<a name="ln2924">      pin[0] -= roi_in-&gt;x;</a>
<a name="ln2925">      pin[1] -= roi_in-&gt;y;</a>
<a name="ln2926"> </a>
<a name="ln2927">      // get output values by interpolation from input image</a>
<a name="ln2928">      dt_interpolation_compute_pixel4c(interpolation, (float *)ivoid, out, pin[0], pin[1], roi_in-&gt;width,</a>
<a name="ln2929">                                       roi_in-&gt;height, ch_width);</a>
<a name="ln2930">    }</a>
<a name="ln2931">  }</a>
<a name="ln2932">}</a>
<a name="ln2933"> </a>
<a name="ln2934">#ifdef HAVE_OPENCL</a>
<a name="ln2935">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln2936">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2937">{</a>
<a name="ln2938">  dt_iop_ashift_data_t *d = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln2939">  dt_iop_ashift_global_data_t *gd = (dt_iop_ashift_global_data_t *)self-&gt;data;</a>
<a name="ln2940">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2941"> </a>
<a name="ln2942">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln2943">  const int iwidth = roi_in-&gt;width;</a>
<a name="ln2944">  const int iheight = roi_in-&gt;height;</a>
<a name="ln2945">  const int width = roi_out-&gt;width;</a>
<a name="ln2946">  const int height = roi_out-&gt;height;</a>
<a name="ln2947"> </a>
<a name="ln2948">  cl_int err = -999;</a>
<a name="ln2949">  cl_mem dev_homo = NULL;</a>
<a name="ln2950"> </a>
<a name="ln2951">  // only for preview pipe: collect input buffer data and do some other evaluations</a>
<a name="ln2952">  if(self-&gt;dev-&gt;gui_attached &amp;&amp; g &amp;&amp; piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln2953">  {</a>
<a name="ln2954">    // we want to find out if the final output image is flipped in relation to this iop</a>
<a name="ln2955">    // so we can adjust the gui labels accordingly</a>
<a name="ln2956"> </a>
<a name="ln2957">    const int x_off = roi_in-&gt;x;</a>
<a name="ln2958">    const int y_off = roi_in-&gt;y;</a>
<a name="ln2959">    const float scale = roi_in-&gt;scale;</a>
<a name="ln2960"> </a>
<a name="ln2961">    // origin of image and opposite corner as reference points</a>
<a name="ln2962">    float points[4] = { 0.0f, 0.0f, (float)piece-&gt;buf_in.width, (float)piece-&gt;buf_in.height };</a>
<a name="ln2963">    float ivec[2] = { points[2] - points[0], points[3] - points[1] };</a>
<a name="ln2964">    float ivecl = sqrt(ivec[0] * ivec[0] + ivec[1] * ivec[1]);</a>
<a name="ln2965"> </a>
<a name="ln2966">    // where do they go?</a>
<a name="ln2967">    dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;priority + 1, 9999999, points,</a>
<a name="ln2968">                                      2);</a>
<a name="ln2969"> </a>
<a name="ln2970">    float ovec[2] = { points[2] - points[0], points[3] - points[1] };</a>
<a name="ln2971">    float ovecl = sqrt(ovec[0] * ovec[0] + ovec[1] * ovec[1]);</a>
<a name="ln2972"> </a>
<a name="ln2973">    // angle between input vector and output vector</a>
<a name="ln2974">    float alpha = acos(CLAMP((ivec[0] * ovec[0] + ivec[1] * ovec[1]) / (ivecl * ovecl), -1.0f, 1.0f));</a>
<a name="ln2975"> </a>
<a name="ln2976">    // we are interested if |alpha| is in the range of 90° +/- 45° -&gt; we assume the image is flipped</a>
<a name="ln2977">    int isflipped = fabs(fmod(alpha + M_PI, M_PI) - M_PI / 2.0f) &lt; M_PI / 4.0f ? 1 : 0;</a>
<a name="ln2978"> </a>
<a name="ln2979">    // do modules coming before this one in pixelpipe have changed? -&gt; check via hash value</a>
<a name="ln2980">    uint64_t hash = dt_dev_hash_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, 0, self-&gt;priority - 1);</a>
<a name="ln2981"> </a>
<a name="ln2982">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2983">    g-&gt;isflipped = isflipped;</a>
<a name="ln2984"> </a>
<a name="ln2985">    // save a copy of preview input buffer for parameter fitting</a>
<a name="ln2986">    if(g-&gt;buf == NULL || (size_t)g-&gt;buf_width * g-&gt;buf_height &lt; (size_t)iwidth * iheight)</a>
<a name="ln2987">    {</a>
<a name="ln2988">      // if needed allocate buffer</a>
<a name="ln2989">      free(g-&gt;buf); // a no-op if g-&gt;buf is NULL</a>
<a name="ln2990">      // only get new buffer if no old buffer or old buffer does not fit in terms of size</a>
<a name="ln2991">      g-&gt;buf = malloc((size_t)iwidth * iheight * 4 * sizeof(float));</a>
<a name="ln2992">    }</a>
<a name="ln2993"> </a>
<a name="ln2994">    if(g-&gt;buf /* &amp;&amp; hash != g-&gt;buf_hash */)</a>
<a name="ln2995">    {</a>
<a name="ln2996">      // copy data</a>
<a name="ln2997">      err = dt_opencl_copy_device_to_host(devid, g-&gt;buf, dev_in, iwidth, iheight, 4 * sizeof(float));</a>
<a name="ln2998"> </a>
<a name="ln2999">      g-&gt;buf_width = iwidth;</a>
<a name="ln3000">      g-&gt;buf_height = iheight;</a>
<a name="ln3001">      g-&gt;buf_x_off = x_off;</a>
<a name="ln3002">      g-&gt;buf_y_off = y_off;</a>
<a name="ln3003">      g-&gt;buf_scale = scale;</a>
<a name="ln3004">      g-&gt;buf_hash = hash;</a>
<a name="ln3005">    }</a>
<a name="ln3006">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln3007">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3008">  }</a>
<a name="ln3009"> </a>
<a name="ln3010">  // if module is set to neutral parameters we just copy input-&gt;output and are done</a>
<a name="ln3011">  if(isneutral(d))</a>
<a name="ln3012">  {</a>
<a name="ln3013">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3014">    size_t region[] = { width, height, 1 };</a>
<a name="ln3015">    err = dt_opencl_enqueue_copy_image(devid, dev_in, dev_out, origin, origin, region);</a>
<a name="ln3016">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3017">    return TRUE;</a>
<a name="ln3018">  }</a>
<a name="ln3019"> </a>
<a name="ln3020">  float ihomograph[3][3];</a>
<a name="ln3021">  homography((float *)ihomograph, d-&gt;rotation, d-&gt;lensshift_v, d-&gt;lensshift_h, d-&gt;shear, d-&gt;f_length_kb,</a>
<a name="ln3022">             d-&gt;orthocorr, d-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln3023"> </a>
<a name="ln3024">  // clipping offset</a>
<a name="ln3025">  const float fullwidth = (float)piece-&gt;buf_out.width / (d-&gt;cr - d-&gt;cl);</a>
<a name="ln3026">  const float fullheight = (float)piece-&gt;buf_out.height / (d-&gt;cb - d-&gt;ct);</a>
<a name="ln3027">  const float cx = roi_out-&gt;scale * fullwidth * d-&gt;cl;</a>
<a name="ln3028">  const float cy = roi_out-&gt;scale * fullheight * d-&gt;ct;</a>
<a name="ln3029"> </a>
<a name="ln3030">  dev_homo = dt_opencl_copy_host_to_device_constant(devid, sizeof(float) * 9, ihomograph);</a>
<a name="ln3031">  if(dev_homo == NULL) goto error;</a>
<a name="ln3032"> </a>
<a name="ln3033">  const int iroi[2] = { roi_in-&gt;x, roi_in-&gt;y };</a>
<a name="ln3034">  const int oroi[2] = { roi_out-&gt;x, roi_out-&gt;y };</a>
<a name="ln3035">  const float in_scale = roi_in-&gt;scale;</a>
<a name="ln3036">  const float out_scale = roi_out-&gt;scale;</a>
<a name="ln3037">  const float clip[2] = { cx, cy };</a>
<a name="ln3038"> </a>
<a name="ln3039">  size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3040"> </a>
<a name="ln3041">  const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln3042"> </a>
<a name="ln3043">  int ldkernel = -1;</a>
<a name="ln3044"> </a>
<a name="ln3045">  switch(interpolation-&gt;id)</a>
<a name="ln3046">  {</a>
<a name="ln3047">    case DT_INTERPOLATION_BILINEAR:</a>
<a name="ln3048">      ldkernel = gd-&gt;kernel_ashift_bilinear;</a>
<a name="ln3049">      break;</a>
<a name="ln3050">    case DT_INTERPOLATION_BICUBIC:</a>
<a name="ln3051">      ldkernel = gd-&gt;kernel_ashift_bicubic;</a>
<a name="ln3052">      break;</a>
<a name="ln3053">    case DT_INTERPOLATION_LANCZOS2:</a>
<a name="ln3054">      ldkernel = gd-&gt;kernel_ashift_lanczos2;</a>
<a name="ln3055">      break;</a>
<a name="ln3056">    case DT_INTERPOLATION_LANCZOS3:</a>
<a name="ln3057">      ldkernel = gd-&gt;kernel_ashift_lanczos3;</a>
<a name="ln3058">      break;</a>
<a name="ln3059">    default:</a>
<a name="ln3060">      goto error;</a>
<a name="ln3061">  }</a>
<a name="ln3062"> </a>
<a name="ln3063">  dt_opencl_set_kernel_arg(devid, ldkernel, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3064">  dt_opencl_set_kernel_arg(devid, ldkernel, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3065">  dt_opencl_set_kernel_arg(devid, ldkernel, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3066">  dt_opencl_set_kernel_arg(devid, ldkernel, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3067">  dt_opencl_set_kernel_arg(devid, ldkernel, 4, sizeof(int), (void *)&amp;iwidth);</a>
<a name="ln3068">  dt_opencl_set_kernel_arg(devid, ldkernel, 5, sizeof(int), (void *)&amp;iheight);</a>
<a name="ln3069">  dt_opencl_set_kernel_arg(devid, ldkernel, 6, 2 * sizeof(int), (void *)iroi);</a>
<a name="ln3070">  dt_opencl_set_kernel_arg(devid, ldkernel, 7, 2 * sizeof(int), (void *)oroi);</a>
<a name="ln3071">  dt_opencl_set_kernel_arg(devid, ldkernel, 8, sizeof(float), (void *)&amp;in_scale);</a>
<a name="ln3072">  dt_opencl_set_kernel_arg(devid, ldkernel, 9, sizeof(float), (void *)&amp;out_scale);</a>
<a name="ln3073">  dt_opencl_set_kernel_arg(devid, ldkernel, 10, 2 * sizeof(float), (void *)clip);</a>
<a name="ln3074">  dt_opencl_set_kernel_arg(devid, ldkernel, 11, sizeof(cl_mem), (void *)&amp;dev_homo);</a>
<a name="ln3075">  err = dt_opencl_enqueue_kernel_2d(devid, ldkernel, sizes);</a>
<a name="ln3076">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln3077"> </a>
<a name="ln3078">  dt_opencl_release_mem_object(dev_homo);</a>
<a name="ln3079">  return TRUE;</a>
<a name="ln3080"> </a>
<a name="ln3081">error:</a>
<a name="ln3082">  dt_opencl_release_mem_object(dev_homo);</a>
<a name="ln3083">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_ashift] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3084">  return FALSE;</a>
<a name="ln3085">}</a>
<a name="ln3086">#endif</a>
<a name="ln3087"> </a>
<a name="ln3088">// gather information about &quot;near&quot;-ness in g-&gt;points_idx</a>
<a name="ln3089">static void get_near(const float *points, dt_iop_ashift_points_idx_t *points_idx, const int lines_count,</a>
<a name="ln3090">                     float pzx, float pzy, float delta)</a>
<a name="ln3091">{</a>
<a name="ln3092">  const float delta2 = delta * delta;</a>
<a name="ln3093"> </a>
<a name="ln3094">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3095">  {</a>
<a name="ln3096">    points_idx[n].near = 0;</a>
<a name="ln3097"> </a>
<a name="ln3098">    // skip irrelevant lines</a>
<a name="ln3099">    if(points_idx[n].type == ASHIFT_LINE_IRRELEVANT)</a>
<a name="ln3100">      continue;</a>
<a name="ln3101"> </a>
<a name="ln3102">    // first check if the mouse pointer is outside the bounding box of the line -&gt; skip this line</a>
<a name="ln3103">    if(pzx &lt; points_idx[n].bbx - delta &amp;&amp;</a>
<a name="ln3104">       pzx &gt; points_idx[n].bbX + delta &amp;&amp;</a>
<a name="ln3105">       pzy &lt; points_idx[n].bby - delta &amp;&amp;</a>
<a name="ln3106">       pzy &gt; points_idx[n].bbY + delta)</a>
<a name="ln3107">      continue;</a>
<a name="ln3108"> </a>
<a name="ln3109">    // pointer is inside bounding box</a>
<a name="ln3110">    size_t offset = points_idx[n].offset;</a>
<a name="ln3111">    const int length = points_idx[n].length;</a>
<a name="ln3112"> </a>
<a name="ln3113">    // sanity check (this should not happen)</a>
<a name="ln3114">    if(length &lt; 2) continue;</a>
<a name="ln3115"> </a>
<a name="ln3116">    // check line point by point</a>
<a name="ln3117">    for(int l = 0; l &lt; length; l++, offset++)</a>
<a name="ln3118">    {</a>
<a name="ln3119">      float dx = pzx - points[offset * 2];</a>
<a name="ln3120">      float dy = pzy - points[offset * 2 + 1];</a>
<a name="ln3121"> </a>
<a name="ln3122">      if(dx * dx + dy * dy &lt; delta2)</a>
<a name="ln3123">      {</a>
<a name="ln3124">        points_idx[n].near = 1;</a>
<a name="ln3125">        break;</a>
<a name="ln3126">      }</a>
<a name="ln3127">    }</a>
<a name="ln3128">  }</a>
<a name="ln3129">}</a>
<a name="ln3130"> </a>
<a name="ln3131">// mark lines which are inside a rectangular area in isbounding mode</a>
<a name="ln3132">static void get_bounded_inside(const float *points, dt_iop_ashift_points_idx_t *points_idx,</a>
<a name="ln3133">                               const int points_lines_count, float pzx, float pzy, float pzx2, float pzy2,</a>
<a name="ln3134">                               dt_iop_ashift_bounding_t mode)</a>
<a name="ln3135">{</a>
<a name="ln3136">  // get bounding box coordinates</a>
<a name="ln3137">  float ax = pzx;</a>
<a name="ln3138">  float ay = pzy;</a>
<a name="ln3139">  float bx = pzx2;</a>
<a name="ln3140">  float by = pzy2;</a>
<a name="ln3141">  if(pzx &gt; pzx2)</a>
<a name="ln3142">  {</a>
<a name="ln3143">    ax = pzx2;</a>
<a name="ln3144">    bx = pzx;</a>
<a name="ln3145">  }</a>
<a name="ln3146">  if(pzy &gt; pzy2)</a>
<a name="ln3147">  {</a>
<a name="ln3148">    ay = pzy2;</a>
<a name="ln3149">    by = pzy;</a>
<a name="ln3150">  }</a>
<a name="ln3151"> </a>
<a name="ln3152">  // we either look for the selected or the deselected lines</a>
<a name="ln3153">  dt_iop_ashift_linetype_t mask = ASHIFT_LINE_SELECTED;</a>
<a name="ln3154">  dt_iop_ashift_linetype_t state = (mode == ASHIFT_BOUNDING_DESELECT) ? ASHIFT_LINE_SELECTED : 0;</a>
<a name="ln3155"> </a>
<a name="ln3156">  for(int n = 0; n &lt; points_lines_count; n++)</a>
<a name="ln3157">  {</a>
<a name="ln3158">    // mark line as &quot;not near&quot; and &quot;not bounded&quot;</a>
<a name="ln3159">    points_idx[n].near = 0;</a>
<a name="ln3160">    points_idx[n].bounded = 0;</a>
<a name="ln3161"> </a>
<a name="ln3162">    // skip irrelevant lines</a>
<a name="ln3163">    if(points_idx[n].type == ASHIFT_LINE_IRRELEVANT)</a>
<a name="ln3164">      continue;</a>
<a name="ln3165"> </a>
<a name="ln3166">    // is the line inside the box ?</a>
<a name="ln3167">    if(points_idx[n].bbx &gt;= ax &amp;&amp; points_idx[n].bbx &lt;= bx &amp;&amp; points_idx[n].bbX &gt;= ax</a>
<a name="ln3168">       &amp;&amp; points_idx[n].bbX &lt;= bx &amp;&amp; points_idx[n].bby &gt;= ay &amp;&amp; points_idx[n].bby &lt;= by</a>
<a name="ln3169">       &amp;&amp; points_idx[n].bbY &gt;= ay &amp;&amp; points_idx[n].bbY &lt;= by)</a>
<a name="ln3170">    {</a>
<a name="ln3171">      points_idx[n].bounded = 1;</a>
<a name="ln3172">      // only mark &quot;near&quot;-ness of those lines we are interested in</a>
<a name="ln3173">      points_idx[n].near = ((points_idx[n].type &amp; mask) != state) ? 0 : 1;</a>
<a name="ln3174">    }</a>
<a name="ln3175">  }</a>
<a name="ln3176">}</a>
<a name="ln3177"> </a>
<a name="ln3178">// generate hash value for lines taking into account only the end point coordinates</a>
<a name="ln3179">static uint64_t get_lines_hash(const dt_iop_ashift_line_t *lines, const int lines_count)</a>
<a name="ln3180">{</a>
<a name="ln3181">  uint64_t hash = 5381;</a>
<a name="ln3182">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3183">  {</a>
<a name="ln3184">    float v[4] = { lines[n].p1[0], lines[n].p1[1], lines[n].p2[0], lines[n].p2[1] };</a>
<a name="ln3185"> </a>
<a name="ln3186">    for(int i = 0; i &lt; 4; i++)</a>
<a name="ln3187">      hash = ((hash &lt;&lt; 5) + hash) ^ ((uint32_t *)v)[i];</a>
<a name="ln3188">  }</a>
<a name="ln3189">  return hash;</a>
<a name="ln3190">}</a>
<a name="ln3191"> </a>
<a name="ln3192">// update color information in points_idx if lines have changed in terms of type (but not in terms</a>
<a name="ln3193">// of number or position)</a>
<a name="ln3194">static int update_colors(struct dt_iop_module_t *self, dt_iop_ashift_points_idx_t *points_idx,</a>
<a name="ln3195">                         int points_lines_count)</a>
<a name="ln3196">{</a>
<a name="ln3197">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3198"> </a>
<a name="ln3199">  // is the display flipped relative to the original image?</a>
<a name="ln3200">  const int isflipped = g-&gt;isflipped;</a>
<a name="ln3201"> </a>
<a name="ln3202">  // go through all lines</a>
<a name="ln3203">  for(int n = 0; n &lt; points_lines_count; n++)</a>
<a name="ln3204">  {</a>
<a name="ln3205">    const dt_iop_ashift_linetype_t type = points_idx[n].type;</a>
<a name="ln3206"> </a>
<a name="ln3207">    // set line color according to line type/orientation</a>
<a name="ln3208">    // note: if the screen display is flipped versus the original image we need</a>
<a name="ln3209">    // to respect that fact in the color selection</a>
<a name="ln3210">    if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_SELECTED)</a>
<a name="ln3211">      points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_BLUE : ASHIFT_LINECOLOR_GREEN;</a>
<a name="ln3212">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_NOT_SELECTED)</a>
<a name="ln3213">      points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_YELLOW : ASHIFT_LINECOLOR_RED;</a>
<a name="ln3214">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_SELECTED)</a>
<a name="ln3215">      points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_GREEN : ASHIFT_LINECOLOR_BLUE;</a>
<a name="ln3216">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_NOT_SELECTED)</a>
<a name="ln3217">      points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_RED : ASHIFT_LINECOLOR_YELLOW;</a>
<a name="ln3218">    else</a>
<a name="ln3219">      points_idx[n].color = ASHIFT_LINECOLOR_GREY;</a>
<a name="ln3220">  }</a>
<a name="ln3221"> </a>
<a name="ln3222">  return TRUE;</a>
<a name="ln3223">}</a>
<a name="ln3224"> </a>
<a name="ln3225">// get all the points to display lines in the gui</a>
<a name="ln3226">static int get_points(struct dt_iop_module_t *self, const dt_iop_ashift_line_t *lines, const int lines_count,</a>
<a name="ln3227">                      const int lines_version, float **points, dt_iop_ashift_points_idx_t **points_idx,</a>
<a name="ln3228">                      int *points_lines_count)</a>
<a name="ln3229">{</a>
<a name="ln3230">  dt_develop_t *dev = self-&gt;dev;</a>
<a name="ln3231">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3232"> </a>
<a name="ln3233">  dt_iop_ashift_points_idx_t *my_points_idx = NULL;</a>
<a name="ln3234">  float *my_points = NULL;</a>
<a name="ln3235"> </a>
<a name="ln3236">  // is the display flipped relative to the original image?</a>
<a name="ln3237">  const int isflipped = g-&gt;isflipped;</a>
<a name="ln3238"> </a>
<a name="ln3239">  // allocate new index array</a>
<a name="ln3240">  my_points_idx = (dt_iop_ashift_points_idx_t *)malloc(lines_count * sizeof(dt_iop_ashift_points_idx_t));</a>
<a name="ln3241">  if(my_points_idx == NULL) goto error;</a>
<a name="ln3242"> </a>
<a name="ln3243">  // account for total number of points</a>
<a name="ln3244">  size_t total_points = 0;</a>
<a name="ln3245"> </a>
<a name="ln3246">  // first step: basic initialization of my_points_idx and counting of total_points</a>
<a name="ln3247">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3248">  {</a>
<a name="ln3249">    const int length = lines[n].length;</a>
<a name="ln3250"> </a>
<a name="ln3251">    total_points += length;</a>
<a name="ln3252"> </a>
<a name="ln3253">    my_points_idx[n].length = length;</a>
<a name="ln3254">    my_points_idx[n].near = 0;</a>
<a name="ln3255">    my_points_idx[n].bounded = 0;</a>
<a name="ln3256"> </a>
<a name="ln3257">    const dt_iop_ashift_linetype_t type = lines[n].type;</a>
<a name="ln3258">    my_points_idx[n].type = type;</a>
<a name="ln3259"> </a>
<a name="ln3260">    // set line color according to line type/orientation</a>
<a name="ln3261">    // note: if the screen display is flipped versus the original image we need</a>
<a name="ln3262">    // to respect that fact in the color selection</a>
<a name="ln3263">    if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_SELECTED)</a>
<a name="ln3264">      my_points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_BLUE : ASHIFT_LINECOLOR_GREEN;</a>
<a name="ln3265">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_NOT_SELECTED)</a>
<a name="ln3266">      my_points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_YELLOW : ASHIFT_LINECOLOR_RED;</a>
<a name="ln3267">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_SELECTED)</a>
<a name="ln3268">      my_points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_GREEN : ASHIFT_LINECOLOR_BLUE;</a>
<a name="ln3269">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_NOT_SELECTED)</a>
<a name="ln3270">      my_points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_RED : ASHIFT_LINECOLOR_YELLOW;</a>
<a name="ln3271">    else</a>
<a name="ln3272">      my_points_idx[n].color = ASHIFT_LINECOLOR_GREY;</a>
<a name="ln3273">  }</a>
<a name="ln3274"> </a>
<a name="ln3275">  // now allocate new points buffer</a>
<a name="ln3276">  my_points = (float *)malloc((size_t)2 * total_points * sizeof(float));</a>
<a name="ln3277">  if(my_points == NULL) goto error;</a>
<a name="ln3278"> </a>
<a name="ln3279">  // second step: generate points for each line</a>
<a name="ln3280">  for(int n = 0, offset = 0; n &lt; lines_count; n++)</a>
<a name="ln3281">  {</a>
<a name="ln3282">    my_points_idx[n].offset = offset;</a>
<a name="ln3283"> </a>
<a name="ln3284">    float x = lines[n].p1[0];</a>
<a name="ln3285">    float y = lines[n].p1[1];</a>
<a name="ln3286">    const int length = lines[n].length;</a>
<a name="ln3287"> </a>
<a name="ln3288">    const float dx = (lines[n].p2[0] - x) / (float)(length - 1);</a>
<a name="ln3289">    const float dy = (lines[n].p2[1] - y) / (float)(length - 1);</a>
<a name="ln3290"> </a>
<a name="ln3291">    for(int l = 0; l &lt; length &amp;&amp; offset &lt; total_points; l++, offset++)</a>
<a name="ln3292">    {</a>
<a name="ln3293">      my_points[2 * offset] = x;</a>
<a name="ln3294">      my_points[2 * offset + 1] = y;</a>
<a name="ln3295"> </a>
<a name="ln3296">      x += dx;</a>
<a name="ln3297">      y += dy;</a>
<a name="ln3298">    }</a>
<a name="ln3299">  }</a>
<a name="ln3300"> </a>
<a name="ln3301">  // third step: transform all points</a>
<a name="ln3302">  if(!dt_dev_distort_transform_plus(dev, dev-&gt;preview_pipe, self-&gt;priority, 9999999, my_points, total_points))</a>
<a name="ln3303">    goto error;</a>
<a name="ln3304"> </a>
<a name="ln3305">  // fourth step: get bounding box in final coordinates (used later for checking &quot;near&quot;-ness to mouse pointer)</a>
<a name="ln3306">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3307">  {</a>
<a name="ln3308">    float xmin = FLT_MAX, xmax = FLT_MIN, ymin = FLT_MAX, ymax = FLT_MIN;</a>
<a name="ln3309"> </a>
<a name="ln3310">    size_t offset = my_points_idx[n].offset;</a>
<a name="ln3311">    int length = my_points_idx[n].length;</a>
<a name="ln3312"> </a>
<a name="ln3313">    for(int l = 0; l &lt; length; l++)</a>
<a name="ln3314">    {</a>
<a name="ln3315">      xmin = fmin(xmin, my_points[2 * offset]);</a>
<a name="ln3316">      xmax = fmax(xmax, my_points[2 * offset]);</a>
<a name="ln3317">      ymin = fmin(ymin, my_points[2 * offset + 1]);</a>
<a name="ln3318">      ymax = fmax(ymax, my_points[2 * offset + 1]);</a>
<a name="ln3319">    }</a>
<a name="ln3320"> </a>
<a name="ln3321">    my_points_idx[n].bbx = xmin;</a>
<a name="ln3322">    my_points_idx[n].bbX = xmax;</a>
<a name="ln3323">    my_points_idx[n].bby = ymin;</a>
<a name="ln3324">    my_points_idx[n].bbY = ymax;</a>
<a name="ln3325">  }</a>
<a name="ln3326"> </a>
<a name="ln3327">  // check if lines_version has changed in-between -&gt; too bad: we can forget about all we did :(</a>
<a name="ln3328">  if(g-&gt;lines_version &gt; lines_version)</a>
<a name="ln3329">    goto error;</a>
<a name="ln3330"> </a>
<a name="ln3331">  *points = my_points;</a>
<a name="ln3332">  *points_idx = my_points_idx;</a>
<a name="ln3333">  *points_lines_count = lines_count;</a>
<a name="ln3334"> </a>
<a name="ln3335">  return TRUE;</a>
<a name="ln3336"> </a>
<a name="ln3337">error:</a>
<a name="ln3338">  if(my_points_idx != NULL) free(my_points_idx);</a>
<a name="ln3339">  if(my_points != NULL) free(my_points);</a>
<a name="ln3340">  return FALSE;</a>
<a name="ln3341">}</a>
<a name="ln3342"> </a>
<a name="ln3343">// does this gui have focus?</a>
<a name="ln3344">static int gui_has_focus(struct dt_iop_module_t *self)</a>
<a name="ln3345">{</a>
<a name="ln3346">  return self-&gt;dev-&gt;gui_module == self;</a>
<a name="ln3347">}</a>
<a name="ln3348"> </a>
<a name="ln3349">void gui_post_expose(struct dt_iop_module_t *self, cairo_t *cr, int32_t width, int32_t height,</a>
<a name="ln3350">                     int32_t pointerx, int32_t pointery)</a>
<a name="ln3351">{</a>
<a name="ln3352">  dt_develop_t *dev = self-&gt;dev;</a>
<a name="ln3353">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3354">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln3355"> </a>
<a name="ln3356">  // the usual rescaling stuff</a>
<a name="ln3357">  const float wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3358">  const float ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3359">  if(wd &lt; 1.0 || ht &lt; 1.0) return;</a>
<a name="ln3360">  const float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln3361">  const float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln3362">  const dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln3363">  const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln3364">  const float zoom_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln3365"> </a>
<a name="ln3366">  // we draw the cropping area; we need x_off/y_off/width/height which is only available</a>
<a name="ln3367">  // after g-&gt;buf has been processed</a>
<a name="ln3368">  if(g-&gt;buf &amp;&amp; (p-&gt;cropmode != ASHIFT_CROP_OFF) &amp;&amp; self-&gt;enabled)</a>
<a name="ln3369">  {</a>
<a name="ln3370">    // roi data of the preview pipe input buffer</a>
<a name="ln3371">    const float iwd = g-&gt;buf_width;</a>
<a name="ln3372">    const float iht = g-&gt;buf_height;</a>
<a name="ln3373">    const float ixo = g-&gt;buf_x_off;</a>
<a name="ln3374">    const float iyo = g-&gt;buf_y_off;</a>
<a name="ln3375"> </a>
<a name="ln3376">    // the four corners of the input buffer of this module</a>
<a name="ln3377">    const float V[4][2] = { { ixo,        iyo       },</a>
<a name="ln3378">                          {   ixo,        iyo + iht },</a>
<a name="ln3379">                          {   ixo + iwd,  iyo + iht },</a>
<a name="ln3380">                          {   ixo + iwd,  iyo       } };</a>
<a name="ln3381"> </a>
<a name="ln3382">    // convert coordinates of corners to coordinates of this module's output</a>
<a name="ln3383">    if(!dt_dev_distort_transform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;priority, self-&gt;priority + 1,</a>
<a name="ln3384">      (float *)V, 4))</a>
<a name="ln3385">      return;</a>
<a name="ln3386"> </a>
<a name="ln3387">    // get x/y-offset as well as width and height of output buffer</a>
<a name="ln3388">    float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN;</a>
<a name="ln3389">    for(int n = 0; n &lt; 4; n++)</a>
<a name="ln3390">    {</a>
<a name="ln3391">      xmin = MIN(xmin, V[n][0]);</a>
<a name="ln3392">      xmax = MAX(xmax, V[n][0]);</a>
<a name="ln3393">      ymin = MIN(ymin, V[n][1]);</a>
<a name="ln3394">      ymax = MAX(ymax, V[n][1]);</a>
<a name="ln3395">    }</a>
<a name="ln3396">    const float owd = xmax - xmin;</a>
<a name="ln3397">    const float oht = ymax - ymin;</a>
<a name="ln3398"> </a>
<a name="ln3399">    // the four clipping corners</a>
<a name="ln3400">    const float C[4][2] = { { xmin + p-&gt;cl * owd, ymin + p-&gt;ct * oht },</a>
<a name="ln3401">                            { xmin + p-&gt;cl * owd, ymin + p-&gt;cb * oht },</a>
<a name="ln3402">                            { xmin + p-&gt;cr * owd, ymin + p-&gt;cb * oht },</a>
<a name="ln3403">                            { xmin + p-&gt;cr * owd, ymin + p-&gt;ct * oht } };</a>
<a name="ln3404"> </a>
<a name="ln3405">    // convert clipping corners to final output image</a>
<a name="ln3406">    if(!dt_dev_distort_transform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;priority + 1, 9999999,</a>
<a name="ln3407">      (float *)C, 4))</a>
<a name="ln3408">      return;</a>
<a name="ln3409"> </a>
<a name="ln3410">    cairo_save(cr);</a>
<a name="ln3411"> </a>
<a name="ln3412">    double dashes = DT_PIXEL_APPLY_DPI(5.0) / zoom_scale;</a>
<a name="ln3413">    cairo_set_dash(cr, &amp;dashes, 0, 0);</a>
<a name="ln3414"> </a>
<a name="ln3415">    cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3416">    cairo_clip(cr);</a>
<a name="ln3417"> </a>
<a name="ln3418">    // mask parts of image outside of clipping area in dark grey</a>
<a name="ln3419">    cairo_set_source_rgba(cr, .2, .2, .2, .8);</a>
<a name="ln3420">    cairo_set_fill_rule(cr, CAIRO_FILL_RULE_EVEN_ODD);</a>
<a name="ln3421">    cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3422">    cairo_translate(cr, width / 2.0, height / 2.0);</a>
<a name="ln3423">    cairo_scale(cr, zoom_scale, zoom_scale);</a>
<a name="ln3424">    cairo_translate(cr, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln3425">    cairo_move_to(cr, C[0][0], C[0][1]);</a>
<a name="ln3426">    cairo_line_to(cr, C[1][0], C[1][1]);</a>
<a name="ln3427">    cairo_line_to(cr, C[2][0], C[2][1]);</a>
<a name="ln3428">    cairo_line_to(cr, C[3][0], C[3][1]);</a>
<a name="ln3429">    cairo_close_path(cr);</a>
<a name="ln3430">    cairo_fill(cr);</a>
<a name="ln3431"> </a>
<a name="ln3432">    // draw white outline around clipping area</a>
<a name="ln3433">    cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln3434">    cairo_move_to(cr, C[0][0], C[0][1]);</a>
<a name="ln3435">    cairo_line_to(cr, C[1][0], C[1][1]);</a>
<a name="ln3436">    cairo_line_to(cr, C[2][0], C[2][1]);</a>
<a name="ln3437">    cairo_line_to(cr, C[3][0], C[3][1]);</a>
<a name="ln3438">    cairo_close_path(cr);</a>
<a name="ln3439">    cairo_stroke(cr);</a>
<a name="ln3440"> </a>
<a name="ln3441">    // if adjusting crop, draw indicator</a>
<a name="ln3442">    if (g-&gt;adjust_crop &amp;&amp; p-&gt;cropmode == ASHIFT_CROP_ASPECT)</a>
<a name="ln3443">    {</a>
<a name="ln3444">      const double xpos = (C[1][0] + C[2][0]) / 2.0f;</a>
<a name="ln3445">      const double ypos = (C[0][1] + C[1][1]) / 2.0f;</a>
<a name="ln3446">      const double size_circle = (C[2][0] - C[1][0]) / 30.0f;</a>
<a name="ln3447">      const double size_line = (C[2][0] - C[1][0]) / 5.0f;</a>
<a name="ln3448">      const double size_arrow = (C[2][0] - C[1][0]) / 25.0f;</a>
<a name="ln3449"> </a>
<a name="ln3450">      cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln3451">      cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln3452">      cairo_arc (cr, xpos, ypos, size_circle, 0, 2.0 * M_PI);</a>
<a name="ln3453">      cairo_stroke(cr);</a>
<a name="ln3454">      cairo_fill(cr);</a>
<a name="ln3455"> </a>
<a name="ln3456">      cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln3457">      cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln3458"> </a>
<a name="ln3459">      // horizontal line</a>
<a name="ln3460">      cairo_move_to(cr, xpos - size_line, ypos);</a>
<a name="ln3461">      cairo_line_to(cr, xpos + size_line, ypos);</a>
<a name="ln3462"> </a>
<a name="ln3463">      cairo_move_to(cr, xpos - size_line, ypos);</a>
<a name="ln3464">      cairo_rel_line_to(cr, size_arrow, size_arrow);</a>
<a name="ln3465">      cairo_move_to(cr, xpos - size_line, ypos);</a>
<a name="ln3466">      cairo_rel_line_to(cr, size_arrow, -size_arrow);</a>
<a name="ln3467"> </a>
<a name="ln3468">      cairo_move_to(cr, xpos + size_line, ypos);</a>
<a name="ln3469">      cairo_rel_line_to(cr, -size_arrow, size_arrow);</a>
<a name="ln3470">      cairo_move_to(cr, xpos + size_line, ypos);</a>
<a name="ln3471">      cairo_rel_line_to(cr, -size_arrow, -size_arrow);</a>
<a name="ln3472"> </a>
<a name="ln3473">      // vertical line</a>
<a name="ln3474">      cairo_move_to(cr, xpos, ypos - size_line);</a>
<a name="ln3475">      cairo_line_to(cr, xpos, ypos + size_line);</a>
<a name="ln3476"> </a>
<a name="ln3477">      cairo_move_to(cr, xpos, ypos - size_line);</a>
<a name="ln3478">      cairo_rel_line_to(cr, -size_arrow, size_arrow);</a>
<a name="ln3479">      cairo_move_to(cr, xpos, ypos - size_line);</a>
<a name="ln3480">      cairo_rel_line_to(cr, size_arrow, size_arrow);</a>
<a name="ln3481"> </a>
<a name="ln3482">      cairo_move_to(cr, xpos, ypos + size_line);</a>
<a name="ln3483">      cairo_rel_line_to(cr, -size_arrow, -size_arrow);</a>
<a name="ln3484">      cairo_move_to(cr, xpos, ypos + size_line);</a>
<a name="ln3485">      cairo_rel_line_to(cr, size_arrow, -size_arrow);</a>
<a name="ln3486"> </a>
<a name="ln3487">      cairo_stroke(cr);</a>
<a name="ln3488">    }</a>
<a name="ln3489"> </a>
<a name="ln3490">    cairo_restore(cr);</a>
<a name="ln3491">  }</a>
<a name="ln3492"> </a>
<a name="ln3493">  // show guide lines on request</a>
<a name="ln3494">  if(g-&gt;show_guides)</a>
<a name="ln3495">  {</a>
<a name="ln3496">    dt_guides_t *guide = (dt_guides_t *)g_list_nth_data(darktable.guides, 0);</a>
<a name="ln3497">    double dashes = DT_PIXEL_APPLY_DPI(5.0);</a>
<a name="ln3498">    cairo_save(cr);</a>
<a name="ln3499">    cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3500">    cairo_clip(cr);</a>
<a name="ln3501">    cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.0));</a>
<a name="ln3502">    cairo_set_source_rgb(cr, .8, .8, .8);</a>
<a name="ln3503">    cairo_set_dash(cr, &amp;dashes, 1, 0);</a>
<a name="ln3504">    guide-&gt;draw(cr, 0, 0, width, height, 1.0, guide-&gt;user_data);</a>
<a name="ln3505">    cairo_stroke_preserve(cr);</a>
<a name="ln3506">    cairo_set_dash(cr, &amp;dashes, 0, 0);</a>
<a name="ln3507">    cairo_set_source_rgba(cr, 0.3, .3, .3, .8);</a>
<a name="ln3508">    cairo_stroke(cr);</a>
<a name="ln3509">    cairo_restore(cr);</a>
<a name="ln3510">  }</a>
<a name="ln3511"> </a>
<a name="ln3512">  // structural data are currently being collected or fit procedure is running? -&gt; skip</a>
<a name="ln3513">  if(g-&gt;fitting) return;</a>
<a name="ln3514"> </a>
<a name="ln3515">  // no structural data or visibility switched off? -&gt; stop here</a>
<a name="ln3516">  if(g-&gt;lines == NULL || g-&gt;lines_suppressed || !gui_has_focus(self)) return;</a>
<a name="ln3517"> </a>
<a name="ln3518">  // get hash value that changes if distortions from here to the end of the pixelpipe changed</a>
<a name="ln3519">  uint64_t hash = dt_dev_hash_distort(dev);</a>
<a name="ln3520">  // get hash value that changes if coordinates of lines have changed</a>
<a name="ln3521">  uint64_t lines_hash = get_lines_hash(g-&gt;lines, g-&gt;lines_count);</a>
<a name="ln3522"> </a>
<a name="ln3523">  // points data are missing or outdated, or distortion has changed?</a>
<a name="ln3524">  if(g-&gt;points == NULL || g-&gt;points_idx == NULL || hash != g-&gt;grid_hash ||</a>
<a name="ln3525">    (g-&gt;lines_version &gt; g-&gt;points_version &amp;&amp; g-&gt;lines_hash != lines_hash))</a>
<a name="ln3526">  {</a>
<a name="ln3527">    // we need to reprocess points</a>
<a name="ln3528">    free(g-&gt;points);</a>
<a name="ln3529">    g-&gt;points = NULL;</a>
<a name="ln3530">    free(g-&gt;points_idx);</a>
<a name="ln3531">    g-&gt;points_idx = NULL;</a>
<a name="ln3532">    g-&gt;points_lines_count = 0;</a>
<a name="ln3533"> </a>
<a name="ln3534">    if(!get_points(self, g-&gt;lines, g-&gt;lines_count, g-&gt;lines_version, &amp;g-&gt;points, &amp;g-&gt;points_idx,</a>
<a name="ln3535">                   &amp;g-&gt;points_lines_count))</a>
<a name="ln3536">      return;</a>
<a name="ln3537"> </a>
<a name="ln3538">    g-&gt;points_version = g-&gt;lines_version;</a>
<a name="ln3539">    g-&gt;grid_hash = hash;</a>
<a name="ln3540">    g-&gt;lines_hash = lines_hash;</a>
<a name="ln3541">  }</a>
<a name="ln3542">  else if(g-&gt;lines_hash == lines_hash)</a>
<a name="ln3543">  {</a>
<a name="ln3544">    // update line type information in points_idx</a>
<a name="ln3545">    for(int n = 0; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3546">      g-&gt;points_idx[n].type = g-&gt;lines[n].type;</a>
<a name="ln3547"> </a>
<a name="ln3548">    // coordinates of lines are unchanged -&gt; we only need to update colors</a>
<a name="ln3549">    if(!update_colors(self, g-&gt;points_idx, g-&gt;points_lines_count))</a>
<a name="ln3550">      return;</a>
<a name="ln3551"> </a>
<a name="ln3552">    g-&gt;points_version = g-&gt;lines_version;</a>
<a name="ln3553">  }</a>
<a name="ln3554"> </a>
<a name="ln3555">  // a final check</a>
<a name="ln3556">  if(g-&gt;points == NULL || g-&gt;points_idx == NULL) return;</a>
<a name="ln3557"> </a>
<a name="ln3558">  cairo_save(cr);</a>
<a name="ln3559">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3560">  cairo_clip(cr);</a>
<a name="ln3561">  cairo_translate(cr, width / 2.0, height / 2.0);</a>
<a name="ln3562">  cairo_scale(cr, zoom_scale, zoom_scale);</a>
<a name="ln3563">  cairo_translate(cr, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln3564"> </a>
<a name="ln3565">  // this must match the sequence of enum dt_iop_ashift_linecolor_t!</a>
<a name="ln3566">  const float line_colors[5][4] =</a>
<a name="ln3567">  { { 0.3f, 0.3f, 0.3f, 0.8f },                    // grey (misc. lines)</a>
<a name="ln3568">    { 0.0f, 1.0f, 0.0f, 0.8f },                    // green (selected vertical lines)</a>
<a name="ln3569">    { 0.8f, 0.0f, 0.0f, 0.8f },                    // red (de-selected vertical lines)</a>
<a name="ln3570">    { 0.0f, 0.0f, 1.0f, 0.8f },                    // blue (selected horizontal lines)</a>
<a name="ln3571">    { 0.8f, 0.8f, 0.0f, 0.8f } };                  // yellow (de-selected horizontal lines)</a>
<a name="ln3572"> </a>
<a name="ln3573">  cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln3574"> </a>
<a name="ln3575">  // now draw all lines</a>
<a name="ln3576">  for(int n = 0; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3577">  {</a>
<a name="ln3578">    // is the near flag set? -&gt; draw line a bit thicker</a>
<a name="ln3579">    if(g-&gt;points_idx[n].near)</a>
<a name="ln3580">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(3.0) / zoom_scale);</a>
<a name="ln3581">    else</a>
<a name="ln3582">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.5) / zoom_scale);</a>
<a name="ln3583"> </a>
<a name="ln3584">    // the color of this line</a>
<a name="ln3585">    const float *color = line_colors[g-&gt;points_idx[n].color];</a>
<a name="ln3586">    cairo_set_source_rgba(cr, color[0], color[1], color[2], color[3]);</a>
<a name="ln3587"> </a>
<a name="ln3588">    size_t offset = g-&gt;points_idx[n].offset;</a>
<a name="ln3589">    const int length = g-&gt;points_idx[n].length;</a>
<a name="ln3590"> </a>
<a name="ln3591">    // sanity check (this should not happen)</a>
<a name="ln3592">    if(length &lt; 2) continue;</a>
<a name="ln3593"> </a>
<a name="ln3594">    // set starting point of multi-segment line</a>
<a name="ln3595">    cairo_move_to(cr, g-&gt;points[offset * 2], g-&gt;points[offset * 2 + 1]);</a>
<a name="ln3596"> </a>
<a name="ln3597">    offset++;</a>
<a name="ln3598">    // draw individual line segments</a>
<a name="ln3599">    for(int l = 1; l &lt; length; l++, offset++)</a>
<a name="ln3600">    {</a>
<a name="ln3601">      cairo_line_to(cr, g-&gt;points[offset * 2], g-&gt;points[offset * 2 + 1]);</a>
<a name="ln3602">    }</a>
<a name="ln3603"> </a>
<a name="ln3604">    // finally stroke the line</a>
<a name="ln3605">    cairo_stroke(cr);</a>
<a name="ln3606">  }</a>
<a name="ln3607"> </a>
<a name="ln3608">  // and we draw the selection box if any</a>
<a name="ln3609">  if(g-&gt;isbounding != ASHIFT_BOUNDING_OFF)</a>
<a name="ln3610">  {</a>
<a name="ln3611">    float pzx, pzy;</a>
<a name="ln3612">    dt_dev_get_pointer_zoom_pos(dev, pointerx, pointery, &amp;pzx, &amp;pzy);</a>
<a name="ln3613">    pzx += 0.5f;</a>
<a name="ln3614">    pzy += 0.5f;</a>
<a name="ln3615"> </a>
<a name="ln3616">    double dashed[] = { 4.0, 4.0 };</a>
<a name="ln3617">    dashed[0] /= zoom_scale;</a>
<a name="ln3618">    dashed[1] /= zoom_scale;</a>
<a name="ln3619">    int len = sizeof(dashed) / sizeof(dashed[0]);</a>
<a name="ln3620"> </a>
<a name="ln3621">    cairo_rectangle(cr, g-&gt;lastx * wd, g-&gt;lasty * ht, (pzx - g-&gt;lastx) * wd, (pzy - g-&gt;lasty) * ht);</a>
<a name="ln3622"> </a>
<a name="ln3623">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln3624">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln3625">    cairo_set_dash(cr, dashed, len, 0);</a>
<a name="ln3626">    cairo_stroke_preserve(cr);</a>
<a name="ln3627">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln3628">    cairo_set_dash(cr, dashed, len, 4);</a>
<a name="ln3629">    cairo_stroke(cr);</a>
<a name="ln3630">  }</a>
<a name="ln3631"> </a>
<a name="ln3632">  // indicate which area is used for &quot;near&quot;-ness detection when selecting/deselecting lines</a>
<a name="ln3633">  if(g-&gt;near_delta &gt; 0)</a>
<a name="ln3634">  {</a>
<a name="ln3635">    float pzx, pzy;</a>
<a name="ln3636">    dt_dev_get_pointer_zoom_pos(dev, pointerx, pointery, &amp;pzx, &amp;pzy);</a>
<a name="ln3637">    pzx += 0.5f;</a>
<a name="ln3638">    pzy += 0.5f;</a>
<a name="ln3639"> </a>
<a name="ln3640">    double dashed[] = { 4.0, 4.0 };</a>
<a name="ln3641">    dashed[0] /= zoom_scale;</a>
<a name="ln3642">    dashed[1] /= zoom_scale;</a>
<a name="ln3643">    int len = sizeof(dashed) / sizeof(dashed[0]);</a>
<a name="ln3644"> </a>
<a name="ln3645">    cairo_arc(cr, pzx * wd, pzy * ht, g-&gt;near_delta, 0, 2.0 * M_PI);</a>
<a name="ln3646"> </a>
<a name="ln3647">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln3648">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln3649">    cairo_set_dash(cr, dashed, len, 0);</a>
<a name="ln3650">    cairo_stroke_preserve(cr);</a>
<a name="ln3651">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln3652">    cairo_set_dash(cr, dashed, len, 4);</a>
<a name="ln3653">    cairo_stroke(cr);</a>
<a name="ln3654">  }</a>
<a name="ln3655"> </a>
<a name="ln3656">  cairo_restore(cr);</a>
<a name="ln3657">}</a>
<a name="ln3658"> </a>
<a name="ln3659">// update the number of selected vertical and horizontal lines</a>
<a name="ln3660">static void update_lines_count(const dt_iop_ashift_line_t *lines, const int lines_count,</a>
<a name="ln3661">                        int *vertical_count, int *horizontal_count)</a>
<a name="ln3662">{</a>
<a name="ln3663">  int vlines = 0;</a>
<a name="ln3664">  int hlines = 0;</a>
<a name="ln3665"> </a>
<a name="ln3666">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3667">  {</a>
<a name="ln3668">    if((lines[n].type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_SELECTED)</a>
<a name="ln3669">      vlines++;</a>
<a name="ln3670">    else if((lines[n].type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_SELECTED)</a>
<a name="ln3671">      hlines++;</a>
<a name="ln3672">  }</a>
<a name="ln3673"> </a>
<a name="ln3674">  *vertical_count = vlines;</a>
<a name="ln3675">  *horizontal_count = hlines;</a>
<a name="ln3676">}</a>
<a name="ln3677"> </a>
<a name="ln3678">int mouse_moved(struct dt_iop_module_t *self, double x, double y, double pressure, int which)</a>
<a name="ln3679">{</a>
<a name="ln3680">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3681">  int handled = 0;</a>
<a name="ln3682"> </a>
<a name="ln3683">  const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3684">  const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3685">  if(wd &lt; 1.0 || ht &lt; 1.0) return 1;</a>
<a name="ln3686"> </a>
<a name="ln3687">  float pzx, pzy;</a>
<a name="ln3688">  dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln3689">  pzx += 0.5f;</a>
<a name="ln3690">  pzy += 0.5f;</a>
<a name="ln3691"> </a>
<a name="ln3692">  if (g-&gt;adjust_crop)</a>
<a name="ln3693">  {</a>
<a name="ln3694">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln3695">    const float newx = g-&gt;crop_cx + pzx - g-&gt;lastx;</a>
<a name="ln3696">    const float newy = g-&gt;crop_cy + pzy - g-&gt;lasty;</a>
<a name="ln3697">    crop_adjust(self, p, newx, newy);</a>
<a name="ln3698">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3699">    return TRUE;</a>
<a name="ln3700">  }</a>
<a name="ln3701"> </a>
<a name="ln3702">  // if in rectangle selecting mode adjust &quot;near&quot;-ness of lines according to</a>
<a name="ln3703">  // the rectangular selection</a>
<a name="ln3704">  if(g-&gt;isbounding != ASHIFT_BOUNDING_OFF)</a>
<a name="ln3705">  {</a>
<a name="ln3706">    if(wd &gt;= 1.0 &amp;&amp; ht &gt;= 1.0)</a>
<a name="ln3707">    {</a>
<a name="ln3708">      // mark lines inside the rectangle</a>
<a name="ln3709">      get_bounded_inside(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;lastx * wd,</a>
<a name="ln3710">                         g-&gt;lasty * ht, g-&gt;isbounding);</a>
<a name="ln3711">    }</a>
<a name="ln3712"> </a>
<a name="ln3713">    dt_control_queue_redraw_center();</a>
<a name="ln3714">    return FALSE;</a>
<a name="ln3715">  }</a>
<a name="ln3716"> </a>
<a name="ln3717">  // gather information about &quot;near&quot;-ness in g-&gt;points_idx</a>
<a name="ln3718">  get_near(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;near_delta);</a>
<a name="ln3719"> </a>
<a name="ln3720">  // if we are in sweeping mode iterate over lines as we move the pointer and change &quot;selected&quot; state.</a>
<a name="ln3721">  if(g-&gt;isdeselecting || g-&gt;isselecting)</a>
<a name="ln3722">  {</a>
<a name="ln3723">    for(int n = 0; g-&gt;selecting_lines_version == g-&gt;lines_version &amp;&amp; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3724">    {</a>
<a name="ln3725">      if(g-&gt;points_idx[n].near == 0)</a>
<a name="ln3726">        continue;</a>
<a name="ln3727"> </a>
<a name="ln3728">      if(g-&gt;isdeselecting)</a>
<a name="ln3729">        g-&gt;lines[n].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln3730">      else if(g-&gt;isselecting)</a>
<a name="ln3731">        g-&gt;lines[n].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln3732"> </a>
<a name="ln3733">      handled = 1;</a>
<a name="ln3734">    }</a>
<a name="ln3735">  }</a>
<a name="ln3736"> </a>
<a name="ln3737">  if(handled)</a>
<a name="ln3738">  {</a>
<a name="ln3739">    update_lines_count(g-&gt;lines, g-&gt;lines_count, &amp;g-&gt;vertical_count, &amp;g-&gt;horizontal_count);</a>
<a name="ln3740">    g-&gt;lines_version++;</a>
<a name="ln3741">    g-&gt;selecting_lines_version++;</a>
<a name="ln3742">  }</a>
<a name="ln3743"> </a>
<a name="ln3744">  dt_control_queue_redraw_center();</a>
<a name="ln3745"> </a>
<a name="ln3746">  // if not in sweeping mode we need to pass the event</a>
<a name="ln3747">  return (g-&gt;isdeselecting || g-&gt;isselecting);</a>
<a name="ln3748">}</a>
<a name="ln3749"> </a>
<a name="ln3750">int button_pressed(struct dt_iop_module_t *self, double x, double y, double pressure, int which, int type,</a>
<a name="ln3751">                   uint32_t state)</a>
<a name="ln3752">{</a>
<a name="ln3753">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3754">  int handled = 0;</a>
<a name="ln3755"> </a>
<a name="ln3756">  float pzx, pzy;</a>
<a name="ln3757">  dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln3758">  pzx += 0.5f;</a>
<a name="ln3759">  pzy += 0.5f;</a>
<a name="ln3760"> </a>
<a name="ln3761">  const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3762">  const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3763">  if(wd &lt; 1.0 || ht &lt; 1.0) return 1;</a>
<a name="ln3764"> </a>
<a name="ln3765"> </a>
<a name="ln3766">  // if visibility of lines is switched off or no lines available -&gt; potentially adjust crop area</a>
<a name="ln3767">  if(g-&gt;lines_suppressed || g-&gt;lines == NULL)</a>
<a name="ln3768">  {</a>
<a name="ln3769">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln3770">    if (p-&gt;cropmode == ASHIFT_CROP_ASPECT)</a>
<a name="ln3771">    {</a>
<a name="ln3772">      dt_control_change_cursor(GDK_HAND1);</a>
<a name="ln3773">      g-&gt;adjust_crop = TRUE;</a>
<a name="ln3774">      g-&gt;lastx = pzx;</a>
<a name="ln3775">      g-&gt;lasty = pzy;</a>
<a name="ln3776">      g-&gt;crop_cx = 0.5f * (p-&gt;cl + p-&gt;cr);</a>
<a name="ln3777">      g-&gt;crop_cy = 0.5f * (p-&gt;ct + p-&gt;cb);</a>
<a name="ln3778">      return TRUE;</a>
<a name="ln3779">    }</a>
<a name="ln3780">    else</a>
<a name="ln3781">      return FALSE;</a>
<a name="ln3782">  }</a>
<a name="ln3783"> </a>
<a name="ln3784">  // remember lines version at this stage so we can continuously monitor if the</a>
<a name="ln3785">  // lines have changed in-between</a>
<a name="ln3786">  g-&gt;selecting_lines_version = g-&gt;lines_version;</a>
<a name="ln3787"> </a>
<a name="ln3788">  // if shift button is pressed go into bounding mode (selecting or deselecting</a>
<a name="ln3789">  // in a rectangle area)</a>
<a name="ln3790">  if((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln3791">  {</a>
<a name="ln3792">    g-&gt;lastx = pzx;</a>
<a name="ln3793">    g-&gt;lasty = pzy;</a>
<a name="ln3794"> </a>
<a name="ln3795">    g-&gt;isbounding = (which == 3) ? ASHIFT_BOUNDING_DESELECT : ASHIFT_BOUNDING_SELECT;</a>
<a name="ln3796">    dt_control_change_cursor(GDK_CROSS);</a>
<a name="ln3797"> </a>
<a name="ln3798">    return TRUE;</a>
<a name="ln3799">  }</a>
<a name="ln3800"> </a>
<a name="ln3801">  dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln3802">  const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln3803">  const float min_scale = dt_dev_get_zoom_scale(self-&gt;dev, DT_ZOOM_FIT, 1&lt;&lt;closeup, 0);</a>
<a name="ln3804">  const float cur_scale = dt_dev_get_zoom_scale(self-&gt;dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln3805"> </a>
<a name="ln3806">  // if we are zoomed out (no panning possible) and we have lines to display we take control</a>
<a name="ln3807">  const int take_control = (cur_scale == min_scale) &amp;&amp; (g-&gt;points_lines_count &gt; 0);</a>
<a name="ln3808"> </a>
<a name="ln3809">  g-&gt;near_delta = dt_conf_get_float(&quot;plugins/darkroom/ashift/near_delta&quot;);</a>
<a name="ln3810"> </a>
<a name="ln3811">  // gather information about &quot;near&quot;-ness in g-&gt;points_idx</a>
<a name="ln3812">  get_near(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;near_delta);</a>
<a name="ln3813"> </a>
<a name="ln3814">  // iterate over all lines close to the pointer and change &quot;selected&quot; state.</a>
<a name="ln3815">  // left-click selects and right-click deselects the line</a>
<a name="ln3816">  for(int n = 0; g-&gt;selecting_lines_version == g-&gt;lines_version &amp;&amp; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3817">  {</a>
<a name="ln3818">    if(g-&gt;points_idx[n].near == 0)</a>
<a name="ln3819">      continue;</a>
<a name="ln3820"> </a>
<a name="ln3821">    if(which == 3)</a>
<a name="ln3822">      g-&gt;lines[n].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln3823">    else</a>
<a name="ln3824">      g-&gt;lines[n].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln3825"> </a>
<a name="ln3826">    handled = 1;</a>
<a name="ln3827">  }</a>
<a name="ln3828"> </a>
<a name="ln3829">  // we switch into sweeping mode either if we anyhow take control</a>
<a name="ln3830">  // or if cursor was close to a line when button was pressed. in other</a>
<a name="ln3831">  // cases we hand over the event (for image panning)</a>
<a name="ln3832">  if((take_control || handled) &amp;&amp; which == 3)</a>
<a name="ln3833">  {</a>
<a name="ln3834">    dt_control_change_cursor(GDK_PIRATE);</a>
<a name="ln3835">    g-&gt;isdeselecting = 1;</a>
<a name="ln3836">  }</a>
<a name="ln3837">  else if(take_control || handled)</a>
<a name="ln3838">  {</a>
<a name="ln3839">    dt_control_change_cursor(GDK_PLUS);</a>
<a name="ln3840">    g-&gt;isselecting = 1;</a>
<a name="ln3841">  }</a>
<a name="ln3842"> </a>
<a name="ln3843">  if(handled)</a>
<a name="ln3844">  {</a>
<a name="ln3845">    update_lines_count(g-&gt;lines, g-&gt;lines_count, &amp;g-&gt;vertical_count, &amp;g-&gt;horizontal_count);</a>
<a name="ln3846">    g-&gt;lines_version++;</a>
<a name="ln3847">    g-&gt;selecting_lines_version++;</a>
<a name="ln3848">  }</a>
<a name="ln3849"> </a>
<a name="ln3850">  return (take_control || handled);</a>
<a name="ln3851">}</a>
<a name="ln3852"> </a>
<a name="ln3853">int button_released(struct dt_iop_module_t *self, double x, double y, int which, uint32_t state)</a>
<a name="ln3854">{</a>
<a name="ln3855">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3856"> </a>
<a name="ln3857">  // stop adjust crop</a>
<a name="ln3858">  g-&gt;adjust_crop = FALSE;</a>
<a name="ln3859">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln3860"> </a>
<a name="ln3861">  // finalize the isbounding mode</a>
<a name="ln3862">  // if user has released the shift button in-between -&gt; do nothing</a>
<a name="ln3863">  if(g-&gt;isbounding != ASHIFT_BOUNDING_OFF &amp;&amp; (state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln3864">  {</a>
<a name="ln3865">    int handled = 0;</a>
<a name="ln3866"> </a>
<a name="ln3867">    // we compute the rectangle selection</a>
<a name="ln3868">    float pzx, pzy;</a>
<a name="ln3869">    dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln3870"> </a>
<a name="ln3871">    pzx += 0.5f;</a>
<a name="ln3872">    pzy += 0.5f;</a>
<a name="ln3873"> </a>
<a name="ln3874">    const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3875">    const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3876"> </a>
<a name="ln3877">    if(wd &gt;= 1.0 &amp;&amp; ht &gt;= 1.0)</a>
<a name="ln3878">    {</a>
<a name="ln3879">      // mark lines inside the rectangle</a>
<a name="ln3880">      get_bounded_inside(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;lastx * wd,</a>
<a name="ln3881">                         g-&gt;lasty * ht, g-&gt;isbounding);</a>
<a name="ln3882"> </a>
<a name="ln3883">      // select or deselect lines within the rectangle according to isbounding state</a>
<a name="ln3884">      for(int n = 0; g-&gt;selecting_lines_version == g-&gt;lines_version &amp;&amp; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3885">      {</a>
<a name="ln3886">        if(g-&gt;points_idx[n].bounded == 0) continue;</a>
<a name="ln3887"> </a>
<a name="ln3888">        if(g-&gt;isbounding == ASHIFT_BOUNDING_DESELECT)</a>
<a name="ln3889">          g-&gt;lines[n].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln3890">        else</a>
<a name="ln3891">          g-&gt;lines[n].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln3892"> </a>
<a name="ln3893">        handled = 1;</a>
<a name="ln3894">      }</a>
<a name="ln3895"> </a>
<a name="ln3896">      if(handled)</a>
<a name="ln3897">      {</a>
<a name="ln3898">        update_lines_count(g-&gt;lines, g-&gt;lines_count, &amp;g-&gt;vertical_count, &amp;g-&gt;horizontal_count);</a>
<a name="ln3899">        g-&gt;lines_version++;</a>
<a name="ln3900">        g-&gt;selecting_lines_version++;</a>
<a name="ln3901">      }</a>
<a name="ln3902"> </a>
<a name="ln3903">    dt_control_queue_redraw_center();</a>
<a name="ln3904">    }</a>
<a name="ln3905">  }</a>
<a name="ln3906"> </a>
<a name="ln3907">  // end of sweeping/isbounding mode</a>
<a name="ln3908">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln3909">  g-&gt;isselecting = g-&gt;isdeselecting = 0;</a>
<a name="ln3910">  g-&gt;isbounding = ASHIFT_BOUNDING_OFF;</a>
<a name="ln3911">  g-&gt;near_delta = 0;</a>
<a name="ln3912">  g-&gt;lastx = g-&gt;lasty = -1.0f;</a>
<a name="ln3913">  g-&gt;crop_cx = g-&gt;crop_cy = -1.0f;</a>
<a name="ln3914"> </a>
<a name="ln3915">  return 0;</a>
<a name="ln3916">}</a>
<a name="ln3917"> </a>
<a name="ln3918">int scrolled(struct dt_iop_module_t *self, double x, double y, int up, uint32_t state)</a>
<a name="ln3919">{</a>
<a name="ln3920">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3921"> </a>
<a name="ln3922">  // do nothing if visibility of lines is switched off or no lines available</a>
<a name="ln3923">  if(g-&gt;lines_suppressed || g-&gt;lines == NULL)</a>
<a name="ln3924">    return FALSE;</a>
<a name="ln3925"> </a>
<a name="ln3926">  if(g-&gt;near_delta &gt; 0 &amp;&amp; (g-&gt;isdeselecting || g-&gt;isselecting))</a>
<a name="ln3927">  {</a>
<a name="ln3928">    int handled = 0;</a>
<a name="ln3929"> </a>
<a name="ln3930">    float pzx, pzy;</a>
<a name="ln3931">    dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln3932">    pzx += 0.5f;</a>
<a name="ln3933">    pzy += 0.5f;</a>
<a name="ln3934"> </a>
<a name="ln3935">    const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3936">    const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3937"> </a>
<a name="ln3938">    float near_delta = dt_conf_get_float(&quot;plugins/darkroom/ashift/near_delta&quot;);</a>
<a name="ln3939">    const float amount = up ? 0.8f : 1.25f;</a>
<a name="ln3940">    near_delta = MAX(4.0f, MIN(near_delta * amount, 100.0f));</a>
<a name="ln3941">    dt_conf_set_float(&quot;plugins/darkroom/ashift/near_delta&quot;, near_delta);</a>
<a name="ln3942">    g-&gt;near_delta = near_delta;</a>
<a name="ln3943"> </a>
<a name="ln3944">    // gather information about &quot;near&quot;-ness in g-&gt;points_idx</a>
<a name="ln3945">    get_near(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;near_delta);</a>
<a name="ln3946"> </a>
<a name="ln3947">    // iterate over all lines close to the pointer and change &quot;selected&quot; state.</a>
<a name="ln3948">    for(int n = 0; g-&gt;selecting_lines_version == g-&gt;lines_version &amp;&amp; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3949">    {</a>
<a name="ln3950">      if(g-&gt;points_idx[n].near == 0)</a>
<a name="ln3951">        continue;</a>
<a name="ln3952"> </a>
<a name="ln3953">      if(g-&gt;isdeselecting)</a>
<a name="ln3954">        g-&gt;lines[n].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln3955">      else if(g-&gt;isselecting)</a>
<a name="ln3956">        g-&gt;lines[n].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln3957"> </a>
<a name="ln3958">      handled = 1;</a>
<a name="ln3959">    }</a>
<a name="ln3960"> </a>
<a name="ln3961">    if(handled)</a>
<a name="ln3962">    {</a>
<a name="ln3963">      update_lines_count(g-&gt;lines, g-&gt;lines_count, &amp;g-&gt;vertical_count, &amp;g-&gt;horizontal_count);</a>
<a name="ln3964">      g-&gt;lines_version++;</a>
<a name="ln3965">      g-&gt;selecting_lines_version++;</a>
<a name="ln3966">    }</a>
<a name="ln3967"> </a>
<a name="ln3968">    dt_control_queue_redraw_center();</a>
<a name="ln3969">    return TRUE;</a>
<a name="ln3970">  }</a>
<a name="ln3971"> </a>
<a name="ln3972">  return FALSE;</a>
<a name="ln3973">}</a>
<a name="ln3974"> </a>
<a name="ln3975">static void rotation_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln3976">{</a>
<a name="ln3977">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln3978">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln3979">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln3980">  p-&gt;rotation = dt_bauhaus_slider_get(slider);</a>
<a name="ln3981">#ifdef ASHIFT_DEBUG</a>
<a name="ln3982">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3983">  model_probe(self, p, g-&gt;lastfit);</a>
<a name="ln3984">#endif</a>
<a name="ln3985">  do_crop(self, p);</a>
<a name="ln3986">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3987">}</a>
<a name="ln3988"> </a>
<a name="ln3989">static void lensshift_v_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln3990">{</a>
<a name="ln3991">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln3992">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln3993">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln3994">  p-&gt;lensshift_v = dt_bauhaus_slider_get(slider);</a>
<a name="ln3995">#ifdef ASHIFT_DEBUG</a>
<a name="ln3996">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3997">  model_probe(self, p, g-&gt;lastfit);</a>
<a name="ln3998">#endif</a>
<a name="ln3999">  do_crop(self, p);</a>
<a name="ln4000">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4001">}</a>
<a name="ln4002"> </a>
<a name="ln4003">static void lensshift_h_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4004">{</a>
<a name="ln4005">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4006">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4007">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4008">  p-&gt;lensshift_h = dt_bauhaus_slider_get(slider);</a>
<a name="ln4009">#ifdef ASHIFT_DEBUG</a>
<a name="ln4010">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4011">  model_probe(self, p, g-&gt;lastfit);</a>
<a name="ln4012">#endif</a>
<a name="ln4013">  do_crop(self, p);</a>
<a name="ln4014">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4015">}</a>
<a name="ln4016"> </a>
<a name="ln4017">static void shear_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4018">{</a>
<a name="ln4019">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4020">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4021">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4022">  p-&gt;shear = dt_bauhaus_slider_get(slider);</a>
<a name="ln4023">#ifdef ASHIFT_DEBUG</a>
<a name="ln4024">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4025">  model_probe(self, p, g-&gt;lastfit);</a>
<a name="ln4026">#endif</a>
<a name="ln4027">  do_crop(self, p);</a>
<a name="ln4028">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4029">}</a>
<a name="ln4030"> </a>
<a name="ln4031">static void guide_lines_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln4032">{</a>
<a name="ln4033">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4034">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4035">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4036">  g-&gt;show_guides = dt_bauhaus_combobox_get(widget);</a>
<a name="ln4037">  dt_iop_request_focus(self);</a>
<a name="ln4038">  dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4039">}</a>
<a name="ln4040"> </a>
<a name="ln4041">static void cropmode_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln4042">{</a>
<a name="ln4043">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4044">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4045">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4046">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4047">  p-&gt;cropmode = dt_bauhaus_combobox_get(widget);</a>
<a name="ln4048">  if(g-&gt;lines != NULL &amp;&amp; !g-&gt;lines_suppressed)</a>
<a name="ln4049">  {</a>
<a name="ln4050">    g-&gt;lines_suppressed = 1;</a>
<a name="ln4051">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;eye), g-&gt;lines_suppressed);</a>
<a name="ln4052">  }</a>
<a name="ln4053">  do_crop(self, p);</a>
<a name="ln4054">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4055">}</a>
<a name="ln4056"> </a>
<a name="ln4057">static void mode_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln4058">{</a>
<a name="ln4059">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4060">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4061">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4062">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4063">  p-&gt;mode = dt_bauhaus_combobox_get(widget);</a>
<a name="ln4064"> </a>
<a name="ln4065">  switch(p-&gt;mode)</a>
<a name="ln4066">  {</a>
<a name="ln4067">    case ASHIFT_MODE_GENERIC:</a>
<a name="ln4068">      gtk_widget_hide(g-&gt;f_length);</a>
<a name="ln4069">      gtk_widget_hide(g-&gt;crop_factor);</a>
<a name="ln4070">      gtk_widget_hide(g-&gt;orthocorr);</a>
<a name="ln4071">      gtk_widget_hide(g-&gt;aspect);</a>
<a name="ln4072">      break;</a>
<a name="ln4073">    case ASHIFT_MODE_SPECIFIC:</a>
<a name="ln4074">    default:</a>
<a name="ln4075">      gtk_widget_show(g-&gt;f_length);</a>
<a name="ln4076">      gtk_widget_show(g-&gt;crop_factor);</a>
<a name="ln4077">      gtk_widget_show(g-&gt;orthocorr);</a>
<a name="ln4078">      gtk_widget_show(g-&gt;aspect);</a>
<a name="ln4079">      break;</a>
<a name="ln4080">  }</a>
<a name="ln4081"> </a>
<a name="ln4082">  do_crop(self, p);</a>
<a name="ln4083">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4084">}</a>
<a name="ln4085"> </a>
<a name="ln4086">static void f_length_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4087">{</a>
<a name="ln4088">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4089">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4090">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4091">  p-&gt;f_length = dt_bauhaus_slider_get(slider);</a>
<a name="ln4092">  do_crop(self, p);</a>
<a name="ln4093">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4094">}</a>
<a name="ln4095"> </a>
<a name="ln4096">static void crop_factor_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4097">{</a>
<a name="ln4098">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4099">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4100">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4101">  p-&gt;crop_factor = dt_bauhaus_slider_get(slider);</a>
<a name="ln4102">  do_crop(self, p);</a>
<a name="ln4103">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4104">}</a>
<a name="ln4105"> </a>
<a name="ln4106">static void orthocorr_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4107">{</a>
<a name="ln4108">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4109">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4110">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4111">  p-&gt;orthocorr = dt_bauhaus_slider_get(slider);</a>
<a name="ln4112">  do_crop(self, p);</a>
<a name="ln4113">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4114">}</a>
<a name="ln4115"> </a>
<a name="ln4116">static void aspect_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4117">{</a>
<a name="ln4118">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4119">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4120">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4121">  p-&gt;aspect = dt_bauhaus_slider_get(slider);</a>
<a name="ln4122">  do_crop(self, p);</a>
<a name="ln4123">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4124">}</a>
<a name="ln4125"> </a>
<a name="ln4126">static int fit_v_button_clicked(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln4127">{</a>
<a name="ln4128">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4129">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4130"> </a>
<a name="ln4131">  if(event-&gt;button == 1)</a>
<a name="ln4132">  {</a>
<a name="ln4133">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4134">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4135"> </a>
<a name="ln4136">    const int control = (event-&gt;state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK;</a>
<a name="ln4137">    const int shift = (event-&gt;state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK;</a>
<a name="ln4138"> </a>
<a name="ln4139">    dt_iop_ashift_fitaxis_t fitaxis = ASHIFT_FIT_NONE;</a>
<a name="ln4140"> </a>
<a name="ln4141">    if(control)</a>
<a name="ln4142">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_ROTATION_VERTICAL_LINES;</a>
<a name="ln4143">    else if(shift)</a>
<a name="ln4144">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_VERTICALLY_NO_ROTATION;</a>
<a name="ln4145">    else</a>
<a name="ln4146">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_VERTICALLY;</a>
<a name="ln4147"> </a>
<a name="ln4148">    dt_iop_request_focus(self);</a>
<a name="ln4149">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4150"> </a>
<a name="ln4151">    if(self-&gt;enabled)</a>
<a name="ln4152">    {</a>
<a name="ln4153">      // module is enable -&gt; we process directly</a>
<a name="ln4154">      if(do_fit(self, p, fitaxis))</a>
<a name="ln4155">      {</a>
<a name="ln4156">        darktable.gui-&gt;reset = 1;</a>
<a name="ln4157">        dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4158">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4159">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4160">        dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4161">        darktable.gui-&gt;reset = 0;</a>
<a name="ln4162">      }</a>
<a name="ln4163">    }</a>
<a name="ln4164">    else</a>
<a name="ln4165">    {</a>
<a name="ln4166">      // module is not enabled -&gt; invoke it and queue the job to be processed once</a>
<a name="ln4167">      // the preview image is ready</a>
<a name="ln4168">      g-&gt;jobcode = ASHIFT_JOBCODE_FIT;</a>
<a name="ln4169">      g-&gt;jobparams = g-&gt;lastfit = fitaxis;</a>
<a name="ln4170">      p-&gt;toggle ^= 1;</a>
<a name="ln4171">    }</a>
<a name="ln4172"> </a>
<a name="ln4173">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4174">    return TRUE;</a>
<a name="ln4175">  }</a>
<a name="ln4176">  return FALSE;</a>
<a name="ln4177">}</a>
<a name="ln4178"> </a>
<a name="ln4179">static int fit_h_button_clicked(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln4180">{</a>
<a name="ln4181">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4182">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4183"> </a>
<a name="ln4184">  if(event-&gt;button == 1)</a>
<a name="ln4185">  {</a>
<a name="ln4186">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4187">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4188"> </a>
<a name="ln4189">    const int control = (event-&gt;state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK;</a>
<a name="ln4190">    const int shift = (event-&gt;state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK;</a>
<a name="ln4191"> </a>
<a name="ln4192">    dt_iop_ashift_fitaxis_t fitaxis = ASHIFT_FIT_NONE;</a>
<a name="ln4193"> </a>
<a name="ln4194">    if(control)</a>
<a name="ln4195">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_ROTATION_HORIZONTAL_LINES;</a>
<a name="ln4196">    else if(shift)</a>
<a name="ln4197">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_HORIZONTALLY_NO_ROTATION;</a>
<a name="ln4198">    else</a>
<a name="ln4199">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_HORIZONTALLY;</a>
<a name="ln4200"> </a>
<a name="ln4201">    dt_iop_request_focus(self);</a>
<a name="ln4202">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4203"> </a>
<a name="ln4204">    if(self-&gt;enabled)</a>
<a name="ln4205">    {</a>
<a name="ln4206">      // module is enable -&gt; we process directly</a>
<a name="ln4207">      if(do_fit(self, p, fitaxis))</a>
<a name="ln4208">      {</a>
<a name="ln4209">        darktable.gui-&gt;reset = 1;</a>
<a name="ln4210">        dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4211">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4212">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4213">        dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4214">        darktable.gui-&gt;reset = 0;</a>
<a name="ln4215">      }</a>
<a name="ln4216">    }</a>
<a name="ln4217">    else</a>
<a name="ln4218">    {</a>
<a name="ln4219">      // module is not enabled -&gt; invoke it and queue the job to be processed once</a>
<a name="ln4220">      // the preview image is ready</a>
<a name="ln4221">      g-&gt;jobcode = ASHIFT_JOBCODE_FIT;</a>
<a name="ln4222">      g-&gt;jobparams = g-&gt;lastfit = fitaxis;</a>
<a name="ln4223">      p-&gt;toggle ^= 1;</a>
<a name="ln4224">    }</a>
<a name="ln4225"> </a>
<a name="ln4226">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4227">    return TRUE;</a>
<a name="ln4228">  }</a>
<a name="ln4229">  return FALSE;</a>
<a name="ln4230">}</a>
<a name="ln4231"> </a>
<a name="ln4232">static int fit_both_button_clicked(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln4233">{</a>
<a name="ln4234">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4235">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4236"> </a>
<a name="ln4237">  if(event-&gt;button == 1)</a>
<a name="ln4238">  {</a>
<a name="ln4239">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4240">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4241"> </a>
<a name="ln4242">    const int control = (event-&gt;state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK;</a>
<a name="ln4243">    const int shift = (event-&gt;state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK;</a>
<a name="ln4244"> </a>
<a name="ln4245">    dt_iop_ashift_fitaxis_t fitaxis = ASHIFT_FIT_NONE;</a>
<a name="ln4246"> </a>
<a name="ln4247">    if(control &amp;&amp; shift)</a>
<a name="ln4248">      fitaxis = ASHIFT_FIT_BOTH;</a>
<a name="ln4249">    else if(control)</a>
<a name="ln4250">      fitaxis = ASHIFT_FIT_ROTATION_BOTH_LINES;</a>
<a name="ln4251">    else if(shift)</a>
<a name="ln4252">      fitaxis = ASHIFT_FIT_BOTH_NO_ROTATION;</a>
<a name="ln4253">    else</a>
<a name="ln4254">      fitaxis = ASHIFT_FIT_BOTH_SHEAR;</a>
<a name="ln4255"> </a>
<a name="ln4256">    dt_iop_request_focus(self);</a>
<a name="ln4257">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4258"> </a>
<a name="ln4259">    if(self-&gt;enabled)</a>
<a name="ln4260">    {</a>
<a name="ln4261">      // module is enable -&gt; we process directly</a>
<a name="ln4262">      if(do_fit(self, p, fitaxis))</a>
<a name="ln4263">      {</a>
<a name="ln4264">        darktable.gui-&gt;reset = 1;</a>
<a name="ln4265">        dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4266">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4267">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4268">        dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4269">        darktable.gui-&gt;reset = 0;</a>
<a name="ln4270">      }</a>
<a name="ln4271">    }</a>
<a name="ln4272">    else</a>
<a name="ln4273">    {</a>
<a name="ln4274">      // module is not enabled -&gt; invoke it and queue the job to be processed once</a>
<a name="ln4275">      // the preview image is ready</a>
<a name="ln4276">      g-&gt;jobcode = ASHIFT_JOBCODE_FIT;</a>
<a name="ln4277">      g-&gt;jobparams = g-&gt;lastfit = fitaxis;</a>
<a name="ln4278">      p-&gt;toggle ^= 1;</a>
<a name="ln4279">    }</a>
<a name="ln4280"> </a>
<a name="ln4281">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4282">    return TRUE;</a>
<a name="ln4283">  }</a>
<a name="ln4284">  return FALSE;</a>
<a name="ln4285">}</a>
<a name="ln4286"> </a>
<a name="ln4287">static int structure_button_clicked(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln4288">{</a>
<a name="ln4289">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4290">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4291"> </a>
<a name="ln4292">  if(event-&gt;button == 1)</a>
<a name="ln4293">  {</a>
<a name="ln4294">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4295">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4296"> </a>
<a name="ln4297">    const int control = (event-&gt;state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK;</a>
<a name="ln4298">    const int shift = (event-&gt;state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK;</a>
<a name="ln4299"> </a>
<a name="ln4300">    dt_iop_ashift_enhance_t enhance;</a>
<a name="ln4301"> </a>
<a name="ln4302">    if(control &amp;&amp; shift)</a>
<a name="ln4303">      enhance = ASHIFT_ENHANCE_EDGES | ASHIFT_ENHANCE_DETAIL;</a>
<a name="ln4304">    else if(shift)</a>
<a name="ln4305">      enhance = ASHIFT_ENHANCE_DETAIL;</a>
<a name="ln4306">    else if(control)</a>
<a name="ln4307">      enhance = ASHIFT_ENHANCE_EDGES;</a>
<a name="ln4308">    else</a>
<a name="ln4309">      enhance = ASHIFT_ENHANCE_NONE;</a>
<a name="ln4310"> </a>
<a name="ln4311">    dt_iop_request_focus(self);</a>
<a name="ln4312">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4313"> </a>
<a name="ln4314">    if(self-&gt;enabled)</a>
<a name="ln4315">    {</a>
<a name="ln4316">      // module is enabled -&gt; process directly</a>
<a name="ln4317">      (void)do_get_structure(self, p, enhance);</a>
<a name="ln4318">    }</a>
<a name="ln4319">    else</a>
<a name="ln4320">    {</a>
<a name="ln4321">      // module is not enabled -&gt; invoke it and queue the job to be processed once</a>
<a name="ln4322">      // the preview image is ready</a>
<a name="ln4323">      g-&gt;jobcode = ASHIFT_JOBCODE_GET_STRUCTURE;</a>
<a name="ln4324">      g-&gt;jobparams = enhance;</a>
<a name="ln4325">      p-&gt;toggle ^= 1;</a>
<a name="ln4326">    }</a>
<a name="ln4327"> </a>
<a name="ln4328">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4329">    return TRUE;</a>
<a name="ln4330">  }</a>
<a name="ln4331">  return FALSE;</a>
<a name="ln4332">}</a>
<a name="ln4333"> </a>
<a name="ln4334">static void clean_button_clicked(GtkButton *button, gpointer user_data)</a>
<a name="ln4335">{</a>
<a name="ln4336">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4337">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4338">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4339">  (void)do_clean_structure(self, p);</a>
<a name="ln4340">  dt_iop_request_focus(self);</a>
<a name="ln4341">  dt_control_queue_redraw_center();</a>
<a name="ln4342">}</a>
<a name="ln4343"> </a>
<a name="ln4344">static void eye_button_toggled(GtkToggleButton *togglebutton, gpointer user_data)</a>
<a name="ln4345">{</a>
<a name="ln4346">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4347">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4348">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4349">  if(g-&gt;lines == NULL)</a>
<a name="ln4350">  {</a>
<a name="ln4351">    g-&gt;lines_suppressed = 0;</a>
<a name="ln4352">    gtk_toggle_button_set_active(togglebutton, 0);</a>
<a name="ln4353">  }</a>
<a name="ln4354">  else</a>
<a name="ln4355">  {</a>
<a name="ln4356">    g-&gt;lines_suppressed = gtk_toggle_button_get_active(togglebutton);</a>
<a name="ln4357">  }</a>
<a name="ln4358">  dt_iop_request_focus(self);</a>
<a name="ln4359">  dt_control_queue_redraw_center();</a>
<a name="ln4360">}</a>
<a name="ln4361"> </a>
<a name="ln4362">// routine that is called after preview image has been processed. we use it</a>
<a name="ln4363">// to perform structure collection or fitting in case those have been triggered while</a>
<a name="ln4364">// the module had not yet been enabled</a>
<a name="ln4365">static void process_after_preview_callback(gpointer instance, gpointer user_data)</a>
<a name="ln4366">{</a>
<a name="ln4367">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4368">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4369">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4370"> </a>
<a name="ln4371">  dt_iop_ashift_jobcode_t jobcode = g-&gt;jobcode;</a>
<a name="ln4372">  int jobparams = g-&gt;jobparams;</a>
<a name="ln4373"> </a>
<a name="ln4374">  // purge</a>
<a name="ln4375">  g-&gt;jobcode = ASHIFT_JOBCODE_NONE;</a>
<a name="ln4376">  g-&gt;jobparams = 0;</a>
<a name="ln4377"> </a>
<a name="ln4378">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4379"> </a>
<a name="ln4380">  switch(jobcode)</a>
<a name="ln4381">  {</a>
<a name="ln4382">    case ASHIFT_JOBCODE_GET_STRUCTURE:</a>
<a name="ln4383">      (void)do_get_structure(self, p, (dt_iop_ashift_enhance_t)jobparams);</a>
<a name="ln4384">      break;</a>
<a name="ln4385"> </a>
<a name="ln4386">    case ASHIFT_JOBCODE_FIT:</a>
<a name="ln4387">      if(do_fit(self, p, (dt_iop_ashift_fitaxis_t)jobparams))</a>
<a name="ln4388">      {</a>
<a name="ln4389">        darktable.gui-&gt;reset = 1;</a>
<a name="ln4390">        dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4391">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4392">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4393">        dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4394">        darktable.gui-&gt;reset = 0;</a>
<a name="ln4395">      }</a>
<a name="ln4396">      dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4397">      break;</a>
<a name="ln4398"> </a>
<a name="ln4399">    case ASHIFT_JOBCODE_NONE:</a>
<a name="ln4400">    default:</a>
<a name="ln4401">      break;</a>
<a name="ln4402">  }</a>
<a name="ln4403"> </a>
<a name="ln4404">  dt_control_queue_redraw_center();</a>
<a name="ln4405">}</a>
<a name="ln4406"> </a>
<a name="ln4407">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln4408">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4409">{</a>
<a name="ln4410">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)p1;</a>
<a name="ln4411">  dt_iop_ashift_data_t *d = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln4412"> </a>
<a name="ln4413">  d-&gt;rotation = p-&gt;rotation;</a>
<a name="ln4414">  d-&gt;lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln4415">  d-&gt;lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln4416">  d-&gt;shear = p-&gt;shear;</a>
<a name="ln4417">  d-&gt;f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln4418">  d-&gt;orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln4419">  d-&gt;aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln4420"> </a>
<a name="ln4421">  if(gui_has_focus(self))</a>
<a name="ln4422">  {</a>
<a name="ln4423">    // if gui has focus we want to see the full uncropped image</a>
<a name="ln4424">    d-&gt;cl = 0.0f;</a>
<a name="ln4425">    d-&gt;cr = 1.0f;</a>
<a name="ln4426">    d-&gt;ct = 0.0f;</a>
<a name="ln4427">    d-&gt;cb = 1.0f;</a>
<a name="ln4428">  }</a>
<a name="ln4429">  else</a>
<a name="ln4430">  {</a>
<a name="ln4431">    d-&gt;cl = p-&gt;cl;</a>
<a name="ln4432">    d-&gt;cr = p-&gt;cr;</a>
<a name="ln4433">    d-&gt;ct = p-&gt;ct;</a>
<a name="ln4434">    d-&gt;cb = p-&gt;cb;</a>
<a name="ln4435">  }</a>
<a name="ln4436">}</a>
<a name="ln4437"> </a>
<a name="ln4438">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4439">{</a>
<a name="ln4440">  dt_iop_ashift_data_t *d = (dt_iop_ashift_data_t *)calloc(1, sizeof(dt_iop_ashift_data_t));</a>
<a name="ln4441">  piece-&gt;data = (void *)d;</a>
<a name="ln4442">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln4443">}</a>
<a name="ln4444"> </a>
<a name="ln4445">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4446">{</a>
<a name="ln4447">  free(piece-&gt;data);</a>
<a name="ln4448">  piece-&gt;data = NULL;</a>
<a name="ln4449">}</a>
<a name="ln4450"> </a>
<a name="ln4451">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln4452">{</a>
<a name="ln4453">  dt_iop_module_t *module = (dt_iop_module_t *)self;</a>
<a name="ln4454">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4455">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)module-&gt;params;</a>
<a name="ln4456">  dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4457">  dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4458">  dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4459">  dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4460">  dt_bauhaus_slider_set_soft(g-&gt;f_length, p-&gt;f_length);</a>
<a name="ln4461">  dt_bauhaus_slider_set_soft(g-&gt;crop_factor, p-&gt;crop_factor);</a>
<a name="ln4462">  dt_bauhaus_slider_set(g-&gt;orthocorr, p-&gt;orthocorr);</a>
<a name="ln4463">  dt_bauhaus_slider_set(g-&gt;aspect, p-&gt;aspect);</a>
<a name="ln4464">  dt_bauhaus_combobox_set(g-&gt;mode, p-&gt;mode);</a>
<a name="ln4465">  dt_bauhaus_combobox_set(g-&gt;guide_lines, g-&gt;show_guides);</a>
<a name="ln4466">  dt_bauhaus_combobox_set(g-&gt;cropmode, p-&gt;cropmode);</a>
<a name="ln4467">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;eye), 0);</a>
<a name="ln4468"> </a>
<a name="ln4469">  switch(p-&gt;mode)</a>
<a name="ln4470">  {</a>
<a name="ln4471">    case ASHIFT_MODE_GENERIC:</a>
<a name="ln4472">      gtk_widget_hide(g-&gt;f_length);</a>
<a name="ln4473">      gtk_widget_hide(g-&gt;crop_factor);</a>
<a name="ln4474">      gtk_widget_hide(g-&gt;orthocorr);</a>
<a name="ln4475">      gtk_widget_hide(g-&gt;aspect);</a>
<a name="ln4476">      break;</a>
<a name="ln4477">    case ASHIFT_MODE_SPECIFIC:</a>
<a name="ln4478">    default:</a>
<a name="ln4479">      gtk_widget_show(g-&gt;f_length);</a>
<a name="ln4480">      gtk_widget_show(g-&gt;crop_factor);</a>
<a name="ln4481">      gtk_widget_show(g-&gt;orthocorr);</a>
<a name="ln4482">      gtk_widget_show(g-&gt;aspect);</a>
<a name="ln4483">      break;</a>
<a name="ln4484">  }</a>
<a name="ln4485">}</a>
<a name="ln4486"> </a>
<a name="ln4487">void init(dt_iop_module_t *module)</a>
<a name="ln4488">{</a>
<a name="ln4489">  module-&gt;params = calloc(1, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4490">  module-&gt;default_params = calloc(1, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4491">  module-&gt;default_enabled = 0;</a>
<a name="ln4492">  module-&gt;priority = 214; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln4493">  module-&gt;params_size = sizeof(dt_iop_ashift_params_t);</a>
<a name="ln4494">  module-&gt;gui_data = NULL;</a>
<a name="ln4495">  dt_iop_ashift_params_t tmp = (dt_iop_ashift_params_t){ 0.0f, 0.0f, 0.0f, 0.0f, DEFAULT_F_LENGTH, 1.0f, 100.0f, 1.0f, ASHIFT_MODE_GENERIC, 0,</a>
<a name="ln4496">                                                         ASHIFT_CROP_OFF, 0.0f, 1.0f, 0.0f, 1.0f };</a>
<a name="ln4497">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4498">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4499">}</a>
<a name="ln4500"> </a>
<a name="ln4501">void reload_defaults(dt_iop_module_t *module)</a>
<a name="ln4502">{</a>
<a name="ln4503">  // our module is disabled by default</a>
<a name="ln4504">  module-&gt;default_enabled = 0;</a>
<a name="ln4505"> </a>
<a name="ln4506">  int isflipped = 0;</a>
<a name="ln4507">  float f_length = DEFAULT_F_LENGTH;</a>
<a name="ln4508">  float crop_factor = 1.0f;</a>
<a name="ln4509"> </a>
<a name="ln4510">  // try to get information on orientation, focal length and crop factor from image data</a>
<a name="ln4511">  if(module-&gt;dev)</a>
<a name="ln4512">  {</a>
<a name="ln4513">    const dt_image_t *img = &amp;module-&gt;dev-&gt;image_storage;</a>
<a name="ln4514">    // orientation only needed as a-priori information to correctly label some sliders</a>
<a name="ln4515">    // before pixelpipe has been set up. later we will get a definite result by</a>
<a name="ln4516">    // assessing the pixelpipe</a>
<a name="ln4517">    isflipped = (img-&gt;orientation == ORIENTATION_ROTATE_CCW_90_DEG</a>
<a name="ln4518">                 || img-&gt;orientation == ORIENTATION_ROTATE_CW_90_DEG)</a>
<a name="ln4519">                    ? 1</a>
<a name="ln4520">                    : 0;</a>
<a name="ln4521"> </a>
<a name="ln4522">    // focal length should be available in exif data if lens is electronically coupled to the camera</a>
<a name="ln4523">    f_length = isfinite(img-&gt;exif_focal_length) &amp;&amp; img-&gt;exif_focal_length &gt; 0.0f ? img-&gt;exif_focal_length : f_length;</a>
<a name="ln4524">    // crop factor of the camera is often not available and user will need to set it manually in the gui</a>
<a name="ln4525">    crop_factor = isfinite(img-&gt;exif_crop) &amp;&amp; img-&gt;exif_crop &gt; 0.0f ? img-&gt;exif_crop : crop_factor;</a>
<a name="ln4526">  }</a>
<a name="ln4527"> </a>
<a name="ln4528">  // init defaults:</a>
<a name="ln4529">  dt_iop_ashift_params_t tmp = (dt_iop_ashift_params_t){ 0.0f, 0.0f, 0.0f, 0.0f, f_length, crop_factor, 100.0f, 1.0f, ASHIFT_MODE_GENERIC, 0,</a>
<a name="ln4530">                                                         ASHIFT_CROP_OFF, 0.0f, 1.0f, 0.0f, 1.0f };</a>
<a name="ln4531">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4532">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4533"> </a>
<a name="ln4534">  // reset gui elements</a>
<a name="ln4535">  if(module-&gt;gui_data)</a>
<a name="ln4536">  {</a>
<a name="ln4537">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln4538"> </a>
<a name="ln4539">    char string_v[256];</a>
<a name="ln4540">    char string_h[256];</a>
<a name="ln4541"> </a>
<a name="ln4542">    snprintf(string_v, sizeof(string_v), _(&quot;lens shift (%s)&quot;), isflipped ? _(&quot;horizontal&quot;) : _(&quot;vertical&quot;));</a>
<a name="ln4543">    snprintf(string_h, sizeof(string_h), _(&quot;lens shift (%s)&quot;), isflipped ? _(&quot;vertical&quot;) : _(&quot;horizontal&quot;));</a>
<a name="ln4544"> </a>
<a name="ln4545">    dt_bauhaus_widget_set_label(g-&gt;lensshift_v, NULL, string_v);</a>
<a name="ln4546">    dt_bauhaus_widget_set_label(g-&gt;lensshift_h, NULL, string_h);</a>
<a name="ln4547"> </a>
<a name="ln4548">    dt_bauhaus_slider_set_default(g-&gt;f_length, tmp.f_length);</a>
<a name="ln4549">    dt_bauhaus_slider_set_default(g-&gt;crop_factor, tmp.crop_factor);</a>
<a name="ln4550"> </a>
<a name="ln4551">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln4552">    free(g-&gt;buf);</a>
<a name="ln4553">    g-&gt;buf = NULL;</a>
<a name="ln4554">    g-&gt;buf_width = 0;</a>
<a name="ln4555">    g-&gt;buf_height = 0;</a>
<a name="ln4556">    g-&gt;buf_x_off = 0;</a>
<a name="ln4557">    g-&gt;buf_y_off = 0;</a>
<a name="ln4558">    g-&gt;buf_scale = 1.0f;</a>
<a name="ln4559">    g-&gt;buf_hash = 0;</a>
<a name="ln4560">    g-&gt;isflipped = -1;</a>
<a name="ln4561">    g-&gt;lastfit = ASHIFT_FIT_NONE;</a>
<a name="ln4562">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln4563"> </a>
<a name="ln4564">    g-&gt;fitting = 0;</a>
<a name="ln4565">    free(g-&gt;lines);</a>
<a name="ln4566">    g-&gt;lines = NULL;</a>
<a name="ln4567">    g-&gt;lines_count =0;</a>
<a name="ln4568">    g-&gt;horizontal_count = 0;</a>
<a name="ln4569">    g-&gt;vertical_count = 0;</a>
<a name="ln4570">    g-&gt;grid_hash = 0;</a>
<a name="ln4571">    g-&gt;lines_hash = 0;</a>
<a name="ln4572">    g-&gt;rotation_range = ROTATION_RANGE_SOFT;</a>
<a name="ln4573">    g-&gt;lensshift_v_range = LENSSHIFT_RANGE_SOFT;</a>
<a name="ln4574">    g-&gt;lensshift_h_range = LENSSHIFT_RANGE_SOFT;</a>
<a name="ln4575">    g-&gt;shear_range = SHEAR_RANGE_SOFT;</a>
<a name="ln4576">    g-&gt;lines_suppressed = 0;</a>
<a name="ln4577">    g-&gt;lines_version = 0;</a>
<a name="ln4578">    g-&gt;show_guides = 0;</a>
<a name="ln4579">    g-&gt;isselecting = 0;</a>
<a name="ln4580">    g-&gt;isdeselecting = 0;</a>
<a name="ln4581">    g-&gt;isbounding = ASHIFT_BOUNDING_OFF;</a>
<a name="ln4582">    g-&gt;near_delta = 0;</a>
<a name="ln4583">    g-&gt;selecting_lines_version = 0;</a>
<a name="ln4584"> </a>
<a name="ln4585">    free(g-&gt;points);</a>
<a name="ln4586">    g-&gt;points = NULL;</a>
<a name="ln4587">    free(g-&gt;points_idx);</a>
<a name="ln4588">    g-&gt;points_idx = NULL;</a>
<a name="ln4589">    g-&gt;points_lines_count = 0;</a>
<a name="ln4590">    g-&gt;points_version = 0;</a>
<a name="ln4591"> </a>
<a name="ln4592">    g-&gt;jobcode = ASHIFT_JOBCODE_NONE;</a>
<a name="ln4593">    g-&gt;jobparams = 0;</a>
<a name="ln4594">    g-&gt;adjust_crop = FALSE;</a>
<a name="ln4595">    g-&gt;lastx = g-&gt;lasty = -1.0f;</a>
<a name="ln4596">    g-&gt;crop_cx = g-&gt;crop_cy = 1.0f;</a>
<a name="ln4597">  }</a>
<a name="ln4598">}</a>
<a name="ln4599"> </a>
<a name="ln4600"> </a>
<a name="ln4601">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln4602">{</a>
<a name="ln4603">  dt_iop_ashift_global_data_t *gd</a>
<a name="ln4604">      = (dt_iop_ashift_global_data_t *)malloc(sizeof(dt_iop_ashift_global_data_t));</a>
<a name="ln4605">  module-&gt;data = gd;</a>
<a name="ln4606"> </a>
<a name="ln4607">  const int program = 2; // basic.cl, from programs.conf</a>
<a name="ln4608">  gd-&gt;kernel_ashift_bilinear = dt_opencl_create_kernel(program, &quot;ashift_bilinear&quot;);</a>
<a name="ln4609">  gd-&gt;kernel_ashift_bicubic = dt_opencl_create_kernel(program, &quot;ashift_bicubic&quot;);</a>
<a name="ln4610">  gd-&gt;kernel_ashift_lanczos2 = dt_opencl_create_kernel(program, &quot;ashift_lanczos2&quot;);</a>
<a name="ln4611">  gd-&gt;kernel_ashift_lanczos3 = dt_opencl_create_kernel(program, &quot;ashift_lanczos3&quot;);</a>
<a name="ln4612">}</a>
<a name="ln4613"> </a>
<a name="ln4614">void cleanup(dt_iop_module_t *module)</a>
<a name="ln4615">{</a>
<a name="ln4616">  free(module-&gt;params);</a>
<a name="ln4617">  module-&gt;params = NULL;</a>
<a name="ln4618">}</a>
<a name="ln4619"> </a>
<a name="ln4620">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln4621">{</a>
<a name="ln4622">  dt_iop_ashift_global_data_t *gd = (dt_iop_ashift_global_data_t *)module-&gt;data;</a>
<a name="ln4623">  dt_opencl_free_kernel(gd-&gt;kernel_ashift_bilinear);</a>
<a name="ln4624">  dt_opencl_free_kernel(gd-&gt;kernel_ashift_bicubic);</a>
<a name="ln4625">  dt_opencl_free_kernel(gd-&gt;kernel_ashift_lanczos2);</a>
<a name="ln4626">  dt_opencl_free_kernel(gd-&gt;kernel_ashift_lanczos3);</a>
<a name="ln4627">  free(module-&gt;data);</a>
<a name="ln4628">  module-&gt;data = NULL;</a>
<a name="ln4629">}</a>
<a name="ln4630"> </a>
<a name="ln4631">// adjust labels of lens shift parameters according to flip status of image</a>
<a name="ln4632">static gboolean draw(GtkWidget *widget, cairo_t *cr, dt_iop_module_t *self)</a>
<a name="ln4633">{</a>
<a name="ln4634">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4635">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4636"> </a>
<a name="ln4637">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln4638">  const int isflipped = g-&gt;isflipped;</a>
<a name="ln4639">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln4640"> </a>
<a name="ln4641">  if(isflipped == -1) return FALSE;</a>
<a name="ln4642"> </a>
<a name="ln4643">  char string_v[256];</a>
<a name="ln4644">  char string_h[256];</a>
<a name="ln4645"> </a>
<a name="ln4646">  snprintf(string_v, sizeof(string_v), _(&quot;lens shift (%s)&quot;), isflipped ? _(&quot;horizontal&quot;) : _(&quot;vertical&quot;));</a>
<a name="ln4647">  snprintf(string_h, sizeof(string_h), _(&quot;lens shift (%s)&quot;), isflipped ? _(&quot;vertical&quot;) : _(&quot;horizontal&quot;));</a>
<a name="ln4648"> </a>
<a name="ln4649">  darktable.gui-&gt;reset = 1;</a>
<a name="ln4650">  dt_bauhaus_widget_set_label(g-&gt;lensshift_v, NULL, string_v);</a>
<a name="ln4651">  dt_bauhaus_widget_set_label(g-&gt;lensshift_h, NULL, string_h);</a>
<a name="ln4652">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;eye), g-&gt;lines_suppressed);</a>
<a name="ln4653">  darktable.gui-&gt;reset = 0;</a>
<a name="ln4654"> </a>
<a name="ln4655">  return FALSE;</a>
<a name="ln4656">}</a>
<a name="ln4657"> </a>
<a name="ln4658">void gui_focus(struct dt_iop_module_t *self, gboolean in)</a>
<a name="ln4659">{</a>
<a name="ln4660">  if(self-&gt;enabled)</a>
<a name="ln4661">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4662">}</a>
<a name="ln4663"> </a>
<a name="ln4664">static float log10_callback(GtkWidget *self, float inval, dt_bauhaus_callback_t dir)</a>
<a name="ln4665">{</a>
<a name="ln4666">  float outval;</a>
<a name="ln4667">  switch(dir)</a>
<a name="ln4668">  {</a>
<a name="ln4669">    case DT_BAUHAUS_SET:</a>
<a name="ln4670">      outval = log10(fmax(inval, 1e-15f));</a>
<a name="ln4671">      break;</a>
<a name="ln4672">    case DT_BAUHAUS_GET:</a>
<a name="ln4673">      outval = exp(M_LN10 * inval);</a>
<a name="ln4674">      break;</a>
<a name="ln4675">    default:</a>
<a name="ln4676">      outval = inval;</a>
<a name="ln4677">  }</a>
<a name="ln4678">  return outval;</a>
<a name="ln4679">}</a>
<a name="ln4680"> </a>
<a name="ln4681">static float log2_callback(GtkWidget *self, float inval, dt_bauhaus_callback_t dir)</a>
<a name="ln4682">{</a>
<a name="ln4683">  float outval;</a>
<a name="ln4684">  switch(dir)</a>
<a name="ln4685">  {</a>
<a name="ln4686">    case DT_BAUHAUS_SET:</a>
<a name="ln4687">      outval = log(fmax(inval, 1e-15f)) / M_LN2;</a>
<a name="ln4688">      break;</a>
<a name="ln4689">    case DT_BAUHAUS_GET:</a>
<a name="ln4690">      outval = exp(M_LN2 * inval);</a>
<a name="ln4691">      break;</a>
<a name="ln4692">    default:</a>
<a name="ln4693">      outval = inval;</a>
<a name="ln4694">  }</a>
<a name="ln4695">  return outval;</a>
<a name="ln4696">}</a>
<a name="ln4697"> </a>
<a name="ln4698">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln4699">{</a>
<a name="ln4700">  self-&gt;gui_data = malloc(sizeof(dt_iop_ashift_gui_data_t));</a>
<a name="ln4701">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4702">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4703"> </a>
<a name="ln4704">  dt_pthread_mutex_init(&amp;g-&gt;lock, NULL);</a>
<a name="ln4705">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln4706">  g-&gt;buf = NULL;</a>
<a name="ln4707">  g-&gt;buf_width = 0;</a>
<a name="ln4708">  g-&gt;buf_height = 0;</a>
<a name="ln4709">  g-&gt;buf_x_off = 0;</a>
<a name="ln4710">  g-&gt;buf_y_off = 0;</a>
<a name="ln4711">  g-&gt;buf_scale = 1.0f;</a>
<a name="ln4712">  g-&gt;buf_hash = 0;</a>
<a name="ln4713">  g-&gt;isflipped = -1;</a>
<a name="ln4714">  g-&gt;lastfit = ASHIFT_FIT_NONE;</a>
<a name="ln4715">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln4716"> </a>
<a name="ln4717">  g-&gt;fitting = 0;</a>
<a name="ln4718">  g-&gt;lines = NULL;</a>
<a name="ln4719">  g-&gt;lines_count = 0;</a>
<a name="ln4720">  g-&gt;vertical_count = 0;</a>
<a name="ln4721">  g-&gt;horizontal_count = 0;</a>
<a name="ln4722">  g-&gt;lines_version = 0;</a>
<a name="ln4723">  g-&gt;lines_suppressed = 0;</a>
<a name="ln4724">  g-&gt;points = NULL;</a>
<a name="ln4725">  g-&gt;points_idx = NULL;</a>
<a name="ln4726">  g-&gt;points_lines_count = 0;</a>
<a name="ln4727">  g-&gt;points_version = 0;</a>
<a name="ln4728">  g-&gt;grid_hash = 0;</a>
<a name="ln4729">  g-&gt;lines_hash = 0;</a>
<a name="ln4730">  g-&gt;rotation_range = ROTATION_RANGE_SOFT;</a>
<a name="ln4731">  g-&gt;lensshift_v_range = LENSSHIFT_RANGE_SOFT;</a>
<a name="ln4732">  g-&gt;lensshift_h_range = LENSSHIFT_RANGE_SOFT;</a>
<a name="ln4733">  g-&gt;shear_range = SHEAR_RANGE_SOFT;</a>
<a name="ln4734">  g-&gt;show_guides = 0;</a>
<a name="ln4735">  g-&gt;isselecting = 0;</a>
<a name="ln4736">  g-&gt;isdeselecting = 0;</a>
<a name="ln4737">  g-&gt;isbounding = ASHIFT_BOUNDING_OFF;</a>
<a name="ln4738">  g-&gt;near_delta = 0;</a>
<a name="ln4739">  g-&gt;selecting_lines_version = 0;</a>
<a name="ln4740"> </a>
<a name="ln4741">  g-&gt;jobcode = ASHIFT_JOBCODE_NONE;</a>
<a name="ln4742">  g-&gt;jobparams = 0;</a>
<a name="ln4743">  g-&gt;adjust_crop = FALSE;</a>
<a name="ln4744">  g-&gt;lastx = g-&gt;lasty = -1.0f;</a>
<a name="ln4745">  g-&gt;crop_cx = g-&gt;crop_cy = 1.0f;</a>
<a name="ln4746"> </a>
<a name="ln4747">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln4748">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln4749"> </a>
<a name="ln4750">  g-&gt;rotation = dt_bauhaus_slider_new_with_range(self, -ROTATION_RANGE, ROTATION_RANGE, 0.01*ROTATION_RANGE, p-&gt;rotation, 2);</a>
<a name="ln4751">  dt_bauhaus_widget_set_label(g-&gt;rotation, NULL, _(&quot;rotation&quot;));</a>
<a name="ln4752">  dt_bauhaus_slider_set_format(g-&gt;rotation, &quot;%.2f°&quot;);</a>
<a name="ln4753">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;rotation, -ROTATION_RANGE_SOFT, ROTATION_RANGE_SOFT);</a>
<a name="ln4754">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;rotation, TRUE, TRUE, 0);</a>
<a name="ln4755"> </a>
<a name="ln4756">  g-&gt;lensshift_v = dt_bauhaus_slider_new_with_range(self, -LENSSHIFT_RANGE, LENSSHIFT_RANGE, 0.01*LENSSHIFT_RANGE, p-&gt;lensshift_v, 3);</a>
<a name="ln4757">  dt_bauhaus_widget_set_label(g-&gt;lensshift_v, NULL, _(&quot;lens shift (vertical)&quot;));</a>
<a name="ln4758">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;lensshift_v, -LENSSHIFT_RANGE_SOFT, LENSSHIFT_RANGE_SOFT);</a>
<a name="ln4759">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;lensshift_v, TRUE, TRUE, 0);</a>
<a name="ln4760"> </a>
<a name="ln4761">  g-&gt;lensshift_h = dt_bauhaus_slider_new_with_range(self, -LENSSHIFT_RANGE, LENSSHIFT_RANGE, 0.01*LENSSHIFT_RANGE, p-&gt;lensshift_h, 3);</a>
<a name="ln4762">  dt_bauhaus_widget_set_label(g-&gt;lensshift_h, NULL, _(&quot;lens shift (horizontal)&quot;));</a>
<a name="ln4763">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;lensshift_h, -LENSSHIFT_RANGE_SOFT, LENSSHIFT_RANGE_SOFT);</a>
<a name="ln4764">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;lensshift_h, TRUE, TRUE, 0);</a>
<a name="ln4765"> </a>
<a name="ln4766">  g-&gt;shear = dt_bauhaus_slider_new_with_range(self, -SHEAR_RANGE, SHEAR_RANGE, 0.01*SHEAR_RANGE, p-&gt;shear, 3);</a>
<a name="ln4767">  dt_bauhaus_widget_set_label(g-&gt;shear, NULL, _(&quot;shear&quot;));</a>
<a name="ln4768">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;shear, -SHEAR_RANGE_SOFT, SHEAR_RANGE_SOFT);</a>
<a name="ln4769">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;shear, TRUE, TRUE, 0);</a>
<a name="ln4770"> </a>
<a name="ln4771">  g-&gt;guide_lines = dt_bauhaus_combobox_new(self);</a>
<a name="ln4772">  dt_bauhaus_widget_set_label(g-&gt;guide_lines, NULL, _(&quot;guides&quot;));</a>
<a name="ln4773">  dt_bauhaus_combobox_add(g-&gt;guide_lines, _(&quot;off&quot;));</a>
<a name="ln4774">  dt_bauhaus_combobox_add(g-&gt;guide_lines, _(&quot;on&quot;));</a>
<a name="ln4775">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;guide_lines, TRUE, TRUE, 0);</a>
<a name="ln4776"> </a>
<a name="ln4777">  g-&gt;cropmode = dt_bauhaus_combobox_new(self);</a>
<a name="ln4778">  dt_bauhaus_widget_set_label(g-&gt;cropmode, NULL, _(&quot;automatic cropping&quot;));</a>
<a name="ln4779">  dt_bauhaus_combobox_add(g-&gt;cropmode, _(&quot;off&quot;));</a>
<a name="ln4780">  dt_bauhaus_combobox_add(g-&gt;cropmode, _(&quot;largest area&quot;));</a>
<a name="ln4781">  dt_bauhaus_combobox_add(g-&gt;cropmode, _(&quot;original format&quot;));</a>
<a name="ln4782">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;cropmode, TRUE, TRUE, 0);</a>
<a name="ln4783"> </a>
<a name="ln4784">  g-&gt;mode = dt_bauhaus_combobox_new(self);</a>
<a name="ln4785">  dt_bauhaus_widget_set_label(g-&gt;mode, NULL, _(&quot;lens model&quot;));</a>
<a name="ln4786">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;generic&quot;));</a>
<a name="ln4787">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;specific&quot;));</a>
<a name="ln4788">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;mode, TRUE, TRUE, 0);</a>
<a name="ln4789"> </a>
<a name="ln4790">  g-&gt;f_length = dt_bauhaus_slider_new_with_range(self, 1.0f, 3.0f, 0.01f, 1.0f, 2);</a>
<a name="ln4791">  dt_bauhaus_widget_set_label(g-&gt;f_length, NULL, _(&quot;focal length&quot;));</a>
<a name="ln4792">  dt_bauhaus_slider_set_callback(g-&gt;f_length, log10_callback);</a>
<a name="ln4793">  dt_bauhaus_slider_set_format(g-&gt;f_length, &quot;%.0fmm&quot;);</a>
<a name="ln4794">  dt_bauhaus_slider_set_default(g-&gt;f_length, DEFAULT_F_LENGTH);</a>
<a name="ln4795">  dt_bauhaus_slider_set(g-&gt;f_length, DEFAULT_F_LENGTH);</a>
<a name="ln4796">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;f_length, 1.0f, 2000.0f);</a>
<a name="ln4797">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;f_length, TRUE, TRUE, 0);</a>
<a name="ln4798"> </a>
<a name="ln4799">  g-&gt;crop_factor = dt_bauhaus_slider_new_with_range(self, 1.0f, 2.0f, 0.01f, p-&gt;crop_factor, 2);</a>
<a name="ln4800">  dt_bauhaus_widget_set_label(g-&gt;crop_factor, NULL, _(&quot;crop factor&quot;));</a>
<a name="ln4801">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;crop_factor, 0.5f, 10.0f);</a>
<a name="ln4802">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;crop_factor, TRUE, TRUE, 0);</a>
<a name="ln4803"> </a>
<a name="ln4804">  g-&gt;orthocorr = dt_bauhaus_slider_new_with_range(self, 0.0f, 100.0f, 1.0f, p-&gt;orthocorr, 2);</a>
<a name="ln4805">  dt_bauhaus_widget_set_label(g-&gt;orthocorr, NULL, _(&quot;lens dependence&quot;));</a>
<a name="ln4806">  dt_bauhaus_slider_set_format(g-&gt;orthocorr, &quot;%.0f%%&quot;);</a>
<a name="ln4807">#if 0</a>
<a name="ln4808">  // this parameter could serve to finetune between generic model (0%) and specific model (100%).</a>
<a name="ln4809">  // however, users can more easily get the same effect with the aspect adjust parameter so we keep</a>
<a name="ln4810">  // this one hidden.</a>
<a name="ln4811">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;orthocorr, TRUE, TRUE, 0);</a>
<a name="ln4812">#endif</a>
<a name="ln4813"> </a>
<a name="ln4814">  g-&gt;aspect = dt_bauhaus_slider_new_with_range(self, -1.0f, 1.0f, 0.01f, 0.0f, 2);</a>
<a name="ln4815">  dt_bauhaus_widget_set_label(g-&gt;aspect, NULL, _(&quot;aspect adjust&quot;));</a>
<a name="ln4816">  dt_bauhaus_slider_set_callback(g-&gt;aspect, log2_callback);</a>
<a name="ln4817">  dt_bauhaus_slider_set_default(g-&gt;aspect, 1.0f);</a>
<a name="ln4818">  dt_bauhaus_slider_set(g-&gt;aspect, 1.0f);</a>
<a name="ln4819">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;aspect, TRUE, TRUE, 0);</a>
<a name="ln4820"> </a>
<a name="ln4821">  GtkWidget *grid = gtk_grid_new();</a>
<a name="ln4822">  gtk_grid_set_row_spacing(GTK_GRID(grid), 2 * DT_BAUHAUS_SPACE);</a>
<a name="ln4823">  gtk_grid_set_column_spacing(GTK_GRID(grid), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln4824"> </a>
<a name="ln4825">  GtkWidget *label1 = gtk_label_new(_(&quot;automatic fit&quot;));</a>
<a name="ln4826">  gtk_widget_set_halign(label1, GTK_ALIGN_START);</a>
<a name="ln4827">  gtk_grid_attach(GTK_GRID(grid), label1, 0, 0, 1, 1);</a>
<a name="ln4828"> </a>
<a name="ln4829">  g-&gt;fit_v = dtgtk_button_new(dtgtk_cairo_paint_perspective, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | 1, NULL);</a>
<a name="ln4830">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;fit_v), TRUE);</a>
<a name="ln4831">  gtk_widget_set_size_request(g-&gt;fit_v, -1, DT_PIXEL_APPLY_DPI(24));</a>
<a name="ln4832">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;fit_v, label1, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4833"> </a>
<a name="ln4834">  g-&gt;fit_h = dtgtk_button_new(dtgtk_cairo_paint_perspective, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | 2, NULL);</a>
<a name="ln4835">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;fit_h), TRUE);</a>
<a name="ln4836">  gtk_widget_set_size_request(g-&gt;fit_h, -1, DT_PIXEL_APPLY_DPI(24));</a>
<a name="ln4837">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;fit_h, g-&gt;fit_v, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4838"> </a>
<a name="ln4839">  g-&gt;fit_both = dtgtk_button_new(dtgtk_cairo_paint_perspective, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | 3, NULL);</a>
<a name="ln4840">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;fit_both), TRUE);</a>
<a name="ln4841">  gtk_widget_set_size_request(g-&gt;fit_both, -1, DT_PIXEL_APPLY_DPI(24));</a>
<a name="ln4842">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;fit_both, g-&gt;fit_h, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4843"> </a>
<a name="ln4844">  GtkWidget *label2 = gtk_label_new(_(&quot;get structure&quot;));</a>
<a name="ln4845">  gtk_widget_set_halign(label2, GTK_ALIGN_START);</a>
<a name="ln4846">  gtk_grid_attach(GTK_GRID(grid), label2, 0, 1, 1, 1);</a>
<a name="ln4847"> </a>
<a name="ln4848">  g-&gt;structure = dtgtk_button_new(dtgtk_cairo_paint_structure, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln4849">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;structure), TRUE);</a>
<a name="ln4850">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;structure, label2, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4851"> </a>
<a name="ln4852">  g-&gt;clean = dtgtk_button_new(dtgtk_cairo_paint_cancel, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln4853">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;clean), TRUE);</a>
<a name="ln4854">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;clean, g-&gt;structure, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4855"> </a>
<a name="ln4856">  g-&gt;eye = dtgtk_togglebutton_new(dtgtk_cairo_paint_eye_toggle, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln4857">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;eye), TRUE);</a>
<a name="ln4858">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;eye, g-&gt;clean, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4859"> </a>
<a name="ln4860">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), grid, TRUE, TRUE, 0);</a>
<a name="ln4861"> </a>
<a name="ln4862">  gtk_widget_show_all(g-&gt;f_length);</a>
<a name="ln4863">  gtk_widget_set_no_show_all(g-&gt;f_length, TRUE);</a>
<a name="ln4864">  gtk_widget_show_all(g-&gt;crop_factor);</a>
<a name="ln4865">  gtk_widget_set_no_show_all(g-&gt;crop_factor, TRUE);</a>
<a name="ln4866">  gtk_widget_show_all(g-&gt;orthocorr);</a>
<a name="ln4867">  gtk_widget_set_no_show_all(g-&gt;orthocorr, TRUE);</a>
<a name="ln4868">  gtk_widget_show_all(g-&gt;aspect);</a>
<a name="ln4869">  gtk_widget_set_no_show_all(g-&gt;aspect, TRUE);</a>
<a name="ln4870"> </a>
<a name="ln4871"> </a>
<a name="ln4872">  switch(p-&gt;mode)</a>
<a name="ln4873">  {</a>
<a name="ln4874">    case ASHIFT_MODE_GENERIC:</a>
<a name="ln4875">      gtk_widget_hide(g-&gt;f_length);</a>
<a name="ln4876">      gtk_widget_hide(g-&gt;crop_factor);</a>
<a name="ln4877">      gtk_widget_hide(g-&gt;orthocorr);</a>
<a name="ln4878">      gtk_widget_hide(g-&gt;aspect);</a>
<a name="ln4879">      break;</a>
<a name="ln4880">    case ASHIFT_MODE_SPECIFIC:</a>
<a name="ln4881">    default:</a>
<a name="ln4882">      gtk_widget_show(g-&gt;f_length);</a>
<a name="ln4883">      gtk_widget_show(g-&gt;crop_factor);</a>
<a name="ln4884">      gtk_widget_show(g-&gt;orthocorr);</a>
<a name="ln4885">      gtk_widget_show(g-&gt;aspect);</a>
<a name="ln4886">      break;</a>
<a name="ln4887">  }</a>
<a name="ln4888"> </a>
<a name="ln4889">  gtk_widget_set_tooltip_text(g-&gt;rotation, _(&quot;rotate image&quot;));</a>
<a name="ln4890">  gtk_widget_set_tooltip_text(g-&gt;lensshift_v, _(&quot;apply lens shift correction in one direction&quot;));</a>
<a name="ln4891">  gtk_widget_set_tooltip_text(g-&gt;lensshift_h, _(&quot;apply lens shift correction in one direction&quot;));</a>
<a name="ln4892">  gtk_widget_set_tooltip_text(g-&gt;shear, _(&quot;shear the image along one diagonal&quot;));</a>
<a name="ln4893">  gtk_widget_set_tooltip_text(g-&gt;guide_lines, _(&quot;display guide lines overlay&quot;));</a>
<a name="ln4894">  gtk_widget_set_tooltip_text(g-&gt;cropmode, _(&quot;automatically crop to avoid black edges&quot;));</a>
<a name="ln4895">  gtk_widget_set_tooltip_text(g-&gt;mode, _(&quot;lens model of the perspective correction: &quot;</a>
<a name="ln4896">                                         &quot;generic or according to the focal length&quot;));</a>
<a name="ln4897">  gtk_widget_set_tooltip_text(g-&gt;f_length, _(&quot;focal length of the lens, &quot;</a>
<a name="ln4898">                                             &quot;default value set from exif data if available&quot;));</a>
<a name="ln4899">  gtk_widget_set_tooltip_text(g-&gt;crop_factor, _(&quot;crop factor of the camera sensor, &quot;</a>
<a name="ln4900">                                                &quot;default value set from exif data if available, &quot;</a>
<a name="ln4901">                                                &quot;manual setting is often required&quot;));</a>
<a name="ln4902">  gtk_widget_set_tooltip_text(g-&gt;orthocorr, _(&quot;the level of lens dependent correction, set to maximum for full lens dependency, &quot;</a>
<a name="ln4903">                                              &quot;set to zero for the generic case&quot;));</a>
<a name="ln4904">  gtk_widget_set_tooltip_text(g-&gt;aspect, _(&quot;adjust aspect ratio of image by horizontal and vertical scaling&quot;));</a>
<a name="ln4905">  gtk_widget_set_tooltip_text(g-&gt;fit_v, _(&quot;automatically correct for vertical perspective distortion\n&quot;</a>
<a name="ln4906">                                          &quot;ctrl-click to only fit rotation\n&quot;</a>
<a name="ln4907">                                          &quot;shift-click to only fit lens shift&quot;));</a>
<a name="ln4908">  gtk_widget_set_tooltip_text(g-&gt;fit_h, _(&quot;automatically correct for horizontal perspective distortion\n&quot;</a>
<a name="ln4909">                                          &quot;ctrl-click to only fit rotation\n&quot;</a>
<a name="ln4910">                                          &quot;shift-click to only fit lens shift&quot;));</a>
<a name="ln4911">  gtk_widget_set_tooltip_text(g-&gt;fit_both, _(&quot;automatically correct for vertical and &quot;</a>
<a name="ln4912">                                             &quot;horizontal perspective distortions; fitting rotation,&quot;</a>
<a name="ln4913">                                             &quot;lens shift in both directions, and shear\n&quot;</a>
<a name="ln4914">                                             &quot;ctrl-click to only fit rotation\n&quot;</a>
<a name="ln4915">                                             &quot;shift-click to only fit lens shift\n&quot;</a>
<a name="ln4916">                                             &quot;ctrl-shift-click to only fit rotation and lens shift&quot;));</a>
<a name="ln4917">  gtk_widget_set_tooltip_text(g-&gt;structure, _(&quot;analyse line structure in image\n&quot;</a>
<a name="ln4918">                                              &quot;ctrl-click for an additional edge enhancement\n&quot;</a>
<a name="ln4919">                                              &quot;shift-click for an additional detail enhancement\n&quot;</a>
<a name="ln4920">                                              &quot;ctrl-shift-click for a combination of both methods&quot;));</a>
<a name="ln4921">  gtk_widget_set_tooltip_text(g-&gt;clean, _(&quot;remove line structure information&quot;));</a>
<a name="ln4922">  gtk_widget_set_tooltip_text(g-&gt;eye, _(&quot;toggle visibility of structure lines&quot;));</a>
<a name="ln4923"> </a>
<a name="ln4924">  g_signal_connect(G_OBJECT(g-&gt;rotation), &quot;value-changed&quot;, G_CALLBACK(rotation_callback), self);</a>
<a name="ln4925">  g_signal_connect(G_OBJECT(g-&gt;lensshift_v), &quot;value-changed&quot;, G_CALLBACK(lensshift_v_callback), self);</a>
<a name="ln4926">  g_signal_connect(G_OBJECT(g-&gt;lensshift_h), &quot;value-changed&quot;, G_CALLBACK(lensshift_h_callback), self);</a>
<a name="ln4927">  g_signal_connect(G_OBJECT(g-&gt;shear), &quot;value-changed&quot;, G_CALLBACK(shear_callback), self);</a>
<a name="ln4928">  g_signal_connect(G_OBJECT(g-&gt;guide_lines), &quot;value-changed&quot;, G_CALLBACK(guide_lines_callback), self);</a>
<a name="ln4929">  g_signal_connect(G_OBJECT(g-&gt;cropmode), &quot;value-changed&quot;, G_CALLBACK(cropmode_callback), self);</a>
<a name="ln4930">  g_signal_connect(G_OBJECT(g-&gt;mode), &quot;value-changed&quot;, G_CALLBACK(mode_callback), self);</a>
<a name="ln4931">  g_signal_connect(G_OBJECT(g-&gt;f_length), &quot;value-changed&quot;, G_CALLBACK(f_length_callback), self);</a>
<a name="ln4932">  g_signal_connect(G_OBJECT(g-&gt;crop_factor), &quot;value-changed&quot;, G_CALLBACK(crop_factor_callback), self);</a>
<a name="ln4933">  g_signal_connect(G_OBJECT(g-&gt;orthocorr), &quot;value-changed&quot;, G_CALLBACK(orthocorr_callback), self);</a>
<a name="ln4934">  g_signal_connect(G_OBJECT(g-&gt;aspect), &quot;value-changed&quot;, G_CALLBACK(aspect_callback), self);</a>
<a name="ln4935">  g_signal_connect(G_OBJECT(g-&gt;fit_v), &quot;button-press-event&quot;, G_CALLBACK(fit_v_button_clicked), (gpointer)self);</a>
<a name="ln4936">  g_signal_connect(G_OBJECT(g-&gt;fit_h), &quot;button-press-event&quot;, G_CALLBACK(fit_h_button_clicked), (gpointer)self);</a>
<a name="ln4937">  g_signal_connect(G_OBJECT(g-&gt;fit_both), &quot;button-press-event&quot;, G_CALLBACK(fit_both_button_clicked), (gpointer)self);</a>
<a name="ln4938">  g_signal_connect(G_OBJECT(g-&gt;structure), &quot;button-press-event&quot;, G_CALLBACK(structure_button_clicked), (gpointer)self);</a>
<a name="ln4939">  g_signal_connect(G_OBJECT(g-&gt;clean), &quot;clicked&quot;, G_CALLBACK(clean_button_clicked), (gpointer)self);</a>
<a name="ln4940">  g_signal_connect(G_OBJECT(g-&gt;eye), &quot;toggled&quot;, G_CALLBACK(eye_button_toggled), (gpointer)self);</a>
<a name="ln4941">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;draw&quot;, G_CALLBACK(draw), self);</a>
<a name="ln4942"> </a>
<a name="ln4943">  /* add signal handler for preview pipe finish to redraw the overlay */</a>
<a name="ln4944">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_PREVIEW_PIPE_FINISHED,</a>
<a name="ln4945">                            G_CALLBACK(process_after_preview_callback), self);</a>
<a name="ln4946"> </a>
<a name="ln4947">}</a>
<a name="ln4948"> </a>
<a name="ln4949">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln4950">{</a>
<a name="ln4951">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(process_after_preview_callback), self);</a>
<a name="ln4952"> </a>
<a name="ln4953">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4954">  dt_pthread_mutex_destroy(&amp;g-&gt;lock);</a>
<a name="ln4955">  free(g-&gt;lines);</a>
<a name="ln4956">  free(g-&gt;buf);</a>
<a name="ln4957">  free(g-&gt;points);</a>
<a name="ln4958">  free(g-&gt;points_idx);</a>
<a name="ln4959">  free(self-&gt;gui_data);</a>
<a name="ln4960">  self-&gt;gui_data = NULL;</a>
<a name="ln4961">}</a>
<a name="ln4962"> </a>
<a name="ln4963">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln4964">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln4965">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1232"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'Gy' is always false.</p></div>
<div class="balloon" rel="1643"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1643, 1642.</p></div>
<div class="balloon" rel="1663"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'perm'. Check lines: 1663, 1662.</p></div>
<div class="balloon" rel="1709"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'inout'. Check lines: 1709, 1667.</p></div>
<div class="balloon" rel="1780"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1780, 1644.</p></div>
<div class="balloon" rel="1838"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lines_set'. Check lines: 1838, 1820.</p></div>
<div class="balloon" rel="1839"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'inout_set'. Check lines: 1839, 1822.</p></div>
<div class="balloon" rel="2760"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'g->fitting' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 2752, 2760.</p></div>
<div class="balloon" rel="3816"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>
<div class="balloon" rel="4497"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 4497, 4489.</p></div>
<div class="balloon" rel="4498"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 4498, 4490.</p></div>
<div class="balloon" rel="4608"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 4608, 4604.</p></div>
<div class="balloon" rel="4704"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 4704, 4700.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
