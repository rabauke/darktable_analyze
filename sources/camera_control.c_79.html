
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">   This file is part of darktable,</a>
<a name="ln3">   copyright (c) 2010-2012 Henrik Andersson.</a>
<a name="ln4">   copyright (c) 2012 Tobias Ellinghaus.</a>
<a name="ln5"> </a>
<a name="ln6">   darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">   it under the terms of the GNU General Public License as published by</a>
<a name="ln8">   the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">   (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">   darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">   but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">   GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">   You should have received a copy of the GNU General Public License</a>
<a name="ln17">   along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#ifdef HAVE_CONFIG_H</a>
<a name="ln20">#include &quot;config.h&quot;</a>
<a name="ln21">#endif</a>
<a name="ln22">#include &quot;common/camera_control.h&quot;</a>
<a name="ln23">#include &quot;common/exif.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &lt;gphoto2/gphoto2-file.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;fcntl.h&gt;</a>
<a name="ln28">#include &lt;stdlib.h&gt;</a>
<a name="ln29">#include &lt;unistd.h&gt;</a>
<a name="ln30">#include &lt;errno.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32">/***/</a>
<a name="ln33">typedef enum _camctl_camera_job_type_t</a>
<a name="ln34">{</a>
<a name="ln35">  /** Start a scan of devices and announce new and removed. */</a>
<a name="ln36">  _JOB_TYPE_DETECT_DEVICES,</a>
<a name="ln37">  /** Remotly executes a capture. */</a>
<a name="ln38">  _JOB_TYPE_EXECUTE_CAPTURE,</a>
<a name="ln39">  /** Fetch a preview for live view. */</a>
<a name="ln40">  _JOB_TYPE_EXECUTE_LIVE_VIEW,</a>
<a name="ln41">  /** Read a copy of remote camera config into cache. */</a>
<a name="ln42">  _JOB_TYPE_READ_CONFIG,</a>
<a name="ln43">  /** Writes changed properties in cache to camera */</a>
<a name="ln44">  _JOB_TYPE_WRITE_CONFIG,</a>
<a name="ln45">  /** Set's a property in config cache. \todo This shouldn't be a job in jobqueue !? */</a>
<a name="ln46">  _JOB_TYPE_SET_PROPERTY_STRING,</a>
<a name="ln47">  _JOB_TYPE_SET_PROPERTY_CHOICE,</a>
<a name="ln48">  /** For some reason stopping live view needs to pass an int, not a string. */</a>
<a name="ln49">  _JOB_TYPE_SET_PROPERTY_INT,</a>
<a name="ln50">  /** gets a property from config cache. \todo This shouldn't be a job in jobqueue !?  */</a>
<a name="ln51">  _JOB_TYPE_GET_PROPERTY</a>
<a name="ln52">} _camctl_camera_job_type_t;</a>
<a name="ln53"> </a>
<a name="ln54">typedef struct _camctl_camera_job_t</a>
<a name="ln55">{</a>
<a name="ln56">  _camctl_camera_job_type_t type;</a>
<a name="ln57">} _camctl_camera_job_t;</a>
<a name="ln58"> </a>
<a name="ln59">typedef struct _camctl_camera_set_property_string_job_t</a>
<a name="ln60">{</a>
<a name="ln61">  _camctl_camera_job_type_t type;</a>
<a name="ln62">  char *name;</a>
<a name="ln63">  char *value;</a>
<a name="ln64">} _camctl_camera_set_property_string_job_t;</a>
<a name="ln65"> </a>
<a name="ln66">typedef struct _camctl_camera_set_property_choice_job_t</a>
<a name="ln67">{</a>
<a name="ln68">  _camctl_camera_job_type_t type;</a>
<a name="ln69">  char *name;</a>
<a name="ln70">  int value;</a>
<a name="ln71">} _camctl_camera_set_property_choice_job_t;</a>
<a name="ln72"> </a>
<a name="ln73">typedef struct _camctl_camera_set_property_int_job_t</a>
<a name="ln74">{</a>
<a name="ln75">  _camctl_camera_job_type_t type;</a>
<a name="ln76">  char *name;</a>
<a name="ln77">  int value;</a>
<a name="ln78">} _camctl_camera_set_property_int_job_t;</a>
<a name="ln79"> </a>
<a name="ln80">/** Initializes camera */</a>
<a name="ln81">static gboolean _camera_initialize(const dt_camctl_t *c, dt_camera_t *cam);</a>
<a name="ln82"> </a>
<a name="ln83">/** Poll camera events, this one is called from the thread handling the camera. */</a>
<a name="ln84">static void _camera_poll_events(const dt_camctl_t *c, const dt_camera_t *cam);</a>
<a name="ln85"> </a>
<a name="ln86">/** Lock camera control and notify listener. \note Locks mutex and signals CAMERA_CONTROL_BUSY. \remarks all</a>
<a name="ln87"> * interface functions available to host application should lock/unlock its operation. */</a>
<a name="ln88">static void _camctl_lock(const dt_camctl_t *c, const dt_camera_t *cam);</a>
<a name="ln89">/** Lock camera control and notify listener. \note Locks mutex and signals CAMERA_CONTROL_AVAILABLE. \see</a>
<a name="ln90"> * _camctl_lock() */</a>
<a name="ln91">static void _camctl_unlock(const dt_camctl_t *c);</a>
<a name="ln92"> </a>
<a name="ln93">/** Updates the cached configuration with a copy of camera configuration */</a>
<a name="ln94">static void _camera_configuration_update(const dt_camctl_t *c, const dt_camera_t *camera);</a>
<a name="ln95">/** Commit the changes in cached configuration to the camera configuration */</a>
<a name="ln96">static void _camera_configuration_commit(const dt_camctl_t *c, const dt_camera_t *camera);</a>
<a name="ln97">/** Compares new_config with old_config and notifies listeners of the changes. */</a>
<a name="ln98">static void _camera_configuration_notify_change(const dt_camctl_t *c, const dt_camera_t *camera,</a>
<a name="ln99">                                                CameraWidget *new_config, CameraWidget *old_config);</a>
<a name="ln100">/** Put a job on the queue */</a>
<a name="ln101">static void _camera_add_job(const dt_camctl_t *c, const dt_camera_t *camera, gpointer job);</a>
<a name="ln102">/** Get a job from the queue */</a>
<a name="ln103">static gpointer _camera_get_job(const dt_camctl_t *c, const dt_camera_t *camera);</a>
<a name="ln104">static void _camera_process_job(const dt_camctl_t *c, const dt_camera_t *camera, gpointer job);</a>
<a name="ln105"> </a>
<a name="ln106">/** Dispatch functions for listener interfaces */</a>
<a name="ln107">static const char *_dispatch_request_image_path(const dt_camctl_t *c, time_t *exif_time, const dt_camera_t *camera);</a>
<a name="ln108">static const char *_dispatch_request_image_filename(const dt_camctl_t *c, const char *filename,</a>
<a name="ln109">                                                    time_t *exif_time, const dt_camera_t *camera);</a>
<a name="ln110">static void _dispatch_camera_image_downloaded(const dt_camctl_t *c, const dt_camera_t *camera, const char *filename);</a>
<a name="ln111">static void _dispatch_camera_connected(const dt_camctl_t *c, const dt_camera_t *camera);</a>
<a name="ln112">static void _dispatch_camera_disconnected(const dt_camctl_t *c, const dt_camera_t *camera);</a>
<a name="ln113">static void _dispatch_control_status(const dt_camctl_t *c, dt_camctl_status_t status);</a>
<a name="ln114">static void _dispatch_camera_error(const dt_camctl_t *c, const dt_camera_t *camera, dt_camera_error_t error);</a>
<a name="ln115">static int _dispatch_camera_storage_image_filename(const dt_camctl_t *c, const dt_camera_t *camera,</a>
<a name="ln116">                                                   const char *filename, CameraFile *preview, CameraFile *exif);</a>
<a name="ln117">static void _dispatch_camera_property_value_changed(const dt_camctl_t *c, const dt_camera_t *camera,</a>
<a name="ln118">                                                    const char *name, const char *value);</a>
<a name="ln119">// static void _dispatch_camera_property_accessibility_changed(const dt_camctl_t *c, const dt_camera_t *camera,</a>
<a name="ln120">//                                                             const char *name, gboolean read_only);</a>
<a name="ln121"> </a>
<a name="ln122">/** Helper function to destroy a dt_camera_t object */</a>
<a name="ln123">static void dt_camctl_camera_destroy(dt_camera_t *cam);</a>
<a name="ln124"> </a>
<a name="ln125">/** Wrapper to asynchronously look for cameras */</a>
<a name="ln126">static int _detect_cameras_callback(dt_job_t *job);</a>
<a name="ln127"> </a>
<a name="ln128"> </a>
<a name="ln129">static int logid = 0;</a>
<a name="ln130"> </a>
<a name="ln131">static void _gphoto_log25(GPLogLevel level, const char *domain, const char *log, void *data)</a>
<a name="ln132">{</a>
<a name="ln133">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] %s %s\n&quot;, domain, log);</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">#ifndef HAVE_GPHOTO_25_OR_NEWER</a>
<a name="ln137">static void _gphoto_log(GPLogLevel level, const char *domain, const char *format, va_list args, void *data)</a>
<a name="ln138">{</a>
<a name="ln139">  char log[4096] = { 0 };</a>
<a name="ln140">  vsnprintf(log, sizeof(log), format, args);</a>
<a name="ln141">  _gphoto_log25(level, domain, log, data);</a>
<a name="ln142">}</a>
<a name="ln143">#endif</a>
<a name="ln144"> </a>
<a name="ln145">static void _enable_debug() __attribute__((unused));</a>
<a name="ln146">static void _disable_debug() __attribute__((unused));</a>
<a name="ln147"> </a>
<a name="ln148">static void _enable_debug()</a>
<a name="ln149">{</a>
<a name="ln150">#ifdef HAVE_GPHOTO_25_OR_NEWER</a>
<a name="ln151">  logid = gp_log_add_func(GP_LOG_DATA, (GPLogFunc)_gphoto_log25, NULL);</a>
<a name="ln152">#else</a>
<a name="ln153">  logid = gp_log_add_func(GP_LOG_DATA, (GPLogFunc)_gphoto_log, NULL);</a>
<a name="ln154">#endif</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">static void _disable_debug()</a>
<a name="ln158">{</a>
<a name="ln159">  gp_log_remove_func(logid);</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">static void _error_func_dispatch25(GPContext *context, const char *text, void *data)</a>
<a name="ln163">{</a>
<a name="ln164">  dt_camctl_t *camctl = (dt_camctl_t *)data;</a>
<a name="ln165"> </a>
<a name="ln166">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] gphoto2 error: %s\n&quot;, text);</a>
<a name="ln167"> </a>
<a name="ln168">  if(strstr(text, &quot;PTP&quot;))</a>
<a name="ln169">  {</a>
<a name="ln170"> </a>
<a name="ln171">    /* remove camera for camctl camera list */</a>
<a name="ln172">    GList *ci = g_list_find(camctl-&gt;cameras, camctl-&gt;active_camera);</a>
<a name="ln173">    if(ci) camctl-&gt;cameras = g_list_remove(camctl-&gt;cameras, ci);</a>
<a name="ln174"> </a>
<a name="ln175">    /* notify client of camera connection broken */</a>
<a name="ln176">    _dispatch_camera_error(camctl, camctl-&gt;active_camera, CAMERA_CONNECTION_BROKEN);</a>
<a name="ln177"> </a>
<a name="ln178">    /* notify client of camera disconnection */</a>
<a name="ln179">    _dispatch_camera_disconnected(camctl, camctl-&gt;active_camera);</a>
<a name="ln180">  }</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">static void _status_func_dispatch25(GPContext *context, const char *text, void *data)</a>
<a name="ln184">{</a>
<a name="ln185">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] gphoto2 status: %s\n&quot;, text);</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">static void _message_func_dispatch25(GPContext *context, const char *text, void *data)</a>
<a name="ln189">{</a>
<a name="ln190">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] gphoto2 message: %s\n&quot;, text);</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">#ifndef HAVE_GPHOTO_25_OR_NEWER</a>
<a name="ln194">static void _status_func_dispatch(GPContext *context, const char *format, va_list args, void *data)</a>
<a name="ln195">{</a>
<a name="ln196">  char buffer[4096];</a>
<a name="ln197">  vsnprintf(buffer, sizeof(buffer), format, args);</a>
<a name="ln198"> </a>
<a name="ln199">  _status_func_dispatch25(context, buffer, data);</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">static void _error_func_dispatch(GPContext *context, const char *format, va_list args, void *data)</a>
<a name="ln203">{</a>
<a name="ln204">  char buffer[4096];</a>
<a name="ln205">  vsnprintf(buffer, sizeof(buffer), format, args);</a>
<a name="ln206"> </a>
<a name="ln207">  _error_func_dispatch25(context, buffer, data);</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">static void _message_func_dispatch(GPContext *context, const char *format, va_list args, void *data)</a>
<a name="ln211">{</a>
<a name="ln212">  char buffer[4096];</a>
<a name="ln213">  vsnprintf(buffer, sizeof(buffer), format, args);</a>
<a name="ln214">  _message_func_dispatch25(context, buffer, data);</a>
<a name="ln215">}</a>
<a name="ln216">#endif</a>
<a name="ln217"> </a>
<a name="ln218">static gboolean _camera_timeout_job(gpointer data)</a>
<a name="ln219">{</a>
<a name="ln220">  dt_camera_t *cam = (dt_camera_t *)data;</a>
<a name="ln221">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] Calling timeout func for camera %p.\n&quot;, cam);</a>
<a name="ln222">  cam-&gt;timeout(cam-&gt;gpcam, cam-&gt;gpcontext);</a>
<a name="ln223">  return TRUE;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">static int _camera_start_timeout_func(Camera *c, unsigned int timeout, CameraTimeoutFunc func, void *data)</a>
<a name="ln227">{</a>
<a name="ln228">  dt_print(DT_DEBUG_CAMCTL,</a>
<a name="ln229">           &quot;[camera_control] start timeout %d seconds for camera %p requested by driver.\n&quot;, timeout, data);</a>
<a name="ln230">  dt_camera_t *cam = (dt_camera_t *)data;</a>
<a name="ln231">  cam-&gt;timeout = func;</a>
<a name="ln232">  return g_timeout_add_seconds(timeout, _camera_timeout_job, cam);</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">static void _camera_stop_timeout_func(Camera *c, int id, void *data)</a>
<a name="ln236">{</a>
<a name="ln237">  dt_camera_t *cam = (dt_camera_t *)data;</a>
<a name="ln238">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] Removing timeout %d for camera %p.\n&quot;, id, cam);</a>
<a name="ln239">  g_source_remove(id);</a>
<a name="ln240">  cam-&gt;timeout = NULL;</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243"> </a>
<a name="ln244">static void _camera_add_job(const dt_camctl_t *c, const dt_camera_t *camera, gpointer job)</a>
<a name="ln245">{</a>
<a name="ln246">  dt_camera_t *cam = (dt_camera_t *)camera;</a>
<a name="ln247">  dt_pthread_mutex_lock(&amp;cam-&gt;jobqueue_lock);</a>
<a name="ln248">  cam-&gt;jobqueue = g_list_append(cam-&gt;jobqueue, job);</a>
<a name="ln249">  dt_pthread_mutex_unlock(&amp;cam-&gt;jobqueue_lock);</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">static gpointer _camera_get_job(const dt_camctl_t *c, const dt_camera_t *camera)</a>
<a name="ln253">{</a>
<a name="ln254">  dt_camera_t *cam = (dt_camera_t *)camera;</a>
<a name="ln255">  dt_pthread_mutex_lock(&amp;cam-&gt;jobqueue_lock);</a>
<a name="ln256">  gpointer job = NULL;</a>
<a name="ln257">  if(g_list_length(cam-&gt;jobqueue) &gt; 0)</a>
<a name="ln258">  {</a>
<a name="ln259">    job = g_list_nth_data(cam-&gt;jobqueue, 0);</a>
<a name="ln260">    cam-&gt;jobqueue = g_list_remove(cam-&gt;jobqueue, job);</a>
<a name="ln261">  }</a>
<a name="ln262">  dt_pthread_mutex_unlock(&amp;cam-&gt;jobqueue_lock);</a>
<a name="ln263">  return job;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266"> </a>
<a name="ln267">static void _camera_process_job(const dt_camctl_t *c, const dt_camera_t *camera, gpointer job)</a>
<a name="ln268">{</a>
<a name="ln269">  dt_camera_t *cam = (dt_camera_t *)camera;</a>
<a name="ln270">  _camctl_camera_job_t *j = (_camctl_camera_job_t *)job;</a>
<a name="ln271">  switch(j-&gt;type)</a>
<a name="ln272">  {</a>
<a name="ln273"> </a>
<a name="ln274">    case _JOB_TYPE_EXECUTE_CAPTURE:</a>
<a name="ln275">    {</a>
<a name="ln276">      dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] executing remote camera capture job\n&quot;);</a>
<a name="ln277">      CameraFilePath fp;</a>
<a name="ln278">      int res = GP_OK;</a>
<a name="ln279">      if((res = gp_camera_capture(camera-&gt;gpcam, GP_CAPTURE_IMAGE, &amp;fp, c-&gt;gpcontext)) == GP_OK)</a>
<a name="ln280">      {</a>
<a name="ln281">        CameraFile *destination;</a>
<a name="ln282">        const char *output_path = _dispatch_request_image_path(c, NULL, camera);</a>
<a name="ln283">        if(!output_path) output_path = &quot;/tmp&quot;;</a>
<a name="ln284"> </a>
<a name="ln285">        const char *fname = _dispatch_request_image_filename(c, fp.name, NULL, cam);</a>
<a name="ln286">        if(!fname) break;</a>
<a name="ln287"> </a>
<a name="ln288">        char *output = g_build_filename(output_path, fname, (char *)NULL);</a>
<a name="ln289"> </a>
<a name="ln290">        int handle = g_open(output, O_CREAT | O_WRONLY, 0666);</a>
<a name="ln291">        if(handle != -1)</a>
<a name="ln292">        {</a>
<a name="ln293">          gp_file_new_from_fd(&amp;destination, handle);</a>
<a name="ln294">          if(gp_camera_file_get(camera-&gt;gpcam, fp.folder, fp.name, GP_FILE_TYPE_NORMAL, destination,</a>
<a name="ln295">                                c-&gt;gpcontext) == GP_OK)</a>
<a name="ln296">          {</a>
<a name="ln297">            // Notify listeners of captured image</a>
<a name="ln298">            _dispatch_camera_image_downloaded(c, camera, output);</a>
<a name="ln299">          }</a>
<a name="ln300">          else</a>
<a name="ln301">            dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to download file %s\n&quot;, output);</a>
<a name="ln302">          close(handle);</a>
<a name="ln303">        }</a>
<a name="ln304">        else</a>
<a name="ln305">          dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to download file %s\n&quot;, output);</a>
<a name="ln306">        g_free(output);</a>
<a name="ln307">      }</a>
<a name="ln308">      else</a>
<a name="ln309">        dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] capture job failed to capture image: %s\n&quot;,</a>
<a name="ln310">                 gp_result_as_string(res));</a>
<a name="ln311">    }</a>
<a name="ln312">    break;</a>
<a name="ln313"> </a>
<a name="ln314">    case _JOB_TYPE_EXECUTE_LIVE_VIEW:</a>
<a name="ln315">    {</a>
<a name="ln316">      CameraFile *fp = NULL;</a>
<a name="ln317">      int res = GP_OK;</a>
<a name="ln318">      const gchar *data = NULL;</a>
<a name="ln319">      unsigned long int data_size = 0;</a>
<a name="ln320"> </a>
<a name="ln321">      gp_file_new(&amp;fp);</a>
<a name="ln322"> </a>
<a name="ln323">      if((res = gp_camera_capture_preview(cam-&gt;gpcam, fp, c-&gt;gpcontext)) != GP_OK)</a>
<a name="ln324">      {</a>
<a name="ln325">        dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] live view failed to capture preview: %s\n&quot;,</a>
<a name="ln326">                 gp_result_as_string(res));</a>
<a name="ln327">      }</a>
<a name="ln328">      else if((res = gp_file_get_data_and_size(fp, &amp;data, &amp;data_size)) != GP_OK)</a>
<a name="ln329">      {</a>
<a name="ln330">        dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] live view failed to get preview data: %s\n&quot;,</a>
<a name="ln331">                 gp_result_as_string(res));</a>
<a name="ln332">      }</a>
<a name="ln333">      else</a>
<a name="ln334">      {</a>
<a name="ln335">        // everything worked</a>
<a name="ln336">        GError *error = NULL;</a>
<a name="ln337">        GdkPixbufLoader *loader = gdk_pixbuf_loader_new_with_mime_type(</a>
<a name="ln338">            &quot;image/jpeg&quot;, &amp;error); // there were cases where GDKPixbufLoader failed to recognize the JPEG</a>
<a name="ln339">        if(error)</a>
<a name="ln340">        {</a>
<a name="ln341">          dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] live view failed to create jpeg image loader: %s\n&quot;,</a>
<a name="ln342">                   error-&gt;message);</a>
<a name="ln343">          g_error_free(error);</a>
<a name="ln344">        }</a>
<a name="ln345">        else</a>
<a name="ln346">        {</a>
<a name="ln347">          if(gdk_pixbuf_loader_write(loader, (guchar *)data, data_size, NULL) == TRUE)</a>
<a name="ln348">          {</a>
<a name="ln349">            dt_pthread_mutex_lock(&amp;cam-&gt;live_view_pixbuf_mutex);</a>
<a name="ln350">            if(cam-&gt;live_view_pixbuf != NULL) g_object_unref(cam-&gt;live_view_pixbuf);</a>
<a name="ln351">            // Calling gdk_pixbuf_loader_close forces the data to be parsed by the</a>
<a name="ln352">            // loader.  We must do this before calling gdk_pixbuf_loader_get_pixbuf.</a>
<a name="ln353">            gdk_pixbuf_loader_close(loader, &amp;error);</a>
<a name="ln354">            if(error)</a>
<a name="ln355">            {</a>
<a name="ln356">              dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] live view failed to close image loader: %s\n&quot;,</a>
<a name="ln357">                       error-&gt;message);</a>
<a name="ln358">              g_error_free(error);</a>
<a name="ln359">            }</a>
<a name="ln360">            cam-&gt;live_view_pixbuf = gdk_pixbuf_loader_get_pixbuf(loader);</a>
<a name="ln361">            dt_pthread_mutex_unlock(&amp;cam-&gt;live_view_pixbuf_mutex);</a>
<a name="ln362">          }</a>
<a name="ln363">        }</a>
<a name="ln364">        gdk_pixbuf_loader_close(loader, NULL);</a>
<a name="ln365">      }</a>
<a name="ln366">      if(fp) gp_file_free(fp);</a>
<a name="ln367">      dt_pthread_mutex_BAD_unlock(&amp;cam-&gt;live_view_synch);</a>
<a name="ln368">      dt_control_queue_redraw_center();</a>
<a name="ln369">    }</a>
<a name="ln370">    break;</a>
<a name="ln371"> </a>
<a name="ln372">    case _JOB_TYPE_SET_PROPERTY_STRING:</a>
<a name="ln373">    {</a>
<a name="ln374">      _camctl_camera_set_property_string_job_t *spj = (_camctl_camera_set_property_string_job_t *)job;</a>
<a name="ln375">      dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] executing set camera config job %s=%s\n&quot;, spj-&gt;name,</a>
<a name="ln376">               spj-&gt;value);</a>
<a name="ln377"> </a>
<a name="ln378">      CameraWidget *config; // Copy of camera configuration</a>
<a name="ln379">      CameraWidget *widget;</a>
<a name="ln380">      gp_camera_get_config(cam-&gt;gpcam, &amp;config, c-&gt;gpcontext);</a>
<a name="ln381">      if(gp_widget_get_child_by_name(config, spj-&gt;name, &amp;widget) == GP_OK)</a>
<a name="ln382">      {</a>
<a name="ln383">        gp_widget_set_value(widget, spj-&gt;value);</a>
<a name="ln384">        gp_camera_set_config(cam-&gt;gpcam, config, c-&gt;gpcontext);</a>
<a name="ln385">      }</a>
<a name="ln386">      /* dt_pthread_mutex_lock( &amp;cam-&gt;config_lock );</a>
<a name="ln387">       CameraWidget *widget;</a>
<a name="ln388">       if(  gp_widget_get_child_by_name ( camera-&gt;configuration, spj-&gt;name, &amp;widget) == GP_OK) {</a>
<a name="ln389">         gp_widget_set_value ( widget , spj-&gt;value);</a>
<a name="ln390">         //gp_widget_set_changed( widget, 1 );</a>
<a name="ln391">         cam-&gt;config_changed=TRUE;</a>
<a name="ln392">       }</a>
<a name="ln393"> </a>
<a name="ln394">       dt_pthread_mutex_unlock( &amp;cam-&gt;config_lock);*/</a>
<a name="ln395">      g_free(spj-&gt;name);</a>
<a name="ln396">      g_free(spj-&gt;value);</a>
<a name="ln397">      gp_widget_free(config);</a>
<a name="ln398">    }</a>
<a name="ln399">    break;</a>
<a name="ln400"> </a>
<a name="ln401">    case _JOB_TYPE_SET_PROPERTY_CHOICE:</a>
<a name="ln402">    {</a>
<a name="ln403">      _camctl_camera_set_property_choice_job_t *spj = (_camctl_camera_set_property_choice_job_t *)job;</a>
<a name="ln404">      dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] executing set camera config job %s=%d&quot;, spj-&gt;name, spj-&gt;value);</a>
<a name="ln405"> </a>
<a name="ln406">      CameraWidget *config; // Copy of camera configuration</a>
<a name="ln407">      CameraWidget *widget;</a>
<a name="ln408">      gp_camera_get_config(cam-&gt;gpcam, &amp;config, c-&gt;gpcontext);</a>
<a name="ln409">      if(gp_widget_get_child_by_name(config, spj-&gt;name, &amp;widget) == GP_OK)</a>
<a name="ln410">      {</a>
<a name="ln411">        if(spj-&gt;value &gt;= 0 &amp;&amp; spj-&gt;value &lt; gp_widget_count_choices(widget))</a>
<a name="ln412">        {</a>
<a name="ln413">          const char *choice;</a>
<a name="ln414">          gp_widget_get_choice(widget, spj-&gt;value, &amp;choice);</a>
<a name="ln415">          dt_print(DT_DEBUG_CAMCTL, &quot; (%s)&quot;, choice);</a>
<a name="ln416"> </a>
<a name="ln417">          gp_widget_set_value(widget, choice);</a>
<a name="ln418">          gp_camera_set_config(cam-&gt;gpcam, config, c-&gt;gpcontext);</a>
<a name="ln419">        }</a>
<a name="ln420">      }</a>
<a name="ln421">      /* dt_pthread_mutex_lock( &amp;cam-&gt;config_lock );</a>
<a name="ln422">       CameraWidget *widget;</a>
<a name="ln423">       if(  gp_widget_get_child_by_name ( camera-&gt;configuration, spj-&gt;name, &amp;widget) == GP_OK) {</a>
<a name="ln424">         gp_widget_set_value ( widget , spj-&gt;value);</a>
<a name="ln425">         //gp_widget_set_changed( widget, 1 );</a>
<a name="ln426">         cam-&gt;config_changed=TRUE;</a>
<a name="ln427">       }</a>
<a name="ln428"> </a>
<a name="ln429">       dt_pthread_mutex_unlock( &amp;cam-&gt;config_lock);*/</a>
<a name="ln430">      dt_print(DT_DEBUG_CAMCTL, &quot;\n&quot;);</a>
<a name="ln431">      g_free(spj-&gt;name);</a>
<a name="ln432">      gp_widget_free(config);</a>
<a name="ln433">    }</a>
<a name="ln434">    break;</a>
<a name="ln435"> </a>
<a name="ln436">    case _JOB_TYPE_SET_PROPERTY_INT:</a>
<a name="ln437">    {</a>
<a name="ln438">      _camctl_camera_set_property_int_job_t *spj = (_camctl_camera_set_property_int_job_t *)job;</a>
<a name="ln439">      dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] executing set camera config job %s=%d\n&quot;, spj-&gt;name,</a>
<a name="ln440">               spj-&gt;value);</a>
<a name="ln441"> </a>
<a name="ln442">      CameraWidget *config; // Copy of camera configuration</a>
<a name="ln443">      CameraWidget *widget;</a>
<a name="ln444">      gp_camera_get_config(cam-&gt;gpcam, &amp;config, c-&gt;gpcontext);</a>
<a name="ln445">      if(gp_widget_get_child_by_name(config, spj-&gt;name, &amp;widget) == GP_OK)</a>
<a name="ln446">      {</a>
<a name="ln447">        int value = spj-&gt;value;</a>
<a name="ln448">        gp_widget_set_value(widget, &amp;value);</a>
<a name="ln449">        gp_camera_set_config(cam-&gt;gpcam, config, c-&gt;gpcontext);</a>
<a name="ln450">      }</a>
<a name="ln451">      /* dt_pthread_mutex_lock( &amp;cam-&gt;config_lock );</a>
<a name="ln452">       CameraWidget *widget;</a>
<a name="ln453">       if(  gp_widget_get_child_by_name ( camera-&gt;configuration, spj-&gt;name, &amp;widget) == GP_OK) {</a>
<a name="ln454">         gp_widget_set_value ( widget , spj-&gt;value);</a>
<a name="ln455">         //gp_widget_set_changed( widget, 1 );</a>
<a name="ln456">         cam-&gt;config_changed=TRUE;</a>
<a name="ln457">       }</a>
<a name="ln458"> </a>
<a name="ln459">       dt_pthread_mutex_unlock( &amp;cam-&gt;config_lock);*/</a>
<a name="ln460">      g_free(spj-&gt;name);</a>
<a name="ln461">      gp_widget_free(config);</a>
<a name="ln462">    }</a>
<a name="ln463">    break;</a>
<a name="ln464"> </a>
<a name="ln465">    default:</a>
<a name="ln466">      dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] process of unknown job type 0x%x\n&quot;, j-&gt;type);</a>
<a name="ln467">      break;</a>
<a name="ln468">  }</a>
<a name="ln469"> </a>
<a name="ln470">  g_free(j);</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473">/*************/</a>
<a name="ln474">/* LIVE VIEW */</a>
<a name="ln475">/*************/</a>
<a name="ln476">static void *dt_camctl_camera_get_live_view(void *data)</a>
<a name="ln477">{</a>
<a name="ln478">  dt_camctl_t *camctl = (dt_camctl_t *)data;</a>
<a name="ln479">  dt_camera_t *cam = (dt_camera_t *)camctl-&gt;active_camera;</a>
<a name="ln480"> </a>
<a name="ln481">  dt_pthread_setname(&quot;live view&quot;);</a>
<a name="ln482"> </a>
<a name="ln483">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] live view thread started\n&quot;);</a>
<a name="ln484"> </a>
<a name="ln485">  int frames = 0;</a>
<a name="ln486">  double capture_time = dt_get_wtime();</a>
<a name="ln487"> </a>
<a name="ln488">  while(cam-&gt;is_live_viewing == TRUE)</a>
<a name="ln489">  {</a>
<a name="ln490">    dt_pthread_mutex_BAD_lock(&amp;cam-&gt;live_view_synch);</a>
<a name="ln491"> </a>
<a name="ln492">    // calculate FPS</a>
<a name="ln493">    double current_time = dt_get_wtime();</a>
<a name="ln494">    if(current_time - capture_time &gt;= 1.0)</a>
<a name="ln495">    {</a>
<a name="ln496">      // a second has passed</a>
<a name="ln497">      dt_print(DT_DEBUG_CAMCTL, &quot;%d fps\n&quot;, frames + 1);</a>
<a name="ln498">      frames = 0;</a>
<a name="ln499">      capture_time = current_time;</a>
<a name="ln500">    }</a>
<a name="ln501">    else</a>
<a name="ln502">    {</a>
<a name="ln503">      // just increase the frame counter</a>
<a name="ln504">      frames++;</a>
<a name="ln505">    }</a>
<a name="ln506"> </a>
<a name="ln507">    _camctl_camera_job_t *job = g_malloc(sizeof(_camctl_camera_job_t));</a>
<a name="ln508">    job-&gt;type = _JOB_TYPE_EXECUTE_LIVE_VIEW;</a>
<a name="ln509">    _camera_add_job(camctl, cam, job);</a>
<a name="ln510"> </a>
<a name="ln511">    g_usleep((1.0 / 15) * G_USEC_PER_SEC); // never update faster than 15 FPS. going too fast will result in</a>
<a name="ln512">                                           // too many redraws without a real benefit</a>
<a name="ln513">  }</a>
<a name="ln514">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] live view thread stopped\n&quot;);</a>
<a name="ln515">  return NULL;</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">gboolean dt_camctl_camera_start_live_view(const dt_camctl_t *c)</a>
<a name="ln519">{</a>
<a name="ln520">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln521">  dt_camera_t *cam = (dt_camera_t *)camctl-&gt;active_camera;</a>
<a name="ln522">  if(cam == NULL)</a>
<a name="ln523">  {</a>
<a name="ln524">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] Failed to start live view, camera==NULL\n&quot;);</a>
<a name="ln525">    return FALSE;</a>
<a name="ln526">  }</a>
<a name="ln527">  else</a>
<a name="ln528">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] Starting live view\n&quot;);</a>
<a name="ln529"> </a>
<a name="ln530">  if(cam-&gt;can_live_view == FALSE)</a>
<a name="ln531">  {</a>
<a name="ln532">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] Camera does not support live view\n&quot;);</a>
<a name="ln533">    return FALSE;</a>
<a name="ln534">  }</a>
<a name="ln535">  cam-&gt;is_live_viewing = TRUE;</a>
<a name="ln536">  dt_camctl_camera_set_property_int(camctl, NULL, &quot;eosviewfinder&quot;, 1);</a>
<a name="ln537"> </a>
<a name="ln538">  dt_pthread_create(&amp;cam-&gt;live_view_thread, &amp;dt_camctl_camera_get_live_view, (void *)camctl);</a>
<a name="ln539"> </a>
<a name="ln540">  return TRUE;</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543">void dt_camctl_camera_stop_live_view(const dt_camctl_t *c)</a>
<a name="ln544">{</a>
<a name="ln545">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln546">  dt_camera_t *cam = (dt_camera_t *)camctl-&gt;active_camera;</a>
<a name="ln547">  if(cam-&gt;is_live_viewing == FALSE)</a>
<a name="ln548">  {</a>
<a name="ln549">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] Not in live view mode, nothing to stop\n&quot;);</a>
<a name="ln550">    return;</a>
<a name="ln551">  }</a>
<a name="ln552">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] Stopping live view\n&quot;);</a>
<a name="ln553">  cam-&gt;is_live_viewing = FALSE;</a>
<a name="ln554">  pthread_join(cam-&gt;live_view_thread, NULL);</a>
<a name="ln555">  // tell camera to get back to normal state (close mirror)</a>
<a name="ln556">  dt_camctl_camera_set_property_int(camctl, NULL, &quot;eosviewfinder&quot;, 0);</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">static void _camctl_lock(const dt_camctl_t *c, const dt_camera_t *cam)</a>
<a name="ln560">{</a>
<a name="ln561">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln562">  dt_pthread_mutex_BAD_lock(&amp;camctl-&gt;lock);</a>
<a name="ln563">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] camera control locked for camera %p\n&quot;, cam);</a>
<a name="ln564">  camctl-&gt;active_camera = cam;</a>
<a name="ln565">  _dispatch_control_status(c, CAMERA_CONTROL_BUSY);</a>
<a name="ln566">}</a>
<a name="ln567"> </a>
<a name="ln568">static void _camctl_unlock(const dt_camctl_t *c)</a>
<a name="ln569">{</a>
<a name="ln570">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln571">  const dt_camera_t *cam = camctl-&gt;active_camera;</a>
<a name="ln572">  camctl-&gt;active_camera = NULL;</a>
<a name="ln573">  dt_pthread_mutex_BAD_unlock(&amp;camctl-&gt;lock);</a>
<a name="ln574">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] camera control un-locked for camera %p\n&quot;, cam);</a>
<a name="ln575">  _dispatch_control_status(c, CAMERA_CONTROL_AVAILABLE);</a>
<a name="ln576">}</a>
<a name="ln577"> </a>
<a name="ln578"> </a>
<a name="ln579">dt_camctl_t *dt_camctl_new()</a>
<a name="ln580">{</a>
<a name="ln581">  dt_camctl_t *camctl = g_malloc0(sizeof(dt_camctl_t));</a>
<a name="ln582">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] creating new context %p\n&quot;, camctl);</a>
<a name="ln583"> </a>
<a name="ln584">  // Initialize gphoto2 context and setup dispatch callbacks</a>
<a name="ln585">  camctl-&gt;gpcontext = gp_context_new();</a>
<a name="ln586"> </a>
<a name="ln587">#ifdef HAVE_GPHOTO_25_OR_NEWER</a>
<a name="ln588">  gp_context_set_status_func(camctl-&gt;gpcontext, (GPContextStatusFunc)_status_func_dispatch25, camctl);</a>
<a name="ln589">  gp_context_set_error_func(camctl-&gt;gpcontext, (GPContextErrorFunc)_error_func_dispatch25, camctl);</a>
<a name="ln590">  gp_context_set_message_func(camctl-&gt;gpcontext, (GPContextMessageFunc)_message_func_dispatch25, camctl);</a>
<a name="ln591">#else</a>
<a name="ln592">  gp_context_set_status_func(camctl-&gt;gpcontext, (GPContextStatusFunc)_status_func_dispatch, camctl);</a>
<a name="ln593">  gp_context_set_error_func(camctl-&gt;gpcontext, (GPContextErrorFunc)_error_func_dispatch, camctl);</a>
<a name="ln594">  gp_context_set_message_func(camctl-&gt;gpcontext, (GPContextMessageFunc)_message_func_dispatch, camctl);</a>
<a name="ln595">#endif</a>
<a name="ln596"> </a>
<a name="ln597">  // Load all camera drivers we know...</a>
<a name="ln598">  gp_abilities_list_new(&amp;camctl-&gt;gpcams);</a>
<a name="ln599">  gp_abilities_list_load(camctl-&gt;gpcams, camctl-&gt;gpcontext);</a>
<a name="ln600">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] loaded %d camera drivers.\n&quot;,</a>
<a name="ln601">           gp_abilities_list_count(camctl-&gt;gpcams));</a>
<a name="ln602"> </a>
<a name="ln603">  dt_pthread_mutex_init(&amp;camctl-&gt;lock, NULL);</a>
<a name="ln604">  dt_pthread_mutex_init(&amp;camctl-&gt;listeners_lock, NULL);</a>
<a name="ln605"> </a>
<a name="ln606">  // asynchronously call dt_camctl_detect_cameras(camctl); to fill in camctl</a>
<a name="ln607">  dt_job_t *job = dt_control_job_create(&amp;_detect_cameras_callback, &quot;detect connected cameras&quot;);</a>
<a name="ln608">  if(job)</a>
<a name="ln609">  {</a>
<a name="ln610">    dt_control_job_set_params(job, camctl, NULL);</a>
<a name="ln611">    dt_control_add_job(darktable.control, DT_JOB_QUEUE_SYSTEM_BG, job);</a>
<a name="ln612">  }</a>
<a name="ln613"> </a>
<a name="ln614">  return camctl;</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">static void dt_camctl_camera_destroy(dt_camera_t *cam)</a>
<a name="ln618">{</a>
<a name="ln619">  if(!cam) return;</a>
<a name="ln620">  gp_camera_exit(cam-&gt;gpcam, cam-&gt;gpcontext);</a>
<a name="ln621">  gp_camera_unref(cam-&gt;gpcam);</a>
<a name="ln622">  gp_widget_unref(cam-&gt;configuration);</a>
<a name="ln623">  if(cam-&gt;live_view_pixbuf != NULL)</a>
<a name="ln624">  {</a>
<a name="ln625">    g_object_unref(cam-&gt;live_view_pixbuf);</a>
<a name="ln626">    cam-&gt;live_view_pixbuf = NULL; // just in case someone else is using this</a>
<a name="ln627">  }</a>
<a name="ln628">  g_free(cam-&gt;model);</a>
<a name="ln629">  g_free(cam-&gt;port);</a>
<a name="ln630">  dt_pthread_mutex_destroy(&amp;cam-&gt;config_lock);</a>
<a name="ln631">  dt_pthread_mutex_destroy(&amp;cam-&gt;live_view_pixbuf_mutex);</a>
<a name="ln632">  dt_pthread_mutex_destroy(&amp;cam-&gt;live_view_synch);</a>
<a name="ln633">  // TODO: cam-&gt;jobqueue</a>
<a name="ln634">  g_free(cam);</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637">void dt_camctl_destroy(dt_camctl_t *camctl)</a>
<a name="ln638">{</a>
<a name="ln639">  if(!camctl) return;</a>
<a name="ln640">  // Go thru all c-&gt;cameras and release them..</a>
<a name="ln641">  for(GList *it = g_list_first(camctl-&gt;cameras); it != NULL; it = g_list_delete_link(it, it))</a>
<a name="ln642">  {</a>
<a name="ln643">    dt_camctl_camera_destroy((dt_camera_t *)it-&gt;data);</a>
<a name="ln644">  }</a>
<a name="ln645">  gp_context_unref(camctl-&gt;gpcontext);</a>
<a name="ln646">  gp_abilities_list_free(camctl-&gt;gpcams);</a>
<a name="ln647">  gp_port_info_list_free(camctl-&gt;gpports);</a>
<a name="ln648">  dt_pthread_mutex_destroy(&amp;camctl-&gt;lock);</a>
<a name="ln649">  dt_pthread_mutex_destroy(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln650">  g_free(camctl);</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653"> </a>
<a name="ln654">int dt_camctl_have_cameras(const dt_camctl_t *c)</a>
<a name="ln655">{</a>
<a name="ln656">  return (g_list_length(c-&gt;cameras) &gt; 0) ? 1 : 0;</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">void dt_camctl_register_listener(const dt_camctl_t *c, dt_camctl_listener_t *listener)</a>
<a name="ln660">{</a>
<a name="ln661">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln662">  // Just locking mutex and prevent signalling CAMERA_CONTROL_BUSY</a>
<a name="ln663">  dt_pthread_mutex_lock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln664">  if(g_list_find(camctl-&gt;listeners, listener) == NULL)</a>
<a name="ln665">  {</a>
<a name="ln666">    camctl-&gt;listeners = g_list_append(camctl-&gt;listeners, listener);</a>
<a name="ln667">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] registering listener %p\n&quot;, listener);</a>
<a name="ln668">  }</a>
<a name="ln669">  else</a>
<a name="ln670">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] registering already registered listener %p\n&quot;, listener);</a>
<a name="ln671">  dt_pthread_mutex_unlock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">void dt_camctl_unregister_listener(const dt_camctl_t *c, dt_camctl_listener_t *listener)</a>
<a name="ln675">{</a>
<a name="ln676">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln677">  // Just locking mutex and prevent signalling CAMERA_CONTROL_BUSY</a>
<a name="ln678">  dt_pthread_mutex_lock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln679">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] unregistering listener %p\n&quot;, listener);</a>
<a name="ln680">  camctl-&gt;listeners = g_list_remove(camctl-&gt;listeners, listener);</a>
<a name="ln681">  dt_pthread_mutex_unlock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">static gint _compare_camera_by_port(gconstpointer a, gconstpointer b)</a>
<a name="ln685">{</a>
<a name="ln686">  dt_camera_t *ca = (dt_camera_t *)a;</a>
<a name="ln687">  dt_camera_t *cb = (dt_camera_t *)b;</a>
<a name="ln688">  return g_strcmp0(ca-&gt;port, cb-&gt;port);</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">void dt_camctl_detect_cameras(const dt_camctl_t *c)</a>
<a name="ln692">{</a>
<a name="ln693">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln694">  dt_pthread_mutex_lock(&amp;camctl-&gt;lock);</a>
<a name="ln695"> </a>
<a name="ln696">  /* reload portdrivers */</a>
<a name="ln697">  if(camctl-&gt;gpports) gp_port_info_list_free(camctl-&gt;gpports);</a>
<a name="ln698"> </a>
<a name="ln699">  gp_port_info_list_new(&amp;camctl-&gt;gpports);</a>
<a name="ln700">  gp_port_info_list_load(camctl-&gt;gpports);</a>
<a name="ln701">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] loaded %d port drivers.\n&quot;,</a>
<a name="ln702">           gp_port_info_list_count(camctl-&gt;gpports));</a>
<a name="ln703"> </a>
<a name="ln704"> </a>
<a name="ln705"> </a>
<a name="ln706">  CameraList *available_cameras = NULL;</a>
<a name="ln707">  gp_list_new(&amp;available_cameras);</a>
<a name="ln708">  gp_abilities_list_detect(c-&gt;gpcams, c-&gt;gpports, available_cameras, c-&gt;gpcontext);</a>
<a name="ln709">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] %d cameras connected\n&quot;,</a>
<a name="ln710">           gp_list_count(available_cameras) &gt; 0 ? gp_list_count(available_cameras) : 0);</a>
<a name="ln711"> </a>
<a name="ln712"> </a>
<a name="ln713">  for(int i = 0; i &lt; gp_list_count(available_cameras); i++)</a>
<a name="ln714">  {</a>
<a name="ln715">    dt_camera_t *camera = g_malloc0(sizeof(dt_camera_t));</a>
<a name="ln716">    const gchar *s;</a>
<a name="ln717">    gp_list_get_name(available_cameras, i, &amp;s);</a>
<a name="ln718">    camera-&gt;model = g_strdup(s);</a>
<a name="ln719">    gp_list_get_value(available_cameras, i, &amp;s);</a>
<a name="ln720">    camera-&gt;port = g_strdup(s);</a>
<a name="ln721">    dt_pthread_mutex_init(&amp;camera-&gt;config_lock, NULL);</a>
<a name="ln722">    dt_pthread_mutex_init(&amp;camera-&gt;live_view_pixbuf_mutex, NULL);</a>
<a name="ln723">    dt_pthread_mutex_init(&amp;camera-&gt;live_view_synch, NULL);</a>
<a name="ln724"> </a>
<a name="ln725">    // if(g_strcmp0(camera-&gt;port,&quot;usb:&quot;)==0) { g_free(camera); continue; }</a>
<a name="ln726">    GList *citem;</a>
<a name="ln727">    if((citem = g_list_find_custom(c-&gt;cameras, camera, _compare_camera_by_port)) == NULL</a>
<a name="ln728">       || g_strcmp0(((dt_camera_t *)citem-&gt;data)-&gt;model, camera-&gt;model) != 0)</a>
<a name="ln729">    {</a>
<a name="ln730">      if(citem == NULL)</a>
<a name="ln731">      {</a>
<a name="ln732">        // Newly connected camera</a>
<a name="ln733">        if(_camera_initialize(c, camera) == FALSE)</a>
<a name="ln734">        {</a>
<a name="ln735">          dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to initialize device %s on port %s, probably &quot;</a>
<a name="ln736">                                    &quot;causes are: locked by another application, no access to udev etc.\n&quot;,</a>
<a name="ln737">                   camera-&gt;model, camera-&gt;port);</a>
<a name="ln738">          dt_camctl_camera_destroy(camera);</a>
<a name="ln739">          continue;</a>
<a name="ln740">        }</a>
<a name="ln741"> </a>
<a name="ln742">        // Check if camera has capabilities for being presented to darktable</a>
<a name="ln743">        if(camera-&gt;can_import == FALSE &amp;&amp; camera-&gt;can_tether == FALSE)</a>
<a name="ln744">        {</a>
<a name="ln745">          dt_print(</a>
<a name="ln746">              DT_DEBUG_CAMCTL,</a>
<a name="ln747">              &quot;[camera_control] device %s on port %s doesn't support import or tether, skipping device.\n&quot;,</a>
<a name="ln748">              camera-&gt;model, camera-&gt;port);</a>
<a name="ln749">          dt_camctl_camera_destroy(camera);</a>
<a name="ln750">          continue;</a>
<a name="ln751">        }</a>
<a name="ln752"> </a>
<a name="ln753">        // Fetch some summary of camera</a>
<a name="ln754">        if(gp_camera_get_summary(camera-&gt;gpcam, &amp;camera-&gt;summary, c-&gt;gpcontext) == GP_OK)</a>
<a name="ln755">        {</a>
<a name="ln756">          // Remove device property summary:</a>
<a name="ln757">          char *eos = strstr(camera-&gt;summary.text, &quot;Device Property Summary:\n&quot;);</a>
<a name="ln758">          if(eos) eos[0] = '\0';</a>
<a name="ln759">        }</a>
<a name="ln760"> </a>
<a name="ln761">        // Add to camera list</a>
<a name="ln762">        camctl-&gt;cameras = g_list_append(camctl-&gt;cameras, camera);</a>
<a name="ln763"> </a>
<a name="ln764">        // Notify listeners of connected camera</a>
<a name="ln765">        _dispatch_camera_connected(camctl, camera);</a>
<a name="ln766">      }</a>
<a name="ln767">    }</a>
<a name="ln768">    else</a>
<a name="ln769">      dt_camctl_camera_destroy(camera);</a>
<a name="ln770">  }</a>
<a name="ln771"> </a>
<a name="ln772">  /* check c-&gt;cameras in available_cameras */</a>
<a name="ln773">  if(c-&gt;cameras &amp;&amp; g_list_length(c-&gt;cameras) &gt; 0)</a>
<a name="ln774">  {</a>
<a name="ln775">    GList *citem = c-&gt;cameras;</a>
<a name="ln776">    do</a>
<a name="ln777">    {</a>
<a name="ln778">      int index = 0;</a>
<a name="ln779">      dt_camera_t *cam = (dt_camera_t *)citem-&gt;data;</a>
<a name="ln780">      if(gp_list_find_by_name(available_cameras, &amp;index, cam-&gt;model) != GP_OK)</a>
<a name="ln781">      {</a>
<a name="ln782">        /* remove camera from cached list.. */</a>
<a name="ln783">        dt_camera_t *oldcam = (dt_camera_t *)citem-&gt;data;</a>
<a name="ln784">        camctl-&gt;cameras = citem = g_list_delete_link(c-&gt;cameras, citem);</a>
<a name="ln785">        dt_camctl_camera_destroy(oldcam);</a>
<a name="ln786">      }</a>
<a name="ln787">    } while(citem &amp;&amp; (citem = g_list_next(citem)) != NULL);</a>
<a name="ln788">  }</a>
<a name="ln789"> </a>
<a name="ln790">  gp_list_unref(available_cameras);</a>
<a name="ln791"> </a>
<a name="ln792">  dt_pthread_mutex_unlock(&amp;camctl-&gt;lock);</a>
<a name="ln793"> </a>
<a name="ln794">  // tell the world that we are done. this assumes that there is just one global camctl.</a>
<a name="ln795">  // if there would ever be more it would be easy to pass c with the signal.</a>
<a name="ln796">  // TODO: only raise it when the connected cameras changed?</a>
<a name="ln797">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_CAMERA_DETECTED);</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800">static int _detect_cameras_callback(dt_job_t *job)</a>
<a name="ln801">{</a>
<a name="ln802">  dt_camctl_t *c = dt_control_job_get_params(job);</a>
<a name="ln803">  dt_camctl_detect_cameras(c);</a>
<a name="ln804">  return 0;</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807">static void *_camera_event_thread(void *data)</a>
<a name="ln808">{</a>
<a name="ln809">  dt_camctl_t *camctl = (dt_camctl_t *)data;</a>
<a name="ln810"> </a>
<a name="ln811">  dt_pthread_setname(&quot;tethering&quot;);</a>
<a name="ln812"> </a>
<a name="ln813">  const dt_camera_t *camera = camctl-&gt;active_camera;</a>
<a name="ln814"> </a>
<a name="ln815">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] starting camera event thread of context %p\n&quot;, data);</a>
<a name="ln816"> </a>
<a name="ln817">  while(camera-&gt;is_tethering == TRUE)</a>
<a name="ln818">  {</a>
<a name="ln819">    // Poll event from camera</a>
<a name="ln820">    _camera_poll_events(camctl, camera);</a>
<a name="ln821"> </a>
<a name="ln822">    // Let's check if there are jobs in queue to process</a>
<a name="ln823">    gpointer job;</a>
<a name="ln824">    while((job = _camera_get_job(camctl, camera)) != NULL) _camera_process_job(camctl, camera, job);</a>
<a name="ln825"> </a>
<a name="ln826">    // Check it jobs did change the configuration</a>
<a name="ln827">    if(camera-&gt;config_changed == TRUE) _camera_configuration_commit(camctl, camera);</a>
<a name="ln828">  }</a>
<a name="ln829"> </a>
<a name="ln830">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] exiting camera thread.\n&quot;);</a>
<a name="ln831"> </a>
<a name="ln832">  return NULL;</a>
<a name="ln833">}</a>
<a name="ln834"> </a>
<a name="ln835">static gboolean _camera_initialize(const dt_camctl_t *c, dt_camera_t *cam)</a>
<a name="ln836">{</a>
<a name="ln837">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln838">  CameraAbilities a;</a>
<a name="ln839">  GPPortInfo pi;</a>
<a name="ln840">  if(cam-&gt;gpcam == NULL)</a>
<a name="ln841">  {</a>
<a name="ln842">    gp_camera_new(&amp;cam-&gt;gpcam);</a>
<a name="ln843">    int m = gp_abilities_list_lookup_model(c-&gt;gpcams, cam-&gt;model);</a>
<a name="ln844">    gp_abilities_list_get_abilities(c-&gt;gpcams, m, &amp;a);</a>
<a name="ln845">    gp_camera_set_abilities(cam-&gt;gpcam, a);</a>
<a name="ln846"> </a>
<a name="ln847">    int p = gp_port_info_list_lookup_path(c-&gt;gpports, cam-&gt;port);</a>
<a name="ln848">    gp_port_info_list_get_info(c-&gt;gpports, p, &amp;pi);</a>
<a name="ln849">    gp_camera_set_port_info(cam-&gt;gpcam, pi);</a>
<a name="ln850"> </a>
<a name="ln851">    // Check for abilities</a>
<a name="ln852">    if((a.operations &amp; GP_OPERATION_CAPTURE_IMAGE)) cam-&gt;can_tether = TRUE;</a>
<a name="ln853">    if((a.operations &amp; GP_OPERATION_CAPTURE_PREVIEW)) cam-&gt;can_live_view = TRUE;</a>
<a name="ln854">    if(cam-&gt;can_tether &amp;&amp; (a.operations &amp; GP_OPERATION_CONFIG)) cam-&gt;can_config = TRUE;</a>
<a name="ln855">    if(!(a.file_operations &amp; GP_FILE_OPERATION_NONE)) cam-&gt;can_import = TRUE;</a>
<a name="ln856"> </a>
<a name="ln857">    if(gp_camera_init(cam-&gt;gpcam, camctl-&gt;gpcontext) != GP_OK)</a>
<a name="ln858">    {</a>
<a name="ln859">      dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to initialize camera %s on port %s\n&quot;, cam-&gt;model,</a>
<a name="ln860">               cam-&gt;port);</a>
<a name="ln861">      return FALSE;</a>
<a name="ln862">    }</a>
<a name="ln863"> </a>
<a name="ln864">    // read a full copy of config to configuration cache</a>
<a name="ln865">    gp_camera_get_config(cam-&gt;gpcam, &amp;cam-&gt;configuration, c-&gt;gpcontext);</a>
<a name="ln866"> </a>
<a name="ln867">    // TODO: find a more robust way for this, once we find out how to do it with non-EOS cameras</a>
<a name="ln868">    cam-&gt;can_live_view_advanced = cam-&gt;can_live_view &amp;&amp;</a>
<a name="ln869">                                  dt_camctl_camera_property_exists(camctl, cam, &quot;eoszoomposition&quot;);</a>
<a name="ln870"> </a>
<a name="ln871">    // initialize timeout callbacks eg. keep alive, some cameras needs it.</a>
<a name="ln872">    cam-&gt;gpcontext = camctl-&gt;gpcontext;</a>
<a name="ln873">    gp_camera_set_timeout_funcs(cam-&gt;gpcam, (CameraTimeoutStartFunc)_camera_start_timeout_func,</a>
<a name="ln874">                                (CameraTimeoutStopFunc)_camera_stop_timeout_func, cam);</a>
<a name="ln875"> </a>
<a name="ln876"> </a>
<a name="ln877">    dt_pthread_mutex_init(&amp;cam-&gt;jobqueue_lock, NULL);</a>
<a name="ln878"> </a>
<a name="ln879">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] device %s on port %s initialized\n&quot;, cam-&gt;model, cam-&gt;port);</a>
<a name="ln880">  }</a>
<a name="ln881">  else</a>
<a name="ln882">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] device %s on port %s already initialized\n&quot;, cam-&gt;model,</a>
<a name="ln883">             cam-&gt;port);</a>
<a name="ln884"> </a>
<a name="ln885">  return TRUE;</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">void dt_camctl_import(const dt_camctl_t *c, const dt_camera_t *cam, GList *images)</a>
<a name="ln889">{</a>
<a name="ln890">  // dt_camctl_t *camctl=(dt_camctl_t *)c;</a>
<a name="ln891">  _camctl_lock(c, cam);</a>
<a name="ln892"> </a>
<a name="ln893">  GList *ifile = g_list_first(images);</a>
<a name="ln894"> </a>
<a name="ln895">  if(ifile) do</a>
<a name="ln896">    {</a>
<a name="ln897">      // Split file into folder and filename</a>
<a name="ln898">      char *eos;</a>
<a name="ln899">      char folder[PATH_MAX] = { 0 };</a>
<a name="ln900">      char filename[PATH_MAX] = { 0 };</a>
<a name="ln901">      char *file = (char *)ifile-&gt;data;</a>
<a name="ln902">      eos = file + strlen(file);</a>
<a name="ln903">      while(--eos &gt; file &amp;&amp; *eos != '/')</a>
<a name="ln904">        ;</a>
<a name="ln905">      char *_file = g_strndup(file, eos - file);</a>
<a name="ln906">      g_strlcat(folder, _file, sizeof(folder));</a>
<a name="ln907">      g_strlcat(filename, eos + 1, sizeof(filename));</a>
<a name="ln908">      g_free(_file);</a>
<a name="ln909"> </a>
<a name="ln910">      CameraFile* camfile;</a>
<a name="ln911">      int res = GP_OK;</a>
<a name="ln912">      const uint8_t* data = NULL;</a>
<a name="ln913">      unsigned long int size;</a>
<a name="ln914"> </a>
<a name="ln915">      gp_file_new(&amp;camfile);</a>
<a name="ln916">      if ((res = gp_camera_file_get(cam-&gt;gpcam, folder, filename, GP_FILE_TYPE_NORMAL, camfile, NULL)) &lt; GP_OK) {</a>
<a name="ln917">        dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] import failed: %s\n&quot;, gp_result_as_string(res));</a>
<a name="ln918">        gp_file_free(camfile);</a>
<a name="ln919">        continue;</a>
<a name="ln920">      }</a>
<a name="ln921">      if ((res = gp_file_get_data_and_size(camfile, (const char**)&amp;data, &amp;size)) &lt; GP_OK) {</a>
<a name="ln922">        dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] import failed: %s\n&quot;, gp_result_as_string(res));</a>
<a name="ln923">        gp_file_free(camfile);</a>
<a name="ln924">        continue;</a>
<a name="ln925">      }</a>
<a name="ln926"> </a>
<a name="ln927">      time_t exif_time;</a>
<a name="ln928">      gboolean have_exif_time = dt_exif_get_datetime_taken(data, size, &amp;exif_time);</a>
<a name="ln929"> </a>
<a name="ln930">      const char *output_path = _dispatch_request_image_path(c, have_exif_time ? &amp;exif_time : NULL, cam);</a>
<a name="ln931">      const char *fname = _dispatch_request_image_filename(c, filename, have_exif_time ? &amp;exif_time : NULL, cam);</a>
<a name="ln932">      if(!fname) continue;</a>
<a name="ln933"> </a>
<a name="ln934">      char *output = g_build_filename(output_path, fname, (char *)NULL);</a>
<a name="ln935"> </a>
<a name="ln936">      int handle = g_open(output, O_CREAT | O_WRONLY, 0666);</a>
<a name="ln937">      if(handle &gt; 0)</a>
<a name="ln938">      {</a>
<a name="ln939">        size_t written = 0;</a>
<a name="ln940"> </a>
<a name="ln941">        while(written &lt; size)</a>
<a name="ln942">        {</a>
<a name="ln943">          ssize_t ret = write(handle, data + written, size - written);</a>
<a name="ln944"> </a>
<a name="ln945">          if(ret &lt; 0)</a>
<a name="ln946">          {</a>
<a name="ln947">            if(errno == EINTR)</a>
<a name="ln948">            {</a>
<a name="ln949">              continue;</a>
<a name="ln950">            }</a>
<a name="ln951">            else</a>
<a name="ln952">            {</a>
<a name="ln953">              break;</a>
<a name="ln954">            }</a>
<a name="ln955">          }</a>
<a name="ln956"> </a>
<a name="ln957">          written += ret;</a>
<a name="ln958">        }</a>
<a name="ln959"> </a>
<a name="ln960">        close(handle);</a>
<a name="ln961"> </a>
<a name="ln962">        if(written &lt; size)</a>
<a name="ln963">        {</a>
<a name="ln964">          // If the file was not copied successfully we remove it.</a>
<a name="ln965">          g_unlink(output);</a>
<a name="ln966">          dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to download file %s\n&quot;, output);</a>
<a name="ln967">        }</a>
<a name="ln968">        else</a>
<a name="ln969">        {</a>
<a name="ln970">          _dispatch_camera_image_downloaded(c, cam, output);</a>
<a name="ln971">        }</a>
<a name="ln972">      }</a>
<a name="ln973">      else</a>
<a name="ln974">      {</a>
<a name="ln975">        dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to download file %s\n&quot;, output);</a>
<a name="ln976">      }</a>
<a name="ln977">      gp_file_free(camfile);</a>
<a name="ln978">      g_free(output);</a>
<a name="ln979">    } while((ifile = g_list_next(ifile)));</a>
<a name="ln980"> </a>
<a name="ln981">  _dispatch_control_status(c, CAMERA_CONTROL_AVAILABLE);</a>
<a name="ln982">  _camctl_unlock(c);</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985"> </a>
<a name="ln986">static int _camctl_recursive_get_previews(const dt_camctl_t *c, dt_camera_preview_flags_t flags, char *path)</a>
<a name="ln987">{</a>
<a name="ln988">  CameraList *files;</a>
<a name="ln989">  CameraList *folders;</a>
<a name="ln990">  const char *filename;</a>
<a name="ln991">  const char *foldername;</a>
<a name="ln992"> </a>
<a name="ln993">  gp_list_new(&amp;files);</a>
<a name="ln994">  gp_list_new(&amp;folders);</a>
<a name="ln995"> </a>
<a name="ln996">  // Process files in current folder...</a>
<a name="ln997">  if(gp_camera_folder_list_files(c-&gt;active_camera-&gt;gpcam, path, files, c-&gt;gpcontext) == GP_OK)</a>
<a name="ln998">  {</a>
<a name="ln999">    for(int i = 0; i &lt; gp_list_count(files); i++)</a>
<a name="ln1000">    {</a>
<a name="ln1001">      gp_list_get_name(files, i, &amp;filename);</a>
<a name="ln1002">      char *file = g_build_filename(path, filename, NULL);</a>
<a name="ln1003"> </a>
<a name="ln1004">      // Lets check the type of file...</a>
<a name="ln1005">      CameraFileInfo cfi;</a>
<a name="ln1006">      if(gp_camera_file_get_info(c-&gt;active_camera-&gt;gpcam, path, filename, &amp;cfi, c-&gt;gpcontext) == GP_OK)</a>
<a name="ln1007">      {</a>
<a name="ln1008">        CameraFile *preview = NULL;</a>
<a name="ln1009">        CameraFile *exif = NULL;</a>
<a name="ln1010"> </a>
<a name="ln1011">        /*</a>
<a name="ln1012">         * Fetch image preview if flagged...</a>
<a name="ln1013">         */</a>
<a name="ln1014">        if(flags &amp; CAMCTL_IMAGE_PREVIEW_DATA)</a>
<a name="ln1015">        {</a>
<a name="ln1016">          gp_file_new(&amp;preview);</a>
<a name="ln1017">          if(gp_camera_file_get(c-&gt;active_camera-&gt;gpcam, path, filename, GP_FILE_TYPE_PREVIEW, preview,</a>
<a name="ln1018">                                c-&gt;gpcontext) &lt; GP_OK)</a>
<a name="ln1019">          {</a>
<a name="ln1020">            // No preview for file lets check image size to see if we should download full image for</a>
<a name="ln1021">            // preview...</a>
<a name="ln1022">            if(cfi.file.size &gt; 0 &amp;&amp; cfi.file.size &lt; 512000)</a>
<a name="ln1023">            {</a>
<a name="ln1024">              if(gp_camera_file_get(c-&gt;active_camera-&gt;gpcam, path, filename, GP_FILE_TYPE_NORMAL, preview,</a>
<a name="ln1025">                                    c-&gt;gpcontext) &lt; GP_OK)</a>
<a name="ln1026">              {</a>
<a name="ln1027">                preview = NULL;</a>
<a name="ln1028">                dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to retrieve preview of file %s\n&quot;,</a>
<a name="ln1029">                         filename);</a>
<a name="ln1030">              }</a>
<a name="ln1031">            }</a>
<a name="ln1032">            else if(!strncmp(c-&gt;active_camera-&gt;port, &quot;disk:&quot;, 5))</a>
<a name="ln1033">            {</a>
<a name="ln1034">              char fullpath[PATH_MAX] = { 0 };</a>
<a name="ln1035">              snprintf(fullpath, sizeof(fullpath), &quot;%s/%s/%s&quot;, c-&gt;active_camera-&gt;port + 5, path, filename);</a>
<a name="ln1036">              uint8_t *buf = NULL; // gphoto takes care of freeing it eventually</a>
<a name="ln1037">              size_t bufsize;</a>
<a name="ln1038">              char *mime_type = NULL;</a>
<a name="ln1039"> </a>
<a name="ln1040">              if(!dt_exif_get_thumbnail(fullpath, &amp;buf, &amp;bufsize, &amp;mime_type))</a>
<a name="ln1041">                gp_file_set_data_and_size(preview, (char *)buf, bufsize);</a>
<a name="ln1042"> </a>
<a name="ln1043">              free(mime_type);</a>
<a name="ln1044">            }</a>
<a name="ln1045">          }</a>
<a name="ln1046">        }</a>
<a name="ln1047"> </a>
<a name="ln1048">        if(flags &amp; CAMCTL_IMAGE_EXIF_DATA)</a>
<a name="ln1049">        {</a>
<a name="ln1050">          gp_file_new(&amp;exif);</a>
<a name="ln1051">          if(gp_camera_file_get(c-&gt;active_camera-&gt;gpcam, path, filename, GP_FILE_TYPE_EXIF, exif,</a>
<a name="ln1052">                                c-&gt;gpcontext) &lt; GP_OK)</a>
<a name="ln1053">          {</a>
<a name="ln1054">            exif = NULL;</a>
<a name="ln1055">            dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to retrieve exif of file %s\n&quot;, filename);</a>
<a name="ln1056">          }</a>
<a name="ln1057">        }</a>
<a name="ln1058"> </a>
<a name="ln1059">        // let's dispatch to host app.. return if we should stop...</a>
<a name="ln1060">        int res = _dispatch_camera_storage_image_filename(c, c-&gt;active_camera, file, preview, exif);</a>
<a name="ln1061">        gp_file_free(preview);</a>
<a name="ln1062">        if(!res)</a>
<a name="ln1063">        {</a>
<a name="ln1064">          g_free(file);</a>
<a name="ln1065">          return 0;</a>
<a name="ln1066">        }</a>
<a name="ln1067">      }</a>
<a name="ln1068">      else</a>
<a name="ln1069">        dt_print(DT_DEBUG_CAMCTL,</a>
<a name="ln1070">                 &quot;[camera_control] failed to get file information of %s in folder %s on device\n&quot;, filename,</a>
<a name="ln1071">                 path);</a>
<a name="ln1072">      g_free(file);</a>
<a name="ln1073">    }</a>
<a name="ln1074">  }</a>
<a name="ln1075"> </a>
<a name="ln1076">  // Recurse into folders in current folder...</a>
<a name="ln1077">  if(gp_camera_folder_list_folders(c-&gt;active_camera-&gt;gpcam, path, folders, c-&gt;gpcontext) == GP_OK)</a>
<a name="ln1078">  {</a>
<a name="ln1079">    for(int i = 0; i &lt; gp_list_count(folders); i++)</a>
<a name="ln1080">    {</a>
<a name="ln1081">      char buffer[PATH_MAX] = { 0 };</a>
<a name="ln1082">      g_strlcat(buffer, path, sizeof(buffer));</a>
<a name="ln1083">      if(path[1] != '\0') g_strlcat(buffer, &quot;/&quot;, sizeof(buffer));</a>
<a name="ln1084">      gp_list_get_name(folders, i, &amp;foldername);</a>
<a name="ln1085">      g_strlcat(buffer, foldername, sizeof(buffer));</a>
<a name="ln1086">      if(!_camctl_recursive_get_previews(c, flags, buffer)) return 0;</a>
<a name="ln1087">    }</a>
<a name="ln1088">  }</a>
<a name="ln1089">  gp_list_free(files);</a>
<a name="ln1090">  gp_list_free(folders);</a>
<a name="ln1091">  return 1;</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">void dt_camctl_select_camera(const dt_camctl_t *c, const dt_camera_t *cam)</a>
<a name="ln1095">{</a>
<a name="ln1096">  _camctl_lock(c, cam);</a>
<a name="ln1097">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1098">  camctl-&gt;wanted_camera = cam;</a>
<a name="ln1099">  _camctl_unlock(c);</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102"> </a>
<a name="ln1103">void dt_camctl_get_previews(const dt_camctl_t *c, dt_camera_preview_flags_t flags, const dt_camera_t *cam)</a>
<a name="ln1104">{</a>
<a name="ln1105">  _camctl_lock(c, cam);</a>
<a name="ln1106">  _camctl_recursive_get_previews(c, flags, &quot;/&quot;);</a>
<a name="ln1107">  _camctl_unlock(c);</a>
<a name="ln1108">}</a>
<a name="ln1109"> </a>
<a name="ln1110">int dt_camctl_can_enter_tether_mode(const dt_camctl_t *c, const dt_camera_t *cam)</a>
<a name="ln1111">{</a>
<a name="ln1112">  /* first check if camera is provided else use wanted cam */</a>
<a name="ln1113">  if(cam == NULL) cam = c-&gt;wanted_camera;</a>
<a name="ln1114"> </a>
<a name="ln1115">  /* check if wanted cam is available else use active camera */</a>
<a name="ln1116">  if(cam == NULL) cam = c-&gt;active_camera;</a>
<a name="ln1117"> </a>
<a name="ln1118">  /* check if active cam is available else use first detected one */</a>
<a name="ln1119">  if(cam == NULL &amp;&amp; c-&gt;cameras) cam = g_list_nth_data(c-&gt;cameras, 0);</a>
<a name="ln1120"> </a>
<a name="ln1121">  if(cam &amp;&amp; cam-&gt;can_tether)</a>
<a name="ln1122">  {</a>
<a name="ln1123">    dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1124">    camctl-&gt;wanted_camera = cam;</a>
<a name="ln1125">    return 1;</a>
<a name="ln1126">  }</a>
<a name="ln1127"> </a>
<a name="ln1128">  return 0;</a>
<a name="ln1129">}</a>
<a name="ln1130"> </a>
<a name="ln1131">void dt_camctl_tether_mode(const dt_camctl_t *c, const dt_camera_t *cam, gboolean enable)</a>
<a name="ln1132">{</a>
<a name="ln1133">  /* first check if camera is provided else use wanted cam */</a>
<a name="ln1134">  if(cam == NULL) cam = c-&gt;wanted_camera;</a>
<a name="ln1135"> </a>
<a name="ln1136">  /* check if wanted cam is available else use active camera */</a>
<a name="ln1137">  if(cam == NULL) cam = c-&gt;active_camera;</a>
<a name="ln1138"> </a>
<a name="ln1139">  /* check if active cam is available else use first detected one */</a>
<a name="ln1140">  if(cam == NULL &amp;&amp; c-&gt;cameras) cam = g_list_nth_data(c-&gt;cameras, 0);</a>
<a name="ln1141"> </a>
<a name="ln1142">  if(cam &amp;&amp; cam-&gt;can_tether)</a>
<a name="ln1143">  {</a>
<a name="ln1144">    dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1145">    dt_camera_t *camera = (dt_camera_t *)cam;</a>
<a name="ln1146"> </a>
<a name="ln1147">    if(enable == TRUE &amp;&amp; camera-&gt;is_tethering != TRUE)</a>
<a name="ln1148">    {</a>
<a name="ln1149">      _camctl_lock(c, cam);</a>
<a name="ln1150">      // Start up camera event polling thread</a>
<a name="ln1151">      dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] enabling tether mode\n&quot;);</a>
<a name="ln1152">      camctl-&gt;active_camera = camera;</a>
<a name="ln1153">      camera-&gt;is_tethering = TRUE;</a>
<a name="ln1154">      dt_pthread_create(&amp;camctl-&gt;camera_event_thread, &amp;_camera_event_thread, (void *)c);</a>
<a name="ln1155">    }</a>
<a name="ln1156">    else</a>
<a name="ln1157">    {</a>
<a name="ln1158">      camera-&gt;is_live_viewing = FALSE;</a>
<a name="ln1159">      camera-&gt;is_tethering = FALSE;</a>
<a name="ln1160">      dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] disabling tether mode\n&quot;);</a>
<a name="ln1161">      _camctl_unlock(c);</a>
<a name="ln1162">      // Wait for tether thread with join??</a>
<a name="ln1163">    }</a>
<a name="ln1164">  }</a>
<a name="ln1165">  else</a>
<a name="ln1166">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to set tether mode with reason: %s\n&quot;,</a>
<a name="ln1167">             cam ? &quot;device does not support tethered capture&quot; : &quot;no active camera&quot;);</a>
<a name="ln1168">}</a>
<a name="ln1169"> </a>
<a name="ln1170">const char *dt_camctl_camera_get_model(const dt_camctl_t *c, const dt_camera_t *cam)</a>
<a name="ln1171">{</a>
<a name="ln1172">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1173">  if(!cam &amp;&amp; (cam = camctl-&gt;active_camera) == NULL &amp;&amp; (cam = camctl-&gt;wanted_camera) == NULL)</a>
<a name="ln1174">  {</a>
<a name="ln1175">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to get model of camera, camera==NULL\n&quot;);</a>
<a name="ln1176">    return NULL;</a>
<a name="ln1177">  }</a>
<a name="ln1178">  return cam-&gt;model;</a>
<a name="ln1179">}</a>
<a name="ln1180"> </a>
<a name="ln1181"> </a>
<a name="ln1182">static void _camera_build_property_menu(CameraWidget *widget, GtkMenu *menu, GCallback item_activate,</a>
<a name="ln1183">                                        gpointer user_data)</a>
<a name="ln1184">{</a>
<a name="ln1185">  int num_children = 0;</a>
<a name="ln1186">  const char *sk;</a>
<a name="ln1187">  CameraWidgetType type;</a>
<a name="ln1188"> </a>
<a name="ln1189">  /* if widget has children lets add menutitem and recurse into container */</a>
<a name="ln1190">  if((num_children = gp_widget_count_children(widget)) &gt; 0)</a>
<a name="ln1191">  {</a>
<a name="ln1192">    CameraWidget *child = NULL;</a>
<a name="ln1193">    for(int i = 0; i &lt; num_children; i++)</a>
<a name="ln1194">    {</a>
<a name="ln1195">      gp_widget_get_child(widget, i, &amp;child);</a>
<a name="ln1196">      gp_widget_get_name(child, &amp;sk);</a>
<a name="ln1197"> </a>
<a name="ln1198">      /* Check if widget is submenu */</a>
<a name="ln1199">      if(gp_widget_count_children(child) &gt; 0)</a>
<a name="ln1200">      {</a>
<a name="ln1201">        /* create submenu item */</a>
<a name="ln1202">        GtkMenuItem *item = GTK_MENU_ITEM(gtk_menu_item_new_with_label(sk));</a>
<a name="ln1203">        gtk_menu_item_set_submenu(item, gtk_menu_new());</a>
<a name="ln1204"> </a>
<a name="ln1205">        /* recurse into submenu */</a>
<a name="ln1206">        _camera_build_property_menu(child, GTK_MENU(gtk_menu_item_get_submenu(item)), item_activate,</a>
<a name="ln1207">                                    user_data);</a>
<a name="ln1208"> </a>
<a name="ln1209">        /* add submenu item to menu if not empty*/</a>
<a name="ln1210">        GList *children = gtk_container_get_children(GTK_CONTAINER(gtk_menu_item_get_submenu(item)));</a>
<a name="ln1211">        if(children)</a>
<a name="ln1212">        {</a>
<a name="ln1213">          gtk_menu_shell_append(GTK_MENU_SHELL(menu), GTK_WIDGET(item));</a>
<a name="ln1214">          g_list_free(children);</a>
<a name="ln1215">        }</a>
<a name="ln1216">      }</a>
<a name="ln1217">      else</a>
<a name="ln1218">      {</a>
<a name="ln1219">        /* check widget type */</a>
<a name="ln1220">        gp_widget_get_type(child, &amp;type);</a>
<a name="ln1221">        if(type == GP_WIDGET_MENU || type == GP_WIDGET_TEXT || type == GP_WIDGET_RADIO)</a>
<a name="ln1222">        {</a>
<a name="ln1223">          /* construct menu item for property */</a>
<a name="ln1224">          gp_widget_get_name(child, &amp;sk);</a>
<a name="ln1225">          GtkMenuItem *item = GTK_MENU_ITEM(gtk_menu_item_new_with_label(sk));</a>
<a name="ln1226">          g_signal_connect(G_OBJECT(item), &quot;activate&quot;, item_activate, user_data);</a>
<a name="ln1227">          /* add submenu item to menu */</a>
<a name="ln1228">          gtk_menu_shell_append(GTK_MENU_SHELL(menu), GTK_WIDGET(item));</a>
<a name="ln1229">        }</a>
<a name="ln1230">      }</a>
<a name="ln1231">    }</a>
<a name="ln1232">  }</a>
<a name="ln1233">}</a>
<a name="ln1234"> </a>
<a name="ln1235">void dt_camctl_camera_build_property_menu(const dt_camctl_t *c, const dt_camera_t *cam, GtkMenu **menu,</a>
<a name="ln1236">                                          GCallback item_activate, gpointer user_data)</a>
<a name="ln1237">{</a>
<a name="ln1238">  /* get active camera */</a>
<a name="ln1239">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1240">  if(!cam &amp;&amp; (cam = camctl-&gt;active_camera) == NULL &amp;&amp; (cam = camctl-&gt;wanted_camera) == NULL)</a>
<a name="ln1241">  {</a>
<a name="ln1242">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to build property menu from camera, camera==NULL\n&quot;);</a>
<a name="ln1243">    return;</a>
<a name="ln1244">  }</a>
<a name="ln1245"> </a>
<a name="ln1246">  dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] building property menu from camera configuration\n&quot;);</a>
<a name="ln1247"> </a>
<a name="ln1248">  /* lock camera config mutex while recursive building property menu */</a>
<a name="ln1249">  dt_camera_t *camera = (dt_camera_t *)cam;</a>
<a name="ln1250">  dt_pthread_mutex_lock(&amp;camera-&gt;config_lock);</a>
<a name="ln1251">  *menu = GTK_MENU(gtk_menu_new());</a>
<a name="ln1252">  _camera_build_property_menu(camera-&gt;configuration, *menu, item_activate, user_data);</a>
<a name="ln1253">  gtk_widget_show_all(GTK_WIDGET(*menu));</a>
<a name="ln1254">  dt_pthread_mutex_unlock(&amp;camera-&gt;config_lock);</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257"> </a>
<a name="ln1258"> </a>
<a name="ln1259">void dt_camctl_camera_set_property_string(const dt_camctl_t *c, const dt_camera_t *cam,</a>
<a name="ln1260">                                          const char *property_name, const char *value)</a>
<a name="ln1261">{</a>
<a name="ln1262">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1263">  if(!cam &amp;&amp; (cam = camctl-&gt;active_camera) == NULL &amp;&amp; (cam = camctl-&gt;wanted_camera) == NULL)</a>
<a name="ln1264">  {</a>
<a name="ln1265">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to set property from camera, camera==NULL\n&quot;);</a>
<a name="ln1266">    return;</a>
<a name="ln1267">  }</a>
<a name="ln1268">  dt_camera_t *camera = (dt_camera_t *)cam;</a>
<a name="ln1269"> </a>
<a name="ln1270">  _camctl_camera_set_property_string_job_t *job = g_malloc(sizeof(_camctl_camera_set_property_string_job_t));</a>
<a name="ln1271">  job-&gt;type = _JOB_TYPE_SET_PROPERTY_STRING;</a>
<a name="ln1272">  job-&gt;name = g_strdup(property_name);</a>
<a name="ln1273">  job-&gt;value = g_strdup(value);</a>
<a name="ln1274"> </a>
<a name="ln1275">  // Push the job on the jobqueue</a>
<a name="ln1276">  _camera_add_job(camctl, camera, job);</a>
<a name="ln1277">}</a>
<a name="ln1278"> </a>
<a name="ln1279">void dt_camctl_camera_set_property_choice(const dt_camctl_t *c, const dt_camera_t *cam,</a>
<a name="ln1280">                                          const char *property_name, const int value)</a>
<a name="ln1281">{</a>
<a name="ln1282">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1283">  if(!cam &amp;&amp; (cam = camctl-&gt;active_camera) == NULL &amp;&amp; (cam = camctl-&gt;wanted_camera) == NULL)</a>
<a name="ln1284">  {</a>
<a name="ln1285">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to set property from camera, camera==NULL\n&quot;);</a>
<a name="ln1286">    return;</a>
<a name="ln1287">  }</a>
<a name="ln1288">  dt_camera_t *camera = (dt_camera_t *)cam;</a>
<a name="ln1289"> </a>
<a name="ln1290">  _camctl_camera_set_property_choice_job_t *job = g_malloc(sizeof(_camctl_camera_set_property_choice_job_t));</a>
<a name="ln1291">  job-&gt;type = _JOB_TYPE_SET_PROPERTY_CHOICE;</a>
<a name="ln1292">  job-&gt;name = g_strdup(property_name);</a>
<a name="ln1293">  job-&gt;value = value;</a>
<a name="ln1294"> </a>
<a name="ln1295">  // Push the job on the jobqueue</a>
<a name="ln1296">  _camera_add_job(camctl, camera, job);</a>
<a name="ln1297">}</a>
<a name="ln1298"> </a>
<a name="ln1299">void dt_camctl_camera_set_property_int(const dt_camctl_t *c, const dt_camera_t *cam,</a>
<a name="ln1300">                                       const char *property_name, const int value)</a>
<a name="ln1301">{</a>
<a name="ln1302">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1303">  if(!cam &amp;&amp; (cam = camctl-&gt;active_camera) == NULL &amp;&amp; (cam = camctl-&gt;wanted_camera) == NULL)</a>
<a name="ln1304">  {</a>
<a name="ln1305">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to set property from camera, camera==NULL\n&quot;);</a>
<a name="ln1306">    return;</a>
<a name="ln1307">  }</a>
<a name="ln1308">  dt_camera_t *camera = (dt_camera_t *)cam;</a>
<a name="ln1309"> </a>
<a name="ln1310">  _camctl_camera_set_property_int_job_t *job = g_malloc(sizeof(_camctl_camera_set_property_int_job_t));</a>
<a name="ln1311">  job-&gt;type = _JOB_TYPE_SET_PROPERTY_INT;</a>
<a name="ln1312">  job-&gt;name = g_strdup(property_name);</a>
<a name="ln1313">  job-&gt;value = value;</a>
<a name="ln1314"> </a>
<a name="ln1315">  // Push the job on the jobqueue</a>
<a name="ln1316">  _camera_add_job(camctl, camera, job);</a>
<a name="ln1317">}</a>
<a name="ln1318"> </a>
<a name="ln1319">const char *dt_camctl_camera_get_property(const dt_camctl_t *c, const dt_camera_t *cam,</a>
<a name="ln1320">                                          const char *property_name)</a>
<a name="ln1321">{</a>
<a name="ln1322">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1323">  if(!cam &amp;&amp; (cam = camctl-&gt;active_camera) == NULL &amp;&amp; (cam = camctl-&gt;wanted_camera) == NULL)</a>
<a name="ln1324">  {</a>
<a name="ln1325">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to get property from camera, camera==NULL\n&quot;);</a>
<a name="ln1326">    return NULL;</a>
<a name="ln1327">  }</a>
<a name="ln1328">  dt_camera_t *camera = (dt_camera_t *)cam;</a>
<a name="ln1329">  dt_pthread_mutex_lock(&amp;camera-&gt;config_lock);</a>
<a name="ln1330">  const char *value = NULL;</a>
<a name="ln1331">  CameraWidget *widget;</a>
<a name="ln1332">  if(gp_widget_get_child_by_name(camera-&gt;configuration, property_name, &amp;widget) == GP_OK)</a>
<a name="ln1333">  {</a>
<a name="ln1334">    gp_widget_get_value(widget, &amp;value);</a>
<a name="ln1335">  }</a>
<a name="ln1336">  dt_pthread_mutex_unlock(&amp;camera-&gt;config_lock);</a>
<a name="ln1337">  return value;</a>
<a name="ln1338">}</a>
<a name="ln1339"> </a>
<a name="ln1340">int dt_camctl_camera_property_exists(const dt_camctl_t *c, const dt_camera_t *cam, const char *property_name)</a>
<a name="ln1341">{</a>
<a name="ln1342">  int exists = 0;</a>
<a name="ln1343">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1344">  if(!cam &amp;&amp; ((cam = camctl-&gt;active_camera) == NULL &amp;&amp; (cam = camctl-&gt;wanted_camera) == NULL))</a>
<a name="ln1345">  {</a>
<a name="ln1346">    dt_print(DT_DEBUG_CAMCTL,</a>
<a name="ln1347">             &quot;[camera_control] failed to check if property exists in camera configuration, camera==NULL\n&quot;);</a>
<a name="ln1348">    return 0;</a>
<a name="ln1349">  }</a>
<a name="ln1350"> </a>
<a name="ln1351">  dt_camera_t *camera = (dt_camera_t *)cam;</a>
<a name="ln1352">  dt_pthread_mutex_lock(&amp;camera-&gt;config_lock);</a>
<a name="ln1353"> </a>
<a name="ln1354">  CameraWidget *widget;</a>
<a name="ln1355">  if(gp_widget_get_child_by_name(camera-&gt;configuration, property_name, &amp;widget) == GP_OK) exists = 1;</a>
<a name="ln1356"> </a>
<a name="ln1357">  dt_pthread_mutex_unlock(&amp;camera-&gt;config_lock);</a>
<a name="ln1358"> </a>
<a name="ln1359">  return exists;</a>
<a name="ln1360">}</a>
<a name="ln1361"> </a>
<a name="ln1362">const char *dt_camctl_camera_property_get_first_choice(const dt_camctl_t *c, const dt_camera_t *cam,</a>
<a name="ln1363">                                                       const char *property_name)</a>
<a name="ln1364">{</a>
<a name="ln1365">  const char *value = NULL;</a>
<a name="ln1366">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1367">  if(!cam &amp;&amp; ((cam = camctl-&gt;active_camera) == NULL &amp;&amp; (cam = camctl-&gt;wanted_camera) == NULL))</a>
<a name="ln1368">  {</a>
<a name="ln1369">    dt_print(DT_DEBUG_CAMCTL,</a>
<a name="ln1370">             &quot;[camera_control] failed to get first choice of property from camera, camera==NULL\n&quot;);</a>
<a name="ln1371">    return NULL;</a>
<a name="ln1372">  }</a>
<a name="ln1373">  dt_camera_t *camera = (dt_camera_t *)cam;</a>
<a name="ln1374">  dt_pthread_mutex_lock(&amp;camera-&gt;config_lock);</a>
<a name="ln1375">  if(gp_widget_get_child_by_name(camera-&gt;configuration, property_name, &amp;camera-&gt;current_choice.widget)</a>
<a name="ln1376">     == GP_OK)</a>
<a name="ln1377">  {</a>
<a name="ln1378">    camera-&gt;current_choice.index = 0;</a>
<a name="ln1379">    gp_widget_get_choice(camera-&gt;current_choice.widget, camera-&gt;current_choice.index, &amp;value);</a>
<a name="ln1380">  }</a>
<a name="ln1381">  else</a>
<a name="ln1382">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] property name '%s' not found in camera configuration.\n&quot;,</a>
<a name="ln1383">             property_name);</a>
<a name="ln1384"> </a>
<a name="ln1385">  dt_pthread_mutex_unlock(&amp;camera-&gt;config_lock);</a>
<a name="ln1386"> </a>
<a name="ln1387">  return value;</a>
<a name="ln1388">}</a>
<a name="ln1389"> </a>
<a name="ln1390">const char *dt_camctl_camera_property_get_next_choice(const dt_camctl_t *c, const dt_camera_t *cam,</a>
<a name="ln1391">                                                      const char *property_name)</a>
<a name="ln1392">{</a>
<a name="ln1393">  const char *value = NULL;</a>
<a name="ln1394">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1395">  if(!cam &amp;&amp; ((cam = camctl-&gt;active_camera) == NULL &amp;&amp; (cam = camctl-&gt;wanted_camera) == NULL))</a>
<a name="ln1396">  {</a>
<a name="ln1397">    dt_print(DT_DEBUG_CAMCTL,</a>
<a name="ln1398">             &quot;[camera_control] Failed to get next choice of property from camera, camera==NULL\n&quot;);</a>
<a name="ln1399">    return NULL;</a>
<a name="ln1400">  }</a>
<a name="ln1401">  dt_camera_t *camera = (dt_camera_t *)cam;</a>
<a name="ln1402">  dt_pthread_mutex_lock(&amp;camera-&gt;config_lock);</a>
<a name="ln1403">  if(camera-&gt;current_choice.widget != NULL)</a>
<a name="ln1404">  {</a>
<a name="ln1405"> </a>
<a name="ln1406">    if(++camera-&gt;current_choice.index &lt; gp_widget_count_choices(camera-&gt;current_choice.widget))</a>
<a name="ln1407">    {</a>
<a name="ln1408">      // get the choice value...</a>
<a name="ln1409">      gp_widget_get_choice(camera-&gt;current_choice.widget, camera-&gt;current_choice.index, &amp;value);</a>
<a name="ln1410">    }</a>
<a name="ln1411">    else</a>
<a name="ln1412">    {</a>
<a name="ln1413">      // No more choices, reset current_choices for further use</a>
<a name="ln1414">      camera-&gt;current_choice.index = 0;</a>
<a name="ln1415">      camera-&gt;current_choice.widget = NULL;</a>
<a name="ln1416">    }</a>
<a name="ln1417">  }</a>
<a name="ln1418"> </a>
<a name="ln1419">  dt_pthread_mutex_unlock(&amp;camera-&gt;config_lock);</a>
<a name="ln1420">  return value;</a>
<a name="ln1421">}</a>
<a name="ln1422"> </a>
<a name="ln1423">void dt_camctl_camera_capture(const dt_camctl_t *c, const dt_camera_t *cam)</a>
<a name="ln1424">{</a>
<a name="ln1425">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1426">  if(!cam &amp;&amp; (cam = camctl-&gt;active_camera) == NULL)</a>
<a name="ln1427">  {</a>
<a name="ln1428">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] Failed to capture from camera, camera==NULL\n&quot;);</a>
<a name="ln1429">    return;</a>
<a name="ln1430">  }</a>
<a name="ln1431">  dt_camera_t *camera = (dt_camera_t *)cam;</a>
<a name="ln1432"> </a>
<a name="ln1433">  _camctl_camera_job_t *job = g_malloc(sizeof(_camctl_camera_job_t));</a>
<a name="ln1434">  job-&gt;type = _JOB_TYPE_EXECUTE_CAPTURE;</a>
<a name="ln1435">  _camera_add_job(camctl, camera, job);</a>
<a name="ln1436">}</a>
<a name="ln1437"> </a>
<a name="ln1438">static void _camera_poll_events(const dt_camctl_t *c, const dt_camera_t *cam)</a>
<a name="ln1439">{</a>
<a name="ln1440">  CameraEventType event;</a>
<a name="ln1441">  gpointer data;</a>
<a name="ln1442">  if(gp_camera_wait_for_event(cam-&gt;gpcam, 30, &amp;event, &amp;data, c-&gt;gpcontext) == GP_OK)</a>
<a name="ln1443">  {</a>
<a name="ln1444">    if(event == GP_EVENT_UNKNOWN)</a>
<a name="ln1445">    {</a>
<a name="ln1446">      /* this is really some undefined behavior, seems like it's</a>
<a name="ln1447">      camera driver dependent... very ugly! */</a>
<a name="ln1448">      if(strstr((char *)data, &quot;4006&quot;) || // Nikon PTP driver</a>
<a name="ln1449">         (strstr((char *)data, &quot;PTP Property&quot;)</a>
<a name="ln1450">          &amp;&amp; strstr((char *)data, &quot;changed&quot;)) // Some Canon driver maybe all ??</a>
<a name="ln1451">         )</a>
<a name="ln1452">      {</a>
<a name="ln1453">        // Property change event occurred on camera</a>
<a name="ln1454">        // let's update cache and signalling</a>
<a name="ln1455">        dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] Camera configuration change event, lets update internal &quot;</a>
<a name="ln1456">                                  &quot;configuration cache.\n&quot;);</a>
<a name="ln1457">        _camera_configuration_update(c, cam);</a>
<a name="ln1458">      }</a>
<a name="ln1459">    }</a>
<a name="ln1460">    else if(event == GP_EVENT_FILE_ADDED)</a>
<a name="ln1461">    {</a>
<a name="ln1462">      if(cam-&gt;is_tethering)</a>
<a name="ln1463">      {</a>
<a name="ln1464">        dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] Camera file added event\n&quot;);</a>
<a name="ln1465">        CameraFilePath *fp = (CameraFilePath *)data;</a>
<a name="ln1466">        CameraFile *destination;</a>
<a name="ln1467">        const char *output_path = _dispatch_request_image_path(c, NULL, cam);</a>
<a name="ln1468">        if(!output_path) output_path = &quot;/tmp&quot;;</a>
<a name="ln1469">        const char *fname = _dispatch_request_image_filename(c, fp-&gt;name, NULL, cam);</a>
<a name="ln1470">        if(!fname) fname = fp-&gt;name;</a>
<a name="ln1471"> </a>
<a name="ln1472">        char *output = g_build_filename(output_path, fname, (char *)NULL);</a>
<a name="ln1473"> </a>
<a name="ln1474">        int handle = g_open(output, O_CREAT | O_WRONLY, 0666);</a>
<a name="ln1475">        if(handle != -1)</a>
<a name="ln1476">        {</a>
<a name="ln1477">          gp_file_new_from_fd(&amp;destination, handle);</a>
<a name="ln1478">          if(gp_camera_file_get(cam-&gt;gpcam, fp-&gt;folder, fp-&gt;name, GP_FILE_TYPE_NORMAL, destination,</a>
<a name="ln1479">                                c-&gt;gpcontext) == GP_OK)</a>
<a name="ln1480">          {</a>
<a name="ln1481">            // Notify listeners of captured image</a>
<a name="ln1482">            _dispatch_camera_image_downloaded(c, cam, output);</a>
<a name="ln1483">          }</a>
<a name="ln1484">          else</a>
<a name="ln1485">            dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to download file %s\n&quot;, output);</a>
<a name="ln1486">          close(handle);</a>
<a name="ln1487">        }</a>
<a name="ln1488">        else</a>
<a name="ln1489">          dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] failed to download file %s\n&quot;, output);</a>
<a name="ln1490">        g_free(output);</a>
<a name="ln1491">      }</a>
<a name="ln1492">    }</a>
<a name="ln1493">  }</a>
<a name="ln1494">}</a>
<a name="ln1495"> </a>
<a name="ln1496"> </a>
<a name="ln1497">static void _camera_configuration_notify_change(const dt_camctl_t *c, const dt_camera_t *camera,</a>
<a name="ln1498">                                                CameraWidget *new_config, CameraWidget *old_config)</a>
<a name="ln1499">{</a>
<a name="ln1500">  const char *new_config_name = NULL;</a>
<a name="ln1501">  if(gp_widget_get_name(new_config, &amp;new_config_name) != GP_OK) return;</a>
<a name="ln1502"> </a>
<a name="ln1503">  // If new_config widget has children let's recurse into each children</a>
<a name="ln1504">  int children = gp_widget_count_children(new_config);</a>
<a name="ln1505">  if(children &gt; 0)</a>
<a name="ln1506">  {</a>
<a name="ln1507">    CameraWidget *child = NULL;</a>
<a name="ln1508">    for(int i = 0; i &lt; children; i++)</a>
<a name="ln1509">    {</a>
<a name="ln1510">      if(gp_widget_get_child(new_config, i, &amp;child) == GP_OK)</a>
<a name="ln1511">        _camera_configuration_notify_change(c, camera, child, old_config);</a>
<a name="ln1512">    }</a>
<a name="ln1513">  }</a>
<a name="ln1514">  else</a>
<a name="ln1515">  {</a>
<a name="ln1516">    CameraWidget *old_config_child = NULL;</a>
<a name="ln1517">    if(gp_widget_get_child_by_name(old_config, new_config_name, &amp;old_config_child) != GP_OK) return;</a>
<a name="ln1518"> </a>
<a name="ln1519">    CameraWidgetType new_config_type, old_config_type;</a>
<a name="ln1520">    if(gp_widget_get_type(new_config, &amp;new_config_type) != GP_OK) return;</a>
<a name="ln1521">    if(gp_widget_get_type(old_config_child, &amp;old_config_type) != GP_OK) return;</a>
<a name="ln1522"> </a>
<a name="ln1523"> </a>
<a name="ln1524">    //</a>
<a name="ln1525">    // First of all check if widget has change accessibility</a>
<a name="ln1526">    //</a>
<a name="ln1527">    /// TODO: Resolve this 2.4.8 libgphoto2 dependency</a>
<a name="ln1528">    /*</a>
<a name="ln1529">    int sa,da;</a>
<a name="ln1530">    gp_widget_get_readonly( new_config, &amp;sa );</a>
<a name="ln1531">    gp_widget_get_readonly( old_config_child, &amp;da );</a>
<a name="ln1532"> </a>
<a name="ln1533">    if(  notify_all || ( sa != da ) ) {</a>
<a name="ln1534">      // update old_config widget to new accessibility if differ then notify of the change</a>
<a name="ln1535">      if( ( sa != da )  )</a>
<a name="ln1536">        gp_widget_set_readonly( old_config_child, sa );</a>
<a name="ln1537"> </a>
<a name="ln1538">      _dispatch_camera_property_accessibility_changed(c, camera,new_config_name, ( sa == 1 ) ? TRUE: FALSE) ;</a>
<a name="ln1539">    }</a>
<a name="ln1540">    */</a>
<a name="ln1541"> </a>
<a name="ln1542">    //</a>
<a name="ln1543">    // Lets compare values and notify on change or by notifyAll flag</a>
<a name="ln1544">    //</a>
<a name="ln1545">    if(new_config_type == GP_WIDGET_MENU || new_config_type == GP_WIDGET_TEXT || new_config_type == GP_WIDGET_RADIO ||</a>
<a name="ln1546">       old_config_type == GP_WIDGET_MENU || old_config_type == GP_WIDGET_TEXT || old_config_type == GP_WIDGET_RADIO)</a>
<a name="ln1547">    {</a>
<a name="ln1548">      char *new_config_value = NULL;</a>
<a name="ln1549">      char *old_config_value = NULL;</a>
<a name="ln1550"> </a>
<a name="ln1551">      // gphoto2 has a &quot;feature&quot; that turns RANGE with a small value range and step size of 1 into a MENU.</a>
<a name="ln1552">      // that can for example happen when detaching the lens. the focus range suddenly shrinks to 0 .. 0 and becomes</a>
<a name="ln1553">      // a MENU. See https://redmine.darktable.org/issues/12004 for the crash resulting from that.</a>
<a name="ln1554"> </a>
<a name="ln1555">      // Get new_config and old_config value to be compared</a>
<a name="ln1556">      if(new_config_type == GP_WIDGET_RANGE)</a>
<a name="ln1557">      {</a>
<a name="ln1558">        float value;</a>
<a name="ln1559">        if(gp_widget_get_value(new_config, &amp;value) != GP_OK) goto end;</a>
<a name="ln1560">        new_config_value = g_strdup_printf(&quot;%.0f&quot;, value);</a>
<a name="ln1561">      }</a>
<a name="ln1562">      else</a>
<a name="ln1563">        if(gp_widget_get_value(new_config, &amp;new_config_value) != GP_OK) goto end;</a>
<a name="ln1564"> </a>
<a name="ln1565">      if(old_config_type == GP_WIDGET_RANGE)</a>
<a name="ln1566">      {</a>
<a name="ln1567">        float value;</a>
<a name="ln1568">        if(gp_widget_get_value(old_config_child, &amp;value) != GP_OK) goto end;</a>
<a name="ln1569">        old_config_value = g_strdup_printf(&quot;%.0f&quot;, value);</a>
<a name="ln1570">      }</a>
<a name="ln1571">      else</a>
<a name="ln1572">        if(gp_widget_get_value(old_config_child, &amp;old_config_value) != GP_OK) goto end;</a>
<a name="ln1573"> </a>
<a name="ln1574">      if(g_strcmp0(new_config_value, old_config_value) != 0)</a>
<a name="ln1575">        _dispatch_camera_property_value_changed(c, camera, new_config_name, new_config_value);</a>
<a name="ln1576"> </a>
<a name="ln1577">end:</a>
<a name="ln1578">      if(new_config_type == GP_WIDGET_RANGE) g_free(new_config_value);</a>
<a name="ln1579">      if(old_config_type == GP_WIDGET_RANGE) g_free(old_config_value);</a>
<a name="ln1580">    }</a>
<a name="ln1581">  }</a>
<a name="ln1582">}</a>
<a name="ln1583"> </a>
<a name="ln1584">static void _camera_configuration_commit(const dt_camctl_t *c, const dt_camera_t *camera)</a>
<a name="ln1585">{</a>
<a name="ln1586">  g_assert(camera != NULL);</a>
<a name="ln1587"> </a>
<a name="ln1588">  dt_camera_t *cam = (dt_camera_t *)camera;</a>
<a name="ln1589"> </a>
<a name="ln1590">  dt_pthread_mutex_lock(&amp;cam-&gt;config_lock);</a>
<a name="ln1591">  if(gp_camera_set_config(camera-&gt;gpcam, camera-&gt;configuration, c-&gt;gpcontext) != GP_OK)</a>
<a name="ln1592">    dt_print(DT_DEBUG_CAMCTL, &quot;[camera_control] Failed to commit configuration changes to camera\n&quot;);</a>
<a name="ln1593"> </a>
<a name="ln1594">  cam-&gt;config_changed = FALSE;</a>
<a name="ln1595">  dt_pthread_mutex_unlock(&amp;cam-&gt;config_lock);</a>
<a name="ln1596">}</a>
<a name="ln1597"> </a>
<a name="ln1598">static void _camera_configuration_update(const dt_camctl_t *c, const dt_camera_t *camera)</a>
<a name="ln1599">{</a>
<a name="ln1600">  dt_camera_t *cam = (dt_camera_t *)camera;</a>
<a name="ln1601">  dt_pthread_mutex_lock(&amp;cam-&gt;config_lock);</a>
<a name="ln1602">  CameraWidget *remote; // Copy of remote configuration</a>
<a name="ln1603">  gp_camera_get_config(camera-&gt;gpcam, &amp;remote, c-&gt;gpcontext);</a>
<a name="ln1604">  // merge remote copy with cache and notify on changed properties to host application</a>
<a name="ln1605">  _camera_configuration_notify_change(c, camera, remote, camera-&gt;configuration);</a>
<a name="ln1606">  gp_widget_free(cam-&gt;configuration);</a>
<a name="ln1607">  cam-&gt;configuration = remote;</a>
<a name="ln1608">  dt_pthread_mutex_unlock(&amp;cam-&gt;config_lock);</a>
<a name="ln1609">}</a>
<a name="ln1610"> </a>
<a name="ln1611">static const char *_dispatch_request_image_filename(const dt_camctl_t *c, const char *filename,</a>
<a name="ln1612">                                                    time_t *exif_time, const dt_camera_t *camera)</a>
<a name="ln1613">{</a>
<a name="ln1614">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1615">  GList *listener;</a>
<a name="ln1616">  const char *path = NULL;</a>
<a name="ln1617">  dt_pthread_mutex_lock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1618">  if((listener = g_list_first(camctl-&gt;listeners)) != NULL) do</a>
<a name="ln1619">    {</a>
<a name="ln1620">      if(((dt_camctl_listener_t *)listener-&gt;data)-&gt;request_image_filename != NULL)</a>
<a name="ln1621">        path = ((dt_camctl_listener_t *)listener-&gt;data)</a>
<a name="ln1622">                   -&gt;request_image_filename(camera, filename, exif_time,</a>
<a name="ln1623">                                            ((dt_camctl_listener_t *)listener-&gt;data)-&gt;data);</a>
<a name="ln1624">    } while((listener = g_list_next(listener)) != NULL);</a>
<a name="ln1625">  dt_pthread_mutex_unlock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1626">  return path;</a>
<a name="ln1627">}</a>
<a name="ln1628"> </a>
<a name="ln1629">static const char *_dispatch_request_image_path(const dt_camctl_t *c, time_t *exif_time, const dt_camera_t *camera)</a>
<a name="ln1630">{</a>
<a name="ln1631">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1632">  GList *listener;</a>
<a name="ln1633">  const char *path = NULL;</a>
<a name="ln1634">  dt_pthread_mutex_lock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1635">  if((listener = g_list_first(camctl-&gt;listeners)) != NULL) do</a>
<a name="ln1636">    {</a>
<a name="ln1637">      if(((dt_camctl_listener_t *)listener-&gt;data)-&gt;request_image_path != NULL)</a>
<a name="ln1638">        path = ((dt_camctl_listener_t *)listener-&gt;data)</a>
<a name="ln1639">                   -&gt;request_image_path(camera, exif_time, ((dt_camctl_listener_t *)listener-&gt;data)-&gt;data);</a>
<a name="ln1640">    } while((listener = g_list_next(listener)) != NULL);</a>
<a name="ln1641">  dt_pthread_mutex_unlock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1642">  return path;</a>
<a name="ln1643">}</a>
<a name="ln1644"> </a>
<a name="ln1645">static void _dispatch_camera_connected(const dt_camctl_t *c, const dt_camera_t *camera)</a>
<a name="ln1646">{</a>
<a name="ln1647">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1648">  GList *listener;</a>
<a name="ln1649">  dt_pthread_mutex_lock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1650">  if((listener = g_list_first(camctl-&gt;listeners)) != NULL) do</a>
<a name="ln1651">    {</a>
<a name="ln1652">      if(((dt_camctl_listener_t *)listener-&gt;data)-&gt;camera_connected != NULL)</a>
<a name="ln1653">        ((dt_camctl_listener_t *)listener-&gt;data)</a>
<a name="ln1654">            -&gt;camera_connected(camera, ((dt_camctl_listener_t *)listener-&gt;data)-&gt;data);</a>
<a name="ln1655">    } while((listener = g_list_next(listener)) != NULL);</a>
<a name="ln1656">  dt_pthread_mutex_unlock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1657">}</a>
<a name="ln1658"> </a>
<a name="ln1659">static void _dispatch_camera_disconnected(const dt_camctl_t *c, const dt_camera_t *camera)</a>
<a name="ln1660">{</a>
<a name="ln1661">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1662">  GList *listener;</a>
<a name="ln1663">  dt_pthread_mutex_lock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1664">  if((listener = g_list_first(camctl-&gt;listeners)) != NULL) do</a>
<a name="ln1665">    {</a>
<a name="ln1666">      if(((dt_camctl_listener_t *)listener-&gt;data)-&gt;camera_disconnected != NULL)</a>
<a name="ln1667">        ((dt_camctl_listener_t *)listener-&gt;data)</a>
<a name="ln1668">            -&gt;camera_disconnected(camera, ((dt_camctl_listener_t *)listener-&gt;data)-&gt;data);</a>
<a name="ln1669">    } while((listener = g_list_next(listener)) != NULL);</a>
<a name="ln1670">  dt_pthread_mutex_unlock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1671">}</a>
<a name="ln1672"> </a>
<a name="ln1673">static void _dispatch_camera_image_downloaded(const dt_camctl_t *c, const dt_camera_t *camera, const char *filename)</a>
<a name="ln1674">{</a>
<a name="ln1675">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1676">  GList *listener;</a>
<a name="ln1677">  dt_pthread_mutex_lock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1678">  if((listener = g_list_first(camctl-&gt;listeners)) != NULL) do</a>
<a name="ln1679">    {</a>
<a name="ln1680">      if(((dt_camctl_listener_t *)listener-&gt;data)-&gt;image_downloaded != NULL)</a>
<a name="ln1681">        ((dt_camctl_listener_t *)listener-&gt;data)</a>
<a name="ln1682">            -&gt;image_downloaded(camera, filename, ((dt_camctl_listener_t *)listener-&gt;data)-&gt;data);</a>
<a name="ln1683">    } while((listener = g_list_next(listener)) != NULL);</a>
<a name="ln1684">  dt_pthread_mutex_unlock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1685">}</a>
<a name="ln1686"> </a>
<a name="ln1687">static int _dispatch_camera_storage_image_filename(const dt_camctl_t *c, const dt_camera_t *camera,</a>
<a name="ln1688">                                                   const char *filename, CameraFile *preview, CameraFile *exif)</a>
<a name="ln1689">{</a>
<a name="ln1690">  int res = 0;</a>
<a name="ln1691">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1692">  GList *listener;</a>
<a name="ln1693">  dt_pthread_mutex_lock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1694">  if((listener = g_list_first(camctl-&gt;listeners)) != NULL) do</a>
<a name="ln1695">    {</a>
<a name="ln1696">      if(((dt_camctl_listener_t *)listener-&gt;data)-&gt;camera_storage_image_filename != NULL)</a>
<a name="ln1697">        res = ((dt_camctl_listener_t *)listener-&gt;data)</a>
<a name="ln1698">                  -&gt;camera_storage_image_filename(camera, filename, preview, exif,</a>
<a name="ln1699">                                                  ((dt_camctl_listener_t *)listener-&gt;data)-&gt;data);</a>
<a name="ln1700">    } while((listener = g_list_next(listener)) != NULL);</a>
<a name="ln1701">  dt_pthread_mutex_unlock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1702">  return res;</a>
<a name="ln1703">}</a>
<a name="ln1704"> </a>
<a name="ln1705">static void _dispatch_control_status(const dt_camctl_t *c, dt_camctl_status_t status)</a>
<a name="ln1706">{</a>
<a name="ln1707">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1708">  GList *listener;</a>
<a name="ln1709">  dt_pthread_mutex_lock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1710">  if((listener = g_list_first(camctl-&gt;listeners)) != NULL) do</a>
<a name="ln1711">    {</a>
<a name="ln1712">      if(((dt_camctl_listener_t *)listener-&gt;data)-&gt;control_status != NULL)</a>
<a name="ln1713">        ((dt_camctl_listener_t *)listener-&gt;data)</a>
<a name="ln1714">            -&gt;control_status(status, ((dt_camctl_listener_t *)listener-&gt;data)-&gt;data);</a>
<a name="ln1715">    } while((listener = g_list_next(listener)) != NULL);</a>
<a name="ln1716">  dt_pthread_mutex_unlock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1717">}</a>
<a name="ln1718"> </a>
<a name="ln1719">static void _dispatch_camera_property_value_changed(const dt_camctl_t *c, const dt_camera_t *camera,</a>
<a name="ln1720">                                                    const char *name, const char *value)</a>
<a name="ln1721">{</a>
<a name="ln1722">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1723">  GList *listener;</a>
<a name="ln1724">  dt_pthread_mutex_lock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1725">  if((listener = g_list_first(camctl-&gt;listeners)) != NULL) do</a>
<a name="ln1726">    {</a>
<a name="ln1727">      if(((dt_camctl_listener_t *)listener-&gt;data)-&gt;camera_property_value_changed != NULL)</a>
<a name="ln1728">        ((dt_camctl_listener_t *)listener-&gt;data)</a>
<a name="ln1729">            -&gt;camera_property_value_changed(camera, name, value,</a>
<a name="ln1730">                                            ((dt_camctl_listener_t *)listener-&gt;data)-&gt;data);</a>
<a name="ln1731">    } while((listener = g_list_next(listener)) != NULL);</a>
<a name="ln1732">  dt_pthread_mutex_unlock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1733">}</a>
<a name="ln1734"> </a>
<a name="ln1735">/*</a>
<a name="ln1736">static void _dispatch_camera_property_accessibility_changed(const dt_camctl_t *c, const dt_camera_t *camera,</a>
<a name="ln1737">                                                            const char *name, gboolean read_only)</a>
<a name="ln1738">{</a>
<a name="ln1739">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1740">  GList *listener;</a>
<a name="ln1741">  dt_pthread_mutex_lock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1742">  if((listener = g_list_first(camctl-&gt;listeners)) != NULL) do</a>
<a name="ln1743">    {</a>
<a name="ln1744">      if(((dt_camctl_listener_t *)listener-&gt;data)-&gt;camera_property_accessibility_changed != NULL)</a>
<a name="ln1745">        ((dt_camctl_listener_t *)listener-&gt;data)</a>
<a name="ln1746">            -&gt;camera_property_accessibility_changed(camera, name, read_only,</a>
<a name="ln1747">                                                    ((dt_camctl_listener_t *)listener-&gt;data)-&gt;data);</a>
<a name="ln1748">    } while((listener = g_list_next(listener)) != NULL);</a>
<a name="ln1749">  dt_pthread_mutex_unlock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1750">}</a>
<a name="ln1751">*/</a>
<a name="ln1752"> </a>
<a name="ln1753">static void _dispatch_camera_error(const dt_camctl_t *c, const dt_camera_t *camera, dt_camera_error_t error)</a>
<a name="ln1754">{</a>
<a name="ln1755">  dt_camctl_t *camctl = (dt_camctl_t *)c;</a>
<a name="ln1756">  GList *listener;</a>
<a name="ln1757">  dt_pthread_mutex_lock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1758">  if((listener = g_list_first(camctl-&gt;listeners)) != NULL) do</a>
<a name="ln1759">    {</a>
<a name="ln1760">      if(((dt_camctl_listener_t *)listener-&gt;data)-&gt;camera_error != NULL)</a>
<a name="ln1761">        ((dt_camctl_listener_t *)listener-&gt;data)</a>
<a name="ln1762">            -&gt;camera_error(camera, error, ((dt_camctl_listener_t *)listener-&gt;data)-&gt;data);</a>
<a name="ln1763">    } while((listener = g_list_next(listener)) != NULL);</a>
<a name="ln1764">  dt_pthread_mutex_unlock(&amp;camctl-&gt;listeners_lock);</a>
<a name="ln1765">}</a>
<a name="ln1766"> </a>
<a name="ln1767">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1768">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1769">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="855"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'GP_FILE_OPERATION_NONE' named constant with the value of 0 is used in the bitwise operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
