
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika, Tobias Ellinghaus.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;common/debug.h&quot;</a>
<a name="ln24">#include &quot;common/l10n.h&quot;</a>
<a name="ln25">#include &quot;common/presets.h&quot;</a>
<a name="ln26">#include &quot;control/control.h&quot;</a>
<a name="ln27">#include &quot;develop/imageop.h&quot;</a>
<a name="ln28">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln29">#include &quot;gui/draw.h&quot;</a>
<a name="ln30">#include &quot;gui/gtk.h&quot;</a>
<a name="ln31">#include &quot;gui/preferences.h&quot;</a>
<a name="ln32">#include &quot;gui/presets.h&quot;</a>
<a name="ln33">#include &quot;libs/lib.h&quot;</a>
<a name="ln34">#include &quot;preferences_gen.h&quot;</a>
<a name="ln35">#ifdef USE_LUA</a>
<a name="ln36">#include &quot;lua/preferences.h&quot;</a>
<a name="ln37">#endif</a>
<a name="ln38">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln39">#include &quot;osx/osx.h&quot;</a>
<a name="ln40">#endif</a>
<a name="ln41">#define ICON_SIZE 13</a>
<a name="ln42"> </a>
<a name="ln43">typedef struct dt_gui_presets_edit_dialog_t</a>
<a name="ln44">{</a>
<a name="ln45">  GtkTreeView *tree; // CHANGED!</a>
<a name="ln46">  gint rowid;        // CHANGED!</a>
<a name="ln47">  GtkLabel *name;</a>
<a name="ln48">  GtkEntry *description;</a>
<a name="ln49">  GtkCheckButton *autoapply, *filter;</a>
<a name="ln50">  GtkWidget *details;</a>
<a name="ln51">  GtkEntry *model, *maker, *lens;</a>
<a name="ln52">  GtkSpinButton *iso_min, *iso_max;</a>
<a name="ln53">  GtkWidget *exposure_min, *exposure_max;</a>
<a name="ln54">  GtkWidget *aperture_min, *aperture_max;</a>
<a name="ln55">  GtkSpinButton *focal_length_min, *focal_length_max;</a>
<a name="ln56">  GtkWidget *format_btn[3];</a>
<a name="ln57">} dt_gui_presets_edit_dialog_t;</a>
<a name="ln58"> </a>
<a name="ln59">// FIXME: this is copypasta from gui/presets.c. better put these somewhere so that all places can access the</a>
<a name="ln60">// same data.</a>
<a name="ln61">static const int dt_gui_presets_exposure_value_cnt = 24;</a>
<a name="ln62">static const float dt_gui_presets_exposure_value[]</a>
<a name="ln63">    = { 0.,       1. / 8000, 1. / 4000, 1. / 2000, 1. / 1000, 1. / 1000, 1. / 500, 1. / 250,</a>
<a name="ln64">        1. / 125, 1. / 60,   1. / 30,   1. / 15,   1. / 15,   1. / 8,    1. / 4,   1. / 2,</a>
<a name="ln65">        1,        2,         4,         8,         15,        30,        60,       FLT_MAX };</a>
<a name="ln66">static const char *dt_gui_presets_exposure_value_str[]</a>
<a name="ln67">    = { &quot;0&quot;,     &quot;1/8000&quot;, &quot;1/4000&quot;, &quot;1/2000&quot;, &quot;1/1000&quot;, &quot;1/1000&quot;, &quot;1/500&quot;, &quot;1/250&quot;,</a>
<a name="ln68">        &quot;1/125&quot;, &quot;1/60&quot;,   &quot;1/30&quot;,   &quot;1/15&quot;,   &quot;1/15&quot;,   &quot;1/8&quot;,    &quot;1/4&quot;,   &quot;1/2&quot;,</a>
<a name="ln69">        &quot;1\&quot;&quot;,   &quot;2\&quot;&quot;,    &quot;4\&quot;&quot;,    &quot;8\&quot;&quot;,    &quot;15\&quot;&quot;,   &quot;30\&quot;&quot;,   &quot;60\&quot;&quot;,  &quot;+&quot; };</a>
<a name="ln70">static const int dt_gui_presets_aperture_value_cnt = 19;</a>
<a name="ln71">static const float dt_gui_presets_aperture_value[]</a>
<a name="ln72">    = { 0,    0.5,  0.7,  1.0,  1.4,  2.0,  2.8,  4.0,   5.6,    8.0,</a>
<a name="ln73">        11.0, 16.0, 22.0, 32.0, 45.0, 64.0, 90.0, 128.0, FLT_MAX };</a>
<a name="ln74">static const char *dt_gui_presets_aperture_value_str[]</a>
<a name="ln75">    = { &quot;f/0&quot;,  &quot;f/0.5&quot;, &quot;f/0.7&quot;, &quot;f/1.0&quot;, &quot;f/1.4&quot;, &quot;f/2&quot;,  &quot;f/2.8&quot;, &quot;f/4&quot;,   &quot;f/5.6&quot;, &quot;f/8&quot;,</a>
<a name="ln76">        &quot;f/11&quot;, &quot;f/16&quot;,  &quot;f/22&quot;,  &quot;f/32&quot;,  &quot;f/45&quot;,  &quot;f/64&quot;, &quot;f/90&quot;,  &quot;f/128&quot;, &quot;f/+&quot; };</a>
<a name="ln77"> </a>
<a name="ln78">// format string and corresponding flag stored into the database</a>
<a name="ln79">static const char *dt_gui_presets_format_value_str[3] = { N_(&quot;normal images&quot;),</a>
<a name="ln80">                                                          N_(&quot;raw&quot;),</a>
<a name="ln81">                                                          N_(&quot;HDR&quot;)};</a>
<a name="ln82">static const int dt_gui_presets_format_flag[3] = { FOR_LDR, FOR_RAW, FOR_HDR };</a>
<a name="ln83"> </a>
<a name="ln84">// Values for the accelerators/presets treeview</a>
<a name="ln85"> </a>
<a name="ln86">enum</a>
<a name="ln87">{</a>
<a name="ln88">  A_ACCEL_COLUMN,</a>
<a name="ln89">  A_BINDING_COLUMN,</a>
<a name="ln90">  A_TRANS_COLUMN,</a>
<a name="ln91">  A_N_COLUMNS</a>
<a name="ln92">};</a>
<a name="ln93">enum</a>
<a name="ln94">{</a>
<a name="ln95">  P_ROWID_COLUMN,</a>
<a name="ln96">  P_OPERATION_COLUMN,</a>
<a name="ln97">  P_MODULE_COLUMN,</a>
<a name="ln98">  P_EDITABLE_COLUMN,</a>
<a name="ln99">  P_NAME_COLUMN,</a>
<a name="ln100">  P_MODEL_COLUMN,</a>
<a name="ln101">  P_MAKER_COLUMN,</a>
<a name="ln102">  P_LENS_COLUMN,</a>
<a name="ln103">  P_ISO_COLUMN,</a>
<a name="ln104">  P_EXPOSURE_COLUMN,</a>
<a name="ln105">  P_APERTURE_COLUMN,</a>
<a name="ln106">  P_FOCAL_LENGTH_COLUMN,</a>
<a name="ln107">  P_AUTOAPPLY_COLUMN,</a>
<a name="ln108">  P_N_COLUMNS</a>
<a name="ln109">};</a>
<a name="ln110"> </a>
<a name="ln111">static void init_tab_presets(GtkWidget *book);</a>
<a name="ln112">static void init_tab_accels(GtkWidget *book);</a>
<a name="ln113">static void tree_insert_accel(gpointer accel_struct, gpointer model_link);</a>
<a name="ln114">static void tree_insert_rec(GtkTreeStore *model, GtkTreeIter *parent, const gchar *accel_path,</a>
<a name="ln115">                            const gchar *translated_path, guint accel_key, GdkModifierType accel_mods);</a>
<a name="ln116">static void path_to_accel(GtkTreeModel *model, GtkTreePath *path, gchar *str, size_t str_len);</a>
<a name="ln117">static void update_accels_model(gpointer widget, gpointer data);</a>
<a name="ln118">static void update_accels_model_rec(GtkTreeModel *model, GtkTreeIter *parent, gchar *path, size_t path_len);</a>
<a name="ln119">static void delete_matching_accels(gpointer path, gpointer key_event);</a>
<a name="ln120">static void import_export(GtkButton *button, gpointer data);</a>
<a name="ln121">static void restore_defaults(GtkButton *button, gpointer data);</a>
<a name="ln122">static gint compare_rows_accels(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data);</a>
<a name="ln123">static gint compare_rows_presets(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data);</a>
<a name="ln124">static void import_preset(GtkButton *button, gpointer data);</a>
<a name="ln125"> </a>
<a name="ln126">// Signal handlers</a>
<a name="ln127">static void tree_row_activated_accels(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln128">                                      gpointer data);</a>
<a name="ln129">static void tree_row_activated_presets(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln130">                                       gpointer data);</a>
<a name="ln131">static void tree_selection_changed(GtkTreeSelection *selection, gpointer data);</a>
<a name="ln132">static gboolean tree_key_press(GtkWidget *widget, GdkEventKey *event, gpointer data);</a>
<a name="ln133">static gboolean tree_key_press_presets(GtkWidget *widget, GdkEventKey *event, gpointer data);</a>
<a name="ln134">static gboolean prefix_search(GtkTreeModel *model, gint column, const gchar *key, GtkTreeIter *iter,</a>
<a name="ln135">                              gpointer d);</a>
<a name="ln136"> </a>
<a name="ln137">static void edit_preset(GtkTreeView *tree, const gint rowid, const gchar *name, const gchar *module);</a>
<a name="ln138">static void edit_preset_response(GtkDialog *dialog, gint response_id, dt_gui_presets_edit_dialog_t *g);</a>
<a name="ln139"> </a>
<a name="ln140">static GtkWidget *_preferences_dialog;</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143">///////////// gui language selection</a>
<a name="ln144"> </a>
<a name="ln145">static void language_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln146">{</a>
<a name="ln147">  int selected = gtk_combo_box_get_active(GTK_COMBO_BOX(widget));</a>
<a name="ln148">  dt_l10n_language_t *language = (dt_l10n_language_t *)g_list_nth(darktable.l10n-&gt;languages, selected)-&gt;data;</a>
<a name="ln149">  if(darktable.l10n-&gt;sys_default == selected)</a>
<a name="ln150">  {</a>
<a name="ln151">    dt_conf_set_string(&quot;ui_last/gui_language&quot;, &quot;&quot;);</a>
<a name="ln152">    darktable.l10n-&gt;selected = darktable.l10n-&gt;sys_default;</a>
<a name="ln153">  }</a>
<a name="ln154">  else</a>
<a name="ln155">  {</a>
<a name="ln156">    dt_conf_set_string(&quot;ui_last/gui_language&quot;, language-&gt;code);</a>
<a name="ln157">    darktable.l10n-&gt;selected = selected;</a>
<a name="ln158">  }</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">static gboolean reset_language_widget(GtkWidget *label, GdkEventButton *event, GtkWidget *widget)</a>
<a name="ln162">{</a>
<a name="ln163">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln164">  {</a>
<a name="ln165">    gtk_combo_box_set_active(GTK_COMBO_BOX(widget), darktable.l10n-&gt;sys_default);</a>
<a name="ln166">    return TRUE;</a>
<a name="ln167">  }</a>
<a name="ln168">  return FALSE;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">static void hardcoded_gui(GtkWidget *grid, int *line)</a>
<a name="ln172">{</a>
<a name="ln173">  GtkWidget *label = gtk_label_new(_(&quot;interface language&quot;));</a>
<a name="ln174">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln175">  GtkWidget *labelev = gtk_event_box_new();</a>
<a name="ln176">  gtk_widget_add_events(labelev, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln177">  gtk_container_add(GTK_CONTAINER(labelev), label);</a>
<a name="ln178">  GtkWidget *widget = gtk_combo_box_text_new();</a>
<a name="ln179"> </a>
<a name="ln180">  for(GList *iter = darktable.l10n-&gt;languages; iter; iter = g_list_next(iter))</a>
<a name="ln181">  {</a>
<a name="ln182">    const char *name = dt_l10n_get_name(iter-&gt;data);</a>
<a name="ln183">    gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(widget), name);</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  gtk_combo_box_set_active(GTK_COMBO_BOX(widget), darktable.l10n-&gt;selected);</a>
<a name="ln187">  g_signal_connect(G_OBJECT(widget), &quot;changed&quot;, G_CALLBACK(language_callback), 0);</a>
<a name="ln188">  gtk_widget_set_tooltip_text(labelev,  _(&quot;double click to reset to the system language&quot;));</a>
<a name="ln189">  gtk_event_box_set_visible_window(GTK_EVENT_BOX(labelev), FALSE);</a>
<a name="ln190">  gtk_widget_set_tooltip_text(widget, _(&quot;set the language of the user interface. the system default is marked with an * (needs a restart)&quot;));</a>
<a name="ln191">  gtk_grid_attach(GTK_GRID(grid), labelev, 0, (*line)++, 1, 1);</a>
<a name="ln192">  gtk_grid_attach_next_to(GTK_GRID(grid), widget, labelev, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln193">  g_signal_connect(G_OBJECT(labelev), &quot;button-press-event&quot;, G_CALLBACK(reset_language_widget), (gpointer)widget);</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">///////////// end of gui language selection</a>
<a name="ln197"> </a>
<a name="ln198"> </a>
<a name="ln199">void dt_gui_preferences_show()</a>
<a name="ln200">{</a>
<a name="ln201">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln202">  _preferences_dialog = gtk_dialog_new_with_buttons(_(&quot;darktable preferences&quot;), GTK_WINDOW(win),</a>
<a name="ln203">                                                    GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,</a>
<a name="ln204">                                                    _(&quot;close&quot;), GTK_RESPONSE_ACCEPT, NULL);</a>
<a name="ln205">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln206">  dt_osx_disallow_fullscreen(_preferences_dialog);</a>
<a name="ln207">#endif</a>
<a name="ln208">  gtk_window_set_position(GTK_WINDOW(_preferences_dialog), GTK_WIN_POS_CENTER_ON_PARENT);</a>
<a name="ln209">  GtkWidget *content = gtk_dialog_get_content_area(GTK_DIALOG(_preferences_dialog));</a>
<a name="ln210">  GtkWidget *notebook = gtk_notebook_new();</a>
<a name="ln211">  gtk_widget_set_size_request(notebook, -1, DT_PIXEL_APPLY_DPI(500));</a>
<a name="ln212">  gtk_widget_set_name(notebook, &quot;preferences_notebook&quot;);</a>
<a name="ln213">  gtk_box_pack_start(GTK_BOX(content), notebook, TRUE, TRUE, 0);</a>
<a name="ln214"> </a>
<a name="ln215">  // Make sure remap mode is off initially</a>
<a name="ln216">  darktable.control-&gt;accel_remap_str = NULL;</a>
<a name="ln217">  darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln218"> </a>
<a name="ln219">  init_tab_gui(_preferences_dialog, notebook, &amp;hardcoded_gui);</a>
<a name="ln220">  init_tab_core(_preferences_dialog, notebook, NULL);</a>
<a name="ln221">  init_tab_session(_preferences_dialog, notebook, NULL);</a>
<a name="ln222">  init_tab_accels(notebook);</a>
<a name="ln223">  init_tab_presets(notebook);</a>
<a name="ln224">#ifdef USE_LUA</a>
<a name="ln225">  GtkGrid* lua_grid = init_tab_lua(_preferences_dialog, notebook);</a>
<a name="ln226">#endif</a>
<a name="ln227">  gtk_widget_show_all(_preferences_dialog);</a>
<a name="ln228">  (void)gtk_dialog_run(GTK_DIALOG(_preferences_dialog));</a>
<a name="ln229">#ifdef USE_LUA</a>
<a name="ln230">  destroy_tab_lua(lua_grid);</a>
<a name="ln231">#endif</a>
<a name="ln232">  gtk_widget_destroy(_preferences_dialog);</a>
<a name="ln233"> </a>
<a name="ln234">  // Cleaning up any memory still allocated for remapping</a>
<a name="ln235">  if(darktable.control-&gt;accel_remap_path)</a>
<a name="ln236">  {</a>
<a name="ln237">    gtk_tree_path_free(darktable.control-&gt;accel_remap_path);</a>
<a name="ln238">    darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln239">  }</a>
<a name="ln240"> </a>
<a name="ln241">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_PREFERENCES_CHANGE);</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">static void cairo_destroy_from_pixbuf(guchar *pixels, gpointer data)</a>
<a name="ln245">{</a>
<a name="ln246">  cairo_destroy((cairo_t *)data);</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">static void tree_insert_presets(GtkTreeStore *tree_model)</a>
<a name="ln250">{</a>
<a name="ln251">  GtkTreeIter iter, parent;</a>
<a name="ln252">  sqlite3_stmt *stmt;</a>
<a name="ln253">  gchar *last_module = NULL;</a>
<a name="ln254"> </a>
<a name="ln255">  // Create a GdkPixbuf with a cairo drawing.</a>
<a name="ln256">  // lock</a>
<a name="ln257">  cairo_surface_t *lock_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln258">                                                         DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln259">  cairo_t *lock_cr = cairo_create(lock_cst);</a>
<a name="ln260">  cairo_set_source_rgb(lock_cr, 0.7, 0.7, 0.7);</a>
<a name="ln261">  dtgtk_cairo_paint_lock(lock_cr, 0, 0, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE), 0, NULL);</a>
<a name="ln262">  cairo_surface_flush(lock_cst);</a>
<a name="ln263">  guchar *data = cairo_image_surface_get_data(lock_cst);</a>
<a name="ln264">  dt_draw_cairo_to_gdk_pixbuf(data, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln265">  GdkPixbuf *lock_pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,</a>
<a name="ln266">                                                    DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln267">                                                    cairo_image_surface_get_stride(lock_cst),</a>
<a name="ln268">                                                    cairo_destroy_from_pixbuf, lock_cr);</a>
<a name="ln269"> </a>
<a name="ln270">  // check mark</a>
<a name="ln271">  cairo_surface_t *check_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln272">                                                          DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln273">  cairo_t *check_cr = cairo_create(check_cst);</a>
<a name="ln274">  cairo_set_source_rgb(check_cr, 0.7, 0.7, 0.7);</a>
<a name="ln275">  dtgtk_cairo_paint_check_mark(check_cr, 0, 0, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE), 0, NULL);</a>
<a name="ln276">  cairo_surface_flush(check_cst);</a>
<a name="ln277">  data = cairo_image_surface_get_data(check_cst);</a>
<a name="ln278">  dt_draw_cairo_to_gdk_pixbuf(data, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln279">  GdkPixbuf *check_pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,</a>
<a name="ln280">                                                     DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln281">                                                     cairo_image_surface_get_stride(check_cst),</a>
<a name="ln282">                                                     cairo_destroy_from_pixbuf, check_cr);</a>
<a name="ln283"> </a>
<a name="ln284">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln285">                              &quot;SELECT rowid, name, operation, autoapply, model, maker, lens, iso_min, &quot;</a>
<a name="ln286">                              &quot;iso_max, exposure_min, exposure_max, aperture_min, aperture_max, &quot;</a>
<a name="ln287">                              &quot;focal_length_min, focal_length_max, writeprotect FROM data.presets ORDER BY &quot;</a>
<a name="ln288">                              &quot;operation, name&quot;,</a>
<a name="ln289">                              -1, &amp;stmt, NULL);</a>
<a name="ln290">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln291">  {</a>
<a name="ln292">    const gint rowid = sqlite3_column_int(stmt, 0);</a>
<a name="ln293">    const gchar *name = (gchar *)sqlite3_column_text(stmt, 1);</a>
<a name="ln294">    const gchar *operation = (gchar *)sqlite3_column_text(stmt, 2);</a>
<a name="ln295">    const gboolean autoapply = (sqlite3_column_int(stmt, 3) == 0 ? FALSE : TRUE);</a>
<a name="ln296">    const gchar *model = (gchar *)sqlite3_column_text(stmt, 4);</a>
<a name="ln297">    const gchar *maker = (gchar *)sqlite3_column_text(stmt, 5);</a>
<a name="ln298">    const gchar *lens = (gchar *)sqlite3_column_text(stmt, 6);</a>
<a name="ln299">    const float iso_min = sqlite3_column_double(stmt, 7);</a>
<a name="ln300">    const float iso_max = sqlite3_column_double(stmt, 8);</a>
<a name="ln301">    const float exposure_min = sqlite3_column_double(stmt, 9);</a>
<a name="ln302">    const float exposure_max = sqlite3_column_double(stmt, 10);</a>
<a name="ln303">    const float aperture_min = sqlite3_column_double(stmt, 11);</a>
<a name="ln304">    const float aperture_max = sqlite3_column_double(stmt, 12);</a>
<a name="ln305">    const int focal_length_min = sqlite3_column_double(stmt, 13);</a>
<a name="ln306">    const int focal_length_max = sqlite3_column_double(stmt, 14);</a>
<a name="ln307">    const gboolean writeprotect = (sqlite3_column_int(stmt, 15) == 0 ? FALSE : TRUE);</a>
<a name="ln308"> </a>
<a name="ln309">    gchar *iso = NULL, *exposure = NULL, *aperture = NULL, *focal_length = NULL;</a>
<a name="ln310">    int min, max;</a>
<a name="ln311"> </a>
<a name="ln312">    gchar *module = g_strdup(dt_iop_get_localized_name(operation));</a>
<a name="ln313">    if(module == NULL) module = g_strdup(dt_lib_get_localized_name(operation));</a>
<a name="ln314">    if(module == NULL) module = g_strdup(operation);</a>
<a name="ln315"> </a>
<a name="ln316">    if(iso_min == 0.0 &amp;&amp; iso_max == FLT_MAX)</a>
<a name="ln317">      iso = g_strdup(&quot;%&quot;);</a>
<a name="ln318">    else</a>
<a name="ln319">      iso = g_strdup_printf(&quot;%zu – %zu&quot;, (size_t)iso_min, (size_t)iso_max);</a>
<a name="ln320"> </a>
<a name="ln321">    min = 0, max = 0;</a>
<a name="ln322">    for(; min &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; exposure_min &gt; dt_gui_presets_exposure_value[min]; min++)</a>
<a name="ln323">      ;</a>
<a name="ln324">    for(; max &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; exposure_max &gt; dt_gui_presets_exposure_value[max]; max++)</a>
<a name="ln325">      ;</a>
<a name="ln326">    if(min == 0 &amp;&amp; max == dt_gui_presets_exposure_value_cnt - 1)</a>
<a name="ln327">      exposure = g_strdup(&quot;%&quot;);</a>
<a name="ln328">    else</a>
<a name="ln329">      exposure = g_strdup_printf(&quot;%s – %s&quot;, dt_gui_presets_exposure_value_str[min],</a>
<a name="ln330">                                 dt_gui_presets_exposure_value_str[max]);</a>
<a name="ln331"> </a>
<a name="ln332">    min = 0, max = 0;</a>
<a name="ln333">    for(; min &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; aperture_min &gt; dt_gui_presets_aperture_value[min]; min++)</a>
<a name="ln334">      ;</a>
<a name="ln335">    for(; max &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; aperture_max &gt; dt_gui_presets_aperture_value[max]; max++)</a>
<a name="ln336">      ;</a>
<a name="ln337">    if(min == 0 &amp;&amp; max == dt_gui_presets_aperture_value_cnt - 1)</a>
<a name="ln338">      aperture = g_strdup(&quot;%&quot;);</a>
<a name="ln339">    else</a>
<a name="ln340">      aperture = g_strdup_printf(&quot;%s – %s&quot;, dt_gui_presets_aperture_value_str[min],</a>
<a name="ln341">                                 dt_gui_presets_aperture_value_str[max]);</a>
<a name="ln342"> </a>
<a name="ln343">    if(focal_length_min == 0.0 &amp;&amp; focal_length_max == 1000.0)</a>
<a name="ln344">      focal_length = g_strdup(&quot;%&quot;);</a>
<a name="ln345">    else</a>
<a name="ln346">      focal_length = g_strdup_printf(&quot;%d – %d&quot;, focal_length_min, focal_length_max);</a>
<a name="ln347"> </a>
<a name="ln348">    if(g_strcmp0(last_module, operation) != 0)</a>
<a name="ln349">    {</a>
<a name="ln350">      gtk_tree_store_append(tree_model, &amp;iter, NULL);</a>
<a name="ln351">      gtk_tree_store_set(tree_model, &amp;iter, P_ROWID_COLUMN, 0, P_OPERATION_COLUMN, &quot;&quot;, P_MODULE_COLUMN,</a>
<a name="ln352">                         _(module), P_EDITABLE_COLUMN, NULL, P_NAME_COLUMN, &quot;&quot;, P_MODEL_COLUMN, &quot;&quot;,</a>
<a name="ln353">                         P_MAKER_COLUMN, &quot;&quot;, P_LENS_COLUMN, &quot;&quot;, P_ISO_COLUMN, &quot;&quot;, P_EXPOSURE_COLUMN, &quot;&quot;,</a>
<a name="ln354">                         P_APERTURE_COLUMN, &quot;&quot;, P_FOCAL_LENGTH_COLUMN, &quot;&quot;, P_AUTOAPPLY_COLUMN, NULL, -1);</a>
<a name="ln355">      g_free(last_module);</a>
<a name="ln356">      last_module = g_strdup(operation);</a>
<a name="ln357">      parent = iter;</a>
<a name="ln358">    }</a>
<a name="ln359"> </a>
<a name="ln360">    gtk_tree_store_append(tree_model, &amp;iter, &amp;parent);</a>
<a name="ln361">    gtk_tree_store_set(tree_model, &amp;iter, P_ROWID_COLUMN, rowid, P_OPERATION_COLUMN, operation,</a>
<a name="ln362">                       P_MODULE_COLUMN, &quot;&quot;, P_EDITABLE_COLUMN, writeprotect ? lock_pixbuf : NULL,</a>
<a name="ln363">                       P_NAME_COLUMN, name, P_MODEL_COLUMN, model, P_MAKER_COLUMN, maker, P_LENS_COLUMN, lens,</a>
<a name="ln364">                       P_ISO_COLUMN, iso, P_EXPOSURE_COLUMN, exposure, P_APERTURE_COLUMN, aperture,</a>
<a name="ln365">                       P_FOCAL_LENGTH_COLUMN, focal_length, P_AUTOAPPLY_COLUMN,</a>
<a name="ln366">                       autoapply ? check_pixbuf : NULL, -1);</a>
<a name="ln367"> </a>
<a name="ln368">    g_free(focal_length);</a>
<a name="ln369">    g_free(aperture);</a>
<a name="ln370">    g_free(exposure);</a>
<a name="ln371">    g_free(iso);</a>
<a name="ln372">    g_free(module);</a>
<a name="ln373">  }</a>
<a name="ln374">  g_free(last_module);</a>
<a name="ln375">  sqlite3_finalize(stmt);</a>
<a name="ln376"> </a>
<a name="ln377">  g_object_unref(lock_pixbuf);</a>
<a name="ln378">  cairo_surface_destroy(lock_cst);</a>
<a name="ln379">  g_object_unref(check_pixbuf);</a>
<a name="ln380">  cairo_surface_destroy(check_cst);</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">static void init_tab_presets(GtkWidget *book)</a>
<a name="ln384">{</a>
<a name="ln385">  GtkWidget *container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln386">  GtkWidget *scroll = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln387">  GtkWidget *tree = gtk_tree_view_new();</a>
<a name="ln388">  GtkTreeStore *model = gtk_tree_store_new(</a>
<a name="ln389">      P_N_COLUMNS, G_TYPE_INT /*rowid*/, G_TYPE_STRING /*operation*/, G_TYPE_STRING /*module*/,</a>
<a name="ln390">      GDK_TYPE_PIXBUF /*editable*/, G_TYPE_STRING /*name*/, G_TYPE_STRING /*model*/, G_TYPE_STRING /*maker*/,</a>
<a name="ln391">      G_TYPE_STRING /*lens*/, G_TYPE_STRING /*iso*/, G_TYPE_STRING /*exposure*/, G_TYPE_STRING /*aperture*/,</a>
<a name="ln392">      G_TYPE_STRING /*focal length*/, GDK_TYPE_PIXBUF /*auto*/);</a>
<a name="ln393">  GtkCellRenderer *renderer;</a>
<a name="ln394">  GtkTreeViewColumn *column;</a>
<a name="ln395"> </a>
<a name="ln396">  // Adding the outer container</a>
<a name="ln397">  gtk_widget_set_margin_top(scroll, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln398">  gtk_widget_set_margin_bottom(scroll, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln399">  gtk_widget_set_margin_start(scroll, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln400">  gtk_widget_set_margin_end(scroll, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln401">  gtk_notebook_append_page(GTK_NOTEBOOK(book), container, gtk_label_new(_(&quot;presets&quot;)));</a>
<a name="ln402"> </a>
<a name="ln403">  tree_insert_presets(model);</a>
<a name="ln404"> </a>
<a name="ln405">  // Setting a custom sort functions so expandable groups rise to the top</a>
<a name="ln406">  gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(model), P_MODULE_COLUMN, GTK_SORT_ASCENDING);</a>
<a name="ln407">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model), P_MODULE_COLUMN, compare_rows_presets, NULL, NULL);</a>
<a name="ln408"> </a>
<a name="ln409">  // Setting up the cell renderers</a>
<a name="ln410">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln411">  column = gtk_tree_view_column_new_with_attributes(_(&quot;module&quot;), renderer, &quot;text&quot;, P_MODULE_COLUMN, NULL);</a>
<a name="ln412">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln413"> </a>
<a name="ln414">  renderer = gtk_cell_renderer_pixbuf_new();</a>
<a name="ln415">  column = gtk_tree_view_column_new_with_attributes(&quot;&quot;, renderer, &quot;pixbuf&quot;, P_EDITABLE_COLUMN, NULL);</a>
<a name="ln416">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln417"> </a>
<a name="ln418">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln419">  column = gtk_tree_view_column_new_with_attributes(_(&quot;name&quot;), renderer, &quot;text&quot;, P_NAME_COLUMN, NULL);</a>
<a name="ln420">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln421"> </a>
<a name="ln422">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln423">  column = gtk_tree_view_column_new_with_attributes(_(&quot;model&quot;), renderer, &quot;text&quot;, P_MODEL_COLUMN, NULL);</a>
<a name="ln424">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln425"> </a>
<a name="ln426">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln427">  column = gtk_tree_view_column_new_with_attributes(_(&quot;maker&quot;), renderer, &quot;text&quot;, P_MAKER_COLUMN, NULL);</a>
<a name="ln428">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln429"> </a>
<a name="ln430">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln431">  column = gtk_tree_view_column_new_with_attributes(_(&quot;lens&quot;), renderer, &quot;text&quot;, P_LENS_COLUMN, NULL);</a>
<a name="ln432">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln433"> </a>
<a name="ln434">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln435">  column = gtk_tree_view_column_new_with_attributes(_(&quot;ISO&quot;), renderer, &quot;text&quot;, P_ISO_COLUMN, NULL);</a>
<a name="ln436">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln437"> </a>
<a name="ln438">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln439">  column = gtk_tree_view_column_new_with_attributes(_(&quot;exposure&quot;), renderer, &quot;text&quot;, P_EXPOSURE_COLUMN, NULL);</a>
<a name="ln440">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln441"> </a>
<a name="ln442">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln443">  column = gtk_tree_view_column_new_with_attributes(_(&quot;aperture&quot;), renderer, &quot;text&quot;, P_APERTURE_COLUMN, NULL);</a>
<a name="ln444">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln445"> </a>
<a name="ln446">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln447">  column = gtk_tree_view_column_new_with_attributes(_(&quot;focal length&quot;), renderer, &quot;text&quot;,</a>
<a name="ln448">                                                    P_FOCAL_LENGTH_COLUMN, NULL);</a>
<a name="ln449">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln450"> </a>
<a name="ln451">  renderer = gtk_cell_renderer_pixbuf_new();</a>
<a name="ln452">  column = gtk_tree_view_column_new_with_attributes(_(&quot;auto&quot;), renderer, &quot;pixbuf&quot;, P_AUTOAPPLY_COLUMN, NULL);</a>
<a name="ln453">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln454"> </a>
<a name="ln455">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln456">  gtk_box_pack_start(GTK_BOX(container), scroll, TRUE, TRUE, 0);</a>
<a name="ln457"> </a>
<a name="ln458">  // Adding the import/export buttons</a>
<a name="ln459">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln460"> </a>
<a name="ln461">  GtkWidget *button = gtk_button_new_with_label(C_(&quot;preferences&quot;, &quot;import&quot;));</a>
<a name="ln462">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln463">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_preset), (gpointer)model);</a>
<a name="ln464"> </a>
<a name="ln465">  gtk_box_pack_start(GTK_BOX(container), hbox, FALSE, FALSE, 0);</a>
<a name="ln466"> </a>
<a name="ln467">  // Attaching treeview signals</a>
<a name="ln468"> </a>
<a name="ln469">  // row-activated either expands/collapses a row or activates editing</a>
<a name="ln470">  g_signal_connect(G_OBJECT(tree), &quot;row-activated&quot;, G_CALLBACK(tree_row_activated_presets), NULL);</a>
<a name="ln471"> </a>
<a name="ln472">  // A keypress may delete preset</a>
<a name="ln473">  g_signal_connect(G_OBJECT(tree), &quot;key-press-event&quot;, G_CALLBACK(tree_key_press_presets), (gpointer)model);</a>
<a name="ln474"> </a>
<a name="ln475">  // Setting up the search functionality</a>
<a name="ln476">  gtk_tree_view_set_search_column(GTK_TREE_VIEW(tree), P_NAME_COLUMN);</a>
<a name="ln477">  gtk_tree_view_set_enable_search(GTK_TREE_VIEW(tree), TRUE);</a>
<a name="ln478"> </a>
<a name="ln479">  // Attaching the model to the treeview</a>
<a name="ln480">  gtk_tree_view_set_model(GTK_TREE_VIEW(tree), GTK_TREE_MODEL(model));</a>
<a name="ln481"> </a>
<a name="ln482">  // Adding the treeview to its containers</a>
<a name="ln483">  gtk_container_add(GTK_CONTAINER(scroll), tree);</a>
<a name="ln484">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln485"> </a>
<a name="ln486">  g_object_unref(G_OBJECT(model));</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">static void init_tab_accels(GtkWidget *book)</a>
<a name="ln490">{</a>
<a name="ln491">  GtkWidget *container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln492">  GtkWidget *scroll = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln493">  GtkWidget *tree = gtk_tree_view_new();</a>
<a name="ln494">  GtkWidget *button;</a>
<a name="ln495">  GtkWidget *hbox;</a>
<a name="ln496">  GtkTreeStore *model = gtk_tree_store_new(A_N_COLUMNS, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);</a>
<a name="ln497">  GtkCellRenderer *renderer;</a>
<a name="ln498">  GtkTreeViewColumn *column;</a>
<a name="ln499"> </a>
<a name="ln500">  // Adding the outer container</a>
<a name="ln501">  gtk_widget_set_margin_top(container, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln502">  gtk_widget_set_margin_bottom(container, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln503">  gtk_widget_set_margin_start(container, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln504">  gtk_widget_set_margin_end(container, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln505">  gtk_notebook_append_page(GTK_NOTEBOOK(book), container, gtk_label_new(_(&quot;shortcuts&quot;)));</a>
<a name="ln506"> </a>
<a name="ln507">  // Building the accelerator tree</a>
<a name="ln508">  g_slist_foreach(darktable.control-&gt;accelerator_list, tree_insert_accel, (gpointer)model);</a>
<a name="ln509"> </a>
<a name="ln510">  // Setting a custom sort functions so expandable groups rise to the top</a>
<a name="ln511">  gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(model), A_TRANS_COLUMN, GTK_SORT_ASCENDING);</a>
<a name="ln512">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model), A_TRANS_COLUMN, compare_rows_accels, NULL, NULL);</a>
<a name="ln513"> </a>
<a name="ln514">  // Setting up the cell renderers</a>
<a name="ln515">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln516">  column = gtk_tree_view_column_new_with_attributes(_(&quot;shortcut&quot;), renderer, &quot;text&quot;, A_TRANS_COLUMN, NULL);</a>
<a name="ln517">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln518"> </a>
<a name="ln519">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln520">  column = gtk_tree_view_column_new_with_attributes(_(&quot;binding&quot;), renderer, &quot;text&quot;, A_BINDING_COLUMN, NULL);</a>
<a name="ln521">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln522"> </a>
<a name="ln523">  // Attaching treeview signals</a>
<a name="ln524"> </a>
<a name="ln525">  // row-activated either expands/collapses a row or activates remapping</a>
<a name="ln526">  g_signal_connect(G_OBJECT(tree), &quot;row-activated&quot;, G_CALLBACK(tree_row_activated_accels), NULL);</a>
<a name="ln527"> </a>
<a name="ln528">  // A selection change will cancel a currently active remapping</a>
<a name="ln529">  g_signal_connect(G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(tree))), &quot;changed&quot;,</a>
<a name="ln530">                   G_CALLBACK(tree_selection_changed), NULL);</a>
<a name="ln531"> </a>
<a name="ln532">  // A keypress may remap an accel or delete one</a>
<a name="ln533">  g_signal_connect(G_OBJECT(tree), &quot;key-press-event&quot;, G_CALLBACK(tree_key_press), (gpointer)model);</a>
<a name="ln534"> </a>
<a name="ln535">  // Setting up the search functionality</a>
<a name="ln536">  gtk_tree_view_set_search_column(GTK_TREE_VIEW(tree), A_TRANS_COLUMN);</a>
<a name="ln537">  gtk_tree_view_set_search_equal_func(GTK_TREE_VIEW(tree), prefix_search, NULL, NULL);</a>
<a name="ln538">  gtk_tree_view_set_enable_search(GTK_TREE_VIEW(tree), TRUE);</a>
<a name="ln539"> </a>
<a name="ln540">  // Attaching the model to the treeview</a>
<a name="ln541">  gtk_tree_view_set_model(GTK_TREE_VIEW(tree), GTK_TREE_MODEL(model));</a>
<a name="ln542"> </a>
<a name="ln543">  // Adding the treeview to its containers</a>
<a name="ln544">  gtk_container_add(GTK_CONTAINER(scroll), tree);</a>
<a name="ln545">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln546">  gtk_box_pack_start(GTK_BOX(container), scroll, TRUE, TRUE, 0);</a>
<a name="ln547"> </a>
<a name="ln548">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln549"> </a>
<a name="ln550">  // Adding the restore defaults button</a>
<a name="ln551">  button = gtk_button_new_with_label(C_(&quot;preferences&quot;, &quot;default&quot;));</a>
<a name="ln552">  gtk_box_pack_end(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln553">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(restore_defaults), NULL);</a>
<a name="ln554">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(update_accels_model), (gpointer)model);</a>
<a name="ln555"> </a>
<a name="ln556">  // Adding the import/export buttons</a>
<a name="ln557"> </a>
<a name="ln558">  button = gtk_button_new_with_label(C_(&quot;preferences&quot;, &quot;import&quot;));</a>
<a name="ln559">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln560">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_export), (gpointer)0);</a>
<a name="ln561">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(update_accels_model), (gpointer)model);</a>
<a name="ln562"> </a>
<a name="ln563">  button = gtk_button_new_with_label(_(&quot;export&quot;));</a>
<a name="ln564">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln565">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_export), (gpointer)1);</a>
<a name="ln566"> </a>
<a name="ln567">  gtk_box_pack_start(GTK_BOX(container), hbox, FALSE, FALSE, 0);</a>
<a name="ln568"> </a>
<a name="ln569">  g_object_unref(G_OBJECT(model));</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">static void tree_insert_accel(gpointer accel_struct, gpointer model_link)</a>
<a name="ln573">{</a>
<a name="ln574">  GtkTreeStore *model = (GtkTreeStore *)model_link;</a>
<a name="ln575">  dt_accel_t *accel = (dt_accel_t *)accel_struct;</a>
<a name="ln576">  GtkAccelKey key;</a>
<a name="ln577"> </a>
<a name="ln578">  // Getting the first significant parts of the paths</a>
<a name="ln579">  const char *accel_path = accel-&gt;path;</a>
<a name="ln580">  const char *translated_path = accel-&gt;translated_path;</a>
<a name="ln581"> </a>
<a name="ln582">  /* if prefixed lets forward pointer */</a>
<a name="ln583">  if(!strncmp(accel_path, &quot;&lt;Darktable&gt;&quot;, strlen(&quot;&lt;Darktable&gt;&quot;)))</a>
<a name="ln584">  {</a>
<a name="ln585">    accel_path += strlen(&quot;&lt;Darktable&gt;&quot;) + 1;</a>
<a name="ln586">    translated_path += strlen(&quot;&lt;Darktable&gt;&quot;) + 1;</a>
<a name="ln587">  }</a>
<a name="ln588"> </a>
<a name="ln589">  // Getting the accelerator keys</a>
<a name="ln590">  gtk_accel_map_lookup_entry(accel-&gt;path, &amp;key);</a>
<a name="ln591"> </a>
<a name="ln592">  /* lets recurse path */</a>
<a name="ln593">  tree_insert_rec(model, NULL, accel_path, translated_path, key.accel_key, key.accel_mods);</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">static void tree_insert_rec(GtkTreeStore *model, GtkTreeIter *parent, const gchar *accel_path,</a>
<a name="ln597">                            const gchar *translated_path, guint accel_key, GdkModifierType accel_mods)</a>
<a name="ln598">{</a>
<a name="ln599">  int i;</a>
<a name="ln600">  gboolean found = FALSE;</a>
<a name="ln601">  gchar *val_str;</a>
<a name="ln602">  GtkTreeIter iter;</a>
<a name="ln603"> </a>
<a name="ln604">  /* if we are on end of path lets bail out of recursive insert */</a>
<a name="ln605">  if(*accel_path == 0) return;</a>
<a name="ln606"> </a>
<a name="ln607">  /* check if we are on a leaf or a branch  */</a>
<a name="ln608">  if(!g_strrstr(accel_path, &quot;/&quot;))</a>
<a name="ln609">  {</a>
<a name="ln610">    /* we are on a leaf lets add */</a>
<a name="ln611">    gchar *name = gtk_accelerator_get_label(accel_key, accel_mods);</a>
<a name="ln612">    gtk_tree_store_append(model, &amp;iter, parent);</a>
<a name="ln613">    gtk_tree_store_set(model, &amp;iter, A_ACCEL_COLUMN, accel_path, A_BINDING_COLUMN,</a>
<a name="ln614">                       g_dpgettext2(&quot;gtk30&quot;, &quot;keyboard label&quot;, name), A_TRANS_COLUMN, translated_path, -1);</a>
<a name="ln615">    g_free(name);</a>
<a name="ln616">  }</a>
<a name="ln617">  else</a>
<a name="ln618">  {</a>
<a name="ln619">    /* we are on a branch let's get the node name */</a>
<a name="ln620">    const gchar *end = g_strstr_len(accel_path, strlen(accel_path), &quot;/&quot;);</a>
<a name="ln621">    const gchar *trans_end = g_strstr_len(translated_path, strlen(translated_path), &quot;/&quot;);</a>
<a name="ln622">    gchar *node = g_strndup(accel_path, end - accel_path);</a>
<a name="ln623">    gchar *trans_node;</a>
<a name="ln624">    // safeguard against broken translations</a>
<a name="ln625">    if(trans_end)</a>
<a name="ln626">      trans_node = g_strndup(translated_path, trans_end - translated_path);</a>
<a name="ln627">    else</a>
<a name="ln628">    {</a>
<a name="ln629">      fprintf(stderr, &quot;error: translation mismatch: `%s' vs. `%s'\n&quot;, accel_path, translated_path);</a>
<a name="ln630">      trans_node = g_strdup(node);</a>
<a name="ln631">      translated_path = accel_path;</a>
<a name="ln632">    }</a>
<a name="ln633"> </a>
<a name="ln634">    /* search the tree if we alread have an sibling with node name */</a>
<a name="ln635">    int siblings = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(model), parent);</a>
<a name="ln636">    for(i = 0; i &lt; siblings; i++)</a>
<a name="ln637">    {</a>
<a name="ln638">      gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(model), &amp;iter, parent, i);</a>
<a name="ln639">      gtk_tree_model_get(GTK_TREE_MODEL(model), &amp;iter, A_ACCEL_COLUMN, &amp;val_str, -1);</a>
<a name="ln640"> </a>
<a name="ln641">      /* do we match current sibling */</a>
<a name="ln642">      if(!strcmp(val_str, node)) found = TRUE;</a>
<a name="ln643"> </a>
<a name="ln644">      g_free(val_str);</a>
<a name="ln645"> </a>
<a name="ln646">      /* if we found a matching node let's break out */</a>
<a name="ln647">      if(found) break;</a>
<a name="ln648">    }</a>
<a name="ln649"> </a>
<a name="ln650">    /* if not found let's add a branch */</a>
<a name="ln651">    if(!found)</a>
<a name="ln652">    {</a>
<a name="ln653">      gtk_tree_store_append(model, &amp;iter, parent);</a>
<a name="ln654">      gtk_tree_store_set(model, &amp;iter, A_ACCEL_COLUMN, node, A_BINDING_COLUMN, &quot;&quot;, A_TRANS_COLUMN, trans_node,</a>
<a name="ln655">                         -1);</a>
<a name="ln656">    }</a>
<a name="ln657"> </a>
<a name="ln658">    /* recurse further down the path */</a>
<a name="ln659">    tree_insert_rec(model, &amp;iter, accel_path + strlen(node) + 1, translated_path + strlen(trans_node) + 1,</a>
<a name="ln660">                    accel_key, accel_mods);</a>
<a name="ln661"> </a>
<a name="ln662">    /* free up data */</a>
<a name="ln663">    g_free(node);</a>
<a name="ln664">    g_free(trans_node);</a>
<a name="ln665">  }</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668">static void path_to_accel(GtkTreeModel *model, GtkTreePath *path, gchar *str, size_t str_len)</a>
<a name="ln669">{</a>
<a name="ln670">  gint depth;</a>
<a name="ln671">  gint *indices;</a>
<a name="ln672">  GtkTreeIter parent;</a>
<a name="ln673">  GtkTreeIter child;</a>
<a name="ln674">  gint i;</a>
<a name="ln675">  gchar *data_str;</a>
<a name="ln676"> </a>
<a name="ln677">  // Start out with the base &lt;Darktable&gt;</a>
<a name="ln678">  g_strlcpy(str, &quot;&lt;Darktable&gt;&quot;, str_len);</a>
<a name="ln679"> </a>
<a name="ln680">  // For each index in the path, append a '/' and that section of the path</a>
<a name="ln681">  depth = gtk_tree_path_get_depth(path);</a>
<a name="ln682">  indices = gtk_tree_path_get_indices(path);</a>
<a name="ln683">  for(i = 0; i &lt; depth; i++)</a>
<a name="ln684">  {</a>
<a name="ln685">    g_strlcat(str, &quot;/&quot;, str_len);</a>
<a name="ln686">    gtk_tree_model_iter_nth_child(model, &amp;child, i == 0 ? NULL : &amp;parent, indices[i]);</a>
<a name="ln687">    gtk_tree_model_get(model, &amp;child, A_ACCEL_COLUMN, &amp;data_str, -1);</a>
<a name="ln688">    g_strlcat(str, data_str, str_len);</a>
<a name="ln689">    g_free(data_str);</a>
<a name="ln690">    parent = child;</a>
<a name="ln691">  }</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694">static void update_accels_model(gpointer widget, gpointer data)</a>
<a name="ln695">{</a>
<a name="ln696">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln697">  GtkTreeIter iter;</a>
<a name="ln698">  gchar path[256];</a>
<a name="ln699">  gchar *end;</a>
<a name="ln700">  gint i;</a>
<a name="ln701"> </a>
<a name="ln702">  g_strlcpy(path, &quot;&lt;Darktable&gt;&quot;, sizeof(path));</a>
<a name="ln703">  end = path + strlen(path);</a>
<a name="ln704"> </a>
<a name="ln705">  for(i = 0; i &lt; gtk_tree_model_iter_n_children(model, NULL); i++)</a>
<a name="ln706">  {</a>
<a name="ln707">    gtk_tree_model_iter_nth_child(model, &amp;iter, NULL, i);</a>
<a name="ln708">    update_accels_model_rec(model, &amp;iter, path, sizeof(path));</a>
<a name="ln709">    *end = '\0'; // Trimming the string back to the base for the next iteration</a>
<a name="ln710">  }</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">static void update_accels_model_rec(GtkTreeModel *model, GtkTreeIter *parent, gchar *path, size_t path_len)</a>
<a name="ln714">{</a>
<a name="ln715">  GtkAccelKey key;</a>
<a name="ln716">  GtkTreeIter iter;</a>
<a name="ln717">  gchar *str_data;</a>
<a name="ln718">  gchar *end;</a>
<a name="ln719">  gint i;</a>
<a name="ln720"> </a>
<a name="ln721">  // First concatenating this part of the key</a>
<a name="ln722">  g_strlcat(path, &quot;/&quot;, path_len);</a>
<a name="ln723">  gtk_tree_model_get(model, parent, A_ACCEL_COLUMN, &amp;str_data, -1);</a>
<a name="ln724">  g_strlcat(path, str_data, path_len);</a>
<a name="ln725">  g_free(str_data);</a>
<a name="ln726"> </a>
<a name="ln727">  if(gtk_tree_model_iter_has_child(model, parent))</a>
<a name="ln728">  {</a>
<a name="ln729">    // Branch node, carry on with recursion</a>
<a name="ln730">    end = path + strlen(path);</a>
<a name="ln731"> </a>
<a name="ln732">    for(i = 0; i &lt; gtk_tree_model_iter_n_children(model, parent); i++)</a>
<a name="ln733">    {</a>
<a name="ln734">      gtk_tree_model_iter_nth_child(model, &amp;iter, parent, i);</a>
<a name="ln735">      update_accels_model_rec(model, &amp;iter, path, path_len);</a>
<a name="ln736">      *end = '\0';</a>
<a name="ln737">    }</a>
<a name="ln738">  }</a>
<a name="ln739">  else</a>
<a name="ln740">  {</a>
<a name="ln741">    // Leaf node, update the text</a>
<a name="ln742"> </a>
<a name="ln743">    gtk_accel_map_lookup_entry(path, &amp;key);</a>
<a name="ln744">    gchar *name = gtk_accelerator_get_label(key.accel_key, key.accel_mods);</a>
<a name="ln745">    gtk_tree_store_set(GTK_TREE_STORE(model), parent, A_BINDING_COLUMN, name, -1);</a>
<a name="ln746">    g_free(name);</a>
<a name="ln747">  }</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">static void delete_matching_accels(gpointer current, gpointer mapped)</a>
<a name="ln751">{</a>
<a name="ln752">  const dt_accel_t *current_accel = (dt_accel_t *)current;</a>
<a name="ln753">  const dt_accel_t *mapped_accel = (dt_accel_t *)mapped;</a>
<a name="ln754">  GtkAccelKey current_key;</a>
<a name="ln755">  GtkAccelKey mapped_key;</a>
<a name="ln756"> </a>
<a name="ln757">  // Make sure we're not deleting the key we just remapped</a>
<a name="ln758">  if(!strcmp(current_accel-&gt;path, mapped_accel-&gt;path)) return;</a>
<a name="ln759"> </a>
<a name="ln760">  // Finding the relevant keyboard shortcuts</a>
<a name="ln761">  gtk_accel_map_lookup_entry(current_accel-&gt;path, &amp;current_key);</a>
<a name="ln762">  gtk_accel_map_lookup_entry(mapped_accel-&gt;path, &amp;mapped_key);</a>
<a name="ln763"> </a>
<a name="ln764">  if(current_key.accel_key == mapped_key.accel_key                 // Key code matches</a>
<a name="ln765">     &amp;&amp; current_key.accel_mods == mapped_key.accel_mods            // Key state matches</a>
<a name="ln766">     &amp;&amp; !(current_accel-&gt;local &amp;&amp; mapped_accel-&gt;local              // Not both local to</a>
<a name="ln767">          &amp;&amp; strcmp(current_accel-&gt;module, mapped_accel-&gt;module))) // diff mods</a>
<a name="ln768">    gtk_accel_map_change_entry(current_accel-&gt;path, 0, 0, TRUE);</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">static gint _accelcmp(gconstpointer a, gconstpointer b)</a>
<a name="ln772">{</a>
<a name="ln773">  return (gint)(strcmp(((dt_accel_t *)a)-&gt;path, ((dt_accel_t *)b)-&gt;path));</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">// TODO: remember which sections were collapsed/expanded and where the view was scrolled to and restore that</a>
<a name="ln777">// after editing is done</a>
<a name="ln778">//      Alternative: change edit_preset_response to not clear+refill the tree, but to update the single row</a>
<a name="ln779">//      which changed.</a>
<a name="ln780">static void tree_row_activated_presets(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln781">                                       gpointer data)</a>
<a name="ln782">{</a>
<a name="ln783">  GtkTreeIter iter;</a>
<a name="ln784">  GtkTreeModel *model = gtk_tree_view_get_model(tree);</a>
<a name="ln785"> </a>
<a name="ln786">  gtk_tree_model_get_iter(model, &amp;iter, path);</a>
<a name="ln787"> </a>
<a name="ln788">  if(gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln789">  {</a>
<a name="ln790">    // For branch nodes, toggle expansion on activation</a>
<a name="ln791">    if(gtk_tree_view_row_expanded(tree, path))</a>
<a name="ln792">      gtk_tree_view_collapse_row(tree, path);</a>
<a name="ln793">    else</a>
<a name="ln794">      gtk_tree_view_expand_row(tree, path, FALSE);</a>
<a name="ln795">  }</a>
<a name="ln796">  else</a>
<a name="ln797">  {</a>
<a name="ln798">    // For leaf nodes, open editing window if the preset is not writeprotected</a>
<a name="ln799">    gint rowid;</a>
<a name="ln800">    gchar *name, *operation;</a>
<a name="ln801">    GdkPixbuf *editable;</a>
<a name="ln802">    gtk_tree_model_get(model, &amp;iter, P_ROWID_COLUMN, &amp;rowid, P_NAME_COLUMN, &amp;name, P_OPERATION_COLUMN,</a>
<a name="ln803">                       &amp;operation, P_EDITABLE_COLUMN, &amp;editable, -1);</a>
<a name="ln804">    if(editable == NULL)</a>
<a name="ln805">      edit_preset(tree, rowid, name, operation);</a>
<a name="ln806">    else</a>
<a name="ln807">      g_object_unref(editable);</a>
<a name="ln808">    g_free(name);</a>
<a name="ln809">    g_free(operation);</a>
<a name="ln810">  }</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">static void tree_row_activated_accels(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln814">                                      gpointer data)</a>
<a name="ln815">{</a>
<a name="ln816">  GtkTreeIter iter;</a>
<a name="ln817">  GtkTreeModel *model = gtk_tree_view_get_model(tree);</a>
<a name="ln818"> </a>
<a name="ln819">  static gchar accel_path[256];</a>
<a name="ln820"> </a>
<a name="ln821">  gtk_tree_model_get_iter(model, &amp;iter, path);</a>
<a name="ln822"> </a>
<a name="ln823">  if(gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln824">  {</a>
<a name="ln825">    // For branch nodes, toggle expansion on activation</a>
<a name="ln826">    if(gtk_tree_view_row_expanded(tree, path))</a>
<a name="ln827">      gtk_tree_view_collapse_row(tree, path);</a>
<a name="ln828">    else</a>
<a name="ln829">      gtk_tree_view_expand_row(tree, path, FALSE);</a>
<a name="ln830">  }</a>
<a name="ln831">  else</a>
<a name="ln832">  {</a>
<a name="ln833">    // For leaf nodes, enter remapping mode</a>
<a name="ln834"> </a>
<a name="ln835">    // Assembling the full accelerator path</a>
<a name="ln836">    path_to_accel(model, path, accel_path, sizeof(accel_path));</a>
<a name="ln837"> </a>
<a name="ln838">    // Setting the notification text</a>
<a name="ln839">    gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, A_BINDING_COLUMN, _(&quot;press key combination to remap...&quot;),</a>
<a name="ln840">                       -1);</a>
<a name="ln841"> </a>
<a name="ln842">    // Activating remapping</a>
<a name="ln843">    darktable.control-&gt;accel_remap_str = accel_path;</a>
<a name="ln844">    darktable.control-&gt;accel_remap_path = gtk_tree_path_copy(path);</a>
<a name="ln845">  }</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848">static void tree_selection_changed(GtkTreeSelection *selection, gpointer data)</a>
<a name="ln849">{</a>
<a name="ln850">  GtkTreeModel *model;</a>
<a name="ln851">  GtkTreeIter iter;</a>
<a name="ln852"> </a>
<a name="ln853">  GtkAccelKey key;</a>
<a name="ln854"> </a>
<a name="ln855">  // If remapping is currently activated, it needs to be deactivated</a>
<a name="ln856">  if(!darktable.control-&gt;accel_remap_str) return;</a>
<a name="ln857"> </a>
<a name="ln858">  model = gtk_tree_view_get_model(gtk_tree_selection_get_tree_view(selection));</a>
<a name="ln859">  gtk_tree_model_get_iter(model, &amp;iter, darktable.control-&gt;accel_remap_path);</a>
<a name="ln860"> </a>
<a name="ln861">  // Restoring the A_BINDING_COLUMN text</a>
<a name="ln862">  gtk_accel_map_lookup_entry(darktable.control-&gt;accel_remap_str, &amp;key);</a>
<a name="ln863">  gchar *name = gtk_accelerator_get_label(key.accel_key, key.accel_mods);</a>
<a name="ln864">  gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, A_BINDING_COLUMN, name, -1);</a>
<a name="ln865">  g_free(name);</a>
<a name="ln866"> </a>
<a name="ln867">  // Cleaning up the darktable.gui info</a>
<a name="ln868">  darktable.control-&gt;accel_remap_str = NULL;</a>
<a name="ln869">  gtk_tree_path_free(darktable.control-&gt;accel_remap_path);</a>
<a name="ln870">  darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">static gboolean tree_key_press(GtkWidget *widget, GdkEventKey *event, gpointer data)</a>
<a name="ln874">{</a>
<a name="ln875">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln876">  GtkTreeIter iter;</a>
<a name="ln877">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(widget));</a>
<a name="ln878">  GtkTreePath *path;</a>
<a name="ln879">  GSList *remapped;</a>
<a name="ln880">  dt_accel_t query;</a>
<a name="ln881"> </a>
<a name="ln882">  gchar accel[256];</a>
<a name="ln883">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln884">  gchar accelpath[PATH_MAX] = { 0 };</a>
<a name="ln885"> </a>
<a name="ln886">  // We can just ignore mod key presses outright</a>
<a name="ln887">  if(event-&gt;is_modifier) return FALSE;</a>
<a name="ln888"> </a>
<a name="ln889">  dt_loc_get_user_config_dir(datadir, sizeof(datadir));</a>
<a name="ln890">  snprintf(accelpath, sizeof(accelpath), &quot;%s/keyboardrc&quot;, datadir);</a>
<a name="ln891"> </a>
<a name="ln892">  // Otherwise, determine whether we're in remap mode or not</a>
<a name="ln893">  if(darktable.control-&gt;accel_remap_str)</a>
<a name="ln894">  {</a>
<a name="ln895">    // Change the accel map entry</a>
<a name="ln896">    if(gtk_accel_map_change_entry(darktable.control-&gt;accel_remap_str, gdk_keyval_to_lower(event-&gt;keyval),</a>
<a name="ln897">                                  event-&gt;state &amp; KEY_STATE_MASK, TRUE))</a>
<a name="ln898">    {</a>
<a name="ln899">      // If it succeeded delete any conflicting accelerators</a>
<a name="ln900">      // First locate the accel list entry</a>
<a name="ln901">      g_strlcpy(query.path, darktable.control-&gt;accel_remap_str, sizeof(query.path));</a>
<a name="ln902">      remapped = g_slist_find_custom(darktable.control-&gt;accelerator_list, (gpointer)&amp;query, _accelcmp);</a>
<a name="ln903"> </a>
<a name="ln904">      // Then remove conflicts</a>
<a name="ln905">      g_slist_foreach(darktable.control-&gt;accelerator_list, delete_matching_accels, (gpointer)(remapped-&gt;data));</a>
<a name="ln906">    }</a>
<a name="ln907"> </a>
<a name="ln908"> </a>
<a name="ln909"> </a>
<a name="ln910">    // Then update the text in the A_BINDING_COLUMN of each row</a>
<a name="ln911">    update_accels_model(NULL, model);</a>
<a name="ln912"> </a>
<a name="ln913">    // Finally clear the remap state</a>
<a name="ln914">    darktable.control-&gt;accel_remap_str = NULL;</a>
<a name="ln915">    gtk_tree_path_free(darktable.control-&gt;accel_remap_path);</a>
<a name="ln916">    darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln917"> </a>
<a name="ln918">    // Save the changed keybindings</a>
<a name="ln919">    gtk_accel_map_save(accelpath);</a>
<a name="ln920"> </a>
<a name="ln921">    return TRUE;</a>
<a name="ln922">  }</a>
<a name="ln923">  else if(event-&gt;keyval == GDK_KEY_BackSpace)</a>
<a name="ln924">  {</a>
<a name="ln925">    // If a leaf node is selected, clear that accelerator</a>
<a name="ln926"> </a>
<a name="ln927">    // If nothing is selected, or branch node selected, just return</a>
<a name="ln928">    if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)</a>
<a name="ln929">       || gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln930">      return FALSE;</a>
<a name="ln931"> </a>
<a name="ln932">    // Otherwise, construct the proper accelerator path and delete its entry</a>
<a name="ln933">    g_strlcpy(accel, &quot;&lt;Darktable&gt;&quot;, sizeof(accel));</a>
<a name="ln934">    path = gtk_tree_model_get_path(model, &amp;iter);</a>
<a name="ln935">    path_to_accel(model, path, accel, sizeof(accel));</a>
<a name="ln936">    gtk_tree_path_free(path);</a>
<a name="ln937"> </a>
<a name="ln938">    gtk_accel_map_change_entry(accel, 0, 0, TRUE);</a>
<a name="ln939">    update_accels_model(NULL, model);</a>
<a name="ln940"> </a>
<a name="ln941">    // Saving the changed bindings</a>
<a name="ln942">    gtk_accel_map_save(accelpath);</a>
<a name="ln943"> </a>
<a name="ln944">    return TRUE;</a>
<a name="ln945">  }</a>
<a name="ln946">  else</a>
<a name="ln947">  {</a>
<a name="ln948">    return FALSE;</a>
<a name="ln949">  }</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">static gboolean tree_key_press_presets(GtkWidget *widget, GdkEventKey *event, gpointer data)</a>
<a name="ln953">{</a>
<a name="ln954"> </a>
<a name="ln955">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln956">  GtkTreeIter iter;</a>
<a name="ln957">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(widget));</a>
<a name="ln958"> </a>
<a name="ln959">  // We can just ignore mod key presses outright</a>
<a name="ln960">  if(event-&gt;is_modifier) return FALSE;</a>
<a name="ln961"> </a>
<a name="ln962">  if(event-&gt;keyval == GDK_KEY_Delete || event-&gt;keyval == GDK_KEY_BackSpace)</a>
<a name="ln963">  {</a>
<a name="ln964">    // If a leaf node is selected, delete that preset</a>
<a name="ln965"> </a>
<a name="ln966">    // If nothing is selected, or branch node selected, just return</a>
<a name="ln967">    if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)</a>
<a name="ln968">       || gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln969">      return FALSE;</a>
<a name="ln970"> </a>
<a name="ln971">    // For leaf nodes, open delete confirmation window if the preset is not writeprotected</a>
<a name="ln972">    gint rowid;</a>
<a name="ln973">    gchar *name;</a>
<a name="ln974">    GdkPixbuf *editable;</a>
<a name="ln975">    gtk_tree_model_get(model, &amp;iter, P_ROWID_COLUMN, &amp;rowid, P_NAME_COLUMN, &amp;name, P_EDITABLE_COLUMN,</a>
<a name="ln976">                       &amp;editable, -1);</a>
<a name="ln977">    if(editable == NULL)</a>
<a name="ln978">    {</a>
<a name="ln979">      sqlite3_stmt *stmt;</a>
<a name="ln980"> </a>
<a name="ln981">      GtkWidget *window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln982">      GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(window), GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln983">                                                 GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln984">                                                 _(&quot;do you really want to delete the preset `%s'?&quot;), name);</a>
<a name="ln985">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln986">      dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln987">#endif</a>
<a name="ln988">      gtk_window_set_title(GTK_WINDOW(dialog), _(&quot;delete preset?&quot;));</a>
<a name="ln989">      if(gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_YES)</a>
<a name="ln990">      {</a>
<a name="ln991">        // TODO: remove accel</a>
<a name="ln992">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln993">                                    &quot;DELETE FROM data.presets WHERE rowid=?1 AND writeprotect=0&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln994">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, rowid);</a>
<a name="ln995">        sqlite3_step(stmt);</a>
<a name="ln996">        sqlite3_finalize(stmt);</a>
<a name="ln997">        GtkTreeStore *tree_store = GTK_TREE_STORE(model);</a>
<a name="ln998">        gtk_tree_store_clear(tree_store);</a>
<a name="ln999">        tree_insert_presets(tree_store);</a>
<a name="ln1000">      }</a>
<a name="ln1001">      gtk_widget_destroy(dialog);</a>
<a name="ln1002">    }</a>
<a name="ln1003">    else</a>
<a name="ln1004">      g_object_unref(editable);</a>
<a name="ln1005">    g_free(name);</a>
<a name="ln1006"> </a>
<a name="ln1007">    return TRUE;</a>
<a name="ln1008">  }</a>
<a name="ln1009">  else</a>
<a name="ln1010">  {</a>
<a name="ln1011">    return FALSE;</a>
<a name="ln1012">  }</a>
<a name="ln1013">}</a>
<a name="ln1014"> </a>
<a name="ln1015">static void import_export(GtkButton *button, gpointer data)</a>
<a name="ln1016">{</a>
<a name="ln1017">  GtkWidget *chooser;</a>
<a name="ln1018">  gchar confdir[PATH_MAX] = { 0 };</a>
<a name="ln1019">  gchar accelpath[PATH_MAX] = { 0 };</a>
<a name="ln1020"> </a>
<a name="ln1021">  if(data)</a>
<a name="ln1022">  {</a>
<a name="ln1023">    // Non-zero value indicates export</a>
<a name="ln1024">    chooser = gtk_file_chooser_dialog_new(_(&quot;select file to export&quot;), NULL, GTK_FILE_CHOOSER_ACTION_SAVE,</a>
<a name="ln1025">                                          _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL, _(&quot;_save&quot;), GTK_RESPONSE_ACCEPT,</a>
<a name="ln1026">                                          NULL);</a>
<a name="ln1027">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1028">    dt_osx_disallow_fullscreen(chooser);</a>
<a name="ln1029">#endif</a>
<a name="ln1030">    gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(chooser), TRUE);</a>
<a name="ln1031">    gchar *exported_path = dt_conf_get_string(&quot;ui_last/exported_path&quot;);</a>
<a name="ln1032">    if(exported_path != NULL)</a>
<a name="ln1033">    {</a>
<a name="ln1034">      gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), exported_path);</a>
<a name="ln1035">      g_free(exported_path);</a>
<a name="ln1036">    }</a>
<a name="ln1037">    gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(chooser), &quot;keyboardrc&quot;);</a>
<a name="ln1038">    if(gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1039">    {</a>
<a name="ln1040">      gtk_accel_map_save(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)));</a>
<a name="ln1041">      gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(chooser));</a>
<a name="ln1042">      dt_conf_set_string(&quot;ui_last/export_path&quot;, folder);</a>
<a name="ln1043">      g_free(folder);</a>
<a name="ln1044">    }</a>
<a name="ln1045">    gtk_widget_destroy(chooser);</a>
<a name="ln1046">  }</a>
<a name="ln1047">  else</a>
<a name="ln1048">  {</a>
<a name="ln1049">    // Zero value indicates import</a>
<a name="ln1050">    chooser = gtk_file_chooser_dialog_new(_(&quot;select file to import&quot;), NULL, GTK_FILE_CHOOSER_ACTION_OPEN,</a>
<a name="ln1051">                                          _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT,</a>
<a name="ln1052">                                          NULL);</a>
<a name="ln1053">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1054">    dt_osx_disallow_fullscreen(chooser);</a>
<a name="ln1055">#endif</a>
<a name="ln1056"> </a>
<a name="ln1057">    gchar *import_path = dt_conf_get_string(&quot;ui_last/import_path&quot;);</a>
<a name="ln1058">    if(import_path != NULL)</a>
<a name="ln1059">    {</a>
<a name="ln1060">      gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), import_path);</a>
<a name="ln1061">      g_free(import_path);</a>
<a name="ln1062">    }</a>
<a name="ln1063">    if(gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1064">    {</a>
<a name="ln1065">      if(g_file_test(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)), G_FILE_TEST_EXISTS))</a>
<a name="ln1066">      {</a>
<a name="ln1067">        // Loading the file</a>
<a name="ln1068">        gtk_accel_map_load(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)));</a>
<a name="ln1069"> </a>
<a name="ln1070">        // Saving to the permanent keyboardrc</a>
<a name="ln1071">        dt_loc_get_user_config_dir(confdir, sizeof(confdir));</a>
<a name="ln1072">        snprintf(accelpath, sizeof(accelpath), &quot;%s/keyboardrc&quot;, confdir);</a>
<a name="ln1073">        gtk_accel_map_save(accelpath);</a>
<a name="ln1074"> </a>
<a name="ln1075">        gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(chooser));</a>
<a name="ln1076">        dt_conf_set_string(&quot;ui_last/import_path&quot;, folder);</a>
<a name="ln1077">        g_free(folder);</a>
<a name="ln1078">      }</a>
<a name="ln1079">    }</a>
<a name="ln1080">    gtk_widget_destroy(chooser);</a>
<a name="ln1081">  }</a>
<a name="ln1082">}</a>
<a name="ln1083"> </a>
<a name="ln1084">static void restore_defaults(GtkButton *button, gpointer data)</a>
<a name="ln1085">{</a>
<a name="ln1086">  GList *ops;</a>
<a name="ln1087">  dt_iop_module_so_t *op;</a>
<a name="ln1088">  gchar accelpath[256];</a>
<a name="ln1089">  gchar dir[PATH_MAX] = { 0 };</a>
<a name="ln1090">  gchar path[PATH_MAX] = { 0 };</a>
<a name="ln1091"> </a>
<a name="ln1092">  GtkWidget *message</a>
<a name="ln1093">      = gtk_message_dialog_new(NULL, GTK_DIALOG_MODAL, GTK_MESSAGE_WARNING, GTK_BUTTONS_OK_CANCEL,</a>
<a name="ln1094">                               _(&quot;are you sure you want to restore the default keybindings?  this will &quot;</a>
<a name="ln1095">                                 &quot;erase any modifications you have made.&quot;));</a>
<a name="ln1096">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1097">  dt_osx_disallow_fullscreen(message);</a>
<a name="ln1098">#endif</a>
<a name="ln1099">  if(gtk_dialog_run(GTK_DIALOG(message)) == GTK_RESPONSE_OK)</a>
<a name="ln1100">  {</a>
<a name="ln1101">    // First load the default keybindings for immediate effect</a>
<a name="ln1102">    dt_loc_get_user_config_dir(dir, sizeof(dir));</a>
<a name="ln1103">    snprintf(path, sizeof(path), &quot;%s/keyboardrc_default&quot;, dir);</a>
<a name="ln1104">    gtk_accel_map_load(path);</a>
<a name="ln1105"> </a>
<a name="ln1106">    // Now deleting any iop show shortcuts</a>
<a name="ln1107">    ops = darktable.iop;</a>
<a name="ln1108">    while(ops)</a>
<a name="ln1109">    {</a>
<a name="ln1110">      op = (dt_iop_module_so_t *)ops-&gt;data;</a>
<a name="ln1111">      snprintf(accelpath, sizeof(accelpath), &quot;&lt;Darktable&gt;/darkroom/modules/%s/show&quot;, op-&gt;op);</a>
<a name="ln1112">      gtk_accel_map_change_entry(accelpath, 0, 0, TRUE);</a>
<a name="ln1113">      ops = g_list_next(ops);</a>
<a name="ln1114">    }</a>
<a name="ln1115"> </a>
<a name="ln1116">    // Then delete any changes to the user's keyboardrc so it gets reset</a>
<a name="ln1117">    // on next startup</a>
<a name="ln1118">    dt_loc_get_user_config_dir(dir, sizeof(dir));</a>
<a name="ln1119">    snprintf(path, sizeof(path), &quot;%s/keyboardrc&quot;, dir);</a>
<a name="ln1120"> </a>
<a name="ln1121">    GFile *gpath = g_file_new_for_path(path);</a>
<a name="ln1122">    g_file_delete(gpath, NULL, NULL);</a>
<a name="ln1123">    g_object_unref(gpath);</a>
<a name="ln1124">  }</a>
<a name="ln1125">  gtk_widget_destroy(message);</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128">static void import_preset(GtkButton *button, gpointer data)</a>
<a name="ln1129">{</a>
<a name="ln1130">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln1131">  GtkWidget *chooser;</a>
<a name="ln1132"> </a>
<a name="ln1133">  // Zero value indicates import</a>
<a name="ln1134">  chooser = gtk_file_chooser_dialog_new(_(&quot;select preset to import&quot;), NULL, GTK_FILE_CHOOSER_ACTION_OPEN,</a>
<a name="ln1135">                                        _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT,</a>
<a name="ln1136">                                        NULL);</a>
<a name="ln1137">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1138">  dt_osx_disallow_fullscreen(chooser);</a>
<a name="ln1139">#endif</a>
<a name="ln1140"> </a>
<a name="ln1141">  gchar *import_path = dt_conf_get_string(&quot;ui_last/import_path&quot;);</a>
<a name="ln1142">  if(import_path != NULL)</a>
<a name="ln1143">  {</a>
<a name="ln1144">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), import_path);</a>
<a name="ln1145">    g_free(import_path);</a>
<a name="ln1146">  }</a>
<a name="ln1147">  if(gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1148">  {</a>
<a name="ln1149">    if(g_file_test(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)), G_FILE_TEST_EXISTS))</a>
<a name="ln1150">    {</a>
<a name="ln1151">      if(dt_presets_import_from_file(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser))))</a>
<a name="ln1152">      {</a>
<a name="ln1153">        dt_control_log(_(&quot;failed to import preset&quot;));</a>
<a name="ln1154">      }</a>
<a name="ln1155">      else</a>
<a name="ln1156">      {</a>
<a name="ln1157">        GtkTreeStore *tree_store = GTK_TREE_STORE(model);</a>
<a name="ln1158">        gtk_tree_store_clear(tree_store);</a>
<a name="ln1159">        tree_insert_presets(tree_store);</a>
<a name="ln1160">      }</a>
<a name="ln1161"> </a>
<a name="ln1162">      gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(chooser));</a>
<a name="ln1163">      dt_conf_set_string(&quot;ui_last/import_path&quot;, folder);</a>
<a name="ln1164">      g_free(folder);</a>
<a name="ln1165">    }</a>
<a name="ln1166">  }</a>
<a name="ln1167">  gtk_widget_destroy(chooser);</a>
<a name="ln1168">}</a>
<a name="ln1169"> </a>
<a name="ln1170">static gboolean prefix_search(GtkTreeModel *model, gint column, const gchar *key, GtkTreeIter *iter,</a>
<a name="ln1171">                              gpointer d)</a>
<a name="ln1172">{</a>
<a name="ln1173">  gchar *row_data;</a>
<a name="ln1174"> </a>
<a name="ln1175">  gtk_tree_model_get(model, iter, A_TRANS_COLUMN, &amp;row_data, -1);</a>
<a name="ln1176">  while(*key != '\0')</a>
<a name="ln1177">  {</a>
<a name="ln1178">    if(*row_data != *key) return TRUE;</a>
<a name="ln1179">    key++;</a>
<a name="ln1180">    row_data++;</a>
<a name="ln1181">  }</a>
<a name="ln1182">  return FALSE;</a>
<a name="ln1183">}</a>
<a name="ln1184"> </a>
<a name="ln1185">// Custom sort function for TreeModel entries for accels list</a>
<a name="ln1186">static gint compare_rows_accels(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data)</a>
<a name="ln1187">{</a>
<a name="ln1188">  gchar *a_text;</a>
<a name="ln1189">  gchar *b_text;</a>
<a name="ln1190"> </a>
<a name="ln1191">  // First prioritize branch nodes over leaves</a>
<a name="ln1192">  if(gtk_tree_model_iter_has_child(model, a) &amp;&amp; !gtk_tree_model_iter_has_child(model, b)) return -1;</a>
<a name="ln1193"> </a>
<a name="ln1194">  if(gtk_tree_model_iter_has_child(model, b) &amp;&amp; !gtk_tree_model_iter_has_child(model, a)) return 1;</a>
<a name="ln1195"> </a>
<a name="ln1196">  // Otherwise just return alphabetical order</a>
<a name="ln1197">  gtk_tree_model_get(model, a, A_TRANS_COLUMN, &amp;a_text, -1);</a>
<a name="ln1198">  gtk_tree_model_get(model, b, A_TRANS_COLUMN, &amp;b_text, -1);</a>
<a name="ln1199"> </a>
<a name="ln1200">  const int res = strcasecmp(a_text, b_text);</a>
<a name="ln1201"> </a>
<a name="ln1202">  g_free(a_text);</a>
<a name="ln1203">  g_free(b_text);</a>
<a name="ln1204"> </a>
<a name="ln1205">  return res;</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208">// Custom sort function for TreeModel entries for presets list</a>
<a name="ln1209">static gint compare_rows_presets(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data)</a>
<a name="ln1210">{</a>
<a name="ln1211">  gchar *a_text;</a>
<a name="ln1212">  gchar *b_text;</a>
<a name="ln1213"> </a>
<a name="ln1214">  gtk_tree_model_get(model, a, P_MODULE_COLUMN, &amp;a_text, -1);</a>
<a name="ln1215">  gtk_tree_model_get(model, b, P_MODULE_COLUMN, &amp;b_text, -1);</a>
<a name="ln1216">  if(*a_text == '\0' &amp;&amp; *b_text == '\0')</a>
<a name="ln1217">  {</a>
<a name="ln1218">    g_free(a_text);</a>
<a name="ln1219">    g_free(b_text);</a>
<a name="ln1220"> </a>
<a name="ln1221">    gtk_tree_model_get(model, a, P_NAME_COLUMN, &amp;a_text, -1);</a>
<a name="ln1222">    gtk_tree_model_get(model, b, P_NAME_COLUMN, &amp;b_text, -1);</a>
<a name="ln1223">  }</a>
<a name="ln1224"> </a>
<a name="ln1225">  const int res = strcasecmp(a_text, b_text);</a>
<a name="ln1226"> </a>
<a name="ln1227">  g_free(a_text);</a>
<a name="ln1228">  g_free(b_text);</a>
<a name="ln1229"> </a>
<a name="ln1230">  return res;</a>
<a name="ln1231">}</a>
<a name="ln1232"> </a>
<a name="ln1233">// FIXME: Mostly c&amp;p from gui/presets.c</a>
<a name="ln1234">static void check_buttons_activated(GtkCheckButton *button, dt_gui_presets_edit_dialog_t *g)</a>
<a name="ln1235">{</a>
<a name="ln1236">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;autoapply))</a>
<a name="ln1237">     || gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;filter)))</a>
<a name="ln1238">  {</a>
<a name="ln1239">    gtk_widget_set_visible(GTK_WIDGET(g-&gt;details), TRUE);</a>
<a name="ln1240">    gtk_widget_set_no_show_all(GTK_WIDGET(g-&gt;details), FALSE);</a>
<a name="ln1241">    gtk_widget_show_all(GTK_WIDGET(g-&gt;details));</a>
<a name="ln1242">    gtk_widget_set_no_show_all(GTK_WIDGET(g-&gt;details), TRUE);</a>
<a name="ln1243">  }</a>
<a name="ln1244">  else</a>
<a name="ln1245">    gtk_widget_set_visible(GTK_WIDGET(g-&gt;details), FALSE);</a>
<a name="ln1246">}</a>
<a name="ln1247"> </a>
<a name="ln1248">static void edit_preset(GtkTreeView *tree, const gint rowid, const gchar *name, const gchar *module)</a>
<a name="ln1249">{</a>
<a name="ln1250">  GtkWidget *dialog;</a>
<a name="ln1251">  /* Create the widgets */</a>
<a name="ln1252">  char title[1024];</a>
<a name="ln1253">  snprintf(title, sizeof(title), _(&quot;edit `%s' for module `%s'&quot;), name, module);</a>
<a name="ln1254">  dialog = gtk_dialog_new_with_buttons(title, GTK_WINDOW(_preferences_dialog),</a>
<a name="ln1255">                                       GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,</a>
<a name="ln1256">                                       _(&quot;_save&quot;), GTK_RESPONSE_YES,</a>
<a name="ln1257">                                       _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL,</a>
<a name="ln1258">                                       _(&quot;_ok&quot;), GTK_RESPONSE_OK, NULL);</a>
<a name="ln1259">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1260">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1261">#endif</a>
<a name="ln1262">  GtkContainer *content_area = GTK_CONTAINER(gtk_dialog_get_content_area(GTK_DIALOG(dialog)));</a>
<a name="ln1263">  GtkBox *box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 5));</a>
<a name="ln1264">  gtk_widget_set_margin_top(GTK_WIDGET(box), DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln1265">  gtk_widget_set_margin_bottom(GTK_WIDGET(box), DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln1266">  gtk_widget_set_margin_start(GTK_WIDGET(box), DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln1267">  gtk_widget_set_margin_end(GTK_WIDGET(box), DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln1268">  gtk_container_add(content_area, GTK_WIDGET(box));</a>
<a name="ln1269">  GtkWidget *label;</a>
<a name="ln1270"> </a>
<a name="ln1271">  dt_gui_presets_edit_dialog_t *g</a>
<a name="ln1272">      = (dt_gui_presets_edit_dialog_t *)malloc(sizeof(dt_gui_presets_edit_dialog_t));</a>
<a name="ln1273">  g-&gt;rowid = rowid;</a>
<a name="ln1274">  g-&gt;tree = tree;</a>
<a name="ln1275">  g-&gt;name = GTK_LABEL(gtk_label_new(name));</a>
<a name="ln1276">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;name), FALSE, FALSE, 0);</a>
<a name="ln1277"> </a>
<a name="ln1278">  g-&gt;description = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1279">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;description), FALSE, FALSE, 0);</a>
<a name="ln1280">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;description), _(&quot;description or further information&quot;));</a>
<a name="ln1281"> </a>
<a name="ln1282">  g-&gt;autoapply</a>
<a name="ln1283">      = GTK_CHECK_BUTTON(gtk_check_button_new_with_label(_(&quot;auto apply this preset to matching images&quot;)));</a>
<a name="ln1284">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;autoapply), FALSE, FALSE, 0);</a>
<a name="ln1285">  g-&gt;filter</a>
<a name="ln1286">      = GTK_CHECK_BUTTON(gtk_check_button_new_with_label(_(&quot;only show this preset for matching images&quot;)));</a>
<a name="ln1287">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;filter),</a>
<a name="ln1288">                              _(&quot;be very careful with this option. this might be the last time you see your preset.&quot;));</a>
<a name="ln1289">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;filter), FALSE, FALSE, 0);</a>
<a name="ln1290">  g_signal_connect(G_OBJECT(g-&gt;autoapply), &quot;toggled&quot;, G_CALLBACK(check_buttons_activated), g);</a>
<a name="ln1291">  g_signal_connect(G_OBJECT(g-&gt;filter), &quot;toggled&quot;, G_CALLBACK(check_buttons_activated), g);</a>
<a name="ln1292"> </a>
<a name="ln1293">  int line = 0;</a>
<a name="ln1294">  g-&gt;details = gtk_grid_new();</a>
<a name="ln1295">  gtk_grid_set_row_spacing(GTK_GRID(g-&gt;details), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln1296">  gtk_grid_set_column_spacing(GTK_GRID(g-&gt;details), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln1297">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;details), FALSE, FALSE, 0);</a>
<a name="ln1298"> </a>
<a name="ln1299">  // model, maker, lens</a>
<a name="ln1300">  g-&gt;model = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1301">  /* xgettext:no-c-format */</a>
<a name="ln1302">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;model), _(&quot;string to match model (use % as wildcard)&quot;));</a>
<a name="ln1303">  label = gtk_label_new(_(&quot;model&quot;));</a>
<a name="ln1304">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1305">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1306">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;model), label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1307"> </a>
<a name="ln1308">  g-&gt;maker = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1309">  /* xgettext:no-c-format */</a>
<a name="ln1310">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;maker), _(&quot;string to match maker (use % as wildcard)&quot;));</a>
<a name="ln1311">  label = gtk_label_new(_(&quot;maker&quot;));</a>
<a name="ln1312">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1313">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1314">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;maker), label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1315"> </a>
<a name="ln1316">  g-&gt;lens = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1317">  /* xgettext:no-c-format */</a>
<a name="ln1318">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;lens), _(&quot;string to match lens (use % as wildcard)&quot;));</a>
<a name="ln1319">  label = gtk_label_new(_(&quot;lens&quot;));</a>
<a name="ln1320">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1321">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1322">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;lens), label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1323"> </a>
<a name="ln1324">  // iso</a>
<a name="ln1325">  label = gtk_label_new(_(&quot;ISO&quot;));</a>
<a name="ln1326">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1327">  g-&gt;iso_min = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, FLT_MAX, 100));</a>
<a name="ln1328">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;iso_min), _(&quot;minimum ISO value&quot;));</a>
<a name="ln1329">  gtk_spin_button_set_digits(g-&gt;iso_min, 0);</a>
<a name="ln1330">  g-&gt;iso_max = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, FLT_MAX, 100));</a>
<a name="ln1331">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;iso_max), _(&quot;maximum ISO value&quot;));</a>
<a name="ln1332">  gtk_spin_button_set_digits(g-&gt;iso_max, 0);</a>
<a name="ln1333">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1334">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;iso_min), label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1335">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;iso_max), GTK_WIDGET(g-&gt;iso_min), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1336"> </a>
<a name="ln1337">  // exposure</a>
<a name="ln1338">  label = gtk_label_new(_(&quot;exposure&quot;));</a>
<a name="ln1339">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1340">  g-&gt;exposure_min = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1341">  g-&gt;exposure_max = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1342">  gtk_widget_set_tooltip_text(g-&gt;exposure_min, _(&quot;minimum exposure time&quot;));</a>
<a name="ln1343">  gtk_widget_set_tooltip_text(g-&gt;exposure_max, _(&quot;maximum exposure time&quot;));</a>
<a name="ln1344">  for(int k = 0; k &lt; dt_gui_presets_exposure_value_cnt; k++)</a>
<a name="ln1345">    dt_bauhaus_combobox_add(g-&gt;exposure_min, dt_gui_presets_exposure_value_str[k]);</a>
<a name="ln1346">  for(int k = 0; k &lt; dt_gui_presets_exposure_value_cnt; k++)</a>
<a name="ln1347">    dt_bauhaus_combobox_add(g-&gt;exposure_max, dt_gui_presets_exposure_value_str[k]);</a>
<a name="ln1348">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1349">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;exposure_min, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1350">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;exposure_max, g-&gt;exposure_min, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1351"> </a>
<a name="ln1352">  // aperture</a>
<a name="ln1353">  label = gtk_label_new(_(&quot;aperture&quot;));</a>
<a name="ln1354">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1355">  g-&gt;aperture_min = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1356">  g-&gt;aperture_max = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1357">  gtk_widget_set_tooltip_text(g-&gt;aperture_min, _(&quot;minimum aperture value&quot;));</a>
<a name="ln1358">  gtk_widget_set_tooltip_text(g-&gt;aperture_max, _(&quot;maximum aperture value&quot;));</a>
<a name="ln1359">  for(int k = 0; k &lt; dt_gui_presets_aperture_value_cnt; k++)</a>
<a name="ln1360">    dt_bauhaus_combobox_add(g-&gt;aperture_min, dt_gui_presets_aperture_value_str[k]);</a>
<a name="ln1361">  for(int k = 0; k &lt; dt_gui_presets_aperture_value_cnt; k++)</a>
<a name="ln1362">    dt_bauhaus_combobox_add(g-&gt;aperture_max, dt_gui_presets_aperture_value_str[k]);</a>
<a name="ln1363">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1364">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;aperture_min, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1365">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;aperture_max, g-&gt;aperture_min, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1366"> </a>
<a name="ln1367">  // focal length</a>
<a name="ln1368">  label = gtk_label_new(_(&quot;focal length&quot;));</a>
<a name="ln1369">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1370">  g-&gt;focal_length_min = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, 1000, 10));</a>
<a name="ln1371">  gtk_spin_button_set_digits(g-&gt;focal_length_min, 0);</a>
<a name="ln1372">  g-&gt;focal_length_max = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, 1000, 10));</a>
<a name="ln1373">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;focal_length_min), _(&quot;minimum focal length&quot;));</a>
<a name="ln1374">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;focal_length_max), _(&quot;maximum focal length&quot;));</a>
<a name="ln1375">  gtk_spin_button_set_digits(g-&gt;focal_length_max, 0);</a>
<a name="ln1376">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1377">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;focal_length_min), label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1378">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;focal_length_max), GTK_WIDGET(g-&gt;focal_length_min), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1379">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;focal_length_min), TRUE);</a>
<a name="ln1380">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;focal_length_max), TRUE);</a>
<a name="ln1381"> </a>
<a name="ln1382">  // raw/hdr/ldr</a>
<a name="ln1383">  label = gtk_label_new(_(&quot;format&quot;));</a>
<a name="ln1384">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1385">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line, 1, 1);</a>
<a name="ln1386"> </a>
<a name="ln1387">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1388">  {</a>
<a name="ln1389">    g-&gt;format_btn[i] = gtk_check_button_new_with_label(_(dt_gui_presets_format_value_str[i]));</a>
<a name="ln1390">    gtk_grid_attach(GTK_GRID(g-&gt;details), g-&gt;format_btn[i], 1, line + i, 2, 1);</a>
<a name="ln1391">  }</a>
<a name="ln1392"> </a>
<a name="ln1393">  gtk_widget_set_no_show_all(GTK_WIDGET(g-&gt;details), TRUE);</a>
<a name="ln1394"> </a>
<a name="ln1395">  sqlite3_stmt *stmt;</a>
<a name="ln1396">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1397">                              &quot;SELECT description, model, maker, lens, iso_min, iso_max, exposure_min, &quot;</a>
<a name="ln1398">                              &quot;exposure_max, aperture_min, aperture_max, focal_length_min, focal_length_max, &quot;</a>
<a name="ln1399">                              &quot;autoapply, filter, format FROM data.presets WHERE rowid = ?1&quot;,</a>
<a name="ln1400">                              -1, &amp;stmt, NULL);</a>
<a name="ln1401">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, rowid);</a>
<a name="ln1402">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1403">  {</a>
<a name="ln1404">    gtk_entry_set_text(g-&gt;description, (const char *)sqlite3_column_text(stmt, 0));</a>
<a name="ln1405">    gtk_entry_set_text(g-&gt;model, (const char *)sqlite3_column_text(stmt, 1));</a>
<a name="ln1406">    gtk_entry_set_text(g-&gt;maker, (const char *)sqlite3_column_text(stmt, 2));</a>
<a name="ln1407">    gtk_entry_set_text(g-&gt;lens, (const char *)sqlite3_column_text(stmt, 3));</a>
<a name="ln1408">    gtk_spin_button_set_value(g-&gt;iso_min, sqlite3_column_double(stmt, 4));</a>
<a name="ln1409">    gtk_spin_button_set_value(g-&gt;iso_max, sqlite3_column_double(stmt, 5));</a>
<a name="ln1410"> </a>
<a name="ln1411">    float val = sqlite3_column_double(stmt, 6);</a>
<a name="ln1412">    int k = 0;</a>
<a name="ln1413">    for(; k &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; val &gt; dt_gui_presets_exposure_value[k]; k++)</a>
<a name="ln1414">      ;</a>
<a name="ln1415">    dt_bauhaus_combobox_set(g-&gt;exposure_min, k);</a>
<a name="ln1416">    val = sqlite3_column_double(stmt, 7);</a>
<a name="ln1417">    for(k = 0; k &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; val &gt; dt_gui_presets_exposure_value[k]; k++)</a>
<a name="ln1418">      ;</a>
<a name="ln1419">    dt_bauhaus_combobox_set(g-&gt;exposure_max, k);</a>
<a name="ln1420">    val = sqlite3_column_double(stmt, 8);</a>
<a name="ln1421">    for(k = 0; k &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; val &gt; dt_gui_presets_aperture_value[k]; k++)</a>
<a name="ln1422">      ;</a>
<a name="ln1423">    dt_bauhaus_combobox_set(g-&gt;aperture_min, k);</a>
<a name="ln1424">    val = sqlite3_column_double(stmt, 9);</a>
<a name="ln1425">    for(k = 0; k &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; val &gt; dt_gui_presets_aperture_value[k]; k++)</a>
<a name="ln1426">      ;</a>
<a name="ln1427">    dt_bauhaus_combobox_set(g-&gt;aperture_max, k);</a>
<a name="ln1428">    gtk_spin_button_set_value(g-&gt;focal_length_min, sqlite3_column_double(stmt, 10));</a>
<a name="ln1429">    gtk_spin_button_set_value(g-&gt;focal_length_max, sqlite3_column_double(stmt, 11));</a>
<a name="ln1430">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;autoapply), sqlite3_column_int(stmt, 12));</a>
<a name="ln1431">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;filter), sqlite3_column_int(stmt, 13));</a>
<a name="ln1432">    const int format = sqlite3_column_int(stmt, 14);</a>
<a name="ln1433">    for(k = 0; k &lt; 3; k++)</a>
<a name="ln1434">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;format_btn[k]), format &amp; (dt_gui_presets_format_flag[k]));</a>
<a name="ln1435">  }</a>
<a name="ln1436">  sqlite3_finalize(stmt);</a>
<a name="ln1437"> </a>
<a name="ln1438">  g_signal_connect(dialog, &quot;response&quot;, G_CALLBACK(edit_preset_response), g);</a>
<a name="ln1439">  gtk_widget_show_all(dialog);</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442">static void edit_preset_response(GtkDialog *dialog, gint response_id, dt_gui_presets_edit_dialog_t *g)</a>
<a name="ln1443">{</a>
<a name="ln1444">  // commit all the user input fields</a>
<a name="ln1445">  if(response_id == GTK_RESPONSE_OK)</a>
<a name="ln1446">  {</a>
<a name="ln1447">    sqlite3_stmt *stmt;</a>
<a name="ln1448">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1449">                                &quot;UPDATE data.presets SET description = ?1, model = ?2, maker = ?3, lens = ?4, &quot;</a>
<a name="ln1450">                                &quot;iso_min = ?5, iso_max = ?6, exposure_min = ?7, exposure_max = ?8, &quot;</a>
<a name="ln1451">                                &quot;aperture_min = ?9, aperture_max = ?10, focal_length_min = ?11, &quot;</a>
<a name="ln1452">                                &quot;focal_length_max = ?12, autoapply = ?13, filter = ?14, def = 0, format = ?15 &quot;</a>
<a name="ln1453">                                &quot;WHERE rowid = ?16&quot;,</a>
<a name="ln1454">                                -1, &amp;stmt, NULL);</a>
<a name="ln1455">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, gtk_entry_get_text(g-&gt;description), -1, SQLITE_TRANSIENT);</a>
<a name="ln1456">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, gtk_entry_get_text(g-&gt;model), -1, SQLITE_TRANSIENT);</a>
<a name="ln1457">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 3, gtk_entry_get_text(g-&gt;maker), -1, SQLITE_TRANSIENT);</a>
<a name="ln1458">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, gtk_entry_get_text(g-&gt;lens), -1, SQLITE_TRANSIENT);</a>
<a name="ln1459">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 5, gtk_spin_button_get_value(g-&gt;iso_min));</a>
<a name="ln1460">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 6, gtk_spin_button_get_value(g-&gt;iso_max));</a>
<a name="ln1461">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 7,</a>
<a name="ln1462">                                 dt_gui_presets_exposure_value[dt_bauhaus_combobox_get(g-&gt;exposure_min)]);</a>
<a name="ln1463">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 8,</a>
<a name="ln1464">                                 dt_gui_presets_exposure_value[dt_bauhaus_combobox_get(g-&gt;exposure_max)]);</a>
<a name="ln1465">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 9,</a>
<a name="ln1466">                                 dt_gui_presets_aperture_value[dt_bauhaus_combobox_get(g-&gt;aperture_min)]);</a>
<a name="ln1467">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 10,</a>
<a name="ln1468">                                 dt_gui_presets_aperture_value[dt_bauhaus_combobox_get(g-&gt;aperture_max)]);</a>
<a name="ln1469">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 11, gtk_spin_button_get_value(g-&gt;focal_length_min));</a>
<a name="ln1470">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 12, gtk_spin_button_get_value(g-&gt;focal_length_max));</a>
<a name="ln1471">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 13, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;autoapply)));</a>
<a name="ln1472">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 14, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;filter)));</a>
<a name="ln1473">    int format = 0;</a>
<a name="ln1474">    for(int k = 0; k &lt; 3; k++)</a>
<a name="ln1475">      format += gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;format_btn[k])) * dt_gui_presets_format_flag[k];</a>
<a name="ln1476">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 15, format);</a>
<a name="ln1477">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 16, g-&gt;rowid);</a>
<a name="ln1478">    sqlite3_step(stmt);</a>
<a name="ln1479">    sqlite3_finalize(stmt);</a>
<a name="ln1480">  }</a>
<a name="ln1481">  else if(response_id == GTK_RESPONSE_YES)</a>
<a name="ln1482">  {</a>
<a name="ln1483">    const gchar *name = gtk_label_get_text(g-&gt;name);</a>
<a name="ln1484"> </a>
<a name="ln1485">    // ask for destination directory</a>
<a name="ln1486"> </a>
<a name="ln1487">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1488">    GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1489">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1490">      GTK_RESPONSE_CANCEL, _(&quot;_select as output destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1491">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1492">    dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1493">#endif</a>
<a name="ln1494"> </a>
<a name="ln1495">    // save if accepted</a>
<a name="ln1496"> </a>
<a name="ln1497">    if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1498">    {</a>
<a name="ln1499">      char *filedir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1500">      dt_presets_save_to_file(g-&gt;rowid, name, filedir);</a>
<a name="ln1501">      dt_control_log(_(&quot;preset %s was successfully saved&quot;), name);</a>
<a name="ln1502">      g_free(filedir);</a>
<a name="ln1503">    }</a>
<a name="ln1504"> </a>
<a name="ln1505">    gtk_widget_destroy(GTK_WIDGET(filechooser));</a>
<a name="ln1506">  }</a>
<a name="ln1507"> </a>
<a name="ln1508">  GtkTreeStore *tree_store = GTK_TREE_STORE(gtk_tree_view_get_model(g-&gt;tree));</a>
<a name="ln1509">  gtk_tree_store_clear(tree_store);</a>
<a name="ln1510">  tree_insert_presets(tree_store);</a>
<a name="ln1511"> </a>
<a name="ln1512">  gtk_widget_destroy(GTK_WIDGET(dialog));</a>
<a name="ln1513">  free(g);</a>
<a name="ln1514">}</a>
<a name="ln1515"> </a>
<a name="ln1516">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1517">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1518">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1273"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 1273, 1272.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
