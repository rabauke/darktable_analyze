
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012 johannes hanika.</a>
<a name="ln4">    copyright (c) 2012--2014 tobias ellinghaus.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln21">#include &quot;common/calculator.h&quot;</a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;develop/develop.h&quot;</a>
<a name="ln25">#include &quot;gui/gtk.h&quot;</a>
<a name="ln26">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln27">#include &quot;osx/osx.h&quot;</a>
<a name="ln28">#endif</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;math.h&gt;</a>
<a name="ln31">#include &lt;pango/pangocairo.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">G_DEFINE_TYPE(DtBauhausWidget, dt_bh, GTK_TYPE_DRAWING_AREA)</a>
<a name="ln34"> </a>
<a name="ln35">// INNER_PADDING is the horizontal space between slider and quad</a>
<a name="ln36">// and vertical space between labels and slider baseline</a>
<a name="ln37">#define INNER_PADDING 4.0</a>
<a name="ln38"> </a>
<a name="ln39">// fwd declare</a>
<a name="ln40">static gboolean dt_bauhaus_popup_draw(GtkWidget *widget, cairo_t *cr, gpointer user_data);</a>
<a name="ln41">static gboolean dt_bauhaus_popup_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);</a>
<a name="ln42">static void dt_bauhaus_widget_accept(dt_bauhaus_widget_t *w);</a>
<a name="ln43">static void dt_bauhaus_widget_reject(dt_bauhaus_widget_t *w);</a>
<a name="ln44"> </a>
<a name="ln45">static gboolean _combobox_next_entry(GList *entries, int *new_pos, int delta_y)</a>
<a name="ln46">{</a>
<a name="ln47">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(entries, *new_pos);</a>
<a name="ln48">  while(entry &amp;&amp; !entry-&gt;sensitive)</a>
<a name="ln49">  {</a>
<a name="ln50">    *new_pos += delta_y;</a>
<a name="ln51">    entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(entries, *new_pos);</a>
<a name="ln52">  }</a>
<a name="ln53">  return entry != NULL;</a>
<a name="ln54">}</a>
<a name="ln55"> </a>
<a name="ln56">static inline int get_line_height()</a>
<a name="ln57">{</a>
<a name="ln58">  return darktable.bauhaus-&gt;scale * darktable.bauhaus-&gt;line_height;</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61">static dt_bauhaus_combobox_entry_t *new_combobox_entry(const char *label, dt_bauhaus_combobox_alignment_t alignment,</a>
<a name="ln62">                                                       gboolean sensitive, void *data, void (*free_func)(void *))</a>
<a name="ln63">{</a>
<a name="ln64">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)calloc(1, sizeof(dt_bauhaus_combobox_entry_t));</a>
<a name="ln65">  entry-&gt;label = g_strdup(label);</a>
<a name="ln66">  entry-&gt;alignment = alignment;</a>
<a name="ln67">  entry-&gt;sensitive = sensitive;</a>
<a name="ln68">  entry-&gt;data = data;</a>
<a name="ln69">  entry-&gt;free_func = free_func;</a>
<a name="ln70">  return entry;</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">static void free_combobox_entry(gpointer data)</a>
<a name="ln74">{</a>
<a name="ln75">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)data;</a>
<a name="ln76">  g_free(entry-&gt;label);</a>
<a name="ln77">  if(entry-&gt;free_func)</a>
<a name="ln78">    entry-&gt;free_func(entry-&gt;data);</a>
<a name="ln79">  free(entry);</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">static inline float inner_height(GtkAllocation allocation)</a>
<a name="ln83">{</a>
<a name="ln84">  // retrieve the inner height of the widget (inside the top/bottom margin)</a>
<a name="ln85">  return allocation.height - 2.0f * darktable.bauhaus-&gt;widget_space;</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88"> </a>
<a name="ln89">static GdkRGBA * default_color_assign()</a>
<a name="ln90">{</a>
<a name="ln91">  // helper to initialize a color pointer with red color as a default</a>
<a name="ln92">  GdkRGBA color;</a>
<a name="ln93">  color.red = 1.0f;</a>
<a name="ln94">  color.green = 0.0f;</a>
<a name="ln95">  color.blue = 0.0f;</a>
<a name="ln96">  color.alpha = 1.0f;</a>
<a name="ln97">  return gdk_rgba_copy(&amp;color);</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100"> </a>
<a name="ln101">static int show_pango_text(cairo_t *cr, char *text, float x_pos, float y_pos, float max_width, gboolean right_aligned)</a>
<a name="ln102">{</a>
<a name="ln103">  PangoLayout *layout;</a>
<a name="ln104"> </a>
<a name="ln105">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln106"> </a>
<a name="ln107">  if(max_width &gt; 0)</a>
<a name="ln108">  {</a>
<a name="ln109">    pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_MIDDLE);</a>
<a name="ln110">    pango_layout_set_width(layout, (int)(PANGO_SCALE * max_width + 0.5f));</a>
<a name="ln111">  }</a>
<a name="ln112"> </a>
<a name="ln113">  if(text) {</a>
<a name="ln114">    pango_layout_set_text(layout, text, -1);</a>
<a name="ln115">  } else {</a>
<a name="ln116">    // length of -1 is not allowed with NULL string (wtf)</a>
<a name="ln117">    pango_layout_set_text(layout, NULL, 0);</a>
<a name="ln118">  }</a>
<a name="ln119"> </a>
<a name="ln120">  pango_layout_set_font_description(layout, darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln121">  pango_cairo_context_set_resolution(pango_layout_get_context(layout), darktable.gui-&gt;dpi);</a>
<a name="ln122"> </a>
<a name="ln123">  int pango_width, pango_height;</a>
<a name="ln124">  pango_layout_get_size(layout, &amp;pango_width, &amp;pango_height);</a>
<a name="ln125">  float text_width = ((double)pango_width/PANGO_SCALE);</a>
<a name="ln126"> </a>
<a name="ln127">  if(right_aligned) x_pos -= text_width;</a>
<a name="ln128"> </a>
<a name="ln129">  cairo_move_to(cr, x_pos, y_pos);</a>
<a name="ln130">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln131">  g_object_unref(layout);</a>
<a name="ln132"> </a>
<a name="ln133">  return text_width;</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">// -------------------------------</a>
<a name="ln137">static gboolean _cursor_timeout_callback(gpointer user_data)</a>
<a name="ln138">{</a>
<a name="ln139">  if(darktable.bauhaus-&gt;cursor_blink_counter &gt; 0) darktable.bauhaus-&gt;cursor_blink_counter--;</a>
<a name="ln140"> </a>
<a name="ln141">  darktable.bauhaus-&gt;cursor_visible = !darktable.bauhaus-&gt;cursor_visible;</a>
<a name="ln142">  gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln143"> </a>
<a name="ln144">  if(darktable.bauhaus-&gt;cursor_blink_counter</a>
<a name="ln145">     != 0) // this can be &gt;0 when we haven't reached the desired number or -1 when blinking forever</a>
<a name="ln146">    return TRUE;</a>
<a name="ln147"> </a>
<a name="ln148">  darktable.bauhaus-&gt;cursor_timeout = 0; // otherwise the cursor won't come up when starting to type</a>
<a name="ln149">  return FALSE;</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">static void _start_cursor(int max_blinks)</a>
<a name="ln153">{</a>
<a name="ln154">  darktable.bauhaus-&gt;cursor_blink_counter = max_blinks;</a>
<a name="ln155">  darktable.bauhaus-&gt;cursor_visible = FALSE;</a>
<a name="ln156">  if(darktable.bauhaus-&gt;cursor_timeout == 0)</a>
<a name="ln157">    darktable.bauhaus-&gt;cursor_timeout = g_timeout_add(500, _cursor_timeout_callback, NULL);</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160">static void _stop_cursor()</a>
<a name="ln161">{</a>
<a name="ln162">  if(darktable.bauhaus-&gt;cursor_timeout &gt; 0)</a>
<a name="ln163">  {</a>
<a name="ln164">    g_source_remove(darktable.bauhaus-&gt;cursor_timeout);</a>
<a name="ln165">    darktable.bauhaus-&gt;cursor_timeout = 0;</a>
<a name="ln166">    darktable.bauhaus-&gt;cursor_visible = FALSE;</a>
<a name="ln167">  }</a>
<a name="ln168">}</a>
<a name="ln169">// -------------------------------</a>
<a name="ln170"> </a>
<a name="ln171"> </a>
<a name="ln172">static void dt_bauhaus_slider_set_normalized(dt_bauhaus_widget_t *w, float pos);</a>
<a name="ln173"> </a>
<a name="ln174">static float slider_right_pos(float width)</a>
<a name="ln175">{</a>
<a name="ln176">  // relative position (in widget) of the right bound of the slider corrected with the inner padding</a>
<a name="ln177">  return 1.0f - (darktable.bauhaus-&gt;quad_width + INNER_PADDING) / width;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">static float slider_coordinate(const float abs_position, const float width)</a>
<a name="ln181">{</a>
<a name="ln182">  // Translates an horizontal position relative to the slider</a>
<a name="ln183">  // in an horizontal position relative to the widget</a>
<a name="ln184">  const float left_bound = 0.0f;</a>
<a name="ln185">  const float right_bound = slider_right_pos(width); // exclude the quad area on the right</a>
<a name="ln186">  return (left_bound + abs_position * (right_bound - left_bound)) * width;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189"> </a>
<a name="ln190">static float get_slider_line_offset(float pos, float scale, float x, float y, float ht, const int width)</a>
<a name="ln191">{</a>
<a name="ln192">  // ht is in [0,1] scale here</a>
<a name="ln193">  const float l = 0.0f;</a>
<a name="ln194">  const float r = slider_right_pos(width);</a>
<a name="ln195"> </a>
<a name="ln196">  float offset = 0.0f;</a>
<a name="ln197">  // handle linear startup and rescale y to fit the whole range again</a>
<a name="ln198">  if(y &lt; ht)</a>
<a name="ln199">  {</a>
<a name="ln200">    offset = (x - l) / (r - l) - pos;</a>
<a name="ln201">  }</a>
<a name="ln202">  else</a>
<a name="ln203">  {</a>
<a name="ln204">    y -= ht;</a>
<a name="ln205">    y /= (1.0f - ht);</a>
<a name="ln206"> </a>
<a name="ln207">    offset = (x - y * y * .5f - (1.0f - y * y) * (l + pos * (r - l)))</a>
<a name="ln208">             / (.5f * y * y / scale + (1.0f - y * y) * (r - l));</a>
<a name="ln209">  }</a>
<a name="ln210">  // clamp to result in a [0,1] range:</a>
<a name="ln211">  if(pos + offset &gt; 1.0f) offset = 1.0f - pos;</a>
<a name="ln212">  if(pos + offset &lt; 0.0f) offset = -pos;</a>
<a name="ln213">  return offset;</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">// draw a loupe guideline for the quadratic zoom in in the slider interface:</a>
<a name="ln217">static void draw_slider_line(cairo_t *cr, float pos, float off, float scale, const int width,</a>
<a name="ln218">                             const int height, const int ht)</a>
<a name="ln219">{</a>
<a name="ln220">  // pos is normalized position [0,1], offset is on that scale.</a>
<a name="ln221">  // ht is in pixels here</a>
<a name="ln222">  const float l = 0.0f;</a>
<a name="ln223">  const float r = slider_right_pos(width);</a>
<a name="ln224"> </a>
<a name="ln225">  const int steps = 64;</a>
<a name="ln226">  cairo_move_to(cr, width * (l + (pos + off) * (r - l)), ht * .7f);</a>
<a name="ln227">  cairo_line_to(cr, width * (l + (pos + off) * (r - l)), ht);</a>
<a name="ln228">  for(int j = 1; j &lt; steps; j++)</a>
<a name="ln229">  {</a>
<a name="ln230">    const float y = j / (steps - 1.0f);</a>
<a name="ln231">    const float x = y * y * .5f * (1.f + off / scale) + (1.0f - y * y) * (l + (pos + off) * (r - l));</a>
<a name="ln232">    cairo_line_to(cr, x * width, ht + y * (height - ht));</a>
<a name="ln233">  }</a>
<a name="ln234">}</a>
<a name="ln235">// -------------------------------</a>
<a name="ln236"> </a>
<a name="ln237">// handlers on the popup window, to close popup:</a>
<a name="ln238">static gboolean dt_bauhaus_window_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln239">{</a>
<a name="ln240">  const float tol = 50;</a>
<a name="ln241">  gint wx, wy;</a>
<a name="ln242">  GtkAllocation allocation;</a>
<a name="ln243">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln244">  gdk_window_get_origin(gtk_widget_get_window(widget), &amp;wx, &amp;wy);</a>
<a name="ln245">  if(event-&gt;x_root &gt; wx + allocation.width + tol || event-&gt;y_root &gt; wy + inner_height(allocation) + tol</a>
<a name="ln246">     || event-&gt;x_root &lt; (int)wx - tol || event-&gt;y_root &lt; (int)wy - tol)</a>
<a name="ln247">  {</a>
<a name="ln248">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln249">    dt_bauhaus_hide_popup();</a>
<a name="ln250">    return TRUE;</a>
<a name="ln251">  }</a>
<a name="ln252">  // make sure to propagate the event further</a>
<a name="ln253">  return FALSE;</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">static gboolean dt_bauhaus_window_button_press(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln257">{</a>
<a name="ln258">  const float tol = 0;</a>
<a name="ln259">  gint wx, wy;</a>
<a name="ln260">  GtkAllocation allocation;</a>
<a name="ln261">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln262">  gdk_window_get_origin(gtk_widget_get_window(widget), &amp;wx, &amp;wy);</a>
<a name="ln263">  if((event-&gt;x_root &gt; wx + allocation.width + tol || event-&gt;y_root &gt; wy + inner_height(allocation) + tol</a>
<a name="ln264">      || event-&gt;x_root &lt; (int)wx - tol || event-&gt;y_root &lt; (int)wy - tol))</a>
<a name="ln265">  {</a>
<a name="ln266">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln267">    dt_bauhaus_hide_popup();</a>
<a name="ln268">    return TRUE;</a>
<a name="ln269">  }</a>
<a name="ln270">  // make sure to propagate the event further</a>
<a name="ln271">  return FALSE;</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">static void combobox_popup_scroll(int amt)</a>
<a name="ln275">{</a>
<a name="ln276">  gint wx, wy;</a>
<a name="ln277">  GtkWidget *w = GTK_WIDGET(darktable.bauhaus-&gt;current);</a>
<a name="ln278">  GtkAllocation allocation_w;</a>
<a name="ln279">  gtk_widget_get_allocation(w, &amp;allocation_w);</a>
<a name="ln280">  const int ht = allocation_w.height;</a>
<a name="ln281">  const int skip = ht;</a>
<a name="ln282">  gdk_window_get_origin(gtk_widget_get_window(w), &amp;wx, &amp;wy);</a>
<a name="ln283">  dt_bauhaus_combobox_data_t *d = &amp;darktable.bauhaus-&gt;current-&gt;data.combobox;</a>
<a name="ln284">  int new_value = CLAMP(d-&gt;active + amt, 0, d-&gt;num_labels - 1);</a>
<a name="ln285">  // skip insensitive ones</a>
<a name="ln286">  if(!_combobox_next_entry(d-&gt;entries, &amp;new_value, amt))</a>
<a name="ln287">    return;</a>
<a name="ln288"> </a>
<a name="ln289">  // we move the popup up or down</a>
<a name="ln290">  if(new_value == d-&gt;active)</a>
<a name="ln291">  {</a>
<a name="ln292">    gdk_window_move(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), wx, wy - d-&gt;active * skip);</a>
<a name="ln293">  }</a>
<a name="ln294">  else</a>
<a name="ln295">  {</a>
<a name="ln296">    gint px, py;</a>
<a name="ln297">    gdk_window_get_origin(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), &amp;px, &amp;py);</a>
<a name="ln298">    gdk_window_move(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), wx, py - skip * (new_value - d-&gt;active));</a>
<a name="ln299">  }</a>
<a name="ln300"> </a>
<a name="ln301">  // make sure highlighted entry is updated:</a>
<a name="ln302">  darktable.bauhaus-&gt;mouse_x = 0;</a>
<a name="ln303">  darktable.bauhaus-&gt;mouse_y = new_value * skip + ht / 2;</a>
<a name="ln304">  gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln305"> </a>
<a name="ln306">  // and we change the value</a>
<a name="ln307">  dt_bauhaus_combobox_set(w, new_value);</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310"> </a>
<a name="ln311">static gboolean dt_bauhaus_popup_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln312">{</a>
<a name="ln313">  int delta_y;</a>
<a name="ln314">  switch(darktable.bauhaus-&gt;current-&gt;type)</a>
<a name="ln315">  {</a>
<a name="ln316">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln317">      if(dt_gui_get_scroll_unit_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln318">         combobox_popup_scroll(delta_y);</a>
<a name="ln319">      break;</a>
<a name="ln320">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln321">      break;</a>
<a name="ln322">    default:</a>
<a name="ln323">      break;</a>
<a name="ln324">  }</a>
<a name="ln325">  return TRUE;</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">static gboolean dt_bauhaus_popup_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln329">{</a>
<a name="ln330">  GtkAllocation allocation_popup_window;</a>
<a name="ln331">  gtk_widget_get_allocation(darktable.bauhaus-&gt;popup_window, &amp;allocation_popup_window);</a>
<a name="ln332">  gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln333">  dt_bauhaus_widget_t *w = darktable.bauhaus-&gt;current;</a>
<a name="ln334">  GtkAllocation allocation_w;</a>
<a name="ln335">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;allocation_w);</a>
<a name="ln336">  int width = allocation_popup_window.width, height = inner_height(allocation_popup_window);</a>
<a name="ln337">  // coordinate transform is in vain because we're only ever called after a button release.</a>
<a name="ln338">  // that means the system is always the one of the popup.</a>
<a name="ln339">  // that also means that we can't have hovering combobox entries while still holding the button. :(</a>
<a name="ln340">  const float ex = event-&gt;x;</a>
<a name="ln341">  const float ey = event-&gt;y;</a>
<a name="ln342">  GtkAllocation allocation;</a>
<a name="ln343">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln344"> </a>
<a name="ln345">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_PRELIGHT, TRUE);</a>
<a name="ln346"> </a>
<a name="ln347">  if(darktable.bauhaus-&gt;keys_cnt == 0) _stop_cursor();</a>
<a name="ln348"> </a>
<a name="ln349">  switch(w-&gt;type)</a>
<a name="ln350">  {</a>
<a name="ln351">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln352">      darktable.bauhaus-&gt;mouse_x = ex;</a>
<a name="ln353">      darktable.bauhaus-&gt;mouse_y = ey;</a>
<a name="ln354">      break;</a>
<a name="ln355">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln356">    {</a>
<a name="ln357">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln358">      const float mouse_off = get_slider_line_offset(d-&gt;oldpos, d-&gt;scale, ex / width, ey / height,</a>
<a name="ln359">                                                     allocation_w.height / (float)height, allocation.width);</a>
<a name="ln360">      if(!darktable.bauhaus-&gt;change_active)</a>
<a name="ln361">      {</a>
<a name="ln362">        if((darktable.bauhaus-&gt;mouse_line_distance &lt; 0 &amp;&amp; mouse_off &gt;= 0)</a>
<a name="ln363">           || (darktable.bauhaus-&gt;mouse_line_distance &gt; 0 &amp;&amp; mouse_off &lt;= 0))</a>
<a name="ln364">          darktable.bauhaus-&gt;change_active = 1;</a>
<a name="ln365">        darktable.bauhaus-&gt;mouse_line_distance = mouse_off;</a>
<a name="ln366">      }</a>
<a name="ln367">      if(darktable.bauhaus-&gt;change_active)</a>
<a name="ln368">      {</a>
<a name="ln369">        // remember mouse position for motion effects in draw</a>
<a name="ln370">        darktable.bauhaus-&gt;mouse_x = ex;</a>
<a name="ln371">        darktable.bauhaus-&gt;mouse_y = ey;</a>
<a name="ln372">        dt_bauhaus_slider_set_normalized(w, d-&gt;oldpos + mouse_off);</a>
<a name="ln373">      }</a>
<a name="ln374">    }</a>
<a name="ln375">    break;</a>
<a name="ln376">    default:</a>
<a name="ln377">      break;</a>
<a name="ln378">  }</a>
<a name="ln379">  // throttling using motion hint:</a>
<a name="ln380">  // gdk_event_request_motions(event);</a>
<a name="ln381">  return TRUE;</a>
<a name="ln382">}</a>
<a name="ln383"> </a>
<a name="ln384">static gboolean dt_bauhaus_popup_leave_notify(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln385">{</a>
<a name="ln386">  gtk_widget_set_state_flags(widget, GTK_STATE_FLAG_NORMAL, TRUE);</a>
<a name="ln387">  return TRUE;</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">static gboolean dt_bauhaus_popup_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln391">{</a>
<a name="ln392">  if(darktable.bauhaus-&gt;current &amp;&amp; (darktable.bauhaus-&gt;current-&gt;type == DT_BAUHAUS_COMBOBOX)</a>
<a name="ln393">     &amp;&amp; (event-&gt;button == 1) &amp;&amp;                                // only accept left mouse click</a>
<a name="ln394">     (dt_get_wtime() - darktable.bauhaus-&gt;opentime &gt;= 0.250f)) // default gtk timeout for double-clicks</a>
<a name="ln395">  {</a>
<a name="ln396">    gtk_widget_set_state_flags(widget, GTK_STATE_FLAG_ACTIVE, TRUE);</a>
<a name="ln397"> </a>
<a name="ln398">    // event might be in wrong system, transform ourselves:</a>
<a name="ln399">    gint wx, wy, x, y;</a>
<a name="ln400">    gdk_window_get_origin(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), &amp;wx, &amp;wy);</a>
<a name="ln401"> </a>
<a name="ln402">    gdk_device_get_position(</a>
<a name="ln403">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln404">        gdk_seat_get_pointer(gdk_display_get_default_seat(gtk_widget_get_display(widget))), 0, &amp;x, &amp;y);</a>
<a name="ln405">#else</a>
<a name="ln406">        gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gdk_display_get_default())), NULL, &amp;x,</a>
<a name="ln407">        &amp;y);</a>
<a name="ln408">#endif</a>
<a name="ln409">    darktable.bauhaus-&gt;end_mouse_x = x - wx;</a>
<a name="ln410">    darktable.bauhaus-&gt;end_mouse_y = y - wy;</a>
<a name="ln411">    dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln412">  }</a>
<a name="ln413">  dt_bauhaus_hide_popup();</a>
<a name="ln414">  return TRUE;</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">static gboolean dt_bauhaus_popup_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln418">{</a>
<a name="ln419">  if(event-&gt;button == 1)</a>
<a name="ln420">  {</a>
<a name="ln421">    if(darktable.bauhaus-&gt;current-&gt;type == DT_BAUHAUS_COMBOBOX</a>
<a name="ln422">       &amp;&amp; dt_get_wtime() - darktable.bauhaus-&gt;opentime &lt; 0.250f) // default gtk timeout for double-clicks</a>
<a name="ln423">    {</a>
<a name="ln424">      // counts as double click, reset:</a>
<a name="ln425">      dt_bauhaus_combobox_data_t *d = &amp;darktable.bauhaus-&gt;current-&gt;data.combobox;</a>
<a name="ln426">      dt_bauhaus_combobox_set(GTK_WIDGET(darktable.bauhaus-&gt;current), d-&gt;defpos);</a>
<a name="ln427">      dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln428">    }</a>
<a name="ln429">    else</a>
<a name="ln430">    {</a>
<a name="ln431">      // only accept left mouse click</a>
<a name="ln432">      darktable.bauhaus-&gt;end_mouse_x = event-&gt;x;</a>
<a name="ln433">      darktable.bauhaus-&gt;end_mouse_y = event-&gt;y;</a>
<a name="ln434">      dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln435">    }</a>
<a name="ln436">  }</a>
<a name="ln437">  else</a>
<a name="ln438">  {</a>
<a name="ln439">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln440">  }</a>
<a name="ln441">  return TRUE;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">static void dt_bauhaus_window_show(GtkWidget *w, gpointer user_data)</a>
<a name="ln445">{</a>
<a name="ln446">  // Could grab the popup_area rather than popup_window, but if so</a>
<a name="ln447">  // then popup_area would get all motion events including those</a>
<a name="ln448">  // outside of the popup. This way the popup_area gets motion events</a>
<a name="ln449">  // related to updating the popup, and popup_window gets all others</a>
<a name="ln450">  // which would be the ones telling it to close the popup.</a>
<a name="ln451">  gtk_grab_add(w);</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">static void dt_bh_init(DtBauhausWidget *class)</a>
<a name="ln455">{</a>
<a name="ln456">  // not sure if we want to use this instead of our code in *_new()</a>
<a name="ln457">  // TODO: the common code from bauhaus_widget_init() could go here.</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">static void dt_bh_class_init(DtBauhausWidgetClass *class)</a>
<a name="ln461">{</a>
<a name="ln462">  darktable.bauhaus-&gt;signals[DT_BAUHAUS_VALUE_CHANGED_SIGNAL]</a>
<a name="ln463">      = g_signal_new(&quot;value-changed&quot;, G_TYPE_FROM_CLASS(class), G_SIGNAL_RUN_LAST, 0, NULL, NULL,</a>
<a name="ln464">                     g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);</a>
<a name="ln465">  darktable.bauhaus-&gt;signals[DT_BAUHAUS_QUAD_PRESSED_SIGNAL]</a>
<a name="ln466">      = g_signal_new(&quot;quad-pressed&quot;, G_TYPE_FROM_CLASS(class), G_SIGNAL_RUN_LAST, 0, NULL, NULL,</a>
<a name="ln467">                     g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);</a>
<a name="ln468"> </a>
<a name="ln469">  // TODO: could init callbacks once per class for more efficiency:</a>
<a name="ln470">  // GtkWidgetClass *widget_class;</a>
<a name="ln471">  // widget_class = GTK_WIDGET_CLASS (class);</a>
<a name="ln472">  // widget_class-&gt;draw = dt_bauhaus_draw;</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">void dt_bauhaus_init()</a>
<a name="ln476">{</a>
<a name="ln477">  darktable.bauhaus = (dt_bauhaus_t *)calloc(1, sizeof(dt_bauhaus_t));</a>
<a name="ln478">  darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln479">  darktable.bauhaus-&gt;current = NULL;</a>
<a name="ln480">  darktable.bauhaus-&gt;popup_area = gtk_drawing_area_new();</a>
<a name="ln481">  gtk_widget_set_name(darktable.bauhaus-&gt;popup_area, &quot;bauhaus-popup&quot;);</a>
<a name="ln482"> </a>
<a name="ln483">  darktable.bauhaus-&gt;line_space = 1.5;</a>
<a name="ln484">  darktable.bauhaus-&gt;line_height = 10;</a>
<a name="ln485">  darktable.bauhaus-&gt;marker_size = 0.25f;</a>
<a name="ln486">  darktable.bauhaus-&gt;label_font_size = 0.6f;</a>
<a name="ln487">  darktable.bauhaus-&gt;value_font_size = 0.6f;</a>
<a name="ln488"> </a>
<a name="ln489">  GtkWidget *root_window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln490">  GtkStyleContext *ctx = gtk_style_context_new();</a>
<a name="ln491">  GtkWidgetPath *path;</a>
<a name="ln492">  path = gtk_widget_path_new ();</a>
<a name="ln493">  int pos = gtk_widget_path_append_type(path, GTK_TYPE_WIDGET);</a>
<a name="ln494">  gtk_widget_path_iter_set_name(path, pos, &quot;iop-plugin-ui&quot;);</a>
<a name="ln495">  gtk_style_context_set_path(ctx, path);</a>
<a name="ln496">  gtk_style_context_set_screen (ctx, gtk_widget_get_screen(root_window));</a>
<a name="ln497"> </a>
<a name="ln498">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_fg&quot;, &amp;darktable.bauhaus-&gt;color_fg);</a>
<a name="ln499">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_fg_insensitive&quot;, &amp;darktable.bauhaus-&gt;color_fg_insensitive);</a>
<a name="ln500">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_bg&quot;, &amp;darktable.bauhaus-&gt;color_bg);</a>
<a name="ln501">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_border&quot;, &amp;darktable.bauhaus-&gt;color_border);</a>
<a name="ln502">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_fill&quot;, &amp;darktable.bauhaus-&gt;color_fill);</a>
<a name="ln503">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_indicator_border&quot;, &amp;darktable.bauhaus-&gt;indicator_border);</a>
<a name="ln504"> </a>
<a name="ln505">  gtk_style_context_lookup_color(ctx, &quot;graph_bg&quot;, &amp;darktable.bauhaus-&gt;graph_bg);</a>
<a name="ln506">  gtk_style_context_lookup_color(ctx, &quot;graph_border&quot;, &amp;darktable.bauhaus-&gt;graph_border);</a>
<a name="ln507">  gtk_style_context_lookup_color(ctx, &quot;graph_grid&quot;, &amp;darktable.bauhaus-&gt;graph_grid);</a>
<a name="ln508">  gtk_style_context_lookup_color(ctx, &quot;graph_fg&quot;, &amp;darktable.bauhaus-&gt;graph_fg);</a>
<a name="ln509">  gtk_style_context_lookup_color(ctx, &quot;graph_fg_active&quot;, &amp;darktable.bauhaus-&gt;graph_fg_active);</a>
<a name="ln510">  gtk_style_context_lookup_color(ctx, &quot;inset_histogram&quot;, &amp;darktable.bauhaus-&gt;inset_histogram);</a>
<a name="ln511"> </a>
<a name="ln512">  PangoFontDescription *pfont = 0;</a>
<a name="ln513">  gtk_style_context_get(ctx, GTK_STATE_FLAG_NORMAL, &quot;font&quot;, &amp;pfont, NULL);</a>
<a name="ln514">  gtk_widget_path_free(path);</a>
<a name="ln515"> </a>
<a name="ln516">  darktable.bauhaus-&gt;pango_font_desc = pfont;</a>
<a name="ln517"> </a>
<a name="ln518">  PangoLayout *layout;</a>
<a name="ln519">  cairo_surface_t *cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 128, 128);</a>
<a name="ln520">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln521">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln522">  pango_layout_set_text(layout, &quot;X&quot;, -1);</a>
<a name="ln523">  pango_layout_set_font_description(layout, darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln524">  pango_cairo_context_set_resolution(pango_layout_get_context(layout), darktable.gui-&gt;dpi);</a>
<a name="ln525">  int pango_width, pango_height;</a>
<a name="ln526">  pango_layout_get_size(layout, &amp;pango_width, &amp;pango_height);</a>
<a name="ln527">  g_object_unref(layout);</a>
<a name="ln528">  cairo_destroy(cr);</a>
<a name="ln529">  cairo_surface_destroy(cst);</a>
<a name="ln530"> </a>
<a name="ln531">  darktable.bauhaus-&gt;scale = 1.3f;</a>
<a name="ln532">  darktable.bauhaus-&gt;line_height = pango_height / PANGO_SCALE;</a>
<a name="ln533">  darktable.bauhaus-&gt;widget_space = INNER_PADDING / 2.0f; // used as a top/bottom margin for widgets</a>
<a name="ln534">  darktable.bauhaus-&gt;quad_width = darktable.bauhaus-&gt;line_height;</a>
<a name="ln535"> </a>
<a name="ln536">  darktable.bauhaus-&gt;baseline_size = darktable.bauhaus-&gt;line_height / 2.0f; // absolute size in Cairo unit</a>
<a name="ln537">  darktable.bauhaus-&gt;border_width = 3.0f; // absolute size in Cairo unit</a>
<a name="ln538">  darktable.bauhaus-&gt;marker_size = (darktable.bauhaus-&gt;baseline_size + darktable.bauhaus-&gt;border_width) * 0.75f;</a>
<a name="ln539"> </a>
<a name="ln540">  // keys are freed with g_free, values are ptrs to the widgets, these don't need to be cleaned up.</a>
<a name="ln541">  darktable.bauhaus-&gt;keymap = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);</a>
<a name="ln542">  darktable.bauhaus-&gt;key_mod = NULL;</a>
<a name="ln543">  darktable.bauhaus-&gt;key_val = NULL;</a>
<a name="ln544">  memset(darktable.bauhaus-&gt;key_history, 0, sizeof(darktable.bauhaus-&gt;key_history));</a>
<a name="ln545"> </a>
<a name="ln546">  // this easily gets keyboard input:</a>
<a name="ln547">  // darktable.bauhaus-&gt;popup_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</a>
<a name="ln548">  // but this doesn't flicker, and the above hack with key input seems to work well.</a>
<a name="ln549">  darktable.bauhaus-&gt;popup_window = gtk_window_new(GTK_WINDOW_POPUP);</a>
<a name="ln550">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln551">  dt_osx_disallow_fullscreen(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln552">#endif</a>
<a name="ln553">  // this is needed for popup, not for toplevel.</a>
<a name="ln554">  // since popup_area gets the focus if we show the window, this is all</a>
<a name="ln555">  // we need.</a>
<a name="ln556">  dt_gui_key_accel_block_on_focus_connect(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln557"> </a>
<a name="ln558">  gtk_widget_set_size_request(darktable.bauhaus-&gt;popup_area, DT_PIXEL_APPLY_DPI(300), DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln559">  gtk_window_set_resizable(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), FALSE);</a>
<a name="ln560">  gtk_window_set_default_size(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), 260, 260);</a>
<a name="ln561">  // gtk_window_set_modal(GTK_WINDOW(c-&gt;popup_window), TRUE);</a>
<a name="ln562">  // gtk_window_set_decorated(GTK_WINDOW(c-&gt;popup_window), FALSE);</a>
<a name="ln563"> </a>
<a name="ln564">  // for pie menu:</a>
<a name="ln565">  // gtk_window_set_position(GTK_WINDOW(c-&gt;popup_window), GTK_WIN_POS_MOUSE);// | GTK_WIN_POS_CENTER);</a>
<a name="ln566"> </a>
<a name="ln567">  // gtk_window_set_keep_above isn't enough on OS X</a>
<a name="ln568">  gtk_window_set_transient_for(GTK_WINDOW(darktable.bauhaus-&gt;popup_window),</a>
<a name="ln569">                               GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)));</a>
<a name="ln570">  gtk_container_add(GTK_CONTAINER(darktable.bauhaus-&gt;popup_window), darktable.bauhaus-&gt;popup_area);</a>
<a name="ln571">  // gtk_window_set_title(GTK_WINDOW(c-&gt;popup_window), _(&quot;dtgtk control popup&quot;));</a>
<a name="ln572">  gtk_window_set_keep_above(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), TRUE);</a>
<a name="ln573">  gtk_window_set_gravity(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), GDK_GRAVITY_STATIC);</a>
<a name="ln574"> </a>
<a name="ln575">  gtk_widget_set_can_focus(darktable.bauhaus-&gt;popup_area, TRUE);</a>
<a name="ln576">  gtk_widget_add_events(darktable.bauhaus-&gt;popup_area, GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln577">                                                       | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln578">                                                       | GDK_KEY_PRESS_MASK | GDK_LEAVE_NOTIFY_MASK</a>
<a name="ln579">                                                       | darktable.gui-&gt;scroll_mask);</a>
<a name="ln580"> </a>
<a name="ln581">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_window), &quot;show&quot;, G_CALLBACK(dt_bauhaus_window_show), (gpointer)NULL);</a>
<a name="ln582">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;draw&quot;, G_CALLBACK(dt_bauhaus_popup_draw),</a>
<a name="ln583">                   (gpointer)NULL);</a>
<a name="ln584">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_window), &quot;motion-notify-event&quot;,</a>
<a name="ln585">                   G_CALLBACK(dt_bauhaus_window_motion_notify), (gpointer)NULL);</a>
<a name="ln586">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_window), &quot;button-press-event&quot;, G_CALLBACK(dt_bauhaus_window_button_press),</a>
<a name="ln587">                   (gpointer)NULL);</a>
<a name="ln588">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;motion-notify-event&quot;,</a>
<a name="ln589">                   G_CALLBACK(dt_bauhaus_popup_motion_notify), (gpointer)NULL);</a>
<a name="ln590">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;leave-notify-event&quot;,</a>
<a name="ln591">                   G_CALLBACK(dt_bauhaus_popup_leave_notify), (gpointer)NULL);</a>
<a name="ln592">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;button-press-event&quot;,</a>
<a name="ln593">                   G_CALLBACK(dt_bauhaus_popup_button_press), (gpointer)NULL);</a>
<a name="ln594">  // this is connected to the widget itself, not the popup. we're only interested</a>
<a name="ln595">  // in mouse release events that are initiated by a press on the original widget.</a>
<a name="ln596">  g_signal_connect (G_OBJECT (darktable.bauhaus-&gt;popup_area), &quot;button-release-event&quot;,</a>
<a name="ln597">                    G_CALLBACK (dt_bauhaus_popup_button_release), (gpointer)NULL);</a>
<a name="ln598">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;key-press-event&quot;,</a>
<a name="ln599">                   G_CALLBACK(dt_bauhaus_popup_key_press), (gpointer)NULL);</a>
<a name="ln600">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;scroll-event&quot;,</a>
<a name="ln601">                   G_CALLBACK(dt_bauhaus_popup_scroll), (gpointer)NULL);</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">void dt_bauhaus_cleanup()</a>
<a name="ln605">{</a>
<a name="ln606">  // TODO: destroy popup window and resources</a>
<a name="ln607">  // TODO: destroy keymap hash table!</a>
<a name="ln608">  g_list_free_full(darktable.bauhaus-&gt;key_mod, (GDestroyNotify)g_free);</a>
<a name="ln609">  g_list_free_full(darktable.bauhaus-&gt;key_val, (GDestroyNotify)g_free);</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">// fwd declare a few callbacks</a>
<a name="ln613">static gboolean dt_bauhaus_slider_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln614">static gboolean dt_bauhaus_slider_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln615">static gboolean dt_bauhaus_slider_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data);</a>
<a name="ln616">static gboolean dt_bauhaus_slider_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);</a>
<a name="ln617">static gboolean dt_bauhaus_slider_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data);</a>
<a name="ln618"> </a>
<a name="ln619"> </a>
<a name="ln620">static gboolean dt_bauhaus_combobox_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln621">static gboolean dt_bauhaus_combobox_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data);</a>
<a name="ln622">static gboolean dt_bauhaus_combobox_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);</a>
<a name="ln623"> </a>
<a name="ln624">// static gboolean</a>
<a name="ln625">// dt_bauhaus_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln626">static gboolean dt_bauhaus_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data);</a>
<a name="ln627"> </a>
<a name="ln628"> </a>
<a name="ln629">// end static init/cleanup</a>
<a name="ln630">// =================================================</a>
<a name="ln631"> </a>
<a name="ln632"> </a>
<a name="ln633"> </a>
<a name="ln634">// common initialization</a>
<a name="ln635">static void dt_bauhaus_widget_init(dt_bauhaus_widget_t *w, dt_iop_module_t *self)</a>
<a name="ln636">{</a>
<a name="ln637">  w-&gt;module = self;</a>
<a name="ln638"> </a>
<a name="ln639">  // no quad icon and no toggle button:</a>
<a name="ln640">  w-&gt;quad_paint = 0;</a>
<a name="ln641">  w-&gt;quad_paint_data = NULL;</a>
<a name="ln642">  w-&gt;quad_toggle = 0;</a>
<a name="ln643">  w-&gt;combo_populate = NULL;</a>
<a name="ln644"> </a>
<a name="ln645"> </a>
<a name="ln646">  switch(w-&gt;type)</a>
<a name="ln647">  {</a>
<a name="ln648">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln649">    {</a>
<a name="ln650">      gtk_widget_set_name(GTK_WIDGET(w), &quot;bauhaus-slider&quot;);</a>
<a name="ln651">      gtk_widget_set_size_request(GTK_WIDGET(w), -1, 2 * darktable.bauhaus-&gt;widget_space + INNER_PADDING + darktable.bauhaus-&gt;baseline_size + get_line_height() - darktable.bauhaus-&gt;border_width / 2.0f);</a>
<a name="ln652">      break;</a>
<a name="ln653">    }</a>
<a name="ln654">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln655">    {</a>
<a name="ln656">      gtk_widget_set_name(GTK_WIDGET(w), &quot;bauhaus-combobox&quot;);</a>
<a name="ln657">      gtk_widget_set_size_request(GTK_WIDGET(w), -1, 2 * darktable.bauhaus-&gt;widget_space + get_line_height());</a>
<a name="ln658">      break;</a>
<a name="ln659">    }</a>
<a name="ln660">  }</a>
<a name="ln661"> </a>
<a name="ln662">  gtk_widget_add_events(GTK_WIDGET(w), GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln663">                                       | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln664">                                       | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK</a>
<a name="ln665">                                       | GDK_FOCUS_CHANGE_MASK</a>
<a name="ln666">                                       | darktable.gui-&gt;scroll_mask);</a>
<a name="ln667"> </a>
<a name="ln668">  g_signal_connect(G_OBJECT(w), &quot;draw&quot;, G_CALLBACK(dt_bauhaus_draw), NULL);</a>
<a name="ln669"> </a>
<a name="ln670">  // for combobox, where mouse-release triggers a selection, we need to catch this</a>
<a name="ln671">  // event where the mouse-press occurred, which will be this widget. we just pass</a>
<a name="ln672">  // it on though:</a>
<a name="ln673">  // g_signal_connect (G_OBJECT (w), &quot;button-release-event&quot;,</a>
<a name="ln674">  //                   G_CALLBACK (dt_bauhaus_popup_button_release), (gpointer)NULL);</a>
<a name="ln675">}</a>
<a name="ln676"> </a>
<a name="ln677">void dt_bauhaus_combobox_set_default(GtkWidget *widget, int def)</a>
<a name="ln678">{</a>
<a name="ln679">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln680">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln681">  d-&gt;defpos = def;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">void dt_bauhaus_slider_set_hard_min(GtkWidget* widget, float val)</a>
<a name="ln685">{</a>
<a name="ln686">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln687">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln688">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln689">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln690">  d-&gt;hard_min = rawval;</a>
<a name="ln691">  d-&gt;min = MAX(d-&gt;min, d-&gt;hard_min);</a>
<a name="ln692">  d-&gt;soft_min = MAX(d-&gt;soft_min, d-&gt;hard_min);</a>
<a name="ln693">  if(rawval &gt; d-&gt;hard_max) dt_bauhaus_slider_set_hard_max(widget,val);</a>
<a name="ln694">  if(pos &lt; val)</a>
<a name="ln695">  {</a>
<a name="ln696">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln697">  }</a>
<a name="ln698">  else</a>
<a name="ln699">  {</a>
<a name="ln700">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln701">  }</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704">float dt_bauhaus_slider_get_hard_min(GtkWidget* widget)</a>
<a name="ln705">{</a>
<a name="ln706">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln707">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln708">  return d-&gt;callback(widget, d-&gt;hard_min, DT_BAUHAUS_GET);</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">void dt_bauhaus_slider_set_hard_max(GtkWidget* widget, float val)</a>
<a name="ln712">{</a>
<a name="ln713">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln714">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln715">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln716">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln717">  d-&gt;hard_max = rawval;</a>
<a name="ln718">  d-&gt;max = MIN(d-&gt;max, d-&gt;hard_max);</a>
<a name="ln719">  d-&gt;soft_max = MIN(d-&gt;soft_max, d-&gt;hard_max);</a>
<a name="ln720">  if(rawval &lt; d-&gt;hard_min) dt_bauhaus_slider_set_hard_min(widget,val);</a>
<a name="ln721">  if(pos &gt; val) {</a>
<a name="ln722">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln723">  }</a>
<a name="ln724">  else</a>
<a name="ln725">  {</a>
<a name="ln726">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln727">  }</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730">float dt_bauhaus_slider_get_hard_max(GtkWidget* widget)</a>
<a name="ln731">{</a>
<a name="ln732">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln733">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln734">  return d-&gt;callback(widget, d-&gt;hard_max, DT_BAUHAUS_GET);</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">void dt_bauhaus_slider_set_soft_min(GtkWidget* widget, float val)</a>
<a name="ln738">{</a>
<a name="ln739">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln740">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln741">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln742">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln743">  d-&gt;soft_min = rawval;</a>
<a name="ln744">  d-&gt;hard_min = MIN(d-&gt;hard_min,d-&gt;soft_min);</a>
<a name="ln745">  d-&gt;min =  d-&gt;soft_min;</a>
<a name="ln746">  if(rawval &gt; d-&gt;soft_max) dt_bauhaus_slider_set_soft_max(widget,val);</a>
<a name="ln747">  if(rawval &gt; d-&gt;hard_max) dt_bauhaus_slider_set_hard_max(widget,val);</a>
<a name="ln748">  if(pos &lt; val)</a>
<a name="ln749">  {</a>
<a name="ln750">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln751">  }</a>
<a name="ln752">  else</a>
<a name="ln753">  {</a>
<a name="ln754">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln755">  }</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758">float dt_bauhaus_slider_get_soft_min(GtkWidget* widget)</a>
<a name="ln759">{</a>
<a name="ln760">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln761">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln762">  return d-&gt;callback(widget, d-&gt;soft_min, DT_BAUHAUS_GET);</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">void dt_bauhaus_slider_set_soft_max(GtkWidget* widget, float val)</a>
<a name="ln766">{</a>
<a name="ln767">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln768">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln769">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln770">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln771">  d-&gt;soft_max = rawval;</a>
<a name="ln772">  d-&gt;hard_max = MAX(d-&gt;soft_max, d-&gt;hard_max);</a>
<a name="ln773">  d-&gt;max =  d-&gt;soft_max;</a>
<a name="ln774">  if(rawval &lt; d-&gt;soft_min) dt_bauhaus_slider_set_soft_min(widget,val);</a>
<a name="ln775">  if(rawval &lt; d-&gt;hard_min) dt_bauhaus_slider_set_hard_min(widget,val);</a>
<a name="ln776">  if(pos &gt; val) {</a>
<a name="ln777">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln778">  } else {</a>
<a name="ln779">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln780">  }</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783">float dt_bauhaus_slider_get_soft_max(GtkWidget* widget)</a>
<a name="ln784">{</a>
<a name="ln785">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln786">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln787">  return d-&gt;callback(widget, d-&gt;soft_max, DT_BAUHAUS_GET);</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790">void dt_bauhaus_slider_set_default(GtkWidget *widget, float def)</a>
<a name="ln791">{</a>
<a name="ln792">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln793">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln794">  float val = d-&gt;callback(widget, def, DT_BAUHAUS_SET);</a>
<a name="ln795">  d-&gt;defpos = (val - d-&gt;min) / (d-&gt;max - d-&gt;min);</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">void dt_bauhaus_slider_enable_soft_boundaries(GtkWidget *widget, float hard_min, float hard_max)</a>
<a name="ln799">{</a>
<a name="ln800">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln801">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln802">  d-&gt;hard_min = d-&gt;callback(widget, hard_min, DT_BAUHAUS_SET);</a>
<a name="ln803">  d-&gt;hard_max = d-&gt;callback(widget, hard_max, DT_BAUHAUS_SET);</a>
<a name="ln804">}</a>
<a name="ln805"> </a>
<a name="ln806">void dt_bauhaus_widget_set_label(GtkWidget *widget, const char *section, const char *label)</a>
<a name="ln807">{</a>
<a name="ln808">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln809">  memset(w-&gt;label, 0, sizeof(w-&gt;label)); // keep valgrind happy</a>
<a name="ln810">  g_strlcpy(w-&gt;label, label, sizeof(w-&gt;label));</a>
<a name="ln811"> </a>
<a name="ln812">  if(w-&gt;module)</a>
<a name="ln813">  {</a>
<a name="ln814">    // construct control path name and insert into keymap:</a>
<a name="ln815">    gchar *path;</a>
<a name="ln816">    if(section &amp;&amp; section[0] != '\0')</a>
<a name="ln817">    {</a>
<a name="ln818">      path = g_strdup_printf(&quot;%s.%s.%s&quot;, w-&gt;module-&gt;name(), section, w-&gt;label);</a>
<a name="ln819">      gchar *section_path = g_strdup_printf(&quot;%s.%s&quot;, w-&gt;module-&gt;name(), section);</a>
<a name="ln820">      if(!g_list_find_custom(darktable.bauhaus-&gt;key_val, section_path, (GCompareFunc)strcmp))</a>
<a name="ln821">        darktable.bauhaus-&gt;key_val</a>
<a name="ln822">            = g_list_insert_sorted(darktable.bauhaus-&gt;key_val, section_path, (GCompareFunc)strcmp);</a>
<a name="ln823">      else</a>
<a name="ln824">        g_free(section_path);</a>
<a name="ln825">    }</a>
<a name="ln826">    else</a>
<a name="ln827">      path = g_strdup_printf(&quot;%s.%s&quot;, w-&gt;module-&gt;name(), w-&gt;label);</a>
<a name="ln828">    if(!g_hash_table_lookup(darktable.bauhaus-&gt;keymap, path))</a>
<a name="ln829">    {</a>
<a name="ln830">      // also insert into sorted tab-complete list.</a>
<a name="ln831">      // (but only if this is the first time we insert this path)</a>
<a name="ln832">      gchar *mod = g_strdup(path);</a>
<a name="ln833">      gchar *val = g_strstr_len(mod, strlen(mod), &quot;.&quot;);</a>
<a name="ln834">      if(val)</a>
<a name="ln835">      {</a>
<a name="ln836">        *val = 0;</a>
<a name="ln837">        if(!g_list_find_custom(darktable.bauhaus-&gt;key_mod, mod, (GCompareFunc)strcmp))</a>
<a name="ln838">          darktable.bauhaus-&gt;key_mod</a>
<a name="ln839">              = g_list_insert_sorted(darktable.bauhaus-&gt;key_mod, mod, (GCompareFunc)strcmp);</a>
<a name="ln840">        else</a>
<a name="ln841">          g_free(mod);</a>
<a name="ln842"> </a>
<a name="ln843">        // unfortunately need our own string, as replace in the hashtable below might destroy this pointer.</a>
<a name="ln844">        darktable.bauhaus-&gt;key_val</a>
<a name="ln845">            = g_list_insert_sorted(darktable.bauhaus-&gt;key_val, g_strdup(path), (GCompareFunc)strcmp);</a>
<a name="ln846">      }</a>
<a name="ln847">    }</a>
<a name="ln848">    // might free an old path</a>
<a name="ln849">    g_hash_table_replace(darktable.bauhaus-&gt;keymap, path, w);</a>
<a name="ln850">    gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln851">  }</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">const char* dt_bauhaus_widget_get_label(GtkWidget *widget)</a>
<a name="ln855">{</a>
<a name="ln856">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln857">  return w-&gt;label;</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860">void dt_bauhaus_widget_set_quad_paint(GtkWidget *widget, dt_bauhaus_quad_paint_f f, int paint_flags, void *paint_data)</a>
<a name="ln861">{</a>
<a name="ln862">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln863">  w-&gt;quad_paint = f;</a>
<a name="ln864">  w-&gt;quad_paint_flags = paint_flags;</a>
<a name="ln865">  w-&gt;quad_paint_data = paint_data;</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868">// make this quad a toggle button:</a>
<a name="ln869">void dt_bauhaus_widget_set_quad_toggle(GtkWidget *widget, int toggle)</a>
<a name="ln870">{</a>
<a name="ln871">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln872">  w-&gt;quad_toggle = toggle;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">void dt_bauhaus_widget_set_quad_active(GtkWidget *widget, int active)</a>
<a name="ln876">{</a>
<a name="ln877">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln878">  if (active)</a>
<a name="ln879">    w-&gt;quad_paint_flags |= CPF_ACTIVE;</a>
<a name="ln880">  else</a>
<a name="ln881">    w-&gt;quad_paint_flags &amp;= ~CPF_ACTIVE;</a>
<a name="ln882">  gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885">int dt_bauhaus_widget_get_quad_active(GtkWidget *widget)</a>
<a name="ln886">{</a>
<a name="ln887">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln888">  return (w-&gt;quad_paint_flags &amp; CPF_ACTIVE) == CPF_ACTIVE;</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891">static float _default_linear_callback(GtkWidget *self, float value, dt_bauhaus_callback_t dir)</a>
<a name="ln892">{</a>
<a name="ln893">  // regardless of dir: input &lt;-&gt; output</a>
<a name="ln894">  return value;</a>
<a name="ln895">}</a>
<a name="ln896"> </a>
<a name="ln897">static void dt_bauhaus_slider_destroy(dt_bauhaus_widget_t *widget, gpointer user_data)</a>
<a name="ln898">{</a>
<a name="ln899">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln900">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln901">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln902">  if(d-&gt;timeout_handle) g_source_remove(d-&gt;timeout_handle);</a>
<a name="ln903">  d-&gt;timeout_handle = 0;</a>
<a name="ln904">}</a>
<a name="ln905"> </a>
<a name="ln906">GtkWidget *dt_bauhaus_slider_new(dt_iop_module_t *self)</a>
<a name="ln907">{</a>
<a name="ln908">  return dt_bauhaus_slider_new_with_range(self, 0.0, 1.0, 0.1, 0.5, 3);</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911">GtkWidget *dt_bauhaus_slider_new_with_range(dt_iop_module_t *self, float min, float max, float step,</a>
<a name="ln912">                                            float defval, int digits)</a>
<a name="ln913">{</a>
<a name="ln914">  return dt_bauhaus_slider_new_with_range_and_feedback(self, min, max, step, defval, digits, 1);</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917">GtkWidget *dt_bauhaus_slider_new_with_range_and_feedback(dt_iop_module_t *self, float min, float max,</a>
<a name="ln918">                                                         float step, float defval, int digits, int feedback)</a>
<a name="ln919">{</a>
<a name="ln920">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(g_object_new(DT_BAUHAUS_WIDGET_TYPE, NULL));</a>
<a name="ln921">  return dt_bauhaus_slider_from_widget(w,self, min, max, step, defval, digits, feedback);</a>
<a name="ln922">}</a>
<a name="ln923">GtkWidget *dt_bauhaus_slider_from_widget(dt_bauhaus_widget_t* w,dt_iop_module_t *self, float min, float max,</a>
<a name="ln924">                                                         float step, float defval, int digits, int feedback)</a>
<a name="ln925">{</a>
<a name="ln926">  w-&gt;type = DT_BAUHAUS_SLIDER;</a>
<a name="ln927">  dt_bauhaus_widget_init(w, self);</a>
<a name="ln928">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln929">  d-&gt;min = d-&gt;soft_min = d-&gt;hard_min = min;</a>
<a name="ln930">  d-&gt;max = d-&gt;soft_max = d-&gt;hard_max = max;</a>
<a name="ln931">  d-&gt;step = step;</a>
<a name="ln932">  // normalize default:</a>
<a name="ln933">  d-&gt;defpos = (defval - min) / (max - min);</a>
<a name="ln934">  d-&gt;pos = d-&gt;defpos;</a>
<a name="ln935">  d-&gt;oldpos = d-&gt;defpos;</a>
<a name="ln936">  d-&gt;scale = 5.0f * step / (max - min);</a>
<a name="ln937">  d-&gt;digits = digits;</a>
<a name="ln938">  snprintf(d-&gt;format, sizeof(d-&gt;format), &quot;%%.0%df&quot;, digits);</a>
<a name="ln939"> </a>
<a name="ln940">  d-&gt;grad_cnt = 0;</a>
<a name="ln941"> </a>
<a name="ln942">  d-&gt;fill_feedback = feedback;</a>
<a name="ln943"> </a>
<a name="ln944">  d-&gt;is_dragging = 0;</a>
<a name="ln945">  d-&gt;is_changed = 0;</a>
<a name="ln946">  d-&gt;timeout_handle = 0;</a>
<a name="ln947">  d-&gt;callback = _default_linear_callback;</a>
<a name="ln948"> </a>
<a name="ln949">  gtk_widget_add_events(GTK_WIDGET(w), GDK_KEY_PRESS_MASK);</a>
<a name="ln950">  gtk_widget_set_can_focus(GTK_WIDGET(w), TRUE);</a>
<a name="ln951"> </a>
<a name="ln952">  g_signal_connect(G_OBJECT(w), &quot;button-press-event&quot;, G_CALLBACK(dt_bauhaus_slider_button_press),</a>
<a name="ln953">                   (gpointer)NULL);</a>
<a name="ln954">  g_signal_connect(G_OBJECT(w), &quot;button-release-event&quot;, G_CALLBACK(dt_bauhaus_slider_button_release),</a>
<a name="ln955">                   (gpointer)NULL);</a>
<a name="ln956">  g_signal_connect(G_OBJECT(w), &quot;scroll-event&quot;, G_CALLBACK(dt_bauhaus_slider_scroll), (gpointer)NULL);</a>
<a name="ln957">  g_signal_connect(G_OBJECT(w), &quot;key-press-event&quot;, G_CALLBACK(dt_bauhaus_slider_key_press), (gpointer)NULL);</a>
<a name="ln958">  g_signal_connect(G_OBJECT(w), &quot;motion-notify-event&quot;, G_CALLBACK(dt_bauhaus_slider_motion_notify),</a>
<a name="ln959">                   (gpointer)NULL);</a>
<a name="ln960">  g_signal_connect(G_OBJECT(w), &quot;destroy&quot;, G_CALLBACK(dt_bauhaus_slider_destroy), (gpointer)NULL);</a>
<a name="ln961">  return GTK_WIDGET(w);</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">static void dt_bauhaus_combobox_destroy(dt_bauhaus_widget_t *widget, gpointer user_data)</a>
<a name="ln965">{</a>
<a name="ln966">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln967">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln968">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln969">  g_list_free_full(d-&gt;entries, free_combobox_entry);</a>
<a name="ln970">  d-&gt;entries = NULL;</a>
<a name="ln971">  d-&gt;num_labels = 0;</a>
<a name="ln972">  d-&gt;active = -1;</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">GtkWidget *dt_bauhaus_combobox_new(dt_iop_module_t *self)</a>
<a name="ln976">{</a>
<a name="ln977">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(g_object_new(DT_BAUHAUS_WIDGET_TYPE, NULL));</a>
<a name="ln978">  dt_bauhaus_combobox_from_widget(w,self);</a>
<a name="ln979">  return GTK_WIDGET(w);</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">void dt_bauhaus_combobox_from_widget(dt_bauhaus_widget_t* w,dt_iop_module_t *self)</a>
<a name="ln983">{</a>
<a name="ln984">  w-&gt;type = DT_BAUHAUS_COMBOBOX;</a>
<a name="ln985">  dt_bauhaus_widget_init(w, self);</a>
<a name="ln986">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln987">  d-&gt;entries = NULL;</a>
<a name="ln988">  d-&gt;num_labels = 0;</a>
<a name="ln989">  d-&gt;defpos = 0;</a>
<a name="ln990">  d-&gt;active = -1;</a>
<a name="ln991">  d-&gt;editable = 0;</a>
<a name="ln992">  memset(d-&gt;text, 0, sizeof(d-&gt;text));</a>
<a name="ln993"> </a>
<a name="ln994">  gtk_widget_add_events(GTK_WIDGET(w), GDK_KEY_PRESS_MASK);</a>
<a name="ln995">  gtk_widget_set_can_focus(GTK_WIDGET(w), TRUE);</a>
<a name="ln996"> </a>
<a name="ln997">  g_signal_connect(G_OBJECT(w), &quot;button-press-event&quot;, G_CALLBACK(dt_bauhaus_combobox_button_press),</a>
<a name="ln998">                   (gpointer)NULL);</a>
<a name="ln999">  g_signal_connect(G_OBJECT(w), &quot;button-release-event&quot;, G_CALLBACK(dt_bauhaus_popup_button_release),</a>
<a name="ln1000">                   (gpointer)NULL);</a>
<a name="ln1001">  g_signal_connect(G_OBJECT(w), &quot;scroll-event&quot;, G_CALLBACK(dt_bauhaus_combobox_scroll), (gpointer)NULL);</a>
<a name="ln1002">  g_signal_connect(G_OBJECT(w), &quot;key-press-event&quot;, G_CALLBACK(dt_bauhaus_combobox_key_press), (gpointer)NULL);</a>
<a name="ln1003">  g_signal_connect(G_OBJECT(w), &quot;destroy&quot;, G_CALLBACK(dt_bauhaus_combobox_destroy), (gpointer)NULL);</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006">void dt_bauhaus_combobox_add_populate_fct(GtkWidget *widget, void (*fct)(GtkWidget *w, struct dt_iop_module_t **module))</a>
<a name="ln1007">{</a>
<a name="ln1008">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1009">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1010">  w-&gt;combo_populate = fct;</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">void dt_bauhaus_combobox_add(GtkWidget *widget, const char *text)</a>
<a name="ln1014">{</a>
<a name="ln1015">  dt_bauhaus_combobox_add_full(widget, text, DT_BAUHAUS_COMBOBOX_ALIGN_RIGHT, NULL, NULL);</a>
<a name="ln1016">}</a>
<a name="ln1017"> </a>
<a name="ln1018">void dt_bauhaus_combobox_add_aligned(GtkWidget *widget, const char *text, dt_bauhaus_combobox_alignment_t align)</a>
<a name="ln1019">{</a>
<a name="ln1020">  dt_bauhaus_combobox_add_full(widget, text, align, NULL, NULL);</a>
<a name="ln1021">}</a>
<a name="ln1022"> </a>
<a name="ln1023">void dt_bauhaus_combobox_add_full(GtkWidget *widget, const char *text, dt_bauhaus_combobox_alignment_t align,</a>
<a name="ln1024">                                  gpointer data, void (free_func)(void *data))</a>
<a name="ln1025">{</a>
<a name="ln1026">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1027">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1028">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1029">  d-&gt;num_labels++;</a>
<a name="ln1030">  dt_bauhaus_combobox_entry_t *entry = new_combobox_entry(text, align, TRUE, data, free_func);</a>
<a name="ln1031">  d-&gt;entries = g_list_append(d-&gt;entries, entry);</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034">void dt_bauhaus_combobox_set_editable(GtkWidget *widget, int editable)</a>
<a name="ln1035">{</a>
<a name="ln1036">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1037">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1038">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1039">  d-&gt;editable = editable ? 1 : 0;</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">int dt_bauhaus_combobox_get_editable(GtkWidget *widget)</a>
<a name="ln1043">{</a>
<a name="ln1044">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1045">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return 0;</a>
<a name="ln1046">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1047">  return d-&gt;editable;</a>
<a name="ln1048">}</a>
<a name="ln1049"> </a>
<a name="ln1050">void dt_bauhaus_combobox_remove_at(GtkWidget *widget, int pos)</a>
<a name="ln1051">{</a>
<a name="ln1052">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1053">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1054">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1055"> </a>
<a name="ln1056">  if(pos &lt; 0 || pos &gt;= d-&gt;num_labels) return;</a>
<a name="ln1057"> </a>
<a name="ln1058">  GList *rm = g_list_nth(d-&gt;entries, pos);</a>
<a name="ln1059">  free_combobox_entry(rm-&gt;data);</a>
<a name="ln1060">  d-&gt;entries = g_list_delete_link(d-&gt;entries, rm);</a>
<a name="ln1061"> </a>
<a name="ln1062">  d-&gt;num_labels--;</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">void dt_bauhaus_combobox_insert(GtkWidget *widget, const char *text,int pos)</a>
<a name="ln1066">{</a>
<a name="ln1067">  dt_bauhaus_combobox_insert_full(widget, text, DT_BAUHAUS_COMBOBOX_ALIGN_RIGHT, NULL, NULL, pos);</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">void dt_bauhaus_combobox_insert_full(GtkWidget *widget, const char *text, dt_bauhaus_combobox_alignment_t align,</a>
<a name="ln1071">                                     gpointer data, void (*free_func)(void *), int pos)</a>
<a name="ln1072">{</a>
<a name="ln1073">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1074">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1075">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1076">  d-&gt;num_labels++;</a>
<a name="ln1077">  d-&gt;entries = g_list_insert(d-&gt;entries, new_combobox_entry(text, align, TRUE, data, free_func), pos);</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">int dt_bauhaus_combobox_length(GtkWidget *widget)</a>
<a name="ln1081">{</a>
<a name="ln1082">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1083">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return 0;</a>
<a name="ln1084">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1085"> </a>
<a name="ln1086">  return d-&gt;num_labels;</a>
<a name="ln1087">}</a>
<a name="ln1088"> </a>
<a name="ln1089">const char *dt_bauhaus_combobox_get_text(GtkWidget *widget)</a>
<a name="ln1090">{</a>
<a name="ln1091">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1092">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return NULL;</a>
<a name="ln1093">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1094"> </a>
<a name="ln1095">  if(d-&gt;editable &amp;&amp; d-&gt;active &lt; 0)</a>
<a name="ln1096">  {</a>
<a name="ln1097">    return d-&gt;text;</a>
<a name="ln1098">  }</a>
<a name="ln1099">  else</a>
<a name="ln1100">  {</a>
<a name="ln1101">    if(d-&gt;active &lt; 0 || d-&gt;active &gt;= d-&gt;num_labels) return NULL;</a>
<a name="ln1102">    const dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(d-&gt;entries, d-&gt;active);</a>
<a name="ln1103">    return entry-&gt;label;</a>
<a name="ln1104">  }</a>
<a name="ln1105">  return NULL;</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108">gpointer dt_bauhaus_combobox_get_data(GtkWidget *widget)</a>
<a name="ln1109">{</a>
<a name="ln1110">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1111">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return NULL;</a>
<a name="ln1112">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1113">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(d-&gt;entries, d-&gt;active);</a>
<a name="ln1114">  return entry ? entry-&gt;data : NULL;</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117">void dt_bauhaus_combobox_clear(GtkWidget *widget)</a>
<a name="ln1118">{</a>
<a name="ln1119">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1120">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1121">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1122">  d-&gt;active = -1;</a>
<a name="ln1123">  g_list_free_full(d-&gt;entries, free_combobox_entry);</a>
<a name="ln1124">  d-&gt;entries = NULL;</a>
<a name="ln1125">  d-&gt;num_labels = 0;</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128">const GList *dt_bauhaus_combobox_get_entries(GtkWidget *widget)</a>
<a name="ln1129">{</a>
<a name="ln1130">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1131">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return 0;</a>
<a name="ln1132">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1133">  return d-&gt;entries;</a>
<a name="ln1134">}</a>
<a name="ln1135"> </a>
<a name="ln1136">void dt_bauhaus_combobox_set_text(GtkWidget *widget, const char *text)</a>
<a name="ln1137">{</a>
<a name="ln1138">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1139">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1140">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1141">  if(!d-&gt;editable) return;</a>
<a name="ln1142">  g_strlcpy(d-&gt;text, text, sizeof(d-&gt;text));</a>
<a name="ln1143">}</a>
<a name="ln1144"> </a>
<a name="ln1145">void dt_bauhaus_combobox_set(GtkWidget *widget, int pos)</a>
<a name="ln1146">{</a>
<a name="ln1147">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1148">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1149">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1150">  d-&gt;active = CLAMP(pos, -1, d-&gt;num_labels - 1);</a>
<a name="ln1151">  gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln1152">  if(!darktable.gui-&gt;reset) g_signal_emit_by_name(G_OBJECT(w), &quot;value-changed&quot;);</a>
<a name="ln1153">}</a>
<a name="ln1154"> </a>
<a name="ln1155">gboolean dt_bauhaus_combobox_set_from_text(GtkWidget *widget, const char *text)</a>
<a name="ln1156">{</a>
<a name="ln1157">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1158">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln1159">  if(!text) return FALSE;</a>
<a name="ln1160">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1161">  int i = 0;</a>
<a name="ln1162">  for(GList *iter = d-&gt;entries; iter; iter = g_list_next(iter), i++)</a>
<a name="ln1163">  {</a>
<a name="ln1164">    const dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)iter-&gt;data;</a>
<a name="ln1165">    if(!g_strcmp0(entry-&gt;label, text))</a>
<a name="ln1166">    {</a>
<a name="ln1167">      dt_bauhaus_combobox_set(widget, i);</a>
<a name="ln1168">      return TRUE;</a>
<a name="ln1169">    }</a>
<a name="ln1170">  }</a>
<a name="ln1171">  return FALSE;</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174">int dt_bauhaus_combobox_get(GtkWidget *widget)</a>
<a name="ln1175">{</a>
<a name="ln1176">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1177">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return -1;</a>
<a name="ln1178">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1179">  return d-&gt;active;</a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182">void dt_bauhaus_combobox_entry_set_sensitive(GtkWidget *widget, int pos, gboolean sensitive)</a>
<a name="ln1183">{</a>
<a name="ln1184">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1185">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1186">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1187">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(d-&gt;entries, pos);</a>
<a name="ln1188">  if(entry)</a>
<a name="ln1189">    entry-&gt;sensitive = sensitive;</a>
<a name="ln1190">}</a>
<a name="ln1191"> </a>
<a name="ln1192">void dt_bauhaus_slider_clear_stops(GtkWidget *widget)</a>
<a name="ln1193">{</a>
<a name="ln1194">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1195">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1196">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1197">  d-&gt;grad_cnt = 0;</a>
<a name="ln1198">}</a>
<a name="ln1199"> </a>
<a name="ln1200">void dt_bauhaus_slider_set_stop(GtkWidget *widget, float stop, float r, float g, float b)</a>
<a name="ln1201">{</a>
<a name="ln1202">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1203">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1204">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1205">  float rawstop = d-&gt;callback(widget, stop, DT_BAUHAUS_SET);</a>
<a name="ln1206">  // need to replace stop?</a>
<a name="ln1207">  for(int k = 0; k &lt; d-&gt;grad_cnt; k++)</a>
<a name="ln1208">  {</a>
<a name="ln1209">    if(d-&gt;grad_pos[k] == rawstop)</a>
<a name="ln1210">    {</a>
<a name="ln1211">      d-&gt;grad_col[k][0] = r;</a>
<a name="ln1212">      d-&gt;grad_col[k][1] = g;</a>
<a name="ln1213">      d-&gt;grad_col[k][2] = b;</a>
<a name="ln1214">      return;</a>
<a name="ln1215">    }</a>
<a name="ln1216">  }</a>
<a name="ln1217">  // new stop:</a>
<a name="ln1218">  if(d-&gt;grad_cnt &lt; DT_BAUHAUS_SLIDER_MAX_STOPS)</a>
<a name="ln1219">  {</a>
<a name="ln1220">    int k = d-&gt;grad_cnt++;</a>
<a name="ln1221">    d-&gt;grad_pos[k] = rawstop;</a>
<a name="ln1222">    d-&gt;grad_col[k][0] = r;</a>
<a name="ln1223">    d-&gt;grad_col[k][1] = g;</a>
<a name="ln1224">    d-&gt;grad_col[k][2] = b;</a>
<a name="ln1225">  }</a>
<a name="ln1226">  else</a>
<a name="ln1227">  {</a>
<a name="ln1228">    fprintf(stderr, &quot;[bauhaus_slider_set_stop] only %d stops allowed.\n&quot;, DT_BAUHAUS_SLIDER_MAX_STOPS);</a>
<a name="ln1229">  }</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232"> </a>
<a name="ln1233">static void draw_equilateral_triangle(cairo_t *cr, float radius)</a>
<a name="ln1234">{</a>
<a name="ln1235">  const float sin = 0.866025404 * radius;</a>
<a name="ln1236">  const float cos = 0.5f * radius;</a>
<a name="ln1237">  cairo_move_to(cr, 0.0, radius);</a>
<a name="ln1238">  cairo_line_to(cr, -sin, -cos);</a>
<a name="ln1239">  cairo_line_to(cr, sin, -cos);</a>
<a name="ln1240">  cairo_line_to(cr, 0.0, radius);</a>
<a name="ln1241">}</a>
<a name="ln1242"> </a>
<a name="ln1243"> </a>
<a name="ln1244">static void dt_bauhaus_draw_indicator(dt_bauhaus_widget_t *w, float pos, cairo_t *cr, const GdkRGBA *fg_color, const GdkRGBA *border_color)</a>
<a name="ln1245">{</a>
<a name="ln1246">  // draw scale indicator (the tiny triangle)</a>
<a name="ln1247">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1248">  GtkAllocation allocation;</a>
<a name="ln1249">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1250">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1251">  const float wd = allocation.width;</a>
<a name="ln1252">  const float border_width = darktable.bauhaus-&gt;border_width;</a>
<a name="ln1253">  const float size = darktable.bauhaus-&gt;marker_size;</a>
<a name="ln1254"> </a>
<a name="ln1255">  cairo_save(cr);</a>
<a name="ln1256">  cairo_translate(cr, slider_coordinate(pos, wd), get_line_height() + INNER_PADDING - border_width * 0.25f);</a>
<a name="ln1257">  cairo_scale(cr, 1.0f, -1.0f);</a>
<a name="ln1258">  cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln1259"> </a>
<a name="ln1260">  // draw the outer triangle</a>
<a name="ln1261">  draw_equilateral_triangle(cr, size);</a>
<a name="ln1262">  cairo_set_line_width(cr, border_width);</a>
<a name="ln1263">  set_color(cr, *border_color);</a>
<a name="ln1264">  cairo_stroke(cr);</a>
<a name="ln1265"> </a>
<a name="ln1266">  draw_equilateral_triangle(cr, size - border_width);</a>
<a name="ln1267">  cairo_clip(cr);</a>
<a name="ln1268"> </a>
<a name="ln1269">  // draw the inner triangle</a>
<a name="ln1270">  draw_equilateral_triangle(cr, size - border_width);</a>
<a name="ln1271">  set_color(cr, *fg_color);</a>
<a name="ln1272">  cairo_set_line_width(cr, border_width);</a>
<a name="ln1273"> </a>
<a name="ln1274">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1275"> </a>
<a name="ln1276">  if(d-&gt;fill_feedback)</a>
<a name="ln1277">    cairo_fill(cr); // Plain indicator (regular sliders)</a>
<a name="ln1278">  else</a>
<a name="ln1279">    cairo_stroke(cr);  // Hollow indicator to see a color through it (gradient sliders)</a>
<a name="ln1280"> </a>
<a name="ln1281">  cairo_restore(cr);</a>
<a name="ln1282">}</a>
<a name="ln1283"> </a>
<a name="ln1284">static void dt_bauhaus_draw_quad(dt_bauhaus_widget_t *w, cairo_t *cr)</a>
<a name="ln1285">{</a>
<a name="ln1286">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1287">  const gboolean sensitive = gtk_widget_is_sensitive(GTK_WIDGET(w));</a>
<a name="ln1288">  GtkAllocation allocation;</a>
<a name="ln1289">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1290">  const int width = allocation.width;</a>
<a name="ln1291">  const int height = inner_height(allocation);</a>
<a name="ln1292"> </a>
<a name="ln1293">  if(w-&gt;quad_paint)</a>
<a name="ln1294">  {</a>
<a name="ln1295">    cairo_save(cr);</a>
<a name="ln1296"> </a>
<a name="ln1297">    if(sensitive &amp;&amp; (w-&gt;quad_paint_flags &amp; CPF_ACTIVE))</a>
<a name="ln1298">      set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1299">    else</a>
<a name="ln1300">      set_color(cr, darktable.bauhaus-&gt;color_fg_insensitive);</a>
<a name="ln1301"> </a>
<a name="ln1302">    w-&gt;quad_paint(cr, width - darktable.bauhaus-&gt;quad_width,  // x</a>
<a name="ln1303">                      0.0,        // y</a>
<a name="ln1304">                      darktable.bauhaus-&gt;quad_width,          // width</a>
<a name="ln1305">                      darktable.bauhaus-&gt;quad_width,          // height</a>
<a name="ln1306">                      w-&gt;quad_paint_flags, w-&gt;quad_paint_data);</a>
<a name="ln1307"> </a>
<a name="ln1308">    cairo_restore(cr);</a>
<a name="ln1309">  }</a>
<a name="ln1310">  else</a>
<a name="ln1311">  {</a>
<a name="ln1312">    // draw active area square:</a>
<a name="ln1313">    cairo_save(cr);</a>
<a name="ln1314">    if(sensitive)</a>
<a name="ln1315">      set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1316">    else</a>
<a name="ln1317">      set_color(cr, darktable.bauhaus-&gt;color_fg_insensitive);</a>
<a name="ln1318">    switch(w-&gt;type)</a>
<a name="ln1319">    {</a>
<a name="ln1320">      case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1321">        cairo_translate(cr, width - darktable.bauhaus-&gt;quad_width * .5f, height * .33f);</a>
<a name="ln1322">        draw_equilateral_triangle(cr, darktable.bauhaus-&gt;quad_width * .25f);</a>
<a name="ln1323">        cairo_fill_preserve(cr);</a>
<a name="ln1324">        cairo_set_line_width(cr, 0.5);</a>
<a name="ln1325">        set_color(cr, darktable.bauhaus-&gt;color_border);</a>
<a name="ln1326">        cairo_stroke(cr);</a>
<a name="ln1327">        break;</a>
<a name="ln1328">      case DT_BAUHAUS_SLIDER:</a>
<a name="ln1329">        break;</a>
<a name="ln1330">      default:</a>
<a name="ln1331">        cairo_set_source_rgb(cr, 1.0, 0.0, 0.0);</a>
<a name="ln1332">        cairo_rectangle(cr, width - darktable.bauhaus-&gt;quad_width, 0.0, darktable.bauhaus-&gt;quad_width, darktable.bauhaus-&gt;quad_width);</a>
<a name="ln1333">        cairo_fill(cr);</a>
<a name="ln1334">        break;</a>
<a name="ln1335">    }</a>
<a name="ln1336">    cairo_restore(cr);</a>
<a name="ln1337">  }</a>
<a name="ln1338">}</a>
<a name="ln1339"> </a>
<a name="ln1340">static void dt_bauhaus_draw_baseline(dt_bauhaus_widget_t *w, cairo_t *cr)</a>
<a name="ln1341">{</a>
<a name="ln1342">  // draw line for orientation in slider</a>
<a name="ln1343">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1344">  GtkAllocation allocation;</a>
<a name="ln1345">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1346">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1347">  const int wd = allocation.width;</a>
<a name="ln1348">  const float slider_width = wd - darktable.bauhaus-&gt;quad_width - INNER_PADDING;</a>
<a name="ln1349">  cairo_save(cr);</a>
<a name="ln1350">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1351"> </a>
<a name="ln1352">  // pos of baseline</a>
<a name="ln1353">  const float htm = darktable.bauhaus-&gt;line_height + INNER_PADDING;</a>
<a name="ln1354"> </a>
<a name="ln1355">  // thickness of baseline</a>
<a name="ln1356">  const float htM = darktable.bauhaus-&gt;baseline_size - darktable.bauhaus-&gt;border_width;</a>
<a name="ln1357"> </a>
<a name="ln1358">  // the background of the line</a>
<a name="ln1359">  cairo_pattern_t *gradient = NULL;</a>
<a name="ln1360">  cairo_rectangle(cr, 0, htm, slider_width, htM);</a>
<a name="ln1361"> </a>
<a name="ln1362">  if(d-&gt;grad_cnt &gt; 0)</a>
<a name="ln1363">  {</a>
<a name="ln1364">    // gradient line as used in some modules</a>
<a name="ln1365">    gradient = cairo_pattern_create_linear(0, 0, slider_width, htM);</a>
<a name="ln1366">    for(int k = 0; k &lt; d-&gt;grad_cnt; k++)</a>
<a name="ln1367">      cairo_pattern_add_color_stop_rgba(gradient, d-&gt;grad_pos[k], d-&gt;grad_col[k][0], d-&gt;grad_col[k][1],</a>
<a name="ln1368">                                        d-&gt;grad_col[k][2], 0.4f);</a>
<a name="ln1369">    cairo_set_source(cr, gradient);</a>
<a name="ln1370">  }</a>
<a name="ln1371">  else</a>
<a name="ln1372">  {</a>
<a name="ln1373">    // regular baseline</a>
<a name="ln1374">    set_color(cr, darktable.bauhaus-&gt;color_bg);</a>
<a name="ln1375">  }</a>
<a name="ln1376"> </a>
<a name="ln1377">  cairo_fill(cr);</a>
<a name="ln1378"> </a>
<a name="ln1379">  // get the reference of the slider aka the position of the 0 value</a>
<a name="ln1380">  const float origin = fmaxf(fminf(-(d-&gt;hard_min / (d-&gt;hard_max - d-&gt;hard_min)) * slider_width, slider_width), 0.0f);</a>
<a name="ln1381">  const float position = d-&gt;pos * slider_width;</a>
<a name="ln1382">  const float delta = position - origin;</a>
<a name="ln1383"> </a>
<a name="ln1384">  // have a `fill ratio feel' from zero to current position</a>
<a name="ln1385">  // - but only if set</a>
<a name="ln1386">  if(d-&gt;fill_feedback)</a>
<a name="ln1387">  {</a>
<a name="ln1388">    // only brighten, useful for colored sliders to not get too faint:</a>
<a name="ln1389">    cairo_set_operator(cr, CAIRO_OPERATOR_SCREEN);</a>
<a name="ln1390">    set_color(cr, darktable.bauhaus-&gt;color_fill);</a>
<a name="ln1391">    cairo_rectangle(cr, origin, htm, delta, htM);</a>
<a name="ln1392">    cairo_fill(cr);</a>
<a name="ln1393"> </a>
<a name="ln1394">    // change back to default cairo operator:</a>
<a name="ln1395">    cairo_set_operator(cr, CAIRO_OPERATOR_OVER);</a>
<a name="ln1396">  }</a>
<a name="ln1397"> </a>
<a name="ln1398">  // draw the 0 reference graduation if it's different than the bounds of the slider</a>
<a name="ln1399">  const float graduation_top = htm + htM + 2.0f * darktable.bauhaus-&gt;border_width;</a>
<a name="ln1400">  const float graduation_height = darktable.bauhaus-&gt;border_width / 2.0f;</a>
<a name="ln1401">  set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1402"> </a>
<a name="ln1403">  // If the max of the slider is 180 or 360, it is likely a hue slider in degrees</a>
<a name="ln1404">  // a zero in periodic stuff has not much meaning so we skip it</a>
<a name="ln1405">  if(d-&gt;hard_max != 180.0f &amp;&amp; d-&gt;hard_max != 326.0f)</a>
<a name="ln1406">  {</a>
<a name="ln1407">    // translate the dot if it overflows the widget frame</a>
<a name="ln1408">    if(origin &lt; graduation_height)</a>
<a name="ln1409">      cairo_arc(cr, graduation_height, graduation_top, graduation_height, 0, 2 * M_PI);</a>
<a name="ln1410">    else if(origin &gt; slider_width - graduation_height)</a>
<a name="ln1411">      cairo_arc(cr, slider_width - graduation_height, graduation_top, graduation_height, 0, 2 * M_PI);</a>
<a name="ln1412">    else</a>
<a name="ln1413">      cairo_arc(cr, origin, graduation_top, graduation_height, 0, 2 * M_PI);</a>
<a name="ln1414">}</a>
<a name="ln1415"> </a>
<a name="ln1416">  cairo_fill(cr);</a>
<a name="ln1417">  cairo_restore(cr);</a>
<a name="ln1418"> </a>
<a name="ln1419">  if(d-&gt;grad_cnt &gt; 0) cairo_pattern_destroy(gradient);</a>
<a name="ln1420">}</a>
<a name="ln1421"> </a>
<a name="ln1422">static void dt_bauhaus_widget_reject(dt_bauhaus_widget_t *w)</a>
<a name="ln1423">{</a>
<a name="ln1424">  switch(w-&gt;type)</a>
<a name="ln1425">  {</a>
<a name="ln1426">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1427">      break;</a>
<a name="ln1428">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1429">    {</a>
<a name="ln1430">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1431">      dt_bauhaus_slider_set_normalized(w, d-&gt;oldpos);</a>
<a name="ln1432">    }</a>
<a name="ln1433">    break;</a>
<a name="ln1434">    default:</a>
<a name="ln1435">      break;</a>
<a name="ln1436">  }</a>
<a name="ln1437">}</a>
<a name="ln1438"> </a>
<a name="ln1439">static void dt_bauhaus_widget_accept(dt_bauhaus_widget_t *w)</a>
<a name="ln1440">{</a>
<a name="ln1441">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1442">  GtkAllocation allocation;</a>
<a name="ln1443">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1444">  int base_width = allocation.width, base_height = inner_height(allocation);</a>
<a name="ln1445"> </a>
<a name="ln1446">  GtkAllocation allocation_popup_window;</a>
<a name="ln1447">  gtk_widget_get_allocation(darktable.bauhaus-&gt;popup_window, &amp;allocation_popup_window);</a>
<a name="ln1448"> </a>
<a name="ln1449">  int width = allocation_popup_window.width, height = inner_height(allocation_popup_window);</a>
<a name="ln1450"> </a>
<a name="ln1451">  switch(w-&gt;type)</a>
<a name="ln1452">  {</a>
<a name="ln1453">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1454">    {</a>
<a name="ln1455">      // only set to what's in the filtered list.</a>
<a name="ln1456">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1457">      int active = darktable.bauhaus-&gt;end_mouse_y &gt;= 0</a>
<a name="ln1458">                       ? (darktable.bauhaus-&gt;end_mouse_y / (base_height))</a>
<a name="ln1459">                       : d-&gt;active;</a>
<a name="ln1460">      int k = 0, i = 0, kk = 0, match = 1;</a>
<a name="ln1461"> </a>
<a name="ln1462">      gchar *keys = g_utf8_casefold(darktable.bauhaus-&gt;keys, -1);</a>
<a name="ln1463">      for(GList *it = d-&gt;entries; it; it = g_list_next(it))</a>
<a name="ln1464">      {</a>
<a name="ln1465">        const dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)it-&gt;data;</a>
<a name="ln1466">        gchar *text_cmp = g_utf8_casefold(entry-&gt;label, -1);</a>
<a name="ln1467">        if(!strncmp(text_cmp, keys, darktable.bauhaus-&gt;keys_cnt))</a>
<a name="ln1468">        {</a>
<a name="ln1469">          if(active == k)</a>
<a name="ln1470">          {</a>
<a name="ln1471">            if(entry-&gt;sensitive)</a>
<a name="ln1472">              dt_bauhaus_combobox_set(widget, i);</a>
<a name="ln1473">            g_free(keys);</a>
<a name="ln1474">            g_free(text_cmp);</a>
<a name="ln1475">            return;</a>
<a name="ln1476">          }</a>
<a name="ln1477">          kk = i; // remember for down there</a>
<a name="ln1478">          // editable should only snap to perfect matches, not prefixes:</a>
<a name="ln1479">          if(d-&gt;editable &amp;&amp; strcmp(entry-&gt;label, darktable.bauhaus-&gt;keys)) match = 0;</a>
<a name="ln1480">          k++;</a>
<a name="ln1481">        }</a>
<a name="ln1482">        i++;</a>
<a name="ln1483">        g_free(text_cmp);</a>
<a name="ln1484">      }</a>
<a name="ln1485">      // if list is short (2 entries could be: typed something similar, and one similar)</a>
<a name="ln1486">      if(k &lt; 3)</a>
<a name="ln1487">      {</a>
<a name="ln1488">        // didn't find it, but had only one matching choice?</a>
<a name="ln1489">        if(k == 1 &amp;&amp; match)</a>
<a name="ln1490">          dt_bauhaus_combobox_set(widget, kk);</a>
<a name="ln1491">        else if(d-&gt;editable)</a>
<a name="ln1492">        {</a>
<a name="ln1493">          // had no close match (k == 1 &amp;&amp; !match) or no match at all (k == 0)</a>
<a name="ln1494">          memset(d-&gt;text, 0, sizeof(d-&gt;text));</a>
<a name="ln1495">          g_strlcpy(d-&gt;text, darktable.bauhaus-&gt;keys, sizeof(d-&gt;text));</a>
<a name="ln1496">          // select custom entry</a>
<a name="ln1497">          dt_bauhaus_combobox_set(widget, -1);</a>
<a name="ln1498">        }</a>
<a name="ln1499">      }</a>
<a name="ln1500">      g_free(keys);</a>
<a name="ln1501">      break;</a>
<a name="ln1502">    }</a>
<a name="ln1503">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1504">    {</a>
<a name="ln1505">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1506">      const float mouse_off = get_slider_line_offset(</a>
<a name="ln1507">          d-&gt;oldpos, d-&gt;scale, darktable.bauhaus-&gt;end_mouse_x / width,</a>
<a name="ln1508">          darktable.bauhaus-&gt;end_mouse_y / height, base_height / (float)height, base_width);</a>
<a name="ln1509">      dt_bauhaus_slider_set_normalized(w, d-&gt;oldpos + mouse_off);</a>
<a name="ln1510">      d-&gt;oldpos = d-&gt;pos;</a>
<a name="ln1511">      break;</a>
<a name="ln1512">    }</a>
<a name="ln1513">    default:</a>
<a name="ln1514">      break;</a>
<a name="ln1515">  }</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518">static gboolean dt_bauhaus_popup_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln1519">{</a>
<a name="ln1520">  dt_bauhaus_widget_t *w = darktable.bauhaus-&gt;current;</a>
<a name="ln1521"> </a>
<a name="ln1522">  // dimensions of the popup</a>
<a name="ln1523">  GtkAllocation allocation;</a>
<a name="ln1524">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1525">  int width = allocation.width, height = inner_height(allocation);</a>
<a name="ln1526"> </a>
<a name="ln1527">  // dimensions of the original line</a>
<a name="ln1528">  GtkWidget *current = GTK_WIDGET(w);</a>
<a name="ln1529">  GtkAllocation allocation_current;</a>
<a name="ln1530">  gtk_widget_get_allocation(current, &amp;allocation_current);</a>
<a name="ln1531">  int wd = allocation_current.width, ht = inner_height(allocation_current);</a>
<a name="ln1532"> </a>
<a name="ln1533">  // get area properties</a>
<a name="ln1534">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln1535">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln1536">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln1537"> </a>
<a name="ln1538">  // translate to account for the widget spacing</a>
<a name="ln1539">  cairo_translate(cr, 0, darktable.bauhaus-&gt;widget_space);</a>
<a name="ln1540"> </a>
<a name="ln1541">  // draw background</a>
<a name="ln1542">  gtk_render_background(context, cr, 0.0, 0.0, width, height);</a>
<a name="ln1543"> </a>
<a name="ln1544">  // look up some colors once</a>
<a name="ln1545">  GdkRGBA text_color, text_color_selected, text_color_hover, text_color_insensitive;</a>
<a name="ln1546">  gtk_style_context_get_color(context, GTK_STATE_FLAG_NORMAL, &amp;text_color);</a>
<a name="ln1547">  gtk_style_context_get_color(context, GTK_STATE_FLAG_SELECTED, &amp;text_color_selected);</a>
<a name="ln1548">  gtk_style_context_get_color(context, GTK_STATE_FLAG_PRELIGHT, &amp;text_color_hover);</a>
<a name="ln1549">  gtk_style_context_get_color(context, GTK_STATE_FLAG_INSENSITIVE, &amp;text_color_insensitive);</a>
<a name="ln1550"> </a>
<a name="ln1551">  GdkRGBA *fg_color = default_color_assign();</a>
<a name="ln1552">  GdkRGBA *bg_color = default_color_assign();</a>
<a name="ln1553">  GtkStateFlags state = gtk_widget_get_state_flags(widget);</a>
<a name="ln1554">  gtk_render_background(context, cr, 0, 0, width, height);</a>
<a name="ln1555"> </a>
<a name="ln1556">  gtk_style_context_get(context, state, &quot;background-color&quot;, bg_color, NULL);</a>
<a name="ln1557">  gtk_style_context_get_color(context, state, fg_color);</a>
<a name="ln1558"> </a>
<a name="ln1559">  // switch on bauhaus widget type (so we only need one static window)</a>
<a name="ln1560">  switch(w-&gt;type)</a>
<a name="ln1561">  {</a>
<a name="ln1562">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1563">    {</a>
<a name="ln1564">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1565"> </a>
<a name="ln1566">      dt_bauhaus_draw_baseline(w, cr);</a>
<a name="ln1567"> </a>
<a name="ln1568">      cairo_save(cr);</a>
<a name="ln1569">      cairo_set_line_width(cr, 0.5);</a>
<a name="ln1570">      const int num_scales = 1.f / d-&gt;scale;</a>
<a name="ln1571"> </a>
<a name="ln1572">      cairo_rectangle(cr, 0.0f, ht, width - INNER_PADDING, height);</a>
<a name="ln1573">      cairo_clip(cr);</a>
<a name="ln1574"> </a>
<a name="ln1575">      for(int k = 0; k &lt; num_scales; k++)</a>
<a name="ln1576">      {</a>
<a name="ln1577">        const float off = k * d-&gt;scale - d-&gt;oldpos;</a>
<a name="ln1578">        GdkRGBA fg_copy = *fg_color;</a>
<a name="ln1579">        fg_copy.alpha = d-&gt;scale / fabsf(off);</a>
<a name="ln1580">        set_color(cr, fg_copy);</a>
<a name="ln1581">        draw_slider_line(cr, d-&gt;oldpos, off, d-&gt;scale, width, height, ht);</a>
<a name="ln1582">        cairo_stroke(cr);</a>
<a name="ln1583">      }</a>
<a name="ln1584">      cairo_restore(cr);</a>
<a name="ln1585">      set_color(cr, *fg_color);</a>
<a name="ln1586">      show_pango_text(cr, w-&gt;label, 0, 0, 0, FALSE);</a>
<a name="ln1587"> </a>
<a name="ln1588">      // draw mouse over indicator line</a>
<a name="ln1589">      cairo_save(cr);</a>
<a name="ln1590">      cairo_set_line_width(cr, 2.);</a>
<a name="ln1591">      const float mouse_off</a>
<a name="ln1592">          = darktable.bauhaus-&gt;change_active</a>
<a name="ln1593">                ? get_slider_line_offset(d-&gt;oldpos, d-&gt;scale, darktable.bauhaus-&gt;mouse_x / width,</a>
<a name="ln1594">                                         darktable.bauhaus-&gt;mouse_y / height, ht / (float)height, width)</a>
<a name="ln1595">                : 0.0f;</a>
<a name="ln1596">      draw_slider_line(cr, d-&gt;oldpos, mouse_off, d-&gt;scale, width, height, ht);</a>
<a name="ln1597">      cairo_stroke(cr);</a>
<a name="ln1598">      cairo_restore(cr);</a>
<a name="ln1599"> </a>
<a name="ln1600">      // draw indicator</a>
<a name="ln1601">      dt_bauhaus_draw_indicator(w, d-&gt;oldpos + mouse_off, cr, fg_color, bg_color);</a>
<a name="ln1602"> </a>
<a name="ln1603">      // draw numerical value:</a>
<a name="ln1604">      cairo_save(cr);</a>
<a name="ln1605">      char text[256];</a>
<a name="ln1606">      const float f = d-&gt;min + (d-&gt;oldpos + mouse_off) * (d-&gt;max - d-&gt;min);</a>
<a name="ln1607">      const float fc = d-&gt;callback(widget, f, DT_BAUHAUS_GET);</a>
<a name="ln1608">      snprintf(text, sizeof(text), d-&gt;format, fc);</a>
<a name="ln1609">      set_color(cr, *fg_color);</a>
<a name="ln1610">      show_pango_text(cr, text, wd - darktable.bauhaus-&gt;quad_width - INNER_PADDING, 0, 0, TRUE);</a>
<a name="ln1611"> </a>
<a name="ln1612">      cairo_restore(cr);</a>
<a name="ln1613">    }</a>
<a name="ln1614">    break;</a>
<a name="ln1615">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1616">    {</a>
<a name="ln1617">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1618">      cairo_save(cr);</a>
<a name="ln1619">      float first_label_width = 0.0;</a>
<a name="ln1620">      gboolean first_label = TRUE;</a>
<a name="ln1621">      int k = 0, i = 0;</a>
<a name="ln1622">      int hovered = darktable.bauhaus-&gt;mouse_y / ht;</a>
<a name="ln1623">      gchar *keys = g_utf8_casefold(darktable.bauhaus-&gt;keys, -1);</a>
<a name="ln1624">      for(GList *it = d-&gt;entries; it; it = g_list_next(it))</a>
<a name="ln1625">      {</a>
<a name="ln1626">        const dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)it-&gt;data;</a>
<a name="ln1627">        gchar *text_cmp = g_utf8_casefold(entry-&gt;label, -1);</a>
<a name="ln1628">        if(!strncmp(text_cmp, keys, darktable.bauhaus-&gt;keys_cnt))</a>
<a name="ln1629">        {</a>
<a name="ln1630">          float max_width = wd - INNER_PADDING - darktable.bauhaus-&gt;quad_width;</a>
<a name="ln1631">          if(first_label) max_width *= 0.8; // give the label at least some room</a>
<a name="ln1632"> </a>
<a name="ln1633">          float label_width;</a>
<a name="ln1634">          if(!entry-&gt;sensitive)</a>
<a name="ln1635">            set_color(cr, text_color_insensitive);</a>
<a name="ln1636">          else if(i == hovered)</a>
<a name="ln1637">            set_color(cr, text_color_hover);</a>
<a name="ln1638">          else if(i == d-&gt;active)</a>
<a name="ln1639">            set_color(cr, text_color_selected);</a>
<a name="ln1640">          else</a>
<a name="ln1641">            set_color(cr, text_color);</a>
<a name="ln1642"> </a>
<a name="ln1643">          if(entry-&gt;alignment == DT_BAUHAUS_COMBOBOX_ALIGN_LEFT)</a>
<a name="ln1644">            label_width = show_pango_text(cr, entry-&gt;label, 0, ht * k, max_width, FALSE);</a>
<a name="ln1645">          else</a>
<a name="ln1646">            label_width = show_pango_text(cr, entry-&gt;label, wd - INNER_PADDING - darktable.bauhaus-&gt;quad_width, ht * k, max_width, TRUE);</a>
<a name="ln1647"> </a>
<a name="ln1648">          // prefer the entry over the label wrt. ellipsization when expanded</a>
<a name="ln1649">          if(first_label)</a>
<a name="ln1650">          {</a>
<a name="ln1651">            first_label_width = label_width;</a>
<a name="ln1652">            first_label = FALSE;</a>
<a name="ln1653">          }</a>
<a name="ln1654"> </a>
<a name="ln1655">          k++;</a>
<a name="ln1656">        }</a>
<a name="ln1657">        i++;</a>
<a name="ln1658">        g_free(text_cmp);</a>
<a name="ln1659">      }</a>
<a name="ln1660">      cairo_restore(cr);</a>
<a name="ln1661"> </a>
<a name="ln1662">      // left aligned box label. add it to the gui after the entries so we can ellipsize it if needed</a>
<a name="ln1663">      set_color(cr, text_color);</a>
<a name="ln1664">      show_pango_text(cr, w-&gt;label, 0, 0, wd - INNER_PADDING - darktable.bauhaus-&gt;quad_width - first_label_width, FALSE);</a>
<a name="ln1665"> </a>
<a name="ln1666">      g_free(keys);</a>
<a name="ln1667">    }</a>
<a name="ln1668">    break;</a>
<a name="ln1669">    default:</a>
<a name="ln1670">      // yell</a>
<a name="ln1671">      break;</a>
<a name="ln1672">  }</a>
<a name="ln1673"> </a>
<a name="ln1674">  // draw currently typed text. if a type doesn't want this, it should not</a>
<a name="ln1675">  // allow stuff to be written here in the key callback.</a>
<a name="ln1676">  if(darktable.bauhaus-&gt;keys_cnt)</a>
<a name="ln1677">  {</a>
<a name="ln1678">    cairo_save(cr);</a>
<a name="ln1679">    PangoLayout *layout;</a>
<a name="ln1680">    PangoRectangle ink;</a>
<a name="ln1681">    layout = pango_cairo_create_layout(cr);</a>
<a name="ln1682">    pango_cairo_context_set_resolution(pango_layout_get_context(layout), darktable.gui-&gt;dpi);</a>
<a name="ln1683">    set_color(cr, text_color);</a>
<a name="ln1684"> </a>
<a name="ln1685">    // make extra large, but without dependency on popup window height</a>
<a name="ln1686">    // (that might differ for comboboxes for example). only fall back</a>
<a name="ln1687">    // to height dependency if the popup is really small.</a>
<a name="ln1688">    const int line_height = get_line_height();</a>
<a name="ln1689">    const int size = MIN(3 * line_height, .2 * height);</a>
<a name="ln1690">    PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln1691">    pango_font_description_set_absolute_size(desc, size * PANGO_SCALE);</a>
<a name="ln1692">    pango_layout_set_font_description(layout, desc);</a>
<a name="ln1693"> </a>
<a name="ln1694">    pango_layout_set_text(layout, darktable.bauhaus-&gt;keys, -1);</a>
<a name="ln1695">    pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln1696">    cairo_move_to(cr, wd - INNER_PADDING - darktable.bauhaus-&gt;quad_width - ink.width, height * 0.5 - size);</a>
<a name="ln1697">    pango_cairo_show_layout(cr, layout);</a>
<a name="ln1698">    cairo_restore(cr);</a>
<a name="ln1699">    pango_font_description_free(desc);</a>
<a name="ln1700">    g_object_unref(layout);</a>
<a name="ln1701">  }</a>
<a name="ln1702">  if(darktable.bauhaus-&gt;cursor_visible)</a>
<a name="ln1703">  {</a>
<a name="ln1704">    // show the blinking cursor</a>
<a name="ln1705">    cairo_save(cr);</a>
<a name="ln1706">    set_color(cr, text_color);</a>
<a name="ln1707">    const int line_height = get_line_height();</a>
<a name="ln1708">    cairo_move_to(cr, wd - darktable.bauhaus-&gt;quad_width + 3, height * 0.5 + line_height);</a>
<a name="ln1709">    cairo_line_to(cr, wd - darktable.bauhaus-&gt;quad_width + 3, height * 0.5 - 3 * line_height);</a>
<a name="ln1710">    cairo_set_line_width(cr, 2.);</a>
<a name="ln1711">    cairo_stroke(cr);</a>
<a name="ln1712">    cairo_restore(cr);</a>
<a name="ln1713">  }</a>
<a name="ln1714"> </a>
<a name="ln1715">  cairo_destroy(cr);</a>
<a name="ln1716">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln1717">  cairo_paint(crf);</a>
<a name="ln1718">  cairo_surface_destroy(cst);</a>
<a name="ln1719"> </a>
<a name="ln1720">  gdk_rgba_free(bg_color);</a>
<a name="ln1721">  gdk_rgba_free(fg_color);</a>
<a name="ln1722"> </a>
<a name="ln1723">  return TRUE;</a>
<a name="ln1724">}</a>
<a name="ln1725"> </a>
<a name="ln1726">static gboolean dt_bauhaus_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln1727">{</a>
<a name="ln1728">  GtkAllocation allocation;</a>
<a name="ln1729">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1730">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1731">  const int width = allocation.width, height = allocation.height;</a>
<a name="ln1732">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln1733">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln1734">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln1735"> </a>
<a name="ln1736">  // translate to account for the widget spacing</a>
<a name="ln1737">  cairo_translate(cr, 0, darktable.bauhaus-&gt;widget_space);</a>
<a name="ln1738"> </a>
<a name="ln1739">  GdkRGBA *fg_color = default_color_assign();</a>
<a name="ln1740">  GdkRGBA *text_color = default_color_assign();</a>
<a name="ln1741">  GtkStateFlags state = gtk_widget_get_state_flags(widget);</a>
<a name="ln1742">  gtk_style_context_get_color(context, state, text_color);</a>
<a name="ln1743">  gtk_render_background(context, cr, 0, 0, width, height + INNER_PADDING);</a>
<a name="ln1744">  gtk_style_context_get_color(context, state, fg_color);</a>
<a name="ln1745"> </a>
<a name="ln1746">  // draw type specific content:</a>
<a name="ln1747">  cairo_save(cr);</a>
<a name="ln1748">  cairo_set_line_width(cr, 1.0);</a>
<a name="ln1749">  switch(w-&gt;type)</a>
<a name="ln1750">  {</a>
<a name="ln1751">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1752">    {</a>
<a name="ln1753">      // draw label and quad area at right end</a>
<a name="ln1754">      set_color(cr, *text_color);</a>
<a name="ln1755">      float label_width</a>
<a name="ln1756">          = show_pango_text(cr, w-&gt;label, 0, 0, 0, FALSE);</a>
<a name="ln1757">      dt_bauhaus_draw_quad(w, cr);</a>
<a name="ln1758"> </a>
<a name="ln1759">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1760">      gchar *text = d-&gt;text;</a>
<a name="ln1761">      if(d-&gt;active &gt;= 0)</a>
<a name="ln1762">      {</a>
<a name="ln1763">        const dt_bauhaus_combobox_entry_t *entry = g_list_nth_data(d-&gt;entries, d-&gt;active);</a>
<a name="ln1764">        text = entry-&gt;label;</a>
<a name="ln1765">      }</a>
<a name="ln1766">      set_color(cr, *text_color);</a>
<a name="ln1767">      show_pango_text(cr, text, width - darktable.bauhaus-&gt;quad_width - INNER_PADDING, 0, width - darktable.bauhaus-&gt;quad_width - label_width, TRUE);</a>
<a name="ln1768">      break;</a>
<a name="ln1769">    }</a>
<a name="ln1770">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1771">    {</a>
<a name="ln1772">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1773"> </a>
<a name="ln1774">      // line for orientation</a>
<a name="ln1775">      dt_bauhaus_draw_baseline(w, cr);</a>
<a name="ln1776">      dt_bauhaus_draw_quad(w, cr);</a>
<a name="ln1777"> </a>
<a name="ln1778">      if(gtk_widget_is_sensitive(widget))</a>
<a name="ln1779">      {</a>
<a name="ln1780">        cairo_save(cr);</a>
<a name="ln1781">        cairo_rectangle(cr, 0, 0, width - darktable.bauhaus-&gt;quad_width - INNER_PADDING, height + INNER_PADDING);</a>
<a name="ln1782">        cairo_clip(cr);</a>
<a name="ln1783">        dt_bauhaus_draw_indicator(w, d-&gt;pos, cr, fg_color, &amp;darktable.bauhaus-&gt;indicator_border);</a>
<a name="ln1784">        cairo_restore(cr);</a>
<a name="ln1785"> </a>
<a name="ln1786">        // TODO: merge that text with combo</a>
<a name="ln1787">        char text[256];</a>
<a name="ln1788">        const float f = d-&gt;min + d-&gt;pos * (d-&gt;max - d-&gt;min);</a>
<a name="ln1789">        const float fc = d-&gt;callback(widget, f, DT_BAUHAUS_GET);</a>
<a name="ln1790">        snprintf(text, sizeof(text), d-&gt;format, fc);</a>
<a name="ln1791">        set_color(cr, *text_color);</a>
<a name="ln1792">        show_pango_text(cr, text, width - darktable.bauhaus-&gt;quad_width - INNER_PADDING, 0, 0, TRUE);</a>
<a name="ln1793">      }</a>
<a name="ln1794">      // label on top of marker:</a>
<a name="ln1795">      set_color(cr, *text_color);</a>
<a name="ln1796">      show_pango_text(cr, w-&gt;label, 0, 0, 0, FALSE);</a>
<a name="ln1797">    }</a>
<a name="ln1798">    break;</a>
<a name="ln1799">    default:</a>
<a name="ln1800">      break;</a>
<a name="ln1801">  }</a>
<a name="ln1802">  cairo_restore(cr);</a>
<a name="ln1803">  cairo_destroy(cr);</a>
<a name="ln1804">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln1805">  cairo_paint(crf);</a>
<a name="ln1806">  cairo_surface_destroy(cst);</a>
<a name="ln1807"> </a>
<a name="ln1808">  gdk_rgba_free(text_color);</a>
<a name="ln1809">  gdk_rgba_free(fg_color);</a>
<a name="ln1810"> </a>
<a name="ln1811">  return TRUE;</a>
<a name="ln1812">}</a>
<a name="ln1813"> </a>
<a name="ln1814">void dt_bauhaus_hide_popup()</a>
<a name="ln1815">{</a>
<a name="ln1816">  if(darktable.bauhaus-&gt;current)</a>
<a name="ln1817">  {</a>
<a name="ln1818">    gtk_grab_remove(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1819">    gtk_widget_hide(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1820">    darktable.bauhaus-&gt;current = NULL;</a>
<a name="ln1821">    // TODO: give focus to center view? do in accept() as well?</a>
<a name="ln1822">  }</a>
<a name="ln1823">  _stop_cursor();</a>
<a name="ln1824">}</a>
<a name="ln1825"> </a>
<a name="ln1826">void dt_bauhaus_show_popup(dt_bauhaus_widget_t *w)</a>
<a name="ln1827">{</a>
<a name="ln1828">  if(darktable.bauhaus-&gt;current) dt_bauhaus_hide_popup();</a>
<a name="ln1829">  darktable.bauhaus-&gt;current = w;</a>
<a name="ln1830">  darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln1831">  memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln1832">  darktable.bauhaus-&gt;change_active = 0;</a>
<a name="ln1833">  darktable.bauhaus-&gt;mouse_line_distance = 0.0f;</a>
<a name="ln1834">  _stop_cursor();</a>
<a name="ln1835"> </a>
<a name="ln1836">  if(w-&gt;module)</a>
<a name="ln1837">  {</a>
<a name="ln1838">    dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1839">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln1840">  }</a>
<a name="ln1841"> </a>
<a name="ln1842">  int offset = 0;</a>
<a name="ln1843">  GtkAllocation tmp;</a>
<a name="ln1844">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln1845"> </a>
<a name="ln1846">  gtk_widget_realize(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1847">  switch(darktable.bauhaus-&gt;current-&gt;type)</a>
<a name="ln1848">  {</a>
<a name="ln1849">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1850">    {</a>
<a name="ln1851">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1852">      d-&gt;oldpos = d-&gt;pos;</a>
<a name="ln1853">      tmp.height = tmp.width;</a>
<a name="ln1854">      _start_cursor(6);</a>
<a name="ln1855">      break;</a>
<a name="ln1856">    }</a>
<a name="ln1857">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1858">    {</a>
<a name="ln1859">      // we launch the dynamic populate fct if any</a>
<a name="ln1860">      if(w-&gt;combo_populate) w-&gt;combo_populate(GTK_WIDGET(w), &amp;w-&gt;module);</a>
<a name="ln1861">      // comboboxes change immediately</a>
<a name="ln1862">      darktable.bauhaus-&gt;change_active = 1;</a>
<a name="ln1863">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1864">      tmp.height = tmp.height * d-&gt;num_labels;</a>
<a name="ln1865">      GtkAllocation allocation_w;</a>
<a name="ln1866">      gtk_widget_get_allocation(GTK_WIDGET(w), &amp;allocation_w);</a>
<a name="ln1867">      const int ht = allocation_w.height;</a>
<a name="ln1868">      const int skip = ht + get_line_height();</a>
<a name="ln1869">      offset = -d-&gt;active * get_line_height();</a>
<a name="ln1870">      darktable.bauhaus-&gt;mouse_x = 0;</a>
<a name="ln1871">      darktable.bauhaus-&gt;mouse_y = d-&gt;active * skip + ht / 2;</a>
<a name="ln1872">      break;</a>
<a name="ln1873">    }</a>
<a name="ln1874">    default:</a>
<a name="ln1875">      break;</a>
<a name="ln1876">  }</a>
<a name="ln1877"> </a>
<a name="ln1878">  gint wx, wy;</a>
<a name="ln1879">  gdk_window_get_origin(gtk_widget_get_window(GTK_WIDGET(w)), &amp;wx, &amp;wy);</a>
<a name="ln1880"> </a>
<a name="ln1881">  // move popup so mouse is over currently active item, to minimize confusion with scroll wheel:</a>
<a name="ln1882">  if(darktable.bauhaus-&gt;current-&gt;type == DT_BAUHAUS_COMBOBOX) wy += offset;</a>
<a name="ln1883"> </a>
<a name="ln1884">  // gtk_widget_get_window will return null if not shown yet.</a>
<a name="ln1885">  // it is needed for gdk_window_move, and gtk_window move will</a>
<a name="ln1886">  // sometimes be ignored. this is why we always call both...</a>
<a name="ln1887">  // we also don't want to show before move, as this results in noticeable flickering.</a>
<a name="ln1888">  GdkWindow *window = gtk_widget_get_window(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1889">  if(window) gdk_window_move(window, wx, wy);</a>
<a name="ln1890">  gtk_window_move(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), wx, wy);</a>
<a name="ln1891">  gtk_widget_set_size_request(darktable.bauhaus-&gt;popup_area, tmp.width, tmp.height);</a>
<a name="ln1892">  gtk_widget_set_size_request(darktable.bauhaus-&gt;popup_window, tmp.width, tmp.height);</a>
<a name="ln1893">  gtk_widget_show_all(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1894">  gtk_widget_grab_focus(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln1895">}</a>
<a name="ln1896"> </a>
<a name="ln1897">static gboolean dt_bauhaus_slider_add_delta_internal(GtkWidget *widget, float delta, guint state)</a>
<a name="ln1898">{</a>
<a name="ln1899">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1900">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1901"> </a>
<a name="ln1902">  float multiplier;</a>
<a name="ln1903"> </a>
<a name="ln1904">  GdkModifierType modifiers = gtk_accelerator_get_default_mod_mask();</a>
<a name="ln1905">  if((state &amp; modifiers) == GDK_SHIFT_MASK)</a>
<a name="ln1906">  {</a>
<a name="ln1907">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_rough_step_multiplier&quot;);</a>
<a name="ln1908">  }</a>
<a name="ln1909">  else if((state &amp; modifiers) == GDK_CONTROL_MASK)</a>
<a name="ln1910">  {</a>
<a name="ln1911">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_precise_step_multiplier&quot;);</a>
<a name="ln1912">  }</a>
<a name="ln1913">  else</a>
<a name="ln1914">  {</a>
<a name="ln1915">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_step_multiplier&quot;);</a>
<a name="ln1916">  }</a>
<a name="ln1917"> </a>
<a name="ln1918">  delta *= multiplier;</a>
<a name="ln1919"> </a>
<a name="ln1920">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1921"> </a>
<a name="ln1922">  dt_bauhaus_slider_set_normalized(w, d-&gt;pos + delta);</a>
<a name="ln1923"> </a>
<a name="ln1924">  return TRUE;</a>
<a name="ln1925">}</a>
<a name="ln1926"> </a>
<a name="ln1927">static gboolean dt_bauhaus_slider_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln1928">{</a>
<a name="ln1929">  gdouble delta_y;</a>
<a name="ln1930">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1931">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return FALSE;</a>
<a name="ln1932">  gtk_widget_grab_focus(widget);</a>
<a name="ln1933"> </a>
<a name="ln1934">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln1935"> </a>
<a name="ln1936">  if(dt_gui_get_scroll_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln1937">  {</a>
<a name="ln1938">    delta_y *= -w-&gt;data.slider.scale / 5.0;</a>
<a name="ln1939">    return dt_bauhaus_slider_add_delta_internal(widget, delta_y, event-&gt;state);</a>
<a name="ln1940">  }</a>
<a name="ln1941"> </a>
<a name="ln1942">  return FALSE;</a>
<a name="ln1943">}</a>
<a name="ln1944"> </a>
<a name="ln1945">static gboolean dt_bauhaus_slider_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data)</a>
<a name="ln1946">{</a>
<a name="ln1947">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1948">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return FALSE;</a>
<a name="ln1949">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1950"> </a>
<a name="ln1951">  int handled = 0;</a>
<a name="ln1952">  float delta = 0.0f;</a>
<a name="ln1953">  if(event-&gt;keyval == GDK_KEY_Up || event-&gt;keyval == GDK_KEY_KP_Up || event-&gt;keyval == GDK_KEY_Right</a>
<a name="ln1954">     || event-&gt;keyval == GDK_KEY_KP_Right)</a>
<a name="ln1955">  {</a>
<a name="ln1956">    handled = 1;</a>
<a name="ln1957">    delta = d-&gt;scale / 5.0f;</a>
<a name="ln1958">  }</a>
<a name="ln1959">  else if(event-&gt;keyval == GDK_KEY_Down || event-&gt;keyval == GDK_KEY_KP_Down || event-&gt;keyval == GDK_KEY_Left</a>
<a name="ln1960">          || event-&gt;keyval == GDK_KEY_KP_Left)</a>
<a name="ln1961">  {</a>
<a name="ln1962">    handled = 1;</a>
<a name="ln1963">    delta = -d-&gt;scale / 5.0f;</a>
<a name="ln1964">  }</a>
<a name="ln1965"> </a>
<a name="ln1966">  if(!handled) return FALSE;</a>
<a name="ln1967"> </a>
<a name="ln1968">  return dt_bauhaus_slider_add_delta_internal(widget, delta, event-&gt;state);</a>
<a name="ln1969">}</a>
<a name="ln1970"> </a>
<a name="ln1971"> </a>
<a name="ln1972">static gboolean dt_bauhaus_combobox_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln1973">{</a>
<a name="ln1974">  int delta_y;</a>
<a name="ln1975">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1976">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln1977">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1978">  gtk_widget_grab_focus(widget);</a>
<a name="ln1979"> </a>
<a name="ln1980">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln1981"> </a>
<a name="ln1982">  if(dt_gui_get_scroll_unit_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln1983">  {</a>
<a name="ln1984">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1985">    // go to next sensitive one</a>
<a name="ln1986">    int new_pos = CLAMP(d-&gt;active + delta_y, 0, d-&gt;num_labels - 1);</a>
<a name="ln1987">    if(_combobox_next_entry(d-&gt;entries, &amp;new_pos, delta_y))</a>
<a name="ln1988">      dt_bauhaus_combobox_set(widget, new_pos);</a>
<a name="ln1989">    return TRUE;</a>
<a name="ln1990">  }</a>
<a name="ln1991"> </a>
<a name="ln1992">  return FALSE;</a>
<a name="ln1993">}</a>
<a name="ln1994"> </a>
<a name="ln1995">static gboolean dt_bauhaus_combobox_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data)</a>
<a name="ln1996">{</a>
<a name="ln1997">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1998">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln1999">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln2000">  if(event-&gt;keyval == GDK_KEY_Up || event-&gt;keyval == GDK_KEY_KP_Up || event-&gt;keyval == GDK_KEY_Left</a>
<a name="ln2001">     || event-&gt;keyval == GDK_KEY_KP_Left)</a>
<a name="ln2002">  {</a>
<a name="ln2003">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2004">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2005">    // skip insensitive ones</a>
<a name="ln2006">    int new_pos = CLAMP(d-&gt;active - 1, 0, d-&gt;num_labels - 1);</a>
<a name="ln2007">    if(_combobox_next_entry(d-&gt;entries, &amp;new_pos, -1))</a>
<a name="ln2008">      dt_bauhaus_combobox_set(widget, new_pos);</a>
<a name="ln2009">    return TRUE;</a>
<a name="ln2010">  }</a>
<a name="ln2011">  else if(event-&gt;keyval == GDK_KEY_Down || event-&gt;keyval == GDK_KEY_KP_Down || event-&gt;keyval == GDK_KEY_Right</a>
<a name="ln2012">          || event-&gt;keyval == GDK_KEY_KP_Right)</a>
<a name="ln2013">  {</a>
<a name="ln2014">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2015">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2016">    // skip insensitive ones</a>
<a name="ln2017">    int new_pos = CLAMP(d-&gt;active + 1, 0, d-&gt;num_labels - 1);</a>
<a name="ln2018">    if(_combobox_next_entry(d-&gt;entries, &amp;new_pos, 1))</a>
<a name="ln2019">      dt_bauhaus_combobox_set(widget, new_pos);</a>
<a name="ln2020">    return TRUE;</a>
<a name="ln2021">  }</a>
<a name="ln2022">  return FALSE;</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025">static gboolean dt_bauhaus_combobox_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2026">{</a>
<a name="ln2027">  GtkAllocation allocation;</a>
<a name="ln2028">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln2029">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2030"> </a>
<a name="ln2031">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln2032">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2033">  gtk_widget_grab_focus(GTK_WIDGET(w));</a>
<a name="ln2034">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2035"> </a>
<a name="ln2036">  GtkAllocation tmp;</a>
<a name="ln2037">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2038">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln2039">  if(w-&gt;quad_paint &amp;&amp; (event-&gt;x &gt; allocation.width - darktable.bauhaus-&gt;quad_width))</a>
<a name="ln2040">  {</a>
<a name="ln2041">    if (w-&gt;quad_toggle)</a>
<a name="ln2042">    {</a>
<a name="ln2043">      if (w-&gt;quad_paint_flags &amp; CPF_ACTIVE)</a>
<a name="ln2044">        w-&gt;quad_paint_flags &amp;= ~CPF_ACTIVE;</a>
<a name="ln2045">      else</a>
<a name="ln2046">        w-&gt;quad_paint_flags |= CPF_ACTIVE;</a>
<a name="ln2047">    }</a>
<a name="ln2048">    g_signal_emit_by_name(G_OBJECT(w), &quot;quad-pressed&quot;);</a>
<a name="ln2049">    return TRUE;</a>
<a name="ln2050">  }</a>
<a name="ln2051">  else if(event-&gt;button == 3)</a>
<a name="ln2052">  {</a>
<a name="ln2053">    darktable.bauhaus-&gt;mouse_x = event-&gt;x;</a>
<a name="ln2054">    darktable.bauhaus-&gt;mouse_y = event-&gt;y;</a>
<a name="ln2055">    dt_bauhaus_show_popup(w);</a>
<a name="ln2056">    return TRUE;</a>
<a name="ln2057">  }</a>
<a name="ln2058">  else if(event-&gt;button == 1)</a>
<a name="ln2059">  {</a>
<a name="ln2060">    // reset to default.</a>
<a name="ln2061">    if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln2062">    {</a>
<a name="ln2063">      // never called, as we popup the other window under your cursor before.</a>
<a name="ln2064">      // (except in weird corner cases where the popup is under the -1st entry</a>
<a name="ln2065">      dt_bauhaus_combobox_set(widget, d-&gt;defpos);</a>
<a name="ln2066">      dt_bauhaus_hide_popup();</a>
<a name="ln2067">    }</a>
<a name="ln2068">    else</a>
<a name="ln2069">    {</a>
<a name="ln2070">      // single click, show options</a>
<a name="ln2071">      darktable.bauhaus-&gt;opentime = dt_get_wtime();</a>
<a name="ln2072">      darktable.bauhaus-&gt;mouse_x = event-&gt;x;</a>
<a name="ln2073">      darktable.bauhaus-&gt;mouse_y = event-&gt;y;</a>
<a name="ln2074">      dt_bauhaus_show_popup(w);</a>
<a name="ln2075">    }</a>
<a name="ln2076">    return TRUE;</a>
<a name="ln2077">  }</a>
<a name="ln2078">  return FALSE;</a>
<a name="ln2079">}</a>
<a name="ln2080"> </a>
<a name="ln2081">float dt_bauhaus_slider_get(GtkWidget *widget)</a>
<a name="ln2082">{</a>
<a name="ln2083">  // first cast to bh widget, to check that type:</a>
<a name="ln2084">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2085">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return -1.0f;</a>
<a name="ln2086">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2087">  if(d-&gt;max == d-&gt;min) {</a>
<a name="ln2088">    return d-&gt;max;</a>
<a name="ln2089">  }</a>
<a name="ln2090">  float rawval = d-&gt;min + d-&gt;pos * (d-&gt;max - d-&gt;min);</a>
<a name="ln2091">  return d-&gt;callback(widget, rawval, DT_BAUHAUS_GET);</a>
<a name="ln2092">}</a>
<a name="ln2093"> </a>
<a name="ln2094">void dt_bauhaus_slider_set(GtkWidget *widget, float pos)</a>
<a name="ln2095">{</a>
<a name="ln2096">  // this is the public interface function, translate by bounds and call set_normalized</a>
<a name="ln2097">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2098">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2099">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2100">  float rawval = d-&gt;callback(widget, pos, DT_BAUHAUS_SET);</a>
<a name="ln2101">  dt_bauhaus_slider_set_normalized(w, (rawval - d-&gt;min) / (d-&gt;max - d-&gt;min));</a>
<a name="ln2102">}</a>
<a name="ln2103"> </a>
<a name="ln2104">void dt_bauhaus_slider_set_digits(GtkWidget *widget, int val)</a>
<a name="ln2105">{</a>
<a name="ln2106">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2107"> </a>
<a name="ln2108">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2109"> </a>
<a name="ln2110">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2111"> </a>
<a name="ln2112">  d-&gt;digits = val;</a>
<a name="ln2113">  snprintf(d-&gt;format, sizeof(d-&gt;format), &quot;%%.0%df&quot;, val);</a>
<a name="ln2114">}</a>
<a name="ln2115"> </a>
<a name="ln2116">int dt_bauhaus_slider_get_digits(GtkWidget *widget)</a>
<a name="ln2117">{</a>
<a name="ln2118">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2119"> </a>
<a name="ln2120">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return 0;</a>
<a name="ln2121"> </a>
<a name="ln2122">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2123"> </a>
<a name="ln2124">  return d-&gt;digits;</a>
<a name="ln2125">}</a>
<a name="ln2126"> </a>
<a name="ln2127">void dt_bauhaus_slider_set_step(GtkWidget *widget, float val)</a>
<a name="ln2128">{</a>
<a name="ln2129">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2130"> </a>
<a name="ln2131">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2132"> </a>
<a name="ln2133">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2134"> </a>
<a name="ln2135">  d-&gt;step = val;</a>
<a name="ln2136">  d-&gt;scale = 5.0f * d-&gt;step / (d-&gt;max - d-&gt;min);</a>
<a name="ln2137">}</a>
<a name="ln2138"> </a>
<a name="ln2139">float dt_bauhaus_slider_get_step(GtkWidget *widget)</a>
<a name="ln2140">{</a>
<a name="ln2141">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2142"> </a>
<a name="ln2143">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return 0;</a>
<a name="ln2144"> </a>
<a name="ln2145">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2146"> </a>
<a name="ln2147">  return d-&gt;step;</a>
<a name="ln2148">}</a>
<a name="ln2149"> </a>
<a name="ln2150">void dt_bauhaus_slider_reset(GtkWidget *widget)</a>
<a name="ln2151">{</a>
<a name="ln2152">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2153"> </a>
<a name="ln2154">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2155">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2156"> </a>
<a name="ln2157">  d-&gt;min = d-&gt;soft_min;</a>
<a name="ln2158">  d-&gt;max = d-&gt;soft_max;</a>
<a name="ln2159">  dt_bauhaus_slider_set_normalized(w, d-&gt;defpos);</a>
<a name="ln2160"> </a>
<a name="ln2161">  return;</a>
<a name="ln2162">}</a>
<a name="ln2163"> </a>
<a name="ln2164">void dt_bauhaus_slider_set_format(GtkWidget *widget, const char *format)</a>
<a name="ln2165">{</a>
<a name="ln2166">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2167">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2168">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2169">  g_strlcpy(d-&gt;format, format, sizeof(d-&gt;format));</a>
<a name="ln2170">}</a>
<a name="ln2171"> </a>
<a name="ln2172">void dt_bauhaus_slider_set_callback(GtkWidget *widget, float (*callback)(GtkWidget *self, float value, dt_bauhaus_callback_t dir))</a>
<a name="ln2173">{</a>
<a name="ln2174">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2175">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2176">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2177">  d-&gt;callback = (callback == NULL ? _default_linear_callback : callback);</a>
<a name="ln2178">}</a>
<a name="ln2179"> </a>
<a name="ln2180">void dt_bauhaus_slider_set_soft(GtkWidget *widget, float pos)</a>
<a name="ln2181">{</a>
<a name="ln2182">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2183">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2184">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2185">  float rawval = d-&gt;callback(widget, pos, DT_BAUHAUS_SET);</a>
<a name="ln2186">  float rpos = CLAMP(rawval, d-&gt;hard_min, d-&gt;hard_max);</a>
<a name="ln2187">  d-&gt;min = MIN(d-&gt;min, rpos);</a>
<a name="ln2188">  d-&gt;max = MAX(d-&gt;max, rpos);</a>
<a name="ln2189">  d-&gt;scale = 5.0f * d-&gt;step / (d-&gt;max - d-&gt;min);</a>
<a name="ln2190">  rpos = (rpos - d-&gt;min) / (d-&gt;max - d-&gt;min);</a>
<a name="ln2191">  dt_bauhaus_slider_set_normalized(w, rpos);</a>
<a name="ln2192">}</a>
<a name="ln2193"> </a>
<a name="ln2194">static void dt_bauhaus_slider_set_normalized(dt_bauhaus_widget_t *w, float pos)</a>
<a name="ln2195">{</a>
<a name="ln2196">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2197">  float rpos = CLAMP(pos, 0.0f, 1.0f);</a>
<a name="ln2198">  rpos = d-&gt;min + (d-&gt;max - d-&gt;min) * rpos;</a>
<a name="ln2199">  const float base = powf(10.0f, d-&gt;digits);</a>
<a name="ln2200">  rpos = roundf(base * rpos) / base;</a>
<a name="ln2201">  d-&gt;pos = (rpos - d-&gt;min) / (d-&gt;max - d-&gt;min);</a>
<a name="ln2202">  gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln2203">  d-&gt;is_changed = 1;</a>
<a name="ln2204">  if(!darktable.gui-&gt;reset &amp;&amp; !d-&gt;is_dragging)</a>
<a name="ln2205">  {</a>
<a name="ln2206">    g_signal_emit_by_name(G_OBJECT(w), &quot;value-changed&quot;);</a>
<a name="ln2207">    d-&gt;is_changed = 0;</a>
<a name="ln2208">  }</a>
<a name="ln2209">}</a>
<a name="ln2210"> </a>
<a name="ln2211">static gboolean dt_bauhaus_slider_postponed_value_change(gpointer data)</a>
<a name="ln2212">{</a>
<a name="ln2213">  if(!GTK_IS_WIDGET(data)) return 0;</a>
<a name="ln2214"> </a>
<a name="ln2215">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)data;</a>
<a name="ln2216">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2217">  if(d-&gt;is_changed)</a>
<a name="ln2218">  {</a>
<a name="ln2219">    g_signal_emit_by_name(G_OBJECT(w), &quot;value-changed&quot;);</a>
<a name="ln2220">    d-&gt;is_changed = 0;</a>
<a name="ln2221">  }</a>
<a name="ln2222"> </a>
<a name="ln2223">  if(!d-&gt;is_dragging) d-&gt;timeout_handle = 0;</a>
<a name="ln2224"> </a>
<a name="ln2225">  return d-&gt;is_dragging;</a>
<a name="ln2226">}</a>
<a name="ln2227"> </a>
<a name="ln2228">static gboolean dt_bauhaus_popup_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data)</a>
<a name="ln2229">{</a>
<a name="ln2230">  switch(darktable.bauhaus-&gt;current-&gt;type)</a>
<a name="ln2231">  {</a>
<a name="ln2232">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln2233">    {</a>
<a name="ln2234">      // hack to do screenshots from popup:</a>
<a name="ln2235">      // if(event-&gt;string[0] == 'p') return system(&quot;scrot&quot;);</a>
<a name="ln2236">      // else</a>
<a name="ln2237">      if(darktable.bauhaus-&gt;keys_cnt + 2 &lt; 64</a>
<a name="ln2238">         &amp;&amp; (event-&gt;keyval == GDK_KEY_space || event-&gt;keyval == GDK_KEY_KP_Space || // SPACE</a>
<a name="ln2239">             event-&gt;keyval == GDK_KEY_percent ||                                    // %</a>
<a name="ln2240">             (event-&gt;string[0] &gt;= 40 &amp;&amp; event-&gt;string[0] &lt;= 57) ||                  // ()+-*/.,0-9</a>
<a name="ln2241">             event-&gt;keyval == GDK_KEY_asciicircum ||                                // ^</a>
<a name="ln2242">             event-&gt;keyval == GDK_KEY_X || event-&gt;keyval == GDK_KEY_x))             // Xx</a>
<a name="ln2243">      {</a>
<a name="ln2244">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt++] = event-&gt;string[0];</a>
<a name="ln2245">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2246">      }</a>
<a name="ln2247">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0</a>
<a name="ln2248">              &amp;&amp; (event-&gt;keyval == GDK_KEY_BackSpace || event-&gt;keyval == GDK_KEY_Delete))</a>
<a name="ln2249">      {</a>
<a name="ln2250">        darktable.bauhaus-&gt;keys[--darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2251">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2252">      }</a>
<a name="ln2253">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0 &amp;&amp; darktable.bauhaus-&gt;keys_cnt + 1 &lt; 64</a>
<a name="ln2254">              &amp;&amp; (event-&gt;keyval == GDK_KEY_Return || event-&gt;keyval == GDK_KEY_KP_Enter))</a>
<a name="ln2255">      {</a>
<a name="ln2256">        // accept input</a>
<a name="ln2257">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2258">        // unnormalized input, user was typing this:</a>
<a name="ln2259">        float old_value = dt_bauhaus_slider_get(GTK_WIDGET(darktable.bauhaus-&gt;current));</a>
<a name="ln2260">        float new_value = dt_calculator_solve(old_value, darktable.bauhaus-&gt;keys);</a>
<a name="ln2261">        if(isfinite(new_value)) dt_bauhaus_slider_set_soft(GTK_WIDGET(darktable.bauhaus-&gt;current), new_value);</a>
<a name="ln2262">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2263">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2264">        dt_bauhaus_hide_popup();</a>
<a name="ln2265">      }</a>
<a name="ln2266">      else if(event-&gt;keyval == GDK_KEY_Escape)</a>
<a name="ln2267">      {</a>
<a name="ln2268">        // discard input and close popup</a>
<a name="ln2269">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2270">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2271">        dt_bauhaus_hide_popup();</a>
<a name="ln2272">      }</a>
<a name="ln2273">      else</a>
<a name="ln2274">        return FALSE;</a>
<a name="ln2275">      if(darktable.bauhaus-&gt;keys_cnt &gt; 0) _start_cursor(-1);</a>
<a name="ln2276">      return TRUE;</a>
<a name="ln2277">    }</a>
<a name="ln2278">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln2279">    {</a>
<a name="ln2280">      if(!g_utf8_validate(event-&gt;string, -1, NULL)) return FALSE;</a>
<a name="ln2281">      gunichar c = g_utf8_get_char(event-&gt;string);</a>
<a name="ln2282">      long int char_width = g_utf8_next_char(event-&gt;string) - event-&gt;string;</a>
<a name="ln2283">      // if(event-&gt;string[0] == 'p') return system(&quot;scrot&quot;);</a>
<a name="ln2284">      // else</a>
<a name="ln2285">      if(darktable.bauhaus-&gt;keys_cnt + 1 + char_width &lt; 64 &amp;&amp; g_unichar_isprint(c))</a>
<a name="ln2286">      {</a>
<a name="ln2287">        // only accept key input if still valid or editable?</a>
<a name="ln2288">        g_utf8_strncpy(darktable.bauhaus-&gt;keys + darktable.bauhaus-&gt;keys_cnt, event-&gt;string, 1);</a>
<a name="ln2289">        darktable.bauhaus-&gt;keys_cnt += char_width;</a>
<a name="ln2290">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2291">      }</a>
<a name="ln2292">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0</a>
<a name="ln2293">              &amp;&amp; (event-&gt;keyval == GDK_KEY_BackSpace || event-&gt;keyval == GDK_KEY_Delete))</a>
<a name="ln2294">      {</a>
<a name="ln2295">        darktable.bauhaus-&gt;keys_cnt</a>
<a name="ln2296">            -= (darktable.bauhaus-&gt;keys + darktable.bauhaus-&gt;keys_cnt)</a>
<a name="ln2297">               - g_utf8_prev_char(darktable.bauhaus-&gt;keys + darktable.bauhaus-&gt;keys_cnt);</a>
<a name="ln2298">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2299">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2300">      }</a>
<a name="ln2301">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0 &amp;&amp; darktable.bauhaus-&gt;keys_cnt + 1 &lt; 64</a>
<a name="ln2302">              &amp;&amp; (event-&gt;keyval == GDK_KEY_Return || event-&gt;keyval == GDK_KEY_KP_Enter))</a>
<a name="ln2303">      {</a>
<a name="ln2304">        // accept unique matches only for editable:</a>
<a name="ln2305">        if(darktable.bauhaus-&gt;current-&gt;data.combobox.editable)</a>
<a name="ln2306">          darktable.bauhaus-&gt;end_mouse_y = FLT_MAX;</a>
<a name="ln2307">        else</a>
<a name="ln2308">          darktable.bauhaus-&gt;end_mouse_y = 0;</a>
<a name="ln2309">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2310">        dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln2311">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2312">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2313">        dt_bauhaus_hide_popup();</a>
<a name="ln2314">      }</a>
<a name="ln2315">      else if(event-&gt;keyval == GDK_KEY_Escape)</a>
<a name="ln2316">      {</a>
<a name="ln2317">        // discard input and close popup</a>
<a name="ln2318">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2319">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2320">        dt_bauhaus_hide_popup();</a>
<a name="ln2321">      }</a>
<a name="ln2322">      else if(event-&gt;keyval == GDK_KEY_Up)</a>
<a name="ln2323">      {</a>
<a name="ln2324">        combobox_popup_scroll(-1);</a>
<a name="ln2325">      }</a>
<a name="ln2326">      else if(event-&gt;keyval == GDK_KEY_Down)</a>
<a name="ln2327">      {</a>
<a name="ln2328">        combobox_popup_scroll(1);</a>
<a name="ln2329">      }</a>
<a name="ln2330">      else if(event-&gt;keyval == GDK_KEY_Return || event-&gt;keyval == GDK_KEY_KP_Enter)</a>
<a name="ln2331">      {</a>
<a name="ln2332">        // return pressed, but didn't type anything</a>
<a name="ln2333">        darktable.bauhaus-&gt;end_mouse_y = -1; // negative will use currently highlighted instead.</a>
<a name="ln2334">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2335">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2336">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2337">        dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln2338">        dt_bauhaus_hide_popup();</a>
<a name="ln2339">      }</a>
<a name="ln2340">      else</a>
<a name="ln2341">        return FALSE;</a>
<a name="ln2342">      return TRUE;</a>
<a name="ln2343">    }</a>
<a name="ln2344">    default:</a>
<a name="ln2345">      return FALSE;</a>
<a name="ln2346">  }</a>
<a name="ln2347">}</a>
<a name="ln2348"> </a>
<a name="ln2349">static gboolean dt_bauhaus_slider_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2350">{</a>
<a name="ln2351">  GtkAllocation allocation;</a>
<a name="ln2352">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln2353">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2354">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2355">  gtk_widget_grab_focus(GTK_WIDGET(w));</a>
<a name="ln2356">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2357"> </a>
<a name="ln2358">  GtkAllocation tmp;</a>
<a name="ln2359">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2360">  if(w-&gt;quad_paint &amp;&amp; (event-&gt;x &gt; allocation.width - darktable.bauhaus-&gt;quad_width))</a>
<a name="ln2361">  {</a>
<a name="ln2362">    if (w-&gt;quad_toggle)</a>
<a name="ln2363">    {</a>
<a name="ln2364">      if (w-&gt;quad_paint_flags &amp; CPF_ACTIVE)</a>
<a name="ln2365">        w-&gt;quad_paint_flags &amp;= ~CPF_ACTIVE;</a>
<a name="ln2366">      else</a>
<a name="ln2367">        w-&gt;quad_paint_flags |= CPF_ACTIVE;</a>
<a name="ln2368">    }</a>
<a name="ln2369">    g_signal_emit_by_name(G_OBJECT(w), &quot;quad-pressed&quot;);</a>
<a name="ln2370">    return TRUE;</a>
<a name="ln2371">  }</a>
<a name="ln2372">  else if(event-&gt;button == 3)</a>
<a name="ln2373">  {</a>
<a name="ln2374">    dt_bauhaus_show_popup(w);</a>
<a name="ln2375">    return TRUE;</a>
<a name="ln2376">  }</a>
<a name="ln2377">  else if(event-&gt;button == 1)</a>
<a name="ln2378">  {</a>
<a name="ln2379">    // reset to default.</a>
<a name="ln2380">    if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln2381">    {</a>
<a name="ln2382">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2383">      d-&gt;is_dragging = 0;</a>
<a name="ln2384">      dt_bauhaus_slider_reset(GTK_WIDGET(w));</a>
<a name="ln2385">    }</a>
<a name="ln2386">    else</a>
<a name="ln2387">    {</a>
<a name="ln2388">      const float l = 0.0f;</a>
<a name="ln2389">      const float r = slider_right_pos((float)tmp.width);</a>
<a name="ln2390">      dt_bauhaus_slider_set_normalized(w, (event-&gt;x / tmp.width - l) / (r - l));</a>
<a name="ln2391">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2392">      d-&gt;is_dragging = 1;</a>
<a name="ln2393">      int delay = CLAMP(darktable.develop-&gt;average_delay * 3 / 2, DT_BAUHAUS_SLIDER_VALUE_CHANGED_DELAY_MIN,</a>
<a name="ln2394">                        DT_BAUHAUS_SLIDER_VALUE_CHANGED_DELAY_MAX);</a>
<a name="ln2395">      // timeout_handle should always be zero here, but check just in case</a>
<a name="ln2396">      if(!d-&gt;timeout_handle)</a>
<a name="ln2397">        d-&gt;timeout_handle = g_timeout_add(delay, dt_bauhaus_slider_postponed_value_change, widget);</a>
<a name="ln2398">    }</a>
<a name="ln2399">    return TRUE;</a>
<a name="ln2400">  }</a>
<a name="ln2401">  return FALSE;</a>
<a name="ln2402">}</a>
<a name="ln2403"> </a>
<a name="ln2404">static gboolean dt_bauhaus_slider_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2405">{</a>
<a name="ln2406">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2407">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2408"> </a>
<a name="ln2409">  if((event-&gt;button == 1) &amp;&amp; (d-&gt;is_dragging))</a>
<a name="ln2410">  {</a>
<a name="ln2411">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2412">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2413"> </a>
<a name="ln2414">    GtkAllocation tmp;</a>
<a name="ln2415">    gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2416">    d-&gt;is_dragging = 0;</a>
<a name="ln2417">    if(d-&gt;timeout_handle) g_source_remove(d-&gt;timeout_handle);</a>
<a name="ln2418">    d-&gt;timeout_handle = 0;</a>
<a name="ln2419">    const float l = 0.0f;</a>
<a name="ln2420">    const float r = slider_right_pos((float)tmp.width);</a>
<a name="ln2421">    dt_bauhaus_slider_set_normalized(w, (event-&gt;x / tmp.width - l) / (r - l));</a>
<a name="ln2422"> </a>
<a name="ln2423">    return TRUE;</a>
<a name="ln2424">  }</a>
<a name="ln2425">  return FALSE;</a>
<a name="ln2426">}</a>
<a name="ln2427"> </a>
<a name="ln2428">static gboolean dt_bauhaus_slider_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln2429">{</a>
<a name="ln2430">  // remember mouse position for motion effects in draw</a>
<a name="ln2431">  if(event-&gt;state &amp; GDK_BUTTON1_MASK &amp;&amp; event-&gt;type != GDK_2BUTTON_PRESS)</a>
<a name="ln2432">  {</a>
<a name="ln2433">    dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2434">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2435">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2436">    GtkAllocation tmp;</a>
<a name="ln2437">    gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2438">    const float l = 0.0f;</a>
<a name="ln2439">    const float r = slider_right_pos((float)tmp.width);</a>
<a name="ln2440">    dt_bauhaus_slider_set_normalized(w, (event-&gt;x / tmp.width - l) / (r - l));</a>
<a name="ln2441">  }</a>
<a name="ln2442">  // not sure if needed:</a>
<a name="ln2443">  // gdk_event_request_motions(event);</a>
<a name="ln2444">  return TRUE;</a>
<a name="ln2445">}</a>
<a name="ln2446"> </a>
<a name="ln2447">void dt_bauhaus_vimkey_exec(const char *input)</a>
<a name="ln2448">{</a>
<a name="ln2449">  char module[64], label[64], value[256], *key;</a>
<a name="ln2450">  float old_value, new_value;</a>
<a name="ln2451"> </a>
<a name="ln2452">  sscanf(input, &quot;:set %63[^.].%63[^=]=%255s&quot;, module, label, value);</a>
<a name="ln2453">  fprintf(stderr, &quot;[vimkey] setting module `%s', slider `%s' to `%s'&quot;, module, label, value);</a>
<a name="ln2454">  key = g_strjoin(&quot;.&quot;, module, label, NULL);</a>
<a name="ln2455">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)g_hash_table_lookup(darktable.bauhaus-&gt;keymap, key);</a>
<a name="ln2456">  g_free(key);</a>
<a name="ln2457">  if(!w) return;</a>
<a name="ln2458">  switch(w-&gt;type)</a>
<a name="ln2459">  {</a>
<a name="ln2460">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln2461">      old_value = dt_bauhaus_slider_get(GTK_WIDGET(w));</a>
<a name="ln2462">      new_value = dt_calculator_solve(old_value, value);</a>
<a name="ln2463">      fprintf(stderr, &quot; = %f\n&quot;, new_value);</a>
<a name="ln2464">      if(isfinite(new_value)) dt_bauhaus_slider_set_soft(GTK_WIDGET(w), new_value);</a>
<a name="ln2465">      break;</a>
<a name="ln2466">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln2467">      // TODO: what about text as entry?</a>
<a name="ln2468">      old_value = dt_bauhaus_combobox_get(GTK_WIDGET(w));</a>
<a name="ln2469">      new_value = dt_calculator_solve(old_value, value);</a>
<a name="ln2470">      fprintf(stderr, &quot; = %f\n&quot;, new_value);</a>
<a name="ln2471">      if(isfinite(new_value)) dt_bauhaus_combobox_set(GTK_WIDGET(w), new_value);</a>
<a name="ln2472">      break;</a>
<a name="ln2473">    default:</a>
<a name="ln2474">      break;</a>
<a name="ln2475">  }</a>
<a name="ln2476">}</a>
<a name="ln2477"> </a>
<a name="ln2478">// give autocomplete suggestions</a>
<a name="ln2479">GList *dt_bauhaus_vimkey_complete(const char *input)</a>
<a name="ln2480">{</a>
<a name="ln2481">  GList *cmp = darktable.bauhaus-&gt;key_mod;</a>
<a name="ln2482">  char *point = strstr(input, &quot;.&quot;);</a>
<a name="ln2483">  if(point) cmp = darktable.bauhaus-&gt;key_val;</a>
<a name="ln2484">  int prefix = strlen(input);</a>
<a name="ln2485">  GList *res = NULL;</a>
<a name="ln2486">  int after = 0;</a>
<a name="ln2487">  while(cmp)</a>
<a name="ln2488">  {</a>
<a name="ln2489">    char *path = (char *)cmp-&gt;data;</a>
<a name="ln2490">    if(strncasecmp(path, input, prefix))</a>
<a name="ln2491">    {</a>
<a name="ln2492">      if(after) break; // sorted, so we're done</a>
<a name="ln2493">                       // else loop till we find the start of it</a>
<a name="ln2494">    }</a>
<a name="ln2495">    else</a>
<a name="ln2496">    {</a>
<a name="ln2497">      // append:</a>
<a name="ln2498">      res = g_list_insert_sorted(res, path, (GCompareFunc)strcmp);</a>
<a name="ln2499">      after = 1;</a>
<a name="ln2500">    }</a>
<a name="ln2501">    cmp = g_list_next(cmp);</a>
<a name="ln2502">  }</a>
<a name="ln2503">  return res;</a>
<a name="ln2504">}</a>
<a name="ln2505"> </a>
<a name="ln2506">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2507">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2508">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="65"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'entry'. Check lines: 65, 64.</p></div>
<div class="balloon" rel="478"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'darktable.bauhaus'. Check lines: 478, 477.</p></div>
<div class="balloon" rel="532"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v636/" target="_blank">V636</a> The 'pango_height / 1024' expression was implicitly cast from 'int' type to 'float' type. Consider utilizing an explicit type cast to avoid the loss of a fractional part. An example: double A = (double)(X) / Y;.</p></div>
<div class="balloon" rel="1552"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v656/" target="_blank">V656</a> Variables 'fg_color', 'bg_color' are initialized through the call to the same function. It's probably an error or un-optimized code. Consider inspecting the 'default_color_assign()' expression. Check lines: 1551, 1552.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
