
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012 johannes hanika.</a>
<a name="ln4">    copyright (c) 2012--2014 tobias ellinghaus.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln21">#include &quot;common/calculator.h&quot;</a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;develop/develop.h&quot;</a>
<a name="ln25">#include &quot;gui/gtk.h&quot;</a>
<a name="ln26">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln27">#include &quot;osx/osx.h&quot;</a>
<a name="ln28">#endif</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;math.h&gt;</a>
<a name="ln31">#include &lt;pango/pangocairo.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">G_DEFINE_TYPE(DtBauhausWidget, dt_bh, GTK_TYPE_DRAWING_AREA)</a>
<a name="ln34"> </a>
<a name="ln35">// INNER_PADDING is the horizontal space between slider and quad</a>
<a name="ln36">// and vertical space between labels and slider baseline</a>
<a name="ln37">#define INNER_PADDING 4.0</a>
<a name="ln38"> </a>
<a name="ln39">// fwd declare</a>
<a name="ln40">static gboolean dt_bauhaus_popup_draw(GtkWidget *widget, cairo_t *cr, gpointer user_data);</a>
<a name="ln41">static gboolean dt_bauhaus_popup_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);</a>
<a name="ln42">static void dt_bauhaus_widget_accept(dt_bauhaus_widget_t *w);</a>
<a name="ln43">static void dt_bauhaus_widget_reject(dt_bauhaus_widget_t *w);</a>
<a name="ln44"> </a>
<a name="ln45">static gboolean _combobox_next_entry(GList *entries, int *new_pos, int delta_y)</a>
<a name="ln46">{</a>
<a name="ln47">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(entries, *new_pos);</a>
<a name="ln48">  while(entry &amp;&amp; !entry-&gt;sensitive)</a>
<a name="ln49">  {</a>
<a name="ln50">    *new_pos += delta_y;</a>
<a name="ln51">    entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(entries, *new_pos);</a>
<a name="ln52">  }</a>
<a name="ln53">  return entry != NULL;</a>
<a name="ln54">}</a>
<a name="ln55"> </a>
<a name="ln56">static inline int get_line_height()</a>
<a name="ln57">{</a>
<a name="ln58">  return darktable.bauhaus-&gt;scale * darktable.bauhaus-&gt;line_height;</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61">static dt_bauhaus_combobox_entry_t *new_combobox_entry(const char *label, dt_bauhaus_combobox_alignment_t alignment,</a>
<a name="ln62">                                                       gboolean sensitive, void *data, void (*free_func)(void *))</a>
<a name="ln63">{</a>
<a name="ln64">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)calloc(1, sizeof(dt_bauhaus_combobox_entry_t));</a>
<a name="ln65">  entry-&gt;label = g_strdup(label);</a>
<a name="ln66">  entry-&gt;alignment = alignment;</a>
<a name="ln67">  entry-&gt;sensitive = sensitive;</a>
<a name="ln68">  entry-&gt;data = data;</a>
<a name="ln69">  entry-&gt;free_func = free_func;</a>
<a name="ln70">  return entry;</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">static void free_combobox_entry(gpointer data)</a>
<a name="ln74">{</a>
<a name="ln75">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)data;</a>
<a name="ln76">  g_free(entry-&gt;label);</a>
<a name="ln77">  if(entry-&gt;free_func)</a>
<a name="ln78">    entry-&gt;free_func(entry-&gt;data);</a>
<a name="ln79">  free(entry);</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">static inline float inner_height(GtkAllocation allocation)</a>
<a name="ln83">{</a>
<a name="ln84">  // retrieve the inner height of the widget (inside the top/bottom margin)</a>
<a name="ln85">  return allocation.height - 2.0f * darktable.bauhaus-&gt;widget_space;</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88"> </a>
<a name="ln89">static GdkRGBA * default_color_assign()</a>
<a name="ln90">{</a>
<a name="ln91">  // helper to initialize a color pointer with red color as a default</a>
<a name="ln92">  GdkRGBA color;</a>
<a name="ln93">  color.red = 1.0f;</a>
<a name="ln94">  color.green = 0.0f;</a>
<a name="ln95">  color.blue = 0.0f;</a>
<a name="ln96">  color.alpha = 1.0f;</a>
<a name="ln97">  return gdk_rgba_copy(&amp;color);</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100"> </a>
<a name="ln101">static int show_pango_text(cairo_t *cr, char *text, float x_pos, float y_pos, float max_width, gboolean right_aligned)</a>
<a name="ln102">{</a>
<a name="ln103">  PangoLayout *layout;</a>
<a name="ln104"> </a>
<a name="ln105">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln106"> </a>
<a name="ln107">  if(max_width &gt; 0)</a>
<a name="ln108">  {</a>
<a name="ln109">    pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_MIDDLE);</a>
<a name="ln110">    pango_layout_set_width(layout, (int)(PANGO_SCALE * max_width + 0.5f));</a>
<a name="ln111">  }</a>
<a name="ln112"> </a>
<a name="ln113">  if(text) {</a>
<a name="ln114">    pango_layout_set_text(layout, text, -1);</a>
<a name="ln115">  } else {</a>
<a name="ln116">    // length of -1 is not allowed with NULL string (wtf)</a>
<a name="ln117">    pango_layout_set_text(layout, NULL, 0);</a>
<a name="ln118">  }</a>
<a name="ln119"> </a>
<a name="ln120">  pango_layout_set_font_description(layout, darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln121">  pango_cairo_context_set_resolution(pango_layout_get_context(layout), darktable.gui-&gt;dpi);</a>
<a name="ln122"> </a>
<a name="ln123">  int pango_width, pango_height;</a>
<a name="ln124">  pango_layout_get_size(layout, &amp;pango_width, &amp;pango_height);</a>
<a name="ln125">  float text_width = ((double)pango_width/PANGO_SCALE);</a>
<a name="ln126"> </a>
<a name="ln127">  if(right_aligned) x_pos -= text_width;</a>
<a name="ln128"> </a>
<a name="ln129">  cairo_move_to(cr, x_pos, y_pos);</a>
<a name="ln130">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln131">  g_object_unref(layout);</a>
<a name="ln132"> </a>
<a name="ln133">  return text_width;</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">// -------------------------------</a>
<a name="ln137">static gboolean _cursor_timeout_callback(gpointer user_data)</a>
<a name="ln138">{</a>
<a name="ln139">  if(darktable.bauhaus-&gt;cursor_blink_counter &gt; 0) darktable.bauhaus-&gt;cursor_blink_counter--;</a>
<a name="ln140"> </a>
<a name="ln141">  darktable.bauhaus-&gt;cursor_visible = !darktable.bauhaus-&gt;cursor_visible;</a>
<a name="ln142">  gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln143"> </a>
<a name="ln144">  if(darktable.bauhaus-&gt;cursor_blink_counter</a>
<a name="ln145">     != 0) // this can be &gt;0 when we haven't reached the desired number or -1 when blinking forever</a>
<a name="ln146">    return TRUE;</a>
<a name="ln147"> </a>
<a name="ln148">  darktable.bauhaus-&gt;cursor_timeout = 0; // otherwise the cursor won't come up when starting to type</a>
<a name="ln149">  return FALSE;</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">static void _start_cursor(int max_blinks)</a>
<a name="ln153">{</a>
<a name="ln154">  darktable.bauhaus-&gt;cursor_blink_counter = max_blinks;</a>
<a name="ln155">  darktable.bauhaus-&gt;cursor_visible = FALSE;</a>
<a name="ln156">  if(darktable.bauhaus-&gt;cursor_timeout == 0)</a>
<a name="ln157">    darktable.bauhaus-&gt;cursor_timeout = g_timeout_add(500, _cursor_timeout_callback, NULL);</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160">static void _stop_cursor()</a>
<a name="ln161">{</a>
<a name="ln162">  if(darktable.bauhaus-&gt;cursor_timeout &gt; 0)</a>
<a name="ln163">  {</a>
<a name="ln164">    g_source_remove(darktable.bauhaus-&gt;cursor_timeout);</a>
<a name="ln165">    darktable.bauhaus-&gt;cursor_timeout = 0;</a>
<a name="ln166">    darktable.bauhaus-&gt;cursor_visible = FALSE;</a>
<a name="ln167">  }</a>
<a name="ln168">}</a>
<a name="ln169">// -------------------------------</a>
<a name="ln170"> </a>
<a name="ln171"> </a>
<a name="ln172">static void dt_bauhaus_slider_set_normalized(dt_bauhaus_widget_t *w, float pos);</a>
<a name="ln173"> </a>
<a name="ln174">static float slider_right_pos(float width)</a>
<a name="ln175">{</a>
<a name="ln176">  // relative position (in widget) of the right bound of the slider corrected with the inner padding</a>
<a name="ln177">  return 1.0f - (darktable.bauhaus-&gt;quad_width + INNER_PADDING) / width;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">static float slider_coordinate(const float abs_position, const float width)</a>
<a name="ln181">{</a>
<a name="ln182">  // Translates an horizontal position relative to the slider</a>
<a name="ln183">  // in an horizontal position relative to the widget</a>
<a name="ln184">  const float left_bound = 0.0f;</a>
<a name="ln185">  const float right_bound = slider_right_pos(width); // exclude the quad area on the right</a>
<a name="ln186">  return (left_bound + abs_position * (right_bound - left_bound)) * width;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189"> </a>
<a name="ln190">static float get_slider_line_offset(float pos, float scale, float x, float y, float ht, const int width)</a>
<a name="ln191">{</a>
<a name="ln192">  // ht is in [0,1] scale here</a>
<a name="ln193">  const float l = 0.0f;</a>
<a name="ln194">  const float r = slider_right_pos(width);</a>
<a name="ln195"> </a>
<a name="ln196">  float offset = 0.0f;</a>
<a name="ln197">  // handle linear startup and rescale y to fit the whole range again</a>
<a name="ln198">  if(y &lt; ht)</a>
<a name="ln199">  {</a>
<a name="ln200">    offset = (x - l) / (r - l) - pos;</a>
<a name="ln201">  }</a>
<a name="ln202">  else</a>
<a name="ln203">  {</a>
<a name="ln204">    y -= ht;</a>
<a name="ln205">    y /= (1.0f - ht);</a>
<a name="ln206"> </a>
<a name="ln207">    offset = (x - y * y * .5f - (1.0f - y * y) * (l + pos * (r - l)))</a>
<a name="ln208">             / (.5f * y * y / scale + (1.0f - y * y) * (r - l));</a>
<a name="ln209">  }</a>
<a name="ln210">  // clamp to result in a [0,1] range:</a>
<a name="ln211">  if(pos + offset &gt; 1.0f) offset = 1.0f - pos;</a>
<a name="ln212">  if(pos + offset &lt; 0.0f) offset = -pos;</a>
<a name="ln213">  return offset;</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">// draw a loupe guideline for the quadratic zoom in in the slider interface:</a>
<a name="ln217">static void draw_slider_line(cairo_t *cr, float pos, float off, float scale, const int width,</a>
<a name="ln218">                             const int height, const int ht)</a>
<a name="ln219">{</a>
<a name="ln220">  // pos is normalized position [0,1], offset is on that scale.</a>
<a name="ln221">  // ht is in pixels here</a>
<a name="ln222">  const float l = 0.0f;</a>
<a name="ln223">  const float r = slider_right_pos(width);</a>
<a name="ln224"> </a>
<a name="ln225">  const int steps = 64;</a>
<a name="ln226">  cairo_move_to(cr, width * (l + (pos + off) * (r - l)), ht * .7f);</a>
<a name="ln227">  cairo_line_to(cr, width * (l + (pos + off) * (r - l)), ht);</a>
<a name="ln228">  for(int j = 1; j &lt; steps; j++)</a>
<a name="ln229">  {</a>
<a name="ln230">    const float y = j / (steps - 1.0f);</a>
<a name="ln231">    const float x = y * y * .5f * (1.f + off / scale) + (1.0f - y * y) * (l + (pos + off) * (r - l));</a>
<a name="ln232">    cairo_line_to(cr, x * width, ht + y * (height - ht));</a>
<a name="ln233">  }</a>
<a name="ln234">}</a>
<a name="ln235">// -------------------------------</a>
<a name="ln236"> </a>
<a name="ln237">// handlers on the popup window, to close popup:</a>
<a name="ln238">static gboolean dt_bauhaus_window_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln239">{</a>
<a name="ln240">  const float tol = 50;</a>
<a name="ln241">  gint wx, wy;</a>
<a name="ln242">  GtkAllocation allocation;</a>
<a name="ln243">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln244">  gdk_window_get_origin(gtk_widget_get_window(widget), &amp;wx, &amp;wy);</a>
<a name="ln245">  if(event-&gt;x_root &gt; wx + allocation.width + tol || event-&gt;y_root &gt; wy + inner_height(allocation) + tol</a>
<a name="ln246">     || event-&gt;x_root &lt; (int)wx - tol || event-&gt;y_root &lt; (int)wy - tol)</a>
<a name="ln247">  {</a>
<a name="ln248">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln249">    dt_bauhaus_hide_popup();</a>
<a name="ln250">    return TRUE;</a>
<a name="ln251">  }</a>
<a name="ln252">  // make sure to propagate the event further</a>
<a name="ln253">  return FALSE;</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">static gboolean dt_bauhaus_window_button_press(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln257">{</a>
<a name="ln258">  const float tol = 0;</a>
<a name="ln259">  gint wx, wy;</a>
<a name="ln260">  GtkAllocation allocation;</a>
<a name="ln261">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln262">  gdk_window_get_origin(gtk_widget_get_window(widget), &amp;wx, &amp;wy);</a>
<a name="ln263">  if((event-&gt;x_root &gt; wx + allocation.width + tol || event-&gt;y_root &gt; wy + inner_height(allocation) + tol</a>
<a name="ln264">      || event-&gt;x_root &lt; (int)wx - tol || event-&gt;y_root &lt; (int)wy - tol))</a>
<a name="ln265">  {</a>
<a name="ln266">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln267">    dt_bauhaus_hide_popup();</a>
<a name="ln268">    return TRUE;</a>
<a name="ln269">  }</a>
<a name="ln270">  // make sure to propagate the event further</a>
<a name="ln271">  return FALSE;</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">static void combobox_popup_scroll(int amt)</a>
<a name="ln275">{</a>
<a name="ln276">  gint wx, wy;</a>
<a name="ln277">  GtkWidget *w = GTK_WIDGET(darktable.bauhaus-&gt;current);</a>
<a name="ln278">  GtkAllocation allocation_w;</a>
<a name="ln279">  gtk_widget_get_allocation(w, &amp;allocation_w);</a>
<a name="ln280">  const int ht = allocation_w.height;</a>
<a name="ln281">  const int skip = ht;</a>
<a name="ln282">  gdk_window_get_origin(gtk_widget_get_window(w), &amp;wx, &amp;wy);</a>
<a name="ln283">  dt_bauhaus_combobox_data_t *d = &amp;darktable.bauhaus-&gt;current-&gt;data.combobox;</a>
<a name="ln284">  int new_value = CLAMP(d-&gt;active + amt, 0, d-&gt;num_labels - 1);</a>
<a name="ln285">  // skip insensitive ones</a>
<a name="ln286">  if(!_combobox_next_entry(d-&gt;entries, &amp;new_value, amt))</a>
<a name="ln287">    return;</a>
<a name="ln288"> </a>
<a name="ln289">  // we move the popup up or down</a>
<a name="ln290">  if(new_value == d-&gt;active)</a>
<a name="ln291">  {</a>
<a name="ln292">    gdk_window_move(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), wx, wy - d-&gt;active * skip);</a>
<a name="ln293">  }</a>
<a name="ln294">  else</a>
<a name="ln295">  {</a>
<a name="ln296">    gint px, py;</a>
<a name="ln297">    gdk_window_get_origin(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), &amp;px, &amp;py);</a>
<a name="ln298">    gdk_window_move(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), wx, py - skip * (new_value - d-&gt;active));</a>
<a name="ln299">  }</a>
<a name="ln300"> </a>
<a name="ln301">  // make sure highlighted entry is updated:</a>
<a name="ln302">  darktable.bauhaus-&gt;mouse_x = 0;</a>
<a name="ln303">  darktable.bauhaus-&gt;mouse_y = new_value * skip + ht / 2;</a>
<a name="ln304">  gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln305"> </a>
<a name="ln306">  // and we change the value</a>
<a name="ln307">  dt_bauhaus_combobox_set(w, new_value);</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310"> </a>
<a name="ln311">static gboolean dt_bauhaus_popup_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln312">{</a>
<a name="ln313">  int delta_y;</a>
<a name="ln314">  switch(darktable.bauhaus-&gt;current-&gt;type)</a>
<a name="ln315">  {</a>
<a name="ln316">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln317">      if(dt_gui_get_scroll_unit_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln318">         combobox_popup_scroll(delta_y);</a>
<a name="ln319">      break;</a>
<a name="ln320">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln321">      break;</a>
<a name="ln322">    default:</a>
<a name="ln323">      break;</a>
<a name="ln324">  }</a>
<a name="ln325">  return TRUE;</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">static gboolean dt_bauhaus_popup_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln329">{</a>
<a name="ln330">  GtkAllocation allocation_popup_window;</a>
<a name="ln331">  gtk_widget_get_allocation(darktable.bauhaus-&gt;popup_window, &amp;allocation_popup_window);</a>
<a name="ln332">  gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln333">  dt_bauhaus_widget_t *w = darktable.bauhaus-&gt;current;</a>
<a name="ln334">  GtkAllocation allocation_w;</a>
<a name="ln335">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;allocation_w);</a>
<a name="ln336">  int width = allocation_popup_window.width, height = inner_height(allocation_popup_window);</a>
<a name="ln337">  // coordinate transform is in vain because we're only ever called after a button release.</a>
<a name="ln338">  // that means the system is always the one of the popup.</a>
<a name="ln339">  // that also means that we can't have hovering combobox entries while still holding the button. :(</a>
<a name="ln340">  const float ex = event-&gt;x;</a>
<a name="ln341">  const float ey = event-&gt;y;</a>
<a name="ln342">  GtkAllocation allocation;</a>
<a name="ln343">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln344"> </a>
<a name="ln345">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_PRELIGHT, TRUE);</a>
<a name="ln346"> </a>
<a name="ln347">  if(darktable.bauhaus-&gt;keys_cnt == 0) _stop_cursor();</a>
<a name="ln348"> </a>
<a name="ln349">  switch(w-&gt;type)</a>
<a name="ln350">  {</a>
<a name="ln351">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln352">      darktable.bauhaus-&gt;mouse_x = ex;</a>
<a name="ln353">      darktable.bauhaus-&gt;mouse_y = ey;</a>
<a name="ln354">      break;</a>
<a name="ln355">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln356">    {</a>
<a name="ln357">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln358">      const float mouse_off = get_slider_line_offset(d-&gt;oldpos, d-&gt;scale, ex / width, ey / height,</a>
<a name="ln359">                                                     allocation_w.height / (float)height, allocation.width);</a>
<a name="ln360">      if(!darktable.bauhaus-&gt;change_active)</a>
<a name="ln361">      {</a>
<a name="ln362">        if((darktable.bauhaus-&gt;mouse_line_distance &lt; 0 &amp;&amp; mouse_off &gt;= 0)</a>
<a name="ln363">           || (darktable.bauhaus-&gt;mouse_line_distance &gt; 0 &amp;&amp; mouse_off &lt;= 0))</a>
<a name="ln364">          darktable.bauhaus-&gt;change_active = 1;</a>
<a name="ln365">        darktable.bauhaus-&gt;mouse_line_distance = mouse_off;</a>
<a name="ln366">      }</a>
<a name="ln367">      if(darktable.bauhaus-&gt;change_active)</a>
<a name="ln368">      {</a>
<a name="ln369">        // remember mouse position for motion effects in draw</a>
<a name="ln370">        darktable.bauhaus-&gt;mouse_x = ex;</a>
<a name="ln371">        darktable.bauhaus-&gt;mouse_y = ey;</a>
<a name="ln372">        dt_bauhaus_slider_set_normalized(w, d-&gt;oldpos + mouse_off);</a>
<a name="ln373">      }</a>
<a name="ln374">    }</a>
<a name="ln375">    break;</a>
<a name="ln376">    default:</a>
<a name="ln377">      break;</a>
<a name="ln378">  }</a>
<a name="ln379">  // throttling using motion hint:</a>
<a name="ln380">  // gdk_event_request_motions(event);</a>
<a name="ln381">  return TRUE;</a>
<a name="ln382">}</a>
<a name="ln383"> </a>
<a name="ln384">static gboolean dt_bauhaus_popup_leave_notify(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln385">{</a>
<a name="ln386">  gtk_widget_set_state_flags(widget, GTK_STATE_FLAG_NORMAL, TRUE);</a>
<a name="ln387">  return TRUE;</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">static gboolean dt_bauhaus_popup_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln391">{</a>
<a name="ln392">  if(darktable.bauhaus-&gt;current &amp;&amp; (darktable.bauhaus-&gt;current-&gt;type == DT_BAUHAUS_COMBOBOX)</a>
<a name="ln393">     &amp;&amp; (event-&gt;button == 1) &amp;&amp;                                // only accept left mouse click</a>
<a name="ln394">     (dt_get_wtime() - darktable.bauhaus-&gt;opentime &gt;= 0.250f)) // default gtk timeout for double-clicks</a>
<a name="ln395">  {</a>
<a name="ln396">    gtk_widget_set_state_flags(widget, GTK_STATE_FLAG_ACTIVE, TRUE);</a>
<a name="ln397"> </a>
<a name="ln398">    // event might be in wrong system, transform ourselves:</a>
<a name="ln399">    gint wx, wy, x, y;</a>
<a name="ln400">    gdk_window_get_origin(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), &amp;wx, &amp;wy);</a>
<a name="ln401"> </a>
<a name="ln402">    gdk_device_get_position(</a>
<a name="ln403">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln404">        gdk_seat_get_pointer(gdk_display_get_default_seat(gtk_widget_get_display(widget))), 0, &amp;x, &amp;y);</a>
<a name="ln405">#else</a>
<a name="ln406">        gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gdk_display_get_default())), NULL, &amp;x,</a>
<a name="ln407">        &amp;y);</a>
<a name="ln408">#endif</a>
<a name="ln409">    darktable.bauhaus-&gt;end_mouse_x = x - wx;</a>
<a name="ln410">    darktable.bauhaus-&gt;end_mouse_y = y - wy;</a>
<a name="ln411">    dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln412">  }</a>
<a name="ln413">  dt_bauhaus_hide_popup();</a>
<a name="ln414">  return TRUE;</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">static gboolean dt_bauhaus_popup_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln418">{</a>
<a name="ln419">  if(event-&gt;button == 1)</a>
<a name="ln420">  {</a>
<a name="ln421">    if(darktable.bauhaus-&gt;current-&gt;type == DT_BAUHAUS_COMBOBOX</a>
<a name="ln422">       &amp;&amp; dt_get_wtime() - darktable.bauhaus-&gt;opentime &lt; 0.250f) // default gtk timeout for double-clicks</a>
<a name="ln423">    {</a>
<a name="ln424">      // counts as double click, reset:</a>
<a name="ln425">      dt_bauhaus_combobox_data_t *d = &amp;darktable.bauhaus-&gt;current-&gt;data.combobox;</a>
<a name="ln426">      dt_bauhaus_combobox_set(GTK_WIDGET(darktable.bauhaus-&gt;current), d-&gt;defpos);</a>
<a name="ln427">      dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln428">    }</a>
<a name="ln429">    else</a>
<a name="ln430">    {</a>
<a name="ln431">      // only accept left mouse click</a>
<a name="ln432">      darktable.bauhaus-&gt;end_mouse_x = event-&gt;x;</a>
<a name="ln433">      darktable.bauhaus-&gt;end_mouse_y = event-&gt;y;</a>
<a name="ln434">      dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln435">    }</a>
<a name="ln436">  }</a>
<a name="ln437">  else</a>
<a name="ln438">  {</a>
<a name="ln439">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln440">  }</a>
<a name="ln441">  return TRUE;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">static void dt_bauhaus_window_show(GtkWidget *w, gpointer user_data)</a>
<a name="ln445">{</a>
<a name="ln446">  // Could grab the popup_area rather than popup_window, but if so</a>
<a name="ln447">  // then popup_area would get all motion events including those</a>
<a name="ln448">  // outside of the popup. This way the popup_area gets motion events</a>
<a name="ln449">  // related to updating the popup, and popup_window gets all others</a>
<a name="ln450">  // which would be the ones telling it to close the popup.</a>
<a name="ln451">  gtk_grab_add(w);</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">static void dt_bh_init(DtBauhausWidget *class)</a>
<a name="ln455">{</a>
<a name="ln456">  // not sure if we want to use this instead of our code in *_new()</a>
<a name="ln457">  // TODO: the common code from bauhaus_widget_init() could go here.</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">static void dt_bh_class_init(DtBauhausWidgetClass *class)</a>
<a name="ln461">{</a>
<a name="ln462">  darktable.bauhaus-&gt;signals[DT_BAUHAUS_VALUE_CHANGED_SIGNAL]</a>
<a name="ln463">      = g_signal_new(&quot;value-changed&quot;, G_TYPE_FROM_CLASS(class), G_SIGNAL_RUN_LAST, 0, NULL, NULL,</a>
<a name="ln464">                     g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);</a>
<a name="ln465">  darktable.bauhaus-&gt;signals[DT_BAUHAUS_QUAD_PRESSED_SIGNAL]</a>
<a name="ln466">      = g_signal_new(&quot;quad-pressed&quot;, G_TYPE_FROM_CLASS(class), G_SIGNAL_RUN_LAST, 0, NULL, NULL,</a>
<a name="ln467">                     g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);</a>
<a name="ln468"> </a>
<a name="ln469">  // TODO: could init callbacks once per class for more efficiency:</a>
<a name="ln470">  // GtkWidgetClass *widget_class;</a>
<a name="ln471">  // widget_class = GTK_WIDGET_CLASS (class);</a>
<a name="ln472">  // widget_class-&gt;draw = dt_bauhaus_draw;</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">void dt_bauhaus_load_theme()</a>
<a name="ln476">{</a>
<a name="ln477">  darktable.bauhaus-&gt;line_space = 1.5;</a>
<a name="ln478">  darktable.bauhaus-&gt;line_height = 10;</a>
<a name="ln479">  darktable.bauhaus-&gt;marker_size = 0.25f;</a>
<a name="ln480">  darktable.bauhaus-&gt;label_font_size = 0.6f;</a>
<a name="ln481">  darktable.bauhaus-&gt;value_font_size = 0.6f;</a>
<a name="ln482"> </a>
<a name="ln483">  GtkWidget *root_window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln484">  GtkStyleContext *ctx = gtk_style_context_new();</a>
<a name="ln485">  GtkWidgetPath *path;</a>
<a name="ln486">  path = gtk_widget_path_new ();</a>
<a name="ln487">  int pos = gtk_widget_path_append_type(path, GTK_TYPE_WIDGET);</a>
<a name="ln488">  gtk_widget_path_iter_set_name(path, pos, &quot;iop-plugin-ui&quot;);</a>
<a name="ln489">  gtk_style_context_set_path(ctx, path);</a>
<a name="ln490">  gtk_style_context_set_screen (ctx, gtk_widget_get_screen(root_window));</a>
<a name="ln491"> </a>
<a name="ln492">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_fg&quot;, &amp;darktable.bauhaus-&gt;color_fg);</a>
<a name="ln493">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_fg_insensitive&quot;, &amp;darktable.bauhaus-&gt;color_fg_insensitive);</a>
<a name="ln494">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_bg&quot;, &amp;darktable.bauhaus-&gt;color_bg);</a>
<a name="ln495">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_border&quot;, &amp;darktable.bauhaus-&gt;color_border);</a>
<a name="ln496">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_fill&quot;, &amp;darktable.bauhaus-&gt;color_fill);</a>
<a name="ln497">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_indicator_border&quot;, &amp;darktable.bauhaus-&gt;indicator_border);</a>
<a name="ln498"> </a>
<a name="ln499">  gtk_style_context_lookup_color(ctx, &quot;graph_bg&quot;, &amp;darktable.bauhaus-&gt;graph_bg);</a>
<a name="ln500">  gtk_style_context_lookup_color(ctx, &quot;graph_border&quot;, &amp;darktable.bauhaus-&gt;graph_border);</a>
<a name="ln501">  gtk_style_context_lookup_color(ctx, &quot;graph_grid&quot;, &amp;darktable.bauhaus-&gt;graph_grid);</a>
<a name="ln502">  gtk_style_context_lookup_color(ctx, &quot;graph_fg&quot;, &amp;darktable.bauhaus-&gt;graph_fg);</a>
<a name="ln503">  gtk_style_context_lookup_color(ctx, &quot;graph_fg_active&quot;, &amp;darktable.bauhaus-&gt;graph_fg_active);</a>
<a name="ln504">  gtk_style_context_lookup_color(ctx, &quot;inset_histogram&quot;, &amp;darktable.bauhaus-&gt;inset_histogram);</a>
<a name="ln505"> </a>
<a name="ln506">  PangoFontDescription *pfont = 0;</a>
<a name="ln507">  gtk_style_context_get(ctx, GTK_STATE_FLAG_NORMAL, &quot;font&quot;, &amp;pfont, NULL);</a>
<a name="ln508">  gtk_widget_path_free(path);</a>
<a name="ln509"> </a>
<a name="ln510">  darktable.bauhaus-&gt;pango_font_desc = pfont;</a>
<a name="ln511"> </a>
<a name="ln512">  PangoLayout *layout;</a>
<a name="ln513">  cairo_surface_t *cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 128, 128);</a>
<a name="ln514">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln515">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln516">  pango_layout_set_text(layout, &quot;X&quot;, -1);</a>
<a name="ln517">  pango_layout_set_font_description(layout, darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln518">  pango_cairo_context_set_resolution(pango_layout_get_context(layout), darktable.gui-&gt;dpi);</a>
<a name="ln519">  int pango_width, pango_height;</a>
<a name="ln520">  pango_layout_get_size(layout, &amp;pango_width, &amp;pango_height);</a>
<a name="ln521">  g_object_unref(layout);</a>
<a name="ln522">  cairo_destroy(cr);</a>
<a name="ln523">  cairo_surface_destroy(cst);</a>
<a name="ln524"> </a>
<a name="ln525">  darktable.bauhaus-&gt;scale = 1.3f;</a>
<a name="ln526">  darktable.bauhaus-&gt;line_height = pango_height / PANGO_SCALE;</a>
<a name="ln527">  darktable.bauhaus-&gt;widget_space = INNER_PADDING / 2.0f; // used as a top/bottom margin for widgets</a>
<a name="ln528">  darktable.bauhaus-&gt;quad_width = darktable.bauhaus-&gt;line_height;</a>
<a name="ln529"> </a>
<a name="ln530">  darktable.bauhaus-&gt;baseline_size = darktable.bauhaus-&gt;line_height / 2.0f; // absolute size in Cairo unit</a>
<a name="ln531">  darktable.bauhaus-&gt;border_width = 3.0f; // absolute size in Cairo unit</a>
<a name="ln532">  darktable.bauhaus-&gt;marker_size = (darktable.bauhaus-&gt;baseline_size + darktable.bauhaus-&gt;border_width) * 0.75f;</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">void dt_bauhaus_init()</a>
<a name="ln536">{</a>
<a name="ln537">  darktable.bauhaus = (dt_bauhaus_t *)calloc(1, sizeof(dt_bauhaus_t));</a>
<a name="ln538">  darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln539">  darktable.bauhaus-&gt;current = NULL;</a>
<a name="ln540">  darktable.bauhaus-&gt;popup_area = gtk_drawing_area_new();</a>
<a name="ln541">  gtk_widget_set_name(darktable.bauhaus-&gt;popup_area, &quot;bauhaus-popup&quot;);</a>
<a name="ln542"> </a>
<a name="ln543">  dt_bauhaus_load_theme();</a>
<a name="ln544"> </a>
<a name="ln545">  // keys are freed with g_free, values are ptrs to the widgets, these don't need to be cleaned up.</a>
<a name="ln546">  darktable.bauhaus-&gt;keymap = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);</a>
<a name="ln547">  darktable.bauhaus-&gt;key_mod = NULL;</a>
<a name="ln548">  darktable.bauhaus-&gt;key_val = NULL;</a>
<a name="ln549">  memset(darktable.bauhaus-&gt;key_history, 0, sizeof(darktable.bauhaus-&gt;key_history));</a>
<a name="ln550"> </a>
<a name="ln551">  // this easily gets keyboard input:</a>
<a name="ln552">  // darktable.bauhaus-&gt;popup_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</a>
<a name="ln553">  // but this doesn't flicker, and the above hack with key input seems to work well.</a>
<a name="ln554">  darktable.bauhaus-&gt;popup_window = gtk_window_new(GTK_WINDOW_POPUP);</a>
<a name="ln555">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln556">  dt_osx_disallow_fullscreen(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln557">#endif</a>
<a name="ln558">  // this is needed for popup, not for toplevel.</a>
<a name="ln559">  // since popup_area gets the focus if we show the window, this is all</a>
<a name="ln560">  // we need.</a>
<a name="ln561">  dt_gui_key_accel_block_on_focus_connect(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln562"> </a>
<a name="ln563">  gtk_widget_set_size_request(darktable.bauhaus-&gt;popup_area, DT_PIXEL_APPLY_DPI(300), DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln564">  gtk_window_set_resizable(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), FALSE);</a>
<a name="ln565">  gtk_window_set_default_size(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), 260, 260);</a>
<a name="ln566">  // gtk_window_set_modal(GTK_WINDOW(c-&gt;popup_window), TRUE);</a>
<a name="ln567">  // gtk_window_set_decorated(GTK_WINDOW(c-&gt;popup_window), FALSE);</a>
<a name="ln568"> </a>
<a name="ln569">  // for pie menu:</a>
<a name="ln570">  // gtk_window_set_position(GTK_WINDOW(c-&gt;popup_window), GTK_WIN_POS_MOUSE);// | GTK_WIN_POS_CENTER);</a>
<a name="ln571"> </a>
<a name="ln572">  // gtk_window_set_keep_above isn't enough on OS X</a>
<a name="ln573">  gtk_window_set_transient_for(GTK_WINDOW(darktable.bauhaus-&gt;popup_window),</a>
<a name="ln574">                               GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)));</a>
<a name="ln575">  gtk_container_add(GTK_CONTAINER(darktable.bauhaus-&gt;popup_window), darktable.bauhaus-&gt;popup_area);</a>
<a name="ln576">  // gtk_window_set_title(GTK_WINDOW(c-&gt;popup_window), _(&quot;dtgtk control popup&quot;));</a>
<a name="ln577">  gtk_window_set_keep_above(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), TRUE);</a>
<a name="ln578">  gtk_window_set_gravity(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), GDK_GRAVITY_STATIC);</a>
<a name="ln579"> </a>
<a name="ln580">  gtk_widget_set_can_focus(darktable.bauhaus-&gt;popup_area, TRUE);</a>
<a name="ln581">  gtk_widget_add_events(darktable.bauhaus-&gt;popup_area, GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln582">                                                       | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln583">                                                       | GDK_KEY_PRESS_MASK | GDK_LEAVE_NOTIFY_MASK</a>
<a name="ln584">                                                       | darktable.gui-&gt;scroll_mask);</a>
<a name="ln585"> </a>
<a name="ln586">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_window), &quot;show&quot;, G_CALLBACK(dt_bauhaus_window_show), (gpointer)NULL);</a>
<a name="ln587">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;draw&quot;, G_CALLBACK(dt_bauhaus_popup_draw),</a>
<a name="ln588">                   (gpointer)NULL);</a>
<a name="ln589">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_window), &quot;motion-notify-event&quot;,</a>
<a name="ln590">                   G_CALLBACK(dt_bauhaus_window_motion_notify), (gpointer)NULL);</a>
<a name="ln591">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_window), &quot;button-press-event&quot;, G_CALLBACK(dt_bauhaus_window_button_press),</a>
<a name="ln592">                   (gpointer)NULL);</a>
<a name="ln593">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;motion-notify-event&quot;,</a>
<a name="ln594">                   G_CALLBACK(dt_bauhaus_popup_motion_notify), (gpointer)NULL);</a>
<a name="ln595">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;leave-notify-event&quot;,</a>
<a name="ln596">                   G_CALLBACK(dt_bauhaus_popup_leave_notify), (gpointer)NULL);</a>
<a name="ln597">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;button-press-event&quot;,</a>
<a name="ln598">                   G_CALLBACK(dt_bauhaus_popup_button_press), (gpointer)NULL);</a>
<a name="ln599">  // this is connected to the widget itself, not the popup. we're only interested</a>
<a name="ln600">  // in mouse release events that are initiated by a press on the original widget.</a>
<a name="ln601">  g_signal_connect (G_OBJECT (darktable.bauhaus-&gt;popup_area), &quot;button-release-event&quot;,</a>
<a name="ln602">                    G_CALLBACK (dt_bauhaus_popup_button_release), (gpointer)NULL);</a>
<a name="ln603">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;key-press-event&quot;,</a>
<a name="ln604">                   G_CALLBACK(dt_bauhaus_popup_key_press), (gpointer)NULL);</a>
<a name="ln605">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;scroll-event&quot;,</a>
<a name="ln606">                   G_CALLBACK(dt_bauhaus_popup_scroll), (gpointer)NULL);</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">void dt_bauhaus_cleanup()</a>
<a name="ln610">{</a>
<a name="ln611">  // TODO: destroy popup window and resources</a>
<a name="ln612">  // TODO: destroy keymap hash table!</a>
<a name="ln613">  g_list_free_full(darktable.bauhaus-&gt;key_mod, (GDestroyNotify)g_free);</a>
<a name="ln614">  g_list_free_full(darktable.bauhaus-&gt;key_val, (GDestroyNotify)g_free);</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">// fwd declare a few callbacks</a>
<a name="ln618">static gboolean dt_bauhaus_slider_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln619">static gboolean dt_bauhaus_slider_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln620">static gboolean dt_bauhaus_slider_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data);</a>
<a name="ln621">static gboolean dt_bauhaus_slider_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);</a>
<a name="ln622">static gboolean dt_bauhaus_slider_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data);</a>
<a name="ln623"> </a>
<a name="ln624"> </a>
<a name="ln625">static gboolean dt_bauhaus_combobox_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln626">static gboolean dt_bauhaus_combobox_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data);</a>
<a name="ln627">static gboolean dt_bauhaus_combobox_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);</a>
<a name="ln628"> </a>
<a name="ln629">// static gboolean</a>
<a name="ln630">// dt_bauhaus_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln631">static gboolean dt_bauhaus_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data);</a>
<a name="ln632"> </a>
<a name="ln633"> </a>
<a name="ln634">// end static init/cleanup</a>
<a name="ln635">// =================================================</a>
<a name="ln636"> </a>
<a name="ln637"> </a>
<a name="ln638"> </a>
<a name="ln639">// common initialization</a>
<a name="ln640">static void dt_bauhaus_widget_init(dt_bauhaus_widget_t *w, dt_iop_module_t *self)</a>
<a name="ln641">{</a>
<a name="ln642">  w-&gt;module = self;</a>
<a name="ln643"> </a>
<a name="ln644">  // no quad icon and no toggle button:</a>
<a name="ln645">  w-&gt;quad_paint = 0;</a>
<a name="ln646">  w-&gt;quad_paint_data = NULL;</a>
<a name="ln647">  w-&gt;quad_toggle = 0;</a>
<a name="ln648">  w-&gt;combo_populate = NULL;</a>
<a name="ln649"> </a>
<a name="ln650"> </a>
<a name="ln651">  switch(w-&gt;type)</a>
<a name="ln652">  {</a>
<a name="ln653">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln654">    {</a>
<a name="ln655">      gtk_widget_set_name(GTK_WIDGET(w), &quot;bauhaus-slider&quot;);</a>
<a name="ln656">      gtk_widget_set_size_request(GTK_WIDGET(w), -1, 2 * darktable.bauhaus-&gt;widget_space + INNER_PADDING + darktable.bauhaus-&gt;baseline_size + get_line_height() - darktable.bauhaus-&gt;border_width / 2.0f);</a>
<a name="ln657">      break;</a>
<a name="ln658">    }</a>
<a name="ln659">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln660">    {</a>
<a name="ln661">      gtk_widget_set_name(GTK_WIDGET(w), &quot;bauhaus-combobox&quot;);</a>
<a name="ln662">      gtk_widget_set_size_request(GTK_WIDGET(w), -1, 2 * darktable.bauhaus-&gt;widget_space + get_line_height());</a>
<a name="ln663">      break;</a>
<a name="ln664">    }</a>
<a name="ln665">  }</a>
<a name="ln666"> </a>
<a name="ln667">  gtk_widget_add_events(GTK_WIDGET(w), GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln668">                                       | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln669">                                       | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK</a>
<a name="ln670">                                       | GDK_FOCUS_CHANGE_MASK</a>
<a name="ln671">                                       | darktable.gui-&gt;scroll_mask);</a>
<a name="ln672"> </a>
<a name="ln673">  g_signal_connect(G_OBJECT(w), &quot;draw&quot;, G_CALLBACK(dt_bauhaus_draw), NULL);</a>
<a name="ln674"> </a>
<a name="ln675">  // for combobox, where mouse-release triggers a selection, we need to catch this</a>
<a name="ln676">  // event where the mouse-press occurred, which will be this widget. we just pass</a>
<a name="ln677">  // it on though:</a>
<a name="ln678">  // g_signal_connect (G_OBJECT (w), &quot;button-release-event&quot;,</a>
<a name="ln679">  //                   G_CALLBACK (dt_bauhaus_popup_button_release), (gpointer)NULL);</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">void dt_bauhaus_combobox_set_default(GtkWidget *widget, int def)</a>
<a name="ln683">{</a>
<a name="ln684">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln685">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln686">  d-&gt;defpos = def;</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">int dt_bauhaus_combobox_get_default(GtkWidget *widget)</a>
<a name="ln690">{</a>
<a name="ln691">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln692">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln693">  return d-&gt;defpos;</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">void dt_bauhaus_slider_set_hard_min(GtkWidget* widget, float val)</a>
<a name="ln697">{</a>
<a name="ln698">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln699">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln700">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln701">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln702">  d-&gt;hard_min = rawval;</a>
<a name="ln703">  d-&gt;min = MAX(d-&gt;min, d-&gt;hard_min);</a>
<a name="ln704">  d-&gt;soft_min = MAX(d-&gt;soft_min, d-&gt;hard_min);</a>
<a name="ln705">  if(rawval &gt; d-&gt;hard_max) dt_bauhaus_slider_set_hard_max(widget,val);</a>
<a name="ln706">  if(pos &lt; val)</a>
<a name="ln707">  {</a>
<a name="ln708">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln709">  }</a>
<a name="ln710">  else</a>
<a name="ln711">  {</a>
<a name="ln712">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln713">  }</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">float dt_bauhaus_slider_get_hard_min(GtkWidget* widget)</a>
<a name="ln717">{</a>
<a name="ln718">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln719">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln720">  return d-&gt;callback(widget, d-&gt;hard_min, DT_BAUHAUS_GET);</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">void dt_bauhaus_slider_set_hard_max(GtkWidget* widget, float val)</a>
<a name="ln724">{</a>
<a name="ln725">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln726">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln727">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln728">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln729">  d-&gt;hard_max = rawval;</a>
<a name="ln730">  d-&gt;max = MIN(d-&gt;max, d-&gt;hard_max);</a>
<a name="ln731">  d-&gt;soft_max = MIN(d-&gt;soft_max, d-&gt;hard_max);</a>
<a name="ln732">  if(rawval &lt; d-&gt;hard_min) dt_bauhaus_slider_set_hard_min(widget,val);</a>
<a name="ln733">  if(pos &gt; val) {</a>
<a name="ln734">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln735">  }</a>
<a name="ln736">  else</a>
<a name="ln737">  {</a>
<a name="ln738">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln739">  }</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">float dt_bauhaus_slider_get_hard_max(GtkWidget* widget)</a>
<a name="ln743">{</a>
<a name="ln744">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln745">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln746">  return d-&gt;callback(widget, d-&gt;hard_max, DT_BAUHAUS_GET);</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">void dt_bauhaus_slider_set_soft_min(GtkWidget* widget, float val)</a>
<a name="ln750">{</a>
<a name="ln751">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln752">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln753">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln754">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln755">  d-&gt;soft_min = rawval;</a>
<a name="ln756">  d-&gt;hard_min = MIN(d-&gt;hard_min,d-&gt;soft_min);</a>
<a name="ln757">  d-&gt;min =  d-&gt;soft_min;</a>
<a name="ln758">  if(rawval &gt; d-&gt;soft_max) dt_bauhaus_slider_set_soft_max(widget,val);</a>
<a name="ln759">  if(rawval &gt; d-&gt;hard_max) dt_bauhaus_slider_set_hard_max(widget,val);</a>
<a name="ln760">  if(pos &lt; val)</a>
<a name="ln761">  {</a>
<a name="ln762">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln763">  }</a>
<a name="ln764">  else</a>
<a name="ln765">  {</a>
<a name="ln766">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln767">  }</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770">float dt_bauhaus_slider_get_soft_min(GtkWidget* widget)</a>
<a name="ln771">{</a>
<a name="ln772">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln773">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln774">  return d-&gt;callback(widget, d-&gt;soft_min, DT_BAUHAUS_GET);</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">void dt_bauhaus_slider_set_soft_max(GtkWidget* widget, float val)</a>
<a name="ln778">{</a>
<a name="ln779">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln780">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln781">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln782">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln783">  d-&gt;soft_max = rawval;</a>
<a name="ln784">  d-&gt;hard_max = MAX(d-&gt;soft_max, d-&gt;hard_max);</a>
<a name="ln785">  d-&gt;max =  d-&gt;soft_max;</a>
<a name="ln786">  if(rawval &lt; d-&gt;soft_min) dt_bauhaus_slider_set_soft_min(widget,val);</a>
<a name="ln787">  if(rawval &lt; d-&gt;hard_min) dt_bauhaus_slider_set_hard_min(widget,val);</a>
<a name="ln788">  if(pos &gt; val) {</a>
<a name="ln789">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln790">  } else {</a>
<a name="ln791">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln792">  }</a>
<a name="ln793">}</a>
<a name="ln794"> </a>
<a name="ln795">float dt_bauhaus_slider_get_soft_max(GtkWidget* widget)</a>
<a name="ln796">{</a>
<a name="ln797">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln798">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln799">  return d-&gt;callback(widget, d-&gt;soft_max, DT_BAUHAUS_GET);</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">void dt_bauhaus_slider_set_default(GtkWidget *widget, float def)</a>
<a name="ln803">{</a>
<a name="ln804">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln805">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln806">  float val = d-&gt;callback(widget, def, DT_BAUHAUS_SET);</a>
<a name="ln807">  d-&gt;defpos = (val - d-&gt;min) / (d-&gt;max - d-&gt;min);</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810">void dt_bauhaus_slider_enable_soft_boundaries(GtkWidget *widget, float hard_min, float hard_max)</a>
<a name="ln811">{</a>
<a name="ln812">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln813">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln814">  d-&gt;hard_min = d-&gt;callback(widget, hard_min, DT_BAUHAUS_SET);</a>
<a name="ln815">  d-&gt;hard_max = d-&gt;callback(widget, hard_max, DT_BAUHAUS_SET);</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">void dt_bauhaus_widget_set_label(GtkWidget *widget, const char *section, const char *label)</a>
<a name="ln819">{</a>
<a name="ln820">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln821">  memset(w-&gt;label, 0, sizeof(w-&gt;label)); // keep valgrind happy</a>
<a name="ln822">  g_strlcpy(w-&gt;label, label, sizeof(w-&gt;label));</a>
<a name="ln823"> </a>
<a name="ln824">  if(w-&gt;module)</a>
<a name="ln825">  {</a>
<a name="ln826">    // construct control path name and insert into keymap:</a>
<a name="ln827">    gchar *path;</a>
<a name="ln828">    if(section &amp;&amp; section[0] != '\0')</a>
<a name="ln829">    {</a>
<a name="ln830">      path = g_strdup_printf(&quot;%s.%s.%s&quot;, w-&gt;module-&gt;name(), section, w-&gt;label);</a>
<a name="ln831">      gchar *section_path = g_strdup_printf(&quot;%s.%s&quot;, w-&gt;module-&gt;name(), section);</a>
<a name="ln832">      if(!g_list_find_custom(darktable.bauhaus-&gt;key_val, section_path, (GCompareFunc)strcmp))</a>
<a name="ln833">        darktable.bauhaus-&gt;key_val</a>
<a name="ln834">            = g_list_insert_sorted(darktable.bauhaus-&gt;key_val, section_path, (GCompareFunc)strcmp);</a>
<a name="ln835">      else</a>
<a name="ln836">        g_free(section_path);</a>
<a name="ln837">    }</a>
<a name="ln838">    else</a>
<a name="ln839">      path = g_strdup_printf(&quot;%s.%s&quot;, w-&gt;module-&gt;name(), w-&gt;label);</a>
<a name="ln840">    if(!g_hash_table_lookup(darktable.bauhaus-&gt;keymap, path))</a>
<a name="ln841">    {</a>
<a name="ln842">      // also insert into sorted tab-complete list.</a>
<a name="ln843">      // (but only if this is the first time we insert this path)</a>
<a name="ln844">      gchar *mod = g_strdup(path);</a>
<a name="ln845">      gchar *val = g_strstr_len(mod, strlen(mod), &quot;.&quot;);</a>
<a name="ln846">      if(val)</a>
<a name="ln847">      {</a>
<a name="ln848">        *val = 0;</a>
<a name="ln849">        if(!g_list_find_custom(darktable.bauhaus-&gt;key_mod, mod, (GCompareFunc)strcmp))</a>
<a name="ln850">          darktable.bauhaus-&gt;key_mod</a>
<a name="ln851">              = g_list_insert_sorted(darktable.bauhaus-&gt;key_mod, mod, (GCompareFunc)strcmp);</a>
<a name="ln852">        else</a>
<a name="ln853">          g_free(mod);</a>
<a name="ln854"> </a>
<a name="ln855">        // unfortunately need our own string, as replace in the hashtable below might destroy this pointer.</a>
<a name="ln856">        darktable.bauhaus-&gt;key_val</a>
<a name="ln857">            = g_list_insert_sorted(darktable.bauhaus-&gt;key_val, g_strdup(path), (GCompareFunc)strcmp);</a>
<a name="ln858">      }</a>
<a name="ln859">    }</a>
<a name="ln860">    // might free an old path</a>
<a name="ln861">    g_hash_table_replace(darktable.bauhaus-&gt;keymap, path, w);</a>
<a name="ln862">    gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln863">  }</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866">const char* dt_bauhaus_widget_get_label(GtkWidget *widget)</a>
<a name="ln867">{</a>
<a name="ln868">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln869">  return w-&gt;label;</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872">void dt_bauhaus_widget_set_quad_paint(GtkWidget *widget, dt_bauhaus_quad_paint_f f, int paint_flags, void *paint_data)</a>
<a name="ln873">{</a>
<a name="ln874">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln875">  w-&gt;quad_paint = f;</a>
<a name="ln876">  w-&gt;quad_paint_flags = paint_flags;</a>
<a name="ln877">  w-&gt;quad_paint_data = paint_data;</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880">// make this quad a toggle button:</a>
<a name="ln881">void dt_bauhaus_widget_set_quad_toggle(GtkWidget *widget, int toggle)</a>
<a name="ln882">{</a>
<a name="ln883">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln884">  w-&gt;quad_toggle = toggle;</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887">void dt_bauhaus_widget_set_quad_active(GtkWidget *widget, int active)</a>
<a name="ln888">{</a>
<a name="ln889">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln890">  if (active)</a>
<a name="ln891">    w-&gt;quad_paint_flags |= CPF_ACTIVE;</a>
<a name="ln892">  else</a>
<a name="ln893">    w-&gt;quad_paint_flags &amp;= ~CPF_ACTIVE;</a>
<a name="ln894">  gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln895">}</a>
<a name="ln896"> </a>
<a name="ln897">int dt_bauhaus_widget_get_quad_active(GtkWidget *widget)</a>
<a name="ln898">{</a>
<a name="ln899">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln900">  return (w-&gt;quad_paint_flags &amp; CPF_ACTIVE) == CPF_ACTIVE;</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">static float _default_linear_callback(GtkWidget *self, float value, dt_bauhaus_callback_t dir)</a>
<a name="ln904">{</a>
<a name="ln905">  // regardless of dir: input &lt;-&gt; output</a>
<a name="ln906">  return value;</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">static void dt_bauhaus_slider_destroy(dt_bauhaus_widget_t *widget, gpointer user_data)</a>
<a name="ln910">{</a>
<a name="ln911">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln912">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln913">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln914">  if(d-&gt;timeout_handle) g_source_remove(d-&gt;timeout_handle);</a>
<a name="ln915">  d-&gt;timeout_handle = 0;</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">GtkWidget *dt_bauhaus_slider_new(dt_iop_module_t *self)</a>
<a name="ln919">{</a>
<a name="ln920">  return dt_bauhaus_slider_new_with_range(self, 0.0, 1.0, 0.1, 0.5, 3);</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923">GtkWidget *dt_bauhaus_slider_new_with_range(dt_iop_module_t *self, float min, float max, float step,</a>
<a name="ln924">                                            float defval, int digits)</a>
<a name="ln925">{</a>
<a name="ln926">  return dt_bauhaus_slider_new_with_range_and_feedback(self, min, max, step, defval, digits, 1);</a>
<a name="ln927">}</a>
<a name="ln928"> </a>
<a name="ln929">GtkWidget *dt_bauhaus_slider_new_with_range_and_feedback(dt_iop_module_t *self, float min, float max,</a>
<a name="ln930">                                                         float step, float defval, int digits, int feedback)</a>
<a name="ln931">{</a>
<a name="ln932">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(g_object_new(DT_BAUHAUS_WIDGET_TYPE, NULL));</a>
<a name="ln933">  return dt_bauhaus_slider_from_widget(w,self, min, max, step, defval, digits, feedback);</a>
<a name="ln934">}</a>
<a name="ln935">GtkWidget *dt_bauhaus_slider_from_widget(dt_bauhaus_widget_t* w,dt_iop_module_t *self, float min, float max,</a>
<a name="ln936">                                                         float step, float defval, int digits, int feedback)</a>
<a name="ln937">{</a>
<a name="ln938">  w-&gt;type = DT_BAUHAUS_SLIDER;</a>
<a name="ln939">  dt_bauhaus_widget_init(w, self);</a>
<a name="ln940">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln941">  d-&gt;min = d-&gt;soft_min = d-&gt;hard_min = min;</a>
<a name="ln942">  d-&gt;max = d-&gt;soft_max = d-&gt;hard_max = max;</a>
<a name="ln943">  d-&gt;step = step;</a>
<a name="ln944">  // normalize default:</a>
<a name="ln945">  d-&gt;defpos = (defval - min) / (max - min);</a>
<a name="ln946">  d-&gt;pos = d-&gt;defpos;</a>
<a name="ln947">  d-&gt;oldpos = d-&gt;defpos;</a>
<a name="ln948">  d-&gt;scale = 5.0f * step / (max - min);</a>
<a name="ln949">  d-&gt;digits = digits;</a>
<a name="ln950">  snprintf(d-&gt;format, sizeof(d-&gt;format), &quot;%%.0%df&quot;, digits);</a>
<a name="ln951"> </a>
<a name="ln952">  d-&gt;grad_cnt = 0;</a>
<a name="ln953"> </a>
<a name="ln954">  d-&gt;fill_feedback = feedback;</a>
<a name="ln955"> </a>
<a name="ln956">  d-&gt;is_dragging = 0;</a>
<a name="ln957">  d-&gt;is_changed = 0;</a>
<a name="ln958">  d-&gt;timeout_handle = 0;</a>
<a name="ln959">  d-&gt;callback = _default_linear_callback;</a>
<a name="ln960"> </a>
<a name="ln961">  gtk_widget_add_events(GTK_WIDGET(w), GDK_KEY_PRESS_MASK);</a>
<a name="ln962">  gtk_widget_set_can_focus(GTK_WIDGET(w), TRUE);</a>
<a name="ln963"> </a>
<a name="ln964">  g_signal_connect(G_OBJECT(w), &quot;button-press-event&quot;, G_CALLBACK(dt_bauhaus_slider_button_press),</a>
<a name="ln965">                   (gpointer)NULL);</a>
<a name="ln966">  g_signal_connect(G_OBJECT(w), &quot;button-release-event&quot;, G_CALLBACK(dt_bauhaus_slider_button_release),</a>
<a name="ln967">                   (gpointer)NULL);</a>
<a name="ln968">  g_signal_connect(G_OBJECT(w), &quot;scroll-event&quot;, G_CALLBACK(dt_bauhaus_slider_scroll), (gpointer)NULL);</a>
<a name="ln969">  g_signal_connect(G_OBJECT(w), &quot;key-press-event&quot;, G_CALLBACK(dt_bauhaus_slider_key_press), (gpointer)NULL);</a>
<a name="ln970">  g_signal_connect(G_OBJECT(w), &quot;motion-notify-event&quot;, G_CALLBACK(dt_bauhaus_slider_motion_notify),</a>
<a name="ln971">                   (gpointer)NULL);</a>
<a name="ln972">  g_signal_connect(G_OBJECT(w), &quot;destroy&quot;, G_CALLBACK(dt_bauhaus_slider_destroy), (gpointer)NULL);</a>
<a name="ln973">  return GTK_WIDGET(w);</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976">static void dt_bauhaus_combobox_destroy(dt_bauhaus_widget_t *widget, gpointer user_data)</a>
<a name="ln977">{</a>
<a name="ln978">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln979">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln980">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln981">  g_list_free_full(d-&gt;entries, free_combobox_entry);</a>
<a name="ln982">  d-&gt;entries = NULL;</a>
<a name="ln983">  d-&gt;num_labels = 0;</a>
<a name="ln984">  d-&gt;active = -1;</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987">GtkWidget *dt_bauhaus_combobox_new(dt_iop_module_t *self)</a>
<a name="ln988">{</a>
<a name="ln989">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(g_object_new(DT_BAUHAUS_WIDGET_TYPE, NULL));</a>
<a name="ln990">  dt_bauhaus_combobox_from_widget(w,self);</a>
<a name="ln991">  return GTK_WIDGET(w);</a>
<a name="ln992">}</a>
<a name="ln993"> </a>
<a name="ln994">void dt_bauhaus_combobox_from_widget(dt_bauhaus_widget_t* w,dt_iop_module_t *self)</a>
<a name="ln995">{</a>
<a name="ln996">  w-&gt;type = DT_BAUHAUS_COMBOBOX;</a>
<a name="ln997">  dt_bauhaus_widget_init(w, self);</a>
<a name="ln998">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln999">  d-&gt;entries = NULL;</a>
<a name="ln1000">  d-&gt;num_labels = 0;</a>
<a name="ln1001">  d-&gt;defpos = 0;</a>
<a name="ln1002">  d-&gt;active = -1;</a>
<a name="ln1003">  d-&gt;editable = 0;</a>
<a name="ln1004">  memset(d-&gt;text, 0, sizeof(d-&gt;text));</a>
<a name="ln1005"> </a>
<a name="ln1006">  gtk_widget_add_events(GTK_WIDGET(w), GDK_KEY_PRESS_MASK);</a>
<a name="ln1007">  gtk_widget_set_can_focus(GTK_WIDGET(w), TRUE);</a>
<a name="ln1008"> </a>
<a name="ln1009">  g_signal_connect(G_OBJECT(w), &quot;button-press-event&quot;, G_CALLBACK(dt_bauhaus_combobox_button_press),</a>
<a name="ln1010">                   (gpointer)NULL);</a>
<a name="ln1011">  g_signal_connect(G_OBJECT(w), &quot;button-release-event&quot;, G_CALLBACK(dt_bauhaus_popup_button_release),</a>
<a name="ln1012">                   (gpointer)NULL);</a>
<a name="ln1013">  g_signal_connect(G_OBJECT(w), &quot;scroll-event&quot;, G_CALLBACK(dt_bauhaus_combobox_scroll), (gpointer)NULL);</a>
<a name="ln1014">  g_signal_connect(G_OBJECT(w), &quot;key-press-event&quot;, G_CALLBACK(dt_bauhaus_combobox_key_press), (gpointer)NULL);</a>
<a name="ln1015">  g_signal_connect(G_OBJECT(w), &quot;destroy&quot;, G_CALLBACK(dt_bauhaus_combobox_destroy), (gpointer)NULL);</a>
<a name="ln1016">}</a>
<a name="ln1017"> </a>
<a name="ln1018">void dt_bauhaus_combobox_add_populate_fct(GtkWidget *widget, void (*fct)(GtkWidget *w, struct dt_iop_module_t **module))</a>
<a name="ln1019">{</a>
<a name="ln1020">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1021">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1022">  w-&gt;combo_populate = fct;</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">void dt_bauhaus_combobox_add(GtkWidget *widget, const char *text)</a>
<a name="ln1026">{</a>
<a name="ln1027">  dt_bauhaus_combobox_add_full(widget, text, DT_BAUHAUS_COMBOBOX_ALIGN_RIGHT, NULL, NULL);</a>
<a name="ln1028">}</a>
<a name="ln1029"> </a>
<a name="ln1030">void dt_bauhaus_combobox_add_aligned(GtkWidget *widget, const char *text, dt_bauhaus_combobox_alignment_t align)</a>
<a name="ln1031">{</a>
<a name="ln1032">  dt_bauhaus_combobox_add_full(widget, text, align, NULL, NULL);</a>
<a name="ln1033">}</a>
<a name="ln1034"> </a>
<a name="ln1035">void dt_bauhaus_combobox_add_full(GtkWidget *widget, const char *text, dt_bauhaus_combobox_alignment_t align,</a>
<a name="ln1036">                                  gpointer data, void (free_func)(void *data))</a>
<a name="ln1037">{</a>
<a name="ln1038">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1039">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1040">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1041">  d-&gt;num_labels++;</a>
<a name="ln1042">  dt_bauhaus_combobox_entry_t *entry = new_combobox_entry(text, align, TRUE, data, free_func);</a>
<a name="ln1043">  d-&gt;entries = g_list_append(d-&gt;entries, entry);</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046">void dt_bauhaus_combobox_set_editable(GtkWidget *widget, int editable)</a>
<a name="ln1047">{</a>
<a name="ln1048">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1049">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1050">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1051">  d-&gt;editable = editable ? 1 : 0;</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054">int dt_bauhaus_combobox_get_editable(GtkWidget *widget)</a>
<a name="ln1055">{</a>
<a name="ln1056">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1057">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return 0;</a>
<a name="ln1058">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1059">  return d-&gt;editable;</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062">void dt_bauhaus_combobox_remove_at(GtkWidget *widget, int pos)</a>
<a name="ln1063">{</a>
<a name="ln1064">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1065">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1066">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1067"> </a>
<a name="ln1068">  if(pos &lt; 0 || pos &gt;= d-&gt;num_labels) return;</a>
<a name="ln1069"> </a>
<a name="ln1070">  GList *rm = g_list_nth(d-&gt;entries, pos);</a>
<a name="ln1071">  free_combobox_entry(rm-&gt;data);</a>
<a name="ln1072">  d-&gt;entries = g_list_delete_link(d-&gt;entries, rm);</a>
<a name="ln1073"> </a>
<a name="ln1074">  d-&gt;num_labels--;</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077">void dt_bauhaus_combobox_insert(GtkWidget *widget, const char *text,int pos)</a>
<a name="ln1078">{</a>
<a name="ln1079">  dt_bauhaus_combobox_insert_full(widget, text, DT_BAUHAUS_COMBOBOX_ALIGN_RIGHT, NULL, NULL, pos);</a>
<a name="ln1080">}</a>
<a name="ln1081"> </a>
<a name="ln1082">void dt_bauhaus_combobox_insert_full(GtkWidget *widget, const char *text, dt_bauhaus_combobox_alignment_t align,</a>
<a name="ln1083">                                     gpointer data, void (*free_func)(void *), int pos)</a>
<a name="ln1084">{</a>
<a name="ln1085">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1086">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1087">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1088">  d-&gt;num_labels++;</a>
<a name="ln1089">  d-&gt;entries = g_list_insert(d-&gt;entries, new_combobox_entry(text, align, TRUE, data, free_func), pos);</a>
<a name="ln1090">}</a>
<a name="ln1091"> </a>
<a name="ln1092">int dt_bauhaus_combobox_length(GtkWidget *widget)</a>
<a name="ln1093">{</a>
<a name="ln1094">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1095">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return 0;</a>
<a name="ln1096">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1097"> </a>
<a name="ln1098">  return d-&gt;num_labels;</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">const char *dt_bauhaus_combobox_get_text(GtkWidget *widget)</a>
<a name="ln1102">{</a>
<a name="ln1103">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1104">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return NULL;</a>
<a name="ln1105">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1106"> </a>
<a name="ln1107">  if(d-&gt;editable &amp;&amp; d-&gt;active &lt; 0)</a>
<a name="ln1108">  {</a>
<a name="ln1109">    return d-&gt;text;</a>
<a name="ln1110">  }</a>
<a name="ln1111">  else</a>
<a name="ln1112">  {</a>
<a name="ln1113">    if(d-&gt;active &lt; 0 || d-&gt;active &gt;= d-&gt;num_labels) return NULL;</a>
<a name="ln1114">    const dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(d-&gt;entries, d-&gt;active);</a>
<a name="ln1115">    return entry-&gt;label;</a>
<a name="ln1116">  }</a>
<a name="ln1117">  return NULL;</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">gpointer dt_bauhaus_combobox_get_data(GtkWidget *widget)</a>
<a name="ln1121">{</a>
<a name="ln1122">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1123">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return NULL;</a>
<a name="ln1124">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1125">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(d-&gt;entries, d-&gt;active);</a>
<a name="ln1126">  return entry ? entry-&gt;data : NULL;</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129">void dt_bauhaus_combobox_clear(GtkWidget *widget)</a>
<a name="ln1130">{</a>
<a name="ln1131">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1132">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1133">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1134">  d-&gt;active = -1;</a>
<a name="ln1135">  g_list_free_full(d-&gt;entries, free_combobox_entry);</a>
<a name="ln1136">  d-&gt;entries = NULL;</a>
<a name="ln1137">  d-&gt;num_labels = 0;</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">const GList *dt_bauhaus_combobox_get_entries(GtkWidget *widget)</a>
<a name="ln1141">{</a>
<a name="ln1142">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1143">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return 0;</a>
<a name="ln1144">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1145">  return d-&gt;entries;</a>
<a name="ln1146">}</a>
<a name="ln1147"> </a>
<a name="ln1148">void dt_bauhaus_combobox_set_text(GtkWidget *widget, const char *text)</a>
<a name="ln1149">{</a>
<a name="ln1150">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1151">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1152">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1153">  if(!d-&gt;editable) return;</a>
<a name="ln1154">  g_strlcpy(d-&gt;text, text, sizeof(d-&gt;text));</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">void dt_bauhaus_combobox_set(GtkWidget *widget, int pos)</a>
<a name="ln1158">{</a>
<a name="ln1159">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1160">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1161">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1162">  d-&gt;active = CLAMP(pos, -1, d-&gt;num_labels - 1);</a>
<a name="ln1163">  gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln1164">  if(!darktable.gui-&gt;reset) g_signal_emit_by_name(G_OBJECT(w), &quot;value-changed&quot;);</a>
<a name="ln1165">}</a>
<a name="ln1166"> </a>
<a name="ln1167">gboolean dt_bauhaus_combobox_set_from_text(GtkWidget *widget, const char *text)</a>
<a name="ln1168">{</a>
<a name="ln1169">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1170">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln1171">  if(!text) return FALSE;</a>
<a name="ln1172">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1173">  int i = 0;</a>
<a name="ln1174">  for(GList *iter = d-&gt;entries; iter; iter = g_list_next(iter), i++)</a>
<a name="ln1175">  {</a>
<a name="ln1176">    const dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)iter-&gt;data;</a>
<a name="ln1177">    if(!g_strcmp0(entry-&gt;label, text))</a>
<a name="ln1178">    {</a>
<a name="ln1179">      dt_bauhaus_combobox_set(widget, i);</a>
<a name="ln1180">      return TRUE;</a>
<a name="ln1181">    }</a>
<a name="ln1182">  }</a>
<a name="ln1183">  return FALSE;</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186">int dt_bauhaus_combobox_get(GtkWidget *widget)</a>
<a name="ln1187">{</a>
<a name="ln1188">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1189">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return -1;</a>
<a name="ln1190">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1191">  return d-&gt;active;</a>
<a name="ln1192">}</a>
<a name="ln1193"> </a>
<a name="ln1194">void dt_bauhaus_combobox_entry_set_sensitive(GtkWidget *widget, int pos, gboolean sensitive)</a>
<a name="ln1195">{</a>
<a name="ln1196">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1197">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1198">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1199">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(d-&gt;entries, pos);</a>
<a name="ln1200">  if(entry)</a>
<a name="ln1201">    entry-&gt;sensitive = sensitive;</a>
<a name="ln1202">}</a>
<a name="ln1203"> </a>
<a name="ln1204">void dt_bauhaus_slider_clear_stops(GtkWidget *widget)</a>
<a name="ln1205">{</a>
<a name="ln1206">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1207">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1208">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1209">  d-&gt;grad_cnt = 0;</a>
<a name="ln1210">}</a>
<a name="ln1211"> </a>
<a name="ln1212">void dt_bauhaus_slider_set_stop(GtkWidget *widget, float stop, float r, float g, float b)</a>
<a name="ln1213">{</a>
<a name="ln1214">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1215">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1216">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1217">  float rawstop = d-&gt;callback(widget, stop, DT_BAUHAUS_SET);</a>
<a name="ln1218">  // need to replace stop?</a>
<a name="ln1219">  for(int k = 0; k &lt; d-&gt;grad_cnt; k++)</a>
<a name="ln1220">  {</a>
<a name="ln1221">    if(d-&gt;grad_pos[k] == rawstop)</a>
<a name="ln1222">    {</a>
<a name="ln1223">      d-&gt;grad_col[k][0] = r;</a>
<a name="ln1224">      d-&gt;grad_col[k][1] = g;</a>
<a name="ln1225">      d-&gt;grad_col[k][2] = b;</a>
<a name="ln1226">      return;</a>
<a name="ln1227">    }</a>
<a name="ln1228">  }</a>
<a name="ln1229">  // new stop:</a>
<a name="ln1230">  if(d-&gt;grad_cnt &lt; DT_BAUHAUS_SLIDER_MAX_STOPS)</a>
<a name="ln1231">  {</a>
<a name="ln1232">    int k = d-&gt;grad_cnt++;</a>
<a name="ln1233">    d-&gt;grad_pos[k] = rawstop;</a>
<a name="ln1234">    d-&gt;grad_col[k][0] = r;</a>
<a name="ln1235">    d-&gt;grad_col[k][1] = g;</a>
<a name="ln1236">    d-&gt;grad_col[k][2] = b;</a>
<a name="ln1237">  }</a>
<a name="ln1238">  else</a>
<a name="ln1239">  {</a>
<a name="ln1240">    fprintf(stderr, &quot;[bauhaus_slider_set_stop] only %d stops allowed.\n&quot;, DT_BAUHAUS_SLIDER_MAX_STOPS);</a>
<a name="ln1241">  }</a>
<a name="ln1242">}</a>
<a name="ln1243"> </a>
<a name="ln1244"> </a>
<a name="ln1245">static void draw_equilateral_triangle(cairo_t *cr, float radius)</a>
<a name="ln1246">{</a>
<a name="ln1247">  const float sin = 0.866025404 * radius;</a>
<a name="ln1248">  const float cos = 0.5f * radius;</a>
<a name="ln1249">  cairo_move_to(cr, 0.0, radius);</a>
<a name="ln1250">  cairo_line_to(cr, -sin, -cos);</a>
<a name="ln1251">  cairo_line_to(cr, sin, -cos);</a>
<a name="ln1252">  cairo_line_to(cr, 0.0, radius);</a>
<a name="ln1253">}</a>
<a name="ln1254"> </a>
<a name="ln1255"> </a>
<a name="ln1256">static void dt_bauhaus_draw_indicator(dt_bauhaus_widget_t *w, float pos, cairo_t *cr, const GdkRGBA *fg_color, const GdkRGBA *border_color)</a>
<a name="ln1257">{</a>
<a name="ln1258">  // draw scale indicator (the tiny triangle)</a>
<a name="ln1259">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1260">  GtkAllocation allocation;</a>
<a name="ln1261">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1262">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1263">  const float wd = allocation.width;</a>
<a name="ln1264">  const float border_width = darktable.bauhaus-&gt;border_width;</a>
<a name="ln1265">  const float size = darktable.bauhaus-&gt;marker_size;</a>
<a name="ln1266"> </a>
<a name="ln1267">  cairo_save(cr);</a>
<a name="ln1268">  cairo_translate(cr, slider_coordinate(pos, wd), get_line_height() + INNER_PADDING - border_width * 0.25f);</a>
<a name="ln1269">  cairo_scale(cr, 1.0f, -1.0f);</a>
<a name="ln1270">  cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln1271"> </a>
<a name="ln1272">  // draw the outer triangle</a>
<a name="ln1273">  draw_equilateral_triangle(cr, size);</a>
<a name="ln1274">  cairo_set_line_width(cr, border_width);</a>
<a name="ln1275">  set_color(cr, *border_color);</a>
<a name="ln1276">  cairo_stroke(cr);</a>
<a name="ln1277"> </a>
<a name="ln1278">  draw_equilateral_triangle(cr, size - border_width);</a>
<a name="ln1279">  cairo_clip(cr);</a>
<a name="ln1280"> </a>
<a name="ln1281">  // draw the inner triangle</a>
<a name="ln1282">  draw_equilateral_triangle(cr, size - border_width);</a>
<a name="ln1283">  set_color(cr, *fg_color);</a>
<a name="ln1284">  cairo_set_line_width(cr, border_width);</a>
<a name="ln1285"> </a>
<a name="ln1286">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1287"> </a>
<a name="ln1288">  if(d-&gt;fill_feedback)</a>
<a name="ln1289">    cairo_fill(cr); // Plain indicator (regular sliders)</a>
<a name="ln1290">  else</a>
<a name="ln1291">    cairo_stroke(cr);  // Hollow indicator to see a color through it (gradient sliders)</a>
<a name="ln1292"> </a>
<a name="ln1293">  cairo_restore(cr);</a>
<a name="ln1294">}</a>
<a name="ln1295"> </a>
<a name="ln1296">static void dt_bauhaus_draw_quad(dt_bauhaus_widget_t *w, cairo_t *cr)</a>
<a name="ln1297">{</a>
<a name="ln1298">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1299">  const gboolean sensitive = gtk_widget_is_sensitive(GTK_WIDGET(w));</a>
<a name="ln1300">  GtkAllocation allocation;</a>
<a name="ln1301">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1302">  const int width = allocation.width;</a>
<a name="ln1303">  const int height = inner_height(allocation);</a>
<a name="ln1304"> </a>
<a name="ln1305">  if(w-&gt;quad_paint)</a>
<a name="ln1306">  {</a>
<a name="ln1307">    cairo_save(cr);</a>
<a name="ln1308"> </a>
<a name="ln1309">    if(sensitive &amp;&amp; (w-&gt;quad_paint_flags &amp; CPF_ACTIVE))</a>
<a name="ln1310">      set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1311">    else</a>
<a name="ln1312">      set_color(cr, darktable.bauhaus-&gt;color_fg_insensitive);</a>
<a name="ln1313"> </a>
<a name="ln1314">    w-&gt;quad_paint(cr, width - darktable.bauhaus-&gt;quad_width,  // x</a>
<a name="ln1315">                      0.0,        // y</a>
<a name="ln1316">                      darktable.bauhaus-&gt;quad_width,          // width</a>
<a name="ln1317">                      darktable.bauhaus-&gt;quad_width,          // height</a>
<a name="ln1318">                      w-&gt;quad_paint_flags, w-&gt;quad_paint_data);</a>
<a name="ln1319"> </a>
<a name="ln1320">    cairo_restore(cr);</a>
<a name="ln1321">  }</a>
<a name="ln1322">  else</a>
<a name="ln1323">  {</a>
<a name="ln1324">    // draw active area square:</a>
<a name="ln1325">    cairo_save(cr);</a>
<a name="ln1326">    if(sensitive)</a>
<a name="ln1327">      set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1328">    else</a>
<a name="ln1329">      set_color(cr, darktable.bauhaus-&gt;color_fg_insensitive);</a>
<a name="ln1330">    switch(w-&gt;type)</a>
<a name="ln1331">    {</a>
<a name="ln1332">      case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1333">        cairo_translate(cr, width - darktable.bauhaus-&gt;quad_width * .5f, height * .33f);</a>
<a name="ln1334">        draw_equilateral_triangle(cr, darktable.bauhaus-&gt;quad_width * .25f);</a>
<a name="ln1335">        cairo_fill_preserve(cr);</a>
<a name="ln1336">        cairo_set_line_width(cr, 0.5);</a>
<a name="ln1337">        set_color(cr, darktable.bauhaus-&gt;color_border);</a>
<a name="ln1338">        cairo_stroke(cr);</a>
<a name="ln1339">        break;</a>
<a name="ln1340">      case DT_BAUHAUS_SLIDER:</a>
<a name="ln1341">        break;</a>
<a name="ln1342">      default:</a>
<a name="ln1343">        cairo_set_source_rgb(cr, 1.0, 0.0, 0.0);</a>
<a name="ln1344">        cairo_rectangle(cr, width - darktable.bauhaus-&gt;quad_width, 0.0, darktable.bauhaus-&gt;quad_width, darktable.bauhaus-&gt;quad_width);</a>
<a name="ln1345">        cairo_fill(cr);</a>
<a name="ln1346">        break;</a>
<a name="ln1347">    }</a>
<a name="ln1348">    cairo_restore(cr);</a>
<a name="ln1349">  }</a>
<a name="ln1350">}</a>
<a name="ln1351"> </a>
<a name="ln1352">static void dt_bauhaus_draw_baseline(dt_bauhaus_widget_t *w, cairo_t *cr)</a>
<a name="ln1353">{</a>
<a name="ln1354">  // draw line for orientation in slider</a>
<a name="ln1355">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1356">  GtkAllocation allocation;</a>
<a name="ln1357">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1358">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1359">  const int wd = allocation.width;</a>
<a name="ln1360">  const float slider_width = wd - darktable.bauhaus-&gt;quad_width - INNER_PADDING;</a>
<a name="ln1361">  cairo_save(cr);</a>
<a name="ln1362">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1363"> </a>
<a name="ln1364">  // pos of baseline</a>
<a name="ln1365">  const float htm = darktable.bauhaus-&gt;line_height + INNER_PADDING;</a>
<a name="ln1366"> </a>
<a name="ln1367">  // thickness of baseline</a>
<a name="ln1368">  const float htM = darktable.bauhaus-&gt;baseline_size - darktable.bauhaus-&gt;border_width;</a>
<a name="ln1369"> </a>
<a name="ln1370">  // the background of the line</a>
<a name="ln1371">  cairo_pattern_t *gradient = NULL;</a>
<a name="ln1372">  cairo_rectangle(cr, 0, htm, slider_width, htM);</a>
<a name="ln1373"> </a>
<a name="ln1374">  if(d-&gt;grad_cnt &gt; 0)</a>
<a name="ln1375">  {</a>
<a name="ln1376">    // gradient line as used in some modules</a>
<a name="ln1377">    gradient = cairo_pattern_create_linear(0, 0, slider_width, htM);</a>
<a name="ln1378">    for(int k = 0; k &lt; d-&gt;grad_cnt; k++)</a>
<a name="ln1379">      cairo_pattern_add_color_stop_rgba(gradient, d-&gt;grad_pos[k], d-&gt;grad_col[k][0], d-&gt;grad_col[k][1],</a>
<a name="ln1380">                                        d-&gt;grad_col[k][2], 0.4f);</a>
<a name="ln1381">    cairo_set_source(cr, gradient);</a>
<a name="ln1382">  }</a>
<a name="ln1383">  else</a>
<a name="ln1384">  {</a>
<a name="ln1385">    // regular baseline</a>
<a name="ln1386">    set_color(cr, darktable.bauhaus-&gt;color_bg);</a>
<a name="ln1387">  }</a>
<a name="ln1388"> </a>
<a name="ln1389">  cairo_fill(cr);</a>
<a name="ln1390"> </a>
<a name="ln1391">  // get the reference of the slider aka the position of the 0 value</a>
<a name="ln1392">  const float origin = fmaxf(fminf(-(d-&gt;min / (d-&gt;max - d-&gt;min)) * slider_width, slider_width), 0.0f);</a>
<a name="ln1393">  const float position = d-&gt;pos * slider_width;</a>
<a name="ln1394">  const float delta = position - origin;</a>
<a name="ln1395"> </a>
<a name="ln1396">  // have a `fill ratio feel' from zero to current position</a>
<a name="ln1397">  // - but only if set</a>
<a name="ln1398">  if(d-&gt;fill_feedback)</a>
<a name="ln1399">  {</a>
<a name="ln1400">    // only brighten, useful for colored sliders to not get too faint:</a>
<a name="ln1401">    cairo_set_operator(cr, CAIRO_OPERATOR_SCREEN);</a>
<a name="ln1402">    set_color(cr, darktable.bauhaus-&gt;color_fill);</a>
<a name="ln1403">    cairo_rectangle(cr, origin, htm, delta, htM);</a>
<a name="ln1404">    cairo_fill(cr);</a>
<a name="ln1405"> </a>
<a name="ln1406">    // change back to default cairo operator:</a>
<a name="ln1407">    cairo_set_operator(cr, CAIRO_OPERATOR_OVER);</a>
<a name="ln1408">  }</a>
<a name="ln1409"> </a>
<a name="ln1410">  // draw the 0 reference graduation if it's different than the bounds of the slider</a>
<a name="ln1411">  const float graduation_top = htm + htM + 2.0f * darktable.bauhaus-&gt;border_width;</a>
<a name="ln1412">  const float graduation_height = darktable.bauhaus-&gt;border_width / 2.0f;</a>
<a name="ln1413">  set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1414"> </a>
<a name="ln1415">  // If the max of the slider is 180 or 360, it is likely a hue slider in degrees</a>
<a name="ln1416">  // a zero in periodic stuff has not much meaning so we skip it</a>
<a name="ln1417">  if(d-&gt;hard_max != 180.0f &amp;&amp; d-&gt;hard_max != 360.0f)</a>
<a name="ln1418">  {</a>
<a name="ln1419">    // translate the dot if it overflows the widget frame</a>
<a name="ln1420">    if(origin &lt; graduation_height)</a>
<a name="ln1421">      cairo_arc(cr, graduation_height, graduation_top, graduation_height, 0, 2 * M_PI);</a>
<a name="ln1422">    else if(origin &gt; slider_width - graduation_height)</a>
<a name="ln1423">      cairo_arc(cr, slider_width - graduation_height, graduation_top, graduation_height, 0, 2 * M_PI);</a>
<a name="ln1424">    else</a>
<a name="ln1425">      cairo_arc(cr, origin, graduation_top, graduation_height, 0, 2 * M_PI);</a>
<a name="ln1426">}</a>
<a name="ln1427"> </a>
<a name="ln1428">  cairo_fill(cr);</a>
<a name="ln1429">  cairo_restore(cr);</a>
<a name="ln1430"> </a>
<a name="ln1431">  if(d-&gt;grad_cnt &gt; 0) cairo_pattern_destroy(gradient);</a>
<a name="ln1432">}</a>
<a name="ln1433"> </a>
<a name="ln1434">static void dt_bauhaus_widget_reject(dt_bauhaus_widget_t *w)</a>
<a name="ln1435">{</a>
<a name="ln1436">  switch(w-&gt;type)</a>
<a name="ln1437">  {</a>
<a name="ln1438">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1439">      break;</a>
<a name="ln1440">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1441">    {</a>
<a name="ln1442">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1443">      dt_bauhaus_slider_set_normalized(w, d-&gt;oldpos);</a>
<a name="ln1444">    }</a>
<a name="ln1445">    break;</a>
<a name="ln1446">    default:</a>
<a name="ln1447">      break;</a>
<a name="ln1448">  }</a>
<a name="ln1449">}</a>
<a name="ln1450"> </a>
<a name="ln1451">static void dt_bauhaus_widget_accept(dt_bauhaus_widget_t *w)</a>
<a name="ln1452">{</a>
<a name="ln1453">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1454">  GtkAllocation allocation;</a>
<a name="ln1455">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1456">  int base_width = allocation.width, base_height = inner_height(allocation);</a>
<a name="ln1457"> </a>
<a name="ln1458">  GtkAllocation allocation_popup_window;</a>
<a name="ln1459">  gtk_widget_get_allocation(darktable.bauhaus-&gt;popup_window, &amp;allocation_popup_window);</a>
<a name="ln1460"> </a>
<a name="ln1461">  int width = allocation_popup_window.width, height = inner_height(allocation_popup_window);</a>
<a name="ln1462"> </a>
<a name="ln1463">  switch(w-&gt;type)</a>
<a name="ln1464">  {</a>
<a name="ln1465">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1466">    {</a>
<a name="ln1467">      // only set to what's in the filtered list.</a>
<a name="ln1468">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1469">      int active = darktable.bauhaus-&gt;end_mouse_y &gt;= 0</a>
<a name="ln1470">                       ? (darktable.bauhaus-&gt;end_mouse_y / (base_height))</a>
<a name="ln1471">                       : d-&gt;active;</a>
<a name="ln1472">      int k = 0, i = 0, kk = 0, match = 1;</a>
<a name="ln1473"> </a>
<a name="ln1474">      gchar *keys = g_utf8_casefold(darktable.bauhaus-&gt;keys, -1);</a>
<a name="ln1475">      for(GList *it = d-&gt;entries; it; it = g_list_next(it))</a>
<a name="ln1476">      {</a>
<a name="ln1477">        const dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)it-&gt;data;</a>
<a name="ln1478">        gchar *text_cmp = g_utf8_casefold(entry-&gt;label, -1);</a>
<a name="ln1479">        if(!strncmp(text_cmp, keys, darktable.bauhaus-&gt;keys_cnt))</a>
<a name="ln1480">        {</a>
<a name="ln1481">          if(active == k)</a>
<a name="ln1482">          {</a>
<a name="ln1483">            if(entry-&gt;sensitive)</a>
<a name="ln1484">              dt_bauhaus_combobox_set(widget, i);</a>
<a name="ln1485">            g_free(keys);</a>
<a name="ln1486">            g_free(text_cmp);</a>
<a name="ln1487">            return;</a>
<a name="ln1488">          }</a>
<a name="ln1489">          kk = i; // remember for down there</a>
<a name="ln1490">          // editable should only snap to perfect matches, not prefixes:</a>
<a name="ln1491">          if(d-&gt;editable &amp;&amp; strcmp(entry-&gt;label, darktable.bauhaus-&gt;keys)) match = 0;</a>
<a name="ln1492">          k++;</a>
<a name="ln1493">        }</a>
<a name="ln1494">        i++;</a>
<a name="ln1495">        g_free(text_cmp);</a>
<a name="ln1496">      }</a>
<a name="ln1497">      // if list is short (2 entries could be: typed something similar, and one similar)</a>
<a name="ln1498">      if(k &lt; 3)</a>
<a name="ln1499">      {</a>
<a name="ln1500">        // didn't find it, but had only one matching choice?</a>
<a name="ln1501">        if(k == 1 &amp;&amp; match)</a>
<a name="ln1502">          dt_bauhaus_combobox_set(widget, kk);</a>
<a name="ln1503">        else if(d-&gt;editable)</a>
<a name="ln1504">        {</a>
<a name="ln1505">          // had no close match (k == 1 &amp;&amp; !match) or no match at all (k == 0)</a>
<a name="ln1506">          memset(d-&gt;text, 0, sizeof(d-&gt;text));</a>
<a name="ln1507">          g_strlcpy(d-&gt;text, darktable.bauhaus-&gt;keys, sizeof(d-&gt;text));</a>
<a name="ln1508">          // select custom entry</a>
<a name="ln1509">          dt_bauhaus_combobox_set(widget, -1);</a>
<a name="ln1510">        }</a>
<a name="ln1511">      }</a>
<a name="ln1512">      g_free(keys);</a>
<a name="ln1513">      break;</a>
<a name="ln1514">    }</a>
<a name="ln1515">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1516">    {</a>
<a name="ln1517">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1518">      const float mouse_off = get_slider_line_offset(</a>
<a name="ln1519">          d-&gt;oldpos, d-&gt;scale, darktable.bauhaus-&gt;end_mouse_x / width,</a>
<a name="ln1520">          darktable.bauhaus-&gt;end_mouse_y / height, base_height / (float)height, base_width);</a>
<a name="ln1521">      dt_bauhaus_slider_set_normalized(w, d-&gt;oldpos + mouse_off);</a>
<a name="ln1522">      d-&gt;oldpos = d-&gt;pos;</a>
<a name="ln1523">      break;</a>
<a name="ln1524">    }</a>
<a name="ln1525">    default:</a>
<a name="ln1526">      break;</a>
<a name="ln1527">  }</a>
<a name="ln1528">}</a>
<a name="ln1529"> </a>
<a name="ln1530">static gboolean dt_bauhaus_popup_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln1531">{</a>
<a name="ln1532">  dt_bauhaus_widget_t *w = darktable.bauhaus-&gt;current;</a>
<a name="ln1533"> </a>
<a name="ln1534">  // dimensions of the popup</a>
<a name="ln1535">  GtkAllocation allocation;</a>
<a name="ln1536">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1537">  int width = allocation.width, height = inner_height(allocation);</a>
<a name="ln1538"> </a>
<a name="ln1539">  // dimensions of the original line</a>
<a name="ln1540">  GtkWidget *current = GTK_WIDGET(w);</a>
<a name="ln1541">  GtkAllocation allocation_current;</a>
<a name="ln1542">  gtk_widget_get_allocation(current, &amp;allocation_current);</a>
<a name="ln1543">  int wd = allocation_current.width, ht = inner_height(allocation_current);</a>
<a name="ln1544"> </a>
<a name="ln1545">  // get area properties</a>
<a name="ln1546">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln1547">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln1548">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln1549"> </a>
<a name="ln1550">  // translate to account for the widget spacing</a>
<a name="ln1551">  cairo_translate(cr, 0, darktable.bauhaus-&gt;widget_space);</a>
<a name="ln1552"> </a>
<a name="ln1553">  // draw background</a>
<a name="ln1554">  gtk_render_background(context, cr, 0.0, 0.0, width, height);</a>
<a name="ln1555"> </a>
<a name="ln1556">  // look up some colors once</a>
<a name="ln1557">  GdkRGBA text_color, text_color_selected, text_color_hover, text_color_insensitive;</a>
<a name="ln1558">  gtk_style_context_get_color(context, GTK_STATE_FLAG_NORMAL, &amp;text_color);</a>
<a name="ln1559">  gtk_style_context_get_color(context, GTK_STATE_FLAG_SELECTED, &amp;text_color_selected);</a>
<a name="ln1560">  gtk_style_context_get_color(context, GTK_STATE_FLAG_PRELIGHT, &amp;text_color_hover);</a>
<a name="ln1561">  gtk_style_context_get_color(context, GTK_STATE_FLAG_INSENSITIVE, &amp;text_color_insensitive);</a>
<a name="ln1562"> </a>
<a name="ln1563">  GdkRGBA *fg_color = default_color_assign();</a>
<a name="ln1564">  GdkRGBA *bg_color = default_color_assign();</a>
<a name="ln1565">  GtkStateFlags state = gtk_widget_get_state_flags(widget);</a>
<a name="ln1566">  gtk_render_background(context, cr, 0, 0, width, height);</a>
<a name="ln1567"> </a>
<a name="ln1568">  gtk_style_context_get(context, state, &quot;background-color&quot;, bg_color, NULL);</a>
<a name="ln1569">  gtk_style_context_get_color(context, state, fg_color);</a>
<a name="ln1570"> </a>
<a name="ln1571">  // switch on bauhaus widget type (so we only need one static window)</a>
<a name="ln1572">  switch(w-&gt;type)</a>
<a name="ln1573">  {</a>
<a name="ln1574">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1575">    {</a>
<a name="ln1576">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1577"> </a>
<a name="ln1578">      dt_bauhaus_draw_baseline(w, cr);</a>
<a name="ln1579"> </a>
<a name="ln1580">      cairo_save(cr);</a>
<a name="ln1581">      cairo_set_line_width(cr, 0.5);</a>
<a name="ln1582">      const int num_scales = 1.f / d-&gt;scale;</a>
<a name="ln1583"> </a>
<a name="ln1584">      cairo_rectangle(cr, 0.0f, ht, width - INNER_PADDING, height);</a>
<a name="ln1585">      cairo_clip(cr);</a>
<a name="ln1586"> </a>
<a name="ln1587">      for(int k = 0; k &lt; num_scales; k++)</a>
<a name="ln1588">      {</a>
<a name="ln1589">        const float off = k * d-&gt;scale - d-&gt;oldpos;</a>
<a name="ln1590">        GdkRGBA fg_copy = *fg_color;</a>
<a name="ln1591">        fg_copy.alpha = d-&gt;scale / fabsf(off);</a>
<a name="ln1592">        set_color(cr, fg_copy);</a>
<a name="ln1593">        draw_slider_line(cr, d-&gt;oldpos, off, d-&gt;scale, width, height, ht);</a>
<a name="ln1594">        cairo_stroke(cr);</a>
<a name="ln1595">      }</a>
<a name="ln1596">      cairo_restore(cr);</a>
<a name="ln1597">      set_color(cr, *fg_color);</a>
<a name="ln1598">      show_pango_text(cr, w-&gt;label, 0, 0, 0, FALSE);</a>
<a name="ln1599"> </a>
<a name="ln1600">      // draw mouse over indicator line</a>
<a name="ln1601">      cairo_save(cr);</a>
<a name="ln1602">      cairo_set_line_width(cr, 2.);</a>
<a name="ln1603">      const float mouse_off</a>
<a name="ln1604">          = darktable.bauhaus-&gt;change_active</a>
<a name="ln1605">                ? get_slider_line_offset(d-&gt;oldpos, d-&gt;scale, darktable.bauhaus-&gt;mouse_x / width,</a>
<a name="ln1606">                                         darktable.bauhaus-&gt;mouse_y / height, ht / (float)height, width)</a>
<a name="ln1607">                : 0.0f;</a>
<a name="ln1608">      draw_slider_line(cr, d-&gt;oldpos, mouse_off, d-&gt;scale, width, height, ht);</a>
<a name="ln1609">      cairo_stroke(cr);</a>
<a name="ln1610">      cairo_restore(cr);</a>
<a name="ln1611"> </a>
<a name="ln1612">      // draw indicator</a>
<a name="ln1613">      dt_bauhaus_draw_indicator(w, d-&gt;oldpos + mouse_off, cr, fg_color, bg_color);</a>
<a name="ln1614"> </a>
<a name="ln1615">      // draw numerical value:</a>
<a name="ln1616">      cairo_save(cr);</a>
<a name="ln1617">      char text[256];</a>
<a name="ln1618">      const float f = d-&gt;min + (d-&gt;oldpos + mouse_off) * (d-&gt;max - d-&gt;min);</a>
<a name="ln1619">      const float fc = d-&gt;callback(widget, f, DT_BAUHAUS_GET);</a>
<a name="ln1620">      snprintf(text, sizeof(text), d-&gt;format, fc);</a>
<a name="ln1621">      set_color(cr, *fg_color);</a>
<a name="ln1622">      show_pango_text(cr, text, wd - darktable.bauhaus-&gt;quad_width - INNER_PADDING, 0, 0, TRUE);</a>
<a name="ln1623"> </a>
<a name="ln1624">      cairo_restore(cr);</a>
<a name="ln1625">    }</a>
<a name="ln1626">    break;</a>
<a name="ln1627">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1628">    {</a>
<a name="ln1629">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1630">      cairo_save(cr);</a>
<a name="ln1631">      float first_label_width = 0.0;</a>
<a name="ln1632">      gboolean first_label = TRUE;</a>
<a name="ln1633">      int k = 0, i = 0;</a>
<a name="ln1634">      int hovered = darktable.bauhaus-&gt;mouse_y / ht;</a>
<a name="ln1635">      gchar *keys = g_utf8_casefold(darktable.bauhaus-&gt;keys, -1);</a>
<a name="ln1636">      for(GList *it = d-&gt;entries; it; it = g_list_next(it))</a>
<a name="ln1637">      {</a>
<a name="ln1638">        const dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)it-&gt;data;</a>
<a name="ln1639">        gchar *text_cmp = g_utf8_casefold(entry-&gt;label, -1);</a>
<a name="ln1640">        if(!strncmp(text_cmp, keys, darktable.bauhaus-&gt;keys_cnt))</a>
<a name="ln1641">        {</a>
<a name="ln1642">          float max_width = wd - INNER_PADDING - darktable.bauhaus-&gt;quad_width;</a>
<a name="ln1643">          if(first_label) max_width *= 0.8; // give the label at least some room</a>
<a name="ln1644"> </a>
<a name="ln1645">          float label_width;</a>
<a name="ln1646">          if(!entry-&gt;sensitive)</a>
<a name="ln1647">            set_color(cr, text_color_insensitive);</a>
<a name="ln1648">          else if(i == hovered)</a>
<a name="ln1649">            set_color(cr, text_color_hover);</a>
<a name="ln1650">          else if(i == d-&gt;active)</a>
<a name="ln1651">            set_color(cr, text_color_selected);</a>
<a name="ln1652">          else</a>
<a name="ln1653">            set_color(cr, text_color);</a>
<a name="ln1654"> </a>
<a name="ln1655">          if(entry-&gt;alignment == DT_BAUHAUS_COMBOBOX_ALIGN_LEFT)</a>
<a name="ln1656">            label_width = show_pango_text(cr, entry-&gt;label, 0, ht * k, max_width, FALSE);</a>
<a name="ln1657">          else</a>
<a name="ln1658">            label_width = show_pango_text(cr, entry-&gt;label, wd - INNER_PADDING - darktable.bauhaus-&gt;quad_width, ht * k, max_width, TRUE);</a>
<a name="ln1659"> </a>
<a name="ln1660">          // prefer the entry over the label wrt. ellipsization when expanded</a>
<a name="ln1661">          if(first_label)</a>
<a name="ln1662">          {</a>
<a name="ln1663">            first_label_width = label_width;</a>
<a name="ln1664">            first_label = FALSE;</a>
<a name="ln1665">          }</a>
<a name="ln1666"> </a>
<a name="ln1667">          k++;</a>
<a name="ln1668">        }</a>
<a name="ln1669">        i++;</a>
<a name="ln1670">        g_free(text_cmp);</a>
<a name="ln1671">      }</a>
<a name="ln1672">      cairo_restore(cr);</a>
<a name="ln1673"> </a>
<a name="ln1674">      // left aligned box label. add it to the gui after the entries so we can ellipsize it if needed</a>
<a name="ln1675">      set_color(cr, text_color);</a>
<a name="ln1676">      show_pango_text(cr, w-&gt;label, 0, 0, wd - INNER_PADDING - darktable.bauhaus-&gt;quad_width - first_label_width, FALSE);</a>
<a name="ln1677"> </a>
<a name="ln1678">      g_free(keys);</a>
<a name="ln1679">    }</a>
<a name="ln1680">    break;</a>
<a name="ln1681">    default:</a>
<a name="ln1682">      // yell</a>
<a name="ln1683">      break;</a>
<a name="ln1684">  }</a>
<a name="ln1685"> </a>
<a name="ln1686">  // draw currently typed text. if a type doesn't want this, it should not</a>
<a name="ln1687">  // allow stuff to be written here in the key callback.</a>
<a name="ln1688">  if(darktable.bauhaus-&gt;keys_cnt)</a>
<a name="ln1689">  {</a>
<a name="ln1690">    cairo_save(cr);</a>
<a name="ln1691">    PangoLayout *layout;</a>
<a name="ln1692">    PangoRectangle ink;</a>
<a name="ln1693">    layout = pango_cairo_create_layout(cr);</a>
<a name="ln1694">    pango_cairo_context_set_resolution(pango_layout_get_context(layout), darktable.gui-&gt;dpi);</a>
<a name="ln1695">    set_color(cr, text_color);</a>
<a name="ln1696"> </a>
<a name="ln1697">    // make extra large, but without dependency on popup window height</a>
<a name="ln1698">    // (that might differ for comboboxes for example). only fall back</a>
<a name="ln1699">    // to height dependency if the popup is really small.</a>
<a name="ln1700">    const int line_height = get_line_height();</a>
<a name="ln1701">    const int size = MIN(3 * line_height, .2 * height);</a>
<a name="ln1702">    PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln1703">    pango_font_description_set_absolute_size(desc, size * PANGO_SCALE);</a>
<a name="ln1704">    pango_layout_set_font_description(layout, desc);</a>
<a name="ln1705"> </a>
<a name="ln1706">    pango_layout_set_text(layout, darktable.bauhaus-&gt;keys, -1);</a>
<a name="ln1707">    pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln1708">    cairo_move_to(cr, wd - INNER_PADDING - darktable.bauhaus-&gt;quad_width - ink.width, height * 0.5 - size);</a>
<a name="ln1709">    pango_cairo_show_layout(cr, layout);</a>
<a name="ln1710">    cairo_restore(cr);</a>
<a name="ln1711">    pango_font_description_free(desc);</a>
<a name="ln1712">    g_object_unref(layout);</a>
<a name="ln1713">  }</a>
<a name="ln1714">  if(darktable.bauhaus-&gt;cursor_visible)</a>
<a name="ln1715">  {</a>
<a name="ln1716">    // show the blinking cursor</a>
<a name="ln1717">    cairo_save(cr);</a>
<a name="ln1718">    set_color(cr, text_color);</a>
<a name="ln1719">    const int line_height = get_line_height();</a>
<a name="ln1720">    cairo_move_to(cr, wd - darktable.bauhaus-&gt;quad_width + 3, height * 0.5 + line_height);</a>
<a name="ln1721">    cairo_line_to(cr, wd - darktable.bauhaus-&gt;quad_width + 3, height * 0.5 - 3 * line_height);</a>
<a name="ln1722">    cairo_set_line_width(cr, 2.);</a>
<a name="ln1723">    cairo_stroke(cr);</a>
<a name="ln1724">    cairo_restore(cr);</a>
<a name="ln1725">  }</a>
<a name="ln1726"> </a>
<a name="ln1727">  cairo_destroy(cr);</a>
<a name="ln1728">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln1729">  cairo_paint(crf);</a>
<a name="ln1730">  cairo_surface_destroy(cst);</a>
<a name="ln1731"> </a>
<a name="ln1732">  gdk_rgba_free(bg_color);</a>
<a name="ln1733">  gdk_rgba_free(fg_color);</a>
<a name="ln1734"> </a>
<a name="ln1735">  return TRUE;</a>
<a name="ln1736">}</a>
<a name="ln1737"> </a>
<a name="ln1738">static gboolean dt_bauhaus_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln1739">{</a>
<a name="ln1740">  GtkAllocation allocation;</a>
<a name="ln1741">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1742">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1743">  const int width = allocation.width, height = allocation.height;</a>
<a name="ln1744">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln1745">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln1746">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln1747"> </a>
<a name="ln1748">  // translate to account for the widget spacing</a>
<a name="ln1749">  cairo_translate(cr, 0, darktable.bauhaus-&gt;widget_space);</a>
<a name="ln1750"> </a>
<a name="ln1751">  GdkRGBA *fg_color = default_color_assign();</a>
<a name="ln1752">  GdkRGBA *text_color = default_color_assign();</a>
<a name="ln1753">  GtkStateFlags state = gtk_widget_get_state_flags(widget);</a>
<a name="ln1754">  gtk_style_context_get_color(context, state, text_color);</a>
<a name="ln1755">  gtk_render_background(context, cr, 0, 0, width, height + INNER_PADDING);</a>
<a name="ln1756">  gtk_style_context_get_color(context, state, fg_color);</a>
<a name="ln1757"> </a>
<a name="ln1758">  // draw type specific content:</a>
<a name="ln1759">  cairo_save(cr);</a>
<a name="ln1760">  cairo_set_line_width(cr, 1.0);</a>
<a name="ln1761">  switch(w-&gt;type)</a>
<a name="ln1762">  {</a>
<a name="ln1763">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1764">    {</a>
<a name="ln1765">      // draw label and quad area at right end</a>
<a name="ln1766">      set_color(cr, *text_color);</a>
<a name="ln1767">      float label_width</a>
<a name="ln1768">          = show_pango_text(cr, w-&gt;label, 0, 0, 0, FALSE);</a>
<a name="ln1769">      dt_bauhaus_draw_quad(w, cr);</a>
<a name="ln1770"> </a>
<a name="ln1771">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1772">      gchar *text = d-&gt;text;</a>
<a name="ln1773">      if(d-&gt;active &gt;= 0)</a>
<a name="ln1774">      {</a>
<a name="ln1775">        const dt_bauhaus_combobox_entry_t *entry = g_list_nth_data(d-&gt;entries, d-&gt;active);</a>
<a name="ln1776">        text = entry-&gt;label;</a>
<a name="ln1777">      }</a>
<a name="ln1778">      set_color(cr, *text_color);</a>
<a name="ln1779">      show_pango_text(cr, text, width - darktable.bauhaus-&gt;quad_width - INNER_PADDING, 0, width - darktable.bauhaus-&gt;quad_width - label_width, TRUE);</a>
<a name="ln1780">      break;</a>
<a name="ln1781">    }</a>
<a name="ln1782">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1783">    {</a>
<a name="ln1784">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1785"> </a>
<a name="ln1786">      // line for orientation</a>
<a name="ln1787">      dt_bauhaus_draw_baseline(w, cr);</a>
<a name="ln1788">      dt_bauhaus_draw_quad(w, cr);</a>
<a name="ln1789"> </a>
<a name="ln1790">      if(gtk_widget_is_sensitive(widget))</a>
<a name="ln1791">      {</a>
<a name="ln1792">        cairo_save(cr);</a>
<a name="ln1793">        cairo_rectangle(cr, 0, 0, width - darktable.bauhaus-&gt;quad_width - INNER_PADDING, height + INNER_PADDING);</a>
<a name="ln1794">        cairo_clip(cr);</a>
<a name="ln1795">        dt_bauhaus_draw_indicator(w, d-&gt;pos, cr, fg_color, &amp;darktable.bauhaus-&gt;indicator_border);</a>
<a name="ln1796">        cairo_restore(cr);</a>
<a name="ln1797"> </a>
<a name="ln1798">        // TODO: merge that text with combo</a>
<a name="ln1799">        char text[256];</a>
<a name="ln1800">        const float f = d-&gt;min + d-&gt;pos * (d-&gt;max - d-&gt;min);</a>
<a name="ln1801">        const float fc = d-&gt;callback(widget, f, DT_BAUHAUS_GET);</a>
<a name="ln1802">        snprintf(text, sizeof(text), d-&gt;format, fc);</a>
<a name="ln1803">        set_color(cr, *text_color);</a>
<a name="ln1804">        show_pango_text(cr, text, width - darktable.bauhaus-&gt;quad_width - INNER_PADDING, 0, 0, TRUE);</a>
<a name="ln1805">      }</a>
<a name="ln1806">      // label on top of marker:</a>
<a name="ln1807">      set_color(cr, *text_color);</a>
<a name="ln1808">      show_pango_text(cr, w-&gt;label, 0, 0, 0, FALSE);</a>
<a name="ln1809">    }</a>
<a name="ln1810">    break;</a>
<a name="ln1811">    default:</a>
<a name="ln1812">      break;</a>
<a name="ln1813">  }</a>
<a name="ln1814">  cairo_restore(cr);</a>
<a name="ln1815">  cairo_destroy(cr);</a>
<a name="ln1816">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln1817">  cairo_paint(crf);</a>
<a name="ln1818">  cairo_surface_destroy(cst);</a>
<a name="ln1819"> </a>
<a name="ln1820">  gdk_rgba_free(text_color);</a>
<a name="ln1821">  gdk_rgba_free(fg_color);</a>
<a name="ln1822"> </a>
<a name="ln1823">  return TRUE;</a>
<a name="ln1824">}</a>
<a name="ln1825"> </a>
<a name="ln1826">void dt_bauhaus_hide_popup()</a>
<a name="ln1827">{</a>
<a name="ln1828">  if(darktable.bauhaus-&gt;current)</a>
<a name="ln1829">  {</a>
<a name="ln1830">    gtk_grab_remove(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1831">    gtk_widget_hide(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1832">    darktable.bauhaus-&gt;current = NULL;</a>
<a name="ln1833">    // TODO: give focus to center view? do in accept() as well?</a>
<a name="ln1834">  }</a>
<a name="ln1835">  _stop_cursor();</a>
<a name="ln1836">}</a>
<a name="ln1837"> </a>
<a name="ln1838">void dt_bauhaus_show_popup(dt_bauhaus_widget_t *w)</a>
<a name="ln1839">{</a>
<a name="ln1840">  if(darktable.bauhaus-&gt;current) dt_bauhaus_hide_popup();</a>
<a name="ln1841">  darktable.bauhaus-&gt;current = w;</a>
<a name="ln1842">  darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln1843">  memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln1844">  darktable.bauhaus-&gt;change_active = 0;</a>
<a name="ln1845">  darktable.bauhaus-&gt;mouse_line_distance = 0.0f;</a>
<a name="ln1846">  _stop_cursor();</a>
<a name="ln1847"> </a>
<a name="ln1848">  if(w-&gt;module)</a>
<a name="ln1849">  {</a>
<a name="ln1850">    dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1851">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln1852">  }</a>
<a name="ln1853"> </a>
<a name="ln1854">  int offset = 0;</a>
<a name="ln1855">  GtkAllocation tmp;</a>
<a name="ln1856">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln1857"> </a>
<a name="ln1858">  gtk_widget_realize(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1859">  switch(darktable.bauhaus-&gt;current-&gt;type)</a>
<a name="ln1860">  {</a>
<a name="ln1861">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1862">    {</a>
<a name="ln1863">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1864">      d-&gt;oldpos = d-&gt;pos;</a>
<a name="ln1865">      tmp.height = tmp.width;</a>
<a name="ln1866">      _start_cursor(6);</a>
<a name="ln1867">      break;</a>
<a name="ln1868">    }</a>
<a name="ln1869">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1870">    {</a>
<a name="ln1871">      // we launch the dynamic populate fct if any</a>
<a name="ln1872">      if(w-&gt;combo_populate) w-&gt;combo_populate(GTK_WIDGET(w), &amp;w-&gt;module);</a>
<a name="ln1873">      // comboboxes change immediately</a>
<a name="ln1874">      darktable.bauhaus-&gt;change_active = 1;</a>
<a name="ln1875">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1876">      tmp.height = tmp.height * d-&gt;num_labels;</a>
<a name="ln1877">      GtkAllocation allocation_w;</a>
<a name="ln1878">      gtk_widget_get_allocation(GTK_WIDGET(w), &amp;allocation_w);</a>
<a name="ln1879">      const int ht = allocation_w.height;</a>
<a name="ln1880">      const int skip = ht + get_line_height();</a>
<a name="ln1881">      offset = -d-&gt;active * get_line_height();</a>
<a name="ln1882">      darktable.bauhaus-&gt;mouse_x = 0;</a>
<a name="ln1883">      darktable.bauhaus-&gt;mouse_y = d-&gt;active * skip + ht / 2;</a>
<a name="ln1884">      break;</a>
<a name="ln1885">    }</a>
<a name="ln1886">    default:</a>
<a name="ln1887">      break;</a>
<a name="ln1888">  }</a>
<a name="ln1889"> </a>
<a name="ln1890">  gint wx, wy;</a>
<a name="ln1891">  gdk_window_get_origin(gtk_widget_get_window(GTK_WIDGET(w)), &amp;wx, &amp;wy);</a>
<a name="ln1892"> </a>
<a name="ln1893">  // move popup so mouse is over currently active item, to minimize confusion with scroll wheel:</a>
<a name="ln1894">  if(darktable.bauhaus-&gt;current-&gt;type == DT_BAUHAUS_COMBOBOX) wy += offset;</a>
<a name="ln1895"> </a>
<a name="ln1896">  // gtk_widget_get_window will return null if not shown yet.</a>
<a name="ln1897">  // it is needed for gdk_window_move, and gtk_window move will</a>
<a name="ln1898">  // sometimes be ignored. this is why we always call both...</a>
<a name="ln1899">  // we also don't want to show before move, as this results in noticeable flickering.</a>
<a name="ln1900">  GdkWindow *window = gtk_widget_get_window(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1901">  if(window) gdk_window_move(window, wx, wy);</a>
<a name="ln1902">  gtk_window_move(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), wx, wy);</a>
<a name="ln1903">  gtk_widget_set_size_request(darktable.bauhaus-&gt;popup_area, tmp.width, tmp.height);</a>
<a name="ln1904">  gtk_widget_set_size_request(darktable.bauhaus-&gt;popup_window, tmp.width, tmp.height);</a>
<a name="ln1905">  gtk_widget_show_all(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1906">  gtk_widget_grab_focus(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln1907">}</a>
<a name="ln1908"> </a>
<a name="ln1909">static gboolean dt_bauhaus_slider_add_delta_internal(GtkWidget *widget, float delta, guint state)</a>
<a name="ln1910">{</a>
<a name="ln1911">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1912">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1913"> </a>
<a name="ln1914">  float multiplier;</a>
<a name="ln1915"> </a>
<a name="ln1916">  GdkModifierType modifiers = gtk_accelerator_get_default_mod_mask();</a>
<a name="ln1917">  if((state &amp; modifiers) == GDK_SHIFT_MASK)</a>
<a name="ln1918">  {</a>
<a name="ln1919">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_rough_step_multiplier&quot;);</a>
<a name="ln1920">  }</a>
<a name="ln1921">  else if((state &amp; modifiers) == GDK_CONTROL_MASK)</a>
<a name="ln1922">  {</a>
<a name="ln1923">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_precise_step_multiplier&quot;);</a>
<a name="ln1924">  }</a>
<a name="ln1925">  else</a>
<a name="ln1926">  {</a>
<a name="ln1927">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_step_multiplier&quot;);</a>
<a name="ln1928">  }</a>
<a name="ln1929"> </a>
<a name="ln1930">  delta *= multiplier;</a>
<a name="ln1931"> </a>
<a name="ln1932">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1933"> </a>
<a name="ln1934">  dt_bauhaus_slider_set_normalized(w, d-&gt;pos + delta);</a>
<a name="ln1935"> </a>
<a name="ln1936">  return TRUE;</a>
<a name="ln1937">}</a>
<a name="ln1938"> </a>
<a name="ln1939">static gboolean dt_bauhaus_slider_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln1940">{</a>
<a name="ln1941">  gdouble delta_y;</a>
<a name="ln1942">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1943">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return FALSE;</a>
<a name="ln1944">  if(((event-&gt;state &amp; gtk_accelerator_get_default_mod_mask()) == darktable.gui-&gt;sidebar_scroll_mask) != dt_conf_get_bool(&quot;darkroom/ui/sidebar_scroll_default&quot;)) return FALSE;</a>
<a name="ln1945">  gtk_widget_grab_focus(widget);</a>
<a name="ln1946"> </a>
<a name="ln1947">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln1948"> </a>
<a name="ln1949">  if(dt_gui_get_scroll_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln1950">  {</a>
<a name="ln1951">    delta_y *= -w-&gt;data.slider.scale / 5.0;</a>
<a name="ln1952">    return dt_bauhaus_slider_add_delta_internal(widget, delta_y, event-&gt;state);</a>
<a name="ln1953">  }</a>
<a name="ln1954"> </a>
<a name="ln1955">  return FALSE;</a>
<a name="ln1956">}</a>
<a name="ln1957"> </a>
<a name="ln1958">static gboolean dt_bauhaus_slider_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data)</a>
<a name="ln1959">{</a>
<a name="ln1960">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1961">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return FALSE;</a>
<a name="ln1962">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1963"> </a>
<a name="ln1964">  int handled = 0;</a>
<a name="ln1965">  float delta = 0.0f;</a>
<a name="ln1966">  if(event-&gt;keyval == GDK_KEY_Up || event-&gt;keyval == GDK_KEY_KP_Up || event-&gt;keyval == GDK_KEY_Right</a>
<a name="ln1967">     || event-&gt;keyval == GDK_KEY_KP_Right)</a>
<a name="ln1968">  {</a>
<a name="ln1969">    handled = 1;</a>
<a name="ln1970">    delta = d-&gt;scale / 5.0f;</a>
<a name="ln1971">  }</a>
<a name="ln1972">  else if(event-&gt;keyval == GDK_KEY_Down || event-&gt;keyval == GDK_KEY_KP_Down || event-&gt;keyval == GDK_KEY_Left</a>
<a name="ln1973">          || event-&gt;keyval == GDK_KEY_KP_Left)</a>
<a name="ln1974">  {</a>
<a name="ln1975">    handled = 1;</a>
<a name="ln1976">    delta = -d-&gt;scale / 5.0f;</a>
<a name="ln1977">  }</a>
<a name="ln1978"> </a>
<a name="ln1979">  if(!handled) return FALSE;</a>
<a name="ln1980"> </a>
<a name="ln1981">  return dt_bauhaus_slider_add_delta_internal(widget, delta, event-&gt;state);</a>
<a name="ln1982">}</a>
<a name="ln1983"> </a>
<a name="ln1984"> </a>
<a name="ln1985">static gboolean dt_bauhaus_combobox_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln1986">{</a>
<a name="ln1987">  int delta_y;</a>
<a name="ln1988">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1989">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln1990">  if(((event-&gt;state &amp; gtk_accelerator_get_default_mod_mask()) == darktable.gui-&gt;sidebar_scroll_mask) != dt_conf_get_bool(&quot;darkroom/ui/sidebar_scroll_default&quot;)) return FALSE;</a>
<a name="ln1991">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1992">  gtk_widget_grab_focus(widget);</a>
<a name="ln1993"> </a>
<a name="ln1994">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln1995"> </a>
<a name="ln1996">  if(dt_gui_get_scroll_unit_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln1997">  {</a>
<a name="ln1998">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1999">    // go to next sensitive one</a>
<a name="ln2000">    int new_pos = CLAMP(d-&gt;active + delta_y, 0, d-&gt;num_labels - 1);</a>
<a name="ln2001">    if(_combobox_next_entry(d-&gt;entries, &amp;new_pos, delta_y))</a>
<a name="ln2002">      dt_bauhaus_combobox_set(widget, new_pos);</a>
<a name="ln2003">    return TRUE;</a>
<a name="ln2004">  }</a>
<a name="ln2005"> </a>
<a name="ln2006">  return FALSE;</a>
<a name="ln2007">}</a>
<a name="ln2008"> </a>
<a name="ln2009">static gboolean dt_bauhaus_combobox_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data)</a>
<a name="ln2010">{</a>
<a name="ln2011">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2012">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln2013">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln2014">  if(event-&gt;keyval == GDK_KEY_Up || event-&gt;keyval == GDK_KEY_KP_Up || event-&gt;keyval == GDK_KEY_Left</a>
<a name="ln2015">     || event-&gt;keyval == GDK_KEY_KP_Left)</a>
<a name="ln2016">  {</a>
<a name="ln2017">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2018">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2019">    // skip insensitive ones</a>
<a name="ln2020">    int new_pos = CLAMP(d-&gt;active - 1, 0, d-&gt;num_labels - 1);</a>
<a name="ln2021">    if(_combobox_next_entry(d-&gt;entries, &amp;new_pos, -1))</a>
<a name="ln2022">      dt_bauhaus_combobox_set(widget, new_pos);</a>
<a name="ln2023">    return TRUE;</a>
<a name="ln2024">  }</a>
<a name="ln2025">  else if(event-&gt;keyval == GDK_KEY_Down || event-&gt;keyval == GDK_KEY_KP_Down || event-&gt;keyval == GDK_KEY_Right</a>
<a name="ln2026">          || event-&gt;keyval == GDK_KEY_KP_Right)</a>
<a name="ln2027">  {</a>
<a name="ln2028">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2029">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2030">    // skip insensitive ones</a>
<a name="ln2031">    int new_pos = CLAMP(d-&gt;active + 1, 0, d-&gt;num_labels - 1);</a>
<a name="ln2032">    if(_combobox_next_entry(d-&gt;entries, &amp;new_pos, 1))</a>
<a name="ln2033">      dt_bauhaus_combobox_set(widget, new_pos);</a>
<a name="ln2034">    return TRUE;</a>
<a name="ln2035">  }</a>
<a name="ln2036">  return FALSE;</a>
<a name="ln2037">}</a>
<a name="ln2038"> </a>
<a name="ln2039">static gboolean dt_bauhaus_combobox_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2040">{</a>
<a name="ln2041">  GtkAllocation allocation;</a>
<a name="ln2042">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln2043">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2044"> </a>
<a name="ln2045">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln2046">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2047">  gtk_widget_grab_focus(GTK_WIDGET(w));</a>
<a name="ln2048">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2049"> </a>
<a name="ln2050">  GtkAllocation tmp;</a>
<a name="ln2051">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2052">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln2053">  if(w-&gt;quad_paint &amp;&amp; (event-&gt;x &gt; allocation.width - darktable.bauhaus-&gt;quad_width))</a>
<a name="ln2054">  {</a>
<a name="ln2055">    if (w-&gt;quad_toggle)</a>
<a name="ln2056">    {</a>
<a name="ln2057">      if (w-&gt;quad_paint_flags &amp; CPF_ACTIVE)</a>
<a name="ln2058">        w-&gt;quad_paint_flags &amp;= ~CPF_ACTIVE;</a>
<a name="ln2059">      else</a>
<a name="ln2060">        w-&gt;quad_paint_flags |= CPF_ACTIVE;</a>
<a name="ln2061">    }</a>
<a name="ln2062">    g_signal_emit_by_name(G_OBJECT(w), &quot;quad-pressed&quot;);</a>
<a name="ln2063">    return TRUE;</a>
<a name="ln2064">  }</a>
<a name="ln2065">  else if(event-&gt;button == 3)</a>
<a name="ln2066">  {</a>
<a name="ln2067">    darktable.bauhaus-&gt;mouse_x = event-&gt;x;</a>
<a name="ln2068">    darktable.bauhaus-&gt;mouse_y = event-&gt;y;</a>
<a name="ln2069">    dt_bauhaus_show_popup(w);</a>
<a name="ln2070">    return TRUE;</a>
<a name="ln2071">  }</a>
<a name="ln2072">  else if(event-&gt;button == 1)</a>
<a name="ln2073">  {</a>
<a name="ln2074">    // reset to default.</a>
<a name="ln2075">    if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln2076">    {</a>
<a name="ln2077">      // never called, as we popup the other window under your cursor before.</a>
<a name="ln2078">      // (except in weird corner cases where the popup is under the -1st entry</a>
<a name="ln2079">      dt_bauhaus_combobox_set(widget, d-&gt;defpos);</a>
<a name="ln2080">      dt_bauhaus_hide_popup();</a>
<a name="ln2081">    }</a>
<a name="ln2082">    else</a>
<a name="ln2083">    {</a>
<a name="ln2084">      // single click, show options</a>
<a name="ln2085">      darktable.bauhaus-&gt;opentime = dt_get_wtime();</a>
<a name="ln2086">      darktable.bauhaus-&gt;mouse_x = event-&gt;x;</a>
<a name="ln2087">      darktable.bauhaus-&gt;mouse_y = event-&gt;y;</a>
<a name="ln2088">      dt_bauhaus_show_popup(w);</a>
<a name="ln2089">    }</a>
<a name="ln2090">    return TRUE;</a>
<a name="ln2091">  }</a>
<a name="ln2092">  return FALSE;</a>
<a name="ln2093">}</a>
<a name="ln2094"> </a>
<a name="ln2095">float dt_bauhaus_slider_get(GtkWidget *widget)</a>
<a name="ln2096">{</a>
<a name="ln2097">  // first cast to bh widget, to check that type:</a>
<a name="ln2098">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2099">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return -1.0f;</a>
<a name="ln2100">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2101">  if(d-&gt;max == d-&gt;min) {</a>
<a name="ln2102">    return d-&gt;max;</a>
<a name="ln2103">  }</a>
<a name="ln2104">  float rawval = d-&gt;min + d-&gt;pos * (d-&gt;max - d-&gt;min);</a>
<a name="ln2105">  return d-&gt;callback(widget, rawval, DT_BAUHAUS_GET);</a>
<a name="ln2106">}</a>
<a name="ln2107"> </a>
<a name="ln2108">void dt_bauhaus_slider_set(GtkWidget *widget, float pos)</a>
<a name="ln2109">{</a>
<a name="ln2110">  // this is the public interface function, translate by bounds and call set_normalized</a>
<a name="ln2111">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2112">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2113">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2114">  float rawval = d-&gt;callback(widget, pos, DT_BAUHAUS_SET);</a>
<a name="ln2115">  dt_bauhaus_slider_set_normalized(w, (rawval - d-&gt;min) / (d-&gt;max - d-&gt;min));</a>
<a name="ln2116">}</a>
<a name="ln2117"> </a>
<a name="ln2118">void dt_bauhaus_slider_set_digits(GtkWidget *widget, int val)</a>
<a name="ln2119">{</a>
<a name="ln2120">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2121"> </a>
<a name="ln2122">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2123"> </a>
<a name="ln2124">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2125"> </a>
<a name="ln2126">  d-&gt;digits = val;</a>
<a name="ln2127">  snprintf(d-&gt;format, sizeof(d-&gt;format), &quot;%%.0%df&quot;, val);</a>
<a name="ln2128">}</a>
<a name="ln2129"> </a>
<a name="ln2130">int dt_bauhaus_slider_get_digits(GtkWidget *widget)</a>
<a name="ln2131">{</a>
<a name="ln2132">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2133"> </a>
<a name="ln2134">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return 0;</a>
<a name="ln2135"> </a>
<a name="ln2136">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2137"> </a>
<a name="ln2138">  return d-&gt;digits;</a>
<a name="ln2139">}</a>
<a name="ln2140"> </a>
<a name="ln2141">void dt_bauhaus_slider_set_step(GtkWidget *widget, float val)</a>
<a name="ln2142">{</a>
<a name="ln2143">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2144"> </a>
<a name="ln2145">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2146"> </a>
<a name="ln2147">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2148"> </a>
<a name="ln2149">  d-&gt;step = val;</a>
<a name="ln2150">  d-&gt;scale = 5.0f * d-&gt;step / (d-&gt;max - d-&gt;min);</a>
<a name="ln2151">}</a>
<a name="ln2152"> </a>
<a name="ln2153">float dt_bauhaus_slider_get_step(GtkWidget *widget)</a>
<a name="ln2154">{</a>
<a name="ln2155">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2156"> </a>
<a name="ln2157">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return 0;</a>
<a name="ln2158"> </a>
<a name="ln2159">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2160"> </a>
<a name="ln2161">  return d-&gt;step;</a>
<a name="ln2162">}</a>
<a name="ln2163"> </a>
<a name="ln2164">void dt_bauhaus_slider_reset(GtkWidget *widget)</a>
<a name="ln2165">{</a>
<a name="ln2166">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2167"> </a>
<a name="ln2168">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2169">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2170"> </a>
<a name="ln2171">  d-&gt;min = d-&gt;soft_min;</a>
<a name="ln2172">  d-&gt;max = d-&gt;soft_max;</a>
<a name="ln2173">  dt_bauhaus_slider_set_normalized(w, d-&gt;defpos);</a>
<a name="ln2174"> </a>
<a name="ln2175">  return;</a>
<a name="ln2176">}</a>
<a name="ln2177"> </a>
<a name="ln2178">void dt_bauhaus_slider_set_format(GtkWidget *widget, const char *format)</a>
<a name="ln2179">{</a>
<a name="ln2180">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2181">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2182">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2183">  g_strlcpy(d-&gt;format, format, sizeof(d-&gt;format));</a>
<a name="ln2184">}</a>
<a name="ln2185"> </a>
<a name="ln2186">void dt_bauhaus_slider_set_callback(GtkWidget *widget, float (*callback)(GtkWidget *self, float value, dt_bauhaus_callback_t dir))</a>
<a name="ln2187">{</a>
<a name="ln2188">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2189">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2190">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2191">  d-&gt;callback = (callback == NULL ? _default_linear_callback : callback);</a>
<a name="ln2192">}</a>
<a name="ln2193"> </a>
<a name="ln2194">void dt_bauhaus_slider_set_soft(GtkWidget *widget, float pos)</a>
<a name="ln2195">{</a>
<a name="ln2196">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2197">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2198">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2199">  float rawval = d-&gt;callback(widget, pos, DT_BAUHAUS_SET);</a>
<a name="ln2200">  float rpos = CLAMP(rawval, d-&gt;hard_min, d-&gt;hard_max);</a>
<a name="ln2201">  d-&gt;min = MIN(d-&gt;min, rpos);</a>
<a name="ln2202">  d-&gt;max = MAX(d-&gt;max, rpos);</a>
<a name="ln2203">  d-&gt;scale = 5.0f * d-&gt;step / (d-&gt;max - d-&gt;min);</a>
<a name="ln2204">  rpos = (rpos - d-&gt;min) / (d-&gt;max - d-&gt;min);</a>
<a name="ln2205">  dt_bauhaus_slider_set_normalized(w, rpos);</a>
<a name="ln2206">}</a>
<a name="ln2207"> </a>
<a name="ln2208">static void dt_bauhaus_slider_set_normalized(dt_bauhaus_widget_t *w, float pos)</a>
<a name="ln2209">{</a>
<a name="ln2210">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2211">  float rpos = CLAMP(pos, 0.0f, 1.0f);</a>
<a name="ln2212">  rpos = d-&gt;min + (d-&gt;max - d-&gt;min) * rpos;</a>
<a name="ln2213">  const float base = powf(10.0f, d-&gt;digits);</a>
<a name="ln2214">  rpos = roundf(base * rpos) / base;</a>
<a name="ln2215">  d-&gt;pos = (rpos - d-&gt;min) / (d-&gt;max - d-&gt;min);</a>
<a name="ln2216">  gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln2217">  d-&gt;is_changed = 1;</a>
<a name="ln2218">  if(!darktable.gui-&gt;reset &amp;&amp; !d-&gt;is_dragging)</a>
<a name="ln2219">  {</a>
<a name="ln2220">    g_signal_emit_by_name(G_OBJECT(w), &quot;value-changed&quot;);</a>
<a name="ln2221">    d-&gt;is_changed = 0;</a>
<a name="ln2222">  }</a>
<a name="ln2223">}</a>
<a name="ln2224"> </a>
<a name="ln2225">static gboolean dt_bauhaus_slider_postponed_value_change(gpointer data)</a>
<a name="ln2226">{</a>
<a name="ln2227">  if(!GTK_IS_WIDGET(data)) return 0;</a>
<a name="ln2228"> </a>
<a name="ln2229">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)data;</a>
<a name="ln2230">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2231">  if(d-&gt;is_changed)</a>
<a name="ln2232">  {</a>
<a name="ln2233">    g_signal_emit_by_name(G_OBJECT(w), &quot;value-changed&quot;);</a>
<a name="ln2234">    d-&gt;is_changed = 0;</a>
<a name="ln2235">  }</a>
<a name="ln2236"> </a>
<a name="ln2237">  if(!d-&gt;is_dragging) d-&gt;timeout_handle = 0;</a>
<a name="ln2238"> </a>
<a name="ln2239">  return d-&gt;is_dragging;</a>
<a name="ln2240">}</a>
<a name="ln2241"> </a>
<a name="ln2242">static gboolean dt_bauhaus_popup_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data)</a>
<a name="ln2243">{</a>
<a name="ln2244">  switch(darktable.bauhaus-&gt;current-&gt;type)</a>
<a name="ln2245">  {</a>
<a name="ln2246">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln2247">    {</a>
<a name="ln2248">      // hack to do screenshots from popup:</a>
<a name="ln2249">      // if(event-&gt;string[0] == 'p') return system(&quot;scrot&quot;);</a>
<a name="ln2250">      // else</a>
<a name="ln2251">      if(darktable.bauhaus-&gt;keys_cnt + 2 &lt; 64</a>
<a name="ln2252">         &amp;&amp; (event-&gt;keyval == GDK_KEY_space || event-&gt;keyval == GDK_KEY_KP_Space || // SPACE</a>
<a name="ln2253">             event-&gt;keyval == GDK_KEY_percent ||                                    // %</a>
<a name="ln2254">             (event-&gt;string[0] &gt;= 40 &amp;&amp; event-&gt;string[0] &lt;= 57) ||                  // ()+-*/.,0-9</a>
<a name="ln2255">             event-&gt;keyval == GDK_KEY_asciicircum ||                                // ^</a>
<a name="ln2256">             event-&gt;keyval == GDK_KEY_X || event-&gt;keyval == GDK_KEY_x))             // Xx</a>
<a name="ln2257">      {</a>
<a name="ln2258">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt++] = event-&gt;string[0];</a>
<a name="ln2259">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2260">      }</a>
<a name="ln2261">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0</a>
<a name="ln2262">              &amp;&amp; (event-&gt;keyval == GDK_KEY_BackSpace || event-&gt;keyval == GDK_KEY_Delete))</a>
<a name="ln2263">      {</a>
<a name="ln2264">        darktable.bauhaus-&gt;keys[--darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2265">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2266">      }</a>
<a name="ln2267">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0 &amp;&amp; darktable.bauhaus-&gt;keys_cnt + 1 &lt; 64</a>
<a name="ln2268">              &amp;&amp; (event-&gt;keyval == GDK_KEY_Return || event-&gt;keyval == GDK_KEY_KP_Enter))</a>
<a name="ln2269">      {</a>
<a name="ln2270">        // accept input</a>
<a name="ln2271">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2272">        // unnormalized input, user was typing this:</a>
<a name="ln2273">        float old_value = dt_bauhaus_slider_get(GTK_WIDGET(darktable.bauhaus-&gt;current));</a>
<a name="ln2274">        float new_value = dt_calculator_solve(old_value, darktable.bauhaus-&gt;keys);</a>
<a name="ln2275">        if(isfinite(new_value)) dt_bauhaus_slider_set_soft(GTK_WIDGET(darktable.bauhaus-&gt;current), new_value);</a>
<a name="ln2276">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2277">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2278">        dt_bauhaus_hide_popup();</a>
<a name="ln2279">      }</a>
<a name="ln2280">      else if(event-&gt;keyval == GDK_KEY_Escape)</a>
<a name="ln2281">      {</a>
<a name="ln2282">        // discard input and close popup</a>
<a name="ln2283">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2284">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2285">        dt_bauhaus_hide_popup();</a>
<a name="ln2286">      }</a>
<a name="ln2287">      else</a>
<a name="ln2288">        return FALSE;</a>
<a name="ln2289">      if(darktable.bauhaus-&gt;keys_cnt &gt; 0) _start_cursor(-1);</a>
<a name="ln2290">      return TRUE;</a>
<a name="ln2291">    }</a>
<a name="ln2292">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln2293">    {</a>
<a name="ln2294">      if(!g_utf8_validate(event-&gt;string, -1, NULL)) return FALSE;</a>
<a name="ln2295">      gunichar c = g_utf8_get_char(event-&gt;string);</a>
<a name="ln2296">      long int char_width = g_utf8_next_char(event-&gt;string) - event-&gt;string;</a>
<a name="ln2297">      // if(event-&gt;string[0] == 'p') return system(&quot;scrot&quot;);</a>
<a name="ln2298">      // else</a>
<a name="ln2299">      if(darktable.bauhaus-&gt;keys_cnt + 1 + char_width &lt; 64 &amp;&amp; g_unichar_isprint(c))</a>
<a name="ln2300">      {</a>
<a name="ln2301">        // only accept key input if still valid or editable?</a>
<a name="ln2302">        g_utf8_strncpy(darktable.bauhaus-&gt;keys + darktable.bauhaus-&gt;keys_cnt, event-&gt;string, 1);</a>
<a name="ln2303">        darktable.bauhaus-&gt;keys_cnt += char_width;</a>
<a name="ln2304">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2305">      }</a>
<a name="ln2306">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0</a>
<a name="ln2307">              &amp;&amp; (event-&gt;keyval == GDK_KEY_BackSpace || event-&gt;keyval == GDK_KEY_Delete))</a>
<a name="ln2308">      {</a>
<a name="ln2309">        darktable.bauhaus-&gt;keys_cnt</a>
<a name="ln2310">            -= (darktable.bauhaus-&gt;keys + darktable.bauhaus-&gt;keys_cnt)</a>
<a name="ln2311">               - g_utf8_prev_char(darktable.bauhaus-&gt;keys + darktable.bauhaus-&gt;keys_cnt);</a>
<a name="ln2312">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2313">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2314">      }</a>
<a name="ln2315">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0 &amp;&amp; darktable.bauhaus-&gt;keys_cnt + 1 &lt; 64</a>
<a name="ln2316">              &amp;&amp; (event-&gt;keyval == GDK_KEY_Return || event-&gt;keyval == GDK_KEY_KP_Enter))</a>
<a name="ln2317">      {</a>
<a name="ln2318">        // accept unique matches only for editable:</a>
<a name="ln2319">        if(darktable.bauhaus-&gt;current-&gt;data.combobox.editable)</a>
<a name="ln2320">          darktable.bauhaus-&gt;end_mouse_y = FLT_MAX;</a>
<a name="ln2321">        else</a>
<a name="ln2322">          darktable.bauhaus-&gt;end_mouse_y = 0;</a>
<a name="ln2323">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2324">        dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln2325">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2326">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2327">        dt_bauhaus_hide_popup();</a>
<a name="ln2328">      }</a>
<a name="ln2329">      else if(event-&gt;keyval == GDK_KEY_Escape)</a>
<a name="ln2330">      {</a>
<a name="ln2331">        // discard input and close popup</a>
<a name="ln2332">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2333">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2334">        dt_bauhaus_hide_popup();</a>
<a name="ln2335">      }</a>
<a name="ln2336">      else if(event-&gt;keyval == GDK_KEY_Up)</a>
<a name="ln2337">      {</a>
<a name="ln2338">        combobox_popup_scroll(-1);</a>
<a name="ln2339">      }</a>
<a name="ln2340">      else if(event-&gt;keyval == GDK_KEY_Down)</a>
<a name="ln2341">      {</a>
<a name="ln2342">        combobox_popup_scroll(1);</a>
<a name="ln2343">      }</a>
<a name="ln2344">      else if(event-&gt;keyval == GDK_KEY_Return || event-&gt;keyval == GDK_KEY_KP_Enter)</a>
<a name="ln2345">      {</a>
<a name="ln2346">        // return pressed, but didn't type anything</a>
<a name="ln2347">        darktable.bauhaus-&gt;end_mouse_y = -1; // negative will use currently highlighted instead.</a>
<a name="ln2348">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2349">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2350">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2351">        dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln2352">        dt_bauhaus_hide_popup();</a>
<a name="ln2353">      }</a>
<a name="ln2354">      else</a>
<a name="ln2355">        return FALSE;</a>
<a name="ln2356">      return TRUE;</a>
<a name="ln2357">    }</a>
<a name="ln2358">    default:</a>
<a name="ln2359">      return FALSE;</a>
<a name="ln2360">  }</a>
<a name="ln2361">}</a>
<a name="ln2362"> </a>
<a name="ln2363">static gboolean dt_bauhaus_slider_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2364">{</a>
<a name="ln2365">  GtkAllocation allocation;</a>
<a name="ln2366">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln2367">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2368">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2369">  gtk_widget_grab_focus(GTK_WIDGET(w));</a>
<a name="ln2370">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2371"> </a>
<a name="ln2372">  GtkAllocation tmp;</a>
<a name="ln2373">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2374">  if(w-&gt;quad_paint &amp;&amp; (event-&gt;x &gt; allocation.width - darktable.bauhaus-&gt;quad_width))</a>
<a name="ln2375">  {</a>
<a name="ln2376">    if (w-&gt;quad_toggle)</a>
<a name="ln2377">    {</a>
<a name="ln2378">      if (w-&gt;quad_paint_flags &amp; CPF_ACTIVE)</a>
<a name="ln2379">        w-&gt;quad_paint_flags &amp;= ~CPF_ACTIVE;</a>
<a name="ln2380">      else</a>
<a name="ln2381">        w-&gt;quad_paint_flags |= CPF_ACTIVE;</a>
<a name="ln2382">    }</a>
<a name="ln2383">    g_signal_emit_by_name(G_OBJECT(w), &quot;quad-pressed&quot;);</a>
<a name="ln2384">    return TRUE;</a>
<a name="ln2385">  }</a>
<a name="ln2386">  else if(event-&gt;button == 3)</a>
<a name="ln2387">  {</a>
<a name="ln2388">    dt_bauhaus_show_popup(w);</a>
<a name="ln2389">    return TRUE;</a>
<a name="ln2390">  }</a>
<a name="ln2391">  else if(event-&gt;button == 1)</a>
<a name="ln2392">  {</a>
<a name="ln2393">    // reset to default.</a>
<a name="ln2394">    if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln2395">    {</a>
<a name="ln2396">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2397">      d-&gt;is_dragging = 0;</a>
<a name="ln2398">      dt_bauhaus_slider_reset(GTK_WIDGET(w));</a>
<a name="ln2399">    }</a>
<a name="ln2400">    else</a>
<a name="ln2401">    {</a>
<a name="ln2402">      const float l = 0.0f;</a>
<a name="ln2403">      const float r = slider_right_pos((float)tmp.width);</a>
<a name="ln2404">      dt_bauhaus_slider_set_normalized(w, (event-&gt;x / tmp.width - l) / (r - l));</a>
<a name="ln2405">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2406">      d-&gt;is_dragging = 1;</a>
<a name="ln2407">      int delay = CLAMP(darktable.develop-&gt;average_delay * 3 / 2, DT_BAUHAUS_SLIDER_VALUE_CHANGED_DELAY_MIN,</a>
<a name="ln2408">                        DT_BAUHAUS_SLIDER_VALUE_CHANGED_DELAY_MAX);</a>
<a name="ln2409">      // timeout_handle should always be zero here, but check just in case</a>
<a name="ln2410">      if(!d-&gt;timeout_handle)</a>
<a name="ln2411">        d-&gt;timeout_handle = g_timeout_add(delay, dt_bauhaus_slider_postponed_value_change, widget);</a>
<a name="ln2412">    }</a>
<a name="ln2413">    return TRUE;</a>
<a name="ln2414">  }</a>
<a name="ln2415">  return FALSE;</a>
<a name="ln2416">}</a>
<a name="ln2417"> </a>
<a name="ln2418">static gboolean dt_bauhaus_slider_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2419">{</a>
<a name="ln2420">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2421">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2422"> </a>
<a name="ln2423">  if((event-&gt;button == 1) &amp;&amp; (d-&gt;is_dragging))</a>
<a name="ln2424">  {</a>
<a name="ln2425">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2426">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2427"> </a>
<a name="ln2428">    GtkAllocation tmp;</a>
<a name="ln2429">    gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2430">    d-&gt;is_dragging = 0;</a>
<a name="ln2431">    if(d-&gt;timeout_handle) g_source_remove(d-&gt;timeout_handle);</a>
<a name="ln2432">    d-&gt;timeout_handle = 0;</a>
<a name="ln2433">    const float l = 0.0f;</a>
<a name="ln2434">    const float r = slider_right_pos((float)tmp.width);</a>
<a name="ln2435">    dt_bauhaus_slider_set_normalized(w, (event-&gt;x / tmp.width - l) / (r - l));</a>
<a name="ln2436"> </a>
<a name="ln2437">    return TRUE;</a>
<a name="ln2438">  }</a>
<a name="ln2439">  return FALSE;</a>
<a name="ln2440">}</a>
<a name="ln2441"> </a>
<a name="ln2442">static gboolean dt_bauhaus_slider_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln2443">{</a>
<a name="ln2444">  // remember mouse position for motion effects in draw</a>
<a name="ln2445">  if(event-&gt;state &amp; GDK_BUTTON1_MASK &amp;&amp; event-&gt;type != GDK_2BUTTON_PRESS)</a>
<a name="ln2446">  {</a>
<a name="ln2447">    dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2448">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2449">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2450">    GtkAllocation tmp;</a>
<a name="ln2451">    gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2452">    const float l = 0.0f;</a>
<a name="ln2453">    const float r = slider_right_pos((float)tmp.width);</a>
<a name="ln2454">    dt_bauhaus_slider_set_normalized(w, (event-&gt;x / tmp.width - l) / (r - l));</a>
<a name="ln2455">  }</a>
<a name="ln2456">  // not sure if needed:</a>
<a name="ln2457">  // gdk_event_request_motions(event);</a>
<a name="ln2458">  return TRUE;</a>
<a name="ln2459">}</a>
<a name="ln2460"> </a>
<a name="ln2461">void dt_bauhaus_vimkey_exec(const char *input)</a>
<a name="ln2462">{</a>
<a name="ln2463">  char module[64], label[64], value[256], *key;</a>
<a name="ln2464">  float old_value, new_value;</a>
<a name="ln2465"> </a>
<a name="ln2466">  sscanf(input, &quot;:set %63[^.].%63[^=]=%255s&quot;, module, label, value);</a>
<a name="ln2467">  fprintf(stderr, &quot;[vimkey] setting module `%s', slider `%s' to `%s'&quot;, module, label, value);</a>
<a name="ln2468">  key = g_strjoin(&quot;.&quot;, module, label, NULL);</a>
<a name="ln2469">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)g_hash_table_lookup(darktable.bauhaus-&gt;keymap, key);</a>
<a name="ln2470">  g_free(key);</a>
<a name="ln2471">  if(!w) return;</a>
<a name="ln2472">  switch(w-&gt;type)</a>
<a name="ln2473">  {</a>
<a name="ln2474">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln2475">      old_value = dt_bauhaus_slider_get(GTK_WIDGET(w));</a>
<a name="ln2476">      new_value = dt_calculator_solve(old_value, value);</a>
<a name="ln2477">      fprintf(stderr, &quot; = %f\n&quot;, new_value);</a>
<a name="ln2478">      if(isfinite(new_value)) dt_bauhaus_slider_set_soft(GTK_WIDGET(w), new_value);</a>
<a name="ln2479">      break;</a>
<a name="ln2480">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln2481">      // TODO: what about text as entry?</a>
<a name="ln2482">      old_value = dt_bauhaus_combobox_get(GTK_WIDGET(w));</a>
<a name="ln2483">      new_value = dt_calculator_solve(old_value, value);</a>
<a name="ln2484">      fprintf(stderr, &quot; = %f\n&quot;, new_value);</a>
<a name="ln2485">      if(isfinite(new_value)) dt_bauhaus_combobox_set(GTK_WIDGET(w), new_value);</a>
<a name="ln2486">      break;</a>
<a name="ln2487">    default:</a>
<a name="ln2488">      break;</a>
<a name="ln2489">  }</a>
<a name="ln2490">}</a>
<a name="ln2491"> </a>
<a name="ln2492">// give autocomplete suggestions</a>
<a name="ln2493">GList *dt_bauhaus_vimkey_complete(const char *input)</a>
<a name="ln2494">{</a>
<a name="ln2495">  GList *cmp = darktable.bauhaus-&gt;key_mod;</a>
<a name="ln2496">  char *point = strstr(input, &quot;.&quot;);</a>
<a name="ln2497">  if(point) cmp = darktable.bauhaus-&gt;key_val;</a>
<a name="ln2498">  int prefix = strlen(input);</a>
<a name="ln2499">  GList *res = NULL;</a>
<a name="ln2500">  int after = 0;</a>
<a name="ln2501">  while(cmp)</a>
<a name="ln2502">  {</a>
<a name="ln2503">    char *path = (char *)cmp-&gt;data;</a>
<a name="ln2504">    if(strncasecmp(path, input, prefix))</a>
<a name="ln2505">    {</a>
<a name="ln2506">      if(after) break; // sorted, so we're done</a>
<a name="ln2507">                       // else loop till we find the start of it</a>
<a name="ln2508">    }</a>
<a name="ln2509">    else</a>
<a name="ln2510">    {</a>
<a name="ln2511">      // append:</a>
<a name="ln2512">      res = g_list_insert_sorted(res, path, (GCompareFunc)strcmp);</a>
<a name="ln2513">      after = 1;</a>
<a name="ln2514">    }</a>
<a name="ln2515">    cmp = g_list_next(cmp);</a>
<a name="ln2516">  }</a>
<a name="ln2517">  return res;</a>
<a name="ln2518">}</a>
<a name="ln2519"> </a>
<a name="ln2520">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2521">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2522">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="65"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'entry'. Check lines: 65, 64.</p></div>
<div class="balloon" rel="526"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v636/" target="_blank">V636</a> The 'pango_height / 1024' expression was implicitly cast from 'int' type to 'float' type. Consider utilizing an explicit type cast to avoid the loss of a fractional part. An example: double A = (double)(X) / Y;.</p></div>
<div class="balloon" rel="538"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'darktable.bauhaus'. Check lines: 538, 537.</p></div>
<div class="balloon" rel="1564"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v656/" target="_blank">V656</a> Variables 'fg_color', 'bg_color' are initialized through the call to the same function. It's probably an error or un-optimized code. Consider inspecting the 'default_color_assign()' expression. Check lines: 1563, 1564.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
