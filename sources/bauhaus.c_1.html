
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012 johannes hanika.</a>
<a name="ln4">    copyright (c) 2012--2014 tobias ellinghaus.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln21">#include &quot;common/calculator.h&quot;</a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;develop/develop.h&quot;</a>
<a name="ln25">#include &quot;gui/gtk.h&quot;</a>
<a name="ln26">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln27">#include &quot;osx/osx.h&quot;</a>
<a name="ln28">#endif</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;math.h&gt;</a>
<a name="ln31">#include &lt;strings.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;pango/pangocairo.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">G_DEFINE_TYPE(DtBauhausWidget, dt_bh, GTK_TYPE_DRAWING_AREA)</a>
<a name="ln36"> </a>
<a name="ln37">// INNER_PADDING is the horizontal space between slider and quad</a>
<a name="ln38">// and vertical space between labels and slider baseline</a>
<a name="ln39">#define INNER_PADDING 4.0</a>
<a name="ln40"> </a>
<a name="ln41">// fwd declare</a>
<a name="ln42">static gboolean dt_bauhaus_popup_draw(GtkWidget *widget, cairo_t *cr, gpointer user_data);</a>
<a name="ln43">static gboolean dt_bauhaus_popup_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);</a>
<a name="ln44">static void dt_bauhaus_widget_accept(dt_bauhaus_widget_t *w);</a>
<a name="ln45">static void dt_bauhaus_widget_reject(dt_bauhaus_widget_t *w);</a>
<a name="ln46"> </a>
<a name="ln47">static gboolean _combobox_next_entry(GList *entries, int *new_pos, int delta_y)</a>
<a name="ln48">{</a>
<a name="ln49">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(entries, *new_pos);</a>
<a name="ln50">  while(entry &amp;&amp; !entry-&gt;sensitive)</a>
<a name="ln51">  {</a>
<a name="ln52">    *new_pos += delta_y;</a>
<a name="ln53">    entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(entries, *new_pos);</a>
<a name="ln54">  }</a>
<a name="ln55">  return entry != NULL;</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">static inline int get_line_height()</a>
<a name="ln59">{</a>
<a name="ln60">  return darktable.bauhaus-&gt;scale * darktable.bauhaus-&gt;line_height;</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">static dt_bauhaus_combobox_entry_t *new_combobox_entry(const char *label, dt_bauhaus_combobox_alignment_t alignment,</a>
<a name="ln64">                                                       gboolean sensitive, void *data, void (*free_func)(void *))</a>
<a name="ln65">{</a>
<a name="ln66">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)calloc(1, sizeof(dt_bauhaus_combobox_entry_t));</a>
<a name="ln67">  entry-&gt;label = g_strdup(label);</a>
<a name="ln68">  entry-&gt;alignment = alignment;</a>
<a name="ln69">  entry-&gt;sensitive = sensitive;</a>
<a name="ln70">  entry-&gt;data = data;</a>
<a name="ln71">  entry-&gt;free_func = free_func;</a>
<a name="ln72">  return entry;</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">static void free_combobox_entry(gpointer data)</a>
<a name="ln76">{</a>
<a name="ln77">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)data;</a>
<a name="ln78">  g_free(entry-&gt;label);</a>
<a name="ln79">  if(entry-&gt;free_func)</a>
<a name="ln80">    entry-&gt;free_func(entry-&gt;data);</a>
<a name="ln81">  free(entry);</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84">static inline float inner_height(GtkAllocation allocation)</a>
<a name="ln85">{</a>
<a name="ln86">  // retrieve the inner height of the widget (inside the top/bottom margin)</a>
<a name="ln87">  return allocation.height - 2.0f * darktable.bauhaus-&gt;widget_space;</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">static GdkRGBA * default_color_assign()</a>
<a name="ln92">{</a>
<a name="ln93">  // helper to initialize a color pointer with red color as a default</a>
<a name="ln94">  GdkRGBA color;</a>
<a name="ln95">  color.red = 1.0f;</a>
<a name="ln96">  color.green = 0.0f;</a>
<a name="ln97">  color.blue = 0.0f;</a>
<a name="ln98">  color.alpha = 1.0f;</a>
<a name="ln99">  return gdk_rgba_copy(&amp;color);</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102"> </a>
<a name="ln103">static int show_pango_text(dt_bauhaus_widget_t *w, GtkStyleContext *context, cairo_t *cr, char *text, float x_pos, float y_pos, float max_width, gboolean right_aligned)</a>
<a name="ln104">{</a>
<a name="ln105">  PangoLayout *layout;</a>
<a name="ln106"> </a>
<a name="ln107">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln108"> </a>
<a name="ln109">  if(max_width &gt; 0)</a>
<a name="ln110">  {</a>
<a name="ln111">    pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_MIDDLE);</a>
<a name="ln112">    pango_layout_set_width(layout, (int)(PANGO_SCALE * max_width + 0.5f));</a>
<a name="ln113">  }</a>
<a name="ln114"> </a>
<a name="ln115">  if(text) {</a>
<a name="ln116">    pango_layout_set_text(layout, text, -1);</a>
<a name="ln117">  } else {</a>
<a name="ln118">    // length of -1 is not allowed with NULL string (wtf)</a>
<a name="ln119">    pango_layout_set_text(layout, NULL, 0);</a>
<a name="ln120">  }</a>
<a name="ln121"> </a>
<a name="ln122">  PangoFontDescription *font_desc = pango_font_description_copy(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln123"> </a>
<a name="ln124">  // This should be able to update the font style for current text depending on :hover, :focused, etc.</a>
<a name="ln125">  // CSS pseudo-classes, yet it defaults to system font.</a>
<a name="ln126">  // FIXME: get that working so we can put :active text in bold, for example.</a>
<a name="ln127">  //gtk_style_context_get(context, gtk_widget_get_state_flags(GTK_WIDGET(w)), &quot;font&quot;, font_desc, NULL);</a>
<a name="ln128"> </a>
<a name="ln129">  pango_layout_set_font_description(layout, font_desc);</a>
<a name="ln130">  pango_cairo_context_set_resolution(pango_layout_get_context(layout), darktable.gui-&gt;dpi);</a>
<a name="ln131"> </a>
<a name="ln132">  int pango_width, pango_height;</a>
<a name="ln133">  pango_layout_get_size(layout, &amp;pango_width, &amp;pango_height);</a>
<a name="ln134">  float text_width = ((double)pango_width/PANGO_SCALE);</a>
<a name="ln135"> </a>
<a name="ln136">  if(right_aligned) x_pos -= text_width;</a>
<a name="ln137"> </a>
<a name="ln138">  cairo_move_to(cr, x_pos, y_pos);</a>
<a name="ln139">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln140">  g_object_unref(layout);</a>
<a name="ln141"> </a>
<a name="ln142">  return text_width;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">// -------------------------------</a>
<a name="ln146">static gboolean _cursor_timeout_callback(gpointer user_data)</a>
<a name="ln147">{</a>
<a name="ln148">  if(darktable.bauhaus-&gt;cursor_blink_counter &gt; 0) darktable.bauhaus-&gt;cursor_blink_counter--;</a>
<a name="ln149"> </a>
<a name="ln150">  darktable.bauhaus-&gt;cursor_visible = !darktable.bauhaus-&gt;cursor_visible;</a>
<a name="ln151">  gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln152"> </a>
<a name="ln153">  if(darktable.bauhaus-&gt;cursor_blink_counter</a>
<a name="ln154">     != 0) // this can be &gt;0 when we haven't reached the desired number or -1 when blinking forever</a>
<a name="ln155">    return TRUE;</a>
<a name="ln156"> </a>
<a name="ln157">  darktable.bauhaus-&gt;cursor_timeout = 0; // otherwise the cursor won't come up when starting to type</a>
<a name="ln158">  return FALSE;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">static void _start_cursor(int max_blinks)</a>
<a name="ln162">{</a>
<a name="ln163">  darktable.bauhaus-&gt;cursor_blink_counter = max_blinks;</a>
<a name="ln164">  darktable.bauhaus-&gt;cursor_visible = FALSE;</a>
<a name="ln165">  if(darktable.bauhaus-&gt;cursor_timeout == 0)</a>
<a name="ln166">    darktable.bauhaus-&gt;cursor_timeout = g_timeout_add(500, _cursor_timeout_callback, NULL);</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">static void _stop_cursor()</a>
<a name="ln170">{</a>
<a name="ln171">  if(darktable.bauhaus-&gt;cursor_timeout &gt; 0)</a>
<a name="ln172">  {</a>
<a name="ln173">    g_source_remove(darktable.bauhaus-&gt;cursor_timeout);</a>
<a name="ln174">    darktable.bauhaus-&gt;cursor_timeout = 0;</a>
<a name="ln175">    darktable.bauhaus-&gt;cursor_visible = FALSE;</a>
<a name="ln176">  }</a>
<a name="ln177">}</a>
<a name="ln178">// -------------------------------</a>
<a name="ln179"> </a>
<a name="ln180"> </a>
<a name="ln181">static void dt_bauhaus_slider_set_normalized(dt_bauhaus_widget_t *w, float pos);</a>
<a name="ln182"> </a>
<a name="ln183">static float slider_right_pos(float width)</a>
<a name="ln184">{</a>
<a name="ln185">  // relative position (in widget) of the right bound of the slider corrected with the inner padding</a>
<a name="ln186">  return 1.0f - (darktable.bauhaus-&gt;quad_width + INNER_PADDING) / width;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">static float slider_coordinate(const float abs_position, const float width)</a>
<a name="ln190">{</a>
<a name="ln191">  // Translates an horizontal position relative to the slider</a>
<a name="ln192">  // in an horizontal position relative to the widget</a>
<a name="ln193">  const float left_bound = 0.0f;</a>
<a name="ln194">  const float right_bound = slider_right_pos(width); // exclude the quad area on the right</a>
<a name="ln195">  return (left_bound + abs_position * (right_bound - left_bound)) * width;</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198"> </a>
<a name="ln199">static float get_slider_line_offset(float pos, float scale, float x, float y, float ht, const int width)</a>
<a name="ln200">{</a>
<a name="ln201">  // ht is in [0,1] scale here</a>
<a name="ln202">  const float l = 0.0f;</a>
<a name="ln203">  const float r = slider_right_pos(width);</a>
<a name="ln204"> </a>
<a name="ln205">  float offset = 0.0f;</a>
<a name="ln206">  // handle linear startup and rescale y to fit the whole range again</a>
<a name="ln207">  if(y &lt; ht)</a>
<a name="ln208">  {</a>
<a name="ln209">    offset = (x - l) / (r - l) - pos;</a>
<a name="ln210">  }</a>
<a name="ln211">  else</a>
<a name="ln212">  {</a>
<a name="ln213">    y -= ht;</a>
<a name="ln214">    y /= (1.0f - ht);</a>
<a name="ln215"> </a>
<a name="ln216">    offset = (x - y * y * .5f - (1.0f - y * y) * (l + pos * (r - l)))</a>
<a name="ln217">             / (.5f * y * y / scale + (1.0f - y * y) * (r - l));</a>
<a name="ln218">  }</a>
<a name="ln219">  // clamp to result in a [0,1] range:</a>
<a name="ln220">  if(pos + offset &gt; 1.0f) offset = 1.0f - pos;</a>
<a name="ln221">  if(pos + offset &lt; 0.0f) offset = -pos;</a>
<a name="ln222">  return offset;</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">// draw a loupe guideline for the quadratic zoom in in the slider interface:</a>
<a name="ln226">static void draw_slider_line(cairo_t *cr, float pos, float off, float scale, const int width,</a>
<a name="ln227">                             const int height, const int ht)</a>
<a name="ln228">{</a>
<a name="ln229">  // pos is normalized position [0,1], offset is on that scale.</a>
<a name="ln230">  // ht is in pixels here</a>
<a name="ln231">  const float l = 0.0f;</a>
<a name="ln232">  const float r = slider_right_pos(width);</a>
<a name="ln233"> </a>
<a name="ln234">  const int steps = 64;</a>
<a name="ln235">  cairo_move_to(cr, width * (l + (pos + off) * (r - l)), ht * .7f);</a>
<a name="ln236">  cairo_line_to(cr, width * (l + (pos + off) * (r - l)), ht);</a>
<a name="ln237">  for(int j = 1; j &lt; steps; j++)</a>
<a name="ln238">  {</a>
<a name="ln239">    const float y = j / (steps - 1.0f);</a>
<a name="ln240">    const float x = y * y * .5f * (1.f + off / scale) + (1.0f - y * y) * (l + (pos + off) * (r - l));</a>
<a name="ln241">    cairo_line_to(cr, x * width, ht + y * (height - ht));</a>
<a name="ln242">  }</a>
<a name="ln243">}</a>
<a name="ln244">// -------------------------------</a>
<a name="ln245"> </a>
<a name="ln246">// handlers on the popup window, to close popup:</a>
<a name="ln247">static gboolean dt_bauhaus_window_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln248">{</a>
<a name="ln249">  const float tol = 50;</a>
<a name="ln250">  gint wx, wy;</a>
<a name="ln251">  GtkAllocation allocation;</a>
<a name="ln252">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln253">  gdk_window_get_origin(gtk_widget_get_window(widget), &amp;wx, &amp;wy);</a>
<a name="ln254">  if(event-&gt;x_root &gt; wx + allocation.width + tol || event-&gt;y_root &gt; wy + inner_height(allocation) + tol</a>
<a name="ln255">     || event-&gt;x_root &lt; (int)wx - tol || event-&gt;y_root &lt; (int)wy - tol)</a>
<a name="ln256">  {</a>
<a name="ln257">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln258">    dt_bauhaus_hide_popup();</a>
<a name="ln259">    gtk_widget_set_state_flags(GTK_WIDGET(darktable.bauhaus-&gt;current), GTK_STATE_FLAG_NORMAL, TRUE);</a>
<a name="ln260">    return TRUE;</a>
<a name="ln261">  }</a>
<a name="ln262">  // make sure to propagate the event further</a>
<a name="ln263">  return FALSE;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">static gboolean dt_bauhaus_window_button_press(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln267">{</a>
<a name="ln268">  const float tol = 0;</a>
<a name="ln269">  gint wx, wy;</a>
<a name="ln270">  GtkAllocation allocation;</a>
<a name="ln271">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln272">  gdk_window_get_origin(gtk_widget_get_window(widget), &amp;wx, &amp;wy);</a>
<a name="ln273">  if((event-&gt;x_root &gt; wx + allocation.width + tol || event-&gt;y_root &gt; wy + inner_height(allocation) + tol</a>
<a name="ln274">      || event-&gt;x_root &lt; (int)wx - tol || event-&gt;y_root &lt; (int)wy - tol))</a>
<a name="ln275">  {</a>
<a name="ln276">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln277">    dt_bauhaus_hide_popup();</a>
<a name="ln278">    gtk_widget_set_state_flags(GTK_WIDGET(darktable.bauhaus-&gt;current),</a>
<a name="ln279">                            GTK_STATE_FLAG_NORMAL, FALSE);</a>
<a name="ln280">    return TRUE;</a>
<a name="ln281">  }</a>
<a name="ln282">  // make sure to propagate the event further</a>
<a name="ln283">  return FALSE;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">static void combobox_popup_scroll(int amt)</a>
<a name="ln287">{</a>
<a name="ln288">  gint wx, wy;</a>
<a name="ln289">  GtkWidget *w = GTK_WIDGET(darktable.bauhaus-&gt;current);</a>
<a name="ln290">  GtkAllocation allocation_w;</a>
<a name="ln291">  gtk_widget_get_allocation(w, &amp;allocation_w);</a>
<a name="ln292">  const int ht = allocation_w.height;</a>
<a name="ln293">  const int skip = ht;</a>
<a name="ln294">  gdk_window_get_origin(gtk_widget_get_window(w), &amp;wx, &amp;wy);</a>
<a name="ln295">  dt_bauhaus_combobox_data_t *d = &amp;darktable.bauhaus-&gt;current-&gt;data.combobox;</a>
<a name="ln296">  int new_value = CLAMP(d-&gt;active + amt, 0, d-&gt;num_labels - 1);</a>
<a name="ln297">  // skip insensitive ones</a>
<a name="ln298">  if(!_combobox_next_entry(d-&gt;entries, &amp;new_value, amt))</a>
<a name="ln299">    return;</a>
<a name="ln300"> </a>
<a name="ln301">  // we move the popup up or down</a>
<a name="ln302">  if(new_value == d-&gt;active)</a>
<a name="ln303">  {</a>
<a name="ln304">    gdk_window_move(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), wx, wy - d-&gt;active * skip);</a>
<a name="ln305">  }</a>
<a name="ln306">  else</a>
<a name="ln307">  {</a>
<a name="ln308">    gint px, py;</a>
<a name="ln309">    gdk_window_get_origin(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), &amp;px, &amp;py);</a>
<a name="ln310">    gdk_window_move(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), wx, py - skip * (new_value - d-&gt;active));</a>
<a name="ln311">  }</a>
<a name="ln312"> </a>
<a name="ln313">  // make sure highlighted entry is updated:</a>
<a name="ln314">  darktable.bauhaus-&gt;mouse_x = 0;</a>
<a name="ln315">  darktable.bauhaus-&gt;mouse_y = new_value * skip + ht / 2;</a>
<a name="ln316">  gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln317"> </a>
<a name="ln318">  // and we change the value</a>
<a name="ln319">  dt_bauhaus_combobox_set(w, new_value);</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322"> </a>
<a name="ln323">static gboolean dt_bauhaus_popup_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln324">{</a>
<a name="ln325">  int delta_y;</a>
<a name="ln326">  switch(darktable.bauhaus-&gt;current-&gt;type)</a>
<a name="ln327">  {</a>
<a name="ln328">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln329">      if(dt_gui_get_scroll_unit_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln330">         combobox_popup_scroll(delta_y);</a>
<a name="ln331">      break;</a>
<a name="ln332">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln333">      break;</a>
<a name="ln334">    default:</a>
<a name="ln335">      break;</a>
<a name="ln336">  }</a>
<a name="ln337">  return TRUE;</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340">static gboolean dt_bauhaus_popup_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln341">{</a>
<a name="ln342">  GtkAllocation allocation_popup_window;</a>
<a name="ln343">  gtk_widget_get_allocation(darktable.bauhaus-&gt;popup_window, &amp;allocation_popup_window);</a>
<a name="ln344">  gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln345">  dt_bauhaus_widget_t *w = darktable.bauhaus-&gt;current;</a>
<a name="ln346">  GtkAllocation allocation_w;</a>
<a name="ln347">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;allocation_w);</a>
<a name="ln348">  int width = allocation_popup_window.width, height = inner_height(allocation_popup_window);</a>
<a name="ln349">  // coordinate transform is in vain because we're only ever called after a button release.</a>
<a name="ln350">  // that means the system is always the one of the popup.</a>
<a name="ln351">  // that also means that we can't have hovering combobox entries while still holding the button. :(</a>
<a name="ln352">  const float ex = event-&gt;x;</a>
<a name="ln353">  const float ey = event-&gt;y;</a>
<a name="ln354">  GtkAllocation allocation;</a>
<a name="ln355">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln356"> </a>
<a name="ln357">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_PRELIGHT, TRUE);</a>
<a name="ln358"> </a>
<a name="ln359">  if(darktable.bauhaus-&gt;keys_cnt == 0) _stop_cursor();</a>
<a name="ln360"> </a>
<a name="ln361">  switch(w-&gt;type)</a>
<a name="ln362">  {</a>
<a name="ln363">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln364">      darktable.bauhaus-&gt;mouse_x = ex;</a>
<a name="ln365">      darktable.bauhaus-&gt;mouse_y = ey;</a>
<a name="ln366">      break;</a>
<a name="ln367">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln368">    {</a>
<a name="ln369">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln370">      const float mouse_off = get_slider_line_offset(d-&gt;oldpos, d-&gt;scale, ex / width, ey / height,</a>
<a name="ln371">                                                     allocation_w.height / (float)height, allocation.width);</a>
<a name="ln372">      if(!darktable.bauhaus-&gt;change_active)</a>
<a name="ln373">      {</a>
<a name="ln374">        if((darktable.bauhaus-&gt;mouse_line_distance &lt; 0 &amp;&amp; mouse_off &gt;= 0)</a>
<a name="ln375">           || (darktable.bauhaus-&gt;mouse_line_distance &gt; 0 &amp;&amp; mouse_off &lt;= 0))</a>
<a name="ln376">          darktable.bauhaus-&gt;change_active = 1;</a>
<a name="ln377">        darktable.bauhaus-&gt;mouse_line_distance = mouse_off;</a>
<a name="ln378">      }</a>
<a name="ln379">      if(darktable.bauhaus-&gt;change_active)</a>
<a name="ln380">      {</a>
<a name="ln381">        // remember mouse position for motion effects in draw</a>
<a name="ln382">        darktable.bauhaus-&gt;mouse_x = ex;</a>
<a name="ln383">        darktable.bauhaus-&gt;mouse_y = ey;</a>
<a name="ln384">        dt_bauhaus_slider_set_normalized(w, d-&gt;oldpos + mouse_off);</a>
<a name="ln385">      }</a>
<a name="ln386">    }</a>
<a name="ln387">    break;</a>
<a name="ln388">    default:</a>
<a name="ln389">      break;</a>
<a name="ln390">  }</a>
<a name="ln391">  // throttling using motion hint:</a>
<a name="ln392">  // gdk_event_request_motions(event);</a>
<a name="ln393">  return TRUE;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">static gboolean dt_bauhaus_popup_leave_notify(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln397">{</a>
<a name="ln398">  gtk_widget_set_state_flags(widget, GTK_STATE_FLAG_NORMAL, TRUE);</a>
<a name="ln399">  return TRUE;</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">static gboolean dt_bauhaus_popup_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln403">{</a>
<a name="ln404">  if(darktable.bauhaus-&gt;current &amp;&amp; (darktable.bauhaus-&gt;current-&gt;type == DT_BAUHAUS_COMBOBOX)</a>
<a name="ln405">     &amp;&amp; (event-&gt;button == 1) &amp;&amp;                                // only accept left mouse click</a>
<a name="ln406">     (dt_get_wtime() - darktable.bauhaus-&gt;opentime &gt;= 0.250f)) // default gtk timeout for double-clicks</a>
<a name="ln407">  {</a>
<a name="ln408">    gtk_widget_set_state_flags(widget, GTK_STATE_FLAG_ACTIVE, TRUE);</a>
<a name="ln409"> </a>
<a name="ln410">    // event might be in wrong system, transform ourselves:</a>
<a name="ln411">    gint wx, wy, x, y;</a>
<a name="ln412">    gdk_window_get_origin(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), &amp;wx, &amp;wy);</a>
<a name="ln413"> </a>
<a name="ln414">    gdk_device_get_position(</a>
<a name="ln415">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln416">        gdk_seat_get_pointer(gdk_display_get_default_seat(gtk_widget_get_display(widget))), 0, &amp;x, &amp;y);</a>
<a name="ln417">#else</a>
<a name="ln418">        gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gdk_display_get_default())), NULL, &amp;x,</a>
<a name="ln419">        &amp;y);</a>
<a name="ln420">#endif</a>
<a name="ln421">    darktable.bauhaus-&gt;end_mouse_x = x - wx;</a>
<a name="ln422">    darktable.bauhaus-&gt;end_mouse_y = y - wy;</a>
<a name="ln423">    dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln424">  }</a>
<a name="ln425">  dt_bauhaus_hide_popup();</a>
<a name="ln426">  return TRUE;</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">static gboolean dt_bauhaus_popup_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln430">{</a>
<a name="ln431">  if(event-&gt;button == 1)</a>
<a name="ln432">  {</a>
<a name="ln433">    if(darktable.bauhaus-&gt;current-&gt;type == DT_BAUHAUS_COMBOBOX</a>
<a name="ln434">       &amp;&amp; dt_get_wtime() - darktable.bauhaus-&gt;opentime &lt; 0.250f) // default gtk timeout for double-clicks</a>
<a name="ln435">    {</a>
<a name="ln436">      // counts as double click, reset:</a>
<a name="ln437">      dt_bauhaus_combobox_data_t *d = &amp;darktable.bauhaus-&gt;current-&gt;data.combobox;</a>
<a name="ln438">      dt_bauhaus_combobox_set(GTK_WIDGET(darktable.bauhaus-&gt;current), d-&gt;defpos);</a>
<a name="ln439">      dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln440">      gtk_widget_set_state_flags(GTK_WIDGET(darktable.bauhaus-&gt;current),</a>
<a name="ln441">                            GTK_STATE_FLAG_FOCUSED, FALSE);</a>
<a name="ln442">    }</a>
<a name="ln443">    else</a>
<a name="ln444">    {</a>
<a name="ln445">      // only accept left mouse click</a>
<a name="ln446">      darktable.bauhaus-&gt;end_mouse_x = event-&gt;x;</a>
<a name="ln447">      darktable.bauhaus-&gt;end_mouse_y = event-&gt;y;</a>
<a name="ln448">      dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln449">      gtk_widget_set_state_flags(GTK_WIDGET(darktable.bauhaus-&gt;current),</a>
<a name="ln450">                            GTK_STATE_FLAG_FOCUSED, FALSE);</a>
<a name="ln451">    }</a>
<a name="ln452">  }</a>
<a name="ln453">  else</a>
<a name="ln454">  {</a>
<a name="ln455">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln456">  }</a>
<a name="ln457">  return TRUE;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">static void dt_bauhaus_window_show(GtkWidget *w, gpointer user_data)</a>
<a name="ln461">{</a>
<a name="ln462">  // Could grab the popup_area rather than popup_window, but if so</a>
<a name="ln463">  // then popup_area would get all motion events including those</a>
<a name="ln464">  // outside of the popup. This way the popup_area gets motion events</a>
<a name="ln465">  // related to updating the popup, and popup_window gets all others</a>
<a name="ln466">  // which would be the ones telling it to close the popup.</a>
<a name="ln467">  gtk_grab_add(w);</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">static void dt_bh_init(DtBauhausWidget *class)</a>
<a name="ln471">{</a>
<a name="ln472">  // not sure if we want to use this instead of our code in *_new()</a>
<a name="ln473">  // TODO: the common code from bauhaus_widget_init() could go here.</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476">static void dt_bh_class_init(DtBauhausWidgetClass *class)</a>
<a name="ln477">{</a>
<a name="ln478">  darktable.bauhaus-&gt;signals[DT_BAUHAUS_VALUE_CHANGED_SIGNAL]</a>
<a name="ln479">      = g_signal_new(&quot;value-changed&quot;, G_TYPE_FROM_CLASS(class), G_SIGNAL_RUN_LAST, 0, NULL, NULL,</a>
<a name="ln480">                     g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);</a>
<a name="ln481">  darktable.bauhaus-&gt;signals[DT_BAUHAUS_QUAD_PRESSED_SIGNAL]</a>
<a name="ln482">      = g_signal_new(&quot;quad-pressed&quot;, G_TYPE_FROM_CLASS(class), G_SIGNAL_RUN_LAST, 0, NULL, NULL,</a>
<a name="ln483">                     g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);</a>
<a name="ln484"> </a>
<a name="ln485">  // TODO: could init callbacks once per class for more efficiency:</a>
<a name="ln486">  // GtkWidgetClass *widget_class;</a>
<a name="ln487">  // widget_class = GTK_WIDGET_CLASS (class);</a>
<a name="ln488">  // widget_class-&gt;draw = dt_bauhaus_draw;</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491">void dt_bauhaus_load_theme()</a>
<a name="ln492">{</a>
<a name="ln493">  darktable.bauhaus-&gt;line_space = 1.5;</a>
<a name="ln494">  darktable.bauhaus-&gt;line_height = 10;</a>
<a name="ln495">  darktable.bauhaus-&gt;marker_size = 0.25f;</a>
<a name="ln496">  darktable.bauhaus-&gt;label_font_size = 0.6f;</a>
<a name="ln497">  darktable.bauhaus-&gt;value_font_size = 0.6f;</a>
<a name="ln498"> </a>
<a name="ln499">  GtkWidget *root_window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln500">  GtkStyleContext *ctx = gtk_style_context_new();</a>
<a name="ln501">  GtkWidgetPath *path;</a>
<a name="ln502">  path = gtk_widget_path_new ();</a>
<a name="ln503">  int pos = gtk_widget_path_append_type(path, GTK_TYPE_WIDGET);</a>
<a name="ln504">  gtk_widget_path_iter_set_name(path, pos, &quot;iop-plugin-ui&quot;);</a>
<a name="ln505">  gtk_style_context_set_path(ctx, path);</a>
<a name="ln506">  gtk_style_context_set_screen (ctx, gtk_widget_get_screen(root_window));</a>
<a name="ln507"> </a>
<a name="ln508">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_fg&quot;, &amp;darktable.bauhaus-&gt;color_fg);</a>
<a name="ln509">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_fg_insensitive&quot;, &amp;darktable.bauhaus-&gt;color_fg_insensitive);</a>
<a name="ln510">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_bg&quot;, &amp;darktable.bauhaus-&gt;color_bg);</a>
<a name="ln511">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_border&quot;, &amp;darktable.bauhaus-&gt;color_border);</a>
<a name="ln512">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_fill&quot;, &amp;darktable.bauhaus-&gt;color_fill);</a>
<a name="ln513">  gtk_style_context_lookup_color(ctx, &quot;bauhaus_indicator_border&quot;, &amp;darktable.bauhaus-&gt;indicator_border);</a>
<a name="ln514"> </a>
<a name="ln515">  gtk_style_context_lookup_color(ctx, &quot;graph_bg&quot;, &amp;darktable.bauhaus-&gt;graph_bg);</a>
<a name="ln516">  gtk_style_context_lookup_color(ctx, &quot;graph_border&quot;, &amp;darktable.bauhaus-&gt;graph_border);</a>
<a name="ln517">  gtk_style_context_lookup_color(ctx, &quot;graph_grid&quot;, &amp;darktable.bauhaus-&gt;graph_grid);</a>
<a name="ln518">  gtk_style_context_lookup_color(ctx, &quot;graph_fg&quot;, &amp;darktable.bauhaus-&gt;graph_fg);</a>
<a name="ln519">  gtk_style_context_lookup_color(ctx, &quot;graph_fg_active&quot;, &amp;darktable.bauhaus-&gt;graph_fg_active);</a>
<a name="ln520">  gtk_style_context_lookup_color(ctx, &quot;inset_histogram&quot;, &amp;darktable.bauhaus-&gt;inset_histogram);</a>
<a name="ln521"> </a>
<a name="ln522">  PangoFontDescription *pfont = 0;</a>
<a name="ln523">  gtk_style_context_get(ctx, GTK_STATE_FLAG_NORMAL, &quot;font&quot;, &amp;pfont, NULL);</a>
<a name="ln524">  gtk_widget_path_free(path);</a>
<a name="ln525"> </a>
<a name="ln526">  darktable.bauhaus-&gt;pango_font_desc = pfont;</a>
<a name="ln527"> </a>
<a name="ln528">  PangoLayout *layout;</a>
<a name="ln529">  cairo_surface_t *cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 128, 128);</a>
<a name="ln530">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln531">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln532">  pango_layout_set_text(layout, &quot;X&quot;, -1);</a>
<a name="ln533">  pango_layout_set_font_description(layout, darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln534">  pango_cairo_context_set_resolution(pango_layout_get_context(layout), darktable.gui-&gt;dpi);</a>
<a name="ln535">  int pango_width, pango_height;</a>
<a name="ln536">  pango_layout_get_size(layout, &amp;pango_width, &amp;pango_height);</a>
<a name="ln537">  g_object_unref(layout);</a>
<a name="ln538">  cairo_destroy(cr);</a>
<a name="ln539">  cairo_surface_destroy(cst);</a>
<a name="ln540"> </a>
<a name="ln541">  darktable.bauhaus-&gt;scale = 1.3f;</a>
<a name="ln542">  darktable.bauhaus-&gt;line_height = pango_height / PANGO_SCALE;</a>
<a name="ln543">  darktable.bauhaus-&gt;widget_space = INNER_PADDING / 2.0f; // used as a top/bottom margin for widgets</a>
<a name="ln544">  darktable.bauhaus-&gt;quad_width = darktable.bauhaus-&gt;line_height;</a>
<a name="ln545"> </a>
<a name="ln546">  darktable.bauhaus-&gt;baseline_size = darktable.bauhaus-&gt;line_height / 2.0f; // absolute size in Cairo unit</a>
<a name="ln547">  darktable.bauhaus-&gt;border_width = 3.0f; // absolute size in Cairo unit</a>
<a name="ln548">  darktable.bauhaus-&gt;marker_size = (darktable.bauhaus-&gt;baseline_size + darktable.bauhaus-&gt;border_width) * 0.75f;</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">void dt_bauhaus_init()</a>
<a name="ln552">{</a>
<a name="ln553">  darktable.bauhaus = (dt_bauhaus_t *)calloc(1, sizeof(dt_bauhaus_t));</a>
<a name="ln554">  darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln555">  darktable.bauhaus-&gt;current = NULL;</a>
<a name="ln556">  darktable.bauhaus-&gt;popup_area = gtk_drawing_area_new();</a>
<a name="ln557">  gtk_widget_set_name(darktable.bauhaus-&gt;popup_area, &quot;bauhaus-popup&quot;);</a>
<a name="ln558"> </a>
<a name="ln559">  dt_bauhaus_load_theme();</a>
<a name="ln560"> </a>
<a name="ln561">  // keys are freed with g_free, values are ptrs to the widgets, these don't need to be cleaned up.</a>
<a name="ln562">  darktable.bauhaus-&gt;keymap = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);</a>
<a name="ln563">  darktable.bauhaus-&gt;key_mod = NULL;</a>
<a name="ln564">  darktable.bauhaus-&gt;key_val = NULL;</a>
<a name="ln565">  memset(darktable.bauhaus-&gt;key_history, 0, sizeof(darktable.bauhaus-&gt;key_history));</a>
<a name="ln566"> </a>
<a name="ln567">  // this easily gets keyboard input:</a>
<a name="ln568">  // darktable.bauhaus-&gt;popup_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</a>
<a name="ln569">  // but this doesn't flicker, and the above hack with key input seems to work well.</a>
<a name="ln570">  darktable.bauhaus-&gt;popup_window = gtk_window_new(GTK_WINDOW_POPUP);</a>
<a name="ln571">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln572">  dt_osx_disallow_fullscreen(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln573">#endif</a>
<a name="ln574">  // this is needed for popup, not for toplevel.</a>
<a name="ln575">  // since popup_area gets the focus if we show the window, this is all</a>
<a name="ln576">  // we need.</a>
<a name="ln577">  dt_gui_key_accel_block_on_focus_connect(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln578"> </a>
<a name="ln579">  gtk_widget_set_size_request(darktable.bauhaus-&gt;popup_area, DT_PIXEL_APPLY_DPI(300), DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln580">  gtk_window_set_resizable(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), FALSE);</a>
<a name="ln581">  gtk_window_set_default_size(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), 260, 260);</a>
<a name="ln582">  // gtk_window_set_modal(GTK_WINDOW(c-&gt;popup_window), TRUE);</a>
<a name="ln583">  // gtk_window_set_decorated(GTK_WINDOW(c-&gt;popup_window), FALSE);</a>
<a name="ln584"> </a>
<a name="ln585">  // for pie menu:</a>
<a name="ln586">  // gtk_window_set_position(GTK_WINDOW(c-&gt;popup_window), GTK_WIN_POS_MOUSE);// | GTK_WIN_POS_CENTER);</a>
<a name="ln587"> </a>
<a name="ln588">  // gtk_window_set_keep_above isn't enough on OS X</a>
<a name="ln589">  gtk_window_set_transient_for(GTK_WINDOW(darktable.bauhaus-&gt;popup_window),</a>
<a name="ln590">                               GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)));</a>
<a name="ln591">  gtk_container_add(GTK_CONTAINER(darktable.bauhaus-&gt;popup_window), darktable.bauhaus-&gt;popup_area);</a>
<a name="ln592">  // gtk_window_set_title(GTK_WINDOW(c-&gt;popup_window), _(&quot;dtgtk control popup&quot;));</a>
<a name="ln593">  gtk_window_set_keep_above(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), TRUE);</a>
<a name="ln594">  gtk_window_set_gravity(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), GDK_GRAVITY_STATIC);</a>
<a name="ln595"> </a>
<a name="ln596">  gtk_widget_set_can_focus(darktable.bauhaus-&gt;popup_area, TRUE);</a>
<a name="ln597">  gtk_widget_add_events(darktable.bauhaus-&gt;popup_area, GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln598">                                                       | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln599">                                                       | GDK_KEY_PRESS_MASK | GDK_LEAVE_NOTIFY_MASK</a>
<a name="ln600">                                                       | darktable.gui-&gt;scroll_mask);</a>
<a name="ln601"> </a>
<a name="ln602">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_window), &quot;show&quot;, G_CALLBACK(dt_bauhaus_window_show), (gpointer)NULL);</a>
<a name="ln603">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;draw&quot;, G_CALLBACK(dt_bauhaus_popup_draw),</a>
<a name="ln604">                   (gpointer)NULL);</a>
<a name="ln605">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_window), &quot;motion-notify-event&quot;,</a>
<a name="ln606">                   G_CALLBACK(dt_bauhaus_window_motion_notify), (gpointer)NULL);</a>
<a name="ln607">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_window), &quot;button-press-event&quot;, G_CALLBACK(dt_bauhaus_window_button_press),</a>
<a name="ln608">                   (gpointer)NULL);</a>
<a name="ln609">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;motion-notify-event&quot;,</a>
<a name="ln610">                   G_CALLBACK(dt_bauhaus_popup_motion_notify), (gpointer)NULL);</a>
<a name="ln611">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;leave-notify-event&quot;,</a>
<a name="ln612">                   G_CALLBACK(dt_bauhaus_popup_leave_notify), (gpointer)NULL);</a>
<a name="ln613">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;button-press-event&quot;,</a>
<a name="ln614">                   G_CALLBACK(dt_bauhaus_popup_button_press), (gpointer)NULL);</a>
<a name="ln615">  // this is connected to the widget itself, not the popup. we're only interested</a>
<a name="ln616">  // in mouse release events that are initiated by a press on the original widget.</a>
<a name="ln617">  g_signal_connect (G_OBJECT (darktable.bauhaus-&gt;popup_area), &quot;button-release-event&quot;,</a>
<a name="ln618">                    G_CALLBACK (dt_bauhaus_popup_button_release), (gpointer)NULL);</a>
<a name="ln619">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;key-press-event&quot;,</a>
<a name="ln620">                   G_CALLBACK(dt_bauhaus_popup_key_press), (gpointer)NULL);</a>
<a name="ln621">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;scroll-event&quot;,</a>
<a name="ln622">                   G_CALLBACK(dt_bauhaus_popup_scroll), (gpointer)NULL);</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">void dt_bauhaus_cleanup()</a>
<a name="ln626">{</a>
<a name="ln627">  // TODO: destroy popup window and resources</a>
<a name="ln628">  // TODO: destroy keymap hash table!</a>
<a name="ln629">  g_list_free_full(darktable.bauhaus-&gt;key_mod, (GDestroyNotify)g_free);</a>
<a name="ln630">  g_list_free_full(darktable.bauhaus-&gt;key_val, (GDestroyNotify)g_free);</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">// fwd declare a few callbacks</a>
<a name="ln634">static gboolean dt_bauhaus_slider_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln635">static gboolean dt_bauhaus_slider_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln636">static gboolean dt_bauhaus_slider_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data);</a>
<a name="ln637">static gboolean dt_bauhaus_slider_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);</a>
<a name="ln638">static gboolean dt_bauhaus_slider_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data);</a>
<a name="ln639"> </a>
<a name="ln640"> </a>
<a name="ln641">static gboolean dt_bauhaus_combobox_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln642">static gboolean dt_bauhaus_combobox_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data);</a>
<a name="ln643">static gboolean dt_bauhaus_combobox_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);</a>
<a name="ln644"> </a>
<a name="ln645">// static gboolean</a>
<a name="ln646">// dt_bauhaus_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln647">static gboolean dt_bauhaus_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data);</a>
<a name="ln648"> </a>
<a name="ln649"> </a>
<a name="ln650">// end static init/cleanup</a>
<a name="ln651">// =================================================</a>
<a name="ln652"> </a>
<a name="ln653"> </a>
<a name="ln654"> </a>
<a name="ln655">// common initialization</a>
<a name="ln656">static void dt_bauhaus_widget_init(dt_bauhaus_widget_t *w, dt_iop_module_t *self)</a>
<a name="ln657">{</a>
<a name="ln658">  w-&gt;module = self;</a>
<a name="ln659"> </a>
<a name="ln660">  // no quad icon and no toggle button:</a>
<a name="ln661">  w-&gt;quad_paint = 0;</a>
<a name="ln662">  w-&gt;quad_paint_data = NULL;</a>
<a name="ln663">  w-&gt;quad_toggle = 0;</a>
<a name="ln664">  w-&gt;combo_populate = NULL;</a>
<a name="ln665"> </a>
<a name="ln666"> </a>
<a name="ln667">  switch(w-&gt;type)</a>
<a name="ln668">  {</a>
<a name="ln669">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln670">    {</a>
<a name="ln671">      gtk_widget_set_name(GTK_WIDGET(w), &quot;bauhaus-slider&quot;);</a>
<a name="ln672">      gtk_widget_set_size_request(GTK_WIDGET(w), -1, 2 * darktable.bauhaus-&gt;widget_space + INNER_PADDING + darktable.bauhaus-&gt;baseline_size + get_line_height() - darktable.bauhaus-&gt;border_width / 2.0f);</a>
<a name="ln673">      break;</a>
<a name="ln674">    }</a>
<a name="ln675">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln676">    {</a>
<a name="ln677">      gtk_widget_set_name(GTK_WIDGET(w), &quot;bauhaus-combobox&quot;);</a>
<a name="ln678">      gtk_widget_set_size_request(GTK_WIDGET(w), -1, 2 * darktable.bauhaus-&gt;widget_space + get_line_height());</a>
<a name="ln679">      break;</a>
<a name="ln680">    }</a>
<a name="ln681">  }</a>
<a name="ln682"> </a>
<a name="ln683">  gtk_widget_add_events(GTK_WIDGET(w), GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln684">                                       | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln685">                                       | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK</a>
<a name="ln686">                                       | GDK_FOCUS_CHANGE_MASK</a>
<a name="ln687">                                       | darktable.gui-&gt;scroll_mask);</a>
<a name="ln688"> </a>
<a name="ln689">  g_signal_connect(G_OBJECT(w), &quot;draw&quot;, G_CALLBACK(dt_bauhaus_draw), NULL);</a>
<a name="ln690"> </a>
<a name="ln691">  // for combobox, where mouse-release triggers a selection, we need to catch this</a>
<a name="ln692">  // event where the mouse-press occurred, which will be this widget. we just pass</a>
<a name="ln693">  // it on though:</a>
<a name="ln694">  // g_signal_connect (G_OBJECT (w), &quot;button-release-event&quot;,</a>
<a name="ln695">  //                   G_CALLBACK (dt_bauhaus_popup_button_release), (gpointer)NULL);</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">void dt_bauhaus_combobox_set_default(GtkWidget *widget, int def)</a>
<a name="ln699">{</a>
<a name="ln700">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln701">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln702">  d-&gt;defpos = def;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">int dt_bauhaus_combobox_get_default(GtkWidget *widget)</a>
<a name="ln706">{</a>
<a name="ln707">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln708">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln709">  return d-&gt;defpos;</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712">void dt_bauhaus_slider_set_hard_min(GtkWidget* widget, float val)</a>
<a name="ln713">{</a>
<a name="ln714">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln715">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln716">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln717">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln718">  d-&gt;hard_min = rawval;</a>
<a name="ln719">  d-&gt;min = MAX(d-&gt;min, d-&gt;hard_min);</a>
<a name="ln720">  d-&gt;soft_min = MAX(d-&gt;soft_min, d-&gt;hard_min);</a>
<a name="ln721">  if(rawval &gt; d-&gt;hard_max) dt_bauhaus_slider_set_hard_max(widget,val);</a>
<a name="ln722">  if(pos &lt; val)</a>
<a name="ln723">  {</a>
<a name="ln724">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln725">  }</a>
<a name="ln726">  else</a>
<a name="ln727">  {</a>
<a name="ln728">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln729">  }</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">float dt_bauhaus_slider_get_hard_min(GtkWidget* widget)</a>
<a name="ln733">{</a>
<a name="ln734">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln735">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln736">  return d-&gt;callback(widget, d-&gt;hard_min, DT_BAUHAUS_GET);</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">void dt_bauhaus_slider_set_hard_max(GtkWidget* widget, float val)</a>
<a name="ln740">{</a>
<a name="ln741">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln742">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln743">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln744">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln745">  d-&gt;hard_max = rawval;</a>
<a name="ln746">  d-&gt;max = MIN(d-&gt;max, d-&gt;hard_max);</a>
<a name="ln747">  d-&gt;soft_max = MIN(d-&gt;soft_max, d-&gt;hard_max);</a>
<a name="ln748">  if(rawval &lt; d-&gt;hard_min) dt_bauhaus_slider_set_hard_min(widget,val);</a>
<a name="ln749">  if(pos &gt; val) {</a>
<a name="ln750">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln751">  }</a>
<a name="ln752">  else</a>
<a name="ln753">  {</a>
<a name="ln754">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln755">  }</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758">float dt_bauhaus_slider_get_hard_max(GtkWidget* widget)</a>
<a name="ln759">{</a>
<a name="ln760">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln761">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln762">  return d-&gt;callback(widget, d-&gt;hard_max, DT_BAUHAUS_GET);</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">void dt_bauhaus_slider_set_soft_min(GtkWidget* widget, float val)</a>
<a name="ln766">{</a>
<a name="ln767">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln768">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln769">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln770">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln771">  d-&gt;soft_min = rawval;</a>
<a name="ln772">  d-&gt;hard_min = MIN(d-&gt;hard_min,d-&gt;soft_min);</a>
<a name="ln773">  d-&gt;min =  d-&gt;soft_min;</a>
<a name="ln774">  if(rawval &gt; d-&gt;soft_max) dt_bauhaus_slider_set_soft_max(widget,val);</a>
<a name="ln775">  if(rawval &gt; d-&gt;hard_max) dt_bauhaus_slider_set_hard_max(widget,val);</a>
<a name="ln776">  if(pos &lt; val)</a>
<a name="ln777">  {</a>
<a name="ln778">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln779">  }</a>
<a name="ln780">  else</a>
<a name="ln781">  {</a>
<a name="ln782">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln783">  }</a>
<a name="ln784">}</a>
<a name="ln785"> </a>
<a name="ln786">float dt_bauhaus_slider_get_soft_min(GtkWidget* widget)</a>
<a name="ln787">{</a>
<a name="ln788">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln789">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln790">  return d-&gt;callback(widget, d-&gt;soft_min, DT_BAUHAUS_GET);</a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793">void dt_bauhaus_slider_set_soft_max(GtkWidget* widget, float val)</a>
<a name="ln794">{</a>
<a name="ln795">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln796">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln797">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln798">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln799">  d-&gt;soft_max = rawval;</a>
<a name="ln800">  d-&gt;hard_max = MAX(d-&gt;soft_max, d-&gt;hard_max);</a>
<a name="ln801">  d-&gt;max =  d-&gt;soft_max;</a>
<a name="ln802">  if(rawval &lt; d-&gt;soft_min) dt_bauhaus_slider_set_soft_min(widget,val);</a>
<a name="ln803">  if(rawval &lt; d-&gt;hard_min) dt_bauhaus_slider_set_hard_min(widget,val);</a>
<a name="ln804">  if(pos &gt; val) {</a>
<a name="ln805">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln806">  } else {</a>
<a name="ln807">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln808">  }</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">float dt_bauhaus_slider_get_soft_max(GtkWidget* widget)</a>
<a name="ln812">{</a>
<a name="ln813">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln814">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln815">  return d-&gt;callback(widget, d-&gt;soft_max, DT_BAUHAUS_GET);</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">void dt_bauhaus_slider_set_default(GtkWidget *widget, float def)</a>
<a name="ln819">{</a>
<a name="ln820">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln821">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln822">  float val = d-&gt;callback(widget, def, DT_BAUHAUS_SET);</a>
<a name="ln823">  d-&gt;defpos = (val - d-&gt;min) / (d-&gt;max - d-&gt;min);</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">void dt_bauhaus_slider_enable_soft_boundaries(GtkWidget *widget, float hard_min, float hard_max)</a>
<a name="ln827">{</a>
<a name="ln828">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln829">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln830">  d-&gt;hard_min = d-&gt;callback(widget, hard_min, DT_BAUHAUS_SET);</a>
<a name="ln831">  d-&gt;hard_max = d-&gt;callback(widget, hard_max, DT_BAUHAUS_SET);</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">void dt_bauhaus_widget_set_label(GtkWidget *widget, const char *section, const char *label)</a>
<a name="ln835">{</a>
<a name="ln836">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln837">  memset(w-&gt;label, 0, sizeof(w-&gt;label)); // keep valgrind happy</a>
<a name="ln838">  g_strlcpy(w-&gt;label, label, sizeof(w-&gt;label));</a>
<a name="ln839"> </a>
<a name="ln840">  if(w-&gt;module)</a>
<a name="ln841">  {</a>
<a name="ln842">    // construct control path name and insert into keymap:</a>
<a name="ln843">    gchar *path;</a>
<a name="ln844">    if(section &amp;&amp; section[0] != '\0')</a>
<a name="ln845">    {</a>
<a name="ln846">      path = g_strdup_printf(&quot;%s.%s.%s&quot;, w-&gt;module-&gt;name(), section, w-&gt;label);</a>
<a name="ln847">      gchar *section_path = g_strdup_printf(&quot;%s.%s&quot;, w-&gt;module-&gt;name(), section);</a>
<a name="ln848">      if(!g_list_find_custom(darktable.bauhaus-&gt;key_val, section_path, (GCompareFunc)strcmp))</a>
<a name="ln849">        darktable.bauhaus-&gt;key_val</a>
<a name="ln850">            = g_list_insert_sorted(darktable.bauhaus-&gt;key_val, section_path, (GCompareFunc)strcmp);</a>
<a name="ln851">      else</a>
<a name="ln852">        g_free(section_path);</a>
<a name="ln853">    }</a>
<a name="ln854">    else</a>
<a name="ln855">      path = g_strdup_printf(&quot;%s.%s&quot;, w-&gt;module-&gt;name(), w-&gt;label);</a>
<a name="ln856">    if(!g_hash_table_lookup(darktable.bauhaus-&gt;keymap, path))</a>
<a name="ln857">    {</a>
<a name="ln858">      // also insert into sorted tab-complete list.</a>
<a name="ln859">      // (but only if this is the first time we insert this path)</a>
<a name="ln860">      gchar *mod = g_strdup(path);</a>
<a name="ln861">      gchar *val = g_strstr_len(mod, strlen(mod), &quot;.&quot;);</a>
<a name="ln862">      if(val)</a>
<a name="ln863">      {</a>
<a name="ln864">        *val = 0;</a>
<a name="ln865">        if(!g_list_find_custom(darktable.bauhaus-&gt;key_mod, mod, (GCompareFunc)strcmp))</a>
<a name="ln866">          darktable.bauhaus-&gt;key_mod</a>
<a name="ln867">              = g_list_insert_sorted(darktable.bauhaus-&gt;key_mod, mod, (GCompareFunc)strcmp);</a>
<a name="ln868">        else</a>
<a name="ln869">          g_free(mod);</a>
<a name="ln870"> </a>
<a name="ln871">        // unfortunately need our own string, as replace in the hashtable below might destroy this pointer.</a>
<a name="ln872">        darktable.bauhaus-&gt;key_val</a>
<a name="ln873">            = g_list_insert_sorted(darktable.bauhaus-&gt;key_val, g_strdup(path), (GCompareFunc)strcmp);</a>
<a name="ln874">      }</a>
<a name="ln875">    }</a>
<a name="ln876">    // might free an old path</a>
<a name="ln877">    g_hash_table_replace(darktable.bauhaus-&gt;keymap, path, w);</a>
<a name="ln878">    gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln879">  }</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">const char* dt_bauhaus_widget_get_label(GtkWidget *widget)</a>
<a name="ln883">{</a>
<a name="ln884">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln885">  return w-&gt;label;</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">void dt_bauhaus_widget_set_quad_paint(GtkWidget *widget, dt_bauhaus_quad_paint_f f, int paint_flags, void *paint_data)</a>
<a name="ln889">{</a>
<a name="ln890">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln891">  w-&gt;quad_paint = f;</a>
<a name="ln892">  w-&gt;quad_paint_flags = paint_flags;</a>
<a name="ln893">  w-&gt;quad_paint_data = paint_data;</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896">// make this quad a toggle button:</a>
<a name="ln897">void dt_bauhaus_widget_set_quad_toggle(GtkWidget *widget, int toggle)</a>
<a name="ln898">{</a>
<a name="ln899">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln900">  w-&gt;quad_toggle = toggle;</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">void dt_bauhaus_widget_set_quad_active(GtkWidget *widget, int active)</a>
<a name="ln904">{</a>
<a name="ln905">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln906">  if (active)</a>
<a name="ln907">    w-&gt;quad_paint_flags |= CPF_ACTIVE;</a>
<a name="ln908">  else</a>
<a name="ln909">    w-&gt;quad_paint_flags &amp;= ~CPF_ACTIVE;</a>
<a name="ln910">  gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln911">}</a>
<a name="ln912"> </a>
<a name="ln913">int dt_bauhaus_widget_get_quad_active(GtkWidget *widget)</a>
<a name="ln914">{</a>
<a name="ln915">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln916">  return (w-&gt;quad_paint_flags &amp; CPF_ACTIVE) == CPF_ACTIVE;</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">static float _default_linear_callback(GtkWidget *self, float value, dt_bauhaus_callback_t dir)</a>
<a name="ln920">{</a>
<a name="ln921">  // regardless of dir: input &lt;-&gt; output</a>
<a name="ln922">  return value;</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">static void dt_bauhaus_slider_destroy(dt_bauhaus_widget_t *widget, gpointer user_data)</a>
<a name="ln926">{</a>
<a name="ln927">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln928">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln929">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln930">  if(d-&gt;timeout_handle) g_source_remove(d-&gt;timeout_handle);</a>
<a name="ln931">  d-&gt;timeout_handle = 0;</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934">GtkWidget *dt_bauhaus_slider_new(dt_iop_module_t *self)</a>
<a name="ln935">{</a>
<a name="ln936">  return dt_bauhaus_slider_new_with_range(self, 0.0, 1.0, 0.1, 0.5, 3);</a>
<a name="ln937">}</a>
<a name="ln938"> </a>
<a name="ln939">GtkWidget *dt_bauhaus_slider_new_with_range(dt_iop_module_t *self, float min, float max, float step,</a>
<a name="ln940">                                            float defval, int digits)</a>
<a name="ln941">{</a>
<a name="ln942">  return dt_bauhaus_slider_new_with_range_and_feedback(self, min, max, step, defval, digits, 1);</a>
<a name="ln943">}</a>
<a name="ln944"> </a>
<a name="ln945">GtkWidget *dt_bauhaus_slider_new_with_range_and_feedback(dt_iop_module_t *self, float min, float max,</a>
<a name="ln946">                                                         float step, float defval, int digits, int feedback)</a>
<a name="ln947">{</a>
<a name="ln948">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(g_object_new(DT_BAUHAUS_WIDGET_TYPE, NULL));</a>
<a name="ln949">  return dt_bauhaus_slider_from_widget(w,self, min, max, step, defval, digits, feedback);</a>
<a name="ln950">}</a>
<a name="ln951">GtkWidget *dt_bauhaus_slider_from_widget(dt_bauhaus_widget_t* w,dt_iop_module_t *self, float min, float max,</a>
<a name="ln952">                                                         float step, float defval, int digits, int feedback)</a>
<a name="ln953">{</a>
<a name="ln954">  w-&gt;type = DT_BAUHAUS_SLIDER;</a>
<a name="ln955">  dt_bauhaus_widget_init(w, self);</a>
<a name="ln956">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln957">  d-&gt;min = d-&gt;soft_min = d-&gt;hard_min = min;</a>
<a name="ln958">  d-&gt;max = d-&gt;soft_max = d-&gt;hard_max = max;</a>
<a name="ln959">  d-&gt;step = step;</a>
<a name="ln960">  // normalize default:</a>
<a name="ln961">  d-&gt;defpos = (defval - min) / (max - min);</a>
<a name="ln962">  d-&gt;pos = d-&gt;defpos;</a>
<a name="ln963">  d-&gt;oldpos = d-&gt;defpos;</a>
<a name="ln964">  d-&gt;scale = 5.0f * step / (max - min);</a>
<a name="ln965">  d-&gt;digits = digits;</a>
<a name="ln966">  snprintf(d-&gt;format, sizeof(d-&gt;format), &quot;%%.0%df&quot;, digits);</a>
<a name="ln967"> </a>
<a name="ln968">  d-&gt;grad_cnt = 0;</a>
<a name="ln969"> </a>
<a name="ln970">  d-&gt;fill_feedback = feedback;</a>
<a name="ln971"> </a>
<a name="ln972">  d-&gt;is_dragging = 0;</a>
<a name="ln973">  d-&gt;is_changed = 0;</a>
<a name="ln974">  d-&gt;timeout_handle = 0;</a>
<a name="ln975">  d-&gt;callback = _default_linear_callback;</a>
<a name="ln976"> </a>
<a name="ln977">  gtk_widget_add_events(GTK_WIDGET(w), GDK_KEY_PRESS_MASK);</a>
<a name="ln978">  gtk_widget_set_can_focus(GTK_WIDGET(w), TRUE);</a>
<a name="ln979"> </a>
<a name="ln980">  g_signal_connect(G_OBJECT(w), &quot;button-press-event&quot;, G_CALLBACK(dt_bauhaus_slider_button_press),</a>
<a name="ln981">                   (gpointer)NULL);</a>
<a name="ln982">  g_signal_connect(G_OBJECT(w), &quot;button-release-event&quot;, G_CALLBACK(dt_bauhaus_slider_button_release),</a>
<a name="ln983">                   (gpointer)NULL);</a>
<a name="ln984">  g_signal_connect(G_OBJECT(w), &quot;scroll-event&quot;, G_CALLBACK(dt_bauhaus_slider_scroll), (gpointer)NULL);</a>
<a name="ln985">  g_signal_connect(G_OBJECT(w), &quot;key-press-event&quot;, G_CALLBACK(dt_bauhaus_slider_key_press), (gpointer)NULL);</a>
<a name="ln986">  g_signal_connect(G_OBJECT(w), &quot;motion-notify-event&quot;, G_CALLBACK(dt_bauhaus_slider_motion_notify),</a>
<a name="ln987">                   (gpointer)NULL);</a>
<a name="ln988">  g_signal_connect(G_OBJECT(w), &quot;destroy&quot;, G_CALLBACK(dt_bauhaus_slider_destroy), (gpointer)NULL);</a>
<a name="ln989">  return GTK_WIDGET(w);</a>
<a name="ln990">}</a>
<a name="ln991"> </a>
<a name="ln992">static void dt_bauhaus_combobox_destroy(dt_bauhaus_widget_t *widget, gpointer user_data)</a>
<a name="ln993">{</a>
<a name="ln994">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln995">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln996">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln997">  g_list_free_full(d-&gt;entries, free_combobox_entry);</a>
<a name="ln998">  d-&gt;entries = NULL;</a>
<a name="ln999">  d-&gt;num_labels = 0;</a>
<a name="ln1000">  d-&gt;active = -1;</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003">GtkWidget *dt_bauhaus_combobox_new(dt_iop_module_t *self)</a>
<a name="ln1004">{</a>
<a name="ln1005">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(g_object_new(DT_BAUHAUS_WIDGET_TYPE, NULL));</a>
<a name="ln1006">  dt_bauhaus_combobox_from_widget(w,self);</a>
<a name="ln1007">  return GTK_WIDGET(w);</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010">void dt_bauhaus_combobox_from_widget(dt_bauhaus_widget_t* w,dt_iop_module_t *self)</a>
<a name="ln1011">{</a>
<a name="ln1012">  w-&gt;type = DT_BAUHAUS_COMBOBOX;</a>
<a name="ln1013">  dt_bauhaus_widget_init(w, self);</a>
<a name="ln1014">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1015">  d-&gt;entries = NULL;</a>
<a name="ln1016">  d-&gt;num_labels = 0;</a>
<a name="ln1017">  d-&gt;defpos = 0;</a>
<a name="ln1018">  d-&gt;active = -1;</a>
<a name="ln1019">  d-&gt;editable = 0;</a>
<a name="ln1020">  memset(d-&gt;text, 0, sizeof(d-&gt;text));</a>
<a name="ln1021"> </a>
<a name="ln1022">  gtk_widget_add_events(GTK_WIDGET(w), GDK_KEY_PRESS_MASK);</a>
<a name="ln1023">  gtk_widget_set_can_focus(GTK_WIDGET(w), TRUE);</a>
<a name="ln1024"> </a>
<a name="ln1025">  g_signal_connect(G_OBJECT(w), &quot;button-press-event&quot;, G_CALLBACK(dt_bauhaus_combobox_button_press),</a>
<a name="ln1026">                   (gpointer)NULL);</a>
<a name="ln1027">  g_signal_connect(G_OBJECT(w), &quot;button-release-event&quot;, G_CALLBACK(dt_bauhaus_popup_button_release),</a>
<a name="ln1028">                   (gpointer)NULL);</a>
<a name="ln1029">  g_signal_connect(G_OBJECT(w), &quot;scroll-event&quot;, G_CALLBACK(dt_bauhaus_combobox_scroll), (gpointer)NULL);</a>
<a name="ln1030">  g_signal_connect(G_OBJECT(w), &quot;key-press-event&quot;, G_CALLBACK(dt_bauhaus_combobox_key_press), (gpointer)NULL);</a>
<a name="ln1031">  g_signal_connect(G_OBJECT(w), &quot;destroy&quot;, G_CALLBACK(dt_bauhaus_combobox_destroy), (gpointer)NULL);</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034">void dt_bauhaus_combobox_add_populate_fct(GtkWidget *widget, void (*fct)(GtkWidget *w, struct dt_iop_module_t **module))</a>
<a name="ln1035">{</a>
<a name="ln1036">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1037">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1038">  w-&gt;combo_populate = fct;</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041">void dt_bauhaus_combobox_add(GtkWidget *widget, const char *text)</a>
<a name="ln1042">{</a>
<a name="ln1043">  dt_bauhaus_combobox_add_full(widget, text, DT_BAUHAUS_COMBOBOX_ALIGN_RIGHT, NULL, NULL);</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046">void dt_bauhaus_combobox_add_aligned(GtkWidget *widget, const char *text, dt_bauhaus_combobox_alignment_t align)</a>
<a name="ln1047">{</a>
<a name="ln1048">  dt_bauhaus_combobox_add_full(widget, text, align, NULL, NULL);</a>
<a name="ln1049">}</a>
<a name="ln1050"> </a>
<a name="ln1051">void dt_bauhaus_combobox_add_full(GtkWidget *widget, const char *text, dt_bauhaus_combobox_alignment_t align,</a>
<a name="ln1052">                                  gpointer data, void (free_func)(void *data))</a>
<a name="ln1053">{</a>
<a name="ln1054">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1055">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1056">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1057">  d-&gt;num_labels++;</a>
<a name="ln1058">  dt_bauhaus_combobox_entry_t *entry = new_combobox_entry(text, align, TRUE, data, free_func);</a>
<a name="ln1059">  d-&gt;entries = g_list_append(d-&gt;entries, entry);</a>
<a name="ln1060">  if(d-&gt;active &lt; 0) d-&gt;active = 0;</a>
<a name="ln1061">}</a>
<a name="ln1062"> </a>
<a name="ln1063">void dt_bauhaus_combobox_set_editable(GtkWidget *widget, int editable)</a>
<a name="ln1064">{</a>
<a name="ln1065">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1066">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1067">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1068">  d-&gt;editable = editable ? 1 : 0;</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071">int dt_bauhaus_combobox_get_editable(GtkWidget *widget)</a>
<a name="ln1072">{</a>
<a name="ln1073">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1074">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return 0;</a>
<a name="ln1075">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1076">  return d-&gt;editable;</a>
<a name="ln1077">}</a>
<a name="ln1078"> </a>
<a name="ln1079">void dt_bauhaus_combobox_remove_at(GtkWidget *widget, int pos)</a>
<a name="ln1080">{</a>
<a name="ln1081">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1082">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1083">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1084"> </a>
<a name="ln1085">  if(pos &lt; 0 || pos &gt;= d-&gt;num_labels) return;</a>
<a name="ln1086"> </a>
<a name="ln1087">  // move active position up if removing anything before it</a>
<a name="ln1088">  // or when removing last position that is currently active.</a>
<a name="ln1089">  // this also sets active to -1 when removing the last remaining entry in a combobox.</a>
<a name="ln1090">  if(d-&gt;active &gt; pos) d-&gt;active--;</a>
<a name="ln1091">  else if((d-&gt;active == pos) &amp;&amp; (d-&gt;active &gt;= d-&gt;num_labels-1))</a>
<a name="ln1092">    d-&gt;active = d-&gt;num_labels-2;</a>
<a name="ln1093"> </a>
<a name="ln1094">  GList *rm = g_list_nth(d-&gt;entries, pos);</a>
<a name="ln1095">  free_combobox_entry(rm-&gt;data);</a>
<a name="ln1096">  d-&gt;entries = g_list_delete_link(d-&gt;entries, rm);</a>
<a name="ln1097"> </a>
<a name="ln1098">  d-&gt;num_labels--;</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">void dt_bauhaus_combobox_insert(GtkWidget *widget, const char *text,int pos)</a>
<a name="ln1102">{</a>
<a name="ln1103">  dt_bauhaus_combobox_insert_full(widget, text, DT_BAUHAUS_COMBOBOX_ALIGN_RIGHT, NULL, NULL, pos);</a>
<a name="ln1104">}</a>
<a name="ln1105"> </a>
<a name="ln1106">void dt_bauhaus_combobox_insert_full(GtkWidget *widget, const char *text, dt_bauhaus_combobox_alignment_t align,</a>
<a name="ln1107">                                     gpointer data, void (*free_func)(void *), int pos)</a>
<a name="ln1108">{</a>
<a name="ln1109">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1110">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1111">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1112">  d-&gt;num_labels++;</a>
<a name="ln1113">  d-&gt;entries = g_list_insert(d-&gt;entries, new_combobox_entry(text, align, TRUE, data, free_func), pos);</a>
<a name="ln1114">  if(d-&gt;active &lt; 0) d-&gt;active = 0;</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117">int dt_bauhaus_combobox_length(GtkWidget *widget)</a>
<a name="ln1118">{</a>
<a name="ln1119">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1120">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return 0;</a>
<a name="ln1121">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1122"> </a>
<a name="ln1123">  return d-&gt;num_labels;</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">const char *dt_bauhaus_combobox_get_text(GtkWidget *widget)</a>
<a name="ln1127">{</a>
<a name="ln1128">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1129">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return NULL;</a>
<a name="ln1130">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1131"> </a>
<a name="ln1132">  if(d-&gt;editable &amp;&amp; d-&gt;active &lt; 0)</a>
<a name="ln1133">  {</a>
<a name="ln1134">    return d-&gt;text;</a>
<a name="ln1135">  }</a>
<a name="ln1136">  else</a>
<a name="ln1137">  {</a>
<a name="ln1138">    if(d-&gt;active &lt; 0 || d-&gt;active &gt;= d-&gt;num_labels) return NULL;</a>
<a name="ln1139">    const dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(d-&gt;entries, d-&gt;active);</a>
<a name="ln1140">    return entry-&gt;label;</a>
<a name="ln1141">  }</a>
<a name="ln1142">  return NULL;</a>
<a name="ln1143">}</a>
<a name="ln1144"> </a>
<a name="ln1145">gpointer dt_bauhaus_combobox_get_data(GtkWidget *widget)</a>
<a name="ln1146">{</a>
<a name="ln1147">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1148">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return NULL;</a>
<a name="ln1149">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1150">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(d-&gt;entries, d-&gt;active);</a>
<a name="ln1151">  return entry ? entry-&gt;data : NULL;</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154">void dt_bauhaus_combobox_clear(GtkWidget *widget)</a>
<a name="ln1155">{</a>
<a name="ln1156">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1157">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1158">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1159">  d-&gt;active = -1;</a>
<a name="ln1160">  g_list_free_full(d-&gt;entries, free_combobox_entry);</a>
<a name="ln1161">  d-&gt;entries = NULL;</a>
<a name="ln1162">  d-&gt;num_labels = 0;</a>
<a name="ln1163">}</a>
<a name="ln1164"> </a>
<a name="ln1165">const GList *dt_bauhaus_combobox_get_entries(GtkWidget *widget)</a>
<a name="ln1166">{</a>
<a name="ln1167">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1168">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return 0;</a>
<a name="ln1169">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1170">  return d-&gt;entries;</a>
<a name="ln1171">}</a>
<a name="ln1172"> </a>
<a name="ln1173">void dt_bauhaus_combobox_set_text(GtkWidget *widget, const char *text)</a>
<a name="ln1174">{</a>
<a name="ln1175">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1176">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1177">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1178">  if(!d-&gt;editable) return;</a>
<a name="ln1179">  g_strlcpy(d-&gt;text, text, sizeof(d-&gt;text));</a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182">void dt_bauhaus_combobox_set(GtkWidget *widget, int pos)</a>
<a name="ln1183">{</a>
<a name="ln1184">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1185">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1186">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1187">  d-&gt;active = CLAMP(pos, -1, d-&gt;num_labels - 1);</a>
<a name="ln1188">  gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln1189">  if(!darktable.gui-&gt;reset) g_signal_emit_by_name(G_OBJECT(w), &quot;value-changed&quot;);</a>
<a name="ln1190">}</a>
<a name="ln1191"> </a>
<a name="ln1192">gboolean dt_bauhaus_combobox_set_from_text(GtkWidget *widget, const char *text)</a>
<a name="ln1193">{</a>
<a name="ln1194">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1195">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln1196">  if(!text) return FALSE;</a>
<a name="ln1197">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1198">  int i = 0;</a>
<a name="ln1199">  for(GList *iter = d-&gt;entries; iter; iter = g_list_next(iter), i++)</a>
<a name="ln1200">  {</a>
<a name="ln1201">    const dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)iter-&gt;data;</a>
<a name="ln1202">    if(!g_strcmp0(entry-&gt;label, text))</a>
<a name="ln1203">    {</a>
<a name="ln1204">      dt_bauhaus_combobox_set(widget, i);</a>
<a name="ln1205">      return TRUE;</a>
<a name="ln1206">    }</a>
<a name="ln1207">  }</a>
<a name="ln1208">  return FALSE;</a>
<a name="ln1209">}</a>
<a name="ln1210"> </a>
<a name="ln1211">int dt_bauhaus_combobox_get(GtkWidget *widget)</a>
<a name="ln1212">{</a>
<a name="ln1213">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1214">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return -1;</a>
<a name="ln1215">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1216">  return d-&gt;active;</a>
<a name="ln1217">}</a>
<a name="ln1218"> </a>
<a name="ln1219">void dt_bauhaus_combobox_entry_set_sensitive(GtkWidget *widget, int pos, gboolean sensitive)</a>
<a name="ln1220">{</a>
<a name="ln1221">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1222">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1223">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1224">  dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)g_list_nth_data(d-&gt;entries, pos);</a>
<a name="ln1225">  if(entry)</a>
<a name="ln1226">    entry-&gt;sensitive = sensitive;</a>
<a name="ln1227">}</a>
<a name="ln1228"> </a>
<a name="ln1229">void dt_bauhaus_slider_clear_stops(GtkWidget *widget)</a>
<a name="ln1230">{</a>
<a name="ln1231">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1232">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1233">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1234">  d-&gt;grad_cnt = 0;</a>
<a name="ln1235">}</a>
<a name="ln1236"> </a>
<a name="ln1237">void dt_bauhaus_slider_set_stop(GtkWidget *widget, float stop, float r, float g, float b)</a>
<a name="ln1238">{</a>
<a name="ln1239">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1240">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1241">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1242">  float rawstop = d-&gt;callback(widget, stop, DT_BAUHAUS_SET);</a>
<a name="ln1243">  // need to replace stop?</a>
<a name="ln1244">  for(int k = 0; k &lt; d-&gt;grad_cnt; k++)</a>
<a name="ln1245">  {</a>
<a name="ln1246">    if(d-&gt;grad_pos[k] == rawstop)</a>
<a name="ln1247">    {</a>
<a name="ln1248">      d-&gt;grad_col[k][0] = r;</a>
<a name="ln1249">      d-&gt;grad_col[k][1] = g;</a>
<a name="ln1250">      d-&gt;grad_col[k][2] = b;</a>
<a name="ln1251">      return;</a>
<a name="ln1252">    }</a>
<a name="ln1253">  }</a>
<a name="ln1254">  // new stop:</a>
<a name="ln1255">  if(d-&gt;grad_cnt &lt; DT_BAUHAUS_SLIDER_MAX_STOPS)</a>
<a name="ln1256">  {</a>
<a name="ln1257">    int k = d-&gt;grad_cnt++;</a>
<a name="ln1258">    d-&gt;grad_pos[k] = rawstop;</a>
<a name="ln1259">    d-&gt;grad_col[k][0] = r;</a>
<a name="ln1260">    d-&gt;grad_col[k][1] = g;</a>
<a name="ln1261">    d-&gt;grad_col[k][2] = b;</a>
<a name="ln1262">  }</a>
<a name="ln1263">  else</a>
<a name="ln1264">  {</a>
<a name="ln1265">    fprintf(stderr, &quot;[bauhaus_slider_set_stop] only %d stops allowed.\n&quot;, DT_BAUHAUS_SLIDER_MAX_STOPS);</a>
<a name="ln1266">  }</a>
<a name="ln1267">}</a>
<a name="ln1268"> </a>
<a name="ln1269"> </a>
<a name="ln1270">static void draw_equilateral_triangle(cairo_t *cr, float radius)</a>
<a name="ln1271">{</a>
<a name="ln1272">  const float sin = 0.866025404 * radius;</a>
<a name="ln1273">  const float cos = 0.5f * radius;</a>
<a name="ln1274">  cairo_move_to(cr, 0.0, radius);</a>
<a name="ln1275">  cairo_line_to(cr, -sin, -cos);</a>
<a name="ln1276">  cairo_line_to(cr, sin, -cos);</a>
<a name="ln1277">  cairo_line_to(cr, 0.0, radius);</a>
<a name="ln1278">}</a>
<a name="ln1279"> </a>
<a name="ln1280"> </a>
<a name="ln1281">static void dt_bauhaus_draw_indicator(dt_bauhaus_widget_t *w, float pos, cairo_t *cr, const GdkRGBA *fg_color, const GdkRGBA *border_color)</a>
<a name="ln1282">{</a>
<a name="ln1283">  // draw scale indicator (the tiny triangle)</a>
<a name="ln1284">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1285">  GtkAllocation allocation;</a>
<a name="ln1286">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1287">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1288">  const float wd = allocation.width;</a>
<a name="ln1289">  const float border_width = darktable.bauhaus-&gt;border_width;</a>
<a name="ln1290">  const float size = darktable.bauhaus-&gt;marker_size;</a>
<a name="ln1291"> </a>
<a name="ln1292">  cairo_save(cr);</a>
<a name="ln1293">  cairo_translate(cr, slider_coordinate(pos, wd), get_line_height() + INNER_PADDING - border_width * 0.25f);</a>
<a name="ln1294">  cairo_scale(cr, 1.0f, -1.0f);</a>
<a name="ln1295">  cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln1296"> </a>
<a name="ln1297">  // draw the outer triangle</a>
<a name="ln1298">  draw_equilateral_triangle(cr, size);</a>
<a name="ln1299">  cairo_set_line_width(cr, border_width);</a>
<a name="ln1300">  set_color(cr, *border_color);</a>
<a name="ln1301">  cairo_stroke(cr);</a>
<a name="ln1302"> </a>
<a name="ln1303">  draw_equilateral_triangle(cr, size - border_width);</a>
<a name="ln1304">  cairo_clip(cr);</a>
<a name="ln1305"> </a>
<a name="ln1306">  // draw the inner triangle</a>
<a name="ln1307">  draw_equilateral_triangle(cr, size - border_width);</a>
<a name="ln1308">  set_color(cr, *fg_color);</a>
<a name="ln1309">  cairo_set_line_width(cr, border_width);</a>
<a name="ln1310"> </a>
<a name="ln1311">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1312"> </a>
<a name="ln1313">  if(d-&gt;fill_feedback)</a>
<a name="ln1314">    cairo_fill(cr); // Plain indicator (regular sliders)</a>
<a name="ln1315">  else</a>
<a name="ln1316">    cairo_stroke(cr);  // Hollow indicator to see a color through it (gradient sliders)</a>
<a name="ln1317"> </a>
<a name="ln1318">  cairo_restore(cr);</a>
<a name="ln1319">}</a>
<a name="ln1320"> </a>
<a name="ln1321">static void dt_bauhaus_draw_quad(dt_bauhaus_widget_t *w, cairo_t *cr)</a>
<a name="ln1322">{</a>
<a name="ln1323">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1324">  const gboolean sensitive = gtk_widget_is_sensitive(GTK_WIDGET(w));</a>
<a name="ln1325">  GtkAllocation allocation;</a>
<a name="ln1326">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1327">  const int width = allocation.width;</a>
<a name="ln1328">  const int height = inner_height(allocation);</a>
<a name="ln1329"> </a>
<a name="ln1330">  if(w-&gt;quad_paint)</a>
<a name="ln1331">  {</a>
<a name="ln1332">    cairo_save(cr);</a>
<a name="ln1333"> </a>
<a name="ln1334">    if(sensitive &amp;&amp; (w-&gt;quad_paint_flags &amp; CPF_ACTIVE))</a>
<a name="ln1335">      set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1336">    else</a>
<a name="ln1337">      set_color(cr, darktable.bauhaus-&gt;color_fg_insensitive);</a>
<a name="ln1338"> </a>
<a name="ln1339">    w-&gt;quad_paint(cr, width - darktable.bauhaus-&gt;quad_width,  // x</a>
<a name="ln1340">                      0.0,        // y</a>
<a name="ln1341">                      darktable.bauhaus-&gt;quad_width,          // width</a>
<a name="ln1342">                      darktable.bauhaus-&gt;quad_width,          // height</a>
<a name="ln1343">                      w-&gt;quad_paint_flags, w-&gt;quad_paint_data);</a>
<a name="ln1344"> </a>
<a name="ln1345">    cairo_restore(cr);</a>
<a name="ln1346">  }</a>
<a name="ln1347">  else</a>
<a name="ln1348">  {</a>
<a name="ln1349">    // draw active area square:</a>
<a name="ln1350">    cairo_save(cr);</a>
<a name="ln1351">    if(sensitive)</a>
<a name="ln1352">      set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1353">    else</a>
<a name="ln1354">      set_color(cr, darktable.bauhaus-&gt;color_fg_insensitive);</a>
<a name="ln1355">    switch(w-&gt;type)</a>
<a name="ln1356">    {</a>
<a name="ln1357">      case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1358">        cairo_translate(cr, width - darktable.bauhaus-&gt;quad_width * .5f, height * .33f);</a>
<a name="ln1359">        draw_equilateral_triangle(cr, darktable.bauhaus-&gt;quad_width * .25f);</a>
<a name="ln1360">        cairo_fill_preserve(cr);</a>
<a name="ln1361">        cairo_set_line_width(cr, 0.5);</a>
<a name="ln1362">        set_color(cr, darktable.bauhaus-&gt;color_border);</a>
<a name="ln1363">        cairo_stroke(cr);</a>
<a name="ln1364">        break;</a>
<a name="ln1365">      case DT_BAUHAUS_SLIDER:</a>
<a name="ln1366">        break;</a>
<a name="ln1367">      default:</a>
<a name="ln1368">        cairo_set_source_rgb(cr, 1.0, 0.0, 0.0);</a>
<a name="ln1369">        cairo_rectangle(cr, width - darktable.bauhaus-&gt;quad_width, 0.0, darktable.bauhaus-&gt;quad_width, darktable.bauhaus-&gt;quad_width);</a>
<a name="ln1370">        cairo_fill(cr);</a>
<a name="ln1371">        break;</a>
<a name="ln1372">    }</a>
<a name="ln1373">    cairo_restore(cr);</a>
<a name="ln1374">  }</a>
<a name="ln1375">}</a>
<a name="ln1376"> </a>
<a name="ln1377">static void dt_bauhaus_draw_baseline(dt_bauhaus_widget_t *w, cairo_t *cr)</a>
<a name="ln1378">{</a>
<a name="ln1379">  // draw line for orientation in slider</a>
<a name="ln1380">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1381">  GtkAllocation allocation;</a>
<a name="ln1382">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1383">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1384">  const int wd = allocation.width;</a>
<a name="ln1385">  const float slider_width = wd - darktable.bauhaus-&gt;quad_width - INNER_PADDING;</a>
<a name="ln1386">  cairo_save(cr);</a>
<a name="ln1387">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1388"> </a>
<a name="ln1389">  // pos of baseline</a>
<a name="ln1390">  const float htm = darktable.bauhaus-&gt;line_height + INNER_PADDING;</a>
<a name="ln1391"> </a>
<a name="ln1392">  // thickness of baseline</a>
<a name="ln1393">  const float htM = darktable.bauhaus-&gt;baseline_size - darktable.bauhaus-&gt;border_width;</a>
<a name="ln1394"> </a>
<a name="ln1395">  // the background of the line</a>
<a name="ln1396">  cairo_pattern_t *gradient = NULL;</a>
<a name="ln1397">  cairo_rectangle(cr, 0, htm, slider_width, htM);</a>
<a name="ln1398"> </a>
<a name="ln1399">  if(d-&gt;grad_cnt &gt; 0)</a>
<a name="ln1400">  {</a>
<a name="ln1401">    // gradient line as used in some modules</a>
<a name="ln1402">    gradient = cairo_pattern_create_linear(0, 0, slider_width, htM);</a>
<a name="ln1403">    for(int k = 0; k &lt; d-&gt;grad_cnt; k++)</a>
<a name="ln1404">      cairo_pattern_add_color_stop_rgba(gradient, d-&gt;grad_pos[k], d-&gt;grad_col[k][0], d-&gt;grad_col[k][1],</a>
<a name="ln1405">                                        d-&gt;grad_col[k][2], 0.4f);</a>
<a name="ln1406">    cairo_set_source(cr, gradient);</a>
<a name="ln1407">  }</a>
<a name="ln1408">  else</a>
<a name="ln1409">  {</a>
<a name="ln1410">    // regular baseline</a>
<a name="ln1411">    set_color(cr, darktable.bauhaus-&gt;color_bg);</a>
<a name="ln1412">  }</a>
<a name="ln1413"> </a>
<a name="ln1414">  cairo_fill(cr);</a>
<a name="ln1415"> </a>
<a name="ln1416">  // get the reference of the slider aka the position of the 0 value</a>
<a name="ln1417">  const float origin = fmaxf(fminf(-(d-&gt;min / (d-&gt;max - d-&gt;min)) * slider_width, slider_width), 0.0f);</a>
<a name="ln1418">  const float position = d-&gt;pos * slider_width;</a>
<a name="ln1419">  const float delta = position - origin;</a>
<a name="ln1420"> </a>
<a name="ln1421">  // have a `fill ratio feel' from zero to current position</a>
<a name="ln1422">  // - but only if set</a>
<a name="ln1423">  if(d-&gt;fill_feedback)</a>
<a name="ln1424">  {</a>
<a name="ln1425">    // only brighten, useful for colored sliders to not get too faint:</a>
<a name="ln1426">    cairo_set_operator(cr, CAIRO_OPERATOR_SCREEN);</a>
<a name="ln1427">    set_color(cr, darktable.bauhaus-&gt;color_fill);</a>
<a name="ln1428">    cairo_rectangle(cr, origin, htm, delta, htM);</a>
<a name="ln1429">    cairo_fill(cr);</a>
<a name="ln1430"> </a>
<a name="ln1431">    // change back to default cairo operator:</a>
<a name="ln1432">    cairo_set_operator(cr, CAIRO_OPERATOR_OVER);</a>
<a name="ln1433">  }</a>
<a name="ln1434"> </a>
<a name="ln1435">  // draw the 0 reference graduation if it's different than the bounds of the slider</a>
<a name="ln1436">  const float graduation_top = htm + htM + 2.0f * darktable.bauhaus-&gt;border_width;</a>
<a name="ln1437">  const float graduation_height = darktable.bauhaus-&gt;border_width / 2.0f;</a>
<a name="ln1438">  set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1439"> </a>
<a name="ln1440">  // If the max of the slider is 180 or 360, it is likely a hue slider in degrees</a>
<a name="ln1441">  // a zero in periodic stuff has not much meaning so we skip it</a>
<a name="ln1442">  if(d-&gt;hard_max != 180.0f &amp;&amp; d-&gt;hard_max != 360.0f)</a>
<a name="ln1443">  {</a>
<a name="ln1444">    // translate the dot if it overflows the widget frame</a>
<a name="ln1445">    if(origin &lt; graduation_height)</a>
<a name="ln1446">      cairo_arc(cr, graduation_height, graduation_top, graduation_height, 0, 2 * M_PI);</a>
<a name="ln1447">    else if(origin &gt; slider_width - graduation_height)</a>
<a name="ln1448">      cairo_arc(cr, slider_width - graduation_height, graduation_top, graduation_height, 0, 2 * M_PI);</a>
<a name="ln1449">    else</a>
<a name="ln1450">      cairo_arc(cr, origin, graduation_top, graduation_height, 0, 2 * M_PI);</a>
<a name="ln1451">}</a>
<a name="ln1452"> </a>
<a name="ln1453">  cairo_fill(cr);</a>
<a name="ln1454">  cairo_restore(cr);</a>
<a name="ln1455"> </a>
<a name="ln1456">  if(d-&gt;grad_cnt &gt; 0) cairo_pattern_destroy(gradient);</a>
<a name="ln1457">}</a>
<a name="ln1458"> </a>
<a name="ln1459">static void dt_bauhaus_widget_reject(dt_bauhaus_widget_t *w)</a>
<a name="ln1460">{</a>
<a name="ln1461">  switch(w-&gt;type)</a>
<a name="ln1462">  {</a>
<a name="ln1463">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1464">      break;</a>
<a name="ln1465">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1466">    {</a>
<a name="ln1467">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1468">      dt_bauhaus_slider_set_normalized(w, d-&gt;oldpos);</a>
<a name="ln1469">    }</a>
<a name="ln1470">    break;</a>
<a name="ln1471">    default:</a>
<a name="ln1472">      break;</a>
<a name="ln1473">  }</a>
<a name="ln1474">}</a>
<a name="ln1475"> </a>
<a name="ln1476">static void dt_bauhaus_widget_accept(dt_bauhaus_widget_t *w)</a>
<a name="ln1477">{</a>
<a name="ln1478">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1479">  GtkAllocation allocation;</a>
<a name="ln1480">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1481">  int base_width = allocation.width, base_height = inner_height(allocation);</a>
<a name="ln1482"> </a>
<a name="ln1483">  GtkAllocation allocation_popup_window;</a>
<a name="ln1484">  gtk_widget_get_allocation(darktable.bauhaus-&gt;popup_window, &amp;allocation_popup_window);</a>
<a name="ln1485"> </a>
<a name="ln1486">  int width = allocation_popup_window.width, height = inner_height(allocation_popup_window);</a>
<a name="ln1487"> </a>
<a name="ln1488">  switch(w-&gt;type)</a>
<a name="ln1489">  {</a>
<a name="ln1490">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1491">    {</a>
<a name="ln1492">      // only set to what's in the filtered list.</a>
<a name="ln1493">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1494">      int active = darktable.bauhaus-&gt;end_mouse_y &gt;= 0</a>
<a name="ln1495">                       ? (darktable.bauhaus-&gt;end_mouse_y / (base_height))</a>
<a name="ln1496">                       : d-&gt;active;</a>
<a name="ln1497">      int k = 0, i = 0, kk = 0, match = 1;</a>
<a name="ln1498"> </a>
<a name="ln1499">      gchar *keys = g_utf8_casefold(darktable.bauhaus-&gt;keys, -1);</a>
<a name="ln1500">      for(GList *it = d-&gt;entries; it; it = g_list_next(it))</a>
<a name="ln1501">      {</a>
<a name="ln1502">        const dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)it-&gt;data;</a>
<a name="ln1503">        gchar *text_cmp = g_utf8_casefold(entry-&gt;label, -1);</a>
<a name="ln1504">        if(!strncmp(text_cmp, keys, darktable.bauhaus-&gt;keys_cnt))</a>
<a name="ln1505">        {</a>
<a name="ln1506">          if(active == k)</a>
<a name="ln1507">          {</a>
<a name="ln1508">            if(entry-&gt;sensitive)</a>
<a name="ln1509">              dt_bauhaus_combobox_set(widget, i);</a>
<a name="ln1510">            g_free(keys);</a>
<a name="ln1511">            g_free(text_cmp);</a>
<a name="ln1512">            return;</a>
<a name="ln1513">          }</a>
<a name="ln1514">          kk = i; // remember for down there</a>
<a name="ln1515">          // editable should only snap to perfect matches, not prefixes:</a>
<a name="ln1516">          if(d-&gt;editable &amp;&amp; strcmp(entry-&gt;label, darktable.bauhaus-&gt;keys)) match = 0;</a>
<a name="ln1517">          k++;</a>
<a name="ln1518">        }</a>
<a name="ln1519">        i++;</a>
<a name="ln1520">        g_free(text_cmp);</a>
<a name="ln1521">      }</a>
<a name="ln1522">      // if list is short (2 entries could be: typed something similar, and one similar)</a>
<a name="ln1523">      if(k &lt; 3)</a>
<a name="ln1524">      {</a>
<a name="ln1525">        // didn't find it, but had only one matching choice?</a>
<a name="ln1526">        if(k == 1 &amp;&amp; match)</a>
<a name="ln1527">          dt_bauhaus_combobox_set(widget, kk);</a>
<a name="ln1528">        else if(d-&gt;editable)</a>
<a name="ln1529">        {</a>
<a name="ln1530">          // had no close match (k == 1 &amp;&amp; !match) or no match at all (k == 0)</a>
<a name="ln1531">          memset(d-&gt;text, 0, sizeof(d-&gt;text));</a>
<a name="ln1532">          g_strlcpy(d-&gt;text, darktable.bauhaus-&gt;keys, sizeof(d-&gt;text));</a>
<a name="ln1533">          // select custom entry</a>
<a name="ln1534">          dt_bauhaus_combobox_set(widget, -1);</a>
<a name="ln1535">        }</a>
<a name="ln1536">      }</a>
<a name="ln1537">      g_free(keys);</a>
<a name="ln1538">      break;</a>
<a name="ln1539">    }</a>
<a name="ln1540">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1541">    {</a>
<a name="ln1542">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1543">      const float mouse_off = get_slider_line_offset(</a>
<a name="ln1544">          d-&gt;oldpos, d-&gt;scale, darktable.bauhaus-&gt;end_mouse_x / width,</a>
<a name="ln1545">          darktable.bauhaus-&gt;end_mouse_y / height, base_height / (float)height, base_width);</a>
<a name="ln1546">      dt_bauhaus_slider_set_normalized(w, d-&gt;oldpos + mouse_off);</a>
<a name="ln1547">      d-&gt;oldpos = d-&gt;pos;</a>
<a name="ln1548">      break;</a>
<a name="ln1549">    }</a>
<a name="ln1550">    default:</a>
<a name="ln1551">      break;</a>
<a name="ln1552">  }</a>
<a name="ln1553">}</a>
<a name="ln1554"> </a>
<a name="ln1555">static gboolean dt_bauhaus_popup_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln1556">{</a>
<a name="ln1557">  dt_bauhaus_widget_t *w = darktable.bauhaus-&gt;current;</a>
<a name="ln1558"> </a>
<a name="ln1559">  // dimensions of the popup</a>
<a name="ln1560">  GtkAllocation allocation;</a>
<a name="ln1561">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1562">  int width = allocation.width, height = inner_height(allocation);</a>
<a name="ln1563"> </a>
<a name="ln1564">  // dimensions of the original line</a>
<a name="ln1565">  GtkWidget *current = GTK_WIDGET(w);</a>
<a name="ln1566">  GtkAllocation allocation_current;</a>
<a name="ln1567">  gtk_widget_get_allocation(current, &amp;allocation_current);</a>
<a name="ln1568">  int wd = allocation_current.width, ht = inner_height(allocation_current);</a>
<a name="ln1569"> </a>
<a name="ln1570">  // get area properties</a>
<a name="ln1571">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln1572">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln1573">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln1574"> </a>
<a name="ln1575">  // translate to account for the widget spacing</a>
<a name="ln1576">  cairo_translate(cr, 0, darktable.bauhaus-&gt;widget_space);</a>
<a name="ln1577"> </a>
<a name="ln1578">  // draw background</a>
<a name="ln1579">  gtk_render_background(context, cr, 0.0, 0.0, width, height);</a>
<a name="ln1580"> </a>
<a name="ln1581">  // look up some colors once</a>
<a name="ln1582">  GdkRGBA text_color, text_color_selected, text_color_hover, text_color_insensitive;</a>
<a name="ln1583">  gtk_style_context_get_color(context, GTK_STATE_FLAG_NORMAL, &amp;text_color);</a>
<a name="ln1584">  gtk_style_context_get_color(context, GTK_STATE_FLAG_SELECTED, &amp;text_color_selected);</a>
<a name="ln1585">  gtk_style_context_get_color(context, GTK_STATE_FLAG_PRELIGHT, &amp;text_color_hover);</a>
<a name="ln1586">  gtk_style_context_get_color(context, GTK_STATE_FLAG_INSENSITIVE, &amp;text_color_insensitive);</a>
<a name="ln1587"> </a>
<a name="ln1588">  GdkRGBA *fg_color = default_color_assign();</a>
<a name="ln1589">  GdkRGBA *bg_color = default_color_assign();</a>
<a name="ln1590">  GtkStateFlags state = gtk_widget_get_state_flags(widget);</a>
<a name="ln1591">  gtk_render_background(context, cr, 0, 0, width, height);</a>
<a name="ln1592"> </a>
<a name="ln1593">  gtk_style_context_get(context, state, &quot;background-color&quot;, bg_color, NULL);</a>
<a name="ln1594">  gtk_style_context_get_color(context, state, fg_color);</a>
<a name="ln1595"> </a>
<a name="ln1596">  // switch on bauhaus widget type (so we only need one static window)</a>
<a name="ln1597">  switch(w-&gt;type)</a>
<a name="ln1598">  {</a>
<a name="ln1599">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1600">    {</a>
<a name="ln1601">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1602"> </a>
<a name="ln1603">      dt_bauhaus_draw_baseline(w, cr);</a>
<a name="ln1604"> </a>
<a name="ln1605">      cairo_save(cr);</a>
<a name="ln1606">      cairo_set_line_width(cr, 0.5);</a>
<a name="ln1607">      const int num_scales = 1.f / d-&gt;scale;</a>
<a name="ln1608"> </a>
<a name="ln1609">      cairo_rectangle(cr, 0.0f, ht, width - INNER_PADDING, height);</a>
<a name="ln1610">      cairo_clip(cr);</a>
<a name="ln1611"> </a>
<a name="ln1612">      for(int k = 0; k &lt; num_scales; k++)</a>
<a name="ln1613">      {</a>
<a name="ln1614">        const float off = k * d-&gt;scale - d-&gt;oldpos;</a>
<a name="ln1615">        GdkRGBA fg_copy = *fg_color;</a>
<a name="ln1616">        fg_copy.alpha = d-&gt;scale / fabsf(off);</a>
<a name="ln1617">        set_color(cr, fg_copy);</a>
<a name="ln1618">        draw_slider_line(cr, d-&gt;oldpos, off, d-&gt;scale, width, height, ht);</a>
<a name="ln1619">        cairo_stroke(cr);</a>
<a name="ln1620">      }</a>
<a name="ln1621">      cairo_restore(cr);</a>
<a name="ln1622">      set_color(cr, *fg_color);</a>
<a name="ln1623">      show_pango_text(w, context, cr, w-&gt;label, 0, 0, 0, FALSE);</a>
<a name="ln1624"> </a>
<a name="ln1625">      // draw mouse over indicator line</a>
<a name="ln1626">      cairo_save(cr);</a>
<a name="ln1627">      cairo_set_line_width(cr, 2.);</a>
<a name="ln1628">      const float mouse_off</a>
<a name="ln1629">          = darktable.bauhaus-&gt;change_active</a>
<a name="ln1630">                ? get_slider_line_offset(d-&gt;oldpos, d-&gt;scale, darktable.bauhaus-&gt;mouse_x / width,</a>
<a name="ln1631">                                         darktable.bauhaus-&gt;mouse_y / height, ht / (float)height, width)</a>
<a name="ln1632">                : 0.0f;</a>
<a name="ln1633">      draw_slider_line(cr, d-&gt;oldpos, mouse_off, d-&gt;scale, width, height, ht);</a>
<a name="ln1634">      cairo_stroke(cr);</a>
<a name="ln1635">      cairo_restore(cr);</a>
<a name="ln1636"> </a>
<a name="ln1637">      // draw indicator</a>
<a name="ln1638">      dt_bauhaus_draw_indicator(w, d-&gt;oldpos + mouse_off, cr, fg_color, bg_color);</a>
<a name="ln1639"> </a>
<a name="ln1640">      // draw numerical value:</a>
<a name="ln1641">      cairo_save(cr);</a>
<a name="ln1642">      char text[256];</a>
<a name="ln1643">      const float f = d-&gt;min + (d-&gt;oldpos + mouse_off) * (d-&gt;max - d-&gt;min);</a>
<a name="ln1644">      const float fc = d-&gt;callback(widget, f, DT_BAUHAUS_GET);</a>
<a name="ln1645">      snprintf(text, sizeof(text), d-&gt;format, fc);</a>
<a name="ln1646">      set_color(cr, *fg_color);</a>
<a name="ln1647">      show_pango_text(w, context, cr, text, wd - darktable.bauhaus-&gt;quad_width - INNER_PADDING, 0, 0, TRUE);</a>
<a name="ln1648"> </a>
<a name="ln1649">      cairo_restore(cr);</a>
<a name="ln1650">    }</a>
<a name="ln1651">    break;</a>
<a name="ln1652">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1653">    {</a>
<a name="ln1654">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1655">      cairo_save(cr);</a>
<a name="ln1656">      float first_label_width = 0.0;</a>
<a name="ln1657">      gboolean first_label = TRUE;</a>
<a name="ln1658">      int k = 0, i = 0;</a>
<a name="ln1659">      int hovered = darktable.bauhaus-&gt;mouse_y / ht;</a>
<a name="ln1660">      gchar *keys = g_utf8_casefold(darktable.bauhaus-&gt;keys, -1);</a>
<a name="ln1661">      for(GList *it = d-&gt;entries; it; it = g_list_next(it))</a>
<a name="ln1662">      {</a>
<a name="ln1663">        const dt_bauhaus_combobox_entry_t *entry = (dt_bauhaus_combobox_entry_t *)it-&gt;data;</a>
<a name="ln1664">        gchar *text_cmp = g_utf8_casefold(entry-&gt;label, -1);</a>
<a name="ln1665">        if(!strncmp(text_cmp, keys, darktable.bauhaus-&gt;keys_cnt))</a>
<a name="ln1666">        {</a>
<a name="ln1667">          float max_width = wd - INNER_PADDING - darktable.bauhaus-&gt;quad_width;</a>
<a name="ln1668">          if(first_label) max_width *= 0.8; // give the label at least some room</a>
<a name="ln1669"> </a>
<a name="ln1670">          float label_width;</a>
<a name="ln1671">          if(!entry-&gt;sensitive)</a>
<a name="ln1672">            set_color(cr, text_color_insensitive);</a>
<a name="ln1673">          else if(i == hovered)</a>
<a name="ln1674">            set_color(cr, text_color_hover);</a>
<a name="ln1675">          else if(i == d-&gt;active)</a>
<a name="ln1676">            set_color(cr, text_color_selected);</a>
<a name="ln1677">          else</a>
<a name="ln1678">            set_color(cr, text_color);</a>
<a name="ln1679"> </a>
<a name="ln1680">          if(entry-&gt;alignment == DT_BAUHAUS_COMBOBOX_ALIGN_LEFT)</a>
<a name="ln1681">            label_width = show_pango_text(w, context, cr, entry-&gt;label, 0, ht * k, max_width, FALSE);</a>
<a name="ln1682">          else</a>
<a name="ln1683">            label_width = show_pango_text(w, context, cr, entry-&gt;label, wd - INNER_PADDING - darktable.bauhaus-&gt;quad_width, ht * k, max_width, TRUE);</a>
<a name="ln1684"> </a>
<a name="ln1685">          // prefer the entry over the label wrt. ellipsization when expanded</a>
<a name="ln1686">          if(first_label)</a>
<a name="ln1687">          {</a>
<a name="ln1688">            first_label_width = label_width;</a>
<a name="ln1689">            first_label = FALSE;</a>
<a name="ln1690">          }</a>
<a name="ln1691"> </a>
<a name="ln1692">          k++;</a>
<a name="ln1693">        }</a>
<a name="ln1694">        i++;</a>
<a name="ln1695">        g_free(text_cmp);</a>
<a name="ln1696">      }</a>
<a name="ln1697">      cairo_restore(cr);</a>
<a name="ln1698"> </a>
<a name="ln1699">      // left aligned box label. add it to the gui after the entries so we can ellipsize it if needed</a>
<a name="ln1700">      set_color(cr, text_color);</a>
<a name="ln1701">      show_pango_text(w, context, cr, w-&gt;label, 0, 0, wd - INNER_PADDING - darktable.bauhaus-&gt;quad_width - first_label_width, FALSE);</a>
<a name="ln1702"> </a>
<a name="ln1703">      g_free(keys);</a>
<a name="ln1704">    }</a>
<a name="ln1705">    break;</a>
<a name="ln1706">    default:</a>
<a name="ln1707">      // yell</a>
<a name="ln1708">      break;</a>
<a name="ln1709">  }</a>
<a name="ln1710"> </a>
<a name="ln1711">  // draw currently typed text. if a type doesn't want this, it should not</a>
<a name="ln1712">  // allow stuff to be written here in the key callback.</a>
<a name="ln1713">  if(darktable.bauhaus-&gt;keys_cnt)</a>
<a name="ln1714">  {</a>
<a name="ln1715">    cairo_save(cr);</a>
<a name="ln1716">    PangoLayout *layout;</a>
<a name="ln1717">    PangoRectangle ink;</a>
<a name="ln1718">    layout = pango_cairo_create_layout(cr);</a>
<a name="ln1719">    pango_cairo_context_set_resolution(pango_layout_get_context(layout), darktable.gui-&gt;dpi);</a>
<a name="ln1720">    set_color(cr, text_color);</a>
<a name="ln1721"> </a>
<a name="ln1722">    // make extra large, but without dependency on popup window height</a>
<a name="ln1723">    // (that might differ for comboboxes for example). only fall back</a>
<a name="ln1724">    // to height dependency if the popup is really small.</a>
<a name="ln1725">    const int line_height = get_line_height();</a>
<a name="ln1726">    const int size = MIN(3 * line_height, .2 * height);</a>
<a name="ln1727">    PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln1728">    pango_font_description_set_absolute_size(desc, size * PANGO_SCALE);</a>
<a name="ln1729">    pango_layout_set_font_description(layout, desc);</a>
<a name="ln1730"> </a>
<a name="ln1731">    pango_layout_set_text(layout, darktable.bauhaus-&gt;keys, -1);</a>
<a name="ln1732">    pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln1733">    cairo_move_to(cr, wd - INNER_PADDING - darktable.bauhaus-&gt;quad_width - ink.width, height * 0.5 - size);</a>
<a name="ln1734">    pango_cairo_show_layout(cr, layout);</a>
<a name="ln1735">    cairo_restore(cr);</a>
<a name="ln1736">    pango_font_description_free(desc);</a>
<a name="ln1737">    g_object_unref(layout);</a>
<a name="ln1738">  }</a>
<a name="ln1739">  if(darktable.bauhaus-&gt;cursor_visible)</a>
<a name="ln1740">  {</a>
<a name="ln1741">    // show the blinking cursor</a>
<a name="ln1742">    cairo_save(cr);</a>
<a name="ln1743">    set_color(cr, text_color);</a>
<a name="ln1744">    const int line_height = get_line_height();</a>
<a name="ln1745">    cairo_move_to(cr, wd - darktable.bauhaus-&gt;quad_width + 3, height * 0.5 + line_height);</a>
<a name="ln1746">    cairo_line_to(cr, wd - darktable.bauhaus-&gt;quad_width + 3, height * 0.5 - 3 * line_height);</a>
<a name="ln1747">    cairo_set_line_width(cr, 2.);</a>
<a name="ln1748">    cairo_stroke(cr);</a>
<a name="ln1749">    cairo_restore(cr);</a>
<a name="ln1750">  }</a>
<a name="ln1751"> </a>
<a name="ln1752">  cairo_destroy(cr);</a>
<a name="ln1753">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln1754">  cairo_paint(crf);</a>
<a name="ln1755">  cairo_surface_destroy(cst);</a>
<a name="ln1756"> </a>
<a name="ln1757">  gdk_rgba_free(bg_color);</a>
<a name="ln1758">  gdk_rgba_free(fg_color);</a>
<a name="ln1759"> </a>
<a name="ln1760">  return TRUE;</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763">static gboolean dt_bauhaus_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln1764">{</a>
<a name="ln1765">  GtkAllocation allocation;</a>
<a name="ln1766">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1767">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1768">  const int width = allocation.width, height = allocation.height;</a>
<a name="ln1769">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln1770">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln1771">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln1772"> </a>
<a name="ln1773">  // translate to account for the widget spacing</a>
<a name="ln1774">  cairo_translate(cr, 0, darktable.bauhaus-&gt;widget_space);</a>
<a name="ln1775"> </a>
<a name="ln1776">  GdkRGBA *fg_color = default_color_assign();</a>
<a name="ln1777">  GdkRGBA *text_color = default_color_assign();</a>
<a name="ln1778">  GtkStateFlags state = gtk_widget_get_state_flags(widget);</a>
<a name="ln1779">  gtk_style_context_get_color(context, state, text_color);</a>
<a name="ln1780">  gtk_render_background(context, cr, 0, 0, width, height + INNER_PADDING);</a>
<a name="ln1781">  gtk_style_context_get_color(context, state, fg_color);</a>
<a name="ln1782"> </a>
<a name="ln1783">  // draw type specific content:</a>
<a name="ln1784">  cairo_save(cr);</a>
<a name="ln1785">  cairo_set_line_width(cr, 1.0);</a>
<a name="ln1786">  switch(w-&gt;type)</a>
<a name="ln1787">  {</a>
<a name="ln1788">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1789">    {</a>
<a name="ln1790">      // draw label and quad area at right end</a>
<a name="ln1791">      set_color(cr, *text_color);</a>
<a name="ln1792">      float label_width</a>
<a name="ln1793">          = show_pango_text(w, context, cr, w-&gt;label, 0, 0, 0, FALSE);</a>
<a name="ln1794">      dt_bauhaus_draw_quad(w, cr);</a>
<a name="ln1795"> </a>
<a name="ln1796">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1797">      gchar *text = d-&gt;text;</a>
<a name="ln1798">      if(d-&gt;active &gt;= 0)</a>
<a name="ln1799">      {</a>
<a name="ln1800">        const dt_bauhaus_combobox_entry_t *entry = g_list_nth_data(d-&gt;entries, d-&gt;active);</a>
<a name="ln1801">        text = entry-&gt;label;</a>
<a name="ln1802">      }</a>
<a name="ln1803">      set_color(cr, *text_color);</a>
<a name="ln1804">      show_pango_text(w, context, cr, text, width - darktable.bauhaus-&gt;quad_width - INNER_PADDING, 0, width - darktable.bauhaus-&gt;quad_width - label_width, TRUE);</a>
<a name="ln1805">      break;</a>
<a name="ln1806">    }</a>
<a name="ln1807">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1808">    {</a>
<a name="ln1809">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1810"> </a>
<a name="ln1811">      // line for orientation</a>
<a name="ln1812">      dt_bauhaus_draw_baseline(w, cr);</a>
<a name="ln1813">      dt_bauhaus_draw_quad(w, cr);</a>
<a name="ln1814"> </a>
<a name="ln1815">      if(gtk_widget_is_sensitive(widget))</a>
<a name="ln1816">      {</a>
<a name="ln1817">        cairo_save(cr);</a>
<a name="ln1818">        cairo_rectangle(cr, 0, 0, width - darktable.bauhaus-&gt;quad_width - INNER_PADDING, height + INNER_PADDING);</a>
<a name="ln1819">        cairo_clip(cr);</a>
<a name="ln1820">        dt_bauhaus_draw_indicator(w, d-&gt;pos, cr, fg_color, &amp;darktable.bauhaus-&gt;indicator_border);</a>
<a name="ln1821">        cairo_restore(cr);</a>
<a name="ln1822"> </a>
<a name="ln1823">        // TODO: merge that text with combo</a>
<a name="ln1824">        char text[256];</a>
<a name="ln1825">        const float f = d-&gt;min + d-&gt;pos * (d-&gt;max - d-&gt;min);</a>
<a name="ln1826">        const float fc = d-&gt;callback(widget, f, DT_BAUHAUS_GET);</a>
<a name="ln1827">        snprintf(text, sizeof(text), d-&gt;format, fc);</a>
<a name="ln1828">        set_color(cr, *text_color);</a>
<a name="ln1829">        show_pango_text(w, context, cr, text, width - darktable.bauhaus-&gt;quad_width - INNER_PADDING, 0, 0, TRUE);</a>
<a name="ln1830">      }</a>
<a name="ln1831">      // label on top of marker:</a>
<a name="ln1832">      set_color(cr, *text_color);</a>
<a name="ln1833">      show_pango_text(w, context, cr, w-&gt;label, 0, 0, 0, FALSE);</a>
<a name="ln1834">    }</a>
<a name="ln1835">    break;</a>
<a name="ln1836">    default:</a>
<a name="ln1837">      break;</a>
<a name="ln1838">  }</a>
<a name="ln1839">  cairo_restore(cr);</a>
<a name="ln1840">  cairo_destroy(cr);</a>
<a name="ln1841">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln1842">  cairo_paint(crf);</a>
<a name="ln1843">  cairo_surface_destroy(cst);</a>
<a name="ln1844"> </a>
<a name="ln1845">  gdk_rgba_free(text_color);</a>
<a name="ln1846">  gdk_rgba_free(fg_color);</a>
<a name="ln1847"> </a>
<a name="ln1848">  return TRUE;</a>
<a name="ln1849">}</a>
<a name="ln1850"> </a>
<a name="ln1851">void dt_bauhaus_hide_popup()</a>
<a name="ln1852">{</a>
<a name="ln1853">  if(darktable.bauhaus-&gt;current)</a>
<a name="ln1854">  {</a>
<a name="ln1855">    gtk_grab_remove(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1856">    gtk_widget_hide(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1857">    darktable.bauhaus-&gt;current = NULL;</a>
<a name="ln1858">    // TODO: give focus to center view? do in accept() as well?</a>
<a name="ln1859">  }</a>
<a name="ln1860">  _stop_cursor();</a>
<a name="ln1861">}</a>
<a name="ln1862"> </a>
<a name="ln1863">void dt_bauhaus_show_popup(dt_bauhaus_widget_t *w)</a>
<a name="ln1864">{</a>
<a name="ln1865">  if(darktable.bauhaus-&gt;current) dt_bauhaus_hide_popup();</a>
<a name="ln1866">  darktable.bauhaus-&gt;current = w;</a>
<a name="ln1867">  darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln1868">  memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln1869">  darktable.bauhaus-&gt;change_active = 0;</a>
<a name="ln1870">  darktable.bauhaus-&gt;mouse_line_distance = 0.0f;</a>
<a name="ln1871">  _stop_cursor();</a>
<a name="ln1872"> </a>
<a name="ln1873">  if(w-&gt;module)</a>
<a name="ln1874">  {</a>
<a name="ln1875">    dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1876">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln1877">  }</a>
<a name="ln1878"> </a>
<a name="ln1879">  int offset = 0;</a>
<a name="ln1880">  GtkAllocation tmp;</a>
<a name="ln1881">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln1882"> </a>
<a name="ln1883">  gtk_widget_realize(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1884">  switch(darktable.bauhaus-&gt;current-&gt;type)</a>
<a name="ln1885">  {</a>
<a name="ln1886">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1887">    {</a>
<a name="ln1888">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1889">      d-&gt;oldpos = d-&gt;pos;</a>
<a name="ln1890">      tmp.height = tmp.width;</a>
<a name="ln1891">      _start_cursor(6);</a>
<a name="ln1892">      break;</a>
<a name="ln1893">    }</a>
<a name="ln1894">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1895">    {</a>
<a name="ln1896">      // we launch the dynamic populate fct if any</a>
<a name="ln1897">      if(w-&gt;combo_populate) w-&gt;combo_populate(GTK_WIDGET(w), &amp;w-&gt;module);</a>
<a name="ln1898">      // comboboxes change immediately</a>
<a name="ln1899">      darktable.bauhaus-&gt;change_active = 1;</a>
<a name="ln1900">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1901">      tmp.height = tmp.height * d-&gt;num_labels;</a>
<a name="ln1902">      GtkAllocation allocation_w;</a>
<a name="ln1903">      gtk_widget_get_allocation(GTK_WIDGET(w), &amp;allocation_w);</a>
<a name="ln1904">      const int ht = allocation_w.height;</a>
<a name="ln1905">      const int skip = ht + get_line_height();</a>
<a name="ln1906">      offset = -d-&gt;active * get_line_height();</a>
<a name="ln1907">      darktable.bauhaus-&gt;mouse_x = 0;</a>
<a name="ln1908">      darktable.bauhaus-&gt;mouse_y = d-&gt;active * skip + ht / 2;</a>
<a name="ln1909">      break;</a>
<a name="ln1910">    }</a>
<a name="ln1911">    default:</a>
<a name="ln1912">      break;</a>
<a name="ln1913">  }</a>
<a name="ln1914"> </a>
<a name="ln1915">  gint wx, wy;</a>
<a name="ln1916">  gdk_window_get_origin(gtk_widget_get_window(GTK_WIDGET(w)), &amp;wx, &amp;wy);</a>
<a name="ln1917"> </a>
<a name="ln1918">  // move popup so mouse is over currently active item, to minimize confusion with scroll wheel:</a>
<a name="ln1919">  if(darktable.bauhaus-&gt;current-&gt;type == DT_BAUHAUS_COMBOBOX) wy += offset;</a>
<a name="ln1920"> </a>
<a name="ln1921">  // gtk_widget_get_window will return null if not shown yet.</a>
<a name="ln1922">  // it is needed for gdk_window_move, and gtk_window move will</a>
<a name="ln1923">  // sometimes be ignored. this is why we always call both...</a>
<a name="ln1924">  // we also don't want to show before move, as this results in noticeable flickering.</a>
<a name="ln1925">  GdkWindow *window = gtk_widget_get_window(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1926">  if(window) gdk_window_move(window, wx, wy);</a>
<a name="ln1927">  gtk_window_move(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), wx, wy);</a>
<a name="ln1928">  gtk_widget_set_size_request(darktable.bauhaus-&gt;popup_area, tmp.width, tmp.height);</a>
<a name="ln1929">  gtk_widget_set_size_request(darktable.bauhaus-&gt;popup_window, tmp.width, tmp.height);</a>
<a name="ln1930">  gtk_widget_show_all(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1931">  gtk_widget_grab_focus(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln1932">}</a>
<a name="ln1933"> </a>
<a name="ln1934">static gboolean dt_bauhaus_slider_add_delta_internal(GtkWidget *widget, float delta, guint state)</a>
<a name="ln1935">{</a>
<a name="ln1936">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1937">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1938"> </a>
<a name="ln1939">  float multiplier;</a>
<a name="ln1940"> </a>
<a name="ln1941">  GdkModifierType modifiers = gtk_accelerator_get_default_mod_mask();</a>
<a name="ln1942">  if((state &amp; modifiers) == GDK_SHIFT_MASK)</a>
<a name="ln1943">  {</a>
<a name="ln1944">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_rough_step_multiplier&quot;);</a>
<a name="ln1945">  }</a>
<a name="ln1946">  else if((state &amp; modifiers) == GDK_CONTROL_MASK)</a>
<a name="ln1947">  {</a>
<a name="ln1948">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_precise_step_multiplier&quot;);</a>
<a name="ln1949">  }</a>
<a name="ln1950">  else</a>
<a name="ln1951">  {</a>
<a name="ln1952">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_step_multiplier&quot;);</a>
<a name="ln1953">  }</a>
<a name="ln1954"> </a>
<a name="ln1955">  delta *= multiplier;</a>
<a name="ln1956"> </a>
<a name="ln1957">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1958"> </a>
<a name="ln1959">  dt_bauhaus_slider_set_normalized(w, d-&gt;pos + delta);</a>
<a name="ln1960"> </a>
<a name="ln1961">  return TRUE;</a>
<a name="ln1962">}</a>
<a name="ln1963"> </a>
<a name="ln1964">static gboolean dt_bauhaus_slider_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln1965">{</a>
<a name="ln1966">  gdouble delta_y;</a>
<a name="ln1967">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1968">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return FALSE;</a>
<a name="ln1969">  if(((event-&gt;state &amp; gtk_accelerator_get_default_mod_mask()) == darktable.gui-&gt;sidebar_scroll_mask) != dt_conf_get_bool(&quot;darkroom/ui/sidebar_scroll_default&quot;)) return FALSE;</a>
<a name="ln1970">  gtk_widget_grab_focus(widget);</a>
<a name="ln1971"> </a>
<a name="ln1972">  if(dt_gui_get_scroll_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln1973">  {</a>
<a name="ln1974">    delta_y *= -w-&gt;data.slider.scale / 5.0;</a>
<a name="ln1975">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln1976">    return dt_bauhaus_slider_add_delta_internal(widget, delta_y, event-&gt;state);</a>
<a name="ln1977">  }</a>
<a name="ln1978"> </a>
<a name="ln1979">  return FALSE;</a>
<a name="ln1980">}</a>
<a name="ln1981"> </a>
<a name="ln1982">static gboolean dt_bauhaus_slider_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data)</a>
<a name="ln1983">{</a>
<a name="ln1984">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1985">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return FALSE;</a>
<a name="ln1986">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1987"> </a>
<a name="ln1988">  int handled = 0;</a>
<a name="ln1989">  float delta = 0.0f;</a>
<a name="ln1990">  if(event-&gt;keyval == GDK_KEY_Up || event-&gt;keyval == GDK_KEY_KP_Up || event-&gt;keyval == GDK_KEY_Right</a>
<a name="ln1991">     || event-&gt;keyval == GDK_KEY_KP_Right)</a>
<a name="ln1992">  {</a>
<a name="ln1993">    handled = 1;</a>
<a name="ln1994">    delta = d-&gt;scale / 5.0f;</a>
<a name="ln1995">  }</a>
<a name="ln1996">  else if(event-&gt;keyval == GDK_KEY_Down || event-&gt;keyval == GDK_KEY_KP_Down || event-&gt;keyval == GDK_KEY_Left</a>
<a name="ln1997">          || event-&gt;keyval == GDK_KEY_KP_Left)</a>
<a name="ln1998">  {</a>
<a name="ln1999">    handled = 1;</a>
<a name="ln2000">    delta = -d-&gt;scale / 5.0f;</a>
<a name="ln2001">  }</a>
<a name="ln2002"> </a>
<a name="ln2003">  if(!handled) return FALSE;</a>
<a name="ln2004"> </a>
<a name="ln2005">  return dt_bauhaus_slider_add_delta_internal(widget, delta, event-&gt;state);</a>
<a name="ln2006">}</a>
<a name="ln2007"> </a>
<a name="ln2008"> </a>
<a name="ln2009">static gboolean dt_bauhaus_combobox_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln2010">{</a>
<a name="ln2011">  int delta_y;</a>
<a name="ln2012">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2013">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln2014">  if(((event-&gt;state &amp; gtk_accelerator_get_default_mod_mask()) == darktable.gui-&gt;sidebar_scroll_mask) != dt_conf_get_bool(&quot;darkroom/ui/sidebar_scroll_default&quot;)) return FALSE;</a>
<a name="ln2015">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln2016">  gtk_widget_grab_focus(widget);</a>
<a name="ln2017"> </a>
<a name="ln2018">  if(dt_gui_get_scroll_unit_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln2019">  {</a>
<a name="ln2020">    if(w-&gt;module)</a>
<a name="ln2021">    {</a>
<a name="ln2022">      dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2023">      gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2024">    }</a>
<a name="ln2025">    // go to next sensitive one</a>
<a name="ln2026">    int new_pos = CLAMP(d-&gt;active + delta_y, 0, d-&gt;num_labels - 1);</a>
<a name="ln2027">    if(_combobox_next_entry(d-&gt;entries, &amp;new_pos, delta_y))</a>
<a name="ln2028">      dt_bauhaus_combobox_set(widget, new_pos);</a>
<a name="ln2029">    return TRUE;</a>
<a name="ln2030">  }</a>
<a name="ln2031">  return FALSE;</a>
<a name="ln2032">}</a>
<a name="ln2033"> </a>
<a name="ln2034">static gboolean dt_bauhaus_combobox_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data)</a>
<a name="ln2035">{</a>
<a name="ln2036">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2037">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln2038">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln2039">  if(event-&gt;keyval == GDK_KEY_Up || event-&gt;keyval == GDK_KEY_KP_Up || event-&gt;keyval == GDK_KEY_Left</a>
<a name="ln2040">     || event-&gt;keyval == GDK_KEY_KP_Left)</a>
<a name="ln2041">  {</a>
<a name="ln2042">    if(w-&gt;module)</a>
<a name="ln2043">    {</a>
<a name="ln2044">      dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2045">      gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2046">    }</a>
<a name="ln2047">    // skip insensitive ones</a>
<a name="ln2048">    int new_pos = CLAMP(d-&gt;active - 1, 0, d-&gt;num_labels - 1);</a>
<a name="ln2049">    if(_combobox_next_entry(d-&gt;entries, &amp;new_pos, -1))</a>
<a name="ln2050">      dt_bauhaus_combobox_set(widget, new_pos);</a>
<a name="ln2051">    return TRUE;</a>
<a name="ln2052">  }</a>
<a name="ln2053">  else if(event-&gt;keyval == GDK_KEY_Down || event-&gt;keyval == GDK_KEY_KP_Down || event-&gt;keyval == GDK_KEY_Right</a>
<a name="ln2054">          || event-&gt;keyval == GDK_KEY_KP_Right)</a>
<a name="ln2055">  {</a>
<a name="ln2056">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2057">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2058"> </a>
<a name="ln2059">    // skip insensitive ones</a>
<a name="ln2060">    int new_pos = CLAMP(d-&gt;active + 1, 0, d-&gt;num_labels - 1);</a>
<a name="ln2061">    if(_combobox_next_entry(d-&gt;entries, &amp;new_pos, 1))</a>
<a name="ln2062">      dt_bauhaus_combobox_set(widget, new_pos);</a>
<a name="ln2063">    return TRUE;</a>
<a name="ln2064">  }</a>
<a name="ln2065">  return FALSE;</a>
<a name="ln2066">}</a>
<a name="ln2067"> </a>
<a name="ln2068">static gboolean dt_bauhaus_combobox_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2069">{</a>
<a name="ln2070">  GtkAllocation allocation;</a>
<a name="ln2071">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln2072">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2073"> </a>
<a name="ln2074">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln2075">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2076">  gtk_widget_grab_focus(GTK_WIDGET(w));</a>
<a name="ln2077">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2078"> </a>
<a name="ln2079">  GtkAllocation tmp;</a>
<a name="ln2080">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2081">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln2082">  if(w-&gt;quad_paint &amp;&amp; (event-&gt;x &gt; allocation.width - darktable.bauhaus-&gt;quad_width))</a>
<a name="ln2083">  {</a>
<a name="ln2084">    if (w-&gt;quad_toggle)</a>
<a name="ln2085">    {</a>
<a name="ln2086">      if (w-&gt;quad_paint_flags &amp; CPF_ACTIVE)</a>
<a name="ln2087">        w-&gt;quad_paint_flags &amp;= ~CPF_ACTIVE;</a>
<a name="ln2088">      else</a>
<a name="ln2089">        w-&gt;quad_paint_flags |= CPF_ACTIVE;</a>
<a name="ln2090">    }</a>
<a name="ln2091">    g_signal_emit_by_name(G_OBJECT(w), &quot;quad-pressed&quot;);</a>
<a name="ln2092">    return TRUE;</a>
<a name="ln2093">  }</a>
<a name="ln2094">  else if(event-&gt;button == 3)</a>
<a name="ln2095">  {</a>
<a name="ln2096">    darktable.bauhaus-&gt;mouse_x = event-&gt;x;</a>
<a name="ln2097">    darktable.bauhaus-&gt;mouse_y = event-&gt;y;</a>
<a name="ln2098">    dt_bauhaus_show_popup(w);</a>
<a name="ln2099">    return TRUE;</a>
<a name="ln2100">  }</a>
<a name="ln2101">  else if(event-&gt;button == 1)</a>
<a name="ln2102">  {</a>
<a name="ln2103">    // reset to default.</a>
<a name="ln2104">    if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln2105">    {</a>
<a name="ln2106">      // never called, as we popup the other window under your cursor before.</a>
<a name="ln2107">      // (except in weird corner cases where the popup is under the -1st entry</a>
<a name="ln2108">      dt_bauhaus_combobox_set(widget, d-&gt;defpos);</a>
<a name="ln2109">      dt_bauhaus_hide_popup();</a>
<a name="ln2110">    }</a>
<a name="ln2111">    else</a>
<a name="ln2112">    {</a>
<a name="ln2113">      // single click, show options</a>
<a name="ln2114">      darktable.bauhaus-&gt;opentime = dt_get_wtime();</a>
<a name="ln2115">      darktable.bauhaus-&gt;mouse_x = event-&gt;x;</a>
<a name="ln2116">      darktable.bauhaus-&gt;mouse_y = event-&gt;y;</a>
<a name="ln2117">      dt_bauhaus_show_popup(w);</a>
<a name="ln2118">    }</a>
<a name="ln2119">    return TRUE;</a>
<a name="ln2120">  }</a>
<a name="ln2121">  return FALSE;</a>
<a name="ln2122">}</a>
<a name="ln2123"> </a>
<a name="ln2124">float dt_bauhaus_slider_get(GtkWidget *widget)</a>
<a name="ln2125">{</a>
<a name="ln2126">  // first cast to bh widget, to check that type:</a>
<a name="ln2127">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2128">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return -1.0f;</a>
<a name="ln2129">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2130">  if(d-&gt;max == d-&gt;min) {</a>
<a name="ln2131">    return d-&gt;max;</a>
<a name="ln2132">  }</a>
<a name="ln2133">  float rawval = d-&gt;min + d-&gt;pos * (d-&gt;max - d-&gt;min);</a>
<a name="ln2134">  return d-&gt;callback(widget, rawval, DT_BAUHAUS_GET);</a>
<a name="ln2135">}</a>
<a name="ln2136"> </a>
<a name="ln2137">void dt_bauhaus_slider_set(GtkWidget *widget, float pos)</a>
<a name="ln2138">{</a>
<a name="ln2139">  // this is the public interface function, translate by bounds and call set_normalized</a>
<a name="ln2140">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2141">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2142">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2143">  float rawval = d-&gt;callback(widget, pos, DT_BAUHAUS_SET);</a>
<a name="ln2144">  dt_bauhaus_slider_set_normalized(w, (rawval - d-&gt;min) / (d-&gt;max - d-&gt;min));</a>
<a name="ln2145">}</a>
<a name="ln2146"> </a>
<a name="ln2147">void dt_bauhaus_slider_set_digits(GtkWidget *widget, int val)</a>
<a name="ln2148">{</a>
<a name="ln2149">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2150"> </a>
<a name="ln2151">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2152"> </a>
<a name="ln2153">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2154"> </a>
<a name="ln2155">  d-&gt;digits = val;</a>
<a name="ln2156">  snprintf(d-&gt;format, sizeof(d-&gt;format), &quot;%%.0%df&quot;, val);</a>
<a name="ln2157">}</a>
<a name="ln2158"> </a>
<a name="ln2159">int dt_bauhaus_slider_get_digits(GtkWidget *widget)</a>
<a name="ln2160">{</a>
<a name="ln2161">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2162"> </a>
<a name="ln2163">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return 0;</a>
<a name="ln2164"> </a>
<a name="ln2165">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2166"> </a>
<a name="ln2167">  return d-&gt;digits;</a>
<a name="ln2168">}</a>
<a name="ln2169"> </a>
<a name="ln2170">void dt_bauhaus_slider_set_step(GtkWidget *widget, float val)</a>
<a name="ln2171">{</a>
<a name="ln2172">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2173"> </a>
<a name="ln2174">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2175"> </a>
<a name="ln2176">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2177"> </a>
<a name="ln2178">  d-&gt;step = val;</a>
<a name="ln2179">  d-&gt;scale = 5.0f * d-&gt;step / (d-&gt;max - d-&gt;min);</a>
<a name="ln2180">}</a>
<a name="ln2181"> </a>
<a name="ln2182">float dt_bauhaus_slider_get_step(GtkWidget *widget)</a>
<a name="ln2183">{</a>
<a name="ln2184">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2185"> </a>
<a name="ln2186">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return 0;</a>
<a name="ln2187"> </a>
<a name="ln2188">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2189"> </a>
<a name="ln2190">  return d-&gt;step;</a>
<a name="ln2191">}</a>
<a name="ln2192"> </a>
<a name="ln2193">void dt_bauhaus_slider_reset(GtkWidget *widget)</a>
<a name="ln2194">{</a>
<a name="ln2195">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2196"> </a>
<a name="ln2197">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2198">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2199"> </a>
<a name="ln2200">  d-&gt;min = d-&gt;soft_min;</a>
<a name="ln2201">  d-&gt;max = d-&gt;soft_max;</a>
<a name="ln2202">  dt_bauhaus_slider_set_normalized(w, d-&gt;defpos);</a>
<a name="ln2203"> </a>
<a name="ln2204">  return;</a>
<a name="ln2205">}</a>
<a name="ln2206"> </a>
<a name="ln2207">void dt_bauhaus_slider_set_format(GtkWidget *widget, const char *format)</a>
<a name="ln2208">{</a>
<a name="ln2209">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2210">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2211">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2212">  g_strlcpy(d-&gt;format, format, sizeof(d-&gt;format));</a>
<a name="ln2213">}</a>
<a name="ln2214"> </a>
<a name="ln2215">void dt_bauhaus_slider_set_callback(GtkWidget *widget, float (*callback)(GtkWidget *self, float value, dt_bauhaus_callback_t dir))</a>
<a name="ln2216">{</a>
<a name="ln2217">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2218">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2219">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2220">  d-&gt;callback = (callback == NULL ? _default_linear_callback : callback);</a>
<a name="ln2221">}</a>
<a name="ln2222"> </a>
<a name="ln2223">void dt_bauhaus_slider_set_soft(GtkWidget *widget, float pos)</a>
<a name="ln2224">{</a>
<a name="ln2225">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2226">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2227">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2228">  float rawval = d-&gt;callback(widget, pos, DT_BAUHAUS_SET);</a>
<a name="ln2229">  float rpos = CLAMP(rawval, d-&gt;hard_min, d-&gt;hard_max);</a>
<a name="ln2230">  d-&gt;min = MIN(d-&gt;min, rpos);</a>
<a name="ln2231">  d-&gt;max = MAX(d-&gt;max, rpos);</a>
<a name="ln2232">  d-&gt;scale = 5.0f * d-&gt;step / (d-&gt;max - d-&gt;min);</a>
<a name="ln2233">  rpos = (rpos - d-&gt;min) / (d-&gt;max - d-&gt;min);</a>
<a name="ln2234">  dt_bauhaus_slider_set_normalized(w, rpos);</a>
<a name="ln2235">}</a>
<a name="ln2236"> </a>
<a name="ln2237">static void dt_bauhaus_slider_set_normalized(dt_bauhaus_widget_t *w, float pos)</a>
<a name="ln2238">{</a>
<a name="ln2239">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2240">  float rpos = CLAMP(pos, 0.0f, 1.0f);</a>
<a name="ln2241">  rpos = d-&gt;min + (d-&gt;max - d-&gt;min) * rpos;</a>
<a name="ln2242">  const float base = powf(10.0f, d-&gt;digits);</a>
<a name="ln2243">  rpos = roundf(base * rpos) / base;</a>
<a name="ln2244">  d-&gt;pos = (rpos - d-&gt;min) / (d-&gt;max - d-&gt;min);</a>
<a name="ln2245">  gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln2246">  d-&gt;is_changed = 1;</a>
<a name="ln2247">  if(!darktable.gui-&gt;reset &amp;&amp; !d-&gt;is_dragging)</a>
<a name="ln2248">  {</a>
<a name="ln2249">    g_signal_emit_by_name(G_OBJECT(w), &quot;value-changed&quot;);</a>
<a name="ln2250">    d-&gt;is_changed = 0;</a>
<a name="ln2251"> </a>
<a name="ln2252">    if(!gtk_widget_is_visible(GTK_WIDGET(w)) &amp;&amp; *w-&gt;label)</a>
<a name="ln2253">    {</a>
<a name="ln2254">      char text[256];</a>
<a name="ln2255">      const float f = d-&gt;min + d-&gt;pos * (d-&gt;max - d-&gt;min);</a>
<a name="ln2256">      const float fc = d-&gt;callback(GTK_WIDGET(w), f, DT_BAUHAUS_GET);</a>
<a name="ln2257">      snprintf(text, sizeof(text), d-&gt;format, fc);</a>
<a name="ln2258"> </a>
<a name="ln2259">      if(w-&gt;module &amp;&amp; !strstr(w-&gt;module-&gt;name(), w-&gt;label))</a>
<a name="ln2260">        dt_control_log(_(&quot;%s/%s: %s&quot;), w-&gt;module-&gt;name(), w-&gt;label, text);</a>
<a name="ln2261">      else</a>
<a name="ln2262">        dt_control_log(_(&quot;%s: %s&quot;), w-&gt;label, text);</a>
<a name="ln2263">    }</a>
<a name="ln2264">  }</a>
<a name="ln2265">}</a>
<a name="ln2266"> </a>
<a name="ln2267">static gboolean dt_bauhaus_slider_postponed_value_change(gpointer data)</a>
<a name="ln2268">{</a>
<a name="ln2269">  if(!GTK_IS_WIDGET(data)) return 0;</a>
<a name="ln2270"> </a>
<a name="ln2271">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)data;</a>
<a name="ln2272">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2273">  if(d-&gt;is_changed)</a>
<a name="ln2274">  {</a>
<a name="ln2275">    g_signal_emit_by_name(G_OBJECT(w), &quot;value-changed&quot;);</a>
<a name="ln2276">    d-&gt;is_changed = 0;</a>
<a name="ln2277">  }</a>
<a name="ln2278"> </a>
<a name="ln2279">  if(!d-&gt;is_dragging) d-&gt;timeout_handle = 0;</a>
<a name="ln2280"> </a>
<a name="ln2281">  return d-&gt;is_dragging;</a>
<a name="ln2282">}</a>
<a name="ln2283"> </a>
<a name="ln2284">static gboolean dt_bauhaus_popup_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data)</a>
<a name="ln2285">{</a>
<a name="ln2286">  switch(darktable.bauhaus-&gt;current-&gt;type)</a>
<a name="ln2287">  {</a>
<a name="ln2288">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln2289">    {</a>
<a name="ln2290">      // hack to do screenshots from popup:</a>
<a name="ln2291">      // if(event-&gt;string[0] == 'p') return system(&quot;scrot&quot;);</a>
<a name="ln2292">      // else</a>
<a name="ln2293">      if(darktable.bauhaus-&gt;keys_cnt + 2 &lt; 64</a>
<a name="ln2294">         &amp;&amp; (event-&gt;keyval == GDK_KEY_space || event-&gt;keyval == GDK_KEY_KP_Space || // SPACE</a>
<a name="ln2295">             event-&gt;keyval == GDK_KEY_percent ||                                    // %</a>
<a name="ln2296">             (event-&gt;string[0] &gt;= 40 &amp;&amp; event-&gt;string[0] &lt;= 57) ||                  // ()+-*/.,0-9</a>
<a name="ln2297">             event-&gt;keyval == GDK_KEY_asciicircum ||                                // ^</a>
<a name="ln2298">             event-&gt;keyval == GDK_KEY_X || event-&gt;keyval == GDK_KEY_x))             // Xx</a>
<a name="ln2299">      {</a>
<a name="ln2300">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt++] = event-&gt;string[0];</a>
<a name="ln2301">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2302">      }</a>
<a name="ln2303">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0</a>
<a name="ln2304">              &amp;&amp; (event-&gt;keyval == GDK_KEY_BackSpace || event-&gt;keyval == GDK_KEY_Delete))</a>
<a name="ln2305">      {</a>
<a name="ln2306">        darktable.bauhaus-&gt;keys[--darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2307">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2308">      }</a>
<a name="ln2309">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0 &amp;&amp; darktable.bauhaus-&gt;keys_cnt + 1 &lt; 64</a>
<a name="ln2310">              &amp;&amp; (event-&gt;keyval == GDK_KEY_Return || event-&gt;keyval == GDK_KEY_KP_Enter))</a>
<a name="ln2311">      {</a>
<a name="ln2312">        // accept input</a>
<a name="ln2313">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2314">        // unnormalized input, user was typing this:</a>
<a name="ln2315">        float old_value = dt_bauhaus_slider_get(GTK_WIDGET(darktable.bauhaus-&gt;current));</a>
<a name="ln2316">        float new_value = dt_calculator_solve(old_value, darktable.bauhaus-&gt;keys);</a>
<a name="ln2317">        if(isfinite(new_value)) dt_bauhaus_slider_set_soft(GTK_WIDGET(darktable.bauhaus-&gt;current), new_value);</a>
<a name="ln2318">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2319">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2320">        dt_bauhaus_hide_popup();</a>
<a name="ln2321">      }</a>
<a name="ln2322">      else if(event-&gt;keyval == GDK_KEY_Escape)</a>
<a name="ln2323">      {</a>
<a name="ln2324">        // discard input and close popup</a>
<a name="ln2325">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2326">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2327">        dt_bauhaus_hide_popup();</a>
<a name="ln2328">      }</a>
<a name="ln2329">      else</a>
<a name="ln2330">        return FALSE;</a>
<a name="ln2331">      if(darktable.bauhaus-&gt;keys_cnt &gt; 0) _start_cursor(-1);</a>
<a name="ln2332">      return TRUE;</a>
<a name="ln2333">    }</a>
<a name="ln2334">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln2335">    {</a>
<a name="ln2336">      if(!g_utf8_validate(event-&gt;string, -1, NULL)) return FALSE;</a>
<a name="ln2337">      gunichar c = g_utf8_get_char(event-&gt;string);</a>
<a name="ln2338">      long int char_width = g_utf8_next_char(event-&gt;string) - event-&gt;string;</a>
<a name="ln2339">      // if(event-&gt;string[0] == 'p') return system(&quot;scrot&quot;);</a>
<a name="ln2340">      // else</a>
<a name="ln2341">      if(darktable.bauhaus-&gt;keys_cnt + 1 + char_width &lt; 64 &amp;&amp; g_unichar_isprint(c))</a>
<a name="ln2342">      {</a>
<a name="ln2343">        // only accept key input if still valid or editable?</a>
<a name="ln2344">        g_utf8_strncpy(darktable.bauhaus-&gt;keys + darktable.bauhaus-&gt;keys_cnt, event-&gt;string, 1);</a>
<a name="ln2345">        darktable.bauhaus-&gt;keys_cnt += char_width;</a>
<a name="ln2346">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2347">      }</a>
<a name="ln2348">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0</a>
<a name="ln2349">              &amp;&amp; (event-&gt;keyval == GDK_KEY_BackSpace || event-&gt;keyval == GDK_KEY_Delete))</a>
<a name="ln2350">      {</a>
<a name="ln2351">        darktable.bauhaus-&gt;keys_cnt</a>
<a name="ln2352">            -= (darktable.bauhaus-&gt;keys + darktable.bauhaus-&gt;keys_cnt)</a>
<a name="ln2353">               - g_utf8_prev_char(darktable.bauhaus-&gt;keys + darktable.bauhaus-&gt;keys_cnt);</a>
<a name="ln2354">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2355">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2356">      }</a>
<a name="ln2357">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0 &amp;&amp; darktable.bauhaus-&gt;keys_cnt + 1 &lt; 64</a>
<a name="ln2358">              &amp;&amp; (event-&gt;keyval == GDK_KEY_Return || event-&gt;keyval == GDK_KEY_KP_Enter))</a>
<a name="ln2359">      {</a>
<a name="ln2360">        // accept unique matches only for editable:</a>
<a name="ln2361">        if(darktable.bauhaus-&gt;current-&gt;data.combobox.editable)</a>
<a name="ln2362">          darktable.bauhaus-&gt;end_mouse_y = FLT_MAX;</a>
<a name="ln2363">        else</a>
<a name="ln2364">          darktable.bauhaus-&gt;end_mouse_y = 0;</a>
<a name="ln2365">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2366">        dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln2367">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2368">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2369">        dt_bauhaus_hide_popup();</a>
<a name="ln2370">      }</a>
<a name="ln2371">      else if(event-&gt;keyval == GDK_KEY_Escape)</a>
<a name="ln2372">      {</a>
<a name="ln2373">        // discard input and close popup</a>
<a name="ln2374">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2375">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2376">        dt_bauhaus_hide_popup();</a>
<a name="ln2377">      }</a>
<a name="ln2378">      else if(event-&gt;keyval == GDK_KEY_Up)</a>
<a name="ln2379">      {</a>
<a name="ln2380">        combobox_popup_scroll(-1);</a>
<a name="ln2381">      }</a>
<a name="ln2382">      else if(event-&gt;keyval == GDK_KEY_Down)</a>
<a name="ln2383">      {</a>
<a name="ln2384">        combobox_popup_scroll(1);</a>
<a name="ln2385">      }</a>
<a name="ln2386">      else if(event-&gt;keyval == GDK_KEY_Return || event-&gt;keyval == GDK_KEY_KP_Enter)</a>
<a name="ln2387">      {</a>
<a name="ln2388">        // return pressed, but didn't type anything</a>
<a name="ln2389">        darktable.bauhaus-&gt;end_mouse_y = -1; // negative will use currently highlighted instead.</a>
<a name="ln2390">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2391">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2392">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2393">        dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln2394">        dt_bauhaus_hide_popup();</a>
<a name="ln2395">      }</a>
<a name="ln2396">      else</a>
<a name="ln2397">        return FALSE;</a>
<a name="ln2398">      return TRUE;</a>
<a name="ln2399">    }</a>
<a name="ln2400">    default:</a>
<a name="ln2401">      return FALSE;</a>
<a name="ln2402">  }</a>
<a name="ln2403">}</a>
<a name="ln2404"> </a>
<a name="ln2405">static gboolean dt_bauhaus_slider_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2406">{</a>
<a name="ln2407">  GtkAllocation allocation;</a>
<a name="ln2408">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln2409">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2410">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2411">  gtk_widget_grab_focus(GTK_WIDGET(w));</a>
<a name="ln2412">  gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2413"> </a>
<a name="ln2414"> </a>
<a name="ln2415">  GtkAllocation tmp;</a>
<a name="ln2416">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2417">  if(w-&gt;quad_paint &amp;&amp; (event-&gt;x &gt; allocation.width - darktable.bauhaus-&gt;quad_width))</a>
<a name="ln2418">  {</a>
<a name="ln2419">    if (w-&gt;quad_toggle)</a>
<a name="ln2420">    {</a>
<a name="ln2421">      if (w-&gt;quad_paint_flags &amp; CPF_ACTIVE)</a>
<a name="ln2422">        w-&gt;quad_paint_flags &amp;= ~CPF_ACTIVE;</a>
<a name="ln2423">      else</a>
<a name="ln2424">        w-&gt;quad_paint_flags |= CPF_ACTIVE;</a>
<a name="ln2425">    }</a>
<a name="ln2426">    g_signal_emit_by_name(G_OBJECT(w), &quot;quad-pressed&quot;);</a>
<a name="ln2427">    return TRUE;</a>
<a name="ln2428">  }</a>
<a name="ln2429">  else if(event-&gt;button == 3)</a>
<a name="ln2430">  {</a>
<a name="ln2431">    dt_bauhaus_show_popup(w);</a>
<a name="ln2432">    return TRUE;</a>
<a name="ln2433">  }</a>
<a name="ln2434">  else if(event-&gt;button == 1)</a>
<a name="ln2435">  {</a>
<a name="ln2436">    // reset to default.</a>
<a name="ln2437">    if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln2438">    {</a>
<a name="ln2439">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2440">      d-&gt;is_dragging = 0;</a>
<a name="ln2441">      dt_bauhaus_slider_reset(GTK_WIDGET(w));</a>
<a name="ln2442">    }</a>
<a name="ln2443">    else</a>
<a name="ln2444">    {</a>
<a name="ln2445">      const float l = 0.0f;</a>
<a name="ln2446">      const float r = slider_right_pos((float)tmp.width);</a>
<a name="ln2447">      dt_bauhaus_slider_set_normalized(w, (event-&gt;x / tmp.width - l) / (r - l));</a>
<a name="ln2448">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2449">      d-&gt;is_dragging = 1;</a>
<a name="ln2450">      int delay = CLAMP(darktable.develop-&gt;average_delay * 3 / 2, DT_BAUHAUS_SLIDER_VALUE_CHANGED_DELAY_MIN,</a>
<a name="ln2451">                        DT_BAUHAUS_SLIDER_VALUE_CHANGED_DELAY_MAX);</a>
<a name="ln2452">      // timeout_handle should always be zero here, but check just in case</a>
<a name="ln2453">      if(!d-&gt;timeout_handle)</a>
<a name="ln2454">        d-&gt;timeout_handle = g_timeout_add(delay, dt_bauhaus_slider_postponed_value_change, widget);</a>
<a name="ln2455">    }</a>
<a name="ln2456">    return TRUE;</a>
<a name="ln2457">  }</a>
<a name="ln2458">  return FALSE;</a>
<a name="ln2459">}</a>
<a name="ln2460"> </a>
<a name="ln2461">static gboolean dt_bauhaus_slider_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2462">{</a>
<a name="ln2463">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2464">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2465"> </a>
<a name="ln2466">  if((event-&gt;button == 1) &amp;&amp; (d-&gt;is_dragging))</a>
<a name="ln2467">  {</a>
<a name="ln2468">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2469">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2470"> </a>
<a name="ln2471">    GtkAllocation tmp;</a>
<a name="ln2472">    gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2473">    d-&gt;is_dragging = 0;</a>
<a name="ln2474">    if(d-&gt;timeout_handle) g_source_remove(d-&gt;timeout_handle);</a>
<a name="ln2475">    d-&gt;timeout_handle = 0;</a>
<a name="ln2476">    const float l = 0.0f;</a>
<a name="ln2477">    const float r = slider_right_pos((float)tmp.width);</a>
<a name="ln2478">    dt_bauhaus_slider_set_normalized(w, (event-&gt;x / tmp.width - l) / (r - l));</a>
<a name="ln2479"> </a>
<a name="ln2480">    return TRUE;</a>
<a name="ln2481">  }</a>
<a name="ln2482">  return FALSE;</a>
<a name="ln2483">}</a>
<a name="ln2484"> </a>
<a name="ln2485">static gboolean dt_bauhaus_slider_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln2486">{</a>
<a name="ln2487">  // remember mouse position for motion effects in draw</a>
<a name="ln2488">  if(event-&gt;state &amp; GDK_BUTTON1_MASK &amp;&amp; event-&gt;type != GDK_2BUTTON_PRESS)</a>
<a name="ln2489">  {</a>
<a name="ln2490">    dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2491">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2492">    gtk_widget_set_state_flags(GTK_WIDGET(w), GTK_STATE_FLAG_FOCUSED, TRUE);</a>
<a name="ln2493">    GtkAllocation tmp;</a>
<a name="ln2494">    gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2495">    const float l = 0.0f;</a>
<a name="ln2496">    const float r = slider_right_pos((float)tmp.width);</a>
<a name="ln2497">    dt_bauhaus_slider_set_normalized(w, (event-&gt;x / tmp.width - l) / (r - l));</a>
<a name="ln2498">  }</a>
<a name="ln2499">  // not sure if needed:</a>
<a name="ln2500">  // gdk_event_request_motions(event);</a>
<a name="ln2501">  return TRUE;</a>
<a name="ln2502">}</a>
<a name="ln2503"> </a>
<a name="ln2504">void dt_bauhaus_vimkey_exec(const char *input)</a>
<a name="ln2505">{</a>
<a name="ln2506">  char module[64], label[64], value[256], *key;</a>
<a name="ln2507">  float old_value, new_value;</a>
<a name="ln2508"> </a>
<a name="ln2509">  sscanf(input, &quot;:set %63[^.].%63[^=]=%255s&quot;, module, label, value);</a>
<a name="ln2510">  fprintf(stderr, &quot;[vimkey] setting module `%s', slider `%s' to `%s'&quot;, module, label, value);</a>
<a name="ln2511">  key = g_strjoin(&quot;.&quot;, module, label, NULL);</a>
<a name="ln2512">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)g_hash_table_lookup(darktable.bauhaus-&gt;keymap, key);</a>
<a name="ln2513">  g_free(key);</a>
<a name="ln2514">  if(!w) return;</a>
<a name="ln2515">  switch(w-&gt;type)</a>
<a name="ln2516">  {</a>
<a name="ln2517">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln2518">      old_value = dt_bauhaus_slider_get(GTK_WIDGET(w));</a>
<a name="ln2519">      new_value = dt_calculator_solve(old_value, value);</a>
<a name="ln2520">      fprintf(stderr, &quot; = %f\n&quot;, new_value);</a>
<a name="ln2521">      if(isfinite(new_value)) dt_bauhaus_slider_set_soft(GTK_WIDGET(w), new_value);</a>
<a name="ln2522">      break;</a>
<a name="ln2523">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln2524">      // TODO: what about text as entry?</a>
<a name="ln2525">      old_value = dt_bauhaus_combobox_get(GTK_WIDGET(w));</a>
<a name="ln2526">      new_value = dt_calculator_solve(old_value, value);</a>
<a name="ln2527">      fprintf(stderr, &quot; = %f\n&quot;, new_value);</a>
<a name="ln2528">      if(isfinite(new_value)) dt_bauhaus_combobox_set(GTK_WIDGET(w), new_value);</a>
<a name="ln2529">      break;</a>
<a name="ln2530">    default:</a>
<a name="ln2531">      break;</a>
<a name="ln2532">  }</a>
<a name="ln2533">}</a>
<a name="ln2534"> </a>
<a name="ln2535">// give autocomplete suggestions</a>
<a name="ln2536">GList *dt_bauhaus_vimkey_complete(const char *input)</a>
<a name="ln2537">{</a>
<a name="ln2538">  GList *cmp = darktable.bauhaus-&gt;key_mod;</a>
<a name="ln2539">  char *point = strstr(input, &quot;.&quot;);</a>
<a name="ln2540">  if(point) cmp = darktable.bauhaus-&gt;key_val;</a>
<a name="ln2541">  int prefix = strlen(input);</a>
<a name="ln2542">  GList *res = NULL;</a>
<a name="ln2543">  int after = 0;</a>
<a name="ln2544">  while(cmp)</a>
<a name="ln2545">  {</a>
<a name="ln2546">    char *path = (char *)cmp-&gt;data;</a>
<a name="ln2547">    if(strncasecmp(path, input, prefix))</a>
<a name="ln2548">    {</a>
<a name="ln2549">      if(after) break; // sorted, so we're done</a>
<a name="ln2550">                       // else loop till we find the start of it</a>
<a name="ln2551">    }</a>
<a name="ln2552">    else</a>
<a name="ln2553">    {</a>
<a name="ln2554">      // append:</a>
<a name="ln2555">      res = g_list_insert_sorted(res, path, (GCompareFunc)strcmp);</a>
<a name="ln2556">      after = 1;</a>
<a name="ln2557">    }</a>
<a name="ln2558">    cmp = g_list_next(cmp);</a>
<a name="ln2559">  }</a>
<a name="ln2560">  return res;</a>
<a name="ln2561">}</a>
<a name="ln2562"> </a>
<a name="ln2563">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2564">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2565">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="67"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'entry'. Check lines: 67, 66.</p></div>
<div class="balloon" rel="542"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v636/" target="_blank">V636</a> The 'pango_height / 1024' expression was implicitly cast from 'int' type to 'float' type. Consider utilizing an explicit type cast to avoid the loss of a fractional part. An example: double A = (double)(X) / Y;.</p></div>
<div class="balloon" rel="554"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'darktable.bauhaus'. Check lines: 554, 553.</p></div>
<div class="balloon" rel="1589"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v656/" target="_blank">V656</a> Variables 'fg_color', 'bg_color' are initialized through the call to the same function. It's probably an error or un-optimized code. Consider inspecting the 'default_color_assign()' expression. Check lines: 1588, 1589.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
