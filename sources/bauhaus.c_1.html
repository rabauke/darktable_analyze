
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012 johannes hanika.</a>
<a name="ln4">    copyright (c) 2012--2014 tobias ellinghaus.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln21">#include &quot;common/calculator.h&quot;</a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;develop/develop.h&quot;</a>
<a name="ln25">#include &quot;gui/gtk.h&quot;</a>
<a name="ln26">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln27">#include &quot;osx/osx.h&quot;</a>
<a name="ln28">#endif</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;math.h&gt;</a>
<a name="ln31">#include &lt;pango/pangocairo.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">G_DEFINE_TYPE(DtBauhausWidget, dt_bh, GTK_TYPE_DRAWING_AREA)</a>
<a name="ln34"> </a>
<a name="ln35">// fwd declare</a>
<a name="ln36">static gboolean dt_bauhaus_popup_draw(GtkWidget *widget, cairo_t *cr, gpointer user_data);</a>
<a name="ln37">static gboolean dt_bauhaus_popup_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);</a>
<a name="ln38">static void dt_bauhaus_widget_accept(dt_bauhaus_widget_t *w);</a>
<a name="ln39">static void dt_bauhaus_widget_reject(dt_bauhaus_widget_t *w);</a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">static int get_line_space()</a>
<a name="ln43">{</a>
<a name="ln44">  return darktable.bauhaus-&gt;scale * darktable.bauhaus-&gt;line_space;</a>
<a name="ln45">}</a>
<a name="ln46"> </a>
<a name="ln47">static int get_line_height()</a>
<a name="ln48">{</a>
<a name="ln49">  return darktable.bauhaus-&gt;scale * darktable.bauhaus-&gt;line_height;</a>
<a name="ln50">}</a>
<a name="ln51"> </a>
<a name="ln52">static float get_marker_size()</a>
<a name="ln53">{</a>
<a name="ln54">  // will be fraction of the height, so doesn't depend on scale itself.</a>
<a name="ln55">  return darktable.bauhaus-&gt;marker_size;</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">// TODO: remove / make use of the pango font size / X height</a>
<a name="ln59">static float get_label_font_size()</a>
<a name="ln60">{</a>
<a name="ln61">  return get_line_height() * darktable.bauhaus-&gt;label_font_size;</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">static inline void set_color(cairo_t *cr, GdkRGBA color)</a>
<a name="ln65">{</a>
<a name="ln66">  cairo_set_source_rgba(cr, color.red, color.green, color.blue, color.alpha);</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">static int show_pango_text(cairo_t *cr, char *text, float x_pos, float y_pos, float max_width, gboolean right_aligned)</a>
<a name="ln70">{</a>
<a name="ln71">  PangoLayout *layout;</a>
<a name="ln72"> </a>
<a name="ln73">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln74"> </a>
<a name="ln75">  if(max_width &gt; 0)</a>
<a name="ln76">  {</a>
<a name="ln77">    pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_MIDDLE);</a>
<a name="ln78">    pango_layout_set_width(layout, (int)(PANGO_SCALE * max_width + 0.5f));</a>
<a name="ln79">  }</a>
<a name="ln80"> </a>
<a name="ln81">  if(text) {</a>
<a name="ln82">    pango_layout_set_text(layout, text, -1);</a>
<a name="ln83">  } else {</a>
<a name="ln84">    // length of -1 is not allowed with NULL string (wtf)</a>
<a name="ln85">    pango_layout_set_text(layout, NULL, 0);</a>
<a name="ln86">  }</a>
<a name="ln87"> </a>
<a name="ln88">  pango_layout_set_font_description(layout, darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln89">  pango_cairo_context_set_resolution(pango_layout_get_context(layout), darktable.gui-&gt;dpi);</a>
<a name="ln90"> </a>
<a name="ln91">  int pango_width, pango_height;</a>
<a name="ln92">  pango_layout_get_size(layout, &amp;pango_width, &amp;pango_height);</a>
<a name="ln93">  float text_width = ((double)pango_width/PANGO_SCALE);</a>
<a name="ln94"> </a>
<a name="ln95">  if(right_aligned) x_pos -= text_width;</a>
<a name="ln96"> </a>
<a name="ln97">  cairo_move_to(cr, x_pos, y_pos);</a>
<a name="ln98">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln99">  g_object_unref(layout);</a>
<a name="ln100"> </a>
<a name="ln101">  return text_width;</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104">// -------------------------------</a>
<a name="ln105">static gboolean _cursor_timeout_callback(gpointer user_data)</a>
<a name="ln106">{</a>
<a name="ln107">  if(darktable.bauhaus-&gt;cursor_blink_counter &gt; 0) darktable.bauhaus-&gt;cursor_blink_counter--;</a>
<a name="ln108"> </a>
<a name="ln109">  darktable.bauhaus-&gt;cursor_visible = !darktable.bauhaus-&gt;cursor_visible;</a>
<a name="ln110">  gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln111"> </a>
<a name="ln112">  if(darktable.bauhaus-&gt;cursor_blink_counter</a>
<a name="ln113">     != 0) // this can be &gt;0 when we haven't reached the desired number or -1 when blinking forever</a>
<a name="ln114">    return TRUE;</a>
<a name="ln115"> </a>
<a name="ln116">  darktable.bauhaus-&gt;cursor_timeout = 0; // otherwise the cursor won't come up when starting to type</a>
<a name="ln117">  return FALSE;</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">static void _start_cursor(int max_blinks)</a>
<a name="ln121">{</a>
<a name="ln122">  darktable.bauhaus-&gt;cursor_blink_counter = max_blinks;</a>
<a name="ln123">  darktable.bauhaus-&gt;cursor_visible = FALSE;</a>
<a name="ln124">  if(darktable.bauhaus-&gt;cursor_timeout == 0)</a>
<a name="ln125">    darktable.bauhaus-&gt;cursor_timeout = g_timeout_add(500, _cursor_timeout_callback, NULL);</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">static void _stop_cursor()</a>
<a name="ln129">{</a>
<a name="ln130">  if(darktable.bauhaus-&gt;cursor_timeout &gt; 0)</a>
<a name="ln131">  {</a>
<a name="ln132">    g_source_remove(darktable.bauhaus-&gt;cursor_timeout);</a>
<a name="ln133">    darktable.bauhaus-&gt;cursor_timeout = 0;</a>
<a name="ln134">    darktable.bauhaus-&gt;cursor_visible = FALSE;</a>
<a name="ln135">  }</a>
<a name="ln136">}</a>
<a name="ln137">// -------------------------------</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">static void dt_bauhaus_slider_set_normalized(dt_bauhaus_widget_t *w, float pos);</a>
<a name="ln141"> </a>
<a name="ln142">static float get_slider_line_offset(float pos, float scale, float x, float y, float ht, const int width)</a>
<a name="ln143">{</a>
<a name="ln144">  // ht is in [0,1] scale here</a>
<a name="ln145">  const float l = 4.0f / width;</a>
<a name="ln146">  const float r = 1.0f - 4.0f / width - ht;</a>
<a name="ln147"> </a>
<a name="ln148">  float offset = 0.0f;</a>
<a name="ln149">  // handle linear startup and rescale y to fit the whole range again</a>
<a name="ln150">  if(y &lt; ht)</a>
<a name="ln151">  {</a>
<a name="ln152">    offset = (x - l) / (r - l) - pos;</a>
<a name="ln153">  }</a>
<a name="ln154">  else</a>
<a name="ln155">  {</a>
<a name="ln156">    y -= ht;</a>
<a name="ln157">    y /= (1.0f - ht);</a>
<a name="ln158"> </a>
<a name="ln159">    // x = y^2 * .5(1+off/scale) + (1-y^2)*(l + (pos+off)*(r-l))</a>
<a name="ln160">    // now find off given pos, y, and x:</a>
<a name="ln161">    // x - y^2*.5 - (1-y^2)*pos = y^2*.5f*off/scale + (1-y^2)off</a>
<a name="ln162">    //                          = off ((.5f/scale-1)*y^2 + 1)</a>
<a name="ln163">    // return (x - y*y*.5f - (1.0f-y*y)*pos)/((.5f/scale-1.f)*y*y + 1.0f);</a>
<a name="ln164"> </a>
<a name="ln165">    offset = (x - y * y * .5f - (1.0f - y * y) * (l + pos * (r - l)))</a>
<a name="ln166">             / (.5f * y * y / scale + (1.0f - y * y) * (r - l));</a>
<a name="ln167">  }</a>
<a name="ln168">  // clamp to result in a [0,1] range:</a>
<a name="ln169">  if(pos + offset &gt; 1.0f) offset = 1.0f - pos;</a>
<a name="ln170">  if(pos + offset &lt; 0.0f) offset = -pos;</a>
<a name="ln171">  return offset;</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">// draw a loupe guideline for the quadratic zoom in in the slider interface:</a>
<a name="ln175">static void draw_slider_line(cairo_t *cr, float pos, float off, float scale, const int width,</a>
<a name="ln176">                             const int height, const int ht)</a>
<a name="ln177">{</a>
<a name="ln178">  // pos is normalized position [0,1], offset is on that scale.</a>
<a name="ln179">  // ht is in pixels here</a>
<a name="ln180">  const float l = 4.0f / width;</a>
<a name="ln181">  const float r = 1.0f - (ht + 4.0f) / width;</a>
<a name="ln182"> </a>
<a name="ln183">  const int steps = 64;</a>
<a name="ln184">  cairo_move_to(cr, width * (l + (pos + off) * (r - l)), ht * .7f);</a>
<a name="ln185">  cairo_line_to(cr, width * (l + (pos + off) * (r - l)), ht);</a>
<a name="ln186">  for(int j = 1; j &lt; steps; j++)</a>
<a name="ln187">  {</a>
<a name="ln188">    const float y = j / (steps - 1.0f);</a>
<a name="ln189">    const float x = y * y * .5f * (1.f + off / scale) + (1.0f - y * y) * (l + (pos + off) * (r - l));</a>
<a name="ln190">    cairo_line_to(cr, x * width, ht + y * (height - ht));</a>
<a name="ln191">  }</a>
<a name="ln192">}</a>
<a name="ln193">// -------------------------------</a>
<a name="ln194"> </a>
<a name="ln195">// handlers on the popup window, to close popup:</a>
<a name="ln196">static gboolean dt_bauhaus_window_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln197">{</a>
<a name="ln198">  const float tol = 50;</a>
<a name="ln199">  gint wx, wy;</a>
<a name="ln200">  GtkAllocation allocation;</a>
<a name="ln201">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln202">  gdk_window_get_origin(gtk_widget_get_window(widget), &amp;wx, &amp;wy);</a>
<a name="ln203">  if(event-&gt;x_root &gt; wx + allocation.width + tol || event-&gt;y_root &gt; wy + allocation.height + tol</a>
<a name="ln204">     || event-&gt;x_root &lt; (int)wx - tol || event-&gt;y_root &lt; (int)wy - tol)</a>
<a name="ln205">  {</a>
<a name="ln206">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln207">    dt_bauhaus_hide_popup();</a>
<a name="ln208">    return TRUE;</a>
<a name="ln209">  }</a>
<a name="ln210">  // make sure to propagate the event further</a>
<a name="ln211">  return FALSE;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">static gboolean dt_bauhaus_window_button_press(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln215">{</a>
<a name="ln216">  const float tol = 0;</a>
<a name="ln217">  gint wx, wy;</a>
<a name="ln218">  GtkAllocation allocation;</a>
<a name="ln219">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln220">  gdk_window_get_origin(gtk_widget_get_window(widget), &amp;wx, &amp;wy);</a>
<a name="ln221">  if((event-&gt;x_root &gt; wx + allocation.width + tol || event-&gt;y_root &gt; wy + allocation.height + tol</a>
<a name="ln222">      || event-&gt;x_root &lt; (int)wx - tol || event-&gt;y_root &lt; (int)wy - tol))</a>
<a name="ln223">  {</a>
<a name="ln224">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln225">    dt_bauhaus_hide_popup();</a>
<a name="ln226">    return TRUE;</a>
<a name="ln227">  }</a>
<a name="ln228">  // make sure to propagate the event further</a>
<a name="ln229">  return FALSE;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">static void combobox_popup_scroll(int amt)</a>
<a name="ln233">{</a>
<a name="ln234">  gint wx, wy;</a>
<a name="ln235">  GtkWidget *w = GTK_WIDGET(darktable.bauhaus-&gt;current);</a>
<a name="ln236">  GtkAllocation allocation_w;</a>
<a name="ln237">  gtk_widget_get_allocation(w, &amp;allocation_w);</a>
<a name="ln238">  const int ht = allocation_w.height;</a>
<a name="ln239">  const int skip = ht + get_line_space();</a>
<a name="ln240">  gdk_window_get_origin(gtk_widget_get_window(w), &amp;wx, &amp;wy);</a>
<a name="ln241">  dt_bauhaus_combobox_data_t *d = &amp;darktable.bauhaus-&gt;current-&gt;data.combobox;</a>
<a name="ln242">  const int new_value = CLAMP(d-&gt;active + amt, 0, d-&gt;num_labels - 1);</a>
<a name="ln243"> </a>
<a name="ln244">  // we move the popup up or down</a>
<a name="ln245">  if(new_value == d-&gt;active)</a>
<a name="ln246">  {</a>
<a name="ln247">    gdk_window_move(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), wx, wy - d-&gt;active * skip);</a>
<a name="ln248">  }</a>
<a name="ln249">  else</a>
<a name="ln250">  {</a>
<a name="ln251">    gint px, py;</a>
<a name="ln252">    gdk_window_get_origin(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), &amp;px, &amp;py);</a>
<a name="ln253">    gdk_window_move(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), wx, py - skip * amt);</a>
<a name="ln254">  }</a>
<a name="ln255"> </a>
<a name="ln256">  // make sure highlighted entry is updated:</a>
<a name="ln257">  darktable.bauhaus-&gt;mouse_x = 0;</a>
<a name="ln258">  darktable.bauhaus-&gt;mouse_y = new_value * skip + ht / 2;</a>
<a name="ln259">  gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln260"> </a>
<a name="ln261">  // and we change the value</a>
<a name="ln262">  dt_bauhaus_combobox_set(w, new_value);</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265"> </a>
<a name="ln266">static gboolean dt_bauhaus_popup_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln267">{</a>
<a name="ln268">  int delta_y;</a>
<a name="ln269">  switch(darktable.bauhaus-&gt;current-&gt;type)</a>
<a name="ln270">  {</a>
<a name="ln271">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln272">      if(dt_gui_get_scroll_unit_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln273">         combobox_popup_scroll(delta_y);</a>
<a name="ln274">      break;</a>
<a name="ln275">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln276">      break;</a>
<a name="ln277">    default:</a>
<a name="ln278">      break;</a>
<a name="ln279">  }</a>
<a name="ln280">  return TRUE;</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">static gboolean dt_bauhaus_popup_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln284">{</a>
<a name="ln285">  GtkAllocation allocation_popup_window;</a>
<a name="ln286">  gtk_widget_get_allocation(darktable.bauhaus-&gt;popup_window, &amp;allocation_popup_window);</a>
<a name="ln287">  gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln288">  dt_bauhaus_widget_t *w = darktable.bauhaus-&gt;current;</a>
<a name="ln289">  GtkAllocation allocation_w;</a>
<a name="ln290">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;allocation_w);</a>
<a name="ln291">  int width = allocation_popup_window.width, height = allocation_popup_window.height;</a>
<a name="ln292">  // coordinate transform is in vain because we're only ever called after a button release.</a>
<a name="ln293">  // that means the system is always the one of the popup.</a>
<a name="ln294">  // that also means that we can't have hovering combobox entries while still holding the button. :(</a>
<a name="ln295">  const float ex = event-&gt;x;</a>
<a name="ln296">  const float ey = event-&gt;y;</a>
<a name="ln297">  GtkAllocation allocation;</a>
<a name="ln298">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln299"> </a>
<a name="ln300">  if(darktable.bauhaus-&gt;keys_cnt == 0) _stop_cursor();</a>
<a name="ln301"> </a>
<a name="ln302">  switch(w-&gt;type)</a>
<a name="ln303">  {</a>
<a name="ln304">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln305">      darktable.bauhaus-&gt;mouse_x = ex;</a>
<a name="ln306">      darktable.bauhaus-&gt;mouse_y = ey;</a>
<a name="ln307">      break;</a>
<a name="ln308">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln309">    {</a>
<a name="ln310">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln311">      const float mouse_off = get_slider_line_offset(d-&gt;oldpos, d-&gt;scale, ex / width, ey / height,</a>
<a name="ln312">                                                     allocation_w.height / (float)height, allocation.width);</a>
<a name="ln313">      if(!darktable.bauhaus-&gt;change_active)</a>
<a name="ln314">      {</a>
<a name="ln315">        if((darktable.bauhaus-&gt;mouse_line_distance &lt; 0 &amp;&amp; mouse_off &gt;= 0)</a>
<a name="ln316">           || (darktable.bauhaus-&gt;mouse_line_distance &gt; 0 &amp;&amp; mouse_off &lt;= 0))</a>
<a name="ln317">          darktable.bauhaus-&gt;change_active = 1;</a>
<a name="ln318">        darktable.bauhaus-&gt;mouse_line_distance = mouse_off;</a>
<a name="ln319">      }</a>
<a name="ln320">      if(darktable.bauhaus-&gt;change_active)</a>
<a name="ln321">      {</a>
<a name="ln322">        // remember mouse position for motion effects in draw</a>
<a name="ln323">        darktable.bauhaus-&gt;mouse_x = ex;</a>
<a name="ln324">        darktable.bauhaus-&gt;mouse_y = ey;</a>
<a name="ln325">        dt_bauhaus_slider_set_normalized(w, d-&gt;oldpos + mouse_off);</a>
<a name="ln326">      }</a>
<a name="ln327">    }</a>
<a name="ln328">    break;</a>
<a name="ln329">    default:</a>
<a name="ln330">      break;</a>
<a name="ln331">  }</a>
<a name="ln332">  // throttling using motion hint:</a>
<a name="ln333">  // gdk_event_request_motions(event);</a>
<a name="ln334">  return TRUE;</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337">static gboolean dt_bauhaus_popup_leave_notify(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln338">{</a>
<a name="ln339">// all that doesn't seem to work (more events are created than necessary, exits at random</a>
<a name="ln340">// during popup already etc.</a>
<a name="ln341">#if 0</a>
<a name="ln342">  // if(event-&gt;x &gt; allocation.width + 20 || event-&gt;y &gt; allocation.height + 20 ||</a>
<a name="ln343">  // event-&gt;x &lt; -20 || event-&gt;y &lt; -20)</a>
<a name="ln344">  if(!event-&gt;state)</a>
<a name="ln345">  {</a>
<a name="ln346">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln347">    dt_bauhaus_hide_popup();</a>
<a name="ln348">  }</a>
<a name="ln349">#endif</a>
<a name="ln350">  return TRUE;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">static gboolean dt_bauhaus_popup_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln354">{</a>
<a name="ln355">  if(darktable.bauhaus-&gt;current &amp;&amp; (darktable.bauhaus-&gt;current-&gt;type == DT_BAUHAUS_COMBOBOX)</a>
<a name="ln356">     &amp;&amp; (event-&gt;button == 1) &amp;&amp;                                // only accept left mouse click</a>
<a name="ln357">     (dt_get_wtime() - darktable.bauhaus-&gt;opentime &gt;= 0.250f)) // default gtk timeout for double-clicks</a>
<a name="ln358">  {</a>
<a name="ln359">    // event might be in wrong system, transform ourselves:</a>
<a name="ln360">    gint wx, wy, x, y;</a>
<a name="ln361">    gdk_window_get_origin(gtk_widget_get_window(darktable.bauhaus-&gt;popup_window), &amp;wx, &amp;wy);</a>
<a name="ln362"> </a>
<a name="ln363">    gdk_device_get_position(</a>
<a name="ln364">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln365">        gdk_seat_get_pointer(gdk_display_get_default_seat(gtk_widget_get_display(widget))), 0, &amp;x, &amp;y);</a>
<a name="ln366">#else</a>
<a name="ln367">        gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gdk_display_get_default())), NULL, &amp;x,</a>
<a name="ln368">        &amp;y);</a>
<a name="ln369">#endif</a>
<a name="ln370">    darktable.bauhaus-&gt;end_mouse_x = x - wx;</a>
<a name="ln371">    darktable.bauhaus-&gt;end_mouse_y = y - wy;</a>
<a name="ln372">    dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln373">  }</a>
<a name="ln374">  dt_bauhaus_hide_popup();</a>
<a name="ln375">  return TRUE;</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">static gboolean dt_bauhaus_popup_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln379">{</a>
<a name="ln380">  if(event-&gt;button == 1)</a>
<a name="ln381">  {</a>
<a name="ln382">    if(darktable.bauhaus-&gt;current-&gt;type == DT_BAUHAUS_COMBOBOX</a>
<a name="ln383">       &amp;&amp; dt_get_wtime() - darktable.bauhaus-&gt;opentime &lt; 0.250f) // default gtk timeout for double-clicks</a>
<a name="ln384">    {</a>
<a name="ln385">      // counts as double click, reset:</a>
<a name="ln386">      dt_bauhaus_combobox_data_t *d = &amp;darktable.bauhaus-&gt;current-&gt;data.combobox;</a>
<a name="ln387">      dt_bauhaus_combobox_set(GTK_WIDGET(darktable.bauhaus-&gt;current), d-&gt;defpos);</a>
<a name="ln388">      dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln389">    }</a>
<a name="ln390">    else</a>
<a name="ln391">    {</a>
<a name="ln392">      // only accept left mouse click</a>
<a name="ln393">      darktable.bauhaus-&gt;end_mouse_x = event-&gt;x;</a>
<a name="ln394">      darktable.bauhaus-&gt;end_mouse_y = event-&gt;y;</a>
<a name="ln395">      dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln396">    }</a>
<a name="ln397">  }</a>
<a name="ln398">  else</a>
<a name="ln399">  {</a>
<a name="ln400">    dt_bauhaus_widget_reject(darktable.bauhaus-&gt;current);</a>
<a name="ln401">  }</a>
<a name="ln402">  return TRUE;</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405">static void dt_bauhaus_window_show(GtkWidget *w, gpointer user_data)</a>
<a name="ln406">{</a>
<a name="ln407">  // Could grab the popup_area rather than popup_window, but if so</a>
<a name="ln408">  // then popup_area would get all motion events including those</a>
<a name="ln409">  // outside of the popup. This way the popup_area gets motion events</a>
<a name="ln410">  // related to updating the popup, and popup_window gets all others</a>
<a name="ln411">  // which would be the ones telling it to close the popup.</a>
<a name="ln412">  gtk_grab_add(w);</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">static void dt_bh_init(DtBauhausWidget *class)</a>
<a name="ln416">{</a>
<a name="ln417">  // not sure if we want to use this instead of our code in *_new()</a>
<a name="ln418">  // TODO: the common code from bauhaus_widget_init() could go here.</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">static void dt_bh_class_init(DtBauhausWidgetClass *class)</a>
<a name="ln422">{</a>
<a name="ln423">  darktable.bauhaus-&gt;signals[DT_BAUHAUS_VALUE_CHANGED_SIGNAL]</a>
<a name="ln424">      = g_signal_new(&quot;value-changed&quot;, G_TYPE_FROM_CLASS(class), G_SIGNAL_RUN_LAST, 0, NULL, NULL,</a>
<a name="ln425">                     g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);</a>
<a name="ln426">  darktable.bauhaus-&gt;signals[DT_BAUHAUS_QUAD_PRESSED_SIGNAL]</a>
<a name="ln427">      = g_signal_new(&quot;quad-pressed&quot;, G_TYPE_FROM_CLASS(class), G_SIGNAL_RUN_LAST, 0, NULL, NULL,</a>
<a name="ln428">                     g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);</a>
<a name="ln429"> </a>
<a name="ln430">  // TODO: could init callbacks once per class for more efficiency:</a>
<a name="ln431">  // GtkWidgetClass *widget_class;</a>
<a name="ln432">  // widget_class = GTK_WIDGET_CLASS (class);</a>
<a name="ln433">  // widget_class-&gt;draw = dt_bauhaus_draw;</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">void dt_bauhaus_init()</a>
<a name="ln437">{</a>
<a name="ln438">  darktable.bauhaus = (dt_bauhaus_t *)calloc(1, sizeof(dt_bauhaus_t));</a>
<a name="ln439">  darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln440">  darktable.bauhaus-&gt;current = NULL;</a>
<a name="ln441">  darktable.bauhaus-&gt;popup_area = gtk_drawing_area_new();</a>
<a name="ln442">  gtk_widget_set_name(darktable.bauhaus-&gt;popup_area, &quot;bauhaus-popup&quot;);</a>
<a name="ln443"> </a>
<a name="ln444">  darktable.bauhaus-&gt;line_space = 2;</a>
<a name="ln445">  darktable.bauhaus-&gt;line_height = 11;</a>
<a name="ln446">  darktable.bauhaus-&gt;marker_size = 0.3f;</a>
<a name="ln447">  darktable.bauhaus-&gt;label_font_size = 0.6f;</a>
<a name="ln448">  darktable.bauhaus-&gt;value_font_size = 0.6f;</a>
<a name="ln449">  g_strlcpy(darktable.bauhaus-&gt;label_font, &quot;sans&quot;, sizeof(darktable.bauhaus-&gt;label_font));</a>
<a name="ln450">  g_strlcpy(darktable.bauhaus-&gt;value_font, &quot;sans&quot;, sizeof(darktable.bauhaus-&gt;value_font));</a>
<a name="ln451"> </a>
<a name="ln452">  GtkWidget *root_window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln453">  GtkStyleContext *ctx = gtk_style_context_new();</a>
<a name="ln454">  GtkWidgetPath *path;</a>
<a name="ln455">  path = gtk_widget_path_new ();</a>
<a name="ln456">  int pos = gtk_widget_path_append_type(path, GTK_TYPE_WIDGET);</a>
<a name="ln457">  gtk_widget_path_iter_set_name(path, pos, &quot;iop-plugin-ui&quot;);</a>
<a name="ln458">  gtk_style_context_set_path(ctx, path);</a>
<a name="ln459">  gtk_style_context_set_screen (ctx, gtk_widget_get_screen(root_window));</a>
<a name="ln460"> </a>
<a name="ln461">  if(!gtk_style_context_lookup_color(ctx, &quot;bauhaus_fg&quot;, &amp;darktable.bauhaus-&gt;color_fg))</a>
<a name="ln462">  {</a>
<a name="ln463">    darktable.bauhaus-&gt;color_fg.red = 0x99 / 255.0;</a>
<a name="ln464">    darktable.bauhaus-&gt;color_fg.green = 0x99 / 255.0;</a>
<a name="ln465">    darktable.bauhaus-&gt;color_fg.blue = 0x99 / 255.0;</a>
<a name="ln466">    darktable.bauhaus-&gt;color_fg.alpha = 1.0;</a>
<a name="ln467">  }</a>
<a name="ln468">  if(!gtk_style_context_lookup_color(ctx, &quot;bauhaus_fg_insensitive&quot;, &amp;darktable.bauhaus-&gt;color_fg_insensitive))</a>
<a name="ln469">  {</a>
<a name="ln470">    darktable.bauhaus-&gt;color_fg_insensitive.red = 0x19 / 255.0;</a>
<a name="ln471">    darktable.bauhaus-&gt;color_fg_insensitive.green = 0x19 / 255.0;</a>
<a name="ln472">    darktable.bauhaus-&gt;color_fg_insensitive.blue = 0x19 / 255.0;</a>
<a name="ln473">    darktable.bauhaus-&gt;color_fg_insensitive.alpha = .5;</a>
<a name="ln474">  }</a>
<a name="ln475">  if(!gtk_style_context_lookup_color(ctx, &quot;bauhaus_bg&quot;, &amp;darktable.bauhaus-&gt;color_bg))</a>
<a name="ln476">  {</a>
<a name="ln477">    darktable.bauhaus-&gt;color_bg.red = 0x99 / 255.0;</a>
<a name="ln478">    darktable.bauhaus-&gt;color_bg.green = 0x99 / 255.0;</a>
<a name="ln479">    darktable.bauhaus-&gt;color_bg.blue = 0x99 / 255.0;</a>
<a name="ln480">    darktable.bauhaus-&gt;color_bg.alpha = .2;</a>
<a name="ln481">  }</a>
<a name="ln482">  if(!gtk_style_context_lookup_color(ctx, &quot;bauhaus_border&quot;, &amp;darktable.bauhaus-&gt;color_border))</a>
<a name="ln483">  {</a>
<a name="ln484">    darktable.bauhaus-&gt;color_border.red = 0x19 / 255.0;</a>
<a name="ln485">    darktable.bauhaus-&gt;color_border.green = 0x19 / 255.0;</a>
<a name="ln486">    darktable.bauhaus-&gt;color_border.blue = 0x19 / 255.0;</a>
<a name="ln487">    darktable.bauhaus-&gt;color_border.alpha = 1.0;</a>
<a name="ln488">  }</a>
<a name="ln489"> </a>
<a name="ln490"> </a>
<a name="ln491">  PangoFontDescription *pfont = 0;</a>
<a name="ln492">  gtk_style_context_get(ctx, GTK_STATE_FLAG_NORMAL, &quot;font&quot;, &amp;pfont, NULL);</a>
<a name="ln493">  gtk_widget_path_free(path);</a>
<a name="ln494"> </a>
<a name="ln495">  darktable.bauhaus-&gt;pango_font_desc = pfont;</a>
<a name="ln496"> </a>
<a name="ln497">  PangoLayout *layout;</a>
<a name="ln498">  cairo_surface_t *cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 128, 128);</a>
<a name="ln499">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln500">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln501">  pango_layout_set_text(layout, &quot;X&quot;, -1);</a>
<a name="ln502">  pango_layout_set_font_description(layout, darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln503">  pango_cairo_context_set_resolution(pango_layout_get_context(layout), darktable.gui-&gt;dpi);</a>
<a name="ln504">  int pango_width, pango_height;</a>
<a name="ln505">  pango_layout_get_size(layout, &amp;pango_width, &amp;pango_height);</a>
<a name="ln506">  g_object_unref(layout);</a>
<a name="ln507">  cairo_destroy(cr);</a>
<a name="ln508">  cairo_surface_destroy(cst);</a>
<a name="ln509"> </a>
<a name="ln510">  darktable.bauhaus-&gt;scale = (pango_height + 0.0f) / PANGO_SCALE / 8.5f;</a>
<a name="ln511">  darktable.bauhaus-&gt;widget_space = 2.5f * darktable.bauhaus-&gt;scale;</a>
<a name="ln512"> </a>
<a name="ln513">  // keys are freed with g_free, values are ptrs to the widgets, these don't need to be cleaned up.</a>
<a name="ln514">  darktable.bauhaus-&gt;keymap = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);</a>
<a name="ln515">  darktable.bauhaus-&gt;key_mod = NULL;</a>
<a name="ln516">  darktable.bauhaus-&gt;key_val = NULL;</a>
<a name="ln517">  memset(darktable.bauhaus-&gt;key_history, 0, sizeof(darktable.bauhaus-&gt;key_history));</a>
<a name="ln518"> </a>
<a name="ln519">  // this easily gets keyboard input:</a>
<a name="ln520">  // darktable.bauhaus-&gt;popup_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</a>
<a name="ln521">  // but this doesn't flicker, and the above hack with key input seems to work well.</a>
<a name="ln522">  darktable.bauhaus-&gt;popup_window = gtk_window_new(GTK_WINDOW_POPUP);</a>
<a name="ln523">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln524">  dt_osx_disallow_fullscreen(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln525">#endif</a>
<a name="ln526">  // this is needed for popup, not for toplevel.</a>
<a name="ln527">  // since popup_area gets the focus if we show the window, this is all</a>
<a name="ln528">  // we need.</a>
<a name="ln529">  dt_gui_key_accel_block_on_focus_connect(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln530"> </a>
<a name="ln531">  gtk_widget_set_size_request(darktable.bauhaus-&gt;popup_area, DT_PIXEL_APPLY_DPI(300), DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln532">  gtk_window_set_resizable(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), FALSE);</a>
<a name="ln533">  gtk_window_set_default_size(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), 260, 260);</a>
<a name="ln534">  // gtk_window_set_modal(GTK_WINDOW(c-&gt;popup_window), TRUE);</a>
<a name="ln535">  // gtk_window_set_decorated(GTK_WINDOW(c-&gt;popup_window), FALSE);</a>
<a name="ln536"> </a>
<a name="ln537">  // for pie menu:</a>
<a name="ln538">  // gtk_window_set_position(GTK_WINDOW(c-&gt;popup_window), GTK_WIN_POS_MOUSE);// | GTK_WIN_POS_CENTER);</a>
<a name="ln539"> </a>
<a name="ln540">  // gtk_window_set_keep_above isn't enough on OS X</a>
<a name="ln541">  gtk_window_set_transient_for(GTK_WINDOW(darktable.bauhaus-&gt;popup_window),</a>
<a name="ln542">                               GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)));</a>
<a name="ln543">  gtk_container_add(GTK_CONTAINER(darktable.bauhaus-&gt;popup_window), darktable.bauhaus-&gt;popup_area);</a>
<a name="ln544">  // gtk_window_set_title(GTK_WINDOW(c-&gt;popup_window), _(&quot;dtgtk control popup&quot;));</a>
<a name="ln545">  gtk_window_set_keep_above(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), TRUE);</a>
<a name="ln546">  gtk_window_set_gravity(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), GDK_GRAVITY_STATIC);</a>
<a name="ln547"> </a>
<a name="ln548">  gtk_widget_set_can_focus(darktable.bauhaus-&gt;popup_area, TRUE);</a>
<a name="ln549">  gtk_widget_add_events(darktable.bauhaus-&gt;popup_area, GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln550">                                                       | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln551">                                                       | GDK_KEY_PRESS_MASK | GDK_LEAVE_NOTIFY_MASK</a>
<a name="ln552">                                                       | darktable.gui-&gt;scroll_mask);</a>
<a name="ln553"> </a>
<a name="ln554">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_window), &quot;show&quot;, G_CALLBACK(dt_bauhaus_window_show), (gpointer)NULL);</a>
<a name="ln555">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;draw&quot;, G_CALLBACK(dt_bauhaus_popup_draw),</a>
<a name="ln556">                   (gpointer)NULL);</a>
<a name="ln557">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_window), &quot;motion-notify-event&quot;,</a>
<a name="ln558">                   G_CALLBACK(dt_bauhaus_window_motion_notify), (gpointer)NULL);</a>
<a name="ln559">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_window), &quot;button-press-event&quot;, G_CALLBACK(dt_bauhaus_window_button_press),</a>
<a name="ln560">                   (gpointer)NULL);</a>
<a name="ln561">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;motion-notify-event&quot;,</a>
<a name="ln562">                   G_CALLBACK(dt_bauhaus_popup_motion_notify), (gpointer)NULL);</a>
<a name="ln563">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;leave-notify-event&quot;,</a>
<a name="ln564">                   G_CALLBACK(dt_bauhaus_popup_leave_notify), (gpointer)NULL);</a>
<a name="ln565">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;button-press-event&quot;,</a>
<a name="ln566">                   G_CALLBACK(dt_bauhaus_popup_button_press), (gpointer)NULL);</a>
<a name="ln567">  // this is connected to the widget itself, not the popup. we're only interested</a>
<a name="ln568">  // in mouse release events that are initiated by a press on the original widget.</a>
<a name="ln569">  g_signal_connect (G_OBJECT (darktable.bauhaus-&gt;popup_area), &quot;button-release-event&quot;,</a>
<a name="ln570">                    G_CALLBACK (dt_bauhaus_popup_button_release), (gpointer)NULL);</a>
<a name="ln571">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;key-press-event&quot;,</a>
<a name="ln572">                   G_CALLBACK(dt_bauhaus_popup_key_press), (gpointer)NULL);</a>
<a name="ln573">  g_signal_connect(G_OBJECT(darktable.bauhaus-&gt;popup_area), &quot;scroll-event&quot;,</a>
<a name="ln574">                   G_CALLBACK(dt_bauhaus_popup_scroll), (gpointer)NULL);</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">void dt_bauhaus_cleanup()</a>
<a name="ln578">{</a>
<a name="ln579">  // TODO: destroy popup window and resources</a>
<a name="ln580">  // TODO: destroy keymap hash table!</a>
<a name="ln581">  g_list_free_full(darktable.bauhaus-&gt;key_mod, (GDestroyNotify)g_free);</a>
<a name="ln582">  g_list_free_full(darktable.bauhaus-&gt;key_val, (GDestroyNotify)g_free);</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">// fwd declare a few callbacks</a>
<a name="ln586">static gboolean dt_bauhaus_slider_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln587">static gboolean dt_bauhaus_slider_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln588">static gboolean dt_bauhaus_slider_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data);</a>
<a name="ln589">static gboolean dt_bauhaus_slider_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);</a>
<a name="ln590">static gboolean dt_bauhaus_slider_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data);</a>
<a name="ln591"> </a>
<a name="ln592"> </a>
<a name="ln593">static gboolean dt_bauhaus_combobox_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln594">static gboolean dt_bauhaus_combobox_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data);</a>
<a name="ln595">static gboolean dt_bauhaus_combobox_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);</a>
<a name="ln596"> </a>
<a name="ln597">// static gboolean</a>
<a name="ln598">// dt_bauhaus_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data);</a>
<a name="ln599">static gboolean dt_bauhaus_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data);</a>
<a name="ln600"> </a>
<a name="ln601"> </a>
<a name="ln602">// end static init/cleanup</a>
<a name="ln603">// =================================================</a>
<a name="ln604"> </a>
<a name="ln605"> </a>
<a name="ln606"> </a>
<a name="ln607">// common initialization</a>
<a name="ln608">static void dt_bauhaus_widget_init(dt_bauhaus_widget_t *w, dt_iop_module_t *self)</a>
<a name="ln609">{</a>
<a name="ln610">  w-&gt;module = self;</a>
<a name="ln611"> </a>
<a name="ln612">  // no quad icon and no toggle button:</a>
<a name="ln613">  w-&gt;quad_paint = 0;</a>
<a name="ln614">  w-&gt;quad_paint_data = NULL;</a>
<a name="ln615">  w-&gt;quad_toggle = 0;</a>
<a name="ln616">  w-&gt;combo_populate = NULL;</a>
<a name="ln617">  gtk_widget_set_size_request(GTK_WIDGET(w), -1, get_line_height());</a>
<a name="ln618"> </a>
<a name="ln619">  gtk_widget_add_events(GTK_WIDGET(w), GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln620">                                       | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln621">                                       | GDK_LEAVE_NOTIFY_MASK | darktable.gui-&gt;scroll_mask);</a>
<a name="ln622"> </a>
<a name="ln623">  g_signal_connect(G_OBJECT(w), &quot;draw&quot;, G_CALLBACK(dt_bauhaus_draw), NULL);</a>
<a name="ln624"> </a>
<a name="ln625">  // for combobox, where mouse-release triggers a selection, we need to catch this</a>
<a name="ln626">  // event where the mouse-press occurred, which will be this widget. we just pass</a>
<a name="ln627">  // it on though:</a>
<a name="ln628">  // g_signal_connect (G_OBJECT (w), &quot;button-release-event&quot;,</a>
<a name="ln629">  //                   G_CALLBACK (dt_bauhaus_popup_button_release), (gpointer)NULL);</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">void dt_bauhaus_combobox_set_default(GtkWidget *widget, int def)</a>
<a name="ln633">{</a>
<a name="ln634">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln635">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln636">  d-&gt;defpos = def;</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639">void dt_bauhaus_slider_set_hard_min(GtkWidget* widget, float val)</a>
<a name="ln640">{</a>
<a name="ln641">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln642">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln643">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln644">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln645">  d-&gt;hard_min = rawval;</a>
<a name="ln646">  d-&gt;min = MAX(d-&gt;min, d-&gt;hard_min);</a>
<a name="ln647">  d-&gt;soft_min = MAX(d-&gt;soft_min, d-&gt;hard_min);</a>
<a name="ln648">  if(rawval &gt; d-&gt;hard_max) dt_bauhaus_slider_set_hard_max(widget,val);</a>
<a name="ln649">  if(pos &lt; val)</a>
<a name="ln650">  {</a>
<a name="ln651">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln652">  }</a>
<a name="ln653">  else</a>
<a name="ln654">  {</a>
<a name="ln655">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln656">  }</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">float dt_bauhaus_slider_get_hard_min(GtkWidget* widget)</a>
<a name="ln660">{</a>
<a name="ln661">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln662">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln663">  return d-&gt;callback(widget, d-&gt;hard_min, DT_BAUHAUS_GET);</a>
<a name="ln664">}</a>
<a name="ln665"> </a>
<a name="ln666">void dt_bauhaus_slider_set_hard_max(GtkWidget* widget, float val)</a>
<a name="ln667">{</a>
<a name="ln668">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln669">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln670">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln671">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln672">  d-&gt;hard_max = rawval;</a>
<a name="ln673">  d-&gt;max = MIN(d-&gt;max, d-&gt;hard_max);</a>
<a name="ln674">  d-&gt;soft_max = MIN(d-&gt;soft_max, d-&gt;hard_max);</a>
<a name="ln675">  if(rawval &lt; d-&gt;hard_min) dt_bauhaus_slider_set_hard_min(widget,val);</a>
<a name="ln676">  if(pos &gt; val) {</a>
<a name="ln677"> </a>
<a name="ln678">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln679">  }</a>
<a name="ln680">  else</a>
<a name="ln681">  {</a>
<a name="ln682">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln683">  }</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686">float dt_bauhaus_slider_get_hard_max(GtkWidget* widget)</a>
<a name="ln687">{</a>
<a name="ln688">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln689">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln690">  return d-&gt;callback(widget, d-&gt;hard_max, DT_BAUHAUS_GET);</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">void dt_bauhaus_slider_set_soft_min(GtkWidget* widget, float val)</a>
<a name="ln694">{</a>
<a name="ln695">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln696">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln697">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln698">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln699">  d-&gt;soft_min = rawval;</a>
<a name="ln700">  d-&gt;hard_min = MIN(d-&gt;hard_min,d-&gt;soft_min);</a>
<a name="ln701">  d-&gt;min =  d-&gt;soft_min;</a>
<a name="ln702">  if(rawval &gt; d-&gt;soft_max) dt_bauhaus_slider_set_soft_max(widget,val);</a>
<a name="ln703">  if(rawval &gt; d-&gt;hard_max) dt_bauhaus_slider_set_hard_max(widget,val);</a>
<a name="ln704">  if(pos &lt; val)</a>
<a name="ln705">  {</a>
<a name="ln706">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln707">  }</a>
<a name="ln708">  else</a>
<a name="ln709">  {</a>
<a name="ln710">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln711">  }</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">float dt_bauhaus_slider_get_soft_min(GtkWidget* widget)</a>
<a name="ln715">{</a>
<a name="ln716">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln717">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln718">  return d-&gt;callback(widget, d-&gt;soft_min, DT_BAUHAUS_GET);</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721">void dt_bauhaus_slider_set_soft_max(GtkWidget* widget, float val)</a>
<a name="ln722">{</a>
<a name="ln723">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln724">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln725">  float pos = dt_bauhaus_slider_get(widget);</a>
<a name="ln726">  float rawval = d-&gt;callback(widget, val, DT_BAUHAUS_SET);</a>
<a name="ln727">  d-&gt;soft_max = rawval;</a>
<a name="ln728">  d-&gt;hard_max = MAX(d-&gt;soft_max, d-&gt;hard_max);</a>
<a name="ln729">  d-&gt;max =  d-&gt;soft_max;</a>
<a name="ln730">  if(rawval &lt; d-&gt;soft_min) dt_bauhaus_slider_set_soft_min(widget,val);</a>
<a name="ln731">  if(rawval &lt; d-&gt;hard_min) dt_bauhaus_slider_set_hard_min(widget,val);</a>
<a name="ln732">  if(pos &gt; val) {</a>
<a name="ln733">    dt_bauhaus_slider_set_soft(widget,val);</a>
<a name="ln734">  } else {</a>
<a name="ln735">    dt_bauhaus_slider_set_soft(widget,pos);</a>
<a name="ln736">  }</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">float dt_bauhaus_slider_get_soft_max(GtkWidget* widget)</a>
<a name="ln740">{</a>
<a name="ln741">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln742">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln743">  return d-&gt;callback(widget, d-&gt;soft_max, DT_BAUHAUS_GET);</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">void dt_bauhaus_slider_set_default(GtkWidget *widget, float def)</a>
<a name="ln747">{</a>
<a name="ln748">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln749">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln750">  float val = d-&gt;callback(widget, def, DT_BAUHAUS_SET);</a>
<a name="ln751">  d-&gt;defpos = (val - d-&gt;min) / (d-&gt;max - d-&gt;min);</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754">void dt_bauhaus_slider_enable_soft_boundaries(GtkWidget *widget, float hard_min, float hard_max)</a>
<a name="ln755">{</a>
<a name="ln756">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln757">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln758">  d-&gt;hard_min = d-&gt;callback(widget, hard_min, DT_BAUHAUS_SET);</a>
<a name="ln759">  d-&gt;hard_max = d-&gt;callback(widget, hard_max, DT_BAUHAUS_SET);</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">void dt_bauhaus_widget_set_label(GtkWidget *widget, const char *section, const char *label)</a>
<a name="ln763">{</a>
<a name="ln764">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln765">  memset(w-&gt;label, 0, sizeof(w-&gt;label)); // keep valgrind happy</a>
<a name="ln766">  g_strlcpy(w-&gt;label, label, sizeof(w-&gt;label));</a>
<a name="ln767"> </a>
<a name="ln768">  if(w-&gt;module)</a>
<a name="ln769">  {</a>
<a name="ln770">    // construct control path name and insert into keymap:</a>
<a name="ln771">    gchar *path;</a>
<a name="ln772">    if(section &amp;&amp; section[0] != '\0')</a>
<a name="ln773">    {</a>
<a name="ln774">      path = g_strdup_printf(&quot;%s.%s.%s&quot;, w-&gt;module-&gt;name(), section, w-&gt;label);</a>
<a name="ln775">      gchar *section_path = g_strdup_printf(&quot;%s.%s&quot;, w-&gt;module-&gt;name(), section);</a>
<a name="ln776">      if(!g_list_find_custom(darktable.bauhaus-&gt;key_val, section_path, (GCompareFunc)strcmp))</a>
<a name="ln777">        darktable.bauhaus-&gt;key_val</a>
<a name="ln778">            = g_list_insert_sorted(darktable.bauhaus-&gt;key_val, section_path, (GCompareFunc)strcmp);</a>
<a name="ln779">      else</a>
<a name="ln780">        g_free(section_path);</a>
<a name="ln781">    }</a>
<a name="ln782">    else</a>
<a name="ln783">      path = g_strdup_printf(&quot;%s.%s&quot;, w-&gt;module-&gt;name(), w-&gt;label);</a>
<a name="ln784">    if(!g_hash_table_lookup(darktable.bauhaus-&gt;keymap, path))</a>
<a name="ln785">    {</a>
<a name="ln786">      // also insert into sorted tab-complete list.</a>
<a name="ln787">      // (but only if this is the first time we insert this path)</a>
<a name="ln788">      gchar *mod = g_strdup(path);</a>
<a name="ln789">      gchar *val = g_strstr_len(mod, strlen(mod), &quot;.&quot;);</a>
<a name="ln790">      if(val)</a>
<a name="ln791">      {</a>
<a name="ln792">        *val = 0;</a>
<a name="ln793">        if(!g_list_find_custom(darktable.bauhaus-&gt;key_mod, mod, (GCompareFunc)strcmp))</a>
<a name="ln794">          darktable.bauhaus-&gt;key_mod</a>
<a name="ln795">              = g_list_insert_sorted(darktable.bauhaus-&gt;key_mod, mod, (GCompareFunc)strcmp);</a>
<a name="ln796">        else</a>
<a name="ln797">          g_free(mod);</a>
<a name="ln798"> </a>
<a name="ln799">        // unfortunately need our own string, as replace in the hashtable below might destroy this pointer.</a>
<a name="ln800">        darktable.bauhaus-&gt;key_val</a>
<a name="ln801">            = g_list_insert_sorted(darktable.bauhaus-&gt;key_val, g_strdup(path), (GCompareFunc)strcmp);</a>
<a name="ln802">      }</a>
<a name="ln803">    }</a>
<a name="ln804">    // might free an old path</a>
<a name="ln805">    g_hash_table_replace(darktable.bauhaus-&gt;keymap, path, w);</a>
<a name="ln806">    gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln807">  }</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810">const char* dt_bauhaus_widget_get_label(GtkWidget *widget)</a>
<a name="ln811">{</a>
<a name="ln812">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln813">  return w-&gt;label;</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">void dt_bauhaus_widget_set_quad_paint(GtkWidget *widget, dt_bauhaus_quad_paint_f f, int paint_flags, void *paint_data)</a>
<a name="ln817">{</a>
<a name="ln818">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln819">  w-&gt;quad_paint = f;</a>
<a name="ln820">  w-&gt;quad_paint_flags = paint_flags;</a>
<a name="ln821">  w-&gt;quad_paint_data = paint_data;</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824">// make this quad a toggle button:</a>
<a name="ln825">void dt_bauhaus_widget_set_quad_toggle(GtkWidget *widget, int toggle)</a>
<a name="ln826">{</a>
<a name="ln827">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln828">  w-&gt;quad_toggle = toggle;</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831">void dt_bauhaus_widget_set_quad_active(GtkWidget *widget, int active)</a>
<a name="ln832">{</a>
<a name="ln833">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln834">  if (active)</a>
<a name="ln835">    w-&gt;quad_paint_flags |= CPF_ACTIVE;</a>
<a name="ln836">  else</a>
<a name="ln837">    w-&gt;quad_paint_flags &amp;= ~CPF_ACTIVE;</a>
<a name="ln838">  gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841">int dt_bauhaus_widget_get_quad_active(GtkWidget *widget)</a>
<a name="ln842">{</a>
<a name="ln843">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln844">  return (w-&gt;quad_paint_flags &amp; CPF_ACTIVE) == CPF_ACTIVE;</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">static float _default_linear_callback(GtkWidget *self, float value, dt_bauhaus_callback_t dir)</a>
<a name="ln848">{</a>
<a name="ln849">  // regardless of dir: input &lt;-&gt; output</a>
<a name="ln850">  return value;</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853">static void dt_bauhaus_slider_destroy(dt_bauhaus_widget_t *widget, gpointer user_data)</a>
<a name="ln854">{</a>
<a name="ln855">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln856">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln857">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln858">  if(d-&gt;timeout_handle) g_source_remove(d-&gt;timeout_handle);</a>
<a name="ln859">  d-&gt;timeout_handle = 0;</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">GtkWidget *dt_bauhaus_slider_new(dt_iop_module_t *self)</a>
<a name="ln863">{</a>
<a name="ln864">  return dt_bauhaus_slider_new_with_range(self, 0.0, 1.0, 0.1, 0.5, 3);</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867">GtkWidget *dt_bauhaus_slider_new_with_range(dt_iop_module_t *self, float min, float max, float step,</a>
<a name="ln868">                                            float defval, int digits)</a>
<a name="ln869">{</a>
<a name="ln870">  return dt_bauhaus_slider_new_with_range_and_feedback(self, min, max, step, defval, digits, 1);</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">GtkWidget *dt_bauhaus_slider_new_with_range_and_feedback(dt_iop_module_t *self, float min, float max,</a>
<a name="ln874">                                                         float step, float defval, int digits, int feedback)</a>
<a name="ln875">{</a>
<a name="ln876">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(g_object_new(DT_BAUHAUS_WIDGET_TYPE, NULL));</a>
<a name="ln877">  return dt_bauhaus_slider_from_widget(w,self, min, max, step, defval, digits, feedback);</a>
<a name="ln878">}</a>
<a name="ln879">GtkWidget *dt_bauhaus_slider_from_widget(dt_bauhaus_widget_t* w,dt_iop_module_t *self, float min, float max,</a>
<a name="ln880">                                                         float step, float defval, int digits, int feedback)</a>
<a name="ln881">{</a>
<a name="ln882">  w-&gt;type = DT_BAUHAUS_SLIDER;</a>
<a name="ln883">  dt_bauhaus_widget_init(w, self);</a>
<a name="ln884">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln885">  d-&gt;min = d-&gt;soft_min = d-&gt;hard_min = min;</a>
<a name="ln886">  d-&gt;max = d-&gt;soft_max = d-&gt;hard_max = max;</a>
<a name="ln887">  d-&gt;step = step;</a>
<a name="ln888">  // normalize default:</a>
<a name="ln889">  d-&gt;defpos = (defval - min) / (max - min);</a>
<a name="ln890">  d-&gt;pos = d-&gt;defpos;</a>
<a name="ln891">  d-&gt;oldpos = d-&gt;defpos;</a>
<a name="ln892">  d-&gt;scale = 5.0f * step / (max - min);</a>
<a name="ln893">  d-&gt;digits = digits;</a>
<a name="ln894">  snprintf(d-&gt;format, sizeof(d-&gt;format), &quot;%%.0%df&quot;, digits);</a>
<a name="ln895"> </a>
<a name="ln896">  d-&gt;grad_cnt = 0;</a>
<a name="ln897"> </a>
<a name="ln898">  d-&gt;fill_feedback = feedback;</a>
<a name="ln899"> </a>
<a name="ln900">  d-&gt;is_dragging = 0;</a>
<a name="ln901">  d-&gt;is_changed = 0;</a>
<a name="ln902">  d-&gt;timeout_handle = 0;</a>
<a name="ln903">  d-&gt;callback = _default_linear_callback;</a>
<a name="ln904"> </a>
<a name="ln905">  gtk_widget_add_events(GTK_WIDGET(w), GDK_KEY_PRESS_MASK);</a>
<a name="ln906">  gtk_widget_set_can_focus(GTK_WIDGET(w), TRUE);</a>
<a name="ln907"> </a>
<a name="ln908">  g_signal_connect(G_OBJECT(w), &quot;button-press-event&quot;, G_CALLBACK(dt_bauhaus_slider_button_press),</a>
<a name="ln909">                   (gpointer)NULL);</a>
<a name="ln910">  g_signal_connect(G_OBJECT(w), &quot;button-release-event&quot;, G_CALLBACK(dt_bauhaus_slider_button_release),</a>
<a name="ln911">                   (gpointer)NULL);</a>
<a name="ln912">  g_signal_connect(G_OBJECT(w), &quot;scroll-event&quot;, G_CALLBACK(dt_bauhaus_slider_scroll), (gpointer)NULL);</a>
<a name="ln913">  g_signal_connect(G_OBJECT(w), &quot;key-press-event&quot;, G_CALLBACK(dt_bauhaus_slider_key_press), (gpointer)NULL);</a>
<a name="ln914">  g_signal_connect(G_OBJECT(w), &quot;motion-notify-event&quot;, G_CALLBACK(dt_bauhaus_slider_motion_notify),</a>
<a name="ln915">                   (gpointer)NULL);</a>
<a name="ln916">  g_signal_connect(G_OBJECT(w), &quot;destroy&quot;, G_CALLBACK(dt_bauhaus_slider_destroy), (gpointer)NULL);</a>
<a name="ln917">  return GTK_WIDGET(w);</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">static void dt_bauhaus_combobox_destroy(dt_bauhaus_widget_t *widget, gpointer user_data)</a>
<a name="ln921">{</a>
<a name="ln922">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln923">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln924">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln925">  g_list_free_full(d-&gt;labels, g_free);</a>
<a name="ln926">  d-&gt;labels = NULL;</a>
<a name="ln927">  g_list_free(d-&gt;alignments);</a>
<a name="ln928">  d-&gt;alignments = NULL;</a>
<a name="ln929">  d-&gt;num_labels = 0;</a>
<a name="ln930">  if(d-&gt;free_func)</a>
<a name="ln931">    g_list_free_full(d-&gt;data, d-&gt;free_func);</a>
<a name="ln932">  else</a>
<a name="ln933">    g_list_free(d-&gt;data);</a>
<a name="ln934">  d-&gt;data = NULL;</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937">GtkWidget *dt_bauhaus_combobox_new(dt_iop_module_t *self)</a>
<a name="ln938">{</a>
<a name="ln939">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(g_object_new(DT_BAUHAUS_WIDGET_TYPE, NULL));</a>
<a name="ln940">  dt_bauhaus_combobox_from_widget(w,self);</a>
<a name="ln941">  return GTK_WIDGET(w);</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">void dt_bauhaus_combobox_from_widget(dt_bauhaus_widget_t* w,dt_iop_module_t *self)</a>
<a name="ln945">{</a>
<a name="ln946">  w-&gt;type = DT_BAUHAUS_COMBOBOX;</a>
<a name="ln947">  dt_bauhaus_widget_init(w, self);</a>
<a name="ln948">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln949">  d-&gt;labels = NULL;</a>
<a name="ln950">  d-&gt;alignments = NULL;</a>
<a name="ln951">  d-&gt;num_labels = 0;</a>
<a name="ln952">  d-&gt;defpos = 0;</a>
<a name="ln953">  d-&gt;active = d-&gt;defpos;</a>
<a name="ln954">  d-&gt;editable = 0;</a>
<a name="ln955">  d-&gt;data = NULL;</a>
<a name="ln956">  memset(d-&gt;text, 0, sizeof(d-&gt;text));</a>
<a name="ln957"> </a>
<a name="ln958">  gtk_widget_add_events(GTK_WIDGET(w), GDK_KEY_PRESS_MASK);</a>
<a name="ln959">  gtk_widget_set_can_focus(GTK_WIDGET(w), TRUE);</a>
<a name="ln960"> </a>
<a name="ln961">  g_signal_connect(G_OBJECT(w), &quot;button-press-event&quot;, G_CALLBACK(dt_bauhaus_combobox_button_press),</a>
<a name="ln962">                   (gpointer)NULL);</a>
<a name="ln963">  g_signal_connect(G_OBJECT(w), &quot;button-release-event&quot;, G_CALLBACK(dt_bauhaus_popup_button_release),</a>
<a name="ln964">                   (gpointer)NULL);</a>
<a name="ln965">  g_signal_connect(G_OBJECT(w), &quot;scroll-event&quot;, G_CALLBACK(dt_bauhaus_combobox_scroll), (gpointer)NULL);</a>
<a name="ln966">  g_signal_connect(G_OBJECT(w), &quot;key-press-event&quot;, G_CALLBACK(dt_bauhaus_combobox_key_press), (gpointer)NULL);</a>
<a name="ln967">  g_signal_connect(G_OBJECT(w), &quot;destroy&quot;, G_CALLBACK(dt_bauhaus_combobox_destroy), (gpointer)NULL);</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970">void dt_bauhaus_combobox_add_populate_fct(GtkWidget *widget, void (*fct)(GtkWidget *w, struct dt_iop_module_t **module))</a>
<a name="ln971">{</a>
<a name="ln972">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln973">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln974">  w-&gt;combo_populate = fct;</a>
<a name="ln975">}</a>
<a name="ln976"> </a>
<a name="ln977">void dt_bauhaus_combobox_add(GtkWidget *widget, const char *text)</a>
<a name="ln978">{</a>
<a name="ln979">  dt_bauhaus_combobox_add_full(widget, text, DT_BAUHAUS_COMBOBOX_ALIGN_RIGHT, NULL, NULL);</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">void dt_bauhaus_combobox_add_aligned(GtkWidget *widget, const char *text, dt_bauhaus_combobox_alignment_t align)</a>
<a name="ln983">{</a>
<a name="ln984">  dt_bauhaus_combobox_add_full(widget, text, align, NULL, NULL);</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987">void dt_bauhaus_combobox_add_full(GtkWidget *widget, const char *text, dt_bauhaus_combobox_alignment_t align,</a>
<a name="ln988">                                  gpointer data, void (free_func)(void *data))</a>
<a name="ln989">{</a>
<a name="ln990">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln991">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln992">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln993">  d-&gt;num_labels++;</a>
<a name="ln994">  d-&gt;labels = g_list_append(d-&gt;labels, g_strdup(text));</a>
<a name="ln995">  d-&gt;alignments = g_list_append(d-&gt;alignments, GINT_TO_POINTER(align));</a>
<a name="ln996">  d-&gt;data = g_list_append(d-&gt;data, data);</a>
<a name="ln997">  d-&gt;free_func = free_func;</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000">void dt_bauhaus_combobox_set_editable(GtkWidget *widget, int editable)</a>
<a name="ln1001">{</a>
<a name="ln1002">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1003">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1004">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1005">  d-&gt;editable = editable ? 1 : 0;</a>
<a name="ln1006">}</a>
<a name="ln1007"> </a>
<a name="ln1008">int dt_bauhaus_combobox_get_editable(GtkWidget *widget)</a>
<a name="ln1009">{</a>
<a name="ln1010">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1011">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return 0;</a>
<a name="ln1012">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1013">  return d-&gt;editable;</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016">void dt_bauhaus_combobox_remove_at(GtkWidget *widget, int pos)</a>
<a name="ln1017">{</a>
<a name="ln1018">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1019">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1020">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1021"> </a>
<a name="ln1022">  if(pos &lt; 0 || pos &gt;= d-&gt;num_labels) return;</a>
<a name="ln1023"> </a>
<a name="ln1024">  GList *rm = g_list_nth(d-&gt;labels, pos);</a>
<a name="ln1025">  g_free(rm-&gt;data);</a>
<a name="ln1026">  d-&gt;labels = g_list_delete_link(d-&gt;labels, rm);</a>
<a name="ln1027"> </a>
<a name="ln1028">  rm = g_list_nth(d-&gt;alignments, pos);</a>
<a name="ln1029">  d-&gt;alignments = g_list_delete_link(d-&gt;alignments, rm);</a>
<a name="ln1030"> </a>
<a name="ln1031">  rm = g_list_nth(d-&gt;data, pos);</a>
<a name="ln1032">  if(d-&gt;free_func) d-&gt;free_func(rm-&gt;data);</a>
<a name="ln1033">  d-&gt;data = g_list_delete_link(d-&gt;data, rm);</a>
<a name="ln1034"> </a>
<a name="ln1035">  d-&gt;num_labels--;</a>
<a name="ln1036">}</a>
<a name="ln1037"> </a>
<a name="ln1038">void dt_bauhaus_combobox_insert(GtkWidget *widget, const char *text,int pos)</a>
<a name="ln1039">{</a>
<a name="ln1040">  dt_bauhaus_combobox_insert_full(widget, text, DT_BAUHAUS_COMBOBOX_ALIGN_RIGHT, NULL, pos);</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">void dt_bauhaus_combobox_insert_full(GtkWidget *widget, const char *text, dt_bauhaus_combobox_alignment_t align,</a>
<a name="ln1044">                                     gpointer data, int pos)</a>
<a name="ln1045">{</a>
<a name="ln1046">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1047">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1048">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1049">  d-&gt;num_labels++;</a>
<a name="ln1050">  d-&gt;labels = g_list_insert(d-&gt;labels, g_strdup(text), pos);</a>
<a name="ln1051">  d-&gt;alignments = g_list_insert(d-&gt;alignments, GINT_TO_POINTER(align), pos);</a>
<a name="ln1052">  d-&gt;data = g_list_insert(d-&gt;data, data, pos);</a>
<a name="ln1053">}</a>
<a name="ln1054"> </a>
<a name="ln1055">int dt_bauhaus_combobox_length(GtkWidget *widget)</a>
<a name="ln1056">{</a>
<a name="ln1057">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1058">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return 0;</a>
<a name="ln1059">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1060"> </a>
<a name="ln1061">  return d-&gt;num_labels;</a>
<a name="ln1062">}</a>
<a name="ln1063"> </a>
<a name="ln1064">const char *dt_bauhaus_combobox_get_text(GtkWidget *widget)</a>
<a name="ln1065">{</a>
<a name="ln1066">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1067">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return NULL;</a>
<a name="ln1068">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1069"> </a>
<a name="ln1070">  if(d-&gt;editable &amp;&amp; d-&gt;active &lt; 0)</a>
<a name="ln1071">  {</a>
<a name="ln1072">    return d-&gt;text;</a>
<a name="ln1073">  }</a>
<a name="ln1074">  else</a>
<a name="ln1075">  {</a>
<a name="ln1076">    if(d-&gt;active &lt; 0 || d-&gt;active &gt;= d-&gt;num_labels) return NULL;</a>
<a name="ln1077">    return (const char *)g_list_nth_data(d-&gt;labels, d-&gt;active);</a>
<a name="ln1078">  }</a>
<a name="ln1079">  return NULL;</a>
<a name="ln1080">}</a>
<a name="ln1081"> </a>
<a name="ln1082">gpointer dt_bauhaus_combobox_get_data(GtkWidget *widget)</a>
<a name="ln1083">{</a>
<a name="ln1084">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1085">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return NULL;</a>
<a name="ln1086">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1087">  return g_list_nth_data(d-&gt;data, d-&gt;active);</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090">void dt_bauhaus_combobox_clear(GtkWidget *widget)</a>
<a name="ln1091">{</a>
<a name="ln1092">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1093">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1094">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1095">  d-&gt;active = 0;</a>
<a name="ln1096">  g_list_free_full(d-&gt;labels, g_free);</a>
<a name="ln1097">  d-&gt;labels = NULL;</a>
<a name="ln1098">  g_list_free(d-&gt;alignments);</a>
<a name="ln1099">  d-&gt;alignments = NULL;</a>
<a name="ln1100">  if(d-&gt;free_func)</a>
<a name="ln1101">    g_list_free_full(d-&gt;data, d-&gt;free_func);</a>
<a name="ln1102">  else</a>
<a name="ln1103">    g_list_free(d-&gt;data);</a>
<a name="ln1104">  d-&gt;data = NULL;</a>
<a name="ln1105">  d-&gt;num_labels = 0;</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108">const GList *dt_bauhaus_combobox_get_labels(GtkWidget *widget)</a>
<a name="ln1109">{</a>
<a name="ln1110">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1111">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return 0;</a>
<a name="ln1112">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1113">  return d-&gt;labels;</a>
<a name="ln1114">}</a>
<a name="ln1115"> </a>
<a name="ln1116">void dt_bauhaus_combobox_set_text(GtkWidget *widget, const char *text)</a>
<a name="ln1117">{</a>
<a name="ln1118">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1119">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1120">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1121">  if(!d-&gt;editable) return;</a>
<a name="ln1122">  g_strlcpy(d-&gt;text, text, sizeof(d-&gt;text));</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125">void dt_bauhaus_combobox_set(GtkWidget *widget, int pos)</a>
<a name="ln1126">{</a>
<a name="ln1127">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1128">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return;</a>
<a name="ln1129">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1130">  d-&gt;active = CLAMP(pos, -1, d-&gt;num_labels - 1);</a>
<a name="ln1131">  gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln1132">  if(!darktable.gui-&gt;reset) g_signal_emit_by_name(G_OBJECT(w), &quot;value-changed&quot;);</a>
<a name="ln1133">}</a>
<a name="ln1134"> </a>
<a name="ln1135">int dt_bauhaus_combobox_get(GtkWidget *widget)</a>
<a name="ln1136">{</a>
<a name="ln1137">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1138">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return -1;</a>
<a name="ln1139">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1140">  return d-&gt;active;</a>
<a name="ln1141">}</a>
<a name="ln1142"> </a>
<a name="ln1143">void dt_bauhaus_slider_clear_stops(GtkWidget *widget)</a>
<a name="ln1144">{</a>
<a name="ln1145">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1146">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1147">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1148">  d-&gt;grad_cnt = 0;</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151">void dt_bauhaus_slider_set_stop(GtkWidget *widget, float stop, float r, float g, float b)</a>
<a name="ln1152">{</a>
<a name="ln1153">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1154">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1155">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1156">  float rawstop = d-&gt;callback(widget, stop, DT_BAUHAUS_SET);</a>
<a name="ln1157">  // need to replace stop?</a>
<a name="ln1158">  for(int k = 0; k &lt; d-&gt;grad_cnt; k++)</a>
<a name="ln1159">  {</a>
<a name="ln1160">    if(d-&gt;grad_pos[k] == rawstop)</a>
<a name="ln1161">    {</a>
<a name="ln1162">      d-&gt;grad_col[k][0] = r;</a>
<a name="ln1163">      d-&gt;grad_col[k][1] = g;</a>
<a name="ln1164">      d-&gt;grad_col[k][2] = b;</a>
<a name="ln1165">      return;</a>
<a name="ln1166">    }</a>
<a name="ln1167">  }</a>
<a name="ln1168">  // new stop:</a>
<a name="ln1169">  if(d-&gt;grad_cnt &lt; DT_BAUHAUS_SLIDER_MAX_STOPS)</a>
<a name="ln1170">  {</a>
<a name="ln1171">    int k = d-&gt;grad_cnt++;</a>
<a name="ln1172">    d-&gt;grad_pos[k] = rawstop;</a>
<a name="ln1173">    d-&gt;grad_col[k][0] = r;</a>
<a name="ln1174">    d-&gt;grad_col[k][1] = g;</a>
<a name="ln1175">    d-&gt;grad_col[k][2] = b;</a>
<a name="ln1176">  }</a>
<a name="ln1177">  else</a>
<a name="ln1178">  {</a>
<a name="ln1179">    fprintf(stderr, &quot;[bauhaus_slider_set_stop] only %d stops allowed.\n&quot;, DT_BAUHAUS_SLIDER_MAX_STOPS);</a>
<a name="ln1180">  }</a>
<a name="ln1181">}</a>
<a name="ln1182"> </a>
<a name="ln1183"> </a>
<a name="ln1184">static void draw_equilateral_triangle(cairo_t *cr, float radius)</a>
<a name="ln1185">{</a>
<a name="ln1186">  const float sin = 0.866025404 * radius;</a>
<a name="ln1187">  const float cos = 0.5f * radius;</a>
<a name="ln1188">  cairo_move_to(cr, 0.0, radius);</a>
<a name="ln1189">  cairo_line_to(cr, -sin, -cos);</a>
<a name="ln1190">  cairo_line_to(cr, sin, -cos);</a>
<a name="ln1191">  cairo_line_to(cr, 0.0, radius);</a>
<a name="ln1192">}</a>
<a name="ln1193"> </a>
<a name="ln1194">static void dt_bauhaus_draw_indicator(dt_bauhaus_widget_t *w, float pos, cairo_t *cr)</a>
<a name="ln1195">{</a>
<a name="ln1196">  // draw scale indicator (the tiny triangle)</a>
<a name="ln1197">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1198">  GtkAllocation allocation;</a>
<a name="ln1199">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1200">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1201">  const int wd = allocation.width;</a>
<a name="ln1202">  const int ht = allocation.height;</a>
<a name="ln1203">  cairo_save(cr);</a>
<a name="ln1204"> </a>
<a name="ln1205">  const float l = 4.0f / wd;</a>
<a name="ln1206">  const float r = 1.0f - (ht + 4.0f) / wd;</a>
<a name="ln1207">  set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1208">  cairo_translate(cr, (l + pos * (r - l)) * wd,</a>
<a name="ln1209">                  get_line_height() * (darktable.bauhaus-&gt;label_font_size + 0.25f));</a>
<a name="ln1210">  cairo_scale(cr, 1.0f, -1.0f);</a>
<a name="ln1211">  draw_equilateral_triangle(cr, ht * get_marker_size());</a>
<a name="ln1212">  cairo_fill_preserve(cr);</a>
<a name="ln1213">  cairo_set_line_width(cr, 1.);</a>
<a name="ln1214">  set_color(cr, darktable.bauhaus-&gt;color_border);</a>
<a name="ln1215">  cairo_stroke(cr);</a>
<a name="ln1216">  cairo_restore(cr);</a>
<a name="ln1217">}</a>
<a name="ln1218"> </a>
<a name="ln1219">static void dt_bauhaus_draw_quad(dt_bauhaus_widget_t *w, cairo_t *cr)</a>
<a name="ln1220">{</a>
<a name="ln1221">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1222">  const gboolean sensitive = gtk_widget_is_sensitive(GTK_WIDGET(w));</a>
<a name="ln1223">  GtkAllocation allocation;</a>
<a name="ln1224">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1225">  const int width = allocation.width;</a>
<a name="ln1226">  const int height = allocation.height;</a>
<a name="ln1227"> </a>
<a name="ln1228">  if(w-&gt;quad_paint)</a>
<a name="ln1229">  {</a>
<a name="ln1230">    const float font_size = get_label_font_size();</a>
<a name="ln1231">    cairo_save(cr);</a>
<a name="ln1232"> </a>
<a name="ln1233">    if(sensitive &amp;&amp; (w-&gt;quad_paint_flags &amp; CPF_ACTIVE))</a>
<a name="ln1234">      set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1235">    else</a>
<a name="ln1236">      set_color(cr, darktable.bauhaus-&gt;color_fg_insensitive);</a>
<a name="ln1237">    w-&gt;quad_paint(cr, width - height, 0, height, font_size, w-&gt;quad_paint_flags, w-&gt;quad_paint_data);</a>
<a name="ln1238">    cairo_restore(cr);</a>
<a name="ln1239">  }</a>
<a name="ln1240">  else</a>
<a name="ln1241">  {</a>
<a name="ln1242">    // draw active area square:</a>
<a name="ln1243">    cairo_save(cr);</a>
<a name="ln1244">    if(sensitive)</a>
<a name="ln1245">      set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1246">    else</a>
<a name="ln1247">      set_color(cr, darktable.bauhaus-&gt;color_fg_insensitive);</a>
<a name="ln1248">    switch(w-&gt;type)</a>
<a name="ln1249">    {</a>
<a name="ln1250">      case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1251">        cairo_translate(cr, width - height * .5f, get_label_font_size() * .5f);</a>
<a name="ln1252">        draw_equilateral_triangle(cr, height * get_marker_size());</a>
<a name="ln1253">        cairo_fill_preserve(cr);</a>
<a name="ln1254">        cairo_set_line_width(cr, 1.);</a>
<a name="ln1255">        set_color(cr, darktable.bauhaus-&gt;color_border);</a>
<a name="ln1256">        cairo_stroke(cr);</a>
<a name="ln1257">        break;</a>
<a name="ln1258">      case DT_BAUHAUS_SLIDER:</a>
<a name="ln1259">        break;</a>
<a name="ln1260">      default:</a>
<a name="ln1261">        cairo_set_source_rgb(cr, 1.0, 0.0, 0.0);</a>
<a name="ln1262">        cairo_rectangle(cr, width - height, 0, height, height);</a>
<a name="ln1263">        cairo_fill(cr);</a>
<a name="ln1264">        break;</a>
<a name="ln1265">    }</a>
<a name="ln1266">    cairo_restore(cr);</a>
<a name="ln1267">  }</a>
<a name="ln1268">}</a>
<a name="ln1269"> </a>
<a name="ln1270">static void dt_bauhaus_draw_baseline(dt_bauhaus_widget_t *w, cairo_t *cr)</a>
<a name="ln1271">{</a>
<a name="ln1272">  // draw line for orientation in slider</a>
<a name="ln1273">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1274">  GtkAllocation allocation;</a>
<a name="ln1275">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1276">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1277">  const int wd = allocation.width;</a>
<a name="ln1278">  const int ht = allocation.height;</a>
<a name="ln1279">  cairo_save(cr);</a>
<a name="ln1280">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1281"> </a>
<a name="ln1282">  // pos of baseline</a>
<a name="ln1283">  const float htm = ht * (darktable.bauhaus-&gt;label_font_size + 0.15f);</a>
<a name="ln1284">  const float htM = ht * 0.2f; // thickness of baseline</a>
<a name="ln1285"> </a>
<a name="ln1286">  // the background of the line</a>
<a name="ln1287">  cairo_pattern_t *gradient = NULL;</a>
<a name="ln1288">  if(d-&gt;grad_cnt &gt; 0)</a>
<a name="ln1289">  {</a>
<a name="ln1290">    // gradient line as used in some modules</a>
<a name="ln1291">    gradient = cairo_pattern_create_linear(0, 0, wd - 4 - ht - 2, ht);</a>
<a name="ln1292">    for(int k = 0; k &lt; d-&gt;grad_cnt; k++)</a>
<a name="ln1293">      cairo_pattern_add_color_stop_rgba(gradient, d-&gt;grad_pos[k], d-&gt;grad_col[k][0], d-&gt;grad_col[k][1],</a>
<a name="ln1294">                                        d-&gt;grad_col[k][2], 0.4f);</a>
<a name="ln1295">    cairo_set_source(cr, gradient);</a>
<a name="ln1296">  }</a>
<a name="ln1297">  else</a>
<a name="ln1298">  {</a>
<a name="ln1299">    // regular baseline</a>
<a name="ln1300">    set_color(cr, darktable.bauhaus-&gt;color_bg);</a>
<a name="ln1301">  }</a>
<a name="ln1302"> </a>
<a name="ln1303">  cairo_rectangle(cr, 2, htm, wd - 4 - ht - 2, htM);</a>
<a name="ln1304">  cairo_fill(cr);</a>
<a name="ln1305"> </a>
<a name="ln1306">  // have a `fill ratio feel'</a>
<a name="ln1307">  // - but only if set (default, but might not be good for 'balance' sliders)</a>
<a name="ln1308">  if(d-&gt;fill_feedback)</a>
<a name="ln1309">  {</a>
<a name="ln1310">    // only brighten, useful for colored sliders to not get too faint:</a>
<a name="ln1311">    cairo_set_operator(cr, CAIRO_OPERATOR_SCREEN);</a>
<a name="ln1312">    cairo_set_source_rgb(cr, .3, .3, .3);</a>
<a name="ln1313">    cairo_rectangle(cr, 2, htm, d-&gt;pos * (wd - 4 - ht - 2), htM);</a>
<a name="ln1314">    cairo_fill(cr);</a>
<a name="ln1315">    // change back to default cairo operator:</a>
<a name="ln1316">    cairo_set_operator(cr, CAIRO_OPERATOR_OVER);</a>
<a name="ln1317">  }</a>
<a name="ln1318"> </a>
<a name="ln1319">  cairo_rectangle(cr, 2, htm, wd - 4 - ht - 2, htM);</a>
<a name="ln1320">  cairo_set_line_width(cr, 1.);</a>
<a name="ln1321">  set_color(cr, darktable.bauhaus-&gt;color_border);</a>
<a name="ln1322">  cairo_stroke(cr);</a>
<a name="ln1323"> </a>
<a name="ln1324">  cairo_restore(cr);</a>
<a name="ln1325"> </a>
<a name="ln1326">  if(d-&gt;grad_cnt &gt; 0) cairo_pattern_destroy(gradient);</a>
<a name="ln1327">}</a>
<a name="ln1328"> </a>
<a name="ln1329">static void dt_bauhaus_widget_reject(dt_bauhaus_widget_t *w)</a>
<a name="ln1330">{</a>
<a name="ln1331">  switch(w-&gt;type)</a>
<a name="ln1332">  {</a>
<a name="ln1333">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1334">      break;</a>
<a name="ln1335">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1336">    {</a>
<a name="ln1337">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1338">      dt_bauhaus_slider_set_normalized(w, d-&gt;oldpos);</a>
<a name="ln1339">    }</a>
<a name="ln1340">    break;</a>
<a name="ln1341">    default:</a>
<a name="ln1342">      break;</a>
<a name="ln1343">  }</a>
<a name="ln1344">}</a>
<a name="ln1345"> </a>
<a name="ln1346">static void dt_bauhaus_widget_accept(dt_bauhaus_widget_t *w)</a>
<a name="ln1347">{</a>
<a name="ln1348">  GtkWidget *widget = GTK_WIDGET(w);</a>
<a name="ln1349">  GtkAllocation allocation;</a>
<a name="ln1350">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1351">  GtkAllocation allocation_popup_window;</a>
<a name="ln1352">  gtk_widget_get_allocation(darktable.bauhaus-&gt;popup_window, &amp;allocation_popup_window);</a>
<a name="ln1353">  int width = allocation_popup_window.width, height = allocation_popup_window.height;</a>
<a name="ln1354">  switch(w-&gt;type)</a>
<a name="ln1355">  {</a>
<a name="ln1356">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1357">    {</a>
<a name="ln1358">      // only set to what's in the filtered list.</a>
<a name="ln1359">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1360">      int active = darktable.bauhaus-&gt;end_mouse_y &gt;= 0</a>
<a name="ln1361">                       ? (darktable.bauhaus-&gt;end_mouse_y / (allocation.height + get_line_space()))</a>
<a name="ln1362">                       : d-&gt;active;</a>
<a name="ln1363">      GList *it = d-&gt;labels;</a>
<a name="ln1364">      int k = 0, i = 0, kk = 0, match = 1;</a>
<a name="ln1365"> </a>
<a name="ln1366">      gchar *keys = g_utf8_casefold(darktable.bauhaus-&gt;keys, -1);</a>
<a name="ln1367">      while(it)</a>
<a name="ln1368">      {</a>
<a name="ln1369">        gchar *text = (gchar *)it-&gt;data;</a>
<a name="ln1370">        gchar *text_cmp = g_utf8_casefold(text, -1);</a>
<a name="ln1371">        if(!strncmp(text_cmp, keys, darktable.bauhaus-&gt;keys_cnt))</a>
<a name="ln1372">        {</a>
<a name="ln1373">          if(active == k)</a>
<a name="ln1374">          {</a>
<a name="ln1375">            dt_bauhaus_combobox_set(widget, i);</a>
<a name="ln1376">            g_free(keys);</a>
<a name="ln1377">            g_free(text_cmp);</a>
<a name="ln1378">            return;</a>
<a name="ln1379">          }</a>
<a name="ln1380">          kk = i; // remember for down there</a>
<a name="ln1381">          // editable should only snap to perfect matches, not prefixes:</a>
<a name="ln1382">          if(d-&gt;editable &amp;&amp; strcmp(text, darktable.bauhaus-&gt;keys)) match = 0;</a>
<a name="ln1383">          k++;</a>
<a name="ln1384">        }</a>
<a name="ln1385">        i++;</a>
<a name="ln1386">        it = g_list_next(it);</a>
<a name="ln1387">        g_free(text_cmp);</a>
<a name="ln1388">      }</a>
<a name="ln1389">      // if list is short (2 entries could be: typed something similar, and one similar)</a>
<a name="ln1390">      if(k &lt; 3)</a>
<a name="ln1391">      {</a>
<a name="ln1392">        // didn't find it, but had only one matching choice?</a>
<a name="ln1393">        if(k == 1 &amp;&amp; match)</a>
<a name="ln1394">          dt_bauhaus_combobox_set(widget, kk);</a>
<a name="ln1395">        else if(d-&gt;editable)</a>
<a name="ln1396">        {</a>
<a name="ln1397">          // had no close match (k == 1 &amp;&amp; !match) or no match at all (k == 0)</a>
<a name="ln1398">          memset(d-&gt;text, 0, sizeof(d-&gt;text));</a>
<a name="ln1399">          g_strlcpy(d-&gt;text, darktable.bauhaus-&gt;keys, sizeof(d-&gt;text));</a>
<a name="ln1400">          // select custom entry</a>
<a name="ln1401">          dt_bauhaus_combobox_set(widget, -1);</a>
<a name="ln1402">        }</a>
<a name="ln1403">      }</a>
<a name="ln1404">      g_free(keys);</a>
<a name="ln1405">      break;</a>
<a name="ln1406">    }</a>
<a name="ln1407">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1408">    {</a>
<a name="ln1409">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1410">      const float mouse_off = get_slider_line_offset(</a>
<a name="ln1411">          d-&gt;oldpos, d-&gt;scale, darktable.bauhaus-&gt;end_mouse_x / width,</a>
<a name="ln1412">          darktable.bauhaus-&gt;end_mouse_y / height, allocation.height / (float)height, allocation.width);</a>
<a name="ln1413">      dt_bauhaus_slider_set_normalized(w, d-&gt;oldpos + mouse_off);</a>
<a name="ln1414">      d-&gt;oldpos = d-&gt;pos;</a>
<a name="ln1415">      break;</a>
<a name="ln1416">    }</a>
<a name="ln1417">    default:</a>
<a name="ln1418">      break;</a>
<a name="ln1419">  }</a>
<a name="ln1420">}</a>
<a name="ln1421"> </a>
<a name="ln1422">static gboolean dt_bauhaus_popup_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln1423">{</a>
<a name="ln1424">  GtkAllocation allocation;</a>
<a name="ln1425">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1426">  dt_bauhaus_widget_t *w = darktable.bauhaus-&gt;current;</a>
<a name="ln1427">  // dimensions of the popup</a>
<a name="ln1428">  int width = allocation.width, height = allocation.height;</a>
<a name="ln1429">  // dimensions of the original line</a>
<a name="ln1430">  GtkWidget *current = GTK_WIDGET(w);</a>
<a name="ln1431">  GtkAllocation allocation_current;</a>
<a name="ln1432">  gtk_widget_get_allocation(current, &amp;allocation_current);</a>
<a name="ln1433">  int wd = allocation_current.width, ht = allocation_current.height;</a>
<a name="ln1434">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln1435">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln1436"> </a>
<a name="ln1437">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln1438">  gtk_render_background(context, cr, 0.0, 0.0, width, height);</a>
<a name="ln1439"> </a>
<a name="ln1440">  GdkRGBA text_color, text_color_selected, text_color_hover;</a>
<a name="ln1441">  gtk_style_context_get_color(context, GTK_STATE_FLAG_NORMAL, &amp;text_color);</a>
<a name="ln1442">  gtk_style_context_get_color(context, GTK_STATE_FLAG_SELECTED, &amp;text_color_selected);</a>
<a name="ln1443">  gtk_style_context_get_color(context, GTK_STATE_FLAG_PRELIGHT, &amp;text_color_hover);</a>
<a name="ln1444"> </a>
<a name="ln1445">  // draw line around popup</a>
<a name="ln1446">  cairo_set_line_width(cr, 1.0);</a>
<a name="ln1447">  set_color(cr, darktable.bauhaus-&gt;color_border);</a>
<a name="ln1448">  if(w-&gt;type == DT_BAUHAUS_COMBOBOX)</a>
<a name="ln1449">  {</a>
<a name="ln1450">    // separate more clearly (looks terrible in a way but might help separate text</a>
<a name="ln1451">    // from other widgets above and below)</a>
<a name="ln1452">    cairo_move_to(cr, 1.0, height - 1.0);</a>
<a name="ln1453">    cairo_line_to(cr, width - 1.0, height - 1.0);</a>
<a name="ln1454">    cairo_line_to(cr, width - 1.0, 1.0);</a>
<a name="ln1455">    cairo_stroke(cr);</a>
<a name="ln1456">    GdkRGBA color = darktable.bauhaus-&gt;color_border;</a>
<a name="ln1457">    color.alpha = 0.4;</a>
<a name="ln1458">    set_color(cr, color);</a>
<a name="ln1459">    cairo_move_to(cr, 1.0, height - 1.0);</a>
<a name="ln1460">    cairo_line_to(cr, 1.0, 1.0);</a>
<a name="ln1461">    cairo_line_to(cr, width - 1.0, 1.0);</a>
<a name="ln1462">    cairo_stroke(cr);</a>
<a name="ln1463">  }</a>
<a name="ln1464">  else</a>
<a name="ln1465">  {</a>
<a name="ln1466">    // blend in</a>
<a name="ln1467">    cairo_move_to(cr, 1.0, 3.0 * ht);</a>
<a name="ln1468">    cairo_line_to(cr, 1.0, height - 1);</a>
<a name="ln1469">    cairo_line_to(cr, width - 1, height - 1);</a>
<a name="ln1470">    cairo_line_to(cr, width - 1, 3.0 * ht);</a>
<a name="ln1471">    cairo_stroke(cr);</a>
<a name="ln1472">    // fade in line around popup:</a>
<a name="ln1473">    for(int k = 0; k &lt; 4; k++)</a>
<a name="ln1474">    {</a>
<a name="ln1475">      cairo_set_line_width(cr, (k + 1) / 4.0f);</a>
<a name="ln1476">      cairo_move_to(cr, 1.0, ht * (2.f + k / 4.0f));</a>
<a name="ln1477">      cairo_line_to(cr, 1.0, ht * (2.f + (k + 1) / 4.0f));</a>
<a name="ln1478">      cairo_move_to(cr, width - 1.0, ht * (2.f + k / 4.0f));</a>
<a name="ln1479">      cairo_line_to(cr, width - 1.0, ht * (2.f + (k + 1) / 4.0f));</a>
<a name="ln1480">      cairo_stroke(cr);</a>
<a name="ln1481">    }</a>
<a name="ln1482">  }</a>
<a name="ln1483"> </a>
<a name="ln1484">  // switch on bauhaus widget type (so we only need one static window)</a>
<a name="ln1485">  switch(w-&gt;type)</a>
<a name="ln1486">  {</a>
<a name="ln1487">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1488">    {</a>
<a name="ln1489">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1490"> </a>
<a name="ln1491">      dt_bauhaus_draw_baseline(w, cr);</a>
<a name="ln1492"> </a>
<a name="ln1493">      cairo_save(cr);</a>
<a name="ln1494">      cairo_set_line_width(cr, 1.);</a>
<a name="ln1495">      const int num_scales = 1.f / d-&gt;scale;</a>
<a name="ln1496">      // don't draw over orientation line</a>
<a name="ln1497">      cairo_rectangle(cr, 0.0f, 0.9 * ht, width, height);</a>
<a name="ln1498">      cairo_clip(cr);</a>
<a name="ln1499">      GdkRGBA color = darktable.bauhaus-&gt;color_border;</a>
<a name="ln1500">      for(int k = 0; k &lt; num_scales; k++)</a>
<a name="ln1501">      {</a>
<a name="ln1502">        const float off = k * d-&gt;scale - d-&gt;oldpos;</a>
<a name="ln1503">        color.alpha = d-&gt;scale / fabsf(off);</a>
<a name="ln1504">        set_color(cr, color);</a>
<a name="ln1505">        draw_slider_line(cr, d-&gt;oldpos, off, d-&gt;scale, width, height, ht);</a>
<a name="ln1506">        cairo_stroke(cr);</a>
<a name="ln1507">      }</a>
<a name="ln1508">      cairo_restore(cr);</a>
<a name="ln1509">      set_color(cr, text_color);</a>
<a name="ln1510">      show_pango_text(cr, w-&gt;label, 2, 0, 0, FALSE);</a>
<a name="ln1511"> </a>
<a name="ln1512">      // draw mouse over indicator line</a>
<a name="ln1513">      cairo_save(cr);</a>
<a name="ln1514">      set_color(cr, darktable.bauhaus-&gt;color_fg);</a>
<a name="ln1515">      cairo_set_line_width(cr, 2.);</a>
<a name="ln1516">      const float mouse_off</a>
<a name="ln1517">          = darktable.bauhaus-&gt;change_active</a>
<a name="ln1518">                ? get_slider_line_offset(d-&gt;oldpos, d-&gt;scale, darktable.bauhaus-&gt;mouse_x / width,</a>
<a name="ln1519">                                         darktable.bauhaus-&gt;mouse_y / height, ht / (float)height, width)</a>
<a name="ln1520">                : 0.0f;</a>
<a name="ln1521">      draw_slider_line(cr, d-&gt;oldpos, mouse_off, d-&gt;scale, width, height, ht);</a>
<a name="ln1522">      cairo_stroke(cr);</a>
<a name="ln1523">      cairo_restore(cr);</a>
<a name="ln1524"> </a>
<a name="ln1525">      // draw indicator</a>
<a name="ln1526">      dt_bauhaus_draw_indicator(w, d-&gt;oldpos + mouse_off, cr);</a>
<a name="ln1527"> </a>
<a name="ln1528">      // draw numerical value:</a>
<a name="ln1529">      cairo_save(cr);</a>
<a name="ln1530">      char text[256];</a>
<a name="ln1531">      const float f = d-&gt;min + (d-&gt;oldpos + mouse_off) * (d-&gt;max - d-&gt;min);</a>
<a name="ln1532">      const float fc = d-&gt;callback(widget, f, DT_BAUHAUS_GET);</a>
<a name="ln1533">      snprintf(text, sizeof(text), d-&gt;format, fc);</a>
<a name="ln1534">      set_color(cr, text_color);</a>
<a name="ln1535">      show_pango_text(cr, text, wd - 4 - ht, 0, 0, TRUE);</a>
<a name="ln1536"> </a>
<a name="ln1537">      cairo_restore(cr);</a>
<a name="ln1538">    }</a>
<a name="ln1539">    break;</a>
<a name="ln1540">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1541">    {</a>
<a name="ln1542">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1543">      cairo_save(cr);</a>
<a name="ln1544">      float first_label_width = 0.0;</a>
<a name="ln1545">      gboolean first_label = TRUE;</a>
<a name="ln1546">      int k = 0, i = 0;</a>
<a name="ln1547">      int hovered = darktable.bauhaus-&gt;mouse_y / (ht + get_line_space());</a>
<a name="ln1548">      gchar *keys = g_utf8_casefold(darktable.bauhaus-&gt;keys, -1);</a>
<a name="ln1549">      for(GList *it_label = d-&gt;labels, *it_align = d-&gt;alignments; it_label &amp;&amp; it_align;</a>
<a name="ln1550">          it_label = g_list_next(it_label), it_align = g_list_next(it_align))</a>
<a name="ln1551">      {</a>
<a name="ln1552">        dt_bauhaus_combobox_alignment_t align = GPOINTER_TO_INT(it_align-&gt;data);</a>
<a name="ln1553">        gchar *text = (gchar *)it_label-&gt;data;</a>
<a name="ln1554">        gchar *text_cmp = g_utf8_casefold(text, -1);</a>
<a name="ln1555">        if(!strncmp(text_cmp, keys, darktable.bauhaus-&gt;keys_cnt))</a>
<a name="ln1556">        {</a>
<a name="ln1557">          float max_width = wd - 4 - ht;</a>
<a name="ln1558">          if(first_label) max_width *= 0.8; // give the label at least some room</a>
<a name="ln1559"> </a>
<a name="ln1560">          float label_width;</a>
<a name="ln1561">          if(i == hovered)</a>
<a name="ln1562">            set_color(cr, text_color_hover);</a>
<a name="ln1563">          else if(i == d-&gt;active)</a>
<a name="ln1564">            set_color(cr, text_color_selected);</a>
<a name="ln1565">          else</a>
<a name="ln1566">            set_color(cr, text_color);</a>
<a name="ln1567"> </a>
<a name="ln1568">          if(align == DT_BAUHAUS_COMBOBOX_ALIGN_LEFT)</a>
<a name="ln1569">            label_width = show_pango_text(cr, text, 2, (get_line_space() + ht) * k, max_width, FALSE);</a>
<a name="ln1570">          else</a>
<a name="ln1571">            label_width = show_pango_text(cr, text, wd - 4 - ht, (get_line_space() + ht) * k, max_width, TRUE);</a>
<a name="ln1572"> </a>
<a name="ln1573">          // prefer the entry over the label wrt. ellipsization when expanded</a>
<a name="ln1574">          if(first_label)</a>
<a name="ln1575">          {</a>
<a name="ln1576">            first_label_width = label_width;</a>
<a name="ln1577">            first_label = FALSE;</a>
<a name="ln1578">          }</a>
<a name="ln1579"> </a>
<a name="ln1580">          k++;</a>
<a name="ln1581">        }</a>
<a name="ln1582">        i++;</a>
<a name="ln1583">        g_free(text_cmp);</a>
<a name="ln1584">      }</a>
<a name="ln1585">      cairo_restore(cr);</a>
<a name="ln1586"> </a>
<a name="ln1587">      // left aligned box label. add it to the gui after the entries so we can ellipsize it if needed</a>
<a name="ln1588">      set_color(cr, text_color);</a>
<a name="ln1589">      show_pango_text(cr, w-&gt;label, 2, 0, wd - 8 - ht - first_label_width, FALSE);</a>
<a name="ln1590"> </a>
<a name="ln1591">      g_free(keys);</a>
<a name="ln1592">    }</a>
<a name="ln1593">    break;</a>
<a name="ln1594">    default:</a>
<a name="ln1595">      // yell</a>
<a name="ln1596">      break;</a>
<a name="ln1597">  }</a>
<a name="ln1598"> </a>
<a name="ln1599">  // draw currently typed text. if a type doesn't want this, it should not</a>
<a name="ln1600">  // allow stuff to be written here in the key callback.</a>
<a name="ln1601">  if(darktable.bauhaus-&gt;keys_cnt)</a>
<a name="ln1602">  {</a>
<a name="ln1603">    cairo_save(cr);</a>
<a name="ln1604">    PangoLayout *layout;</a>
<a name="ln1605">    PangoRectangle ink;</a>
<a name="ln1606">    layout = pango_cairo_create_layout(cr);</a>
<a name="ln1607">    pango_cairo_context_set_resolution(pango_layout_get_context(layout), darktable.gui-&gt;dpi);</a>
<a name="ln1608">    set_color(cr, text_color);</a>
<a name="ln1609"> </a>
<a name="ln1610">    // make extra large, but without dependency on popup window height</a>
<a name="ln1611">    // (that might differ for comboboxes for example). only fall back</a>
<a name="ln1612">    // to height dependency if the popup is really small.</a>
<a name="ln1613">    const int line_height = get_line_height();</a>
<a name="ln1614">    const int size = MIN(3 * line_height, .2 * height);</a>
<a name="ln1615">    PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln1616">    pango_font_description_set_absolute_size(desc, size * PANGO_SCALE);</a>
<a name="ln1617">    pango_layout_set_font_description(layout, desc);</a>
<a name="ln1618"> </a>
<a name="ln1619">    pango_layout_set_text(layout, darktable.bauhaus-&gt;keys, -1);</a>
<a name="ln1620">    pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln1621">    cairo_move_to(cr, wd - 4 - ht - ink.width, height * 0.5 - size);</a>
<a name="ln1622">    pango_cairo_show_layout(cr, layout);</a>
<a name="ln1623">    cairo_restore(cr);</a>
<a name="ln1624">    pango_font_description_free(desc);</a>
<a name="ln1625">    g_object_unref(layout);</a>
<a name="ln1626">  }</a>
<a name="ln1627">  if(darktable.bauhaus-&gt;cursor_visible)</a>
<a name="ln1628">  {</a>
<a name="ln1629">    // show the blinking cursor</a>
<a name="ln1630">    cairo_save(cr);</a>
<a name="ln1631">    set_color(cr, text_color);</a>
<a name="ln1632">    const int line_height = get_line_height();</a>
<a name="ln1633">    cairo_move_to(cr, wd - ht + 3, height * 0.5 + line_height);</a>
<a name="ln1634">    cairo_line_to(cr, wd - ht + 3, height * 0.5 - 3 * line_height);</a>
<a name="ln1635">    cairo_set_line_width(cr, 2.);</a>
<a name="ln1636">    cairo_stroke(cr);</a>
<a name="ln1637">    cairo_restore(cr);</a>
<a name="ln1638">  }</a>
<a name="ln1639"> </a>
<a name="ln1640">  cairo_destroy(cr);</a>
<a name="ln1641">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln1642">  cairo_paint(crf);</a>
<a name="ln1643">  cairo_surface_destroy(cst);</a>
<a name="ln1644"> </a>
<a name="ln1645">  return TRUE;</a>
<a name="ln1646">}</a>
<a name="ln1647"> </a>
<a name="ln1648">static gboolean dt_bauhaus_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln1649">{</a>
<a name="ln1650">  GtkAllocation allocation;</a>
<a name="ln1651">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1652">  dt_bauhaus_widget_t *w = DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1653">  const int width = allocation.width, height = allocation.height;</a>
<a name="ln1654">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln1655">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln1656"> </a>
<a name="ln1657">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln1658"> </a>
<a name="ln1659">  GdkRGBA text_color;</a>
<a name="ln1660">  gtk_style_context_get_color(context, gtk_style_context_get_state(context), &amp;text_color);</a>
<a name="ln1661"> </a>
<a name="ln1662">  gtk_render_background(context, cr, 0.0, 0.0, width, height);</a>
<a name="ln1663"> </a>
<a name="ln1664">  // draw type specific content:</a>
<a name="ln1665">  cairo_save(cr);</a>
<a name="ln1666">  cairo_set_line_width(cr, 1.0);</a>
<a name="ln1667">  switch(w-&gt;type)</a>
<a name="ln1668">  {</a>
<a name="ln1669">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1670">    {</a>
<a name="ln1671">      // draw label and quad area at right end</a>
<a name="ln1672">      set_color(cr, text_color);</a>
<a name="ln1673">      float label_width</a>
<a name="ln1674">          = show_pango_text(cr, w-&gt;label, 2, 0, 0, FALSE);</a>
<a name="ln1675">      dt_bauhaus_draw_quad(w, cr);</a>
<a name="ln1676"> </a>
<a name="ln1677">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1678">      gchar *text = d-&gt;text;</a>
<a name="ln1679">      if(d-&gt;active &gt;= 0) text = (gchar *)g_list_nth_data(d-&gt;labels, d-&gt;active);</a>
<a name="ln1680">      set_color(cr, text_color);</a>
<a name="ln1681">      show_pango_text(cr, text, width - 4 - height, 0, width - 4 - height - label_width - height, TRUE/*,</a>
<a name="ln1682">                      gtk_widget_is_sensitive(widget), FALSE*/);</a>
<a name="ln1683">      break;</a>
<a name="ln1684">    }</a>
<a name="ln1685">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1686">    {</a>
<a name="ln1687">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1688"> </a>
<a name="ln1689">      // line for orientation</a>
<a name="ln1690">      dt_bauhaus_draw_baseline(w, cr);</a>
<a name="ln1691">      dt_bauhaus_draw_quad(w, cr);</a>
<a name="ln1692"> </a>
<a name="ln1693">      if(gtk_widget_is_sensitive(widget))</a>
<a name="ln1694">      {</a>
<a name="ln1695">        dt_bauhaus_draw_indicator(w, d-&gt;pos, cr);</a>
<a name="ln1696"> </a>
<a name="ln1697">        // TODO: merge that text with combo</a>
<a name="ln1698">        char text[256];</a>
<a name="ln1699">        const float f = d-&gt;min + d-&gt;pos * (d-&gt;max - d-&gt;min);</a>
<a name="ln1700">        const float fc = d-&gt;callback(widget, f, DT_BAUHAUS_GET);</a>
<a name="ln1701">        snprintf(text, sizeof(text), d-&gt;format, fc);</a>
<a name="ln1702">        set_color(cr, text_color);</a>
<a name="ln1703">        show_pango_text(cr, text, width - 4 - height, 0, 0, TRUE);</a>
<a name="ln1704">      }</a>
<a name="ln1705">      // label on top of marker:</a>
<a name="ln1706">      set_color(cr, text_color);</a>
<a name="ln1707">      show_pango_text(cr, w-&gt;label, 2, 0, 0, FALSE/*, gtk_widget_is_sensitive(widget), FALSE*/);</a>
<a name="ln1708">    }</a>
<a name="ln1709">    break;</a>
<a name="ln1710">    default:</a>
<a name="ln1711">      break;</a>
<a name="ln1712">  }</a>
<a name="ln1713">  cairo_restore(cr);</a>
<a name="ln1714"> </a>
<a name="ln1715">  cairo_destroy(cr);</a>
<a name="ln1716">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln1717">  cairo_paint(crf);</a>
<a name="ln1718">  cairo_surface_destroy(cst);</a>
<a name="ln1719"> </a>
<a name="ln1720">  return TRUE;</a>
<a name="ln1721">}</a>
<a name="ln1722"> </a>
<a name="ln1723">void dt_bauhaus_hide_popup()</a>
<a name="ln1724">{</a>
<a name="ln1725">  if(darktable.bauhaus-&gt;current)</a>
<a name="ln1726">  {</a>
<a name="ln1727">    gtk_grab_remove(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1728">    gtk_widget_hide(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1729">    darktable.bauhaus-&gt;current = NULL;</a>
<a name="ln1730">    // TODO: give focus to center view? do in accept() as well?</a>
<a name="ln1731">  }</a>
<a name="ln1732">  _stop_cursor();</a>
<a name="ln1733">}</a>
<a name="ln1734"> </a>
<a name="ln1735">void dt_bauhaus_show_popup(dt_bauhaus_widget_t *w)</a>
<a name="ln1736">{</a>
<a name="ln1737">  if(darktable.bauhaus-&gt;current) dt_bauhaus_hide_popup();</a>
<a name="ln1738">  darktable.bauhaus-&gt;current = w;</a>
<a name="ln1739">  darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln1740">  memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln1741">  darktable.bauhaus-&gt;change_active = 0;</a>
<a name="ln1742">  darktable.bauhaus-&gt;mouse_line_distance = 0.0f;</a>
<a name="ln1743">  _stop_cursor();</a>
<a name="ln1744"> </a>
<a name="ln1745">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1746"> </a>
<a name="ln1747">  int offset = 0;</a>
<a name="ln1748">  GtkAllocation tmp;</a>
<a name="ln1749">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln1750"> </a>
<a name="ln1751">  gtk_widget_realize(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1752">  switch(darktable.bauhaus-&gt;current-&gt;type)</a>
<a name="ln1753">  {</a>
<a name="ln1754">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln1755">    {</a>
<a name="ln1756">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1757">      d-&gt;oldpos = d-&gt;pos;</a>
<a name="ln1758">      tmp.height = tmp.width;</a>
<a name="ln1759">      _start_cursor(6);</a>
<a name="ln1760">      break;</a>
<a name="ln1761">    }</a>
<a name="ln1762">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln1763">    {</a>
<a name="ln1764">      // we launch the dynamic populate fct if any</a>
<a name="ln1765">      if(w-&gt;combo_populate) w-&gt;combo_populate(GTK_WIDGET(w), &amp;w-&gt;module);</a>
<a name="ln1766">      // comboboxes change immediately</a>
<a name="ln1767">      darktable.bauhaus-&gt;change_active = 1;</a>
<a name="ln1768">      dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1769">      tmp.height = (tmp.height + get_line_space()) * d-&gt;num_labels;</a>
<a name="ln1770">      GtkAllocation allocation_w;</a>
<a name="ln1771">      gtk_widget_get_allocation(GTK_WIDGET(w), &amp;allocation_w);</a>
<a name="ln1772">      const int ht = allocation_w.height;</a>
<a name="ln1773">      const int skip = ht + get_line_space();</a>
<a name="ln1774">      offset = -d-&gt;active * skip;</a>
<a name="ln1775">      darktable.bauhaus-&gt;mouse_x = 0;</a>
<a name="ln1776">      darktable.bauhaus-&gt;mouse_y = d-&gt;active * skip + ht / 2;</a>
<a name="ln1777">      break;</a>
<a name="ln1778">    }</a>
<a name="ln1779">    default:</a>
<a name="ln1780">      break;</a>
<a name="ln1781">  }</a>
<a name="ln1782"> </a>
<a name="ln1783">  gint wx, wy;</a>
<a name="ln1784">  gdk_window_get_origin(gtk_widget_get_window(GTK_WIDGET(w)), &amp;wx, &amp;wy);</a>
<a name="ln1785"> </a>
<a name="ln1786">  // move popup so mouse is over currently active item, to minimize confusion with scroll wheel:</a>
<a name="ln1787">  if(darktable.bauhaus-&gt;current-&gt;type == DT_BAUHAUS_COMBOBOX) wy += offset;</a>
<a name="ln1788"> </a>
<a name="ln1789">  // gtk_widget_get_window will return null if not shown yet.</a>
<a name="ln1790">  // it is needed for gdk_window_move, and gtk_window move will</a>
<a name="ln1791">  // sometimes be ignored. this is why we always call both...</a>
<a name="ln1792">  // we also don't want to show before move, as this results in noticeable flickering.</a>
<a name="ln1793">  GdkWindow *window = gtk_widget_get_window(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1794">  if(window) gdk_window_move(window, wx, wy);</a>
<a name="ln1795">  gtk_window_move(GTK_WINDOW(darktable.bauhaus-&gt;popup_window), wx, wy);</a>
<a name="ln1796">  gtk_widget_set_size_request(darktable.bauhaus-&gt;popup_area, tmp.width, tmp.height);</a>
<a name="ln1797">  gtk_widget_set_size_request(darktable.bauhaus-&gt;popup_window, tmp.width, tmp.height);</a>
<a name="ln1798">  gtk_widget_show_all(darktable.bauhaus-&gt;popup_window);</a>
<a name="ln1799">  gtk_widget_grab_focus(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln1800">}</a>
<a name="ln1801"> </a>
<a name="ln1802">static gboolean dt_bauhaus_slider_add_delta_internal(GtkWidget *widget, float delta, guint state)</a>
<a name="ln1803">{</a>
<a name="ln1804">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1805">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1806"> </a>
<a name="ln1807">  float multiplier;</a>
<a name="ln1808"> </a>
<a name="ln1809">  GdkModifierType modifiers = gtk_accelerator_get_default_mod_mask();</a>
<a name="ln1810">  if((state &amp; modifiers) == GDK_SHIFT_MASK)</a>
<a name="ln1811">  {</a>
<a name="ln1812">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_rough_step_multiplier&quot;);</a>
<a name="ln1813">  }</a>
<a name="ln1814">  else if((state &amp; modifiers) == GDK_CONTROL_MASK)</a>
<a name="ln1815">  {</a>
<a name="ln1816">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_precise_step_multiplier&quot;);</a>
<a name="ln1817">  }</a>
<a name="ln1818">  else</a>
<a name="ln1819">  {</a>
<a name="ln1820">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_step_multiplier&quot;);</a>
<a name="ln1821">  }</a>
<a name="ln1822"> </a>
<a name="ln1823">  delta *= multiplier;</a>
<a name="ln1824"> </a>
<a name="ln1825">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1826"> </a>
<a name="ln1827">  dt_bauhaus_slider_set_normalized(w, d-&gt;pos + delta);</a>
<a name="ln1828"> </a>
<a name="ln1829">  return TRUE;</a>
<a name="ln1830">}</a>
<a name="ln1831"> </a>
<a name="ln1832">static gboolean dt_bauhaus_slider_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln1833">{</a>
<a name="ln1834">  gdouble delta_y;</a>
<a name="ln1835">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1836">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return FALSE;</a>
<a name="ln1837">  gtk_widget_grab_focus(widget);</a>
<a name="ln1838"> </a>
<a name="ln1839">  if(dt_gui_get_scroll_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln1840">  {</a>
<a name="ln1841">    delta_y *= -w-&gt;data.slider.scale / 5.0;</a>
<a name="ln1842">    return dt_bauhaus_slider_add_delta_internal(widget, delta_y, event-&gt;state);</a>
<a name="ln1843">  }</a>
<a name="ln1844"> </a>
<a name="ln1845">  return FALSE;</a>
<a name="ln1846">}</a>
<a name="ln1847"> </a>
<a name="ln1848">static gboolean dt_bauhaus_slider_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data)</a>
<a name="ln1849">{</a>
<a name="ln1850">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1851">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return FALSE;</a>
<a name="ln1852">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1853"> </a>
<a name="ln1854">  int handled = 0;</a>
<a name="ln1855">  float delta = 0.0f;</a>
<a name="ln1856">  if(event-&gt;keyval == GDK_KEY_Up || event-&gt;keyval == GDK_KEY_KP_Up || event-&gt;keyval == GDK_KEY_Right</a>
<a name="ln1857">     || event-&gt;keyval == GDK_KEY_KP_Right)</a>
<a name="ln1858">  {</a>
<a name="ln1859">    handled = 1;</a>
<a name="ln1860">    delta = d-&gt;scale / 5.0f;</a>
<a name="ln1861">  }</a>
<a name="ln1862">  else if(event-&gt;keyval == GDK_KEY_Down || event-&gt;keyval == GDK_KEY_KP_Down || event-&gt;keyval == GDK_KEY_Left</a>
<a name="ln1863">          || event-&gt;keyval == GDK_KEY_KP_Left)</a>
<a name="ln1864">  {</a>
<a name="ln1865">    handled = 1;</a>
<a name="ln1866">    delta = -d-&gt;scale / 5.0f;</a>
<a name="ln1867">  }</a>
<a name="ln1868"> </a>
<a name="ln1869">  if(!handled) return FALSE;</a>
<a name="ln1870"> </a>
<a name="ln1871">  return dt_bauhaus_slider_add_delta_internal(widget, delta, event-&gt;state);</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874"> </a>
<a name="ln1875">static gboolean dt_bauhaus_combobox_scroll(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln1876">{</a>
<a name="ln1877">  int delta_y;</a>
<a name="ln1878">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1879">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln1880">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1881">  gtk_widget_grab_focus(widget);</a>
<a name="ln1882"> </a>
<a name="ln1883">  if(dt_gui_get_scroll_unit_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln1884">  {</a>
<a name="ln1885">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1886">    dt_bauhaus_combobox_set(widget, CLAMP(d-&gt;active + delta_y, 0, d-&gt;num_labels - 1));</a>
<a name="ln1887">    return TRUE;</a>
<a name="ln1888">  }</a>
<a name="ln1889"> </a>
<a name="ln1890">  return FALSE;</a>
<a name="ln1891">}</a>
<a name="ln1892"> </a>
<a name="ln1893">static gboolean dt_bauhaus_combobox_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data)</a>
<a name="ln1894">{</a>
<a name="ln1895">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1896">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln1897">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1898">  if(event-&gt;keyval == GDK_KEY_Up || event-&gt;keyval == GDK_KEY_KP_Up || event-&gt;keyval == GDK_KEY_Left</a>
<a name="ln1899">     || event-&gt;keyval == GDK_KEY_KP_Left)</a>
<a name="ln1900">  {</a>
<a name="ln1901">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1902">    dt_bauhaus_combobox_set(widget, CLAMP(d-&gt;active - 1, 0, d-&gt;num_labels - 1));</a>
<a name="ln1903">    return TRUE;</a>
<a name="ln1904">  }</a>
<a name="ln1905">  else if(event-&gt;keyval == GDK_KEY_Down || event-&gt;keyval == GDK_KEY_KP_Down || event-&gt;keyval == GDK_KEY_Right</a>
<a name="ln1906">          || event-&gt;keyval == GDK_KEY_KP_Right)</a>
<a name="ln1907">  {</a>
<a name="ln1908">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1909">    dt_bauhaus_combobox_set(widget, CLAMP(d-&gt;active + 1, 0, d-&gt;num_labels - 1));</a>
<a name="ln1910">    return TRUE;</a>
<a name="ln1911">  }</a>
<a name="ln1912">  return FALSE;</a>
<a name="ln1913">}</a>
<a name="ln1914"> </a>
<a name="ln1915">static gboolean dt_bauhaus_combobox_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln1916">{</a>
<a name="ln1917">  GtkAllocation allocation;</a>
<a name="ln1918">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1919">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln1920">  if(w-&gt;type != DT_BAUHAUS_COMBOBOX) return FALSE;</a>
<a name="ln1921">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln1922">  gtk_widget_grab_focus(GTK_WIDGET(w));</a>
<a name="ln1923">  GtkAllocation tmp;</a>
<a name="ln1924">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln1925">  dt_bauhaus_combobox_data_t *d = &amp;w-&gt;data.combobox;</a>
<a name="ln1926">  if(w-&gt;quad_paint &amp;&amp; (event-&gt;x &gt; allocation.width - allocation.height))</a>
<a name="ln1927">  {</a>
<a name="ln1928">    if (w-&gt;quad_toggle)</a>
<a name="ln1929">    {</a>
<a name="ln1930">      if (w-&gt;quad_paint_flags &amp; CPF_ACTIVE)</a>
<a name="ln1931">        w-&gt;quad_paint_flags &amp;= ~CPF_ACTIVE;</a>
<a name="ln1932">      else</a>
<a name="ln1933">        w-&gt;quad_paint_flags |= CPF_ACTIVE;</a>
<a name="ln1934">    }</a>
<a name="ln1935">    g_signal_emit_by_name(G_OBJECT(w), &quot;quad-pressed&quot;);</a>
<a name="ln1936">    return TRUE;</a>
<a name="ln1937">  }</a>
<a name="ln1938">  else if(event-&gt;button == 3)</a>
<a name="ln1939">  {</a>
<a name="ln1940">    darktable.bauhaus-&gt;mouse_x = event-&gt;x;</a>
<a name="ln1941">    darktable.bauhaus-&gt;mouse_y = event-&gt;y;</a>
<a name="ln1942">    dt_bauhaus_show_popup(w);</a>
<a name="ln1943">    return TRUE;</a>
<a name="ln1944">  }</a>
<a name="ln1945">  else if(event-&gt;button == 1)</a>
<a name="ln1946">  {</a>
<a name="ln1947">    // reset to default.</a>
<a name="ln1948">    if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln1949">    {</a>
<a name="ln1950">      // never called, as we popup the other window under your cursor before.</a>
<a name="ln1951">      // (except in weird corner cases where the popup is under the -1st entry</a>
<a name="ln1952">      dt_bauhaus_combobox_set(widget, d-&gt;defpos);</a>
<a name="ln1953">      dt_bauhaus_hide_popup();</a>
<a name="ln1954">    }</a>
<a name="ln1955">    else</a>
<a name="ln1956">    {</a>
<a name="ln1957">      // single click, show options</a>
<a name="ln1958">      darktable.bauhaus-&gt;opentime = dt_get_wtime();</a>
<a name="ln1959">      darktable.bauhaus-&gt;mouse_x = event-&gt;x;</a>
<a name="ln1960">      darktable.bauhaus-&gt;mouse_y = event-&gt;y;</a>
<a name="ln1961">      dt_bauhaus_show_popup(w);</a>
<a name="ln1962">    }</a>
<a name="ln1963">    return TRUE;</a>
<a name="ln1964">  }</a>
<a name="ln1965">  return FALSE;</a>
<a name="ln1966">}</a>
<a name="ln1967"> </a>
<a name="ln1968">float dt_bauhaus_slider_get(GtkWidget *widget)</a>
<a name="ln1969">{</a>
<a name="ln1970">  // first cast to bh widget, to check that type:</a>
<a name="ln1971">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1972">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return -1.0f;</a>
<a name="ln1973">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1974">  if(d-&gt;max == d-&gt;min) {</a>
<a name="ln1975">    return d-&gt;max;</a>
<a name="ln1976">  }</a>
<a name="ln1977">  float rawval = d-&gt;min + d-&gt;pos * (d-&gt;max - d-&gt;min);</a>
<a name="ln1978">  return d-&gt;callback(widget, rawval, DT_BAUHAUS_GET);</a>
<a name="ln1979">}</a>
<a name="ln1980"> </a>
<a name="ln1981">void dt_bauhaus_slider_set(GtkWidget *widget, float pos)</a>
<a name="ln1982">{</a>
<a name="ln1983">  // this is the public interface function, translate by bounds and call set_normalized</a>
<a name="ln1984">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1985">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1986">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1987">  float rawval = d-&gt;callback(widget, pos, DT_BAUHAUS_SET);</a>
<a name="ln1988">  dt_bauhaus_slider_set_normalized(w, (rawval - d-&gt;min) / (d-&gt;max - d-&gt;min));</a>
<a name="ln1989">}</a>
<a name="ln1990"> </a>
<a name="ln1991">void dt_bauhaus_slider_set_digits(GtkWidget *widget, int val)</a>
<a name="ln1992">{</a>
<a name="ln1993">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln1994"> </a>
<a name="ln1995">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln1996"> </a>
<a name="ln1997">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln1998"> </a>
<a name="ln1999">  d-&gt;digits = val;</a>
<a name="ln2000">  snprintf(d-&gt;format, sizeof(d-&gt;format), &quot;%%.0%df&quot;, val);</a>
<a name="ln2001">}</a>
<a name="ln2002"> </a>
<a name="ln2003">int dt_bauhaus_slider_get_digits(GtkWidget *widget)</a>
<a name="ln2004">{</a>
<a name="ln2005">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2006"> </a>
<a name="ln2007">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return 0;</a>
<a name="ln2008"> </a>
<a name="ln2009">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2010"> </a>
<a name="ln2011">  return d-&gt;digits;</a>
<a name="ln2012">}</a>
<a name="ln2013"> </a>
<a name="ln2014">void dt_bauhaus_slider_set_step(GtkWidget *widget, float val)</a>
<a name="ln2015">{</a>
<a name="ln2016">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2017"> </a>
<a name="ln2018">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2019"> </a>
<a name="ln2020">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2021"> </a>
<a name="ln2022">  d-&gt;step = val;</a>
<a name="ln2023">  d-&gt;scale = 5.0f * d-&gt;step / (d-&gt;max - d-&gt;min);</a>
<a name="ln2024">}</a>
<a name="ln2025"> </a>
<a name="ln2026">float dt_bauhaus_slider_get_step(GtkWidget *widget)</a>
<a name="ln2027">{</a>
<a name="ln2028">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2029"> </a>
<a name="ln2030">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return 0;</a>
<a name="ln2031"> </a>
<a name="ln2032">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2033"> </a>
<a name="ln2034">  return d-&gt;step;</a>
<a name="ln2035">}</a>
<a name="ln2036"> </a>
<a name="ln2037">void dt_bauhaus_slider_reset(GtkWidget *widget)</a>
<a name="ln2038">{</a>
<a name="ln2039">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2040"> </a>
<a name="ln2041">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2042">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2043"> </a>
<a name="ln2044">  d-&gt;min = d-&gt;soft_min;</a>
<a name="ln2045">  d-&gt;max = d-&gt;soft_max;</a>
<a name="ln2046">  dt_bauhaus_slider_set_normalized(w, d-&gt;defpos);</a>
<a name="ln2047"> </a>
<a name="ln2048">  return;</a>
<a name="ln2049">}</a>
<a name="ln2050"> </a>
<a name="ln2051">void dt_bauhaus_slider_set_format(GtkWidget *widget, const char *format)</a>
<a name="ln2052">{</a>
<a name="ln2053">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2054">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2055">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2056">  g_strlcpy(d-&gt;format, format, sizeof(d-&gt;format));</a>
<a name="ln2057">}</a>
<a name="ln2058"> </a>
<a name="ln2059">void dt_bauhaus_slider_set_callback(GtkWidget *widget, float (*callback)(GtkWidget *self, float value, dt_bauhaus_callback_t dir))</a>
<a name="ln2060">{</a>
<a name="ln2061">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2062">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2063">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2064">  d-&gt;callback = (callback == NULL ? _default_linear_callback : callback);</a>
<a name="ln2065">}</a>
<a name="ln2066"> </a>
<a name="ln2067">void dt_bauhaus_slider_set_soft(GtkWidget *widget, float pos)</a>
<a name="ln2068">{</a>
<a name="ln2069">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)DT_BAUHAUS_WIDGET(widget);</a>
<a name="ln2070">  if(w-&gt;type != DT_BAUHAUS_SLIDER) return;</a>
<a name="ln2071">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2072">  float rawval = d-&gt;callback(widget, pos, DT_BAUHAUS_SET);</a>
<a name="ln2073">  float rpos = CLAMP(rawval, d-&gt;hard_min, d-&gt;hard_max);</a>
<a name="ln2074">  d-&gt;min = MIN(d-&gt;min, rpos);</a>
<a name="ln2075">  d-&gt;max = MAX(d-&gt;max, rpos);</a>
<a name="ln2076">  d-&gt;scale = 5.0f * d-&gt;step / (d-&gt;max - d-&gt;min);</a>
<a name="ln2077">  rpos = (rpos - d-&gt;min) / (d-&gt;max - d-&gt;min);</a>
<a name="ln2078">  dt_bauhaus_slider_set_normalized(w, rpos);</a>
<a name="ln2079">}</a>
<a name="ln2080"> </a>
<a name="ln2081">static void dt_bauhaus_slider_set_normalized(dt_bauhaus_widget_t *w, float pos)</a>
<a name="ln2082">{</a>
<a name="ln2083">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2084">  float rpos = CLAMP(pos, 0.0f, 1.0f);</a>
<a name="ln2085">  rpos = d-&gt;min + (d-&gt;max - d-&gt;min) * rpos;</a>
<a name="ln2086">  const float base = powf(10.0f, d-&gt;digits);</a>
<a name="ln2087">  rpos = roundf(base * rpos) / base;</a>
<a name="ln2088">  d-&gt;pos = (rpos - d-&gt;min) / (d-&gt;max - d-&gt;min);</a>
<a name="ln2089">  gtk_widget_queue_draw(GTK_WIDGET(w));</a>
<a name="ln2090">  d-&gt;is_changed = 1;</a>
<a name="ln2091">  if(!darktable.gui-&gt;reset &amp;&amp; !d-&gt;is_dragging)</a>
<a name="ln2092">  {</a>
<a name="ln2093">    g_signal_emit_by_name(G_OBJECT(w), &quot;value-changed&quot;);</a>
<a name="ln2094">    d-&gt;is_changed = 0;</a>
<a name="ln2095">  }</a>
<a name="ln2096">}</a>
<a name="ln2097"> </a>
<a name="ln2098">static gboolean dt_bauhaus_slider_postponed_value_change(gpointer data)</a>
<a name="ln2099">{</a>
<a name="ln2100">  if(!GTK_IS_WIDGET(data)) return 0;</a>
<a name="ln2101"> </a>
<a name="ln2102">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)data;</a>
<a name="ln2103">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2104">  if(d-&gt;is_changed)</a>
<a name="ln2105">  {</a>
<a name="ln2106">    g_signal_emit_by_name(G_OBJECT(w), &quot;value-changed&quot;);</a>
<a name="ln2107">    d-&gt;is_changed = 0;</a>
<a name="ln2108">  }</a>
<a name="ln2109"> </a>
<a name="ln2110">  if(!d-&gt;is_dragging) d-&gt;timeout_handle = 0;</a>
<a name="ln2111"> </a>
<a name="ln2112">  return d-&gt;is_dragging;</a>
<a name="ln2113">}</a>
<a name="ln2114"> </a>
<a name="ln2115">static gboolean dt_bauhaus_popup_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data)</a>
<a name="ln2116">{</a>
<a name="ln2117">  switch(darktable.bauhaus-&gt;current-&gt;type)</a>
<a name="ln2118">  {</a>
<a name="ln2119">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln2120">    {</a>
<a name="ln2121">      // hack to do screenshots from popup:</a>
<a name="ln2122">      // if(event-&gt;string[0] == 'p') return system(&quot;scrot&quot;);</a>
<a name="ln2123">      // else</a>
<a name="ln2124">      if(darktable.bauhaus-&gt;keys_cnt + 2 &lt; 64</a>
<a name="ln2125">         &amp;&amp; (event-&gt;keyval == GDK_KEY_space || event-&gt;keyval == GDK_KEY_KP_Space || // SPACE</a>
<a name="ln2126">             event-&gt;keyval == GDK_KEY_percent ||                                    // %</a>
<a name="ln2127">             (event-&gt;string[0] &gt;= 40 &amp;&amp; event-&gt;string[0] &lt;= 57) ||                  // ()+-*/.,0-9</a>
<a name="ln2128">             event-&gt;keyval == GDK_KEY_asciicircum ||                                // ^</a>
<a name="ln2129">             event-&gt;keyval == GDK_KEY_X || event-&gt;keyval == GDK_KEY_x))             // Xx</a>
<a name="ln2130">      {</a>
<a name="ln2131">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt++] = event-&gt;string[0];</a>
<a name="ln2132">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2133">      }</a>
<a name="ln2134">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0</a>
<a name="ln2135">              &amp;&amp; (event-&gt;keyval == GDK_KEY_BackSpace || event-&gt;keyval == GDK_KEY_Delete))</a>
<a name="ln2136">      {</a>
<a name="ln2137">        darktable.bauhaus-&gt;keys[--darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2138">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2139">      }</a>
<a name="ln2140">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0 &amp;&amp; darktable.bauhaus-&gt;keys_cnt + 1 &lt; 64</a>
<a name="ln2141">              &amp;&amp; (event-&gt;keyval == GDK_KEY_Return || event-&gt;keyval == GDK_KEY_KP_Enter))</a>
<a name="ln2142">      {</a>
<a name="ln2143">        // accept input</a>
<a name="ln2144">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2145">        // unnormalized input, user was typing this:</a>
<a name="ln2146">        float old_value = dt_bauhaus_slider_get(GTK_WIDGET(darktable.bauhaus-&gt;current));</a>
<a name="ln2147">        float new_value = dt_calculator_solve(old_value, darktable.bauhaus-&gt;keys);</a>
<a name="ln2148">        if(isfinite(new_value)) dt_bauhaus_slider_set_soft(GTK_WIDGET(darktable.bauhaus-&gt;current), new_value);</a>
<a name="ln2149">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2150">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2151">        dt_bauhaus_hide_popup();</a>
<a name="ln2152">      }</a>
<a name="ln2153">      else if(event-&gt;keyval == GDK_KEY_Escape)</a>
<a name="ln2154">      {</a>
<a name="ln2155">        // discard input and close popup</a>
<a name="ln2156">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2157">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2158">        dt_bauhaus_hide_popup();</a>
<a name="ln2159">      }</a>
<a name="ln2160">      else</a>
<a name="ln2161">        return FALSE;</a>
<a name="ln2162">      if(darktable.bauhaus-&gt;keys_cnt &gt; 0) _start_cursor(-1);</a>
<a name="ln2163">      return TRUE;</a>
<a name="ln2164">    }</a>
<a name="ln2165">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln2166">    {</a>
<a name="ln2167">      if(!g_utf8_validate(event-&gt;string, -1, NULL)) return FALSE;</a>
<a name="ln2168">      gunichar c = g_utf8_get_char(event-&gt;string);</a>
<a name="ln2169">      long int char_width = g_utf8_next_char(event-&gt;string) - event-&gt;string;</a>
<a name="ln2170">      // if(event-&gt;string[0] == 'p') return system(&quot;scrot&quot;);</a>
<a name="ln2171">      // else</a>
<a name="ln2172">      if(darktable.bauhaus-&gt;keys_cnt + 1 + char_width &lt; 64 &amp;&amp; g_unichar_isprint(c))</a>
<a name="ln2173">      {</a>
<a name="ln2174">        // only accept key input if still valid or editable?</a>
<a name="ln2175">        g_utf8_strncpy(darktable.bauhaus-&gt;keys + darktable.bauhaus-&gt;keys_cnt, event-&gt;string, 1);</a>
<a name="ln2176">        darktable.bauhaus-&gt;keys_cnt += char_width;</a>
<a name="ln2177">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2178">      }</a>
<a name="ln2179">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0</a>
<a name="ln2180">              &amp;&amp; (event-&gt;keyval == GDK_KEY_BackSpace || event-&gt;keyval == GDK_KEY_Delete))</a>
<a name="ln2181">      {</a>
<a name="ln2182">        darktable.bauhaus-&gt;keys_cnt</a>
<a name="ln2183">            -= (darktable.bauhaus-&gt;keys + darktable.bauhaus-&gt;keys_cnt)</a>
<a name="ln2184">               - g_utf8_prev_char(darktable.bauhaus-&gt;keys + darktable.bauhaus-&gt;keys_cnt);</a>
<a name="ln2185">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2186">        gtk_widget_queue_draw(darktable.bauhaus-&gt;popup_area);</a>
<a name="ln2187">      }</a>
<a name="ln2188">      else if(darktable.bauhaus-&gt;keys_cnt &gt; 0 &amp;&amp; darktable.bauhaus-&gt;keys_cnt + 1 &lt; 64</a>
<a name="ln2189">              &amp;&amp; (event-&gt;keyval == GDK_KEY_Return || event-&gt;keyval == GDK_KEY_KP_Enter))</a>
<a name="ln2190">      {</a>
<a name="ln2191">        // accept unique matches only for editable:</a>
<a name="ln2192">        if(darktable.bauhaus-&gt;current-&gt;data.combobox.editable)</a>
<a name="ln2193">          darktable.bauhaus-&gt;end_mouse_y = FLT_MAX;</a>
<a name="ln2194">        else</a>
<a name="ln2195">          darktable.bauhaus-&gt;end_mouse_y = 0;</a>
<a name="ln2196">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2197">        dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln2198">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2199">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2200">        dt_bauhaus_hide_popup();</a>
<a name="ln2201">      }</a>
<a name="ln2202">      else if(event-&gt;keyval == GDK_KEY_Escape)</a>
<a name="ln2203">      {</a>
<a name="ln2204">        // discard input and close popup</a>
<a name="ln2205">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2206">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2207">        dt_bauhaus_hide_popup();</a>
<a name="ln2208">      }</a>
<a name="ln2209">      else if(event-&gt;keyval == GDK_KEY_Up)</a>
<a name="ln2210">      {</a>
<a name="ln2211">        combobox_popup_scroll(-1);</a>
<a name="ln2212">      }</a>
<a name="ln2213">      else if(event-&gt;keyval == GDK_KEY_Down)</a>
<a name="ln2214">      {</a>
<a name="ln2215">        combobox_popup_scroll(1);</a>
<a name="ln2216">      }</a>
<a name="ln2217">      else if(event-&gt;keyval == GDK_KEY_Return || event-&gt;keyval == GDK_KEY_KP_Enter)</a>
<a name="ln2218">      {</a>
<a name="ln2219">        // return pressed, but didn't type anything</a>
<a name="ln2220">        darktable.bauhaus-&gt;end_mouse_y = -1; // negative will use currently highlighted instead.</a>
<a name="ln2221">        darktable.bauhaus-&gt;keys[darktable.bauhaus-&gt;keys_cnt] = 0;</a>
<a name="ln2222">        darktable.bauhaus-&gt;keys_cnt = 0;</a>
<a name="ln2223">        memset(darktable.bauhaus-&gt;keys, 0, sizeof(darktable.bauhaus-&gt;keys));</a>
<a name="ln2224">        dt_bauhaus_widget_accept(darktable.bauhaus-&gt;current);</a>
<a name="ln2225">        dt_bauhaus_hide_popup();</a>
<a name="ln2226">      }</a>
<a name="ln2227">      else</a>
<a name="ln2228">        return FALSE;</a>
<a name="ln2229">      return TRUE;</a>
<a name="ln2230">    }</a>
<a name="ln2231">    default:</a>
<a name="ln2232">      return FALSE;</a>
<a name="ln2233">  }</a>
<a name="ln2234">}</a>
<a name="ln2235"> </a>
<a name="ln2236">static gboolean dt_bauhaus_slider_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2237">{</a>
<a name="ln2238">  GtkAllocation allocation;</a>
<a name="ln2239">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln2240">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2241">  if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2242">  gtk_widget_grab_focus(GTK_WIDGET(w));</a>
<a name="ln2243">  GtkAllocation tmp;</a>
<a name="ln2244">  gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2245">  if(w-&gt;quad_paint &amp;&amp; (event-&gt;x &gt; allocation.width - allocation.height))</a>
<a name="ln2246">  {</a>
<a name="ln2247">    if (w-&gt;quad_toggle)</a>
<a name="ln2248">    {</a>
<a name="ln2249">      if (w-&gt;quad_paint_flags &amp; CPF_ACTIVE)</a>
<a name="ln2250">        w-&gt;quad_paint_flags &amp;= ~CPF_ACTIVE;</a>
<a name="ln2251">      else</a>
<a name="ln2252">        w-&gt;quad_paint_flags |= CPF_ACTIVE;</a>
<a name="ln2253">    }</a>
<a name="ln2254">    g_signal_emit_by_name(G_OBJECT(w), &quot;quad-pressed&quot;);</a>
<a name="ln2255">    return TRUE;</a>
<a name="ln2256">  }</a>
<a name="ln2257">  else if(event-&gt;button == 3)</a>
<a name="ln2258">  {</a>
<a name="ln2259">    dt_bauhaus_show_popup(w);</a>
<a name="ln2260">    return TRUE;</a>
<a name="ln2261">  }</a>
<a name="ln2262">  else if(event-&gt;button == 1)</a>
<a name="ln2263">  {</a>
<a name="ln2264">    // reset to default.</a>
<a name="ln2265">    if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln2266">    {</a>
<a name="ln2267">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2268">      d-&gt;is_dragging = 0;</a>
<a name="ln2269">      dt_bauhaus_slider_reset(GTK_WIDGET(w));</a>
<a name="ln2270">    }</a>
<a name="ln2271">    else</a>
<a name="ln2272">    {</a>
<a name="ln2273">      const float l = 4.0f / tmp.width;</a>
<a name="ln2274">      const float r = 1.0f - (tmp.height + 4.0f) / tmp.width;</a>
<a name="ln2275">      dt_bauhaus_slider_set_normalized(w, (event-&gt;x / tmp.width - l) / (r - l));</a>
<a name="ln2276">      dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2277">      d-&gt;is_dragging = 1;</a>
<a name="ln2278">      int delay = CLAMP(darktable.develop-&gt;average_delay * 3 / 2, DT_BAUHAUS_SLIDER_VALUE_CHANGED_DELAY_MIN,</a>
<a name="ln2279">                        DT_BAUHAUS_SLIDER_VALUE_CHANGED_DELAY_MAX);</a>
<a name="ln2280">      // timeout_handle should always be zero here, but check just in case</a>
<a name="ln2281">      if(!d-&gt;timeout_handle)</a>
<a name="ln2282">        d-&gt;timeout_handle = g_timeout_add(delay, dt_bauhaus_slider_postponed_value_change, widget);</a>
<a name="ln2283">    }</a>
<a name="ln2284">    return TRUE;</a>
<a name="ln2285">  }</a>
<a name="ln2286">  return FALSE;</a>
<a name="ln2287">}</a>
<a name="ln2288"> </a>
<a name="ln2289">static gboolean dt_bauhaus_slider_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2290">{</a>
<a name="ln2291">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2292">  dt_bauhaus_slider_data_t *d = &amp;w-&gt;data.slider;</a>
<a name="ln2293"> </a>
<a name="ln2294">  if((event-&gt;button == 1) &amp;&amp; (d-&gt;is_dragging))</a>
<a name="ln2295">  {</a>
<a name="ln2296">    if(w-&gt;module) dt_iop_request_focus(w-&gt;module);</a>
<a name="ln2297">    GtkAllocation tmp;</a>
<a name="ln2298">    gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2299">    d-&gt;is_dragging = 0;</a>
<a name="ln2300">    if(d-&gt;timeout_handle) g_source_remove(d-&gt;timeout_handle);</a>
<a name="ln2301">    d-&gt;timeout_handle = 0;</a>
<a name="ln2302">    const float l = 4.0f / tmp.width;</a>
<a name="ln2303">    const float r = 1.0f - (tmp.height + 4.0f) / tmp.width;</a>
<a name="ln2304">    dt_bauhaus_slider_set_normalized(w, (event-&gt;x / tmp.width - l) / (r - l));</a>
<a name="ln2305"> </a>
<a name="ln2306">    return TRUE;</a>
<a name="ln2307">  }</a>
<a name="ln2308">  return FALSE;</a>
<a name="ln2309">}</a>
<a name="ln2310"> </a>
<a name="ln2311">static gboolean dt_bauhaus_slider_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln2312">{</a>
<a name="ln2313">  // remember mouse position for motion effects in draw</a>
<a name="ln2314">  if(event-&gt;state &amp; GDK_BUTTON1_MASK &amp;&amp; event-&gt;type != GDK_2BUTTON_PRESS)</a>
<a name="ln2315">  {</a>
<a name="ln2316">    dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)widget;</a>
<a name="ln2317">    GtkAllocation tmp;</a>
<a name="ln2318">    gtk_widget_get_allocation(GTK_WIDGET(w), &amp;tmp);</a>
<a name="ln2319">    const float l = 4.0f / tmp.width;</a>
<a name="ln2320">    const float r = 1.0f - (tmp.height + 4.0f) / tmp.width;</a>
<a name="ln2321">    dt_bauhaus_slider_set_normalized(w, (event-&gt;x / tmp.width - l) / (r - l));</a>
<a name="ln2322">  }</a>
<a name="ln2323">  // not sure if needed:</a>
<a name="ln2324">  // gdk_event_request_motions(event);</a>
<a name="ln2325">  return TRUE;</a>
<a name="ln2326">}</a>
<a name="ln2327"> </a>
<a name="ln2328">void dt_bauhaus_vimkey_exec(const char *input)</a>
<a name="ln2329">{</a>
<a name="ln2330">  char module[64], label[64], value[256], *key;</a>
<a name="ln2331">  float old_value, new_value;</a>
<a name="ln2332"> </a>
<a name="ln2333">  sscanf(input, &quot;:set %[^.].%[^=]=%s&quot;, module, label, value);</a>
<a name="ln2334">  fprintf(stderr, &quot;[vimkey] setting module `%s', slider `%s' to `%s'&quot;, module, label, value);</a>
<a name="ln2335">  key = g_strjoin(&quot;.&quot;, module, label, NULL);</a>
<a name="ln2336">  dt_bauhaus_widget_t *w = (dt_bauhaus_widget_t *)g_hash_table_lookup(darktable.bauhaus-&gt;keymap, key);</a>
<a name="ln2337">  g_free(key);</a>
<a name="ln2338">  if(!w) return;</a>
<a name="ln2339">  switch(w-&gt;type)</a>
<a name="ln2340">  {</a>
<a name="ln2341">    case DT_BAUHAUS_SLIDER:</a>
<a name="ln2342">      old_value = dt_bauhaus_slider_get(GTK_WIDGET(w));</a>
<a name="ln2343">      new_value = dt_calculator_solve(old_value, value);</a>
<a name="ln2344">      fprintf(stderr, &quot; = %f\n&quot;, new_value);</a>
<a name="ln2345">      if(isfinite(new_value)) dt_bauhaus_slider_set_soft(GTK_WIDGET(w), new_value);</a>
<a name="ln2346">      break;</a>
<a name="ln2347">    case DT_BAUHAUS_COMBOBOX:</a>
<a name="ln2348">      // TODO: what about text as entry?</a>
<a name="ln2349">      old_value = dt_bauhaus_combobox_get(GTK_WIDGET(w));</a>
<a name="ln2350">      new_value = dt_calculator_solve(old_value, value);</a>
<a name="ln2351">      fprintf(stderr, &quot; = %f\n&quot;, new_value);</a>
<a name="ln2352">      if(isfinite(new_value)) dt_bauhaus_combobox_set(GTK_WIDGET(w), new_value);</a>
<a name="ln2353">      break;</a>
<a name="ln2354">    default:</a>
<a name="ln2355">      break;</a>
<a name="ln2356">  }</a>
<a name="ln2357">}</a>
<a name="ln2358"> </a>
<a name="ln2359">// give autocomplete suggestions</a>
<a name="ln2360">GList *dt_bauhaus_vimkey_complete(const char *input)</a>
<a name="ln2361">{</a>
<a name="ln2362">  GList *cmp = darktable.bauhaus-&gt;key_mod;</a>
<a name="ln2363">  char *point = strstr(input, &quot;.&quot;);</a>
<a name="ln2364">  if(point) cmp = darktable.bauhaus-&gt;key_val;</a>
<a name="ln2365">  int prefix = strlen(input);</a>
<a name="ln2366">  GList *res = NULL;</a>
<a name="ln2367">  int after = 0;</a>
<a name="ln2368">  while(cmp)</a>
<a name="ln2369">  {</a>
<a name="ln2370">    char *path = (char *)cmp-&gt;data;</a>
<a name="ln2371">    if(strncasecmp(path, input, prefix))</a>
<a name="ln2372">    {</a>
<a name="ln2373">      if(after) break; // sorted, so we're done</a>
<a name="ln2374">                       // else loop till we find the start of it</a>
<a name="ln2375">    }</a>
<a name="ln2376">    else</a>
<a name="ln2377">    {</a>
<a name="ln2378">      // append:</a>
<a name="ln2379">      res = g_list_insert_sorted(res, path, (GCompareFunc)strcmp);</a>
<a name="ln2380">      after = 1;</a>
<a name="ln2381">    }</a>
<a name="ln2382">    cmp = g_list_next(cmp);</a>
<a name="ln2383">  }</a>
<a name="ln2384">  return res;</a>
<a name="ln2385">}</a>
<a name="ln2386"> </a>
<a name="ln2387">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2388">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2389">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="439"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'darktable.bauhaus'. Check lines: 439, 438.</p></div>
<div class="balloon" rel="2333"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'sscanf' function. It's dangerous to use string specifier without width specification. Buffer overflow is possible.</p></div>
<div class="balloon" rel="2333"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'sscanf' function. It's dangerous to use string specifier without width specification. Buffer overflow is possible.</p></div>
<div class="balloon" rel="2333"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'sscanf' function. It's dangerous to use string specifier without width specification. Buffer overflow is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
