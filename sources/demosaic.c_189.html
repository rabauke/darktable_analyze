
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4">    copyright (c) 2016 Ulrich Pegelow.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln21">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;common/interpolation.h&quot;</a>
<a name="ln24">#include &quot;common/opencl.h&quot;</a>
<a name="ln25">#include &quot;control/conf.h&quot;</a>
<a name="ln26">#include &quot;control/control.h&quot;</a>
<a name="ln27">#include &quot;develop/develop.h&quot;</a>
<a name="ln28">#include &quot;develop/imageop.h&quot;</a>
<a name="ln29">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln30">#include &quot;develop/tiling.h&quot;</a>
<a name="ln31">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln32">#include &quot;gui/gtk.h&quot;</a>
<a name="ln33">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;complex.h&gt;</a>
<a name="ln36">#include &lt;glib.h&gt;</a>
<a name="ln37">#include &lt;math.h&gt;</a>
<a name="ln38">#include &lt;memory.h&gt;</a>
<a name="ln39">#include &lt;stdlib.h&gt;</a>
<a name="ln40">#include &lt;string.h&gt;</a>
<a name="ln41"> </a>
<a name="ln42">// we assume people have -msee support.</a>
<a name="ln43">#if defined(__SSE__)</a>
<a name="ln44">#include &lt;xmmintrin.h&gt;</a>
<a name="ln45">#endif</a>
<a name="ln46"> </a>
<a name="ln47">DT_MODULE_INTROSPECTION(3, dt_iop_demosaic_params_t)</a>
<a name="ln48"> </a>
<a name="ln49">#define DEMOSAIC_XTRANS 1024 // masks for non-Bayer demosaic ops</a>
<a name="ln50">#define REDUCESIZE 64</a>
<a name="ln51"> </a>
<a name="ln52">typedef enum dt_iop_demosaic_method_t</a>
<a name="ln53">{</a>
<a name="ln54">  // methods for Bayer images</a>
<a name="ln55">  DT_IOP_DEMOSAIC_PPG = 0,</a>
<a name="ln56">  DT_IOP_DEMOSAIC_AMAZE = 1,</a>
<a name="ln57">  DT_IOP_DEMOSAIC_VNG4 = 2,</a>
<a name="ln58">  DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME = 3,</a>
<a name="ln59">  // methods for x-trans images</a>
<a name="ln60">  DT_IOP_DEMOSAIC_VNG = DEMOSAIC_XTRANS | 0,</a>
<a name="ln61">  DT_IOP_DEMOSAIC_MARKESTEIJN = DEMOSAIC_XTRANS | 1,</a>
<a name="ln62">  DT_IOP_DEMOSAIC_MARKESTEIJN_3 = DEMOSAIC_XTRANS | 2,</a>
<a name="ln63">  DT_IOP_DEMOSAIC_FDC = DEMOSAIC_XTRANS | 4</a>
<a name="ln64">} dt_iop_demosaic_method_t;</a>
<a name="ln65"> </a>
<a name="ln66">typedef enum dt_iop_demosaic_greeneq_t</a>
<a name="ln67">{</a>
<a name="ln68">  DT_IOP_GREEN_EQ_NO = 0,</a>
<a name="ln69">  DT_IOP_GREEN_EQ_LOCAL = 1,</a>
<a name="ln70">  DT_IOP_GREEN_EQ_FULL = 2,</a>
<a name="ln71">  DT_IOP_GREEN_EQ_BOTH = 3</a>
<a name="ln72">} dt_iop_demosaic_greeneq_t;</a>
<a name="ln73"> </a>
<a name="ln74">typedef enum dt_iop_demosaic_qual_flags_t</a>
<a name="ln75">{</a>
<a name="ln76">  // either perform full scale demosaicing or choose simple half scale</a>
<a name="ln77">  // or third scale interpolation instead</a>
<a name="ln78">  DEMOSAIC_FULL_SCALE              = 1 &lt;&lt; 0,</a>
<a name="ln79">  DEMOSAIC_ONLY_VNG_LINEAR         = 1 &lt;&lt; 1,</a>
<a name="ln80">  DEMOSAIC_XTRANS_FULL             = 1 &lt;&lt; 2,</a>
<a name="ln81">  DEMOSAIC_MEDIUM_QUAL             = 1 &lt;&lt; 3</a>
<a name="ln82">} dt_iop_demosaic_qual_flags_t;</a>
<a name="ln83"> </a>
<a name="ln84">typedef struct dt_iop_demosaic_params_t</a>
<a name="ln85">{</a>
<a name="ln86">  dt_iop_demosaic_greeneq_t green_eq;</a>
<a name="ln87">  float median_thrs;</a>
<a name="ln88">  uint32_t color_smoothing;</a>
<a name="ln89">  dt_iop_demosaic_method_t demosaicing_method;</a>
<a name="ln90">  uint32_t yet_unused_data_specific_to_demosaicing_method;</a>
<a name="ln91">} dt_iop_demosaic_params_t;</a>
<a name="ln92"> </a>
<a name="ln93">typedef struct dt_iop_demosaic_gui_data_t</a>
<a name="ln94">{</a>
<a name="ln95">  GtkWidget *box_raw;</a>
<a name="ln96">  GtkWidget *median_thrs;</a>
<a name="ln97">  GtkWidget *greeneq;</a>
<a name="ln98">  GtkWidget *color_smoothing;</a>
<a name="ln99">  GtkWidget *demosaic_method_bayer;</a>
<a name="ln100">  GtkWidget *demosaic_method_xtrans;</a>
<a name="ln101">  GtkWidget *label_non_raw;</a>
<a name="ln102">} dt_iop_demosaic_gui_data_t;</a>
<a name="ln103"> </a>
<a name="ln104">typedef struct dt_iop_demosaic_global_data_t</a>
<a name="ln105">{</a>
<a name="ln106">  // demosaic pattern</a>
<a name="ln107">  int kernel_green_eq_lavg;</a>
<a name="ln108">  int kernel_green_eq_favg_reduce_first;</a>
<a name="ln109">  int kernel_green_eq_favg_reduce_second;</a>
<a name="ln110">  int kernel_green_eq_favg_apply;</a>
<a name="ln111">  int kernel_pre_median;</a>
<a name="ln112">  int kernel_passthrough_monochrome;</a>
<a name="ln113">  int kernel_ppg_green;</a>
<a name="ln114">  int kernel_ppg_redblue;</a>
<a name="ln115">  int kernel_zoom_half_size;</a>
<a name="ln116">  int kernel_downsample;</a>
<a name="ln117">  int kernel_border_interpolate;</a>
<a name="ln118">  int kernel_color_smoothing;</a>
<a name="ln119">  int kernel_zoom_passthrough_monochrome;</a>
<a name="ln120">  int kernel_vng_border_interpolate;</a>
<a name="ln121">  int kernel_vng_lin_interpolate;</a>
<a name="ln122">  int kernel_zoom_third_size;</a>
<a name="ln123">  int kernel_vng_green_equilibrate;</a>
<a name="ln124">  int kernel_vng_interpolate;</a>
<a name="ln125">  int kernel_markesteijn_initial_copy;</a>
<a name="ln126">  int kernel_markesteijn_green_minmax;</a>
<a name="ln127">  int kernel_markesteijn_interpolate_green;</a>
<a name="ln128">  int kernel_markesteijn_solitary_green;</a>
<a name="ln129">  int kernel_markesteijn_recalculate_green;</a>
<a name="ln130">  int kernel_markesteijn_red_and_blue;</a>
<a name="ln131">  int kernel_markesteijn_interpolate_twoxtwo;</a>
<a name="ln132">  int kernel_markesteijn_convert_yuv;</a>
<a name="ln133">  int kernel_markesteijn_differentiate;</a>
<a name="ln134">  int kernel_markesteijn_homo_threshold;</a>
<a name="ln135">  int kernel_markesteijn_homo_set;</a>
<a name="ln136">  int kernel_markesteijn_homo_sum;</a>
<a name="ln137">  int kernel_markesteijn_homo_max;</a>
<a name="ln138">  int kernel_markesteijn_homo_max_corr;</a>
<a name="ln139">  int kernel_markesteijn_homo_quench;</a>
<a name="ln140">  int kernel_markesteijn_zero;</a>
<a name="ln141">  int kernel_markesteijn_accu;</a>
<a name="ln142">  int kernel_markesteijn_final;</a>
<a name="ln143">} dt_iop_demosaic_global_data_t;</a>
<a name="ln144"> </a>
<a name="ln145">typedef struct dt_iop_demosaic_data_t</a>
<a name="ln146">{</a>
<a name="ln147">  uint32_t green_eq;</a>
<a name="ln148">  uint32_t color_smoothing;</a>
<a name="ln149">  uint32_t demosaicing_method;</a>
<a name="ln150">  uint32_t yet_unused_data_specific_to_demosaicing_method;</a>
<a name="ln151">  float median_thrs;</a>
<a name="ln152">  double CAM_to_RGB[3][4];</a>
<a name="ln153">} dt_iop_demosaic_data_t;</a>
<a name="ln154"> </a>
<a name="ln155">void amaze_demosaic_RT(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln156">                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln157">                       const uint32_t filters);</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">const char *name()</a>
<a name="ln161">{</a>
<a name="ln162">  return _(&quot;demosaic&quot;);</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">int default_group()</a>
<a name="ln166">{</a>
<a name="ln167">  return IOP_GROUP_BASIC;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">int flags()</a>
<a name="ln171">{</a>
<a name="ln172">  return IOP_FLAGS_ALLOW_TILING | IOP_FLAGS_ONE_INSTANCE | IOP_FLAGS_FENCE;</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln176">{</a>
<a name="ln177">  return iop_cs_RAW;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln181">{</a>
<a name="ln182">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;edge threshold&quot;));</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln186">{</a>
<a name="ln187">  dt_accel_connect_slider_iop(self, &quot;edge threshold&quot;,</a>
<a name="ln188">                              GTK_WIDGET(((dt_iop_demosaic_gui_data_t *)self-&gt;gui_data)-&gt;median_thrs));</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln192">                  void *new_params, const int new_version)</a>
<a name="ln193">{</a>
<a name="ln194">  if(old_version == 2 &amp;&amp; new_version == 3)</a>
<a name="ln195">  {</a>
<a name="ln196">    dt_iop_demosaic_params_t *o = (dt_iop_demosaic_params_t *)old_params;</a>
<a name="ln197">    dt_iop_demosaic_params_t *n = (dt_iop_demosaic_params_t *)new_params;</a>
<a name="ln198">    n-&gt;green_eq = o-&gt;green_eq;</a>
<a name="ln199">    n-&gt;median_thrs = o-&gt;median_thrs;</a>
<a name="ln200">    n-&gt;color_smoothing = 0;</a>
<a name="ln201">    n-&gt;demosaicing_method = DT_IOP_DEMOSAIC_PPG;</a>
<a name="ln202">    n-&gt;yet_unused_data_specific_to_demosaicing_method = 0;</a>
<a name="ln203">    return 0;</a>
<a name="ln204">  }</a>
<a name="ln205">  return 1;</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">int input_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln209">                     dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln210">{</a>
<a name="ln211">  return iop_cs_RAW;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">int output_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln215">                      dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln216">{</a>
<a name="ln217">  return iop_cs_rgb;</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220">#ifdef HAVE_OPENCL</a>
<a name="ln221">static const char* method2string(dt_iop_demosaic_method_t method)</a>
<a name="ln222">{</a>
<a name="ln223">  const char *string;</a>
<a name="ln224"> </a>
<a name="ln225">  switch(method)</a>
<a name="ln226">  {</a>
<a name="ln227">    case DT_IOP_DEMOSAIC_PPG:</a>
<a name="ln228">      string = &quot;PPG&quot;;</a>
<a name="ln229">      break;</a>
<a name="ln230">    case DT_IOP_DEMOSAIC_AMAZE:</a>
<a name="ln231">      string = &quot;AMaZE&quot;;</a>
<a name="ln232">      break;</a>
<a name="ln233">    case DT_IOP_DEMOSAIC_VNG4:</a>
<a name="ln234">      string = &quot;VNG4&quot;;</a>
<a name="ln235">      break;</a>
<a name="ln236">    case DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME:</a>
<a name="ln237">      string = &quot;passthrough monochrome&quot;;</a>
<a name="ln238">      break;</a>
<a name="ln239">    case DT_IOP_DEMOSAIC_VNG:</a>
<a name="ln240">      string = &quot;VNG (xtrans)&quot;;</a>
<a name="ln241">      break;</a>
<a name="ln242">    case DT_IOP_DEMOSAIC_MARKESTEIJN:</a>
<a name="ln243">      string = &quot;Markesteijn-1 (xtrans)&quot;;</a>
<a name="ln244">      break;</a>
<a name="ln245">    case DT_IOP_DEMOSAIC_MARKESTEIJN_3:</a>
<a name="ln246">      string = &quot;Markesteijn-3 (xtrans)&quot;;</a>
<a name="ln247">      break;</a>
<a name="ln248">    case DT_IOP_DEMOSAIC_FDC:</a>
<a name="ln249">      string = &quot;Frequency Domain Chroma (xtrans)&quot;;</a>
<a name="ln250">      break;</a>
<a name="ln251">    default:</a>
<a name="ln252">      string = &quot;(unknown method)&quot;;</a>
<a name="ln253">  }</a>
<a name="ln254">  return string;</a>
<a name="ln255">}</a>
<a name="ln256">#endif</a>
<a name="ln257"> </a>
<a name="ln258">#define SWAP(a, b)                                                                                           \</a>
<a name="ln259">  {                                                                                                          \</a>
<a name="ln260">    const float tmp = (b);                                                                                   \</a>
<a name="ln261">    (b) = (a);                                                                                               \</a>
<a name="ln262">    (a) = tmp;                                                                                               \</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265">static void pre_median_b(float *out, const float *const in, const dt_iop_roi_t *const roi, const uint32_t filters,</a>
<a name="ln266">                         const int num_passes, const float threshold)</a>
<a name="ln267">{</a>
<a name="ln268">#if 1</a>
<a name="ln269">  memcpy(out, in, (size_t)roi-&gt;width * roi-&gt;height * sizeof(float));</a>
<a name="ln270">#else</a>
<a name="ln271">  // colors:</a>
<a name="ln272">  const float thrsc = 2 * threshold;</a>
<a name="ln273">  for(int pass = 0; pass &lt; num_passes; pass++)</a>
<a name="ln274">  {</a>
<a name="ln275">    for(int c = 0; c &lt; 3; c += 2)</a>
<a name="ln276">    {</a>
<a name="ln277">      int rows = 3;</a>
<a name="ln278">      if(FC(rows, 3, filters) != c &amp;&amp; FC(rows, 4, filters) != c) rows++;</a>
<a name="ln279">#ifdef _OPENMP</a>
<a name="ln280">#pragma omp parallel for default(none) shared(rows, c, out) schedule(static)</a>
<a name="ln281">#endif</a>
<a name="ln282">      for(int row = rows; row &lt; roi-&gt;height - 3; row += 2)</a>
<a name="ln283">      {</a>
<a name="ln284">        float med[9];</a>
<a name="ln285">        int col = 3;</a>
<a name="ln286">        if(FC(row, col, filters) != c) col++;</a>
<a name="ln287">        float *pixo = out + (size_t)roi-&gt;width * row + col;</a>
<a name="ln288">        const float *pixi = in + (size_t)roi-&gt;width * row + col;</a>
<a name="ln289">        for(; col &lt; roi-&gt;width - 3; col += 2)</a>
<a name="ln290">        {</a>
<a name="ln291">          int cnt = 0;</a>
<a name="ln292">          for(int k = 0, i = -2 * roi-&gt;width; i &lt;= 2 * roi-&gt;width; i += 2 * roi-&gt;width)</a>
<a name="ln293">          {</a>
<a name="ln294">            for(int j = i - 2; j &lt;= i + 2; j += 2)</a>
<a name="ln295">            {</a>
<a name="ln296">              if(fabsf(pixi[j] - pixi[0]) &lt; thrsc)</a>
<a name="ln297">              {</a>
<a name="ln298">                med[k++] = pixi[j];</a>
<a name="ln299">                cnt++;</a>
<a name="ln300">              }</a>
<a name="ln301">              else</a>
<a name="ln302">                med[k++] = 64.0f + pixi[j];</a>
<a name="ln303">            }</a>
<a name="ln304">          }</a>
<a name="ln305">          for(int i = 0; i &lt; 8; i++)</a>
<a name="ln306">            for(int ii = i + 1; ii &lt; 9; ii++)</a>
<a name="ln307">              if(med[i] &gt; med[ii]) SWAP(med[i], med[ii]);</a>
<a name="ln308">#if 0</a>
<a name="ln309">          // cnt == 1 and no small edge in greens.</a>
<a name="ln310">          if(fabsf(pixi[-roi-&gt;width] - pixi[+roi-&gt;width]) + fabsf(pixi[-1] - pixi[+1])</a>
<a name="ln311">              + fabsf(pixi[-roi-&gt;width] - pixi[+1]) + fabsf(pixi[-1] - pixi[+roi-&gt;width])</a>
<a name="ln312">              + fabsf(pixi[+roi-&gt;width] - pixi[+1]) + fabsf(pixi[-1] - pixi[-roi-&gt;width])</a>
<a name="ln313">              &gt; 0.06)</a>
<a name="ln314">            pixo[0] = med[(cnt-1)/2];</a>
<a name="ln315">          else</a>
<a name="ln316">#endif</a>
<a name="ln317">          pixo[0] = (cnt == 1 ? med[4] - 64.0f : med[(cnt - 1) / 2]);</a>
<a name="ln318">          pixo += 2;</a>
<a name="ln319">          pixi += 2;</a>
<a name="ln320">        }</a>
<a name="ln321">      }</a>
<a name="ln322">    }</a>
<a name="ln323">  }</a>
<a name="ln324">#endif</a>
<a name="ln325"> </a>
<a name="ln326">  // now green:</a>
<a name="ln327">  const int lim[5] = { 0, 1, 2, 1, 0 };</a>
<a name="ln328">  for(int pass = 0; pass &lt; num_passes; pass++)</a>
<a name="ln329">  {</a>
<a name="ln330">#ifdef _OPENMP</a>
<a name="ln331">#pragma omp parallel for default(none) shared(out) schedule(static)</a>
<a name="ln332">#endif</a>
<a name="ln333">    for(int row = 3; row &lt; roi-&gt;height - 3; row++)</a>
<a name="ln334">    {</a>
<a name="ln335">      float med[9];</a>
<a name="ln336">      int col = 3;</a>
<a name="ln337">      if(FC(row, col, filters) != 1 &amp;&amp; FC(row, col, filters) != 3) col++;</a>
<a name="ln338">      float *pixo = out + (size_t)roi-&gt;width * row + col;</a>
<a name="ln339">      const float *pixi = in + (size_t)roi-&gt;width * row + col;</a>
<a name="ln340">      for(; col &lt; roi-&gt;width - 3; col += 2)</a>
<a name="ln341">      {</a>
<a name="ln342">        int cnt = 0;</a>
<a name="ln343">        for(int k = 0, i = 0; i &lt; 5; i++)</a>
<a name="ln344">        {</a>
<a name="ln345">          for(int j = -lim[i]; j &lt;= lim[i]; j += 2)</a>
<a name="ln346">          {</a>
<a name="ln347">            if(fabsf(pixi[roi-&gt;width * (i - 2) + j] - pixi[0]) &lt; threshold)</a>
<a name="ln348">            {</a>
<a name="ln349">              med[k++] = pixi[roi-&gt;width * (i - 2) + j];</a>
<a name="ln350">              cnt++;</a>
<a name="ln351">            }</a>
<a name="ln352">            else</a>
<a name="ln353">              med[k++] = 64.0f + pixi[roi-&gt;width * (i - 2) + j];</a>
<a name="ln354">          }</a>
<a name="ln355">        }</a>
<a name="ln356">        for(int i = 0; i &lt; 8; i++)</a>
<a name="ln357">          for(int ii = i + 1; ii &lt; 9; ii++)</a>
<a name="ln358">            if(med[i] &gt; med[ii]) SWAP(med[i], med[ii]);</a>
<a name="ln359">        pixo[0] = (cnt == 1 ? med[4] - 64.0f : med[(cnt - 1) / 2]);</a>
<a name="ln360">        // pixo[0] = med[(cnt-1)/2];</a>
<a name="ln361">        pixo += 2;</a>
<a name="ln362">        pixi += 2;</a>
<a name="ln363">      }</a>
<a name="ln364">    }</a>
<a name="ln365">  }</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">static void pre_median(float *out, const float *const in, const dt_iop_roi_t *const roi, const uint32_t filters,</a>
<a name="ln369">                       const int num_passes, const float threshold)</a>
<a name="ln370">{</a>
<a name="ln371">  pre_median_b(out, in, roi, filters, num_passes, threshold);</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">#define SWAPmed(I, J)                                                                                        \</a>
<a name="ln375">  if(med[I] &gt; med[J]) SWAP(med[I], med[J])</a>
<a name="ln376"> </a>
<a name="ln377">static void color_smoothing(float *out, const dt_iop_roi_t *const roi_out, const int num_passes)</a>
<a name="ln378">{</a>
<a name="ln379">  const int width4 = 4 * roi_out-&gt;width;</a>
<a name="ln380"> </a>
<a name="ln381">  for(int pass = 0; pass &lt; num_passes; pass++)</a>
<a name="ln382">  {</a>
<a name="ln383">    for(int c = 0; c &lt; 3; c += 2)</a>
<a name="ln384">    {</a>
<a name="ln385">      {</a>
<a name="ln386">        float *outp = out;</a>
<a name="ln387">        for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln388">          for(int i = 0; i &lt; roi_out-&gt;width; i++, outp += 4) outp[3] = outp[c];</a>
<a name="ln389">      }</a>
<a name="ln390">#ifdef _OPENMP</a>
<a name="ln391">#pragma omp parallel for schedule(static) default(none) shared(out, c)</a>
<a name="ln392">#endif</a>
<a name="ln393">      for(int j = 1; j &lt; roi_out-&gt;height - 1; j++)</a>
<a name="ln394">      {</a>
<a name="ln395">        float *outp = out + (size_t)4 * j * roi_out-&gt;width + 4;</a>
<a name="ln396">        for(int i = 1; i &lt; roi_out-&gt;width - 1; i++, outp += 4)</a>
<a name="ln397">        {</a>
<a name="ln398">          float med[9] = {</a>
<a name="ln399">            outp[-width4 - 4 + 3] - outp[-width4 - 4 + 1], outp[-width4 + 0 + 3] - outp[-width4 + 0 + 1],</a>
<a name="ln400">            outp[-width4 + 4 + 3] - outp[-width4 + 4 + 1], outp[-4 + 3] - outp[-4 + 1],</a>
<a name="ln401">            outp[+0 + 3] - outp[+0 + 1], outp[+4 + 3] - outp[+4 + 1],</a>
<a name="ln402">            outp[+width4 - 4 + 3] - outp[+width4 - 4 + 1], outp[+width4 + 0 + 3] - outp[+width4 + 0 + 1],</a>
<a name="ln403">            outp[+width4 + 4 + 3] - outp[+width4 + 4 + 1],</a>
<a name="ln404">          };</a>
<a name="ln405">          /* optimal 9-element median search */</a>
<a name="ln406">          SWAPmed(1, 2);</a>
<a name="ln407">          SWAPmed(4, 5);</a>
<a name="ln408">          SWAPmed(7, 8);</a>
<a name="ln409">          SWAPmed(0, 1);</a>
<a name="ln410">          SWAPmed(3, 4);</a>
<a name="ln411">          SWAPmed(6, 7);</a>
<a name="ln412">          SWAPmed(1, 2);</a>
<a name="ln413">          SWAPmed(4, 5);</a>
<a name="ln414">          SWAPmed(7, 8);</a>
<a name="ln415">          SWAPmed(0, 3);</a>
<a name="ln416">          SWAPmed(5, 8);</a>
<a name="ln417">          SWAPmed(4, 7);</a>
<a name="ln418">          SWAPmed(3, 6);</a>
<a name="ln419">          SWAPmed(1, 4);</a>
<a name="ln420">          SWAPmed(2, 5);</a>
<a name="ln421">          SWAPmed(4, 7);</a>
<a name="ln422">          SWAPmed(4, 2);</a>
<a name="ln423">          SWAPmed(6, 4);</a>
<a name="ln424">          SWAPmed(4, 2);</a>
<a name="ln425">          outp[c] = fmaxf(med[4] + outp[1], 0.0f);</a>
<a name="ln426">        }</a>
<a name="ln427">      }</a>
<a name="ln428">    }</a>
<a name="ln429">  }</a>
<a name="ln430">}</a>
<a name="ln431">#undef SWAP</a>
<a name="ln432"> </a>
<a name="ln433">static void green_equilibration_lavg(float *out, const float *const in, const int width, const int height,</a>
<a name="ln434">                                     const uint32_t filters, const int x, const int y, const float thr)</a>
<a name="ln435">{</a>
<a name="ln436">  const float maximum = 1.0f;</a>
<a name="ln437"> </a>
<a name="ln438">  int oj = 2, oi = 2;</a>
<a name="ln439">  if(FC(oj + y, oi + x, filters) != 1) oj++;</a>
<a name="ln440">  if(FC(oj + y, oi + x, filters) != 1) oi++;</a>
<a name="ln441">  if(FC(oj + y, oi + x, filters) != 1) oj--;</a>
<a name="ln442"> </a>
<a name="ln443">  memcpy(out, in, height * width * sizeof(float));</a>
<a name="ln444"> </a>
<a name="ln445">#ifdef _OPENMP</a>
<a name="ln446">#pragma omp parallel for schedule(static) default(none) shared(out, oi, oj)</a>
<a name="ln447">#endif</a>
<a name="ln448">  for(size_t j = oj; j &lt; height - 2; j += 2)</a>
<a name="ln449">  {</a>
<a name="ln450">    for(size_t i = oi; i &lt; width - 2; i += 2)</a>
<a name="ln451">    {</a>
<a name="ln452">      const float o1_1 = in[(j - 1) * width + i - 1];</a>
<a name="ln453">      const float o1_2 = in[(j - 1) * width + i + 1];</a>
<a name="ln454">      const float o1_3 = in[(j + 1) * width + i - 1];</a>
<a name="ln455">      const float o1_4 = in[(j + 1) * width + i + 1];</a>
<a name="ln456">      const float o2_1 = in[(j - 2) * width + i];</a>
<a name="ln457">      const float o2_2 = in[(j + 2) * width + i];</a>
<a name="ln458">      const float o2_3 = in[j * width + i - 2];</a>
<a name="ln459">      const float o2_4 = in[j * width + i + 2];</a>
<a name="ln460"> </a>
<a name="ln461">      const float m1 = (o1_1 + o1_2 + o1_3 + o1_4) / 4.0f;</a>
<a name="ln462">      const float m2 = (o2_1 + o2_2 + o2_3 + o2_4) / 4.0f;</a>
<a name="ln463"> </a>
<a name="ln464">      // prevent divide by zero and ...</a>
<a name="ln465">      // guard against m1/m2 becoming too large (due to m2 being too small) which results in hot pixels</a>
<a name="ln466">      if(m2 &gt; 0.0f &amp;&amp; m1 / m2 &lt; maximum * 2.0f)</a>
<a name="ln467">      {</a>
<a name="ln468">        const float c1 = (fabsf(o1_1 - o1_2) + fabsf(o1_1 - o1_3) + fabsf(o1_1 - o1_4) + fabsf(o1_2 - o1_3)</a>
<a name="ln469">                          + fabsf(o1_3 - o1_4) + fabsf(o1_2 - o1_4)) / 6.0f;</a>
<a name="ln470">        const float c2 = (fabsf(o2_1 - o2_2) + fabsf(o2_1 - o2_3) + fabsf(o2_1 - o2_4) + fabsf(o2_2 - o2_3)</a>
<a name="ln471">                          + fabsf(o2_3 - o2_4) + fabsf(o2_2 - o2_4)) / 6.0f;</a>
<a name="ln472">        if((in[j * width + i] &lt; maximum * 0.95f) &amp;&amp; (c1 &lt; maximum * thr) &amp;&amp; (c2 &lt; maximum * thr))</a>
<a name="ln473">        {</a>
<a name="ln474">          out[j * width + i] = in[j * width + i] * m1 / m2;</a>
<a name="ln475">        }</a>
<a name="ln476">      }</a>
<a name="ln477">    }</a>
<a name="ln478">  }</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">static void green_equilibration_favg(float *out, const float *const in, const int width, const int height,</a>
<a name="ln482">                                     const uint32_t filters, const int x, const int y)</a>
<a name="ln483">{</a>
<a name="ln484">  int oj = 0, oi = 0;</a>
<a name="ln485">  // const float ratio_max = 1.1f;</a>
<a name="ln486">  double sum1 = 0.0, sum2 = 0.0, gr_ratio;</a>
<a name="ln487"> </a>
<a name="ln488">  if((FC(oj + y, oi + x, filters) &amp; 1) != 1) oi++;</a>
<a name="ln489">  const int g2_offset = oi ? -1 : 1;</a>
<a name="ln490">  memcpy(out, in, (size_t)height * width * sizeof(float));</a>
<a name="ln491">#ifdef _OPENMP</a>
<a name="ln492">#pragma omp parallel for schedule(static) default(none) reduction(+ : sum1, sum2) shared(oi, oj)</a>
<a name="ln493">#endif</a>
<a name="ln494">  for(size_t j = oj; j &lt; (height - 1); j += 2)</a>
<a name="ln495">  {</a>
<a name="ln496">    for(size_t i = oi; i &lt; (width - 1 - g2_offset); i += 2)</a>
<a name="ln497">    {</a>
<a name="ln498">      sum1 += in[j * width + i];</a>
<a name="ln499">      sum2 += in[(j + 1) * width + i + g2_offset];</a>
<a name="ln500">    }</a>
<a name="ln501">  }</a>
<a name="ln502"> </a>
<a name="ln503">  if(sum1 &gt; 0.0 &amp;&amp; sum2 &gt; 0.0)</a>
<a name="ln504">    gr_ratio = sum2 / sum1;</a>
<a name="ln505">  else</a>
<a name="ln506">    return;</a>
<a name="ln507"> </a>
<a name="ln508">#ifdef _OPENMP</a>
<a name="ln509">#pragma omp parallel for schedule(static) default(none) shared(out, oi, oj, gr_ratio)</a>
<a name="ln510">#endif</a>
<a name="ln511">  for(int j = oj; j &lt; (height - 1); j += 2)</a>
<a name="ln512">  {</a>
<a name="ln513">    for(int i = oi; i &lt; (width - 1 - g2_offset); i += 2)</a>
<a name="ln514">    {</a>
<a name="ln515">      out[(size_t)j * width + i] = in[(size_t)j * width + i] * gr_ratio;</a>
<a name="ln516">    }</a>
<a name="ln517">  }</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520"> </a>
<a name="ln521">//</a>
<a name="ln522">// x-trans specific demosaicing algorithms</a>
<a name="ln523">//</a>
<a name="ln524"> </a>
<a name="ln525">// xtrans_interpolate adapted from dcraw 9.20</a>
<a name="ln526"> </a>
<a name="ln527">#define SQR(x) ((x) * (x))</a>
<a name="ln528">// tile size, optimized to keep data in L2 cache</a>
<a name="ln529">#define TS 122</a>
<a name="ln530"> </a>
<a name="ln531">/** Lookup for allhex[], making sure that row/col aren't negative **/</a>
<a name="ln532">static inline const short *const hexmap(const int row, const int col,</a>
<a name="ln533">                                        short (*const allhex)[3][8])</a>
<a name="ln534">{</a>
<a name="ln535">  // Row and column offsets may be negative, but C's modulo function</a>
<a name="ln536">  // is not useful here with a negative dividend. To be safe, add a</a>
<a name="ln537">  // fairly large multiple of 3. In current code row and col will</a>
<a name="ln538">  // never be less than -9 (1-pass) or -14 (3-pass).</a>
<a name="ln539">  int irow = row + 600;</a>
<a name="ln540">  int icol = col + 600;</a>
<a name="ln541">  assert(irow &gt;= 0 &amp;&amp; icol &gt;= 0);</a>
<a name="ln542">  return allhex[irow % 3][icol % 3];</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">/*</a>
<a name="ln546">   Frank Markesteijn's algorithm for Fuji X-Trans sensors</a>
<a name="ln547"> */</a>
<a name="ln548">static void xtrans_markesteijn_interpolate(float *out, const float *const in,</a>
<a name="ln549">                                           const dt_iop_roi_t *const roi_out,</a>
<a name="ln550">                                           const dt_iop_roi_t *const roi_in,</a>
<a name="ln551">                                           const uint8_t (*const xtrans)[6], const int passes)</a>
<a name="ln552">{</a>
<a name="ln553">  static const short orth[12] = { 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1 },</a>
<a name="ln554">                     patt[2][16] = { { 0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0 },</a>
<a name="ln555">                                     { 0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1 } },</a>
<a name="ln556">                     dir[4] = { 1, TS, TS + 1, TS - 1 };</a>
<a name="ln557"> </a>
<a name="ln558">  short allhex[3][3][8];</a>
<a name="ln559">  // sgrow/sgcol is the offset in the sensor matrix of the solitary</a>
<a name="ln560">  // green pixels (initialized here only to avoid compiler warning)</a>
<a name="ln561">  unsigned short sgrow = 0, sgcol = 0;</a>
<a name="ln562"> </a>
<a name="ln563">  const int width = roi_out-&gt;width;</a>
<a name="ln564">  const int height = roi_out-&gt;height;</a>
<a name="ln565">  const int ndir = 4 &lt;&lt; (passes &gt; 1);</a>
<a name="ln566"> </a>
<a name="ln567">  const size_t buffer_size = (size_t)TS * TS * (ndir * 4 + 3) * sizeof(float);</a>
<a name="ln568">  char *const all_buffers = (char *)dt_alloc_align(64, dt_get_num_threads() * buffer_size);</a>
<a name="ln569">  if(!all_buffers)</a>
<a name="ln570">  {</a>
<a name="ln571">    printf(&quot;[demosaic] not able to allocate Markesteijn buffers\n&quot;);</a>
<a name="ln572">    return;</a>
<a name="ln573">  }</a>
<a name="ln574"> </a>
<a name="ln575">  /* Map a green hexagon around each non-green pixel and vice versa:    */</a>
<a name="ln576">  for(int row = 0; row &lt; 3; row++)</a>
<a name="ln577">    for(int col = 0; col &lt; 3; col++)</a>
<a name="ln578">      for(int ng = 0, d = 0; d &lt; 10; d += 2)</a>
<a name="ln579">      {</a>
<a name="ln580">        int g = FCxtrans(row, col, NULL, xtrans) == 1;</a>
<a name="ln581">        if(FCxtrans(row + orth[d], col + orth[d + 2], NULL, xtrans) == 1)</a>
<a name="ln582">          ng = 0;</a>
<a name="ln583">        else</a>
<a name="ln584">          ng++;</a>
<a name="ln585">        // if there are four non-green pixels adjacent in cardinal</a>
<a name="ln586">        // directions, this is the solitary green pixel</a>
<a name="ln587">        if(ng == 4)</a>
<a name="ln588">        {</a>
<a name="ln589">          sgrow = row;</a>
<a name="ln590">          sgcol = col;</a>
<a name="ln591">        }</a>
<a name="ln592">        if(ng == g + 1)</a>
<a name="ln593">          for(int c = 0; c &lt; 8; c++)</a>
<a name="ln594">          {</a>
<a name="ln595">            int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];</a>
<a name="ln596">            int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];</a>
<a name="ln597">            // offset within TSxTS buffer</a>
<a name="ln598">            allhex[row][col][c ^ (g * 2 &amp; d)] = h + v * TS;</a>
<a name="ln599">          }</a>
<a name="ln600">      }</a>
<a name="ln601"> </a>
<a name="ln602">  // extra passes propagates out errors at edges, hence need more padding</a>
<a name="ln603">  const int pad_tile = (passes == 1) ? 12 : 17;</a>
<a name="ln604">#ifdef _OPENMP</a>
<a name="ln605">#pragma omp parallel for default(none) shared(sgrow, sgcol, allhex, out) schedule(dynamic)</a>
<a name="ln606">#endif</a>
<a name="ln607">  // step through TSxTS cells of image, each tile overlapping the</a>
<a name="ln608">  // prior as interpolation needs a substantial border</a>
<a name="ln609">  for(int top = -pad_tile; top &lt; height - pad_tile; top += TS - (pad_tile*2))</a>
<a name="ln610">  {</a>
<a name="ln611">    char *const buffer = all_buffers + dt_get_thread_num() * buffer_size;</a>
<a name="ln612">    // rgb points to ndir TSxTS tiles of 3 channels (R, G, and B)</a>
<a name="ln613">    float(*rgb)[TS][TS][3] = (float(*)[TS][TS][3])buffer;</a>
<a name="ln614">    // yuv points to 3 channel (Y, u, and v) TSxTS tiles</a>
<a name="ln615">    // note that channels come before tiles to allow for a</a>
<a name="ln616">    // vectorization optimization when building drv[] from yuv[]</a>
<a name="ln617">    float (*const yuv)[TS][TS] = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln618">    // drv points to ndir TSxTS tiles, each a single chanel of derivatives</a>
<a name="ln619">    float (*const drv)[TS][TS] = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 3 + 3) * sizeof(float));</a>
<a name="ln620">    // gmin and gmax reuse memory which is used later by yuv buffer;</a>
<a name="ln621">    // each points to a TSxTS tile of single channel data</a>
<a name="ln622">    float (*const gmin)[TS] = (float(*)[TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln623">    float (*const gmax)[TS] = (float(*)[TS])(buffer + TS * TS * (ndir * 3 + 1) * sizeof(float));</a>
<a name="ln624">    // homo and homosum reuse memory which is used earlier in the</a>
<a name="ln625">    // loop; each points to ndir single-channel TSxTS tiles</a>
<a name="ln626">    uint8_t (*const homo)[TS][TS] = (uint8_t(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln627">    uint8_t (*const homosum)[TS][TS] = (uint8_t(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float)</a>
<a name="ln628">                                                            + TS * TS * ndir * sizeof(uint8_t));</a>
<a name="ln629"> </a>
<a name="ln630">    for(int left = -pad_tile; left &lt; width - pad_tile; left += TS - (pad_tile*2))</a>
<a name="ln631">    {</a>
<a name="ln632">      int mrow = MIN(top + TS, height + pad_tile);</a>
<a name="ln633">      int mcol = MIN(left + TS, width + pad_tile);</a>
<a name="ln634"> </a>
<a name="ln635">      // Copy current tile from in to image buffer. If border goes</a>
<a name="ln636">      // beyond edges of image, fill with mirrored/interpolated edges.</a>
<a name="ln637">      // The extra border avoids discontinuities at image edges.</a>
<a name="ln638">      for(int row = top; row &lt; mrow; row++)</a>
<a name="ln639">        for(int col = left; col &lt; mcol; col++)</a>
<a name="ln640">        {</a>
<a name="ln641">          float(*const pix) = rgb[0][row - top][col - left];</a>
<a name="ln642">          if((col &gt;= 0) &amp;&amp; (row &gt;= 0) &amp;&amp; (col &lt; width) &amp;&amp; (row &lt; height))</a>
<a name="ln643">          {</a>
<a name="ln644">            const int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln645">            for(int c = 0; c &lt; 3; c++) pix[c] = (c == f) ? in[roi_in-&gt;width * row + col] : 0.f;</a>
<a name="ln646">          }</a>
<a name="ln647">          else</a>
<a name="ln648">          {</a>
<a name="ln649">            // mirror a border pixel if beyond image edge</a>
<a name="ln650">            const int c = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln651">            for(int cc = 0; cc &lt; 3; cc++)</a>
<a name="ln652">              if(cc != c)</a>
<a name="ln653">                pix[cc] = 0.0f;</a>
<a name="ln654">              else</a>
<a name="ln655">              {</a>
<a name="ln656">#define TRANSLATE(n, size) ((n &gt;= size) ? (2 * size - n - 2) : abs(n))</a>
<a name="ln657">                const int cy = TRANSLATE(row, height), cx = TRANSLATE(col, width);</a>
<a name="ln658">                if(c == FCxtrans(cy, cx, roi_in, xtrans))</a>
<a name="ln659">                  pix[c] = in[roi_in-&gt;width * cy + cx];</a>
<a name="ln660">                else</a>
<a name="ln661">                {</a>
<a name="ln662">                  // interpolate if mirror pixel is a different color</a>
<a name="ln663">                  float sum = 0.0f;</a>
<a name="ln664">                  uint8_t count = 0;</a>
<a name="ln665">                  for(int y = row - 1; y &lt;= row + 1; y++)</a>
<a name="ln666">                    for(int x = col - 1; x &lt;= col + 1; x++)</a>
<a name="ln667">                    {</a>
<a name="ln668">                      const int yy = TRANSLATE(y, height), xx = TRANSLATE(x, width);</a>
<a name="ln669">                      const int ff = FCxtrans(yy, xx, roi_in, xtrans);</a>
<a name="ln670">                      if(ff == c)</a>
<a name="ln671">                      {</a>
<a name="ln672">                        sum += in[roi_in-&gt;width * yy + xx];</a>
<a name="ln673">                        count++;</a>
<a name="ln674">                      }</a>
<a name="ln675">                    }</a>
<a name="ln676">                  pix[c] = sum / count;</a>
<a name="ln677">                }</a>
<a name="ln678">              }</a>
<a name="ln679">          }</a>
<a name="ln680">        }</a>
<a name="ln681"> </a>
<a name="ln682">      // duplicate rgb[0] to rgb[1], rgb[2], and rgb[3]</a>
<a name="ln683">      for(int c = 1; c &lt;= 3; c++) memcpy(rgb[c], rgb[0], sizeof(*rgb));</a>
<a name="ln684"> </a>
<a name="ln685">      // note that successive calculations are inset within the tile</a>
<a name="ln686">      // so as to give enough border data, and there needs to be a 6</a>
<a name="ln687">      // pixel border initially to allow allhex to find neighboring</a>
<a name="ln688">      // pixels</a>
<a name="ln689"> </a>
<a name="ln690">      /* Set green1 and green3 to the minimum and maximum allowed values:   */</a>
<a name="ln691">      // Run through each red/blue or blue/red pair, setting their g1</a>
<a name="ln692">      // and g3 values to the min/max of green pixels surrounding the</a>
<a name="ln693">      // pair. Use a 3 pixel border as gmin/gmax is used by</a>
<a name="ln694">      // interpolate green which has a 3 pixel border.</a>
<a name="ln695">      const int pad_g1_g3 = 3;</a>
<a name="ln696">      for(int row = top + pad_g1_g3; row &lt; mrow - pad_g1_g3; row++)</a>
<a name="ln697">      {</a>
<a name="ln698">        // setting max to 0.0f signifies that this is a new pair, which</a>
<a name="ln699">        // requires a new min/max calculation of its neighboring greens</a>
<a name="ln700">        float min = FLT_MAX, max = 0.0f;</a>
<a name="ln701">        for(int col = left + pad_g1_g3; col &lt; mcol - pad_g1_g3; col++)</a>
<a name="ln702">        {</a>
<a name="ln703">          // if in row of horizontal red &amp; blue pairs (or processing</a>
<a name="ln704">          // vertical red &amp; blue pairs near image bottom), reset min/max</a>
<a name="ln705">          // between each pair</a>
<a name="ln706">          if(FCxtrans(row, col, roi_in, xtrans) == 1)</a>
<a name="ln707">          {</a>
<a name="ln708">            min = FLT_MAX, max = 0.0f;</a>
<a name="ln709">            continue;</a>
<a name="ln710">          }</a>
<a name="ln711">          // if at start of red &amp; blue pair, calculate min/max of green</a>
<a name="ln712">          // pixels surrounding it; note that while normally using == to</a>
<a name="ln713">          // compare floats is suspect, here the check is if 0.0f has</a>
<a name="ln714">          // explicitly been assigned to max (which signifies a new</a>
<a name="ln715">          // red/blue pair)</a>
<a name="ln716">          if(max == 0.0f)</a>
<a name="ln717">          {</a>
<a name="ln718">            float (*const pix)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln719">            const short *const hex = hexmap(row,col,allhex);</a>
<a name="ln720">            for(int c = 0; c &lt; 6; c++)</a>
<a name="ln721">            {</a>
<a name="ln722">              const float val = pix[hex[c]][1];</a>
<a name="ln723">              if(min &gt; val) min = val;</a>
<a name="ln724">              if(max &lt; val) max = val;</a>
<a name="ln725">            }</a>
<a name="ln726">          }</a>
<a name="ln727">          gmin[row - top][col - left] = min;</a>
<a name="ln728">          gmax[row - top][col - left] = max;</a>
<a name="ln729">          // handle vertical red/blue pairs</a>
<a name="ln730">          switch((row - sgrow) % 3)</a>
<a name="ln731">          {</a>
<a name="ln732">            // hop down a row to second pixel in vertical pair</a>
<a name="ln733">            case 1:</a>
<a name="ln734">              if(row &lt; mrow - 4) row++, col--;</a>
<a name="ln735">              break;</a>
<a name="ln736">            // then if not done with the row hop up and right to next</a>
<a name="ln737">            // vertical red/blue pair, resetting min/max</a>
<a name="ln738">            case 2:</a>
<a name="ln739">              min = FLT_MAX, max = 0.0f;</a>
<a name="ln740">              if((col += 2) &lt; mcol - 4 &amp;&amp; row &gt; top + 3) row--;</a>
<a name="ln741">          }</a>
<a name="ln742">        }</a>
<a name="ln743">      }</a>
<a name="ln744"> </a>
<a name="ln745">      /* Interpolate green horizontally, vertically, and along both diagonals: */</a>
<a name="ln746">      // need a 3 pixel border here as 3*hex[] can have a 3 unit offset</a>
<a name="ln747">      const int pad_g_interp = 3;</a>
<a name="ln748">      for(int row = top + pad_g_interp; row &lt; mrow - pad_g_interp; row++)</a>
<a name="ln749">        for(int col = left + pad_g_interp; col &lt; mcol - pad_g_interp; col++)</a>
<a name="ln750">        {</a>
<a name="ln751">          float color[8];</a>
<a name="ln752">          int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln753">          if(f == 1) continue;</a>
<a name="ln754">          float (*const pix)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln755">          const short *const hex = hexmap(row,col,allhex);</a>
<a name="ln756">          // TODO: these constants come from integer math constants in</a>
<a name="ln757">          // dcraw -- calculate them instead from interpolation math</a>
<a name="ln758">          color[0] = 0.6796875f * (pix[hex[1]][1] + pix[hex[0]][1])</a>
<a name="ln759">                     - 0.1796875f * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);</a>
<a name="ln760">          color[1] = 0.87109375f * pix[hex[3]][1] + pix[hex[2]][1] * 0.13f</a>
<a name="ln761">                     + 0.359375f * (pix[0][f] - pix[-hex[2]][f]);</a>
<a name="ln762">          for(int c = 0; c &lt; 2; c++)</a>
<a name="ln763">            color[2 + c] = 0.640625f * pix[hex[4 + c]][1] + 0.359375f * pix[-2 * hex[4 + c]][1]</a>
<a name="ln764">                           + 0.12890625f * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);</a>
<a name="ln765">          for(int c = 0; c &lt; 4; c++)</a>
<a name="ln766">            rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1]</a>
<a name="ln767">                = CLAMPS(color[c], gmin[row - top][col - left], gmax[row - top][col - left]);</a>
<a name="ln768">        }</a>
<a name="ln769"> </a>
<a name="ln770">      for(int pass = 0; pass &lt; passes; pass++)</a>
<a name="ln771">      {</a>
<a name="ln772">        if(pass == 1)</a>
<a name="ln773">        {</a>
<a name="ln774">          // if on second pass, copy rgb[0] to [3] into rgb[4] to [7],</a>
<a name="ln775">          // and process that second set of buffers</a>
<a name="ln776">          memcpy(rgb + 4, rgb, (size_t)4 * sizeof(*rgb));</a>
<a name="ln777">          rgb += 4;</a>
<a name="ln778">        }</a>
<a name="ln779"> </a>
<a name="ln780">        /* Recalculate green from interpolated values of closer pixels: */</a>
<a name="ln781">        if(pass)</a>
<a name="ln782">        {</a>
<a name="ln783">          const int pad_g_recalc = 6;</a>
<a name="ln784">          for(int row = top + pad_g_recalc; row &lt; mrow - pad_g_recalc; row++)</a>
<a name="ln785">            for(int col = left + pad_g_recalc; col &lt; mcol - pad_g_recalc; col++)</a>
<a name="ln786">            {</a>
<a name="ln787">              int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln788">              if(f == 1) continue;</a>
<a name="ln789">              const short *const hex = hexmap(row,col,allhex);</a>
<a name="ln790">              for(int d = 3; d &lt; 6; d++)</a>
<a name="ln791">              {</a>
<a name="ln792">                float(*rfx)[3] = &amp;rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];</a>
<a name="ln793">                float val = rfx[-2 * hex[d]][1] + 2 * rfx[hex[d]][1] - rfx[-2 * hex[d]][f]</a>
<a name="ln794">                            - 2 * rfx[hex[d]][f] + 3 * rfx[0][f];</a>
<a name="ln795">                rfx[0][1] = CLAMPS(val / 3.0f, gmin[row - top][col - left], gmax[row - top][col - left]);</a>
<a name="ln796">              }</a>
<a name="ln797">            }</a>
<a name="ln798">        }</a>
<a name="ln799"> </a>
<a name="ln800">        /* Interpolate red and blue values for solitary green pixels:   */</a>
<a name="ln801">        const int pad_rb_g = (passes == 1) ? 6 : 5;</a>
<a name="ln802">        for(int row = (top - sgrow + pad_rb_g + 2) / 3 * 3 + sgrow; row &lt; mrow - pad_rb_g; row += 3)</a>
<a name="ln803">          for(int col = (left - sgcol + pad_rb_g + 2) / 3 * 3 + sgcol; col &lt; mcol - pad_rb_g; col += 3)</a>
<a name="ln804">          {</a>
<a name="ln805">            float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln806">            int h = FCxtrans(row, col + 1, roi_in, xtrans);</a>
<a name="ln807">            float diff[6] = { 0.0f };</a>
<a name="ln808">            // interplated color: first index is red/blue, second is</a>
<a name="ln809">            // pass, is double actual result</a>
<a name="ln810">            float color[2][6];</a>
<a name="ln811">            // Six passes, alternating hori/vert interp (i),</a>
<a name="ln812">            // starting with R or B (h) depending on which is closest.</a>
<a name="ln813">            // Passes 0,1 to rgb[0], rgb[1] of hori/vert interp. Pass</a>
<a name="ln814">            // 3,5 to rgb[2], rgb[3] of best of interp hori/vert</a>
<a name="ln815">            // results. Each pass which outputs moves on to the next</a>
<a name="ln816">            // rgb[] for input of interp greens.</a>
<a name="ln817">            for(int i = 1, d = 0; d &lt; 6; d++, i ^= TS ^ 1, h ^= 2)</a>
<a name="ln818">            {</a>
<a name="ln819">              // look 1 and 2 pixels distance from solitary green to</a>
<a name="ln820">              // red then blue or blue then red</a>
<a name="ln821">              for(int c = 0; c &lt; 2; c++, h ^= 2)</a>
<a name="ln822">              {</a>
<a name="ln823">                // rate of change in greens between current pixel and</a>
<a name="ln824">                // interpolated pixels 1 or 2 distant: a quick</a>
<a name="ln825">                // derivative which will be divided by two later to be</a>
<a name="ln826">                // rate of luminance change for red/blue between known</a>
<a name="ln827">                // red/blue neighbors and the current unknown pixel</a>
<a name="ln828">                float g = 2 * rfx[0][1] - rfx[i &lt;&lt; c][1] - rfx[-(i &lt;&lt; c)][1];</a>
<a name="ln829">                // color is halved before being stored in rgb, hence</a>
<a name="ln830">                // this becomes green rate of change plus the average</a>
<a name="ln831">                // of the near red or blue pixels on current axis</a>
<a name="ln832">                color[h != 0][d] = g + rfx[i &lt;&lt; c][h] + rfx[-(i &lt;&lt; c)][h];</a>
<a name="ln833">                // Note that diff will become the slope for both red</a>
<a name="ln834">                // and blue differentials in the current direction.</a>
<a name="ln835">                // For 2nd and 3rd hori+vert passes, create a sum of</a>
<a name="ln836">                // steepness for both cardinal directions.</a>
<a name="ln837">                if(d &gt; 1)</a>
<a name="ln838">                  diff[d] += SQR(rfx[i &lt;&lt; c][1] - rfx[-(i &lt;&lt; c)][1] - rfx[i &lt;&lt; c][h] + rfx[-(i &lt;&lt; c)][h])</a>
<a name="ln839">                             + SQR(g);</a>
<a name="ln840">              }</a>
<a name="ln841">              if((d &lt; 2) || (d &amp; 1))</a>
<a name="ln842">              { // output for passes 0, 1, 3, 5</a>
<a name="ln843">                // for 0, 1 just use hori/vert, for 3, 5 use best of x/y dir</a>
<a name="ln844">                const int d_out = d - ((d &gt; 1) &amp;&amp; (diff[d-1] &lt; diff[d]));</a>
<a name="ln845">                rfx[0][0] = color[0][d_out] / 2.f;</a>
<a name="ln846">                rfx[0][2] = color[1][d_out] / 2.f;</a>
<a name="ln847">                rfx += TS * TS;</a>
<a name="ln848">              }</a>
<a name="ln849">            }</a>
<a name="ln850">          }</a>
<a name="ln851"> </a>
<a name="ln852">        /* Interpolate red for blue pixels and vice versa:              */</a>
<a name="ln853">        const int pad_rb_br = (passes == 1) ? 6 : 5;</a>
<a name="ln854">        for(int row = top + pad_rb_br; row &lt; mrow - pad_rb_br; row++)</a>
<a name="ln855">          for(int col = left + pad_rb_br; col &lt; mcol - pad_rb_br; col++)</a>
<a name="ln856">          {</a>
<a name="ln857">            int f = 2 - FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln858">            if(f == 1) continue;</a>
<a name="ln859">            float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln860">            int c = (row - sgrow) % 3 ? TS : 1;</a>
<a name="ln861">            int h = 3 * (c ^ TS ^ 1);</a>
<a name="ln862">            for(int d = 0; d &lt; 4; d++, rfx += TS * TS)</a>
<a name="ln863">            {</a>
<a name="ln864">              int i = d &gt; 1 || ((d ^ c) &amp; 1) ||</a>
<a name="ln865">                ((fabsf(rfx[0][1]-rfx[c][1]) + fabsf(rfx[0][1]-rfx[-c][1])) &lt;</a>
<a name="ln866">                 2.f*(fabsf(rfx[0][1]-rfx[h][1]) + fabsf(rfx[0][1]-rfx[-h][1]))) ? c:h;</a>
<a name="ln867">              rfx[0][f] = (rfx[i][f] + rfx[-i][f] + 2.f * rfx[0][1] - rfx[i][1] - rfx[-i][1]) / 2.f;</a>
<a name="ln868">            }</a>
<a name="ln869">          }</a>
<a name="ln870"> </a>
<a name="ln871">        /* Fill in red and blue for 2x2 blocks of green:                */</a>
<a name="ln872">        const int pad_g22 = (passes == 1) ? 8 : 4;</a>
<a name="ln873">        for(int row = top + pad_g22; row &lt; mrow - pad_g22; row++)</a>
<a name="ln874">          if((row - sgrow) % 3)</a>
<a name="ln875">            for(int col = left + pad_g22; col &lt; mcol - pad_g22; col++)</a>
<a name="ln876">              if((col - sgcol) % 3)</a>
<a name="ln877">              {</a>
<a name="ln878">                float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln879">                const short *const hex = hexmap(row,col,allhex);</a>
<a name="ln880">                for(int d = 0; d &lt; ndir; d += 2, rfx += TS * TS)</a>
<a name="ln881">                  if(hex[d] + hex[d + 1])</a>
<a name="ln882">                  {</a>
<a name="ln883">                    float g = 3.f * rfx[0][1] - 2.f * rfx[hex[d]][1] - rfx[hex[d + 1]][1];</a>
<a name="ln884">                    for(int c = 0; c &lt; 4; c += 2)</a>
<a name="ln885">                      rfx[0][c] = (g + 2.f * rfx[hex[d]][c] + rfx[hex[d + 1]][c]) / 3.f;</a>
<a name="ln886">                  }</a>
<a name="ln887">                  else</a>
<a name="ln888">                  {</a>
<a name="ln889">                    float g = 2.f * rfx[0][1] - rfx[hex[d]][1] - rfx[hex[d + 1]][1];</a>
<a name="ln890">                    for(int c = 0; c &lt; 4; c += 2)</a>
<a name="ln891">                      rfx[0][c] = (g + rfx[hex[d]][c] + rfx[hex[d + 1]][c]) / 2.f;</a>
<a name="ln892">                  }</a>
<a name="ln893">              }</a>
<a name="ln894">      } // end of multipass loop</a>
<a name="ln895"> </a>
<a name="ln896">      // jump back to the first set of rgb buffers (this is a nop</a>
<a name="ln897">      // unless on the second pass)</a>
<a name="ln898">      rgb = (float(*)[TS][TS][3])buffer;</a>
<a name="ln899">      // from here on out, mainly are working within the current tile</a>
<a name="ln900">      // rather than in reference to the image, so don't offset</a>
<a name="ln901">      // mrow/mcol by top/left of tile</a>
<a name="ln902">      mrow -= top;</a>
<a name="ln903">      mcol -= left;</a>
<a name="ln904"> </a>
<a name="ln905">      /* Convert to perceptual colorspace and differentiate in all directions:  */</a>
<a name="ln906">      // Original dcraw algorithm uses CIELab as perceptual space</a>
<a name="ln907">      // (presumably coming from original AHD) and converts taking</a>
<a name="ln908">      // camera matrix into account. Now use YPbPr which requires much</a>
<a name="ln909">      // less code and is nearly indistinguishable. It assumes the</a>
<a name="ln910">      // camera RGB is roughly linear.</a>
<a name="ln911">      for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln912">      {</a>
<a name="ln913">        const int pad_yuv = (passes == 1) ? 8 : 13;</a>
<a name="ln914">        for(int row = pad_yuv; row &lt; mrow - pad_yuv; row++)</a>
<a name="ln915">          for(int col = pad_yuv; col &lt; mcol - pad_yuv; col++)</a>
<a name="ln916">          {</a>
<a name="ln917">            float *rx = rgb[d][row][col];</a>
<a name="ln918">            // use ITU-R BT.2020 YPbPr, which is great, but could use</a>
<a name="ln919">            // a better/simpler choice? note that imageop.h provides</a>
<a name="ln920">            // dt_iop_RGB_to_YCbCr which uses Rec. 601 conversion,</a>
<a name="ln921">            // which appears less good with specular highlights</a>
<a name="ln922">            float y = 0.2627f * rx[0] + 0.6780f * rx[1] + 0.0593f * rx[2];</a>
<a name="ln923">            yuv[0][row][col] = y;</a>
<a name="ln924">            yuv[1][row][col] = (rx[2] - y) * 0.56433f;</a>
<a name="ln925">            yuv[2][row][col] = (rx[0] - y) * 0.67815f;</a>
<a name="ln926">          }</a>
<a name="ln927">        // Note that f can offset by a column (-1 or +1) and by a row</a>
<a name="ln928">        // (-TS or TS). The row-wise offsets cause the undefined</a>
<a name="ln929">        // behavior sanitizer to warn of an out of bounds index, but</a>
<a name="ln930">        // as yfx is multi-dimensional and there is sufficient</a>
<a name="ln931">        // padding, that is not actually so.</a>
<a name="ln932">        const int f = dir[d &amp; 3];</a>
<a name="ln933">        const int pad_drv = (passes == 1) ? 9 : 14;</a>
<a name="ln934">        for(int row = pad_drv; row &lt; mrow - pad_drv; row++)</a>
<a name="ln935">          for(int col = pad_drv; col &lt; mcol - pad_drv; col++)</a>
<a name="ln936">          {</a>
<a name="ln937">            float(*yfx)[TS][TS] = (float(*)[TS][TS]) &amp; yuv[0][row][col];</a>
<a name="ln938">            drv[d][row][col] = SQR(2 * yfx[0][0][0] - yfx[0][0][f] - yfx[0][0][-f])</a>
<a name="ln939">                               + SQR(2 * yfx[1][0][0] - yfx[1][0][f] - yfx[1][0][-f])</a>
<a name="ln940">                               + SQR(2 * yfx[2][0][0] - yfx[2][0][f] - yfx[2][0][-f]);</a>
<a name="ln941">          }</a>
<a name="ln942">      }</a>
<a name="ln943"> </a>
<a name="ln944">      /* Build homogeneity maps from the derivatives:                   */</a>
<a name="ln945">      memset(homo, 0, (size_t)ndir * TS * TS * sizeof(uint8_t));</a>
<a name="ln946">      const int pad_homo = (passes == 1) ? 10 : 15;</a>
<a name="ln947">      for(int row = pad_homo; row &lt; mrow - pad_homo; row++)</a>
<a name="ln948">        for(int col = pad_homo; col &lt; mcol - pad_homo; col++)</a>
<a name="ln949">        {</a>
<a name="ln950">          float tr = FLT_MAX;</a>
<a name="ln951">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln952">            if(tr &gt; drv[d][row][col]) tr = drv[d][row][col];</a>
<a name="ln953">          tr *= 8;</a>
<a name="ln954">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln955">            for(int v = -1; v &lt;= 1; v++)</a>
<a name="ln956">              for(int h = -1; h &lt;= 1; h++) homo[d][row][col] += ((drv[d][row + v][col + h] &lt;= tr) ? 1 : 0);</a>
<a name="ln957">        }</a>
<a name="ln958"> </a>
<a name="ln959">      /* Build 5x5 sum of homogeneity maps for each pixel &amp; direction */</a>
<a name="ln960">      for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln961">        for(int row = pad_tile; row &lt; mrow - pad_tile; row++)</a>
<a name="ln962">        {</a>
<a name="ln963">          // start before first column where homo[d][row][col+2] != 0,</a>
<a name="ln964">          // so can know v5sum and homosum[d][row][col] will be 0</a>
<a name="ln965">          int col = pad_tile-5;</a>
<a name="ln966">          uint8_t v5sum[5] = { 0 };</a>
<a name="ln967">          homosum[d][row][col] = 0;</a>
<a name="ln968">          // calculate by rolling through column sums</a>
<a name="ln969">          for(col++; col &lt; mcol - pad_tile; col++)</a>
<a name="ln970">          {</a>
<a name="ln971">            uint8_t colsum = 0;</a>
<a name="ln972">            for(int v = -2; v &lt;= 2; v++) colsum += homo[d][row + v][col + 2];</a>
<a name="ln973">            homosum[d][row][col] = homosum[d][row][col - 1] - v5sum[col % 5] + colsum;</a>
<a name="ln974">            v5sum[col % 5] = colsum;</a>
<a name="ln975">          }</a>
<a name="ln976">        }</a>
<a name="ln977"> </a>
<a name="ln978">      /* Average the most homogenous pixels for the final result:       */</a>
<a name="ln979">      for(int row = pad_tile; row &lt; mrow - pad_tile; row++)</a>
<a name="ln980">        for(int col = pad_tile; col &lt; mcol - pad_tile; col++)</a>
<a name="ln981">        {</a>
<a name="ln982">          uint8_t hm[8] = { 0 };</a>
<a name="ln983">          uint8_t maxval = 0;</a>
<a name="ln984">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln985">          {</a>
<a name="ln986">            hm[d] = homosum[d][row][col];</a>
<a name="ln987">            maxval = (maxval &lt; hm[d] ? hm[d] : maxval);</a>
<a name="ln988">          }</a>
<a name="ln989">          maxval -= maxval &gt;&gt; 3;</a>
<a name="ln990">          for(int d = 0; d &lt; ndir - 4; d++)</a>
<a name="ln991">            if(hm[d] &lt; hm[d + 4])</a>
<a name="ln992">              hm[d] = 0;</a>
<a name="ln993">            else if(hm[d] &gt; hm[d + 4])</a>
<a name="ln994">              hm[d + 4] = 0;</a>
<a name="ln995">          float avg[4] = { 0.0f };</a>
<a name="ln996">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln997">            if(hm[d] &gt;= maxval)</a>
<a name="ln998">            {</a>
<a name="ln999">              for(int c = 0; c &lt; 3; c++) avg[c] += rgb[d][row][col][c];</a>
<a name="ln1000">              avg[3]++;</a>
<a name="ln1001">            }</a>
<a name="ln1002">          for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1003">            out[4 * (width * (row + top) + col + left) + c] =</a>
<a name="ln1004">              avg[c]/avg[3];</a>
<a name="ln1005">        }</a>
<a name="ln1006">    }</a>
<a name="ln1007">  }</a>
<a name="ln1008">  dt_free_align(all_buffers);</a>
<a name="ln1009">}</a>
<a name="ln1010"> </a>
<a name="ln1011">#undef TS</a>
<a name="ln1012"> </a>
<a name="ln1013">#define TS 122</a>
<a name="ln1014">static void xtrans_fdc_interpolate(struct dt_iop_module_t *self, float *out, const float *const in,</a>
<a name="ln1015">                                   const dt_iop_roi_t *const roi_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln1016">                                   const uint8_t (*const xtrans)[6])</a>
<a name="ln1017">{</a>
<a name="ln1018"> </a>
<a name="ln1019">  static const short orth[12] = { 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1 },</a>
<a name="ln1020">                     patt[2][16] = { { 0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0 },</a>
<a name="ln1021">                                     { 0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1 } },</a>
<a name="ln1022">                     dir[4] = { 1, TS, TS + 1, TS - 1 };</a>
<a name="ln1023"> </a>
<a name="ln1024">  static const float directionality[8] = { 1.0f, 0.0f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f };</a>
<a name="ln1025"> </a>
<a name="ln1026">  short allhex[3][3][8];</a>
<a name="ln1027">  // sgrow/sgcol is the offset in the sensor matrix of the solitary</a>
<a name="ln1028">  // green pixels (initialized here only to avoid compiler warning)</a>
<a name="ln1029">  unsigned short sgrow = 0, sgcol = 0;</a>
<a name="ln1030"> </a>
<a name="ln1031">  const int width = roi_out-&gt;width;</a>
<a name="ln1032">  const int height = roi_out-&gt;height;</a>
<a name="ln1033">  static const int ndir = 4;</a>
<a name="ln1034"> </a>
<a name="ln1035">  static const float complex Minv[3][8] = {</a>
<a name="ln1036">    { 1.000000e+00f, 2.500000e-01f - 4.330127e-01f * _Complex_I, -2.500000e-01f - 4.330127e-01f * _Complex_I,</a>
<a name="ln1037">      -1.000000e+00f, 7.500000e-01f - 1.299038e+00f * _Complex_I, -2.500000e-01f + 4.330127e-01f * _Complex_I,</a>
<a name="ln1038">      7.500000e-01f + 1.299038e+00f * _Complex_I, 2.500000e-01f + 4.330127e-01f * _Complex_I },</a>
<a name="ln1039">    { 1.000000e+00f, -2.000000e-01f + 3.464102e-01f * _Complex_I, 2.000000e-01f + 3.464102e-01f * _Complex_I,</a>
<a name="ln1040">      8.000000e-01f, 0.0f, 2.000000e-01f - 3.464102e-01f * _Complex_I, 0.0f,</a>
<a name="ln1041">      -2.000000e-01f - 3.464102e-01f * _Complex_I },</a>
<a name="ln1042">    { 1.000000e+00f, 2.500000e-01f - 4.330127e-01f * _Complex_I, -2.500000e-01f - 4.330127e-01f * _Complex_I,</a>
<a name="ln1043">      -1.000000e+00f, -7.500000e-01f + 1.299038e+00f * _Complex_I, -2.500000e-01f + 4.330127e-01f * _Complex_I,</a>
<a name="ln1044">      -7.500000e-01f - 1.299038e+00f * _Complex_I, 2.500000e-01f + 4.330127e-01f * _Complex_I },</a>
<a name="ln1045">  };</a>
<a name="ln1046"> </a>
<a name="ln1047">  static const float complex modarr[6][6][8] = {</a>
<a name="ln1048">    { { 1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1049">        1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1050">        1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1051">        1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1052">      { -1.000000e+00f - 1.224647e-16f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1053">        -1.000000e+00f - 1.224647e-16f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1054">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1055">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1056">      { 1.000000e+00f + 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1057">        1.000000e+00f + 2.449294e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1058">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1059">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1060">      { -1.000000e+00f - 3.673940e-16f * _Complex_I, -1.000000e+00f + 1.224647e-16f * _Complex_I,</a>
<a name="ln1061">        -1.000000e+00f - 3.673940e-16f * _Complex_I, -1.000000e+00f - 1.224647e-16f * _Complex_I,</a>
<a name="ln1062">        1.000000e+00f - 2.449294e-16f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1063">        1.000000e+00f - 2.449294e-16f * _Complex_I, 1.000000e+00f + 2.449294e-16f * _Complex_I },</a>
<a name="ln1064">      { 1.000000e+00f + 4.898587e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1065">        1.000000e+00f + 4.898587e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1066">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1067">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1068">      { -1.000000e+00f - 6.123234e-16f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1069">        -1.000000e+00f - 6.123234e-16f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1070">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1071">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I } },</a>
<a name="ln1072">    { { 5.000000e-01f + 8.660254e-01f * _Complex_I, -1.000000e+00f + 1.224647e-16f * _Complex_I,</a>
<a name="ln1073">        5.000000e-01f - 8.660254e-01f * _Complex_I, -1.000000e+00f + 1.224647e-16f * _Complex_I,</a>
<a name="ln1074">        1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1075">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1076">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1077">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1078">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1079">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1080">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1081">        5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1082">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1083">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1084">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1085">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1086">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1087">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1088">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1089">        5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1090">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1091">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 2.449294e-16f * _Complex_I },</a>
<a name="ln1092">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1093">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1094">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1095">        1.000000e+00f - 2.266216e-15f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I } },</a>
<a name="ln1096">    { { -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1097">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1098">        1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1099">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1100">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1101">        5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1102">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1103">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1104">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1105">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1106">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1107">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1108">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, -1.000000e+00f + 3.673940e-16f * _Complex_I,</a>
<a name="ln1109">        5.000000e-01f + 8.660254e-01f * _Complex_I, -1.000000e+00f + 1.224647e-16f * _Complex_I,</a>
<a name="ln1110">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1111">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1112">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1113">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1114">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1115">        1.000000e+00f - 4.898587e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1116">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1117">        5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1118">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1119">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 1.133108e-15f * _Complex_I } },</a>
<a name="ln1120">    { { -1.000000e+00f + 1.224647e-16f * _Complex_I, -1.000000e+00f + 3.673940e-16f * _Complex_I,</a>
<a name="ln1121">        -1.000000e+00f - 1.224647e-16f * _Complex_I, -1.000000e+00f + 3.673940e-16f * _Complex_I,</a>
<a name="ln1122">        1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1123">        1.000000e+00f - 2.449294e-16f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I },</a>
<a name="ln1124">      { 1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1125">        1.000000e+00f + 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1126">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1127">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1128">      { -1.000000e+00f - 1.224647e-16f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1129">        -1.000000e+00f - 3.673940e-16f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1130">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1131">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1132">      { 1.000000e+00f + 2.449294e-16f * _Complex_I, 1.000000e+00f - 4.898587e-16f * _Complex_I,</a>
<a name="ln1133">        1.000000e+00f + 4.898587e-16f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1134">        1.000000e+00f - 2.449294e-16f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1135">        1.000000e+00f - 4.898587e-16f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1136">      { -1.000000e+00f - 3.673940e-16f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1137">        -1.000000e+00f - 6.123234e-16f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1138">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1139">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1140">      { 1.000000e+00f + 4.898587e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1141">        1.000000e+00f + 7.347881e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1142">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1143">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I } },</a>
<a name="ln1144">    { { -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 4.898587e-16f * _Complex_I,</a>
<a name="ln1145">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 4.898587e-16f * _Complex_I,</a>
<a name="ln1146">        1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1147">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1148">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1149">        5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1150">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1151">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I },</a>
<a name="ln1152">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1153">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1154">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1155">        1.000000e+00f - 4.898587e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1156">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, -1.000000e+00f + 6.123234e-16f * _Complex_I,</a>
<a name="ln1157">        5.000000e-01f - 8.660254e-01f * _Complex_I, -1.000000e+00f + 3.673940e-16f * _Complex_I,</a>
<a name="ln1158">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1159">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1160">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1161">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1162">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1163">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1164">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1165">        5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1166">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1167">        1.000000e+00f - 7.347881e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I } },</a>
<a name="ln1168">    { { 5.000000e-01f - 8.660254e-01f * _Complex_I, -1.000000e+00f + 6.123234e-16f * _Complex_I,</a>
<a name="ln1169">        5.000000e-01f + 8.660254e-01f * _Complex_I, -1.000000e+00f + 6.123234e-16f * _Complex_I,</a>
<a name="ln1170">        1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1171">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1172">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1173">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1174">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1175">        1.000000e+00f - 2.266216e-15f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1176">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1177">        5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1178">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1179">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 1.133108e-15f * _Complex_I },</a>
<a name="ln1180">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 7.347881e-16f * _Complex_I,</a>
<a name="ln1181">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 4.898587e-16f * _Complex_I,</a>
<a name="ln1182">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1183">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1184">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1185">        5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1186">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1187">        1.000000e+00f - 7.347881e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1188">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1189">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1190">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1191">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I } },</a>
<a name="ln1192">  };</a>
<a name="ln1193"> </a>
<a name="ln1194">  static const float complex harr[4][13][13]</a>
<a name="ln1195">      = { { { 1.326343e-03f - 1.299441e-18f * _Complex_I, 7.091837e-04f - 1.228342e-03f * _Complex_I,</a>
<a name="ln1196">              -6.278557e-04f - 1.087478e-03f * _Complex_I, -1.157216e-03f + 9.920263e-19f * _Complex_I,</a>
<a name="ln1197">              -4.887166e-04f + 8.464820e-04f * _Complex_I, 5.758687e-04f + 9.974338e-04f * _Complex_I,</a>
<a name="ln1198">              1.225183e-03f - 9.002496e-19f * _Complex_I, 5.758687e-04f - 9.974338e-04f * _Complex_I,</a>
<a name="ln1199">              -4.887166e-04f - 8.464820e-04f * _Complex_I, -1.157216e-03f + 7.085902e-19f * _Complex_I,</a>
<a name="ln1200">              -6.278557e-04f + 1.087478e-03f * _Complex_I, 7.091837e-04f + 1.228342e-03f * _Complex_I,</a>
<a name="ln1201">              1.326343e-03f - 6.497206e-19f * _Complex_I },</a>
<a name="ln1202">            { -1.980815e-03f + 1.698059e-18f * _Complex_I, -1.070384e-03f + 1.853959e-03f * _Complex_I,</a>
<a name="ln1203">              7.924697e-04f + 1.372598e-03f * _Complex_I, 1.876584e-03f - 1.378892e-18f * _Complex_I,</a>
<a name="ln1204">              1.225866e-03f - 2.123262e-03f * _Complex_I, -1.569320e-03f - 2.718142e-03f * _Complex_I,</a>
<a name="ln1205">              -3.273971e-03f + 2.004729e-18f * _Complex_I, -1.569320e-03f + 2.718142e-03f * _Complex_I,</a>
<a name="ln1206">              1.225866e-03f + 2.123262e-03f * _Complex_I, 1.876584e-03f - 9.192611e-19f * _Complex_I,</a>
<a name="ln1207">              7.924697e-04f - 1.372598e-03f * _Complex_I, -1.070384e-03f - 1.853959e-03f * _Complex_I,</a>
<a name="ln1208">              -1.980815e-03f + 7.277398e-19f * _Complex_I },</a>
<a name="ln1209">            { 1.457023e-03f - 1.070603e-18f * _Complex_I, 8.487143e-04f - 1.470016e-03f * _Complex_I,</a>
<a name="ln1210">              -6.873776e-04f - 1.190573e-03f * _Complex_I, -2.668335e-03f + 1.633884e-18f * _Complex_I,</a>
<a name="ln1211">              -2.459813e-03f + 4.260521e-03f * _Complex_I, 3.238772e-03f + 5.609717e-03f * _Complex_I,</a>
<a name="ln1212">              7.074895e-03f - 3.465699e-18f * _Complex_I, 3.238772e-03f - 5.609717e-03f * _Complex_I,</a>
<a name="ln1213">              -2.459813e-03f - 4.260521e-03f * _Complex_I, -2.668335e-03f + 9.803302e-19f * _Complex_I,</a>
<a name="ln1214">              -6.873776e-04f + 1.190573e-03f * _Complex_I, 8.487143e-04f + 1.470016e-03f * _Complex_I,</a>
<a name="ln1215">              1.457023e-03f - 3.568678e-19f * _Complex_I },</a>
<a name="ln1216">            { -1.017660e-03f + 6.231370e-19f * _Complex_I, -5.415171e-04f + 9.379351e-04f * _Complex_I,</a>
<a name="ln1217">              7.255109e-04f + 1.256622e-03f * _Complex_I, 3.699792e-03f - 1.812375e-18f * _Complex_I,</a>
<a name="ln1218">              4.090356e-03f - 7.084704e-03f * _Complex_I, -6.006283e-03f - 1.040319e-02f * _Complex_I,</a>
<a name="ln1219">              -1.391431e-02f + 5.112034e-18f * _Complex_I, -6.006283e-03f + 1.040319e-02f * _Complex_I,</a>
<a name="ln1220">              4.090356e-03f + 7.084704e-03f * _Complex_I, 3.699792e-03f - 9.061876e-19f * _Complex_I,</a>
<a name="ln1221">              7.255109e-04f - 1.256622e-03f * _Complex_I, -5.415171e-04f - 9.379351e-04f * _Complex_I,</a>
<a name="ln1222">              -1.017660e-03f + 1.246274e-19f * _Complex_I },</a>
<a name="ln1223">            { 9.198983e-04f - 4.506202e-19f * _Complex_I, 6.815900e-04f - 1.180548e-03f * _Complex_I,</a>
<a name="ln1224">              -1.287335e-03f - 2.229729e-03f * _Complex_I, -5.023856e-03f + 1.845735e-18f * _Complex_I,</a>
<a name="ln1225">              -5.499048e-03f + 9.524630e-03f * _Complex_I, 9.797672e-03f + 1.697006e-02f * _Complex_I,</a>
<a name="ln1226">              2.504795e-02f - 6.134977e-18f * _Complex_I, 9.797672e-03f - 1.697006e-02f * _Complex_I,</a>
<a name="ln1227">              -5.499048e-03f - 9.524630e-03f * _Complex_I, -5.023856e-03f + 6.152449e-19f * _Complex_I,</a>
<a name="ln1228">              -1.287335e-03f + 2.229729e-03f * _Complex_I, 6.815900e-04f + 1.180548e-03f * _Complex_I,</a>
<a name="ln1229">              9.198983e-04f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1230">            { -7.972663e-04f + 2.929109e-19f * _Complex_I, -1.145605e-03f + 1.984247e-03f * _Complex_I,</a>
<a name="ln1231">              1.983334e-03f + 3.435235e-03f * _Complex_I, 6.730096e-03f - 1.648398e-18f * _Complex_I,</a>
<a name="ln1232">              6.782033e-03f - 1.174683e-02f * _Complex_I, -1.392077e-02f - 2.411147e-02f * _Complex_I,</a>
<a name="ln1233">              -3.906939e-02f + 4.784620e-18f * _Complex_I, -1.392077e-02f + 2.411147e-02f * _Complex_I,</a>
<a name="ln1234">              6.782033e-03f + 1.174683e-02f * _Complex_I, 6.730096e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1235">              1.983334e-03f - 3.435235e-03f * _Complex_I, -1.145605e-03f - 1.984247e-03f * _Complex_I,</a>
<a name="ln1236">              -7.972663e-04f - 9.763696e-20f * _Complex_I },</a>
<a name="ln1237">            { 8.625458e-04f - 2.112628e-19f * _Complex_I, 1.431113e-03f - 2.478760e-03f * _Complex_I,</a>
<a name="ln1238">              -2.310309e-03f - 4.001572e-03f * _Complex_I, -7.706486e-03f + 9.437723e-19f * _Complex_I,</a>
<a name="ln1239">              -7.220186e-03f + 1.250573e-02f * _Complex_I, 1.587118e-02f + 2.748969e-02f * _Complex_I,</a>
<a name="ln1240">              4.765675e-02f + 0.000000e+00f * _Complex_I, 1.587118e-02f - 2.748969e-02f * _Complex_I,</a>
<a name="ln1241">              -7.220186e-03f - 1.250573e-02f * _Complex_I, -7.706486e-03f - 9.437723e-19f * _Complex_I,</a>
<a name="ln1242">              -2.310309e-03f + 4.001572e-03f * _Complex_I, 1.431113e-03f + 2.478760e-03f * _Complex_I,</a>
<a name="ln1243">              8.625458e-04f + 2.112628e-19f * _Complex_I },</a>
<a name="ln1244">            { -7.972663e-04f + 9.763696e-20f * _Complex_I, -1.145605e-03f + 1.984247e-03f * _Complex_I,</a>
<a name="ln1245">              1.983334e-03f + 3.435235e-03f * _Complex_I, 6.730096e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1246">              6.782033e-03f - 1.174683e-02f * _Complex_I, -1.392077e-02f - 2.411147e-02f * _Complex_I,</a>
<a name="ln1247">              -3.906939e-02f - 4.784620e-18f * _Complex_I, -1.392077e-02f + 2.411147e-02f * _Complex_I,</a>
<a name="ln1248">              6.782033e-03f + 1.174683e-02f * _Complex_I, 6.730096e-03f + 1.648398e-18f * _Complex_I,</a>
<a name="ln1249">              1.983334e-03f - 3.435235e-03f * _Complex_I, -1.145605e-03f - 1.984247e-03f * _Complex_I,</a>
<a name="ln1250">              -7.972663e-04f - 2.929109e-19f * _Complex_I },</a>
<a name="ln1251">            { 9.198983e-04f + 0.000000e+00f * _Complex_I, 6.815900e-04f - 1.180548e-03f * _Complex_I,</a>
<a name="ln1252">              -1.287335e-03f - 2.229729e-03f * _Complex_I, -5.023856e-03f - 6.152449e-19f * _Complex_I,</a>
<a name="ln1253">              -5.499048e-03f + 9.524630e-03f * _Complex_I, 9.797672e-03f + 1.697006e-02f * _Complex_I,</a>
<a name="ln1254">              2.504795e-02f + 6.134977e-18f * _Complex_I, 9.797672e-03f - 1.697006e-02f * _Complex_I,</a>
<a name="ln1255">              -5.499048e-03f - 9.524630e-03f * _Complex_I, -5.023856e-03f - 1.845735e-18f * _Complex_I,</a>
<a name="ln1256">              -1.287335e-03f + 2.229729e-03f * _Complex_I, 6.815900e-04f + 1.180548e-03f * _Complex_I,</a>
<a name="ln1257">              9.198983e-04f + 4.506202e-19f * _Complex_I },</a>
<a name="ln1258">            { -1.017660e-03f - 1.246274e-19f * _Complex_I, -5.415171e-04f + 9.379351e-04f * _Complex_I,</a>
<a name="ln1259">              7.255109e-04f + 1.256622e-03f * _Complex_I, 3.699792e-03f + 9.061876e-19f * _Complex_I,</a>
<a name="ln1260">              4.090356e-03f - 7.084704e-03f * _Complex_I, -6.006283e-03f - 1.040319e-02f * _Complex_I,</a>
<a name="ln1261">              -1.391431e-02f - 5.112034e-18f * _Complex_I, -6.006283e-03f + 1.040319e-02f * _Complex_I,</a>
<a name="ln1262">              4.090356e-03f + 7.084704e-03f * _Complex_I, 3.699792e-03f + 1.812375e-18f * _Complex_I,</a>
<a name="ln1263">              7.255109e-04f - 1.256622e-03f * _Complex_I, -5.415171e-04f - 9.379351e-04f * _Complex_I,</a>
<a name="ln1264">              -1.017660e-03f - 6.231370e-19f * _Complex_I },</a>
<a name="ln1265">            { 1.457023e-03f + 3.568678e-19f * _Complex_I, 8.487143e-04f - 1.470016e-03f * _Complex_I,</a>
<a name="ln1266">              -6.873776e-04f - 1.190573e-03f * _Complex_I, -2.668335e-03f - 9.803302e-19f * _Complex_I,</a>
<a name="ln1267">              -2.459813e-03f + 4.260521e-03f * _Complex_I, 3.238772e-03f + 5.609717e-03f * _Complex_I,</a>
<a name="ln1268">              7.074895e-03f + 3.465699e-18f * _Complex_I, 3.238772e-03f - 5.609717e-03f * _Complex_I,</a>
<a name="ln1269">              -2.459813e-03f - 4.260521e-03f * _Complex_I, -2.668335e-03f - 1.633884e-18f * _Complex_I,</a>
<a name="ln1270">              -6.873776e-04f + 1.190573e-03f * _Complex_I, 8.487143e-04f + 1.470016e-03f * _Complex_I,</a>
<a name="ln1271">              1.457023e-03f + 1.070603e-18f * _Complex_I },</a>
<a name="ln1272">            { -1.980815e-03f - 7.277398e-19f * _Complex_I, -1.070384e-03f + 1.853959e-03f * _Complex_I,</a>
<a name="ln1273">              7.924697e-04f + 1.372598e-03f * _Complex_I, 1.876584e-03f + 9.192611e-19f * _Complex_I,</a>
<a name="ln1274">              1.225866e-03f - 2.123262e-03f * _Complex_I, -1.569320e-03f - 2.718142e-03f * _Complex_I,</a>
<a name="ln1275">              -3.273971e-03f - 2.004729e-18f * _Complex_I, -1.569320e-03f + 2.718142e-03f * _Complex_I,</a>
<a name="ln1276">              1.225866e-03f + 2.123262e-03f * _Complex_I, 1.876584e-03f + 1.378892e-18f * _Complex_I,</a>
<a name="ln1277">              7.924697e-04f - 1.372598e-03f * _Complex_I, -1.070384e-03f - 1.853959e-03f * _Complex_I,</a>
<a name="ln1278">              -1.980815e-03f - 1.698059e-18f * _Complex_I },</a>
<a name="ln1279">            { 1.326343e-03f + 6.497206e-19f * _Complex_I, 7.091837e-04f - 1.228342e-03f * _Complex_I,</a>
<a name="ln1280">              -6.278557e-04f - 1.087478e-03f * _Complex_I, -1.157216e-03f - 7.085902e-19f * _Complex_I,</a>
<a name="ln1281">              -4.887166e-04f + 8.464820e-04f * _Complex_I, 5.758687e-04f + 9.974338e-04f * _Complex_I,</a>
<a name="ln1282">              1.225183e-03f + 9.002496e-19f * _Complex_I, 5.758687e-04f - 9.974338e-04f * _Complex_I,</a>
<a name="ln1283">              -4.887166e-04f - 8.464820e-04f * _Complex_I, -1.157216e-03f - 9.920263e-19f * _Complex_I,</a>
<a name="ln1284">              -6.278557e-04f + 1.087478e-03f * _Complex_I, 7.091837e-04f + 1.228342e-03f * _Complex_I,</a>
<a name="ln1285">              1.326343e-03f + 1.299441e-18f * _Complex_I } },</a>
<a name="ln1286">          { { 9.129120e-04f - 8.943958e-19f * _Complex_I, -5.925973e-04f - 1.026409e-03f * _Complex_I,</a>
<a name="ln1287">              -5.989682e-04f + 1.037443e-03f * _Complex_I, 1.158755e-03f - 8.514393e-19f * _Complex_I,</a>
<a name="ln1288">              -8.992493e-04f - 1.557545e-03f * _Complex_I, -1.283187e-03f + 2.222546e-03f * _Complex_I,</a>
<a name="ln1289">              2.730635e-03f - 1.337625e-18f * _Complex_I, -1.283187e-03f - 2.222546e-03f * _Complex_I,</a>
<a name="ln1290">              -8.992493e-04f + 1.557545e-03f * _Complex_I, 1.158755e-03f - 2.838131e-19f * _Complex_I,</a>
<a name="ln1291">              -5.989682e-04f - 1.037443e-03f * _Complex_I, -5.925973e-04f + 1.026409e-03f * _Complex_I,</a>
<a name="ln1292">              9.129120e-04f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1293">            { -5.588854e-04f - 9.680179e-04f * _Complex_I, -6.474856e-04f + 1.121478e-03f * _Complex_I,</a>
<a name="ln1294">              1.536588e-03f - 1.129066e-18f * _Complex_I, -9.123802e-04f - 1.580289e-03f * _Complex_I,</a>
<a name="ln1295">              -1.541434e-03f + 2.669842e-03f * _Complex_I, 4.379825e-03f - 9.925627e-18f * _Complex_I,</a>
<a name="ln1296">              -2.394173e-03f - 4.146830e-03f * _Complex_I, -2.189912e-03f + 3.793039e-03f * _Complex_I,</a>
<a name="ln1297">              3.082869e-03f - 3.493222e-18f * _Complex_I, -9.123802e-04f - 1.580289e-03f * _Complex_I,</a>
<a name="ln1298">              -7.682939e-04f + 1.330724e-03f * _Complex_I, 1.294971e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1299">              -5.588854e-04f - 9.680179e-04f * _Complex_I },</a>
<a name="ln1300">            { -5.883876e-04f + 1.019117e-03f * _Complex_I, 1.714796e-03f - 1.260012e-18f * _Complex_I,</a>
<a name="ln1301">              -1.180365e-03f - 2.044451e-03f * _Complex_I, -1.483082e-03f + 2.568774e-03f * _Complex_I,</a>
<a name="ln1302">              4.933362e-03f - 2.416651e-18f * _Complex_I, -3.296542e-03f - 5.709779e-03f * _Complex_I,</a>
<a name="ln1303">              -3.546477e-03f + 6.142678e-03f * _Complex_I, 6.593085e-03f - 1.614840e-18f * _Complex_I,</a>
<a name="ln1304">              -2.466681e-03f - 4.272417e-03f * _Complex_I, -1.483082e-03f + 2.568774e-03f * _Complex_I,</a>
<a name="ln1305">              2.360729e-03f + 0.000000e+00f * _Complex_I, -8.573982e-04f - 1.485057e-03f * _Complex_I,</a>
<a name="ln1306">              -5.883876e-04f + 1.019117e-03f * _Complex_I },</a>
<a name="ln1307">            { 1.483526e-03f - 1.090077e-18f * _Complex_I, -1.074793e-03f - 1.861596e-03f * _Complex_I,</a>
<a name="ln1308">              -1.447448e-03f + 2.507053e-03f * _Complex_I, 3.952416e-03f - 1.936126e-18f * _Complex_I,</a>
<a name="ln1309">              -3.496688e-03f - 6.056441e-03f * _Complex_I, -4.898024e-03f + 8.483627e-03f * _Complex_I,</a>
<a name="ln1310">              1.070518e-02f - 2.622012e-18f * _Complex_I, -4.898024e-03f - 8.483627e-03f * _Complex_I,</a>
<a name="ln1311">              -3.496688e-03f + 6.056441e-03f * _Complex_I, 3.952416e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1312">              -1.447448e-03f - 2.507053e-03f * _Complex_I, -1.074793e-03f + 1.861596e-03f * _Complex_I,</a>
<a name="ln1313">              1.483526e-03f + 3.633590e-19f * _Complex_I },</a>
<a name="ln1314">            { -9.966429e-04f - 1.726236e-03f * _Complex_I, -1.478281e-03f + 2.560458e-03f * _Complex_I,</a>
<a name="ln1315">              4.306274e-03f - 2.109466e-18f * _Complex_I, -3.294955e-03f - 5.707029e-03f * _Complex_I,</a>
<a name="ln1316">              -5.436890e-03f + 9.416970e-03f * _Complex_I, 1.556418e-02f - 3.812124e-18f * _Complex_I,</a>
<a name="ln1317">              -8.842875e-03f - 1.531631e-02f * _Complex_I, -7.782088e-03f + 1.347897e-02f * _Complex_I,</a>
<a name="ln1318">              1.087378e-02f + 0.000000e+00f * _Complex_I, -3.294955e-03f - 5.707029e-03f * _Complex_I,</a>
<a name="ln1319">              -2.153137e-03f + 3.729342e-03f * _Complex_I, 2.956562e-03f + 3.350104e-18f * _Complex_I,</a>
<a name="ln1320">              -9.966429e-04f - 1.726236e-03f * _Complex_I },</a>
<a name="ln1321">            { -1.291288e-03f + 2.236576e-03f * _Complex_I, 3.942788e-03f - 8.935208e-18f * _Complex_I,</a>
<a name="ln1322">              -2.798347e-03f - 4.846880e-03f * _Complex_I, -4.448869e-03f + 7.705666e-03f * _Complex_I,</a>
<a name="ln1323">              1.522441e-02f - 3.728906e-18f * _Complex_I, -1.175443e-02f - 2.035927e-02f * _Complex_I,</a>
<a name="ln1324">              -1.417872e-02f + 2.455826e-02f * _Complex_I, 2.350886e-02f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1325">              -7.612206e-03f - 1.318473e-02f * _Complex_I, -4.448869e-03f + 7.705666e-03f * _Complex_I,</a>
<a name="ln1326">              5.596695e-03f + 1.370795e-18f * _Complex_I, -1.971394e-03f - 3.414555e-03f * _Complex_I,</a>
<a name="ln1327">              -1.291288e-03f + 2.236576e-03f * _Complex_I },</a>
<a name="ln1328">            { 2.779286e-03f - 1.361458e-18f * _Complex_I, -2.194126e-03f - 3.800338e-03f * _Complex_I,</a>
<a name="ln1329">              -3.057720e-03f + 5.296126e-03f * _Complex_I, 9.725261e-03f - 2.382002e-18f * _Complex_I,</a>
<a name="ln1330">              -8.649261e-03f - 1.498096e-02f * _Complex_I, -1.417667e-02f + 2.455472e-02f * _Complex_I,</a>
<a name="ln1331">              3.552610e-02f + 0.000000e+00f * _Complex_I, -1.417667e-02f - 2.455472e-02f * _Complex_I,</a>
<a name="ln1332">              -8.649261e-03f + 1.498096e-02f * _Complex_I, 9.725261e-03f + 2.382002e-18f * _Complex_I,</a>
<a name="ln1333">              -3.057720e-03f - 5.296126e-03f * _Complex_I, -2.194126e-03f + 3.800338e-03f * _Complex_I,</a>
<a name="ln1334">              2.779286e-03f + 1.361458e-18f * _Complex_I },</a>
<a name="ln1335">            { -1.291288e-03f - 2.236576e-03f * _Complex_I, -1.971394e-03f + 3.414555e-03f * _Complex_I,</a>
<a name="ln1336">              5.596695e-03f - 1.370795e-18f * _Complex_I, -4.448869e-03f - 7.705666e-03f * _Complex_I,</a>
<a name="ln1337">              -7.612206e-03f + 1.318473e-02f * _Complex_I, 2.350886e-02f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1338">              -1.417872e-02f - 2.455826e-02f * _Complex_I, -1.175443e-02f + 2.035927e-02f * _Complex_I,</a>
<a name="ln1339">              1.522441e-02f + 3.728906e-18f * _Complex_I, -4.448869e-03f - 7.705666e-03f * _Complex_I,</a>
<a name="ln1340">              -2.798347e-03f + 4.846880e-03f * _Complex_I, 3.942788e-03f + 8.935208e-18f * _Complex_I,</a>
<a name="ln1341">              -1.291288e-03f - 2.236576e-03f * _Complex_I },</a>
<a name="ln1342">            { -9.966429e-04f + 1.726236e-03f * _Complex_I, 2.956562e-03f - 3.350104e-18f * _Complex_I,</a>
<a name="ln1343">              -2.153137e-03f - 3.729342e-03f * _Complex_I, -3.294955e-03f + 5.707029e-03f * _Complex_I,</a>
<a name="ln1344">              1.087378e-02f + 0.000000e+00f * _Complex_I, -7.782088e-03f - 1.347897e-02f * _Complex_I,</a>
<a name="ln1345">              -8.842875e-03f + 1.531631e-02f * _Complex_I, 1.556418e-02f + 3.812124e-18f * _Complex_I,</a>
<a name="ln1346">              -5.436890e-03f - 9.416970e-03f * _Complex_I, -3.294955e-03f + 5.707029e-03f * _Complex_I,</a>
<a name="ln1347">              4.306274e-03f + 2.109466e-18f * _Complex_I, -1.478281e-03f - 2.560458e-03f * _Complex_I,</a>
<a name="ln1348">              -9.966429e-04f + 1.726236e-03f * _Complex_I },</a>
<a name="ln1349">            { 1.483526e-03f - 3.633590e-19f * _Complex_I, -1.074793e-03f - 1.861596e-03f * _Complex_I,</a>
<a name="ln1350">              -1.447448e-03f + 2.507053e-03f * _Complex_I, 3.952416e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1351">              -3.496688e-03f - 6.056441e-03f * _Complex_I, -4.898024e-03f + 8.483627e-03f * _Complex_I,</a>
<a name="ln1352">              1.070518e-02f + 2.622012e-18f * _Complex_I, -4.898024e-03f - 8.483627e-03f * _Complex_I,</a>
<a name="ln1353">              -3.496688e-03f + 6.056441e-03f * _Complex_I, 3.952416e-03f + 1.936126e-18f * _Complex_I,</a>
<a name="ln1354">              -1.447448e-03f - 2.507053e-03f * _Complex_I, -1.074793e-03f + 1.861596e-03f * _Complex_I,</a>
<a name="ln1355">              1.483526e-03f + 1.090077e-18f * _Complex_I },</a>
<a name="ln1356">            { -5.883876e-04f - 1.019117e-03f * _Complex_I, -8.573982e-04f + 1.485057e-03f * _Complex_I,</a>
<a name="ln1357">              2.360729e-03f + 0.000000e+00f * _Complex_I, -1.483082e-03f - 2.568774e-03f * _Complex_I,</a>
<a name="ln1358">              -2.466681e-03f + 4.272417e-03f * _Complex_I, 6.593085e-03f + 1.614840e-18f * _Complex_I,</a>
<a name="ln1359">              -3.546477e-03f - 6.142678e-03f * _Complex_I, -3.296542e-03f + 5.709779e-03f * _Complex_I,</a>
<a name="ln1360">              4.933362e-03f + 2.416651e-18f * _Complex_I, -1.483082e-03f - 2.568774e-03f * _Complex_I,</a>
<a name="ln1361">              -1.180365e-03f + 2.044451e-03f * _Complex_I, 1.714796e-03f + 1.260012e-18f * _Complex_I,</a>
<a name="ln1362">              -5.883876e-04f - 1.019117e-03f * _Complex_I },</a>
<a name="ln1363">            { -5.588854e-04f + 9.680179e-04f * _Complex_I, 1.294971e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1364">              -7.682939e-04f - 1.330724e-03f * _Complex_I, -9.123802e-04f + 1.580289e-03f * _Complex_I,</a>
<a name="ln1365">              3.082869e-03f + 3.493222e-18f * _Complex_I, -2.189912e-03f - 3.793039e-03f * _Complex_I,</a>
<a name="ln1366">              -2.394173e-03f + 4.146830e-03f * _Complex_I, 4.379825e-03f + 9.925627e-18f * _Complex_I,</a>
<a name="ln1367">              -1.541434e-03f - 2.669842e-03f * _Complex_I, -9.123802e-04f + 1.580289e-03f * _Complex_I,</a>
<a name="ln1368">              1.536588e-03f + 1.129066e-18f * _Complex_I, -6.474856e-04f - 1.121478e-03f * _Complex_I,</a>
<a name="ln1369">              -5.588854e-04f + 9.680179e-04f * _Complex_I },</a>
<a name="ln1370">            { 9.129120e-04f + 0.000000e+00f * _Complex_I, -5.925973e-04f - 1.026409e-03f * _Complex_I,</a>
<a name="ln1371">              -5.989682e-04f + 1.037443e-03f * _Complex_I, 1.158755e-03f + 2.838131e-19f * _Complex_I,</a>
<a name="ln1372">              -8.992493e-04f - 1.557545e-03f * _Complex_I, -1.283187e-03f + 2.222546e-03f * _Complex_I,</a>
<a name="ln1373">              2.730635e-03f + 1.337625e-18f * _Complex_I, -1.283187e-03f - 2.222546e-03f * _Complex_I,</a>
<a name="ln1374">              -8.992493e-04f + 1.557545e-03f * _Complex_I, 1.158755e-03f + 8.514393e-19f * _Complex_I,</a>
<a name="ln1375">              -5.989682e-04f - 1.037443e-03f * _Complex_I, -5.925973e-04f + 1.026409e-03f * _Complex_I,</a>
<a name="ln1376">              9.129120e-04f + 8.943958e-19f * _Complex_I } },</a>
<a name="ln1377">          { { 8.228091e-04f + 0.000000e+00f * _Complex_I, -5.365069e-04f + 9.292572e-04f * _Complex_I,</a>
<a name="ln1378">              -6.011501e-04f - 1.041223e-03f * _Complex_I, 1.249890e-03f - 3.061346e-19f * _Complex_I,</a>
<a name="ln1379">              -7.632708e-04f + 1.322024e-03f * _Complex_I, -9.846035e-04f - 1.705383e-03f * _Complex_I,</a>
<a name="ln1380">              2.080486e-03f - 1.019144e-18f * _Complex_I, -9.846035e-04f + 1.705383e-03f * _Complex_I,</a>
<a name="ln1381">              -7.632708e-04f - 1.322024e-03f * _Complex_I, 1.249890e-03f - 9.184039e-19f * _Complex_I,</a>
<a name="ln1382">              -6.011501e-04f + 1.041223e-03f * _Complex_I, -5.365069e-04f - 9.292572e-04f * _Complex_I,</a>
<a name="ln1383">              8.228091e-04f - 8.061204e-19f * _Complex_I },</a>
<a name="ln1384">            { -5.616336e-04f - 9.727779e-04f * _Complex_I, 1.382894e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1385">              -8.694311e-04f + 1.505899e-03f * _Complex_I, -9.721139e-04f - 1.683751e-03f * _Complex_I,</a>
<a name="ln1386">              2.446785e-03f - 2.772471e-18f * _Complex_I, -1.605471e-03f + 2.780758e-03f * _Complex_I,</a>
<a name="ln1387">              -1.832781e-03f - 3.174469e-03f * _Complex_I, 3.210942e-03f - 7.276687e-18f * _Complex_I,</a>
<a name="ln1388">              -1.223392e-03f + 2.118978e-03f * _Complex_I, -9.721139e-04f - 1.683751e-03f * _Complex_I,</a>
<a name="ln1389">              1.738862e-03f - 1.277695e-18f * _Complex_I, -6.914471e-04f + 1.197621e-03f * _Complex_I,</a>
<a name="ln1390">              -5.616336e-04f - 9.727779e-04f * _Complex_I },</a>
<a name="ln1391">            { -5.723872e-04f + 9.914038e-04f * _Complex_I, -8.302721e-04f - 1.438073e-03f * _Complex_I,</a>
<a name="ln1392">              2.445280e-03f + 0.000000e+00f * _Complex_I, -1.378399e-03f + 2.387458e-03f * _Complex_I,</a>
<a name="ln1393">              -1.882898e-03f - 3.261274e-03f * _Complex_I, 4.921549e-03f - 1.205432e-18f * _Complex_I,</a>
<a name="ln1394">              -2.760152e-03f + 4.780723e-03f * _Complex_I, -2.460774e-03f - 4.262186e-03f * _Complex_I,</a>
<a name="ln1395">              3.765795e-03f - 1.844708e-18f * _Complex_I, -1.378399e-03f + 2.387458e-03f * _Complex_I,</a>
<a name="ln1396">              -1.222640e-03f - 2.117675e-03f * _Complex_I, 1.660544e-03f - 1.220148e-18f * _Complex_I,</a>
<a name="ln1397">              -5.723872e-04f + 9.914038e-04f * _Complex_I },</a>
<a name="ln1398">            { 1.226482e-03f + 3.004015e-19f * _Complex_I, -9.600816e-04f + 1.662910e-03f * _Complex_I,</a>
<a name="ln1399">              -1.495900e-03f - 2.590974e-03f * _Complex_I, 3.833507e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1400">              -3.167257e-03f + 5.485850e-03f * _Complex_I, -4.303595e-03f - 7.454046e-03f * _Complex_I,</a>
<a name="ln1401">              9.412791e-03f - 2.305469e-18f * _Complex_I, -4.303595e-03f + 7.454046e-03f * _Complex_I,</a>
<a name="ln1402">              -3.167257e-03f - 5.485850e-03f * _Complex_I, 3.833507e-03f - 1.877877e-18f * _Complex_I,</a>
<a name="ln1403">              -1.495900e-03f + 2.590974e-03f * _Complex_I, -9.600816e-04f - 1.662910e-03f * _Complex_I,</a>
<a name="ln1404">              1.226482e-03f - 9.012046e-19f * _Complex_I },</a>
<a name="ln1405">            { -9.898007e-04f - 1.714385e-03f * _Complex_I, 3.215120e-03f + 3.643077e-18f * _Complex_I,</a>
<a name="ln1406">              -2.507621e-03f + 4.343327e-03f * _Complex_I, -3.557798e-03f - 6.162286e-03f * _Complex_I,</a>
<a name="ln1407">              1.105198e-02f + 0.000000e+00f * _Complex_I, -7.691179e-03f + 1.332151e-02f * _Complex_I,</a>
<a name="ln1408">              -8.705793e-03f - 1.507888e-02f * _Complex_I, 1.538236e-02f - 3.767591e-18f * _Complex_I,</a>
<a name="ln1409">              -5.525988e-03f + 9.571292e-03f * _Complex_I, -3.557798e-03f - 6.162286e-03f * _Complex_I,</a>
<a name="ln1410">              5.015242e-03f - 2.456760e-18f * _Complex_I, -1.607560e-03f + 2.784375e-03f * _Complex_I,</a>
<a name="ln1411">              -9.898007e-04f - 1.714385e-03f * _Complex_I },</a>
<a name="ln1412">            { -1.414655e-03f + 2.450254e-03f * _Complex_I, -2.341263e-03f - 4.055186e-03f * _Complex_I,</a>
<a name="ln1413">              6.915775e-03f + 1.693876e-18f * _Complex_I, -5.086403e-03f + 8.809908e-03f * _Complex_I,</a>
<a name="ln1414">              -8.062191e-03f - 1.396412e-02f * _Complex_I, 2.415333e-02f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1415">              -1.451128e-02f + 2.513428e-02f * _Complex_I, -1.207667e-02f - 2.091740e-02f * _Complex_I,</a>
<a name="ln1416">              1.612438e-02f - 3.949335e-18f * _Complex_I, -5.086403e-03f + 8.809908e-03f * _Complex_I,</a>
<a name="ln1417">              -3.457887e-03f - 5.989237e-03f * _Complex_I, 4.682526e-03f - 1.061161e-17f * _Complex_I,</a>
<a name="ln1418">              -1.414655e-03f + 2.450254e-03f * _Complex_I },</a>
<a name="ln1419">            { 3.039574e-03f + 1.488962e-18f * _Complex_I, -2.598226e-03f + 4.500260e-03f * _Complex_I,</a>
<a name="ln1420">              -3.750909e-03f - 6.496765e-03f * _Complex_I, 1.119776e-02f + 2.742661e-18f * _Complex_I,</a>
<a name="ln1421">              -9.210579e-03f + 1.595319e-02f * _Complex_I, -1.464762e-02f - 2.537042e-02f * _Complex_I,</a>
<a name="ln1422">              3.672076e-02f + 0.000000e+00f * _Complex_I, -1.464762e-02f + 2.537042e-02f * _Complex_I,</a>
<a name="ln1423">              -9.210579e-03f - 1.595319e-02f * _Complex_I, 1.119776e-02f - 2.742661e-18f * _Complex_I,</a>
<a name="ln1424">              -3.750909e-03f + 6.496765e-03f * _Complex_I, -2.598226e-03f - 4.500260e-03f * _Complex_I,</a>
<a name="ln1425">              3.039574e-03f - 1.488962e-18f * _Complex_I },</a>
<a name="ln1426">            { -1.414655e-03f - 2.450254e-03f * _Complex_I, 4.682526e-03f + 1.061161e-17f * _Complex_I,</a>
<a name="ln1427">              -3.457887e-03f + 5.989237e-03f * _Complex_I, -5.086403e-03f - 8.809908e-03f * _Complex_I,</a>
<a name="ln1428">              1.612438e-02f + 3.949335e-18f * _Complex_I, -1.207667e-02f + 2.091740e-02f * _Complex_I,</a>
<a name="ln1429">              -1.451128e-02f - 2.513428e-02f * _Complex_I, 2.415333e-02f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1430">              -8.062191e-03f + 1.396412e-02f * _Complex_I, -5.086403e-03f - 8.809908e-03f * _Complex_I,</a>
<a name="ln1431">              6.915775e-03f - 1.693876e-18f * _Complex_I, -2.341263e-03f + 4.055186e-03f * _Complex_I,</a>
<a name="ln1432">              -1.414655e-03f - 2.450254e-03f * _Complex_I },</a>
<a name="ln1433">            { -9.898007e-04f + 1.714385e-03f * _Complex_I, -1.607560e-03f - 2.784375e-03f * _Complex_I,</a>
<a name="ln1434">              5.015242e-03f + 2.456760e-18f * _Complex_I, -3.557798e-03f + 6.162286e-03f * _Complex_I,</a>
<a name="ln1435">              -5.525988e-03f - 9.571292e-03f * _Complex_I, 1.538236e-02f + 3.767591e-18f * _Complex_I,</a>
<a name="ln1436">              -8.705793e-03f + 1.507888e-02f * _Complex_I, -7.691179e-03f - 1.332151e-02f * _Complex_I,</a>
<a name="ln1437">              1.105198e-02f + 0.000000e+00f * _Complex_I, -3.557798e-03f + 6.162286e-03f * _Complex_I,</a>
<a name="ln1438">              -2.507621e-03f - 4.343327e-03f * _Complex_I, 3.215120e-03f - 3.643077e-18f * _Complex_I,</a>
<a name="ln1439">              -9.898007e-04f + 1.714385e-03f * _Complex_I },</a>
<a name="ln1440">            { 1.226482e-03f + 9.012046e-19f * _Complex_I, -9.600816e-04f + 1.662910e-03f * _Complex_I,</a>
<a name="ln1441">              -1.495900e-03f - 2.590974e-03f * _Complex_I, 3.833507e-03f + 1.877877e-18f * _Complex_I,</a>
<a name="ln1442">              -3.167257e-03f + 5.485850e-03f * _Complex_I, -4.303595e-03f - 7.454046e-03f * _Complex_I,</a>
<a name="ln1443">              9.412791e-03f + 2.305469e-18f * _Complex_I, -4.303595e-03f + 7.454046e-03f * _Complex_I,</a>
<a name="ln1444">              -3.167257e-03f - 5.485850e-03f * _Complex_I, 3.833507e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1445">              -1.495900e-03f + 2.590974e-03f * _Complex_I, -9.600816e-04f - 1.662910e-03f * _Complex_I,</a>
<a name="ln1446">              1.226482e-03f - 3.004015e-19f * _Complex_I },</a>
<a name="ln1447">            { -5.723872e-04f - 9.914038e-04f * _Complex_I, 1.660544e-03f + 1.220148e-18f * _Complex_I,</a>
<a name="ln1448">              -1.222640e-03f + 2.117675e-03f * _Complex_I, -1.378399e-03f - 2.387458e-03f * _Complex_I,</a>
<a name="ln1449">              3.765795e-03f + 1.844708e-18f * _Complex_I, -2.460774e-03f + 4.262186e-03f * _Complex_I,</a>
<a name="ln1450">              -2.760152e-03f - 4.780723e-03f * _Complex_I, 4.921549e-03f + 1.205432e-18f * _Complex_I,</a>
<a name="ln1451">              -1.882898e-03f + 3.261274e-03f * _Complex_I, -1.378399e-03f - 2.387458e-03f * _Complex_I,</a>
<a name="ln1452">              2.445280e-03f + 0.000000e+00f * _Complex_I, -8.302721e-04f + 1.438073e-03f * _Complex_I,</a>
<a name="ln1453">              -5.723872e-04f - 9.914038e-04f * _Complex_I },</a>
<a name="ln1454">            { -5.616336e-04f + 9.727779e-04f * _Complex_I, -6.914471e-04f - 1.197621e-03f * _Complex_I,</a>
<a name="ln1455">              1.738862e-03f + 1.277695e-18f * _Complex_I, -9.721139e-04f + 1.683751e-03f * _Complex_I,</a>
<a name="ln1456">              -1.223392e-03f - 2.118978e-03f * _Complex_I, 3.210942e-03f + 7.276687e-18f * _Complex_I,</a>
<a name="ln1457">              -1.832781e-03f + 3.174469e-03f * _Complex_I, -1.605471e-03f - 2.780758e-03f * _Complex_I,</a>
<a name="ln1458">              2.446785e-03f + 2.772471e-18f * _Complex_I, -9.721139e-04f + 1.683751e-03f * _Complex_I,</a>
<a name="ln1459">              -8.694311e-04f - 1.505899e-03f * _Complex_I, 1.382894e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1460">              -5.616336e-04f + 9.727779e-04f * _Complex_I },</a>
<a name="ln1461">            { 8.228091e-04f + 8.061204e-19f * _Complex_I, -5.365069e-04f + 9.292572e-04f * _Complex_I,</a>
<a name="ln1462">              -6.011501e-04f - 1.041223e-03f * _Complex_I, 1.249890e-03f + 9.184039e-19f * _Complex_I,</a>
<a name="ln1463">              -7.632708e-04f + 1.322024e-03f * _Complex_I, -9.846035e-04f - 1.705383e-03f * _Complex_I,</a>
<a name="ln1464">              2.080486e-03f + 1.019144e-18f * _Complex_I, -9.846035e-04f + 1.705383e-03f * _Complex_I,</a>
<a name="ln1465">              -7.632708e-04f - 1.322024e-03f * _Complex_I, 1.249890e-03f + 3.061346e-19f * _Complex_I,</a>
<a name="ln1466">              -6.011501e-04f + 1.041223e-03f * _Complex_I, -5.365069e-04f - 9.292572e-04f * _Complex_I,</a>
<a name="ln1467">              8.228091e-04f + 0.000000e+00f * _Complex_I } },</a>
<a name="ln1468">          { { 1.221201e-03f + 5.982162e-19f * _Complex_I, -1.773498e-03f - 6.515727e-19f * _Complex_I,</a>
<a name="ln1469">              1.246697e-03f + 3.053526e-19f * _Complex_I, -8.215306e-04f - 1.006085e-19f * _Complex_I,</a>
<a name="ln1470">              7.609372e-04f + 0.000000e+00f * _Complex_I, -4.863927e-04f + 5.956592e-20f * _Complex_I,</a>
<a name="ln1471">              4.882100e-04f - 1.195770e-19f * _Complex_I, -4.863927e-04f + 1.786978e-19f * _Complex_I,</a>
<a name="ln1472">              7.609372e-04f - 3.727517e-19f * _Complex_I, -8.215306e-04f + 5.030424e-19f * _Complex_I,</a>
<a name="ln1473">              1.246697e-03f - 9.160579e-19f * _Complex_I, -1.773498e-03f + 1.520336e-18f * _Complex_I,</a>
<a name="ln1474">              1.221201e-03f - 1.196432e-18f * _Complex_I },</a>
<a name="ln1475">            { 7.406884e-04f - 1.282910e-03f * _Complex_I, -1.025411e-03f + 1.776065e-03f * _Complex_I,</a>
<a name="ln1476">              7.186273e-04f - 1.244699e-03f * _Complex_I, -4.025606e-04f + 6.972554e-04f * _Complex_I,</a>
<a name="ln1477">              5.908383e-04f - 1.023362e-03f * _Complex_I, -1.125190e-03f + 1.948886e-03f * _Complex_I,</a>
<a name="ln1478">              1.432695e-03f - 2.481501e-03f * _Complex_I, -1.125190e-03f + 1.948886e-03f * _Complex_I,</a>
<a name="ln1479">              5.908383e-04f - 1.023362e-03f * _Complex_I, -4.025606e-04f + 6.972554e-04f * _Complex_I,</a>
<a name="ln1480">              7.186273e-04f - 1.244699e-03f * _Complex_I, -1.025411e-03f + 1.776065e-03f * _Complex_I,</a>
<a name="ln1481">              7.406884e-04f - 1.282910e-03f * _Complex_I },</a>
<a name="ln1482">            { -7.162255e-04f - 1.240539e-03f * _Complex_I, 8.961176e-04f + 1.552121e-03f * _Complex_I,</a>
<a name="ln1483">              -6.705589e-04f - 1.161442e-03f * _Complex_I, 6.187140e-04f + 1.071644e-03f * _Complex_I,</a>
<a name="ln1484">              -1.165433e-03f - 2.018589e-03f * _Complex_I, 1.948120e-03f + 3.374242e-03f * _Complex_I,</a>
<a name="ln1485">              -2.297663e-03f - 3.979669e-03f * _Complex_I, 1.948120e-03f + 3.374242e-03f * _Complex_I,</a>
<a name="ln1486">              -1.165433e-03f - 2.018589e-03f * _Complex_I, 6.187140e-04f + 1.071644e-03f * _Complex_I,</a>
<a name="ln1487">              -6.705589e-04f - 1.161442e-03f * _Complex_I, 8.961176e-04f + 1.552121e-03f * _Complex_I,</a>
<a name="ln1488">              -7.162255e-04f - 1.240539e-03f * _Complex_I },</a>
<a name="ln1489">            { -1.280260e-03f - 7.839331e-19f * _Complex_I, 1.987108e-03f + 9.734024e-19f * _Complex_I,</a>
<a name="ln1490">              -2.614019e-03f - 9.603749e-19f * _Complex_I, 3.635167e-03f + 8.903590e-19f * _Complex_I,</a>
<a name="ln1491">              -4.954867e-03f - 6.067962e-19f * _Complex_I, 6.653220e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1492">              -7.600546e-03f + 9.307984e-19f * _Complex_I, 6.653220e-03f - 1.629569e-18f * _Complex_I,</a>
<a name="ln1493">              -4.954867e-03f + 1.820389e-18f * _Complex_I, 3.635167e-03f - 1.780718e-18f * _Complex_I,</a>
<a name="ln1494">              -2.614019e-03f + 1.600625e-18f * _Complex_I, 1.987108e-03f - 1.460104e-18f * _Complex_I,</a>
<a name="ln1495">              -1.280260e-03f + 1.097506e-18f * _Complex_I },</a>
<a name="ln1496">            { -5.756945e-04f + 9.971322e-04f * _Complex_I, 1.268614e-03f - 2.197304e-03f * _Complex_I,</a>
<a name="ln1497">              -2.421407e-03f + 4.194000e-03f * _Complex_I, 4.045715e-03f - 7.007384e-03f * _Complex_I,</a>
<a name="ln1498">              -5.527367e-03f + 9.573681e-03f * _Complex_I, 6.837207e-03f - 1.184239e-02f * _Complex_I,</a>
<a name="ln1499">              -7.288212e-03f + 1.262355e-02f * _Complex_I, 6.837207e-03f - 1.184239e-02f * _Complex_I,</a>
<a name="ln1500">              -5.527367e-03f + 9.573681e-03f * _Complex_I, 4.045715e-03f - 7.007384e-03f * _Complex_I,</a>
<a name="ln1501">              -2.421407e-03f + 4.194000e-03f * _Complex_I, 1.268614e-03f - 2.197304e-03f * _Complex_I,</a>
<a name="ln1502">              -5.756945e-04f + 9.971322e-04f * _Complex_I },</a>
<a name="ln1503">            { 7.349896e-04f + 1.273039e-03f * _Complex_I, -1.748057e-03f - 3.027723e-03f * _Complex_I,</a>
<a name="ln1504">              3.332671e-03f + 5.772355e-03f * _Complex_I, -6.051736e-03f - 1.048191e-02f * _Complex_I,</a>
<a name="ln1505">              9.842376e-03f + 1.704749e-02f * _Complex_I, -1.401169e-02f - 2.426897e-02f * _Complex_I,</a>
<a name="ln1506">              1.598601e-02f + 2.768858e-02f * _Complex_I, -1.401169e-02f - 2.426897e-02f * _Complex_I,</a>
<a name="ln1507">              9.842376e-03f + 1.704749e-02f * _Complex_I, -6.051736e-03f - 1.048191e-02f * _Complex_I,</a>
<a name="ln1508">              3.332671e-03f + 5.772355e-03f * _Complex_I, -1.748057e-03f - 3.027723e-03f * _Complex_I,</a>
<a name="ln1509">              7.349896e-04f + 1.273039e-03f * _Complex_I },</a>
<a name="ln1510">            { 1.400383e-03f + 1.028985e-18f * _Complex_I, -3.545886e-03f - 2.171229e-18f * _Complex_I,</a>
<a name="ln1511">              7.289370e-03f + 3.570761e-18f * _Complex_I, -1.418908e-02f - 5.212982e-18f * _Complex_I,</a>
<a name="ln1512">              2.520839e-02f + 6.174275e-18f * _Complex_I, -3.934772e-02f - 4.818706e-18f * _Complex_I,</a>
<a name="ln1513">              4.797481e-02f + 0.000000e+00f * _Complex_I, -3.934772e-02f + 4.818706e-18f * _Complex_I,</a>
<a name="ln1514">              2.520839e-02f - 6.174275e-18f * _Complex_I, -1.418908e-02f + 5.212982e-18f * _Complex_I,</a>
<a name="ln1515">              7.289370e-03f - 3.570761e-18f * _Complex_I, -3.545886e-03f + 2.171229e-18f * _Complex_I,</a>
<a name="ln1516">              1.400383e-03f - 1.028985e-18f * _Complex_I },</a>
<a name="ln1517">            { 7.349896e-04f - 1.273039e-03f * _Complex_I, -1.748057e-03f + 3.027723e-03f * _Complex_I,</a>
<a name="ln1518">              3.332671e-03f - 5.772355e-03f * _Complex_I, -6.051736e-03f + 1.048191e-02f * _Complex_I,</a>
<a name="ln1519">              9.842376e-03f - 1.704749e-02f * _Complex_I, -1.401169e-02f + 2.426897e-02f * _Complex_I,</a>
<a name="ln1520">              1.598601e-02f - 2.768858e-02f * _Complex_I, -1.401169e-02f + 2.426897e-02f * _Complex_I,</a>
<a name="ln1521">              9.842376e-03f - 1.704749e-02f * _Complex_I, -6.051736e-03f + 1.048191e-02f * _Complex_I,</a>
<a name="ln1522">              3.332671e-03f - 5.772355e-03f * _Complex_I, -1.748057e-03f + 3.027723e-03f * _Complex_I,</a>
<a name="ln1523">              7.349896e-04f - 1.273039e-03f * _Complex_I },</a>
<a name="ln1524">            { -5.756945e-04f - 9.971322e-04f * _Complex_I, 1.268614e-03f + 2.197304e-03f * _Complex_I,</a>
<a name="ln1525">              -2.421407e-03f - 4.194000e-03f * _Complex_I, 4.045715e-03f + 7.007384e-03f * _Complex_I,</a>
<a name="ln1526">              -5.527367e-03f - 9.573681e-03f * _Complex_I, 6.837207e-03f + 1.184239e-02f * _Complex_I,</a>
<a name="ln1527">              -7.288212e-03f - 1.262355e-02f * _Complex_I, 6.837207e-03f + 1.184239e-02f * _Complex_I,</a>
<a name="ln1528">              -5.527367e-03f - 9.573681e-03f * _Complex_I, 4.045715e-03f + 7.007384e-03f * _Complex_I,</a>
<a name="ln1529">              -2.421407e-03f - 4.194000e-03f * _Complex_I, 1.268614e-03f + 2.197304e-03f * _Complex_I,</a>
<a name="ln1530">              -5.756945e-04f - 9.971322e-04f * _Complex_I },</a>
<a name="ln1531">            { -1.280260e-03f - 1.097506e-18f * _Complex_I, 1.987108e-03f + 1.460104e-18f * _Complex_I,</a>
<a name="ln1532">              -2.614019e-03f - 1.600625e-18f * _Complex_I, 3.635167e-03f + 1.780718e-18f * _Complex_I,</a>
<a name="ln1533">              -4.954867e-03f - 1.820389e-18f * _Complex_I, 6.653220e-03f + 1.629569e-18f * _Complex_I,</a>
<a name="ln1534">              -7.600546e-03f - 9.307984e-19f * _Complex_I, 6.653220e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1535">              -4.954867e-03f + 6.067962e-19f * _Complex_I, 3.635167e-03f - 8.903590e-19f * _Complex_I,</a>
<a name="ln1536">              -2.614019e-03f + 9.603749e-19f * _Complex_I, 1.987108e-03f - 9.734024e-19f * _Complex_I,</a>
<a name="ln1537">              -1.280260e-03f + 7.839331e-19f * _Complex_I },</a>
<a name="ln1538">            { -7.162255e-04f + 1.240539e-03f * _Complex_I, 8.961176e-04f - 1.552121e-03f * _Complex_I,</a>
<a name="ln1539">              -6.705589e-04f + 1.161442e-03f * _Complex_I, 6.187140e-04f - 1.071644e-03f * _Complex_I,</a>
<a name="ln1540">              -1.165433e-03f + 2.018589e-03f * _Complex_I, 1.948120e-03f - 3.374242e-03f * _Complex_I,</a>
<a name="ln1541">              -2.297663e-03f + 3.979669e-03f * _Complex_I, 1.948120e-03f - 3.374242e-03f * _Complex_I,</a>
<a name="ln1542">              -1.165433e-03f + 2.018589e-03f * _Complex_I, 6.187140e-04f - 1.071644e-03f * _Complex_I,</a>
<a name="ln1543">              -6.705589e-04f + 1.161442e-03f * _Complex_I, 8.961176e-04f - 1.552121e-03f * _Complex_I,</a>
<a name="ln1544">              -7.162255e-04f + 1.240539e-03f * _Complex_I },</a>
<a name="ln1545">            { 7.406884e-04f + 1.282910e-03f * _Complex_I, -1.025411e-03f - 1.776065e-03f * _Complex_I,</a>
<a name="ln1546">              7.186273e-04f + 1.244699e-03f * _Complex_I, -4.025606e-04f - 6.972554e-04f * _Complex_I,</a>
<a name="ln1547">              5.908383e-04f + 1.023362e-03f * _Complex_I, -1.125190e-03f - 1.948886e-03f * _Complex_I,</a>
<a name="ln1548">              1.432695e-03f + 2.481501e-03f * _Complex_I, -1.125190e-03f - 1.948886e-03f * _Complex_I,</a>
<a name="ln1549">              5.908383e-04f + 1.023362e-03f * _Complex_I, -4.025606e-04f - 6.972554e-04f * _Complex_I,</a>
<a name="ln1550">              7.186273e-04f + 1.244699e-03f * _Complex_I, -1.025411e-03f - 1.776065e-03f * _Complex_I,</a>
<a name="ln1551">              7.406884e-04f + 1.282910e-03f * _Complex_I },</a>
<a name="ln1552">            { 1.221201e-03f + 1.196432e-18f * _Complex_I, -1.773498e-03f - 1.520336e-18f * _Complex_I,</a>
<a name="ln1553">              1.246697e-03f + 9.160579e-19f * _Complex_I, -8.215306e-04f - 5.030424e-19f * _Complex_I,</a>
<a name="ln1554">              7.609372e-04f + 3.727517e-19f * _Complex_I, -4.863927e-04f - 1.786978e-19f * _Complex_I,</a>
<a name="ln1555">              4.882100e-04f + 1.195770e-19f * _Complex_I, -4.863927e-04f - 5.956592e-20f * _Complex_I,</a>
<a name="ln1556">              7.609372e-04f + 0.000000e+00f * _Complex_I, -8.215306e-04f + 1.006085e-19f * _Complex_I,</a>
<a name="ln1557">              1.246697e-03f - 3.053526e-19f * _Complex_I, -1.773498e-03f + 6.515727e-19f * _Complex_I,</a>
<a name="ln1558">              1.221201e-03f - 5.982162e-19f * _Complex_I } } };</a>
<a name="ln1559"> </a>
<a name="ln1560">  const size_t buffer_size = (size_t)TS * TS * (ndir * 4 + 7) * sizeof(float);</a>
<a name="ln1561">  char *const all_buffers = (char *)dt_alloc_align(64, dt_get_num_threads() * buffer_size);</a>
<a name="ln1562">  if(!all_buffers)</a>
<a name="ln1563">  {</a>
<a name="ln1564">    fprintf(stderr, &quot;[demosaic] not able to allocate FDC base buffers\n&quot;);</a>
<a name="ln1565">    return;</a>
<a name="ln1566">  }</a>
<a name="ln1567"> </a>
<a name="ln1568">  /* Map a green hexagon around each non-green pixel and vice versa:    */</a>
<a name="ln1569">  for(int row = 0; row &lt; 3; row++)</a>
<a name="ln1570">    for(int col = 0; col &lt; 3; col++)</a>
<a name="ln1571">      for(int ng = 0, d = 0; d &lt; 10; d += 2)</a>
<a name="ln1572">      {</a>
<a name="ln1573">        int g = FCxtrans(row, col, NULL, xtrans) == 1;</a>
<a name="ln1574">        if(FCxtrans(row + orth[d], col + orth[d + 2], NULL, xtrans) == 1)</a>
<a name="ln1575">          ng = 0;</a>
<a name="ln1576">        else</a>
<a name="ln1577">          ng++;</a>
<a name="ln1578">        // if there are four non-green pixels adjacent in cardinal</a>
<a name="ln1579">        // directions, this is the solitary green pixel</a>
<a name="ln1580">        if(ng == 4)</a>
<a name="ln1581">        {</a>
<a name="ln1582">          sgrow = row;</a>
<a name="ln1583">          sgcol = col;</a>
<a name="ln1584">        }</a>
<a name="ln1585">        if(ng == g + 1)</a>
<a name="ln1586">          for(int c = 0; c &lt; 8; c++)</a>
<a name="ln1587">          {</a>
<a name="ln1588">            int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];</a>
<a name="ln1589">            int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];</a>
<a name="ln1590">            // offset within TSxTS buffer</a>
<a name="ln1591">            allhex[row][col][c ^ (g * 2 &amp; d)] = h + v * TS;</a>
<a name="ln1592">          }</a>
<a name="ln1593">      }</a>
<a name="ln1594"> </a>
<a name="ln1595">  // extra passes propagates out errors at edges, hence need more padding</a>
<a name="ln1596">  const int pad_tile = 13;</a>
<a name="ln1597"> </a>
<a name="ln1598">  // calculate offsets for this roi</a>
<a name="ln1599">  int rowoffset = 0;</a>
<a name="ln1600">  int coloffset = 0;</a>
<a name="ln1601">  for(int row = 0; row &lt; 6; row++)</a>
<a name="ln1602">  {</a>
<a name="ln1603">    if(!((row - sgrow) % 3))</a>
<a name="ln1604">    {</a>
<a name="ln1605">      for(int col = 0; col &lt; 6; col++)</a>
<a name="ln1606">      {</a>
<a name="ln1607">        if(!((col - sgcol) % 3) &amp;&amp; (FCxtrans(row, col + 1, roi_in, xtrans) == 0))</a>
<a name="ln1608">        {</a>
<a name="ln1609">          rowoffset = 37 - row - pad_tile; // 1 plus a generous multiple of 6</a>
<a name="ln1610">          coloffset = 37 - col - pad_tile; // to avoid that this value gets negative</a>
<a name="ln1611">          break;</a>
<a name="ln1612">        }</a>
<a name="ln1613">      }</a>
<a name="ln1614">      break;</a>
<a name="ln1615">    }</a>
<a name="ln1616">  }</a>
<a name="ln1617"> </a>
<a name="ln1618">  // depending on the iso, use either a hybrid approach for chroma, or pure fdc</a>
<a name="ln1619">  float hybrid_fdc[2] = { 1.0f, 0.0f };</a>
<a name="ln1620">  const int xover_iso = dt_conf_get_int(&quot;plugins/darkroom/demosaic/fdc_xover_iso&quot;);</a>
<a name="ln1621">  int iso = self-&gt;dev-&gt;image_storage.exif_iso;</a>
<a name="ln1622">  if(iso &gt; xover_iso)</a>
<a name="ln1623">  {</a>
<a name="ln1624">    hybrid_fdc[0] = 0.0f;</a>
<a name="ln1625">    hybrid_fdc[1] = 1.0f;</a>
<a name="ln1626">  }</a>
<a name="ln1627"> </a>
<a name="ln1628">#ifdef _OPENMP</a>
<a name="ln1629">#pragma omp parallel for default(none) shared(sgrow, sgcol, allhex, out, rowoffset, coloffset, hybrid_fdc) schedule(dynamic)</a>
<a name="ln1630">#endif</a>
<a name="ln1631">  // step through TSxTS cells of image, each tile overlapping the</a>
<a name="ln1632">  // prior as interpolation needs a substantial border</a>
<a name="ln1633">  for(int top = -pad_tile; top &lt; height - pad_tile; top += TS - (pad_tile * 2))</a>
<a name="ln1634">  {</a>
<a name="ln1635">    char *const buffer = all_buffers + dt_get_thread_num() * buffer_size;</a>
<a name="ln1636">    // rgb points to ndir TSxTS tiles of 3 channels (R, G, and B)</a>
<a name="ln1637">    float(*rgb)[TS][TS][3] = (float(*)[TS][TS][3])buffer;</a>
<a name="ln1638">    // yuv points to 3 channel (Y, u, and v) TSxTS tiles</a>
<a name="ln1639">    // note that channels come before tiles to allow for a</a>
<a name="ln1640">    // vectorization optimization when building drv[] from yuv[]</a>
<a name="ln1641">    float (*const yuv)[TS][TS] = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln1642">    // drv points to ndir TSxTS tiles, each a single chanel of derivatives</a>
<a name="ln1643">    float (*const drv)[TS][TS] = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 3 + 3) * sizeof(float));</a>
<a name="ln1644">    // gmin and gmax reuse memory which is used later by yuv buffer;</a>
<a name="ln1645">    // each points to a TSxTS tile of single channel data</a>
<a name="ln1646">    float (*const gmin)[TS] = (float(*)[TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln1647">    float (*const gmax)[TS] = (float(*)[TS])(buffer + TS * TS * (ndir * 3 + 1) * sizeof(float));</a>
<a name="ln1648">    // homo and homosum reuse memory which is used earlier in the</a>
<a name="ln1649">    // loop; each points to ndir single-channel TSxTS tiles</a>
<a name="ln1650">    uint8_t (*const homo)[TS][TS] = (uint8_t(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln1651">    uint8_t (*const homosum)[TS][TS]</a>
<a name="ln1652">        = (uint8_t(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float) + TS * TS * ndir * sizeof(uint8_t));</a>
<a name="ln1653">    // append all fdc related buffers</a>
<a name="ln1654">    float complex *fdc_buf_start = (float complex *)(buffer + TS * TS * (ndir * 4 + 3) * sizeof(float));</a>
<a name="ln1655">    const int fdc_buf_size = TS * TS;</a>
<a name="ln1656">    float(*const i_src) = (float *)fdc_buf_start;</a>
<a name="ln1657">    float complex(*const o_src) = fdc_buf_start + fdc_buf_size;</a>
<a name="ln1658">    // by the time the chroma values are calculated, o_src can be overwritten.</a>
<a name="ln1659">    float(*const fdc_chroma) = (float *)o_src;</a>
<a name="ln1660"> </a>
<a name="ln1661">    for(int left = -pad_tile; left &lt; width - pad_tile; left += TS - (pad_tile * 2))</a>
<a name="ln1662">    {</a>
<a name="ln1663">      int mrow = MIN(top + TS, height + pad_tile);</a>
<a name="ln1664">      int mcol = MIN(left + TS, width + pad_tile);</a>
<a name="ln1665"> </a>
<a name="ln1666">      // Copy current tile from in to image buffer. If border goes</a>
<a name="ln1667">      // beyond edges of image, fill with mirrored/interpolated edges.</a>
<a name="ln1668">      // The extra border avoids discontinuities at image edges.</a>
<a name="ln1669">      for(int row = top; row &lt; mrow; row++)</a>
<a name="ln1670">        for(int col = left; col &lt; mcol; col++)</a>
<a name="ln1671">        {</a>
<a name="ln1672">          float(*const pix) = rgb[0][row - top][col - left];</a>
<a name="ln1673">          if((col &gt;= 0) &amp;&amp; (row &gt;= 0) &amp;&amp; (col &lt; width) &amp;&amp; (row &lt; height))</a>
<a name="ln1674">          {</a>
<a name="ln1675">            const int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln1676">            for(int c = 0; c &lt; 3; c++) pix[c] = (c == f) ? in[roi_in-&gt;width * row + col] : 0.f;</a>
<a name="ln1677">            *(i_src + TS * (row - top) + (col - left)) = in[roi_in-&gt;width * row + col];</a>
<a name="ln1678">          }</a>
<a name="ln1679">          else</a>
<a name="ln1680">          {</a>
<a name="ln1681">            // mirror a border pixel if beyond image edge</a>
<a name="ln1682">            const int c = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln1683">            for(int cc = 0; cc &lt; 3; cc++)</a>
<a name="ln1684">              if(cc != c)</a>
<a name="ln1685">                pix[cc] = 0.0f;</a>
<a name="ln1686">              else</a>
<a name="ln1687">              {</a>
<a name="ln1688">#define TRANSLATE(n, size) ((n &gt;= size) ? (2 * size - n - 2) : abs(n))</a>
<a name="ln1689">                const int cy = TRANSLATE(row, height), cx = TRANSLATE(col, width);</a>
<a name="ln1690">                if(c == FCxtrans(cy, cx, roi_in, xtrans))</a>
<a name="ln1691">                {</a>
<a name="ln1692">                  pix[c] = in[roi_in-&gt;width * cy + cx];</a>
<a name="ln1693">                  *(i_src + TS * (row - top) + (col - left)) = in[roi_in-&gt;width * cy + cx];</a>
<a name="ln1694">                }</a>
<a name="ln1695">                else</a>
<a name="ln1696">                {</a>
<a name="ln1697">                  // interpolate if mirror pixel is a different color</a>
<a name="ln1698">                  float sum = 0.0f;</a>
<a name="ln1699">                  uint8_t count = 0;</a>
<a name="ln1700">                  for(int y = row - 1; y &lt;= row + 1; y++)</a>
<a name="ln1701">                    for(int x = col - 1; x &lt;= col + 1; x++)</a>
<a name="ln1702">                    {</a>
<a name="ln1703">                      const int yy = TRANSLATE(y, height), xx = TRANSLATE(x, width);</a>
<a name="ln1704">                      const int ff = FCxtrans(yy, xx, roi_in, xtrans);</a>
<a name="ln1705">                      if(ff == c)</a>
<a name="ln1706">                      {</a>
<a name="ln1707">                        sum += in[roi_in-&gt;width * yy + xx];</a>
<a name="ln1708">                        count++;</a>
<a name="ln1709">                      }</a>
<a name="ln1710">                    }</a>
<a name="ln1711">                  pix[c] = sum / count;</a>
<a name="ln1712">                  *(i_src + TS * (row - top) + (col - left)) = pix[c];</a>
<a name="ln1713">                }</a>
<a name="ln1714">              }</a>
<a name="ln1715">          }</a>
<a name="ln1716">        }</a>
<a name="ln1717"> </a>
<a name="ln1718">      // duplicate rgb[0] to rgb[1], rgb[2], and rgb[3]</a>
<a name="ln1719">      for(int c = 1; c &lt;= 3; c++) memcpy(rgb[c], rgb[0], sizeof(*rgb));</a>
<a name="ln1720"> </a>
<a name="ln1721">      // note that successive calculations are inset within the tile</a>
<a name="ln1722">      // so as to give enough border data, and there needs to be a 6</a>
<a name="ln1723">      // pixel border initially to allow allhex to find neighboring</a>
<a name="ln1724">      // pixels</a>
<a name="ln1725"> </a>
<a name="ln1726">      /* Set green1 and green3 to the minimum and maximum allowed values:   */</a>
<a name="ln1727">      // Run through each red/blue or blue/red pair, setting their g1</a>
<a name="ln1728">      // and g3 values to the min/max of green pixels surrounding the</a>
<a name="ln1729">      // pair. Use a 3 pixel border as gmin/gmax is used by</a>
<a name="ln1730">      // interpolate green which has a 3 pixel border.</a>
<a name="ln1731">      const int pad_g1_g3 = 3;</a>
<a name="ln1732">      for(int row = top + pad_g1_g3; row &lt; mrow - pad_g1_g3; row++)</a>
<a name="ln1733">      {</a>
<a name="ln1734">        // setting max to 0.0f signifies that this is a new pair, which</a>
<a name="ln1735">        // requires a new min/max calculation of its neighboring greens</a>
<a name="ln1736">        float min = FLT_MAX, max = 0.0f;</a>
<a name="ln1737">        for(int col = left + pad_g1_g3; col &lt; mcol - pad_g1_g3; col++)</a>
<a name="ln1738">        {</a>
<a name="ln1739">          // if in row of horizontal red &amp; blue pairs (or processing</a>
<a name="ln1740">          // vertical red &amp; blue pairs near image bottom), reset min/max</a>
<a name="ln1741">          // between each pair</a>
<a name="ln1742">          if(FCxtrans(row, col, roi_in, xtrans) == 1)</a>
<a name="ln1743">          {</a>
<a name="ln1744">            min = FLT_MAX, max = 0.0f;</a>
<a name="ln1745">            continue;</a>
<a name="ln1746">          }</a>
<a name="ln1747">          // if at start of red &amp; blue pair, calculate min/max of green</a>
<a name="ln1748">          // pixels surrounding it; note that while normally using == to</a>
<a name="ln1749">          // compare floats is suspect, here the check is if 0.0f has</a>
<a name="ln1750">          // explicitly been assigned to max (which signifies a new</a>
<a name="ln1751">          // red/blue pair)</a>
<a name="ln1752">          if(max == 0.0f)</a>
<a name="ln1753">          {</a>
<a name="ln1754">            float (*const pix)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1755">            const short *const hex = hexmap(row, col, allhex);</a>
<a name="ln1756">            for(int c = 0; c &lt; 6; c++)</a>
<a name="ln1757">            {</a>
<a name="ln1758">              const float val = pix[hex[c]][1];</a>
<a name="ln1759">              if(min &gt; val) min = val;</a>
<a name="ln1760">              if(max &lt; val) max = val;</a>
<a name="ln1761">            }</a>
<a name="ln1762">          }</a>
<a name="ln1763">          gmin[row - top][col - left] = min;</a>
<a name="ln1764">          gmax[row - top][col - left] = max;</a>
<a name="ln1765">          // handle vertical red/blue pairs</a>
<a name="ln1766">          switch((row - sgrow) % 3)</a>
<a name="ln1767">          {</a>
<a name="ln1768">            // hop down a row to second pixel in vertical pair</a>
<a name="ln1769">            case 1:</a>
<a name="ln1770">              if(row &lt; mrow - 4) row++, col--;</a>
<a name="ln1771">              break;</a>
<a name="ln1772">            // then if not done with the row hop up and right to next</a>
<a name="ln1773">            // vertical red/blue pair, resetting min/max</a>
<a name="ln1774">            case 2:</a>
<a name="ln1775">              min = FLT_MAX, max = 0.0f;</a>
<a name="ln1776">              if((col += 2) &lt; mcol - 4 &amp;&amp; row &gt; top + 3) row--;</a>
<a name="ln1777">          }</a>
<a name="ln1778">        }</a>
<a name="ln1779">      }</a>
<a name="ln1780"> </a>
<a name="ln1781">      /* Interpolate green horizontally, vertically, and along both diagonals: */</a>
<a name="ln1782">      // need a 3 pixel border here as 3*hex[] can have a 3 unit offset</a>
<a name="ln1783">      const int pad_g_interp = 3;</a>
<a name="ln1784">      for(int row = top + pad_g_interp; row &lt; mrow - pad_g_interp; row++)</a>
<a name="ln1785">        for(int col = left + pad_g_interp; col &lt; mcol - pad_g_interp; col++)</a>
<a name="ln1786">        {</a>
<a name="ln1787">          float color[8];</a>
<a name="ln1788">          int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln1789">          if(f == 1) continue;</a>
<a name="ln1790">          float (*const pix)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1791">          const short *const hex = hexmap(row, col, allhex);</a>
<a name="ln1792">          // TODO: these constants come from integer math constants in</a>
<a name="ln1793">          // dcraw -- calculate them instead from interpolation math</a>
<a name="ln1794">          color[0] = 0.6796875f * (pix[hex[1]][1] + pix[hex[0]][1])</a>
<a name="ln1795">                     - 0.1796875f * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);</a>
<a name="ln1796">          color[1] = 0.87109375f * pix[hex[3]][1] + pix[hex[2]][1] * 0.13f</a>
<a name="ln1797">                     + 0.359375f * (pix[0][f] - pix[-hex[2]][f]);</a>
<a name="ln1798">          for(int c = 0; c &lt; 2; c++)</a>
<a name="ln1799">            color[2 + c] = 0.640625f * pix[hex[4 + c]][1] + 0.359375f * pix[-2 * hex[4 + c]][1]</a>
<a name="ln1800">                           + 0.12890625f * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);</a>
<a name="ln1801">          for(int c = 0; c &lt; 4; c++)</a>
<a name="ln1802">            rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1]</a>
<a name="ln1803">                = CLAMPS(color[c], gmin[row - top][col - left], gmax[row - top][col - left]);</a>
<a name="ln1804">        }</a>
<a name="ln1805"> </a>
<a name="ln1806">      /* Interpolate red and blue values for solitary green pixels:   */</a>
<a name="ln1807">      const int pad_rb_g = 6;</a>
<a name="ln1808">      for(int row = (top - sgrow + pad_rb_g + 2) / 3 * 3 + sgrow; row &lt; mrow - pad_rb_g; row += 3)</a>
<a name="ln1809">        for(int col = (left - sgcol + pad_rb_g + 2) / 3 * 3 + sgcol; col &lt; mcol - pad_rb_g; col += 3)</a>
<a name="ln1810">        {</a>
<a name="ln1811">          float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1812">          int h = FCxtrans(row, col + 1, roi_in, xtrans);</a>
<a name="ln1813">          float diff[6] = { 0.0f };</a>
<a name="ln1814">          float color[3][8];</a>
<a name="ln1815">          for(int i = 1, d = 0; d &lt; 6; d++, i ^= TS ^ 1, h ^= 2)</a>
<a name="ln1816">          {</a>
<a name="ln1817">            for(int c = 0; c &lt; 2; c++, h ^= 2)</a>
<a name="ln1818">            {</a>
<a name="ln1819">              float g = 2 * rfx[0][1] - rfx[i &lt;&lt; c][1] - rfx[-(i &lt;&lt; c)][1];</a>
<a name="ln1820">              color[h][d] = g + rfx[i &lt;&lt; c][h] + rfx[-(i &lt;&lt; c)][h];</a>
<a name="ln1821">              if(d &gt; 1)</a>
<a name="ln1822">                diff[d] += SQR(rfx[i &lt;&lt; c][1] - rfx[-(i &lt;&lt; c)][1] - rfx[i &lt;&lt; c][h] + rfx[-(i &lt;&lt; c)][h]) + SQR(g);</a>
<a name="ln1823">            }</a>
<a name="ln1824">            if(d &gt; 1 &amp;&amp; (d &amp; 1))</a>
<a name="ln1825">              if(diff[d - 1] &lt; diff[d])</a>
<a name="ln1826">                for(int c = 0; c &lt; 2; c++) color[c * 2][d] = color[c * 2][d - 1];</a>
<a name="ln1827">            if(d &lt; 2 || (d &amp; 1))</a>
<a name="ln1828">            {</a>
<a name="ln1829">              for(int c = 0; c &lt; 2; c++) rfx[0][c * 2] = color[c * 2][d] / 2.f;</a>
<a name="ln1830">              rfx += TS * TS;</a>
<a name="ln1831">            }</a>
<a name="ln1832">          }</a>
<a name="ln1833">        }</a>
<a name="ln1834"> </a>
<a name="ln1835">      /* Interpolate red for blue pixels and vice versa:              */</a>
<a name="ln1836">      const int pad_rb_br = 6;</a>
<a name="ln1837">      for(int row = top + pad_rb_br; row &lt; mrow - pad_rb_br; row++)</a>
<a name="ln1838">        for(int col = left + pad_rb_br; col &lt; mcol - pad_rb_br; col++)</a>
<a name="ln1839">        {</a>
<a name="ln1840">          int f = 2 - FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln1841">          if(f == 1) continue;</a>
<a name="ln1842">          float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1843">          int c = (row - sgrow) % 3 ? TS : 1;</a>
<a name="ln1844">          int h = 3 * (c ^ TS ^ 1);</a>
<a name="ln1845">          for(int d = 0; d &lt; 4; d++, rfx += TS * TS)</a>
<a name="ln1846">          {</a>
<a name="ln1847">            int i = d &gt; 1 || ((d ^ c) &amp; 1)</a>
<a name="ln1848">                            || ((fabsf(rfx[0][1] - rfx[c][1]) + fabsf(rfx[0][1] - rfx[-c][1]))</a>
<a name="ln1849">                                &lt; 2.f * (fabsf(rfx[0][1] - rfx[h][1]) + fabsf(rfx[0][1] - rfx[-h][1]))) ? c : h;</a>
<a name="ln1850">            rfx[0][f] = (rfx[i][f] + rfx[-i][f] + 2.f * rfx[0][1] - rfx[i][1] - rfx[-i][1]) / 2.f;</a>
<a name="ln1851">          }</a>
<a name="ln1852">        }</a>
<a name="ln1853"> </a>
<a name="ln1854">      /* Fill in red and blue for 2x2 blocks of green:                */</a>
<a name="ln1855">      const int pad_g22 = 8;</a>
<a name="ln1856">      for(int row = top + pad_g22; row &lt; mrow - pad_g22; row++)</a>
<a name="ln1857">        if((row - sgrow) % 3)</a>
<a name="ln1858">          for(int col = left + pad_g22; col &lt; mcol - pad_g22; col++)</a>
<a name="ln1859">            if((col - sgcol) % 3)</a>
<a name="ln1860">            {</a>
<a name="ln1861">              float redblue[3][3];</a>
<a name="ln1862">              float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1863">              const short *const hex = hexmap(row, col, allhex);</a>
<a name="ln1864">              for(int d = 0; d &lt; ndir; d += 2, rfx += TS * TS)</a>
<a name="ln1865">                if(hex[d] + hex[d + 1])</a>
<a name="ln1866">                {</a>
<a name="ln1867">                  float g = 3.f * rfx[0][1] - 2.f * rfx[hex[d]][1] - rfx[hex[d + 1]][1];</a>
<a name="ln1868">                  for(int c = 0; c &lt; 4; c += 2)</a>
<a name="ln1869">                  {</a>
<a name="ln1870">                    rfx[0][c] = (g + 2.f * rfx[hex[d]][c] + rfx[hex[d + 1]][c]) / 3.f;</a>
<a name="ln1871">                    redblue[d][c] = rfx[0][c];</a>
<a name="ln1872">                  }</a>
<a name="ln1873">                }</a>
<a name="ln1874">                else</a>
<a name="ln1875">                {</a>
<a name="ln1876">                  float g = 2.f * rfx[0][1] - rfx[hex[d]][1] - rfx[hex[d + 1]][1];</a>
<a name="ln1877">                  for(int c = 0; c &lt; 4; c += 2)</a>
<a name="ln1878">                  {</a>
<a name="ln1879">                    rfx[0][c] = (g + rfx[hex[d]][c] + rfx[hex[d + 1]][c]) / 2.f;</a>
<a name="ln1880">                    redblue[d][c] = rfx[0][c];</a>
<a name="ln1881">                  }</a>
<a name="ln1882">                }</a>
<a name="ln1883">              // to fill in red and blue also for diagonal directions</a>
<a name="ln1884">              for(int d = 0; d &lt; ndir; d += 2, rfx += TS * TS)</a>
<a name="ln1885">                for(int c = 0; c &lt; 4; c += 2) rfx[0][c] = (redblue[0][c] + redblue[2][c]) * 0.5f;</a>
<a name="ln1886">           }</a>
<a name="ln1887"> </a>
<a name="ln1888">      // jump back to the first set of rgb buffers (this is a nop</a>
<a name="ln1889">      // unless on the second pass)</a>
<a name="ln1890">      rgb = (float(*)[TS][TS][3])buffer;</a>
<a name="ln1891">      // from here on out, mainly are working within the current tile</a>
<a name="ln1892">      // rather than in reference to the image, so don't offset</a>
<a name="ln1893">      // mrow/mcol by top/left of tile</a>
<a name="ln1894">      mrow -= top;</a>
<a name="ln1895">      mcol -= left;</a>
<a name="ln1896"> </a>
<a name="ln1897">      /* Convert to perceptual colorspace and differentiate in all directions:  */</a>
<a name="ln1898">      // Original dcraw algorithm uses CIELab as perceptual space</a>
<a name="ln1899">      // (presumably coming from original AHD) and converts taking</a>
<a name="ln1900">      // camera matrix into account. Now use YPbPr which requires much</a>
<a name="ln1901">      // less code and is nearly indistinguishable. It assumes the</a>
<a name="ln1902">      // camera RGB is roughly linear.</a>
<a name="ln1903">      for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1904">      {</a>
<a name="ln1905">        const int pad_yuv = 8;</a>
<a name="ln1906">        for(int row = pad_yuv; row &lt; mrow - pad_yuv; row++)</a>
<a name="ln1907">          for(int col = pad_yuv; col &lt; mcol - pad_yuv; col++)</a>
<a name="ln1908">          {</a>
<a name="ln1909">            float *rx = rgb[d][row][col];</a>
<a name="ln1910">            // use ITU-R BT.2020 YPbPr, which is great, but could use</a>
<a name="ln1911">            // a better/simpler choice? note that imageop.h provides</a>
<a name="ln1912">            // dt_iop_RGB_to_YCbCr which uses Rec. 601 conversion,</a>
<a name="ln1913">            // which appears less good with specular highlights</a>
<a name="ln1914">            float y = 0.2627f * rx[0] + 0.6780f * rx[1] + 0.0593f * rx[2];</a>
<a name="ln1915">            yuv[0][row][col] = y;</a>
<a name="ln1916">            yuv[1][row][col] = (rx[2] - y) * 0.56433f;</a>
<a name="ln1917">            yuv[2][row][col] = (rx[0] - y) * 0.67815f;</a>
<a name="ln1918">          }</a>
<a name="ln1919">        // Note that f can offset by a column (-1 or +1) and by a row</a>
<a name="ln1920">        // (-TS or TS). The row-wise offsets cause the undefined</a>
<a name="ln1921">        // behavior sanitizer to warn of an out of bounds index, but</a>
<a name="ln1922">        // as yfx is multi-dimensional and there is sufficient</a>
<a name="ln1923">        // padding, that is not actually so.</a>
<a name="ln1924">        const int f = dir[d &amp; 3];</a>
<a name="ln1925">        const int pad_drv = 9;</a>
<a name="ln1926">        for(int row = pad_drv; row &lt; mrow - pad_drv; row++)</a>
<a name="ln1927">          for(int col = pad_drv; col &lt; mcol - pad_drv; col++)</a>
<a name="ln1928">          {</a>
<a name="ln1929">            float(*yfx)[TS][TS] = (float(*)[TS][TS]) &amp; yuv[0][row][col];</a>
<a name="ln1930">            drv[d][row][col] = SQR(2 * yfx[0][0][0] - yfx[0][0][f] - yfx[0][0][-f])</a>
<a name="ln1931">                               + SQR(2 * yfx[1][0][0] - yfx[1][0][f] - yfx[1][0][-f])</a>
<a name="ln1932">                               + SQR(2 * yfx[2][0][0] - yfx[2][0][f] - yfx[2][0][-f]);</a>
<a name="ln1933">          }</a>
<a name="ln1934">      }</a>
<a name="ln1935"> </a>
<a name="ln1936">      /* Build homogeneity maps from the derivatives:                   */</a>
<a name="ln1937">      memset(homo, 0, (size_t)ndir * TS * TS * sizeof(uint8_t));</a>
<a name="ln1938">      const int pad_homo = 10;</a>
<a name="ln1939">      for(int row = pad_homo; row &lt; mrow - pad_homo; row++)</a>
<a name="ln1940">        for(int col = pad_homo; col &lt; mcol - pad_homo; col++)</a>
<a name="ln1941">        {</a>
<a name="ln1942">          float tr = FLT_MAX;</a>
<a name="ln1943">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1944">            if(tr &gt; drv[d][row][col]) tr = drv[d][row][col];</a>
<a name="ln1945">          tr *= 8;</a>
<a name="ln1946">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1947">            for(int v = -1; v &lt;= 1; v++)</a>
<a name="ln1948">              for(int h = -1; h &lt;= 1; h++) homo[d][row][col] += ((drv[d][row + v][col + h] &lt;= tr) ? 1 : 0);</a>
<a name="ln1949">        }</a>
<a name="ln1950"> </a>
<a name="ln1951">      /* Build 5x5 sum of homogeneity maps for each pixel &amp; direction */</a>
<a name="ln1952">      for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1953">        for(int row = pad_tile; row &lt; mrow - pad_tile; row++)</a>
<a name="ln1954">        {</a>
<a name="ln1955">          // start before first column where homo[d][row][col+2] != 0,</a>
<a name="ln1956">          // so can know v5sum and homosum[d][row][col] will be 0</a>
<a name="ln1957">          int col = pad_tile - 5;</a>
<a name="ln1958">          uint8_t v5sum[5] = { 0 };</a>
<a name="ln1959">          homosum[d][row][col] = 0;</a>
<a name="ln1960">          // calculate by rolling through column sums</a>
<a name="ln1961">          for(col++; col &lt; mcol - pad_tile; col++)</a>
<a name="ln1962">          {</a>
<a name="ln1963">            uint8_t colsum = 0;</a>
<a name="ln1964">            for(int v = -2; v &lt;= 2; v++) colsum += homo[d][row + v][col + 2];</a>
<a name="ln1965">            homosum[d][row][col] = homosum[d][row][col - 1] - v5sum[col % 5] + colsum;</a>
<a name="ln1966">            v5sum[col % 5] = colsum;</a>
<a name="ln1967">          }</a>
<a name="ln1968">        }</a>
<a name="ln1969"> </a>
<a name="ln1970">      /* Calculate chroma values in fdc:       */</a>
<a name="ln1971">      const int pad_fdc = 6;</a>
<a name="ln1972">      for(int row = pad_fdc; row &lt; mrow - pad_fdc; row++)</a>
<a name="ln1973">        for(int col = pad_fdc; col &lt; mcol - pad_fdc; col++)</a>
<a name="ln1974">        {</a>
<a name="ln1975">          int myrow, mycol;</a>
<a name="ln1976">          uint8_t hm[8] = { 0 };</a>
<a name="ln1977">          uint8_t maxval = 0;</a>
<a name="ln1978">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1979">          {</a>
<a name="ln1980">            hm[d] = homosum[d][row][col];</a>
<a name="ln1981">            maxval = (maxval &lt; hm[d] ? hm[d] : maxval);</a>
<a name="ln1982">          }</a>
<a name="ln1983">          maxval -= maxval &gt;&gt; 3;</a>
<a name="ln1984">          float dircount = 0;</a>
<a name="ln1985">          float dirsum = 0.f;</a>
<a name="ln1986">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1987">            if(hm[d] &gt;= maxval)</a>
<a name="ln1988">            {</a>
<a name="ln1989">              dircount++;</a>
<a name="ln1990">              dirsum += directionality[d];</a>
<a name="ln1991">            }</a>
<a name="ln1992">          float w = dirsum / (float)dircount;</a>
<a name="ln1993">          int fdc_row, fdc_col;</a>
<a name="ln1994">          float complex C2m, C5m, C7m, C10m;</a>
<a name="ln1995">#define CONV_FILT(VAR, FILT)                                                                                      \</a>
<a name="ln1996">  VAR = 0.0f + 0.0f * _Complex_I;                                                                                 \</a>
<a name="ln1997">  for(fdc_row = 0, myrow = row - 6; fdc_row &lt; 13; fdc_row++, myrow++)                                             \</a>
<a name="ln1998">    for(fdc_col = 0, mycol = col - 6; fdc_col &lt; 13; fdc_col++, mycol++)                                           \</a>
<a name="ln1999">      VAR += FILT[12 - fdc_row][12 - fdc_col] * *(i_src + TS * myrow + mycol);</a>
<a name="ln2000">          CONV_FILT(C2m, harr[0])</a>
<a name="ln2001">          CONV_FILT(C5m, harr[1])</a>
<a name="ln2002">          CONV_FILT(C7m, harr[2])</a>
<a name="ln2003">          CONV_FILT(C10m, harr[3])</a>
<a name="ln2004">#undef CONV_FILT</a>
<a name="ln2005">          // build the q vector components</a>
<a name="ln2006">          myrow = (row + rowoffset) % 6;</a>
<a name="ln2007">          mycol = (col + coloffset) % 6;</a>
<a name="ln2008">          float complex modulator[8];</a>
<a name="ln2009">          for(int c = 0; c &lt; 8; c++) modulator[c] = modarr[myrow][mycol][c];</a>
<a name="ln2010">          float complex qmat[8];</a>
<a name="ln2011">          qmat[4] = w * C10m * modulator[0] - (1.0f - w) * C2m * modulator[1];</a>
<a name="ln2012">          qmat[6] = conjf(qmat[4]);</a>
<a name="ln2013">          qmat[1] = C5m * modulator[6];</a>
<a name="ln2014">          qmat[2] = conjf(-0.5f * qmat[1]);</a>
<a name="ln2015">          qmat[5] = conjf(qmat[2]);</a>
<a name="ln2016">          qmat[3] = C7m * modulator[7];</a>
<a name="ln2017">          qmat[7] = conjf(qmat[1]);</a>
<a name="ln2018">          // get L</a>
<a name="ln2019">          C2m = qmat[4] * (conjf(modulator[0]) - conjf(modulator[1]));</a>
<a name="ln2020">          float complex C3m = qmat[6] * (modulator[2] - modulator[3]);</a>
<a name="ln2021">          float complex C6m = qmat[2] * (conjf(modulator[4]) + conjf(modulator[5]));</a>
<a name="ln2022">          float complex C12m = qmat[5] * (modulator[4] + modulator[5]);</a>
<a name="ln2023">          float complex C18m = qmat[7] * modulator[6];</a>
<a name="ln2024">          qmat[0] = *(i_src + row * TS + col) - C2m - C3m - C5m - C6m - 2.0f * C7m - C12m - C18m;</a>
<a name="ln2025">          // get the rgb components from fdc</a>
<a name="ln2026">          float rgbpix[3] = { 0.f, 0.f, 0.f };</a>
<a name="ln2027">          // multiply with the inverse matrix of M</a>
<a name="ln2028">          for(int color = 0; color &lt; 3; color++)</a>
<a name="ln2029">            for(int c = 0; c &lt; 8; c++)</a>
<a name="ln2030">            {</a>
<a name="ln2031">              rgbpix[color] += Minv[color][c] * qmat[c];</a>
<a name="ln2032">            }</a>
<a name="ln2033">          // now separate luma and chroma for</a>
<a name="ln2034">          // frequency domain chroma</a>
<a name="ln2035">          // and store it in fdc_chroma</a>
<a name="ln2036">          float uv[2];</a>
<a name="ln2037">          float y = 0.2627f * rgbpix[0] + 0.6780f * rgbpix[1] + 0.0593f * rgbpix[2];</a>
<a name="ln2038">          uv[0] = (rgbpix[2] - y) * 0.56433f;</a>
<a name="ln2039">          uv[1] = (rgbpix[0] - y) * 0.67815f;</a>
<a name="ln2040">          for(int c = 0; c &lt; 2; c++) *(fdc_chroma + c * TS * TS + row * TS + col) = uv[c];</a>
<a name="ln2041">        }</a>
<a name="ln2042"> </a>
<a name="ln2043">      /* Average the most homogenous pixels for the final result:       */</a>
<a name="ln2044">      for(int row = pad_tile; row &lt; mrow - pad_tile; row++)</a>
<a name="ln2045">        for(int col = pad_tile; col &lt; mcol - pad_tile; col++)</a>
<a name="ln2046">        {</a>
<a name="ln2047">          uint8_t hm[8] = { 0 };</a>
<a name="ln2048">          uint8_t maxval = 0;</a>
<a name="ln2049">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln2050">          {</a>
<a name="ln2051">            hm[d] = homosum[d][row][col];</a>
<a name="ln2052">            maxval = (maxval &lt; hm[d] ? hm[d] : maxval);</a>
<a name="ln2053">          }</a>
<a name="ln2054">          maxval -= maxval &gt;&gt; 3;</a>
<a name="ln2055">          for(int d = 0; d &lt; ndir - 4; d++)</a>
<a name="ln2056">            if(hm[d] &lt; hm[d + 4])</a>
<a name="ln2057">              hm[d] = 0;</a>
<a name="ln2058">            else if(hm[d] &gt; hm[d + 4])</a>
<a name="ln2059">              hm[d + 4] = 0;</a>
<a name="ln2060">          float avg[4] = { 0.f };</a>
<a name="ln2061">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln2062">            if(hm[d] &gt;= maxval)</a>
<a name="ln2063">            {</a>
<a name="ln2064">              for(int c = 0; c &lt; 3; c++) avg[c] += rgb[d][row][col][c];</a>
<a name="ln2065">              avg[3]++;</a>
<a name="ln2066">            }</a>
<a name="ln2067">          float rgbpix[3];</a>
<a name="ln2068">          for(int c = 0; c &lt; 3; c++) rgbpix[c] = avg[c] / avg[3];</a>
<a name="ln2069">          // preserve all components of Markesteijn for this pixel</a>
<a name="ln2070">          float y = 0.2627f * rgbpix[0] + 0.6780f * rgbpix[1] + 0.0593f * rgbpix[2];</a>
<a name="ln2071">          float um = (rgbpix[2] - y) * 0.56433f;</a>
<a name="ln2072">          float vm = (rgbpix[0] - y) * 0.67815f;</a>
<a name="ln2073">          float uvf[2];</a>
<a name="ln2074">          // macros for fast meadian filtering</a>
<a name="ln2075">#define PIX_SWAP(a, b)                                                                                            \</a>
<a name="ln2076">  {                                                                                                               \</a>
<a name="ln2077">    tempf = (a);                                                                                                  \</a>
<a name="ln2078">    (a) = (b);                                                                                                    \</a>
<a name="ln2079">    (b) = tempf;                                                                                                  \</a>
<a name="ln2080">  }</a>
<a name="ln2081">#define PIX_SORT(a, b)                                                                                            \</a>
<a name="ln2082">  {                                                                                                               \</a>
<a name="ln2083">    if((a) &gt; (b)) PIX_SWAP((a), (b));                                                                             \</a>
<a name="ln2084">  }</a>
<a name="ln2085">          // instead of merely reading the values, perform 5 pixel median filter</a>
<a name="ln2086">          // one median filter is required to avoid textile artifacts</a>
<a name="ln2087">          for(int chrm = 0; chrm &lt; 2; chrm++)</a>
<a name="ln2088">          {</a>
<a name="ln2089">            float temp[5];</a>
<a name="ln2090">            float tempf;</a>
<a name="ln2091">            // load the window into temp</a>
<a name="ln2092">            memcpy(&amp;temp[0], fdc_chroma + chrm * TS * TS + (row - 1) * TS + (col), 1 * sizeof(float));</a>
<a name="ln2093">            memcpy(&amp;temp[1], fdc_chroma + chrm * TS * TS + (row)*TS + (col - 1), 3 * sizeof(float));</a>
<a name="ln2094">            memcpy(&amp;temp[4], fdc_chroma + chrm * TS * TS + (row + 1) * TS + (col), 1 * sizeof(float));</a>
<a name="ln2095">            PIX_SORT(temp[0], temp[1]);</a>
<a name="ln2096">            PIX_SORT(temp[3], temp[4]);</a>
<a name="ln2097">            PIX_SORT(temp[0], temp[3]);</a>
<a name="ln2098">            PIX_SORT(temp[1], temp[4]);</a>
<a name="ln2099">            PIX_SORT(temp[1], temp[2]);</a>
<a name="ln2100">            PIX_SORT(temp[2], temp[3]);</a>
<a name="ln2101">            PIX_SORT(temp[1], temp[2]);</a>
<a name="ln2102">            uvf[chrm] = temp[2];</a>
<a name="ln2103">          }</a>
<a name="ln2104">          // use hybrid or pure fdc, depending on what was set above.</a>
<a name="ln2105">          // in case of hybrid, use the chroma that has the smallest</a>
<a name="ln2106">          // absolute value</a>
<a name="ln2107">          float uv[2];</a>
<a name="ln2108">          uv[0] = (((ABS(uvf[0]) &lt; ABS(um)) &amp; (ABS(uvf[1]) &lt; (1.02f * ABS(vm)))) ? uvf[0] : um) * hybrid_fdc[0] + uvf[0] * hybrid_fdc[1];</a>
<a name="ln2109">          uv[1] = (((ABS(uvf[1]) &lt; ABS(vm)) &amp; (ABS(uvf[0]) &lt; (1.02f * ABS(vm)))) ? uvf[1] : vm) * hybrid_fdc[0] + uvf[1] * hybrid_fdc[1];</a>
<a name="ln2110">          // combine the luma from Markesteijn with the chroma from above</a>
<a name="ln2111">          rgbpix[0] = y + 1.474600014746f * uv[1];</a>
<a name="ln2112">          rgbpix[1] = y - 0.15498578286403f * uv[0] - 0.571353132557189f * uv[1];</a>
<a name="ln2113">          rgbpix[2] = y + 1.77201282937288f * uv[0];</a>
<a name="ln2114">          for(int c = 0; c &lt; 3; c++) out[4 * (width * (row + top) + col + left) + c] = rgbpix[c];</a>
<a name="ln2115">        }</a>
<a name="ln2116">    }</a>
<a name="ln2117">  }</a>
<a name="ln2118">  dt_free_align(all_buffers);</a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121">#undef PIX_SWAP</a>
<a name="ln2122">#undef PIX_SORT</a>
<a name="ln2123">#undef CCLIP</a>
<a name="ln2124">#undef TS</a>
<a name="ln2125"> </a>
<a name="ln2126">/* taken from dcraw and demosaic_ppg below */</a>
<a name="ln2127"> </a>
<a name="ln2128">static void lin_interpolate(float *out, const float *const in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln2129">                            const dt_iop_roi_t *const roi_in, const uint32_t filters,</a>
<a name="ln2130">                            const uint8_t (*const xtrans)[6])</a>
<a name="ln2131">{</a>
<a name="ln2132">  const int colors = (filters == 9) ? 3 : 4;</a>
<a name="ln2133"> </a>
<a name="ln2134">// border interpolate</a>
<a name="ln2135">#ifdef _OPENMP</a>
<a name="ln2136">#pragma omp parallel for default(none) shared(out) schedule(static)</a>
<a name="ln2137">#endif</a>
<a name="ln2138">  for(int row = 0; row &lt; roi_out-&gt;height; row++)</a>
<a name="ln2139">    for(int col = 0; col &lt; roi_out-&gt;width; col++)</a>
<a name="ln2140">    {</a>
<a name="ln2141">      float sum[4] = { 0.0f };</a>
<a name="ln2142">      uint8_t count[4] = { 0 };</a>
<a name="ln2143">      if(col == 1 &amp;&amp; row &gt;= 1 &amp;&amp; row &lt; roi_out-&gt;height - 1) col = roi_out-&gt;width - 1;</a>
<a name="ln2144">      // average all the adjoining pixels inside image by color</a>
<a name="ln2145">      for(int y = row - 1; y != row + 2; y++)</a>
<a name="ln2146">        for(int x = col - 1; x != col + 2; x++)</a>
<a name="ln2147">          if(y &gt;= 0 &amp;&amp; x &gt;= 0 &amp;&amp; y &lt; roi_in-&gt;height &amp;&amp; x &lt; roi_in-&gt;width)</a>
<a name="ln2148">          {</a>
<a name="ln2149">            const int f = fcol(y + roi_in-&gt;y, x + roi_in-&gt;x, filters, xtrans);</a>
<a name="ln2150">            sum[f] += in[y * roi_in-&gt;width + x];</a>
<a name="ln2151">            count[f]++;</a>
<a name="ln2152">          }</a>
<a name="ln2153">      const int f = fcol(row + roi_in-&gt;y, col + roi_in-&gt;x, filters, xtrans);</a>
<a name="ln2154">      // for current cell, copy the current sensor's color data,</a>
<a name="ln2155">      // interpolate the other two colors from surrounding pixels of</a>
<a name="ln2156">      // their color</a>
<a name="ln2157">      for(int c = 0; c &lt; colors; c++)</a>
<a name="ln2158">      {</a>
<a name="ln2159">        if(c != f &amp;&amp; count[c] != 0)</a>
<a name="ln2160">          out[4 * (row * roi_out-&gt;width + col) + c] = sum[c] / count[c];</a>
<a name="ln2161">        else</a>
<a name="ln2162">          out[4 * (row * roi_out-&gt;width + col) + c] = in[row * roi_in-&gt;width + col];</a>
<a name="ln2163">      }</a>
<a name="ln2164">    }</a>
<a name="ln2165"> </a>
<a name="ln2166">  // build interpolation lookup table which for a given offset in the sensor</a>
<a name="ln2167">  // lists neighboring pixels from which to interpolate:</a>
<a name="ln2168">  // NUM_PIXELS                 # of neighboring pixels to read</a>
<a name="ln2169">  // for (1..NUM_PIXELS):</a>
<a name="ln2170">  //   OFFSET                   # in bytes from current pixel</a>
<a name="ln2171">  //   WEIGHT                   # how much weight to give this neighbor</a>
<a name="ln2172">  //   COLOR                    # sensor color</a>
<a name="ln2173">  // # weights of adjoining pixels not of this pixel's color</a>
<a name="ln2174">  // COLORA TOT_WEIGHT</a>
<a name="ln2175">  // COLORB TOT_WEIGHT</a>
<a name="ln2176">  // COLORPIX                   # color of center pixel</a>
<a name="ln2177"> </a>
<a name="ln2178">  int(*const lookup)[16][32] = malloc((size_t)16 * 16 * 32 * sizeof(int));</a>
<a name="ln2179"> </a>
<a name="ln2180">  const int size = (filters == 9) ? 6 : 16;</a>
<a name="ln2181">  for(int row = 0; row &lt; size; row++)</a>
<a name="ln2182">    for(int col = 0; col &lt; size; col++)</a>
<a name="ln2183">    {</a>
<a name="ln2184">      int *ip = lookup[row][col] + 1;</a>
<a name="ln2185">      int sum[4] = { 0 };</a>
<a name="ln2186">      const int f = fcol(row + roi_in-&gt;y, col + roi_in-&gt;x, filters, xtrans);</a>
<a name="ln2187">      // make list of adjoining pixel offsets by weight &amp; color</a>
<a name="ln2188">      for(int y = -1; y &lt;= 1; y++)</a>
<a name="ln2189">        for(int x = -1; x &lt;= 1; x++)</a>
<a name="ln2190">        {</a>
<a name="ln2191">          int weight = 1 &lt;&lt; ((y == 0) + (x == 0));</a>
<a name="ln2192">          const int color = fcol(row + y + roi_in-&gt;y, col + x + roi_in-&gt;x, filters, xtrans);</a>
<a name="ln2193">          if(color == f) continue;</a>
<a name="ln2194">          *ip++ = (roi_in-&gt;width * y + x);</a>
<a name="ln2195">          *ip++ = weight;</a>
<a name="ln2196">          *ip++ = color;</a>
<a name="ln2197">          sum[color] += weight;</a>
<a name="ln2198">        }</a>
<a name="ln2199">      lookup[row][col][0] = (ip - lookup[row][col]) / 3; /* # of neighboring pixels found */</a>
<a name="ln2200">      for(int c = 0; c &lt; colors; c++)</a>
<a name="ln2201">        if(c != f)</a>
<a name="ln2202">        {</a>
<a name="ln2203">          *ip++ = c;</a>
<a name="ln2204">          *ip++ = sum[c];</a>
<a name="ln2205">        }</a>
<a name="ln2206">      *ip = f;</a>
<a name="ln2207">    }</a>
<a name="ln2208"> </a>
<a name="ln2209">#ifdef _OPENMP</a>
<a name="ln2210">#pragma omp parallel for default(none) shared(out) schedule(static)</a>
<a name="ln2211">#endif</a>
<a name="ln2212">  for(int row = 1; row &lt; roi_out-&gt;height - 1; row++)</a>
<a name="ln2213">  {</a>
<a name="ln2214">    float *buf = out + 4 * roi_out-&gt;width * row + 4;</a>
<a name="ln2215">    const float *buf_in = in + roi_in-&gt;width * row + 1;</a>
<a name="ln2216">    for(int col = 1; col &lt; roi_out-&gt;width - 1; col++)</a>
<a name="ln2217">    {</a>
<a name="ln2218">      float sum[4] = { 0.0f };</a>
<a name="ln2219">      int *ip = lookup[row % size][col % size];</a>
<a name="ln2220">      // for each adjoining pixel not of this pixel's color, sum up its weighted values</a>
<a name="ln2221">      for(int i = *ip++; i--; ip += 3) sum[ip[2]] += buf_in[ip[0]] * ip[1];</a>
<a name="ln2222">      // for each interpolated color, load it into the pixel</a>
<a name="ln2223">      for(int i = colors; --i; ip += 2) buf[*ip] = sum[ip[0]] / ip[1];</a>
<a name="ln2224">      buf[*ip] = *buf_in;</a>
<a name="ln2225">      buf += 4;</a>
<a name="ln2226">      buf_in++;</a>
<a name="ln2227">    }</a>
<a name="ln2228">  }</a>
<a name="ln2229"> </a>
<a name="ln2230">  free(lookup);</a>
<a name="ln2231">}</a>
<a name="ln2232"> </a>
<a name="ln2233"> </a>
<a name="ln2234">// VNG interpolate adapted from dcraw 9.20</a>
<a name="ln2235"> </a>
<a name="ln2236">/*</a>
<a name="ln2237">   This algorithm is officially called:</a>
<a name="ln2238"> </a>
<a name="ln2239">   &quot;Interpolation using a Threshold-based variable number of gradients&quot;</a>
<a name="ln2240"> </a>
<a name="ln2241">   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html</a>
<a name="ln2242"> </a>
<a name="ln2243">   I've extended the basic idea to work with non-Bayer filter arrays.</a>
<a name="ln2244">   Gradients are numbered clockwise from NW=0 to W=7.</a>
<a name="ln2245"> */</a>
<a name="ln2246">static void vng_interpolate(float *out, const float *const in,</a>
<a name="ln2247">                            const dt_iop_roi_t *const roi_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln2248">                            const uint32_t filters, const uint8_t (*const xtrans)[6], const int only_vng_linear)</a>
<a name="ln2249">{</a>
<a name="ln2250">  static const signed char terms[]</a>
<a name="ln2251">      = { -2, -2, +0, -1, 1, 0x01, -2, -2, +0, +0, 2, 0x01, -2, -1, -1, +0, 1, 0x01, -2, -1, +0, -1, 1, 0x02,</a>
<a name="ln2252">          -2, -1, +0, +0, 1, 0x03, -2, -1, +0, +1, 2, 0x01, -2, +0, +0, -1, 1, 0x06, -2, +0, +0, +0, 2, 0x02,</a>
<a name="ln2253">          -2, +0, +0, +1, 1, 0x03, -2, +1, -1, +0, 1, 0x04, -2, +1, +0, -1, 2, 0x04, -2, +1, +0, +0, 1, 0x06,</a>
<a name="ln2254">          -2, +1, +0, +1, 1, 0x02, -2, +2, +0, +0, 2, 0x04, -2, +2, +0, +1, 1, 0x04, -1, -2, -1, +0, 1, 0x80,</a>
<a name="ln2255">          -1, -2, +0, -1, 1, 0x01, -1, -2, +1, -1, 1, 0x01, -1, -2, +1, +0, 2, 0x01, -1, -1, -1, +1, 1, 0x88,</a>
<a name="ln2256">          -1, -1, +1, -2, 1, 0x40, -1, -1, +1, -1, 1, 0x22, -1, -1, +1, +0, 1, 0x33, -1, -1, +1, +1, 2, 0x11,</a>
<a name="ln2257">          -1, +0, -1, +2, 1, 0x08, -1, +0, +0, -1, 1, 0x44, -1, +0, +0, +1, 1, 0x11, -1, +0, +1, -2, 2, 0x40,</a>
<a name="ln2258">          -1, +0, +1, -1, 1, 0x66, -1, +0, +1, +0, 2, 0x22, -1, +0, +1, +1, 1, 0x33, -1, +0, +1, +2, 2, 0x10,</a>
<a name="ln2259">          -1, +1, +1, -1, 2, 0x44, -1, +1, +1, +0, 1, 0x66, -1, +1, +1, +1, 1, 0x22, -1, +1, +1, +2, 1, 0x10,</a>
<a name="ln2260">          -1, +2, +0, +1, 1, 0x04, -1, +2, +1, +0, 2, 0x04, -1, +2, +1, +1, 1, 0x04, +0, -2, +0, +0, 2, 0x80,</a>
<a name="ln2261">          +0, -1, +0, +1, 2, 0x88, +0, -1, +1, -2, 1, 0x40, +0, -1, +1, +0, 1, 0x11, +0, -1, +2, -2, 1, 0x40,</a>
<a name="ln2262">          +0, -1, +2, -1, 1, 0x20, +0, -1, +2, +0, 1, 0x30, +0, -1, +2, +1, 2, 0x10, +0, +0, +0, +2, 2, 0x08,</a>
<a name="ln2263">          +0, +0, +2, -2, 2, 0x40, +0, +0, +2, -1, 1, 0x60, +0, +0, +2, +0, 2, 0x20, +0, +0, +2, +1, 1, 0x30,</a>
<a name="ln2264">          +0, +0, +2, +2, 2, 0x10, +0, +1, +1, +0, 1, 0x44, +0, +1, +1, +2, 1, 0x10, +0, +1, +2, -1, 2, 0x40,</a>
<a name="ln2265">          +0, +1, +2, +0, 1, 0x60, +0, +1, +2, +1, 1, 0x20, +0, +1, +2, +2, 1, 0x10, +1, -2, +1, +0, 1, 0x80,</a>
<a name="ln2266">          +1, -1, +1, +1, 1, 0x88, +1, +0, +1, +2, 1, 0x08, +1, +0, +2, -1, 1, 0x40, +1, +0, +2, +1, 1, 0x10 },</a>
<a name="ln2267">      chood[] = { -1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1 };</a>
<a name="ln2268">  int *ip, *code[16][16];</a>
<a name="ln2269">  // ring buffer pointing to three most recent rows processed (brow[3]</a>
<a name="ln2270">  // is only used for rotating the buffer</a>
<a name="ln2271">  float(*brow[4])[4];</a>
<a name="ln2272">  const int width = roi_out-&gt;width, height = roi_out-&gt;height;</a>
<a name="ln2273">  const int prow = (filters == 9) ? 6 : 8;</a>
<a name="ln2274">  const int pcol = (filters == 9) ? 6 : 2;</a>
<a name="ln2275">  const int colors = (filters == 9) ? 3 : 4;</a>
<a name="ln2276"> </a>
<a name="ln2277">  // separate out G1 and G2 in RGGB Bayer patterns</a>
<a name="ln2278">  uint32_t filters4 = filters;</a>
<a name="ln2279">  if(filters == 9 || FILTERS_ARE_4BAYER(filters)) // x-trans or CYGM/RGBE</a>
<a name="ln2280">    filters4 = filters;</a>
<a name="ln2281">  else if((filters &amp; 3) == 1)</a>
<a name="ln2282">    filters4 = filters | 0x03030303u;</a>
<a name="ln2283">  else</a>
<a name="ln2284">    filters4 = filters | 0x0c0c0c0cu;</a>
<a name="ln2285"> </a>
<a name="ln2286">  lin_interpolate(out, in, roi_out, roi_in, filters4, xtrans);</a>
<a name="ln2287"> </a>
<a name="ln2288">  // if only linear interpolation is requested we can stop it here</a>
<a name="ln2289">  if(only_vng_linear) return;</a>
<a name="ln2290"> </a>
<a name="ln2291">  char *buffer</a>
<a name="ln2292">      = (char *)dt_alloc_align(64, (size_t)sizeof(**brow) * width * 3 + sizeof(*ip) * prow * pcol * 320);</a>
<a name="ln2293">  if(!buffer)</a>
<a name="ln2294">  {</a>
<a name="ln2295">    fprintf(stderr, &quot;[demosaic] not able to allocate VNG buffer\n&quot;);</a>
<a name="ln2296">    return;</a>
<a name="ln2297">  }</a>
<a name="ln2298">  for(int row = 0; row &lt; 3; row++) brow[row] = (float(*)[4])buffer + row * width;</a>
<a name="ln2299">  ip = (int *)(buffer + (size_t)sizeof(**brow) * width * 3);</a>
<a name="ln2300"> </a>
<a name="ln2301">  for(int row = 0; row &lt; prow; row++) /* Precalculate for VNG */</a>
<a name="ln2302">    for(int col = 0; col &lt; pcol; col++)</a>
<a name="ln2303">    {</a>
<a name="ln2304">      code[row][col] = ip;</a>
<a name="ln2305">      const signed char *cp = terms;</a>
<a name="ln2306">      for(int t = 0; t &lt; 64; t++)</a>
<a name="ln2307">      {</a>
<a name="ln2308">        int y1 = *cp++, x1 = *cp++;</a>
<a name="ln2309">        int y2 = *cp++, x2 = *cp++;</a>
<a name="ln2310">        int weight = *cp++;</a>
<a name="ln2311">        int grads = *cp++;</a>
<a name="ln2312">        int color = fcol(row + y1, col + x1, filters4, xtrans);</a>
<a name="ln2313">        if(fcol(row + y2, col + x2, filters4, xtrans) != color) continue;</a>
<a name="ln2314">        int diag</a>
<a name="ln2315">            = (fcol(row, col + 1, filters4, xtrans) == color &amp;&amp; fcol(row + 1, col, filters4, xtrans) == color)</a>
<a name="ln2316">                  ? 2</a>
<a name="ln2317">                  : 1;</a>
<a name="ln2318">        if(abs(y1 - y2) == diag &amp;&amp; abs(x1 - x2) == diag) continue;</a>
<a name="ln2319">        *ip++ = (y1 * width + x1) * 4 + color;</a>
<a name="ln2320">        *ip++ = (y2 * width + x2) * 4 + color;</a>
<a name="ln2321">        *ip++ = weight;</a>
<a name="ln2322">        for(int g = 0; g &lt; 8; g++)</a>
<a name="ln2323">          if(grads &amp; 1 &lt;&lt; g) *ip++ = g;</a>
<a name="ln2324">        *ip++ = -1;</a>
<a name="ln2325">      }</a>
<a name="ln2326">      *ip++ = INT_MAX;</a>
<a name="ln2327">      cp = chood;</a>
<a name="ln2328">      for(int g = 0; g &lt; 8; g++)</a>
<a name="ln2329">      {</a>
<a name="ln2330">        int y = *cp++, x = *cp++;</a>
<a name="ln2331">        *ip++ = (y * width + x) * 4;</a>
<a name="ln2332">        int color = fcol(row, col, filters4, xtrans);</a>
<a name="ln2333">        if(fcol(row + y, col + x, filters4, xtrans) != color</a>
<a name="ln2334">           &amp;&amp; fcol(row + y * 2, col + x * 2, filters4, xtrans) == color)</a>
<a name="ln2335">          *ip++ = (y * width + x) * 8 + color;</a>
<a name="ln2336">        else</a>
<a name="ln2337">          *ip++ = 0;</a>
<a name="ln2338">      }</a>
<a name="ln2339">    }</a>
<a name="ln2340"> </a>
<a name="ln2341">  for(int row = 2; row &lt; height - 2; row++) /* Do VNG interpolation */</a>
<a name="ln2342">  {</a>
<a name="ln2343">#ifdef _OPENMP</a>
<a name="ln2344">#pragma omp parallel for default(none) shared(row, code, brow, out, filters4) private(ip) schedule(static)</a>
<a name="ln2345">#endif</a>
<a name="ln2346">    for(int col = 2; col &lt; width - 2; col++)</a>
<a name="ln2347">    {</a>
<a name="ln2348">      int g;</a>
<a name="ln2349">      float gval[8] = { 0.0f };</a>
<a name="ln2350">      float *pix = out + 4 * (row * width + col);</a>
<a name="ln2351">      ip = code[(row + roi_in-&gt;y) % prow][(col + roi_in-&gt;x) % pcol];</a>
<a name="ln2352">      while((g = ip[0]) != INT_MAX) /* Calculate gradients */</a>
<a name="ln2353">      {</a>
<a name="ln2354">        float diff = fabsf(pix[g] - pix[ip[1]]) * ip[2];</a>
<a name="ln2355">        gval[ip[3]] += diff;</a>
<a name="ln2356">        ip += 5;</a>
<a name="ln2357">        if((g = ip[-1]) == -1) continue;</a>
<a name="ln2358">        gval[g] += diff;</a>
<a name="ln2359">        while((g = *ip++) != -1) gval[g] += diff;</a>
<a name="ln2360">      }</a>
<a name="ln2361">      ip++;</a>
<a name="ln2362">      float gmin = gval[0], gmax = gval[0]; /* Choose a threshold */</a>
<a name="ln2363">      for(g = 1; g &lt; 8; g++)</a>
<a name="ln2364">      {</a>
<a name="ln2365">        if(gmin &gt; gval[g]) gmin = gval[g];</a>
<a name="ln2366">        if(gmax &lt; gval[g]) gmax = gval[g];</a>
<a name="ln2367">      }</a>
<a name="ln2368">      if(gmax == 0)</a>
<a name="ln2369">      {</a>
<a name="ln2370">        memcpy(brow[2][col], pix, (size_t)4 * sizeof(*out));</a>
<a name="ln2371">        continue;</a>
<a name="ln2372">      }</a>
<a name="ln2373">      float thold = gmin + (gmax * 0.5f);</a>
<a name="ln2374">      float sum[4] = { 0.0f };</a>
<a name="ln2375">      int color = fcol(row + roi_in-&gt;y, col + roi_in-&gt;x, filters4, xtrans);</a>
<a name="ln2376">      int num = 0;</a>
<a name="ln2377">      for(g = 0; g &lt; 8; g++, ip += 2) /* Average the neighbors */</a>
<a name="ln2378">      {</a>
<a name="ln2379">        if(gval[g] &lt;= thold)</a>
<a name="ln2380">        {</a>
<a name="ln2381">          for(int c = 0; c &lt; colors; c++)</a>
<a name="ln2382">            if(c == color &amp;&amp; ip[1])</a>
<a name="ln2383">              sum[c] += (pix[c] + pix[ip[1]]) * 0.5f;</a>
<a name="ln2384">            else</a>
<a name="ln2385">              sum[c] += pix[ip[0] + c];</a>
<a name="ln2386">          num++;</a>
<a name="ln2387">        }</a>
<a name="ln2388">      }</a>
<a name="ln2389">      for(int c = 0; c &lt; colors; c++) /* Save to buffer */</a>
<a name="ln2390">      {</a>
<a name="ln2391">        float tot = pix[color];</a>
<a name="ln2392">        if(c != color) tot += (sum[c] - sum[color]) / num;</a>
<a name="ln2393">        brow[2][col][c] = tot;</a>
<a name="ln2394">      }</a>
<a name="ln2395">    }</a>
<a name="ln2396">    if(row &gt; 3) /* Write buffer to image */</a>
<a name="ln2397">      memcpy(out + 4 * ((row - 2) * width + 2), brow[0] + 2, (size_t)(width - 4) * 4 * sizeof(*out));</a>
<a name="ln2398">    // rotate ring buffer</a>
<a name="ln2399">    for(int g = 0; g &lt; 4; g++) brow[(g - 1) &amp; 3] = brow[g];</a>
<a name="ln2400">  }</a>
<a name="ln2401">  // copy the final two rows to the image</a>
<a name="ln2402">  memcpy(out + (4 * ((height - 4) * width + 2)), brow[0] + 2, (size_t)(width - 4) * 4 * sizeof(*out));</a>
<a name="ln2403">  memcpy(out + (4 * ((height - 3) * width + 2)), brow[1] + 2, (size_t)(width - 4) * 4 * sizeof(*out));</a>
<a name="ln2404">  dt_free_align(buffer);</a>
<a name="ln2405"> </a>
<a name="ln2406">  if(filters != 9 &amp;&amp; !FILTERS_ARE_4BAYER(filters)) // x-trans or CYGM/RGBE</a>
<a name="ln2407">// for Bayer mix the two greens to make VNG4</a>
<a name="ln2408">#ifdef _OPENMP</a>
<a name="ln2409">#pragma omp parallel for default(none) shared(out) schedule(static)</a>
<a name="ln2410">#endif</a>
<a name="ln2411">    for(int i = 0; i &lt; height * width; i++) out[i * 4 + 1] = (out[i * 4 + 1] + out[i * 4 + 3]) / 2.0f;</a>
<a name="ln2412">}</a>
<a name="ln2413"> </a>
<a name="ln2414">/** 1:1 demosaic from in to out, in is full buf, out is translated/cropped (scale == 1.0!) */</a>
<a name="ln2415">static void passthrough_monochrome(float *out, const float *const in, dt_iop_roi_t *const roi_out,</a>
<a name="ln2416">                                   const dt_iop_roi_t *const roi_in)</a>
<a name="ln2417">{</a>
<a name="ln2418">  // we never want to access the input out of bounds though:</a>
<a name="ln2419">  assert(roi_in-&gt;width &gt;= roi_out-&gt;width);</a>
<a name="ln2420">  assert(roi_in-&gt;height &gt;= roi_out-&gt;height);</a>
<a name="ln2421"> </a>
<a name="ln2422">#ifdef _OPENMP</a>
<a name="ln2423">#pragma omp parallel for default(none) shared(out) schedule(static)</a>
<a name="ln2424">#endif</a>
<a name="ln2425">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln2426">  {</a>
<a name="ln2427">    for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln2428">    {</a>
<a name="ln2429">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2430">      {</a>
<a name="ln2431">        out[(size_t)4 * ((size_t)j * roi_out-&gt;width + i) + c]</a>
<a name="ln2432">            = in[(size_t)((size_t)j + roi_out-&gt;y) * roi_in-&gt;width + i + roi_out-&gt;x];</a>
<a name="ln2433">      }</a>
<a name="ln2434">    }</a>
<a name="ln2435">  }</a>
<a name="ln2436">}</a>
<a name="ln2437"> </a>
<a name="ln2438">/** 1:1 demosaic from in to out, in is full buf, out is translated/cropped (scale == 1.0!) */</a>
<a name="ln2439">static void demosaic_ppg(float *const out, const float *const in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln2440">                         const dt_iop_roi_t *const roi_in, const uint32_t filters, const float thrs)</a>
<a name="ln2441">{</a>
<a name="ln2442">  // offsets only where the buffer ends:</a>
<a name="ln2443">  const int offx = 3; // MAX(0, 3 - roi_out-&gt;x);</a>
<a name="ln2444">  const int offy = 3; // MAX(0, 3 - roi_out-&gt;y);</a>
<a name="ln2445">  const int offX = 3; // MAX(0, 3 - (roi_in-&gt;width  - (roi_out-&gt;x + roi_out-&gt;width)));</a>
<a name="ln2446">  const int offY = 3; // MAX(0, 3 - (roi_in-&gt;height - (roi_out-&gt;y + roi_out-&gt;height)));</a>
<a name="ln2447"> </a>
<a name="ln2448">  // these may differ a little, if you're unlucky enough to split a bayer block with cropping or similar.</a>
<a name="ln2449">  // we never want to access the input out of bounds though:</a>
<a name="ln2450">  assert(roi_in-&gt;width &gt;= roi_out-&gt;width);</a>
<a name="ln2451">  assert(roi_in-&gt;height &gt;= roi_out-&gt;height);</a>
<a name="ln2452">  // border interpolate</a>
<a name="ln2453">  float sum[8];</a>
<a name="ln2454">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln2455">    for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln2456">    {</a>
<a name="ln2457">      if(i == offx &amp;&amp; j &gt;= offy &amp;&amp; j &lt; roi_out-&gt;height - offY) i = roi_out-&gt;width - offX;</a>
<a name="ln2458">      if(i == roi_out-&gt;width) break;</a>
<a name="ln2459">      memset(sum, 0, sizeof(float) * 8);</a>
<a name="ln2460">      for(int y = j - 1; y != j + 2; y++)</a>
<a name="ln2461">        for(int x = i - 1; x != i + 2; x++)</a>
<a name="ln2462">        {</a>
<a name="ln2463">          const int yy = y + roi_out-&gt;y, xx = x + roi_out-&gt;x;</a>
<a name="ln2464">          if(yy &gt;= 0 &amp;&amp; xx &gt;= 0 &amp;&amp; yy &lt; roi_in-&gt;height &amp;&amp; xx &lt; roi_in-&gt;width)</a>
<a name="ln2465">          {</a>
<a name="ln2466">            int f = FC(y, x, filters);</a>
<a name="ln2467">            sum[f] += in[(size_t)yy * roi_in-&gt;width + xx];</a>
<a name="ln2468">            sum[f + 4]++;</a>
<a name="ln2469">          }</a>
<a name="ln2470">        }</a>
<a name="ln2471">      int f = FC(j, i, filters);</a>
<a name="ln2472">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2473">      {</a>
<a name="ln2474">        if(c != f &amp;&amp; sum[c + 4] &gt; 0.0f)</a>
<a name="ln2475">          out[4 * ((size_t)j * roi_out-&gt;width + i) + c] = sum[c] / sum[c + 4];</a>
<a name="ln2476">        else</a>
<a name="ln2477">          out[4 * ((size_t)j * roi_out-&gt;width + i) + c]</a>
<a name="ln2478">              = in[((size_t)j + roi_out-&gt;y) * roi_in-&gt;width + i + roi_out-&gt;x];</a>
<a name="ln2479">      }</a>
<a name="ln2480">    }</a>
<a name="ln2481">  const int median = thrs &gt; 0.0f;</a>
<a name="ln2482">  // if(median) fbdd_green(out, in, roi_out, roi_in, filters);</a>
<a name="ln2483">  const float *input = in;</a>
<a name="ln2484">  if(median)</a>
<a name="ln2485">  {</a>
<a name="ln2486">    float *med_in = (float *)dt_alloc_align(64, (size_t)roi_in-&gt;height * roi_in-&gt;width * sizeof(float));</a>
<a name="ln2487">    pre_median(med_in, in, roi_in, filters, 1, thrs);</a>
<a name="ln2488">    input = med_in;</a>
<a name="ln2489">  }</a>
<a name="ln2490">// for all pixels: interpolate green into float array, or copy color.</a>
<a name="ln2491">#ifdef _OPENMP</a>
<a name="ln2492">#pragma omp parallel for default(none) shared(input) schedule(static)</a>
<a name="ln2493">#endif</a>
<a name="ln2494">  for(int j = offy; j &lt; roi_out-&gt;height - offY; j++)</a>
<a name="ln2495">  {</a>
<a name="ln2496">    float *buf = out + (size_t)4 * roi_out-&gt;width * j + 4 * offx;</a>
<a name="ln2497">    const float *buf_in = input + (size_t)roi_in-&gt;width * (j + roi_out-&gt;y) + offx + roi_out-&gt;x;</a>
<a name="ln2498">    for(int i = offx; i &lt; roi_out-&gt;width - offX; i++)</a>
<a name="ln2499">    {</a>
<a name="ln2500">      const int c = FC(j, i, filters);</a>
<a name="ln2501">#if defined(__SSE__)</a>
<a name="ln2502">      // prefetch what we need soon (load to cpu caches)</a>
<a name="ln2503">      _mm_prefetch((char *)buf_in + 256, _MM_HINT_NTA); // TODO: try HINT_T0-3</a>
<a name="ln2504">      _mm_prefetch((char *)buf_in + roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2505">      _mm_prefetch((char *)buf_in + 2 * roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2506">      _mm_prefetch((char *)buf_in + 3 * roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2507">      _mm_prefetch((char *)buf_in - roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2508">      _mm_prefetch((char *)buf_in - 2 * roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2509">      _mm_prefetch((char *)buf_in - 3 * roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2510">#endif</a>
<a name="ln2511"> </a>
<a name="ln2512">#if defined(__SSE__)</a>
<a name="ln2513">      __m128 col = _mm_load_ps(buf);</a>
<a name="ln2514">      float *color = (float *)&amp;col;</a>
<a name="ln2515">#else</a>
<a name="ln2516">      float color[4] = { buf[0], buf[1], buf[2], buf[3] };</a>
<a name="ln2517">#endif</a>
<a name="ln2518">      const float pc = buf_in[0];</a>
<a name="ln2519">      // if(__builtin_expect(c == 0 || c == 2, 1))</a>
<a name="ln2520">      if(c == 0 || c == 2)</a>
<a name="ln2521">      {</a>
<a name="ln2522">        color[c] = pc;</a>
<a name="ln2523">        // get stuff (hopefully from cache)</a>
<a name="ln2524">        const float pym = buf_in[-roi_in-&gt;width * 1];</a>
<a name="ln2525">        const float pym2 = buf_in[-roi_in-&gt;width * 2];</a>
<a name="ln2526">        const float pym3 = buf_in[-roi_in-&gt;width * 3];</a>
<a name="ln2527">        const float pyM = buf_in[+roi_in-&gt;width * 1];</a>
<a name="ln2528">        const float pyM2 = buf_in[+roi_in-&gt;width * 2];</a>
<a name="ln2529">        const float pyM3 = buf_in[+roi_in-&gt;width * 3];</a>
<a name="ln2530">        const float pxm = buf_in[-1];</a>
<a name="ln2531">        const float pxm2 = buf_in[-2];</a>
<a name="ln2532">        const float pxm3 = buf_in[-3];</a>
<a name="ln2533">        const float pxM = buf_in[+1];</a>
<a name="ln2534">        const float pxM2 = buf_in[+2];</a>
<a name="ln2535">        const float pxM3 = buf_in[+3];</a>
<a name="ln2536"> </a>
<a name="ln2537">        const float guessx = (pxm + pc + pxM) * 2.0f - pxM2 - pxm2;</a>
<a name="ln2538">        const float diffx = (fabsf(pxm2 - pc) + fabsf(pxM2 - pc) + fabsf(pxm - pxM)) * 3.0f</a>
<a name="ln2539">                            + (fabsf(pxM3 - pxM) + fabsf(pxm3 - pxm)) * 2.0f;</a>
<a name="ln2540">        const float guessy = (pym + pc + pyM) * 2.0f - pyM2 - pym2;</a>
<a name="ln2541">        const float diffy = (fabsf(pym2 - pc) + fabsf(pyM2 - pc) + fabsf(pym - pyM)) * 3.0f</a>
<a name="ln2542">                            + (fabsf(pyM3 - pyM) + fabsf(pym3 - pym)) * 2.0f;</a>
<a name="ln2543">        if(diffx &gt; diffy)</a>
<a name="ln2544">        {</a>
<a name="ln2545">          // use guessy</a>
<a name="ln2546">          const float m = fminf(pym, pyM);</a>
<a name="ln2547">          const float M = fmaxf(pym, pyM);</a>
<a name="ln2548">          color[1] = fmaxf(fminf(guessy * .25f, M), m);</a>
<a name="ln2549">        }</a>
<a name="ln2550">        else</a>
<a name="ln2551">        {</a>
<a name="ln2552">          const float m = fminf(pxm, pxM);</a>
<a name="ln2553">          const float M = fmaxf(pxm, pxM);</a>
<a name="ln2554">          color[1] = fmaxf(fminf(guessx * .25f, M), m);</a>
<a name="ln2555">        }</a>
<a name="ln2556">      }</a>
<a name="ln2557">      else</a>
<a name="ln2558">        color[1] = pc;</a>
<a name="ln2559"> </a>
<a name="ln2560">      // write using MOVNTPS (write combine omitting caches)</a>
<a name="ln2561">      // _mm_stream_ps(buf, col);</a>
<a name="ln2562">      memcpy(buf, color, 4 * sizeof(float));</a>
<a name="ln2563">      buf += 4;</a>
<a name="ln2564">      buf_in++;</a>
<a name="ln2565">    }</a>
<a name="ln2566">  }</a>
<a name="ln2567">// SFENCE (make sure stuff is stored now)</a>
<a name="ln2568">// _mm_sfence();</a>
<a name="ln2569"> </a>
<a name="ln2570">// for all pixels: interpolate colors into float array</a>
<a name="ln2571">#ifdef _OPENMP</a>
<a name="ln2572">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln2573">#endif</a>
<a name="ln2574">  for(int j = 1; j &lt; roi_out-&gt;height - 1; j++)</a>
<a name="ln2575">  {</a>
<a name="ln2576">    float *buf = out + (size_t)4 * roi_out-&gt;width * j + 4;</a>
<a name="ln2577">    for(int i = 1; i &lt; roi_out-&gt;width - 1; i++)</a>
<a name="ln2578">    {</a>
<a name="ln2579">      // also prefetch direct nbs top/bottom</a>
<a name="ln2580">#if defined(__SSE__)</a>
<a name="ln2581">      _mm_prefetch((char *)buf + 256, _MM_HINT_NTA);</a>
<a name="ln2582">      _mm_prefetch((char *)buf - roi_out-&gt;width * 4 * sizeof(float) + 256, _MM_HINT_NTA);</a>
<a name="ln2583">      _mm_prefetch((char *)buf + roi_out-&gt;width * 4 * sizeof(float) + 256, _MM_HINT_NTA);</a>
<a name="ln2584">#endif</a>
<a name="ln2585"> </a>
<a name="ln2586">      const int c = FC(j, i, filters);</a>
<a name="ln2587">#if defined(__SSE__)</a>
<a name="ln2588">      __m128 col = _mm_load_ps(buf);</a>
<a name="ln2589">      float *color = (float *)&amp;col;</a>
<a name="ln2590">#else</a>
<a name="ln2591">      float color[4] = { buf[0], buf[1], buf[2], buf[3] };</a>
<a name="ln2592">#endif</a>
<a name="ln2593">      // fill all four pixels with correctly interpolated stuff: r/b for green1/2</a>
<a name="ln2594">      // b for r and r for b</a>
<a name="ln2595">      if(__builtin_expect(c &amp; 1, 1)) // c == 1 || c == 3)</a>
<a name="ln2596">      {</a>
<a name="ln2597">        // calculate red and blue for green pixels:</a>
<a name="ln2598">        // need 4-nbhood:</a>
<a name="ln2599">        const float *nt = buf - 4 * roi_out-&gt;width;</a>
<a name="ln2600">        const float *nb = buf + 4 * roi_out-&gt;width;</a>
<a name="ln2601">        const float *nl = buf - 4;</a>
<a name="ln2602">        const float *nr = buf + 4;</a>
<a name="ln2603">        if(FC(j, i + 1, filters) == 0) // red nb in same row</a>
<a name="ln2604">        {</a>
<a name="ln2605">          color[2] = (nt[2] + nb[2] + 2.0f * color[1] - nt[1] - nb[1]) * .5f;</a>
<a name="ln2606">          color[0] = (nl[0] + nr[0] + 2.0f * color[1] - nl[1] - nr[1]) * .5f;</a>
<a name="ln2607">        }</a>
<a name="ln2608">        else</a>
<a name="ln2609">        {</a>
<a name="ln2610">          // blue nb</a>
<a name="ln2611">          color[0] = (nt[0] + nb[0] + 2.0f * color[1] - nt[1] - nb[1]) * .5f;</a>
<a name="ln2612">          color[2] = (nl[2] + nr[2] + 2.0f * color[1] - nl[1] - nr[1]) * .5f;</a>
<a name="ln2613">        }</a>
<a name="ln2614">      }</a>
<a name="ln2615">      else</a>
<a name="ln2616">      {</a>
<a name="ln2617">        // get 4-star-nbhood:</a>
<a name="ln2618">        const float *ntl = buf - 4 - 4 * roi_out-&gt;width;</a>
<a name="ln2619">        const float *ntr = buf + 4 - 4 * roi_out-&gt;width;</a>
<a name="ln2620">        const float *nbl = buf - 4 + 4 * roi_out-&gt;width;</a>
<a name="ln2621">        const float *nbr = buf + 4 + 4 * roi_out-&gt;width;</a>
<a name="ln2622"> </a>
<a name="ln2623">        if(c == 0)</a>
<a name="ln2624">        {</a>
<a name="ln2625">          // red pixel, fill blue:</a>
<a name="ln2626">          const float diff1 = fabsf(ntl[2] - nbr[2]) + fabsf(ntl[1] - color[1]) + fabsf(nbr[1] - color[1]);</a>
<a name="ln2627">          const float guess1 = ntl[2] + nbr[2] + 2.0f * color[1] - ntl[1] - nbr[1];</a>
<a name="ln2628">          const float diff2 = fabsf(ntr[2] - nbl[2]) + fabsf(ntr[1] - color[1]) + fabsf(nbl[1] - color[1]);</a>
<a name="ln2629">          const float guess2 = ntr[2] + nbl[2] + 2.0f * color[1] - ntr[1] - nbl[1];</a>
<a name="ln2630">          if(diff1 &gt; diff2)</a>
<a name="ln2631">            color[2] = guess2 * .5f;</a>
<a name="ln2632">          else if(diff1 &lt; diff2)</a>
<a name="ln2633">            color[2] = guess1 * .5f;</a>
<a name="ln2634">          else</a>
<a name="ln2635">            color[2] = (guess1 + guess2) * .25f;</a>
<a name="ln2636">        }</a>
<a name="ln2637">        else // c == 2, blue pixel, fill red:</a>
<a name="ln2638">        {</a>
<a name="ln2639">          const float diff1 = fabsf(ntl[0] - nbr[0]) + fabsf(ntl[1] - color[1]) + fabsf(nbr[1] - color[1]);</a>
<a name="ln2640">          const float guess1 = ntl[0] + nbr[0] + 2.0f * color[1] - ntl[1] - nbr[1];</a>
<a name="ln2641">          const float diff2 = fabsf(ntr[0] - nbl[0]) + fabsf(ntr[1] - color[1]) + fabsf(nbl[1] - color[1]);</a>
<a name="ln2642">          const float guess2 = ntr[0] + nbl[0] + 2.0f * color[1] - ntr[1] - nbl[1];</a>
<a name="ln2643">          if(diff1 &gt; diff2)</a>
<a name="ln2644">            color[0] = guess2 * .5f;</a>
<a name="ln2645">          else if(diff1 &lt; diff2)</a>
<a name="ln2646">            color[0] = guess1 * .5f;</a>
<a name="ln2647">          else</a>
<a name="ln2648">            color[0] = (guess1 + guess2) * .25f;</a>
<a name="ln2649">        }</a>
<a name="ln2650">      }</a>
<a name="ln2651">      // _mm_stream_ps(buf, col);</a>
<a name="ln2652">      memcpy(buf, color, 4 * sizeof(float));</a>
<a name="ln2653">      buf += 4;</a>
<a name="ln2654">    }</a>
<a name="ln2655">  }</a>
<a name="ln2656">  // _mm_sfence();</a>
<a name="ln2657">  if(median) dt_free_align((float *)input);</a>
<a name="ln2658">}</a>
<a name="ln2659"> </a>
<a name="ln2660">void distort_mask(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln2661">                  float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2662">{</a>
<a name="ln2663">  const struct dt_interpolation *itor = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln2664">  dt_interpolation_resample_roi_1c(itor, out, roi_out, roi_out-&gt;width * sizeof(float), in, roi_in,</a>
<a name="ln2665">                                   roi_in-&gt;width * sizeof(float));</a>
<a name="ln2666">}</a>
<a name="ln2667"> </a>
<a name="ln2668">void modify_roi_out(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, dt_iop_roi_t *roi_out,</a>
<a name="ln2669">                    const dt_iop_roi_t *const roi_in)</a>
<a name="ln2670">{</a>
<a name="ln2671">  *roi_out = *roi_in;</a>
<a name="ln2672"> </a>
<a name="ln2673">  // snap to start of mosaic block:</a>
<a name="ln2674">  roi_out-&gt;x = 0; // MAX(0, roi_out-&gt;x &amp; ~1);</a>
<a name="ln2675">  roi_out-&gt;y = 0; // MAX(0, roi_out-&gt;y &amp; ~1);</a>
<a name="ln2676">}</a>
<a name="ln2677"> </a>
<a name="ln2678">// which roi input is needed to process to this output?</a>
<a name="ln2679">// roi_out is unchanged, full buffer in is full buffer out.</a>
<a name="ln2680">void modify_roi_in(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln2681">                   const dt_iop_roi_t *roi_out, dt_iop_roi_t *roi_in)</a>
<a name="ln2682">{</a>
<a name="ln2683">  // this op is disabled for preview pipe/filters == 0</a>
<a name="ln2684"> </a>
<a name="ln2685">  *roi_in = *roi_out;</a>
<a name="ln2686">  // need 1:1, demosaic and then sub-sample. or directly sample half-size</a>
<a name="ln2687">  roi_in-&gt;x /= roi_out-&gt;scale;</a>
<a name="ln2688">  roi_in-&gt;y /= roi_out-&gt;scale;</a>
<a name="ln2689">  roi_in-&gt;width /= roi_out-&gt;scale;</a>
<a name="ln2690">  roi_in-&gt;height /= roi_out-&gt;scale;</a>
<a name="ln2691">  roi_in-&gt;scale = 1.0f;</a>
<a name="ln2692">  // clamp to even x/y, to make demosaic pattern still hold..</a>
<a name="ln2693">  if(piece-&gt;pipe-&gt;dsc.filters != 9u)</a>
<a name="ln2694">  {</a>
<a name="ln2695">    roi_in-&gt;x = MAX(0, roi_in-&gt;x &amp; ~1);</a>
<a name="ln2696">    roi_in-&gt;y = MAX(0, roi_in-&gt;y &amp; ~1);</a>
<a name="ln2697">  }</a>
<a name="ln2698">  else</a>
<a name="ln2699">  {</a>
<a name="ln2700">    // Markesteijn needs factors of 3</a>
<a name="ln2701">    roi_in-&gt;x = MAX(0, roi_in-&gt;x - (roi_in-&gt;x % 3));</a>
<a name="ln2702">    roi_in-&gt;y = MAX(0, roi_in-&gt;y - (roi_in-&gt;y % 3));</a>
<a name="ln2703">  }</a>
<a name="ln2704"> </a>
<a name="ln2705">  // clamp numeric inaccuracies to full buffer, to avoid scaling/copying in pixelpipe:</a>
<a name="ln2706">  if(abs(piece-&gt;pipe-&gt;image.width - roi_in-&gt;width) &lt; MAX(ceilf(1.0f / roi_out-&gt;scale), 10))</a>
<a name="ln2707">    roi_in-&gt;width = piece-&gt;pipe-&gt;image.width;</a>
<a name="ln2708"> </a>
<a name="ln2709">  if(abs(piece-&gt;pipe-&gt;image.height - roi_in-&gt;height) &lt; MAX(ceilf(1.0f / roi_out-&gt;scale), 10))</a>
<a name="ln2710">    roi_in-&gt;height = piece-&gt;pipe-&gt;image.height;</a>
<a name="ln2711">}</a>
<a name="ln2712"> </a>
<a name="ln2713">static int get_quality()</a>
<a name="ln2714">{</a>
<a name="ln2715">  int qual = 1;</a>
<a name="ln2716">  gchar *quality = dt_conf_get_string(&quot;plugins/darkroom/demosaic/quality&quot;);</a>
<a name="ln2717">  if(quality)</a>
<a name="ln2718">  {</a>
<a name="ln2719">    if(!strcmp(quality, &quot;always bilinear (fast)&quot;))</a>
<a name="ln2720">      qual = 0;</a>
<a name="ln2721">    else if(!strcmp(quality, &quot;full (possibly slow)&quot;))</a>
<a name="ln2722">      qual = 2;</a>
<a name="ln2723">    g_free(quality);</a>
<a name="ln2724">  }</a>
<a name="ln2725">  return qual;</a>
<a name="ln2726">}</a>
<a name="ln2727"> </a>
<a name="ln2728">static int get_thumb_quality(int width, int height)</a>
<a name="ln2729">{</a>
<a name="ln2730">  // we check if we need ultra-high quality thumbnail for this size</a>
<a name="ln2731">  char *min = dt_conf_get_string(&quot;plugins/lighttable/thumbnail_hq_min_level&quot;);</a>
<a name="ln2732"> </a>
<a name="ln2733">  int level = dt_mipmap_cache_get_matching_size(darktable.mipmap_cache, width, height);</a>
<a name="ln2734">  int res = 0;</a>
<a name="ln2735">  if (strcmp(min, &quot;always&quot;)==0) res = 1;</a>
<a name="ln2736">  else if (strcmp(min, &quot;small&quot;)==0) res = ( level &gt;= 1 );</a>
<a name="ln2737">  else if (strcmp(min, &quot;VGA&quot;)==0) res = ( level &gt;= 2 );</a>
<a name="ln2738">  else if (strcmp(min, &quot;720p&quot;)==0) res = ( level &gt;= 3 );</a>
<a name="ln2739">  else if (strcmp(min, &quot;1080p&quot;)==0) res = ( level &gt;= 4 );</a>
<a name="ln2740">  else if (strcmp(min, &quot;WQXGA&quot;)==0) res = ( level &gt;= 5 );</a>
<a name="ln2741">  else if (strcmp(min, &quot;4k&quot;)==0) res = ( level &gt;= 6 );</a>
<a name="ln2742">  else if (strcmp(min, &quot;5K&quot;)==0) res = ( level &gt;= 7 );</a>
<a name="ln2743"> </a>
<a name="ln2744">  g_free(min);</a>
<a name="ln2745">  return res;</a>
<a name="ln2746">}</a>
<a name="ln2747"> </a>
<a name="ln2748">// set flags for demosaic quality based on factors besides demosaic</a>
<a name="ln2749">// method (e.g. config, scale, pixelpipe type)</a>
<a name="ln2750">static int demosaic_qual_flags(const dt_dev_pixelpipe_iop_t *const piece,</a>
<a name="ln2751">                               const dt_image_t *const img,</a>
<a name="ln2752">                               const dt_iop_roi_t *const roi_out)</a>
<a name="ln2753">{</a>
<a name="ln2754">  int flags = 0;</a>
<a name="ln2755">  switch (piece-&gt;pipe-&gt;type)</a>
<a name="ln2756">  {</a>
<a name="ln2757">    case DT_DEV_PIXELPIPE_FULL:</a>
<a name="ln2758">      {</a>
<a name="ln2759">        const int qual = get_quality();</a>
<a name="ln2760">        if (qual &gt; 0) flags |= DEMOSAIC_FULL_SCALE;</a>
<a name="ln2761">        if (qual &gt; 1) flags |= DEMOSAIC_XTRANS_FULL;</a>
<a name="ln2762">        if ((qual &lt; 2) &amp;&amp; (roi_out-&gt;scale &lt;= .99999f))</a>
<a name="ln2763">          flags |= DEMOSAIC_MEDIUM_QUAL;</a>
<a name="ln2764">      }</a>
<a name="ln2765">      break;</a>
<a name="ln2766">    case DT_DEV_PIXELPIPE_EXPORT:</a>
<a name="ln2767">      flags |= DEMOSAIC_FULL_SCALE | DEMOSAIC_XTRANS_FULL;</a>
<a name="ln2768">      break;</a>
<a name="ln2769">    case DT_DEV_PIXELPIPE_THUMBNAIL:</a>
<a name="ln2770">      // we check if we need ultra-high quality thumbnail for this size</a>
<a name="ln2771">      if (get_thumb_quality(roi_out-&gt;width, roi_out-&gt;height))</a>
<a name="ln2772">      {</a>
<a name="ln2773">        flags |= DEMOSAIC_FULL_SCALE | DEMOSAIC_XTRANS_FULL;</a>
<a name="ln2774">      }</a>
<a name="ln2775">      break;</a>
<a name="ln2776">    default: // make C not complain about missing enum members</a>
<a name="ln2777">      break;</a>
<a name="ln2778">  }</a>
<a name="ln2779"> </a>
<a name="ln2780">  // For suficiently small scaling, one or more repetitition of the</a>
<a name="ln2781">  // CFA pattern can be merged into a single pixel, hence it is</a>
<a name="ln2782">  // possible to skip the full demosaic and perform a quick downscale.</a>
<a name="ln2783">  // Note even though the X-Trans CFA is 6x6, for this purposes we can</a>
<a name="ln2784">  // see each 6x6 tile as four fairly similar 3x3 tiles</a>
<a name="ln2785">  if (roi_out-&gt;scale &gt; (piece-&gt;pipe-&gt;dsc.filters == 9u ? 0.333f : 0.5f))</a>
<a name="ln2786">  {</a>
<a name="ln2787">    flags |= DEMOSAIC_FULL_SCALE;</a>
<a name="ln2788">  }</a>
<a name="ln2789">  // half_size_f doesn't support 4bayer images</a>
<a name="ln2790">  if (img-&gt;flags &amp; DT_IMAGE_4BAYER) flags |= DEMOSAIC_FULL_SCALE;</a>
<a name="ln2791">  // we use full Markesteijn demosaicing on xtrans sensors if maximum</a>
<a name="ln2792">  // quality is required</a>
<a name="ln2793">  if (roi_out-&gt;scale &gt; 0.667f)</a>
<a name="ln2794">  {</a>
<a name="ln2795">    flags |= DEMOSAIC_XTRANS_FULL;</a>
<a name="ln2796">  }</a>
<a name="ln2797"> </a>
<a name="ln2798">  // we check if we can stop at the linear interpolation step in VNG</a>
<a name="ln2799">  // instead of going the full way</a>
<a name="ln2800">  if ((flags &amp; DEMOSAIC_FULL_SCALE) &amp;&amp;</a>
<a name="ln2801">      (roi_out-&gt;scale &lt; (piece-&gt;pipe-&gt;dsc.filters == 9u ? 0.5f : 0.667f)))</a>
<a name="ln2802">  {</a>
<a name="ln2803">    flags |= DEMOSAIC_ONLY_VNG_LINEAR;</a>
<a name="ln2804">  }</a>
<a name="ln2805"> </a>
<a name="ln2806">  return flags;</a>
<a name="ln2807">}</a>
<a name="ln2808"> </a>
<a name="ln2809">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o,</a>
<a name="ln2810">             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2811">{</a>
<a name="ln2812">  const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln2813">  const float threshold = 0.0001f * img-&gt;exif_iso;</a>
<a name="ln2814"> </a>
<a name="ln2815">  dt_iop_roi_t roi = *roi_in;</a>
<a name="ln2816">  dt_iop_roi_t roo = *roi_out;</a>
<a name="ln2817">  roo.x = roo.y = 0;</a>
<a name="ln2818">  // roi_out-&gt;scale = global scale: (iscale == 1.0, always when demosaic is on)</a>
<a name="ln2819"> </a>
<a name="ln2820">  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece-&gt;pipe-&gt;dsc.xtrans;</a>
<a name="ln2821"> </a>
<a name="ln2822">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln2823"> </a>
<a name="ln2824">  const int qual_flags = demosaic_qual_flags(piece, img, roi_out);</a>
<a name="ln2825">  int demosaicing_method = data-&gt;demosaicing_method;</a>
<a name="ln2826">  if((qual_flags &amp; DEMOSAIC_MEDIUM_QUAL)</a>
<a name="ln2827">     &amp;&amp; // only overwrite setting if quality &lt;&lt; requested and in dr mode</a>
<a name="ln2828">     (demosaicing_method != DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)) // do not touch this special method</a>
<a name="ln2829">    demosaicing_method = (piece-&gt;pipe-&gt;dsc.filters != 9u) ? DT_IOP_DEMOSAIC_PPG : DT_IOP_DEMOSAIC_MARKESTEIJN;</a>
<a name="ln2830"> </a>
<a name="ln2831">  const float *const pixels = (float *)i;</a>
<a name="ln2832"> </a>
<a name="ln2833">  if(qual_flags &amp; DEMOSAIC_FULL_SCALE)</a>
<a name="ln2834">  {</a>
<a name="ln2835">    // Full demosaic and then scaling if needed</a>
<a name="ln2836">    const int scaled = (roi_out-&gt;width != roi_in-&gt;width || roi_out-&gt;height != roi_in-&gt;height);</a>
<a name="ln2837">    float *tmp = (float *) o;</a>
<a name="ln2838">    if(scaled)</a>
<a name="ln2839">    {</a>
<a name="ln2840">      // demosaic and then clip and zoom</a>
<a name="ln2841">      // we demosaic at 1:1 the size of input roi, so make sure</a>
<a name="ln2842">      // we fit these bounds exactly, to avoid crashes..</a>
<a name="ln2843">      roo.width = roi_in-&gt;width;</a>
<a name="ln2844">      roo.height = roi_in-&gt;height;</a>
<a name="ln2845">      roo.scale = 1.0f;</a>
<a name="ln2846">      tmp = (float *)dt_alloc_align(64, (size_t)roo.width * roo.height * 4 * sizeof(float));</a>
<a name="ln2847">    }</a>
<a name="ln2848"> </a>
<a name="ln2849">    if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln2850">    {</a>
<a name="ln2851">      passthrough_monochrome(tmp, pixels, &amp;roo, &amp;roi);</a>
<a name="ln2852">    }</a>
<a name="ln2853">    else if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln2854">    {</a>
<a name="ln2855">      if(demosaicing_method == DT_IOP_DEMOSAIC_FDC &amp;&amp; (qual_flags &amp; DEMOSAIC_XTRANS_FULL))</a>
<a name="ln2856">        xtrans_fdc_interpolate(self, tmp, pixels, &amp;roo, &amp;roi, xtrans);</a>
<a name="ln2857">      else if(demosaicing_method &gt;= DT_IOP_DEMOSAIC_MARKESTEIJN &amp;&amp; (qual_flags &amp; DEMOSAIC_XTRANS_FULL))</a>
<a name="ln2858">        xtrans_markesteijn_interpolate(tmp, pixels, &amp;roo, &amp;roi, xtrans,</a>
<a name="ln2859">                                       1 + (demosaicing_method - DT_IOP_DEMOSAIC_MARKESTEIJN) * 2);</a>
<a name="ln2860">      else</a>
<a name="ln2861">        vng_interpolate(tmp, pixels, &amp;roo, &amp;roi, piece-&gt;pipe-&gt;dsc.filters, xtrans, qual_flags &amp; DEMOSAIC_ONLY_VNG_LINEAR);</a>
<a name="ln2862">    }</a>
<a name="ln2863">    else</a>
<a name="ln2864">    {</a>
<a name="ln2865">      float *in = (float *)pixels;</a>
<a name="ln2866">      float *aux;</a>
<a name="ln2867"> </a>
<a name="ln2868">      if(!(img-&gt;flags &amp; DT_IMAGE_4BAYER) &amp;&amp; data-&gt;green_eq != DT_IOP_GREEN_EQ_NO)</a>
<a name="ln2869">      {</a>
<a name="ln2870">        in = (float *)dt_alloc_align(64, (size_t)roi_in-&gt;height * roi_in-&gt;width * sizeof(float));</a>
<a name="ln2871">        switch(data-&gt;green_eq)</a>
<a name="ln2872">        {</a>
<a name="ln2873">          case DT_IOP_GREEN_EQ_FULL:</a>
<a name="ln2874">            green_equilibration_favg(in, pixels, roi_in-&gt;width, roi_in-&gt;height, piece-&gt;pipe-&gt;dsc.filters,</a>
<a name="ln2875">                                     roi_in-&gt;x, roi_in-&gt;y);</a>
<a name="ln2876">            break;</a>
<a name="ln2877">          case DT_IOP_GREEN_EQ_LOCAL:</a>
<a name="ln2878">            green_equilibration_lavg(in, pixels, roi_in-&gt;width, roi_in-&gt;height, piece-&gt;pipe-&gt;dsc.filters,</a>
<a name="ln2879">                                     roi_in-&gt;x, roi_in-&gt;y, threshold);</a>
<a name="ln2880">            break;</a>
<a name="ln2881">          case DT_IOP_GREEN_EQ_BOTH:</a>
<a name="ln2882">            aux = dt_alloc_align(64, (size_t)roi_in-&gt;height * roi_in-&gt;width * sizeof(float));</a>
<a name="ln2883">            green_equilibration_favg(aux, pixels, roi_in-&gt;width, roi_in-&gt;height, piece-&gt;pipe-&gt;dsc.filters,</a>
<a name="ln2884">                                     roi_in-&gt;x, roi_in-&gt;y);</a>
<a name="ln2885">            green_equilibration_lavg(in, aux, roi_in-&gt;width, roi_in-&gt;height, piece-&gt;pipe-&gt;dsc.filters, roi_in-&gt;x,</a>
<a name="ln2886">                                     roi_in-&gt;y, threshold);</a>
<a name="ln2887">            dt_free_align(aux);</a>
<a name="ln2888">            break;</a>
<a name="ln2889">        }</a>
<a name="ln2890">      }</a>
<a name="ln2891"> </a>
<a name="ln2892">      if(demosaicing_method == DT_IOP_DEMOSAIC_VNG4 || (img-&gt;flags &amp; DT_IMAGE_4BAYER))</a>
<a name="ln2893">      {</a>
<a name="ln2894">        vng_interpolate(tmp, in, &amp;roo, &amp;roi, piece-&gt;pipe-&gt;dsc.filters, xtrans, qual_flags &amp; DEMOSAIC_ONLY_VNG_LINEAR);</a>
<a name="ln2895">        if (img-&gt;flags &amp; DT_IMAGE_4BAYER)</a>
<a name="ln2896">        {</a>
<a name="ln2897">          dt_colorspaces_cygm_to_rgb(tmp, roo.width*roo.height, data-&gt;CAM_to_RGB);</a>
<a name="ln2898">          dt_colorspaces_cygm_to_rgb(piece-&gt;pipe-&gt;dsc.processed_maximum, 1, data-&gt;CAM_to_RGB);</a>
<a name="ln2899">        }</a>
<a name="ln2900">      }</a>
<a name="ln2901">      else if(demosaicing_method != DT_IOP_DEMOSAIC_AMAZE)</a>
<a name="ln2902">        demosaic_ppg(tmp, in, &amp;roo, &amp;roi, piece-&gt;pipe-&gt;dsc.filters,</a>
<a name="ln2903">                     data-&gt;median_thrs); // wanted ppg or zoomed out a lot and quality is limited to 1</a>
<a name="ln2904">      else</a>
<a name="ln2905">        amaze_demosaic_RT(self, piece, in, tmp, &amp;roi, &amp;roo, piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln2906"> </a>
<a name="ln2907">      if(!(img-&gt;flags &amp; DT_IMAGE_4BAYER) &amp;&amp; data-&gt;green_eq != DT_IOP_GREEN_EQ_NO) dt_free_align(in);</a>
<a name="ln2908">    }</a>
<a name="ln2909"> </a>
<a name="ln2910">    if(scaled)</a>
<a name="ln2911">    {</a>
<a name="ln2912">      roi = *roi_out;</a>
<a name="ln2913">      dt_iop_clip_and_zoom_roi((float *)o, tmp, &amp;roi, &amp;roo, roi.width, roo.width);</a>
<a name="ln2914">      dt_free_align(tmp);</a>
<a name="ln2915">    }</a>
<a name="ln2916">  }</a>
<a name="ln2917">  else</a>
<a name="ln2918">  {</a>
<a name="ln2919">    if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln2920">      dt_iop_clip_and_zoom_demosaic_passthrough_monochrome_f((float *)o, pixels, &amp;roo, &amp;roi, roo.width, roi.width);</a>
<a name="ln2921">    else // sample half-size raw (Bayer) or 1/3-size raw (X-Trans)</a>
<a name="ln2922">        if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln2923">      dt_iop_clip_and_zoom_demosaic_third_size_xtrans_f((float *)o, pixels, &amp;roo, &amp;roi, roo.width, roi.width,</a>
<a name="ln2924">                                                        xtrans);</a>
<a name="ln2925">    else</a>
<a name="ln2926">      dt_iop_clip_and_zoom_demosaic_half_size_f((float *)o, pixels, &amp;roo, &amp;roi, roo.width, roi.width,</a>
<a name="ln2927">                                                piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln2928">  }</a>
<a name="ln2929">  if(data-&gt;color_smoothing) color_smoothing(o, roi_out, data-&gt;color_smoothing);</a>
<a name="ln2930">}</a>
<a name="ln2931"> </a>
<a name="ln2932">#ifdef HAVE_OPENCL</a>
<a name="ln2933">// color smoothing step by multiple passes of median filtering</a>
<a name="ln2934">static int color_smoothing_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln2935">                              cl_mem dev_out, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2936">{</a>
<a name="ln2937">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln2938">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;data;</a>
<a name="ln2939"> </a>
<a name="ln2940">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln2941">  const int width = roi_out-&gt;width;</a>
<a name="ln2942">  const int height = roi_out-&gt;height;</a>
<a name="ln2943"> </a>
<a name="ln2944">  cl_int err = -999;</a>
<a name="ln2945"> </a>
<a name="ln2946">  cl_mem dev_tmp = dt_opencl_alloc_device(devid, width, height, 4 * sizeof(float));</a>
<a name="ln2947">  if(dev_tmp == NULL) goto error;</a>
<a name="ln2948"> </a>
<a name="ln2949">  dt_opencl_local_buffer_t locopt</a>
<a name="ln2950">    = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln2951">                                  .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln2952">                                  .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln2953"> </a>
<a name="ln2954">  if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_color_smoothing, &amp;locopt))</a>
<a name="ln2955">    goto error;</a>
<a name="ln2956"> </a>
<a name="ln2957">  // two buffer references for our ping-pong</a>
<a name="ln2958">  cl_mem dev_t1 = dev_out;</a>
<a name="ln2959">  cl_mem dev_t2 = dev_tmp;</a>
<a name="ln2960"> </a>
<a name="ln2961">  for(int pass = 0; pass &lt; data-&gt;color_smoothing; pass++)</a>
<a name="ln2962">  {</a>
<a name="ln2963">    size_t sizes[] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln2964">    size_t local[] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln2965">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 0, sizeof(cl_mem), &amp;dev_t1);</a>
<a name="ln2966">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 1, sizeof(cl_mem), &amp;dev_t2);</a>
<a name="ln2967">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 2, sizeof(int), &amp;width);</a>
<a name="ln2968">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 3, sizeof(int), &amp;height);</a>
<a name="ln2969">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 4,</a>
<a name="ln2970">                               (locopt.sizex + 2) * (locopt.sizey + 2) * 4 * sizeof(float), NULL);</a>
<a name="ln2971">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_color_smoothing, sizes, local);</a>
<a name="ln2972">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2973"> </a>
<a name="ln2974">    // swap dev_t1 and dev_t2</a>
<a name="ln2975">    cl_mem t = dev_t1;</a>
<a name="ln2976">    dev_t1 = dev_t2;</a>
<a name="ln2977">    dev_t2 = t;</a>
<a name="ln2978">  }</a>
<a name="ln2979"> </a>
<a name="ln2980">  // after last step we find final output in dev_t1.</a>
<a name="ln2981">  // let's see if this is in dev_tmp1 and needs to be copied to dev_out</a>
<a name="ln2982">  if(dev_t1 == dev_tmp)</a>
<a name="ln2983">  {</a>
<a name="ln2984">    // copy data from dev_tmp -&gt; dev_out</a>
<a name="ln2985">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln2986">    size_t region[] = { width, height, 1 };</a>
<a name="ln2987">    err = dt_opencl_enqueue_copy_image(devid, dev_tmp, dev_out, origin, origin, region);</a>
<a name="ln2988">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2989">  }</a>
<a name="ln2990"> </a>
<a name="ln2991">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln2992">  return TRUE;</a>
<a name="ln2993"> </a>
<a name="ln2994">error:</a>
<a name="ln2995">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln2996">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic_color_smoothing] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln2997">  return FALSE;</a>
<a name="ln2998">}</a>
<a name="ln2999"> </a>
<a name="ln3000">static int green_equilibration_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln3001">                                  cl_mem dev_out, const dt_iop_roi_t *const roi_in)</a>
<a name="ln3002">{</a>
<a name="ln3003">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln3004">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;data;</a>
<a name="ln3005"> </a>
<a name="ln3006">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3007">  const int width = roi_in-&gt;width;</a>
<a name="ln3008">  const int height = roi_in-&gt;height;</a>
<a name="ln3009"> </a>
<a name="ln3010">  cl_mem dev_tmp = NULL;</a>
<a name="ln3011">  cl_mem dev_m = NULL;</a>
<a name="ln3012">  cl_mem dev_r = NULL;</a>
<a name="ln3013">  cl_mem dev_in1 = NULL;</a>
<a name="ln3014">  cl_mem dev_out1 = NULL;</a>
<a name="ln3015">  cl_mem dev_in2 = NULL;</a>
<a name="ln3016">  cl_mem dev_out2 = NULL;</a>
<a name="ln3017">  float *sumsum = NULL;</a>
<a name="ln3018"> </a>
<a name="ln3019">  cl_int err = -999;</a>
<a name="ln3020"> </a>
<a name="ln3021">  if(data-&gt;green_eq == DT_IOP_GREEN_EQ_BOTH)</a>
<a name="ln3022">  {</a>
<a name="ln3023">    dev_tmp = dt_opencl_alloc_device(devid, width, height, sizeof(float));</a>
<a name="ln3024">    if(dev_tmp == NULL) goto error;</a>
<a name="ln3025">  }</a>
<a name="ln3026"> </a>
<a name="ln3027">  switch(data-&gt;green_eq)</a>
<a name="ln3028">  {</a>
<a name="ln3029">    case DT_IOP_GREEN_EQ_FULL:</a>
<a name="ln3030">      dev_in1 = dev_in;</a>
<a name="ln3031">      dev_out1 = dev_out;</a>
<a name="ln3032">      break;</a>
<a name="ln3033">    case DT_IOP_GREEN_EQ_LOCAL:</a>
<a name="ln3034">      dev_in2 = dev_in;</a>
<a name="ln3035">      dev_out2 = dev_out;</a>
<a name="ln3036">      break;</a>
<a name="ln3037">    case DT_IOP_GREEN_EQ_BOTH:</a>
<a name="ln3038">      dev_in1 = dev_in;</a>
<a name="ln3039">      dev_out1 = dev_tmp;</a>
<a name="ln3040">      dev_in2 = dev_tmp;</a>
<a name="ln3041">      dev_out2 = dev_out;</a>
<a name="ln3042">      break;</a>
<a name="ln3043">    case DT_IOP_GREEN_EQ_NO:</a>
<a name="ln3044">    default:</a>
<a name="ln3045">      goto error;</a>
<a name="ln3046">  }</a>
<a name="ln3047"> </a>
<a name="ln3048">  if(data-&gt;green_eq == DT_IOP_GREEN_EQ_FULL || data-&gt;green_eq == DT_IOP_GREEN_EQ_BOTH)</a>
<a name="ln3049">  {</a>
<a name="ln3050">    dt_opencl_local_buffer_t flocopt</a>
<a name="ln3051">      = (dt_opencl_local_buffer_t){ .xoffset = 0, .xfactor = 1, .yoffset = 0, .yfactor = 1,</a>
<a name="ln3052">                                    .cellsize = 2 * sizeof(float), .overhead = 0,</a>
<a name="ln3053">                                    .sizex = 1 &lt;&lt; 4, .sizey = 1 &lt;&lt; 4 };</a>
<a name="ln3054"> </a>
<a name="ln3055">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_green_eq_favg_reduce_first, &amp;flocopt))</a>
<a name="ln3056">      goto error;</a>
<a name="ln3057"> </a>
<a name="ln3058">    const size_t bwidth = ROUNDUP(width, flocopt.sizex);</a>
<a name="ln3059">    const size_t bheight = ROUNDUP(height, flocopt.sizey);</a>
<a name="ln3060"> </a>
<a name="ln3061">    const int bufsize = (bwidth / flocopt.sizex) * (bheight / flocopt.sizey);</a>
<a name="ln3062"> </a>
<a name="ln3063">    dev_m = dt_opencl_alloc_device_buffer(devid, (size_t)bufsize * 2 * sizeof(float));</a>
<a name="ln3064">    if(dev_m == NULL) goto error;</a>
<a name="ln3065"> </a>
<a name="ln3066">    size_t fsizes[3] = { bwidth, bheight, 1 };</a>
<a name="ln3067">    size_t flocal[3] = { flocopt.sizex, flocopt.sizey, 1 };</a>
<a name="ln3068">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 0, sizeof(cl_mem), &amp;dev_in1);</a>
<a name="ln3069">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 1, sizeof(int), &amp;width);</a>
<a name="ln3070">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 2, sizeof(int), &amp;height);</a>
<a name="ln3071">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 3, sizeof(cl_mem), &amp;dev_m);</a>
<a name="ln3072">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 4, sizeof(uint32_t), (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3073">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 5, sizeof(int), &amp;roi_in-&gt;x);</a>
<a name="ln3074">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 6, sizeof(int), &amp;roi_in-&gt;y);</a>
<a name="ln3075">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 7,</a>
<a name="ln3076">                             flocopt.sizex * flocopt.sizey * 2 * sizeof(float), NULL);</a>
<a name="ln3077">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_green_eq_favg_reduce_first, fsizes,</a>
<a name="ln3078">                                                 flocal);</a>
<a name="ln3079">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3080"> </a>
<a name="ln3081">    dt_opencl_local_buffer_t slocopt</a>
<a name="ln3082">      = (dt_opencl_local_buffer_t){ .xoffset = 0, .xfactor = 1, .yoffset = 0, .yfactor = 1,</a>
<a name="ln3083">                                    .cellsize = 2 * sizeof(float), .overhead = 0,</a>
<a name="ln3084">                                    .sizex = 1 &lt;&lt; 16, .sizey = 1 };</a>
<a name="ln3085"> </a>
<a name="ln3086">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_green_eq_favg_reduce_second, &amp;slocopt))</a>
<a name="ln3087">      goto error;</a>
<a name="ln3088"> </a>
<a name="ln3089">    const int reducesize = MIN(REDUCESIZE, ROUNDUP(bufsize, slocopt.sizex) / slocopt.sizex);</a>
<a name="ln3090"> </a>
<a name="ln3091">    dev_r = dt_opencl_alloc_device_buffer(devid, (size_t)reducesize * 2 * sizeof(float));</a>
<a name="ln3092">    if(dev_r == NULL) goto error;</a>
<a name="ln3093"> </a>
<a name="ln3094">    size_t ssizes[3] = { reducesize * slocopt.sizex, 1, 1 };</a>
<a name="ln3095">    size_t slocal[3] = { slocopt.sizex, 1, 1 };</a>
<a name="ln3096">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_second, 0, sizeof(cl_mem), &amp;dev_m);</a>
<a name="ln3097">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_second, 1, sizeof(cl_mem), &amp;dev_r);</a>
<a name="ln3098">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_second, 2, sizeof(int), &amp;bufsize);</a>
<a name="ln3099">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_second, 3, slocopt.sizex * 2 * sizeof(float), NULL);</a>
<a name="ln3100">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_green_eq_favg_reduce_second, ssizes,</a>
<a name="ln3101">                                                 slocal);</a>
<a name="ln3102">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3103"> </a>
<a name="ln3104">    sumsum = dt_alloc_align(64, (size_t)reducesize * 2 * sizeof(float));</a>
<a name="ln3105">    if(sumsum == NULL) goto error;</a>
<a name="ln3106">    err = dt_opencl_read_buffer_from_device(devid, (void *)sumsum, dev_r, 0,</a>
<a name="ln3107">                                            (size_t)reducesize * 2 * sizeof(float), CL_TRUE);</a>
<a name="ln3108">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3109"> </a>
<a name="ln3110">    float sum1 = 0.0f, sum2 = 0.0f;</a>
<a name="ln3111">    for(int k = 0; k &lt; reducesize; k++)</a>
<a name="ln3112">    {</a>
<a name="ln3113">      sum1 += sumsum[2 * k];</a>
<a name="ln3114">      sum2 += sumsum[2 * k + 1];</a>
<a name="ln3115">    }</a>
<a name="ln3116"> </a>
<a name="ln3117">    const float gr_ratio = (sum1 &gt; 0.0f &amp;&amp; sum2 &gt; 0.0f) ? sum2 / sum1 : 1.0f;</a>
<a name="ln3118"> </a>
<a name="ln3119">    size_t asizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3120">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 0, sizeof(cl_mem), &amp;dev_in1);</a>
<a name="ln3121">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 1, sizeof(cl_mem), &amp;dev_out1);</a>
<a name="ln3122">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 2, sizeof(int), &amp;width);</a>
<a name="ln3123">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 3, sizeof(int), &amp;height);</a>
<a name="ln3124">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 4, sizeof(uint32_t), (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3125">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 5, sizeof(int), &amp;roi_in-&gt;x);</a>
<a name="ln3126">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 6, sizeof(int), &amp;roi_in-&gt;y);</a>
<a name="ln3127">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 7, sizeof(float), &amp;gr_ratio);</a>
<a name="ln3128">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_green_eq_favg_apply, asizes);</a>
<a name="ln3129">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3130">  }</a>
<a name="ln3131"> </a>
<a name="ln3132">  if(data-&gt;green_eq == DT_IOP_GREEN_EQ_LOCAL || data-&gt;green_eq == DT_IOP_GREEN_EQ_BOTH)</a>
<a name="ln3133">  {</a>
<a name="ln3134">    const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln3135">    const float threshold = 0.0001f * img-&gt;exif_iso;</a>
<a name="ln3136"> </a>
<a name="ln3137">    dt_opencl_local_buffer_t locopt</a>
<a name="ln3138">      = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln3139">                                    .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3140">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3141"> </a>
<a name="ln3142">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_green_eq_lavg, &amp;locopt))</a>
<a name="ln3143">      goto error;</a>
<a name="ln3144"> </a>
<a name="ln3145">    size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3146">    size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3147">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 0, sizeof(cl_mem), &amp;dev_in2);</a>
<a name="ln3148">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 1, sizeof(cl_mem), &amp;dev_out2);</a>
<a name="ln3149">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 2, sizeof(int), &amp;width);</a>
<a name="ln3150">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 3, sizeof(int), &amp;height);</a>
<a name="ln3151">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 4, sizeof(uint32_t), (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3152">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 5, sizeof(int), &amp;roi_in-&gt;x);</a>
<a name="ln3153">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 6, sizeof(int), &amp;roi_in-&gt;y);</a>
<a name="ln3154">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 7, sizeof(float), (void *)&amp;threshold);</a>
<a name="ln3155">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 8,</a>
<a name="ln3156">                           (locopt.sizex + 4) * (locopt.sizey + 4) * sizeof(float), NULL);</a>
<a name="ln3157">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_green_eq_lavg, sizes, local);</a>
<a name="ln3158">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3159">  }</a>
<a name="ln3160"> </a>
<a name="ln3161">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3162">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln3163">  dt_opencl_release_mem_object(dev_r);</a>
<a name="ln3164">  dt_free_align(sumsum);</a>
<a name="ln3165">  return TRUE;</a>
<a name="ln3166"> </a>
<a name="ln3167">error:</a>
<a name="ln3168">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3169">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln3170">  dt_opencl_release_mem_object(dev_r);</a>
<a name="ln3171">  dt_free_align(sumsum);</a>
<a name="ln3172">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic_green_equilibration] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3173">  return FALSE;</a>
<a name="ln3174">}</a>
<a name="ln3175"> </a>
<a name="ln3176"> </a>
<a name="ln3177">static int process_default_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln3178">                              cl_mem dev_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln3179">                              const dt_iop_roi_t *const roi_out)</a>
<a name="ln3180">{</a>
<a name="ln3181">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln3182">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;data;</a>
<a name="ln3183">  const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln3184"> </a>
<a name="ln3185">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3186">  const int qual_flags = demosaic_qual_flags(piece, img, roi_out);</a>
<a name="ln3187">  const int demosaicing_method = data-&gt;demosaicing_method;</a>
<a name="ln3188"> </a>
<a name="ln3189">  cl_mem dev_aux = NULL;</a>
<a name="ln3190">  cl_mem dev_tmp = NULL;</a>
<a name="ln3191">  cl_mem dev_green_eq = NULL;</a>
<a name="ln3192">  cl_int err = -999;</a>
<a name="ln3193"> </a>
<a name="ln3194"> </a>
<a name="ln3195">  if(qual_flags &amp; DEMOSAIC_FULL_SCALE)</a>
<a name="ln3196">  {</a>
<a name="ln3197">    // Full demosaic and then scaling if needed</a>
<a name="ln3198">    const int scaled = (roi_out-&gt;width != roi_in-&gt;width || roi_out-&gt;height != roi_in-&gt;height);</a>
<a name="ln3199"> </a>
<a name="ln3200">    int width = roi_out-&gt;width;</a>
<a name="ln3201">    int height = roi_out-&gt;height;</a>
<a name="ln3202"> </a>
<a name="ln3203">    // green equilibration</a>
<a name="ln3204">    if(data-&gt;green_eq != DT_IOP_GREEN_EQ_NO)</a>
<a name="ln3205">    {</a>
<a name="ln3206">      dev_green_eq = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, sizeof(float));</a>
<a name="ln3207">      if(dev_green_eq == NULL) goto error;</a>
<a name="ln3208"> </a>
<a name="ln3209">      if(!green_equilibration_cl(self, piece, dev_in, dev_green_eq, roi_in))</a>
<a name="ln3210">        goto error;</a>
<a name="ln3211"> </a>
<a name="ln3212">      dev_in = dev_green_eq;</a>
<a name="ln3213">    }</a>
<a name="ln3214"> </a>
<a name="ln3215">    // need to reserve scaled auxiliary buffer or use dev_out</a>
<a name="ln3216">    if(scaled)</a>
<a name="ln3217">    {</a>
<a name="ln3218">      dev_aux = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, 4 * sizeof(float));</a>
<a name="ln3219">      if(dev_aux == NULL) goto error;</a>
<a name="ln3220">      width = roi_in-&gt;width;</a>
<a name="ln3221">      height = roi_in-&gt;height;</a>
<a name="ln3222">    }</a>
<a name="ln3223">    else</a>
<a name="ln3224">      dev_aux = dev_out;</a>
<a name="ln3225"> </a>
<a name="ln3226">    if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln3227">    {</a>
<a name="ln3228">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3229">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_passthrough_monochrome, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln3230">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_passthrough_monochrome, 1, sizeof(cl_mem), &amp;dev_aux);</a>
<a name="ln3231">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_passthrough_monochrome, 2, sizeof(int), &amp;width);</a>
<a name="ln3232">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_passthrough_monochrome, 3, sizeof(int), &amp;height);</a>
<a name="ln3233">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_passthrough_monochrome, sizes);</a>
<a name="ln3234">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3235">    }</a>
<a name="ln3236">    else if(demosaicing_method == DT_IOP_DEMOSAIC_PPG)</a>
<a name="ln3237">    {</a>
<a name="ln3238">      if(data-&gt;median_thrs &gt; 0.0f)</a>
<a name="ln3239">      {</a>
<a name="ln3240">        dt_opencl_local_buffer_t locopt</a>
<a name="ln3241">          = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln3242">                                        .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3243">                                        .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3244"> </a>
<a name="ln3245">        if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_pre_median, &amp;locopt))</a>
<a name="ln3246">        goto error;</a>
<a name="ln3247"> </a>
<a name="ln3248">        size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3249">        size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3250">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln3251">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 1, sizeof(cl_mem), &amp;dev_aux);</a>
<a name="ln3252">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 2, sizeof(int), &amp;width);</a>
<a name="ln3253">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 3, sizeof(int), &amp;height);</a>
<a name="ln3254">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 4, sizeof(uint32_t),</a>
<a name="ln3255">                                 (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3256">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 5, sizeof(float), (void *)&amp;data-&gt;median_thrs);</a>
<a name="ln3257">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 6,</a>
<a name="ln3258">                             (locopt.sizex + 4) * (locopt.sizey + 4) * sizeof(float), NULL);</a>
<a name="ln3259">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_pre_median, sizes, local);</a>
<a name="ln3260">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3261">        dev_in = dev_aux;</a>
<a name="ln3262">      }</a>
<a name="ln3263"> </a>
<a name="ln3264">      dev_tmp = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, 4 * sizeof(float));</a>
<a name="ln3265">      if(dev_tmp == NULL) goto error;</a>
<a name="ln3266"> </a>
<a name="ln3267">      {</a>
<a name="ln3268">        dt_opencl_local_buffer_t locopt</a>
<a name="ln3269">          = (dt_opencl_local_buffer_t){ .xoffset = 2*3, .xfactor = 1, .yoffset = 2*3, .yfactor = 1,</a>
<a name="ln3270">                                        .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3271">                                        .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3272"> </a>
<a name="ln3273">        if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_ppg_green, &amp;locopt))</a>
<a name="ln3274">        goto error;</a>
<a name="ln3275"> </a>
<a name="ln3276">        size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3277">        size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3278">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln3279">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 1, sizeof(cl_mem), &amp;dev_tmp);</a>
<a name="ln3280">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 2, sizeof(int), &amp;width);</a>
<a name="ln3281">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 3, sizeof(int), &amp;height);</a>
<a name="ln3282">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 4, sizeof(uint32_t),</a>
<a name="ln3283">                                 (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3284">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 5,</a>
<a name="ln3285">                             (locopt.sizex + 2*3) * (locopt.sizey + 2*3) * sizeof(float), NULL);</a>
<a name="ln3286"> </a>
<a name="ln3287">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_ppg_green, sizes, local);</a>
<a name="ln3288">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3289">      }</a>
<a name="ln3290"> </a>
<a name="ln3291">      {</a>
<a name="ln3292">        dt_opencl_local_buffer_t locopt</a>
<a name="ln3293">          = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln3294">                                        .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln3295">                                        .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3296"> </a>
<a name="ln3297">        if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_ppg_redblue, &amp;locopt))</a>
<a name="ln3298">        goto error;</a>
<a name="ln3299"> </a>
<a name="ln3300">        size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3301">        size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3302">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 0, sizeof(cl_mem), &amp;dev_tmp);</a>
<a name="ln3303">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 1, sizeof(cl_mem), &amp;dev_aux);</a>
<a name="ln3304">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 2, sizeof(int), &amp;width);</a>
<a name="ln3305">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 3, sizeof(int), &amp;height);</a>
<a name="ln3306">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 4, sizeof(uint32_t),</a>
<a name="ln3307">                                 (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3308">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 5,</a>
<a name="ln3309">                             (locopt.sizex + 2) * (locopt.sizey + 2) * 4 * sizeof(float), NULL);</a>
<a name="ln3310"> </a>
<a name="ln3311">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_ppg_redblue, sizes, local);</a>
<a name="ln3312">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3313">      }</a>
<a name="ln3314"> </a>
<a name="ln3315">      {</a>
<a name="ln3316">        // manage borders</a>
<a name="ln3317">        size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3318">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln3319">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 1, sizeof(cl_mem), &amp;dev_aux);</a>
<a name="ln3320">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3321">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3322">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 4, sizeof(uint32_t),</a>
<a name="ln3323">                                 (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3324">        err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_border_interpolate, sizes);</a>
<a name="ln3325">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3326">      }</a>
<a name="ln3327">    }</a>
<a name="ln3328"> </a>
<a name="ln3329">    if(scaled)</a>
<a name="ln3330">    {</a>
<a name="ln3331">      // scale aux buffer to output buffer</a>
<a name="ln3332">      err = dt_iop_clip_and_zoom_roi_cl(devid, dev_out, dev_aux, roi_out, roi_in);</a>
<a name="ln3333">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3334">    }</a>
<a name="ln3335">  }</a>
<a name="ln3336">  else</a>
<a name="ln3337">  {</a>
<a name="ln3338">    if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln3339">    {</a>
<a name="ln3340">      // sample image:</a>
<a name="ln3341">      const int zero = 0;</a>
<a name="ln3342">      cl_mem dev_pix = dev_in;</a>
<a name="ln3343">      const int width = roi_out-&gt;width;</a>
<a name="ln3344">      const int height = roi_out-&gt;height;</a>
<a name="ln3345"> </a>
<a name="ln3346">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3347">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 0, sizeof(cl_mem), &amp;dev_pix);</a>
<a name="ln3348">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 1, sizeof(cl_mem), &amp;dev_out);</a>
<a name="ln3349">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 2, sizeof(int), &amp;width);</a>
<a name="ln3350">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 3, sizeof(int), &amp;height);</a>
<a name="ln3351">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 4, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3352">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 5, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3353">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 6, sizeof(int),</a>
<a name="ln3354">                               (void *)&amp;roi_in-&gt;width);</a>
<a name="ln3355">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 7, sizeof(int),</a>
<a name="ln3356">                               (void *)&amp;roi_in-&gt;height);</a>
<a name="ln3357">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 8, sizeof(float),</a>
<a name="ln3358">                               (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln3359">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 9, sizeof(uint32_t),</a>
<a name="ln3360">                               (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3361">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_passthrough_monochrome, sizes);</a>
<a name="ln3362">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3363">    }</a>
<a name="ln3364">    else</a>
<a name="ln3365">    {</a>
<a name="ln3366">      // sample half-size image:</a>
<a name="ln3367">      const int zero = 0;</a>
<a name="ln3368">      cl_mem dev_pix = dev_in;</a>
<a name="ln3369">      const int width = roi_out-&gt;width;</a>
<a name="ln3370">      const int height = roi_out-&gt;height;</a>
<a name="ln3371"> </a>
<a name="ln3372">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3373">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 0, sizeof(cl_mem), &amp;dev_pix);</a>
<a name="ln3374">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 1, sizeof(cl_mem), &amp;dev_out);</a>
<a name="ln3375">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 2, sizeof(int), &amp;width);</a>
<a name="ln3376">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 3, sizeof(int), &amp;height);</a>
<a name="ln3377">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 4, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3378">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 5, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3379">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 6, sizeof(int), (void *)&amp;roi_in-&gt;width);</a>
<a name="ln3380">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 7, sizeof(int), (void *)&amp;roi_in-&gt;height);</a>
<a name="ln3381">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 8, sizeof(float), (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln3382">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 9, sizeof(uint32_t),</a>
<a name="ln3383">                               (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3384">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_half_size, sizes);</a>
<a name="ln3385">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3386">    }</a>
<a name="ln3387">  }</a>
<a name="ln3388"> </a>
<a name="ln3389">  if(dev_aux != dev_out) dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln3390">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln3391">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3392">  dev_aux = dev_green_eq = dev_tmp = NULL;</a>
<a name="ln3393"> </a>
<a name="ln3394">  // color smoothing</a>
<a name="ln3395">  if(data-&gt;color_smoothing)</a>
<a name="ln3396">  {</a>
<a name="ln3397">    if(!color_smoothing_cl(self, piece, dev_out, dev_out, roi_out))</a>
<a name="ln3398">      goto error;</a>
<a name="ln3399">  }</a>
<a name="ln3400"> </a>
<a name="ln3401">  return TRUE;</a>
<a name="ln3402"> </a>
<a name="ln3403">error:</a>
<a name="ln3404">  if(dev_aux != dev_out) dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln3405">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln3406">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3407">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3408">  return FALSE;</a>
<a name="ln3409">}</a>
<a name="ln3410"> </a>
<a name="ln3411">static int process_vng_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln3412">                          cl_mem dev_out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln3413">{</a>
<a name="ln3414">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln3415">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;data;</a>
<a name="ln3416">  const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln3417"> </a>
<a name="ln3418">  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece-&gt;pipe-&gt;dsc.xtrans;</a>
<a name="ln3419"> </a>
<a name="ln3420">  // separate out G1 and G2 in Bayer patterns</a>
<a name="ln3421">  uint32_t filters4;</a>
<a name="ln3422">  if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln3423">    filters4 = piece-&gt;pipe-&gt;dsc.filters;</a>
<a name="ln3424">  else if((piece-&gt;pipe-&gt;dsc.filters &amp; 3) == 1)</a>
<a name="ln3425">    filters4 = piece-&gt;pipe-&gt;dsc.filters | 0x03030303u;</a>
<a name="ln3426">  else</a>
<a name="ln3427">    filters4 = piece-&gt;pipe-&gt;dsc.filters | 0x0c0c0c0cu;</a>
<a name="ln3428"> </a>
<a name="ln3429">  const int size = (filters4 == 9u) ? 6 : 16;</a>
<a name="ln3430">  const int colors = (filters4 == 9u) ? 3 : 4;</a>
<a name="ln3431">  const int prow = (filters4 == 9u) ? 6 : 8;</a>
<a name="ln3432">  const int pcol = (filters4 == 9u) ? 6 : 2;</a>
<a name="ln3433">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3434"> </a>
<a name="ln3435">  const float processed_maximum[4]</a>
<a name="ln3436">      = { piece-&gt;pipe-&gt;dsc.processed_maximum[0], piece-&gt;pipe-&gt;dsc.processed_maximum[1],</a>
<a name="ln3437">          piece-&gt;pipe-&gt;dsc.processed_maximum[2], 1.0f };</a>
<a name="ln3438"> </a>
<a name="ln3439">  const int qual_flags = demosaic_qual_flags(piece, img, roi_out);</a>
<a name="ln3440"> </a>
<a name="ln3441">  int *ips = NULL;</a>
<a name="ln3442"> </a>
<a name="ln3443">  cl_mem dev_tmp = NULL;</a>
<a name="ln3444">  cl_mem dev_aux = NULL;</a>
<a name="ln3445">  cl_mem dev_xtrans = NULL;</a>
<a name="ln3446">  cl_mem dev_lookup = NULL;</a>
<a name="ln3447">  cl_mem dev_code = NULL;</a>
<a name="ln3448">  cl_mem dev_ips = NULL;</a>
<a name="ln3449">  cl_mem dev_green_eq = NULL;</a>
<a name="ln3450">  cl_int err = -999;</a>
<a name="ln3451"> </a>
<a name="ln3452">  int32_t(*lookup)[16][32] = NULL;</a>
<a name="ln3453"> </a>
<a name="ln3454">  if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln3455">  {</a>
<a name="ln3456">    dev_xtrans</a>
<a name="ln3457">        = dt_opencl_copy_host_to_device_constant(devid, sizeof(piece-&gt;pipe-&gt;dsc.xtrans), piece-&gt;pipe-&gt;dsc.xtrans);</a>
<a name="ln3458">    if(dev_xtrans == NULL) goto error;</a>
<a name="ln3459">  }</a>
<a name="ln3460"> </a>
<a name="ln3461">  if(qual_flags &amp; DEMOSAIC_FULL_SCALE)</a>
<a name="ln3462">  {</a>
<a name="ln3463">    // Full demosaic and then scaling if needed</a>
<a name="ln3464">    const int scaled = (roi_out-&gt;width != roi_in-&gt;width || roi_out-&gt;height != roi_in-&gt;height);</a>
<a name="ln3465"> </a>
<a name="ln3466">    // build interpolation lookup table for linear interpolation which for a given offset in the sensor</a>
<a name="ln3467">    // lists neighboring pixels from which to interpolate:</a>
<a name="ln3468">    // NUM_PIXELS                 # of neighboring pixels to read</a>
<a name="ln3469">    // for (1..NUM_PIXELS):</a>
<a name="ln3470">    //   OFFSET                   # in bytes from current pixel</a>
<a name="ln3471">    //   WEIGHT                   # how much weight to give this neighbor</a>
<a name="ln3472">    //   COLOR                    # sensor color</a>
<a name="ln3473">    // # weights of adjoining pixels not of this pixel's color</a>
<a name="ln3474">    // COLORA TOT_WEIGHT</a>
<a name="ln3475">    // COLORB TOT_WEIGHT</a>
<a name="ln3476">    // COLORPIX                   # color of center pixel</a>
<a name="ln3477">    const size_t lookup_size = (size_t)16 * 16 * 32 * sizeof(int32_t);</a>
<a name="ln3478">    lookup = malloc(lookup_size);</a>
<a name="ln3479"> </a>
<a name="ln3480">    for(int row = 0; row &lt; size; row++)</a>
<a name="ln3481">      for(int col = 0; col &lt; size; col++)</a>
<a name="ln3482">      {</a>
<a name="ln3483">        int32_t *ip = lookup[row][col] + 1;</a>
<a name="ln3484">        int sum[4] = { 0 };</a>
<a name="ln3485">        const int f = fcol(row + roi_in-&gt;y, col + roi_in-&gt;x, filters4, xtrans);</a>
<a name="ln3486">        // make list of adjoining pixel offsets by weight &amp; color</a>
<a name="ln3487">        for(int y = -1; y &lt;= 1; y++)</a>
<a name="ln3488">          for(int x = -1; x &lt;= 1; x++)</a>
<a name="ln3489">          {</a>
<a name="ln3490">            int weight = 1 &lt;&lt; ((y == 0) + (x == 0));</a>
<a name="ln3491">            const int color = fcol(row + y + roi_in-&gt;y, col + x + roi_in-&gt;x, filters4, xtrans);</a>
<a name="ln3492">            if(color == f) continue;</a>
<a name="ln3493">            *ip++ = (y &lt;&lt; 16) | (x &amp; 0xffffu);</a>
<a name="ln3494">            *ip++ = weight;</a>
<a name="ln3495">            *ip++ = color;</a>
<a name="ln3496">            sum[color] += weight;</a>
<a name="ln3497">          }</a>
<a name="ln3498">        lookup[row][col][0] = (ip - lookup[row][col]) / 3; /* # of neighboring pixels found */</a>
<a name="ln3499">        for(int c = 0; c &lt; colors; c++)</a>
<a name="ln3500">          if(c != f)</a>
<a name="ln3501">          {</a>
<a name="ln3502">            *ip++ = c;</a>
<a name="ln3503">            *ip++ = sum[c];</a>
<a name="ln3504">          }</a>
<a name="ln3505">        *ip = f;</a>
<a name="ln3506">      }</a>
<a name="ln3507"> </a>
<a name="ln3508">    // Precalculate for VNG</a>
<a name="ln3509">    static const signed char terms[]</a>
<a name="ln3510">      = { -2, -2, +0, -1, 1, 0x01, -2, -2, +0, +0, 2, 0x01, -2, -1, -1, +0, 1, 0x01, -2, -1, +0, -1, 1, 0x02,</a>
<a name="ln3511">          -2, -1, +0, +0, 1, 0x03, -2, -1, +0, +1, 2, 0x01, -2, +0, +0, -1, 1, 0x06, -2, +0, +0, +0, 2, 0x02,</a>
<a name="ln3512">          -2, +0, +0, +1, 1, 0x03, -2, +1, -1, +0, 1, 0x04, -2, +1, +0, -1, 2, 0x04, -2, +1, +0, +0, 1, 0x06,</a>
<a name="ln3513">          -2, +1, +0, +1, 1, 0x02, -2, +2, +0, +0, 2, 0x04, -2, +2, +0, +1, 1, 0x04, -1, -2, -1, +0, 1, 0x80,</a>
<a name="ln3514">          -1, -2, +0, -1, 1, 0x01, -1, -2, +1, -1, 1, 0x01, -1, -2, +1, +0, 2, 0x01, -1, -1, -1, +1, 1, 0x88,</a>
<a name="ln3515">          -1, -1, +1, -2, 1, 0x40, -1, -1, +1, -1, 1, 0x22, -1, -1, +1, +0, 1, 0x33, -1, -1, +1, +1, 2, 0x11,</a>
<a name="ln3516">          -1, +0, -1, +2, 1, 0x08, -1, +0, +0, -1, 1, 0x44, -1, +0, +0, +1, 1, 0x11, -1, +0, +1, -2, 2, 0x40,</a>
<a name="ln3517">          -1, +0, +1, -1, 1, 0x66, -1, +0, +1, +0, 2, 0x22, -1, +0, +1, +1, 1, 0x33, -1, +0, +1, +2, 2, 0x10,</a>
<a name="ln3518">          -1, +1, +1, -1, 2, 0x44, -1, +1, +1, +0, 1, 0x66, -1, +1, +1, +1, 1, 0x22, -1, +1, +1, +2, 1, 0x10,</a>
<a name="ln3519">          -1, +2, +0, +1, 1, 0x04, -1, +2, +1, +0, 2, 0x04, -1, +2, +1, +1, 1, 0x04, +0, -2, +0, +0, 2, 0x80,</a>
<a name="ln3520">          +0, -1, +0, +1, 2, 0x88, +0, -1, +1, -2, 1, 0x40, +0, -1, +1, +0, 1, 0x11, +0, -1, +2, -2, 1, 0x40,</a>
<a name="ln3521">          +0, -1, +2, -1, 1, 0x20, +0, -1, +2, +0, 1, 0x30, +0, -1, +2, +1, 2, 0x10, +0, +0, +0, +2, 2, 0x08,</a>
<a name="ln3522">          +0, +0, +2, -2, 2, 0x40, +0, +0, +2, -1, 1, 0x60, +0, +0, +2, +0, 2, 0x20, +0, +0, +2, +1, 1, 0x30,</a>
<a name="ln3523">          +0, +0, +2, +2, 2, 0x10, +0, +1, +1, +0, 1, 0x44, +0, +1, +1, +2, 1, 0x10, +0, +1, +2, -1, 2, 0x40,</a>
<a name="ln3524">          +0, +1, +2, +0, 1, 0x60, +0, +1, +2, +1, 1, 0x20, +0, +1, +2, +2, 1, 0x10, +1, -2, +1, +0, 1, 0x80,</a>
<a name="ln3525">          +1, -1, +1, +1, 1, 0x88, +1, +0, +1, +2, 1, 0x08, +1, +0, +2, -1, 1, 0x40, +1, +0, +2, +1, 1, 0x10 };</a>
<a name="ln3526">    static const signed char chood[]</a>
<a name="ln3527">      = { -1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1 };</a>
<a name="ln3528"> </a>
<a name="ln3529">    const size_t ips_size = (size_t)prow * pcol * 352 * sizeof(int);</a>
<a name="ln3530">    ips = malloc(ips_size);</a>
<a name="ln3531"> </a>
<a name="ln3532">    int *ip = ips;</a>
<a name="ln3533">    int code[16][16];</a>
<a name="ln3534"> </a>
<a name="ln3535">    for(int row = 0; row &lt; prow; row++)</a>
<a name="ln3536">      for(int col = 0; col &lt; pcol; col++)</a>
<a name="ln3537">      {</a>
<a name="ln3538">        code[row][col] = ip - ips;</a>
<a name="ln3539">        const signed char *cp = terms;</a>
<a name="ln3540">        for(int t = 0; t &lt; 64; t++)</a>
<a name="ln3541">        {</a>
<a name="ln3542">          int y1 = *cp++, x1 = *cp++;</a>
<a name="ln3543">          int y2 = *cp++, x2 = *cp++;</a>
<a name="ln3544">          int weight = *cp++;</a>
<a name="ln3545">          int grads = *cp++;</a>
<a name="ln3546">          int color = fcol(row + y1, col + x1, filters4, xtrans);</a>
<a name="ln3547">          if(fcol(row + y2, col + x2, filters4, xtrans) != color) continue;</a>
<a name="ln3548">          int diag</a>
<a name="ln3549">              = (fcol(row, col + 1, filters4, xtrans) == color &amp;&amp; fcol(row + 1, col, filters4, xtrans) == color)</a>
<a name="ln3550">                    ? 2</a>
<a name="ln3551">                    : 1;</a>
<a name="ln3552">          if(abs(y1 - y2) == diag &amp;&amp; abs(x1 - x2) == diag) continue;</a>
<a name="ln3553">          *ip++ = (y1 &lt;&lt; 16) | (x1 &amp; 0xffffu);</a>
<a name="ln3554">          *ip++ = (y2 &lt;&lt; 16) | (x2 &amp; 0xffffu);</a>
<a name="ln3555">          *ip++ = (color &lt;&lt; 16) | (weight &amp; 0xffffu);</a>
<a name="ln3556">          for(int g = 0; g &lt; 8; g++)</a>
<a name="ln3557">            if(grads &amp; 1 &lt;&lt; g) *ip++ = g;</a>
<a name="ln3558">          *ip++ = -1;</a>
<a name="ln3559">        }</a>
<a name="ln3560">        *ip++ = INT_MAX;</a>
<a name="ln3561">        cp = chood;</a>
<a name="ln3562">        for(int g = 0; g &lt; 8; g++)</a>
<a name="ln3563">        {</a>
<a name="ln3564">          int y = *cp++, x = *cp++;</a>
<a name="ln3565">          *ip++ = (y &lt;&lt; 16) | (x &amp; 0xffffu);</a>
<a name="ln3566">          int color = fcol(row, col, filters4, xtrans);</a>
<a name="ln3567">          if(fcol(row + y, col + x, filters4, xtrans) != color</a>
<a name="ln3568">             &amp;&amp; fcol(row + y * 2, col + x * 2, filters4, xtrans) == color)</a>
<a name="ln3569">          {</a>
<a name="ln3570">            *ip++ = (2*y &lt;&lt; 16) | (2*x &amp; 0xffffu);</a>
<a name="ln3571">            *ip++ = color;</a>
<a name="ln3572">          }</a>
<a name="ln3573">          else</a>
<a name="ln3574">          {</a>
<a name="ln3575">            *ip++ = 0;</a>
<a name="ln3576">            *ip++ = 0;</a>
<a name="ln3577">          }</a>
<a name="ln3578">        }</a>
<a name="ln3579">      }</a>
<a name="ln3580"> </a>
<a name="ln3581"> </a>
<a name="ln3582">    dev_lookup = dt_opencl_copy_host_to_device_constant(devid, lookup_size, lookup);</a>
<a name="ln3583">    if(dev_lookup == NULL) goto error;</a>
<a name="ln3584"> </a>
<a name="ln3585">    dev_code = dt_opencl_copy_host_to_device_constant(devid, sizeof(code), code);</a>
<a name="ln3586">    if(dev_code == NULL) goto error;</a>
<a name="ln3587"> </a>
<a name="ln3588">    dev_ips = dt_opencl_copy_host_to_device_constant(devid, ips_size, ips);</a>
<a name="ln3589">    if(dev_ips == NULL) goto error;</a>
<a name="ln3590"> </a>
<a name="ln3591">    // green equilibration for Bayer sensors</a>
<a name="ln3592">    if(piece-&gt;pipe-&gt;dsc.filters != 9u &amp;&amp; data-&gt;green_eq != DT_IOP_GREEN_EQ_NO)</a>
<a name="ln3593">    {</a>
<a name="ln3594">      dev_green_eq = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, sizeof(float));</a>
<a name="ln3595">      if(dev_green_eq == NULL) goto error;</a>
<a name="ln3596"> </a>
<a name="ln3597">      if(!green_equilibration_cl(self, piece, dev_in, dev_green_eq, roi_in))</a>
<a name="ln3598">        goto error;</a>
<a name="ln3599"> </a>
<a name="ln3600">      dev_in = dev_green_eq;</a>
<a name="ln3601">    }</a>
<a name="ln3602"> </a>
<a name="ln3603">    int width = roi_out-&gt;width;</a>
<a name="ln3604">    int height = roi_out-&gt;height;</a>
<a name="ln3605"> </a>
<a name="ln3606">    // need to reserve scaled auxiliary buffer or use dev_out</a>
<a name="ln3607">    if(scaled)</a>
<a name="ln3608">    {</a>
<a name="ln3609">      dev_aux = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, 4 * sizeof(float));</a>
<a name="ln3610">      if(dev_aux == NULL) goto error;</a>
<a name="ln3611">      width = roi_in-&gt;width;</a>
<a name="ln3612">      height = roi_in-&gt;height;</a>
<a name="ln3613">    }</a>
<a name="ln3614">    else</a>
<a name="ln3615">      dev_aux = dev_out;</a>
<a name="ln3616"> </a>
<a name="ln3617">    dev_tmp = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, 4 * sizeof(float));</a>
<a name="ln3618">    if(dev_tmp == NULL) goto error;</a>
<a name="ln3619"> </a>
<a name="ln3620">    {</a>
<a name="ln3621">      // manage borders for linear interpolation part</a>
<a name="ln3622">      const int border = 1;</a>
<a name="ln3623"> </a>
<a name="ln3624">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3625">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3626">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3627">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3628">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3629">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 4, sizeof(int), (void *)&amp;border);</a>
<a name="ln3630">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 5, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3631">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 6, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3632">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 7, sizeof(uint32_t), (void *)&amp;filters4);</a>
<a name="ln3633">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3634">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_vng_border_interpolate, sizes);</a>
<a name="ln3635">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3636">    }</a>
<a name="ln3637"> </a>
<a name="ln3638">    {</a>
<a name="ln3639">      // do linear interpolation</a>
<a name="ln3640">      dt_opencl_local_buffer_t locopt</a>
<a name="ln3641">        = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln3642">                                      .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3643">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3644"> </a>
<a name="ln3645">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_vng_lin_interpolate, &amp;locopt))</a>
<a name="ln3646">        goto error;</a>
<a name="ln3647"> </a>
<a name="ln3648">      size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3649">      size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3650">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3651">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3652">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3653">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3654">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 4, sizeof(uint32_t), (void *)&amp;filters4);</a>
<a name="ln3655">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 5, sizeof(cl_mem), (void *)&amp;dev_lookup);</a>
<a name="ln3656">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 6,</a>
<a name="ln3657">                               (locopt.sizex + 2) * (locopt.sizey + 2) * sizeof(float), NULL);</a>
<a name="ln3658">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_vng_lin_interpolate, sizes, local);</a>
<a name="ln3659">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3660">    }</a>
<a name="ln3661"> </a>
<a name="ln3662"> </a>
<a name="ln3663">    if(qual_flags &amp; DEMOSAIC_ONLY_VNG_LINEAR)</a>
<a name="ln3664">    {</a>
<a name="ln3665">      // leave it at linear interpolation and skip VNG</a>
<a name="ln3666">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3667">      size_t region[] = { width, height, 1 };</a>
<a name="ln3668">      err = dt_opencl_enqueue_copy_image(devid, dev_tmp, dev_aux, origin, origin, region);</a>
<a name="ln3669">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3670">    }</a>
<a name="ln3671">    else</a>
<a name="ln3672">    {</a>
<a name="ln3673">      // do full VNG interpolation</a>
<a name="ln3674">      dt_opencl_local_buffer_t locopt</a>
<a name="ln3675">        = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln3676">                                      .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln3677">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3678"> </a>
<a name="ln3679">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_vng_interpolate, &amp;locopt))</a>
<a name="ln3680">        goto error;</a>
<a name="ln3681"> </a>
<a name="ln3682">      size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3683">      size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3684">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3685">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln3686">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3687">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3688">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3689">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3690">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 6, sizeof(uint32_t), (void *)&amp;filters4);</a>
<a name="ln3691">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 7, 4*sizeof(float), (void *)processed_maximum);</a>
<a name="ln3692">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3693">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 9, sizeof(cl_mem), (void *)&amp;dev_ips);</a>
<a name="ln3694">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 10, sizeof(cl_mem), (void *)&amp;dev_code);</a>
<a name="ln3695">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 11, (locopt.sizex + 4) * (locopt.sizey + 4) * 4 * sizeof(float), NULL);</a>
<a name="ln3696">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_vng_interpolate, sizes, local);</a>
<a name="ln3697">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3698">    }</a>
<a name="ln3699"> </a>
<a name="ln3700">    {</a>
<a name="ln3701">      // manage borders</a>
<a name="ln3702">      const int border = 2;</a>
<a name="ln3703"> </a>
<a name="ln3704">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3705">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3706">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln3707">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3708">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3709">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 4, sizeof(int), (void *)&amp;border);</a>
<a name="ln3710">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 5, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3711">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 6, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3712">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 7, sizeof(uint32_t), (void *)&amp;filters4);</a>
<a name="ln3713">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3714">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_vng_border_interpolate, sizes);</a>
<a name="ln3715">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3716">    }</a>
<a name="ln3717"> </a>
<a name="ln3718">    if(filters4 != 9)</a>
<a name="ln3719">    {</a>
<a name="ln3720">      // for Bayer sensors mix the two green channels</a>
<a name="ln3721">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3722">      size_t region[] = { width, height, 1 };</a>
<a name="ln3723">      err = dt_opencl_enqueue_copy_image(devid, dev_aux, dev_tmp, origin, origin, region);</a>
<a name="ln3724">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3725"> </a>
<a name="ln3726">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3727">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_green_equilibrate, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3728">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_green_equilibrate, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln3729">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_green_equilibrate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3730">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_green_equilibrate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3731">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_vng_green_equilibrate, sizes);</a>
<a name="ln3732">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3733">    }</a>
<a name="ln3734"> </a>
<a name="ln3735">    if(scaled)</a>
<a name="ln3736">    {</a>
<a name="ln3737">      // scale temp buffer to output buffer</a>
<a name="ln3738">      err = dt_iop_clip_and_zoom_roi_cl(devid, dev_out, dev_aux, roi_out, roi_in);</a>
<a name="ln3739">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3740">    }</a>
<a name="ln3741">  }</a>
<a name="ln3742">  else</a>
<a name="ln3743">  {</a>
<a name="ln3744">    // sample half-size or third-size image</a>
<a name="ln3745">    if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln3746">    {</a>
<a name="ln3747">      const int width = roi_out-&gt;width;</a>
<a name="ln3748">      const int height = roi_out-&gt;height;</a>
<a name="ln3749"> </a>
<a name="ln3750">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3751">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3752">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3753">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3754">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3755">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3756">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3757">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 6, sizeof(int), (void *)&amp;roi_in-&gt;width);</a>
<a name="ln3758">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 7, sizeof(int), (void *)&amp;roi_in-&gt;height);</a>
<a name="ln3759">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 8, sizeof(float), (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln3760">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 9, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3761">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_third_size, sizes);</a>
<a name="ln3762">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3763">    }</a>
<a name="ln3764">    else</a>
<a name="ln3765">    {</a>
<a name="ln3766">      const int zero = 0;</a>
<a name="ln3767">      const int width = roi_out-&gt;width;</a>
<a name="ln3768">      const int height = roi_out-&gt;height;</a>
<a name="ln3769"> </a>
<a name="ln3770">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3771">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3772">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3773">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3774">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3775">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 4, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3776">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 5, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3777">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 6, sizeof(int), (void *)&amp;roi_in-&gt;width);</a>
<a name="ln3778">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 7, sizeof(int), (void *)&amp;roi_in-&gt;height);</a>
<a name="ln3779">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 8, sizeof(float), (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln3780">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 9, sizeof(uint32_t),</a>
<a name="ln3781">                               (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3782">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_half_size, sizes);</a>
<a name="ln3783">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3784">    }</a>
<a name="ln3785">  }</a>
<a name="ln3786"> </a>
<a name="ln3787"> </a>
<a name="ln3788">  if(dev_aux != dev_out) dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln3789">  dev_aux = NULL;</a>
<a name="ln3790"> </a>
<a name="ln3791">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3792">  dev_tmp = NULL;</a>
<a name="ln3793"> </a>
<a name="ln3794">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln3795">  dev_xtrans = NULL;</a>
<a name="ln3796"> </a>
<a name="ln3797">  dt_opencl_release_mem_object(dev_lookup);</a>
<a name="ln3798">  dev_lookup = NULL;</a>
<a name="ln3799"> </a>
<a name="ln3800">  free(lookup);</a>
<a name="ln3801"> </a>
<a name="ln3802">  dt_opencl_release_mem_object(dev_code);</a>
<a name="ln3803">  dev_code = NULL;</a>
<a name="ln3804"> </a>
<a name="ln3805">  dt_opencl_release_mem_object(dev_ips);</a>
<a name="ln3806">  dev_ips = NULL;</a>
<a name="ln3807"> </a>
<a name="ln3808">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln3809">  dev_green_eq = NULL;</a>
<a name="ln3810"> </a>
<a name="ln3811">  free(ips);</a>
<a name="ln3812">  ips = NULL;</a>
<a name="ln3813"> </a>
<a name="ln3814">  // color smoothing</a>
<a name="ln3815">  if(data-&gt;color_smoothing)</a>
<a name="ln3816">  {</a>
<a name="ln3817">    if(!color_smoothing_cl(self, piece, dev_out, dev_out, roi_out))</a>
<a name="ln3818">      goto error;</a>
<a name="ln3819">  }</a>
<a name="ln3820"> </a>
<a name="ln3821">  return TRUE;</a>
<a name="ln3822"> </a>
<a name="ln3823">error:</a>
<a name="ln3824">  if(dev_aux != dev_out) dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln3825">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3826">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln3827">  dt_opencl_release_mem_object(dev_lookup);</a>
<a name="ln3828">  free(lookup);</a>
<a name="ln3829">  dt_opencl_release_mem_object(dev_code);</a>
<a name="ln3830">  dt_opencl_release_mem_object(dev_ips);</a>
<a name="ln3831">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln3832">  free(ips);</a>
<a name="ln3833">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3834">  return FALSE;</a>
<a name="ln3835">}</a>
<a name="ln3836"> </a>
<a name="ln3837">static int process_markesteijn_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln3838">                                  cl_mem dev_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln3839">                                  const dt_iop_roi_t *const roi_out)</a>
<a name="ln3840">{</a>
<a name="ln3841">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln3842">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;data;</a>
<a name="ln3843"> </a>
<a name="ln3844">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3845">  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece-&gt;pipe-&gt;dsc.xtrans;</a>
<a name="ln3846"> </a>
<a name="ln3847">  const float processed_maximum[4]</a>
<a name="ln3848">      = { piece-&gt;pipe-&gt;dsc.processed_maximum[0], piece-&gt;pipe-&gt;dsc.processed_maximum[1],</a>
<a name="ln3849">          piece-&gt;pipe-&gt;dsc.processed_maximum[2], 1.0f };</a>
<a name="ln3850"> </a>
<a name="ln3851">  const int qual_flags = demosaic_qual_flags(piece, &amp;self-&gt;dev-&gt;image_storage, roi_out);</a>
<a name="ln3852"> </a>
<a name="ln3853">  cl_mem dev_tmp = NULL;</a>
<a name="ln3854">  cl_mem dev_tmptmp = NULL;</a>
<a name="ln3855">  cl_mem dev_xtrans = NULL;</a>
<a name="ln3856">  cl_mem dev_green_eq = NULL;</a>
<a name="ln3857">  cl_mem dev_rgbv[8] = { NULL };</a>
<a name="ln3858">  cl_mem dev_drv[8] = { NULL };</a>
<a name="ln3859">  cl_mem dev_homo[8] = { NULL };</a>
<a name="ln3860">  cl_mem dev_homosum[8] = { NULL };</a>
<a name="ln3861">  cl_mem dev_gminmax = NULL;</a>
<a name="ln3862">  cl_mem dev_allhex = NULL;</a>
<a name="ln3863">  cl_mem dev_aux = NULL;</a>
<a name="ln3864">  cl_mem dev_edge_in = NULL;</a>
<a name="ln3865">  cl_mem dev_edge_out = NULL;</a>
<a name="ln3866">  cl_int err = -999;</a>
<a name="ln3867"> </a>
<a name="ln3868">  cl_mem *dev_rgb = dev_rgbv;</a>
<a name="ln3869"> </a>
<a name="ln3870">  dev_xtrans</a>
<a name="ln3871">      = dt_opencl_copy_host_to_device_constant(devid, sizeof(piece-&gt;pipe-&gt;dsc.xtrans), piece-&gt;pipe-&gt;dsc.xtrans);</a>
<a name="ln3872">  if(dev_xtrans == NULL) goto error;</a>
<a name="ln3873"> </a>
<a name="ln3874">  if(qual_flags &amp; DEMOSAIC_FULL_SCALE)</a>
<a name="ln3875">  {</a>
<a name="ln3876">    // Full demosaic and then scaling if needed</a>
<a name="ln3877">    const int scaled = (roi_out-&gt;width != roi_in-&gt;width || roi_out-&gt;height != roi_in-&gt;height);</a>
<a name="ln3878"> </a>
<a name="ln3879">    int width = roi_in-&gt;width;</a>
<a name="ln3880">    int height = roi_in-&gt;height;</a>
<a name="ln3881">    const int passes = (data-&gt;demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3) ? 3 : 1;</a>
<a name="ln3882">    const int ndir = 4 &lt;&lt; (passes &gt; 1);</a>
<a name="ln3883">    const int pad_tile = (passes == 1) ? 12 : 17;</a>
<a name="ln3884"> </a>
<a name="ln3885">    static const short orth[12] = { 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1 },</a>
<a name="ln3886">                       patt[2][16] = { { 0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0 },</a>
<a name="ln3887">                                       { 0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1 } };</a>
<a name="ln3888"> </a>
<a name="ln3889">    // allhex contains the offset coordinates (x,y) of a green hexagon around each</a>
<a name="ln3890">    // non-green pixel and vice versa</a>
<a name="ln3891">    char allhex[3][3][8][2];</a>
<a name="ln3892">    // sgreen is the offset in the sensor matrix of the solitary</a>
<a name="ln3893">    // green pixels (initialized here only to avoid compiler warning)</a>
<a name="ln3894">    char sgreen[2] = { 0 };</a>
<a name="ln3895"> </a>
<a name="ln3896">    // Map a green hexagon around each non-green pixel and vice versa:</a>
<a name="ln3897">    for(int row = 0; row &lt; 3; row++)</a>
<a name="ln3898">      for(int col = 0; col &lt; 3; col++)</a>
<a name="ln3899">        for(int ng = 0, d = 0; d &lt; 10; d += 2)</a>
<a name="ln3900">        {</a>
<a name="ln3901">          int g = FCxtrans(row, col, NULL, xtrans) == 1;</a>
<a name="ln3902">          if(FCxtrans(row + orth[d] + 6, col + orth[d + 2] + 6, NULL, xtrans) == 1)</a>
<a name="ln3903">            ng = 0;</a>
<a name="ln3904">          else</a>
<a name="ln3905">            ng++;</a>
<a name="ln3906">          // if there are four non-green pixels adjacent in cardinal</a>
<a name="ln3907">          // directions, this is the solitary green pixel</a>
<a name="ln3908">          if(ng == 4)</a>
<a name="ln3909">          {</a>
<a name="ln3910">            sgreen[0] = col;</a>
<a name="ln3911">            sgreen[1] = row;</a>
<a name="ln3912">          }</a>
<a name="ln3913">          if(ng == g + 1)</a>
<a name="ln3914">            for(int c = 0; c &lt; 8; c++)</a>
<a name="ln3915">            {</a>
<a name="ln3916">              int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];</a>
<a name="ln3917">              int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];</a>
<a name="ln3918"> </a>
<a name="ln3919">              allhex[row][col][c ^ (g * 2 &amp; d)][0] = h;</a>
<a name="ln3920">              allhex[row][col][c ^ (g * 2 &amp; d)][1] = v;</a>
<a name="ln3921">            }</a>
<a name="ln3922">        }</a>
<a name="ln3923"> </a>
<a name="ln3924">    dev_allhex = dt_opencl_copy_host_to_device_constant(devid, sizeof(allhex), allhex);</a>
<a name="ln3925">    if(dev_allhex == NULL) goto error;</a>
<a name="ln3926"> </a>
<a name="ln3927">    for(int n = 0; n &lt; ndir; n++)</a>
<a name="ln3928">    {</a>
<a name="ln3929">      dev_rgbv[n] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln3930">      if(dev_rgbv[n] == NULL) goto error;</a>
<a name="ln3931">    }</a>
<a name="ln3932"> </a>
<a name="ln3933">    dev_gminmax = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * 2 * sizeof(float));</a>
<a name="ln3934">    if(dev_gminmax == NULL) goto error;</a>
<a name="ln3935"> </a>
<a name="ln3936">    dev_aux = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln3937">    if(dev_aux == NULL) goto error;</a>
<a name="ln3938"> </a>
<a name="ln3939">    if(scaled)</a>
<a name="ln3940">    {</a>
<a name="ln3941">      // need to scale to right res</a>
<a name="ln3942">      dev_tmp = dt_opencl_alloc_device(devid, (size_t)width, height, 4 * sizeof(float));</a>
<a name="ln3943">      if(dev_tmp == NULL) goto error;</a>
<a name="ln3944">    }</a>
<a name="ln3945">    else</a>
<a name="ln3946">    {</a>
<a name="ln3947">      // scaling factor 1.0 --&gt; we can directly process into the output buffer</a>
<a name="ln3948">      dev_tmp = dev_out;</a>
<a name="ln3949">    }</a>
<a name="ln3950"> </a>
<a name="ln3951">    {</a>
<a name="ln3952">      // copy from dev_in to first rgb image buffer.</a>
<a name="ln3953">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3954">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3955">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 1, sizeof(cl_mem), (void *)&amp;dev_rgb[0]);</a>
<a name="ln3956">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3957">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3958">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3959">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3960">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 6, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3961">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_initial_copy, sizes);</a>
<a name="ln3962">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3963">    }</a>
<a name="ln3964"> </a>
<a name="ln3965"> </a>
<a name="ln3966">    // duplicate dev_rgb[0] to dev_rgb[1], dev_rgb[2], and dev_rgb[3]</a>
<a name="ln3967">    for(int c = 1; c &lt;= 3; c++)</a>
<a name="ln3968">    {</a>
<a name="ln3969">      err = dt_opencl_enqueue_copy_buffer_to_buffer(devid, dev_rgb[0], dev_rgb[c], 0, 0,</a>
<a name="ln3970">                                                    (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln3971">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3972">    }</a>
<a name="ln3973"> </a>
<a name="ln3974">    // find minimum and maximum allowed green values of red/blue pixel pairs</a>
<a name="ln3975">    const int pad_g1_g3 = 3;</a>
<a name="ln3976">    dt_opencl_local_buffer_t locopt_g1_g3</a>
<a name="ln3977">      = (dt_opencl_local_buffer_t){ .xoffset = 2*3, .xfactor = 1, .yoffset = 2*3, .yfactor = 1,</a>
<a name="ln3978">                                    .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3979">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3980"> </a>
<a name="ln3981">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_green_minmax, &amp;locopt_g1_g3))</a>
<a name="ln3982">      goto error;</a>
<a name="ln3983"> </a>
<a name="ln3984">    {</a>
<a name="ln3985">      size_t sizes[3] = { ROUNDUP(width, locopt_g1_g3.sizex), ROUNDUP(height, locopt_g1_g3.sizey), 1 };</a>
<a name="ln3986">      size_t local[3] = { locopt_g1_g3.sizex, locopt_g1_g3.sizey, 1 };</a>
<a name="ln3987">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[0]);</a>
<a name="ln3988">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 1, sizeof(cl_mem), (void *)&amp;dev_gminmax);</a>
<a name="ln3989">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3990">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3991">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 4, sizeof(int), (void *)&amp;pad_g1_g3);</a>
<a name="ln3992">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 5, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3993">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 6, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3994">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 7, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln3995">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3996">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 9, sizeof(cl_mem), (void *)&amp;dev_allhex);</a>
<a name="ln3997">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 10,</a>
<a name="ln3998">                               (locopt_g1_g3.sizex + 2*3) * (locopt_g1_g3.sizey + 2*3) * sizeof(float), NULL);</a>
<a name="ln3999">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_green_minmax, sizes, local);</a>
<a name="ln4000">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4001">    }</a>
<a name="ln4002"> </a>
<a name="ln4003">    // interpolate green horizontally, vertically, and along both diagonals</a>
<a name="ln4004">    const int pad_g_interp = 3;</a>
<a name="ln4005">    dt_opencl_local_buffer_t locopt_g_interp</a>
<a name="ln4006">      = (dt_opencl_local_buffer_t){ .xoffset = 2*6, .xfactor = 1, .yoffset = 2*6, .yfactor = 1,</a>
<a name="ln4007">                                    .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4008">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4009"> </a>
<a name="ln4010">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_interpolate_green, &amp;locopt_g_interp))</a>
<a name="ln4011">      goto error;</a>
<a name="ln4012"> </a>
<a name="ln4013">    {</a>
<a name="ln4014">      size_t sizes[3] = { ROUNDUP(width, locopt_g_interp.sizex), ROUNDUP(height, locopt_g_interp.sizey), 1 };</a>
<a name="ln4015">      size_t local[3] = { locopt_g_interp.sizex, locopt_g_interp.sizey, 1 };</a>
<a name="ln4016">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[0]);</a>
<a name="ln4017">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 1, sizeof(cl_mem), (void *)&amp;dev_rgb[1]);</a>
<a name="ln4018">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 2, sizeof(cl_mem), (void *)&amp;dev_rgb[2]);</a>
<a name="ln4019">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 3, sizeof(cl_mem), (void *)&amp;dev_rgb[3]);</a>
<a name="ln4020">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 4, sizeof(cl_mem), (void *)&amp;dev_gminmax);</a>
<a name="ln4021">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 5, sizeof(int), (void *)&amp;width);</a>
<a name="ln4022">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 6, sizeof(int), (void *)&amp;height);</a>
<a name="ln4023">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 7, sizeof(int), (void *)&amp;pad_g_interp);</a>
<a name="ln4024">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 8, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4025">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 9, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4026">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 10, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4027">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 11, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4028">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 12, sizeof(cl_mem), (void *)&amp;dev_allhex);</a>
<a name="ln4029">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 13,</a>
<a name="ln4030">                               (locopt_g_interp.sizex + 2*6) * (locopt_g_interp.sizey + 2*6) * 4 * sizeof(float), NULL);</a>
<a name="ln4031">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_interpolate_green, sizes, local);</a>
<a name="ln4032">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4033">    }</a>
<a name="ln4034"> </a>
<a name="ln4035">    // multi-pass loop: one pass for Markesteijn-1 and three passes for Markesteijn-3</a>
<a name="ln4036">    for(int pass = 0; pass &lt; passes; pass++)</a>
<a name="ln4037">    {</a>
<a name="ln4038"> </a>
<a name="ln4039">      // if on second pass, copy rgb[0] to [3] into rgb[4] to [7] ....</a>
<a name="ln4040">      if(pass == 1)</a>
<a name="ln4041">      {</a>
<a name="ln4042">        for(int c = 0; c &lt; 4; c++)</a>
<a name="ln4043">        {</a>
<a name="ln4044">          err = dt_opencl_enqueue_copy_buffer_to_buffer(devid, dev_rgb[c], dev_rgb[c + 4], 0, 0,</a>
<a name="ln4045">                                                        (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln4046">          if(err != CL_SUCCESS) goto error;</a>
<a name="ln4047">        }</a>
<a name="ln4048">        // ... and process that second set of buffers</a>
<a name="ln4049">        dev_rgb += 4;</a>
<a name="ln4050">      }</a>
<a name="ln4051"> </a>
<a name="ln4052">      // second and third pass (only Markesteijn-3)</a>
<a name="ln4053">      if(pass)</a>
<a name="ln4054">      {</a>
<a name="ln4055">        // recalculate green from interpolated values of closer pixels</a>
<a name="ln4056">        const int pad_g_recalc = 6;</a>
<a name="ln4057">        size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4058">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[0]);</a>
<a name="ln4059">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 1, sizeof(cl_mem), (void *)&amp;dev_rgb[1]);</a>
<a name="ln4060">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 2, sizeof(cl_mem), (void *)&amp;dev_rgb[2]);</a>
<a name="ln4061">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 3, sizeof(cl_mem), (void *)&amp;dev_rgb[3]);</a>
<a name="ln4062">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 4, sizeof(cl_mem), (void *)&amp;dev_gminmax);</a>
<a name="ln4063">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 5, sizeof(int), (void *)&amp;width);</a>
<a name="ln4064">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 6, sizeof(int), (void *)&amp;height);</a>
<a name="ln4065">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 7, sizeof(int), (void *)&amp;pad_g_recalc);</a>
<a name="ln4066">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 8, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4067">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 9, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4068">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 10, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4069">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 11, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4070">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 12, sizeof(cl_mem), (void *)&amp;dev_allhex);</a>
<a name="ln4071">        err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_recalculate_green, sizes);</a>
<a name="ln4072">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln4073">      }</a>
<a name="ln4074"> </a>
<a name="ln4075">      // interpolate red and blue values for solitary green pixels</a>
<a name="ln4076">      const int pad_rb_g = (passes == 1) ? 6 : 5;</a>
<a name="ln4077">      dt_opencl_local_buffer_t locopt_rb_g</a>
<a name="ln4078">        = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln4079">                                      .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4080">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4081"> </a>
<a name="ln4082">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_solitary_green, &amp;locopt_rb_g))</a>
<a name="ln4083">      goto error;</a>
<a name="ln4084"> </a>
<a name="ln4085">      cl_mem *dev_trgb = dev_rgb;</a>
<a name="ln4086">      for(int d = 0, i = 1, h = 0; d &lt; 6; d++, i ^= 1, h ^= 2)</a>
<a name="ln4087">      {</a>
<a name="ln4088">        const char dir[2] = { i, i ^ 1 };</a>
<a name="ln4089"> </a>
<a name="ln4090">        // we use dev_aux to transport intermediate results from one loop run to the next</a>
<a name="ln4091">        size_t sizes[3] = { ROUNDUP(width, locopt_rb_g.sizex), ROUNDUP(height, locopt_rb_g.sizey), 1 };</a>
<a name="ln4092">        size_t local[3] = { locopt_rb_g.sizex, locopt_rb_g.sizey, 1 };</a>
<a name="ln4093">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 0, sizeof(cl_mem), (void *)&amp;dev_trgb[0]);</a>
<a name="ln4094">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4095">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4096">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4097">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 4, sizeof(int), (void *)&amp;pad_rb_g);</a>
<a name="ln4098">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 5, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4099">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 6, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4100">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 7, sizeof(int), (void *)&amp;d);</a>
<a name="ln4101">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 8, 2 * sizeof(char), (void *)dir);</a>
<a name="ln4102">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 9, sizeof(int), (void *)&amp;h);</a>
<a name="ln4103">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 10, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4104">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 11, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4105">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 12,</a>
<a name="ln4106">                                (locopt_rb_g.sizex + 2*2) * (locopt_rb_g.sizey + 2*2) * 4 * sizeof(float), NULL);</a>
<a name="ln4107">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_solitary_green, sizes, local);</a>
<a name="ln4108">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln4109"> </a>
<a name="ln4110">        if((d &lt; 2) || (d &amp; 1)) dev_trgb++;</a>
<a name="ln4111">      }</a>
<a name="ln4112"> </a>
<a name="ln4113">      // interpolate red for blue pixels and vice versa</a>
<a name="ln4114">      const int pad_rb_br = (passes == 1) ? 6 : 5;</a>
<a name="ln4115">      dt_opencl_local_buffer_t locopt_rb_br</a>
<a name="ln4116">        = (dt_opencl_local_buffer_t){ .xoffset = 2*3, .xfactor = 1, .yoffset = 2*3, .yfactor = 1,</a>
<a name="ln4117">                                      .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4118">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4119"> </a>
<a name="ln4120">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_red_and_blue, &amp;locopt_rb_br))</a>
<a name="ln4121">      goto error;</a>
<a name="ln4122"> </a>
<a name="ln4123">      for(int d = 0; d &lt; 4; d++)</a>
<a name="ln4124">      {</a>
<a name="ln4125">        size_t sizes[3] = { ROUNDUP(width, locopt_rb_br.sizex), ROUNDUP(height, locopt_rb_br.sizey), 1 };</a>
<a name="ln4126">        size_t local[3] = { locopt_rb_br.sizex, locopt_rb_br.sizey, 1 };</a>
<a name="ln4127">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[d]);</a>
<a name="ln4128">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln4129">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln4130">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 3, sizeof(int), (void *)&amp;pad_rb_br);</a>
<a name="ln4131">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4132">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4133">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 6, sizeof(int), (void *)&amp;d);</a>
<a name="ln4134">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 7, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4135">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4136">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 9,</a>
<a name="ln4137">                                (locopt_rb_br.sizex + 2*3) * (locopt_rb_br.sizey + 2*3) * 4 * sizeof(float), NULL);</a>
<a name="ln4138">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_red_and_blue, sizes, local);</a>
<a name="ln4139">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln4140">      }</a>
<a name="ln4141"> </a>
<a name="ln4142">      // interpolate red and blue for 2x2 blocks of green</a>
<a name="ln4143">      const int pad_g22 = (passes == 1) ? 8 : 4;</a>
<a name="ln4144">      dt_opencl_local_buffer_t locopt_g22</a>
<a name="ln4145">        = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln4146">                                      .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4147">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4148"> </a>
<a name="ln4149">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, &amp;locopt_g22))</a>
<a name="ln4150">      goto error;</a>
<a name="ln4151"> </a>
<a name="ln4152">      for(int d = 0, n = 0; d &lt; ndir; d += 2, n++)</a>
<a name="ln4153">      {</a>
<a name="ln4154">        size_t sizes[3] = { ROUNDUP(width, locopt_g22.sizex), ROUNDUP(height, locopt_g22.sizey), 1 };</a>
<a name="ln4155">        size_t local[3] = { locopt_g22.sizex, locopt_g22.sizey, 1 };</a>
<a name="ln4156">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[n]);</a>
<a name="ln4157">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln4158">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln4159">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 3, sizeof(int), (void *)&amp;pad_g22);</a>
<a name="ln4160">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4161">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4162">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 6, sizeof(int), (void *)&amp;d);</a>
<a name="ln4163">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 7, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4164">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4165">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 9, sizeof(cl_mem), (void *)&amp;dev_allhex);</a>
<a name="ln4166">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 10,</a>
<a name="ln4167">                                (locopt_g22.sizex + 2*2) * (locopt_g22.sizey + 2*2) * 4 * sizeof(float), NULL);</a>
<a name="ln4168">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, sizes, local);</a>
<a name="ln4169">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln4170">      }</a>
<a name="ln4171">    }</a>
<a name="ln4172">    // end of multi pass</a>
<a name="ln4173"> </a>
<a name="ln4174">    // gminmax data no longer needed</a>
<a name="ln4175">    dt_opencl_release_mem_object(dev_gminmax);</a>
<a name="ln4176">    dev_gminmax = NULL;</a>
<a name="ln4177"> </a>
<a name="ln4178">    // jump back to the first set of rgb buffers (this is a noop for Markesteijn-1)</a>
<a name="ln4179">    dev_rgb = dev_rgbv;</a>
<a name="ln4180"> </a>
<a name="ln4181">    // prepare derivatives buffers</a>
<a name="ln4182">    for(int n = 0; n &lt; ndir; n++)</a>
<a name="ln4183">    {</a>
<a name="ln4184">      dev_drv[n] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * sizeof(float));</a>
<a name="ln4185">      if(dev_drv[n] == NULL) goto error;</a>
<a name="ln4186">    }</a>
<a name="ln4187"> </a>
<a name="ln4188">    // convert to perceptual colorspace and differentiate in all directions</a>
<a name="ln4189">    const int pad_yuv = (passes == 1) ? 8 : 13;</a>
<a name="ln4190">    dt_opencl_local_buffer_t locopt_diff</a>
<a name="ln4191">      = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln4192">                                    .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4193">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4194"> </a>
<a name="ln4195">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_differentiate, &amp;locopt_diff))</a>
<a name="ln4196">    goto error;</a>
<a name="ln4197"> </a>
<a name="ln4198">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4199">    {</a>
<a name="ln4200">      // convert to perceptual YPbPr colorspace</a>
<a name="ln4201">      size_t sizes_yuv[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4202">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[d]);</a>
<a name="ln4203">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4204">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4205">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4206">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 4, sizeof(int), (void *)&amp;pad_yuv);</a>
<a name="ln4207">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_convert_yuv, sizes_yuv);</a>
<a name="ln4208">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4209"> </a>
<a name="ln4210"> </a>
<a name="ln4211">      // differentiate in all directions</a>
<a name="ln4212">      size_t sizes_diff[3] = { ROUNDUP(width, locopt_diff.sizex), ROUNDUP(height, locopt_diff.sizey), 1 };</a>
<a name="ln4213">      size_t local_diff[3] = { locopt_diff.sizex, locopt_diff.sizey, 1 };</a>
<a name="ln4214">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 0, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4215">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 1, sizeof(cl_mem), (void *)&amp;dev_drv[d]);</a>
<a name="ln4216">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4217">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4218">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 4, sizeof(int), (void *)&amp;pad_yuv);</a>
<a name="ln4219">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 5, sizeof(int), (void *)&amp;d);</a>
<a name="ln4220">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 6,</a>
<a name="ln4221">                              (locopt_diff.sizex + 2*1) * (locopt_diff.sizey + 2*1) * 4 * sizeof(float), NULL);</a>
<a name="ln4222">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_differentiate, sizes_diff, local_diff);</a>
<a name="ln4223">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4224">    }</a>
<a name="ln4225"> </a>
<a name="ln4226">    // reserve buffers for homogeneity maps and sum maps</a>
<a name="ln4227">    for(int n = 0; n &lt; ndir; n++)</a>
<a name="ln4228">    {</a>
<a name="ln4229">      dev_homo[n] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * sizeof(unsigned char));</a>
<a name="ln4230">      if(dev_homo[n] == NULL) goto error;</a>
<a name="ln4231"> </a>
<a name="ln4232">      dev_homosum[n] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * sizeof(unsigned char));</a>
<a name="ln4233">      if(dev_homosum[n] == NULL) goto error;</a>
<a name="ln4234">    }</a>
<a name="ln4235"> </a>
<a name="ln4236">    // get thresholds for homogeneity map (store them in dev_aux)</a>
<a name="ln4237">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4238">    {</a>
<a name="ln4239">      const int pad_homo = (passes == 1) ? 10 : 15;</a>
<a name="ln4240">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4241">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 0, sizeof(cl_mem), (void *)&amp;dev_drv[d]);</a>
<a name="ln4242">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4243">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4244">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4245">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 4, sizeof(int), (void *)&amp;pad_homo);</a>
<a name="ln4246">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 5, sizeof(int), (void *)&amp;d);</a>
<a name="ln4247">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_homo_threshold, sizes);</a>
<a name="ln4248">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4249">    }</a>
<a name="ln4250"> </a>
<a name="ln4251">    // set homogeneity maps</a>
<a name="ln4252">    const int pad_homo = (passes == 1) ? 10 : 15;</a>
<a name="ln4253">    dt_opencl_local_buffer_t locopt_homo</a>
<a name="ln4254">      = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln4255">                                    .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln4256">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4257"> </a>
<a name="ln4258">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_homo_set, &amp;locopt_homo))</a>
<a name="ln4259">    goto error;</a>
<a name="ln4260"> </a>
<a name="ln4261">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4262">    {</a>
<a name="ln4263">      size_t sizes[3] = { ROUNDUP(width, locopt_homo.sizex),ROUNDUP(height, locopt_homo.sizey), 1 };</a>
<a name="ln4264">      size_t local[3] = { locopt_homo.sizex, locopt_homo.sizey, 1 };</a>
<a name="ln4265">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 0, sizeof(cl_mem), (void *)&amp;dev_drv[d]);</a>
<a name="ln4266">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4267">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 2, sizeof(cl_mem), (void *)&amp;dev_homo[d]);</a>
<a name="ln4268">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 3, sizeof(int), (void *)&amp;width);</a>
<a name="ln4269">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 4, sizeof(int), (void *)&amp;height);</a>
<a name="ln4270">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 5, sizeof(int), (void *)&amp;pad_homo);</a>
<a name="ln4271">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 6,</a>
<a name="ln4272">                              (locopt_homo.sizex + 2*1) * (locopt_homo.sizey + 2*1) * sizeof(float), NULL);</a>
<a name="ln4273">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_homo_set, sizes, local);</a>
<a name="ln4274">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4275">    }</a>
<a name="ln4276"> </a>
<a name="ln4277">    // get rid of dev_drv buffers</a>
<a name="ln4278">    for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4279">    {</a>
<a name="ln4280">      dt_opencl_release_mem_object(dev_drv[n]);</a>
<a name="ln4281">      dev_drv[n] = NULL;</a>
<a name="ln4282">    }</a>
<a name="ln4283"> </a>
<a name="ln4284">    // build 5x5 sum of homogeneity maps for each pixel and direction</a>
<a name="ln4285">    dt_opencl_local_buffer_t locopt_homo_sum</a>
<a name="ln4286">      = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln4287">                                    .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln4288">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4289"> </a>
<a name="ln4290">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_homo_sum, &amp;locopt_homo_sum))</a>
<a name="ln4291">    goto error;</a>
<a name="ln4292"> </a>
<a name="ln4293">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4294">    {</a>
<a name="ln4295">      size_t sizes[3] = { ROUNDUP(width, locopt_homo_sum.sizex), ROUNDUP(height, locopt_homo_sum.sizey), 1 };</a>
<a name="ln4296">      size_t local[3] = { locopt_homo_sum.sizex, locopt_homo_sum.sizey, 1 };</a>
<a name="ln4297">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 0, sizeof(cl_mem), (void *)&amp;dev_homo[d]);</a>
<a name="ln4298">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 1, sizeof(cl_mem), (void *)&amp;dev_homosum[d]);</a>
<a name="ln4299">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4300">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4301">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 4, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4302">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 5,</a>
<a name="ln4303">                              (locopt_homo_sum.sizex + 2*2) * (locopt_homo_sum.sizey + 2*2) * sizeof(char), NULL);</a>
<a name="ln4304">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_homo_sum, sizes, local);</a>
<a name="ln4305">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4306">    }</a>
<a name="ln4307"> </a>
<a name="ln4308">    // get maximum of homogeneity maps (store in dev_aux)</a>
<a name="ln4309">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4310">    {</a>
<a name="ln4311">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4312">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 0, sizeof(cl_mem), (void *)&amp;dev_homosum[d]);</a>
<a name="ln4313">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4314">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4315">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4316">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 4, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4317">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 5, sizeof(int), (void *)&amp;d);</a>
<a name="ln4318">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_homo_max, sizes);</a>
<a name="ln4319">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4320">    }</a>
<a name="ln4321"> </a>
<a name="ln4322">    {</a>
<a name="ln4323">      // adjust maximum value</a>
<a name="ln4324">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4325">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max_corr, 0, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4326">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max_corr, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln4327">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max_corr, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln4328">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max_corr, 3, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4329">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_homo_max_corr, sizes);</a>
<a name="ln4330">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4331">    }</a>
<a name="ln4332"> </a>
<a name="ln4333">    // for Markesteijn-3: use only one of two directions if there is a difference in homogeneity</a>
<a name="ln4334">    for(int d = 0; d &lt; ndir - 4; d++)</a>
<a name="ln4335">    {</a>
<a name="ln4336">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4337">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 0, sizeof(cl_mem), (void *)&amp;dev_homosum[d]);</a>
<a name="ln4338">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 1, sizeof(cl_mem), (void *)&amp;dev_homosum[d + 4]);</a>
<a name="ln4339">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4340">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4341">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 4, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4342">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_homo_quench, sizes);</a>
<a name="ln4343">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4344">    }</a>
<a name="ln4345"> </a>
<a name="ln4346">    {</a>
<a name="ln4347">      // initialize output buffer to zero</a>
<a name="ln4348">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4349">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_zero, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln4350">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_zero, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln4351">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_zero, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln4352">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_zero, 3, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4353">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_zero, sizes);</a>
<a name="ln4354">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4355">    }</a>
<a name="ln4356"> </a>
<a name="ln4357">    // need to get another temp buffer for the output image (may use the space of dev_drv[] freed earlier)</a>
<a name="ln4358">    dev_tmptmp = dt_opencl_alloc_device(devid, (size_t)width, height, 4 * sizeof(float));</a>
<a name="ln4359">    if(dev_tmptmp == NULL) goto error;</a>
<a name="ln4360"> </a>
<a name="ln4361">    cl_mem dev_t1 = dev_tmp;</a>
<a name="ln4362">    cl_mem dev_t2 = dev_tmptmp;</a>
<a name="ln4363"> </a>
<a name="ln4364">    // accumulate all contributions</a>
<a name="ln4365">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4366">    {</a>
<a name="ln4367">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4368">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 0, sizeof(cl_mem), (void *)&amp;dev_t1);</a>
<a name="ln4369">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 1, sizeof(cl_mem), (void *)&amp;dev_t2);</a>
<a name="ln4370">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 2, sizeof(cl_mem), (void *)&amp;dev_rgbv[d]);</a>
<a name="ln4371">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 3, sizeof(cl_mem), (void *)&amp;dev_homosum[d]);</a>
<a name="ln4372">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 4, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4373">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 5, sizeof(int), (void *)&amp;width);</a>
<a name="ln4374">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 6, sizeof(int), (void *)&amp;height);</a>
<a name="ln4375">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 7, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4376">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_accu, sizes);</a>
<a name="ln4377">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4378"> </a>
<a name="ln4379">      // swap buffers</a>
<a name="ln4380">      cl_mem dev_t = dev_t2;</a>
<a name="ln4381">      dev_t2 = dev_t1;</a>
<a name="ln4382">      dev_t1 = dev_t;</a>
<a name="ln4383">    }</a>
<a name="ln4384"> </a>
<a name="ln4385">    // copy output to dev_tmptmp (if not already there)</a>
<a name="ln4386">    // note: we need to take swap of buffers into account, so current output lies in dev_t1</a>
<a name="ln4387">    if(dev_t1 != dev_tmptmp)</a>
<a name="ln4388">    {</a>
<a name="ln4389">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln4390">      size_t region[] = { width, height, 1 };</a>
<a name="ln4391">      err = dt_opencl_enqueue_copy_image(devid, dev_t1, dev_tmptmp, origin, origin, region);</a>
<a name="ln4392">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4393">    }</a>
<a name="ln4394"> </a>
<a name="ln4395">    {</a>
<a name="ln4396">      // process the final image</a>
<a name="ln4397">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4398">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 0, sizeof(cl_mem), (void *)&amp;dev_tmptmp);</a>
<a name="ln4399">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln4400">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4401">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4402">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 4, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4403">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 5, 4*sizeof(float), (void *)processed_maximum);</a>
<a name="ln4404">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_final, sizes);</a>
<a name="ln4405">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4406">    }</a>
<a name="ln4407"> </a>
<a name="ln4408">    // now it's time to get rid of most of the temporary buffers (except of dev_tmp and dev_xtrans)</a>
<a name="ln4409">    for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4410">    {</a>
<a name="ln4411">      dt_opencl_release_mem_object(dev_rgbv[n]);</a>
<a name="ln4412">      dev_rgbv[n] = NULL;</a>
<a name="ln4413">    }</a>
<a name="ln4414"> </a>
<a name="ln4415">    for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4416">    {</a>
<a name="ln4417">      dt_opencl_release_mem_object(dev_homo[n]);</a>
<a name="ln4418">      dev_homo[n] = NULL;</a>
<a name="ln4419">    }</a>
<a name="ln4420"> </a>
<a name="ln4421">    for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4422">    {</a>
<a name="ln4423">      dt_opencl_release_mem_object(dev_homosum[n]);</a>
<a name="ln4424">      dev_homosum[n] = NULL;</a>
<a name="ln4425">    }</a>
<a name="ln4426"> </a>
<a name="ln4427">    dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln4428">    dev_aux = NULL;</a>
<a name="ln4429"> </a>
<a name="ln4430">    dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln4431">    dev_xtrans = NULL;</a>
<a name="ln4432"> </a>
<a name="ln4433">    dt_opencl_release_mem_object(dev_allhex);</a>
<a name="ln4434">    dev_allhex = NULL;</a>
<a name="ln4435"> </a>
<a name="ln4436">    dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln4437">    dev_green_eq = NULL;</a>
<a name="ln4438"> </a>
<a name="ln4439">    dt_opencl_release_mem_object(dev_tmptmp);</a>
<a name="ln4440">    dev_tmptmp = NULL;</a>
<a name="ln4441"> </a>
<a name="ln4442">    // take care of image borders. the algorihm above leaves an unprocessed border of pad_tile pixels.</a>
<a name="ln4443">    // strategy: take the four edges and process them each with process_vng_cl(). as VNG produces</a>
<a name="ln4444">    // an image with a border with only linear interpolation we process edges of pad_tile+3px and</a>
<a name="ln4445">    // drop 3px on the inner side if possible</a>
<a name="ln4446"> </a>
<a name="ln4447">    // take care of some degenerate cases (which might happen if we are called in a tiling context)</a>
<a name="ln4448">    const int wd = (width &gt; pad_tile+3) ? pad_tile+3 : width;</a>
<a name="ln4449">    const int ht = (height &gt; pad_tile+3) ? pad_tile+3 : height;</a>
<a name="ln4450">    const int wdc = (wd &gt;= pad_tile+3) ? 3 : 0;</a>
<a name="ln4451">    const int htc = (ht &gt;= pad_tile+3) ? 3 : 0;</a>
<a name="ln4452"> </a>
<a name="ln4453">    // the data of all four edges:</a>
<a name="ln4454">    // total edge: x-offset, y-offset, width, height,</a>
<a name="ln4455">    // after dropping: x-offset adjust, y-offset adjust, width adjust, height adjust</a>
<a name="ln4456">    const int edges[4][8] = { { 0, 0, wd, height, 0, 0, -wdc, 0 },</a>
<a name="ln4457">                              { 0, 0, width, ht, 0, 0, 0, -htc },</a>
<a name="ln4458">                              { width - wd, 0, wd, height, wdc, 0, -wdc, 0 },</a>
<a name="ln4459">                              { 0, height - ht, width, ht, 0, htc, 0, -htc } };</a>
<a name="ln4460"> </a>
<a name="ln4461">    for(int n = 0; n &lt; 4; n++)</a>
<a name="ln4462">    {</a>
<a name="ln4463">      dt_iop_roi_t roi = { roi_in-&gt;x + edges[n][0], roi_in-&gt;y + edges[n][1], edges[n][2], edges[n][3], 1.0f };</a>
<a name="ln4464"> </a>
<a name="ln4465">      size_t iorigin[] = { edges[n][0], edges[n][1], 0 };</a>
<a name="ln4466">      size_t oorigin[] = { 0, 0, 0 };</a>
<a name="ln4467">      size_t region[] = { edges[n][2], edges[n][3], 1 };</a>
<a name="ln4468"> </a>
<a name="ln4469">      // reserve input buffer for image edge</a>
<a name="ln4470">      dev_edge_in = dt_opencl_alloc_device(devid, edges[n][2], edges[n][3], sizeof(float));</a>
<a name="ln4471">      if(dev_edge_in == NULL) goto error;</a>
<a name="ln4472"> </a>
<a name="ln4473">      // reserve output buffer for VNG processing of edge</a>
<a name="ln4474">      dev_edge_out = dt_opencl_alloc_device(devid, edges[n][2], edges[n][3], 4 * sizeof(float));</a>
<a name="ln4475">      if(dev_edge_out == NULL) goto error;</a>
<a name="ln4476"> </a>
<a name="ln4477">      // copy edge to input buffer</a>
<a name="ln4478">      err = dt_opencl_enqueue_copy_image(devid, dev_in, dev_edge_in, iorigin, oorigin, region);</a>
<a name="ln4479">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4480"> </a>
<a name="ln4481">      // VNG processing</a>
<a name="ln4482">      if(!process_vng_cl(self, piece, dev_edge_in, dev_edge_out, &amp;roi, &amp;roi))</a>
<a name="ln4483">        goto error;</a>
<a name="ln4484"> </a>
<a name="ln4485">      // adjust for &quot;good&quot; part, dropping linear border where possible</a>
<a name="ln4486">      iorigin[0] += edges[n][4];</a>
<a name="ln4487">      iorigin[1] += edges[n][5];</a>
<a name="ln4488">      oorigin[0] += edges[n][4];</a>
<a name="ln4489">      oorigin[1] += edges[n][5];</a>
<a name="ln4490">      region[0] += edges[n][6];</a>
<a name="ln4491">      region[1] += edges[n][7];</a>
<a name="ln4492"> </a>
<a name="ln4493">      // copy output</a>
<a name="ln4494">      err = dt_opencl_enqueue_copy_image(devid, dev_edge_out, dev_tmp, oorigin, iorigin, region);</a>
<a name="ln4495">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4496"> </a>
<a name="ln4497">      // release intermediate buffers</a>
<a name="ln4498">      dt_opencl_release_mem_object(dev_edge_in);</a>
<a name="ln4499">      dt_opencl_release_mem_object(dev_edge_out);</a>
<a name="ln4500">      dev_edge_in = dev_edge_out = NULL;</a>
<a name="ln4501">    }</a>
<a name="ln4502"> </a>
<a name="ln4503"> </a>
<a name="ln4504">    if(scaled)</a>
<a name="ln4505">    {</a>
<a name="ln4506">      // scale temp buffer to output buffer</a>
<a name="ln4507">      err = dt_iop_clip_and_zoom_roi_cl(devid, dev_out, dev_tmp, roi_out, roi_in);</a>
<a name="ln4508">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4509">    }</a>
<a name="ln4510">  }</a>
<a name="ln4511">  else</a>
<a name="ln4512">  {</a>
<a name="ln4513">    // sample third-size image</a>
<a name="ln4514">    const int width = roi_out-&gt;width;</a>
<a name="ln4515">    const int height = roi_out-&gt;height;</a>
<a name="ln4516"> </a>
<a name="ln4517">    size_t sizes[2] = { ROUNDUPWD(width), ROUNDUPHT(height) };</a>
<a name="ln4518">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln4519">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 1, sizeof(cl_mem), &amp;dev_out);</a>
<a name="ln4520">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 2, sizeof(int), &amp;width);</a>
<a name="ln4521">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 3, sizeof(int), &amp;height);</a>
<a name="ln4522">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4523">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4524">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 6, sizeof(int), (void *)&amp;roi_in-&gt;width);</a>
<a name="ln4525">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 7, sizeof(int), (void *)&amp;roi_in-&gt;height);</a>
<a name="ln4526">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 8, sizeof(float), (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln4527">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 9, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4528">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_third_size, sizes);</a>
<a name="ln4529">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln4530">  }</a>
<a name="ln4531"> </a>
<a name="ln4532">  // free remaining temporary buffers</a>
<a name="ln4533">  if(dev_tmp != dev_out) dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln4534">  dev_tmp = NULL;</a>
<a name="ln4535"> </a>
<a name="ln4536">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln4537">  dev_xtrans = NULL;</a>
<a name="ln4538"> </a>
<a name="ln4539"> </a>
<a name="ln4540">  // color smoothing</a>
<a name="ln4541">  if(data-&gt;color_smoothing)</a>
<a name="ln4542">  {</a>
<a name="ln4543">    if(!color_smoothing_cl(self, piece, dev_out, dev_out, roi_out))</a>
<a name="ln4544">      goto error;</a>
<a name="ln4545">  }</a>
<a name="ln4546"> </a>
<a name="ln4547">  return TRUE;</a>
<a name="ln4548"> </a>
<a name="ln4549">error:</a>
<a name="ln4550">  if(dev_tmp != dev_out) dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln4551"> </a>
<a name="ln4552">  for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4553">    dt_opencl_release_mem_object(dev_rgbv[n]);</a>
<a name="ln4554">  for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4555">    dt_opencl_release_mem_object(dev_drv[n]);</a>
<a name="ln4556">  for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4557">    dt_opencl_release_mem_object(dev_homo[n]);</a>
<a name="ln4558">  for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4559">    dt_opencl_release_mem_object(dev_homosum[n]);</a>
<a name="ln4560">  dt_opencl_release_mem_object(dev_gminmax);</a>
<a name="ln4561">  dt_opencl_release_mem_object(dev_tmptmp);</a>
<a name="ln4562">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln4563">  dt_opencl_release_mem_object(dev_allhex);</a>
<a name="ln4564">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln4565">  dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln4566">  dt_opencl_release_mem_object(dev_edge_in);</a>
<a name="ln4567">  dt_opencl_release_mem_object(dev_edge_out);</a>
<a name="ln4568">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln4569">  return FALSE;</a>
<a name="ln4570">}</a>
<a name="ln4571"> </a>
<a name="ln4572">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln4573">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln4574">{</a>
<a name="ln4575">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln4576">  const int demosaicing_method = data-&gt;demosaicing_method;</a>
<a name="ln4577">  const int qual_flags = demosaic_qual_flags(piece, &amp;self-&gt;dev-&gt;image_storage, roi_out);</a>
<a name="ln4578"> </a>
<a name="ln4579">  if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME || demosaicing_method == DT_IOP_DEMOSAIC_PPG)</a>
<a name="ln4580">  {</a>
<a name="ln4581">    return process_default_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln4582">  }</a>
<a name="ln4583">  else if(demosaicing_method ==  DT_IOP_DEMOSAIC_VNG4 || demosaicing_method == DT_IOP_DEMOSAIC_VNG)</a>
<a name="ln4584">  {</a>
<a name="ln4585">    return process_vng_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln4586">  }</a>
<a name="ln4587">  else if((demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN || demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3) &amp;&amp;</a>
<a name="ln4588">    !(qual_flags &amp; DEMOSAIC_XTRANS_FULL))</a>
<a name="ln4589">  {</a>
<a name="ln4590">    return process_vng_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln4591">  }</a>
<a name="ln4592">  else if(demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN || demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3)</a>
<a name="ln4593">  {</a>
<a name="ln4594">    return process_markesteijn_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln4595">  }</a>
<a name="ln4596">  else</a>
<a name="ln4597">  {</a>
<a name="ln4598">    dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic] demosaicing method '%s' not yet supported by opencl code\n&quot;, method2string(demosaicing_method));</a>
<a name="ln4599">    return FALSE;</a>
<a name="ln4600">  }</a>
<a name="ln4601">}</a>
<a name="ln4602">#endif</a>
<a name="ln4603"> </a>
<a name="ln4604">void tiling_callback(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln4605">                     const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out,</a>
<a name="ln4606">                     struct dt_develop_tiling_t *tiling)</a>
<a name="ln4607">{</a>
<a name="ln4608">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln4609"> </a>
<a name="ln4610">  const float ioratio = (float)roi_out-&gt;width * roi_out-&gt;height / ((float)roi_in-&gt;width * roi_in-&gt;height);</a>
<a name="ln4611">  const float smooth = data-&gt;color_smoothing ? ioratio : 0.0f;</a>
<a name="ln4612">  const float greeneq</a>
<a name="ln4613">      = ((piece-&gt;pipe-&gt;dsc.filters != 9u) &amp;&amp; (data-&gt;green_eq != DT_IOP_GREEN_EQ_NO)) ? 0.25f : 0.0f;</a>
<a name="ln4614">  const dt_iop_demosaic_method_t demosaicing_method = data-&gt;demosaicing_method;</a>
<a name="ln4615"> </a>
<a name="ln4616">  const int qual_flags = demosaic_qual_flags(piece, &amp;self-&gt;dev-&gt;image_storage, roi_out);</a>
<a name="ln4617">  const int full_scale_demosaicing = qual_flags &amp; DEMOSAIC_FULL_SCALE;</a>
<a name="ln4618"> </a>
<a name="ln4619">  // check if output buffer has same dimension as input buffer (thus avoiding one</a>
<a name="ln4620">  // additional temporary buffer)</a>
<a name="ln4621">  const int unscaled = (roi_out-&gt;width == roi_in-&gt;width &amp;&amp; roi_out-&gt;height == roi_in-&gt;height);</a>
<a name="ln4622"> </a>
<a name="ln4623">  if((demosaicing_method == DT_IOP_DEMOSAIC_PPG) ||</a>
<a name="ln4624">      (demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME) ||</a>
<a name="ln4625">      (demosaicing_method == DT_IOP_DEMOSAIC_AMAZE))</a>
<a name="ln4626">  {</a>
<a name="ln4627">    // Bayer pattern with PPG, Monochrome and Amaze</a>
<a name="ln4628">    tiling-&gt;factor = 1.0f + ioratio;         // in + out</a>
<a name="ln4629"> </a>
<a name="ln4630">    if(full_scale_demosaicing &amp;&amp; unscaled)</a>
<a name="ln4631">      tiling-&gt;factor += fmax(1.0f + greeneq, smooth);  // + tmp + geeneq | + smooth</a>
<a name="ln4632">    else if(full_scale_demosaicing)</a>
<a name="ln4633">      tiling-&gt;factor += fmax(2.0f + greeneq, smooth);  // + tmp + aux + greeneq | + smooth</a>
<a name="ln4634">    else</a>
<a name="ln4635">      tiling-&gt;factor += smooth;                        // + smooth</a>
<a name="ln4636"> </a>
<a name="ln4637">    tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln4638">    tiling-&gt;overhead = 0;</a>
<a name="ln4639">    tiling-&gt;xalign = 2;</a>
<a name="ln4640">    tiling-&gt;yalign = 2;</a>
<a name="ln4641">    tiling-&gt;overlap = 5; // take care of border handling</a>
<a name="ln4642">  }</a>
<a name="ln4643">  else if(((demosaicing_method ==  DT_IOP_DEMOSAIC_MARKESTEIJN) ||</a>
<a name="ln4644">           (demosaicing_method ==  DT_IOP_DEMOSAIC_MARKESTEIJN_3) ||</a>
<a name="ln4645">           (demosaicing_method == DT_IOP_DEMOSAIC_FDC)) &amp;&amp;</a>
<a name="ln4646">          (qual_flags &amp; DEMOSAIC_XTRANS_FULL))</a>
<a name="ln4647">  {</a>
<a name="ln4648">    // X-Trans pattern full Markesteijn processing</a>
<a name="ln4649">    const int ndir = (demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3) ? 8 : 4;</a>
<a name="ln4650">    const int overlap = (demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3) ? 17 : 12;</a>
<a name="ln4651"> </a>
<a name="ln4652">    tiling-&gt;factor = 1.0f + ioratio;</a>
<a name="ln4653">    tiling-&gt;factor += ndir * 1.0f      // rgb</a>
<a name="ln4654">                      + ndir * 0.25f   // drv</a>
<a name="ln4655">                      + ndir * 0.125f  // homo + homosum</a>
<a name="ln4656">                      + 1.0f;          // aux</a>
<a name="ln4657"> </a>
<a name="ln4658">    if(full_scale_demosaicing &amp;&amp; unscaled)</a>
<a name="ln4659">      tiling-&gt;factor += fmax(1.0f + greeneq, smooth);</a>
<a name="ln4660">    else if(full_scale_demosaicing)</a>
<a name="ln4661">      tiling-&gt;factor += fmax(2.0f + greeneq, smooth);</a>
<a name="ln4662">    else</a>
<a name="ln4663">      tiling-&gt;factor += smooth;</a>
<a name="ln4664"> </a>
<a name="ln4665">    tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln4666">    tiling-&gt;overhead = 0;</a>
<a name="ln4667">    tiling-&gt;xalign = 3;</a>
<a name="ln4668">    tiling-&gt;yalign = 3;</a>
<a name="ln4669">    tiling-&gt;overlap = overlap;</a>
<a name="ln4670">  }</a>
<a name="ln4671">  else</a>
<a name="ln4672">  {</a>
<a name="ln4673">    // VNG</a>
<a name="ln4674">    tiling-&gt;factor = 1.0f + ioratio;</a>
<a name="ln4675"> </a>
<a name="ln4676">    if(full_scale_demosaicing &amp;&amp; unscaled)</a>
<a name="ln4677">      tiling-&gt;factor += fmax(1.0f + greeneq, smooth);</a>
<a name="ln4678">    else if(full_scale_demosaicing)</a>
<a name="ln4679">      tiling-&gt;factor += fmax(2.0f + greeneq, smooth);</a>
<a name="ln4680">    else</a>
<a name="ln4681">      tiling-&gt;factor += smooth;</a>
<a name="ln4682"> </a>
<a name="ln4683">    tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln4684">    tiling-&gt;overhead = 0;</a>
<a name="ln4685">    tiling-&gt;xalign = 6; // covering Bayer pattern for VNG4 as well as xtrans for VNG</a>
<a name="ln4686">    tiling-&gt;yalign = 6; // covering Bayer pattern for VNG4 as well as xtrans for VNG</a>
<a name="ln4687">    tiling-&gt;overlap = 6;</a>
<a name="ln4688">  }</a>
<a name="ln4689">  return;</a>
<a name="ln4690">}</a>
<a name="ln4691"> </a>
<a name="ln4692"> </a>
<a name="ln4693"> </a>
<a name="ln4694">void init(dt_iop_module_t *module)</a>
<a name="ln4695">{</a>
<a name="ln4696">  module-&gt;params = calloc(1, sizeof(dt_iop_demosaic_params_t));</a>
<a name="ln4697">  module-&gt;default_params = calloc(1, sizeof(dt_iop_demosaic_params_t));</a>
<a name="ln4698">  module-&gt;default_enabled = 1;</a>
<a name="ln4699">  module-&gt;hide_enable_button = 1;</a>
<a name="ln4700">  module-&gt;params_size = sizeof(dt_iop_demosaic_params_t);</a>
<a name="ln4701">  module-&gt;gui_data = NULL;</a>
<a name="ln4702">}</a>
<a name="ln4703"> </a>
<a name="ln4704">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln4705">{</a>
<a name="ln4706">  const int program = 0; // from programs.conf</a>
<a name="ln4707">  dt_iop_demosaic_global_data_t *gd</a>
<a name="ln4708">      = (dt_iop_demosaic_global_data_t *)malloc(sizeof(dt_iop_demosaic_global_data_t));</a>
<a name="ln4709">  module-&gt;data = gd;</a>
<a name="ln4710">  gd-&gt;kernel_zoom_half_size = dt_opencl_create_kernel(program, &quot;clip_and_zoom_demosaic_half_size&quot;);</a>
<a name="ln4711">  gd-&gt;kernel_ppg_green = dt_opencl_create_kernel(program, &quot;ppg_demosaic_green&quot;);</a>
<a name="ln4712">  gd-&gt;kernel_green_eq_lavg = dt_opencl_create_kernel(program, &quot;green_equilibration_lavg&quot;);</a>
<a name="ln4713">  gd-&gt;kernel_green_eq_favg_reduce_first = dt_opencl_create_kernel(program, &quot;green_equilibration_favg_reduce_first&quot;);</a>
<a name="ln4714">  gd-&gt;kernel_green_eq_favg_reduce_second = dt_opencl_create_kernel(program, &quot;green_equilibration_favg_reduce_second&quot;);</a>
<a name="ln4715">  gd-&gt;kernel_green_eq_favg_apply = dt_opencl_create_kernel(program, &quot;green_equilibration_favg_apply&quot;);</a>
<a name="ln4716">  gd-&gt;kernel_pre_median = dt_opencl_create_kernel(program, &quot;pre_median&quot;);</a>
<a name="ln4717">  gd-&gt;kernel_ppg_redblue = dt_opencl_create_kernel(program, &quot;ppg_demosaic_redblue&quot;);</a>
<a name="ln4718">  gd-&gt;kernel_downsample = dt_opencl_create_kernel(program, &quot;clip_and_zoom&quot;);</a>
<a name="ln4719">  gd-&gt;kernel_border_interpolate = dt_opencl_create_kernel(program, &quot;border_interpolate&quot;);</a>
<a name="ln4720">  gd-&gt;kernel_color_smoothing = dt_opencl_create_kernel(program, &quot;color_smoothing&quot;);</a>
<a name="ln4721"> </a>
<a name="ln4722">  const int other = 14; // from programs.conf</a>
<a name="ln4723">  gd-&gt;kernel_passthrough_monochrome = dt_opencl_create_kernel(other, &quot;passthrough_monochrome&quot;);</a>
<a name="ln4724">  gd-&gt;kernel_zoom_passthrough_monochrome</a>
<a name="ln4725">      = dt_opencl_create_kernel(other, &quot;clip_and_zoom_demosaic_passthrough_monochrome&quot;);</a>
<a name="ln4726"> </a>
<a name="ln4727">  const int vng = 15; // from programs.conf</a>
<a name="ln4728">  gd-&gt;kernel_vng_border_interpolate = dt_opencl_create_kernel(vng, &quot;vng_border_interpolate&quot;);</a>
<a name="ln4729">  gd-&gt;kernel_vng_lin_interpolate = dt_opencl_create_kernel(vng, &quot;vng_lin_interpolate&quot;);</a>
<a name="ln4730">  gd-&gt;kernel_zoom_third_size = dt_opencl_create_kernel(vng, &quot;clip_and_zoom_demosaic_third_size_xtrans&quot;);</a>
<a name="ln4731">  gd-&gt;kernel_vng_green_equilibrate = dt_opencl_create_kernel(vng, &quot;vng_green_equilibrate&quot;);</a>
<a name="ln4732">  gd-&gt;kernel_vng_interpolate = dt_opencl_create_kernel(vng, &quot;vng_interpolate&quot;);</a>
<a name="ln4733"> </a>
<a name="ln4734">  const int markesteijn = 16; // from programs.conf</a>
<a name="ln4735">  gd-&gt;kernel_markesteijn_initial_copy = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_initial_copy&quot;);</a>
<a name="ln4736">  gd-&gt;kernel_markesteijn_green_minmax = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_green_minmax&quot;);</a>
<a name="ln4737">  gd-&gt;kernel_markesteijn_interpolate_green = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_interpolate_green&quot;);</a>
<a name="ln4738">  gd-&gt;kernel_markesteijn_solitary_green = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_solitary_green&quot;);</a>
<a name="ln4739">  gd-&gt;kernel_markesteijn_recalculate_green = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_recalculate_green&quot;);</a>
<a name="ln4740">  gd-&gt;kernel_markesteijn_red_and_blue = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_red_and_blue&quot;);</a>
<a name="ln4741">  gd-&gt;kernel_markesteijn_interpolate_twoxtwo = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_interpolate_twoxtwo&quot;);</a>
<a name="ln4742">  gd-&gt;kernel_markesteijn_convert_yuv = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_convert_yuv&quot;);</a>
<a name="ln4743">  gd-&gt;kernel_markesteijn_differentiate = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_differentiate&quot;);</a>
<a name="ln4744">  gd-&gt;kernel_markesteijn_homo_threshold = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_threshold&quot;);</a>
<a name="ln4745">  gd-&gt;kernel_markesteijn_homo_set = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_set&quot;);</a>
<a name="ln4746">  gd-&gt;kernel_markesteijn_homo_sum = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_sum&quot;);</a>
<a name="ln4747">  gd-&gt;kernel_markesteijn_homo_max = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_max&quot;);</a>
<a name="ln4748">  gd-&gt;kernel_markesteijn_homo_max_corr = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_max_corr&quot;);</a>
<a name="ln4749">  gd-&gt;kernel_markesteijn_homo_quench = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_quench&quot;);</a>
<a name="ln4750">  gd-&gt;kernel_markesteijn_zero = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_zero&quot;);</a>
<a name="ln4751">  gd-&gt;kernel_markesteijn_accu = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_accu&quot;);</a>
<a name="ln4752">  gd-&gt;kernel_markesteijn_final = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_final&quot;);</a>
<a name="ln4753">}</a>
<a name="ln4754"> </a>
<a name="ln4755">void cleanup(dt_iop_module_t *module)</a>
<a name="ln4756">{</a>
<a name="ln4757">  free(module-&gt;params);</a>
<a name="ln4758">  module-&gt;params = NULL;</a>
<a name="ln4759">}</a>
<a name="ln4760"> </a>
<a name="ln4761">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln4762">{</a>
<a name="ln4763">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)module-&gt;data;</a>
<a name="ln4764">  dt_opencl_free_kernel(gd-&gt;kernel_zoom_half_size);</a>
<a name="ln4765">  dt_opencl_free_kernel(gd-&gt;kernel_ppg_green);</a>
<a name="ln4766">  dt_opencl_free_kernel(gd-&gt;kernel_pre_median);</a>
<a name="ln4767">  dt_opencl_free_kernel(gd-&gt;kernel_green_eq_lavg);</a>
<a name="ln4768">  dt_opencl_free_kernel(gd-&gt;kernel_green_eq_favg_reduce_first);</a>
<a name="ln4769">  dt_opencl_free_kernel(gd-&gt;kernel_green_eq_favg_reduce_second);</a>
<a name="ln4770">  dt_opencl_free_kernel(gd-&gt;kernel_green_eq_favg_apply);</a>
<a name="ln4771">  dt_opencl_free_kernel(gd-&gt;kernel_ppg_redblue);</a>
<a name="ln4772">  dt_opencl_free_kernel(gd-&gt;kernel_downsample);</a>
<a name="ln4773">  dt_opencl_free_kernel(gd-&gt;kernel_border_interpolate);</a>
<a name="ln4774">  dt_opencl_free_kernel(gd-&gt;kernel_color_smoothing);</a>
<a name="ln4775">  dt_opencl_free_kernel(gd-&gt;kernel_passthrough_monochrome);</a>
<a name="ln4776">  dt_opencl_free_kernel(gd-&gt;kernel_zoom_passthrough_monochrome);</a>
<a name="ln4777">  dt_opencl_free_kernel(gd-&gt;kernel_vng_border_interpolate);</a>
<a name="ln4778">  dt_opencl_free_kernel(gd-&gt;kernel_vng_lin_interpolate);</a>
<a name="ln4779">  dt_opencl_free_kernel(gd-&gt;kernel_zoom_third_size);</a>
<a name="ln4780">  dt_opencl_free_kernel(gd-&gt;kernel_vng_green_equilibrate);</a>
<a name="ln4781">  dt_opencl_free_kernel(gd-&gt;kernel_vng_interpolate);</a>
<a name="ln4782">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_initial_copy);</a>
<a name="ln4783">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_green_minmax);</a>
<a name="ln4784">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_interpolate_green);</a>
<a name="ln4785">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_solitary_green);</a>
<a name="ln4786">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_recalculate_green);</a>
<a name="ln4787">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_red_and_blue);</a>
<a name="ln4788">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_interpolate_twoxtwo);</a>
<a name="ln4789">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_convert_yuv);</a>
<a name="ln4790">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_differentiate);</a>
<a name="ln4791">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_threshold);</a>
<a name="ln4792">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_set);</a>
<a name="ln4793">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_sum);</a>
<a name="ln4794">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_max);</a>
<a name="ln4795">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_max_corr);</a>
<a name="ln4796">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_quench);</a>
<a name="ln4797">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_zero);</a>
<a name="ln4798">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_accu);</a>
<a name="ln4799">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_final);</a>
<a name="ln4800">  free(module-&gt;data);</a>
<a name="ln4801">  module-&gt;data = NULL;</a>
<a name="ln4802">}</a>
<a name="ln4803"> </a>
<a name="ln4804">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *params, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln4805">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4806">{</a>
<a name="ln4807">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)params;</a>
<a name="ln4808">  dt_iop_demosaic_data_t *d = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln4809">  if(!(pipe-&gt;image.flags &amp; DT_IMAGE_RAW)) piece-&gt;enabled = 0;</a>
<a name="ln4810">  d-&gt;green_eq = p-&gt;green_eq;</a>
<a name="ln4811">  d-&gt;color_smoothing = p-&gt;color_smoothing;</a>
<a name="ln4812">  d-&gt;median_thrs = p-&gt;median_thrs;</a>
<a name="ln4813">  d-&gt;demosaicing_method = p-&gt;demosaicing_method;</a>
<a name="ln4814"> </a>
<a name="ln4815">  if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME</a>
<a name="ln4816">     || p-&gt;demosaicing_method == (DEMOSAIC_XTRANS | DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME))</a>
<a name="ln4817">  {</a>
<a name="ln4818">    d-&gt;demosaicing_method = DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME;</a>
<a name="ln4819">    d-&gt;green_eq = DT_IOP_GREEN_EQ_NO;</a>
<a name="ln4820">    d-&gt;color_smoothing = 0;</a>
<a name="ln4821">    d-&gt;median_thrs = 0.0f;</a>
<a name="ln4822">  }</a>
<a name="ln4823"> </a>
<a name="ln4824">  if(d-&gt;demosaicing_method == DT_IOP_DEMOSAIC_AMAZE)</a>
<a name="ln4825">  {</a>
<a name="ln4826">    d-&gt;median_thrs = 0.0f;</a>
<a name="ln4827">  }</a>
<a name="ln4828"> </a>
<a name="ln4829">  // OpenCL only supported by some of the demosaicing methods</a>
<a name="ln4830">  switch(d-&gt;demosaicing_method)</a>
<a name="ln4831">  {</a>
<a name="ln4832">    case DT_IOP_DEMOSAIC_PPG:</a>
<a name="ln4833">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4834">      break;</a>
<a name="ln4835">    case DT_IOP_DEMOSAIC_AMAZE:</a>
<a name="ln4836">      piece-&gt;process_cl_ready = 0;</a>
<a name="ln4837">      break;</a>
<a name="ln4838">    case DT_IOP_DEMOSAIC_VNG4:</a>
<a name="ln4839">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4840">      break;</a>
<a name="ln4841">    case DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME:</a>
<a name="ln4842">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4843">      break;</a>
<a name="ln4844">    case DT_IOP_DEMOSAIC_VNG:</a>
<a name="ln4845">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4846">      break;</a>
<a name="ln4847">    case DT_IOP_DEMOSAIC_MARKESTEIJN:</a>
<a name="ln4848">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4849">      break;</a>
<a name="ln4850">    case DT_IOP_DEMOSAIC_MARKESTEIJN_3:</a>
<a name="ln4851">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4852">      break;</a>
<a name="ln4853">    case DT_IOP_DEMOSAIC_FDC:</a>
<a name="ln4854">      piece-&gt;process_cl_ready = 0;</a>
<a name="ln4855">      break;</a>
<a name="ln4856">    default:</a>
<a name="ln4857">      piece-&gt;process_cl_ready = 0;</a>
<a name="ln4858">  }</a>
<a name="ln4859"> </a>
<a name="ln4860">  // green-equilibrate over full image excludes tiling</a>
<a name="ln4861">  if(d-&gt;green_eq == DT_IOP_GREEN_EQ_FULL || d-&gt;green_eq == DT_IOP_GREEN_EQ_BOTH) piece-&gt;process_tiling_ready = 0;</a>
<a name="ln4862"> </a>
<a name="ln4863">  if (self-&gt;dev-&gt;image_storage.flags &amp; DT_IMAGE_4BAYER)</a>
<a name="ln4864">  {</a>
<a name="ln4865">    // 4Bayer images not implemented in OpenCL yet</a>
<a name="ln4866">    piece-&gt;process_cl_ready = 0;</a>
<a name="ln4867"> </a>
<a name="ln4868">    // Get and store the matrix to go from camera to RGB for 4Bayer images</a>
<a name="ln4869">    char *camera = self-&gt;dev-&gt;image_storage.camera_makermodel;</a>
<a name="ln4870">    if (!dt_colorspaces_conversion_matrices_rgb(camera, NULL, d-&gt;CAM_to_RGB, NULL))</a>
<a name="ln4871">    {</a>
<a name="ln4872">      fprintf(stderr, &quot;[colorspaces] `%s' color matrix not found for 4bayer image!\n&quot;, camera);</a>
<a name="ln4873">      dt_control_log(_(&quot;`%s' color matrix not found for 4bayer image!&quot;), camera);</a>
<a name="ln4874">    }</a>
<a name="ln4875">  }</a>
<a name="ln4876">}</a>
<a name="ln4877"> </a>
<a name="ln4878">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4879">{</a>
<a name="ln4880">  piece-&gt;data = malloc(sizeof(dt_iop_demosaic_data_t));</a>
<a name="ln4881">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln4882">}</a>
<a name="ln4883"> </a>
<a name="ln4884">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4885">{</a>
<a name="ln4886">  free(piece-&gt;data);</a>
<a name="ln4887">  piece-&gt;data = NULL;</a>
<a name="ln4888">}</a>
<a name="ln4889"> </a>
<a name="ln4890">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln4891">{</a>
<a name="ln4892">  dt_iop_demosaic_gui_data_t *g = (dt_iop_demosaic_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4893">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln4894"> </a>
<a name="ln4895">  if(self-&gt;dev-&gt;image_storage.buf_dsc.filters != 9u)</a>
<a name="ln4896">  {</a>
<a name="ln4897">    gtk_widget_show(g-&gt;demosaic_method_bayer);</a>
<a name="ln4898">    gtk_widget_hide(g-&gt;demosaic_method_xtrans);</a>
<a name="ln4899">    gtk_widget_show(g-&gt;median_thrs);</a>
<a name="ln4900">    gtk_widget_show(g-&gt;greeneq);</a>
<a name="ln4901">    dt_bauhaus_combobox_set(g-&gt;demosaic_method_bayer, p-&gt;demosaicing_method);</a>
<a name="ln4902">  }</a>
<a name="ln4903">  else</a>
<a name="ln4904">  {</a>
<a name="ln4905">    gtk_widget_show(g-&gt;demosaic_method_xtrans);</a>
<a name="ln4906">    gtk_widget_hide(g-&gt;demosaic_method_bayer);</a>
<a name="ln4907">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln4908">    gtk_widget_hide(g-&gt;greeneq);</a>
<a name="ln4909">    dt_bauhaus_combobox_set(g-&gt;demosaic_method_xtrans, p-&gt;demosaicing_method &amp; ~DEMOSAIC_XTRANS);</a>
<a name="ln4910">  }</a>
<a name="ln4911"> </a>
<a name="ln4912">  if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln4913">  {</a>
<a name="ln4914">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln4915">    gtk_widget_hide(g-&gt;color_smoothing);</a>
<a name="ln4916">    gtk_widget_hide(g-&gt;greeneq);</a>
<a name="ln4917">  }</a>
<a name="ln4918"> </a>
<a name="ln4919">  if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_AMAZE || p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_VNG4)</a>
<a name="ln4920">  {</a>
<a name="ln4921">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln4922">  }</a>
<a name="ln4923"> </a>
<a name="ln4924">  dt_bauhaus_slider_set(g-&gt;median_thrs, p-&gt;median_thrs);</a>
<a name="ln4925">  dt_bauhaus_combobox_set(g-&gt;color_smoothing, p-&gt;color_smoothing);</a>
<a name="ln4926">  dt_bauhaus_combobox_set(g-&gt;greeneq, p-&gt;green_eq);</a>
<a name="ln4927"> </a>
<a name="ln4928">  if(self-&gt;default_enabled)</a>
<a name="ln4929">  {</a>
<a name="ln4930">    gtk_widget_show(g-&gt;box_raw);</a>
<a name="ln4931">    gtk_widget_hide(g-&gt;label_non_raw);</a>
<a name="ln4932">  }</a>
<a name="ln4933">  else</a>
<a name="ln4934">  {</a>
<a name="ln4935">    gtk_widget_hide(g-&gt;box_raw);</a>
<a name="ln4936">    gtk_widget_show(g-&gt;label_non_raw);</a>
<a name="ln4937">  }</a>
<a name="ln4938">}</a>
<a name="ln4939"> </a>
<a name="ln4940">void reload_defaults(dt_iop_module_t *module)</a>
<a name="ln4941">{</a>
<a name="ln4942">  dt_iop_demosaic_params_t tmp</a>
<a name="ln4943">      = (dt_iop_demosaic_params_t){ .green_eq = DT_IOP_GREEN_EQ_NO,</a>
<a name="ln4944">                                    .median_thrs = 0.0f,</a>
<a name="ln4945">                                    .color_smoothing = 0,</a>
<a name="ln4946">                                    .demosaicing_method = DT_IOP_DEMOSAIC_PPG,</a>
<a name="ln4947">                                    .yet_unused_data_specific_to_demosaicing_method = 0 };</a>
<a name="ln4948"> </a>
<a name="ln4949">  // we might be called from presets update infrastructure =&gt; there is no image</a>
<a name="ln4950">  if(!module-&gt;dev) goto end;</a>
<a name="ln4951"> </a>
<a name="ln4952">  if(dt_image_is_monochrome(&amp;module-&gt;dev-&gt;image_storage))</a>
<a name="ln4953">    tmp.demosaicing_method = DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME;</a>
<a name="ln4954"> </a>
<a name="ln4955">  // only on for raw images:</a>
<a name="ln4956">  if(dt_image_is_raw(&amp;module-&gt;dev-&gt;image_storage))</a>
<a name="ln4957">    module-&gt;default_enabled = 1;</a>
<a name="ln4958">  else</a>
<a name="ln4959">    module-&gt;default_enabled = 0;</a>
<a name="ln4960"> </a>
<a name="ln4961">  if(module-&gt;dev-&gt;image_storage.buf_dsc.filters == 9u) tmp.demosaicing_method = DT_IOP_DEMOSAIC_MARKESTEIJN;</a>
<a name="ln4962"> </a>
<a name="ln4963">end:</a>
<a name="ln4964">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_demosaic_params_t));</a>
<a name="ln4965">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_demosaic_params_t));</a>
<a name="ln4966">}</a>
<a name="ln4967"> </a>
<a name="ln4968">static void median_thrs_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4969">{</a>
<a name="ln4970">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4971">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4972">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln4973">  p-&gt;median_thrs = dt_bauhaus_slider_get(slider);</a>
<a name="ln4974">  if(p-&gt;median_thrs &lt; 0.001f) p-&gt;median_thrs = 0.0f;</a>
<a name="ln4975">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4976">}</a>
<a name="ln4977"> </a>
<a name="ln4978">static void color_smoothing_callback(GtkWidget *button, gpointer user_data)</a>
<a name="ln4979">{</a>
<a name="ln4980">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4981">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4982">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln4983">  p-&gt;color_smoothing = dt_bauhaus_combobox_get(button);</a>
<a name="ln4984">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4985">}</a>
<a name="ln4986"> </a>
<a name="ln4987">static void greeneq_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln4988">{</a>
<a name="ln4989">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln4990">  int active = dt_bauhaus_combobox_get(combo);</a>
<a name="ln4991">  switch(active)</a>
<a name="ln4992">  {</a>
<a name="ln4993">    case DT_IOP_GREEN_EQ_FULL:</a>
<a name="ln4994">      p-&gt;green_eq = DT_IOP_GREEN_EQ_FULL;</a>
<a name="ln4995">      break;</a>
<a name="ln4996">    case DT_IOP_GREEN_EQ_LOCAL:</a>
<a name="ln4997">      p-&gt;green_eq = DT_IOP_GREEN_EQ_LOCAL;</a>
<a name="ln4998">      break;</a>
<a name="ln4999">    case DT_IOP_GREEN_EQ_BOTH:</a>
<a name="ln5000">      p-&gt;green_eq = DT_IOP_GREEN_EQ_BOTH;</a>
<a name="ln5001">      break;</a>
<a name="ln5002">    default:</a>
<a name="ln5003">    case DT_IOP_GREEN_EQ_NO:</a>
<a name="ln5004">      p-&gt;green_eq = DT_IOP_GREEN_EQ_NO;</a>
<a name="ln5005">      break;</a>
<a name="ln5006">  }</a>
<a name="ln5007">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln5008">}</a>
<a name="ln5009"> </a>
<a name="ln5010">static void demosaic_method_bayer_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln5011">{</a>
<a name="ln5012">  dt_iop_demosaic_gui_data_t *g = (dt_iop_demosaic_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln5013">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln5014">  int active = dt_bauhaus_combobox_get(combo);</a>
<a name="ln5015"> </a>
<a name="ln5016">  switch(active)</a>
<a name="ln5017">  {</a>
<a name="ln5018">    case DT_IOP_DEMOSAIC_AMAZE:</a>
<a name="ln5019">      p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_AMAZE;</a>
<a name="ln5020">      break;</a>
<a name="ln5021">    case DT_IOP_DEMOSAIC_VNG4:</a>
<a name="ln5022">      p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_VNG4;</a>
<a name="ln5023">      break;</a>
<a name="ln5024">    case DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME:</a>
<a name="ln5025">      p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME;</a>
<a name="ln5026">      break;</a>
<a name="ln5027">    default:</a>
<a name="ln5028">    case DT_IOP_DEMOSAIC_PPG:</a>
<a name="ln5029">      p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_PPG;</a>
<a name="ln5030">      break;</a>
<a name="ln5031">  }</a>
<a name="ln5032"> </a>
<a name="ln5033">  if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln5034">  {</a>
<a name="ln5035">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln5036">    gtk_widget_hide(g-&gt;color_smoothing);</a>
<a name="ln5037">    gtk_widget_hide(g-&gt;greeneq);</a>
<a name="ln5038">  }</a>
<a name="ln5039">  else if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_AMAZE || p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_VNG4)</a>
<a name="ln5040">  {</a>
<a name="ln5041">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln5042">    gtk_widget_show(g-&gt;color_smoothing);</a>
<a name="ln5043">    gtk_widget_show(g-&gt;greeneq);</a>
<a name="ln5044">  }</a>
<a name="ln5045">  else</a>
<a name="ln5046">  {</a>
<a name="ln5047">    gtk_widget_show(g-&gt;median_thrs);</a>
<a name="ln5048">    gtk_widget_show(g-&gt;color_smoothing);</a>
<a name="ln5049">    gtk_widget_show(g-&gt;greeneq);</a>
<a name="ln5050">  }</a>
<a name="ln5051"> </a>
<a name="ln5052">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln5053">}</a>
<a name="ln5054"> </a>
<a name="ln5055">static void demosaic_method_xtrans_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln5056">{</a>
<a name="ln5057">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln5058">  p-&gt;demosaicing_method = dt_bauhaus_combobox_get(combo) | DEMOSAIC_XTRANS;</a>
<a name="ln5059">  if((p-&gt;demosaicing_method &gt; (DT_IOP_DEMOSAIC_FDC | DEMOSAIC_XTRANS))</a>
<a name="ln5060">     || (p-&gt;demosaicing_method &lt; (DT_IOP_DEMOSAIC_VNG | DEMOSAIC_XTRANS)))</a>
<a name="ln5061">    p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_MARKESTEIJN;</a>
<a name="ln5062">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln5063">}</a>
<a name="ln5064"> </a>
<a name="ln5065">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln5066">{</a>
<a name="ln5067">  self-&gt;gui_data = malloc(sizeof(dt_iop_demosaic_gui_data_t));</a>
<a name="ln5068">  dt_iop_demosaic_gui_data_t *g = (dt_iop_demosaic_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln5069">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln5070"> </a>
<a name="ln5071">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln5072">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln5073"> </a>
<a name="ln5074">  g-&gt;box_raw = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln5075"> </a>
<a name="ln5076">  g-&gt;demosaic_method_bayer = dt_bauhaus_combobox_new(self);</a>
<a name="ln5077">  dt_bauhaus_widget_set_label(g-&gt;demosaic_method_bayer, NULL, _(&quot;method&quot;));</a>
<a name="ln5078">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;demosaic_method_bayer, TRUE, TRUE, 0);</a>
<a name="ln5079">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_bayer, _(&quot;PPG (fast)&quot;));</a>
<a name="ln5080">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_bayer, _(&quot;AMaZE (slow)&quot;));</a>
<a name="ln5081">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_bayer, _(&quot;VNG4&quot;));</a>
<a name="ln5082">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_bayer, _(&quot;passthrough (monochrome) (experimental)&quot;));</a>
<a name="ln5083">  gtk_widget_set_tooltip_text(g-&gt;demosaic_method_bayer, _(&quot;demosaicing raw data method&quot;));</a>
<a name="ln5084"> </a>
<a name="ln5085">  g-&gt;demosaic_method_xtrans = dt_bauhaus_combobox_new(self);</a>
<a name="ln5086">  dt_bauhaus_widget_set_label(g-&gt;demosaic_method_xtrans, NULL, _(&quot;method&quot;));</a>
<a name="ln5087">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;demosaic_method_xtrans, TRUE, TRUE, 0);</a>
<a name="ln5088">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;VNG&quot;));</a>
<a name="ln5089">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;Markesteijn 1-pass&quot;));</a>
<a name="ln5090">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;Markesteijn 3-pass (slow)&quot;));</a>
<a name="ln5091">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;passthrough (monochrome) (experimental)&quot;));</a>
<a name="ln5092">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;frequency domain chroma (slow)&quot;));</a>
<a name="ln5093">  gtk_widget_set_tooltip_text(g-&gt;demosaic_method_xtrans, _(&quot;demosaicing raw data method&quot;));</a>
<a name="ln5094"> </a>
<a name="ln5095">  g-&gt;median_thrs = dt_bauhaus_slider_new_with_range(self, 0.0, 1.0, 0.001, p-&gt;median_thrs, 3);</a>
<a name="ln5096">  gtk_widget_set_tooltip_text(g-&gt;median_thrs, _(&quot;threshold for edge-aware median.\nset to 0.0 to switch off.\n&quot;</a>
<a name="ln5097">                                                &quot;set to 1.0 to ignore edges.&quot;));</a>
<a name="ln5098">  dt_bauhaus_widget_set_label(g-&gt;median_thrs, NULL, _(&quot;edge threshold&quot;));</a>
<a name="ln5099">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;median_thrs, TRUE, TRUE, 0);</a>
<a name="ln5100"> </a>
<a name="ln5101">  g-&gt;color_smoothing = dt_bauhaus_combobox_new(self);</a>
<a name="ln5102">  dt_bauhaus_widget_set_label(g-&gt;color_smoothing, NULL, _(&quot;color smoothing&quot;));</a>
<a name="ln5103">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;color_smoothing, TRUE, TRUE, 0);</a>
<a name="ln5104">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;off&quot;));</a>
<a name="ln5105">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;one time&quot;));</a>
<a name="ln5106">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;two times&quot;));</a>
<a name="ln5107">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;three times&quot;));</a>
<a name="ln5108">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;four times&quot;));</a>
<a name="ln5109">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;five times&quot;));</a>
<a name="ln5110">  gtk_widget_set_tooltip_text(g-&gt;color_smoothing, _(&quot;how many color smoothing median steps after demosaicing&quot;));</a>
<a name="ln5111"> </a>
<a name="ln5112">  g-&gt;greeneq = dt_bauhaus_combobox_new(self);</a>
<a name="ln5113">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;greeneq, TRUE, TRUE, 0);</a>
<a name="ln5114">  dt_bauhaus_widget_set_label(g-&gt;greeneq, NULL, _(&quot;match greens&quot;));</a>
<a name="ln5115">  dt_bauhaus_combobox_add(g-&gt;greeneq, _(&quot;disabled&quot;));</a>
<a name="ln5116">  dt_bauhaus_combobox_add(g-&gt;greeneq, _(&quot;local average&quot;));</a>
<a name="ln5117">  dt_bauhaus_combobox_add(g-&gt;greeneq, _(&quot;full average&quot;));</a>
<a name="ln5118">  dt_bauhaus_combobox_add(g-&gt;greeneq, _(&quot;full and local average&quot;));</a>
<a name="ln5119">  gtk_widget_set_tooltip_text(g-&gt;greeneq, _(&quot;green channels matching method&quot;));</a>
<a name="ln5120"> </a>
<a name="ln5121">  g_signal_connect(G_OBJECT(g-&gt;median_thrs), &quot;value-changed&quot;, G_CALLBACK(median_thrs_callback), self);</a>
<a name="ln5122">  g_signal_connect(G_OBJECT(g-&gt;color_smoothing), &quot;value-changed&quot;, G_CALLBACK(color_smoothing_callback), self);</a>
<a name="ln5123">  g_signal_connect(G_OBJECT(g-&gt;greeneq), &quot;value-changed&quot;, G_CALLBACK(greeneq_callback), self);</a>
<a name="ln5124">  g_signal_connect(G_OBJECT(g-&gt;demosaic_method_bayer), &quot;value-changed&quot;,</a>
<a name="ln5125">                   G_CALLBACK(demosaic_method_bayer_callback), self);</a>
<a name="ln5126">  g_signal_connect(G_OBJECT(g-&gt;demosaic_method_xtrans), &quot;value-changed&quot;,</a>
<a name="ln5127">                   G_CALLBACK(demosaic_method_xtrans_callback), self);</a>
<a name="ln5128"> </a>
<a name="ln5129">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;box_raw, FALSE, FALSE, 0);</a>
<a name="ln5130"> </a>
<a name="ln5131">  g-&gt;label_non_raw = gtk_label_new(_(&quot;demosaicing\nonly needed for raw images.&quot;));</a>
<a name="ln5132">  gtk_widget_set_halign(g-&gt;label_non_raw, GTK_ALIGN_START);</a>
<a name="ln5133">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;label_non_raw, FALSE, FALSE, 0);</a>
<a name="ln5134">}</a>
<a name="ln5135"> </a>
<a name="ln5136">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln5137">{</a>
<a name="ln5138">  free(self-&gt;gui_data);</a>
<a name="ln5139">  self-&gt;gui_data = NULL;</a>
<a name="ln5140">}</a>
<a name="ln5141"> </a>
<a name="ln5142">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln5143">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln5144">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="776"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v743/" target="_blank">V743</a> The memory areas must not overlap. Use 'memmove' function.</p></div>
<div class="balloon" rel="881"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'hex[d] + hex[d + 1]' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="885"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="885"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="891"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="891"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1865"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'hex[d] + hex[d + 1]' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="1870"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1870"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1871"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'd' index could reach 3.</p></div>
<div class="balloon" rel="1871"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1871"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1879"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1879"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1880"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'd' index could reach 3.</p></div>
<div class="balloon" rel="1880"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1880"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1885"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1885"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1930"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'f' index could reach 123.</p></div>
<div class="balloon" rel="1930"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of '-f' index could reach -123.</p></div>
<div class="balloon" rel="1931"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'f' index could reach 123.</p></div>
<div class="balloon" rel="1931"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of '-f' index could reach -123.</p></div>
<div class="balloon" rel="1932"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'f' index could reach 123.</p></div>
<div class="balloon" rel="1932"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of '-f' index could reach -123.</p></div>
<div class="balloon" rel="2055"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v654/" target="_blank">V654</a> The condition 'd < ndir - 4' of loop is always false.</p></div>
<div class="balloon" rel="2055"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v621/" target="_blank">V621</a> Consider inspecting the 'for' operator. It's possible that the loop will be executed incorrectly or won't be executed at all.</p></div>
<div class="balloon" rel="2184"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lookup'. Check lines: 2184, 2178.</p></div>
<div class="balloon" rel="2503"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2504"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2505"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2506"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2507"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2508"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2509"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2581"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2582"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2583"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="3483"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lookup'. Check lines: 3483, 3478.</p></div>
<div class="balloon" rel="3493"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '<<'. The left operand is negative ('y' = [-1..1]).</p></div>
<div class="balloon" rel="3538"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'ip' pointer in the 'ip - ips' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 3538, 3530.</p></div>
<div class="balloon" rel="3828"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v586/" target="_blank">V586</a> The 'free' function is called twice for deallocation of the same memory space.</p></div>
<div class="balloon" rel="4710"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 4710, 4708.</p></div>
<div class="balloon" rel="5059"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false.</p></div>
<div class="balloon" rel="5074"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 5074, 5067.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
