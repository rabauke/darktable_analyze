
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2014-2018 pascal obry.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;cups/cups.h&gt;</a>
<a name="ln20">#include &lt;cups/ppd.h&gt;</a>
<a name="ln21">#include &lt;glib.h&gt;</a>
<a name="ln22">#include &lt;stdio.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;common/file_location.h&quot;</a>
<a name="ln25">#include &quot;common/image.h&quot;</a>
<a name="ln26">#include &quot;common/image_cache.h&quot;</a>
<a name="ln27">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln28">#include &quot;common/pdf.h&quot;</a>
<a name="ln29">#include &quot;control/jobs/control_jobs.h&quot;</a>
<a name="ln30">#include &quot;cups_print.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;</a>
<a name="ln33">// some platforms are starting to provide CUPS 2.2.9 and there the</a>
<a name="ln34">// CUPS API deprecated routines ate now flagged as such and reported as</a>
<a name="ln35">// warning preventing the compilation.</a>
<a name="ln36">//</a>
<a name="ln37">// this seems wrong and PPD should be removed from this unit. but there</a>
<a name="ln38">// still one missing piece discussed with the CUPS maintainers about the</a>
<a name="ln39">// way to get media-type using the IPP API. nothing close to working at</a>
<a name="ln40">// this stage, so instead of breaking the compilation on platforms using</a>
<a name="ln41">// recent CUPS version we kill the warning.</a>
<a name="ln42"> </a>
<a name="ln43">typedef struct dt_prtctl_t</a>
<a name="ln44">{</a>
<a name="ln45">  void (*cb)(dt_printer_info_t *, void *);</a>
<a name="ln46">  void *user_data;</a>
<a name="ln47">} dt_prtctl_t;</a>
<a name="ln48"> </a>
<a name="ln49">// initialize the pinfo structure</a>
<a name="ln50">void dt_init_print_info(dt_print_info_t *pinfo)</a>
<a name="ln51">{</a>
<a name="ln52">  memset(&amp;pinfo-&gt;printer, 0, sizeof(dt_printer_info_t));</a>
<a name="ln53">  memset(&amp;pinfo-&gt;page, 0, sizeof(dt_page_setup_t));</a>
<a name="ln54">  memset(&amp;pinfo-&gt;paper, 0, sizeof(dt_paper_info_t));</a>
<a name="ln55">  pinfo-&gt;printer.intent = DT_INTENT_PERCEPTUAL;</a>
<a name="ln56">  pinfo-&gt;printer.is_turboprint = FALSE;</a>
<a name="ln57">  *pinfo-&gt;printer.profile = '\0';</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">void dt_get_printer_info(const char *printer_name, dt_printer_info_t *pinfo)</a>
<a name="ln61">{</a>
<a name="ln62">  cups_dest_t *dests;</a>
<a name="ln63">  int num_dests = cupsGetDests(&amp;dests);</a>
<a name="ln64">  cups_dest_t *dest = cupsGetDest(printer_name, NULL, num_dests, dests);</a>
<a name="ln65"> </a>
<a name="ln66">  if (dest)</a>
<a name="ln67">  {</a>
<a name="ln68">    const char *PPDFile = cupsGetPPD (printer_name);</a>
<a name="ln69">    g_strlcpy(pinfo-&gt;name, dest-&gt;name, MAX_NAME);</a>
<a name="ln70">    ppd_file_t *ppd = ppdOpenFile(PPDFile);</a>
<a name="ln71"> </a>
<a name="ln72">    if (ppd)</a>
<a name="ln73">    {</a>
<a name="ln74">      ppdMarkDefaults(ppd);</a>
<a name="ln75">      cupsMarkOptions(ppd, dest-&gt;num_options, dest-&gt;options);</a>
<a name="ln76"> </a>
<a name="ln77">      // first check if this is turboprint drived printer, two solutions:</a>
<a name="ln78">      // 1. ModelName constains TurboPrint</a>
<a name="ln79">      // 2. zedoPrinterDriver exists</a>
<a name="ln80">      ppd_attr_t *attr = ppdFindAttr(ppd, &quot;ModelName&quot;, NULL);</a>
<a name="ln81"> </a>
<a name="ln82">      if (attr)</a>
<a name="ln83">      {</a>
<a name="ln84">        pinfo-&gt;is_turboprint = strstr(attr-&gt;value, &quot;TurboPrint&quot;) != NULL;</a>
<a name="ln85">      }</a>
<a name="ln86"> </a>
<a name="ln87">      // hardware margins</a>
<a name="ln88"> </a>
<a name="ln89">      attr = ppdFindAttr(ppd, &quot;HWMargins&quot;, NULL);</a>
<a name="ln90"> </a>
<a name="ln91">      if (attr)</a>
<a name="ln92">      {</a>
<a name="ln93">        sscanf(attr-&gt;value, &quot;%lf %lf %lf %lf&quot;,</a>
<a name="ln94">               &amp;pinfo-&gt;hw_margin_left, &amp;pinfo-&gt;hw_margin_bottom,</a>
<a name="ln95">               &amp;pinfo-&gt;hw_margin_right, &amp;pinfo-&gt;hw_margin_top);</a>
<a name="ln96"> </a>
<a name="ln97">        pinfo-&gt;hw_margin_left   = dt_pdf_point_to_mm (pinfo-&gt;hw_margin_left);</a>
<a name="ln98">        pinfo-&gt;hw_margin_bottom = dt_pdf_point_to_mm (pinfo-&gt;hw_margin_bottom);</a>
<a name="ln99">        pinfo-&gt;hw_margin_right  = dt_pdf_point_to_mm (pinfo-&gt;hw_margin_right);</a>
<a name="ln100">        pinfo-&gt;hw_margin_top    = dt_pdf_point_to_mm (pinfo-&gt;hw_margin_top);</a>
<a name="ln101">      }</a>
<a name="ln102"> </a>
<a name="ln103">      // default resolution</a>
<a name="ln104"> </a>
<a name="ln105">      attr = ppdFindAttr(ppd, &quot;DefaultResolution&quot;, NULL);</a>
<a name="ln106"> </a>
<a name="ln107">      if (attr)</a>
<a name="ln108">      {</a>
<a name="ln109">        char *x = strstr(attr-&gt;value, &quot;x&quot;);</a>
<a name="ln110"> </a>
<a name="ln111">        if (x)</a>
<a name="ln112">          sscanf (x+1, &quot;%ddpi&quot;, &amp;pinfo-&gt;resolution);</a>
<a name="ln113">        else</a>
<a name="ln114">          sscanf (attr-&gt;value, &quot;%ddpi&quot;, &amp;pinfo-&gt;resolution);</a>
<a name="ln115">      }</a>
<a name="ln116">      else</a>
<a name="ln117">        pinfo-&gt;resolution = 300;</a>
<a name="ln118"> </a>
<a name="ln119">      while(pinfo-&gt;resolution&gt;360)</a>
<a name="ln120">        pinfo-&gt;resolution /= 2.0;</a>
<a name="ln121"> </a>
<a name="ln122">      ppdClose(ppd);</a>
<a name="ln123">      g_unlink(PPDFile);</a>
<a name="ln124">    }</a>
<a name="ln125">  }</a>
<a name="ln126"> </a>
<a name="ln127">  cupsFreeDests(num_dests, dests);</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">static int _dest_cb(void *user_data, unsigned flags, cups_dest_t *dest)</a>
<a name="ln131">{</a>
<a name="ln132">  const dt_prtctl_t *pctl = (dt_prtctl_t *)user_data;</a>
<a name="ln133">  const char *psvalue = cupsGetOption(&quot;printer-state&quot;, dest-&gt;num_options, dest-&gt;options);</a>
<a name="ln134"> </a>
<a name="ln135">  // check that the printer is ready</a>
<a name="ln136">  if (psvalue!=NULL &amp;&amp; strtol(psvalue, NULL, 10) &lt; IPP_PRINTER_STOPPED)</a>
<a name="ln137">  {</a>
<a name="ln138">    dt_printer_info_t pr;</a>
<a name="ln139">    memset(&amp;pr, 0, sizeof(pr));</a>
<a name="ln140">    dt_get_printer_info(dest-&gt;name, &amp;pr);</a>
<a name="ln141">    if (pctl-&gt;cb) pctl-&gt;cb(&amp;pr, pctl-&gt;user_data);</a>
<a name="ln142">    dt_print(DT_DEBUG_PRINT, &quot;[print] new printer %s found\n&quot;, dest-&gt;name);</a>
<a name="ln143">  }</a>
<a name="ln144">  else</a>
<a name="ln145">    dt_print(DT_DEBUG_PRINT, &quot;[print] skip printer %s as stopped\n&quot;, dest-&gt;name);</a>
<a name="ln146"> </a>
<a name="ln147">  return 1;</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">static int _cancel = 0;</a>
<a name="ln151"> </a>
<a name="ln152">static int _detect_printers_callback(dt_job_t *job)</a>
<a name="ln153">{</a>
<a name="ln154">  dt_prtctl_t *pctl = dt_control_job_get_params(job);</a>
<a name="ln155">  int res;</a>
<a name="ln156">#if ((CUPS_VERSION_MAJOR == 1) &amp;&amp; (CUPS_VERSION_MINOR &gt;= 6)) || CUPS_VERSION_MAJOR &gt; 1</a>
<a name="ln157">#if defined(__APPLE__) &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &lt; MAC_OS_X_VERSION_10_8</a>
<a name="ln158">  if (cupsEnumDests != NULL)</a>
<a name="ln159">#endif</a>
<a name="ln160">    res = cupsEnumDests(CUPS_MEDIA_FLAGS_DEFAULT, 30000, &amp;_cancel, 0, 0, _dest_cb, pctl);</a>
<a name="ln161">#if defined(__APPLE__) &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &lt; MAC_OS_X_VERSION_10_8</a>
<a name="ln162">  else</a>
<a name="ln163">#endif</a>
<a name="ln164">#endif</a>
<a name="ln165">#if defined(__APPLE__) &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &lt; MAC_OS_X_VERSION_10_8 || !(((CUPS_VERSION_MAJOR == 1) &amp;&amp; (CUPS_VERSION_MINOR &gt;= 6)) || CUPS_VERSION_MAJOR &gt; 1)</a>
<a name="ln166">  {</a>
<a name="ln167">    cups_dest_t *dests;</a>
<a name="ln168">    const int num_dests = cupsGetDests(&amp;dests);</a>
<a name="ln169">    for (int k=0; k&lt;num_dests; k++)</a>
<a name="ln170">    {</a>
<a name="ln171">      _dest_cb((void *)pctl, 0, &amp;dests[k]);</a>
<a name="ln172">    }</a>
<a name="ln173">    cupsFreeDests(num_dests, dests);</a>
<a name="ln174">    res=1;</a>
<a name="ln175">  }</a>
<a name="ln176">#endif</a>
<a name="ln177">  return !res;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">void dt_printers_abort_discovery(void)</a>
<a name="ln181">{</a>
<a name="ln182">  _cancel = 1;</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">void dt_printers_discovery(void (*cb)(dt_printer_info_t *pr, void *user_data), void *user_data)</a>
<a name="ln186">{</a>
<a name="ln187">  // asynchronously checks for available printers</a>
<a name="ln188">  dt_job_t *job = dt_control_job_create(&amp;_detect_printers_callback, &quot;detect connected printers&quot;);</a>
<a name="ln189">  if(job)</a>
<a name="ln190">  {</a>
<a name="ln191">    dt_prtctl_t *prtctl = g_malloc0(sizeof(dt_prtctl_t));</a>
<a name="ln192"> </a>
<a name="ln193">    prtctl-&gt;cb = cb;</a>
<a name="ln194">    prtctl-&gt;user_data = user_data;</a>
<a name="ln195"> </a>
<a name="ln196">    dt_control_job_set_params(job, prtctl, g_free);</a>
<a name="ln197">    dt_control_add_job(darktable.control, DT_JOB_QUEUE_SYSTEM_BG, job);</a>
<a name="ln198">  }</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">static int paper_exists(GList *papers, const char *name)</a>
<a name="ln202">{</a>
<a name="ln203">  if (strstr(name,&quot;custom_&quot;) == name)</a>
<a name="ln204">    return 1;</a>
<a name="ln205"> </a>
<a name="ln206">  GList *p = papers;</a>
<a name="ln207">  while (p)</a>
<a name="ln208">  {</a>
<a name="ln209">    const dt_paper_info_t *pi = (dt_paper_info_t*)p-&gt;data;</a>
<a name="ln210">    if (!strcmp(pi-&gt;name,name) || !strcmp(pi-&gt;common_name,name))</a>
<a name="ln211">      return 1;</a>
<a name="ln212">    p = g_list_next (p);</a>
<a name="ln213">  }</a>
<a name="ln214">  return 0;</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">dt_paper_info_t *dt_get_paper(GList *papers, const char *name)</a>
<a name="ln218">{</a>
<a name="ln219">  GList *p = papers;</a>
<a name="ln220">  dt_paper_info_t *result = NULL;</a>
<a name="ln221"> </a>
<a name="ln222">  while (p)</a>
<a name="ln223">  {</a>
<a name="ln224">    dt_paper_info_t *pi = (dt_paper_info_t*)p-&gt;data;</a>
<a name="ln225">    if (!strcmp(pi-&gt;name,name) || !strcmp(pi-&gt;common_name,name))</a>
<a name="ln226">    {</a>
<a name="ln227">      result = pi;</a>
<a name="ln228">      break;</a>
<a name="ln229">    }</a>
<a name="ln230">    p = g_list_next (p);</a>
<a name="ln231">  }</a>
<a name="ln232">  return result;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">static gint</a>
<a name="ln236">sort_papers (gconstpointer p1, gconstpointer p2)</a>
<a name="ln237">{</a>
<a name="ln238">  const dt_paper_info_t *n1 = (dt_paper_info_t *)p1;</a>
<a name="ln239">  const dt_paper_info_t *n2 = (dt_paper_info_t *)p2;</a>
<a name="ln240">  const int l1 = strlen(n1-&gt;common_name);</a>
<a name="ln241">  const int l2 = strlen(n2-&gt;common_name);</a>
<a name="ln242">  return l1==l2 ? strcmp(n1-&gt;common_name, n2-&gt;common_name) : (l1 &lt; l2 ? -1 : +1);</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">GList *dt_get_papers(const dt_printer_info_t *printer)</a>
<a name="ln246">{</a>
<a name="ln247">  const char *printer_name = printer-&gt;name;</a>
<a name="ln248">  GList *result = NULL;</a>
<a name="ln249"> </a>
<a name="ln250">#if ((CUPS_VERSION_MAJOR == 1) &amp;&amp; (CUPS_VERSION_MINOR &gt;= 7)) || CUPS_VERSION_MAJOR &gt; 1</a>
<a name="ln251">#if defined(__APPLE__) &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &lt; MAC_OS_X_VERSION_10_9</a>
<a name="ln252">  if (cupsConnectDest != NULL &amp;&amp; cupsCopyDestInfo != NULL &amp;&amp; cupsGetDestMediaCount != NULL &amp;&amp;</a>
<a name="ln253">      cupsGetDestMediaByIndex != NULL &amp;&amp; cupsFreeDestInfo != NULL)</a>
<a name="ln254">#endif</a>
<a name="ln255">  {</a>
<a name="ln256">    cups_dest_t *dests;</a>
<a name="ln257">    int num_dests = cupsGetDests(&amp;dests);</a>
<a name="ln258">    cups_dest_t *dest = cupsGetDest(printer_name, NULL, num_dests, dests);</a>
<a name="ln259"> </a>
<a name="ln260">    int cancel = 0; // important</a>
<a name="ln261"> </a>
<a name="ln262">    char resource[1024];</a>
<a name="ln263"> </a>
<a name="ln264">    if (dest)</a>
<a name="ln265">    {</a>
<a name="ln266">      http_t *hcon = cupsConnectDest(dest, 0, 2000, &amp;cancel, resource, sizeof(resource), NULL, (void *)NULL);</a>
<a name="ln267"> </a>
<a name="ln268">      if (hcon)</a>
<a name="ln269">      {</a>
<a name="ln270">        cups_size_t size;</a>
<a name="ln271">        cups_dinfo_t *info = cupsCopyDestInfo (hcon, dest);</a>
<a name="ln272">        const int count = cupsGetDestMediaCount(hcon, dest, info, CUPS_MEDIA_FLAGS_DEFAULT);</a>
<a name="ln273">        for (int k=0; k&lt;count; k++)</a>
<a name="ln274">        {</a>
<a name="ln275">          if (cupsGetDestMediaByIndex(hcon, dest, info, k, CUPS_MEDIA_FLAGS_DEFAULT, &amp;size))</a>
<a name="ln276">          {</a>
<a name="ln277">            if (size.width!=0 &amp;&amp; size.length!=0 &amp;&amp; !paper_exists(result, size.media))</a>
<a name="ln278">            {</a>
<a name="ln279">              pwg_media_t *med = pwgMediaForPWG (size.media);</a>
<a name="ln280">              char common_name[MAX_NAME] = { 0 };</a>
<a name="ln281"> </a>
<a name="ln282">              if (med-&gt;ppd)</a>
<a name="ln283">                g_strlcpy(common_name, med-&gt;ppd, sizeof(common_name));</a>
<a name="ln284">              else</a>
<a name="ln285">                g_strlcpy(common_name, size.media, sizeof(common_name));</a>
<a name="ln286"> </a>
<a name="ln287">              dt_paper_info_t *paper = (dt_paper_info_t*)malloc(sizeof(dt_paper_info_t));</a>
<a name="ln288">              g_strlcpy(paper-&gt;name, size.media, sizeof(paper-&gt;name));</a>
<a name="ln289">              g_strlcpy(paper-&gt;common_name, common_name, sizeof(paper-&gt;common_name));</a>
<a name="ln290">              paper-&gt;width = (double)size.width / 100.0;</a>
<a name="ln291">              paper-&gt;height = (double)size.length / 100.0;</a>
<a name="ln292">              result = g_list_append (result, paper);</a>
<a name="ln293"> </a>
<a name="ln294">              dt_print(DT_DEBUG_PRINT,</a>
<a name="ln295">                       &quot;[print] new media paper %4d %6.2f x %6.2f (%s) (%s)\n&quot;,</a>
<a name="ln296">                       k, paper-&gt;width, paper-&gt;height, paper-&gt;name, paper-&gt;common_name);</a>
<a name="ln297">            }</a>
<a name="ln298">          }</a>
<a name="ln299">        }</a>
<a name="ln300"> </a>
<a name="ln301">        cupsFreeDestInfo(info);</a>
<a name="ln302">        httpClose(hcon);</a>
<a name="ln303">      }</a>
<a name="ln304">      else</a>
<a name="ln305">        dt_print(DT_DEBUG_PRINT, &quot;[print] cannot connect to printer %s (cancel=%d)\n&quot;, printer_name, cancel);</a>
<a name="ln306">    }</a>
<a name="ln307"> </a>
<a name="ln308">    cupsFreeDests(num_dests, dests);</a>
<a name="ln309">  }</a>
<a name="ln310">#endif</a>
<a name="ln311"> </a>
<a name="ln312">  // check now PPD page sizes</a>
<a name="ln313"> </a>
<a name="ln314">  const char *PPDFile = cupsGetPPD(printer_name);</a>
<a name="ln315">  ppd_file_t *ppd = ppdOpenFile(PPDFile);</a>
<a name="ln316"> </a>
<a name="ln317">  if (ppd)</a>
<a name="ln318">  {</a>
<a name="ln319">    ppd_size_t *size = ppd-&gt;sizes;</a>
<a name="ln320"> </a>
<a name="ln321">    for (int k=0; k&lt;ppd-&gt;num_sizes; k++)</a>
<a name="ln322">    {</a>
<a name="ln323">      if (size-&gt;width!=0 &amp;&amp; size-&gt;length!=0 &amp;&amp; !paper_exists(result, size-&gt;name))</a>
<a name="ln324">      {</a>
<a name="ln325">        dt_paper_info_t *paper = (dt_paper_info_t*)malloc(sizeof(dt_paper_info_t));</a>
<a name="ln326">        g_strlcpy(paper-&gt;name, size-&gt;name, MAX_NAME);</a>
<a name="ln327">        g_strlcpy(paper-&gt;common_name, size-&gt;name, MAX_NAME);</a>
<a name="ln328">        paper-&gt;width = (double)dt_pdf_point_to_mm(size-&gt;width);</a>
<a name="ln329">        paper-&gt;height = (double)dt_pdf_point_to_mm(size-&gt;length);</a>
<a name="ln330">        result = g_list_append (result, paper);</a>
<a name="ln331"> </a>
<a name="ln332">        dt_print(DT_DEBUG_PRINT,</a>
<a name="ln333">                 &quot;[print] new ppd paper %4d %6.2f x %6.2f (%s) (%s)\n&quot;,</a>
<a name="ln334">                 k, paper-&gt;width, paper-&gt;height, paper-&gt;name, paper-&gt;common_name);</a>
<a name="ln335">      }</a>
<a name="ln336">      size++;</a>
<a name="ln337">    }</a>
<a name="ln338"> </a>
<a name="ln339">    ppdClose(ppd);</a>
<a name="ln340">    g_unlink(PPDFile);</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  result = g_list_sort_with_data (result, (GCompareDataFunc)sort_papers, NULL);</a>
<a name="ln344">  return result;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347">GList *dt_get_media_type(const dt_printer_info_t *printer)</a>
<a name="ln348">{</a>
<a name="ln349">  const char *printer_name = printer-&gt;name;</a>
<a name="ln350">  GList *result = NULL;</a>
<a name="ln351"> </a>
<a name="ln352">  // check now PPD media type</a>
<a name="ln353"> </a>
<a name="ln354">  const char *PPDFile = cupsGetPPD(printer_name);</a>
<a name="ln355">  ppd_file_t *ppd = ppdOpenFile(PPDFile);</a>
<a name="ln356"> </a>
<a name="ln357">  if (ppd)</a>
<a name="ln358">  {</a>
<a name="ln359">      ppd_option_t *opt = ppdFindOption(ppd, &quot;MediaType&quot;);</a>
<a name="ln360"> </a>
<a name="ln361">      if (opt)</a>
<a name="ln362">      {</a>
<a name="ln363">        ppd_choice_t *choice = opt-&gt;choices;</a>
<a name="ln364"> </a>
<a name="ln365">        for (int k=0; k&lt;opt-&gt;num_choices; k++)</a>
<a name="ln366">        {</a>
<a name="ln367">          dt_medium_info_t *media = (dt_medium_info_t*)malloc(sizeof(dt_medium_info_t));</a>
<a name="ln368">          g_strlcpy(media-&gt;name, choice-&gt;choice, MAX_NAME);</a>
<a name="ln369">          g_strlcpy(media-&gt;common_name, choice-&gt;text, MAX_NAME);</a>
<a name="ln370">          result = g_list_append (result, media);</a>
<a name="ln371"> </a>
<a name="ln372">          dt_print(DT_DEBUG_PRINT, &quot;[print] new media %2d (%s) (%s)\n&quot;, k, media-&gt;name, media-&gt;common_name);</a>
<a name="ln373">          choice++;</a>
<a name="ln374">        }</a>
<a name="ln375">      }</a>
<a name="ln376">  }</a>
<a name="ln377"> </a>
<a name="ln378">  ppdClose(ppd);</a>
<a name="ln379">  g_unlink(PPDFile);</a>
<a name="ln380"> </a>
<a name="ln381">  return result;</a>
<a name="ln382">}</a>
<a name="ln383"> </a>
<a name="ln384">dt_medium_info_t *dt_get_medium(GList *media, const char *name)</a>
<a name="ln385">{</a>
<a name="ln386">  GList *m = media;</a>
<a name="ln387">  dt_medium_info_t *result = NULL;</a>
<a name="ln388"> </a>
<a name="ln389">  while (m)</a>
<a name="ln390">  {</a>
<a name="ln391">    dt_medium_info_t *mi = (dt_medium_info_t*)m-&gt;data;</a>
<a name="ln392">    if (!strcmp(mi-&gt;name, name) || !strcmp(mi-&gt;common_name, name))</a>
<a name="ln393">    {</a>
<a name="ln394">      result = mi;</a>
<a name="ln395">      break;</a>
<a name="ln396">    }</a>
<a name="ln397">    m = g_list_next (m);</a>
<a name="ln398">  }</a>
<a name="ln399">  return result;</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">void dt_print_file(const int32_t imgid, const char *filename, const char *job_title, const dt_print_info_t *pinfo)</a>
<a name="ln403">{</a>
<a name="ln404">  // first for safety check that filename exists and is readable</a>
<a name="ln405"> </a>
<a name="ln406">  if (!g_file_test(filename, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln407">  {</a>
<a name="ln408">    dt_control_log(_(&quot;file `%s' to print not found for image %d on `%s'&quot;), filename, imgid, pinfo-&gt;printer.name);</a>
<a name="ln409">    return;</a>
<a name="ln410">  }</a>
<a name="ln411"> </a>
<a name="ln412">  cups_option_t *options = NULL;</a>
<a name="ln413">  int num_options = 0;</a>
<a name="ln414"> </a>
<a name="ln415">  // for turboprint drived printer, use the turboprint dialog</a>
<a name="ln416">  if (pinfo-&gt;printer.is_turboprint)</a>
<a name="ln417">  {</a>
<a name="ln418">    const char *tp_intent_name[] = { &quot;perception_0&quot;, &quot;colorimetric-relative_1&quot;, &quot;saturation_1&quot;, &quot;colorimetric-absolute_1&quot; };</a>
<a name="ln419">    char tmpfile[PATH_MAX] = { 0 };</a>
<a name="ln420"> </a>
<a name="ln421">    dt_loc_get_tmp_dir(tmpfile, sizeof(tmpfile));</a>
<a name="ln422">    g_strlcat(tmpfile, &quot;/dt_cups_opts_XXXXXX&quot;, sizeof(tmpfile));</a>
<a name="ln423"> </a>
<a name="ln424">    gint fd = g_mkstemp(tmpfile);</a>
<a name="ln425">    if(fd == -1)</a>
<a name="ln426">    {</a>
<a name="ln427">      dt_control_log(_(&quot;failed to create temporary file for printing options&quot;));</a>
<a name="ln428">      fprintf(stderr, &quot;failed to create temporary pdf for printing options\n&quot;);</a>
<a name="ln429">      return;</a>
<a name="ln430">    }</a>
<a name="ln431">    close(fd);</a>
<a name="ln432"> </a>
<a name="ln433">    // ensure that intent is in the range, may happen if at some point we add new intent in the list</a>
<a name="ln434">    const int intent = (pinfo-&gt;printer.intent &lt; 4) ? pinfo-&gt;printer.intent : 0;</a>
<a name="ln435"> </a>
<a name="ln436">    // spawn turboprint command</a>
<a name="ln437">    gchar * argv[15] = { 0 };</a>
<a name="ln438"> </a>
<a name="ln439">    argv[0] = &quot;turboprint&quot;;</a>
<a name="ln440">    argv[1] = g_strdup_printf(&quot;--printer=%s&quot;, pinfo-&gt;printer.name);</a>
<a name="ln441">    argv[2] = &quot;--options&quot;;</a>
<a name="ln442">    argv[3] = g_strdup_printf(&quot;--output=%s&quot;, tmpfile);</a>
<a name="ln443">    argv[4] = &quot;-o&quot;;</a>
<a name="ln444">    argv[5] = &quot;copies=1&quot;;</a>
<a name="ln445">    argv[6] = &quot;-o&quot;;</a>
<a name="ln446">    argv[7] = g_strdup_printf(&quot;PageSize=%s&quot;, pinfo-&gt;paper.common_name);</a>
<a name="ln447">    argv[8] = &quot;-o&quot;;</a>
<a name="ln448">    argv[9] = &quot;InputSlot=AutoSelect&quot;;</a>
<a name="ln449">    argv[10] = &quot;-o&quot;;</a>
<a name="ln450">    argv[11] = g_strdup_printf(&quot;zedoIntent=%s&quot;, tp_intent_name[intent]);</a>
<a name="ln451">    argv[12] = &quot;-o&quot;;</a>
<a name="ln452">    argv[13] = g_strdup_printf(&quot;MediaType=%s&quot;, pinfo-&gt;medium.name);</a>
<a name="ln453">    argv[14] = NULL;</a>
<a name="ln454"> </a>
<a name="ln455">    gint exit_status = 0;</a>
<a name="ln456"> </a>
<a name="ln457">    g_spawn_sync (NULL, argv, NULL, G_SPAWN_SEARCH_PATH | G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,</a>
<a name="ln458">                  NULL, NULL, NULL, NULL, &amp;exit_status, NULL);</a>
<a name="ln459"> </a>
<a name="ln460">    g_free(argv[1]);</a>
<a name="ln461">    g_free(argv[3]);</a>
<a name="ln462">    g_free(argv[7]);</a>
<a name="ln463">    g_free(argv[11]);</a>
<a name="ln464">    g_free(argv[13]);</a>
<a name="ln465"> </a>
<a name="ln466">    if(exit_status==0)</a>
<a name="ln467">    {</a>
<a name="ln468">      FILE *stream = g_fopen(tmpfile, &quot;rb&quot;);</a>
<a name="ln469"> </a>
<a name="ln470">      while(1)</a>
<a name="ln471">      {</a>
<a name="ln472">        char optname[100];</a>
<a name="ln473">        char optvalue[100];</a>
<a name="ln474">        const int ropt = fscanf(stream, &quot;%*s %99[^= ]=%99s&quot;, optname, optvalue);</a>
<a name="ln475"> </a>
<a name="ln476">        // if we parsed an option name=value</a>
<a name="ln477">        if (ropt==2)</a>
<a name="ln478">        {</a>
<a name="ln479">          char *v = optvalue;</a>
<a name="ln480"> </a>
<a name="ln481">          // remove possible single quote around value</a>
<a name="ln482">          if (*v == '\'') v++;</a>
<a name="ln483">          if (v[strlen(v)-1] == '\'') v[strlen(v)-1] = '\0';</a>
<a name="ln484"> </a>
<a name="ln485">          num_options = cupsAddOption(optname, v, num_options, &amp;options);</a>
<a name="ln486">        }</a>
<a name="ln487">        else if (ropt == EOF)</a>
<a name="ln488">          break;</a>
<a name="ln489">      }</a>
<a name="ln490">      fclose(stream);</a>
<a name="ln491">      g_unlink(tmpfile);</a>
<a name="ln492">    }</a>
<a name="ln493">    else</a>
<a name="ln494">    {</a>
<a name="ln495">      dt_control_log(_(&quot;printing on `%s' cancelled&quot;), pinfo-&gt;printer.name);</a>
<a name="ln496">      dt_print(DT_DEBUG_PRINT, &quot;[print]   command fails with %d, cancel printing\n&quot;, exit_status);</a>
<a name="ln497">      return;</a>
<a name="ln498">    }</a>
<a name="ln499">  }</a>
<a name="ln500">  else</a>
<a name="ln501">  {</a>
<a name="ln502">    cups_dest_t *dests;</a>
<a name="ln503">    int num_dests = cupsGetDests(&amp;dests);</a>
<a name="ln504">    cups_dest_t *dest = cupsGetDest(pinfo-&gt;printer.name, NULL, num_dests, dests);</a>
<a name="ln505"> </a>
<a name="ln506">    for (int j = 0; j &lt; dest-&gt;num_options; j ++)</a>
<a name="ln507">      if (cupsGetOption(dest-&gt;options[j].name, num_options,</a>
<a name="ln508">                        options) == NULL)</a>
<a name="ln509">        num_options = cupsAddOption(dest-&gt;options[j].name,</a>
<a name="ln510">                                    dest-&gt;options[j].value,</a>
<a name="ln511">                                    num_options, &amp;options);</a>
<a name="ln512"> </a>
<a name="ln513">    cupsFreeDests(num_dests, dests);</a>
<a name="ln514"> </a>
<a name="ln515">    // if we have a profile, disable cm on CUPS, this is important as dt does the cm</a>
<a name="ln516"> </a>
<a name="ln517">    num_options = cupsAddOption(&quot;cm-calibration&quot;, *pinfo-&gt;printer.profile ? &quot;true&quot; : &quot;false&quot;, num_options, &amp;options);</a>
<a name="ln518"> </a>
<a name="ln519">    // media to print on</a>
<a name="ln520"> </a>
<a name="ln521">    num_options = cupsAddOption(&quot;media&quot;, pinfo-&gt;paper.name, num_options, &amp;options);</a>
<a name="ln522"> </a>
<a name="ln523">    // the media type to print on</a>
<a name="ln524"> </a>
<a name="ln525">    num_options = cupsAddOption(&quot;MediaType&quot;, pinfo-&gt;medium.name, num_options, &amp;options);</a>
<a name="ln526"> </a>
<a name="ln527">    // never print two-side</a>
<a name="ln528"> </a>
<a name="ln529">    num_options = cupsAddOption(&quot;sides&quot;, &quot;one-sided&quot;, num_options, &amp;options);</a>
<a name="ln530"> </a>
<a name="ln531">    // and a single image per page</a>
<a name="ln532"> </a>
<a name="ln533">    num_options = cupsAddOption(&quot;number-up&quot;, &quot;1&quot;, num_options, &amp;options);</a>
<a name="ln534"> </a>
<a name="ln535">    // if the printer has no hardware margins activate the borderless mode</a>
<a name="ln536"> </a>
<a name="ln537">    if (pinfo-&gt;printer.hw_margin_top == 0 || pinfo-&gt;printer.hw_margin_bottom == 0</a>
<a name="ln538">        || pinfo-&gt;printer.hw_margin_left == 0 || pinfo-&gt;printer.hw_margin_right == 0)</a>
<a name="ln539">    {</a>
<a name="ln540">      // there is many variant for this parameter</a>
<a name="ln541">      num_options = cupsAddOption(&quot;StpFullBleed&quot;, &quot;true&quot;, num_options, &amp;options);</a>
<a name="ln542">      num_options = cupsAddOption(&quot;STP_FullBleed&quot;, &quot;true&quot;, num_options, &amp;options);</a>
<a name="ln543">      num_options = cupsAddOption(&quot;Borderless&quot;, &quot;true&quot;, num_options, &amp;options);</a>
<a name="ln544">    }</a>
<a name="ln545"> </a>
<a name="ln546">    num_options = cupsAddOption(&quot;landscape&quot;, pinfo-&gt;page.landscape ? &quot;true&quot; : &quot;false&quot;, num_options, &amp;options);</a>
<a name="ln547">  }</a>
<a name="ln548"> </a>
<a name="ln549">  // print lp options</a>
<a name="ln550"> </a>
<a name="ln551">  dt_print(DT_DEBUG_PRINT, &quot;[print] printer options (%d)\n&quot;, num_options);</a>
<a name="ln552">  for (int k=0; k&lt;num_options; k++)</a>
<a name="ln553">    dt_print(DT_DEBUG_PRINT, &quot;[print]   %2d  %s=%s\n&quot;, k+1, options[k].name, options[k].value);</a>
<a name="ln554"> </a>
<a name="ln555">  const int job_id = cupsPrintFile(pinfo-&gt;printer.name, filename, job_title, num_options, options);</a>
<a name="ln556"> </a>
<a name="ln557">  if (job_id == 0)</a>
<a name="ln558">    dt_control_log(_(&quot;error while printing `%s' on `%s'&quot;), job_title, pinfo-&gt;printer.name);</a>
<a name="ln559">  else</a>
<a name="ln560">    dt_control_log(_(&quot;printing `%s' on `%s'&quot;), job_title, pinfo-&gt;printer.name);</a>
<a name="ln561"> </a>
<a name="ln562">  cupsFreeOptions (num_options, options);</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">void dt_get_print_layout(const int32_t imgid, const dt_print_info_t *prt,</a>
<a name="ln566">                         const int32_t area_width, const int32_t area_height,</a>
<a name="ln567">                         int32_t *iwpix, int32_t *ihpix,</a>
<a name="ln568">                         int32_t *px,    int32_t *py,    int32_t *pwidth, int32_t *pheight,</a>
<a name="ln569">                         int32_t *ax,    int32_t *ay,    int32_t *awidth, int32_t *aheight,</a>
<a name="ln570">                         int32_t *ix,    int32_t *iy,    int32_t *iwidth, int32_t *iheight)</a>
<a name="ln571">{</a>
<a name="ln572">  /* this is where the layout is done for the display and for the print too. So this routine is one</a>
<a name="ln573">     of the most critical for the print circuitry. */</a>
<a name="ln574"> </a>
<a name="ln575">  double width, height;</a>
<a name="ln576"> </a>
<a name="ln577">  // page w/h</a>
<a name="ln578">  double pg_width  = prt-&gt;paper.width;</a>
<a name="ln579">  double pg_height = prt-&gt;paper.height;</a>
<a name="ln580"> </a>
<a name="ln581">  if (area_width==0)</a>
<a name="ln582">    width = pg_width;</a>
<a name="ln583">  else</a>
<a name="ln584">    width = area_width;</a>
<a name="ln585"> </a>
<a name="ln586">  if (area_height==0)</a>
<a name="ln587">    height = pg_height;</a>
<a name="ln588">  else</a>
<a name="ln589">    height = area_height;</a>
<a name="ln590"> </a>
<a name="ln591">  /* here, width and height correspond to the area for the picture */</a>
<a name="ln592"> </a>
<a name="ln593">  // non-printable</a>
<a name="ln594">  double np_top = prt-&gt;printer.hw_margin_top;</a>
<a name="ln595">  double np_left = prt-&gt;printer.hw_margin_left;</a>
<a name="ln596">  double np_right = prt-&gt;printer.hw_margin_right;</a>
<a name="ln597">  double np_bottom = prt-&gt;printer.hw_margin_bottom;</a>
<a name="ln598"> </a>
<a name="ln599">  /* do some arrangements for the landscape mode. */</a>
<a name="ln600"> </a>
<a name="ln601">  if (prt-&gt;page.landscape)</a>
<a name="ln602">  {</a>
<a name="ln603">    double tmp = pg_width;</a>
<a name="ln604">    pg_width = pg_height;</a>
<a name="ln605">    pg_height = tmp;</a>
<a name="ln606"> </a>
<a name="ln607">    //  only invert if we did not get a specific area</a>
<a name="ln608">    if (area_width == 0 &amp;&amp; area_height == 0)</a>
<a name="ln609">    {</a>
<a name="ln610">      tmp = width;</a>
<a name="ln611">      width = height;</a>
<a name="ln612">      height = tmp;</a>
<a name="ln613">    }</a>
<a name="ln614"> </a>
<a name="ln615">    // rotate the non-printable margins</a>
<a name="ln616">    tmp       = np_top;</a>
<a name="ln617">    np_top    = np_right;</a>
<a name="ln618">    np_right  = np_bottom;</a>
<a name="ln619">    np_bottom = np_left;</a>
<a name="ln620">    np_left   = tmp;</a>
<a name="ln621">  }</a>
<a name="ln622"> </a>
<a name="ln623">  // the image area aspect</a>
<a name="ln624">  const double a_aspect = (double)width / (double)height;</a>
<a name="ln625"> </a>
<a name="ln626">  // page aspect</a>
<a name="ln627">  const double pg_aspect = pg_width / pg_height;</a>
<a name="ln628"> </a>
<a name="ln629">  // display page</a>
<a name="ln630">  int32_t p_bottom, p_right;</a>
<a name="ln631"> </a>
<a name="ln632">  if (a_aspect &gt; pg_aspect)</a>
<a name="ln633">  {</a>
<a name="ln634">    *px = (width - (height * pg_aspect)) / 2;</a>
<a name="ln635">    *py = 0;</a>
<a name="ln636">    p_bottom = height;</a>
<a name="ln637">    p_right = width - *px;</a>
<a name="ln638">  }</a>
<a name="ln639">  else</a>
<a name="ln640">  {</a>
<a name="ln641">    *px = 0;</a>
<a name="ln642">    *py = (height - (width / pg_aspect)) / 2;</a>
<a name="ln643">    p_right = width;</a>
<a name="ln644">    p_bottom = height - *py;</a>
<a name="ln645">  }</a>
<a name="ln646"> </a>
<a name="ln647">  *pwidth = p_right - *px;</a>
<a name="ln648">  *pheight = p_bottom - *py;</a>
<a name="ln649"> </a>
<a name="ln650">  // page margins, note that we do not want to change those values for the landscape mode.</a>
<a name="ln651">  // these margins are those set by the user from the GUI, and the top margin is *always*</a>
<a name="ln652">  // at the top of the screen.</a>
<a name="ln653"> </a>
<a name="ln654">  const double border_top = prt-&gt;page.margin_top;</a>
<a name="ln655">  const double border_left = prt-&gt;page.margin_left;</a>
<a name="ln656">  const double border_right = prt-&gt;page.margin_right;</a>
<a name="ln657">  const double border_bottom = prt-&gt;page.margin_bottom;</a>
<a name="ln658"> </a>
<a name="ln659">  // display picture area, that is removing the non printable areas and user's margins</a>
<a name="ln660"> </a>
<a name="ln661">  const int32_t bx = *px + ((np_left + border_left) / pg_width) * (*pwidth);</a>
<a name="ln662">  const int32_t by = *py + ((np_top + border_top)/ pg_height) * (*pheight);</a>
<a name="ln663">  const int32_t bb = p_bottom - ((np_bottom + border_bottom) / pg_height) * (*pheight);</a>
<a name="ln664">  const int32_t br = p_right - ((np_right + border_right) / pg_width) * (*pwidth);</a>
<a name="ln665"> </a>
<a name="ln666">  // now we have the printable area (ax, ay) -&gt; (ax + awidth, ay + aheight)</a>
<a name="ln667"> </a>
<a name="ln668">  *ax      = bx;</a>
<a name="ln669">  *ay      = by;</a>
<a name="ln670">  *awidth  = br - bx;</a>
<a name="ln671">  *aheight = bb - by;</a>
<a name="ln672"> </a>
<a name="ln673">  // get the image dimensions if needed</a>
<a name="ln674"> </a>
<a name="ln675">  if (*iwpix &lt;= 0 || *ihpix &lt;= 0)</a>
<a name="ln676">    dt_image_get_final_size(imgid, iwpix, ihpix);</a>
<a name="ln677"> </a>
<a name="ln678">  // compute the scaling for the image to fit into the printable area</a>
<a name="ln679"> </a>
<a name="ln680">  double scale;</a>
<a name="ln681"> </a>
<a name="ln682">  *iwidth = *iwpix;</a>
<a name="ln683">  *iheight = *ihpix;</a>
<a name="ln684"> </a>
<a name="ln685">  if (*iwidth &gt; *awidth)</a>
<a name="ln686">  {</a>
<a name="ln687">    scale =  (double)(*awidth) / (double)*iwidth;</a>
<a name="ln688">    *iwidth = *awidth;</a>
<a name="ln689">    *iheight = (int32_t)(((double)*iheight + 0.5) * scale);</a>
<a name="ln690">  }</a>
<a name="ln691"> </a>
<a name="ln692">  if (*iheight &gt; *aheight)</a>
<a name="ln693">  {</a>
<a name="ln694">    scale = (double)(*aheight) / (double)*iheight;</a>
<a name="ln695">    *iheight = *aheight;</a>
<a name="ln696">    *iwidth = (int32_t)(((double)*iwidth + 0.5) * scale);</a>
<a name="ln697">  }</a>
<a name="ln698"> </a>
<a name="ln699">  // now the image position (top-left corner coordinates) in the display area depending on the page</a>
<a name="ln700">  // alignment set by the user.</a>
<a name="ln701"> </a>
<a name="ln702">  switch (prt-&gt;page.alignment)</a>
<a name="ln703">  {</a>
<a name="ln704">    case ALIGNMENT_TOP_LEFT:</a>
<a name="ln705">      *ix = bx;</a>
<a name="ln706">      *iy = by;</a>
<a name="ln707">      break;</a>
<a name="ln708">    case ALIGNMENT_TOP:</a>
<a name="ln709">      *ix = bx + (*awidth - *iwidth) / 2;</a>
<a name="ln710">      *iy = by;</a>
<a name="ln711">      break;</a>
<a name="ln712">    case ALIGNMENT_TOP_RIGHT:</a>
<a name="ln713">      *ix = br - *iwidth;</a>
<a name="ln714">      *iy = by;</a>
<a name="ln715">      break;</a>
<a name="ln716">    case ALIGNMENT_LEFT:</a>
<a name="ln717">      *ix = bx;</a>
<a name="ln718">      *iy = by + (*aheight - *iheight) / 2;</a>
<a name="ln719">      break;</a>
<a name="ln720">    case ALIGNMENT_CENTER:</a>
<a name="ln721">      *ix = bx + (*awidth - *iwidth) / 2;</a>
<a name="ln722">      *iy = by + (*aheight - *iheight) / 2;</a>
<a name="ln723">      break;</a>
<a name="ln724">    case ALIGNMENT_RIGHT:</a>
<a name="ln725">      *ix = br - *iwidth;</a>
<a name="ln726">      *iy = by + (*aheight - *iheight) / 2;</a>
<a name="ln727">      break;</a>
<a name="ln728">    case ALIGNMENT_BOTTOM_LEFT:</a>
<a name="ln729">      *ix = bx;</a>
<a name="ln730">      *iy = bb - *iheight;</a>
<a name="ln731">      break;</a>
<a name="ln732">    case ALIGNMENT_BOTTOM:</a>
<a name="ln733">      *ix = bx + (*awidth - *iwidth) / 2;</a>
<a name="ln734">      *iy = bb - *iheight;</a>
<a name="ln735">      break;</a>
<a name="ln736">    case ALIGNMENT_BOTTOM_RIGHT:</a>
<a name="ln737">      *ix = br - *iwidth;</a>
<a name="ln738">      *iy = bb - *iheight;</a>
<a name="ln739">      break;</a>
<a name="ln740">  }</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln744">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln745">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="288"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'paper'. Check lines: 288, 287.</p></div>
<div class="balloon" rel="326"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'paper'. Check lines: 326, 325.</p></div>
<div class="balloon" rel="368"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'media'. Check lines: 368, 367.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
