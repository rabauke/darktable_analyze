
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">   This file is part of darktable,</a>
<a name="ln3">   copyright (c) 2009--2013 johannes hanika.</a>
<a name="ln4">   copyright (c) 2011 henrik andersson.</a>
<a name="ln5">   copyright (c) 2012-2017 tobias ellinghaus.</a>
<a name="ln6"> </a>
<a name="ln7">   darktable is free software: you can redistribute it and/or modify</a>
<a name="ln8">   it under the terms of the GNU General Public License as published by</a>
<a name="ln9">   the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln10">   (at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">   darktable is distributed in the hope that it will be useful,</a>
<a name="ln13">   but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">   GNU General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">   You should have received a copy of the GNU General Public License</a>
<a name="ln18">   along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln19"> */</a>
<a name="ln20"> </a>
<a name="ln21">#define __STDC_FORMAT_MACROS</a>
<a name="ln22"> </a>
<a name="ln23">extern &quot;C&quot; {</a>
<a name="ln24">#ifdef HAVE_CONFIG_H</a>
<a name="ln25">#include &quot;config.h&quot;</a>
<a name="ln26">#endif</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;glib.h&gt;</a>
<a name="ln29">#include &lt;sqlite3.h&gt;</a>
<a name="ln30">#include &lt;sys/stat.h&gt;</a>
<a name="ln31">#include &lt;sys/types.h&gt;</a>
<a name="ln32">#include &lt;time.h&gt;</a>
<a name="ln33">#include &lt;unistd.h&gt;</a>
<a name="ln34">#include &lt;zlib.h&gt;</a>
<a name="ln35">}</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;cassert&gt;</a>
<a name="ln38">#include &lt;cmath&gt;</a>
<a name="ln39">#include &lt;fstream&gt;</a>
<a name="ln40">#include &lt;iostream&gt;</a>
<a name="ln41">#include &lt;sstream&gt;</a>
<a name="ln42">#include &lt;string&gt;</a>
<a name="ln43"> </a>
<a name="ln44">#include &lt;exiv2/exiv2.hpp&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#if defined(_WIN32) &amp;&amp; defined(EXV_UNICODE_PATH)</a>
<a name="ln47">  #define WIDEN(s) pugi::as_wide(s)</a>
<a name="ln48">#else</a>
<a name="ln49">  #define WIDEN(s) (s)</a>
<a name="ln50">#endif</a>
<a name="ln51"> </a>
<a name="ln52">#include &lt;pugixml.hpp&gt;</a>
<a name="ln53"> </a>
<a name="ln54">using namespace std;</a>
<a name="ln55"> </a>
<a name="ln56">extern &quot;C&quot; {</a>
<a name="ln57">#include &quot;common/colorlabels.h&quot;</a>
<a name="ln58">#include &quot;common/darktable.h&quot;</a>
<a name="ln59">#include &quot;common/debug.h&quot;</a>
<a name="ln60">#include &quot;common/exif.h&quot;</a>
<a name="ln61">#include &quot;common/image_cache.h&quot;</a>
<a name="ln62">#include &quot;common/imageio.h&quot;</a>
<a name="ln63">#include &quot;common/imageio_jpeg.h&quot;</a>
<a name="ln64">#include &quot;common/metadata.h&quot;</a>
<a name="ln65">#include &quot;common/tags.h&quot;</a>
<a name="ln66">#include &quot;control/conf.h&quot;</a>
<a name="ln67">#include &quot;develop/imageop.h&quot;</a>
<a name="ln68">#include &quot;develop/blend.h&quot;</a>
<a name="ln69">#include &quot;develop/masks.h&quot;</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">// exiv2's readMetadata is not thread safe in 0.26. so we lock it. since readMetadata might throw an exception we</a>
<a name="ln73">// wrap it into some c++ magic to make sure we unlock in all cases. well, actually not magic but basic raii.</a>
<a name="ln74">// FIXME: check again once we rely on 0.27</a>
<a name="ln75">class Lock</a>
<a name="ln76">{</a>
<a name="ln77">public:</a>
<a name="ln78">  Lock() { dt_pthread_mutex_lock(&amp;darktable.exiv2_threadsafe); }</a>
<a name="ln79">  ~Lock() { dt_pthread_mutex_unlock(&amp;darktable.exiv2_threadsafe); }</a>
<a name="ln80">};</a>
<a name="ln81"> </a>
<a name="ln82">#define read_metadata_threadsafe(image)                       \</a>
<a name="ln83">{                                                             \</a>
<a name="ln84">  Lock lock;                                                  \</a>
<a name="ln85">  image-&gt;readMetadata();                                      \</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">static void _exif_import_tags(dt_image_t *img, Exiv2::XmpData::iterator &amp;pos);</a>
<a name="ln89"> </a>
<a name="ln90">// this array should contain all XmpBag and XmpSeq keys used by dt</a>
<a name="ln91">const char *dt_xmp_keys[]</a>
<a name="ln92">    = { &quot;Xmp.dc.subject&quot;, &quot;Xmp.lr.hierarchicalSubject&quot;, &quot;Xmp.darktable.colorlabels&quot;, &quot;Xmp.darktable.history&quot;,</a>
<a name="ln93">        &quot;Xmp.darktable.history_modversion&quot;, &quot;Xmp.darktable.history_enabled&quot;, &quot;Xmp.darktable.history_end&quot;,</a>
<a name="ln94">        &quot;Xmp.darktable.history_operation&quot;, &quot;Xmp.darktable.history_params&quot;, &quot;Xmp.darktable.blendop_params&quot;,</a>
<a name="ln95">        &quot;Xmp.darktable.blendop_version&quot;, &quot;Xmp.darktable.multi_priority&quot;, &quot;Xmp.darktable.multi_name&quot;,</a>
<a name="ln96">        &quot;Xmp.darktable.xmp_version&quot;, &quot;Xmp.darktable.raw_params&quot;, &quot;Xmp.darktable.auto_presets_applied&quot;,</a>
<a name="ln97">        &quot;Xmp.darktable.mask_id&quot;, &quot;Xmp.darktable.mask_type&quot;, &quot;Xmp.darktable.mask_name&quot;,</a>
<a name="ln98">        &quot;Xmp.darktable.mask_version&quot;, &quot;Xmp.darktable.mask&quot;, &quot;Xmp.darktable.mask_nb&quot;, &quot;Xmp.darktable.mask_src&quot;,</a>
<a name="ln99">        &quot;Xmp.dc.creator&quot;, &quot;Xmp.dc.publisher&quot;, &quot;Xmp.dc.title&quot;, &quot;Xmp.dc.description&quot;, &quot;Xmp.dc.rights&quot;,</a>
<a name="ln100">        &quot;Xmp.xmpMM.DerivedFrom&quot; };</a>
<a name="ln101"> </a>
<a name="ln102">static const guint dt_xmp_keys_n = G_N_ELEMENTS(dt_xmp_keys); // the number of XmpBag XmpSeq keys that dt uses</a>
<a name="ln103"> </a>
<a name="ln104">// inspired by ufraw_exiv2.cc:</a>
<a name="ln105"> </a>
<a name="ln106">static void dt_strlcpy_to_utf8(char *dest, size_t dest_max, Exiv2::ExifData::const_iterator &amp;pos,</a>
<a name="ln107">                               Exiv2::ExifData &amp;exifData)</a>
<a name="ln108">{</a>
<a name="ln109">  std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln110"> </a>
<a name="ln111">  char *s = g_locale_to_utf8(str.c_str(), str.length(), NULL, NULL, NULL);</a>
<a name="ln112">  if(s != NULL)</a>
<a name="ln113">  {</a>
<a name="ln114">    g_strlcpy(dest, s, dest_max);</a>
<a name="ln115">    g_free(s);</a>
<a name="ln116">  }</a>
<a name="ln117">  else</a>
<a name="ln118">  {</a>
<a name="ln119">    g_strlcpy(dest, str.c_str(), dest_max);</a>
<a name="ln120">  }</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">// function to remove known dt keys and subtrees from xmpdata, so not to append them twice</a>
<a name="ln124">// this should work because dt first reads all known keys</a>
<a name="ln125">static void dt_remove_known_keys(Exiv2::XmpData &amp;xmp)</a>
<a name="ln126">{</a>
<a name="ln127">  xmp.sortByKey();</a>
<a name="ln128">  for(unsigned int i = 0; i &lt; dt_xmp_keys_n; i++)</a>
<a name="ln129">  {</a>
<a name="ln130">    Exiv2::XmpData::iterator pos = xmp.findKey(Exiv2::XmpKey(dt_xmp_keys[i]));</a>
<a name="ln131"> </a>
<a name="ln132">    while(pos != xmp.end())</a>
<a name="ln133">    {</a>
<a name="ln134">      std::string key = pos-&gt;key();</a>
<a name="ln135">      const char *ckey = key.c_str();</a>
<a name="ln136">      size_t len = key.size();</a>
<a name="ln137">      // stop iterating once the key no longer matches what we are trying to delete. this assumes sorted input</a>
<a name="ln138">      if(!(g_str_has_prefix(ckey, dt_xmp_keys[i]) &amp;&amp; (ckey[len] == '[' || ckey[len] == '\0')))</a>
<a name="ln139">        break;</a>
<a name="ln140">      pos = xmp.erase(pos);</a>
<a name="ln141">    }</a>
<a name="ln142">  }</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">static void dt_remove_exif_keys(Exiv2::ExifData &amp;exif, const char *keys[], unsigned int n_keys)</a>
<a name="ln146">{</a>
<a name="ln147">  for(unsigned int i = 0; i &lt; n_keys; i++)</a>
<a name="ln148">  {</a>
<a name="ln149">    try</a>
<a name="ln150">    {</a>
<a name="ln151">      Exiv2::ExifData::iterator pos;</a>
<a name="ln152">      while((pos = exif.findKey(Exiv2::ExifKey(keys[i]))) != exif.end())</a>
<a name="ln153">        exif.erase(pos);</a>
<a name="ln154">    }</a>
<a name="ln155">    catch(Exiv2::AnyError &amp;e)</a>
<a name="ln156">    {</a>
<a name="ln157">      // the only exception we may get is &quot;invalid&quot; tag, which is not</a>
<a name="ln158">      // important enough to either stop the function, or even display</a>
<a name="ln159">      // a message (it's probably the tag is not implemented in the</a>
<a name="ln160">      // exiv2 version used)</a>
<a name="ln161">    }</a>
<a name="ln162">  }</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">static void dt_remove_xmp_keys(Exiv2::XmpData &amp;xmp, const char *keys[], unsigned int n_keys)</a>
<a name="ln166">{</a>
<a name="ln167">  for(unsigned int i = 0; i &lt; n_keys; i++)</a>
<a name="ln168">  {</a>
<a name="ln169">    try</a>
<a name="ln170">    {</a>
<a name="ln171">      Exiv2::XmpData::iterator pos;</a>
<a name="ln172">      while((pos = xmp.findKey(Exiv2::XmpKey(keys[i]))) != xmp.end())</a>
<a name="ln173">        xmp.erase(pos);</a>
<a name="ln174">    }</a>
<a name="ln175">    catch(Exiv2::AnyError &amp;e)</a>
<a name="ln176">    {</a>
<a name="ln177">      // the only exception we may get is &quot;invalid&quot; tag, which is not</a>
<a name="ln178">      // important enough to either stop the function, or even display</a>
<a name="ln179">      // a message (it's probably the tag is not implemented in the</a>
<a name="ln180">      // exiv2 version used)</a>
<a name="ln181">    }</a>
<a name="ln182">  }</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">static bool dt_exif_read_xmp_tag(Exiv2::XmpData &amp;xmpData, Exiv2::XmpData::iterator *pos, string key)</a>
<a name="ln186">{</a>
<a name="ln187">  try</a>
<a name="ln188">  {</a>
<a name="ln189">    return (*pos = xmpData.findKey(Exiv2::XmpKey(key))) != xmpData.end() &amp;&amp; (*pos)-&gt;size();</a>
<a name="ln190">  }</a>
<a name="ln191">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln192">  {</a>
<a name="ln193">    std::string s(e.what());</a>
<a name="ln194">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln195">    return false;</a>
<a name="ln196">  }</a>
<a name="ln197">}</a>
<a name="ln198">#define FIND_XMP_TAG(key) dt_exif_read_xmp_tag(xmpData, &amp;pos, key)</a>
<a name="ln199"> </a>
<a name="ln200"> </a>
<a name="ln201">// FIXME: according to http://www.exiv2.org/doc/classExiv2_1_1Metadatum.html#63c2b87249ba96679c29e01218169124</a>
<a name="ln202">// there is no need to pass xmpData</a>
<a name="ln203">// version = -1 -&gt; version ignored</a>
<a name="ln204">static bool dt_exif_read_xmp_data(dt_image_t *img, Exiv2::XmpData &amp;xmpData, int version,</a>
<a name="ln205">                                  bool use_default_rating)</a>
<a name="ln206">{</a>
<a name="ln207">  try</a>
<a name="ln208">  {</a>
<a name="ln209">    Exiv2::XmpData::iterator pos;</a>
<a name="ln210"> </a>
<a name="ln211">    // older darktable version did not write this data correctly:</a>
<a name="ln212">    // the reasoning behind strdup'ing all the strings before passing it to sqlite3 is, that</a>
<a name="ln213">    // they are somehow corrupt after the call to sqlite3_prepare_v2() -- don't ask me</a>
<a name="ln214">    // why for they don't get passed to that function.</a>
<a name="ln215">    if(version == -1 || version &gt; 0)</a>
<a name="ln216">    {</a>
<a name="ln217">      if(FIND_XMP_TAG(&quot;Xmp.dc.rights&quot;))</a>
<a name="ln218">      {</a>
<a name="ln219">        // rights</a>
<a name="ln220">        char *rights = strdup(pos-&gt;toString().c_str());</a>
<a name="ln221">        char *adr = rights;</a>
<a name="ln222">        if(strncmp(rights, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln223">        {</a>
<a name="ln224">          rights = strchr(rights, ' ');</a>
<a name="ln225">          if(rights != NULL) rights++;</a>
<a name="ln226">        }</a>
<a name="ln227">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.rights&quot;, rights);</a>
<a name="ln228">        free(adr);</a>
<a name="ln229">      }</a>
<a name="ln230">      if(FIND_XMP_TAG(&quot;Xmp.dc.description&quot;))</a>
<a name="ln231">      {</a>
<a name="ln232">        // description</a>
<a name="ln233">        char *description = strdup(pos-&gt;toString().c_str());</a>
<a name="ln234">        char *adr = description;</a>
<a name="ln235">        if(strncmp(description, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln236">        {</a>
<a name="ln237">          description = strchr(description, ' ');</a>
<a name="ln238">          if(description != NULL) description++;</a>
<a name="ln239">        }</a>
<a name="ln240">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.description&quot;, description);</a>
<a name="ln241">        free(adr);</a>
<a name="ln242">      }</a>
<a name="ln243">      if(FIND_XMP_TAG(&quot;Xmp.dc.title&quot;))</a>
<a name="ln244">      {</a>
<a name="ln245">        // title</a>
<a name="ln246">        char *title = strdup(pos-&gt;toString().c_str());</a>
<a name="ln247">        char *adr = title;</a>
<a name="ln248">        if(strncmp(title, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln249">        {</a>
<a name="ln250">          title = strchr(title, ' ');</a>
<a name="ln251">          if(title != NULL) title++;</a>
<a name="ln252">        }</a>
<a name="ln253">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.title&quot;, title);</a>
<a name="ln254">        free(adr);</a>
<a name="ln255">      }</a>
<a name="ln256">      if(FIND_XMP_TAG(&quot;Xmp.dc.creator&quot;))</a>
<a name="ln257">      {</a>
<a name="ln258">        // creator</a>
<a name="ln259">        char *creator = strdup(pos-&gt;toString().c_str());</a>
<a name="ln260">        char *adr = creator;</a>
<a name="ln261">        if(strncmp(creator, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln262">        {</a>
<a name="ln263">          creator = strchr(creator, ' ');</a>
<a name="ln264">          if(creator != NULL) creator++;</a>
<a name="ln265">        }</a>
<a name="ln266">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, creator);</a>
<a name="ln267">        free(adr);</a>
<a name="ln268">      }</a>
<a name="ln269">      if(FIND_XMP_TAG(&quot;Xmp.dc.publisher&quot;))</a>
<a name="ln270">      {</a>
<a name="ln271">        // publisher</a>
<a name="ln272">        char *publisher = strdup(pos-&gt;toString().c_str());</a>
<a name="ln273">        char *adr = publisher;</a>
<a name="ln274">        if(strncmp(publisher, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln275">        {</a>
<a name="ln276">          publisher = strchr(publisher, ' ');</a>
<a name="ln277">          if(publisher != NULL) publisher++;</a>
<a name="ln278">        }</a>
<a name="ln279">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.publisher&quot;, publisher);</a>
<a name="ln280">        free(adr);</a>
<a name="ln281">      }</a>
<a name="ln282">    }</a>
<a name="ln283"> </a>
<a name="ln284">    if(FIND_XMP_TAG(&quot;Xmp.xmp.Rating&quot;))</a>
<a name="ln285">    {</a>
<a name="ln286">      int stars = pos-&gt;toLong();</a>
<a name="ln287">      if(use_default_rating &amp;&amp; stars == 0) stars = dt_conf_get_int(&quot;ui_last/import_initial_rating&quot;);</a>
<a name="ln288"> </a>
<a name="ln289">      stars = (stars == -1) ? 6 : stars;</a>
<a name="ln290">      img-&gt;flags = (img-&gt;flags &amp; ~0x7) | (0x7 &amp; stars);</a>
<a name="ln291">    }</a>
<a name="ln292"> </a>
<a name="ln293">    if(FIND_XMP_TAG(&quot;Xmp.xmp.Label&quot;))</a>
<a name="ln294">    {</a>
<a name="ln295">      std::string label = pos-&gt;toString();</a>
<a name="ln296">      if(label == &quot;Red&quot;) // Is it really called like that in XMP files?</a>
<a name="ln297">        dt_colorlabels_set_label(img-&gt;id, 0);</a>
<a name="ln298">      else if(label == &quot;Yellow&quot;) // Is it really called like that in XMP files?</a>
<a name="ln299">        dt_colorlabels_set_label(img-&gt;id, 1);</a>
<a name="ln300">      else if(label == &quot;Green&quot;)</a>
<a name="ln301">        dt_colorlabels_set_label(img-&gt;id, 2);</a>
<a name="ln302">      else if(label == &quot;Blue&quot;) // Is it really called like that in XMP files?</a>
<a name="ln303">        dt_colorlabels_set_label(img-&gt;id, 3);</a>
<a name="ln304">      else if(label == &quot;Purple&quot;) // Is it really called like that in XMP files?</a>
<a name="ln305">        dt_colorlabels_set_label(img-&gt;id, 4);</a>
<a name="ln306">    }</a>
<a name="ln307">    if(FIND_XMP_TAG(&quot;Xmp.darktable.colorlabels&quot;))</a>
<a name="ln308">    {</a>
<a name="ln309">      // TODO: store these in dc:subject or xmp:Label?</a>
<a name="ln310">      // color labels</a>
<a name="ln311">      const int cnt = pos-&gt;count();</a>
<a name="ln312">      dt_colorlabels_remove_labels(img-&gt;id);</a>
<a name="ln313">      for(int i = 0; i &lt; cnt; i++)</a>
<a name="ln314">      {</a>
<a name="ln315">        dt_colorlabels_set_label(img-&gt;id, pos-&gt;toLong(i));</a>
<a name="ln316">      }</a>
<a name="ln317">    }</a>
<a name="ln318"> </a>
<a name="ln319">    if(FIND_XMP_TAG(&quot;Xmp.lr.hierarchicalSubject&quot;))</a>
<a name="ln320">      _exif_import_tags(img, pos);</a>
<a name="ln321">    else if(FIND_XMP_TAG(&quot;Xmp.dc.subject&quot;))</a>
<a name="ln322">      _exif_import_tags(img, pos);</a>
<a name="ln323"> </a>
<a name="ln324">    /* read gps location */</a>
<a name="ln325">    if(FIND_XMP_TAG(&quot;Xmp.exif.GPSLatitude&quot;))</a>
<a name="ln326">    {</a>
<a name="ln327">      img-&gt;latitude = dt_util_gps_string_to_number(pos-&gt;toString().c_str());</a>
<a name="ln328">    }</a>
<a name="ln329"> </a>
<a name="ln330">    if(FIND_XMP_TAG(&quot;Xmp.exif.GPSLongitude&quot;))</a>
<a name="ln331">    {</a>
<a name="ln332">      img-&gt;longitude = dt_util_gps_string_to_number(pos-&gt;toString().c_str());</a>
<a name="ln333">    }</a>
<a name="ln334"> </a>
<a name="ln335">    if(FIND_XMP_TAG(&quot;Xmp.exif.GPSAltitude&quot;))</a>
<a name="ln336">    {</a>
<a name="ln337">      Exiv2::XmpData::const_iterator ref = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.exif.GPSAltitudeRef&quot;));</a>
<a name="ln338">      if(ref != xmpData.end() &amp;&amp; ref-&gt;size())</a>
<a name="ln339">      {</a>
<a name="ln340">        std::string sign_str = ref-&gt;toString();</a>
<a name="ln341">        const char *sign = sign_str.c_str();</a>
<a name="ln342">        double elevation = 0.0;</a>
<a name="ln343">        if(dt_util_gps_elevation_to_number(pos-&gt;toRational(0).first, pos-&gt;toRational(0).second, sign[0], &amp;elevation))</a>
<a name="ln344">          img-&gt;elevation = elevation;</a>
<a name="ln345">      }</a>
<a name="ln346">    }</a>
<a name="ln347"> </a>
<a name="ln348">    /* read lens type from Xmp.exifEX.LensModel */</a>
<a name="ln349">    if(FIND_XMP_TAG(&quot;Xmp.exifEX.LensModel&quot;))</a>
<a name="ln350">    {</a>
<a name="ln351">      // lens model</a>
<a name="ln352">      char *lens = strdup(pos-&gt;toString().c_str());</a>
<a name="ln353">      char *adr =  lens;</a>
<a name="ln354">      if(strncmp(lens, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln355">      {</a>
<a name="ln356">        lens = strchr(lens, ' ');</a>
<a name="ln357">        if(lens != NULL) lens++;</a>
<a name="ln358">      }</a>
<a name="ln359">      // no need to do any Unicode&lt;-&gt;locale conversion, the field is specified as ASCII</a>
<a name="ln360">      g_strlcpy(img-&gt;exif_lens, lens, sizeof(img-&gt;exif_lens));</a>
<a name="ln361">      free(adr);</a>
<a name="ln362">    }</a>
<a name="ln363"> </a>
<a name="ln364">    /* read timestamp from Xmp.exif.DateTimeOriginal */</a>
<a name="ln365">    if(FIND_XMP_TAG(&quot;Xmp.exif.DateTimeOriginal&quot;))</a>
<a name="ln366">    {</a>
<a name="ln367">      char *datetime = strdup(pos-&gt;toString().c_str());</a>
<a name="ln368"> </a>
<a name="ln369">      /*</a>
<a name="ln370">       * exiftool (but apparently not evix2) convert</a>
<a name="ln371">       * e.g. &quot;2017:10:23 12:34:56&quot; to &quot;2017-10-23T12:34:54&quot; (ISO)</a>
<a name="ln372">       * revert this to the format expected by exif and darktable</a>
<a name="ln373">       */</a>
<a name="ln374"> </a>
<a name="ln375">      // replace 'T' by ' ' (space)</a>
<a name="ln376">      char *c ;</a>
<a name="ln377">      while ( ( c = strchr(datetime,'T') ) != NULL )</a>
<a name="ln378">      {</a>
<a name="ln379">	*c = ' ';</a>
<a name="ln380">      }</a>
<a name="ln381">      // replace '-' by ':'</a>
<a name="ln382">      while ( ( c = strchr(datetime,'-')) != NULL ) {</a>
<a name="ln383">	*c = ':';</a>
<a name="ln384">      }</a>
<a name="ln385"> </a>
<a name="ln386">      g_strlcpy(img-&gt;exif_datetime_taken, datetime, sizeof(img-&gt;exif_datetime_taken));</a>
<a name="ln387">      free(datetime);</a>
<a name="ln388">    }</a>
<a name="ln389"> </a>
<a name="ln390">    return true;</a>
<a name="ln391">  }</a>
<a name="ln392">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln393">  {</a>
<a name="ln394">    std::string s(e.what());</a>
<a name="ln395">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; img-&gt;filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln396">    return false;</a>
<a name="ln397">  }</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">static bool dt_exif_read_iptc_tag(Exiv2::IptcData &amp;iptcData, Exiv2::IptcData::const_iterator *pos, string key)</a>
<a name="ln401">{</a>
<a name="ln402">  try</a>
<a name="ln403">  {</a>
<a name="ln404">    return (*pos = iptcData.findKey(Exiv2::IptcKey(key))) != iptcData.end() &amp;&amp; (*pos)-&gt;size();</a>
<a name="ln405">  }</a>
<a name="ln406">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln407">  {</a>
<a name="ln408">    std::string s(e.what());</a>
<a name="ln409">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln410">    return false;</a>
<a name="ln411">  }</a>
<a name="ln412">}</a>
<a name="ln413">#define FIND_IPTC_TAG(key) dt_exif_read_iptc_tag(iptcData, &amp;pos, key)</a>
<a name="ln414"> </a>
<a name="ln415"> </a>
<a name="ln416">// FIXME: according to http://www.exiv2.org/doc/classExiv2_1_1Metadatum.html#63c2b87249ba96679c29e01218169124</a>
<a name="ln417">// there is no need to pass iptcData</a>
<a name="ln418">static bool dt_exif_read_iptc_data(dt_image_t *img, Exiv2::IptcData &amp;iptcData)</a>
<a name="ln419">{</a>
<a name="ln420">  try</a>
<a name="ln421">  {</a>
<a name="ln422">    Exiv2::IptcData::const_iterator pos;</a>
<a name="ln423">    iptcData.sortByKey(); // this helps to quickly find all Iptc.Application2.Keywords</a>
<a name="ln424"> </a>
<a name="ln425">    if((pos = iptcData.findKey(Exiv2::IptcKey(&quot;Iptc.Application2.Keywords&quot;))) != iptcData.end())</a>
<a name="ln426">    {</a>
<a name="ln427">      while(pos != iptcData.end())</a>
<a name="ln428">      {</a>
<a name="ln429">        std::string key = pos-&gt;key();</a>
<a name="ln430">        if(g_strcmp0(key.c_str(), &quot;Iptc.Application2.Keywords&quot;)) break;</a>
<a name="ln431">        std::string str = pos-&gt;print();</a>
<a name="ln432">        char *tag = dt_util_foo_to_utf8(str.c_str());</a>
<a name="ln433">        guint tagid = 0;</a>
<a name="ln434">        dt_tag_new(tag, &amp;tagid);</a>
<a name="ln435">        dt_tag_attach(tagid, img-&gt;id);</a>
<a name="ln436">        g_free(tag);</a>
<a name="ln437">        ++pos;</a>
<a name="ln438">      }</a>
<a name="ln439">    }</a>
<a name="ln440">    if(FIND_IPTC_TAG(&quot;Iptc.Application2.Caption&quot;))</a>
<a name="ln441">    {</a>
<a name="ln442">      std::string str = pos-&gt;print(/*&amp;iptcData*/);</a>
<a name="ln443">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.description&quot;, str.c_str());</a>
<a name="ln444">    }</a>
<a name="ln445">    if(FIND_IPTC_TAG(&quot;Iptc.Application2.Copyright&quot;))</a>
<a name="ln446">    {</a>
<a name="ln447">      std::string str = pos-&gt;print(/*&amp;iptcData*/);</a>
<a name="ln448">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.rights&quot;, str.c_str());</a>
<a name="ln449">    }</a>
<a name="ln450">    if(FIND_IPTC_TAG(&quot;Iptc.Application2.Writer&quot;))</a>
<a name="ln451">    {</a>
<a name="ln452">      std::string str = pos-&gt;print(/*&amp;iptcData*/);</a>
<a name="ln453">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str.c_str());</a>
<a name="ln454">    }</a>
<a name="ln455">    else if(FIND_IPTC_TAG(&quot;Iptc.Application2.Contact&quot;))</a>
<a name="ln456">    {</a>
<a name="ln457">      std::string str = pos-&gt;print(/*&amp;iptcData*/);</a>
<a name="ln458">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str.c_str());</a>
<a name="ln459">    }</a>
<a name="ln460"> </a>
<a name="ln461">    return true;</a>
<a name="ln462">  }</a>
<a name="ln463">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln464">  {</a>
<a name="ln465">    std::string s(e.what());</a>
<a name="ln466">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; img-&gt;filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln467">    return false;</a>
<a name="ln468">  }</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471">static bool dt_exif_read_exif_tag(Exiv2::ExifData &amp;exifData, Exiv2::ExifData::const_iterator *pos, string key)</a>
<a name="ln472">{</a>
<a name="ln473">  try</a>
<a name="ln474">  {</a>
<a name="ln475">    return (*pos = exifData.findKey(Exiv2::ExifKey(key))) != exifData.end() &amp;&amp; (*pos)-&gt;size();</a>
<a name="ln476">  }</a>
<a name="ln477">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln478">  {</a>
<a name="ln479">    std::string s(e.what());</a>
<a name="ln480">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln481">    return false;</a>
<a name="ln482">  }</a>
<a name="ln483">}</a>
<a name="ln484">#define FIND_EXIF_TAG(key) dt_exif_read_exif_tag(exifData, &amp;pos, key)</a>
<a name="ln485"> </a>
<a name="ln486">static void _find_datetime_taken(Exiv2::ExifData &amp;exifData, Exiv2::ExifData::const_iterator pos,</a>
<a name="ln487">                                 char *exif_datetime_taken)</a>
<a name="ln488">{</a>
<a name="ln489">  if(FIND_EXIF_TAG(&quot;Exif.Image.DateTimeOriginal&quot;))</a>
<a name="ln490">  {</a>
<a name="ln491">    dt_strlcpy_to_utf8(exif_datetime_taken, 20, pos, exifData);</a>
<a name="ln492">  }</a>
<a name="ln493">  else if(FIND_EXIF_TAG(&quot;Exif.Photo.DateTimeOriginal&quot;))</a>
<a name="ln494">  {</a>
<a name="ln495">    dt_strlcpy_to_utf8(exif_datetime_taken, 20, pos, exifData);</a>
<a name="ln496">  }</a>
<a name="ln497">  else</a>
<a name="ln498">  {</a>
<a name="ln499">    *exif_datetime_taken = '\0';</a>
<a name="ln500">  }</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">static bool dt_exif_read_exif_data(dt_image_t *img, Exiv2::ExifData &amp;exifData)</a>
<a name="ln504">{</a>
<a name="ln505">  try</a>
<a name="ln506">  {</a>
<a name="ln507">    /* List of tag names taken from exiv2's printSummary() in actions.cpp */</a>
<a name="ln508">    Exiv2::ExifData::const_iterator pos;</a>
<a name="ln509"> </a>
<a name="ln510">    // look for maker &amp; model first so we can use that info later</a>
<a name="ln511">    if(FIND_EXIF_TAG(&quot;Exif.Image.Make&quot;))</a>
<a name="ln512">    {</a>
<a name="ln513">      dt_strlcpy_to_utf8(img-&gt;exif_maker, sizeof(img-&gt;exif_maker), pos, exifData);</a>
<a name="ln514">    }</a>
<a name="ln515">    else if(FIND_EXIF_TAG(&quot;Exif.PanasonicRaw.Make&quot;))</a>
<a name="ln516">    {</a>
<a name="ln517">      dt_strlcpy_to_utf8(img-&gt;exif_maker, sizeof(img-&gt;exif_maker), pos, exifData);</a>
<a name="ln518">    }</a>
<a name="ln519"> </a>
<a name="ln520">    for(char *c = img-&gt;exif_maker + sizeof(img-&gt;exif_maker) - 1; c &gt; img-&gt;exif_maker; c--)</a>
<a name="ln521">      if(*c != ' ' &amp;&amp; *c != '\0')</a>
<a name="ln522">      {</a>
<a name="ln523">        *(c + 1) = '\0';</a>
<a name="ln524">        break;</a>
<a name="ln525">      }</a>
<a name="ln526"> </a>
<a name="ln527">    if(FIND_EXIF_TAG(&quot;Exif.Image.Model&quot;))</a>
<a name="ln528">    {</a>
<a name="ln529">      dt_strlcpy_to_utf8(img-&gt;exif_model, sizeof(img-&gt;exif_model), pos, exifData);</a>
<a name="ln530">    }</a>
<a name="ln531">    else if(FIND_EXIF_TAG(&quot;Exif.PanasonicRaw.Model&quot;))</a>
<a name="ln532">    {</a>
<a name="ln533">      dt_strlcpy_to_utf8(img-&gt;exif_model, sizeof(img-&gt;exif_model), pos, exifData);</a>
<a name="ln534">    }</a>
<a name="ln535"> </a>
<a name="ln536">    for(char *c = img-&gt;exif_model + sizeof(img-&gt;exif_model) - 1; c &gt; img-&gt;exif_model; c--)</a>
<a name="ln537">      if(*c != ' ' &amp;&amp; *c != '\0')</a>
<a name="ln538">      {</a>
<a name="ln539">        *(c + 1) = '\0';</a>
<a name="ln540">        break;</a>
<a name="ln541">      }</a>
<a name="ln542"> </a>
<a name="ln543">    // Make sure we copy the exif make and model to the correct place if needed</a>
<a name="ln544">    dt_image_refresh_makermodel(img);</a>
<a name="ln545"> </a>
<a name="ln546">    /* Read shutter time */</a>
<a name="ln547">    if(FIND_EXIF_TAG(&quot;Exif.Photo.ExposureTime&quot;))</a>
<a name="ln548">    {</a>
<a name="ln549">      // dt_strlcpy_to_utf8(uf-&gt;conf-&gt;shutterText, max_name, pos, exifData);</a>
<a name="ln550">      img-&gt;exif_exposure = pos-&gt;toFloat();</a>
<a name="ln551">    }</a>
<a name="ln552">    else if(FIND_EXIF_TAG(&quot;Exif.Photo.ShutterSpeedValue&quot;))</a>
<a name="ln553">    {</a>
<a name="ln554">      // uf_strlcpy_to_utf8(uf-&gt;conf-&gt;shutterText, max_name, pos, exifData);</a>
<a name="ln555">      img-&gt;exif_exposure = 1.0 / pos-&gt;toFloat();</a>
<a name="ln556">    }</a>
<a name="ln557">    /* Read aperture */</a>
<a name="ln558">    if(FIND_EXIF_TAG(&quot;Exif.Photo.FNumber&quot;))</a>
<a name="ln559">    {</a>
<a name="ln560">      img-&gt;exif_aperture = pos-&gt;toFloat();</a>
<a name="ln561">    }</a>
<a name="ln562">    else if(FIND_EXIF_TAG(&quot;Exif.Photo.ApertureValue&quot;))</a>
<a name="ln563">    {</a>
<a name="ln564">      img-&gt;exif_aperture = pos-&gt;toFloat();</a>
<a name="ln565">    }</a>
<a name="ln566"> </a>
<a name="ln567">    /* Read ISO speed - Nikon happens to return a pair for Lo and Hi modes */</a>
<a name="ln568">    if((pos = Exiv2::isoSpeed(exifData)) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln569">    {</a>
<a name="ln570">      // if standard exif iso tag, use the old way of interpreting the return value to be more regression-save</a>
<a name="ln571">      if(strcmp(pos-&gt;key().c_str(), &quot;Exif.Photo.ISOSpeedRatings&quot;) == 0)</a>
<a name="ln572">      {</a>
<a name="ln573">        int isofield = pos-&gt;count() &gt; 1 ? 1 : 0;</a>
<a name="ln574">        img-&gt;exif_iso = pos-&gt;toFloat(isofield);</a>
<a name="ln575">      }</a>
<a name="ln576">      else</a>
<a name="ln577">      {</a>
<a name="ln578">        std::string str = pos-&gt;print();</a>
<a name="ln579">        img-&gt;exif_iso = (float)std::atof(str.c_str());</a>
<a name="ln580">      }</a>
<a name="ln581">    }</a>
<a name="ln582">    // some newer cameras support iso settings that exceed the 16 bit of exif's ISOSpeedRatings</a>
<a name="ln583">    if(img-&gt;exif_iso == 65535 || img-&gt;exif_iso == 0)</a>
<a name="ln584">    {</a>
<a name="ln585">      if(FIND_EXIF_TAG(&quot;Exif.PentaxDng.ISO&quot;) || FIND_EXIF_TAG(&quot;Exif.Pentax.ISO&quot;))</a>
<a name="ln586">      {</a>
<a name="ln587">        std::string str = pos-&gt;print();</a>
<a name="ln588">        img-&gt;exif_iso = (float)std::atof(str.c_str());</a>
<a name="ln589">      }</a>
<a name="ln590">      else if((!g_strcmp0(img-&gt;exif_maker, &quot;SONY&quot;) || !g_strcmp0(img-&gt;exif_maker, &quot;Canon&quot;))</a>
<a name="ln591">        &amp;&amp; FIND_EXIF_TAG(&quot;Exif.Photo.RecommendedExposureIndex&quot;))</a>
<a name="ln592">      {</a>
<a name="ln593">        img-&gt;exif_iso = pos-&gt;toFloat();</a>
<a name="ln594">      }</a>
<a name="ln595">    }</a>
<a name="ln596"> </a>
<a name="ln597">    /* Read focal length  */</a>
<a name="ln598">    if((pos = Exiv2::focalLength(exifData)) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln599">    {</a>
<a name="ln600">      // This works around a bug in exiv2 the developers refuse to fix</a>
<a name="ln601">      // For details see http://dev.exiv2.org/issues/1083</a>
<a name="ln602">      if (pos-&gt;key() == &quot;Exif.Canon.FocalLength&quot; &amp;&amp; pos-&gt;count() == 4)</a>
<a name="ln603">        img-&gt;exif_focal_length = pos-&gt;toFloat(1);</a>
<a name="ln604">      else</a>
<a name="ln605">        img-&gt;exif_focal_length = pos-&gt;toFloat();</a>
<a name="ln606">    }</a>
<a name="ln607"> </a>
<a name="ln608">    /* Read focal length in 35mm if available and try to calculate crop factor */</a>
<a name="ln609">    if(FIND_EXIF_TAG(&quot;Exif.Photo.FocalLengthIn35mmFilm&quot;))</a>
<a name="ln610">    {</a>
<a name="ln611">      const float focal_length_35mm = pos-&gt;toFloat();</a>
<a name="ln612">      if(focal_length_35mm &gt; 0.0f &amp;&amp; img-&gt;exif_focal_length &gt; 0.0f)</a>
<a name="ln613">        img-&gt;exif_crop = focal_length_35mm / img-&gt;exif_focal_length;</a>
<a name="ln614">      else</a>
<a name="ln615">        img-&gt;exif_crop = 1.0f;</a>
<a name="ln616">    }</a>
<a name="ln617"> </a>
<a name="ln618">    if(FIND_EXIF_TAG(&quot;Exif.NikonLd2.FocusDistance&quot;))</a>
<a name="ln619">    {</a>
<a name="ln620">      float value = pos-&gt;toFloat();</a>
<a name="ln621">      img-&gt;exif_focus_distance = (0.01 * pow(10, value / 40));</a>
<a name="ln622">    }</a>
<a name="ln623">    else if(FIND_EXIF_TAG(&quot;Exif.NikonLd3.FocusDistance&quot;))</a>
<a name="ln624">    {</a>
<a name="ln625">      float value = pos-&gt;toFloat();</a>
<a name="ln626">      img-&gt;exif_focus_distance = (0.01 * pow(10, value / 40));</a>
<a name="ln627">    }</a>
<a name="ln628">    else if(FIND_EXIF_TAG(&quot;Exif.OlympusFi.FocusDistance&quot;))</a>
<a name="ln629">    {</a>
<a name="ln630">      /* the distance is stored as a rational (fraction). according to</a>
<a name="ln631">       * http://www.dpreview.com/forums/thread/1173960?page=4</a>
<a name="ln632">       * some Olympus cameras have a wrong denominator of 10 in there while the nominator is always in mm.</a>
<a name="ln633">       * thus we ignore the denominator</a>
<a name="ln634">       * and divide with 1000.</a>
<a name="ln635">       * &quot;I've checked a number of E-1 and E-300 images, and I agree that the FocusDistance looks like it is</a>
<a name="ln636">       * in mm for the E-1. However,</a>
<a name="ln637">       * it looks more like cm for the E-300.</a>
<a name="ln638">       * For both cameras, this value is stored as a rational. With the E-1, the denominator is always 1,</a>
<a name="ln639">       * while for the E-300 it is 10.</a>
<a name="ln640">       * Therefore, it looks like the numerator in both cases is in mm (which makes a bit of sense, in an odd</a>
<a name="ln641">       * sort of way). So I think</a>
<a name="ln642">       * what I will do in ExifTool is to take the numerator and divide by 1000 to display the focus distance</a>
<a name="ln643">       * in meters.&quot;</a>
<a name="ln644">       *   -- Boardhead, dpreview forums in 2005</a>
<a name="ln645">       */</a>
<a name="ln646">      int nominator = pos-&gt;toRational(0).first;</a>
<a name="ln647">      img-&gt;exif_focus_distance = fmax(0.0, (0.001 * nominator));</a>
<a name="ln648">    }</a>
<a name="ln649">    else if(EXIV2_MAKE_VERSION(0,25,0) &lt;= Exiv2::versionNumber() &amp;&amp; FIND_EXIF_TAG(&quot;Exif.CanonFi.FocusDistanceUpper&quot;))</a>
<a name="ln650">    {</a>
<a name="ln651">      const float FocusDistanceUpper = pos-&gt;toFloat();</a>
<a name="ln652">      if(FocusDistanceUpper &lt;= 0.0f || (int)FocusDistanceUpper &gt;= 0xffff)</a>
<a name="ln653">      {</a>
<a name="ln654">        img-&gt;exif_focus_distance = 0.0f;</a>
<a name="ln655">      }</a>
<a name="ln656">      else</a>
<a name="ln657">      {</a>
<a name="ln658">        img-&gt;exif_focus_distance = FocusDistanceUpper / 100.0;</a>
<a name="ln659">        if(FIND_EXIF_TAG(&quot;Exif.CanonFi.FocusDistanceLower&quot;))</a>
<a name="ln660">        {</a>
<a name="ln661">          const float FocusDistanceLower = pos-&gt;toFloat();</a>
<a name="ln662">          if(FocusDistanceLower &gt; 0.0f &amp;&amp; (int)FocusDistanceLower &lt; 0xffff)</a>
<a name="ln663">          {</a>
<a name="ln664">            img-&gt;exif_focus_distance += FocusDistanceLower / 100.0;</a>
<a name="ln665">            img-&gt;exif_focus_distance /= 2.0;</a>
<a name="ln666">          }</a>
<a name="ln667">        }</a>
<a name="ln668">      }</a>
<a name="ln669">    }</a>
<a name="ln670">    else if(FIND_EXIF_TAG(&quot;Exif.CanonSi.SubjectDistance&quot;))</a>
<a name="ln671">    {</a>
<a name="ln672">      img-&gt;exif_focus_distance = pos-&gt;toFloat() / 100.0;</a>
<a name="ln673">    }</a>
<a name="ln674">    else if((pos = Exiv2::subjectDistance(exifData)) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln675">    {</a>
<a name="ln676">      img-&gt;exif_focus_distance = pos-&gt;toFloat();</a>
<a name="ln677">    }</a>
<a name="ln678">    /** read image orientation */</a>
<a name="ln679">    if(FIND_EXIF_TAG(&quot;Exif.Image.Orientation&quot;))</a>
<a name="ln680">    {</a>
<a name="ln681">      img-&gt;orientation = dt_image_orientation_to_flip_bits(pos-&gt;toLong());</a>
<a name="ln682">    }</a>
<a name="ln683">    else if(FIND_EXIF_TAG(&quot;Exif.PanasonicRaw.Orientation&quot;))</a>
<a name="ln684">    {</a>
<a name="ln685">      img-&gt;orientation = dt_image_orientation_to_flip_bits(pos-&gt;toLong());</a>
<a name="ln686">    }</a>
<a name="ln687"> </a>
<a name="ln688">    /* read gps location */</a>
<a name="ln689">    if(FIND_EXIF_TAG(&quot;Exif.GPSInfo.GPSLatitude&quot;))</a>
<a name="ln690">    {</a>
<a name="ln691">      Exiv2::ExifData::const_iterator ref = exifData.findKey(Exiv2::ExifKey(&quot;Exif.GPSInfo.GPSLatitudeRef&quot;));</a>
<a name="ln692">      if(ref != exifData.end() &amp;&amp; ref-&gt;size())</a>
<a name="ln693">      {</a>
<a name="ln694">        std::string sign_str = ref-&gt;toString();</a>
<a name="ln695">        const char *sign = sign_str.c_str();</a>
<a name="ln696">        double latitude = 0.0;</a>
<a name="ln697">        if(dt_util_gps_rationale_to_number(pos-&gt;toRational(0).first, pos-&gt;toRational(0).second,</a>
<a name="ln698">                                           pos-&gt;toRational(1).first, pos-&gt;toRational(1).second,</a>
<a name="ln699">                                           pos-&gt;toRational(2).first, pos-&gt;toRational(2).second, sign[0], &amp;latitude))</a>
<a name="ln700">          img-&gt;latitude = latitude;</a>
<a name="ln701">      }</a>
<a name="ln702">    }</a>
<a name="ln703"> </a>
<a name="ln704">    if(FIND_EXIF_TAG(&quot;Exif.GPSInfo.GPSLongitude&quot;))</a>
<a name="ln705">    {</a>
<a name="ln706">      Exiv2::ExifData::const_iterator ref = exifData.findKey(Exiv2::ExifKey(&quot;Exif.GPSInfo.GPSLongitudeRef&quot;));</a>
<a name="ln707">      if(ref != exifData.end() &amp;&amp; ref-&gt;size())</a>
<a name="ln708">      {</a>
<a name="ln709">        std::string sign_str = ref-&gt;toString();</a>
<a name="ln710">        const char *sign = sign_str.c_str();</a>
<a name="ln711">        double longitude = 0.0;</a>
<a name="ln712">        if(dt_util_gps_rationale_to_number(pos-&gt;toRational(0).first, pos-&gt;toRational(0).second,</a>
<a name="ln713">                                           pos-&gt;toRational(1).first, pos-&gt;toRational(1).second,</a>
<a name="ln714">                                           pos-&gt;toRational(2).first, pos-&gt;toRational(2).second, sign[0], &amp;longitude))</a>
<a name="ln715">          img-&gt;longitude = longitude;</a>
<a name="ln716">      }</a>
<a name="ln717">    }</a>
<a name="ln718"> </a>
<a name="ln719">    if(FIND_EXIF_TAG(&quot;Exif.GPSInfo.GPSAltitude&quot;))</a>
<a name="ln720">    {</a>
<a name="ln721">      Exiv2::ExifData::const_iterator ref = exifData.findKey(Exiv2::ExifKey(&quot;Exif.GPSInfo.GPSAltitudeRef&quot;));</a>
<a name="ln722">      if(ref != exifData.end() &amp;&amp; ref-&gt;size())</a>
<a name="ln723">      {</a>
<a name="ln724">        std::string sign_str = ref-&gt;toString();</a>
<a name="ln725">        const char *sign = sign_str.c_str();</a>
<a name="ln726">        double elevation = 0.0;</a>
<a name="ln727">        if(dt_util_gps_elevation_to_number(pos-&gt;toRational(0).first, pos-&gt;toRational(0).second, sign[0], &amp;elevation))</a>
<a name="ln728">          img-&gt;elevation = elevation;</a>
<a name="ln729">      }</a>
<a name="ln730">    }</a>
<a name="ln731"> </a>
<a name="ln732">    /* Read lens name */</a>
<a name="ln733">    if((FIND_EXIF_TAG(&quot;Exif.CanonCs.LensType&quot;) &amp;&amp; pos-&gt;print(&amp;exifData) != &quot;(0)&quot;</a>
<a name="ln734">        &amp;&amp; pos-&gt;print(&amp;exifData) != &quot;(65535)&quot;)</a>
<a name="ln735">       || FIND_EXIF_TAG(&quot;Exif.Canon.0x0095&quot;))</a>
<a name="ln736">    {</a>
<a name="ln737">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln738">    }</a>
<a name="ln739">    else if(EXIV2_MAKE_VERSION(0,25,0) &lt;= Exiv2::versionNumber() &amp;&amp; FIND_EXIF_TAG(&quot;Exif.PentaxDng.LensType&quot;))</a>
<a name="ln740">    {</a>
<a name="ln741">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln742">    }</a>
<a name="ln743">    else if(FIND_EXIF_TAG(&quot;Exif.Panasonic.LensType&quot;))</a>
<a name="ln744">    {</a>
<a name="ln745">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln746">    }</a>
<a name="ln747">    else if(FIND_EXIF_TAG(&quot;Exif.OlympusEq.LensType&quot;))</a>
<a name="ln748">    {</a>
<a name="ln749">      /* For every Olympus camera Exif.OlympusEq.LensType is present. */</a>
<a name="ln750">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln751"> </a>
<a name="ln752">      /* We have to check if Exif.OlympusEq.LensType has been translated by</a>
<a name="ln753">       * exiv2. If it hasn't, fall back to Exif.OlympusEq.LensModel. */</a>
<a name="ln754">      std::string lens(img-&gt;exif_lens);</a>
<a name="ln755">      if(std::string::npos == lens.find_first_not_of(&quot; 1234567890&quot;))</a>
<a name="ln756">      {</a>
<a name="ln757">        /* Exif.OlympusEq.LensType contains only digits and spaces.</a>
<a name="ln758">         * This means that exiv2 couldn't convert it to human readable</a>
<a name="ln759">         * form. */</a>
<a name="ln760">        if(FIND_EXIF_TAG(&quot;Exif.OlympusEq.LensModel&quot;))</a>
<a name="ln761">        {</a>
<a name="ln762">          dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln763">        }</a>
<a name="ln764">        /* Just in case Exif.OlympusEq.LensModel hasn't been found */</a>
<a name="ln765">        else if(FIND_EXIF_TAG(&quot;Exif.Photo.LensModel&quot;))</a>
<a name="ln766">        {</a>
<a name="ln767">          dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln768">        }</a>
<a name="ln769">        fprintf(stderr, &quot;[exif] Warning: lens \&quot;%s\&quot; unknown as \&quot;%s\&quot;\n&quot;, img-&gt;exif_lens, lens.c_str());</a>
<a name="ln770">      }</a>
<a name="ln771">    }</a>
<a name="ln772">    else if((pos = Exiv2::lensName(exifData)) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln773">    {</a>
<a name="ln774">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln775">    }</a>
<a name="ln776">    else if(FIND_EXIF_TAG(&quot;Exif.Photo.LensModel&quot;))</a>
<a name="ln777">    {</a>
<a name="ln778">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln779">    }</a>
<a name="ln780"> </a>
<a name="ln781">#if 0</a>
<a name="ln782">    /* Read flash mode */</a>
<a name="ln783">    if ( (pos=exifData.findKey(Exiv2::ExifKey(&quot;Exif.Photo.Flash&quot;)))</a>
<a name="ln784">         != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln785">    {</a>
<a name="ln786">      uf_strlcpy_to_utf8(uf-&gt;conf-&gt;flashText, max_name, pos, exifData);</a>
<a name="ln787">    }</a>
<a name="ln788">    /* Read White Balance Setting */</a>
<a name="ln789">    if ( (pos=exifData.findKey(Exiv2::ExifKey(&quot;Exif.Photo.WhiteBalance&quot;)))</a>
<a name="ln790">         != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln791">    {</a>
<a name="ln792">      uf_strlcpy_to_utf8(uf-&gt;conf-&gt;whiteBalanceText, max_name, pos, exifData);</a>
<a name="ln793">    }</a>
<a name="ln794">#endif</a>
<a name="ln795"> </a>
<a name="ln796">    _find_datetime_taken(exifData, pos, img-&gt;exif_datetime_taken);</a>
<a name="ln797"> </a>
<a name="ln798">    if(FIND_EXIF_TAG(&quot;Exif.Image.Artist&quot;))</a>
<a name="ln799">    {</a>
<a name="ln800">      std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln801">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str.c_str());</a>
<a name="ln802">    }</a>
<a name="ln803">    else if(FIND_EXIF_TAG(&quot;Exif.Canon.OwnerName&quot;))</a>
<a name="ln804">    {</a>
<a name="ln805">      std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln806">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str.c_str());</a>
<a name="ln807">    }</a>
<a name="ln808"> </a>
<a name="ln809">    // FIXME: Should the UserComment go into the description? Or do we need an extra field for this?</a>
<a name="ln810">    if(FIND_EXIF_TAG(&quot;Exif.Photo.UserComment&quot;))</a>
<a name="ln811">    {</a>
<a name="ln812">      std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln813">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.description&quot;, str.c_str());</a>
<a name="ln814">    }</a>
<a name="ln815"> </a>
<a name="ln816">    if(FIND_EXIF_TAG(&quot;Exif.Image.Copyright&quot;))</a>
<a name="ln817">    {</a>
<a name="ln818">      std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln819">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.rights&quot;, str.c_str());</a>
<a name="ln820">    }</a>
<a name="ln821"> </a>
<a name="ln822">    if(FIND_EXIF_TAG(&quot;Exif.Image.Rating&quot;))</a>
<a name="ln823">    {</a>
<a name="ln824">      int stars = pos-&gt;toLong();</a>
<a name="ln825">      if(stars == 0)</a>
<a name="ln826">      {</a>
<a name="ln827">        stars = dt_conf_get_int(&quot;ui_last/import_initial_rating&quot;);</a>
<a name="ln828">      }</a>
<a name="ln829">      else</a>
<a name="ln830">      {</a>
<a name="ln831">        stars = (stars == -1) ? 6 : stars;</a>
<a name="ln832">      }</a>
<a name="ln833">      img-&gt;flags = (img-&gt;flags &amp; ~0x7) | (0x7 &amp; stars);</a>
<a name="ln834">    }</a>
<a name="ln835">    else if(FIND_EXIF_TAG(&quot;Exif.Image.RatingPercent&quot;))</a>
<a name="ln836">    {</a>
<a name="ln837">      int stars = pos-&gt;toLong() * 5. / 100;</a>
<a name="ln838">      if(stars == 0)</a>
<a name="ln839">      {</a>
<a name="ln840">        stars = dt_conf_get_int(&quot;ui_last/import_initial_rating&quot;);</a>
<a name="ln841">      }</a>
<a name="ln842">      else</a>
<a name="ln843">      {</a>
<a name="ln844">        stars = (stars == -1) ? 6 : stars;</a>
<a name="ln845">      }</a>
<a name="ln846">      img-&gt;flags = (img-&gt;flags &amp; ~0x7) | (0x7 &amp; stars);</a>
<a name="ln847">    }</a>
<a name="ln848"> </a>
<a name="ln849">    // read embedded color matrix as used in DNGs</a>
<a name="ln850">    {</a>
<a name="ln851">      int is_1_65 = -1, is_2_65 = -1; // -1: not found, 0: some random type, 1: D65</a>
<a name="ln852">      if(FIND_EXIF_TAG(&quot;Exif.Image.CalibrationIlluminant1&quot;))</a>
<a name="ln853">      {</a>
<a name="ln854">        is_1_65 = (pos-&gt;toLong() == 21) ? 1 : 0;</a>
<a name="ln855">      }</a>
<a name="ln856">      if(FIND_EXIF_TAG(&quot;Exif.Image.CalibrationIlluminant2&quot;))</a>
<a name="ln857">      {</a>
<a name="ln858">        is_2_65 = (pos-&gt;toLong() == 21) ? 1 : 0;</a>
<a name="ln859">      }</a>
<a name="ln860"> </a>
<a name="ln861">      // use the d65 (type == 21) matrix if we found it, otherwise use whatever we got</a>
<a name="ln862">      Exiv2::ExifData::const_iterator cm1_pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.Image.ColorMatrix1&quot;));</a>
<a name="ln863">      Exiv2::ExifData::const_iterator cm2_pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.Image.ColorMatrix2&quot;));</a>
<a name="ln864">      if(is_1_65 == 1 &amp;&amp; cm1_pos != exifData.end() &amp;&amp; cm1_pos-&gt;count() == 9 &amp;&amp; cm1_pos-&gt;size())</a>
<a name="ln865">        for(int i = 0; i &lt; 9; i++) img-&gt;d65_color_matrix[i] = cm1_pos-&gt;toFloat(i);</a>
<a name="ln866">      else if(is_2_65 == 1 &amp;&amp; cm2_pos != exifData.end() &amp;&amp; cm2_pos-&gt;count() == 9 &amp;&amp; cm2_pos-&gt;size())</a>
<a name="ln867">        for(int i = 0; i &lt; 9; i++) img-&gt;d65_color_matrix[i] = cm2_pos-&gt;toFloat(i);</a>
<a name="ln868">      else if(cm1_pos != exifData.end() &amp;&amp; cm1_pos-&gt;count() == 9 &amp;&amp; cm1_pos-&gt;size())</a>
<a name="ln869">        for(int i = 0; i &lt; 9; i++) img-&gt;d65_color_matrix[i] = cm1_pos-&gt;toFloat(i);</a>
<a name="ln870">      else if(cm2_pos != exifData.end() &amp;&amp; cm2_pos-&gt;count() == 9 &amp;&amp; cm2_pos-&gt;size())</a>
<a name="ln871">        for(int i = 0; i &lt; 9; i++) img-&gt;d65_color_matrix[i] = cm2_pos-&gt;toFloat(i);</a>
<a name="ln872">    }</a>
<a name="ln873"> </a>
<a name="ln874">    // some files have the colorspace explicitly set. try to read that.</a>
<a name="ln875">    // is_ldr -&gt; none</a>
<a name="ln876">    // 0x01   -&gt; sRGB</a>
<a name="ln877">    // 0x02   -&gt; AdobeRGB</a>
<a name="ln878">    // 0xffff -&gt; Uncalibrated</a>
<a name="ln879">    //          + Exif.Iop.InteroperabilityIndex of 'R03' -&gt; AdobeRGB</a>
<a name="ln880">    //          + Exif.Iop.InteroperabilityIndex of 'R98' -&gt; sRGB</a>
<a name="ln881">    if(dt_image_is_ldr(img) &amp;&amp; FIND_EXIF_TAG(&quot;Exif.Photo.ColorSpace&quot;))</a>
<a name="ln882">    {</a>
<a name="ln883">      int colorspace = pos-&gt;toLong();</a>
<a name="ln884">      if(colorspace == 0x01)</a>
<a name="ln885">        img-&gt;colorspace = DT_IMAGE_COLORSPACE_SRGB;</a>
<a name="ln886">      else if(colorspace == 0x02)</a>
<a name="ln887">        img-&gt;colorspace = DT_IMAGE_COLORSPACE_ADOBE_RGB;</a>
<a name="ln888">      else if(colorspace == 0xffff)</a>
<a name="ln889">      {</a>
<a name="ln890">        if(FIND_EXIF_TAG(&quot;Exif.Iop.InteroperabilityIndex&quot;))</a>
<a name="ln891">        {</a>
<a name="ln892">          std::string interop_index = pos-&gt;toString();</a>
<a name="ln893">          if(interop_index == &quot;R03&quot;)</a>
<a name="ln894">            img-&gt;colorspace = DT_IMAGE_COLORSPACE_ADOBE_RGB;</a>
<a name="ln895">          else if(interop_index == &quot;R98&quot;)</a>
<a name="ln896">            img-&gt;colorspace = DT_IMAGE_COLORSPACE_SRGB;</a>
<a name="ln897">        }</a>
<a name="ln898">      }</a>
<a name="ln899">    }</a>
<a name="ln900"> </a>
<a name="ln901">#if EXIV2_MINOR_VERSION &lt; 23</a>
<a name="ln902">    // workaround for an exiv2 bug writing random garbage into exif_lens for this camera:</a>
<a name="ln903">    // http://dev.exiv2.org/issues/779</a>
<a name="ln904">    if(!strcmp(img-&gt;exif_model, &quot;DMC-GH2&quot;)) snprintf(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), &quot;(unknown)&quot;);</a>
<a name="ln905">#endif</a>
<a name="ln906"> </a>
<a name="ln907">    // Improve lens detection for Sony SAL lenses.</a>
<a name="ln908">    if(FIND_EXIF_TAG(&quot;Exif.Sony2.LensID&quot;) &amp;&amp; pos-&gt;toLong() != 65535 &amp;&amp; pos-&gt;print().find('|') == std::string::npos)</a>
<a name="ln909">    {</a>
<a name="ln910">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln911">    }</a>
<a name="ln912">    // Workaround for an issue on newer Sony NEX cams.</a>
<a name="ln913">    // The default EXIF field is not used by Sony to store lens data</a>
<a name="ln914">    // http://dev.exiv2.org/issues/883</a>
<a name="ln915">    // http://darktable.org/redmine/issues/8813</a>
<a name="ln916">    // FIXME: This is still a workaround</a>
<a name="ln917">    else if((!strncmp(img-&gt;exif_model, &quot;NEX&quot;, 3)) || (!strncmp(img-&gt;exif_model, &quot;ILCE&quot;, 4)))</a>
<a name="ln918">    {</a>
<a name="ln919">      snprintf(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), &quot;(unknown)&quot;);</a>
<a name="ln920">      if(FIND_EXIF_TAG(&quot;Exif.Photo.LensModel&quot;))</a>
<a name="ln921">      {</a>
<a name="ln922">        std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln923">        snprintf(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), &quot;%s&quot;, str.c_str());</a>
<a name="ln924">      }</a>
<a name="ln925">    };</a>
<a name="ln926"> </a>
<a name="ln927">    img-&gt;exif_inited = 1;</a>
<a name="ln928">    return true;</a>
<a name="ln929">  }</a>
<a name="ln930">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln931">  {</a>
<a name="ln932">    std::string s(e.what());</a>
<a name="ln933">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; img-&gt;filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln934">    return false;</a>
<a name="ln935">  }</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">static void dt_exif_apply_global_overwrites(dt_image_t *img)</a>
<a name="ln939">{</a>
<a name="ln940">  if(dt_conf_get_bool(&quot;ui_last/import_apply_metadata&quot;) == TRUE)</a>
<a name="ln941">  {</a>
<a name="ln942">    char *str;</a>
<a name="ln943"> </a>
<a name="ln944">    str = dt_conf_get_string(&quot;ui_last/import_last_creator&quot;);</a>
<a name="ln945">    if(str != NULL &amp;&amp; str[0] != '\0') dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str);</a>
<a name="ln946">    g_free(str);</a>
<a name="ln947"> </a>
<a name="ln948">    str = dt_conf_get_string(&quot;ui_last/import_last_rights&quot;);</a>
<a name="ln949">    if(str != NULL &amp;&amp; str[0] != '\0') dt_metadata_set(img-&gt;id, &quot;Xmp.dc.rights&quot;, str);</a>
<a name="ln950">    g_free(str);</a>
<a name="ln951"> </a>
<a name="ln952">    str = dt_conf_get_string(&quot;ui_last/import_last_publisher&quot;);</a>
<a name="ln953">    if(str != NULL &amp;&amp; str[0] != '\0') dt_metadata_set(img-&gt;id, &quot;Xmp.dc.publisher&quot;, str);</a>
<a name="ln954">    g_free(str);</a>
<a name="ln955"> </a>
<a name="ln956">    str = dt_conf_get_string(&quot;ui_last/import_last_tags&quot;);</a>
<a name="ln957">    if(str != NULL &amp;&amp; str[0] != '\0') dt_tag_attach_string_list(str, img-&gt;id);</a>
<a name="ln958">    g_free(str);</a>
<a name="ln959">  }</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962">// TODO: can this blob also contain xmp and iptc data?</a>
<a name="ln963">int dt_exif_read_from_blob(dt_image_t *img, uint8_t *blob, const int size)</a>
<a name="ln964">{</a>
<a name="ln965">  try</a>
<a name="ln966">  {</a>
<a name="ln967">    Exiv2::ExifData exifData;</a>
<a name="ln968">    Exiv2::ExifParser::decode(exifData, blob, size);</a>
<a name="ln969">    bool res = dt_exif_read_exif_data(img, exifData);</a>
<a name="ln970">    dt_exif_apply_global_overwrites(img);</a>
<a name="ln971">    return res ? 0 : 1;</a>
<a name="ln972">  }</a>
<a name="ln973">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln974">  {</a>
<a name="ln975">    std::string s(e.what());</a>
<a name="ln976">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; img-&gt;filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln977">    return 1;</a>
<a name="ln978">  }</a>
<a name="ln979">}</a>
<a name="ln980"> </a>
<a name="ln981">/**</a>
<a name="ln982"> * Get the largest possible thumbnail from the image</a>
<a name="ln983"> */</a>
<a name="ln984">int dt_exif_get_thumbnail(const char *path, uint8_t **buffer, size_t *size, char **mime_type)</a>
<a name="ln985">{</a>
<a name="ln986">  try</a>
<a name="ln987">  {</a>
<a name="ln988">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(path)));</a>
<a name="ln989">    assert(image.get() != 0);</a>
<a name="ln990">    read_metadata_threadsafe(image);</a>
<a name="ln991"> </a>
<a name="ln992">    // Get a list of preview images available in the image. The list is sorted</a>
<a name="ln993">    // by the preview image pixel size, starting with the smallest preview.</a>
<a name="ln994">    Exiv2::PreviewManager loader(*image);</a>
<a name="ln995">    Exiv2::PreviewPropertiesList list = loader.getPreviewProperties();</a>
<a name="ln996">    if(list.empty())</a>
<a name="ln997">    {</a>
<a name="ln998">      dt_print(DT_DEBUG_LIGHTTABLE, &quot;[exiv2] couldn't find thumbnail for %s&quot;, path);</a>
<a name="ln999">      return 1;</a>
<a name="ln1000">    }</a>
<a name="ln1001"> </a>
<a name="ln1002">    // Select the largest one</a>
<a name="ln1003">    // FIXME: We could probably select a smaller thumbnail to match the mip size</a>
<a name="ln1004">    //        we actually want to create. Is it really much faster though?</a>
<a name="ln1005">    Exiv2::PreviewProperties selected = list.back();</a>
<a name="ln1006"> </a>
<a name="ln1007">    // Get the selected preview image</a>
<a name="ln1008">    Exiv2::PreviewImage preview = loader.getPreviewImage(selected);</a>
<a name="ln1009">    const unsigned  char *tmp = preview.pData();</a>
<a name="ln1010">    size_t _size = preview.size();</a>
<a name="ln1011"> </a>
<a name="ln1012">    *size = _size;</a>
<a name="ln1013">    *mime_type = strdup(preview.mimeType().c_str());</a>
<a name="ln1014">    *buffer = (uint8_t *)malloc(_size);</a>
<a name="ln1015">    if(!*buffer) {</a>
<a name="ln1016">      std::cerr &lt;&lt; &quot;[exiv2] couldn't allocate memory for thumbnail for &quot; &lt;&lt; path &lt;&lt; std::endl;</a>
<a name="ln1017">      return 1;</a>
<a name="ln1018">    }</a>
<a name="ln1019">    //std::cerr &lt;&lt; &quot;[exiv2] &quot;&lt;&lt; path &lt;&lt; &quot;: found thumbnail &quot;&lt;&lt; preview.width() &lt;&lt; &quot;x&quot; &lt;&lt; preview.height() &lt;&lt; std::endl;</a>
<a name="ln1020">    memcpy(*buffer, tmp, _size);</a>
<a name="ln1021"> </a>
<a name="ln1022">    return 0;</a>
<a name="ln1023">  }</a>
<a name="ln1024">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1025">  {</a>
<a name="ln1026">    std::string s(e.what());</a>
<a name="ln1027">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; path &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1028">    return 1;</a>
<a name="ln1029">  }</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">/** read the metadata of an image.</a>
<a name="ln1033"> * XMP data trumps IPTC data trumps EXIF data</a>
<a name="ln1034"> */</a>
<a name="ln1035">int dt_exif_read(dt_image_t *img, const char *path)</a>
<a name="ln1036">{</a>
<a name="ln1037">  // at least set datetime taken to something useful in case there is no exif data in this file (pfm, png,</a>
<a name="ln1038">  // ...)</a>
<a name="ln1039">  struct stat statbuf;</a>
<a name="ln1040"> </a>
<a name="ln1041">  if(!stat(path, &amp;statbuf))</a>
<a name="ln1042">  {</a>
<a name="ln1043">    struct tm result;</a>
<a name="ln1044">    strftime(img-&gt;exif_datetime_taken, 20, &quot;%Y:%m:%d %H:%M:%S&quot;, localtime_r(&amp;statbuf.st_mtime, &amp;result));</a>
<a name="ln1045">  }</a>
<a name="ln1046"> </a>
<a name="ln1047">  try</a>
<a name="ln1048">  {</a>
<a name="ln1049">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(path)));</a>
<a name="ln1050">    assert(image.get() != 0);</a>
<a name="ln1051">    read_metadata_threadsafe(image);</a>
<a name="ln1052">    bool res = true;</a>
<a name="ln1053"> </a>
<a name="ln1054">    // EXIF metadata</a>
<a name="ln1055">    Exiv2::ExifData &amp;exifData = image-&gt;exifData();</a>
<a name="ln1056">    if(!exifData.empty())</a>
<a name="ln1057">      res = dt_exif_read_exif_data(img, exifData);</a>
<a name="ln1058">    else</a>
<a name="ln1059">      img-&gt;exif_inited = 1;</a>
<a name="ln1060"> </a>
<a name="ln1061">    // these get overwritten by IPTC and XMP. is that how it should work?</a>
<a name="ln1062">    dt_exif_apply_global_overwrites(img);</a>
<a name="ln1063"> </a>
<a name="ln1064">    // IPTC metadata.</a>
<a name="ln1065">    Exiv2::IptcData &amp;iptcData = image-&gt;iptcData();</a>
<a name="ln1066">    if(!iptcData.empty()) res = dt_exif_read_iptc_data(img, iptcData) &amp;&amp; res;</a>
<a name="ln1067"> </a>
<a name="ln1068">    // XMP metadata</a>
<a name="ln1069">    Exiv2::XmpData &amp;xmpData = image-&gt;xmpData();</a>
<a name="ln1070">    if(!xmpData.empty()) res = dt_exif_read_xmp_data(img, xmpData, -1, true) &amp;&amp; res;</a>
<a name="ln1071"> </a>
<a name="ln1072">    // Initialize size - don't wait for full raw to be loaded to get this</a>
<a name="ln1073">    // information. If use_embedded_thumbnail is set, it will take a</a>
<a name="ln1074">    // change in development history to have this information</a>
<a name="ln1075">    img-&gt;height = image-&gt;pixelHeight();</a>
<a name="ln1076">    img-&gt;width = image-&gt;pixelWidth();</a>
<a name="ln1077"> </a>
<a name="ln1078">    return res ? 0 : 1;</a>
<a name="ln1079">  }</a>
<a name="ln1080">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1081">  {</a>
<a name="ln1082">    std::string s(e.what());</a>
<a name="ln1083">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; path &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1084">    return 1;</a>
<a name="ln1085">  }</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088">int dt_exif_write_blob(uint8_t *blob, uint32_t size, const char *path, const int compressed)</a>
<a name="ln1089">{</a>
<a name="ln1090">  try</a>
<a name="ln1091">  {</a>
<a name="ln1092">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(path)));</a>
<a name="ln1093">    assert(image.get() != 0);</a>
<a name="ln1094">    read_metadata_threadsafe(image);</a>
<a name="ln1095">    Exiv2::ExifData &amp;imgExifData = image-&gt;exifData();</a>
<a name="ln1096">    Exiv2::ExifData blobExifData;</a>
<a name="ln1097">    Exiv2::ExifParser::decode(blobExifData, blob + 6, size);</a>
<a name="ln1098">    Exiv2::ExifData::const_iterator end = blobExifData.end();</a>
<a name="ln1099">    Exiv2::ExifData::iterator it;</a>
<a name="ln1100">    for(Exiv2::ExifData::const_iterator i = blobExifData.begin(); i != end; ++i)</a>
<a name="ln1101">    {</a>
<a name="ln1102">      // add() does not override! we need to delete existing key first.</a>
<a name="ln1103">      Exiv2::ExifKey key(i-&gt;key());</a>
<a name="ln1104">      if((it = imgExifData.findKey(key)) != imgExifData.end()) imgExifData.erase(it);</a>
<a name="ln1105"> </a>
<a name="ln1106">      imgExifData.add(Exiv2::ExifKey(i-&gt;key()), &amp;i-&gt;value());</a>
<a name="ln1107">    }</a>
<a name="ln1108"> </a>
<a name="ln1109">    {</a>
<a name="ln1110">      // Remove thumbnail</a>
<a name="ln1111">      static const char *keys[] = {</a>
<a name="ln1112">        &quot;Exif.Thumbnail.Compression&quot;,</a>
<a name="ln1113">        &quot;Exif.Thumbnail.XResolution&quot;,</a>
<a name="ln1114">        &quot;Exif.Thumbnail.YResolution&quot;,</a>
<a name="ln1115">        &quot;Exif.Thumbnail.ResolutionUnit&quot;,</a>
<a name="ln1116">        &quot;Exif.Thumbnail.JPEGInterchangeFormat&quot;,</a>
<a name="ln1117">        &quot;Exif.Thumbnail.JPEGInterchangeFormatLength&quot;</a>
<a name="ln1118">      };</a>
<a name="ln1119">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1120">      dt_remove_exif_keys(imgExifData, keys, n_keys);</a>
<a name="ln1121">    }</a>
<a name="ln1122"> </a>
<a name="ln1123">    // only compressed images may set PixelXDimension and PixelYDimension</a>
<a name="ln1124">    if(!compressed)</a>
<a name="ln1125">    {</a>
<a name="ln1126">      static const char *keys[] = {</a>
<a name="ln1127">        &quot;Exif.Photo.PixelXDimension&quot;,</a>
<a name="ln1128">        &quot;Exif.Photo.PixelYDimension&quot;</a>
<a name="ln1129">      };</a>
<a name="ln1130">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1131">      dt_remove_exif_keys(imgExifData, keys, n_keys);</a>
<a name="ln1132">    }</a>
<a name="ln1133"> </a>
<a name="ln1134">    imgExifData.sortByTag();</a>
<a name="ln1135">    image-&gt;writeMetadata();</a>
<a name="ln1136">  }</a>
<a name="ln1137">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1138">  {</a>
<a name="ln1139">    std::string s(e.what());</a>
<a name="ln1140">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; path &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1141">    return 0;</a>
<a name="ln1142">  }</a>
<a name="ln1143">  return 1;</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146">int dt_exif_read_blob(uint8_t **buf, const char *path, const int imgid, const int sRGB, const int out_width,</a>
<a name="ln1147">                      const int out_height, const int dng_mode)</a>
<a name="ln1148">{</a>
<a name="ln1149">  *buf = NULL;</a>
<a name="ln1150">  try</a>
<a name="ln1151">  {</a>
<a name="ln1152">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(path)));</a>
<a name="ln1153">    assert(image.get() != 0);</a>
<a name="ln1154">    read_metadata_threadsafe(image);</a>
<a name="ln1155">    Exiv2::ExifData &amp;exifData = image-&gt;exifData();</a>
<a name="ln1156"> </a>
<a name="ln1157">    // get rid of thumbnails</a>
<a name="ln1158">    Exiv2::ExifThumb(exifData).erase();</a>
<a name="ln1159"> </a>
<a name="ln1160">    // ufraw-style exif stripping:</a>
<a name="ln1161">    Exiv2::ExifData::iterator pos;</a>
<a name="ln1162">    {</a>
<a name="ln1163">    /* Delete original TIFF data, which is irrelevant*/</a>
<a name="ln1164">      static const char *keys[] = {</a>
<a name="ln1165">        &quot;Exif.Image.ImageWidth&quot;,</a>
<a name="ln1166">        &quot;Exif.Image.ImageLength&quot;,</a>
<a name="ln1167">        &quot;Exif.Image.BitsPerSample&quot;,</a>
<a name="ln1168">        &quot;Exif.Image.Compression&quot;,</a>
<a name="ln1169">        &quot;Exif.Image.PhotometricInterpretation&quot;,</a>
<a name="ln1170">        &quot;Exif.Image.FillOrder&quot;,</a>
<a name="ln1171">        &quot;Exif.Image.SamplesPerPixel&quot;,</a>
<a name="ln1172">        &quot;Exif.Image.StripOffsets&quot;,</a>
<a name="ln1173">        &quot;Exif.Image.RowsPerStrip&quot;,</a>
<a name="ln1174">        &quot;Exif.Image.StripByteCounts&quot;,</a>
<a name="ln1175">        &quot;Exif.Image.PlanarConfiguration&quot;,</a>
<a name="ln1176">        &quot;Exif.Image.DNGVersion&quot;,</a>
<a name="ln1177">        &quot;Exif.Image.DNGBackwardVersion&quot;</a>
<a name="ln1178">      };</a>
<a name="ln1179">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1180">      dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1181">    }</a>
<a name="ln1182"> </a>
<a name="ln1183">    if(!dng_mode)</a>
<a name="ln1184">    {</a>
<a name="ln1185">      /* Delete various MakerNote fields only applicable to the raw file */</a>
<a name="ln1186"> </a>
<a name="ln1187">      exifData[&quot;Exif.Image.Orientation&quot;] = uint16_t(1);</a>
<a name="ln1188"> </a>
<a name="ln1189">      {</a>
<a name="ln1190">        static const char *keys[] = {</a>
<a name="ln1191">          // Embedded color profile info</a>
<a name="ln1192">          &quot;Exif.Image.BaselineExposureOffset&quot;,</a>
<a name="ln1193">          &quot;Exif.Image.CalibrationIlluminant1&quot;,</a>
<a name="ln1194">          &quot;Exif.Image.CalibrationIlluminant2&quot;,</a>
<a name="ln1195">          &quot;Exif.Image.ColorMatrix1&quot;,</a>
<a name="ln1196">          &quot;Exif.Image.ColorMatrix2&quot;,</a>
<a name="ln1197">          &quot;Exif.Image.DefaultBlackRender&quot;,</a>
<a name="ln1198">          &quot;Exif.Image.ForwardMatrix1&quot;,</a>
<a name="ln1199">          &quot;Exif.Image.ForwardMatrix2&quot;,</a>
<a name="ln1200">          &quot;Exif.Image.ProfileCalibrationSignature&quot;,</a>
<a name="ln1201">          &quot;Exif.Image.ProfileCopyright&quot;,</a>
<a name="ln1202">          &quot;Exif.Image.ProfileEmbedPolicy&quot;,</a>
<a name="ln1203">          &quot;Exif.Image.ProfileHueSatMapData1&quot;,</a>
<a name="ln1204">          &quot;Exif.Image.ProfileHueSatMapData2&quot;,</a>
<a name="ln1205">          &quot;Exif.Image.ProfileHueSatMapDims&quot;,</a>
<a name="ln1206">          &quot;Exif.Image.ProfileHueSatMapEncoding&quot;,</a>
<a name="ln1207">          &quot;Exif.Image.ProfileLookTableData&quot;,</a>
<a name="ln1208">          &quot;Exif.Image.ProfileLookTableDims&quot;,</a>
<a name="ln1209">          &quot;Exif.Image.ProfileLookTableEncoding&quot;,</a>
<a name="ln1210">          &quot;Exif.Image.ProfileName&quot;,</a>
<a name="ln1211">          &quot;Exif.Image.ProfileToneCurve&quot;,</a>
<a name="ln1212">          &quot;Exif.Image.ReductionMatrix1&quot;,</a>
<a name="ln1213">          &quot;Exif.Image.ReductionMatrix2&quot;,</a>
<a name="ln1214"> </a>
<a name="ln1215">          // Canon color space info</a>
<a name="ln1216">          &quot;Exif.Canon.ColorSpace&quot;,</a>
<a name="ln1217">          &quot;Exif.Canon.ColorData&quot;,</a>
<a name="ln1218"> </a>
<a name="ln1219">          // Nikon thumbnail data</a>
<a name="ln1220">          &quot;Exif.Nikon3.Preview&quot;,</a>
<a name="ln1221">          &quot;Exif.NikonPreview.JPEGInterchangeFormat&quot;,</a>
<a name="ln1222"> </a>
<a name="ln1223">          // DNG private data</a>
<a name="ln1224">          &quot;Exif.Image.DNGPrivateData&quot;,</a>
<a name="ln1225"> </a>
<a name="ln1226">          // Pentax thumbnail data</a>
<a name="ln1227">          &quot;Exif.Pentax.PreviewResolution&quot;,</a>
<a name="ln1228">          &quot;Exif.Pentax.PreviewLength&quot;,</a>
<a name="ln1229">          &quot;Exif.Pentax.PreviewOffset&quot;,</a>
<a name="ln1230">          &quot;Exif.PentaxDng.PreviewResolution&quot;,</a>
<a name="ln1231">          &quot;Exif.PentaxDng.PreviewLength&quot;,</a>
<a name="ln1232">          &quot;Exif.PentaxDng.PreviewOffset&quot;,</a>
<a name="ln1233">          // Pentax color info</a>
<a name="ln1234">          &quot;Exif.PentaxDng.ColorInfo&quot;,</a>
<a name="ln1235"> </a>
<a name="ln1236">          // Minolta thumbnail data</a>
<a name="ln1237">          &quot;Exif.Minolta.Thumbnail&quot;,</a>
<a name="ln1238">          &quot;Exif.Minolta.ThumbnailOffset&quot;,</a>
<a name="ln1239">          &quot;Exif.Minolta.ThumbnailLength&quot;,</a>
<a name="ln1240"> </a>
<a name="ln1241">          // Sony thumbnail data</a>
<a name="ln1242">          &quot;Exif.SonyMinolta.ThumbnailOffset&quot;,</a>
<a name="ln1243">          &quot;Exif.SonyMinolta.ThumbnailLength&quot;,</a>
<a name="ln1244"> </a>
<a name="ln1245">          // Olympus thumbnail data</a>
<a name="ln1246">          &quot;Exif.Olympus.Thumbnail&quot;,</a>
<a name="ln1247">          &quot;Exif.Olympus.ThumbnailOffset&quot;,</a>
<a name="ln1248">          &quot;Exif.Olympus.ThumbnailLength&quot;</a>
<a name="ln1249">        };</a>
<a name="ln1250">        static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1251">        dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1252">      }</a>
<a name="ln1253"> </a>
<a name="ln1254">      // remove subimage* trees, related to thumbnails or HDR usually</a>
<a name="ln1255">      for(Exiv2::ExifData::iterator i = exifData.begin(); i != exifData.end();)</a>
<a name="ln1256">      {</a>
<a name="ln1257">        static const std::string needle = &quot;Exif.SubImage&quot;;</a>
<a name="ln1258">        if(i-&gt;key().compare(0, needle.length(), needle) == 0)</a>
<a name="ln1259">          i = exifData.erase(i);</a>
<a name="ln1260">        else</a>
<a name="ln1261">          ++i;</a>
<a name="ln1262">      }</a>
<a name="ln1263"> </a>
<a name="ln1264">#if EXIV2_MINOR_VERSION &gt;= 23</a>
<a name="ln1265">      {</a>
<a name="ln1266">        // Exiv2 versions older than 0.23 drop all EXIF if the code below is executed</a>
<a name="ln1267">        // Samsung makernote cleanup, the entries below have no relevance for exported images</a>
<a name="ln1268">        static const char *keys[] = {</a>
<a name="ln1269">          &quot;Exif.Samsung2.SensorAreas&quot;,</a>
<a name="ln1270">          &quot;Exif.Samsung2.ColorSpace&quot;,</a>
<a name="ln1271">          &quot;Exif.Samsung2.EncryptionKey&quot;,</a>
<a name="ln1272">          &quot;Exif.Samsung2.WB_RGGBLevelsUncorrected&quot;,</a>
<a name="ln1273">          &quot;Exif.Samsung2.WB_RGGBLevelsAuto&quot;,</a>
<a name="ln1274">          &quot;Exif.Samsung2.WB_RGGBLevelsIlluminator1&quot;,</a>
<a name="ln1275">          &quot;Exif.Samsung2.WB_RGGBLevelsIlluminator2&quot;,</a>
<a name="ln1276">          &quot;Exif.Samsung2.WB_RGGBLevelsBlack&quot;,</a>
<a name="ln1277">          &quot;Exif.Samsung2.ColorMatrix&quot;,</a>
<a name="ln1278">          &quot;Exif.Samsung2.ColorMatrixSRGB&quot;,</a>
<a name="ln1279">          &quot;Exif.Samsung2.ColorMatrixAdobeRGB&quot;,</a>
<a name="ln1280">          &quot;Exif.Samsung2.ToneCurve1&quot;,</a>
<a name="ln1281">          &quot;Exif.Samsung2.ToneCurve2&quot;,</a>
<a name="ln1282">          &quot;Exif.Samsung2.ToneCurve3&quot;,</a>
<a name="ln1283">          &quot;Exif.Samsung2.ToneCurve4&quot;</a>
<a name="ln1284">        };</a>
<a name="ln1285">        static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1286">        dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1287">      }</a>
<a name="ln1288">#endif</a>
<a name="ln1289"> </a>
<a name="ln1290">      /* Write appropriate color space tag if using sRGB output */</a>
<a name="ln1291">      if(sRGB)</a>
<a name="ln1292">        exifData[&quot;Exif.Photo.ColorSpace&quot;] = uint16_t(1); /* sRGB */</a>
<a name="ln1293">      else</a>
<a name="ln1294">        exifData[&quot;Exif.Photo.ColorSpace&quot;] = uint16_t(0xFFFF); /* Uncalibrated */</a>
<a name="ln1295">    }</a>
<a name="ln1296"> </a>
<a name="ln1297">    /* Replace RAW dimension with output dimensions (for example after crop/scale, or orientation for dng</a>
<a name="ln1298">     * mode) */</a>
<a name="ln1299">    if(out_width &gt; 0) exifData[&quot;Exif.Photo.PixelXDimension&quot;] = (uint32_t)out_width;</a>
<a name="ln1300">    if(out_height &gt; 0) exifData[&quot;Exif.Photo.PixelYDimension&quot;] = (uint32_t)out_height;</a>
<a name="ln1301"> </a>
<a name="ln1302">    int resolution = dt_conf_get_int(&quot;metadata/resolution&quot;);</a>
<a name="ln1303">    if(resolution &gt; 0)</a>
<a name="ln1304">    {</a>
<a name="ln1305">      exifData[&quot;Exif.Image.XResolution&quot;] = Exiv2::Rational(resolution, 1);</a>
<a name="ln1306">      exifData[&quot;Exif.Image.YResolution&quot;] = Exiv2::Rational(resolution, 1);</a>
<a name="ln1307">      exifData[&quot;Exif.Image.ResolutionUnit&quot;] = uint16_t(2); /* inches */</a>
<a name="ln1308">    }</a>
<a name="ln1309">    else</a>
<a name="ln1310">    {</a>
<a name="ln1311">      static const char *keys[] = {</a>
<a name="ln1312">        &quot;Exif.Image.XResolution&quot;,</a>
<a name="ln1313">        &quot;Exif.Image.YResolution&quot;,</a>
<a name="ln1314">        &quot;Exif.Image.ResolutionUnit&quot;</a>
<a name="ln1315">      };</a>
<a name="ln1316">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1317">      dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1318">    }</a>
<a name="ln1319"> </a>
<a name="ln1320">    exifData[&quot;Exif.Image.Software&quot;] = darktable_package_string;</a>
<a name="ln1321"> </a>
<a name="ln1322">    // TODO: find a nice place for the missing metadata (tags, publisher, colorlabels?). Additionally find out</a>
<a name="ln1323">    // how to embed XMP data.</a>
<a name="ln1324">    //       And shall we add a description of the history stack to Exif.Image.ImageHistory?</a>
<a name="ln1325">    if(imgid &gt;= 0)</a>
<a name="ln1326">    {</a>
<a name="ln1327">      /* Delete metadata taken from the original file if it's fileds we manage in dt, too */</a>
<a name="ln1328">      static const char * keys[] = {</a>
<a name="ln1329">        &quot;Exif.Image.Artist&quot;,</a>
<a name="ln1330">        &quot;Exif.Image.ImageDescription&quot;,</a>
<a name="ln1331">        &quot;Exif.Photo.UserComment&quot;,</a>
<a name="ln1332">        &quot;Exif.Image.Copyright&quot;,</a>
<a name="ln1333">        &quot;Exif.Image.Rating&quot;,</a>
<a name="ln1334">        &quot;Exif.Image.RatingPercent&quot;,</a>
<a name="ln1335">        &quot;Exif.GPSInfo.GPSVersionID&quot;,</a>
<a name="ln1336">        &quot;Exif.GPSInfo.GPSLongitudeRef&quot;,</a>
<a name="ln1337">        &quot;Exif.GPSInfo.GPSLatitudeRef&quot;,</a>
<a name="ln1338">        &quot;Exif.GPSInfo.GPSLongitude&quot;,</a>
<a name="ln1339">        &quot;Exif.GPSInfo.GPSLatitude&quot;,</a>
<a name="ln1340">        &quot;Exif.GPSInfo.GPSAltitudeRef&quot;,</a>
<a name="ln1341">        &quot;Exif.GPSInfo.GPSAltitude&quot;</a>
<a name="ln1342">      };</a>
<a name="ln1343">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1344">      dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1345"> </a>
<a name="ln1346">      GList *res = dt_metadata_get(imgid, &quot;Xmp.dc.creator&quot;, NULL);</a>
<a name="ln1347">      if(res != NULL)</a>
<a name="ln1348">      {</a>
<a name="ln1349">        exifData[&quot;Exif.Image.Artist&quot;] = (char *)res-&gt;data;</a>
<a name="ln1350">        g_list_free_full(res, &amp;g_free);</a>
<a name="ln1351">      }</a>
<a name="ln1352"> </a>
<a name="ln1353">      res = dt_metadata_get(imgid, &quot;Xmp.dc.description&quot;, NULL);</a>
<a name="ln1354">      if(res != NULL)</a>
<a name="ln1355">      {</a>
<a name="ln1356">        char *desc = (char *)res-&gt;data;</a>
<a name="ln1357">        if(g_str_is_ascii(desc))</a>
<a name="ln1358">          exifData[&quot;Exif.Image.ImageDescription&quot;] = desc;</a>
<a name="ln1359">        else</a>
<a name="ln1360">          exifData[&quot;Exif.Photo.UserComment&quot;] = desc;</a>
<a name="ln1361">        g_list_free_full(res, &amp;g_free);</a>
<a name="ln1362">      }</a>
<a name="ln1363"> </a>
<a name="ln1364">      res = dt_metadata_get(imgid, &quot;Xmp.dc.rights&quot;, NULL);</a>
<a name="ln1365">      if(res != NULL)</a>
<a name="ln1366">      {</a>
<a name="ln1367">        exifData[&quot;Exif.Image.Copyright&quot;] = (char *)res-&gt;data;</a>
<a name="ln1368">        g_list_free_full(res, &amp;g_free);</a>
<a name="ln1369">      }</a>
<a name="ln1370"> </a>
<a name="ln1371">      res = dt_metadata_get(imgid, &quot;Xmp.xmp.Rating&quot;, NULL);</a>
<a name="ln1372">      if(res != NULL)</a>
<a name="ln1373">      {</a>
<a name="ln1374">        int rating = GPOINTER_TO_INT(res-&gt;data) + 1;</a>
<a name="ln1375">        exifData[&quot;Exif.Image.Rating&quot;] = rating;</a>
<a name="ln1376">        exifData[&quot;Exif.Image.RatingPercent&quot;] = int(rating / 5. * 100.);</a>
<a name="ln1377">        g_list_free(res);</a>
<a name="ln1378">      }</a>
<a name="ln1379"> </a>
<a name="ln1380">      // GPS data</a>
<a name="ln1381">      const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1382">      if(!std::isnan(cimg-&gt;longitude) &amp;&amp; !std::isnan(cimg-&gt;latitude))</a>
<a name="ln1383">      {</a>
<a name="ln1384">        exifData[&quot;Exif.GPSInfo.GPSVersionID&quot;] = &quot;02 02 00 00&quot;;</a>
<a name="ln1385">        exifData[&quot;Exif.GPSInfo.GPSLongitudeRef&quot;] = (cimg-&gt;longitude &lt; 0) ? &quot;W&quot; : &quot;E&quot;;</a>
<a name="ln1386">        exifData[&quot;Exif.GPSInfo.GPSLatitudeRef&quot;] = (cimg-&gt;latitude &lt; 0) ? &quot;S&quot; : &quot;N&quot;;</a>
<a name="ln1387"> </a>
<a name="ln1388">        long long_deg = (int)floor(fabs(cimg-&gt;longitude));</a>
<a name="ln1389">        long lat_deg = (int)floor(fabs(cimg-&gt;latitude));</a>
<a name="ln1390">        long long_min = (int)floor((fabs(cimg-&gt;longitude) - floor(fabs(cimg-&gt;longitude))) * 60000000);</a>
<a name="ln1391">        long lat_min = (int)floor((fabs(cimg-&gt;latitude) - floor(fabs(cimg-&gt;latitude))) * 60000000);</a>
<a name="ln1392">        gchar *long_str = g_strdup_printf(&quot;%ld/1 %ld/1000000 0/1&quot;, long_deg, long_min);</a>
<a name="ln1393">        gchar *lat_str = g_strdup_printf(&quot;%ld/1 %ld/1000000 0/1&quot;, lat_deg, lat_min);</a>
<a name="ln1394">        exifData[&quot;Exif.GPSInfo.GPSLongitude&quot;] = long_str;</a>
<a name="ln1395">        exifData[&quot;Exif.GPSInfo.GPSLatitude&quot;] = lat_str;</a>
<a name="ln1396">        g_free(long_str);</a>
<a name="ln1397">        g_free(lat_str);</a>
<a name="ln1398">      }</a>
<a name="ln1399">      if(!std::isnan(cimg-&gt;elevation))</a>
<a name="ln1400">      {</a>
<a name="ln1401">        exifData[&quot;Exif.GPSInfo.GPSVersionID&quot;] = &quot;02 02 00 00&quot;;</a>
<a name="ln1402">        exifData[&quot;Exif.GPSInfo.GPSAltitudeRef&quot;] = (cimg-&gt;elevation &lt; 0) ? &quot;1&quot; : &quot;0&quot;;</a>
<a name="ln1403"> </a>
<a name="ln1404">        long ele_dm = (int)floor(fabs(10.0 * cimg-&gt;elevation));</a>
<a name="ln1405">        gchar *ele_str = g_strdup_printf(&quot;%ld/10&quot;, ele_dm);</a>
<a name="ln1406">        exifData[&quot;Exif.GPSInfo.GPSAltitude&quot;] = ele_str;</a>
<a name="ln1407">        g_free(ele_str);</a>
<a name="ln1408">      }</a>
<a name="ln1409"> </a>
<a name="ln1410">      // According to the Exif specs DateTime is to be set to the last modification time while</a>
<a name="ln1411">      // DateTimeOriginal is to be kept.</a>
<a name="ln1412">      // For us &quot;keeping&quot; it means to write out what we have in DB to support people adding a time offset in</a>
<a name="ln1413">      // the geotagging module.</a>
<a name="ln1414">      gchar new_datetime[20];</a>
<a name="ln1415">      dt_gettime(new_datetime, sizeof(new_datetime));</a>
<a name="ln1416">      exifData[&quot;Exif.Image.DateTime&quot;] = new_datetime;</a>
<a name="ln1417">      exifData[&quot;Exif.Image.DateTimeOriginal&quot;] = cimg-&gt;exif_datetime_taken;</a>
<a name="ln1418">      exifData[&quot;Exif.Photo.DateTimeOriginal&quot;] = cimg-&gt;exif_datetime_taken;</a>
<a name="ln1419">      // FIXME: What about DateTimeDigitized? we currently update it, too, which might not be what is expected</a>
<a name="ln1420">      // for scanned images</a>
<a name="ln1421">      exifData[&quot;Exif.Photo.DateTimeDigitized&quot;] = cimg-&gt;exif_datetime_taken;</a>
<a name="ln1422"> </a>
<a name="ln1423">      dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1424">    }</a>
<a name="ln1425"> </a>
<a name="ln1426">    Exiv2::Blob blob;</a>
<a name="ln1427">    Exiv2::ExifParser::encode(blob, Exiv2::bigEndian, exifData);</a>
<a name="ln1428">    const int length = blob.size();</a>
<a name="ln1429">    *buf = (uint8_t *)malloc(length+6);</a>
<a name="ln1430">    if (!*buf)</a>
<a name="ln1431">    {</a>
<a name="ln1432">      return 0;</a>
<a name="ln1433">    }</a>
<a name="ln1434">    memcpy(*buf, &quot;Exif\000\000&quot;, 6);</a>
<a name="ln1435">    memcpy(*buf + 6, &amp;(blob[0]), length);</a>
<a name="ln1436">    return length + 6;</a>
<a name="ln1437">  }</a>
<a name="ln1438">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1439">  {</a>
<a name="ln1440">    // std::cerr.rdbuf(savecerr);</a>
<a name="ln1441">    std::string s(e.what());</a>
<a name="ln1442">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; path &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1443">    free(*buf);</a>
<a name="ln1444">    *buf = NULL;</a>
<a name="ln1445">    return 0;</a>
<a name="ln1446">  }</a>
<a name="ln1447">}</a>
<a name="ln1448"> </a>
<a name="ln1449">// encode binary blob into text:</a>
<a name="ln1450">char *dt_exif_xmp_encode(const unsigned char *input, const int len, int *output_len)</a>
<a name="ln1451">{</a>
<a name="ln1452">#define COMPRESS_THRESHOLD 100</a>
<a name="ln1453"> </a>
<a name="ln1454">  gboolean do_compress = FALSE;</a>
<a name="ln1455"> </a>
<a name="ln1456">  // if input data field exceeds a certain size we compress it and convert to base64;</a>
<a name="ln1457">  // main reason for compression: make more xmp data fit into 64k segment within</a>
<a name="ln1458">  // JPEG output files.</a>
<a name="ln1459">  char *config = dt_conf_get_string(&quot;compress_xmp_tags&quot;);</a>
<a name="ln1460">  if(config)</a>
<a name="ln1461">  {</a>
<a name="ln1462">    if(!strcmp(config, &quot;always&quot;))</a>
<a name="ln1463">      do_compress = TRUE;</a>
<a name="ln1464">    else if((len &gt; COMPRESS_THRESHOLD) &amp;&amp; !strcmp(config, &quot;only large entries&quot;))</a>
<a name="ln1465">      do_compress = TRUE;</a>
<a name="ln1466">    else</a>
<a name="ln1467">      do_compress = FALSE;</a>
<a name="ln1468">    g_free(config);</a>
<a name="ln1469">  }</a>
<a name="ln1470"> </a>
<a name="ln1471">  return dt_exif_xmp_encode_internal(input, len, output_len, do_compress);</a>
<a name="ln1472"> </a>
<a name="ln1473">#undef COMPRESS_THRESHOLD</a>
<a name="ln1474">}</a>
<a name="ln1475"> </a>
<a name="ln1476">char *dt_exif_xmp_encode_internal(const unsigned char *input, const int len, int *output_len, gboolean do_compress)</a>
<a name="ln1477">{</a>
<a name="ln1478">  char *output = NULL;</a>
<a name="ln1479"> </a>
<a name="ln1480">  if(do_compress)</a>
<a name="ln1481">  {</a>
<a name="ln1482">    int result;</a>
<a name="ln1483">    uLongf destLen = compressBound(len);</a>
<a name="ln1484">    unsigned char *buffer1 = (unsigned char *)malloc(destLen);</a>
<a name="ln1485"> </a>
<a name="ln1486">    result = compress(buffer1, &amp;destLen, input, len);</a>
<a name="ln1487"> </a>
<a name="ln1488">    if(result != Z_OK)</a>
<a name="ln1489">    {</a>
<a name="ln1490">      free(buffer1);</a>
<a name="ln1491">      return NULL;</a>
<a name="ln1492">    }</a>
<a name="ln1493"> </a>
<a name="ln1494">    // we store the compression factor</a>
<a name="ln1495">    const int factor = MIN(len / destLen + 1, 99);</a>
<a name="ln1496"> </a>
<a name="ln1497">    char *buffer2 = (char *)g_base64_encode(buffer1, destLen);</a>
<a name="ln1498">    free(buffer1);</a>
<a name="ln1499">    if(!buffer2) return NULL;</a>
<a name="ln1500"> </a>
<a name="ln1501">    int outlen = strlen(buffer2) + 5; // leading &quot;gz&quot; + compression factor + base64 string + trailing '\0'</a>
<a name="ln1502">    output = (char *)malloc(outlen);</a>
<a name="ln1503">    if(!output)</a>
<a name="ln1504">    {</a>
<a name="ln1505">      g_free(buffer2);</a>
<a name="ln1506">      return NULL;</a>
<a name="ln1507">    }</a>
<a name="ln1508"> </a>
<a name="ln1509">    output[0] = 'g';</a>
<a name="ln1510">    output[1] = 'z';</a>
<a name="ln1511">    output[2] = factor / 10 + '0';</a>
<a name="ln1512">    output[3] = factor % 10 + '0';</a>
<a name="ln1513">    g_strlcpy(output + 4, buffer2, outlen);</a>
<a name="ln1514">    g_free(buffer2);</a>
<a name="ln1515"> </a>
<a name="ln1516">    if(output_len) *output_len = outlen;</a>
<a name="ln1517">  }</a>
<a name="ln1518">  else</a>
<a name="ln1519">  {</a>
<a name="ln1520">    const char hex[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };</a>
<a name="ln1521"> </a>
<a name="ln1522">    output = (char *)malloc(2 * len + 1);</a>
<a name="ln1523">    if(!output) return NULL;</a>
<a name="ln1524"> </a>
<a name="ln1525">    if(output_len) *output_len = 2 * len + 1;</a>
<a name="ln1526"> </a>
<a name="ln1527">    for(int i = 0; i &lt; len; i++)</a>
<a name="ln1528">    {</a>
<a name="ln1529">      const int hi = input[i] &gt;&gt; 4;</a>
<a name="ln1530">      const int lo = input[i] &amp; 15;</a>
<a name="ln1531">      output[2 * i] = hex[hi];</a>
<a name="ln1532">      output[2 * i + 1] = hex[lo];</a>
<a name="ln1533">    }</a>
<a name="ln1534">    output[2 * len] = '\0';</a>
<a name="ln1535">  }</a>
<a name="ln1536"> </a>
<a name="ln1537">  return output;</a>
<a name="ln1538">}</a>
<a name="ln1539"> </a>
<a name="ln1540">// and back to binary</a>
<a name="ln1541">unsigned char *dt_exif_xmp_decode(const char *input, const int len, int *output_len)</a>
<a name="ln1542">{</a>
<a name="ln1543">  unsigned char *output = NULL;</a>
<a name="ln1544"> </a>
<a name="ln1545">  // check if data is in compressed format</a>
<a name="ln1546">  if(!strncmp(input, &quot;gz&quot;, 2))</a>
<a name="ln1547">  {</a>
<a name="ln1548">    // we have compressed data in base64 representation with leading &quot;gz&quot;</a>
<a name="ln1549"> </a>
<a name="ln1550">    // get stored compression factor so we know the needed buffer size for uncompress</a>
<a name="ln1551">    const float factor = 10 * (input[2] - '0') + (input[3] - '0');</a>
<a name="ln1552"> </a>
<a name="ln1553">    // get a rw copy of input buffer omitting leading &quot;gz&quot; and compression factor</a>
<a name="ln1554">    unsigned char *buffer = (unsigned char *)strdup(input + 4);</a>
<a name="ln1555">    if(!buffer) return NULL;</a>
<a name="ln1556"> </a>
<a name="ln1557">    // decode from base64 to compressed binary</a>
<a name="ln1558">    gsize compressed_size;</a>
<a name="ln1559">    g_base64_decode_inplace((char *)buffer, &amp;compressed_size);</a>
<a name="ln1560"> </a>
<a name="ln1561">    // do the actual uncompress step</a>
<a name="ln1562">    int result = Z_BUF_ERROR;</a>
<a name="ln1563">    uLongf bufLen = factor * compressed_size;</a>
<a name="ln1564">    uLongf destLen;</a>
<a name="ln1565"> </a>
<a name="ln1566">    // we know the actual compression factor but if that fails we re-try with</a>
<a name="ln1567">    // increasing buffer sizes, eg. we don't know (unlikely) factors &gt; 99</a>
<a name="ln1568">    do</a>
<a name="ln1569">    {</a>
<a name="ln1570">      if(output) free(output);</a>
<a name="ln1571">      output = (unsigned char *)malloc(bufLen);</a>
<a name="ln1572">      if(!output) break;</a>
<a name="ln1573"> </a>
<a name="ln1574">      destLen = bufLen;</a>
<a name="ln1575"> </a>
<a name="ln1576">      result = uncompress(output, &amp;destLen, buffer, compressed_size);</a>
<a name="ln1577"> </a>
<a name="ln1578">      bufLen *= 2;</a>
<a name="ln1579"> </a>
<a name="ln1580">    } while(result == Z_BUF_ERROR);</a>
<a name="ln1581"> </a>
<a name="ln1582"> </a>
<a name="ln1583">    free(buffer);</a>
<a name="ln1584"> </a>
<a name="ln1585">    if(result != Z_OK)</a>
<a name="ln1586">    {</a>
<a name="ln1587">      if(output) free(output);</a>
<a name="ln1588">      return NULL;</a>
<a name="ln1589">    }</a>
<a name="ln1590"> </a>
<a name="ln1591">    if(output_len) *output_len = destLen;</a>
<a name="ln1592">  }</a>
<a name="ln1593">  else</a>
<a name="ln1594">  {</a>
<a name="ln1595">// we have uncompressed data in hexadecimal ascii representation</a>
<a name="ln1596"> </a>
<a name="ln1597">// ascii table:</a>
<a name="ln1598">// 48- 57 0-9</a>
<a name="ln1599">// 97-102 a-f</a>
<a name="ln1600">#define TO_BINARY(a) (a &gt; 57 ? a - 97 + 10 : a - 48)</a>
<a name="ln1601"> </a>
<a name="ln1602">    // make sure that we don't find any unexpected characters indicating corrupted data</a>
<a name="ln1603">    if(strspn(input, &quot;0123456789abcdef&quot;) != strlen(input)) return NULL;</a>
<a name="ln1604"> </a>
<a name="ln1605">    output = (unsigned char *)malloc(len / 2);</a>
<a name="ln1606">    if(!output) return NULL;</a>
<a name="ln1607"> </a>
<a name="ln1608">    if(output_len) *output_len = len / 2;</a>
<a name="ln1609"> </a>
<a name="ln1610">    for(int i = 0; i &lt; len / 2; i++)</a>
<a name="ln1611">    {</a>
<a name="ln1612">      const int hi = TO_BINARY(input[2 * i]);</a>
<a name="ln1613">      const int lo = TO_BINARY(input[2 * i + 1]);</a>
<a name="ln1614">      output[i] = (hi &lt;&lt; 4) | lo;</a>
<a name="ln1615">    }</a>
<a name="ln1616">#undef TO_BINARY</a>
<a name="ln1617">  }</a>
<a name="ln1618"> </a>
<a name="ln1619">  return output;</a>
<a name="ln1620">}</a>
<a name="ln1621"> </a>
<a name="ln1622">static void _exif_import_tags(dt_image_t *img, Exiv2::XmpData::iterator &amp;pos)</a>
<a name="ln1623">{</a>
<a name="ln1624">  // tags in array</a>
<a name="ln1625">  const int cnt = pos-&gt;count();</a>
<a name="ln1626"> </a>
<a name="ln1627">  sqlite3_stmt *stmt_sel_id, *stmt_ins_tags, *stmt_ins_tagged;</a>
<a name="ln1628">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT id FROM data.tags WHERE name = ?1&quot;, -1,</a>
<a name="ln1629">                              &amp;stmt_sel_id, NULL);</a>
<a name="ln1630">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;INSERT INTO data.tags (id, name) VALUES (NULL, ?1)&quot;,</a>
<a name="ln1631">                              -1, &amp;stmt_ins_tags, NULL);</a>
<a name="ln1632">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1633">                              &quot;INSERT INTO main.tagged_images (tagid, imgid) VALUES (?1, ?2)&quot;, -1,</a>
<a name="ln1634">                              &amp;stmt_ins_tagged, NULL);</a>
<a name="ln1635">  for(int i = 0; i &lt; cnt; i++)</a>
<a name="ln1636">  {</a>
<a name="ln1637">    char tagbuf[1024];</a>
<a name="ln1638">    std::string pos_str = pos-&gt;toString(i);</a>
<a name="ln1639">    g_strlcpy(tagbuf, pos_str.c_str(), sizeof(tagbuf));</a>
<a name="ln1640">    int tagid = -1;</a>
<a name="ln1641">    char *tag = tagbuf;</a>
<a name="ln1642">    while(tag)</a>
<a name="ln1643">    {</a>
<a name="ln1644">      char *next_tag = strstr(tag, &quot;,&quot;);</a>
<a name="ln1645">      if(next_tag) *(next_tag++) = 0;</a>
<a name="ln1646">      // check if tag is available, get its id:</a>
<a name="ln1647">      for(int k = 0; k &lt; 2; k++)</a>
<a name="ln1648">      {</a>
<a name="ln1649">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt_sel_id, 1, tag, -1, SQLITE_TRANSIENT);</a>
<a name="ln1650">        if(sqlite3_step(stmt_sel_id) == SQLITE_ROW) tagid = sqlite3_column_int(stmt_sel_id, 0);</a>
<a name="ln1651">        sqlite3_reset(stmt_sel_id);</a>
<a name="ln1652">        sqlite3_clear_bindings(stmt_sel_id);</a>
<a name="ln1653"> </a>
<a name="ln1654">        if(tagid &gt; 0) break;</a>
<a name="ln1655"> </a>
<a name="ln1656">        fprintf(stderr, &quot;[xmp_import] creating tag: %s\n&quot;, tag);</a>
<a name="ln1657">        // create this tag (increment id, leave icon empty), retry.</a>
<a name="ln1658">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt_ins_tags, 1, tag, -1, SQLITE_TRANSIENT);</a>
<a name="ln1659">        sqlite3_step(stmt_ins_tags);</a>
<a name="ln1660">        sqlite3_reset(stmt_ins_tags);</a>
<a name="ln1661">        sqlite3_clear_bindings(stmt_ins_tags);</a>
<a name="ln1662">      }</a>
<a name="ln1663">      // associate image and tag.</a>
<a name="ln1664">      DT_DEBUG_SQLITE3_BIND_INT(stmt_ins_tagged, 1, tagid);</a>
<a name="ln1665">      DT_DEBUG_SQLITE3_BIND_INT(stmt_ins_tagged, 2, img-&gt;id);</a>
<a name="ln1666">      sqlite3_step(stmt_ins_tagged);</a>
<a name="ln1667">      sqlite3_reset(stmt_ins_tagged);</a>
<a name="ln1668">      sqlite3_clear_bindings(stmt_ins_tagged);</a>
<a name="ln1669"> </a>
<a name="ln1670">      tag = next_tag;</a>
<a name="ln1671">    }</a>
<a name="ln1672">  }</a>
<a name="ln1673">  sqlite3_finalize(stmt_sel_id);</a>
<a name="ln1674">  sqlite3_finalize(stmt_ins_tags);</a>
<a name="ln1675">  sqlite3_finalize(stmt_ins_tagged);</a>
<a name="ln1676"> </a>
<a name="ln1677">  // update used_tags</a>
<a name="ln1678">  dt_tag_update_used_tags();</a>
<a name="ln1679">}</a>
<a name="ln1680"> </a>
<a name="ln1681">typedef struct history_entry_t</a>
<a name="ln1682">{</a>
<a name="ln1683">  char *operation;</a>
<a name="ln1684">  gboolean enabled;</a>
<a name="ln1685">  int modversion;</a>
<a name="ln1686">  unsigned char *params;</a>
<a name="ln1687">  int params_len;</a>
<a name="ln1688">  char *multi_name;</a>
<a name="ln1689">  int multi_priority;</a>
<a name="ln1690">  int blendop_version;</a>
<a name="ln1691">  unsigned char *blendop_params;</a>
<a name="ln1692">  int blendop_params_len;</a>
<a name="ln1693"> </a>
<a name="ln1694">  // sanity checking</a>
<a name="ln1695">  gboolean have_operation, have_params, have_modversion;</a>
<a name="ln1696">} history_entry_t;</a>
<a name="ln1697"> </a>
<a name="ln1698">// used for a hash table that maps mask_id to the mask data</a>
<a name="ln1699">typedef struct mask_entry_t</a>
<a name="ln1700">{</a>
<a name="ln1701">  int mask_id;</a>
<a name="ln1702">  int mask_type;</a>
<a name="ln1703">  char *mask_name;</a>
<a name="ln1704">  int mask_version;</a>
<a name="ln1705">  unsigned char *mask;</a>
<a name="ln1706">  int mask_len;</a>
<a name="ln1707">  int mask_nb;</a>
<a name="ln1708">  unsigned char *mask_src;</a>
<a name="ln1709">  int mask_src_len;</a>
<a name="ln1710">  gboolean already_added;</a>
<a name="ln1711">} mask_entry_t;</a>
<a name="ln1712"> </a>
<a name="ln1713">static void print_history_entry(history_entry_t *entry) __attribute__((unused));</a>
<a name="ln1714">static void print_history_entry(history_entry_t *entry)</a>
<a name="ln1715">{</a>
<a name="ln1716">  if(!entry || !entry-&gt;operation)</a>
<a name="ln1717">  {</a>
<a name="ln1718">    std::cout &lt;&lt; &quot;malformed entry&quot; &lt;&lt; std::endl;</a>
<a name="ln1719">    return;</a>
<a name="ln1720">  }</a>
<a name="ln1721"> </a>
<a name="ln1722">  std::cout &lt;&lt; entry-&gt;operation &lt;&lt; std::endl;</a>
<a name="ln1723">  std::cout &lt;&lt; &quot;  modversion      :&quot; &lt;&lt;  entry-&gt;modversion                                    &lt;&lt; std::endl;</a>
<a name="ln1724">  std::cout &lt;&lt; &quot;  enabled         :&quot; &lt;&lt;  entry-&gt;enabled                                       &lt;&lt; std::endl;</a>
<a name="ln1725">  std::cout &lt;&lt; &quot;  params          :&quot; &lt;&lt; (entry-&gt;params ? &quot;&lt;found&gt;&quot; : &quot;&lt;missing&gt;&quot;)             &lt;&lt; std::endl;</a>
<a name="ln1726">  std::cout &lt;&lt; &quot;  multi_name      :&quot; &lt;&lt; (entry-&gt;multi_name ? entry-&gt;multi_name : &quot;&lt;missing&gt;&quot;) &lt;&lt; std::endl;</a>
<a name="ln1727">  std::cout &lt;&lt; &quot;  multi_priority  :&quot; &lt;&lt;  entry-&gt;multi_priority                                &lt;&lt; std::endl;</a>
<a name="ln1728">  std::cout &lt;&lt; &quot;  blendop_version :&quot; &lt;&lt;  entry-&gt;blendop_version                               &lt;&lt; std::endl;</a>
<a name="ln1729">  std::cout &lt;&lt; &quot;  blendop_params  :&quot; &lt;&lt; (entry-&gt;blendop_params ? &quot;&lt;found&gt;&quot; : &quot;&lt;missing&gt;&quot;)     &lt;&lt; std::endl;</a>
<a name="ln1730">  std::cout &lt;&lt; std::endl;</a>
<a name="ln1731">}</a>
<a name="ln1732"> </a>
<a name="ln1733">static void free_history_entry(gpointer data)</a>
<a name="ln1734">{</a>
<a name="ln1735">  history_entry_t *entry = (history_entry_t *)data;</a>
<a name="ln1736">  g_free(entry-&gt;operation);</a>
<a name="ln1737">  g_free(entry-&gt;multi_name);</a>
<a name="ln1738">  free(entry-&gt;params);</a>
<a name="ln1739">  free(entry-&gt;blendop_params);</a>
<a name="ln1740">  free(entry);</a>
<a name="ln1741">}</a>
<a name="ln1742"> </a>
<a name="ln1743">// we have to use pugixml as the old format could contain empty rdf:li elements in the multi_name array</a>
<a name="ln1744">// which causes problems when accessing it with libexiv2 :(</a>
<a name="ln1745">// superold is a flag indicating that data is wrapped in &lt;rdf:Bag&gt; instead of &lt;rdf:Seq&gt;.</a>
<a name="ln1746">static GList *read_history_v1(const std::string &amp;xmpPacket, const char *filename, const int superold)</a>
<a name="ln1747">{</a>
<a name="ln1748">  GList *history_entries = NULL;</a>
<a name="ln1749"> </a>
<a name="ln1750">  pugi::xml_document doc;</a>
<a name="ln1751">#if defined(PUGIXML_VERSION) &amp;&amp; PUGIXML_VERSION &gt;= 150</a>
<a name="ln1752">  pugi::xml_parse_result result = doc.load_string(xmpPacket.c_str());</a>
<a name="ln1753">#else</a>
<a name="ln1754">  pugi::xml_parse_result result = doc.load(xmpPacket.c_str());</a>
<a name="ln1755">#endif</a>
<a name="ln1756"> </a>
<a name="ln1757">  if(!result)</a>
<a name="ln1758">  {</a>
<a name="ln1759">    std::cerr &lt;&lt; &quot;XML '&quot; &lt;&lt; filename &lt;&lt; &quot;' parsed with errors&quot; &lt;&lt; std::endl;</a>
<a name="ln1760">    std::cerr &lt;&lt; &quot;Error description: &quot; &lt;&lt; result.description() &lt;&lt; std::endl;</a>
<a name="ln1761">    std::cerr &lt;&lt; &quot;Error offset: &quot; &lt;&lt; result.offset &lt;&lt; std::endl;</a>
<a name="ln1762">    return NULL;</a>
<a name="ln1763">  }</a>
<a name="ln1764"> </a>
<a name="ln1765">  // get the old elements</a>
<a name="ln1766">  // select_single_node() is deprecated and just kept for old versions shipped in some distributions</a>
<a name="ln1767">#if defined(PUGIXML_VERSION) &amp;&amp; PUGIXML_VERSION &gt;= 150</a>
<a name="ln1768">  pugi::xpath_node modversion      = superold ?</a>
<a name="ln1769">    doc.select_node(&quot;//darktable:history_modversion/rdf:Bag&quot;):</a>
<a name="ln1770">    doc.select_node(&quot;//darktable:history_modversion/rdf:Seq&quot;);</a>
<a name="ln1771">  pugi::xpath_node enabled         = superold ?</a>
<a name="ln1772">    doc.select_node(&quot;//darktable:history_enabled/rdf:Bag&quot;):</a>
<a name="ln1773">    doc.select_node(&quot;//darktable:history_enabled/rdf:Seq&quot;);</a>
<a name="ln1774">  pugi::xpath_node operation       = superold ?</a>
<a name="ln1775">    doc.select_node(&quot;//darktable:history_operation/rdf:Bag&quot;):</a>
<a name="ln1776">    doc.select_node(&quot;//darktable:history_operation/rdf:Seq&quot;);</a>
<a name="ln1777">  pugi::xpath_node params          = superold ?</a>
<a name="ln1778">    doc.select_node(&quot;//darktable:history_params/rdf:Bag&quot;):</a>
<a name="ln1779">    doc.select_node(&quot;//darktable:history_params/rdf:Seq&quot;);</a>
<a name="ln1780">  pugi::xpath_node blendop_params  = superold ?</a>
<a name="ln1781">    doc.select_node(&quot;//darktable:blendop_params/rdf:Bag&quot;):</a>
<a name="ln1782">    doc.select_node(&quot;//darktable:blendop_params/rdf:Seq&quot;);</a>
<a name="ln1783">  pugi::xpath_node blendop_version = superold ?</a>
<a name="ln1784">    doc.select_node(&quot;//darktable:blendop_version/rdf:Bag&quot;):</a>
<a name="ln1785">    doc.select_node(&quot;//darktable:blendop_version/rdf:Seq&quot;);</a>
<a name="ln1786">  pugi::xpath_node multi_priority  = superold ?</a>
<a name="ln1787">    doc.select_node(&quot;//darktable:multi_priority/rdf:Bag&quot;):</a>
<a name="ln1788">    doc.select_node(&quot;//darktable:multi_priority/rdf:Seq&quot;);</a>
<a name="ln1789">  pugi::xpath_node multi_name      = superold ?</a>
<a name="ln1790">    doc.select_node(&quot;//darktable:multi_name/rdf:Bag&quot;):</a>
<a name="ln1791">    doc.select_node(&quot;//darktable:multi_name/rdf:Bag&quot;);</a>
<a name="ln1792">#else</a>
<a name="ln1793">  pugi::xpath_node modversion      = superold ?</a>
<a name="ln1794">    doc.select_single_node(&quot;//darktable:history_modversion/rdf:Bag&quot;):</a>
<a name="ln1795">    doc.select_single_node(&quot;//darktable:history_modversion/rdf:Seq&quot;);</a>
<a name="ln1796">  pugi::xpath_node enabled         = superold ?</a>
<a name="ln1797">    doc.select_single_node(&quot;//darktable:history_enabled/rdf:Bag&quot;):</a>
<a name="ln1798">    doc.select_single_node(&quot;//darktable:history_enabled/rdf:Seq&quot;);</a>
<a name="ln1799">  pugi::xpath_node operation       = superold ?</a>
<a name="ln1800">    doc.select_single_node(&quot;//darktable:history_operation/rdf:Bag&quot;):</a>
<a name="ln1801">    doc.select_single_node(&quot;//darktable:history_operation/rdf:Seq&quot;);</a>
<a name="ln1802">  pugi::xpath_node params          = superold ?</a>
<a name="ln1803">    doc.select_single_node(&quot;//darktable:history_params/rdf:Bag&quot;):</a>
<a name="ln1804">    doc.select_single_node(&quot;//darktable:history_params/rdf:Seq&quot;);</a>
<a name="ln1805">  pugi::xpath_node blendop_params  = superold ?</a>
<a name="ln1806">    doc.select_single_node(&quot;//darktable:blendop_params/rdf:Bag&quot;):</a>
<a name="ln1807">    doc.select_single_node(&quot;//darktable:blendop_params/rdf:Seq&quot;);</a>
<a name="ln1808">  pugi::xpath_node blendop_version = superold ?</a>
<a name="ln1809">    doc.select_single_node(&quot;//darktable:blendop_version/rdf:Bag&quot;):</a>
<a name="ln1810">    doc.select_single_node(&quot;//darktable:blendop_version/rdf:Seq&quot;);</a>
<a name="ln1811">  pugi::xpath_node multi_priority  = superold ?</a>
<a name="ln1812">    doc.select_single_node(&quot;//darktable:multi_priority/rdf:Bag&quot;):</a>
<a name="ln1813">    doc.select_single_node(&quot;//darktable:multi_priority/rdf:Seq&quot;);</a>
<a name="ln1814">  pugi::xpath_node multi_name      = superold ?</a>
<a name="ln1815">    doc.select_single_node(&quot;//darktable:multi_name/rdf:Bag&quot;):</a>
<a name="ln1816">    doc.select_single_node(&quot;//darktable:multi_name/rdf:Bag&quot;);</a>
<a name="ln1817">#endif</a>
<a name="ln1818"> </a>
<a name="ln1819">  // fill the list of history entries. we are iterating over history_operation as we know that it's there.</a>
<a name="ln1820">  // the other iters are taken care of manually.</a>
<a name="ln1821">  auto modversion_iter = modversion.node().children().begin();</a>
<a name="ln1822">  auto enabled_iter = enabled.node().children().begin();</a>
<a name="ln1823">  auto params_iter = params.node().children().begin();</a>
<a name="ln1824">  auto blendop_params_iter = blendop_params.node().children().begin();</a>
<a name="ln1825">  auto blendop_version_iter = blendop_version.node().children().begin();</a>
<a name="ln1826">  auto multi_priority_iter = multi_priority.node().children().begin();</a>
<a name="ln1827">  auto multi_name_iter = multi_name.node().children().begin();</a>
<a name="ln1828"> </a>
<a name="ln1829">  for(pugi::xml_node operation_iter: operation.node().children())</a>
<a name="ln1830">  {</a>
<a name="ln1831">    history_entry_t *current_entry = (history_entry_t *)calloc(1, sizeof(history_entry_t));</a>
<a name="ln1832">    current_entry-&gt;blendop_version = 1; // default version in case it's not specified</a>
<a name="ln1833">    history_entries = g_list_append(history_entries, current_entry);</a>
<a name="ln1834"> </a>
<a name="ln1835">    current_entry-&gt;operation = g_strdup(operation_iter.child_value());</a>
<a name="ln1836"> </a>
<a name="ln1837">    current_entry-&gt;enabled = g_strcmp0(enabled_iter-&gt;child_value(), &quot;0&quot;) != 0;</a>
<a name="ln1838"> </a>
<a name="ln1839">    current_entry-&gt;modversion = atoi(modversion_iter-&gt;child_value());</a>
<a name="ln1840"> </a>
<a name="ln1841">    current_entry-&gt;params = dt_exif_xmp_decode(params_iter-&gt;child_value(), strlen(params_iter-&gt;child_value()),</a>
<a name="ln1842">                                               &amp;current_entry-&gt;params_len);</a>
<a name="ln1843"> </a>
<a name="ln1844">    if(multi_name &amp;&amp; multi_name_iter != multi_name.node().children().end())</a>
<a name="ln1845">    {</a>
<a name="ln1846">      current_entry-&gt;multi_name = g_strdup(multi_name_iter-&gt;child_value());</a>
<a name="ln1847">      multi_name_iter++;</a>
<a name="ln1848">    }</a>
<a name="ln1849"> </a>
<a name="ln1850">    if(multi_priority &amp;&amp; multi_priority_iter != multi_priority.node().children().end())</a>
<a name="ln1851">    {</a>
<a name="ln1852">      current_entry-&gt;multi_priority = atoi(multi_priority_iter-&gt;child_value());</a>
<a name="ln1853">      multi_priority_iter++;</a>
<a name="ln1854">    }</a>
<a name="ln1855"> </a>
<a name="ln1856">    if(blendop_version &amp;&amp; blendop_version_iter != blendop_version.node().children().end())</a>
<a name="ln1857">    {</a>
<a name="ln1858">      current_entry-&gt;blendop_version = atoi(blendop_version_iter-&gt;child_value());</a>
<a name="ln1859">      blendop_version_iter++;</a>
<a name="ln1860">    }</a>
<a name="ln1861"> </a>
<a name="ln1862">    if(blendop_params &amp;&amp; blendop_params_iter != blendop_params.node().children().end())</a>
<a name="ln1863">    {</a>
<a name="ln1864">      current_entry-&gt;blendop_params = dt_exif_xmp_decode(blendop_params_iter-&gt;child_value(),</a>
<a name="ln1865">                                                         strlen(blendop_params_iter-&gt;child_value()),</a>
<a name="ln1866">                                                         &amp;current_entry-&gt;blendop_params_len);</a>
<a name="ln1867">      blendop_params_iter++;</a>
<a name="ln1868">    }</a>
<a name="ln1869"> </a>
<a name="ln1870">    modversion_iter++;</a>
<a name="ln1871">    enabled_iter++;</a>
<a name="ln1872">    params_iter++;</a>
<a name="ln1873">  }</a>
<a name="ln1874"> </a>
<a name="ln1875">  return history_entries;</a>
<a name="ln1876">}</a>
<a name="ln1877"> </a>
<a name="ln1878">static GList *read_history_v2(Exiv2::XmpData &amp;xmpData, const char *filename)</a>
<a name="ln1879">{</a>
<a name="ln1880">  GList *history_entries = NULL;</a>
<a name="ln1881">  history_entry_t *current_entry = NULL;</a>
<a name="ln1882"> </a>
<a name="ln1883">  for(auto history = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.history&quot;)); history != xmpData.end(); history++)</a>
<a name="ln1884">  {</a>
<a name="ln1885">    // TODO: support human readable params via introspection with something like this:</a>
<a name="ln1886">    // XmpText: Xmp.darktable.history[1]/darktable:settings[1]/darktable:name = width</a>
<a name="ln1887">    // XmpText: Xmp.darktable.history[1]/darktable:settings[1]/darktable:value = 23</a>
<a name="ln1888"> </a>
<a name="ln1889">    char *key = g_strdup(history-&gt;key().c_str());</a>
<a name="ln1890">    char *key_iter = key;</a>
<a name="ln1891">    if(g_str_has_prefix(key, &quot;Xmp.darktable.history[&quot;))</a>
<a name="ln1892">    {</a>
<a name="ln1893">      key_iter += strlen(&quot;Xmp.darktable.history[&quot;);</a>
<a name="ln1894">      errno = 0;</a>
<a name="ln1895">      unsigned int n = strtol(key_iter, &amp;key_iter, 10);</a>
<a name="ln1896">      if(errno)</a>
<a name="ln1897">      {</a>
<a name="ln1898">        std::cerr &lt;&lt; &quot;error reading history from '&quot; &lt;&lt; key &lt;&lt; &quot;' (&quot; &lt;&lt; filename &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln1899">        g_list_free_full(history_entries, free_history_entry);</a>
<a name="ln1900">        g_free(key);</a>
<a name="ln1901">        return NULL;</a>
<a name="ln1902">      }</a>
<a name="ln1903"> </a>
<a name="ln1904">      // skip everything that isn't part of the actual array</a>
<a name="ln1905">      if(*(key_iter++) != ']')</a>
<a name="ln1906">      {</a>
<a name="ln1907">        std::cerr &lt;&lt; &quot;error reading history from '&quot; &lt;&lt; key &lt;&lt; &quot;' (&quot; &lt;&lt; filename &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln1908">        g_list_free_full(history_entries, free_history_entry);</a>
<a name="ln1909">        g_free(key);</a>
<a name="ln1910">        return NULL;</a>
<a name="ln1911">      }</a>
<a name="ln1912">      if(*(key_iter++) != '/') goto skip;</a>
<a name="ln1913">      if(*key_iter == '?') key_iter++;</a>
<a name="ln1914"> </a>
<a name="ln1915">      // make sure we are filling in the details of the correct entry</a>
<a name="ln1916">      unsigned int length = g_list_length(history_entries);</a>
<a name="ln1917">      if(n &gt; length)</a>
<a name="ln1918">      {</a>
<a name="ln1919">        current_entry = (history_entry_t *)calloc(1, sizeof(history_entry_t));</a>
<a name="ln1920">        current_entry-&gt;blendop_version = 1; // default version in case it's not specified</a>
<a name="ln1921">        history_entries = g_list_append(history_entries, current_entry);</a>
<a name="ln1922">      }</a>
<a name="ln1923">      else if(n &lt; length)</a>
<a name="ln1924">      {</a>
<a name="ln1925">        // AFAICT this can't happen with regular exiv2 parsed XMP data, but better safe than sorry.</a>
<a name="ln1926">        // it can happen though when constructing things in a unusual order and then passing it to us without</a>
<a name="ln1927">        // serializing it in between</a>
<a name="ln1928">        current_entry = (history_entry_t *)g_list_nth_data(history_entries, n - 1); // XMP starts counting at 1!</a>
<a name="ln1929">      }</a>
<a name="ln1930"> </a>
<a name="ln1931">      // go on reading things into current_entry</a>
<a name="ln1932">      if(g_str_has_prefix(key_iter, &quot;darktable:operation&quot;))</a>
<a name="ln1933">      {</a>
<a name="ln1934">        current_entry-&gt;have_operation = TRUE;</a>
<a name="ln1935">        current_entry-&gt;operation = g_strdup(history-&gt;value().toString().c_str());</a>
<a name="ln1936">      }</a>
<a name="ln1937">      else if(g_str_has_prefix(key_iter, &quot;darktable:enabled&quot;))</a>
<a name="ln1938">      {</a>
<a name="ln1939">        current_entry-&gt;enabled = history-&gt;value().toLong() == 1;</a>
<a name="ln1940">      }</a>
<a name="ln1941">      else if(g_str_has_prefix(key_iter, &quot;darktable:modversion&quot;))</a>
<a name="ln1942">      {</a>
<a name="ln1943">        current_entry-&gt;have_modversion = TRUE;</a>
<a name="ln1944">        current_entry-&gt;modversion = history-&gt;value().toLong();</a>
<a name="ln1945">      }</a>
<a name="ln1946">      else if(g_str_has_prefix(key_iter, &quot;darktable:params&quot;))</a>
<a name="ln1947">      {</a>
<a name="ln1948">        current_entry-&gt;have_params = TRUE;</a>
<a name="ln1949">        current_entry-&gt;params = dt_exif_xmp_decode(history-&gt;value().toString().c_str(), history-&gt;value().size(),</a>
<a name="ln1950">                                                   &amp;current_entry-&gt;params_len);</a>
<a name="ln1951">      }</a>
<a name="ln1952">      else if(g_str_has_prefix(key_iter, &quot;darktable:multi_name&quot;))</a>
<a name="ln1953">      {</a>
<a name="ln1954">        current_entry-&gt;multi_name = g_strdup(history-&gt;value().toString().c_str());</a>
<a name="ln1955">      }</a>
<a name="ln1956">      else if(g_str_has_prefix(key_iter, &quot;darktable:multi_priority&quot;))</a>
<a name="ln1957">      {</a>
<a name="ln1958">        current_entry-&gt;multi_priority = history-&gt;value().toLong();</a>
<a name="ln1959">      }</a>
<a name="ln1960">      else if(g_str_has_prefix(key_iter, &quot;darktable:blendop_version&quot;))</a>
<a name="ln1961">      {</a>
<a name="ln1962">        current_entry-&gt;blendop_version = history-&gt;value().toLong();</a>
<a name="ln1963">      }</a>
<a name="ln1964">      else if(g_str_has_prefix(key_iter, &quot;darktable:blendop_params&quot;))</a>
<a name="ln1965">      {</a>
<a name="ln1966">        current_entry-&gt;blendop_params = dt_exif_xmp_decode(history-&gt;value().toString().c_str(),</a>
<a name="ln1967">                                                           history-&gt;value().size(),</a>
<a name="ln1968">                                                           &amp;current_entry-&gt;blendop_params_len);</a>
<a name="ln1969">      }</a>
<a name="ln1970"> </a>
<a name="ln1971">    }</a>
<a name="ln1972">skip:</a>
<a name="ln1973">    g_free(key);</a>
<a name="ln1974">  }</a>
<a name="ln1975"> </a>
<a name="ln1976">  // a final sanity check</a>
<a name="ln1977">  for(GList *iter = history_entries; iter; iter = g_list_next(iter))</a>
<a name="ln1978">  {</a>
<a name="ln1979">    history_entry_t *entry = (history_entry_t *)iter-&gt;data;</a>
<a name="ln1980">    if(!(entry-&gt;have_operation &amp;&amp; entry-&gt;have_params &amp;&amp; entry-&gt;have_modversion))</a>
<a name="ln1981">    {</a>
<a name="ln1982">      std::cerr &lt;&lt; &quot;[exif] error: reading history from '&quot; &lt;&lt; filename &lt;&lt; &quot;' failed due to missing tags&quot; &lt;&lt; std::endl;</a>
<a name="ln1983">      g_list_free_full(history_entries, free_history_entry);</a>
<a name="ln1984">      history_entries = NULL;</a>
<a name="ln1985">      break;</a>
<a name="ln1986">    }</a>
<a name="ln1987">  }</a>
<a name="ln1988"> </a>
<a name="ln1989">  return history_entries;</a>
<a name="ln1990">}</a>
<a name="ln1991"> </a>
<a name="ln1992">void free_mask_entry(gpointer data)</a>
<a name="ln1993">{</a>
<a name="ln1994">  mask_entry_t *entry = (mask_entry_t *)data;</a>
<a name="ln1995">  g_free(entry-&gt;mask_name);</a>
<a name="ln1996">  free(entry-&gt;mask);</a>
<a name="ln1997">  free(entry-&gt;mask_src);</a>
<a name="ln1998">  free(entry);</a>
<a name="ln1999">}</a>
<a name="ln2000"> </a>
<a name="ln2001">static GHashTable *read_masks(Exiv2::XmpData &amp;xmpData, const char *filename)</a>
<a name="ln2002">{</a>
<a name="ln2003">  GHashTable *mask_entries = g_hash_table_new_full(g_int_hash, g_int_equal, NULL, free_mask_entry);</a>
<a name="ln2004"> </a>
<a name="ln2005">  // TODO: turn that into something like Xmp.darktable.history!</a>
<a name="ln2006">  Exiv2::XmpData::iterator mask;</a>
<a name="ln2007">  Exiv2::XmpData::iterator mask_name;</a>
<a name="ln2008">  Exiv2::XmpData::iterator mask_type;</a>
<a name="ln2009">  Exiv2::XmpData::iterator mask_version;</a>
<a name="ln2010">  Exiv2::XmpData::iterator mask_id;</a>
<a name="ln2011">  Exiv2::XmpData::iterator mask_nb;</a>
<a name="ln2012">  Exiv2::XmpData::iterator mask_src;</a>
<a name="ln2013">  if((mask = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask&quot;))) != xmpData.end()</a>
<a name="ln2014">    &amp;&amp; (mask_src = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_src&quot;))) != xmpData.end()</a>
<a name="ln2015">    &amp;&amp; (mask_name = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_name&quot;))) != xmpData.end()</a>
<a name="ln2016">    &amp;&amp; (mask_type = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_type&quot;))) != xmpData.end()</a>
<a name="ln2017">    &amp;&amp; (mask_version = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_version&quot;))) != xmpData.end()</a>
<a name="ln2018">    &amp;&amp; (mask_id = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_id&quot;))) != xmpData.end()</a>
<a name="ln2019">    &amp;&amp; (mask_nb = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_nb&quot;))) != xmpData.end())</a>
<a name="ln2020">  {</a>
<a name="ln2021">    const int cnt = mask-&gt;count();</a>
<a name="ln2022">    if(cnt == mask_src-&gt;count() &amp;&amp; cnt == mask_name-&gt;count() &amp;&amp; cnt == mask_type-&gt;count()</a>
<a name="ln2023">      &amp;&amp; cnt == mask_version-&gt;count() &amp;&amp; cnt == mask_id-&gt;count() &amp;&amp; cnt == mask_nb-&gt;count())</a>
<a name="ln2024">    {</a>
<a name="ln2025">      for(int i = 0; i &lt; cnt; i++)</a>
<a name="ln2026">      {</a>
<a name="ln2027">        mask_entry_t *entry = (mask_entry_t *)calloc(1, sizeof(mask_entry_t));</a>
<a name="ln2028"> </a>
<a name="ln2029">        entry-&gt;mask_id = mask_id-&gt;toLong(i);</a>
<a name="ln2030">        entry-&gt;mask_type = mask_type-&gt;toLong(i);</a>
<a name="ln2031">        std::string mask_name_str = mask_name-&gt;toString(i);</a>
<a name="ln2032">        if(mask_name_str.c_str() != NULL)</a>
<a name="ln2033">          entry-&gt;mask_name = g_strdup(mask_name_str.c_str());</a>
<a name="ln2034">        else</a>
<a name="ln2035">          entry-&gt;mask_name = g_strdup(&quot;form&quot;);</a>
<a name="ln2036"> </a>
<a name="ln2037">        entry-&gt;mask_version = mask_version-&gt;toLong(i);</a>
<a name="ln2038"> </a>
<a name="ln2039">        std::string mask_str = mask-&gt;toString(i);</a>
<a name="ln2040">        const char *mask_c = mask_str.c_str();</a>
<a name="ln2041">        const size_t mask_c_len = strlen(mask_c);</a>
<a name="ln2042">        entry-&gt;mask = dt_exif_xmp_decode(mask_c, mask_c_len, &amp;entry-&gt;mask_len);</a>
<a name="ln2043"> </a>
<a name="ln2044">        entry-&gt;mask_nb = mask_nb-&gt;toLong(i);</a>
<a name="ln2045"> </a>
<a name="ln2046">        std::string mask_src_str = mask_src-&gt;toString(i);</a>
<a name="ln2047">        const char *mask_src_c = mask_src_str.c_str();</a>
<a name="ln2048">        const size_t mask_src_c_len = strlen(mask_src_c);</a>
<a name="ln2049">        entry-&gt;mask_src = dt_exif_xmp_decode(mask_src_c, mask_src_c_len, &amp;entry-&gt;mask_src_len);</a>
<a name="ln2050"> </a>
<a name="ln2051">        g_hash_table_insert(mask_entries, &amp;entry-&gt;mask_id, (gpointer)entry);</a>
<a name="ln2052">      }</a>
<a name="ln2053">    }</a>
<a name="ln2054">  }</a>
<a name="ln2055"> </a>
<a name="ln2056">  return mask_entries;</a>
<a name="ln2057">}</a>
<a name="ln2058"> </a>
<a name="ln2059">static void add_mask_entry_to_db(int imgid, mask_entry_t *entry)</a>
<a name="ln2060">{</a>
<a name="ln2061">  // add the mask entry only once</a>
<a name="ln2062">  if(entry-&gt;already_added)</a>
<a name="ln2063">    return;</a>
<a name="ln2064">  entry-&gt;already_added = TRUE;</a>
<a name="ln2065"> </a>
<a name="ln2066">  sqlite3_stmt *stmt;</a>
<a name="ln2067">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln2068">    dt_database_get(darktable.db),</a>
<a name="ln2069">                              &quot;INSERT INTO main.mask (imgid, formid, form, name, version, points, points_count, source) &quot;</a>
<a name="ln2070">                              &quot;VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)&quot;,</a>
<a name="ln2071">                              -1, &amp;stmt, NULL);</a>
<a name="ln2072">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2073">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, entry-&gt;mask_id);</a>
<a name="ln2074">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, entry-&gt;mask_type);</a>
<a name="ln2075">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, entry-&gt;mask_name, -1, SQLITE_TRANSIENT);</a>
<a name="ln2076">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 5, entry-&gt;mask_version);</a>
<a name="ln2077">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 6, entry-&gt;mask, entry-&gt;mask_len, SQLITE_TRANSIENT);</a>
<a name="ln2078">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 7, entry-&gt;mask_nb);</a>
<a name="ln2079">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 8, entry-&gt;mask_src, entry-&gt;mask_src_len, SQLITE_TRANSIENT);</a>
<a name="ln2080">  sqlite3_step(stmt);</a>
<a name="ln2081">  sqlite3_finalize(stmt);</a>
<a name="ln2082">}</a>
<a name="ln2083"> </a>
<a name="ln2084">static void add_non_clone_mask_entries_to_db(gpointer key, gpointer value, gpointer user_data)</a>
<a name="ln2085">{</a>
<a name="ln2086">  int imgid = *(int *)user_data;</a>
<a name="ln2087">  mask_entry_t *entry = (mask_entry_t *)value;</a>
<a name="ln2088">  if(!(entry-&gt;mask_type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))) add_mask_entry_to_db(imgid, entry);</a>
<a name="ln2089">}</a>
<a name="ln2090"> </a>
<a name="ln2091">static void add_mask_entries_to_db(int imgid, GHashTable *mask_entries, int mask_id)</a>
<a name="ln2092">{</a>
<a name="ln2093">  if(mask_id &lt;= 0) return;</a>
<a name="ln2094"> </a>
<a name="ln2095">  // look for mask_id in the hash table</a>
<a name="ln2096">  mask_entry_t *entry = (mask_entry_t *)g_hash_table_lookup(mask_entries, &amp;mask_id);</a>
<a name="ln2097"> </a>
<a name="ln2098">  if(!entry) return;</a>
<a name="ln2099"> </a>
<a name="ln2100">  // if it's a group: recurse into the children first</a>
<a name="ln2101">  if(entry-&gt;mask_type &amp; DT_MASKS_GROUP)</a>
<a name="ln2102">  {</a>
<a name="ln2103">    dt_masks_point_group_t *group = (dt_masks_point_group_t *)entry-&gt;mask;</a>
<a name="ln2104">    if((int)(entry-&gt;mask_nb * sizeof(dt_masks_point_group_t)) != entry-&gt;mask_len)</a>
<a name="ln2105">    {</a>
<a name="ln2106">      fprintf(stderr, &quot;[masks] error loading masks from xmp file, bad binary blob size.\n&quot;);</a>
<a name="ln2107">      return;</a>
<a name="ln2108">    }</a>
<a name="ln2109">    for(int i = 0; i &lt; entry-&gt;mask_nb; i++)</a>
<a name="ln2110">      add_mask_entries_to_db(imgid, mask_entries, group[i].formid);</a>
<a name="ln2111">  }</a>
<a name="ln2112"> </a>
<a name="ln2113">  add_mask_entry_to_db(imgid, entry);</a>
<a name="ln2114">}</a>
<a name="ln2115"> </a>
<a name="ln2116">// need a write lock on *img (non-const) to write stars (and soon color labels).</a>
<a name="ln2117">int dt_exif_xmp_read(dt_image_t *img, const char *filename, const int history_only)</a>
<a name="ln2118">{</a>
<a name="ln2119">  // exclude pfm to avoid stupid errors on the console</a>
<a name="ln2120">  const char *c = filename + strlen(filename) - 4;</a>
<a name="ln2121">  if(c &gt;= filename &amp;&amp; !strcmp(c, &quot;.pfm&quot;)) return 1;</a>
<a name="ln2122">  try</a>
<a name="ln2123">  {</a>
<a name="ln2124">    // read xmp sidecar</a>
<a name="ln2125">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(filename)));</a>
<a name="ln2126">    assert(image.get() != 0);</a>
<a name="ln2127">    read_metadata_threadsafe(image);</a>
<a name="ln2128">    Exiv2::XmpData &amp;xmpData = image-&gt;xmpData();</a>
<a name="ln2129"> </a>
<a name="ln2130">    sqlite3_stmt *stmt;</a>
<a name="ln2131"> </a>
<a name="ln2132">    Exiv2::XmpData::iterator pos;</a>
<a name="ln2133"> </a>
<a name="ln2134">    int version = 0;</a>
<a name="ln2135">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.xmp_version&quot;))) != xmpData.end())</a>
<a name="ln2136">      version = pos-&gt;toLong();</a>
<a name="ln2137"> </a>
<a name="ln2138">    if(!history_only)</a>
<a name="ln2139">    {</a>
<a name="ln2140">      // otherwise we ignore title, description, ... from non-dt xmp files :(</a>
<a name="ln2141">      size_t ns_pos = image-&gt;xmpPacket().find(&quot;xmlns:darktable=\&quot;http://darktable.sf.net/\&quot;&quot;);</a>
<a name="ln2142">      bool is_a_dt_xmp = (ns_pos != std::string::npos);</a>
<a name="ln2143">      dt_exif_read_xmp_data(img, xmpData, is_a_dt_xmp ? version : -1, false);</a>
<a name="ln2144">    }</a>
<a name="ln2145"> </a>
<a name="ln2146"> </a>
<a name="ln2147">    // convert legacy flip bits (will not be written anymore, convert to flip history item here):</a>
<a name="ln2148">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.raw_params&quot;))) != xmpData.end())</a>
<a name="ln2149">    {</a>
<a name="ln2150">      int32_t i = pos-&gt;toLong();</a>
<a name="ln2151">      dt_image_raw_parameters_t raw_params = *(dt_image_raw_parameters_t *)&amp;i;</a>
<a name="ln2152">      int32_t user_flip = raw_params.user_flip;</a>
<a name="ln2153">      img-&gt;legacy_flip.user_flip = user_flip;</a>
<a name="ln2154">      img-&gt;legacy_flip.legacy = 0;</a>
<a name="ln2155">    }</a>
<a name="ln2156"> </a>
<a name="ln2157">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.auto_presets_applied&quot;))) != xmpData.end())</a>
<a name="ln2158">    {</a>
<a name="ln2159">      int32_t i = pos-&gt;toLong();</a>
<a name="ln2160">      // set or clear bit in image struct</a>
<a name="ln2161">      if(i == 1) img-&gt;flags |= DT_IMAGE_AUTO_PRESETS_APPLIED;</a>
<a name="ln2162">      if(i == 0) img-&gt;flags &amp;= ~DT_IMAGE_AUTO_PRESETS_APPLIED;</a>
<a name="ln2163">      // in any case, this is no legacy image.</a>
<a name="ln2164">      img-&gt;flags |= DT_IMAGE_NO_LEGACY_PRESETS;</a>
<a name="ln2165">    }</a>
<a name="ln2166">    else</a>
<a name="ln2167">    {</a>
<a name="ln2168">      // not found means 0 (old xmp)</a>
<a name="ln2169">      img-&gt;flags &amp;= ~DT_IMAGE_AUTO_PRESETS_APPLIED;</a>
<a name="ln2170">      // so we are legacy (thus have to clear the no-legacy flag)</a>
<a name="ln2171">      img-&gt;flags &amp;= ~DT_IMAGE_NO_LEGACY_PRESETS;</a>
<a name="ln2172">    }</a>
<a name="ln2173">    // when we are reading the xmp data it doesn't make sense to flag the image as removed</a>
<a name="ln2174">    img-&gt;flags &amp;= ~DT_IMAGE_REMOVE;</a>
<a name="ln2175"> </a>
<a name="ln2176"> </a>
<a name="ln2177">    // masks</a>
<a name="ln2178">    // clean all old masks for this image</a>
<a name="ln2179">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.mask WHERE imgid = ?1&quot;, -1,</a>
<a name="ln2180">                                &amp;stmt, NULL);</a>
<a name="ln2181">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2182">    sqlite3_step(stmt);</a>
<a name="ln2183">    sqlite3_finalize(stmt);</a>
<a name="ln2184"> </a>
<a name="ln2185">    // read the masks from the file first so we can add them to the db while reading history entries</a>
<a name="ln2186">    GHashTable *mask_entries = read_masks(xmpData, filename);</a>
<a name="ln2187"> </a>
<a name="ln2188">    // now add all masks that are not used for cloning. keeping them might be useful.</a>
<a name="ln2189">    // TODO: make this configurable? or remove it altogether?</a>
<a name="ln2190">    sqlite3_exec(dt_database_get(darktable.db), &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln2191">    g_hash_table_foreach(mask_entries, add_non_clone_mask_entries_to_db, &amp;img-&gt;id);</a>
<a name="ln2192">    sqlite3_exec(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln2193"> </a>
<a name="ln2194">    // history</a>
<a name="ln2195">    int num = 0;</a>
<a name="ln2196">    gboolean all_ok = TRUE;</a>
<a name="ln2197">    GList *history_entries = NULL;</a>
<a name="ln2198"> </a>
<a name="ln2199">    if(version &lt; 2)</a>
<a name="ln2200">    {</a>
<a name="ln2201">      std::string &amp;xmpPacket = image-&gt;xmpPacket();</a>
<a name="ln2202">      history_entries = read_history_v1(xmpPacket, filename, 0);</a>
<a name="ln2203">      if(!history_entries) // didn't work? try super old version with rdf:Bag</a>
<a name="ln2204">        history_entries = read_history_v1(xmpPacket, filename, 1);</a>
<a name="ln2205">    }</a>
<a name="ln2206">    else if(version == 2)</a>
<a name="ln2207">      history_entries = read_history_v2(xmpData, filename);</a>
<a name="ln2208">    else</a>
<a name="ln2209">    {</a>
<a name="ln2210">      std::cerr &lt;&lt; &quot;error: Xmp schema version &quot; &lt;&lt; version &lt;&lt; &quot; in &quot; &lt;&lt; filename &lt;&lt; &quot; not supported&quot; &lt;&lt; std::endl;</a>
<a name="ln2211">      g_hash_table_destroy(mask_entries);</a>
<a name="ln2212">      return 1;</a>
<a name="ln2213">    }</a>
<a name="ln2214"> </a>
<a name="ln2215">    sqlite3_exec(dt_database_get(darktable.db), &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln2216"> </a>
<a name="ln2217">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln2218">                                &amp;stmt, NULL);</a>
<a name="ln2219">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2220">    if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2221">    {</a>
<a name="ln2222">      fprintf(stderr, &quot;[exif] error deleting history for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2223">      fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2224">      all_ok = FALSE;</a>
<a name="ln2225">      goto end;</a>
<a name="ln2226">    }</a>
<a name="ln2227"> </a>
<a name="ln2228">    sqlite3_finalize(stmt);</a>
<a name="ln2229"> </a>
<a name="ln2230">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2231">                                &quot;INSERT INTO main.history (imgid, num, module, operation, op_params, enabled, &quot;</a>
<a name="ln2232">                                &quot;blendop_params, blendop_version, multi_priority, multi_name) &quot;</a>
<a name="ln2233">                                &quot;VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln2234"> </a>
<a name="ln2235">    for(GList *iter = history_entries; iter; iter = g_list_next(iter))</a>
<a name="ln2236">    {</a>
<a name="ln2237">      history_entry_t *entry = (history_entry_t *)iter-&gt;data;</a>
<a name="ln2238">//       print_history_entry(entry);</a>
<a name="ln2239"> </a>
<a name="ln2240">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2241">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, num);</a>
<a name="ln2242">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, entry-&gt;modversion);</a>
<a name="ln2243">      DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, entry-&gt;operation, -1, SQLITE_TRANSIENT);</a>
<a name="ln2244">      DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 5, entry-&gt;params, entry-&gt;params_len, SQLITE_TRANSIENT);</a>
<a name="ln2245">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 6, entry-&gt;enabled);</a>
<a name="ln2246">      if(entry-&gt;blendop_params)</a>
<a name="ln2247">      {</a>
<a name="ln2248">        DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 7, entry-&gt;blendop_params, entry-&gt;blendop_params_len, SQLITE_TRANSIENT);</a>
<a name="ln2249"> </a>
<a name="ln2250">        // check what mask entries belong to this iop and add them to the db</a>
<a name="ln2251">        const dt_develop_blend_params_t *blendop_params = (dt_develop_blend_params_t *)entry-&gt;blendop_params;</a>
<a name="ln2252">        add_mask_entries_to_db(img-&gt;id, mask_entries, blendop_params-&gt;mask_id);</a>
<a name="ln2253">      }</a>
<a name="ln2254">      else</a>
<a name="ln2255">      {</a>
<a name="ln2256">        sqlite3_bind_null(stmt, 7);</a>
<a name="ln2257">      }</a>
<a name="ln2258">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 8, entry-&gt;blendop_version);</a>
<a name="ln2259">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 9, entry-&gt;multi_priority);</a>
<a name="ln2260">      if(entry-&gt;multi_name)</a>
<a name="ln2261">      {</a>
<a name="ln2262">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 10, entry-&gt;multi_name, -1, SQLITE_TRANSIENT);</a>
<a name="ln2263">      }</a>
<a name="ln2264">      else</a>
<a name="ln2265">      {</a>
<a name="ln2266">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 10, &quot;&quot;, -1, SQLITE_TRANSIENT); // &quot;&quot; instead of &quot; &quot; should be fine now</a>
<a name="ln2267">      }</a>
<a name="ln2268"> </a>
<a name="ln2269">      if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2270">      {</a>
<a name="ln2271">        fprintf(stderr, &quot;[exif] error adding history entry for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2272">        fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2273">        all_ok = FALSE;</a>
<a name="ln2274">        goto end;</a>
<a name="ln2275">      }</a>
<a name="ln2276">      sqlite3_reset(stmt);</a>
<a name="ln2277">      sqlite3_clear_bindings(stmt);</a>
<a name="ln2278"> </a>
<a name="ln2279">      num++;</a>
<a name="ln2280">    }</a>
<a name="ln2281">    sqlite3_finalize(stmt);</a>
<a name="ln2282"> </a>
<a name="ln2283">    // we shouldn't change history_end when no history was read!</a>
<a name="ln2284">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.history_end&quot;))) != xmpData.end() &amp;&amp; num &gt; 0)</a>
<a name="ln2285">    {</a>
<a name="ln2286">      int history_end = MIN(pos-&gt;toLong(), num);</a>
<a name="ln2287">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2288">                                  &quot;UPDATE main.images SET history_end = ?1 WHERE id = ?2&quot;, -1,</a>
<a name="ln2289">                                  &amp;stmt, NULL);</a>
<a name="ln2290">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, history_end);</a>
<a name="ln2291">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, img-&gt;id);</a>
<a name="ln2292">      if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2293">      {</a>
<a name="ln2294">        fprintf(stderr, &quot;[exif] error writing history_end for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2295">        fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2296">        all_ok = FALSE;</a>
<a name="ln2297">        goto end;</a>
<a name="ln2298">      }</a>
<a name="ln2299">    }</a>
<a name="ln2300">    else</a>
<a name="ln2301">    {</a>
<a name="ln2302">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2303">                                  &quot;UPDATE main.images SET history_end = (SELECT IFNULL(MAX(num) + 1, 0) &quot;</a>
<a name="ln2304">                                  &quot;FROM main.history WHERE imgid = ?1) WHERE id = ?1&quot;, -1,</a>
<a name="ln2305">                                  &amp;stmt, NULL);</a>
<a name="ln2306">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2307">      if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2308">      {</a>
<a name="ln2309">        fprintf(stderr, &quot;[exif] error writing history_end for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2310">        fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2311">        all_ok = FALSE;</a>
<a name="ln2312">        goto end;</a>
<a name="ln2313">      }</a>
<a name="ln2314">    }</a>
<a name="ln2315"> </a>
<a name="ln2316">end:</a>
<a name="ln2317">    sqlite3_finalize(stmt);</a>
<a name="ln2318"> </a>
<a name="ln2319">    g_list_free_full(history_entries, free_history_entry);</a>
<a name="ln2320">    g_hash_table_destroy(mask_entries);</a>
<a name="ln2321"> </a>
<a name="ln2322">    if(all_ok)</a>
<a name="ln2323">    {</a>
<a name="ln2324">      sqlite3_exec(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln2325">    }</a>
<a name="ln2326">    else</a>
<a name="ln2327">    {</a>
<a name="ln2328">      std::cerr &lt;&lt; &quot;[exif] error reading history from '&quot; &lt;&lt; filename &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;</a>
<a name="ln2329">      sqlite3_exec(dt_database_get(darktable.db), &quot;ROLLBACK TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln2330">      return 1;</a>
<a name="ln2331">    }</a>
<a name="ln2332"> </a>
<a name="ln2333">  }</a>
<a name="ln2334">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln2335">  {</a>
<a name="ln2336">    // actually nobody's interested in that if the file doesn't exist:</a>
<a name="ln2337">    // std::string s(e.what());</a>
<a name="ln2338">    // std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln2339">    return 1;</a>
<a name="ln2340">  }</a>
<a name="ln2341">  return 0;</a>
<a name="ln2342">}</a>
<a name="ln2343"> </a>
<a name="ln2344">// helper to create an xmp data thing. throws exiv2 exceptions if stuff goes wrong.</a>
<a name="ln2345">static void dt_exif_xmp_read_data(Exiv2::XmpData &amp;xmpData, const int imgid)</a>
<a name="ln2346">{</a>
<a name="ln2347">  const int xmp_version = 2;</a>
<a name="ln2348">  int stars = 1, raw_params = 0, history_end = -1;</a>
<a name="ln2349">  double longitude = NAN, latitude = NAN, altitude = NAN;</a>
<a name="ln2350">  gchar *filename = NULL;</a>
<a name="ln2351">  // get stars and raw params from db</a>
<a name="ln2352">  sqlite3_stmt *stmt;</a>
<a name="ln2353">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT filename, flags, raw_parameters, &quot;</a>
<a name="ln2354">                                                             &quot;longitude, latitude, altitude, history_end &quot;</a>
<a name="ln2355">                                                             &quot;FROM main.images WHERE id = ?1&quot;,</a>
<a name="ln2356">                              -1, &amp;stmt, NULL);</a>
<a name="ln2357">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2358">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2359">  {</a>
<a name="ln2360">    filename = (gchar *)sqlite3_column_text(stmt, 0);</a>
<a name="ln2361">    stars = sqlite3_column_int(stmt, 1);</a>
<a name="ln2362">    raw_params = sqlite3_column_int(stmt, 2);</a>
<a name="ln2363">    if(sqlite3_column_type(stmt, 3) == SQLITE_FLOAT) longitude = sqlite3_column_double(stmt, 3);</a>
<a name="ln2364">    if(sqlite3_column_type(stmt, 4) == SQLITE_FLOAT) latitude = sqlite3_column_double(stmt, 4);</a>
<a name="ln2365">    if(sqlite3_column_type(stmt, 5) == SQLITE_FLOAT) altitude = sqlite3_column_double(stmt, 5);</a>
<a name="ln2366">    history_end = sqlite3_column_int(stmt, 6);</a>
<a name="ln2367">  }</a>
<a name="ln2368"> </a>
<a name="ln2369">  // We have to erase the old ratings first as exiv2 seems to not change it otherwise.</a>
<a name="ln2370">  Exiv2::XmpData::iterator pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.xmp.Rating&quot;));</a>
<a name="ln2371">  if(pos != xmpData.end()) xmpData.erase(pos);</a>
<a name="ln2372">  xmpData[&quot;Xmp.xmp.Rating&quot;] = ((stars &amp; 0x7) == 6) ? -1 : (stars &amp; 0x7); // rejected image = -1, others = 0..5</a>
<a name="ln2373"> </a>
<a name="ln2374">  // The original file name</a>
<a name="ln2375">  if(filename) xmpData[&quot;Xmp.xmpMM.DerivedFrom&quot;] = filename;</a>
<a name="ln2376"> </a>
<a name="ln2377">  // GPS data</a>
<a name="ln2378">  if(!std::isnan(longitude) &amp;&amp; !std::isnan(latitude))</a>
<a name="ln2379">  {</a>
<a name="ln2380">    char long_dir = 'E', lat_dir = 'N';</a>
<a name="ln2381">    if(longitude &lt; 0) long_dir = 'W';</a>
<a name="ln2382">    if(latitude &lt; 0) lat_dir = 'S';</a>
<a name="ln2383"> </a>
<a name="ln2384">    longitude = fabs(longitude);</a>
<a name="ln2385">    latitude = fabs(latitude);</a>
<a name="ln2386"> </a>
<a name="ln2387">    int long_deg = (int)floor(longitude);</a>
<a name="ln2388">    int lat_deg = (int)floor(latitude);</a>
<a name="ln2389">    double long_min = (longitude - (double)long_deg) * 60.0;</a>
<a name="ln2390">    double lat_min = (latitude - (double)lat_deg) * 60.0;</a>
<a name="ln2391"> </a>
<a name="ln2392">    char *str = (char *)g_malloc(G_ASCII_DTOSTR_BUF_SIZE);</a>
<a name="ln2393"> </a>
<a name="ln2394">    g_ascii_formatd(str, G_ASCII_DTOSTR_BUF_SIZE, &quot;%08f&quot;, long_min);</a>
<a name="ln2395">    gchar *long_str = g_strdup_printf(&quot;%d,%s%c&quot;, long_deg, str, long_dir);</a>
<a name="ln2396">    g_ascii_formatd(str, G_ASCII_DTOSTR_BUF_SIZE, &quot;%08f&quot;, lat_min);</a>
<a name="ln2397">    gchar *lat_str = g_strdup_printf(&quot;%d,%s%c&quot;, lat_deg, str, lat_dir);</a>
<a name="ln2398"> </a>
<a name="ln2399">    xmpData[&quot;Xmp.exif.GPSVersionID&quot;] = &quot;2.2.0.0&quot;;</a>
<a name="ln2400">    xmpData[&quot;Xmp.exif.GPSLongitude&quot;] = long_str;</a>
<a name="ln2401">    xmpData[&quot;Xmp.exif.GPSLatitude&quot;] = lat_str;</a>
<a name="ln2402">    g_free(long_str);</a>
<a name="ln2403">    g_free(lat_str);</a>
<a name="ln2404">    g_free(str);</a>
<a name="ln2405">  }</a>
<a name="ln2406">  if(!std::isnan(altitude))</a>
<a name="ln2407">  {</a>
<a name="ln2408">    xmpData[&quot;Xmp.exif.GPSAltitudeRef&quot;] = (altitude &lt; 0) ? &quot;1&quot; : &quot;0&quot;;</a>
<a name="ln2409"> </a>
<a name="ln2410">    long ele_dm = (int)floor(fabs(10.0 * altitude));</a>
<a name="ln2411">    gchar *ele_str = g_strdup_printf(&quot;%ld/10&quot;, ele_dm);</a>
<a name="ln2412">    xmpData[&quot;Xmp.exif.GPSAltitude&quot;] = ele_str;</a>
<a name="ln2413">    g_free(ele_str);</a>
<a name="ln2414">  }</a>
<a name="ln2415">  sqlite3_finalize(stmt);</a>
<a name="ln2416"> </a>
<a name="ln2417">  // the meta data</a>
<a name="ln2418">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT key, value FROM main.meta_data WHERE id = ?1&quot;,</a>
<a name="ln2419">                              -1, &amp;stmt, NULL);</a>
<a name="ln2420">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2421">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2422">  {</a>
<a name="ln2423">    int key = sqlite3_column_int(stmt, 0);</a>
<a name="ln2424">    switch(key)</a>
<a name="ln2425">    {</a>
<a name="ln2426">      case DT_METADATA_XMP_DC_CREATOR:</a>
<a name="ln2427">        xmpData[&quot;Xmp.dc.creator&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln2428">        break;</a>
<a name="ln2429">      case DT_METADATA_XMP_DC_PUBLISHER:</a>
<a name="ln2430">        xmpData[&quot;Xmp.dc.publisher&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln2431">        break;</a>
<a name="ln2432">      case DT_METADATA_XMP_DC_TITLE:</a>
<a name="ln2433">        xmpData[&quot;Xmp.dc.title&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln2434">        break;</a>
<a name="ln2435">      case DT_METADATA_XMP_DC_DESCRIPTION:</a>
<a name="ln2436">        xmpData[&quot;Xmp.dc.description&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln2437">        break;</a>
<a name="ln2438">      case DT_METADATA_XMP_DC_RIGHTS:</a>
<a name="ln2439">        xmpData[&quot;Xmp.dc.rights&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln2440">        break;</a>
<a name="ln2441">    }</a>
<a name="ln2442">  }</a>
<a name="ln2443">  sqlite3_finalize(stmt);</a>
<a name="ln2444"> </a>
<a name="ln2445">  xmpData[&quot;Xmp.darktable.xmp_version&quot;] = xmp_version;</a>
<a name="ln2446">  xmpData[&quot;Xmp.darktable.raw_params&quot;] = raw_params;</a>
<a name="ln2447"> </a>
<a name="ln2448">  if(stars &amp; DT_IMAGE_AUTO_PRESETS_APPLIED)</a>
<a name="ln2449">    xmpData[&quot;Xmp.darktable.auto_presets_applied&quot;] = 1;</a>
<a name="ln2450">  else</a>
<a name="ln2451">    xmpData[&quot;Xmp.darktable.auto_presets_applied&quot;] = 0;</a>
<a name="ln2452"> </a>
<a name="ln2453">  // get tags from db, store in dublin core</a>
<a name="ln2454">  std::unique_ptr&lt;Exiv2::Value&gt; v1(Exiv2::Value::create(Exiv2::xmpSeq)); // or xmpBag or xmpAlt.</a>
<a name="ln2455"> </a>
<a name="ln2456">  std::unique_ptr&lt;Exiv2::Value&gt; v2(Exiv2::Value::create(Exiv2::xmpSeq)); // or xmpBag or xmpAlt.</a>
<a name="ln2457"> </a>
<a name="ln2458">  GList *tags = dt_tag_get_list(imgid);</a>
<a name="ln2459">  while(tags)</a>
<a name="ln2460">  {</a>
<a name="ln2461">    v1-&gt;read((char *)tags-&gt;data);</a>
<a name="ln2462">    tags = g_list_next(tags);</a>
<a name="ln2463">  }</a>
<a name="ln2464"> </a>
<a name="ln2465">  GList *hierarchical = dt_tag_get_hierarchical(imgid);</a>
<a name="ln2466">  while(hierarchical)</a>
<a name="ln2467">  {</a>
<a name="ln2468">    v2-&gt;read((char *)hierarchical-&gt;data);</a>
<a name="ln2469">    hierarchical = g_list_next(hierarchical);</a>
<a name="ln2470">  }</a>
<a name="ln2471"> </a>
<a name="ln2472">  if(v1-&gt;count() &gt; 0) xmpData.add(Exiv2::XmpKey(&quot;Xmp.dc.subject&quot;), v1.get());</a>
<a name="ln2473">  if(v2-&gt;count() &gt; 0) xmpData.add(Exiv2::XmpKey(&quot;Xmp.lr.hierarchicalSubject&quot;), v2.get());</a>
<a name="ln2474">  /* TODO: Add tags to IPTC namespace as well */</a>
<a name="ln2475"> </a>
<a name="ln2476">  // color labels</a>
<a name="ln2477">  char val[2048];</a>
<a name="ln2478">  std::unique_ptr&lt;Exiv2::Value&gt; v(Exiv2::Value::create(Exiv2::xmpSeq)); // or xmpBag or xmpAlt.</a>
<a name="ln2479"> </a>
<a name="ln2480">  /* Already initialized v = Exiv2::Value::create(Exiv2::xmpSeq); // or xmpBag or xmpAlt.*/</a>
<a name="ln2481">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT color FROM main.color_labels WHERE imgid=?1&quot;,</a>
<a name="ln2482">                              -1, &amp;stmt, NULL);</a>
<a name="ln2483">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2484">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2485">  {</a>
<a name="ln2486">    snprintf(val, sizeof(val), &quot;%d&quot;, sqlite3_column_int(stmt, 0));</a>
<a name="ln2487">    v-&gt;read(val);</a>
<a name="ln2488">  }</a>
<a name="ln2489">  sqlite3_finalize(stmt);</a>
<a name="ln2490">  if(v-&gt;count() &gt; 0) xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.colorlabels&quot;), v.get());</a>
<a name="ln2491"> </a>
<a name="ln2492">  // masks:</a>
<a name="ln2493">  char key[1024];</a>
<a name="ln2494">  int num = 1;</a>
<a name="ln2495"> </a>
<a name="ln2496">  // create an array:</a>
<a name="ln2497">  Exiv2::XmpTextValue tvm(&quot;&quot;);</a>
<a name="ln2498">  tvm.setXmpArrayType(Exiv2::XmpValue::xaSeq);</a>
<a name="ln2499">  xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.mask_id&quot;), &amp;tvm);</a>
<a name="ln2500">  xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.mask_type&quot;), &amp;tvm);</a>
<a name="ln2501">  xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.mask_name&quot;), &amp;tvm);</a>
<a name="ln2502">  xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.mask_version&quot;), &amp;tvm);</a>
<a name="ln2503">  xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.mask&quot;), &amp;tvm);</a>
<a name="ln2504">  xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.mask_nb&quot;), &amp;tvm);</a>
<a name="ln2505">  xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.mask_src&quot;), &amp;tvm);</a>
<a name="ln2506"> </a>
<a name="ln2507">  // reset tv</a>
<a name="ln2508">  tvm.setXmpArrayType(Exiv2::XmpValue::xaNone);</a>
<a name="ln2509"> </a>
<a name="ln2510">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln2511">      dt_database_get(darktable.db),</a>
<a name="ln2512">      &quot;SELECT imgid, formid, form, name, version, points, points_count, source FROM main.mask WHERE imgid = ?1&quot;,</a>
<a name="ln2513">      -1, &amp;stmt, NULL);</a>
<a name="ln2514">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2515">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2516">  {</a>
<a name="ln2517">    int32_t mask_id = sqlite3_column_int(stmt, 1);</a>
<a name="ln2518">    snprintf(val, sizeof(val), &quot;%d&quot;, mask_id);</a>
<a name="ln2519">    tvm.read(val);</a>
<a name="ln2520">    snprintf(key, sizeof(key), &quot;Xmp.darktable.mask_id[%d]&quot;, num);</a>
<a name="ln2521">    xmpData.add(Exiv2::XmpKey(key), &amp;tvm);</a>
<a name="ln2522"> </a>
<a name="ln2523">    int32_t mask_type = sqlite3_column_int(stmt, 2);</a>
<a name="ln2524">    snprintf(val, sizeof(val), &quot;%d&quot;, mask_type);</a>
<a name="ln2525">    tvm.read(val);</a>
<a name="ln2526">    snprintf(key, sizeof(key), &quot;Xmp.darktable.mask_type[%d]&quot;, num);</a>
<a name="ln2527">    xmpData.add(Exiv2::XmpKey(key), &amp;tvm);</a>
<a name="ln2528"> </a>
<a name="ln2529">    const char *mask_name = (const char *)sqlite3_column_text(stmt, 3);</a>
<a name="ln2530">    tvm.read(mask_name);</a>
<a name="ln2531">    snprintf(key, sizeof(key), &quot;Xmp.darktable.mask_name[%d]&quot;, num);</a>
<a name="ln2532">    xmpData.add(Exiv2::XmpKey(key), &amp;tvm);</a>
<a name="ln2533"> </a>
<a name="ln2534">    int32_t mask_version = sqlite3_column_int(stmt, 4);</a>
<a name="ln2535">    snprintf(val, sizeof(val), &quot;%d&quot;, mask_version);</a>
<a name="ln2536">    tvm.read(val);</a>
<a name="ln2537">    snprintf(key, sizeof(key), &quot;Xmp.darktable.mask_version[%d]&quot;, num);</a>
<a name="ln2538">    xmpData.add(Exiv2::XmpKey(key), &amp;tvm);</a>
<a name="ln2539"> </a>
<a name="ln2540">    int32_t len = sqlite3_column_bytes(stmt, 5);</a>
<a name="ln2541">    char *mask_d = dt_exif_xmp_encode((const unsigned char *)sqlite3_column_blob(stmt, 5), len, NULL);</a>
<a name="ln2542">    tvm.read(mask_d);</a>
<a name="ln2543">    snprintf(key, sizeof(key), &quot;Xmp.darktable.mask[%d]&quot;, num);</a>
<a name="ln2544">    xmpData.add(Exiv2::XmpKey(key), &amp;tvm);</a>
<a name="ln2545">    free(mask_d);</a>
<a name="ln2546"> </a>
<a name="ln2547">    int32_t mask_nb = sqlite3_column_int(stmt, 6);</a>
<a name="ln2548">    snprintf(val, sizeof(val), &quot;%d&quot;, mask_nb);</a>
<a name="ln2549">    tvm.read(val);</a>
<a name="ln2550">    snprintf(key, sizeof(key), &quot;Xmp.darktable.mask_nb[%d]&quot;, num);</a>
<a name="ln2551">    xmpData.add(Exiv2::XmpKey(key), &amp;tvm);</a>
<a name="ln2552"> </a>
<a name="ln2553">    len = sqlite3_column_bytes(stmt, 7);</a>
<a name="ln2554">    char *mask_src = dt_exif_xmp_encode((const unsigned char *)sqlite3_column_blob(stmt, 7), len, NULL);</a>
<a name="ln2555">    tvm.read(mask_src);</a>
<a name="ln2556">    snprintf(key, sizeof(key), &quot;Xmp.darktable.mask_src[%d]&quot;, num);</a>
<a name="ln2557">    xmpData.add(Exiv2::XmpKey(key), &amp;tvm);</a>
<a name="ln2558">    free(mask_src);</a>
<a name="ln2559"> </a>
<a name="ln2560">    num++;</a>
<a name="ln2561">  }</a>
<a name="ln2562">  sqlite3_finalize(stmt);</a>
<a name="ln2563"> </a>
<a name="ln2564"> </a>
<a name="ln2565">  // history stack:</a>
<a name="ln2566">  num = 1;</a>
<a name="ln2567"> </a>
<a name="ln2568">  // create an array:</a>
<a name="ln2569">  Exiv2::XmpTextValue tv(&quot;&quot;);</a>
<a name="ln2570">  tv.setXmpArrayType(Exiv2::XmpValue::xaSeq);</a>
<a name="ln2571">  xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.history&quot;), &amp;tv);</a>
<a name="ln2572"> </a>
<a name="ln2573">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln2574">      dt_database_get(darktable.db),</a>
<a name="ln2575">      &quot;SELECT module, operation, op_params, enabled, blendop_params, &quot;</a>
<a name="ln2576">      &quot;blendop_version, multi_priority, multi_name FROM main.history WHERE imgid = ?1 ORDER BY num&quot;,</a>
<a name="ln2577">      -1, &amp;stmt, NULL);</a>
<a name="ln2578">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2579">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2580">  {</a>
<a name="ln2581">    int32_t modversion = sqlite3_column_int(stmt, 0);</a>
<a name="ln2582">    const char *operation = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln2583">    int32_t params_len = sqlite3_column_bytes(stmt, 2);</a>
<a name="ln2584">    const void *params_blob = sqlite3_column_blob(stmt, 2);</a>
<a name="ln2585">    int32_t enabled = sqlite3_column_int(stmt, 3);</a>
<a name="ln2586">    const void *blendop_blob = sqlite3_column_blob(stmt, 4);</a>
<a name="ln2587">    int32_t blendop_params_len = sqlite3_column_bytes(stmt, 4);</a>
<a name="ln2588">    int32_t blendop_version = sqlite3_column_int(stmt, 5);</a>
<a name="ln2589">    int32_t multi_priority = sqlite3_column_int(stmt, 6);</a>
<a name="ln2590">    const char *multi_name = (const char *)sqlite3_column_text(stmt, 7);</a>
<a name="ln2591"> </a>
<a name="ln2592">    if(!operation) continue; // no op is fatal.</a>
<a name="ln2593"> </a>
<a name="ln2594">    char *params = dt_exif_xmp_encode((const unsigned char *)params_blob, params_len, NULL);</a>
<a name="ln2595"> </a>
<a name="ln2596">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:operation&quot;, num);</a>
<a name="ln2597">    xmpData[key] = operation;</a>
<a name="ln2598">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:enabled&quot;, num);</a>
<a name="ln2599">    xmpData[key] = enabled;</a>
<a name="ln2600">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:modversion&quot;, num);</a>
<a name="ln2601">    xmpData[key] = modversion;</a>
<a name="ln2602">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:params&quot;, num);</a>
<a name="ln2603">    xmpData[key] = params;</a>
<a name="ln2604">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:multi_name&quot;, num);</a>
<a name="ln2605">    xmpData[key] = multi_name ? multi_name : &quot;&quot;;</a>
<a name="ln2606">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:multi_priority&quot;, num);</a>
<a name="ln2607">    xmpData[key] = multi_priority;</a>
<a name="ln2608">    if(blendop_blob)</a>
<a name="ln2609">    {</a>
<a name="ln2610">      // this shouldn't fail in general, but reading is robust enough to allow it,</a>
<a name="ln2611">      // and flipping images from LT will result in this being left out</a>
<a name="ln2612">      char *blendop_params = dt_exif_xmp_encode((const unsigned char *)blendop_blob, blendop_params_len, NULL);</a>
<a name="ln2613">      snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:blendop_version&quot;, num);</a>
<a name="ln2614">      xmpData[key] = blendop_version;</a>
<a name="ln2615">      snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:blendop_params&quot;, num);</a>
<a name="ln2616">      xmpData[key] = blendop_params;</a>
<a name="ln2617">      free(blendop_params);</a>
<a name="ln2618">    }</a>
<a name="ln2619"> </a>
<a name="ln2620">    free(params);</a>
<a name="ln2621"> </a>
<a name="ln2622">    num++;</a>
<a name="ln2623">  }</a>
<a name="ln2624"> </a>
<a name="ln2625">  if(history_end == -1) history_end = num - 1;</a>
<a name="ln2626">  else history_end = MIN(history_end, num - 1); // safeguard for some old buggy libraries</a>
<a name="ln2627">  xmpData[&quot;Xmp.darktable.history_end&quot;] = history_end;</a>
<a name="ln2628"> </a>
<a name="ln2629">  sqlite3_finalize(stmt);</a>
<a name="ln2630">  g_list_free_full(tags, g_free);</a>
<a name="ln2631">  g_list_free_full(hierarchical, g_free);</a>
<a name="ln2632">}</a>
<a name="ln2633"> </a>
<a name="ln2634">#if EXIV2_VERSION &gt;= EXIV2_MAKE_VERSION(0,27,0)</a>
<a name="ln2635">#define ERROR_CODE(a) (static_cast&lt;Exiv2::ErrorCode&gt;((a)))</a>
<a name="ln2636">#else</a>
<a name="ln2637">#define ERROR_CODE(a) (a)</a>
<a name="ln2638">#endif</a>
<a name="ln2639"> </a>
<a name="ln2640">char *dt_exif_xmp_read_string(const int imgid)</a>
<a name="ln2641">{</a>
<a name="ln2642">  try</a>
<a name="ln2643">  {</a>
<a name="ln2644">    char input_filename[PATH_MAX] = { 0 };</a>
<a name="ln2645">    gboolean from_cache = FALSE;</a>
<a name="ln2646">    dt_image_full_path(imgid, input_filename, sizeof(input_filename), &amp;from_cache);</a>
<a name="ln2647"> </a>
<a name="ln2648">    // first take over the data from the source image</a>
<a name="ln2649">    Exiv2::XmpData xmpData;</a>
<a name="ln2650">    if(g_file_test(input_filename, G_FILE_TEST_EXISTS))</a>
<a name="ln2651">    {</a>
<a name="ln2652">      std::string xmpPacket;</a>
<a name="ln2653"> </a>
<a name="ln2654">      Exiv2::DataBuf buf = Exiv2::readFile(WIDEN(input_filename));</a>
<a name="ln2655">      xmpPacket.assign(reinterpret_cast&lt;char *&gt;(buf.pData_), buf.size_);</a>
<a name="ln2656">      Exiv2::XmpParser::decode(xmpData, xmpPacket);</a>
<a name="ln2657">      // because XmpSeq or XmpBag are added to the list, we first have</a>
<a name="ln2658">      // to remove these so that we don't end up with a string of duplicates</a>
<a name="ln2659">      dt_remove_known_keys(xmpData);</a>
<a name="ln2660">    }</a>
<a name="ln2661"> </a>
<a name="ln2662">    // now add whatever we have in the sidecar XMP. this overwrites stuff from the source image</a>
<a name="ln2663">    dt_image_path_append_version(imgid, input_filename, sizeof(input_filename));</a>
<a name="ln2664">    g_strlcat(input_filename, &quot;.xmp&quot;, sizeof(input_filename));</a>
<a name="ln2665">    if(g_file_test(input_filename, G_FILE_TEST_EXISTS))</a>
<a name="ln2666">    {</a>
<a name="ln2667">      Exiv2::XmpData sidecarXmpData;</a>
<a name="ln2668">      std::string xmpPacket;</a>
<a name="ln2669"> </a>
<a name="ln2670">      Exiv2::DataBuf buf = Exiv2::readFile(WIDEN(input_filename));</a>
<a name="ln2671">      xmpPacket.assign(reinterpret_cast&lt;char *&gt;(buf.pData_), buf.size_);</a>
<a name="ln2672">      Exiv2::XmpParser::decode(sidecarXmpData, xmpPacket);</a>
<a name="ln2673"> </a>
<a name="ln2674">      for(Exiv2::XmpData::const_iterator it = sidecarXmpData.begin(); it != sidecarXmpData.end(); ++it)</a>
<a name="ln2675">        xmpData.add(*it);</a>
<a name="ln2676">    }</a>
<a name="ln2677"> </a>
<a name="ln2678">    dt_remove_known_keys(xmpData); // is this needed?</a>
<a name="ln2679"> </a>
<a name="ln2680">    // last but not least attach what we have in DB to the XMP. in theory that should be</a>
<a name="ln2681">    // the same as what we just copied over from the sidecar file, but you never know ...</a>
<a name="ln2682">    dt_exif_xmp_read_data(xmpData, imgid);</a>
<a name="ln2683"> </a>
<a name="ln2684">    // serialize the xmp data and output the xmp packet</a>
<a name="ln2685">    std::string xmpPacket;</a>
<a name="ln2686">    if(Exiv2::XmpParser::encode(xmpPacket, xmpData,</a>
<a name="ln2687">      Exiv2::XmpParser::useCompactFormat | Exiv2::XmpParser::omitPacketWrapper) != 0)</a>
<a name="ln2688">    {</a>
<a name="ln2689">      throw Exiv2::Error(ERROR_CODE(1), &quot;[xmp_write] failed to serialize xmp data&quot;);</a>
<a name="ln2690">    }</a>
<a name="ln2691">    return g_strdup(xmpPacket.c_str());</a>
<a name="ln2692">  }</a>
<a name="ln2693">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln2694">  {</a>
<a name="ln2695">    std::cerr &lt;&lt; &quot;[xmp_read_blob] caught exiv2 exception '&quot; &lt;&lt; e &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln2696">    return NULL;</a>
<a name="ln2697">  }</a>
<a name="ln2698">}</a>
<a name="ln2699"> </a>
<a name="ln2700">int dt_exif_xmp_attach(const int imgid, const char *filename)</a>
<a name="ln2701">{</a>
<a name="ln2702">  try</a>
<a name="ln2703">  {</a>
<a name="ln2704">    char input_filename[PATH_MAX] = { 0 };</a>
<a name="ln2705">    gboolean from_cache = TRUE;</a>
<a name="ln2706">    dt_image_full_path(imgid, input_filename, sizeof(input_filename), &amp;from_cache);</a>
<a name="ln2707"> </a>
<a name="ln2708">    std::unique_ptr&lt;Exiv2::Image&gt; img(Exiv2::ImageFactory::open(WIDEN(filename)));</a>
<a name="ln2709">    // unfortunately it seems we have to read the metadata, to not erase the exif (which we just wrote).</a>
<a name="ln2710">    // will make export slightly slower, oh well.</a>
<a name="ln2711">    // img-&gt;clearXmpPacket();</a>
<a name="ln2712">    read_metadata_threadsafe(img);</a>
<a name="ln2713"> </a>
<a name="ln2714">    try</a>
<a name="ln2715">    {</a>
<a name="ln2716">      // initialize XMP and IPTC data with the one from the original file</a>
<a name="ln2717">      std::unique_ptr&lt;Exiv2::Image&gt; input_image(Exiv2::ImageFactory::open(WIDEN(input_filename)));</a>
<a name="ln2718">      if(input_image.get() != 0)</a>
<a name="ln2719">      {</a>
<a name="ln2720">        read_metadata_threadsafe(input_image);</a>
<a name="ln2721">        img-&gt;setIptcData(input_image-&gt;iptcData());</a>
<a name="ln2722">        img-&gt;setXmpData(input_image-&gt;xmpData());</a>
<a name="ln2723">      }</a>
<a name="ln2724">    }</a>
<a name="ln2725">    catch(Exiv2::AnyError &amp;e)</a>
<a name="ln2726">    {</a>
<a name="ln2727">      std::cerr &lt;&lt; &quot;[xmp_attach] &quot; &lt;&lt; input_filename &lt;&lt; &quot;: caught exiv2 exception '&quot; &lt;&lt; e &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln2728">    }</a>
<a name="ln2729"> </a>
<a name="ln2730">    Exiv2::XmpData &amp;xmpData = img-&gt;xmpData();</a>
<a name="ln2731"> </a>
<a name="ln2732">    // now add whatever we have in the sidecar XMP. this overwrites stuff from the source image</a>
<a name="ln2733">    dt_image_path_append_version(imgid, input_filename, sizeof(input_filename));</a>
<a name="ln2734">    g_strlcat(input_filename, &quot;.xmp&quot;, sizeof(input_filename));</a>
<a name="ln2735">    if(g_file_test(input_filename, G_FILE_TEST_EXISTS))</a>
<a name="ln2736">    {</a>
<a name="ln2737">      Exiv2::XmpData sidecarXmpData;</a>
<a name="ln2738">      std::string xmpPacket;</a>
<a name="ln2739"> </a>
<a name="ln2740">      Exiv2::DataBuf buf = Exiv2::readFile(WIDEN(input_filename));</a>
<a name="ln2741">      xmpPacket.assign(reinterpret_cast&lt;char *&gt;(buf.pData_), buf.size_);</a>
<a name="ln2742">      Exiv2::XmpParser::decode(sidecarXmpData, xmpPacket);</a>
<a name="ln2743"> </a>
<a name="ln2744">      for(Exiv2::XmpData::const_iterator it = sidecarXmpData.begin(); it != sidecarXmpData.end(); ++it)</a>
<a name="ln2745">        xmpData.add(*it);</a>
<a name="ln2746">    }</a>
<a name="ln2747"> </a>
<a name="ln2748">    dt_remove_known_keys(xmpData); // is this needed?</a>
<a name="ln2749"> </a>
<a name="ln2750">    {</a>
<a name="ln2751">      // We also want to make sure to not have some tags that might</a>
<a name="ln2752">      // have come in from XMP files created by digikam or similar</a>
<a name="ln2753">      static const char *keys[] = {</a>
<a name="ln2754">        &quot;Xmp.tiff.Orientation&quot;</a>
<a name="ln2755">      };</a>
<a name="ln2756">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln2757">      dt_remove_xmp_keys(xmpData, keys, n_keys);</a>
<a name="ln2758">    }</a>
<a name="ln2759"> </a>
<a name="ln2760">    // last but not least attach what we have in DB to the XMP. in theory that should be</a>
<a name="ln2761">    // the same as what we just copied over from the sidecar file, but you never know ...</a>
<a name="ln2762">    dt_exif_xmp_read_data(xmpData, imgid);</a>
<a name="ln2763"> </a>
<a name="ln2764">    img-&gt;writeMetadata();</a>
<a name="ln2765">    return 0;</a>
<a name="ln2766">  }</a>
<a name="ln2767">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln2768">  {</a>
<a name="ln2769">    std::cerr &lt;&lt; &quot;[xmp_attach] &quot; &lt;&lt; filename &lt;&lt; &quot;: caught exiv2 exception '&quot; &lt;&lt; e &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln2770">    return -1;</a>
<a name="ln2771">  }</a>
<a name="ln2772">}</a>
<a name="ln2773"> </a>
<a name="ln2774">// write xmp sidecar file:</a>
<a name="ln2775">int dt_exif_xmp_write(const int imgid, const char *filename)</a>
<a name="ln2776">{</a>
<a name="ln2777">  // refuse to write sidecar for non-existent image:</a>
<a name="ln2778">  char imgfname[PATH_MAX] = { 0 };</a>
<a name="ln2779">  gboolean from_cache = TRUE;</a>
<a name="ln2780"> </a>
<a name="ln2781">  dt_image_full_path(imgid, imgfname, sizeof(imgfname), &amp;from_cache);</a>
<a name="ln2782">  if(!g_file_test(imgfname, G_FILE_TEST_IS_REGULAR)) return 1;</a>
<a name="ln2783"> </a>
<a name="ln2784">  try</a>
<a name="ln2785">  {</a>
<a name="ln2786">    Exiv2::XmpData xmpData;</a>
<a name="ln2787">    std::string xmpPacket;</a>
<a name="ln2788">    char *checksum_old = NULL;</a>
<a name="ln2789">    if(g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln2790">    {</a>
<a name="ln2791">      // we want to avoid writing the sidecar file if it didn't change to avoid issues when using the same images</a>
<a name="ln2792">      // from different computers. sample use case: images on NAS, several computers using them NOT AT THE SAME TIME and</a>
<a name="ln2793">      // the xmp crawler is used to find changed sidecars.</a>
<a name="ln2794">      FILE *fd = g_fopen(filename, &quot;rb&quot;);</a>
<a name="ln2795">      if(fd)</a>
<a name="ln2796">      {</a>
<a name="ln2797">        fseek(fd, 0, SEEK_END);</a>
<a name="ln2798">        size_t end = ftell(fd);</a>
<a name="ln2799">        rewind(fd);</a>
<a name="ln2800">        unsigned char *content = (unsigned char *)malloc(end * sizeof(char));</a>
<a name="ln2801">        if(content)</a>
<a name="ln2802">        {</a>
<a name="ln2803">          if(fread(content, sizeof(unsigned char), end, fd) == end)</a>
<a name="ln2804">            checksum_old = g_compute_checksum_for_data(G_CHECKSUM_MD5, content, end);</a>
<a name="ln2805">          free(content);</a>
<a name="ln2806">        }</a>
<a name="ln2807">        fclose(fd);</a>
<a name="ln2808">      }</a>
<a name="ln2809"> </a>
<a name="ln2810">      Exiv2::DataBuf buf = Exiv2::readFile(WIDEN(filename));</a>
<a name="ln2811">      xmpPacket.assign(reinterpret_cast&lt;char *&gt;(buf.pData_), buf.size_);</a>
<a name="ln2812">      Exiv2::XmpParser::decode(xmpData, xmpPacket);</a>
<a name="ln2813">      // because XmpSeq or XmpBag are added to the list, we first have</a>
<a name="ln2814">      // to remove these so that we don't end up with a string of duplicates</a>
<a name="ln2815">      dt_remove_known_keys(xmpData);</a>
<a name="ln2816">    }</a>
<a name="ln2817"> </a>
<a name="ln2818">    // initialize xmp data:</a>
<a name="ln2819">    dt_exif_xmp_read_data(xmpData, imgid);</a>
<a name="ln2820"> </a>
<a name="ln2821">    // serialize the xmp data and output the xmp packet</a>
<a name="ln2822">    if(Exiv2::XmpParser::encode(xmpPacket, xmpData,</a>
<a name="ln2823">       Exiv2::XmpParser::useCompactFormat | Exiv2::XmpParser::omitPacketWrapper) != 0)</a>
<a name="ln2824">    {</a>
<a name="ln2825">      throw Exiv2::Error(ERROR_CODE(1), &quot;[xmp_write] failed to serialize xmp data&quot;);</a>
<a name="ln2826">    }</a>
<a name="ln2827"> </a>
<a name="ln2828">    // hash the new data and compare it to the old hash (if applicable)</a>
<a name="ln2829">    const char *xml_header = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;;</a>
<a name="ln2830">    gboolean write_sidecar = TRUE;</a>
<a name="ln2831">    if(checksum_old)</a>
<a name="ln2832">    {</a>
<a name="ln2833">      GChecksum *checksum = g_checksum_new(G_CHECKSUM_MD5);</a>
<a name="ln2834">      if(checksum)</a>
<a name="ln2835">      {</a>
<a name="ln2836">        g_checksum_update(checksum, (unsigned char*)xml_header, -1);</a>
<a name="ln2837">        g_checksum_update(checksum, (unsigned char*)xmpPacket.c_str(), -1);</a>
<a name="ln2838">        const char *checksum_new = g_checksum_get_string(checksum);</a>
<a name="ln2839">        write_sidecar = g_strcmp0(checksum_old, checksum_new) != 0;</a>
<a name="ln2840">        g_checksum_free(checksum);</a>
<a name="ln2841">      }</a>
<a name="ln2842">      g_free(checksum_old);</a>
<a name="ln2843">    }</a>
<a name="ln2844"> </a>
<a name="ln2845">    if(write_sidecar)</a>
<a name="ln2846">    {</a>
<a name="ln2847">      // using std::ofstream isn't possible here -- on Windows it doesn't support Unicode filenames with mingw</a>
<a name="ln2848">      FILE *fout = g_fopen(filename, &quot;wb&quot;);</a>
<a name="ln2849">      if(fout)</a>
<a name="ln2850">      {</a>
<a name="ln2851">        fprintf(fout, &quot;%s&quot;, xml_header);</a>
<a name="ln2852">        fprintf(fout, &quot;%s&quot;, xmpPacket.c_str());</a>
<a name="ln2853">        fclose(fout);</a>
<a name="ln2854">      }</a>
<a name="ln2855">    }</a>
<a name="ln2856"> </a>
<a name="ln2857">    return 0;</a>
<a name="ln2858">  }</a>
<a name="ln2859">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln2860">  {</a>
<a name="ln2861">    std::cerr &lt;&lt; &quot;[xmp_write] &quot; &lt;&lt; filename &lt;&lt; &quot;: caught exiv2 exception '&quot; &lt;&lt; e &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln2862">    return -1;</a>
<a name="ln2863">  }</a>
<a name="ln2864">}</a>
<a name="ln2865"> </a>
<a name="ln2866">dt_colorspaces_color_profile_type_t dt_exif_get_color_space(const uint8_t *data, size_t size)</a>
<a name="ln2867">{</a>
<a name="ln2868">  try</a>
<a name="ln2869">  {</a>
<a name="ln2870">    Exiv2::ExifData::const_iterator pos;</a>
<a name="ln2871">    Exiv2::ExifData exifData;</a>
<a name="ln2872">    Exiv2::ExifParser::decode(exifData, data, size);</a>
<a name="ln2873"> </a>
<a name="ln2874">    // 0x01   -&gt; sRGB</a>
<a name="ln2875">    // 0x02   -&gt; AdobeRGB</a>
<a name="ln2876">    // 0xffff -&gt; Uncalibrated</a>
<a name="ln2877">    //          + Exif.Iop.InteroperabilityIndex of 'R03' -&gt; AdobeRGB</a>
<a name="ln2878">    //          + Exif.Iop.InteroperabilityIndex of 'R98' -&gt; sRGB</a>
<a name="ln2879">    if((pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.Photo.ColorSpace&quot;))) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln2880">    {</a>
<a name="ln2881">      int colorspace = pos-&gt;toLong();</a>
<a name="ln2882">      if(colorspace == 0x01)</a>
<a name="ln2883">        return DT_COLORSPACE_SRGB;</a>
<a name="ln2884">      else if(colorspace == 0x02)</a>
<a name="ln2885">        return DT_COLORSPACE_ADOBERGB;</a>
<a name="ln2886">      else if(colorspace == 0xffff)</a>
<a name="ln2887">      {</a>
<a name="ln2888">        if((pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.Iop.InteroperabilityIndex&quot;))) != exifData.end()</a>
<a name="ln2889">          &amp;&amp; pos-&gt;size())</a>
<a name="ln2890">        {</a>
<a name="ln2891">          std::string interop_index = pos-&gt;toString();</a>
<a name="ln2892">          if(interop_index == &quot;R03&quot;)</a>
<a name="ln2893">            return DT_COLORSPACE_ADOBERGB;</a>
<a name="ln2894">          else if(interop_index == &quot;R98&quot;)</a>
<a name="ln2895">            return DT_COLORSPACE_SRGB;</a>
<a name="ln2896">        }</a>
<a name="ln2897">      }</a>
<a name="ln2898">    }</a>
<a name="ln2899"> </a>
<a name="ln2900">    return DT_COLORSPACE_DISPLAY; // nothing embedded</a>
<a name="ln2901">  }</a>
<a name="ln2902">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln2903">  {</a>
<a name="ln2904">    std::string s(e.what());</a>
<a name="ln2905">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln2906">    return DT_COLORSPACE_DISPLAY;</a>
<a name="ln2907">  }</a>
<a name="ln2908">}</a>
<a name="ln2909"> </a>
<a name="ln2910">gboolean dt_exif_get_datetime_taken(const uint8_t *data, size_t size, time_t *datetime_taken)</a>
<a name="ln2911">{</a>
<a name="ln2912">  try</a>
<a name="ln2913">  {</a>
<a name="ln2914">    Exiv2::ExifData::const_iterator pos;</a>
<a name="ln2915">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(data, size));</a>
<a name="ln2916">    read_metadata_threadsafe(image);</a>
<a name="ln2917">    Exiv2::ExifData &amp;exifData = image-&gt;exifData();</a>
<a name="ln2918"> </a>
<a name="ln2919">    char exif_datetime_taken[20];</a>
<a name="ln2920">    _find_datetime_taken(exifData, pos, exif_datetime_taken);</a>
<a name="ln2921"> </a>
<a name="ln2922">    if(*exif_datetime_taken)</a>
<a name="ln2923">    {</a>
<a name="ln2924">      struct tm exif_tm= {0};</a>
<a name="ln2925">      if(sscanf(exif_datetime_taken,&quot;%d:%d:%d %d:%d:%d&quot;,</a>
<a name="ln2926">        &amp;exif_tm.tm_year,</a>
<a name="ln2927">        &amp;exif_tm.tm_mon,</a>
<a name="ln2928">        &amp;exif_tm.tm_mday,</a>
<a name="ln2929">        &amp;exif_tm.tm_hour,</a>
<a name="ln2930">        &amp;exif_tm.tm_min,</a>
<a name="ln2931">        &amp;exif_tm.tm_sec) == 6)</a>
<a name="ln2932">      {</a>
<a name="ln2933">        exif_tm.tm_year -= 1900;</a>
<a name="ln2934">        exif_tm.tm_mon--;</a>
<a name="ln2935">        *datetime_taken = mktime(&amp;exif_tm);</a>
<a name="ln2936">        return TRUE;</a>
<a name="ln2937">      }</a>
<a name="ln2938">    }</a>
<a name="ln2939"> </a>
<a name="ln2940">    return FALSE;</a>
<a name="ln2941">  }</a>
<a name="ln2942">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln2943">  {</a>
<a name="ln2944">    std::string s(e.what());</a>
<a name="ln2945">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln2946">    return FALSE;</a>
<a name="ln2947">  }</a>
<a name="ln2948">}</a>
<a name="ln2949"> </a>
<a name="ln2950">static void dt_exif_log_handler(int log_level, const char *message)</a>
<a name="ln2951">{</a>
<a name="ln2952">  if(log_level &gt;= Exiv2::LogMsg::level())</a>
<a name="ln2953">  {</a>
<a name="ln2954">    // We don't seem to need \n in the format string as exiv2 includes it</a>
<a name="ln2955">    // in the messages themselves</a>
<a name="ln2956">    dt_print(DT_DEBUG_CAMERA_SUPPORT, &quot;[exiv2] %s&quot;, message);</a>
<a name="ln2957">  }</a>
<a name="ln2958">}</a>
<a name="ln2959"> </a>
<a name="ln2960">void dt_exif_init()</a>
<a name="ln2961">{</a>
<a name="ln2962">  // preface the exiv2 messages with &quot;[exiv2] &quot;</a>
<a name="ln2963">  Exiv2::LogMsg::setHandler(&amp;dt_exif_log_handler);</a>
<a name="ln2964"> </a>
<a name="ln2965">  Exiv2::XmpParser::initialize();</a>
<a name="ln2966">  // this has to stay with the old url (namespace already propagated outside dt)</a>
<a name="ln2967">  Exiv2::XmpProperties::registerNs(&quot;http://darktable.sf.net/&quot;, &quot;darktable&quot;);</a>
<a name="ln2968">  Exiv2::XmpProperties::registerNs(&quot;http://ns.adobe.com/lightroom/1.0/&quot;, &quot;lr&quot;);</a>
<a name="ln2969">  Exiv2::XmpProperties::registerNs(&quot;http://cipa.jp/exif/1.0/&quot;, &quot;exifEX&quot;);</a>
<a name="ln2970">}</a>
<a name="ln2971"> </a>
<a name="ln2972">void dt_exif_cleanup()</a>
<a name="ln2973">{</a>
<a name="ln2974">  Exiv2::XmpParser::terminate();</a>
<a name="ln2975">}</a>
<a name="ln2976"> </a>
<a name="ln2977">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2978">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2979">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="222"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 222, 220.</p></div>
<div class="balloon" rel="235"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 235, 233.</p></div>
<div class="balloon" rel="248"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 248, 246.</p></div>
<div class="balloon" rel="261"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 261, 259.</p></div>
<div class="balloon" rel="274"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 274, 272.</p></div>
<div class="balloon" rel="354"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 354, 352.</p></div>
<div class="balloon" rel="377"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strchr' function. Inspect the first argument. Check lines: 377, 367.</p></div>
<div class="balloon" rel="1486"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'compress' function. Inspect the first argument. Check lines: 1486, 1484.</p></div>
<div class="balloon" rel="1571"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The 'output' pointer was assigned values twice without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1789"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v583/" target="_blank">V583</a> The '?:' operator, regardless of its conditional expression, always returns one and the same value.</p></div>
<div class="balloon" rel="1832"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'current_entry'. Check lines: 1832, 1831.</p></div>
<div class="balloon" rel="1916"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_length' function. Inspect the first argument.</p></div>
<div class="balloon" rel="1920"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'current_entry'. Check lines: 1920, 1919.</p></div>
<div class="balloon" rel="2029"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'entry'. Check lines: 2029, 2027.</p></div>
<div class="balloon" rel="2032"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'mask_name_str.c_str() != __null' is always true.</p></div>
<div class="balloon" rel="2630"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="2631"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="2920"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized iterator 'pos' used. Consider checking the second actual argument of the '_find_datetime_taken' function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
