
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;control/control.h&quot;</a>
<a name="ln24">#include &quot;develop/develop.h&quot;</a>
<a name="ln25">#include &quot;develop/imageop.h&quot;</a>
<a name="ln26">#include &quot;gui/draw.h&quot;</a>
<a name="ln27">#include &quot;gui/gtk.h&quot;</a>
<a name="ln28">#include &quot;gui/presets.h&quot;</a>
<a name="ln29">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln30">#include &lt;assert.h&gt;</a>
<a name="ln31">#include &lt;math.h&gt;</a>
<a name="ln32">#include &lt;stdlib.h&gt;</a>
<a name="ln33">#include &lt;string.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;iop/equalizer_eaw.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">// #define DT_GUI_EQUALIZER_INSET 5</a>
<a name="ln38">// #define DT_GUI_CURVE_INFL .3f</a>
<a name="ln39"> </a>
<a name="ln40">DT_MODULE_INTROSPECTION(1, dt_iop_equalizer_params_t)</a>
<a name="ln41"> </a>
<a name="ln42"> </a>
<a name="ln43">#define DT_IOP_EQUALIZER_RES 64</a>
<a name="ln44">#define DT_IOP_EQUALIZER_BANDS 6</a>
<a name="ln45">#define DT_IOP_EQUALIZER_MAX_LEVEL 6</a>
<a name="ln46"> </a>
<a name="ln47">typedef struct dt_iop_equalizer_params_t</a>
<a name="ln48">{</a>
<a name="ln49">  float equalizer_x[3][DT_IOP_EQUALIZER_BANDS], equalizer_y[3][DT_IOP_EQUALIZER_BANDS];</a>
<a name="ln50">} dt_iop_equalizer_params_t;</a>
<a name="ln51"> </a>
<a name="ln52">typedef enum dt_iop_equalizer_channel_t</a>
<a name="ln53">{</a>
<a name="ln54">  DT_IOP_EQUALIZER_L = 0,</a>
<a name="ln55">  DT_IOP_EQUALIZER_a = 1,</a>
<a name="ln56">  DT_IOP_EQUALIZER_b = 2</a>
<a name="ln57">} dt_iop_equalizer_channel_t;</a>
<a name="ln58"> </a>
<a name="ln59">typedef struct dt_iop_equalizer_gui_data_t</a>
<a name="ln60">{</a>
<a name="ln61">  dt_draw_curve_t *minmax_curve; // curve for gui to draw</a>
<a name="ln62">  GtkBox *hbox;</a>
<a name="ln63">  GtkDrawingArea *area;</a>
<a name="ln64">  GtkComboBox *presets;</a>
<a name="ln65">  GtkRadioButton *channel_button[3];</a>
<a name="ln66">  double mouse_x, mouse_y, mouse_pick;</a>
<a name="ln67">  float mouse_radius;</a>
<a name="ln68">  dt_iop_equalizer_params_t drag_params;</a>
<a name="ln69">  int dragging;</a>
<a name="ln70">  int x_move;</a>
<a name="ln71">  dt_iop_equalizer_channel_t channel;</a>
<a name="ln72">  float draw_xs[DT_IOP_EQUALIZER_RES], draw_ys[DT_IOP_EQUALIZER_RES];</a>
<a name="ln73">  float draw_min_xs[DT_IOP_EQUALIZER_RES], draw_min_ys[DT_IOP_EQUALIZER_RES];</a>
<a name="ln74">  float draw_max_xs[DT_IOP_EQUALIZER_RES], draw_max_ys[DT_IOP_EQUALIZER_RES];</a>
<a name="ln75">  float band_hist[DT_IOP_EQUALIZER_BANDS];</a>
<a name="ln76">  float band_max;</a>
<a name="ln77">} dt_iop_equalizer_gui_data_t;</a>
<a name="ln78"> </a>
<a name="ln79">typedef struct dt_iop_equalizer_data_t</a>
<a name="ln80">{</a>
<a name="ln81">  dt_draw_curve_t *curve[3];</a>
<a name="ln82">  int num_levels;</a>
<a name="ln83">} dt_iop_equalizer_data_t;</a>
<a name="ln84"> </a>
<a name="ln85"> </a>
<a name="ln86">const char *name()</a>
<a name="ln87">{</a>
<a name="ln88">  return _(&quot;legacy equalizer&quot;);</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">int default_group()</a>
<a name="ln93">{</a>
<a name="ln94">  return IOP_GROUP_CORRECT;</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">int flags()</a>
<a name="ln98">{</a>
<a name="ln99">  return IOP_FLAGS_DEPRECATED;</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102"> </a>
<a name="ln103"> </a>
<a name="ln104">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln105">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln106">{</a>
<a name="ln107">  const int chs = piece-&gt;colors;</a>
<a name="ln108">  const int width = roi_in-&gt;width, height = roi_in-&gt;height;</a>
<a name="ln109">  const float scale = roi_in-&gt;scale;</a>
<a name="ln110">  memcpy(ovoid, ivoid, (size_t)chs * sizeof(float) * width * height);</a>
<a name="ln111">#if 1</a>
<a name="ln112">  // printf(&quot;thread %d starting equalizer&quot;, (int)pthread_self());</a>
<a name="ln113">  // if(piece-&gt;iscale != 1.0) printf(&quot; for preview\n&quot;);</a>
<a name="ln114">  // else printf(&quot;\n&quot;);</a>
<a name="ln115">  dt_iop_equalizer_data_t *d = (dt_iop_equalizer_data_t *)(piece-&gt;data);</a>
<a name="ln116">  // dt_iop_equalizer_gui_data_t *c = (dt_iop_equalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln117"> </a>
<a name="ln118">  // 1 pixel in this buffer represents 1.0/scale pixels in original image:</a>
<a name="ln119">  const float l1 = 1.0f + dt_log2f(piece-&gt;iscale / scale); // finest level</a>
<a name="ln120">  float lm = 0;</a>
<a name="ln121">  for(int k = MIN(width, height) * piece-&gt;iscale / scale; k; k &gt;&gt;= 1) lm++; // coarsest level</a>
<a name="ln122">  lm = MIN(DT_IOP_EQUALIZER_MAX_LEVEL, l1 + lm);</a>
<a name="ln123">  // level 1 =&gt; full resolution</a>
<a name="ln124">  int numl = 0;</a>
<a name="ln125">  for(int k = MIN(width, height); k; k &gt;&gt;= 1) numl++;</a>
<a name="ln126">  const int numl_cap = MIN(DT_IOP_EQUALIZER_MAX_LEVEL - l1 + 1.5, numl);</a>
<a name="ln127">  // printf(&quot;level range in %d %d: %f %f, cap: %d\n&quot;, 1, d-&gt;num_levels, l1, lm, numl_cap);</a>
<a name="ln128"> </a>
<a name="ln129">  // TODO: fixed alloc for data piece at capped resolution?</a>
<a name="ln130">  float **tmp = (float **)calloc(numl_cap, sizeof(float *));</a>
<a name="ln131">  for(int k = 1; k &lt; numl_cap; k++)</a>
<a name="ln132">  {</a>
<a name="ln133">    const int wd = (int)(1 + (width &gt;&gt; (k - 1))), ht = (int)(1 + (height &gt;&gt; (k - 1)));</a>
<a name="ln134">    tmp[k] = (float *)malloc((size_t)sizeof(float) * wd * ht);</a>
<a name="ln135">  }</a>
<a name="ln136"> </a>
<a name="ln137">  for(int level = 1; level &lt; numl_cap; level++) dt_iop_equalizer_wtf(ovoid, tmp, level, width, height);</a>
<a name="ln138"> </a>
<a name="ln139">#if 0</a>
<a name="ln140">  // printf(&quot;transformed\n&quot;);</a>
<a name="ln141">  // store luma wavelet histogram for later drawing</a>
<a name="ln142">  if(self-&gt;dev-&gt;gui_attached &amp;&amp; piece-&gt;iscale == 1.0 &amp;&amp; self-&gt;dev-&gt;preview_pipe &amp;&amp; c) // 1.0 =&gt; full pipe, only for gui applications.</a>
<a name="ln143">  {</a>
<a name="ln144">    float *out = (float *)ovoid;</a>
<a name="ln145">    // chose full pipe and current window.</a>
<a name="ln146">    int cnt[DT_IOP_EQUALIZER_BANDS];</a>
<a name="ln147">    for(int i=0; i&lt;DT_IOP_EQUALIZER_BANDS; i++) cnt[i] = 0;</a>
<a name="ln148">    for(int l=1; l&lt;numl_cap; l++)</a>
<a name="ln149">    {</a>
<a name="ln150">      const float lv = (lm-l1)*(l-1)/(float)(numl_cap-1) + l1; // appr level in real image.</a>
<a name="ln151">      const int band = CLAMP(.5f + (1.0 - lv / d-&gt;num_levels) * (DT_IOP_EQUALIZER_BANDS), 0, DT_IOP_EQUALIZER_BANDS);</a>
<a name="ln152">      c-&gt;band_hist[band] = 0.0f;</a>
<a name="ln153">      cnt[band]++;</a>
<a name="ln154">      int ch = (int)c-&gt;channel;</a>
<a name="ln155">      {</a>
<a name="ln156">        const int step = 1&lt;&lt;l;</a>
<a name="ln157">        for(int j=0; j&lt;height; j+=step)      for(int i=step/2; i&lt;width; i+=step) c-&gt;band_hist[band] += out[chs*width*j + chs*i + ch]*out[chs*width*j + chs*i + ch];</a>
<a name="ln158">        for(int j=step/2; j&lt;height; j+=step) for(int i=0; i&lt;width; i+=step)      c-&gt;band_hist[band] += out[chs*width*j + chs*i + ch]*out[chs*width*j + chs*i + ch];</a>
<a name="ln159">        for(int j=step/2; j&lt;height; j+=step) for(int i=step/2; i&lt;width; i+=step) c-&gt;band_hist[band] += out[chs*width*j + chs*i + ch]*out[chs*width*j + chs*i + ch]*.5f;</a>
<a name="ln160">      }</a>
<a name="ln161">    }</a>
<a name="ln162">    c-&gt;band_max = 0.0f;</a>
<a name="ln163">    for(int i=0; i&lt;DT_IOP_EQUALIZER_BANDS; i++)</a>
<a name="ln164">    {</a>
<a name="ln165">      if(cnt[i]) c-&gt;band_hist[i] /= cnt[i];</a>
<a name="ln166">      else c-&gt;band_hist[i] = 0.0;</a>
<a name="ln167">      c-&gt;band_max = fmaxf(c-&gt;band_max, c-&gt;band_hist[i]);</a>
<a name="ln168">      // printf(&quot;band %d = %f\n&quot;, i, c-&gt;band_hist[i]);</a>
<a name="ln169">    }</a>
<a name="ln170">  }</a>
<a name="ln171">#endif</a>
<a name="ln172">  // printf(&quot;histogrammed\n&quot;);</a>
<a name="ln173"> </a>
<a name="ln174">  for(int l = 1; l &lt; numl_cap; l++)</a>
<a name="ln175">  {</a>
<a name="ln176">    float *out = (float *)ovoid;</a>
<a name="ln177">    const float lv = (lm - l1) * (l - 1) / (float)(numl_cap - 1) + l1; // appr level in real image.</a>
<a name="ln178">    const float band = CLAMP((1.0 - lv / d-&gt;num_levels), 0, 1.0);</a>
<a name="ln179">    for(int ch = 0; ch &lt; 3; ch++)</a>
<a name="ln180">    {</a>
<a name="ln181">      // coefficients in range [0, 2], 1 being neutral.</a>
<a name="ln182">      const float coeff = 2 * dt_draw_curve_calc_value(d-&gt;curve[ch == 0 ? 0 : 1], band);</a>
<a name="ln183">      const int step = 1 &lt;&lt; l;</a>
<a name="ln184">#if 1 // scale coefficients</a>
<a name="ln185">      for(int j = 0; j &lt; height; j += step)</a>
<a name="ln186">        for(int i = step / 2; i &lt; width; i += step) out[(size_t)chs * width * j + chs * i + ch] *= coeff;</a>
<a name="ln187">      for(int j = step / 2; j &lt; height; j += step)</a>
<a name="ln188">        for(int i = 0; i &lt; width; i += step) out[(size_t)chs * width * j + chs * i + ch] *= coeff;</a>
<a name="ln189">      for(int j = step / 2; j &lt; height; j += step)</a>
<a name="ln190">        for(int i = step / 2; i &lt; width; i += step)</a>
<a name="ln191">          out[(size_t)chs * width * j + chs * i + ch] *= coeff * coeff;</a>
<a name="ln192">#else // soft-thresholding (shrinkage)</a>
<a name="ln193">#define wshrink                                                                                              \</a>
<a name="ln194">  (copysignf(fmaxf(0.0f, fabsf(out[(size_t)chs * width * j + chs * i + ch]) - (1.0 - coeff)),                \</a>
<a name="ln195">             out[(size_t)chs * width * j + chs * i + ch]))</a>
<a name="ln196">      for(int j = 0; j &lt; height; j += step)</a>
<a name="ln197">        for(int i = step / 2; i &lt; width; i += step) out[(size_t)chs * width * j + chs * i + ch] = wshrink;</a>
<a name="ln198">      for(int j = step / 2; j &lt; height; j += step)</a>
<a name="ln199">        for(int i = 0; i &lt; width; i += step) out[(size_t)chs * width * j + chs * i + ch] = wshrink;</a>
<a name="ln200">      for(int j = step / 2; j &lt; height; j += step)</a>
<a name="ln201">        for(int i = step / 2; i &lt; width; i += step) out[(size_t)chs * width * j + chs * i + ch] = wshrink;</a>
<a name="ln202">#undef wshrink</a>
<a name="ln203">#endif</a>
<a name="ln204">    }</a>
<a name="ln205">  }</a>
<a name="ln206">  // printf(&quot;applied\n&quot;);</a>
<a name="ln207">  for(int level = numl_cap - 1; level &gt; 0; level--) dt_iop_equalizer_iwtf(ovoid, tmp, level, width, height);</a>
<a name="ln208"> </a>
<a name="ln209">  for(int k = 1; k &lt; numl_cap; k++) free(tmp[k]);</a>
<a name="ln210">  free(tmp);</a>
<a name="ln211">// printf(&quot;thread %d finished equalizer&quot;, (int)pthread_self());</a>
<a name="ln212">// if(piece-&gt;iscale != 1.0) printf(&quot; for preview\n&quot;);</a>
<a name="ln213">// else printf(&quot;\n&quot;);</a>
<a name="ln214">#endif</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln218">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln219">{</a>
<a name="ln220">  // pull in new params to pipe</a>
<a name="ln221">  dt_iop_equalizer_data_t *d = (dt_iop_equalizer_data_t *)(piece-&gt;data);</a>
<a name="ln222">  dt_iop_equalizer_params_t *p = (dt_iop_equalizer_params_t *)p1;</a>
<a name="ln223"> </a>
<a name="ln224">  for(int ch = 0; ch &lt; 3; ch++)</a>
<a name="ln225">    for(int k = 0; k &lt; DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln226">      dt_draw_curve_set_point(d-&gt;curve[ch], k, p-&gt;equalizer_x[ch][k], p-&gt;equalizer_y[ch][k]);</a>
<a name="ln227">  int l = 0;</a>
<a name="ln228">  for(int k = (int)MIN(pipe-&gt;iwidth * pipe-&gt;iscale, pipe-&gt;iheight * pipe-&gt;iscale); k; k &gt;&gt;= 1) l++;</a>
<a name="ln229">  d-&gt;num_levels = MIN(DT_IOP_EQUALIZER_MAX_LEVEL, l);</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln233">{</a>
<a name="ln234">  // create part of the pixelpipe</a>
<a name="ln235">  dt_iop_equalizer_data_t *d = (dt_iop_equalizer_data_t *)malloc(sizeof(dt_iop_equalizer_data_t));</a>
<a name="ln236">  dt_iop_equalizer_params_t *default_params = (dt_iop_equalizer_params_t *)self-&gt;default_params;</a>
<a name="ln237">  piece-&gt;data = (void *)d;</a>
<a name="ln238">  for(int ch = 0; ch &lt; 3; ch++)</a>
<a name="ln239">  {</a>
<a name="ln240">    d-&gt;curve[ch] = dt_draw_curve_new(0.0, 1.0, CATMULL_ROM);</a>
<a name="ln241">    for(int k = 0; k &lt; DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln242">      (void)dt_draw_curve_add_point(d-&gt;curve[ch], default_params-&gt;equalizer_x[ch][k],</a>
<a name="ln243">                                    default_params-&gt;equalizer_y[ch][k]);</a>
<a name="ln244">  }</a>
<a name="ln245">  int l = 0;</a>
<a name="ln246">  for(int k = (int)MIN(pipe-&gt;iwidth * pipe-&gt;iscale, pipe-&gt;iheight * pipe-&gt;iscale); k; k &gt;&gt;= 1) l++;</a>
<a name="ln247">  d-&gt;num_levels = MIN(DT_IOP_EQUALIZER_MAX_LEVEL, l);</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln251">{</a>
<a name="ln252">// clean up everything again.</a>
<a name="ln253">  dt_iop_equalizer_data_t *d = (dt_iop_equalizer_data_t *)(piece-&gt;data);</a>
<a name="ln254">  for(int ch = 0; ch &lt; 3; ch++) dt_draw_curve_destroy(d-&gt;curve[ch]);</a>
<a name="ln255">  free(piece-&gt;data);</a>
<a name="ln256">  piece-&gt;data = NULL;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln260">{</a>
<a name="ln261">  // nothing to do, gui curve is read directly from params during expose event.</a>
<a name="ln262">  // gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">void init(dt_iop_module_t *module)</a>
<a name="ln266">{</a>
<a name="ln267">  module-&gt;params = calloc(1, sizeof(dt_iop_equalizer_params_t));</a>
<a name="ln268">  module-&gt;default_params = calloc(1, sizeof(dt_iop_equalizer_params_t));</a>
<a name="ln269">  module-&gt;default_enabled = 0; // we're a rather slow and rare op.</a>
<a name="ln270">  module-&gt;priority = 428; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln271">  module-&gt;params_size = sizeof(dt_iop_equalizer_params_t);</a>
<a name="ln272">  module-&gt;gui_data = NULL;</a>
<a name="ln273">  dt_iop_equalizer_params_t tmp;</a>
<a name="ln274">  for(int ch = 0; ch &lt; 3; ch++)</a>
<a name="ln275">  {</a>
<a name="ln276">    for(int k = 0; k &lt; DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln277">      tmp.equalizer_x[ch][k] = k / (float)(DT_IOP_EQUALIZER_BANDS - 1);</a>
<a name="ln278">    for(int k = 0; k &lt; DT_IOP_EQUALIZER_BANDS; k++) tmp.equalizer_y[ch][k] = 0.5f;</a>
<a name="ln279">  }</a>
<a name="ln280">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_equalizer_params_t));</a>
<a name="ln281">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_equalizer_params_t));</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">void cleanup(dt_iop_module_t *module)</a>
<a name="ln285">{</a>
<a name="ln286">  free(module-&gt;params);</a>
<a name="ln287">  module-&gt;params = NULL;</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">#if 0</a>
<a name="ln291">void init_presets (dt_iop_module_so_t *self)</a>
<a name="ln292">{</a>
<a name="ln293">  DT_DEBUG_SQLITE3_EXEC(darktable.db, &quot;begin&quot;, NULL, NULL, NULL);</a>
<a name="ln294">  dt_iop_equalizer_params_t p;</a>
<a name="ln295"> </a>
<a name="ln296">  for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln297">  {</a>
<a name="ln298">    p.equalizer_x[DT_IOP_EQUALIZER_L][k] = k/(DT_IOP_EQUALIZER_BANDS-1.0);</a>
<a name="ln299">    p.equalizer_x[DT_IOP_EQUALIZER_a][k] = k/(DT_IOP_EQUALIZER_BANDS-1.0);</a>
<a name="ln300">    p.equalizer_x[DT_IOP_EQUALIZER_b][k] = k/(DT_IOP_EQUALIZER_BANDS-1.0);</a>
<a name="ln301">    p.equalizer_y[DT_IOP_EQUALIZER_L][k] = .5f+.5f*k/(float)DT_IOP_EQUALIZER_BANDS;</a>
<a name="ln302">    p.equalizer_y[DT_IOP_EQUALIZER_a][k] = .5f;</a>
<a name="ln303">    p.equalizer_y[DT_IOP_EQUALIZER_b][k] = .5f;</a>
<a name="ln304">  }</a>
<a name="ln305">  dt_gui_presets_add_generic(_(&quot;sharpen (strong)&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln306">  for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln307">  {</a>
<a name="ln308">    p.equalizer_x[DT_IOP_EQUALIZER_L][k] = k/(DT_IOP_EQUALIZER_BANDS-1.0);</a>
<a name="ln309">    p.equalizer_x[DT_IOP_EQUALIZER_a][k] = k/(DT_IOP_EQUALIZER_BANDS-1.0);</a>
<a name="ln310">    p.equalizer_x[DT_IOP_EQUALIZER_b][k] = k/(DT_IOP_EQUALIZER_BANDS-1.0);</a>
<a name="ln311">    p.equalizer_y[DT_IOP_EQUALIZER_L][k] = .5f+.25f*k/(float)DT_IOP_EQUALIZER_BANDS;</a>
<a name="ln312">    p.equalizer_y[DT_IOP_EQUALIZER_a][k] = .5f;</a>
<a name="ln313">    p.equalizer_y[DT_IOP_EQUALIZER_b][k] = .5f;</a>
<a name="ln314">  }</a>
<a name="ln315">  dt_gui_presets_add_generic(C_(&quot;equalizer&quot;, &quot;sharpen&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln316">  for(int ch=0; ch&lt;3; ch++)</a>
<a name="ln317">  {</a>
<a name="ln318">    for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++) p.equalizer_x[ch][k] = k/(float)(DT_IOP_EQUALIZER_BANDS-1);</a>
<a name="ln319">    for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++) p.equalizer_y[ch][k] = 0.5f;</a>
<a name="ln320">  }</a>
<a name="ln321">  dt_gui_presets_add_generic(_(&quot;null&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln322">  for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln323">  {</a>
<a name="ln324">    p.equalizer_x[DT_IOP_EQUALIZER_L][k] = k/(DT_IOP_EQUALIZER_BANDS-1.0);</a>
<a name="ln325">    p.equalizer_x[DT_IOP_EQUALIZER_a][k] = k/(DT_IOP_EQUALIZER_BANDS-1.0);</a>
<a name="ln326">    p.equalizer_x[DT_IOP_EQUALIZER_b][k] = k/(DT_IOP_EQUALIZER_BANDS-1.0);</a>
<a name="ln327">    p.equalizer_y[DT_IOP_EQUALIZER_L][k] = .5f-.2f*k/(float)DT_IOP_EQUALIZER_BANDS;</a>
<a name="ln328">    p.equalizer_y[DT_IOP_EQUALIZER_a][k] = fmaxf(0.0f, .5f-.3f*k/(float)DT_IOP_EQUALIZER_BANDS);</a>
<a name="ln329">    p.equalizer_y[DT_IOP_EQUALIZER_b][k] = fmaxf(0.0f, .5f-.3f*k/(float)DT_IOP_EQUALIZER_BANDS);</a>
<a name="ln330">  }</a>
<a name="ln331">  dt_gui_presets_add_generic(_(&quot;denoise&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln332">  for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln333">  {</a>
<a name="ln334">    p.equalizer_x[DT_IOP_EQUALIZER_L][k] = k/(DT_IOP_EQUALIZER_BANDS-1.0);</a>
<a name="ln335">    p.equalizer_x[DT_IOP_EQUALIZER_a][k] = k/(DT_IOP_EQUALIZER_BANDS-1.0);</a>
<a name="ln336">    p.equalizer_x[DT_IOP_EQUALIZER_b][k] = k/(DT_IOP_EQUALIZER_BANDS-1.0);</a>
<a name="ln337">    p.equalizer_y[DT_IOP_EQUALIZER_L][k] = .5f-.4f*k/(float)DT_IOP_EQUALIZER_BANDS;</a>
<a name="ln338">    p.equalizer_y[DT_IOP_EQUALIZER_a][k] = fmaxf(0.0f, .5f-.6f*k/(float)DT_IOP_EQUALIZER_BANDS);</a>
<a name="ln339">    p.equalizer_y[DT_IOP_EQUALIZER_b][k] = fmaxf(0.0f, .5f-.6f*k/(float)DT_IOP_EQUALIZER_BANDS);</a>
<a name="ln340">  }</a>
<a name="ln341">  dt_gui_presets_add_generic(_(&quot;denoise (strong)&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln342">  DT_DEBUG_SQLITE3_EXEC(darktable.db, &quot;commit&quot;, NULL, NULL, NULL);</a>
<a name="ln343">}</a>
<a name="ln344">#endif</a>
<a name="ln345"> </a>
<a name="ln346">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln347">{</a>
<a name="ln348">  self-&gt;gui_data = malloc(sizeof(dt_iop_equalizer_gui_data_t));</a>
<a name="ln349">  self-&gt;widget = gtk_label_new(_(&quot;this module will be removed in the future\nand is only here so you can &quot;</a>
<a name="ln350">                                 &quot;switch it off\nand move to the new equalizer.&quot;));</a>
<a name="ln351">  gtk_widget_set_halign(self-&gt;widget, GTK_ALIGN_START);</a>
<a name="ln352"> </a>
<a name="ln353">#if 0</a>
<a name="ln354">  dt_iop_equalizer_gui_data_t *c = (dt_iop_equalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln355">  dt_iop_equalizer_params_t *p = (dt_iop_equalizer_params_t *)self-&gt;params;</a>
<a name="ln356"> </a>
<a name="ln357">  c-&gt;band_max = 0;</a>
<a name="ln358">  c-&gt;channel = DT_IOP_EQUALIZER_L;</a>
<a name="ln359">  int ch = (int)c-&gt;channel;</a>
<a name="ln360">  c-&gt;minmax_curve = dt_draw_curve_new(0.0, 1.0, HERMITE_SPLINE);</a>
<a name="ln361">  for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++) (void)dt_draw_curve_add_point(c-&gt;minmax_curve, p-&gt;equalizer_x[ch][k], p-&gt;equalizer_y[ch][k]);</a>
<a name="ln362">  c-&gt;mouse_x = c-&gt;mouse_y = c-&gt;mouse_pick = -1.0;</a>
<a name="ln363">  c-&gt;dragging = 0;</a>
<a name="ln364">  c-&gt;x_move = -1;</a>
<a name="ln365">  c-&gt;mouse_radius = 1.0/DT_IOP_EQUALIZER_BANDS;</a>
<a name="ln366"> </a>
<a name="ln367">  self-&gt;widget = GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));</a>
<a name="ln368">  c-&gt;area = GTK_DRAWING_AREA(gtk_drawing_area_new());</a>
<a name="ln369">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(c-&gt;area), TRUE, TRUE, 0);</a>
<a name="ln370">  gtk_widget_set_size_request(GTK_WIDGET(c-&gt;area), 195, 195);</a>
<a name="ln371"> </a>
<a name="ln372">  gtk_widget_add_events(GTK_WIDGET(c-&gt;area), GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_LEAVE_NOTIFY_MASK | darktable.gui.scroll_mask);</a>
<a name="ln373">  g_signal_connect (G_OBJECT (c-&gt;area), &quot;draw&quot;,</a>
<a name="ln374">                    G_CALLBACK (dt_iop_equalizer_expose), self);</a>
<a name="ln375">  g_signal_connect (G_OBJECT (c-&gt;area), &quot;button-press-event&quot;,</a>
<a name="ln376">                    G_CALLBACK (dt_iop_equalizer_button_press), self);</a>
<a name="ln377">  g_signal_connect (G_OBJECT (c-&gt;area), &quot;button-release-event&quot;,</a>
<a name="ln378">                    G_CALLBACK (dt_iop_equalizer_button_release), self);</a>
<a name="ln379">  g_signal_connect (G_OBJECT (c-&gt;area), &quot;motion-notify-event&quot;,</a>
<a name="ln380">                    G_CALLBACK (dt_iop_equalizer_motion_notify), self);</a>
<a name="ln381">  g_signal_connect (G_OBJECT (c-&gt;area), &quot;leave-notify-event&quot;,</a>
<a name="ln382">                    G_CALLBACK (dt_iop_equalizer_leave_notify), self);</a>
<a name="ln383">  g_signal_connect (G_OBJECT (c-&gt;area), &quot;scroll-event&quot;,</a>
<a name="ln384">                    G_CALLBACK (dt_iop_equalizer_scrolled), self);</a>
<a name="ln385">  // init gtk stuff</a>
<a name="ln386">  c-&gt;hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln387">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(c-&gt;hbox), FALSE, FALSE, 0);</a>
<a name="ln388"> </a>
<a name="ln389">  c-&gt;channel_button[0] = GTK_RADIO_BUTTON(gtk_radio_button_new_with_label(NULL, _(&quot;luma&quot;)));</a>
<a name="ln390">  c-&gt;channel_button[1] = GTK_RADIO_BUTTON(gtk_radio_button_new_with_label_from_widget(c-&gt;channel_button[0], _(&quot;chroma&quot;)));</a>
<a name="ln391">  // c-&gt;channel_button[2] = GTK_RADIO_BUTTON(gtk_radio_button_new_with_label_from_widget(c-&gt;channel_button[0], &quot;b&quot;));</a>
<a name="ln392"> </a>
<a name="ln393">  g_signal_connect (G_OBJECT (c-&gt;channel_button[0]), &quot;toggled&quot;,</a>
<a name="ln394">                    G_CALLBACK (dt_iop_equalizer_button_toggled), self);</a>
<a name="ln395">  g_signal_connect (G_OBJECT (c-&gt;channel_button[1]), &quot;toggled&quot;,</a>
<a name="ln396">                    G_CALLBACK (dt_iop_equalizer_button_toggled), self);</a>
<a name="ln397">  // g_signal_connect (G_OBJECT (c-&gt;channel_button[2]), &quot;toggled&quot;,</a>
<a name="ln398">  //                   G_CALLBACK (dt_iop_equalizer_button_toggled), self);</a>
<a name="ln399"> </a>
<a name="ln400">  // gtk_box_pack_end(GTK_BOX(c-&gt;hbox), GTK_WIDGET(c-&gt;channel_button[2]), FALSE, FALSE, 5);</a>
<a name="ln401">  gtk_box_pack_end(GTK_BOX(c-&gt;hbox), GTK_WIDGET(c-&gt;channel_button[1]), FALSE, FALSE, 5);</a>
<a name="ln402">  gtk_box_pack_end(GTK_BOX(c-&gt;hbox), GTK_WIDGET(c-&gt;channel_button[0]), FALSE, FALSE, 5);</a>
<a name="ln403">#endif</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln407">{</a>
<a name="ln408">  free(self-&gt;gui_data);</a>
<a name="ln409">  self-&gt;gui_data = NULL;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">#if 0</a>
<a name="ln413">static gboolean dt_iop_equalizer_leave_notify(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln414">{</a>
<a name="ln415">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln416">  dt_iop_equalizer_gui_data_t *c = (dt_iop_equalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln417">  // c-&gt;mouse_radius = 1.0/DT_IOP_EQUALIZER_BANDS;</a>
<a name="ln418">  if(!c-&gt;dragging) c-&gt;mouse_x = c-&gt;mouse_y = -1.0;</a>
<a name="ln419">  gtk_widget_queue_draw(widget);</a>
<a name="ln420">  return TRUE;</a>
<a name="ln421">}</a>
<a name="ln422"> </a>
<a name="ln423">// fills in new parameters based on mouse position (in 0,1)</a>
<a name="ln424">static void dt_iop_equalizer_get_params(dt_iop_equalizer_params_t *p, const int ch, const double mouse_x, const double mouse_y, const float rad)</a>
<a name="ln425">{</a>
<a name="ln426">  for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln427">  {</a>
<a name="ln428">    const float f = expf(-(mouse_x - p-&gt;equalizer_x[ch][k])*(mouse_x - p-&gt;equalizer_x[ch][k])/(rad*rad));</a>
<a name="ln429">    p-&gt;equalizer_y[ch][k] = (1-f)*p-&gt;equalizer_y[ch][k] + f*mouse_y;</a>
<a name="ln430">  }</a>
<a name="ln431">}</a>
<a name="ln432"> </a>
<a name="ln433">static gboolean dt_iop_equalizer_expose(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln434">{</a>
<a name="ln435">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln436">  dt_iop_equalizer_gui_data_t *c = (dt_iop_equalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln437">  dt_iop_equalizer_params_t p = *(dt_iop_equalizer_params_t *)self-&gt;params;</a>
<a name="ln438">  int ch = (int)c-&gt;channel;</a>
<a name="ln439">  for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++) dt_draw_curve_set_point(c-&gt;minmax_curve, k, p.equalizer_x[ch][k], p.equalizer_y[ch][k]);</a>
<a name="ln440">  const int inset = DT_GUI_EQUALIZER_INSET;</a>
<a name="ln441">  int width = allocation.width, height = allocation.height;</a>
<a name="ln442">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln443">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln444">  // clear bg</a>
<a name="ln445">  cairo_set_source_rgb (cr, .2, .2, .2);</a>
<a name="ln446">  cairo_paint(cr);</a>
<a name="ln447"> </a>
<a name="ln448">  cairo_translate(cr, inset, inset);</a>
<a name="ln449">  width -= 2*inset;</a>
<a name="ln450">  height -= 2*inset;</a>
<a name="ln451"> </a>
<a name="ln452">  cairo_set_line_width(cr, 1.0);</a>
<a name="ln453">  cairo_set_source_rgb (cr, .1, .1, .1);</a>
<a name="ln454">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln455">  cairo_stroke(cr);</a>
<a name="ln456"> </a>
<a name="ln457">  cairo_set_source_rgb (cr, .3, .3, .3);</a>
<a name="ln458">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln459">  cairo_fill(cr);</a>
<a name="ln460"> </a>
<a name="ln461">  if(c-&gt;mouse_y &gt; 0 || c-&gt;dragging)</a>
<a name="ln462">  {</a>
<a name="ln463">    // draw min/max curves:</a>
<a name="ln464">    dt_iop_equalizer_get_params(&amp;p, c-&gt;channel, c-&gt;mouse_x, 1., c-&gt;mouse_radius);</a>
<a name="ln465">    for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln466">      dt_draw_curve_set_point(c-&gt;minmax_curve, k, p.equalizer_x[ch][k], p.equalizer_y[ch][k]);</a>
<a name="ln467">    dt_draw_curve_calc_values(c-&gt;minmax_curve, 0.0, 1.0, DT_IOP_EQUALIZER_RES, c-&gt;draw_min_xs, c-&gt;draw_min_ys);</a>
<a name="ln468"> </a>
<a name="ln469">    p = *(dt_iop_equalizer_params_t *)self-&gt;params;</a>
<a name="ln470">    dt_iop_equalizer_get_params(&amp;p, c-&gt;channel, c-&gt;mouse_x, .0, c-&gt;mouse_radius);</a>
<a name="ln471">    for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln472">      dt_draw_curve_set_point(c-&gt;minmax_curve, k, p.equalizer_x[ch][k], p.equalizer_y[ch][k]);</a>
<a name="ln473">    dt_draw_curve_calc_values(c-&gt;minmax_curve, 0.0, 1.0, DT_IOP_EQUALIZER_RES, c-&gt;draw_max_xs, c-&gt;draw_max_ys);</a>
<a name="ln474">  }</a>
<a name="ln475"> </a>
<a name="ln476">  // draw grid</a>
<a name="ln477">  cairo_set_line_width(cr, .4);</a>
<a name="ln478">  cairo_set_source_rgb (cr, .1, .1, .1);</a>
<a name="ln479">  dt_draw_grid(cr, 8, 0, 0, width, height);</a>
<a name="ln480"> </a>
<a name="ln481">  // draw x positions</a>
<a name="ln482">  cairo_set_line_width(cr, 1.);</a>
<a name="ln483">  cairo_set_source_rgb(cr, 0.6, 0.6, 0.6);</a>
<a name="ln484">  const float arrw = 7.0f;</a>
<a name="ln485">  for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln486">  {</a>
<a name="ln487">    cairo_move_to(cr, width*p.equalizer_x[c-&gt;channel][k], height+inset-1);</a>
<a name="ln488">    cairo_rel_line_to(cr, -arrw*.5f, 0);</a>
<a name="ln489">    cairo_rel_line_to(cr, arrw*.5f, -arrw);</a>
<a name="ln490">    cairo_rel_line_to(cr, arrw*.5f, arrw);</a>
<a name="ln491">    cairo_close_path(cr);</a>
<a name="ln492">    if(c-&gt;x_move == k) cairo_fill(cr);</a>
<a name="ln493">    else               cairo_stroke(cr);</a>
<a name="ln494">  }</a>
<a name="ln495"> </a>
<a name="ln496">  // draw selected cursor</a>
<a name="ln497">  cairo_set_line_width(cr, 1.);</a>
<a name="ln498">  cairo_translate(cr, 0, height);</a>
<a name="ln499"> </a>
<a name="ln500">  // draw frequency histogram in bg.</a>
<a name="ln501">#if 1</a>
<a name="ln502">  if(c-&gt;band_max &gt; 0)</a>
<a name="ln503">  {</a>
<a name="ln504">    cairo_save(cr);</a>
<a name="ln505">    cairo_scale(cr, width/(DT_IOP_EQUALIZER_BANDS-1.0), -(height-5)/c-&gt;band_max);</a>
<a name="ln506">    cairo_set_source_rgba(cr, .2, .2, .2, 0.5);</a>
<a name="ln507">    cairo_move_to(cr, 0, 0);</a>
<a name="ln508">    for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++) cairo_line_to(cr, k, c-&gt;band_hist[k]);</a>
<a name="ln509">    cairo_line_to(cr, DT_IOP_EQUALIZER_BANDS-1.0, 0.);</a>
<a name="ln510">    cairo_close_path(cr);</a>
<a name="ln511">    cairo_fill(cr);</a>
<a name="ln512">    cairo_restore(cr);</a>
<a name="ln513">  }</a>
<a name="ln514">#endif</a>
<a name="ln515"> </a>
<a name="ln516">  // cairo_set_operator(cr, CAIRO_OPERATOR_ADD);</a>
<a name="ln517">  cairo_set_operator(cr, CAIRO_OPERATOR_OVER);</a>
<a name="ln518">  cairo_set_line_width(cr, 2.);</a>
<a name="ln519">  for(int i=0; i&lt;3; i++)</a>
<a name="ln520">  {</a>
<a name="ln521">    // draw curves, selected last.</a>
<a name="ln522">    int ch = ((int)c-&gt;channel+i+1)%3;</a>
<a name="ln523">    if(ch == 2) continue;</a>
<a name="ln524">    switch(ch)</a>
<a name="ln525">    {</a>
<a name="ln526">      case DT_IOP_EQUALIZER_L:</a>
<a name="ln527">        cairo_set_source_rgba(cr, .6, .6, .6, .3);</a>
<a name="ln528">        break;</a>
<a name="ln529">      case DT_IOP_EQUALIZER_a:</a>
<a name="ln530">        cairo_set_source_rgba(cr, .4, .2, .0, .4);</a>
<a name="ln531">        break;</a>
<a name="ln532">      default: //case DT_IOP_EQUALIZER_b:</a>
<a name="ln533">        cairo_set_source_rgba(cr, 0., .2, .4, .4);</a>
<a name="ln534">        break;</a>
<a name="ln535">    }</a>
<a name="ln536">    p = *(dt_iop_equalizer_params_t *)self-&gt;params;</a>
<a name="ln537">    for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln538">      dt_draw_curve_set_point(c-&gt;minmax_curve, k, p.equalizer_x[ch][k], p.equalizer_y[ch][k]);</a>
<a name="ln539">    dt_draw_curve_calc_values(c-&gt;minmax_curve, 0.0, 1.0, DT_IOP_EQUALIZER_RES, c-&gt;draw_xs, c-&gt;draw_ys);</a>
<a name="ln540">    // cairo_set_line_cap  (cr, CAIRO_LINE_CAP_SQUARE);</a>
<a name="ln541">    cairo_move_to(cr, 0, 0);</a>
<a name="ln542">    for(int k=0; k&lt;DT_IOP_EQUALIZER_RES; k++) cairo_line_to(cr, k*width/(float)(DT_IOP_EQUALIZER_RES-1), - height*c-&gt;draw_ys[k]);</a>
<a name="ln543">    cairo_line_to(cr, width, 0);</a>
<a name="ln544">    cairo_close_path(cr);</a>
<a name="ln545">    cairo_stroke_preserve(cr);</a>
<a name="ln546">    cairo_fill(cr);</a>
<a name="ln547">  }</a>
<a name="ln548"> </a>
<a name="ln549">  // draw dots on knots</a>
<a name="ln550">  cairo_save(cr);</a>
<a name="ln551">  cairo_set_source_rgb(cr, 0.7, 0.7, 0.7);</a>
<a name="ln552">  cairo_set_line_width(cr, 1.);</a>
<a name="ln553">  for(int k=0; k&lt;DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln554">  {</a>
<a name="ln555">    cairo_arc(cr, width*p.equalizer_x[c-&gt;channel][k], - height*p.equalizer_y[c-&gt;channel][k], 3.0, 0.0, 2.0*M_PI);</a>
<a name="ln556">    if(c-&gt;x_move == k) cairo_fill(cr);</a>
<a name="ln557">    else               cairo_stroke(cr);</a>
<a name="ln558">  }</a>
<a name="ln559">  cairo_restore(cr);</a>
<a name="ln560"> </a>
<a name="ln561">  if(c-&gt;mouse_y &gt; 0 || c-&gt;dragging)</a>
<a name="ln562">  {</a>
<a name="ln563">    // draw min/max, if selected</a>
<a name="ln564">    // cairo_set_source_rgba(cr, .6, .6, .6, .5);</a>
<a name="ln565">    cairo_move_to(cr, 0, - height*c-&gt;draw_min_ys[0]);</a>
<a name="ln566">    for(int k=1; k&lt;DT_IOP_EQUALIZER_RES; k++)    cairo_line_to(cr, k*width/(float)(DT_IOP_EQUALIZER_RES-1), - height*c-&gt;draw_min_ys[k]);</a>
<a name="ln567">    for(int k=DT_IOP_EQUALIZER_RES-2; k&gt;=0; k--) cairo_line_to(cr, k*width/(float)(DT_IOP_EQUALIZER_RES-1), - height*c-&gt;draw_max_ys[k]);</a>
<a name="ln568">    cairo_close_path(cr);</a>
<a name="ln569">    cairo_fill(cr);</a>
<a name="ln570">    // draw mouse focus circle</a>
<a name="ln571">    cairo_set_source_rgba(cr, .9, .9, .9, .5);</a>
<a name="ln572">    const float pos = DT_IOP_EQUALIZER_RES * c-&gt;mouse_x;</a>
<a name="ln573">    int k = (int)pos;</a>
<a name="ln574">    const float f = k - pos;</a>
<a name="ln575">    if(k &gt;= DT_IOP_EQUALIZER_RES-1) k = DT_IOP_EQUALIZER_RES - 2;</a>
<a name="ln576">    float ht = -height*(f*c-&gt;draw_ys[k] + (1-f)*c-&gt;draw_ys[k+1]);</a>
<a name="ln577">    cairo_arc(cr, c-&gt;mouse_x*width, ht, c-&gt;mouse_radius*width, 0, 2.*M_PI);</a>
<a name="ln578">    cairo_stroke(cr);</a>
<a name="ln579">  }</a>
<a name="ln580"> </a>
<a name="ln581">  cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);</a>
<a name="ln582"> </a>
<a name="ln583">  cairo_destroy(cr);</a>
<a name="ln584">  cairo_set_source_surface (crf, cst, 0, 0);</a>
<a name="ln585">  cairo_paint(crf);</a>
<a name="ln586">  cairo_surface_destroy(cst);</a>
<a name="ln587">  return TRUE;</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">static gboolean dt_iop_equalizer_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln591">{</a>
<a name="ln592">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln593">  dt_iop_equalizer_gui_data_t *c = (dt_iop_equalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln594">  dt_iop_equalizer_params_t *p = (dt_iop_equalizer_params_t *)self-&gt;params;</a>
<a name="ln595">  const int inset = DT_GUI_EQUALIZER_INSET;</a>
<a name="ln596">  int height = allocation.height - 2*inset, width = allocation.width - 2*inset;</a>
<a name="ln597">  if(!c-&gt;dragging) c-&gt;mouse_x = CLAMP(event-&gt;x - inset, 0, width)/(float)width;</a>
<a name="ln598">  c-&gt;mouse_y = 1.0 - CLAMP(event-&gt;y - inset, 0, height)/(float)height;</a>
<a name="ln599">  if(c-&gt;dragging)</a>
<a name="ln600">  {</a>
<a name="ln601">    *p = c-&gt;drag_params;</a>
<a name="ln602">    if(c-&gt;x_move &gt;= 0)</a>
<a name="ln603">    {</a>
<a name="ln604">      const float mx = CLAMP(event-&gt;x - inset, 0, width)/(float)width;</a>
<a name="ln605">      if(c-&gt;x_move &gt; 0 &amp;&amp; c-&gt;x_move &lt; DT_IOP_EQUALIZER_BANDS-1)</a>
<a name="ln606">      {</a>
<a name="ln607">        const float minx = p-&gt;equalizer_x[c-&gt;channel][c-&gt;x_move-1] + 0.001f;</a>
<a name="ln608">        const float maxx = p-&gt;equalizer_x[c-&gt;channel][c-&gt;x_move+1] - 0.001f;</a>
<a name="ln609">        p-&gt;equalizer_x[c-&gt;channel][c-&gt;x_move] = fminf(maxx, fmaxf(minx, mx));</a>
<a name="ln610">      }</a>
<a name="ln611">    }</a>
<a name="ln612">    else</a>
<a name="ln613">    {</a>
<a name="ln614">      dt_iop_equalizer_get_params(p, c-&gt;channel, c-&gt;mouse_x, c-&gt;mouse_y + c-&gt;mouse_pick, c-&gt;mouse_radius);</a>
<a name="ln615">    }</a>
<a name="ln616">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln617">  }</a>
<a name="ln618">  else if(event-&gt;y &gt; height)</a>
<a name="ln619">  {</a>
<a name="ln620">    c-&gt;x_move = 0;</a>
<a name="ln621">    float dist = fabsf(p-&gt;equalizer_x[c-&gt;channel][0] - c-&gt;mouse_x);</a>
<a name="ln622">    for(int k=1; k&lt;DT_IOP_EQUALIZER_BANDS; k++)</a>
<a name="ln623">    {</a>
<a name="ln624">      float d2 = fabsf(p-&gt;equalizer_x[c-&gt;channel][k] - c-&gt;mouse_x);</a>
<a name="ln625">      if(d2 &lt; dist)</a>
<a name="ln626">      {</a>
<a name="ln627">        c-&gt;x_move = k;</a>
<a name="ln628">        dist = d2;</a>
<a name="ln629">      }</a>
<a name="ln630">    }</a>
<a name="ln631">  }</a>
<a name="ln632">  else</a>
<a name="ln633">  {</a>
<a name="ln634">    c-&gt;x_move = -1;</a>
<a name="ln635">  }</a>
<a name="ln636">  gtk_widget_queue_draw(widget);</a>
<a name="ln637">  gint x, y;</a>
<a name="ln638">  gdk_window_get_device_position(event-&gt;window, gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gdk_window_get_display(event-&gt;window))), &amp;x, &amp;y, NULL);</a>
<a name="ln639"> </a>
<a name="ln640">  return TRUE;</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643">static gboolean dt_iop_equalizer_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln644">{</a>
<a name="ln645">  // set active point</a>
<a name="ln646">  if(event-&gt;button == 1)</a>
<a name="ln647">  {</a>
<a name="ln648">    dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln649">    dt_iop_equalizer_gui_data_t *c = (dt_iop_equalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln650">    c-&gt;drag_params = *(dt_iop_equalizer_params_t *)self-&gt;params;</a>
<a name="ln651">    const int inset = DT_GUI_EQUALIZER_INSET;</a>
<a name="ln652">    int height = allocation.height - 2*inset, width = allocation.width - 2*inset;</a>
<a name="ln653">    c-&gt;mouse_pick = dt_draw_curve_calc_value(c-&gt;minmax_curve, CLAMP(event-&gt;x - inset, 0, width)/(float)width);</a>
<a name="ln654">    c-&gt;mouse_pick -= 1.0 - CLAMP(event-&gt;y - inset, 0, height)/(float)height;</a>
<a name="ln655">    c-&gt;dragging = 1;</a>
<a name="ln656">    return TRUE;</a>
<a name="ln657">  }</a>
<a name="ln658">  return FALSE;</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661">static gboolean dt_iop_equalizer_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln662">{</a>
<a name="ln663">  if(event-&gt;button == 1)</a>
<a name="ln664">  {</a>
<a name="ln665">    dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln666">    dt_iop_equalizer_gui_data_t *c = (dt_iop_equalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln667">    c-&gt;dragging = 0;</a>
<a name="ln668">    return TRUE;</a>
<a name="ln669">  }</a>
<a name="ln670">  return FALSE;</a>
<a name="ln671">}</a>
<a name="ln672"> </a>
<a name="ln673">static gboolean dt_iop_equalizer_scrolled(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln674">{</a>
<a name="ln675">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln676">  dt_iop_equalizer_gui_data_t *c = (dt_iop_equalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln677"> </a>
<a name="ln678">  gdouble delta_y;</a>
<a name="ln679">  if(dt_gui_get_scroll_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln680">  {</a>
<a name="ln681">    c-&gt;mouse_radius = CLAMP(c-&gt;mouse_radius * (1.0 + 0.1 * delta_y), 0.25 / DT_IOP_EQUALIZER_BANDS, 1.0);</a>
<a name="ln682">    gtk_widget_queue_draw(widget);</a>
<a name="ln683">  }</a>
<a name="ln684"> </a>
<a name="ln685">  return TRUE;</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688">static void dt_iop_equalizer_button_toggled(GtkToggleButton *togglebutton, gpointer user_data)</a>
<a name="ln689">{</a>
<a name="ln690">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln691">  dt_iop_equalizer_gui_data_t *c = (dt_iop_equalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln692">  if(gtk_toggle_button_get_active(togglebutton))</a>
<a name="ln693">  {</a>
<a name="ln694">    for(int k=0; k&lt;3; k++) if(c-&gt;channel_button[k] == GTK_RADIO_BUTTON(togglebutton))</a>
<a name="ln695">      {</a>
<a name="ln696">        c-&gt;channel = (dt_iop_equalizer_channel_t)k;</a>
<a name="ln697">        gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln698">        return;</a>
<a name="ln699">      }</a>
<a name="ln700">  }</a>
<a name="ln701">}</a>
<a name="ln702">#endif</a>
<a name="ln703"> </a>
<a name="ln704">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln705">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln706">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="134"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'tmp'. Check lines: 134, 130.</p></div>
<div class="balloon" rel="240"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 240, 235.</p></div>
<div class="balloon" rel="280"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 280, 267.</p></div>
<div class="balloon" rel="281"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 281, 268.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
