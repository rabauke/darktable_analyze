
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/darktable.h&quot;</a>
<a name="ln20">#include &quot;common/debug.h&quot;</a>
<a name="ln21">#include &quot;common/styles.h&quot;</a>
<a name="ln22">#include &quot;common/undo.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;develop/develop.h&quot;</a>
<a name="ln26">#include &quot;develop/masks.h&quot;</a>
<a name="ln27">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln28">#include &quot;gui/gtk.h&quot;</a>
<a name="ln29">#include &quot;gui/styles.h&quot;</a>
<a name="ln30">#include &quot;libs/lib.h&quot;</a>
<a name="ln31">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln32">#include &quot;common/history.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">DT_MODULE(1)</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">typedef struct dt_undo_history_t</a>
<a name="ln38">{</a>
<a name="ln39">  GList *snapshot;</a>
<a name="ln40">  int end;</a>
<a name="ln41">} dt_undo_history_t;</a>
<a name="ln42"> </a>
<a name="ln43">typedef struct dt_lib_history_t</a>
<a name="ln44">{</a>
<a name="ln45">  /* vbox with managed history items */</a>
<a name="ln46">  GtkWidget *history_box;</a>
<a name="ln47">  GtkWidget *create_button;</a>
<a name="ln48">//   GtkWidget *apply_button;</a>
<a name="ln49">  GtkWidget *compress_button;</a>
<a name="ln50">  gboolean record_undo;</a>
<a name="ln51">} dt_lib_history_t;</a>
<a name="ln52"> </a>
<a name="ln53">/* compress history stack */</a>
<a name="ln54">static void _lib_history_compress_clicked_callback(GtkWidget *widget, gpointer user_data);</a>
<a name="ln55">static void _lib_history_button_clicked_callback(GtkWidget *widget, gpointer user_data);</a>
<a name="ln56">static void _lib_history_create_style_button_clicked_callback(GtkWidget *widget, gpointer user_data);</a>
<a name="ln57">/* signal callback for history change */</a>
<a name="ln58">static void _lib_history_change_callback(gpointer instance, gpointer user_data);</a>
<a name="ln59">static void _lib_history_module_remove_callback(gpointer instance, dt_iop_module_t *module, gpointer user_data);</a>
<a name="ln60"> </a>
<a name="ln61">const char *name(dt_lib_module_t *self)</a>
<a name="ln62">{</a>
<a name="ln63">  return _(&quot;history&quot;);</a>
<a name="ln64">}</a>
<a name="ln65"> </a>
<a name="ln66">const char **views(dt_lib_module_t *self)</a>
<a name="ln67">{</a>
<a name="ln68">  static const char *v[] = {&quot;darkroom&quot;, NULL};</a>
<a name="ln69">  return v;</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln73">{</a>
<a name="ln74">  return DT_UI_CONTAINER_PANEL_LEFT_CENTER;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">int position()</a>
<a name="ln78">{</a>
<a name="ln79">  return 900;</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln83">{</a>
<a name="ln84">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;create style from history&quot;), 0, 0);</a>
<a name="ln85">//   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;apply style from popup menu&quot;), 0, 0);</a>
<a name="ln86">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;compress history stack&quot;), 0, 0);</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln90">{</a>
<a name="ln91">  dt_lib_history_t *d = (dt_lib_history_t *)self-&gt;data;</a>
<a name="ln92"> </a>
<a name="ln93">  dt_accel_connect_button_lib(self, &quot;create style from history&quot;, d-&gt;create_button);</a>
<a name="ln94">//   dt_accel_connect_button_lib(self, &quot;apply style from popup menu&quot;, d-&gt;apply_button);</a>
<a name="ln95">  dt_accel_connect_button_lib(self, &quot;compress history stack&quot;, d-&gt;compress_button);</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">void gui_init(dt_lib_module_t *self)</a>
<a name="ln99">{</a>
<a name="ln100">  /* initialize ui widgets */</a>
<a name="ln101">  dt_lib_history_t *d = (dt_lib_history_t *)g_malloc0(sizeof(dt_lib_history_t));</a>
<a name="ln102">  self-&gt;data = (void *)d;</a>
<a name="ln103"> </a>
<a name="ln104">  d-&gt;record_undo = TRUE;</a>
<a name="ln105"> </a>
<a name="ln106">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln107">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln108">  gtk_widget_set_name(self-&gt;widget, &quot;history-ui&quot;);</a>
<a name="ln109">  d-&gt;history_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln110"> </a>
<a name="ln111">  GtkWidget *hhbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln112"> </a>
<a name="ln113">  d-&gt;compress_button = gtk_button_new_with_label(_(&quot;compress history stack&quot;));</a>
<a name="ln114">  gtk_label_set_xalign (GTK_LABEL(gtk_bin_get_child(GTK_BIN(d-&gt;compress_button))), 0.0f);</a>
<a name="ln115">  gtk_widget_set_tooltip_text(d-&gt;compress_button, _(&quot;create a minimal history stack which produces the same image&quot;));</a>
<a name="ln116">  g_signal_connect(G_OBJECT(d-&gt;compress_button), &quot;clicked&quot;, G_CALLBACK(_lib_history_compress_clicked_callback), NULL);</a>
<a name="ln117"> </a>
<a name="ln118">  /* add toolbar button for creating style */</a>
<a name="ln119">  d-&gt;create_button = dtgtk_button_new(dtgtk_cairo_paint_styles, CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln120">  g_signal_connect(G_OBJECT(d-&gt;create_button), &quot;clicked&quot;,</a>
<a name="ln121">                   G_CALLBACK(_lib_history_create_style_button_clicked_callback), NULL);</a>
<a name="ln122">  gtk_widget_set_tooltip_text(d-&gt;create_button, _(&quot;create a style from the current history stack&quot;));</a>
<a name="ln123"> </a>
<a name="ln124">  /* add buttons to buttonbox */</a>
<a name="ln125">  gtk_box_pack_start(GTK_BOX(hhbox), d-&gt;compress_button, TRUE, TRUE, 0);</a>
<a name="ln126">  gtk_box_pack_start(GTK_BOX(hhbox), d-&gt;create_button, FALSE, FALSE, 0);</a>
<a name="ln127"> </a>
<a name="ln128">  /* add history list and buttonbox to widget */</a>
<a name="ln129">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), d-&gt;history_box, FALSE, FALSE, 0);</a>
<a name="ln130">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), hhbox, FALSE, FALSE, 0);</a>
<a name="ln131"> </a>
<a name="ln132"> </a>
<a name="ln133">  gtk_widget_show_all(self-&gt;widget);</a>
<a name="ln134"> </a>
<a name="ln135">  /* connect to history change signal for updating the history view */</a>
<a name="ln136">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE,</a>
<a name="ln137">                            G_CALLBACK(_lib_history_change_callback), self);</a>
<a name="ln138">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_MODULE_REMOVE,</a>
<a name="ln139">                            G_CALLBACK(_lib_history_module_remove_callback), self);</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln143">{</a>
<a name="ln144">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_history_change_callback), self);</a>
<a name="ln145">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_history_module_remove_callback), self);</a>
<a name="ln146">  g_free(self-&gt;data);</a>
<a name="ln147">  self-&gt;data = NULL;</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">static GtkWidget *_lib_history_create_button(dt_lib_module_t *self, int num, const char *label,</a>
<a name="ln151">                                             gboolean enabled, gboolean selected)</a>
<a name="ln152">{</a>
<a name="ln153">  /* create label */</a>
<a name="ln154">  GtkWidget *widget = NULL;</a>
<a name="ln155">  gchar numlabel[256];</a>
<a name="ln156">  if(num == -1)</a>
<a name="ln157">    g_snprintf(numlabel, sizeof(numlabel), &quot;%d - %s&quot;, num + 1, label);</a>
<a name="ln158">  else</a>
<a name="ln159">  {</a>
<a name="ln160">    if(enabled)</a>
<a name="ln161">      g_snprintf(numlabel, sizeof(numlabel), &quot;%d - %s&quot;, num + 1, label);</a>
<a name="ln162">    else</a>
<a name="ln163">      g_snprintf(numlabel, sizeof(numlabel), &quot;%d - %s (%s)&quot;, num + 1, label, _(&quot;off&quot;));</a>
<a name="ln164">  }</a>
<a name="ln165"> </a>
<a name="ln166">  /* create toggle button */</a>
<a name="ln167">  widget = gtk_toggle_button_new_with_label(numlabel);</a>
<a name="ln168">  gtk_widget_set_halign(gtk_bin_get_child(GTK_BIN(widget)), GTK_ALIGN_START);</a>
<a name="ln169">  gtk_widget_set_name(GTK_WIDGET(widget), &quot;history-button&quot;);</a>
<a name="ln170">  g_object_set_data(G_OBJECT(widget), &quot;history_number&quot;, GINT_TO_POINTER(num + 1));</a>
<a name="ln171">  g_object_set_data(G_OBJECT(widget), &quot;label&quot;, (gpointer)label);</a>
<a name="ln172">  if(selected) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(widget), TRUE);</a>
<a name="ln173"> </a>
<a name="ln174">  /* set callback when clicked */</a>
<a name="ln175">  g_signal_connect(G_OBJECT(widget), &quot;clicked&quot;, G_CALLBACK(_lib_history_button_clicked_callback), self);</a>
<a name="ln176"> </a>
<a name="ln177">  /* associate the history number */</a>
<a name="ln178">  g_object_set_data(G_OBJECT(widget), &quot;history-number&quot;, GINT_TO_POINTER(num + 1));</a>
<a name="ln179"> </a>
<a name="ln180">  return widget;</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">static dt_iop_module_t *get_base_module(GList *iop_list, const char *op)</a>
<a name="ln184">{</a>
<a name="ln185">  dt_iop_module_t *result = NULL;</a>
<a name="ln186"> </a>
<a name="ln187">  GList *modules = g_list_first(iop_list);</a>
<a name="ln188">  while(modules)</a>
<a name="ln189">  {</a>
<a name="ln190">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln191">    if(strcmp(mod-&gt;op, op) == 0)</a>
<a name="ln192">    {</a>
<a name="ln193">      result = mod;</a>
<a name="ln194">      break;</a>
<a name="ln195">    }</a>
<a name="ln196">    modules = g_list_next(modules);</a>
<a name="ln197">  }</a>
<a name="ln198"> </a>
<a name="ln199">  return result;</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">static GList *_duplicate_history(GList *hist)</a>
<a name="ln203">{</a>
<a name="ln204">  GList *result = NULL;</a>
<a name="ln205"> </a>
<a name="ln206">  GList *h = g_list_first(hist);</a>
<a name="ln207">  while(h)</a>
<a name="ln208">  {</a>
<a name="ln209">    const dt_dev_history_item_t *old = (dt_dev_history_item_t *)(h-&gt;data);</a>
<a name="ln210"> </a>
<a name="ln211">    dt_dev_history_item_t *new = (dt_dev_history_item_t *)malloc(sizeof(dt_dev_history_item_t));</a>
<a name="ln212"> </a>
<a name="ln213">    memcpy(new, old, sizeof(dt_dev_history_item_t));</a>
<a name="ln214"> </a>
<a name="ln215">    int32_t params_size = 0;</a>
<a name="ln216">    if(old-&gt;module)</a>
<a name="ln217">    {</a>
<a name="ln218">      params_size = old-&gt;module-&gt;params_size;</a>
<a name="ln219">    }</a>
<a name="ln220">    else</a>
<a name="ln221">    {</a>
<a name="ln222">      dt_iop_module_t *base = get_base_module(darktable.develop-&gt;iop, old-&gt;op_name);</a>
<a name="ln223">      if(base)</a>
<a name="ln224">      {</a>
<a name="ln225">        params_size = base-&gt;params_size;</a>
<a name="ln226">      }</a>
<a name="ln227">      else</a>
<a name="ln228">      {</a>
<a name="ln229">        // nothing else to do</a>
<a name="ln230">        fprintf(stderr, &quot;[_duplicate_history] can't find base module for %s\n&quot;, old-&gt;op_name);</a>
<a name="ln231">      }</a>
<a name="ln232">    }</a>
<a name="ln233"> </a>
<a name="ln234">    new-&gt;params = malloc(params_size);</a>
<a name="ln235">    new-&gt;blend_params = malloc(sizeof(dt_develop_blend_params_t));</a>
<a name="ln236"> </a>
<a name="ln237">    memcpy(new-&gt;params, old-&gt;params, params_size);</a>
<a name="ln238">    memcpy(new-&gt;blend_params, old-&gt;blend_params, sizeof(dt_develop_blend_params_t));</a>
<a name="ln239"> </a>
<a name="ln240">    if(old-&gt;forms) new-&gt;forms = dt_masks_dup_forms_deep(old-&gt;forms, NULL);</a>
<a name="ln241"> </a>
<a name="ln242">    result = g_list_append(result, new);</a>
<a name="ln243"> </a>
<a name="ln244">    h = g_list_next(h);</a>
<a name="ln245">  }</a>
<a name="ln246">  return result;</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">static void _reset_module_instance(GList *hist, dt_iop_module_t *module, int multi_priority)</a>
<a name="ln250">{</a>
<a name="ln251">  while (hist)</a>
<a name="ln252">  {</a>
<a name="ln253">    dt_dev_history_item_t *hit = (dt_dev_history_item_t *)hist-&gt;data;</a>
<a name="ln254"> </a>
<a name="ln255">    if(!hit-&gt;module &amp;&amp; strcmp(hit-&gt;op_name, module-&gt;op) == 0 &amp;&amp; hit-&gt;multi_priority == multi_priority)</a>
<a name="ln256">    {</a>
<a name="ln257">      hit-&gt;module = module;</a>
<a name="ln258">    }</a>
<a name="ln259">    hist = hist-&gt;next;</a>
<a name="ln260">  }</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">struct _cb_data</a>
<a name="ln264">{</a>
<a name="ln265">  dt_iop_module_t *module;</a>
<a name="ln266">  int multi_priority;</a>
<a name="ln267">};</a>
<a name="ln268"> </a>
<a name="ln269">static void _undo_items_cb(gpointer user_data, dt_undo_type_t type, dt_undo_data_t data)</a>
<a name="ln270">{</a>
<a name="ln271">  struct _cb_data *udata = (struct _cb_data *)user_data;</a>
<a name="ln272">  dt_undo_history_t *hdata = (dt_undo_history_t *)data;</a>
<a name="ln273">  _reset_module_instance(hdata-&gt;snapshot, udata-&gt;module, udata-&gt;multi_priority);</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">static void _history_invalidate_cb(gpointer user_data, dt_undo_type_t type, dt_undo_data_t item)</a>
<a name="ln277">{</a>
<a name="ln278">  dt_iop_module_t *module = (dt_iop_module_t *)user_data;</a>
<a name="ln279">  dt_undo_history_t *hist = (dt_undo_history_t *)item;</a>
<a name="ln280">  dt_dev_invalidate_history_module(hist-&gt;snapshot, module);</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">static void _add_module_expander(GList *iop_list, dt_iop_module_t *module)</a>
<a name="ln284">{</a>
<a name="ln285">  // dt_dev_reload_history_items won't do this for base instances</a>
<a name="ln286">  // and it will call gui_init() for the rest</a>
<a name="ln287">  // so we do it here</a>
<a name="ln288">  if(!dt_iop_is_hidden(module) &amp;&amp; !module-&gt;expander)</a>
<a name="ln289">  {</a>
<a name="ln290">      /* add module to right panel */</a>
<a name="ln291">      GtkWidget *expander = dt_iop_gui_get_expander(module);</a>
<a name="ln292">      dt_ui_container_add_widget(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER, expander);</a>
<a name="ln293">      dt_iop_gui_set_expanded(module, TRUE, FALSE);</a>
<a name="ln294">      dt_iop_gui_update_blending(module);</a>
<a name="ln295">  }</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">// return the 1st history entry that matches module</a>
<a name="ln299">static dt_dev_history_item_t *_search_history_by_module(GList *history_list, dt_iop_module_t *module)</a>
<a name="ln300">{</a>
<a name="ln301">  dt_dev_history_item_t *hist_ret = NULL;</a>
<a name="ln302"> </a>
<a name="ln303">  GList *history = g_list_first(history_list);</a>
<a name="ln304">  while(history)</a>
<a name="ln305">  {</a>
<a name="ln306">    dt_dev_history_item_t *hist_item = (dt_dev_history_item_t *)history-&gt;data;</a>
<a name="ln307"> </a>
<a name="ln308">    if(hist_item-&gt;module == module)</a>
<a name="ln309">    {</a>
<a name="ln310">      hist_ret = hist_item;</a>
<a name="ln311">      break;</a>
<a name="ln312">    }</a>
<a name="ln313"> </a>
<a name="ln314">    history = g_list_next(history);</a>
<a name="ln315">  }</a>
<a name="ln316">  return hist_ret;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">static int _check_deleted_instances(dt_develop_t *dev, GList **_iop_list, GList *history_list)</a>
<a name="ln320">{</a>
<a name="ln321">  GList *iop_list = *_iop_list;</a>
<a name="ln322">  int deleted_module_found = 0;</a>
<a name="ln323"> </a>
<a name="ln324">  // we will check on dev-&gt;iop if there's a module that is not in history</a>
<a name="ln325">  GList *modules = g_list_first(iop_list);</a>
<a name="ln326">  while(modules)</a>
<a name="ln327">  {</a>
<a name="ln328">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln329"> </a>
<a name="ln330">    int delete_module = 0;</a>
<a name="ln331"> </a>
<a name="ln332">    // base modules are a special case</a>
<a name="ln333">    // most base modules won't be in history and must not be deleted</a>
<a name="ln334">    // but the user may have deleted a base instance of a multi-instance module</a>
<a name="ln335">    // and then undo and redo, so we will end up with two entries in dev-&gt;iop</a>
<a name="ln336">    // with multi_priority == 0, this can't happen and the extra one must be deleted</a>
<a name="ln337">    // dev-&gt;iop is sorted by (priority, multi_priority DESC), so if the next one is</a>
<a name="ln338">    // a base instance too, one must be deleted</a>
<a name="ln339">    if(mod-&gt;multi_priority == 0)</a>
<a name="ln340">    {</a>
<a name="ln341">      GList *modules_next = g_list_next(modules);</a>
<a name="ln342">      if(modules_next)</a>
<a name="ln343">      {</a>
<a name="ln344">        dt_iop_module_t *mod_next = (dt_iop_module_t *)modules_next-&gt;data;</a>
<a name="ln345">        if(strcmp(mod_next-&gt;op, mod-&gt;op) == 0 &amp;&amp; mod_next-&gt;multi_priority == 0)</a>
<a name="ln346">        {</a>
<a name="ln347">          // is the same one, check which one must be deleted</a>
<a name="ln348">          const int mod_in_history = (_search_history_by_module(history_list, mod) != NULL);</a>
<a name="ln349">          const int mod_next_in_history = (_search_history_by_module(history_list, mod_next) != NULL);</a>
<a name="ln350"> </a>
<a name="ln351">          // current is in history and next is not, delete next</a>
<a name="ln352">          if(mod_in_history &amp;&amp; !mod_next_in_history)</a>
<a name="ln353">          {</a>
<a name="ln354">            mod = mod_next;</a>
<a name="ln355">            modules = modules_next;</a>
<a name="ln356">            delete_module = 1;</a>
<a name="ln357">          }</a>
<a name="ln358">          // current is not in history and next is, delete current</a>
<a name="ln359">          else if(!mod_in_history &amp;&amp; mod_next_in_history)</a>
<a name="ln360">          {</a>
<a name="ln361">            delete_module = 1;</a>
<a name="ln362">          }</a>
<a name="ln363">          else</a>
<a name="ln364">          {</a>
<a name="ln365">            if(mod_in_history &amp;&amp; mod_next_in_history)</a>
<a name="ln366">              fprintf(</a>
<a name="ln367">                  stderr,</a>
<a name="ln368">                  &quot;[_check_deleted_instances] found duplicate module %s %s (%i) and %s %s (%i) both in history\n&quot;,</a>
<a name="ln369">                  mod-&gt;op, mod-&gt;multi_name, mod-&gt;multi_priority, mod_next-&gt;op, mod_next-&gt;multi_name,</a>
<a name="ln370">                  mod_next-&gt;multi_priority);</a>
<a name="ln371">            else</a>
<a name="ln372">              fprintf(</a>
<a name="ln373">                  stderr,</a>
<a name="ln374">                  &quot;[_check_deleted_instances] found duplicate module %s %s (%i) and %s %s (%i) none in history\n&quot;,</a>
<a name="ln375">                  mod-&gt;op, mod-&gt;multi_name, mod-&gt;multi_priority, mod_next-&gt;op, mod_next-&gt;multi_name,</a>
<a name="ln376">                  mod_next-&gt;multi_priority);</a>
<a name="ln377">          }</a>
<a name="ln378">        }</a>
<a name="ln379">      }</a>
<a name="ln380">    }</a>
<a name="ln381">    // this is a regular multi-instance and must be in history</a>
<a name="ln382">    else</a>
<a name="ln383">    {</a>
<a name="ln384">      delete_module = (_search_history_by_module(history_list, mod) == NULL);</a>
<a name="ln385">    }</a>
<a name="ln386"> </a>
<a name="ln387">    // if module is not in history we delete it</a>
<a name="ln388">    if(delete_module)</a>
<a name="ln389">    {</a>
<a name="ln390">      deleted_module_found = 1;</a>
<a name="ln391"> </a>
<a name="ln392">      if(darktable.develop-&gt;gui_module == mod) dt_iop_request_focus(NULL);</a>
<a name="ln393"> </a>
<a name="ln394">      const int reset = darktable.gui-&gt;reset;</a>
<a name="ln395">      darktable.gui-&gt;reset = 1;</a>
<a name="ln396"> </a>
<a name="ln397">      // we remove the plugin effectively</a>
<a name="ln398">      if(!dt_iop_is_hidden(mod))</a>
<a name="ln399">      {</a>
<a name="ln400">        // we just hide the module to avoid lots of gtk critical warnings</a>
<a name="ln401">        gtk_widget_hide(mod-&gt;expander);</a>
<a name="ln402"> </a>
<a name="ln403">        // this is copied from dt_iop_gui_delete_callback(), not sure why the above sentence...</a>
<a name="ln404">        gtk_widget_destroy(mod-&gt;widget);</a>
<a name="ln405">        dt_iop_gui_cleanup_module(mod);</a>
<a name="ln406">      }</a>
<a name="ln407"> </a>
<a name="ln408">      iop_list = g_list_remove_link(iop_list, modules);</a>
<a name="ln409"> </a>
<a name="ln410">      // remove it from all snapshots</a>
<a name="ln411">      dt_undo_iterate_internal(darktable.undo, DT_UNDO_HISTORY, mod, &amp;_history_invalidate_cb);</a>
<a name="ln412"> </a>
<a name="ln413">      // we cleanup the module</a>
<a name="ln414">      dt_accel_disconnect_list(mod-&gt;accel_closures);</a>
<a name="ln415">      dt_accel_cleanup_locals_iop(mod);</a>
<a name="ln416">      mod-&gt;accel_closures = NULL;</a>
<a name="ln417">      // don't delete the module, a pipe may still need it</a>
<a name="ln418">      dev-&gt;alliop = g_list_append(dev-&gt;alliop, mod);</a>
<a name="ln419"> </a>
<a name="ln420">      darktable.gui-&gt;reset = reset;</a>
<a name="ln421"> </a>
<a name="ln422">      // and reset the list</a>
<a name="ln423">      modules = g_list_first(iop_list);</a>
<a name="ln424">      continue;</a>
<a name="ln425">    }</a>
<a name="ln426"> </a>
<a name="ln427">    modules = g_list_next(modules);</a>
<a name="ln428">  }</a>
<a name="ln429">  if(deleted_module_found) iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln430"> </a>
<a name="ln431">  *_iop_list = iop_list;</a>
<a name="ln432"> </a>
<a name="ln433">  return deleted_module_found;</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">static void _reorder_gui_module_list(dt_develop_t *dev)</a>
<a name="ln437">{</a>
<a name="ln438">  int pos_module = 0;</a>
<a name="ln439">  GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln440">  while(modules)</a>
<a name="ln441">  {</a>
<a name="ln442">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln443"> </a>
<a name="ln444">    GtkWidget *expander = module-&gt;expander;</a>
<a name="ln445">    if(expander)</a>
<a name="ln446">    {</a>
<a name="ln447">      gtk_box_reorder_child(dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER), expander,</a>
<a name="ln448">                            pos_module++);</a>
<a name="ln449">    }</a>
<a name="ln450"> </a>
<a name="ln451">    modules = g_list_previous(modules);</a>
<a name="ln452">  }</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">static int _rebuild_multi_priority(GList *history_list)</a>
<a name="ln456">{</a>
<a name="ln457">  int changed = 0;</a>
<a name="ln458">  GList *history = g_list_first(history_list);</a>
<a name="ln459">  while(history)</a>
<a name="ln460">  {</a>
<a name="ln461">    dt_dev_history_item_t *hitem = (dt_dev_history_item_t *)history-&gt;data;</a>
<a name="ln462"> </a>
<a name="ln463">    // if multi_priority is different in history and dev-&gt;iop</a>
<a name="ln464">    // we keep the history version</a>
<a name="ln465">    if(hitem-&gt;module &amp;&amp; hitem-&gt;module-&gt;multi_priority != hitem-&gt;multi_priority)</a>
<a name="ln466">    {</a>
<a name="ln467">      dt_iop_update_multi_priority(hitem-&gt;module, hitem-&gt;multi_priority);</a>
<a name="ln468">      changed = 1;</a>
<a name="ln469">    }</a>
<a name="ln470"> </a>
<a name="ln471">    history = g_list_next(history);</a>
<a name="ln472">  }</a>
<a name="ln473">  return changed;</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476">static int _create_deleted_modules(GList **_iop_list, GList *history_list)</a>
<a name="ln477">{</a>
<a name="ln478">  GList *iop_list = *_iop_list;</a>
<a name="ln479">  int changed = 0;</a>
<a name="ln480">  gboolean done = FALSE;</a>
<a name="ln481"> </a>
<a name="ln482">  GList *l = g_list_first(history_list);</a>
<a name="ln483">  while(l)</a>
<a name="ln484">  {</a>
<a name="ln485">    GList *next = g_list_next(l);</a>
<a name="ln486">    dt_dev_history_item_t *hitem = (dt_dev_history_item_t *)l-&gt;data;</a>
<a name="ln487"> </a>
<a name="ln488">    // this fixes the duplicate module when undo: hitem-&gt;multi_priority = 0;</a>
<a name="ln489">    if(hitem-&gt;module == NULL)</a>
<a name="ln490">    {</a>
<a name="ln491">      changed = 1;</a>
<a name="ln492"> </a>
<a name="ln493">      const dt_iop_module_t *base_module = get_base_module(iop_list, hitem-&gt;op_name);</a>
<a name="ln494">      if(base_module == NULL)</a>
<a name="ln495">      {</a>
<a name="ln496">        fprintf(stderr, &quot;[_create_deleted_modules] can't find base module for %s\n&quot;, hitem-&gt;op_name);</a>
<a name="ln497">        return changed;</a>
<a name="ln498">      }</a>
<a name="ln499"> </a>
<a name="ln500">      // from there we create a new module for this base instance. The goal is to do a very minimal setup of the</a>
<a name="ln501">      // new module to be able to write the history items. From there we reload the whole history back and this</a>
<a name="ln502">      // will recreate the proper module instances.</a>
<a name="ln503">      dt_iop_module_t *module = (dt_iop_module_t *)calloc(1, sizeof(dt_iop_module_t));</a>
<a name="ln504">      if(dt_iop_load_module(module, base_module-&gt;so, base_module-&gt;dev))</a>
<a name="ln505">      {</a>
<a name="ln506">        return changed;</a>
<a name="ln507">      }</a>
<a name="ln508">      module-&gt;instance = base_module-&gt;instance;</a>
<a name="ln509"> </a>
<a name="ln510">      if(!dt_iop_is_hidden(module))</a>
<a name="ln511">      {</a>
<a name="ln512">        module-&gt;gui_init(module);</a>
<a name="ln513">      }</a>
<a name="ln514"> </a>
<a name="ln515">      // adjust the multi_name of the new module</a>
<a name="ln516">      g_strlcpy(module-&gt;multi_name, hitem-&gt;multi_name, sizeof(module-&gt;multi_name));</a>
<a name="ln517">      dt_iop_update_multi_priority(module, hitem-&gt;multi_priority);</a>
<a name="ln518">      module-&gt;iop_order = hitem-&gt;iop_order;</a>
<a name="ln519"> </a>
<a name="ln520">      // we insert this module into dev-&gt;iop</a>
<a name="ln521">      iop_list = g_list_insert_sorted(iop_list, module, dt_sort_iop_by_order);</a>
<a name="ln522"> </a>
<a name="ln523">      // add the expander, dt_dev_reload_history_items() don't work well without one</a>
<a name="ln524">      _add_module_expander(iop_list, module);</a>
<a name="ln525"> </a>
<a name="ln526">      // if not already done, set the module to all others same instance</a>
<a name="ln527">      if(!done)</a>
<a name="ln528">      {</a>
<a name="ln529">        _reset_module_instance(history_list, module, hitem-&gt;multi_priority);</a>
<a name="ln530"> </a>
<a name="ln531">        // and do that also in the undo/redo lists</a>
<a name="ln532">        struct _cb_data udata = { module, hitem-&gt;multi_priority };</a>
<a name="ln533">        dt_undo_iterate_internal(darktable.undo, DT_UNDO_HISTORY, &amp;udata, &amp;_undo_items_cb);</a>
<a name="ln534">        done = TRUE;</a>
<a name="ln535">      }</a>
<a name="ln536"> </a>
<a name="ln537">      hitem-&gt;module = module;</a>
<a name="ln538">    }</a>
<a name="ln539">    l = next;</a>
<a name="ln540">  }</a>
<a name="ln541"> </a>
<a name="ln542">  *_iop_list = iop_list;</a>
<a name="ln543"> </a>
<a name="ln544">  return changed;</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">static void _pop_undo(gpointer user_data, dt_undo_type_t type, dt_undo_data_t data, dt_undo_action_t action)</a>
<a name="ln548">{</a>
<a name="ln549">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln550"> </a>
<a name="ln551">  if(type == DT_UNDO_HISTORY)</a>
<a name="ln552">  {</a>
<a name="ln553">    dt_lib_history_t *d = (dt_lib_history_t *)self-&gt;data;</a>
<a name="ln554">    dt_undo_history_t *hist = (dt_undo_history_t *)data;</a>
<a name="ln555">    dt_develop_t *dev = darktable.develop;</a>
<a name="ln556"> </a>
<a name="ln557">    // we will work on a copy of history and modules</a>
<a name="ln558">    // when we're done we'll replace dev-&gt;history and dev-&gt;iop</a>
<a name="ln559">    GList *history_temp = _duplicate_history(hist-&gt;snapshot);</a>
<a name="ln560">    const int hist_end = hist-&gt;end;</a>
<a name="ln561">    GList *iop_temp = g_list_copy(dev-&gt;iop);</a>
<a name="ln562"> </a>
<a name="ln563">    // topology has changed?</a>
<a name="ln564">    int pipe_remove = 0;</a>
<a name="ln565"> </a>
<a name="ln566">    // we have to check if multi_priority has changed since history was saved</a>
<a name="ln567">    // we will adjust it here</a>
<a name="ln568">    if(_rebuild_multi_priority(history_temp))</a>
<a name="ln569">    {</a>
<a name="ln570">      pipe_remove = 1;</a>
<a name="ln571">      iop_temp = g_list_sort(iop_temp, dt_sort_iop_by_order);</a>
<a name="ln572">    }</a>
<a name="ln573"> </a>
<a name="ln574">    // check if this undo a delete module and re-create it</a>
<a name="ln575">    if(_create_deleted_modules(&amp;iop_temp, history_temp))</a>
<a name="ln576">    {</a>
<a name="ln577">      pipe_remove = 1;</a>
<a name="ln578">    }</a>
<a name="ln579"> </a>
<a name="ln580">    // check if this is a redo of a delete module or an undo of an add module</a>
<a name="ln581">    if(_check_deleted_instances(dev, &amp;iop_temp, history_temp))</a>
<a name="ln582">    {</a>
<a name="ln583">      pipe_remove = 1;</a>
<a name="ln584">    }</a>
<a name="ln585"> </a>
<a name="ln586">    // disable recording undo as the _lib_history_change_callback will be triggered by the calls below</a>
<a name="ln587">    d-&gt;record_undo = FALSE;</a>
<a name="ln588"> </a>
<a name="ln589">    dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln590"> </a>
<a name="ln591">    // set history and modules to dev</a>
<a name="ln592">    GList *history_temp2 = dev-&gt;history;</a>
<a name="ln593">    dev-&gt;history = history_temp;</a>
<a name="ln594">    dev-&gt;history_end = hist_end;</a>
<a name="ln595">    g_list_free_full(history_temp2, dt_dev_free_history_item);</a>
<a name="ln596">    GList *iop_temp2 = dev-&gt;iop;</a>
<a name="ln597">    dev-&gt;iop = iop_temp;</a>
<a name="ln598">    g_list_free(iop_temp2);</a>
<a name="ln599"> </a>
<a name="ln600">    // topology has changed</a>
<a name="ln601">    if(pipe_remove)</a>
<a name="ln602">    {</a>
<a name="ln603">      // we refresh the pipe</a>
<a name="ln604">      dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln605">      dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln606">      dev-&gt;preview2_pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln607">      dev-&gt;pipe-&gt;cache_obsolete = 1;</a>
<a name="ln608">      dev-&gt;preview_pipe-&gt;cache_obsolete = 1;</a>
<a name="ln609">      dev-&gt;preview2_pipe-&gt;cache_obsolete = 1;</a>
<a name="ln610"> </a>
<a name="ln611">      // invalidate buffers and force redraw of darkroom</a>
<a name="ln612">      dt_dev_invalidate_all(dev);</a>
<a name="ln613">    }</a>
<a name="ln614"> </a>
<a name="ln615">    dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln616"> </a>
<a name="ln617">    // if dev-&gt;iop has changed reflect that on module list</a>
<a name="ln618">    if(pipe_remove) _reorder_gui_module_list(dev);</a>
<a name="ln619"> </a>
<a name="ln620">    // write new history and reload</a>
<a name="ln621">    dt_dev_write_history(dev);</a>
<a name="ln622">    dt_dev_reload_history_items(dev);</a>
<a name="ln623"> </a>
<a name="ln624">    dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln625">  }</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">static void _history_undo_data_free(gpointer data)</a>
<a name="ln629">{</a>
<a name="ln630">  dt_undo_history_t *hist = (dt_undo_history_t *)data;</a>
<a name="ln631">  GList *snapshot = hist-&gt;snapshot;</a>
<a name="ln632">  g_list_free_full(snapshot, dt_dev_free_history_item);</a>
<a name="ln633">  free(data);</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">static void _lib_history_module_remove_callback(gpointer instance, dt_iop_module_t *module, gpointer user_data)</a>
<a name="ln637">{</a>
<a name="ln638">  dt_undo_iterate(darktable.undo, DT_UNDO_HISTORY, module, &amp;_history_invalidate_cb);</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641">static void _lib_history_change_callback(gpointer instance, gpointer user_data)</a>
<a name="ln642">{</a>
<a name="ln643">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln644">  dt_lib_history_t *d = (dt_lib_history_t *)self-&gt;data;</a>
<a name="ln645"> </a>
<a name="ln646">  /* first destroy all buttons in list */</a>
<a name="ln647">  gtk_container_foreach(GTK_CONTAINER(d-&gt;history_box), (GtkCallback)gtk_widget_destroy, 0);</a>
<a name="ln648"> </a>
<a name="ln649">  /* add default which always should be */</a>
<a name="ln650">  int num = -1;</a>
<a name="ln651">  gtk_box_pack_start(GTK_BOX(d-&gt;history_box),</a>
<a name="ln652">                     _lib_history_create_button(self, num, _(&quot;original&quot;), FALSE, darktable.develop-&gt;history_end == 0),</a>
<a name="ln653">                     TRUE, TRUE, 0);</a>
<a name="ln654">  num++;</a>
<a name="ln655"> </a>
<a name="ln656">  if (d-&gt;record_undo == TRUE)</a>
<a name="ln657">  {</a>
<a name="ln658">    /* record undo/redo history snapshot */</a>
<a name="ln659">    dt_undo_history_t *hist = malloc(sizeof(dt_undo_history_t));</a>
<a name="ln660">    hist-&gt;snapshot = _duplicate_history(darktable.develop-&gt;history);</a>
<a name="ln661">    hist-&gt;end = darktable.develop-&gt;history_end;</a>
<a name="ln662"> </a>
<a name="ln663">    dt_undo_record(darktable.undo, self, DT_UNDO_HISTORY, (dt_undo_data_t)hist,</a>
<a name="ln664">                   _pop_undo, _history_undo_data_free);</a>
<a name="ln665">  }</a>
<a name="ln666">  else</a>
<a name="ln667">    d-&gt;record_undo = TRUE;</a>
<a name="ln668"> </a>
<a name="ln669">  /* lock history mutex */</a>
<a name="ln670">  dt_pthread_mutex_lock(&amp;darktable.develop-&gt;history_mutex);</a>
<a name="ln671"> </a>
<a name="ln672">  /* iterate over history items and add them to list*/</a>
<a name="ln673">  GList *history = g_list_first(darktable.develop-&gt;history);</a>
<a name="ln674">  while(history)</a>
<a name="ln675">  {</a>
<a name="ln676">    const dt_dev_history_item_t *hitem = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln677">    char marker [32] = &quot;&quot;;</a>
<a name="ln678">    if(hitem-&gt;module-&gt;flags() &amp; IOP_FLAGS_DEPRECATED)</a>
<a name="ln679">      g_snprintf(marker, sizeof(marker), &quot;/!\\&quot;); // instead of an UTF character</a>
<a name="ln680">    gchar *label;</a>
<a name="ln681">    if(!hitem-&gt;multi_name[0] || strcmp(hitem-&gt;multi_name, &quot;0&quot;) == 0)</a>
<a name="ln682">      label = g_strdup_printf(&quot;%s %s&quot;, marker, hitem-&gt;module-&gt;name());</a>
<a name="ln683">    else</a>
<a name="ln684">      label = g_strdup_printf(&quot;%s %s %s&quot;, marker, hitem-&gt;module-&gt;name(), hitem-&gt;multi_name);</a>
<a name="ln685"> </a>
<a name="ln686">    gboolean selected = (num == darktable.develop-&gt;history_end - 1);</a>
<a name="ln687">    GtkWidget *widget = _lib_history_create_button(self, num, label, (hitem-&gt;enabled || (strcmp(hitem-&gt;op_name, &quot;mask_manager&quot;) == 0)), selected);</a>
<a name="ln688">    g_free(label);</a>
<a name="ln689"> </a>
<a name="ln690">    gtk_box_pack_start(GTK_BOX(d-&gt;history_box), widget, TRUE, TRUE, 0);</a>
<a name="ln691">    gtk_box_reorder_child(GTK_BOX(d-&gt;history_box), widget, 0);</a>
<a name="ln692">    num++;</a>
<a name="ln693"> </a>
<a name="ln694">    history = g_list_next(history);</a>
<a name="ln695">  }</a>
<a name="ln696"> </a>
<a name="ln697">  /* show all widgets */</a>
<a name="ln698">  gtk_widget_show_all(d-&gt;history_box);</a>
<a name="ln699"> </a>
<a name="ln700">  dt_pthread_mutex_unlock(&amp;darktable.develop-&gt;history_mutex);</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703">static void _lib_history_compress_clicked_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln704">{</a>
<a name="ln705">  const int32_t imgid = darktable.develop-&gt;image_storage.id;</a>
<a name="ln706">  if(!imgid) return;</a>
<a name="ln707"> </a>
<a name="ln708">  // As dt_history_compress_on_image does *not* use the history stack data at all</a>
<a name="ln709">  // make sure the current stack is in the database</a>
<a name="ln710">  dt_dev_write_history(darktable.develop);</a>
<a name="ln711"> </a>
<a name="ln712">  dt_history_compress_on_image(imgid);</a>
<a name="ln713"> </a>
<a name="ln714">  sqlite3_stmt *stmt;</a>
<a name="ln715"> </a>
<a name="ln716">  // load new history and write it back to ensure that all history are properly numbered without a gap</a>
<a name="ln717">  dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln718">  dt_dev_write_history(darktable.develop);</a>
<a name="ln719">  dt_image_synch_xmp(imgid);</a>
<a name="ln720"> </a>
<a name="ln721">  // then we can get the item to select in the new clean-up history retrieve the position of the module</a>
<a name="ln722">  // corresponding to the history end.</a>
<a name="ln723">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT IFNULL(MAX(num)+1, 0) FROM main.history &quot;</a>
<a name="ln724">                                                             &quot;WHERE imgid=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln725">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln726"> </a>
<a name="ln727">  if (sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln728">    darktable.develop-&gt;history_end = sqlite3_column_int(stmt, 0);</a>
<a name="ln729">  sqlite3_finalize(stmt);</a>
<a name="ln730"> </a>
<a name="ln731">  // select the new history end corresponding to the one before the history compression</a>
<a name="ln732">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;UPDATE main.images SET history_end=?2 WHERE id=?1&quot;,</a>
<a name="ln733">                              -1, &amp;stmt, NULL);</a>
<a name="ln734">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln735">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, darktable.develop-&gt;history_end);</a>
<a name="ln736">  sqlite3_step(stmt);</a>
<a name="ln737">  sqlite3_finalize(stmt);</a>
<a name="ln738"> </a>
<a name="ln739">  dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln740">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE);</a>
<a name="ln741">  dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">static void _lib_history_button_clicked_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln745">{</a>
<a name="ln746">  static int reset = 0;</a>
<a name="ln747">  if(reset) return;</a>
<a name="ln748">  if(!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) return;</a>
<a name="ln749"> </a>
<a name="ln750">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln751">  dt_lib_history_t *d = (dt_lib_history_t *)self-&gt;data;</a>
<a name="ln752">  reset = 1;</a>
<a name="ln753"> </a>
<a name="ln754">  /* deactivate all toggle buttons */</a>
<a name="ln755">  GList *children = gtk_container_get_children(GTK_CONTAINER(d-&gt;history_box));</a>
<a name="ln756">  for(GList *l = children; l != NULL; l = g_list_next(l))</a>
<a name="ln757">  {</a>
<a name="ln758">    GtkToggleButton *b = GTK_TOGGLE_BUTTON(l-&gt;data);</a>
<a name="ln759">    if(b != GTK_TOGGLE_BUTTON(widget)) g_object_set(G_OBJECT(b), &quot;active&quot;, FALSE, (gchar *)0);</a>
<a name="ln760">  }</a>
<a name="ln761">  g_list_free(children);</a>
<a name="ln762"> </a>
<a name="ln763">  reset = 0;</a>
<a name="ln764">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln765"> </a>
<a name="ln766">  /* revert to given history item. */</a>
<a name="ln767">  const int num = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), &quot;history-number&quot;));</a>
<a name="ln768">  dt_dev_pop_history_items(darktable.develop, num);</a>
<a name="ln769">  // set the module list order</a>
<a name="ln770">  dt_dev_reorder_gui_module_list(darktable.develop);</a>
<a name="ln771">  /* signal history changed */</a>
<a name="ln772">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE);</a>
<a name="ln773">  dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">static void _lib_history_create_style_button_clicked_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln777">{</a>
<a name="ln778">  if(darktable.develop-&gt;image_storage.id)</a>
<a name="ln779">  {</a>
<a name="ln780">    dt_dev_write_history(darktable.develop);</a>
<a name="ln781">    dt_gui_styles_dialog_new(darktable.develop-&gt;image_storage.id);</a>
<a name="ln782">  }</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln786">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln787">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="213"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 213, 211.</p></div>
<div class="balloon" rel="237"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 237, 234.</p></div>
<div class="balloon" rel="238"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 238, 235.</p></div>
<div class="balloon" rel="508"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'module'. Check lines: 508, 503.</p></div>
<div class="balloon" rel="660"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'hist'. Check lines: 660, 659.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
