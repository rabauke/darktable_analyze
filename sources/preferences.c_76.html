
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika, Tobias Ellinghaus.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;common/debug.h&quot;</a>
<a name="ln24">#include &quot;common/l10n.h&quot;</a>
<a name="ln25">#include &quot;common/presets.h&quot;</a>
<a name="ln26">#include &quot;control/control.h&quot;</a>
<a name="ln27">#include &quot;develop/imageop.h&quot;</a>
<a name="ln28">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln29">#include &quot;gui/draw.h&quot;</a>
<a name="ln30">#include &quot;gui/gtk.h&quot;</a>
<a name="ln31">#include &quot;gui/preferences.h&quot;</a>
<a name="ln32">#include &quot;gui/presets.h&quot;</a>
<a name="ln33">#include &quot;libs/lib.h&quot;</a>
<a name="ln34">#include &quot;preferences_gen.h&quot;</a>
<a name="ln35">#ifdef USE_LUA</a>
<a name="ln36">#include &quot;lua/preferences.h&quot;</a>
<a name="ln37">#endif</a>
<a name="ln38">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln39">#include &quot;osx/osx.h&quot;</a>
<a name="ln40">#endif</a>
<a name="ln41">#define ICON_SIZE 13</a>
<a name="ln42"> </a>
<a name="ln43">typedef struct dt_gui_presets_edit_dialog_t</a>
<a name="ln44">{</a>
<a name="ln45">  GtkTreeView *tree; // CHANGED!</a>
<a name="ln46">  gint rowid;        // CHANGED!</a>
<a name="ln47">  GtkLabel *name;</a>
<a name="ln48">  GtkEntry *description;</a>
<a name="ln49">  GtkCheckButton *autoapply, *filter;</a>
<a name="ln50">  GtkWidget *details;</a>
<a name="ln51">  GtkEntry *model, *maker, *lens;</a>
<a name="ln52">  GtkSpinButton *iso_min, *iso_max;</a>
<a name="ln53">  GtkWidget *exposure_min, *exposure_max;</a>
<a name="ln54">  GtkWidget *aperture_min, *aperture_max;</a>
<a name="ln55">  GtkSpinButton *focal_length_min, *focal_length_max;</a>
<a name="ln56">  GtkWidget *format_btn[3];</a>
<a name="ln57">} dt_gui_presets_edit_dialog_t;</a>
<a name="ln58"> </a>
<a name="ln59">// FIXME: this is copypasta from gui/presets.c. better put these somewhere so that all places can access the</a>
<a name="ln60">// same data.</a>
<a name="ln61">static const int dt_gui_presets_exposure_value_cnt = 24;</a>
<a name="ln62">static const float dt_gui_presets_exposure_value[]</a>
<a name="ln63">    = { 0.,       1. / 8000, 1. / 4000, 1. / 2000, 1. / 1000, 1. / 1000, 1. / 500, 1. / 250,</a>
<a name="ln64">        1. / 125, 1. / 60,   1. / 30,   1. / 15,   1. / 15,   1. / 8,    1. / 4,   1. / 2,</a>
<a name="ln65">        1,        2,         4,         8,         15,        30,        60,       FLT_MAX };</a>
<a name="ln66">static const char *dt_gui_presets_exposure_value_str[]</a>
<a name="ln67">    = { &quot;0&quot;,     &quot;1/8000&quot;, &quot;1/4000&quot;, &quot;1/2000&quot;, &quot;1/1000&quot;, &quot;1/1000&quot;, &quot;1/500&quot;, &quot;1/250&quot;,</a>
<a name="ln68">        &quot;1/125&quot;, &quot;1/60&quot;,   &quot;1/30&quot;,   &quot;1/15&quot;,   &quot;1/15&quot;,   &quot;1/8&quot;,    &quot;1/4&quot;,   &quot;1/2&quot;,</a>
<a name="ln69">        &quot;1\&quot;&quot;,   &quot;2\&quot;&quot;,    &quot;4\&quot;&quot;,    &quot;8\&quot;&quot;,    &quot;15\&quot;&quot;,   &quot;30\&quot;&quot;,   &quot;60\&quot;&quot;,  &quot;+&quot; };</a>
<a name="ln70">static const int dt_gui_presets_aperture_value_cnt = 19;</a>
<a name="ln71">static const float dt_gui_presets_aperture_value[]</a>
<a name="ln72">    = { 0,    0.5,  0.7,  1.0,  1.4,  2.0,  2.8,  4.0,   5.6,    8.0,</a>
<a name="ln73">        11.0, 16.0, 22.0, 32.0, 45.0, 64.0, 90.0, 128.0, FLT_MAX };</a>
<a name="ln74">static const char *dt_gui_presets_aperture_value_str[]</a>
<a name="ln75">    = { &quot;f/0&quot;,  &quot;f/0.5&quot;, &quot;f/0.7&quot;, &quot;f/1.0&quot;, &quot;f/1.4&quot;, &quot;f/2&quot;,  &quot;f/2.8&quot;, &quot;f/4&quot;,   &quot;f/5.6&quot;, &quot;f/8&quot;,</a>
<a name="ln76">        &quot;f/11&quot;, &quot;f/16&quot;,  &quot;f/22&quot;,  &quot;f/32&quot;,  &quot;f/45&quot;,  &quot;f/64&quot;, &quot;f/90&quot;,  &quot;f/128&quot;, &quot;f/+&quot; };</a>
<a name="ln77"> </a>
<a name="ln78">// format string and corresponding flag stored into the database</a>
<a name="ln79">static const char *dt_gui_presets_format_value_str[3] = { N_(&quot;normal images&quot;),</a>
<a name="ln80">                                                          N_(&quot;raw&quot;),</a>
<a name="ln81">                                                          N_(&quot;HDR&quot;)};</a>
<a name="ln82">static const int dt_gui_presets_format_flag[3] = { FOR_LDR, FOR_RAW, FOR_HDR };</a>
<a name="ln83"> </a>
<a name="ln84">// Values for the accelerators/presets treeview</a>
<a name="ln85"> </a>
<a name="ln86">enum</a>
<a name="ln87">{</a>
<a name="ln88">  A_ACCEL_COLUMN,</a>
<a name="ln89">  A_BINDING_COLUMN,</a>
<a name="ln90">  A_TRANS_COLUMN,</a>
<a name="ln91">  A_N_COLUMNS</a>
<a name="ln92">};</a>
<a name="ln93">enum</a>
<a name="ln94">{</a>
<a name="ln95">  P_ROWID_COLUMN,</a>
<a name="ln96">  P_OPERATION_COLUMN,</a>
<a name="ln97">  P_MODULE_COLUMN,</a>
<a name="ln98">  P_EDITABLE_COLUMN,</a>
<a name="ln99">  P_NAME_COLUMN,</a>
<a name="ln100">  P_MODEL_COLUMN,</a>
<a name="ln101">  P_MAKER_COLUMN,</a>
<a name="ln102">  P_LENS_COLUMN,</a>
<a name="ln103">  P_ISO_COLUMN,</a>
<a name="ln104">  P_EXPOSURE_COLUMN,</a>
<a name="ln105">  P_APERTURE_COLUMN,</a>
<a name="ln106">  P_FOCAL_LENGTH_COLUMN,</a>
<a name="ln107">  P_AUTOAPPLY_COLUMN,</a>
<a name="ln108">  P_N_COLUMNS</a>
<a name="ln109">};</a>
<a name="ln110"> </a>
<a name="ln111">static void init_tab_presets(GtkWidget *book);</a>
<a name="ln112">static void init_tab_accels(GtkWidget *book);</a>
<a name="ln113">static void tree_insert_accel(gpointer accel_struct, gpointer model_link);</a>
<a name="ln114">static void tree_insert_rec(GtkTreeStore *model, GtkTreeIter *parent, const gchar *accel_path,</a>
<a name="ln115">                            const gchar *translated_path, guint accel_key, GdkModifierType accel_mods);</a>
<a name="ln116">static void path_to_accel(GtkTreeModel *model, GtkTreePath *path, gchar *str, size_t str_len);</a>
<a name="ln117">static void update_accels_model(gpointer widget, gpointer data);</a>
<a name="ln118">static void update_accels_model_rec(GtkTreeModel *model, GtkTreeIter *parent, gchar *path, size_t path_len);</a>
<a name="ln119">static void delete_matching_accels(gpointer path, gpointer key_event);</a>
<a name="ln120">static void import_export(GtkButton *button, gpointer data);</a>
<a name="ln121">static void restore_defaults(GtkButton *button, gpointer data);</a>
<a name="ln122">static gint compare_rows_accels(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data);</a>
<a name="ln123">static gint compare_rows_presets(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data);</a>
<a name="ln124">static void import_preset(GtkButton *button, gpointer data);</a>
<a name="ln125"> </a>
<a name="ln126">// Signal handlers</a>
<a name="ln127">static void tree_row_activated_accels(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln128">                                      gpointer data);</a>
<a name="ln129">static void tree_row_activated_presets(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln130">                                       gpointer data);</a>
<a name="ln131">static void tree_selection_changed(GtkTreeSelection *selection, gpointer data);</a>
<a name="ln132">static gboolean tree_key_press(GtkWidget *widget, GdkEventKey *event, gpointer data);</a>
<a name="ln133">static gboolean tree_key_press_presets(GtkWidget *widget, GdkEventKey *event, gpointer data);</a>
<a name="ln134">static gboolean prefix_search(GtkTreeModel *model, gint column, const gchar *key, GtkTreeIter *iter,</a>
<a name="ln135">                              gpointer d);</a>
<a name="ln136"> </a>
<a name="ln137">static void edit_preset(GtkTreeView *tree, const gint rowid, const gchar *name, const gchar *module);</a>
<a name="ln138">static void edit_preset_response(GtkDialog *dialog, gint response_id, dt_gui_presets_edit_dialog_t *g);</a>
<a name="ln139"> </a>
<a name="ln140">static GtkWidget *_preferences_dialog;</a>
<a name="ln141"> </a>
<a name="ln142">///////////// gui theme selection</a>
<a name="ln143"> </a>
<a name="ln144">static void load_themes_dir(const char *basedir)</a>
<a name="ln145">{</a>
<a name="ln146">  char *themes_dir = g_build_filename(basedir, &quot;themes&quot;, NULL);</a>
<a name="ln147">  GDir *dir = g_dir_open(themes_dir, 0, NULL);</a>
<a name="ln148">  if(dir)</a>
<a name="ln149">  {</a>
<a name="ln150">    const gchar *d_name;</a>
<a name="ln151">    while((d_name = g_dir_read_name(dir)))</a>
<a name="ln152">      darktable.themes = g_list_append(darktable.themes, g_strdup(d_name));</a>
<a name="ln153">    g_dir_close(dir);</a>
<a name="ln154">  }</a>
<a name="ln155">  g_free(themes_dir);</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">static void load_themes(void)</a>
<a name="ln159">{</a>
<a name="ln160">  // Clear theme list...</a>
<a name="ln161">  g_list_free_full(darktable.themes, g_free);</a>
<a name="ln162">  darktable.themes = NULL;</a>
<a name="ln163"> </a>
<a name="ln164">  // check themes dirs</a>
<a name="ln165">  gchar configdir[PATH_MAX] = { 0 };</a>
<a name="ln166">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln167">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln168">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln169"> </a>
<a name="ln170">  load_themes_dir(datadir);</a>
<a name="ln171">  load_themes_dir(configdir);</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">static void theme_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln175">{</a>
<a name="ln176">  const int selected = gtk_combo_box_get_active(GTK_COMBO_BOX(widget));</a>
<a name="ln177">  gchar *theme = g_list_nth(darktable.themes, selected)-&gt;data;</a>
<a name="ln178">  gchar *i = g_strrstr(theme, &quot;.&quot;);</a>
<a name="ln179">  if(i) *i = '\0';</a>
<a name="ln180">  dt_gui_load_theme(theme);</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">///////////// gui language selection</a>
<a name="ln184"> </a>
<a name="ln185">static void language_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln186">{</a>
<a name="ln187">  int selected = gtk_combo_box_get_active(GTK_COMBO_BOX(widget));</a>
<a name="ln188">  dt_l10n_language_t *language = (dt_l10n_language_t *)g_list_nth(darktable.l10n-&gt;languages, selected)-&gt;data;</a>
<a name="ln189">  if(darktable.l10n-&gt;sys_default == selected)</a>
<a name="ln190">  {</a>
<a name="ln191">    dt_conf_set_string(&quot;ui_last/gui_language&quot;, &quot;&quot;);</a>
<a name="ln192">    darktable.l10n-&gt;selected = darktable.l10n-&gt;sys_default;</a>
<a name="ln193">  }</a>
<a name="ln194">  else</a>
<a name="ln195">  {</a>
<a name="ln196">    dt_conf_set_string(&quot;ui_last/gui_language&quot;, language-&gt;code);</a>
<a name="ln197">    darktable.l10n-&gt;selected = selected;</a>
<a name="ln198">  }</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">static gboolean reset_language_widget(GtkWidget *label, GdkEventButton *event, GtkWidget *widget)</a>
<a name="ln202">{</a>
<a name="ln203">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln204">  {</a>
<a name="ln205">    gtk_combo_box_set_active(GTK_COMBO_BOX(widget), darktable.l10n-&gt;sys_default);</a>
<a name="ln206">    return TRUE;</a>
<a name="ln207">  }</a>
<a name="ln208">  return FALSE;</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">static void hardcoded_gui(GtkWidget *grid, int *line)</a>
<a name="ln212">{</a>
<a name="ln213">  // language</a>
<a name="ln214"> </a>
<a name="ln215">  GtkWidget *label = gtk_label_new(_(&quot;interface language&quot;));</a>
<a name="ln216">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln217">  GtkWidget *labelev = gtk_event_box_new();</a>
<a name="ln218">  gtk_widget_add_events(labelev, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln219">  gtk_container_add(GTK_CONTAINER(labelev), label);</a>
<a name="ln220">  GtkWidget *widget = gtk_combo_box_text_new();</a>
<a name="ln221"> </a>
<a name="ln222">  for(GList *iter = darktable.l10n-&gt;languages; iter; iter = g_list_next(iter))</a>
<a name="ln223">  {</a>
<a name="ln224">    const char *name = dt_l10n_get_name(iter-&gt;data);</a>
<a name="ln225">    gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(widget), name);</a>
<a name="ln226">  }</a>
<a name="ln227"> </a>
<a name="ln228">  gtk_combo_box_set_active(GTK_COMBO_BOX(widget), darktable.l10n-&gt;selected);</a>
<a name="ln229">  g_signal_connect(G_OBJECT(widget), &quot;changed&quot;, G_CALLBACK(language_callback), 0);</a>
<a name="ln230">  gtk_widget_set_tooltip_text(labelev,  _(&quot;double click to reset to the system language&quot;));</a>
<a name="ln231">  gtk_event_box_set_visible_window(GTK_EVENT_BOX(labelev), FALSE);</a>
<a name="ln232">  gtk_widget_set_tooltip_text(widget, _(&quot;set the language of the user interface. the system default is marked with an * (needs a restart)&quot;));</a>
<a name="ln233">  gtk_grid_attach(GTK_GRID(grid), labelev, 0, (*line)++, 1, 1);</a>
<a name="ln234">  gtk_grid_attach_next_to(GTK_GRID(grid), widget, labelev, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln235">  g_signal_connect(G_OBJECT(labelev), &quot;button-press-event&quot;, G_CALLBACK(reset_language_widget), (gpointer)widget);</a>
<a name="ln236"> </a>
<a name="ln237">  // theme</a>
<a name="ln238"> </a>
<a name="ln239">  load_themes();</a>
<a name="ln240"> </a>
<a name="ln241">  label = gtk_label_new(_(&quot;theme&quot;));</a>
<a name="ln242">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln243">  gtk_widget_add_events(labelev, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln244">  widget = gtk_combo_box_text_new();</a>
<a name="ln245"> </a>
<a name="ln246">  // read all themes</a>
<a name="ln247">  const char *theme_name = dt_conf_get_string(&quot;ui_last/theme&quot;);</a>
<a name="ln248">  int selected = 0;</a>
<a name="ln249">  int k = 0;</a>
<a name="ln250"> </a>
<a name="ln251">  for(GList *iter = darktable.themes; iter; iter = g_list_next(iter))</a>
<a name="ln252">  {</a>
<a name="ln253">    gchar *name = g_strdup((gchar*)(iter-&gt;data));</a>
<a name="ln254">    // remove extension</a>
<a name="ln255">    gchar *i = g_strrstr(name, &quot;.&quot;);</a>
<a name="ln256">    if(i) *i = '\0';</a>
<a name="ln257">    gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(widget), name);</a>
<a name="ln258">    if(!g_strcmp0(name, theme_name)) selected = k;</a>
<a name="ln259">    k++;</a>
<a name="ln260">  }</a>
<a name="ln261"> </a>
<a name="ln262">  gtk_combo_box_set_active(GTK_COMBO_BOX(widget), selected);</a>
<a name="ln263"> </a>
<a name="ln264">  g_signal_connect(G_OBJECT(widget), &quot;changed&quot;, G_CALLBACK(theme_callback), 0);</a>
<a name="ln265">  gtk_widget_set_tooltip_text(widget, _(&quot;set the theme for the user interface&quot;));</a>
<a name="ln266">  gtk_grid_attach(GTK_GRID(grid), label, 0, (*line)++, 1, 1);</a>
<a name="ln267">  gtk_grid_attach_next_to(GTK_GRID(grid), widget, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">///////////// end of gui language selection</a>
<a name="ln271"> </a>
<a name="ln272"> </a>
<a name="ln273">void dt_gui_preferences_show()</a>
<a name="ln274">{</a>
<a name="ln275">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln276">  _preferences_dialog = gtk_dialog_new_with_buttons(_(&quot;darktable preferences&quot;), GTK_WINDOW(win),</a>
<a name="ln277">                                                    GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,</a>
<a name="ln278">                                                    _(&quot;close&quot;), GTK_RESPONSE_ACCEPT, NULL);</a>
<a name="ln279">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln280">  dt_osx_disallow_fullscreen(_preferences_dialog);</a>
<a name="ln281">#endif</a>
<a name="ln282">  gtk_window_set_position(GTK_WINDOW(_preferences_dialog), GTK_WIN_POS_CENTER_ON_PARENT);</a>
<a name="ln283">  GtkWidget *content = gtk_dialog_get_content_area(GTK_DIALOG(_preferences_dialog));</a>
<a name="ln284">  GtkWidget *notebook = gtk_notebook_new();</a>
<a name="ln285">  gtk_widget_set_size_request(notebook, -1, DT_PIXEL_APPLY_DPI(500));</a>
<a name="ln286">  gtk_widget_set_name(notebook, &quot;preferences_notebook&quot;);</a>
<a name="ln287">  gtk_box_pack_start(GTK_BOX(content), notebook, TRUE, TRUE, 0);</a>
<a name="ln288"> </a>
<a name="ln289">  // Make sure remap mode is off initially</a>
<a name="ln290">  darktable.control-&gt;accel_remap_str = NULL;</a>
<a name="ln291">  darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln292"> </a>
<a name="ln293">  init_tab_gui(_preferences_dialog, notebook, &amp;hardcoded_gui);</a>
<a name="ln294">  init_tab_core(_preferences_dialog, notebook, NULL);</a>
<a name="ln295">  init_tab_session(_preferences_dialog, notebook, NULL);</a>
<a name="ln296">  init_tab_accels(notebook);</a>
<a name="ln297">  init_tab_presets(notebook);</a>
<a name="ln298">#ifdef USE_LUA</a>
<a name="ln299">  GtkGrid* lua_grid = init_tab_lua(_preferences_dialog, notebook);</a>
<a name="ln300">#endif</a>
<a name="ln301">  gtk_widget_show_all(_preferences_dialog);</a>
<a name="ln302">  (void)gtk_dialog_run(GTK_DIALOG(_preferences_dialog));</a>
<a name="ln303">#ifdef USE_LUA</a>
<a name="ln304">  destroy_tab_lua(lua_grid);</a>
<a name="ln305">#endif</a>
<a name="ln306">  gtk_widget_destroy(_preferences_dialog);</a>
<a name="ln307"> </a>
<a name="ln308">  // Cleaning up any memory still allocated for remapping</a>
<a name="ln309">  if(darktable.control-&gt;accel_remap_path)</a>
<a name="ln310">  {</a>
<a name="ln311">    gtk_tree_path_free(darktable.control-&gt;accel_remap_path);</a>
<a name="ln312">    darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln313">  }</a>
<a name="ln314"> </a>
<a name="ln315">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_PREFERENCES_CHANGE);</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">static void cairo_destroy_from_pixbuf(guchar *pixels, gpointer data)</a>
<a name="ln319">{</a>
<a name="ln320">  cairo_destroy((cairo_t *)data);</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">static void tree_insert_presets(GtkTreeStore *tree_model)</a>
<a name="ln324">{</a>
<a name="ln325">  GtkTreeIter iter, parent;</a>
<a name="ln326">  sqlite3_stmt *stmt;</a>
<a name="ln327">  gchar *last_module = NULL;</a>
<a name="ln328"> </a>
<a name="ln329">  // Create a GdkPixbuf with a cairo drawing.</a>
<a name="ln330">  // lock</a>
<a name="ln331">  cairo_surface_t *lock_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln332">                                                         DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln333">  cairo_t *lock_cr = cairo_create(lock_cst);</a>
<a name="ln334">  cairo_set_source_rgb(lock_cr, 0.7, 0.7, 0.7);</a>
<a name="ln335">  dtgtk_cairo_paint_lock(lock_cr, 0, 0, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE), 0, NULL);</a>
<a name="ln336">  cairo_surface_flush(lock_cst);</a>
<a name="ln337">  guchar *data = cairo_image_surface_get_data(lock_cst);</a>
<a name="ln338">  dt_draw_cairo_to_gdk_pixbuf(data, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln339">  GdkPixbuf *lock_pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,</a>
<a name="ln340">                                                    DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln341">                                                    cairo_image_surface_get_stride(lock_cst),</a>
<a name="ln342">                                                    cairo_destroy_from_pixbuf, lock_cr);</a>
<a name="ln343"> </a>
<a name="ln344">  // check mark</a>
<a name="ln345">  cairo_surface_t *check_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln346">                                                          DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln347">  cairo_t *check_cr = cairo_create(check_cst);</a>
<a name="ln348">  cairo_set_source_rgb(check_cr, 0.7, 0.7, 0.7);</a>
<a name="ln349">  dtgtk_cairo_paint_check_mark(check_cr, 0, 0, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE), 0, NULL);</a>
<a name="ln350">  cairo_surface_flush(check_cst);</a>
<a name="ln351">  data = cairo_image_surface_get_data(check_cst);</a>
<a name="ln352">  dt_draw_cairo_to_gdk_pixbuf(data, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln353">  GdkPixbuf *check_pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,</a>
<a name="ln354">                                                     DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln355">                                                     cairo_image_surface_get_stride(check_cst),</a>
<a name="ln356">                                                     cairo_destroy_from_pixbuf, check_cr);</a>
<a name="ln357"> </a>
<a name="ln358">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln359">                              &quot;SELECT rowid, name, operation, autoapply, model, maker, lens, iso_min, &quot;</a>
<a name="ln360">                              &quot;iso_max, exposure_min, exposure_max, aperture_min, aperture_max, &quot;</a>
<a name="ln361">                              &quot;focal_length_min, focal_length_max, writeprotect FROM data.presets ORDER BY &quot;</a>
<a name="ln362">                              &quot;operation, name&quot;,</a>
<a name="ln363">                              -1, &amp;stmt, NULL);</a>
<a name="ln364">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln365">  {</a>
<a name="ln366">    const gint rowid = sqlite3_column_int(stmt, 0);</a>
<a name="ln367">    const gchar *name = (gchar *)sqlite3_column_text(stmt, 1);</a>
<a name="ln368">    const gchar *operation = (gchar *)sqlite3_column_text(stmt, 2);</a>
<a name="ln369">    const gboolean autoapply = (sqlite3_column_int(stmt, 3) == 0 ? FALSE : TRUE);</a>
<a name="ln370">    const gchar *model = (gchar *)sqlite3_column_text(stmt, 4);</a>
<a name="ln371">    const gchar *maker = (gchar *)sqlite3_column_text(stmt, 5);</a>
<a name="ln372">    const gchar *lens = (gchar *)sqlite3_column_text(stmt, 6);</a>
<a name="ln373">    const float iso_min = sqlite3_column_double(stmt, 7);</a>
<a name="ln374">    const float iso_max = sqlite3_column_double(stmt, 8);</a>
<a name="ln375">    const float exposure_min = sqlite3_column_double(stmt, 9);</a>
<a name="ln376">    const float exposure_max = sqlite3_column_double(stmt, 10);</a>
<a name="ln377">    const float aperture_min = sqlite3_column_double(stmt, 11);</a>
<a name="ln378">    const float aperture_max = sqlite3_column_double(stmt, 12);</a>
<a name="ln379">    const int focal_length_min = sqlite3_column_double(stmt, 13);</a>
<a name="ln380">    const int focal_length_max = sqlite3_column_double(stmt, 14);</a>
<a name="ln381">    const gboolean writeprotect = (sqlite3_column_int(stmt, 15) == 0 ? FALSE : TRUE);</a>
<a name="ln382"> </a>
<a name="ln383">    gchar *iso = NULL, *exposure = NULL, *aperture = NULL, *focal_length = NULL;</a>
<a name="ln384">    int min, max;</a>
<a name="ln385"> </a>
<a name="ln386">    gchar *module = g_strdup(dt_iop_get_localized_name(operation));</a>
<a name="ln387">    if(module == NULL) module = g_strdup(dt_lib_get_localized_name(operation));</a>
<a name="ln388">    if(module == NULL) module = g_strdup(operation);</a>
<a name="ln389"> </a>
<a name="ln390">    if(iso_min == 0.0 &amp;&amp; iso_max == FLT_MAX)</a>
<a name="ln391">      iso = g_strdup(&quot;%&quot;);</a>
<a name="ln392">    else</a>
<a name="ln393">      iso = g_strdup_printf(&quot;%zu – %zu&quot;, (size_t)iso_min, (size_t)iso_max);</a>
<a name="ln394"> </a>
<a name="ln395">    min = 0, max = 0;</a>
<a name="ln396">    for(; min &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; exposure_min &gt; dt_gui_presets_exposure_value[min]; min++)</a>
<a name="ln397">      ;</a>
<a name="ln398">    for(; max &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; exposure_max &gt; dt_gui_presets_exposure_value[max]; max++)</a>
<a name="ln399">      ;</a>
<a name="ln400">    if(min == 0 &amp;&amp; max == dt_gui_presets_exposure_value_cnt - 1)</a>
<a name="ln401">      exposure = g_strdup(&quot;%&quot;);</a>
<a name="ln402">    else</a>
<a name="ln403">      exposure = g_strdup_printf(&quot;%s – %s&quot;, dt_gui_presets_exposure_value_str[min],</a>
<a name="ln404">                                 dt_gui_presets_exposure_value_str[max]);</a>
<a name="ln405"> </a>
<a name="ln406">    min = 0, max = 0;</a>
<a name="ln407">    for(; min &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; aperture_min &gt; dt_gui_presets_aperture_value[min]; min++)</a>
<a name="ln408">      ;</a>
<a name="ln409">    for(; max &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; aperture_max &gt; dt_gui_presets_aperture_value[max]; max++)</a>
<a name="ln410">      ;</a>
<a name="ln411">    if(min == 0 &amp;&amp; max == dt_gui_presets_aperture_value_cnt - 1)</a>
<a name="ln412">      aperture = g_strdup(&quot;%&quot;);</a>
<a name="ln413">    else</a>
<a name="ln414">      aperture = g_strdup_printf(&quot;%s – %s&quot;, dt_gui_presets_aperture_value_str[min],</a>
<a name="ln415">                                 dt_gui_presets_aperture_value_str[max]);</a>
<a name="ln416"> </a>
<a name="ln417">    if(focal_length_min == 0.0 &amp;&amp; focal_length_max == 1000.0)</a>
<a name="ln418">      focal_length = g_strdup(&quot;%&quot;);</a>
<a name="ln419">    else</a>
<a name="ln420">      focal_length = g_strdup_printf(&quot;%d – %d&quot;, focal_length_min, focal_length_max);</a>
<a name="ln421"> </a>
<a name="ln422">    if(g_strcmp0(last_module, operation) != 0)</a>
<a name="ln423">    {</a>
<a name="ln424">      gtk_tree_store_append(tree_model, &amp;iter, NULL);</a>
<a name="ln425">      gtk_tree_store_set(tree_model, &amp;iter, P_ROWID_COLUMN, 0, P_OPERATION_COLUMN, &quot;&quot;, P_MODULE_COLUMN,</a>
<a name="ln426">                         _(module), P_EDITABLE_COLUMN, NULL, P_NAME_COLUMN, &quot;&quot;, P_MODEL_COLUMN, &quot;&quot;,</a>
<a name="ln427">                         P_MAKER_COLUMN, &quot;&quot;, P_LENS_COLUMN, &quot;&quot;, P_ISO_COLUMN, &quot;&quot;, P_EXPOSURE_COLUMN, &quot;&quot;,</a>
<a name="ln428">                         P_APERTURE_COLUMN, &quot;&quot;, P_FOCAL_LENGTH_COLUMN, &quot;&quot;, P_AUTOAPPLY_COLUMN, NULL, -1);</a>
<a name="ln429">      g_free(last_module);</a>
<a name="ln430">      last_module = g_strdup(operation);</a>
<a name="ln431">      parent = iter;</a>
<a name="ln432">    }</a>
<a name="ln433"> </a>
<a name="ln434">    gtk_tree_store_append(tree_model, &amp;iter, &amp;parent);</a>
<a name="ln435">    gtk_tree_store_set(tree_model, &amp;iter, P_ROWID_COLUMN, rowid, P_OPERATION_COLUMN, operation,</a>
<a name="ln436">                       P_MODULE_COLUMN, &quot;&quot;, P_EDITABLE_COLUMN, writeprotect ? lock_pixbuf : NULL,</a>
<a name="ln437">                       P_NAME_COLUMN, name, P_MODEL_COLUMN, model, P_MAKER_COLUMN, maker, P_LENS_COLUMN, lens,</a>
<a name="ln438">                       P_ISO_COLUMN, iso, P_EXPOSURE_COLUMN, exposure, P_APERTURE_COLUMN, aperture,</a>
<a name="ln439">                       P_FOCAL_LENGTH_COLUMN, focal_length, P_AUTOAPPLY_COLUMN,</a>
<a name="ln440">                       autoapply ? check_pixbuf : NULL, -1);</a>
<a name="ln441"> </a>
<a name="ln442">    g_free(focal_length);</a>
<a name="ln443">    g_free(aperture);</a>
<a name="ln444">    g_free(exposure);</a>
<a name="ln445">    g_free(iso);</a>
<a name="ln446">    g_free(module);</a>
<a name="ln447">  }</a>
<a name="ln448">  g_free(last_module);</a>
<a name="ln449">  sqlite3_finalize(stmt);</a>
<a name="ln450"> </a>
<a name="ln451">  g_object_unref(lock_pixbuf);</a>
<a name="ln452">  cairo_surface_destroy(lock_cst);</a>
<a name="ln453">  g_object_unref(check_pixbuf);</a>
<a name="ln454">  cairo_surface_destroy(check_cst);</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">static void init_tab_presets(GtkWidget *book)</a>
<a name="ln458">{</a>
<a name="ln459">  GtkWidget *container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln460">  GtkWidget *scroll = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln461">  GtkWidget *tree = gtk_tree_view_new();</a>
<a name="ln462">  GtkTreeStore *model = gtk_tree_store_new(</a>
<a name="ln463">      P_N_COLUMNS, G_TYPE_INT /*rowid*/, G_TYPE_STRING /*operation*/, G_TYPE_STRING /*module*/,</a>
<a name="ln464">      GDK_TYPE_PIXBUF /*editable*/, G_TYPE_STRING /*name*/, G_TYPE_STRING /*model*/, G_TYPE_STRING /*maker*/,</a>
<a name="ln465">      G_TYPE_STRING /*lens*/, G_TYPE_STRING /*iso*/, G_TYPE_STRING /*exposure*/, G_TYPE_STRING /*aperture*/,</a>
<a name="ln466">      G_TYPE_STRING /*focal length*/, GDK_TYPE_PIXBUF /*auto*/);</a>
<a name="ln467">  GtkCellRenderer *renderer;</a>
<a name="ln468">  GtkTreeViewColumn *column;</a>
<a name="ln469"> </a>
<a name="ln470">  // Adding the outer container</a>
<a name="ln471">  gtk_widget_set_margin_top(scroll, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln472">  gtk_widget_set_margin_bottom(scroll, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln473">  gtk_widget_set_margin_start(scroll, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln474">  gtk_widget_set_margin_end(scroll, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln475">  gtk_notebook_append_page(GTK_NOTEBOOK(book), container, gtk_label_new(_(&quot;presets&quot;)));</a>
<a name="ln476"> </a>
<a name="ln477">  tree_insert_presets(model);</a>
<a name="ln478"> </a>
<a name="ln479">  // Setting a custom sort functions so expandable groups rise to the top</a>
<a name="ln480">  gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(model), P_MODULE_COLUMN, GTK_SORT_ASCENDING);</a>
<a name="ln481">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model), P_MODULE_COLUMN, compare_rows_presets, NULL, NULL);</a>
<a name="ln482"> </a>
<a name="ln483">  // Setting up the cell renderers</a>
<a name="ln484">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln485">  column = gtk_tree_view_column_new_with_attributes(_(&quot;module&quot;), renderer, &quot;text&quot;, P_MODULE_COLUMN, NULL);</a>
<a name="ln486">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln487"> </a>
<a name="ln488">  renderer = gtk_cell_renderer_pixbuf_new();</a>
<a name="ln489">  column = gtk_tree_view_column_new_with_attributes(&quot;&quot;, renderer, &quot;pixbuf&quot;, P_EDITABLE_COLUMN, NULL);</a>
<a name="ln490">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln491"> </a>
<a name="ln492">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln493">  column = gtk_tree_view_column_new_with_attributes(_(&quot;name&quot;), renderer, &quot;text&quot;, P_NAME_COLUMN, NULL);</a>
<a name="ln494">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln495"> </a>
<a name="ln496">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln497">  column = gtk_tree_view_column_new_with_attributes(_(&quot;model&quot;), renderer, &quot;text&quot;, P_MODEL_COLUMN, NULL);</a>
<a name="ln498">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln499"> </a>
<a name="ln500">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln501">  column = gtk_tree_view_column_new_with_attributes(_(&quot;maker&quot;), renderer, &quot;text&quot;, P_MAKER_COLUMN, NULL);</a>
<a name="ln502">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln503"> </a>
<a name="ln504">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln505">  column = gtk_tree_view_column_new_with_attributes(_(&quot;lens&quot;), renderer, &quot;text&quot;, P_LENS_COLUMN, NULL);</a>
<a name="ln506">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln507"> </a>
<a name="ln508">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln509">  column = gtk_tree_view_column_new_with_attributes(_(&quot;ISO&quot;), renderer, &quot;text&quot;, P_ISO_COLUMN, NULL);</a>
<a name="ln510">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln511"> </a>
<a name="ln512">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln513">  column = gtk_tree_view_column_new_with_attributes(_(&quot;exposure&quot;), renderer, &quot;text&quot;, P_EXPOSURE_COLUMN, NULL);</a>
<a name="ln514">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln515"> </a>
<a name="ln516">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln517">  column = gtk_tree_view_column_new_with_attributes(_(&quot;aperture&quot;), renderer, &quot;text&quot;, P_APERTURE_COLUMN, NULL);</a>
<a name="ln518">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln519"> </a>
<a name="ln520">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln521">  column = gtk_tree_view_column_new_with_attributes(_(&quot;focal length&quot;), renderer, &quot;text&quot;,</a>
<a name="ln522">                                                    P_FOCAL_LENGTH_COLUMN, NULL);</a>
<a name="ln523">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln524"> </a>
<a name="ln525">  renderer = gtk_cell_renderer_pixbuf_new();</a>
<a name="ln526">  column = gtk_tree_view_column_new_with_attributes(_(&quot;auto&quot;), renderer, &quot;pixbuf&quot;, P_AUTOAPPLY_COLUMN, NULL);</a>
<a name="ln527">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln528"> </a>
<a name="ln529">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln530">  gtk_box_pack_start(GTK_BOX(container), scroll, TRUE, TRUE, 0);</a>
<a name="ln531"> </a>
<a name="ln532">  // Adding the import/export buttons</a>
<a name="ln533">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln534"> </a>
<a name="ln535">  GtkWidget *button = gtk_button_new_with_label(C_(&quot;preferences&quot;, &quot;import&quot;));</a>
<a name="ln536">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln537">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_preset), (gpointer)model);</a>
<a name="ln538"> </a>
<a name="ln539">  gtk_box_pack_start(GTK_BOX(container), hbox, FALSE, FALSE, 0);</a>
<a name="ln540"> </a>
<a name="ln541">  // Attaching treeview signals</a>
<a name="ln542"> </a>
<a name="ln543">  // row-activated either expands/collapses a row or activates editing</a>
<a name="ln544">  g_signal_connect(G_OBJECT(tree), &quot;row-activated&quot;, G_CALLBACK(tree_row_activated_presets), NULL);</a>
<a name="ln545"> </a>
<a name="ln546">  // A keypress may delete preset</a>
<a name="ln547">  g_signal_connect(G_OBJECT(tree), &quot;key-press-event&quot;, G_CALLBACK(tree_key_press_presets), (gpointer)model);</a>
<a name="ln548"> </a>
<a name="ln549">  // Setting up the search functionality</a>
<a name="ln550">  gtk_tree_view_set_search_column(GTK_TREE_VIEW(tree), P_NAME_COLUMN);</a>
<a name="ln551">  gtk_tree_view_set_enable_search(GTK_TREE_VIEW(tree), TRUE);</a>
<a name="ln552"> </a>
<a name="ln553">  // Attaching the model to the treeview</a>
<a name="ln554">  gtk_tree_view_set_model(GTK_TREE_VIEW(tree), GTK_TREE_MODEL(model));</a>
<a name="ln555"> </a>
<a name="ln556">  // Adding the treeview to its containers</a>
<a name="ln557">  gtk_container_add(GTK_CONTAINER(scroll), tree);</a>
<a name="ln558">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln559"> </a>
<a name="ln560">  g_object_unref(G_OBJECT(model));</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563">static void init_tab_accels(GtkWidget *book)</a>
<a name="ln564">{</a>
<a name="ln565">  GtkWidget *container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln566">  GtkWidget *scroll = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln567">  GtkWidget *tree = gtk_tree_view_new();</a>
<a name="ln568">  GtkWidget *button;</a>
<a name="ln569">  GtkWidget *hbox;</a>
<a name="ln570">  GtkTreeStore *model = gtk_tree_store_new(A_N_COLUMNS, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);</a>
<a name="ln571">  GtkCellRenderer *renderer;</a>
<a name="ln572">  GtkTreeViewColumn *column;</a>
<a name="ln573"> </a>
<a name="ln574">  // Adding the outer container</a>
<a name="ln575">  gtk_widget_set_margin_top(container, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln576">  gtk_widget_set_margin_bottom(container, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln577">  gtk_widget_set_margin_start(container, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln578">  gtk_widget_set_margin_end(container, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln579">  gtk_notebook_append_page(GTK_NOTEBOOK(book), container, gtk_label_new(_(&quot;shortcuts&quot;)));</a>
<a name="ln580"> </a>
<a name="ln581">  // Building the accelerator tree</a>
<a name="ln582">  g_slist_foreach(darktable.control-&gt;accelerator_list, tree_insert_accel, (gpointer)model);</a>
<a name="ln583"> </a>
<a name="ln584">  // Setting a custom sort functions so expandable groups rise to the top</a>
<a name="ln585">  gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(model), A_TRANS_COLUMN, GTK_SORT_ASCENDING);</a>
<a name="ln586">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model), A_TRANS_COLUMN, compare_rows_accels, NULL, NULL);</a>
<a name="ln587"> </a>
<a name="ln588">  // Setting up the cell renderers</a>
<a name="ln589">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln590">  column = gtk_tree_view_column_new_with_attributes(_(&quot;shortcut&quot;), renderer, &quot;text&quot;, A_TRANS_COLUMN, NULL);</a>
<a name="ln591">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln592"> </a>
<a name="ln593">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln594">  column = gtk_tree_view_column_new_with_attributes(_(&quot;binding&quot;), renderer, &quot;text&quot;, A_BINDING_COLUMN, NULL);</a>
<a name="ln595">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln596"> </a>
<a name="ln597">  // Attaching treeview signals</a>
<a name="ln598"> </a>
<a name="ln599">  // row-activated either expands/collapses a row or activates remapping</a>
<a name="ln600">  g_signal_connect(G_OBJECT(tree), &quot;row-activated&quot;, G_CALLBACK(tree_row_activated_accels), NULL);</a>
<a name="ln601"> </a>
<a name="ln602">  // A selection change will cancel a currently active remapping</a>
<a name="ln603">  g_signal_connect(G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(tree))), &quot;changed&quot;,</a>
<a name="ln604">                   G_CALLBACK(tree_selection_changed), NULL);</a>
<a name="ln605"> </a>
<a name="ln606">  // A keypress may remap an accel or delete one</a>
<a name="ln607">  g_signal_connect(G_OBJECT(tree), &quot;key-press-event&quot;, G_CALLBACK(tree_key_press), (gpointer)model);</a>
<a name="ln608"> </a>
<a name="ln609">  // Setting up the search functionality</a>
<a name="ln610">  gtk_tree_view_set_search_column(GTK_TREE_VIEW(tree), A_TRANS_COLUMN);</a>
<a name="ln611">  gtk_tree_view_set_search_equal_func(GTK_TREE_VIEW(tree), prefix_search, NULL, NULL);</a>
<a name="ln612">  gtk_tree_view_set_enable_search(GTK_TREE_VIEW(tree), TRUE);</a>
<a name="ln613"> </a>
<a name="ln614">  // Attaching the model to the treeview</a>
<a name="ln615">  gtk_tree_view_set_model(GTK_TREE_VIEW(tree), GTK_TREE_MODEL(model));</a>
<a name="ln616"> </a>
<a name="ln617">  // Adding the treeview to its containers</a>
<a name="ln618">  gtk_container_add(GTK_CONTAINER(scroll), tree);</a>
<a name="ln619">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln620">  gtk_box_pack_start(GTK_BOX(container), scroll, TRUE, TRUE, 0);</a>
<a name="ln621"> </a>
<a name="ln622">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln623"> </a>
<a name="ln624">  // Adding the restore defaults button</a>
<a name="ln625">  button = gtk_button_new_with_label(C_(&quot;preferences&quot;, &quot;default&quot;));</a>
<a name="ln626">  gtk_box_pack_end(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln627">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(restore_defaults), NULL);</a>
<a name="ln628">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(update_accels_model), (gpointer)model);</a>
<a name="ln629"> </a>
<a name="ln630">  // Adding the import/export buttons</a>
<a name="ln631"> </a>
<a name="ln632">  button = gtk_button_new_with_label(C_(&quot;preferences&quot;, &quot;import&quot;));</a>
<a name="ln633">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln634">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_export), (gpointer)0);</a>
<a name="ln635">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(update_accels_model), (gpointer)model);</a>
<a name="ln636"> </a>
<a name="ln637">  button = gtk_button_new_with_label(_(&quot;export&quot;));</a>
<a name="ln638">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln639">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_export), (gpointer)1);</a>
<a name="ln640"> </a>
<a name="ln641">  gtk_box_pack_start(GTK_BOX(container), hbox, FALSE, FALSE, 0);</a>
<a name="ln642"> </a>
<a name="ln643">  g_object_unref(G_OBJECT(model));</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">static void tree_insert_accel(gpointer accel_struct, gpointer model_link)</a>
<a name="ln647">{</a>
<a name="ln648">  GtkTreeStore *model = (GtkTreeStore *)model_link;</a>
<a name="ln649">  dt_accel_t *accel = (dt_accel_t *)accel_struct;</a>
<a name="ln650">  GtkAccelKey key;</a>
<a name="ln651"> </a>
<a name="ln652">  // Getting the first significant parts of the paths</a>
<a name="ln653">  const char *accel_path = accel-&gt;path;</a>
<a name="ln654">  const char *translated_path = accel-&gt;translated_path;</a>
<a name="ln655"> </a>
<a name="ln656">  /* if prefixed lets forward pointer */</a>
<a name="ln657">  if(!strncmp(accel_path, &quot;&lt;Darktable&gt;&quot;, strlen(&quot;&lt;Darktable&gt;&quot;)))</a>
<a name="ln658">  {</a>
<a name="ln659">    accel_path += strlen(&quot;&lt;Darktable&gt;&quot;) + 1;</a>
<a name="ln660">    translated_path += strlen(&quot;&lt;Darktable&gt;&quot;) + 1;</a>
<a name="ln661">  }</a>
<a name="ln662"> </a>
<a name="ln663">  // Getting the accelerator keys</a>
<a name="ln664">  gtk_accel_map_lookup_entry(accel-&gt;path, &amp;key);</a>
<a name="ln665"> </a>
<a name="ln666">  /* lets recurse path */</a>
<a name="ln667">  tree_insert_rec(model, NULL, accel_path, translated_path, key.accel_key, key.accel_mods);</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">static void tree_insert_rec(GtkTreeStore *model, GtkTreeIter *parent, const gchar *accel_path,</a>
<a name="ln671">                            const gchar *translated_path, guint accel_key, GdkModifierType accel_mods)</a>
<a name="ln672">{</a>
<a name="ln673">  int i;</a>
<a name="ln674">  gboolean found = FALSE;</a>
<a name="ln675">  gchar *val_str;</a>
<a name="ln676">  GtkTreeIter iter;</a>
<a name="ln677"> </a>
<a name="ln678">  /* if we are on end of path lets bail out of recursive insert */</a>
<a name="ln679">  if(*accel_path == 0) return;</a>
<a name="ln680"> </a>
<a name="ln681">  /* check if we are on a leaf or a branch  */</a>
<a name="ln682">  if(!g_strrstr(accel_path, &quot;/&quot;))</a>
<a name="ln683">  {</a>
<a name="ln684">    /* we are on a leaf lets add */</a>
<a name="ln685">    gchar *name = gtk_accelerator_get_label(accel_key, accel_mods);</a>
<a name="ln686">    gtk_tree_store_append(model, &amp;iter, parent);</a>
<a name="ln687">    gtk_tree_store_set(model, &amp;iter, A_ACCEL_COLUMN, accel_path, A_BINDING_COLUMN,</a>
<a name="ln688">                       g_dpgettext2(&quot;gtk30&quot;, &quot;keyboard label&quot;, name), A_TRANS_COLUMN, translated_path, -1);</a>
<a name="ln689">    g_free(name);</a>
<a name="ln690">  }</a>
<a name="ln691">  else</a>
<a name="ln692">  {</a>
<a name="ln693">    /* we are on a branch let's get the node name */</a>
<a name="ln694">    const gchar *end = g_strstr_len(accel_path, strlen(accel_path), &quot;/&quot;);</a>
<a name="ln695">    const gchar *trans_end = g_strstr_len(translated_path, strlen(translated_path), &quot;/&quot;);</a>
<a name="ln696">    gchar *node = g_strndup(accel_path, end - accel_path);</a>
<a name="ln697">    gchar *trans_node;</a>
<a name="ln698">    // safeguard against broken translations</a>
<a name="ln699">    if(trans_end)</a>
<a name="ln700">      trans_node = g_strndup(translated_path, trans_end - translated_path);</a>
<a name="ln701">    else</a>
<a name="ln702">    {</a>
<a name="ln703">      fprintf(stderr, &quot;error: translation mismatch: `%s' vs. `%s'\n&quot;, accel_path, translated_path);</a>
<a name="ln704">      trans_node = g_strdup(node);</a>
<a name="ln705">      translated_path = accel_path;</a>
<a name="ln706">    }</a>
<a name="ln707"> </a>
<a name="ln708">    /* search the tree if we alread have an sibling with node name */</a>
<a name="ln709">    int siblings = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(model), parent);</a>
<a name="ln710">    for(i = 0; i &lt; siblings; i++)</a>
<a name="ln711">    {</a>
<a name="ln712">      gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(model), &amp;iter, parent, i);</a>
<a name="ln713">      gtk_tree_model_get(GTK_TREE_MODEL(model), &amp;iter, A_ACCEL_COLUMN, &amp;val_str, -1);</a>
<a name="ln714"> </a>
<a name="ln715">      /* do we match current sibling */</a>
<a name="ln716">      if(!strcmp(val_str, node)) found = TRUE;</a>
<a name="ln717"> </a>
<a name="ln718">      g_free(val_str);</a>
<a name="ln719"> </a>
<a name="ln720">      /* if we found a matching node let's break out */</a>
<a name="ln721">      if(found) break;</a>
<a name="ln722">    }</a>
<a name="ln723"> </a>
<a name="ln724">    /* if not found let's add a branch */</a>
<a name="ln725">    if(!found)</a>
<a name="ln726">    {</a>
<a name="ln727">      gtk_tree_store_append(model, &amp;iter, parent);</a>
<a name="ln728">      gtk_tree_store_set(model, &amp;iter, A_ACCEL_COLUMN, node, A_BINDING_COLUMN, &quot;&quot;, A_TRANS_COLUMN, trans_node,</a>
<a name="ln729">                         -1);</a>
<a name="ln730">    }</a>
<a name="ln731"> </a>
<a name="ln732">    /* recurse further down the path */</a>
<a name="ln733">    tree_insert_rec(model, &amp;iter, accel_path + strlen(node) + 1, translated_path + strlen(trans_node) + 1,</a>
<a name="ln734">                    accel_key, accel_mods);</a>
<a name="ln735"> </a>
<a name="ln736">    /* free up data */</a>
<a name="ln737">    g_free(node);</a>
<a name="ln738">    g_free(trans_node);</a>
<a name="ln739">  }</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">static void path_to_accel(GtkTreeModel *model, GtkTreePath *path, gchar *str, size_t str_len)</a>
<a name="ln743">{</a>
<a name="ln744">  gint depth;</a>
<a name="ln745">  gint *indices;</a>
<a name="ln746">  GtkTreeIter parent;</a>
<a name="ln747">  GtkTreeIter child;</a>
<a name="ln748">  gint i;</a>
<a name="ln749">  gchar *data_str;</a>
<a name="ln750"> </a>
<a name="ln751">  // Start out with the base &lt;Darktable&gt;</a>
<a name="ln752">  g_strlcpy(str, &quot;&lt;Darktable&gt;&quot;, str_len);</a>
<a name="ln753"> </a>
<a name="ln754">  // For each index in the path, append a '/' and that section of the path</a>
<a name="ln755">  depth = gtk_tree_path_get_depth(path);</a>
<a name="ln756">  indices = gtk_tree_path_get_indices(path);</a>
<a name="ln757">  for(i = 0; i &lt; depth; i++)</a>
<a name="ln758">  {</a>
<a name="ln759">    g_strlcat(str, &quot;/&quot;, str_len);</a>
<a name="ln760">    gtk_tree_model_iter_nth_child(model, &amp;child, i == 0 ? NULL : &amp;parent, indices[i]);</a>
<a name="ln761">    gtk_tree_model_get(model, &amp;child, A_ACCEL_COLUMN, &amp;data_str, -1);</a>
<a name="ln762">    g_strlcat(str, data_str, str_len);</a>
<a name="ln763">    g_free(data_str);</a>
<a name="ln764">    parent = child;</a>
<a name="ln765">  }</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768">static void update_accels_model(gpointer widget, gpointer data)</a>
<a name="ln769">{</a>
<a name="ln770">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln771">  GtkTreeIter iter;</a>
<a name="ln772">  gchar path[256];</a>
<a name="ln773">  gchar *end;</a>
<a name="ln774">  gint i;</a>
<a name="ln775"> </a>
<a name="ln776">  g_strlcpy(path, &quot;&lt;Darktable&gt;&quot;, sizeof(path));</a>
<a name="ln777">  end = path + strlen(path);</a>
<a name="ln778"> </a>
<a name="ln779">  for(i = 0; i &lt; gtk_tree_model_iter_n_children(model, NULL); i++)</a>
<a name="ln780">  {</a>
<a name="ln781">    gtk_tree_model_iter_nth_child(model, &amp;iter, NULL, i);</a>
<a name="ln782">    update_accels_model_rec(model, &amp;iter, path, sizeof(path));</a>
<a name="ln783">    *end = '\0'; // Trimming the string back to the base for the next iteration</a>
<a name="ln784">  }</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">static void update_accels_model_rec(GtkTreeModel *model, GtkTreeIter *parent, gchar *path, size_t path_len)</a>
<a name="ln788">{</a>
<a name="ln789">  GtkAccelKey key;</a>
<a name="ln790">  GtkTreeIter iter;</a>
<a name="ln791">  gchar *str_data;</a>
<a name="ln792">  gchar *end;</a>
<a name="ln793">  gint i;</a>
<a name="ln794"> </a>
<a name="ln795">  // First concatenating this part of the key</a>
<a name="ln796">  g_strlcat(path, &quot;/&quot;, path_len);</a>
<a name="ln797">  gtk_tree_model_get(model, parent, A_ACCEL_COLUMN, &amp;str_data, -1);</a>
<a name="ln798">  g_strlcat(path, str_data, path_len);</a>
<a name="ln799">  g_free(str_data);</a>
<a name="ln800"> </a>
<a name="ln801">  if(gtk_tree_model_iter_has_child(model, parent))</a>
<a name="ln802">  {</a>
<a name="ln803">    // Branch node, carry on with recursion</a>
<a name="ln804">    end = path + strlen(path);</a>
<a name="ln805"> </a>
<a name="ln806">    for(i = 0; i &lt; gtk_tree_model_iter_n_children(model, parent); i++)</a>
<a name="ln807">    {</a>
<a name="ln808">      gtk_tree_model_iter_nth_child(model, &amp;iter, parent, i);</a>
<a name="ln809">      update_accels_model_rec(model, &amp;iter, path, path_len);</a>
<a name="ln810">      *end = '\0';</a>
<a name="ln811">    }</a>
<a name="ln812">  }</a>
<a name="ln813">  else</a>
<a name="ln814">  {</a>
<a name="ln815">    // Leaf node, update the text</a>
<a name="ln816"> </a>
<a name="ln817">    gtk_accel_map_lookup_entry(path, &amp;key);</a>
<a name="ln818">    gchar *name = gtk_accelerator_get_label(key.accel_key, key.accel_mods);</a>
<a name="ln819">    gtk_tree_store_set(GTK_TREE_STORE(model), parent, A_BINDING_COLUMN, name, -1);</a>
<a name="ln820">    g_free(name);</a>
<a name="ln821">  }</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824">static void delete_matching_accels(gpointer current, gpointer mapped)</a>
<a name="ln825">{</a>
<a name="ln826">  const dt_accel_t *current_accel = (dt_accel_t *)current;</a>
<a name="ln827">  const dt_accel_t *mapped_accel = (dt_accel_t *)mapped;</a>
<a name="ln828">  GtkAccelKey current_key;</a>
<a name="ln829">  GtkAccelKey mapped_key;</a>
<a name="ln830"> </a>
<a name="ln831">  // Make sure we're not deleting the key we just remapped</a>
<a name="ln832">  if(!strcmp(current_accel-&gt;path, mapped_accel-&gt;path)) return;</a>
<a name="ln833"> </a>
<a name="ln834">  // Finding the relevant keyboard shortcuts</a>
<a name="ln835">  gtk_accel_map_lookup_entry(current_accel-&gt;path, &amp;current_key);</a>
<a name="ln836">  gtk_accel_map_lookup_entry(mapped_accel-&gt;path, &amp;mapped_key);</a>
<a name="ln837"> </a>
<a name="ln838">  if(current_key.accel_key == mapped_key.accel_key                 // Key code matches</a>
<a name="ln839">     &amp;&amp; current_key.accel_mods == mapped_key.accel_mods            // Key state matches</a>
<a name="ln840">     &amp;&amp; !(current_accel-&gt;local &amp;&amp; mapped_accel-&gt;local              // Not both local to</a>
<a name="ln841">          &amp;&amp; strcmp(current_accel-&gt;module, mapped_accel-&gt;module))) // diff mods</a>
<a name="ln842">    gtk_accel_map_change_entry(current_accel-&gt;path, 0, 0, TRUE);</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">static gint _accelcmp(gconstpointer a, gconstpointer b)</a>
<a name="ln846">{</a>
<a name="ln847">  return (gint)(strcmp(((dt_accel_t *)a)-&gt;path, ((dt_accel_t *)b)-&gt;path));</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">// TODO: remember which sections were collapsed/expanded and where the view was scrolled to and restore that</a>
<a name="ln851">// after editing is done</a>
<a name="ln852">//      Alternative: change edit_preset_response to not clear+refill the tree, but to update the single row</a>
<a name="ln853">//      which changed.</a>
<a name="ln854">static void tree_row_activated_presets(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln855">                                       gpointer data)</a>
<a name="ln856">{</a>
<a name="ln857">  GtkTreeIter iter;</a>
<a name="ln858">  GtkTreeModel *model = gtk_tree_view_get_model(tree);</a>
<a name="ln859"> </a>
<a name="ln860">  gtk_tree_model_get_iter(model, &amp;iter, path);</a>
<a name="ln861"> </a>
<a name="ln862">  if(gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln863">  {</a>
<a name="ln864">    // For branch nodes, toggle expansion on activation</a>
<a name="ln865">    if(gtk_tree_view_row_expanded(tree, path))</a>
<a name="ln866">      gtk_tree_view_collapse_row(tree, path);</a>
<a name="ln867">    else</a>
<a name="ln868">      gtk_tree_view_expand_row(tree, path, FALSE);</a>
<a name="ln869">  }</a>
<a name="ln870">  else</a>
<a name="ln871">  {</a>
<a name="ln872">    // For leaf nodes, open editing window if the preset is not writeprotected</a>
<a name="ln873">    gint rowid;</a>
<a name="ln874">    gchar *name, *operation;</a>
<a name="ln875">    GdkPixbuf *editable;</a>
<a name="ln876">    gtk_tree_model_get(model, &amp;iter, P_ROWID_COLUMN, &amp;rowid, P_NAME_COLUMN, &amp;name, P_OPERATION_COLUMN,</a>
<a name="ln877">                       &amp;operation, P_EDITABLE_COLUMN, &amp;editable, -1);</a>
<a name="ln878">    if(editable == NULL)</a>
<a name="ln879">      edit_preset(tree, rowid, name, operation);</a>
<a name="ln880">    else</a>
<a name="ln881">      g_object_unref(editable);</a>
<a name="ln882">    g_free(name);</a>
<a name="ln883">    g_free(operation);</a>
<a name="ln884">  }</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887">static void tree_row_activated_accels(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln888">                                      gpointer data)</a>
<a name="ln889">{</a>
<a name="ln890">  GtkTreeIter iter;</a>
<a name="ln891">  GtkTreeModel *model = gtk_tree_view_get_model(tree);</a>
<a name="ln892"> </a>
<a name="ln893">  static gchar accel_path[256];</a>
<a name="ln894"> </a>
<a name="ln895">  gtk_tree_model_get_iter(model, &amp;iter, path);</a>
<a name="ln896"> </a>
<a name="ln897">  if(gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln898">  {</a>
<a name="ln899">    // For branch nodes, toggle expansion on activation</a>
<a name="ln900">    if(gtk_tree_view_row_expanded(tree, path))</a>
<a name="ln901">      gtk_tree_view_collapse_row(tree, path);</a>
<a name="ln902">    else</a>
<a name="ln903">      gtk_tree_view_expand_row(tree, path, FALSE);</a>
<a name="ln904">  }</a>
<a name="ln905">  else</a>
<a name="ln906">  {</a>
<a name="ln907">    // For leaf nodes, enter remapping mode</a>
<a name="ln908"> </a>
<a name="ln909">    // Assembling the full accelerator path</a>
<a name="ln910">    path_to_accel(model, path, accel_path, sizeof(accel_path));</a>
<a name="ln911"> </a>
<a name="ln912">    // Setting the notification text</a>
<a name="ln913">    gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, A_BINDING_COLUMN, _(&quot;press key combination to remap...&quot;),</a>
<a name="ln914">                       -1);</a>
<a name="ln915"> </a>
<a name="ln916">    // Activating remapping</a>
<a name="ln917">    darktable.control-&gt;accel_remap_str = accel_path;</a>
<a name="ln918">    darktable.control-&gt;accel_remap_path = gtk_tree_path_copy(path);</a>
<a name="ln919">  }</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922">static void tree_selection_changed(GtkTreeSelection *selection, gpointer data)</a>
<a name="ln923">{</a>
<a name="ln924">  GtkTreeModel *model;</a>
<a name="ln925">  GtkTreeIter iter;</a>
<a name="ln926"> </a>
<a name="ln927">  GtkAccelKey key;</a>
<a name="ln928"> </a>
<a name="ln929">  // If remapping is currently activated, it needs to be deactivated</a>
<a name="ln930">  if(!darktable.control-&gt;accel_remap_str) return;</a>
<a name="ln931"> </a>
<a name="ln932">  model = gtk_tree_view_get_model(gtk_tree_selection_get_tree_view(selection));</a>
<a name="ln933">  gtk_tree_model_get_iter(model, &amp;iter, darktable.control-&gt;accel_remap_path);</a>
<a name="ln934"> </a>
<a name="ln935">  // Restoring the A_BINDING_COLUMN text</a>
<a name="ln936">  gtk_accel_map_lookup_entry(darktable.control-&gt;accel_remap_str, &amp;key);</a>
<a name="ln937">  gchar *name = gtk_accelerator_get_label(key.accel_key, key.accel_mods);</a>
<a name="ln938">  gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, A_BINDING_COLUMN, name, -1);</a>
<a name="ln939">  g_free(name);</a>
<a name="ln940"> </a>
<a name="ln941">  // Cleaning up the darktable.gui info</a>
<a name="ln942">  darktable.control-&gt;accel_remap_str = NULL;</a>
<a name="ln943">  gtk_tree_path_free(darktable.control-&gt;accel_remap_path);</a>
<a name="ln944">  darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">static gboolean tree_key_press(GtkWidget *widget, GdkEventKey *event, gpointer data)</a>
<a name="ln948">{</a>
<a name="ln949">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln950">  GtkTreeIter iter;</a>
<a name="ln951">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(widget));</a>
<a name="ln952">  GtkTreePath *path;</a>
<a name="ln953">  GSList *remapped;</a>
<a name="ln954">  dt_accel_t query;</a>
<a name="ln955"> </a>
<a name="ln956">  gchar accel[256];</a>
<a name="ln957">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln958">  gchar accelpath[PATH_MAX] = { 0 };</a>
<a name="ln959"> </a>
<a name="ln960">  // We can just ignore mod key presses outright</a>
<a name="ln961">  if(event-&gt;is_modifier) return FALSE;</a>
<a name="ln962"> </a>
<a name="ln963">  dt_loc_get_user_config_dir(datadir, sizeof(datadir));</a>
<a name="ln964">  snprintf(accelpath, sizeof(accelpath), &quot;%s/keyboardrc&quot;, datadir);</a>
<a name="ln965"> </a>
<a name="ln966">  // Otherwise, determine whether we're in remap mode or not</a>
<a name="ln967">  if(darktable.control-&gt;accel_remap_str)</a>
<a name="ln968">  {</a>
<a name="ln969">    // Change the accel map entry</a>
<a name="ln970">    if(gtk_accel_map_change_entry(darktable.control-&gt;accel_remap_str, gdk_keyval_to_lower(event-&gt;keyval),</a>
<a name="ln971">                                  event-&gt;state &amp; KEY_STATE_MASK, TRUE))</a>
<a name="ln972">    {</a>
<a name="ln973">      // If it succeeded delete any conflicting accelerators</a>
<a name="ln974">      // First locate the accel list entry</a>
<a name="ln975">      g_strlcpy(query.path, darktable.control-&gt;accel_remap_str, sizeof(query.path));</a>
<a name="ln976">      remapped = g_slist_find_custom(darktable.control-&gt;accelerator_list, (gpointer)&amp;query, _accelcmp);</a>
<a name="ln977"> </a>
<a name="ln978">      // Then remove conflicts</a>
<a name="ln979">      g_slist_foreach(darktable.control-&gt;accelerator_list, delete_matching_accels, (gpointer)(remapped-&gt;data));</a>
<a name="ln980">    }</a>
<a name="ln981"> </a>
<a name="ln982"> </a>
<a name="ln983"> </a>
<a name="ln984">    // Then update the text in the A_BINDING_COLUMN of each row</a>
<a name="ln985">    update_accels_model(NULL, model);</a>
<a name="ln986"> </a>
<a name="ln987">    // Finally clear the remap state</a>
<a name="ln988">    darktable.control-&gt;accel_remap_str = NULL;</a>
<a name="ln989">    gtk_tree_path_free(darktable.control-&gt;accel_remap_path);</a>
<a name="ln990">    darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln991"> </a>
<a name="ln992">    // Save the changed keybindings</a>
<a name="ln993">    gtk_accel_map_save(accelpath);</a>
<a name="ln994"> </a>
<a name="ln995">    return TRUE;</a>
<a name="ln996">  }</a>
<a name="ln997">  else if(event-&gt;keyval == GDK_KEY_BackSpace)</a>
<a name="ln998">  {</a>
<a name="ln999">    // If a leaf node is selected, clear that accelerator</a>
<a name="ln1000"> </a>
<a name="ln1001">    // If nothing is selected, or branch node selected, just return</a>
<a name="ln1002">    if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)</a>
<a name="ln1003">       || gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln1004">      return FALSE;</a>
<a name="ln1005"> </a>
<a name="ln1006">    // Otherwise, construct the proper accelerator path and delete its entry</a>
<a name="ln1007">    g_strlcpy(accel, &quot;&lt;Darktable&gt;&quot;, sizeof(accel));</a>
<a name="ln1008">    path = gtk_tree_model_get_path(model, &amp;iter);</a>
<a name="ln1009">    path_to_accel(model, path, accel, sizeof(accel));</a>
<a name="ln1010">    gtk_tree_path_free(path);</a>
<a name="ln1011"> </a>
<a name="ln1012">    gtk_accel_map_change_entry(accel, 0, 0, TRUE);</a>
<a name="ln1013">    update_accels_model(NULL, model);</a>
<a name="ln1014"> </a>
<a name="ln1015">    // Saving the changed bindings</a>
<a name="ln1016">    gtk_accel_map_save(accelpath);</a>
<a name="ln1017"> </a>
<a name="ln1018">    return TRUE;</a>
<a name="ln1019">  }</a>
<a name="ln1020">  else</a>
<a name="ln1021">  {</a>
<a name="ln1022">    return FALSE;</a>
<a name="ln1023">  }</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026">static gboolean tree_key_press_presets(GtkWidget *widget, GdkEventKey *event, gpointer data)</a>
<a name="ln1027">{</a>
<a name="ln1028"> </a>
<a name="ln1029">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln1030">  GtkTreeIter iter;</a>
<a name="ln1031">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(widget));</a>
<a name="ln1032"> </a>
<a name="ln1033">  // We can just ignore mod key presses outright</a>
<a name="ln1034">  if(event-&gt;is_modifier) return FALSE;</a>
<a name="ln1035"> </a>
<a name="ln1036">  if(event-&gt;keyval == GDK_KEY_Delete || event-&gt;keyval == GDK_KEY_BackSpace)</a>
<a name="ln1037">  {</a>
<a name="ln1038">    // If a leaf node is selected, delete that preset</a>
<a name="ln1039"> </a>
<a name="ln1040">    // If nothing is selected, or branch node selected, just return</a>
<a name="ln1041">    if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)</a>
<a name="ln1042">       || gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln1043">      return FALSE;</a>
<a name="ln1044"> </a>
<a name="ln1045">    // For leaf nodes, open delete confirmation window if the preset is not writeprotected</a>
<a name="ln1046">    gint rowid;</a>
<a name="ln1047">    gchar *name;</a>
<a name="ln1048">    GdkPixbuf *editable;</a>
<a name="ln1049">    gtk_tree_model_get(model, &amp;iter, P_ROWID_COLUMN, &amp;rowid, P_NAME_COLUMN, &amp;name, P_EDITABLE_COLUMN,</a>
<a name="ln1050">                       &amp;editable, -1);</a>
<a name="ln1051">    if(editable == NULL)</a>
<a name="ln1052">    {</a>
<a name="ln1053">      sqlite3_stmt *stmt;</a>
<a name="ln1054"> </a>
<a name="ln1055">      GtkWidget *window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1056">      GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(window), GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln1057">                                                 GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1058">                                                 _(&quot;do you really want to delete the preset `%s'?&quot;), name);</a>
<a name="ln1059">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1060">      dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1061">#endif</a>
<a name="ln1062">      gtk_window_set_title(GTK_WINDOW(dialog), _(&quot;delete preset?&quot;));</a>
<a name="ln1063">      if(gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_YES)</a>
<a name="ln1064">      {</a>
<a name="ln1065">        // TODO: remove accel</a>
<a name="ln1066">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1067">                                    &quot;DELETE FROM data.presets WHERE rowid=?1 AND writeprotect=0&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1068">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, rowid);</a>
<a name="ln1069">        sqlite3_step(stmt);</a>
<a name="ln1070">        sqlite3_finalize(stmt);</a>
<a name="ln1071">        GtkTreeStore *tree_store = GTK_TREE_STORE(model);</a>
<a name="ln1072">        gtk_tree_store_clear(tree_store);</a>
<a name="ln1073">        tree_insert_presets(tree_store);</a>
<a name="ln1074">      }</a>
<a name="ln1075">      gtk_widget_destroy(dialog);</a>
<a name="ln1076">    }</a>
<a name="ln1077">    else</a>
<a name="ln1078">      g_object_unref(editable);</a>
<a name="ln1079">    g_free(name);</a>
<a name="ln1080"> </a>
<a name="ln1081">    return TRUE;</a>
<a name="ln1082">  }</a>
<a name="ln1083">  else</a>
<a name="ln1084">  {</a>
<a name="ln1085">    return FALSE;</a>
<a name="ln1086">  }</a>
<a name="ln1087">}</a>
<a name="ln1088"> </a>
<a name="ln1089">static void import_export(GtkButton *button, gpointer data)</a>
<a name="ln1090">{</a>
<a name="ln1091">  GtkWidget *chooser;</a>
<a name="ln1092">  gchar confdir[PATH_MAX] = { 0 };</a>
<a name="ln1093">  gchar accelpath[PATH_MAX] = { 0 };</a>
<a name="ln1094"> </a>
<a name="ln1095">  if(data)</a>
<a name="ln1096">  {</a>
<a name="ln1097">    // Non-zero value indicates export</a>
<a name="ln1098">    chooser = gtk_file_chooser_dialog_new(_(&quot;select file to export&quot;), NULL, GTK_FILE_CHOOSER_ACTION_SAVE,</a>
<a name="ln1099">                                          _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL, _(&quot;_save&quot;), GTK_RESPONSE_ACCEPT,</a>
<a name="ln1100">                                          NULL);</a>
<a name="ln1101">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1102">    dt_osx_disallow_fullscreen(chooser);</a>
<a name="ln1103">#endif</a>
<a name="ln1104">    gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(chooser), TRUE);</a>
<a name="ln1105">    gchar *exported_path = dt_conf_get_string(&quot;ui_last/exported_path&quot;);</a>
<a name="ln1106">    if(exported_path != NULL)</a>
<a name="ln1107">    {</a>
<a name="ln1108">      gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), exported_path);</a>
<a name="ln1109">      g_free(exported_path);</a>
<a name="ln1110">    }</a>
<a name="ln1111">    gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(chooser), &quot;keyboardrc&quot;);</a>
<a name="ln1112">    if(gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1113">    {</a>
<a name="ln1114">      gtk_accel_map_save(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)));</a>
<a name="ln1115">      gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(chooser));</a>
<a name="ln1116">      dt_conf_set_string(&quot;ui_last/export_path&quot;, folder);</a>
<a name="ln1117">      g_free(folder);</a>
<a name="ln1118">    }</a>
<a name="ln1119">    gtk_widget_destroy(chooser);</a>
<a name="ln1120">  }</a>
<a name="ln1121">  else</a>
<a name="ln1122">  {</a>
<a name="ln1123">    // Zero value indicates import</a>
<a name="ln1124">    chooser = gtk_file_chooser_dialog_new(_(&quot;select file to import&quot;), NULL, GTK_FILE_CHOOSER_ACTION_OPEN,</a>
<a name="ln1125">                                          _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT,</a>
<a name="ln1126">                                          NULL);</a>
<a name="ln1127">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1128">    dt_osx_disallow_fullscreen(chooser);</a>
<a name="ln1129">#endif</a>
<a name="ln1130"> </a>
<a name="ln1131">    gchar *import_path = dt_conf_get_string(&quot;ui_last/import_path&quot;);</a>
<a name="ln1132">    if(import_path != NULL)</a>
<a name="ln1133">    {</a>
<a name="ln1134">      gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), import_path);</a>
<a name="ln1135">      g_free(import_path);</a>
<a name="ln1136">    }</a>
<a name="ln1137">    if(gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1138">    {</a>
<a name="ln1139">      if(g_file_test(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)), G_FILE_TEST_EXISTS))</a>
<a name="ln1140">      {</a>
<a name="ln1141">        // Loading the file</a>
<a name="ln1142">        gtk_accel_map_load(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)));</a>
<a name="ln1143"> </a>
<a name="ln1144">        // Saving to the permanent keyboardrc</a>
<a name="ln1145">        dt_loc_get_user_config_dir(confdir, sizeof(confdir));</a>
<a name="ln1146">        snprintf(accelpath, sizeof(accelpath), &quot;%s/keyboardrc&quot;, confdir);</a>
<a name="ln1147">        gtk_accel_map_save(accelpath);</a>
<a name="ln1148"> </a>
<a name="ln1149">        gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(chooser));</a>
<a name="ln1150">        dt_conf_set_string(&quot;ui_last/import_path&quot;, folder);</a>
<a name="ln1151">        g_free(folder);</a>
<a name="ln1152">      }</a>
<a name="ln1153">    }</a>
<a name="ln1154">    gtk_widget_destroy(chooser);</a>
<a name="ln1155">  }</a>
<a name="ln1156">}</a>
<a name="ln1157"> </a>
<a name="ln1158">static void restore_defaults(GtkButton *button, gpointer data)</a>
<a name="ln1159">{</a>
<a name="ln1160">  GList *ops;</a>
<a name="ln1161">  dt_iop_module_so_t *op;</a>
<a name="ln1162">  gchar accelpath[256];</a>
<a name="ln1163">  gchar dir[PATH_MAX] = { 0 };</a>
<a name="ln1164">  gchar path[PATH_MAX] = { 0 };</a>
<a name="ln1165"> </a>
<a name="ln1166">  GtkWidget *message</a>
<a name="ln1167">      = gtk_message_dialog_new(NULL, GTK_DIALOG_MODAL, GTK_MESSAGE_WARNING, GTK_BUTTONS_OK_CANCEL,</a>
<a name="ln1168">                               _(&quot;are you sure you want to restore the default keybindings?  this will &quot;</a>
<a name="ln1169">                                 &quot;erase any modifications you have made.&quot;));</a>
<a name="ln1170">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1171">  dt_osx_disallow_fullscreen(message);</a>
<a name="ln1172">#endif</a>
<a name="ln1173">  if(gtk_dialog_run(GTK_DIALOG(message)) == GTK_RESPONSE_OK)</a>
<a name="ln1174">  {</a>
<a name="ln1175">    // First load the default keybindings for immediate effect</a>
<a name="ln1176">    dt_loc_get_user_config_dir(dir, sizeof(dir));</a>
<a name="ln1177">    snprintf(path, sizeof(path), &quot;%s/keyboardrc_default&quot;, dir);</a>
<a name="ln1178">    gtk_accel_map_load(path);</a>
<a name="ln1179"> </a>
<a name="ln1180">    // Now deleting any iop show shortcuts</a>
<a name="ln1181">    ops = darktable.iop;</a>
<a name="ln1182">    while(ops)</a>
<a name="ln1183">    {</a>
<a name="ln1184">      op = (dt_iop_module_so_t *)ops-&gt;data;</a>
<a name="ln1185">      snprintf(accelpath, sizeof(accelpath), &quot;&lt;Darktable&gt;/darkroom/modules/%s/show&quot;, op-&gt;op);</a>
<a name="ln1186">      gtk_accel_map_change_entry(accelpath, 0, 0, TRUE);</a>
<a name="ln1187">      ops = g_list_next(ops);</a>
<a name="ln1188">    }</a>
<a name="ln1189"> </a>
<a name="ln1190">    // Then delete any changes to the user's keyboardrc so it gets reset</a>
<a name="ln1191">    // on next startup</a>
<a name="ln1192">    dt_loc_get_user_config_dir(dir, sizeof(dir));</a>
<a name="ln1193">    snprintf(path, sizeof(path), &quot;%s/keyboardrc&quot;, dir);</a>
<a name="ln1194"> </a>
<a name="ln1195">    GFile *gpath = g_file_new_for_path(path);</a>
<a name="ln1196">    g_file_delete(gpath, NULL, NULL);</a>
<a name="ln1197">    g_object_unref(gpath);</a>
<a name="ln1198">  }</a>
<a name="ln1199">  gtk_widget_destroy(message);</a>
<a name="ln1200">}</a>
<a name="ln1201"> </a>
<a name="ln1202">static void import_preset(GtkButton *button, gpointer data)</a>
<a name="ln1203">{</a>
<a name="ln1204">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln1205">  GtkWidget *chooser;</a>
<a name="ln1206"> </a>
<a name="ln1207">  // Zero value indicates import</a>
<a name="ln1208">  chooser = gtk_file_chooser_dialog_new(_(&quot;select preset to import&quot;), NULL, GTK_FILE_CHOOSER_ACTION_OPEN,</a>
<a name="ln1209">                                        _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT,</a>
<a name="ln1210">                                        NULL);</a>
<a name="ln1211">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1212">  dt_osx_disallow_fullscreen(chooser);</a>
<a name="ln1213">#endif</a>
<a name="ln1214"> </a>
<a name="ln1215">  gchar *import_path = dt_conf_get_string(&quot;ui_last/import_path&quot;);</a>
<a name="ln1216">  if(import_path != NULL)</a>
<a name="ln1217">  {</a>
<a name="ln1218">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), import_path);</a>
<a name="ln1219">    g_free(import_path);</a>
<a name="ln1220">  }</a>
<a name="ln1221">  if(gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1222">  {</a>
<a name="ln1223">    if(g_file_test(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)), G_FILE_TEST_EXISTS))</a>
<a name="ln1224">    {</a>
<a name="ln1225">      if(dt_presets_import_from_file(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser))))</a>
<a name="ln1226">      {</a>
<a name="ln1227">        dt_control_log(_(&quot;failed to import preset&quot;));</a>
<a name="ln1228">      }</a>
<a name="ln1229">      else</a>
<a name="ln1230">      {</a>
<a name="ln1231">        GtkTreeStore *tree_store = GTK_TREE_STORE(model);</a>
<a name="ln1232">        gtk_tree_store_clear(tree_store);</a>
<a name="ln1233">        tree_insert_presets(tree_store);</a>
<a name="ln1234">      }</a>
<a name="ln1235"> </a>
<a name="ln1236">      gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(chooser));</a>
<a name="ln1237">      dt_conf_set_string(&quot;ui_last/import_path&quot;, folder);</a>
<a name="ln1238">      g_free(folder);</a>
<a name="ln1239">    }</a>
<a name="ln1240">  }</a>
<a name="ln1241">  gtk_widget_destroy(chooser);</a>
<a name="ln1242">}</a>
<a name="ln1243"> </a>
<a name="ln1244">static gboolean prefix_search(GtkTreeModel *model, gint column, const gchar *key, GtkTreeIter *iter,</a>
<a name="ln1245">                              gpointer d)</a>
<a name="ln1246">{</a>
<a name="ln1247">  gchar *row_data;</a>
<a name="ln1248"> </a>
<a name="ln1249">  gtk_tree_model_get(model, iter, A_TRANS_COLUMN, &amp;row_data, -1);</a>
<a name="ln1250">  while(*key != '\0')</a>
<a name="ln1251">  {</a>
<a name="ln1252">    if(*row_data != *key) return TRUE;</a>
<a name="ln1253">    key++;</a>
<a name="ln1254">    row_data++;</a>
<a name="ln1255">  }</a>
<a name="ln1256">  return FALSE;</a>
<a name="ln1257">}</a>
<a name="ln1258"> </a>
<a name="ln1259">// Custom sort function for TreeModel entries for accels list</a>
<a name="ln1260">static gint compare_rows_accels(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data)</a>
<a name="ln1261">{</a>
<a name="ln1262">  gchar *a_text;</a>
<a name="ln1263">  gchar *b_text;</a>
<a name="ln1264"> </a>
<a name="ln1265">  // First prioritize branch nodes over leaves</a>
<a name="ln1266">  if(gtk_tree_model_iter_has_child(model, a) &amp;&amp; !gtk_tree_model_iter_has_child(model, b)) return -1;</a>
<a name="ln1267"> </a>
<a name="ln1268">  if(gtk_tree_model_iter_has_child(model, b) &amp;&amp; !gtk_tree_model_iter_has_child(model, a)) return 1;</a>
<a name="ln1269"> </a>
<a name="ln1270">  // Otherwise just return alphabetical order</a>
<a name="ln1271">  gtk_tree_model_get(model, a, A_TRANS_COLUMN, &amp;a_text, -1);</a>
<a name="ln1272">  gtk_tree_model_get(model, b, A_TRANS_COLUMN, &amp;b_text, -1);</a>
<a name="ln1273"> </a>
<a name="ln1274">  const int res = strcasecmp(a_text, b_text);</a>
<a name="ln1275"> </a>
<a name="ln1276">  g_free(a_text);</a>
<a name="ln1277">  g_free(b_text);</a>
<a name="ln1278"> </a>
<a name="ln1279">  return res;</a>
<a name="ln1280">}</a>
<a name="ln1281"> </a>
<a name="ln1282">// Custom sort function for TreeModel entries for presets list</a>
<a name="ln1283">static gint compare_rows_presets(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data)</a>
<a name="ln1284">{</a>
<a name="ln1285">  gchar *a_text;</a>
<a name="ln1286">  gchar *b_text;</a>
<a name="ln1287"> </a>
<a name="ln1288">  gtk_tree_model_get(model, a, P_MODULE_COLUMN, &amp;a_text, -1);</a>
<a name="ln1289">  gtk_tree_model_get(model, b, P_MODULE_COLUMN, &amp;b_text, -1);</a>
<a name="ln1290">  if(*a_text == '\0' &amp;&amp; *b_text == '\0')</a>
<a name="ln1291">  {</a>
<a name="ln1292">    g_free(a_text);</a>
<a name="ln1293">    g_free(b_text);</a>
<a name="ln1294"> </a>
<a name="ln1295">    gtk_tree_model_get(model, a, P_NAME_COLUMN, &amp;a_text, -1);</a>
<a name="ln1296">    gtk_tree_model_get(model, b, P_NAME_COLUMN, &amp;b_text, -1);</a>
<a name="ln1297">  }</a>
<a name="ln1298"> </a>
<a name="ln1299">  const int res = strcasecmp(a_text, b_text);</a>
<a name="ln1300"> </a>
<a name="ln1301">  g_free(a_text);</a>
<a name="ln1302">  g_free(b_text);</a>
<a name="ln1303"> </a>
<a name="ln1304">  return res;</a>
<a name="ln1305">}</a>
<a name="ln1306"> </a>
<a name="ln1307">// FIXME: Mostly c&amp;p from gui/presets.c</a>
<a name="ln1308">static void check_buttons_activated(GtkCheckButton *button, dt_gui_presets_edit_dialog_t *g)</a>
<a name="ln1309">{</a>
<a name="ln1310">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;autoapply))</a>
<a name="ln1311">     || gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;filter)))</a>
<a name="ln1312">  {</a>
<a name="ln1313">    gtk_widget_set_visible(GTK_WIDGET(g-&gt;details), TRUE);</a>
<a name="ln1314">    gtk_widget_set_no_show_all(GTK_WIDGET(g-&gt;details), FALSE);</a>
<a name="ln1315">    gtk_widget_show_all(GTK_WIDGET(g-&gt;details));</a>
<a name="ln1316">    gtk_widget_set_no_show_all(GTK_WIDGET(g-&gt;details), TRUE);</a>
<a name="ln1317">  }</a>
<a name="ln1318">  else</a>
<a name="ln1319">    gtk_widget_set_visible(GTK_WIDGET(g-&gt;details), FALSE);</a>
<a name="ln1320">}</a>
<a name="ln1321"> </a>
<a name="ln1322">static void edit_preset(GtkTreeView *tree, const gint rowid, const gchar *name, const gchar *module)</a>
<a name="ln1323">{</a>
<a name="ln1324">  GtkWidget *dialog;</a>
<a name="ln1325">  /* Create the widgets */</a>
<a name="ln1326">  char title[1024];</a>
<a name="ln1327">  snprintf(title, sizeof(title), _(&quot;edit `%s' for module `%s'&quot;), name, module);</a>
<a name="ln1328">  dialog = gtk_dialog_new_with_buttons(title, GTK_WINDOW(_preferences_dialog),</a>
<a name="ln1329">                                       GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,</a>
<a name="ln1330">                                       _(&quot;_save&quot;), GTK_RESPONSE_YES,</a>
<a name="ln1331">                                       _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL,</a>
<a name="ln1332">                                       _(&quot;_ok&quot;), GTK_RESPONSE_OK, NULL);</a>
<a name="ln1333">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1334">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1335">#endif</a>
<a name="ln1336">  GtkContainer *content_area = GTK_CONTAINER(gtk_dialog_get_content_area(GTK_DIALOG(dialog)));</a>
<a name="ln1337">  GtkBox *box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 5));</a>
<a name="ln1338">  gtk_widget_set_margin_top(GTK_WIDGET(box), DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln1339">  gtk_widget_set_margin_bottom(GTK_WIDGET(box), DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln1340">  gtk_widget_set_margin_start(GTK_WIDGET(box), DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln1341">  gtk_widget_set_margin_end(GTK_WIDGET(box), DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln1342">  gtk_container_add(content_area, GTK_WIDGET(box));</a>
<a name="ln1343">  GtkWidget *label;</a>
<a name="ln1344"> </a>
<a name="ln1345">  dt_gui_presets_edit_dialog_t *g</a>
<a name="ln1346">      = (dt_gui_presets_edit_dialog_t *)malloc(sizeof(dt_gui_presets_edit_dialog_t));</a>
<a name="ln1347">  g-&gt;rowid = rowid;</a>
<a name="ln1348">  g-&gt;tree = tree;</a>
<a name="ln1349">  g-&gt;name = GTK_LABEL(gtk_label_new(name));</a>
<a name="ln1350">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;name), FALSE, FALSE, 0);</a>
<a name="ln1351"> </a>
<a name="ln1352">  g-&gt;description = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1353">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;description), FALSE, FALSE, 0);</a>
<a name="ln1354">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;description), _(&quot;description or further information&quot;));</a>
<a name="ln1355"> </a>
<a name="ln1356">  g-&gt;autoapply</a>
<a name="ln1357">      = GTK_CHECK_BUTTON(gtk_check_button_new_with_label(_(&quot;auto apply this preset to matching images&quot;)));</a>
<a name="ln1358">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;autoapply), FALSE, FALSE, 0);</a>
<a name="ln1359">  g-&gt;filter</a>
<a name="ln1360">      = GTK_CHECK_BUTTON(gtk_check_button_new_with_label(_(&quot;only show this preset for matching images&quot;)));</a>
<a name="ln1361">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;filter),</a>
<a name="ln1362">                              _(&quot;be very careful with this option. this might be the last time you see your preset.&quot;));</a>
<a name="ln1363">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;filter), FALSE, FALSE, 0);</a>
<a name="ln1364">  g_signal_connect(G_OBJECT(g-&gt;autoapply), &quot;toggled&quot;, G_CALLBACK(check_buttons_activated), g);</a>
<a name="ln1365">  g_signal_connect(G_OBJECT(g-&gt;filter), &quot;toggled&quot;, G_CALLBACK(check_buttons_activated), g);</a>
<a name="ln1366"> </a>
<a name="ln1367">  int line = 0;</a>
<a name="ln1368">  g-&gt;details = gtk_grid_new();</a>
<a name="ln1369">  gtk_grid_set_row_spacing(GTK_GRID(g-&gt;details), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln1370">  gtk_grid_set_column_spacing(GTK_GRID(g-&gt;details), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln1371">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;details), FALSE, FALSE, 0);</a>
<a name="ln1372"> </a>
<a name="ln1373">  // model, maker, lens</a>
<a name="ln1374">  g-&gt;model = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1375">  /* xgettext:no-c-format */</a>
<a name="ln1376">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;model), _(&quot;string to match model (use % as wildcard)&quot;));</a>
<a name="ln1377">  label = gtk_label_new(_(&quot;model&quot;));</a>
<a name="ln1378">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1379">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1380">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;model), label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1381"> </a>
<a name="ln1382">  g-&gt;maker = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1383">  /* xgettext:no-c-format */</a>
<a name="ln1384">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;maker), _(&quot;string to match maker (use % as wildcard)&quot;));</a>
<a name="ln1385">  label = gtk_label_new(_(&quot;maker&quot;));</a>
<a name="ln1386">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1387">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1388">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;maker), label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1389"> </a>
<a name="ln1390">  g-&gt;lens = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1391">  /* xgettext:no-c-format */</a>
<a name="ln1392">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;lens), _(&quot;string to match lens (use % as wildcard)&quot;));</a>
<a name="ln1393">  label = gtk_label_new(_(&quot;lens&quot;));</a>
<a name="ln1394">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1395">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1396">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;lens), label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1397"> </a>
<a name="ln1398">  // iso</a>
<a name="ln1399">  label = gtk_label_new(_(&quot;ISO&quot;));</a>
<a name="ln1400">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1401">  g-&gt;iso_min = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, FLT_MAX, 100));</a>
<a name="ln1402">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;iso_min), _(&quot;minimum ISO value&quot;));</a>
<a name="ln1403">  gtk_spin_button_set_digits(g-&gt;iso_min, 0);</a>
<a name="ln1404">  g-&gt;iso_max = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, FLT_MAX, 100));</a>
<a name="ln1405">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;iso_max), _(&quot;maximum ISO value&quot;));</a>
<a name="ln1406">  gtk_spin_button_set_digits(g-&gt;iso_max, 0);</a>
<a name="ln1407">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1408">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;iso_min), label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1409">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;iso_max), GTK_WIDGET(g-&gt;iso_min), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1410"> </a>
<a name="ln1411">  // exposure</a>
<a name="ln1412">  label = gtk_label_new(_(&quot;exposure&quot;));</a>
<a name="ln1413">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1414">  g-&gt;exposure_min = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1415">  g-&gt;exposure_max = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1416">  gtk_widget_set_tooltip_text(g-&gt;exposure_min, _(&quot;minimum exposure time&quot;));</a>
<a name="ln1417">  gtk_widget_set_tooltip_text(g-&gt;exposure_max, _(&quot;maximum exposure time&quot;));</a>
<a name="ln1418">  for(int k = 0; k &lt; dt_gui_presets_exposure_value_cnt; k++)</a>
<a name="ln1419">    dt_bauhaus_combobox_add(g-&gt;exposure_min, dt_gui_presets_exposure_value_str[k]);</a>
<a name="ln1420">  for(int k = 0; k &lt; dt_gui_presets_exposure_value_cnt; k++)</a>
<a name="ln1421">    dt_bauhaus_combobox_add(g-&gt;exposure_max, dt_gui_presets_exposure_value_str[k]);</a>
<a name="ln1422">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1423">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;exposure_min, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1424">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;exposure_max, g-&gt;exposure_min, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1425"> </a>
<a name="ln1426">  // aperture</a>
<a name="ln1427">  label = gtk_label_new(_(&quot;aperture&quot;));</a>
<a name="ln1428">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1429">  g-&gt;aperture_min = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1430">  g-&gt;aperture_max = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1431">  gtk_widget_set_tooltip_text(g-&gt;aperture_min, _(&quot;minimum aperture value&quot;));</a>
<a name="ln1432">  gtk_widget_set_tooltip_text(g-&gt;aperture_max, _(&quot;maximum aperture value&quot;));</a>
<a name="ln1433">  for(int k = 0; k &lt; dt_gui_presets_aperture_value_cnt; k++)</a>
<a name="ln1434">    dt_bauhaus_combobox_add(g-&gt;aperture_min, dt_gui_presets_aperture_value_str[k]);</a>
<a name="ln1435">  for(int k = 0; k &lt; dt_gui_presets_aperture_value_cnt; k++)</a>
<a name="ln1436">    dt_bauhaus_combobox_add(g-&gt;aperture_max, dt_gui_presets_aperture_value_str[k]);</a>
<a name="ln1437">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1438">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;aperture_min, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1439">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;aperture_max, g-&gt;aperture_min, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1440"> </a>
<a name="ln1441">  // focal length</a>
<a name="ln1442">  label = gtk_label_new(_(&quot;focal length&quot;));</a>
<a name="ln1443">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1444">  g-&gt;focal_length_min = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, 1000, 10));</a>
<a name="ln1445">  gtk_spin_button_set_digits(g-&gt;focal_length_min, 0);</a>
<a name="ln1446">  g-&gt;focal_length_max = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, 1000, 10));</a>
<a name="ln1447">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;focal_length_min), _(&quot;minimum focal length&quot;));</a>
<a name="ln1448">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;focal_length_max), _(&quot;maximum focal length&quot;));</a>
<a name="ln1449">  gtk_spin_button_set_digits(g-&gt;focal_length_max, 0);</a>
<a name="ln1450">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1451">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;focal_length_min), label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1452">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;focal_length_max), GTK_WIDGET(g-&gt;focal_length_min), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1453">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;focal_length_min), TRUE);</a>
<a name="ln1454">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;focal_length_max), TRUE);</a>
<a name="ln1455"> </a>
<a name="ln1456">  // raw/hdr/ldr</a>
<a name="ln1457">  label = gtk_label_new(_(&quot;format&quot;));</a>
<a name="ln1458">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1459">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line, 1, 1);</a>
<a name="ln1460"> </a>
<a name="ln1461">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1462">  {</a>
<a name="ln1463">    g-&gt;format_btn[i] = gtk_check_button_new_with_label(_(dt_gui_presets_format_value_str[i]));</a>
<a name="ln1464">    gtk_grid_attach(GTK_GRID(g-&gt;details), g-&gt;format_btn[i], 1, line + i, 2, 1);</a>
<a name="ln1465">  }</a>
<a name="ln1466"> </a>
<a name="ln1467">  gtk_widget_set_no_show_all(GTK_WIDGET(g-&gt;details), TRUE);</a>
<a name="ln1468"> </a>
<a name="ln1469">  sqlite3_stmt *stmt;</a>
<a name="ln1470">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1471">                              &quot;SELECT description, model, maker, lens, iso_min, iso_max, exposure_min, &quot;</a>
<a name="ln1472">                              &quot;exposure_max, aperture_min, aperture_max, focal_length_min, focal_length_max, &quot;</a>
<a name="ln1473">                              &quot;autoapply, filter, format FROM data.presets WHERE rowid = ?1&quot;,</a>
<a name="ln1474">                              -1, &amp;stmt, NULL);</a>
<a name="ln1475">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, rowid);</a>
<a name="ln1476">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1477">  {</a>
<a name="ln1478">    gtk_entry_set_text(g-&gt;description, (const char *)sqlite3_column_text(stmt, 0));</a>
<a name="ln1479">    gtk_entry_set_text(g-&gt;model, (const char *)sqlite3_column_text(stmt, 1));</a>
<a name="ln1480">    gtk_entry_set_text(g-&gt;maker, (const char *)sqlite3_column_text(stmt, 2));</a>
<a name="ln1481">    gtk_entry_set_text(g-&gt;lens, (const char *)sqlite3_column_text(stmt, 3));</a>
<a name="ln1482">    gtk_spin_button_set_value(g-&gt;iso_min, sqlite3_column_double(stmt, 4));</a>
<a name="ln1483">    gtk_spin_button_set_value(g-&gt;iso_max, sqlite3_column_double(stmt, 5));</a>
<a name="ln1484"> </a>
<a name="ln1485">    float val = sqlite3_column_double(stmt, 6);</a>
<a name="ln1486">    int k = 0;</a>
<a name="ln1487">    for(; k &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; val &gt; dt_gui_presets_exposure_value[k]; k++)</a>
<a name="ln1488">      ;</a>
<a name="ln1489">    dt_bauhaus_combobox_set(g-&gt;exposure_min, k);</a>
<a name="ln1490">    val = sqlite3_column_double(stmt, 7);</a>
<a name="ln1491">    for(k = 0; k &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; val &gt; dt_gui_presets_exposure_value[k]; k++)</a>
<a name="ln1492">      ;</a>
<a name="ln1493">    dt_bauhaus_combobox_set(g-&gt;exposure_max, k);</a>
<a name="ln1494">    val = sqlite3_column_double(stmt, 8);</a>
<a name="ln1495">    for(k = 0; k &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; val &gt; dt_gui_presets_aperture_value[k]; k++)</a>
<a name="ln1496">      ;</a>
<a name="ln1497">    dt_bauhaus_combobox_set(g-&gt;aperture_min, k);</a>
<a name="ln1498">    val = sqlite3_column_double(stmt, 9);</a>
<a name="ln1499">    for(k = 0; k &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; val &gt; dt_gui_presets_aperture_value[k]; k++)</a>
<a name="ln1500">      ;</a>
<a name="ln1501">    dt_bauhaus_combobox_set(g-&gt;aperture_max, k);</a>
<a name="ln1502">    gtk_spin_button_set_value(g-&gt;focal_length_min, sqlite3_column_double(stmt, 10));</a>
<a name="ln1503">    gtk_spin_button_set_value(g-&gt;focal_length_max, sqlite3_column_double(stmt, 11));</a>
<a name="ln1504">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;autoapply), sqlite3_column_int(stmt, 12));</a>
<a name="ln1505">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;filter), sqlite3_column_int(stmt, 13));</a>
<a name="ln1506">    const int format = sqlite3_column_int(stmt, 14);</a>
<a name="ln1507">    for(k = 0; k &lt; 3; k++)</a>
<a name="ln1508">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;format_btn[k]), format &amp; (dt_gui_presets_format_flag[k]));</a>
<a name="ln1509">  }</a>
<a name="ln1510">  sqlite3_finalize(stmt);</a>
<a name="ln1511"> </a>
<a name="ln1512">  g_signal_connect(dialog, &quot;response&quot;, G_CALLBACK(edit_preset_response), g);</a>
<a name="ln1513">  gtk_widget_show_all(dialog);</a>
<a name="ln1514">}</a>
<a name="ln1515"> </a>
<a name="ln1516">static void edit_preset_response(GtkDialog *dialog, gint response_id, dt_gui_presets_edit_dialog_t *g)</a>
<a name="ln1517">{</a>
<a name="ln1518">  // commit all the user input fields</a>
<a name="ln1519">  if(response_id == GTK_RESPONSE_OK)</a>
<a name="ln1520">  {</a>
<a name="ln1521">    sqlite3_stmt *stmt;</a>
<a name="ln1522">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1523">                                &quot;UPDATE data.presets SET description = ?1, model = ?2, maker = ?3, lens = ?4, &quot;</a>
<a name="ln1524">                                &quot;iso_min = ?5, iso_max = ?6, exposure_min = ?7, exposure_max = ?8, &quot;</a>
<a name="ln1525">                                &quot;aperture_min = ?9, aperture_max = ?10, focal_length_min = ?11, &quot;</a>
<a name="ln1526">                                &quot;focal_length_max = ?12, autoapply = ?13, filter = ?14, def = 0, format = ?15 &quot;</a>
<a name="ln1527">                                &quot;WHERE rowid = ?16&quot;,</a>
<a name="ln1528">                                -1, &amp;stmt, NULL);</a>
<a name="ln1529">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, gtk_entry_get_text(g-&gt;description), -1, SQLITE_TRANSIENT);</a>
<a name="ln1530">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, gtk_entry_get_text(g-&gt;model), -1, SQLITE_TRANSIENT);</a>
<a name="ln1531">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 3, gtk_entry_get_text(g-&gt;maker), -1, SQLITE_TRANSIENT);</a>
<a name="ln1532">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, gtk_entry_get_text(g-&gt;lens), -1, SQLITE_TRANSIENT);</a>
<a name="ln1533">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 5, gtk_spin_button_get_value(g-&gt;iso_min));</a>
<a name="ln1534">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 6, gtk_spin_button_get_value(g-&gt;iso_max));</a>
<a name="ln1535">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 7,</a>
<a name="ln1536">                                 dt_gui_presets_exposure_value[dt_bauhaus_combobox_get(g-&gt;exposure_min)]);</a>
<a name="ln1537">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 8,</a>
<a name="ln1538">                                 dt_gui_presets_exposure_value[dt_bauhaus_combobox_get(g-&gt;exposure_max)]);</a>
<a name="ln1539">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 9,</a>
<a name="ln1540">                                 dt_gui_presets_aperture_value[dt_bauhaus_combobox_get(g-&gt;aperture_min)]);</a>
<a name="ln1541">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 10,</a>
<a name="ln1542">                                 dt_gui_presets_aperture_value[dt_bauhaus_combobox_get(g-&gt;aperture_max)]);</a>
<a name="ln1543">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 11, gtk_spin_button_get_value(g-&gt;focal_length_min));</a>
<a name="ln1544">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 12, gtk_spin_button_get_value(g-&gt;focal_length_max));</a>
<a name="ln1545">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 13, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;autoapply)));</a>
<a name="ln1546">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 14, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;filter)));</a>
<a name="ln1547">    int format = 0;</a>
<a name="ln1548">    for(int k = 0; k &lt; 3; k++)</a>
<a name="ln1549">      format += gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;format_btn[k])) * dt_gui_presets_format_flag[k];</a>
<a name="ln1550">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 15, format);</a>
<a name="ln1551">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 16, g-&gt;rowid);</a>
<a name="ln1552">    sqlite3_step(stmt);</a>
<a name="ln1553">    sqlite3_finalize(stmt);</a>
<a name="ln1554">  }</a>
<a name="ln1555">  else if(response_id == GTK_RESPONSE_YES)</a>
<a name="ln1556">  {</a>
<a name="ln1557">    const gchar *name = gtk_label_get_text(g-&gt;name);</a>
<a name="ln1558"> </a>
<a name="ln1559">    // ask for destination directory</a>
<a name="ln1560"> </a>
<a name="ln1561">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1562">    GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1563">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1564">      GTK_RESPONSE_CANCEL, _(&quot;_select as output destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1565">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1566">    dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1567">#endif</a>
<a name="ln1568"> </a>
<a name="ln1569">    // save if accepted</a>
<a name="ln1570"> </a>
<a name="ln1571">    if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1572">    {</a>
<a name="ln1573">      char *filedir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1574">      dt_presets_save_to_file(g-&gt;rowid, name, filedir);</a>
<a name="ln1575">      dt_control_log(_(&quot;preset %s was successfully saved&quot;), name);</a>
<a name="ln1576">      g_free(filedir);</a>
<a name="ln1577">    }</a>
<a name="ln1578"> </a>
<a name="ln1579">    gtk_widget_destroy(GTK_WIDGET(filechooser));</a>
<a name="ln1580">  }</a>
<a name="ln1581"> </a>
<a name="ln1582">  GtkTreeStore *tree_store = GTK_TREE_STORE(gtk_tree_view_get_model(g-&gt;tree));</a>
<a name="ln1583">  gtk_tree_store_clear(tree_store);</a>
<a name="ln1584">  tree_insert_presets(tree_store);</a>
<a name="ln1585"> </a>
<a name="ln1586">  gtk_widget_destroy(GTK_WIDGET(dialog));</a>
<a name="ln1587">  free(g);</a>
<a name="ln1588">}</a>
<a name="ln1589"> </a>
<a name="ln1590">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1591">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1592">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="268"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'theme_name' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1347"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 1347, 1346.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
