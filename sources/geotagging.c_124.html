
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012 tobias ellinghaus.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">// #include &quot;common/darktable.h&quot;</a>
<a name="ln19">// #include &quot;control/control.h&quot;</a>
<a name="ln20">#include &quot;common/debug.h&quot;</a>
<a name="ln21">#include &quot;common/file_location.h&quot;</a>
<a name="ln22">#include &quot;common/image_cache.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">// #include &quot;gui/accelerators.h&quot;</a>
<a name="ln25">// #include &quot;gui/gtk.h&quot;</a>
<a name="ln26">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln27">// #include &quot;dtgtk/paint.h&quot;</a>
<a name="ln28">// #include &quot;libs/lib.h&quot;</a>
<a name="ln29">#include &quot;control/jobs.h&quot;</a>
<a name="ln30">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln31">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln32">#include &quot;osx/osx.h&quot;</a>
<a name="ln33">#endif</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">DT_MODULE(1)</a>
<a name="ln38"> </a>
<a name="ln39">typedef struct tz_tuple_t</a>
<a name="ln40">{</a>
<a name="ln41">  char *name, *display;</a>
<a name="ln42">} tz_tuple_t;</a>
<a name="ln43"> </a>
<a name="ln44">typedef struct dt_lib_geotagging_t</a>
<a name="ln45">{</a>
<a name="ln46">  GtkWidget *offset_entry;</a>
<a name="ln47">  GList *timezones;</a>
<a name="ln48">  GtkWidget *floating_window, *floating_window_ok, *floating_window_cancel, *floating_window_entry;</a>
<a name="ln49">} dt_lib_geotagging_t;</a>
<a name="ln50"> </a>
<a name="ln51">static void free_tz_tuple(gpointer data)</a>
<a name="ln52">{</a>
<a name="ln53">  tz_tuple_t *tz_tuple = (tz_tuple_t *)data;</a>
<a name="ln54">  g_free(tz_tuple-&gt;display);</a>
<a name="ln55">#ifdef _WIN32</a>
<a name="ln56">  g_free(tz_tuple-&gt;name); // on non-Windows both point to the same string</a>
<a name="ln57">#endif</a>
<a name="ln58">  free(tz_tuple);</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61">const char *name(dt_lib_module_t *self)</a>
<a name="ln62">{</a>
<a name="ln63">  return _(&quot;geotagging&quot;);</a>
<a name="ln64">}</a>
<a name="ln65"> </a>
<a name="ln66">const char **views(dt_lib_module_t *self)</a>
<a name="ln67">{</a>
<a name="ln68">  static const char *v[] = {&quot;lighttable&quot;, NULL};</a>
<a name="ln69">  return v;</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln73">{</a>
<a name="ln74">  return DT_UI_CONTAINER_PANEL_RIGHT_CENTER;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">int position()</a>
<a name="ln79">{</a>
<a name="ln80">  return 450;</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">/* try to parse the offset string. returns true if it worked, false otherwise.</a>
<a name="ln84"> *if seconds != NULL the offset will be put there in seconds or 0 if it failed. always look at the return</a>
<a name="ln85"> *value before using the seconds value! */</a>
<a name="ln86">static gboolean _lib_geotagging_parse_offset(const char *str, long int *seconds)</a>
<a name="ln87">{</a>
<a name="ln88">  const gchar *str_bak = str;</a>
<a name="ln89">  long int result = 0;</a>
<a name="ln90">  int numbers[3] = { 0, 0, 0 };</a>
<a name="ln91">  int fields = 0;</a>
<a name="ln92">  char sign = '+';</a>
<a name="ln93">  if(seconds) *seconds = 0;</a>
<a name="ln94"> </a>
<a name="ln95">  if(!str) return FALSE;</a>
<a name="ln96"> </a>
<a name="ln97">  size_t len = strlen(str);</a>
<a name="ln98"> </a>
<a name="ln99">  // optional sign</a>
<a name="ln100">  if(*str == '+' || *str == '-')</a>
<a name="ln101">  {</a>
<a name="ln102">    sign = *str;</a>
<a name="ln103">    str++;</a>
<a name="ln104">    len--;</a>
<a name="ln105">  }</a>
<a name="ln106"> </a>
<a name="ln107">  // hh, mm or ss</a>
<a name="ln108">  if(len &lt; 2) return FALSE;</a>
<a name="ln109">  if(!g_ascii_isdigit(str[0]) || !g_ascii_isdigit(str[1]))</a>
<a name="ln110">    return FALSE;</a>
<a name="ln111">  else</a>
<a name="ln112">  {</a>
<a name="ln113">    numbers[fields++] = 10 * (str[0] - '0') + (str[1] - '0');</a>
<a name="ln114">    str += 2;</a>
<a name="ln115">    len -= 2;</a>
<a name="ln116">  }</a>
<a name="ln117"> </a>
<a name="ln118">  // : or end</a>
<a name="ln119">  if(*str == '\0') goto parse_success;</a>
<a name="ln120">  if(*str == ':')</a>
<a name="ln121">  {</a>
<a name="ln122">    str++;</a>
<a name="ln123">    len--;</a>
<a name="ln124">  }</a>
<a name="ln125"> </a>
<a name="ln126">  // mm or ss</a>
<a name="ln127">  if(len &lt; 2) return FALSE;</a>
<a name="ln128">  if(!g_ascii_isdigit(str[0]) || !g_ascii_isdigit(str[1]))</a>
<a name="ln129">    return FALSE;</a>
<a name="ln130">  else</a>
<a name="ln131">  {</a>
<a name="ln132">    numbers[fields++] = 10 * (str[0] - '0') + (str[1] - '0');</a>
<a name="ln133">    str += 2;</a>
<a name="ln134">    len -= 2;</a>
<a name="ln135">  }</a>
<a name="ln136"> </a>
<a name="ln137">  // : or end</a>
<a name="ln138">  if(*str == '\0') goto parse_success;</a>
<a name="ln139">  if(*str == ':')</a>
<a name="ln140">  {</a>
<a name="ln141">    str++;</a>
<a name="ln142">    len--;</a>
<a name="ln143">  }</a>
<a name="ln144"> </a>
<a name="ln145">  // ss</a>
<a name="ln146">  if(len &lt; 2) return FALSE;</a>
<a name="ln147">  if(!g_ascii_isdigit(str[0]) || !g_ascii_isdigit(str[1]))</a>
<a name="ln148">    return FALSE;</a>
<a name="ln149">  else</a>
<a name="ln150">  {</a>
<a name="ln151">    numbers[fields++] = 10 * (str[0] - '0') + (str[1] - '0');</a>
<a name="ln152">    str += 2;</a>
<a name="ln153">//     len -= 2;</a>
<a name="ln154">  }</a>
<a name="ln155"> </a>
<a name="ln156">  // end</a>
<a name="ln157">  if(*str == '\0') goto parse_success;</a>
<a name="ln158"> </a>
<a name="ln159">  return FALSE;</a>
<a name="ln160"> </a>
<a name="ln161">parse_success:</a>
<a name="ln162">  if(seconds)</a>
<a name="ln163">  {</a>
<a name="ln164">    // assemble the numbers in numbers[] into a single seconds value</a>
<a name="ln165">    switch(fields)</a>
<a name="ln166">    {</a>
<a name="ln167">      case 1: // 0: seconds</a>
<a name="ln168">        result = numbers[0];</a>
<a name="ln169">        break;</a>
<a name="ln170">      case 2: // 0: minutes, 1: seconds</a>
<a name="ln171">        result = 60 * numbers[0] + numbers[1];</a>
<a name="ln172">        break;</a>
<a name="ln173">      case 3: // 0: hours, 1: minutes, 2: seconds</a>
<a name="ln174">        result = 60 * 60 * numbers[0] + 60 * numbers[1] + numbers[2];</a>
<a name="ln175">        break;</a>
<a name="ln176">      default: // shouldn't happen</a>
<a name="ln177">        fprintf(stderr, &quot;[geotagging] error: something went terribly wrong while parsing the offset, %d &quot;</a>
<a name="ln178">                        &quot;fields found in %s\n&quot;,</a>
<a name="ln179">                fields, str_bak);</a>
<a name="ln180">    }</a>
<a name="ln181"> </a>
<a name="ln182">    if(sign == '-') result *= -1;</a>
<a name="ln183">    *seconds = result;</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  return TRUE;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">static gboolean _lib_geotagging_offset_key_press(GtkWidget *entry, GdkEventKey *event, dt_lib_module_t *self)</a>
<a name="ln190">{</a>
<a name="ln191">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)self-&gt;data;</a>
<a name="ln192">  switch(event-&gt;keyval)</a>
<a name="ln193">  {</a>
<a name="ln194">    case GDK_KEY_Escape:</a>
<a name="ln195">    case GDK_KEY_Tab:</a>
<a name="ln196">    {</a>
<a name="ln197">      // reset</a>
<a name="ln198">      gchar *str = dt_conf_get_string(&quot;plugins/lighttable/geotagging/offset&quot;);</a>
<a name="ln199">      if(_lib_geotagging_parse_offset(str, NULL))</a>
<a name="ln200">      {</a>
<a name="ln201">        gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), str);</a>
<a name="ln202">      }</a>
<a name="ln203">      else</a>
<a name="ln204">      {</a>
<a name="ln205">        gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), &quot;+00:00:00&quot;);</a>
<a name="ln206">        dt_conf_set_string(&quot;plugins/lighttable/geotagging/offset&quot;, &quot;+00:00:00&quot;);</a>
<a name="ln207">      }</a>
<a name="ln208">      g_free(str);</a>
<a name="ln209">      gtk_window_set_focus(GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)), NULL);</a>
<a name="ln210">      return FALSE;</a>
<a name="ln211">    }</a>
<a name="ln212"> </a>
<a name="ln213">    case GDK_KEY_Return:</a>
<a name="ln214">    case GDK_KEY_KP_Enter:</a>
<a name="ln215">    {</a>
<a name="ln216">      const gchar *value = gtk_entry_get_text(GTK_ENTRY(d-&gt;offset_entry));</a>
<a name="ln217">      if(_lib_geotagging_parse_offset(value, NULL))</a>
<a name="ln218">      {</a>
<a name="ln219">        dt_conf_set_string(&quot;plugins/lighttable/geotagging/offset&quot;, value);</a>
<a name="ln220">      }</a>
<a name="ln221">      else</a>
<a name="ln222">      {</a>
<a name="ln223">        gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), &quot;+00:00:00&quot;);</a>
<a name="ln224">        dt_conf_set_string(&quot;plugins/lighttable/geotagging/offset&quot;, &quot;+00:00:00&quot;);</a>
<a name="ln225">      }</a>
<a name="ln226">      gtk_window_set_focus(GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)), NULL);</a>
<a name="ln227">      return FALSE;</a>
<a name="ln228">    }</a>
<a name="ln229"> </a>
<a name="ln230">    // allow +, -, :, 0 .. 9, left/right/home/end movement using arrow keys and del/backspace</a>
<a name="ln231">    case GDK_KEY_plus:</a>
<a name="ln232">    case GDK_KEY_KP_Add:</a>
<a name="ln233">    case GDK_KEY_minus:</a>
<a name="ln234">    case GDK_KEY_KP_Subtract:</a>
<a name="ln235">    case GDK_KEY_colon:</a>
<a name="ln236">    case GDK_KEY_0:</a>
<a name="ln237">    case GDK_KEY_KP_0:</a>
<a name="ln238">    case GDK_KEY_1:</a>
<a name="ln239">    case GDK_KEY_KP_1:</a>
<a name="ln240">    case GDK_KEY_2:</a>
<a name="ln241">    case GDK_KEY_KP_2:</a>
<a name="ln242">    case GDK_KEY_3:</a>
<a name="ln243">    case GDK_KEY_KP_3:</a>
<a name="ln244">    case GDK_KEY_4:</a>
<a name="ln245">    case GDK_KEY_KP_4:</a>
<a name="ln246">    case GDK_KEY_5:</a>
<a name="ln247">    case GDK_KEY_KP_5:</a>
<a name="ln248">    case GDK_KEY_6:</a>
<a name="ln249">    case GDK_KEY_KP_6:</a>
<a name="ln250">    case GDK_KEY_7:</a>
<a name="ln251">    case GDK_KEY_KP_7:</a>
<a name="ln252">    case GDK_KEY_8:</a>
<a name="ln253">    case GDK_KEY_KP_8:</a>
<a name="ln254">    case GDK_KEY_9:</a>
<a name="ln255">    case GDK_KEY_KP_9:</a>
<a name="ln256"> </a>
<a name="ln257">    case GDK_KEY_Left:</a>
<a name="ln258">    case GDK_KEY_Right:</a>
<a name="ln259">    case GDK_KEY_Home:</a>
<a name="ln260">    case GDK_KEY_KP_Home:</a>
<a name="ln261">    case GDK_KEY_End:</a>
<a name="ln262">    case GDK_KEY_KP_End:</a>
<a name="ln263">    case GDK_KEY_Delete:</a>
<a name="ln264">    case GDK_KEY_KP_Delete:</a>
<a name="ln265">    case GDK_KEY_BackSpace:</a>
<a name="ln266">      return FALSE;</a>
<a name="ln267"> </a>
<a name="ln268">    default: // block everything else</a>
<a name="ln269">      return TRUE;</a>
<a name="ln270">  }</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">static gboolean _lib_geotagging_offset_focus_out(GtkWidget *widget, GdkEvent *event, dt_lib_module_t *self)</a>
<a name="ln274">{</a>
<a name="ln275">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)self-&gt;data;</a>
<a name="ln276">  const gchar *value = gtk_entry_get_text(GTK_ENTRY(d-&gt;offset_entry));</a>
<a name="ln277">  if(_lib_geotagging_parse_offset(value, NULL))</a>
<a name="ln278">    dt_conf_set_string(&quot;plugins/lighttable/geotagging/offset&quot;, value);</a>
<a name="ln279">  else</a>
<a name="ln280">  {</a>
<a name="ln281">    gchar *str = dt_conf_get_string(&quot;plugins/lighttable/geotagging/offset&quot;);</a>
<a name="ln282">    gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), str);</a>
<a name="ln283">    g_free(str);</a>
<a name="ln284">  }</a>
<a name="ln285">  return FALSE;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">static void _lib_geotagging_calculate_offset_callback(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln289">{</a>
<a name="ln290">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)self-&gt;data;</a>
<a name="ln291">  const gchar *gps_time = gtk_entry_get_text(GTK_ENTRY(d-&gt;floating_window_entry));</a>
<a name="ln292">  if(gps_time)</a>
<a name="ln293">  {</a>
<a name="ln294">    gchar **tokens = g_strsplit(gps_time, &quot;:&quot;, 0);</a>
<a name="ln295">    if(tokens[0] != NULL &amp;&amp; tokens[1] != NULL &amp;&amp; tokens[2] != NULL)</a>
<a name="ln296">    {</a>
<a name="ln297">      if(g_ascii_isdigit(tokens[0][0]) &amp;&amp; g_ascii_isdigit(tokens[0][1]) &amp;&amp; tokens[0][2] == '\0'</a>
<a name="ln298">         &amp;&amp; g_ascii_isdigit(tokens[1][0]) &amp;&amp; g_ascii_isdigit(tokens[1][1]) &amp;&amp; tokens[1][2] == '\0'</a>
<a name="ln299">         &amp;&amp; g_ascii_isdigit(tokens[2][0]) &amp;&amp; g_ascii_isdigit(tokens[2][1]) &amp;&amp; tokens[2][2] == '\0')</a>
<a name="ln300">      {</a>
<a name="ln301">        int h, m, s;</a>
<a name="ln302">        h = (tokens[0][0] - '0') * 10 + tokens[0][1] - '0';</a>
<a name="ln303">        m = (tokens[1][0] - '0') * 10 + tokens[1][1] - '0';</a>
<a name="ln304">        s = (tokens[2][0] - '0') * 10 + tokens[2][1] - '0';</a>
<a name="ln305">        if(h &lt; 24 &amp;&amp; m &lt; 60 &amp;&amp; s &lt; 60)</a>
<a name="ln306">        {</a>
<a name="ln307">          // finally a valid time</a>
<a name="ln308">          // get imgid</a>
<a name="ln309">          int32_t imgid = -1;</a>
<a name="ln310">          sqlite3_stmt *stmt;</a>
<a name="ln311">          DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln312">                                      &quot;SELECT imgid FROM main.selected_images ORDER BY imgid ASC LIMIT 1&quot;, -1,</a>
<a name="ln313">                                      &amp;stmt, NULL);</a>
<a name="ln314">          if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln315">            imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln316">          else // no selection is used, use mouse over id</a>
<a name="ln317">            imgid = dt_control_get_mouse_over_id();</a>
<a name="ln318">          sqlite3_finalize(stmt);</a>
<a name="ln319"> </a>
<a name="ln320">          if(imgid &gt; 0)</a>
<a name="ln321">          {</a>
<a name="ln322">            const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln323">            // get the exif_datetime_taken and parse it</a>
<a name="ln324">            gint year;</a>
<a name="ln325">            gint month;</a>
<a name="ln326">            gint day;</a>
<a name="ln327">            gint hour;</a>
<a name="ln328">            gint minute;</a>
<a name="ln329">            gint second;</a>
<a name="ln330"> </a>
<a name="ln331">            if(sscanf(cimg-&gt;exif_datetime_taken, &quot;%d:%d:%d %d:%d:%d&quot;, (int *)&amp;year, (int *)&amp;month,</a>
<a name="ln332">                      (int *)&amp;day, (int *)&amp;hour, (int *)&amp;minute, (int *)&amp;second) == 6)</a>
<a name="ln333">            {</a>
<a name="ln334">              // calculate the offset</a>
<a name="ln335">              long int exif_seconds = hour * 60 * 60 + minute * 60 + second;</a>
<a name="ln336">              long int gps_seconds = h * 60 * 60 + m * 60 + s;</a>
<a name="ln337">              long int offset = gps_seconds - exif_seconds;</a>
<a name="ln338">              // transform the offset back into a string</a>
<a name="ln339">              gchar sign = (offset &lt; 0) ? '-' : '+';</a>
<a name="ln340">              offset = labs(offset);</a>
<a name="ln341">              gint offset_h = offset / (60 * 60);</a>
<a name="ln342">              offset -= offset_h * 60 * 60;</a>
<a name="ln343">              gint offset_m = offset / 60;</a>
<a name="ln344">              offset -= offset_m * 60;</a>
<a name="ln345">              gchar *offset_str = g_strdup_printf(&quot;%c%02d:%02d:%02ld&quot;, sign, offset_h, offset_m, offset);</a>
<a name="ln346">              // write the offset into d-&gt;offset_entry</a>
<a name="ln347">              gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), offset_str);</a>
<a name="ln348">              g_free(offset_str);</a>
<a name="ln349">            }</a>
<a name="ln350"> </a>
<a name="ln351">            dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln352">          }</a>
<a name="ln353">        }</a>
<a name="ln354">      }</a>
<a name="ln355">    }</a>
<a name="ln356">    g_strfreev(tokens);</a>
<a name="ln357">  }</a>
<a name="ln358">  gtk_widget_destroy(d-&gt;floating_window);</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">static gboolean _lib_geotagging_floating_key_press(GtkWidget *entry, GdkEventKey *event, dt_lib_module_t *self)</a>
<a name="ln362">{</a>
<a name="ln363">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)self-&gt;data;</a>
<a name="ln364">  switch(event-&gt;keyval)</a>
<a name="ln365">  {</a>
<a name="ln366">    case GDK_KEY_Escape:</a>
<a name="ln367">      gtk_widget_destroy(d-&gt;floating_window);</a>
<a name="ln368">      return TRUE;</a>
<a name="ln369"> </a>
<a name="ln370">    case GDK_KEY_Return:</a>
<a name="ln371">    case GDK_KEY_KP_Enter:</a>
<a name="ln372">      _lib_geotagging_calculate_offset_callback(NULL, self);</a>
<a name="ln373">      return TRUE;</a>
<a name="ln374"> </a>
<a name="ln375">    default:</a>
<a name="ln376">      return FALSE;</a>
<a name="ln377">  }</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">static void _lib_geotagging_show_offset_window(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln381">{</a>
<a name="ln382">  dt_lib_geotagging_t *d = self-&gt;data;</a>
<a name="ln383">  gint x, y;</a>
<a name="ln384">  gint px, py, center_w, center_h, window_w, window_h;</a>
<a name="ln385">  GtkWidget *window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln386">  GtkWidget *center = dt_ui_center(darktable.gui-&gt;ui);</a>
<a name="ln387">  gdk_window_get_origin(gtk_widget_get_window(center), &amp;px, &amp;py);</a>
<a name="ln388"> </a>
<a name="ln389">  center_w = gdk_window_get_width(gtk_widget_get_window(center));</a>
<a name="ln390">  center_h = gdk_window_get_height(gtk_widget_get_window(center));</a>
<a name="ln391"> </a>
<a name="ln392">  d-&gt;floating_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</a>
<a name="ln393">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln394">  dt_osx_disallow_fullscreen(d-&gt;floating_window);</a>
<a name="ln395">#endif</a>
<a name="ln396">  gtk_widget_set_can_focus(d-&gt;floating_window, TRUE);</a>
<a name="ln397">  gtk_window_set_decorated(GTK_WINDOW(d-&gt;floating_window), FALSE);</a>
<a name="ln398">  gtk_window_set_type_hint(GTK_WINDOW(d-&gt;floating_window), GDK_WINDOW_TYPE_HINT_POPUP_MENU);</a>
<a name="ln399">  gtk_window_set_transient_for(GTK_WINDOW(d-&gt;floating_window), GTK_WINDOW(window));</a>
<a name="ln400">  gtk_widget_set_opacity(d-&gt;floating_window, 0.8);</a>
<a name="ln401">  gtk_window_set_modal(GTK_WINDOW(d-&gt;floating_window), TRUE);</a>
<a name="ln402"> </a>
<a name="ln403">  GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln404">  gtk_container_add(GTK_CONTAINER(d-&gt;floating_window), vbox);</a>
<a name="ln405"> </a>
<a name="ln406">  d-&gt;floating_window_entry = gtk_entry_new();</a>
<a name="ln407">  gtk_widget_add_events(d-&gt;floating_window_entry, GDK_FOCUS_CHANGE_MASK);</a>
<a name="ln408">  g_signal_connect_swapped(d-&gt;floating_window, &quot;focus-out-event&quot;, G_CALLBACK(gtk_widget_destroy),</a>
<a name="ln409">                           d-&gt;floating_window);</a>
<a name="ln410">  gtk_widget_set_tooltip_text(d-&gt;floating_window_entry,</a>
<a name="ln411">                              _(&quot;enter the time shown on the selected picture\nformat: hh:mm:ss&quot;));</a>
<a name="ln412"> </a>
<a name="ln413">  gtk_editable_select_region(GTK_EDITABLE(d-&gt;floating_window_entry), 0, -1);</a>
<a name="ln414">  gtk_box_pack_start(GTK_BOX(vbox), d-&gt;floating_window_entry, TRUE, TRUE, 0);</a>
<a name="ln415">  g_signal_connect(d-&gt;floating_window_entry, &quot;key-press-event&quot;,</a>
<a name="ln416">                   G_CALLBACK(_lib_geotagging_floating_key_press), self);</a>
<a name="ln417"> </a>
<a name="ln418">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln419">  GtkWidget *cancel_button = gtk_button_new_with_label(_(&quot;cancel&quot;));</a>
<a name="ln420">  GtkWidget *ok_button = gtk_button_new_with_label(_(&quot;ok&quot;));</a>
<a name="ln421"> </a>
<a name="ln422">  gtk_box_pack_start(GTK_BOX(hbox), cancel_button, TRUE, TRUE, 0);</a>
<a name="ln423">  gtk_box_pack_start(GTK_BOX(hbox), ok_button, TRUE, TRUE, 0);</a>
<a name="ln424">  g_signal_connect_swapped(G_OBJECT(cancel_button), &quot;clicked&quot;, G_CALLBACK(gtk_widget_destroy),</a>
<a name="ln425">                           d-&gt;floating_window);</a>
<a name="ln426">  g_signal_connect(G_OBJECT(ok_button), &quot;clicked&quot;, G_CALLBACK(_lib_geotagging_calculate_offset_callback),</a>
<a name="ln427">                   self);</a>
<a name="ln428"> </a>
<a name="ln429">  gtk_box_pack_start(GTK_BOX(vbox), hbox, TRUE, TRUE, 0);</a>
<a name="ln430"> </a>
<a name="ln431">  gtk_widget_show_all(d-&gt;floating_window);</a>
<a name="ln432">  gtk_widget_grab_focus(d-&gt;floating_window_entry);</a>
<a name="ln433"> </a>
<a name="ln434">  window_w = gdk_window_get_width(gtk_widget_get_window(d-&gt;floating_window));</a>
<a name="ln435">  window_h = gdk_window_get_height(gtk_widget_get_window(d-&gt;floating_window));</a>
<a name="ln436"> </a>
<a name="ln437">  x = px + 0.5 * (center_w - window_w);</a>
<a name="ln438">  y = py + center_h - 20 - window_h;</a>
<a name="ln439">  gtk_window_move(GTK_WINDOW(d-&gt;floating_window), x, y);</a>
<a name="ln440"> </a>
<a name="ln441">  gtk_window_present(GTK_WINDOW(d-&gt;floating_window));</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">// modify the datetime_taken field in the db/cache</a>
<a name="ln445">static void _lib_geotagging_apply_offset_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln446">{</a>
<a name="ln447">  dt_lib_geotagging_t *l = (dt_lib_geotagging_t *)((dt_lib_module_t *)user_data)-&gt;data;</a>
<a name="ln448">  long int offset = 0;</a>
<a name="ln449">  _lib_geotagging_parse_offset(gtk_entry_get_text(GTK_ENTRY(l-&gt;offset_entry)), &amp;offset);</a>
<a name="ln450">  dt_control_time_offset(offset, -1);</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">static gboolean _lib_geotagging_filter_gpx(const GtkFileFilterInfo *filter_info, gpointer data)</a>
<a name="ln454">{</a>
<a name="ln455">  if(!g_ascii_strcasecmp(filter_info-&gt;mime_type, &quot;application/gpx+xml&quot;)) return TRUE;</a>
<a name="ln456"> </a>
<a name="ln457">  const gchar *filename = filter_info-&gt;filename;</a>
<a name="ln458">  const char *cc = filename + strlen(filename);</a>
<a name="ln459">  for(; *cc != '.' &amp;&amp; cc &gt; filename; cc--)</a>
<a name="ln460">    ;</a>
<a name="ln461"> </a>
<a name="ln462">  if(!g_ascii_strcasecmp(cc, &quot;.gpx&quot;)) return TRUE;</a>
<a name="ln463"> </a>
<a name="ln464">  return FALSE;</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">static void _lib_geotagging_gpx_callback(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln468">{</a>
<a name="ln469">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)self-&gt;data;</a>
<a name="ln470">  /* bring a filechooser to select the gpx file to apply to selection */</a>
<a name="ln471">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln472">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln473">      _(&quot;open GPX file&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_OPEN, _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL,</a>
<a name="ln474">      _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln475">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln476">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln477">#endif</a>
<a name="ln478"> </a>
<a name="ln479">  char *last_directory = dt_conf_get_string(&quot;ui_last/gpx_last_directory&quot;);</a>
<a name="ln480">  if(last_directory != NULL)</a>
<a name="ln481">  {</a>
<a name="ln482">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(filechooser), last_directory);</a>
<a name="ln483">    g_free(last_directory);</a>
<a name="ln484">  }</a>
<a name="ln485"> </a>
<a name="ln486">  GtkFileFilter *filter;</a>
<a name="ln487">  filter = GTK_FILE_FILTER(gtk_file_filter_new());</a>
<a name="ln488">  gtk_file_filter_add_custom(filter, GTK_FILE_FILTER_FILENAME | GTK_FILE_FILTER_MIME_TYPE,</a>
<a name="ln489">                             _lib_geotagging_filter_gpx, NULL, NULL);</a>
<a name="ln490">  gtk_file_filter_set_name(filter, _(&quot;GPS data exchange format&quot;));</a>
<a name="ln491">  gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(filechooser), filter);</a>
<a name="ln492"> </a>
<a name="ln493">  filter = GTK_FILE_FILTER(gtk_file_filter_new());</a>
<a name="ln494">  gtk_file_filter_add_pattern(filter, &quot;*&quot;);</a>
<a name="ln495">  gtk_file_filter_set_name(filter, _(&quot;all files&quot;));</a>
<a name="ln496">  gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(filechooser), filter);</a>
<a name="ln497"> </a>
<a name="ln498">  // add time zone selection</a>
<a name="ln499">  GtkWidget *extra_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln500">  GtkWidget *label = gtk_label_new(_(&quot;camera time zone&quot;));</a>
<a name="ln501">  gtk_widget_set_tooltip_text(label, _(&quot;most cameras don't store the time zone in EXIF. &quot;</a>
<a name="ln502">                                       &quot;give the correct time zone so the GPX data can be correctly matched&quot;));</a>
<a name="ln503"> </a>
<a name="ln504">  GtkCellRenderer *renderer;</a>
<a name="ln505">  GtkTreeIter tree_iter;</a>
<a name="ln506">  GtkListStore *model = gtk_list_store_new(2, G_TYPE_STRING /*display*/, G_TYPE_STRING /*name*/);</a>
<a name="ln507"> </a>
<a name="ln508">  GtkWidget *tz_selection = gtk_combo_box_new_with_model(GTK_TREE_MODEL(model));</a>
<a name="ln509">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln510">  gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(tz_selection), renderer, FALSE);</a>
<a name="ln511">  gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(tz_selection), renderer, &quot;text&quot;, 0, NULL);</a>
<a name="ln512"> </a>
<a name="ln513">  int i = 0;</a>
<a name="ln514">  gchar *old_tz = dt_conf_get_string(&quot;plugins/lighttable/geotagging/tz&quot;);</a>
<a name="ln515">  for(GList *iter = d-&gt;timezones; iter; iter = g_list_next(iter))</a>
<a name="ln516">  {</a>
<a name="ln517">    tz_tuple_t *tz_tuple = (tz_tuple_t *)iter-&gt;data;</a>
<a name="ln518">    gtk_list_store_append(model, &amp;tree_iter);</a>
<a name="ln519">    gtk_list_store_set(model, &amp;tree_iter, 0, tz_tuple-&gt;display, 1, tz_tuple-&gt;name, -1);</a>
<a name="ln520">    if(i == 0 || !strcmp(tz_tuple-&gt;name, old_tz)) gtk_combo_box_set_active(GTK_COMBO_BOX(tz_selection), i);</a>
<a name="ln521">    i++;</a>
<a name="ln522">  }</a>
<a name="ln523">  g_free(old_tz);</a>
<a name="ln524"> </a>
<a name="ln525">  gtk_box_pack_start(GTK_BOX(extra_box), label, FALSE, FALSE, 0);</a>
<a name="ln526">  gtk_box_pack_start(GTK_BOX(extra_box), tz_selection, FALSE, FALSE, 0);</a>
<a name="ln527">  gtk_widget_show_all(extra_box);</a>
<a name="ln528">  gtk_file_chooser_set_extra_widget(GTK_FILE_CHOOSER(filechooser), extra_box);</a>
<a name="ln529"> </a>
<a name="ln530">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln531">  {</a>
<a name="ln532">    gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln533">    dt_conf_set_string(&quot;ui_last/gpx_last_directory&quot;, folder);</a>
<a name="ln534">    g_free(folder);</a>
<a name="ln535"> </a>
<a name="ln536">    gchar *tz;</a>
<a name="ln537">    if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(tz_selection), &amp;tree_iter) == TRUE)</a>
<a name="ln538">    {</a>
<a name="ln539">      GValue value = { 0, };</a>
<a name="ln540">      gtk_tree_model_get_value(GTK_TREE_MODEL(model), &amp;tree_iter, 1, &amp;value);</a>
<a name="ln541">      tz = g_strdup((gchar *)g_value_get_string(&amp;value));</a>
<a name="ln542">      g_value_unset(&amp;value);</a>
<a name="ln543">    }</a>
<a name="ln544">    else</a>
<a name="ln545">      tz = g_strdup(&quot;UTC&quot;);</a>
<a name="ln546">    dt_conf_set_string(&quot;plugins/lighttable/geotagging/tz&quot;, tz);</a>
<a name="ln547">    gchar *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln548">    dt_control_gpx_apply(filename, -1, tz);</a>
<a name="ln549">    g_free(filename);</a>
<a name="ln550">    g_free(tz);</a>
<a name="ln551">  }</a>
<a name="ln552"> </a>
<a name="ln553">  g_object_unref(model);</a>
<a name="ln554">  gtk_widget_destroy(extra_box);</a>
<a name="ln555">  gtk_widget_destroy(filechooser);</a>
<a name="ln556">  //   dt_control_queue_redraw_center();</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">static int _sort_timezones(gconstpointer a, gconstpointer b)</a>
<a name="ln560">{</a>
<a name="ln561">  const tz_tuple_t *tz_a = (tz_tuple_t *)a;</a>
<a name="ln562">  const tz_tuple_t *tz_b = (tz_tuple_t *)b;</a>
<a name="ln563"> </a>
<a name="ln564">#ifdef _WIN32</a>
<a name="ln565">  gboolean utc_neg_a = g_str_has_prefix(tz_a-&gt;display, &quot;(UTC-&quot;);</a>
<a name="ln566">  gboolean utc_neg_b = g_str_has_prefix(tz_b-&gt;display, &quot;(UTC-&quot;);</a>
<a name="ln567"> </a>
<a name="ln568">  gboolean utc_pos_a = g_str_has_prefix(tz_a-&gt;display, &quot;(UTC+&quot;);</a>
<a name="ln569">  gboolean utc_pos_b = g_str_has_prefix(tz_b-&gt;display, &quot;(UTC+&quot;);</a>
<a name="ln570"> </a>
<a name="ln571">  if(utc_neg_a &amp;&amp; utc_neg_b)</a>
<a name="ln572">  {</a>
<a name="ln573">    char *iter_a = tz_a-&gt;display + strlen(&quot;(UTC-&quot;);</a>
<a name="ln574">    char *iter_b = tz_b-&gt;display + strlen(&quot;(UTC-&quot;);</a>
<a name="ln575"> </a>
<a name="ln576">    while(((*iter_a &gt;= '0' &amp;&amp; *iter_a &lt;= '9') || *iter_a == ':') &amp;&amp;</a>
<a name="ln577">          ((*iter_b &gt;= '0' &amp;&amp; *iter_b &lt;= '9') || *iter_b == ':'))</a>
<a name="ln578">    {</a>
<a name="ln579">      if(*iter_a != *iter_b) return *iter_b - *iter_a;</a>
<a name="ln580">      iter_a++;</a>
<a name="ln581">      iter_b++;</a>
<a name="ln582">    }</a>
<a name="ln583">  }</a>
<a name="ln584">  else if(utc_neg_a &amp;&amp; utc_pos_b) return -1;</a>
<a name="ln585">  else if(utc_pos_a &amp;&amp; utc_neg_b) return 1;</a>
<a name="ln586">#endif</a>
<a name="ln587"> </a>
<a name="ln588">  return g_strcmp0(tz_a-&gt;display, tz_b-&gt;display);</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">// create a list of possible time zones</a>
<a name="ln592">static GList *_lib_geotagging_get_timezones(void)</a>
<a name="ln593">{</a>
<a name="ln594">  GList *timezones = NULL;</a>
<a name="ln595"> </a>
<a name="ln596">#ifndef _WIN32</a>
<a name="ln597">  // possible locations for zone.tab:</a>
<a name="ln598">  // - /usr/share/zoneinfo</a>
<a name="ln599">  // - /usr/lib/zoneinfo</a>
<a name="ln600">  // - getenv(&quot;TZDIR&quot;)</a>
<a name="ln601">  // - apparently on solaris there is no zones.tab. we need to collect the information ourselves like this:</a>
<a name="ln602">  //   /bin/grep -h ^Zone /usr/share/lib/zoneinfo/src/* | /bin/awk '{print &quot;??\t+9999+99999\t&quot; $2}'</a>
<a name="ln603">#define MAX_LINE_LENGTH 256</a>
<a name="ln604">  FILE *fp;</a>
<a name="ln605">  char line[MAX_LINE_LENGTH];</a>
<a name="ln606"> </a>
<a name="ln607">  // find the file using known possible locations</a>
<a name="ln608">  gchar *zone_tab = g_strdup(&quot;/usr/share/zoneinfo/zone.tab&quot;);</a>
<a name="ln609">  if(!g_file_test(zone_tab, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln610">  {</a>
<a name="ln611">    g_free(zone_tab);</a>
<a name="ln612">    zone_tab = g_strdup(&quot;/usr/lib/zoneinfo/zone.tab&quot;);</a>
<a name="ln613">    if(!g_file_test(zone_tab, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln614">    {</a>
<a name="ln615">      g_free(zone_tab);</a>
<a name="ln616">      zone_tab = g_build_filename(g_getenv(&quot;TZDIR&quot;), &quot;zone.tab&quot;, NULL);</a>
<a name="ln617">      if(!g_file_test(zone_tab, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln618">      {</a>
<a name="ln619">        g_free(zone_tab);</a>
<a name="ln620">        char datadir[PATH_MAX] = { 0 };</a>
<a name="ln621">        dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln622">        zone_tab = g_build_filename(datadir, &quot;zone.tab&quot;, NULL);</a>
<a name="ln623">        if(!g_file_test(zone_tab, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln624">        {</a>
<a name="ln625">          g_free(zone_tab);</a>
<a name="ln626">          // TODO: Solaris test</a>
<a name="ln627">          return NULL;</a>
<a name="ln628">        }</a>
<a name="ln629">      }</a>
<a name="ln630">    }</a>
<a name="ln631">  }</a>
<a name="ln632"> </a>
<a name="ln633">  // parse zone.tab and put all time zone descriptions into timezones</a>
<a name="ln634">  fp = g_fopen(zone_tab, &quot;r&quot;);</a>
<a name="ln635">  g_free(zone_tab);</a>
<a name="ln636"> </a>
<a name="ln637">  if(!fp) return NULL;</a>
<a name="ln638"> </a>
<a name="ln639">  while(fgets(line, MAX_LINE_LENGTH, fp))</a>
<a name="ln640">  {</a>
<a name="ln641">    if(line[0] == '#' || line[0] == '\0') continue;</a>
<a name="ln642">    gchar **tokens = g_strsplit_set(line, &quot; \t\n&quot;, 0);</a>
<a name="ln643">    // sometimes files are not separated by single tabs but multiple spaces, resulting in empty strings in tokens</a>
<a name="ln644">    // so we have to look for the 3rd non-empty entry</a>
<a name="ln645">    int n_found = -1, i;</a>
<a name="ln646">    for(i = 0; tokens[i] &amp;&amp; n_found &lt; 2; i++) if(*tokens[i]) n_found++;</a>
<a name="ln647">    if(n_found != 2)</a>
<a name="ln648">    {</a>
<a name="ln649">      g_strfreev(tokens);</a>
<a name="ln650">      continue;</a>
<a name="ln651">    }</a>
<a name="ln652">    gchar *name = g_strdup(tokens[i - 1]);</a>
<a name="ln653">    g_strfreev(tokens);</a>
<a name="ln654">    if(name[0] == '\0')</a>
<a name="ln655">    {</a>
<a name="ln656">      g_free(name);</a>
<a name="ln657">      continue;</a>
<a name="ln658">    }</a>
<a name="ln659">    size_t last_char = strlen(name) - 1;</a>
<a name="ln660">    if(name[last_char] == '\n') name[last_char] = '\0';</a>
<a name="ln661">    tz_tuple_t *tz_tuple = (tz_tuple_t *)malloc(sizeof(tz_tuple_t));</a>
<a name="ln662">    tz_tuple-&gt;display = name;</a>
<a name="ln663">    tz_tuple-&gt;name = name;</a>
<a name="ln664">    timezones = g_list_prepend(timezones, tz_tuple);</a>
<a name="ln665">  }</a>
<a name="ln666"> </a>
<a name="ln667">  fclose(fp);</a>
<a name="ln668"> </a>
<a name="ln669">  // sort timezones</a>
<a name="ln670">  timezones = g_list_sort(timezones, _sort_timezones);</a>
<a name="ln671"> </a>
<a name="ln672">  tz_tuple_t *utc = (tz_tuple_t *)malloc(sizeof(tz_tuple_t));</a>
<a name="ln673">  utc-&gt;display = g_strdup(&quot;UTC&quot;);</a>
<a name="ln674">  utc-&gt;name = utc-&gt;display;</a>
<a name="ln675">  timezones = g_list_prepend(timezones, utc);</a>
<a name="ln676"> </a>
<a name="ln677">#undef MAX_LINE_LENGTH</a>
<a name="ln678"> </a>
<a name="ln679">#else // !_WIN32</a>
<a name="ln680">  // on Windows we have to grab the time zones from the registry</a>
<a name="ln681">  char *keypath = &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\\&quot;;</a>
<a name="ln682">  HKEY hKey;</a>
<a name="ln683"> </a>
<a name="ln684">  if(RegOpenKeyExA(HKEY_LOCAL_MACHINE,</a>
<a name="ln685">                   keypath,</a>
<a name="ln686">                   0,</a>
<a name="ln687">                   KEY_READ,</a>
<a name="ln688">                   &amp;hKey) == ERROR_SUCCESS)</a>
<a name="ln689">  {</a>
<a name="ln690">    DWORD n_subkeys, max_subkey_len;</a>
<a name="ln691"> </a>
<a name="ln692">    if(RegQueryInfoKey(hKey,</a>
<a name="ln693">                       NULL,</a>
<a name="ln694">                       NULL,</a>
<a name="ln695">                       NULL,</a>
<a name="ln696">                       &amp;n_subkeys,</a>
<a name="ln697">                       &amp;max_subkey_len,</a>
<a name="ln698">                       NULL,</a>
<a name="ln699">                       NULL,</a>
<a name="ln700">                       NULL,</a>
<a name="ln701">                       NULL,</a>
<a name="ln702">                       NULL,</a>
<a name="ln703">                       NULL) == ERROR_SUCCESS)</a>
<a name="ln704">    {</a>
<a name="ln705">      wchar_t *subkeyname = (wchar_t *)malloc((max_subkey_len + 1) * sizeof(wchar_t));</a>
<a name="ln706"> </a>
<a name="ln707">      for(DWORD i = 1; i &lt; n_subkeys; i++)</a>
<a name="ln708">      {</a>
<a name="ln709">        DWORD subkeyname_length = max_subkey_len + 1;</a>
<a name="ln710">        if(RegEnumKeyExW(hKey,</a>
<a name="ln711">                         i,</a>
<a name="ln712">                         subkeyname,</a>
<a name="ln713">                         &amp;subkeyname_length,</a>
<a name="ln714">                         NULL,</a>
<a name="ln715">                         NULL,</a>
<a name="ln716">                         NULL,</a>
<a name="ln717">                         NULL) == ERROR_SUCCESS)</a>
<a name="ln718">        {</a>
<a name="ln719">          DWORD buffer_size;</a>
<a name="ln720">          char *subkeyname_utf8 = g_utf16_to_utf8(subkeyname, -1, NULL, NULL, NULL);</a>
<a name="ln721">          char *subkeypath_utf8 = g_strconcat(keypath, &quot;\\&quot;, subkeyname_utf8, NULL);</a>
<a name="ln722">          wchar_t *subkeypath = g_utf8_to_utf16(subkeypath_utf8, -1, NULL, NULL, NULL);</a>
<a name="ln723">          if(RegGetValueW(HKEY_LOCAL_MACHINE,</a>
<a name="ln724">                          subkeypath,</a>
<a name="ln725">                          L&quot;Display&quot;,</a>
<a name="ln726">                          RRF_RT_ANY,</a>
<a name="ln727">                          NULL,</a>
<a name="ln728">                          NULL,</a>
<a name="ln729">                          &amp;buffer_size) == ERROR_SUCCESS)</a>
<a name="ln730">          {</a>
<a name="ln731">            wchar_t *display_name = (wchar_t *)malloc(buffer_size);</a>
<a name="ln732">            if(RegGetValueW(HKEY_LOCAL_MACHINE,</a>
<a name="ln733">                            subkeypath,</a>
<a name="ln734">                            L&quot;Display&quot;,</a>
<a name="ln735">                            RRF_RT_ANY,</a>
<a name="ln736">                            NULL,</a>
<a name="ln737">                            display_name,</a>
<a name="ln738">                            &amp;buffer_size) == ERROR_SUCCESS)</a>
<a name="ln739">            {</a>
<a name="ln740">              tz_tuple_t *tz = (tz_tuple_t *)malloc(sizeof(tz_tuple_t));</a>
<a name="ln741"> </a>
<a name="ln742">              tz-&gt;name = subkeyname_utf8;</a>
<a name="ln743">              tz-&gt;display = g_utf16_to_utf8(display_name, -1, NULL, NULL, NULL);</a>
<a name="ln744">              timezones = g_list_prepend(timezones, tz);</a>
<a name="ln745"> </a>
<a name="ln746">              subkeyname_utf8 = NULL; // to not free it later</a>
<a name="ln747">            }</a>
<a name="ln748">            free(display_name);</a>
<a name="ln749">          }</a>
<a name="ln750">          g_free(subkeyname_utf8);</a>
<a name="ln751">          g_free(subkeypath_utf8);</a>
<a name="ln752">          g_free(subkeypath);</a>
<a name="ln753">        }</a>
<a name="ln754">      }</a>
<a name="ln755"> </a>
<a name="ln756">      free(subkeyname);</a>
<a name="ln757">    }</a>
<a name="ln758">  }</a>
<a name="ln759"> </a>
<a name="ln760">  RegCloseKey(hKey);</a>
<a name="ln761"> </a>
<a name="ln762">  timezones = g_list_sort(timezones, _sort_timezones);</a>
<a name="ln763">#endif // !_WIN32</a>
<a name="ln764"> </a>
<a name="ln765">  return timezones;</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768"> </a>
<a name="ln769">void gui_init(dt_lib_module_t *self)</a>
<a name="ln770">{</a>
<a name="ln771">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)malloc(sizeof(dt_lib_geotagging_t));</a>
<a name="ln772">  self-&gt;data = (void *)d;</a>
<a name="ln773">  d-&gt;timezones = _lib_geotagging_get_timezones();</a>
<a name="ln774">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln775">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln776">  GtkBox *hbox;</a>
<a name="ln777">  GtkWidget *button, *label;</a>
<a name="ln778"> </a>
<a name="ln779">  /* the offset line */</a>
<a name="ln780">  hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln781">  label = GTK_WIDGET(gtk_label_new(_(&quot;time offset&quot;)));</a>
<a name="ln782">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln783">  gtk_box_pack_start(hbox, label, FALSE, TRUE, 0);</a>
<a name="ln784"> </a>
<a name="ln785">  d-&gt;offset_entry = gtk_entry_new();</a>
<a name="ln786">  dt_gui_key_accel_block_on_focus_connect(d-&gt;offset_entry);</a>
<a name="ln787">  gtk_entry_set_max_length(GTK_ENTRY(d-&gt;offset_entry), 9);</a>
<a name="ln788">  gtk_entry_set_width_chars(GTK_ENTRY(d-&gt;offset_entry), 0);</a>
<a name="ln789">  gtk_box_pack_start(hbox, d-&gt;offset_entry, TRUE, TRUE, 0);</a>
<a name="ln790">  g_signal_connect(d-&gt;offset_entry, &quot;key-press-event&quot;, G_CALLBACK(_lib_geotagging_offset_key_press), self);</a>
<a name="ln791">  g_signal_connect(d-&gt;offset_entry, &quot;focus-out-event&quot;, G_CALLBACK(_lib_geotagging_offset_focus_out), self);</a>
<a name="ln792">  gtk_widget_set_tooltip_text(d-&gt;offset_entry, _(&quot;time offset\nformat: [+-]?[[hh:]mm:]ss&quot;));</a>
<a name="ln793">  gchar *str = dt_conf_get_string(&quot;plugins/lighttable/geotagging/offset&quot;);</a>
<a name="ln794">  if(_lib_geotagging_parse_offset(str, NULL))</a>
<a name="ln795">    gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), str);</a>
<a name="ln796">  else</a>
<a name="ln797">    gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), &quot;+00:00:00&quot;);</a>
<a name="ln798">  g_free(str);</a>
<a name="ln799"> </a>
<a name="ln800">  GtkBox *button_box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln801">  button = dtgtk_button_new(dtgtk_cairo_paint_zoom, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln802">  gtk_widget_set_tooltip_text(button, _(&quot;calculate the time offset from an image&quot;));</a>
<a name="ln803">  gtk_box_pack_start(button_box, button, TRUE, TRUE, 0);</a>
<a name="ln804">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(_lib_geotagging_show_offset_window), self);</a>
<a name="ln805"> </a>
<a name="ln806">  button = dtgtk_button_new(dtgtk_cairo_paint_check_mark, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln807">  gtk_widget_set_tooltip_text(button, _(&quot;apply time offset to selected images&quot;));</a>
<a name="ln808">  gtk_box_pack_start(button_box, button, TRUE, TRUE, 0);</a>
<a name="ln809">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(_lib_geotagging_apply_offset_callback), self);</a>
<a name="ln810"> </a>
<a name="ln811">  gtk_box_pack_start(hbox, GTK_WIDGET(button_box), FALSE, TRUE, 0);</a>
<a name="ln812">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hbox), TRUE, TRUE, 0);</a>
<a name="ln813"> </a>
<a name="ln814">  /* gpx */</a>
<a name="ln815">  button = gtk_button_new_with_label(_(&quot;apply GPX track file&quot;));</a>
<a name="ln816">  gtk_widget_set_tooltip_text(button, _(&quot;parses a GPX file and updates location of selected images&quot;));</a>
<a name="ln817">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), button, TRUE, TRUE, 0);</a>
<a name="ln818">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(_lib_geotagging_gpx_callback), self);</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln822">{</a>
<a name="ln823">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)self-&gt;data;</a>
<a name="ln824">  dt_gui_key_accel_block_on_focus_disconnect(d-&gt;offset_entry);</a>
<a name="ln825">  g_list_free_full(d-&gt;timezones, free_tz_tuple);</a>
<a name="ln826">  d-&gt;timezones = NULL;</a>
<a name="ln827">  free(self-&gt;data);</a>
<a name="ln828">  self-&gt;data = NULL;</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln832">{</a>
<a name="ln833">  //   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;remove from collection&quot;),</a>
<a name="ln834">  //                         GDK_Delete, 0);</a>
<a name="ln835">  //   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;delete from disk&quot;), 0, 0);</a>
<a name="ln836">  //   dt_accel_register_lib(self,</a>
<a name="ln837">  //                         NC_(&quot;accel&quot;, &quot;rotate selected images 90 degrees CW&quot;),</a>
<a name="ln838">  //                         0, 0);</a>
<a name="ln839">  //   dt_accel_register_lib(self,</a>
<a name="ln840">  //                         NC_(&quot;accel&quot;, &quot;rotate selected images 90 degrees CCW&quot;),</a>
<a name="ln841">  //                         0, 0);</a>
<a name="ln842">  //   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;create hdr&quot;), 0, 0);</a>
<a name="ln843">  //   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;duplicate&quot;), 0, 0);</a>
<a name="ln844">  //   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;reset rotation&quot;), 0, 0);</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln848">{</a>
<a name="ln849">  //   dt_lib_image_t *d = (dt_lib_image_t*)self-&gt;data;</a>
<a name="ln850">  //</a>
<a name="ln851">  //   dt_accel_connect_button_lib(self, &quot;remove from collection&quot;, d-&gt;remove_button);</a>
<a name="ln852">  //   dt_accel_connect_button_lib(self, &quot;delete from disk&quot;, d-&gt;delete_button);</a>
<a name="ln853">  //   dt_accel_connect_button_lib(self, &quot;rotate selected images 90 degrees CW&quot;,</a>
<a name="ln854">  //                               d-&gt;rotate_cw_button);</a>
<a name="ln855">  //   dt_accel_connect_button_lib(self, &quot;rotate selected images 90 degrees CCW&quot;,</a>
<a name="ln856">  //                               d-&gt;rotate_ccw_button);</a>
<a name="ln857">  //   dt_accel_connect_button_lib(self, &quot;create hdr&quot;, d-&gt;create_hdr_button);</a>
<a name="ln858">  //   dt_accel_connect_button_lib(self, &quot;duplicate&quot;, d-&gt;duplicate_button);</a>
<a name="ln859">  //   dt_accel_connect_button_lib(self, &quot;reset rotation&quot;, d-&gt;reset_button);</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln863">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln864">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="662"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'tz_tuple'. Check lines: 662, 661.</p></div>
<div class="balloon" rel="673"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'utc'. Check lines: 673, 672.</p></div>
<div class="balloon" rel="773"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 773, 771.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
