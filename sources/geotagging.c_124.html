
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012 tobias ellinghaus.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">// #include &quot;common/darktable.h&quot;</a>
<a name="ln19">// #include &quot;control/control.h&quot;</a>
<a name="ln20">#include &quot;common/debug.h&quot;</a>
<a name="ln21">#include &quot;common/image_cache.h&quot;</a>
<a name="ln22">#include &quot;control/conf.h&quot;</a>
<a name="ln23">// #include &quot;gui/accelerators.h&quot;</a>
<a name="ln24">// #include &quot;gui/gtk.h&quot;</a>
<a name="ln25">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln26">// #include &quot;dtgtk/paint.h&quot;</a>
<a name="ln27">// #include &quot;libs/lib.h&quot;</a>
<a name="ln28">#include &quot;control/jobs.h&quot;</a>
<a name="ln29">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln30">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln31">#include &quot;osx/osx.h&quot;</a>
<a name="ln32">#endif</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">DT_MODULE(1)</a>
<a name="ln37"> </a>
<a name="ln38">typedef struct tz_tuple_t</a>
<a name="ln39">{</a>
<a name="ln40">  char *name, *display;</a>
<a name="ln41">} tz_tuple_t;</a>
<a name="ln42"> </a>
<a name="ln43">typedef struct dt_lib_geotagging_t</a>
<a name="ln44">{</a>
<a name="ln45">  GtkWidget *offset_entry;</a>
<a name="ln46">  GList *timezones;</a>
<a name="ln47">  GtkWidget *floating_window, *floating_window_ok, *floating_window_cancel, *floating_window_entry;</a>
<a name="ln48">} dt_lib_geotagging_t;</a>
<a name="ln49"> </a>
<a name="ln50">static void free_tz_tuple(gpointer data)</a>
<a name="ln51">{</a>
<a name="ln52">  tz_tuple_t *tz_tuple = (tz_tuple_t *)data;</a>
<a name="ln53">  g_free(tz_tuple-&gt;display);</a>
<a name="ln54">#ifdef _WIN32</a>
<a name="ln55">  g_free(tz_tuple-&gt;name); // on non-Windows both point to the same string</a>
<a name="ln56">#endif</a>
<a name="ln57">  free(tz_tuple);</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">const char *name(dt_lib_module_t *self)</a>
<a name="ln61">{</a>
<a name="ln62">  return _(&quot;geotagging&quot;);</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65">const char **views(dt_lib_module_t *self)</a>
<a name="ln66">{</a>
<a name="ln67">  static const char *v[] = {&quot;lighttable&quot;, NULL};</a>
<a name="ln68">  return v;</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln72">{</a>
<a name="ln73">  return DT_UI_CONTAINER_PANEL_RIGHT_CENTER;</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76"> </a>
<a name="ln77">int position()</a>
<a name="ln78">{</a>
<a name="ln79">  return 450;</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">/* try to parse the offset string. returns true if it worked, false otherwise.</a>
<a name="ln83"> *if seconds != NULL the offset will be put there in seconds or 0 if it failed. always look at the return</a>
<a name="ln84"> *value before using the seconds value! */</a>
<a name="ln85">static gboolean _lib_geotagging_parse_offset(const char *str, long int *seconds)</a>
<a name="ln86">{</a>
<a name="ln87">  const gchar *str_bak = str;</a>
<a name="ln88">  long int result = 0;</a>
<a name="ln89">  int numbers[3] = { 0, 0, 0 };</a>
<a name="ln90">  int fields = 0;</a>
<a name="ln91">  char sign = '+';</a>
<a name="ln92">  if(seconds) *seconds = 0;</a>
<a name="ln93"> </a>
<a name="ln94">  if(!str) return FALSE;</a>
<a name="ln95"> </a>
<a name="ln96">  size_t len = strlen(str);</a>
<a name="ln97"> </a>
<a name="ln98">  // optional sign</a>
<a name="ln99">  if(*str == '+' || *str == '-')</a>
<a name="ln100">  {</a>
<a name="ln101">    sign = *str;</a>
<a name="ln102">    str++;</a>
<a name="ln103">    len--;</a>
<a name="ln104">  }</a>
<a name="ln105"> </a>
<a name="ln106">  // hh, mm or ss</a>
<a name="ln107">  if(len &lt; 2) return FALSE;</a>
<a name="ln108">  if(!g_ascii_isdigit(str[0]) || !g_ascii_isdigit(str[1]))</a>
<a name="ln109">    return FALSE;</a>
<a name="ln110">  else</a>
<a name="ln111">  {</a>
<a name="ln112">    numbers[fields++] = 10 * (str[0] - '0') + (str[1] - '0');</a>
<a name="ln113">    str += 2;</a>
<a name="ln114">    len -= 2;</a>
<a name="ln115">  }</a>
<a name="ln116"> </a>
<a name="ln117">  // : or end</a>
<a name="ln118">  if(*str == '\0') goto parse_success;</a>
<a name="ln119">  if(*str == ':')</a>
<a name="ln120">  {</a>
<a name="ln121">    str++;</a>
<a name="ln122">    len--;</a>
<a name="ln123">  }</a>
<a name="ln124"> </a>
<a name="ln125">  // mm or ss</a>
<a name="ln126">  if(len &lt; 2) return FALSE;</a>
<a name="ln127">  if(!g_ascii_isdigit(str[0]) || !g_ascii_isdigit(str[1]))</a>
<a name="ln128">    return FALSE;</a>
<a name="ln129">  else</a>
<a name="ln130">  {</a>
<a name="ln131">    numbers[fields++] = 10 * (str[0] - '0') + (str[1] - '0');</a>
<a name="ln132">    str += 2;</a>
<a name="ln133">    len -= 2;</a>
<a name="ln134">  }</a>
<a name="ln135"> </a>
<a name="ln136">  // : or end</a>
<a name="ln137">  if(*str == '\0') goto parse_success;</a>
<a name="ln138">  if(*str == ':')</a>
<a name="ln139">  {</a>
<a name="ln140">    str++;</a>
<a name="ln141">    len--;</a>
<a name="ln142">  }</a>
<a name="ln143"> </a>
<a name="ln144">  // ss</a>
<a name="ln145">  if(len &lt; 2) return FALSE;</a>
<a name="ln146">  if(!g_ascii_isdigit(str[0]) || !g_ascii_isdigit(str[1]))</a>
<a name="ln147">    return FALSE;</a>
<a name="ln148">  else</a>
<a name="ln149">  {</a>
<a name="ln150">    numbers[fields++] = 10 * (str[0] - '0') + (str[1] - '0');</a>
<a name="ln151">    str += 2;</a>
<a name="ln152">//     len -= 2;</a>
<a name="ln153">  }</a>
<a name="ln154"> </a>
<a name="ln155">  // end</a>
<a name="ln156">  if(*str == '\0') goto parse_success;</a>
<a name="ln157"> </a>
<a name="ln158">  return FALSE;</a>
<a name="ln159"> </a>
<a name="ln160">parse_success:</a>
<a name="ln161">  if(seconds)</a>
<a name="ln162">  {</a>
<a name="ln163">    // assemble the numbers in numbers[] into a single seconds value</a>
<a name="ln164">    switch(fields)</a>
<a name="ln165">    {</a>
<a name="ln166">      case 1: // 0: seconds</a>
<a name="ln167">        result = numbers[0];</a>
<a name="ln168">        break;</a>
<a name="ln169">      case 2: // 0: minutes, 1: seconds</a>
<a name="ln170">        result = 60 * numbers[0] + numbers[1];</a>
<a name="ln171">        break;</a>
<a name="ln172">      case 3: // 0: hours, 1: minutes, 2: seconds</a>
<a name="ln173">        result = 60 * 60 * numbers[0] + 60 * numbers[1] + numbers[2];</a>
<a name="ln174">        break;</a>
<a name="ln175">      default: // shouldn't happen</a>
<a name="ln176">        fprintf(stderr, &quot;[geotagging] error: something went terribly wrong while parsing the offset, %d &quot;</a>
<a name="ln177">                        &quot;fields found in %s\n&quot;,</a>
<a name="ln178">                fields, str_bak);</a>
<a name="ln179">    }</a>
<a name="ln180"> </a>
<a name="ln181">    if(sign == '-') result *= -1;</a>
<a name="ln182">    *seconds = result;</a>
<a name="ln183">  }</a>
<a name="ln184"> </a>
<a name="ln185">  return TRUE;</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">static gboolean _lib_geotagging_offset_key_press(GtkWidget *entry, GdkEventKey *event, dt_lib_module_t *self)</a>
<a name="ln189">{</a>
<a name="ln190">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)self-&gt;data;</a>
<a name="ln191">  switch(event-&gt;keyval)</a>
<a name="ln192">  {</a>
<a name="ln193">    case GDK_KEY_Escape:</a>
<a name="ln194">    case GDK_KEY_Tab:</a>
<a name="ln195">    {</a>
<a name="ln196">      // reset</a>
<a name="ln197">      gchar *str = dt_conf_get_string(&quot;plugins/lighttable/geotagging/offset&quot;);</a>
<a name="ln198">      if(_lib_geotagging_parse_offset(str, NULL))</a>
<a name="ln199">      {</a>
<a name="ln200">        gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), str);</a>
<a name="ln201">      }</a>
<a name="ln202">      else</a>
<a name="ln203">      {</a>
<a name="ln204">        gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), &quot;+00:00:00&quot;);</a>
<a name="ln205">        dt_conf_set_string(&quot;plugins/lighttable/geotagging/offset&quot;, &quot;+00:00:00&quot;);</a>
<a name="ln206">      }</a>
<a name="ln207">      g_free(str);</a>
<a name="ln208">      gtk_window_set_focus(GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)), NULL);</a>
<a name="ln209">      return FALSE;</a>
<a name="ln210">    }</a>
<a name="ln211"> </a>
<a name="ln212">    case GDK_KEY_Return:</a>
<a name="ln213">    case GDK_KEY_KP_Enter:</a>
<a name="ln214">    {</a>
<a name="ln215">      const gchar *value = gtk_entry_get_text(GTK_ENTRY(d-&gt;offset_entry));</a>
<a name="ln216">      if(_lib_geotagging_parse_offset(value, NULL))</a>
<a name="ln217">      {</a>
<a name="ln218">        dt_conf_set_string(&quot;plugins/lighttable/geotagging/offset&quot;, value);</a>
<a name="ln219">      }</a>
<a name="ln220">      else</a>
<a name="ln221">      {</a>
<a name="ln222">        gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), &quot;+00:00:00&quot;);</a>
<a name="ln223">        dt_conf_set_string(&quot;plugins/lighttable/geotagging/offset&quot;, &quot;+00:00:00&quot;);</a>
<a name="ln224">      }</a>
<a name="ln225">      gtk_window_set_focus(GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)), NULL);</a>
<a name="ln226">      return FALSE;</a>
<a name="ln227">    }</a>
<a name="ln228"> </a>
<a name="ln229">    // allow +, -, :, 0 .. 9, left/right/home/end movement using arrow keys and del/backspace</a>
<a name="ln230">    case GDK_KEY_plus:</a>
<a name="ln231">    case GDK_KEY_KP_Add:</a>
<a name="ln232">    case GDK_KEY_minus:</a>
<a name="ln233">    case GDK_KEY_KP_Subtract:</a>
<a name="ln234">    case GDK_KEY_colon:</a>
<a name="ln235">    case GDK_KEY_0:</a>
<a name="ln236">    case GDK_KEY_KP_0:</a>
<a name="ln237">    case GDK_KEY_1:</a>
<a name="ln238">    case GDK_KEY_KP_1:</a>
<a name="ln239">    case GDK_KEY_2:</a>
<a name="ln240">    case GDK_KEY_KP_2:</a>
<a name="ln241">    case GDK_KEY_3:</a>
<a name="ln242">    case GDK_KEY_KP_3:</a>
<a name="ln243">    case GDK_KEY_4:</a>
<a name="ln244">    case GDK_KEY_KP_4:</a>
<a name="ln245">    case GDK_KEY_5:</a>
<a name="ln246">    case GDK_KEY_KP_5:</a>
<a name="ln247">    case GDK_KEY_6:</a>
<a name="ln248">    case GDK_KEY_KP_6:</a>
<a name="ln249">    case GDK_KEY_7:</a>
<a name="ln250">    case GDK_KEY_KP_7:</a>
<a name="ln251">    case GDK_KEY_8:</a>
<a name="ln252">    case GDK_KEY_KP_8:</a>
<a name="ln253">    case GDK_KEY_9:</a>
<a name="ln254">    case GDK_KEY_KP_9:</a>
<a name="ln255"> </a>
<a name="ln256">    case GDK_KEY_Left:</a>
<a name="ln257">    case GDK_KEY_Right:</a>
<a name="ln258">    case GDK_KEY_Home:</a>
<a name="ln259">    case GDK_KEY_KP_Home:</a>
<a name="ln260">    case GDK_KEY_End:</a>
<a name="ln261">    case GDK_KEY_KP_End:</a>
<a name="ln262">    case GDK_KEY_Delete:</a>
<a name="ln263">    case GDK_KEY_KP_Delete:</a>
<a name="ln264">    case GDK_KEY_BackSpace:</a>
<a name="ln265">      return FALSE;</a>
<a name="ln266"> </a>
<a name="ln267">    default: // block everything else</a>
<a name="ln268">      return TRUE;</a>
<a name="ln269">  }</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">static gboolean _lib_geotagging_offset_focus_out(GtkWidget *widget, GdkEvent *event, dt_lib_module_t *self)</a>
<a name="ln273">{</a>
<a name="ln274">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)self-&gt;data;</a>
<a name="ln275">  const gchar *value = gtk_entry_get_text(GTK_ENTRY(d-&gt;offset_entry));</a>
<a name="ln276">  if(_lib_geotagging_parse_offset(value, NULL))</a>
<a name="ln277">    dt_conf_set_string(&quot;plugins/lighttable/geotagging/offset&quot;, value);</a>
<a name="ln278">  else</a>
<a name="ln279">  {</a>
<a name="ln280">    gchar *str = dt_conf_get_string(&quot;plugins/lighttable/geotagging/offset&quot;);</a>
<a name="ln281">    gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), str);</a>
<a name="ln282">    g_free(str);</a>
<a name="ln283">  }</a>
<a name="ln284">  return FALSE;</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287">static void _lib_geotagging_calculate_offset_callback(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln288">{</a>
<a name="ln289">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)self-&gt;data;</a>
<a name="ln290">  const gchar *gps_time = gtk_entry_get_text(GTK_ENTRY(d-&gt;floating_window_entry));</a>
<a name="ln291">  if(gps_time)</a>
<a name="ln292">  {</a>
<a name="ln293">    gchar **tokens = g_strsplit(gps_time, &quot;:&quot;, 0);</a>
<a name="ln294">    if(tokens[0] != NULL &amp;&amp; tokens[1] != NULL &amp;&amp; tokens[2] != NULL)</a>
<a name="ln295">    {</a>
<a name="ln296">      if(g_ascii_isdigit(tokens[0][0]) &amp;&amp; g_ascii_isdigit(tokens[0][1]) &amp;&amp; tokens[0][2] == '\0'</a>
<a name="ln297">         &amp;&amp; g_ascii_isdigit(tokens[1][0]) &amp;&amp; g_ascii_isdigit(tokens[1][1]) &amp;&amp; tokens[1][2] == '\0'</a>
<a name="ln298">         &amp;&amp; g_ascii_isdigit(tokens[2][0]) &amp;&amp; g_ascii_isdigit(tokens[2][1]) &amp;&amp; tokens[2][2] == '\0')</a>
<a name="ln299">      {</a>
<a name="ln300">        int h, m, s;</a>
<a name="ln301">        h = (tokens[0][0] - '0') * 10 + tokens[0][1] - '0';</a>
<a name="ln302">        m = (tokens[1][0] - '0') * 10 + tokens[1][1] - '0';</a>
<a name="ln303">        s = (tokens[2][0] - '0') * 10 + tokens[2][1] - '0';</a>
<a name="ln304">        if(h &lt; 24 &amp;&amp; m &lt; 60 &amp;&amp; s &lt; 60)</a>
<a name="ln305">        {</a>
<a name="ln306">          // finally a valid time</a>
<a name="ln307">          // get imgid</a>
<a name="ln308">          int32_t imgid = -1;</a>
<a name="ln309">          sqlite3_stmt *stmt;</a>
<a name="ln310">          DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln311">                                      &quot;SELECT imgid FROM main.selected_images ORDER BY imgid ASC LIMIT 1&quot;, -1,</a>
<a name="ln312">                                      &amp;stmt, NULL);</a>
<a name="ln313">          if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln314">            imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln315">          else // no selection is used, use mouse over id</a>
<a name="ln316">            imgid = dt_control_get_mouse_over_id();</a>
<a name="ln317">          sqlite3_finalize(stmt);</a>
<a name="ln318"> </a>
<a name="ln319">          if(imgid &gt; 0)</a>
<a name="ln320">          {</a>
<a name="ln321">            const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln322">            // get the exif_datetime_taken and parse it</a>
<a name="ln323">            gint year;</a>
<a name="ln324">            gint month;</a>
<a name="ln325">            gint day;</a>
<a name="ln326">            gint hour;</a>
<a name="ln327">            gint minute;</a>
<a name="ln328">            gint second;</a>
<a name="ln329"> </a>
<a name="ln330">            if(sscanf(cimg-&gt;exif_datetime_taken, &quot;%d:%d:%d %d:%d:%d&quot;, (int *)&amp;year, (int *)&amp;month,</a>
<a name="ln331">                      (int *)&amp;day, (int *)&amp;hour, (int *)&amp;minute, (int *)&amp;second) == 6)</a>
<a name="ln332">            {</a>
<a name="ln333">              // calculate the offset</a>
<a name="ln334">              long int exif_seconds = hour * 60 * 60 + minute * 60 + second;</a>
<a name="ln335">              long int gps_seconds = h * 60 * 60 + m * 60 + s;</a>
<a name="ln336">              long int offset = gps_seconds - exif_seconds;</a>
<a name="ln337">              // transform the offset back into a string</a>
<a name="ln338">              gchar sign = (offset &lt; 0) ? '-' : '+';</a>
<a name="ln339">              offset = labs(offset);</a>
<a name="ln340">              gint offset_h = offset / (60 * 60);</a>
<a name="ln341">              offset -= offset_h * 60 * 60;</a>
<a name="ln342">              gint offset_m = offset / 60;</a>
<a name="ln343">              offset -= offset_m * 60;</a>
<a name="ln344">              gchar *offset_str = g_strdup_printf(&quot;%c%02d:%02d:%02ld&quot;, sign, offset_h, offset_m, offset);</a>
<a name="ln345">              // write the offset into d-&gt;offset_entry</a>
<a name="ln346">              gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), offset_str);</a>
<a name="ln347">              g_free(offset_str);</a>
<a name="ln348">            }</a>
<a name="ln349"> </a>
<a name="ln350">            dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln351">          }</a>
<a name="ln352">        }</a>
<a name="ln353">      }</a>
<a name="ln354">    }</a>
<a name="ln355">    g_strfreev(tokens);</a>
<a name="ln356">  }</a>
<a name="ln357">  gtk_widget_destroy(d-&gt;floating_window);</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">static gboolean _lib_geotagging_floating_key_press(GtkWidget *entry, GdkEventKey *event, dt_lib_module_t *self)</a>
<a name="ln361">{</a>
<a name="ln362">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)self-&gt;data;</a>
<a name="ln363">  switch(event-&gt;keyval)</a>
<a name="ln364">  {</a>
<a name="ln365">    case GDK_KEY_Escape:</a>
<a name="ln366">      gtk_widget_destroy(d-&gt;floating_window);</a>
<a name="ln367">      return TRUE;</a>
<a name="ln368"> </a>
<a name="ln369">    case GDK_KEY_Return:</a>
<a name="ln370">    case GDK_KEY_KP_Enter:</a>
<a name="ln371">      _lib_geotagging_calculate_offset_callback(NULL, self);</a>
<a name="ln372">      return TRUE;</a>
<a name="ln373"> </a>
<a name="ln374">    default:</a>
<a name="ln375">      return FALSE;</a>
<a name="ln376">  }</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">static void _lib_geotagging_show_offset_window(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln380">{</a>
<a name="ln381">  dt_lib_geotagging_t *d = self-&gt;data;</a>
<a name="ln382">  gint x, y;</a>
<a name="ln383">  gint px, py, center_w, center_h, window_w, window_h;</a>
<a name="ln384">  GtkWidget *window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln385">  GtkWidget *center = dt_ui_center(darktable.gui-&gt;ui);</a>
<a name="ln386">  gdk_window_get_origin(gtk_widget_get_window(center), &amp;px, &amp;py);</a>
<a name="ln387"> </a>
<a name="ln388">  center_w = gdk_window_get_width(gtk_widget_get_window(center));</a>
<a name="ln389">  center_h = gdk_window_get_height(gtk_widget_get_window(center));</a>
<a name="ln390"> </a>
<a name="ln391">  d-&gt;floating_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</a>
<a name="ln392">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln393">  dt_osx_disallow_fullscreen(d-&gt;floating_window);</a>
<a name="ln394">#endif</a>
<a name="ln395">  gtk_widget_set_can_focus(d-&gt;floating_window, TRUE);</a>
<a name="ln396">  gtk_window_set_decorated(GTK_WINDOW(d-&gt;floating_window), FALSE);</a>
<a name="ln397">  gtk_window_set_type_hint(GTK_WINDOW(d-&gt;floating_window), GDK_WINDOW_TYPE_HINT_POPUP_MENU);</a>
<a name="ln398">  gtk_window_set_transient_for(GTK_WINDOW(d-&gt;floating_window), GTK_WINDOW(window));</a>
<a name="ln399">  gtk_widget_set_opacity(d-&gt;floating_window, 0.8);</a>
<a name="ln400">  gtk_window_set_modal(GTK_WINDOW(d-&gt;floating_window), TRUE);</a>
<a name="ln401"> </a>
<a name="ln402">  GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln403">  gtk_container_add(GTK_CONTAINER(d-&gt;floating_window), vbox);</a>
<a name="ln404"> </a>
<a name="ln405">  d-&gt;floating_window_entry = gtk_entry_new();</a>
<a name="ln406">  gtk_widget_add_events(d-&gt;floating_window_entry, GDK_FOCUS_CHANGE_MASK);</a>
<a name="ln407">  g_signal_connect_swapped(d-&gt;floating_window, &quot;focus-out-event&quot;, G_CALLBACK(gtk_widget_destroy),</a>
<a name="ln408">                           d-&gt;floating_window);</a>
<a name="ln409">  gtk_widget_set_tooltip_text(d-&gt;floating_window_entry,</a>
<a name="ln410">                              _(&quot;enter the time shown on the selected picture\nformat: hh:mm:ss&quot;));</a>
<a name="ln411"> </a>
<a name="ln412">  gtk_editable_select_region(GTK_EDITABLE(d-&gt;floating_window_entry), 0, -1);</a>
<a name="ln413">  gtk_box_pack_start(GTK_BOX(vbox), d-&gt;floating_window_entry, TRUE, TRUE, 0);</a>
<a name="ln414">  g_signal_connect(d-&gt;floating_window_entry, &quot;key-press-event&quot;,</a>
<a name="ln415">                   G_CALLBACK(_lib_geotagging_floating_key_press), self);</a>
<a name="ln416"> </a>
<a name="ln417">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln418">  GtkWidget *cancel_button = gtk_button_new_with_label(_(&quot;cancel&quot;));</a>
<a name="ln419">  GtkWidget *ok_button = gtk_button_new_with_label(_(&quot;ok&quot;));</a>
<a name="ln420"> </a>
<a name="ln421">  gtk_box_pack_start(GTK_BOX(hbox), cancel_button, TRUE, TRUE, 0);</a>
<a name="ln422">  gtk_box_pack_start(GTK_BOX(hbox), ok_button, TRUE, TRUE, 0);</a>
<a name="ln423">  g_signal_connect_swapped(G_OBJECT(cancel_button), &quot;clicked&quot;, G_CALLBACK(gtk_widget_destroy),</a>
<a name="ln424">                           d-&gt;floating_window);</a>
<a name="ln425">  g_signal_connect(G_OBJECT(ok_button), &quot;clicked&quot;, G_CALLBACK(_lib_geotagging_calculate_offset_callback),</a>
<a name="ln426">                   self);</a>
<a name="ln427"> </a>
<a name="ln428">  gtk_box_pack_start(GTK_BOX(vbox), hbox, TRUE, TRUE, 0);</a>
<a name="ln429"> </a>
<a name="ln430">  gtk_widget_show_all(d-&gt;floating_window);</a>
<a name="ln431">  gtk_widget_grab_focus(d-&gt;floating_window_entry);</a>
<a name="ln432"> </a>
<a name="ln433">  window_w = gdk_window_get_width(gtk_widget_get_window(d-&gt;floating_window));</a>
<a name="ln434">  window_h = gdk_window_get_height(gtk_widget_get_window(d-&gt;floating_window));</a>
<a name="ln435"> </a>
<a name="ln436">  x = px + 0.5 * (center_w - window_w);</a>
<a name="ln437">  y = py + center_h - 20 - window_h;</a>
<a name="ln438">  gtk_window_move(GTK_WINDOW(d-&gt;floating_window), x, y);</a>
<a name="ln439"> </a>
<a name="ln440">  gtk_window_present(GTK_WINDOW(d-&gt;floating_window));</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">// modify the datetime_taken field in the db/cache</a>
<a name="ln444">static void _lib_geotagging_apply_offset_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln445">{</a>
<a name="ln446">  dt_lib_geotagging_t *l = (dt_lib_geotagging_t *)((dt_lib_module_t *)user_data)-&gt;data;</a>
<a name="ln447">  long int offset = 0;</a>
<a name="ln448">  _lib_geotagging_parse_offset(gtk_entry_get_text(GTK_ENTRY(l-&gt;offset_entry)), &amp;offset);</a>
<a name="ln449">  dt_control_time_offset(offset, -1);</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">static gboolean _lib_geotagging_filter_gpx(const GtkFileFilterInfo *filter_info, gpointer data)</a>
<a name="ln453">{</a>
<a name="ln454">  if(!g_ascii_strcasecmp(filter_info-&gt;mime_type, &quot;application/gpx+xml&quot;)) return TRUE;</a>
<a name="ln455"> </a>
<a name="ln456">  const gchar *filename = filter_info-&gt;filename;</a>
<a name="ln457">  const char *cc = filename + strlen(filename);</a>
<a name="ln458">  for(; *cc != '.' &amp;&amp; cc &gt; filename; cc--)</a>
<a name="ln459">    ;</a>
<a name="ln460"> </a>
<a name="ln461">  if(!g_ascii_strcasecmp(cc, &quot;.gpx&quot;)) return TRUE;</a>
<a name="ln462"> </a>
<a name="ln463">  return FALSE;</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">static void _lib_geotagging_gpx_callback(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln467">{</a>
<a name="ln468">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)self-&gt;data;</a>
<a name="ln469">  /* bring a filechooser to select the gpx file to apply to selection */</a>
<a name="ln470">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln471">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln472">      _(&quot;open GPX file&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_OPEN, _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL,</a>
<a name="ln473">      _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln474">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln475">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln476">#endif</a>
<a name="ln477"> </a>
<a name="ln478">  char *last_directory = dt_conf_get_string(&quot;ui_last/gpx_last_directory&quot;);</a>
<a name="ln479">  if(last_directory != NULL)</a>
<a name="ln480">  {</a>
<a name="ln481">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(filechooser), last_directory);</a>
<a name="ln482">    g_free(last_directory);</a>
<a name="ln483">  }</a>
<a name="ln484"> </a>
<a name="ln485">  GtkFileFilter *filter;</a>
<a name="ln486">  filter = GTK_FILE_FILTER(gtk_file_filter_new());</a>
<a name="ln487">  gtk_file_filter_add_custom(filter, GTK_FILE_FILTER_FILENAME | GTK_FILE_FILTER_MIME_TYPE,</a>
<a name="ln488">                             _lib_geotagging_filter_gpx, NULL, NULL);</a>
<a name="ln489">  gtk_file_filter_set_name(filter, _(&quot;GPS data exchange format&quot;));</a>
<a name="ln490">  gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(filechooser), filter);</a>
<a name="ln491"> </a>
<a name="ln492">  filter = GTK_FILE_FILTER(gtk_file_filter_new());</a>
<a name="ln493">  gtk_file_filter_add_pattern(filter, &quot;*&quot;);</a>
<a name="ln494">  gtk_file_filter_set_name(filter, _(&quot;all files&quot;));</a>
<a name="ln495">  gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(filechooser), filter);</a>
<a name="ln496"> </a>
<a name="ln497">  // add time zone selection</a>
<a name="ln498">  GtkWidget *extra_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln499">  GtkWidget *label = gtk_label_new(_(&quot;camera time zone&quot;));</a>
<a name="ln500">  gtk_widget_set_tooltip_text(label, _(&quot;most cameras don't store the time zone in EXIF. &quot;</a>
<a name="ln501">                                       &quot;give the correct time zone so the GPX data can be correctly matched&quot;));</a>
<a name="ln502"> </a>
<a name="ln503">  GtkCellRenderer *renderer;</a>
<a name="ln504">  GtkTreeIter tree_iter;</a>
<a name="ln505">  GtkListStore *model = gtk_list_store_new(2, G_TYPE_STRING /*display*/, G_TYPE_STRING /*name*/);</a>
<a name="ln506"> </a>
<a name="ln507">  GtkWidget *tz_selection = gtk_combo_box_new_with_model(GTK_TREE_MODEL(model));</a>
<a name="ln508">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln509">  gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(tz_selection), renderer, FALSE);</a>
<a name="ln510">  gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(tz_selection), renderer, &quot;text&quot;, 0, NULL);</a>
<a name="ln511"> </a>
<a name="ln512">  int i = 0;</a>
<a name="ln513">  gchar *old_tz = dt_conf_get_string(&quot;plugins/lighttable/geotagging/tz&quot;);</a>
<a name="ln514">  for(GList *iter = d-&gt;timezones; iter; iter = g_list_next(iter))</a>
<a name="ln515">  {</a>
<a name="ln516">    tz_tuple_t *tz_tuple = (tz_tuple_t *)iter-&gt;data;</a>
<a name="ln517">    gtk_list_store_append(model, &amp;tree_iter);</a>
<a name="ln518">    gtk_list_store_set(model, &amp;tree_iter, 0, tz_tuple-&gt;display, 1, tz_tuple-&gt;name, -1);</a>
<a name="ln519">    if(i == 0 || !strcmp(tz_tuple-&gt;name, old_tz)) gtk_combo_box_set_active(GTK_COMBO_BOX(tz_selection), i);</a>
<a name="ln520">    i++;</a>
<a name="ln521">  }</a>
<a name="ln522">  g_free(old_tz);</a>
<a name="ln523"> </a>
<a name="ln524">  gtk_box_pack_start(GTK_BOX(extra_box), label, FALSE, FALSE, 0);</a>
<a name="ln525">  gtk_box_pack_start(GTK_BOX(extra_box), tz_selection, FALSE, FALSE, 0);</a>
<a name="ln526">  gtk_widget_show_all(extra_box);</a>
<a name="ln527">  gtk_file_chooser_set_extra_widget(GTK_FILE_CHOOSER(filechooser), extra_box);</a>
<a name="ln528"> </a>
<a name="ln529">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln530">  {</a>
<a name="ln531">    gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln532">    dt_conf_set_string(&quot;ui_last/gpx_last_directory&quot;, folder);</a>
<a name="ln533">    g_free(folder);</a>
<a name="ln534"> </a>
<a name="ln535">    gchar *tz;</a>
<a name="ln536">    if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(tz_selection), &amp;tree_iter) == TRUE)</a>
<a name="ln537">    {</a>
<a name="ln538">      GValue value = { 0, };</a>
<a name="ln539">      gtk_tree_model_get_value(GTK_TREE_MODEL(model), &amp;tree_iter, 1, &amp;value);</a>
<a name="ln540">      tz = g_strdup((gchar *)g_value_get_string(&amp;value));</a>
<a name="ln541">      g_value_unset(&amp;value);</a>
<a name="ln542">    }</a>
<a name="ln543">    else</a>
<a name="ln544">      tz = g_strdup(&quot;UTC&quot;);</a>
<a name="ln545">    dt_conf_set_string(&quot;plugins/lighttable/geotagging/tz&quot;, tz);</a>
<a name="ln546">    gchar *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln547">    dt_control_gpx_apply(filename, -1, tz);</a>
<a name="ln548">    g_free(filename);</a>
<a name="ln549">    g_free(tz);</a>
<a name="ln550">  }</a>
<a name="ln551"> </a>
<a name="ln552">  g_object_unref(model);</a>
<a name="ln553">  gtk_widget_destroy(extra_box);</a>
<a name="ln554">  gtk_widget_destroy(filechooser);</a>
<a name="ln555">  //   dt_control_queue_redraw_center();</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">static int _sort_timezones(gconstpointer a, gconstpointer b)</a>
<a name="ln559">{</a>
<a name="ln560">  const tz_tuple_t *tz_a = (tz_tuple_t *)a;</a>
<a name="ln561">  const tz_tuple_t *tz_b = (tz_tuple_t *)b;</a>
<a name="ln562"> </a>
<a name="ln563">#ifdef _WIN32</a>
<a name="ln564">  gboolean utc_neg_a = g_str_has_prefix(tz_a-&gt;display, &quot;(UTC-&quot;);</a>
<a name="ln565">  gboolean utc_neg_b = g_str_has_prefix(tz_b-&gt;display, &quot;(UTC-&quot;);</a>
<a name="ln566"> </a>
<a name="ln567">  gboolean utc_pos_a = g_str_has_prefix(tz_a-&gt;display, &quot;(UTC+&quot;);</a>
<a name="ln568">  gboolean utc_pos_b = g_str_has_prefix(tz_b-&gt;display, &quot;(UTC+&quot;);</a>
<a name="ln569"> </a>
<a name="ln570">  if(utc_neg_a &amp;&amp; utc_neg_b)</a>
<a name="ln571">  {</a>
<a name="ln572">    char *iter_a = tz_a-&gt;display + strlen(&quot;(UTC-&quot;);</a>
<a name="ln573">    char *iter_b = tz_b-&gt;display + strlen(&quot;(UTC-&quot;);</a>
<a name="ln574"> </a>
<a name="ln575">    while(((*iter_a &gt;= '0' &amp;&amp; *iter_a &lt;= '9') || *iter_a == ':') &amp;&amp;</a>
<a name="ln576">          ((*iter_b &gt;= '0' &amp;&amp; *iter_b &lt;= '9') || *iter_b == ':'))</a>
<a name="ln577">    {</a>
<a name="ln578">      if(*iter_a != *iter_b) return *iter_b - *iter_a;</a>
<a name="ln579">      iter_a++;</a>
<a name="ln580">      iter_b++;</a>
<a name="ln581">    }</a>
<a name="ln582">  }</a>
<a name="ln583">  else if(utc_neg_a &amp;&amp; utc_pos_b) return -1;</a>
<a name="ln584">  else if(utc_pos_a &amp;&amp; utc_neg_b) return 1;</a>
<a name="ln585">#endif</a>
<a name="ln586"> </a>
<a name="ln587">  return g_strcmp0(tz_a-&gt;display, tz_b-&gt;display);</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">// create a list of possible time zones</a>
<a name="ln591">static GList *_lib_geotagging_get_timezones(void)</a>
<a name="ln592">{</a>
<a name="ln593">  GList *timezones = NULL;</a>
<a name="ln594"> </a>
<a name="ln595">#ifndef _WIN32</a>
<a name="ln596">  // possible locations for zone.tab:</a>
<a name="ln597">  // - /usr/share/zoneinfo</a>
<a name="ln598">  // - /usr/lib/zoneinfo</a>
<a name="ln599">  // - getenv(&quot;TZDIR&quot;)</a>
<a name="ln600">  // - apparently on solaris there is no zones.tab. we need to collect the information ourselves like this:</a>
<a name="ln601">  //   /bin/grep -h ^Zone /usr/share/lib/zoneinfo/src/* | /bin/awk '{print &quot;??\t+9999+99999\t&quot; $2}'</a>
<a name="ln602">#define MAX_LINE_LENGTH 256</a>
<a name="ln603">  FILE *fp;</a>
<a name="ln604">  char line[MAX_LINE_LENGTH];</a>
<a name="ln605"> </a>
<a name="ln606">  // find the file using known possible locations</a>
<a name="ln607">  gchar *zone_tab = g_strdup(&quot;/usr/share/zoneinfo/zone.tab&quot;);</a>
<a name="ln608">  if(!g_file_test(zone_tab, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln609">  {</a>
<a name="ln610">    g_free(zone_tab);</a>
<a name="ln611">    zone_tab = g_strdup(&quot;/usr/lib/zoneinfo/zone.tab&quot;);</a>
<a name="ln612">    if(!g_file_test(zone_tab, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln613">    {</a>
<a name="ln614">      g_free(zone_tab);</a>
<a name="ln615">      zone_tab = g_build_filename(g_getenv(&quot;TZDIR&quot;), &quot;zone.tab&quot;, NULL);</a>
<a name="ln616">      if(!g_file_test(zone_tab, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln617">      {</a>
<a name="ln618">        g_free(zone_tab);</a>
<a name="ln619">        char datadir[PATH_MAX] = { 0 };</a>
<a name="ln620">        dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln621">        zone_tab = g_build_filename(datadir, &quot;zone.tab&quot;, NULL);</a>
<a name="ln622">        if(!g_file_test(zone_tab, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln623">        {</a>
<a name="ln624">          g_free(zone_tab);</a>
<a name="ln625">          // TODO: Solaris test</a>
<a name="ln626">          return NULL;</a>
<a name="ln627">        }</a>
<a name="ln628">      }</a>
<a name="ln629">    }</a>
<a name="ln630">  }</a>
<a name="ln631"> </a>
<a name="ln632">  // parse zone.tab and put all time zone descriptions into timezones</a>
<a name="ln633">  fp = g_fopen(zone_tab, &quot;r&quot;);</a>
<a name="ln634">  g_free(zone_tab);</a>
<a name="ln635"> </a>
<a name="ln636">  if(!fp) return NULL;</a>
<a name="ln637"> </a>
<a name="ln638">  while(fgets(line, MAX_LINE_LENGTH, fp))</a>
<a name="ln639">  {</a>
<a name="ln640">    if(line[0] == '#' || line[0] == '\0') continue;</a>
<a name="ln641">    gchar **tokens = g_strsplit_set(line, &quot; \t\n&quot;, 0);</a>
<a name="ln642">    // sometimes files are not separated by single tabs but multiple spaces, resulting in empty strings in tokens</a>
<a name="ln643">    // so we have to look for the 3rd non-empty entry</a>
<a name="ln644">    int n_found = -1, i;</a>
<a name="ln645">    for(i = 0; tokens[i] &amp;&amp; n_found &lt; 2; i++) if(*tokens[i]) n_found++;</a>
<a name="ln646">    if(n_found != 2)</a>
<a name="ln647">    {</a>
<a name="ln648">      g_strfreev(tokens);</a>
<a name="ln649">      continue;</a>
<a name="ln650">    }</a>
<a name="ln651">    gchar *name = g_strdup(tokens[i - 1]);</a>
<a name="ln652">    g_strfreev(tokens);</a>
<a name="ln653">    if(name[0] == '\0')</a>
<a name="ln654">    {</a>
<a name="ln655">      g_free(name);</a>
<a name="ln656">      continue;</a>
<a name="ln657">    }</a>
<a name="ln658">    size_t last_char = strlen(name) - 1;</a>
<a name="ln659">    if(name[last_char] == '\n') name[last_char] = '\0';</a>
<a name="ln660">    tz_tuple_t *tz_tuple = (tz_tuple_t *)malloc(sizeof(tz_tuple_t));</a>
<a name="ln661">    tz_tuple-&gt;display = name;</a>
<a name="ln662">    tz_tuple-&gt;name = name;</a>
<a name="ln663">    timezones = g_list_prepend(timezones, tz_tuple);</a>
<a name="ln664">  }</a>
<a name="ln665"> </a>
<a name="ln666">  fclose(fp);</a>
<a name="ln667"> </a>
<a name="ln668">  // sort timezones</a>
<a name="ln669">  timezones = g_list_sort(timezones, _sort_timezones);</a>
<a name="ln670"> </a>
<a name="ln671">  tz_tuple_t *utc = (tz_tuple_t *)malloc(sizeof(tz_tuple_t));</a>
<a name="ln672">  utc-&gt;display = g_strdup(&quot;UTC&quot;);</a>
<a name="ln673">  utc-&gt;name = utc-&gt;display;</a>
<a name="ln674">  timezones = g_list_prepend(timezones, utc);</a>
<a name="ln675"> </a>
<a name="ln676">#undef MAX_LINE_LENGTH</a>
<a name="ln677"> </a>
<a name="ln678">#else // !_WIN32</a>
<a name="ln679">  // on Windows we have to grab the time zones from the registry</a>
<a name="ln680">  char *keypath = &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\\&quot;;</a>
<a name="ln681">  HKEY hKey;</a>
<a name="ln682"> </a>
<a name="ln683">  if(RegOpenKeyExA(HKEY_LOCAL_MACHINE,</a>
<a name="ln684">                   keypath,</a>
<a name="ln685">                   0,</a>
<a name="ln686">                   KEY_READ,</a>
<a name="ln687">                   &amp;hKey) == ERROR_SUCCESS)</a>
<a name="ln688">  {</a>
<a name="ln689">    DWORD n_subkeys, max_subkey_len;</a>
<a name="ln690"> </a>
<a name="ln691">    if(RegQueryInfoKey(hKey,</a>
<a name="ln692">                       NULL,</a>
<a name="ln693">                       NULL,</a>
<a name="ln694">                       NULL,</a>
<a name="ln695">                       &amp;n_subkeys,</a>
<a name="ln696">                       &amp;max_subkey_len,</a>
<a name="ln697">                       NULL,</a>
<a name="ln698">                       NULL,</a>
<a name="ln699">                       NULL,</a>
<a name="ln700">                       NULL,</a>
<a name="ln701">                       NULL,</a>
<a name="ln702">                       NULL) == ERROR_SUCCESS)</a>
<a name="ln703">    {</a>
<a name="ln704">      wchar_t *subkeyname = (wchar_t *)malloc((max_subkey_len + 1) * sizeof(wchar_t));</a>
<a name="ln705"> </a>
<a name="ln706">      for(DWORD i = 1; i &lt; n_subkeys; i++)</a>
<a name="ln707">      {</a>
<a name="ln708">        DWORD subkeyname_length = max_subkey_len + 1;</a>
<a name="ln709">        if(RegEnumKeyExW(hKey,</a>
<a name="ln710">                         i,</a>
<a name="ln711">                         subkeyname,</a>
<a name="ln712">                         &amp;subkeyname_length,</a>
<a name="ln713">                         NULL,</a>
<a name="ln714">                         NULL,</a>
<a name="ln715">                         NULL,</a>
<a name="ln716">                         NULL) == ERROR_SUCCESS)</a>
<a name="ln717">        {</a>
<a name="ln718">          DWORD buffer_size;</a>
<a name="ln719">          char *subkeyname_utf8 = g_utf16_to_utf8(subkeyname, -1, NULL, NULL, NULL);</a>
<a name="ln720">          char *subkeypath_utf8 = g_strconcat(keypath, &quot;\\&quot;, subkeyname_utf8, NULL);</a>
<a name="ln721">          wchar_t *subkeypath = g_utf8_to_utf16(subkeypath_utf8, -1, NULL, NULL, NULL);</a>
<a name="ln722">          if(RegGetValueW(HKEY_LOCAL_MACHINE,</a>
<a name="ln723">                          subkeypath,</a>
<a name="ln724">                          L&quot;Display&quot;,</a>
<a name="ln725">                          RRF_RT_ANY,</a>
<a name="ln726">                          NULL,</a>
<a name="ln727">                          NULL,</a>
<a name="ln728">                          &amp;buffer_size) == ERROR_SUCCESS)</a>
<a name="ln729">          {</a>
<a name="ln730">            wchar_t *display_name = (wchar_t *)malloc(buffer_size);</a>
<a name="ln731">            if(RegGetValueW(HKEY_LOCAL_MACHINE,</a>
<a name="ln732">                            subkeypath,</a>
<a name="ln733">                            L&quot;Display&quot;,</a>
<a name="ln734">                            RRF_RT_ANY,</a>
<a name="ln735">                            NULL,</a>
<a name="ln736">                            display_name,</a>
<a name="ln737">                            &amp;buffer_size) == ERROR_SUCCESS)</a>
<a name="ln738">            {</a>
<a name="ln739">              tz_tuple_t *tz = (tz_tuple_t *)malloc(sizeof(tz_tuple_t));</a>
<a name="ln740"> </a>
<a name="ln741">              tz-&gt;name = subkeyname_utf8;</a>
<a name="ln742">              tz-&gt;display = g_utf16_to_utf8(display_name, -1, NULL, NULL, NULL);</a>
<a name="ln743">              timezones = g_list_prepend(timezones, tz);</a>
<a name="ln744"> </a>
<a name="ln745">              subkeyname_utf8 = NULL; // to not free it later</a>
<a name="ln746">            }</a>
<a name="ln747">            free(display_name);</a>
<a name="ln748">          }</a>
<a name="ln749">          g_free(subkeyname_utf8);</a>
<a name="ln750">          g_free(subkeypath_utf8);</a>
<a name="ln751">          g_free(subkeypath);</a>
<a name="ln752">        }</a>
<a name="ln753">      }</a>
<a name="ln754"> </a>
<a name="ln755">      free(subkeyname);</a>
<a name="ln756">    }</a>
<a name="ln757">  }</a>
<a name="ln758"> </a>
<a name="ln759">  RegCloseKey(hKey);</a>
<a name="ln760"> </a>
<a name="ln761">  timezones = g_list_sort(timezones, _sort_timezones);</a>
<a name="ln762">#endif // !_WIN32</a>
<a name="ln763"> </a>
<a name="ln764">  return timezones;</a>
<a name="ln765">}</a>
<a name="ln766"> </a>
<a name="ln767"> </a>
<a name="ln768">void gui_init(dt_lib_module_t *self)</a>
<a name="ln769">{</a>
<a name="ln770">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)malloc(sizeof(dt_lib_geotagging_t));</a>
<a name="ln771">  self-&gt;data = (void *)d;</a>
<a name="ln772">  d-&gt;timezones = _lib_geotagging_get_timezones();</a>
<a name="ln773">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln774">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln775">  GtkBox *hbox;</a>
<a name="ln776">  GtkWidget *button, *label;</a>
<a name="ln777"> </a>
<a name="ln778">  /* the offset line */</a>
<a name="ln779">  hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln780">  label = GTK_WIDGET(gtk_label_new(_(&quot;time offset&quot;)));</a>
<a name="ln781">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln782">  gtk_box_pack_start(hbox, label, FALSE, TRUE, 0);</a>
<a name="ln783"> </a>
<a name="ln784">  d-&gt;offset_entry = gtk_entry_new();</a>
<a name="ln785">  dt_gui_key_accel_block_on_focus_connect(d-&gt;offset_entry);</a>
<a name="ln786">  gtk_entry_set_max_length(GTK_ENTRY(d-&gt;offset_entry), 9);</a>
<a name="ln787">  gtk_entry_set_width_chars(GTK_ENTRY(d-&gt;offset_entry), 0);</a>
<a name="ln788">  gtk_box_pack_start(hbox, d-&gt;offset_entry, TRUE, TRUE, 0);</a>
<a name="ln789">  g_signal_connect(d-&gt;offset_entry, &quot;key-press-event&quot;, G_CALLBACK(_lib_geotagging_offset_key_press), self);</a>
<a name="ln790">  g_signal_connect(d-&gt;offset_entry, &quot;focus-out-event&quot;, G_CALLBACK(_lib_geotagging_offset_focus_out), self);</a>
<a name="ln791">  gtk_widget_set_tooltip_text(d-&gt;offset_entry, _(&quot;time offset\nformat: [+-]?[[hh:]mm:]ss&quot;));</a>
<a name="ln792">  gchar *str = dt_conf_get_string(&quot;plugins/lighttable/geotagging/offset&quot;);</a>
<a name="ln793">  if(_lib_geotagging_parse_offset(str, NULL))</a>
<a name="ln794">    gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), str);</a>
<a name="ln795">  else</a>
<a name="ln796">    gtk_entry_set_text(GTK_ENTRY(d-&gt;offset_entry), &quot;+00:00:00&quot;);</a>
<a name="ln797">  g_free(str);</a>
<a name="ln798"> </a>
<a name="ln799">  GtkBox *button_box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln800">  button = dtgtk_button_new(dtgtk_cairo_paint_zoom, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln801">  gtk_widget_set_tooltip_text(button, _(&quot;calculate the time offset from an image&quot;));</a>
<a name="ln802">  gtk_box_pack_start(button_box, button, TRUE, TRUE, 0);</a>
<a name="ln803">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(_lib_geotagging_show_offset_window), self);</a>
<a name="ln804"> </a>
<a name="ln805">  button = dtgtk_button_new(dtgtk_cairo_paint_check_mark, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln806">  gtk_widget_set_tooltip_text(button, _(&quot;apply time offset to selected images&quot;));</a>
<a name="ln807">  gtk_box_pack_start(button_box, button, TRUE, TRUE, 0);</a>
<a name="ln808">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(_lib_geotagging_apply_offset_callback), self);</a>
<a name="ln809"> </a>
<a name="ln810">  gtk_box_pack_start(hbox, GTK_WIDGET(button_box), FALSE, TRUE, 0);</a>
<a name="ln811">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hbox), TRUE, TRUE, 0);</a>
<a name="ln812"> </a>
<a name="ln813">  /* gpx */</a>
<a name="ln814">  button = gtk_button_new_with_label(_(&quot;apply GPX track file&quot;));</a>
<a name="ln815">  gtk_widget_set_tooltip_text(button, _(&quot;parses a GPX file and updates location of selected images&quot;));</a>
<a name="ln816">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), button, TRUE, TRUE, 0);</a>
<a name="ln817">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(_lib_geotagging_gpx_callback), self);</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln821">{</a>
<a name="ln822">  dt_lib_geotagging_t *d = (dt_lib_geotagging_t *)self-&gt;data;</a>
<a name="ln823">  dt_gui_key_accel_block_on_focus_disconnect(d-&gt;offset_entry);</a>
<a name="ln824">  g_list_free_full(d-&gt;timezones, free_tz_tuple);</a>
<a name="ln825">  d-&gt;timezones = NULL;</a>
<a name="ln826">  free(self-&gt;data);</a>
<a name="ln827">  self-&gt;data = NULL;</a>
<a name="ln828">}</a>
<a name="ln829"> </a>
<a name="ln830">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln831">{</a>
<a name="ln832">  //   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;remove from collection&quot;),</a>
<a name="ln833">  //                         GDK_Delete, 0);</a>
<a name="ln834">  //   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;delete from disk&quot;), 0, 0);</a>
<a name="ln835">  //   dt_accel_register_lib(self,</a>
<a name="ln836">  //                         NC_(&quot;accel&quot;, &quot;rotate selected images 90 degrees CW&quot;),</a>
<a name="ln837">  //                         0, 0);</a>
<a name="ln838">  //   dt_accel_register_lib(self,</a>
<a name="ln839">  //                         NC_(&quot;accel&quot;, &quot;rotate selected images 90 degrees CCW&quot;),</a>
<a name="ln840">  //                         0, 0);</a>
<a name="ln841">  //   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;create hdr&quot;), 0, 0);</a>
<a name="ln842">  //   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;duplicate&quot;), 0, 0);</a>
<a name="ln843">  //   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;reset rotation&quot;), 0, 0);</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln847">{</a>
<a name="ln848">  //   dt_lib_image_t *d = (dt_lib_image_t*)self-&gt;data;</a>
<a name="ln849">  //</a>
<a name="ln850">  //   dt_accel_connect_button_lib(self, &quot;remove from collection&quot;, d-&gt;remove_button);</a>
<a name="ln851">  //   dt_accel_connect_button_lib(self, &quot;delete from disk&quot;, d-&gt;delete_button);</a>
<a name="ln852">  //   dt_accel_connect_button_lib(self, &quot;rotate selected images 90 degrees CW&quot;,</a>
<a name="ln853">  //                               d-&gt;rotate_cw_button);</a>
<a name="ln854">  //   dt_accel_connect_button_lib(self, &quot;rotate selected images 90 degrees CCW&quot;,</a>
<a name="ln855">  //                               d-&gt;rotate_ccw_button);</a>
<a name="ln856">  //   dt_accel_connect_button_lib(self, &quot;create hdr&quot;, d-&gt;create_hdr_button);</a>
<a name="ln857">  //   dt_accel_connect_button_lib(self, &quot;duplicate&quot;, d-&gt;duplicate_button);</a>
<a name="ln858">  //   dt_accel_connect_button_lib(self, &quot;reset rotation&quot;, d-&gt;reset_button);</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln862">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln863">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="661"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'tz_tuple'. Check lines: 661, 660.</p></div>
<div class="balloon" rel="672"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'utc'. Check lines: 672, 671.</p></div>
<div class="balloon" rel="772"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 772, 770.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
