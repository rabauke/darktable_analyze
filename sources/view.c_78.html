
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4">    copyright (c) 2011-2014 henrik andersson.</a>
<a name="ln5">    copyright (c) 2012 tobias ellinghaus.</a>
<a name="ln6"> </a>
<a name="ln7">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln8">    it under the terms of the GNU General Public License as published by</a>
<a name="ln9">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln10">    (at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln13">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">    GNU General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">    You should have received a copy of the GNU General Public License</a>
<a name="ln18">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln19">*/</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;views/view.h&quot;</a>
<a name="ln22">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln23">#include &quot;common/collection.h&quot;</a>
<a name="ln24">#include &quot;common/darktable.h&quot;</a>
<a name="ln25">#include &quot;common/debug.h&quot;</a>
<a name="ln26">#include &quot;common/history.h&quot;</a>
<a name="ln27">#include &quot;common/image_cache.h&quot;</a>
<a name="ln28">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln29">#include &quot;common/module.h&quot;</a>
<a name="ln30">#include &quot;common/undo.h&quot;</a>
<a name="ln31">#include &quot;common/usermanual_url.h&quot;</a>
<a name="ln32">#include &quot;control/conf.h&quot;</a>
<a name="ln33">#include &quot;control/control.h&quot;</a>
<a name="ln34">#include &quot;develop/develop.h&quot;</a>
<a name="ln35">#include &quot;dtgtk/expander.h&quot;</a>
<a name="ln36">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln37">#include &quot;gui/gtk.h&quot;</a>
<a name="ln38">#include &quot;libs/lib.h&quot;</a>
<a name="ln39">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln40">#include &quot;osx/osx.h&quot;</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;glib.h&gt;</a>
<a name="ln44">#include &lt;math.h&gt;</a>
<a name="ln45">#include &lt;stdio.h&gt;</a>
<a name="ln46">#include &lt;stdlib.h&gt;</a>
<a name="ln47">#include &lt;string.h&gt;</a>
<a name="ln48">#include &lt;strings.h&gt;</a>
<a name="ln49"> </a>
<a name="ln50">#define DECORATION_SIZE_LIMIT 40</a>
<a name="ln51"> </a>
<a name="ln52">static void dt_view_manager_load_modules(dt_view_manager_t *vm);</a>
<a name="ln53">static int dt_view_load_module(void *v, const char *libname, const char *module_name);</a>
<a name="ln54">static void dt_view_unload_module(dt_view_t *view);</a>
<a name="ln55"> </a>
<a name="ln56">void dt_view_manager_init(dt_view_manager_t *vm)</a>
<a name="ln57">{</a>
<a name="ln58">  /* prepare statements */</a>
<a name="ln59">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images &quot;</a>
<a name="ln60">                              &quot;WHERE imgid = ?1&quot;, -1, &amp;vm-&gt;statements.is_selected, NULL);</a>
<a name="ln61">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images WHERE imgid = ?1&quot;,</a>
<a name="ln62">                              -1, &amp;vm-&gt;statements.delete_from_selected, NULL);</a>
<a name="ln63">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln64">                              &quot;INSERT OR IGNORE INTO main.selected_images VALUES (?1)&quot;, -1,</a>
<a name="ln65">                              &amp;vm-&gt;statements.make_selected, NULL);</a>
<a name="ln66">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT num FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln67">                              &amp;vm-&gt;statements.have_history, NULL);</a>
<a name="ln68">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT color FROM main.color_labels WHERE imgid=?1&quot;,</a>
<a name="ln69">                              -1, &amp;vm-&gt;statements.get_color, NULL);</a>
<a name="ln70">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln71">      dt_database_get(darktable.db),</a>
<a name="ln72">      &quot;SELECT id FROM main.images WHERE group_id = (SELECT group_id FROM main.images WHERE id=?1) AND id != ?2&quot;,</a>
<a name="ln73">      -1, &amp;vm-&gt;statements.get_grouped, NULL);</a>
<a name="ln74"> </a>
<a name="ln75">  dt_view_manager_load_modules(vm);</a>
<a name="ln76"> </a>
<a name="ln77">  // Modules loaded, let's handle specific cases</a>
<a name="ln78">  for(GList *iter = vm-&gt;views; iter; iter = g_list_next(iter))</a>
<a name="ln79">  {</a>
<a name="ln80">    dt_view_t *view = (dt_view_t *)iter-&gt;data;</a>
<a name="ln81">    if(!strcmp(view-&gt;module_name, &quot;darkroom&quot;))</a>
<a name="ln82">    {</a>
<a name="ln83">      darktable.develop = (dt_develop_t *)view-&gt;data;</a>
<a name="ln84">      break;</a>
<a name="ln85">    }</a>
<a name="ln86">  }</a>
<a name="ln87"> </a>
<a name="ln88">  vm-&gt;current_view = NULL;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">void dt_view_manager_gui_init(dt_view_manager_t *vm)</a>
<a name="ln92">{</a>
<a name="ln93">  for(GList *iter = vm-&gt;views; iter; iter = g_list_next(iter))</a>
<a name="ln94">  {</a>
<a name="ln95">    dt_view_t *view = (dt_view_t *)iter-&gt;data;</a>
<a name="ln96">    if(view-&gt;gui_init) view-&gt;gui_init(view);</a>
<a name="ln97">  }</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">void dt_view_manager_cleanup(dt_view_manager_t *vm)</a>
<a name="ln101">{</a>
<a name="ln102">  for(GList *iter = vm-&gt;views; iter; iter = g_list_next(iter)) dt_view_unload_module((dt_view_t *)iter-&gt;data);</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">const dt_view_t *dt_view_manager_get_current_view(dt_view_manager_t *vm)</a>
<a name="ln106">{</a>
<a name="ln107">  return vm-&gt;current_view;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">// we want a stable order of views, for example for viewswitcher.</a>
<a name="ln111">// anything not hardcoded will be put alphabetically wrt. localised names.</a>
<a name="ln112">static gint sort_views(gconstpointer a, gconstpointer b)</a>
<a name="ln113">{</a>
<a name="ln114">  static const char *view_order[] = {&quot;lighttable&quot;, &quot;darkroom&quot;};</a>
<a name="ln115">  static const int n_view_order = G_N_ELEMENTS(view_order);</a>
<a name="ln116"> </a>
<a name="ln117">  dt_view_t *av = (dt_view_t *)a;</a>
<a name="ln118">  dt_view_t *bv = (dt_view_t *)b;</a>
<a name="ln119">  const char *aname = av-&gt;name(av);</a>
<a name="ln120">  const char *bname = bv-&gt;name(bv);</a>
<a name="ln121">  int apos = n_view_order;</a>
<a name="ln122">  int bpos = n_view_order;</a>
<a name="ln123"> </a>
<a name="ln124">  for(int i = 0; i &lt; n_view_order; i++)</a>
<a name="ln125">  {</a>
<a name="ln126">    if(!strcmp(av-&gt;module_name, view_order[i])) apos = i;</a>
<a name="ln127">    if(!strcmp(bv-&gt;module_name, view_order[i])) bpos = i;</a>
<a name="ln128">  }</a>
<a name="ln129"> </a>
<a name="ln130">  // order will be zero iff apos == bpos which can only happen when both views are not in view_order</a>
<a name="ln131">  const int order = apos - bpos;</a>
<a name="ln132">  return order ? order : strcmp(aname, bname);</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">static void dt_view_manager_load_modules(dt_view_manager_t *vm)</a>
<a name="ln136">{</a>
<a name="ln137">  vm-&gt;views = dt_module_load_modules(&quot;/views&quot;, sizeof(dt_view_t), dt_view_load_module, NULL, sort_views);</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">/* default flags for view which does not implement the flags() function */</a>
<a name="ln141">static uint32_t default_flags()</a>
<a name="ln142">{</a>
<a name="ln143">  return 0;</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">/** load a view module */</a>
<a name="ln147">static int dt_view_load_module(void *v, const char *libname, const char *module_name)</a>
<a name="ln148">{</a>
<a name="ln149">  dt_view_t *view = (dt_view_t *)v;</a>
<a name="ln150"> </a>
<a name="ln151">  view-&gt;data = NULL;</a>
<a name="ln152">  view-&gt;vscroll_size = view-&gt;vscroll_viewport_size = 1.0;</a>
<a name="ln153">  view-&gt;hscroll_size = view-&gt;hscroll_viewport_size = 1.0;</a>
<a name="ln154">  view-&gt;vscroll_pos = view-&gt;hscroll_pos = 0.0;</a>
<a name="ln155">  view-&gt;height = view-&gt;width = 100; // set to non-insane defaults before first expose/configure.</a>
<a name="ln156">  g_strlcpy(view-&gt;module_name, module_name, sizeof(view-&gt;module_name));</a>
<a name="ln157">  dt_print(DT_DEBUG_CONTROL, &quot;[view_load_module] loading view `%s' from %s\n&quot;, module_name, libname);</a>
<a name="ln158">  view-&gt;module = g_module_open(libname, G_MODULE_BIND_LAZY | G_MODULE_BIND_LOCAL);</a>
<a name="ln159">  if(!view-&gt;module)</a>
<a name="ln160">  {</a>
<a name="ln161">    fprintf(stderr, &quot;[view_load_module] could not open %s (%s)!\n&quot;, libname, g_module_error());</a>
<a name="ln162">    goto error;</a>
<a name="ln163">  }</a>
<a name="ln164">  int (*version)();</a>
<a name="ln165">  if(!g_module_symbol(view-&gt;module, &quot;dt_module_dt_version&quot;, (gpointer) &amp; (version))) goto error;</a>
<a name="ln166">  if(version() != dt_version())</a>
<a name="ln167">  {</a>
<a name="ln168">    fprintf(stderr, &quot;[view_load_module] `%s' is compiled for another version of dt (module %d != dt %d) !\n&quot;,</a>
<a name="ln169">            libname, version(), dt_version());</a>
<a name="ln170">    goto error;</a>
<a name="ln171">  }</a>
<a name="ln172">  if(!g_module_symbol(view-&gt;module, &quot;name&quot;, (gpointer) &amp; (view-&gt;name))) view-&gt;name = NULL;</a>
<a name="ln173">  if(!g_module_symbol(view-&gt;module, &quot;view&quot;, (gpointer) &amp; (view-&gt;view))) view-&gt;view = NULL;</a>
<a name="ln174">  if(!g_module_symbol(view-&gt;module, &quot;flags&quot;, (gpointer) &amp; (view-&gt;flags))) view-&gt;flags = default_flags;</a>
<a name="ln175">  if(!g_module_symbol(view-&gt;module, &quot;init&quot;, (gpointer) &amp; (view-&gt;init))) view-&gt;init = NULL;</a>
<a name="ln176">  if(!g_module_symbol(view-&gt;module, &quot;gui_init&quot;, (gpointer) &amp; (view-&gt;gui_init))) view-&gt;gui_init = NULL;</a>
<a name="ln177">  if(!g_module_symbol(view-&gt;module, &quot;cleanup&quot;, (gpointer) &amp; (view-&gt;cleanup))) view-&gt;cleanup = NULL;</a>
<a name="ln178">  if(!g_module_symbol(view-&gt;module, &quot;expose&quot;, (gpointer) &amp; (view-&gt;expose))) view-&gt;expose = NULL;</a>
<a name="ln179">  if(!g_module_symbol(view-&gt;module, &quot;try_enter&quot;, (gpointer) &amp; (view-&gt;try_enter))) view-&gt;try_enter = NULL;</a>
<a name="ln180">  if(!g_module_symbol(view-&gt;module, &quot;enter&quot;, (gpointer) &amp; (view-&gt;enter))) view-&gt;enter = NULL;</a>
<a name="ln181">  if(!g_module_symbol(view-&gt;module, &quot;leave&quot;, (gpointer) &amp; (view-&gt;leave))) view-&gt;leave = NULL;</a>
<a name="ln182">  if(!g_module_symbol(view-&gt;module, &quot;reset&quot;, (gpointer) &amp; (view-&gt;reset))) view-&gt;reset = NULL;</a>
<a name="ln183">  if(!g_module_symbol(view-&gt;module, &quot;mouse_enter&quot;, (gpointer) &amp; (view-&gt;mouse_enter)))</a>
<a name="ln184">    view-&gt;mouse_enter = NULL;</a>
<a name="ln185">  if(!g_module_symbol(view-&gt;module, &quot;mouse_leave&quot;, (gpointer) &amp; (view-&gt;mouse_leave)))</a>
<a name="ln186">    view-&gt;mouse_leave = NULL;</a>
<a name="ln187">  if(!g_module_symbol(view-&gt;module, &quot;mouse_moved&quot;, (gpointer) &amp; (view-&gt;mouse_moved)))</a>
<a name="ln188">    view-&gt;mouse_moved = NULL;</a>
<a name="ln189">  if(!g_module_symbol(view-&gt;module, &quot;button_released&quot;, (gpointer) &amp; (view-&gt;button_released)))</a>
<a name="ln190">    view-&gt;button_released = NULL;</a>
<a name="ln191">  if(!g_module_symbol(view-&gt;module, &quot;button_pressed&quot;, (gpointer) &amp; (view-&gt;button_pressed)))</a>
<a name="ln192">    view-&gt;button_pressed = NULL;</a>
<a name="ln193">  if(!g_module_symbol(view-&gt;module, &quot;key_pressed&quot;, (gpointer) &amp; (view-&gt;key_pressed)))</a>
<a name="ln194">    view-&gt;key_pressed = NULL;</a>
<a name="ln195">  if(!g_module_symbol(view-&gt;module, &quot;key_released&quot;, (gpointer) &amp; (view-&gt;key_released)))</a>
<a name="ln196">    view-&gt;key_released = NULL;</a>
<a name="ln197">  if(!g_module_symbol(view-&gt;module, &quot;configure&quot;, (gpointer) &amp; (view-&gt;configure))) view-&gt;configure = NULL;</a>
<a name="ln198">  if(!g_module_symbol(view-&gt;module, &quot;scrolled&quot;, (gpointer) &amp; (view-&gt;scrolled))) view-&gt;scrolled = NULL;</a>
<a name="ln199">  if(!g_module_symbol(view-&gt;module, &quot;scrollbar_changed&quot;, (gpointer) &amp; (view-&gt;scrollbar_changed)))</a>
<a name="ln200">    view-&gt;scrollbar_changed = NULL;</a>
<a name="ln201">  if(!g_module_symbol(view-&gt;module, &quot;init_key_accels&quot;, (gpointer) &amp; (view-&gt;init_key_accels)))</a>
<a name="ln202">    view-&gt;init_key_accels = NULL;</a>
<a name="ln203">  if(!g_module_symbol(view-&gt;module, &quot;connect_key_accels&quot;, (gpointer) &amp; (view-&gt;connect_key_accels)))</a>
<a name="ln204">    view-&gt;connect_key_accels = NULL;</a>
<a name="ln205"> </a>
<a name="ln206">  view-&gt;accel_closures = NULL;</a>
<a name="ln207"> </a>
<a name="ln208">  if(!strcmp(view-&gt;module_name, &quot;darkroom&quot;)) darktable.develop = (dt_develop_t *)view-&gt;data;</a>
<a name="ln209"> </a>
<a name="ln210">#ifdef USE_LUA</a>
<a name="ln211">  dt_lua_register_view(darktable.lua_state.state, view);</a>
<a name="ln212">#endif</a>
<a name="ln213"> </a>
<a name="ln214">  if(view-&gt;init) view-&gt;init(view);</a>
<a name="ln215">  if(darktable.gui &amp;&amp; view-&gt;init_key_accels) view-&gt;init_key_accels(view);</a>
<a name="ln216"> </a>
<a name="ln217">  return 0;</a>
<a name="ln218"> </a>
<a name="ln219">error:</a>
<a name="ln220">  if(view-&gt;module) g_module_close(view-&gt;module);</a>
<a name="ln221">  return 1;</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">/** unload, cleanup */</a>
<a name="ln225">static void dt_view_unload_module(dt_view_t *view)</a>
<a name="ln226">{</a>
<a name="ln227">  if(view-&gt;cleanup) view-&gt;cleanup(view);</a>
<a name="ln228"> </a>
<a name="ln229">  g_slist_free(view-&gt;accel_closures);</a>
<a name="ln230"> </a>
<a name="ln231">  if(view-&gt;module) g_module_close(view-&gt;module);</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234">void dt_vm_remove_child(GtkWidget *widget, gpointer data)</a>
<a name="ln235">{</a>
<a name="ln236">  gtk_container_remove(GTK_CONTAINER(data), widget);</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">/*</a>
<a name="ln240">   When expanders get destoyed, they destroy the child</a>
<a name="ln241">   so remove the child before that</a>
<a name="ln242">   */</a>
<a name="ln243">static void _remove_child(GtkWidget *child,GtkContainer *container)</a>
<a name="ln244">{</a>
<a name="ln245">    if(DTGTK_IS_EXPANDER(child))</a>
<a name="ln246">    {</a>
<a name="ln247">      GtkWidget * evb = dtgtk_expander_get_body_event_box(DTGTK_EXPANDER(child));</a>
<a name="ln248">      gtk_container_remove(GTK_CONTAINER(evb),dtgtk_expander_get_body(DTGTK_EXPANDER(child)));</a>
<a name="ln249">      gtk_widget_destroy(child);</a>
<a name="ln250">    }</a>
<a name="ln251">    else</a>
<a name="ln252">    {</a>
<a name="ln253">      gtk_container_remove(container,child);</a>
<a name="ln254">    }</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">int dt_view_manager_switch(dt_view_manager_t *vm, const char *view_name)</a>
<a name="ln258">{</a>
<a name="ln259">  gboolean switching_to_none = *view_name == '\0';</a>
<a name="ln260">  dt_view_t *new_view = NULL;</a>
<a name="ln261"> </a>
<a name="ln262">  if(!switching_to_none)</a>
<a name="ln263">  {</a>
<a name="ln264">    for(GList *iter = vm-&gt;views; iter; iter = g_list_next(iter))</a>
<a name="ln265">    {</a>
<a name="ln266">      dt_view_t *v = (dt_view_t *)iter-&gt;data;</a>
<a name="ln267">      if(!strcmp(v-&gt;module_name, view_name))</a>
<a name="ln268">      {</a>
<a name="ln269">        new_view = v;</a>
<a name="ln270">        break;</a>
<a name="ln271">      }</a>
<a name="ln272">    }</a>
<a name="ln273">    if(!new_view) return 1; // the requested view doesn't exist</a>
<a name="ln274">  }</a>
<a name="ln275"> </a>
<a name="ln276">  return dt_view_manager_switch_by_view(vm, new_view);</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">int dt_view_manager_switch_by_view(dt_view_manager_t *vm, const dt_view_t *nv)</a>
<a name="ln280">{</a>
<a name="ln281">  dt_view_t *old_view = vm-&gt;current_view;</a>
<a name="ln282">  dt_view_t *new_view = (dt_view_t *)nv; // views belong to us, we can de-const them :-)</a>
<a name="ln283"> </a>
<a name="ln284">  // Before switching views, restore accelerators if disabled</a>
<a name="ln285">  if(!darktable.control-&gt;key_accelerators_on) dt_control_key_accelerators_on(darktable.control);</a>
<a name="ln286"> </a>
<a name="ln287">  // reset the cursor to the default one</a>
<a name="ln288">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln289"> </a>
<a name="ln290">  // also ignore what scrolling there was previously happening</a>
<a name="ln291">  memset(darktable.gui-&gt;scroll_to, 0, sizeof(darktable.gui-&gt;scroll_to));</a>
<a name="ln292"> </a>
<a name="ln293">  // destroy old module list</a>
<a name="ln294"> </a>
<a name="ln295">  /*  clear the undo list, for now we do this inconditionally. At some point we will probably want to clear</a>
<a name="ln296">     only part</a>
<a name="ln297">      of the undo list. This should probably done with a view proxy routine returning the type of undo to</a>
<a name="ln298">     remove. */</a>
<a name="ln299">  dt_undo_clear(darktable.undo, DT_UNDO_ALL);</a>
<a name="ln300"> </a>
<a name="ln301">  /* Special case when entering nothing (just before leaving dt) */</a>
<a name="ln302">  if(!new_view)</a>
<a name="ln303">  {</a>
<a name="ln304">    if(old_view)</a>
<a name="ln305">    {</a>
<a name="ln306">      /* leave the current view*/</a>
<a name="ln307">      if(old_view-&gt;leave) old_view-&gt;leave(old_view);</a>
<a name="ln308"> </a>
<a name="ln309">      /* iterator plugins and cleanup plugins in current view */</a>
<a name="ln310">      for(GList *iter = darktable.lib-&gt;plugins; iter; iter = g_list_next(iter))</a>
<a name="ln311">      {</a>
<a name="ln312">        dt_lib_module_t *plugin = (dt_lib_module_t *)(iter-&gt;data);</a>
<a name="ln313"> </a>
<a name="ln314">        /* does this module belong to current view ?*/</a>
<a name="ln315">        if(dt_lib_is_visible_in_view(plugin, old_view))</a>
<a name="ln316">        {</a>
<a name="ln317">          if(plugin-&gt;view_leave) plugin-&gt;view_leave(plugin, old_view, NULL);</a>
<a name="ln318">          plugin-&gt;gui_cleanup(plugin);</a>
<a name="ln319">          plugin-&gt;data = NULL;</a>
<a name="ln320">          dt_accel_disconnect_list(plugin-&gt;accel_closures);</a>
<a name="ln321">          plugin-&gt;accel_closures = NULL;</a>
<a name="ln322">          plugin-&gt;widget = NULL;</a>
<a name="ln323">        }</a>
<a name="ln324">      }</a>
<a name="ln325">    }</a>
<a name="ln326"> </a>
<a name="ln327">    /* remove all widgets in all containers */</a>
<a name="ln328">    for(int l = 0; l &lt; DT_UI_CONTAINER_SIZE; l++)</a>
<a name="ln329">      dt_ui_container_destroy_children(darktable.gui-&gt;ui, l);</a>
<a name="ln330">    vm-&gt;current_view = NULL;</a>
<a name="ln331">    return 0;</a>
<a name="ln332">  }</a>
<a name="ln333"> </a>
<a name="ln334">  // invariant: new_view != NULL after this point</a>
<a name="ln335">  assert(new_view != NULL);</a>
<a name="ln336"> </a>
<a name="ln337">  if(new_view-&gt;try_enter)</a>
<a name="ln338">  {</a>
<a name="ln339">    int error = new_view-&gt;try_enter(new_view);</a>
<a name="ln340">    if(error) return error;</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  /* cleanup current view before initialization of new  */</a>
<a name="ln344">  if(old_view)</a>
<a name="ln345">  {</a>
<a name="ln346">    /* leave current view */</a>
<a name="ln347">    if(old_view-&gt;leave) old_view-&gt;leave(old_view);</a>
<a name="ln348">    dt_accel_disconnect_list(old_view-&gt;accel_closures);</a>
<a name="ln349">    old_view-&gt;accel_closures = NULL;</a>
<a name="ln350"> </a>
<a name="ln351">    /* iterator plugins and cleanup plugins in current view */</a>
<a name="ln352">    for(GList *iter = darktable.lib-&gt;plugins; iter; iter = g_list_next(iter))</a>
<a name="ln353">    {</a>
<a name="ln354">      dt_lib_module_t *plugin = (dt_lib_module_t *)(iter-&gt;data);</a>
<a name="ln355"> </a>
<a name="ln356">      /* does this module belong to current view ?*/</a>
<a name="ln357">      if(dt_lib_is_visible_in_view(plugin, old_view))</a>
<a name="ln358">      {</a>
<a name="ln359">        if(plugin-&gt;view_leave) plugin-&gt;view_leave(plugin, old_view, new_view);</a>
<a name="ln360">        dt_accel_disconnect_list(plugin-&gt;accel_closures);</a>
<a name="ln361">        plugin-&gt;accel_closures = NULL;</a>
<a name="ln362">      }</a>
<a name="ln363">    }</a>
<a name="ln364"> </a>
<a name="ln365">    /* remove all widets in all containers */</a>
<a name="ln366">    for(int l = 0; l &lt; DT_UI_CONTAINER_SIZE; l++)</a>
<a name="ln367">      dt_ui_container_foreach(darktable.gui-&gt;ui, l,(GtkCallback)_remove_child);</a>
<a name="ln368">  }</a>
<a name="ln369"> </a>
<a name="ln370">  /* change current view to the new view */</a>
<a name="ln371">  vm-&gt;current_view = new_view;</a>
<a name="ln372"> </a>
<a name="ln373">  /* restore visible stat of panels for the new view */</a>
<a name="ln374">  dt_ui_restore_panels(darktable.gui-&gt;ui);</a>
<a name="ln375"> </a>
<a name="ln376">  /* lets add plugins related to new view into panels.</a>
<a name="ln377">   * this has to be done in reverse order to have the lowest position at the bottom! */</a>
<a name="ln378">  for(GList *iter = g_list_last(darktable.lib-&gt;plugins); iter; iter = g_list_previous(iter))</a>
<a name="ln379">  {</a>
<a name="ln380">    dt_lib_module_t *plugin = (dt_lib_module_t *)(iter-&gt;data);</a>
<a name="ln381">    if(dt_lib_is_visible_in_view(plugin, new_view))</a>
<a name="ln382">    {</a>
<a name="ln383"> </a>
<a name="ln384">      /* try get the module expander  */</a>
<a name="ln385">      GtkWidget *w = dt_lib_gui_get_expander(plugin);</a>
<a name="ln386"> </a>
<a name="ln387">      if(plugin-&gt;connect_key_accels) plugin-&gt;connect_key_accels(plugin);</a>
<a name="ln388">      dt_lib_connect_common_accels(plugin);</a>
<a name="ln389"> </a>
<a name="ln390">      /* if we didn't get an expander let's add the widget */</a>
<a name="ln391">      if(!w) w = plugin-&gt;widget;</a>
<a name="ln392"> </a>
<a name="ln393">      dt_gui_add_help_link(w, dt_get_help_url(plugin-&gt;plugin_name));</a>
<a name="ln394">      // some plugins help links depend on the view</a>
<a name="ln395">      if(!strcmp(plugin-&gt;plugin_name,&quot;module_toolbox&quot;)</a>
<a name="ln396">        || !strcmp(plugin-&gt;plugin_name,&quot;view_toolbox&quot;))</a>
<a name="ln397">      {</a>
<a name="ln398">        dt_view_type_flags_t view_type = new_view-&gt;view(new_view);</a>
<a name="ln399">        if(view_type == DT_VIEW_LIGHTTABLE)</a>
<a name="ln400">          dt_gui_add_help_link(w,&quot;lighttable_chapter.html#lighttable_overview&quot;);</a>
<a name="ln401">        if(view_type == DT_VIEW_DARKROOM)</a>
<a name="ln402">          dt_gui_add_help_link(w,&quot;darkroom_bottom_panel.html#darkroom_bottom_panel&quot;);</a>
<a name="ln403">      }</a>
<a name="ln404"> </a>
<a name="ln405"> </a>
<a name="ln406">      /* add module to its container */</a>
<a name="ln407">      dt_ui_container_add_widget(darktable.gui-&gt;ui, plugin-&gt;container(plugin), w);</a>
<a name="ln408">    }</a>
<a name="ln409">  }</a>
<a name="ln410"> </a>
<a name="ln411">  /* hide/show modules as last config */</a>
<a name="ln412">  for(GList *iter = darktable.lib-&gt;plugins; iter; iter = g_list_next(iter))</a>
<a name="ln413">  {</a>
<a name="ln414">    dt_lib_module_t *plugin = (dt_lib_module_t *)(iter-&gt;data);</a>
<a name="ln415">    if(dt_lib_is_visible_in_view(plugin, new_view))</a>
<a name="ln416">    {</a>
<a name="ln417">      /* set expanded if last mode was that */</a>
<a name="ln418">      char var[1024];</a>
<a name="ln419">      gboolean expanded = FALSE;</a>
<a name="ln420">      gboolean visible = dt_lib_is_visible(plugin);</a>
<a name="ln421">      if(plugin-&gt;expandable(plugin))</a>
<a name="ln422">      {</a>
<a name="ln423">        snprintf(var, sizeof(var), &quot;plugins/%s/%s/expanded&quot;, new_view-&gt;module_name, plugin-&gt;plugin_name);</a>
<a name="ln424">        expanded = dt_conf_get_bool(var);</a>
<a name="ln425"> </a>
<a name="ln426">        dt_lib_gui_set_expanded(plugin, expanded);</a>
<a name="ln427">      }</a>
<a name="ln428">      else</a>
<a name="ln429">      {</a>
<a name="ln430">        /* show/hide plugin widget depending on expanded flag or if plugin</a>
<a name="ln431">            not is expandeable() */</a>
<a name="ln432">        if(visible)</a>
<a name="ln433">          gtk_widget_show_all(plugin-&gt;widget);</a>
<a name="ln434">        else</a>
<a name="ln435">          gtk_widget_hide(plugin-&gt;widget);</a>
<a name="ln436">      }</a>
<a name="ln437">      if(plugin-&gt;view_enter) plugin-&gt;view_enter(plugin, old_view, new_view);</a>
<a name="ln438">    }</a>
<a name="ln439">  }</a>
<a name="ln440"> </a>
<a name="ln441">  /* enter view. crucially, do this before initing the plugins below,</a>
<a name="ln442">      as e.g. modulegroups requires the dr stuff to be inited. */</a>
<a name="ln443">  if(new_view-&gt;enter) new_view-&gt;enter(new_view);</a>
<a name="ln444">  if(new_view-&gt;connect_key_accels) new_view-&gt;connect_key_accels(new_view);</a>
<a name="ln445"> </a>
<a name="ln446">  /* update the scrollbars */</a>
<a name="ln447">  dt_ui_update_scrollbars(darktable.gui-&gt;ui);</a>
<a name="ln448"> </a>
<a name="ln449">  /* raise view changed signal */</a>
<a name="ln450">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_VIEWMANAGER_VIEW_CHANGED, old_view, new_view);</a>
<a name="ln451"> </a>
<a name="ln452">  /* add endmarkers to left and right center containers */</a>
<a name="ln453">  GtkWidget *endmarker = gtk_drawing_area_new();</a>
<a name="ln454">  dt_ui_container_add_widget(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_LEFT_CENTER, endmarker);</a>
<a name="ln455">  g_signal_connect(G_OBJECT(endmarker), &quot;draw&quot;, G_CALLBACK(dt_control_draw_endmarker), 0);</a>
<a name="ln456">  gtk_widget_set_size_request(endmarker, -1, DT_PIXEL_APPLY_DPI(50));</a>
<a name="ln457">  gtk_widget_show(endmarker);</a>
<a name="ln458"> </a>
<a name="ln459">  endmarker = gtk_drawing_area_new();</a>
<a name="ln460">  dt_ui_container_add_widget(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER, endmarker);</a>
<a name="ln461">  g_signal_connect(G_OBJECT(endmarker), &quot;draw&quot;, G_CALLBACK(dt_control_draw_endmarker), GINT_TO_POINTER(1));</a>
<a name="ln462">  gtk_widget_set_size_request(endmarker, -1, DT_PIXEL_APPLY_DPI(50));</a>
<a name="ln463">  gtk_widget_show(endmarker);</a>
<a name="ln464"> </a>
<a name="ln465">  return 0;</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468">const char *dt_view_manager_name(dt_view_manager_t *vm)</a>
<a name="ln469">{</a>
<a name="ln470">  if(!vm-&gt;current_view) return &quot;&quot;;</a>
<a name="ln471">  if(vm-&gt;current_view-&gt;name)</a>
<a name="ln472">    return vm-&gt;current_view-&gt;name(vm-&gt;current_view);</a>
<a name="ln473">  else</a>
<a name="ln474">    return vm-&gt;current_view-&gt;module_name;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">void dt_view_manager_expose(dt_view_manager_t *vm, cairo_t *cr, int32_t width, int32_t height,</a>
<a name="ln478">                            int32_t pointerx, int32_t pointery)</a>
<a name="ln479">{</a>
<a name="ln480">  if(!vm-&gt;current_view)</a>
<a name="ln481">  {</a>
<a name="ln482">    dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_BG);</a>
<a name="ln483">    cairo_paint(cr);</a>
<a name="ln484">    return;</a>
<a name="ln485">  }</a>
<a name="ln486">  vm-&gt;current_view-&gt;width = width;</a>
<a name="ln487">  vm-&gt;current_view-&gt;height = height;</a>
<a name="ln488"> </a>
<a name="ln489">  if(vm-&gt;current_view-&gt;expose)</a>
<a name="ln490">  {</a>
<a name="ln491">    /* expose the view */</a>
<a name="ln492">    cairo_rectangle(cr, 0, 0, vm-&gt;current_view-&gt;width, vm-&gt;current_view-&gt;height);</a>
<a name="ln493">    cairo_clip(cr);</a>
<a name="ln494">    cairo_new_path(cr);</a>
<a name="ln495">    cairo_save(cr);</a>
<a name="ln496">    float px = pointerx, py = pointery;</a>
<a name="ln497">    if(pointery &gt; vm-&gt;current_view-&gt;height)</a>
<a name="ln498">    {</a>
<a name="ln499">      px = 10000.0;</a>
<a name="ln500">      py = -1.0;</a>
<a name="ln501">    }</a>
<a name="ln502">    vm-&gt;current_view-&gt;expose(vm-&gt;current_view, cr, vm-&gt;current_view-&gt;width, vm-&gt;current_view-&gt;height, px, py);</a>
<a name="ln503"> </a>
<a name="ln504">    cairo_restore(cr);</a>
<a name="ln505">    /* expose plugins */</a>
<a name="ln506">    GList *plugins = g_list_last(darktable.lib-&gt;plugins);</a>
<a name="ln507">    while(plugins)</a>
<a name="ln508">    {</a>
<a name="ln509">      dt_lib_module_t *plugin = (dt_lib_module_t *)(plugins-&gt;data);</a>
<a name="ln510"> </a>
<a name="ln511">      /* does this module belong to current view ?*/</a>
<a name="ln512">      if(plugin-&gt;gui_post_expose &amp;&amp; dt_lib_is_visible_in_view(plugin, vm-&gt;current_view))</a>
<a name="ln513">        plugin-&gt;gui_post_expose(plugin, cr, vm-&gt;current_view-&gt;width, vm-&gt;current_view-&gt;height, px, py);</a>
<a name="ln514"> </a>
<a name="ln515">      /* get next plugin */</a>
<a name="ln516">      plugins = g_list_previous(plugins);</a>
<a name="ln517">    }</a>
<a name="ln518">  }</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521">void dt_view_manager_reset(dt_view_manager_t *vm)</a>
<a name="ln522">{</a>
<a name="ln523">  if(!vm-&gt;current_view) return;</a>
<a name="ln524">  if(vm-&gt;current_view-&gt;reset) vm-&gt;current_view-&gt;reset(vm-&gt;current_view);</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">void dt_view_manager_mouse_leave(dt_view_manager_t *vm)</a>
<a name="ln528">{</a>
<a name="ln529">  if(!vm-&gt;current_view) return;</a>
<a name="ln530">  dt_view_t *v = vm-&gt;current_view;</a>
<a name="ln531"> </a>
<a name="ln532">  /* lets check if any plugins want to handle mouse move */</a>
<a name="ln533">  gboolean handled = FALSE;</a>
<a name="ln534">  GList *plugins = g_list_last(darktable.lib-&gt;plugins);</a>
<a name="ln535">  while(plugins)</a>
<a name="ln536">  {</a>
<a name="ln537">    dt_lib_module_t *plugin = (dt_lib_module_t *)(plugins-&gt;data);</a>
<a name="ln538"> </a>
<a name="ln539">    /* does this module belong to current view ?*/</a>
<a name="ln540">    if(plugin-&gt;mouse_leave &amp;&amp; dt_lib_is_visible_in_view(plugin, v))</a>
<a name="ln541">      if(plugin-&gt;mouse_leave(plugin)) handled = TRUE;</a>
<a name="ln542"> </a>
<a name="ln543">    /* get next plugin */</a>
<a name="ln544">    plugins = g_list_previous(plugins);</a>
<a name="ln545">  }</a>
<a name="ln546"> </a>
<a name="ln547">  /* if not handled by any plugin let pass to view handler*/</a>
<a name="ln548">  if(!handled &amp;&amp; v-&gt;mouse_leave) v-&gt;mouse_leave(v);</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">void dt_view_manager_mouse_enter(dt_view_manager_t *vm)</a>
<a name="ln552">{</a>
<a name="ln553">  if(!vm-&gt;current_view) return;</a>
<a name="ln554">  if(vm-&gt;current_view-&gt;mouse_enter) vm-&gt;current_view-&gt;mouse_enter(vm-&gt;current_view);</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">void dt_view_manager_mouse_moved(dt_view_manager_t *vm, double x, double y, double pressure, int which)</a>
<a name="ln558">{</a>
<a name="ln559">  if(!vm-&gt;current_view) return;</a>
<a name="ln560">  dt_view_t *v = vm-&gt;current_view;</a>
<a name="ln561"> </a>
<a name="ln562">  /* lets check if any plugins want to handle mouse move */</a>
<a name="ln563">  gboolean handled = FALSE;</a>
<a name="ln564">  GList *plugins = g_list_last(darktable.lib-&gt;plugins);</a>
<a name="ln565">  while(plugins)</a>
<a name="ln566">  {</a>
<a name="ln567">    dt_lib_module_t *plugin = (dt_lib_module_t *)(plugins-&gt;data);</a>
<a name="ln568"> </a>
<a name="ln569">    /* does this module belong to current view ?*/</a>
<a name="ln570">    if(plugin-&gt;mouse_moved &amp;&amp; dt_lib_is_visible_in_view(plugin, v))</a>
<a name="ln571">      if(plugin-&gt;mouse_moved(plugin, x, y, pressure, which)) handled = TRUE;</a>
<a name="ln572"> </a>
<a name="ln573">    /* get next plugin */</a>
<a name="ln574">    plugins = g_list_previous(plugins);</a>
<a name="ln575">  }</a>
<a name="ln576"> </a>
<a name="ln577">  /* if not handled by any plugin let pass to view handler*/</a>
<a name="ln578">  if(!handled &amp;&amp; v-&gt;mouse_moved) v-&gt;mouse_moved(v, x, y, pressure, which);</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">int dt_view_manager_button_released(dt_view_manager_t *vm, double x, double y, int which, uint32_t state)</a>
<a name="ln582">{</a>
<a name="ln583">  if(!vm-&gt;current_view) return 0;</a>
<a name="ln584">  dt_view_t *v = vm-&gt;current_view;</a>
<a name="ln585"> </a>
<a name="ln586">  /* lets check if any plugins want to handle button press */</a>
<a name="ln587">  gboolean handled = FALSE;</a>
<a name="ln588">  GList *plugins = g_list_last(darktable.lib-&gt;plugins);</a>
<a name="ln589">  while(plugins)</a>
<a name="ln590">  {</a>
<a name="ln591">    dt_lib_module_t *plugin = (dt_lib_module_t *)(plugins-&gt;data);</a>
<a name="ln592"> </a>
<a name="ln593">    /* does this module belong to current view ?*/</a>
<a name="ln594">    if(plugin-&gt;button_released &amp;&amp; dt_lib_is_visible_in_view(plugin, v))</a>
<a name="ln595">      if(plugin-&gt;button_released(plugin, x, y, which, state)) handled = TRUE;</a>
<a name="ln596"> </a>
<a name="ln597">    /* get next plugin */</a>
<a name="ln598">    plugins = g_list_previous(plugins);</a>
<a name="ln599">  }</a>
<a name="ln600"> </a>
<a name="ln601">  if(handled) return 1;</a>
<a name="ln602">  /* if not handled by any plugin let pass to view handler*/</a>
<a name="ln603">  else if(v-&gt;button_released)</a>
<a name="ln604">    v-&gt;button_released(v, x, y, which, state);</a>
<a name="ln605"> </a>
<a name="ln606">  return 0;</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">int dt_view_manager_button_pressed(dt_view_manager_t *vm, double x, double y, double pressure, int which,</a>
<a name="ln610">                                   int type, uint32_t state)</a>
<a name="ln611">{</a>
<a name="ln612">  if(!vm-&gt;current_view) return 0;</a>
<a name="ln613">  dt_view_t *v = vm-&gt;current_view;</a>
<a name="ln614"> </a>
<a name="ln615">  /* lets check if any plugins want to handle button press */</a>
<a name="ln616">  gboolean handled = FALSE;</a>
<a name="ln617">  GList *plugins = g_list_last(darktable.lib-&gt;plugins);</a>
<a name="ln618">  while(plugins &amp;&amp; !handled)</a>
<a name="ln619">  {</a>
<a name="ln620">    dt_lib_module_t *plugin = (dt_lib_module_t *)(plugins-&gt;data);</a>
<a name="ln621"> </a>
<a name="ln622">    /* does this module belong to current view ?*/</a>
<a name="ln623">    if(plugin-&gt;button_pressed &amp;&amp; dt_lib_is_visible_in_view(plugin, v))</a>
<a name="ln624">      if(plugin-&gt;button_pressed(plugin, x, y, pressure, which, type, state)) handled = TRUE;</a>
<a name="ln625"> </a>
<a name="ln626">    /* get next plugin */</a>
<a name="ln627">    plugins = g_list_previous(plugins);</a>
<a name="ln628">  }</a>
<a name="ln629"> </a>
<a name="ln630">  if(handled) return 1;</a>
<a name="ln631">  /* if not handled by any plugin let pass to view handler*/</a>
<a name="ln632">  else if(v-&gt;button_pressed)</a>
<a name="ln633">    return v-&gt;button_pressed(v, x, y, pressure, which, type, state);</a>
<a name="ln634"> </a>
<a name="ln635">  return 0;</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">int dt_view_manager_key_pressed(dt_view_manager_t *vm, guint key, guint state)</a>
<a name="ln639">{</a>
<a name="ln640">  int film_strip_result = 0;</a>
<a name="ln641">  if(!vm-&gt;current_view) return 0;</a>
<a name="ln642">  if(vm-&gt;current_view-&gt;key_pressed)</a>
<a name="ln643">    return vm-&gt;current_view-&gt;key_pressed(vm-&gt;current_view, key, state) || film_strip_result;</a>
<a name="ln644">  return 0;</a>
<a name="ln645">}</a>
<a name="ln646"> </a>
<a name="ln647">int dt_view_manager_key_released(dt_view_manager_t *vm, guint key, guint state)</a>
<a name="ln648">{</a>
<a name="ln649">  int film_strip_result = 0;</a>
<a name="ln650">  if(!vm-&gt;current_view) return 0;</a>
<a name="ln651">  if(vm-&gt;current_view-&gt;key_released)</a>
<a name="ln652">    return vm-&gt;current_view-&gt;key_released(vm-&gt;current_view, key, state) || film_strip_result;</a>
<a name="ln653">  return 0;</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656">void dt_view_manager_configure(dt_view_manager_t *vm, int width, int height)</a>
<a name="ln657">{</a>
<a name="ln658">  for(GList *iter = vm-&gt;views; iter; iter = g_list_next(iter))</a>
<a name="ln659">  {</a>
<a name="ln660">    // this is necessary for all</a>
<a name="ln661">    dt_view_t *v = (dt_view_t *)iter-&gt;data;</a>
<a name="ln662">    v-&gt;width = width;</a>
<a name="ln663">    v-&gt;height = height;</a>
<a name="ln664">    if(v-&gt;configure) v-&gt;configure(v, width, height);</a>
<a name="ln665">  }</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668">void dt_view_manager_scrolled(dt_view_manager_t *vm, double x, double y, int up, int state)</a>
<a name="ln669">{</a>
<a name="ln670">  if(!vm-&gt;current_view) return;</a>
<a name="ln671">  if(vm-&gt;current_view-&gt;scrolled) vm-&gt;current_view-&gt;scrolled(vm-&gt;current_view, x, y, up, state);</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">void dt_view_manager_scrollbar_changed(dt_view_manager_t *vm, double x, double y)</a>
<a name="ln675">{</a>
<a name="ln676">  if(!vm-&gt;current_view) return;</a>
<a name="ln677">  if(vm-&gt;current_view-&gt;scrollbar_changed) vm-&gt;current_view-&gt;scrollbar_changed(vm-&gt;current_view, x, y);</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">void dt_view_set_scrollbar(dt_view_t *view, float hpos, float hlower, float hsize, float hwinsize,</a>
<a name="ln681">                           float vpos, float vlower, float vsize,float vwinsize)</a>
<a name="ln682">{</a>
<a name="ln683">  if (view-&gt;vscroll_pos == vpos &amp;&amp; view-&gt;vscroll_lower == vlower &amp;&amp; view-&gt;vscroll_size == vsize &amp;&amp;</a>
<a name="ln684">      view-&gt;vscroll_viewport_size == vwinsize &amp;&amp; view-&gt;hscroll_pos == hpos &amp;&amp; view-&gt;hscroll_lower == hlower &amp;&amp;</a>
<a name="ln685">      view-&gt;hscroll_size == hsize &amp;&amp; view-&gt;hscroll_viewport_size == hwinsize)</a>
<a name="ln686">    return;</a>
<a name="ln687"> </a>
<a name="ln688">  view-&gt;vscroll_pos = vpos;</a>
<a name="ln689">  view-&gt;vscroll_lower = vlower;</a>
<a name="ln690">  view-&gt;vscroll_size = vsize;</a>
<a name="ln691">  view-&gt;vscroll_viewport_size = vwinsize;</a>
<a name="ln692">  view-&gt;hscroll_pos = hpos;</a>
<a name="ln693">  view-&gt;hscroll_lower = hlower;</a>
<a name="ln694">  view-&gt;hscroll_size = hsize;</a>
<a name="ln695">  view-&gt;hscroll_viewport_size = hwinsize;</a>
<a name="ln696"> </a>
<a name="ln697">  GtkWidget *widget;</a>
<a name="ln698">  widget = darktable.gui-&gt;widgets.left_border;</a>
<a name="ln699">  gtk_widget_queue_draw(widget);</a>
<a name="ln700">  widget = darktable.gui-&gt;widgets.right_border;</a>
<a name="ln701">  gtk_widget_queue_draw(widget);</a>
<a name="ln702">  widget = darktable.gui-&gt;widgets.bottom_border;</a>
<a name="ln703">  gtk_widget_queue_draw(widget);</a>
<a name="ln704">  widget = darktable.gui-&gt;widgets.top_border;</a>
<a name="ln705">  gtk_widget_queue_draw(widget);</a>
<a name="ln706"> </a>
<a name="ln707">  if (!darktable.gui-&gt;scrollbars.dragging) dt_ui_update_scrollbars(darktable.gui-&gt;ui);</a>
<a name="ln708"> </a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">static inline void dt_view_draw_altered(cairo_t *cr, const float x, const float y, const float r)</a>
<a name="ln712">{</a>
<a name="ln713">  cairo_new_sub_path(cr);</a>
<a name="ln714">  cairo_arc(cr, x, y, r, 0, 2.0f * M_PI);</a>
<a name="ln715">  const float dx = r * cosf(M_PI / 8.0f), dy = r * sinf(M_PI / 8.0f);</a>
<a name="ln716">  cairo_move_to(cr, x - dx, y - dy);</a>
<a name="ln717">  cairo_curve_to(cr, x, y - 2 * dy, x, y + 2 * dy, x + dx, y + dy);</a>
<a name="ln718">  cairo_move_to(cr, x - .20 * dx, y + .8 * dy);</a>
<a name="ln719">  cairo_line_to(cr, x - .80 * dx, y + .8 * dy);</a>
<a name="ln720">  cairo_move_to(cr, x + .20 * dx, y - .8 * dy);</a>
<a name="ln721">  cairo_line_to(cr, x + .80 * dx, y - .8 * dy);</a>
<a name="ln722">  cairo_move_to(cr, x + .50 * dx, y - .8 * dy - 0.3 * dx);</a>
<a name="ln723">  cairo_line_to(cr, x + .50 * dx, y - .8 * dy + 0.3 * dx);</a>
<a name="ln724">  cairo_stroke(cr);</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">static inline void dt_view_draw_audio(cairo_t *cr, const float x, const float y, const float r)</a>
<a name="ln728">{</a>
<a name="ln729">  const float d = 2.0 * r;</a>
<a name="ln730"> </a>
<a name="ln731">  cairo_save(cr);</a>
<a name="ln732"> </a>
<a name="ln733">  cairo_translate(cr, x - (d / 2.0), y - (d / 2.0));</a>
<a name="ln734">  cairo_scale(cr, d, d);</a>
<a name="ln735"> </a>
<a name="ln736">  cairo_rectangle(cr, 0.05, 0.4, 0.2, 0.2);</a>
<a name="ln737">  cairo_move_to(cr, 0.25, 0.6);</a>
<a name="ln738">  cairo_line_to(cr, 0.45, 0.77);</a>
<a name="ln739">  cairo_line_to(cr, 0.45, 0.23);</a>
<a name="ln740">  cairo_line_to(cr, 0.25, 0.4);</a>
<a name="ln741"> </a>
<a name="ln742">  cairo_new_sub_path(cr);</a>
<a name="ln743">  cairo_arc(cr, 0.2, 0.5, 0.45, -(35.0 / 180.0) * M_PI, (35.0 / 180.0) * M_PI);</a>
<a name="ln744">  cairo_new_sub_path(cr);</a>
<a name="ln745">  cairo_arc(cr, 0.2, 0.5, 0.6, -(35.0 / 180.0) * M_PI, (35.0 / 180.0) * M_PI);</a>
<a name="ln746">  cairo_new_sub_path(cr);</a>
<a name="ln747">  cairo_arc(cr, 0.2, 0.5, 0.75, -(35.0 / 180.0) * M_PI, (35.0 / 180.0) * M_PI);</a>
<a name="ln748"> </a>
<a name="ln749">  cairo_restore(cr);</a>
<a name="ln750">  cairo_stroke(cr);</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753">static inline void dt_view_star(cairo_t *cr, float x, float y, float r1, float r2)</a>
<a name="ln754">{</a>
<a name="ln755">  const float d = 2.0 * M_PI * 0.1f;</a>
<a name="ln756">  const float dx[10] = { sinf(0.0),   sinf(d),     sinf(2 * d), sinf(3 * d), sinf(4 * d),</a>
<a name="ln757">                         sinf(5 * d), sinf(6 * d), sinf(7 * d), sinf(8 * d), sinf(9 * d) };</a>
<a name="ln758">  const float dy[10] = { cosf(0.0),   cosf(d),     cosf(2 * d), cosf(3 * d), cosf(4 * d),</a>
<a name="ln759">                         cosf(5 * d), cosf(6 * d), cosf(7 * d), cosf(8 * d), cosf(9 * d) };</a>
<a name="ln760">  cairo_move_to(cr, x + r1 * dx[0], y - r1 * dy[0]);</a>
<a name="ln761">  for(int k = 1; k &lt; 10; k++)</a>
<a name="ln762">    if(k &amp; 1)</a>
<a name="ln763">      cairo_line_to(cr, x + r2 * dx[k], y - r2 * dy[k]);</a>
<a name="ln764">    else</a>
<a name="ln765">      cairo_line_to(cr, x + r1 * dx[k], y - r1 * dy[k]);</a>
<a name="ln766">  cairo_close_path(cr);</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">int32_t dt_view_get_image_to_act_on()</a>
<a name="ln770">{</a>
<a name="ln771">  // this works as follows:</a>
<a name="ln772">  // - if mouse hovers over an image, that's the one, except:</a>
<a name="ln773">  // - if images are selected and the mouse hovers over the selection,</a>
<a name="ln774">  //   in which case it affects the whole selection.</a>
<a name="ln775">  // - if the mouse is outside the center view (or no image hovered over otherwise)</a>
<a name="ln776">  //   it only affects the selection.</a>
<a name="ln777">  const int32_t mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln778"> </a>
<a name="ln779">  const int zoom = darktable.view_manager-&gt;proxy.lighttable.get_images_in_row(</a>
<a name="ln780">      darktable.view_manager-&gt;proxy.lighttable.view);</a>
<a name="ln781"> </a>
<a name="ln782">  const int full_preview_id = darktable.view_manager-&gt;proxy.lighttable.get_full_preview_id(</a>
<a name="ln783">      darktable.view_manager-&gt;proxy.lighttable.view);</a>
<a name="ln784"> </a>
<a name="ln785">  const int layout = darktable.view_manager-&gt;proxy.lighttable.get_layout(</a>
<a name="ln786">      darktable.view_manager-&gt;proxy.lighttable.module);</a>
<a name="ln787"> </a>
<a name="ln788">  if(zoom == 1 || full_preview_id &gt; 1 || layout == DT_LIGHTTABLE_LAYOUT_EXPOSE)</a>
<a name="ln789">  {</a>
<a name="ln790">    return mouse_over_id;</a>
<a name="ln791">  }</a>
<a name="ln792">  else</a>
<a name="ln793">  {</a>
<a name="ln794">    /* clear and reset statement */</a>
<a name="ln795">    DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln796">    DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln797"> </a>
<a name="ln798">    /* setup statement and iterate over rows */</a>
<a name="ln799">    DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.is_selected, 1, mouse_over_id);</a>
<a name="ln800"> </a>
<a name="ln801">    if(mouse_over_id &lt;= 0 || sqlite3_step(darktable.view_manager-&gt;statements.is_selected) == SQLITE_ROW)</a>
<a name="ln802">      return -1;</a>
<a name="ln803">    else</a>
<a name="ln804">      return mouse_over_id;</a>
<a name="ln805">  }</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808">// Draw one of the controls that overlay thumbnails (e.g. stars) and check if the pointer is hovering it.</a>
<a name="ln809">// cr == NULL --&gt; only check for pointer hovering</a>
<a name="ln810">// active --&gt; non zero if the control can be activated by the mouse hovering it</a>
<a name="ln811">// return value non zero --&gt; mouse is hovering</a>
<a name="ln812"> </a>
<a name="ln813">int dt_view_process_image_over(dt_view_image_over_t what, int active, cairo_t *cr, const dt_image_t *img,</a>
<a name="ln814">                               int32_t width, int32_t height, int32_t zoom, int32_t px, int32_t py,</a>
<a name="ln815">                               dt_gui_color_t outlinecol, dt_gui_color_t fontcol)</a>
<a name="ln816">{</a>
<a name="ln817">  int ret = 0; // return value</a>
<a name="ln818"> </a>
<a name="ln819">  float fscale = DT_PIXEL_APPLY_DPI(fminf(width, height));</a>
<a name="ln820">  float r1, r2;</a>
<a name="ln821">  if(zoom != 1)</a>
<a name="ln822">  {</a>
<a name="ln823">    r1 = 0.05 * width;</a>
<a name="ln824">    r2 = 0.022 * width;</a>
<a name="ln825">  }</a>
<a name="ln826">  else</a>
<a name="ln827">  {</a>
<a name="ln828">    r1 = 0.015 * fscale;</a>
<a name="ln829">    r2 = 0.007 * fscale;</a>
<a name="ln830">  }</a>
<a name="ln831"> </a>
<a name="ln832">  gboolean extended_thumb_overlay = dt_conf_get_bool(&quot;plugins/lighttable/extended_thumb_overlay&quot;);</a>
<a name="ln833">  float x, y;</a>
<a name="ln834">  if(zoom != 1)</a>
<a name="ln835">    y = (extended_thumb_overlay ? 0.93 : 0.9) * height;</a>
<a name="ln836">  else</a>
<a name="ln837">    y = .12 * fscale;</a>
<a name="ln838"> </a>
<a name="ln839">  int rejected = img &amp;&amp; (img-&gt;flags &amp; 0x7) == 6;</a>
<a name="ln840"> </a>
<a name="ln841">  switch(what)</a>
<a name="ln842">  {</a>
<a name="ln843">    case DT_VIEW_STAR_1:</a>
<a name="ln844">    case DT_VIEW_STAR_2:</a>
<a name="ln845">    case DT_VIEW_STAR_3:</a>
<a name="ln846">    case DT_VIEW_STAR_4:</a>
<a name="ln847">    case DT_VIEW_STAR_5:</a>
<a name="ln848">      if(zoom != 1)</a>
<a name="ln849">        x = (0.26 + (what - DT_VIEW_STAR_1) * 0.12) * width;</a>
<a name="ln850">      else</a>
<a name="ln851">        x = (.08 + (what - DT_VIEW_STAR_1) * 0.04) * fscale;</a>
<a name="ln852"> </a>
<a name="ln853">      if(cr) dt_view_star(cr, x, y, r1, r2);</a>
<a name="ln854"> </a>
<a name="ln855">      if(active &amp;&amp; (px - x) * (px - x) + (py - y) * (py - y) &lt; r1 * r1)</a>
<a name="ln856">      {</a>
<a name="ln857">        ret = 1;</a>
<a name="ln858">        if(cr) cairo_fill(cr);</a>
<a name="ln859">      }</a>
<a name="ln860">      else if(cr &amp;&amp; img &amp;&amp; (img-&gt;flags &amp; 0x7) &gt; what - DT_VIEW_STAR_1)</a>
<a name="ln861">      {</a>
<a name="ln862">        cairo_fill_preserve(cr);</a>
<a name="ln863">        dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_THUMBNAIL_SELECTED_BORDER);</a>
<a name="ln864">        cairo_stroke(cr);</a>
<a name="ln865">        dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln866">      }</a>
<a name="ln867">      else if(cr)</a>
<a name="ln868">        cairo_stroke(cr);</a>
<a name="ln869"> </a>
<a name="ln870">      break;</a>
<a name="ln871"> </a>
<a name="ln872">    case DT_VIEW_REJECT:</a>
<a name="ln873">      if(zoom != 1)</a>
<a name="ln874">        x = 0.08 * width;</a>
<a name="ln875">      else</a>
<a name="ln876">        x = .04 * fscale;</a>
<a name="ln877"> </a>
<a name="ln878">      if(cr &amp;&amp; rejected) cairo_set_source_rgb(cr, 1., 0., 0.);</a>
<a name="ln879"> </a>
<a name="ln880">      if(active &amp;&amp; (px - x) * (px - x) + (py - y) * (py - y) &lt; r1 * r1)</a>
<a name="ln881">      {</a>
<a name="ln882">        ret = 1;</a>
<a name="ln883">        if(cr)</a>
<a name="ln884">        {</a>
<a name="ln885">          cairo_new_sub_path(cr);</a>
<a name="ln886">          cairo_arc(cr, x, y, (r1 + r2) * .5, 0, 2.0f * M_PI);</a>
<a name="ln887">          cairo_stroke(cr);</a>
<a name="ln888">        }</a>
<a name="ln889">      }</a>
<a name="ln890"> </a>
<a name="ln891">      if(cr)</a>
<a name="ln892">      {</a>
<a name="ln893">        if(rejected) cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.5));</a>
<a name="ln894"> </a>
<a name="ln895">        // reject cross:</a>
<a name="ln896">        cairo_move_to(cr, x - r2, y - r2);</a>
<a name="ln897">        cairo_line_to(cr, x + r2, y + r2);</a>
<a name="ln898">        cairo_move_to(cr, x + r2, y - r2);</a>
<a name="ln899">        cairo_line_to(cr, x - r2, y + r2);</a>
<a name="ln900">        cairo_close_path(cr);</a>
<a name="ln901">        cairo_stroke(cr);</a>
<a name="ln902">        dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln903">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.5));</a>
<a name="ln904">      }</a>
<a name="ln905"> </a>
<a name="ln906">      break;</a>
<a name="ln907"> </a>
<a name="ln908">    case DT_VIEW_GROUP:</a>
<a name="ln909">    {</a>
<a name="ln910">      // draw grouping icon and border if the current group is expanded</a>
<a name="ln911">      // align to the right, left of altered</a>
<a name="ln912">      float s = (r1 + r2) * .6;</a>
<a name="ln913">      if(zoom != 1)</a>
<a name="ln914">      {</a>
<a name="ln915">        x = width * 0.9 - s * 2.5;</a>
<a name="ln916">        y = height * 0.1 - s * .4;</a>
<a name="ln917">      }</a>
<a name="ln918">      else</a>
<a name="ln919">      {</a>
<a name="ln920">        x = (.04 + 8 * 0.04 - 1.1 * .04) * fscale;</a>
<a name="ln921">        y = y - (.17 * .04) * fscale;</a>
<a name="ln922">      }</a>
<a name="ln923">      if(cr)</a>
<a name="ln924">      {</a>
<a name="ln925">        cairo_save(cr);</a>
<a name="ln926">        if(img &amp;&amp; (img-&gt;id != img-&gt;group_id)) dt_gui_gtk_set_source_rgb(cr, fontcol);</a>
<a name="ln927">        dtgtk_cairo_paint_grouping(cr, x, y, s, s, 23, NULL);</a>
<a name="ln928">        cairo_restore(cr);</a>
<a name="ln929">      }</a>
<a name="ln930"> </a>
<a name="ln931">      if(active &amp;&amp; fabs(px - x - .5 * s) &lt;= .8 * s &amp;&amp; fabs(py - y - .5 * s) &lt;= .8 * s) ret = 1;</a>
<a name="ln932"> </a>
<a name="ln933">      break;</a>
<a name="ln934">    }</a>
<a name="ln935"> </a>
<a name="ln936">    case DT_VIEW_AUDIO:</a>
<a name="ln937">    {</a>
<a name="ln938">      // align to right</a>
<a name="ln939">      float s = (r1 + r2) * .5;</a>
<a name="ln940">      if(zoom != 1)</a>
<a name="ln941">      {</a>
<a name="ln942">        x = width * 0.9 - s * 5;</a>
<a name="ln943">        y = height * 0.1;</a>
<a name="ln944">      }</a>
<a name="ln945">      else</a>
<a name="ln946">        x = (.04 + 8 * 0.04 - 1.9 * .04) * fscale;</a>
<a name="ln947">      if(cr) dt_view_draw_audio(cr, x, y, s);</a>
<a name="ln948">      // mouse is over the audio icon</a>
<a name="ln949">      if(active &amp;&amp; fabsf(px - x) &lt;= 1.2 * s &amp;&amp; fabsf(py - y) &lt;= 1.2 * s) ret = 1;</a>
<a name="ln950"> </a>
<a name="ln951">      break;</a>
<a name="ln952">    }</a>
<a name="ln953"> </a>
<a name="ln954">    case DT_VIEW_ALTERED:</a>
<a name="ln955">    {</a>
<a name="ln956">      // align to right</a>
<a name="ln957">      float s = (r1 + r2) * .5;</a>
<a name="ln958">      if(zoom != 1)</a>
<a name="ln959">      {</a>
<a name="ln960">        x = width * 0.9;</a>
<a name="ln961">        y = height * 0.1;</a>
<a name="ln962">      }</a>
<a name="ln963">      else</a>
<a name="ln964">        x = (.04 + 8 * 0.04) * fscale;</a>
<a name="ln965">      if(cr) dt_view_draw_altered(cr, x, y, s);</a>
<a name="ln966">      if(active &amp;&amp; fabsf(px - x) &lt;= 1.2 * s &amp;&amp; fabsf(py - y) &lt;= 1.2 * s) ret = 1;</a>
<a name="ln967"> </a>
<a name="ln968">      break;</a>
<a name="ln969">    }</a>
<a name="ln970"> </a>
<a name="ln971">    default: // if what == DT_VIEW_DESERT just return 0</a>
<a name="ln972">      return 0;</a>
<a name="ln973">  }</a>
<a name="ln974"> </a>
<a name="ln975">  return ret;</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978">dt_view_image_over_t dt_view_guess_image_over(int32_t width, int32_t height, int32_t zoom, int32_t px, int32_t py)</a>
<a name="ln979">{</a>
<a name="ln980">  // active if zoom&gt;1 or in the proper area</a>
<a name="ln981">  gboolean in_metadata_zone = (px &lt; width &amp;&amp; py &lt; height / 2) || (zoom &gt; 1);</a>
<a name="ln982"> </a>
<a name="ln983">  gboolean draw_metadata = darktable.gui-&gt;show_overlays || in_metadata_zone;</a>
<a name="ln984"> </a>
<a name="ln985">  if(draw_metadata &amp;&amp; width &gt; DECORATION_SIZE_LIMIT)</a>
<a name="ln986">  {</a>
<a name="ln987">    dt_view_image_over_t i;</a>
<a name="ln988">    for(i = DT_VIEW_ERR; i &lt; DT_VIEW_END; i++)</a>
<a name="ln989">      if(dt_view_process_image_over(i, 1, NULL, NULL, width, height, zoom, px, py, 0, 0)) return i;</a>
<a name="ln990">  }</a>
<a name="ln991"> </a>
<a name="ln992">  return DT_VIEW_DESERT;</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995">int dt_view_image_expose(dt_view_image_over_t *image_over, uint32_t imgid, cairo_t *cr, int32_t width,</a>
<a name="ln996">                         int32_t height, int32_t zoom, int32_t px, int32_t py, gboolean full_preview, gboolean image_only)</a>
<a name="ln997">{</a>
<a name="ln998">  int missing = 0;</a>
<a name="ln999">  const double start = dt_get_wtime();</a>
<a name="ln1000">// some performance tuning stuff, for your pleasure.</a>
<a name="ln1001">// on my machine with 7 image per row it seems grouping has the largest</a>
<a name="ln1002">// impact from around 400ms -&gt; 55ms per redraw.</a>
<a name="ln1003"> </a>
<a name="ln1004">  // this is a gui thread only thing. no mutex required:</a>
<a name="ln1005">  const int imgsel = dt_control_get_mouse_over_id(); //  darktable.control-&gt;global_settings.lib_image_mouse_over_id;</a>
<a name="ln1006"> </a>
<a name="ln1007">  // active if zoom&gt;1 or in the proper area</a>
<a name="ln1008">  const gboolean in_metadata_zone = (px &lt; width &amp;&amp; py &lt; height / 2) || (zoom &gt; 1);</a>
<a name="ln1009"> </a>
<a name="ln1010">  const gboolean draw_thumb = TRUE;</a>
<a name="ln1011">  const gboolean draw_colorlabels = !image_only &amp;&amp; (darktable.gui-&gt;show_overlays || in_metadata_zone);</a>
<a name="ln1012">  const gboolean draw_local_copy = !image_only &amp;&amp; (darktable.gui-&gt;show_overlays || in_metadata_zone);</a>
<a name="ln1013">  const gboolean draw_grouping = !image_only;</a>
<a name="ln1014">  const gboolean draw_selected = !image_only;</a>
<a name="ln1015">  const gboolean draw_history = !image_only;</a>
<a name="ln1016">  const gboolean draw_metadata = !image_only &amp;&amp; (darktable.gui-&gt;show_overlays || in_metadata_zone);</a>
<a name="ln1017">  const gboolean draw_audio = !image_only;</a>
<a name="ln1018"> </a>
<a name="ln1019">  cairo_save(cr);</a>
<a name="ln1020">  dt_gui_color_t bgcol = DT_GUI_COLOR_THUMBNAIL_BG;</a>
<a name="ln1021">  dt_gui_color_t fontcol = DT_GUI_COLOR_THUMBNAIL_FONT;</a>
<a name="ln1022">  dt_gui_color_t outlinecol = DT_GUI_COLOR_THUMBNAIL_OUTLINE;</a>
<a name="ln1023"> </a>
<a name="ln1024">  int selected = 0, is_grouped = 0;</a>
<a name="ln1025"> </a>
<a name="ln1026">  if (draw_selected)</a>
<a name="ln1027">  {</a>
<a name="ln1028">    /* clear and reset statements */</a>
<a name="ln1029">    DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln1030">    DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln1031">    /* bind imgid to prepared statements */</a>
<a name="ln1032">    DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.is_selected, 1, imgid);</a>
<a name="ln1033">    /* lets check if imgid is selected */</a>
<a name="ln1034">    if(sqlite3_step(darktable.view_manager-&gt;statements.is_selected) == SQLITE_ROW) selected = 1;</a>
<a name="ln1035">  }</a>
<a name="ln1036"> </a>
<a name="ln1037">  dt_image_t buffered_image;</a>
<a name="ln1038">  const dt_image_t *img;</a>
<a name="ln1039">  // if darktable.gui-&gt;show_overlays is set or the user points at this image, we really want it:</a>
<a name="ln1040">  if(darktable.gui-&gt;show_overlays || imgsel == imgid || zoom == 1)</a>
<a name="ln1041">    img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1042">  else</a>
<a name="ln1043">    img = dt_image_cache_testget(darktable.image_cache, imgid, 'r');</a>
<a name="ln1044"> </a>
<a name="ln1045">  if(selected == 1 &amp;&amp; zoom != 1) // If zoom == 1 there is no need to set colors here</a>
<a name="ln1046">  {</a>
<a name="ln1047">    outlinecol = DT_GUI_COLOR_THUMBNAIL_SELECTED_OUTLINE;</a>
<a name="ln1048">    bgcol = DT_GUI_COLOR_THUMBNAIL_SELECTED_BG;</a>
<a name="ln1049">    fontcol = DT_GUI_COLOR_THUMBNAIL_SELECTED_FONT;</a>
<a name="ln1050">  }</a>
<a name="ln1051">  if(imgsel == imgid || zoom == 1)</a>
<a name="ln1052">  {</a>
<a name="ln1053">    // mouse over</a>
<a name="ln1054">    bgcol = DT_GUI_COLOR_THUMBNAIL_HOVER_BG;</a>
<a name="ln1055">    fontcol = DT_GUI_COLOR_THUMBNAIL_HOVER_FONT;</a>
<a name="ln1056">    outlinecol = DT_GUI_COLOR_THUMBNAIL_HOVER_OUTLINE;</a>
<a name="ln1057">  }</a>
<a name="ln1058">  // release image cache lock as early as possible, to avoid deadlocks (mipmap cache might need to lock it, too)</a>
<a name="ln1059">  if(img)</a>
<a name="ln1060">  {</a>
<a name="ln1061">    buffered_image = *img;</a>
<a name="ln1062">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln1063">    img = &amp;buffered_image;</a>
<a name="ln1064">  }</a>
<a name="ln1065"> </a>
<a name="ln1066">  gboolean draw_thumb_background = FALSE;</a>
<a name="ln1067">  float imgwd = 0.90f;</a>
<a name="ln1068">  if (image_only)</a>
<a name="ln1069">  {</a>
<a name="ln1070">    imgwd = 1.0;</a>
<a name="ln1071">  }</a>
<a name="ln1072">  else if(zoom == 1)</a>
<a name="ln1073">  {</a>
<a name="ln1074">    imgwd = .97f;</a>
<a name="ln1075">    // cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE);</a>
<a name="ln1076">  }</a>
<a name="ln1077">  else</a>
<a name="ln1078">  {</a>
<a name="ln1079">    draw_thumb_background = TRUE;</a>
<a name="ln1080">  }</a>
<a name="ln1081"> </a>
<a name="ln1082">  dt_mipmap_buffer_t buf;</a>
<a name="ln1083">  dt_mipmap_size_t mip</a>
<a name="ln1084">      = dt_mipmap_cache_get_matching_size(darktable.mipmap_cache, imgwd * width, imgwd * height);</a>
<a name="ln1085">  dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, mip, DT_MIPMAP_BEST_EFFORT, 'r');</a>
<a name="ln1086"> </a>
<a name="ln1087">  if(draw_thumb_background)</a>
<a name="ln1088">  {</a>
<a name="ln1089">    double x0 = DT_PIXEL_APPLY_DPI(1), y0 = DT_PIXEL_APPLY_DPI(1), rect_width = width - DT_PIXEL_APPLY_DPI(2),</a>
<a name="ln1090">           rect_height = height - DT_PIXEL_APPLY_DPI(2), radius = DT_PIXEL_APPLY_DPI(5);</a>
<a name="ln1091">    double x1, y1, off, off1;</a>
<a name="ln1092"> </a>
<a name="ln1093">    x1 = x0 + rect_width;</a>
<a name="ln1094">    y1 = y0 + rect_height;</a>
<a name="ln1095">    off = radius * 0.666;</a>
<a name="ln1096">    off1 = radius - off;</a>
<a name="ln1097">    cairo_move_to(cr, x0, y0 + radius);</a>
<a name="ln1098">    cairo_curve_to(cr, x0, y0 + off1, x0 + off1, y0, x0 + radius, y0);</a>
<a name="ln1099">    cairo_line_to(cr, x1 - radius, y0);</a>
<a name="ln1100">    cairo_curve_to(cr, x1 - off1, y0, x1, y0 + off1, x1, y0 + radius);</a>
<a name="ln1101">    cairo_line_to(cr, x1, y1 - radius);</a>
<a name="ln1102">    cairo_curve_to(cr, x1, y1 - off1, x1 - off1, y1, x1 - radius, y1);</a>
<a name="ln1103">    cairo_line_to(cr, x0 + radius, y1);</a>
<a name="ln1104">    cairo_curve_to(cr, x0 + off1, y1, x0, y1 - off1, x0, y1 - radius);</a>
<a name="ln1105">    cairo_close_path(cr);</a>
<a name="ln1106">    dt_gui_gtk_set_source_rgb(cr, bgcol);</a>
<a name="ln1107">    cairo_fill_preserve(cr);</a>
<a name="ln1108">    cairo_set_line_width(cr, 0.005 * width);</a>
<a name="ln1109">    dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln1110">    cairo_stroke(cr);</a>
<a name="ln1111"> </a>
<a name="ln1112">    if(img)</a>
<a name="ln1113">    {</a>
<a name="ln1114">      PangoLayout *layout;</a>
<a name="ln1115">      PangoRectangle ink;</a>
<a name="ln1116">      PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln1117">      pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln1118">      const int fontsize = 0.20 * width;</a>
<a name="ln1119">      pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);</a>
<a name="ln1120">      layout = pango_cairo_create_layout(cr);</a>
<a name="ln1121">      pango_layout_set_font_description(layout, desc);</a>
<a name="ln1122">      const char *ext = img-&gt;filename + strlen(img-&gt;filename);</a>
<a name="ln1123">      while(ext &gt; img-&gt;filename &amp;&amp; *ext != '.') ext--;</a>
<a name="ln1124">      ext++;</a>
<a name="ln1125">      dt_gui_gtk_set_source_rgb(cr, fontcol);</a>
<a name="ln1126"> </a>
<a name="ln1127">      char* upcase_ext = g_ascii_strup(ext, -1);  // extension in capital letters to avoid character descenders</a>
<a name="ln1128"> </a>
<a name="ln1129">      if (buf.height &gt; buf.width)</a>
<a name="ln1130">      {</a>
<a name="ln1131">        int max_chr_width = 0;</a>
<a name="ln1132">        for (int i = 0; upcase_ext[i] != 0; i++)</a>
<a name="ln1133">        {</a>
<a name="ln1134">          pango_layout_set_text(layout, &amp;upcase_ext[i], 1);</a>
<a name="ln1135">          pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln1136">          max_chr_width = MAX(max_chr_width, ink.width);</a>
<a name="ln1137">        }</a>
<a name="ln1138"> </a>
<a name="ln1139">        for (int i = 0, yoffs = fontsize;  upcase_ext[i] != 0; i++,  yoffs -= fontsize)</a>
<a name="ln1140">        {</a>
<a name="ln1141">          pango_layout_set_text(layout, &amp;upcase_ext[i], 1);</a>
<a name="ln1142">          pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln1143">          cairo_move_to(cr, .025 * width - ink.x + (max_chr_width - ink.width) / 2, .2 * height - yoffs);</a>
<a name="ln1144">          pango_cairo_show_layout(cr, layout);</a>
<a name="ln1145">        }</a>
<a name="ln1146">      }</a>
<a name="ln1147">      else</a>
<a name="ln1148">      {</a>
<a name="ln1149">        pango_layout_set_text(layout, upcase_ext, -1);</a>
<a name="ln1150">        pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln1151">        cairo_move_to(cr, .025 * width - ink.x, .2 * height - fontsize);</a>
<a name="ln1152">        pango_cairo_show_layout(cr, layout);</a>
<a name="ln1153">      }</a>
<a name="ln1154">      g_free(upcase_ext);</a>
<a name="ln1155">      pango_font_description_free(desc);</a>
<a name="ln1156">      g_object_unref(layout);</a>
<a name="ln1157"> </a>
<a name="ln1158">    }</a>
<a name="ln1159">  }</a>
<a name="ln1160"> </a>
<a name="ln1161">  // if we got a different mip than requested, and it's not a skull (8x8 px), we count</a>
<a name="ln1162">  // this thumbnail as missing (to trigger re-exposure)</a>
<a name="ln1163">  if(buf.size != mip &amp;&amp; buf.width != 8 &amp;&amp; buf.height != 8) missing = 1;</a>
<a name="ln1164"> </a>
<a name="ln1165">  if (draw_thumb)</a>
<a name="ln1166">  {</a>
<a name="ln1167">    float scale = 1.0;</a>
<a name="ln1168"> </a>
<a name="ln1169">    cairo_surface_t *surface = NULL;</a>
<a name="ln1170">    uint8_t *rgbbuf = NULL;</a>
<a name="ln1171">    if(buf.buf)</a>
<a name="ln1172">    {</a>
<a name="ln1173">      rgbbuf = (uint8_t *)calloc(buf.width * buf.height * 4, sizeof(uint8_t));</a>
<a name="ln1174">      if(rgbbuf)</a>
<a name="ln1175">      {</a>
<a name="ln1176">        gboolean have_lock = FALSE;</a>
<a name="ln1177">        cmsHTRANSFORM transform = NULL;</a>
<a name="ln1178"> </a>
<a name="ln1179">        if(dt_conf_get_bool(&quot;cache_color_managed&quot;))</a>
<a name="ln1180">        {</a>
<a name="ln1181">          pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1182">          have_lock = TRUE;</a>
<a name="ln1183"> </a>
<a name="ln1184">          // we only color manage when a thumbnail is sRGB or AdobeRGB. everything else just gets dumped to the screen</a>
<a name="ln1185">          if(buf.color_space == DT_COLORSPACE_SRGB &amp;&amp;</a>
<a name="ln1186">             darktable.color_profiles-&gt;transform_srgb_to_display)</a>
<a name="ln1187">          {</a>
<a name="ln1188">            transform = darktable.color_profiles-&gt;transform_srgb_to_display;</a>
<a name="ln1189">          }</a>
<a name="ln1190">          else if(buf.color_space == DT_COLORSPACE_ADOBERGB &amp;&amp;</a>
<a name="ln1191">                  darktable.color_profiles-&gt;transform_adobe_rgb_to_display)</a>
<a name="ln1192">          {</a>
<a name="ln1193">            transform = darktable.color_profiles-&gt;transform_adobe_rgb_to_display;</a>
<a name="ln1194">          }</a>
<a name="ln1195">          else</a>
<a name="ln1196">          {</a>
<a name="ln1197">            pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1198">            have_lock = FALSE;</a>
<a name="ln1199">            if(buf.color_space == DT_COLORSPACE_NONE)</a>
<a name="ln1200">            {</a>
<a name="ln1201">              fprintf(stderr, &quot;oops, there seems to be a code path not setting the color space of thumbnails!\n&quot;);</a>
<a name="ln1202">            }</a>
<a name="ln1203">            else if(buf.color_space != DT_COLORSPACE_DISPLAY)</a>
<a name="ln1204">            {</a>
<a name="ln1205">              fprintf(stderr, &quot;oops, there seems to be a code path setting an unhandled color space of thumbnails (%s)!\n&quot;,</a>
<a name="ln1206">                      dt_colorspaces_get_name(buf.color_space, &quot;from file&quot;));</a>
<a name="ln1207">            }</a>
<a name="ln1208">          }</a>
<a name="ln1209">        }</a>
<a name="ln1210"> </a>
<a name="ln1211">#ifdef _OPENMP</a>
<a name="ln1212">  #pragma omp parallel for schedule(static) default(none) shared(buf, rgbbuf, transform)</a>
<a name="ln1213">#endif</a>
<a name="ln1214">        for(int i = 0; i &lt; buf.height; i++)</a>
<a name="ln1215">        {</a>
<a name="ln1216">          const uint8_t *in = buf.buf + i * buf.width * 4;</a>
<a name="ln1217">          uint8_t *out = rgbbuf + i * buf.width * 4;</a>
<a name="ln1218"> </a>
<a name="ln1219">          if(transform)</a>
<a name="ln1220">          {</a>
<a name="ln1221">            cmsDoTransform(transform, in, out, buf.width);</a>
<a name="ln1222">          }</a>
<a name="ln1223">          else</a>
<a name="ln1224">          {</a>
<a name="ln1225">            for(int j = 0; j &lt; buf.width; j++, in += 4, out += 4)</a>
<a name="ln1226">            {</a>
<a name="ln1227">              out[0] = in[2];</a>
<a name="ln1228">              out[1] = in[1];</a>
<a name="ln1229">              out[2] = in[0];</a>
<a name="ln1230">            }</a>
<a name="ln1231">          }</a>
<a name="ln1232">        }</a>
<a name="ln1233">        if(have_lock) pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1234"> </a>
<a name="ln1235">        const int32_t stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, buf.width);</a>
<a name="ln1236">        surface</a>
<a name="ln1237">          = cairo_image_surface_create_for_data(rgbbuf, CAIRO_FORMAT_RGB24, buf.width, buf.height, stride);</a>
<a name="ln1238">      }</a>
<a name="ln1239"> </a>
<a name="ln1240">      if(zoom == 1 &amp;&amp; !image_only)</a>
<a name="ln1241">      {</a>
<a name="ln1242">        const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln1243">        scale = fminf((width - 2 * tb) / (float)buf.width, (height - 2 * tb) / (float)buf.height);</a>
<a name="ln1244">      }</a>
<a name="ln1245">      else</a>
<a name="ln1246">        scale = fminf(width * imgwd / (float)buf.width, height * imgwd / (float)buf.height);</a>
<a name="ln1247">    }</a>
<a name="ln1248"> </a>
<a name="ln1249">    // draw centered and fitted:</a>
<a name="ln1250">    cairo_save(cr);</a>
<a name="ln1251"> </a>
<a name="ln1252">    if (image_only) // in this case we want to display the picture exactly at (px, py)</a>
<a name="ln1253">      cairo_translate(cr, px, py);</a>
<a name="ln1254">    else</a>
<a name="ln1255">      cairo_translate(cr, width / 2.0, height / 2.0);</a>
<a name="ln1256"> </a>
<a name="ln1257">    cairo_scale(cr, scale, scale);</a>
<a name="ln1258"> </a>
<a name="ln1259">    if(buf.buf &amp;&amp; surface)</a>
<a name="ln1260">    {</a>
<a name="ln1261">      if (!image_only) cairo_translate(cr, -0.5 * buf.width, -0.5 * buf.height);</a>
<a name="ln1262">      cairo_set_source_surface(cr, surface, 0, 0);</a>
<a name="ln1263">      // set filter no nearest:</a>
<a name="ln1264">      // in skull mode, we want to see big pixels.</a>
<a name="ln1265">      // in 1 iir mode for the right mip, we want to see exactly what the pipe gave us, 1:1 pixel for pixel.</a>
<a name="ln1266">      // in between, filtering just makes stuff go unsharp.</a>
<a name="ln1267">      if((buf.width &lt;= 8 &amp;&amp; buf.height &lt;= 8) || fabsf(scale - 1.0f) &lt; 0.01f)</a>
<a name="ln1268">        cairo_pattern_set_filter(cairo_get_source(cr), CAIRO_FILTER_NEAREST);</a>
<a name="ln1269">      cairo_rectangle(cr, 0, 0, buf.width, buf.height);</a>
<a name="ln1270">      cairo_fill(cr);</a>
<a name="ln1271">      cairo_surface_destroy(surface);</a>
<a name="ln1272"> </a>
<a name="ln1273">      cairo_rectangle(cr, 0, 0, buf.width, buf.height);</a>
<a name="ln1274">    }</a>
<a name="ln1275"> </a>
<a name="ln1276">    free(rgbbuf);</a>
<a name="ln1277"> </a>
<a name="ln1278">    if (image_only)</a>
<a name="ln1279">    {</a>
<a name="ln1280">      cairo_restore(cr);</a>
<a name="ln1281">      cairo_save(cr);</a>
<a name="ln1282">      cairo_new_path(cr);</a>
<a name="ln1283">    }</a>
<a name="ln1284">    else</a>
<a name="ln1285">    {</a>
<a name="ln1286">      // border around image</a>
<a name="ln1287">      dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_THUMBNAIL_BORDER);</a>
<a name="ln1288">      if(buf.buf &amp;&amp; (selected || zoom == 1))</a>
<a name="ln1289">      {</a>
<a name="ln1290">        const float border = zoom == 1 ? DT_PIXEL_APPLY_DPI(16 / scale) : DT_PIXEL_APPLY_DPI(2 / scale);</a>
<a name="ln1291">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1. / scale));</a>
<a name="ln1292">        if(zoom == 1)</a>
<a name="ln1293">        {</a>
<a name="ln1294">          // draw shadow around border</a>
<a name="ln1295">          cairo_set_source_rgb(cr, 0.2, 0.2, 0.2);</a>
<a name="ln1296">          cairo_stroke(cr);</a>
<a name="ln1297">          // cairo_new_path(cr);</a>
<a name="ln1298">          cairo_set_fill_rule(cr, CAIRO_FILL_RULE_EVEN_ODD);</a>
<a name="ln1299">          float alpha = 1.0f;</a>
<a name="ln1300">          for(int k = 0; k &lt; 16; k++)</a>
<a name="ln1301">          {</a>
<a name="ln1302">            cairo_rectangle(cr, 0, 0, buf.width, buf.height);</a>
<a name="ln1303">            cairo_new_sub_path(cr);</a>
<a name="ln1304">            cairo_rectangle(cr, -k / scale, -k / scale, buf.width + 2. * k / scale, buf.height + 2. * k / scale);</a>
<a name="ln1305">            cairo_set_source_rgba(cr, 0, 0, 0, alpha);</a>
<a name="ln1306">            alpha *= 0.6f;</a>
<a name="ln1307">            cairo_fill(cr);</a>
<a name="ln1308">          }</a>
<a name="ln1309">        }</a>
<a name="ln1310">        else</a>
<a name="ln1311">        {</a>
<a name="ln1312">          cairo_set_fill_rule(cr, CAIRO_FILL_RULE_EVEN_ODD);</a>
<a name="ln1313">          cairo_new_sub_path(cr);</a>
<a name="ln1314">          cairo_rectangle(cr, -border, -border, buf.width + 2. * border, buf.height + 2. * border);</a>
<a name="ln1315">          cairo_stroke_preserve(cr);</a>
<a name="ln1316">          dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_THUMBNAIL_SELECTED_BORDER);</a>
<a name="ln1317">          cairo_fill(cr);</a>
<a name="ln1318">        }</a>
<a name="ln1319">      }</a>
<a name="ln1320">      else if(buf.buf)</a>
<a name="ln1321">      {</a>
<a name="ln1322">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(0.5 / scale));</a>
<a name="ln1323">        cairo_stroke(cr);</a>
<a name="ln1324">      }</a>
<a name="ln1325">    }</a>
<a name="ln1326">  }</a>
<a name="ln1327">  cairo_restore(cr);</a>
<a name="ln1328"> </a>
<a name="ln1329">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln1330"> </a>
<a name="ln1331">  cairo_save(cr);</a>
<a name="ln1332"> </a>
<a name="ln1333">  const float fscale = DT_PIXEL_APPLY_DPI(fminf(width, height));</a>
<a name="ln1334">  if(imgsel == imgid || full_preview || darktable.gui-&gt;show_overlays || zoom == 1)</a>
<a name="ln1335">  {</a>
<a name="ln1336">    if(draw_metadata &amp;&amp; width &gt; DECORATION_SIZE_LIMIT)</a>
<a name="ln1337">    {</a>
<a name="ln1338">      // draw mouseover hover effects, set event hook for mouse button down!</a>
<a name="ln1339">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.5));</a>
<a name="ln1340">      dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln1341">      cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);</a>
<a name="ln1342"> </a>
<a name="ln1343">      const gboolean extended_thumb_overlay = dt_conf_get_bool(&quot;plugins/lighttable/extended_thumb_overlay&quot;);</a>
<a name="ln1344">      const gboolean image_is_rejected = (img &amp;&amp; ((img-&gt;flags &amp; 0x7) == 6));</a>
<a name="ln1345"> </a>
<a name="ln1346">      if(img)</a>
<a name="ln1347">      {</a>
<a name="ln1348">        if (zoom != 1 &amp;&amp; (!darktable.gui-&gt;show_overlays || imgsel == imgid) &amp;&amp; extended_thumb_overlay)</a>
<a name="ln1349">        {</a>
<a name="ln1350">          const double overlay_height = 0.26 * height;</a>
<a name="ln1351">          const int exif_offset = DT_PIXEL_APPLY_DPI(3);</a>
<a name="ln1352">          const int fontsize = 0.18 * overlay_height;</a>
<a name="ln1353">          const double line_offs = 1.15 * fontsize;</a>
<a name="ln1354"> </a>
<a name="ln1355"> </a>
<a name="ln1356">          double x0 = DT_PIXEL_APPLY_DPI(1);</a>
<a name="ln1357">          double y0 = height - overlay_height;</a>
<a name="ln1358">          double rect_width = width - DT_PIXEL_APPLY_DPI(2);</a>
<a name="ln1359">          double rect_height = overlay_height - DT_PIXEL_APPLY_DPI(2);</a>
<a name="ln1360">          double radius = DT_PIXEL_APPLY_DPI(5);</a>
<a name="ln1361">          double x1, y1, off, off1;</a>
<a name="ln1362"> </a>
<a name="ln1363">          x1 = x0 + rect_width;</a>
<a name="ln1364">          y1 = y0 + rect_height;</a>
<a name="ln1365">          off = radius * 0.666;</a>
<a name="ln1366">          off1 = radius - off;</a>
<a name="ln1367">          cairo_save(cr);</a>
<a name="ln1368">          cairo_move_to(cr, x0, y0 + radius);</a>
<a name="ln1369">          cairo_curve_to(cr, x0, y0 + off1, x0 + off1, y0, x0 + radius, y0);</a>
<a name="ln1370">          cairo_line_to(cr, x1 - radius, y0);</a>
<a name="ln1371">          cairo_curve_to(cr, x1 - off1, y0, x1, y0 + off1, x1, y0 + radius);</a>
<a name="ln1372">          cairo_line_to(cr, x1, y1 - radius);</a>
<a name="ln1373">          cairo_curve_to(cr, x1, y1 - off1, x1 - off1, y1, x1 - radius, y1);</a>
<a name="ln1374">          cairo_line_to(cr, x0 + radius, y1);</a>
<a name="ln1375">          cairo_curve_to(cr, x0 + off1, y1, x0, y1 - off1, x0, y1 - radius);</a>
<a name="ln1376">          cairo_close_path(cr);</a>
<a name="ln1377">          dt_gui_gtk_set_source_rgb(cr, bgcol);</a>
<a name="ln1378">          cairo_fill_preserve(cr);</a>
<a name="ln1379">          cairo_set_line_width(cr, 0.005 * width);</a>
<a name="ln1380">          dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln1381">          cairo_stroke(cr);</a>
<a name="ln1382"> </a>
<a name="ln1383">          // some exif data</a>
<a name="ln1384">          PangoLayout *layout;</a>
<a name="ln1385">          PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln1386">          pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln1387">          layout = pango_cairo_create_layout(cr);</a>
<a name="ln1388">          pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);</a>
<a name="ln1389">          pango_layout_set_font_description(layout, desc);</a>
<a name="ln1390">          dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln1391"> </a>
<a name="ln1392">          cairo_move_to(cr, x0 + exif_offset, y0 + exif_offset);</a>
<a name="ln1393">          pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_MIDDLE);</a>
<a name="ln1394">          pango_layout_set_width(layout, (int)(PANGO_SCALE * (width - 2 * exif_offset)));</a>
<a name="ln1395">          pango_layout_set_text(layout, img-&gt;filename, -1);</a>
<a name="ln1396">          pango_cairo_show_layout(cr, layout);</a>
<a name="ln1397">          char exifline[50];</a>
<a name="ln1398">          cairo_move_to(cr, x0 + exif_offset, y0 + exif_offset + line_offs);</a>
<a name="ln1399">          dt_image_print_exif(img, exifline, sizeof(exifline));</a>
<a name="ln1400">          pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_END);</a>
<a name="ln1401">          pango_layout_set_text(layout, exifline, -1);</a>
<a name="ln1402">          pango_cairo_show_layout(cr, layout);</a>
<a name="ln1403"> </a>
<a name="ln1404">          pango_font_description_free(desc);</a>
<a name="ln1405">          g_object_unref(layout);</a>
<a name="ln1406">          cairo_restore(cr);</a>
<a name="ln1407">        }</a>
<a name="ln1408"> </a>
<a name="ln1409">        if(!image_is_rejected) // if rejected: draw no stars</a>
<a name="ln1410">        {</a>
<a name="ln1411">          for(int k = 0; k &lt; 5; k++)</a>
<a name="ln1412">          {</a>
<a name="ln1413">            dt_view_image_over_t star = DT_VIEW_STAR_1 + k;</a>
<a name="ln1414">            if(dt_view_process_image_over(star, imgsel == imgid || zoom == 1, cr, img,</a>
<a name="ln1415">                                          width, height, zoom, px, py, outlinecol, fontcol))</a>
<a name="ln1416">              *image_over = star;</a>
<a name="ln1417">          }</a>
<a name="ln1418">        }</a>
<a name="ln1419">      }</a>
<a name="ln1420"> </a>
<a name="ln1421">      if(dt_view_process_image_over(DT_VIEW_REJECT, imgsel == imgid || zoom == 1, cr, img,</a>
<a name="ln1422">                                    width, height, zoom, px, py, outlinecol, fontcol))</a>
<a name="ln1423">        *image_over = DT_VIEW_REJECT;</a>
<a name="ln1424"> </a>
<a name="ln1425">      if(draw_audio &amp;&amp; img &amp;&amp; (img-&gt;flags &amp; DT_IMAGE_HAS_WAV))</a>
<a name="ln1426">      {</a>
<a name="ln1427">        if(dt_view_process_image_over(DT_VIEW_AUDIO, imgsel == imgid || zoom == 1, cr, img,</a>
<a name="ln1428">                                      width, height, zoom, px, py, outlinecol, fontcol))</a>
<a name="ln1429">          *image_over = DT_VIEW_AUDIO;</a>
<a name="ln1430">      }</a>
<a name="ln1431"> </a>
<a name="ln1432">      if(draw_grouping)</a>
<a name="ln1433">      {</a>
<a name="ln1434">        DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.get_grouped);</a>
<a name="ln1435">        DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.get_grouped);</a>
<a name="ln1436">        DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.get_grouped, 1, imgid);</a>
<a name="ln1437">        DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.get_grouped, 2, imgid);</a>
<a name="ln1438"> </a>
<a name="ln1439">        /* lets check if imgid is in a group */</a>
<a name="ln1440">        if(sqlite3_step(darktable.view_manager-&gt;statements.get_grouped) == SQLITE_ROW)</a>
<a name="ln1441">          is_grouped = 1;</a>
<a name="ln1442">        else if(img &amp;&amp; darktable.gui-&gt;expanded_group_id == img-&gt;group_id)</a>
<a name="ln1443">          darktable.gui-&gt;expanded_group_id = -1;</a>
<a name="ln1444">      }</a>
<a name="ln1445"> </a>
<a name="ln1446">      // image part of a group?</a>
<a name="ln1447">      if(is_grouped &amp;&amp; darktable.gui &amp;&amp; darktable.gui-&gt;grouping)</a>
<a name="ln1448">      {</a>
<a name="ln1449">        if(dt_view_process_image_over(DT_VIEW_GROUP, img != NULL, cr, img,</a>
<a name="ln1450">                                      width, height, zoom, px, py, outlinecol, fontcol))</a>
<a name="ln1451">          *image_over = DT_VIEW_GROUP;</a>
<a name="ln1452">      }</a>
<a name="ln1453"> </a>
<a name="ln1454">      // image altered?</a>
<a name="ln1455">      if(draw_history &amp;&amp; dt_image_altered(imgid))</a>
<a name="ln1456">      {</a>
<a name="ln1457">        if(dt_view_process_image_over(DT_VIEW_ALTERED, img != NULL, cr, img,</a>
<a name="ln1458">                                      width, height, zoom, px, py, outlinecol, fontcol))</a>
<a name="ln1459">          darktable.gui-&gt;center_tooltip = 1;</a>
<a name="ln1460">      }</a>
<a name="ln1461">    }</a>
<a name="ln1462">  }</a>
<a name="ln1463">  cairo_restore(cr);</a>
<a name="ln1464"> </a>
<a name="ln1465">  // kill all paths, in case img was not loaded yet, or is blocked:</a>
<a name="ln1466">  cairo_new_path(cr);</a>
<a name="ln1467"> </a>
<a name="ln1468">  if (draw_colorlabels)</a>
<a name="ln1469">  {</a>
<a name="ln1470">    // TODO: make mouse sensitive, just as stars!</a>
<a name="ln1471">    // TODO: cache in image struct!</a>
<a name="ln1472"> </a>
<a name="ln1473">    // TODO: there is a branch that sets the bg == colorlabel</a>
<a name="ln1474">    //       this might help if zoom &gt; 15</a>
<a name="ln1475">    if(width &gt; DECORATION_SIZE_LIMIT)</a>
<a name="ln1476">    {</a>
<a name="ln1477">      // color labels:</a>
<a name="ln1478">      const float x[] = {0.84, 0.92, 0.88, 0.84, 0.92};</a>
<a name="ln1479">      const float y[] = {0.84, 0.84, 0.88, 0.92, 0.92};</a>
<a name="ln1480">      const float x_zoom[] = {0.27, 0.30, 0.285, 0.27, 0.30};</a>
<a name="ln1481">      const float y_zoom[] = {0.095, 0.095, 0.11, 0.125, 0.125};</a>
<a name="ln1482">      const int max_col = sizeof(x) / sizeof(x[0]);</a>
<a name="ln1483">      const float r = zoom == 1 ? 0.01 * fscale : 0.03 * width;</a>
<a name="ln1484"> </a>
<a name="ln1485">      gboolean colorlabel_painted = FALSE;</a>
<a name="ln1486">      gboolean painted_col[] = {FALSE, FALSE, FALSE, FALSE, FALSE};</a>
<a name="ln1487"> </a>
<a name="ln1488">      /* clear and reset prepared statement */</a>
<a name="ln1489">      DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.get_color);</a>
<a name="ln1490">      DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.get_color);</a>
<a name="ln1491"> </a>
<a name="ln1492">      /* setup statement and iterate rows */</a>
<a name="ln1493">      DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.get_color, 1, imgid);</a>
<a name="ln1494">      while(sqlite3_step(darktable.view_manager-&gt;statements.get_color) == SQLITE_ROW)</a>
<a name="ln1495">      {</a>
<a name="ln1496">        cairo_save(cr);</a>
<a name="ln1497">        const int col = sqlite3_column_int(darktable.view_manager-&gt;statements.get_color, 0);</a>
<a name="ln1498">        if (col &lt; max_col)</a>
<a name="ln1499">        {</a>
<a name="ln1500">          // see src/dtgtk/paint.c</a>
<a name="ln1501">          if (zoom != 1)</a>
<a name="ln1502">            dtgtk_cairo_paint_label(cr, x[col]  * width, y[col] * height, r * 2, r * 2, col, NULL);</a>
<a name="ln1503">          else</a>
<a name="ln1504">            dtgtk_cairo_paint_label(cr, x_zoom[col]  * fscale, y_zoom[col] * fscale, r * 2, r * 2, col, NULL);</a>
<a name="ln1505">          colorlabel_painted = colorlabel_painted || TRUE;</a>
<a name="ln1506">          painted_col[col] = TRUE;</a>
<a name="ln1507">        }</a>
<a name="ln1508">        cairo_restore(cr);</a>
<a name="ln1509">      }</a>
<a name="ln1510">      if (colorlabel_painted)</a>
<a name="ln1511">      {</a>
<a name="ln1512">        const int dont_fill_col = 7;</a>
<a name="ln1513">        for(int i = 0; i &lt; max_col; i++)</a>
<a name="ln1514">        {</a>
<a name="ln1515">          if (!painted_col[i])</a>
<a name="ln1516">          {</a>
<a name="ln1517">            cairo_save(cr);</a>
<a name="ln1518">            if (zoom != 1)</a>
<a name="ln1519">              dtgtk_cairo_paint_label(cr, x[i]  * width, y[i] * height, r * 2, r * 2, dont_fill_col, NULL);</a>
<a name="ln1520">            else</a>
<a name="ln1521">              dtgtk_cairo_paint_label(cr, x_zoom[i]  * fscale, y_zoom[i] * fscale, r * 2, r * 2, dont_fill_col, NULL);</a>
<a name="ln1522">            cairo_restore(cr);</a>
<a name="ln1523">          }</a>
<a name="ln1524">        }</a>
<a name="ln1525">      }</a>
<a name="ln1526">    }</a>
<a name="ln1527">  }</a>
<a name="ln1528"> </a>
<a name="ln1529">  if (draw_local_copy)</a>
<a name="ln1530">  {</a>
<a name="ln1531">    if(img &amp;&amp; width &gt; DECORATION_SIZE_LIMIT)</a>
<a name="ln1532">    {</a>
<a name="ln1533">      const gboolean has_local_copy = (img &amp;&amp; (img-&gt;flags &amp; DT_IMAGE_LOCAL_COPY));</a>
<a name="ln1534"> </a>
<a name="ln1535">      if (has_local_copy)</a>
<a name="ln1536">      {</a>
<a name="ln1537">        cairo_save(cr);</a>
<a name="ln1538"> </a>
<a name="ln1539">        if (zoom != 1)</a>
<a name="ln1540">        {</a>
<a name="ln1541">          const double x0 = DT_PIXEL_APPLY_DPI(1), y0 = DT_PIXEL_APPLY_DPI(1), rect_width = width - DT_PIXEL_APPLY_DPI(2),</a>
<a name="ln1542">                radius = DT_PIXEL_APPLY_DPI(5);</a>
<a name="ln1543">          double x1, off, off1;</a>
<a name="ln1544"> </a>
<a name="ln1545">          x1 = x0 + rect_width;</a>
<a name="ln1546">          off = radius * 0.666;</a>
<a name="ln1547">          off1 = radius - off;</a>
<a name="ln1548"> </a>
<a name="ln1549">          cairo_move_to(cr, x1 - width * 0.08, y0);</a>
<a name="ln1550">          cairo_line_to(cr, x1 - radius, y0);</a>
<a name="ln1551">          cairo_curve_to(cr, x1 - off1, y0, x1, y0 + off1, x1, y0 + radius);</a>
<a name="ln1552">          cairo_line_to(cr, x1, y0 + height * 0.08);</a>
<a name="ln1553">          cairo_close_path(cr);</a>
<a name="ln1554">          cairo_set_source_rgb(cr, 1, 1, 1);</a>
<a name="ln1555">          cairo_fill_preserve(cr);</a>
<a name="ln1556">          cairo_set_line_width(cr, 0.005 * width);</a>
<a name="ln1557">          dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln1558">          cairo_stroke(cr);</a>
<a name="ln1559">        }</a>
<a name="ln1560">        else</a>
<a name="ln1561">        {</a>
<a name="ln1562">          const float x_zoom = 0.280;</a>
<a name="ln1563">          const float y_zoom = 0.110;</a>
<a name="ln1564">          const float edge_length = 0.018 * fscale;</a>
<a name="ln1565"> </a>
<a name="ln1566">          cairo_rectangle(cr, x_zoom * fscale, y_zoom * fscale, edge_length, edge_length);</a>
<a name="ln1567">          cairo_set_source_rgb(cr, 0.5, 0.5, 0.5);</a>
<a name="ln1568">          cairo_set_line_width(cr, 0.002 * fscale);</a>
<a name="ln1569">          cairo_stroke(cr);</a>
<a name="ln1570"> </a>
<a name="ln1571">          cairo_move_to(cr, x_zoom * fscale + edge_length * 0.1, y_zoom * fscale);</a>
<a name="ln1572">          cairo_line_to(cr, x_zoom * fscale + edge_length, y_zoom * fscale);</a>
<a name="ln1573">          cairo_line_to(cr, x_zoom * fscale + edge_length, y_zoom * fscale + edge_length * 0.9);</a>
<a name="ln1574">          cairo_close_path(cr);</a>
<a name="ln1575">          cairo_set_source_rgb(cr, 1, 1, 1);</a>
<a name="ln1576">          cairo_fill_preserve(cr);</a>
<a name="ln1577">          cairo_set_source_rgb(cr, 0.5, 0.5, 0.5);</a>
<a name="ln1578">          cairo_stroke(cr);</a>
<a name="ln1579">        }</a>
<a name="ln1580">        cairo_restore(cr);</a>
<a name="ln1581">      }</a>
<a name="ln1582">    }</a>
<a name="ln1583">  }</a>
<a name="ln1584"> </a>
<a name="ln1585">  if(draw_metadata &amp;&amp; img &amp;&amp; (zoom == 1))</a>
<a name="ln1586">  {</a>
<a name="ln1587">    // some exif data</a>
<a name="ln1588">    PangoLayout *layout;</a>
<a name="ln1589">    PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln1590">    pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln1591">    layout = pango_cairo_create_layout(cr);</a>
<a name="ln1592">    const int fontsize = 0.025 * fscale;</a>
<a name="ln1593">    pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);</a>
<a name="ln1594">    pango_layout_set_font_description(layout, desc);</a>
<a name="ln1595">    cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);</a>
<a name="ln1596">    cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0));</a>
<a name="ln1597">    cairo_set_source_rgb(cr, 0.3, 0.3, 0.3);</a>
<a name="ln1598"> </a>
<a name="ln1599">    cairo_move_to(cr, .02 * fscale, .04 * fscale - fontsize);</a>
<a name="ln1600">    pango_layout_set_text(layout, img-&gt;filename, -1);</a>
<a name="ln1601">    pango_cairo_layout_path(cr, layout);</a>
<a name="ln1602">    char exifline[50];</a>
<a name="ln1603">    cairo_move_to(cr, .02 * fscale, .08 * fscale - fontsize);</a>
<a name="ln1604">    dt_image_print_exif(img, exifline, sizeof(exifline));</a>
<a name="ln1605">    pango_layout_set_text(layout, exifline, -1);</a>
<a name="ln1606">    pango_cairo_layout_path(cr, layout);</a>
<a name="ln1607">    cairo_stroke_preserve(cr);</a>
<a name="ln1608">    cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln1609">    cairo_fill(cr);</a>
<a name="ln1610">    pango_font_description_free(desc);</a>
<a name="ln1611">    g_object_unref(layout);</a>
<a name="ln1612"> </a>
<a name="ln1613">  }</a>
<a name="ln1614"> </a>
<a name="ln1615">  // draw custom metadata from accompanying text file:</a>
<a name="ln1616">  if(draw_metadata &amp;&amp; img &amp;&amp; (img-&gt;flags &amp; DT_IMAGE_HAS_TXT) &amp;&amp; dt_conf_get_bool(&quot;plugins/lighttable/draw_custom_metadata&quot;)</a>
<a name="ln1617">     &amp;&amp; (zoom == 1))</a>
<a name="ln1618">  {</a>
<a name="ln1619">    char *path = dt_image_get_text_path(img-&gt;id);</a>
<a name="ln1620">    if(path)</a>
<a name="ln1621">    {</a>
<a name="ln1622">      FILE *f = g_fopen(path, &quot;rb&quot;);</a>
<a name="ln1623">      if(f)</a>
<a name="ln1624">      {</a>
<a name="ln1625">        char line[2048];</a>
<a name="ln1626">        PangoLayout *layout;</a>
<a name="ln1627">        PangoFontDescription *desc = pango_font_description_from_string(&quot;monospace bold&quot;);</a>
<a name="ln1628">        layout = pango_cairo_create_layout(cr);</a>
<a name="ln1629">        const float fontsize = 0.015 * fscale;</a>
<a name="ln1630">        pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);</a>
<a name="ln1631">        pango_layout_set_font_description(layout, desc);</a>
<a name="ln1632">        // cairo_set_operator(cr, CAIRO_OPERATOR_XOR);</a>
<a name="ln1633">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0));</a>
<a name="ln1634">        cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);</a>
<a name="ln1635">        int k = 0;</a>
<a name="ln1636">        while(!feof(f))</a>
<a name="ln1637">        {</a>
<a name="ln1638">          gchar *line_pattern = g_strdup_printf(&quot;%%%zu[^\n]&quot;, sizeof(line) - 1);</a>
<a name="ln1639">          const int read = fscanf(f, line_pattern, line);</a>
<a name="ln1640">          g_free(line_pattern);</a>
<a name="ln1641">          if(read != 1) break;</a>
<a name="ln1642">          fgetc(f); // munch \n</a>
<a name="ln1643"> </a>
<a name="ln1644">          cairo_move_to(cr, .02 * fscale, .20 * fscale + .017 * fscale * k - fontsize);</a>
<a name="ln1645">          cairo_set_source_rgb(cr, 0.3, 0.3, 0.3);</a>
<a name="ln1646">          pango_layout_set_text(layout, line, -1);</a>
<a name="ln1647">          pango_cairo_layout_path(cr, layout);</a>
<a name="ln1648">          cairo_stroke_preserve(cr);</a>
<a name="ln1649">          cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln1650">          cairo_fill(cr);</a>
<a name="ln1651">          k++;</a>
<a name="ln1652">        }</a>
<a name="ln1653">        fclose(f);</a>
<a name="ln1654">        pango_font_description_free(desc);</a>
<a name="ln1655">        g_object_unref(layout);</a>
<a name="ln1656"> </a>
<a name="ln1657">      }</a>
<a name="ln1658">      g_free(path);</a>
<a name="ln1659">    }</a>
<a name="ln1660">  }</a>
<a name="ln1661"> </a>
<a name="ln1662">  cairo_restore(cr);</a>
<a name="ln1663">  // if(zoom == 1) cairo_set_antialias(cr, CAIRO_ANTIALIAS_DEFAULT);</a>
<a name="ln1664"> </a>
<a name="ln1665">  const double end = dt_get_wtime();</a>
<a name="ln1666">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1667">    dt_print(DT_DEBUG_LIGHTTABLE, &quot;[lighttable] image expose took %0.04f sec\n&quot;, end - start);</a>
<a name="ln1668">  return missing;</a>
<a name="ln1669">}</a>
<a name="ln1670"> </a>
<a name="ln1671">void</a>
<a name="ln1672">dt_view_image_only_expose(</a>
<a name="ln1673">  uint32_t imgid,</a>
<a name="ln1674">  cairo_t *cr,</a>
<a name="ln1675">  int32_t width,</a>
<a name="ln1676">  int32_t height,</a>
<a name="ln1677">  int32_t offsetx,</a>
<a name="ln1678">  int32_t offsety)</a>
<a name="ln1679">{</a>
<a name="ln1680">  dt_view_image_over_t image_over;</a>
<a name="ln1681">  dt_view_image_expose(&amp;image_over, imgid, cr, width, height, 1, offsetx, offsety, TRUE, TRUE);</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684"> </a>
<a name="ln1685">/**</a>
<a name="ln1686"> * \brief Set the selection bit to a given value for the specified image</a>
<a name="ln1687"> * \param[in] imgid The image id</a>
<a name="ln1688"> * \param[in] value The boolean value for the bit</a>
<a name="ln1689"> */</a>
<a name="ln1690">void dt_view_set_selection(int imgid, int value)</a>
<a name="ln1691">{</a>
<a name="ln1692">  /* clear and reset statement */</a>
<a name="ln1693">  DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln1694">  DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln1695"> </a>
<a name="ln1696">  /* setup statement and iterate over rows */</a>
<a name="ln1697">  DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.is_selected, 1, imgid);</a>
<a name="ln1698"> </a>
<a name="ln1699">  if(sqlite3_step(darktable.view_manager-&gt;statements.is_selected) == SQLITE_ROW)</a>
<a name="ln1700">  {</a>
<a name="ln1701">    if(!value)</a>
<a name="ln1702">    {</a>
<a name="ln1703">      /* Value is set and should be unset; get rid of it */</a>
<a name="ln1704"> </a>
<a name="ln1705">      /* clear and reset statement */</a>
<a name="ln1706">      DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.delete_from_selected);</a>
<a name="ln1707">      DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.delete_from_selected);</a>
<a name="ln1708"> </a>
<a name="ln1709">      /* setup statement and execute */</a>
<a name="ln1710">      DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.delete_from_selected, 1, imgid);</a>
<a name="ln1711">      sqlite3_step(darktable.view_manager-&gt;statements.delete_from_selected);</a>
<a name="ln1712">    }</a>
<a name="ln1713">  }</a>
<a name="ln1714">  else if(value)</a>
<a name="ln1715">  {</a>
<a name="ln1716">    /* Select bit is unset and should be set; add it */</a>
<a name="ln1717"> </a>
<a name="ln1718">    /* clear and reset statement */</a>
<a name="ln1719">    DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1720">    DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1721"> </a>
<a name="ln1722">    /* setup statement and execute */</a>
<a name="ln1723">    DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.make_selected, 1, imgid);</a>
<a name="ln1724">    sqlite3_step(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1725">  }</a>
<a name="ln1726">}</a>
<a name="ln1727"> </a>
<a name="ln1728">/**</a>
<a name="ln1729"> * \brief Toggle the selection bit in the database for the specified image</a>
<a name="ln1730"> * \param[in] imgid The image id</a>
<a name="ln1731"> */</a>
<a name="ln1732">void dt_view_toggle_selection(int imgid)</a>
<a name="ln1733">{</a>
<a name="ln1734"> </a>
<a name="ln1735">  /* clear and reset statement */</a>
<a name="ln1736">  DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln1737">  DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln1738"> </a>
<a name="ln1739">  /* setup statement and iterate over rows */</a>
<a name="ln1740">  DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.is_selected, 1, imgid);</a>
<a name="ln1741">  if(sqlite3_step(darktable.view_manager-&gt;statements.is_selected) == SQLITE_ROW)</a>
<a name="ln1742">  {</a>
<a name="ln1743">    /* clear and reset statement */</a>
<a name="ln1744">    DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.delete_from_selected);</a>
<a name="ln1745">    DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.delete_from_selected);</a>
<a name="ln1746"> </a>
<a name="ln1747">    /* setup statement and execute */</a>
<a name="ln1748">    DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.delete_from_selected, 1, imgid);</a>
<a name="ln1749">    sqlite3_step(darktable.view_manager-&gt;statements.delete_from_selected);</a>
<a name="ln1750">  }</a>
<a name="ln1751">  else</a>
<a name="ln1752">  {</a>
<a name="ln1753">    /* clear and reset statement */</a>
<a name="ln1754">    DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1755">    DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1756"> </a>
<a name="ln1757">    /* setup statement and execute */</a>
<a name="ln1758">    DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.make_selected, 1, imgid);</a>
<a name="ln1759">    sqlite3_step(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1760">  }</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763">/**</a>
<a name="ln1764"> * \brief Reset filter</a>
<a name="ln1765"> */</a>
<a name="ln1766">void dt_view_filter_reset(const dt_view_manager_t *vm, gboolean smart_filter)</a>
<a name="ln1767">{</a>
<a name="ln1768">  if(vm-&gt;proxy.filter.module &amp;&amp; vm-&gt;proxy.filter.reset_filter)</a>
<a name="ln1769">    vm-&gt;proxy.filter.reset_filter(vm-&gt;proxy.filter.module, smart_filter);</a>
<a name="ln1770">}</a>
<a name="ln1771"> </a>
<a name="ln1772">void dt_view_filmstrip_scroll_relative(const int diff, int offset)</a>
<a name="ln1773">{</a>
<a name="ln1774">  const gchar *qin = dt_collection_get_query(darktable.collection);</a>
<a name="ln1775">  if(qin)</a>
<a name="ln1776">  {</a>
<a name="ln1777">    sqlite3_stmt *stmt;</a>
<a name="ln1778"> </a>
<a name="ln1779">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), qin, -1, &amp;stmt, NULL);</a>
<a name="ln1780">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, offset + diff);</a>
<a name="ln1781">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, 1);</a>
<a name="ln1782">    if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1783">    {</a>
<a name="ln1784">      const int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1785"> </a>
<a name="ln1786">      if(!darktable.develop-&gt;image_loading)</a>
<a name="ln1787">      {</a>
<a name="ln1788">        dt_view_filmstrip_scroll_to_image(darktable.view_manager, imgid, TRUE);</a>
<a name="ln1789">      }</a>
<a name="ln1790">    }</a>
<a name="ln1791">    sqlite3_finalize(stmt);</a>
<a name="ln1792">  }</a>
<a name="ln1793">}</a>
<a name="ln1794"> </a>
<a name="ln1795">void dt_view_filmstrip_scroll_to_image(dt_view_manager_t *vm, const int imgid, gboolean activate)</a>
<a name="ln1796">{</a>
<a name="ln1797">  // g_return_if_fail(vm-&gt;proxy.filmstrip.module!=NULL); // This can happen here for debugging</a>
<a name="ln1798">  // g_return_if_fail(vm-&gt;proxy.filmstrip.scroll_to_image!=NULL);</a>
<a name="ln1799"> </a>
<a name="ln1800">  if(vm-&gt;proxy.filmstrip.module &amp;&amp; vm-&gt;proxy.filmstrip.scroll_to_image)</a>
<a name="ln1801">    vm-&gt;proxy.filmstrip.scroll_to_image(vm-&gt;proxy.filmstrip.module, imgid, activate);</a>
<a name="ln1802">}</a>
<a name="ln1803"> </a>
<a name="ln1804">int32_t dt_view_filmstrip_get_activated_imgid(dt_view_manager_t *vm)</a>
<a name="ln1805">{</a>
<a name="ln1806">  // g_return_val_if_fail(vm-&gt;proxy.filmstrip.module!=NULL, 0); // This can happen here for debugging</a>
<a name="ln1807">  // g_return_val_if_fail(vm-&gt;proxy.filmstrip.activated_image!=NULL, 0);</a>
<a name="ln1808"> </a>
<a name="ln1809">  if(vm-&gt;proxy.filmstrip.module &amp;&amp; vm-&gt;proxy.filmstrip.activated_image)</a>
<a name="ln1810">    return vm-&gt;proxy.filmstrip.activated_image(vm-&gt;proxy.filmstrip.module);</a>
<a name="ln1811"> </a>
<a name="ln1812">  return 0;</a>
<a name="ln1813">}</a>
<a name="ln1814"> </a>
<a name="ln1815">void dt_view_filmstrip_set_active_image(dt_view_manager_t *vm, int iid)</a>
<a name="ln1816">{</a>
<a name="ln1817">  /* First off clear all selected images... */</a>
<a name="ln1818">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images&quot;, NULL, NULL, NULL);</a>
<a name="ln1819"> </a>
<a name="ln1820">  /* clear and reset statement */</a>
<a name="ln1821">  DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1822">  DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1823"> </a>
<a name="ln1824">  /* setup statement and execute */</a>
<a name="ln1825">  DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.make_selected, 1, iid);</a>
<a name="ln1826">  sqlite3_step(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1827"> </a>
<a name="ln1828">  dt_view_filmstrip_scroll_to_image(vm, iid, TRUE);</a>
<a name="ln1829">}</a>
<a name="ln1830"> </a>
<a name="ln1831">void dt_view_filmstrip_prefetch()</a>
<a name="ln1832">{</a>
<a name="ln1833">  const gchar *qin = dt_collection_get_query(darktable.collection);</a>
<a name="ln1834">  if(!qin) return;</a>
<a name="ln1835"> </a>
<a name="ln1836">  int offset = 0;</a>
<a name="ln1837">  if(qin)</a>
<a name="ln1838">  {</a>
<a name="ln1839">    int imgid = -1;</a>
<a name="ln1840">    sqlite3_stmt *stmt;</a>
<a name="ln1841">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;, -1, &amp;stmt,</a>
<a name="ln1842">                                NULL);</a>
<a name="ln1843">    if(sqlite3_step(stmt) == SQLITE_ROW) imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1844">    sqlite3_finalize(stmt);</a>
<a name="ln1845"> </a>
<a name="ln1846">    offset = dt_collection_image_offset(imgid);</a>
<a name="ln1847">  }</a>
<a name="ln1848"> </a>
<a name="ln1849">  sqlite3_stmt *stmt;</a>
<a name="ln1850">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), qin, -1, &amp;stmt, NULL);</a>
<a name="ln1851">  // only get one more image:</a>
<a name="ln1852">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, offset + 1);</a>
<a name="ln1853">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, offset + 2);</a>
<a name="ln1854">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1855">  {</a>
<a name="ln1856">    const uint32_t prefetchid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1857">    // dt_control_log(&quot;prefetching image %u&quot;, prefetchid);</a>
<a name="ln1858">    dt_mipmap_cache_get(darktable.mipmap_cache, NULL, prefetchid, DT_MIPMAP_FULL, DT_MIPMAP_PREFETCH, 'r');</a>
<a name="ln1859">  }</a>
<a name="ln1860">  sqlite3_finalize(stmt);</a>
<a name="ln1861">}</a>
<a name="ln1862"> </a>
<a name="ln1863">void dt_view_manager_view_toolbox_add(dt_view_manager_t *vm, GtkWidget *tool, dt_view_type_flags_t views)</a>
<a name="ln1864">{</a>
<a name="ln1865">  if(vm-&gt;proxy.view_toolbox.module) vm-&gt;proxy.view_toolbox.add(vm-&gt;proxy.view_toolbox.module, tool, views);</a>
<a name="ln1866">}</a>
<a name="ln1867"> </a>
<a name="ln1868">void dt_view_manager_module_toolbox_add(dt_view_manager_t *vm, GtkWidget *tool, dt_view_type_flags_t views)</a>
<a name="ln1869">{</a>
<a name="ln1870">  if(vm-&gt;proxy.module_toolbox.module) vm-&gt;proxy.module_toolbox.add(vm-&gt;proxy.module_toolbox.module, tool, views);</a>
<a name="ln1871">}</a>
<a name="ln1872"> </a>
<a name="ln1873">void dt_view_lighttable_set_zoom(dt_view_manager_t *vm, gint zoom)</a>
<a name="ln1874">{</a>
<a name="ln1875">  if(vm-&gt;proxy.lighttable.module) vm-&gt;proxy.lighttable.set_zoom(vm-&gt;proxy.lighttable.module, zoom);</a>
<a name="ln1876">}</a>
<a name="ln1877"> </a>
<a name="ln1878">gint dt_view_lighttable_get_zoom(dt_view_manager_t *vm)</a>
<a name="ln1879">{</a>
<a name="ln1880">  if(vm-&gt;proxy.lighttable.module)</a>
<a name="ln1881">    return vm-&gt;proxy.lighttable.get_zoom(vm-&gt;proxy.lighttable.module);</a>
<a name="ln1882">  else</a>
<a name="ln1883">    return 10;</a>
<a name="ln1884">}</a>
<a name="ln1885"> </a>
<a name="ln1886">dt_lighttable_layout_t dt_view_lighttable_get_layout(dt_view_manager_t *vm)</a>
<a name="ln1887">{</a>
<a name="ln1888">  if(vm-&gt;proxy.lighttable.module)</a>
<a name="ln1889">    return vm-&gt;proxy.lighttable.get_layout(vm-&gt;proxy.lighttable.module);</a>
<a name="ln1890">  else</a>
<a name="ln1891">    return DT_LIGHTTABLE_LAYOUT_FILEMANAGER;</a>
<a name="ln1892">}</a>
<a name="ln1893"> </a>
<a name="ln1894">void dt_view_lighttable_set_position(dt_view_manager_t *vm, uint32_t pos)</a>
<a name="ln1895">{</a>
<a name="ln1896">  if(vm-&gt;proxy.lighttable.view) vm-&gt;proxy.lighttable.set_position(vm-&gt;proxy.lighttable.view, pos);</a>
<a name="ln1897"> </a>
<a name="ln1898">  // ugh. but will go away once module guis are persistent between views:</a>
<a name="ln1899">  dt_conf_set_int(&quot;plugins/lighttable/recentcollect/pos0&quot;, pos);</a>
<a name="ln1900">}</a>
<a name="ln1901"> </a>
<a name="ln1902">uint32_t dt_view_lighttable_get_position(dt_view_manager_t *vm)</a>
<a name="ln1903">{</a>
<a name="ln1904">  if(vm-&gt;proxy.lighttable.view) return vm-&gt;proxy.lighttable.get_position(vm-&gt;proxy.lighttable.view);</a>
<a name="ln1905">  return 0;</a>
<a name="ln1906">}</a>
<a name="ln1907"> </a>
<a name="ln1908">void dt_view_collection_update(const dt_view_manager_t *vm)</a>
<a name="ln1909">{</a>
<a name="ln1910">  if(vm-&gt;proxy.module_collect.module) vm-&gt;proxy.module_collect.update(vm-&gt;proxy.module_collect.module);</a>
<a name="ln1911">}</a>
<a name="ln1912"> </a>
<a name="ln1913"> </a>
<a name="ln1914">int32_t dt_view_tethering_get_selected_imgid(const dt_view_manager_t *vm)</a>
<a name="ln1915">{</a>
<a name="ln1916">  if(vm-&gt;proxy.tethering.view) return vm-&gt;proxy.tethering.get_selected_imgid(vm-&gt;proxy.tethering.view);</a>
<a name="ln1917"> </a>
<a name="ln1918">  return -1;</a>
<a name="ln1919">}</a>
<a name="ln1920"> </a>
<a name="ln1921">void dt_view_tethering_set_job_code(const dt_view_manager_t *vm, const char *name)</a>
<a name="ln1922">{</a>
<a name="ln1923">  if(vm-&gt;proxy.tethering.view) vm-&gt;proxy.tethering.set_job_code(vm-&gt;proxy.tethering.view, name);</a>
<a name="ln1924">}</a>
<a name="ln1925"> </a>
<a name="ln1926">const char *dt_view_tethering_get_job_code(const dt_view_manager_t *vm)</a>
<a name="ln1927">{</a>
<a name="ln1928">  if(vm-&gt;proxy.tethering.view) return vm-&gt;proxy.tethering.get_job_code(vm-&gt;proxy.tethering.view);</a>
<a name="ln1929">  return NULL;</a>
<a name="ln1930">}</a>
<a name="ln1931"> </a>
<a name="ln1932">#ifdef HAVE_MAP</a>
<a name="ln1933">void dt_view_map_center_on_location(const dt_view_manager_t *vm, gdouble lon, gdouble lat, gdouble zoom)</a>
<a name="ln1934">{</a>
<a name="ln1935">  if(vm-&gt;proxy.map.view) vm-&gt;proxy.map.center_on_location(vm-&gt;proxy.map.view, lon, lat, zoom);</a>
<a name="ln1936">}</a>
<a name="ln1937"> </a>
<a name="ln1938">void dt_view_map_center_on_bbox(const dt_view_manager_t *vm, gdouble lon1, gdouble lat1, gdouble lon2, gdouble lat2)</a>
<a name="ln1939">{</a>
<a name="ln1940">  if(vm-&gt;proxy.map.view) vm-&gt;proxy.map.center_on_bbox(vm-&gt;proxy.map.view, lon1, lat1, lon2, lat2);</a>
<a name="ln1941">}</a>
<a name="ln1942"> </a>
<a name="ln1943">void dt_view_map_show_osd(const dt_view_manager_t *vm, gboolean enabled)</a>
<a name="ln1944">{</a>
<a name="ln1945">  if(vm-&gt;proxy.map.view) vm-&gt;proxy.map.show_osd(vm-&gt;proxy.map.view, enabled);</a>
<a name="ln1946">}</a>
<a name="ln1947"> </a>
<a name="ln1948">void dt_view_map_set_map_source(const dt_view_manager_t *vm, OsmGpsMapSource_t map_source)</a>
<a name="ln1949">{</a>
<a name="ln1950">  if(vm-&gt;proxy.map.view) vm-&gt;proxy.map.set_map_source(vm-&gt;proxy.map.view, map_source);</a>
<a name="ln1951">}</a>
<a name="ln1952"> </a>
<a name="ln1953">GObject *dt_view_map_add_marker(const dt_view_manager_t *vm, dt_geo_map_display_t type, GList *points)</a>
<a name="ln1954">{</a>
<a name="ln1955">  if(vm-&gt;proxy.map.view) return vm-&gt;proxy.map.add_marker(vm-&gt;proxy.map.view, type, points);</a>
<a name="ln1956">  return NULL;</a>
<a name="ln1957">}</a>
<a name="ln1958"> </a>
<a name="ln1959">gboolean dt_view_map_remove_marker(const dt_view_manager_t *vm, dt_geo_map_display_t type, GObject *marker)</a>
<a name="ln1960">{</a>
<a name="ln1961">  if(vm-&gt;proxy.map.view) return vm-&gt;proxy.map.remove_marker(vm-&gt;proxy.map.view, type, marker);</a>
<a name="ln1962">  return FALSE;</a>
<a name="ln1963">}</a>
<a name="ln1964">#endif</a>
<a name="ln1965"> </a>
<a name="ln1966">#ifdef HAVE_PRINT</a>
<a name="ln1967">void dt_view_print_settings(const dt_view_manager_t *vm, dt_print_info_t *pinfo)</a>
<a name="ln1968">{</a>
<a name="ln1969">  if (vm-&gt;proxy.print.view)</a>
<a name="ln1970">    vm-&gt;proxy.print.print_settings(vm-&gt;proxy.print.view, pinfo);</a>
<a name="ln1971">}</a>
<a name="ln1972">#endif</a>
<a name="ln1973"> </a>
<a name="ln1974">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1975">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1976">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1443"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'darktable.gui' pointer was utilized before it was verified against nullptr. Check lines: 1443, 1447.</p></div>
<div class="balloon" rel="1533"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: img.</p></div>
<div class="balloon" rel="1837"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'qin' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
