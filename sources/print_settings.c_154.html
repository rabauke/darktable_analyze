
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2014-2017 pascal obry.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;glib.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln22">#include &quot;common/collection.h&quot;</a>
<a name="ln23">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln24">#include &quot;common/cups_print.h&quot;</a>
<a name="ln25">#include &quot;common/image_cache.h&quot;</a>
<a name="ln26">#include &quot;common/metadata.h&quot;</a>
<a name="ln27">#include &quot;common/pdf.h&quot;</a>
<a name="ln28">#include &quot;common/printprof.h&quot;</a>
<a name="ln29">#include &quot;common/styles.h&quot;</a>
<a name="ln30">#include &quot;common/tags.h&quot;</a>
<a name="ln31">#include &quot;common/variables.h&quot;</a>
<a name="ln32">#include &quot;control/jobs.h&quot;</a>
<a name="ln33">#include &quot;dtgtk/resetlabel.h&quot;</a>
<a name="ln34">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln35">#include &quot;gui/gtk.h&quot;</a>
<a name="ln36">#include &quot;libs/lib.h&quot;</a>
<a name="ln37">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">DT_MODULE(3)</a>
<a name="ln40"> </a>
<a name="ln41">const char *name(dt_lib_module_t *self)</a>
<a name="ln42">{</a>
<a name="ln43">  return _(&quot;print settings&quot;);</a>
<a name="ln44">}</a>
<a name="ln45"> </a>
<a name="ln46">const char **views(dt_lib_module_t *self)</a>
<a name="ln47">{</a>
<a name="ln48">  static const char *v[] = {&quot;print&quot;, NULL};</a>
<a name="ln49">  return v;</a>
<a name="ln50">}</a>
<a name="ln51"> </a>
<a name="ln52">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln53">{</a>
<a name="ln54">  return DT_UI_CONTAINER_PANEL_RIGHT_CENTER;</a>
<a name="ln55">}</a>
<a name="ln56"> </a>
<a name="ln57">typedef struct dt_lib_print_settings_t</a>
<a name="ln58">{</a>
<a name="ln59">  GtkWidget *profile, *intent, *style, *style_mode, *papers, *media;</a>
<a name="ln60">  GtkWidget *printers, *orientation, *pprofile, *pintent;</a>
<a name="ln61">  GtkWidget *width, *height, *black_point_compensation;</a>
<a name="ln62">  GtkWidget *info;</a>
<a name="ln63">  GList *profiles;</a>
<a name="ln64">  GtkButton *print_button;</a>
<a name="ln65">  GtkToggleButton *lock_button;</a>
<a name="ln66">  GtkWidget *b_top, *b_bottom, *b_left, *b_right;</a>
<a name="ln67">  GtkDarktableToggleButton *dtba[9];	                                   // Alignment buttons</a>
<a name="ln68">  GList *paper_list, *media_list;</a>
<a name="ln69">  gboolean lock_activated;</a>
<a name="ln70">  dt_print_info_t prt;</a>
<a name="ln71">  int32_t image_id;</a>
<a name="ln72">  int32_t iwidth, iheight;</a>
<a name="ln73">  int unit;</a>
<a name="ln74">  int v_intent, v_pintent;</a>
<a name="ln75">  int v_icctype, v_picctype;</a>
<a name="ln76">  char *v_iccprofile, *v_piccprofile, *v_style;</a>
<a name="ln77">  gboolean v_style_append, v_black_point_compensation;</a>
<a name="ln78">} dt_lib_print_settings_t;</a>
<a name="ln79"> </a>
<a name="ln80">typedef struct dt_lib_print_job_t</a>
<a name="ln81">{</a>
<a name="ln82">  int imgid;</a>
<a name="ln83">  gchar *job_title;</a>
<a name="ln84">  dt_print_info_t prt;</a>
<a name="ln85">  gchar* style;</a>
<a name="ln86">  gboolean style_append, black_point_compensation;</a>
<a name="ln87">  dt_colorspaces_color_profile_type_t buf_icc_type, p_icc_type;</a>
<a name="ln88">  gchar *buf_icc_profile, *p_icc_profile;</a>
<a name="ln89">  dt_iop_color_intent_t buf_icc_intent, p_icc_intent;</a>
<a name="ln90">  uint16_t *buf;</a>
<a name="ln91">  dt_pdf_page_t *pdf_page;</a>
<a name="ln92">  dt_pdf_image_t *pdf_image;</a>
<a name="ln93">  char pdf_filename[PATH_MAX];</a>
<a name="ln94">} dt_lib_print_job_t;</a>
<a name="ln95"> </a>
<a name="ln96">typedef struct dt_lib_export_profile_t</a>
<a name="ln97">{</a>
<a name="ln98">  dt_colorspaces_color_profile_type_t type; // filename is only used for type DT_COLORSPACE_FILE</a>
<a name="ln99">  char filename[512];                       // icc file name</a>
<a name="ln100">  char name[512];                           // product name</a>
<a name="ln101">  int  pos, ppos;                           // position in combo boxen</a>
<a name="ln102">} dt_lib_export_profile_t;</a>
<a name="ln103"> </a>
<a name="ln104">typedef struct _dialog_description</a>
<a name="ln105">{</a>
<a name="ln106">  const char *name;</a>
<a name="ln107">} dialog_description_t;</a>
<a name="ln108"> </a>
<a name="ln109">static double units[3] = {1.0, 0.1, 1.0/25.4};</a>
<a name="ln110"> </a>
<a name="ln111">static void _update_slider (dt_lib_print_settings_t *ps);</a>
<a name="ln112"> </a>
<a name="ln113">static const int min_borders = -100; // this is in mm</a>
<a name="ln114"> </a>
<a name="ln115">int</a>
<a name="ln116">position ()</a>
<a name="ln117">{</a>
<a name="ln118">  return 990;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">// callbacks for in-memory export</a>
<a name="ln122"> </a>
<a name="ln123">typedef struct dt_print_format_t</a>
<a name="ln124">{</a>
<a name="ln125">  int max_width, max_height;</a>
<a name="ln126">  int width, height;</a>
<a name="ln127">  char style[128];</a>
<a name="ln128">  gboolean style_append;</a>
<a name="ln129">  int bpp;</a>
<a name="ln130">  dt_lib_print_job_t *params;</a>
<a name="ln131">} dt_print_format_t;</a>
<a name="ln132"> </a>
<a name="ln133">static int bpp(dt_imageio_module_data_t *data)</a>
<a name="ln134">{</a>
<a name="ln135">  const dt_print_format_t *d = (dt_print_format_t *)data;</a>
<a name="ln136">  return d-&gt;bpp;</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139">static int levels(dt_imageio_module_data_t *data)</a>
<a name="ln140">{</a>
<a name="ln141">  const dt_print_format_t *d = (dt_print_format_t *)data;</a>
<a name="ln142">  return IMAGEIO_RGB | (d-&gt;bpp == 8 ? IMAGEIO_INT8 : IMAGEIO_INT16);</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">static const char *mime(dt_imageio_module_data_t *data)</a>
<a name="ln146">{</a>
<a name="ln147">  return &quot;memory&quot;;</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">static int write_image(dt_imageio_module_data_t *data, const char *filename, const void *in,</a>
<a name="ln151">                       dt_colorspaces_color_profile_type_t over_type, const char *over_filename,</a>
<a name="ln152">                       void *exif, int exif_len, int imgid, int num, int total, dt_dev_pixelpipe_t *pipe)</a>
<a name="ln153">{</a>
<a name="ln154">  dt_print_format_t *d = (dt_print_format_t *)data;</a>
<a name="ln155"> </a>
<a name="ln156">  d-&gt;params-&gt;buf = (uint16_t *)malloc(d-&gt;width * d-&gt;height * 3 * (d-&gt;bpp == 8?1:2));</a>
<a name="ln157"> </a>
<a name="ln158">  if (d-&gt;bpp == 8)</a>
<a name="ln159">  {</a>
<a name="ln160">    const uint8_t *in_ptr = (const uint8_t *)in;</a>
<a name="ln161">    uint8_t *out_ptr = (uint8_t *)d-&gt;params-&gt;buf;</a>
<a name="ln162">    for(int y = 0; y &lt; d-&gt;height; y++)</a>
<a name="ln163">    {</a>
<a name="ln164">      for(int x = 0; x &lt; d-&gt;width; x++, in_ptr += 4, out_ptr += 3)</a>
<a name="ln165">        memcpy(out_ptr, in_ptr, 3);</a>
<a name="ln166">    }</a>
<a name="ln167">  }</a>
<a name="ln168">  else</a>
<a name="ln169">  {</a>
<a name="ln170">    const uint16_t *in_ptr = (const uint16_t *)in;</a>
<a name="ln171">    uint16_t *out_ptr = (uint16_t *)d-&gt;params-&gt;buf;</a>
<a name="ln172">    for(int y = 0; y &lt; d-&gt;height; y++)</a>
<a name="ln173">    {</a>
<a name="ln174">      for(int x = 0; x &lt; d-&gt;width; x++, in_ptr += 4, out_ptr += 3)</a>
<a name="ln175">        memcpy(out_ptr, in_ptr, 6);</a>
<a name="ln176">    }</a>
<a name="ln177">  }</a>
<a name="ln178"> </a>
<a name="ln179">  return 0;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">static int _print_job_run(dt_job_t *job)</a>
<a name="ln183">{</a>
<a name="ln184">  dt_lib_print_job_t *params = dt_control_job_get_params(job);</a>
<a name="ln185"> </a>
<a name="ln186">  // user margin are already in the proper orientation landscape/portrait</a>
<a name="ln187">  double width, height;</a>
<a name="ln188">  double margin_w = params-&gt;prt.page.margin_left + params-&gt;prt.page.margin_right;</a>
<a name="ln189">  double margin_h = params-&gt;prt.page.margin_top + params-&gt;prt.page.margin_bottom;</a>
<a name="ln190"> </a>
<a name="ln191">  if (params-&gt;prt.page.landscape)</a>
<a name="ln192">  {</a>
<a name="ln193">    width = params-&gt;prt.paper.height;</a>
<a name="ln194">    height = params-&gt;prt.paper.width;</a>
<a name="ln195">    margin_w += params-&gt;prt.printer.hw_margin_top + params-&gt;prt.printer.hw_margin_bottom;</a>
<a name="ln196">    margin_h += params-&gt;prt.printer.hw_margin_left + params-&gt;prt.printer.hw_margin_right;</a>
<a name="ln197">  }</a>
<a name="ln198">  else</a>
<a name="ln199">  {</a>
<a name="ln200">    width = params-&gt;prt.paper.width;</a>
<a name="ln201">    height = params-&gt;prt.paper.height;</a>
<a name="ln202">    margin_w += params-&gt;prt.printer.hw_margin_left + params-&gt;prt.printer.hw_margin_right;</a>
<a name="ln203">    margin_h += params-&gt;prt.printer.hw_margin_top + params-&gt;prt.printer.hw_margin_bottom;</a>
<a name="ln204">  }</a>
<a name="ln205"> </a>
<a name="ln206">  const int32_t width_pix = (width * params-&gt;prt.printer.resolution) / 25.4;</a>
<a name="ln207">  const int32_t height_pix = (height * params-&gt;prt.printer.resolution) / 25.4;</a>
<a name="ln208"> </a>
<a name="ln209">  const double pa_width  = (width  - margin_w) / 25.4;</a>
<a name="ln210">  const double pa_height = (height - margin_h) / 25.4;</a>
<a name="ln211"> </a>
<a name="ln212">  dt_print(DT_DEBUG_PRINT, &quot;[print] printable area for image %u : %3.2fin x %3.2fin\n&quot;, params-&gt;imgid, pa_width, pa_height);</a>
<a name="ln213"> </a>
<a name="ln214">  // compute the needed size for picture for the given printer resolution</a>
<a name="ln215"> </a>
<a name="ln216">  const int max_width  = (pa_width  * params-&gt;prt.printer.resolution);</a>
<a name="ln217">  const int max_height = (pa_height * params-&gt;prt.printer.resolution);</a>
<a name="ln218"> </a>
<a name="ln219">  dt_print(DT_DEBUG_PRINT, &quot;[print] max image size %d x %d (at resolution %d)\n&quot;, max_width, max_height, params-&gt;prt.printer.resolution);</a>
<a name="ln220"> </a>
<a name="ln221">  dt_imageio_module_format_t buf;</a>
<a name="ln222">  buf.mime = mime;</a>
<a name="ln223">  buf.levels = levels;</a>
<a name="ln224">  buf.bpp = bpp;</a>
<a name="ln225">  buf.write_image = write_image;</a>
<a name="ln226"> </a>
<a name="ln227">  dt_print_format_t dat;</a>
<a name="ln228">  dat.max_width = max_width;</a>
<a name="ln229">  dat.max_height = max_height;</a>
<a name="ln230">  dat.style[0] = '\0';</a>
<a name="ln231">  dat.style_append = params-&gt;style_append;</a>
<a name="ln232">  dat.bpp = *params-&gt;p_icc_profile ? 16 : 8; // set to 16bit when a profile is to be applied</a>
<a name="ln233">  dat.params = params;</a>
<a name="ln234"> </a>
<a name="ln235">  if (params-&gt;style) g_strlcpy(dat.style, params-&gt;style, sizeof(dat.style));</a>
<a name="ln236"> </a>
<a name="ln237">  // let the user know something is happening</a>
<a name="ln238">  dt_control_job_set_progress(job, 0.05);</a>
<a name="ln239">  dt_control_log(_(&quot;processing `%s' for `%s'&quot;), params-&gt;job_title, params-&gt;prt.printer.name);</a>
<a name="ln240"> </a>
<a name="ln241">  const gboolean high_quality = TRUE;</a>
<a name="ln242">  const gboolean upscale = TRUE;</a>
<a name="ln243">  const dt_colorspaces_color_profile_t *buf_profile = dt_colorspaces_get_output_profile(params-&gt;imgid,</a>
<a name="ln244">                                                                                        params-&gt;buf_icc_type,</a>
<a name="ln245">                                                                                        params-&gt;buf_icc_profile);</a>
<a name="ln246"> </a>
<a name="ln247">  dt_imageio_export_with_flags(params-&gt;imgid, &quot;unused&quot;, &amp;buf, (dt_imageio_module_data_t *)&amp;dat, TRUE, FALSE,</a>
<a name="ln248">                               high_quality, upscale, FALSE, NULL, FALSE, params-&gt;buf_icc_type, params-&gt;buf_icc_profile,</a>
<a name="ln249">                               params-&gt;buf_icc_intent,  NULL, NULL, 1, 1);</a>
<a name="ln250"> </a>
<a name="ln251">  // after exporting we know the real size of the image, compute the layout</a>
<a name="ln252"> </a>
<a name="ln253">  // compute print-area (in inches)</a>
<a name="ln254">  int32_t px=0, py=0, pwidth=0, pheight=0;</a>
<a name="ln255">  int32_t ax=0, ay=0, awidth=0, aheight=0;</a>
<a name="ln256">  int32_t ix=0, iy=0, iwidth=0, iheight=0;</a>
<a name="ln257">  int32_t iwpix=dat.width, ihpix=dat.height;</a>
<a name="ln258"> </a>
<a name="ln259">  dt_get_print_layout (params-&gt;imgid, &amp;params-&gt;prt, width_pix, height_pix,</a>
<a name="ln260">                       &amp;iwpix, &amp;ihpix,</a>
<a name="ln261">                       &amp;px, &amp;py, &amp;pwidth, &amp;pheight,</a>
<a name="ln262">                       &amp;ax, &amp;ay, &amp;awidth, &amp;aheight,</a>
<a name="ln263">                       &amp;ix, &amp;iy, &amp;iwidth, &amp;iheight);</a>
<a name="ln264"> </a>
<a name="ln265">  const int margin_top    = iy;</a>
<a name="ln266">  const int margin_left   = ix;</a>
<a name="ln267">  const int margin_right  = pwidth - iwidth - ix;</a>
<a name="ln268">  const int margin_bottom = pheight - iheight - iy;</a>
<a name="ln269"> </a>
<a name="ln270">  dt_print(DT_DEBUG_PRINT, &quot;[print] margins top %d ; bottom %d ; left %d ; right %d\n&quot;,</a>
<a name="ln271">           margin_top, margin_bottom, margin_left, margin_right);</a>
<a name="ln272"> </a>
<a name="ln273">  // we have the exported buffer, let's apply the printer profile</a>
<a name="ln274"> </a>
<a name="ln275">  if (*params-&gt;p_icc_profile)</a>
<a name="ln276">  {</a>
<a name="ln277">    const dt_colorspaces_color_profile_t *pprof = dt_colorspaces_get_profile(params-&gt;p_icc_type, params-&gt;p_icc_profile,</a>
<a name="ln278">                                                                             DT_PROFILE_DIRECTION_OUT);</a>
<a name="ln279">    if (!pprof)</a>
<a name="ln280">    {</a>
<a name="ln281">      dt_control_log(_(&quot;cannot open printer profile `%s'&quot;), params-&gt;p_icc_profile);</a>
<a name="ln282">      fprintf(stderr, &quot;cannot open printer profile `%s'\n&quot;, params-&gt;p_icc_profile);</a>
<a name="ln283">      dt_control_queue_redraw();</a>
<a name="ln284">      return 1;</a>
<a name="ln285">    }</a>
<a name="ln286">    else</a>
<a name="ln287">    {</a>
<a name="ln288">      if(!buf_profile || !buf_profile-&gt;profile)</a>
<a name="ln289">      {</a>
<a name="ln290">        dt_control_log(_(&quot;error getting output profile for image %d&quot;), params-&gt;imgid);</a>
<a name="ln291">        fprintf(stderr, &quot;error getting output profile for image %d\n&quot;, params-&gt;imgid);</a>
<a name="ln292">        dt_control_queue_redraw();</a>
<a name="ln293">        return 1;</a>
<a name="ln294">      }</a>
<a name="ln295">      if (dt_apply_printer_profile((void **)&amp;(params-&gt;buf), dat.width, dat.height, dat.bpp, buf_profile-&gt;profile,</a>
<a name="ln296">                                   pprof-&gt;profile, params-&gt;p_icc_intent, params-&gt;black_point_compensation))</a>
<a name="ln297">      {</a>
<a name="ln298">        dt_control_log(_(&quot;cannot apply printer profile `%s'&quot;), params-&gt;p_icc_profile);</a>
<a name="ln299">        fprintf(stderr, &quot;cannot apply printer profile `%s'\n&quot;, params-&gt;p_icc_profile);</a>
<a name="ln300">        dt_control_queue_redraw();</a>
<a name="ln301">        return 1;</a>
<a name="ln302">      }</a>
<a name="ln303">    }</a>
<a name="ln304">  }</a>
<a name="ln305"> </a>
<a name="ln306">  const float page_width  = dt_pdf_mm_to_point(width);</a>
<a name="ln307">  const float page_height = dt_pdf_mm_to_point(height);</a>
<a name="ln308"> </a>
<a name="ln309">  if(dt_control_job_get_state(job) == DT_JOB_STATE_CANCELLED) return 0;</a>
<a name="ln310">  dt_control_job_set_progress(job, 0.9);</a>
<a name="ln311"> </a>
<a name="ln312">  dt_loc_get_tmp_dir(params-&gt;pdf_filename, sizeof(params-&gt;pdf_filename));</a>
<a name="ln313">  g_strlcat(params-&gt;pdf_filename, &quot;/pf.XXXXXX.pdf&quot;, sizeof(params-&gt;pdf_filename));</a>
<a name="ln314"> </a>
<a name="ln315">  gint fd = g_mkstemp(params-&gt;pdf_filename);</a>
<a name="ln316">  if(fd == -1)</a>
<a name="ln317">  {</a>
<a name="ln318">    dt_control_log(_(&quot;failed to create temporary pdf for printing&quot;));</a>
<a name="ln319">    fprintf(stderr, &quot;failed to create temporary pdf for printing\n&quot;);</a>
<a name="ln320">    return 1;</a>
<a name="ln321">  }</a>
<a name="ln322">  close(fd);</a>
<a name="ln323"> </a>
<a name="ln324">  const int icc_id = 0;</a>
<a name="ln325"> </a>
<a name="ln326">  dt_pdf_t *pdf = dt_pdf_start(params-&gt;pdf_filename, page_width, page_height, params-&gt;prt.printer.resolution, DT_PDF_STREAM_ENCODER_FLATE);</a>
<a name="ln327"> </a>
<a name="ln328">/*</a>
<a name="ln329">  // ??? should a profile be embedded here?</a>
<a name="ln330">  if (*printer_profile)</a>
<a name="ln331">    icc_id = dt_pdf_add_icc(pdf, printer_profile);</a>
<a name="ln332">*/</a>
<a name="ln333">  params-&gt;pdf_image = dt_pdf_add_image(pdf, (uint8_t *)params-&gt;buf, dat.width, dat.height, 8, icc_id, 0.0);</a>
<a name="ln334"> </a>
<a name="ln335">  //  PDF bounding-box has origin on bottom-left</a>
<a name="ln336">  params-&gt;pdf_image-&gt;bb_x      = dt_pdf_pixel_to_point((float)margin_left, params-&gt;prt.printer.resolution);</a>
<a name="ln337">  params-&gt;pdf_image-&gt;bb_y      = dt_pdf_pixel_to_point((float)margin_bottom, params-&gt;prt.printer.resolution);</a>
<a name="ln338">  params-&gt;pdf_image-&gt;bb_width  = dt_pdf_pixel_to_point((float)iwidth, params-&gt;prt.printer.resolution);</a>
<a name="ln339">  params-&gt;pdf_image-&gt;bb_height = dt_pdf_pixel_to_point((float)iheight, params-&gt;prt.printer.resolution);</a>
<a name="ln340"> </a>
<a name="ln341">  if (params-&gt;prt.page.landscape &amp;&amp; (dat.width &gt; dat.height))</a>
<a name="ln342">    params-&gt;pdf_image-&gt;rotate_to_fit = TRUE;</a>
<a name="ln343">  else</a>
<a name="ln344">    params-&gt;pdf_image-&gt;rotate_to_fit = FALSE;</a>
<a name="ln345"> </a>
<a name="ln346">  params-&gt;pdf_page = dt_pdf_add_page(pdf, &amp;params-&gt;pdf_image, 1);</a>
<a name="ln347">  dt_pdf_finish(pdf, &amp;params-&gt;pdf_page, 1);</a>
<a name="ln348"> </a>
<a name="ln349">  if(dt_control_job_get_state(job) == DT_JOB_STATE_CANCELLED) return 0;</a>
<a name="ln350">  dt_control_job_set_progress(job, 0.95);</a>
<a name="ln351"> </a>
<a name="ln352">  // send to CUPS</a>
<a name="ln353"> </a>
<a name="ln354">  dt_print_file (params-&gt;imgid, params-&gt;pdf_filename, params-&gt;job_title, &amp;params-&gt;prt);</a>
<a name="ln355">  dt_control_job_set_progress(job, 1.0);</a>
<a name="ln356"> </a>
<a name="ln357">  // add tag for this image</a>
<a name="ln358"> </a>
<a name="ln359">  char tag[256] = { 0 };</a>
<a name="ln360">  guint tagid = 0;</a>
<a name="ln361">  snprintf (tag, sizeof(tag), &quot;darktable|printed|%s&quot;, params-&gt;prt.printer.name);</a>
<a name="ln362">  dt_tag_new(tag, &amp;tagid);</a>
<a name="ln363">  dt_tag_attach(tagid, params-&gt;imgid);</a>
<a name="ln364"> </a>
<a name="ln365">  return 0;</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">static void _print_job_cleanup(void *p)</a>
<a name="ln369">{</a>
<a name="ln370">  dt_lib_print_job_t *params = p;</a>
<a name="ln371">  if(params-&gt;pdf_filename[0]) g_unlink(params-&gt;pdf_filename);</a>
<a name="ln372">  free(params-&gt;pdf_image);</a>
<a name="ln373">  free(params-&gt;pdf_page);</a>
<a name="ln374">  free(params-&gt;buf);</a>
<a name="ln375">  g_free(params-&gt;style);</a>
<a name="ln376">  g_free(params-&gt;buf_icc_profile);</a>
<a name="ln377">  g_free(params-&gt;p_icc_profile);</a>
<a name="ln378">  g_free(params-&gt;job_title);</a>
<a name="ln379">  free(params);</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">static void</a>
<a name="ln383">_print_button_clicked (GtkWidget *widget, gpointer user_data)</a>
<a name="ln384">{</a>
<a name="ln385">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln386">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln387"> </a>
<a name="ln388">  const int imgid = dt_view_filmstrip_get_activated_imgid(darktable.view_manager);</a>
<a name="ln389"> </a>
<a name="ln390">  if (imgid == -1)</a>
<a name="ln391">  {</a>
<a name="ln392">    dt_control_log(_(&quot;cannot print until a picture is selected&quot;));</a>
<a name="ln393">    return;</a>
<a name="ln394">  }</a>
<a name="ln395">  if (strlen(ps-&gt;prt.printer.name) == 0 || ps-&gt;prt.printer.resolution == 0)</a>
<a name="ln396">  {</a>
<a name="ln397">    dt_control_log(_(&quot;cannot print until a printer is selected&quot;));</a>
<a name="ln398">    return;</a>
<a name="ln399">  }</a>
<a name="ln400">  if (ps-&gt;prt.paper.width == 0 || ps-&gt;prt.paper.height == 0)</a>
<a name="ln401">  {</a>
<a name="ln402">    dt_control_log(_(&quot;cannot print until a paper is selected&quot;));</a>
<a name="ln403">    return;</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  dt_job_t *job = dt_control_job_create(&amp;_print_job_run, &quot;print image %d&quot;, imgid);</a>
<a name="ln407">  if(!job) return;</a>
<a name="ln408"> </a>
<a name="ln409">  dt_lib_print_job_t *params = calloc(1, sizeof(dt_lib_print_job_t));</a>
<a name="ln410">  dt_control_job_set_params(job, params, _print_job_cleanup);</a>
<a name="ln411"> </a>
<a name="ln412">  params-&gt;imgid = imgid;</a>
<a name="ln413">  memcpy(&amp;params-&gt;prt, &amp;ps-&gt;prt, sizeof(dt_print_info_t));</a>
<a name="ln414"> </a>
<a name="ln415">  // what to call the image?</a>
<a name="ln416">  GList *res;</a>
<a name="ln417">  if((res = dt_metadata_get(params-&gt;imgid, &quot;Xmp.dc.title&quot;, NULL)) != NULL)</a>
<a name="ln418">  {</a>
<a name="ln419">    // FIXME: in metadata_view.c, non-printables are filtered, should we do this here?</a>
<a name="ln420">    params-&gt;job_title = g_strdup((gchar *)res-&gt;data);</a>
<a name="ln421">    g_list_free_full(res, &amp;g_free);</a>
<a name="ln422">  }</a>
<a name="ln423">  else</a>
<a name="ln424">  {</a>
<a name="ln425">    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, params-&gt;imgid, 'r');</a>
<a name="ln426">    if(!img)</a>
<a name="ln427">    {</a>
<a name="ln428">      // in this case no need to release from cache what we couldn't get</a>
<a name="ln429">      dt_control_log(_(&quot;cannot get image %d for printing&quot;), imgid);</a>
<a name="ln430">      dt_control_job_dispose(job);</a>
<a name="ln431">      return;</a>
<a name="ln432">    }</a>
<a name="ln433">    params-&gt;job_title = g_strdup(img-&gt;filename);</a>
<a name="ln434">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln435">  }</a>
<a name="ln436">  // FIXME: ellipsize title/printer as the export completed message is ellipsized</a>
<a name="ln437">  gchar *message = g_strdup_printf(_(&quot;processing `%s' for `%s'&quot;), params-&gt;job_title, params-&gt;prt.printer.name);</a>
<a name="ln438">  dt_control_job_add_progress(job, message, TRUE);</a>
<a name="ln439">  g_free(message);</a>
<a name="ln440"> </a>
<a name="ln441">  // FIXME: getting this from conf as w/prior code, but switch to getting from ps</a>
<a name="ln442">  params-&gt;style = dt_conf_get_string(&quot;plugins/print/print/style&quot;);</a>
<a name="ln443">  params-&gt;style_append = ps-&gt;v_style_append;</a>
<a name="ln444"> </a>
<a name="ln445">  // FIXME: getting these from conf as w/prior code, but switch to getting them from ps</a>
<a name="ln446">  params-&gt;buf_icc_type = dt_conf_get_int(&quot;plugins/print/print/icctype&quot;);</a>
<a name="ln447">  params-&gt;buf_icc_profile = dt_conf_get_string(&quot;plugins/print/print/iccprofile&quot;);</a>
<a name="ln448">  params-&gt;buf_icc_intent = dt_conf_get_int(&quot;plugins/print/print/iccintent&quot;);</a>
<a name="ln449"> </a>
<a name="ln450">  params-&gt;p_icc_type = ps-&gt;v_picctype;</a>
<a name="ln451">  params-&gt;p_icc_profile = g_strdup(ps-&gt;v_piccprofile);</a>
<a name="ln452">  params-&gt;p_icc_intent = ps-&gt;v_pintent;</a>
<a name="ln453">  params-&gt;black_point_compensation = ps-&gt;v_black_point_compensation;</a>
<a name="ln454"> </a>
<a name="ln455">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_EXPORT, job);</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">static void _set_printer(const dt_lib_module_t *self, const char *printer_name)</a>
<a name="ln459">{</a>
<a name="ln460">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln461"> </a>
<a name="ln462">  dt_get_printer_info (printer_name, &amp;ps-&gt;prt.printer);</a>
<a name="ln463"> </a>
<a name="ln464">  // if this is a turboprint printer, disable the printer profile</a>
<a name="ln465"> </a>
<a name="ln466">  if (ps-&gt;prt.printer.is_turboprint)</a>
<a name="ln467">    dt_bauhaus_combobox_set(ps-&gt;pprofile, 0);</a>
<a name="ln468"> </a>
<a name="ln469">  // if there is 0 hardware margins, set the user margin to 17mm</a>
<a name="ln470"> </a>
<a name="ln471">  if (ps-&gt;prt.printer.hw_margin_top == 0)</a>
<a name="ln472">  {</a>
<a name="ln473">    ps-&gt;prt.page.margin_top = 17;</a>
<a name="ln474">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_top), ps-&gt;prt.page.margin_top * units[ps-&gt;unit]);</a>
<a name="ln475">  }</a>
<a name="ln476">  if (ps-&gt;prt.printer.hw_margin_bottom == 0)</a>
<a name="ln477">  {</a>
<a name="ln478">    ps-&gt;prt.page.margin_bottom = 17;</a>
<a name="ln479">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), ps-&gt;prt.page.margin_bottom * units[ps-&gt;unit]);</a>
<a name="ln480">  }</a>
<a name="ln481">  if (ps-&gt;prt.printer.hw_margin_left == 0)</a>
<a name="ln482">  {</a>
<a name="ln483">    ps-&gt;prt.page.margin_left = 17;</a>
<a name="ln484">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left), ps-&gt;prt.page.margin_left * units[ps-&gt;unit]);</a>
<a name="ln485">  }</a>
<a name="ln486">  if (ps-&gt;prt.printer.hw_margin_right == 0)</a>
<a name="ln487">  {</a>
<a name="ln488">    ps-&gt;prt.page.margin_right = 17;</a>
<a name="ln489">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right), ps-&gt;prt.page.margin_right * units[ps-&gt;unit]);</a>
<a name="ln490">  }</a>
<a name="ln491"> </a>
<a name="ln492">  dt_conf_set_string(&quot;plugins/print/print/printer&quot;, printer_name);</a>
<a name="ln493"> </a>
<a name="ln494">  char *default_paper = dt_conf_get_string(&quot;plugins/print/print/paper&quot;);</a>
<a name="ln495"> </a>
<a name="ln496">  // next add corresponding papers</a>
<a name="ln497"> </a>
<a name="ln498">  // first clear current list</a>
<a name="ln499"> </a>
<a name="ln500">  dt_bauhaus_combobox_clear(ps-&gt;papers);</a>
<a name="ln501"> </a>
<a name="ln502">  // then add papers for the given printer</a>
<a name="ln503"> </a>
<a name="ln504">  if(ps-&gt;paper_list) g_list_free_full(ps-&gt;paper_list, free);</a>
<a name="ln505"> </a>
<a name="ln506">  ps-&gt;paper_list = dt_get_papers (&amp;ps-&gt;prt.printer);</a>
<a name="ln507">  GList *papers = ps-&gt;paper_list;</a>
<a name="ln508">  int np = 0;</a>
<a name="ln509">  gboolean ispaperset = FALSE;</a>
<a name="ln510"> </a>
<a name="ln511">  while (papers)</a>
<a name="ln512">  {</a>
<a name="ln513">    const dt_paper_info_t *p = (dt_paper_info_t *)papers-&gt;data;</a>
<a name="ln514">    dt_bauhaus_combobox_add(ps-&gt;papers, p-&gt;common_name);</a>
<a name="ln515"> </a>
<a name="ln516">    if (ispaperset == FALSE &amp;&amp; (!g_strcmp0(default_paper, p-&gt;common_name) || default_paper[0] == '\0'))</a>
<a name="ln517">    {</a>
<a name="ln518">      dt_bauhaus_combobox_set(ps-&gt;papers, np);</a>
<a name="ln519">      ispaperset = TRUE;</a>
<a name="ln520">    }</a>
<a name="ln521"> </a>
<a name="ln522">    np++;</a>
<a name="ln523">    papers = g_list_next (papers);</a>
<a name="ln524">  }</a>
<a name="ln525"> </a>
<a name="ln526">  //  paper not found in this printer</a>
<a name="ln527">  if (!ispaperset) dt_bauhaus_combobox_set(ps-&gt;papers, 0);</a>
<a name="ln528"> </a>
<a name="ln529">  const dt_paper_info_t *paper = dt_get_paper(ps-&gt;paper_list, default_paper);</a>
<a name="ln530"> </a>
<a name="ln531">  if (paper)</a>
<a name="ln532">    memcpy(&amp;ps-&gt;prt.paper, paper, sizeof(dt_paper_info_t));</a>
<a name="ln533"> </a>
<a name="ln534">  g_free (default_paper);</a>
<a name="ln535"> </a>
<a name="ln536">  // next add corresponding supported media</a>
<a name="ln537"> </a>
<a name="ln538">  char *default_medium = dt_conf_get_string(&quot;plugins/print/print/medium&quot;);</a>
<a name="ln539"> </a>
<a name="ln540">  // first clear current list</a>
<a name="ln541"> </a>
<a name="ln542">  dt_bauhaus_combobox_clear(ps-&gt;media);</a>
<a name="ln543"> </a>
<a name="ln544">  // then add papers for the given printer</a>
<a name="ln545"> </a>
<a name="ln546">  if(ps-&gt;media_list) g_list_free_full(ps-&gt;media_list, free);</a>
<a name="ln547"> </a>
<a name="ln548">  ps-&gt;media_list = dt_get_media_type (&amp;ps-&gt;prt.printer);</a>
<a name="ln549">  GList *media = ps-&gt;media_list;</a>
<a name="ln550">  gboolean ismediaset = FALSE;</a>
<a name="ln551"> </a>
<a name="ln552">  np = 0;</a>
<a name="ln553"> </a>
<a name="ln554">  while (media)</a>
<a name="ln555">  {</a>
<a name="ln556">    const dt_medium_info_t *m = (dt_medium_info_t *)media-&gt;data;</a>
<a name="ln557">    dt_bauhaus_combobox_add(ps-&gt;media, m-&gt;common_name);</a>
<a name="ln558"> </a>
<a name="ln559">    if (ismediaset == FALSE &amp;&amp; (!g_strcmp0(default_medium, m-&gt;common_name) || default_medium[0] == '\0'))</a>
<a name="ln560">    {</a>
<a name="ln561">      dt_bauhaus_combobox_set(ps-&gt;media, np);</a>
<a name="ln562">      ismediaset = TRUE;</a>
<a name="ln563">    }</a>
<a name="ln564"> </a>
<a name="ln565">    np++;</a>
<a name="ln566">    media = g_list_next (media);</a>
<a name="ln567">  }</a>
<a name="ln568"> </a>
<a name="ln569">  //  media not found in this printer</a>
<a name="ln570">  if (!ismediaset) dt_bauhaus_combobox_set(ps-&gt;media, 0);</a>
<a name="ln571"> </a>
<a name="ln572">  const dt_medium_info_t *medium = dt_get_medium(ps-&gt;media_list, default_medium);</a>
<a name="ln573"> </a>
<a name="ln574">  if (medium)</a>
<a name="ln575">    memcpy(&amp;ps-&gt;prt.medium, medium, sizeof(dt_medium_info_t));</a>
<a name="ln576"> </a>
<a name="ln577">  g_free (default_medium);</a>
<a name="ln578"> </a>
<a name="ln579">  dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">static void</a>
<a name="ln583">_printer_changed (GtkWidget *combo, const dt_lib_module_t *self)</a>
<a name="ln584">{</a>
<a name="ln585">  const gchar *printer_name = dt_bauhaus_combobox_get_text(combo);</a>
<a name="ln586"> </a>
<a name="ln587">  if (printer_name)</a>
<a name="ln588">    _set_printer (self, printer_name);</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">static void</a>
<a name="ln592">_paper_changed (GtkWidget *combo, const dt_lib_module_t *self)</a>
<a name="ln593">{</a>
<a name="ln594">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln595"> </a>
<a name="ln596">  const gchar *paper_name = dt_bauhaus_combobox_get_text(combo);</a>
<a name="ln597"> </a>
<a name="ln598">  if (!paper_name) return;</a>
<a name="ln599"> </a>
<a name="ln600">  const dt_paper_info_t *paper = dt_get_paper(ps-&gt;paper_list, paper_name);</a>
<a name="ln601"> </a>
<a name="ln602">  if (paper)</a>
<a name="ln603">    memcpy(&amp;ps-&gt;prt.paper, paper, sizeof(dt_paper_info_t));</a>
<a name="ln604"> </a>
<a name="ln605">  ps-&gt;iwidth = ps-&gt;iheight = 0;</a>
<a name="ln606"> </a>
<a name="ln607">  dt_conf_set_string(&quot;plugins/print/print/paper&quot;, paper_name);</a>
<a name="ln608">  dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln609"> </a>
<a name="ln610">  _update_slider(ps);</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">static void</a>
<a name="ln614">_media_changed (GtkWidget *combo, const dt_lib_module_t *self)</a>
<a name="ln615">{</a>
<a name="ln616">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln617"> </a>
<a name="ln618">  const gchar *medium_name = dt_bauhaus_combobox_get_text(combo);</a>
<a name="ln619"> </a>
<a name="ln620">  if (!medium_name) return;</a>
<a name="ln621"> </a>
<a name="ln622">  const dt_medium_info_t *medium = dt_get_medium(ps-&gt;media_list, medium_name);</a>
<a name="ln623"> </a>
<a name="ln624">  if (medium)</a>
<a name="ln625">    memcpy(&amp;ps-&gt;prt.medium, medium, sizeof(dt_medium_info_t));</a>
<a name="ln626"> </a>
<a name="ln627">  dt_conf_set_string(&quot;plugins/print/print/medium&quot;, medium_name);</a>
<a name="ln628">  dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln629"> </a>
<a name="ln630">  _update_slider(ps);</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">static double to_mm(dt_lib_print_settings_t *ps, double value)</a>
<a name="ln634">{</a>
<a name="ln635">  return value / units[ps-&gt;unit];</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">static void</a>
<a name="ln639">_update_slider (dt_lib_print_settings_t *ps)</a>
<a name="ln640">{</a>
<a name="ln641">  dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln642"> </a>
<a name="ln643">  // if widget are created, let's display the current image size</a>
<a name="ln644"> </a>
<a name="ln645">  if (ps-&gt;image_id != -1 &amp;&amp; ps-&gt;width &amp;&amp; ps-&gt;height &amp;&amp; ps-&gt;info)</a>
<a name="ln646">  {</a>
<a name="ln647">    int32_t px=0, py=0, pwidth=0, pheight=0;</a>
<a name="ln648">    int32_t ax=0, ay=0, awidth=0, aheight=0;</a>
<a name="ln649">    int32_t ix=0, iy=0, iwidth=0, iheight=0;</a>
<a name="ln650">    int32_t iwpix=ps-&gt;iwidth, ihpix=ps-&gt;iheight;</a>
<a name="ln651">    int32_t pa_width, pa_height;</a>
<a name="ln652"> </a>
<a name="ln653">    if (ps-&gt;prt.page.landscape)</a>
<a name="ln654">    {</a>
<a name="ln655">      pa_height = (int32_t)ps-&gt;prt.paper.width;</a>
<a name="ln656">      pa_width = (int32_t)ps-&gt;prt.paper.height;</a>
<a name="ln657">    }</a>
<a name="ln658">    else</a>
<a name="ln659">    {</a>
<a name="ln660">      pa_width = (int32_t)ps-&gt;prt.paper.width;</a>
<a name="ln661">      pa_height = (int32_t)ps-&gt;prt.paper.height;</a>
<a name="ln662">    }</a>
<a name="ln663"> </a>
<a name="ln664">    dt_get_print_layout(ps-&gt;image_id, &amp;ps-&gt;prt, pa_width, pa_height,</a>
<a name="ln665">                        &amp;iwpix, &amp;ihpix,</a>
<a name="ln666">                        &amp;px, &amp;py, &amp;pwidth, &amp;pheight,</a>
<a name="ln667">                        &amp;ax, &amp;ay, &amp;awidth, &amp;aheight,</a>
<a name="ln668">                        &amp;ix, &amp;iy, &amp;iwidth, &amp;iheight);</a>
<a name="ln669"> </a>
<a name="ln670">    if (ps-&gt;iwidth==0 || ps-&gt;iheight==0)</a>
<a name="ln671">    {</a>
<a name="ln672">      ps-&gt;iwidth = iwpix;</a>
<a name="ln673">      ps-&gt;iheight = ihpix;</a>
<a name="ln674">    }</a>
<a name="ln675"> </a>
<a name="ln676">    const double h = iheight * units[ps-&gt;unit];</a>
<a name="ln677">    const double w = iwidth * units[ps-&gt;unit];</a>
<a name="ln678">    char *value;</a>
<a name="ln679"> </a>
<a name="ln680">    value = g_strdup_printf(&quot;%3.2f&quot;, w);</a>
<a name="ln681">    gtk_label_set_text(GTK_LABEL(ps-&gt;width), value);</a>
<a name="ln682">    g_free(value);</a>
<a name="ln683"> </a>
<a name="ln684">    value = g_strdup_printf(&quot;%3.2f&quot;, h);</a>
<a name="ln685">    gtk_label_set_text(GTK_LABEL(ps-&gt;height), value);</a>
<a name="ln686">    g_free(value);</a>
<a name="ln687"> </a>
<a name="ln688">    // compute the image down/up scale and report information</a>
<a name="ln689">    double scale;</a>
<a name="ln690"> </a>
<a name="ln691">    if (iwidth &gt;= awidth)</a>
<a name="ln692">      scale = dt_pdf_point_to_pixel(dt_pdf_mm_to_point((double)awidth), ps-&gt;prt.printer.resolution) / ps-&gt;iwidth;</a>
<a name="ln693">    else</a>
<a name="ln694">      scale = dt_pdf_point_to_pixel(dt_pdf_mm_to_point((double)aheight), ps-&gt;prt.printer.resolution) / ps-&gt;iheight;</a>
<a name="ln695"> </a>
<a name="ln696">    value = g_strdup_printf(_(&quot;%3.2f (dpi:%d)&quot;), scale, scale&lt;=1.0 ? (int)ps-&gt;prt.printer.resolution : (int)(ps-&gt;prt.printer.resolution / scale));</a>
<a name="ln697">    gtk_label_set_text(GTK_LABEL(ps-&gt;info), value);</a>
<a name="ln698">    g_free(value);</a>
<a name="ln699">  }</a>
<a name="ln700"> </a>
<a name="ln701">  // set the max range for the borders depending on the others border and never allow to have an image size of 0 or less</a>
<a name="ln702">  const int min_size = 5; // minimum size in mm</a>
<a name="ln703">  const int pa_max_height = ps-&gt;prt.paper.height - ps-&gt;prt.printer.hw_margin_top - ps-&gt;prt.printer.hw_margin_bottom - min_size;</a>
<a name="ln704">  const int pa_max_width  = ps-&gt;prt.paper.width  - ps-&gt;prt.printer.hw_margin_left - ps-&gt;prt.printer.hw_margin_right - min_size;</a>
<a name="ln705"> </a>
<a name="ln706">  gtk_spin_button_set_range (GTK_SPIN_BUTTON(ps-&gt;b_top),</a>
<a name="ln707">                             min_borders * units[ps-&gt;unit], (pa_max_height - ps-&gt;prt.page.margin_bottom) * units[ps-&gt;unit]);</a>
<a name="ln708">  gtk_spin_button_set_range (GTK_SPIN_BUTTON(ps-&gt;b_left),</a>
<a name="ln709">                             min_borders * units[ps-&gt;unit], (pa_max_width - ps-&gt;prt.page.margin_right) * units[ps-&gt;unit]);</a>
<a name="ln710">  gtk_spin_button_set_range (GTK_SPIN_BUTTON(ps-&gt;b_right),</a>
<a name="ln711">                             min_borders * units[ps-&gt;unit], (pa_max_width - ps-&gt;prt.page.margin_left) * units[ps-&gt;unit]);</a>
<a name="ln712">  gtk_spin_button_set_range (GTK_SPIN_BUTTON(ps-&gt;b_bottom),</a>
<a name="ln713">                             min_borders * units[ps-&gt;unit], (pa_max_height - ps-&gt;prt.page.margin_top) * units[ps-&gt;unit]);</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">static void</a>
<a name="ln717">_top_border_callback (GtkWidget *spin, gpointer user_data)</a>
<a name="ln718">{</a>
<a name="ln719">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln720">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln721">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(spin));</a>
<a name="ln722"> </a>
<a name="ln723">  ps-&gt;prt.page.margin_top = to_mm(ps, value);</a>
<a name="ln724"> </a>
<a name="ln725">  if (ps-&gt;lock_activated == TRUE)</a>
<a name="ln726">  {</a>
<a name="ln727">    ps-&gt;prt.page.margin_bottom = to_mm(ps, value);</a>
<a name="ln728">    ps-&gt;prt.page.margin_left = to_mm(ps, value);</a>
<a name="ln729">    ps-&gt;prt.page.margin_right = to_mm(ps, value);</a>
<a name="ln730"> </a>
<a name="ln731">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), value);</a>
<a name="ln732">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left), value);</a>
<a name="ln733">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right), value);</a>
<a name="ln734">  }</a>
<a name="ln735"> </a>
<a name="ln736">  _update_slider (ps);</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">static void</a>
<a name="ln740">_bottom_border_callback (GtkWidget *spin, gpointer user_data)</a>
<a name="ln741">{</a>
<a name="ln742">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln743">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln744">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(spin));</a>
<a name="ln745"> </a>
<a name="ln746">  ps-&gt;prt.page.margin_bottom = to_mm(ps, value);</a>
<a name="ln747">  _update_slider (ps);</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">static void</a>
<a name="ln751">_left_border_callback (GtkWidget *spin, gpointer user_data)</a>
<a name="ln752">{</a>
<a name="ln753">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln754">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln755">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(spin));</a>
<a name="ln756"> </a>
<a name="ln757">  ps-&gt;prt.page.margin_left = to_mm(ps, value);</a>
<a name="ln758">  _update_slider (ps);</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">static void</a>
<a name="ln762">_right_border_callback (GtkWidget *spin, gpointer user_data)</a>
<a name="ln763">{</a>
<a name="ln764">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln765">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln766">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(spin));</a>
<a name="ln767"> </a>
<a name="ln768">  ps-&gt;prt.page.margin_right = to_mm(ps, value);</a>
<a name="ln769">  _update_slider (ps);</a>
<a name="ln770">}</a>
<a name="ln771"> </a>
<a name="ln772">static void</a>
<a name="ln773">_lock_callback (GtkWidget *button, gpointer user_data)</a>
<a name="ln774">{</a>
<a name="ln775">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln776">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln777"> </a>
<a name="ln778">  ps-&gt;lock_activated = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button));</a>
<a name="ln779"> </a>
<a name="ln780">  dt_conf_set_bool(&quot;plugins/print/print/lock_borders&quot;, ps-&gt;lock_activated);</a>
<a name="ln781"> </a>
<a name="ln782">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;b_bottom), !ps-&gt;lock_activated);</a>
<a name="ln783">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;b_left), !ps-&gt;lock_activated);</a>
<a name="ln784">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;b_right), !ps-&gt;lock_activated);</a>
<a name="ln785"> </a>
<a name="ln786">  //  get value of top and set it to all other borders</a>
<a name="ln787"> </a>
<a name="ln788">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(ps-&gt;b_top));</a>
<a name="ln789">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), value);</a>
<a name="ln790">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left), value);</a>
<a name="ln791">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right), value);</a>
<a name="ln792"> </a>
<a name="ln793">  _update_slider (ps);</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">static void</a>
<a name="ln797">_alignment_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln798">{</a>
<a name="ln799">  int index=-1;</a>
<a name="ln800">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln801">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln802"> </a>
<a name="ln803">  for(int i=0; i&lt;9; i++)</a>
<a name="ln804">  {</a>
<a name="ln805">    /* block signal handler */</a>
<a name="ln806">    g_signal_handlers_block_by_func (ps-&gt;dtba[i],_alignment_callback,user_data);</a>
<a name="ln807"> </a>
<a name="ln808">    if( GTK_WIDGET(ps-&gt;dtba[i]) == tb )</a>
<a name="ln809">    {</a>
<a name="ln810">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;dtba[i]),TRUE);</a>
<a name="ln811">      index=i;</a>
<a name="ln812">    }</a>
<a name="ln813">    else gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;dtba[i]),FALSE);</a>
<a name="ln814"> </a>
<a name="ln815">    /* unblock signal handler */</a>
<a name="ln816">    g_signal_handlers_unblock_by_func (ps-&gt;dtba[i],_alignment_callback,user_data);</a>
<a name="ln817">  }</a>
<a name="ln818">  ps-&gt;prt.page.alignment = index;</a>
<a name="ln819">  _update_slider (ps);</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">static void</a>
<a name="ln823">_orientation_changed (GtkWidget *combo, dt_lib_module_t *self)</a>
<a name="ln824">{</a>
<a name="ln825">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln826"> </a>
<a name="ln827">  ps-&gt;prt.page.landscape = dt_bauhaus_combobox_get (combo);</a>
<a name="ln828"> </a>
<a name="ln829">  _update_slider (ps);</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">static void</a>
<a name="ln833">_unit_changed (GtkWidget *combo, dt_lib_module_t *self)</a>
<a name="ln834">{</a>
<a name="ln835">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln836"> </a>
<a name="ln837">  int unit = dt_bauhaus_combobox_get(combo);</a>
<a name="ln838">  if(unit &lt; 0) return; // shouldn't happen, but it could be -1 if nothing is selected</a>
<a name="ln839">  ps-&gt;unit = unit;</a>
<a name="ln840">  dt_conf_set_int(&quot;plugins/print/print/unit&quot;, ps-&gt;unit);</a>
<a name="ln841"> </a>
<a name="ln842">  const double margin_top = ps-&gt;prt.page.margin_top;</a>
<a name="ln843">  const double margin_left = ps-&gt;prt.page.margin_left;</a>
<a name="ln844">  const double margin_right = ps-&gt;prt.page.margin_right;</a>
<a name="ln845">  const double margin_bottom = ps-&gt;prt.page.margin_bottom;</a>
<a name="ln846"> </a>
<a name="ln847">  const int n_digits = (int)(1.0 / (units[ps-&gt;unit] * 10.0));</a>
<a name="ln848"> </a>
<a name="ln849">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(ps-&gt;b_top),    n_digits);</a>
<a name="ln850">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(ps-&gt;b_bottom), n_digits);</a>
<a name="ln851">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(ps-&gt;b_left),   n_digits);</a>
<a name="ln852">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(ps-&gt;b_right),  n_digits);</a>
<a name="ln853"> </a>
<a name="ln854">  const float incr = units[ps-&gt;unit];</a>
<a name="ln855"> </a>
<a name="ln856">  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(ps-&gt;b_top), incr, incr);</a>
<a name="ln857">  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(ps-&gt;b_bottom), incr, incr);</a>
<a name="ln858">  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(ps-&gt;b_left), incr, incr);</a>
<a name="ln859">  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(ps-&gt;b_right), incr, incr);</a>
<a name="ln860"> </a>
<a name="ln861">  _update_slider (ps);</a>
<a name="ln862"> </a>
<a name="ln863">  // convert margins to new unit</a>
<a name="ln864">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_top),    margin_top * units[ps-&gt;unit]);</a>
<a name="ln865">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), margin_bottom * units[ps-&gt;unit]);</a>
<a name="ln866">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left),   margin_left * units[ps-&gt;unit]);</a>
<a name="ln867">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right),  margin_right * units[ps-&gt;unit]);</a>
<a name="ln868"> </a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871">static void</a>
<a name="ln872">_style_callback(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln873">{</a>
<a name="ln874">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln875"> </a>
<a name="ln876">  if(dt_bauhaus_combobox_get(ps-&gt;style) == 0)</a>
<a name="ln877">  {</a>
<a name="ln878">    dt_conf_set_string(&quot;plugins/print/print/style&quot;, &quot;&quot;);</a>
<a name="ln879">    gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;style_mode), FALSE);</a>
<a name="ln880">  }</a>
<a name="ln881">  else</a>
<a name="ln882">  {</a>
<a name="ln883">    const gchar *style = dt_bauhaus_combobox_get_text(ps-&gt;style);</a>
<a name="ln884">    dt_conf_set_string(&quot;plugins/print/print/style&quot;, style);</a>
<a name="ln885">    gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;style_mode), TRUE);</a>
<a name="ln886">  }</a>
<a name="ln887"> </a>
<a name="ln888">  g_free(ps-&gt;v_style);</a>
<a name="ln889">  ps-&gt;v_style = dt_conf_get_string(&quot;plugins/print/print/style&quot;);</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892">static void</a>
<a name="ln893">_style_mode_changed(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln894">{</a>
<a name="ln895">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln896"> </a>
<a name="ln897">  if(dt_bauhaus_combobox_get(ps-&gt;style_mode) == 0)</a>
<a name="ln898">    ps-&gt;v_style_append = FALSE;</a>
<a name="ln899">  else</a>
<a name="ln900">    ps-&gt;v_style_append = TRUE;</a>
<a name="ln901"> </a>
<a name="ln902">  dt_conf_set_bool(&quot;plugins/print/print/style_append&quot;, ps-&gt;v_style_append);</a>
<a name="ln903">}</a>
<a name="ln904"> </a>
<a name="ln905">static void</a>
<a name="ln906">_profile_changed(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln907">{</a>
<a name="ln908">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln909">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln910">  GList *prof = ps-&gt;profiles;</a>
<a name="ln911">  while(prof)</a>
<a name="ln912">  {</a>
<a name="ln913">    dt_lib_export_profile_t *pp = (dt_lib_export_profile_t *)prof-&gt;data;</a>
<a name="ln914">    if(pp-&gt;pos == pos)</a>
<a name="ln915">    {</a>
<a name="ln916">      dt_conf_set_int(&quot;plugins/print/print/icctype&quot;, pp-&gt;type);</a>
<a name="ln917">      dt_conf_set_string(&quot;plugins/print/print/iccprofile&quot;, pp-&gt;filename);</a>
<a name="ln918">      g_free(ps-&gt;v_iccprofile);</a>
<a name="ln919">      ps-&gt;v_icctype = pp-&gt;type;</a>
<a name="ln920">      ps-&gt;v_iccprofile = g_strdup(pp-&gt;filename);</a>
<a name="ln921">      return;</a>
<a name="ln922">    }</a>
<a name="ln923">    prof = g_list_next(prof);</a>
<a name="ln924">  }</a>
<a name="ln925">  dt_conf_set_int(&quot;plugins/print/print/icctype&quot;, DT_COLORSPACE_NONE);</a>
<a name="ln926">  dt_conf_set_string(&quot;plugins/print/print/iccprofile&quot;, &quot;&quot;);</a>
<a name="ln927">  g_free(ps-&gt;v_iccprofile);</a>
<a name="ln928">  ps-&gt;v_icctype = DT_COLORSPACE_NONE;</a>
<a name="ln929">  ps-&gt;v_iccprofile = g_strdup(&quot;&quot;);</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">static void</a>
<a name="ln933">_printer_profile_changed(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln934">{</a>
<a name="ln935">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln936">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln937">  GList *prof = ps-&gt;profiles;</a>
<a name="ln938">  while(prof)</a>
<a name="ln939">  {</a>
<a name="ln940">    dt_lib_export_profile_t *pp = (dt_lib_export_profile_t *)prof-&gt;data;</a>
<a name="ln941">    if(pp-&gt;ppos == pos)</a>
<a name="ln942">    {</a>
<a name="ln943">      dt_conf_set_int(&quot;plugins/print/printer/icctype&quot;, pp-&gt;type);</a>
<a name="ln944">      dt_conf_set_string(&quot;plugins/print/printer/iccprofile&quot;, pp-&gt;filename);</a>
<a name="ln945">      g_free(ps-&gt;v_piccprofile);</a>
<a name="ln946">      ps-&gt;v_picctype = pp-&gt;type;</a>
<a name="ln947">      ps-&gt;v_piccprofile = g_strdup(pp-&gt;filename);</a>
<a name="ln948"> </a>
<a name="ln949">      // activate the black compensation and printer intent</a>
<a name="ln950">      gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;black_point_compensation), TRUE);</a>
<a name="ln951">      return;</a>
<a name="ln952">    }</a>
<a name="ln953">    prof = g_list_next(prof);</a>
<a name="ln954">  }</a>
<a name="ln955">  dt_conf_set_int(&quot;plugins/print/printer/icctype&quot;, DT_COLORSPACE_NONE);</a>
<a name="ln956">  dt_conf_set_string(&quot;plugins/print/printer/iccprofile&quot;, &quot;&quot;);</a>
<a name="ln957">  g_free(ps-&gt;v_piccprofile);</a>
<a name="ln958">  ps-&gt;v_picctype = DT_COLORSPACE_NONE;</a>
<a name="ln959">  ps-&gt;v_piccprofile = g_strdup(&quot;&quot;);</a>
<a name="ln960">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;black_point_compensation), FALSE);</a>
<a name="ln961">}</a>
<a name="ln962"> </a>
<a name="ln963">static void</a>
<a name="ln964">_printer_intent_callback (GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln965">{</a>
<a name="ln966">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln967">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln968">  dt_conf_set_int(&quot;plugins/print/printer/iccintent&quot;, pos);</a>
<a name="ln969">  ps-&gt;v_pintent = pos;</a>
<a name="ln970">  ps-&gt;prt.printer.intent = pos;</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973">static void</a>
<a name="ln974">_printer_bpc_callback (GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln975">{</a>
<a name="ln976">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln977">  ps-&gt;v_black_point_compensation = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ps-&gt;black_point_compensation));</a>
<a name="ln978">  dt_conf_set_bool(&quot;plugins/print/print/black_point_compensation&quot;, ps-&gt;v_black_point_compensation);</a>
<a name="ln979">}</a>
<a name="ln980"> </a>
<a name="ln981">static void</a>
<a name="ln982">_intent_callback (GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln983">{</a>
<a name="ln984">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln985">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln986">  // record the intent that will override the out rendering module on export</a>
<a name="ln987">  dt_conf_set_int(&quot;plugins/print/print/iccintent&quot;, pos - 1);</a>
<a name="ln988">  ps-&gt;v_intent = pos - 1;</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991">static void _set_orientation(dt_lib_print_settings_t *ps)</a>
<a name="ln992">{</a>
<a name="ln993">  if (ps-&gt;image_id &lt;= 0)</a>
<a name="ln994">    return;</a>
<a name="ln995"> </a>
<a name="ln996">  dt_mipmap_buffer_t buf;</a>
<a name="ln997">  dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, ps-&gt;image_id, DT_MIPMAP_0, DT_MIPMAP_BEST_EFFORT, 'r');</a>
<a name="ln998"> </a>
<a name="ln999">  // If there's a mipmap available, figure out orientation based upon</a>
<a name="ln1000">  // its dimensions. Otherwise, don't touch orientation until the</a>
<a name="ln1001">  // mipmap arrives.</a>
<a name="ln1002">  if (buf.size != DT_MIPMAP_NONE)</a>
<a name="ln1003">  {</a>
<a name="ln1004">    ps-&gt;prt.page.landscape = (buf.width &gt; buf.height);</a>
<a name="ln1005">    dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln1006">    dt_bauhaus_combobox_set (ps-&gt;orientation, ps-&gt;prt.page.landscape==TRUE?1:0);</a>
<a name="ln1007">  }</a>
<a name="ln1008"> </a>
<a name="ln1009">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln1010">}</a>
<a name="ln1011"> </a>
<a name="ln1012">static void _print_settings_activate_or_update_callback(gpointer instance,gpointer user_data)</a>
<a name="ln1013">{</a>
<a name="ln1014">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1015">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1016"> </a>
<a name="ln1017">  ps-&gt;image_id = dt_view_filmstrip_get_activated_imgid(darktable.view_manager);</a>
<a name="ln1018">  ps-&gt;iwidth = ps-&gt;iheight = 0;</a>
<a name="ln1019">  _set_orientation (ps);</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022">static GList* _get_profiles ()</a>
<a name="ln1023">{</a>
<a name="ln1024">  //  Create list of profiles</a>
<a name="ln1025">  GList *list = NULL;</a>
<a name="ln1026"> </a>
<a name="ln1027">  dt_lib_export_profile_t *prof = (dt_lib_export_profile_t *)g_malloc0(sizeof(dt_lib_export_profile_t));</a>
<a name="ln1028">  prof-&gt;type = DT_COLORSPACE_SRGB;</a>
<a name="ln1029">  dt_utf8_strlcpy(prof-&gt;name, _(&quot;sRGB (web-safe)&quot;), sizeof(prof-&gt;name));</a>
<a name="ln1030">  prof-&gt;pos = -2;</a>
<a name="ln1031">  prof-&gt;ppos = -2;</a>
<a name="ln1032">  list = g_list_append(list, prof);</a>
<a name="ln1033"> </a>
<a name="ln1034">  prof = (dt_lib_export_profile_t *)g_malloc0(sizeof(dt_lib_export_profile_t));</a>
<a name="ln1035">  prof-&gt;type = DT_COLORSPACE_ADOBERGB;</a>
<a name="ln1036">  dt_utf8_strlcpy(prof-&gt;name, _(&quot;Adobe RGB (compatible)&quot;), sizeof(prof-&gt;name));</a>
<a name="ln1037">  prof-&gt;pos = -2;</a>
<a name="ln1038">  prof-&gt;ppos = -2;</a>
<a name="ln1039">  list = g_list_append(list, prof);</a>
<a name="ln1040"> </a>
<a name="ln1041">  // add the profiles from datadir/color/out/*.icc</a>
<a name="ln1042">  for(GList *iter = darktable.color_profiles-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln1043">  {</a>
<a name="ln1044">    dt_colorspaces_color_profile_t *p = (dt_colorspaces_color_profile_t *)iter-&gt;data;</a>
<a name="ln1045">    if(p-&gt;type == DT_COLORSPACE_FILE)</a>
<a name="ln1046">    {</a>
<a name="ln1047">      prof = (dt_lib_export_profile_t *)g_malloc0(sizeof(dt_lib_export_profile_t));</a>
<a name="ln1048">      g_strlcpy(prof-&gt;name, p-&gt;name, sizeof(prof-&gt;name));</a>
<a name="ln1049">      g_strlcpy(prof-&gt;filename, p-&gt;filename, sizeof(prof-&gt;filename));</a>
<a name="ln1050">      prof-&gt;type = DT_COLORSPACE_FILE;</a>
<a name="ln1051">      prof-&gt;pos = -2;</a>
<a name="ln1052">      prof-&gt;ppos = -2;</a>
<a name="ln1053">      list = g_list_append(list, prof);</a>
<a name="ln1054">    }</a>
<a name="ln1055">  }</a>
<a name="ln1056"> </a>
<a name="ln1057">  return list;</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060">static void _new_printer_callback(dt_printer_info_t *printer, void *user_data)</a>
<a name="ln1061">{</a>
<a name="ln1062">  static int count = 0;</a>
<a name="ln1063">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1064">  const dt_lib_print_settings_t *d = (dt_lib_print_settings_t*)self-&gt;data;</a>
<a name="ln1065"> </a>
<a name="ln1066">  char *default_printer = dt_conf_get_string(&quot;plugins/print/print/printer&quot;);</a>
<a name="ln1067"> </a>
<a name="ln1068">  g_signal_handlers_block_by_func(G_OBJECT(d-&gt;printers), G_CALLBACK(_printer_changed), NULL);</a>
<a name="ln1069"> </a>
<a name="ln1070">  dt_bauhaus_combobox_add(d-&gt;printers, printer-&gt;name);</a>
<a name="ln1071"> </a>
<a name="ln1072">  if (!g_strcmp0(default_printer, printer-&gt;name) || default_printer[0]=='\0')</a>
<a name="ln1073">  {</a>
<a name="ln1074">    dt_bauhaus_combobox_set(d-&gt;printers, count);</a>
<a name="ln1075">    _set_printer(self, printer-&gt;name);</a>
<a name="ln1076">  }</a>
<a name="ln1077">  count++;</a>
<a name="ln1078">  g_free(default_printer);</a>
<a name="ln1079"> </a>
<a name="ln1080">  g_signal_handlers_unblock_by_func(G_OBJECT(d-&gt;printers), G_CALLBACK(_printer_changed), NULL);</a>
<a name="ln1081">}</a>
<a name="ln1082"> </a>
<a name="ln1083">void view_enter(struct dt_lib_module_t *self,struct dt_view_t *old_view,struct dt_view_t *new_view)</a>
<a name="ln1084">{</a>
<a name="ln1085">  // user activated a new image via the filmstrip or user entered view</a>
<a name="ln1086">  // mode which activates an image: get image_id and orientation</a>
<a name="ln1087">  dt_control_signal_connect(darktable.signals,</a>
<a name="ln1088">                            DT_SIGNAL_VIEWMANAGER_FILMSTRIP_ACTIVATE,</a>
<a name="ln1089">                            G_CALLBACK(_print_settings_activate_or_update_callback),</a>
<a name="ln1090">                            self);</a>
<a name="ln1091"> </a>
<a name="ln1092">  // when an updated mipmap, we may have new orientation information</a>
<a name="ln1093">  // about the current image. This updates the image_id as well and</a>
<a name="ln1094">  // zeros out dimensions, but there should be no harm in that</a>
<a name="ln1095">  dt_control_signal_connect(darktable.signals,</a>
<a name="ln1096">                            DT_SIGNAL_DEVELOP_MIPMAP_UPDATED,</a>
<a name="ln1097">                            G_CALLBACK(_print_settings_activate_or_update_callback),</a>
<a name="ln1098">                            self);</a>
<a name="ln1099"> </a>
<a name="ln1100">  // NOTE: it would be proper to set image_id here to -1, but this seems to make no difference</a>
<a name="ln1101">}</a>
<a name="ln1102"> </a>
<a name="ln1103">void view_leave(struct dt_lib_module_t *self,struct dt_view_t *old_view,struct dt_view_t *new_view)</a>
<a name="ln1104">{</a>
<a name="ln1105">  dt_control_signal_disconnect(darktable.signals,</a>
<a name="ln1106">                               G_CALLBACK(_print_settings_activate_or_update_callback),</a>
<a name="ln1107">                               self);</a>
<a name="ln1108">}</a>
<a name="ln1109"> </a>
<a name="ln1110">void</a>
<a name="ln1111">gui_init (dt_lib_module_t *self)</a>
<a name="ln1112">{</a>
<a name="ln1113">  dt_lib_print_settings_t *d = (dt_lib_print_settings_t*)malloc(sizeof(dt_lib_print_settings_t));</a>
<a name="ln1114">  self-&gt;data = d;</a>
<a name="ln1115">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln1116">  dt_gui_add_help_link(self-&gt;widget, &quot;print_chapter.html#print_overview&quot;);</a>
<a name="ln1117"> </a>
<a name="ln1118">  char datadir[PATH_MAX] = { 0 };</a>
<a name="ln1119">  char confdir[PATH_MAX] = { 0 };</a>
<a name="ln1120">  dt_loc_get_user_config_dir(confdir, sizeof(confdir));</a>
<a name="ln1121">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln1122">  char *system_profile_dir = g_build_filename(datadir, &quot;color&quot;, &quot;out&quot;, NULL);</a>
<a name="ln1123">  char *user_profile_dir = g_build_filename(confdir, &quot;color&quot;, &quot;out&quot;, NULL);</a>
<a name="ln1124"> </a>
<a name="ln1125">  GtkWidget *label;</a>
<a name="ln1126"> </a>
<a name="ln1127">  d-&gt;paper_list = NULL;</a>
<a name="ln1128">  d-&gt;media_list = NULL;</a>
<a name="ln1129">  d-&gt;iwidth = d-&gt;iheight = 0;</a>
<a name="ln1130">  d-&gt;unit = 0;</a>
<a name="ln1131">  d-&gt;width = d-&gt;height = NULL;</a>
<a name="ln1132">  d-&gt;v_piccprofile = NULL;</a>
<a name="ln1133">  d-&gt;v_iccprofile = NULL;</a>
<a name="ln1134">  d-&gt;v_style = NULL;</a>
<a name="ln1135"> </a>
<a name="ln1136">  dt_init_print_info(&amp;d-&gt;prt);</a>
<a name="ln1137">  dt_view_print_settings(darktable.view_manager, &amp;d-&gt;prt);</a>
<a name="ln1138"> </a>
<a name="ln1139">  d-&gt;profiles = _get_profiles();</a>
<a name="ln1140"> </a>
<a name="ln1141">  d-&gt;image_id = -1;</a>
<a name="ln1142"> </a>
<a name="ln1143">  //  create the spin-button now as values could be set when the printer has no hardware margin</a>
<a name="ln1144"> </a>
<a name="ln1145">  d-&gt;b_top    = gtk_spin_button_new_with_range(0, 1000, 1);</a>
<a name="ln1146">  d-&gt;b_left   = gtk_spin_button_new_with_range(0, 1000, 1);</a>
<a name="ln1147">  d-&gt;b_right  = gtk_spin_button_new_with_range(0, 1000, 1);</a>
<a name="ln1148">  d-&gt;b_bottom = gtk_spin_button_new_with_range(0, 1000, 1);</a>
<a name="ln1149"> </a>
<a name="ln1150">  gtk_entry_set_alignment (GTK_ENTRY(d-&gt;b_top), 1);</a>
<a name="ln1151">  gtk_entry_set_alignment (GTK_ENTRY(d-&gt;b_left), 1);</a>
<a name="ln1152">  gtk_entry_set_alignment (GTK_ENTRY(d-&gt;b_right), 1);</a>
<a name="ln1153">  gtk_entry_set_alignment (GTK_ENTRY(d-&gt;b_bottom), 1);</a>
<a name="ln1154"> </a>
<a name="ln1155">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;b_top));</a>
<a name="ln1156">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;b_left));</a>
<a name="ln1157">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;b_right));</a>
<a name="ln1158">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;b_bottom));</a>
<a name="ln1159"> </a>
<a name="ln1160">  ////////////////////////// PRINTER SETTINGS</a>
<a name="ln1161"> </a>
<a name="ln1162">  // create papers combo as filled when adding printers</a>
<a name="ln1163">  d-&gt;papers = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1164"> </a>
<a name="ln1165">  label = dt_ui_section_label_new(_(&quot;printer&quot;));</a>
<a name="ln1166">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), label, TRUE, TRUE, 0);</a>
<a name="ln1167">  dt_gui_add_help_link(self-&gt;widget, &quot;print_usage.html#print_printer_section&quot;);</a>
<a name="ln1168">  d-&gt;printers = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1169"> </a>
<a name="ln1170">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), d-&gt;printers, TRUE, TRUE, 0);</a>
<a name="ln1171">  g_signal_connect(G_OBJECT(d-&gt;printers), &quot;value-changed&quot;, G_CALLBACK(_printer_changed), self);</a>
<a name="ln1172"> </a>
<a name="ln1173">  //// media</a>
<a name="ln1174"> </a>
<a name="ln1175">  d-&gt;media = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1176"> </a>
<a name="ln1177">  dt_bauhaus_widget_set_label(d-&gt;media, NULL, _(&quot;media&quot;));</a>
<a name="ln1178"> </a>
<a name="ln1179">  g_signal_connect(G_OBJECT(d-&gt;media), &quot;value-changed&quot;, G_CALLBACK(_media_changed), self);</a>
<a name="ln1180">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;media), TRUE, TRUE, 0);</a>
<a name="ln1181"> </a>
<a name="ln1182">  //  Add printer profile combo</a>
<a name="ln1183"> </a>
<a name="ln1184">  d-&gt;pprofile = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1185">  dt_bauhaus_widget_set_label(d-&gt;pprofile, NULL, _(&quot;profile&quot;));</a>
<a name="ln1186"> </a>
<a name="ln1187">  int combo_idx, n;</a>
<a name="ln1188">  GList *l = d-&gt;profiles;</a>
<a name="ln1189"> </a>
<a name="ln1190">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;pprofile), TRUE, TRUE, 0);</a>
<a name="ln1191">  int printer_profile_type = dt_conf_get_int(&quot;plugins/print/printer/icctype&quot;);</a>
<a name="ln1192">  gchar *printer_profile = dt_conf_get_string(&quot;plugins/print/printer/iccprofile&quot;);</a>
<a name="ln1193">  combo_idx = -1;</a>
<a name="ln1194">  n = 0;</a>
<a name="ln1195"> </a>
<a name="ln1196">  dt_bauhaus_combobox_add(d-&gt;pprofile, _(&quot;color management in printer driver&quot;));</a>
<a name="ln1197">  while(l)</a>
<a name="ln1198">  {</a>
<a name="ln1199">    dt_lib_export_profile_t *prof = (dt_lib_export_profile_t *)l-&gt;data;</a>
<a name="ln1200">    // do not add built-in profiles, these are in no way for printing</a>
<a name="ln1201">    if(prof-&gt;type == DT_COLORSPACE_FILE)</a>
<a name="ln1202">    {</a>
<a name="ln1203">      dt_bauhaus_combobox_add(d-&gt;pprofile, prof-&gt;name);</a>
<a name="ln1204">      prof-&gt;ppos = ++n;</a>
<a name="ln1205">      if(prof-&gt;type == printer_profile_type &amp;&amp;</a>
<a name="ln1206">        (prof-&gt;type != DT_COLORSPACE_FILE || !g_strcmp0(prof-&gt;filename, printer_profile)))</a>
<a name="ln1207">      {</a>
<a name="ln1208">        g_free(d-&gt;v_piccprofile);</a>
<a name="ln1209">        d-&gt;v_picctype = printer_profile_type;</a>
<a name="ln1210">        d-&gt;v_piccprofile = g_strdup(printer_profile);</a>
<a name="ln1211">        combo_idx = n;</a>
<a name="ln1212">      }</a>
<a name="ln1213">    }</a>
<a name="ln1214">    l = g_list_next(l);</a>
<a name="ln1215">  }</a>
<a name="ln1216"> </a>
<a name="ln1217">  g_free (printer_profile);</a>
<a name="ln1218"> </a>
<a name="ln1219">  // profile not found, maybe a profile has been removed? revert to none</a>
<a name="ln1220">  if (combo_idx == -1)</a>
<a name="ln1221">  {</a>
<a name="ln1222">    dt_conf_set_int(&quot;plugins/print/printer/icctype&quot;, DT_COLORSPACE_NONE);</a>
<a name="ln1223">    dt_conf_set_string(&quot;plugins/print/printer/iccprofile&quot;, &quot;&quot;);</a>
<a name="ln1224">    g_free(d-&gt;v_piccprofile);</a>
<a name="ln1225">    d-&gt;v_picctype = DT_COLORSPACE_NONE;</a>
<a name="ln1226">    d-&gt;v_piccprofile = g_strdup(&quot;&quot;);</a>
<a name="ln1227">    combo_idx = 0;</a>
<a name="ln1228">  }</a>
<a name="ln1229">  dt_bauhaus_combobox_set(d-&gt;pprofile, combo_idx);</a>
<a name="ln1230"> </a>
<a name="ln1231">  char *tooltip = g_strdup_printf(_(&quot;printer ICC profiles in %s or %s&quot;), user_profile_dir, system_profile_dir);</a>
<a name="ln1232">  gtk_widget_set_tooltip_text(d-&gt;pprofile, tooltip);</a>
<a name="ln1233">  g_free(tooltip);</a>
<a name="ln1234"> </a>
<a name="ln1235">  g_signal_connect(G_OBJECT(d-&gt;pprofile), &quot;value-changed&quot;, G_CALLBACK(_printer_profile_changed), (gpointer)self);</a>
<a name="ln1236"> </a>
<a name="ln1237">  //  Add printer intent combo</a>
<a name="ln1238"> </a>
<a name="ln1239">  d-&gt;pintent = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1240">  dt_bauhaus_widget_set_label(d-&gt;pintent, NULL, _(&quot;intent&quot;));</a>
<a name="ln1241">  dt_bauhaus_combobox_add(d-&gt;pintent, _(&quot;perceptual&quot;));</a>
<a name="ln1242">  dt_bauhaus_combobox_add(d-&gt;pintent, _(&quot;relative colorimetric&quot;));</a>
<a name="ln1243">  dt_bauhaus_combobox_add(d-&gt;pintent, C_(&quot;rendering intent&quot;, &quot;saturation&quot;));</a>
<a name="ln1244">  dt_bauhaus_combobox_add(d-&gt;pintent, _(&quot;absolute colorimetric&quot;));</a>
<a name="ln1245">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;pintent), TRUE, TRUE, 0);</a>
<a name="ln1246"> </a>
<a name="ln1247">  d-&gt;v_pintent = dt_conf_get_int(&quot;plugins/print/printer/iccintent&quot;);</a>
<a name="ln1248">  dt_bauhaus_combobox_set(d-&gt;pintent, d-&gt;v_pintent);</a>
<a name="ln1249"> </a>
<a name="ln1250">  g_signal_connect (G_OBJECT (d-&gt;pintent), &quot;value-changed&quot;, G_CALLBACK (_printer_intent_callback), (gpointer)self);</a>
<a name="ln1251">  d-&gt;prt.printer.intent = d-&gt;v_pintent;</a>
<a name="ln1252"> </a>
<a name="ln1253">  d-&gt;black_point_compensation = gtk_check_button_new_with_label(_(&quot;black point compensation&quot;));</a>
<a name="ln1254">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;black_point_compensation), TRUE, FALSE, 0);</a>
<a name="ln1255">  g_signal_connect(d-&gt;black_point_compensation, &quot;toggled&quot;, G_CALLBACK(_printer_bpc_callback), (gpointer)self);</a>
<a name="ln1256"> </a>
<a name="ln1257">  d-&gt;v_black_point_compensation = dt_conf_get_bool(&quot;plugins/print/print/black_point_compensation&quot;);</a>
<a name="ln1258">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;black_point_compensation), d-&gt;v_black_point_compensation);</a>
<a name="ln1259"> </a>
<a name="ln1260">  gtk_widget_set_tooltip_text(d-&gt;black_point_compensation,</a>
<a name="ln1261">                              _(&quot;activate black point compensation when applying the printer profile&quot;));</a>
<a name="ln1262"> </a>
<a name="ln1263">  gtk_widget_set_sensitive(GTK_WIDGET(d-&gt;black_point_compensation), combo_idx==0?FALSE:TRUE);</a>
<a name="ln1264"> </a>
<a name="ln1265">  ////////////////////////// PAGE SETTINGS</a>
<a name="ln1266"> </a>
<a name="ln1267">  label = dt_ui_section_label_new(_(&quot;page&quot;));</a>
<a name="ln1268">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), label, TRUE, TRUE, 0);</a>
<a name="ln1269">  dt_gui_add_help_link(self-&gt;widget, &quot;print_page_section.html#print_page_section&quot;);</a>
<a name="ln1270"> </a>
<a name="ln1271">  //// papers</a>
<a name="ln1272"> </a>
<a name="ln1273">  dt_bauhaus_widget_set_label(d-&gt;papers, NULL, _(&quot;paper size&quot;));</a>
<a name="ln1274"> </a>
<a name="ln1275">  g_signal_connect(G_OBJECT(d-&gt;papers), &quot;value-changed&quot;, G_CALLBACK(_paper_changed), self);</a>
<a name="ln1276">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;papers), TRUE, TRUE, 0);</a>
<a name="ln1277"> </a>
<a name="ln1278">  //// portrait / landscape</a>
<a name="ln1279"> </a>
<a name="ln1280">  d-&gt;orientation = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1281">  dt_bauhaus_widget_set_label(d-&gt;orientation, NULL, _(&quot;orientation&quot;));</a>
<a name="ln1282">  dt_bauhaus_combobox_add(d-&gt;orientation, _(&quot;portrait&quot;));</a>
<a name="ln1283">  dt_bauhaus_combobox_add(d-&gt;orientation, _(&quot;landscape&quot;));</a>
<a name="ln1284"> </a>
<a name="ln1285">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;orientation), TRUE, TRUE, 0);</a>
<a name="ln1286"> </a>
<a name="ln1287">  GtkWidget *ucomb = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1288">  dt_bauhaus_combobox_add(ucomb, _(&quot;mm&quot;));</a>
<a name="ln1289">  dt_bauhaus_combobox_add(ucomb, _(&quot;cm&quot;));</a>
<a name="ln1290">  dt_bauhaus_combobox_add(ucomb, _(&quot;inch&quot;));</a>
<a name="ln1291">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), ucomb, TRUE, TRUE, 0);</a>
<a name="ln1292"> </a>
<a name="ln1293">  g_signal_connect(G_OBJECT(d-&gt;orientation), &quot;value-changed&quot;, G_CALLBACK(_orientation_changed), self);</a>
<a name="ln1294">  g_signal_connect(G_OBJECT(ucomb), &quot;value-changed&quot;, G_CALLBACK(_unit_changed), self);</a>
<a name="ln1295"> </a>
<a name="ln1296">  d-&gt;unit = dt_conf_get_int(&quot;plugins/print/print/unit&quot;);</a>
<a name="ln1297">  dt_bauhaus_combobox_set(ucomb, d-&gt;unit);</a>
<a name="ln1298"> </a>
<a name="ln1299">  dt_bauhaus_combobox_set (d-&gt;orientation, d-&gt;prt.page.landscape?1:0);</a>
<a name="ln1300"> </a>
<a name="ln1301">  //// image dimensions, create them now as we need them</a>
<a name="ln1302"> </a>
<a name="ln1303">  GtkWidget *hboxdim = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);</a>
<a name="ln1304">  label = gtk_label_new(_(&quot;image width/height&quot;));</a>
<a name="ln1305">  gtk_box_pack_start(GTK_BOX(hboxdim),GTK_WIDGET(label),TRUE,TRUE,0);</a>
<a name="ln1306">  d-&gt;width = gtk_label_new(_(&quot;width&quot;));</a>
<a name="ln1307">  gtk_box_pack_start(GTK_BOX(hboxdim),GTK_WIDGET(d-&gt;width),TRUE,TRUE,0);</a>
<a name="ln1308">  label = gtk_label_new(_(&quot; x &quot;));</a>
<a name="ln1309">  gtk_box_pack_start(GTK_BOX(hboxdim),GTK_WIDGET(label),TRUE,TRUE,0);</a>
<a name="ln1310">  d-&gt;height = gtk_label_new(_(&quot;height&quot;));</a>
<a name="ln1311">  gtk_box_pack_start(GTK_BOX(hboxdim),GTK_WIDGET(d-&gt;height),TRUE,TRUE,0);</a>
<a name="ln1312"> </a>
<a name="ln1313">  //// image information (downscale/upscale)</a>
<a name="ln1314"> </a>
<a name="ln1315">  GtkWidget *hboxinfo = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);</a>
<a name="ln1316">  label = gtk_label_new(_(&quot;scale factor&quot;));</a>
<a name="ln1317">  gtk_box_pack_start(GTK_BOX(hboxinfo),GTK_WIDGET(label),TRUE,TRUE,0);</a>
<a name="ln1318">  d-&gt;info = gtk_label_new(&quot;1.0&quot;);</a>
<a name="ln1319">  gtk_box_pack_start(GTK_BOX(hboxinfo),GTK_WIDGET(d-&gt;info),TRUE,TRUE,0);</a>
<a name="ln1320">  gtk_widget_set_tooltip_text(hboxinfo,</a>
<a name="ln1321">               _(&quot;image scale factor from native printer DPI:\n&quot;</a>
<a name="ln1322">                 &quot; &lt; 1 means that it is downscaled (best quality)\n&quot;</a>
<a name="ln1323">                 &quot; &gt; 1 means that the image is upscaled\n&quot;</a>
<a name="ln1324">                 &quot; a too large value may result in poor print quality&quot;));</a>
<a name="ln1325"> </a>
<a name="ln1326">  //// borders</a>
<a name="ln1327"> </a>
<a name="ln1328">  GtkGrid *bds = GTK_GRID(gtk_grid_new());</a>
<a name="ln1329">  gtk_grid_set_row_spacing(bds, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1330">  gtk_grid_set_column_spacing(bds, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1331"> </a>
<a name="ln1332">  d-&gt;lock_activated = FALSE;</a>
<a name="ln1333"> </a>
<a name="ln1334">  //d-&gt;b_top  = gtk_spin_button_new_with_range(0, 10000, 1);</a>
<a name="ln1335">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;b_top), _(&quot;top margin&quot;));</a>
<a name="ln1336">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;b_top), 1, 0, 1, 1);</a>
<a name="ln1337"> </a>
<a name="ln1338">  //d-&gt;b_left  = gtk_spin_button_new_with_range(0, 10000, 1);</a>
<a name="ln1339">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;b_left), _(&quot;left margin&quot;));</a>
<a name="ln1340">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;b_left), 0, 1, 1, 1);</a>
<a name="ln1341"> </a>
<a name="ln1342">  d-&gt;lock_button = GTK_TOGGLE_BUTTON(gtk_toggle_button_new_with_label(_(&quot;lock&quot;)));</a>
<a name="ln1343">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;lock_button), _(&quot;change all margins uniformly&quot;));</a>
<a name="ln1344">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;lock_button), 1, 1, 1, 1);</a>
<a name="ln1345"> </a>
<a name="ln1346">  //d-&gt;b_right  = gtk_spin_button_new_with_range(0, 10000, 1);</a>
<a name="ln1347">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;b_right), _(&quot;right margin&quot;));</a>
<a name="ln1348">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;b_right), 2, 1, 1, 1);</a>
<a name="ln1349"> </a>
<a name="ln1350">  //d-&gt;b_bottom  = gtk_spin_button_new_with_range(0, 10000, 1);</a>
<a name="ln1351">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;b_bottom), _(&quot;bottom margin&quot;));</a>
<a name="ln1352">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;b_bottom), 1, 2, 1, 1);</a>
<a name="ln1353"> </a>
<a name="ln1354">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(bds), TRUE, TRUE, 0);</a>
<a name="ln1355"> </a>
<a name="ln1356">  g_signal_connect (G_OBJECT (d-&gt;b_top), &quot;value-changed&quot;,</a>
<a name="ln1357">                    G_CALLBACK (_top_border_callback), self);</a>
<a name="ln1358">  g_signal_connect (G_OBJECT (d-&gt;b_bottom), &quot;value-changed&quot;,</a>
<a name="ln1359">                    G_CALLBACK (_bottom_border_callback), self);</a>
<a name="ln1360">  g_signal_connect (G_OBJECT (d-&gt;b_left), &quot;value-changed&quot;,</a>
<a name="ln1361">                    G_CALLBACK (_left_border_callback), self);</a>
<a name="ln1362">  g_signal_connect (G_OBJECT (d-&gt;b_right), &quot;value-changed&quot;,</a>
<a name="ln1363">                    G_CALLBACK (_right_border_callback), self);</a>
<a name="ln1364">  g_signal_connect (G_OBJECT(d-&gt;lock_button), &quot;toggled&quot;,</a>
<a name="ln1365">                    G_CALLBACK(_lock_callback), self);</a>
<a name="ln1366"> </a>
<a name="ln1367">  const gboolean lock_active = dt_conf_get_bool(&quot;plugins/print/print/lock_borders&quot;);</a>
<a name="ln1368">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;lock_button), lock_active);</a>
<a name="ln1369"> </a>
<a name="ln1370">  // pack image dimension hbox here</a>
<a name="ln1371"> </a>
<a name="ln1372">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hboxdim), TRUE, TRUE, 0);</a>
<a name="ln1373">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hboxinfo), TRUE, TRUE, 0);</a>
<a name="ln1374"> </a>
<a name="ln1375">  //// alignments</a>
<a name="ln1376"> </a>
<a name="ln1377">  // Create the 3x3 gtk table toggle button table...</a>
<a name="ln1378">  GtkGrid *bat = GTK_GRID(gtk_grid_new());</a>
<a name="ln1379">  gtk_grid_set_row_spacing(bat, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1380">  gtk_grid_set_column_spacing(bat, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1381">  for(int i=0; i&lt;9; i++)</a>
<a name="ln1382">  {</a>
<a name="ln1383">    d-&gt;dtba[i] = DTGTK_TOGGLEBUTTON (dtgtk_togglebutton_new (dtgtk_cairo_paint_alignment,CPF_STYLE_FLAT|(CPF_SPECIAL_FLAG&lt;&lt;i), NULL));</a>
<a name="ln1384">    gtk_grid_attach (GTK_GRID (bat), GTK_WIDGET (d-&gt;dtba[i]), (i%3), i/3, 1, 1);</a>
<a name="ln1385">    g_signal_connect (G_OBJECT (d-&gt;dtba[i]), &quot;toggled&quot;,G_CALLBACK (_alignment_callback), self);</a>
<a name="ln1386">  }</a>
<a name="ln1387">  d-&gt;prt.page.alignment = ALIGNMENT_CENTER;</a>
<a name="ln1388">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;dtba[d-&gt;prt.page.alignment]),TRUE);</a>
<a name="ln1389"> </a>
<a name="ln1390">  GtkWidget *hbox22 = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);</a>
<a name="ln1391">  GtkWidget *label4 = gtk_label_new(_(&quot;alignment&quot;));</a>
<a name="ln1392">  gtk_box_pack_start(GTK_BOX(hbox22),GTK_WIDGET(label4),TRUE,TRUE,0);</a>
<a name="ln1393">  gtk_box_pack_start(GTK_BOX(hbox22), GTK_WIDGET(bat), TRUE, TRUE, 0);</a>
<a name="ln1394">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hbox22), TRUE, TRUE, 0);</a>
<a name="ln1395"> </a>
<a name="ln1396">  ////////////////////////// PRINT SETTINGS</a>
<a name="ln1397"> </a>
<a name="ln1398">  label = dt_ui_section_label_new(_(&quot;print settings&quot;));</a>
<a name="ln1399">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), label, TRUE, TRUE, 0);</a>
<a name="ln1400">  dt_gui_add_help_link(self-&gt;widget, &quot;print_settings.html#print_settings&quot;);</a>
<a name="ln1401"> </a>
<a name="ln1402">  //  Add export profile combo</a>
<a name="ln1403"> </a>
<a name="ln1404">  d-&gt;profile = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1405">  dt_bauhaus_widget_set_label(d-&gt;profile, NULL, _(&quot;profile&quot;));</a>
<a name="ln1406"> </a>
<a name="ln1407">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;profile), TRUE, TRUE, 0);</a>
<a name="ln1408">  dt_bauhaus_combobox_add(d-&gt;profile, _(&quot;image settings&quot;));</a>
<a name="ln1409"> </a>
<a name="ln1410">  int icctype = dt_conf_get_int(&quot;plugins/print/print/icctype&quot;);</a>
<a name="ln1411">  gchar *iccprofile = dt_conf_get_string(&quot;plugins/print/print/iccprofile&quot;);</a>
<a name="ln1412">  combo_idx = -1;</a>
<a name="ln1413">  n = 0;</a>
<a name="ln1414"> </a>
<a name="ln1415">  l = d-&gt;profiles;</a>
<a name="ln1416">  while(l)</a>
<a name="ln1417">  {</a>
<a name="ln1418">    dt_lib_export_profile_t *prof = (dt_lib_export_profile_t *)l-&gt;data;</a>
<a name="ln1419">    dt_bauhaus_combobox_add(d-&gt;profile, prof-&gt;name);</a>
<a name="ln1420">    prof-&gt;pos = ++n;</a>
<a name="ln1421">    if(prof-&gt;type == icctype &amp;&amp; (prof-&gt;type != DT_COLORSPACE_FILE || !g_strcmp0(prof-&gt;filename, iccprofile)))</a>
<a name="ln1422">    {</a>
<a name="ln1423">      g_free(d-&gt;v_iccprofile);</a>
<a name="ln1424">      d-&gt;v_icctype = icctype;</a>
<a name="ln1425">      d-&gt;v_iccprofile = g_strdup(iccprofile);</a>
<a name="ln1426">      combo_idx = n;</a>
<a name="ln1427">    }</a>
<a name="ln1428">    l = g_list_next(l);</a>
<a name="ln1429">  }</a>
<a name="ln1430"> </a>
<a name="ln1431">  if (combo_idx == -1)</a>
<a name="ln1432">  {</a>
<a name="ln1433">    dt_conf_set_int(&quot;plugins/print/print/icctype&quot;, DT_COLORSPACE_NONE);</a>
<a name="ln1434">    dt_conf_set_string(&quot;plugins/print/print/iccprofile&quot;, &quot;&quot;);</a>
<a name="ln1435">    g_free(d-&gt;v_iccprofile);</a>
<a name="ln1436">    d-&gt;v_icctype = DT_COLORSPACE_NONE;</a>
<a name="ln1437">    d-&gt;v_iccprofile = g_strdup(&quot;&quot;);</a>
<a name="ln1438">    combo_idx = 0;</a>
<a name="ln1439">  }</a>
<a name="ln1440">  g_free (iccprofile);</a>
<a name="ln1441"> </a>
<a name="ln1442">  dt_bauhaus_combobox_set(d-&gt;profile, combo_idx);</a>
<a name="ln1443"> </a>
<a name="ln1444">  tooltip = g_strdup_printf(_(&quot;output ICC profiles in %s or %s&quot;), user_profile_dir, system_profile_dir);</a>
<a name="ln1445">  gtk_widget_set_tooltip_text(d-&gt;profile, tooltip);</a>
<a name="ln1446">  g_free(tooltip);</a>
<a name="ln1447"> </a>
<a name="ln1448">  g_signal_connect(G_OBJECT(d-&gt;profile), &quot;value-changed&quot;, G_CALLBACK(_profile_changed), (gpointer)self);</a>
<a name="ln1449"> </a>
<a name="ln1450">  //  Add export intent combo</a>
<a name="ln1451"> </a>
<a name="ln1452">  d-&gt;intent = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1453">  dt_bauhaus_widget_set_label(d-&gt;intent, NULL, _(&quot;intent&quot;));</a>
<a name="ln1454"> </a>
<a name="ln1455">  dt_bauhaus_combobox_add(d-&gt;intent, _(&quot;image settings&quot;));</a>
<a name="ln1456">  dt_bauhaus_combobox_add(d-&gt;intent, _(&quot;perceptual&quot;));</a>
<a name="ln1457">  dt_bauhaus_combobox_add(d-&gt;intent, _(&quot;relative colorimetric&quot;));</a>
<a name="ln1458">  dt_bauhaus_combobox_add(d-&gt;intent, C_(&quot;rendering intent&quot;, &quot;saturation&quot;));</a>
<a name="ln1459">  dt_bauhaus_combobox_add(d-&gt;intent, _(&quot;absolute colorimetric&quot;));</a>
<a name="ln1460">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;intent), TRUE, TRUE, 0);</a>
<a name="ln1461"> </a>
<a name="ln1462">  dt_bauhaus_combobox_set(d-&gt;intent, dt_conf_get_int(&quot;plugins/print/print/iccintent&quot;) + 1);</a>
<a name="ln1463"> </a>
<a name="ln1464">  g_signal_connect (G_OBJECT (d-&gt;intent), &quot;value-changed&quot;, G_CALLBACK (_intent_callback), (gpointer)self);</a>
<a name="ln1465"> </a>
<a name="ln1466">  //  Add export style combo</a>
<a name="ln1467"> </a>
<a name="ln1468">  d-&gt;style = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1469">  dt_bauhaus_widget_set_label(d-&gt;style, NULL, _(&quot;style&quot;));</a>
<a name="ln1470"> </a>
<a name="ln1471">  dt_bauhaus_combobox_add(d-&gt;style, _(&quot;none&quot;));</a>
<a name="ln1472"> </a>
<a name="ln1473">  GList *styles = dt_styles_get_list(&quot;&quot;);</a>
<a name="ln1474">  gchar *current_style = dt_conf_get_string(&quot;plugins/print/print/style&quot;);</a>
<a name="ln1475">  combo_idx = -1; n=0;</a>
<a name="ln1476"> </a>
<a name="ln1477">  while (styles)</a>
<a name="ln1478">  {</a>
<a name="ln1479">    dt_style_t *style=(dt_style_t *)styles-&gt;data;</a>
<a name="ln1480">    dt_bauhaus_combobox_add(d-&gt;style, style-&gt;name);</a>
<a name="ln1481">    n++;</a>
<a name="ln1482">    if (g_strcmp0(style-&gt;name,current_style)==0)</a>
<a name="ln1483">    {</a>
<a name="ln1484">      g_free(d-&gt;v_style);</a>
<a name="ln1485">      d-&gt;v_style = g_strdup(current_style);</a>
<a name="ln1486">      combo_idx=n;</a>
<a name="ln1487">    }</a>
<a name="ln1488">    styles=g_list_next(styles);</a>
<a name="ln1489">  }</a>
<a name="ln1490">  g_free(current_style);</a>
<a name="ln1491">  g_list_free_full(styles, dt_style_free);</a>
<a name="ln1492">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;style), TRUE, TRUE, 0);</a>
<a name="ln1493">  gtk_widget_set_tooltip_text(d-&gt;style, _(&quot;temporary style to use while printing&quot;));</a>
<a name="ln1494"> </a>
<a name="ln1495">  // style not found, maybe a style has been removed? revert to none</a>
<a name="ln1496">  if (combo_idx == -1)</a>
<a name="ln1497">  {</a>
<a name="ln1498">    dt_conf_set_string(&quot;plugins/print/print/style&quot;, &quot;&quot;);</a>
<a name="ln1499">    g_free(d-&gt;v_style);</a>
<a name="ln1500">    d-&gt;v_style = g_strdup(&quot;&quot;);</a>
<a name="ln1501">    combo_idx=0;</a>
<a name="ln1502">  }</a>
<a name="ln1503">  dt_bauhaus_combobox_set(d-&gt;style, combo_idx);</a>
<a name="ln1504"> </a>
<a name="ln1505">  g_signal_connect (G_OBJECT (d-&gt;style), &quot;value-changed&quot;,</a>
<a name="ln1506">                    G_CALLBACK (_style_callback),</a>
<a name="ln1507">                    (gpointer)self);</a>
<a name="ln1508"> </a>
<a name="ln1509">  //  Whether to add/replace style items</a>
<a name="ln1510"> </a>
<a name="ln1511">  d-&gt;style_mode = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1512">  dt_bauhaus_widget_set_label(d-&gt;style_mode, NULL, _(&quot;mode&quot;));</a>
<a name="ln1513"> </a>
<a name="ln1514">  dt_bauhaus_combobox_add(d-&gt;style_mode, _(&quot;replace history&quot;));</a>
<a name="ln1515">  dt_bauhaus_combobox_add(d-&gt;style_mode, _(&quot;append history&quot;));</a>
<a name="ln1516"> </a>
<a name="ln1517">  d-&gt;v_style_append = dt_conf_get_bool(&quot;plugins/print/print/style_append&quot;);</a>
<a name="ln1518">  dt_bauhaus_combobox_set(d-&gt;style_mode, d-&gt;v_style_append?1:0);</a>
<a name="ln1519"> </a>
<a name="ln1520">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;style_mode), TRUE, TRUE, 0);</a>
<a name="ln1521">  gtk_widget_set_tooltip_text(d-&gt;style_mode,</a>
<a name="ln1522">                              _(&quot;whether the style items are appended to the history or replacing the history&quot;));</a>
<a name="ln1523"> </a>
<a name="ln1524">  gtk_widget_set_sensitive(GTK_WIDGET(d-&gt;style_mode), combo_idx==0?FALSE:TRUE);</a>
<a name="ln1525"> </a>
<a name="ln1526">  g_signal_connect(G_OBJECT(d-&gt;style_mode), &quot;value-changed&quot;, G_CALLBACK(_style_mode_changed), (gpointer)self);</a>
<a name="ln1527"> </a>
<a name="ln1528">  // Print button</a>
<a name="ln1529"> </a>
<a name="ln1530">  GtkButton *button = GTK_BUTTON(gtk_button_new_with_label(_(&quot;print&quot;)));</a>
<a name="ln1531">  d-&gt;print_button = button;</a>
<a name="ln1532">  gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;print with current settings&quot;));</a>
<a name="ln1533">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(button), TRUE, TRUE, 0);</a>
<a name="ln1534">  dt_gui_add_help_link(GTK_WIDGET(button), &quot;print_button.html#print_button&quot;);</a>
<a name="ln1535"> </a>
<a name="ln1536">  g_signal_connect (G_OBJECT (button), &quot;clicked&quot;,</a>
<a name="ln1537">                    G_CALLBACK (_print_button_clicked),</a>
<a name="ln1538">                    (gpointer)self);</a>
<a name="ln1539"> </a>
<a name="ln1540">  g_free(system_profile_dir);</a>
<a name="ln1541">  g_free(user_profile_dir);</a>
<a name="ln1542"> </a>
<a name="ln1543">  // Let's start the printer discovery now</a>
<a name="ln1544"> </a>
<a name="ln1545">  dt_printers_discovery(_new_printer_callback, self);</a>
<a name="ln1546">}</a>
<a name="ln1547"> </a>
<a name="ln1548">void init_presets(dt_lib_module_t *self)</a>
<a name="ln1549">{</a>
<a name="ln1550">}</a>
<a name="ln1551"> </a>
<a name="ln1552">void *legacy_params(dt_lib_module_t *self, const void *const old_params, const size_t old_params_size,</a>
<a name="ln1553">                    const int old_version, int *new_version, size_t *new_size)</a>
<a name="ln1554">{</a>
<a name="ln1555">  if(old_version == 1)</a>
<a name="ln1556">  {</a>
<a name="ln1557">    // we added the profile type</a>
<a name="ln1558">    //</a>
<a name="ln1559">    // old format:</a>
<a name="ln1560">    //   char *printer</a>
<a name="ln1561">    //   char *paper</a>
<a name="ln1562">    //   int32_t landscape</a>
<a name="ln1563">    //   char *f_profile</a>
<a name="ln1564">    //   int32_t intent</a>
<a name="ln1565">    //   char *f_pprofile</a>
<a name="ln1566">    //   &lt;rest&gt;</a>
<a name="ln1567">    //</a>
<a name="ln1568">    // new format:</a>
<a name="ln1569">    //   char *printer</a>
<a name="ln1570">    //   char *paper</a>
<a name="ln1571">    //   int32_t landscape</a>
<a name="ln1572">    //   int32_t f_profile_type</a>
<a name="ln1573">    //   char *f_profile</a>
<a name="ln1574">    //   int32_t intent</a>
<a name="ln1575">    //   int32_t f_pprofile_type</a>
<a name="ln1576">    //   char *f_pprofile</a>
<a name="ln1577">    //   &lt;rest&gt;</a>
<a name="ln1578"> </a>
<a name="ln1579">    const char *buf = (const char *)old_params;</a>
<a name="ln1580"> </a>
<a name="ln1581">    // printer</a>
<a name="ln1582">    const char *printer = buf;</a>
<a name="ln1583">    const int32_t printer_len = strlen(printer) + 1;</a>
<a name="ln1584">    buf += printer_len;</a>
<a name="ln1585"> </a>
<a name="ln1586">    // paper</a>
<a name="ln1587">    const char *paper = buf;</a>
<a name="ln1588">    const int32_t paper_len = strlen(paper) + 1;</a>
<a name="ln1589">    buf += paper_len;</a>
<a name="ln1590"> </a>
<a name="ln1591">    // landscape</a>
<a name="ln1592">    const int32_t landscape = *(int32_t *)buf;</a>
<a name="ln1593">    buf +=  sizeof(int32_t);</a>
<a name="ln1594"> </a>
<a name="ln1595">    // profile</a>
<a name="ln1596">    const char *profile = buf;</a>
<a name="ln1597">    const int32_t profile_len = strlen(profile) + 1;</a>
<a name="ln1598">    buf += profile_len;</a>
<a name="ln1599"> </a>
<a name="ln1600">    // intent</a>
<a name="ln1601">    const int32_t intent = *(int32_t *)buf;</a>
<a name="ln1602">    buf += sizeof(int32_t);</a>
<a name="ln1603"> </a>
<a name="ln1604">    // pprofile</a>
<a name="ln1605">    const char *pprofile = buf;</a>
<a name="ln1606">    const int32_t pprofile_len = strlen(pprofile) + 1;</a>
<a name="ln1607">    buf += pprofile_len;</a>
<a name="ln1608"> </a>
<a name="ln1609"> </a>
<a name="ln1610">    // now we got all fields from the start of the buffer and buf points to the beginning or &lt;rest&gt;</a>
<a name="ln1611"> </a>
<a name="ln1612">    // find the new values for the two profiles</a>
<a name="ln1613">    dt_colorspaces_color_profile_type_t profile_type, pprofile_type;</a>
<a name="ln1614">    const char *profile_filename = &quot;&quot;, *pprofile_filename = &quot;&quot;;</a>
<a name="ln1615"> </a>
<a name="ln1616">    if(*profile == '\0' || !g_strcmp0(profile, &quot;none&quot;))</a>
<a name="ln1617">    {</a>
<a name="ln1618">      profile_type = DT_COLORSPACE_NONE;</a>
<a name="ln1619">    }</a>
<a name="ln1620">    else if(!g_strcmp0(profile, &quot;sRGB&quot;))</a>
<a name="ln1621">    {</a>
<a name="ln1622">      profile_type = DT_COLORSPACE_SRGB;</a>
<a name="ln1623">    }</a>
<a name="ln1624">    else if(!g_strcmp0(profile, &quot;adobergb&quot;))</a>
<a name="ln1625">    {</a>
<a name="ln1626">      profile_type = DT_COLORSPACE_ADOBERGB;</a>
<a name="ln1627">    }</a>
<a name="ln1628">    else</a>
<a name="ln1629">    {</a>
<a name="ln1630">      profile_type = DT_COLORSPACE_FILE;</a>
<a name="ln1631">      profile_filename = &amp;profile[1]; // the old code had a '/' in the beginning</a>
<a name="ln1632">    }</a>
<a name="ln1633"> </a>
<a name="ln1634">    // in theory pprofile can't be srgb or adobergb, but checking for them won't hurt</a>
<a name="ln1635">    if(*pprofile == '\0')</a>
<a name="ln1636">    {</a>
<a name="ln1637">      pprofile_type = DT_COLORSPACE_NONE;</a>
<a name="ln1638">    }</a>
<a name="ln1639">    else if(!g_strcmp0(pprofile, &quot;sRGB&quot;))</a>
<a name="ln1640">    {</a>
<a name="ln1641">      pprofile_type = DT_COLORSPACE_SRGB;</a>
<a name="ln1642">    }</a>
<a name="ln1643">    else if(!g_strcmp0(pprofile, &quot;adobergb&quot;))</a>
<a name="ln1644">    {</a>
<a name="ln1645">      pprofile_type = DT_COLORSPACE_ADOBERGB;</a>
<a name="ln1646">    }</a>
<a name="ln1647">    else</a>
<a name="ln1648">    {</a>
<a name="ln1649">      pprofile_type = DT_COLORSPACE_FILE;</a>
<a name="ln1650">      pprofile_filename = &amp;pprofile[1]; // the old code had a '/' in the beginning</a>
<a name="ln1651">    }</a>
<a name="ln1652"> </a>
<a name="ln1653">    int32_t new_profile_len = strlen(profile_filename) + 1;</a>
<a name="ln1654">    int32_t new_pprofile_len = strlen(pprofile_filename) + 1;</a>
<a name="ln1655"> </a>
<a name="ln1656">    // now we got everything to reassemble the new params</a>
<a name="ln1657">    size_t new_params_size = old_params_size - profile_len - pprofile_len;</a>
<a name="ln1658">    new_params_size += 2 * sizeof(dt_colorspaces_color_profile_type_t);</a>
<a name="ln1659">    new_params_size += new_profile_len + new_pprofile_len;</a>
<a name="ln1660">    void *new_params = malloc(new_params_size);</a>
<a name="ln1661"> </a>
<a name="ln1662">    size_t pos = 0;</a>
<a name="ln1663">    //   char *printer</a>
<a name="ln1664">    memcpy(new_params + pos, printer, printer_len);</a>
<a name="ln1665">    pos += printer_len;</a>
<a name="ln1666">    //   char *paper</a>
<a name="ln1667">    memcpy(new_params + pos, paper, paper_len);</a>
<a name="ln1668">    pos += paper_len;</a>
<a name="ln1669">    //   int32_t landscape</a>
<a name="ln1670">    memcpy(new_params + pos, &amp;landscape, sizeof(int32_t));</a>
<a name="ln1671">    pos += sizeof(int32_t);</a>
<a name="ln1672">    //   int32_t f_profile_type</a>
<a name="ln1673">    memcpy(new_params + pos, &amp;profile_type, sizeof(int32_t));</a>
<a name="ln1674">    pos += sizeof(int32_t);</a>
<a name="ln1675">    //   char *f_profile</a>
<a name="ln1676">    memcpy(new_params + pos, profile_filename, new_profile_len);</a>
<a name="ln1677">    pos += new_profile_len;</a>
<a name="ln1678">    //   int32_t intent</a>
<a name="ln1679">    memcpy(new_params + pos, &amp;intent, sizeof(int32_t));</a>
<a name="ln1680">    pos += sizeof(int32_t);</a>
<a name="ln1681">    //   int32_t f_pprofile_type</a>
<a name="ln1682">    memcpy(new_params + pos, &amp;pprofile_type, sizeof(int32_t));</a>
<a name="ln1683">    pos += sizeof(int32_t);</a>
<a name="ln1684">    //   char *f_pprofile</a>
<a name="ln1685">    memcpy(new_params + pos, pprofile_filename, new_pprofile_len);</a>
<a name="ln1686">    pos += new_pprofile_len;</a>
<a name="ln1687">    //   &lt;rest&gt;</a>
<a name="ln1688">    memcpy(new_params + pos, buf, old_params_size - ((char *)buf - (char *)old_params));</a>
<a name="ln1689"> </a>
<a name="ln1690">    *new_size = new_params_size;</a>
<a name="ln1691">    *new_version = 2;</a>
<a name="ln1692">    return new_params;</a>
<a name="ln1693">  }</a>
<a name="ln1694">  else if(old_version == 2)</a>
<a name="ln1695">  {</a>
<a name="ln1696">    // add upscale to params</a>
<a name="ln1697">    size_t new_params_size = old_params_size + 1;</a>
<a name="ln1698">    void *new_params = calloc(1, new_params_size);</a>
<a name="ln1699"> </a>
<a name="ln1700">    memcpy(new_params, old_params, old_params_size);</a>
<a name="ln1701">    // no media type specified</a>
<a name="ln1702">    ((char *)new_params)[old_params_size] = '\0';</a>
<a name="ln1703"> </a>
<a name="ln1704">    *new_size = new_params_size;</a>
<a name="ln1705">    *new_version = 3;</a>
<a name="ln1706">    return new_params;</a>
<a name="ln1707">  }</a>
<a name="ln1708"> </a>
<a name="ln1709">  return NULL;</a>
<a name="ln1710">}</a>
<a name="ln1711"> </a>
<a name="ln1712">int set_params(dt_lib_module_t *self, const void *params, int size)</a>
<a name="ln1713">{</a>
<a name="ln1714">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1715"> </a>
<a name="ln1716">  if(!params) return 1;</a>
<a name="ln1717"> </a>
<a name="ln1718">  // get the parameters buffer</a>
<a name="ln1719">  const char *buf = (char *)params;</a>
<a name="ln1720"> </a>
<a name="ln1721">  // get individual items</a>
<a name="ln1722">  const char *printer = buf;</a>
<a name="ln1723">  if (!printer) return 1;</a>
<a name="ln1724">  const int32_t printer_len = strlen(printer) + 1;</a>
<a name="ln1725">  buf += printer_len;</a>
<a name="ln1726"> </a>
<a name="ln1727">  const char *paper = buf;</a>
<a name="ln1728">  if (!paper) return 1;</a>
<a name="ln1729">  const int32_t paper_len = strlen(paper) + 1;</a>
<a name="ln1730">  buf += paper_len;</a>
<a name="ln1731"> </a>
<a name="ln1732">  const int32_t landscape = *(int32_t *)buf;</a>
<a name="ln1733">  buf +=  sizeof(int32_t);</a>
<a name="ln1734"> </a>
<a name="ln1735">  const int32_t f_profile_type = *(int32_t *)buf;</a>
<a name="ln1736">  buf +=  sizeof(int32_t);</a>
<a name="ln1737"> </a>
<a name="ln1738">  const char *f_profile = buf;</a>
<a name="ln1739">  if (!f_profile) return 1;</a>
<a name="ln1740">  const int32_t profile_len = strlen(f_profile) + 1;</a>
<a name="ln1741">  buf += profile_len;</a>
<a name="ln1742"> </a>
<a name="ln1743">  const int32_t intent = *(int32_t *)buf;</a>
<a name="ln1744">  buf += sizeof(int32_t);</a>
<a name="ln1745"> </a>
<a name="ln1746">  const int32_t f_pprofile_type = *(int32_t *)buf;</a>
<a name="ln1747">  buf +=  sizeof(int32_t);</a>
<a name="ln1748"> </a>
<a name="ln1749">  const char *f_pprofile = buf;</a>
<a name="ln1750">  if (!f_pprofile) return 1;</a>
<a name="ln1751">  const int32_t pprofile_len = strlen(f_pprofile) + 1;</a>
<a name="ln1752">  buf += pprofile_len;</a>
<a name="ln1753"> </a>
<a name="ln1754">  const int32_t pintent = *(int32_t *)buf;</a>
<a name="ln1755">  buf += sizeof(int32_t);</a>
<a name="ln1756"> </a>
<a name="ln1757">  const int32_t bpc = *(int32_t *)buf;</a>
<a name="ln1758">  buf += sizeof(int32_t);</a>
<a name="ln1759"> </a>
<a name="ln1760">  const char *style = buf;</a>
<a name="ln1761">  if (!style) return 1;</a>
<a name="ln1762">  const int32_t style_len = strlen(style) + 1;</a>
<a name="ln1763">  buf += style_len;</a>
<a name="ln1764"> </a>
<a name="ln1765">  const int32_t style_mode = *(int32_t *)buf;</a>
<a name="ln1766">  buf += sizeof(int32_t);</a>
<a name="ln1767"> </a>
<a name="ln1768">  const double b_top = *(double *)buf;</a>
<a name="ln1769">  buf += sizeof(double);</a>
<a name="ln1770"> </a>
<a name="ln1771">  const double b_bottom = *(double *)buf;</a>
<a name="ln1772">  buf += sizeof(double);</a>
<a name="ln1773"> </a>
<a name="ln1774">  const double b_left = *(double *)buf;</a>
<a name="ln1775">  buf += sizeof(double);</a>
<a name="ln1776"> </a>
<a name="ln1777">  const double b_right = *(double *)buf;</a>
<a name="ln1778">  buf += sizeof(double);</a>
<a name="ln1779"> </a>
<a name="ln1780">  const int32_t alignment = *(int32_t *)buf;</a>
<a name="ln1781">  buf += sizeof(int32_t);</a>
<a name="ln1782"> </a>
<a name="ln1783">  const char *media = buf;</a>
<a name="ln1784">  if (!media) return 1;</a>
<a name="ln1785">  const int32_t media_len = strlen(media) + 1;</a>
<a name="ln1786">  // buf += media_len;</a>
<a name="ln1787"> </a>
<a name="ln1788">  // ensure that the size is correct</a>
<a name="ln1789">  if(size != printer_len + paper_len + media_len + profile_len + pprofile_len + style_len + 8 * sizeof(int32_t) + 4 * sizeof(double))</a>
<a name="ln1790">    return 1;</a>
<a name="ln1791"> </a>
<a name="ln1792">  // set the GUI with corresponding values</a>
<a name="ln1793">  if (printer[0] != '\0')</a>
<a name="ln1794">    dt_bauhaus_combobox_set_from_text(ps-&gt;printers, printer);</a>
<a name="ln1795"> </a>
<a name="ln1796">  if (paper[0] != '\0')</a>
<a name="ln1797">    dt_bauhaus_combobox_set_from_text(ps-&gt;papers, paper);</a>
<a name="ln1798"> </a>
<a name="ln1799">  if (media[0] != '\0')</a>
<a name="ln1800">    dt_bauhaus_combobox_set_from_text(ps-&gt;media, media);</a>
<a name="ln1801"> </a>
<a name="ln1802">  dt_bauhaus_combobox_set (ps-&gt;orientation, landscape);</a>
<a name="ln1803"> </a>
<a name="ln1804">  dt_bauhaus_combobox_set(ps-&gt;profile, 0);</a>
<a name="ln1805">  for(GList *iter = ps-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln1806">  {</a>
<a name="ln1807">    dt_lib_export_profile_t *p = (dt_lib_export_profile_t *)iter-&gt;data;</a>
<a name="ln1808">    if(f_profile_type == p-&gt;type &amp;&amp; (f_profile_type != DT_COLORSPACE_FILE || !g_strcmp0(f_profile, p-&gt;filename)))</a>
<a name="ln1809">    {</a>
<a name="ln1810">      dt_bauhaus_combobox_set(ps-&gt;profile, p-&gt;pos);</a>
<a name="ln1811">      break;</a>
<a name="ln1812">    }</a>
<a name="ln1813">  }</a>
<a name="ln1814"> </a>
<a name="ln1815">  dt_bauhaus_combobox_set (ps-&gt;intent, intent);</a>
<a name="ln1816"> </a>
<a name="ln1817">  dt_bauhaus_combobox_set(ps-&gt;pprofile, 0);</a>
<a name="ln1818">  for(GList *iter = ps-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln1819">  {</a>
<a name="ln1820">    dt_lib_export_profile_t *p = (dt_lib_export_profile_t *)iter-&gt;data;</a>
<a name="ln1821">    if(f_pprofile_type == p-&gt;type &amp;&amp; (f_pprofile_type != DT_COLORSPACE_FILE || !g_strcmp0(f_pprofile, p-&gt;filename)))</a>
<a name="ln1822">    {</a>
<a name="ln1823">      dt_bauhaus_combobox_set(ps-&gt;pprofile, p-&gt;ppos);</a>
<a name="ln1824">      break;</a>
<a name="ln1825">    }</a>
<a name="ln1826">  }</a>
<a name="ln1827"> </a>
<a name="ln1828">  dt_bauhaus_combobox_set (ps-&gt;pintent, pintent);</a>
<a name="ln1829">  ps-&gt;prt.printer.intent = pintent;</a>
<a name="ln1830"> </a>
<a name="ln1831">  if (style[0] != '\0')</a>
<a name="ln1832">    dt_bauhaus_combobox_set_from_text(ps-&gt;style, style);</a>
<a name="ln1833">  dt_bauhaus_combobox_set (ps-&gt;style_mode, style_mode);</a>
<a name="ln1834"> </a>
<a name="ln1835">  gtk_spin_button_set_value (GTK_SPIN_BUTTON(ps-&gt;b_top), b_top * units[ps-&gt;unit]);</a>
<a name="ln1836">  gtk_spin_button_set_value (GTK_SPIN_BUTTON(ps-&gt;b_bottom), b_bottom * units[ps-&gt;unit]);</a>
<a name="ln1837">  gtk_spin_button_set_value (GTK_SPIN_BUTTON(ps-&gt;b_left), b_left * units[ps-&gt;unit]);</a>
<a name="ln1838">  gtk_spin_button_set_value (GTK_SPIN_BUTTON(ps-&gt;b_right), b_right * units[ps-&gt;unit]);</a>
<a name="ln1839"> </a>
<a name="ln1840">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;dtba[alignment]),TRUE);</a>
<a name="ln1841">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;black_point_compensation), bpc);</a>
<a name="ln1842"> </a>
<a name="ln1843">  return 0;</a>
<a name="ln1844">}</a>
<a name="ln1845"> </a>
<a name="ln1846">void *get_params(dt_lib_module_t *self, int *size)</a>
<a name="ln1847">{</a>
<a name="ln1848">  const dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1849"> </a>
<a name="ln1850">  // get the data</a>
<a name="ln1851">  const char *printer = dt_bauhaus_combobox_get_text(ps-&gt;printers);</a>
<a name="ln1852">  const char *paper = dt_bauhaus_combobox_get_text(ps-&gt;papers);</a>
<a name="ln1853">  const char *media = dt_bauhaus_combobox_get_text(ps-&gt;media);</a>
<a name="ln1854">  const int32_t profile_pos = dt_bauhaus_combobox_get(ps-&gt;profile);</a>
<a name="ln1855">  const int32_t intent =  dt_bauhaus_combobox_get(ps-&gt;intent);</a>
<a name="ln1856">  const char *style = dt_bauhaus_combobox_get_text(ps-&gt;style);</a>
<a name="ln1857">  const int32_t style_mode = dt_bauhaus_combobox_get(ps-&gt;style_mode);</a>
<a name="ln1858">  const int32_t pprofile_pos = dt_bauhaus_combobox_get(ps-&gt;pprofile);</a>
<a name="ln1859">  const int32_t pintent =  dt_bauhaus_combobox_get(ps-&gt;pintent);</a>
<a name="ln1860">  const int32_t landscape = dt_bauhaus_combobox_get(ps-&gt;orientation);</a>
<a name="ln1861">  const int32_t bpc = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ps-&gt;black_point_compensation));</a>
<a name="ln1862">  const double b_top = ps-&gt;prt.page.margin_top;</a>
<a name="ln1863">  const double b_bottom = ps-&gt;prt.page.margin_bottom;</a>
<a name="ln1864">  const double b_left = ps-&gt;prt.page.margin_left;</a>
<a name="ln1865">  const double b_right = ps-&gt;prt.page.margin_right;</a>
<a name="ln1866">  const int32_t alignment = ps-&gt;prt.page.alignment;</a>
<a name="ln1867"> </a>
<a name="ln1868">  dt_colorspaces_color_profile_type_t profile_type = DT_COLORSPACE_NONE, pprofile_type = DT_COLORSPACE_NONE;</a>
<a name="ln1869">  const char *profile = &quot;&quot;, *pprofile = &quot;&quot;;</a>
<a name="ln1870">  for(GList *iter = ps-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln1871">  {</a>
<a name="ln1872">    dt_lib_export_profile_t *p = (dt_lib_export_profile_t *)iter-&gt;data;</a>
<a name="ln1873">    if(p-&gt;pos == profile_pos)</a>
<a name="ln1874">    {</a>
<a name="ln1875">      profile_type = p-&gt;type;</a>
<a name="ln1876">      profile = p-&gt;filename;</a>
<a name="ln1877">    }</a>
<a name="ln1878">    if(p-&gt;ppos == pprofile_pos)</a>
<a name="ln1879">    {</a>
<a name="ln1880">      pprofile_type = p-&gt;type;</a>
<a name="ln1881">      pprofile = p-&gt;filename;</a>
<a name="ln1882">    }</a>
<a name="ln1883">  }</a>
<a name="ln1884"> </a>
<a name="ln1885">  // these will be NULL when no printer is connected/found</a>
<a name="ln1886">  if(!printer) printer = &quot;&quot;;</a>
<a name="ln1887">  if(!paper) paper = &quot;&quot;;</a>
<a name="ln1888">  if(!media) media = &quot;&quot;;</a>
<a name="ln1889"> </a>
<a name="ln1890">  // compute the size of individual items, always get the \0 for strings</a>
<a name="ln1891">  const int32_t printer_len = strlen (printer) + 1;</a>
<a name="ln1892">  const int32_t paper_len = strlen (paper) + 1;</a>
<a name="ln1893">  const int32_t media_len = strlen (media) + 1;</a>
<a name="ln1894">  const int32_t profile_len = strlen (profile) + 1;</a>
<a name="ln1895">  const int32_t pprofile_len = strlen (pprofile) + 1;</a>
<a name="ln1896">  const int32_t style_len = strlen (style) + 1;</a>
<a name="ln1897"> </a>
<a name="ln1898">  // compute the size of all parameters</a>
<a name="ln1899">  *size = printer_len + paper_len + media_len + profile_len + pprofile_len + style_len + 8 * sizeof(int32_t) + 4 * sizeof(double);</a>
<a name="ln1900"> </a>
<a name="ln1901">  // allocate the parameter buffer</a>
<a name="ln1902">  char *params = (char *)malloc(*size);</a>
<a name="ln1903"> </a>
<a name="ln1904">  int pos = 0;</a>
<a name="ln1905"> </a>
<a name="ln1906">  memcpy(params+pos, printer, printer_len);</a>
<a name="ln1907">  pos += printer_len;</a>
<a name="ln1908">  memcpy(params+pos, paper, paper_len);</a>
<a name="ln1909">  pos += paper_len;</a>
<a name="ln1910">  memcpy(params+pos, &amp;landscape, sizeof(int32_t));</a>
<a name="ln1911">  pos += sizeof(int32_t);</a>
<a name="ln1912">  memcpy(params+pos, &amp;profile_type, sizeof(int32_t));</a>
<a name="ln1913">  pos += sizeof(int32_t);</a>
<a name="ln1914">  memcpy(params+pos, profile, profile_len);</a>
<a name="ln1915">  pos += profile_len;</a>
<a name="ln1916">  memcpy(params+pos, &amp;intent, sizeof(int32_t));</a>
<a name="ln1917">  pos += sizeof(int32_t);</a>
<a name="ln1918">  memcpy(params+pos, &amp;pprofile_type, sizeof(int32_t));</a>
<a name="ln1919">  pos += sizeof(int32_t);</a>
<a name="ln1920">  memcpy(params+pos, pprofile, pprofile_len);</a>
<a name="ln1921">  pos += pprofile_len;</a>
<a name="ln1922">  memcpy(params+pos, &amp;pintent, sizeof(int32_t));</a>
<a name="ln1923">  pos += sizeof(int32_t);</a>
<a name="ln1924">  memcpy(params+pos, &amp;bpc, sizeof(int32_t));</a>
<a name="ln1925">  pos += sizeof(int32_t);</a>
<a name="ln1926">  memcpy(params+pos, style, style_len);</a>
<a name="ln1927">  pos += style_len;</a>
<a name="ln1928">  memcpy(params+pos, &amp;style_mode, sizeof(int32_t));</a>
<a name="ln1929">  pos += sizeof(int32_t);</a>
<a name="ln1930">  memcpy(params+pos, &amp;b_top, sizeof(double));</a>
<a name="ln1931">  pos += sizeof(double);</a>
<a name="ln1932">  memcpy(params+pos, &amp;b_bottom, sizeof(double));</a>
<a name="ln1933">  pos += sizeof(double);</a>
<a name="ln1934">  memcpy(params+pos, &amp;b_left, sizeof(double));</a>
<a name="ln1935">  pos += sizeof(double);</a>
<a name="ln1936">  memcpy(params+pos, &amp;b_right, sizeof(double));</a>
<a name="ln1937">  pos += sizeof(double);</a>
<a name="ln1938">  memcpy(params+pos, &amp;alignment, sizeof(int32_t));</a>
<a name="ln1939">  pos += sizeof(int32_t);</a>
<a name="ln1940">  memcpy(params+pos, media, media_len);</a>
<a name="ln1941">  pos += media_len;</a>
<a name="ln1942"> </a>
<a name="ln1943">  g_assert(pos == *size);</a>
<a name="ln1944"> </a>
<a name="ln1945">  return params;</a>
<a name="ln1946">}</a>
<a name="ln1947"> </a>
<a name="ln1948">void</a>
<a name="ln1949">gui_cleanup (dt_lib_module_t *self)</a>
<a name="ln1950">{</a>
<a name="ln1951">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1952"> </a>
<a name="ln1953">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ps-&gt;b_top));</a>
<a name="ln1954">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ps-&gt;b_left));</a>
<a name="ln1955">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ps-&gt;b_right));</a>
<a name="ln1956">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ps-&gt;b_bottom));</a>
<a name="ln1957"> </a>
<a name="ln1958">  g_list_free_full(ps-&gt;profiles, g_free);</a>
<a name="ln1959">  g_list_free_full(ps-&gt;paper_list, free);</a>
<a name="ln1960">  g_list_free_full(ps-&gt;media_list, free);</a>
<a name="ln1961"> </a>
<a name="ln1962">  g_free(ps-&gt;v_iccprofile);</a>
<a name="ln1963">  g_free(ps-&gt;v_piccprofile);</a>
<a name="ln1964">  g_free(ps-&gt;v_style);</a>
<a name="ln1965"> </a>
<a name="ln1966">  free(self-&gt;data);</a>
<a name="ln1967">  self-&gt;data = NULL;</a>
<a name="ln1968">}</a>
<a name="ln1969"> </a>
<a name="ln1970">void</a>
<a name="ln1971">gui_reset (dt_lib_module_t *self)</a>
<a name="ln1972">{</a>
<a name="ln1973">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1974"> </a>
<a name="ln1975">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_top), 17 * units[ps-&gt;unit]);</a>
<a name="ln1976">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), 17 * units[ps-&gt;unit]);</a>
<a name="ln1977">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left), 17 * units[ps-&gt;unit]);</a>
<a name="ln1978">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right), 17 * units[ps-&gt;unit]);</a>
<a name="ln1979">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;dtba[ALIGNMENT_CENTER]), TRUE);</a>
<a name="ln1980">  ps-&gt;prt.page.alignment = ALIGNMENT_CENTER;</a>
<a name="ln1981">  ps-&gt;prt.printer.intent = DT_INTENT_PERCEPTUAL;</a>
<a name="ln1982">  dt_bauhaus_combobox_set(ps-&gt;profile, 0);</a>
<a name="ln1983">  dt_bauhaus_combobox_set(ps-&gt;pprofile, 0);</a>
<a name="ln1984">  dt_bauhaus_combobox_set(ps-&gt;pintent, 0);</a>
<a name="ln1985">  dt_bauhaus_combobox_set(ps-&gt;style, 0);</a>
<a name="ln1986">  dt_bauhaus_combobox_set(ps-&gt;intent, 0);</a>
<a name="ln1987">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;black_point_compensation), TRUE);</a>
<a name="ln1988">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;pintent), TRUE);</a>
<a name="ln1989">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;black_point_compensation), FALSE);</a>
<a name="ln1990">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;style_mode), FALSE);</a>
<a name="ln1991"> </a>
<a name="ln1992">  // reset page orientation to fit the picture</a>
<a name="ln1993"> </a>
<a name="ln1994">  _set_orientation (ps);</a>
<a name="ln1995">}</a>
<a name="ln1996"> </a>
<a name="ln1997">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln1998">{</a>
<a name="ln1999">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;print&quot;), GDK_KEY_p, GDK_CONTROL_MASK);</a>
<a name="ln2000">}</a>
<a name="ln2001"> </a>
<a name="ln2002">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln2003">{</a>
<a name="ln2004">  dt_lib_print_settings_t *d = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln2005"> </a>
<a name="ln2006">  dt_accel_connect_button_lib(self, &quot;print&quot;, GTK_WIDGET(d-&gt;print_button));</a>
<a name="ln2007">}</a>
<a name="ln2008"> </a>
<a name="ln2009">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2010">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2011">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="165"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 165, 156.</p></div>
<div class="balloon" rel="175"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 175, 156.</p></div>
<div class="balloon" rel="412"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'params'. Check lines: 412, 409.</p></div>
<div class="balloon" rel="1127"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 1127, 1113.</p></div>
<div class="balloon" rel="1206"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: prof->type != DT_COLORSPACE_FILE.</p></div>
<div class="balloon" rel="1491"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="1664"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'new_params' pointer in the 'new_params + pos' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 1664, 1660.</p></div>
<div class="balloon" rel="1700"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1700, 1698.</p></div>
<div class="balloon" rel="1723"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!printer' is always false.</p></div>
<div class="balloon" rel="1728"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!paper' is always false.</p></div>
<div class="balloon" rel="1739"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!f_profile' is always false.</p></div>
<div class="balloon" rel="1750"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!f_pprofile' is always false.</p></div>
<div class="balloon" rel="1761"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!style' is always false.</p></div>
<div class="balloon" rel="1784"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!media' is always false.</p></div>
<div class="balloon" rel="1906"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'params' pointer in the 'params + pos' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 1906, 1902.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
