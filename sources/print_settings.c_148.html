
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2014-2017 pascal obry.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;glib.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln22">#include &quot;common/collection.h&quot;</a>
<a name="ln23">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln24">#include &quot;common/cups_print.h&quot;</a>
<a name="ln25">#include &quot;common/image_cache.h&quot;</a>
<a name="ln26">#include &quot;common/metadata.h&quot;</a>
<a name="ln27">#include &quot;common/pdf.h&quot;</a>
<a name="ln28">#include &quot;common/printprof.h&quot;</a>
<a name="ln29">#include &quot;common/styles.h&quot;</a>
<a name="ln30">#include &quot;common/tags.h&quot;</a>
<a name="ln31">#include &quot;common/variables.h&quot;</a>
<a name="ln32">#include &quot;control/jobs.h&quot;</a>
<a name="ln33">#include &quot;dtgtk/resetlabel.h&quot;</a>
<a name="ln34">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln35">#include &quot;gui/gtk.h&quot;</a>
<a name="ln36">#include &quot;libs/lib.h&quot;</a>
<a name="ln37">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">DT_MODULE(3)</a>
<a name="ln40"> </a>
<a name="ln41">static gboolean _bauhaus_combobox_set_active_text(GtkWidget *cb, const gchar *text);</a>
<a name="ln42"> </a>
<a name="ln43">const char *name(dt_lib_module_t *self)</a>
<a name="ln44">{</a>
<a name="ln45">  return _(&quot;print settings&quot;);</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48">const char **views(dt_lib_module_t *self)</a>
<a name="ln49">{</a>
<a name="ln50">  static const char *v[] = {&quot;print&quot;, NULL};</a>
<a name="ln51">  return v;</a>
<a name="ln52">}</a>
<a name="ln53"> </a>
<a name="ln54">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln55">{</a>
<a name="ln56">  return DT_UI_CONTAINER_PANEL_RIGHT_CENTER;</a>
<a name="ln57">}</a>
<a name="ln58"> </a>
<a name="ln59">typedef struct dt_lib_print_settings_t</a>
<a name="ln60">{</a>
<a name="ln61">  GtkWidget *profile, *intent, *style, *style_mode, *papers, *media;</a>
<a name="ln62">  GtkWidget *printers, *orientation, *pprofile, *pintent;</a>
<a name="ln63">  GtkWidget *width, *height, *black_point_compensation;</a>
<a name="ln64">  GtkWidget *info;</a>
<a name="ln65">  GList *profiles;</a>
<a name="ln66">  GtkButton *print_button;</a>
<a name="ln67">  GtkToggleButton *lock_button;</a>
<a name="ln68">  GtkWidget *b_top, *b_bottom, *b_left, *b_right;</a>
<a name="ln69">  GtkDarktableToggleButton *dtba[9];	                                   // Alignment buttons</a>
<a name="ln70">  GList *paper_list, *media_list;</a>
<a name="ln71">  gboolean lock_activated;</a>
<a name="ln72">  dt_print_info_t prt;</a>
<a name="ln73">  int32_t image_id;</a>
<a name="ln74">  int32_t iwidth, iheight;</a>
<a name="ln75">  int unit;</a>
<a name="ln76">  int v_intent, v_pintent;</a>
<a name="ln77">  int v_icctype, v_picctype;</a>
<a name="ln78">  char *v_iccprofile, *v_piccprofile, *v_style;</a>
<a name="ln79">  gboolean v_style_append, v_black_point_compensation;</a>
<a name="ln80">} dt_lib_print_settings_t;</a>
<a name="ln81"> </a>
<a name="ln82">typedef struct dt_lib_print_job_t</a>
<a name="ln83">{</a>
<a name="ln84">  int imgid;</a>
<a name="ln85">  gchar *job_title;</a>
<a name="ln86">  dt_print_info_t prt;</a>
<a name="ln87">  gchar* style;</a>
<a name="ln88">  gboolean style_append, black_point_compensation;</a>
<a name="ln89">  dt_colorspaces_color_profile_type_t buf_icc_type, p_icc_type;</a>
<a name="ln90">  gchar *buf_icc_profile, *p_icc_profile;</a>
<a name="ln91">  dt_iop_color_intent_t buf_icc_intent, p_icc_intent;</a>
<a name="ln92">  uint16_t *buf;</a>
<a name="ln93">  dt_pdf_page_t *pdf_page;</a>
<a name="ln94">  dt_pdf_image_t *pdf_image;</a>
<a name="ln95">  char pdf_filename[PATH_MAX];</a>
<a name="ln96">} dt_lib_print_job_t;</a>
<a name="ln97"> </a>
<a name="ln98">typedef struct dt_lib_export_profile_t</a>
<a name="ln99">{</a>
<a name="ln100">  dt_colorspaces_color_profile_type_t type; // filename is only used for type DT_COLORSPACE_FILE</a>
<a name="ln101">  char filename[512];                       // icc file name</a>
<a name="ln102">  char name[512];                           // product name</a>
<a name="ln103">  int  pos, ppos;                           // position in combo boxen</a>
<a name="ln104">} dt_lib_export_profile_t;</a>
<a name="ln105"> </a>
<a name="ln106">typedef struct _dialog_description</a>
<a name="ln107">{</a>
<a name="ln108">  const char *name;</a>
<a name="ln109">} dialog_description_t;</a>
<a name="ln110"> </a>
<a name="ln111">static double units[3] = {1.0, 0.1, 1.0/25.4};</a>
<a name="ln112"> </a>
<a name="ln113">static void _update_slider (dt_lib_print_settings_t *ps);</a>
<a name="ln114"> </a>
<a name="ln115">static const int min_borders = -100; // this is in mm</a>
<a name="ln116"> </a>
<a name="ln117">int</a>
<a name="ln118">position ()</a>
<a name="ln119">{</a>
<a name="ln120">  return 990;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">// callbacks for in-memory export</a>
<a name="ln124"> </a>
<a name="ln125">typedef struct dt_print_format_t</a>
<a name="ln126">{</a>
<a name="ln127">  int max_width, max_height;</a>
<a name="ln128">  int width, height;</a>
<a name="ln129">  char style[128];</a>
<a name="ln130">  gboolean style_append;</a>
<a name="ln131">  int bpp;</a>
<a name="ln132">  dt_lib_print_job_t *params;</a>
<a name="ln133">} dt_print_format_t;</a>
<a name="ln134"> </a>
<a name="ln135">static int bpp(dt_imageio_module_data_t *data)</a>
<a name="ln136">{</a>
<a name="ln137">  const dt_print_format_t *d = (dt_print_format_t *)data;</a>
<a name="ln138">  return d-&gt;bpp;</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141">static int levels(dt_imageio_module_data_t *data)</a>
<a name="ln142">{</a>
<a name="ln143">  const dt_print_format_t *d = (dt_print_format_t *)data;</a>
<a name="ln144">  return IMAGEIO_RGB | (d-&gt;bpp == 8 ? IMAGEIO_INT8 : IMAGEIO_INT16);</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">static const char *mime(dt_imageio_module_data_t *data)</a>
<a name="ln148">{</a>
<a name="ln149">  return &quot;memory&quot;;</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">static int write_image(dt_imageio_module_data_t *data, const char *filename, const void *in,</a>
<a name="ln153">                       dt_colorspaces_color_profile_type_t over_type, const char *over_filename,</a>
<a name="ln154">                       void *exif, int exif_len, int imgid, int num, int total, dt_dev_pixelpipe_t *pipe)</a>
<a name="ln155">{</a>
<a name="ln156">  dt_print_format_t *d = (dt_print_format_t *)data;</a>
<a name="ln157"> </a>
<a name="ln158">  d-&gt;params-&gt;buf = (uint16_t *)malloc(d-&gt;width * d-&gt;height * 3 * (d-&gt;bpp == 8?1:2));</a>
<a name="ln159"> </a>
<a name="ln160">  if (d-&gt;bpp == 8)</a>
<a name="ln161">  {</a>
<a name="ln162">    const uint8_t *in_ptr = (const uint8_t *)in;</a>
<a name="ln163">    uint8_t *out_ptr = (uint8_t *)d-&gt;params-&gt;buf;</a>
<a name="ln164">    for(int y = 0; y &lt; d-&gt;height; y++)</a>
<a name="ln165">    {</a>
<a name="ln166">      for(int x = 0; x &lt; d-&gt;width; x++, in_ptr += 4, out_ptr += 3)</a>
<a name="ln167">        memcpy(out_ptr, in_ptr, 3);</a>
<a name="ln168">    }</a>
<a name="ln169">  }</a>
<a name="ln170">  else</a>
<a name="ln171">  {</a>
<a name="ln172">    const uint16_t *in_ptr = (const uint16_t *)in;</a>
<a name="ln173">    uint16_t *out_ptr = (uint16_t *)d-&gt;params-&gt;buf;</a>
<a name="ln174">    for(int y = 0; y &lt; d-&gt;height; y++)</a>
<a name="ln175">    {</a>
<a name="ln176">      for(int x = 0; x &lt; d-&gt;width; x++, in_ptr += 4, out_ptr += 3)</a>
<a name="ln177">        memcpy(out_ptr, in_ptr, 6);</a>
<a name="ln178">    }</a>
<a name="ln179">  }</a>
<a name="ln180"> </a>
<a name="ln181">  return 0;</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">static int _print_job_run(dt_job_t *job)</a>
<a name="ln185">{</a>
<a name="ln186">  dt_lib_print_job_t *params = dt_control_job_get_params(job);</a>
<a name="ln187"> </a>
<a name="ln188">  // user margin are already in the proper orientation landscape/portrait</a>
<a name="ln189">  double width, height;</a>
<a name="ln190">  double margin_w = params-&gt;prt.page.margin_left + params-&gt;prt.page.margin_right;</a>
<a name="ln191">  double margin_h = params-&gt;prt.page.margin_top + params-&gt;prt.page.margin_bottom;</a>
<a name="ln192"> </a>
<a name="ln193">  if (params-&gt;prt.page.landscape)</a>
<a name="ln194">  {</a>
<a name="ln195">    width = params-&gt;prt.paper.height;</a>
<a name="ln196">    height = params-&gt;prt.paper.width;</a>
<a name="ln197">    margin_w += params-&gt;prt.printer.hw_margin_top + params-&gt;prt.printer.hw_margin_bottom;</a>
<a name="ln198">    margin_h += params-&gt;prt.printer.hw_margin_left + params-&gt;prt.printer.hw_margin_right;</a>
<a name="ln199">  }</a>
<a name="ln200">  else</a>
<a name="ln201">  {</a>
<a name="ln202">    width = params-&gt;prt.paper.width;</a>
<a name="ln203">    height = params-&gt;prt.paper.height;</a>
<a name="ln204">    margin_w += params-&gt;prt.printer.hw_margin_left + params-&gt;prt.printer.hw_margin_right;</a>
<a name="ln205">    margin_h += params-&gt;prt.printer.hw_margin_top + params-&gt;prt.printer.hw_margin_bottom;</a>
<a name="ln206">  }</a>
<a name="ln207"> </a>
<a name="ln208">  const int32_t width_pix = (width * params-&gt;prt.printer.resolution) / 25.4;</a>
<a name="ln209">  const int32_t height_pix = (height * params-&gt;prt.printer.resolution) / 25.4;</a>
<a name="ln210"> </a>
<a name="ln211">  const double pa_width  = (width  - margin_w) / 25.4;</a>
<a name="ln212">  const double pa_height = (height - margin_h) / 25.4;</a>
<a name="ln213"> </a>
<a name="ln214">  dt_print(DT_DEBUG_PRINT, &quot;[print] printable area for image %u : %3.2fin x %3.2fin\n&quot;, params-&gt;imgid, pa_width, pa_height);</a>
<a name="ln215"> </a>
<a name="ln216">  // compute the needed size for picture for the given printer resolution</a>
<a name="ln217"> </a>
<a name="ln218">  const int max_width  = (pa_width  * params-&gt;prt.printer.resolution);</a>
<a name="ln219">  const int max_height = (pa_height * params-&gt;prt.printer.resolution);</a>
<a name="ln220"> </a>
<a name="ln221">  dt_print(DT_DEBUG_PRINT, &quot;[print] max image size %d x %d (at resolution %d)\n&quot;, max_width, max_height, params-&gt;prt.printer.resolution);</a>
<a name="ln222"> </a>
<a name="ln223">  dt_imageio_module_format_t buf;</a>
<a name="ln224">  buf.mime = mime;</a>
<a name="ln225">  buf.levels = levels;</a>
<a name="ln226">  buf.bpp = bpp;</a>
<a name="ln227">  buf.write_image = write_image;</a>
<a name="ln228"> </a>
<a name="ln229">  dt_print_format_t dat;</a>
<a name="ln230">  dat.max_width = max_width;</a>
<a name="ln231">  dat.max_height = max_height;</a>
<a name="ln232">  dat.style[0] = '\0';</a>
<a name="ln233">  dat.style_append = params-&gt;style_append;</a>
<a name="ln234">  dat.bpp = *params-&gt;p_icc_profile ? 16 : 8; // set to 16bit when a profile is to be applied</a>
<a name="ln235">  dat.params = params;</a>
<a name="ln236"> </a>
<a name="ln237">  if (params-&gt;style) g_strlcpy(dat.style, params-&gt;style, sizeof(dat.style));</a>
<a name="ln238"> </a>
<a name="ln239">  // let the user know something is happening</a>
<a name="ln240">  dt_control_job_set_progress(job, 0.05);</a>
<a name="ln241">  dt_control_log(_(&quot;processing `%s' for `%s'&quot;), params-&gt;job_title, params-&gt;prt.printer.name);</a>
<a name="ln242"> </a>
<a name="ln243">  const gboolean high_quality = TRUE;</a>
<a name="ln244">  const gboolean upscale = TRUE;</a>
<a name="ln245">  const dt_colorspaces_color_profile_t *buf_profile = dt_colorspaces_get_output_profile(params-&gt;imgid,</a>
<a name="ln246">                                                                                        params-&gt;buf_icc_type,</a>
<a name="ln247">                                                                                        params-&gt;buf_icc_profile);</a>
<a name="ln248"> </a>
<a name="ln249">  dt_imageio_export_with_flags(params-&gt;imgid, &quot;unused&quot;, &amp;buf, (dt_imageio_module_data_t *)&amp;dat, TRUE, FALSE,</a>
<a name="ln250">                               high_quality, upscale, FALSE, NULL, FALSE, params-&gt;buf_icc_type, params-&gt;buf_icc_profile,</a>
<a name="ln251">                               params-&gt;buf_icc_intent,  NULL, NULL, 1, 1);</a>
<a name="ln252"> </a>
<a name="ln253">  // after exporting we know the real size of the image, compute the layout</a>
<a name="ln254"> </a>
<a name="ln255">  // compute print-area (in inches)</a>
<a name="ln256">  int32_t px=0, py=0, pwidth=0, pheight=0;</a>
<a name="ln257">  int32_t ax=0, ay=0, awidth=0, aheight=0;</a>
<a name="ln258">  int32_t ix=0, iy=0, iwidth=0, iheight=0;</a>
<a name="ln259">  int32_t iwpix=dat.width, ihpix=dat.height;</a>
<a name="ln260"> </a>
<a name="ln261">  dt_get_print_layout (params-&gt;imgid, &amp;params-&gt;prt, width_pix, height_pix,</a>
<a name="ln262">                       &amp;iwpix, &amp;ihpix,</a>
<a name="ln263">                       &amp;px, &amp;py, &amp;pwidth, &amp;pheight,</a>
<a name="ln264">                       &amp;ax, &amp;ay, &amp;awidth, &amp;aheight,</a>
<a name="ln265">                       &amp;ix, &amp;iy, &amp;iwidth, &amp;iheight);</a>
<a name="ln266"> </a>
<a name="ln267">  const int margin_top    = iy;</a>
<a name="ln268">  const int margin_left   = ix;</a>
<a name="ln269">  const int margin_right  = pwidth - iwidth - ix;</a>
<a name="ln270">  const int margin_bottom = pheight - iheight - iy;</a>
<a name="ln271"> </a>
<a name="ln272">  dt_print(DT_DEBUG_PRINT, &quot;[print] margins top %d ; bottom %d ; left %d ; right %d\n&quot;,</a>
<a name="ln273">           margin_top, margin_bottom, margin_left, margin_right);</a>
<a name="ln274"> </a>
<a name="ln275">  // we have the exported buffer, let's apply the printer profile</a>
<a name="ln276"> </a>
<a name="ln277">  if (*params-&gt;p_icc_profile)</a>
<a name="ln278">  {</a>
<a name="ln279">    const dt_colorspaces_color_profile_t *pprof = dt_colorspaces_get_profile(params-&gt;p_icc_type, params-&gt;p_icc_profile,</a>
<a name="ln280">                                                                             DT_PROFILE_DIRECTION_OUT);</a>
<a name="ln281">    if (!pprof)</a>
<a name="ln282">    {</a>
<a name="ln283">      dt_control_log(_(&quot;cannot open printer profile `%s'&quot;), params-&gt;p_icc_profile);</a>
<a name="ln284">      fprintf(stderr, &quot;cannot open printer profile `%s'\n&quot;, params-&gt;p_icc_profile);</a>
<a name="ln285">      dt_control_queue_redraw();</a>
<a name="ln286">      return 1;</a>
<a name="ln287">    }</a>
<a name="ln288">    else</a>
<a name="ln289">    {</a>
<a name="ln290">      if(!buf_profile || !buf_profile-&gt;profile)</a>
<a name="ln291">      {</a>
<a name="ln292">        dt_control_log(_(&quot;error getting output profile for image %d&quot;), params-&gt;imgid);</a>
<a name="ln293">        fprintf(stderr, &quot;error getting output profile for image %d\n&quot;, params-&gt;imgid);</a>
<a name="ln294">        dt_control_queue_redraw();</a>
<a name="ln295">        return 1;</a>
<a name="ln296">      }</a>
<a name="ln297">      if (dt_apply_printer_profile((void **)&amp;(params-&gt;buf), dat.width, dat.height, dat.bpp, buf_profile-&gt;profile,</a>
<a name="ln298">                                   pprof-&gt;profile, params-&gt;p_icc_intent, params-&gt;black_point_compensation))</a>
<a name="ln299">      {</a>
<a name="ln300">        dt_control_log(_(&quot;cannot apply printer profile `%s'&quot;), params-&gt;p_icc_profile);</a>
<a name="ln301">        fprintf(stderr, &quot;cannot apply printer profile `%s'\n&quot;, params-&gt;p_icc_profile);</a>
<a name="ln302">        dt_control_queue_redraw();</a>
<a name="ln303">        return 1;</a>
<a name="ln304">      }</a>
<a name="ln305">    }</a>
<a name="ln306">  }</a>
<a name="ln307"> </a>
<a name="ln308">  const float page_width  = dt_pdf_mm_to_point(width);</a>
<a name="ln309">  const float page_height = dt_pdf_mm_to_point(height);</a>
<a name="ln310"> </a>
<a name="ln311">  if(dt_control_job_get_state(job) == DT_JOB_STATE_CANCELLED) return 0;</a>
<a name="ln312">  dt_control_job_set_progress(job, 0.9);</a>
<a name="ln313"> </a>
<a name="ln314">  dt_loc_get_tmp_dir(params-&gt;pdf_filename, sizeof(params-&gt;pdf_filename));</a>
<a name="ln315">  g_strlcat(params-&gt;pdf_filename, &quot;/pf.XXXXXX.pdf&quot;, sizeof(params-&gt;pdf_filename));</a>
<a name="ln316"> </a>
<a name="ln317">  gint fd = g_mkstemp(params-&gt;pdf_filename);</a>
<a name="ln318">  if(fd == -1)</a>
<a name="ln319">  {</a>
<a name="ln320">    dt_control_log(_(&quot;failed to create temporary pdf for printing&quot;));</a>
<a name="ln321">    fprintf(stderr, &quot;failed to create temporary pdf for printing\n&quot;);</a>
<a name="ln322">    return 1;</a>
<a name="ln323">  }</a>
<a name="ln324">  close(fd);</a>
<a name="ln325"> </a>
<a name="ln326">  const int icc_id = 0;</a>
<a name="ln327"> </a>
<a name="ln328">  dt_pdf_t *pdf = dt_pdf_start(params-&gt;pdf_filename, page_width, page_height, params-&gt;prt.printer.resolution, DT_PDF_STREAM_ENCODER_FLATE);</a>
<a name="ln329"> </a>
<a name="ln330">/*</a>
<a name="ln331">  // ??? should a profile be embedded here?</a>
<a name="ln332">  if (*printer_profile)</a>
<a name="ln333">    icc_id = dt_pdf_add_icc(pdf, printer_profile);</a>
<a name="ln334">*/</a>
<a name="ln335">  params-&gt;pdf_image = dt_pdf_add_image(pdf, (uint8_t *)params-&gt;buf, dat.width, dat.height, 8, icc_id, 0.0);</a>
<a name="ln336"> </a>
<a name="ln337">  //  PDF bounding-box has origin on bottom-left</a>
<a name="ln338">  params-&gt;pdf_image-&gt;bb_x      = dt_pdf_pixel_to_point((float)margin_left, params-&gt;prt.printer.resolution);</a>
<a name="ln339">  params-&gt;pdf_image-&gt;bb_y      = dt_pdf_pixel_to_point((float)margin_bottom, params-&gt;prt.printer.resolution);</a>
<a name="ln340">  params-&gt;pdf_image-&gt;bb_width  = dt_pdf_pixel_to_point((float)iwidth, params-&gt;prt.printer.resolution);</a>
<a name="ln341">  params-&gt;pdf_image-&gt;bb_height = dt_pdf_pixel_to_point((float)iheight, params-&gt;prt.printer.resolution);</a>
<a name="ln342"> </a>
<a name="ln343">  if (params-&gt;prt.page.landscape &amp;&amp; (dat.width &gt; dat.height))</a>
<a name="ln344">    params-&gt;pdf_image-&gt;rotate_to_fit = TRUE;</a>
<a name="ln345">  else</a>
<a name="ln346">    params-&gt;pdf_image-&gt;rotate_to_fit = FALSE;</a>
<a name="ln347"> </a>
<a name="ln348">  params-&gt;pdf_page = dt_pdf_add_page(pdf, &amp;params-&gt;pdf_image, 1);</a>
<a name="ln349">  dt_pdf_finish(pdf, &amp;params-&gt;pdf_page, 1);</a>
<a name="ln350"> </a>
<a name="ln351">  if(dt_control_job_get_state(job) == DT_JOB_STATE_CANCELLED) return 0;</a>
<a name="ln352">  dt_control_job_set_progress(job, 0.95);</a>
<a name="ln353"> </a>
<a name="ln354">  // send to CUPS</a>
<a name="ln355"> </a>
<a name="ln356">  dt_print_file (params-&gt;imgid, params-&gt;pdf_filename, params-&gt;job_title, &amp;params-&gt;prt);</a>
<a name="ln357">  dt_control_job_set_progress(job, 1.0);</a>
<a name="ln358"> </a>
<a name="ln359">  // add tag for this image</a>
<a name="ln360"> </a>
<a name="ln361">  char tag[256] = { 0 };</a>
<a name="ln362">  guint tagid = 0;</a>
<a name="ln363">  snprintf (tag, sizeof(tag), &quot;darktable|printed|%s&quot;, params-&gt;prt.printer.name);</a>
<a name="ln364">  dt_tag_new(tag, &amp;tagid);</a>
<a name="ln365">  dt_tag_attach(tagid, params-&gt;imgid);</a>
<a name="ln366"> </a>
<a name="ln367">  return 0;</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">static void _print_job_cleanup(void *p)</a>
<a name="ln371">{</a>
<a name="ln372">  dt_lib_print_job_t *params = p;</a>
<a name="ln373">  if(params-&gt;pdf_filename[0]) g_unlink(params-&gt;pdf_filename);</a>
<a name="ln374">  free(params-&gt;pdf_image);</a>
<a name="ln375">  free(params-&gt;pdf_page);</a>
<a name="ln376">  free(params-&gt;buf);</a>
<a name="ln377">  g_free(params-&gt;style);</a>
<a name="ln378">  g_free(params-&gt;buf_icc_profile);</a>
<a name="ln379">  g_free(params-&gt;p_icc_profile);</a>
<a name="ln380">  g_free(params-&gt;job_title);</a>
<a name="ln381">  free(params);</a>
<a name="ln382">}</a>
<a name="ln383"> </a>
<a name="ln384">static void</a>
<a name="ln385">_print_button_clicked (GtkWidget *widget, gpointer user_data)</a>
<a name="ln386">{</a>
<a name="ln387">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln388">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln389"> </a>
<a name="ln390">  const int imgid = dt_view_filmstrip_get_activated_imgid(darktable.view_manager);</a>
<a name="ln391"> </a>
<a name="ln392">  if (imgid == -1)</a>
<a name="ln393">  {</a>
<a name="ln394">    dt_control_log(_(&quot;cannot print until a picture is selected&quot;));</a>
<a name="ln395">    return;</a>
<a name="ln396">  }</a>
<a name="ln397">  if (strlen(ps-&gt;prt.printer.name) == 0 || ps-&gt;prt.printer.resolution == 0)</a>
<a name="ln398">  {</a>
<a name="ln399">    dt_control_log(_(&quot;cannot print until a printer is selected&quot;));</a>
<a name="ln400">    return;</a>
<a name="ln401">  }</a>
<a name="ln402">  if (ps-&gt;prt.paper.width == 0 || ps-&gt;prt.paper.height == 0)</a>
<a name="ln403">  {</a>
<a name="ln404">    dt_control_log(_(&quot;cannot print until a paper is selected&quot;));</a>
<a name="ln405">    return;</a>
<a name="ln406">  }</a>
<a name="ln407"> </a>
<a name="ln408">  dt_job_t *job = dt_control_job_create(&amp;_print_job_run, &quot;print image %d&quot;, imgid);</a>
<a name="ln409">  if(!job) return;</a>
<a name="ln410"> </a>
<a name="ln411">  dt_lib_print_job_t *params = calloc(1, sizeof(dt_lib_print_job_t));</a>
<a name="ln412">  dt_control_job_set_params(job, params, _print_job_cleanup);</a>
<a name="ln413"> </a>
<a name="ln414">  params-&gt;imgid = imgid;</a>
<a name="ln415">  memcpy(&amp;params-&gt;prt, &amp;ps-&gt;prt, sizeof(dt_print_info_t));</a>
<a name="ln416"> </a>
<a name="ln417">  // what to call the image?</a>
<a name="ln418">  GList *res;</a>
<a name="ln419">  if((res = dt_metadata_get(params-&gt;imgid, &quot;Xmp.dc.title&quot;, NULL)) != NULL)</a>
<a name="ln420">  {</a>
<a name="ln421">    // FIXME: in metadata_view.c, non-printables are filtered, should we do this here?</a>
<a name="ln422">    params-&gt;job_title = g_strdup((gchar *)res-&gt;data);</a>
<a name="ln423">    g_list_free_full(res, &amp;g_free);</a>
<a name="ln424">  }</a>
<a name="ln425">  else</a>
<a name="ln426">  {</a>
<a name="ln427">    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, params-&gt;imgid, 'r');</a>
<a name="ln428">    if(!img)</a>
<a name="ln429">    {</a>
<a name="ln430">      // in this case no need to release from cache what we couldn't get</a>
<a name="ln431">      dt_control_log(_(&quot;cannot get image %d for printing&quot;), imgid);</a>
<a name="ln432">      dt_control_job_dispose(job);</a>
<a name="ln433">      return;</a>
<a name="ln434">    }</a>
<a name="ln435">    params-&gt;job_title = g_strdup(img-&gt;filename);</a>
<a name="ln436">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln437">  }</a>
<a name="ln438">  // FIXME: ellipsize title/printer as the export completed message is ellipsized</a>
<a name="ln439">  gchar *message = g_strdup_printf(_(&quot;processing `%s' for `%s'&quot;), params-&gt;job_title, params-&gt;prt.printer.name);</a>
<a name="ln440">  dt_control_job_add_progress(job, message, TRUE);</a>
<a name="ln441">  g_free(message);</a>
<a name="ln442"> </a>
<a name="ln443">  // FIXME: getting this from conf as w/prior code, but switch to getting from ps</a>
<a name="ln444">  params-&gt;style = dt_conf_get_string(&quot;plugins/print/print/style&quot;);</a>
<a name="ln445">  params-&gt;style_append = ps-&gt;v_style_append;</a>
<a name="ln446"> </a>
<a name="ln447">  // FIXME: getting these from conf as w/prior code, but switch to getting them from ps</a>
<a name="ln448">  params-&gt;buf_icc_type = dt_conf_get_int(&quot;plugins/print/print/icctype&quot;);</a>
<a name="ln449">  params-&gt;buf_icc_profile = dt_conf_get_string(&quot;plugins/print/print/iccprofile&quot;);</a>
<a name="ln450">  params-&gt;buf_icc_intent = dt_conf_get_int(&quot;plugins/print/print/iccintent&quot;);</a>
<a name="ln451"> </a>
<a name="ln452">  params-&gt;p_icc_type = ps-&gt;v_picctype;</a>
<a name="ln453">  params-&gt;p_icc_profile = g_strdup(ps-&gt;v_piccprofile);</a>
<a name="ln454">  params-&gt;p_icc_intent = ps-&gt;v_pintent;</a>
<a name="ln455">  params-&gt;black_point_compensation = ps-&gt;v_black_point_compensation;</a>
<a name="ln456"> </a>
<a name="ln457">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_EXPORT, job);</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">static void _set_printer(const dt_lib_module_t *self, const char *printer_name)</a>
<a name="ln461">{</a>
<a name="ln462">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln463"> </a>
<a name="ln464">  dt_get_printer_info (printer_name, &amp;ps-&gt;prt.printer);</a>
<a name="ln465"> </a>
<a name="ln466">  // if this is a turboprint printer, disable the printer profile</a>
<a name="ln467"> </a>
<a name="ln468">  if (ps-&gt;prt.printer.is_turboprint)</a>
<a name="ln469">    dt_bauhaus_combobox_set(ps-&gt;pprofile, 0);</a>
<a name="ln470"> </a>
<a name="ln471">  // if there is 0 hardware margins, set the user marging to 15mm</a>
<a name="ln472"> </a>
<a name="ln473">  if (ps-&gt;prt.printer.hw_margin_top == 0)</a>
<a name="ln474">  {</a>
<a name="ln475">    ps-&gt;prt.page.margin_top = 15;</a>
<a name="ln476">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_top), ps-&gt;prt.page.margin_top * units[ps-&gt;unit]);</a>
<a name="ln477">  }</a>
<a name="ln478">  if (ps-&gt;prt.printer.hw_margin_bottom == 0)</a>
<a name="ln479">  {</a>
<a name="ln480">    ps-&gt;prt.page.margin_bottom = 15;</a>
<a name="ln481">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), ps-&gt;prt.page.margin_bottom * units[ps-&gt;unit]);</a>
<a name="ln482">  }</a>
<a name="ln483">  if (ps-&gt;prt.printer.hw_margin_left == 0)</a>
<a name="ln484">  {</a>
<a name="ln485">    ps-&gt;prt.page.margin_left = 15;</a>
<a name="ln486">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left), ps-&gt;prt.page.margin_left * units[ps-&gt;unit]);</a>
<a name="ln487">  }</a>
<a name="ln488">  if (ps-&gt;prt.printer.hw_margin_right == 0)</a>
<a name="ln489">  {</a>
<a name="ln490">    ps-&gt;prt.page.margin_right = 15;</a>
<a name="ln491">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right), ps-&gt;prt.page.margin_right * units[ps-&gt;unit]);</a>
<a name="ln492">  }</a>
<a name="ln493"> </a>
<a name="ln494">  dt_conf_set_string(&quot;plugins/print/print/printer&quot;, printer_name);</a>
<a name="ln495"> </a>
<a name="ln496">  char *default_paper = dt_conf_get_string(&quot;plugins/print/print/paper&quot;);</a>
<a name="ln497"> </a>
<a name="ln498">  // next add corresponding papers</a>
<a name="ln499"> </a>
<a name="ln500">  // first clear current list</a>
<a name="ln501"> </a>
<a name="ln502">  dt_bauhaus_combobox_clear(ps-&gt;papers);</a>
<a name="ln503"> </a>
<a name="ln504">  // then add papers for the given printer</a>
<a name="ln505"> </a>
<a name="ln506">  if(ps-&gt;paper_list) g_list_free_full(ps-&gt;paper_list, free);</a>
<a name="ln507"> </a>
<a name="ln508">  ps-&gt;paper_list = dt_get_papers (&amp;ps-&gt;prt.printer);</a>
<a name="ln509">  GList *papers = ps-&gt;paper_list;</a>
<a name="ln510">  int np = 0;</a>
<a name="ln511">  gboolean ispaperset = FALSE;</a>
<a name="ln512"> </a>
<a name="ln513">  while (papers)</a>
<a name="ln514">  {</a>
<a name="ln515">    const dt_paper_info_t *p = (dt_paper_info_t *)papers-&gt;data;</a>
<a name="ln516">    dt_bauhaus_combobox_add(ps-&gt;papers, p-&gt;common_name);</a>
<a name="ln517"> </a>
<a name="ln518">    if (ispaperset == FALSE &amp;&amp; (!g_strcmp0(default_paper, p-&gt;common_name) || default_paper[0] == '\0'))</a>
<a name="ln519">    {</a>
<a name="ln520">      dt_bauhaus_combobox_set(ps-&gt;papers, np);</a>
<a name="ln521">      ispaperset = TRUE;</a>
<a name="ln522">    }</a>
<a name="ln523"> </a>
<a name="ln524">    np++;</a>
<a name="ln525">    papers = g_list_next (papers);</a>
<a name="ln526">  }</a>
<a name="ln527"> </a>
<a name="ln528">  //  paper not found in this printer</a>
<a name="ln529">  if (!ispaperset) dt_bauhaus_combobox_set(ps-&gt;papers, 0);</a>
<a name="ln530"> </a>
<a name="ln531">  const dt_paper_info_t *paper = dt_get_paper(ps-&gt;paper_list, default_paper);</a>
<a name="ln532"> </a>
<a name="ln533">  if (paper)</a>
<a name="ln534">    memcpy(&amp;ps-&gt;prt.paper, paper, sizeof(dt_paper_info_t));</a>
<a name="ln535"> </a>
<a name="ln536">  g_free (default_paper);</a>
<a name="ln537"> </a>
<a name="ln538">  // next add corresponding supported media</a>
<a name="ln539"> </a>
<a name="ln540">  char *default_medium = dt_conf_get_string(&quot;plugins/print/print/medium&quot;);</a>
<a name="ln541"> </a>
<a name="ln542">  // first clear current list</a>
<a name="ln543"> </a>
<a name="ln544">  dt_bauhaus_combobox_clear(ps-&gt;media);</a>
<a name="ln545"> </a>
<a name="ln546">  // then add papers for the given printer</a>
<a name="ln547"> </a>
<a name="ln548">  if(ps-&gt;media_list) g_list_free_full(ps-&gt;media_list, free);</a>
<a name="ln549"> </a>
<a name="ln550">  ps-&gt;media_list = dt_get_media_type (&amp;ps-&gt;prt.printer);</a>
<a name="ln551">  GList *media = ps-&gt;media_list;</a>
<a name="ln552">  gboolean ismediaset = FALSE;</a>
<a name="ln553"> </a>
<a name="ln554">  np = 0;</a>
<a name="ln555"> </a>
<a name="ln556">  while (media)</a>
<a name="ln557">  {</a>
<a name="ln558">    const dt_medium_info_t *m = (dt_medium_info_t *)media-&gt;data;</a>
<a name="ln559">    dt_bauhaus_combobox_add(ps-&gt;media, m-&gt;common_name);</a>
<a name="ln560"> </a>
<a name="ln561">    if (ismediaset == FALSE &amp;&amp; (!g_strcmp0(default_medium, m-&gt;common_name) || default_medium[0] == '\0'))</a>
<a name="ln562">    {</a>
<a name="ln563">      dt_bauhaus_combobox_set(ps-&gt;media, np);</a>
<a name="ln564">      ismediaset = TRUE;</a>
<a name="ln565">    }</a>
<a name="ln566"> </a>
<a name="ln567">    np++;</a>
<a name="ln568">    media = g_list_next (media);</a>
<a name="ln569">  }</a>
<a name="ln570"> </a>
<a name="ln571">  //  media not found in this printer</a>
<a name="ln572">  if (!ismediaset) dt_bauhaus_combobox_set(ps-&gt;media, 0);</a>
<a name="ln573"> </a>
<a name="ln574">  const dt_medium_info_t *medium = dt_get_medium(ps-&gt;media_list, default_medium);</a>
<a name="ln575"> </a>
<a name="ln576">  if (medium)</a>
<a name="ln577">    memcpy(&amp;ps-&gt;prt.medium, medium, sizeof(dt_medium_info_t));</a>
<a name="ln578"> </a>
<a name="ln579">  g_free (default_medium);</a>
<a name="ln580"> </a>
<a name="ln581">  dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">static void</a>
<a name="ln585">_printer_changed (GtkWidget *combo, const dt_lib_module_t *self)</a>
<a name="ln586">{</a>
<a name="ln587">  const gchar *printer_name = dt_bauhaus_combobox_get_text(combo);</a>
<a name="ln588"> </a>
<a name="ln589">  if (printer_name)</a>
<a name="ln590">    _set_printer (self, printer_name);</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">static void</a>
<a name="ln594">_paper_changed (GtkWidget *combo, const dt_lib_module_t *self)</a>
<a name="ln595">{</a>
<a name="ln596">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln597"> </a>
<a name="ln598">  const gchar *paper_name = dt_bauhaus_combobox_get_text(combo);</a>
<a name="ln599"> </a>
<a name="ln600">  if (!paper_name) return;</a>
<a name="ln601"> </a>
<a name="ln602">  const dt_paper_info_t *paper = dt_get_paper(ps-&gt;paper_list, paper_name);</a>
<a name="ln603"> </a>
<a name="ln604">  if (paper)</a>
<a name="ln605">    memcpy(&amp;ps-&gt;prt.paper, paper, sizeof(dt_paper_info_t));</a>
<a name="ln606"> </a>
<a name="ln607">  ps-&gt;iwidth = ps-&gt;iheight = 0;</a>
<a name="ln608"> </a>
<a name="ln609">  dt_conf_set_string(&quot;plugins/print/print/paper&quot;, paper_name);</a>
<a name="ln610">  dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln611"> </a>
<a name="ln612">  _update_slider(ps);</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615">static void</a>
<a name="ln616">_media_changed (GtkWidget *combo, const dt_lib_module_t *self)</a>
<a name="ln617">{</a>
<a name="ln618">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln619"> </a>
<a name="ln620">  const gchar *medium_name = dt_bauhaus_combobox_get_text(combo);</a>
<a name="ln621"> </a>
<a name="ln622">  if (!medium_name) return;</a>
<a name="ln623"> </a>
<a name="ln624">  const dt_medium_info_t *medium = dt_get_medium(ps-&gt;media_list, medium_name);</a>
<a name="ln625"> </a>
<a name="ln626">  if (medium)</a>
<a name="ln627">    memcpy(&amp;ps-&gt;prt.medium, medium, sizeof(dt_medium_info_t));</a>
<a name="ln628"> </a>
<a name="ln629">  dt_conf_set_string(&quot;plugins/print/print/medium&quot;, medium_name);</a>
<a name="ln630">  dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln631"> </a>
<a name="ln632">  _update_slider(ps);</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">static double to_mm(dt_lib_print_settings_t *ps, double value)</a>
<a name="ln636">{</a>
<a name="ln637">  return value / units[ps-&gt;unit];</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640">static void</a>
<a name="ln641">_update_slider (dt_lib_print_settings_t *ps)</a>
<a name="ln642">{</a>
<a name="ln643">  dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln644"> </a>
<a name="ln645">  // if widget are created, let's display the current image size</a>
<a name="ln646"> </a>
<a name="ln647">  if (ps-&gt;image_id != -1 &amp;&amp; ps-&gt;width &amp;&amp; ps-&gt;height &amp;&amp; ps-&gt;info)</a>
<a name="ln648">  {</a>
<a name="ln649">    int32_t px=0, py=0, pwidth=0, pheight=0;</a>
<a name="ln650">    int32_t ax=0, ay=0, awidth=0, aheight=0;</a>
<a name="ln651">    int32_t ix=0, iy=0, iwidth=0, iheight=0;</a>
<a name="ln652">    int32_t iwpix=ps-&gt;iwidth, ihpix=ps-&gt;iheight;</a>
<a name="ln653">    int32_t pa_width, pa_height;</a>
<a name="ln654"> </a>
<a name="ln655">    if (ps-&gt;prt.page.landscape)</a>
<a name="ln656">    {</a>
<a name="ln657">      pa_height = (int32_t)ps-&gt;prt.paper.width;</a>
<a name="ln658">      pa_width = (int32_t)ps-&gt;prt.paper.height;</a>
<a name="ln659">    }</a>
<a name="ln660">    else</a>
<a name="ln661">    {</a>
<a name="ln662">      pa_width = (int32_t)ps-&gt;prt.paper.width;</a>
<a name="ln663">      pa_height = (int32_t)ps-&gt;prt.paper.height;</a>
<a name="ln664">    }</a>
<a name="ln665"> </a>
<a name="ln666">    dt_get_print_layout(ps-&gt;image_id, &amp;ps-&gt;prt, pa_width, pa_height,</a>
<a name="ln667">                        &amp;iwpix, &amp;ihpix,</a>
<a name="ln668">                        &amp;px, &amp;py, &amp;pwidth, &amp;pheight,</a>
<a name="ln669">                        &amp;ax, &amp;ay, &amp;awidth, &amp;aheight,</a>
<a name="ln670">                        &amp;ix, &amp;iy, &amp;iwidth, &amp;iheight);</a>
<a name="ln671"> </a>
<a name="ln672">    if (ps-&gt;iwidth==0 || ps-&gt;iheight==0)</a>
<a name="ln673">    {</a>
<a name="ln674">      ps-&gt;iwidth = iwpix;</a>
<a name="ln675">      ps-&gt;iheight = ihpix;</a>
<a name="ln676">    }</a>
<a name="ln677"> </a>
<a name="ln678">    const double h = iheight * units[ps-&gt;unit];</a>
<a name="ln679">    const double w = iwidth * units[ps-&gt;unit];</a>
<a name="ln680">    char *value;</a>
<a name="ln681"> </a>
<a name="ln682">    value = g_strdup_printf(&quot;%3.2f&quot;, w);</a>
<a name="ln683">    gtk_label_set_text(GTK_LABEL(ps-&gt;width), value);</a>
<a name="ln684">    g_free(value);</a>
<a name="ln685"> </a>
<a name="ln686">    value = g_strdup_printf(&quot;%3.2f&quot;, h);</a>
<a name="ln687">    gtk_label_set_text(GTK_LABEL(ps-&gt;height), value);</a>
<a name="ln688">    g_free(value);</a>
<a name="ln689"> </a>
<a name="ln690">    // compute the image down/up scale and report information</a>
<a name="ln691">    double scale;</a>
<a name="ln692"> </a>
<a name="ln693">    if (iwidth &gt;= awidth)</a>
<a name="ln694">      scale = dt_pdf_point_to_pixel(dt_pdf_mm_to_point((double)awidth), ps-&gt;prt.printer.resolution) / ps-&gt;iwidth;</a>
<a name="ln695">    else</a>
<a name="ln696">      scale = dt_pdf_point_to_pixel(dt_pdf_mm_to_point((double)aheight), ps-&gt;prt.printer.resolution) / ps-&gt;iheight;</a>
<a name="ln697"> </a>
<a name="ln698">    value = g_strdup_printf(_(&quot;%3.2f (dpi:%d)&quot;), scale, scale&lt;=1.0 ? (int)ps-&gt;prt.printer.resolution : (int)(ps-&gt;prt.printer.resolution / scale));</a>
<a name="ln699">    gtk_label_set_text(GTK_LABEL(ps-&gt;info), value);</a>
<a name="ln700">    g_free(value);</a>
<a name="ln701">  }</a>
<a name="ln702"> </a>
<a name="ln703">  // set the max range for the borders depending on the others border and never allow to have an image size of 0 or less</a>
<a name="ln704">  const int min_size = 5; // minimum size in mm</a>
<a name="ln705">  const int pa_max_height = ps-&gt;prt.paper.height - ps-&gt;prt.printer.hw_margin_top - ps-&gt;prt.printer.hw_margin_bottom - min_size;</a>
<a name="ln706">  const int pa_max_width  = ps-&gt;prt.paper.width  - ps-&gt;prt.printer.hw_margin_left - ps-&gt;prt.printer.hw_margin_right - min_size;</a>
<a name="ln707"> </a>
<a name="ln708">  gtk_spin_button_set_range (GTK_SPIN_BUTTON(ps-&gt;b_top),</a>
<a name="ln709">                             min_borders * units[ps-&gt;unit], (pa_max_height - ps-&gt;prt.page.margin_bottom) * units[ps-&gt;unit]);</a>
<a name="ln710">  gtk_spin_button_set_range (GTK_SPIN_BUTTON(ps-&gt;b_left),</a>
<a name="ln711">                             min_borders * units[ps-&gt;unit], (pa_max_width - ps-&gt;prt.page.margin_right) * units[ps-&gt;unit]);</a>
<a name="ln712">  gtk_spin_button_set_range (GTK_SPIN_BUTTON(ps-&gt;b_right),</a>
<a name="ln713">                             min_borders * units[ps-&gt;unit], (pa_max_width - ps-&gt;prt.page.margin_left) * units[ps-&gt;unit]);</a>
<a name="ln714">  gtk_spin_button_set_range (GTK_SPIN_BUTTON(ps-&gt;b_bottom),</a>
<a name="ln715">                             min_borders * units[ps-&gt;unit], (pa_max_height - ps-&gt;prt.page.margin_top) * units[ps-&gt;unit]);</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">static void</a>
<a name="ln719">_top_border_callback (GtkWidget *spin, gpointer user_data)</a>
<a name="ln720">{</a>
<a name="ln721">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln722">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln723">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(spin));</a>
<a name="ln724"> </a>
<a name="ln725">  ps-&gt;prt.page.margin_top = to_mm(ps, value);</a>
<a name="ln726"> </a>
<a name="ln727">  if (ps-&gt;lock_activated == TRUE)</a>
<a name="ln728">  {</a>
<a name="ln729">    ps-&gt;prt.page.margin_bottom = to_mm(ps, value);</a>
<a name="ln730">    ps-&gt;prt.page.margin_left = to_mm(ps, value);</a>
<a name="ln731">    ps-&gt;prt.page.margin_right = to_mm(ps, value);</a>
<a name="ln732"> </a>
<a name="ln733">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), value);</a>
<a name="ln734">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left), value);</a>
<a name="ln735">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right), value);</a>
<a name="ln736">  }</a>
<a name="ln737"> </a>
<a name="ln738">  _update_slider (ps);</a>
<a name="ln739">}</a>
<a name="ln740"> </a>
<a name="ln741">static void</a>
<a name="ln742">_bottom_border_callback (GtkWidget *spin, gpointer user_data)</a>
<a name="ln743">{</a>
<a name="ln744">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln745">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln746">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(spin));</a>
<a name="ln747"> </a>
<a name="ln748">  ps-&gt;prt.page.margin_bottom = to_mm(ps, value);</a>
<a name="ln749">  _update_slider (ps);</a>
<a name="ln750">}</a>
<a name="ln751"> </a>
<a name="ln752">static void</a>
<a name="ln753">_left_border_callback (GtkWidget *spin, gpointer user_data)</a>
<a name="ln754">{</a>
<a name="ln755">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln756">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln757">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(spin));</a>
<a name="ln758"> </a>
<a name="ln759">  ps-&gt;prt.page.margin_left = to_mm(ps, value);</a>
<a name="ln760">  _update_slider (ps);</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763">static void</a>
<a name="ln764">_right_border_callback (GtkWidget *spin, gpointer user_data)</a>
<a name="ln765">{</a>
<a name="ln766">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln767">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln768">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(spin));</a>
<a name="ln769"> </a>
<a name="ln770">  ps-&gt;prt.page.margin_right = to_mm(ps, value);</a>
<a name="ln771">  _update_slider (ps);</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774">static void</a>
<a name="ln775">_lock_callback (GtkWidget *button, gpointer user_data)</a>
<a name="ln776">{</a>
<a name="ln777">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln778">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln779"> </a>
<a name="ln780">  ps-&gt;lock_activated = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button));</a>
<a name="ln781"> </a>
<a name="ln782">  dt_conf_set_bool(&quot;plugins/print/print/lock_borders&quot;, ps-&gt;lock_activated);</a>
<a name="ln783"> </a>
<a name="ln784">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;b_bottom), !ps-&gt;lock_activated);</a>
<a name="ln785">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;b_left), !ps-&gt;lock_activated);</a>
<a name="ln786">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;b_right), !ps-&gt;lock_activated);</a>
<a name="ln787"> </a>
<a name="ln788">  //  get value of top and set it to all other borders</a>
<a name="ln789"> </a>
<a name="ln790">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(ps-&gt;b_top));</a>
<a name="ln791">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), value);</a>
<a name="ln792">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left), value);</a>
<a name="ln793">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right), value);</a>
<a name="ln794"> </a>
<a name="ln795">  _update_slider (ps);</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">static void</a>
<a name="ln799">_alignment_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln800">{</a>
<a name="ln801">  int index=-1;</a>
<a name="ln802">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln803">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln804"> </a>
<a name="ln805">  for(int i=0; i&lt;9; i++)</a>
<a name="ln806">  {</a>
<a name="ln807">    /* block signal handler */</a>
<a name="ln808">    g_signal_handlers_block_by_func (ps-&gt;dtba[i],_alignment_callback,user_data);</a>
<a name="ln809"> </a>
<a name="ln810">    if( GTK_WIDGET(ps-&gt;dtba[i]) == tb )</a>
<a name="ln811">    {</a>
<a name="ln812">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;dtba[i]),TRUE);</a>
<a name="ln813">      index=i;</a>
<a name="ln814">    }</a>
<a name="ln815">    else gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;dtba[i]),FALSE);</a>
<a name="ln816"> </a>
<a name="ln817">    /* unblock signal handler */</a>
<a name="ln818">    g_signal_handlers_unblock_by_func (ps-&gt;dtba[i],_alignment_callback,user_data);</a>
<a name="ln819">  }</a>
<a name="ln820">  ps-&gt;prt.page.alignment = index;</a>
<a name="ln821">  _update_slider (ps);</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824">static void</a>
<a name="ln825">_orientation_changed (GtkWidget *combo, dt_lib_module_t *self)</a>
<a name="ln826">{</a>
<a name="ln827">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln828"> </a>
<a name="ln829">  ps-&gt;prt.page.landscape = dt_bauhaus_combobox_get (combo);</a>
<a name="ln830"> </a>
<a name="ln831">  _update_slider (ps);</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">static void</a>
<a name="ln835">_unit_changed (GtkWidget *combo, dt_lib_module_t *self)</a>
<a name="ln836">{</a>
<a name="ln837">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln838"> </a>
<a name="ln839">  int unit = dt_bauhaus_combobox_get(combo);</a>
<a name="ln840">  if(unit &lt; 0) return; // shouldn't happen, but it could be -1 if nothing is selected</a>
<a name="ln841">  ps-&gt;unit = unit;</a>
<a name="ln842">  dt_conf_set_int(&quot;plugins/print/print/unit&quot;, ps-&gt;unit);</a>
<a name="ln843"> </a>
<a name="ln844">  const double margin_top = ps-&gt;prt.page.margin_top;</a>
<a name="ln845">  const double margin_left = ps-&gt;prt.page.margin_left;</a>
<a name="ln846">  const double margin_right = ps-&gt;prt.page.margin_right;</a>
<a name="ln847">  const double margin_bottom = ps-&gt;prt.page.margin_bottom;</a>
<a name="ln848"> </a>
<a name="ln849">  const int n_digits = (int)(1.0 / (units[ps-&gt;unit] * 10.0));</a>
<a name="ln850"> </a>
<a name="ln851">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(ps-&gt;b_top),    n_digits);</a>
<a name="ln852">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(ps-&gt;b_bottom), n_digits);</a>
<a name="ln853">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(ps-&gt;b_left),   n_digits);</a>
<a name="ln854">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(ps-&gt;b_right),  n_digits);</a>
<a name="ln855"> </a>
<a name="ln856">  const float incr = units[ps-&gt;unit];</a>
<a name="ln857"> </a>
<a name="ln858">  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(ps-&gt;b_top), incr, incr);</a>
<a name="ln859">  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(ps-&gt;b_bottom), incr, incr);</a>
<a name="ln860">  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(ps-&gt;b_left), incr, incr);</a>
<a name="ln861">  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(ps-&gt;b_right), incr, incr);</a>
<a name="ln862"> </a>
<a name="ln863">  _update_slider (ps);</a>
<a name="ln864"> </a>
<a name="ln865">  // convert margins to new unit</a>
<a name="ln866">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_top),    margin_top * units[ps-&gt;unit]);</a>
<a name="ln867">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), margin_bottom * units[ps-&gt;unit]);</a>
<a name="ln868">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left),   margin_left * units[ps-&gt;unit]);</a>
<a name="ln869">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right),  margin_right * units[ps-&gt;unit]);</a>
<a name="ln870"> </a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">static void</a>
<a name="ln874">_style_callback(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln875">{</a>
<a name="ln876">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln877"> </a>
<a name="ln878">  if(dt_bauhaus_combobox_get(ps-&gt;style) == 0)</a>
<a name="ln879">  {</a>
<a name="ln880">    dt_conf_set_string(&quot;plugins/print/print/style&quot;, &quot;&quot;);</a>
<a name="ln881">    gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;style_mode), FALSE);</a>
<a name="ln882">  }</a>
<a name="ln883">  else</a>
<a name="ln884">  {</a>
<a name="ln885">    const gchar *style = dt_bauhaus_combobox_get_text(ps-&gt;style);</a>
<a name="ln886">    dt_conf_set_string(&quot;plugins/print/print/style&quot;, style);</a>
<a name="ln887">    gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;style_mode), TRUE);</a>
<a name="ln888">  }</a>
<a name="ln889"> </a>
<a name="ln890">  g_free(ps-&gt;v_style);</a>
<a name="ln891">  ps-&gt;v_style = dt_conf_get_string(&quot;plugins/print/print/style&quot;);</a>
<a name="ln892">}</a>
<a name="ln893"> </a>
<a name="ln894">static void</a>
<a name="ln895">_style_mode_changed(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln896">{</a>
<a name="ln897">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln898"> </a>
<a name="ln899">  if(dt_bauhaus_combobox_get(ps-&gt;style_mode) == 0)</a>
<a name="ln900">    ps-&gt;v_style_append = FALSE;</a>
<a name="ln901">  else</a>
<a name="ln902">    ps-&gt;v_style_append = TRUE;</a>
<a name="ln903"> </a>
<a name="ln904">  dt_conf_set_bool(&quot;plugins/print/print/style_append&quot;, ps-&gt;v_style_append);</a>
<a name="ln905">}</a>
<a name="ln906"> </a>
<a name="ln907">static void</a>
<a name="ln908">_profile_changed(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln909">{</a>
<a name="ln910">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln911">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln912">  GList *prof = ps-&gt;profiles;</a>
<a name="ln913">  while(prof)</a>
<a name="ln914">  {</a>
<a name="ln915">    dt_lib_export_profile_t *pp = (dt_lib_export_profile_t *)prof-&gt;data;</a>
<a name="ln916">    if(pp-&gt;pos == pos)</a>
<a name="ln917">    {</a>
<a name="ln918">      dt_conf_set_int(&quot;plugins/print/print/icctype&quot;, pp-&gt;type);</a>
<a name="ln919">      dt_conf_set_string(&quot;plugins/print/print/iccprofile&quot;, pp-&gt;filename);</a>
<a name="ln920">      g_free(ps-&gt;v_iccprofile);</a>
<a name="ln921">      ps-&gt;v_icctype = pp-&gt;type;</a>
<a name="ln922">      ps-&gt;v_iccprofile = g_strdup(pp-&gt;filename);</a>
<a name="ln923">      return;</a>
<a name="ln924">    }</a>
<a name="ln925">    prof = g_list_next(prof);</a>
<a name="ln926">  }</a>
<a name="ln927">  dt_conf_set_int(&quot;plugins/print/print/icctype&quot;, DT_COLORSPACE_NONE);</a>
<a name="ln928">  dt_conf_set_string(&quot;plugins/print/print/iccprofile&quot;, &quot;&quot;);</a>
<a name="ln929">  g_free(ps-&gt;v_iccprofile);</a>
<a name="ln930">  ps-&gt;v_icctype = DT_COLORSPACE_NONE;</a>
<a name="ln931">  ps-&gt;v_iccprofile = g_strdup(&quot;&quot;);</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934">static void</a>
<a name="ln935">_printer_profile_changed(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln936">{</a>
<a name="ln937">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln938">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln939">  GList *prof = ps-&gt;profiles;</a>
<a name="ln940">  while(prof)</a>
<a name="ln941">  {</a>
<a name="ln942">    dt_lib_export_profile_t *pp = (dt_lib_export_profile_t *)prof-&gt;data;</a>
<a name="ln943">    if(pp-&gt;ppos == pos)</a>
<a name="ln944">    {</a>
<a name="ln945">      dt_conf_set_int(&quot;plugins/print/printer/icctype&quot;, pp-&gt;type);</a>
<a name="ln946">      dt_conf_set_string(&quot;plugins/print/printer/iccprofile&quot;, pp-&gt;filename);</a>
<a name="ln947">      g_free(ps-&gt;v_piccprofile);</a>
<a name="ln948">      ps-&gt;v_picctype = pp-&gt;type;</a>
<a name="ln949">      ps-&gt;v_piccprofile = g_strdup(pp-&gt;filename);</a>
<a name="ln950"> </a>
<a name="ln951">      // activate the black compensation and printer intent</a>
<a name="ln952">      gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;black_point_compensation), TRUE);</a>
<a name="ln953">      return;</a>
<a name="ln954">    }</a>
<a name="ln955">    prof = g_list_next(prof);</a>
<a name="ln956">  }</a>
<a name="ln957">  dt_conf_set_int(&quot;plugins/print/printer/icctype&quot;, DT_COLORSPACE_NONE);</a>
<a name="ln958">  dt_conf_set_string(&quot;plugins/print/printer/iccprofile&quot;, &quot;&quot;);</a>
<a name="ln959">  g_free(ps-&gt;v_piccprofile);</a>
<a name="ln960">  ps-&gt;v_picctype = DT_COLORSPACE_NONE;</a>
<a name="ln961">  ps-&gt;v_piccprofile = g_strdup(&quot;&quot;);</a>
<a name="ln962">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;black_point_compensation), FALSE);</a>
<a name="ln963">}</a>
<a name="ln964"> </a>
<a name="ln965">static void</a>
<a name="ln966">_printer_intent_callback (GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln967">{</a>
<a name="ln968">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln969">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln970">  dt_conf_set_int(&quot;plugins/print/printer/iccintent&quot;, pos);</a>
<a name="ln971">  ps-&gt;v_pintent = pos;</a>
<a name="ln972">  ps-&gt;prt.printer.intent = pos;</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">static void</a>
<a name="ln976">_printer_bpc_callback (GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln977">{</a>
<a name="ln978">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln979">  ps-&gt;v_black_point_compensation = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ps-&gt;black_point_compensation));</a>
<a name="ln980">  dt_conf_set_bool(&quot;plugins/print/print/black_point_compensation&quot;, ps-&gt;v_black_point_compensation);</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983">static void</a>
<a name="ln984">_intent_callback (GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln985">{</a>
<a name="ln986">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln987">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln988">  // record the intent that will override the out rendering module on export</a>
<a name="ln989">  dt_conf_set_int(&quot;plugins/print/print/iccintent&quot;, pos - 1);</a>
<a name="ln990">  ps-&gt;v_intent = pos - 1;</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">static void _set_orientation(dt_lib_print_settings_t *ps)</a>
<a name="ln994">{</a>
<a name="ln995">  if (ps-&gt;image_id &lt;= 0)</a>
<a name="ln996">    return;</a>
<a name="ln997"> </a>
<a name="ln998">  dt_mipmap_buffer_t buf;</a>
<a name="ln999">  dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, ps-&gt;image_id, DT_MIPMAP_0, DT_MIPMAP_BEST_EFFORT, 'r');</a>
<a name="ln1000"> </a>
<a name="ln1001">  // If there's a mipmap available, figure out orientation based upon</a>
<a name="ln1002">  // its dimensions. Otherwise, don't touch orientation until the</a>
<a name="ln1003">  // mipmap arrives.</a>
<a name="ln1004">  if (buf.size != DT_MIPMAP_NONE)</a>
<a name="ln1005">  {</a>
<a name="ln1006">    ps-&gt;prt.page.landscape = (buf.width &gt; buf.height);</a>
<a name="ln1007">    dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln1008">    dt_bauhaus_combobox_set (ps-&gt;orientation, ps-&gt;prt.page.landscape==TRUE?1:0);</a>
<a name="ln1009">  }</a>
<a name="ln1010"> </a>
<a name="ln1011">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014">static void _print_settings_activate_or_update_callback(gpointer instance,gpointer user_data)</a>
<a name="ln1015">{</a>
<a name="ln1016">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1017">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1018"> </a>
<a name="ln1019">  ps-&gt;image_id = dt_view_filmstrip_get_activated_imgid(darktable.view_manager);</a>
<a name="ln1020">  ps-&gt;iwidth = ps-&gt;iheight = 0;</a>
<a name="ln1021">  _set_orientation (ps);</a>
<a name="ln1022">}</a>
<a name="ln1023"> </a>
<a name="ln1024">static GList* _get_profiles ()</a>
<a name="ln1025">{</a>
<a name="ln1026">  //  Create list of profiles</a>
<a name="ln1027">  GList *list = NULL;</a>
<a name="ln1028"> </a>
<a name="ln1029">  dt_lib_export_profile_t *prof = (dt_lib_export_profile_t *)g_malloc0(sizeof(dt_lib_export_profile_t));</a>
<a name="ln1030">  prof-&gt;type = DT_COLORSPACE_SRGB;</a>
<a name="ln1031">  dt_utf8_strlcpy(prof-&gt;name, _(&quot;sRGB (web-safe)&quot;), sizeof(prof-&gt;name));</a>
<a name="ln1032">  prof-&gt;pos = -2;</a>
<a name="ln1033">  prof-&gt;ppos = -2;</a>
<a name="ln1034">  list = g_list_append(list, prof);</a>
<a name="ln1035"> </a>
<a name="ln1036">  prof = (dt_lib_export_profile_t *)g_malloc0(sizeof(dt_lib_export_profile_t));</a>
<a name="ln1037">  prof-&gt;type = DT_COLORSPACE_ADOBERGB;</a>
<a name="ln1038">  dt_utf8_strlcpy(prof-&gt;name, _(&quot;Adobe RGB (compatible)&quot;), sizeof(prof-&gt;name));</a>
<a name="ln1039">  prof-&gt;pos = -2;</a>
<a name="ln1040">  prof-&gt;ppos = -2;</a>
<a name="ln1041">  list = g_list_append(list, prof);</a>
<a name="ln1042"> </a>
<a name="ln1043">  // add the profiles from datadir/color/out/*.icc</a>
<a name="ln1044">  for(GList *iter = darktable.color_profiles-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln1045">  {</a>
<a name="ln1046">    dt_colorspaces_color_profile_t *p = (dt_colorspaces_color_profile_t *)iter-&gt;data;</a>
<a name="ln1047">    if(p-&gt;type == DT_COLORSPACE_FILE)</a>
<a name="ln1048">    {</a>
<a name="ln1049">      prof = (dt_lib_export_profile_t *)g_malloc0(sizeof(dt_lib_export_profile_t));</a>
<a name="ln1050">      g_strlcpy(prof-&gt;name, p-&gt;name, sizeof(prof-&gt;name));</a>
<a name="ln1051">      g_strlcpy(prof-&gt;filename, p-&gt;filename, sizeof(prof-&gt;filename));</a>
<a name="ln1052">      prof-&gt;type = DT_COLORSPACE_FILE;</a>
<a name="ln1053">      prof-&gt;pos = -2;</a>
<a name="ln1054">      prof-&gt;ppos = -2;</a>
<a name="ln1055">      list = g_list_append(list, prof);</a>
<a name="ln1056">    }</a>
<a name="ln1057">  }</a>
<a name="ln1058"> </a>
<a name="ln1059">  return list;</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062">static void _new_printer_callback(dt_printer_info_t *printer, void *user_data)</a>
<a name="ln1063">{</a>
<a name="ln1064">  static int count = 0;</a>
<a name="ln1065">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1066">  const dt_lib_print_settings_t *d = (dt_lib_print_settings_t*)self-&gt;data;</a>
<a name="ln1067"> </a>
<a name="ln1068">  char *default_printer = dt_conf_get_string(&quot;plugins/print/print/printer&quot;);</a>
<a name="ln1069"> </a>
<a name="ln1070">  g_signal_handlers_block_by_func(G_OBJECT(d-&gt;printers), G_CALLBACK(_printer_changed), NULL);</a>
<a name="ln1071"> </a>
<a name="ln1072">  dt_bauhaus_combobox_add(d-&gt;printers, printer-&gt;name);</a>
<a name="ln1073"> </a>
<a name="ln1074">  if (!g_strcmp0(default_printer, printer-&gt;name) || default_printer[0]=='\0')</a>
<a name="ln1075">  {</a>
<a name="ln1076">    dt_bauhaus_combobox_set(d-&gt;printers, count);</a>
<a name="ln1077">    _set_printer(self, printer-&gt;name);</a>
<a name="ln1078">  }</a>
<a name="ln1079">  count++;</a>
<a name="ln1080">  g_free(default_printer);</a>
<a name="ln1081"> </a>
<a name="ln1082">  g_signal_handlers_unblock_by_func(G_OBJECT(d-&gt;printers), G_CALLBACK(_printer_changed), NULL);</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085">void view_enter(struct dt_lib_module_t *self,struct dt_view_t *old_view,struct dt_view_t *new_view)</a>
<a name="ln1086">{</a>
<a name="ln1087">  // user activated a new image via the filmstrip or user entered view</a>
<a name="ln1088">  // mode which activates an image: get image_id and orientation</a>
<a name="ln1089">  dt_control_signal_connect(darktable.signals,</a>
<a name="ln1090">                            DT_SIGNAL_VIEWMANAGER_FILMSTRIP_ACTIVATE,</a>
<a name="ln1091">                            G_CALLBACK(_print_settings_activate_or_update_callback),</a>
<a name="ln1092">                            self);</a>
<a name="ln1093"> </a>
<a name="ln1094">  // when an updated mipmap, we may have new orientation information</a>
<a name="ln1095">  // about the current image. This updates the image_id as well and</a>
<a name="ln1096">  // zeros out dimensions, but there should be no harm in that</a>
<a name="ln1097">  dt_control_signal_connect(darktable.signals,</a>
<a name="ln1098">                            DT_SIGNAL_DEVELOP_MIPMAP_UPDATED,</a>
<a name="ln1099">                            G_CALLBACK(_print_settings_activate_or_update_callback),</a>
<a name="ln1100">                            self);</a>
<a name="ln1101"> </a>
<a name="ln1102">  // NOTE: it would be proper to set image_id here to -1, but this seems to make no difference</a>
<a name="ln1103">}</a>
<a name="ln1104"> </a>
<a name="ln1105">void view_leave(struct dt_lib_module_t *self,struct dt_view_t *old_view,struct dt_view_t *new_view)</a>
<a name="ln1106">{</a>
<a name="ln1107">  dt_control_signal_disconnect(darktable.signals,</a>
<a name="ln1108">                               G_CALLBACK(_print_settings_activate_or_update_callback),</a>
<a name="ln1109">                               self);</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112">void</a>
<a name="ln1113">gui_init (dt_lib_module_t *self)</a>
<a name="ln1114">{</a>
<a name="ln1115">  dt_lib_print_settings_t *d = (dt_lib_print_settings_t*)malloc(sizeof(dt_lib_print_settings_t));</a>
<a name="ln1116">  self-&gt;data = d;</a>
<a name="ln1117">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln1118">  dt_gui_add_help_link(self-&gt;widget, &quot;print_chapter.html#print_overview&quot;);</a>
<a name="ln1119"> </a>
<a name="ln1120">  char datadir[PATH_MAX] = { 0 };</a>
<a name="ln1121">  char confdir[PATH_MAX] = { 0 };</a>
<a name="ln1122">  dt_loc_get_user_config_dir(confdir, sizeof(confdir));</a>
<a name="ln1123">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln1124">  char *system_profile_dir = g_build_filename(datadir, &quot;color&quot;, &quot;out&quot;, NULL);</a>
<a name="ln1125">  char *user_profile_dir = g_build_filename(confdir, &quot;color&quot;, &quot;out&quot;, NULL);</a>
<a name="ln1126"> </a>
<a name="ln1127">  GtkWidget *label;</a>
<a name="ln1128"> </a>
<a name="ln1129">  d-&gt;paper_list = NULL;</a>
<a name="ln1130">  d-&gt;media_list = NULL;</a>
<a name="ln1131">  d-&gt;iwidth = d-&gt;iheight = 0;</a>
<a name="ln1132">  d-&gt;unit = 0;</a>
<a name="ln1133">  d-&gt;width = d-&gt;height = NULL;</a>
<a name="ln1134">  d-&gt;v_piccprofile = NULL;</a>
<a name="ln1135">  d-&gt;v_iccprofile = NULL;</a>
<a name="ln1136">  d-&gt;v_style = NULL;</a>
<a name="ln1137"> </a>
<a name="ln1138">  dt_init_print_info(&amp;d-&gt;prt);</a>
<a name="ln1139">  dt_view_print_settings(darktable.view_manager, &amp;d-&gt;prt);</a>
<a name="ln1140"> </a>
<a name="ln1141">  d-&gt;profiles = _get_profiles();</a>
<a name="ln1142"> </a>
<a name="ln1143">  d-&gt;image_id = -1;</a>
<a name="ln1144"> </a>
<a name="ln1145">  //  create the spin-button now as values could be set when the printer has no hardware margin</a>
<a name="ln1146"> </a>
<a name="ln1147">  d-&gt;b_top    = gtk_spin_button_new_with_range(0, 1000, 1);</a>
<a name="ln1148">  d-&gt;b_left   = gtk_spin_button_new_with_range(0, 1000, 1);</a>
<a name="ln1149">  d-&gt;b_right  = gtk_spin_button_new_with_range(0, 1000, 1);</a>
<a name="ln1150">  d-&gt;b_bottom = gtk_spin_button_new_with_range(0, 1000, 1);</a>
<a name="ln1151"> </a>
<a name="ln1152">  gtk_entry_set_alignment (GTK_ENTRY(d-&gt;b_top), 1);</a>
<a name="ln1153">  gtk_entry_set_alignment (GTK_ENTRY(d-&gt;b_left), 1);</a>
<a name="ln1154">  gtk_entry_set_alignment (GTK_ENTRY(d-&gt;b_right), 1);</a>
<a name="ln1155">  gtk_entry_set_alignment (GTK_ENTRY(d-&gt;b_bottom), 1);</a>
<a name="ln1156"> </a>
<a name="ln1157">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;b_top));</a>
<a name="ln1158">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;b_left));</a>
<a name="ln1159">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;b_right));</a>
<a name="ln1160">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;b_bottom));</a>
<a name="ln1161"> </a>
<a name="ln1162">  ////////////////////////// PRINTER SETTINGS</a>
<a name="ln1163"> </a>
<a name="ln1164">  // create papers combo as filled when adding printers</a>
<a name="ln1165">  d-&gt;papers = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1166"> </a>
<a name="ln1167">  label = dt_ui_section_label_new(_(&quot;printer&quot;));</a>
<a name="ln1168">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), label, TRUE, TRUE, 0);</a>
<a name="ln1169">  dt_gui_add_help_link(self-&gt;widget, &quot;print_usage.html#print_printer_section&quot;);</a>
<a name="ln1170">  d-&gt;printers = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1171"> </a>
<a name="ln1172">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), d-&gt;printers, TRUE, TRUE, 0);</a>
<a name="ln1173">  g_signal_connect(G_OBJECT(d-&gt;printers), &quot;value-changed&quot;, G_CALLBACK(_printer_changed), self);</a>
<a name="ln1174"> </a>
<a name="ln1175">  //// media</a>
<a name="ln1176"> </a>
<a name="ln1177">  d-&gt;media = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1178"> </a>
<a name="ln1179">  dt_bauhaus_widget_set_label(d-&gt;media, NULL, _(&quot;media&quot;));</a>
<a name="ln1180"> </a>
<a name="ln1181">  g_signal_connect(G_OBJECT(d-&gt;media), &quot;value-changed&quot;, G_CALLBACK(_media_changed), self);</a>
<a name="ln1182">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;media), TRUE, TRUE, 0);</a>
<a name="ln1183"> </a>
<a name="ln1184">  //  Add printer profile combo</a>
<a name="ln1185"> </a>
<a name="ln1186">  d-&gt;pprofile = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1187">  dt_bauhaus_widget_set_label(d-&gt;pprofile, NULL, _(&quot;profile&quot;));</a>
<a name="ln1188"> </a>
<a name="ln1189">  int combo_idx, n;</a>
<a name="ln1190">  GList *l = d-&gt;profiles;</a>
<a name="ln1191"> </a>
<a name="ln1192">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;pprofile), TRUE, TRUE, 0);</a>
<a name="ln1193">  int printer_profile_type = dt_conf_get_int(&quot;plugins/print/printer/icctype&quot;);</a>
<a name="ln1194">  gchar *printer_profile = dt_conf_get_string(&quot;plugins/print/printer/iccprofile&quot;);</a>
<a name="ln1195">  combo_idx = -1;</a>
<a name="ln1196">  n = 0;</a>
<a name="ln1197"> </a>
<a name="ln1198">  dt_bauhaus_combobox_add(d-&gt;pprofile, _(&quot;color management in printer driver&quot;));</a>
<a name="ln1199">  while(l)</a>
<a name="ln1200">  {</a>
<a name="ln1201">    dt_lib_export_profile_t *prof = (dt_lib_export_profile_t *)l-&gt;data;</a>
<a name="ln1202">    // do not add built-in profiles, these are in no way for printing</a>
<a name="ln1203">    if(prof-&gt;type == DT_COLORSPACE_FILE)</a>
<a name="ln1204">    {</a>
<a name="ln1205">      dt_bauhaus_combobox_add(d-&gt;pprofile, prof-&gt;name);</a>
<a name="ln1206">      prof-&gt;ppos = ++n;</a>
<a name="ln1207">      if(prof-&gt;type == printer_profile_type &amp;&amp;</a>
<a name="ln1208">        (prof-&gt;type != DT_COLORSPACE_FILE || !g_strcmp0(prof-&gt;filename, printer_profile)))</a>
<a name="ln1209">      {</a>
<a name="ln1210">        g_free(d-&gt;v_piccprofile);</a>
<a name="ln1211">        d-&gt;v_picctype = printer_profile_type;</a>
<a name="ln1212">        d-&gt;v_piccprofile = g_strdup(printer_profile);</a>
<a name="ln1213">        combo_idx = n;</a>
<a name="ln1214">      }</a>
<a name="ln1215">    }</a>
<a name="ln1216">    l = g_list_next(l);</a>
<a name="ln1217">  }</a>
<a name="ln1218"> </a>
<a name="ln1219">  g_free (printer_profile);</a>
<a name="ln1220"> </a>
<a name="ln1221">  // profile not found, maybe a profile has been removed? revert to none</a>
<a name="ln1222">  if (combo_idx == -1)</a>
<a name="ln1223">  {</a>
<a name="ln1224">    dt_conf_set_int(&quot;plugins/print/printer/icctype&quot;, DT_COLORSPACE_NONE);</a>
<a name="ln1225">    dt_conf_set_string(&quot;plugins/print/printer/iccprofile&quot;, &quot;&quot;);</a>
<a name="ln1226">    g_free(d-&gt;v_piccprofile);</a>
<a name="ln1227">    d-&gt;v_picctype = DT_COLORSPACE_NONE;</a>
<a name="ln1228">    d-&gt;v_piccprofile = g_strdup(&quot;&quot;);</a>
<a name="ln1229">    combo_idx = 0;</a>
<a name="ln1230">  }</a>
<a name="ln1231">  dt_bauhaus_combobox_set(d-&gt;pprofile, combo_idx);</a>
<a name="ln1232"> </a>
<a name="ln1233">  char *tooltip = g_strdup_printf(_(&quot;printer ICC profiles in %s or %s&quot;), user_profile_dir, system_profile_dir);</a>
<a name="ln1234">  gtk_widget_set_tooltip_text(d-&gt;pprofile, tooltip);</a>
<a name="ln1235">  g_free(tooltip);</a>
<a name="ln1236"> </a>
<a name="ln1237">  g_signal_connect(G_OBJECT(d-&gt;pprofile), &quot;value-changed&quot;, G_CALLBACK(_printer_profile_changed), (gpointer)self);</a>
<a name="ln1238"> </a>
<a name="ln1239">  //  Add printer intent combo</a>
<a name="ln1240"> </a>
<a name="ln1241">  d-&gt;pintent = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1242">  dt_bauhaus_widget_set_label(d-&gt;pintent, NULL, _(&quot;intent&quot;));</a>
<a name="ln1243">  dt_bauhaus_combobox_add(d-&gt;pintent, _(&quot;perceptual&quot;));</a>
<a name="ln1244">  dt_bauhaus_combobox_add(d-&gt;pintent, _(&quot;relative colorimetric&quot;));</a>
<a name="ln1245">  dt_bauhaus_combobox_add(d-&gt;pintent, C_(&quot;rendering intent&quot;, &quot;saturation&quot;));</a>
<a name="ln1246">  dt_bauhaus_combobox_add(d-&gt;pintent, _(&quot;absolute colorimetric&quot;));</a>
<a name="ln1247">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;pintent), TRUE, TRUE, 0);</a>
<a name="ln1248"> </a>
<a name="ln1249">  d-&gt;v_pintent = dt_conf_get_int(&quot;plugins/print/printer/iccintent&quot;);</a>
<a name="ln1250">  dt_bauhaus_combobox_set(d-&gt;pintent, d-&gt;v_pintent);</a>
<a name="ln1251"> </a>
<a name="ln1252">  g_signal_connect (G_OBJECT (d-&gt;pintent), &quot;value-changed&quot;, G_CALLBACK (_printer_intent_callback), (gpointer)self);</a>
<a name="ln1253">  d-&gt;prt.printer.intent = d-&gt;v_pintent;</a>
<a name="ln1254"> </a>
<a name="ln1255">  d-&gt;black_point_compensation = gtk_check_button_new_with_label(_(&quot;black point compensation&quot;));</a>
<a name="ln1256">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;black_point_compensation), TRUE, FALSE, 0);</a>
<a name="ln1257">  g_signal_connect(d-&gt;black_point_compensation, &quot;toggled&quot;, G_CALLBACK(_printer_bpc_callback), (gpointer)self);</a>
<a name="ln1258"> </a>
<a name="ln1259">  d-&gt;v_black_point_compensation = dt_conf_get_bool(&quot;plugins/print/print/black_point_compensation&quot;);</a>
<a name="ln1260">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;black_point_compensation), d-&gt;v_black_point_compensation);</a>
<a name="ln1261"> </a>
<a name="ln1262">  gtk_widget_set_tooltip_text(d-&gt;black_point_compensation,</a>
<a name="ln1263">                              _(&quot;activate black point compensation when applying the printer profile&quot;));</a>
<a name="ln1264"> </a>
<a name="ln1265">  gtk_widget_set_sensitive(GTK_WIDGET(d-&gt;black_point_compensation), combo_idx==0?FALSE:TRUE);</a>
<a name="ln1266"> </a>
<a name="ln1267">  ////////////////////////// PAGE SETTINGS</a>
<a name="ln1268"> </a>
<a name="ln1269">  label = dt_ui_section_label_new(_(&quot;page&quot;));</a>
<a name="ln1270">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), label, TRUE, TRUE, 0);</a>
<a name="ln1271">  dt_gui_add_help_link(self-&gt;widget, &quot;print_page_section.html#print_page_section&quot;);</a>
<a name="ln1272"> </a>
<a name="ln1273">  //// papers</a>
<a name="ln1274"> </a>
<a name="ln1275">  dt_bauhaus_widget_set_label(d-&gt;papers, NULL, _(&quot;paper size&quot;));</a>
<a name="ln1276"> </a>
<a name="ln1277">  g_signal_connect(G_OBJECT(d-&gt;papers), &quot;value-changed&quot;, G_CALLBACK(_paper_changed), self);</a>
<a name="ln1278">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;papers), TRUE, TRUE, 0);</a>
<a name="ln1279"> </a>
<a name="ln1280">  //// portrait / landscape</a>
<a name="ln1281"> </a>
<a name="ln1282">  d-&gt;orientation = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1283">  dt_bauhaus_widget_set_label(d-&gt;orientation, NULL, _(&quot;orientation&quot;));</a>
<a name="ln1284">  dt_bauhaus_combobox_add(d-&gt;orientation, _(&quot;portrait&quot;));</a>
<a name="ln1285">  dt_bauhaus_combobox_add(d-&gt;orientation, _(&quot;landscape&quot;));</a>
<a name="ln1286"> </a>
<a name="ln1287">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;orientation), TRUE, TRUE, 0);</a>
<a name="ln1288"> </a>
<a name="ln1289">  GtkWidget *ucomb = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1290">  dt_bauhaus_combobox_add(ucomb, _(&quot;mm&quot;));</a>
<a name="ln1291">  dt_bauhaus_combobox_add(ucomb, _(&quot;cm&quot;));</a>
<a name="ln1292">  dt_bauhaus_combobox_add(ucomb, _(&quot;inch&quot;));</a>
<a name="ln1293">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), ucomb, TRUE, TRUE, 0);</a>
<a name="ln1294"> </a>
<a name="ln1295">  g_signal_connect(G_OBJECT(d-&gt;orientation), &quot;value-changed&quot;, G_CALLBACK(_orientation_changed), self);</a>
<a name="ln1296">  g_signal_connect(G_OBJECT(ucomb), &quot;value-changed&quot;, G_CALLBACK(_unit_changed), self);</a>
<a name="ln1297"> </a>
<a name="ln1298">  d-&gt;unit = dt_conf_get_int(&quot;plugins/print/print/unit&quot;);</a>
<a name="ln1299">  dt_bauhaus_combobox_set(ucomb, d-&gt;unit);</a>
<a name="ln1300"> </a>
<a name="ln1301">  dt_bauhaus_combobox_set (d-&gt;orientation, d-&gt;prt.page.landscape?1:0);</a>
<a name="ln1302"> </a>
<a name="ln1303">  //// image dimensions, create them now as we need them</a>
<a name="ln1304"> </a>
<a name="ln1305">  GtkWidget *hboxdim = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);</a>
<a name="ln1306">  label = gtk_label_new(_(&quot;image width/height&quot;));</a>
<a name="ln1307">  gtk_box_pack_start(GTK_BOX(hboxdim),GTK_WIDGET(label),TRUE,TRUE,0);</a>
<a name="ln1308">  d-&gt;width = gtk_label_new(_(&quot;width&quot;));</a>
<a name="ln1309">  gtk_box_pack_start(GTK_BOX(hboxdim),GTK_WIDGET(d-&gt;width),TRUE,TRUE,0);</a>
<a name="ln1310">  label = gtk_label_new(_(&quot; x &quot;));</a>
<a name="ln1311">  gtk_box_pack_start(GTK_BOX(hboxdim),GTK_WIDGET(label),TRUE,TRUE,0);</a>
<a name="ln1312">  d-&gt;height = gtk_label_new(_(&quot;height&quot;));</a>
<a name="ln1313">  gtk_box_pack_start(GTK_BOX(hboxdim),GTK_WIDGET(d-&gt;height),TRUE,TRUE,0);</a>
<a name="ln1314"> </a>
<a name="ln1315">  //// image information (downscale/upscale)</a>
<a name="ln1316"> </a>
<a name="ln1317">  GtkWidget *hboxinfo = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);</a>
<a name="ln1318">  label = gtk_label_new(_(&quot;scale factor&quot;));</a>
<a name="ln1319">  gtk_box_pack_start(GTK_BOX(hboxinfo),GTK_WIDGET(label),TRUE,TRUE,0);</a>
<a name="ln1320">  d-&gt;info = gtk_label_new(&quot;1.0&quot;);</a>
<a name="ln1321">  gtk_box_pack_start(GTK_BOX(hboxinfo),GTK_WIDGET(d-&gt;info),TRUE,TRUE,0);</a>
<a name="ln1322">  gtk_widget_set_tooltip_text(hboxinfo,</a>
<a name="ln1323">               _(&quot;image scale factor from native printer DPI:\n&quot;</a>
<a name="ln1324">                 &quot; &lt; 1 means that it is downscaled (best quality)\n&quot;</a>
<a name="ln1325">                 &quot; &gt; 1 means that the image is upscaled\n&quot;</a>
<a name="ln1326">                 &quot; a too large value may result in poor print quality&quot;));</a>
<a name="ln1327"> </a>
<a name="ln1328">  //// borders</a>
<a name="ln1329"> </a>
<a name="ln1330">  GtkGrid *bds = GTK_GRID(gtk_grid_new());</a>
<a name="ln1331">  gtk_grid_set_row_spacing(bds, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1332">  gtk_grid_set_column_spacing(bds, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1333"> </a>
<a name="ln1334">  d-&gt;lock_activated = FALSE;</a>
<a name="ln1335"> </a>
<a name="ln1336">  //d-&gt;b_top  = gtk_spin_button_new_with_range(0, 10000, 1);</a>
<a name="ln1337">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;b_top), _(&quot;top margin&quot;));</a>
<a name="ln1338">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;b_top), 1, 0, 1, 1);</a>
<a name="ln1339"> </a>
<a name="ln1340">  //d-&gt;b_left  = gtk_spin_button_new_with_range(0, 10000, 1);</a>
<a name="ln1341">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;b_left), _(&quot;left margin&quot;));</a>
<a name="ln1342">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;b_left), 0, 1, 1, 1);</a>
<a name="ln1343"> </a>
<a name="ln1344">  d-&gt;lock_button = GTK_TOGGLE_BUTTON(gtk_toggle_button_new_with_label(_(&quot;lock&quot;)));</a>
<a name="ln1345">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;lock_button), _(&quot;change all margins uniformly&quot;));</a>
<a name="ln1346">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;lock_button), 1, 1, 1, 1);</a>
<a name="ln1347"> </a>
<a name="ln1348">  //d-&gt;b_right  = gtk_spin_button_new_with_range(0, 10000, 1);</a>
<a name="ln1349">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;b_right), _(&quot;right margin&quot;));</a>
<a name="ln1350">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;b_right), 2, 1, 1, 1);</a>
<a name="ln1351"> </a>
<a name="ln1352">  //d-&gt;b_bottom  = gtk_spin_button_new_with_range(0, 10000, 1);</a>
<a name="ln1353">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;b_bottom), _(&quot;bottom margin&quot;));</a>
<a name="ln1354">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;b_bottom), 1, 2, 1, 1);</a>
<a name="ln1355"> </a>
<a name="ln1356">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(bds), TRUE, TRUE, 0);</a>
<a name="ln1357"> </a>
<a name="ln1358">  g_signal_connect (G_OBJECT (d-&gt;b_top), &quot;value-changed&quot;,</a>
<a name="ln1359">                    G_CALLBACK (_top_border_callback), self);</a>
<a name="ln1360">  g_signal_connect (G_OBJECT (d-&gt;b_bottom), &quot;value-changed&quot;,</a>
<a name="ln1361">                    G_CALLBACK (_bottom_border_callback), self);</a>
<a name="ln1362">  g_signal_connect (G_OBJECT (d-&gt;b_left), &quot;value-changed&quot;,</a>
<a name="ln1363">                    G_CALLBACK (_left_border_callback), self);</a>
<a name="ln1364">  g_signal_connect (G_OBJECT (d-&gt;b_right), &quot;value-changed&quot;,</a>
<a name="ln1365">                    G_CALLBACK (_right_border_callback), self);</a>
<a name="ln1366">  g_signal_connect (G_OBJECT(d-&gt;lock_button), &quot;toggled&quot;,</a>
<a name="ln1367">                    G_CALLBACK(_lock_callback), self);</a>
<a name="ln1368"> </a>
<a name="ln1369">  const gboolean lock_active = dt_conf_get_bool(&quot;plugins/print/print/lock_borders&quot;);</a>
<a name="ln1370">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;lock_button), lock_active);</a>
<a name="ln1371"> </a>
<a name="ln1372">  // pack image dimension hbox here</a>
<a name="ln1373"> </a>
<a name="ln1374">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hboxdim), TRUE, TRUE, 0);</a>
<a name="ln1375">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hboxinfo), TRUE, TRUE, 0);</a>
<a name="ln1376"> </a>
<a name="ln1377">  //// alignments</a>
<a name="ln1378"> </a>
<a name="ln1379">  // Create the 3x3 gtk table toggle button table...</a>
<a name="ln1380">  GtkGrid *bat = GTK_GRID(gtk_grid_new());</a>
<a name="ln1381">  gtk_grid_set_row_spacing(bat, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1382">  gtk_grid_set_column_spacing(bat, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1383">  for(int i=0; i&lt;9; i++)</a>
<a name="ln1384">  {</a>
<a name="ln1385">    d-&gt;dtba[i] = DTGTK_TOGGLEBUTTON (dtgtk_togglebutton_new (dtgtk_cairo_paint_alignment,CPF_STYLE_FLAT|(CPF_SPECIAL_FLAG&lt;&lt;i), NULL));</a>
<a name="ln1386">    gtk_grid_attach (GTK_GRID (bat), GTK_WIDGET (d-&gt;dtba[i]), (i%3), i/3, 1, 1);</a>
<a name="ln1387">    g_signal_connect (G_OBJECT (d-&gt;dtba[i]), &quot;toggled&quot;,G_CALLBACK (_alignment_callback), self);</a>
<a name="ln1388">  }</a>
<a name="ln1389">  d-&gt;prt.page.alignment = ALIGNMENT_CENTER;</a>
<a name="ln1390">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;dtba[d-&gt;prt.page.alignment]),TRUE);</a>
<a name="ln1391"> </a>
<a name="ln1392">  GtkWidget *hbox22 = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);</a>
<a name="ln1393">  GtkWidget *label4 = gtk_label_new(_(&quot;alignment&quot;));</a>
<a name="ln1394">  gtk_box_pack_start(GTK_BOX(hbox22),GTK_WIDGET(label4),TRUE,TRUE,0);</a>
<a name="ln1395">  gtk_box_pack_start(GTK_BOX(hbox22), GTK_WIDGET(bat), TRUE, TRUE, 0);</a>
<a name="ln1396">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hbox22), TRUE, TRUE, 0);</a>
<a name="ln1397"> </a>
<a name="ln1398">  ////////////////////////// PRINT SETTINGS</a>
<a name="ln1399"> </a>
<a name="ln1400">  label = dt_ui_section_label_new(_(&quot;print settings&quot;));</a>
<a name="ln1401">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), label, TRUE, TRUE, 0);</a>
<a name="ln1402">  dt_gui_add_help_link(self-&gt;widget, &quot;print_settings.html#print_settings&quot;);</a>
<a name="ln1403"> </a>
<a name="ln1404">  //  Add export profile combo</a>
<a name="ln1405"> </a>
<a name="ln1406">  d-&gt;profile = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1407">  dt_bauhaus_widget_set_label(d-&gt;profile, NULL, _(&quot;profile&quot;));</a>
<a name="ln1408"> </a>
<a name="ln1409">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;profile), TRUE, TRUE, 0);</a>
<a name="ln1410">  dt_bauhaus_combobox_add(d-&gt;profile, _(&quot;image settings&quot;));</a>
<a name="ln1411"> </a>
<a name="ln1412">  int icctype = dt_conf_get_int(&quot;plugins/print/print/icctype&quot;);</a>
<a name="ln1413">  gchar *iccprofile = dt_conf_get_string(&quot;plugins/print/print/iccprofile&quot;);</a>
<a name="ln1414">  combo_idx = -1;</a>
<a name="ln1415">  n = 0;</a>
<a name="ln1416"> </a>
<a name="ln1417">  l = d-&gt;profiles;</a>
<a name="ln1418">  while(l)</a>
<a name="ln1419">  {</a>
<a name="ln1420">    dt_lib_export_profile_t *prof = (dt_lib_export_profile_t *)l-&gt;data;</a>
<a name="ln1421">    dt_bauhaus_combobox_add(d-&gt;profile, prof-&gt;name);</a>
<a name="ln1422">    prof-&gt;pos = ++n;</a>
<a name="ln1423">    if(prof-&gt;type == icctype &amp;&amp; (prof-&gt;type != DT_COLORSPACE_FILE || !g_strcmp0(prof-&gt;filename, iccprofile)))</a>
<a name="ln1424">    {</a>
<a name="ln1425">      g_free(d-&gt;v_iccprofile);</a>
<a name="ln1426">      d-&gt;v_icctype = icctype;</a>
<a name="ln1427">      d-&gt;v_iccprofile = g_strdup(iccprofile);</a>
<a name="ln1428">      combo_idx = n;</a>
<a name="ln1429">    }</a>
<a name="ln1430">    l = g_list_next(l);</a>
<a name="ln1431">  }</a>
<a name="ln1432"> </a>
<a name="ln1433">  if (combo_idx == -1)</a>
<a name="ln1434">  {</a>
<a name="ln1435">    dt_conf_set_int(&quot;plugins/print/print/icctype&quot;, DT_COLORSPACE_NONE);</a>
<a name="ln1436">    dt_conf_set_string(&quot;plugins/print/print/iccprofile&quot;, &quot;&quot;);</a>
<a name="ln1437">    g_free(d-&gt;v_iccprofile);</a>
<a name="ln1438">    d-&gt;v_icctype = DT_COLORSPACE_NONE;</a>
<a name="ln1439">    d-&gt;v_iccprofile = g_strdup(&quot;&quot;);</a>
<a name="ln1440">    combo_idx = 0;</a>
<a name="ln1441">  }</a>
<a name="ln1442">  g_free (iccprofile);</a>
<a name="ln1443"> </a>
<a name="ln1444">  dt_bauhaus_combobox_set(d-&gt;profile, combo_idx);</a>
<a name="ln1445"> </a>
<a name="ln1446">  tooltip = g_strdup_printf(_(&quot;output ICC profiles in %s or %s&quot;), user_profile_dir, system_profile_dir);</a>
<a name="ln1447">  gtk_widget_set_tooltip_text(d-&gt;profile, tooltip);</a>
<a name="ln1448">  g_free(tooltip);</a>
<a name="ln1449"> </a>
<a name="ln1450">  g_signal_connect(G_OBJECT(d-&gt;profile), &quot;value-changed&quot;, G_CALLBACK(_profile_changed), (gpointer)self);</a>
<a name="ln1451"> </a>
<a name="ln1452">  //  Add export intent combo</a>
<a name="ln1453"> </a>
<a name="ln1454">  d-&gt;intent = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1455">  dt_bauhaus_widget_set_label(d-&gt;intent, NULL, _(&quot;intent&quot;));</a>
<a name="ln1456"> </a>
<a name="ln1457">  dt_bauhaus_combobox_add(d-&gt;intent, _(&quot;image settings&quot;));</a>
<a name="ln1458">  dt_bauhaus_combobox_add(d-&gt;intent, _(&quot;perceptual&quot;));</a>
<a name="ln1459">  dt_bauhaus_combobox_add(d-&gt;intent, _(&quot;relative colorimetric&quot;));</a>
<a name="ln1460">  dt_bauhaus_combobox_add(d-&gt;intent, C_(&quot;rendering intent&quot;, &quot;saturation&quot;));</a>
<a name="ln1461">  dt_bauhaus_combobox_add(d-&gt;intent, _(&quot;absolute colorimetric&quot;));</a>
<a name="ln1462">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;intent), TRUE, TRUE, 0);</a>
<a name="ln1463"> </a>
<a name="ln1464">  dt_bauhaus_combobox_set(d-&gt;intent, dt_conf_get_int(&quot;plugins/print/print/iccintent&quot;) + 1);</a>
<a name="ln1465"> </a>
<a name="ln1466">  g_signal_connect (G_OBJECT (d-&gt;intent), &quot;value-changed&quot;, G_CALLBACK (_intent_callback), (gpointer)self);</a>
<a name="ln1467"> </a>
<a name="ln1468">  //  Add export style combo</a>
<a name="ln1469"> </a>
<a name="ln1470">  d-&gt;style = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1471">  dt_bauhaus_widget_set_label(d-&gt;style, NULL, _(&quot;style&quot;));</a>
<a name="ln1472"> </a>
<a name="ln1473">  dt_bauhaus_combobox_add(d-&gt;style, _(&quot;none&quot;));</a>
<a name="ln1474"> </a>
<a name="ln1475">  GList *styles = dt_styles_get_list(&quot;&quot;);</a>
<a name="ln1476">  gchar *current_style = dt_conf_get_string(&quot;plugins/print/print/style&quot;);</a>
<a name="ln1477">  combo_idx = -1; n=0;</a>
<a name="ln1478"> </a>
<a name="ln1479">  while (styles)</a>
<a name="ln1480">  {</a>
<a name="ln1481">    dt_style_t *style=(dt_style_t *)styles-&gt;data;</a>
<a name="ln1482">    dt_bauhaus_combobox_add(d-&gt;style, style-&gt;name);</a>
<a name="ln1483">    n++;</a>
<a name="ln1484">    if (g_strcmp0(style-&gt;name,current_style)==0)</a>
<a name="ln1485">    {</a>
<a name="ln1486">      g_free(d-&gt;v_style);</a>
<a name="ln1487">      d-&gt;v_style = g_strdup(current_style);</a>
<a name="ln1488">      combo_idx=n;</a>
<a name="ln1489">    }</a>
<a name="ln1490">    styles=g_list_next(styles);</a>
<a name="ln1491">  }</a>
<a name="ln1492">  g_free(current_style);</a>
<a name="ln1493">  g_list_free_full(styles, dt_style_free);</a>
<a name="ln1494">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;style), TRUE, TRUE, 0);</a>
<a name="ln1495">  gtk_widget_set_tooltip_text(d-&gt;style, _(&quot;temporary style to use while printing&quot;));</a>
<a name="ln1496"> </a>
<a name="ln1497">  // style not found, maybe a style has been removed? revert to none</a>
<a name="ln1498">  if (combo_idx == -1)</a>
<a name="ln1499">  {</a>
<a name="ln1500">    dt_conf_set_string(&quot;plugins/print/print/style&quot;, &quot;&quot;);</a>
<a name="ln1501">    g_free(d-&gt;v_style);</a>
<a name="ln1502">    d-&gt;v_style = g_strdup(&quot;&quot;);</a>
<a name="ln1503">    combo_idx=0;</a>
<a name="ln1504">  }</a>
<a name="ln1505">  dt_bauhaus_combobox_set(d-&gt;style, combo_idx);</a>
<a name="ln1506"> </a>
<a name="ln1507">  g_signal_connect (G_OBJECT (d-&gt;style), &quot;value-changed&quot;,</a>
<a name="ln1508">                    G_CALLBACK (_style_callback),</a>
<a name="ln1509">                    (gpointer)self);</a>
<a name="ln1510"> </a>
<a name="ln1511">  //  Whether to add/replace style items</a>
<a name="ln1512"> </a>
<a name="ln1513">  d-&gt;style_mode = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1514">  dt_bauhaus_widget_set_label(d-&gt;style_mode, NULL, _(&quot;mode&quot;));</a>
<a name="ln1515"> </a>
<a name="ln1516">  dt_bauhaus_combobox_add(d-&gt;style_mode, _(&quot;replace history&quot;));</a>
<a name="ln1517">  dt_bauhaus_combobox_add(d-&gt;style_mode, _(&quot;append history&quot;));</a>
<a name="ln1518"> </a>
<a name="ln1519">  d-&gt;v_style_append = dt_conf_get_bool(&quot;plugins/print/print/style_append&quot;);</a>
<a name="ln1520">  dt_bauhaus_combobox_set(d-&gt;style_mode, d-&gt;v_style_append?1:0);</a>
<a name="ln1521"> </a>
<a name="ln1522">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;style_mode), TRUE, TRUE, 0);</a>
<a name="ln1523">  gtk_widget_set_tooltip_text(d-&gt;style_mode,</a>
<a name="ln1524">                              _(&quot;whether the style items are appended to the history or replacing the history&quot;));</a>
<a name="ln1525"> </a>
<a name="ln1526">  gtk_widget_set_sensitive(GTK_WIDGET(d-&gt;style_mode), combo_idx==0?FALSE:TRUE);</a>
<a name="ln1527"> </a>
<a name="ln1528">  g_signal_connect(G_OBJECT(d-&gt;style_mode), &quot;value-changed&quot;, G_CALLBACK(_style_mode_changed), (gpointer)self);</a>
<a name="ln1529"> </a>
<a name="ln1530">  // Print button</a>
<a name="ln1531"> </a>
<a name="ln1532">  GtkButton *button = GTK_BUTTON(gtk_button_new_with_label(_(&quot;print&quot;)));</a>
<a name="ln1533">  d-&gt;print_button = button;</a>
<a name="ln1534">  gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;print with current settings&quot;));</a>
<a name="ln1535">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(button), TRUE, TRUE, 0);</a>
<a name="ln1536">  dt_gui_add_help_link(GTK_WIDGET(button), &quot;print_button.html#print_button&quot;);</a>
<a name="ln1537"> </a>
<a name="ln1538">  g_signal_connect (G_OBJECT (button), &quot;clicked&quot;,</a>
<a name="ln1539">                    G_CALLBACK (_print_button_clicked),</a>
<a name="ln1540">                    (gpointer)self);</a>
<a name="ln1541"> </a>
<a name="ln1542">  g_free(system_profile_dir);</a>
<a name="ln1543">  g_free(user_profile_dir);</a>
<a name="ln1544"> </a>
<a name="ln1545">  // Let's start the printer discovery now</a>
<a name="ln1546"> </a>
<a name="ln1547">  dt_printers_discovery(_new_printer_callback, self);</a>
<a name="ln1548">}</a>
<a name="ln1549"> </a>
<a name="ln1550">static gboolean _bauhaus_combobox_set_active_text(GtkWidget *cb, const gchar *text)</a>
<a name="ln1551">{</a>
<a name="ln1552">  g_assert(text != NULL);</a>
<a name="ln1553">  g_assert(cb != NULL);</a>
<a name="ln1554">  const GList *labels = dt_bauhaus_combobox_get_labels(cb);</a>
<a name="ln1555">  const GList *iter = labels;</a>
<a name="ln1556">  int i = 0;</a>
<a name="ln1557">  while(iter)</a>
<a name="ln1558">  {</a>
<a name="ln1559">    if(!g_strcmp0((gchar*)iter-&gt;data, text))</a>
<a name="ln1560">    {</a>
<a name="ln1561">      dt_bauhaus_combobox_set(cb, i);</a>
<a name="ln1562">      return TRUE;</a>
<a name="ln1563">    }</a>
<a name="ln1564">    i++;</a>
<a name="ln1565">    iter = g_list_next(iter);</a>
<a name="ln1566">  }</a>
<a name="ln1567">  return FALSE;</a>
<a name="ln1568">}</a>
<a name="ln1569"> </a>
<a name="ln1570">void init_presets(dt_lib_module_t *self)</a>
<a name="ln1571">{</a>
<a name="ln1572">}</a>
<a name="ln1573"> </a>
<a name="ln1574">void *legacy_params(dt_lib_module_t *self, const void *const old_params, const size_t old_params_size,</a>
<a name="ln1575">                    const int old_version, int *new_version, size_t *new_size)</a>
<a name="ln1576">{</a>
<a name="ln1577">  if(old_version == 1)</a>
<a name="ln1578">  {</a>
<a name="ln1579">    // we added the profile type</a>
<a name="ln1580">    //</a>
<a name="ln1581">    // old format:</a>
<a name="ln1582">    //   char *printer</a>
<a name="ln1583">    //   char *paper</a>
<a name="ln1584">    //   int32_t landscape</a>
<a name="ln1585">    //   char *f_profile</a>
<a name="ln1586">    //   int32_t intent</a>
<a name="ln1587">    //   char *f_pprofile</a>
<a name="ln1588">    //   &lt;rest&gt;</a>
<a name="ln1589">    //</a>
<a name="ln1590">    // new format:</a>
<a name="ln1591">    //   char *printer</a>
<a name="ln1592">    //   char *paper</a>
<a name="ln1593">    //   int32_t landscape</a>
<a name="ln1594">    //   int32_t f_profile_type</a>
<a name="ln1595">    //   char *f_profile</a>
<a name="ln1596">    //   int32_t intent</a>
<a name="ln1597">    //   int32_t f_pprofile_type</a>
<a name="ln1598">    //   char *f_pprofile</a>
<a name="ln1599">    //   &lt;rest&gt;</a>
<a name="ln1600"> </a>
<a name="ln1601">    const char *buf = (const char *)old_params;</a>
<a name="ln1602"> </a>
<a name="ln1603">    // printer</a>
<a name="ln1604">    const char *printer = buf;</a>
<a name="ln1605">    const int32_t printer_len = strlen(printer) + 1;</a>
<a name="ln1606">    buf += printer_len;</a>
<a name="ln1607"> </a>
<a name="ln1608">    // paper</a>
<a name="ln1609">    const char *paper = buf;</a>
<a name="ln1610">    const int32_t paper_len = strlen(paper) + 1;</a>
<a name="ln1611">    buf += paper_len;</a>
<a name="ln1612"> </a>
<a name="ln1613">    // landscape</a>
<a name="ln1614">    const int32_t landscape = *(int32_t *)buf;</a>
<a name="ln1615">    buf +=  sizeof(int32_t);</a>
<a name="ln1616"> </a>
<a name="ln1617">    // profile</a>
<a name="ln1618">    const char *profile = buf;</a>
<a name="ln1619">    const int32_t profile_len = strlen(profile) + 1;</a>
<a name="ln1620">    buf += profile_len;</a>
<a name="ln1621"> </a>
<a name="ln1622">    // intent</a>
<a name="ln1623">    const int32_t intent = *(int32_t *)buf;</a>
<a name="ln1624">    buf += sizeof(int32_t);</a>
<a name="ln1625"> </a>
<a name="ln1626">    // pprofile</a>
<a name="ln1627">    const char *pprofile = buf;</a>
<a name="ln1628">    const int32_t pprofile_len = strlen(pprofile) + 1;</a>
<a name="ln1629">    buf += pprofile_len;</a>
<a name="ln1630"> </a>
<a name="ln1631"> </a>
<a name="ln1632">    // now we got all fields from the start of the buffer and buf points to the beginning or &lt;rest&gt;</a>
<a name="ln1633"> </a>
<a name="ln1634">    // find the new values for the two profiles</a>
<a name="ln1635">    dt_colorspaces_color_profile_type_t profile_type, pprofile_type;</a>
<a name="ln1636">    const char *profile_filename = &quot;&quot;, *pprofile_filename = &quot;&quot;;</a>
<a name="ln1637"> </a>
<a name="ln1638">    if(*profile == '\0' || !g_strcmp0(profile, &quot;none&quot;))</a>
<a name="ln1639">    {</a>
<a name="ln1640">      profile_type = DT_COLORSPACE_NONE;</a>
<a name="ln1641">    }</a>
<a name="ln1642">    else if(!g_strcmp0(profile, &quot;sRGB&quot;))</a>
<a name="ln1643">    {</a>
<a name="ln1644">      profile_type = DT_COLORSPACE_SRGB;</a>
<a name="ln1645">    }</a>
<a name="ln1646">    else if(!g_strcmp0(profile, &quot;adobergb&quot;))</a>
<a name="ln1647">    {</a>
<a name="ln1648">      profile_type = DT_COLORSPACE_ADOBERGB;</a>
<a name="ln1649">    }</a>
<a name="ln1650">    else</a>
<a name="ln1651">    {</a>
<a name="ln1652">      profile_type = DT_COLORSPACE_FILE;</a>
<a name="ln1653">      profile_filename = &amp;profile[1]; // the old code had a '/' in the beginning</a>
<a name="ln1654">    }</a>
<a name="ln1655"> </a>
<a name="ln1656">    // in theory pprofile can't be srgb or adobergb, but checking for them won't hurt</a>
<a name="ln1657">    if(*pprofile == '\0')</a>
<a name="ln1658">    {</a>
<a name="ln1659">      pprofile_type = DT_COLORSPACE_NONE;</a>
<a name="ln1660">    }</a>
<a name="ln1661">    else if(!g_strcmp0(pprofile, &quot;sRGB&quot;))</a>
<a name="ln1662">    {</a>
<a name="ln1663">      pprofile_type = DT_COLORSPACE_SRGB;</a>
<a name="ln1664">    }</a>
<a name="ln1665">    else if(!g_strcmp0(pprofile, &quot;adobergb&quot;))</a>
<a name="ln1666">    {</a>
<a name="ln1667">      pprofile_type = DT_COLORSPACE_ADOBERGB;</a>
<a name="ln1668">    }</a>
<a name="ln1669">    else</a>
<a name="ln1670">    {</a>
<a name="ln1671">      pprofile_type = DT_COLORSPACE_FILE;</a>
<a name="ln1672">      pprofile_filename = &amp;pprofile[1]; // the old code had a '/' in the beginning</a>
<a name="ln1673">    }</a>
<a name="ln1674"> </a>
<a name="ln1675">    int32_t new_profile_len = strlen(profile_filename) + 1;</a>
<a name="ln1676">    int32_t new_pprofile_len = strlen(pprofile_filename) + 1;</a>
<a name="ln1677"> </a>
<a name="ln1678">    // now we got everything to reassemble the new params</a>
<a name="ln1679">    size_t new_params_size = old_params_size - profile_len - pprofile_len;</a>
<a name="ln1680">    new_params_size += 2 * sizeof(dt_colorspaces_color_profile_type_t);</a>
<a name="ln1681">    new_params_size += new_profile_len + new_pprofile_len;</a>
<a name="ln1682">    void *new_params = malloc(new_params_size);</a>
<a name="ln1683"> </a>
<a name="ln1684">    size_t pos = 0;</a>
<a name="ln1685">    //   char *printer</a>
<a name="ln1686">    memcpy(new_params + pos, printer, printer_len);</a>
<a name="ln1687">    pos += printer_len;</a>
<a name="ln1688">    //   char *paper</a>
<a name="ln1689">    memcpy(new_params + pos, paper, paper_len);</a>
<a name="ln1690">    pos += paper_len;</a>
<a name="ln1691">    //   int32_t landscape</a>
<a name="ln1692">    memcpy(new_params + pos, &amp;landscape, sizeof(int32_t));</a>
<a name="ln1693">    pos += sizeof(int32_t);</a>
<a name="ln1694">    //   int32_t f_profile_type</a>
<a name="ln1695">    memcpy(new_params + pos, &amp;profile_type, sizeof(int32_t));</a>
<a name="ln1696">    pos += sizeof(int32_t);</a>
<a name="ln1697">    //   char *f_profile</a>
<a name="ln1698">    memcpy(new_params + pos, profile_filename, new_profile_len);</a>
<a name="ln1699">    pos += new_profile_len;</a>
<a name="ln1700">    //   int32_t intent</a>
<a name="ln1701">    memcpy(new_params + pos, &amp;intent, sizeof(int32_t));</a>
<a name="ln1702">    pos += sizeof(int32_t);</a>
<a name="ln1703">    //   int32_t f_pprofile_type</a>
<a name="ln1704">    memcpy(new_params + pos, &amp;pprofile_type, sizeof(int32_t));</a>
<a name="ln1705">    pos += sizeof(int32_t);</a>
<a name="ln1706">    //   char *f_pprofile</a>
<a name="ln1707">    memcpy(new_params + pos, pprofile_filename, new_pprofile_len);</a>
<a name="ln1708">    pos += new_pprofile_len;</a>
<a name="ln1709">    //   &lt;rest&gt;</a>
<a name="ln1710">    memcpy(new_params + pos, buf, old_params_size - ((char *)buf - (char *)old_params));</a>
<a name="ln1711"> </a>
<a name="ln1712">    *new_size = new_params_size;</a>
<a name="ln1713">    *new_version = 2;</a>
<a name="ln1714">    return new_params;</a>
<a name="ln1715">  }</a>
<a name="ln1716">  else if(old_version == 2)</a>
<a name="ln1717">  {</a>
<a name="ln1718">    // add upscale to params</a>
<a name="ln1719">    size_t new_params_size = old_params_size + 1;</a>
<a name="ln1720">    void *new_params = calloc(1, new_params_size);</a>
<a name="ln1721"> </a>
<a name="ln1722">    memcpy(new_params, old_params, old_params_size);</a>
<a name="ln1723">    // no media type specified</a>
<a name="ln1724">    ((char *)new_params)[old_params_size] = '\0';</a>
<a name="ln1725"> </a>
<a name="ln1726">    *new_size = new_params_size;</a>
<a name="ln1727">    *new_version = 3;</a>
<a name="ln1728">    return new_params;</a>
<a name="ln1729">  }</a>
<a name="ln1730"> </a>
<a name="ln1731">  return NULL;</a>
<a name="ln1732">}</a>
<a name="ln1733"> </a>
<a name="ln1734">int set_params(dt_lib_module_t *self, const void *params, int size)</a>
<a name="ln1735">{</a>
<a name="ln1736">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1737"> </a>
<a name="ln1738">  if(!params) return 1;</a>
<a name="ln1739"> </a>
<a name="ln1740">  // get the parameters buffer</a>
<a name="ln1741">  const char *buf = (char *)params;</a>
<a name="ln1742"> </a>
<a name="ln1743">  // get individual items</a>
<a name="ln1744">  const char *printer = buf;</a>
<a name="ln1745">  if (!printer) return 1;</a>
<a name="ln1746">  const int32_t printer_len = strlen(printer) + 1;</a>
<a name="ln1747">  buf += printer_len;</a>
<a name="ln1748"> </a>
<a name="ln1749">  const char *paper = buf;</a>
<a name="ln1750">  if (!paper) return 1;</a>
<a name="ln1751">  const int32_t paper_len = strlen(paper) + 1;</a>
<a name="ln1752">  buf += paper_len;</a>
<a name="ln1753"> </a>
<a name="ln1754">  const int32_t landscape = *(int32_t *)buf;</a>
<a name="ln1755">  buf +=  sizeof(int32_t);</a>
<a name="ln1756"> </a>
<a name="ln1757">  const int32_t f_profile_type = *(int32_t *)buf;</a>
<a name="ln1758">  buf +=  sizeof(int32_t);</a>
<a name="ln1759"> </a>
<a name="ln1760">  const char *f_profile = buf;</a>
<a name="ln1761">  if (!f_profile) return 1;</a>
<a name="ln1762">  const int32_t profile_len = strlen(f_profile) + 1;</a>
<a name="ln1763">  buf += profile_len;</a>
<a name="ln1764"> </a>
<a name="ln1765">  const int32_t intent = *(int32_t *)buf;</a>
<a name="ln1766">  buf += sizeof(int32_t);</a>
<a name="ln1767"> </a>
<a name="ln1768">  const int32_t f_pprofile_type = *(int32_t *)buf;</a>
<a name="ln1769">  buf +=  sizeof(int32_t);</a>
<a name="ln1770"> </a>
<a name="ln1771">  const char *f_pprofile = buf;</a>
<a name="ln1772">  if (!f_pprofile) return 1;</a>
<a name="ln1773">  const int32_t pprofile_len = strlen(f_pprofile) + 1;</a>
<a name="ln1774">  buf += pprofile_len;</a>
<a name="ln1775"> </a>
<a name="ln1776">  const int32_t pintent = *(int32_t *)buf;</a>
<a name="ln1777">  buf += sizeof(int32_t);</a>
<a name="ln1778"> </a>
<a name="ln1779">  const int32_t bpc = *(int32_t *)buf;</a>
<a name="ln1780">  buf += sizeof(int32_t);</a>
<a name="ln1781"> </a>
<a name="ln1782">  const char *style = buf;</a>
<a name="ln1783">  if (!style) return 1;</a>
<a name="ln1784">  const int32_t style_len = strlen(style) + 1;</a>
<a name="ln1785">  buf += style_len;</a>
<a name="ln1786"> </a>
<a name="ln1787">  const int32_t style_mode = *(int32_t *)buf;</a>
<a name="ln1788">  buf += sizeof(int32_t);</a>
<a name="ln1789"> </a>
<a name="ln1790">  const double b_top = *(double *)buf;</a>
<a name="ln1791">  buf += sizeof(double);</a>
<a name="ln1792"> </a>
<a name="ln1793">  const double b_bottom = *(double *)buf;</a>
<a name="ln1794">  buf += sizeof(double);</a>
<a name="ln1795"> </a>
<a name="ln1796">  const double b_left = *(double *)buf;</a>
<a name="ln1797">  buf += sizeof(double);</a>
<a name="ln1798"> </a>
<a name="ln1799">  const double b_right = *(double *)buf;</a>
<a name="ln1800">  buf += sizeof(double);</a>
<a name="ln1801"> </a>
<a name="ln1802">  const int32_t alignment = *(int32_t *)buf;</a>
<a name="ln1803">  buf += sizeof(int32_t);</a>
<a name="ln1804"> </a>
<a name="ln1805">  const char *media = buf;</a>
<a name="ln1806">  if (!media) return 1;</a>
<a name="ln1807">  const int32_t media_len = strlen(media) + 1;</a>
<a name="ln1808">  // buf += media_len;</a>
<a name="ln1809"> </a>
<a name="ln1810">  // ensure that the size is correct</a>
<a name="ln1811">  if(size != printer_len + paper_len + media_len + profile_len + pprofile_len + style_len + 8 * sizeof(int32_t) + 4 * sizeof(double))</a>
<a name="ln1812">    return 1;</a>
<a name="ln1813"> </a>
<a name="ln1814">  // set the GUI with corresponding values</a>
<a name="ln1815">  if (printer[0] != '\0')</a>
<a name="ln1816">    _bauhaus_combobox_set_active_text(ps-&gt;printers, printer);</a>
<a name="ln1817"> </a>
<a name="ln1818">  if (paper[0] != '\0')</a>
<a name="ln1819">    _bauhaus_combobox_set_active_text(ps-&gt;papers, paper);</a>
<a name="ln1820"> </a>
<a name="ln1821">  if (media[0] != '\0')</a>
<a name="ln1822">    _bauhaus_combobox_set_active_text(ps-&gt;media, media);</a>
<a name="ln1823"> </a>
<a name="ln1824">  dt_bauhaus_combobox_set (ps-&gt;orientation, landscape);</a>
<a name="ln1825"> </a>
<a name="ln1826">  dt_bauhaus_combobox_set(ps-&gt;profile, 0);</a>
<a name="ln1827">  for(GList *iter = ps-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln1828">  {</a>
<a name="ln1829">    dt_lib_export_profile_t *p = (dt_lib_export_profile_t *)iter-&gt;data;</a>
<a name="ln1830">    if(f_profile_type == p-&gt;type &amp;&amp; (f_profile_type != DT_COLORSPACE_FILE || !g_strcmp0(f_profile, p-&gt;filename)))</a>
<a name="ln1831">    {</a>
<a name="ln1832">      dt_bauhaus_combobox_set(ps-&gt;profile, p-&gt;pos);</a>
<a name="ln1833">      break;</a>
<a name="ln1834">    }</a>
<a name="ln1835">  }</a>
<a name="ln1836"> </a>
<a name="ln1837">  dt_bauhaus_combobox_set (ps-&gt;intent, intent);</a>
<a name="ln1838"> </a>
<a name="ln1839">  dt_bauhaus_combobox_set(ps-&gt;pprofile, 0);</a>
<a name="ln1840">  for(GList *iter = ps-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln1841">  {</a>
<a name="ln1842">    dt_lib_export_profile_t *p = (dt_lib_export_profile_t *)iter-&gt;data;</a>
<a name="ln1843">    if(f_pprofile_type == p-&gt;type &amp;&amp; (f_pprofile_type != DT_COLORSPACE_FILE || !g_strcmp0(f_pprofile, p-&gt;filename)))</a>
<a name="ln1844">    {</a>
<a name="ln1845">      dt_bauhaus_combobox_set(ps-&gt;pprofile, p-&gt;ppos);</a>
<a name="ln1846">      break;</a>
<a name="ln1847">    }</a>
<a name="ln1848">  }</a>
<a name="ln1849"> </a>
<a name="ln1850">  dt_bauhaus_combobox_set (ps-&gt;pintent, pintent);</a>
<a name="ln1851">  ps-&gt;prt.printer.intent = pintent;</a>
<a name="ln1852"> </a>
<a name="ln1853">  if (style[0] != '\0')</a>
<a name="ln1854">    _bauhaus_combobox_set_active_text(ps-&gt;style, style);</a>
<a name="ln1855">  dt_bauhaus_combobox_set (ps-&gt;style_mode, style_mode);</a>
<a name="ln1856"> </a>
<a name="ln1857">  gtk_spin_button_set_value (GTK_SPIN_BUTTON(ps-&gt;b_top), b_top * units[ps-&gt;unit]);</a>
<a name="ln1858">  gtk_spin_button_set_value (GTK_SPIN_BUTTON(ps-&gt;b_bottom), b_bottom * units[ps-&gt;unit]);</a>
<a name="ln1859">  gtk_spin_button_set_value (GTK_SPIN_BUTTON(ps-&gt;b_left), b_left * units[ps-&gt;unit]);</a>
<a name="ln1860">  gtk_spin_button_set_value (GTK_SPIN_BUTTON(ps-&gt;b_right), b_right * units[ps-&gt;unit]);</a>
<a name="ln1861"> </a>
<a name="ln1862">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;dtba[alignment]),TRUE);</a>
<a name="ln1863">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;black_point_compensation), bpc);</a>
<a name="ln1864"> </a>
<a name="ln1865">  return 0;</a>
<a name="ln1866">}</a>
<a name="ln1867"> </a>
<a name="ln1868">void *get_params(dt_lib_module_t *self, int *size)</a>
<a name="ln1869">{</a>
<a name="ln1870">  const dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1871"> </a>
<a name="ln1872">  // get the data</a>
<a name="ln1873">  const char *printer = dt_bauhaus_combobox_get_text(ps-&gt;printers);</a>
<a name="ln1874">  const char *paper = dt_bauhaus_combobox_get_text(ps-&gt;papers);</a>
<a name="ln1875">  const char *media = dt_bauhaus_combobox_get_text(ps-&gt;media);</a>
<a name="ln1876">  const int32_t profile_pos = dt_bauhaus_combobox_get(ps-&gt;profile);</a>
<a name="ln1877">  const int32_t intent =  dt_bauhaus_combobox_get(ps-&gt;intent);</a>
<a name="ln1878">  const char *style = dt_bauhaus_combobox_get_text(ps-&gt;style);</a>
<a name="ln1879">  const int32_t style_mode = dt_bauhaus_combobox_get(ps-&gt;style_mode);</a>
<a name="ln1880">  const int32_t pprofile_pos = dt_bauhaus_combobox_get(ps-&gt;pprofile);</a>
<a name="ln1881">  const int32_t pintent =  dt_bauhaus_combobox_get(ps-&gt;pintent);</a>
<a name="ln1882">  const int32_t landscape = dt_bauhaus_combobox_get(ps-&gt;orientation);</a>
<a name="ln1883">  const int32_t bpc = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ps-&gt;black_point_compensation));</a>
<a name="ln1884">  const double b_top = ps-&gt;prt.page.margin_top;</a>
<a name="ln1885">  const double b_bottom = ps-&gt;prt.page.margin_bottom;</a>
<a name="ln1886">  const double b_left = ps-&gt;prt.page.margin_left;</a>
<a name="ln1887">  const double b_right = ps-&gt;prt.page.margin_right;</a>
<a name="ln1888">  const int32_t alignment = ps-&gt;prt.page.alignment;</a>
<a name="ln1889"> </a>
<a name="ln1890">  dt_colorspaces_color_profile_type_t profile_type = DT_COLORSPACE_NONE, pprofile_type = DT_COLORSPACE_NONE;</a>
<a name="ln1891">  const char *profile = &quot;&quot;, *pprofile = &quot;&quot;;</a>
<a name="ln1892">  for(GList *iter = ps-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln1893">  {</a>
<a name="ln1894">    dt_lib_export_profile_t *p = (dt_lib_export_profile_t *)iter-&gt;data;</a>
<a name="ln1895">    if(p-&gt;pos == profile_pos)</a>
<a name="ln1896">    {</a>
<a name="ln1897">      profile_type = p-&gt;type;</a>
<a name="ln1898">      profile = p-&gt;filename;</a>
<a name="ln1899">    }</a>
<a name="ln1900">    if(p-&gt;ppos == pprofile_pos)</a>
<a name="ln1901">    {</a>
<a name="ln1902">      pprofile_type = p-&gt;type;</a>
<a name="ln1903">      pprofile = p-&gt;filename;</a>
<a name="ln1904">    }</a>
<a name="ln1905">  }</a>
<a name="ln1906"> </a>
<a name="ln1907">  // these will be NULL when no printer is connected/found</a>
<a name="ln1908">  if(!printer) printer = &quot;&quot;;</a>
<a name="ln1909">  if(!paper) paper = &quot;&quot;;</a>
<a name="ln1910">  if(!media) media = &quot;&quot;;</a>
<a name="ln1911"> </a>
<a name="ln1912">  // compute the size of individual items, always get the \0 for strings</a>
<a name="ln1913">  const int32_t printer_len = strlen (printer) + 1;</a>
<a name="ln1914">  const int32_t paper_len = strlen (paper) + 1;</a>
<a name="ln1915">  const int32_t media_len = strlen (media) + 1;</a>
<a name="ln1916">  const int32_t profile_len = strlen (profile) + 1;</a>
<a name="ln1917">  const int32_t pprofile_len = strlen (pprofile) + 1;</a>
<a name="ln1918">  const int32_t style_len = strlen (style) + 1;</a>
<a name="ln1919"> </a>
<a name="ln1920">  // compute the size of all parameters</a>
<a name="ln1921">  *size = printer_len + paper_len + media_len + profile_len + pprofile_len + style_len + 8 * sizeof(int32_t) + 4 * sizeof(double);</a>
<a name="ln1922"> </a>
<a name="ln1923">  // allocate the parameter buffer</a>
<a name="ln1924">  char *params = (char *)malloc(*size);</a>
<a name="ln1925"> </a>
<a name="ln1926">  int pos = 0;</a>
<a name="ln1927"> </a>
<a name="ln1928">  memcpy(params+pos, printer, printer_len);</a>
<a name="ln1929">  pos += printer_len;</a>
<a name="ln1930">  memcpy(params+pos, paper, paper_len);</a>
<a name="ln1931">  pos += paper_len;</a>
<a name="ln1932">  memcpy(params+pos, &amp;landscape, sizeof(int32_t));</a>
<a name="ln1933">  pos += sizeof(int32_t);</a>
<a name="ln1934">  memcpy(params+pos, &amp;profile_type, sizeof(int32_t));</a>
<a name="ln1935">  pos += sizeof(int32_t);</a>
<a name="ln1936">  memcpy(params+pos, profile, profile_len);</a>
<a name="ln1937">  pos += profile_len;</a>
<a name="ln1938">  memcpy(params+pos, &amp;intent, sizeof(int32_t));</a>
<a name="ln1939">  pos += sizeof(int32_t);</a>
<a name="ln1940">  memcpy(params+pos, &amp;pprofile_type, sizeof(int32_t));</a>
<a name="ln1941">  pos += sizeof(int32_t);</a>
<a name="ln1942">  memcpy(params+pos, pprofile, pprofile_len);</a>
<a name="ln1943">  pos += pprofile_len;</a>
<a name="ln1944">  memcpy(params+pos, &amp;pintent, sizeof(int32_t));</a>
<a name="ln1945">  pos += sizeof(int32_t);</a>
<a name="ln1946">  memcpy(params+pos, &amp;bpc, sizeof(int32_t));</a>
<a name="ln1947">  pos += sizeof(int32_t);</a>
<a name="ln1948">  memcpy(params+pos, style, style_len);</a>
<a name="ln1949">  pos += style_len;</a>
<a name="ln1950">  memcpy(params+pos, &amp;style_mode, sizeof(int32_t));</a>
<a name="ln1951">  pos += sizeof(int32_t);</a>
<a name="ln1952">  memcpy(params+pos, &amp;b_top, sizeof(double));</a>
<a name="ln1953">  pos += sizeof(double);</a>
<a name="ln1954">  memcpy(params+pos, &amp;b_bottom, sizeof(double));</a>
<a name="ln1955">  pos += sizeof(double);</a>
<a name="ln1956">  memcpy(params+pos, &amp;b_left, sizeof(double));</a>
<a name="ln1957">  pos += sizeof(double);</a>
<a name="ln1958">  memcpy(params+pos, &amp;b_right, sizeof(double));</a>
<a name="ln1959">  pos += sizeof(double);</a>
<a name="ln1960">  memcpy(params+pos, &amp;alignment, sizeof(int32_t));</a>
<a name="ln1961">  pos += sizeof(int32_t);</a>
<a name="ln1962">  memcpy(params+pos, media, media_len);</a>
<a name="ln1963">  pos += media_len;</a>
<a name="ln1964"> </a>
<a name="ln1965">  g_assert(pos == *size);</a>
<a name="ln1966"> </a>
<a name="ln1967">  return params;</a>
<a name="ln1968">}</a>
<a name="ln1969"> </a>
<a name="ln1970">void</a>
<a name="ln1971">gui_cleanup (dt_lib_module_t *self)</a>
<a name="ln1972">{</a>
<a name="ln1973">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1974"> </a>
<a name="ln1975">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ps-&gt;b_top));</a>
<a name="ln1976">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ps-&gt;b_left));</a>
<a name="ln1977">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ps-&gt;b_right));</a>
<a name="ln1978">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ps-&gt;b_bottom));</a>
<a name="ln1979"> </a>
<a name="ln1980">  g_list_free_full(ps-&gt;profiles, g_free);</a>
<a name="ln1981">  g_list_free_full(ps-&gt;paper_list, free);</a>
<a name="ln1982">  g_list_free_full(ps-&gt;media_list, free);</a>
<a name="ln1983"> </a>
<a name="ln1984">  g_free(ps-&gt;v_iccprofile);</a>
<a name="ln1985">  g_free(ps-&gt;v_piccprofile);</a>
<a name="ln1986">  g_free(ps-&gt;v_style);</a>
<a name="ln1987"> </a>
<a name="ln1988">  free(self-&gt;data);</a>
<a name="ln1989">  self-&gt;data = NULL;</a>
<a name="ln1990">}</a>
<a name="ln1991"> </a>
<a name="ln1992">void</a>
<a name="ln1993">gui_reset (dt_lib_module_t *self)</a>
<a name="ln1994">{</a>
<a name="ln1995">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1996"> </a>
<a name="ln1997">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_top), 15 * units[ps-&gt;unit]);</a>
<a name="ln1998">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), 15 * units[ps-&gt;unit]);</a>
<a name="ln1999">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left), 15 * units[ps-&gt;unit]);</a>
<a name="ln2000">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right), 15 * units[ps-&gt;unit]);</a>
<a name="ln2001">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;dtba[ALIGNMENT_CENTER]), TRUE);</a>
<a name="ln2002">  ps-&gt;prt.page.alignment = ALIGNMENT_CENTER;</a>
<a name="ln2003">  ps-&gt;prt.printer.intent = DT_INTENT_PERCEPTUAL;</a>
<a name="ln2004">  dt_bauhaus_combobox_set(ps-&gt;profile, 0);</a>
<a name="ln2005">  dt_bauhaus_combobox_set(ps-&gt;pprofile, 0);</a>
<a name="ln2006">  dt_bauhaus_combobox_set(ps-&gt;pintent, 0);</a>
<a name="ln2007">  dt_bauhaus_combobox_set(ps-&gt;style, 0);</a>
<a name="ln2008">  dt_bauhaus_combobox_set(ps-&gt;intent, 0);</a>
<a name="ln2009">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;black_point_compensation), TRUE);</a>
<a name="ln2010">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;pintent), TRUE);</a>
<a name="ln2011">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;black_point_compensation), FALSE);</a>
<a name="ln2012">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;style_mode), FALSE);</a>
<a name="ln2013"> </a>
<a name="ln2014">  // reset page orientation to fit the picture</a>
<a name="ln2015"> </a>
<a name="ln2016">  _set_orientation (ps);</a>
<a name="ln2017">}</a>
<a name="ln2018"> </a>
<a name="ln2019">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln2020">{</a>
<a name="ln2021">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;print&quot;), GDK_KEY_p, GDK_CONTROL_MASK);</a>
<a name="ln2022">}</a>
<a name="ln2023"> </a>
<a name="ln2024">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln2025">{</a>
<a name="ln2026">  dt_lib_print_settings_t *d = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln2027"> </a>
<a name="ln2028">  dt_accel_connect_button_lib(self, &quot;print&quot;, GTK_WIDGET(d-&gt;print_button));</a>
<a name="ln2029">}</a>
<a name="ln2030"> </a>
<a name="ln2031">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2032">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2033">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="167"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 167, 158.</p></div>
<div class="balloon" rel="177"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 177, 158.</p></div>
<div class="balloon" rel="414"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'params'. Check lines: 414, 411.</p></div>
<div class="balloon" rel="1129"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 1129, 1115.</p></div>
<div class="balloon" rel="1208"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: prof->type != DT_COLORSPACE_FILE.</p></div>
<div class="balloon" rel="1493"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="1686"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'new_params' pointer in the 'new_params + pos' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 1686, 1682.</p></div>
<div class="balloon" rel="1722"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1722, 1720.</p></div>
<div class="balloon" rel="1745"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!printer' is always false.</p></div>
<div class="balloon" rel="1750"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!paper' is always false.</p></div>
<div class="balloon" rel="1761"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!f_profile' is always false.</p></div>
<div class="balloon" rel="1772"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!f_pprofile' is always false.</p></div>
<div class="balloon" rel="1783"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!style' is always false.</p></div>
<div class="balloon" rel="1806"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!media' is always false.</p></div>
<div class="balloon" rel="1928"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'params' pointer in the 'params + pos' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 1928, 1924.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
