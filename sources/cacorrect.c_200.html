
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;develop/imageop.h&quot;</a>
<a name="ln23">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln24">#include &quot;gui/gtk.h&quot;</a>
<a name="ln25">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln28">#include &lt;stdlib.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#if defined(__SSE__)</a>
<a name="ln31">#include &lt;xmmintrin.h&gt;</a>
<a name="ln32">#endif</a>
<a name="ln33"> </a>
<a name="ln34">// this is the version of the modules parameters,</a>
<a name="ln35">// and includes version information about compile-time dt</a>
<a name="ln36">DT_MODULE_INTROSPECTION(1, dt_iop_cacorrect_params_t)</a>
<a name="ln37"> </a>
<a name="ln38">#pragma GCC diagnostic ignored &quot;-Wshadow&quot;</a>
<a name="ln39"> </a>
<a name="ln40">typedef struct dt_iop_cacorrect_params_t</a>
<a name="ln41">{</a>
<a name="ln42">  int keep;</a>
<a name="ln43">} dt_iop_cacorrect_params_t;</a>
<a name="ln44"> </a>
<a name="ln45">typedef struct dt_iop_cacorrect_gui_data_t</a>
<a name="ln46">{</a>
<a name="ln47">} dt_iop_cacorrect_gui_data_t;</a>
<a name="ln48"> </a>
<a name="ln49">dt_iop_cacorrect_gui_data_t dummy;</a>
<a name="ln50"> </a>
<a name="ln51">// this returns a translatable name</a>
<a name="ln52">const char *name()</a>
<a name="ln53">{</a>
<a name="ln54">  // make sure you put all your translatable strings into _() !</a>
<a name="ln55">  return _(&quot;chromatic aberrations&quot;);</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">int default_group()</a>
<a name="ln59">{</a>
<a name="ln60">  return IOP_GROUP_CORRECT;</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">int flags()</a>
<a name="ln64">{</a>
<a name="ln65">  return IOP_FLAGS_ONE_INSTANCE;</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln69">{</a>
<a name="ln70">  return iop_cs_RAW;</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">/*==================================================================================</a>
<a name="ln74"> * begin raw therapee code, hg checkout of march 09, 2016 branch master.</a>
<a name="ln75"> *==================================================================================*/</a>
<a name="ln76"> </a>
<a name="ln77">#ifdef __GNUC__</a>
<a name="ln78">#define INLINE __inline</a>
<a name="ln79">#else</a>
<a name="ln80">#define INLINE inline</a>
<a name="ln81">#endif</a>
<a name="ln82"> </a>
<a name="ln83">#ifdef __SSE2__</a>
<a name="ln84"> </a>
<a name="ln85">typedef __m128i vmask;</a>
<a name="ln86">typedef __m128 vfloat;</a>
<a name="ln87"> </a>
<a name="ln88">#define ZEROV _mm_setzero_ps()</a>
<a name="ln89">#define F2V(a) _mm_set1_ps((a))</a>
<a name="ln90">#define STVFU(x, y) _mm_storeu_ps(&amp;x, y)</a>
<a name="ln91">#define LVFU(x) _mm_loadu_ps(&amp;x)</a>
<a name="ln92"> </a>
<a name="ln93">#define STC2VFU(a, v)                                                                                        \</a>
<a name="ln94">  {                                                                                                          \</a>
<a name="ln95">    __m128 TST1V = _mm_loadu_ps(&amp;a);                                                                         \</a>
<a name="ln96">    __m128 TST2V = _mm_unpacklo_ps(v, v);                                                                    \</a>
<a name="ln97">    vmask cmask = _mm_set_epi32(0xffffffff, 0, 0xffffffff, 0);                                               \</a>
<a name="ln98">    _mm_storeu_ps(&amp;a, vself(cmask, TST1V, TST2V));                                                           \</a>
<a name="ln99">    TST1V = _mm_loadu_ps((&amp;a) + 4);                                                                          \</a>
<a name="ln100">    TST2V = _mm_unpackhi_ps(v, v);                                                                           \</a>
<a name="ln101">    _mm_storeu_ps((&amp;a) + 4, vself(cmask, TST1V, TST2V));                                                     \</a>
<a name="ln102">  }</a>
<a name="ln103"> </a>
<a name="ln104">static INLINE vfloat LC2VFU(float *a)</a>
<a name="ln105">{</a>
<a name="ln106">  // Load 8 floats from a and combine a[0],a[2],a[4] and a[6] into a vector of 4 floats</a>
<a name="ln107">  vfloat a1 = _mm_loadu_ps(a);</a>
<a name="ln108">  vfloat a2 = _mm_loadu_ps((a) + 4);</a>
<a name="ln109">  return _mm_shuffle_ps(a1, a2, _MM_SHUFFLE(2, 0, 2, 0));</a>
<a name="ln110">}</a>
<a name="ln111">static INLINE vfloat SQRV(vfloat a)</a>
<a name="ln112">{</a>
<a name="ln113">  return a * a;</a>
<a name="ln114">}</a>
<a name="ln115">static INLINE vfloat vmul2f(vfloat a)</a>
<a name="ln116">{</a>
<a name="ln117">  // fastest way to multiply by 2</a>
<a name="ln118">  return a + a;</a>
<a name="ln119">}</a>
<a name="ln120">static INLINE vfloat vcast_vf_f(float f)</a>
<a name="ln121">{</a>
<a name="ln122">  return _mm_set_ps(f, f, f, f);</a>
<a name="ln123">}</a>
<a name="ln124">static INLINE vmask vorm(vmask x, vmask y)</a>
<a name="ln125">{</a>
<a name="ln126">  return _mm_or_si128(x, y);</a>
<a name="ln127">}</a>
<a name="ln128">static INLINE vmask vandm(vmask x, vmask y)</a>
<a name="ln129">{</a>
<a name="ln130">  return _mm_and_si128(x, y);</a>
<a name="ln131">}</a>
<a name="ln132">static INLINE vmask vandnotm(vmask x, vmask y)</a>
<a name="ln133">{</a>
<a name="ln134">  return _mm_andnot_si128(x, y);</a>
<a name="ln135">}</a>
<a name="ln136">static INLINE vfloat vabsf(vfloat f)</a>
<a name="ln137">{</a>
<a name="ln138">  return (vfloat)vandnotm((vmask)vcast_vf_f(-0.0f), (vmask)f);</a>
<a name="ln139">}</a>
<a name="ln140">static INLINE vfloat vself(vmask mask, vfloat x, vfloat y)</a>
<a name="ln141">{</a>
<a name="ln142">  return (vfloat)vorm(vandm(mask, (vmask)x), vandnotm(mask, (vmask)y));</a>
<a name="ln143">}</a>
<a name="ln144">static INLINE float vhadd(vfloat a)</a>
<a name="ln145">{</a>
<a name="ln146">  // returns a[0] + a[1] + a[2] + a[3]</a>
<a name="ln147">  a += _mm_movehl_ps(a, a);</a>
<a name="ln148">  return _mm_cvtss_f32(_mm_add_ss(a, _mm_shuffle_ps(a, a, 1)));</a>
<a name="ln149">}</a>
<a name="ln150">static INLINE vfloat vintpf(vfloat a, vfloat b, vfloat c)</a>
<a name="ln151">{</a>
<a name="ln152">  // calculate a * b + (1 - a) * c (interpolate two values)</a>
<a name="ln153">  // following is valid:</a>
<a name="ln154">  // vintpf(a, b+x, c+x) = vintpf(a, b, c) + x</a>
<a name="ln155">  // vintpf(a, b*x, c*x) = vintpf(a, b, c) * x</a>
<a name="ln156">  return a * (b - c) + c;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">#endif // __SSE2__</a>
<a name="ln160"> </a>
<a name="ln161">static INLINE float SQR(float x)</a>
<a name="ln162">{</a>
<a name="ln163">  //      return std::pow(x,2); Slower than:</a>
<a name="ln164">  return (x * x);</a>
<a name="ln165">}</a>
<a name="ln166">static INLINE float LIM(const float a, const float b, const float c)</a>
<a name="ln167">{</a>
<a name="ln168">  return MAX(b, MIN(a, c));</a>
<a name="ln169">}</a>
<a name="ln170">static INLINE float intp(const float a, const float b, const float c)</a>
<a name="ln171">{</a>
<a name="ln172">  // calculate a * b + (1 - a) * c</a>
<a name="ln173">  // following is valid:</a>
<a name="ln174">  // intp(a, b+x, c+x) = intp(a, b, c) + x</a>
<a name="ln175">  // intp(a, b*x, c*x) = intp(a, b, c) * x</a>
<a name="ln176">  return a * (b - c) + c;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">////////////////////////////////////////////////////////////////</a>
<a name="ln180">//</a>
<a name="ln181">//		Chromatic Aberration Auto-correction</a>
<a name="ln182">//</a>
<a name="ln183">//		copyright (c) 2008-2010  Emil Martinec &lt;ejmartin@uchicago.edu&gt;</a>
<a name="ln184">//</a>
<a name="ln185">//</a>
<a name="ln186">// code dated: November 26, 2010</a>
<a name="ln187">//</a>
<a name="ln188">//	CA_correct_RT.cc is free software: you can redistribute it and/or modify</a>
<a name="ln189">//	it under the terms of the GNU General Public License as published by</a>
<a name="ln190">//	the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln191">//	(at your option) any later version.</a>
<a name="ln192">//</a>
<a name="ln193">//	This program is distributed in the hope that it will be useful,</a>
<a name="ln194">//	but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln195">//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln196">//	GNU General Public License for more details.</a>
<a name="ln197">//</a>
<a name="ln198">//	You should have received a copy of the GNU General Public License</a>
<a name="ln199">//	along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln200">//</a>
<a name="ln201">////////////////////////////////////////////////////////////////</a>
<a name="ln202">//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</a>
<a name="ln203">static gboolean LinEqSolve(int nDim, double *pfMatr, double *pfVect, double *pfSolution)</a>
<a name="ln204">{</a>
<a name="ln205">  //==============================================================================</a>
<a name="ln206">  // return 1 if system not solving, 0 if system solved</a>
<a name="ln207">  // nDim - system dimension</a>
<a name="ln208">  // pfMatr - matrix with coefficients</a>
<a name="ln209">  // pfVect - vector with free members</a>
<a name="ln210">  // pfSolution - vector with system solution</a>
<a name="ln211">  // pfMatr becomes triangular after function call</a>
<a name="ln212">  // pfVect changes after function call</a>
<a name="ln213">  //</a>
<a name="ln214">  // Developer: Henry Guennadi Levkin</a>
<a name="ln215">  //</a>
<a name="ln216">  //==============================================================================</a>
<a name="ln217"> </a>
<a name="ln218">  double fMaxElem;</a>
<a name="ln219">  double fAcc;</a>
<a name="ln220"> </a>
<a name="ln221">  int i, j, k, m;</a>
<a name="ln222"> </a>
<a name="ln223">  for(k = 0; k &lt; (nDim - 1); k++)</a>
<a name="ln224">  { // base row of matrix</a>
<a name="ln225">    // search of line with max element</a>
<a name="ln226">    fMaxElem = fabs(pfMatr[k * nDim + k]);</a>
<a name="ln227">    m = k;</a>
<a name="ln228"> </a>
<a name="ln229">    for(i = k + 1; i &lt; nDim; i++)</a>
<a name="ln230">    {</a>
<a name="ln231">      if(fMaxElem &lt; fabs(pfMatr[i * nDim + k]))</a>
<a name="ln232">      {</a>
<a name="ln233">        fMaxElem = pfMatr[i * nDim + k];</a>
<a name="ln234">        m = i;</a>
<a name="ln235">      }</a>
<a name="ln236">    }</a>
<a name="ln237"> </a>
<a name="ln238">    // permutation of base line (index k) and max element line(index m)</a>
<a name="ln239">    if(m != k)</a>
<a name="ln240">    {</a>
<a name="ln241">      for(i = k; i &lt; nDim; i++)</a>
<a name="ln242">      {</a>
<a name="ln243">        fAcc = pfMatr[k * nDim + i];</a>
<a name="ln244">        pfMatr[k * nDim + i] = pfMatr[m * nDim + i];</a>
<a name="ln245">        pfMatr[m * nDim + i] = fAcc;</a>
<a name="ln246">      }</a>
<a name="ln247"> </a>
<a name="ln248">      fAcc = pfVect[k];</a>
<a name="ln249">      pfVect[k] = pfVect[m];</a>
<a name="ln250">      pfVect[m] = fAcc;</a>
<a name="ln251">    }</a>
<a name="ln252"> </a>
<a name="ln253">    if(pfMatr[k * nDim + k] == 0.)</a>
<a name="ln254">    {</a>
<a name="ln255">      // linear system has no solution</a>
<a name="ln256">      return FALSE; // needs improvement !!!</a>
<a name="ln257">    }</a>
<a name="ln258"> </a>
<a name="ln259">    // triangulation of matrix with coefficients</a>
<a name="ln260">    for(j = (k + 1); j &lt; nDim; j++)</a>
<a name="ln261">    { // current row of matrix</a>
<a name="ln262">      fAcc = -pfMatr[j * nDim + k] / pfMatr[k * nDim + k];</a>
<a name="ln263"> </a>
<a name="ln264">      for(i = k; i &lt; nDim; i++)</a>
<a name="ln265">      {</a>
<a name="ln266">        pfMatr[j * nDim + i] = pfMatr[j * nDim + i] + fAcc * pfMatr[k * nDim + i];</a>
<a name="ln267">      }</a>
<a name="ln268"> </a>
<a name="ln269">      pfVect[j] = pfVect[j] + fAcc * pfVect[k]; // free member recalculation</a>
<a name="ln270">    }</a>
<a name="ln271">  }</a>
<a name="ln272"> </a>
<a name="ln273">  for(k = (nDim - 1); k &gt;= 0; k--)</a>
<a name="ln274">  {</a>
<a name="ln275">    pfSolution[k] = pfVect[k];</a>
<a name="ln276"> </a>
<a name="ln277">    for(i = (k + 1); i &lt; nDim; i++)</a>
<a name="ln278">    {</a>
<a name="ln279">      pfSolution[k] -= (pfMatr[k * nDim + i] * pfSolution[i]);</a>
<a name="ln280">    }</a>
<a name="ln281"> </a>
<a name="ln282">    pfSolution[k] = pfSolution[k] / pfMatr[k * nDim + k];</a>
<a name="ln283">  }</a>
<a name="ln284"> </a>
<a name="ln285">  return TRUE;</a>
<a name="ln286">}</a>
<a name="ln287">// end of linear equation solver</a>
<a name="ln288">//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</a>
<a name="ln289"> </a>
<a name="ln290">static inline void pixSort(float *a, float *b)</a>
<a name="ln291">{</a>
<a name="ln292">  if(*a &gt; *b)</a>
<a name="ln293">  {</a>
<a name="ln294">    float temp = *a;</a>
<a name="ln295">    *a = *b;</a>
<a name="ln296">    *b = temp;</a>
<a name="ln297">  }</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">// void RawImageSource::CA_correct_RT(const double cared, const double cablue, const double caautostrength)</a>
<a name="ln301">static void CA_correct(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in2,</a>
<a name="ln302">                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln303">{</a>
<a name="ln304">  const int width = roi_in-&gt;width;</a>
<a name="ln305">  const int height = roi_in-&gt;height;</a>
<a name="ln306">  const uint32_t filters = piece-&gt;pipe-&gt;dsc.filters;</a>
<a name="ln307">  memcpy(out, in2, width * height * sizeof(float));</a>
<a name="ln308">  const float *const in = out;</a>
<a name="ln309">  const double cared = 0, cablue = 0;</a>
<a name="ln310">  const double caautostrength = 4;</a>
<a name="ln311"> </a>
<a name="ln312">  // multithreaded and partly vectorized by Ingo Weyrich</a>
<a name="ln313">  const int ts = 128;</a>
<a name="ln314">  const int tsh = ts / 2;</a>
<a name="ln315">  // shifts to location of vertical and diagonal neighbors</a>
<a name="ln316">  const int v1 = ts, v2 = 2 * ts, v3 = 3 * ts,</a>
<a name="ln317">            v4 = 4 * ts; //, p1=-ts+1, p2=-2*ts+2, p3=-3*ts+3, m1=ts+1, m2=2*ts+2, m3=3*ts+3;</a>
<a name="ln318"> </a>
<a name="ln319">  // Test for RGB cfa</a>
<a name="ln320">  for(int i = 0; i &lt; 2; i++)</a>
<a name="ln321">    for(int j = 0; j &lt; 2; j++)</a>
<a name="ln322">      if(FC(i, j, filters) == 3)</a>
<a name="ln323">      {</a>
<a name="ln324">        printf(&quot;CA correction supports only RGB Colour filter arrays\n&quot;);</a>
<a name="ln325">        return;</a>
<a name="ln326">      }</a>
<a name="ln327"> </a>
<a name="ln328">  //   volatile double progress = 0.0;</a>
<a name="ln329">  //</a>
<a name="ln330">  //   if(plistener)</a>
<a name="ln331">  //   {</a>
<a name="ln332">  //     plistener-&gt;setProgress(progress);</a>
<a name="ln333">  //   }</a>
<a name="ln334"> </a>
<a name="ln335">  const gboolean autoCA = (cared == 0 &amp;&amp; cablue == 0);</a>
<a name="ln336">  // local variables</a>
<a name="ln337">  //   const int width = W, height = H;</a>
<a name="ln338">  // temporary array to store simple interpolation of G</a>
<a name="ln339">  float *Gtmp = (float(*))calloc((height) * (width), sizeof *Gtmp);</a>
<a name="ln340"> </a>
<a name="ln341">  // temporary array to avoid race conflicts, only every second pixel needs to be saved here</a>
<a name="ln342">  float *RawDataTmp = (float *)malloc(height * width * sizeof(float) / 2 + 4);</a>
<a name="ln343"> </a>
<a name="ln344">  float blockave[2][2] = { { 0, 0 }, { 0, 0 } }, blocksqave[2][2] = { { 0, 0 }, { 0, 0 } },</a>
<a name="ln345">        blockdenom[2][2] = { { 0, 0 }, { 0, 0 } }, blockvar[2][2];</a>
<a name="ln346"> </a>
<a name="ln347">  // Because we can't break parallel processing, we need a switch do handle the errors</a>
<a name="ln348">  gboolean processpasstwo = TRUE;</a>
<a name="ln349"> </a>
<a name="ln350">  const int border = 8;</a>
<a name="ln351">  const int border2 = 16;</a>
<a name="ln352"> </a>
<a name="ln353">  const int vz1 = (height + border2) % (ts - border2) == 0 ? 1 : 0;</a>
<a name="ln354">  const int hz1 = (width + border2) % (ts - border2) == 0 ? 1 : 0;</a>
<a name="ln355">  const int vblsz = ceil((float)(height + border2) / (ts - border2) + 2 + vz1);</a>
<a name="ln356">  const int hblsz = ceil((float)(width + border2) / (ts - border2) + 2 + hz1);</a>
<a name="ln357"> </a>
<a name="ln358">  char *buffer1 = (char *)calloc(vblsz * hblsz * (2 * 2 + 1), sizeof(float));</a>
<a name="ln359"> </a>
<a name="ln360">  // block CA shift values and weight assigned to block</a>
<a name="ln361">  float *blockwt = (float *)buffer1;</a>
<a name="ln362">  float(*blockshifts)[2][2] = (float(*)[2][2])(buffer1 + (vblsz * hblsz * sizeof(float)));</a>
<a name="ln363"> </a>
<a name="ln364">  double fitparams[2][2][16];</a>
<a name="ln365"> </a>
<a name="ln366">  // order of 2d polynomial fit (polyord), and numpar=polyord^2</a>
<a name="ln367">  int polyord = 4, numpar = 16;</a>
<a name="ln368"> </a>
<a name="ln369">  const float eps = 1e-5f, eps2 = 1e-10f; // tolerance to avoid dividing by zero</a>
<a name="ln370"> </a>
<a name="ln371">#ifdef _OPENMP</a>
<a name="ln372">#pragma omp parallel</a>
<a name="ln373">#endif</a>
<a name="ln374">  {</a>
<a name="ln375">    //     int progresscounter = 0;</a>
<a name="ln376"> </a>
<a name="ln377">    // direction of the CA shift in a tile</a>
<a name="ln378">    int GRBdir[2][3];</a>
<a name="ln379"> </a>
<a name="ln380">    int shifthfloor[3], shiftvfloor[3], shifthceil[3], shiftvceil[3];</a>
<a name="ln381"> </a>
<a name="ln382">    // local quadratic fit to shift data within a tile</a>
<a name="ln383">    float coeff[2][3][2];</a>
<a name="ln384">    // measured CA shift parameters for a tile</a>
<a name="ln385">    float CAshift[2][2];</a>
<a name="ln386">    // polynomial fit coefficients</a>
<a name="ln387">    // residual CA shift amount within a plaquette</a>
<a name="ln388">    float shifthfrac[3], shiftvfrac[3];</a>
<a name="ln389">    // per thread data for evaluation of block CA shift variance</a>
<a name="ln390">    float blockavethr[2][2] = { { 0, 0 }, { 0, 0 } }, blocksqavethr[2][2] = { { 0, 0 }, { 0, 0 } },</a>
<a name="ln391">          blockdenomthr[2][2] = { { 0, 0 }, { 0, 0 } };</a>
<a name="ln392"> </a>
<a name="ln393">    // assign working space</a>
<a name="ln394">    const int buffersize = 3 * sizeof(float) * ts * ts + 6 * sizeof(float) * ts * tsh + 8 * 64 + 63;</a>
<a name="ln395">    char *buffer = (char *)malloc(buffersize);</a>
<a name="ln396">    char *data = (char *)(((uintptr_t)buffer + (uintptr_t)63) / 64 * 64);</a>
<a name="ln397"> </a>
<a name="ln398">    // shift the beginning of all arrays but the first by 64 bytes to avoid cache miss conflicts on CPUs which</a>
<a name="ln399">    // have &lt;=4-way associative L1-Cache</a>
<a name="ln400"> </a>
<a name="ln401">    // rgb data in a tile</a>
<a name="ln402">    float *rgb[3];</a>
<a name="ln403">    rgb[0] = (float(*))data;</a>
<a name="ln404">    rgb[1] = (float(*))(data + 1 * sizeof(float) * ts * ts + 1 * 64);</a>
<a name="ln405">    rgb[2] = (float(*))(data + 2 * sizeof(float) * ts * ts + 2 * 64);</a>
<a name="ln406"> </a>
<a name="ln407">    // high pass filter for R/B in vertical direction</a>
<a name="ln408">    float *rbhpfh = (float(*))(data + 3 * sizeof(float) * ts * ts + 3 * 64);</a>
<a name="ln409">    // high pass filter for R/B in horizontal direction</a>
<a name="ln410">    float *rbhpfv = (float(*))(data + 3 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 4 * 64);</a>
<a name="ln411">    // low pass filter for R/B in horizontal direction</a>
<a name="ln412">    float *rblpfh = (float(*))(data + 4 * sizeof(float) * ts * ts + 5 * 64);</a>
<a name="ln413">    // low pass filter for R/B in vertical direction</a>
<a name="ln414">    float *rblpfv = (float(*))(data + 4 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 6 * 64);</a>
<a name="ln415">    // low pass filter for colour differences in horizontal direction</a>
<a name="ln416">    float *grblpfh = (float(*))(data + 5 * sizeof(float) * ts * ts + 7 * 64);</a>
<a name="ln417">    // low pass filter for colour differences in vertical direction</a>
<a name="ln418">    float *grblpfv = (float(*))(data + 5 * sizeof(float) * ts * ts + sizeof(float) * ts * tsh + 8 * 64);</a>
<a name="ln419">    // colour differences</a>
<a name="ln420">    float *grbdiff = rbhpfh; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln421">    // green interpolated to optical sample points for R/B</a>
<a name="ln422">    float *gshift = rbhpfv; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln423"> </a>
<a name="ln424"> </a>
<a name="ln425">    if(autoCA)</a>
<a name="ln426">    {</a>
<a name="ln427">// Main algorithm: Tile loop calculating correction parameters per tile</a>
<a name="ln428">#ifdef _OPENMP</a>
<a name="ln429">#pragma omp for collapse(2) schedule(dynamic) nowait</a>
<a name="ln430">#endif</a>
<a name="ln431">      for(int top = -border; top &lt; height; top += ts - border2)</a>
<a name="ln432">        for(int left = -border; left &lt; width; left += ts - border2)</a>
<a name="ln433">        {</a>
<a name="ln434">          memset(buffer, 0, buffersize);</a>
<a name="ln435">          const int vblock = ((top + border) / (ts - border2)) + 1;</a>
<a name="ln436">          const int hblock = ((left + border) / (ts - border2)) + 1;</a>
<a name="ln437">          const int bottom = MIN(top + ts, height + border);</a>
<a name="ln438">          const int right = MIN(left + ts, width + border);</a>
<a name="ln439">          const int rr1 = bottom - top;</a>
<a name="ln440">          const int cc1 = right - left;</a>
<a name="ln441">          const int rrmin = top &lt; 0 ? border : 0;</a>
<a name="ln442">          const int rrmax = bottom &gt; height ? height - top : rr1;</a>
<a name="ln443">          const int ccmin = left &lt; 0 ? border : 0;</a>
<a name="ln444">          const int ccmax = right &gt; width ? width - left : cc1;</a>
<a name="ln445"> </a>
<a name="ln446">          // rgb from input CFA data</a>
<a name="ln447">          // rgb values should be floating point numbers between 0 and 1</a>
<a name="ln448">          // after white balance multipliers are applied</a>
<a name="ln449"> </a>
<a name="ln450">          for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln451">            for(int row = rr + top, cc = ccmin; cc &lt; ccmax; cc++)</a>
<a name="ln452">            {</a>
<a name="ln453">              int col = cc + left;</a>
<a name="ln454">              int c = FC(rr, cc, filters);</a>
<a name="ln455">              int indx = row * width + col;</a>
<a name="ln456">              int indx1 = rr * ts + cc;</a>
<a name="ln457">              rgb[c][indx1] = (in[indx]);</a>
<a name="ln458">            }</a>
<a name="ln459"> </a>
<a name="ln460">          // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</a>
<a name="ln461">          // fill borders</a>
<a name="ln462">          if(rrmin &gt; 0)</a>
<a name="ln463">          {</a>
<a name="ln464">            for(int rr = 0; rr &lt; border; rr++)</a>
<a name="ln465">              for(int cc = ccmin; cc &lt; ccmax; cc++)</a>
<a name="ln466">              {</a>
<a name="ln467">                int c = FC(rr, cc, filters);</a>
<a name="ln468">                rgb[c][rr * ts + cc] = rgb[c][(border2 - rr) * ts + cc];</a>
<a name="ln469">              }</a>
<a name="ln470">          }</a>
<a name="ln471"> </a>
<a name="ln472">          if(rrmax &lt; rr1)</a>
<a name="ln473">          {</a>
<a name="ln474">            for(int rr = 0; rr &lt; border; rr++)</a>
<a name="ln475">              for(int cc = ccmin; cc &lt; ccmax; cc++)</a>
<a name="ln476">              {</a>
<a name="ln477">                int c = FC(rr, cc, filters);</a>
<a name="ln478">                rgb[c][(rrmax + rr) * ts + cc] = (in[(height - rr - 2) * width + left + cc]);</a>
<a name="ln479">              }</a>
<a name="ln480">          }</a>
<a name="ln481"> </a>
<a name="ln482">          if(ccmin &gt; 0)</a>
<a name="ln483">          {</a>
<a name="ln484">            for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln485">              for(int cc = 0; cc &lt; border; cc++)</a>
<a name="ln486">              {</a>
<a name="ln487">                int c = FC(rr, cc, filters);</a>
<a name="ln488">                rgb[c][rr * ts + cc] = rgb[c][rr * ts + border2 - cc];</a>
<a name="ln489">              }</a>
<a name="ln490">          }</a>
<a name="ln491"> </a>
<a name="ln492">          if(ccmax &lt; cc1)</a>
<a name="ln493">          {</a>
<a name="ln494">            for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln495">              for(int cc = 0; cc &lt; border; cc++)</a>
<a name="ln496">              {</a>
<a name="ln497">                int c = FC(rr, cc, filters);</a>
<a name="ln498">                rgb[c][rr * ts + ccmax + cc] = (in[(top + rr) * width + (width - cc - 2)]);</a>
<a name="ln499">              }</a>
<a name="ln500">          }</a>
<a name="ln501"> </a>
<a name="ln502">          // also, fill the image corners</a>
<a name="ln503">          if(rrmin &gt; 0 &amp;&amp; ccmin &gt; 0)</a>
<a name="ln504">          {</a>
<a name="ln505">            for(int rr = 0; rr &lt; border; rr++)</a>
<a name="ln506">              for(int cc = 0; cc &lt; border; cc++)</a>
<a name="ln507">              {</a>
<a name="ln508">                int c = FC(rr, cc, filters);</a>
<a name="ln509">                rgb[c][(rr)*ts + cc] = (in[(border2 - rr) * width + border2 - cc]);</a>
<a name="ln510">              }</a>
<a name="ln511">          }</a>
<a name="ln512"> </a>
<a name="ln513">          if(rrmax &lt; rr1 &amp;&amp; ccmax &lt; cc1)</a>
<a name="ln514">          {</a>
<a name="ln515">            for(int rr = 0; rr &lt; border; rr++)</a>
<a name="ln516">              for(int cc = 0; cc &lt; border; cc++)</a>
<a name="ln517">              {</a>
<a name="ln518">                int c = FC(rr, cc, filters);</a>
<a name="ln519">                rgb[c][(rrmax + rr) * ts + ccmax + cc] = (in[(height - rr - 2) * width + (width - cc - 2)]);</a>
<a name="ln520">              }</a>
<a name="ln521">          }</a>
<a name="ln522"> </a>
<a name="ln523">          if(rrmin &gt; 0 &amp;&amp; ccmax &lt; cc1)</a>
<a name="ln524">          {</a>
<a name="ln525">            for(int rr = 0; rr &lt; border; rr++)</a>
<a name="ln526">              for(int cc = 0; cc &lt; border; cc++)</a>
<a name="ln527">              {</a>
<a name="ln528">                int c = FC(rr, cc, filters);</a>
<a name="ln529">                rgb[c][(rr)*ts + ccmax + cc] = (in[(border2 - rr) * width + (width - cc - 2)]);</a>
<a name="ln530">              }</a>
<a name="ln531">          }</a>
<a name="ln532"> </a>
<a name="ln533">          if(rrmax &lt; rr1 &amp;&amp; ccmin &gt; 0)</a>
<a name="ln534">          {</a>
<a name="ln535">            for(int rr = 0; rr &lt; border; rr++)</a>
<a name="ln536">              for(int cc = 0; cc &lt; border; cc++)</a>
<a name="ln537">              {</a>
<a name="ln538">                int c = FC(rr, cc, filters);</a>
<a name="ln539">                rgb[c][(rrmax + rr) * ts + cc] = (in[(height - rr - 2) * width + (border2 - cc)]);</a>
<a name="ln540">              }</a>
<a name="ln541">          }</a>
<a name="ln542"> </a>
<a name="ln543">// end of border fill</a>
<a name="ln544">// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</a>
<a name="ln545">// end of initialization</a>
<a name="ln546"> </a>
<a name="ln547"> </a>
<a name="ln548">#ifdef __SSE2__</a>
<a name="ln549">          vfloat onev = F2V(1.f);</a>
<a name="ln550">          vfloat epsv = F2V(eps);</a>
<a name="ln551">#endif</a>
<a name="ln552">          for(int rr = 3; rr &lt; rr1 - 3; rr++)</a>
<a name="ln553">          {</a>
<a name="ln554">            int row = rr + top;</a>
<a name="ln555">            int cc = 3 + (FC(rr, 3, filters) &amp; 1);</a>
<a name="ln556">            int indx = rr * ts + cc;</a>
<a name="ln557">            int c = FC(rr, cc, filters);</a>
<a name="ln558">#ifdef __SSE2__</a>
<a name="ln559">            for(; cc &lt; cc1 - 9; cc += 8, indx += 8)</a>
<a name="ln560">            {</a>
<a name="ln561">              // compute directional weights using image gradients</a>
<a name="ln562">              vfloat wtuv = onev / SQRV(epsv + vabsf(LC2VFU(&amp;rgb[1][indx + v1]) - LC2VFU(&amp;rgb[1][indx - v1]))</a>
<a name="ln563">                                        + vabsf(LC2VFU(&amp;rgb[c][indx]) - LC2VFU(&amp;rgb[c][indx - v2]))</a>
<a name="ln564">                                        + vabsf(LC2VFU(&amp;rgb[1][indx - v1]) - LC2VFU(&amp;rgb[1][indx - v3])));</a>
<a name="ln565">              vfloat wtdv = onev / SQRV(epsv + vabsf(LC2VFU(&amp;rgb[1][indx - v1]) - LC2VFU(&amp;rgb[1][indx + v1]))</a>
<a name="ln566">                                        + vabsf(LC2VFU(&amp;rgb[c][indx]) - LC2VFU(&amp;rgb[c][indx + v2]))</a>
<a name="ln567">                                        + vabsf(LC2VFU(&amp;rgb[1][indx + v1]) - LC2VFU(&amp;rgb[1][indx + v3])));</a>
<a name="ln568">              vfloat wtlv = onev / SQRV(epsv + vabsf(LC2VFU(&amp;rgb[1][indx + 1]) - LC2VFU(&amp;rgb[1][indx - 1]))</a>
<a name="ln569">                                        + vabsf(LC2VFU(&amp;rgb[c][indx]) - LC2VFU(&amp;rgb[c][indx - 2]))</a>
<a name="ln570">                                        + vabsf(LC2VFU(&amp;rgb[1][indx - 1]) - LC2VFU(&amp;rgb[1][indx - 3])));</a>
<a name="ln571">              vfloat wtrv = onev / SQRV(epsv + vabsf(LC2VFU(&amp;rgb[1][indx - 1]) - LC2VFU(&amp;rgb[1][indx + 1]))</a>
<a name="ln572">                                        + vabsf(LC2VFU(&amp;rgb[c][indx]) - LC2VFU(&amp;rgb[c][indx + 2]))</a>
<a name="ln573">                                        + vabsf(LC2VFU(&amp;rgb[1][indx + 1]) - LC2VFU(&amp;rgb[1][indx + 3])));</a>
<a name="ln574"> </a>
<a name="ln575">              // store in rgb array the interpolated G value at R/B grid points using directional weighted</a>
<a name="ln576">              // average</a>
<a name="ln577">              STC2VFU(rgb[1][indx], (wtuv * LC2VFU(&amp;rgb[1][indx - v1]) + wtdv * LC2VFU(&amp;rgb[1][indx + v1])</a>
<a name="ln578">                                     + wtlv * LC2VFU(&amp;rgb[1][indx - 1]) + wtrv * LC2VFU(&amp;rgb[1][indx + 1]))</a>
<a name="ln579">                                        / (wtuv + wtdv + wtlv + wtrv));</a>
<a name="ln580">            }</a>
<a name="ln581"> </a>
<a name="ln582">#endif</a>
<a name="ln583">            for(; cc &lt; cc1 - 3; cc += 2, indx += 2)</a>
<a name="ln584">            {</a>
<a name="ln585">              // compute directional weights using image gradients</a>
<a name="ln586">              float wtu = 1.f / SQR(eps + fabsf(rgb[1][indx + v1] - rgb[1][indx - v1])</a>
<a name="ln587">                                    + fabsf(rgb[c][indx] - rgb[c][indx - v2])</a>
<a name="ln588">                                    + fabsf(rgb[1][indx - v1] - rgb[1][indx - v3]));</a>
<a name="ln589">              float wtd = 1.f / SQR(eps + fabsf(rgb[1][indx - v1] - rgb[1][indx + v1])</a>
<a name="ln590">                                    + fabsf(rgb[c][indx] - rgb[c][indx + v2])</a>
<a name="ln591">                                    + fabsf(rgb[1][indx + v1] - rgb[1][indx + v3]));</a>
<a name="ln592">              float wtl = 1.f / SQR(eps + fabsf(rgb[1][indx + 1] - rgb[1][indx - 1])</a>
<a name="ln593">                                    + fabsf(rgb[c][indx] - rgb[c][indx - 2])</a>
<a name="ln594">                                    + fabsf(rgb[1][indx - 1] - rgb[1][indx - 3]));</a>
<a name="ln595">              float wtr = 1.f / SQR(eps + fabsf(rgb[1][indx - 1] - rgb[1][indx + 1])</a>
<a name="ln596">                                    + fabsf(rgb[c][indx] - rgb[c][indx + 2])</a>
<a name="ln597">                                    + fabsf(rgb[1][indx + 1] - rgb[1][indx + 3]));</a>
<a name="ln598"> </a>
<a name="ln599">              // store in rgb array the interpolated G value at R/B grid points using directional weighted</a>
<a name="ln600">              // average</a>
<a name="ln601">              rgb[1][indx] = (wtu * rgb[1][indx - v1] + wtd * rgb[1][indx + v1] + wtl * rgb[1][indx - 1]</a>
<a name="ln602">                              + wtr * rgb[1][indx + 1])</a>
<a name="ln603">                             / (wtu + wtd + wtl + wtr);</a>
<a name="ln604">            }</a>
<a name="ln605"> </a>
<a name="ln606">            if(row &gt; -1 &amp;&amp; row &lt; height)</a>
<a name="ln607">            {</a>
<a name="ln608">              for(int col = MAX(left + 3, 0), indx = rr * ts + 3 - (left &lt; 0 ? (left + 3) : 0);</a>
<a name="ln609">                  col &lt; MIN(cc1 + left - 3, width); col++, indx++)</a>
<a name="ln610">              {</a>
<a name="ln611">                Gtmp[row * width + col] = rgb[1][indx];</a>
<a name="ln612">              }</a>
<a name="ln613">            }</a>
<a name="ln614">          }</a>
<a name="ln615">//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</a>
<a name="ln616">#ifdef __SSE2__</a>
<a name="ln617">          vfloat zd25v = F2V(0.25f);</a>
<a name="ln618">#endif</a>
<a name="ln619">          for(int rr = 4; rr &lt; rr1 - 4; rr++)</a>
<a name="ln620">          {</a>
<a name="ln621">            int cc = 4 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc, c = FC(rr, cc, filters);</a>
<a name="ln622">#ifdef __SSE2__</a>
<a name="ln623">            for(; cc &lt; cc1 - 10; cc += 8, indx += 8)</a>
<a name="ln624">            {</a>
<a name="ln625">              vfloat rgb1v = LC2VFU(&amp;rgb[1][indx]);</a>
<a name="ln626">              vfloat rgbcv = LC2VFU(&amp;rgb[c][indx]);</a>
<a name="ln627">              vfloat temp1v</a>
<a name="ln628">                  = vabsf(vabsf((rgb1v - rgbcv) - (LC2VFU(&amp;rgb[1][indx + v4]) - LC2VFU(&amp;rgb[c][indx + v4])))</a>
<a name="ln629">                          + vabsf(LC2VFU(&amp;rgb[1][indx - v4]) - LC2VFU(&amp;rgb[c][indx - v4]) - rgb1v + rgbcv)</a>
<a name="ln630">                          - vabsf(LC2VFU(&amp;rgb[1][indx - v4]) - LC2VFU(&amp;rgb[c][indx - v4])</a>
<a name="ln631">                                  - LC2VFU(&amp;rgb[1][indx + v4]) + LC2VFU(&amp;rgb[c][indx + v4])));</a>
<a name="ln632">              STVFU(rbhpfv[indx &gt;&gt; 1], temp1v);</a>
<a name="ln633">              vfloat temp2v</a>
<a name="ln634">                  = vabsf(vabsf((rgb1v - rgbcv) - (LC2VFU(&amp;rgb[1][indx + 4]) - LC2VFU(&amp;rgb[c][indx + 4])))</a>
<a name="ln635">                          + vabsf(LC2VFU(&amp;rgb[1][indx - 4]) - LC2VFU(&amp;rgb[c][indx - 4]) - rgb1v + rgbcv)</a>
<a name="ln636">                          - vabsf(LC2VFU(&amp;rgb[1][indx - 4]) - LC2VFU(&amp;rgb[c][indx - 4])</a>
<a name="ln637">                                  - LC2VFU(&amp;rgb[1][indx + 4]) + LC2VFU(&amp;rgb[c][indx + 4])));</a>
<a name="ln638">              STVFU(rbhpfh[indx &gt;&gt; 1], temp2v);</a>
<a name="ln639"> </a>
<a name="ln640">              // low and high pass 1D filters of G in vertical/horizontal directions</a>
<a name="ln641">              rgb1v = vmul2f(rgb1v);</a>
<a name="ln642">              vfloat glpfvv = zd25v * (rgb1v + LC2VFU(&amp;rgb[1][indx + v2]) + LC2VFU(&amp;rgb[1][indx - v2]));</a>
<a name="ln643">              vfloat glpfhv = zd25v * (rgb1v + LC2VFU(&amp;rgb[1][indx + 2]) + LC2VFU(&amp;rgb[1][indx - 2]));</a>
<a name="ln644">              rgbcv = vmul2f(rgbcv);</a>
<a name="ln645">              STVFU(rblpfv[indx &gt;&gt; 1],</a>
<a name="ln646">                    epsv + vabsf(glpfvv</a>
<a name="ln647">                                 - zd25v * (rgbcv + LC2VFU(&amp;rgb[c][indx + v2]) + LC2VFU(&amp;rgb[c][indx - v2]))));</a>
<a name="ln648">              STVFU(rblpfh[indx &gt;&gt; 1],</a>
<a name="ln649">                    epsv + vabsf(glpfhv</a>
<a name="ln650">                                 - zd25v * (rgbcv + LC2VFU(&amp;rgb[c][indx + 2]) + LC2VFU(&amp;rgb[c][indx - 2]))));</a>
<a name="ln651">              STVFU(grblpfv[indx &gt;&gt; 1],</a>
<a name="ln652">                    glpfvv + zd25v * (rgbcv + LC2VFU(&amp;rgb[c][indx + v2]) + LC2VFU(&amp;rgb[c][indx - v2])));</a>
<a name="ln653">              STVFU(grblpfh[indx &gt;&gt; 1],</a>
<a name="ln654">                    glpfhv + zd25v * (rgbcv + LC2VFU(&amp;rgb[c][indx + 2]) + LC2VFU(&amp;rgb[c][indx - 2])));</a>
<a name="ln655">            }</a>
<a name="ln656"> </a>
<a name="ln657">#endif</a>
<a name="ln658">            for(; cc &lt; cc1 - 4; cc += 2, indx += 2)</a>
<a name="ln659">            {</a>
<a name="ln660">              rbhpfv[indx &gt;&gt; 1] = fabsf(</a>
<a name="ln661">                  fabsf((rgb[1][indx] - rgb[c][indx]) - (rgb[1][indx + v4] - rgb[c][indx + v4]))</a>
<a name="ln662">                  + fabsf((rgb[1][indx - v4] - rgb[c][indx - v4]) - (rgb[1][indx] - rgb[c][indx]))</a>
<a name="ln663">                  - fabsf((rgb[1][indx - v4] - rgb[c][indx - v4]) - (rgb[1][indx + v4] - rgb[c][indx + v4])));</a>
<a name="ln664">              rbhpfh[indx &gt;&gt; 1] = fabsf(</a>
<a name="ln665">                  fabsf((rgb[1][indx] - rgb[c][indx]) - (rgb[1][indx + 4] - rgb[c][indx + 4]))</a>
<a name="ln666">                  + fabsf((rgb[1][indx - 4] - rgb[c][indx - 4]) - (rgb[1][indx] - rgb[c][indx]))</a>
<a name="ln667">                  - fabsf((rgb[1][indx - 4] - rgb[c][indx - 4]) - (rgb[1][indx + 4] - rgb[c][indx + 4])));</a>
<a name="ln668"> </a>
<a name="ln669">              // low and high pass 1D filters of G in vertical/horizontal directions</a>
<a name="ln670">              float glpfv = 0.25f * (2.f * rgb[1][indx] + rgb[1][indx + v2] + rgb[1][indx - v2]);</a>
<a name="ln671">              float glpfh = 0.25f * (2.f * rgb[1][indx] + rgb[1][indx + 2] + rgb[1][indx - 2]);</a>
<a name="ln672">              rblpfv[indx &gt;&gt; 1]</a>
<a name="ln673">                  = eps + fabsf(glpfv - 0.25f * (2.f * rgb[c][indx] + rgb[c][indx + v2] + rgb[c][indx - v2]));</a>
<a name="ln674">              rblpfh[indx &gt;&gt; 1]</a>
<a name="ln675">                  = eps + fabsf(glpfh - 0.25f * (2.f * rgb[c][indx] + rgb[c][indx + 2] + rgb[c][indx - 2]));</a>
<a name="ln676">              grblpfv[indx &gt;&gt; 1]</a>
<a name="ln677">                  = glpfv + 0.25f * (2.f * rgb[c][indx] + rgb[c][indx + v2] + rgb[c][indx - v2]);</a>
<a name="ln678">              grblpfh[indx &gt;&gt; 1] = glpfh + 0.25f * (2.f * rgb[c][indx] + rgb[c][indx + 2] + rgb[c][indx - 2]);</a>
<a name="ln679">            }</a>
<a name="ln680">          }</a>
<a name="ln681"> </a>
<a name="ln682">          for(int dir = 0; dir &lt; 2; dir++)</a>
<a name="ln683">          {</a>
<a name="ln684">            for(int k = 0; k &lt; 3; k++)</a>
<a name="ln685">            {</a>
<a name="ln686">              for(int c = 0; c &lt; 2; c++)</a>
<a name="ln687">              {</a>
<a name="ln688">                coeff[dir][k][c] = 0;</a>
<a name="ln689">              }</a>
<a name="ln690">            }</a>
<a name="ln691">          }</a>
<a name="ln692"> </a>
<a name="ln693">#ifdef __SSE2__</a>
<a name="ln694">          vfloat zd3125v = F2V(0.3125f);</a>
<a name="ln695">          vfloat zd09375v = F2V(0.09375f);</a>
<a name="ln696">          vfloat zd1v = F2V(0.1f);</a>
<a name="ln697">          vfloat zd125v = F2V(0.125f);</a>
<a name="ln698">#endif</a>
<a name="ln699"> </a>
<a name="ln700">          // along line segments, find the point along each segment that minimizes the colour variance</a>
<a name="ln701">          // averaged over the tile; evaluate for up/down and left/right away from R/B grid point</a>
<a name="ln702">          for(int rr = 8; rr &lt; rr1 - 8; rr++)</a>
<a name="ln703">          {</a>
<a name="ln704">            int cc = 8 + (FC(rr, 2, filters) &amp; 1);</a>
<a name="ln705">            int indx = rr * ts + cc;</a>
<a name="ln706">            int c = FC(rr, cc, filters);</a>
<a name="ln707">#ifdef __SSE2__</a>
<a name="ln708">            vfloat coeff00v = ZEROV;</a>
<a name="ln709">            vfloat coeff01v = ZEROV;</a>
<a name="ln710">            vfloat coeff02v = ZEROV;</a>
<a name="ln711">            vfloat coeff10v = ZEROV;</a>
<a name="ln712">            vfloat coeff11v = ZEROV;</a>
<a name="ln713">            vfloat coeff12v = ZEROV;</a>
<a name="ln714">            for(; cc &lt; cc1 - 14; cc += 8, indx += 8)</a>
<a name="ln715">            {</a>
<a name="ln716"> </a>
<a name="ln717">              // in linear interpolation, colour differences are a quadratic function of interpolation</a>
<a name="ln718">              // position;</a>
<a name="ln719">              // solve for the interpolation position that minimizes colour difference variance over the tile</a>
<a name="ln720"> </a>
<a name="ln721">              // vertical</a>
<a name="ln722">              vfloat gdiffv</a>
<a name="ln723">                  = zd3125v * (LC2VFU(&amp;rgb[1][indx + ts]) - LC2VFU(&amp;rgb[1][indx - ts]))</a>
<a name="ln724">                    + zd09375v * (LC2VFU(&amp;rgb[1][indx + ts + 1]) - LC2VFU(&amp;rgb[1][indx - ts + 1])</a>
<a name="ln725">                                  + LC2VFU(&amp;rgb[1][indx + ts - 1]) - LC2VFU(&amp;rgb[1][indx - ts - 1]));</a>
<a name="ln726">              vfloat deltgrbv = LC2VFU(&amp;rgb[c][indx]) - LC2VFU(&amp;rgb[1][indx]);</a>
<a name="ln727"> </a>
<a name="ln728">              vfloat gradwtv</a>
<a name="ln729">                  = vabsf(zd25v * LVFU(rbhpfv[indx &gt;&gt; 1])</a>
<a name="ln730">                          + zd125v * (LVFU(rbhpfv[(indx &gt;&gt; 1) + 1]) + LVFU(rbhpfv[(indx &gt;&gt; 1) - 1])))</a>
<a name="ln731">                    * (LVFU(grblpfv[(indx &gt;&gt; 1) - v1]) + LVFU(grblpfv[(indx &gt;&gt; 1) + v1]))</a>
<a name="ln732">                    / (epsv + zd1v * (LVFU(grblpfv[(indx &gt;&gt; 1) - v1]) + LVFU(grblpfv[(indx &gt;&gt; 1) + v1]))</a>
<a name="ln733">                       + LVFU(rblpfv[(indx &gt;&gt; 1) - v1]) + LVFU(rblpfv[(indx &gt;&gt; 1) + v1]));</a>
<a name="ln734"> </a>
<a name="ln735">              coeff00v += gradwtv * deltgrbv * deltgrbv;</a>
<a name="ln736">              coeff01v += gradwtv * gdiffv * deltgrbv;</a>
<a name="ln737">              coeff02v += gradwtv * gdiffv * gdiffv;</a>
<a name="ln738"> </a>
<a name="ln739">              // horizontal</a>
<a name="ln740">              gdiffv = zd3125v * (LC2VFU(&amp;rgb[1][indx + 1]) - LC2VFU(&amp;rgb[1][indx - 1]))</a>
<a name="ln741">                       + zd09375v * (LC2VFU(&amp;rgb[1][indx + 1 + ts]) - LC2VFU(&amp;rgb[1][indx - 1 + ts])</a>
<a name="ln742">                                     + LC2VFU(&amp;rgb[1][indx + 1 - ts]) - LC2VFU(&amp;rgb[1][indx - 1 - ts]));</a>
<a name="ln743"> </a>
<a name="ln744">              gradwtv = vabsf(zd25v * LVFU(rbhpfh[indx &gt;&gt; 1])</a>
<a name="ln745">                              + zd125v * (LVFU(rbhpfh[(indx &gt;&gt; 1) + v1]) + LVFU(rbhpfh[(indx &gt;&gt; 1) - v1])))</a>
<a name="ln746">                        * (LVFU(grblpfh[(indx &gt;&gt; 1) - 1]) + LVFU(grblpfh[(indx &gt;&gt; 1) + 1]))</a>
<a name="ln747">                        / (epsv + zd1v * (LVFU(grblpfh[(indx &gt;&gt; 1) - 1]) + LVFU(grblpfh[(indx &gt;&gt; 1) + 1]))</a>
<a name="ln748">                           + LVFU(rblpfh[(indx &gt;&gt; 1) - 1]) + LVFU(rblpfh[(indx &gt;&gt; 1) + 1]));</a>
<a name="ln749"> </a>
<a name="ln750">              coeff10v += gradwtv * deltgrbv * deltgrbv;</a>
<a name="ln751">              coeff11v += gradwtv * gdiffv * deltgrbv;</a>
<a name="ln752">              coeff12v += gradwtv * gdiffv * gdiffv;</a>
<a name="ln753"> </a>
<a name="ln754">              //  In Mathematica,</a>
<a name="ln755">              //  f[x_]=Expand[Total[Flatten[</a>
<a name="ln756">              //  ((1-x) RotateLeft[Gint,shift1]+x</a>
<a name="ln757">              //  RotateLeft[Gint,shift2]-cfapad)^2[[dv;;-1;;2,dh;;-1;;2]]]]];</a>
<a name="ln758">              //  extremum = -.5Coefficient[f[x],x]/Coefficient[f[x],x^2]</a>
<a name="ln759">            }</a>
<a name="ln760">            coeff[0][0][c &gt;&gt; 1] += vhadd(coeff00v);</a>
<a name="ln761">            coeff[0][1][c &gt;&gt; 1] += vhadd(coeff01v);</a>
<a name="ln762">            coeff[0][2][c &gt;&gt; 1] += vhadd(coeff02v);</a>
<a name="ln763">            coeff[1][0][c &gt;&gt; 1] += vhadd(coeff10v);</a>
<a name="ln764">            coeff[1][1][c &gt;&gt; 1] += vhadd(coeff11v);</a>
<a name="ln765">            coeff[1][2][c &gt;&gt; 1] += vhadd(coeff12v);</a>
<a name="ln766"> </a>
<a name="ln767">#endif</a>
<a name="ln768">            for(; cc &lt; cc1 - 8; cc += 2, indx += 2)</a>
<a name="ln769">            {</a>
<a name="ln770"> </a>
<a name="ln771">              // in linear interpolation, colour differences are a quadratic function of interpolation</a>
<a name="ln772">              // position;</a>
<a name="ln773">              // solve for the interpolation position that minimizes colour difference variance over the tile</a>
<a name="ln774"> </a>
<a name="ln775">              // vertical</a>
<a name="ln776">              float gdiff = 0.3125f * (rgb[1][indx + ts] - rgb[1][indx - ts])</a>
<a name="ln777">                            + 0.09375f * (rgb[1][indx + ts + 1] - rgb[1][indx - ts + 1]</a>
<a name="ln778">                                          + rgb[1][indx + ts - 1] - rgb[1][indx - ts - 1]);</a>
<a name="ln779">              float deltgrb = (rgb[c][indx] - rgb[1][indx]);</a>
<a name="ln780"> </a>
<a name="ln781">              float gradwt = fabsf(0.25f * rbhpfv[indx &gt;&gt; 1]</a>
<a name="ln782">                                   + 0.125f * (rbhpfv[(indx &gt;&gt; 1) + 1] + rbhpfv[(indx &gt;&gt; 1) - 1]))</a>
<a name="ln783">                             * (grblpfv[(indx &gt;&gt; 1) - v1] + grblpfv[(indx &gt;&gt; 1) + v1])</a>
<a name="ln784">                             / (eps + 0.1f * (grblpfv[(indx &gt;&gt; 1) - v1] + grblpfv[(indx &gt;&gt; 1) + v1])</a>
<a name="ln785">                                + rblpfv[(indx &gt;&gt; 1) - v1] + rblpfv[(indx &gt;&gt; 1) + v1]);</a>
<a name="ln786"> </a>
<a name="ln787">              coeff[0][0][c &gt;&gt; 1] += gradwt * deltgrb * deltgrb;</a>
<a name="ln788">              coeff[0][1][c &gt;&gt; 1] += gradwt * gdiff * deltgrb;</a>
<a name="ln789">              coeff[0][2][c &gt;&gt; 1] += gradwt * gdiff * gdiff;</a>
<a name="ln790"> </a>
<a name="ln791">              // horizontal</a>
<a name="ln792">              gdiff = 0.3125f * (rgb[1][indx + 1] - rgb[1][indx - 1])</a>
<a name="ln793">                      + 0.09375f * (rgb[1][indx + 1 + ts] - rgb[1][indx - 1 + ts] + rgb[1][indx + 1 - ts]</a>
<a name="ln794">                                    - rgb[1][indx - 1 - ts]);</a>
<a name="ln795"> </a>
<a name="ln796">              gradwt = fabsf(0.25f * rbhpfh[indx &gt;&gt; 1]</a>
<a name="ln797">                             + 0.125f * (rbhpfh[(indx &gt;&gt; 1) + v1] + rbhpfh[(indx &gt;&gt; 1) - v1]))</a>
<a name="ln798">                       * (grblpfh[(indx &gt;&gt; 1) - 1] + grblpfh[(indx &gt;&gt; 1) + 1])</a>
<a name="ln799">                       / (eps + 0.1f * (grblpfh[(indx &gt;&gt; 1) - 1] + grblpfh[(indx &gt;&gt; 1) + 1])</a>
<a name="ln800">                          + rblpfh[(indx &gt;&gt; 1) - 1] + rblpfh[(indx &gt;&gt; 1) + 1]);</a>
<a name="ln801"> </a>
<a name="ln802">              coeff[1][0][c &gt;&gt; 1] += gradwt * deltgrb * deltgrb;</a>
<a name="ln803">              coeff[1][1][c &gt;&gt; 1] += gradwt * gdiff * deltgrb;</a>
<a name="ln804">              coeff[1][2][c &gt;&gt; 1] += gradwt * gdiff * gdiff;</a>
<a name="ln805"> </a>
<a name="ln806">              //  In Mathematica,</a>
<a name="ln807">              //  f[x_]=Expand[Total[Flatten[</a>
<a name="ln808">              //  ((1-x) RotateLeft[Gint,shift1]+x</a>
<a name="ln809">              //  RotateLeft[Gint,shift2]-cfapad)^2[[dv;;-1;;2,dh;;-1;;2]]]]];</a>
<a name="ln810">              //  extremum = -.5Coefficient[f[x],x]/Coefficient[f[x],x^2]</a>
<a name="ln811">            }</a>
<a name="ln812">          }</a>
<a name="ln813"> </a>
<a name="ln814">          for(int c = 0; c &lt; 2; c++)</a>
<a name="ln815">          {</a>
<a name="ln816">            for(int dir = 0; dir &lt; 2; dir++)</a>
<a name="ln817">            { // vert/hor</a>
<a name="ln818"> </a>
<a name="ln819">              // CAshift[dir][c] are the locations</a>
<a name="ln820">              // that minimize colour difference variances;</a>
<a name="ln821">              // This is the approximate _optical_ location of the R/B pixels</a>
<a name="ln822">              if(coeff[dir][2][c] &gt; eps2)</a>
<a name="ln823">              {</a>
<a name="ln824">                CAshift[dir][c] = coeff[dir][1][c] / coeff[dir][2][c];</a>
<a name="ln825">                blockwt[vblock * hblsz + hblock] = coeff[dir][2][c] / (eps + coeff[dir][0][c]);</a>
<a name="ln826">              }</a>
<a name="ln827">              else</a>
<a name="ln828">              {</a>
<a name="ln829">                CAshift[dir][c] = 17.0;</a>
<a name="ln830">                blockwt[vblock * hblsz + hblock] = 0;</a>
<a name="ln831">              }</a>
<a name="ln832"> </a>
<a name="ln833">              // data structure = CAshift[vert/hor][colour]</a>
<a name="ln834">              // dir : 0=vert, 1=hor</a>
<a name="ln835"> </a>
<a name="ln836">              // offset gives NW corner of square containing the min; dir : 0=vert, 1=hor</a>
<a name="ln837">              if(fabsf(CAshift[dir][c]) &lt; 2.0f)</a>
<a name="ln838">              {</a>
<a name="ln839">                blockavethr[dir][c] += CAshift[dir][c];</a>
<a name="ln840">                blocksqavethr[dir][c] += SQR(CAshift[dir][c]);</a>
<a name="ln841">                blockdenomthr[dir][c] += 1;</a>
<a name="ln842">              }</a>
<a name="ln843">              // evaluate the shifts to the location that minimizes CA within the tile</a>
<a name="ln844">              blockshifts[vblock * hblsz + hblock][c][dir] = CAshift[dir][c]; // vert/hor CA shift for R/B</a>
<a name="ln845"> </a>
<a name="ln846">            } // vert/hor</a>
<a name="ln847">          }   // colour</a>
<a name="ln848"> </a>
<a name="ln849">          //           if(plistener)</a>
<a name="ln850">          //           {</a>
<a name="ln851">          //             progresscounter++;</a>
<a name="ln852">          //</a>
<a name="ln853">          //             if(progresscounter % 8 == 0)</a>
<a name="ln854">          // #pragma omp critical(cadetectpass1)</a>
<a name="ln855">          //             {</a>
<a name="ln856">          //               progress += (double)(8.0 * (ts - border2) * (ts - border2)) / (2 * height * width);</a>
<a name="ln857">          //</a>
<a name="ln858">          //               if(progress &gt; 1.0)</a>
<a name="ln859">          //               {</a>
<a name="ln860">          //                 progress = 1.0;</a>
<a name="ln861">          //               }</a>
<a name="ln862">          //</a>
<a name="ln863">          //               plistener-&gt;setProgress(progress);</a>
<a name="ln864">          //             }</a>
<a name="ln865">          //           }</a>
<a name="ln866">        }</a>
<a name="ln867"> </a>
<a name="ln868">// end of diagnostic pass</a>
<a name="ln869">#ifdef _OPENMP</a>
<a name="ln870">#pragma omp critical(cadetectpass2)</a>
<a name="ln871">#endif</a>
<a name="ln872">      {</a>
<a name="ln873">        for(int dir = 0; dir &lt; 2; dir++)</a>
<a name="ln874">          for(int c = 0; c &lt; 2; c++)</a>
<a name="ln875">          {</a>
<a name="ln876">            blockdenom[dir][c] += blockdenomthr[dir][c];</a>
<a name="ln877">            blocksqave[dir][c] += blocksqavethr[dir][c];</a>
<a name="ln878">            blockave[dir][c] += blockavethr[dir][c];</a>
<a name="ln879">          }</a>
<a name="ln880">      }</a>
<a name="ln881">#ifdef _OPENMP</a>
<a name="ln882">#pragma omp barrier</a>
<a name="ln883">#endif</a>
<a name="ln884"> </a>
<a name="ln885">#ifdef _OPENMP</a>
<a name="ln886">#pragma omp single</a>
<a name="ln887">#endif</a>
<a name="ln888">      {</a>
<a name="ln889">        for(int dir = 0; dir &lt; 2; dir++)</a>
<a name="ln890">          for(int c = 0; c &lt; 2; c++)</a>
<a name="ln891">          {</a>
<a name="ln892">            if(blockdenom[dir][c])</a>
<a name="ln893">            {</a>
<a name="ln894">              blockvar[dir][c]</a>
<a name="ln895">                  = blocksqave[dir][c] / blockdenom[dir][c] - SQR(blockave[dir][c] / blockdenom[dir][c]);</a>
<a name="ln896">            }</a>
<a name="ln897">            else</a>
<a name="ln898">            {</a>
<a name="ln899">              processpasstwo = FALSE;</a>
<a name="ln900">              printf(&quot;blockdenom vanishes \n&quot;);</a>
<a name="ln901">              break;</a>
<a name="ln902">            }</a>
<a name="ln903">          }</a>
<a name="ln904"> </a>
<a name="ln905">        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</a>
<a name="ln906"> </a>
<a name="ln907">        // now prepare for CA correction pass</a>
<a name="ln908">        // first, fill border blocks of blockshift array</a>
<a name="ln909">        if(processpasstwo)</a>
<a name="ln910">        {</a>
<a name="ln911">          for(int vblock = 1; vblock &lt; vblsz - 1; vblock++)</a>
<a name="ln912">          { // left and right sides</a>
<a name="ln913">            for(int c = 0; c &lt; 2; c++)</a>
<a name="ln914">            {</a>
<a name="ln915">              for(int i = 0; i &lt; 2; i++)</a>
<a name="ln916">              {</a>
<a name="ln917">                blockshifts[vblock * hblsz][c][i] = blockshifts[(vblock)*hblsz + 2][c][i];</a>
<a name="ln918">                blockshifts[vblock * hblsz + hblsz - 1][c][i] = blockshifts[(vblock)*hblsz + hblsz - 3][c][i];</a>
<a name="ln919">              }</a>
<a name="ln920">            }</a>
<a name="ln921">          }</a>
<a name="ln922"> </a>
<a name="ln923">          for(int hblock = 0; hblock &lt; hblsz; hblock++)</a>
<a name="ln924">          { // top and bottom sides</a>
<a name="ln925">            for(int c = 0; c &lt; 2; c++)</a>
<a name="ln926">            {</a>
<a name="ln927">              for(int i = 0; i &lt; 2; i++)</a>
<a name="ln928">              {</a>
<a name="ln929">                blockshifts[hblock][c][i] = blockshifts[2 * hblsz + hblock][c][i];</a>
<a name="ln930">                blockshifts[(vblsz - 1) * hblsz + hblock][c][i]</a>
<a name="ln931">                    = blockshifts[(vblsz - 3) * hblsz + hblock][c][i];</a>
<a name="ln932">              }</a>
<a name="ln933">            }</a>
<a name="ln934">          }</a>
<a name="ln935"> </a>
<a name="ln936">          // end of filling border pixels of blockshift array</a>
<a name="ln937"> </a>
<a name="ln938">          // initialize fit arrays</a>
<a name="ln939">          double polymat[2][2][256], shiftmat[2][2][16];</a>
<a name="ln940"> </a>
<a name="ln941">          for(int i = 0; i &lt; 256; i++)</a>
<a name="ln942">          {</a>
<a name="ln943">            polymat[0][0][i] = polymat[0][1][i] = polymat[1][0][i] = polymat[1][1][i] = 0;</a>
<a name="ln944">          }</a>
<a name="ln945"> </a>
<a name="ln946">          for(int i = 0; i &lt; 16; i++)</a>
<a name="ln947">          {</a>
<a name="ln948">            shiftmat[0][0][i] = shiftmat[0][1][i] = shiftmat[1][0][i] = shiftmat[1][1][i] = 0;</a>
<a name="ln949">          }</a>
<a name="ln950"> </a>
<a name="ln951">          int numblox[2] = { 0, 0 };</a>
<a name="ln952"> </a>
<a name="ln953">          for(int vblock = 1; vblock &lt; vblsz - 1; vblock++)</a>
<a name="ln954">            for(int hblock = 1; hblock &lt; hblsz - 1; hblock++)</a>
<a name="ln955">            {</a>
<a name="ln956">              // block 3x3 median of blockshifts for robustness</a>
<a name="ln957">              for(int c = 0; c &lt; 2; c++)</a>
<a name="ln958">              {</a>
<a name="ln959">                float bstemp[2];</a>
<a name="ln960">                for(int dir = 0; dir &lt; 2; dir++)</a>
<a name="ln961">                {</a>
<a name="ln962">                  // temporary storage for median filter</a>
<a name="ln963">                  float p[9];</a>
<a name="ln964">                  p[0] = blockshifts[(vblock - 1) * hblsz + hblock - 1][c][dir];</a>
<a name="ln965">                  p[1] = blockshifts[(vblock - 1) * hblsz + hblock][c][dir];</a>
<a name="ln966">                  p[2] = blockshifts[(vblock - 1) * hblsz + hblock + 1][c][dir];</a>
<a name="ln967">                  p[3] = blockshifts[(vblock)*hblsz + hblock - 1][c][dir];</a>
<a name="ln968">                  p[4] = blockshifts[(vblock)*hblsz + hblock][c][dir];</a>
<a name="ln969">                  p[5] = blockshifts[(vblock)*hblsz + hblock + 1][c][dir];</a>
<a name="ln970">                  p[6] = blockshifts[(vblock + 1) * hblsz + hblock - 1][c][dir];</a>
<a name="ln971">                  p[7] = blockshifts[(vblock + 1) * hblsz + hblock][c][dir];</a>
<a name="ln972">                  p[8] = blockshifts[(vblock + 1) * hblsz + hblock + 1][c][dir];</a>
<a name="ln973">                  pixSort(&amp;p[1], &amp;p[2]);</a>
<a name="ln974">                  pixSort(&amp;p[4], &amp;p[5]);</a>
<a name="ln975">                  pixSort(&amp;p[7], &amp;p[8]);</a>
<a name="ln976">                  pixSort(&amp;p[0], &amp;p[1]);</a>
<a name="ln977">                  pixSort(&amp;p[3], &amp;p[4]);</a>
<a name="ln978">                  pixSort(&amp;p[6], &amp;p[7]);</a>
<a name="ln979">                  pixSort(&amp;p[1], &amp;p[2]);</a>
<a name="ln980">                  pixSort(&amp;p[4], &amp;p[5]);</a>
<a name="ln981">                  pixSort(&amp;p[7], &amp;p[8]);</a>
<a name="ln982">                  pixSort(&amp;p[0], &amp;p[3]);</a>
<a name="ln983">                  pixSort(&amp;p[5], &amp;p[8]);</a>
<a name="ln984">                  pixSort(&amp;p[4], &amp;p[7]);</a>
<a name="ln985">                  pixSort(&amp;p[3], &amp;p[6]);</a>
<a name="ln986">                  pixSort(&amp;p[1], &amp;p[4]);</a>
<a name="ln987">                  pixSort(&amp;p[2], &amp;p[5]);</a>
<a name="ln988">                  pixSort(&amp;p[4], &amp;p[7]);</a>
<a name="ln989">                  pixSort(&amp;p[4], &amp;p[2]);</a>
<a name="ln990">                  pixSort(&amp;p[6], &amp;p[4]);</a>
<a name="ln991">                  pixSort(&amp;p[4], &amp;p[2]);</a>
<a name="ln992">                  bstemp[dir] = p[4];</a>
<a name="ln993">                }</a>
<a name="ln994"> </a>
<a name="ln995">                // now prepare coefficient matrix; use only data points within caautostrength/2 std devs of</a>
<a name="ln996">                // zero</a>
<a name="ln997">                if(SQR(bstemp[0]) &gt; caautostrength * blockvar[0][c]</a>
<a name="ln998">                   || SQR(bstemp[1]) &gt; caautostrength * blockvar[1][c])</a>
<a name="ln999">                {</a>
<a name="ln1000">                  continue;</a>
<a name="ln1001">                }</a>
<a name="ln1002"> </a>
<a name="ln1003">                numblox[c]++;</a>
<a name="ln1004"> </a>
<a name="ln1005">                for(int dir = 0; dir &lt; 2; dir++)</a>
<a name="ln1006">                {</a>
<a name="ln1007">                  double powVblockInit = 1.0;</a>
<a name="ln1008">                  for(int i = 0; i &lt; polyord; i++)</a>
<a name="ln1009">                  {</a>
<a name="ln1010">                    double powHblockInit = 1.0;</a>
<a name="ln1011">                    for(int j = 0; j &lt; polyord; j++)</a>
<a name="ln1012">                    {</a>
<a name="ln1013">                      double powVblock = powVblockInit;</a>
<a name="ln1014">                      for(int m = 0; m &lt; polyord; m++)</a>
<a name="ln1015">                      {</a>
<a name="ln1016">                        double powHblock = powHblockInit;</a>
<a name="ln1017">                        for(int n = 0; n &lt; polyord; n++)</a>
<a name="ln1018">                        {</a>
<a name="ln1019">                          polymat[c][dir][numpar * (polyord * i + j) + (polyord * m + n)]</a>
<a name="ln1020">                              += powVblock * powHblock * blockwt[vblock * hblsz + hblock];</a>
<a name="ln1021">                          powHblock *= hblock;</a>
<a name="ln1022">                        }</a>
<a name="ln1023">                        powVblock *= vblock;</a>
<a name="ln1024">                      }</a>
<a name="ln1025">                      shiftmat[c][dir][(polyord * i + j)]</a>
<a name="ln1026">                          += powVblockInit * powHblockInit * bstemp[dir] * blockwt[vblock * hblsz + hblock];</a>
<a name="ln1027">                      powHblockInit *= hblock;</a>
<a name="ln1028">                    }</a>
<a name="ln1029">                    powVblockInit *= vblock;</a>
<a name="ln1030">                  } // monomials</a>
<a name="ln1031">                }   // dir</a>
<a name="ln1032">              }     // c</a>
<a name="ln1033">            }       // blocks</a>
<a name="ln1034"> </a>
<a name="ln1035">          numblox[1] = MIN(numblox[0], numblox[1]);</a>
<a name="ln1036"> </a>
<a name="ln1037">          // if too few data points, restrict the order of the fit to linear</a>
<a name="ln1038">          if(numblox[1] &lt; 32)</a>
<a name="ln1039">          {</a>
<a name="ln1040">            polyord = 2;</a>
<a name="ln1041">            numpar = 4;</a>
<a name="ln1042"> </a>
<a name="ln1043">            if(numblox[1] &lt; 10)</a>
<a name="ln1044">            {</a>
<a name="ln1045"> </a>
<a name="ln1046">              printf(&quot;numblox = %d \n&quot;, numblox[1]);</a>
<a name="ln1047">              processpasstwo = FALSE;</a>
<a name="ln1048">            }</a>
<a name="ln1049">          }</a>
<a name="ln1050"> </a>
<a name="ln1051">          if(processpasstwo)</a>
<a name="ln1052"> </a>
<a name="ln1053">            // fit parameters to blockshifts</a>
<a name="ln1054">            for(int c = 0; c &lt; 2; c++)</a>
<a name="ln1055">              for(int dir = 0; dir &lt; 2; dir++)</a>
<a name="ln1056">              {</a>
<a name="ln1057">                if(!LinEqSolve(numpar, polymat[c][dir], shiftmat[c][dir], fitparams[c][dir]))</a>
<a name="ln1058">                {</a>
<a name="ln1059">                  printf(&quot;CA correction pass failed -- can't solve linear equations for colour %d direction &quot;</a>
<a name="ln1060">                         &quot;%d...\n&quot;,</a>
<a name="ln1061">                         c, dir);</a>
<a name="ln1062">                  processpasstwo = FALSE;</a>
<a name="ln1063">                }</a>
<a name="ln1064">              }</a>
<a name="ln1065">        }</a>
<a name="ln1066"> </a>
<a name="ln1067">        // fitparams[polyord*i+j] gives the coefficients of (vblock^i hblock^j) in a polynomial fit for i,j&lt;=4</a>
<a name="ln1068">      }</a>
<a name="ln1069">      // end of initialization for CA correction pass</a>
<a name="ln1070">      // only executed if cared and cablue are zero</a>
<a name="ln1071">    }</a>
<a name="ln1072"> </a>
<a name="ln1073">    // Main algorithm: Tile loop</a>
<a name="ln1074">    if(processpasstwo)</a>
<a name="ln1075">    {</a>
<a name="ln1076">#ifdef _OPENMP</a>
<a name="ln1077">#pragma omp for schedule(dynamic) collapse(2) nowait</a>
<a name="ln1078">#endif</a>
<a name="ln1079"> </a>
<a name="ln1080">      for(int top = -border; top &lt; height; top += ts - border2)</a>
<a name="ln1081">        for(int left = -border; left &lt; width; left += ts - border2)</a>
<a name="ln1082">        {</a>
<a name="ln1083">          memset(buffer, 0, buffersize);</a>
<a name="ln1084">          float lblockshifts[2][2];</a>
<a name="ln1085">          const int vblock = ((top + border) / (ts - border2)) + 1;</a>
<a name="ln1086">          const int hblock = ((left + border) / (ts - border2)) + 1;</a>
<a name="ln1087">          const int bottom = MIN(top + ts, height + border);</a>
<a name="ln1088">          const int right = MIN(left + ts, width + border);</a>
<a name="ln1089">          const int rr1 = bottom - top;</a>
<a name="ln1090">          const int cc1 = right - left;</a>
<a name="ln1091"> </a>
<a name="ln1092">          const int rrmin = top &lt; 0 ? border : 0;</a>
<a name="ln1093">          const int rrmax = bottom &gt; height ? height - top : rr1;</a>
<a name="ln1094">          const int ccmin = left &lt; 0 ? border : 0;</a>
<a name="ln1095">          const int ccmax = right &gt; width ? width - left : cc1;</a>
<a name="ln1096"> </a>
<a name="ln1097">          // rgb from input CFA data</a>
<a name="ln1098">          // rgb values should be floating point number between 0 and 1</a>
<a name="ln1099">          // after white balance multipliers are applied</a>
<a name="ln1100"> </a>
<a name="ln1101">          for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln1102">            for(int row = rr + top, cc = ccmin; cc &lt; ccmax; cc++)</a>
<a name="ln1103">            {</a>
<a name="ln1104">              int col = cc + left;</a>
<a name="ln1105">              int c = FC(rr, cc, filters);</a>
<a name="ln1106">              int indx = row * width + col;</a>
<a name="ln1107">              int indx1 = rr * ts + cc;</a>
<a name="ln1108">              rgb[c][indx1] = (in[indx]);</a>
<a name="ln1109"> </a>
<a name="ln1110">              if((c &amp; 1) == 0)</a>
<a name="ln1111">              {</a>
<a name="ln1112">                rgb[1][indx1] = Gtmp[indx];</a>
<a name="ln1113">              }</a>
<a name="ln1114">            }</a>
<a name="ln1115"> </a>
<a name="ln1116">          // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</a>
<a name="ln1117">          // fill borders</a>
<a name="ln1118">          if(rrmin &gt; 0)</a>
<a name="ln1119">          {</a>
<a name="ln1120">            for(int rr = 0; rr &lt; border; rr++)</a>
<a name="ln1121">              for(int cc = ccmin; cc &lt; ccmax; cc++)</a>
<a name="ln1122">              {</a>
<a name="ln1123">                int c = FC(rr, cc, filters);</a>
<a name="ln1124">                rgb[c][rr * ts + cc] = rgb[c][(border2 - rr) * ts + cc];</a>
<a name="ln1125">                rgb[1][rr * ts + cc] = rgb[1][(border2 - rr) * ts + cc];</a>
<a name="ln1126">              }</a>
<a name="ln1127">          }</a>
<a name="ln1128"> </a>
<a name="ln1129">          if(rrmax &lt; rr1)</a>
<a name="ln1130">          {</a>
<a name="ln1131">            for(int rr = 0; rr &lt; border; rr++)</a>
<a name="ln1132">              for(int cc = ccmin; cc &lt; ccmax; cc++)</a>
<a name="ln1133">              {</a>
<a name="ln1134">                int c = FC(rr, cc, filters);</a>
<a name="ln1135">                rgb[c][(rrmax + rr) * ts + cc] = (in[(height - rr - 2) * width + left + cc]);</a>
<a name="ln1136">                rgb[1][(rrmax + rr) * ts + cc] = Gtmp[(height - rr - 2) * width + left + cc];</a>
<a name="ln1137">              }</a>
<a name="ln1138">          }</a>
<a name="ln1139"> </a>
<a name="ln1140">          if(ccmin &gt; 0)</a>
<a name="ln1141">          {</a>
<a name="ln1142">            for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln1143">              for(int cc = 0; cc &lt; border; cc++)</a>
<a name="ln1144">              {</a>
<a name="ln1145">                int c = FC(rr, cc, filters);</a>
<a name="ln1146">                rgb[c][rr * ts + cc] = rgb[c][rr * ts + border2 - cc];</a>
<a name="ln1147">                rgb[1][rr * ts + cc] = rgb[1][rr * ts + border2 - cc];</a>
<a name="ln1148">              }</a>
<a name="ln1149">          }</a>
<a name="ln1150"> </a>
<a name="ln1151">          if(ccmax &lt; cc1)</a>
<a name="ln1152">          {</a>
<a name="ln1153">            for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln1154">              for(int cc = 0; cc &lt; border; cc++)</a>
<a name="ln1155">              {</a>
<a name="ln1156">                int c = FC(rr, cc, filters);</a>
<a name="ln1157">                rgb[c][rr * ts + ccmax + cc] = (in[(top + rr) * width + (width - cc - 2)]);</a>
<a name="ln1158">                rgb[1][rr * ts + ccmax + cc] = Gtmp[(top + rr) * width + (width - cc - 2)];</a>
<a name="ln1159">              }</a>
<a name="ln1160">          }</a>
<a name="ln1161"> </a>
<a name="ln1162">          // also, fill the image corners</a>
<a name="ln1163">          if(rrmin &gt; 0 &amp;&amp; ccmin &gt; 0)</a>
<a name="ln1164">          {</a>
<a name="ln1165">            for(int rr = 0; rr &lt; border; rr++)</a>
<a name="ln1166">              for(int cc = 0; cc &lt; border; cc++)</a>
<a name="ln1167">              {</a>
<a name="ln1168">                int c = FC(rr, cc, filters);</a>
<a name="ln1169">                rgb[c][(rr)*ts + cc] = (in[(border2 - rr) * width + border2 - cc]);</a>
<a name="ln1170">                rgb[1][(rr)*ts + cc] = Gtmp[(border2 - rr) * width + border2 - cc];</a>
<a name="ln1171">              }</a>
<a name="ln1172">          }</a>
<a name="ln1173"> </a>
<a name="ln1174">          if(rrmax &lt; rr1 &amp;&amp; ccmax &lt; cc1)</a>
<a name="ln1175">          {</a>
<a name="ln1176">            for(int rr = 0; rr &lt; border; rr++)</a>
<a name="ln1177">              for(int cc = 0; cc &lt; border; cc++)</a>
<a name="ln1178">              {</a>
<a name="ln1179">                int c = FC(rr, cc, filters);</a>
<a name="ln1180">                rgb[c][(rrmax + rr) * ts + ccmax + cc] = (in[(height - rr - 2) * width + (width - cc - 2)]);</a>
<a name="ln1181">                rgb[1][(rrmax + rr) * ts + ccmax + cc] = Gtmp[(height - rr - 2) * width + (width - cc - 2)];</a>
<a name="ln1182">              }</a>
<a name="ln1183">          }</a>
<a name="ln1184"> </a>
<a name="ln1185">          if(rrmin &gt; 0 &amp;&amp; ccmax &lt; cc1)</a>
<a name="ln1186">          {</a>
<a name="ln1187">            for(int rr = 0; rr &lt; border; rr++)</a>
<a name="ln1188">              for(int cc = 0; cc &lt; border; cc++)</a>
<a name="ln1189">              {</a>
<a name="ln1190">                int c = FC(rr, cc, filters);</a>
<a name="ln1191">                rgb[c][(rr)*ts + ccmax + cc] = (in[(border2 - rr) * width + (width - cc - 2)]);</a>
<a name="ln1192">                rgb[1][(rr)*ts + ccmax + cc] = Gtmp[(border2 - rr) * width + (width - cc - 2)];</a>
<a name="ln1193">              }</a>
<a name="ln1194">          }</a>
<a name="ln1195"> </a>
<a name="ln1196">          if(rrmax &lt; rr1 &amp;&amp; ccmin &gt; 0)</a>
<a name="ln1197">          {</a>
<a name="ln1198">            for(int rr = 0; rr &lt; border; rr++)</a>
<a name="ln1199">              for(int cc = 0; cc &lt; border; cc++)</a>
<a name="ln1200">              {</a>
<a name="ln1201">                int c = FC(rr, cc, filters);</a>
<a name="ln1202">                rgb[c][(rrmax + rr) * ts + cc] = (in[(height - rr - 2) * width + (border2 - cc)]);</a>
<a name="ln1203">                rgb[1][(rrmax + rr) * ts + cc] = Gtmp[(height - rr - 2) * width + (border2 - cc)];</a>
<a name="ln1204">              }</a>
<a name="ln1205">          }</a>
<a name="ln1206"> </a>
<a name="ln1207">          // end of border fill</a>
<a name="ln1208">          // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</a>
<a name="ln1209"> </a>
<a name="ln1210">          if(!autoCA)</a>
<a name="ln1211">          {</a>
<a name="ln1212">            // manual CA correction; use red/blue slider values to set CA shift parameters</a>
<a name="ln1213">            for(int rr = 3; rr &lt; rr1 - 3; rr++)</a>
<a name="ln1214">              for(int row = rr + top, cc = 3, indx = rr * ts + cc; cc &lt; cc1 - 3; cc++, indx++)</a>
<a name="ln1215">              {</a>
<a name="ln1216">                int col = cc + left;</a>
<a name="ln1217">                int c = FC(rr, cc, filters);</a>
<a name="ln1218"> </a>
<a name="ln1219">                if(c != 1)</a>
<a name="ln1220">                {</a>
<a name="ln1221">                  // compute directional weights using image gradients</a>
<a name="ln1222">                  float wtu = 1.0 / SQR(eps + fabsf(rgb[1][(rr + 1) * ts + cc] - rgb[1][(rr - 1) * ts + cc])</a>
<a name="ln1223">                                        + fabsf(rgb[c][(rr)*ts + cc] - rgb[c][(rr - 2) * ts + cc])</a>
<a name="ln1224">                                        + fabsf(rgb[1][(rr - 1) * ts + cc] - rgb[1][(rr - 3) * ts + cc]));</a>
<a name="ln1225">                  float wtd = 1.0 / SQR(eps + fabsf(rgb[1][(rr - 1) * ts + cc] - rgb[1][(rr + 1) * ts + cc])</a>
<a name="ln1226">                                        + fabsf(rgb[c][(rr)*ts + cc] - rgb[c][(rr + 2) * ts + cc])</a>
<a name="ln1227">                                        + fabsf(rgb[1][(rr + 1) * ts + cc] - rgb[1][(rr + 3) * ts + cc]));</a>
<a name="ln1228">                  float wtl = 1.0 / SQR(eps + fabsf(rgb[1][(rr)*ts + cc + 1] - rgb[1][(rr)*ts + cc - 1])</a>
<a name="ln1229">                                        + fabsf(rgb[c][(rr)*ts + cc] - rgb[c][(rr)*ts + cc - 2])</a>
<a name="ln1230">                                        + fabsf(rgb[1][(rr)*ts + cc - 1] - rgb[1][(rr)*ts + cc - 3]));</a>
<a name="ln1231">                  float wtr = 1.0 / SQR(eps + fabsf(rgb[1][(rr)*ts + cc - 1] - rgb[1][(rr)*ts + cc + 1])</a>
<a name="ln1232">                                        + fabsf(rgb[c][(rr)*ts + cc] - rgb[c][(rr)*ts + cc + 2])</a>
<a name="ln1233">                                        + fabsf(rgb[1][(rr)*ts + cc + 1] - rgb[1][(rr)*ts + cc + 3]));</a>
<a name="ln1234"> </a>
<a name="ln1235">                  // store in rgb array the interpolated G value at R/B grid points using directional weighted</a>
<a name="ln1236">                  // average</a>
<a name="ln1237">                  rgb[1][indx] = (wtu * rgb[1][indx - v1] + wtd * rgb[1][indx + v1] + wtl * rgb[1][indx - 1]</a>
<a name="ln1238">                                  + wtr * rgb[1][indx + 1])</a>
<a name="ln1239">                                 / (wtu + wtd + wtl + wtr);</a>
<a name="ln1240">                }</a>
<a name="ln1241"> </a>
<a name="ln1242">                if(row &gt; -1 &amp;&amp; row &lt; height &amp;&amp; col &gt; -1 &amp;&amp; col &lt; width)</a>
<a name="ln1243">                {</a>
<a name="ln1244">                  Gtmp[row * width + col] = rgb[1][indx];</a>
<a name="ln1245">                }</a>
<a name="ln1246">              }</a>
<a name="ln1247"> </a>
<a name="ln1248">            float hfrac = -((float)(hblock - 0.5) / (hblsz - 2) - 0.5);</a>
<a name="ln1249">            float vfrac = -((float)(vblock - 0.5) / (vblsz - 2) - 0.5) * height / width;</a>
<a name="ln1250">            lblockshifts[0][0] = 2 * vfrac * cared;</a>
<a name="ln1251">            lblockshifts[0][1] = 2 * hfrac * cared;</a>
<a name="ln1252">            lblockshifts[1][0] = 2 * vfrac * cablue;</a>
<a name="ln1253">            lblockshifts[1][1] = 2 * hfrac * cablue;</a>
<a name="ln1254">          }</a>
<a name="ln1255">          else</a>
<a name="ln1256">          {</a>
<a name="ln1257">            // CA auto correction; use CA diagnostic pass to set shift parameters</a>
<a name="ln1258">            lblockshifts[0][0] = lblockshifts[0][1] = 0;</a>
<a name="ln1259">            lblockshifts[1][0] = lblockshifts[1][1] = 0;</a>
<a name="ln1260">            double powVblock = 1.0;</a>
<a name="ln1261">            for(int i = 0; i &lt; polyord; i++)</a>
<a name="ln1262">            {</a>
<a name="ln1263">              double powHblock = powVblock;</a>
<a name="ln1264">              for(int j = 0; j &lt; polyord; j++)</a>
<a name="ln1265">              {</a>
<a name="ln1266">                // printf(&quot;i= %d j= %d polycoeff= %f \n&quot;,i,j,fitparams[0][0][polyord*i+j]);</a>
<a name="ln1267">                lblockshifts[0][0] += powHblock * fitparams[0][0][polyord * i + j];</a>
<a name="ln1268">                lblockshifts[0][1] += powHblock * fitparams[0][1][polyord * i + j];</a>
<a name="ln1269">                lblockshifts[1][0] += powHblock * fitparams[1][0][polyord * i + j];</a>
<a name="ln1270">                lblockshifts[1][1] += powHblock * fitparams[1][1][polyord * i + j];</a>
<a name="ln1271">                powHblock *= hblock;</a>
<a name="ln1272">              }</a>
<a name="ln1273">              powVblock *= vblock;</a>
<a name="ln1274">            }</a>
<a name="ln1275">            const float bslim = 3.99; // max allowed CA shift</a>
<a name="ln1276">            lblockshifts[0][0] = LIM(lblockshifts[0][0], -bslim, bslim);</a>
<a name="ln1277">            lblockshifts[0][1] = LIM(lblockshifts[0][1], -bslim, bslim);</a>
<a name="ln1278">            lblockshifts[1][0] = LIM(lblockshifts[1][0], -bslim, bslim);</a>
<a name="ln1279">            lblockshifts[1][1] = LIM(lblockshifts[1][1], -bslim, bslim);</a>
<a name="ln1280">          } // end of setting CA shift parameters</a>
<a name="ln1281"> </a>
<a name="ln1282"> </a>
<a name="ln1283">          for(int c = 0; c &lt; 3; c += 2)</a>
<a name="ln1284">          {</a>
<a name="ln1285"> </a>
<a name="ln1286">            // some parameters for the bilinear interpolation</a>
<a name="ln1287">            shiftvfloor[c] = floor((float)lblockshifts[c &gt;&gt; 1][0]);</a>
<a name="ln1288">            shiftvceil[c] = ceil((float)lblockshifts[c &gt;&gt; 1][0]);</a>
<a name="ln1289">            if (lblockshifts[c&gt;&gt;1][0] &lt; 0.f) {</a>
<a name="ln1290">              float tmp = shiftvfloor[c];</a>
<a name="ln1291">              shiftvfloor[c] = shiftvceil[c];</a>
<a name="ln1292">              shiftvceil[c] = tmp;</a>
<a name="ln1293">            }</a>
<a name="ln1294">            shiftvfrac[c] = fabsf(lblockshifts[c&gt;&gt;1][0] - shiftvfloor[c]);</a>
<a name="ln1295"> </a>
<a name="ln1296">            shifthfloor[c] = floor((float)lblockshifts[c &gt;&gt; 1][1]);</a>
<a name="ln1297">            shifthceil[c] = ceil((float)lblockshifts[c &gt;&gt; 1][1]);</a>
<a name="ln1298">            if (lblockshifts[c&gt;&gt;1][1] &lt; 0.f) {</a>
<a name="ln1299">              float tmp = shifthfloor[c];</a>
<a name="ln1300">              shifthfloor[c] = shifthceil[c];</a>
<a name="ln1301">              shifthceil[c] = tmp;</a>
<a name="ln1302">            }</a>
<a name="ln1303">            shifthfrac[c] = fabsf(lblockshifts[c&gt;&gt;1][1] - shifthfloor[c]);</a>
<a name="ln1304"> </a>
<a name="ln1305"> </a>
<a name="ln1306">            GRBdir[0][c] = lblockshifts[c &gt;&gt; 1][0] &gt; 0 ? 2 : -2;</a>
<a name="ln1307">            GRBdir[1][c] = lblockshifts[c &gt;&gt; 1][1] &gt; 0 ? 2 : -2;</a>
<a name="ln1308">          }</a>
<a name="ln1309"> </a>
<a name="ln1310"> </a>
<a name="ln1311">          for(int rr = 4; rr &lt; rr1 - 4; rr++)</a>
<a name="ln1312">          {</a>
<a name="ln1313">            int cc = 4 + (FC(rr, 2, filters) &amp; 1);</a>
<a name="ln1314">            int c = FC(rr, cc, filters);</a>
<a name="ln1315">#ifdef __SSE2__</a>
<a name="ln1316">            vfloat shifthfracv = F2V(shifthfrac[c]);</a>
<a name="ln1317">            vfloat shiftvfracv = F2V(shiftvfrac[c]);</a>
<a name="ln1318">            for(; cc &lt; cc1 - 10; cc += 8)</a>
<a name="ln1319">            {</a>
<a name="ln1320">              // perform CA correction using colour ratios or colour differences</a>
<a name="ln1321">              vfloat Ginthfloorv</a>
<a name="ln1322">                  = vintpf(shifthfracv, LC2VFU(&amp;rgb[1][(rr + shiftvfloor[c]) * ts + cc + shifthceil[c]]),</a>
<a name="ln1323">                           LC2VFU(&amp;rgb[1][(rr + shiftvfloor[c]) * ts + cc + shifthfloor[c]]));</a>
<a name="ln1324">              vfloat Ginthceilv</a>
<a name="ln1325">                  = vintpf(shifthfracv, LC2VFU(&amp;rgb[1][(rr + shiftvceil[c]) * ts + cc + shifthceil[c]]),</a>
<a name="ln1326">                           LC2VFU(&amp;rgb[1][(rr + shiftvceil[c]) * ts + cc + shifthfloor[c]]));</a>
<a name="ln1327">              // Gint is bilinear interpolation of G at CA shift point</a>
<a name="ln1328">              vfloat Gintv = vintpf(shiftvfracv, Ginthceilv, Ginthfloorv);</a>
<a name="ln1329"> </a>
<a name="ln1330">              // determine R/B at grid points using colour differences at shift point plus interpolated G</a>
<a name="ln1331">              // value at grid point</a>
<a name="ln1332">              // but first we need to interpolate G-R/G-B to grid points...</a>
<a name="ln1333">              STVFU(grbdiff[((rr)*ts + cc) &gt;&gt; 1], Gintv - LC2VFU(&amp;rgb[c][(rr)*ts + cc]));</a>
<a name="ln1334">              STVFU(gshift[((rr)*ts + cc) &gt;&gt; 1], Gintv);</a>
<a name="ln1335">            }</a>
<a name="ln1336"> </a>
<a name="ln1337">#endif</a>
<a name="ln1338">            for(; cc &lt; cc1 - 4; cc += 2)</a>
<a name="ln1339">            {</a>
<a name="ln1340">              // perform CA correction using colour ratios or colour differences</a>
<a name="ln1341">              float Ginthfloor = intp(shifthfrac[c], rgb[1][(rr + shiftvfloor[c]) * ts + cc + shifthceil[c]],</a>
<a name="ln1342">                                      rgb[1][(rr + shiftvfloor[c]) * ts + cc + shifthfloor[c]]);</a>
<a name="ln1343">              float Ginthceil = intp(shifthfrac[c], rgb[1][(rr + shiftvceil[c]) * ts + cc + shifthceil[c]],</a>
<a name="ln1344">                                     rgb[1][(rr + shiftvceil[c]) * ts + cc + shifthfloor[c]]);</a>
<a name="ln1345">              // Gint is bilinear interpolation of G at CA shift point</a>
<a name="ln1346">              float Gint = intp(shiftvfrac[c], Ginthceil, Ginthfloor);</a>
<a name="ln1347"> </a>
<a name="ln1348">              // determine R/B at grid points using colour differences at shift point plus interpolated G</a>
<a name="ln1349">              // value at grid point</a>
<a name="ln1350">              // but first we need to interpolate G-R/G-B to grid points...</a>
<a name="ln1351">              grbdiff[((rr)*ts + cc) &gt;&gt; 1] = Gint - rgb[c][(rr)*ts + cc];</a>
<a name="ln1352">              gshift[((rr)*ts + cc) &gt;&gt; 1] = Gint;</a>
<a name="ln1353">            }</a>
<a name="ln1354">          }</a>
<a name="ln1355"> </a>
<a name="ln1356">          shifthfrac[0] /= 2.f;</a>
<a name="ln1357">          shifthfrac[2] /= 2.f;</a>
<a name="ln1358">          shiftvfrac[0] /= 2.f;</a>
<a name="ln1359">          shiftvfrac[2] /= 2.f;</a>
<a name="ln1360"> </a>
<a name="ln1361">          // this loop does not deserve vectorization in mainly because the most expensive part with the</a>
<a name="ln1362">          // divisions does not happen often (less than 1/10 in my tests)</a>
<a name="ln1363">          for(int rr = 8; rr &lt; rr1 - 8; rr++)</a>
<a name="ln1364">            for(int cc = 8 + (FC(rr, 2, filters) &amp; 1), c = FC(rr, cc, filters), indx = rr * ts + cc;</a>
<a name="ln1365">                cc &lt; cc1 - 8; cc += 2, indx += 2)</a>
<a name="ln1366">            {</a>
<a name="ln1367"> </a>
<a name="ln1368">              float grbdiffold = rgb[1][indx] - rgb[c][indx];</a>
<a name="ln1369"> </a>
<a name="ln1370">              // interpolate colour difference from optical R/B locations to grid locations</a>
<a name="ln1371">              float grbdiffinthfloor</a>
<a name="ln1372">                  = intp(shifthfrac[c], grbdiff[(indx - GRBdir[1][c]) &gt;&gt; 1], grbdiff[indx &gt;&gt; 1]);</a>
<a name="ln1373">              float grbdiffinthceil</a>
<a name="ln1374">                  = intp(shifthfrac[c], grbdiff[((rr - GRBdir[0][c]) * ts + cc - GRBdir[1][c]) &gt;&gt; 1],</a>
<a name="ln1375">                         grbdiff[((rr - GRBdir[0][c]) * ts + cc) &gt;&gt; 1]);</a>
<a name="ln1376">              // grbdiffint is bilinear interpolation of G-R/G-B at grid point</a>
<a name="ln1377">              float grbdiffint = intp(shiftvfrac[c], grbdiffinthceil, grbdiffinthfloor);</a>
<a name="ln1378"> </a>
<a name="ln1379">              // now determine R/B at grid points using interpolated colour differences and interpolated G</a>
<a name="ln1380">              // value at grid point</a>
<a name="ln1381">              float RBint = rgb[1][indx] - grbdiffint;</a>
<a name="ln1382"> </a>
<a name="ln1383">              if(fabsf(RBint - rgb[c][indx]) &lt; 0.25f * (RBint + rgb[c][indx]))</a>
<a name="ln1384">              {</a>
<a name="ln1385">                if(fabsf(grbdiffold) &gt; fabsf(grbdiffint))</a>
<a name="ln1386">                {</a>
<a name="ln1387">                  rgb[c][indx] = RBint;</a>
<a name="ln1388">                }</a>
<a name="ln1389">              }</a>
<a name="ln1390">              else</a>
<a name="ln1391">              {</a>
<a name="ln1392"> </a>
<a name="ln1393">                // gradient weights using difference from G at CA shift points and G at grid points</a>
<a name="ln1394">                float p0 = 1.0f / (eps + fabsf(rgb[1][indx] - gshift[indx &gt;&gt; 1]));</a>
<a name="ln1395">                float p1 = 1.0f / (eps + fabsf(rgb[1][indx] - gshift[(indx - GRBdir[1][c]) &gt;&gt; 1]));</a>
<a name="ln1396">                float p2 = 1.0f / (eps + fabsf(rgb[1][indx] - gshift[((rr - GRBdir[0][c]) * ts + cc) &gt;&gt; 1]));</a>
<a name="ln1397">                float p3</a>
<a name="ln1398">                    = 1.0f / (eps + fabsf(rgb[1][indx]</a>
<a name="ln1399">                                          - gshift[((rr - GRBdir[0][c]) * ts + cc - GRBdir[1][c]) &gt;&gt; 1]));</a>
<a name="ln1400"> </a>
<a name="ln1401">                grbdiffint = (p0 * grbdiff[indx &gt;&gt; 1] + p1 * grbdiff[(indx - GRBdir[1][c]) &gt;&gt; 1]</a>
<a name="ln1402">                              + p2 * grbdiff[((rr - GRBdir[0][c]) * ts + cc) &gt;&gt; 1]</a>
<a name="ln1403">                              + p3 * grbdiff[((rr - GRBdir[0][c]) * ts + cc - GRBdir[1][c]) &gt;&gt; 1])</a>
<a name="ln1404">                             / (p0 + p1 + p2 + p3);</a>
<a name="ln1405"> </a>
<a name="ln1406">                // now determine R/B at grid points using interpolated colour differences and interpolated G</a>
<a name="ln1407">                // value at grid point</a>
<a name="ln1408">                if(fabsf(grbdiffold) &gt; fabsf(grbdiffint))</a>
<a name="ln1409">                {</a>
<a name="ln1410">                  rgb[c][indx] = rgb[1][indx] - grbdiffint;</a>
<a name="ln1411">                }</a>
<a name="ln1412">              }</a>
<a name="ln1413"> </a>
<a name="ln1414">              // if colour difference interpolation overshot the correction, just desaturate</a>
<a name="ln1415">              if(grbdiffold * grbdiffint &lt; 0)</a>
<a name="ln1416">              {</a>
<a name="ln1417">                rgb[c][indx] = rgb[1][indx] - 0.5f * (grbdiffold + grbdiffint);</a>
<a name="ln1418">              }</a>
<a name="ln1419">            }</a>
<a name="ln1420"> </a>
<a name="ln1421">          // copy CA corrected results to temporary image matrix</a>
<a name="ln1422">          for(int rr = border; rr &lt; rr1 - border; rr++)</a>
<a name="ln1423">          {</a>
<a name="ln1424">            int c = FC(rr + top, left + border + (FC(rr + top, 2, filters) &amp; 1), filters);</a>
<a name="ln1425"> </a>
<a name="ln1426">            for(int row = rr + top, cc = border + (FC(rr, 2, filters) &amp; 1),</a>
<a name="ln1427">                    indx = (row * width + cc + left) &gt;&gt; 1;</a>
<a name="ln1428">                cc &lt; cc1 - border; cc += 2, indx++)</a>
<a name="ln1429">            {</a>
<a name="ln1430">              //               int col = cc + left;</a>
<a name="ln1431">              RawDataTmp[indx] = rgb[c][(rr)*ts + cc];</a>
<a name="ln1432">            }</a>
<a name="ln1433">          }</a>
<a name="ln1434"> </a>
<a name="ln1435">          //           if(plistener)</a>
<a name="ln1436">          //           {</a>
<a name="ln1437">          //             progresscounter++;</a>
<a name="ln1438">          //</a>
<a name="ln1439">          //             if(progresscounter % 8 == 0)</a>
<a name="ln1440">          // #pragma omp critical(cacorrect)</a>
<a name="ln1441">          //             {</a>
<a name="ln1442">          //               progress += (double)(8.0 * (ts - border2) * (ts - border2)) / (2 * height * width);</a>
<a name="ln1443">          //</a>
<a name="ln1444">          //               if(progress &gt; 1.0)</a>
<a name="ln1445">          //               {</a>
<a name="ln1446">          //                 progress = 1.0;</a>
<a name="ln1447">          //               }</a>
<a name="ln1448">          //</a>
<a name="ln1449">          //               plistener-&gt;setProgress(progress);</a>
<a name="ln1450">          //             }</a>
<a name="ln1451">          //           }</a>
<a name="ln1452">        }</a>
<a name="ln1453"> </a>
<a name="ln1454">#ifdef _OPENMP</a>
<a name="ln1455">#pragma omp barrier</a>
<a name="ln1456">#endif</a>
<a name="ln1457">// copy temporary image matrix back to image matrix</a>
<a name="ln1458">#ifdef _OPENMP</a>
<a name="ln1459">#pragma omp for</a>
<a name="ln1460">#endif</a>
<a name="ln1461"> </a>
<a name="ln1462">      for(int row = 0; row &lt; height; row++)</a>
<a name="ln1463">        for(int col = 0 + (FC(row, 0, filters) &amp; 1), indx = (row * width + col) &gt;&gt; 1; col &lt; width;</a>
<a name="ln1464">            col += 2, indx++)</a>
<a name="ln1465">        {</a>
<a name="ln1466">          out[row * width + col] = RawDataTmp[indx];</a>
<a name="ln1467">        }</a>
<a name="ln1468">    }</a>
<a name="ln1469"> </a>
<a name="ln1470">    // clean up</a>
<a name="ln1471">    free(buffer);</a>
<a name="ln1472">  }</a>
<a name="ln1473"> </a>
<a name="ln1474">  free(Gtmp);</a>
<a name="ln1475">  free(buffer1);</a>
<a name="ln1476">  free(RawDataTmp);</a>
<a name="ln1477"> </a>
<a name="ln1478">  //   if(plistener)</a>
<a name="ln1479">  //   {</a>
<a name="ln1480">  //     plistener-&gt;setProgress(1.0);</a>
<a name="ln1481">  //   }</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">/*==================================================================================</a>
<a name="ln1485"> * end raw therapee code</a>
<a name="ln1486"> *==================================================================================*/</a>
<a name="ln1487"> </a>
<a name="ln1488"> </a>
<a name="ln1489">/** process, all real work is done here. */</a>
<a name="ln1490">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o,</a>
<a name="ln1491">             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln1492">{</a>
<a name="ln1493">  CA_correct(self, piece, (float *)i, (float *)o, roi_in, roi_out);</a>
<a name="ln1494">}</a>
<a name="ln1495"> </a>
<a name="ln1496">void reload_defaults(dt_iop_module_t *module)</a>
<a name="ln1497">{</a>
<a name="ln1498">  // init defaults:</a>
<a name="ln1499">  dt_iop_cacorrect_params_t tmp = (dt_iop_cacorrect_params_t){.keep = 50 };</a>
<a name="ln1500"> </a>
<a name="ln1501">  // we might be called from presets update infrastructure =&gt; there is no image</a>
<a name="ln1502">  if(!module-&gt;dev) goto end;</a>
<a name="ln1503"> </a>
<a name="ln1504">  dt_image_t *img = &amp;module-&gt;dev-&gt;image_storage;</a>
<a name="ln1505">  // can't be switched on for non-raw or x-trans images:</a>
<a name="ln1506">  if(dt_image_is_raw(img) &amp;&amp; (img-&gt;buf_dsc.filters != 9u) &amp;&amp; !dt_image_is_monochrome(img))</a>
<a name="ln1507">    module-&gt;hide_enable_button = 0;</a>
<a name="ln1508">  else</a>
<a name="ln1509">    module-&gt;hide_enable_button = 1;</a>
<a name="ln1510">  module-&gt;default_enabled = 0;</a>
<a name="ln1511"> </a>
<a name="ln1512">end:</a>
<a name="ln1513">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_cacorrect_params_t));</a>
<a name="ln1514">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_cacorrect_params_t));</a>
<a name="ln1515">}</a>
<a name="ln1516"> </a>
<a name="ln1517">/** init, cleanup, commit to pipeline */</a>
<a name="ln1518">void init(dt_iop_module_t *module)</a>
<a name="ln1519">{</a>
<a name="ln1520">  // we don't need global data:</a>
<a name="ln1521">  module-&gt;data = NULL; // malloc(sizeof(dt_iop_cacorrect_global_data_t));</a>
<a name="ln1522">  module-&gt;params = calloc(1, sizeof(dt_iop_cacorrect_params_t));</a>
<a name="ln1523">  module-&gt;default_params = calloc(1, sizeof(dt_iop_cacorrect_params_t));</a>
<a name="ln1524">  // our module is disabled by default</a>
<a name="ln1525">  // by default:</a>
<a name="ln1526">  module-&gt;default_enabled = 0;</a>
<a name="ln1527"> </a>
<a name="ln1528">  // we come just before demosaicing.</a>
<a name="ln1529">  module-&gt;params_size = sizeof(dt_iop_cacorrect_params_t);</a>
<a name="ln1530">  module-&gt;gui_data = NULL;</a>
<a name="ln1531">}</a>
<a name="ln1532"> </a>
<a name="ln1533">void cleanup(dt_iop_module_t *module)</a>
<a name="ln1534">{</a>
<a name="ln1535">  free(module-&gt;params);</a>
<a name="ln1536">  module-&gt;params = NULL;</a>
<a name="ln1537">  free(module-&gt;data); // just to be sure</a>
<a name="ln1538">  module-&gt;data = NULL;</a>
<a name="ln1539">}</a>
<a name="ln1540"> </a>
<a name="ln1541">/** commit is the synch point between core and gui, so it copies params to pipe data. */</a>
<a name="ln1542">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *params, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln1543">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1544">{</a>
<a name="ln1545">  dt_image_t *img = &amp;pipe-&gt;image;</a>
<a name="ln1546">  if(!(img-&gt;flags &amp; DT_IMAGE_RAW) || dt_image_is_monochrome(img)) piece-&gt;enabled = 0;</a>
<a name="ln1547">}</a>
<a name="ln1548"> </a>
<a name="ln1549">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1550">{</a>
<a name="ln1551">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln1552">}</a>
<a name="ln1553"> </a>
<a name="ln1554">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1555">{</a>
<a name="ln1556">  piece-&gt;data = NULL;</a>
<a name="ln1557">}</a>
<a name="ln1558"> </a>
<a name="ln1559">void gui_update(dt_iop_module_t *self)</a>
<a name="ln1560">{</a>
<a name="ln1561">  if(dt_image_is_raw(&amp;self-&gt;dev-&gt;image_storage))</a>
<a name="ln1562">    if(self-&gt;dev-&gt;image_storage.buf_dsc.filters != 9u &amp;&amp; !dt_image_is_monochrome(&amp;self-&gt;dev-&gt;image_storage))</a>
<a name="ln1563">      gtk_label_set_text(GTK_LABEL(self-&gt;widget), _(&quot;automatic chromatic aberration correction&quot;));</a>
<a name="ln1564">    else</a>
<a name="ln1565">      gtk_label_set_text(GTK_LABEL(self-&gt;widget),</a>
<a name="ln1566">                         _(&quot;automatic chromatic aberration correction\ndisabled for non-Bayer sensors&quot;));</a>
<a name="ln1567">  else</a>
<a name="ln1568">    gtk_label_set_text(GTK_LABEL(self-&gt;widget),</a>
<a name="ln1569">                       _(&quot;automatic chromatic aberration correction\nonly works for raw images.&quot;));</a>
<a name="ln1570">}</a>
<a name="ln1571"> </a>
<a name="ln1572">void gui_init(dt_iop_module_t *self)</a>
<a name="ln1573">{</a>
<a name="ln1574">  self-&gt;widget = gtk_label_new(&quot;&quot;);</a>
<a name="ln1575">  gtk_widget_set_halign(self-&gt;widget, GTK_ALIGN_START);</a>
<a name="ln1576">  self-&gt;gui_data = &amp;dummy;</a>
<a name="ln1577">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln1578">}</a>
<a name="ln1579"> </a>
<a name="ln1580">void gui_cleanup(dt_iop_module_t *self)</a>
<a name="ln1581">{</a>
<a name="ln1582">  self-&gt;gui_data = NULL;</a>
<a name="ln1583">}</a>
<a name="ln1584"> </a>
<a name="ln1585">/** additional, optional callbacks to capture darkroom center events. */</a>
<a name="ln1586">// void gui_post_expose(dt_iop_module_t *self, cairo_t *cr, int32_t width, int32_t height, int32_t pointerx,</a>
<a name="ln1587">// int32_t pointery);</a>
<a name="ln1588">// int mouse_moved(dt_iop_module_t *self, double x, double y, double pressure, int which);</a>
<a name="ln1589">// int button_pressed(dt_iop_module_t *self, double x, double y, double pressure, int which, int type,</a>
<a name="ln1590">// uint32_t state);</a>
<a name="ln1591"> </a>
<a name="ln1592">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1593">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1594">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="362"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'buffer1' pointer in the expression could be nullptr. In such case, resulting value of arithmetic operations on this pointer will be senseless and it should not be used. Check lines: 362, 358.</p></div>
<div class="balloon" rel="434"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memset' function. Inspect the first argument. Check lines: 434, 395.</p></div>
<div class="balloon" rel="611"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'Gtmp'. Check lines: 611, 339.</p></div>
<div class="balloon" rel="825"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'blockwt'. Check lines: 825, 358.</p></div>
<div class="balloon" rel="1431"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'RawDataTmp'. Check lines: 1431, 342.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
