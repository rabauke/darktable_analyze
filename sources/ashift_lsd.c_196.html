
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  This file is part of darktable,</a>
<a name="ln3">  copyright (c) 2016 Ulrich Pegelow.</a>
<a name="ln4"> </a>
<a name="ln5">  darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">  GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19"> </a>
<a name="ln20">/* For line detection we are using the LSD code as published below.</a>
<a name="ln21"> * Changes versus the original code:</a>
<a name="ln22"> *      do not include &quot;lsd.h&quot; (not needed)</a>
<a name="ln23"> *      make all interface functions static</a>
<a name="ln24"> *      comment out unused interface functions</a>
<a name="ln25"> *      catch (unlikely) division by zero near line 2035</a>
<a name="ln26"> *      rename rad1 and rad2 to radius1 and radius2 in reduce_region_radius()</a>
<a name="ln27"> *        to avoid naming conflict in windows build</a>
<a name="ln28"> *</a>
<a name="ln29"> */</a>
<a name="ln30"> </a>
<a name="ln31">/* TODO: LSD employs intensive sanity checks of input data and allocation</a>
<a name="ln32"> * results. In case of errors it will terminate the program. On the one side</a>
<a name="ln33"> * this is not optimal for a module within darktable - it should better</a>
<a name="ln34"> * report errors upstream where they should be handled properly. On the other</a>
<a name="ln35"> * hand the kind of error which could be triggered in LSD would make it very unlikely</a>
<a name="ln36"> * that the darktable process could survive anyhow.</a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39">// clang-format off</a>
<a name="ln40"> </a>
<a name="ln41">/*==================================================================================</a>
<a name="ln42"> * begin LSD code version 1.6. downloaded on January 30, 2016</a>
<a name="ln43"> *==================================================================================*/</a>
<a name="ln44"> </a>
<a name="ln45">/*----------------------------------------------------------------------------</a>
<a name="ln46"> </a>
<a name="ln47">  LSD - Line Segment Detector on digital images</a>
<a name="ln48"> </a>
<a name="ln49">  This code is part of the following publication and was subject</a>
<a name="ln50">  to peer review:</a>
<a name="ln51"> </a>
<a name="ln52">    &quot;LSD: a Line Segment Detector&quot; by Rafael Grompone von Gioi,</a>
<a name="ln53">    Jeremie Jakubowicz, Jean-Michel Morel, and Gregory Randall,</a>
<a name="ln54">    Image Processing On Line, 2012. DOI:10.5201/ipol.2012.gjmr-lsd</a>
<a name="ln55">    http://dx.doi.org/10.5201/ipol.2012.gjmr-lsd</a>
<a name="ln56"> </a>
<a name="ln57">  Copyright (c) 2007-2011 rafael grompone von gioi &lt;grompone@gmail.com&gt;</a>
<a name="ln58"> </a>
<a name="ln59">  This program is free software: you can redistribute it and/or modify</a>
<a name="ln60">  it under the terms of the GNU Affero General Public License as</a>
<a name="ln61">  published by the Free Software Foundation, either version 3 of the</a>
<a name="ln62">  License, or (at your option) any later version.</a>
<a name="ln63"> </a>
<a name="ln64">  This program is distributed in the hope that it will be useful,</a>
<a name="ln65">  but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln66">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</a>
<a name="ln67">  GNU Affero General Public License for more details.</a>
<a name="ln68"> </a>
<a name="ln69">  You should have received a copy of the GNU Affero General Public License</a>
<a name="ln70">  along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln71"> </a>
<a name="ln72">  ----------------------------------------------------------------------------*/</a>
<a name="ln73"> </a>
<a name="ln74">/*----------------------------------------------------------------------------*/</a>
<a name="ln75">/** @file lsd.c</a>
<a name="ln76">    LSD module code</a>
<a name="ln77">    @author rafael grompone von gioi &lt;grompone@gmail.com&gt;</a>
<a name="ln78"> */</a>
<a name="ln79">/*----------------------------------------------------------------------------*/</a>
<a name="ln80"> </a>
<a name="ln81">/*----------------------------------------------------------------------------*/</a>
<a name="ln82">/** @mainpage LSD code documentation</a>
<a name="ln83"> </a>
<a name="ln84">    This is an implementation of the Line Segment Detector described</a>
<a name="ln85">    in the paper:</a>
<a name="ln86"> </a>
<a name="ln87">      &quot;LSD: A Fast Line Segment Detector with a False Detection Control&quot;</a>
<a name="ln88">      by Rafael Grompone von Gioi, Jeremie Jakubowicz, Jean-Michel Morel,</a>
<a name="ln89">      and Gregory Randall, IEEE Transactions on Pattern Analysis and</a>
<a name="ln90">      Machine Intelligence, vol. 32, no. 4, pp. 722-732, April, 2010.</a>
<a name="ln91"> </a>
<a name="ln92">    and in more details in the CMLA Technical Report:</a>
<a name="ln93"> </a>
<a name="ln94">      &quot;LSD: A Line Segment Detector, Technical Report&quot;,</a>
<a name="ln95">      by Rafael Grompone von Gioi, Jeremie Jakubowicz, Jean-Michel Morel,</a>
<a name="ln96">      Gregory Randall, CMLA, ENS Cachan, 2010.</a>
<a name="ln97"> </a>
<a name="ln98">    The version implemented here includes some further improvements</a>
<a name="ln99">    described in the following publication, of which this code is part:</a>
<a name="ln100"> </a>
<a name="ln101">      &quot;LSD: a Line Segment Detector&quot; by Rafael Grompone von Gioi,</a>
<a name="ln102">      Jeremie Jakubowicz, Jean-Michel Morel, and Gregory Randall,</a>
<a name="ln103">      Image Processing On Line, 2012. DOI:10.5201/ipol.2012.gjmr-lsd</a>
<a name="ln104">      http://dx.doi.org/10.5201/ipol.2012.gjmr-lsd</a>
<a name="ln105"> </a>
<a name="ln106">    The module's main function is lsd().</a>
<a name="ln107"> </a>
<a name="ln108">    The source code is contained in two files: lsd.h and lsd.c.</a>
<a name="ln109"> </a>
<a name="ln110">    HISTORY:</a>
<a name="ln111">    - version 1.6 - nov 2011:</a>
<a name="ln112">                              - changes in the interface,</a>
<a name="ln113">                              - max_grad parameter removed,</a>
<a name="ln114">                              - the factor 11 was added to the number of test</a>
<a name="ln115">                                to consider the different precision values</a>
<a name="ln116">                                tested,</a>
<a name="ln117">                              - a minor bug corrected in the gradient sorting</a>
<a name="ln118">                                code,</a>
<a name="ln119">                              - the algorithm now also returns p and log_nfa</a>
<a name="ln120">                                for each detection,</a>
<a name="ln121">                              - a minor bug was corrected in the image scaling,</a>
<a name="ln122">                              - the angle comparison in &quot;isaligned&quot; changed</a>
<a name="ln123">                                from &lt; to &lt;=,</a>
<a name="ln124">                              - &quot;eps&quot; variable renamed &quot;log_eps&quot;,</a>
<a name="ln125">                              - &quot;lsd_scale_region&quot; interface was added,</a>
<a name="ln126">                              - minor changes to comments.</a>
<a name="ln127">    - version 1.5 - dec 2010: Changes in 'refine', -W option added,</a>
<a name="ln128">                              and more comments added.</a>
<a name="ln129">    - version 1.4 - jul 2010: lsd_scale interface added and doxygen doc.</a>
<a name="ln130">    - version 1.3 - feb 2010: Multiple bug correction and improved code.</a>
<a name="ln131">    - version 1.2 - dec 2009: First full Ansi C Language version.</a>
<a name="ln132">    - version 1.1 - sep 2009: Systematic subsampling to scale 0.8 and</a>
<a name="ln133">                              correction to partially handle &quot;angle problem&quot;.</a>
<a name="ln134">    - version 1.0 - jan 2009: First complete Megawave2 and Ansi C Language</a>
<a name="ln135">                              version.</a>
<a name="ln136"> </a>
<a name="ln137">    @author rafael grompone von gioi &lt;grompone@gmail.com&gt;</a>
<a name="ln138"> */</a>
<a name="ln139">/*----------------------------------------------------------------------------*/</a>
<a name="ln140"> </a>
<a name="ln141">#include &lt;stdio.h&gt;</a>
<a name="ln142">#include &lt;stdlib.h&gt;</a>
<a name="ln143">#include &lt;math.h&gt;</a>
<a name="ln144">#include &lt;limits.h&gt;</a>
<a name="ln145">#include &lt;float.h&gt;</a>
<a name="ln146">//#include &quot;lsd.h&quot;</a>
<a name="ln147"> </a>
<a name="ln148">/** ln(10) */</a>
<a name="ln149">#ifndef M_LN10</a>
<a name="ln150">#define M_LN10 2.30258509299404568402</a>
<a name="ln151">#endif /* !M_LN10 */</a>
<a name="ln152"> </a>
<a name="ln153">/** PI */</a>
<a name="ln154">#ifndef M_PI</a>
<a name="ln155">#define M_PI   3.14159265358979323846</a>
<a name="ln156">#endif /* !M_PI */</a>
<a name="ln157"> </a>
<a name="ln158">#ifndef FALSE</a>
<a name="ln159">#define FALSE 0</a>
<a name="ln160">#endif /* !FALSE */</a>
<a name="ln161"> </a>
<a name="ln162">#ifndef TRUE</a>
<a name="ln163">#define TRUE 1</a>
<a name="ln164">#endif /* !TRUE */</a>
<a name="ln165"> </a>
<a name="ln166">/** Label for pixels with undefined gradient. */</a>
<a name="ln167">#define NOTDEF -1024.0</a>
<a name="ln168"> </a>
<a name="ln169">/** 3/2 pi */</a>
<a name="ln170">#define M_3_2_PI 4.71238898038</a>
<a name="ln171"> </a>
<a name="ln172">/** 2 pi */</a>
<a name="ln173">#define M_2__PI  6.28318530718</a>
<a name="ln174"> </a>
<a name="ln175">/** Label for pixels not used in yet. */</a>
<a name="ln176">#define NOTUSED 0</a>
<a name="ln177"> </a>
<a name="ln178">/** Label for pixels already used in detection. */</a>
<a name="ln179">#define USED    1</a>
<a name="ln180"> </a>
<a name="ln181">/*----------------------------------------------------------------------------*/</a>
<a name="ln182">/** Chained list of coordinates.</a>
<a name="ln183"> */</a>
<a name="ln184">struct coorlist</a>
<a name="ln185">{</a>
<a name="ln186">  int x,y;</a>
<a name="ln187">  struct coorlist * next;</a>
<a name="ln188">};</a>
<a name="ln189"> </a>
<a name="ln190">/*----------------------------------------------------------------------------*/</a>
<a name="ln191">/** A point (or pixel).</a>
<a name="ln192"> */</a>
<a name="ln193">struct point {int x,y;};</a>
<a name="ln194"> </a>
<a name="ln195"> </a>
<a name="ln196">/*----------------------------------------------------------------------------*/</a>
<a name="ln197">/*------------------------- Miscellaneous functions --------------------------*/</a>
<a name="ln198">/*----------------------------------------------------------------------------*/</a>
<a name="ln199"> </a>
<a name="ln200">/*----------------------------------------------------------------------------*/</a>
<a name="ln201">/** Fatal error, print a message to standard-error output and exit.</a>
<a name="ln202"> */</a>
<a name="ln203">static void error(char * msg)</a>
<a name="ln204">{</a>
<a name="ln205">  fprintf(stderr,&quot;LSD Error: %s\n&quot;,msg);</a>
<a name="ln206">  exit(EXIT_FAILURE);</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">/*----------------------------------------------------------------------------*/</a>
<a name="ln210">/** Doubles relative error factor</a>
<a name="ln211"> */</a>
<a name="ln212">#define RELATIVE_ERROR_FACTOR 100.0</a>
<a name="ln213"> </a>
<a name="ln214">/*----------------------------------------------------------------------------*/</a>
<a name="ln215">/** Compare doubles by relative error.</a>
<a name="ln216"> </a>
<a name="ln217">    The resulting rounding error after floating point computations</a>
<a name="ln218">    depend on the specific operations done. The same number computed by</a>
<a name="ln219">    different algorithms could present different rounding errors. For a</a>
<a name="ln220">    useful comparison, an estimation of the relative rounding error</a>
<a name="ln221">    should be considered and compared to a factor times EPS. The factor</a>
<a name="ln222">    should be related to the cumulated rounding error in the chain of</a>
<a name="ln223">    computation. Here, as a simplification, a fixed factor is used.</a>
<a name="ln224"> */</a>
<a name="ln225">static int double_equal(double a, double b)</a>
<a name="ln226">{</a>
<a name="ln227">  double abs_diff,aa,bb,abs_max;</a>
<a name="ln228"> </a>
<a name="ln229">  /* trivial case */</a>
<a name="ln230">  if( a == b ) return TRUE;</a>
<a name="ln231"> </a>
<a name="ln232">  abs_diff = fabs(a-b);</a>
<a name="ln233">  aa = fabs(a);</a>
<a name="ln234">  bb = fabs(b);</a>
<a name="ln235">  abs_max = aa &gt; bb ? aa : bb;</a>
<a name="ln236"> </a>
<a name="ln237">  /* DBL_MIN is the smallest normalized number, thus, the smallest</a>
<a name="ln238">     number whose relative error is bounded by DBL_EPSILON. For</a>
<a name="ln239">     smaller numbers, the same quantization steps as for DBL_MIN</a>
<a name="ln240">     are used. Then, for smaller numbers, a meaningful &quot;relative&quot;</a>
<a name="ln241">     error should be computed by dividing the difference by DBL_MIN. */</a>
<a name="ln242">  if( abs_max &lt; DBL_MIN ) abs_max = DBL_MIN;</a>
<a name="ln243"> </a>
<a name="ln244">  /* equal if relative error &lt;= factor x eps */</a>
<a name="ln245">  return (abs_diff / abs_max) &lt;= (RELATIVE_ERROR_FACTOR * DBL_EPSILON);</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">/*----------------------------------------------------------------------------*/</a>
<a name="ln249">/** Computes Euclidean distance between point (x1,y1) and point (x2,y2).</a>
<a name="ln250"> */</a>
<a name="ln251">static double dist(double x1, double y1, double x2, double y2)</a>
<a name="ln252">{</a>
<a name="ln253">  return sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256"> </a>
<a name="ln257">/*----------------------------------------------------------------------------*/</a>
<a name="ln258">/*----------------------- 'list of n-tuple' data type ------------------------*/</a>
<a name="ln259">/*----------------------------------------------------------------------------*/</a>
<a name="ln260"> </a>
<a name="ln261">/*----------------------------------------------------------------------------*/</a>
<a name="ln262">/** 'list of n-tuple' data type</a>
<a name="ln263"> </a>
<a name="ln264">    The i-th component of the j-th n-tuple of an n-tuple list 'ntl'</a>
<a name="ln265">    is accessed with:</a>
<a name="ln266"> </a>
<a name="ln267">      ntl-&gt;values[ i + j * ntl-&gt;dim ]</a>
<a name="ln268"> </a>
<a name="ln269">    The dimension of the n-tuple (n) is:</a>
<a name="ln270"> </a>
<a name="ln271">      ntl-&gt;dim</a>
<a name="ln272"> </a>
<a name="ln273">    The number of n-tuples in the list is:</a>
<a name="ln274"> </a>
<a name="ln275">      ntl-&gt;size</a>
<a name="ln276"> </a>
<a name="ln277">    The maximum number of n-tuples that can be stored in the</a>
<a name="ln278">    list with the allocated memory at a given time is given by:</a>
<a name="ln279"> </a>
<a name="ln280">      ntl-&gt;max_size</a>
<a name="ln281"> */</a>
<a name="ln282">typedef struct ntuple_list_s</a>
<a name="ln283">{</a>
<a name="ln284">  unsigned int size;</a>
<a name="ln285">  unsigned int max_size;</a>
<a name="ln286">  unsigned int dim;</a>
<a name="ln287">  double * values;</a>
<a name="ln288">} * ntuple_list;</a>
<a name="ln289"> </a>
<a name="ln290">/*----------------------------------------------------------------------------*/</a>
<a name="ln291">/** Free memory used in n-tuple 'in'.</a>
<a name="ln292"> */</a>
<a name="ln293">static void free_ntuple_list(ntuple_list in)</a>
<a name="ln294">{</a>
<a name="ln295">  if( in == NULL || in-&gt;values == NULL )</a>
<a name="ln296">    error(&quot;free_ntuple_list: invalid n-tuple input.&quot;);</a>
<a name="ln297">  free( (void *) in-&gt;values );</a>
<a name="ln298">  free( (void *) in );</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">/*----------------------------------------------------------------------------*/</a>
<a name="ln302">/** Create an n-tuple list and allocate memory for one element.</a>
<a name="ln303">    @param dim the dimension (n) of the n-tuple.</a>
<a name="ln304"> */</a>
<a name="ln305">static ntuple_list new_ntuple_list(unsigned int dim)</a>
<a name="ln306">{</a>
<a name="ln307">  ntuple_list n_tuple;</a>
<a name="ln308"> </a>
<a name="ln309">  /* check parameters */</a>
<a name="ln310">  if( dim == 0 ) error(&quot;new_ntuple_list: 'dim' must be positive.&quot;);</a>
<a name="ln311"> </a>
<a name="ln312">  /* get memory for list structure */</a>
<a name="ln313">  n_tuple = (ntuple_list) malloc( sizeof(struct ntuple_list_s) );</a>
<a name="ln314">  if( n_tuple == NULL ) error(&quot;not enough memory.&quot;);</a>
<a name="ln315"> </a>
<a name="ln316">  /* initialize list */</a>
<a name="ln317">  n_tuple-&gt;size = 0;</a>
<a name="ln318">  n_tuple-&gt;max_size = 1;</a>
<a name="ln319">  n_tuple-&gt;dim = dim;</a>
<a name="ln320"> </a>
<a name="ln321">  /* get memory for tuples */</a>
<a name="ln322">  n_tuple-&gt;values = (double *) malloc( dim*n_tuple-&gt;max_size * sizeof(double) );</a>
<a name="ln323">  if( n_tuple-&gt;values == NULL ) error(&quot;not enough memory.&quot;);</a>
<a name="ln324"> </a>
<a name="ln325">  return n_tuple;</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">/*----------------------------------------------------------------------------*/</a>
<a name="ln329">/** Enlarge the allocated memory of an n-tuple list.</a>
<a name="ln330"> */</a>
<a name="ln331">static void enlarge_ntuple_list(ntuple_list n_tuple)</a>
<a name="ln332">{</a>
<a name="ln333">  /* check parameters */</a>
<a name="ln334">  if( n_tuple == NULL || n_tuple-&gt;values == NULL || n_tuple-&gt;max_size == 0 )</a>
<a name="ln335">    error(&quot;enlarge_ntuple_list: invalid n-tuple.&quot;);</a>
<a name="ln336"> </a>
<a name="ln337">  /* duplicate number of tuples */</a>
<a name="ln338">  n_tuple-&gt;max_size *= 2;</a>
<a name="ln339"> </a>
<a name="ln340">  /* realloc memory */</a>
<a name="ln341">  n_tuple-&gt;values = (double *) realloc( (void *) n_tuple-&gt;values,</a>
<a name="ln342">                      n_tuple-&gt;dim * n_tuple-&gt;max_size * sizeof(double) );</a>
<a name="ln343">  if( n_tuple-&gt;values == NULL ) error(&quot;not enough memory.&quot;);</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">/*----------------------------------------------------------------------------*/</a>
<a name="ln347">/** Add a 7-tuple to an n-tuple list.</a>
<a name="ln348"> */</a>
<a name="ln349">static void add_7tuple( ntuple_list out, double v1, double v2, double v3,</a>
<a name="ln350">                        double v4, double v5, double v6, double v7 )</a>
<a name="ln351">{</a>
<a name="ln352">  /* check parameters */</a>
<a name="ln353">  if( out == NULL ) error(&quot;add_7tuple: invalid n-tuple input.&quot;);</a>
<a name="ln354">  if( out-&gt;dim != 7 ) error(&quot;add_7tuple: the n-tuple must be a 7-tuple.&quot;);</a>
<a name="ln355"> </a>
<a name="ln356">  /* if needed, alloc more tuples to 'out' */</a>
<a name="ln357">  if( out-&gt;size == out-&gt;max_size ) enlarge_ntuple_list(out);</a>
<a name="ln358">  if( out-&gt;values == NULL ) error(&quot;add_7tuple: invalid n-tuple input.&quot;);</a>
<a name="ln359"> </a>
<a name="ln360">  /* add new 7-tuple */</a>
<a name="ln361">  out-&gt;values[ out-&gt;size * out-&gt;dim + 0 ] = v1;</a>
<a name="ln362">  out-&gt;values[ out-&gt;size * out-&gt;dim + 1 ] = v2;</a>
<a name="ln363">  out-&gt;values[ out-&gt;size * out-&gt;dim + 2 ] = v3;</a>
<a name="ln364">  out-&gt;values[ out-&gt;size * out-&gt;dim + 3 ] = v4;</a>
<a name="ln365">  out-&gt;values[ out-&gt;size * out-&gt;dim + 4 ] = v5;</a>
<a name="ln366">  out-&gt;values[ out-&gt;size * out-&gt;dim + 5 ] = v6;</a>
<a name="ln367">  out-&gt;values[ out-&gt;size * out-&gt;dim + 6 ] = v7;</a>
<a name="ln368"> </a>
<a name="ln369">  /* update number of tuples counter */</a>
<a name="ln370">  out-&gt;size++;</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373"> </a>
<a name="ln374">/*----------------------------------------------------------------------------*/</a>
<a name="ln375">/*----------------------------- Image Data Types -----------------------------*/</a>
<a name="ln376">/*----------------------------------------------------------------------------*/</a>
<a name="ln377"> </a>
<a name="ln378">/*----------------------------------------------------------------------------*/</a>
<a name="ln379">/** char image data type</a>
<a name="ln380"> </a>
<a name="ln381">    The pixel value at (x,y) is accessed by:</a>
<a name="ln382"> </a>
<a name="ln383">      image-&gt;data[ x + y * image-&gt;xsize ]</a>
<a name="ln384"> </a>
<a name="ln385">    with x and y integer.</a>
<a name="ln386"> */</a>
<a name="ln387">typedef struct image_char_s</a>
<a name="ln388">{</a>
<a name="ln389">  unsigned char * data;</a>
<a name="ln390">  unsigned int xsize,ysize;</a>
<a name="ln391">} * image_char;</a>
<a name="ln392"> </a>
<a name="ln393">/*----------------------------------------------------------------------------*/</a>
<a name="ln394">/** Free memory used in image_char 'i'.</a>
<a name="ln395"> */</a>
<a name="ln396">static void free_image_char(image_char i)</a>
<a name="ln397">{</a>
<a name="ln398">  if( i == NULL || i-&gt;data == NULL )</a>
<a name="ln399">    error(&quot;free_image_char: invalid input image.&quot;);</a>
<a name="ln400">  free( (void *) i-&gt;data );</a>
<a name="ln401">  free( (void *) i );</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">/*----------------------------------------------------------------------------*/</a>
<a name="ln405">/** Create a new image_char of size 'xsize' times 'ysize'.</a>
<a name="ln406"> */</a>
<a name="ln407">static image_char new_image_char(unsigned int xsize, unsigned int ysize)</a>
<a name="ln408">{</a>
<a name="ln409">  image_char image;</a>
<a name="ln410"> </a>
<a name="ln411">  /* check parameters */</a>
<a name="ln412">  if( xsize == 0 || ysize == 0 ) error(&quot;new_image_char: invalid image size.&quot;);</a>
<a name="ln413"> </a>
<a name="ln414">  /* get memory */</a>
<a name="ln415">  image = (image_char) malloc( sizeof(struct image_char_s) );</a>
<a name="ln416">  if( image == NULL ) error(&quot;not enough memory.&quot;);</a>
<a name="ln417">  image-&gt;data = (unsigned char *) calloc( (size_t) (xsize*ysize),</a>
<a name="ln418">                                          sizeof(unsigned char) );</a>
<a name="ln419">  if( image-&gt;data == NULL ) error(&quot;not enough memory.&quot;);</a>
<a name="ln420"> </a>
<a name="ln421">  /* set image size */</a>
<a name="ln422">  image-&gt;xsize = xsize;</a>
<a name="ln423">  image-&gt;ysize = ysize;</a>
<a name="ln424"> </a>
<a name="ln425">  return image;</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">/*----------------------------------------------------------------------------*/</a>
<a name="ln429">/** Create a new image_char of size 'xsize' times 'ysize',</a>
<a name="ln430">    initialized to the value 'fill_value'.</a>
<a name="ln431"> */</a>
<a name="ln432">static image_char new_image_char_ini( unsigned int xsize, unsigned int ysize,</a>
<a name="ln433">                                      unsigned char fill_value )</a>
<a name="ln434">{</a>
<a name="ln435">  image_char image = new_image_char(xsize,ysize); /* create image */</a>
<a name="ln436">  unsigned int N = xsize*ysize;</a>
<a name="ln437">  unsigned int i;</a>
<a name="ln438"> </a>
<a name="ln439">  /* check parameters */</a>
<a name="ln440">  if( image == NULL || image-&gt;data == NULL )</a>
<a name="ln441">    error(&quot;new_image_char_ini: invalid image.&quot;);</a>
<a name="ln442"> </a>
<a name="ln443">  /* initialize */</a>
<a name="ln444">  for(i=0; i&lt;N; i++) image-&gt;data[i] = fill_value;</a>
<a name="ln445"> </a>
<a name="ln446">  return image;</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">/*----------------------------------------------------------------------------*/</a>
<a name="ln450">/** int image data type</a>
<a name="ln451"> </a>
<a name="ln452">    The pixel value at (x,y) is accessed by:</a>
<a name="ln453"> </a>
<a name="ln454">      image-&gt;data[ x + y * image-&gt;xsize ]</a>
<a name="ln455"> </a>
<a name="ln456">    with x and y integer.</a>
<a name="ln457"> */</a>
<a name="ln458">typedef struct image_int_s</a>
<a name="ln459">{</a>
<a name="ln460">  int * data;</a>
<a name="ln461">  unsigned int xsize,ysize;</a>
<a name="ln462">} * image_int;</a>
<a name="ln463"> </a>
<a name="ln464">/*----------------------------------------------------------------------------*/</a>
<a name="ln465">/** Create a new image_int of size 'xsize' times 'ysize'.</a>
<a name="ln466"> */</a>
<a name="ln467">static image_int new_image_int(unsigned int xsize, unsigned int ysize)</a>
<a name="ln468">{</a>
<a name="ln469">  image_int image;</a>
<a name="ln470"> </a>
<a name="ln471">  /* check parameters */</a>
<a name="ln472">  if( xsize == 0 || ysize == 0 ) error(&quot;new_image_int: invalid image size.&quot;);</a>
<a name="ln473"> </a>
<a name="ln474">  /* get memory */</a>
<a name="ln475">  image = (image_int) malloc( sizeof(struct image_int_s) );</a>
<a name="ln476">  if( image == NULL ) error(&quot;not enough memory.&quot;);</a>
<a name="ln477">  image-&gt;data = (int *) calloc( (size_t) (xsize*ysize), sizeof(int) );</a>
<a name="ln478">  if( image-&gt;data == NULL ) error(&quot;not enough memory.&quot;);</a>
<a name="ln479"> </a>
<a name="ln480">  /* set image size */</a>
<a name="ln481">  image-&gt;xsize = xsize;</a>
<a name="ln482">  image-&gt;ysize = ysize;</a>
<a name="ln483"> </a>
<a name="ln484">  return image;</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487">/*----------------------------------------------------------------------------*/</a>
<a name="ln488">/** Create a new image_int of size 'xsize' times 'ysize',</a>
<a name="ln489">    initialized to the value 'fill_value'.</a>
<a name="ln490"> */</a>
<a name="ln491">static image_int new_image_int_ini( unsigned int xsize, unsigned int ysize,</a>
<a name="ln492">                                    int fill_value )</a>
<a name="ln493">{</a>
<a name="ln494">  image_int image = new_image_int(xsize,ysize); /* create image */</a>
<a name="ln495">  unsigned int N = xsize*ysize;</a>
<a name="ln496">  unsigned int i;</a>
<a name="ln497"> </a>
<a name="ln498">  /* initialize */</a>
<a name="ln499">  for(i=0; i&lt;N; i++) image-&gt;data[i] = fill_value;</a>
<a name="ln500"> </a>
<a name="ln501">  return image;</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">/*----------------------------------------------------------------------------*/</a>
<a name="ln505">/** double image data type</a>
<a name="ln506"> </a>
<a name="ln507">    The pixel value at (x,y) is accessed by:</a>
<a name="ln508"> </a>
<a name="ln509">      image-&gt;data[ x + y * image-&gt;xsize ]</a>
<a name="ln510"> </a>
<a name="ln511">    with x and y integer.</a>
<a name="ln512"> */</a>
<a name="ln513">typedef struct image_double_s</a>
<a name="ln514">{</a>
<a name="ln515">  double * data;</a>
<a name="ln516">  unsigned int xsize,ysize;</a>
<a name="ln517">} * image_double;</a>
<a name="ln518"> </a>
<a name="ln519">/*----------------------------------------------------------------------------*/</a>
<a name="ln520">/** Free memory used in image_double 'i'.</a>
<a name="ln521"> */</a>
<a name="ln522">static void free_image_double(image_double i)</a>
<a name="ln523">{</a>
<a name="ln524">  if( i == NULL || i-&gt;data == NULL )</a>
<a name="ln525">    error(&quot;free_image_double: invalid input image.&quot;);</a>
<a name="ln526">  free( (void *) i-&gt;data );</a>
<a name="ln527">  free( (void *) i );</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530">/*----------------------------------------------------------------------------*/</a>
<a name="ln531">/** Create a new image_double of size 'xsize' times 'ysize'.</a>
<a name="ln532"> */</a>
<a name="ln533">static image_double new_image_double(unsigned int xsize, unsigned int ysize)</a>
<a name="ln534">{</a>
<a name="ln535">  image_double image;</a>
<a name="ln536"> </a>
<a name="ln537">  /* check parameters */</a>
<a name="ln538">  if( xsize == 0 || ysize == 0 ) error(&quot;new_image_double: invalid image size.&quot;);</a>
<a name="ln539"> </a>
<a name="ln540">  /* get memory */</a>
<a name="ln541">  image = (image_double) malloc( sizeof(struct image_double_s) );</a>
<a name="ln542">  if( image == NULL ) error(&quot;not enough memory.&quot;);</a>
<a name="ln543">  image-&gt;data = (double *) calloc( (size_t) (xsize*ysize), sizeof(double) );</a>
<a name="ln544">  if( image-&gt;data == NULL ) error(&quot;not enough memory.&quot;);</a>
<a name="ln545"> </a>
<a name="ln546">  /* set image size */</a>
<a name="ln547">  image-&gt;xsize = xsize;</a>
<a name="ln548">  image-&gt;ysize = ysize;</a>
<a name="ln549"> </a>
<a name="ln550">  return image;</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553">/*----------------------------------------------------------------------------*/</a>
<a name="ln554">/** Create a new image_double of size 'xsize' times 'ysize'</a>
<a name="ln555">    with the data pointed by 'data'.</a>
<a name="ln556"> */</a>
<a name="ln557">static image_double new_image_double_ptr( unsigned int xsize,</a>
<a name="ln558">                                          unsigned int ysize, double * data )</a>
<a name="ln559">{</a>
<a name="ln560">  image_double image;</a>
<a name="ln561"> </a>
<a name="ln562">  /* check parameters */</a>
<a name="ln563">  if( xsize == 0 || ysize == 0 )</a>
<a name="ln564">    error(&quot;new_image_double_ptr: invalid image size.&quot;);</a>
<a name="ln565">  if( data == NULL ) error(&quot;new_image_double_ptr: NULL data pointer.&quot;);</a>
<a name="ln566"> </a>
<a name="ln567">  /* get memory */</a>
<a name="ln568">  image = (image_double) malloc( sizeof(struct image_double_s) );</a>
<a name="ln569">  if( image == NULL ) error(&quot;not enough memory.&quot;);</a>
<a name="ln570"> </a>
<a name="ln571">  /* set image */</a>
<a name="ln572">  image-&gt;xsize = xsize;</a>
<a name="ln573">  image-&gt;ysize = ysize;</a>
<a name="ln574">  image-&gt;data = data;</a>
<a name="ln575"> </a>
<a name="ln576">  return image;</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579"> </a>
<a name="ln580">/*----------------------------------------------------------------------------*/</a>
<a name="ln581">/*----------------------------- Gaussian filter ------------------------------*/</a>
<a name="ln582">/*----------------------------------------------------------------------------*/</a>
<a name="ln583"> </a>
<a name="ln584">/*----------------------------------------------------------------------------*/</a>
<a name="ln585">/** Compute a Gaussian kernel of length 'kernel-&gt;dim',</a>
<a name="ln586">    standard deviation 'sigma', and centered at value 'mean'.</a>
<a name="ln587"> </a>
<a name="ln588">    For example, if mean=0.5, the Gaussian will be centered</a>
<a name="ln589">    in the middle point between values 'kernel-&gt;values[0]'</a>
<a name="ln590">    and 'kernel-&gt;values[1]'.</a>
<a name="ln591"> */</a>
<a name="ln592">static void gaussian_kernel(ntuple_list kernel, double sigma, double mean)</a>
<a name="ln593">{</a>
<a name="ln594">  double sum = 0.0;</a>
<a name="ln595">  double val;</a>
<a name="ln596">  unsigned int i;</a>
<a name="ln597"> </a>
<a name="ln598">  /* check parameters */</a>
<a name="ln599">  if( kernel == NULL || kernel-&gt;values == NULL )</a>
<a name="ln600">    error(&quot;gaussian_kernel: invalid n-tuple 'kernel'.&quot;);</a>
<a name="ln601">  if( sigma &lt;= 0.0 ) error(&quot;gaussian_kernel: 'sigma' must be positive.&quot;);</a>
<a name="ln602"> </a>
<a name="ln603">  /* compute Gaussian kernel */</a>
<a name="ln604">  if( kernel-&gt;max_size &lt; 1 ) enlarge_ntuple_list(kernel);</a>
<a name="ln605">  kernel-&gt;size = 1;</a>
<a name="ln606">  for(i=0;i&lt;kernel-&gt;dim;i++)</a>
<a name="ln607">    {</a>
<a name="ln608">      val = ( (double) i - mean ) / sigma;</a>
<a name="ln609">      kernel-&gt;values[i] = exp( -0.5 * val * val );</a>
<a name="ln610">      sum += kernel-&gt;values[i];</a>
<a name="ln611">    }</a>
<a name="ln612"> </a>
<a name="ln613">  /* normalization */</a>
<a name="ln614">  if( sum &gt;= 0.0 ) for(i=0;i&lt;kernel-&gt;dim;i++) kernel-&gt;values[i] /= sum;</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">/*----------------------------------------------------------------------------*/</a>
<a name="ln618">/** Scale the input image 'in' by a factor 'scale' by Gaussian sub-sampling.</a>
<a name="ln619"> </a>
<a name="ln620">    For example, scale=0.8 will give a result at 80% of the original size.</a>
<a name="ln621"> </a>
<a name="ln622">    The image is convolved with a Gaussian kernel</a>
<a name="ln623">    @f[</a>
<a name="ln624">        G(x,y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}}</a>
<a name="ln625">    @f]</a>
<a name="ln626">    before the sub-sampling to prevent aliasing.</a>
<a name="ln627"> </a>
<a name="ln628">    The standard deviation sigma given by:</a>
<a name="ln629">    -  sigma = sigma_scale / scale,   if scale &lt;  1.0</a>
<a name="ln630">    -  sigma = sigma_scale,           if scale &gt;= 1.0</a>
<a name="ln631"> </a>
<a name="ln632">    To be able to sub-sample at non-integer steps, some interpolation</a>
<a name="ln633">    is needed. In this implementation, the interpolation is done by</a>
<a name="ln634">    the Gaussian kernel, so both operations (filtering and sampling)</a>
<a name="ln635">    are done at the same time. The Gaussian kernel is computed</a>
<a name="ln636">    centered on the coordinates of the required sample. In this way,</a>
<a name="ln637">    when applied, it gives directly the result of convolving the image</a>
<a name="ln638">    with the kernel and interpolated to that particular position.</a>
<a name="ln639"> </a>
<a name="ln640">    A fast algorithm is done using the separability of the Gaussian</a>
<a name="ln641">    kernel. Applying the 2D Gaussian kernel is equivalent to applying</a>
<a name="ln642">    first a horizontal 1D Gaussian kernel and then a vertical 1D</a>
<a name="ln643">    Gaussian kernel (or the other way round). The reason is that</a>
<a name="ln644">    @f[</a>
<a name="ln645">        G(x,y) = G(x) * G(y)</a>
<a name="ln646">    @f]</a>
<a name="ln647">    where</a>
<a name="ln648">    @f[</a>
<a name="ln649">        G(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{x^2}{2\sigma^2}}.</a>
<a name="ln650">    @f]</a>
<a name="ln651">    The algorithm first applies a combined Gaussian kernel and sampling</a>
<a name="ln652">    in the x axis, and then the combined Gaussian kernel and sampling</a>
<a name="ln653">    in the y axis.</a>
<a name="ln654"> */</a>
<a name="ln655">static image_double gaussian_sampler( image_double in, double scale,</a>
<a name="ln656">                                      double sigma_scale )</a>
<a name="ln657">{</a>
<a name="ln658">  image_double aux,out;</a>
<a name="ln659">  ntuple_list kernel;</a>
<a name="ln660">  unsigned int N,M,h,n,x,y,i;</a>
<a name="ln661">  int xc,yc,j,double_x_size,double_y_size;</a>
<a name="ln662">  double sigma,xx,yy,sum,prec;</a>
<a name="ln663"> </a>
<a name="ln664">  /* check parameters */</a>
<a name="ln665">  if( in == NULL || in-&gt;data == NULL || in-&gt;xsize == 0 || in-&gt;ysize == 0 )</a>
<a name="ln666">    error(&quot;gaussian_sampler: invalid image.&quot;);</a>
<a name="ln667">  if( scale &lt;= 0.0 ) error(&quot;gaussian_sampler: 'scale' must be positive.&quot;);</a>
<a name="ln668">  if( sigma_scale &lt;= 0.0 )</a>
<a name="ln669">    error(&quot;gaussian_sampler: 'sigma_scale' must be positive.&quot;);</a>
<a name="ln670"> </a>
<a name="ln671">  /* compute new image size and get memory for images */</a>
<a name="ln672">  if( in-&gt;xsize * scale &gt; (double) UINT_MAX ||</a>
<a name="ln673">      in-&gt;ysize * scale &gt; (double) UINT_MAX )</a>
<a name="ln674">    error(&quot;gaussian_sampler: the output image size exceeds the handled size.&quot;);</a>
<a name="ln675">  N = (unsigned int) ceil( in-&gt;xsize * scale );</a>
<a name="ln676">  M = (unsigned int) ceil( in-&gt;ysize * scale );</a>
<a name="ln677">  aux = new_image_double(N,in-&gt;ysize);</a>
<a name="ln678">  out = new_image_double(N,M);</a>
<a name="ln679"> </a>
<a name="ln680">  /* sigma, kernel size and memory for the kernel */</a>
<a name="ln681">  sigma = scale &lt; 1.0 ? sigma_scale / scale : sigma_scale;</a>
<a name="ln682">  /*</a>
<a name="ln683">     The size of the kernel is selected to guarantee that the</a>
<a name="ln684">     the first discarded term is at least 10^prec times smaller</a>
<a name="ln685">     than the central value. For that, h should be larger than x, with</a>
<a name="ln686">       e^(-x^2/2sigma^2) = 1/10^prec.</a>
<a name="ln687">     Then,</a>
<a name="ln688">       x = sigma * sqrt( 2 * prec * ln(10) ).</a>
<a name="ln689">   */</a>
<a name="ln690">  prec = 3.0;</a>
<a name="ln691">  h = (unsigned int) ceil( sigma * sqrt( 2.0 * prec * log(10.0) ) );</a>
<a name="ln692">  n = 1+2*h; /* kernel size */</a>
<a name="ln693">  kernel = new_ntuple_list(n);</a>
<a name="ln694"> </a>
<a name="ln695">  /* auxiliary double image size variables */</a>
<a name="ln696">  double_x_size = (int) (2 * in-&gt;xsize);</a>
<a name="ln697">  double_y_size = (int) (2 * in-&gt;ysize);</a>
<a name="ln698"> </a>
<a name="ln699">  /* First subsampling: x axis */</a>
<a name="ln700">  for(x=0;x&lt;aux-&gt;xsize;x++)</a>
<a name="ln701">    {</a>
<a name="ln702">      /*</a>
<a name="ln703">         x   is the coordinate in the new image.</a>
<a name="ln704">         xx  is the corresponding x-value in the original size image.</a>
<a name="ln705">         xc  is the integer value, the pixel coordinate of xx.</a>
<a name="ln706">       */</a>
<a name="ln707">      xx = (double) x / scale;</a>
<a name="ln708">      /* coordinate (0.0,0.0) is in the center of pixel (0,0),</a>
<a name="ln709">         so the pixel with xc=0 get the values of xx from -0.5 to 0.5 */</a>
<a name="ln710">      xc = (int) floor( xx + 0.5 );</a>
<a name="ln711">      gaussian_kernel( kernel, sigma, (double) h + xx - (double) xc );</a>
<a name="ln712">      /* the kernel must be computed for each x because the fine</a>
<a name="ln713">         offset xx-xc is different in each case */</a>
<a name="ln714"> </a>
<a name="ln715">      for(y=0;y&lt;aux-&gt;ysize;y++)</a>
<a name="ln716">        {</a>
<a name="ln717">          sum = 0.0;</a>
<a name="ln718">          for(i=0;i&lt;kernel-&gt;dim;i++)</a>
<a name="ln719">            {</a>
<a name="ln720">              j = xc - h + i;</a>
<a name="ln721"> </a>
<a name="ln722">              /* symmetry boundary condition */</a>
<a name="ln723">              while( j &lt; 0 ) j += double_x_size;</a>
<a name="ln724">              while( j &gt;= double_x_size ) j -= double_x_size;</a>
<a name="ln725">              if( j &gt;= (int) in-&gt;xsize ) j = double_x_size-1-j;</a>
<a name="ln726"> </a>
<a name="ln727">              sum += in-&gt;data[ j + y * in-&gt;xsize ] * kernel-&gt;values[i];</a>
<a name="ln728">            }</a>
<a name="ln729">          aux-&gt;data[ x + y * aux-&gt;xsize ] = sum;</a>
<a name="ln730">        }</a>
<a name="ln731">    }</a>
<a name="ln732"> </a>
<a name="ln733">  /* Second subsampling: y axis */</a>
<a name="ln734">  for(y=0;y&lt;out-&gt;ysize;y++)</a>
<a name="ln735">    {</a>
<a name="ln736">      /*</a>
<a name="ln737">         y   is the coordinate in the new image.</a>
<a name="ln738">         yy  is the corresponding x-value in the original size image.</a>
<a name="ln739">         yc  is the integer value, the pixel coordinate of xx.</a>
<a name="ln740">       */</a>
<a name="ln741">      yy = (double) y / scale;</a>
<a name="ln742">      /* coordinate (0.0,0.0) is in the center of pixel (0,0),</a>
<a name="ln743">         so the pixel with yc=0 get the values of yy from -0.5 to 0.5 */</a>
<a name="ln744">      yc = (int) floor( yy + 0.5 );</a>
<a name="ln745">      gaussian_kernel( kernel, sigma, (double) h + yy - (double) yc );</a>
<a name="ln746">      /* the kernel must be computed for each y because the fine</a>
<a name="ln747">         offset yy-yc is different in each case */</a>
<a name="ln748"> </a>
<a name="ln749">      for(x=0;x&lt;out-&gt;xsize;x++)</a>
<a name="ln750">        {</a>
<a name="ln751">          sum = 0.0;</a>
<a name="ln752">          for(i=0;i&lt;kernel-&gt;dim;i++)</a>
<a name="ln753">            {</a>
<a name="ln754">              j = yc - h + i;</a>
<a name="ln755"> </a>
<a name="ln756">              /* symmetry boundary condition */</a>
<a name="ln757">              while( j &lt; 0 ) j += double_y_size;</a>
<a name="ln758">              while( j &gt;= double_y_size ) j -= double_y_size;</a>
<a name="ln759">              if( j &gt;= (int) in-&gt;ysize ) j = double_y_size-1-j;</a>
<a name="ln760"> </a>
<a name="ln761">              sum += aux-&gt;data[ x + j * aux-&gt;xsize ] * kernel-&gt;values[i];</a>
<a name="ln762">            }</a>
<a name="ln763">          out-&gt;data[ x + y * out-&gt;xsize ] = sum;</a>
<a name="ln764">        }</a>
<a name="ln765">    }</a>
<a name="ln766"> </a>
<a name="ln767">  /* free memory */</a>
<a name="ln768">  free_ntuple_list(kernel);</a>
<a name="ln769">  free_image_double(aux);</a>
<a name="ln770"> </a>
<a name="ln771">  return out;</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774"> </a>
<a name="ln775">/*----------------------------------------------------------------------------*/</a>
<a name="ln776">/*--------------------------------- Gradient ---------------------------------*/</a>
<a name="ln777">/*----------------------------------------------------------------------------*/</a>
<a name="ln778"> </a>
<a name="ln779">/*----------------------------------------------------------------------------*/</a>
<a name="ln780">/** Computes the direction of the level line of 'in' at each point.</a>
<a name="ln781"> </a>
<a name="ln782">    The result is:</a>
<a name="ln783">    - an image_double with the angle at each pixel, or NOTDEF if not defined.</a>
<a name="ln784">    - the image_double 'modgrad' (a pointer is passed as argument)</a>
<a name="ln785">      with the gradient magnitude at each point.</a>
<a name="ln786">    - a list of pixels 'list_p' roughly ordered by decreasing</a>
<a name="ln787">      gradient magnitude. (The order is made by classifying points</a>
<a name="ln788">      into bins by gradient magnitude. The parameters 'n_bins' and</a>
<a name="ln789">      'max_grad' specify the number of bins and the gradient modulus</a>
<a name="ln790">      at the highest bin. The pixels in the list would be in</a>
<a name="ln791">      decreasing gradient magnitude, up to a precision of the size of</a>
<a name="ln792">      the bins.)</a>
<a name="ln793">    - a pointer 'mem_p' to the memory used by 'list_p' to be able to</a>
<a name="ln794">      free the memory when it is not used anymore.</a>
<a name="ln795"> */</a>
<a name="ln796">static image_double ll_angle( image_double in, double threshold,</a>
<a name="ln797">                              struct coorlist ** list_p, void ** mem_p,</a>
<a name="ln798">                              image_double * modgrad, unsigned int n_bins )</a>
<a name="ln799">{</a>
<a name="ln800">  image_double g;</a>
<a name="ln801">  unsigned int n,p,x,y,adr,i;</a>
<a name="ln802">  double com1,com2,gx,gy,norm,norm2;</a>
<a name="ln803">  /* the rest of the variables are used for pseudo-ordering</a>
<a name="ln804">     the gradient magnitude values */</a>
<a name="ln805">  int list_count = 0;</a>
<a name="ln806">  struct coorlist * list;</a>
<a name="ln807">  struct coorlist ** range_l_s; /* array of pointers to start of bin list */</a>
<a name="ln808">  struct coorlist ** range_l_e; /* array of pointers to end of bin list */</a>
<a name="ln809">  struct coorlist * start;</a>
<a name="ln810">  struct coorlist * end;</a>
<a name="ln811">  double max_grad = 0.0;</a>
<a name="ln812"> </a>
<a name="ln813">  /* check parameters */</a>
<a name="ln814">  if( in == NULL || in-&gt;data == NULL || in-&gt;xsize == 0 || in-&gt;ysize == 0 )</a>
<a name="ln815">    error(&quot;ll_angle: invalid image.&quot;);</a>
<a name="ln816">  if( threshold &lt; 0.0 ) error(&quot;ll_angle: 'threshold' must be positive.&quot;);</a>
<a name="ln817">  if( list_p == NULL ) error(&quot;ll_angle: NULL pointer 'list_p'.&quot;);</a>
<a name="ln818">  if( mem_p == NULL ) error(&quot;ll_angle: NULL pointer 'mem_p'.&quot;);</a>
<a name="ln819">  if( modgrad == NULL ) error(&quot;ll_angle: NULL pointer 'modgrad'.&quot;);</a>
<a name="ln820">  if( n_bins == 0 ) error(&quot;ll_angle: 'n_bins' must be positive.&quot;);</a>
<a name="ln821"> </a>
<a name="ln822">  /* image size shortcuts */</a>
<a name="ln823">  n = in-&gt;ysize;</a>
<a name="ln824">  p = in-&gt;xsize;</a>
<a name="ln825"> </a>
<a name="ln826">  /* allocate output image */</a>
<a name="ln827">  g = new_image_double(in-&gt;xsize,in-&gt;ysize);</a>
<a name="ln828"> </a>
<a name="ln829">  /* get memory for the image of gradient modulus */</a>
<a name="ln830">  *modgrad = new_image_double(in-&gt;xsize,in-&gt;ysize);</a>
<a name="ln831"> </a>
<a name="ln832">  /* get memory for &quot;ordered&quot; list of pixels */</a>
<a name="ln833">  list = (struct coorlist *) calloc( (size_t) (n*p), sizeof(struct coorlist) );</a>
<a name="ln834">  *mem_p = (void *) list;</a>
<a name="ln835">  range_l_s = (struct coorlist **) calloc( (size_t) n_bins,</a>
<a name="ln836">                                           sizeof(struct coorlist *) );</a>
<a name="ln837">  range_l_e = (struct coorlist **) calloc( (size_t) n_bins,</a>
<a name="ln838">                                           sizeof(struct coorlist *) );</a>
<a name="ln839">  if( list == NULL || range_l_s == NULL || range_l_e == NULL )</a>
<a name="ln840">    error(&quot;not enough memory.&quot;);</a>
<a name="ln841">  for(i=0;i&lt;n_bins;i++) range_l_s[i] = range_l_e[i] = NULL;</a>
<a name="ln842"> </a>
<a name="ln843">  /* 'undefined' on the down and right boundaries */</a>
<a name="ln844">  for(x=0;x&lt;p;x++) g-&gt;data[(n-1)*p+x] = NOTDEF;</a>
<a name="ln845">  for(y=0;y&lt;n;y++) g-&gt;data[p*y+p-1]   = NOTDEF;</a>
<a name="ln846"> </a>
<a name="ln847">  /* compute gradient on the remaining pixels */</a>
<a name="ln848">  for(x=0;x&lt;p-1;x++)</a>
<a name="ln849">    for(y=0;y&lt;n-1;y++)</a>
<a name="ln850">      {</a>
<a name="ln851">        adr = y*p+x;</a>
<a name="ln852"> </a>
<a name="ln853">        /*</a>
<a name="ln854">           Norm 2 computation using 2x2 pixel window:</a>
<a name="ln855">             A B</a>
<a name="ln856">             C D</a>
<a name="ln857">           and</a>
<a name="ln858">             com1 = D-A,  com2 = B-C.</a>
<a name="ln859">           Then</a>
<a name="ln860">             gx = B+D - (A+C)   horizontal difference</a>
<a name="ln861">             gy = C+D - (A+B)   vertical difference</a>
<a name="ln862">           com1 and com2 are just to avoid 2 additions.</a>
<a name="ln863">         */</a>
<a name="ln864">        com1 = in-&gt;data[adr+p+1] - in-&gt;data[adr];</a>
<a name="ln865">        com2 = in-&gt;data[adr+1]   - in-&gt;data[adr+p];</a>
<a name="ln866"> </a>
<a name="ln867">        gx = com1+com2; /* gradient x component */</a>
<a name="ln868">        gy = com1-com2; /* gradient y component */</a>
<a name="ln869">        norm2 = gx*gx+gy*gy;</a>
<a name="ln870">        norm = sqrt( norm2 / 4.0 ); /* gradient norm */</a>
<a name="ln871"> </a>
<a name="ln872">        (*modgrad)-&gt;data[adr] = norm; /* store gradient norm */</a>
<a name="ln873"> </a>
<a name="ln874">        if( norm &lt;= threshold ) /* norm too small, gradient no defined */</a>
<a name="ln875">          g-&gt;data[adr] = NOTDEF; /* gradient angle not defined */</a>
<a name="ln876">        else</a>
<a name="ln877">          {</a>
<a name="ln878">            /* gradient angle computation */</a>
<a name="ln879">            g-&gt;data[adr] = atan2(gx,-gy);</a>
<a name="ln880"> </a>
<a name="ln881">            /* look for the maximum of the gradient */</a>
<a name="ln882">            if( norm &gt; max_grad ) max_grad = norm;</a>
<a name="ln883">          }</a>
<a name="ln884">      }</a>
<a name="ln885"> </a>
<a name="ln886">  /* compute histogram of gradient values */</a>
<a name="ln887">  for(x=0;x&lt;p-1;x++)</a>
<a name="ln888">    for(y=0;y&lt;n-1;y++)</a>
<a name="ln889">      {</a>
<a name="ln890">        norm = (*modgrad)-&gt;data[y*p+x];</a>
<a name="ln891"> </a>
<a name="ln892">        /* store the point in the right bin according to its norm */</a>
<a name="ln893">        i = (unsigned int) (norm * (double) n_bins / max_grad);</a>
<a name="ln894">        if( i &gt;= n_bins ) i = n_bins-1;</a>
<a name="ln895">        if( range_l_e[i] == NULL )</a>
<a name="ln896">          range_l_s[i] = range_l_e[i] = list+list_count++;</a>
<a name="ln897">        else</a>
<a name="ln898">          {</a>
<a name="ln899">            range_l_e[i]-&gt;next = list+list_count;</a>
<a name="ln900">            range_l_e[i] = list+list_count++;</a>
<a name="ln901">          }</a>
<a name="ln902">        range_l_e[i]-&gt;x = (int) x;</a>
<a name="ln903">        range_l_e[i]-&gt;y = (int) y;</a>
<a name="ln904">        range_l_e[i]-&gt;next = NULL;</a>
<a name="ln905">      }</a>
<a name="ln906"> </a>
<a name="ln907">  /* Make the list of pixels (almost) ordered by norm value.</a>
<a name="ln908">     It starts by the larger bin, so the list starts by the</a>
<a name="ln909">     pixels with the highest gradient value. Pixels would be ordered</a>
<a name="ln910">     by norm value, up to a precision given by max_grad/n_bins.</a>
<a name="ln911">   */</a>
<a name="ln912">  for(i=n_bins-1; i&gt;0 &amp;&amp; range_l_s[i]==NULL; i--);</a>
<a name="ln913">  start = range_l_s[i];</a>
<a name="ln914">  end = range_l_e[i];</a>
<a name="ln915">  if( start != NULL )</a>
<a name="ln916">    while(i&gt;0)</a>
<a name="ln917">      {</a>
<a name="ln918">        --i;</a>
<a name="ln919">        if( range_l_s[i] != NULL )</a>
<a name="ln920">          {</a>
<a name="ln921">            end-&gt;next = range_l_s[i];</a>
<a name="ln922">            end = range_l_e[i];</a>
<a name="ln923">          }</a>
<a name="ln924">      }</a>
<a name="ln925">  *list_p = start;</a>
<a name="ln926"> </a>
<a name="ln927">  /* free memory */</a>
<a name="ln928">  free( (void *) range_l_s );</a>
<a name="ln929">  free( (void *) range_l_e );</a>
<a name="ln930"> </a>
<a name="ln931">  return g;</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934">/*----------------------------------------------------------------------------*/</a>
<a name="ln935">/** Is point (x,y) aligned to angle theta, up to precision 'prec'?</a>
<a name="ln936"> */</a>
<a name="ln937">static int isaligned( int x, int y, image_double angles, double theta,</a>
<a name="ln938">                      double prec )</a>
<a name="ln939">{</a>
<a name="ln940">  double a;</a>
<a name="ln941"> </a>
<a name="ln942">  /* check parameters */</a>
<a name="ln943">  if( angles == NULL || angles-&gt;data == NULL )</a>
<a name="ln944">    error(&quot;isaligned: invalid image 'angles'.&quot;);</a>
<a name="ln945">  if( x &lt; 0 || y &lt; 0 || x &gt;= (int) angles-&gt;xsize || y &gt;= (int) angles-&gt;ysize )</a>
<a name="ln946">    error(&quot;isaligned: (x,y) out of the image.&quot;);</a>
<a name="ln947">  if( prec &lt; 0.0 ) error(&quot;isaligned: 'prec' must be positive.&quot;);</a>
<a name="ln948"> </a>
<a name="ln949">  /* angle at pixel (x,y) */</a>
<a name="ln950">  a = angles-&gt;data[ x + y * angles-&gt;xsize ];</a>
<a name="ln951"> </a>
<a name="ln952">  /* pixels whose level-line angle is not defined</a>
<a name="ln953">     are considered as NON-aligned */</a>
<a name="ln954">  if( a == NOTDEF ) return FALSE;  /* there is no need to call the function</a>
<a name="ln955">                                      'double_equal' here because there is</a>
<a name="ln956">                                      no risk of problems related to the</a>
<a name="ln957">                                      comparison doubles, we are only</a>
<a name="ln958">                                      interested in the exact NOTDEF value */</a>
<a name="ln959"> </a>
<a name="ln960">  /* it is assumed that 'theta' and 'a' are in the range [-pi,pi] */</a>
<a name="ln961">  theta -= a;</a>
<a name="ln962">  if( theta &lt; 0.0 ) theta = -theta;</a>
<a name="ln963">  if( theta &gt; M_3_2_PI )</a>
<a name="ln964">    {</a>
<a name="ln965">      theta -= M_2__PI;</a>
<a name="ln966">      if( theta &lt; 0.0 ) theta = -theta;</a>
<a name="ln967">    }</a>
<a name="ln968"> </a>
<a name="ln969">  return theta &lt;= prec;</a>
<a name="ln970">}</a>
<a name="ln971"> </a>
<a name="ln972">/*----------------------------------------------------------------------------*/</a>
<a name="ln973">/** Absolute value angle difference.</a>
<a name="ln974"> */</a>
<a name="ln975">static double angle_diff(double a, double b)</a>
<a name="ln976">{</a>
<a name="ln977">  a -= b;</a>
<a name="ln978">  while( a &lt;= -M_PI ) a += M_2__PI;</a>
<a name="ln979">  while( a &gt;   M_PI ) a -= M_2__PI;</a>
<a name="ln980">  if( a &lt; 0.0 ) a = -a;</a>
<a name="ln981">  return a;</a>
<a name="ln982">}</a>
<a name="ln983"> </a>
<a name="ln984">/*----------------------------------------------------------------------------*/</a>
<a name="ln985">/** Signed angle difference.</a>
<a name="ln986"> */</a>
<a name="ln987">static double angle_diff_signed(double a, double b)</a>
<a name="ln988">{</a>
<a name="ln989">  a -= b;</a>
<a name="ln990">  while( a &lt;= -M_PI ) a += M_2__PI;</a>
<a name="ln991">  while( a &gt;   M_PI ) a -= M_2__PI;</a>
<a name="ln992">  return a;</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995"> </a>
<a name="ln996">/*----------------------------------------------------------------------------*/</a>
<a name="ln997">/*----------------------------- NFA computation ------------------------------*/</a>
<a name="ln998">/*----------------------------------------------------------------------------*/</a>
<a name="ln999"> </a>
<a name="ln1000">/*----------------------------------------------------------------------------*/</a>
<a name="ln1001">/** Computes the natural logarithm of the absolute value of</a>
<a name="ln1002">    the gamma function of x using the Lanczos approximation.</a>
<a name="ln1003">    See http://www.rskey.org/gamma.htm</a>
<a name="ln1004"> </a>
<a name="ln1005">    The formula used is</a>
<a name="ln1006">    @f[</a>
<a name="ln1007">      \Gamma(x) = \frac{ \sum_{n=0}^{N} q_n x^n }{ \Pi_{n=0}^{N} (x+n) }</a>
<a name="ln1008">                  (x+5.5)^{x+0.5} e^{-(x+5.5)}</a>
<a name="ln1009">    @f]</a>
<a name="ln1010">    so</a>
<a name="ln1011">    @f[</a>
<a name="ln1012">      \log\Gamma(x) = \log\left( \sum_{n=0}^{N} q_n x^n \right)</a>
<a name="ln1013">                      + (x+0.5) \log(x+5.5) - (x+5.5) - \sum_{n=0}^{N} \log(x+n)</a>
<a name="ln1014">    @f]</a>
<a name="ln1015">    and</a>
<a name="ln1016">      q0 = 75122.6331530,</a>
<a name="ln1017">      q1 = 80916.6278952,</a>
<a name="ln1018">      q2 = 36308.2951477,</a>
<a name="ln1019">      q3 = 8687.24529705,</a>
<a name="ln1020">      q4 = 1168.92649479,</a>
<a name="ln1021">      q5 = 83.8676043424,</a>
<a name="ln1022">      q6 = 2.50662827511.</a>
<a name="ln1023"> */</a>
<a name="ln1024">static double log_gamma_lanczos(double x)</a>
<a name="ln1025">{</a>
<a name="ln1026">  static double q[7] = { 75122.6331530, 80916.6278952, 36308.2951477,</a>
<a name="ln1027">                         8687.24529705, 1168.92649479, 83.8676043424,</a>
<a name="ln1028">                         2.50662827511 };</a>
<a name="ln1029">  double a = (x+0.5) * log(x+5.5) - (x+5.5);</a>
<a name="ln1030">  double b = 0.0;</a>
<a name="ln1031">  int n;</a>
<a name="ln1032"> </a>
<a name="ln1033">  for(n=0;n&lt;7;n++)</a>
<a name="ln1034">    {</a>
<a name="ln1035">      a -= log( x + (double) n );</a>
<a name="ln1036">      b += q[n] * pow( x, (double) n );</a>
<a name="ln1037">    }</a>
<a name="ln1038">  return a + log(b);</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041">/*----------------------------------------------------------------------------*/</a>
<a name="ln1042">/** Computes the natural logarithm of the absolute value of</a>
<a name="ln1043">    the gamma function of x using Windschitl method.</a>
<a name="ln1044">    See http://www.rskey.org/gamma.htm</a>
<a name="ln1045"> </a>
<a name="ln1046">    The formula used is</a>
<a name="ln1047">    @f[</a>
<a name="ln1048">        \Gamma(x) = \sqrt{\frac{2\pi}{x}} \left( \frac{x}{e}</a>
<a name="ln1049">                    \sqrt{ x\sinh(1/x) + \frac{1}{810x^6} } \right)^x</a>
<a name="ln1050">    @f]</a>
<a name="ln1051">    so</a>
<a name="ln1052">    @f[</a>
<a name="ln1053">        \log\Gamma(x) = 0.5\log(2\pi) + (x-0.5)\log(x) - x</a>
<a name="ln1054">                      + 0.5x\log\left( x\sinh(1/x) + \frac{1}{810x^6} \right).</a>
<a name="ln1055">    @f]</a>
<a name="ln1056">    This formula is a good approximation when x &gt; 15.</a>
<a name="ln1057"> */</a>
<a name="ln1058">static double log_gamma_windschitl(double x)</a>
<a name="ln1059">{</a>
<a name="ln1060">  return 0.918938533204673 + (x-0.5)*log(x) - x</a>
<a name="ln1061">         + 0.5*x*log( x*sinh(1/x) + 1/(810.0*pow(x,6.0)) );</a>
<a name="ln1062">}</a>
<a name="ln1063"> </a>
<a name="ln1064">/*----------------------------------------------------------------------------*/</a>
<a name="ln1065">/** Computes the natural logarithm of the absolute value of</a>
<a name="ln1066">    the gamma function of x. When x&gt;15 use log_gamma_windschitl(),</a>
<a name="ln1067">    otherwise use log_gamma_lanczos().</a>
<a name="ln1068"> */</a>
<a name="ln1069">#define log_gamma(x) ((x)&gt;15.0?log_gamma_windschitl(x):log_gamma_lanczos(x))</a>
<a name="ln1070"> </a>
<a name="ln1071">/*----------------------------------------------------------------------------*/</a>
<a name="ln1072">/** Size of the table to store already computed inverse values.</a>
<a name="ln1073"> */</a>
<a name="ln1074">#define TABSIZE 100000</a>
<a name="ln1075"> </a>
<a name="ln1076">// clang-format on</a>
<a name="ln1077"> </a>
<a name="ln1078">static double *inv = NULL; /* table to keep computed inverse values */</a>
<a name="ln1079"> </a>
<a name="ln1080">__attribute__((constructor)) static void invConstructor()</a>
<a name="ln1081">{</a>
<a name="ln1082">  if(inv) return;</a>
<a name="ln1083">  inv = malloc(sizeof(double) * TABSIZE);</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086">__attribute__((destructor)) static void invDestructor()</a>
<a name="ln1087">{</a>
<a name="ln1088">  free(inv);</a>
<a name="ln1089">  inv = NULL;</a>
<a name="ln1090">}</a>
<a name="ln1091"> </a>
<a name="ln1092">// clang-format off</a>
<a name="ln1093"> </a>
<a name="ln1094">/*----------------------------------------------------------------------------*/</a>
<a name="ln1095">/** Computes -log10(NFA).</a>
<a name="ln1096"> </a>
<a name="ln1097">    NFA stands for Number of False Alarms:</a>
<a name="ln1098">    @f[</a>
<a name="ln1099">        \mathrm{NFA} = NT \cdot B(n,k,p)</a>
<a name="ln1100">    @f]</a>
<a name="ln1101"> </a>
<a name="ln1102">    - NT       - number of tests</a>
<a name="ln1103">    - B(n,k,p) - tail of binomial distribution with parameters n,k and p:</a>
<a name="ln1104">    @f[</a>
<a name="ln1105">        B(n,k,p) = \sum_{j=k}^n</a>
<a name="ln1106">                   \left(\begin{array}{c}n\\j\end{array}\right)</a>
<a name="ln1107">                   p^{j} (1-p)^{n-j}</a>
<a name="ln1108">    @f]</a>
<a name="ln1109"> </a>
<a name="ln1110">    The value -log10(NFA) is equivalent but more intuitive than NFA:</a>
<a name="ln1111">    - -1 corresponds to 10 mean false alarms</a>
<a name="ln1112">    -  0 corresponds to 1 mean false alarm</a>
<a name="ln1113">    -  1 corresponds to 0.1 mean false alarms</a>
<a name="ln1114">    -  2 corresponds to 0.01 mean false alarms</a>
<a name="ln1115">    -  ...</a>
<a name="ln1116"> </a>
<a name="ln1117">    Used this way, the bigger the value, better the detection,</a>
<a name="ln1118">    and a logarithmic scale is used.</a>
<a name="ln1119"> </a>
<a name="ln1120">    @param n,k,p binomial parameters.</a>
<a name="ln1121">    @param logNT logarithm of Number of Tests</a>
<a name="ln1122"> </a>
<a name="ln1123">    The computation is based in the gamma function by the following</a>
<a name="ln1124">    relation:</a>
<a name="ln1125">    @f[</a>
<a name="ln1126">        \left(\begin{array}{c}n\\k\end{array}\right)</a>
<a name="ln1127">        = \frac{ \Gamma(n+1) }{ \Gamma(k+1) \cdot \Gamma(n-k+1) }.</a>
<a name="ln1128">    @f]</a>
<a name="ln1129">    We use efficient algorithms to compute the logarithm of</a>
<a name="ln1130">    the gamma function.</a>
<a name="ln1131"> </a>
<a name="ln1132">    To make the computation faster, not all the sum is computed, part</a>
<a name="ln1133">    of the terms are neglected based on a bound to the error obtained</a>
<a name="ln1134">    (an error of 10% in the result is accepted).</a>
<a name="ln1135"> */</a>
<a name="ln1136">static double nfa(int n, int k, double p, double logNT)</a>
<a name="ln1137">{</a>
<a name="ln1138">  double tolerance = 0.1;       /* an error of 10% in the result is accepted */</a>
<a name="ln1139">  double log1term,term,bin_term,mult_term,bin_tail,err,p_term;</a>
<a name="ln1140">  int i;</a>
<a name="ln1141"> </a>
<a name="ln1142">  /* check parameters */</a>
<a name="ln1143">  if( n&lt;0 || k&lt;0 || k&gt;n || p&lt;=0.0 || p&gt;=1.0 )</a>
<a name="ln1144">    error(&quot;nfa: wrong n, k or p values.&quot;);</a>
<a name="ln1145"> </a>
<a name="ln1146">  /* trivial cases */</a>
<a name="ln1147">  if( n==0 || k==0 ) return -logNT;</a>
<a name="ln1148">  if( n==k ) return -logNT - (double) n * log10(p);</a>
<a name="ln1149"> </a>
<a name="ln1150">  /* probability term */</a>
<a name="ln1151">  p_term = p / (1.0-p);</a>
<a name="ln1152"> </a>
<a name="ln1153">  /* compute the first term of the series */</a>
<a name="ln1154">  /*</a>
<a name="ln1155">     binomial_tail(n,k,p) = sum_{i=k}^n bincoef(n,i) * p^i * (1-p)^{n-i}</a>
<a name="ln1156">     where bincoef(n,i) are the binomial coefficients.</a>
<a name="ln1157">     But</a>
<a name="ln1158">       bincoef(n,k) = gamma(n+1) / ( gamma(k+1) * gamma(n-k+1) ).</a>
<a name="ln1159">     We use this to compute the first term. Actually the log of it.</a>
<a name="ln1160">   */</a>
<a name="ln1161">  log1term = log_gamma( (double) n + 1.0 ) - log_gamma( (double) k + 1.0 )</a>
<a name="ln1162">           - log_gamma( (double) (n-k) + 1.0 )</a>
<a name="ln1163">           + (double) k * log(p) + (double) (n-k) * log(1.0-p);</a>
<a name="ln1164">  term = exp(log1term);</a>
<a name="ln1165"> </a>
<a name="ln1166">  /* in some cases no more computations are needed */</a>
<a name="ln1167">  if( double_equal(term,0.0) )              /* the first term is almost zero */</a>
<a name="ln1168">    {</a>
<a name="ln1169">      if( (double) k &gt; (double) n * p )     /* at begin or end of the tail?  */</a>
<a name="ln1170">        return -log1term / M_LN10 - logNT;  /* end: use just the first term  */</a>
<a name="ln1171">      else</a>
<a name="ln1172">        return -logNT;                      /* begin: the tail is roughly 1  */</a>
<a name="ln1173">    }</a>
<a name="ln1174"> </a>
<a name="ln1175">  /* compute more terms if needed */</a>
<a name="ln1176">  bin_tail = term;</a>
<a name="ln1177">  for(i=k+1;i&lt;=n;i++)</a>
<a name="ln1178">    {</a>
<a name="ln1179">      /*</a>
<a name="ln1180">         As</a>
<a name="ln1181">           term_i = bincoef(n,i) * p^i * (1-p)^(n-i)</a>
<a name="ln1182">         and</a>
<a name="ln1183">           bincoef(n,i)/bincoef(n,i-1) = n-1+1 / i,</a>
<a name="ln1184">         then,</a>
<a name="ln1185">           term_i / term_i-1 = (n-i+1)/i * p/(1-p)</a>
<a name="ln1186">         and</a>
<a name="ln1187">           term_i = term_i-1 * (n-i+1)/i * p/(1-p).</a>
<a name="ln1188">         1/i is stored in a table as they are computed,</a>
<a name="ln1189">         because divisions are expensive.</a>
<a name="ln1190">         p/(1-p) is computed only once and stored in 'p_term'.</a>
<a name="ln1191">       */</a>
<a name="ln1192">      bin_term = (double) (n-i+1) * ( i&lt;TABSIZE ?</a>
<a name="ln1193">                   ( inv[i]!=0.0 ? inv[i] : ( inv[i] = 1.0 / (double) i ) ) :</a>
<a name="ln1194">                   1.0 / (double) i );</a>
<a name="ln1195"> </a>
<a name="ln1196">      mult_term = bin_term * p_term;</a>
<a name="ln1197">      term *= mult_term;</a>
<a name="ln1198">      bin_tail += term;</a>
<a name="ln1199">      if(bin_term&lt;1.0)</a>
<a name="ln1200">        {</a>
<a name="ln1201">          /* When bin_term&lt;1 then mult_term_j&lt;mult_term_i for j&gt;i.</a>
<a name="ln1202">             Then, the error on the binomial tail when truncated at</a>
<a name="ln1203">             the i term can be bounded by a geometric series of form</a>
<a name="ln1204">             term_i * sum mult_term_i^j.                            */</a>
<a name="ln1205">          err = term * ( ( 1.0 - pow( mult_term, (double) (n-i+1) ) ) /</a>
<a name="ln1206">                         (1.0-mult_term) - 1.0 );</a>
<a name="ln1207"> </a>
<a name="ln1208">          /* One wants an error at most of tolerance*final_result, or:</a>
<a name="ln1209">             tolerance * abs(-log10(bin_tail)-logNT).</a>
<a name="ln1210">             Now, the error that can be accepted on bin_tail is</a>
<a name="ln1211">             given by tolerance*final_result divided by the derivative</a>
<a name="ln1212">             of -log10(x) when x=bin_tail. that is:</a>
<a name="ln1213">             tolerance * abs(-log10(bin_tail)-logNT) / (1/bin_tail)</a>
<a name="ln1214">             Finally, we truncate the tail if the error is less than:</a>
<a name="ln1215">             tolerance * abs(-log10(bin_tail)-logNT) * bin_tail        */</a>
<a name="ln1216">          if( err &lt; tolerance * fabs(-log10(bin_tail)-logNT) * bin_tail ) break;</a>
<a name="ln1217">        }</a>
<a name="ln1218">    }</a>
<a name="ln1219">  return -log10(bin_tail) - logNT;</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222"> </a>
<a name="ln1223">/*----------------------------------------------------------------------------*/</a>
<a name="ln1224">/*--------------------------- Rectangle structure ----------------------------*/</a>
<a name="ln1225">/*----------------------------------------------------------------------------*/</a>
<a name="ln1226"> </a>
<a name="ln1227">/*----------------------------------------------------------------------------*/</a>
<a name="ln1228">/** Rectangle structure: line segment with width.</a>
<a name="ln1229"> */</a>
<a name="ln1230">struct rect</a>
<a name="ln1231">{</a>
<a name="ln1232">  double x1,y1,x2,y2;  /* first and second point of the line segment */</a>
<a name="ln1233">  double width;        /* rectangle width */</a>
<a name="ln1234">  double x,y;          /* center of the rectangle */</a>
<a name="ln1235">  double theta;        /* angle */</a>
<a name="ln1236">  double dx,dy;        /* (dx,dy) is vector oriented as the line segment */</a>
<a name="ln1237">  double prec;         /* tolerance angle */</a>
<a name="ln1238">  double p;            /* probability of a point with angle within 'prec' */</a>
<a name="ln1239">};</a>
<a name="ln1240"> </a>
<a name="ln1241">/*----------------------------------------------------------------------------*/</a>
<a name="ln1242">/** Copy one rectangle structure to another.</a>
<a name="ln1243"> */</a>
<a name="ln1244">static void rect_copy(struct rect * in, struct rect * out)</a>
<a name="ln1245">{</a>
<a name="ln1246">  /* check parameters */</a>
<a name="ln1247">  if( in == NULL || out == NULL ) error(&quot;rect_copy: invalid 'in' or 'out'.&quot;);</a>
<a name="ln1248"> </a>
<a name="ln1249">  /* copy values */</a>
<a name="ln1250">  out-&gt;x1 = in-&gt;x1;</a>
<a name="ln1251">  out-&gt;y1 = in-&gt;y1;</a>
<a name="ln1252">  out-&gt;x2 = in-&gt;x2;</a>
<a name="ln1253">  out-&gt;y2 = in-&gt;y2;</a>
<a name="ln1254">  out-&gt;width = in-&gt;width;</a>
<a name="ln1255">  out-&gt;x = in-&gt;x;</a>
<a name="ln1256">  out-&gt;y = in-&gt;y;</a>
<a name="ln1257">  out-&gt;theta = in-&gt;theta;</a>
<a name="ln1258">  out-&gt;dx = in-&gt;dx;</a>
<a name="ln1259">  out-&gt;dy = in-&gt;dy;</a>
<a name="ln1260">  out-&gt;prec = in-&gt;prec;</a>
<a name="ln1261">  out-&gt;p = in-&gt;p;</a>
<a name="ln1262">}</a>
<a name="ln1263"> </a>
<a name="ln1264">/*----------------------------------------------------------------------------*/</a>
<a name="ln1265">/** Rectangle points iterator.</a>
<a name="ln1266"> </a>
<a name="ln1267">    The integer coordinates of pixels inside a rectangle are</a>
<a name="ln1268">    iteratively explored. This structure keep track of the process and</a>
<a name="ln1269">    functions ri_ini(), ri_inc(), ri_end(), and ri_del() are used in</a>
<a name="ln1270">    the process. An example of how to use the iterator is as follows:</a>
<a name="ln1271">    \code</a>
<a name="ln1272"> </a>
<a name="ln1273">      struct rect * rec = XXX; // some rectangle</a>
<a name="ln1274">      rect_iter * i;</a>
<a name="ln1275">      for( i=ri_ini(rec); !ri_end(i); ri_inc(i) )</a>
<a name="ln1276">        {</a>
<a name="ln1277">          // your code, using 'i-&gt;x' and 'i-&gt;y' as coordinates</a>
<a name="ln1278">        }</a>
<a name="ln1279">      ri_del(i); // delete iterator</a>
<a name="ln1280"> </a>
<a name="ln1281">    \endcode</a>
<a name="ln1282">    The pixels are explored 'column' by 'column', where we call</a>
<a name="ln1283">    'column' a set of pixels with the same x value that are inside the</a>
<a name="ln1284">    rectangle. The following is an schematic representation of a</a>
<a name="ln1285">    rectangle, the 'column' being explored is marked by colons, and</a>
<a name="ln1286">    the current pixel being explored is 'x,y'.</a>
<a name="ln1287">    \verbatim</a>
<a name="ln1288"> </a>
<a name="ln1289">              vx[1],vy[1]</a>
<a name="ln1290">                 *   *</a>
<a name="ln1291">                *       *</a>
<a name="ln1292">               *           *</a>
<a name="ln1293">              *               ye</a>
<a name="ln1294">             *                :  *</a>
<a name="ln1295">        vx[0],vy[0]           :     *</a>
<a name="ln1296">               *              :        *</a>
<a name="ln1297">                  *          x,y          *</a>
<a name="ln1298">                     *        :              *</a>
<a name="ln1299">                        *     :            vx[2],vy[2]</a>
<a name="ln1300">                           *  :                *</a>
<a name="ln1301">        y                     ys              *</a>
<a name="ln1302">        ^                        *           *</a>
<a name="ln1303">        |                           *       *</a>
<a name="ln1304">        |                              *   *</a>
<a name="ln1305">        +---&gt; x                      vx[3],vy[3]</a>
<a name="ln1306"> </a>
<a name="ln1307">    \endverbatim</a>
<a name="ln1308">    The first 'column' to be explored is the one with the smaller x</a>
<a name="ln1309">    value. Each 'column' is explored starting from the pixel of the</a>
<a name="ln1310">    'column' (inside the rectangle) with the smallest y value.</a>
<a name="ln1311"> </a>
<a name="ln1312">    The four corners of the rectangle are stored in order that rotates</a>
<a name="ln1313">    around the corners at the arrays 'vx[]' and 'vy[]'. The first</a>
<a name="ln1314">    point is always the one with smaller x value.</a>
<a name="ln1315"> </a>
<a name="ln1316">    'x' and 'y' are the coordinates of the pixel being explored. 'ys'</a>
<a name="ln1317">    and 'ye' are the start and end values of the current column being</a>
<a name="ln1318">    explored. So, 'ys' &lt; 'ye'.</a>
<a name="ln1319"> */</a>
<a name="ln1320">typedef struct</a>
<a name="ln1321">{</a>
<a name="ln1322">  double vx[4];  /* rectangle's corner X coordinates in circular order */</a>
<a name="ln1323">  double vy[4];  /* rectangle's corner Y coordinates in circular order */</a>
<a name="ln1324">  double ys,ye;  /* start and end Y values of current 'column' */</a>
<a name="ln1325">  int x,y;       /* coordinates of currently explored pixel */</a>
<a name="ln1326">} rect_iter;</a>
<a name="ln1327"> </a>
<a name="ln1328">/*----------------------------------------------------------------------------*/</a>
<a name="ln1329">/** Interpolate y value corresponding to 'x' value given, in</a>
<a name="ln1330">    the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the smaller</a>
<a name="ln1331">    of 'y1' and 'y2'.</a>
<a name="ln1332"> </a>
<a name="ln1333">    The following restrictions are required:</a>
<a name="ln1334">    - x1 &lt;= x2</a>
<a name="ln1335">    - x1 &lt;= x</a>
<a name="ln1336">    - x  &lt;= x2</a>
<a name="ln1337"> */</a>
<a name="ln1338">static double inter_low(double x, double x1, double y1, double x2, double y2)</a>
<a name="ln1339">{</a>
<a name="ln1340">  /* check parameters */</a>
<a name="ln1341">  if( x1 &gt; x2 || x &lt; x1 || x &gt; x2 )</a>
<a name="ln1342">    error(&quot;inter_low: unsuitable input, 'x1&gt;x2' or 'x&lt;x1' or 'x&gt;x2'.&quot;);</a>
<a name="ln1343"> </a>
<a name="ln1344">  /* interpolation */</a>
<a name="ln1345">  if( double_equal(x1,x2) &amp;&amp; y1&lt;y2 ) return y1;</a>
<a name="ln1346">  if( double_equal(x1,x2) &amp;&amp; y1&gt;y2 ) return y2;</a>
<a name="ln1347">  return y1 + (x-x1) * (y2-y1) / (x2-x1);</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350">/*----------------------------------------------------------------------------*/</a>
<a name="ln1351">/** Interpolate y value corresponding to 'x' value given, in</a>
<a name="ln1352">    the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the larger</a>
<a name="ln1353">    of 'y1' and 'y2'.</a>
<a name="ln1354"> </a>
<a name="ln1355">    The following restrictions are required:</a>
<a name="ln1356">    - x1 &lt;= x2</a>
<a name="ln1357">    - x1 &lt;= x</a>
<a name="ln1358">    - x  &lt;= x2</a>
<a name="ln1359"> */</a>
<a name="ln1360">static double inter_hi(double x, double x1, double y1, double x2, double y2)</a>
<a name="ln1361">{</a>
<a name="ln1362">  /* check parameters */</a>
<a name="ln1363">  if( x1 &gt; x2 || x &lt; x1 || x &gt; x2 )</a>
<a name="ln1364">    error(&quot;inter_hi: unsuitable input, 'x1&gt;x2' or 'x&lt;x1' or 'x&gt;x2'.&quot;);</a>
<a name="ln1365"> </a>
<a name="ln1366">  /* interpolation */</a>
<a name="ln1367">  if( double_equal(x1,x2) &amp;&amp; y1&lt;y2 ) return y2;</a>
<a name="ln1368">  if( double_equal(x1,x2) &amp;&amp; y1&gt;y2 ) return y1;</a>
<a name="ln1369">  return y1 + (x-x1) * (y2-y1) / (x2-x1);</a>
<a name="ln1370">}</a>
<a name="ln1371"> </a>
<a name="ln1372">/*----------------------------------------------------------------------------*/</a>
<a name="ln1373">/** Free memory used by a rectangle iterator.</a>
<a name="ln1374"> */</a>
<a name="ln1375">static void ri_del(rect_iter * iter)</a>
<a name="ln1376">{</a>
<a name="ln1377">  if( iter == NULL ) error(&quot;ri_del: NULL iterator.&quot;);</a>
<a name="ln1378">  free( (void *) iter );</a>
<a name="ln1379">}</a>
<a name="ln1380"> </a>
<a name="ln1381">/*----------------------------------------------------------------------------*/</a>
<a name="ln1382">/** Check if the iterator finished the full iteration.</a>
<a name="ln1383"> </a>
<a name="ln1384">    See details in \ref rect_iter</a>
<a name="ln1385"> */</a>
<a name="ln1386">static int ri_end(rect_iter * i)</a>
<a name="ln1387">{</a>
<a name="ln1388">  /* check input */</a>
<a name="ln1389">  if( i == NULL ) error(&quot;ri_end: NULL iterator.&quot;);</a>
<a name="ln1390"> </a>
<a name="ln1391">  /* if the current x value is larger than the largest</a>
<a name="ln1392">     x value in the rectangle (vx[2]), we know the full</a>
<a name="ln1393">     exploration of the rectangle is finished. */</a>
<a name="ln1394">  return (double)(i-&gt;x) &gt; i-&gt;vx[2];</a>
<a name="ln1395">}</a>
<a name="ln1396"> </a>
<a name="ln1397">/*----------------------------------------------------------------------------*/</a>
<a name="ln1398">/** Increment a rectangle iterator.</a>
<a name="ln1399"> </a>
<a name="ln1400">    See details in \ref rect_iter</a>
<a name="ln1401"> */</a>
<a name="ln1402">static void ri_inc(rect_iter * i)</a>
<a name="ln1403">{</a>
<a name="ln1404">  /* check input */</a>
<a name="ln1405">  if( i == NULL ) error(&quot;ri_inc: NULL iterator.&quot;);</a>
<a name="ln1406"> </a>
<a name="ln1407">  /* if not at end of exploration,</a>
<a name="ln1408">     increase y value for next pixel in the 'column' */</a>
<a name="ln1409">  if( !ri_end(i) ) i-&gt;y++;</a>
<a name="ln1410"> </a>
<a name="ln1411">  /* if the end of the current 'column' is reached,</a>
<a name="ln1412">     and it is not the end of exploration,</a>
<a name="ln1413">     advance to the next 'column' */</a>
<a name="ln1414">  while( (double) (i-&gt;y) &gt; i-&gt;ye &amp;&amp; !ri_end(i) )</a>
<a name="ln1415">    {</a>
<a name="ln1416">      /* increase x, next 'column' */</a>
<a name="ln1417">      i-&gt;x++;</a>
<a name="ln1418"> </a>
<a name="ln1419">      /* if end of exploration, return */</a>
<a name="ln1420">      if( ri_end(i) ) return;</a>
<a name="ln1421"> </a>
<a name="ln1422">      /* update lower y limit (start) for the new 'column'.</a>
<a name="ln1423"> </a>
<a name="ln1424">         We need to interpolate the y value that corresponds to the</a>
<a name="ln1425">         lower side of the rectangle. The first thing is to decide if</a>
<a name="ln1426">         the corresponding side is</a>
<a name="ln1427"> </a>
<a name="ln1428">           vx[0],vy[0] to vx[3],vy[3] or</a>
<a name="ln1429">           vx[3],vy[3] to vx[2],vy[2]</a>
<a name="ln1430"> </a>
<a name="ln1431">         Then, the side is interpolated for the x value of the</a>
<a name="ln1432">         'column'. But, if the side is vertical (as it could happen if</a>
<a name="ln1433">         the rectangle is vertical and we are dealing with the first</a>
<a name="ln1434">         or last 'columns') then we pick the lower value of the side</a>
<a name="ln1435">         by using 'inter_low'.</a>
<a name="ln1436">       */</a>
<a name="ln1437">      if( (double) i-&gt;x &lt; i-&gt;vx[3] )</a>
<a name="ln1438">        i-&gt;ys = inter_low((double)i-&gt;x,i-&gt;vx[0],i-&gt;vy[0],i-&gt;vx[3],i-&gt;vy[3]);</a>
<a name="ln1439">      else</a>
<a name="ln1440">        i-&gt;ys = inter_low((double)i-&gt;x,i-&gt;vx[3],i-&gt;vy[3],i-&gt;vx[2],i-&gt;vy[2]);</a>
<a name="ln1441"> </a>
<a name="ln1442">      /* update upper y limit (end) for the new 'column'.</a>
<a name="ln1443"> </a>
<a name="ln1444">         We need to interpolate the y value that corresponds to the</a>
<a name="ln1445">         upper side of the rectangle. The first thing is to decide if</a>
<a name="ln1446">         the corresponding side is</a>
<a name="ln1447"> </a>
<a name="ln1448">           vx[0],vy[0] to vx[1],vy[1] or</a>
<a name="ln1449">           vx[1],vy[1] to vx[2],vy[2]</a>
<a name="ln1450"> </a>
<a name="ln1451">         Then, the side is interpolated for the x value of the</a>
<a name="ln1452">         'column'. But, if the side is vertical (as it could happen if</a>
<a name="ln1453">         the rectangle is vertical and we are dealing with the first</a>
<a name="ln1454">         or last 'columns') then we pick the lower value of the side</a>
<a name="ln1455">         by using 'inter_low'.</a>
<a name="ln1456">       */</a>
<a name="ln1457">      if( (double)i-&gt;x &lt; i-&gt;vx[1] )</a>
<a name="ln1458">        i-&gt;ye = inter_hi((double)i-&gt;x,i-&gt;vx[0],i-&gt;vy[0],i-&gt;vx[1],i-&gt;vy[1]);</a>
<a name="ln1459">      else</a>
<a name="ln1460">        i-&gt;ye = inter_hi((double)i-&gt;x,i-&gt;vx[1],i-&gt;vy[1],i-&gt;vx[2],i-&gt;vy[2]);</a>
<a name="ln1461"> </a>
<a name="ln1462">      /* new y */</a>
<a name="ln1463">      i-&gt;y = (int) ceil(i-&gt;ys);</a>
<a name="ln1464">    }</a>
<a name="ln1465">}</a>
<a name="ln1466"> </a>
<a name="ln1467">/*----------------------------------------------------------------------------*/</a>
<a name="ln1468">/** Create and initialize a rectangle iterator.</a>
<a name="ln1469"> </a>
<a name="ln1470">    See details in \ref rect_iter</a>
<a name="ln1471"> */</a>
<a name="ln1472">static rect_iter * ri_ini(struct rect * r)</a>
<a name="ln1473">{</a>
<a name="ln1474">  double vx[4],vy[4];</a>
<a name="ln1475">  int n,offset;</a>
<a name="ln1476">  rect_iter * i;</a>
<a name="ln1477"> </a>
<a name="ln1478">  /* check parameters */</a>
<a name="ln1479">  if( r == NULL ) error(&quot;ri_ini: invalid rectangle.&quot;);</a>
<a name="ln1480"> </a>
<a name="ln1481">  /* get memory */</a>
<a name="ln1482">  i = (rect_iter *) malloc(sizeof(rect_iter));</a>
<a name="ln1483">  if( i == NULL ) error(&quot;ri_ini: Not enough memory.&quot;);</a>
<a name="ln1484"> </a>
<a name="ln1485">  /* build list of rectangle corners ordered</a>
<a name="ln1486">     in a circular way around the rectangle */</a>
<a name="ln1487">  vx[0] = r-&gt;x1 - r-&gt;dy * r-&gt;width / 2.0;</a>
<a name="ln1488">  vy[0] = r-&gt;y1 + r-&gt;dx * r-&gt;width / 2.0;</a>
<a name="ln1489">  vx[1] = r-&gt;x2 - r-&gt;dy * r-&gt;width / 2.0;</a>
<a name="ln1490">  vy[1] = r-&gt;y2 + r-&gt;dx * r-&gt;width / 2.0;</a>
<a name="ln1491">  vx[2] = r-&gt;x2 + r-&gt;dy * r-&gt;width / 2.0;</a>
<a name="ln1492">  vy[2] = r-&gt;y2 - r-&gt;dx * r-&gt;width / 2.0;</a>
<a name="ln1493">  vx[3] = r-&gt;x1 + r-&gt;dy * r-&gt;width / 2.0;</a>
<a name="ln1494">  vy[3] = r-&gt;y1 - r-&gt;dx * r-&gt;width / 2.0;</a>
<a name="ln1495"> </a>
<a name="ln1496">  /* compute rotation of index of corners needed so that the first</a>
<a name="ln1497">     point has the smaller x.</a>
<a name="ln1498"> </a>
<a name="ln1499">     if one side is vertical, thus two corners have the same smaller x</a>
<a name="ln1500">     value, the one with the largest y value is selected as the first.</a>
<a name="ln1501">   */</a>
<a name="ln1502">  if( r-&gt;x1 &lt; r-&gt;x2 &amp;&amp; r-&gt;y1 &lt;= r-&gt;y2 ) offset = 0;</a>
<a name="ln1503">  else if( r-&gt;x1 &gt;= r-&gt;x2 &amp;&amp; r-&gt;y1 &lt; r-&gt;y2 ) offset = 1;</a>
<a name="ln1504">  else if( r-&gt;x1 &gt; r-&gt;x2 &amp;&amp; r-&gt;y1 &gt;= r-&gt;y2 ) offset = 2;</a>
<a name="ln1505">  else offset = 3;</a>
<a name="ln1506"> </a>
<a name="ln1507">  /* apply rotation of index. */</a>
<a name="ln1508">  for(n=0; n&lt;4; n++)</a>
<a name="ln1509">    {</a>
<a name="ln1510">      i-&gt;vx[n] = vx[(offset+n)%4];</a>
<a name="ln1511">      i-&gt;vy[n] = vy[(offset+n)%4];</a>
<a name="ln1512">    }</a>
<a name="ln1513"> </a>
<a name="ln1514">  /* Set an initial condition.</a>
<a name="ln1515"> </a>
<a name="ln1516">     The values are set to values that will cause 'ri_inc' (that will</a>
<a name="ln1517">     be called immediately) to initialize correctly the first 'column'</a>
<a name="ln1518">     and compute the limits 'ys' and 'ye'.</a>
<a name="ln1519"> </a>
<a name="ln1520">     'y' is set to the integer value of vy[0], the starting corner.</a>
<a name="ln1521"> </a>
<a name="ln1522">     'ys' and 'ye' are set to very small values, so 'ri_inc' will</a>
<a name="ln1523">     notice that it needs to start a new 'column'.</a>
<a name="ln1524"> </a>
<a name="ln1525">     The smallest integer coordinate inside of the rectangle is</a>
<a name="ln1526">     'ceil(vx[0])'. The current 'x' value is set to that value minus</a>
<a name="ln1527">     one, so 'ri_inc' (that will increase x by one) will advance to</a>
<a name="ln1528">     the first 'column'.</a>
<a name="ln1529">   */</a>
<a name="ln1530">  i-&gt;x = (int) ceil(i-&gt;vx[0]) - 1;</a>
<a name="ln1531">  i-&gt;y = (int) ceil(i-&gt;vy[0]);</a>
<a name="ln1532">  i-&gt;ys = i-&gt;ye = -DBL_MAX;</a>
<a name="ln1533"> </a>
<a name="ln1534">  /* advance to the first pixel */</a>
<a name="ln1535">  ri_inc(i);</a>
<a name="ln1536"> </a>
<a name="ln1537">  return i;</a>
<a name="ln1538">}</a>
<a name="ln1539"> </a>
<a name="ln1540">/*----------------------------------------------------------------------------*/</a>
<a name="ln1541">/** Compute a rectangle's NFA value.</a>
<a name="ln1542"> */</a>
<a name="ln1543">static double rect_nfa(struct rect * rec, image_double angles, double logNT)</a>
<a name="ln1544">{</a>
<a name="ln1545">  rect_iter * i;</a>
<a name="ln1546">  int pts = 0;</a>
<a name="ln1547">  int alg = 0;</a>
<a name="ln1548"> </a>
<a name="ln1549">  /* check parameters */</a>
<a name="ln1550">  if( rec == NULL ) error(&quot;rect_nfa: invalid rectangle.&quot;);</a>
<a name="ln1551">  if( angles == NULL ) error(&quot;rect_nfa: invalid 'angles'.&quot;);</a>
<a name="ln1552"> </a>
<a name="ln1553">  /* compute the total number of pixels and of aligned points in 'rec' */</a>
<a name="ln1554">  for(i=ri_ini(rec); !ri_end(i); ri_inc(i)) /* rectangle iterator */</a>
<a name="ln1555">    if( i-&gt;x &gt;= 0 &amp;&amp; i-&gt;y &gt;= 0 &amp;&amp;</a>
<a name="ln1556">        i-&gt;x &lt; (int) angles-&gt;xsize &amp;&amp; i-&gt;y &lt; (int) angles-&gt;ysize )</a>
<a name="ln1557">      {</a>
<a name="ln1558">        ++pts; /* total number of pixels counter */</a>
<a name="ln1559">        if( isaligned(i-&gt;x, i-&gt;y, angles, rec-&gt;theta, rec-&gt;prec) )</a>
<a name="ln1560">          ++alg; /* aligned points counter */</a>
<a name="ln1561">      }</a>
<a name="ln1562">  ri_del(i); /* delete iterator */</a>
<a name="ln1563"> </a>
<a name="ln1564">  return nfa(pts,alg,rec-&gt;p,logNT); /* compute NFA value */</a>
<a name="ln1565">}</a>
<a name="ln1566"> </a>
<a name="ln1567"> </a>
<a name="ln1568">/*----------------------------------------------------------------------------*/</a>
<a name="ln1569">/*---------------------------------- Regions ---------------------------------*/</a>
<a name="ln1570">/*----------------------------------------------------------------------------*/</a>
<a name="ln1571"> </a>
<a name="ln1572">/*----------------------------------------------------------------------------*/</a>
<a name="ln1573">/** Compute region's angle as the principal inertia axis of the region.</a>
<a name="ln1574"> </a>
<a name="ln1575">    The following is the region inertia matrix A:</a>
<a name="ln1576">    @f[</a>
<a name="ln1577"> </a>
<a name="ln1578">        A = \left(\begin{array}{cc}</a>
<a name="ln1579">                                    Ixx &amp; Ixy \\</a>
<a name="ln1580">                                    Ixy &amp; Iyy \\</a>
<a name="ln1581">             \end{array}\right)</a>
<a name="ln1582"> </a>
<a name="ln1583">    @f]</a>
<a name="ln1584">    where</a>
<a name="ln1585"> </a>
<a name="ln1586">      Ixx =   sum_i G(i).(y_i - cx)^2</a>
<a name="ln1587"> </a>
<a name="ln1588">      Iyy =   sum_i G(i).(x_i - cy)^2</a>
<a name="ln1589"> </a>
<a name="ln1590">      Ixy = - sum_i G(i).(x_i - cx).(y_i - cy)</a>
<a name="ln1591"> </a>
<a name="ln1592">    and</a>
<a name="ln1593">    - G(i) is the gradient norm at pixel i, used as pixel's weight.</a>
<a name="ln1594">    - x_i and y_i are the coordinates of pixel i.</a>
<a name="ln1595">    - cx and cy are the coordinates of the center of th region.</a>
<a name="ln1596"> </a>
<a name="ln1597">    lambda1 and lambda2 are the eigenvalues of matrix A,</a>
<a name="ln1598">    with lambda1 &gt;= lambda2. They are found by solving the</a>
<a name="ln1599">    characteristic polynomial:</a>
<a name="ln1600"> </a>
<a name="ln1601">      det( lambda I - A) = 0</a>
<a name="ln1602"> </a>
<a name="ln1603">    that gives:</a>
<a name="ln1604"> </a>
<a name="ln1605">      lambda1 = ( Ixx + Iyy + sqrt( (Ixx-Iyy)^2 + 4.0*Ixy*Ixy) ) / 2</a>
<a name="ln1606"> </a>
<a name="ln1607">      lambda2 = ( Ixx + Iyy - sqrt( (Ixx-Iyy)^2 + 4.0*Ixy*Ixy) ) / 2</a>
<a name="ln1608"> </a>
<a name="ln1609">    To get the line segment direction we want to get the angle the</a>
<a name="ln1610">    eigenvector associated to the smallest eigenvalue. We have</a>
<a name="ln1611">    to solve for a,b in:</a>
<a name="ln1612"> </a>
<a name="ln1613">      a.Ixx + b.Ixy = a.lambda2</a>
<a name="ln1614"> </a>
<a name="ln1615">      a.Ixy + b.Iyy = b.lambda2</a>
<a name="ln1616"> </a>
<a name="ln1617">    We want the angle theta = atan(b/a). It can be computed with</a>
<a name="ln1618">    any of the two equations:</a>
<a name="ln1619"> </a>
<a name="ln1620">      theta = atan( (lambda2-Ixx) / Ixy )</a>
<a name="ln1621"> </a>
<a name="ln1622">    or</a>
<a name="ln1623"> </a>
<a name="ln1624">      theta = atan( Ixy / (lambda2-Iyy) )</a>
<a name="ln1625"> </a>
<a name="ln1626">    When |Ixx| &gt; |Iyy| we use the first, otherwise the second (just to</a>
<a name="ln1627">    get better numeric precision).</a>
<a name="ln1628"> */</a>
<a name="ln1629">static double get_theta( struct point * reg, int reg_size, double x, double y,</a>
<a name="ln1630">                         image_double modgrad, double reg_angle, double prec )</a>
<a name="ln1631">{</a>
<a name="ln1632">  double lambda,theta,weight;</a>
<a name="ln1633">  double Ixx = 0.0;</a>
<a name="ln1634">  double Iyy = 0.0;</a>
<a name="ln1635">  double Ixy = 0.0;</a>
<a name="ln1636">  int i;</a>
<a name="ln1637"> </a>
<a name="ln1638">  /* check parameters */</a>
<a name="ln1639">  if( reg == NULL ) error(&quot;get_theta: invalid region.&quot;);</a>
<a name="ln1640">  if( reg_size &lt;= 1 ) error(&quot;get_theta: region size &lt;= 1.&quot;);</a>
<a name="ln1641">  if( modgrad == NULL || modgrad-&gt;data == NULL )</a>
<a name="ln1642">    error(&quot;get_theta: invalid 'modgrad'.&quot;);</a>
<a name="ln1643">  if( prec &lt; 0.0 ) error(&quot;get_theta: 'prec' must be positive.&quot;);</a>
<a name="ln1644"> </a>
<a name="ln1645">  /* compute inertia matrix */</a>
<a name="ln1646">  for(i=0; i&lt;reg_size; i++)</a>
<a name="ln1647">    {</a>
<a name="ln1648">      weight = modgrad-&gt;data[ reg[i].x + reg[i].y * modgrad-&gt;xsize ];</a>
<a name="ln1649">      Ixx += ( (double) reg[i].y - y ) * ( (double) reg[i].y - y ) * weight;</a>
<a name="ln1650">      Iyy += ( (double) reg[i].x - x ) * ( (double) reg[i].x - x ) * weight;</a>
<a name="ln1651">      Ixy -= ( (double) reg[i].x - x ) * ( (double) reg[i].y - y ) * weight;</a>
<a name="ln1652">    }</a>
<a name="ln1653">  if( double_equal(Ixx,0.0) &amp;&amp; double_equal(Iyy,0.0) &amp;&amp; double_equal(Ixy,0.0) )</a>
<a name="ln1654">    error(&quot;get_theta: null inertia matrix.&quot;);</a>
<a name="ln1655"> </a>
<a name="ln1656">  /* compute smallest eigenvalue */</a>
<a name="ln1657">  lambda = 0.5 * ( Ixx + Iyy - sqrt( (Ixx-Iyy)*(Ixx-Iyy) + 4.0*Ixy*Ixy ) );</a>
<a name="ln1658"> </a>
<a name="ln1659">  /* compute angle */</a>
<a name="ln1660">  theta = fabs(Ixx)&gt;fabs(Iyy) ? atan2(lambda-Ixx,Ixy) : atan2(Ixy,lambda-Iyy);</a>
<a name="ln1661"> </a>
<a name="ln1662">  /* The previous procedure doesn't cares about orientation,</a>
<a name="ln1663">     so it could be wrong by 180 degrees. Here is corrected if necessary. */</a>
<a name="ln1664">  if( angle_diff(theta,reg_angle) &gt; prec ) theta += M_PI;</a>
<a name="ln1665"> </a>
<a name="ln1666">  return theta;</a>
<a name="ln1667">}</a>
<a name="ln1668"> </a>
<a name="ln1669">/*----------------------------------------------------------------------------*/</a>
<a name="ln1670">/** Computes a rectangle that covers a region of points.</a>
<a name="ln1671"> */</a>
<a name="ln1672">static void region2rect( struct point * reg, int reg_size,</a>
<a name="ln1673">                         image_double modgrad, double reg_angle,</a>
<a name="ln1674">                         double prec, double p, struct rect * rec )</a>
<a name="ln1675">{</a>
<a name="ln1676">  double x,y,dx,dy,l,w,theta,weight,sum,l_min,l_max,w_min,w_max;</a>
<a name="ln1677">  int i;</a>
<a name="ln1678"> </a>
<a name="ln1679">  /* check parameters */</a>
<a name="ln1680">  if( reg == NULL ) error(&quot;region2rect: invalid region.&quot;);</a>
<a name="ln1681">  if( reg_size &lt;= 1 ) error(&quot;region2rect: region size &lt;= 1.&quot;);</a>
<a name="ln1682">  if( modgrad == NULL || modgrad-&gt;data == NULL )</a>
<a name="ln1683">    error(&quot;region2rect: invalid image 'modgrad'.&quot;);</a>
<a name="ln1684">  if( rec == NULL ) error(&quot;region2rect: invalid 'rec'.&quot;);</a>
<a name="ln1685"> </a>
<a name="ln1686">  /* center of the region:</a>
<a name="ln1687"> </a>
<a name="ln1688">     It is computed as the weighted sum of the coordinates</a>
<a name="ln1689">     of all the pixels in the region. The norm of the gradient</a>
<a name="ln1690">     is used as the weight of a pixel. The sum is as follows:</a>
<a name="ln1691">       cx = \sum_i G(i).x_i</a>
<a name="ln1692">       cy = \sum_i G(i).y_i</a>
<a name="ln1693">     where G(i) is the norm of the gradient of pixel i</a>
<a name="ln1694">     and x_i,y_i are its coordinates.</a>
<a name="ln1695">   */</a>
<a name="ln1696">  x = y = sum = 0.0;</a>
<a name="ln1697">  for(i=0; i&lt;reg_size; i++)</a>
<a name="ln1698">    {</a>
<a name="ln1699">      weight = modgrad-&gt;data[ reg[i].x + reg[i].y * modgrad-&gt;xsize ];</a>
<a name="ln1700">      x += (double) reg[i].x * weight;</a>
<a name="ln1701">      y += (double) reg[i].y * weight;</a>
<a name="ln1702">      sum += weight;</a>
<a name="ln1703">    }</a>
<a name="ln1704">  if( sum &lt;= 0.0 ) error(&quot;region2rect: weights sum equal to zero.&quot;);</a>
<a name="ln1705">  x /= sum;</a>
<a name="ln1706">  y /= sum;</a>
<a name="ln1707"> </a>
<a name="ln1708">  /* theta */</a>
<a name="ln1709">  theta = get_theta(reg,reg_size,x,y,modgrad,reg_angle,prec);</a>
<a name="ln1710"> </a>
<a name="ln1711">  /* length and width:</a>
<a name="ln1712"> </a>
<a name="ln1713">     'l' and 'w' are computed as the distance from the center of the</a>
<a name="ln1714">     region to pixel i, projected along the rectangle axis (dx,dy) and</a>
<a name="ln1715">     to the orthogonal axis (-dy,dx), respectively.</a>
<a name="ln1716"> </a>
<a name="ln1717">     The length of the rectangle goes from l_min to l_max, where l_min</a>
<a name="ln1718">     and l_max are the minimum and maximum values of l in the region.</a>
<a name="ln1719">     Analogously, the width is selected from w_min to w_max, where</a>
<a name="ln1720">     w_min and w_max are the minimum and maximum of w for the pixels</a>
<a name="ln1721">     in the region.</a>
<a name="ln1722">   */</a>
<a name="ln1723">  dx = cos(theta);</a>
<a name="ln1724">  dy = sin(theta);</a>
<a name="ln1725">  l_min = l_max = w_min = w_max = 0.0;</a>
<a name="ln1726">  for(i=0; i&lt;reg_size; i++)</a>
<a name="ln1727">    {</a>
<a name="ln1728">      l =  ( (double) reg[i].x - x) * dx + ( (double) reg[i].y - y) * dy;</a>
<a name="ln1729">      w = -( (double) reg[i].x - x) * dy + ( (double) reg[i].y - y) * dx;</a>
<a name="ln1730"> </a>
<a name="ln1731">      if( l &gt; l_max ) l_max = l;</a>
<a name="ln1732">      if( l &lt; l_min ) l_min = l;</a>
<a name="ln1733">      if( w &gt; w_max ) w_max = w;</a>
<a name="ln1734">      if( w &lt; w_min ) w_min = w;</a>
<a name="ln1735">    }</a>
<a name="ln1736"> </a>
<a name="ln1737">  /* store values */</a>
<a name="ln1738">  rec-&gt;x1 = x + l_min * dx;</a>
<a name="ln1739">  rec-&gt;y1 = y + l_min * dy;</a>
<a name="ln1740">  rec-&gt;x2 = x + l_max * dx;</a>
<a name="ln1741">  rec-&gt;y2 = y + l_max * dy;</a>
<a name="ln1742">  rec-&gt;width = w_max - w_min;</a>
<a name="ln1743">  rec-&gt;x = x;</a>
<a name="ln1744">  rec-&gt;y = y;</a>
<a name="ln1745">  rec-&gt;theta = theta;</a>
<a name="ln1746">  rec-&gt;dx = dx;</a>
<a name="ln1747">  rec-&gt;dy = dy;</a>
<a name="ln1748">  rec-&gt;prec = prec;</a>
<a name="ln1749">  rec-&gt;p = p;</a>
<a name="ln1750"> </a>
<a name="ln1751">  /* we impose a minimal width of one pixel</a>
<a name="ln1752"> </a>
<a name="ln1753">     A sharp horizontal or vertical step would produce a perfectly</a>
<a name="ln1754">     horizontal or vertical region. The width computed would be</a>
<a name="ln1755">     zero. But that corresponds to a one pixels width transition in</a>
<a name="ln1756">     the image.</a>
<a name="ln1757">   */</a>
<a name="ln1758">  if( rec-&gt;width &lt; 1.0 ) rec-&gt;width = 1.0;</a>
<a name="ln1759">}</a>
<a name="ln1760"> </a>
<a name="ln1761">/*----------------------------------------------------------------------------*/</a>
<a name="ln1762">/** Build a region of pixels that share the same angle, up to a</a>
<a name="ln1763">    tolerance 'prec', starting at point (x,y).</a>
<a name="ln1764"> */</a>
<a name="ln1765">static void region_grow( int x, int y, image_double angles, struct point * reg,</a>
<a name="ln1766">                         int * reg_size, double * reg_angle, image_char used,</a>
<a name="ln1767">                         double prec )</a>
<a name="ln1768">{</a>
<a name="ln1769">  double sumdx,sumdy;</a>
<a name="ln1770">  int xx,yy,i;</a>
<a name="ln1771"> </a>
<a name="ln1772">  /* check parameters */</a>
<a name="ln1773">  if( x &lt; 0 || y &lt; 0 || x &gt;= (int) angles-&gt;xsize || y &gt;= (int) angles-&gt;ysize )</a>
<a name="ln1774">    error(&quot;region_grow: (x,y) out of the image.&quot;);</a>
<a name="ln1775">  if( angles == NULL || angles-&gt;data == NULL )</a>
<a name="ln1776">    error(&quot;region_grow: invalid image 'angles'.&quot;);</a>
<a name="ln1777">  if( reg == NULL ) error(&quot;region_grow: invalid 'reg'.&quot;);</a>
<a name="ln1778">  if( reg_size == NULL ) error(&quot;region_grow: invalid pointer 'reg_size'.&quot;);</a>
<a name="ln1779">  if( reg_angle == NULL ) error(&quot;region_grow: invalid pointer 'reg_angle'.&quot;);</a>
<a name="ln1780">  if( used == NULL || used-&gt;data == NULL )</a>
<a name="ln1781">    error(&quot;region_grow: invalid image 'used'.&quot;);</a>
<a name="ln1782"> </a>
<a name="ln1783">  /* first point of the region */</a>
<a name="ln1784">  *reg_size = 1;</a>
<a name="ln1785">  reg[0].x = x;</a>
<a name="ln1786">  reg[0].y = y;</a>
<a name="ln1787">  *reg_angle = angles-&gt;data[x+y*angles-&gt;xsize];  /* region's angle */</a>
<a name="ln1788">  sumdx = cos(*reg_angle);</a>
<a name="ln1789">  sumdy = sin(*reg_angle);</a>
<a name="ln1790">  used-&gt;data[x+y*used-&gt;xsize] = USED;</a>
<a name="ln1791"> </a>
<a name="ln1792">  /* try neighbors as new region points */</a>
<a name="ln1793">  for(i=0; i&lt;*reg_size; i++)</a>
<a name="ln1794">    for(xx=reg[i].x-1; xx&lt;=reg[i].x+1; xx++)</a>
<a name="ln1795">      for(yy=reg[i].y-1; yy&lt;=reg[i].y+1; yy++)</a>
<a name="ln1796">        if( xx&gt;=0 &amp;&amp; yy&gt;=0 &amp;&amp; xx&lt;(int)used-&gt;xsize &amp;&amp; yy&lt;(int)used-&gt;ysize &amp;&amp;</a>
<a name="ln1797">            used-&gt;data[xx+yy*used-&gt;xsize] != USED &amp;&amp;</a>
<a name="ln1798">            isaligned(xx,yy,angles,*reg_angle,prec) )</a>
<a name="ln1799">          {</a>
<a name="ln1800">            /* add point */</a>
<a name="ln1801">            used-&gt;data[xx+yy*used-&gt;xsize] = USED;</a>
<a name="ln1802">            reg[*reg_size].x = xx;</a>
<a name="ln1803">            reg[*reg_size].y = yy;</a>
<a name="ln1804">            ++(*reg_size);</a>
<a name="ln1805"> </a>
<a name="ln1806">            /* update region's angle */</a>
<a name="ln1807">            sumdx += cos( angles-&gt;data[xx+yy*angles-&gt;xsize] );</a>
<a name="ln1808">            sumdy += sin( angles-&gt;data[xx+yy*angles-&gt;xsize] );</a>
<a name="ln1809">            *reg_angle = atan2(sumdy,sumdx);</a>
<a name="ln1810">          }</a>
<a name="ln1811">}</a>
<a name="ln1812"> </a>
<a name="ln1813">/*----------------------------------------------------------------------------*/</a>
<a name="ln1814">/** Try some rectangles variations to improve NFA value. Only if the</a>
<a name="ln1815">    rectangle is not meaningful (i.e., log_nfa &lt;= log_eps).</a>
<a name="ln1816"> */</a>
<a name="ln1817">static double rect_improve( struct rect * rec, image_double angles,</a>
<a name="ln1818">                            double logNT, double log_eps )</a>
<a name="ln1819">{</a>
<a name="ln1820">  struct rect r;</a>
<a name="ln1821">  double log_nfa,log_nfa_new;</a>
<a name="ln1822">  double delta = 0.5;</a>
<a name="ln1823">  double delta_2 = delta / 2.0;</a>
<a name="ln1824">  int n;</a>
<a name="ln1825"> </a>
<a name="ln1826">  log_nfa = rect_nfa(rec,angles,logNT);</a>
<a name="ln1827"> </a>
<a name="ln1828">  if( log_nfa &gt; log_eps ) return log_nfa;</a>
<a name="ln1829"> </a>
<a name="ln1830">  /* try finer precisions */</a>
<a name="ln1831">  rect_copy(rec,&amp;r);</a>
<a name="ln1832">  for(n=0; n&lt;5; n++)</a>
<a name="ln1833">    {</a>
<a name="ln1834">      r.p /= 2.0;</a>
<a name="ln1835">      r.prec = r.p * M_PI;</a>
<a name="ln1836">      log_nfa_new = rect_nfa(&amp;r,angles,logNT);</a>
<a name="ln1837">      if( log_nfa_new &gt; log_nfa )</a>
<a name="ln1838">        {</a>
<a name="ln1839">          log_nfa = log_nfa_new;</a>
<a name="ln1840">          rect_copy(&amp;r,rec);</a>
<a name="ln1841">        }</a>
<a name="ln1842">    }</a>
<a name="ln1843"> </a>
<a name="ln1844">  if( log_nfa &gt; log_eps ) return log_nfa;</a>
<a name="ln1845"> </a>
<a name="ln1846">  /* try to reduce width */</a>
<a name="ln1847">  rect_copy(rec,&amp;r);</a>
<a name="ln1848">  for(n=0; n&lt;5; n++)</a>
<a name="ln1849">    {</a>
<a name="ln1850">      if( (r.width - delta) &gt;= 0.5 )</a>
<a name="ln1851">        {</a>
<a name="ln1852">          r.width -= delta;</a>
<a name="ln1853">          log_nfa_new = rect_nfa(&amp;r,angles,logNT);</a>
<a name="ln1854">          if( log_nfa_new &gt; log_nfa )</a>
<a name="ln1855">            {</a>
<a name="ln1856">              rect_copy(&amp;r,rec);</a>
<a name="ln1857">              log_nfa = log_nfa_new;</a>
<a name="ln1858">            }</a>
<a name="ln1859">        }</a>
<a name="ln1860">    }</a>
<a name="ln1861"> </a>
<a name="ln1862">  if( log_nfa &gt; log_eps ) return log_nfa;</a>
<a name="ln1863"> </a>
<a name="ln1864">  /* try to reduce one side of the rectangle */</a>
<a name="ln1865">  rect_copy(rec,&amp;r);</a>
<a name="ln1866">  for(n=0; n&lt;5; n++)</a>
<a name="ln1867">    {</a>
<a name="ln1868">      if( (r.width - delta) &gt;= 0.5 )</a>
<a name="ln1869">        {</a>
<a name="ln1870">          r.x1 += -r.dy * delta_2;</a>
<a name="ln1871">          r.y1 +=  r.dx * delta_2;</a>
<a name="ln1872">          r.x2 += -r.dy * delta_2;</a>
<a name="ln1873">          r.y2 +=  r.dx * delta_2;</a>
<a name="ln1874">          r.width -= delta;</a>
<a name="ln1875">          log_nfa_new = rect_nfa(&amp;r,angles,logNT);</a>
<a name="ln1876">          if( log_nfa_new &gt; log_nfa )</a>
<a name="ln1877">            {</a>
<a name="ln1878">              rect_copy(&amp;r,rec);</a>
<a name="ln1879">              log_nfa = log_nfa_new;</a>
<a name="ln1880">            }</a>
<a name="ln1881">        }</a>
<a name="ln1882">    }</a>
<a name="ln1883"> </a>
<a name="ln1884">  if( log_nfa &gt; log_eps ) return log_nfa;</a>
<a name="ln1885"> </a>
<a name="ln1886">  /* try to reduce the other side of the rectangle */</a>
<a name="ln1887">  rect_copy(rec,&amp;r);</a>
<a name="ln1888">  for(n=0; n&lt;5; n++)</a>
<a name="ln1889">    {</a>
<a name="ln1890">      if( (r.width - delta) &gt;= 0.5 )</a>
<a name="ln1891">        {</a>
<a name="ln1892">          r.x1 -= -r.dy * delta_2;</a>
<a name="ln1893">          r.y1 -=  r.dx * delta_2;</a>
<a name="ln1894">          r.x2 -= -r.dy * delta_2;</a>
<a name="ln1895">          r.y2 -=  r.dx * delta_2;</a>
<a name="ln1896">          r.width -= delta;</a>
<a name="ln1897">          log_nfa_new = rect_nfa(&amp;r,angles,logNT);</a>
<a name="ln1898">          if( log_nfa_new &gt; log_nfa )</a>
<a name="ln1899">            {</a>
<a name="ln1900">              rect_copy(&amp;r,rec);</a>
<a name="ln1901">              log_nfa = log_nfa_new;</a>
<a name="ln1902">            }</a>
<a name="ln1903">        }</a>
<a name="ln1904">    }</a>
<a name="ln1905"> </a>
<a name="ln1906">  if( log_nfa &gt; log_eps ) return log_nfa;</a>
<a name="ln1907"> </a>
<a name="ln1908">  /* try even finer precisions */</a>
<a name="ln1909">  rect_copy(rec,&amp;r);</a>
<a name="ln1910">  for(n=0; n&lt;5; n++)</a>
<a name="ln1911">    {</a>
<a name="ln1912">      r.p /= 2.0;</a>
<a name="ln1913">      r.prec = r.p * M_PI;</a>
<a name="ln1914">      log_nfa_new = rect_nfa(&amp;r,angles,logNT);</a>
<a name="ln1915">      if( log_nfa_new &gt; log_nfa )</a>
<a name="ln1916">        {</a>
<a name="ln1917">          log_nfa = log_nfa_new;</a>
<a name="ln1918">          rect_copy(&amp;r,rec);</a>
<a name="ln1919">        }</a>
<a name="ln1920">    }</a>
<a name="ln1921"> </a>
<a name="ln1922">  return log_nfa;</a>
<a name="ln1923">}</a>
<a name="ln1924"> </a>
<a name="ln1925">/*----------------------------------------------------------------------------*/</a>
<a name="ln1926">/** Reduce the region size, by elimination the points far from the</a>
<a name="ln1927">    starting point, until that leads to rectangle with the right</a>
<a name="ln1928">    density of region points or to discard the region if too small.</a>
<a name="ln1929"> */</a>
<a name="ln1930">static int reduce_region_radius( struct point * reg, int * reg_size,</a>
<a name="ln1931">                                 image_double modgrad, double reg_angle,</a>
<a name="ln1932">                                 double prec, double p, struct rect * rec,</a>
<a name="ln1933">                                 image_char used, image_double angles,</a>
<a name="ln1934">                                 double density_th )</a>
<a name="ln1935">{</a>
<a name="ln1936">  double density,radius1,radius2,rad,xc,yc;</a>
<a name="ln1937">  int i;</a>
<a name="ln1938"> </a>
<a name="ln1939">  /* check parameters */</a>
<a name="ln1940">  if( reg == NULL ) error(&quot;reduce_region_radius: invalid pointer 'reg'.&quot;);</a>
<a name="ln1941">  if( reg_size == NULL )</a>
<a name="ln1942">    error(&quot;reduce_region_radius: invalid pointer 'reg_size'.&quot;);</a>
<a name="ln1943">  if( prec &lt; 0.0 ) error(&quot;reduce_region_radius: 'prec' must be positive.&quot;);</a>
<a name="ln1944">  if( rec == NULL ) error(&quot;reduce_region_radius: invalid pointer 'rec'.&quot;);</a>
<a name="ln1945">  if( used == NULL || used-&gt;data == NULL )</a>
<a name="ln1946">    error(&quot;reduce_region_radius: invalid image 'used'.&quot;);</a>
<a name="ln1947">  if( angles == NULL || angles-&gt;data == NULL )</a>
<a name="ln1948">    error(&quot;reduce_region_radius: invalid image 'angles'.&quot;);</a>
<a name="ln1949"> </a>
<a name="ln1950">  /* compute region points density */</a>
<a name="ln1951">  density = (double) *reg_size /</a>
<a name="ln1952">                         ( dist(rec-&gt;x1,rec-&gt;y1,rec-&gt;x2,rec-&gt;y2) * rec-&gt;width );</a>
<a name="ln1953"> </a>
<a name="ln1954">  /* if the density criterion is satisfied there is nothing to do */</a>
<a name="ln1955">  if( density &gt;= density_th ) return TRUE;</a>
<a name="ln1956"> </a>
<a name="ln1957">  /* compute region's radius */</a>
<a name="ln1958">  xc = (double) reg[0].x;</a>
<a name="ln1959">  yc = (double) reg[0].y;</a>
<a name="ln1960">  radius1 = dist( xc, yc, rec-&gt;x1, rec-&gt;y1 );</a>
<a name="ln1961">  radius2 = dist( xc, yc, rec-&gt;x2, rec-&gt;y2 );</a>
<a name="ln1962">  rad = radius1 &gt; radius2 ? radius1 : radius2;</a>
<a name="ln1963"> </a>
<a name="ln1964">  /* while the density criterion is not satisfied, remove farther pixels */</a>
<a name="ln1965">  while( density &lt; density_th )</a>
<a name="ln1966">    {</a>
<a name="ln1967">      rad *= 0.75; /* reduce region's radius to 75% of its value */</a>
<a name="ln1968"> </a>
<a name="ln1969">      /* remove points from the region and update 'used' map */</a>
<a name="ln1970">      for(i=0; i&lt;*reg_size; i++)</a>
<a name="ln1971">        if( dist( xc, yc, (double) reg[i].x, (double) reg[i].y ) &gt; rad )</a>
<a name="ln1972">          {</a>
<a name="ln1973">            /* point not kept, mark it as NOTUSED */</a>
<a name="ln1974">            used-&gt;data[ reg[i].x + reg[i].y * used-&gt;xsize ] = NOTUSED;</a>
<a name="ln1975">            /* remove point from the region */</a>
<a name="ln1976">            reg[i].x = reg[*reg_size-1].x; /* if i==*reg_size-1 copy itself */</a>
<a name="ln1977">            reg[i].y = reg[*reg_size-1].y;</a>
<a name="ln1978">            --(*reg_size);</a>
<a name="ln1979">            --i; /* to avoid skipping one point */</a>
<a name="ln1980">          }</a>
<a name="ln1981"> </a>
<a name="ln1982">      /* reject if the region is too small.</a>
<a name="ln1983">         2 is the minimal region size for 'region2rect' to work. */</a>
<a name="ln1984">      if( *reg_size &lt; 2 ) return FALSE;</a>
<a name="ln1985"> </a>
<a name="ln1986">      /* re-compute rectangle */</a>
<a name="ln1987">      region2rect(reg,*reg_size,modgrad,reg_angle,prec,p,rec);</a>
<a name="ln1988"> </a>
<a name="ln1989">      /* re-compute region points density */</a>
<a name="ln1990">      density = (double) *reg_size /</a>
<a name="ln1991">                         ( dist(rec-&gt;x1,rec-&gt;y1,rec-&gt;x2,rec-&gt;y2) * rec-&gt;width );</a>
<a name="ln1992">    }</a>
<a name="ln1993"> </a>
<a name="ln1994">  /* if this point is reached, the density criterion is satisfied */</a>
<a name="ln1995">  return TRUE;</a>
<a name="ln1996">}</a>
<a name="ln1997"> </a>
<a name="ln1998">/*----------------------------------------------------------------------------*/</a>
<a name="ln1999">/** Refine a rectangle.</a>
<a name="ln2000"> </a>
<a name="ln2001">    For that, an estimation of the angle tolerance is performed by the</a>
<a name="ln2002">    standard deviation of the angle at points near the region's</a>
<a name="ln2003">    starting point. Then, a new region is grown starting from the same</a>
<a name="ln2004">    point, but using the estimated angle tolerance. If this fails to</a>
<a name="ln2005">    produce a rectangle with the right density of region points,</a>
<a name="ln2006">    'reduce_region_radius' is called to try to satisfy this condition.</a>
<a name="ln2007"> */</a>
<a name="ln2008">static int refine( struct point * reg, int * reg_size, image_double modgrad,</a>
<a name="ln2009">                   double reg_angle, double prec, double p, struct rect * rec,</a>
<a name="ln2010">                   image_char used, image_double angles, double density_th )</a>
<a name="ln2011">{</a>
<a name="ln2012">  double angle,ang_d,mean_angle,tau,density,xc,yc,ang_c,sum,s_sum;</a>
<a name="ln2013">  int i,n;</a>
<a name="ln2014"> </a>
<a name="ln2015">  /* check parameters */</a>
<a name="ln2016">  if( reg == NULL ) error(&quot;refine: invalid pointer 'reg'.&quot;);</a>
<a name="ln2017">  if( reg_size == NULL ) error(&quot;refine: invalid pointer 'reg_size'.&quot;);</a>
<a name="ln2018">  if( prec &lt; 0.0 ) error(&quot;refine: 'prec' must be positive.&quot;);</a>
<a name="ln2019">  if( rec == NULL ) error(&quot;refine: invalid pointer 'rec'.&quot;);</a>
<a name="ln2020">  if( used == NULL || used-&gt;data == NULL )</a>
<a name="ln2021">    error(&quot;refine: invalid image 'used'.&quot;);</a>
<a name="ln2022">  if( angles == NULL || angles-&gt;data == NULL )</a>
<a name="ln2023">    error(&quot;refine: invalid image 'angles'.&quot;);</a>
<a name="ln2024"> </a>
<a name="ln2025">  /* compute region points density */</a>
<a name="ln2026">  density = (double) *reg_size /</a>
<a name="ln2027">                         ( dist(rec-&gt;x1,rec-&gt;y1,rec-&gt;x2,rec-&gt;y2) * rec-&gt;width );</a>
<a name="ln2028"> </a>
<a name="ln2029">  /* if the density criterion is satisfied there is nothing to do */</a>
<a name="ln2030">  if( density &gt;= density_th ) return TRUE;</a>
<a name="ln2031"> </a>
<a name="ln2032">  /*------ First try: reduce angle tolerance ------*/</a>
<a name="ln2033"> </a>
<a name="ln2034">  /* compute the new mean angle and tolerance */</a>
<a name="ln2035">  xc = (double) reg[0].x;</a>
<a name="ln2036">  yc = (double) reg[0].y;</a>
<a name="ln2037">  ang_c = angles-&gt;data[ reg[0].x + reg[0].y * angles-&gt;xsize ];</a>
<a name="ln2038">  sum = s_sum = 0.0;</a>
<a name="ln2039">  n = 0;</a>
<a name="ln2040">  for(i=0; i&lt;*reg_size; i++)</a>
<a name="ln2041">    {</a>
<a name="ln2042">      used-&gt;data[ reg[i].x + reg[i].y * used-&gt;xsize ] = NOTUSED;</a>
<a name="ln2043">      if( dist( xc, yc, (double) reg[i].x, (double) reg[i].y ) &lt; rec-&gt;width )</a>
<a name="ln2044">        {</a>
<a name="ln2045">          angle = angles-&gt;data[ reg[i].x + reg[i].y * angles-&gt;xsize ];</a>
<a name="ln2046">          ang_d = angle_diff_signed(angle,ang_c);</a>
<a name="ln2047">          sum += ang_d;</a>
<a name="ln2048">          s_sum += ang_d * ang_d;</a>
<a name="ln2049">          ++n;</a>
<a name="ln2050">        }</a>
<a name="ln2051">    }</a>
<a name="ln2052"> </a>
<a name="ln2053">  /* should not happen */</a>
<a name="ln2054">  if(n == 0) return FALSE;</a>
<a name="ln2055"> </a>
<a name="ln2056">  mean_angle = sum / (double) n;</a>
<a name="ln2057">  tau = 2.0 * sqrt( (s_sum - 2.0 * mean_angle * sum) / (double) n</a>
<a name="ln2058">                         + mean_angle*mean_angle ); /* 2 * standard deviation */</a>
<a name="ln2059"> </a>
<a name="ln2060">  /* find a new region from the same starting point and new angle tolerance */</a>
<a name="ln2061">  region_grow(reg[0].x,reg[0].y,angles,reg,reg_size,&amp;reg_angle,used,tau);</a>
<a name="ln2062"> </a>
<a name="ln2063">  /* if the region is too small, reject */</a>
<a name="ln2064">  if( *reg_size &lt; 2 ) return FALSE;</a>
<a name="ln2065"> </a>
<a name="ln2066">  /* re-compute rectangle */</a>
<a name="ln2067">  region2rect(reg,*reg_size,modgrad,reg_angle,prec,p,rec);</a>
<a name="ln2068"> </a>
<a name="ln2069">  /* re-compute region points density */</a>
<a name="ln2070">  density = (double) *reg_size /</a>
<a name="ln2071">                      ( dist(rec-&gt;x1,rec-&gt;y1,rec-&gt;x2,rec-&gt;y2) * rec-&gt;width );</a>
<a name="ln2072"> </a>
<a name="ln2073">  /*------ Second try: reduce region radius ------*/</a>
<a name="ln2074">  if( density &lt; density_th )</a>
<a name="ln2075">    return reduce_region_radius( reg, reg_size, modgrad, reg_angle, prec, p,</a>
<a name="ln2076">                                 rec, used, angles, density_th );</a>
<a name="ln2077"> </a>
<a name="ln2078">  /* if this point is reached, the density criterion is satisfied */</a>
<a name="ln2079">  return TRUE;</a>
<a name="ln2080">}</a>
<a name="ln2081"> </a>
<a name="ln2082"> </a>
<a name="ln2083">/*----------------------------------------------------------------------------*/</a>
<a name="ln2084">/*-------------------------- Line Segment Detector ---------------------------*/</a>
<a name="ln2085">/*----------------------------------------------------------------------------*/</a>
<a name="ln2086"> </a>
<a name="ln2087">/*----------------------------------------------------------------------------*/</a>
<a name="ln2088">/** LSD full interface.</a>
<a name="ln2089"> */</a>
<a name="ln2090">static</a>
<a name="ln2091">double * LineSegmentDetection( int * n_out,</a>
<a name="ln2092">                               double * img, int X, int Y,</a>
<a name="ln2093">                               double scale, double sigma_scale, double quant,</a>
<a name="ln2094">                               double ang_th, double log_eps, double density_th,</a>
<a name="ln2095">                               int n_bins,</a>
<a name="ln2096">                               int ** reg_img, int * reg_x, int * reg_y )</a>
<a name="ln2097">{</a>
<a name="ln2098">  image_double image;</a>
<a name="ln2099">  ntuple_list out = new_ntuple_list(7);</a>
<a name="ln2100">  double * return_value;</a>
<a name="ln2101">  image_double scaled_image,angles,modgrad;</a>
<a name="ln2102">  image_char used;</a>
<a name="ln2103">  image_int region = NULL;</a>
<a name="ln2104">  struct coorlist * list_p;</a>
<a name="ln2105">  void * mem_p;</a>
<a name="ln2106">  struct rect rec;</a>
<a name="ln2107">  struct point * reg;</a>
<a name="ln2108">  int reg_size,min_reg_size,i;</a>
<a name="ln2109">  unsigned int xsize,ysize;</a>
<a name="ln2110">  double rho,reg_angle,prec,p,log_nfa,logNT;</a>
<a name="ln2111">  int ls_count = 0;                   /* line segments are numbered 1,2,3,... */</a>
<a name="ln2112"> </a>
<a name="ln2113"> </a>
<a name="ln2114">  /* check parameters */</a>
<a name="ln2115">  if( img == NULL || X &lt;= 0 || Y &lt;= 0 ) error(&quot;invalid image input.&quot;);</a>
<a name="ln2116">  if( scale &lt;= 0.0 ) error(&quot;'scale' value must be positive.&quot;);</a>
<a name="ln2117">  if( sigma_scale &lt;= 0.0 ) error(&quot;'sigma_scale' value must be positive.&quot;);</a>
<a name="ln2118">  if( quant &lt; 0.0 ) error(&quot;'quant' value must be positive.&quot;);</a>
<a name="ln2119">  if( ang_th &lt;= 0.0 || ang_th &gt;= 180.0 )</a>
<a name="ln2120">    error(&quot;'ang_th' value must be in the range (0,180).&quot;);</a>
<a name="ln2121">  if( density_th &lt; 0.0 || density_th &gt; 1.0 )</a>
<a name="ln2122">    error(&quot;'density_th' value must be in the range [0,1].&quot;);</a>
<a name="ln2123">  if( n_bins &lt;= 0 ) error(&quot;'n_bins' value must be positive.&quot;);</a>
<a name="ln2124"> </a>
<a name="ln2125"> </a>
<a name="ln2126">  /* angle tolerance */</a>
<a name="ln2127">  prec = M_PI * ang_th / 180.0;</a>
<a name="ln2128">  p = ang_th / 180.0;</a>
<a name="ln2129">  rho = quant / sin(prec); /* gradient magnitude threshold */</a>
<a name="ln2130"> </a>
<a name="ln2131"> </a>
<a name="ln2132">  /* load and scale image (if necessary) and compute angle at each pixel */</a>
<a name="ln2133">  image = new_image_double_ptr( (unsigned int) X, (unsigned int) Y, img );</a>
<a name="ln2134">  if( scale != 1.0 )</a>
<a name="ln2135">    {</a>
<a name="ln2136">      scaled_image = gaussian_sampler( image, scale, sigma_scale );</a>
<a name="ln2137">      angles = ll_angle( scaled_image, rho, &amp;list_p, &amp;mem_p,</a>
<a name="ln2138">                         &amp;modgrad, (unsigned int) n_bins );</a>
<a name="ln2139">      free_image_double(scaled_image);</a>
<a name="ln2140">    }</a>
<a name="ln2141">  else</a>
<a name="ln2142">    angles = ll_angle( image, rho, &amp;list_p, &amp;mem_p, &amp;modgrad,</a>
<a name="ln2143">                       (unsigned int) n_bins );</a>
<a name="ln2144">  xsize = angles-&gt;xsize;</a>
<a name="ln2145">  ysize = angles-&gt;ysize;</a>
<a name="ln2146"> </a>
<a name="ln2147">  /* Number of Tests - NT</a>
<a name="ln2148"> </a>
<a name="ln2149">     The theoretical number of tests is Np.(XY)^(5/2)</a>
<a name="ln2150">     where X and Y are number of columns and rows of the image.</a>
<a name="ln2151">     Np corresponds to the number of angle precisions considered.</a>
<a name="ln2152">     As the procedure 'rect_improve' tests 5 times to halve the</a>
<a name="ln2153">     angle precision, and 5 more times after improving other factors,</a>
<a name="ln2154">     11 different precision values are potentially tested. Thus,</a>
<a name="ln2155">     the number of tests is</a>
<a name="ln2156">       11 * (X*Y)^(5/2)</a>
<a name="ln2157">     whose logarithm value is</a>
<a name="ln2158">       log10(11) + 5/2 * (log10(X) + log10(Y)).</a>
<a name="ln2159">  */</a>
<a name="ln2160">  logNT = 5.0 * ( log10( (double) xsize ) + log10( (double) ysize ) ) / 2.0</a>
<a name="ln2161">          + log10(11.0);</a>
<a name="ln2162">  min_reg_size = (int) (-logNT/log10(p)); /* minimal number of points in region</a>
<a name="ln2163">                                             that can give a meaningful event */</a>
<a name="ln2164"> </a>
<a name="ln2165"> </a>
<a name="ln2166">  /* initialize some structures */</a>
<a name="ln2167">  if( reg_img != NULL &amp;&amp; reg_x != NULL &amp;&amp; reg_y != NULL ) /* save region data */</a>
<a name="ln2168">    region = new_image_int_ini(angles-&gt;xsize,angles-&gt;ysize,0);</a>
<a name="ln2169">  used = new_image_char_ini(xsize,ysize,NOTUSED);</a>
<a name="ln2170">  reg = (struct point *) calloc( (size_t) (xsize*ysize), sizeof(struct point) );</a>
<a name="ln2171">  if( reg == NULL ) error(&quot;not enough memory!&quot;);</a>
<a name="ln2172"> </a>
<a name="ln2173"> </a>
<a name="ln2174">  /* search for line segments */</a>
<a name="ln2175">  for(; list_p != NULL; list_p = list_p-&gt;next )</a>
<a name="ln2176">    if( used-&gt;data[ list_p-&gt;x + list_p-&gt;y * used-&gt;xsize ] == NOTUSED &amp;&amp;</a>
<a name="ln2177">        angles-&gt;data[ list_p-&gt;x + list_p-&gt;y * angles-&gt;xsize ] != NOTDEF )</a>
<a name="ln2178">       /* there is no risk of double comparison problems here</a>
<a name="ln2179">          because we are only interested in the exact NOTDEF value */</a>
<a name="ln2180">      {</a>
<a name="ln2181">        /* find the region of connected point and ~equal angle */</a>
<a name="ln2182">        region_grow( list_p-&gt;x, list_p-&gt;y, angles, reg, &amp;reg_size,</a>
<a name="ln2183">                     &amp;reg_angle, used, prec );</a>
<a name="ln2184"> </a>
<a name="ln2185">        /* reject small regions */</a>
<a name="ln2186">        if( reg_size &lt; min_reg_size ) continue;</a>
<a name="ln2187"> </a>
<a name="ln2188">        /* construct rectangular approximation for the region */</a>
<a name="ln2189">        region2rect(reg,reg_size,modgrad,reg_angle,prec,p,&amp;rec);</a>
<a name="ln2190"> </a>
<a name="ln2191">        /* Check if the rectangle exceeds the minimal density of</a>
<a name="ln2192">           region points. If not, try to improve the region.</a>
<a name="ln2193">           The rectangle will be rejected if the final one does</a>
<a name="ln2194">           not fulfill the minimal density condition.</a>
<a name="ln2195">           This is an addition to the original LSD algorithm published in</a>
<a name="ln2196">           &quot;LSD: A Fast Line Segment Detector with a False Detection Control&quot;</a>
<a name="ln2197">           by R. Grompone von Gioi, J. Jakubowicz, J.M. Morel, and G. Randall.</a>
<a name="ln2198">           The original algorithm is obtained with density_th = 0.0.</a>
<a name="ln2199">         */</a>
<a name="ln2200">        if( !refine( reg, &amp;reg_size, modgrad, reg_angle,</a>
<a name="ln2201">                     prec, p, &amp;rec, used, angles, density_th ) ) continue;</a>
<a name="ln2202"> </a>
<a name="ln2203">        /* compute NFA value */</a>
<a name="ln2204">        log_nfa = rect_improve(&amp;rec,angles,logNT,log_eps);</a>
<a name="ln2205">        if( log_nfa &lt;= log_eps ) continue;</a>
<a name="ln2206"> </a>
<a name="ln2207">        /* A New Line Segment was found! */</a>
<a name="ln2208">        ++ls_count;  /* increase line segment counter */</a>
<a name="ln2209"> </a>
<a name="ln2210">        /*</a>
<a name="ln2211">           The gradient was computed with a 2x2 mask, its value corresponds to</a>
<a name="ln2212">           points with an offset of (0.5,0.5), that should be added to output.</a>
<a name="ln2213">           The coordinates origin is at the center of pixel (0,0).</a>
<a name="ln2214">         */</a>
<a name="ln2215">        rec.x1 += 0.5; rec.y1 += 0.5;</a>
<a name="ln2216">        rec.x2 += 0.5; rec.y2 += 0.5;</a>
<a name="ln2217"> </a>
<a name="ln2218">        /* scale the result values if a subsampling was performed */</a>
<a name="ln2219">        if( scale != 1.0 )</a>
<a name="ln2220">          {</a>
<a name="ln2221">            rec.x1 /= scale; rec.y1 /= scale;</a>
<a name="ln2222">            rec.x2 /= scale; rec.y2 /= scale;</a>
<a name="ln2223">            rec.width /= scale;</a>
<a name="ln2224">          }</a>
<a name="ln2225"> </a>
<a name="ln2226">        /* add line segment found to output */</a>
<a name="ln2227">        add_7tuple( out, rec.x1, rec.y1, rec.x2, rec.y2,</a>
<a name="ln2228">                         rec.width, rec.p, log_nfa );</a>
<a name="ln2229"> </a>
<a name="ln2230">        /* add region number to 'region' image if needed */</a>
<a name="ln2231">        if( region != NULL )</a>
<a name="ln2232">          for(i=0; i&lt;reg_size; i++)</a>
<a name="ln2233">            region-&gt;data[ reg[i].x + reg[i].y * region-&gt;xsize ] = ls_count;</a>
<a name="ln2234">      }</a>
<a name="ln2235"> </a>
<a name="ln2236"> </a>
<a name="ln2237">  /* free memory */</a>
<a name="ln2238">  free( (void *) image );   /* only the double_image structure should be freed,</a>
<a name="ln2239">                               the data pointer was provided to this functions</a>
<a name="ln2240">                               and should not be destroyed.                 */</a>
<a name="ln2241">  free_image_double(angles);</a>
<a name="ln2242">  free_image_double(modgrad);</a>
<a name="ln2243">  free_image_char(used);</a>
<a name="ln2244">  free( (void *) reg );</a>
<a name="ln2245">  free( (void *) mem_p );</a>
<a name="ln2246"> </a>
<a name="ln2247">  /* return the result */</a>
<a name="ln2248">  if( reg_img != NULL &amp;&amp; reg_x != NULL &amp;&amp; reg_y != NULL )</a>
<a name="ln2249">    {</a>
<a name="ln2250">      if( region == NULL ) error(&quot;'region' should be a valid image.&quot;);</a>
<a name="ln2251">      *reg_img = region-&gt;data;</a>
<a name="ln2252">      if( region-&gt;xsize &gt; (unsigned int) INT_MAX ||</a>
<a name="ln2253">          region-&gt;ysize &gt; (unsigned int) INT_MAX )</a>
<a name="ln2254">        error(&quot;region image to big to fit in INT sizes.&quot;);</a>
<a name="ln2255">      *reg_x = (int) (region-&gt;xsize);</a>
<a name="ln2256">      *reg_y = (int) (region-&gt;ysize);</a>
<a name="ln2257"> </a>
<a name="ln2258">      /* free the 'region' structure.</a>
<a name="ln2259">         we cannot use the function 'free_image_int' because we need to keep</a>
<a name="ln2260">         the memory with the image data to be returned by this function. */</a>
<a name="ln2261">      free( (void *) region );</a>
<a name="ln2262">    }</a>
<a name="ln2263">  if( out-&gt;size &gt; (unsigned int) INT_MAX )</a>
<a name="ln2264">    error(&quot;too many detections to fit in an INT.&quot;);</a>
<a name="ln2265">  *n_out = (int) (out-&gt;size);</a>
<a name="ln2266"> </a>
<a name="ln2267">  return_value = out-&gt;values;</a>
<a name="ln2268">  free( (void *) out );  /* only the 'ntuple_list' structure must be freed,</a>
<a name="ln2269">                            but the 'values' pointer must be keep to return</a>
<a name="ln2270">                            as a result. */</a>
<a name="ln2271"> </a>
<a name="ln2272">  return return_value;</a>
<a name="ln2273">}</a>
<a name="ln2274">#if 0</a>
<a name="ln2275">/*----------------------------------------------------------------------------*/</a>
<a name="ln2276">/** LSD Simple Interface with Scale and Region output.</a>
<a name="ln2277"> */</a>
<a name="ln2278">static</a>
<a name="ln2279">double * lsd_scale_region( int * n_out,</a>
<a name="ln2280">                           double * img, int X, int Y, double scale,</a>
<a name="ln2281">                           int ** reg_img, int * reg_x, int * reg_y )</a>
<a name="ln2282">{</a>
<a name="ln2283">  /* LSD parameters */</a>
<a name="ln2284">  double sigma_scale = 0.6; /* Sigma for Gaussian filter is computed as</a>
<a name="ln2285">                                sigma = sigma_scale/scale.                    */</a>
<a name="ln2286">  double quant = 2.0;       /* Bound to the quantization error on the</a>
<a name="ln2287">                                gradient norm.                                */</a>
<a name="ln2288">  double ang_th = 22.5;     /* Gradient angle tolerance in degrees.           */</a>
<a name="ln2289">  double log_eps = 0.0;     /* Detection threshold: -log10(NFA) &gt; log_eps     */</a>
<a name="ln2290">  double density_th = 0.7;  /* Minimal density of region points in rectangle. */</a>
<a name="ln2291">  int n_bins = 1024;        /* Number of bins in pseudo-ordering of gradient</a>
<a name="ln2292">                               modulus.                                       */</a>
<a name="ln2293"> </a>
<a name="ln2294">  return LineSegmentDetection( n_out, img, X, Y, scale, sigma_scale, quant,</a>
<a name="ln2295">                               ang_th, log_eps, density_th, n_bins,</a>
<a name="ln2296">                               reg_img, reg_x, reg_y );</a>
<a name="ln2297">}</a>
<a name="ln2298"> </a>
<a name="ln2299">/*----------------------------------------------------------------------------*/</a>
<a name="ln2300">/** LSD Simple Interface with Scale.</a>
<a name="ln2301"> */</a>
<a name="ln2302">static</a>
<a name="ln2303">double * lsd_scale(int * n_out, double * img, int X, int Y, double scale)</a>
<a name="ln2304">{</a>
<a name="ln2305">  return lsd_scale_region(n_out,img,X,Y,scale,NULL,NULL,NULL);</a>
<a name="ln2306">}</a>
<a name="ln2307"> </a>
<a name="ln2308">/*----------------------------------------------------------------------------*/</a>
<a name="ln2309">/** LSD Simple Interface.</a>
<a name="ln2310"> */</a>
<a name="ln2311">static</a>
<a name="ln2312">double * lsd(int * n_out, double * img, int X, int Y)</a>
<a name="ln2313">{</a>
<a name="ln2314">  /* LSD parameters */</a>
<a name="ln2315">  double scale = 0.8;       /* Scale the image by Gaussian filter to 'scale'. */</a>
<a name="ln2316"> </a>
<a name="ln2317">  return lsd_scale(n_out,img,X,Y,scale);</a>
<a name="ln2318">}</a>
<a name="ln2319">/*----------------------------------------------------------------------------*/</a>
<a name="ln2320">#endif</a>
<a name="ln2321">/*==================================================================================</a>
<a name="ln2322"> * end of LSD code</a>
<a name="ln2323"> *==================================================================================*/</a>
<a name="ln2324"> </a>
<a name="ln2325">// clang-format on</a>
<a name="ln2326"> </a>
<a name="ln2327">#undef NOTDEF</a>
<a name="ln2328">#undef NOTUSED</a>
<a name="ln2329">#undef USED</a>
<a name="ln2330">#undef RELATIVE_ERROR_FACTOR</a>
<a name="ln2331">#undef TABSIZE</a>
<a name="ln2332"> </a>
<a name="ln2333">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2334">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2335">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="417"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'xsize * ysize' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="440"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: image == NULL.</p></div>
<div class="balloon" rel="477"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'xsize * ysize' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="543"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'xsize * ysize' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="833"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'n * p' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="1773"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'angles' pointer was utilized before it was verified against nullptr. Check lines: 1773, 1775.</p></div>
<div class="balloon" rel="2170"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'xsize * ysize' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="2272"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'region' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
