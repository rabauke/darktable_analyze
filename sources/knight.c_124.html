
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> *    This file is part of darktable,</a>
<a name="ln3"> *    copyright (c) 2016 tobias ellinghaus.</a>
<a name="ln4"> *</a>
<a name="ln5"> *    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6"> *    it under the terms of the GNU General Public License as published by</a>
<a name="ln7"> *    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8"> *    (at your option) any later version.</a>
<a name="ln9"> *</a>
<a name="ln10"> *    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13"> *    GNU General Public License for more details.</a>
<a name="ln14"> *</a>
<a name="ln15"> *    You should have received a copy of the GNU General Public License</a>
<a name="ln16"> *    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17"> */</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;control/control.h&quot;</a>
<a name="ln20">#include &quot;views/knight_font.h&quot;</a>
<a name="ln21">#include &quot;views/view.h&quot;</a>
<a name="ln22">#include &quot;views/view_api.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24">DT_MODULE(1)</a>
<a name="ln25"> </a>
<a name="ln26">#pragma GCC diagnostic ignored &quot;-Wshadow&quot;</a>
<a name="ln27"> </a>
<a name="ln28">// tunables for how the game looks and reacts</a>
<a name="ln29">#define ASPECT_RATIO 0.875 // the playground</a>
<a name="ln30">#define LOOP_SPEED 50      // ms between event loop calls</a>
<a name="ln31">#define STEP_SIZE 0.25     // factor wrt. sprite size for movement</a>
<a name="ln32"> </a>
<a name="ln33">#define MAX_ALIEN_SHOTS 3 // max shots in the air from the big alien block. mystery goes extra</a>
<a name="ln34">#define N_ALIENS_X 11     // number of aliens in the block in x direction</a>
<a name="ln35">#define N_ALIENS_Y 5      // number of aliens in the block in y direction</a>
<a name="ln36">#define ALIEN_DEATH_TIME                                                                                     \</a>
<a name="ln37">  (0.3 * 1000.0 / LOOP_SPEED)     // number frames to show explosions + freeze alien movement on hit</a>
<a name="ln38">#define ALIEN_SHOT_PROBABILITY 20 // rand() % ALIEN_SHOT_PROBABILITY == 0 is the test</a>
<a name="ln39"> </a>
<a name="ln40">#define LETTER_WIDTH (1.0 / 45.0)   // scale font so that 45 letters fit next to each other</a>
<a name="ln41">#define LETTER_SPACING (1.0 / 28.0) // space text so that 28 letters fit next to each other</a>
<a name="ln42">#define LETTER_HEIGHT (LETTER_WIDTH * FONT_HEIGHT / (float)FONT_WIDTH)</a>
<a name="ln43">#define CELL_WIDTH (1.0 / 20.0)        // size factor for when nothing else is appropriate</a>
<a name="ln44">#define GAP 1.5                        // space between aliens in the block + lifes</a>
<a name="ln45">#define SHOT_LENGTH (0.4 * CELL_WIDTH) // length of the visible shot graphics</a>
<a name="ln46"> </a>
<a name="ln47">#define TOP_MARGIN (5 * LETTER_HEIGHT)                         // start of the alien block from the top</a>
<a name="ln48">#define BOTTOM_MARGIN (1.0 - 2 * LETTER_HEIGHT * ASPECT_RATIO) // ground plane</a>
<a name="ln49">#define MYSTERY_SHIP_Y (3 * LETTER_HEIGHT)                     // height where the UFO flies</a>
<a name="ln50">#define PLAYER_Y 0.85                                          // height where the player moves</a>
<a name="ln51"> </a>
<a name="ln52">// *_[WIDTH|HEIGHT] is pixel size of the data</a>
<a name="ln53">// *_TARGET_[WIDTH|HEIGHT] is size wrt. playground (0..1)</a>
<a name="ln54">#define TARGET_HEIGHT(n) (((float)n##_TARGET_WIDTH / n##_WIDTH * n##_HEIGHT * ASPECT_RATIO))</a>
<a name="ln55"> </a>
<a name="ln56">// clang-format off</a>
<a name="ln57"> </a>
<a name="ln58">#define ALIEN_WIDTH 6 // pixel size of the bitmaps</a>
<a name="ln59">#define ALIEN_HEIGHT 6</a>
<a name="ln60">#define ALIEN_TARGET_WIDTH CELL_WIDTH</a>
<a name="ln61">#define ALIEN_TARGET_HEIGHT TARGET_HEIGHT(ALIEN)</a>
<a name="ln62">static const uint8_t alien[2][ALIEN_WIDTH * ALIEN_HEIGHT] = {</a>
<a name="ln63">  // first animation frame</a>
<a name="ln64">  {</a>
<a name="ln65">    0x00, 0xff, 0xff, 0xff, 0xff, 0x00,</a>
<a name="ln66">    0xff, 0x00, 0xff, 0xff, 0x00, 0xff,</a>
<a name="ln67">    0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln68">    0x00, 0xff, 0x00, 0x00, 0xff, 0x00,</a>
<a name="ln69">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln70">    0x00, 0xff, 0xff, 0xff, 0xff, 0x00,</a>
<a name="ln71">  },</a>
<a name="ln72">  // second animation frame</a>
<a name="ln73">  {</a>
<a name="ln74">    0x00, 0xff, 0xff, 0xff, 0xff, 0x00,</a>
<a name="ln75">    0xff, 0x00, 0xff, 0xff, 0x00, 0xff,</a>
<a name="ln76">    0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln77">    0x00, 0xff, 0x00, 0x00, 0xff, 0x00,</a>
<a name="ln78">    0x00, 0xff, 0xff, 0xff, 0xff, 0x00,</a>
<a name="ln79">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln80">  },</a>
<a name="ln81">};</a>
<a name="ln82"> </a>
<a name="ln83">#define PLAYER_WIDTH 13</a>
<a name="ln84">#define PLAYER_HEIGHT 8</a>
<a name="ln85">#define PLAYER_TARGET_WIDTH (1.2 * CELL_WIDTH)</a>
<a name="ln86">#define PLAYER_TARGET_HEIGHT TARGET_HEIGHT(PLAYER)</a>
<a name="ln87">static const uint8_t player[3][PLAYER_WIDTH * PLAYER_HEIGHT] = {</a>
<a name="ln88">  // normal graphic</a>
<a name="ln89">  {</a>
<a name="ln90">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln91">    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln92">    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln93">    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,</a>
<a name="ln94">    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln95">    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln96">    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln97">    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln98">  },</a>
<a name="ln99">  // explosion 1</a>
<a name="ln100">  {</a>
<a name="ln101">    0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,</a>
<a name="ln102">    0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00,</a>
<a name="ln103">    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,</a>
<a name="ln104">    0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00,</a>
<a name="ln105">    0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00,</a>
<a name="ln106">    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,</a>
<a name="ln107">    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,</a>
<a name="ln108">    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,</a>
<a name="ln109">  },</a>
<a name="ln110">  // explosion 2</a>
<a name="ln111">  {</a>
<a name="ln112">    0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln113">    0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00,</a>
<a name="ln114">    0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00,</a>
<a name="ln115">    0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff,</a>
<a name="ln116">    0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00,</a>
<a name="ln117">    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,</a>
<a name="ln118">    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,</a>
<a name="ln119">    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,</a>
<a name="ln120">  },</a>
<a name="ln121">};</a>
<a name="ln122"> </a>
<a name="ln123">#define MYSTERY_SHIP_WIDTH 16</a>
<a name="ln124">#define MYSTERY_SHIP_HEIGHT 7</a>
<a name="ln125">#define MYSTERY_SHIP_TARGET_WIDTH CELL_WIDTH</a>
<a name="ln126">#define MYSTERY_SHIP_TARGET_HEIGHT TARGET_HEIGHT(MYSTERY_SHIP)</a>
<a name="ln127">static const uint8_t mystery_ship[MYSTERY_SHIP_WIDTH * MYSTERY_SHIP_HEIGHT] = {</a>
<a name="ln128">  0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln129">  0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln130">  0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,</a>
<a name="ln131">  0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00,</a>
<a name="ln132">  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln133">  0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,</a>
<a name="ln134">  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln135">};</a>
<a name="ln136"> </a>
<a name="ln137">#define BUNKER_WIDTH 22</a>
<a name="ln138">#define BUNKER_HEIGHT 16</a>
<a name="ln139">#define BUNKER_TARGET_WIDTH (1.0 / 9.0)</a>
<a name="ln140">#define BUNKER_TARGET_HEIGHT TARGET_HEIGHT(BUNKER)</a>
<a name="ln141">#define BUNKER_Y (PLAYER_Y - PLAYER_TARGET_HEIGHT - BUNKER_TARGET_HEIGHT)</a>
<a name="ln142">static const uint8_t bunker[BUNKER_WIDTH * BUNKER_HEIGHT] = {</a>
<a name="ln143">  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln144">  0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln145">  0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,</a>
<a name="ln146">  0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,</a>
<a name="ln147">  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln148">  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln149">  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln150">  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln151">  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln152">  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln153">  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln154">  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln155">  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln156">  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln157">  0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln158">  0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln159">};</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">#define EXPLOSION_WIDTH 12</a>
<a name="ln163">#define EXPLOSION_HEIGHT 12</a>
<a name="ln164">// keep this in sync to the bunker so that the damages look good later</a>
<a name="ln165">#define EXPLOSION_TARGET_WIDTH (BUNKER_TARGET_WIDTH / BUNKER_WIDTH * EXPLOSION_WIDTH)</a>
<a name="ln166">#define EXPLOSION_TARGET_HEIGHT TARGET_HEIGHT(EXPLOSION)</a>
<a name="ln167">#define EXPLOSION_ALIEN 0</a>
<a name="ln168">#define EXPLOSION_MYSTERY 1</a>
<a name="ln169">#define EXPLOSION_SHOT 2</a>
<a name="ln170">#define EXPLOSION_TOP 3</a>
<a name="ln171">#define EXPLOSION_BOTTOM 4</a>
<a name="ln172">#define EXPLOSION_AMOUNT 5</a>
<a name="ln173">static const uint8_t explosions[EXPLOSION_AMOUNT][EXPLOSION_WIDTH * EXPLOSION_HEIGHT] = {</a>
<a name="ln174">  // aliens</a>
<a name="ln175">  {</a>
<a name="ln176">    0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln177">    0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln178">    0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,</a>
<a name="ln179">    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,</a>
<a name="ln180">    0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln181">    0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,</a>
<a name="ln182">    0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln183">    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,</a>
<a name="ln184">    0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,</a>
<a name="ln185">    0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln186">    0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln187">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln188">  },</a>
<a name="ln189">  // mystery</a>
<a name="ln190">  {</a>
<a name="ln191">    0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln192">    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,</a>
<a name="ln193">    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln194">    0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln195">    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln196">    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,</a>
<a name="ln197">    0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln198">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln199">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln200">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln201">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln202">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln203">  },</a>
<a name="ln204">  // shot</a>
<a name="ln205">  {</a>
<a name="ln206">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln207">    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln208">    0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln209">    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln210">    0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln211">    0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln212">    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln213">    0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln214">    0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln215">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln216">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln217">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln218">  },</a>
<a name="ln219">  // on the top</a>
<a name="ln220">  {</a>
<a name="ln221">    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln222">    0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln223">    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln224">    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln225">    0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln226">    0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln227">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln228">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln229">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln230">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln231">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln232">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln233">  },</a>
<a name="ln234">  // on the bottom</a>
<a name="ln235">  {</a>
<a name="ln236">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln237">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln238">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln239">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln240">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln241">    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln242">    0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln243">    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln244">    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln245">    0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln246">    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,</a>
<a name="ln247">    0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,</a>
<a name="ln248">  },</a>
<a name="ln249">};</a>
<a name="ln250"> </a>
<a name="ln251">// clang-format on</a>
<a name="ln252"> </a>
<a name="ln253"> </a>
<a name="ln254">typedef struct dt_knight_shot_t</a>
<a name="ln255">{</a>
<a name="ln256">  gboolean active;</a>
<a name="ln257">  float x, y, start, direction;</a>
<a name="ln258">} dt_knight_shot_t;</a>
<a name="ln259"> </a>
<a name="ln260">typedef struct dt_knight_alien_t</a>
<a name="ln261">{</a>
<a name="ln262">  gboolean alive;</a>
<a name="ln263">  float x, y;</a>
<a name="ln264">  int frame;</a>
<a name="ln265">  int points;</a>
<a name="ln266">} dt_knight_alien_t;</a>
<a name="ln267"> </a>
<a name="ln268">typedef struct dt_knight_explosion_t</a>
<a name="ln269">{</a>
<a name="ln270">  float x, y, target_width;</a>
<a name="ln271">  int ttl;</a>
<a name="ln272">  cairo_pattern_t *sprite;</a>
<a name="ln273">} dt_knight_explosion_t;</a>
<a name="ln274"> </a>
<a name="ln275">typedef struct dt_knight_t</a>
<a name="ln276">{</a>
<a name="ln277">  // control state</a>
<a name="ln278">  enum</a>
<a name="ln279">  {</a>
<a name="ln280">    INTRO,</a>
<a name="ln281">    START,</a>
<a name="ln282">    GAME,</a>
<a name="ln283">    WIN,</a>
<a name="ln284">    LOSE</a>
<a name="ln285">  } game_state;</a>
<a name="ln286">  unsigned int animation_loop; // animation frame counter for the non-interactive states</a>
<a name="ln287">  guint event_loop;</a>
<a name="ln288">  int freeze; // frames until the freeze is over</a>
<a name="ln289">  gboolean total_freeze, super_total_final_freeze;</a>
<a name="ln290">  GList *explosions;</a>
<a name="ln291">  int move; // we handle movement in the event loop. using key_pressed suffers from X's key repeat + delay</a>
<a name="ln292"> </a>
<a name="ln293">  // visible game state</a>
<a name="ln294">  int credit;</a>
<a name="ln295">  int lifes;</a>
<a name="ln296">  unsigned int score_1, score_2, high_score;</a>
<a name="ln297"> </a>
<a name="ln298">  // other state</a>
<a name="ln299">  float player_x;</a>
<a name="ln300">  dt_knight_shot_t player_shot;</a>
<a name="ln301"> </a>
<a name="ln302">  dt_knight_alien_t aliens[N_ALIENS_X * N_ALIENS_Y];</a>
<a name="ln303">  int n_aliens;</a>
<a name="ln304">  enum</a>
<a name="ln305">  {</a>
<a name="ln306">    ALIEN_LEFT,</a>
<a name="ln307">    ALIEN_RIGHT,</a>
<a name="ln308">    ALIEN_DOWN_THEN_LEFT,</a>
<a name="ln309">    ALIEN_DOWN_THEN_RIGHT</a>
<a name="ln310">  } alien_direction;</a>
<a name="ln311">  int alien_next_to_move;</a>
<a name="ln312">  dt_knight_shot_t alien_shots[MAX_ALIEN_SHOTS + 1]; // the mystery ship can shoot, too, so it's +1</a>
<a name="ln313">  int n_alien_shots;</a>
<a name="ln314">  float mystery_ship_x;</a>
<a name="ln315">  int time_until_mystery_ship;</a>
<a name="ln316">  float mystery_ship_potential_shot_x;</a>
<a name="ln317"> </a>
<a name="ln318">  // buffers to free in the end</a>
<a name="ln319">  GList *bufs, *surfaces, *patterns;</a>
<a name="ln320">  // sprites</a>
<a name="ln321">  cairo_pattern_t *alien_sprite[2];</a>
<a name="ln322">  cairo_pattern_t *player_sprite[3];</a>
<a name="ln323">  cairo_pattern_t *mystery_sprite;</a>
<a name="ln324">  cairo_pattern_t *explosion_sprite[EXPLOSION_AMOUNT];</a>
<a name="ln325">  cairo_pattern_t **letters;</a>
<a name="ln326">  cairo_pattern_t *bunker_sprite[4];</a>
<a name="ln327">  // needed to add explosions to the bunkers</a>
<a name="ln328">  int bunker_stride;</a>
<a name="ln329">  uint8_t *bunker_buf[4];</a>
<a name="ln330">} dt_knight_t;</a>
<a name="ln331"> </a>
<a name="ln332">const char *name(const dt_view_t *self)</a>
<a name="ln333">{</a>
<a name="ln334">  return _(&quot;good knight&quot;);</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337">uint32_t view(const dt_view_t *self)</a>
<a name="ln338">{</a>
<a name="ln339">  return DT_VIEW_KNIGHT;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">uint32_t flags()</a>
<a name="ln343">{</a>
<a name="ln344">  return VIEW_FLAGS_HIDDEN;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347">// turn a monochrome pixel buffer into a cairo pattern for later usage</a>
<a name="ln348">static inline cairo_pattern_t *_new_sprite(const uint8_t *data, const int width, const int height,</a>
<a name="ln349">                                           int *_stride, GList **bufs, GList **surfaces, GList **patterns)</a>
<a name="ln350">{</a>
<a name="ln351">  const int32_t stride = cairo_format_stride_for_width(CAIRO_FORMAT_A8, width);</a>
<a name="ln352">  uint8_t *buf = (uint8_t *)malloc(stride * height);</a>
<a name="ln353">  for(int y = 0; y &lt; height; y++) memcpy(&amp;buf[y * stride], &amp;(data[y * width]), width * sizeof(uint8_t));</a>
<a name="ln354">  cairo_surface_t *surface = cairo_image_surface_create_for_data(buf, CAIRO_FORMAT_A8, width, height, stride);</a>
<a name="ln355">  cairo_pattern_t *pattern = cairo_pattern_create_for_surface(surface);</a>
<a name="ln356">  cairo_pattern_set_filter(pattern, CAIRO_FILTER_NEAREST);</a>
<a name="ln357">  *bufs = g_list_append(*bufs, buf);</a>
<a name="ln358">  *surfaces = g_list_append(*surfaces, surface);</a>
<a name="ln359">  *patterns = g_list_append(*patterns, pattern);</a>
<a name="ln360">  if(_stride) *_stride = stride;</a>
<a name="ln361">  return pattern;</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364">// spawn a mystery ship every 25±3 seconds</a>
<a name="ln365">static int _get_mystery_timeout()</a>
<a name="ln366">{</a>
<a name="ln367">  int r = (rand() % 7) - 3;</a>
<a name="ln368">  return (25.0 + r) * 1000.0 / LOOP_SPEED;</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">// reset most but not all values of dt_knight_t</a>
<a name="ln372">static void _reset_board(dt_knight_t *d)</a>
<a name="ln373">{</a>
<a name="ln374">  d-&gt;player_x = 0.0;</a>
<a name="ln375">  d-&gt;player_shot.active = FALSE;</a>
<a name="ln376"> </a>
<a name="ln377">  for(int y = 0; y &lt; N_ALIENS_Y; y++)</a>
<a name="ln378">    for(int x = 0; x &lt; N_ALIENS_X; x++)</a>
<a name="ln379">    {</a>
<a name="ln380">      int i = y * N_ALIENS_X + x;</a>
<a name="ln381">      d-&gt;aliens[i].x = x * ALIEN_TARGET_WIDTH * GAP + 0.5 - (N_ALIENS_X - 1) * 0.5 * ALIEN_TARGET_WIDTH * GAP</a>
<a name="ln382">                       - 0.5 * ALIEN_TARGET_WIDTH;</a>
<a name="ln383">      d-&gt;aliens[i].y = y * ALIEN_TARGET_HEIGHT * GAP + TOP_MARGIN;</a>
<a name="ln384">      d-&gt;aliens[i].alive = TRUE;</a>
<a name="ln385">      d-&gt;aliens[i].frame = 0;</a>
<a name="ln386">      d-&gt;aliens[i].points = ((N_ALIENS_Y - y - 1) / 2 + 1) * 10; // bottom 2: 10, middle 2: 20, top: 30</a>
<a name="ln387">    }</a>
<a name="ln388">  d-&gt;n_aliens = N_ALIENS_Y * N_ALIENS_X;</a>
<a name="ln389">  d-&gt;alien_direction = ALIEN_RIGHT;</a>
<a name="ln390">  d-&gt;alien_next_to_move = 0 + (N_ALIENS_Y - 1) * N_ALIENS_X;</a>
<a name="ln391">  for(int i = 0; i &lt; MAX_ALIEN_SHOTS + 1; i++) d-&gt;alien_shots[i].active = FALSE;</a>
<a name="ln392">  d-&gt;n_alien_shots = 0;</a>
<a name="ln393">  d-&gt;mystery_ship_x = -1.0;</a>
<a name="ln394">  d-&gt;time_until_mystery_ship = _get_mystery_timeout();</a>
<a name="ln395">  d-&gt;mystery_ship_potential_shot_x = 0.0;</a>
<a name="ln396"> </a>
<a name="ln397">  d-&gt;move = 0;</a>
<a name="ln398">  d-&gt;freeze = 0;</a>
<a name="ln399">  d-&gt;total_freeze = FALSE;</a>
<a name="ln400">  d-&gt;super_total_final_freeze = FALSE;</a>
<a name="ln401">  d-&gt;animation_loop = 0;</a>
<a name="ln402">  g_list_free_full(d-&gt;explosions, free);</a>
<a name="ln403">  d-&gt;explosions = NULL;</a>
<a name="ln404"> </a>
<a name="ln405">  d-&gt;lifes = 3;</a>
<a name="ln406">  d-&gt;score_1 = d-&gt;score_2 = 0;</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409">void init(dt_view_t *self)</a>
<a name="ln410">{</a>
<a name="ln411">  self-&gt;data = calloc(1, sizeof(dt_knight_t));</a>
<a name="ln412">  dt_knight_t *d = (dt_knight_t *)self-&gt;data;</a>
<a name="ln413"> </a>
<a name="ln414">  _reset_board(d);</a>
<a name="ln415">  d-&gt;game_state = INTRO;</a>
<a name="ln416"> </a>
<a name="ln417">  // create sprites</a>
<a name="ln418">  // good knight alien frames</a>
<a name="ln419">  for(int i = 0; i &lt; 2; i++)</a>
<a name="ln420">    d-&gt;alien_sprite[i]</a>
<a name="ln421">        = _new_sprite(alien[i], ALIEN_WIDTH, ALIEN_HEIGHT, NULL, &amp;(d-&gt;bufs), &amp;(d-&gt;surfaces), &amp;(d-&gt;patterns));</a>
<a name="ln422">  // player</a>
<a name="ln423">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln424">    d-&gt;player_sprite[i] = _new_sprite(player[i], PLAYER_WIDTH, PLAYER_HEIGHT, NULL, &amp;(d-&gt;bufs),</a>
<a name="ln425">                                      &amp;(d-&gt;surfaces), &amp;(d-&gt;patterns));</a>
<a name="ln426">  // mystery ship</a>
<a name="ln427">  d-&gt;mystery_sprite = _new_sprite(mystery_ship, MYSTERY_SHIP_WIDTH, MYSTERY_SHIP_HEIGHT, NULL, &amp;(d-&gt;bufs),</a>
<a name="ln428">                                  &amp;(d-&gt;surfaces), &amp;(d-&gt;patterns));</a>
<a name="ln429">  // explosions</a>
<a name="ln430">  for(int i = 0; i &lt; EXPLOSION_AMOUNT; i++)</a>
<a name="ln431">    d-&gt;explosion_sprite[i] = _new_sprite(explosions[i], EXPLOSION_WIDTH, EXPLOSION_HEIGHT, NULL, &amp;(d-&gt;bufs),</a>
<a name="ln432">                                         &amp;(d-&gt;surfaces), &amp;(d-&gt;patterns));</a>
<a name="ln433">  // bunkers</a>
<a name="ln434">  for(int i = 0; i &lt; 4; i++)</a>
<a name="ln435">  {</a>
<a name="ln436">    d-&gt;bunker_sprite[i] = _new_sprite(bunker, BUNKER_WIDTH, BUNKER_HEIGHT, &amp;d-&gt;bunker_stride, &amp;(d-&gt;bufs),</a>
<a name="ln437">                                      &amp;(d-&gt;surfaces), &amp;(d-&gt;patterns));</a>
<a name="ln438">    d-&gt;bunker_buf[i] = (uint8_t *)g_list_last(d-&gt;bufs)-&gt;data;</a>
<a name="ln439">  }</a>
<a name="ln440">  // font</a>
<a name="ln441">  d-&gt;letters = (cairo_pattern_t **)malloc(n_letters * sizeof(cairo_pattern_t *));</a>
<a name="ln442">  for(int i = 0; i &lt; n_letters; i++)</a>
<a name="ln443">    d-&gt;letters[i]</a>
<a name="ln444">        = _new_sprite(font[i], FONT_WIDTH, FONT_HEIGHT, NULL, &amp;(d-&gt;bufs), &amp;(d-&gt;surfaces), &amp;(d-&gt;patterns));</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447">void cleanup(dt_view_t *self)</a>
<a name="ln448">{</a>
<a name="ln449">  dt_knight_t *d = (dt_knight_t *)self-&gt;data;</a>
<a name="ln450"> </a>
<a name="ln451">  g_list_free_full(d-&gt;patterns, (GDestroyNotify)cairo_pattern_destroy);</a>
<a name="ln452">  g_list_free_full(d-&gt;surfaces, (GDestroyNotify)cairo_surface_destroy);</a>
<a name="ln453">  g_list_free_full(d-&gt;bufs, free);</a>
<a name="ln454"> </a>
<a name="ln455">  free(d-&gt;letters);</a>
<a name="ln456">  free(self-&gt;data);</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">// get the next alien in move order: bottom left to top right</a>
<a name="ln460">static int _next_alien(dt_knight_alien_t *aliens, int current)</a>
<a name="ln461">{</a>
<a name="ln462">  for(int i = 0; i &lt; N_ALIENS_Y * N_ALIENS_X; i++)</a>
<a name="ln463">  {</a>
<a name="ln464">    int x = (current % N_ALIENS_X) + 1;</a>
<a name="ln465">    int y = current / N_ALIENS_X;</a>
<a name="ln466">    if(x == N_ALIENS_X)</a>
<a name="ln467">    {</a>
<a name="ln468">      x = 0;</a>
<a name="ln469">      y = (y - 1 + N_ALIENS_Y) % N_ALIENS_Y;</a>
<a name="ln470">    }</a>
<a name="ln471">    current = x + y * N_ALIENS_X;</a>
<a name="ln472">    if(aliens[current].alive) return current;</a>
<a name="ln473">  }</a>
<a name="ln474">  return -1;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">// get the lowest alien in the left most column</a>
<a name="ln478">static float _leftest(const dt_knight_alien_t *aliens)</a>
<a name="ln479">{</a>
<a name="ln480">  for(int x = 0; x &lt; N_ALIENS_X; x++)</a>
<a name="ln481">    for(int y = N_ALIENS_Y - 1; y &gt;= 0; y--)</a>
<a name="ln482">    {</a>
<a name="ln483">      const int i = x + y * N_ALIENS_X;</a>
<a name="ln484">      if(aliens[i].alive) return aliens[i].x;</a>
<a name="ln485">    }</a>
<a name="ln486">  return 0.0;</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">// get the lowest alien in the rightmost column</a>
<a name="ln490">static float _rightest(const dt_knight_alien_t *aliens)</a>
<a name="ln491">{</a>
<a name="ln492">  for(int x = N_ALIENS_X - 1; x &gt;= 0; x--)</a>
<a name="ln493">    for(int y = N_ALIENS_Y - 1; y &gt;= 0; y--)</a>
<a name="ln494">    {</a>
<a name="ln495">      const int i = x + y * N_ALIENS_X;</a>
<a name="ln496">      if(aliens[i].alive) return aliens[i].x;</a>
<a name="ln497">    }</a>
<a name="ln498">  return 0.0;</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">// reset the spawn timer when removing the mystery ship</a>
<a name="ln502">static inline void _kill_mystery_ship(dt_knight_t *d)</a>
<a name="ln503">{</a>
<a name="ln504">  d-&gt;mystery_ship_x = -1.0;</a>
<a name="ln505">  d-&gt;time_until_mystery_ship = _get_mystery_timeout();</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">// roll a dice to see where the mystery ship will shoot when adding it</a>
<a name="ln509">static inline void _add_mystery_ship(dt_knight_t *d)</a>
<a name="ln510">{</a>
<a name="ln511">  d-&gt;mystery_ship_x = 0.0;</a>
<a name="ln512">  // only shoot once per occurrence</a>
<a name="ln513">  d-&gt;mystery_ship_potential_shot_x = (float)rand() / (float)RAND_MAX;</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">// return a new explosion object with the fields initialized. has to be free()'d</a>
<a name="ln517">static dt_knight_explosion_t *_new_explosion(float x, float y, int ttl, cairo_pattern_t *sprite)</a>
<a name="ln518">{</a>
<a name="ln519">  dt_knight_explosion_t *explosion = (dt_knight_explosion_t *)malloc(sizeof(dt_knight_explosion_t));</a>
<a name="ln520">  explosion-&gt;x = x;</a>
<a name="ln521">  explosion-&gt;y = y;</a>
<a name="ln522">  explosion-&gt;ttl = ttl;</a>
<a name="ln523">  explosion-&gt;sprite = sprite;</a>
<a name="ln524">  return explosion;</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">// change the bunker graphics by subtracting an explosion sprite</a>
<a name="ln528">static void _destroy_bunker(dt_knight_t *d, int bunker, int hit_x, int hit_y)</a>
<a name="ln529">{</a>
<a name="ln530">  uint8_t *buf = d-&gt;bunker_buf[bunker];</a>
<a name="ln531">  // the explosion has stride == width</a>
<a name="ln532">  const uint8_t *ex = explosions[EXPLOSION_SHOT];</a>
<a name="ln533"> </a>
<a name="ln534">  const int ex_half = EXPLOSION_WIDTH / 2.0 + 0.5;</a>
<a name="ln535">  const int ex_x0 = MAX(ex_half - hit_x, 0);</a>
<a name="ln536">  const int ex_x1 = MIN(BUNKER_WIDTH - hit_x + ex_half, EXPLOSION_WIDTH);</a>
<a name="ln537">  const int ex_y0 = MAX(ex_half - hit_y, 0);</a>
<a name="ln538">  const int ex_y1 = MIN(BUNKER_HEIGHT - hit_y + ex_half, EXPLOSION_HEIGHT);</a>
<a name="ln539"> </a>
<a name="ln540">  const int buf_x0 = MAX(hit_x - ex_half, 0);</a>
<a name="ln541">  const int buf_y0 = MAX(hit_y - ex_half, 0);</a>
<a name="ln542"> </a>
<a name="ln543">  for(int y = ex_y0, j = 0; y &lt; ex_y1; y++, j++)</a>
<a name="ln544">    for(int x = ex_x0, i = 0; x &lt; ex_x1; x++, i++)</a>
<a name="ln545">    {</a>
<a name="ln546">      const int in = x + y * EXPLOSION_WIDTH;</a>
<a name="ln547">      const int out = buf_x0 + i + (buf_y0 + j) * d-&gt;bunker_stride;</a>
<a name="ln548">      buf[out] &amp;= ~ex[in];</a>
<a name="ln549">    }</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">// check if a shot hit a bunker and deal out damage if needed</a>
<a name="ln553">static gboolean _hit_bunker(dt_knight_t *d, const dt_knight_shot_t *shot)</a>
<a name="ln554">{</a>
<a name="ln555">  const float top = BUNKER_Y;</a>
<a name="ln556">  const float bottom = BUNKER_Y + BUNKER_TARGET_HEIGHT;</a>
<a name="ln557">  if((shot-&gt;direction &gt; 0.0 &amp;&amp; shot-&gt;y &lt;= bottom &amp;&amp; shot-&gt;y + SHOT_LENGTH &gt;= top)</a>
<a name="ln558">     || (shot-&gt;y &gt;= top &amp;&amp; shot-&gt;y - SHOT_LENGTH &lt;= bottom))</a>
<a name="ln559">  {</a>
<a name="ln560">    // we might have hit a bunker</a>
<a name="ln561">    for(int i = 0; i &lt; 4; i++)</a>
<a name="ln562">    {</a>
<a name="ln563">      const float bunker_x = (i * 2 + 1) * BUNKER_TARGET_WIDTH;</a>
<a name="ln564">      // check the bounding box</a>
<a name="ln565">      if(shot-&gt;x &gt;= bunker_x &amp;&amp; shot-&gt;x &lt;= bunker_x + BUNKER_TARGET_WIDTH)</a>
<a name="ln566">      {</a>
<a name="ln567">        // we are in the bb, now check the pixels, we might have hit a hole</a>
<a name="ln568">        uint8_t *buf = d-&gt;bunker_buf[i];</a>
<a name="ln569">        int pixel_x = ((shot-&gt;x - bunker_x) / BUNKER_TARGET_WIDTH) * BUNKER_WIDTH + 0.5;</a>
<a name="ln570">        pixel_x = CLAMP(pixel_x, 0, BUNKER_WIDTH - 1);</a>
<a name="ln571">        for(int j = 0; j &lt; BUNKER_HEIGHT; j++)</a>
<a name="ln572">        {</a>
<a name="ln573">          const int pixel_y = shot-&gt;direction &gt; 0 ? BUNKER_HEIGHT - 1 - j : j;</a>
<a name="ln574">          const int pixel = pixel_x + pixel_y * d-&gt;bunker_stride;</a>
<a name="ln575">          if(buf[pixel] == 0xff)</a>
<a name="ln576">          {</a>
<a name="ln577">            // destroy it!</a>
<a name="ln578">            _destroy_bunker(d, i, pixel_x, pixel_y);</a>
<a name="ln579">            const float _x</a>
<a name="ln580">                = bunker_x + pixel_x * BUNKER_TARGET_WIDTH / BUNKER_WIDTH - 0.5 * EXPLOSION_TARGET_WIDTH;</a>
<a name="ln581">            const float _y</a>
<a name="ln582">                = BUNKER_Y + pixel_y * BUNKER_TARGET_HEIGHT / BUNKER_HEIGHT - 0.5 * EXPLOSION_TARGET_HEIGHT;</a>
<a name="ln583">            dt_knight_explosion_t *explosion</a>
<a name="ln584">                = _new_explosion(_x, _y, ALIEN_DEATH_TIME, d-&gt;explosion_sprite[EXPLOSION_SHOT]);</a>
<a name="ln585">            d-&gt;explosions = g_list_append(d-&gt;explosions, explosion);</a>
<a name="ln586">            return TRUE;</a>
<a name="ln587">          }</a>
<a name="ln588">        }</a>
<a name="ln589">        break; // can't possibly hit any other bunker</a>
<a name="ln590">      }</a>
<a name="ln591">    }</a>
<a name="ln592">  }</a>
<a name="ln593">  return FALSE;</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">// when an alien occupies the same space as a bunker the touched part gets removed</a>
<a name="ln597">static void _walk_over_bunker(dt_knight_t *d, float x, float y, float w, float h)</a>
<a name="ln598">{</a>
<a name="ln599">  const float top = BUNKER_Y;</a>
<a name="ln600">  const float bottom = BUNKER_Y + BUNKER_TARGET_HEIGHT;</a>
<a name="ln601">  if(y &lt;= bottom &amp;&amp; y + h &gt;= top)</a>
<a name="ln602">  {</a>
<a name="ln603">    // we might have hit a bunker</a>
<a name="ln604">    for(int i = 0; i &lt; 4; i++)</a>
<a name="ln605">    {</a>
<a name="ln606">      const float bunker_x = (i * 2 + 1) * BUNKER_TARGET_WIDTH;</a>
<a name="ln607">      // check the bounding box</a>
<a name="ln608">      if(x + w &gt;= bunker_x &amp;&amp; x &lt;= bunker_x + BUNKER_TARGET_WIDTH)</a>
<a name="ln609">      {</a>
<a name="ln610">        // we are in the bb, clear the rectangle</a>
<a name="ln611">        uint8_t *buf = d-&gt;bunker_buf[i];</a>
<a name="ln612"> </a>
<a name="ln613">        // express x/y relative to bunker_x/bunker_y in bunker pixels</a>
<a name="ln614">        const int pixel_x = (x - bunker_x) / BUNKER_TARGET_WIDTH * BUNKER_WIDTH + 0.5;</a>
<a name="ln615">        const int pixel_y = (y - BUNKER_Y) / BUNKER_TARGET_HEIGHT * BUNKER_HEIGHT + 0.5;</a>
<a name="ln616">        const int pixel_w = w / BUNKER_TARGET_WIDTH * BUNKER_WIDTH + 0.5;</a>
<a name="ln617">        const int pixel_h = h / BUNKER_TARGET_HEIGHT * BUNKER_HEIGHT + 0.5;</a>
<a name="ln618"> </a>
<a name="ln619">        // overlap with bunker</a>
<a name="ln620">        const int overhang_left = MAX(-1 * pixel_x, 0);</a>
<a name="ln621">        const int overhang_right = MAX(pixel_x + pixel_w - BUNKER_WIDTH, 0);</a>
<a name="ln622">        const int overlap_x = pixel_w - overhang_left - overhang_right;</a>
<a name="ln623"> </a>
<a name="ln624">        const int overhang_top = MAX(-1 * pixel_y, 0);</a>
<a name="ln625">        const int overhang_bottom = MAX(pixel_y + pixel_h - BUNKER_HEIGHT, 0);</a>
<a name="ln626">        const int overlap_y = pixel_h - overhang_top - overhang_bottom;</a>
<a name="ln627"> </a>
<a name="ln628">        // the area to clear is (x0, y0) -&gt; (x0 + overlap_x, y0 + overlap_y)</a>
<a name="ln629">        const int x0 = MAX(pixel_x, 0);</a>
<a name="ln630">        const int y0 = MAX(pixel_y, 0);</a>
<a name="ln631"> </a>
<a name="ln632">        for(int _y = y0; _y &lt; y0 + overlap_y; _y++)</a>
<a name="ln633">        {</a>
<a name="ln634">          const int i = x0 + _y * d-&gt;bunker_stride;</a>
<a name="ln635">          memset(&amp;buf[i], 0x00, overlap_x);</a>
<a name="ln636">        }</a>
<a name="ln637">        break; // can't possibly hit any other bunker</a>
<a name="ln638">      }</a>
<a name="ln639">    }</a>
<a name="ln640">  }</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643">// the control logic for the interactive part</a>
<a name="ln644">static gboolean _event_loop_game(dt_knight_t *d)</a>
<a name="ln645">{</a>
<a name="ln646">  // clean up explosions</a>
<a name="ln647">  for(GList *iter = d-&gt;explosions; iter; iter = g_list_next(iter))</a>
<a name="ln648">  {</a>
<a name="ln649">    dt_knight_explosion_t *explosion = (dt_knight_explosion_t *)iter-&gt;data;</a>
<a name="ln650">    explosion-&gt;ttl--;</a>
<a name="ln651">    if(explosion-&gt;ttl == 0)</a>
<a name="ln652">    {</a>
<a name="ln653">      free(explosion);</a>
<a name="ln654">      iter = d-&gt;explosions = g_list_delete_link(d-&gt;explosions, iter);</a>
<a name="ln655">    }</a>
<a name="ln656">  }</a>
<a name="ln657"> </a>
<a name="ln658">  if(d-&gt;freeze &gt; 0)</a>
<a name="ln659">  {</a>
<a name="ln660">    d-&gt;freeze--;</a>
<a name="ln661">    if(d-&gt;freeze == 0 &amp;&amp; d-&gt;total_freeze)</a>
<a name="ln662">    {</a>
<a name="ln663">      // the player was hit. move him to the left</a>
<a name="ln664">      d-&gt;total_freeze = FALSE;</a>
<a name="ln665">      d-&gt;player_x = 0.0;</a>
<a name="ln666">      d-&gt;lifes--;</a>
<a name="ln667">      if(d-&gt;super_total_final_freeze) d-&gt;lifes = 0;</a>
<a name="ln668">    }</a>
<a name="ln669">    if(d-&gt;super_total_final_freeze) goto end;</a>
<a name="ln670">  }</a>
<a name="ln671"> </a>
<a name="ln672">  // handle movement in the event loop to not be affected by X's keyboard repeat rates and delay</a>
<a name="ln673">  if(!d-&gt;total_freeze)</a>
<a name="ln674">    d-&gt;player_x</a>
<a name="ln675">        = CLAMP(d-&gt;player_x + d-&gt;move * PLAYER_TARGET_WIDTH * STEP_SIZE, 0.0, 1.0 - PLAYER_TARGET_WIDTH);</a>
<a name="ln676"> </a>
<a name="ln677">  // spawn a mystery ship roughly every 25 seconds</a>
<a name="ln678">  d-&gt;time_until_mystery_ship--;</a>
<a name="ln679">  if(d-&gt;time_until_mystery_ship == 0)</a>
<a name="ln680">    _add_mystery_ship(d);</a>
<a name="ln681">  else</a>
<a name="ln682">  {</a>
<a name="ln683">    if(d-&gt;mystery_ship_x &gt;= 0.0) d-&gt;mystery_ship_x += MYSTERY_SHIP_TARGET_WIDTH * STEP_SIZE;</a>
<a name="ln684">    if(d-&gt;mystery_ship_x &gt;= 1.0 - MYSTERY_SHIP_TARGET_WIDTH) _kill_mystery_ship(d);</a>
<a name="ln685">  }</a>
<a name="ln686"> </a>
<a name="ln687">  // don't fire in the first 1.5 seconds</a>
<a name="ln688">  if(d-&gt;animation_loop &gt; 1.5 * 1000.0 / LOOP_SPEED)</a>
<a name="ln689">  {</a>
<a name="ln690">    if(d-&gt;freeze == 0)</a>
<a name="ln691">    {</a>
<a name="ln692">      // randomly shoot at the player</a>
<a name="ln693">      if(d-&gt;n_alien_shots &lt; MAX_ALIEN_SHOTS &amp;&amp; rand() % ALIEN_SHOT_PROBABILITY == 0)</a>
<a name="ln694">      {</a>
<a name="ln695">        int column = rand() % N_ALIENS_X;</a>
<a name="ln696">        for(int c = 0; c &lt; N_ALIENS_X; c++)</a>
<a name="ln697">        {</a>
<a name="ln698">          // if the column has no alien left we try the next one</a>
<a name="ln699">          int column_candidate = (column + c) % N_ALIENS_X;</a>
<a name="ln700">          for(int row = N_ALIENS_Y - 1; row &gt;= 0; row--)</a>
<a name="ln701">          {</a>
<a name="ln702">            const int i = row * N_ALIENS_X + column_candidate;</a>
<a name="ln703">            if(!d-&gt;aliens[i].alive) continue;</a>
<a name="ln704"> </a>
<a name="ln705">            // find an empty spot in the shot table</a>
<a name="ln706">            for(int s = 0; s &lt; MAX_ALIEN_SHOTS; s++)</a>
<a name="ln707">            {</a>
<a name="ln708">              if(d-&gt;alien_shots[s].active) continue;</a>
<a name="ln709">              d-&gt;n_alien_shots++;</a>
<a name="ln710">              d-&gt;alien_shots[s].active = TRUE;</a>
<a name="ln711">              d-&gt;alien_shots[s].x = d-&gt;aliens[i].x + 0.5 * ALIEN_TARGET_WIDTH;</a>
<a name="ln712">              d-&gt;alien_shots[s].y = d-&gt;alien_shots[s].start</a>
<a name="ln713">                  = d-&gt;aliens[i].y + ALIEN_TARGET_HEIGHT + SHOT_LENGTH;</a>
<a name="ln714">              d-&gt;alien_shots[s].direction = -1.0;</a>
<a name="ln715">              goto alien_shots_fired;</a>
<a name="ln716">            }</a>
<a name="ln717">          }</a>
<a name="ln718">        }</a>
<a name="ln719">      }</a>
<a name="ln720">    }</a>
<a name="ln721">  alien_shots_fired:</a>
<a name="ln722"> </a>
<a name="ln723">    // the mystery ship can shoot, too</a>
<a name="ln724">    if(d-&gt;mystery_ship_x &gt;= d-&gt;mystery_ship_potential_shot_x - 0.5 * MYSTERY_SHIP_TARGET_WIDTH</a>
<a name="ln725">       &amp;&amp; !d-&gt;alien_shots[MAX_ALIEN_SHOTS].active)</a>
<a name="ln726">    {</a>
<a name="ln727">      d-&gt;mystery_ship_potential_shot_x = 2.0;</a>
<a name="ln728">      d-&gt;alien_shots[MAX_ALIEN_SHOTS].active = TRUE;</a>
<a name="ln729">      d-&gt;alien_shots[MAX_ALIEN_SHOTS].x = d-&gt;mystery_ship_x + 0.5 * MYSTERY_SHIP_TARGET_WIDTH;</a>
<a name="ln730">      d-&gt;alien_shots[MAX_ALIEN_SHOTS].y = d-&gt;alien_shots[MAX_ALIEN_SHOTS].start</a>
<a name="ln731">          = MYSTERY_SHIP_Y + MYSTERY_SHIP_TARGET_HEIGHT + SHOT_LENGTH;</a>
<a name="ln732">      d-&gt;alien_shots[MAX_ALIEN_SHOTS].direction = -1.0;</a>
<a name="ln733">    }</a>
<a name="ln734">  }</a>
<a name="ln735">  else</a>
<a name="ln736">    d-&gt;animation_loop++;</a>
<a name="ln737"> </a>
<a name="ln738">  // move shots</a>
<a name="ln739">  // the player shot</a>
<a name="ln740">  if(d-&gt;player_shot.active)</a>
<a name="ln741">  {</a>
<a name="ln742">    d-&gt;player_shot.y -= SHOT_LENGTH;</a>
<a name="ln743"> </a>
<a name="ln744">    // TODO: setting this to 0.0 means we can shoot between the aliens. is that what the original did?</a>
<a name="ln745">    const float half_gap = ALIEN_TARGET_WIDTH * (GAP - 1.0) / 2.0;</a>
<a name="ln746"> </a>
<a name="ln747">    // did the player hit something?</a>
<a name="ln748">    // check aliens</a>
<a name="ln749">    for(int i = 0; i &lt; N_ALIENS_Y * N_ALIENS_X; i++)</a>
<a name="ln750">    {</a>
<a name="ln751">      dt_knight_alien_t *alien = &amp;d-&gt;aliens[i];</a>
<a name="ln752">      if(!alien-&gt;alive) continue;</a>
<a name="ln753">      if(d-&gt;player_shot.x &gt;= alien-&gt;x - half_gap</a>
<a name="ln754">         &amp;&amp; d-&gt;player_shot.x &lt;= alien-&gt;x + ALIEN_TARGET_WIDTH + half_gap</a>
<a name="ln755">         &amp;&amp; d-&gt;player_shot.y &gt;= alien-&gt;y - SHOT_LENGTH &amp;&amp; d-&gt;player_shot.y &lt;= alien-&gt;y + ALIEN_TARGET_HEIGHT)</a>
<a name="ln756">      {</a>
<a name="ln757">        // we hit an alien</a>
<a name="ln758">        d-&gt;freeze = ALIEN_DEATH_TIME;</a>
<a name="ln759">        d-&gt;player_shot.active = FALSE;</a>
<a name="ln760">        alien-&gt;alive = FALSE;</a>
<a name="ln761">        d-&gt;n_aliens--;</a>
<a name="ln762">        d-&gt;score_1 += alien-&gt;points;</a>
<a name="ln763">        dt_knight_explosion_t *explosion</a>
<a name="ln764">            = _new_explosion(alien-&gt;x, alien-&gt;y, ALIEN_DEATH_TIME, d-&gt;explosion_sprite[EXPLOSION_ALIEN]);</a>
<a name="ln765">        d-&gt;explosions = g_list_append(d-&gt;explosions, explosion);</a>
<a name="ln766">        if(d-&gt;alien_next_to_move == i) d-&gt;alien_next_to_move = _next_alien(d-&gt;aliens, d-&gt;alien_next_to_move);</a>
<a name="ln767">        break;</a>
<a name="ln768">      }</a>
<a name="ln769">    }</a>
<a name="ln770"> </a>
<a name="ln771">    // test other stuff</a>
<a name="ln772">    if(d-&gt;player_shot.y &lt;= 2.5 * LETTER_HEIGHT)</a>
<a name="ln773">    {</a>
<a name="ln774">      // we hit the top of the board</a>
<a name="ln775">      d-&gt;player_shot.active = FALSE;</a>
<a name="ln776">      dt_knight_explosion_t *explosion</a>
<a name="ln777">          = _new_explosion(d-&gt;player_shot.x - 0.5 * EXPLOSION_TARGET_WIDTH, 2.5 * LETTER_HEIGHT,</a>
<a name="ln778">                           ALIEN_DEATH_TIME, d-&gt;explosion_sprite[EXPLOSION_TOP]);</a>
<a name="ln779">      d-&gt;explosions = g_list_append(d-&gt;explosions, explosion);</a>
<a name="ln780">    }</a>
<a name="ln781">    else if(d-&gt;player_shot.x &gt;= d-&gt;mystery_ship_x</a>
<a name="ln782">            &amp;&amp; d-&gt;player_shot.x &lt;= d-&gt;mystery_ship_x + MYSTERY_SHIP_TARGET_WIDTH</a>
<a name="ln783">            &amp;&amp; d-&gt;player_shot.y &gt;= MYSTERY_SHIP_Y - SHOT_LENGTH</a>
<a name="ln784">            &amp;&amp; d-&gt;player_shot.y &lt;= MYSTERY_SHIP_Y + MYSTERY_SHIP_TARGET_HEIGHT)</a>
<a name="ln785">    {</a>
<a name="ln786">      // we hit the mystery ship</a>
<a name="ln787">      d-&gt;player_shot.active = FALSE;</a>
<a name="ln788">      d-&gt;score_1 += 50;</a>
<a name="ln789">      dt_knight_explosion_t *explosion = _new_explosion(d-&gt;mystery_ship_x, MYSTERY_SHIP_Y, ALIEN_DEATH_TIME,</a>
<a name="ln790">                                                        d-&gt;explosion_sprite[EXPLOSION_MYSTERY]);</a>
<a name="ln791">      d-&gt;explosions = g_list_append(d-&gt;explosions, explosion);</a>
<a name="ln792">      _kill_mystery_ship(d);</a>
<a name="ln793">    }</a>
<a name="ln794">    else if(_hit_bunker(d, &amp;d-&gt;player_shot))</a>
<a name="ln795">    {</a>
<a name="ln796">      // we hit a bunker</a>
<a name="ln797">      d-&gt;player_shot.active = FALSE;</a>
<a name="ln798">    }</a>
<a name="ln799"> </a>
<a name="ln800">    // shot vs. shot is tested later</a>
<a name="ln801">  }</a>
<a name="ln802"> </a>
<a name="ln803"> </a>
<a name="ln804">  // now move the alien shots</a>
<a name="ln805">  gboolean was_hit = d-&gt;total_freeze; // guard against several hits at once</a>
<a name="ln806">  for(int s = 0; s &lt; MAX_ALIEN_SHOTS + 1; s++)</a>
<a name="ln807">  {</a>
<a name="ln808">    dt_knight_shot_t *shot = &amp;d-&gt;alien_shots[s];</a>
<a name="ln809">    if(!shot-&gt;active) continue;</a>
<a name="ln810"> </a>
<a name="ln811">    shot-&gt;y += SHOT_LENGTH;</a>
<a name="ln812"> </a>
<a name="ln813">    if(shot-&gt;x &gt;= d-&gt;player_x - 0.2 * PLAYER_TARGET_WIDTH</a>
<a name="ln814">       &amp;&amp; shot-&gt;x &lt;= d-&gt;player_x + 1.2 * PLAYER_TARGET_WIDTH &amp;&amp; shot-&gt;y &gt;= PLAYER_Y</a>
<a name="ln815">       &amp;&amp; shot-&gt;y &lt;= PLAYER_Y + PLAYER_TARGET_HEIGHT + SHOT_LENGTH)</a>
<a name="ln816">    {</a>
<a name="ln817">      // we hit the player. he is immune when the alien was directly above him!</a>
<a name="ln818">      if(shot-&gt;start &lt;= PLAYER_Y - ALIEN_TARGET_HEIGHT &amp;&amp; !was_hit)</a>
<a name="ln819">      {</a>
<a name="ln820">        was_hit = TRUE;</a>
<a name="ln821">        d-&gt;freeze = 3.0 * 1000.0 / LOOP_SPEED;</a>
<a name="ln822">        d-&gt;total_freeze = TRUE;</a>
<a name="ln823">      }</a>
<a name="ln824">      shot-&gt;active = FALSE;</a>
<a name="ln825">      d-&gt;n_alien_shots--;</a>
<a name="ln826">    }</a>
<a name="ln827">    else if(d-&gt;player_shot.active &amp;&amp; fabs(shot-&gt;x - d-&gt;player_shot.x) &lt; 0.4 * CELL_WIDTH</a>
<a name="ln828">            &amp;&amp; shot-&gt;y &gt;= d-&gt;player_shot.y) // they can only meet from one direction</a>
<a name="ln829">    {</a>
<a name="ln830">      // the player hit the alien's shot. destroy it. there's a 50% chance that the player shot survives</a>
<a name="ln831">      // FIXME: is it this way or the other way round?</a>
<a name="ln832">      shot-&gt;active = FALSE;</a>
<a name="ln833">      d-&gt;n_alien_shots--;</a>
<a name="ln834">      if(rand() % 2 == 0) d-&gt;player_shot.active = FALSE;</a>
<a name="ln835">      dt_knight_explosion_t *explosion</a>
<a name="ln836">          = _new_explosion(d-&gt;player_shot.x - 0.5 * EXPLOSION_TARGET_WIDTH, d-&gt;player_shot.y,</a>
<a name="ln837">                           ALIEN_DEATH_TIME, d-&gt;explosion_sprite[EXPLOSION_SHOT]);</a>
<a name="ln838">      d-&gt;explosions = g_list_append(d-&gt;explosions, explosion);</a>
<a name="ln839">    }</a>
<a name="ln840">    else if(_hit_bunker(d, shot))</a>
<a name="ln841">    {</a>
<a name="ln842">      // we hit a bunker</a>
<a name="ln843">      shot-&gt;active = FALSE;</a>
<a name="ln844">      d-&gt;n_alien_shots--;</a>
<a name="ln845">    }</a>
<a name="ln846">    else if(shot-&gt;y &gt;= BOTTOM_MARGIN)</a>
<a name="ln847">    {</a>
<a name="ln848">      // we hit the ground</a>
<a name="ln849">      shot-&gt;active = FALSE;</a>
<a name="ln850">      d-&gt;n_alien_shots--;</a>
<a name="ln851">      dt_knight_explosion_t *explosion</a>
<a name="ln852">          = _new_explosion(shot-&gt;x - 0.5 * EXPLOSION_TARGET_WIDTH, BOTTOM_MARGIN - EXPLOSION_TARGET_HEIGHT,</a>
<a name="ln853">                           ALIEN_DEATH_TIME, d-&gt;explosion_sprite[EXPLOSION_BOTTOM]);</a>
<a name="ln854">      d-&gt;explosions = g_list_append(d-&gt;explosions, explosion);</a>
<a name="ln855">    }</a>
<a name="ln856">  }</a>
<a name="ln857"> </a>
<a name="ln858"> </a>
<a name="ln859">  // move in blocks of 2</a>
<a name="ln860">  if(d-&gt;freeze == 0)</a>
<a name="ln861">  {</a>
<a name="ln862">    for(int i = 0; i &lt; 2; i++)</a>
<a name="ln863">    {</a>
<a name="ln864">      if(d-&gt;alien_next_to_move == -1) break;</a>
<a name="ln865">      const int x = d-&gt;alien_next_to_move % N_ALIENS_X;</a>
<a name="ln866">      const int y = d-&gt;alien_next_to_move / N_ALIENS_X;</a>
<a name="ln867">      const int next = _next_alien(d-&gt;aliens, d-&gt;alien_next_to_move);</a>
<a name="ln868">      const int next_x = next % N_ALIENS_X;</a>
<a name="ln869">      const int next_y = next / N_ALIENS_X;</a>
<a name="ln870">      dt_knight_alien_t *alien = &amp;d-&gt;aliens[d-&gt;alien_next_to_move];</a>
<a name="ln871">      switch(d-&gt;alien_direction)</a>
<a name="ln872">      {</a>
<a name="ln873">        case ALIEN_LEFT:</a>
<a name="ln874">          alien-&gt;x -= STEP_SIZE * ALIEN_TARGET_WIDTH;</a>
<a name="ln875">          if((next_y &gt; y || (next_y == y &amp;&amp; next_x &lt; x) || next == d-&gt;alien_next_to_move)</a>
<a name="ln876">             &amp;&amp; _leftest(d-&gt;aliens) - STEP_SIZE * ALIEN_TARGET_WIDTH &lt; 0.0)</a>
<a name="ln877">            d-&gt;alien_direction = ALIEN_DOWN_THEN_RIGHT;</a>
<a name="ln878">          break;</a>
<a name="ln879">        case ALIEN_RIGHT:</a>
<a name="ln880">          alien-&gt;x += STEP_SIZE * ALIEN_TARGET_WIDTH;</a>
<a name="ln881">          if((next_y &gt; y || (next_y == y &amp;&amp; next_x &lt; x) || next == d-&gt;alien_next_to_move)</a>
<a name="ln882">             &amp;&amp; _rightest(d-&gt;aliens) + ALIEN_TARGET_WIDTH + STEP_SIZE * ALIEN_TARGET_WIDTH &gt; 1.0)</a>
<a name="ln883">            d-&gt;alien_direction = ALIEN_DOWN_THEN_LEFT;</a>
<a name="ln884">          break;</a>
<a name="ln885">        case ALIEN_DOWN_THEN_LEFT:</a>
<a name="ln886">        case ALIEN_DOWN_THEN_RIGHT:</a>
<a name="ln887">          alien-&gt;y += 0.5 * ALIEN_TARGET_HEIGHT;</a>
<a name="ln888">          if(alien-&gt;y + ALIEN_TARGET_HEIGHT &gt;= PLAYER_Y + 0.5 * PLAYER_TARGET_HEIGHT)</a>
<a name="ln889">          {</a>
<a name="ln890">            d-&gt;freeze = 3.0 * 1000.0 / LOOP_SPEED;</a>
<a name="ln891">            d-&gt;total_freeze = TRUE;</a>
<a name="ln892">            d-&gt;super_total_final_freeze = TRUE;</a>
<a name="ln893">          }</a>
<a name="ln894">          if(next_y &gt; y || (next_y == y &amp;&amp; next_x &lt; x) || next == d-&gt;alien_next_to_move)</a>
<a name="ln895">            d-&gt;alien_direction = (d-&gt;alien_direction == ALIEN_DOWN_THEN_LEFT ? ALIEN_LEFT : ALIEN_RIGHT);</a>
<a name="ln896">          break;</a>
<a name="ln897">      }</a>
<a name="ln898"> </a>
<a name="ln899">      // when going over a bunker it (the bunker) gets destroyed</a>
<a name="ln900">      _walk_over_bunker(d, alien-&gt;x, alien-&gt;y, ALIEN_TARGET_WIDTH, ALIEN_TARGET_HEIGHT);</a>
<a name="ln901"> </a>
<a name="ln902">      // allow the last one to go really fast, but keep it animating</a>
<a name="ln903">      if(!(i == 0 &amp;&amp; d-&gt;alien_next_to_move == next)) alien-&gt;frame = 1 - alien-&gt;frame;</a>
<a name="ln904">      d-&gt;alien_next_to_move = next;</a>
<a name="ln905">    }</a>
<a name="ln906">  }</a>
<a name="ln907"> </a>
<a name="ln908">end:</a>
<a name="ln909">  // finally, did one side win?</a>
<a name="ln910">  if(d-&gt;n_aliens == 0)</a>
<a name="ln911">  {</a>
<a name="ln912">    d-&gt;high_score = MAX(d-&gt;score_1, d-&gt;high_score);</a>
<a name="ln913">    d-&gt;game_state = WIN;</a>
<a name="ln914">    d-&gt;animation_loop = 0;</a>
<a name="ln915">  }</a>
<a name="ln916"> </a>
<a name="ln917">  if(d-&gt;lifes == 0)</a>
<a name="ln918">  {</a>
<a name="ln919">    d-&gt;game_state = LOSE;</a>
<a name="ln920">    d-&gt;animation_loop = 0;</a>
<a name="ln921">  }</a>
<a name="ln922"> </a>
<a name="ln923">  return TRUE;</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926">// the control logic for the non-interactive part: just count up the frames</a>
<a name="ln927">static gboolean _event_loop_animation(dt_knight_t *d)</a>
<a name="ln928">{</a>
<a name="ln929">  d-&gt;animation_loop++;</a>
<a name="ln930">  return TRUE;</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">// control dispatcher, makes sure that the screen is redrawn afterwards</a>
<a name="ln934">static gboolean _event_loop(gpointer user_data)</a>
<a name="ln935">{</a>
<a name="ln936">  dt_knight_t *d = (dt_knight_t *)user_data;</a>
<a name="ln937">  gboolean res;</a>
<a name="ln938">  switch(d-&gt;game_state)</a>
<a name="ln939">  {</a>
<a name="ln940">    case INTRO:</a>
<a name="ln941">    case START:</a>
<a name="ln942">    case WIN:</a>
<a name="ln943">    case LOSE:</a>
<a name="ln944">      res = _event_loop_animation(d);</a>
<a name="ln945">      break;</a>
<a name="ln946">    case GAME:</a>
<a name="ln947">      res = _event_loop_game(d);</a>
<a name="ln948">      break;</a>
<a name="ln949">  }</a>
<a name="ln950">  dt_control_queue_redraw_center();</a>
<a name="ln951">  return res;</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954">void enter(dt_view_t *self)</a>
<a name="ln955">{</a>
<a name="ln956">  dt_knight_t *d = (dt_knight_t *)self-&gt;data;</a>
<a name="ln957"> </a>
<a name="ln958">  dt_control_change_cursor(GDK_BLANK_CURSOR);</a>
<a name="ln959"> </a>
<a name="ln960">  dt_ui_panel_show(darktable.gui-&gt;ui, DT_UI_PANEL_LEFT, FALSE, TRUE);</a>
<a name="ln961">  dt_ui_panel_show(darktable.gui-&gt;ui, DT_UI_PANEL_RIGHT, FALSE, TRUE);</a>
<a name="ln962">  dt_ui_panel_show(darktable.gui-&gt;ui, DT_UI_PANEL_TOP, FALSE, TRUE);</a>
<a name="ln963">  dt_ui_panel_show(darktable.gui-&gt;ui, DT_UI_PANEL_BOTTOM, FALSE, TRUE);</a>
<a name="ln964">  dt_ui_panel_show(darktable.gui-&gt;ui, DT_UI_PANEL_CENTER_TOP, FALSE, TRUE);</a>
<a name="ln965">  dt_ui_panel_show(darktable.gui-&gt;ui, DT_UI_PANEL_CENTER_BOTTOM, FALSE, TRUE);</a>
<a name="ln966"> </a>
<a name="ln967">  // set the initial game state</a>
<a name="ln968">  switch(d-&gt;game_state)</a>
<a name="ln969">  {</a>
<a name="ln970">    case GAME: // allow to pause by leaving the view</a>
<a name="ln971">      break;</a>
<a name="ln972">    case WIN:</a>
<a name="ln973">    case LOSE:</a>
<a name="ln974">      // don't show the full intro again. it gets annoying</a>
<a name="ln975">      d-&gt;game_state = START;</a>
<a name="ln976">    case INTRO:</a>
<a name="ln977">    case START:</a>
<a name="ln978">      // restart the current state</a>
<a name="ln979">      d-&gt;animation_loop = 0;</a>
<a name="ln980">      _reset_board(d);</a>
<a name="ln981">      break;</a>
<a name="ln982">  }</a>
<a name="ln983"> </a>
<a name="ln984">  // start event loop</a>
<a name="ln985">  d-&gt;event_loop = g_timeout_add(LOOP_SPEED, _event_loop, d);</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">void leave(dt_view_t *self)</a>
<a name="ln989">{</a>
<a name="ln990">  dt_knight_t *d = (dt_knight_t *)self-&gt;data;</a>
<a name="ln991"> </a>
<a name="ln992">  // show normal gui again</a>
<a name="ln993">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln994"> </a>
<a name="ln995">  // stop event loop</a>
<a name="ln996">  if(d-&gt;event_loop &gt; 0) g_source_remove(d-&gt;event_loop);</a>
<a name="ln997">  d-&gt;event_loop = 0;</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000">// set the sprite's matrix to scale it up to the desired size to deal with the window size</a>
<a name="ln1001">static void _scale_sprite(cairo_pattern_t *pattern, const int width, const float target_width)</a>
<a name="ln1002">{</a>
<a name="ln1003">  cairo_matrix_t matrix;</a>
<a name="ln1004">  const float s = width / target_width;</a>
<a name="ln1005">  cairo_matrix_init_scale(&amp;matrix, s, s);</a>
<a name="ln1006">  cairo_pattern_set_matrix(pattern, &amp;matrix);</a>
<a name="ln1007">}</a>
<a name="ln1008"> </a>
<a name="ln1009">// show text using the font described in knight_font.h</a>
<a name="ln1010">// text can be justified left ('l'), right ('r') or centered ('c')</a>
<a name="ln1011">static void _show_text(cairo_t *cr, cairo_pattern_t **letters, const char *text, float x, float y, float w,</a>
<a name="ln1012">                       float h, char justify)</a>
<a name="ln1013">{</a>
<a name="ln1014">  const int l = strlen(text);</a>
<a name="ln1015">  const float spacing = LETTER_SPACING * w;</a>
<a name="ln1016">  cairo_save(cr);</a>
<a name="ln1017">  cairo_translate(cr, x, y);</a>
<a name="ln1018">  if(justify == 'c')</a>
<a name="ln1019">  {</a>
<a name="ln1020">    const float justify_offset</a>
<a name="ln1021">        = (-1 * (int)(l / 2.0 + 0.5) * LETTER_SPACING + LETTER_SPACING - LETTER_WIDTH) * w;</a>
<a name="ln1022">    cairo_translate(cr, justify_offset, 0);</a>
<a name="ln1023">  }</a>
<a name="ln1024">  else if(justify == 'r')</a>
<a name="ln1025">  {</a>
<a name="ln1026">    const float justify_offset = (-1 * l * LETTER_SPACING + LETTER_SPACING - LETTER_WIDTH) * w;</a>
<a name="ln1027">    cairo_translate(cr, justify_offset, 0);</a>
<a name="ln1028">  }</a>
<a name="ln1029">  for(int i = 0; i &lt; l; i++)</a>
<a name="ln1030">  {</a>
<a name="ln1031">    unsigned int c = (text[i] - ' ') % n_letters;</a>
<a name="ln1032">    cairo_mask(cr, letters[c]);</a>
<a name="ln1033">    cairo_translate(cr, spacing, 0);</a>
<a name="ln1034">  }</a>
<a name="ln1035">  cairo_fill(cr);</a>
<a name="ln1036">  cairo_restore(cr);</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">// helper functions to draw specific parts of the GUI</a>
<a name="ln1040">static void _show_top_line(dt_knight_t *d, cairo_t *cr, int32_t w, int32_t h)</a>
<a name="ln1041">{</a>
<a name="ln1042">  _show_text(cr, d-&gt;letters, &quot;SCORE&lt;1&gt;&quot;, LETTER_WIDTH * w, 0.0, w, h, 'l');</a>
<a name="ln1043">  _show_text(cr, d-&gt;letters, &quot;HI-SCORE&quot;, 0.5 * w, 0.0, w, h, 'c');</a>
<a name="ln1044">  _show_text(cr, d-&gt;letters, &quot;SCORE&lt;2&gt;&quot;, (1.0 - LETTER_WIDTH) * w, 0.0, w, h, 'r');</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">static void _show_score_1(dt_knight_t *d, cairo_t *cr, int32_t w, int32_t h)</a>
<a name="ln1048">{</a>
<a name="ln1049">  char text[64];</a>
<a name="ln1050">  snprintf(text, sizeof(text), &quot;%04d&quot;, d-&gt;score_1);</a>
<a name="ln1051">  _show_text(cr, d-&gt;letters, text, (LETTER_WIDTH + LETTER_SPACING * 2) * w, 2 * LETTER_HEIGHT * w, w, h, 'l');</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054">static void _show_score_2(dt_knight_t *d, cairo_t *cr, int32_t w, int32_t h)</a>
<a name="ln1055">{</a>
<a name="ln1056">  char text[64];</a>
<a name="ln1057">  snprintf(text, sizeof(text), &quot;%04d&quot;, d-&gt;score_2);</a>
<a name="ln1058">  _show_text(cr, d-&gt;letters, text, (1.0 - (LETTER_WIDTH + LETTER_SPACING * 2)) * w, 2 * LETTER_HEIGHT * w, w,</a>
<a name="ln1059">             h, 'r');</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062">static void _show_high_score(dt_knight_t *d, cairo_t *cr, int32_t w, int32_t h)</a>
<a name="ln1063">{</a>
<a name="ln1064">  char text[64];</a>
<a name="ln1065">  snprintf(text, sizeof(text), &quot;%04d&quot;, d-&gt;high_score);</a>
<a name="ln1066">  _show_text(cr, d-&gt;letters, text, 0.5 * w, 2 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1067">}</a>
<a name="ln1068"> </a>
<a name="ln1069">static void _show_credit(dt_knight_t *d, cairo_t *cr, int32_t w, int32_t h)</a>
<a name="ln1070">{</a>
<a name="ln1071">  char text[64];</a>
<a name="ln1072">  snprintf(text, sizeof(text), &quot;CREDIT %02d&quot;, d-&gt;credit);</a>
<a name="ln1073">  _show_text(cr, d-&gt;letters, text, (1.0 - LETTER_WIDTH - LETTER_SPACING) * w, h - (2 * LETTER_HEIGHT) * w, w,</a>
<a name="ln1074">             h, 'r');</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077">static void _show_lifes(dt_knight_t *d, cairo_t *cr, int32_t w, int32_t h)</a>
<a name="ln1078">{</a>
<a name="ln1079">  char text[64];</a>
<a name="ln1080"> </a>
<a name="ln1081">  cairo_save(cr);</a>
<a name="ln1082">  cairo_translate(cr, 0, h - (2 * LETTER_HEIGHT) * w);</a>
<a name="ln1083"> </a>
<a name="ln1084">  cairo_set_source_rgb(cr, 1, 1, 1);</a>
<a name="ln1085">  snprintf(text, sizeof(text), &quot;%d&quot;, d-&gt;lifes);</a>
<a name="ln1086">  _show_text(cr, d-&gt;letters, text, LETTER_WIDTH * w, 0.0, w, h, 'l');</a>
<a name="ln1087"> </a>
<a name="ln1088">  cairo_set_source_rgb(cr, 0, 1, 0);</a>
<a name="ln1089">  cairo_translate(cr, (LETTER_SPACING + GAP * PLAYER_TARGET_WIDTH) * w, 0);</a>
<a name="ln1090">  for(int i = 0; i &lt; d-&gt;lifes - 1; i++)</a>
<a name="ln1091">  {</a>
<a name="ln1092">    cairo_mask(cr, d-&gt;player_sprite[0]);</a>
<a name="ln1093">    cairo_translate(cr, GAP * PLAYER_TARGET_WIDTH * w, 0);</a>
<a name="ln1094">  }</a>
<a name="ln1095">  cairo_restore(cr);</a>
<a name="ln1096">  cairo_fill(cr);</a>
<a name="ln1097">}</a>
<a name="ln1098"> </a>
<a name="ln1099">static void _show_bunkers(dt_knight_t *d, cairo_t *cr, int32_t w, int32_t h)</a>
<a name="ln1100">{</a>
<a name="ln1101">  cairo_save(cr);</a>
<a name="ln1102">  cairo_set_source_rgb(cr, 0, 1, 0);</a>
<a name="ln1103">  cairo_translate(cr, BUNKER_TARGET_WIDTH * w, BUNKER_Y * h);</a>
<a name="ln1104">  for(int i = 0; i &lt; 4; i++)</a>
<a name="ln1105">  {</a>
<a name="ln1106">    cairo_mask(cr, d-&gt;bunker_sprite[i]);</a>
<a name="ln1107">    cairo_translate(cr, 2 * BUNKER_TARGET_WIDTH * w, 0);</a>
<a name="ln1108">  }</a>
<a name="ln1109">  cairo_fill(cr);</a>
<a name="ln1110">  cairo_restore(cr);</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">static void _show_aliens(dt_knight_t *d, cairo_t *cr, int32_t w, int32_t h)</a>
<a name="ln1114">{</a>
<a name="ln1115">  cairo_save(cr);</a>
<a name="ln1116">  for(int y = 0; y &lt; N_ALIENS_Y; y++)</a>
<a name="ln1117">    for(int x = 0; x &lt; N_ALIENS_X; x++)</a>
<a name="ln1118">    {</a>
<a name="ln1119">      int i = y * N_ALIENS_X + x;</a>
<a name="ln1120">      if(!d-&gt;aliens[i].alive) continue;</a>
<a name="ln1121">      cairo_save(cr);</a>
<a name="ln1122">      cairo_translate(cr, d-&gt;aliens[i].x * w, d-&gt;aliens[i].y * h);</a>
<a name="ln1123">      cairo_mask(cr, d-&gt;alien_sprite[d-&gt;aliens[i].frame]);</a>
<a name="ln1124">      cairo_fill(cr);</a>
<a name="ln1125">      cairo_restore(cr);</a>
<a name="ln1126">    }</a>
<a name="ln1127">  cairo_restore(cr);</a>
<a name="ln1128">}</a>
<a name="ln1129"> </a>
<a name="ln1130">static void _show_ground(dt_knight_t *d, cairo_t *cr, int32_t w, int32_t h)</a>
<a name="ln1131">{</a>
<a name="ln1132">  cairo_set_line_width(cr, h / 250.0);</a>
<a name="ln1133">  cairo_set_source_rgb(cr, 0, 1, 0);</a>
<a name="ln1134">  float y = BOTTOM_MARGIN * h;</a>
<a name="ln1135">  cairo_move_to(cr, 0, y);</a>
<a name="ln1136">  cairo_line_to(cr, w, y);</a>
<a name="ln1137">  cairo_stroke(cr);</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">static void _show_shot(dt_knight_t *d, cairo_t *cr, int32_t w, int32_t h, dt_knight_shot_t *shot)</a>
<a name="ln1141">{</a>
<a name="ln1142">  if(shot-&gt;active)</a>
<a name="ln1143">  {</a>
<a name="ln1144">    cairo_move_to(cr, shot-&gt;x * w, shot-&gt;y * h);</a>
<a name="ln1145">    cairo_rel_line_to(cr, 0, shot-&gt;direction * SHOT_LENGTH * w);</a>
<a name="ln1146">    cairo_stroke(cr);</a>
<a name="ln1147">  }</a>
<a name="ln1148">}</a>
<a name="ln1149"> </a>
<a name="ln1150">// display the running game, according to its state</a>
<a name="ln1151">static void _expose_game(dt_knight_t *d, cairo_t *cr, int32_t w, int32_t h)</a>
<a name="ln1152">{</a>
<a name="ln1153">  // draw the bottom ground line</a>
<a name="ln1154">  _show_ground(d, cr, w, h);</a>
<a name="ln1155"> </a>
<a name="ln1156">  // draw shots</a>
<a name="ln1157">  cairo_set_source_rgb(cr, 1, 1, 1);</a>
<a name="ln1158">  _show_shot(d, cr, w, h, &amp;d-&gt;player_shot);</a>
<a name="ln1159">  for(int s = 0; s &lt; MAX_ALIEN_SHOTS + 1; s++) _show_shot(d, cr, w, h, &amp;d-&gt;alien_shots[s]);</a>
<a name="ln1160"> </a>
<a name="ln1161"> </a>
<a name="ln1162">  cairo_set_line_width(cr, 1); // was set by _show_ground()</a>
<a name="ln1163"> </a>
<a name="ln1164"> </a>
<a name="ln1165">  // draw player</a>
<a name="ln1166">  cairo_set_source_rgb(cr, 0, 1, 0);</a>
<a name="ln1167">  cairo_save(cr);</a>
<a name="ln1168">  cairo_translate(cr, d-&gt;player_x * w, PLAYER_Y * h);</a>
<a name="ln1169">  if(d-&gt;total_freeze)</a>
<a name="ln1170">    // explosion animation</a>
<a name="ln1171">    cairo_mask(cr, d-&gt;player_sprite[1 + (d-&gt;freeze % 4) / 2]);</a>
<a name="ln1172">  else</a>
<a name="ln1173">    // normal graphic</a>
<a name="ln1174">    cairo_mask(cr, d-&gt;player_sprite[0]);</a>
<a name="ln1175">  cairo_fill(cr);</a>
<a name="ln1176">  cairo_restore(cr);</a>
<a name="ln1177"> </a>
<a name="ln1178"> </a>
<a name="ln1179">  // draw bunkers</a>
<a name="ln1180">  _show_bunkers(d, cr, w, h);</a>
<a name="ln1181"> </a>
<a name="ln1182"> </a>
<a name="ln1183">  // draw the alien block</a>
<a name="ln1184">  cairo_set_source_rgb(cr, 1, 1, 1);</a>
<a name="ln1185">  _show_aliens(d, cr, w, h);</a>
<a name="ln1186"> </a>
<a name="ln1187"> </a>
<a name="ln1188">  // draw mystery ship</a>
<a name="ln1189">  if(d-&gt;mystery_ship_x &gt;= 0.0)</a>
<a name="ln1190">  {</a>
<a name="ln1191">    cairo_save(cr);</a>
<a name="ln1192">    cairo_set_source_rgb(cr, 1, 0, 0);</a>
<a name="ln1193">    cairo_translate(cr, d-&gt;mystery_ship_x * w, MYSTERY_SHIP_Y * h);</a>
<a name="ln1194">    cairo_mask(cr, d-&gt;mystery_sprite);</a>
<a name="ln1195">    cairo_fill(cr);</a>
<a name="ln1196">    cairo_restore(cr);</a>
<a name="ln1197">  }</a>
<a name="ln1198"> </a>
<a name="ln1199"> </a>
<a name="ln1200">  // draw explosions</a>
<a name="ln1201">  cairo_set_source_rgb(cr, 1, 1, 1);</a>
<a name="ln1202">  for(GList *iter = d-&gt;explosions; iter; iter = g_list_next(iter))</a>
<a name="ln1203">  {</a>
<a name="ln1204">    dt_knight_explosion_t *explosion = (dt_knight_explosion_t *)iter-&gt;data;</a>
<a name="ln1205">    cairo_save(cr);</a>
<a name="ln1206">    cairo_translate(cr, explosion-&gt;x * w, explosion-&gt;y * h);</a>
<a name="ln1207">    cairo_mask(cr, explosion-&gt;sprite);</a>
<a name="ln1208">    cairo_fill(cr);</a>
<a name="ln1209">    cairo_restore(cr);</a>
<a name="ln1210">  }</a>
<a name="ln1211"> </a>
<a name="ln1212"> </a>
<a name="ln1213">  // draw overlay</a>
<a name="ln1214">  _show_top_line(d, cr, w, h);</a>
<a name="ln1215">  _show_score_1(d, cr, w, h);</a>
<a name="ln1216">  //   _show_score_2(d, cr, w, h); // TODO: 2nd player</a>
<a name="ln1217">  _show_high_score(d, cr, w, h);</a>
<a name="ln1218">  _show_credit(d, cr, w, h);</a>
<a name="ln1219">  _show_lifes(d, cr, w, h);</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222">// draw the non-interactive part of the game: intro and win/lose screen</a>
<a name="ln1223">static void _expose_intro(dt_knight_t *d, cairo_t *cr, int32_t w, int32_t h)</a>
<a name="ln1224">{</a>
<a name="ln1225">  cairo_set_source_rgb(cr, 1, 1, 1);</a>
<a name="ln1226"> </a>
<a name="ln1227">  _show_top_line(d, cr, w, h);</a>
<a name="ln1228">  _show_high_score(d, cr, w, h);</a>
<a name="ln1229">  _show_credit(d, cr, w, h);</a>
<a name="ln1230"> </a>
<a name="ln1231">  const int wipe_duration = 1.0 * 1000.0 / (float)LOOP_SPEED; // i.e., 1 second</a>
<a name="ln1232"> </a>
<a name="ln1233">  if(d-&gt;game_state == INTRO)</a>
<a name="ln1234">  {</a>
<a name="ln1235">    _show_score_1(d, cr, w, h);</a>
<a name="ln1236">    _show_score_2(d, cr, w, h);</a>
<a name="ln1237"> </a>
<a name="ln1238">    if(d-&gt;animation_loop &gt; 8.5 * 1000.0 / (float)LOOP_SPEED &amp;&amp; d-&gt;player_shot.active)</a>
<a name="ln1239">    {</a>
<a name="ln1240">      d-&gt;game_state = START;</a>
<a name="ln1241">      d-&gt;animation_loop = 0;</a>
<a name="ln1242">    }</a>
<a name="ln1243">    else if(d-&gt;animation_loop &gt; 7.5 * 1000.0 / (float)LOOP_SPEED)</a>
<a name="ln1244">    {</a>
<a name="ln1245">      // wait for player select</a>
<a name="ln1246">      _show_text(cr, d-&gt;letters, &quot;PUSH&quot;, 0.5 * w, 11 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1247">      _show_text(cr, d-&gt;letters, &quot;1 OR 2 PLAYERS BUTTON&quot;, 0.5 * w, 13 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1248">    }</a>
<a name="ln1249">    else if(d-&gt;animation_loop &gt; 1.0 * 1000.0 / (float)LOOP_SPEED)</a>
<a name="ln1250">    {</a>
<a name="ln1251">      d-&gt;player_shot.active = FALSE;</a>
<a name="ln1252">      // 1s - 5s: show welcome text</a>
<a name="ln1253">      _show_text(cr, d-&gt;letters, &quot;THE DARKTABLE TEAM&quot;, 0.5 * w, 6 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1254">      _show_text(cr, d-&gt;letters, &quot;PRESENTS&quot;, 0.5 * w, 8 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1255">      _show_text(cr, d-&gt;letters, &quot;THE GOOD KNIGHT&quot;, 0.5 * w, 10 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1256"> </a>
<a name="ln1257">      // 5s - 5.5s: wipe</a>
<a name="ln1258">      const int wipe_start = 6.0 * 1000.0 / (float)LOOP_SPEED;</a>
<a name="ln1259">      if(d-&gt;animation_loop &gt; wipe_start)</a>
<a name="ln1260">      {</a>
<a name="ln1261">        const float wipe_progress = (float)(d-&gt;animation_loop - wipe_start) / wipe_duration;</a>
<a name="ln1262">        cairo_set_source_rgb(cr, 0, 0, 0);</a>
<a name="ln1263">        cairo_rectangle(cr, 0, 5 * LETTER_HEIGHT * w, wipe_progress * w, 9 * LETTER_HEIGHT * w);</a>
<a name="ln1264">        cairo_fill(cr);</a>
<a name="ln1265">      }</a>
<a name="ln1266">    }</a>
<a name="ln1267">  }</a>
<a name="ln1268">  else if(d-&gt;game_state == START)</a>
<a name="ln1269">  {</a>
<a name="ln1270">    if(d-&gt;animation_loop &gt; 5.0 * 1000.0 / (float)LOOP_SPEED)</a>
<a name="ln1271">    {</a>
<a name="ln1272">      int n_aliens = 0;</a>
<a name="ln1273">      d-&gt;n_aliens = MIN(d-&gt;animation_loop - (5.0 * 1000.0 / (float)LOOP_SPEED), N_ALIENS_X * N_ALIENS_Y);</a>
<a name="ln1274">      for(int y = N_ALIENS_Y - 1; y &gt;= 0; y--)</a>
<a name="ln1275">        for(int x = 0; x &lt; N_ALIENS_X; x++)</a>
<a name="ln1276">        {</a>
<a name="ln1277">          const int i = x + y * N_ALIENS_X;</a>
<a name="ln1278">          d-&gt;aliens[i].alive = n_aliens++ &lt; d-&gt;n_aliens;</a>
<a name="ln1279">        }</a>
<a name="ln1280">      if(d-&gt;n_aliens == N_ALIENS_X * N_ALIENS_Y)</a>
<a name="ln1281">      {</a>
<a name="ln1282">        d-&gt;game_state = GAME;</a>
<a name="ln1283">        d-&gt;player_shot.active = FALSE;</a>
<a name="ln1284">        d-&gt;player_x = 0.0;</a>
<a name="ln1285">        d-&gt;animation_loop = 0;</a>
<a name="ln1286">      }</a>
<a name="ln1287">      _show_score_1(d, cr, w, h);</a>
<a name="ln1288">      _show_aliens(d, cr, w, h);</a>
<a name="ln1289">      _show_bunkers(d, cr, w, h);</a>
<a name="ln1290">      _show_ground(d, cr, w, h);</a>
<a name="ln1291">      _show_lifes(d, cr, w, h);</a>
<a name="ln1292">    }</a>
<a name="ln1293">    else if(d-&gt;animation_loop &gt; 1.5 * 1000.0 / (float)LOOP_SPEED)</a>
<a name="ln1294">    {</a>
<a name="ln1295">      _show_text(cr, d-&gt;letters, &quot;PLAY PLAYER&lt;1&gt;&quot;, 0.5 * w, 13 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1296">      _show_lifes(d, cr, w, h);</a>
<a name="ln1297">      if(d-&gt;animation_loop % (int)(1000.0 / (LOOP_SPEED * 2.) + 0.5) &lt; (1000.0 / (LOOP_SPEED * 4.0)))</a>
<a name="ln1298">        _show_score_1(d, cr, w, h);</a>
<a name="ln1299">    }</a>
<a name="ln1300">    else</a>
<a name="ln1301">    {</a>
<a name="ln1302">      _show_score_1(d, cr, w, h);</a>
<a name="ln1303">      _show_score_2(d, cr, w, h);</a>
<a name="ln1304">      if(d-&gt;animation_loop &lt;= 1.0 * 1000.0 / (float)LOOP_SPEED)</a>
<a name="ln1305">      {</a>
<a name="ln1306">        const float wipe_progress = (float)d-&gt;animation_loop / wipe_duration;</a>
<a name="ln1307"> </a>
<a name="ln1308">        _show_text(cr, d-&gt;letters, &quot;PUSH&quot;, 0.5 * w, 11 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1309">        _show_text(cr, d-&gt;letters, &quot;1 OR 2 PLAYERS BUTTON&quot;, 0.5 * w, 13 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1310"> </a>
<a name="ln1311">        cairo_set_source_rgb(cr, 0, 0, 0);</a>
<a name="ln1312">        cairo_rectangle(cr, 0, 0, wipe_progress * w, h);</a>
<a name="ln1313">        cairo_fill(cr);</a>
<a name="ln1314">      }</a>
<a name="ln1315">    }</a>
<a name="ln1316">  }</a>
<a name="ln1317">  else if(d-&gt;game_state == LOSE)</a>
<a name="ln1318">  {</a>
<a name="ln1319">    _show_score_1(d, cr, w, h);</a>
<a name="ln1320">    _show_lifes(d, cr, w, h);</a>
<a name="ln1321">    cairo_set_source_rgb(cr, 1, 1, 1);</a>
<a name="ln1322">    _show_text(cr, d-&gt;letters, &quot;GAME OVER&quot;, 0.5 * w, 6 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1323">    if(d-&gt;animation_loop &gt; 2.0 * 1000.0 / LOOP_SPEED)</a>
<a name="ln1324">      _show_text(cr, d-&gt;letters, &quot;NOW GET BACK TO WORK&quot;, 0.5 * w, 8 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1325">    const int wipe_start = 5.0 * 1000.0 / (float)LOOP_SPEED;</a>
<a name="ln1326">    if(d-&gt;animation_loop &gt; wipe_start)</a>
<a name="ln1327">    {</a>
<a name="ln1328">      const float wipe_progress = (float)(d-&gt;animation_loop - wipe_start) / wipe_duration;</a>
<a name="ln1329">      cairo_set_source_rgb(cr, 0, 0, 0);</a>
<a name="ln1330">      cairo_rectangle(cr, 0, 0, wipe_progress * w, h);</a>
<a name="ln1331">      cairo_fill(cr);</a>
<a name="ln1332">    }</a>
<a name="ln1333">    if(d-&gt;animation_loop &gt; wipe_start + wipe_duration * 2) dt_ctl_switch_mode_to(&quot;lighttable&quot;);</a>
<a name="ln1334">  }</a>
<a name="ln1335">  else if(d-&gt;game_state == WIN)</a>
<a name="ln1336">  {</a>
<a name="ln1337">    _show_score_1(d, cr, w, h);</a>
<a name="ln1338">    _show_lifes(d, cr, w, h);</a>
<a name="ln1339">    cairo_set_source_rgb(cr, 1, 1, 1);</a>
<a name="ln1340">    _show_text(cr, d-&gt;letters, &quot;WELL DONE EARTHLING&quot;, 0.5 * w, 6 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1341">    if(d-&gt;animation_loop &gt; 1.0 * 1000.0 / LOOP_SPEED)</a>
<a name="ln1342">      _show_text(cr, d-&gt;letters, &quot;THIS TIME YOU WIN&quot;, 0.5 * w, 8 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1343">    if(d-&gt;animation_loop &gt; 4.0 * 1000.0 / LOOP_SPEED)</a>
<a name="ln1344">      _show_text(cr, d-&gt;letters, &quot;NOW GET BACK TO WORK&quot;, 0.5 * w, 11 * LETTER_HEIGHT * w, w, h, 'c');</a>
<a name="ln1345">    const int wipe_start = 7.0 * 1000.0 / (float)LOOP_SPEED;</a>
<a name="ln1346">    if(d-&gt;animation_loop &gt; wipe_start)</a>
<a name="ln1347">    {</a>
<a name="ln1348">      const float wipe_progress = (float)(d-&gt;animation_loop - wipe_start) / wipe_duration;</a>
<a name="ln1349">      cairo_set_source_rgb(cr, 0, 0, 0);</a>
<a name="ln1350">      cairo_rectangle(cr, 0, 0, wipe_progress * w, h);</a>
<a name="ln1351">      cairo_fill(cr);</a>
<a name="ln1352">    }</a>
<a name="ln1353">    if(d-&gt;animation_loop &gt; wipe_start + wipe_duration * 2) dt_ctl_switch_mode_to(&quot;lighttable&quot;);</a>
<a name="ln1354">  }</a>
<a name="ln1355">}</a>
<a name="ln1356"> </a>
<a name="ln1357">void expose(dt_view_t *self, cairo_t *cr, int32_t width, int32_t height, int32_t pointerx, int32_t pointery)</a>
<a name="ln1358">{</a>
<a name="ln1359">  dt_knight_t *d = (dt_knight_t *)self-&gt;data;</a>
<a name="ln1360"> </a>
<a name="ln1361">  // we want a fixed playground aspect ratio</a>
<a name="ln1362">  int w = width, h = height;</a>
<a name="ln1363">  if(width / ASPECT_RATIO &lt; height)</a>
<a name="ln1364">    h = (float)w / ASPECT_RATIO;</a>
<a name="ln1365">  else</a>
<a name="ln1366">    w = (float)h * ASPECT_RATIO;</a>
<a name="ln1367"> </a>
<a name="ln1368">  cairo_save(cr);</a>
<a name="ln1369">  // set 0/0 to the top left of the playground</a>
<a name="ln1370">  cairo_translate(cr, (width - w) / 2, (height - h) / 2);</a>
<a name="ln1371"> </a>
<a name="ln1372">  // prepare sprites</a>
<a name="ln1373">  for(int i = 0; i &lt; 2; i++) _scale_sprite(d-&gt;alien_sprite[i], ALIEN_WIDTH, ALIEN_TARGET_WIDTH * w);</a>
<a name="ln1374">  for(int i = 0; i &lt; 3; i++) _scale_sprite(d-&gt;player_sprite[i], PLAYER_WIDTH, PLAYER_TARGET_WIDTH * w);</a>
<a name="ln1375">  _scale_sprite(d-&gt;mystery_sprite, MYSTERY_SHIP_WIDTH, MYSTERY_SHIP_TARGET_WIDTH * w);</a>
<a name="ln1376">  for(int i = 0; i &lt; EXPLOSION_AMOUNT; i++)</a>
<a name="ln1377">    _scale_sprite(d-&gt;explosion_sprite[i], EXPLOSION_WIDTH, EXPLOSION_TARGET_WIDTH * w);</a>
<a name="ln1378">  for(int i = 0; i &lt; 4; i++) _scale_sprite(d-&gt;bunker_sprite[i], BUNKER_WIDTH, BUNKER_TARGET_WIDTH * w);</a>
<a name="ln1379">  for(int i = 0; i &lt; n_letters; i++) _scale_sprite(d-&gt;letters[i], FONT_WIDTH, LETTER_WIDTH * w);</a>
<a name="ln1380"> </a>
<a name="ln1381">  // clear background</a>
<a name="ln1382">  cairo_set_source_rgb(cr, 0, 0, 0);</a>
<a name="ln1383">  cairo_paint(cr);</a>
<a name="ln1384"> </a>
<a name="ln1385">  switch(d-&gt;game_state)</a>
<a name="ln1386">  {</a>
<a name="ln1387">    case INTRO:</a>
<a name="ln1388">    case START:</a>
<a name="ln1389">    case LOSE:</a>
<a name="ln1390">    case WIN:</a>
<a name="ln1391">      _expose_intro(d, cr, w, h);</a>
<a name="ln1392">      break;</a>
<a name="ln1393">    case GAME:</a>
<a name="ln1394">      _expose_game(d, cr, w, h);</a>
<a name="ln1395">      break;</a>
<a name="ln1396">    default:</a>
<a name="ln1397">      break;</a>
<a name="ln1398">  }</a>
<a name="ln1399"> </a>
<a name="ln1400">  cairo_restore(cr);</a>
<a name="ln1401">}</a>
<a name="ln1402"> </a>
<a name="ln1403">int key_released(dt_view_t *self, guint key, guint state)</a>
<a name="ln1404">{</a>
<a name="ln1405">  dt_knight_t *d = (dt_knight_t *)self-&gt;data;</a>
<a name="ln1406">  switch(key)</a>
<a name="ln1407">  {</a>
<a name="ln1408">    case GDK_KEY_Left:</a>
<a name="ln1409">    case GDK_KEY_Right:</a>
<a name="ln1410">      d-&gt;move = 0;</a>
<a name="ln1411">      return 1;</a>
<a name="ln1412">  }</a>
<a name="ln1413">  return 0;</a>
<a name="ln1414">}</a>
<a name="ln1415"> </a>
<a name="ln1416">int key_pressed(dt_view_t *self, guint key, guint state)</a>
<a name="ln1417">{</a>
<a name="ln1418">  dt_knight_t *d = (dt_knight_t *)self-&gt;data;</a>
<a name="ln1419"> </a>
<a name="ln1420">  switch(key)</a>
<a name="ln1421">  {</a>
<a name="ln1422">    // do movement in the event loop</a>
<a name="ln1423">    case GDK_KEY_Left:</a>
<a name="ln1424">      d-&gt;move = -1;</a>
<a name="ln1425">      return 1;</a>
<a name="ln1426">    case GDK_KEY_Right:</a>
<a name="ln1427">      d-&gt;move = 1;</a>
<a name="ln1428">      return 1;</a>
<a name="ln1429">    case GDK_KEY_space:</a>
<a name="ln1430">      if(!d-&gt;player_shot.active &amp;&amp; !d-&gt;total_freeze)</a>
<a name="ln1431">      {</a>
<a name="ln1432">        d-&gt;player_shot.active = TRUE;</a>
<a name="ln1433">        d-&gt;player_shot.x = d-&gt;player_x + 0.5 * PLAYER_TARGET_WIDTH;</a>
<a name="ln1434">        d-&gt;player_shot.y = d-&gt;player_shot.start = PLAYER_Y;</a>
<a name="ln1435">        d-&gt;player_shot.direction = 1.0;</a>
<a name="ln1436">      }</a>
<a name="ln1437">      return 1;</a>
<a name="ln1438">  }</a>
<a name="ln1439"> </a>
<a name="ln1440">  return 0;</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1444">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1445">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="353"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'buf'. Check lines: 353, 352.</p></div>
<div class="balloon" rel="374"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> Dereferencing of the null pointer 'd' might take place. The potential null pointer is passed into '_reset_board' function. Inspect the first argument. Check lines: 374, 414, 411.</p></div>
<div class="balloon" rel="443"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd->letters'. Check lines: 443, 441.</p></div>
<div class="balloon" rel="520"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'explosion'. Check lines: 520, 519.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
