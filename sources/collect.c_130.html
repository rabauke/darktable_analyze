
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika, henrik andersson.</a>
<a name="ln4">    copyright (c) 2012 Jose Carlos Garcia Sogo</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;libs/collect.h&quot;</a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/film.h&quot;</a>
<a name="ln24">#include &quot;common/metadata.h&quot;</a>
<a name="ln25">#include &quot;common/utility.h&quot;</a>
<a name="ln26">#include &quot;control/conf.h&quot;</a>
<a name="ln27">#include &quot;control/control.h&quot;</a>
<a name="ln28">#include &quot;control/jobs.h&quot;</a>
<a name="ln29">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln30">#include &quot;gui/gtk.h&quot;</a>
<a name="ln31">#include &quot;libs/lib.h&quot;</a>
<a name="ln32">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln33">#include &quot;views/view.h&quot;</a>
<a name="ln34">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln35">#include &quot;osx/osx.h&quot;</a>
<a name="ln36">#endif</a>
<a name="ln37"> </a>
<a name="ln38">DT_MODULE(1)</a>
<a name="ln39"> </a>
<a name="ln40">#define MAX_RULES 10</a>
<a name="ln41"> </a>
<a name="ln42">#define PARAM_STRING_SIZE 256 // FIXME: is this enough !?</a>
<a name="ln43"> </a>
<a name="ln44">typedef struct dt_lib_collect_rule_t</a>
<a name="ln45">{</a>
<a name="ln46">  int num;</a>
<a name="ln47">  GtkWidget *hbox;</a>
<a name="ln48">  GtkComboBox *combo;</a>
<a name="ln49">  GtkWidget *text;</a>
<a name="ln50">  GtkWidget *button;</a>
<a name="ln51">  gboolean typing;</a>
<a name="ln52">} dt_lib_collect_rule_t;</a>
<a name="ln53"> </a>
<a name="ln54">typedef struct dt_lib_collect_t</a>
<a name="ln55">{</a>
<a name="ln56">  dt_lib_collect_rule_t rule[MAX_RULES];</a>
<a name="ln57">  int active_rule;</a>
<a name="ln58">  int nb_rules;</a>
<a name="ln59"> </a>
<a name="ln60">  GtkTreeView *view;</a>
<a name="ln61">  int view_rule;</a>
<a name="ln62"> </a>
<a name="ln63">  GtkTreeModel *treefilter;</a>
<a name="ln64">  GtkTreeModel *listfilter;</a>
<a name="ln65">  GtkScrolledWindow *scrolledwindow;</a>
<a name="ln66"> </a>
<a name="ln67">  GtkScrolledWindow *sw2;</a>
<a name="ln68"> </a>
<a name="ln69">  gboolean singleclick;</a>
<a name="ln70">  struct dt_lib_collect_params_t *params;</a>
<a name="ln71">} dt_lib_collect_t;</a>
<a name="ln72"> </a>
<a name="ln73">typedef struct dt_lib_collect_params_rule_t</a>
<a name="ln74">{</a>
<a name="ln75">  uint32_t item : 16;</a>
<a name="ln76">  uint32_t mode : 16;</a>
<a name="ln77">  char string[PARAM_STRING_SIZE];</a>
<a name="ln78">} dt_lib_collect_params_rule_t;</a>
<a name="ln79"> </a>
<a name="ln80">typedef struct dt_lib_collect_params_t</a>
<a name="ln81">{</a>
<a name="ln82">  uint32_t rules;</a>
<a name="ln83">  dt_lib_collect_params_rule_t rule[MAX_RULES];</a>
<a name="ln84">} dt_lib_collect_params_t;</a>
<a name="ln85"> </a>
<a name="ln86">typedef enum dt_lib_collect_cols_t</a>
<a name="ln87">{</a>
<a name="ln88">  DT_LIB_COLLECT_COL_TEXT = 0,</a>
<a name="ln89">  DT_LIB_COLLECT_COL_ID,</a>
<a name="ln90">  DT_LIB_COLLECT_COL_TOOLTIP,</a>
<a name="ln91">  DT_LIB_COLLECT_COL_PATH,</a>
<a name="ln92">  DT_LIB_COLLECT_COL_VISIBLE,</a>
<a name="ln93">  DT_LIB_COLLECT_COL_UNREACHABLE,</a>
<a name="ln94">  DT_LIB_COLLECT_COL_COUNT,</a>
<a name="ln95">  DT_LIB_COLLECT_NUM_COLS</a>
<a name="ln96">} dt_lib_collect_cols_t;</a>
<a name="ln97"> </a>
<a name="ln98">typedef struct _range_t</a>
<a name="ln99">{</a>
<a name="ln100">  gchar *start;</a>
<a name="ln101">  gchar *stop;</a>
<a name="ln102">  GtkTreePath *path1;</a>
<a name="ln103">  GtkTreePath *path2;</a>
<a name="ln104">} _range_t;</a>
<a name="ln105"> </a>
<a name="ln106">static void _lib_collect_gui_update(dt_lib_module_t *self);</a>
<a name="ln107">static void _lib_folders_update_collection(const gchar *filmroll);</a>
<a name="ln108">static void entry_insert_text(GtkWidget *entry, gchar *new_text, gint new_length, gpointer *position,</a>
<a name="ln109">                          dt_lib_collect_rule_t *d);</a>
<a name="ln110">static void entry_changed(GtkEntry *entry, dt_lib_collect_rule_t *dr);</a>
<a name="ln111">static void collection_updated(gpointer instance, gpointer self);</a>
<a name="ln112">static void row_activated_with_event(GtkTreeView *view, GtkTreePath *path, GtkTreeViewColumn *col, GdkEventButton *event, dt_lib_collect_t *d);</a>
<a name="ln113"> </a>
<a name="ln114">const char *name(dt_lib_module_t *self)</a>
<a name="ln115">{</a>
<a name="ln116">  return _(&quot;collect images&quot;);</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">void init_presets(dt_lib_module_t *self)</a>
<a name="ln120">{</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">/* Update the params struct with active ruleset */</a>
<a name="ln124">static void _lib_collect_update_params(dt_lib_collect_t *d)</a>
<a name="ln125">{</a>
<a name="ln126">  /* reset params */</a>
<a name="ln127">  dt_lib_collect_params_t *p = d-&gt;params;</a>
<a name="ln128">  memset(p, 0, sizeof(dt_lib_collect_params_t));</a>
<a name="ln129"> </a>
<a name="ln130">  /* for each active rule set update params */</a>
<a name="ln131">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;) - 1;</a>
<a name="ln132">  const int active = CLAMP(_a, 0, (MAX_RULES - 1));</a>
<a name="ln133">  char confname[200] = { 0 };</a>
<a name="ln134">  for(int i = 0; i &lt;= active; i++)</a>
<a name="ln135">  {</a>
<a name="ln136">    /* get item */</a>
<a name="ln137">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln138">    p-&gt;rule[i].item = dt_conf_get_int(confname);</a>
<a name="ln139"> </a>
<a name="ln140">    /* get mode */</a>
<a name="ln141">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln142">    p-&gt;rule[i].mode = dt_conf_get_int(confname);</a>
<a name="ln143"> </a>
<a name="ln144">    /* get string */</a>
<a name="ln145">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln146">    gchar *string = dt_conf_get_string(confname);</a>
<a name="ln147">    if(string != NULL)</a>
<a name="ln148">    {</a>
<a name="ln149">      snprintf(p-&gt;rule[i].string, PARAM_STRING_SIZE, &quot;%s&quot;, string);</a>
<a name="ln150">      g_free(string);</a>
<a name="ln151">    }</a>
<a name="ln152"> </a>
<a name="ln153">    // fprintf(stderr,&quot;[%i] %d,%d,%s\n&quot;,i, p-&gt;rule[i].item, p-&gt;rule[i].mode,  p-&gt;rule[i].string);</a>
<a name="ln154">  }</a>
<a name="ln155"> </a>
<a name="ln156">  p-&gt;rules = active + 1;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">void *get_params(dt_lib_module_t *self, int *size)</a>
<a name="ln160">{</a>
<a name="ln161">  _lib_collect_update_params(self-&gt;data);</a>
<a name="ln162"> </a>
<a name="ln163">  /* allocate a copy of params to return, freed by caller */</a>
<a name="ln164">  *size = sizeof(dt_lib_collect_params_t);</a>
<a name="ln165">  void *p = malloc(*size);</a>
<a name="ln166">  memcpy(p, ((dt_lib_collect_t *)self-&gt;data)-&gt;params, *size);</a>
<a name="ln167">  return p;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">int set_params(dt_lib_module_t *self, const void *params, int size)</a>
<a name="ln171">{</a>
<a name="ln172">  /* update conf settings from params */</a>
<a name="ln173">  dt_lib_collect_params_t *p = (dt_lib_collect_params_t *)params;</a>
<a name="ln174">  char confname[200] = { 0 };</a>
<a name="ln175"> </a>
<a name="ln176">  for(uint32_t i = 0; i &lt; p-&gt;rules; i++)</a>
<a name="ln177">  {</a>
<a name="ln178">    /* set item */</a>
<a name="ln179">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln180">    dt_conf_set_int(confname, p-&gt;rule[i].item);</a>
<a name="ln181"> </a>
<a name="ln182">    /* set mode */</a>
<a name="ln183">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln184">    dt_conf_set_int(confname, p-&gt;rule[i].mode);</a>
<a name="ln185"> </a>
<a name="ln186">    /* set string */</a>
<a name="ln187">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln188">    dt_conf_set_string(confname, p-&gt;rule[i].string);</a>
<a name="ln189">  }</a>
<a name="ln190"> </a>
<a name="ln191">  /* set number of rules */</a>
<a name="ln192">  g_strlcpy(confname, &quot;plugins/lighttable/collect/num_rules&quot;, sizeof(confname));</a>
<a name="ln193">  dt_conf_set_int(confname, p-&gt;rules);</a>
<a name="ln194"> </a>
<a name="ln195">  /* update internal params */</a>
<a name="ln196">  _lib_collect_update_params(self-&gt;data);</a>
<a name="ln197"> </a>
<a name="ln198">  /* update ui */</a>
<a name="ln199">  _lib_collect_gui_update(self);</a>
<a name="ln200"> </a>
<a name="ln201">  /* update view */</a>
<a name="ln202">  dt_collection_update_query(darktable.collection);</a>
<a name="ln203"> </a>
<a name="ln204">  return 0;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207"> </a>
<a name="ln208">const char **views(dt_lib_module_t *self)</a>
<a name="ln209">{</a>
<a name="ln210">  static const char *v[] = {&quot;lighttable&quot;, &quot;map&quot;, &quot;print&quot;, NULL};</a>
<a name="ln211">  return v;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln215">{</a>
<a name="ln216">  return DT_UI_CONTAINER_PANEL_LEFT_CENTER;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">static void view_popup_menu_onSearchFilmroll(GtkWidget *menuitem, gpointer userdata)</a>
<a name="ln220">{</a>
<a name="ln221">  GtkTreeView *treeview = GTK_TREE_VIEW(userdata);</a>
<a name="ln222">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln223">  GtkWidget *filechooser;</a>
<a name="ln224"> </a>
<a name="ln225">  GtkTreeSelection *selection;</a>
<a name="ln226">  GtkTreeIter iter, child;</a>
<a name="ln227">  GtkTreeModel *model;</a>
<a name="ln228"> </a>
<a name="ln229">  gchar *tree_path = NULL;</a>
<a name="ln230">  gchar *new_path = NULL;</a>
<a name="ln231"> </a>
<a name="ln232">  model = gtk_tree_view_get_model(treeview);</a>
<a name="ln233">  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln234">  if (!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln235">    return;</a>
<a name="ln236"> </a>
<a name="ln237">  child = iter;</a>
<a name="ln238">  gtk_tree_model_iter_parent(model, &amp;iter, &amp;child);</a>
<a name="ln239">  gtk_tree_model_get(model, &amp;child, DT_LIB_COLLECT_COL_PATH, &amp;tree_path, -1);</a>
<a name="ln240"> </a>
<a name="ln241">  filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln242">    _(&quot;search filmroll&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln243">    GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln244">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln245">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln246">#endif</a>
<a name="ln247"> </a>
<a name="ln248">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln249">  if(tree_path != NULL)</a>
<a name="ln250">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(filechooser), tree_path);</a>
<a name="ln251">  else</a>
<a name="ln252">    goto error;</a>
<a name="ln253"> </a>
<a name="ln254">  // run the dialog</a>
<a name="ln255">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln256">  {</a>
<a name="ln257">    gint id = -1;</a>
<a name="ln258">    sqlite3_stmt *stmt;</a>
<a name="ln259">    gchar *query = NULL;</a>
<a name="ln260"> </a>
<a name="ln261">    gchar *uri = NULL;</a>
<a name="ln262">    uri = gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln263">    new_path = g_filename_from_uri(uri, NULL, NULL);</a>
<a name="ln264">    g_free(uri);</a>
<a name="ln265">    if(new_path)</a>
<a name="ln266">    {</a>
<a name="ln267">      gchar *old = NULL;</a>
<a name="ln268">      query = dt_util_dstrcat(query, &quot;SELECT id, folder FROM main.film_rolls WHERE folder LIKE '%s%%'&quot;, tree_path);</a>
<a name="ln269">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln270">      g_free(query);</a>
<a name="ln271">      query = NULL;</a>
<a name="ln272"> </a>
<a name="ln273">      while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln274">      {</a>
<a name="ln275">        id = sqlite3_column_int(stmt, 0);</a>
<a name="ln276">        old = (gchar *)sqlite3_column_text(stmt, 1);</a>
<a name="ln277"> </a>
<a name="ln278">        query = NULL;</a>
<a name="ln279">        query = dt_util_dstrcat(query, &quot;UPDATE main.film_rolls SET folder=?1 WHERE id=?2&quot;);</a>
<a name="ln280"> </a>
<a name="ln281">        gchar trailing[1024] = { 0 };</a>
<a name="ln282">        gchar final[1024] = { 0 };</a>
<a name="ln283"> </a>
<a name="ln284">        if(g_strcmp0(old, tree_path))</a>
<a name="ln285">        {</a>
<a name="ln286">          g_snprintf(trailing, sizeof(trailing), &quot;%s&quot;, old + strlen(tree_path) + 1);</a>
<a name="ln287">          g_snprintf(final, sizeof(final), &quot;%s/%s&quot;, new_path, trailing);</a>
<a name="ln288">        }</a>
<a name="ln289">        else</a>
<a name="ln290">        {</a>
<a name="ln291">          g_snprintf(final, sizeof(final), &quot;%s&quot;, new_path);</a>
<a name="ln292">        }</a>
<a name="ln293"> </a>
<a name="ln294">        sqlite3_stmt *stmt2;</a>
<a name="ln295">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt2, NULL);</a>
<a name="ln296">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt2, 1, final, -1, SQLITE_STATIC);</a>
<a name="ln297">        DT_DEBUG_SQLITE3_BIND_INT(stmt2, 2, id);</a>
<a name="ln298">        sqlite3_step(stmt2);</a>
<a name="ln299">        sqlite3_finalize(stmt2);</a>
<a name="ln300">      }</a>
<a name="ln301">      sqlite3_finalize(stmt);</a>
<a name="ln302">      g_free(query);</a>
<a name="ln303"> </a>
<a name="ln304">      /* reset filter so that view isn't empty */</a>
<a name="ln305">      dt_view_filter_reset(darktable.view_manager, FALSE);</a>
<a name="ln306"> </a>
<a name="ln307">      /* update collection to view missing filmroll */</a>
<a name="ln308">      _lib_folders_update_collection(new_path);</a>
<a name="ln309"> </a>
<a name="ln310">      dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln311">    }</a>
<a name="ln312">    else</a>
<a name="ln313">      goto error;</a>
<a name="ln314">  }</a>
<a name="ln315">  g_free(tree_path);</a>
<a name="ln316">  g_free(new_path);</a>
<a name="ln317">  gtk_widget_destroy(filechooser);</a>
<a name="ln318">  return;</a>
<a name="ln319"> </a>
<a name="ln320">error:</a>
<a name="ln321">  /* Something wrong happened */</a>
<a name="ln322">  gtk_widget_destroy(filechooser);</a>
<a name="ln323">  dt_control_log(_(&quot;problem selecting new path for the filmroll in %s&quot;), tree_path);</a>
<a name="ln324"> </a>
<a name="ln325">  g_free(tree_path);</a>
<a name="ln326">  g_free(new_path);</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">static void view_popup_menu_onRemove(GtkWidget *menuitem, gpointer userdata)</a>
<a name="ln330">{</a>
<a name="ln331">  GtkTreeView *treeview = GTK_TREE_VIEW(userdata);</a>
<a name="ln332"> </a>
<a name="ln333">  GtkTreeSelection *selection;</a>
<a name="ln334">  GtkTreeIter iter, model_iter;</a>
<a name="ln335">  GtkTreeModel *model;</a>
<a name="ln336"> </a>
<a name="ln337">  gchar *filmroll_path = NULL;</a>
<a name="ln338">  gchar *fullq = NULL;</a>
<a name="ln339"> </a>
<a name="ln340">  /* Get info about the filmroll (or parent) selected */</a>
<a name="ln341">  model = gtk_tree_view_get_model(treeview);</a>
<a name="ln342">  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln343">  if (gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln344">  {</a>
<a name="ln345">    gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;filmroll_path, -1);</a>
<a name="ln346"> </a>
<a name="ln347">    /* Clean selected images, and add to the table those which are going to be deleted */</a>
<a name="ln348">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images&quot;, NULL, NULL, NULL);</a>
<a name="ln349"> </a>
<a name="ln350">    fullq = dt_util_dstrcat(fullq, &quot;INSERT INTO main.selected_images SELECT id FROM main.images WHERE film_id IN &quot;</a>
<a name="ln351">                                   &quot;(SELECT id FROM main.film_rolls WHERE folder LIKE '%s%%')&quot;,</a>
<a name="ln352">                            filmroll_path);</a>
<a name="ln353">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), fullq, NULL, NULL, NULL);</a>
<a name="ln354"> </a>
<a name="ln355">    if (dt_control_remove_images())</a>
<a name="ln356">    {</a>
<a name="ln357">      gtk_tree_model_filter_convert_iter_to_child_iter(GTK_TREE_MODEL_FILTER(model), &amp;model_iter, &amp;iter);</a>
<a name="ln358">      gtk_tree_store_remove(GTK_TREE_STORE(gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model))),</a>
<a name="ln359">                            &amp;model_iter);</a>
<a name="ln360">    }</a>
<a name="ln361"> </a>
<a name="ln362">    g_free(fullq);</a>
<a name="ln363">  }</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">static void view_popup_menu(GtkWidget *treeview, GdkEventButton *event, dt_lib_collect_t *d)</a>
<a name="ln367">{</a>
<a name="ln368">  GtkWidget *menu, *menuitem;</a>
<a name="ln369"> </a>
<a name="ln370">  menu = gtk_menu_new();</a>
<a name="ln371"> </a>
<a name="ln372">  menuitem = gtk_menu_item_new_with_label(_(&quot;search filmroll...&quot;));</a>
<a name="ln373">  g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)view_popup_menu_onSearchFilmroll, treeview);</a>
<a name="ln374">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln375"> </a>
<a name="ln376">  menuitem = gtk_menu_item_new_with_label(_(&quot;remove...&quot;));</a>
<a name="ln377">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln378">  g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)view_popup_menu_onRemove, treeview);</a>
<a name="ln379"> </a>
<a name="ln380">  gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln381"> </a>
<a name="ln382">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln383">  gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln384">#else</a>
<a name="ln385">  /* Note: event can be NULL here when called from view_onPopupMenu;</a>
<a name="ln386">   *  gdk_event_get_time() accepts a NULL argument */</a>
<a name="ln387">  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, (event != NULL) ? event-&gt;button : 0,</a>
<a name="ln388">                 gdk_event_get_time((GdkEvent *)event));</a>
<a name="ln389">#endif</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">static gboolean view_onButtonPressed(GtkWidget *treeview, GdkEventButton *event, dt_lib_collect_t *d)</a>
<a name="ln393">{</a>
<a name="ln394">  if((d-&gt;view_rule == DT_COLLECTION_PROP_FOLDERS &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3)</a>
<a name="ln395">     || (!d-&gt;singleclick &amp;&amp; event-&gt;type == GDK_2BUTTON_PRESS &amp;&amp; event-&gt;button == 1)</a>
<a name="ln396">     || (d-&gt;singleclick &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 1))</a>
<a name="ln397">  {</a>
<a name="ln398">    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln399">    GtkTreePath *path = NULL;</a>
<a name="ln400"> </a>
<a name="ln401">    /* Get tree path for row that was clicked */</a>
<a name="ln402">    if(gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(treeview), (gint)event-&gt;x, (gint)event-&gt;y, &amp;path, NULL, NULL,</a>
<a name="ln403">                                     NULL))</a>
<a name="ln404">    {</a>
<a name="ln405">      if(d-&gt;singleclick &amp;&amp; (event-&gt;state &amp; GDK_SHIFT_MASK) &amp;&amp; gtk_tree_selection_count_selected_rows(selection) &gt; 0</a>
<a name="ln406">         &amp;&amp; (d-&gt;view_rule == DT_COLLECTION_PROP_DAY || d-&gt;view_rule == DT_COLLECTION_PROP_TIME</a>
<a name="ln407">             || d-&gt;view_rule == DT_COLLECTION_PROP_APERTURE || d-&gt;view_rule == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln408">             || d-&gt;view_rule == DT_COLLECTION_PROP_ISO || d-&gt;view_rule == DT_COLLECTION_PROP_EXPOSURE</a>
<a name="ln409">             || d-&gt;view_rule == DT_COLLECTION_PROP_ASPECT_RATIO))</a>
<a name="ln410">      {</a>
<a name="ln411">        // range selection</a>
<a name="ln412">        GList *sels = gtk_tree_selection_get_selected_rows(selection, NULL);</a>
<a name="ln413">        GtkTreePath *path2 = (GtkTreePath *)g_list_nth_data(sels, 0);</a>
<a name="ln414">        gtk_tree_selection_unselect_all(selection);</a>
<a name="ln415">        if(gtk_tree_path_compare(path, path2) &gt; 0)</a>
<a name="ln416">          gtk_tree_selection_select_range(selection, path, path2);</a>
<a name="ln417">        else</a>
<a name="ln418">          gtk_tree_selection_select_range(selection, path2, path);</a>
<a name="ln419">      }</a>
<a name="ln420">      else</a>
<a name="ln421">      {</a>
<a name="ln422">        gtk_tree_selection_unselect_all(selection);</a>
<a name="ln423">        gtk_tree_selection_select_path(selection, path);</a>
<a name="ln424">      }</a>
<a name="ln425">    }</a>
<a name="ln426"> </a>
<a name="ln427">    /* single click on folder with the right mouse button? */</a>
<a name="ln428">    if(d-&gt;view_rule == DT_COLLECTION_PROP_FOLDERS &amp;&amp; (event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3))</a>
<a name="ln429">      view_popup_menu(treeview, event, d);</a>
<a name="ln430">    else</a>
<a name="ln431">      row_activated_with_event(GTK_TREE_VIEW(treeview), path, NULL, event, d);</a>
<a name="ln432"> </a>
<a name="ln433">    gtk_tree_path_free(path);</a>
<a name="ln434"> </a>
<a name="ln435">    if((d-&gt;view_rule == DT_COLLECTION_PROP_DAY || d-&gt;view_rule == DT_COLLECTION_PROP_TIME</a>
<a name="ln436">        || d-&gt;view_rule == DT_COLLECTION_PROP_FOLDERS || d-&gt;view_rule == DT_COLLECTION_PROP_TAG)</a>
<a name="ln437">       &amp;&amp; !(event-&gt;state &amp; GDK_SHIFT_MASK))</a>
<a name="ln438">      return FALSE; /* we allow propagation (expand/collapse row) */</a>
<a name="ln439">    else</a>
<a name="ln440">      return TRUE; /* we stop propagation */</a>
<a name="ln441">  }</a>
<a name="ln442">  return FALSE; /* we did not handle this */</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">static gboolean view_onPopupMenu(GtkWidget *treeview, dt_lib_collect_t *d)</a>
<a name="ln446">{</a>
<a name="ln447">  if(d-&gt;view_rule != DT_COLLECTION_PROP_FOLDERS) return FALSE;</a>
<a name="ln448"> </a>
<a name="ln449">  view_popup_menu(treeview, NULL, d);</a>
<a name="ln450"> </a>
<a name="ln451">  return TRUE; /* we handled this */</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">static dt_lib_collect_t *get_collect(dt_lib_collect_rule_t *r)</a>
<a name="ln455">{</a>
<a name="ln456">  dt_lib_collect_t *d = (dt_lib_collect_t *)(((char *)r) - r-&gt;num * sizeof(dt_lib_collect_rule_t));</a>
<a name="ln457">  return d;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">static gboolean list_select(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln461">{</a>
<a name="ln462">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln463">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln464">  gchar *str = NULL;</a>
<a name="ln465"> </a>
<a name="ln466">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, -1);</a>
<a name="ln467"> </a>
<a name="ln468">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln469">  gchar *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln470"> </a>
<a name="ln471">  if(strcmp(haystack, needle) == 0)</a>
<a name="ln472">  {</a>
<a name="ln473">    gtk_tree_selection_select_path(gtk_tree_view_get_selection(d-&gt;view), path);</a>
<a name="ln474">    gtk_tree_view_scroll_to_cell(d-&gt;view, path, NULL, FALSE, 0.2, 0);</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  g_free(haystack);</a>
<a name="ln478">  g_free(needle);</a>
<a name="ln479">  g_free(str);</a>
<a name="ln480"> </a>
<a name="ln481">  return FALSE;</a>
<a name="ln482">}</a>
<a name="ln483">static gboolean range_select(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln484">{</a>
<a name="ln485">  _range_t *range = (_range_t *)data;</a>
<a name="ln486">  gchar *str = NULL;</a>
<a name="ln487"> </a>
<a name="ln488">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, -1);</a>
<a name="ln489"> </a>
<a name="ln490">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln491">  gchar *needle;</a>
<a name="ln492">  if(range-&gt;path1)</a>
<a name="ln493">    needle = g_utf8_strdown(range-&gt;stop, -1);</a>
<a name="ln494">  else</a>
<a name="ln495">    needle = g_utf8_strdown(range-&gt;start, -1);</a>
<a name="ln496"> </a>
<a name="ln497">  if(strcmp(haystack, needle) == 0)</a>
<a name="ln498">  {</a>
<a name="ln499">    if(range-&gt;path1)</a>
<a name="ln500">    {</a>
<a name="ln501">      range-&gt;path2 = gtk_tree_path_copy(path);</a>
<a name="ln502">      return TRUE;</a>
<a name="ln503">    }</a>
<a name="ln504">    else</a>
<a name="ln505">      range-&gt;path1 = gtk_tree_path_copy(path);</a>
<a name="ln506">  }</a>
<a name="ln507"> </a>
<a name="ln508">  g_free(haystack);</a>
<a name="ln509">  g_free(needle);</a>
<a name="ln510">  g_free(str);</a>
<a name="ln511"> </a>
<a name="ln512">  return FALSE;</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">static gboolean tree_expand(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln516">{</a>
<a name="ln517">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln518">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln519">  gchar *str = NULL;</a>
<a name="ln520">  gchar *txt = NULL;</a>
<a name="ln521">  gboolean startwildcard = FALSE;</a>
<a name="ln522"> </a>
<a name="ln523">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, DT_LIB_COLLECT_COL_TEXT, &amp;txt, -1);</a>
<a name="ln524"> </a>
<a name="ln525">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln526">  gchar *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln527">  gchar *txt2 = g_utf8_strdown(txt, -1);</a>
<a name="ln528"> </a>
<a name="ln529">  if(g_str_has_prefix(needle, &quot;%&quot;)) startwildcard = TRUE;</a>
<a name="ln530">  if(g_str_has_suffix(needle, &quot;%&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln531">  if(g_str_has_suffix(haystack, &quot;%&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln532">  if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_TAG)</a>
<a name="ln533">  {</a>
<a name="ln534">    if(g_str_has_suffix(needle, &quot;|&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln535">    if(g_str_has_suffix(haystack, &quot;|&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln536">  }</a>
<a name="ln537">  else if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_FOLDERS)</a>
<a name="ln538">  {</a>
<a name="ln539">    if(g_str_has_suffix(needle, &quot;/&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln540">    if(g_str_has_suffix(haystack, &quot;/&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln541">  }</a>
<a name="ln542">  else if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_DAY</a>
<a name="ln543">          || gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_TIME)</a>
<a name="ln544">  {</a>
<a name="ln545">    if(g_str_has_suffix(needle, &quot;:&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln546">    if(g_str_has_suffix(haystack, &quot;:&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln547">  }</a>
<a name="ln548"> </a>
<a name="ln549">  if(dr-&gt;typing &amp;&amp; g_strrstr(txt2, needle) != NULL)</a>
<a name="ln550">  {</a>
<a name="ln551">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln552">  }</a>
<a name="ln553"> </a>
<a name="ln554">  if(strlen(needle)==0)</a>
<a name="ln555">  {</a>
<a name="ln556">    //nothing to do, we keep the tree collapsed</a>
<a name="ln557">  }</a>
<a name="ln558">  else if(strcmp(haystack, needle) == 0)</a>
<a name="ln559">  {</a>
<a name="ln560">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln561">    gtk_tree_selection_select_path(gtk_tree_view_get_selection(d-&gt;view), path);</a>
<a name="ln562">    gtk_tree_view_scroll_to_cell(d-&gt;view, path, NULL, FALSE, 0.2, 0);</a>
<a name="ln563">  }</a>
<a name="ln564">  else if(startwildcard &amp;&amp; g_strrstr(haystack, needle+1) != NULL)</a>
<a name="ln565">  {</a>
<a name="ln566">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln567">  }</a>
<a name="ln568">  else if(g_str_has_prefix(haystack, needle))</a>
<a name="ln569">  {</a>
<a name="ln570">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  g_free(haystack);</a>
<a name="ln574">  g_free(needle);</a>
<a name="ln575">  g_free(txt2);</a>
<a name="ln576">  g_free(str);</a>
<a name="ln577">  g_free(txt);</a>
<a name="ln578"> </a>
<a name="ln579">  return FALSE;</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">static gboolean list_match_string(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln583">{</a>
<a name="ln584">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln585">  gchar *str = NULL;</a>
<a name="ln586">  gboolean visible;</a>
<a name="ln587"> </a>
<a name="ln588">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, -1);</a>
<a name="ln589"> </a>
<a name="ln590">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln591">  gchar *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln592">  if(g_str_has_suffix(needle, &quot;%&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln593"> </a>
<a name="ln594">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln595">  if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln596">     || property == DT_COLLECTION_PROP_ISO)</a>
<a name="ln597">  {</a>
<a name="ln598">    // handle of numeric value, which can have some operator before the text</a>
<a name="ln599">    visible = TRUE;</a>
<a name="ln600">    gchar *operator, *number, *number2;</a>
<a name="ln601">    dt_collection_split_operator_number(needle, &amp;number, &amp;number2, &amp;operator);</a>
<a name="ln602">    if(number)</a>
<a name="ln603">    {</a>
<a name="ln604">      float nb1 = g_strtod(number, NULL);</a>
<a name="ln605">      float nb2 = g_strtod(haystack, NULL);</a>
<a name="ln606">      if(operator&amp;&amp; strcmp(operator, &quot;&gt;&quot;) == 0)</a>
<a name="ln607">      {</a>
<a name="ln608">        visible = (nb2 &gt; nb1);</a>
<a name="ln609">      }</a>
<a name="ln610">      else if(operator&amp;&amp; strcmp(operator, &quot;&gt;=&quot;) == 0)</a>
<a name="ln611">      {</a>
<a name="ln612">        visible = (nb2 &gt;= nb1);</a>
<a name="ln613">      }</a>
<a name="ln614">      else if(operator&amp;&amp; strcmp(operator, &quot;&lt;&quot;) == 0)</a>
<a name="ln615">      {</a>
<a name="ln616">        visible = (nb2 &lt; nb1);</a>
<a name="ln617">      }</a>
<a name="ln618">      else if(operator&amp;&amp; strcmp(operator, &quot;&lt;=&quot;) == 0)</a>
<a name="ln619">      {</a>
<a name="ln620">        visible = (nb2 &lt;= nb1);</a>
<a name="ln621">      }</a>
<a name="ln622">      else if(operator&amp;&amp; strcmp(operator, &quot;&lt;&gt;&quot;) == 0)</a>
<a name="ln623">      {</a>
<a name="ln624">        visible = (nb1 != nb2);</a>
<a name="ln625">      }</a>
<a name="ln626">      else if(operator&amp;&amp; number2 &amp;&amp; strcmp(operator, &quot;[]&quot;) == 0)</a>
<a name="ln627">      {</a>
<a name="ln628">        float nb3 = g_strtod(number2, NULL);</a>
<a name="ln629">        visible = (nb2 &gt;= nb1 &amp;&amp; nb2 &lt;= nb3);</a>
<a name="ln630">      }</a>
<a name="ln631">      else</a>
<a name="ln632">      {</a>
<a name="ln633">        visible = (nb1 == nb2);</a>
<a name="ln634">      }</a>
<a name="ln635">    }</a>
<a name="ln636">    g_free(operator);</a>
<a name="ln637">    g_free(number);</a>
<a name="ln638">    g_free(number2);</a>
<a name="ln639">  }</a>
<a name="ln640">  else</a>
<a name="ln641">  {</a>
<a name="ln642">    if(g_str_has_prefix(needle, &quot;%&quot;))</a>
<a name="ln643">      visible = (g_strrstr(haystack, needle + 1) != NULL);</a>
<a name="ln644">    else</a>
<a name="ln645">      visible = (g_strrstr(haystack, needle) != NULL);</a>
<a name="ln646">  }</a>
<a name="ln647"> </a>
<a name="ln648">  g_free(haystack);</a>
<a name="ln649">  g_free(needle);</a>
<a name="ln650"> </a>
<a name="ln651">  g_free(str);</a>
<a name="ln652"> </a>
<a name="ln653">  gtk_list_store_set(GTK_LIST_STORE(model), iter, DT_LIB_COLLECT_COL_VISIBLE, visible, -1);</a>
<a name="ln654">  return FALSE;</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">static gboolean tree_match_string(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln658">{</a>
<a name="ln659">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln660">  gchar *str = NULL;</a>
<a name="ln661">  gboolean cur_state, visible;</a>
<a name="ln662"> </a>
<a name="ln663">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, DT_LIB_COLLECT_COL_VISIBLE, &amp;cur_state, -1);</a>
<a name="ln664"> </a>
<a name="ln665">  if(dr-&gt;typing == FALSE &amp;&amp; !cur_state)</a>
<a name="ln666">  {</a>
<a name="ln667">    visible = TRUE;</a>
<a name="ln668">  }</a>
<a name="ln669">  else</a>
<a name="ln670">  {</a>
<a name="ln671">    gchar *haystack = g_utf8_strdown(str, -1),</a>
<a name="ln672">          *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln673">    visible = (g_strrstr(haystack, needle) != NULL);</a>
<a name="ln674">    g_free(haystack);</a>
<a name="ln675">    g_free(needle);</a>
<a name="ln676">  }</a>
<a name="ln677"> </a>
<a name="ln678">  g_free(str);</a>
<a name="ln679"> </a>
<a name="ln680">  gtk_tree_store_set(GTK_TREE_STORE(model), iter, DT_LIB_COLLECT_COL_VISIBLE, visible, -1);</a>
<a name="ln681">  return FALSE;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">static gboolean tree_reveal_func(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln685">{</a>
<a name="ln686">  gboolean state;</a>
<a name="ln687">  GtkTreeIter parent, child = *iter;</a>
<a name="ln688"> </a>
<a name="ln689">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_VISIBLE, &amp;state, -1);</a>
<a name="ln690">  if(!state) return FALSE;</a>
<a name="ln691"> </a>
<a name="ln692">  while(gtk_tree_model_iter_parent(model, &amp;parent, &amp;child))</a>
<a name="ln693">  {</a>
<a name="ln694">    gtk_tree_model_get(model, &amp;parent, DT_LIB_COLLECT_COL_VISIBLE, &amp;state, -1);</a>
<a name="ln695">    gtk_tree_store_set(GTK_TREE_STORE(model), &amp;parent, DT_LIB_COLLECT_COL_VISIBLE, TRUE, -1);</a>
<a name="ln696">    child = parent;</a>
<a name="ln697">  }</a>
<a name="ln698"> </a>
<a name="ln699">  return FALSE;</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">static void tree_set_visibility(GtkTreeModel *model, gpointer data)</a>
<a name="ln703">{</a>
<a name="ln704">  gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)tree_match_string, data);</a>
<a name="ln705"> </a>
<a name="ln706">  gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)tree_reveal_func, NULL);</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">static void _lib_folders_update_collection(const gchar *filmroll)</a>
<a name="ln710">{</a>
<a name="ln711"> </a>
<a name="ln712">  gchar *complete_query = NULL;</a>
<a name="ln713"> </a>
<a name="ln714">  // remove from selected images where not in this query.</a>
<a name="ln715">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln716">  const gchar *cquery = dt_collection_get_query(darktable.collection);</a>
<a name="ln717">  // complete_query = NULL;</a>
<a name="ln718">  if(cquery &amp;&amp; cquery[0] != '\0')</a>
<a name="ln719">  {</a>
<a name="ln720">    complete_query</a>
<a name="ln721">        = dt_util_dstrcat(complete_query, &quot;DELETE FROM main.selected_images WHERE imgid NOT IN (%s)&quot;, cquery);</a>
<a name="ln722">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), complete_query, -1, &amp;stmt, NULL);</a>
<a name="ln723">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, 0);</a>
<a name="ln724">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, -1);</a>
<a name="ln725">    sqlite3_step(stmt);</a>
<a name="ln726">    sqlite3_finalize(stmt);</a>
<a name="ln727"> </a>
<a name="ln728">    /* free allocated strings */</a>
<a name="ln729">    g_free(complete_query);</a>
<a name="ln730">  }</a>
<a name="ln731"> </a>
<a name="ln732">  /* raise signal of collection change, only if this is an original */</a>
<a name="ln733">  if(!darktable.collection-&gt;clone) dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">static void set_properties(dt_lib_collect_rule_t *dr)</a>
<a name="ln737">{</a>
<a name="ln738">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln739">  const gchar *text = gtk_entry_get_text(GTK_ENTRY(dr-&gt;text));</a>
<a name="ln740"> </a>
<a name="ln741">  char confname[200] = { 0 };</a>
<a name="ln742">  snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, dr-&gt;num);</a>
<a name="ln743">  dt_conf_set_string(confname, text);</a>
<a name="ln744">  snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, dr-&gt;num);</a>
<a name="ln745">  dt_conf_set_int(confname, property);</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">static GtkTreeModel *_create_filtered_model(GtkTreeModel *model, dt_lib_collect_rule_t *dr)</a>
<a name="ln749">{</a>
<a name="ln750">  GtkTreeModel *filter = NULL;</a>
<a name="ln751">  GtkTreePath *path = NULL;</a>
<a name="ln752"> </a>
<a name="ln753">  if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_FOLDERS)</a>
<a name="ln754">  {</a>
<a name="ln755">    // we search a common path to all the folders</a>
<a name="ln756">    // we'll use it as root</a>
<a name="ln757">    GtkTreeIter child, iter;</a>
<a name="ln758">    int level = 0;</a>
<a name="ln759"> </a>
<a name="ln760">    while(gtk_tree_model_iter_n_children(model, level &gt; 0 ? &amp;iter : NULL) &gt; 0)</a>
<a name="ln761">    {</a>
<a name="ln762">      if(level &gt; 0)</a>
<a name="ln763">      {</a>
<a name="ln764">        sqlite3_stmt *stmt = NULL;</a>
<a name="ln765">        gchar *pth = NULL;</a>
<a name="ln766">        int id = -1;</a>
<a name="ln767">        // Check if this path also matches a filmroll</a>
<a name="ln768">        gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;pth, -1);</a>
<a name="ln769">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln770">                                    &quot;SELECT id FROM main.film_rolls WHERE folder LIKE ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln771">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, pth, -1, SQLITE_TRANSIENT);</a>
<a name="ln772">        if(sqlite3_step(stmt) == SQLITE_ROW) id = sqlite3_column_int(stmt, 0);</a>
<a name="ln773">        sqlite3_finalize(stmt);</a>
<a name="ln774"> </a>
<a name="ln775">        g_free(pth);</a>
<a name="ln776"> </a>
<a name="ln777">        if(id != -1)</a>
<a name="ln778">        {</a>
<a name="ln779">          // we go back to the parent, in order to show this folder</a>
<a name="ln780">          if(!gtk_tree_model_iter_parent(model, &amp;child, &amp;iter)) level = 0;</a>
<a name="ln781">          iter = child;</a>
<a name="ln782">          break;</a>
<a name="ln783">        }</a>
<a name="ln784">      }</a>
<a name="ln785">      if(gtk_tree_model_iter_n_children(model, level &gt; 0 ? &amp;iter : NULL) != 1) break;</a>
<a name="ln786"> </a>
<a name="ln787">      gtk_tree_model_iter_children(model, &amp;child, level &gt; 0 ? &amp;iter : NULL);</a>
<a name="ln788">      iter = child;</a>
<a name="ln789">      level++;</a>
<a name="ln790">    }</a>
<a name="ln791"> </a>
<a name="ln792">    if(level &gt; 0)</a>
<a name="ln793">    {</a>
<a name="ln794">      if(level &gt; 0 &amp;&amp;</a>
<a name="ln795">         gtk_tree_model_iter_n_children(model, &amp;iter) == 0 &amp;&amp;</a>
<a name="ln796">         gtk_tree_model_iter_parent(model, &amp;child, &amp;iter))</a>
<a name="ln797">      {</a>
<a name="ln798">        path = gtk_tree_model_get_path(model, &amp;child);</a>
<a name="ln799">      }</a>
<a name="ln800">      else</a>
<a name="ln801">      {</a>
<a name="ln802">        path = gtk_tree_model_get_path(model, &amp;iter);</a>
<a name="ln803">      }</a>
<a name="ln804">    }</a>
<a name="ln805">  }</a>
<a name="ln806"> </a>
<a name="ln807">  // Create filter and set virtual root</a>
<a name="ln808">  filter = gtk_tree_model_filter_new(model, path);</a>
<a name="ln809">  gtk_tree_path_free(path);</a>
<a name="ln810"> </a>
<a name="ln811">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(filter), DT_LIB_COLLECT_COL_VISIBLE);</a>
<a name="ln812"> </a>
<a name="ln813">  return filter;</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">static int string_array_length(char **list)</a>
<a name="ln817">{</a>
<a name="ln818">  int length = 0;</a>
<a name="ln819">  for(; *list; list++) length++;</a>
<a name="ln820">  return length;</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">// returns a NULL terminated array of path components</a>
<a name="ln824">static char **split_path(const char *path)</a>
<a name="ln825">{</a>
<a name="ln826">  if(!path || !*path) return NULL;</a>
<a name="ln827"> </a>
<a name="ln828">  char **result;</a>
<a name="ln829">  char **tokens = g_strsplit(path, G_DIR_SEPARATOR_S, -1);</a>
<a name="ln830"> </a>
<a name="ln831">#ifdef _WIN32</a>
<a name="ln832"> </a>
<a name="ln833">  if(! (g_ascii_isalpha(tokens[0][0]) &amp;&amp; tokens[0][strlen(tokens[0]) - 1] == ':') )</a>
<a name="ln834">  {</a>
<a name="ln835">    g_strfreev(tokens);</a>
<a name="ln836">    tokens = NULL;</a>
<a name="ln837">  }</a>
<a name="ln838"> </a>
<a name="ln839">  result = tokens;</a>
<a name="ln840"> </a>
<a name="ln841">#else</a>
<a name="ln842"> </a>
<a name="ln843">  // there are size + 1 elements in tokens -- the final NULL! we want to ignore it.</a>
<a name="ln844">  unsigned int size = g_strv_length(tokens);</a>
<a name="ln845"> </a>
<a name="ln846">  result = malloc(size * sizeof(char *));</a>
<a name="ln847">  for(unsigned int i = 0; i &lt; size; i++)</a>
<a name="ln848">    result[i] = tokens[i + 1];</a>
<a name="ln849"> </a>
<a name="ln850">  g_free(tokens[0]);</a>
<a name="ln851">  g_free(tokens);</a>
<a name="ln852"> </a>
<a name="ln853">#endif</a>
<a name="ln854"> </a>
<a name="ln855">  return result;</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">typedef struct name_key_tuple_t</a>
<a name="ln859">{</a>
<a name="ln860">  char *name, *collate_key;</a>
<a name="ln861">  int count;</a>
<a name="ln862">} name_key_tuple_t;</a>
<a name="ln863"> </a>
<a name="ln864">static void free_tuple(gpointer data)</a>
<a name="ln865">{</a>
<a name="ln866">  name_key_tuple_t *tuple = (name_key_tuple_t *)data;</a>
<a name="ln867">  g_free(tuple-&gt;name);</a>
<a name="ln868">  g_free(tuple-&gt;collate_key);</a>
<a name="ln869">  free(tuple);</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872">static gint sort_folder_tag(gconstpointer a, gconstpointer b)</a>
<a name="ln873">{</a>
<a name="ln874">  const name_key_tuple_t *tuple_a = (const name_key_tuple_t *)a;</a>
<a name="ln875">  const name_key_tuple_t *tuple_b = (const name_key_tuple_t *)b;</a>
<a name="ln876"> </a>
<a name="ln877">  return g_strcmp0(tuple_a-&gt;collate_key, tuple_b-&gt;collate_key);</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880">// create a key such that &quot;darktable|&quot; is coming first, and the rest is ordered such that sub tags are coming directly</a>
<a name="ln881">// behind their parent</a>
<a name="ln882">static char *tag_collate_key(char *tag)</a>
<a name="ln883">{</a>
<a name="ln884">  size_t len = strlen(tag);</a>
<a name="ln885">  char *result = g_malloc(len + 2);</a>
<a name="ln886">  if(g_str_has_prefix(tag, &quot;darktable|&quot;))</a>
<a name="ln887">    *result = '\1';</a>
<a name="ln888">  else</a>
<a name="ln889">    *result = '\2';</a>
<a name="ln890">  memcpy(result + 1, tag, len + 1);</a>
<a name="ln891">  for(char *iter = result + 1; *iter; iter++)</a>
<a name="ln892">    if(*iter == '|') *iter = '\1';</a>
<a name="ln893">  return result;</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896"> </a>
<a name="ln897">void tree_count_show(GtkTreeViewColumn *col, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter,</a>
<a name="ln898">                     gpointer data)</a>
<a name="ln899">{</a>
<a name="ln900">  gchar *name;</a>
<a name="ln901">  guint count;</a>
<a name="ln902"> </a>
<a name="ln903">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_TEXT, &amp;name, DT_LIB_COLLECT_COL_COUNT, &amp;count, -1);</a>
<a name="ln904">  if (!count)</a>
<a name="ln905">  {</a>
<a name="ln906">    g_object_set(renderer, &quot;text&quot;, name, NULL);</a>
<a name="ln907">  }</a>
<a name="ln908">  else</a>
<a name="ln909">  {</a>
<a name="ln910">    gchar *coltext = g_strdup_printf(&quot;%s (%d)&quot;, name, count);</a>
<a name="ln911">    g_object_set(renderer, &quot;text&quot;, coltext, NULL);</a>
<a name="ln912">    g_free(coltext);</a>
<a name="ln913">  }</a>
<a name="ln914"> </a>
<a name="ln915">  g_free(name);</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">static const char *UNCATEGORIZED_TAG = N_(&quot;uncategorized&quot;);</a>
<a name="ln919">static void tree_view(dt_lib_collect_rule_t *dr)</a>
<a name="ln920">{</a>
<a name="ln921">  // update related list</a>
<a name="ln922">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln923">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln924">  const gboolean folders = (property == DT_COLLECTION_PROP_FOLDERS);</a>
<a name="ln925">  const gboolean tags = (property == DT_COLLECTION_PROP_TAG);</a>
<a name="ln926">  const gboolean days = (property == DT_COLLECTION_PROP_DAY);</a>
<a name="ln927">  const gboolean times = (property == DT_COLLECTION_PROP_TIME);</a>
<a name="ln928">  const char *format_separator = folders ? &quot;%s&quot; G_DIR_SEPARATOR_S :</a>
<a name="ln929">  days || times ? &quot;%s:&quot; : &quot;%s|&quot;;</a>
<a name="ln930">  int insert_position = tags ? 0 : -1;</a>
<a name="ln931"> </a>
<a name="ln932">  set_properties(dr);</a>
<a name="ln933"> </a>
<a name="ln934">  GtkTreeModel *model = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(d-&gt;treefilter));</a>
<a name="ln935"> </a>
<a name="ln936">  if(d-&gt;view_rule != property)</a>
<a name="ln937">  {</a>
<a name="ln938">    // tree creation/recreation</a>
<a name="ln939">    sqlite3_stmt *stmt;</a>
<a name="ln940">    GtkTreeIter uncategorized = { 0 };</a>
<a name="ln941">    GtkTreeIter temp;</a>
<a name="ln942"> </a>
<a name="ln943">    g_object_ref(model);</a>
<a name="ln944">    g_object_unref(d-&gt;treefilter);</a>
<a name="ln945">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), NULL);</a>
<a name="ln946">    gtk_tree_store_clear(GTK_TREE_STORE(model));</a>
<a name="ln947">    gtk_widget_hide(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln948">    gtk_widget_hide(GTK_WIDGET(d-&gt;sw2));</a>
<a name="ln949"> </a>
<a name="ln950">    /* query construction */</a>
<a name="ln951">    gchar *where_ext = dt_collection_get_extended_where(darktable.collection, dr-&gt;num);</a>
<a name="ln952">    const char *query = g_strdup_printf(</a>
<a name="ln953">            folders ? &quot;SELECT folder, film_rolls_id, COUNT(*) AS count FROM main.images AS mi &quot;</a>
<a name="ln954">                    &quot;JOIN (SELECT id AS film_rolls_id, folder FROM main.film_rolls) ON film_id = film_rolls_id &quot;</a>
<a name="ln955">                    &quot;WHERE %s GROUP BY folder, film_rolls_id&quot;:</a>
<a name="ln956">            tags ? &quot;SELECT name, tag_id, COUNT(*) AS count FROM main.images AS mi JOIN main.tagged_images ON id = imgid &quot;</a>
<a name="ln957">                    &quot;JOIN (SELECT name, id AS tag_id FROM data.tags) ON tagid = tag_id &quot;</a>
<a name="ln958">                    &quot;WHERE %s GROUP BY name,tag_id&quot; :</a>
<a name="ln959">            days ? &quot;SELECT SUBSTR(datetime_taken, 1, 10) AS date, 1, COUNT(*) AS count FROM main.images AS mi &quot;</a>
<a name="ln960">                    &quot;WHERE %s GROUP BY date ORDER BY datetime_taken ASC&quot; :</a>
<a name="ln961">            times ? &quot;SELECT datetime_taken AS date, 1, COUNT(*) AS count FROM main.images AS mi &quot;</a>
<a name="ln962">                    &quot;WHERE %s GROUP BY date ORDER BY datetime_taken ASC&quot; :</a>
<a name="ln963">            NULL,</a>
<a name="ln964">            where_ext);</a>
<a name="ln965"> </a>
<a name="ln966">    g_free(where_ext);</a>
<a name="ln967">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln968"> </a>
<a name="ln969">    char **last_tokens = NULL;</a>
<a name="ln970">    int last_tokens_length = 0;</a>
<a name="ln971">    GtkTreeIter last_parent = { 0 };</a>
<a name="ln972"> </a>
<a name="ln973">    // we need to sort the names ourselves and not let sqlite handle this</a>
<a name="ln974">    // because it knows nothing about path separators.</a>
<a name="ln975">    GList *sorted_names = NULL;</a>
<a name="ln976">    while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln977">    {</a>
<a name="ln978">      char *name = g_strdup((const char *)sqlite3_column_text(stmt, 0));</a>
<a name="ln979">      gchar *collate_key = NULL;</a>
<a name="ln980"> </a>
<a name="ln981">      const int count = sqlite3_column_int(stmt, 2);</a>
<a name="ln982"> </a>
<a name="ln983">      if(folders)</a>
<a name="ln984">      {</a>
<a name="ln985">        char *name_folded = g_utf8_casefold(name, -1);</a>
<a name="ln986">        char *name_folded_slash = g_strconcat(name_folded, G_DIR_SEPARATOR_S, NULL);</a>
<a name="ln987">        collate_key = g_utf8_collate_key_for_filename(name_folded_slash, -1);</a>
<a name="ln988">        g_free(name_folded_slash);</a>
<a name="ln989">        g_free(name_folded);</a>
<a name="ln990">      }</a>
<a name="ln991">      else if(tags)</a>
<a name="ln992">        collate_key = tag_collate_key(name);</a>
<a name="ln993"> </a>
<a name="ln994">      name_key_tuple_t *tuple = (name_key_tuple_t *)malloc(sizeof(name_key_tuple_t));</a>
<a name="ln995">      tuple-&gt;name = name;</a>
<a name="ln996">      tuple-&gt;collate_key = collate_key;</a>
<a name="ln997">      tuple-&gt;count = count;</a>
<a name="ln998">      sorted_names = g_list_prepend(sorted_names, tuple);</a>
<a name="ln999">    }</a>
<a name="ln1000">    sqlite3_finalize(stmt);</a>
<a name="ln1001"> </a>
<a name="ln1002">    if(folders || tags)</a>
<a name="ln1003">      sorted_names = g_list_sort(sorted_names, sort_folder_tag);</a>
<a name="ln1004">    // we have to know about children in the hierarchy to not add single tags twice when they are</a>
<a name="ln1005">    // also a top level hierarchy</a>
<a name="ln1006">    if(tags)</a>
<a name="ln1007">      sorted_names = g_list_reverse(sorted_names);</a>
<a name="ln1008"> </a>
<a name="ln1009">    for(GList *names = sorted_names; names; names = g_list_next(names))</a>
<a name="ln1010">    {</a>
<a name="ln1011">      name_key_tuple_t *tuple = (name_key_tuple_t *)names-&gt;data;</a>
<a name="ln1012">      char *name = tuple-&gt;name;</a>
<a name="ln1013">      const int count = tuple-&gt;count;</a>
<a name="ln1014">      if(name == NULL) continue; // safeguard against degenerated db entries</a>
<a name="ln1015"> </a>
<a name="ln1016">      if(tags &amp;&amp; strchr(name, '|') == 0 &amp;&amp; (last_tokens_length == 0 || strcmp(name, *last_tokens)))</a>
<a name="ln1017">      {</a>
<a name="ln1018">        /* add uncategorized root iter if not exists */</a>
<a name="ln1019">        if(!uncategorized.stamp)</a>
<a name="ln1020">        {</a>
<a name="ln1021">          gtk_tree_store_insert(GTK_TREE_STORE(model), &amp;uncategorized, NULL, 0);</a>
<a name="ln1022">          gtk_tree_store_set(GTK_TREE_STORE(model), &amp;uncategorized, DT_LIB_COLLECT_COL_TEXT,</a>
<a name="ln1023">                             _(UNCATEGORIZED_TAG), DT_LIB_COLLECT_COL_PATH, &quot;&quot;, DT_LIB_COLLECT_COL_VISIBLE,</a>
<a name="ln1024">                             TRUE, -1);</a>
<a name="ln1025">          insert_position++; // we want to have this at the very top!</a>
<a name="ln1026">        }</a>
<a name="ln1027"> </a>
<a name="ln1028">        /* adding an uncategorized tag */</a>
<a name="ln1029">        gtk_tree_store_insert(GTK_TREE_STORE(model), &amp;temp, &amp;uncategorized, 0);</a>
<a name="ln1030">        gtk_tree_store_set(GTK_TREE_STORE(model), &amp;temp, DT_LIB_COLLECT_COL_TEXT, name,</a>
<a name="ln1031">                           DT_LIB_COLLECT_COL_PATH, name, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1032">                           DT_LIB_COLLECT_COL_COUNT, count, -1);</a>
<a name="ln1033">      }</a>
<a name="ln1034">      else</a>
<a name="ln1035">      {</a>
<a name="ln1036">        char **tokens;</a>
<a name="ln1037">        if(folders)</a>
<a name="ln1038">          tokens = split_path(name);</a>
<a name="ln1039">        else if(days)</a>
<a name="ln1040">          tokens = g_strsplit(name, &quot;:&quot;, -1);</a>
<a name="ln1041">        else if(times)</a>
<a name="ln1042">          tokens = g_strsplit_set(name, &quot;: &quot;, 4);</a>
<a name="ln1043">        else</a>
<a name="ln1044">          tokens = g_strsplit(name, &quot;|&quot;, -1);</a>
<a name="ln1045"> </a>
<a name="ln1046">        if(tokens != NULL)</a>
<a name="ln1047">        {</a>
<a name="ln1048">          // find the number of common parts at the beginning of tokens and last_tokens</a>
<a name="ln1049">          GtkTreeIter parent = last_parent;</a>
<a name="ln1050">          int tokens_length = string_array_length(tokens);</a>
<a name="ln1051">          int common_length = 0;</a>
<a name="ln1052">          if(last_tokens)</a>
<a name="ln1053">          {</a>
<a name="ln1054">            while(tokens[common_length] &amp;&amp; last_tokens[common_length] &amp;&amp;</a>
<a name="ln1055">                  !g_strcmp0(tokens[common_length], last_tokens[common_length]))</a>
<a name="ln1056">            {</a>
<a name="ln1057">              common_length++;</a>
<a name="ln1058">            }</a>
<a name="ln1059"> </a>
<a name="ln1060">            // point parent iter to where the entries should be added</a>
<a name="ln1061">            for(int i = common_length; i &lt; last_tokens_length; i++)</a>
<a name="ln1062">            {</a>
<a name="ln1063">              gtk_tree_model_iter_parent(model, &amp;parent, &amp;last_parent);</a>
<a name="ln1064">              last_parent = parent;</a>
<a name="ln1065">            }</a>
<a name="ln1066">          }</a>
<a name="ln1067"> </a>
<a name="ln1068">          // insert everything from tokens past the common part</a>
<a name="ln1069"> </a>
<a name="ln1070">          char *pth = NULL;</a>
<a name="ln1071">#ifndef _WIN32</a>
<a name="ln1072">          if(folders) pth = g_strdup(&quot;/&quot;);</a>
<a name="ln1073">#endif</a>
<a name="ln1074">          for(int i = 0; i &lt; common_length; i++)</a>
<a name="ln1075">            pth = dt_util_dstrcat(pth, format_separator, tokens[i]);</a>
<a name="ln1076"> </a>
<a name="ln1077">          for(char **token = &amp;tokens[common_length]; *token; token++)</a>
<a name="ln1078">          {</a>
<a name="ln1079">            GtkTreeIter iter;</a>
<a name="ln1080"> </a>
<a name="ln1081">            pth = dt_util_dstrcat(pth, format_separator, *token);</a>
<a name="ln1082">            if(times &amp;&amp; !*(token + 1)) pth[10] = ' ';</a>
<a name="ln1083"> </a>
<a name="ln1084">            gchar *pth2 = g_strdup(pth);</a>
<a name="ln1085">            pth2[strlen(pth2) - 1] = '\0';</a>
<a name="ln1086">            gtk_tree_store_insert(GTK_TREE_STORE(model), &amp;iter, common_length &gt; 0 ? &amp;parent : NULL, insert_position);</a>
<a name="ln1087">            gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_TEXT, *token,</a>
<a name="ln1088">                               DT_LIB_COLLECT_COL_PATH, pth2, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1089">                               DT_LIB_COLLECT_COL_COUNT, (*(token + 1)?0:count), -1);</a>
<a name="ln1090"> </a>
<a name="ln1091">            // also add the item count to parents</a>
<a name="ln1092">            if((folders || days || times) &amp;&amp; !*(token + 1))</a>
<a name="ln1093">            {</a>
<a name="ln1094">              guint parentcount;</a>
<a name="ln1095">              GtkTreeIter parent2, child = iter;</a>
<a name="ln1096"> </a>
<a name="ln1097">              while(gtk_tree_model_iter_parent(model, &amp;parent2, &amp;child))</a>
<a name="ln1098">              {</a>
<a name="ln1099">                gtk_tree_model_get(model, &amp;parent2, DT_LIB_COLLECT_COL_COUNT, &amp;parentcount, -1);</a>
<a name="ln1100">                gtk_tree_store_set(GTK_TREE_STORE(model), &amp;parent2, DT_LIB_COLLECT_COL_COUNT, count + parentcount, -1);</a>
<a name="ln1101">                child = parent2;</a>
<a name="ln1102">              }</a>
<a name="ln1103">            }</a>
<a name="ln1104"> </a>
<a name="ln1105">            if(folders)</a>
<a name="ln1106">              gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_UNREACHABLE,</a>
<a name="ln1107">                                 !(g_file_test(pth, G_FILE_TEST_IS_DIR)), -1);</a>
<a name="ln1108">            common_length++;</a>
<a name="ln1109">            parent = iter;</a>
<a name="ln1110">            g_free(pth2);</a>
<a name="ln1111">          }</a>
<a name="ln1112"> </a>
<a name="ln1113">          g_free(pth);</a>
<a name="ln1114"> </a>
<a name="ln1115">          // remember things for the next round</a>
<a name="ln1116">          if(last_tokens) g_strfreev(last_tokens);</a>
<a name="ln1117">          last_tokens = tokens;</a>
<a name="ln1118">          last_parent = parent;</a>
<a name="ln1119">          last_tokens_length = tokens_length;</a>
<a name="ln1120">        }</a>
<a name="ln1121">      }</a>
<a name="ln1122">    }</a>
<a name="ln1123">    g_list_free_full(sorted_names, free_tuple);</a>
<a name="ln1124"> </a>
<a name="ln1125"> </a>
<a name="ln1126">    gtk_tree_view_set_tooltip_column(GTK_TREE_VIEW(d-&gt;view), DT_LIB_COLLECT_COL_TOOLTIP);</a>
<a name="ln1127"> </a>
<a name="ln1128">    d-&gt;treefilter = _create_filtered_model(model, dr);</a>
<a name="ln1129"> </a>
<a name="ln1130">    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(d-&gt;view));</a>
<a name="ln1131">    if(property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1132">    {</a>
<a name="ln1133">      gtk_tree_selection_set_mode(selection, GTK_SELECTION_MULTIPLE);</a>
<a name="ln1134">    }</a>
<a name="ln1135">    else</a>
<a name="ln1136">    {</a>
<a name="ln1137">      gtk_tree_selection_set_mode(selection, GTK_SELECTION_SINGLE);</a>
<a name="ln1138">    }</a>
<a name="ln1139"> </a>
<a name="ln1140">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), d-&gt;treefilter);</a>
<a name="ln1141">    gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;scrolledwindow), FALSE);</a>
<a name="ln1142">    gtk_widget_show_all(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln1143"> </a>
<a name="ln1144">    g_object_unref(model);</a>
<a name="ln1145">    g_strfreev(last_tokens);</a>
<a name="ln1146"> </a>
<a name="ln1147">    d-&gt;view_rule = property;</a>
<a name="ln1148">  }</a>
<a name="ln1149"> </a>
<a name="ln1150">  // if needed, we restrict the tree to matching entries</a>
<a name="ln1151">  if(dr-&gt;typing) tree_set_visibility(model, dr);</a>
<a name="ln1152">  // we update tree expansion and selection</a>
<a name="ln1153">  gtk_tree_selection_unselect_all(gtk_tree_view_get_selection(d-&gt;view));</a>
<a name="ln1154">  gtk_tree_view_collapse_all(d-&gt;view);</a>
<a name="ln1155"> </a>
<a name="ln1156">  if(property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1157">  {</a>
<a name="ln1158">    // test selection range [xxx;xxx]</a>
<a name="ln1159">    GRegex *regex;</a>
<a name="ln1160">    GMatchInfo *match_info;</a>
<a name="ln1161">    int match_count;</a>
<a name="ln1162"> </a>
<a name="ln1163">    regex = g_regex_new(&quot;^\\s*\\[\\s*(.*)\\s*;\\s*(.*)\\s*\\]\\s*$&quot;, 0, 0, NULL);</a>
<a name="ln1164">    g_regex_match_full(regex, gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1, 0, 0, &amp;match_info, NULL);</a>
<a name="ln1165">    match_count = g_match_info_get_match_count(match_info);</a>
<a name="ln1166"> </a>
<a name="ln1167">    if(match_count == 3)</a>
<a name="ln1168">    {</a>
<a name="ln1169">      _range_t *range = (_range_t *)calloc(1, sizeof(_range_t));</a>
<a name="ln1170">      /* inversed as dates are in reverse order */</a>
<a name="ln1171">      range-&gt;start = g_match_info_fetch(match_info, 2);</a>
<a name="ln1172">      range-&gt;stop = g_match_info_fetch(match_info, 1);</a>
<a name="ln1173"> </a>
<a name="ln1174">      gtk_tree_model_foreach(d-&gt;treefilter, (GtkTreeModelForeachFunc)range_select, range);</a>
<a name="ln1175">      if(range-&gt;path1 &amp;&amp; range-&gt;path2)</a>
<a name="ln1176">      {</a>
<a name="ln1177">        gtk_tree_selection_select_range(gtk_tree_view_get_selection(d-&gt;view), range-&gt;path1, range-&gt;path2);</a>
<a name="ln1178">      }</a>
<a name="ln1179">      g_free(range-&gt;start);</a>
<a name="ln1180">      g_free(range-&gt;stop);</a>
<a name="ln1181">      gtk_tree_path_free(range-&gt;path1);</a>
<a name="ln1182">      gtk_tree_path_free(range-&gt;path2);</a>
<a name="ln1183">      free(range);</a>
<a name="ln1184">    }</a>
<a name="ln1185">    else</a>
<a name="ln1186">      gtk_tree_model_foreach(d-&gt;treefilter, (GtkTreeModelForeachFunc)tree_expand, dr);</a>
<a name="ln1187"> </a>
<a name="ln1188">    g_match_info_free(match_info);</a>
<a name="ln1189">    g_regex_unref(regex);</a>
<a name="ln1190">  }</a>
<a name="ln1191">  else</a>
<a name="ln1192">    gtk_tree_model_foreach(d-&gt;treefilter, (GtkTreeModelForeachFunc)tree_expand, dr);</a>
<a name="ln1193">}</a>
<a name="ln1194"> </a>
<a name="ln1195">static void list_view(dt_lib_collect_rule_t *dr)</a>
<a name="ln1196">{</a>
<a name="ln1197">  // update related list</a>
<a name="ln1198">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln1199">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln1200"> </a>
<a name="ln1201">  set_properties(dr);</a>
<a name="ln1202"> </a>
<a name="ln1203">  GtkTreeModel *model = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(d-&gt;listfilter));</a>
<a name="ln1204">  if(d-&gt;view_rule != property)</a>
<a name="ln1205">  {</a>
<a name="ln1206">    sqlite3_stmt *stmt;</a>
<a name="ln1207">    GtkTreeIter iter;</a>
<a name="ln1208">    g_object_unref(d-&gt;listfilter);</a>
<a name="ln1209">    g_object_ref(model);</a>
<a name="ln1210">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), NULL);</a>
<a name="ln1211">    gtk_list_store_clear(GTK_LIST_STORE(model));</a>
<a name="ln1212">    gtk_widget_hide(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln1213">    gtk_widget_hide(GTK_WIDGET(d-&gt;sw2));</a>
<a name="ln1214">    gchar *where_ext = dt_collection_get_extended_where(darktable.collection, dr-&gt;num);</a>
<a name="ln1215"> </a>
<a name="ln1216">    char query[1024] = { 0 };</a>
<a name="ln1217"> </a>
<a name="ln1218">    switch(property)</a>
<a name="ln1219">    {</a>
<a name="ln1220">      case DT_COLLECTION_PROP_CAMERA:; // camera</a>
<a name="ln1221">        int index = 0;</a>
<a name="ln1222">        gchar *makermodel_query = NULL;</a>
<a name="ln1223">        makermodel_query = dt_util_dstrcat(makermodel_query, &quot;SELECT maker, model, COUNT(*) AS count &quot;</a>
<a name="ln1224">                &quot;FROM main.images AS mi WHERE %s GROUP BY maker, model&quot;, where_ext);</a>
<a name="ln1225"> </a>
<a name="ln1226">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1227">                                makermodel_query,</a>
<a name="ln1228">                                -1, &amp;stmt, NULL);</a>
<a name="ln1229"> </a>
<a name="ln1230">        while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1231">        {</a>
<a name="ln1232">          char *exif_maker = (char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln1233">          char *exif_model = (char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln1234">          const int count = sqlite3_column_int(stmt, 2);</a>
<a name="ln1235"> </a>
<a name="ln1236">          gchar *value =  dt_collection_get_makermodel(exif_maker, exif_model);</a>
<a name="ln1237"> </a>
<a name="ln1238">          gtk_list_store_append(GTK_LIST_STORE(model), &amp;iter);</a>
<a name="ln1239">          gtk_list_store_set(GTK_LIST_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_TEXT, value,</a>
<a name="ln1240">                             DT_LIB_COLLECT_COL_ID, index, DT_LIB_COLLECT_COL_TOOLTIP, value,</a>
<a name="ln1241">                             DT_LIB_COLLECT_COL_PATH, value, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1242">                             DT_LIB_COLLECT_COL_COUNT, count,</a>
<a name="ln1243">                             -1);</a>
<a name="ln1244"> </a>
<a name="ln1245">          g_free(value);</a>
<a name="ln1246">          index++;</a>
<a name="ln1247">        }</a>
<a name="ln1248">        g_free(makermodel_query);</a>
<a name="ln1249">        break;</a>
<a name="ln1250"> </a>
<a name="ln1251">      case DT_COLLECTION_PROP_HISTORY: // History, 2 hardcoded alternatives</a>
<a name="ln1252">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1253">                           &quot;altered WHEN 1 THEN '%s' ELSE '%s' END as altered, 1, COUNT(*) AS count &quot;</a>
<a name="ln1254">                           &quot;FROM main.images AS mi LEFT JOIN &quot;</a>
<a name="ln1255">                           &quot;(SELECT DISTINCT imgid AS history_id, 1 AS altered FROM main.history) ON id = history_id &quot;</a>
<a name="ln1256">                           &quot;WHERE %s GROUP BY altered ORDER BY altered ASC&quot;,</a>
<a name="ln1257">                   _(&quot;altered&quot;),  _(&quot;not altered&quot;), where_ext);</a>
<a name="ln1258">        break;</a>
<a name="ln1259"> </a>
<a name="ln1260">      case DT_COLLECTION_PROP_GEOTAGGING: // Geotagging, 2 hardcoded alternatives</a>
<a name="ln1261">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1262">                           &quot;WHEN latitude IS NOT NULL AND longitude IS NOT NULL THEN '%s' ELSE '%s' END as tagged, 1, &quot;</a>
<a name="ln1263">                           &quot;COUNT(*) AS count &quot;</a>
<a name="ln1264">                           &quot;FROM main.images AS mi &quot;</a>
<a name="ln1265">                           &quot;WHERE %s GROUP BY tagged ORDER BY tagged ASC&quot;,</a>
<a name="ln1266">                       _(&quot;tagged&quot;),  _(&quot;not tagged&quot;), where_ext);</a>
<a name="ln1267">        break;</a>
<a name="ln1268"> </a>
<a name="ln1269">      case DT_COLLECTION_PROP_LOCAL_COPY: // local copy, 2 hardcoded alternatives</a>
<a name="ln1270">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1271">                           &quot;WHEN (flags &amp; %d) THEN '%s' ELSE '%s' END as lcp, 1, &quot;</a>
<a name="ln1272">                           &quot;COUNT(*) AS count &quot;</a>
<a name="ln1273">                           &quot;FROM main.images AS mi &quot;</a>
<a name="ln1274">                           &quot;WHERE %s GROUP BY lcp ORDER BY lcp ASC&quot;,</a>
<a name="ln1275">                   DT_IMAGE_LOCAL_COPY, _(&quot;copied locally&quot;),  _(&quot;not copied locally&quot;), where_ext);</a>
<a name="ln1276">        break;</a>
<a name="ln1277"> </a>
<a name="ln1278">      case DT_COLLECTION_PROP_ASPECT_RATIO: // aspect ratio, 3 hardcoded alternatives</a>
<a name="ln1279">        g_snprintf(query, sizeof(query), &quot;SELECT ROUND(aspect_ratio,1), 1, COUNT(*) AS count FROM main.images AS mi &quot;</a>
<a name="ln1280">                   &quot;WHERE %s GROUP BY ROUND(aspect_ratio,1)&quot;, where_ext);</a>
<a name="ln1281">        break;</a>
<a name="ln1282"> </a>
<a name="ln1283">      case DT_COLLECTION_PROP_COLORLABEL: // colorlabels</a>
<a name="ln1284">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1285">                           &quot;color WHEN 0 THEN '%s' WHEN 1 THEN '%s' WHEN 2 THEN '%s' WHEN 3 THEN '%s' WHEN 4 THEN '%s' &quot;</a>
<a name="ln1286">                           &quot;ELSE '' END, color, COUNT(*) AS count &quot;</a>
<a name="ln1287">                           &quot;FROM main.images AS mi JOIN &quot;</a>
<a name="ln1288">                           &quot;(SELECT imgid AS color_labels_id, color FROM main.color_labels) ON id = color_labels_id &quot;</a>
<a name="ln1289">                           &quot;WHERE %s GROUP BY color ORDER BY color DESC&quot;,</a>
<a name="ln1290">                   _(&quot;red&quot;), _(&quot;yellow&quot;), _(&quot;green&quot;), _(&quot;blue&quot;), _(&quot;purple&quot;), where_ext);</a>
<a name="ln1291">        break;</a>
<a name="ln1292"> </a>
<a name="ln1293">      // TODO: Add empty string for metadata?</a>
<a name="ln1294">      // TODO: Autogenerate this code?</a>
<a name="ln1295">      case DT_COLLECTION_PROP_TITLE: // title</a>
<a name="ln1296">        snprintf(query, sizeof(query),</a>
<a name="ln1297">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images AS mi JOIN &quot;</a>
<a name="ln1298">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1299">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1300">                 DT_METADATA_XMP_DC_TITLE, where_ext);</a>
<a name="ln1301">        break;</a>
<a name="ln1302">      case DT_COLLECTION_PROP_DESCRIPTION: // description</a>
<a name="ln1303">        snprintf(query, sizeof(query),</a>
<a name="ln1304">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images AS mi JOIN &quot;</a>
<a name="ln1305">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1306">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1307">                 DT_METADATA_XMP_DC_DESCRIPTION, where_ext);</a>
<a name="ln1308">        break;</a>
<a name="ln1309">      case DT_COLLECTION_PROP_CREATOR: // creator</a>
<a name="ln1310">        snprintf(query, sizeof(query),</a>
<a name="ln1311">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images AS mi JOIN &quot;</a>
<a name="ln1312">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1313">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1314">                 DT_METADATA_XMP_DC_CREATOR, where_ext);</a>
<a name="ln1315">        break;</a>
<a name="ln1316">      case DT_COLLECTION_PROP_PUBLISHER: // publisher</a>
<a name="ln1317">        snprintf(query, sizeof(query),</a>
<a name="ln1318">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images AS mi JOIN &quot;</a>
<a name="ln1319">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1320">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1321">                 DT_METADATA_XMP_DC_PUBLISHER, where_ext);</a>
<a name="ln1322">        break;</a>
<a name="ln1323">      case DT_COLLECTION_PROP_RIGHTS: // rights</a>
<a name="ln1324">        snprintf(query, sizeof(query),</a>
<a name="ln1325">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images AS mi JOIN &quot;</a>
<a name="ln1326">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1327">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1328">                 DT_METADATA_XMP_DC_RIGHTS, where_ext);</a>
<a name="ln1329">        break;</a>
<a name="ln1330">      case DT_COLLECTION_PROP_LENS: // lens</a>
<a name="ln1331">        g_snprintf(query, sizeof(query), &quot;SELECT lens, 1, COUNT(*) AS count &quot;</a>
<a name="ln1332">                &quot;FROM main.images AS mi WHERE %s GROUP BY lens ORDER BY lens&quot;, where_ext);</a>
<a name="ln1333">        break;</a>
<a name="ln1334"> </a>
<a name="ln1335">      case DT_COLLECTION_PROP_FOCAL_LENGTH: // focal length</a>
<a name="ln1336">        g_snprintf(query, sizeof(query), &quot;SELECT CAST(focal_length AS INTEGER) AS focal_length, 1, COUNT(*) AS count &quot;</a>
<a name="ln1337">                         &quot;FROM main.images AS mi WHERE %s GROUP BY focal_length ORDER BY focal_length&quot;,</a>
<a name="ln1338">                   where_ext);</a>
<a name="ln1339">        break;</a>
<a name="ln1340"> </a>
<a name="ln1341">      case DT_COLLECTION_PROP_ISO: // iso</a>
<a name="ln1342">        g_snprintf(query, sizeof(query), &quot;SELECT CAST(iso AS INTEGER) AS iso, 1, COUNT(*) AS count &quot;</a>
<a name="ln1343">                           &quot;FROM main.images AS mi WHERE %s GROUP BY iso ORDER BY iso&quot;,</a>
<a name="ln1344">                   where_ext);</a>
<a name="ln1345">        break;</a>
<a name="ln1346"> </a>
<a name="ln1347">      case DT_COLLECTION_PROP_APERTURE: // aperture</a>
<a name="ln1348">        g_snprintf(query, sizeof(query), &quot;SELECT ROUND(aperture,1) AS aperture, 1, COUNT(*) AS count &quot;</a>
<a name="ln1349">                           &quot;FROM main.images AS mi WHERE %s GROUP BY aperture ORDER BY aperture&quot;,</a>
<a name="ln1350">                   where_ext);</a>
<a name="ln1351">        break;</a>
<a name="ln1352"> </a>
<a name="ln1353">      case DT_COLLECTION_PROP_EXPOSURE: // exposure</a>
<a name="ln1354">        g_snprintf(query, sizeof(query), &quot;SELECT CASE WHEN (exposure &lt; 0.4) &quot;</a>
<a name="ln1355">                              &quot;THEN '1/' || CAST(1/exposure + 0.9 AS INTEGER) &quot;</a>
<a name="ln1356">                           &quot;ELSE ROUND(exposure,2) || '\&quot;' END as _exposure, 1, COUNT(*) AS count &quot;</a>
<a name="ln1357">                &quot;FROM main.images AS mi WHERE %s GROUP BY _exposure ORDER BY exposure&quot;,</a>
<a name="ln1358">                  where_ext);</a>
<a name="ln1359">        break;</a>
<a name="ln1360"> </a>
<a name="ln1361">      case DT_COLLECTION_PROP_FILENAME: // filename</a>
<a name="ln1362">        g_snprintf(query, sizeof(query), &quot;SELECT filename, 1, COUNT(*) AS count &quot;</a>
<a name="ln1363">                &quot;FROM main.images AS mi WHERE %s GROUP BY filename ORDER BY filename&quot;, where_ext);</a>
<a name="ln1364">        break;</a>
<a name="ln1365"> </a>
<a name="ln1366">      default: // filmroll</a>
<a name="ln1367">        g_snprintf(query, sizeof(query), &quot;SELECT folder, film_rolls_id, COUNT(*) AS count &quot;</a>
<a name="ln1368">                &quot;FROM main.images AS mi JOIN &quot;</a>
<a name="ln1369">                &quot;(SELECT id AS film_rolls_id, folder FROM main.film_rolls) ON film_id = film_rolls_id &quot;</a>
<a name="ln1370">                &quot;WHERE %s GROUP BY folder ORDER BY folder DESC&quot;, where_ext);</a>
<a name="ln1371">        break;</a>
<a name="ln1372"> </a>
<a name="ln1373">      case DT_COLLECTION_PROP_GROUPING: // Grouping, 2 hardcoded alternatives</a>
<a name="ln1374">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1375">                           &quot;WHEN id = group_id THEN '%s' ELSE '%s' END as group_leader, 1, &quot;</a>
<a name="ln1376">                           &quot;COUNT(*) AS count &quot;</a>
<a name="ln1377">                           &quot;FROM main.images AS mi &quot;</a>
<a name="ln1378">                           &quot;WHERE %s GROUP BY group_leader ORDER BY group_leader ASC&quot;,</a>
<a name="ln1379">                   _(&quot;group leaders&quot;),  _(&quot;group followers&quot;), where_ext);</a>
<a name="ln1380">        break;</a>
<a name="ln1381">    }</a>
<a name="ln1382"> </a>
<a name="ln1383">    g_free(where_ext);</a>
<a name="ln1384"> </a>
<a name="ln1385">    if(strlen(query) &gt; 0)</a>
<a name="ln1386">    {</a>
<a name="ln1387">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln1388">      while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1389">      {</a>
<a name="ln1390">        const char *folder = (const char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln1391">        if(folder == NULL) continue; // safeguard against degenerated db entries</a>
<a name="ln1392"> </a>
<a name="ln1393">        gtk_list_store_append(GTK_LIST_STORE(model), &amp;iter);</a>
<a name="ln1394">        if(property == DT_COLLECTION_PROP_FILMROLL)</a>
<a name="ln1395">        {</a>
<a name="ln1396">          folder = dt_image_film_roll_name(folder);</a>
<a name="ln1397">        }</a>
<a name="ln1398">        gchar *value = (gchar *)sqlite3_column_text(stmt, 0);</a>
<a name="ln1399">        const int count = sqlite3_column_int(stmt, 2);</a>
<a name="ln1400"> </a>
<a name="ln1401">        // replace invalid utf8 characters if any</a>
<a name="ln1402">        gchar *text = g_strdup(value);</a>
<a name="ln1403">        gchar *ptr = text;</a>
<a name="ln1404">        while(!g_utf8_validate(ptr, -1, (const gchar **)&amp;ptr)) ptr[0] = '?';</a>
<a name="ln1405"> </a>
<a name="ln1406">        gchar *escaped_text = g_markup_escape_text(text, -1);</a>
<a name="ln1407"> </a>
<a name="ln1408">        gtk_list_store_set(GTK_LIST_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_TEXT, folder,</a>
<a name="ln1409">                           DT_LIB_COLLECT_COL_ID, sqlite3_column_int(stmt, 1), DT_LIB_COLLECT_COL_TOOLTIP,</a>
<a name="ln1410">                           escaped_text, DT_LIB_COLLECT_COL_PATH, value, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1411">                           DT_LIB_COLLECT_COL_COUNT, count,</a>
<a name="ln1412">                           -1);</a>
<a name="ln1413">        g_free(text);</a>
<a name="ln1414">        g_free(escaped_text);</a>
<a name="ln1415">      }</a>
<a name="ln1416">      sqlite3_finalize(stmt);</a>
<a name="ln1417">    }</a>
<a name="ln1418"> </a>
<a name="ln1419">    gtk_tree_view_set_tooltip_column(GTK_TREE_VIEW(d-&gt;view), DT_LIB_COLLECT_COL_TOOLTIP);</a>
<a name="ln1420"> </a>
<a name="ln1421">    d-&gt;listfilter = _create_filtered_model(model, dr);</a>
<a name="ln1422"> </a>
<a name="ln1423">    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(d-&gt;view));</a>
<a name="ln1424">    if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln1425">       || property == DT_COLLECTION_PROP_ISO || property == DT_COLLECTION_PROP_EXPOSURE</a>
<a name="ln1426">       || property == DT_COLLECTION_PROP_ASPECT_RATIO)</a>
<a name="ln1427">    {</a>
<a name="ln1428">      gtk_tree_selection_set_mode(selection, GTK_SELECTION_MULTIPLE);</a>
<a name="ln1429">    }</a>
<a name="ln1430">    else</a>
<a name="ln1431">    {</a>
<a name="ln1432">      gtk_tree_selection_set_mode(selection, GTK_SELECTION_SINGLE);</a>
<a name="ln1433">    }</a>
<a name="ln1434"> </a>
<a name="ln1435">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), d-&gt;listfilter);</a>
<a name="ln1436">    gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;scrolledwindow), FALSE);</a>
<a name="ln1437">    gtk_widget_show_all(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln1438"> </a>
<a name="ln1439">    g_object_unref(model);</a>
<a name="ln1440"> </a>
<a name="ln1441">    d-&gt;view_rule = property;</a>
<a name="ln1442">  }</a>
<a name="ln1443"> </a>
<a name="ln1444">  // if needed, we restrict the tree to matching entries</a>
<a name="ln1445">  if(dr-&gt;typing &amp;&amp; (property == DT_COLLECTION_PROP_CAMERA || property == DT_COLLECTION_PROP_CREATOR</a>
<a name="ln1446">                    || property == DT_COLLECTION_PROP_DESCRIPTION || property == DT_COLLECTION_PROP_FILENAME</a>
<a name="ln1447">                    || property == DT_COLLECTION_PROP_FILMROLL || property == DT_COLLECTION_PROP_LENS</a>
<a name="ln1448">                    || property == DT_COLLECTION_PROP_PUBLISHER || property == DT_COLLECTION_PROP_RIGHTS</a>
<a name="ln1449">                    || property == DT_COLLECTION_PROP_TITLE || property == DT_COLLECTION_PROP_APERTURE</a>
<a name="ln1450">                    || property == DT_COLLECTION_PROP_FOCAL_LENGTH || property == DT_COLLECTION_PROP_ISO))</a>
<a name="ln1451">    gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)list_match_string, dr);</a>
<a name="ln1452">  // we update list selection</a>
<a name="ln1453">  gtk_tree_selection_unselect_all(gtk_tree_view_get_selection(d-&gt;view));</a>
<a name="ln1454"> </a>
<a name="ln1455">  if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln1456">     || property == DT_COLLECTION_PROP_ISO || property == DT_COLLECTION_PROP_EXPOSURE</a>
<a name="ln1457">     || property == DT_COLLECTION_PROP_ASPECT_RATIO)</a>
<a name="ln1458">  {</a>
<a name="ln1459">    // test selection range [xxx;xxx]</a>
<a name="ln1460">    GRegex *regex;</a>
<a name="ln1461">    GMatchInfo *match_info;</a>
<a name="ln1462">    int match_count;</a>
<a name="ln1463"> </a>
<a name="ln1464">    regex = g_regex_new(&quot;^\\s*\\[\\s*(.*)\\s*;\\s*(.*)\\s*\\]\\s*$&quot;, 0, 0, NULL);</a>
<a name="ln1465">    g_regex_match_full(regex, gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1, 0, 0, &amp;match_info, NULL);</a>
<a name="ln1466">    match_count = g_match_info_get_match_count(match_info);</a>
<a name="ln1467"> </a>
<a name="ln1468">    if(match_count == 3)</a>
<a name="ln1469">    {</a>
<a name="ln1470">      _range_t *range = (_range_t *)calloc(1, sizeof(_range_t));</a>
<a name="ln1471">      range-&gt;start = g_match_info_fetch(match_info, 1);</a>
<a name="ln1472">      range-&gt;stop = g_match_info_fetch(match_info, 2);</a>
<a name="ln1473"> </a>
<a name="ln1474">      gtk_tree_model_foreach(d-&gt;listfilter, (GtkTreeModelForeachFunc)range_select, range);</a>
<a name="ln1475">      if(range-&gt;path1 &amp;&amp; range-&gt;path2)</a>
<a name="ln1476">      {</a>
<a name="ln1477">        gtk_tree_selection_select_range(gtk_tree_view_get_selection(d-&gt;view), range-&gt;path1, range-&gt;path2);</a>
<a name="ln1478">      }</a>
<a name="ln1479">      g_free(range-&gt;start);</a>
<a name="ln1480">      g_free(range-&gt;stop);</a>
<a name="ln1481">      gtk_tree_path_free(range-&gt;path1);</a>
<a name="ln1482">      gtk_tree_path_free(range-&gt;path2);</a>
<a name="ln1483">      free(range);</a>
<a name="ln1484">    }</a>
<a name="ln1485">    else</a>
<a name="ln1486">      gtk_tree_model_foreach(d-&gt;listfilter, (GtkTreeModelForeachFunc)list_select, dr);</a>
<a name="ln1487"> </a>
<a name="ln1488">    g_match_info_free(match_info);</a>
<a name="ln1489">    g_regex_unref(regex);</a>
<a name="ln1490">  }</a>
<a name="ln1491">  else</a>
<a name="ln1492">    gtk_tree_model_foreach(d-&gt;listfilter, (GtkTreeModelForeachFunc)list_select, dr);</a>
<a name="ln1493">}</a>
<a name="ln1494"> </a>
<a name="ln1495">static void update_view(dt_lib_collect_rule_t *dr)</a>
<a name="ln1496">{</a>
<a name="ln1497">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln1498"> </a>
<a name="ln1499">  if(property == DT_COLLECTION_PROP_FOLDERS || property == DT_COLLECTION_PROP_TAG</a>
<a name="ln1500">     || property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1501">    tree_view(dr);</a>
<a name="ln1502">  else</a>
<a name="ln1503">    list_view(dr);</a>
<a name="ln1504">}</a>
<a name="ln1505"> </a>
<a name="ln1506"> </a>
<a name="ln1507">static void _lib_collect_gui_update(dt_lib_module_t *self)</a>
<a name="ln1508">{</a>
<a name="ln1509">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln1510"> </a>
<a name="ln1511">  // we check if something as change since last call</a>
<a name="ln1512">  if(d-&gt;view_rule != -1) return;</a>
<a name="ln1513"> </a>
<a name="ln1514">  const int old = darktable.gui-&gt;reset;</a>
<a name="ln1515">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1516">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;) - 1;</a>
<a name="ln1517">  const int active = CLAMP(_a, 0, (MAX_RULES - 1));</a>
<a name="ln1518">  d-&gt;nb_rules = active + 1;</a>
<a name="ln1519">  char confname[200] = { 0 };</a>
<a name="ln1520"> </a>
<a name="ln1521">  gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;scrolledwindow), TRUE);</a>
<a name="ln1522">  gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;sw2), TRUE);</a>
<a name="ln1523"> </a>
<a name="ln1524">  for(int i = 0; i &lt; MAX_RULES; i++)</a>
<a name="ln1525">  {</a>
<a name="ln1526">    gtk_widget_set_no_show_all(d-&gt;rule[i].hbox, TRUE);</a>
<a name="ln1527">    gtk_widget_set_visible(d-&gt;rule[i].hbox, FALSE);</a>
<a name="ln1528">  }</a>
<a name="ln1529">  for(int i = 0; i &lt;= active; i++)</a>
<a name="ln1530">  {</a>
<a name="ln1531">    gtk_widget_set_no_show_all(d-&gt;rule[i].hbox, FALSE);</a>
<a name="ln1532">    gtk_widget_set_visible(d-&gt;rule[i].hbox, TRUE);</a>
<a name="ln1533">    gtk_widget_show_all(d-&gt;rule[i].hbox);</a>
<a name="ln1534">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln1535">    gtk_combo_box_set_active(GTK_COMBO_BOX(d-&gt;rule[i].combo), dt_conf_get_int(confname));</a>
<a name="ln1536">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln1537">    gchar *text = dt_conf_get_string(confname);</a>
<a name="ln1538">    if(text)</a>
<a name="ln1539">    {</a>
<a name="ln1540">      g_signal_handlers_block_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1541">      g_signal_handlers_block_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1542">      gtk_entry_set_text(GTK_ENTRY(d-&gt;rule[i].text), text);</a>
<a name="ln1543">      gtk_editable_set_position(GTK_EDITABLE(d-&gt;rule[i].text), -1);</a>
<a name="ln1544">      g_signal_handlers_unblock_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1545">      g_signal_handlers_unblock_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1546">      g_free(text);</a>
<a name="ln1547">      d-&gt;rule[i].typing = FALSE;</a>
<a name="ln1548">    }</a>
<a name="ln1549"> </a>
<a name="ln1550">    GtkDarktableButton *button = DTGTK_BUTTON(d-&gt;rule[i].button);</a>
<a name="ln1551">    if(i == MAX_RULES - 1)</a>
<a name="ln1552">    {</a>
<a name="ln1553">      // only clear</a>
<a name="ln1554">      button-&gt;icon = dtgtk_cairo_paint_cancel;</a>
<a name="ln1555">      gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;clear this rule&quot;));</a>
<a name="ln1556">    }</a>
<a name="ln1557">    else if(i == active)</a>
<a name="ln1558">    {</a>
<a name="ln1559">      button-&gt;icon = dtgtk_cairo_paint_dropdown;</a>
<a name="ln1560">      gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;clear this rule or add new rules&quot;));</a>
<a name="ln1561">    }</a>
<a name="ln1562">    else</a>
<a name="ln1563">    {</a>
<a name="ln1564">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i + 1);</a>
<a name="ln1565">      const int mode = dt_conf_get_int(confname);</a>
<a name="ln1566">      if(mode == DT_LIB_COLLECT_MODE_AND) button-&gt;icon = dtgtk_cairo_paint_and;</a>
<a name="ln1567">      if(mode == DT_LIB_COLLECT_MODE_OR) button-&gt;icon = dtgtk_cairo_paint_or;</a>
<a name="ln1568">      if(mode == DT_LIB_COLLECT_MODE_AND_NOT) button-&gt;icon = dtgtk_cairo_paint_andnot;</a>
<a name="ln1569">      gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;clear this rule&quot;));</a>
<a name="ln1570">    }</a>
<a name="ln1571">  }</a>
<a name="ln1572"> </a>
<a name="ln1573">  // update list of proposals</a>
<a name="ln1574">  update_view(d-&gt;rule + d-&gt;active_rule);</a>
<a name="ln1575">  darktable.gui-&gt;reset = old;</a>
<a name="ln1576">}</a>
<a name="ln1577"> </a>
<a name="ln1578">void gui_reset(dt_lib_module_t *self)</a>
<a name="ln1579">{</a>
<a name="ln1580">  dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, 1);</a>
<a name="ln1581">  dt_conf_set_int(&quot;plugins/lighttable/collect/item0&quot;, DT_COLLECTION_PROP_FILMROLL);</a>
<a name="ln1582">  dt_conf_set_int(&quot;plugins/lighttable/collect/mode0&quot;, 0);</a>
<a name="ln1583">  dt_conf_set_string(&quot;plugins/lighttable/collect/string0&quot;, &quot;&quot;);</a>
<a name="ln1584">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln1585">  d-&gt;active_rule = 0;</a>
<a name="ln1586">  d-&gt;view_rule = -1;</a>
<a name="ln1587">  dt_collection_set_query_flags(darktable.collection, COLLECTION_QUERY_FULL);</a>
<a name="ln1588">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1589">}</a>
<a name="ln1590"> </a>
<a name="ln1591">static void combo_changed(GtkComboBox *combo, dt_lib_collect_rule_t *d)</a>
<a name="ln1592">{</a>
<a name="ln1593">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln1594">  g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1595">  g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1596">  gtk_entry_set_text(GTK_ENTRY(d-&gt;text), &quot;&quot;);</a>
<a name="ln1597">  g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1598">  g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1599">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1600">  c-&gt;active_rule = d-&gt;num;</a>
<a name="ln1601"> </a>
<a name="ln1602">  int property = gtk_combo_box_get_active(d-&gt;combo);</a>
<a name="ln1603"> </a>
<a name="ln1604">  if(property == DT_COLLECTION_PROP_FOLDERS || property == DT_COLLECTION_PROP_TAG</a>
<a name="ln1605">     || property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1606">  {</a>
<a name="ln1607">    d-&gt;typing = FALSE;</a>
<a name="ln1608">  }</a>
<a name="ln1609"> </a>
<a name="ln1610">  if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln1611">     || property == DT_COLLECTION_PROP_ISO || property == DT_COLLECTION_PROP_ASPECT_RATIO</a>
<a name="ln1612">     || property == DT_COLLECTION_PROP_EXPOSURE)</a>
<a name="ln1613">  {</a>
<a name="ln1614">    gtk_widget_set_tooltip_text(d-&gt;text, _(&quot;type your query, use &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, =, [;] as operators&quot;));</a>
<a name="ln1615">  }</a>
<a name="ln1616">  else if(property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1617">  {</a>
<a name="ln1618">    gtk_widget_set_tooltip_text(d-&gt;text,</a>
<a name="ln1619">                                _(&quot;type your query, use &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, =, [;] as operators, type dates in &quot;</a>
<a name="ln1620">                                  &quot;the form : YYYY:MM:DD HH:MM:SS (only the year is mandatory)&quot;));</a>
<a name="ln1621">  }</a>
<a name="ln1622">  else</a>
<a name="ln1623">  {</a>
<a name="ln1624">    /* xgettext:no-c-format */</a>
<a name="ln1625">    gtk_widget_set_tooltip_text(d-&gt;text, _(&quot;type your query, use `%' as wildcard&quot;));</a>
<a name="ln1626">  }</a>
<a name="ln1627"> </a>
<a name="ln1628">  set_properties(d);</a>
<a name="ln1629">  c-&gt;view_rule = -1;</a>
<a name="ln1630">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">static void row_activated_with_event(GtkTreeView *view, GtkTreePath *path, GtkTreeViewColumn *col, GdkEventButton *event, dt_lib_collect_t *d)</a>
<a name="ln1634">{</a>
<a name="ln1635">  GtkTreeIter iter;</a>
<a name="ln1636">  GtkTreeModel *model = NULL;</a>
<a name="ln1637"> </a>
<a name="ln1638">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln1639">  if(gtk_tree_selection_count_selected_rows(selection) &lt; 1) return;</a>
<a name="ln1640">  GList *sels = gtk_tree_selection_get_selected_rows(selection, &amp;model);</a>
<a name="ln1641">  GtkTreePath *path1 = (GtkTreePath *)g_list_nth_data(sels, 0);</a>
<a name="ln1642">  if(!gtk_tree_model_get_iter(model, &amp;iter, path1)) return;</a>
<a name="ln1643"> </a>
<a name="ln1644">  gchar *text;</a>
<a name="ln1645"> </a>
<a name="ln1646">  const int active = d-&gt;active_rule;</a>
<a name="ln1647">  d-&gt;rule[active].typing = FALSE;</a>
<a name="ln1648"> </a>
<a name="ln1649">  const int item = gtk_combo_box_get_active(GTK_COMBO_BOX(d-&gt;rule[active].combo));</a>
<a name="ln1650">  gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;text, -1);</a>
<a name="ln1651"> </a>
<a name="ln1652">  if(text &amp;&amp; strlen(text) &gt; 0)</a>
<a name="ln1653">  {</a>
<a name="ln1654">    if(gtk_tree_selection_count_selected_rows(selection) &gt; 1</a>
<a name="ln1655">       &amp;&amp; (item == DT_COLLECTION_PROP_DAY || item == DT_COLLECTION_PROP_TIME || item == DT_COLLECTION_PROP_APERTURE</a>
<a name="ln1656">           || item == DT_COLLECTION_PROP_FOCAL_LENGTH || item == DT_COLLECTION_PROP_ISO</a>
<a name="ln1657">           || item == DT_COLLECTION_PROP_EXPOSURE || item == DT_COLLECTION_PROP_ASPECT_RATIO))</a>
<a name="ln1658">    {</a>
<a name="ln1659">      /* this is a range selection */</a>
<a name="ln1660">      GtkTreeIter iter2;</a>
<a name="ln1661">      GtkTreePath *path2 = (GtkTreePath *)g_list_last(sels)-&gt;data;</a>
<a name="ln1662">      if(!gtk_tree_model_get_iter(model, &amp;iter2, path2)) return;</a>
<a name="ln1663"> </a>
<a name="ln1664">      gchar *text2;</a>
<a name="ln1665">      gtk_tree_model_get(model, &amp;iter2, DT_LIB_COLLECT_COL_PATH, &amp;text2, -1);</a>
<a name="ln1666"> </a>
<a name="ln1667">      gchar *n_text;</a>
<a name="ln1668">      if(item == DT_COLLECTION_PROP_DAY || item == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1669">        n_text = g_strdup_printf(&quot;[%s;%s]&quot;, text2, text); /* dates are in reverse order */</a>
<a name="ln1670">      else</a>
<a name="ln1671">        n_text = g_strdup_printf(&quot;[%s;%s]&quot;, text, text2);</a>
<a name="ln1672"> </a>
<a name="ln1673">      g_free(text);</a>
<a name="ln1674">      g_free(text2);</a>
<a name="ln1675">      text = n_text;</a>
<a name="ln1676">    }</a>
<a name="ln1677">    else if(item == DT_COLLECTION_PROP_TAG &amp;&amp; gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln1678">    {</a>
<a name="ln1679">      /* if a tag has children, ctrl-clicking on a parent node should display all images under this hierarchy. */</a>
<a name="ln1680">      if(event-&gt;state &amp; GDK_CONTROL_MASK)</a>
<a name="ln1681">      {</a>
<a name="ln1682">        gchar *n_text = g_strconcat(text, &quot;|%&quot;, NULL);</a>
<a name="ln1683">        g_free(text);</a>
<a name="ln1684">        text = n_text;</a>
<a name="ln1685">      }</a>
<a name="ln1686">      /* if a tag has children, shift-clicking on a parent node should display all images in and under this</a>
<a name="ln1687">       * hierarchy. */</a>
<a name="ln1688">      else if(event-&gt;state &amp; GDK_SHIFT_MASK)</a>
<a name="ln1689">      {</a>
<a name="ln1690">        gchar *n_text = g_strconcat(text, &quot;%&quot;, NULL);</a>
<a name="ln1691">        g_free(text);</a>
<a name="ln1692">        text = n_text;</a>
<a name="ln1693">      }</a>
<a name="ln1694">    }</a>
<a name="ln1695">  }</a>
<a name="ln1696"> </a>
<a name="ln1697">  g_signal_handlers_block_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1698">  g_signal_handlers_block_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1699">  gtk_entry_set_text(GTK_ENTRY(d-&gt;rule[active].text), text);</a>
<a name="ln1700">  gtk_editable_set_position(GTK_EDITABLE(d-&gt;rule[active].text), -1);</a>
<a name="ln1701">  g_signal_handlers_unblock_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text,</a>
<a name="ln1702">                                    NULL);</a>
<a name="ln1703">  g_signal_handlers_unblock_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed,</a>
<a name="ln1704">                                    NULL);</a>
<a name="ln1705">  g_free(text);</a>
<a name="ln1706"> </a>
<a name="ln1707">  if(item == DT_COLLECTION_PROP_TAG || item == DT_COLLECTION_PROP_FOLDERS</a>
<a name="ln1708">     || item == DT_COLLECTION_PROP_DAY || item == DT_COLLECTION_PROP_TIME</a>
<a name="ln1709">     || item == DT_COLLECTION_PROP_COLORLABEL || item == DT_COLLECTION_PROP_GEOTAGGING</a>
<a name="ln1710">     || item == DT_COLLECTION_PROP_HISTORY ||  item == DT_COLLECTION_PROP_LOCAL_COPY</a>
<a name="ln1711">     || item == DT_COLLECTION_PROP_GROUPING)</a>
<a name="ln1712">    set_properties(d-&gt;rule + active); // we just have to set the selection</a>
<a name="ln1713">  else</a>
<a name="ln1714">    update_view(d-&gt;rule + active); // we have to update visible items too</a>
<a name="ln1715"> </a>
<a name="ln1716">  dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1717">                                  darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1718">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1719">  dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1720">                                    darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1721">  dt_control_queue_redraw_center();</a>
<a name="ln1722">}</a>
<a name="ln1723"> </a>
<a name="ln1724">static void entry_activated(GtkWidget *entry, dt_lib_collect_rule_t *d)</a>
<a name="ln1725">{</a>
<a name="ln1726">  GtkTreeView *view;</a>
<a name="ln1727">  GtkTreeModel *model;</a>
<a name="ln1728">  int property, rows;</a>
<a name="ln1729"> </a>
<a name="ln1730">  update_view(d);</a>
<a name="ln1731">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1732"> </a>
<a name="ln1733">  property = gtk_combo_box_get_active(d-&gt;combo);</a>
<a name="ln1734"> </a>
<a name="ln1735">  if(property != DT_COLLECTION_PROP_FOLDERS &amp;&amp; property != DT_COLLECTION_PROP_TAG</a>
<a name="ln1736">     &amp;&amp; property != DT_COLLECTION_PROP_DAY &amp;&amp; property != DT_COLLECTION_PROP_TIME)</a>
<a name="ln1737">  {</a>
<a name="ln1738">    view = c-&gt;view;</a>
<a name="ln1739">    model = gtk_tree_view_get_model(GTK_TREE_VIEW(view));</a>
<a name="ln1740"> </a>
<a name="ln1741">    rows = gtk_tree_model_iter_n_children(model, NULL);</a>
<a name="ln1742"> </a>
<a name="ln1743">    if(rows == 1)</a>
<a name="ln1744">    {</a>
<a name="ln1745">      GtkTreeIter iter;</a>
<a name="ln1746">      if(gtk_tree_model_get_iter_first(model, &amp;iter))</a>
<a name="ln1747">      {</a>
<a name="ln1748">        gchar *text;</a>
<a name="ln1749">        gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;text, -1);</a>
<a name="ln1750"> </a>
<a name="ln1751">        g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1752">        g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1753">        gtk_entry_set_text(GTK_ENTRY(d-&gt;text), text);</a>
<a name="ln1754">        gtk_editable_set_position(GTK_EDITABLE(d-&gt;text), -1);</a>
<a name="ln1755">        g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1756">        g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1757">        g_free(text);</a>
<a name="ln1758">        d-&gt;typing = FALSE;</a>
<a name="ln1759">        update_view(d);</a>
<a name="ln1760">      }</a>
<a name="ln1761">    }</a>
<a name="ln1762">  }</a>
<a name="ln1763">  dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1764">                                  darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1765">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1766">  dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1767">                                    darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1768">}</a>
<a name="ln1769"> </a>
<a name="ln1770">static void entry_insert_text(GtkWidget *entry, gchar *new_text, gint new_length, gpointer *position,</a>
<a name="ln1771">                          dt_lib_collect_rule_t *d)</a>
<a name="ln1772">{</a>
<a name="ln1773">  d-&gt;typing = TRUE;</a>
<a name="ln1774">}</a>
<a name="ln1775"> </a>
<a name="ln1776">static void entry_changed(GtkEntry *entry, dt_lib_collect_rule_t *dr)</a>
<a name="ln1777">{</a>
<a name="ln1778">  update_view(dr);</a>
<a name="ln1779">}</a>
<a name="ln1780"> </a>
<a name="ln1781">int position()</a>
<a name="ln1782">{</a>
<a name="ln1783">  return 400;</a>
<a name="ln1784">}</a>
<a name="ln1785"> </a>
<a name="ln1786">static gboolean entry_focus_in_callback(GtkWidget *w, GdkEventFocus *event, dt_lib_collect_rule_t *d)</a>
<a name="ln1787">{</a>
<a name="ln1788">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1789">  if(c-&gt;active_rule != d-&gt;num)</a>
<a name="ln1790">  {</a>
<a name="ln1791">    c-&gt;active_rule = d-&gt;num;</a>
<a name="ln1792">    update_view(c-&gt;rule + c-&gt;active_rule);</a>
<a name="ln1793">  }</a>
<a name="ln1794"> </a>
<a name="ln1795">  return FALSE;</a>
<a name="ln1796">}</a>
<a name="ln1797"> </a>
<a name="ln1798">static void menuitem_mode(GtkMenuItem *menuitem, dt_lib_collect_rule_t *d)</a>
<a name="ln1799">{</a>
<a name="ln1800">  // add next row with and operator</a>
<a name="ln1801">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1802">  const int active = CLAMP(_a, 1, MAX_RULES);</a>
<a name="ln1803">  if(active &lt; MAX_RULES)</a>
<a name="ln1804">  {</a>
<a name="ln1805">    char confname[200] = { 0 };</a>
<a name="ln1806">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, active);</a>
<a name="ln1807">    const dt_lib_collect_mode_t mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(menuitem), &quot;menuitem_mode&quot;));</a>
<a name="ln1808">    dt_conf_set_int(confname, mode);</a>
<a name="ln1809">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, active);</a>
<a name="ln1810">    dt_conf_set_string(confname, &quot;&quot;);</a>
<a name="ln1811">    dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, active + 1);</a>
<a name="ln1812">    dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1813">    c-&gt;active_rule = active;</a>
<a name="ln1814">    c-&gt;view_rule = -1;</a>
<a name="ln1815">  }</a>
<a name="ln1816">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1817">}</a>
<a name="ln1818"> </a>
<a name="ln1819">static void menuitem_mode_change(GtkMenuItem *menuitem, dt_lib_collect_rule_t *d)</a>
<a name="ln1820">{</a>
<a name="ln1821">  // add next row with and operator</a>
<a name="ln1822">  const int num = d-&gt;num + 1;</a>
<a name="ln1823">  if(num &lt; MAX_RULES &amp;&amp; num &gt; 0)</a>
<a name="ln1824">  {</a>
<a name="ln1825">    char confname[200] = { 0 };</a>
<a name="ln1826">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, num);</a>
<a name="ln1827">    const dt_lib_collect_mode_t mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(menuitem), &quot;menuitem_mode&quot;));</a>
<a name="ln1828">    dt_conf_set_int(confname, mode);</a>
<a name="ln1829">  }</a>
<a name="ln1830">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1831">  c-&gt;view_rule = -1;</a>
<a name="ln1832">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1833">}</a>
<a name="ln1834"> </a>
<a name="ln1835">static void collection_updated(gpointer instance, gpointer self)</a>
<a name="ln1836">{</a>
<a name="ln1837">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1838">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1839"> </a>
<a name="ln1840">  // update tree</a>
<a name="ln1841">  d-&gt;view_rule = -1;</a>
<a name="ln1842">  d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1843">  _lib_collect_gui_update(self);</a>
<a name="ln1844">}</a>
<a name="ln1845"> </a>
<a name="ln1846"> </a>
<a name="ln1847">static void filmrolls_updated(gpointer instance, gpointer self)</a>
<a name="ln1848">{</a>
<a name="ln1849">  // TODO: We should update the count of images here</a>
<a name="ln1850">  _lib_collect_gui_update(self);</a>
<a name="ln1851">}</a>
<a name="ln1852"> </a>
<a name="ln1853">static void filmrolls_imported(gpointer instance, int film_id, gpointer self)</a>
<a name="ln1854">{</a>
<a name="ln1855">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1856">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1857"> </a>
<a name="ln1858">  // update tree</a>
<a name="ln1859">  d-&gt;view_rule = -1;</a>
<a name="ln1860">  d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1861">  _lib_collect_gui_update(self);</a>
<a name="ln1862">}</a>
<a name="ln1863"> </a>
<a name="ln1864">static void filmrolls_removed(gpointer instance, gpointer self)</a>
<a name="ln1865">{</a>
<a name="ln1866">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1867">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1868"> </a>
<a name="ln1869">  // update tree</a>
<a name="ln1870">  if (d-&gt;view_rule != DT_COLLECTION_PROP_FOLDERS)</a>
<a name="ln1871">  {</a>
<a name="ln1872">    d-&gt;view_rule = -1;</a>
<a name="ln1873">  }</a>
<a name="ln1874">  d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1875">  _lib_collect_gui_update(self);</a>
<a name="ln1876">}</a>
<a name="ln1877"> </a>
<a name="ln1878">static void tag_changed(gpointer instance, gpointer self)</a>
<a name="ln1879">{</a>
<a name="ln1880">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1881">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1882"> </a>
<a name="ln1883">  // update tree</a>
<a name="ln1884">  if(gtk_combo_box_get_active(GTK_COMBO_BOX(d-&gt;rule[d-&gt;active_rule].combo)) == DT_COLLECTION_PROP_TAG)</a>
<a name="ln1885">  {</a>
<a name="ln1886">    d-&gt;view_rule = -1;</a>
<a name="ln1887">    d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1888">    _lib_collect_gui_update(self);</a>
<a name="ln1889">  }</a>
<a name="ln1890">}</a>
<a name="ln1891"> </a>
<a name="ln1892">static void menuitem_clear(GtkMenuItem *menuitem, dt_lib_collect_rule_t *d)</a>
<a name="ln1893">{</a>
<a name="ln1894">  // remove this row, or if 1st, clear text entry box</a>
<a name="ln1895">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1896">  const int active = CLAMP(_a, 1, MAX_RULES);</a>
<a name="ln1897">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1898">  if(active &gt; 1)</a>
<a name="ln1899">  {</a>
<a name="ln1900">    dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, active - 1);</a>
<a name="ln1901">    if(c-&gt;active_rule &gt;= active - 1) c-&gt;active_rule = active - 2;</a>
<a name="ln1902">  }</a>
<a name="ln1903">  else</a>
<a name="ln1904">  {</a>
<a name="ln1905">    dt_conf_set_int(&quot;plugins/lighttable/collect/mode0&quot;, DT_LIB_COLLECT_MODE_AND);</a>
<a name="ln1906">    dt_conf_set_int(&quot;plugins/lighttable/collect/item0&quot;, 0);</a>
<a name="ln1907">    dt_conf_set_string(&quot;plugins/lighttable/collect/string0&quot;, &quot;&quot;);</a>
<a name="ln1908">    d-&gt;typing = FALSE;</a>
<a name="ln1909">  }</a>
<a name="ln1910">  // move up all still active rules by one.</a>
<a name="ln1911">  for(int i = d-&gt;num; i &lt; MAX_RULES - 1; i++)</a>
<a name="ln1912">  {</a>
<a name="ln1913">    char confname[200] = { 0 };</a>
<a name="ln1914">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i + 1);</a>
<a name="ln1915">    const int mode = dt_conf_get_int(confname);</a>
<a name="ln1916">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i + 1);</a>
<a name="ln1917">    const int item = dt_conf_get_int(confname);</a>
<a name="ln1918">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i + 1);</a>
<a name="ln1919">    gchar *string = dt_conf_get_string(confname);</a>
<a name="ln1920">    if(string)</a>
<a name="ln1921">    {</a>
<a name="ln1922">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln1923">      dt_conf_set_int(confname, mode);</a>
<a name="ln1924">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln1925">      dt_conf_set_int(confname, item);</a>
<a name="ln1926">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln1927">      dt_conf_set_string(confname, string);</a>
<a name="ln1928">      g_free(string);</a>
<a name="ln1929">    }</a>
<a name="ln1930">  }</a>
<a name="ln1931"> </a>
<a name="ln1932">  c-&gt;view_rule = -1;</a>
<a name="ln1933">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1934">}</a>
<a name="ln1935"> </a>
<a name="ln1936">static gboolean popup_button_callback(GtkWidget *widget, GdkEventButton *event, dt_lib_collect_rule_t *d)</a>
<a name="ln1937">{</a>
<a name="ln1938">  if(event-&gt;button != 1) return FALSE;</a>
<a name="ln1939"> </a>
<a name="ln1940">  GtkWidget *menu = gtk_menu_new();</a>
<a name="ln1941">  GtkWidget *mi;</a>
<a name="ln1942">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1943">  const int active = CLAMP(_a, 1, MAX_RULES);</a>
<a name="ln1944"> </a>
<a name="ln1945">  mi = gtk_menu_item_new_with_label(_(&quot;clear this rule&quot;));</a>
<a name="ln1946">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1947">  g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_clear), d);</a>
<a name="ln1948"> </a>
<a name="ln1949">  if(d-&gt;num == active - 1)</a>
<a name="ln1950">  {</a>
<a name="ln1951">    mi = gtk_menu_item_new_with_label(_(&quot;narrow down search&quot;));</a>
<a name="ln1952">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND));</a>
<a name="ln1953">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1954">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode), d);</a>
<a name="ln1955"> </a>
<a name="ln1956">    mi = gtk_menu_item_new_with_label(_(&quot;add more images&quot;));</a>
<a name="ln1957">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_OR));</a>
<a name="ln1958">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1959">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode), d);</a>
<a name="ln1960"> </a>
<a name="ln1961">    mi = gtk_menu_item_new_with_label(_(&quot;exclude images&quot;));</a>
<a name="ln1962">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND_NOT));</a>
<a name="ln1963">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1964">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode), d);</a>
<a name="ln1965">  }</a>
<a name="ln1966">  else if(d-&gt;num &lt; active - 1)</a>
<a name="ln1967">  {</a>
<a name="ln1968">    mi = gtk_menu_item_new_with_label(_(&quot;change to: and&quot;));</a>
<a name="ln1969">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND));</a>
<a name="ln1970">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1971">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode_change), d);</a>
<a name="ln1972"> </a>
<a name="ln1973">    mi = gtk_menu_item_new_with_label(_(&quot;change to: or&quot;));</a>
<a name="ln1974">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_OR));</a>
<a name="ln1975">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1976">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode_change), d);</a>
<a name="ln1977"> </a>
<a name="ln1978">    mi = gtk_menu_item_new_with_label(_(&quot;change to: except&quot;));</a>
<a name="ln1979">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND_NOT));</a>
<a name="ln1980">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1981">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode_change), d);</a>
<a name="ln1982">  }</a>
<a name="ln1983"> </a>
<a name="ln1984">  gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln1985"> </a>
<a name="ln1986">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln1987">  gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln1988">#else</a>
<a name="ln1989">  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, event-&gt;button, event-&gt;time);</a>
<a name="ln1990">#endif</a>
<a name="ln1991"> </a>
<a name="ln1992">  return TRUE;</a>
<a name="ln1993">}</a>
<a name="ln1994"> </a>
<a name="ln1995">static void view_set_click(gpointer instance, gpointer user_data)</a>
<a name="ln1996">{</a>
<a name="ln1997">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1998">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln1999">  d-&gt;singleclick = dt_conf_get_bool(&quot;plugins/lighttable/collect/single-click&quot;);</a>
<a name="ln2000">}</a>
<a name="ln2001"> </a>
<a name="ln2002">void gui_init(dt_lib_module_t *self)</a>
<a name="ln2003">{</a>
<a name="ln2004">  dt_lib_collect_t *d = (dt_lib_collect_t *)calloc(1, sizeof(dt_lib_collect_t));</a>
<a name="ln2005"> </a>
<a name="ln2006">  self-&gt;data = (void *)d;</a>
<a name="ln2007">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln2008">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln2009"> </a>
<a name="ln2010">  d-&gt;active_rule = 0;</a>
<a name="ln2011">  d-&gt;nb_rules = 0;</a>
<a name="ln2012">  d-&gt;params = (dt_lib_collect_params_t *)malloc(sizeof(dt_lib_collect_params_t));</a>
<a name="ln2013">  view_set_click(NULL, self);</a>
<a name="ln2014"> </a>
<a name="ln2015">  GtkBox *box;</a>
<a name="ln2016">  GtkWidget *w;</a>
<a name="ln2017"> </a>
<a name="ln2018">  for(int i = 0; i &lt; MAX_RULES; i++)</a>
<a name="ln2019">  {</a>
<a name="ln2020">    d-&gt;rule[i].num = i;</a>
<a name="ln2021">    d-&gt;rule[i].typing = FALSE;</a>
<a name="ln2022">    box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5));</a>
<a name="ln2023">    d-&gt;rule[i].hbox = GTK_WIDGET(box);</a>
<a name="ln2024">    gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(box), TRUE, TRUE, 0);</a>
<a name="ln2025">    w = gtk_combo_box_text_new();</a>
<a name="ln2026">    d-&gt;rule[i].combo = GTK_COMBO_BOX(w);</a>
<a name="ln2027">    for(int k = 0; k &lt; dt_lib_collect_string_cnt; k++)</a>
<a name="ln2028">      gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(w), _(dt_lib_collect_string[k]));</a>
<a name="ln2029">    g_signal_connect(G_OBJECT(w), &quot;changed&quot;, G_CALLBACK(combo_changed), d-&gt;rule + i);</a>
<a name="ln2030">    gtk_box_pack_start(box, w, FALSE, FALSE, 0);</a>
<a name="ln2031"> </a>
<a name="ln2032">    w = gtk_entry_new();</a>
<a name="ln2033">    d-&gt;rule[i].text = w;</a>
<a name="ln2034">    dt_gui_key_accel_block_on_focus_connect(d-&gt;rule[i].text);</a>
<a name="ln2035">    gtk_widget_add_events(w, GDK_FOCUS_CHANGE_MASK);</a>
<a name="ln2036">    g_signal_connect(G_OBJECT(w), &quot;focus-in-event&quot;, G_CALLBACK(entry_focus_in_callback), d-&gt;rule + i);</a>
<a name="ln2037"> </a>
<a name="ln2038">    /* xgettext:no-c-format */</a>
<a name="ln2039">    gtk_widget_set_tooltip_text(w, _(&quot;type your query, use `%' as wildcard&quot;));</a>
<a name="ln2040">    gtk_widget_add_events(w, GDK_KEY_PRESS_MASK);</a>
<a name="ln2041">    g_signal_connect(G_OBJECT(w), &quot;insert-text&quot;, G_CALLBACK(entry_insert_text), d-&gt;rule + i);</a>
<a name="ln2042">    g_signal_connect(G_OBJECT(w), &quot;changed&quot;, G_CALLBACK(entry_changed), d-&gt;rule + i);</a>
<a name="ln2043">    g_signal_connect(G_OBJECT(w), &quot;activate&quot;, G_CALLBACK(entry_activated), d-&gt;rule + i);</a>
<a name="ln2044">    gtk_box_pack_start(box, w, TRUE, TRUE, 0);</a>
<a name="ln2045">    gtk_entry_set_width_chars(GTK_ENTRY(w), 0);</a>
<a name="ln2046"> </a>
<a name="ln2047">    w = dtgtk_button_new(dtgtk_cairo_paint_presets, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2048">    d-&gt;rule[i].button = w;</a>
<a name="ln2049">    gtk_widget_set_events(w, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln2050">    g_signal_connect(G_OBJECT(w), &quot;button-press-event&quot;, G_CALLBACK(popup_button_callback), d-&gt;rule + i);</a>
<a name="ln2051">    gtk_box_pack_start(box, w, FALSE, FALSE, 0);</a>
<a name="ln2052">    gtk_widget_set_size_request(w, DT_PIXEL_APPLY_DPI(13), DT_PIXEL_APPLY_DPI(13));</a>
<a name="ln2053">  }</a>
<a name="ln2054"> </a>
<a name="ln2055">  GtkWidget *sw = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln2056">  d-&gt;scrolledwindow = GTK_SCROLLED_WINDOW(sw);</a>
<a name="ln2057">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln2058">  gtk_scrolled_window_set_min_content_height(GTK_SCROLLED_WINDOW(d-&gt;scrolledwindow), DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln2059">  GtkTreeView *view = GTK_TREE_VIEW(gtk_tree_view_new());</a>
<a name="ln2060">  d-&gt;view_rule = -1;</a>
<a name="ln2061">  d-&gt;view = view;</a>
<a name="ln2062">  gtk_tree_view_set_headers_visible(view, FALSE);</a>
<a name="ln2063">  gtk_container_add(GTK_CONTAINER(sw), GTK_WIDGET(view));</a>
<a name="ln2064">  g_signal_connect(G_OBJECT(view), &quot;button-press-event&quot;, G_CALLBACK(view_onButtonPressed), d);</a>
<a name="ln2065">  g_signal_connect(G_OBJECT(view), &quot;popup-menu&quot;, G_CALLBACK(view_onPopupMenu), d);</a>
<a name="ln2066"> </a>
<a name="ln2067">  GtkTreeViewColumn *col = gtk_tree_view_column_new();</a>
<a name="ln2068">  gtk_tree_view_append_column(view, col);</a>
<a name="ln2069">  GtkCellRenderer *renderer = gtk_cell_renderer_text_new();</a>
<a name="ln2070">  gtk_tree_view_column_pack_start(col, renderer, TRUE);</a>
<a name="ln2071">  gtk_tree_view_column_set_cell_data_func(col, renderer, tree_count_show, NULL, NULL);</a>
<a name="ln2072">  g_object_set(renderer, &quot;strikethrough&quot;, TRUE, (gchar *)0);</a>
<a name="ln2073">  gtk_tree_view_column_add_attribute(col, renderer, &quot;strikethrough-set&quot;, DT_LIB_COLLECT_COL_UNREACHABLE);</a>
<a name="ln2074"> </a>
<a name="ln2075">  GtkTreeModel *listmodel</a>
<a name="ln2076">      = GTK_TREE_MODEL(gtk_list_store_new(DT_LIB_COLLECT_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING,</a>
<a name="ln2077">                                          G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_UINT));</a>
<a name="ln2078">  d-&gt;listfilter = gtk_tree_model_filter_new(listmodel, NULL);</a>
<a name="ln2079">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(d-&gt;listfilter), DT_LIB_COLLECT_COL_VISIBLE);</a>
<a name="ln2080"> </a>
<a name="ln2081">  GtkTreeModel *treemodel</a>
<a name="ln2082">      = GTK_TREE_MODEL(gtk_tree_store_new(DT_LIB_COLLECT_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING,</a>
<a name="ln2083">                                          G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_UINT));</a>
<a name="ln2084">  d-&gt;treefilter = gtk_tree_model_filter_new(treemodel, NULL);</a>
<a name="ln2085">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(d-&gt;treefilter), DT_LIB_COLLECT_COL_VISIBLE);</a>
<a name="ln2086">  g_object_unref(treemodel);</a>
<a name="ln2087"> </a>
<a name="ln2088">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(sw), TRUE, TRUE, 0);</a>
<a name="ln2089"> </a>
<a name="ln2090">  GtkWidget *sw2 = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln2091">  d-&gt;sw2 = GTK_SCROLLED_WINDOW(sw2);</a>
<a name="ln2092">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw2), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln2093">  gtk_scrolled_window_set_min_content_height(GTK_SCROLLED_WINDOW(sw2), DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln2094"> </a>
<a name="ln2095">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(sw2), TRUE, TRUE, 0);</a>
<a name="ln2096"> </a>
<a name="ln2097">  /* setup proxy */</a>
<a name="ln2098">  darktable.view_manager-&gt;proxy.module_collect.module = self;</a>
<a name="ln2099">  darktable.view_manager-&gt;proxy.module_collect.update = _lib_collect_gui_update;</a>
<a name="ln2100"> </a>
<a name="ln2101">  _lib_collect_gui_update(self);</a>
<a name="ln2102"> </a>
<a name="ln2103">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED, G_CALLBACK(collection_updated),</a>
<a name="ln2104">                            self);</a>
<a name="ln2105"> </a>
<a name="ln2106">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED, G_CALLBACK(filmrolls_updated),</a>
<a name="ln2107">                            self);</a>
<a name="ln2108"> </a>
<a name="ln2109">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_IMPORTED, G_CALLBACK(filmrolls_imported),</a>
<a name="ln2110">                            self);</a>
<a name="ln2111"> </a>
<a name="ln2112">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_REMOVED, G_CALLBACK(filmrolls_removed),</a>
<a name="ln2113">                            self);</a>
<a name="ln2114"> </a>
<a name="ln2115">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_TAG_CHANGED, G_CALLBACK(tag_changed),</a>
<a name="ln2116">                            self);</a>
<a name="ln2117"> </a>
<a name="ln2118">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_PREFERENCES_CHANGE, G_CALLBACK(view_set_click), self);</a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln2122">{</a>
<a name="ln2123">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln2124"> </a>
<a name="ln2125">  for(int i = 0; i &lt; MAX_RULES; i++) dt_gui_key_accel_block_on_focus_disconnect(d-&gt;rule[i].text);</a>
<a name="ln2126"> </a>
<a name="ln2127">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(collection_updated), self);</a>
<a name="ln2128">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(filmrolls_updated), self);</a>
<a name="ln2129">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(filmrolls_imported), self);</a>
<a name="ln2130">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(filmrolls_removed), self);</a>
<a name="ln2131">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(tag_changed), self);</a>
<a name="ln2132">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(view_set_click), self);</a>
<a name="ln2133">  darktable.view_manager-&gt;proxy.module_collect.module = NULL;</a>
<a name="ln2134">  free(d-&gt;params);</a>
<a name="ln2135"> </a>
<a name="ln2136">  /* cleanup mem */</a>
<a name="ln2137"> </a>
<a name="ln2138">  g_object_unref(d-&gt;treefilter);</a>
<a name="ln2139">  g_object_unref(d-&gt;listfilter);</a>
<a name="ln2140"> </a>
<a name="ln2141">  /* TODO: Make sure we are cleaning up all allocations */</a>
<a name="ln2142"> </a>
<a name="ln2143">  free(self-&gt;data);</a>
<a name="ln2144">  self-&gt;data = NULL;</a>
<a name="ln2145">}</a>
<a name="ln2146"> </a>
<a name="ln2147"> </a>
<a name="ln2148">#ifdef USE_LUA</a>
<a name="ln2149">static int new_rule_cb(lua_State*L)</a>
<a name="ln2150">{</a>
<a name="ln2151">  dt_lib_collect_params_rule_t rule;</a>
<a name="ln2152">  memset(&amp;rule,0, sizeof(dt_lib_collect_params_rule_t));</a>
<a name="ln2153">  luaA_push(L,dt_lib_collect_params_rule_t,&amp;rule);</a>
<a name="ln2154">  return 1;</a>
<a name="ln2155">}</a>
<a name="ln2156">static int filter_cb(lua_State *L)</a>
<a name="ln2157">{</a>
<a name="ln2158">  dt_lib_module_t *self = lua_touserdata(L, lua_upvalueindex(1));</a>
<a name="ln2159"> </a>
<a name="ln2160">  int size;</a>
<a name="ln2161">  dt_lib_collect_params_t *p = get_params(self,&amp;size);</a>
<a name="ln2162">  // put it in stack so memory is not lost if a lua exception is raised</a>
<a name="ln2163"> </a>
<a name="ln2164"> </a>
<a name="ln2165"> </a>
<a name="ln2166">  if(lua_gettop(L) &gt; 0) {</a>
<a name="ln2167">    luaL_checktype(L,1,LUA_TTABLE);</a>
<a name="ln2168">    dt_lib_collect_params_t *new_p = get_params(self,&amp;size);</a>
<a name="ln2169">    new_p-&gt;rules = 0;</a>
<a name="ln2170">    do {</a>
<a name="ln2171">      lua_pushinteger(L,new_p-&gt;rules + 1);</a>
<a name="ln2172">      lua_gettable(L,1);</a>
<a name="ln2173">      if(lua_isnil(L,-1)) break;</a>
<a name="ln2174">      luaA_to(L,dt_lib_collect_params_rule_t,&amp;new_p-&gt;rule[new_p-&gt;rules],-1);</a>
<a name="ln2175">      new_p-&gt;rules++;</a>
<a name="ln2176">    }while(new_p-&gt;rules &lt; MAX_RULES);</a>
<a name="ln2177">    if(new_p-&gt;rules == MAX_RULES) {</a>
<a name="ln2178">      lua_pushinteger(L,new_p-&gt;rules + 1);</a>
<a name="ln2179">      lua_gettable(L,1);</a>
<a name="ln2180">      if(!lua_isnil(L,-1)) {</a>
<a name="ln2181">        luaL_error(L,&quot;Number of rules given excedes max allowed (%d)&quot;,MAX_RULES);</a>
<a name="ln2182">      }</a>
<a name="ln2183">    }</a>
<a name="ln2184">    set_params(self,new_p,size);</a>
<a name="ln2185">    free(new_p);</a>
<a name="ln2186"> </a>
<a name="ln2187">  }</a>
<a name="ln2188">  lua_newtable(L);</a>
<a name="ln2189">  for(int i = 0; i &lt; p-&gt;rules; i++) {</a>
<a name="ln2190">    luaA_push(L,dt_lib_collect_params_rule_t,&amp;p-&gt;rule[i]);</a>
<a name="ln2191">    luaL_ref(L,-2);</a>
<a name="ln2192">  }</a>
<a name="ln2193">  free(p);</a>
<a name="ln2194">  return 1;</a>
<a name="ln2195">}</a>
<a name="ln2196"> </a>
<a name="ln2197">static int mode_member(lua_State *L)</a>
<a name="ln2198">{</a>
<a name="ln2199">  dt_lib_collect_params_rule_t *rule = luaL_checkudata(L,1,&quot;dt_lib_collect_params_rule_t&quot;);</a>
<a name="ln2200">  if(lua_gettop(L) &gt; 2) {</a>
<a name="ln2201">    dt_lib_collect_mode_t value;</a>
<a name="ln2202">    luaA_to(L,dt_lib_collect_mode_t,&amp;value,3);</a>
<a name="ln2203">    rule-&gt;mode = value;</a>
<a name="ln2204">    return 0;</a>
<a name="ln2205">  }</a>
<a name="ln2206">  const dt_lib_collect_mode_t tmp = rule-&gt;mode; // temp buffer because of bitfield in the original struct</a>
<a name="ln2207">  luaA_push(L,dt_lib_collect_mode_t,&amp;tmp);</a>
<a name="ln2208">  return 1;</a>
<a name="ln2209">}</a>
<a name="ln2210"> </a>
<a name="ln2211">static int item_member(lua_State *L)</a>
<a name="ln2212">{</a>
<a name="ln2213">  dt_lib_collect_params_rule_t *rule = luaL_checkudata(L,1,&quot;dt_lib_collect_params_rule_t&quot;);</a>
<a name="ln2214"> </a>
<a name="ln2215">  if(lua_gettop(L) &gt; 2) {</a>
<a name="ln2216">    dt_collection_properties_t value;</a>
<a name="ln2217">    luaA_to(L,dt_collection_properties_t,&amp;value,3);</a>
<a name="ln2218">    rule-&gt;item = value;</a>
<a name="ln2219">    return 0;</a>
<a name="ln2220">  }</a>
<a name="ln2221">  const dt_collection_properties_t tmp = rule-&gt;item; // temp buffer because of bitfield in the original struct</a>
<a name="ln2222">  luaA_push(L,dt_collection_properties_t,&amp;tmp);</a>
<a name="ln2223">  return 1;</a>
<a name="ln2224">}</a>
<a name="ln2225"> </a>
<a name="ln2226">static int data_member(lua_State *L)</a>
<a name="ln2227">{</a>
<a name="ln2228">  dt_lib_collect_params_rule_t *rule = luaL_checkudata(L,1,&quot;dt_lib_collect_params_rule_t&quot;);</a>
<a name="ln2229"> </a>
<a name="ln2230">  if(lua_gettop(L) &gt; 2) {</a>
<a name="ln2231">    size_t tgt_size;</a>
<a name="ln2232">    const char*data = luaL_checklstring(L,3,&amp;tgt_size);</a>
<a name="ln2233">    if(tgt_size &gt; PARAM_STRING_SIZE)</a>
<a name="ln2234">    {</a>
<a name="ln2235">      return luaL_error(L, &quot;string '%s' too long (max is %d)&quot;, data, PARAM_STRING_SIZE);</a>
<a name="ln2236">    }</a>
<a name="ln2237">    g_strlcpy(rule-&gt;string, data, sizeof(rule-&gt;string));</a>
<a name="ln2238">    return 0;</a>
<a name="ln2239">  }</a>
<a name="ln2240">  lua_pushstring(L,rule-&gt;string);</a>
<a name="ln2241">  return 1;</a>
<a name="ln2242">}</a>
<a name="ln2243"> </a>
<a name="ln2244"> </a>
<a name="ln2245"> </a>
<a name="ln2246">void init(struct dt_lib_module_t *self)</a>
<a name="ln2247">{</a>
<a name="ln2248"> </a>
<a name="ln2249">  lua_State *L = darktable.lua_state.state;</a>
<a name="ln2250">  int my_type = dt_lua_module_entry_get_type(L, &quot;lib&quot;, self-&gt;plugin_name);</a>
<a name="ln2251">  lua_pushlightuserdata(L, self);</a>
<a name="ln2252">  lua_pushcclosure(L, filter_cb,1);</a>
<a name="ln2253">  dt_lua_gtk_wrap(L);</a>
<a name="ln2254">  lua_pushcclosure(L, dt_lua_type_member_common, 1);</a>
<a name="ln2255">  dt_lua_type_register_const_type(L, my_type, &quot;filter&quot;);</a>
<a name="ln2256">  lua_pushcfunction(L, new_rule_cb);</a>
<a name="ln2257">  lua_pushcclosure(L, dt_lua_type_member_common, 1);</a>
<a name="ln2258">  dt_lua_type_register_const_type(L, my_type, &quot;new_rule&quot;);</a>
<a name="ln2259"> </a>
<a name="ln2260">  dt_lua_init_type(L,dt_lib_collect_params_rule_t);</a>
<a name="ln2261">  lua_pushcfunction(L,mode_member);</a>
<a name="ln2262">  dt_lua_type_register(L, dt_lib_collect_params_rule_t, &quot;mode&quot;);</a>
<a name="ln2263">  lua_pushcfunction(L,item_member);</a>
<a name="ln2264">  dt_lua_type_register(L, dt_lib_collect_params_rule_t, &quot;item&quot;);</a>
<a name="ln2265">  lua_pushcfunction(L,data_member);</a>
<a name="ln2266">  dt_lua_type_register(L, dt_lib_collect_params_rule_t, &quot;data&quot;);</a>
<a name="ln2267"> </a>
<a name="ln2268"> </a>
<a name="ln2269">  luaA_enum(L,dt_lib_collect_mode_t);</a>
<a name="ln2270">  luaA_enum_value(L,dt_lib_collect_mode_t,DT_LIB_COLLECT_MODE_AND);</a>
<a name="ln2271">  luaA_enum_value(L,dt_lib_collect_mode_t,DT_LIB_COLLECT_MODE_OR);</a>
<a name="ln2272">  luaA_enum_value(L,dt_lib_collect_mode_t,DT_LIB_COLLECT_MODE_AND_NOT);</a>
<a name="ln2273"> </a>
<a name="ln2274">  luaA_enum(L,dt_collection_properties_t);</a>
<a name="ln2275">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FILMROLL);</a>
<a name="ln2276">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FOLDERS);</a>
<a name="ln2277">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_CAMERA);</a>
<a name="ln2278">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_TAG);</a>
<a name="ln2279">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_DAY);</a>
<a name="ln2280">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_TIME);</a>
<a name="ln2281">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_HISTORY);</a>
<a name="ln2282">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_COLORLABEL);</a>
<a name="ln2283">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_TITLE);</a>
<a name="ln2284">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_DESCRIPTION);</a>
<a name="ln2285">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_CREATOR);</a>
<a name="ln2286">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_PUBLISHER);</a>
<a name="ln2287">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_RIGHTS);</a>
<a name="ln2288">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_LENS);</a>
<a name="ln2289">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FOCAL_LENGTH);</a>
<a name="ln2290">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_ISO);</a>
<a name="ln2291">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_APERTURE);</a>
<a name="ln2292">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_ASPECT_RATIO);</a>
<a name="ln2293">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_EXPOSURE);</a>
<a name="ln2294">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FILENAME);</a>
<a name="ln2295">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_GEOTAGGING);</a>
<a name="ln2296">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_LOCAL_COPY);</a>
<a name="ln2297">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_GROUPING);</a>
<a name="ln2298"> </a>
<a name="ln2299">}</a>
<a name="ln2300">#endif</a>
<a name="ln2301">#undef MAX_RULES</a>
<a name="ln2302">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2303">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2304">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="166"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 166, 165.</p></div>
<div class="balloon" rel="326"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="780"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'gtk_tree_model_iter_parent' function: 'child' and 'iter'.</p></div>
<div class="balloon" rel="794"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: level > 0.</p></div>
<div class="balloon" rel="796"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'gtk_tree_model_iter_parent' function: 'child' and 'iter'.</p></div>
<div class="balloon" rel="794"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v571/" target="_blank">V571</a> Recurring check. The 'level > 0' condition was already verified in line 792.</p></div>
<div class="balloon" rel="848"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'result'. Check lines: 848, 846.</p></div>
<div class="balloon" rel="995"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'tuple'. Check lines: 995, 994.</p></div>
<div class="balloon" rel="1171"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'range'. Check lines: 1171, 1169.</p></div>
<div class="balloon" rel="1471"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'range'. Check lines: 1471, 1470.</p></div>
<div class="balloon" rel="2010"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 2010, 2004.</p></div>
<div class="balloon" rel="2169"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'new_p'.</p></div>
<div class="balloon" rel="2189"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'p'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
