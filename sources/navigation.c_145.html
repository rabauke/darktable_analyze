
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/debug.h&quot;</a>
<a name="ln22">#include &quot;common/image_cache.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;develop/develop.h&quot;</a>
<a name="ln26">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln27">#include &quot;gui/gtk.h&quot;</a>
<a name="ln28">#include &quot;libs/lib.h&quot;</a>
<a name="ln29">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">DT_MODULE(1)</a>
<a name="ln32"> </a>
<a name="ln33">#define DT_NAVIGATION_INSET 5</a>
<a name="ln34"> </a>
<a name="ln35">typedef struct dt_lib_navigation_t</a>
<a name="ln36">{</a>
<a name="ln37">  int dragging;</a>
<a name="ln38">  int zoom_w, zoom_h;</a>
<a name="ln39">  unsigned char* buffer;</a>
<a name="ln40">  int wd;</a>
<a name="ln41">  int ht;</a>
<a name="ln42">  int timestamp;</a>
<a name="ln43">} dt_lib_navigation_t;</a>
<a name="ln44"> </a>
<a name="ln45"> </a>
<a name="ln46">/* expose function for navigation module */</a>
<a name="ln47">static gboolean _lib_navigation_draw_callback(GtkWidget *widget, cairo_t *crf, gpointer user_data);</a>
<a name="ln48">/* motion notify callback handler*/</a>
<a name="ln49">static gboolean _lib_navigation_motion_notify_callback(GtkWidget *widget, GdkEventMotion *event,</a>
<a name="ln50">                                                       gpointer user_data);</a>
<a name="ln51">/* button press callback */</a>
<a name="ln52">static gboolean _lib_navigation_button_press_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln53">                                                      gpointer user_data);</a>
<a name="ln54">/* button release callback */</a>
<a name="ln55">static gboolean _lib_navigation_button_release_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln56">                                                        gpointer user_data);</a>
<a name="ln57">/* leave notify callback */</a>
<a name="ln58">static gboolean _lib_navigation_leave_notify_callback(GtkWidget *widget, GdkEventCrossing *event,</a>
<a name="ln59">                                                      gpointer user_data);</a>
<a name="ln60"> </a>
<a name="ln61">/* helper function for position set */</a>
<a name="ln62">static void _lib_navigation_set_position(struct dt_lib_module_t *self, double x, double y, int wd, int ht);</a>
<a name="ln63"> </a>
<a name="ln64">const char *name(dt_lib_module_t *self)</a>
<a name="ln65">{</a>
<a name="ln66">  return _(&quot;navigation&quot;);</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">const char **views(dt_lib_module_t *self)</a>
<a name="ln70">{</a>
<a name="ln71">  static const char *v[] = {&quot;darkroom&quot;, NULL};</a>
<a name="ln72">  return v;</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln76">{</a>
<a name="ln77">  return DT_UI_CONTAINER_PANEL_LEFT_TOP;</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">int expandable(dt_lib_module_t *self)</a>
<a name="ln81">{</a>
<a name="ln82">  return 0;</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85">int position()</a>
<a name="ln86">{</a>
<a name="ln87">  return 1001;</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">static void _lib_navigation_control_redraw_callback(gpointer instance, gpointer user_data)</a>
<a name="ln92">{</a>
<a name="ln93">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln94">  dt_control_queue_redraw_widget(self-&gt;widget);</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">static gboolean _lib_navigation_collapse_callback(GtkAccelGroup *accel_group,</a>
<a name="ln99">                                                GObject *acceleratable, guint keyval,</a>
<a name="ln100">                                                GdkModifierType modifier, gpointer data)</a>
<a name="ln101">{</a>
<a name="ln102">  dt_lib_module_t *self = (dt_lib_module_t *)data;</a>
<a name="ln103"> </a>
<a name="ln104">  // Get the state</a>
<a name="ln105">  const gboolean visible = dt_lib_is_visible(self);</a>
<a name="ln106"> </a>
<a name="ln107">  // Inverse the visibility</a>
<a name="ln108">  dt_lib_set_visible(self, !visible);</a>
<a name="ln109"> </a>
<a name="ln110">  return TRUE;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113"> </a>
<a name="ln114">void gui_init(dt_lib_module_t *self)</a>
<a name="ln115">{</a>
<a name="ln116">  /* initialize ui widgets */</a>
<a name="ln117">  dt_lib_navigation_t *d = (dt_lib_navigation_t *)g_malloc0(sizeof(dt_lib_navigation_t));</a>
<a name="ln118">  self-&gt;data = (void *)d;</a>
<a name="ln119"> </a>
<a name="ln120">  d-&gt;buffer = NULL;</a>
<a name="ln121">  d-&gt;wd = -1;</a>
<a name="ln122">  d-&gt;ht = -1;</a>
<a name="ln123">  d-&gt;timestamp = -1;</a>
<a name="ln124"> </a>
<a name="ln125">  /* create drawingarea */</a>
<a name="ln126">  self-&gt;widget = gtk_drawing_area_new();</a>
<a name="ln127">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln128">  gtk_widget_set_events(self-&gt;widget, GDK_EXPOSURE_MASK | GDK_POINTER_MOTION_MASK</a>
<a name="ln129">                                      | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK</a>
<a name="ln130">                                      | GDK_BUTTON_RELEASE_MASK | GDK_STRUCTURE_MASK);</a>
<a name="ln131"> </a>
<a name="ln132">  /* connect callbacks */</a>
<a name="ln133">  gtk_widget_set_app_paintable(self-&gt;widget, TRUE);</a>
<a name="ln134">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;draw&quot;, G_CALLBACK(_lib_navigation_draw_callback), self);</a>
<a name="ln135">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;button-press-event&quot;,</a>
<a name="ln136">                   G_CALLBACK(_lib_navigation_button_press_callback), self);</a>
<a name="ln137">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;button-release-event&quot;,</a>
<a name="ln138">                   G_CALLBACK(_lib_navigation_button_release_callback), self);</a>
<a name="ln139">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;motion-notify-event&quot;,</a>
<a name="ln140">                   G_CALLBACK(_lib_navigation_motion_notify_callback), self);</a>
<a name="ln141">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;leave-notify-event&quot;,</a>
<a name="ln142">                   G_CALLBACK(_lib_navigation_leave_notify_callback), self);</a>
<a name="ln143"> </a>
<a name="ln144">  /* set size of navigation draw area */</a>
<a name="ln145">  int panel_width = dt_conf_get_int(&quot;panel_width&quot;);</a>
<a name="ln146">  gtk_widget_set_size_request(self-&gt;widget, -1, panel_width * .5);</a>
<a name="ln147">  gtk_widget_set_name(GTK_WIDGET(self-&gt;widget), &quot;navigation-module&quot;);</a>
<a name="ln148"> </a>
<a name="ln149">  /* connect a redraw callback to control draw all and preview pipe finish signals */</a>
<a name="ln150">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_UI_PIPE_FINISHED,</a>
<a name="ln151">                            G_CALLBACK(_lib_navigation_control_redraw_callback), self);</a>
<a name="ln152">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_PREVIEW_PIPE_FINISHED,</a>
<a name="ln153">                            G_CALLBACK(_lib_navigation_control_redraw_callback), self);</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln157">{</a>
<a name="ln158">  /* disconnect from signal */</a>
<a name="ln159">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_navigation_control_redraw_callback), self);</a>
<a name="ln160"> </a>
<a name="ln161">  dt_lib_navigation_t *d = self-&gt;data;</a>
<a name="ln162">  g_free(d-&gt;buffer);</a>
<a name="ln163"> </a>
<a name="ln164">  g_free(self-&gt;data);</a>
<a name="ln165">  self-&gt;data = NULL;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168"> </a>
<a name="ln169"> </a>
<a name="ln170">static gboolean _lib_navigation_draw_callback(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln171">{</a>
<a name="ln172">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln173">  dt_lib_navigation_t *d = (dt_lib_navigation_t *)self-&gt;data;</a>
<a name="ln174"> </a>
<a name="ln175">  GtkAllocation allocation;</a>
<a name="ln176">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln177">  int width = allocation.width, height = allocation.height;</a>
<a name="ln178"> </a>
<a name="ln179">  dt_develop_t *dev = darktable.develop;</a>
<a name="ln180"> </a>
<a name="ln181">  /* double buffering of image data: only take new data if valid */</a>
<a name="ln182">  if(dev-&gt;preview_pipe-&gt;backbuf &amp;&amp; dev-&gt;preview_status == DT_DEV_PIXELPIPE_VALID)</a>
<a name="ln183">  {</a>
<a name="ln184">    /* re-allocate in case of changed image dimensions */</a>
<a name="ln185">    if(d-&gt;buffer == NULL || dev-&gt;preview_pipe-&gt;backbuf_width != d-&gt;wd || dev-&gt;preview_pipe-&gt;backbuf_height != d-&gt;ht)</a>
<a name="ln186">    {</a>
<a name="ln187">      g_free(d-&gt;buffer);</a>
<a name="ln188">      d-&gt;wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln189">      d-&gt;ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln190">      d-&gt;buffer = g_malloc0((size_t)d-&gt;wd * d-&gt;ht * 4 * sizeof(unsigned char));</a>
<a name="ln191">    }</a>
<a name="ln192"> </a>
<a name="ln193">    /* update buffer if new data is available */</a>
<a name="ln194">    if(d-&gt;buffer &amp;&amp; dev-&gt;preview_pipe-&gt;input_timestamp &gt; d-&gt;timestamp)</a>
<a name="ln195">    {</a>
<a name="ln196">      dt_pthread_mutex_t *mutex = &amp;dev-&gt;preview_pipe-&gt;backbuf_mutex;</a>
<a name="ln197">      dt_pthread_mutex_lock(mutex);</a>
<a name="ln198">      memcpy(d-&gt;buffer, dev-&gt;preview_pipe-&gt;backbuf, (size_t)d-&gt;wd * d-&gt;ht * 4 * sizeof(unsigned char));</a>
<a name="ln199">      d-&gt;timestamp = dev-&gt;preview_pipe-&gt;input_timestamp;</a>
<a name="ln200">      dt_pthread_mutex_unlock(mutex);</a>
<a name="ln201">    }</a>
<a name="ln202">  }</a>
<a name="ln203"> </a>
<a name="ln204">  /* get the current style */</a>
<a name="ln205">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln206">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln207"> </a>
<a name="ln208">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln209">  gtk_render_background(context, cr, 0, 0, allocation.width, allocation.height);</a>
<a name="ln210"> </a>
<a name="ln211">  /* draw navigation image if available */</a>
<a name="ln212">  if(d-&gt;buffer)</a>
<a name="ln213">  {</a>
<a name="ln214">    cairo_save(cr);</a>
<a name="ln215">    const int wd = d-&gt;wd;</a>
<a name="ln216">    const int ht = d-&gt;ht;</a>
<a name="ln217">    const float scale = fminf(width / (float)wd, height / (float)ht);</a>
<a name="ln218"> </a>
<a name="ln219">    const int stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, wd);</a>
<a name="ln220">    cairo_surface_t *surface</a>
<a name="ln221">        = cairo_image_surface_create_for_data(d-&gt;buffer, CAIRO_FORMAT_RGB24, wd, ht, stride);</a>
<a name="ln222">    cairo_translate(cr, width / 2.0, height / 2.0f);</a>
<a name="ln223">    cairo_scale(cr, scale, scale);</a>
<a name="ln224">    cairo_translate(cr, -.5f * wd, -.5f * ht);</a>
<a name="ln225"> </a>
<a name="ln226">    cairo_rectangle(cr, 0, 0, wd, ht);</a>
<a name="ln227">    cairo_set_source_surface(cr, surface, 0, 0);</a>
<a name="ln228">    cairo_pattern_set_filter(cairo_get_source(cr), CAIRO_FILTER_BEST);</a>
<a name="ln229">    cairo_fill(cr);</a>
<a name="ln230"> </a>
<a name="ln231">    // draw box where we are</a>
<a name="ln232">    dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln233">    int closeup = dt_control_get_dev_closeup();</a>
<a name="ln234">    float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln235">    float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln236">    const float min_scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_FIT, 1&lt;&lt;closeup, 0);</a>
<a name="ln237">    const float cur_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln238">    // avoid numerical instability for small resolutions:</a>
<a name="ln239">    double h, w;</a>
<a name="ln240">    if(cur_scale &gt; min_scale)</a>
<a name="ln241">    {</a>
<a name="ln242">      // Add a dark overlay on the picture to make it fade</a>
<a name="ln243">      cairo_rectangle(cr, 0, 0, wd, ht);</a>
<a name="ln244">      cairo_set_source_rgba(cr, 0, 0, 0, 0.33);</a>
<a name="ln245">      cairo_fill(cr);</a>
<a name="ln246"> </a>
<a name="ln247">      float boxw = 1, boxh = 1;</a>
<a name="ln248">      dt_dev_check_zoom_bounds(darktable.develop, &amp;zoom_x, &amp;zoom_y, zoom, closeup, &amp;boxw, &amp;boxh);</a>
<a name="ln249"> </a>
<a name="ln250">      // Repaint the original image in the area of interest</a>
<a name="ln251">      cairo_set_source_surface(cr, surface, 0, 0);</a>
<a name="ln252">      cairo_translate(cr, wd * (.5f + zoom_x), ht * (.5f + zoom_y));</a>
<a name="ln253">      boxw *= wd;</a>
<a name="ln254">      boxh *= ht;</a>
<a name="ln255">      cairo_rectangle(cr, -boxw / 2 - 1, -boxh / 2 - 1, boxw + 2, boxh + 2);</a>
<a name="ln256">      cairo_clip_preserve(cr);</a>
<a name="ln257">      cairo_fill_preserve(cr);</a>
<a name="ln258"> </a>
<a name="ln259">      // Paint the external border in black</a>
<a name="ln260">      cairo_set_source_rgb(cr, 0., 0., 0.);</a>
<a name="ln261">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1));</a>
<a name="ln262">      cairo_stroke(cr);</a>
<a name="ln263"> </a>
<a name="ln264">      // Paint the internal border in white</a>
<a name="ln265">      cairo_set_source_rgb(cr, 1., 1., 1.);</a>
<a name="ln266">      cairo_rectangle(cr, -boxw / 2, -boxh / 2, boxw, boxh);</a>
<a name="ln267">      cairo_stroke(cr);</a>
<a name="ln268">    }</a>
<a name="ln269">    cairo_restore(cr);</a>
<a name="ln270">    if(fabsf(cur_scale - min_scale) &gt; 0.001f)</a>
<a name="ln271">    {</a>
<a name="ln272">      /* Zoom % */</a>
<a name="ln273">      PangoLayout *layout;</a>
<a name="ln274">      PangoRectangle ink;</a>
<a name="ln275">      PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln276">      layout = pango_cairo_create_layout(cr);</a>
<a name="ln277">      const float fontsize = DT_PIXEL_APPLY_DPI(14);</a>
<a name="ln278">      pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);</a>
<a name="ln279">      pango_layout_set_font_description(layout, desc);</a>
<a name="ln280">      cairo_translate(cr, 0, height);</a>
<a name="ln281">      cairo_set_source_rgba(cr, 1., 1., 1., 0.5);</a>
<a name="ln282">      cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);</a>
<a name="ln283"> </a>
<a name="ln284">      char zoomline[5];</a>
<a name="ln285">      snprintf(zoomline, sizeof(zoomline), &quot;%.0f%%&quot;, cur_scale * 100);</a>
<a name="ln286"> </a>
<a name="ln287">      pango_layout_set_text(layout, zoomline, -1);</a>
<a name="ln288">      pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln289">      h = d-&gt;zoom_h = ink.height;</a>
<a name="ln290">      w = d-&gt;zoom_w = ink.width;</a>
<a name="ln291"> </a>
<a name="ln292">      cairo_move_to(cr, width - w - h * 1.1 - ink.x, - fontsize);</a>
<a name="ln293"> </a>
<a name="ln294">      cairo_save(cr);</a>
<a name="ln295">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1));</a>
<a name="ln296"> </a>
<a name="ln297">      GdkRGBA *color;</a>
<a name="ln298">      gtk_style_context_get(context, gtk_widget_get_state_flags(widget), &quot;background-color&quot;, &amp;color, NULL);</a>
<a name="ln299"> </a>
<a name="ln300">      gdk_cairo_set_source_rgba(cr, color);</a>
<a name="ln301">      pango_cairo_layout_path(cr, layout);</a>
<a name="ln302">      cairo_stroke_preserve(cr);</a>
<a name="ln303">      cairo_set_source_rgb(cr, 0.8, 0.8, 0.8);</a>
<a name="ln304">      cairo_fill(cr);</a>
<a name="ln305">      cairo_restore(cr);</a>
<a name="ln306"> </a>
<a name="ln307">      gdk_rgba_free(color);</a>
<a name="ln308">      pango_font_description_free(desc);</a>
<a name="ln309">      g_object_unref(layout);</a>
<a name="ln310"> </a>
<a name="ln311">    }</a>
<a name="ln312">    else</a>
<a name="ln313">    {</a>
<a name="ln314">      // draw the zoom-to-fit icon</a>
<a name="ln315">      cairo_translate(cr, 0, height);</a>
<a name="ln316">      cairo_set_source_rgb(cr, 0.8, 0.8, 0.8);</a>
<a name="ln317"> </a>
<a name="ln318">      static int font_height = -1;</a>
<a name="ln319">      if(font_height == -1)</a>
<a name="ln320">      {</a>
<a name="ln321">        PangoLayout *layout;</a>
<a name="ln322">        PangoRectangle ink;</a>
<a name="ln323">        PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln324">        pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln325">        layout = pango_cairo_create_layout(cr);</a>
<a name="ln326">        pango_font_description_set_absolute_size(desc, DT_PIXEL_APPLY_DPI(14) * PANGO_SCALE);</a>
<a name="ln327">        pango_layout_set_font_description(layout, desc);</a>
<a name="ln328">        pango_layout_set_text(layout, &quot;100%&quot;, -1); // dummy text, just to get the height</a>
<a name="ln329">        pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln330">        font_height = ink.height;</a>
<a name="ln331">        pango_font_description_free(desc);</a>
<a name="ln332">        g_object_unref(layout);</a>
<a name="ln333">      }</a>
<a name="ln334"> </a>
<a name="ln335">      h = d-&gt;zoom_h = font_height;</a>
<a name="ln336">      w = h * 1.5;</a>
<a name="ln337">      float sp = h * 0.6;</a>
<a name="ln338">      d-&gt;zoom_w = w + sp;</a>
<a name="ln339"> </a>
<a name="ln340">      cairo_move_to(cr, width - w - h - sp, -1.0 * h);</a>
<a name="ln341">      cairo_rectangle(cr, width - w - h - sp, -1.0 * h, w, h);</a>
<a name="ln342">      cairo_set_source_rgb(cr, 0.2, 0.2, 0.2);</a>
<a name="ln343">      cairo_fill(cr);</a>
<a name="ln344"> </a>
<a name="ln345">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2));</a>
<a name="ln346"> </a>
<a name="ln347">      cairo_set_source_rgb(cr, 0.6, 0.6, 0.6);</a>
<a name="ln348">      cairo_move_to(cr, width - w * 0.8 - h - sp, -1.0 * h);</a>
<a name="ln349">      cairo_line_to(cr, width - w - h - sp, -1.0 * h);</a>
<a name="ln350">      cairo_line_to(cr, width - w - h - sp, -0.7 * h);</a>
<a name="ln351">      cairo_stroke(cr);</a>
<a name="ln352">      cairo_move_to(cr, width - w - h - sp, -0.3 * h);</a>
<a name="ln353">      cairo_line_to(cr, width - w - h - sp, 0);</a>
<a name="ln354">      cairo_line_to(cr, width - w * 0.8 - h - sp, 0);</a>
<a name="ln355">      cairo_stroke(cr);</a>
<a name="ln356">      cairo_move_to(cr, width - w * 0.2 - h - sp, 0);</a>
<a name="ln357">      cairo_line_to(cr, width - h - sp, 0);</a>
<a name="ln358">      cairo_line_to(cr, width - h - sp, -0.3 * h);</a>
<a name="ln359">      cairo_stroke(cr);</a>
<a name="ln360">      cairo_move_to(cr, width - h - sp, -0.7 * h);</a>
<a name="ln361">      cairo_line_to(cr, width - h - sp, -1.0 * h);</a>
<a name="ln362">      cairo_line_to(cr, width - w * 0.2 - h - sp, -1.0 * h);</a>
<a name="ln363">      cairo_stroke(cr);</a>
<a name="ln364">    }</a>
<a name="ln365"> </a>
<a name="ln366">    cairo_move_to(cr, width - 0.95 * h, -0.9 * h);</a>
<a name="ln367">    cairo_line_to(cr, width - 0.05 * h, -0.9 * h);</a>
<a name="ln368">    cairo_line_to(cr, width - 0.5 * h, -0.1 * h);</a>
<a name="ln369">    cairo_fill(cr);</a>
<a name="ln370">    cairo_surface_destroy(surface);</a>
<a name="ln371">  }</a>
<a name="ln372"> </a>
<a name="ln373">  /* blit memsurface into widget */</a>
<a name="ln374">  cairo_destroy(cr);</a>
<a name="ln375">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln376">  cairo_paint(crf);</a>
<a name="ln377">  cairo_surface_destroy(cst);</a>
<a name="ln378"> </a>
<a name="ln379">  return TRUE;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">void _lib_navigation_set_position(dt_lib_module_t *self, double x, double y, int wd, int ht)</a>
<a name="ln383">{</a>
<a name="ln384">  dt_lib_navigation_t *d = (dt_lib_navigation_t *)self-&gt;data;</a>
<a name="ln385"> </a>
<a name="ln386">  dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln387">  int closeup = dt_control_get_dev_closeup();</a>
<a name="ln388">  float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln389">  float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln390"> </a>
<a name="ln391">  if(d-&gt;dragging &amp;&amp; zoom != DT_ZOOM_FIT)</a>
<a name="ln392">  {</a>
<a name="ln393">    const int inset = DT_NAVIGATION_INSET;</a>
<a name="ln394">    const float width = wd - 2 * inset, height = ht - 2 * inset;</a>
<a name="ln395">    const dt_develop_t *dev = darktable.develop;</a>
<a name="ln396">    int iwd, iht;</a>
<a name="ln397">    dt_dev_get_processed_size(dev, &amp;iwd, &amp;iht);</a>
<a name="ln398">    zoom_x = fmaxf(</a>
<a name="ln399">        -.5,</a>
<a name="ln400">        fminf(((x - inset) / width - .5f) / (iwd * fminf(wd / (float)iwd, ht / (float)iht) / (float)wd), .5));</a>
<a name="ln401">    zoom_y = fmaxf(</a>
<a name="ln402">        -.5, fminf(((y - inset) / height - .5f) / (iht * fminf(wd / (float)iwd, ht / (float)iht) / (float)ht),</a>
<a name="ln403">                   .5));</a>
<a name="ln404">    dt_dev_check_zoom_bounds(darktable.develop, &amp;zoom_x, &amp;zoom_y, zoom, closeup, NULL, NULL);</a>
<a name="ln405">    dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln406">    dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln407"> </a>
<a name="ln408">    /* redraw myself */</a>
<a name="ln409">    gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln410"> </a>
<a name="ln411">    /* redraw pipe */</a>
<a name="ln412">    dt_dev_invalidate(darktable.develop);</a>
<a name="ln413">    dt_control_queue_redraw_center();</a>
<a name="ln414">  }</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">static gboolean _lib_navigation_motion_notify_callback(GtkWidget *widget, GdkEventMotion *event,</a>
<a name="ln418">                                                       gpointer user_data)</a>
<a name="ln419">{</a>
<a name="ln420">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln421">  GtkAllocation allocation;</a>
<a name="ln422">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln423">  _lib_navigation_set_position(self, event-&gt;x, event-&gt;y, allocation.width, allocation.height);</a>
<a name="ln424">  gint x, y; // notify gtk for motion_hint.</a>
<a name="ln425">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln426">  gdk_window_get_device_position(event-&gt;window,</a>
<a name="ln427">      gdk_seat_get_pointer(gdk_display_get_default_seat(</a>
<a name="ln428">          gdk_window_get_display(event-&gt;window))),</a>
<a name="ln429">      &amp;x, &amp;y, 0);</a>
<a name="ln430">#else</a>
<a name="ln431">  gdk_window_get_device_position(event-&gt;window,</a>
<a name="ln432">                                 gdk_device_manager_get_client_pointer(</a>
<a name="ln433">                                     gdk_display_get_device_manager(gdk_window_get_display(event-&gt;window))),</a>
<a name="ln434">                                 &amp;x, &amp;y, NULL);</a>
<a name="ln435">#endif</a>
<a name="ln436">  return TRUE;</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">static void _zoom_preset_change(uint64_t val)</a>
<a name="ln440">{</a>
<a name="ln441">  // dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln442">  dt_develop_t *dev = darktable.develop;</a>
<a name="ln443">  if(!dev) return;</a>
<a name="ln444">  dt_dev_zoom_t zoom;</a>
<a name="ln445">  int closeup, procw, proch;</a>
<a name="ln446">  float zoom_x, zoom_y;</a>
<a name="ln447">  zoom = dt_control_get_dev_zoom();</a>
<a name="ln448">  closeup = dt_control_get_dev_closeup();</a>
<a name="ln449">  zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln450">  zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln451">  dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln452">  float scale = 0;</a>
<a name="ln453">  closeup = 0;</a>
<a name="ln454">  if(val == 0u)</a>
<a name="ln455">  {</a>
<a name="ln456">    scale = 0.5 * dt_dev_get_zoom_scale(dev, DT_ZOOM_FIT, 1.0, 0);</a>
<a name="ln457">    zoom = DT_ZOOM_FREE;</a>
<a name="ln458">  }</a>
<a name="ln459">  else if(val == 1u)</a>
<a name="ln460">  {</a>
<a name="ln461">    zoom = DT_ZOOM_FIT;</a>
<a name="ln462">    scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_FIT, 1.0, 0);</a>
<a name="ln463">  }</a>
<a name="ln464">  else if(val == 2u)</a>
<a name="ln465">  {</a>
<a name="ln466">    scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_1, 1.0, 0);</a>
<a name="ln467">    zoom = DT_ZOOM_1;</a>
<a name="ln468">  }</a>
<a name="ln469">  else if(val == 3u)</a>
<a name="ln470">  {</a>
<a name="ln471">    scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_1, 1.0, 0);</a>
<a name="ln472">    zoom = DT_ZOOM_1;</a>
<a name="ln473">    closeup = 1;</a>
<a name="ln474">  }</a>
<a name="ln475">  else if(val == 4u)</a>
<a name="ln476">  {</a>
<a name="ln477">    scale = 0.5f;</a>
<a name="ln478">    zoom = DT_ZOOM_FREE;</a>
<a name="ln479">  }</a>
<a name="ln480">  else if(val == 5u)</a>
<a name="ln481">  {</a>
<a name="ln482">    scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_1, 1.0, 0);</a>
<a name="ln483">    zoom = DT_ZOOM_1;</a>
<a name="ln484">    closeup = 4;</a>
<a name="ln485">  }</a>
<a name="ln486">  else if(val == 6u)</a>
<a name="ln487">  {</a>
<a name="ln488">    scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_1, 1.0, 0);</a>
<a name="ln489">    zoom = DT_ZOOM_1;</a>
<a name="ln490">    closeup = 2;</a>
<a name="ln491">  }</a>
<a name="ln492">  else if(val == 7u)</a>
<a name="ln493">  {</a>
<a name="ln494">    scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_1, 1.0, 0);</a>
<a name="ln495">    zoom = DT_ZOOM_1;</a>
<a name="ln496">    closeup = 3;</a>
<a name="ln497">  }</a>
<a name="ln498"> </a>
<a name="ln499">  // zoom_x = (1.0/(scale*(1&lt;&lt;closeup)))*(zoom_x - .5f*dev-&gt;width )/procw;</a>
<a name="ln500">  // zoom_y = (1.0/(scale*(1&lt;&lt;closeup)))*(zoom_y - .5f*dev-&gt;height)/proch;</a>
<a name="ln501"> </a>
<a name="ln502">  dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, zoom, closeup, NULL, NULL);</a>
<a name="ln503">  dt_control_set_dev_zoom_scale(scale);</a>
<a name="ln504">  dt_control_set_dev_zoom(zoom);</a>
<a name="ln505">  dt_control_set_dev_closeup(closeup);</a>
<a name="ln506">  dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln507">  dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln508">  dt_dev_invalidate(dev);</a>
<a name="ln509">  dt_control_queue_redraw();</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">static void _zoom_preset_callback(GtkButton *button, gpointer user_data)</a>
<a name="ln513">{</a>
<a name="ln514">  _zoom_preset_change((uint64_t)user_data);</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">static gboolean _lib_navigation_button_press_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln518">                                                      gpointer user_data)</a>
<a name="ln519">{</a>
<a name="ln520">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln521">  dt_lib_navigation_t *d = (dt_lib_navigation_t *)self-&gt;data;</a>
<a name="ln522"> </a>
<a name="ln523">  GtkAllocation allocation;</a>
<a name="ln524">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln525">  int w = allocation.width;</a>
<a name="ln526">  int h = allocation.height;</a>
<a name="ln527">  if(event-&gt;x &gt;= w - DT_NAVIGATION_INSET - d-&gt;zoom_h - d-&gt;zoom_w</a>
<a name="ln528">     &amp;&amp; event-&gt;y &gt;= h - DT_NAVIGATION_INSET - d-&gt;zoom_h)</a>
<a name="ln529">  {</a>
<a name="ln530">    // we show the zoom menu</a>
<a name="ln531">    GtkMenuShell *menu = GTK_MENU_SHELL(gtk_menu_new());</a>
<a name="ln532">    GtkWidget *item;</a>
<a name="ln533"> </a>
<a name="ln534">    item = gtk_menu_item_new_with_label(_(&quot;small&quot;));</a>
<a name="ln535">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)0);</a>
<a name="ln536">    gtk_menu_shell_append(menu, item);</a>
<a name="ln537"> </a>
<a name="ln538">    item = gtk_menu_item_new_with_label(_(&quot;fit to screen&quot;));</a>
<a name="ln539">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)1);</a>
<a name="ln540">    gtk_menu_shell_append(menu, item);</a>
<a name="ln541"> </a>
<a name="ln542">    item = gtk_menu_item_new_with_label(_(&quot;50%&quot;));</a>
<a name="ln543">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)4);</a>
<a name="ln544">    gtk_menu_shell_append(menu, item);</a>
<a name="ln545"> </a>
<a name="ln546">    item = gtk_menu_item_new_with_label(_(&quot;100%&quot;));</a>
<a name="ln547">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)2);</a>
<a name="ln548">    gtk_menu_shell_append(menu, item);</a>
<a name="ln549"> </a>
<a name="ln550">    item = gtk_menu_item_new_with_label(_(&quot;200%&quot;));</a>
<a name="ln551">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)3);</a>
<a name="ln552">    gtk_menu_shell_append(menu, item);</a>
<a name="ln553"> </a>
<a name="ln554">    item = gtk_menu_item_new_with_label(_(&quot;400%&quot;));</a>
<a name="ln555">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)6);</a>
<a name="ln556">    gtk_menu_shell_append(menu, item);</a>
<a name="ln557"> </a>
<a name="ln558">    item = gtk_menu_item_new_with_label(_(&quot;800%&quot;));</a>
<a name="ln559">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)7);</a>
<a name="ln560">    gtk_menu_shell_append(menu, item);</a>
<a name="ln561"> </a>
<a name="ln562">    item = gtk_menu_item_new_with_label(_(&quot;1600%&quot;));</a>
<a name="ln563">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)5);</a>
<a name="ln564">    gtk_menu_shell_append(menu, item);</a>
<a name="ln565"> </a>
<a name="ln566">    gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln567"> </a>
<a name="ln568">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln569">    gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln570">#else</a>
<a name="ln571">    gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, 0, gtk_get_current_event_time());</a>
<a name="ln572">#endif</a>
<a name="ln573"> </a>
<a name="ln574">    return TRUE;</a>
<a name="ln575">  }</a>
<a name="ln576">  d-&gt;dragging = 1;</a>
<a name="ln577">  _lib_navigation_set_position(self, event-&gt;x, event-&gt;y, w, h);</a>
<a name="ln578">  return TRUE;</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">static gboolean _lib_navigation_button_release_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln582">                                                        gpointer user_data)</a>
<a name="ln583">{</a>
<a name="ln584">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln585">  dt_lib_navigation_t *d = (dt_lib_navigation_t *)self-&gt;data;</a>
<a name="ln586">  d-&gt;dragging = 0;</a>
<a name="ln587"> </a>
<a name="ln588">  return TRUE;</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">static gboolean _lib_navigation_leave_notify_callback(GtkWidget *widget, GdkEventCrossing *event,</a>
<a name="ln592">                                                      gpointer user_data)</a>
<a name="ln593">{</a>
<a name="ln594">  return TRUE;</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln598">{</a>
<a name="ln599">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;toggle navigation thumbnail visibility&quot;), GDK_KEY_N, GDK_CONTROL_MASK | GDK_SHIFT_MASK);</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln603">{</a>
<a name="ln604">  dt_accel_connect_lib(self, &quot;hide navigation thumbnail&quot;,</a>
<a name="ln605">                     g_cclosure_new(G_CALLBACK(_lib_navigation_collapse_callback), self, NULL));</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln609">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln610">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="453"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'closeup' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 448, 453.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
