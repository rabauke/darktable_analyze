
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010-2012 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/collection.h&quot;</a>
<a name="ln20">#include &quot;common/debug.h&quot;</a>
<a name="ln21">#include &quot;common/image.h&quot;</a>
<a name="ln22">#include &quot;common/imageio_rawspeed.h&quot;</a>
<a name="ln23">#include &quot;common/metadata.h&quot;</a>
<a name="ln24">#include &quot;common/utility.h&quot;</a>
<a name="ln25">#include &quot;control/conf.h&quot;</a>
<a name="ln26">#include &quot;control/control.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;glib.h&gt;</a>
<a name="ln29">#include &lt;memory.h&gt;</a>
<a name="ln30">#include &lt;stdio.h&gt;</a>
<a name="ln31">#include &lt;stdlib.h&gt;</a>
<a name="ln32">#include &lt;unistd.h&gt;</a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">#ifdef _WIN32</a>
<a name="ln36">//MSVCRT does not have strptime implemented</a>
<a name="ln37">#include &quot;win/strptime.h&quot;</a>
<a name="ln38">#endif</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">#define SELECT_QUERY &quot;SELECT DISTINCT * FROM %s&quot;</a>
<a name="ln42">#define ORDER_BY_QUERY &quot;ORDER BY %s&quot;</a>
<a name="ln43">#define LIMIT_QUERY &quot;LIMIT ?1, ?2&quot;</a>
<a name="ln44"> </a>
<a name="ln45">static const char *comparators[] = {</a>
<a name="ln46">  &quot;&lt;&quot;,  // DT_COLLECTION_RATING_COMP_LT = 0,</a>
<a name="ln47">  &quot;&lt;=&quot;, // DT_COLLECTION_RATING_COMP_LEQ,</a>
<a name="ln48">  &quot;=&quot;,  // DT_COLLECTION_RATING_COMP_EQ,</a>
<a name="ln49">  &quot;&gt;=&quot;, // DT_COLLECTION_RATING_COMP_GEQ,</a>
<a name="ln50">  &quot;&gt;&quot;,  // DT_COLLECTION_RATING_COMP_GT,</a>
<a name="ln51">  &quot;!=&quot;, // DT_COLLECTION_RATING_COMP_NE,</a>
<a name="ln52">};</a>
<a name="ln53"> </a>
<a name="ln54">/* Stores the collection query, returns 1 if changed.. */</a>
<a name="ln55">static int _dt_collection_store(const dt_collection_t *collection, gchar *query, gchar *query_no_group);</a>
<a name="ln56">/* Counts the number of images in the current collection */</a>
<a name="ln57">static uint32_t _dt_collection_compute_count(const dt_collection_t *collection, gboolean no_group);</a>
<a name="ln58">/* signal handlers to update the cached count when something interesting might have happened.</a>
<a name="ln59"> * we need 2 different since there are different kinds of signals we need to listen to. */</a>
<a name="ln60">static void _dt_collection_recount_callback_1(gpointer instace, gpointer user_data);</a>
<a name="ln61">static void _dt_collection_recount_callback_2(gpointer instance, uint8_t id, gpointer user_data);</a>
<a name="ln62"> </a>
<a name="ln63">/* determine image offset of specified imgid for the given collection */</a>
<a name="ln64">static int dt_collection_image_offset_with_collection(const dt_collection_t *collection, int imgid);</a>
<a name="ln65">/* update aspect ratio for the selected images */</a>
<a name="ln66">static void _collection_update_aspect_ratio(const dt_collection_t *collection);</a>
<a name="ln67"> </a>
<a name="ln68">const dt_collection_t *dt_collection_new(const dt_collection_t *clone)</a>
<a name="ln69">{</a>
<a name="ln70">  dt_collection_t *collection = g_malloc0(sizeof(dt_collection_t));</a>
<a name="ln71"> </a>
<a name="ln72">  /* initialize collection context*/</a>
<a name="ln73">  if(clone) /* if clone is provided let's copy it into this context */</a>
<a name="ln74">  {</a>
<a name="ln75">    memcpy(&amp;collection-&gt;params, &amp;clone-&gt;params, sizeof(dt_collection_params_t));</a>
<a name="ln76">    memcpy(&amp;collection-&gt;store, &amp;clone-&gt;store, sizeof(dt_collection_params_t));</a>
<a name="ln77">    collection-&gt;where_ext = g_strdupv(clone-&gt;where_ext);</a>
<a name="ln78">    collection-&gt;query = g_strdup(clone-&gt;query);</a>
<a name="ln79">    collection-&gt;query_no_group = g_strdup(clone-&gt;query_no_group);</a>
<a name="ln80">    collection-&gt;clone = 1;</a>
<a name="ln81">    collection-&gt;count = clone-&gt;count;</a>
<a name="ln82">    collection-&gt;count_no_group = clone-&gt;count_no_group;</a>
<a name="ln83">  }</a>
<a name="ln84">  else /* else we just initialize using the reset */</a>
<a name="ln85">    dt_collection_reset(collection);</a>
<a name="ln86"> </a>
<a name="ln87">  /* connect to all the signals that might indicate that the count of images matching the collection changed</a>
<a name="ln88">   */</a>
<a name="ln89">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_TAG_CHANGED,</a>
<a name="ln90">                            G_CALLBACK(_dt_collection_recount_callback_1), collection);</a>
<a name="ln91">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED,</a>
<a name="ln92">                            G_CALLBACK(_dt_collection_recount_callback_1), collection);</a>
<a name="ln93">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_REMOVED,</a>
<a name="ln94">                            G_CALLBACK(_dt_collection_recount_callback_1), collection);</a>
<a name="ln95"> </a>
<a name="ln96">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_IMAGE_IMPORT,</a>
<a name="ln97">                            G_CALLBACK(_dt_collection_recount_callback_2), collection);</a>
<a name="ln98">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_IMPORTED,</a>
<a name="ln99">                            G_CALLBACK(_dt_collection_recount_callback_2), collection);</a>
<a name="ln100"> </a>
<a name="ln101">  return collection;</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104">void dt_collection_free(const dt_collection_t *collection)</a>
<a name="ln105">{</a>
<a name="ln106">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_dt_collection_recount_callback_1),</a>
<a name="ln107">                               (gpointer)collection);</a>
<a name="ln108">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_dt_collection_recount_callback_2),</a>
<a name="ln109">                               (gpointer)collection);</a>
<a name="ln110"> </a>
<a name="ln111">  g_free(collection-&gt;query);</a>
<a name="ln112">  g_free(collection-&gt;query_no_group);</a>
<a name="ln113">  g_strfreev(collection-&gt;where_ext);</a>
<a name="ln114">  g_free((dt_collection_t *)collection);</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">const dt_collection_params_t *dt_collection_params(const dt_collection_t *collection)</a>
<a name="ln118">{</a>
<a name="ln119">  return &amp;collection-&gt;params;</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">int dt_collection_update(const dt_collection_t *collection)</a>
<a name="ln123">{</a>
<a name="ln124">  uint32_t result;</a>
<a name="ln125">  gchar *wq, *wq_no_group, *sq, *selq_pre, *selq_post, *query, *query_no_group;</a>
<a name="ln126">  wq = wq_no_group = sq = selq_pre = selq_post = query = query_no_group = NULL;</a>
<a name="ln127"> </a>
<a name="ln128">  /* build where part */</a>
<a name="ln129">  gchar *where_ext = dt_collection_get_extended_where(collection, -1);</a>
<a name="ln130">  if(!(collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_ONLY_WHERE_EXT))</a>
<a name="ln131">  {</a>
<a name="ln132">    int need_operator = 0;</a>
<a name="ln133">    dt_collection_filter_t rating = collection-&gt;params.rating;</a>
<a name="ln134">    if(rating == DT_COLLECTION_FILTER_NOT_REJECT) rating = DT_COLLECTION_FILTER_STAR_NO;</a>
<a name="ln135"> </a>
<a name="ln136">    /* add default filters */</a>
<a name="ln137">    if(collection-&gt;params.filter_flags &amp; COLLECTION_FILTER_FILM_ID)</a>
<a name="ln138">    {</a>
<a name="ln139">      wq = dt_util_dstrcat(wq, &quot;(film_id = %d)&quot;, collection-&gt;params.film_id);</a>
<a name="ln140">      need_operator = 1;</a>
<a name="ln141">    }</a>
<a name="ln142">    // DON'T SELECT IMAGES MARKED TO BE DELETED.</a>
<a name="ln143">    wq = dt_util_dstrcat(wq, &quot; %s (flags &amp; %d) != %d&quot;,</a>
<a name="ln144">                         (need_operator) ? &quot;AND&quot; : ((need_operator = 1) ? &quot;&quot; : &quot;&quot;), DT_IMAGE_REMOVE,</a>
<a name="ln145">                         DT_IMAGE_REMOVE);</a>
<a name="ln146"> </a>
<a name="ln147">    if(collection-&gt;params.filter_flags &amp; COLLECTION_FILTER_CUSTOM_COMPARE)</a>
<a name="ln148">      wq = dt_util_dstrcat(wq, &quot; %s (flags &amp; 7) %s %d AND (flags &amp; 7) != 6&quot;,</a>
<a name="ln149">                           (need_operator) ? &quot;and&quot; : ((need_operator = 1) ? &quot;&quot; : &quot;&quot;),</a>
<a name="ln150">                           comparators[collection-&gt;params.comparator], rating - 1);</a>
<a name="ln151">    else if(collection-&gt;params.filter_flags &amp; COLLECTION_FILTER_ATLEAST_RATING)</a>
<a name="ln152">      wq = dt_util_dstrcat(wq, &quot; %s (flags &amp; 7) &gt;= %d AND (flags &amp; 7) != 6&quot;,</a>
<a name="ln153">                           (need_operator) ? &quot;and&quot; : ((need_operator = 1) ? &quot;&quot; : &quot;&quot;), rating - 1);</a>
<a name="ln154">    else if(collection-&gt;params.filter_flags &amp; COLLECTION_FILTER_EQUAL_RATING)</a>
<a name="ln155">      wq = dt_util_dstrcat(wq, &quot; %s (flags &amp; 7) == %d&quot;,</a>
<a name="ln156">                           (need_operator) ? &quot;AND&quot; : ((need_operator = 1) ? &quot;&quot; : &quot;&quot;), rating - 1);</a>
<a name="ln157"> </a>
<a name="ln158">    if(collection-&gt;params.filter_flags &amp; COLLECTION_FILTER_ALTERED)</a>
<a name="ln159">      wq = dt_util_dstrcat(wq, &quot; %s id IN (SELECT imgid FROM main.history WHERE imgid=id)&quot;,</a>
<a name="ln160">                           (need_operator) ? &quot;AND&quot; : ((need_operator = 1) ? &quot;&quot; : &quot;&quot;));</a>
<a name="ln161">    else if(collection-&gt;params.filter_flags &amp; COLLECTION_FILTER_UNALTERED)</a>
<a name="ln162">      wq = dt_util_dstrcat(wq, &quot; %s id NOT IN (SELECT imgid FROM main.history WHERE imgid=id)&quot;,</a>
<a name="ln163">                           (need_operator) ? &quot;AND&quot; : ((need_operator = 1) ? &quot;&quot; : &quot;&quot;));</a>
<a name="ln164"> </a>
<a name="ln165">    /* add where ext if wanted */</a>
<a name="ln166">    if((collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_WHERE_EXT))</a>
<a name="ln167">      wq = dt_util_dstrcat(wq, &quot; %s %s&quot;, (need_operator) ? &quot;AND&quot; : &quot;&quot;, where_ext);</a>
<a name="ln168">  }</a>
<a name="ln169">  else</a>
<a name="ln170">    wq = dt_util_dstrcat(wq, &quot;%s&quot;, where_ext);</a>
<a name="ln171"> </a>
<a name="ln172">  g_free(where_ext);</a>
<a name="ln173"> </a>
<a name="ln174">  wq_no_group = g_strdup(wq);</a>
<a name="ln175"> </a>
<a name="ln176">  /* grouping */</a>
<a name="ln177">  if(darktable.gui &amp;&amp; darktable.gui-&gt;grouping)</a>
<a name="ln178">  {</a>
<a name="ln179">    /* Show the expanded group... */</a>
<a name="ln180">    wq = dt_util_dstrcat(wq, &quot; AND (group_id = %d OR &quot;</a>
<a name="ln181">                             /* ...and, in unexpanded groups, show the representative image.</a>
<a name="ln182">                              * It's possible that the above WHERE clauses will filter out the representative</a>
<a name="ln183">                              * image, so we have some logic here to pick the image id closest to the</a>
<a name="ln184">                              * representative image.</a>
<a name="ln185">                              * The *2+CASE statement are to break ties, so that when id &lt; group_id, it's</a>
<a name="ln186">                              * weighted a little higher than when id &gt; group_id. */</a>
<a name="ln187">                             &quot;(ABS(id-group_id)*2 + CASE WHEN (id-group_id) &lt; 0 THEN 1 ELSE 0 END) IN &quot;</a>
<a name="ln188">                             &quot;(SELECT MIN(ABS(id-group_id)*2 + CASE WHEN (id-group_id) &lt; 0 THEN 1 ELSE 0 END) &quot;</a>
<a name="ln189">                             &quot;FROM main.images WHERE %s GROUP BY group_id))&quot;,</a>
<a name="ln190">                         darktable.gui-&gt;expanded_group_id, wq_no_group);</a>
<a name="ln191"> </a>
<a name="ln192">    /* Additionally, when a group is expanded, make sure the representative image wasn't filtered out.</a>
<a name="ln193">     * This is important, because otherwise it may be impossible to collapse the group again. */</a>
<a name="ln194">    wq = dt_util_dstrcat(wq, &quot; OR (id = %d)&quot;, darktable.gui-&gt;expanded_group_id);</a>
<a name="ln195">  }</a>
<a name="ln196"> </a>
<a name="ln197">  /* build select part includes where */</a>
<a name="ln198">  if(collection-&gt;params.sort == DT_COLLECTION_SORT_COLOR</a>
<a name="ln199">     &amp;&amp; (collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_SORT))</a>
<a name="ln200">  {</a>
<a name="ln201">    selq_pre = dt_util_dstrcat(selq_pre, &quot;SELECT DISTINCT id FROM (SELECT * FROM main.images WHERE &quot;);</a>
<a name="ln202">    selq_post = dt_util_dstrcat(selq_post, &quot;) AS a LEFT OUTER JOIN main.color_labels AS b ON a.id = b.imgid&quot;);</a>
<a name="ln203">  }</a>
<a name="ln204">  else if(collection-&gt;params.sort == DT_COLLECTION_SORT_TITLE</a>
<a name="ln205">          &amp;&amp; (collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_SORT))</a>
<a name="ln206">  {</a>
<a name="ln207">    selq_pre = dt_util_dstrcat(selq_pre, &quot;SELECT DISTINCT a.id FROM (SELECT * FROM main.images WHERE &quot;);</a>
<a name="ln208">    selq_post = dt_util_dstrcat(selq_post, &quot;) AS a LEFT OUTER JOIN main.meta_data AS m ON a.id = m.id AND m.key = %d &quot;,</a>
<a name="ln209">                                DT_METADATA_XMP_DC_TITLE);</a>
<a name="ln210">  }</a>
<a name="ln211">  else if(collection-&gt;params.sort == DT_COLLECTION_SORT_DESCRIPTION</a>
<a name="ln212">          &amp;&amp; (collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_SORT))</a>
<a name="ln213">  {</a>
<a name="ln214">    selq_pre = dt_util_dstrcat(selq_pre, &quot;SELECT DISTINCT a.id FROM (SELECT * FROM main.images WHERE &quot;);</a>
<a name="ln215">    selq_post = dt_util_dstrcat(selq_post, &quot;) AS a LEFT OUTER JOIN main.meta_data AS m ON a.id = m.id AND m.key = %d &quot;,</a>
<a name="ln216">                                DT_METADATA_XMP_DC_DESCRIPTION);</a>
<a name="ln217">  }</a>
<a name="ln218">  else if(collection-&gt;params.sort == DT_COLLECTION_SORT_PATH</a>
<a name="ln219">          &amp;&amp; (collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_SORT))</a>
<a name="ln220">  {</a>
<a name="ln221">    selq_pre = dt_util_dstrcat(selq_pre, &quot;SELECT DISTINCT id FROM (SELECT * FROM main.images WHERE &quot;);</a>
<a name="ln222">    selq_post = dt_util_dstrcat(selq_post, &quot;) AS a JOIN (SELECT id AS film_rolls_id, folder FROM main.film_rolls) ON film_id = film_rolls_id&quot;);</a>
<a name="ln223">  }</a>
<a name="ln224">  else if(collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_ONLY_WHERE_EXT)</a>
<a name="ln225">    selq_pre = dt_util_dstrcat(selq_pre, &quot;SELECT DISTINCT images.id FROM main.images AS a &quot;);</a>
<a name="ln226">  else</a>
<a name="ln227">  {</a>
<a name="ln228">    selq_pre = dt_util_dstrcat(selq_pre, &quot;SELECT DISTINCT id FROM images AS a WHERE &quot;);</a>
<a name="ln229">  }</a>
<a name="ln230">  /* build sort order part */</a>
<a name="ln231">  if(!(collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_ONLY_WHERE_EXT)</a>
<a name="ln232">     &amp;&amp; (collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_SORT))</a>
<a name="ln233">  {</a>
<a name="ln234">    sq = dt_collection_get_sort_query(collection);</a>
<a name="ln235">  }</a>
<a name="ln236"> </a>
<a name="ln237">  /* store the new query */</a>
<a name="ln238">  query</a>
<a name="ln239">      = dt_util_dstrcat(query, &quot;%s%s%s %s%s&quot;, selq_pre, wq, selq_post ? selq_post : &quot;&quot;, sq ? sq : &quot;&quot;,</a>
<a name="ln240">                        (collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_LIMIT) ? &quot; &quot; LIMIT_QUERY : &quot;&quot;);</a>
<a name="ln241">  query_no_group</a>
<a name="ln242">      = dt_util_dstrcat(query_no_group, &quot;%s%s%s %s%s&quot;, selq_pre, wq_no_group, selq_post ? selq_post : &quot;&quot;, sq ? sq : &quot;&quot;,</a>
<a name="ln243">                        (collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_LIMIT) ? &quot; &quot; LIMIT_QUERY : &quot;&quot;);</a>
<a name="ln244">  result = _dt_collection_store(collection, query, query_no_group);</a>
<a name="ln245"> </a>
<a name="ln246">  /* free memory used */</a>
<a name="ln247">  g_free(sq);</a>
<a name="ln248">  g_free(wq);</a>
<a name="ln249">  g_free(wq_no_group);</a>
<a name="ln250">  g_free(selq_pre);</a>
<a name="ln251">  g_free(selq_post);</a>
<a name="ln252">  g_free(query);</a>
<a name="ln253">  g_free(query_no_group);</a>
<a name="ln254"> </a>
<a name="ln255">  /* update the cached count. collection isn't a real const anyway, we are writing to it in</a>
<a name="ln256">   * _dt_collection_store, too. */</a>
<a name="ln257">  ((dt_collection_t *)collection)-&gt;count = _dt_collection_compute_count(collection, FALSE);</a>
<a name="ln258">  ((dt_collection_t *)collection)-&gt;count_no_group = _dt_collection_compute_count(collection, TRUE);</a>
<a name="ln259">  dt_collection_hint_message(collection);</a>
<a name="ln260"> </a>
<a name="ln261">  _collection_update_aspect_ratio(collection);</a>
<a name="ln262"> </a>
<a name="ln263">  return result;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">void dt_collection_reset(const dt_collection_t *collection)</a>
<a name="ln267">{</a>
<a name="ln268">  dt_collection_params_t *params = (dt_collection_params_t *)&amp;collection-&gt;params;</a>
<a name="ln269"> </a>
<a name="ln270">  /* setup defaults */</a>
<a name="ln271">  params-&gt;query_flags = COLLECTION_QUERY_FULL;</a>
<a name="ln272">  params-&gt;filter_flags = COLLECTION_FILTER_FILM_ID | COLLECTION_FILTER_ATLEAST_RATING;</a>
<a name="ln273">  params-&gt;film_id = 1;</a>
<a name="ln274">  params-&gt;rating = DT_COLLECTION_FILTER_STAR_NO;</a>
<a name="ln275"> </a>
<a name="ln276">  /* apply stored query parameters from previous darktable session */</a>
<a name="ln277">  params-&gt;film_id = dt_conf_get_int(&quot;plugins/collection/film_id&quot;);</a>
<a name="ln278">  params-&gt;rating = dt_conf_get_int(&quot;plugins/collection/rating&quot;);</a>
<a name="ln279">  params-&gt;comparator = dt_conf_get_int(&quot;plugins/collection/rating_comparator&quot;);</a>
<a name="ln280">  params-&gt;filter_flags = dt_conf_get_int(&quot;plugins/collection/filter_flags&quot;);</a>
<a name="ln281">  params-&gt;sort = dt_conf_get_int(&quot;plugins/collection/sort&quot;);</a>
<a name="ln282">  params-&gt;descending = dt_conf_get_bool(&quot;plugins/collection/descending&quot;);</a>
<a name="ln283">  dt_collection_update_query(collection);</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">const gchar *dt_collection_get_query(const dt_collection_t *collection)</a>
<a name="ln287">{</a>
<a name="ln288">  /* ensure there is a query string for collection */</a>
<a name="ln289">  if(!collection-&gt;query) dt_collection_update(collection);</a>
<a name="ln290"> </a>
<a name="ln291">  return collection-&gt;query;</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">const gchar *dt_collection_get_query_no_group(const dt_collection_t *collection)</a>
<a name="ln295">{</a>
<a name="ln296">  /* ensure there is a query string for collection */</a>
<a name="ln297">  if(!collection-&gt;query_no_group) dt_collection_update(collection);</a>
<a name="ln298"> </a>
<a name="ln299">  return collection-&gt;query_no_group;</a>
<a name="ln300">}</a>
<a name="ln301">uint32_t dt_collection_get_filter_flags(const dt_collection_t *collection)</a>
<a name="ln302">{</a>
<a name="ln303">  return collection-&gt;params.filter_flags;</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">void dt_collection_set_filter_flags(const dt_collection_t *collection, uint32_t flags)</a>
<a name="ln307">{</a>
<a name="ln308">  dt_collection_params_t *params = (dt_collection_params_t *)&amp;collection-&gt;params;</a>
<a name="ln309">  params-&gt;filter_flags = flags;</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312">uint32_t dt_collection_get_query_flags(const dt_collection_t *collection)</a>
<a name="ln313">{</a>
<a name="ln314">  return collection-&gt;params.query_flags;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">void dt_collection_set_query_flags(const dt_collection_t *collection, uint32_t flags)</a>
<a name="ln318">{</a>
<a name="ln319">  dt_collection_params_t *params = (dt_collection_params_t *)&amp;collection-&gt;params;</a>
<a name="ln320">  params-&gt;query_flags = flags;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">gchar *dt_collection_get_extended_where(const dt_collection_t *collection, int exclude)</a>
<a name="ln324">{</a>
<a name="ln325">  gchar *complete_string = NULL;</a>
<a name="ln326"> </a>
<a name="ln327">  if (exclude &gt;= 0)</a>
<a name="ln328">  {</a>
<a name="ln329">    complete_string = g_strdup(&quot;&quot;);</a>
<a name="ln330">    char confname[200];</a>
<a name="ln331">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, exclude);</a>
<a name="ln332">    const int mode = dt_conf_get_int(confname);</a>
<a name="ln333">    if (mode != 1) // don't limit the collection for OR</a>
<a name="ln334">    {</a>
<a name="ln335">      for(int i = 0; collection-&gt;where_ext[i] != NULL; i++)</a>
<a name="ln336">      {</a>
<a name="ln337">        // exclude the one rule from extended where</a>
<a name="ln338">        if (i != exclude)</a>
<a name="ln339">          complete_string = dt_util_dstrcat(complete_string, &quot;%s&quot;, collection-&gt;where_ext[i]);</a>
<a name="ln340">      }</a>
<a name="ln341">    }</a>
<a name="ln342">  }</a>
<a name="ln343">  else</a>
<a name="ln344">    complete_string = g_strjoinv(complete_string, ((dt_collection_t *)collection)-&gt;where_ext);</a>
<a name="ln345"> </a>
<a name="ln346">  gchar *where_ext = dt_util_dstrcat(NULL, &quot;(1=1%s)&quot;, complete_string);</a>
<a name="ln347">  g_free(complete_string);</a>
<a name="ln348"> </a>
<a name="ln349">  return where_ext;</a>
<a name="ln350">}</a>
<a name="ln351"> </a>
<a name="ln352">void dt_collection_set_extended_where(const dt_collection_t *collection, gchar **extended_where)</a>
<a name="ln353">{</a>
<a name="ln354">  /* free extended where if already exists */</a>
<a name="ln355">  g_strfreev(collection-&gt;where_ext);</a>
<a name="ln356"> </a>
<a name="ln357">  /* set new from parameter */</a>
<a name="ln358">  ((dt_collection_t *)collection)-&gt;where_ext = g_strdupv(extended_where);</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">void dt_collection_set_film_id(const dt_collection_t *collection, uint32_t film_id)</a>
<a name="ln362">{</a>
<a name="ln363">  dt_collection_params_t *params = (dt_collection_params_t *)&amp;collection-&gt;params;</a>
<a name="ln364">  params-&gt;film_id = film_id;</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">void dt_collection_set_rating(const dt_collection_t *collection, uint32_t rating)</a>
<a name="ln368">{</a>
<a name="ln369">  dt_collection_params_t *params = (dt_collection_params_t *)&amp;collection-&gt;params;</a>
<a name="ln370">  params-&gt;rating = rating;</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373">uint32_t dt_collection_get_rating(const dt_collection_t *collection)</a>
<a name="ln374">{</a>
<a name="ln375">  uint32_t i;</a>
<a name="ln376">  dt_collection_params_t *params = (dt_collection_params_t *)&amp;collection-&gt;params;</a>
<a name="ln377">  i = params-&gt;rating;</a>
<a name="ln378">  return i;</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">void dt_collection_set_rating_comparator(const dt_collection_t *collection,</a>
<a name="ln382">                                         const dt_collection_rating_comperator_t comparator)</a>
<a name="ln383">{</a>
<a name="ln384">  ((dt_collection_t *)collection)-&gt;params.comparator = comparator;</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">dt_collection_rating_comperator_t dt_collection_get_rating_comparator(const dt_collection_t *collection)</a>
<a name="ln388">{</a>
<a name="ln389">  return collection-&gt;params.comparator;</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">static void _collection_update_aspect_ratio(const dt_collection_t *collection)</a>
<a name="ln393">{</a>
<a name="ln394">  dt_collection_params_t *params = (dt_collection_params_t *)&amp;collection-&gt;params;</a>
<a name="ln395"> </a>
<a name="ln396">  //  Update the aspect ratio for selected images in the collection if needed, we do not do this for all</a>
<a name="ln397">  //  images as it could take a long time. The aspect ratio is then updated when needed, and at some</a>
<a name="ln398">  //  point all aspect ratio for all images will be set and this could won't be really needed.</a>
<a name="ln399"> </a>
<a name="ln400">  if (params-&gt;sort == DT_COLLECTION_SORT_ASPECT_RATIO)</a>
<a name="ln401">  {</a>
<a name="ln402">    const float MAX_TIME = 5.0;</a>
<a name="ln403">    const gchar *where_ext = dt_collection_get_extended_where(collection, -1);</a>
<a name="ln404">    gchar *query = NULL;</a>
<a name="ln405">    sqlite3_stmt *stmt = NULL;</a>
<a name="ln406"> </a>
<a name="ln407">    query = dt_util_dstrcat</a>
<a name="ln408">      (query, &quot;SELECT id FROM main.images WHERE %s AND (aspect_ratio=0.0 OR aspect_ratio IS NULL)&quot;, where_ext);</a>
<a name="ln409"> </a>
<a name="ln410">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln411"> </a>
<a name="ln412">    double start = dt_get_wtime();</a>
<a name="ln413">    while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln414">    {</a>
<a name="ln415">      const int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln416">      dt_image_set_aspect_ratio(imgid);</a>
<a name="ln417"> </a>
<a name="ln418">      if(dt_get_wtime() - start &gt; MAX_TIME)</a>
<a name="ln419">      {</a>
<a name="ln420">        dt_control_log(_(&quot;too much time to update aspect ratio for the collection&quot;));</a>
<a name="ln421">        break;</a>
<a name="ln422">      }</a>
<a name="ln423">    }</a>
<a name="ln424">    sqlite3_finalize(stmt);</a>
<a name="ln425">    g_free(query);</a>
<a name="ln426">  }</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">void dt_collection_set_sort(const dt_collection_t *collection, dt_collection_sort_t sort, gboolean reverse)</a>
<a name="ln430">{</a>
<a name="ln431">  dt_collection_params_t *params = (dt_collection_params_t *)&amp;collection-&gt;params;</a>
<a name="ln432"> </a>
<a name="ln433">  if(sort != DT_COLLECTION_SORT_NONE) params-&gt;sort = sort;</a>
<a name="ln434">  if(reverse != -1) params-&gt;descending = reverse;</a>
<a name="ln435"> </a>
<a name="ln436">  _collection_update_aspect_ratio(collection);</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">dt_collection_sort_t dt_collection_get_sort_field(const dt_collection_t *collection)</a>
<a name="ln440">{</a>
<a name="ln441">  return collection-&gt;params.sort;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">gboolean dt_collection_get_sort_descending(const dt_collection_t *collection)</a>
<a name="ln445">{</a>
<a name="ln446">  return collection-&gt;params.descending;</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">gchar *dt_collection_get_sort_query(const dt_collection_t *collection)</a>
<a name="ln450">{</a>
<a name="ln451">  gchar *sq = NULL;</a>
<a name="ln452"> </a>
<a name="ln453">  if(collection-&gt;params.descending)</a>
<a name="ln454">  {</a>
<a name="ln455">    switch(collection-&gt;params.sort)</a>
<a name="ln456">    {</a>
<a name="ln457">      case DT_COLLECTION_SORT_DATETIME:</a>
<a name="ln458">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;datetime_taken DESC, filename DESC, version DESC&quot;);</a>
<a name="ln459">        break;</a>
<a name="ln460"> </a>
<a name="ln461">      case DT_COLLECTION_SORT_RATING:</a>
<a name="ln462">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;flags &amp; 7, filename DESC, version DESC&quot;);</a>
<a name="ln463">        break;</a>
<a name="ln464"> </a>
<a name="ln465">      case DT_COLLECTION_SORT_FILENAME:</a>
<a name="ln466">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;filename DESC, version DESC&quot;);</a>
<a name="ln467">        break;</a>
<a name="ln468"> </a>
<a name="ln469">      case DT_COLLECTION_SORT_ID:</a>
<a name="ln470">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;id DESC&quot;);</a>
<a name="ln471">        break;</a>
<a name="ln472"> </a>
<a name="ln473">      case DT_COLLECTION_SORT_COLOR:</a>
<a name="ln474">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;color, filename DESC, version DESC&quot;);</a>
<a name="ln475">        break;</a>
<a name="ln476"> </a>
<a name="ln477">      case DT_COLLECTION_SORT_GROUP:</a>
<a name="ln478">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;group_id DESC, id-group_id != 0, id DESC&quot;);</a>
<a name="ln479">        break;</a>
<a name="ln480"> </a>
<a name="ln481">      case DT_COLLECTION_SORT_PATH:</a>
<a name="ln482">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;folder DESC, filename DESC, version DESC&quot;);</a>
<a name="ln483">        break;</a>
<a name="ln484"> </a>
<a name="ln485">      case DT_COLLECTION_SORT_CUSTOM_ORDER:</a>
<a name="ln486">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;position DESC, filename DESC, version DESC&quot;);</a>
<a name="ln487">        break;</a>
<a name="ln488"> </a>
<a name="ln489">      case DT_COLLECTION_SORT_TITLE:</a>
<a name="ln490">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;m.value DESC, caption DESC, filename DESC, version DESC&quot;);</a>
<a name="ln491">        break;</a>
<a name="ln492"> </a>
<a name="ln493">      case DT_COLLECTION_SORT_DESCRIPTION:</a>
<a name="ln494">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;m.value DESC, description DESC, filename DESC, version DESC&quot;);</a>
<a name="ln495">        break;</a>
<a name="ln496"> </a>
<a name="ln497">      case DT_COLLECTION_SORT_ASPECT_RATIO:</a>
<a name="ln498">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;aspect_ratio DESC, filename DESC, version DESC&quot;);</a>
<a name="ln499">        break;</a>
<a name="ln500"> </a>
<a name="ln501">      case DT_COLLECTION_SORT_SHUFFLE:</a>
<a name="ln502">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;RANDOM()&quot;);</a>
<a name="ln503">        break;</a>
<a name="ln504"> </a>
<a name="ln505">      case DT_COLLECTION_SORT_NONE:</a>
<a name="ln506">        // shouldn't happen</a>
<a name="ln507">        break;</a>
<a name="ln508">    }</a>
<a name="ln509">  }</a>
<a name="ln510">  else</a>
<a name="ln511">  {</a>
<a name="ln512">    switch(collection-&gt;params.sort)</a>
<a name="ln513">    {</a>
<a name="ln514">      case DT_COLLECTION_SORT_DATETIME:</a>
<a name="ln515">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;datetime_taken, filename, version&quot;);</a>
<a name="ln516">        break;</a>
<a name="ln517"> </a>
<a name="ln518">      case DT_COLLECTION_SORT_RATING:</a>
<a name="ln519">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;flags &amp; 7 DESC, filename, version&quot;);</a>
<a name="ln520">        break;</a>
<a name="ln521"> </a>
<a name="ln522">      case DT_COLLECTION_SORT_FILENAME:</a>
<a name="ln523">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;filename, version&quot;);</a>
<a name="ln524">        break;</a>
<a name="ln525"> </a>
<a name="ln526">      case DT_COLLECTION_SORT_ID:</a>
<a name="ln527">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;id&quot;);</a>
<a name="ln528">        break;</a>
<a name="ln529"> </a>
<a name="ln530">      case DT_COLLECTION_SORT_COLOR:</a>
<a name="ln531">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;color DESC, filename, version&quot;);</a>
<a name="ln532">        break;</a>
<a name="ln533"> </a>
<a name="ln534">      case DT_COLLECTION_SORT_GROUP:</a>
<a name="ln535">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;group_id, id-group_id != 0, id&quot;);</a>
<a name="ln536">        break;</a>
<a name="ln537"> </a>
<a name="ln538">      case DT_COLLECTION_SORT_PATH:</a>
<a name="ln539">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;folder, filename, version&quot;);</a>
<a name="ln540">        break;</a>
<a name="ln541"> </a>
<a name="ln542">      case DT_COLLECTION_SORT_CUSTOM_ORDER:</a>
<a name="ln543">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;position, filename, version&quot;);</a>
<a name="ln544">        break;</a>
<a name="ln545"> </a>
<a name="ln546">      case DT_COLLECTION_SORT_TITLE:</a>
<a name="ln547">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;m.value, caption, filename, version&quot;);</a>
<a name="ln548">        break;</a>
<a name="ln549"> </a>
<a name="ln550">      case DT_COLLECTION_SORT_DESCRIPTION:</a>
<a name="ln551">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;m.value, description, filename, version&quot;);</a>
<a name="ln552">        break;</a>
<a name="ln553"> </a>
<a name="ln554">      case DT_COLLECTION_SORT_ASPECT_RATIO:</a>
<a name="ln555">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;aspect_ratio, filename, version&quot;);</a>
<a name="ln556">        break;</a>
<a name="ln557"> </a>
<a name="ln558">      case DT_COLLECTION_SORT_SHUFFLE:</a>
<a name="ln559">        sq = dt_util_dstrcat(sq, ORDER_BY_QUERY, &quot;RANDOM()&quot;);</a>
<a name="ln560">        break;</a>
<a name="ln561"> </a>
<a name="ln562">      case DT_COLLECTION_SORT_NONE:</a>
<a name="ln563">        // shouldn't happen</a>
<a name="ln564">        break;</a>
<a name="ln565">    }</a>
<a name="ln566">  }</a>
<a name="ln567"> </a>
<a name="ln568">  return sq;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571"> </a>
<a name="ln572">static int _dt_collection_store(const dt_collection_t *collection, gchar *query, gchar *query_no_group)</a>
<a name="ln573">{</a>
<a name="ln574">  /* store flags to conf */</a>
<a name="ln575">  if(collection == darktable.collection)</a>
<a name="ln576">  {</a>
<a name="ln577">    dt_conf_set_int(&quot;plugins/collection/query_flags&quot;, collection-&gt;params.query_flags);</a>
<a name="ln578">    dt_conf_set_int(&quot;plugins/collection/filter_flags&quot;, collection-&gt;params.filter_flags);</a>
<a name="ln579">    dt_conf_set_int(&quot;plugins/collection/film_id&quot;, collection-&gt;params.film_id);</a>
<a name="ln580">    dt_conf_set_int(&quot;plugins/collection/rating&quot;, collection-&gt;params.rating);</a>
<a name="ln581">    dt_conf_set_int(&quot;plugins/collection/rating_comparator&quot;, collection-&gt;params.comparator);</a>
<a name="ln582">    dt_conf_set_int(&quot;plugins/collection/sort&quot;, collection-&gt;params.sort);</a>
<a name="ln583">    dt_conf_set_bool(&quot;plugins/collection/descending&quot;, collection-&gt;params.descending);</a>
<a name="ln584">  }</a>
<a name="ln585"> </a>
<a name="ln586">  /* store query in context */</a>
<a name="ln587">  g_free(collection-&gt;query);</a>
<a name="ln588">  g_free(collection-&gt;query_no_group);</a>
<a name="ln589"> </a>
<a name="ln590">  ((dt_collection_t *)collection)-&gt;query = g_strdup(query);</a>
<a name="ln591">  ((dt_collection_t *)collection)-&gt;query_no_group = g_strdup(query_no_group);</a>
<a name="ln592"> </a>
<a name="ln593">  return 1;</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">static uint32_t _dt_collection_compute_count(const dt_collection_t *collection, gboolean no_group)</a>
<a name="ln597">{</a>
<a name="ln598">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln599">  uint32_t count = 1;</a>
<a name="ln600">  const gchar *query = no_group ? dt_collection_get_query_no_group(collection) : dt_collection_get_query(collection);</a>
<a name="ln601">  gchar *count_query = NULL;</a>
<a name="ln602"> </a>
<a name="ln603">  gchar *fq = g_strstr_len(query, strlen(query), &quot;FROM&quot;);</a>
<a name="ln604">  if((collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_ONLY_WHERE_EXT))</a>
<a name="ln605">  {</a>
<a name="ln606">    gchar *where_ext = dt_collection_get_extended_where(collection, -1);</a>
<a name="ln607">    count_query = dt_util_dstrcat(NULL, &quot;SELECT COUNT(DISTINCT main.images.id) FROM main.images %s&quot;, where_ext);</a>
<a name="ln608">    g_free(where_ext);</a>
<a name="ln609">  }</a>
<a name="ln610">  else</a>
<a name="ln611">    count_query = dt_util_dstrcat(count_query, &quot;SELECT COUNT(DISTINCT a.id) %s&quot;, fq);</a>
<a name="ln612"> </a>
<a name="ln613">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), count_query, -1, &amp;stmt, NULL);</a>
<a name="ln614">  if((collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_LIMIT)</a>
<a name="ln615">     &amp;&amp; !(collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_ONLY_WHERE_EXT))</a>
<a name="ln616">  {</a>
<a name="ln617">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, 0);</a>
<a name="ln618">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, -1);</a>
<a name="ln619">  }</a>
<a name="ln620"> </a>
<a name="ln621">  if(sqlite3_step(stmt) == SQLITE_ROW) count = sqlite3_column_int(stmt, 0);</a>
<a name="ln622">  sqlite3_finalize(stmt);</a>
<a name="ln623">  g_free(count_query);</a>
<a name="ln624">  return count;</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627">uint32_t dt_collection_get_count(const dt_collection_t *collection)</a>
<a name="ln628">{</a>
<a name="ln629">  return collection-&gt;count;</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">uint32_t dt_collection_get_count_no_group(const dt_collection_t *collection)</a>
<a name="ln633">{</a>
<a name="ln634">  return collection-&gt;count_no_group;</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637">uint32_t dt_collection_get_selected_count(const dt_collection_t *collection)</a>
<a name="ln638">{</a>
<a name="ln639">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln640">  uint32_t count = 0;</a>
<a name="ln641">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln642">                              &quot;SELECT COUNT(*) FROM main.selected_images&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln643">  if(sqlite3_step(stmt) == SQLITE_ROW) count = sqlite3_column_int(stmt, 0);</a>
<a name="ln644">  sqlite3_finalize(stmt);</a>
<a name="ln645">  return count;</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648">GList *dt_collection_get(const dt_collection_t *collection, int limit, gboolean selected)</a>
<a name="ln649">{</a>
<a name="ln650">  GList *list = NULL;</a>
<a name="ln651">  const gchar *query = dt_collection_get_query(collection);</a>
<a name="ln652">  if(query)</a>
<a name="ln653">  {</a>
<a name="ln654">    sqlite3_stmt *stmt = NULL;</a>
<a name="ln655">    gchar *q;</a>
<a name="ln656"> </a>
<a name="ln657">    if(selected)</a>
<a name="ln658">      q = g_strdup_printf(&quot;SELECT id FROM main.selected_images AS s JOIN (%s) AS a WHERE a.id = s.imgid LIMIT -1, ?3&quot;, query);</a>
<a name="ln659">    else</a>
<a name="ln660">      q = g_strdup_printf(&quot;%s&quot;, query);</a>
<a name="ln661"> </a>
<a name="ln662">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), q, -1, &amp;stmt, NULL);</a>
<a name="ln663"> </a>
<a name="ln664">    if(selected)</a>
<a name="ln665">    {</a>
<a name="ln666">      if(collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_LIMIT)</a>
<a name="ln667">      {</a>
<a name="ln668">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, -1);</a>
<a name="ln669">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, -1);</a>
<a name="ln670">      }</a>
<a name="ln671"> </a>
<a name="ln672">      // the limit is done on the main select and not on the JOIN</a>
<a name="ln673">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, limit);</a>
<a name="ln674">    }</a>
<a name="ln675">    else</a>
<a name="ln676">    {</a>
<a name="ln677">      if(collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_LIMIT)</a>
<a name="ln678">      {</a>
<a name="ln679">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, -1);</a>
<a name="ln680">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, limit);</a>
<a name="ln681">      }</a>
<a name="ln682">    }</a>
<a name="ln683"> </a>
<a name="ln684">    while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln685">    {</a>
<a name="ln686">      const int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln687">      list = g_list_append(list, GINT_TO_POINTER(imgid));</a>
<a name="ln688">    }</a>
<a name="ln689"> </a>
<a name="ln690">    sqlite3_finalize(stmt);</a>
<a name="ln691">    g_free(q);</a>
<a name="ln692">  }</a>
<a name="ln693"> </a>
<a name="ln694">  return list;</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">GList *dt_collection_get_all(const dt_collection_t *collection, int limit)</a>
<a name="ln698">{</a>
<a name="ln699">  return dt_collection_get(collection, limit, FALSE);</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">int dt_collection_get_nth(const dt_collection_t *collection, int nth)</a>
<a name="ln703">{</a>
<a name="ln704">  if(nth &lt; 0 || nth &gt;= dt_collection_get_count(collection))</a>
<a name="ln705">    return -1;</a>
<a name="ln706">  const gchar *query = dt_collection_get_query(collection);</a>
<a name="ln707">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln708">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln709">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, nth);</a>
<a name="ln710">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, 1);</a>
<a name="ln711"> </a>
<a name="ln712">  int result = -1;</a>
<a name="ln713">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln714">  {</a>
<a name="ln715">    result  = sqlite3_column_int(stmt, 0);</a>
<a name="ln716">  }</a>
<a name="ln717"> </a>
<a name="ln718">  sqlite3_finalize(stmt);</a>
<a name="ln719"> </a>
<a name="ln720">  return result;</a>
<a name="ln721"> </a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724">GList *dt_collection_get_selected(const dt_collection_t *collection, int limit)</a>
<a name="ln725">{</a>
<a name="ln726">  return dt_collection_get(collection, limit, TRUE);</a>
<a name="ln727">}</a>
<a name="ln728"> </a>
<a name="ln729">/* splits an input string into a number part and an optional operator part.</a>
<a name="ln730">   number can be a decimal integer or rational numerical item.</a>
<a name="ln731">   operator can be any of &quot;=&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot; and &quot;&lt;&gt;&quot;.</a>
<a name="ln732">   range notation [x;y] can also be used</a>
<a name="ln733"> </a>
<a name="ln734">   number and operator are returned as pointers to null terminated strings in g_mallocated</a>
<a name="ln735">   memory (to be g_free'd after use) - or NULL if no match is found.</a>
<a name="ln736">*/</a>
<a name="ln737">void dt_collection_split_operator_number(const gchar *input, char **number1, char **number2, char **operator)</a>
<a name="ln738">{</a>
<a name="ln739">  GRegex *regex;</a>
<a name="ln740">  GMatchInfo *match_info;</a>
<a name="ln741">  int match_count;</a>
<a name="ln742"> </a>
<a name="ln743">  *number1 = *number2 = *operator= NULL;</a>
<a name="ln744"> </a>
<a name="ln745">  // we test the range expression first</a>
<a name="ln746">  regex = g_regex_new(&quot;^\\s*\\[\\s*([0-9]+\\.?[0-9]*)\\s*;\\s*([0-9]+\\.?[0-9]*)\\s*\\]\\s*$&quot;, 0, 0, NULL);</a>
<a name="ln747">  g_regex_match_full(regex, input, -1, 0, 0, &amp;match_info, NULL);</a>
<a name="ln748">  match_count = g_match_info_get_match_count(match_info);</a>
<a name="ln749"> </a>
<a name="ln750">  if(match_count == 3)</a>
<a name="ln751">  {</a>
<a name="ln752">    *number1 = g_match_info_fetch(match_info, 1);</a>
<a name="ln753">    *number2 = g_match_info_fetch(match_info, 2);</a>
<a name="ln754">    *operator= g_strdup(&quot;[]&quot;);</a>
<a name="ln755">    g_match_info_free(match_info);</a>
<a name="ln756">    g_regex_unref(regex);</a>
<a name="ln757">    return;</a>
<a name="ln758">  }</a>
<a name="ln759"> </a>
<a name="ln760">  g_match_info_free(match_info);</a>
<a name="ln761">  g_regex_unref(regex);</a>
<a name="ln762"> </a>
<a name="ln763">  // and we test the classic comparison operators</a>
<a name="ln764">  regex = g_regex_new(&quot;^\\s*(=|&lt;|&gt;|&lt;=|&gt;=|&lt;&gt;)?\\s*([0-9]+\\.?[0-9]*)\\s*$&quot;, 0, 0, NULL);</a>
<a name="ln765">  g_regex_match_full(regex, input, -1, 0, 0, &amp;match_info, NULL);</a>
<a name="ln766">  match_count = g_match_info_get_match_count(match_info);</a>
<a name="ln767"> </a>
<a name="ln768">  if(match_count == 3)</a>
<a name="ln769">  {</a>
<a name="ln770">    *operator= g_match_info_fetch(match_info, 1);</a>
<a name="ln771">    *number1 = g_match_info_fetch(match_info, 2);</a>
<a name="ln772"> </a>
<a name="ln773">    if(*operator &amp;&amp; strcmp(*operator, &quot;&quot;) == 0)</a>
<a name="ln774">    {</a>
<a name="ln775">      g_free(*operator);</a>
<a name="ln776">      *operator= NULL;</a>
<a name="ln777">    }</a>
<a name="ln778">  }</a>
<a name="ln779"> </a>
<a name="ln780">  g_match_info_free(match_info);</a>
<a name="ln781">  g_regex_unref(regex);</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784">static char *_dt_collection_compute_datetime(const char *operator, const char *input)</a>
<a name="ln785">{</a>
<a name="ln786">  int len = strlen(input);</a>
<a name="ln787">  if(len &lt; 4) return NULL;</a>
<a name="ln788"> </a>
<a name="ln789">  struct tm tm1 = { 0 };</a>
<a name="ln790"> </a>
<a name="ln791">  // we initialise all the values of tm, depending of the operator</a>
<a name="ln792">  // we allow unreal values like &quot;2014:02:31&quot; as it's just text comparison at the end</a>
<a name="ln793">  if(strcmp(operator, &quot;&gt;&quot;) == 0 || strcmp(operator, &quot;&lt;=&quot;) == 0)</a>
<a name="ln794">  {</a>
<a name="ln795">    // we set all values to their maximum</a>
<a name="ln796">    tm1.tm_mon = 11;</a>
<a name="ln797">    tm1.tm_mday = 31;</a>
<a name="ln798">    tm1.tm_hour = 23;</a>
<a name="ln799">    tm1.tm_min = 59;</a>
<a name="ln800">    tm1.tm_sec = 59;</a>
<a name="ln801">  }</a>
<a name="ln802"> </a>
<a name="ln803">  // we read the input date, depending of his length</a>
<a name="ln804">  if(len &lt; 7)</a>
<a name="ln805">  {</a>
<a name="ln806">    if(!strptime(input, &quot;%Y&quot;, &amp;tm1)) return NULL;</a>
<a name="ln807">  }</a>
<a name="ln808">  else if(len &lt; 10)</a>
<a name="ln809">  {</a>
<a name="ln810">    if(!strptime(input, &quot;%Y:%m&quot;, &amp;tm1)) return NULL;</a>
<a name="ln811">  }</a>
<a name="ln812">  else if(len &lt; 13)</a>
<a name="ln813">  {</a>
<a name="ln814">    if(!strptime(input, &quot;%Y:%m:%d&quot;, &amp;tm1)) return NULL;</a>
<a name="ln815">  }</a>
<a name="ln816">  else if(len &lt; 16)</a>
<a name="ln817">  {</a>
<a name="ln818">    if(!strptime(input, &quot;%Y:%m:%d %H&quot;, &amp;tm1)) return NULL;</a>
<a name="ln819">  }</a>
<a name="ln820">  else if(len &lt; 19)</a>
<a name="ln821">  {</a>
<a name="ln822">    if(!strptime(input, &quot;%Y:%m:%d %H:%M&quot;, &amp;tm1)) return NULL;</a>
<a name="ln823">  }</a>
<a name="ln824">  else</a>
<a name="ln825">  {</a>
<a name="ln826">    if(!strptime(input, &quot;%Y:%m:%d %H:%M:%S&quot;, &amp;tm1)) return NULL;</a>
<a name="ln827">  }</a>
<a name="ln828"> </a>
<a name="ln829">  // we return the created date</a>
<a name="ln830">  char *ret = (char *)g_malloc0_n(20, sizeof(char));</a>
<a name="ln831">  strftime(ret, 20, &quot;%Y:%m:%d %H:%M:%S&quot;, &amp;tm1);</a>
<a name="ln832">  return ret;</a>
<a name="ln833">}</a>
<a name="ln834">/* splits an input string into a date-time part and an optional operator part.</a>
<a name="ln835">   operator can be any of &quot;=&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot; and &quot;&lt;&gt;&quot;.</a>
<a name="ln836">   range notation [x;y] can also be used</a>
<a name="ln837">   datetime values should follow the pattern YYYY:mm:dd HH:MM:SS</a>
<a name="ln838">   but only year part is mandatory</a>
<a name="ln839"> </a>
<a name="ln840">   datetime and operator are returned as pointers to null terminated strings in g_mallocated</a>
<a name="ln841">   memory (to be g_free'd after use) - or NULL if no match is found.</a>
<a name="ln842">*/</a>
<a name="ln843">void dt_collection_split_operator_datetime(const gchar *input, char **number1, char **number2, char **operator)</a>
<a name="ln844">{</a>
<a name="ln845">  GRegex *regex;</a>
<a name="ln846">  GMatchInfo *match_info;</a>
<a name="ln847">  int match_count;</a>
<a name="ln848"> </a>
<a name="ln849">  *number1 = *number2 = *operator= NULL;</a>
<a name="ln850"> </a>
<a name="ln851">  // we test the range expression first</a>
<a name="ln852">  // 2 elements : date-time1 and  date-time2</a>
<a name="ln853">  regex = g_regex_new(&quot;^\\s*\\[\\s*(\\d{4}[:\\d\\s]*)\\s*;\\s*(\\d{4}[:\\d\\s]*)\\s*\\]\\s*$&quot;, 0, 0, NULL);</a>
<a name="ln854">  g_regex_match_full(regex, input, -1, 0, 0, &amp;match_info, NULL);</a>
<a name="ln855">  match_count = g_match_info_get_match_count(match_info);</a>
<a name="ln856"> </a>
<a name="ln857">  if(match_count == 3)</a>
<a name="ln858">  {</a>
<a name="ln859">    gchar *txt = g_match_info_fetch(match_info, 1);</a>
<a name="ln860">    gchar *txt2 = g_match_info_fetch(match_info, 2);</a>
<a name="ln861"> </a>
<a name="ln862">    *number1 = _dt_collection_compute_datetime(&quot;&gt;=&quot;, txt);</a>
<a name="ln863">    *number2 = _dt_collection_compute_datetime(&quot;&lt;=&quot;, txt2);</a>
<a name="ln864">    *operator= g_strdup(&quot;[]&quot;);</a>
<a name="ln865"> </a>
<a name="ln866">    g_free(txt);</a>
<a name="ln867">    g_free(txt2);</a>
<a name="ln868">    g_match_info_free(match_info);</a>
<a name="ln869">    g_regex_unref(regex);</a>
<a name="ln870">    return;</a>
<a name="ln871">  }</a>
<a name="ln872"> </a>
<a name="ln873">  g_match_info_free(match_info);</a>
<a name="ln874">  g_regex_unref(regex);</a>
<a name="ln875"> </a>
<a name="ln876">  // and we test the classic comparison operators</a>
<a name="ln877">  // 2 elements : operator and date-time</a>
<a name="ln878">  regex = g_regex_new(&quot;^\\s*(=|&lt;|&gt;|&lt;=|&gt;=|&lt;&gt;)?\\s*(\\d{4}[:\\d\\s]*)?\\s*%?\\s*$&quot;, 0, 0, NULL);</a>
<a name="ln879">  g_regex_match_full(regex, input, -1, 0, 0, &amp;match_info, NULL);</a>
<a name="ln880">  match_count = g_match_info_get_match_count(match_info);</a>
<a name="ln881"> </a>
<a name="ln882">  if(match_count == 3)</a>
<a name="ln883">  {</a>
<a name="ln884">    *operator= g_match_info_fetch(match_info, 1);</a>
<a name="ln885">    gchar *txt = g_match_info_fetch(match_info, 2);</a>
<a name="ln886"> </a>
<a name="ln887">    if(strcmp(*operator, &quot;&quot;) == 0 || strcmp(*operator, &quot;=&quot;) == 0 || strcmp(*operator, &quot;&lt;&gt;&quot;) == 0)</a>
<a name="ln888">      *number1 = dt_util_dstrcat(*number1, &quot;%s%%&quot;, txt);</a>
<a name="ln889">    else</a>
<a name="ln890">      *number1 = _dt_collection_compute_datetime(*operator, txt);</a>
<a name="ln891"> </a>
<a name="ln892">    g_free(txt);</a>
<a name="ln893">  }</a>
<a name="ln894"> </a>
<a name="ln895">  // ensure operator is not null</a>
<a name="ln896">  if(!*operator) *operator= g_strdup(&quot;&quot;);</a>
<a name="ln897"> </a>
<a name="ln898">  g_match_info_free(match_info);</a>
<a name="ln899">  g_regex_unref(regex);</a>
<a name="ln900">}</a>
<a name="ln901"> </a>
<a name="ln902">void dt_collection_split_operator_exposure(const gchar *input, char **number1, char **number2, char **operator)</a>
<a name="ln903">{</a>
<a name="ln904">  GRegex *regex;</a>
<a name="ln905">  GMatchInfo *match_info;</a>
<a name="ln906">  int match_count;</a>
<a name="ln907"> </a>
<a name="ln908">  *number1 = *number2 = *operator= NULL;</a>
<a name="ln909"> </a>
<a name="ln910">  // we test the range expression first</a>
<a name="ln911">  regex = g_regex_new(&quot;^\\s*\\[\\s*(1/)?([0-9]+\\.?[0-9]*)(\&quot;)?\\s*;\\s*(1/)?([0-9]+\\.?[0-9]*)(\&quot;)?\\s*\\]\\s*$&quot;, 0, 0, NULL);</a>
<a name="ln912">  g_regex_match_full(regex, input, -1, 0, 0, &amp;match_info, NULL);</a>
<a name="ln913">  match_count = g_match_info_get_match_count(match_info);</a>
<a name="ln914"> </a>
<a name="ln915">  if(match_count == 6 || match_count == 7)</a>
<a name="ln916">  {</a>
<a name="ln917">    gchar *n1 = g_match_info_fetch(match_info, 2);</a>
<a name="ln918"> </a>
<a name="ln919">    if(strstr(g_match_info_fetch(match_info, 1), &quot;1/&quot;) != NULL)</a>
<a name="ln920">      *number1 = dt_util_dstrcat(NULL, &quot;1.0/%s&quot;, n1);</a>
<a name="ln921">    else</a>
<a name="ln922">      *number1 = n1;</a>
<a name="ln923"> </a>
<a name="ln924">    gchar *n2 = g_match_info_fetch(match_info, 5);</a>
<a name="ln925"> </a>
<a name="ln926">    if(strstr(g_match_info_fetch(match_info, 4), &quot;1/&quot;) != NULL)</a>
<a name="ln927">      *number2 = dt_util_dstrcat(NULL, &quot;1.0/%s&quot;, n2);</a>
<a name="ln928">    else</a>
<a name="ln929">      *number2 = n2;</a>
<a name="ln930"> </a>
<a name="ln931">    *operator= g_strdup(&quot;[]&quot;);</a>
<a name="ln932">    g_match_info_free(match_info);</a>
<a name="ln933">    g_regex_unref(regex);</a>
<a name="ln934">    return;</a>
<a name="ln935">  }</a>
<a name="ln936"> </a>
<a name="ln937">  g_match_info_free(match_info);</a>
<a name="ln938">  g_regex_unref(regex);</a>
<a name="ln939"> </a>
<a name="ln940">  // and we test the classic comparison operators</a>
<a name="ln941">  regex = g_regex_new(&quot;^\\s*(=|&lt;|&gt;|&lt;=|&gt;=|&lt;&gt;)?\\s*(1/)?([0-9]+\\.?[0-9]*)(\&quot;)?\\s*$&quot;, 0, 0, NULL);</a>
<a name="ln942">  g_regex_match_full(regex, input, -1, 0, 0, &amp;match_info, NULL);</a>
<a name="ln943">  match_count = g_match_info_get_match_count(match_info);</a>
<a name="ln944">  if(match_count == 4 || match_count == 5)</a>
<a name="ln945">  {</a>
<a name="ln946">    *operator= g_match_info_fetch(match_info, 1);</a>
<a name="ln947"> </a>
<a name="ln948">    gchar *n1 = g_match_info_fetch(match_info, 3);</a>
<a name="ln949"> </a>
<a name="ln950">    if(strstr(g_match_info_fetch(match_info, 2), &quot;1/&quot;) != NULL)</a>
<a name="ln951">      *number1 = dt_util_dstrcat(NULL, &quot;1.0/%s&quot;, n1);</a>
<a name="ln952">    else</a>
<a name="ln953">      *number1 = n1;</a>
<a name="ln954"> </a>
<a name="ln955">    if(*operator &amp;&amp; strcmp(*operator, &quot;&quot;) == 0)</a>
<a name="ln956">    {</a>
<a name="ln957">      g_free(*operator);</a>
<a name="ln958">      *operator= NULL;</a>
<a name="ln959">    }</a>
<a name="ln960">  }</a>
<a name="ln961"> </a>
<a name="ln962">  g_match_info_free(match_info);</a>
<a name="ln963">  g_regex_unref(regex);</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966">void dt_collection_get_makermodels(const gchar *filter, GList **sanitized, GList **exif)</a>
<a name="ln967">{</a>
<a name="ln968">  sqlite3_stmt *stmt;</a>
<a name="ln969">  gchar *needle = NULL;</a>
<a name="ln970"> </a>
<a name="ln971">  GHashTable *names = NULL;</a>
<a name="ln972">  if (sanitized)</a>
<a name="ln973">    names = g_hash_table_new(g_str_hash, g_str_equal);</a>
<a name="ln974"> </a>
<a name="ln975">  if (filter &amp;&amp; filter[0] != '\0')</a>
<a name="ln976">    needle = g_utf8_strdown(filter, -1);</a>
<a name="ln977"> </a>
<a name="ln978">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln979">                              &quot;SELECT maker, model FROM main.images GROUP BY maker, model&quot;,</a>
<a name="ln980">                              -1, &amp;stmt, NULL);</a>
<a name="ln981">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln982">  {</a>
<a name="ln983">    char *exif_maker = (char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln984">    char *exif_model = (char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln985"> </a>
<a name="ln986">    gchar *makermodel =  dt_collection_get_makermodel(exif_maker, exif_model);</a>
<a name="ln987"> </a>
<a name="ln988">    gchar *haystack = g_utf8_strdown(makermodel, -1);</a>
<a name="ln989">    if (!needle || g_strrstr(haystack, needle) != NULL)</a>
<a name="ln990">    {</a>
<a name="ln991">      if (exif)</a>
<a name="ln992">      {</a>
<a name="ln993">        // Append a two element list with maker and model</a>
<a name="ln994">        GList *inner_list = NULL;</a>
<a name="ln995">        inner_list = g_list_append(inner_list, g_strdup(exif_maker));</a>
<a name="ln996">        inner_list = g_list_append(inner_list, g_strdup(exif_model));</a>
<a name="ln997">        *exif = g_list_append(*exif, inner_list);</a>
<a name="ln998">      }</a>
<a name="ln999"> </a>
<a name="ln1000">      if (sanitized)</a>
<a name="ln1001">      {</a>
<a name="ln1002">        gchar *key = g_strdup(makermodel);</a>
<a name="ln1003">        g_hash_table_add(names, key);</a>
<a name="ln1004">      }</a>
<a name="ln1005">    }</a>
<a name="ln1006">    g_free(haystack);</a>
<a name="ln1007">    g_free(makermodel);</a>
<a name="ln1008">  }</a>
<a name="ln1009">  sqlite3_finalize(stmt);</a>
<a name="ln1010">  g_free(needle);</a>
<a name="ln1011"> </a>
<a name="ln1012">  if(sanitized)</a>
<a name="ln1013">  {</a>
<a name="ln1014">    *sanitized = g_list_sort(g_hash_table_get_keys(names), (GCompareFunc) strcmp);</a>
<a name="ln1015">    g_hash_table_destroy(names);</a>
<a name="ln1016">  }</a>
<a name="ln1017">}</a>
<a name="ln1018"> </a>
<a name="ln1019">gchar *dt_collection_get_makermodel(const char *exif_maker, const char *exif_model)</a>
<a name="ln1020">{</a>
<a name="ln1021">  gchar *makermodel = NULL;</a>
<a name="ln1022"> </a>
<a name="ln1023">  char maker[64];</a>
<a name="ln1024">  char model[64];</a>
<a name="ln1025">  char alias[64];</a>
<a name="ln1026">  maker[0] = model[0] = alias[0] = '\0';</a>
<a name="ln1027">  dt_rawspeed_lookup_makermodel(exif_maker, exif_model,</a>
<a name="ln1028">                                maker, sizeof(maker),</a>
<a name="ln1029">                                model, sizeof(model),</a>
<a name="ln1030">                                alias, sizeof(alias));</a>
<a name="ln1031"> </a>
<a name="ln1032">  // Create the makermodel by concatenation</a>
<a name="ln1033"> </a>
<a name="ln1034">  makermodel = dt_util_dstrcat(makermodel, &quot;%s %s&quot;, maker, model);</a>
<a name="ln1035"> </a>
<a name="ln1036">  return makermodel;</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">static gchar *get_query_string(const dt_collection_properties_t property, const gchar *text)</a>
<a name="ln1040">{</a>
<a name="ln1041">  char *escaped_text = sqlite3_mprintf(&quot;%q&quot;, text);</a>
<a name="ln1042">  gchar *query = NULL;</a>
<a name="ln1043"> </a>
<a name="ln1044">  switch(property)</a>
<a name="ln1045">  {</a>
<a name="ln1046">    case DT_COLLECTION_PROP_FILMROLL: // film roll</a>
<a name="ln1047">      if(!(escaped_text &amp;&amp; *escaped_text))</a>
<a name="ln1048">        query = dt_util_dstrcat(query, &quot;(film_id IN (SELECT id FROM main.film_rolls WHERE folder LIKE '%s%%'))&quot;,</a>
<a name="ln1049">                                escaped_text);</a>
<a name="ln1050">      else</a>
<a name="ln1051">        query = dt_util_dstrcat(query, &quot;(film_id IN (SELECT id FROM main.film_rolls WHERE folder LIKE '%s'))&quot;,</a>
<a name="ln1052">                                escaped_text);</a>
<a name="ln1053">      break;</a>
<a name="ln1054"> </a>
<a name="ln1055">    case DT_COLLECTION_PROP_FOLDERS: // folders</a>
<a name="ln1056">      query = dt_util_dstrcat(</a>
<a name="ln1057">          query, &quot;(film_id IN (SELECT id FROM main.film_rolls WHERE folder LIKE '%1$s' OR folder LIKE '%1$s&quot;</a>
<a name="ln1058">                 G_DIR_SEPARATOR_S &quot;%%'))&quot;,</a>
<a name="ln1059">          escaped_text);</a>
<a name="ln1060">      break;</a>
<a name="ln1061"> </a>
<a name="ln1062">    case DT_COLLECTION_PROP_COLORLABEL: // colorlabel</a>
<a name="ln1063">    {</a>
<a name="ln1064">      int color = 0;</a>
<a name="ln1065">      if(!(escaped_text &amp;&amp; *escaped_text) || strcmp(escaped_text, &quot;%&quot;) == 0)</a>
<a name="ln1066">        query = dt_util_dstrcat(query, &quot;(id IN (SELECT imgid FROM main.color_labels WHERE color IS NOT NULL))&quot;);</a>
<a name="ln1067">      else</a>
<a name="ln1068">      {</a>
<a name="ln1069">        if(strcmp(escaped_text, _(&quot;red&quot;)) == 0)</a>
<a name="ln1070">          color = 0;</a>
<a name="ln1071">        else if(strcmp(escaped_text, _(&quot;yellow&quot;)) == 0)</a>
<a name="ln1072">          color = 1;</a>
<a name="ln1073">        else if(strcmp(escaped_text, _(&quot;green&quot;)) == 0)</a>
<a name="ln1074">          color = 2;</a>
<a name="ln1075">        else if(strcmp(escaped_text, _(&quot;blue&quot;)) == 0)</a>
<a name="ln1076">          color = 3;</a>
<a name="ln1077">        else if(strcmp(escaped_text, _(&quot;purple&quot;)) == 0)</a>
<a name="ln1078">          color = 4;</a>
<a name="ln1079">        query = dt_util_dstrcat(query, &quot;(id IN (SELECT imgid FROM main.color_labels WHERE color=%d))&quot;, color);</a>
<a name="ln1080">      }</a>
<a name="ln1081">    }</a>
<a name="ln1082">    break;</a>
<a name="ln1083"> </a>
<a name="ln1084">    case DT_COLLECTION_PROP_HISTORY: // history</a>
<a name="ln1085">      query = dt_util_dstrcat(query, &quot;(id %s IN (SELECT imgid FROM main.history WHERE imgid=images.id)) &quot;,</a>
<a name="ln1086">                              (strcmp(escaped_text, _(&quot;altered&quot;)) == 0) ? &quot;&quot; : &quot;not&quot;);</a>
<a name="ln1087">      break;</a>
<a name="ln1088"> </a>
<a name="ln1089">    case DT_COLLECTION_PROP_GEOTAGGING: // geotagging</a>
<a name="ln1090">      query = dt_util_dstrcat(query, &quot;(id %s IN (SELECT id AS imgid FROM main.images WHERE &quot;</a>
<a name="ln1091">                                     &quot;(longitude IS NOT NULL AND latitude IS NOT NULL))) &quot;,</a>
<a name="ln1092">                              (strcmp(escaped_text, _(&quot;tagged&quot;)) == 0) ? &quot;&quot; : &quot;not&quot;);</a>
<a name="ln1093">      break;</a>
<a name="ln1094"> </a>
<a name="ln1095">    case DT_COLLECTION_PROP_LOCAL_COPY: // local copy</a>
<a name="ln1096">      query = dt_util_dstrcat(query, &quot;(id %s IN (SELECT id AS imgid FROM main.images WHERE &quot;</a>
<a name="ln1097">                                     &quot;(flags &amp; %d))) &quot;,</a>
<a name="ln1098">                              (strcmp(escaped_text, _(&quot;not copied locally&quot;)) == 0) ? &quot;not&quot; : &quot;&quot;,</a>
<a name="ln1099">                              DT_IMAGE_LOCAL_COPY);</a>
<a name="ln1100">      break;</a>
<a name="ln1101"> </a>
<a name="ln1102">    case DT_COLLECTION_PROP_ASPECT_RATIO: // aspect ratio</a>
<a name="ln1103">    {</a>
<a name="ln1104">      gchar *operator, *number1, *number2;</a>
<a name="ln1105">      dt_collection_split_operator_number(escaped_text, &amp;number1, &amp;number2, &amp;operator);</a>
<a name="ln1106"> </a>
<a name="ln1107">      if(operator &amp;&amp; strcmp(operator, &quot;[]&quot;) == 0)</a>
<a name="ln1108">      {</a>
<a name="ln1109">        if(number1 &amp;&amp; number2)</a>
<a name="ln1110">          query = dt_util_dstrcat(query, &quot;((aspect_ratio &gt;= %s) AND (aspect_ratio &lt;= %s))&quot;, number1, number2);</a>
<a name="ln1111">      }</a>
<a name="ln1112">      else if(operator &amp;&amp; number1)</a>
<a name="ln1113">        query = dt_util_dstrcat(query, &quot;(aspect_ratio %s %s)&quot;, operator, number1);</a>
<a name="ln1114">      else if(number1)</a>
<a name="ln1115">        query = dt_util_dstrcat(query, &quot;(aspect_ratio = %s)&quot;, number1);</a>
<a name="ln1116">      else</a>
<a name="ln1117">        query = dt_util_dstrcat(query, &quot;(aspect_ratio LIKE '%%%s%%')&quot;, escaped_text);</a>
<a name="ln1118"> </a>
<a name="ln1119">      g_free(operator);</a>
<a name="ln1120">      g_free(number1);</a>
<a name="ln1121">      g_free(number2);</a>
<a name="ln1122">    }</a>
<a name="ln1123">    break;</a>
<a name="ln1124"> </a>
<a name="ln1125">    case DT_COLLECTION_PROP_CAMERA: // camera</a>
<a name="ln1126">      // Start query with a false statement to avoid special casing the first condition</a>
<a name="ln1127">      query = dt_util_dstrcat(query, &quot;((1=0)&quot;);</a>
<a name="ln1128">      GList *lists = NULL;</a>
<a name="ln1129">      dt_collection_get_makermodels(text, NULL, &amp;lists);</a>
<a name="ln1130">      GList *element = lists;</a>
<a name="ln1131">      while (element)</a>
<a name="ln1132">      {</a>
<a name="ln1133">        GList *tuple = element-&gt;data;</a>
<a name="ln1134">        char *mk = sqlite3_mprintf(&quot;%q&quot;, tuple-&gt;data);</a>
<a name="ln1135">        char *md = sqlite3_mprintf(&quot;%q&quot;, tuple-&gt;next-&gt;data);</a>
<a name="ln1136">        query = dt_util_dstrcat(query, &quot; OR (maker = '%s' AND model = '%s')&quot;, mk, md);</a>
<a name="ln1137">        sqlite3_free(mk);</a>
<a name="ln1138">        sqlite3_free(md);</a>
<a name="ln1139">        g_free(tuple-&gt;data);</a>
<a name="ln1140">        g_free(tuple-&gt;next-&gt;data);</a>
<a name="ln1141">        g_list_free(tuple);</a>
<a name="ln1142">        element = element-&gt;next;</a>
<a name="ln1143">      }</a>
<a name="ln1144">      g_list_free(lists);</a>
<a name="ln1145">      query = dt_util_dstrcat(query, &quot;)&quot;);</a>
<a name="ln1146">      break;</a>
<a name="ln1147">    case DT_COLLECTION_PROP_TAG: // tag</a>
<a name="ln1148">      query = dt_util_dstrcat(query, &quot;(id IN (SELECT imgid FROM main.tagged_images AS a JOIN &quot;</a>
<a name="ln1149">                                     &quot;data.tags AS b ON a.tagid = b.id WHERE name LIKE '%s'))&quot;,</a>
<a name="ln1150">                              escaped_text);</a>
<a name="ln1151">      break;</a>
<a name="ln1152"> </a>
<a name="ln1153">    // TODO: How to handle images without metadata? In the moment they are not shown.</a>
<a name="ln1154">    // TODO: Autogenerate this code?</a>
<a name="ln1155">    case DT_COLLECTION_PROP_TITLE: // title</a>
<a name="ln1156">      query = dt_util_dstrcat(query, &quot;(id IN (SELECT id FROM main.meta_data WHERE key = %d AND value &quot;</a>
<a name="ln1157">                                     &quot;LIKE '%%%s%%'))&quot;, DT_METADATA_XMP_DC_TITLE, escaped_text);</a>
<a name="ln1158">      break;</a>
<a name="ln1159">    case DT_COLLECTION_PROP_DESCRIPTION: // description</a>
<a name="ln1160">      query = dt_util_dstrcat(query, &quot;(id IN (SELECT id FROM main.meta_data WHERE key = %d AND value &quot;</a>
<a name="ln1161">                                     &quot;LIKE '%%%s%%'))&quot;, DT_METADATA_XMP_DC_DESCRIPTION, escaped_text);</a>
<a name="ln1162">      break;</a>
<a name="ln1163">    case DT_COLLECTION_PROP_CREATOR: // creator</a>
<a name="ln1164">      query = dt_util_dstrcat(query, &quot;(id IN (SELECT id FROM main.meta_data WHERE key = %d AND value &quot;</a>
<a name="ln1165">                                     &quot;LIKE '%%%s%%'))&quot;, DT_METADATA_XMP_DC_CREATOR, escaped_text);</a>
<a name="ln1166">      break;</a>
<a name="ln1167">    case DT_COLLECTION_PROP_PUBLISHER: // publisher</a>
<a name="ln1168">      query = dt_util_dstrcat(query, &quot;(id IN (SELECT id FROM main.meta_data WHERE key = %d AND value &quot;</a>
<a name="ln1169">                                     &quot;LIKE '%%%s%%'))&quot;, DT_METADATA_XMP_DC_PUBLISHER, escaped_text);</a>
<a name="ln1170">      break;</a>
<a name="ln1171">    case DT_COLLECTION_PROP_RIGHTS: // rights</a>
<a name="ln1172">      query = dt_util_dstrcat(query, &quot;(id IN (SELECT id FROM main.meta_data WHERE key = %d AND value &quot;</a>
<a name="ln1173">                                     &quot;LIKE '%%%s%%'))&quot;, DT_METADATA_XMP_DC_RIGHTS, escaped_text);</a>
<a name="ln1174">      break;</a>
<a name="ln1175">    case DT_COLLECTION_PROP_LENS: // lens</a>
<a name="ln1176">      query = dt_util_dstrcat(query, &quot;(lens LIKE '%%%s%%')&quot;, escaped_text);</a>
<a name="ln1177">      break;</a>
<a name="ln1178"> </a>
<a name="ln1179">    case DT_COLLECTION_PROP_FOCAL_LENGTH: // focal length</a>
<a name="ln1180">    {</a>
<a name="ln1181">      gchar *operator, *number1, *number2;</a>
<a name="ln1182">      dt_collection_split_operator_number(escaped_text, &amp;number1, &amp;number2, &amp;operator);</a>
<a name="ln1183"> </a>
<a name="ln1184">      if(operator &amp;&amp; strcmp(operator, &quot;[]&quot;) == 0)</a>
<a name="ln1185">      {</a>
<a name="ln1186">        if(number1 &amp;&amp; number2)</a>
<a name="ln1187">          query = dt_util_dstrcat(query, &quot;((focal_length &gt;= %s) AND (focal_length &lt;= %s))&quot;, number1, number2);</a>
<a name="ln1188">      }</a>
<a name="ln1189">      else if(operator &amp;&amp; number1)</a>
<a name="ln1190">        query = dt_util_dstrcat(query, &quot;(focal_length %s %s)&quot;, operator, number1);</a>
<a name="ln1191">      else if(number1)</a>
<a name="ln1192">        query = dt_util_dstrcat(query, &quot;(focal_length = %s)&quot;, number1);</a>
<a name="ln1193">      else</a>
<a name="ln1194">        query = dt_util_dstrcat(query, &quot;(focal_length LIKE '%%%s%%')&quot;, escaped_text);</a>
<a name="ln1195"> </a>
<a name="ln1196">      g_free(operator);</a>
<a name="ln1197">      g_free(number1);</a>
<a name="ln1198">      g_free(number2);</a>
<a name="ln1199">    }</a>
<a name="ln1200">    break;</a>
<a name="ln1201"> </a>
<a name="ln1202">    case DT_COLLECTION_PROP_ISO: // iso</a>
<a name="ln1203">    {</a>
<a name="ln1204">      gchar *operator, *number1, *number2;</a>
<a name="ln1205">      dt_collection_split_operator_number(escaped_text, &amp;number1, &amp;number2, &amp;operator);</a>
<a name="ln1206"> </a>
<a name="ln1207">      if(operator &amp;&amp; strcmp(operator, &quot;[]&quot;) == 0)</a>
<a name="ln1208">      {</a>
<a name="ln1209">        if(number1 &amp;&amp; number2)</a>
<a name="ln1210">          query = dt_util_dstrcat(query, &quot;((iso &gt;= %s) AND (iso &lt;= %s))&quot;, number1, number2);</a>
<a name="ln1211">      }</a>
<a name="ln1212">      else if(operator &amp;&amp; number1)</a>
<a name="ln1213">        query = dt_util_dstrcat(query, &quot;(iso %s %s)&quot;, operator, number1);</a>
<a name="ln1214">      else if(number1)</a>
<a name="ln1215">        query = dt_util_dstrcat(query, &quot;(iso = %s)&quot;, number1);</a>
<a name="ln1216">      else</a>
<a name="ln1217">        query = dt_util_dstrcat(query, &quot;(iso LIKE '%%%s%%')&quot;, escaped_text);</a>
<a name="ln1218"> </a>
<a name="ln1219">      g_free(operator);</a>
<a name="ln1220">      g_free(number1);</a>
<a name="ln1221">      g_free(number2);</a>
<a name="ln1222">    }</a>
<a name="ln1223">    break;</a>
<a name="ln1224"> </a>
<a name="ln1225">    case DT_COLLECTION_PROP_APERTURE: // aperture</a>
<a name="ln1226">    {</a>
<a name="ln1227">      gchar *operator, *number1, *number2;</a>
<a name="ln1228">      dt_collection_split_operator_number(escaped_text, &amp;number1, &amp;number2, &amp;operator);</a>
<a name="ln1229"> </a>
<a name="ln1230">      if(operator &amp;&amp; strcmp(operator, &quot;[]&quot;) == 0)</a>
<a name="ln1231">      {</a>
<a name="ln1232">        if(number1 &amp;&amp; number2)</a>
<a name="ln1233">          query = dt_util_dstrcat(query, &quot;((ROUND(aperture,1) &gt;= %s) AND (ROUND(aperture,1) &lt;= %s))&quot;, number1,</a>
<a name="ln1234">                                  number2);</a>
<a name="ln1235">      }</a>
<a name="ln1236">      else if(operator &amp;&amp; number1)</a>
<a name="ln1237">        query = dt_util_dstrcat(query, &quot;(ROUND(aperture,1) %s %s)&quot;, operator, number1);</a>
<a name="ln1238">      else if(number1)</a>
<a name="ln1239">        query = dt_util_dstrcat(query, &quot;(ROUND(aperture,1) = %s)&quot;, number1);</a>
<a name="ln1240">      else</a>
<a name="ln1241">        query = dt_util_dstrcat(query, &quot;(ROUND(aperture,1) LIKE '%%%s%%')&quot;, escaped_text);</a>
<a name="ln1242"> </a>
<a name="ln1243">      g_free(operator);</a>
<a name="ln1244">      g_free(number1);</a>
<a name="ln1245">      g_free(number2);</a>
<a name="ln1246">    }</a>
<a name="ln1247">    break;</a>
<a name="ln1248"> </a>
<a name="ln1249">    case DT_COLLECTION_PROP_EXPOSURE: // exposure</a>
<a name="ln1250">    {</a>
<a name="ln1251">      gchar *operator, *number1, *number2;</a>
<a name="ln1252">      dt_collection_split_operator_exposure(escaped_text, &amp;number1, &amp;number2, &amp;operator);</a>
<a name="ln1253"> </a>
<a name="ln1254">      if(operator &amp;&amp; strcmp(operator, &quot;[]&quot;) == 0)</a>
<a name="ln1255">      {</a>
<a name="ln1256">        if(number1 &amp;&amp; number2)</a>
<a name="ln1257">          query = dt_util_dstrcat(query, &quot;((exposure &gt;= %s  - 1.0/100000) AND (exposure &lt;= %s  + 1.0/100000))&quot;, number1,</a>
<a name="ln1258">                                  number2);</a>
<a name="ln1259">      }</a>
<a name="ln1260">      else if(operator &amp;&amp; number1)</a>
<a name="ln1261">        query = dt_util_dstrcat(query, &quot;(exposure %s %s)&quot;, operator, number1);</a>
<a name="ln1262">      else if(number1)</a>
<a name="ln1263">        query = dt_util_dstrcat(query,</a>
<a name="ln1264">                                &quot;(CASE WHEN exposure &lt; 0.4 THEN ((exposure &gt;= %s - 1.0/100000) AND  (exposure &lt;= %s + 1.0/100000)) &quot;</a>
<a name="ln1265">                                &quot;ELSE (ROUND(exposure,2) &gt;= %s - 1.0/100000) AND (ROUND(exposure,2) &lt;= %s + 1.0/100000) END)&quot;,</a>
<a name="ln1266">                                number1, number1, number1, number1);</a>
<a name="ln1267">      else</a>
<a name="ln1268">        query = dt_util_dstrcat(query, &quot;(exposure LIKE '%%%s%%')&quot;, escaped_text);</a>
<a name="ln1269"> </a>
<a name="ln1270">      g_free(operator);</a>
<a name="ln1271">      g_free(number1);</a>
<a name="ln1272">      g_free(number2);</a>
<a name="ln1273">    }</a>
<a name="ln1274">    break;</a>
<a name="ln1275"> </a>
<a name="ln1276">    case DT_COLLECTION_PROP_FILENAME: // filename</a>
<a name="ln1277">      query = dt_util_dstrcat(query, &quot;(filename LIKE '%%%s%%')&quot;, escaped_text);</a>
<a name="ln1278">      break;</a>
<a name="ln1279"> </a>
<a name="ln1280">    case DT_COLLECTION_PROP_DAY:</a>
<a name="ln1281">    // query = dt_util_dstrcat(query, &quot;(datetime_taken like '%%%s%%')&quot;, escaped_text);</a>
<a name="ln1282">    // break;</a>
<a name="ln1283"> </a>
<a name="ln1284">    case DT_COLLECTION_PROP_TIME:</a>
<a name="ln1285">    {</a>
<a name="ln1286">      gchar *operator, *number1, *number2;</a>
<a name="ln1287">      dt_collection_split_operator_datetime(escaped_text, &amp;number1, &amp;number2, &amp;operator);</a>
<a name="ln1288"> </a>
<a name="ln1289">      if(strcmp(operator, &quot;[]&quot;) == 0)</a>
<a name="ln1290">      {</a>
<a name="ln1291">        if(number1 &amp;&amp; number2)</a>
<a name="ln1292">          query = dt_util_dstrcat(query, &quot;((datetime_taken &gt;= '%s') AND (datetime_taken &lt;= '%s'))&quot;, number1,</a>
<a name="ln1293">                                  number2);</a>
<a name="ln1294">      }</a>
<a name="ln1295">      else if((strcmp(operator, &quot;=&quot;) == 0 || strcmp(operator, &quot;&quot;) == 0) &amp;&amp; number1)</a>
<a name="ln1296">        query = dt_util_dstrcat(query, &quot;(datetime_taken LIKE '%s')&quot;, number1);</a>
<a name="ln1297">      else if(strcmp(operator, &quot;&lt;&gt;&quot;) == 0 &amp;&amp; number1)</a>
<a name="ln1298">        query = dt_util_dstrcat(query, &quot;(datetime_taken NOT LIKE '%s')&quot;, number1);</a>
<a name="ln1299">      else if(number1)</a>
<a name="ln1300">        query = dt_util_dstrcat(query, &quot;(datetime_taken %s '%s')&quot;, operator, number1);</a>
<a name="ln1301">      else</a>
<a name="ln1302">        query = dt_util_dstrcat(query, &quot;(datetime_taken LIKE '%%%s%%')&quot;, escaped_text);</a>
<a name="ln1303"> </a>
<a name="ln1304">      g_free(operator);</a>
<a name="ln1305">      g_free(number1);</a>
<a name="ln1306">      g_free(number2);</a>
<a name="ln1307">    }</a>
<a name="ln1308">    break;</a>
<a name="ln1309"> </a>
<a name="ln1310">    case DT_COLLECTION_PROP_GROUPING: // grouping</a>
<a name="ln1311">      query = dt_util_dstrcat(query, &quot;(id %s group_id)&quot;, (strcmp(escaped_text, _(&quot;group leaders&quot;)) == 0) ? &quot;=&quot; : &quot;!=&quot;);</a>
<a name="ln1312">      break;</a>
<a name="ln1313"> </a>
<a name="ln1314">    default:</a>
<a name="ln1315">      // we shouldn't be here</a>
<a name="ln1316">      break;</a>
<a name="ln1317">  }</a>
<a name="ln1318">  sqlite3_free(escaped_text);</a>
<a name="ln1319"> </a>
<a name="ln1320">  if(!query) // We've screwed up and not done a query string, send a placeholder</a>
<a name="ln1321">    query = dt_util_dstrcat(query, &quot;(1=1)&quot;);</a>
<a name="ln1322"> </a>
<a name="ln1323">  return query;</a>
<a name="ln1324">}</a>
<a name="ln1325"> </a>
<a name="ln1326">int dt_collection_serialize(char *buf, int bufsize)</a>
<a name="ln1327">{</a>
<a name="ln1328">  char confname[200];</a>
<a name="ln1329">  int c;</a>
<a name="ln1330">  const int num_rules = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1331">  c = snprintf(buf, bufsize, &quot;%d:&quot;, num_rules);</a>
<a name="ln1332">  buf += c;</a>
<a name="ln1333">  bufsize -= c;</a>
<a name="ln1334">  for(int k = 0; k &lt; num_rules; k++)</a>
<a name="ln1335">  {</a>
<a name="ln1336">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, k);</a>
<a name="ln1337">    const int mode = dt_conf_get_int(confname);</a>
<a name="ln1338">    c = snprintf(buf, bufsize, &quot;%d:&quot;, mode);</a>
<a name="ln1339">    buf += c;</a>
<a name="ln1340">    bufsize -= c;</a>
<a name="ln1341">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, k);</a>
<a name="ln1342">    const int item = dt_conf_get_int(confname);</a>
<a name="ln1343">    c = snprintf(buf, bufsize, &quot;%d:&quot;, item);</a>
<a name="ln1344">    buf += c;</a>
<a name="ln1345">    bufsize -= c;</a>
<a name="ln1346">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, k);</a>
<a name="ln1347">    gchar *str = dt_conf_get_string(confname);</a>
<a name="ln1348">    if(str &amp;&amp; (str[0] != '\0'))</a>
<a name="ln1349">      c = snprintf(buf, bufsize, &quot;%s$&quot;, str);</a>
<a name="ln1350">    else</a>
<a name="ln1351">      c = snprintf(buf, bufsize, &quot;%%$&quot;);</a>
<a name="ln1352">    buf += c;</a>
<a name="ln1353">    bufsize -= c;</a>
<a name="ln1354">    g_free(str);</a>
<a name="ln1355">  }</a>
<a name="ln1356">  return 0;</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>
<a name="ln1359">void dt_collection_deserialize(char *buf)</a>
<a name="ln1360">{</a>
<a name="ln1361">  int num_rules = 0;</a>
<a name="ln1362">  char str[400], confname[200];</a>
<a name="ln1363">  int mode = 0, item = 0;</a>
<a name="ln1364">  sscanf(buf, &quot;%d&quot;, &amp;num_rules);</a>
<a name="ln1365">  if(num_rules == 0)</a>
<a name="ln1366">  {</a>
<a name="ln1367">    dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, 1);</a>
<a name="ln1368">    dt_conf_set_int(&quot;plugins/lighttable/collect/mode0&quot;, 0);</a>
<a name="ln1369">    dt_conf_set_int(&quot;plugins/lighttable/collect/item0&quot;, 0);</a>
<a name="ln1370">    dt_conf_set_string(&quot;plugins/lighttable/collect/string0&quot;, &quot;%&quot;);</a>
<a name="ln1371">  }</a>
<a name="ln1372">  else</a>
<a name="ln1373">  {</a>
<a name="ln1374">    dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, num_rules);</a>
<a name="ln1375">    while(buf[0] != '\0' &amp;&amp; buf[0] != ':') buf++;</a>
<a name="ln1376">    if(buf[0] == ':') buf++;</a>
<a name="ln1377">    for(int k = 0; k &lt; num_rules; k++)</a>
<a name="ln1378">    {</a>
<a name="ln1379">      int n = sscanf(buf, &quot;%d:%d:%399[^$]&quot;, &amp;mode, &amp;item, str);</a>
<a name="ln1380">      if(n == 3)</a>
<a name="ln1381">      {</a>
<a name="ln1382">        snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, k);</a>
<a name="ln1383">        dt_conf_set_int(confname, mode);</a>
<a name="ln1384">        snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, k);</a>
<a name="ln1385">        dt_conf_set_int(confname, item);</a>
<a name="ln1386">        snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, k);</a>
<a name="ln1387">        dt_conf_set_string(confname, str);</a>
<a name="ln1388">      }</a>
<a name="ln1389">      else if(num_rules == 1)</a>
<a name="ln1390">      {</a>
<a name="ln1391">        snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, k);</a>
<a name="ln1392">        dt_conf_set_int(confname, 0);</a>
<a name="ln1393">        snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, k);</a>
<a name="ln1394">        dt_conf_set_int(confname, 0);</a>
<a name="ln1395">        snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, k);</a>
<a name="ln1396">        dt_conf_set_string(confname, &quot;%&quot;);</a>
<a name="ln1397">        break;</a>
<a name="ln1398">      }</a>
<a name="ln1399">      else</a>
<a name="ln1400">      {</a>
<a name="ln1401">        dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, k);</a>
<a name="ln1402">        break;</a>
<a name="ln1403">      }</a>
<a name="ln1404">      while(buf[0] != '$' &amp;&amp; buf[0] != '\0') buf++;</a>
<a name="ln1405">      if(buf[0] == '$') buf++;</a>
<a name="ln1406">    }</a>
<a name="ln1407">  }</a>
<a name="ln1408">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1409">}</a>
<a name="ln1410"> </a>
<a name="ln1411">void dt_collection_update_query(const dt_collection_t *collection)</a>
<a name="ln1412">{</a>
<a name="ln1413">  char confname[200];</a>
<a name="ln1414"> </a>
<a name="ln1415">  const int _n_r = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1416">  const int num_rules = CLAMP(_n_r, 1, 10);</a>
<a name="ln1417">  char *conj[] = { &quot;AND&quot;, &quot;OR&quot;, &quot;AND NOT&quot; };</a>
<a name="ln1418"> </a>
<a name="ln1419">  gchar **query_parts = g_new (gchar*, num_rules + 1);</a>
<a name="ln1420">  query_parts[num_rules] =  NULL;</a>
<a name="ln1421"> </a>
<a name="ln1422">  for(int i = 0; i &lt; num_rules; i++)</a>
<a name="ln1423">  {</a>
<a name="ln1424">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln1425">    const int property = dt_conf_get_int(confname);</a>
<a name="ln1426">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln1427">    gchar *text = dt_conf_get_string(confname);</a>
<a name="ln1428">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln1429">    const int mode = dt_conf_get_int(confname);</a>
<a name="ln1430"> </a>
<a name="ln1431">    if(!text || text[0] == '\0') {</a>
<a name="ln1432">      if (mode == 1) // for OR show all</a>
<a name="ln1433">        query_parts[i] = g_strdup(&quot; OR 1=1&quot;);</a>
<a name="ln1434">      else</a>
<a name="ln1435">        query_parts[i] = g_strdup(&quot;&quot;);</a>
<a name="ln1436">    } else {</a>
<a name="ln1437">      gchar *query = get_query_string(property, text);</a>
<a name="ln1438"> </a>
<a name="ln1439">      query_parts[i] =  g_strdup_printf(&quot; %s %s&quot;, conj[mode], query);</a>
<a name="ln1440"> </a>
<a name="ln1441">      g_free(query);</a>
<a name="ln1442">    }</a>
<a name="ln1443">    g_free(text);</a>
<a name="ln1444">  }</a>
<a name="ln1445"> </a>
<a name="ln1446"> </a>
<a name="ln1447">  /* set the extended where and the use of it in the query */</a>
<a name="ln1448">  dt_collection_set_extended_where(collection, query_parts);</a>
<a name="ln1449">  g_strfreev(query_parts);</a>
<a name="ln1450">  dt_collection_set_query_flags(collection,</a>
<a name="ln1451">                                (dt_collection_get_query_flags(collection) | COLLECTION_QUERY_USE_WHERE_EXT));</a>
<a name="ln1452"> </a>
<a name="ln1453">  /* remove film id from default filter */</a>
<a name="ln1454">  dt_collection_set_filter_flags(collection,</a>
<a name="ln1455">                                 (dt_collection_get_filter_flags(collection) &amp; ~COLLECTION_FILTER_FILM_ID));</a>
<a name="ln1456"> </a>
<a name="ln1457">  /* update query and at last the visual */</a>
<a name="ln1458">  dt_collection_update(collection);</a>
<a name="ln1459"> </a>
<a name="ln1460">  // remove from selected images where not in this query.</a>
<a name="ln1461">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln1462">  const gchar *cquery = dt_collection_get_query_no_group(collection);</a>
<a name="ln1463">  gchar *complete_query = NULL;</a>
<a name="ln1464">  if(cquery &amp;&amp; cquery[0] != '\0')</a>
<a name="ln1465">  {</a>
<a name="ln1466">    complete_query</a>
<a name="ln1467">        = dt_util_dstrcat(complete_query, &quot;DELETE FROM main.selected_images WHERE imgid NOT IN (%s)&quot;, cquery);</a>
<a name="ln1468">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), complete_query, -1, &amp;stmt, NULL);</a>
<a name="ln1469">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, 0);</a>
<a name="ln1470">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, -1);</a>
<a name="ln1471">    sqlite3_step(stmt);</a>
<a name="ln1472">    sqlite3_finalize(stmt);</a>
<a name="ln1473"> </a>
<a name="ln1474">    /* free allocated strings */</a>
<a name="ln1475">    g_free(complete_query);</a>
<a name="ln1476">  }</a>
<a name="ln1477"> </a>
<a name="ln1478">  /* raise signal of collection change, only if this is an original */</a>
<a name="ln1479">  if(!collection-&gt;clone) dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln1480">}</a>
<a name="ln1481"> </a>
<a name="ln1482">gboolean dt_collection_hint_message_internal(void *message)</a>
<a name="ln1483">{</a>
<a name="ln1484">  dt_control_hinter_message(darktable.control, message);</a>
<a name="ln1485">  g_free(message);</a>
<a name="ln1486">  return FALSE;</a>
<a name="ln1487">}</a>
<a name="ln1488"> </a>
<a name="ln1489">void dt_collection_hint_message(const dt_collection_t *collection)</a>
<a name="ln1490">{</a>
<a name="ln1491">  /* if relevant, determine offset of selection */</a>
<a name="ln1492">  GList *selected_imgids = dt_collection_get_selected(collection, 1);</a>
<a name="ln1493">  int selected = -1;</a>
<a name="ln1494"> </a>
<a name="ln1495">  if(selected_imgids)</a>
<a name="ln1496">  {</a>
<a name="ln1497">    selected = GPOINTER_TO_INT(selected_imgids-&gt;data);</a>
<a name="ln1498">    selected = dt_collection_image_offset_with_collection(collection, selected);</a>
<a name="ln1499">    selected++;</a>
<a name="ln1500">  }</a>
<a name="ln1501">  /* collection hinting */</a>
<a name="ln1502">  gchar *message;</a>
<a name="ln1503"> </a>
<a name="ln1504">  int c = dt_collection_get_count_no_group(collection);</a>
<a name="ln1505">  int cs = dt_collection_get_selected_count(collection);</a>
<a name="ln1506"> </a>
<a name="ln1507">  if(cs == 1)</a>
<a name="ln1508">  {</a>
<a name="ln1509">    message = g_strdup_printf(_(&quot;%d image of %d (#%d) in current collection is selected&quot;), cs, c, selected);</a>
<a name="ln1510">  }</a>
<a name="ln1511">  else</a>
<a name="ln1512">  {</a>
<a name="ln1513">    message = g_strdup_printf(</a>
<a name="ln1514">      ngettext(</a>
<a name="ln1515">        &quot;%d image of %d in current collection is selected&quot;,</a>
<a name="ln1516">        &quot;%d images of %d in current collection are selected&quot;,</a>
<a name="ln1517">        cs),</a>
<a name="ln1518">      cs, c);</a>
<a name="ln1519">  }</a>
<a name="ln1520"> </a>
<a name="ln1521">  g_idle_add(dt_collection_hint_message_internal, message);</a>
<a name="ln1522">}</a>
<a name="ln1523"> </a>
<a name="ln1524">static int dt_collection_image_offset_with_collection(const dt_collection_t *collection, int imgid)</a>
<a name="ln1525">{</a>
<a name="ln1526">  if(imgid == -1) return 0;</a>
<a name="ln1527">  const gchar *qin = dt_collection_get_query(collection);</a>
<a name="ln1528">  int offset = 0;</a>
<a name="ln1529">  sqlite3_stmt *stmt;</a>
<a name="ln1530"> </a>
<a name="ln1531">  if(qin)</a>
<a name="ln1532">  {</a>
<a name="ln1533">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), qin, -1, &amp;stmt, NULL);</a>
<a name="ln1534"> </a>
<a name="ln1535">    // was the limit portion of the query tacked on?</a>
<a name="ln1536">    if(collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_LIMIT)</a>
<a name="ln1537">    {</a>
<a name="ln1538">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, 0);</a>
<a name="ln1539">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, -1);</a>
<a name="ln1540">    }</a>
<a name="ln1541"> </a>
<a name="ln1542">    gboolean found = FALSE;</a>
<a name="ln1543"> </a>
<a name="ln1544">    while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1545">    {</a>
<a name="ln1546">      int id = sqlite3_column_int(stmt, 0);</a>
<a name="ln1547">      if(imgid == id)</a>
<a name="ln1548">      {</a>
<a name="ln1549">        found = TRUE;</a>
<a name="ln1550">        break;</a>
<a name="ln1551">      }</a>
<a name="ln1552">      offset++;</a>
<a name="ln1553">    }</a>
<a name="ln1554"> </a>
<a name="ln1555">    if(!found) offset = 0;</a>
<a name="ln1556"> </a>
<a name="ln1557">    sqlite3_finalize(stmt);</a>
<a name="ln1558">  }</a>
<a name="ln1559">  return offset;</a>
<a name="ln1560">}</a>
<a name="ln1561"> </a>
<a name="ln1562">int dt_collection_image_offset(int imgid)</a>
<a name="ln1563">{</a>
<a name="ln1564">  return dt_collection_image_offset_with_collection(darktable.collection, imgid);</a>
<a name="ln1565">}</a>
<a name="ln1566"> </a>
<a name="ln1567">static void _dt_collection_recount_callback_1(gpointer instace, gpointer user_data)</a>
<a name="ln1568">{</a>
<a name="ln1569">  dt_collection_t *collection = (dt_collection_t *)user_data;</a>
<a name="ln1570">  int old_count = collection-&gt;count;</a>
<a name="ln1571">  collection-&gt;count = _dt_collection_compute_count(collection, FALSE);</a>
<a name="ln1572">  collection-&gt;count_no_group = _dt_collection_compute_count(collection, TRUE);</a>
<a name="ln1573">  if(!collection-&gt;clone)</a>
<a name="ln1574">  {</a>
<a name="ln1575">    if(old_count != collection-&gt;count) dt_collection_hint_message(collection);</a>
<a name="ln1576">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln1577">  }</a>
<a name="ln1578">}</a>
<a name="ln1579"> </a>
<a name="ln1580">static void _dt_collection_recount_callback_2(gpointer instance, uint8_t id, gpointer user_data)</a>
<a name="ln1581">{</a>
<a name="ln1582">  dt_collection_t *collection = (dt_collection_t *)user_data;</a>
<a name="ln1583">  int old_count = collection-&gt;count;</a>
<a name="ln1584">  collection-&gt;count = _dt_collection_compute_count(collection, FALSE);</a>
<a name="ln1585">  collection-&gt;count_no_group = _dt_collection_compute_count(collection, TRUE);</a>
<a name="ln1586">  if(!collection-&gt;clone)</a>
<a name="ln1587">  {</a>
<a name="ln1588">    if(old_count != collection-&gt;count) dt_collection_hint_message(collection);</a>
<a name="ln1589">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln1590">  }</a>
<a name="ln1591">}</a>
<a name="ln1592"> </a>
<a name="ln1593">int64_t dt_collection_get_image_position(const int32_t image_id)</a>
<a name="ln1594">{</a>
<a name="ln1595">  int64_t image_position = -1;</a>
<a name="ln1596"> </a>
<a name="ln1597">  if (image_id &gt;= 0)</a>
<a name="ln1598">  {</a>
<a name="ln1599">    sqlite3_stmt *stmt = NULL;</a>
<a name="ln1600">    gchar *image_pos_query = NULL;</a>
<a name="ln1601">    image_pos_query = dt_util_dstrcat(</a>
<a name="ln1602">          image_pos_query,</a>
<a name="ln1603">          &quot;SELECT position FROM main.images WHERE id = ?1&quot;);</a>
<a name="ln1604"> </a>
<a name="ln1605">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), image_pos_query, -1, &amp;stmt, NULL);</a>
<a name="ln1606">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, image_id);</a>
<a name="ln1607"> </a>
<a name="ln1608">    if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1609">    {</a>
<a name="ln1610">      image_position = sqlite3_column_int64(stmt, 0);</a>
<a name="ln1611">    }</a>
<a name="ln1612"> </a>
<a name="ln1613">    sqlite3_finalize(stmt);</a>
<a name="ln1614">    g_free(image_pos_query);</a>
<a name="ln1615">  }</a>
<a name="ln1616"> </a>
<a name="ln1617">  return image_position;</a>
<a name="ln1618">}</a>
<a name="ln1619"> </a>
<a name="ln1620">void dt_collection_shift_image_positions(const unsigned int length, const int64_t image_position)</a>
<a name="ln1621">{</a>
<a name="ln1622">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;BEGIN&quot;, NULL, NULL, NULL);</a>
<a name="ln1623">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln1624"> </a>
<a name="ln1625">  // shift image positions to make some space</a>
<a name="ln1626">  gchar * update_image_pos_query = &quot;UPDATE main.images SET position = position + ?1 WHERE position &gt;= ?2 AND position &lt; ?3&quot;;</a>
<a name="ln1627"> </a>
<a name="ln1628">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), update_image_pos_query, -1, &amp;stmt, NULL);</a>
<a name="ln1629">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, length);</a>
<a name="ln1630">  DT_DEBUG_SQLITE3_BIND_INT64(stmt, 2, image_position);</a>
<a name="ln1631">  DT_DEBUG_SQLITE3_BIND_INT64(stmt, 3, (image_position &amp; 0xFFFFFFFF00000000) + (1ll &lt;&lt; 32));</a>
<a name="ln1632"> </a>
<a name="ln1633">  sqlite3_step(stmt);</a>
<a name="ln1634">  sqlite3_finalize(stmt);</a>
<a name="ln1635"> </a>
<a name="ln1636">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln1637">}</a>
<a name="ln1638"> </a>
<a name="ln1639">/* move images with drag and drop</a>
<a name="ln1640"> *</a>
<a name="ln1641"> * An int64 is used for the position index. The upper 31 bits define the initial order.</a>
<a name="ln1642"> * The lower 32bit provide space to reorder images. That way only a small amount of images must be</a>
<a name="ln1643"> * updated while reordering images.</a>
<a name="ln1644"> *</a>
<a name="ln1645"> * Example: (position values hex)</a>
<a name="ln1646"> * Initial order:</a>
<a name="ln1647"> * Img 1: 0000 0001 0000 0000</a>
<a name="ln1648"> * Img 2: 0000 0002 0000 0000</a>
<a name="ln1649"> * Img 3: 0000 0003 0000 0000</a>
<a name="ln1650"> * Img 3: 0000 0004 0000 0000</a>
<a name="ln1651"> *</a>
<a name="ln1652"> * Putting Img 2 in front of Img 1. Would give</a>
<a name="ln1653"> * Img 2: 0000 0001 0000 0000</a>
<a name="ln1654"> * Img 1: 0000 0001 0000 0001</a>
<a name="ln1655"> * Img 3: 0000 0003 0000 0000</a>
<a name="ln1656"> * Img 4: 0000 0004 0000 0000</a>
<a name="ln1657"> *</a>
<a name="ln1658"> * Img 3 and Img 4 is not updated.</a>
<a name="ln1659">*/</a>
<a name="ln1660">void dt_collection_move_before(const int32_t image_id, GList * selected_images)</a>
<a name="ln1661">{</a>
<a name="ln1662">  if (!selected_images)</a>
<a name="ln1663">  {</a>
<a name="ln1664">    return;</a>
<a name="ln1665">  }</a>
<a name="ln1666"> </a>
<a name="ln1667">  const guint selected_images_length = g_list_length(selected_images);</a>
<a name="ln1668"> </a>
<a name="ln1669">  if (selected_images_length == 0)</a>
<a name="ln1670">  {</a>
<a name="ln1671">    return;</a>
<a name="ln1672">  }</a>
<a name="ln1673"> </a>
<a name="ln1674">  // getting the position of the target image</a>
<a name="ln1675">  const int64_t target_image_pos = dt_collection_get_image_position(image_id);</a>
<a name="ln1676"> </a>
<a name="ln1677">  if (target_image_pos &gt;= 0)</a>
<a name="ln1678">  {</a>
<a name="ln1679">    dt_collection_shift_image_positions(selected_images_length, target_image_pos);</a>
<a name="ln1680"> </a>
<a name="ln1681">    sqlite3_stmt *stmt = NULL;</a>
<a name="ln1682">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;BEGIN&quot;, NULL, NULL, NULL);</a>
<a name="ln1683"> </a>
<a name="ln1684">    // move images to their intended positons</a>
<a name="ln1685">    int64_t new_image_pos = target_image_pos;</a>
<a name="ln1686"> </a>
<a name="ln1687">    gchar *insert_image_pos_query = &quot;UPDATE main.images SET position = ?1 WHERE id = ?2&quot;;</a>
<a name="ln1688"> </a>
<a name="ln1689">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), insert_image_pos_query, -1, &amp;stmt, NULL);</a>
<a name="ln1690"> </a>
<a name="ln1691">    for (const GList * selected_images_iter = selected_images;</a>
<a name="ln1692">        selected_images_iter != NULL;</a>
<a name="ln1693">        selected_images_iter = selected_images_iter-&gt;next)</a>
<a name="ln1694">    {</a>
<a name="ln1695">      const int moved_image_id = GPOINTER_TO_INT(selected_images_iter-&gt;data);</a>
<a name="ln1696"> </a>
<a name="ln1697">      DT_DEBUG_SQLITE3_BIND_INT64(stmt, 1, new_image_pos);</a>
<a name="ln1698">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, moved_image_id);</a>
<a name="ln1699">      sqlite3_step(stmt);</a>
<a name="ln1700">      sqlite3_reset(stmt);</a>
<a name="ln1701">      new_image_pos++;</a>
<a name="ln1702">    }</a>
<a name="ln1703">    sqlite3_finalize(stmt);</a>
<a name="ln1704">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln1705">  }</a>
<a name="ln1706">  else</a>
<a name="ln1707">  {</a>
<a name="ln1708">    // move images to the end of the list</a>
<a name="ln1709">    sqlite3_stmt *stmt = NULL;</a>
<a name="ln1710"> </a>
<a name="ln1711">    // get last position</a>
<a name="ln1712">    int64_t max_position = -1;</a>
<a name="ln1713"> </a>
<a name="ln1714">    gchar *max_position_query = &quot;SELECT MAX(position) FROM main.images&quot;;</a>
<a name="ln1715">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), max_position_query, -1, &amp;stmt, NULL);</a>
<a name="ln1716"> </a>
<a name="ln1717">    if (sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1718">    {</a>
<a name="ln1719">      max_position = sqlite3_column_int64(stmt, 0);</a>
<a name="ln1720">      max_position = (max_position &amp; 0xFFFFFFFF00000000) &gt;&gt; 32;</a>
<a name="ln1721">    }</a>
<a name="ln1722"> </a>
<a name="ln1723">    sqlite3_finalize(stmt);</a>
<a name="ln1724">    sqlite3_stmt *update_stmt = NULL;</a>
<a name="ln1725"> </a>
<a name="ln1726">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;BEGIN&quot;, NULL, NULL, NULL);</a>
<a name="ln1727"> </a>
<a name="ln1728">    // move images to last position in custom image order table</a>
<a name="ln1729">    gchar *update_query = &quot;UPDATE main.images SET position = ?1 WHERE id = ?2&quot;;</a>
<a name="ln1730">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), update_query, -1, &amp;update_stmt, NULL);</a>
<a name="ln1731"> </a>
<a name="ln1732">    for (const GList * selected_images_iter = selected_images;</a>
<a name="ln1733">        selected_images_iter != NULL;</a>
<a name="ln1734">        selected_images_iter = selected_images_iter-&gt;next)</a>
<a name="ln1735">    {</a>
<a name="ln1736">      max_position++;</a>
<a name="ln1737">      const int moved_image_id = GPOINTER_TO_INT(selected_images_iter-&gt;data);</a>
<a name="ln1738">      DT_DEBUG_SQLITE3_BIND_INT64(update_stmt, 1, max_position &lt;&lt; 32);</a>
<a name="ln1739">      DT_DEBUG_SQLITE3_BIND_INT(update_stmt, 2, moved_image_id);</a>
<a name="ln1740">      sqlite3_step(update_stmt);</a>
<a name="ln1741">      sqlite3_reset(update_stmt);</a>
<a name="ln1742">    }</a>
<a name="ln1743"> </a>
<a name="ln1744">    sqlite3_finalize(update_stmt);</a>
<a name="ln1745">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln1746">  }</a>
<a name="ln1747">}</a>
<a name="ln1748"> </a>
<a name="ln1749">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1750">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1751">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'need_operator = 1' is always true.</p></div>
<div class="balloon" rel="144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v559/" target="_blank">V559</a> Suspicious assignment inside the conditional expression of ternary operator: need_operator = 1.</p></div>
<div class="balloon" rel="144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v583/" target="_blank">V583</a> The '?:' operator, regardless of its conditional expression, always returns one and the same value: "".</p></div>
<div class="balloon" rel="149"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'need_operator' is always true.</p></div>
<div class="balloon" rel="149"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v559/" target="_blank">V559</a> Suspicious assignment inside the conditional expression of ternary operator: need_operator = 1.</p></div>
<div class="balloon" rel="149"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v583/" target="_blank">V583</a> The '?:' operator, regardless of its conditional expression, always returns one and the same value: "".</p></div>
<div class="balloon" rel="153"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'need_operator' is always true.</p></div>
<div class="balloon" rel="153"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v559/" target="_blank">V559</a> Suspicious assignment inside the conditional expression of ternary operator: need_operator = 1.</p></div>
<div class="balloon" rel="153"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v583/" target="_blank">V583</a> The '?:' operator, regardless of its conditional expression, always returns one and the same value: "".</p></div>
<div class="balloon" rel="156"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'need_operator' is always true.</p></div>
<div class="balloon" rel="156"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v559/" target="_blank">V559</a> Suspicious assignment inside the conditional expression of ternary operator: need_operator = 1.</p></div>
<div class="balloon" rel="156"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v583/" target="_blank">V583</a> The '?:' operator, regardless of its conditional expression, always returns one and the same value: "".</p></div>
<div class="balloon" rel="160"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'need_operator' is always true.</p></div>
<div class="balloon" rel="160"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v559/" target="_blank">V559</a> Suspicious assignment inside the conditional expression of ternary operator: need_operator = 1.</p></div>
<div class="balloon" rel="160"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v583/" target="_blank">V583</a> The '?:' operator, regardless of its conditional expression, always returns one and the same value: "".</p></div>
<div class="balloon" rel="163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'need_operator' is always true.</p></div>
<div class="balloon" rel="163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v559/" target="_blank">V559</a> Suspicious assignment inside the conditional expression of ternary operator: need_operator = 1.</p></div>
<div class="balloon" rel="163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v583/" target="_blank">V583</a> The '?:' operator, regardless of its conditional expression, always returns one and the same value: "".</p></div>
<div class="balloon" rel="167"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'need_operator' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
