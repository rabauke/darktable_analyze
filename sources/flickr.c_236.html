
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010-2011 Jose Carlos Garcia Sogo</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/image.h&quot;</a>
<a name="ln22">#include &quot;common/image_cache.h&quot;</a>
<a name="ln23">#include &quot;common/imageio.h&quot;</a>
<a name="ln24">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln25">#include &quot;common/metadata.h&quot;</a>
<a name="ln26">#include &quot;common/pwstorage/pwstorage.h&quot;</a>
<a name="ln27">#include &quot;common/tags.h&quot;</a>
<a name="ln28">#include &quot;control/conf.h&quot;</a>
<a name="ln29">#include &quot;control/control.h&quot;</a>
<a name="ln30">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln31">#include &quot;gui/gtk.h&quot;</a>
<a name="ln32">#include &quot;imageio/storage/imageio_storage_api.h&quot;</a>
<a name="ln33">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln34">#include &quot;osx/osx.h&quot;</a>
<a name="ln35">#endif</a>
<a name="ln36">#include &lt;curl/curl.h&gt;</a>
<a name="ln37">#include &lt;flickcurl.h&gt;</a>
<a name="ln38">#include &lt;stdio.h&gt;</a>
<a name="ln39">#include &lt;stdlib.h&gt;</a>
<a name="ln40">#include &lt;unistd.h&gt;</a>
<a name="ln41"> </a>
<a name="ln42">DT_MODULE(1)</a>
<a name="ln43"> </a>
<a name="ln44">#define API_KEY &quot;1d25b2dfcceba8c55fecb27645c968a3&quot;</a>
<a name="ln45">#define SHARED_SECRET &quot;ac66b6c212be6f0c&quot;</a>
<a name="ln46"> </a>
<a name="ln47">typedef struct _flickr_api_context_t</a>
<a name="ln48">{</a>
<a name="ln49">  flickcurl *fc;</a>
<a name="ln50"> </a>
<a name="ln51">  gboolean needsReauthentication;</a>
<a name="ln52"> </a>
<a name="ln53">  /** Current album used when posting images... */</a>
<a name="ln54">  flickcurl_photoset *current_album;</a>
<a name="ln55"> </a>
<a name="ln56">  char *album_title;</a>
<a name="ln57">  char *album_summary;</a>
<a name="ln58">  int album_public;</a>
<a name="ln59">  gboolean new_album;</a>
<a name="ln60">  gboolean error_occured;</a>
<a name="ln61"> </a>
<a name="ln62">} _flickr_api_context_t;</a>
<a name="ln63"> </a>
<a name="ln64">typedef struct dt_storage_flickr_gui_data_t</a>
<a name="ln65">{</a>
<a name="ln66"> </a>
<a name="ln67">  GtkLabel *status_label;</a>
<a name="ln68">  GtkEntry *user_entry, *title_entry, *summary_entry;</a>
<a name="ln69">  GtkWidget *export_tags;</a>
<a name="ln70">  GtkBox *create_box;                               // Create album options...</a>
<a name="ln71">  GtkWidget *permission_list, *album_list;</a>
<a name="ln72"> </a>
<a name="ln73">  char *user_token;</a>
<a name="ln74"> </a>
<a name="ln75">  /* List of albums */</a>
<a name="ln76">  flickcurl_photoset **albums;</a>
<a name="ln77"> </a>
<a name="ln78">  /** Current Flickr context for the gui */</a>
<a name="ln79">  _flickr_api_context_t *flickr_api;</a>
<a name="ln80"> </a>
<a name="ln81">} dt_storage_flickr_gui_data_t;</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">typedef struct dt_storage_flickr_params_t</a>
<a name="ln85">{</a>
<a name="ln86">  int64_t hash;</a>
<a name="ln87">  _flickr_api_context_t *flickr_api;</a>
<a name="ln88">  gboolean export_tags;</a>
<a name="ln89">  gboolean public_perm;</a>
<a name="ln90">  gboolean friend_perm;</a>
<a name="ln91">  gboolean family_perm;</a>
<a name="ln92">} dt_storage_flickr_params_t;</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">/** Authenticates and retrieves an initialized flickr api object */</a>
<a name="ln96">static _flickr_api_context_t *_flickr_api_authenticate(dt_storage_flickr_gui_data_t *ui);</a>
<a name="ln97"> </a>
<a name="ln98">static flickcurl_upload_status *_flickr_api_upload_photo(dt_storage_flickr_params_t *params, char *data,</a>
<a name="ln99">                                                         char *caption, char *description, gint imgid);</a>
<a name="ln100"> </a>
<a name="ln101">static void _flickr_api_free(_flickr_api_context_t *ctx)</a>
<a name="ln102">{</a>
<a name="ln103"> </a>
<a name="ln104">  g_free(ctx-&gt;album_title);</a>
<a name="ln105">  g_free(ctx-&gt;album_summary);</a>
<a name="ln106"> </a>
<a name="ln107">  if(ctx-&gt;current_album != NULL) flickcurl_free_photoset(ctx-&gt;current_album);</a>
<a name="ln108"> </a>
<a name="ln109">  flickcurl_free(ctx-&gt;fc);</a>
<a name="ln110"> </a>
<a name="ln111">  g_free(ctx);</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">static void _flickr_api_error_handler(void *data, const char *message)</a>
<a name="ln115">{</a>
<a name="ln116">  dt_control_log(_(&quot;flickr authentication: %s&quot;), message);</a>
<a name="ln117">  fprintf(stderr, &quot;[flickr] error: %s\n&quot;, message);</a>
<a name="ln118">  if(data)</a>
<a name="ln119">  {</a>
<a name="ln120">    _flickr_api_context_t *ctx = (_flickr_api_context_t *)data;</a>
<a name="ln121">    ctx-&gt;error_occured = 1;</a>
<a name="ln122">  }</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">static _flickr_api_context_t *_flickr_api_authenticate(dt_storage_flickr_gui_data_t *ui)</a>
<a name="ln126">{</a>
<a name="ln127">  char *perms = NULL, *frob;</a>
<a name="ln128">  gchar *token;</a>
<a name="ln129">  char *flickr_user_token = NULL;</a>
<a name="ln130">  gint result;</a>
<a name="ln131">  _flickr_api_context_t *ctx = (_flickr_api_context_t *)g_malloc0(sizeof(_flickr_api_context_t));</a>
<a name="ln132"> </a>
<a name="ln133">  flickcurl_init();</a>
<a name="ln134">  ctx-&gt;fc = flickcurl_new();</a>
<a name="ln135">  flickcurl_set_api_key(ctx-&gt;fc, API_KEY);</a>
<a name="ln136">  flickcurl_set_shared_secret(ctx-&gt;fc, SHARED_SECRET);</a>
<a name="ln137">  flickcurl_set_error_handler(ctx-&gt;fc, _flickr_api_error_handler, ctx);</a>
<a name="ln138"> </a>
<a name="ln139">  if(!ui-&gt;user_token)</a>
<a name="ln140">  {</a>
<a name="ln141">    // Retrieve stored auth_key</a>
<a name="ln142">    // TODO: We should be able to store token for different users</a>
<a name="ln143">    GHashTable *table = dt_pwstorage_get(&quot;flickr&quot;);</a>
<a name="ln144">    gchar *_username = g_strdup(g_hash_table_lookup(table, &quot;username&quot;));</a>
<a name="ln145">    gchar *_user_token = g_strdup(g_hash_table_lookup(table, &quot;token&quot;));</a>
<a name="ln146">    g_hash_table_destroy(table);</a>
<a name="ln147"> </a>
<a name="ln148">    if(_username)</a>
<a name="ln149">    {</a>
<a name="ln150">      if(!strcmp(_username, gtk_entry_get_text(ui-&gt;user_entry)))</a>
<a name="ln151">      {</a>
<a name="ln152">        flickr_user_token = g_strdup(_user_token);</a>
<a name="ln153">        perms = flickcurl_auth_checkToken(ctx-&gt;fc, flickr_user_token);</a>
<a name="ln154">      }</a>
<a name="ln155">      g_free(_username);</a>
<a name="ln156">    }</a>
<a name="ln157">    g_free(_user_token);</a>
<a name="ln158">  }</a>
<a name="ln159">  else</a>
<a name="ln160">  {</a>
<a name="ln161">    flickr_user_token = ui-&gt;user_token;</a>
<a name="ln162">    perms = flickcurl_auth_checkToken(ctx-&gt;fc, ui-&gt;user_token);</a>
<a name="ln163">  }</a>
<a name="ln164"> </a>
<a name="ln165"> </a>
<a name="ln166">  if(perms)</a>
<a name="ln167">  {</a>
<a name="ln168">    ui-&gt;user_token = flickr_user_token;</a>
<a name="ln169">    flickcurl_set_auth_token(ctx-&gt;fc, flickr_user_token);</a>
<a name="ln170">    return ctx;</a>
<a name="ln171">  }</a>
<a name="ln172">  else if(!ctx-&gt;error_occured)</a>
<a name="ln173">  {</a>
<a name="ln174">    frob = flickcurl_auth_getFrob(ctx-&gt;fc);</a>
<a name="ln175">    GError *error = NULL;</a>
<a name="ln176">    char *sign = g_strdup_printf(&quot;%sapi_key%sfrob%spermswrite&quot;, SHARED_SECRET, API_KEY, frob);</a>
<a name="ln177">    char *sign_md5 = g_compute_checksum_for_string(G_CHECKSUM_MD5, sign, strlen(sign));</a>
<a name="ln178">    gchar auth_url[250];</a>
<a name="ln179">    snprintf(auth_url, sizeof(auth_url),</a>
<a name="ln180">             &quot;https://flickr.com/services/auth/?api_key=%s&amp;perms=write&amp;frob=%s&amp;api_sig=%s&quot;, API_KEY, frob,</a>
<a name="ln181">             sign_md5);</a>
<a name="ln182"> </a>
<a name="ln183">    if(!gtk_show_uri(gdk_screen_get_default(), auth_url, gtk_get_current_event_time(), &amp;error))</a>
<a name="ln184">    {</a>
<a name="ln185">      fprintf(stderr, &quot;[flickr] error opening browser: %s\n&quot;, error-&gt;message);</a>
<a name="ln186">      g_error_free(error);</a>
<a name="ln187">    }</a>
<a name="ln188"> </a>
<a name="ln189">    g_free(sign);</a>
<a name="ln190">    g_free(sign_md5);</a>
<a name="ln191"> </a>
<a name="ln192">    // Hold here to let the user interact</a>
<a name="ln193">    // Show a dialog.</a>
<a name="ln194">    gchar *text1, *text2;</a>
<a name="ln195">    text1 = g_strdup(</a>
<a name="ln196">        _(&quot;step 1: a new window or tab of your browser should have been loaded. you have to login into your &quot;</a>
<a name="ln197">          &quot;flickr account there and authorize darktable to upload photos before continuing.&quot;));</a>
<a name="ln198">    text2 = g_strdup(_(&quot;step 2: click the OK button once you are done.&quot;));</a>
<a name="ln199"> </a>
<a name="ln200">    GtkWidget *window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln201">    GtkWidget *flickr_auth_dialog</a>
<a name="ln202">        = gtk_message_dialog_new(GTK_WINDOW(window), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_INFO,</a>
<a name="ln203">                                 GTK_BUTTONS_OK_CANCEL, _(&quot;flickr authentication&quot;));</a>
<a name="ln204">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln205">    dt_osx_disallow_fullscreen(flickr_auth_dialog);</a>
<a name="ln206">#endif</a>
<a name="ln207">    gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(flickr_auth_dialog), &quot;%s\n\n%s&quot;, text1, text2);</a>
<a name="ln208"> </a>
<a name="ln209">    result = gtk_dialog_run(GTK_DIALOG(flickr_auth_dialog));</a>
<a name="ln210"> </a>
<a name="ln211">    gtk_widget_destroy(flickr_auth_dialog);</a>
<a name="ln212"> </a>
<a name="ln213">    g_free(text1);</a>
<a name="ln214">    g_free(text2);</a>
<a name="ln215"> </a>
<a name="ln216">    switch(result)</a>
<a name="ln217">    {</a>
<a name="ln218">      case GTK_RESPONSE_OK:</a>
<a name="ln219">        token = flickcurl_auth_getToken(ctx-&gt;fc, frob);</a>
<a name="ln220">        g_free(frob);</a>
<a name="ln221">        // TODO: Handle timeouts errors</a>
<a name="ln222">        if(token)</a>
<a name="ln223">        {</a>
<a name="ln224">          flickr_user_token = g_strdup(token);</a>
<a name="ln225">        }</a>
<a name="ln226">        else</a>
<a name="ln227">        {</a>
<a name="ln228">          g_free(token);</a>
<a name="ln229">          _flickr_api_free(ctx);</a>
<a name="ln230">          return NULL;</a>
<a name="ln231">        }</a>
<a name="ln232">        ui-&gt;user_token = g_strdup(flickr_user_token);</a>
<a name="ln233">        flickcurl_set_auth_token(ctx-&gt;fc, flickr_user_token);</a>
<a name="ln234"> </a>
<a name="ln235">        /* Add creds to pwstorage */</a>
<a name="ln236">        GHashTable *table = g_hash_table_new(g_str_hash, g_str_equal);</a>
<a name="ln237">        gchar *username = (gchar *)gtk_entry_get_text(ui-&gt;user_entry);</a>
<a name="ln238"> </a>
<a name="ln239">        g_hash_table_insert(table, &quot;username&quot;, username);</a>
<a name="ln240">        g_hash_table_insert(table, &quot;token&quot;, flickr_user_token);</a>
<a name="ln241"> </a>
<a name="ln242">        if(!dt_pwstorage_set(&quot;flickr&quot;, table))</a>
<a name="ln243">        {</a>
<a name="ln244">          dt_print(DT_DEBUG_PWSTORAGE, &quot;[flickr] cannot store username/token\n&quot;);</a>
<a name="ln245">        }</a>
<a name="ln246"> </a>
<a name="ln247">        g_free(flickr_user_token);</a>
<a name="ln248">        g_hash_table_destroy(table);</a>
<a name="ln249"> </a>
<a name="ln250">        return ctx;</a>
<a name="ln251"> </a>
<a name="ln252">      default:</a>
<a name="ln253">        dt_print(DT_DEBUG_PWSTORAGE, &quot;[flickr] user cancelled the login process\n&quot;);</a>
<a name="ln254">        return NULL;</a>
<a name="ln255">    }</a>
<a name="ln256">  }</a>
<a name="ln257"> </a>
<a name="ln258">  free(perms);</a>
<a name="ln259"> </a>
<a name="ln260">  return NULL;</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263"> </a>
<a name="ln264">static flickcurl_upload_status *_flickr_api_upload_photo(dt_storage_flickr_params_t *p, char *fname,</a>
<a name="ln265">                                                         char *caption, char *description, gint imgid)</a>
<a name="ln266">{</a>
<a name="ln267"> </a>
<a name="ln268">  flickcurl_upload_params *params = g_malloc0(sizeof(flickcurl_upload_params));</a>
<a name="ln269">  flickcurl_upload_status *status;</a>
<a name="ln270"> </a>
<a name="ln271">  params-&gt;safety_level = 1; // Defaults to safe photos</a>
<a name="ln272">  params-&gt;content_type = 1; // Defaults to photo (we don't support video!)</a>
<a name="ln273"> </a>
<a name="ln274">  params-&gt;title = caption;</a>
<a name="ln275">  params-&gt;description = description;</a>
<a name="ln276"> </a>
<a name="ln277">  if(imgid)</a>
<a name="ln278">  {</a>
<a name="ln279">    GList *tags_list = dt_tag_get_list(imgid);</a>
<a name="ln280">    params-&gt;tags = dt_util_glist_to_str(&quot;,&quot;, tags_list);</a>
<a name="ln281">    g_list_free_full(tags_list, g_free);</a>
<a name="ln282">  }</a>
<a name="ln283">  params-&gt;photo_file = fname; // fname should be the URI of temp file</a>
<a name="ln284"> </a>
<a name="ln285">  params-&gt;is_public = (int)p-&gt;public_perm;</a>
<a name="ln286">  params-&gt;is_friend = (int)p-&gt;friend_perm;</a>
<a name="ln287">  params-&gt;is_family = (int)p-&gt;family_perm;</a>
<a name="ln288"> </a>
<a name="ln289">  status = flickcurl_photos_upload_params(p-&gt;flickr_api-&gt;fc, params);</a>
<a name="ln290">  if(!status)</a>
<a name="ln291">  {</a>
<a name="ln292">    fprintf(stderr, &quot;[flickr] Something went wrong when uploading&quot;);</a>
<a name="ln293">    g_free((gchar *)params-&gt;tags);</a>
<a name="ln294">    g_free(params);</a>
<a name="ln295">    return NULL;</a>
<a name="ln296">  }</a>
<a name="ln297">  g_free((gchar *)params-&gt;tags);</a>
<a name="ln298">  g_free(params);</a>
<a name="ln299">  return status;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302"> </a>
<a name="ln303">static char *_flickr_api_create_photoset(_flickr_api_context_t *ctx, const char *photo_id)</a>
<a name="ln304">{</a>
<a name="ln305">  char *photoset;</a>
<a name="ln306">  const char *title = ctx-&gt;album_title;</a>
<a name="ln307">  const char *summary = ctx-&gt;album_summary;</a>
<a name="ln308"> </a>
<a name="ln309">  photoset = flickcurl_photosets_create(ctx-&gt;fc, title, summary, photo_id, NULL);</a>
<a name="ln310">  if(!photoset) fprintf(stderr, &quot;[flickr] Something went wrong when creating gallery %s&quot;, title);</a>
<a name="ln311">  return photoset;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">const char *name(const struct dt_imageio_module_storage_t *self)</a>
<a name="ln315">{</a>
<a name="ln316">  return _(&quot;flickr webalbum&quot;);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">/** Set status connection text */</a>
<a name="ln320">static void set_status(dt_storage_flickr_gui_data_t *ui, gchar *message, gchar *color)</a>
<a name="ln321">{</a>
<a name="ln322">  if(!color) color = &quot;#ffffff&quot;;</a>
<a name="ln323">  gchar mup[512] = { 0 };</a>
<a name="ln324">  snprintf(mup, sizeof(mup), &quot;&lt;span foreground=\&quot;%s\&quot; &gt;&lt;small&gt;%s&lt;/small&gt;&lt;/span&gt;&quot;, color, message);</a>
<a name="ln325">  gtk_label_set_markup(ui-&gt;status_label, mup);</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">static void flickr_entry_changed(GtkEntry *entry, gpointer data)</a>
<a name="ln329">{</a>
<a name="ln330">  dt_storage_flickr_gui_data_t *ui = (dt_storage_flickr_gui_data_t *)data;</a>
<a name="ln331"> </a>
<a name="ln332">  if(ui-&gt;flickr_api != NULL)</a>
<a name="ln333">  {</a>
<a name="ln334">    ui-&gt;flickr_api-&gt;needsReauthentication = TRUE;</a>
<a name="ln335">    g_free(ui-&gt;user_token);</a>
<a name="ln336">    ui-&gt;user_token = NULL;</a>
<a name="ln337">    set_status(ui, _(&quot;not authenticated&quot;), &quot;#e07f7f&quot;);</a>
<a name="ln338">    gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;album_list), FALSE);</a>
<a name="ln339">  }</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">static flickcurl_photoset **_flickr_api_photosets(_flickr_api_context_t *ctx, const char *user)</a>
<a name="ln343">{</a>
<a name="ln344">  flickcurl_photoset **photoset;</a>
<a name="ln345">  //  char *nsid;</a>
<a name="ln346"> </a>
<a name="ln347">  // TODO: Support both userid and email. As more services uses email as username</a>
<a name="ln348">  //      users can confuse the needed id to be introduced in the user field.</a>
<a name="ln349">  //  nsid = flickcurl_people_findByEmail(ctx-&gt;fc, &quot;@&quot;);</a>
<a name="ln350"> </a>
<a name="ln351">  //  no need to specify nsid at all</a>
<a name="ln352">  //  nsid = flickcurl_people_findByUsername(ctx-&gt;fc, user);</a>
<a name="ln353"> </a>
<a name="ln354">  // &quot;If none is specified, the calling user is assumed (or NULL) &quot;</a>
<a name="ln355">  // (c) http://librdf.org/flickcurl/api/flickcurl-section-photoset.html#flickcurl-photosets-getList</a>
<a name="ln356">  photoset = flickcurl_photosets_getList(ctx-&gt;fc, NULL);</a>
<a name="ln357"> </a>
<a name="ln358">  return photoset;</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">/** Refresh albums */</a>
<a name="ln362">static void refresh_albums(dt_storage_flickr_gui_data_t *ui)</a>
<a name="ln363">{</a>
<a name="ln364">  int i;</a>
<a name="ln365">  gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;album_list), FALSE);</a>
<a name="ln366"> </a>
<a name="ln367">  if(ui-&gt;flickr_api == NULL || ui-&gt;flickr_api-&gt;needsReauthentication == TRUE)</a>
<a name="ln368">  {</a>
<a name="ln369">    if(ui-&gt;flickr_api != NULL) _flickr_api_free(ui-&gt;flickr_api);</a>
<a name="ln370">    ui-&gt;flickr_api = _flickr_api_authenticate(ui);</a>
<a name="ln371">    if(ui-&gt;flickr_api != NULL)</a>
<a name="ln372">    {</a>
<a name="ln373">      set_status(ui, _(&quot;authenticated&quot;), &quot;#7fe07f&quot;);</a>
<a name="ln374">    }</a>
<a name="ln375">    else</a>
<a name="ln376">    {</a>
<a name="ln377">      set_status(ui, _(&quot;not authenticated&quot;), &quot;#e07f7f&quot;);</a>
<a name="ln378">      gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;album_list), FALSE);</a>
<a name="ln379">      return;</a>
<a name="ln380">    }</a>
<a name="ln381">  }</a>
<a name="ln382"> </a>
<a name="ln383">  // First clear the cobobox except first 2 items (none / create new album)</a>
<a name="ln384">  dt_bauhaus_combobox_clear(ui-&gt;album_list);</a>
<a name="ln385"> </a>
<a name="ln386">  ui-&gt;albums = _flickr_api_photosets(ui-&gt;flickr_api, gtk_entry_get_text(ui-&gt;user_entry));</a>
<a name="ln387">  if(ui-&gt;albums)</a>
<a name="ln388">  {</a>
<a name="ln389"> </a>
<a name="ln390">    // Add standard action</a>
<a name="ln391">    dt_bauhaus_combobox_add(ui-&gt;album_list, _(&quot;without album&quot;));</a>
<a name="ln392">    dt_bauhaus_combobox_add(ui-&gt;album_list, _(&quot;create new album&quot;));</a>
<a name="ln393">//     dt_bauhaus_combobox_add(ui-&gt;album_list, &quot;&quot;); // Separator // FIXME: bauhaus doesn't support separators</a>
<a name="ln394"> </a>
<a name="ln395">    // Then add albums from list...</a>
<a name="ln396">    for(i = 0; ui-&gt;albums[i]; i++)</a>
<a name="ln397">    {</a>
<a name="ln398">      char data[512] = { 0 };</a>
<a name="ln399">      snprintf(data, sizeof(data), &quot;%s (%i)&quot;, ui-&gt;albums[i]-&gt;title, ui-&gt;albums[i]-&gt;photos_count);</a>
<a name="ln400">      dt_bauhaus_combobox_add(ui-&gt;album_list, data);</a>
<a name="ln401">    }</a>
<a name="ln402">    dt_bauhaus_combobox_set(ui-&gt;album_list, 2);</a>
<a name="ln403">    gtk_widget_hide(GTK_WIDGET(ui-&gt;create_box)); // Hide create album box...</a>
<a name="ln404">  }</a>
<a name="ln405">  else</a>
<a name="ln406">  {</a>
<a name="ln407">    // Failed to parse feed of album...</a>
<a name="ln408">    // Lets notify somehow...</a>
<a name="ln409">    dt_bauhaus_combobox_set(ui-&gt;album_list, 0);</a>
<a name="ln410">  }</a>
<a name="ln411">  gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;album_list), TRUE);</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414"> </a>
<a name="ln415">static void flickr_album_changed(GtkComboBox *cb, gpointer data)</a>
<a name="ln416">{</a>
<a name="ln417">  dt_storage_flickr_gui_data_t *ui = (dt_storage_flickr_gui_data_t *)data;</a>
<a name="ln418">  const gchar *value = dt_bauhaus_combobox_get_text(ui-&gt;album_list);</a>
<a name="ln419">  if(value != NULL &amp;&amp; strcmp(value, _(&quot;create new album&quot;)) == 0)</a>
<a name="ln420">  {</a>
<a name="ln421">    gtk_widget_set_no_show_all(GTK_WIDGET(ui-&gt;create_box), FALSE);</a>
<a name="ln422">    gtk_widget_show_all(GTK_WIDGET(ui-&gt;create_box));</a>
<a name="ln423">  }</a>
<a name="ln424">  else</a>
<a name="ln425">    gtk_widget_hide(GTK_WIDGET(ui-&gt;create_box));</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">// Refresh button pressed...</a>
<a name="ln429">static void flickr_button1_clicked(GtkButton *button, gpointer data)</a>
<a name="ln430">{</a>
<a name="ln431">  dt_storage_flickr_gui_data_t *ui = (dt_storage_flickr_gui_data_t *)data;</a>
<a name="ln432">  refresh_albums(ui);</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">/*</a>
<a name="ln436">static gboolean</a>
<a name="ln437">focus_in(GtkWidget *widget, GdkEventFocus *event, gpointer user_data)</a>
<a name="ln438">{</a>
<a name="ln439">  dt_control_tab_shortcut_off(darktable.control);</a>
<a name="ln440">  return FALSE;</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">static gboolean</a>
<a name="ln444">focus_out(GtkWidget *widget, GdkEventFocus *event, gpointer user_data)</a>
<a name="ln445">{</a>
<a name="ln446">  dt_control_tab_shortcut_on(darktable.control);</a>
<a name="ln447">  return FALSE;</a>
<a name="ln448">}</a>
<a name="ln449">*/</a>
<a name="ln450"> </a>
<a name="ln451">void gui_init(dt_imageio_module_storage_t *self)</a>
<a name="ln452">{</a>
<a name="ln453">  self-&gt;gui_data = (dt_storage_flickr_gui_data_t *)g_malloc0(sizeof(dt_storage_flickr_gui_data_t));</a>
<a name="ln454">  dt_storage_flickr_gui_data_t *ui = self-&gt;gui_data;</a>
<a name="ln455">  self-&gt;widget = gtk_grid_new();</a>
<a name="ln456">  gtk_grid_set_row_spacing(GTK_GRID(self-&gt;widget), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln457">  gtk_grid_set_column_spacing(GTK_GRID(self-&gt;widget), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln458">  int line = 0;</a>
<a name="ln459"> </a>
<a name="ln460">  GHashTable *table = dt_pwstorage_get(&quot;flickr&quot;);</a>
<a name="ln461">  gchar *_username = g_strdup(g_hash_table_lookup(table, &quot;username&quot;));</a>
<a name="ln462">  g_hash_table_destroy(table);</a>
<a name="ln463"> </a>
<a name="ln464">  GtkWidget *hbox, *label, *button;</a>
<a name="ln465"> </a>
<a name="ln466"> </a>
<a name="ln467">  label = gtk_label_new(_(&quot;flickr user&quot;));</a>
<a name="ln468">  g_object_set(G_OBJECT(label), &quot;xalign&quot;, 0.0, (gchar *)0);</a>
<a name="ln469">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln470"> </a>
<a name="ln471">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln472"> </a>
<a name="ln473">  ui-&gt;user_entry = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln474">  gtk_widget_set_hexpand(GTK_WIDGET(ui-&gt;user_entry), TRUE);</a>
<a name="ln475">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(ui-&gt;user_entry));</a>
<a name="ln476">  gtk_entry_set_text(ui-&gt;user_entry, _username == NULL ? &quot;&quot; : _username);</a>
<a name="ln477">  g_signal_connect(G_OBJECT(ui-&gt;user_entry), &quot;changed&quot;, G_CALLBACK(flickr_entry_changed), (gpointer)ui);</a>
<a name="ln478">  gtk_entry_set_width_chars(GTK_ENTRY(ui-&gt;user_entry), 0);</a>
<a name="ln479"> </a>
<a name="ln480">  button = gtk_button_new_with_label(_(&quot;login&quot;));</a>
<a name="ln481">  gtk_widget_set_tooltip_text(button, _(&quot;flickr login&quot;));</a>
<a name="ln482">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(flickr_button1_clicked), (gpointer)ui);</a>
<a name="ln483">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(ui-&gt;user_entry), TRUE, TRUE, 0);</a>
<a name="ln484">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);</a>
<a name="ln485"> </a>
<a name="ln486">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), hbox, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln487"> </a>
<a name="ln488"> </a>
<a name="ln489">  ui-&gt;status_label = GTK_LABEL(gtk_label_new(NULL));</a>
<a name="ln490">  gtk_widget_set_halign(GTK_WIDGET(ui-&gt;status_label), GTK_ALIGN_START);</a>
<a name="ln491">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(ui-&gt;status_label), 1, line++, 1, 1);</a>
<a name="ln492"> </a>
<a name="ln493"> </a>
<a name="ln494">  ui-&gt;export_tags = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln495">  dt_bauhaus_widget_set_label(ui-&gt;export_tags, NULL, _(&quot;export tags&quot;));</a>
<a name="ln496">  dt_bauhaus_combobox_add(ui-&gt;export_tags, _(&quot;yes&quot;));</a>
<a name="ln497">  dt_bauhaus_combobox_add(ui-&gt;export_tags, _(&quot;no&quot;));</a>
<a name="ln498">  dt_bauhaus_combobox_set(ui-&gt;export_tags, 0);</a>
<a name="ln499">  gtk_widget_set_hexpand(ui-&gt;export_tags, TRUE);</a>
<a name="ln500">  gtk_grid_attach(GTK_GRID(self-&gt;widget), ui-&gt;export_tags, 0, line++, 2, 1);</a>
<a name="ln501"> </a>
<a name="ln502"> </a>
<a name="ln503">  ui-&gt;permission_list = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln504">  dt_bauhaus_widget_set_label(ui-&gt;permission_list, NULL, _(&quot;visible to&quot;));</a>
<a name="ln505">  dt_bauhaus_combobox_add(ui-&gt;permission_list, _(&quot;you&quot;));</a>
<a name="ln506">  dt_bauhaus_combobox_add(ui-&gt;permission_list, _(&quot;friends&quot;));</a>
<a name="ln507">  dt_bauhaus_combobox_add(ui-&gt;permission_list, _(&quot;family&quot;));</a>
<a name="ln508">  dt_bauhaus_combobox_add(ui-&gt;permission_list, _(&quot;friends + family&quot;));</a>
<a name="ln509">  dt_bauhaus_combobox_add(ui-&gt;permission_list, _(&quot;everyone&quot;));</a>
<a name="ln510">  dt_bauhaus_combobox_set(ui-&gt;permission_list, 0); // Set default permission to private</a>
<a name="ln511">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(ui-&gt;permission_list), 0, line++, 2, 1);</a>
<a name="ln512"> </a>
<a name="ln513"> </a>
<a name="ln514">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln515"> </a>
<a name="ln516">  ui-&gt;album_list = dt_bauhaus_combobox_new(NULL); // Available albums</a>
<a name="ln517">  dt_bauhaus_widget_set_label(ui-&gt;album_list, NULL, _(&quot;photosets&quot;));</a>
<a name="ln518">  g_signal_connect(G_OBJECT(ui-&gt;album_list), &quot;value-changed&quot;, G_CALLBACK(flickr_album_changed), (gpointer)ui);</a>
<a name="ln519">  gtk_widget_set_sensitive(ui-&gt;album_list, FALSE);</a>
<a name="ln520">  gtk_box_pack_start(GTK_BOX(hbox), ui-&gt;album_list, TRUE, TRUE, 0);</a>
<a name="ln521"> </a>
<a name="ln522">  button = dtgtk_button_new(dtgtk_cairo_paint_refresh, CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln523">  gtk_widget_set_tooltip_text(button, _(&quot;refresh album list&quot;));</a>
<a name="ln524">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(flickr_button1_clicked), (gpointer)ui);</a>
<a name="ln525">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);</a>
<a name="ln526"> </a>
<a name="ln527">  gtk_grid_attach(GTK_GRID(self-&gt;widget), hbox, 0, line++, 2, 1);</a>
<a name="ln528"> </a>
<a name="ln529"> </a>
<a name="ln530">  // the box that gets shown when a new album is to be created</a>
<a name="ln531">  ui-&gt;create_box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));</a>
<a name="ln532">  gtk_widget_set_no_show_all(GTK_WIDGET(ui-&gt;create_box), TRUE);</a>
<a name="ln533">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(ui-&gt;create_box), 0, line++, 2, 1);</a>
<a name="ln534"> </a>
<a name="ln535"> </a>
<a name="ln536">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln537"> </a>
<a name="ln538">  label = gtk_label_new(_(&quot;title&quot;));</a>
<a name="ln539">  g_object_set(G_OBJECT(label), &quot;xalign&quot;, 0.0, (gchar *)0);</a>
<a name="ln540">  gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);</a>
<a name="ln541"> </a>
<a name="ln542">  ui-&gt;title_entry = GTK_ENTRY(gtk_entry_new()); // Album title</a>
<a name="ln543">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(ui-&gt;title_entry));</a>
<a name="ln544">  gtk_entry_set_text(ui-&gt;title_entry, _(&quot;my new photoset&quot;));</a>
<a name="ln545">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(ui-&gt;title_entry), TRUE, TRUE, 0);</a>
<a name="ln546">  gtk_entry_set_width_chars(GTK_ENTRY(ui-&gt;title_entry), 0);</a>
<a name="ln547"> </a>
<a name="ln548">  gtk_box_pack_start(ui-&gt;create_box, hbox, FALSE, FALSE, 0);</a>
<a name="ln549"> </a>
<a name="ln550"> </a>
<a name="ln551">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln552"> </a>
<a name="ln553">  label = gtk_label_new(_(&quot;summary&quot;));</a>
<a name="ln554">  g_object_set(G_OBJECT(label), &quot;xalign&quot;, 0.0, (gchar *)0);</a>
<a name="ln555">  gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);</a>
<a name="ln556"> </a>
<a name="ln557">  ui-&gt;summary_entry = GTK_ENTRY(gtk_entry_new()); // Album summary</a>
<a name="ln558">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(ui-&gt;summary_entry));</a>
<a name="ln559">  gtk_entry_set_text(ui-&gt;summary_entry, _(&quot;exported from darktable&quot;));</a>
<a name="ln560">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(ui-&gt;summary_entry), TRUE, TRUE, 0);</a>
<a name="ln561">  gtk_entry_set_width_chars(GTK_ENTRY(ui-&gt;summary_entry), 0);</a>
<a name="ln562"> </a>
<a name="ln563">  gtk_box_pack_start(ui-&gt;create_box, hbox, TRUE, TRUE, 0);</a>
<a name="ln564"> </a>
<a name="ln565"> </a>
<a name="ln566">  set_status(ui, _(&quot;click login button to start&quot;), &quot;#ffffff&quot;);</a>
<a name="ln567"> </a>
<a name="ln568">  /**</a>
<a name="ln569">  don't populate the combo on startup, save 3 second</a>
<a name="ln570"> </a>
<a name="ln571">  // If username and password is stored, let's populate the combo</a>
<a name="ln572">  if( _username &amp;&amp; _password )</a>
<a name="ln573">  {</a>
<a name="ln574">    ui-&gt;user_token = _password;</a>
<a name="ln575">    refresh_albums(ui);</a>
<a name="ln576">  }</a>
<a name="ln577">  */</a>
<a name="ln578"> </a>
<a name="ln579">  g_free(_username);</a>
<a name="ln580">  dt_bauhaus_combobox_set(ui-&gt;album_list, 0);</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">void gui_cleanup(dt_imageio_module_storage_t *self)</a>
<a name="ln584">{</a>
<a name="ln585">  dt_storage_flickr_gui_data_t *ui = self-&gt;gui_data;</a>
<a name="ln586">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ui-&gt;user_entry));</a>
<a name="ln587">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ui-&gt;title_entry));</a>
<a name="ln588">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ui-&gt;summary_entry));</a>
<a name="ln589">  g_free(self-&gt;gui_data);</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">void gui_reset(dt_imageio_module_storage_t *self)</a>
<a name="ln593">{</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">int store(dt_imageio_module_storage_t *self, dt_imageio_module_data_t *sdata, const int imgid,</a>
<a name="ln597">          dt_imageio_module_format_t *format, dt_imageio_module_data_t *fdata, const int num, const int total,</a>
<a name="ln598">          const gboolean high_quality, const gboolean upscale, dt_colorspaces_color_profile_type_t icc_type,</a>
<a name="ln599">          const gchar *icc_filename, dt_iop_color_intent_t icc_intent)</a>
<a name="ln600">{</a>
<a name="ln601">  gint result = 0;</a>
<a name="ln602">  dt_storage_flickr_params_t *p = (dt_storage_flickr_params_t *)sdata;</a>
<a name="ln603">  flickcurl_upload_status *photo_status;</a>
<a name="ln604">  gint tags = 0;</a>
<a name="ln605"> </a>
<a name="ln606">  const char *ext = format-&gt;extension(fdata);</a>
<a name="ln607"> </a>
<a name="ln608">  // Let's upload image...</a>
<a name="ln609"> </a>
<a name="ln610">  /* construct a temporary file name */</a>
<a name="ln611">  char fname[PATH_MAX] = { 0 };</a>
<a name="ln612">  dt_loc_get_tmp_dir(fname, sizeof(fname));</a>
<a name="ln613">  g_strlcat(fname, &quot;/darktable.XXXXXX.&quot;, sizeof(fname));</a>
<a name="ln614">  g_strlcat(fname, ext, sizeof(fname));</a>
<a name="ln615"> </a>
<a name="ln616">  char *caption = NULL;</a>
<a name="ln617">  char *description = NULL;</a>
<a name="ln618"> </a>
<a name="ln619"> </a>
<a name="ln620">  gint fd = g_mkstemp(fname);</a>
<a name="ln621">  fprintf(stderr, &quot;tempfile: %s\n&quot;, fname);</a>
<a name="ln622">  if(fd == -1)</a>
<a name="ln623">  {</a>
<a name="ln624">    dt_control_log(&quot;failed to create temporary image for flickr export&quot;);</a>
<a name="ln625">    return 1;</a>
<a name="ln626">  }</a>
<a name="ln627">  close(fd);</a>
<a name="ln628">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln629"> </a>
<a name="ln630">  // If title is not existing, then use the filename without extension. If not, then use title instead</a>
<a name="ln631">  GList *title = dt_metadata_get(img-&gt;id, &quot;Xmp.dc.title&quot;, NULL);</a>
<a name="ln632">  if(title != NULL)</a>
<a name="ln633">  {</a>
<a name="ln634">    caption = g_strdup(title-&gt;data);</a>
<a name="ln635">    g_list_free_full(title, &amp;g_free);</a>
<a name="ln636">  }</a>
<a name="ln637">  else</a>
<a name="ln638">  {</a>
<a name="ln639">    caption = g_path_get_basename(img-&gt;filename);</a>
<a name="ln640">    (g_strrstr(caption, &quot;.&quot;))[0] = '\0'; // chop extension...</a>
<a name="ln641">  }</a>
<a name="ln642"> </a>
<a name="ln643">  GList *desc = dt_metadata_get(img-&gt;id, &quot;Xmp.dc.description&quot;, NULL);</a>
<a name="ln644">  if(desc != NULL)</a>
<a name="ln645">  {</a>
<a name="ln646">    description = desc-&gt;data;</a>
<a name="ln647">  }</a>
<a name="ln648">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln649"> </a>
<a name="ln650">  if(dt_imageio_export(imgid, fname, format, fdata, high_quality, upscale, FALSE, icc_type, icc_filename, icc_intent,</a>
<a name="ln651">                       self, sdata, num, total) != 0)</a>
<a name="ln652">  {</a>
<a name="ln653">    fprintf(stderr, &quot;[imageio_storage_flickr] could not export to file: `%s'!\n&quot;, fname);</a>
<a name="ln654">    dt_control_log(_(&quot;could not export to file `%s'!&quot;), fname);</a>
<a name="ln655">    result = 1;</a>
<a name="ln656">    goto cleanup;</a>
<a name="ln657">  }</a>
<a name="ln658"> </a>
<a name="ln659">#ifdef _OPENMP</a>
<a name="ln660">#pragma omp critical</a>
<a name="ln661">#endif</a>
<a name="ln662">  {</a>
<a name="ln663">    // TODO: Check if this could be done in threads, so we enhance export time by using</a>
<a name="ln664">    //      upload time for one image to export another image to disk.</a>
<a name="ln665">    // Upload image</a>
<a name="ln666">    // Do we export tags?</a>
<a name="ln667">    if(p-&gt;export_tags == TRUE) tags = imgid;</a>
<a name="ln668">    photo_status = _flickr_api_upload_photo(p, fname, caption, description, tags);</a>
<a name="ln669">  }</a>
<a name="ln670"> </a>
<a name="ln671">  if(!photo_status)</a>
<a name="ln672">  {</a>
<a name="ln673">    fprintf(stderr, &quot;[imageio_storage_flickr] could not upload to flickr!\n&quot;);</a>
<a name="ln674">    dt_control_log(_(&quot;could not upload to flickr!&quot;));</a>
<a name="ln675">    result = 1;</a>
<a name="ln676">    goto cleanup;</a>
<a name="ln677">  }</a>
<a name="ln678"> </a>
<a name="ln679">  //  int fail = 0;</a>
<a name="ln680">  // A photoset is only created if we have an album title set</a>
<a name="ln681">  if(p-&gt;flickr_api-&gt;current_album == NULL &amp;&amp; p-&gt;flickr_api-&gt;new_album == TRUE)</a>
<a name="ln682">  {</a>
<a name="ln683">    char *photoset_id;</a>
<a name="ln684">    photoset_id = _flickr_api_create_photoset(p-&gt;flickr_api, photo_status-&gt;photoid);</a>
<a name="ln685"> </a>
<a name="ln686">    if(photoset_id == NULL)</a>
<a name="ln687">    {</a>
<a name="ln688">      dt_control_log(&quot;failed to create flickr album&quot;);</a>
<a name="ln689">      //      fail = 1;</a>
<a name="ln690">    }</a>
<a name="ln691">    else</a>
<a name="ln692">    {</a>
<a name="ln693">      //      p-&gt;flickr_api-&gt;new_album = FALSE;</a>
<a name="ln694">      p-&gt;flickr_api-&gt;current_album = flickcurl_photosets_getInfo(p-&gt;flickr_api-&gt;fc, photoset_id);</a>
<a name="ln695">    }</a>
<a name="ln696">  }</a>
<a name="ln697"> </a>
<a name="ln698">  //  if(fail) return 1;</a>
<a name="ln699">  // TODO: What to do if photoset creation fails?</a>
<a name="ln700"> </a>
<a name="ln701">  // Add to gallery, if needed</a>
<a name="ln702">  if(p-&gt;flickr_api-&gt;current_album != NULL &amp;&amp; p-&gt;flickr_api-&gt;new_album != TRUE)</a>
<a name="ln703">  {</a>
<a name="ln704">    flickcurl_photosets_addPhoto(p-&gt;flickr_api-&gt;fc, p-&gt;flickr_api-&gt;current_album-&gt;id, photo_status-&gt;photoid);</a>
<a name="ln705">    // TODO: Check for errors adding photo to gallery</a>
<a name="ln706">  }</a>
<a name="ln707">  else</a>
<a name="ln708">  {</a>
<a name="ln709">    if(p-&gt;flickr_api-&gt;current_album != NULL &amp;&amp; p-&gt;flickr_api-&gt;new_album == TRUE)</a>
<a name="ln710">    {</a>
<a name="ln711">      p-&gt;flickr_api-&gt;new_album = FALSE;</a>
<a name="ln712">    }</a>
<a name="ln713">  }</a>
<a name="ln714"> </a>
<a name="ln715">cleanup:</a>
<a name="ln716"> </a>
<a name="ln717">  // And remove from filesystem..</a>
<a name="ln718">  g_unlink(fname);</a>
<a name="ln719">  g_free(caption);</a>
<a name="ln720">  if(desc) g_list_free_full(desc, &amp;g_free);</a>
<a name="ln721"> </a>
<a name="ln722">  if(!result)</a>
<a name="ln723">  {</a>
<a name="ln724">    // this makes sense only if the export was successful</a>
<a name="ln725">    dt_control_log(ngettext(&quot;%d/%d exported to flickr webalbum&quot;, &quot;%d/%d exported to flickr webalbum&quot;, num),</a>
<a name="ln726">                   num, total);</a>
<a name="ln727">  }</a>
<a name="ln728">  return result;</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731">size_t params_size(dt_imageio_module_storage_t *self)</a>
<a name="ln732">{</a>
<a name="ln733">  return sizeof(int64_t);</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">void init(dt_imageio_module_storage_t *self)</a>
<a name="ln737">{</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">void *get_params(dt_imageio_module_storage_t *self)</a>
<a name="ln741">{</a>
<a name="ln742">  // have to return the size of the struct to store (i.e. without all the variable pointers at the end)</a>
<a name="ln743">  // TODO: if a hash to encrypted data is stored here, return only this size and store it at the beginning of</a>
<a name="ln744">  // the struct!</a>
<a name="ln745">  dt_storage_flickr_gui_data_t *ui = (dt_storage_flickr_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln746">  if(!ui) return NULL; // gui not initialized, CLI mode</a>
<a name="ln747">  dt_storage_flickr_params_t *d = (dt_storage_flickr_params_t *)g_malloc0(sizeof(dt_storage_flickr_params_t));</a>
<a name="ln748">  if(!d) return NULL;</a>
<a name="ln749">  d-&gt;hash = 1;</a>
<a name="ln750"> </a>
<a name="ln751">  // fill d from controls in ui</a>
<a name="ln752">  if(ui-&gt;flickr_api &amp;&amp; ui-&gt;flickr_api-&gt;needsReauthentication == FALSE)</a>
<a name="ln753">  {</a>
<a name="ln754">    // We are authenticated and off to actually export images..</a>
<a name="ln755">    d-&gt;flickr_api = ui-&gt;flickr_api;</a>
<a name="ln756">    int index = dt_bauhaus_combobox_get(ui-&gt;album_list);</a>
<a name="ln757">    if(index &gt;= 0)</a>
<a name="ln758">    {</a>
<a name="ln759">      switch(index)</a>
<a name="ln760">      {</a>
<a name="ln761">        case 0: // No album</a>
<a name="ln762">          d-&gt;flickr_api-&gt;current_album = NULL;</a>
<a name="ln763">          break;</a>
<a name="ln764">        case 1: // Create new album</a>
<a name="ln765">          d-&gt;flickr_api-&gt;current_album = NULL;</a>
<a name="ln766">          d-&gt;flickr_api-&gt;album_title = g_strdup(gtk_entry_get_text(ui-&gt;title_entry));</a>
<a name="ln767">          d-&gt;flickr_api-&gt;album_summary = g_strdup(gtk_entry_get_text(ui-&gt;summary_entry));</a>
<a name="ln768">          d-&gt;flickr_api-&gt;new_album = TRUE;</a>
<a name="ln769">          break;</a>
<a name="ln770">        default:</a>
<a name="ln771">          // use existing album</a>
<a name="ln772">          d-&gt;flickr_api-&gt;current_album</a>
<a name="ln773">              = flickcurl_photosets_getInfo(d-&gt;flickr_api-&gt;fc, ui-&gt;albums[index - 2]-&gt;id);</a>
<a name="ln774">          if(d-&gt;flickr_api-&gt;current_album == NULL)</a>
<a name="ln775">          {</a>
<a name="ln776">            // Something went wrong...</a>
<a name="ln777">            fprintf(stderr, &quot;Something went wrong.. album index %d = NULL\n&quot;, index - 2);</a>
<a name="ln778">            g_free(d);</a>
<a name="ln779">            return NULL;</a>
<a name="ln780">          }</a>
<a name="ln781">          break;</a>
<a name="ln782">      }</a>
<a name="ln783">    }</a>
<a name="ln784">    else</a>
<a name="ln785">    {</a>
<a name="ln786">      g_free(d);</a>
<a name="ln787">      return NULL;</a>
<a name="ln788">    }</a>
<a name="ln789"> </a>
<a name="ln790">    d-&gt;export_tags = (dt_bauhaus_combobox_get(ui-&gt;export_tags) == 0);</a>
<a name="ln791"> </a>
<a name="ln792">    /* Handle the permissions */</a>
<a name="ln793">    int perm_index = (int)dt_bauhaus_combobox_get(ui-&gt;permission_list);</a>
<a name="ln794">    switch(perm_index)</a>
<a name="ln795">    {</a>
<a name="ln796">      case 0: // Private</a>
<a name="ln797">        d-&gt;public_perm = 0;</a>
<a name="ln798">        d-&gt;friend_perm = 0;</a>
<a name="ln799">        d-&gt;family_perm = 0;</a>
<a name="ln800">        break;</a>
<a name="ln801">      case 1: // Friends</a>
<a name="ln802">        d-&gt;public_perm = 0;</a>
<a name="ln803">        d-&gt;friend_perm = 1;</a>
<a name="ln804">        d-&gt;family_perm = 0;</a>
<a name="ln805">        break;</a>
<a name="ln806">      case 2: // Family</a>
<a name="ln807">        d-&gt;public_perm = 0;</a>
<a name="ln808">        d-&gt;friend_perm = 0;</a>
<a name="ln809">        d-&gt;family_perm = 1;</a>
<a name="ln810">        break;</a>
<a name="ln811">      case 3: // Friend + Family</a>
<a name="ln812">        d-&gt;public_perm = 0;</a>
<a name="ln813">        d-&gt;friend_perm = 1;</a>
<a name="ln814">        d-&gt;family_perm = 1;</a>
<a name="ln815">        break;</a>
<a name="ln816">      case 4: // Public</a>
<a name="ln817">        d-&gt;public_perm = 1;</a>
<a name="ln818">        d-&gt;friend_perm = 0;</a>
<a name="ln819">        d-&gt;family_perm = 0;</a>
<a name="ln820">        break;</a>
<a name="ln821">    }</a>
<a name="ln822"> </a>
<a name="ln823">    // Let UI forget about this api context and recreate a new one for further usage...</a>
<a name="ln824">    ui-&gt;flickr_api = _flickr_api_authenticate(ui);</a>
<a name="ln825">    if(ui-&gt;flickr_api)</a>
<a name="ln826">    {</a>
<a name="ln827">      set_status(ui, _(&quot;authenticated&quot;), &quot;#7fe07f&quot;);</a>
<a name="ln828">    }</a>
<a name="ln829">    else</a>
<a name="ln830">    {</a>
<a name="ln831">      set_status(ui, _(&quot;not authenticated&quot;), &quot;#e07f7f&quot;);</a>
<a name="ln832">      gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;album_list), FALSE);</a>
<a name="ln833">    }</a>
<a name="ln834">  }</a>
<a name="ln835">  else</a>
<a name="ln836">  {</a>
<a name="ln837">    set_status(ui, _(&quot;not authenticated&quot;), &quot;#e07f7f&quot;);</a>
<a name="ln838">    gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;album_list), FALSE);</a>
<a name="ln839">    g_free(d);</a>
<a name="ln840">    return NULL;</a>
<a name="ln841">  }</a>
<a name="ln842">  return d;</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">int set_params(dt_imageio_module_storage_t *self, const void *params, const int size)</a>
<a name="ln846">{</a>
<a name="ln847">  if(size != self-&gt;params_size(self)) return 1;</a>
<a name="ln848">  // gui stuff not updated, as sensitive user data is not stored in the preset.</a>
<a name="ln849">  // TODO: store name/hash in kwallet/etc module and get encrypted stuff from there!</a>
<a name="ln850">  return 0;</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853">int supported(dt_imageio_module_storage_t *storage, dt_imageio_module_format_t *format)</a>
<a name="ln854">{</a>
<a name="ln855">  if(strcmp(format-&gt;mime(NULL), &quot;image/jpeg&quot;) == 0)</a>
<a name="ln856">    return 1;</a>
<a name="ln857">  else if(strcmp(format-&gt;mime(NULL), &quot;image/png&quot;) == 0)</a>
<a name="ln858">    return 1;</a>
<a name="ln859"> </a>
<a name="ln860">  return 0;</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">void free_params(dt_imageio_module_storage_t *self, dt_imageio_module_data_t *params)</a>
<a name="ln864">{</a>
<a name="ln865">  if(!params) return;</a>
<a name="ln866"> </a>
<a name="ln867">  dt_storage_flickr_params_t *d = (dt_storage_flickr_params_t *)params;</a>
<a name="ln868"> </a>
<a name="ln869">  _flickr_api_free(d-&gt;flickr_api); // TODO</a>
<a name="ln870"> </a>
<a name="ln871">  free(params);</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln875">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln876">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="228"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="230"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'flickr_user_token' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="258"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'free' function. Inspect the first argument.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
