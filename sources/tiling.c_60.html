
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011--2014 Ulrich Pegelow.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;develop/tiling.h&quot;</a>
<a name="ln21">#include &quot;common/opencl.h&quot;</a>
<a name="ln22">#include &quot;control/control.h&quot;</a>
<a name="ln23">#include &quot;develop/blend.h&quot;</a>
<a name="ln24">#include &quot;develop/pixelpipe.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;assert.h&gt;</a>
<a name="ln27">#include &lt;math.h&gt;</a>
<a name="ln28">#include &lt;stdlib.h&gt;</a>
<a name="ln29">#include &lt;string.h&gt;</a>
<a name="ln30">#include &lt;strings.h&gt;</a>
<a name="ln31">#include &lt;unistd.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#define CLAMPI(a, mn, mx) ((a) &lt; (mn) ? (mn) : ((a) &gt; (mx) ? (mx) : (a)))</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">/* this defines an additional alignment requirement for opencl image width.</a>
<a name="ln37">   It can have strong effects on processing speed. Reasonable values are a</a>
<a name="ln38">   power of 2. set to 1 for no effect. */</a>
<a name="ln39">#define CL_ALIGNMENT 4</a>
<a name="ln40"> </a>
<a name="ln41">/* parameter RESERVE for extended roi_in sizes due to inaccuracies when doing</a>
<a name="ln42">   roi_out -&gt; roi_in estimations.</a>
<a name="ln43">   Needs to be increased if tiling fails due to insufficient buffer sizes. */</a>
<a name="ln44">#define RESERVE 5</a>
<a name="ln45"> </a>
<a name="ln46"> </a>
<a name="ln47">/* greatest common divisor */</a>
<a name="ln48">static unsigned _gcd(unsigned a, unsigned b)</a>
<a name="ln49">{</a>
<a name="ln50">  unsigned t;</a>
<a name="ln51">  while(b != 0)</a>
<a name="ln52">  {</a>
<a name="ln53">    t = b;</a>
<a name="ln54">    b = a % b;</a>
<a name="ln55">    a = t;</a>
<a name="ln56">  }</a>
<a name="ln57">  return a;</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">/* least common multiple */</a>
<a name="ln61">static unsigned _lcm(unsigned a, unsigned b)</a>
<a name="ln62">{</a>
<a name="ln63">  return (((unsigned long)a * b) / _gcd(a, b));</a>
<a name="ln64">}</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">static inline int _min(int a, int b)</a>
<a name="ln68">{</a>
<a name="ln69">  return a &lt; b ? a : b;</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">static inline int _max(int a, int b)</a>
<a name="ln73">{</a>
<a name="ln74">  return a &gt; b ? a : b;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">static inline int _align_up(int n, int a)</a>
<a name="ln79">{</a>
<a name="ln80">  return n % a != 0 ? (n / a + 1) * a : n;</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">static inline int _align_down(int n, int a)</a>
<a name="ln84">{</a>
<a name="ln85">  return n % a != 0 ? (n / a) * a : n;</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88"> </a>
<a name="ln89">void _print_roi(const dt_iop_roi_t *roi, const char *label)</a>
<a name="ln90">{</a>
<a name="ln91">  printf(&quot;{ %5d  %5d  %5d  %5d  %.6f } %s\n&quot;, roi-&gt;x, roi-&gt;y, roi-&gt;width, roi-&gt;height, roi-&gt;scale, label);</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">#if 0</a>
<a name="ln96">static void</a>
<a name="ln97">_nm_constraints(double x[], int n)</a>
<a name="ln98">{</a>
<a name="ln99">  x[0] = fabs(x[0]);</a>
<a name="ln100">  x[1] = fabs(x[1]);</a>
<a name="ln101">  x[2] = fabs(x[2]);</a>
<a name="ln102">  x[3] = fabs(x[3]);</a>
<a name="ln103"> </a>
<a name="ln104">  if(x[0] &gt; 1.0) x[0] = 1.0 - x[0];</a>
<a name="ln105">  if(x[1] &gt; 1.0) x[1] = 1.0 - x[1];</a>
<a name="ln106">  if(x[2] &gt; 1.0) x[2] = 1.0 - x[2];</a>
<a name="ln107">  if(x[3] &gt; 1.0) x[3] = 1.0 - x[3];</a>
<a name="ln108"> </a>
<a name="ln109">}</a>
<a name="ln110">#endif</a>
<a name="ln111"> </a>
<a name="ln112">static double _nm_fitness(double x[], void *rest[])</a>
<a name="ln113">{</a>
<a name="ln114">  struct dt_iop_module_t *self = (struct dt_iop_module_t *)rest[0];</a>
<a name="ln115">  struct dt_dev_pixelpipe_iop_t *piece = (struct dt_dev_pixelpipe_iop_t *)rest[1];</a>
<a name="ln116">  struct dt_iop_roi_t *iroi = (struct dt_iop_roi_t *)rest[2];</a>
<a name="ln117">  struct dt_iop_roi_t *oroi = (struct dt_iop_roi_t *)rest[3];</a>
<a name="ln118"> </a>
<a name="ln119">  dt_iop_roi_t oroi_test = *oroi;</a>
<a name="ln120">  oroi_test.x = x[0] * piece-&gt;iwidth;</a>
<a name="ln121">  oroi_test.y = x[1] * piece-&gt;iheight;</a>
<a name="ln122">  oroi_test.width = x[2] * piece-&gt;iwidth;</a>
<a name="ln123">  oroi_test.height = x[3] * piece-&gt;iheight;</a>
<a name="ln124"> </a>
<a name="ln125">  dt_iop_roi_t iroi_probe = *iroi;</a>
<a name="ln126">  self-&gt;modify_roi_in(self, piece, &amp;oroi_test, &amp;iroi_probe);</a>
<a name="ln127"> </a>
<a name="ln128">  double fitness = 0.0;</a>
<a name="ln129"> </a>
<a name="ln130">  fitness += (double)(iroi_probe.x - iroi-&gt;x) * (iroi_probe.x - iroi-&gt;x);</a>
<a name="ln131">  fitness += (double)(iroi_probe.y - iroi-&gt;y) * (iroi_probe.y - iroi-&gt;y);</a>
<a name="ln132">  fitness += (double)(iroi_probe.width - iroi-&gt;width) * (iroi_probe.width - iroi-&gt;width);</a>
<a name="ln133">  fitness += (double)(iroi_probe.height - iroi-&gt;height) * (iroi_probe.height - iroi-&gt;height);</a>
<a name="ln134"> </a>
<a name="ln135">  return fitness;</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138"> </a>
<a name="ln139">/* We use a Nelder-Mead simplex algorithm based on an implementation of Michael F. Hutt.</a>
<a name="ln140">   It is covered by the following copyright notice: */</a>
<a name="ln141">/*</a>
<a name="ln142"> * Program: nmsimplex.c</a>
<a name="ln143"> * Author : Michael F. Hutt</a>
<a name="ln144"> * http://www.mikehutt.com</a>
<a name="ln145"> * 11/3/97</a>
<a name="ln146"> *</a>
<a name="ln147"> * An implementation of the Nelder-Mead simplex method.</a>
<a name="ln148"> *</a>
<a name="ln149"> * Copyright (c) 1997-2011 &lt;Michael F. Hutt&gt;</a>
<a name="ln150"> *</a>
<a name="ln151"> * Permission is hereby granted, free of charge, to any person obtaining</a>
<a name="ln152"> * a copy of this software and associated documentation files (the</a>
<a name="ln153"> * &quot;Software&quot;), to deal in the Software without restriction, including</a>
<a name="ln154"> * without limitation the rights to use, copy, modify, merge, publish,</a>
<a name="ln155"> * distribute, sublicense, and/or sell copies of the Software, and to</a>
<a name="ln156"> * permit persons to whom the Software is furnished to do so, subject to</a>
<a name="ln157"> * the following conditions:</a>
<a name="ln158"> *</a>
<a name="ln159"> * The above copyright notice and this permission notice shall be</a>
<a name="ln160"> * included in all copies or substantial portions of the Software.</a>
<a name="ln161"> *</a>
<a name="ln162"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</a>
<a name="ln163"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</a>
<a name="ln164"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</a>
<a name="ln165"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</a>
<a name="ln166"> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</a>
<a name="ln167"> * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</a>
<a name="ln168"> * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln169"> *</a>
<a name="ln170"> */</a>
<a name="ln171"> </a>
<a name="ln172">#define MAX_IT 1000 /* maximum number of iterations */</a>
<a name="ln173">#define ALPHA 1.0   /* reflection coefficient */</a>
<a name="ln174">#define BETA 0.5    /* contraction coefficient */</a>
<a name="ln175">#define GAMMA 2.0   /* expansion coefficient */</a>
<a name="ln176"> </a>
<a name="ln177">static int _simplex(double (*objfunc)(double[], void *[]), double start[], int n, double EPSILON,</a>
<a name="ln178">                    double scale, int maxiter, void (*constrain)(double[], int n), void *rest[])</a>
<a name="ln179">{</a>
<a name="ln180"> </a>
<a name="ln181">  int vs; /* vertex with smallest value */</a>
<a name="ln182">  int vh; /* vertex with next smallest value */</a>
<a name="ln183">  int vg; /* vertex with largest value */</a>
<a name="ln184"> </a>
<a name="ln185">  int i, j = 0, m, row;</a>
<a name="ln186">  int k;   /* track the number of function evaluations */</a>
<a name="ln187">  int itr; /* track the number of iterations */</a>
<a name="ln188"> </a>
<a name="ln189">  double **v;    /* holds vertices of simplex */</a>
<a name="ln190">  double pn, qn; /* values used to create initial simplex */</a>
<a name="ln191">  double *f;     /* value of function at each vertex */</a>
<a name="ln192">  double fr;     /* value of function at reflection point */</a>
<a name="ln193">  double fe;     /* value of function at expansion point */</a>
<a name="ln194">  double fc;     /* value of function at contraction point */</a>
<a name="ln195">  double *vr;    /* reflection - coordinates */</a>
<a name="ln196">  double *ve;    /* expansion - coordinates */</a>
<a name="ln197">  double *vc;    /* contraction - coordinates */</a>
<a name="ln198">  double *vm;    /* centroid - coordinates */</a>
<a name="ln199"> </a>
<a name="ln200">  double fsum, favg, s, cent;</a>
<a name="ln201"> </a>
<a name="ln202">  /* dynamically allocate arrays */</a>
<a name="ln203"> </a>
<a name="ln204">  /* allocate the rows of the arrays */</a>
<a name="ln205">  v = (double **)malloc((n + 1) * sizeof(double *));</a>
<a name="ln206">  f = (double *)malloc((n + 1) * sizeof(double));</a>
<a name="ln207">  vr = (double *)malloc(n * sizeof(double));</a>
<a name="ln208">  ve = (double *)malloc(n * sizeof(double));</a>
<a name="ln209">  vc = (double *)malloc(n * sizeof(double));</a>
<a name="ln210">  vm = (double *)malloc(n * sizeof(double));</a>
<a name="ln211"> </a>
<a name="ln212">  /* allocate the columns of the arrays */</a>
<a name="ln213">  for(i = 0; i &lt;= n; i++)</a>
<a name="ln214">  {</a>
<a name="ln215">    v[i] = (double *)malloc(n * sizeof(double));</a>
<a name="ln216">  }</a>
<a name="ln217"> </a>
<a name="ln218">  /* create the initial simplex */</a>
<a name="ln219">  /* assume one of the vertices is 0,0 */</a>
<a name="ln220"> </a>
<a name="ln221">  pn = scale * (sqrt(n + 1) - 1 + n) / (n * sqrt(2));</a>
<a name="ln222">  qn = scale * (sqrt(n + 1) - 1) / (n * sqrt(2));</a>
<a name="ln223"> </a>
<a name="ln224">  for(i = 0; i &lt; n; i++)</a>
<a name="ln225">  {</a>
<a name="ln226">    v[0][i] = start[i];</a>
<a name="ln227">  }</a>
<a name="ln228"> </a>
<a name="ln229">  for(i = 1; i &lt;= n; i++)</a>
<a name="ln230">  {</a>
<a name="ln231">    for(j = 0; j &lt; n; j++)</a>
<a name="ln232">    {</a>
<a name="ln233">      if(i - 1 == j)</a>
<a name="ln234">      {</a>
<a name="ln235">        v[i][j] = pn + start[j];</a>
<a name="ln236">      }</a>
<a name="ln237">      else</a>
<a name="ln238">      {</a>
<a name="ln239">        v[i][j] = qn + start[j];</a>
<a name="ln240">      }</a>
<a name="ln241">    }</a>
<a name="ln242">  }</a>
<a name="ln243"> </a>
<a name="ln244">  if(constrain != NULL)</a>
<a name="ln245">  {</a>
<a name="ln246">    constrain(v[j], n);</a>
<a name="ln247">  }</a>
<a name="ln248">  /* find the initial function values */</a>
<a name="ln249">  for(j = 0; j &lt;= n; j++)</a>
<a name="ln250">  {</a>
<a name="ln251">    f[j] = objfunc(v[j], rest);</a>
<a name="ln252">  }</a>
<a name="ln253"> </a>
<a name="ln254">  k = n + 1;</a>
<a name="ln255"> </a>
<a name="ln256">#if 0</a>
<a name="ln257">  /* print out the initial values */</a>
<a name="ln258">  printf (&quot;Initial Values\n&quot;);</a>
<a name="ln259">  for (j = 0; j &lt;= n; j++)</a>
<a name="ln260">  {</a>
<a name="ln261">    for (i = 0; i &lt; n; i++)</a>
<a name="ln262">    {</a>
<a name="ln263">      printf (&quot;%f %f\n&quot;, v[j][i], f[j]);</a>
<a name="ln264">    }</a>
<a name="ln265">  }</a>
<a name="ln266">#endif</a>
<a name="ln267"> </a>
<a name="ln268">  /* begin the main loop of the minimization */</a>
<a name="ln269">  for(itr = 1; itr &lt;= maxiter; itr++)</a>
<a name="ln270">  {</a>
<a name="ln271">    /* find the index of the largest value */</a>
<a name="ln272">    vg = 0;</a>
<a name="ln273">    for(j = 0; j &lt;= n; j++)</a>
<a name="ln274">    {</a>
<a name="ln275">      if(f[j] &gt; f[vg])</a>
<a name="ln276">      {</a>
<a name="ln277">        vg = j;</a>
<a name="ln278">      }</a>
<a name="ln279">    }</a>
<a name="ln280"> </a>
<a name="ln281">    /* find the index of the smallest value */</a>
<a name="ln282">    vs = 0;</a>
<a name="ln283">    for(j = 0; j &lt;= n; j++)</a>
<a name="ln284">    {</a>
<a name="ln285">      if(f[j] &lt; f[vs])</a>
<a name="ln286">      {</a>
<a name="ln287">        vs = j;</a>
<a name="ln288">      }</a>
<a name="ln289">    }</a>
<a name="ln290"> </a>
<a name="ln291">    /* find the index of the second largest value */</a>
<a name="ln292">    vh = vs;</a>
<a name="ln293">    for(j = 0; j &lt;= n; j++)</a>
<a name="ln294">    {</a>
<a name="ln295">      if(f[j] &gt; f[vh] &amp;&amp; f[j] &lt; f[vg])</a>
<a name="ln296">      {</a>
<a name="ln297">        vh = j;</a>
<a name="ln298">      }</a>
<a name="ln299">    }</a>
<a name="ln300"> </a>
<a name="ln301">    /* calculate the centroid */</a>
<a name="ln302">    for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln303">    {</a>
<a name="ln304">      cent = 0.0;</a>
<a name="ln305">      for(m = 0; m &lt;= n; m++)</a>
<a name="ln306">      {</a>
<a name="ln307">        if(m != vg)</a>
<a name="ln308">        {</a>
<a name="ln309">          cent += v[m][j];</a>
<a name="ln310">        }</a>
<a name="ln311">      }</a>
<a name="ln312">      vm[j] = cent / n;</a>
<a name="ln313">    }</a>
<a name="ln314"> </a>
<a name="ln315">    /* reflect vg to new vertex vr */</a>
<a name="ln316">    for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln317">    {</a>
<a name="ln318">      /*vr[j] = (1+ALPHA)*vm[j] - ALPHA*v[vg][j]; */</a>
<a name="ln319">      vr[j] = vm[j] + ALPHA * (vm[j] - v[vg][j]);</a>
<a name="ln320">    }</a>
<a name="ln321">    if(constrain != NULL)</a>
<a name="ln322">    {</a>
<a name="ln323">      constrain(vr, n);</a>
<a name="ln324">    }</a>
<a name="ln325">    fr = objfunc(vr, rest);</a>
<a name="ln326">    k++;</a>
<a name="ln327"> </a>
<a name="ln328">    if(fr &lt; f[vh] &amp;&amp; fr &gt;= f[vs])</a>
<a name="ln329">    {</a>
<a name="ln330">      for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln331">      {</a>
<a name="ln332">        v[vg][j] = vr[j];</a>
<a name="ln333">      }</a>
<a name="ln334">      f[vg] = fr;</a>
<a name="ln335">    }</a>
<a name="ln336"> </a>
<a name="ln337">    /* investigate a step further in this direction */</a>
<a name="ln338">    if(fr &lt; f[vs])</a>
<a name="ln339">    {</a>
<a name="ln340">      for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln341">      {</a>
<a name="ln342">        /*ve[j] = GAMMA*vr[j] + (1-GAMMA)*vm[j]; */</a>
<a name="ln343">        ve[j] = vm[j] + GAMMA * (vr[j] - vm[j]);</a>
<a name="ln344">      }</a>
<a name="ln345">      if(constrain != NULL)</a>
<a name="ln346">      {</a>
<a name="ln347">        constrain(ve, n);</a>
<a name="ln348">      }</a>
<a name="ln349">      fe = objfunc(ve, rest);</a>
<a name="ln350">      k++;</a>
<a name="ln351"> </a>
<a name="ln352">      /* by making fe &lt; fr as opposed to fe &lt; f[vs],</a>
<a name="ln353">         Rosenbrocks function takes 63 iterations as opposed</a>
<a name="ln354">         to 64 when using double variables. */</a>
<a name="ln355"> </a>
<a name="ln356">      if(fe &lt; fr)</a>
<a name="ln357">      {</a>
<a name="ln358">        for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln359">        {</a>
<a name="ln360">          v[vg][j] = ve[j];</a>
<a name="ln361">        }</a>
<a name="ln362">        f[vg] = fe;</a>
<a name="ln363">      }</a>
<a name="ln364">      else</a>
<a name="ln365">      {</a>
<a name="ln366">        for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln367">        {</a>
<a name="ln368">          v[vg][j] = vr[j];</a>
<a name="ln369">        }</a>
<a name="ln370">        f[vg] = fr;</a>
<a name="ln371">      }</a>
<a name="ln372">    }</a>
<a name="ln373"> </a>
<a name="ln374">    /* check to see if a contraction is necessary */</a>
<a name="ln375">    if(fr &gt;= f[vh])</a>
<a name="ln376">    {</a>
<a name="ln377">      if(fr &lt; f[vg] &amp;&amp; fr &gt;= f[vh])</a>
<a name="ln378">      {</a>
<a name="ln379">        /* perform outside contraction */</a>
<a name="ln380">        for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln381">        {</a>
<a name="ln382">          /*vc[j] = BETA*v[vg][j] + (1-BETA)*vm[j]; */</a>
<a name="ln383">          vc[j] = vm[j] + BETA * (vr[j] - vm[j]);</a>
<a name="ln384">        }</a>
<a name="ln385">        if(constrain != NULL)</a>
<a name="ln386">        {</a>
<a name="ln387">          constrain(vc, n);</a>
<a name="ln388">        }</a>
<a name="ln389">        fc = objfunc(vc, rest);</a>
<a name="ln390">        k++;</a>
<a name="ln391">      }</a>
<a name="ln392">      else</a>
<a name="ln393">      {</a>
<a name="ln394">        /* perform inside contraction */</a>
<a name="ln395">        for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln396">        {</a>
<a name="ln397">          /*vc[j] = BETA*v[vg][j] + (1-BETA)*vm[j]; */</a>
<a name="ln398">          vc[j] = vm[j] - BETA * (vm[j] - v[vg][j]);</a>
<a name="ln399">        }</a>
<a name="ln400">        if(constrain != NULL)</a>
<a name="ln401">        {</a>
<a name="ln402">          constrain(vc, n);</a>
<a name="ln403">        }</a>
<a name="ln404">        fc = objfunc(vc, rest);</a>
<a name="ln405">        k++;</a>
<a name="ln406">      }</a>
<a name="ln407"> </a>
<a name="ln408"> </a>
<a name="ln409">      if(fc &lt; f[vg])</a>
<a name="ln410">      {</a>
<a name="ln411">        for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln412">        {</a>
<a name="ln413">          v[vg][j] = vc[j];</a>
<a name="ln414">        }</a>
<a name="ln415">        f[vg] = fc;</a>
<a name="ln416">      }</a>
<a name="ln417">      /* at this point the contraction is not successful,</a>
<a name="ln418">         we must halve the distance from vs to all the</a>
<a name="ln419">         vertices of the simplex and then continue.</a>
<a name="ln420">         10/31/97 - modified to account for ALL vertices.</a>
<a name="ln421">       */</a>
<a name="ln422">      else</a>
<a name="ln423">      {</a>
<a name="ln424">        for(row = 0; row &lt;= n; row++)</a>
<a name="ln425">        {</a>
<a name="ln426">          if(row != vs)</a>
<a name="ln427">          {</a>
<a name="ln428">            for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln429">            {</a>
<a name="ln430">              v[row][j] = v[vs][j] + (v[row][j] - v[vs][j]) / 2.0;</a>
<a name="ln431">            }</a>
<a name="ln432">          }</a>
<a name="ln433">        }</a>
<a name="ln434">        if(constrain != NULL)</a>
<a name="ln435">        {</a>
<a name="ln436">          constrain(v[vg], n);</a>
<a name="ln437">        }</a>
<a name="ln438">        f[vg] = objfunc(v[vg], rest);</a>
<a name="ln439">        k++;</a>
<a name="ln440">        if(constrain != NULL)</a>
<a name="ln441">        {</a>
<a name="ln442">          constrain(v[vh], n);</a>
<a name="ln443">        }</a>
<a name="ln444">        f[vh] = objfunc(v[vh], rest);</a>
<a name="ln445">        k++;</a>
<a name="ln446">      }</a>
<a name="ln447">    }</a>
<a name="ln448"> </a>
<a name="ln449">#if 0</a>
<a name="ln450">    /* print out the value at each iteration */</a>
<a name="ln451">    printf (&quot;Iteration %d\n&quot;, itr);</a>
<a name="ln452">    for (j = 0; j &lt;= n; j++)</a>
<a name="ln453">    {</a>
<a name="ln454">      for (i = 0; i &lt; n; i++)</a>
<a name="ln455">      {</a>
<a name="ln456">        printf (&quot;%f %f\n&quot;, v[j][i], f[j]);</a>
<a name="ln457">      }</a>
<a name="ln458">    }</a>
<a name="ln459">#endif</a>
<a name="ln460"> </a>
<a name="ln461">    /* test for convergence */</a>
<a name="ln462">    fsum = 0.0;</a>
<a name="ln463">    for(j = 0; j &lt;= n; j++)</a>
<a name="ln464">    {</a>
<a name="ln465">      fsum += f[j];</a>
<a name="ln466">    }</a>
<a name="ln467">    favg = fsum / (n + 1);</a>
<a name="ln468">    s = 0.0;</a>
<a name="ln469">    for(j = 0; j &lt;= n; j++)</a>
<a name="ln470">    {</a>
<a name="ln471">      s += pow((f[j] - favg), 2.0) / (n);</a>
<a name="ln472">    }</a>
<a name="ln473">    s = sqrt(s);</a>
<a name="ln474">    if(s &lt; EPSILON) break;</a>
<a name="ln475">  }</a>
<a name="ln476">  /* end main loop of the minimization */</a>
<a name="ln477"> </a>
<a name="ln478">  /* find the index of the smallest value */</a>
<a name="ln479">  vs = 0;</a>
<a name="ln480">  for(j = 0; j &lt;= n; j++)</a>
<a name="ln481">  {</a>
<a name="ln482">    if(f[j] &lt; f[vs])</a>
<a name="ln483">    {</a>
<a name="ln484">      vs = j;</a>
<a name="ln485">    }</a>
<a name="ln486">  }</a>
<a name="ln487"> </a>
<a name="ln488">#if 0</a>
<a name="ln489">  printf (&quot;The minimum was found at\n&quot;);</a>
<a name="ln490">  for (j = 0; j &lt; n; j++)</a>
<a name="ln491">  {</a>
<a name="ln492">    printf (&quot;%e\n&quot;, v[vs][j]);</a>
<a name="ln493">    start[j] = v[vs][j];</a>
<a name="ln494">  }</a>
<a name="ln495">  double min = objfunc (v[vs], rest);</a>
<a name="ln496">  printf (&quot;Function value at minimum %f\n&quot;, min);</a>
<a name="ln497">  k++;</a>
<a name="ln498">  printf (&quot;%d Function Evaluations\n&quot;, k);</a>
<a name="ln499">  printf (&quot;%d Iterations through program\n&quot;, itr);</a>
<a name="ln500">#endif</a>
<a name="ln501"> </a>
<a name="ln502">  free(f);</a>
<a name="ln503">  free(vr);</a>
<a name="ln504">  free(ve);</a>
<a name="ln505">  free(vc);</a>
<a name="ln506">  free(vm);</a>
<a name="ln507">  for(i = 0; i &lt;= n; i++)</a>
<a name="ln508">  {</a>
<a name="ln509">    free(v[i]);</a>
<a name="ln510">  }</a>
<a name="ln511">  free(v);</a>
<a name="ln512">  return itr;</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515"> </a>
<a name="ln516">static int _nm_fit_output_to_input_roi(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln517">                                       const dt_iop_roi_t *iroi, dt_iop_roi_t *oroi, int delta)</a>
<a name="ln518">{</a>
<a name="ln519">  void *rest[4] = { (void *)self, (void *)piece, (void *)iroi, (void *)oroi };</a>
<a name="ln520">  double start[4] = { (float)oroi-&gt;x / piece-&gt;iwidth, (float)oroi-&gt;y / piece-&gt;iheight,</a>
<a name="ln521">                      (float)oroi-&gt;width / piece-&gt;iwidth, (float)oroi-&gt;height / piece-&gt;iheight };</a>
<a name="ln522">  double epsilon = (double)delta / MIN(piece-&gt;iwidth, piece-&gt;iheight);</a>
<a name="ln523">  int maxiter = 1000;</a>
<a name="ln524"> </a>
<a name="ln525">  int iter = _simplex(_nm_fitness, start, 4, epsilon, 1.0, maxiter, NULL, rest);</a>
<a name="ln526"> </a>
<a name="ln527">  // printf(&quot;_simplex: %d, delta: %d, epsilon: %f\n&quot;, iter, delta, epsilon);</a>
<a name="ln528"> </a>
<a name="ln529">  oroi-&gt;x = start[0] * piece-&gt;iwidth;</a>
<a name="ln530">  oroi-&gt;y = start[1] * piece-&gt;iheight;</a>
<a name="ln531">  oroi-&gt;width = start[2] * piece-&gt;iwidth;</a>
<a name="ln532">  oroi-&gt;height = start[3] * piece-&gt;iheight;</a>
<a name="ln533"> </a>
<a name="ln534">  return (iter &lt;= maxiter);</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">/* find a matching oroi_full by probing start value of oroi and get corresponding input roi into iroi_probe.</a>
<a name="ln540">   We search in two steps. first by a simplicistic iterative search which will succeed in most cases.</a>
<a name="ln541">   If this does not converge, we do a downhill simplex (nelder-mead) fitting */</a>
<a name="ln542">static int _fit_output_to_input_roi(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln543">                                    const dt_iop_roi_t *iroi, dt_iop_roi_t *oroi, int delta, int iter)</a>
<a name="ln544">{</a>
<a name="ln545">  dt_iop_roi_t iroi_probe = *iroi;</a>
<a name="ln546">  dt_iop_roi_t save_oroi = *oroi;</a>
<a name="ln547"> </a>
<a name="ln548">  // try to go the easy way. this works in many cases where output is</a>
<a name="ln549">  // just like input, only scaled down</a>
<a name="ln550">  self-&gt;modify_roi_in(self, piece, oroi, &amp;iroi_probe);</a>
<a name="ln551">  while((abs((int)iroi_probe.x - (int)iroi-&gt;x) &gt; delta || abs((int)iroi_probe.y - (int)iroi-&gt;y) &gt; delta</a>
<a name="ln552">         || abs((int)iroi_probe.width - (int)iroi-&gt;width) &gt; delta</a>
<a name="ln553">         || abs((int)iroi_probe.height - (int)iroi-&gt;height) &gt; delta) &amp;&amp; iter &gt; 0)</a>
<a name="ln554">  {</a>
<a name="ln555">    //_print_roi(&amp;iroi_probe, &quot;tile iroi_probe&quot;);</a>
<a name="ln556">    //_print_roi(oroi, &quot;tile oroi old&quot;);</a>
<a name="ln557"> </a>
<a name="ln558">    oroi-&gt;x += (iroi-&gt;x - iroi_probe.x) * oroi-&gt;scale / iroi-&gt;scale;</a>
<a name="ln559">    oroi-&gt;y += (iroi-&gt;y - iroi_probe.y) * oroi-&gt;scale / iroi-&gt;scale;</a>
<a name="ln560">    oroi-&gt;width += (iroi-&gt;width - iroi_probe.width) * oroi-&gt;scale / iroi-&gt;scale;</a>
<a name="ln561">    oroi-&gt;height += (iroi-&gt;height - iroi_probe.height) * oroi-&gt;scale / iroi-&gt;scale;</a>
<a name="ln562"> </a>
<a name="ln563">    //_print_roi(oroi, &quot;tile oroi new&quot;);</a>
<a name="ln564"> </a>
<a name="ln565">    self-&gt;modify_roi_in(self, piece, oroi, &amp;iroi_probe);</a>
<a name="ln566">    iter--;</a>
<a name="ln567">  }</a>
<a name="ln568"> </a>
<a name="ln569">  if(iter &gt; 0) return TRUE;</a>
<a name="ln570"> </a>
<a name="ln571">  *oroi = save_oroi;</a>
<a name="ln572"> </a>
<a name="ln573">  // simplicistic approach did not converge.</a>
<a name="ln574">  // try simplex downhill fitting now.</a>
<a name="ln575">  // it's crucial that we have a good starting point in oroi, else this</a>
<a name="ln576">  // will not converge as well.</a>
<a name="ln577">  int fit = _nm_fit_output_to_input_roi(self, piece, iroi, oroi, delta);</a>
<a name="ln578">  return fit;</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">/* simple tiling algorithm for roi_in == roi_out, i.e. for pixel to pixel modules/operations */</a>
<a name="ln583">static void _default_process_tiling_ptp(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln584">                                        const void *const ivoid, void *const ovoid,</a>
<a name="ln585">                                        const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln586">                                        const int in_bpp)</a>
<a name="ln587">{</a>
<a name="ln588">  void *input = NULL;</a>
<a name="ln589">  void *output = NULL;</a>
<a name="ln590">  dt_iop_buffer_dsc_t dsc;</a>
<a name="ln591">  self-&gt;output_format(self, piece-&gt;pipe, piece, &amp;dsc);</a>
<a name="ln592">  const int out_bpp = dt_iop_buffer_dsc_to_bpp(&amp;dsc);</a>
<a name="ln593"> </a>
<a name="ln594">  const int ipitch = roi_in-&gt;width * in_bpp;</a>
<a name="ln595">  const int opitch = roi_out-&gt;width * out_bpp;</a>
<a name="ln596">  const int max_bpp = _max(in_bpp, out_bpp);</a>
<a name="ln597"> </a>
<a name="ln598">  /* get tiling requirements of module */</a>
<a name="ln599">  dt_develop_tiling_t tiling = { 0 };</a>
<a name="ln600">  self-&gt;tiling_callback(self, piece, roi_in, roi_out, &amp;tiling);</a>
<a name="ln601"> </a>
<a name="ln602">  /* tiling really does not make sense in these cases. standard process() is not better or worse than we are</a>
<a name="ln603">   */</a>
<a name="ln604">  if(tiling.factor &lt; 2.2f &amp;&amp; tiling.overhead &lt; 0.2f * roi_in-&gt;width * roi_in-&gt;height * max_bpp)</a>
<a name="ln605">  {</a>
<a name="ln606">    dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_ptp] no need to use tiling for module '%s' as no real &quot;</a>
<a name="ln607">                           &quot;memory saving to be expected\n&quot;,</a>
<a name="ln608">             self-&gt;op);</a>
<a name="ln609">    goto fallback;</a>
<a name="ln610">  }</a>
<a name="ln611"> </a>
<a name="ln612">  /* calculate optimal size of tiles */</a>
<a name="ln613">  float available = dt_conf_get_float(&quot;host_memory_limit&quot;) * 1024.0f * 1024.0f;</a>
<a name="ln614">  assert(available &gt;= 500.0f * 1024.0f * 1024.0f);</a>
<a name="ln615">  /* correct for size of ivoid and ovoid which are needed on top of tiling */</a>
<a name="ln616">  available = fmax(available - ((float)roi_out-&gt;width * roi_out-&gt;height * out_bpp)</a>
<a name="ln617">                   - ((float)roi_in-&gt;width * roi_in-&gt;height * in_bpp) - tiling.overhead,</a>
<a name="ln618">                   0);</a>
<a name="ln619"> </a>
<a name="ln620">  /* we ignore the above value if singlebuffer_limit (is defined and) is higher than available/tiling.factor.</a>
<a name="ln621">     this will mainly allow tiling for modules with high and &quot;unpredictable&quot; memory demand which is</a>
<a name="ln622">     reflected in high values of tiling.factor (take bilateral noise reduction as an example). */</a>
<a name="ln623">  float singlebuffer = dt_conf_get_float(&quot;singlebuffer_limit&quot;) * 1024.0f * 1024.0f;</a>
<a name="ln624">  singlebuffer = fmax(singlebuffer, 2.0f * 1024.0f * 1024.0f);</a>
<a name="ln625">  float factor = fmax(tiling.factor, 1.0f);</a>
<a name="ln626">  float maxbuf = fmax(tiling.maxbuf, 1.0f);</a>
<a name="ln627">  singlebuffer = fmax(available / factor, singlebuffer);</a>
<a name="ln628"> </a>
<a name="ln629">  int width = roi_in-&gt;width;</a>
<a name="ln630">  int height = roi_in-&gt;height;</a>
<a name="ln631"> </a>
<a name="ln632">  /* shrink tile size in case it would exceed singlebuffer size */</a>
<a name="ln633">  if((float)width * height * max_bpp * maxbuf &gt; singlebuffer)</a>
<a name="ln634">  {</a>
<a name="ln635">    const float scale = singlebuffer / ((float)width * height * max_bpp * maxbuf);</a>
<a name="ln636"> </a>
<a name="ln637">    /* TODO: can we make this more efficient to minimize total overlap between tiles? */</a>
<a name="ln638">    if(width &lt; height &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln639">    {</a>
<a name="ln640">      height = floorf(height * scale);</a>
<a name="ln641">    }</a>
<a name="ln642">    else if(height &lt;= width &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln643">    {</a>
<a name="ln644">      width = floorf(width * scale);</a>
<a name="ln645">    }</a>
<a name="ln646">    else</a>
<a name="ln647">    {</a>
<a name="ln648">      width = floorf(width * sqrt(scale));</a>
<a name="ln649">      height = floorf(height * sqrt(scale));</a>
<a name="ln650">    }</a>
<a name="ln651">  }</a>
<a name="ln652"> </a>
<a name="ln653">  /* make sure we have a reasonably effective tile dimension. if not try square tiles */</a>
<a name="ln654">  if(3 * tiling.overlap &gt; width || 3 * tiling.overlap &gt; height)</a>
<a name="ln655">  {</a>
<a name="ln656">    width = height = floorf(sqrtf((float)width * height));</a>
<a name="ln657">  }</a>
<a name="ln658"> </a>
<a name="ln659">  /* Alignment rules: we need to make sure that alignment requirements of module are fulfilled.</a>
<a name="ln660">     Modules will report alignment requirements via xalign and yalign within tiling_callback().</a>
<a name="ln661">     Typical use case is demosaic where Bayer pattern requires alignment to a multiple of 2 in x and y</a>
<a name="ln662">     direction.</a>
<a name="ln663">     We guarantee alignment by selecting image width/height and overlap accordingly. For a tile width/height</a>
<a name="ln664">     that is identical to image width/height no special alignment is needed. */</a>
<a name="ln665"> </a>
<a name="ln666">  const unsigned int xyalign = _lcm(tiling.xalign, tiling.yalign);</a>
<a name="ln667"> </a>
<a name="ln668">  assert(xyalign != 0);</a>
<a name="ln669"> </a>
<a name="ln670">  /* properly align tile width and height by making them smaller if needed */</a>
<a name="ln671">  if(width &lt; roi_in-&gt;width) width = (width / xyalign) * xyalign;</a>
<a name="ln672">  if(height &lt; roi_in-&gt;height) height = (height / xyalign) * xyalign;</a>
<a name="ln673"> </a>
<a name="ln674">  /* also make sure that overlap follows alignment rules by making it wider when needed */</a>
<a name="ln675">  const int overlap = tiling.overlap % xyalign != 0 ? (tiling.overlap / xyalign + 1) * xyalign</a>
<a name="ln676">                                                    : tiling.overlap;</a>
<a name="ln677"> </a>
<a name="ln678">  /* calculate effective tile size */</a>
<a name="ln679">  const int tile_wd = width - 2 * overlap &gt; 0 ? width - 2 * overlap : 1;</a>
<a name="ln680">  const int tile_ht = height - 2 * overlap &gt; 0 ? height - 2 * overlap : 1;</a>
<a name="ln681"> </a>
<a name="ln682">  /* calculate number of tiles */</a>
<a name="ln683">  const int tiles_x = width &lt; roi_in-&gt;width ? ceilf(roi_in-&gt;width / (float)tile_wd) : 1;</a>
<a name="ln684">  const int tiles_y = height &lt; roi_in-&gt;height ? ceilf(roi_in-&gt;height / (float)tile_ht) : 1;</a>
<a name="ln685"> </a>
<a name="ln686">  /* sanity check: don't run wild on too many tiles */</a>
<a name="ln687">  if(tiles_x * tiles_y &gt; dt_conf_get_int(&quot;maximum_number_tiles&quot;))</a>
<a name="ln688">  {</a>
<a name="ln689">    dt_print(DT_DEBUG_DEV,</a>
<a name="ln690">             &quot;[default_process_tiling_ptp] gave up tiling for module '%s'. too many tiles: %d x %d\n&quot;,</a>
<a name="ln691">             self-&gt;op, tiles_x, tiles_y);</a>
<a name="ln692">    goto error;</a>
<a name="ln693">  }</a>
<a name="ln694"> </a>
<a name="ln695"> </a>
<a name="ln696">  dt_print(DT_DEBUG_DEV,</a>
<a name="ln697">           &quot;[default_process_tiling_ptp] use tiling on module '%s' for image with full size %d x %d\n&quot;,</a>
<a name="ln698">           self-&gt;op, roi_in-&gt;width, roi_in-&gt;height);</a>
<a name="ln699">  dt_print(DT_DEBUG_DEV,</a>
<a name="ln700">           &quot;[default_process_tiling_ptp] (%d x %d) tiles with max dimensions %d x %d and overlap %d\n&quot;,</a>
<a name="ln701">           tiles_x, tiles_y, width, height, overlap);</a>
<a name="ln702"> </a>
<a name="ln703">  /* reserve input and output buffers for tiles */</a>
<a name="ln704">  input = dt_alloc_align(64, (size_t)width * height * in_bpp);</a>
<a name="ln705">  if(input == NULL)</a>
<a name="ln706">  {</a>
<a name="ln707">    dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_ptp] could not alloc input buffer for module '%s'\n&quot;,</a>
<a name="ln708">             self-&gt;op);</a>
<a name="ln709">    goto error;</a>
<a name="ln710">  }</a>
<a name="ln711">  output = dt_alloc_align(64, (size_t)width * height * out_bpp);</a>
<a name="ln712">  if(output == NULL)</a>
<a name="ln713">  {</a>
<a name="ln714">    dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_ptp] could not alloc output buffer for module '%s'\n&quot;,</a>
<a name="ln715">             self-&gt;op);</a>
<a name="ln716">    goto error;</a>
<a name="ln717">  }</a>
<a name="ln718"> </a>
<a name="ln719">  /* store processed_maximum to be re-used and aggregated */</a>
<a name="ln720">  float processed_maximum_saved[4];</a>
<a name="ln721">  float processed_maximum_new[4] = { 1.0f };</a>
<a name="ln722">  for(int k = 0; k &lt; 4; k++) processed_maximum_saved[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln723"> </a>
<a name="ln724"> </a>
<a name="ln725">  /* iterate over tiles */</a>
<a name="ln726">  for(size_t tx = 0; tx &lt; tiles_x; tx++)</a>
<a name="ln727">  {</a>
<a name="ln728">    const size_t wd = tx * tile_wd + width &gt; roi_in-&gt;width ? roi_in-&gt;width - tx * tile_wd : width;</a>
<a name="ln729">    for(size_t ty = 0; ty &lt; tiles_y; ty++)</a>
<a name="ln730">    {</a>
<a name="ln731">      piece-&gt;pipe-&gt;tiling = 1;</a>
<a name="ln732"> </a>
<a name="ln733">      const size_t ht = ty * tile_ht + height &gt; roi_in-&gt;height ? roi_in-&gt;height - ty * tile_ht : height;</a>
<a name="ln734"> </a>
<a name="ln735">      /* no need to process end-tiles that are smaller than the total overlap area */</a>
<a name="ln736">      if((wd &lt;= 2 * overlap &amp;&amp; tx &gt; 0) || (ht &lt;= 2 * overlap &amp;&amp; ty &gt; 0)) continue;</a>
<a name="ln737"> </a>
<a name="ln738">      /* origin and region of effective part of tile, which we want to store later */</a>
<a name="ln739">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln740">      size_t region[] = { wd, ht, 1 };</a>
<a name="ln741"> </a>
<a name="ln742">      /* roi_in and roi_out for process_cl on subbuffer */</a>
<a name="ln743">      dt_iop_roi_t iroi = { roi_in-&gt;x + tx * tile_wd, roi_in-&gt;y + ty * tile_ht, wd, ht, roi_in-&gt;scale };</a>
<a name="ln744">      dt_iop_roi_t oroi = { roi_out-&gt;x + tx * tile_wd, roi_out-&gt;y + ty * tile_ht, wd, ht, roi_out-&gt;scale };</a>
<a name="ln745"> </a>
<a name="ln746">      /* offsets of tile into ivoid and ovoid */</a>
<a name="ln747">      size_t ioffs = (ty * tile_ht) * ipitch + (tx * tile_wd) * in_bpp;</a>
<a name="ln748">      size_t ooffs = (ty * tile_ht) * opitch + (tx * tile_wd) * out_bpp;</a>
<a name="ln749"> </a>
<a name="ln750"> </a>
<a name="ln751">      dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_ptp] tile (%zu, %zu) with %zu x %zu at origin [%zu, %zu]\n&quot;,</a>
<a name="ln752">               tx, ty, wd, ht, tx * tile_wd, ty * tile_ht);</a>
<a name="ln753"> </a>
<a name="ln754">/* prepare input tile buffer */</a>
<a name="ln755">#ifdef _OPENMP</a>
<a name="ln756">#pragma omp parallel for default(none) \</a>
<a name="ln757">      dt_omp_firstprivate(ht, in_bpp, ipitch, ivoid, wd) \</a>
<a name="ln758">      shared(input, width, ioffs) \</a>
<a name="ln759">      schedule(static)</a>
<a name="ln760">#endif</a>
<a name="ln761">      for(size_t j = 0; j &lt; ht; j++)</a>
<a name="ln762">        memcpy((char *)input + j * wd * in_bpp, (char *)ivoid + ioffs + j * ipitch, (size_t)wd * in_bpp);</a>
<a name="ln763"> </a>
<a name="ln764">      /* take original processed_maximum as starting point */</a>
<a name="ln765">      for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_saved[k];</a>
<a name="ln766"> </a>
<a name="ln767">      /* call process() of module */</a>
<a name="ln768">      self-&gt;process(self, piece, input, output, &amp;iroi, &amp;oroi);</a>
<a name="ln769"> </a>
<a name="ln770">      /* aggregate resulting processed_maximum */</a>
<a name="ln771">      /* TODO: check if there really can be differences between tiles and take</a>
<a name="ln772">               appropriate action (calculate minimum, maximum, average, ...?) */</a>
<a name="ln773">      for(int k = 0; k &lt; 4; k++)</a>
<a name="ln774">      {</a>
<a name="ln775">        if(tx + ty &gt; 0 &amp;&amp; fabs(processed_maximum_new[k] - piece-&gt;pipe-&gt;dsc.processed_maximum[k]) &gt; 1.0e-6f)</a>
<a name="ln776">          dt_print(</a>
<a name="ln777">              DT_DEBUG_DEV,</a>
<a name="ln778">              &quot;[default_process_tiling_ptp] processed_maximum[%d] differs between tiles in module '%s'\n&quot;, k,</a>
<a name="ln779">              self-&gt;op);</a>
<a name="ln780">        processed_maximum_new[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln781">      }</a>
<a name="ln782"> </a>
<a name="ln783">      /* correct origin and region of tile for overlap.</a>
<a name="ln784">         make sure that we only copy back the &quot;good&quot; part. */</a>
<a name="ln785">      if(tx &gt; 0)</a>
<a name="ln786">      {</a>
<a name="ln787">        origin[0] += overlap;</a>
<a name="ln788">        region[0] -= overlap;</a>
<a name="ln789">        ooffs += overlap * out_bpp;</a>
<a name="ln790">      }</a>
<a name="ln791">      if(ty &gt; 0)</a>
<a name="ln792">      {</a>
<a name="ln793">        origin[1] += overlap;</a>
<a name="ln794">        region[1] -= overlap;</a>
<a name="ln795">        ooffs += overlap * opitch;</a>
<a name="ln796">      }</a>
<a name="ln797"> </a>
<a name="ln798">/* copy &quot;good&quot; part of tile to output buffer */</a>
<a name="ln799">#ifdef _OPENMP</a>
<a name="ln800">#pragma omp parallel for default(none) \</a>
<a name="ln801">      dt_omp_firstprivate(opitch, out_bpp, ovoid, wd) \</a>
<a name="ln802">      shared(ooffs, output, width, origin, region) \</a>
<a name="ln803">      schedule(static)</a>
<a name="ln804">#endif</a>
<a name="ln805">      for(size_t j = 0; j &lt; region[1]; j++)</a>
<a name="ln806">        memcpy((char *)ovoid + ooffs + j * opitch,</a>
<a name="ln807">               (char *)output + ((j + origin[1]) * wd + origin[0]) * out_bpp, (size_t)region[0] * out_bpp);</a>
<a name="ln808">    }</a>
<a name="ln809">  }</a>
<a name="ln810"> </a>
<a name="ln811">  /* copy back final processed_maximum */</a>
<a name="ln812">  for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_new[k];</a>
<a name="ln813"> </a>
<a name="ln814">  if(input != NULL) dt_free_align(input);</a>
<a name="ln815">  if(output != NULL) dt_free_align(output);</a>
<a name="ln816">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln817">  return;</a>
<a name="ln818"> </a>
<a name="ln819">error:</a>
<a name="ln820">  dt_control_log(_(&quot;tiling failed for module '%s'. output might be garbled.&quot;), self-&gt;op);</a>
<a name="ln821">// fall through</a>
<a name="ln822"> </a>
<a name="ln823">fallback:</a>
<a name="ln824">  if(input != NULL) dt_free_align(input);</a>
<a name="ln825">  if(output != NULL) dt_free_align(output);</a>
<a name="ln826">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln827">  dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_ptp] fall back to standard processing for module '%s'\n&quot;,</a>
<a name="ln828">           self-&gt;op);</a>
<a name="ln829">  self-&gt;process(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln830">  return;</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833"> </a>
<a name="ln834"> </a>
<a name="ln835">/* more elaborate tiling algorithm for roi_in != roi_out: slower than the ptp variant,</a>
<a name="ln836">   more tiles and larger overlap */</a>
<a name="ln837">static void _default_process_tiling_roi(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln838">                                        const void *const ivoid, void *const ovoid,</a>
<a name="ln839">                                        const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln840">                                        const int in_bpp)</a>
<a name="ln841">{</a>
<a name="ln842">  void *input = NULL;</a>
<a name="ln843">  void *output = NULL;</a>
<a name="ln844"> </a>
<a name="ln845">  //_print_roi(roi_in, &quot;module roi_in&quot;);</a>
<a name="ln846">  //_print_roi(roi_out, &quot;module roi_out&quot;);</a>
<a name="ln847"> </a>
<a name="ln848">  dt_iop_buffer_dsc_t dsc;</a>
<a name="ln849">  self-&gt;output_format(self, piece-&gt;pipe, piece, &amp;dsc);</a>
<a name="ln850">  const int out_bpp = dt_iop_buffer_dsc_to_bpp(&amp;dsc);</a>
<a name="ln851"> </a>
<a name="ln852">  const int ipitch = roi_in-&gt;width * in_bpp;</a>
<a name="ln853">  const int opitch = roi_out-&gt;width * out_bpp;</a>
<a name="ln854">  const int max_bpp = _max(in_bpp, out_bpp);</a>
<a name="ln855"> </a>
<a name="ln856">  float fullscale = fmax(roi_in-&gt;scale / roi_out-&gt;scale, sqrt(((float)roi_in-&gt;width * roi_in-&gt;height)</a>
<a name="ln857">                                                              / ((float)roi_out-&gt;width * roi_out-&gt;height)));</a>
<a name="ln858"> </a>
<a name="ln859">  /* inaccuracy for roi_in elements in roi_out -&gt; roi_in calculations */</a>
<a name="ln860">  const int delta = ceilf(fullscale);</a>
<a name="ln861"> </a>
<a name="ln862">  /* estimate for additional (space) requirement in buffer dimensions due to inaccuracies */</a>
<a name="ln863">  const int inacc = RESERVE * delta;</a>
<a name="ln864"> </a>
<a name="ln865">  /* get tiling requirements of module */</a>
<a name="ln866">  dt_develop_tiling_t tiling = { 0 };</a>
<a name="ln867">  self-&gt;tiling_callback(self, piece, roi_in, roi_out, &amp;tiling);</a>
<a name="ln868"> </a>
<a name="ln869">  /* tiling really does not make sense in these cases. standard process() is not better or worse than we are</a>
<a name="ln870">   */</a>
<a name="ln871">  if(tiling.factor &lt; 2.2f &amp;&amp; tiling.overhead &lt; 0.2f * roi_in-&gt;width * roi_in-&gt;height * max_bpp)</a>
<a name="ln872">  {</a>
<a name="ln873">    dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] no need to use tiling for module '%s' as no real &quot;</a>
<a name="ln874">                           &quot;memory saving to be expected\n&quot;,</a>
<a name="ln875">             self-&gt;op);</a>
<a name="ln876">    goto fallback;</a>
<a name="ln877">  }</a>
<a name="ln878"> </a>
<a name="ln879">  /* calculate optimal size of tiles */</a>
<a name="ln880">  float available = dt_conf_get_float(&quot;host_memory_limit&quot;) * 1024.0f * 1024.0f;</a>
<a name="ln881">  assert(available &gt;= 500.0f * 1024.0f * 1024.0f);</a>
<a name="ln882">  /* correct for size of ivoid and ovoid which are needed on top of tiling */</a>
<a name="ln883">  available = fmax(available - ((float)roi_out-&gt;width * roi_out-&gt;height * out_bpp)</a>
<a name="ln884">                   - ((float)roi_in-&gt;width * roi_in-&gt;height * in_bpp) - tiling.overhead,</a>
<a name="ln885">                   0);</a>
<a name="ln886"> </a>
<a name="ln887">  /* we ignore the above value if singlebuffer_limit (is defined and) is higher than available/tiling.factor.</a>
<a name="ln888">     this will mainly allow tiling for modules with high and &quot;unpredictable&quot; memory demand which is</a>
<a name="ln889">     reflected in high values of tiling.factor (take bilateral noise reduction as an example). */</a>
<a name="ln890">  float singlebuffer = dt_conf_get_float(&quot;singlebuffer_limit&quot;) * 1024.0f * 1024.0f;</a>
<a name="ln891">  singlebuffer = fmax(singlebuffer, 2.0f * 1024.0f * 1024.0f);</a>
<a name="ln892">  float factor = fmax(tiling.factor, 1.0f);</a>
<a name="ln893">  float maxbuf = fmax(tiling.maxbuf, 1.0f);</a>
<a name="ln894">  singlebuffer = fmax(available / factor, singlebuffer);</a>
<a name="ln895"> </a>
<a name="ln896">  int width = _max(roi_in-&gt;width, roi_out-&gt;width);</a>
<a name="ln897">  int height = _max(roi_in-&gt;height, roi_out-&gt;height);</a>
<a name="ln898"> </a>
<a name="ln899">  /* shrink tile size in case it would exceed singlebuffer size */</a>
<a name="ln900">  if((float)width * height * max_bpp * maxbuf &gt; singlebuffer)</a>
<a name="ln901">  {</a>
<a name="ln902">    const float scale = singlebuffer / ((float)width * height * max_bpp * maxbuf);</a>
<a name="ln903"> </a>
<a name="ln904">    /* TODO: can we make this more efficient to minimize total overlap between tiles? */</a>
<a name="ln905">    if(width &lt; height &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln906">    {</a>
<a name="ln907">      height = floorf(height * scale);</a>
<a name="ln908">    }</a>
<a name="ln909">    else if(height &lt;= width &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln910">    {</a>
<a name="ln911">      width = floorf(width * scale);</a>
<a name="ln912">    }</a>
<a name="ln913">    else</a>
<a name="ln914">    {</a>
<a name="ln915">      width = floorf(width * sqrt(scale));</a>
<a name="ln916">      height = floorf(height * sqrt(scale));</a>
<a name="ln917">    }</a>
<a name="ln918">  }</a>
<a name="ln919"> </a>
<a name="ln920">  /* make sure we have a reasonably effective tile dimension. if not try square tiles */</a>
<a name="ln921">  if(3 * tiling.overlap &gt; width || 3 * tiling.overlap &gt; height)</a>
<a name="ln922">  {</a>
<a name="ln923">    width = height = floorf(sqrtf((float)width * height));</a>
<a name="ln924">  }</a>
<a name="ln925"> </a>
<a name="ln926">  /* Alignment rules: we need to make sure that alignment requirements of module are fulfilled.</a>
<a name="ln927">     Modules will report alignment requirements via xalign and yalign within tiling_callback().</a>
<a name="ln928">     Typical use case is demosaic where Bayer pattern requires alignment to a multiple of 2 in x and y</a>
<a name="ln929">     direction. */</a>
<a name="ln930"> </a>
<a name="ln931">  /* for simplicity reasons we use only one alignment that fits to x and y requirements at the same time */</a>
<a name="ln932">  unsigned int xyalign = _lcm(tiling.xalign, tiling.yalign);</a>
<a name="ln933"> </a>
<a name="ln934">  assert(xyalign != 0);</a>
<a name="ln935"> </a>
<a name="ln936">  /* make sure that overlap follows alignment rules by making it wider when needed.</a>
<a name="ln937">     overlap_in needs to be aligned, overlap_out is only here to calculate output buffer size */</a>
<a name="ln938">  const int overlap_in = _align_up(tiling.overlap, xyalign);</a>
<a name="ln939">  const int overlap_out = ceilf((float)overlap_in / fullscale);</a>
<a name="ln940"> </a>
<a name="ln941">  int tiles_x = 1, tiles_y = 1;</a>
<a name="ln942"> </a>
<a name="ln943">  /* calculate number of tiles taking the larger buffer (input or output) as a guiding one.</a>
<a name="ln944">     normally it is roi_in &gt; roi_out; but let's be prepared */</a>
<a name="ln945">  if(roi_in-&gt;width &gt; roi_out-&gt;width)</a>
<a name="ln946">    tiles_x = width &lt; roi_in-&gt;width</a>
<a name="ln947">                  ? ceilf((float)roi_in-&gt;width / (float)_max(width - 2 * overlap_in - inacc, 1))</a>
<a name="ln948">                  : 1;</a>
<a name="ln949">  else</a>
<a name="ln950">    tiles_x = width &lt; roi_out-&gt;width ? ceilf((float)roi_out-&gt;width / (float)_max(width - 2 * overlap_out, 1))</a>
<a name="ln951">                                     : 1;</a>
<a name="ln952"> </a>
<a name="ln953">  if(roi_in-&gt;height &gt; roi_out-&gt;height)</a>
<a name="ln954">    tiles_y = height &lt; roi_in-&gt;height</a>
<a name="ln955">                  ? ceilf((float)roi_in-&gt;height / (float)_max(height - 2 * overlap_in - inacc, 1))</a>
<a name="ln956">                  : 1;</a>
<a name="ln957">  else</a>
<a name="ln958">    tiles_y = height &lt; roi_out-&gt;height</a>
<a name="ln959">                  ? ceilf((float)roi_out-&gt;height / (float)_max(height - 2 * overlap_out, 1))</a>
<a name="ln960">                  : 1;</a>
<a name="ln961"> </a>
<a name="ln962">  /* sanity check: don't run wild on too many tiles */</a>
<a name="ln963">  if(tiles_x * tiles_y &gt; dt_conf_get_int(&quot;maximum_number_tiles&quot;))</a>
<a name="ln964">  {</a>
<a name="ln965">    dt_print(DT_DEBUG_DEV,</a>
<a name="ln966">             &quot;[default_process_tiling_roi] gave up tiling for module '%s'. too many tiles: %d x %d\n&quot;,</a>
<a name="ln967">             self-&gt;op, tiles_x, tiles_y);</a>
<a name="ln968">    goto error;</a>
<a name="ln969">  }</a>
<a name="ln970"> </a>
<a name="ln971"> </a>
<a name="ln972">  /* calculate tile width and height excl. overlap (i.e. the good part) for output.</a>
<a name="ln973">     values are important for all following processing steps. */</a>
<a name="ln974">  const int tile_wd = _align_up(</a>
<a name="ln975">      roi_out-&gt;width % tiles_x == 0 ? roi_out-&gt;width / tiles_x : roi_out-&gt;width / tiles_x + 1, xyalign);</a>
<a name="ln976">  const int tile_ht = _align_up(</a>
<a name="ln977">      roi_out-&gt;height % tiles_y == 0 ? roi_out-&gt;height / tiles_y : roi_out-&gt;height / tiles_y + 1, xyalign);</a>
<a name="ln978"> </a>
<a name="ln979">  dt_print(DT_DEBUG_DEV,</a>
<a name="ln980">           &quot;[default_process_tiling_roi] use tiling on module '%s' for image with full input size %d x %d\n&quot;,</a>
<a name="ln981">           self-&gt;op, roi_in-&gt;width, roi_in-&gt;height);</a>
<a name="ln982">  dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] (%d x %d) tiles with max dimensions %d x %d\n&quot;,</a>
<a name="ln983">           tiles_x, tiles_y, width, height);</a>
<a name="ln984"> </a>
<a name="ln985"> </a>
<a name="ln986">  /* store processed_maximum to be re-used and aggregated */</a>
<a name="ln987">  float processed_maximum_saved[4];</a>
<a name="ln988">  float processed_maximum_new[4] = { 1.0f };</a>
<a name="ln989">  for(int k = 0; k &lt; 4; k++) processed_maximum_saved[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln990"> </a>
<a name="ln991">  /* iterate over tiles */</a>
<a name="ln992">  for(size_t tx = 0; tx &lt; tiles_x; tx++)</a>
<a name="ln993">    for(size_t ty = 0; ty &lt; tiles_y; ty++)</a>
<a name="ln994">    {</a>
<a name="ln995">      piece-&gt;pipe-&gt;tiling = 1;</a>
<a name="ln996"> </a>
<a name="ln997">      /* the output dimensions of the good part of this specific tile */</a>
<a name="ln998">      size_t wd = (tx + 1) * tile_wd &gt; roi_out-&gt;width ? roi_out-&gt;width - tx * tile_wd : tile_wd;</a>
<a name="ln999">      size_t ht = (ty + 1) * tile_ht &gt; roi_out-&gt;height ? roi_out-&gt;height - ty * tile_ht : tile_ht;</a>
<a name="ln1000"> </a>
<a name="ln1001">      /* roi_in and roi_out of good part: oroi_good easy to calculate based on number and dimension of tile.</a>
<a name="ln1002">         iroi_good is calculated by modify_roi_in() of respective module */</a>
<a name="ln1003">      dt_iop_roi_t iroi_good = { roi_in-&gt;x + tx * tile_wd, roi_in-&gt;y + ty * tile_ht, wd, ht, roi_in-&gt;scale };</a>
<a name="ln1004">      dt_iop_roi_t oroi_good</a>
<a name="ln1005">          = { roi_out-&gt;x + tx * tile_wd, roi_out-&gt;y + ty * tile_ht, wd, ht, roi_out-&gt;scale };</a>
<a name="ln1006"> </a>
<a name="ln1007">      self-&gt;modify_roi_in(self, piece, &amp;oroi_good, &amp;iroi_good);</a>
<a name="ln1008"> </a>
<a name="ln1009">      /* clamp iroi_good to not exceed roi_in */</a>
<a name="ln1010">      iroi_good.x = _max(iroi_good.x, roi_in-&gt;x);</a>
<a name="ln1011">      iroi_good.y = _max(iroi_good.y, roi_in-&gt;y);</a>
<a name="ln1012">      iroi_good.width = _min(iroi_good.width, roi_in-&gt;width + roi_in-&gt;x - iroi_good.x);</a>
<a name="ln1013">      iroi_good.height = _min(iroi_good.height, roi_in-&gt;height + roi_in-&gt;y - iroi_good.y);</a>
<a name="ln1014"> </a>
<a name="ln1015">      //_print_roi(&amp;iroi_good, &quot;tile iroi_good&quot;);</a>
<a name="ln1016">      //_print_roi(&amp;oroi_good, &quot;tile oroi_good&quot;);</a>
<a name="ln1017"> </a>
<a name="ln1018">      /* now we need to calculate full region of this tile: increase input roi to take care of overlap</a>
<a name="ln1019">         requirements</a>
<a name="ln1020">         and alignment and add additional delta to correct for possible rounding errors in modify_roi_in()</a>
<a name="ln1021">         -&gt; generates first estimate of iroi_full */</a>
<a name="ln1022">      const int x_in = iroi_good.x;</a>
<a name="ln1023">      const int y_in = iroi_good.y;</a>
<a name="ln1024">      const int width_in = iroi_good.width;</a>
<a name="ln1025">      const int height_in = iroi_good.height;</a>
<a name="ln1026">      const int new_x_in = _max(_align_down(x_in - overlap_in - delta, xyalign), roi_in-&gt;x);</a>
<a name="ln1027">      const int new_y_in = _max(_align_down(y_in - overlap_in - delta, xyalign), roi_in-&gt;y);</a>
<a name="ln1028">      const int new_width_in = _min(_align_up(width_in + overlap_in + delta + (x_in - new_x_in), xyalign),</a>
<a name="ln1029">                                    roi_in-&gt;width + roi_in-&gt;x - new_x_in);</a>
<a name="ln1030">      const int new_height_in = _min(_align_up(height_in + overlap_in + delta + (y_in - new_y_in), xyalign),</a>
<a name="ln1031">                                     roi_in-&gt;height + roi_in-&gt;y - new_y_in);</a>
<a name="ln1032"> </a>
<a name="ln1033">      /* iroi_full based on calculated numbers and dimensions. oroi_full just set as a starting point for the</a>
<a name="ln1034">       * following iterative search */</a>
<a name="ln1035">      dt_iop_roi_t iroi_full = { new_x_in, new_y_in, new_width_in, new_height_in, iroi_good.scale };</a>
<a name="ln1036">      dt_iop_roi_t oroi_full = oroi_good; // a good starting point for optimization</a>
<a name="ln1037"> </a>
<a name="ln1038">      //_print_roi(&amp;iroi_full, &quot;tile iroi_full before optimization&quot;);</a>
<a name="ln1039">      //_print_roi(&amp;oroi_full, &quot;tile oroi_full before optimization&quot;);</a>
<a name="ln1040"> </a>
<a name="ln1041">      /* try to find a matching oroi_full */</a>
<a name="ln1042">      if(!_fit_output_to_input_roi(self, piece, &amp;iroi_full, &amp;oroi_full, delta, 10))</a>
<a name="ln1043">      {</a>
<a name="ln1044">        dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] can not handle requested roi's. tiling for &quot;</a>
<a name="ln1045">                               &quot;module '%s' not possible.\n&quot;,</a>
<a name="ln1046">                 self-&gt;op);</a>
<a name="ln1047">        goto error;</a>
<a name="ln1048">      }</a>
<a name="ln1049"> </a>
<a name="ln1050">      //_print_roi(&amp;iroi_full, &quot;tile iroi_full after optimization&quot;);</a>
<a name="ln1051">      //_print_roi(&amp;oroi_full, &quot;tile oroi_full after optimization&quot;);</a>
<a name="ln1052"> </a>
<a name="ln1053">      /* make sure that oroi_full at least covers the range of oroi_good.</a>
<a name="ln1054">         this step is needed due to the possibility of rounding errors */</a>
<a name="ln1055">      oroi_full.x = _min(oroi_full.x, oroi_good.x);</a>
<a name="ln1056">      oroi_full.y = _min(oroi_full.y, oroi_good.y);</a>
<a name="ln1057">      oroi_full.width = _max(oroi_full.width, oroi_good.x + oroi_good.width - oroi_full.x);</a>
<a name="ln1058">      oroi_full.height = _max(oroi_full.height, oroi_good.y + oroi_good.height - oroi_full.y);</a>
<a name="ln1059"> </a>
<a name="ln1060">      /* clamp oroi_full to not exceed roi_out */</a>
<a name="ln1061">      oroi_full.x = _max(oroi_full.x, roi_out-&gt;x);</a>
<a name="ln1062">      oroi_full.y = _max(oroi_full.y, roi_out-&gt;y);</a>
<a name="ln1063">      oroi_full.width = _min(oroi_full.width, roi_out-&gt;width + roi_out-&gt;x - oroi_full.x);</a>
<a name="ln1064">      oroi_full.height = _min(oroi_full.height, roi_out-&gt;height + roi_out-&gt;y - oroi_full.y);</a>
<a name="ln1065"> </a>
<a name="ln1066">      /* calculate final iroi_full */</a>
<a name="ln1067">      self-&gt;modify_roi_in(self, piece, &amp;oroi_full, &amp;iroi_full);</a>
<a name="ln1068"> </a>
<a name="ln1069">      /* clamp iroi_full to not exceed roi_in */</a>
<a name="ln1070">      iroi_full.x = _max(iroi_full.x, roi_in-&gt;x);</a>
<a name="ln1071">      iroi_full.y = _max(iroi_full.y, roi_in-&gt;y);</a>
<a name="ln1072">      iroi_full.width = _min(iroi_full.width, roi_in-&gt;width + roi_in-&gt;x - iroi_full.x);</a>
<a name="ln1073">      iroi_full.height = _min(iroi_full.height, roi_in-&gt;height + roi_in-&gt;y - iroi_full.y);</a>
<a name="ln1074"> </a>
<a name="ln1075"> </a>
<a name="ln1076">      //_print_roi(&amp;iroi_full, &quot;tile iroi_full final&quot;);</a>
<a name="ln1077">      //_print_roi(&amp;oroi_full, &quot;tile oroi_full final&quot;);</a>
<a name="ln1078"> </a>
<a name="ln1079">      /* offsets of tile into ivoid and ovoid */</a>
<a name="ln1080">      size_t ioffs = ((size_t)iroi_full.y - roi_in-&gt;y) * ipitch + ((size_t)iroi_full.x - roi_in-&gt;x) * in_bpp;</a>
<a name="ln1081">      size_t ooffs = ((size_t)oroi_good.y - roi_out-&gt;y) * opitch</a>
<a name="ln1082">                     + ((size_t)oroi_good.x - roi_out-&gt;x) * out_bpp;</a>
<a name="ln1083"> </a>
<a name="ln1084">      dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] tile (%zu, %zu) with %d x %d at origin [%d, %d]\n&quot;,</a>
<a name="ln1085">               tx, ty, iroi_full.width, iroi_full.height, iroi_full.x, iroi_full.y);</a>
<a name="ln1086"> </a>
<a name="ln1087"> </a>
<a name="ln1088">      /* prepare input tile buffer */</a>
<a name="ln1089">      input = dt_alloc_align(64, (size_t)iroi_full.width * iroi_full.height * in_bpp);</a>
<a name="ln1090">      if(input == NULL)</a>
<a name="ln1091">      {</a>
<a name="ln1092">        dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] could not alloc input buffer for module '%s'\n&quot;,</a>
<a name="ln1093">                 self-&gt;op);</a>
<a name="ln1094">        goto error;</a>
<a name="ln1095">      }</a>
<a name="ln1096">      output = dt_alloc_align(64, (size_t)oroi_full.width * oroi_full.height * out_bpp);</a>
<a name="ln1097">      if(output == NULL)</a>
<a name="ln1098">      {</a>
<a name="ln1099">        dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] could not alloc output buffer for module '%s'\n&quot;,</a>
<a name="ln1100">                 self-&gt;op);</a>
<a name="ln1101">        goto error;</a>
<a name="ln1102">      }</a>
<a name="ln1103"> </a>
<a name="ln1104">#ifdef _OPENMP</a>
<a name="ln1105">#pragma omp parallel for default(none) \</a>
<a name="ln1106">      dt_omp_firstprivate(in_bpp, ipitch, ivoid) \</a>
<a name="ln1107">      shared(input, ioffs, iroi_full) \</a>
<a name="ln1108">      schedule(static)</a>
<a name="ln1109">#endif</a>
<a name="ln1110">      for(size_t j = 0; j &lt; iroi_full.height; j++)</a>
<a name="ln1111">        memcpy((char *)input + j * iroi_full.width * in_bpp, (char *)ivoid + ioffs + j * ipitch,</a>
<a name="ln1112">               (size_t)iroi_full.width * in_bpp);</a>
<a name="ln1113"> </a>
<a name="ln1114">      /* take original processed_maximum as starting point */</a>
<a name="ln1115">      for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_saved[k];</a>
<a name="ln1116"> </a>
<a name="ln1117">      /* call process() of module */</a>
<a name="ln1118">      self-&gt;process(self, piece, input, output, &amp;iroi_full, &amp;oroi_full);</a>
<a name="ln1119"> </a>
<a name="ln1120">      /* aggregate resulting processed_maximum */</a>
<a name="ln1121">      /* TODO: check if there really can be differences between tiles and take</a>
<a name="ln1122">               appropriate action (calculate minimum, maximum, average, ...?) */</a>
<a name="ln1123">      for(int k = 0; k &lt; 4; k++)</a>
<a name="ln1124">      {</a>
<a name="ln1125">        if(tx + ty &gt; 0 &amp;&amp; fabs(processed_maximum_new[k] - piece-&gt;pipe-&gt;dsc.processed_maximum[k]) &gt; 1.0e-6f)</a>
<a name="ln1126">          dt_print(</a>
<a name="ln1127">              DT_DEBUG_DEV,</a>
<a name="ln1128">              &quot;[default_process_tiling_roi] processed_maximum[%d] differs between tiles in module '%s'\n&quot;, k,</a>
<a name="ln1129">              self-&gt;op);</a>
<a name="ln1130">        processed_maximum_new[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln1131">      }</a>
<a name="ln1132"> </a>
<a name="ln1133">      /* copy &quot;good&quot; part of tile to output buffer */</a>
<a name="ln1134">      const int origin_x = oroi_good.x - oroi_full.x;</a>
<a name="ln1135">      const int origin_y = oroi_good.y - oroi_full.y;</a>
<a name="ln1136">#ifdef _OPENMP</a>
<a name="ln1137">#pragma omp parallel for default(none) \</a>
<a name="ln1138">      dt_omp_firstprivate(opitch, origin_x, origin_y, out_bpp, ovoid) \</a>
<a name="ln1139">      shared(ooffs, output, oroi_good, oroi_full) \</a>
<a name="ln1140">      schedule(static)</a>
<a name="ln1141">#endif</a>
<a name="ln1142">      for(size_t j = 0; j &lt; oroi_good.height; j++)</a>
<a name="ln1143">        memcpy((char *)ovoid + ooffs + j * opitch,</a>
<a name="ln1144">               (char *)output + ((j + origin_y) * oroi_full.width + origin_x) * out_bpp,</a>
<a name="ln1145">               (size_t)oroi_good.width * out_bpp);</a>
<a name="ln1146"> </a>
<a name="ln1147">      dt_free_align(input);</a>
<a name="ln1148">      dt_free_align(output);</a>
<a name="ln1149">      input = output = NULL;</a>
<a name="ln1150">    }</a>
<a name="ln1151"> </a>
<a name="ln1152">  /* copy back final processed_maximum */</a>
<a name="ln1153">  for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_new[k];</a>
<a name="ln1154"> </a>
<a name="ln1155">  if(input != NULL) dt_free_align(input);</a>
<a name="ln1156">  if(output != NULL) dt_free_align(output);</a>
<a name="ln1157">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln1158">  return;</a>
<a name="ln1159"> </a>
<a name="ln1160">error:</a>
<a name="ln1161">  dt_control_log(_(&quot;tiling failed for module '%s'. output might be garbled.&quot;), self-&gt;op);</a>
<a name="ln1162">// fall through</a>
<a name="ln1163"> </a>
<a name="ln1164">fallback:</a>
<a name="ln1165">  if(input != NULL) dt_free_align(input);</a>
<a name="ln1166">  if(output != NULL) dt_free_align(output);</a>
<a name="ln1167">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln1168">  dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] fall back to standard processing for module '%s'\n&quot;,</a>
<a name="ln1169">           self-&gt;op);</a>
<a name="ln1170">  self-&gt;process(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln1171">  return;</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174"> </a>
<a name="ln1175"> </a>
<a name="ln1176">/* if a module does not implement process_tiling() by itself, this function is called instead.</a>
<a name="ln1177">   _default_process_tiling_ptp() is able to handle standard cases where pixels do not change their places.</a>
<a name="ln1178">   _default_process_tiling_roi() takes care of all other cases where image gets distorted and for module</a>
<a name="ln1179">   &quot;clipping&quot;,</a>
<a name="ln1180">   &quot;flip&quot; as this may flip or mirror the image. */</a>
<a name="ln1181">void default_process_tiling(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1182">                            const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln1183">                            const dt_iop_roi_t *const roi_out, const int in_bpp)</a>
<a name="ln1184">{</a>
<a name="ln1185">  if(memcmp(roi_in, roi_out, sizeof(struct dt_iop_roi_t)) || (self-&gt;flags() &amp; IOP_FLAGS_TILING_FULL_ROI))</a>
<a name="ln1186">    _default_process_tiling_roi(self, piece, ivoid, ovoid, roi_in, roi_out, in_bpp);</a>
<a name="ln1187">  else</a>
<a name="ln1188">    _default_process_tiling_ptp(self, piece, ivoid, ovoid, roi_in, roi_out, in_bpp);</a>
<a name="ln1189">  return;</a>
<a name="ln1190">}</a>
<a name="ln1191"> </a>
<a name="ln1192"> </a>
<a name="ln1193"> </a>
<a name="ln1194">#ifdef HAVE_OPENCL</a>
<a name="ln1195">/* simple tiling algorithm for roi_in == roi_out, i.e. for pixel to pixel modules/operations */</a>
<a name="ln1196">static int _default_process_tiling_cl_ptp(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1197">                                          const void *const ivoid, void *const ovoid,</a>
<a name="ln1198">                                          const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln1199">                                          const int in_bpp)</a>
<a name="ln1200">{</a>
<a name="ln1201">  cl_int err = -999;</a>
<a name="ln1202">  cl_mem input = NULL;</a>
<a name="ln1203">  cl_mem output = NULL;</a>
<a name="ln1204">  cl_mem pinned_input = NULL;</a>
<a name="ln1205">  cl_mem pinned_output = NULL;</a>
<a name="ln1206">  void *input_buffer = NULL;</a>
<a name="ln1207">  void *output_buffer = NULL;</a>
<a name="ln1208"> </a>
<a name="ln1209">  dt_iop_buffer_dsc_t dsc;</a>
<a name="ln1210">  self-&gt;output_format(self, piece-&gt;pipe, piece, &amp;dsc);</a>
<a name="ln1211">  const int out_bpp = dt_iop_buffer_dsc_to_bpp(&amp;dsc);</a>
<a name="ln1212"> </a>
<a name="ln1213">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln1214">  const int ipitch = roi_in-&gt;width * in_bpp;</a>
<a name="ln1215">  const int opitch = roi_out-&gt;width * out_bpp;</a>
<a name="ln1216">  const int max_bpp = _max(in_bpp, out_bpp);</a>
<a name="ln1217"> </a>
<a name="ln1218">  /* get tiling requirements of module */</a>
<a name="ln1219">  dt_develop_tiling_t tiling = { 0 };</a>
<a name="ln1220">  self-&gt;tiling_callback(self, piece, roi_in, roi_out, &amp;tiling);</a>
<a name="ln1221"> </a>
<a name="ln1222">  /* shall we use pinned memory transfers? */</a>
<a name="ln1223">  int use_pinned_memory = dt_conf_get_bool(&quot;opencl_use_pinned_memory&quot;);</a>
<a name="ln1224">  const int pinned_buffer_overhead = use_pinned_memory ? 2 : 0; // add two additional pinned memory buffers</a>
<a name="ln1225">                                                                // which seemingly get allocated not only on</a>
<a name="ln1226">                                                                // host but also on device (why???)</a>
<a name="ln1227">  const float pinned_buffer_slack</a>
<a name="ln1228">      = use_pinned_memory</a>
<a name="ln1229">            ? 0.85f</a>
<a name="ln1230">            : 1.0f; // avoid problems when pinned buffer size gets too close to max_mem_alloc size</a>
<a name="ln1231"> </a>
<a name="ln1232">  /* calculate optimal size of tiles */</a>
<a name="ln1233">  float headroom = dt_conf_get_float(&quot;opencl_memory_headroom&quot;) * 1024.0f * 1024.0f;</a>
<a name="ln1234">  headroom = fmin(fmax(headroom, 0.0f), (float)darktable.opencl-&gt;dev[devid].max_global_mem);</a>
<a name="ln1235">  const float available = darktable.opencl-&gt;dev[devid].max_global_mem - headroom;</a>
<a name="ln1236">  float factor = fmax(tiling.factor + pinned_buffer_overhead, 1.0f);</a>
<a name="ln1237">  const float singlebuffer = fmin(fmax((available - tiling.overhead) / factor, 0.0f),</a>
<a name="ln1238">                                  pinned_buffer_slack * darktable.opencl-&gt;dev[devid].max_mem_alloc);</a>
<a name="ln1239">  float maxbuf = fmax(tiling.maxbuf, 1.0f);</a>
<a name="ln1240">  int width = _min(roi_in-&gt;width, darktable.opencl-&gt;dev[devid].max_image_width);</a>
<a name="ln1241">  int height = _min(roi_in-&gt;height, darktable.opencl-&gt;dev[devid].max_image_height);</a>
<a name="ln1242"> </a>
<a name="ln1243">  /* shrink tile size in case it would exceed singlebuffer size */</a>
<a name="ln1244">  if((float)width * height * max_bpp * maxbuf &gt; singlebuffer)</a>
<a name="ln1245">  {</a>
<a name="ln1246">    const float scale = singlebuffer / ((float)width * height * max_bpp * maxbuf);</a>
<a name="ln1247"> </a>
<a name="ln1248">    if(width &lt; height &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln1249">    {</a>
<a name="ln1250">      height = floorf(height * scale);</a>
<a name="ln1251">    }</a>
<a name="ln1252">    else if(height &lt;= width &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln1253">    {</a>
<a name="ln1254">      width = floorf(width * scale);</a>
<a name="ln1255">    }</a>
<a name="ln1256">    else</a>
<a name="ln1257">    {</a>
<a name="ln1258">      width = floorf(width * sqrt(scale));</a>
<a name="ln1259">      height = floorf(height * sqrt(scale));</a>
<a name="ln1260">    }</a>
<a name="ln1261">  }</a>
<a name="ln1262"> </a>
<a name="ln1263">  /* make sure we have a reasonably effective tile dimension. if not try square tiles */</a>
<a name="ln1264">  if(3 * tiling.overlap &gt; width || 3 * tiling.overlap &gt; height)</a>
<a name="ln1265">  {</a>
<a name="ln1266">    width = height = floorf(sqrtf((float)width * height));</a>
<a name="ln1267">  }</a>
<a name="ln1268"> </a>
<a name="ln1269"> </a>
<a name="ln1270">  /* Alignment rules: we need to make sure that alignment requirements of module are fulfilled.</a>
<a name="ln1271">     Modules will report alignment requirements via xalign and yalign within tiling_callback().</a>
<a name="ln1272">     Typical use case is demosaic where Bayer pattern requires alignment to a multiple of 2 in x and y</a>
<a name="ln1273">     direction. Additional alignment requirements are set via definition of CL_ALIGNMENT.</a>
<a name="ln1274">     We guarantee alignment by selecting image width/height and overlap accordingly. For a tile width/height</a>
<a name="ln1275">     that is identical to image width/height no special alignment is done. */</a>
<a name="ln1276"> </a>
<a name="ln1277">  /* for simplicity reasons we use only one alignment that fits to x and y requirements at the same time */</a>
<a name="ln1278">  const unsigned int xyalign = _lcm(tiling.xalign, tiling.yalign);</a>
<a name="ln1279"> </a>
<a name="ln1280">  /* determining alignment requirement for tile width/height.</a>
<a name="ln1281">     in case of tile width also align according to definition of CL_ALIGNMENT */</a>
<a name="ln1282">  const unsigned int walign = _lcm(xyalign, CL_ALIGNMENT);</a>
<a name="ln1283">  const unsigned int halign = xyalign;</a>
<a name="ln1284"> </a>
<a name="ln1285">  assert(xyalign != 0 &amp;&amp; walign != 0 &amp;&amp; halign != 0);</a>
<a name="ln1286"> </a>
<a name="ln1287">  /* properly align tile width and height by making them smaller if needed */</a>
<a name="ln1288">  if(width &lt; roi_in-&gt;width) width = (width / walign) * walign;</a>
<a name="ln1289">  if(height &lt; roi_in-&gt;height) height = (height / halign) * halign;</a>
<a name="ln1290"> </a>
<a name="ln1291">  /* also make sure that overlap follows alignment rules by making it wider when needed */</a>
<a name="ln1292">  const int overlap = tiling.overlap % xyalign != 0 ? (tiling.overlap / xyalign + 1) * xyalign</a>
<a name="ln1293">                                                    : tiling.overlap;</a>
<a name="ln1294"> </a>
<a name="ln1295"> </a>
<a name="ln1296">  /* calculate effective tile size */</a>
<a name="ln1297">  const int tile_wd = width - 2 * overlap &gt; 0 ? width - 2 * overlap : 1;</a>
<a name="ln1298">  const int tile_ht = height - 2 * overlap &gt; 0 ? height - 2 * overlap : 1;</a>
<a name="ln1299"> </a>
<a name="ln1300"> </a>
<a name="ln1301">  /* calculate number of tiles */</a>
<a name="ln1302">  const int tiles_x = width &lt; roi_in-&gt;width ? ceilf(roi_in-&gt;width / (float)tile_wd) : 1;</a>
<a name="ln1303">  const int tiles_y = height &lt; roi_in-&gt;height ? ceilf(roi_in-&gt;height / (float)tile_ht) : 1;</a>
<a name="ln1304"> </a>
<a name="ln1305">  /* sanity check: don't run wild on too many tiles */</a>
<a name="ln1306">  if(tiles_x * tiles_y &gt; dt_conf_get_int(&quot;maximum_number_tiles&quot;))</a>
<a name="ln1307">  {</a>
<a name="ln1308">    dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1309">             &quot;[default_process_tiling_cl_ptp] aborted tiling for module '%s'. too many tiles: %d x %d\n&quot;,</a>
<a name="ln1310">             self-&gt;op, tiles_x, tiles_y);</a>
<a name="ln1311">    return FALSE;</a>
<a name="ln1312">  }</a>
<a name="ln1313"> </a>
<a name="ln1314"> </a>
<a name="ln1315">  dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1316">           &quot;[default_process_tiling_cl_ptp] use tiling on module '%s' for image with full size %d x %d\n&quot;,</a>
<a name="ln1317">           self-&gt;op, roi_in-&gt;width, roi_in-&gt;height);</a>
<a name="ln1318">  dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1319">           &quot;[default_process_tiling_cl_ptp] (%d x %d) tiles with max dimensions %d x %d and overlap %d\n&quot;,</a>
<a name="ln1320">           tiles_x, tiles_y, width, height, overlap);</a>
<a name="ln1321"> </a>
<a name="ln1322">  /* store processed_maximum to be re-used and aggregated */</a>
<a name="ln1323">  float processed_maximum_saved[4];</a>
<a name="ln1324">  float processed_maximum_new[4] = { 1.0f };</a>
<a name="ln1325">  for(int k = 0; k &lt; 4; k++) processed_maximum_saved[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln1326"> </a>
<a name="ln1327">  /* reserve pinned input and output memory for host&lt;-&gt;device data transfer */</a>
<a name="ln1328">  if(use_pinned_memory)</a>
<a name="ln1329">  {</a>
<a name="ln1330">    pinned_input = dt_opencl_alloc_device_buffer_with_flags(devid, (size_t)width * height * in_bpp,</a>
<a name="ln1331">                                                            CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR);</a>
<a name="ln1332">    if(pinned_input == NULL)</a>
<a name="ln1333">    {</a>
<a name="ln1334">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1335">               &quot;[default_process_tiling_cl_ptp] could not alloc pinned input buffer for module '%s'\n&quot;,</a>
<a name="ln1336">               self-&gt;op);</a>
<a name="ln1337">      use_pinned_memory = 0;</a>
<a name="ln1338">    }</a>
<a name="ln1339">  }</a>
<a name="ln1340"> </a>
<a name="ln1341">  if(use_pinned_memory)</a>
<a name="ln1342">  {</a>
<a name="ln1343"> </a>
<a name="ln1344">    input_buffer = dt_opencl_map_buffer(devid, pinned_input, CL_TRUE, CL_MAP_WRITE, 0,</a>
<a name="ln1345">                                        (size_t)width * height * in_bpp);</a>
<a name="ln1346">    if(input_buffer == NULL)</a>
<a name="ln1347">    {</a>
<a name="ln1348">      dt_print(DT_DEBUG_OPENCL, &quot;[default_process_tiling_cl_ptp] could not map pinned input buffer to host &quot;</a>
<a name="ln1349">                                &quot;memory for module '%s'\n&quot;,</a>
<a name="ln1350">               self-&gt;op);</a>
<a name="ln1351">      use_pinned_memory = 0;</a>
<a name="ln1352">    }</a>
<a name="ln1353">  }</a>
<a name="ln1354"> </a>
<a name="ln1355">  if(use_pinned_memory)</a>
<a name="ln1356">  {</a>
<a name="ln1357"> </a>
<a name="ln1358">    pinned_output = dt_opencl_alloc_device_buffer_with_flags(devid, (size_t)width * height * out_bpp,</a>
<a name="ln1359">                                                             CL_MEM_WRITE_ONLY | CL_MEM_ALLOC_HOST_PTR);</a>
<a name="ln1360">    if(pinned_output == NULL)</a>
<a name="ln1361">    {</a>
<a name="ln1362">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1363">               &quot;[default_process_tiling_cl_ptp] could not alloc pinned output buffer for module '%s'\n&quot;,</a>
<a name="ln1364">               self-&gt;op);</a>
<a name="ln1365">      use_pinned_memory = 0;</a>
<a name="ln1366">    }</a>
<a name="ln1367">  }</a>
<a name="ln1368"> </a>
<a name="ln1369">  if(use_pinned_memory)</a>
<a name="ln1370">  {</a>
<a name="ln1371"> </a>
<a name="ln1372">    output_buffer = dt_opencl_map_buffer(devid, pinned_output, CL_TRUE, CL_MAP_READ, 0,</a>
<a name="ln1373">                                         (size_t)width * height * out_bpp);</a>
<a name="ln1374">    if(output_buffer == NULL)</a>
<a name="ln1375">    {</a>
<a name="ln1376">      dt_print(DT_DEBUG_OPENCL, &quot;[default_process_tiling_cl_ptp] could not map pinned output buffer to host &quot;</a>
<a name="ln1377">                                &quot;memory for module '%s'\n&quot;,</a>
<a name="ln1378">               self-&gt;op);</a>
<a name="ln1379">      use_pinned_memory = 0;</a>
<a name="ln1380">    }</a>
<a name="ln1381">  }</a>
<a name="ln1382"> </a>
<a name="ln1383">  /* iterate over tiles */</a>
<a name="ln1384">  for(size_t tx = 0; tx &lt; tiles_x; tx++)</a>
<a name="ln1385">    for(size_t ty = 0; ty &lt; tiles_y; ty++)</a>
<a name="ln1386">    {</a>
<a name="ln1387">      piece-&gt;pipe-&gt;tiling = 1;</a>
<a name="ln1388"> </a>
<a name="ln1389">      size_t wd = tx * tile_wd + width &gt; roi_in-&gt;width ? roi_in-&gt;width - tx * tile_wd : width;</a>
<a name="ln1390">      size_t ht = ty * tile_ht + height &gt; roi_in-&gt;height ? roi_in-&gt;height - ty * tile_ht : height;</a>
<a name="ln1391"> </a>
<a name="ln1392">      /* no need to process (end)tiles that are smaller than the total overlap area */</a>
<a name="ln1393">      if((wd &lt;= 2 * overlap &amp;&amp; tx &gt; 0) || (ht &lt;= 2 * overlap &amp;&amp; ty &gt; 0)) continue;</a>
<a name="ln1394"> </a>
<a name="ln1395">      /* origin and region of effective part of tile, which we want to store later */</a>
<a name="ln1396">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln1397">      size_t region[] = { wd, ht, 1 };</a>
<a name="ln1398"> </a>
<a name="ln1399">      /* roi_in and roi_out for process_cl on subbuffer */</a>
<a name="ln1400">      dt_iop_roi_t iroi = { roi_in-&gt;x + tx * tile_wd, roi_in-&gt;y + ty * tile_ht, wd, ht, roi_in-&gt;scale };</a>
<a name="ln1401">      dt_iop_roi_t oroi = { roi_out-&gt;x + tx * tile_wd, roi_out-&gt;y + ty * tile_ht, wd, ht, roi_out-&gt;scale };</a>
<a name="ln1402"> </a>
<a name="ln1403"> </a>
<a name="ln1404">      /* offsets of tile into ivoid and ovoid */</a>
<a name="ln1405">      size_t ioffs = (ty * tile_ht) * ipitch + (tx * tile_wd) * in_bpp;</a>
<a name="ln1406">      size_t ooffs = (ty * tile_ht) * opitch + (tx * tile_wd) * out_bpp;</a>
<a name="ln1407"> </a>
<a name="ln1408"> </a>
<a name="ln1409">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1410">               &quot;[default_process_tiling_cl_ptp] tile (%zu, %zu) with %zu x %zu at origin [%zu, %zu]\n&quot;, tx, ty, wd,</a>
<a name="ln1411">               ht, tx * tile_wd, ty * tile_ht);</a>
<a name="ln1412"> </a>
<a name="ln1413">      /* get input and output buffers */</a>
<a name="ln1414">      input = dt_opencl_alloc_device(devid, wd, ht, in_bpp);</a>
<a name="ln1415">      if(input == NULL) goto error;</a>
<a name="ln1416">      output = dt_opencl_alloc_device(devid, wd, ht, out_bpp);</a>
<a name="ln1417">      if(output == NULL) goto error;</a>
<a name="ln1418"> </a>
<a name="ln1419">      if(use_pinned_memory)</a>
<a name="ln1420">      {</a>
<a name="ln1421">/* prepare pinned input tile buffer: copy part of input image */</a>
<a name="ln1422">#ifdef _OPENMP</a>
<a name="ln1423">#pragma omp parallel for default(none) \</a>
<a name="ln1424">        dt_omp_firstprivate(in_bpp, ipitch, ivoid) \</a>
<a name="ln1425">        shared(input_buffer, width, ioffs, wd, ht) \</a>
<a name="ln1426">        schedule(static)</a>
<a name="ln1427">#endif</a>
<a name="ln1428">        for(size_t j = 0; j &lt; ht; j++)</a>
<a name="ln1429">          memcpy((char *)input_buffer + j * wd * in_bpp, (char *)ivoid + ioffs + j * ipitch,</a>
<a name="ln1430">                 (size_t)wd * in_bpp);</a>
<a name="ln1431"> </a>
<a name="ln1432">        /* blocking memory transfer: pinned host input buffer -&gt; opencl/device tile */</a>
<a name="ln1433">        err = dt_opencl_write_host_to_device_raw(devid, (char *)input_buffer, input, origin, region,</a>
<a name="ln1434">                                                 wd * in_bpp, CL_TRUE);</a>
<a name="ln1435">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1436">      }</a>
<a name="ln1437">      else</a>
<a name="ln1438">      {</a>
<a name="ln1439">        /* blocking direct memory transfer: host input image -&gt; opencl/device tile */</a>
<a name="ln1440">        err = dt_opencl_write_host_to_device_raw(devid, (char *)ivoid + ioffs, input, origin, region, ipitch,</a>
<a name="ln1441">                                                 CL_TRUE);</a>
<a name="ln1442">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1443">      }</a>
<a name="ln1444"> </a>
<a name="ln1445">      /* take original processed_maximum as starting point */</a>
<a name="ln1446">      for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_saved[k];</a>
<a name="ln1447"> </a>
<a name="ln1448">      /* call process_cl of module */</a>
<a name="ln1449">      if(!self-&gt;process_cl(self, piece, input, output, &amp;iroi, &amp;oroi)) goto error;</a>
<a name="ln1450"> </a>
<a name="ln1451">      /* aggregate resulting processed_maximum */</a>
<a name="ln1452">      /* TODO: check if there really can be differences between tiles and take</a>
<a name="ln1453">               appropriate action (calculate minimum, maximum, average, ...?) */</a>
<a name="ln1454">      for(int k = 0; k &lt; 4; k++)</a>
<a name="ln1455">      {</a>
<a name="ln1456">        if(tx + ty &gt; 0 &amp;&amp; fabs(processed_maximum_new[k] - piece-&gt;pipe-&gt;dsc.processed_maximum[k]) &gt; 1.0e-6f)</a>
<a name="ln1457">          dt_print(</a>
<a name="ln1458">              DT_DEBUG_OPENCL,</a>
<a name="ln1459">              &quot;[default_process_tiling_cl_ptp] processed_maximum[%d] differs between tiles in module '%s'\n&quot;,</a>
<a name="ln1460">              k, self-&gt;op);</a>
<a name="ln1461">        processed_maximum_new[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln1462">      }</a>
<a name="ln1463"> </a>
<a name="ln1464">      if(use_pinned_memory)</a>
<a name="ln1465">      {</a>
<a name="ln1466">        /* blocking memory transfer: complete opencl/device tile -&gt; pinned host output buffer */</a>
<a name="ln1467">        err = dt_opencl_read_host_from_device_raw(devid, (char *)output_buffer, output, origin, region,</a>
<a name="ln1468">                                                  wd * out_bpp, CL_TRUE);</a>
<a name="ln1469">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1470">      }</a>
<a name="ln1471"> </a>
<a name="ln1472">      /* correct origin and region of tile for overlap.</a>
<a name="ln1473">         makes sure that we only copy back the &quot;good&quot; part. */</a>
<a name="ln1474">      if(tx &gt; 0)</a>
<a name="ln1475">      {</a>
<a name="ln1476">        origin[0] += overlap;</a>
<a name="ln1477">        region[0] -= overlap;</a>
<a name="ln1478">        ooffs += overlap * out_bpp;</a>
<a name="ln1479">      }</a>
<a name="ln1480">      if(ty &gt; 0)</a>
<a name="ln1481">      {</a>
<a name="ln1482">        origin[1] += overlap;</a>
<a name="ln1483">        region[1] -= overlap;</a>
<a name="ln1484">        ooffs += overlap * opitch;</a>
<a name="ln1485">      }</a>
<a name="ln1486"> </a>
<a name="ln1487">      if(use_pinned_memory)</a>
<a name="ln1488">      {</a>
<a name="ln1489">/* copy &quot;good&quot; part of tile from pinned output buffer to output image */</a>
<a name="ln1490">#if 0 // def _OPENMP</a>
<a name="ln1491">#pragma omp parallel for default(none) shared(ovoid, ooffs, output_buffer, width, origin, region,            \</a>
<a name="ln1492">                                              wd) schedule(static)</a>
<a name="ln1493">#endif</a>
<a name="ln1494">        for(size_t j = 0; j &lt; region[1]; j++)</a>
<a name="ln1495">          memcpy((char *)ovoid + ooffs + j * opitch,</a>
<a name="ln1496">                 (char *)output_buffer + ((j + origin[1]) * wd + origin[0]) * out_bpp,</a>
<a name="ln1497">                 (size_t)region[0] * out_bpp);</a>
<a name="ln1498">      }</a>
<a name="ln1499">      else</a>
<a name="ln1500">      {</a>
<a name="ln1501">        /* blocking direct memory transfer: good part of opencl/device tile -&gt; host output image */</a>
<a name="ln1502">        err = dt_opencl_read_host_from_device_raw(devid, (char *)ovoid + ooffs, output, origin, region,</a>
<a name="ln1503">                                                  opitch, CL_TRUE);</a>
<a name="ln1504">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1505">      }</a>
<a name="ln1506"> </a>
<a name="ln1507">      /* release input and output buffers */</a>
<a name="ln1508">      dt_opencl_release_mem_object(input);</a>
<a name="ln1509">      input = NULL;</a>
<a name="ln1510">      dt_opencl_release_mem_object(output);</a>
<a name="ln1511">      output = NULL;</a>
<a name="ln1512"> </a>
<a name="ln1513">      /* block until opencl queue has finished to free all used event handlers */</a>
<a name="ln1514">      if(!darktable.opencl-&gt;async_pixelpipe || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_EXPORT)</a>
<a name="ln1515">        dt_opencl_finish(devid);</a>
<a name="ln1516">    }</a>
<a name="ln1517"> </a>
<a name="ln1518">  /* copy back final processed_maximum */</a>
<a name="ln1519">  for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_new[k];</a>
<a name="ln1520"> </a>
<a name="ln1521">  if(input_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_input, input_buffer);</a>
<a name="ln1522">  dt_opencl_release_mem_object(pinned_input);</a>
<a name="ln1523">  if(output_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_output, output_buffer);</a>
<a name="ln1524">  dt_opencl_release_mem_object(pinned_output);</a>
<a name="ln1525">  dt_opencl_release_mem_object(input);</a>
<a name="ln1526">  dt_opencl_release_mem_object(output);</a>
<a name="ln1527">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln1528">  return TRUE;</a>
<a name="ln1529"> </a>
<a name="ln1530">error:</a>
<a name="ln1531">  /* copy back stored processed_maximum */</a>
<a name="ln1532">  for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_saved[k];</a>
<a name="ln1533">  if(input_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_input, input_buffer);</a>
<a name="ln1534">  dt_opencl_release_mem_object(pinned_input);</a>
<a name="ln1535">  if(output_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_output, output_buffer);</a>
<a name="ln1536">  dt_opencl_release_mem_object(pinned_output);</a>
<a name="ln1537">  dt_opencl_release_mem_object(input);</a>
<a name="ln1538">  dt_opencl_release_mem_object(output);</a>
<a name="ln1539">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln1540">  dt_print(</a>
<a name="ln1541">      DT_DEBUG_OPENCL,</a>
<a name="ln1542">      &quot;[default_process_tiling_opencl_ptp] couldn't run process_cl() for module '%s' in tiling mode: %d\n&quot;,</a>
<a name="ln1543">      self-&gt;op, err);</a>
<a name="ln1544">  return FALSE;</a>
<a name="ln1545">}</a>
<a name="ln1546"> </a>
<a name="ln1547"> </a>
<a name="ln1548">/* more elaborate tiling algorithm for roi_in != roi_out: slower than the ptp variant,</a>
<a name="ln1549">   more tiles and larger overlap */</a>
<a name="ln1550">static int _default_process_tiling_cl_roi(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1551">                                          const void *const ivoid, void *const ovoid,</a>
<a name="ln1552">                                          const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln1553">                                          const int in_bpp)</a>
<a name="ln1554">{</a>
<a name="ln1555">  cl_int err = -999;</a>
<a name="ln1556">  cl_mem input = NULL;</a>
<a name="ln1557">  cl_mem output = NULL;</a>
<a name="ln1558">  cl_mem pinned_input = NULL;</a>
<a name="ln1559">  cl_mem pinned_output = NULL;</a>
<a name="ln1560">  void *input_buffer = NULL;</a>
<a name="ln1561">  void *output_buffer = NULL;</a>
<a name="ln1562"> </a>
<a name="ln1563"> </a>
<a name="ln1564">  //_print_roi(roi_in, &quot;module roi_in&quot;);</a>
<a name="ln1565">  //_print_roi(roi_out, &quot;module roi_out&quot;);</a>
<a name="ln1566"> </a>
<a name="ln1567">  dt_iop_buffer_dsc_t dsc;</a>
<a name="ln1568">  self-&gt;output_format(self, piece-&gt;pipe, piece, &amp;dsc);</a>
<a name="ln1569">  const int out_bpp = dt_iop_buffer_dsc_to_bpp(&amp;dsc);</a>
<a name="ln1570"> </a>
<a name="ln1571">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln1572">  const int ipitch = roi_in-&gt;width * in_bpp;</a>
<a name="ln1573">  const int opitch = roi_out-&gt;width * out_bpp;</a>
<a name="ln1574">  const int max_bpp = _max(in_bpp, out_bpp);</a>
<a name="ln1575"> </a>
<a name="ln1576">  float fullscale = fmax(roi_in-&gt;scale / roi_out-&gt;scale, sqrt(((float)roi_in-&gt;width * roi_in-&gt;height)</a>
<a name="ln1577">                                                              / ((float)roi_out-&gt;width * roi_out-&gt;height)));</a>
<a name="ln1578"> </a>
<a name="ln1579">  /* inaccuracy for roi_in elements in roi_out -&gt; roi_in calculations */</a>
<a name="ln1580">  const int delta = ceilf(fullscale);</a>
<a name="ln1581"> </a>
<a name="ln1582">  /* estimate for additional (space) requirement in buffer dimensions due to inaccuracies */</a>
<a name="ln1583">  const int inacc = RESERVE * delta;</a>
<a name="ln1584"> </a>
<a name="ln1585">  /* get tiling requirements of module */</a>
<a name="ln1586">  dt_develop_tiling_t tiling = { 0 };</a>
<a name="ln1587">  self-&gt;tiling_callback(self, piece, roi_in, roi_out, &amp;tiling);</a>
<a name="ln1588"> </a>
<a name="ln1589">  /* shall we use pinned memory transfers? */</a>
<a name="ln1590">  int use_pinned_memory = dt_conf_get_bool(&quot;opencl_use_pinned_memory&quot;);</a>
<a name="ln1591">  const int pinned_buffer_overhead = use_pinned_memory ? 2 : 0; // add two additional pinned memory buffers</a>
<a name="ln1592">                                                                // which seemingly get allocated not only on</a>
<a name="ln1593">                                                                // host but also on device (why???)</a>
<a name="ln1594">  const float pinned_buffer_slack</a>
<a name="ln1595">      = use_pinned_memory</a>
<a name="ln1596">            ? 0.85f</a>
<a name="ln1597">            : 1.0f; // avoid problems when pinned buffer size gets too close to max_mem_alloc size</a>
<a name="ln1598"> </a>
<a name="ln1599">  /* calculate optimal size of tiles */</a>
<a name="ln1600">  float headroom = dt_conf_get_float(&quot;opencl_memory_headroom&quot;) * 1024.0f * 1024.0f;</a>
<a name="ln1601">  headroom = fmin(fmax(headroom, 0.0f), (float)darktable.opencl-&gt;dev[devid].max_global_mem);</a>
<a name="ln1602">  const float available = darktable.opencl-&gt;dev[devid].max_global_mem - headroom;</a>
<a name="ln1603">  float factor = fmax(tiling.factor + pinned_buffer_overhead, 1.0f);</a>
<a name="ln1604">  const float singlebuffer = fmin(fmax((available - tiling.overhead) / factor, 0.0f),</a>
<a name="ln1605">                                  pinned_buffer_slack * darktable.opencl-&gt;dev[devid].max_mem_alloc);</a>
<a name="ln1606">  float maxbuf = fmax(tiling.maxbuf, 1.0f);</a>
<a name="ln1607"> </a>
<a name="ln1608">  int width = _min(_max(roi_in-&gt;width, roi_out-&gt;width), darktable.opencl-&gt;dev[devid].max_image_width);</a>
<a name="ln1609">  int height = _min(_max(roi_in-&gt;height, roi_out-&gt;height), darktable.opencl-&gt;dev[devid].max_image_height);</a>
<a name="ln1610"> </a>
<a name="ln1611">  /* shrink tile size in case it would exceed singlebuffer size */</a>
<a name="ln1612">  if((float)width * height * max_bpp * maxbuf &gt; singlebuffer)</a>
<a name="ln1613">  {</a>
<a name="ln1614">    const float scale = singlebuffer / ((float)width * height * max_bpp * maxbuf);</a>
<a name="ln1615"> </a>
<a name="ln1616">    if(width &lt; height &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln1617">    {</a>
<a name="ln1618">      height = floorf(height * scale);</a>
<a name="ln1619">    }</a>
<a name="ln1620">    else if(height &lt;= width &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln1621">    {</a>
<a name="ln1622">      width = floorf(width * scale);</a>
<a name="ln1623">    }</a>
<a name="ln1624">    else</a>
<a name="ln1625">    {</a>
<a name="ln1626">      width = floorf(width * sqrt(scale));</a>
<a name="ln1627">      height = floorf(height * sqrt(scale));</a>
<a name="ln1628">    }</a>
<a name="ln1629">  }</a>
<a name="ln1630"> </a>
<a name="ln1631">  /* make sure we have a reasonably effective tile dimension. if not try square tiles */</a>
<a name="ln1632">  if(3 * tiling.overlap &gt; width || 3 * tiling.overlap &gt; height)</a>
<a name="ln1633">  {</a>
<a name="ln1634">    width = height = floorf(sqrtf((float)width * height));</a>
<a name="ln1635">  }</a>
<a name="ln1636"> </a>
<a name="ln1637"> </a>
<a name="ln1638">  /* Alignment rules: we need to make sure that alignment requirements of module are fulfilled.</a>
<a name="ln1639">     Modules will report alignment requirements via xalign and yalign within tiling_callback().</a>
<a name="ln1640">     Typical use case is demosaic where Bayer pattern requires alignment to a multiple of 2 in x and y</a>
<a name="ln1641">     direction. Additional alignment requirements are set via definition of CL_ALIGNMENT. */</a>
<a name="ln1642"> </a>
<a name="ln1643">  /* for simplicity reasons we use only one alignment that fits to x and y requirements at the same time */</a>
<a name="ln1644">  unsigned int xyalign = _lcm(tiling.xalign, tiling.yalign);</a>
<a name="ln1645">  xyalign = _lcm(xyalign, CL_ALIGNMENT);</a>
<a name="ln1646"> </a>
<a name="ln1647">  assert(xyalign != 0);</a>
<a name="ln1648"> </a>
<a name="ln1649">  /* make sure that overlap follows alignment rules by making it wider when needed.</a>
<a name="ln1650">     overlap_in needs to be aligned, overlap_out is only here to calculate output buffer size */</a>
<a name="ln1651">  const int overlap_in = _align_up(tiling.overlap, xyalign);</a>
<a name="ln1652">  const int overlap_out = ceilf((float)overlap_in / fullscale);</a>
<a name="ln1653"> </a>
<a name="ln1654">  int tiles_x = 1, tiles_y = 1;</a>
<a name="ln1655"> </a>
<a name="ln1656">  /* calculate number of tiles taking the larger buffer (input or output) as a guiding one.</a>
<a name="ln1657">     normally it is roi_in &gt; roi_out; but let's be prepared */</a>
<a name="ln1658">  if(roi_in-&gt;width &gt; roi_out-&gt;width)</a>
<a name="ln1659">    tiles_x = width &lt; roi_in-&gt;width</a>
<a name="ln1660">                  ? ceilf((float)roi_in-&gt;width / (float)_max(width - 2 * overlap_in - inacc, 1))</a>
<a name="ln1661">                  : 1;</a>
<a name="ln1662">  else</a>
<a name="ln1663">    tiles_x = width &lt; roi_out-&gt;width ? ceilf((float)roi_out-&gt;width / (float)_max(width - 2 * overlap_out, 1))</a>
<a name="ln1664">                                     : 1;</a>
<a name="ln1665"> </a>
<a name="ln1666">  if(roi_in-&gt;height &gt; roi_out-&gt;height)</a>
<a name="ln1667">    tiles_y = height &lt; roi_in-&gt;height</a>
<a name="ln1668">                  ? ceilf((float)roi_in-&gt;height / (float)_max(height - 2 * overlap_in - inacc, 1))</a>
<a name="ln1669">                  : 1;</a>
<a name="ln1670">  else</a>
<a name="ln1671">    tiles_y = height &lt; roi_out-&gt;height</a>
<a name="ln1672">                  ? ceilf((float)roi_out-&gt;height / (float)_max(height - 2 * overlap_out, 1))</a>
<a name="ln1673">                  : 1;</a>
<a name="ln1674"> </a>
<a name="ln1675">  /* sanity check: don't run wild on too many tiles */</a>
<a name="ln1676">  if(tiles_x * tiles_y &gt; dt_conf_get_int(&quot;maximum_number_tiles&quot;))</a>
<a name="ln1677">  {</a>
<a name="ln1678">    dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1679">             &quot;[default_process_tiling_cl_roi] aborted tiling for module '%s'. too many tiles: %d x %d\n&quot;,</a>
<a name="ln1680">             self-&gt;op, tiles_x, tiles_y);</a>
<a name="ln1681">    return FALSE;</a>
<a name="ln1682">  }</a>
<a name="ln1683"> </a>
<a name="ln1684">  /* calculate tile width and height excl. overlap (i.e. the good part) for output.</a>
<a name="ln1685">     important for all following processing steps. */</a>
<a name="ln1686">  const int tile_wd = _align_up(</a>
<a name="ln1687">      roi_out-&gt;width % tiles_x == 0 ? roi_out-&gt;width / tiles_x : roi_out-&gt;width / tiles_x + 1, xyalign);</a>
<a name="ln1688">  const int tile_ht = _align_up(</a>
<a name="ln1689">      roi_out-&gt;height % tiles_y == 0 ? roi_out-&gt;height / tiles_y : roi_out-&gt;height / tiles_y + 1, xyalign);</a>
<a name="ln1690"> </a>
<a name="ln1691"> </a>
<a name="ln1692">  dt_print(</a>
<a name="ln1693">      DT_DEBUG_OPENCL,</a>
<a name="ln1694">      &quot;[default_process_tiling_cl_roi] use tiling on module '%s' for image with full input size %d x %d\n&quot;,</a>
<a name="ln1695">      self-&gt;op, roi_in-&gt;width, roi_in-&gt;height);</a>
<a name="ln1696">  dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1697">           &quot;[default_process_tiling_cl_roi] (%d x %d) tiles with max input dimensions %d x %d\n&quot;, tiles_x,</a>
<a name="ln1698">           tiles_y, width, height);</a>
<a name="ln1699"> </a>
<a name="ln1700"> </a>
<a name="ln1701">  /* store processed_maximum to be re-used and aggregated */</a>
<a name="ln1702">  float processed_maximum_saved[4];</a>
<a name="ln1703">  float processed_maximum_new[4] = { 1.0f };</a>
<a name="ln1704">  for(int k = 0; k &lt; 4; k++) processed_maximum_saved[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln1705"> </a>
<a name="ln1706">  /* reserve pinned input and output memory for host&lt;-&gt;device data transfer */</a>
<a name="ln1707">  if(use_pinned_memory)</a>
<a name="ln1708">  {</a>
<a name="ln1709">    pinned_input = dt_opencl_alloc_device_buffer_with_flags(devid, (size_t)width * height * in_bpp,</a>
<a name="ln1710">                                                            CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR);</a>
<a name="ln1711">    if(pinned_input == NULL)</a>
<a name="ln1712">    {</a>
<a name="ln1713">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1714">               &quot;[default_process_tiling_cl_roi] could not alloc pinned input buffer for module '%s'\n&quot;,</a>
<a name="ln1715">               self-&gt;op);</a>
<a name="ln1716">      use_pinned_memory = 0;</a>
<a name="ln1717">    }</a>
<a name="ln1718">  }</a>
<a name="ln1719"> </a>
<a name="ln1720">  if(use_pinned_memory)</a>
<a name="ln1721">  {</a>
<a name="ln1722"> </a>
<a name="ln1723">    input_buffer = dt_opencl_map_buffer(devid, pinned_input, CL_TRUE, CL_MAP_WRITE, 0,</a>
<a name="ln1724">                                        (size_t)width * height * in_bpp);</a>
<a name="ln1725">    if(input_buffer == NULL)</a>
<a name="ln1726">    {</a>
<a name="ln1727">      dt_print(DT_DEBUG_OPENCL, &quot;[default_process_tiling_cl_roi] could not map pinned input buffer to host &quot;</a>
<a name="ln1728">                                &quot;memory for module '%s'\n&quot;,</a>
<a name="ln1729">               self-&gt;op);</a>
<a name="ln1730">      use_pinned_memory = 0;</a>
<a name="ln1731">    }</a>
<a name="ln1732">  }</a>
<a name="ln1733"> </a>
<a name="ln1734">  if(use_pinned_memory)</a>
<a name="ln1735">  {</a>
<a name="ln1736"> </a>
<a name="ln1737">    pinned_output = dt_opencl_alloc_device_buffer_with_flags(devid, (size_t)width * height * out_bpp,</a>
<a name="ln1738">                                                             CL_MEM_WRITE_ONLY | CL_MEM_ALLOC_HOST_PTR);</a>
<a name="ln1739">    if(pinned_output == NULL)</a>
<a name="ln1740">    {</a>
<a name="ln1741">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1742">               &quot;[default_process_tiling_cl_roi] could not alloc pinned output buffer for module '%s'\n&quot;,</a>
<a name="ln1743">               self-&gt;op);</a>
<a name="ln1744">      use_pinned_memory = 0;</a>
<a name="ln1745">    }</a>
<a name="ln1746">  }</a>
<a name="ln1747"> </a>
<a name="ln1748">  if(use_pinned_memory)</a>
<a name="ln1749">  {</a>
<a name="ln1750"> </a>
<a name="ln1751">    output_buffer = dt_opencl_map_buffer(devid, pinned_output, CL_TRUE, CL_MAP_READ, 0,</a>
<a name="ln1752">                                         (size_t)width * height * out_bpp);</a>
<a name="ln1753">    if(output_buffer == NULL)</a>
<a name="ln1754">    {</a>
<a name="ln1755">      dt_print(DT_DEBUG_OPENCL, &quot;[default_process_tiling_cl_roi] could not map pinned output buffer to host &quot;</a>
<a name="ln1756">                                &quot;memory for module '%s'\n&quot;,</a>
<a name="ln1757">               self-&gt;op);</a>
<a name="ln1758">      use_pinned_memory = 0;</a>
<a name="ln1759">    }</a>
<a name="ln1760">  }</a>
<a name="ln1761"> </a>
<a name="ln1762"> </a>
<a name="ln1763">  /* iterate over tiles */</a>
<a name="ln1764">  for(size_t tx = 0; tx &lt; tiles_x; tx++)</a>
<a name="ln1765">    for(size_t ty = 0; ty &lt; tiles_y; ty++)</a>
<a name="ln1766">    {</a>
<a name="ln1767">      piece-&gt;pipe-&gt;tiling = 1;</a>
<a name="ln1768"> </a>
<a name="ln1769">      /* the output dimensions of the good part of this specific tile */</a>
<a name="ln1770">      size_t wd = (tx + 1) * tile_wd &gt; roi_out-&gt;width ? roi_out-&gt;width - tx * tile_wd : tile_wd;</a>
<a name="ln1771">      size_t ht = (ty + 1) * tile_ht &gt; roi_out-&gt;height ? roi_out-&gt;height - ty * tile_ht : tile_ht;</a>
<a name="ln1772"> </a>
<a name="ln1773">      /* roi_in and roi_out of good part: oroi_good easy to calculate based on number and dimension of tile.</a>
<a name="ln1774">         iroi_good is calculated by modify_roi_in() of respective module */</a>
<a name="ln1775">      dt_iop_roi_t iroi_good = { roi_in-&gt;x + tx * tile_wd, roi_in-&gt;y + ty * tile_ht, wd, ht, roi_in-&gt;scale };</a>
<a name="ln1776">      dt_iop_roi_t oroi_good</a>
<a name="ln1777">          = { roi_out-&gt;x + tx * tile_wd, roi_out-&gt;y + ty * tile_ht, wd, ht, roi_out-&gt;scale };</a>
<a name="ln1778"> </a>
<a name="ln1779">      self-&gt;modify_roi_in(self, piece, &amp;oroi_good, &amp;iroi_good);</a>
<a name="ln1780"> </a>
<a name="ln1781">      /* clamp iroi_good to not exceed roi_in */</a>
<a name="ln1782">      iroi_good.x = _max(iroi_good.x, roi_in-&gt;x);</a>
<a name="ln1783">      iroi_good.y = _max(iroi_good.y, roi_in-&gt;y);</a>
<a name="ln1784">      iroi_good.width = _min(iroi_good.width, roi_in-&gt;width + roi_in-&gt;x - iroi_good.x);</a>
<a name="ln1785">      iroi_good.height = _min(iroi_good.height, roi_in-&gt;height + roi_in-&gt;y - iroi_good.y);</a>
<a name="ln1786"> </a>
<a name="ln1787">      //_print_roi(&amp;iroi_good, &quot;tile iroi_good&quot;);</a>
<a name="ln1788">      //_print_roi(&amp;oroi_good, &quot;tile oroi_good&quot;);</a>
<a name="ln1789"> </a>
<a name="ln1790">      /* now we need to calculate full region of this tile: increase input roi to take care of overlap</a>
<a name="ln1791">         requirements</a>
<a name="ln1792">         and alignment and add additional delta to correct for possible rounding errors in modify_roi_in()</a>
<a name="ln1793">         -&gt; generates first estimate of iroi_full */</a>
<a name="ln1794">      const int x_in = iroi_good.x;</a>
<a name="ln1795">      const int y_in = iroi_good.y;</a>
<a name="ln1796">      const int width_in = iroi_good.width;</a>
<a name="ln1797">      const int height_in = iroi_good.height;</a>
<a name="ln1798">      const int new_x_in = _max(_align_down(x_in - overlap_in - delta, xyalign), roi_in-&gt;x);</a>
<a name="ln1799">      const int new_y_in = _max(_align_down(y_in - overlap_in - delta, xyalign), roi_in-&gt;y);</a>
<a name="ln1800">      const int new_width_in = _min(_align_up(width_in + overlap_in + delta + (x_in - new_x_in), xyalign),</a>
<a name="ln1801">                                    roi_in-&gt;width + roi_in-&gt;x - new_x_in);</a>
<a name="ln1802">      const int new_height_in = _min(_align_up(height_in + overlap_in + delta + (y_in - new_y_in), xyalign),</a>
<a name="ln1803">                                     roi_in-&gt;height + roi_in-&gt;y - new_y_in);</a>
<a name="ln1804"> </a>
<a name="ln1805">      /* iroi_full based on calculated numbers and dimensions. oroi_full just set as a starting point for the</a>
<a name="ln1806">       * following iterative search */</a>
<a name="ln1807">      dt_iop_roi_t iroi_full = { new_x_in, new_y_in, new_width_in, new_height_in, iroi_good.scale };</a>
<a name="ln1808">      dt_iop_roi_t oroi_full = oroi_good; // a good starting point for optimization</a>
<a name="ln1809"> </a>
<a name="ln1810">      //_print_roi(&amp;iroi_full, &quot;tile iroi_full before optimization&quot;);</a>
<a name="ln1811">      //_print_roi(&amp;oroi_full, &quot;tile oroi_full before optimization&quot;);</a>
<a name="ln1812"> </a>
<a name="ln1813">      /* try to find a matching oroi_full */</a>
<a name="ln1814">      if(!_fit_output_to_input_roi(self, piece, &amp;iroi_full, &amp;oroi_full, delta, 10))</a>
<a name="ln1815">      {</a>
<a name="ln1816">        dt_print(DT_DEBUG_OPENCL, &quot;[default_process_tiling_cl_roi] can not handle requested roi's. tiling &quot;</a>
<a name="ln1817">                                  &quot;for module '%s' not possible.\n&quot;,</a>
<a name="ln1818">                 self-&gt;op);</a>
<a name="ln1819">        goto error;</a>
<a name="ln1820">      }</a>
<a name="ln1821"> </a>
<a name="ln1822"> </a>
<a name="ln1823">      /* make sure that oroi_full at least covers the range of oroi_good.</a>
<a name="ln1824">         this step is needed due to the possibility of rounding errors */</a>
<a name="ln1825">      oroi_full.x = _min(oroi_full.x, oroi_good.x);</a>
<a name="ln1826">      oroi_full.y = _min(oroi_full.y, oroi_good.y);</a>
<a name="ln1827">      oroi_full.width = _max(oroi_full.width, oroi_good.x + oroi_good.width - oroi_full.x);</a>
<a name="ln1828">      oroi_full.height = _max(oroi_full.height, oroi_good.y + oroi_good.height - oroi_full.y);</a>
<a name="ln1829"> </a>
<a name="ln1830">      /* clamp oroi_full to not exceed roi_out */</a>
<a name="ln1831">      oroi_full.x = _max(oroi_full.x, roi_out-&gt;x);</a>
<a name="ln1832">      oroi_full.y = _max(oroi_full.y, roi_out-&gt;y);</a>
<a name="ln1833">      oroi_full.width = _min(oroi_full.width, roi_out-&gt;width + roi_out-&gt;x - oroi_full.x);</a>
<a name="ln1834">      oroi_full.height = _min(oroi_full.height, roi_out-&gt;height + roi_out-&gt;y - oroi_full.y);</a>
<a name="ln1835"> </a>
<a name="ln1836"> </a>
<a name="ln1837">      /* calculate final iroi_full */</a>
<a name="ln1838">      self-&gt;modify_roi_in(self, piece, &amp;oroi_full, &amp;iroi_full);</a>
<a name="ln1839"> </a>
<a name="ln1840">      /* clamp iroi_full to not exceed roi_in */</a>
<a name="ln1841">      iroi_full.x = _max(iroi_full.x, roi_in-&gt;x);</a>
<a name="ln1842">      iroi_full.y = _max(iroi_full.y, roi_in-&gt;y);</a>
<a name="ln1843">      iroi_full.width = _min(iroi_full.width, roi_in-&gt;width + roi_in-&gt;x - iroi_full.x);</a>
<a name="ln1844">      iroi_full.height = _min(iroi_full.height, roi_in-&gt;height + roi_in-&gt;y - iroi_full.y);</a>
<a name="ln1845"> </a>
<a name="ln1846">      //_print_roi(&amp;iroi_full, &quot;tile iroi_full&quot;);</a>
<a name="ln1847">      //_print_roi(&amp;oroi_full, &quot;tile oroi_full&quot;);</a>
<a name="ln1848"> </a>
<a name="ln1849">      /* offsets of tile into ivoid and ovoid */</a>
<a name="ln1850">      size_t ioffs = ((size_t)iroi_full.y - roi_in-&gt;y) * ipitch + ((size_t)iroi_full.x - roi_in-&gt;x) * in_bpp;</a>
<a name="ln1851">      size_t ooffs = ((size_t)oroi_good.y - roi_out-&gt;y) * opitch</a>
<a name="ln1852">                     + ((size_t)oroi_good.x - roi_out-&gt;x) * out_bpp;</a>
<a name="ln1853"> </a>
<a name="ln1854">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1855">               &quot;[default_process_tiling_cl_roi] tile (%zu, %zu) with %d x %d at origin [%d, %d]\n&quot;, tx, ty,</a>
<a name="ln1856">               iroi_full.width, iroi_full.height, iroi_full.x, iroi_full.y);</a>
<a name="ln1857"> </a>
<a name="ln1858">      /* origin and region of full input tile */</a>
<a name="ln1859">      size_t iorigin[] = { 0, 0, 0 };</a>
<a name="ln1860">      size_t iregion[] = { iroi_full.width, iroi_full.height, 1 };</a>
<a name="ln1861"> </a>
<a name="ln1862">      /* origin and region of full output tile */</a>
<a name="ln1863">      size_t oforigin[] = { 0, 0, 0 };</a>
<a name="ln1864">      size_t ofregion[] = { oroi_full.width, oroi_full.height, 1 };</a>
<a name="ln1865"> </a>
<a name="ln1866">      /* origin and region of good part of output tile */</a>
<a name="ln1867">      size_t oorigin[] = { oroi_good.x - oroi_full.x, oroi_good.y - oroi_full.y, 0 };</a>
<a name="ln1868">      size_t oregion[] = { oroi_good.width, oroi_good.height, 1 };</a>
<a name="ln1869"> </a>
<a name="ln1870">      /* get opencl input and output buffers */</a>
<a name="ln1871">      input = dt_opencl_alloc_device(devid, iroi_full.width, iroi_full.height, in_bpp);</a>
<a name="ln1872">      if(input == NULL) goto error;</a>
<a name="ln1873"> </a>
<a name="ln1874">      output = dt_opencl_alloc_device(devid, oroi_full.width, oroi_full.height, out_bpp);</a>
<a name="ln1875">      if(output == NULL) goto error;</a>
<a name="ln1876"> </a>
<a name="ln1877">      if(use_pinned_memory)</a>
<a name="ln1878">      {</a>
<a name="ln1879">/* prepare pinned input tile buffer: copy part of input image */</a>
<a name="ln1880">#ifdef _OPENMP</a>
<a name="ln1881">#pragma omp parallel for default(none) \</a>
<a name="ln1882">        dt_omp_firstprivate(in_bpp, ipitch, ivoid) \</a>
<a name="ln1883">        shared(input_buffer, width, ioffs, iroi_full) schedule(static)</a>
<a name="ln1884">#endif</a>
<a name="ln1885">        for(size_t j = 0; j &lt; iroi_full.height; j++)</a>
<a name="ln1886">          memcpy((char *)input_buffer + j * iroi_full.width * in_bpp, (char *)ivoid + ioffs + j * ipitch,</a>
<a name="ln1887">                 (size_t)iroi_full.width * in_bpp);</a>
<a name="ln1888"> </a>
<a name="ln1889">        /* blocking memory transfer: pinned host input buffer -&gt; opencl/device tile */</a>
<a name="ln1890">        err = dt_opencl_write_host_to_device_raw(devid, (char *)input_buffer, input, iorigin, iregion,</a>
<a name="ln1891">                                                 (size_t)iroi_full.width * in_bpp, CL_TRUE);</a>
<a name="ln1892">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1893">      }</a>
<a name="ln1894">      else</a>
<a name="ln1895">      {</a>
<a name="ln1896">        /* blocking direct memory transfer: host input image -&gt; opencl/device tile */</a>
<a name="ln1897">        err = dt_opencl_write_host_to_device_raw(devid, (char *)ivoid + ioffs, input, iorigin, iregion,</a>
<a name="ln1898">                                                 ipitch, CL_TRUE);</a>
<a name="ln1899">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1900">      }</a>
<a name="ln1901"> </a>
<a name="ln1902">      /* take original processed_maximum as starting point */</a>
<a name="ln1903">      for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_saved[k];</a>
<a name="ln1904"> </a>
<a name="ln1905">      /* call process_cl of module */</a>
<a name="ln1906">      if(!self-&gt;process_cl(self, piece, input, output, &amp;iroi_full, &amp;oroi_full)) goto error;</a>
<a name="ln1907"> </a>
<a name="ln1908">      /* aggregate resulting processed_maximum */</a>
<a name="ln1909">      /* TODO: check if there really can be differences between tiles and take</a>
<a name="ln1910">               appropriate action (calculate minimum, maximum, average, ...?) */</a>
<a name="ln1911">      for(int k = 0; k &lt; 4; k++)</a>
<a name="ln1912">      {</a>
<a name="ln1913">        if(tx + ty &gt; 0 &amp;&amp; fabs(processed_maximum_new[k] - piece-&gt;pipe-&gt;dsc.processed_maximum[k]) &gt; 1.0e-6f)</a>
<a name="ln1914">          dt_print(</a>
<a name="ln1915">              DT_DEBUG_OPENCL,</a>
<a name="ln1916">              &quot;[default_process_tiling_cl_roi] processed_maximum[%d] differs between tiles in module '%s'\n&quot;,</a>
<a name="ln1917">              k, self-&gt;op);</a>
<a name="ln1918">        processed_maximum_new[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln1919">      }</a>
<a name="ln1920"> </a>
<a name="ln1921">      if(use_pinned_memory)</a>
<a name="ln1922">      {</a>
<a name="ln1923">        /* blocking memory transfer: complete opencl/device tile -&gt; pinned host output buffer */</a>
<a name="ln1924">        err = dt_opencl_read_host_from_device_raw(devid, (char *)output_buffer, output, oforigin, ofregion,</a>
<a name="ln1925">                                                  (size_t)oroi_full.width * out_bpp, CL_TRUE);</a>
<a name="ln1926">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1927"> </a>
<a name="ln1928">/* copy &quot;good&quot; part of tile from pinned output buffer to output image */</a>
<a name="ln1929">#ifdef _OPENMP</a>
<a name="ln1930">#pragma omp parallel for default(none) \</a>
<a name="ln1931">        dt_omp_firstprivate(ipitch, opitch, ovoid, out_bpp) \</a>
<a name="ln1932">        shared(ooffs, output_buffer, oroi_full, oorigin, oregion) \</a>
<a name="ln1933">        schedule(static)</a>
<a name="ln1934">#endif</a>
<a name="ln1935">        for(size_t j = 0; j &lt; oregion[1]; j++)</a>
<a name="ln1936">          memcpy((char *)ovoid + ooffs + j * opitch,</a>
<a name="ln1937">                 (char *)output_buffer + ((j + oorigin[1]) * oroi_full.width + oorigin[0]) * out_bpp,</a>
<a name="ln1938">                 (size_t)oregion[0] * out_bpp);</a>
<a name="ln1939">      }</a>
<a name="ln1940">      else</a>
<a name="ln1941">      {</a>
<a name="ln1942">        /* blocking direct memory transfer: good part of opencl/device tile -&gt; host output image */</a>
<a name="ln1943">        err = dt_opencl_read_host_from_device_raw(devid, (char *)ovoid + ooffs, output, oorigin, oregion,</a>
<a name="ln1944">                                                  opitch, CL_TRUE);</a>
<a name="ln1945">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1946">      }</a>
<a name="ln1947"> </a>
<a name="ln1948">      /* release input and output buffers */</a>
<a name="ln1949">      dt_opencl_release_mem_object(input);</a>
<a name="ln1950">      input = NULL;</a>
<a name="ln1951">      dt_opencl_release_mem_object(output);</a>
<a name="ln1952">      output = NULL;</a>
<a name="ln1953"> </a>
<a name="ln1954">      /* block until opencl queue has finished to free all used event handlers */</a>
<a name="ln1955">      if(!darktable.opencl-&gt;async_pixelpipe || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_EXPORT)</a>
<a name="ln1956">        dt_opencl_finish(devid);</a>
<a name="ln1957">    }</a>
<a name="ln1958"> </a>
<a name="ln1959">  /* copy back final processed_maximum */</a>
<a name="ln1960">  for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_new[k];</a>
<a name="ln1961">  if(input_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_input, input_buffer);</a>
<a name="ln1962">  dt_opencl_release_mem_object(pinned_input);</a>
<a name="ln1963">  if(output_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_output, output_buffer);</a>
<a name="ln1964">  dt_opencl_release_mem_object(pinned_output);</a>
<a name="ln1965">  dt_opencl_release_mem_object(input);</a>
<a name="ln1966">  dt_opencl_release_mem_object(output);</a>
<a name="ln1967">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln1968">  return TRUE;</a>
<a name="ln1969"> </a>
<a name="ln1970">error:</a>
<a name="ln1971">  /* copy back stored processed_maximum */</a>
<a name="ln1972">  for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_saved[k];</a>
<a name="ln1973">  if(input_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_input, input_buffer);</a>
<a name="ln1974">  dt_opencl_release_mem_object(pinned_input);</a>
<a name="ln1975">  if(output_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_output, output_buffer);</a>
<a name="ln1976">  dt_opencl_release_mem_object(pinned_output);</a>
<a name="ln1977">  dt_opencl_release_mem_object(input);</a>
<a name="ln1978">  dt_opencl_release_mem_object(output);</a>
<a name="ln1979">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln1980">  dt_print(</a>
<a name="ln1981">      DT_DEBUG_OPENCL,</a>
<a name="ln1982">      &quot;[default_process_tiling_opencl_roi] couldn't run process_cl() for module '%s' in tiling mode: %d\n&quot;,</a>
<a name="ln1983">      self-&gt;op, err);</a>
<a name="ln1984">  return FALSE;</a>
<a name="ln1985">}</a>
<a name="ln1986"> </a>
<a name="ln1987"> </a>
<a name="ln1988"> </a>
<a name="ln1989">/* if a module does not implement process_tiling_cl() by itself, this function is called instead.</a>
<a name="ln1990">   _default_process_tiling_cl_ptp() is able to handle standard cases where pixels do not change their places.</a>
<a name="ln1991">   _default_process_tiling_cl_roi() takes care of all other cases where image gets distorted. */</a>
<a name="ln1992">int default_process_tiling_cl(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1993">                              const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln1994">                              const dt_iop_roi_t *const roi_out, const int in_bpp)</a>
<a name="ln1995">{</a>
<a name="ln1996">  if(memcmp(roi_in, roi_out, sizeof(struct dt_iop_roi_t)) || (self-&gt;flags() &amp; IOP_FLAGS_TILING_FULL_ROI))</a>
<a name="ln1997">    return _default_process_tiling_cl_roi(self, piece, ivoid, ovoid, roi_in, roi_out, in_bpp);</a>
<a name="ln1998">  else</a>
<a name="ln1999">    return _default_process_tiling_cl_ptp(self, piece, ivoid, ovoid, roi_in, roi_out, in_bpp);</a>
<a name="ln2000">}</a>
<a name="ln2001"> </a>
<a name="ln2002">#else</a>
<a name="ln2003">int default_process_tiling_cl(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln2004">                              const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln2005">                              const dt_iop_roi_t *const roi_out, const int in_bpp)</a>
<a name="ln2006">{</a>
<a name="ln2007">  return FALSE;</a>
<a name="ln2008">}</a>
<a name="ln2009">#endif</a>
<a name="ln2010"> </a>
<a name="ln2011"> </a>
<a name="ln2012">/* If a module does not implement tiling_callback() by itself, this function is called instead.</a>
<a name="ln2013">   Default is an image size factor of 2 (i.e. input + output buffer needed), no overhead (1),</a>
<a name="ln2014">   no overlap between tiles, and an pixel alignment of 1 in x and y direction, i.e. no special</a>
<a name="ln2015">   alignment required. Simple pixel to pixel modules (take tonecurve as an example) can happily</a>
<a name="ln2016">   live with that.</a>
<a name="ln2017">   (1) Small overhead like look-up-tables in tonecurve can be ignored safely. */</a>
<a name="ln2018">void default_tiling_callback(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln2019">                             const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out,</a>
<a name="ln2020">                             struct dt_develop_tiling_t *tiling)</a>
<a name="ln2021">{</a>
<a name="ln2022">  const float ioratio</a>
<a name="ln2023">      = ((float)roi_out-&gt;width * (float)roi_out-&gt;height) / ((float)roi_in-&gt;width * (float)roi_in-&gt;height);</a>
<a name="ln2024"> </a>
<a name="ln2025">  tiling-&gt;factor = 1.0f + ioratio;</a>
<a name="ln2026">  tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln2027">  tiling-&gt;overhead = 0;</a>
<a name="ln2028">  tiling-&gt;overlap = 0;</a>
<a name="ln2029">  tiling-&gt;xalign = 1;</a>
<a name="ln2030">  tiling-&gt;yalign = 1;</a>
<a name="ln2031"> </a>
<a name="ln2032">  if((self-&gt;flags() &amp; IOP_FLAGS_TILING_FULL_ROI) == IOP_FLAGS_TILING_FULL_ROI) tiling-&gt;overlap = 4;</a>
<a name="ln2033"> </a>
<a name="ln2034">  if(self-&gt;iop_order &gt; dt_ioppr_get_iop_order(piece-&gt;pipe-&gt;iop_order_list, &quot;demosaic&quot;)) return;</a>
<a name="ln2035"> </a>
<a name="ln2036">  // all operations that work with mosaiced data should respect pattern size!</a>
<a name="ln2037"> </a>
<a name="ln2038">  if(!piece-&gt;pipe-&gt;dsc.filters) return;</a>
<a name="ln2039"> </a>
<a name="ln2040">  if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln2041">  {</a>
<a name="ln2042">    // X-Trans, sensor is 6x6</a>
<a name="ln2043">    tiling-&gt;xalign = 6;</a>
<a name="ln2044">    tiling-&gt;yalign = 6;</a>
<a name="ln2045">  }</a>
<a name="ln2046">  else</a>
<a name="ln2047">  {</a>
<a name="ln2048">    // Bayer, good old 2x2</a>
<a name="ln2049">    tiling-&gt;xalign = 2;</a>
<a name="ln2050">    tiling-&gt;yalign = 2;</a>
<a name="ln2051">  }</a>
<a name="ln2052"> </a>
<a name="ln2053">  return;</a>
<a name="ln2054">}</a>
<a name="ln2055"> </a>
<a name="ln2056">int dt_tiling_piece_fits_host_memory(const size_t width, const size_t height, const unsigned bpp,</a>
<a name="ln2057">                                     const float factor, const size_t overhead)</a>
<a name="ln2058">{</a>
<a name="ln2059">  static int host_memory_limit = -1;</a>
<a name="ln2060"> </a>
<a name="ln2061">  /* first time run */</a>
<a name="ln2062">  if(host_memory_limit &lt; 0)</a>
<a name="ln2063">  {</a>
<a name="ln2064">    host_memory_limit = dt_conf_get_int(&quot;host_memory_limit&quot;);</a>
<a name="ln2065"> </a>
<a name="ln2066">    /* don't let the user play games with us */</a>
<a name="ln2067">    if(host_memory_limit != 0) host_memory_limit = CLAMPI(host_memory_limit, 500, 50000);</a>
<a name="ln2068">    dt_conf_set_int(&quot;host_memory_limit&quot;, host_memory_limit);</a>
<a name="ln2069">  }</a>
<a name="ln2070"> </a>
<a name="ln2071">  float requirement = factor * width * height * bpp + overhead;</a>
<a name="ln2072"> </a>
<a name="ln2073">  if(host_memory_limit == 0 || requirement &lt;= host_memory_limit * 1024.0f * 1024.0f) return TRUE;</a>
<a name="ln2074"> </a>
<a name="ln2075">  return FALSE;</a>
<a name="ln2076">}</a>
<a name="ln2077"> </a>
<a name="ln2078">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2079">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2080">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="215"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'v'. Check lines: 215, 205.</p></div>
<div class="balloon" rel="251"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'f'. Check lines: 251, 206.</p></div>
<div class="balloon" rel="312"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'vm'. Check lines: 312, 210.</p></div>
<div class="balloon" rel="319"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'vr'. Check lines: 319, 207.</p></div>
<div class="balloon" rel="343"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 've'. Check lines: 343, 208.</p></div>
<div class="balloon" rel="383"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'vc'. Check lines: 383, 209.</p></div>
<div class="balloon" rel="377"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v571/" target="_blank">V571</a> Recurring check. The 'fr >= f[vh]' condition was already verified in line 375.</p></div>
<div class="balloon" rel="807"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v767/" target="_blank">V767</a> Suspicious access to element of 'region' array by a constant index inside a loop.</p></div>
<div class="balloon" rel="814"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'input != NULL' is always true.</p></div>
<div class="balloon" rel="815"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'output != NULL' is always true.</p></div>
<div class="balloon" rel="825"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'output != NULL' is always false.</p></div>
<div class="balloon" rel="1497"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v767/" target="_blank">V767</a> Suspicious access to element of 'region' array by a constant index inside a loop.</p></div>
<div class="balloon" rel="1938"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v767/" target="_blank">V767</a> Suspicious access to element of 'oregion' array by a constant index inside a loop.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
