
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/darktable.h&quot;</a>
<a name="ln20">#include &quot;common/debug.h&quot;</a>
<a name="ln21">#include &quot;common/styles.h&quot;</a>
<a name="ln22">#include &quot;common/undo.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;develop/develop.h&quot;</a>
<a name="ln26">#include &quot;develop/masks.h&quot;</a>
<a name="ln27">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln28">#include &quot;gui/gtk.h&quot;</a>
<a name="ln29">#include &quot;gui/styles.h&quot;</a>
<a name="ln30">#include &quot;libs/lib.h&quot;</a>
<a name="ln31">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">DT_MODULE(1)</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">typedef struct dt_undo_history_t</a>
<a name="ln37">{</a>
<a name="ln38">  GList *snapshot;</a>
<a name="ln39">  int end;</a>
<a name="ln40">} dt_undo_history_t;</a>
<a name="ln41"> </a>
<a name="ln42">typedef struct dt_lib_history_t</a>
<a name="ln43">{</a>
<a name="ln44">  /* vbox with managed history items */</a>
<a name="ln45">  GtkWidget *history_box;</a>
<a name="ln46">  GtkWidget *create_button;</a>
<a name="ln47">//   GtkWidget *apply_button;</a>
<a name="ln48">  GtkWidget *compress_button;</a>
<a name="ln49">  gboolean record_undo;</a>
<a name="ln50">} dt_lib_history_t;</a>
<a name="ln51"> </a>
<a name="ln52">/* compress history stack */</a>
<a name="ln53">static void _lib_history_compress_clicked_callback(GtkWidget *widget, gpointer user_data);</a>
<a name="ln54">static void _lib_history_button_clicked_callback(GtkWidget *widget, gpointer user_data);</a>
<a name="ln55">static void _lib_history_create_style_button_clicked_callback(GtkWidget *widget, gpointer user_data);</a>
<a name="ln56">/* signal callback for history change */</a>
<a name="ln57">static void _lib_history_change_callback(gpointer instance, gpointer user_data);</a>
<a name="ln58">static void _lib_history_module_remove_callback(gpointer instance, dt_iop_module_t *module, gpointer user_data);</a>
<a name="ln59"> </a>
<a name="ln60">const char *name(dt_lib_module_t *self)</a>
<a name="ln61">{</a>
<a name="ln62">  return _(&quot;history&quot;);</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65">const char **views(dt_lib_module_t *self)</a>
<a name="ln66">{</a>
<a name="ln67">  static const char *v[] = {&quot;darkroom&quot;, NULL};</a>
<a name="ln68">  return v;</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln72">{</a>
<a name="ln73">  return DT_UI_CONTAINER_PANEL_LEFT_CENTER;</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">int position()</a>
<a name="ln77">{</a>
<a name="ln78">  return 900;</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln82">{</a>
<a name="ln83">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;create style from history&quot;), 0, 0);</a>
<a name="ln84">//   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;apply style from popup menu&quot;), 0, 0);</a>
<a name="ln85">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;compress history stack&quot;), 0, 0);</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln89">{</a>
<a name="ln90">  dt_lib_history_t *d = (dt_lib_history_t *)self-&gt;data;</a>
<a name="ln91"> </a>
<a name="ln92">  dt_accel_connect_button_lib(self, &quot;create style from history&quot;, d-&gt;create_button);</a>
<a name="ln93">//   dt_accel_connect_button_lib(self, &quot;apply style from popup menu&quot;, d-&gt;apply_button);</a>
<a name="ln94">  dt_accel_connect_button_lib(self, &quot;compress history stack&quot;, d-&gt;compress_button);</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">void gui_init(dt_lib_module_t *self)</a>
<a name="ln98">{</a>
<a name="ln99">  /* initialize ui widgets */</a>
<a name="ln100">  dt_lib_history_t *d = (dt_lib_history_t *)g_malloc0(sizeof(dt_lib_history_t));</a>
<a name="ln101">  self-&gt;data = (void *)d;</a>
<a name="ln102"> </a>
<a name="ln103">  d-&gt;record_undo = TRUE;</a>
<a name="ln104"> </a>
<a name="ln105">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln106">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln107">  gtk_widget_set_name(self-&gt;widget, &quot;history-ui&quot;);</a>
<a name="ln108">  d-&gt;history_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln109"> </a>
<a name="ln110">  GtkWidget *hhbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln111"> </a>
<a name="ln112">  d-&gt;compress_button = gtk_button_new_with_label(_(&quot;compress history stack&quot;));</a>
<a name="ln113">  gtk_label_set_xalign (GTK_LABEL(gtk_bin_get_child(GTK_BIN(d-&gt;compress_button))), 0.0f);</a>
<a name="ln114">  gtk_widget_set_tooltip_text(d-&gt;compress_button, _(&quot;create a minimal history stack which produces the same image&quot;));</a>
<a name="ln115">  g_signal_connect(G_OBJECT(d-&gt;compress_button), &quot;clicked&quot;, G_CALLBACK(_lib_history_compress_clicked_callback), NULL);</a>
<a name="ln116"> </a>
<a name="ln117">  /* add toolbar button for creating style */</a>
<a name="ln118">  d-&gt;create_button = dtgtk_button_new(dtgtk_cairo_paint_styles, CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln119">  gtk_widget_set_size_request(d-&gt;create_button, DT_PIXEL_APPLY_DPI(24), -1);</a>
<a name="ln120">  g_signal_connect(G_OBJECT(d-&gt;create_button), &quot;clicked&quot;,</a>
<a name="ln121">                   G_CALLBACK(_lib_history_create_style_button_clicked_callback), NULL);</a>
<a name="ln122">  gtk_widget_set_tooltip_text(d-&gt;create_button, _(&quot;create a style from the current history stack&quot;));</a>
<a name="ln123"> </a>
<a name="ln124">  /* add buttons to buttonbox */</a>
<a name="ln125">  gtk_box_pack_start(GTK_BOX(hhbox), d-&gt;compress_button, TRUE, TRUE, 0);</a>
<a name="ln126">  gtk_box_pack_start(GTK_BOX(hhbox), d-&gt;create_button, FALSE, FALSE, 0);</a>
<a name="ln127"> </a>
<a name="ln128">  /* add history list and buttonbox to widget */</a>
<a name="ln129">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), d-&gt;history_box, FALSE, FALSE, 0);</a>
<a name="ln130">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), hhbox, FALSE, FALSE, 0);</a>
<a name="ln131"> </a>
<a name="ln132"> </a>
<a name="ln133">  gtk_widget_show_all(self-&gt;widget);</a>
<a name="ln134"> </a>
<a name="ln135">  /* connect to history change signal for updating the history view */</a>
<a name="ln136">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE,</a>
<a name="ln137">                            G_CALLBACK(_lib_history_change_callback), self);</a>
<a name="ln138">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_MODULE_REMOVE,</a>
<a name="ln139">                            G_CALLBACK(_lib_history_module_remove_callback), self);</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln143">{</a>
<a name="ln144">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_history_change_callback), self);</a>
<a name="ln145">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_history_module_remove_callback), self);</a>
<a name="ln146">  g_free(self-&gt;data);</a>
<a name="ln147">  self-&gt;data = NULL;</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">static GtkWidget *_lib_history_create_button(dt_lib_module_t *self, int num, const char *label,</a>
<a name="ln151">                                             gboolean enabled, gboolean selected)</a>
<a name="ln152">{</a>
<a name="ln153">  /* create label */</a>
<a name="ln154">  GtkWidget *widget = NULL;</a>
<a name="ln155">  gchar numlabel[256];</a>
<a name="ln156">  if(num == -1)</a>
<a name="ln157">    g_snprintf(numlabel, sizeof(numlabel), &quot;%d - %s&quot;, num + 1, label);</a>
<a name="ln158">  else</a>
<a name="ln159">  {</a>
<a name="ln160">    if(enabled)</a>
<a name="ln161">      g_snprintf(numlabel, sizeof(numlabel), &quot;%d - %s&quot;, num + 1, label);</a>
<a name="ln162">    else</a>
<a name="ln163">      g_snprintf(numlabel, sizeof(numlabel), &quot;%d - %s (%s)&quot;, num + 1, label, _(&quot;off&quot;));</a>
<a name="ln164">  }</a>
<a name="ln165"> </a>
<a name="ln166">  /* create toggle button */</a>
<a name="ln167">  widget = gtk_toggle_button_new_with_label(numlabel);</a>
<a name="ln168">  gtk_widget_set_halign(gtk_bin_get_child(GTK_BIN(widget)), GTK_ALIGN_START);</a>
<a name="ln169">  g_object_set_data(G_OBJECT(widget), &quot;history_number&quot;, GINT_TO_POINTER(num + 1));</a>
<a name="ln170">  g_object_set_data(G_OBJECT(widget), &quot;label&quot;, (gpointer)label);</a>
<a name="ln171">  if(selected) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(widget), TRUE);</a>
<a name="ln172"> </a>
<a name="ln173">  /* set callback when clicked */</a>
<a name="ln174">  g_signal_connect(G_OBJECT(widget), &quot;clicked&quot;, G_CALLBACK(_lib_history_button_clicked_callback), self);</a>
<a name="ln175"> </a>
<a name="ln176">  /* associate the history number */</a>
<a name="ln177">  g_object_set_data(G_OBJECT(widget), &quot;history-number&quot;, GINT_TO_POINTER(num + 1));</a>
<a name="ln178"> </a>
<a name="ln179">  return widget;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">static dt_iop_module_t *get_base_module(GList *iop_list, const char *op)</a>
<a name="ln183">{</a>
<a name="ln184">  dt_iop_module_t *result = NULL;</a>
<a name="ln185"> </a>
<a name="ln186">  GList *modules = g_list_first(iop_list);</a>
<a name="ln187">  while(modules)</a>
<a name="ln188">  {</a>
<a name="ln189">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln190">    if(strcmp(mod-&gt;op, op) == 0)</a>
<a name="ln191">    {</a>
<a name="ln192">      result = mod;</a>
<a name="ln193">      break;</a>
<a name="ln194">    }</a>
<a name="ln195">    modules = g_list_next(modules);</a>
<a name="ln196">  }</a>
<a name="ln197"> </a>
<a name="ln198">  return result;</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">static GList *_duplicate_history(GList *hist)</a>
<a name="ln202">{</a>
<a name="ln203">  GList *result = NULL;</a>
<a name="ln204"> </a>
<a name="ln205">  GList *h = g_list_first(hist);</a>
<a name="ln206">  while(h)</a>
<a name="ln207">  {</a>
<a name="ln208">    const dt_dev_history_item_t *old = (dt_dev_history_item_t *)(h-&gt;data);</a>
<a name="ln209"> </a>
<a name="ln210">    dt_dev_history_item_t *new = (dt_dev_history_item_t *)malloc(sizeof(dt_dev_history_item_t));</a>
<a name="ln211"> </a>
<a name="ln212">    memcpy(new, old, sizeof(dt_dev_history_item_t));</a>
<a name="ln213"> </a>
<a name="ln214">    int32_t params_size = 0;</a>
<a name="ln215">    if(old-&gt;module)</a>
<a name="ln216">    {</a>
<a name="ln217">      params_size = old-&gt;module-&gt;params_size;</a>
<a name="ln218">    }</a>
<a name="ln219">    else</a>
<a name="ln220">    {</a>
<a name="ln221">      dt_iop_module_t *base = get_base_module(darktable.develop-&gt;iop, old-&gt;op_name);</a>
<a name="ln222">      if(base)</a>
<a name="ln223">      {</a>
<a name="ln224">        params_size = base-&gt;params_size;</a>
<a name="ln225">      }</a>
<a name="ln226">      else</a>
<a name="ln227">      {</a>
<a name="ln228">        // nothing else to do</a>
<a name="ln229">        fprintf(stderr, &quot;[_duplicate_history] can't find base module for %s\n&quot;, old-&gt;op_name);</a>
<a name="ln230">      }</a>
<a name="ln231">    }</a>
<a name="ln232"> </a>
<a name="ln233">    new-&gt;params = malloc(params_size);</a>
<a name="ln234">    new-&gt;blend_params = malloc(sizeof(dt_develop_blend_params_t));</a>
<a name="ln235"> </a>
<a name="ln236">    memcpy(new-&gt;params, old-&gt;params, params_size);</a>
<a name="ln237">    memcpy(new-&gt;blend_params, old-&gt;blend_params, sizeof(dt_develop_blend_params_t));</a>
<a name="ln238"> </a>
<a name="ln239">    if(old-&gt;forms) new-&gt;forms = dt_masks_dup_forms_deep(old-&gt;forms, NULL);</a>
<a name="ln240"> </a>
<a name="ln241">    result = g_list_append(result, new);</a>
<a name="ln242"> </a>
<a name="ln243">    h = g_list_next(h);</a>
<a name="ln244">  }</a>
<a name="ln245">  return result;</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">static void _reset_module_instance(GList *hist, dt_iop_module_t *module, int multi_priority)</a>
<a name="ln249">{</a>
<a name="ln250">  while (hist)</a>
<a name="ln251">  {</a>
<a name="ln252">    dt_dev_history_item_t *hit = (dt_dev_history_item_t *)hist-&gt;data;</a>
<a name="ln253"> </a>
<a name="ln254">    if(!hit-&gt;module &amp;&amp; strcmp(hit-&gt;op_name, module-&gt;op) == 0 &amp;&amp; hit-&gt;multi_priority == multi_priority)</a>
<a name="ln255">    {</a>
<a name="ln256">      hit-&gt;module = module;</a>
<a name="ln257">    }</a>
<a name="ln258">    hist = hist-&gt;next;</a>
<a name="ln259">  }</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">struct _cb_data</a>
<a name="ln263">{</a>
<a name="ln264">  dt_iop_module_t *module;</a>
<a name="ln265">  int multi_priority;</a>
<a name="ln266">};</a>
<a name="ln267"> </a>
<a name="ln268">static void _undo_items_cb(gpointer user_data, dt_undo_type_t type, dt_undo_data_t *data)</a>
<a name="ln269">{</a>
<a name="ln270">  struct _cb_data *udata = (struct _cb_data *)user_data;</a>
<a name="ln271">  dt_undo_history_t *hdata = (dt_undo_history_t *)data;</a>
<a name="ln272">  _reset_module_instance(hdata-&gt;snapshot, udata-&gt;module, udata-&gt;multi_priority);</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">static void _history_invalidate_cb(gpointer user_data, dt_undo_type_t type, dt_undo_data_t *item)</a>
<a name="ln276">{</a>
<a name="ln277">  dt_iop_module_t *module = (dt_iop_module_t *)user_data;</a>
<a name="ln278">  dt_undo_history_t *hist = (dt_undo_history_t *)item;</a>
<a name="ln279">  dt_dev_invalidate_history_module(hist-&gt;snapshot, module);</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">static void _add_module_expander(GList *iop_list, dt_iop_module_t *module)</a>
<a name="ln283">{</a>
<a name="ln284">  // dt_dev_reload_history_items won't do this for base instances</a>
<a name="ln285">  // and it will call gui_init() for the rest</a>
<a name="ln286">  // so we do it here</a>
<a name="ln287">  if(!dt_iop_is_hidden(module) &amp;&amp; !module-&gt;expander)</a>
<a name="ln288">  {</a>
<a name="ln289">      /* add module to right panel */</a>
<a name="ln290">      GtkWidget *expander = dt_iop_gui_get_expander(module);</a>
<a name="ln291">      dt_ui_container_add_widget(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER, expander);</a>
<a name="ln292">      dt_iop_gui_set_expanded(module, TRUE, FALSE);</a>
<a name="ln293">      dt_iop_gui_update_blending(module);</a>
<a name="ln294">  }</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">// return the 1st history entry that matches module</a>
<a name="ln298">static dt_dev_history_item_t *_search_history_by_module(GList *history_list, dt_iop_module_t *module)</a>
<a name="ln299">{</a>
<a name="ln300">  dt_dev_history_item_t *hist_ret = NULL;</a>
<a name="ln301"> </a>
<a name="ln302">  GList *history = g_list_first(history_list);</a>
<a name="ln303">  while(history)</a>
<a name="ln304">  {</a>
<a name="ln305">    dt_dev_history_item_t *hist_item = (dt_dev_history_item_t *)history-&gt;data;</a>
<a name="ln306"> </a>
<a name="ln307">    if(hist_item-&gt;module == module)</a>
<a name="ln308">    {</a>
<a name="ln309">      hist_ret = hist_item;</a>
<a name="ln310">      break;</a>
<a name="ln311">    }</a>
<a name="ln312"> </a>
<a name="ln313">    history = g_list_next(history);</a>
<a name="ln314">  }</a>
<a name="ln315">  return hist_ret;</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">static int _check_deleted_instances(dt_develop_t *dev, GList **_iop_list, GList *history_list)</a>
<a name="ln319">{</a>
<a name="ln320">  GList *iop_list = *_iop_list;</a>
<a name="ln321">  int deleted_module_found = 0;</a>
<a name="ln322"> </a>
<a name="ln323">  // we will check on dev-&gt;iop if there's a module that is not in history</a>
<a name="ln324">  GList *modules = g_list_first(iop_list);</a>
<a name="ln325">  while(modules)</a>
<a name="ln326">  {</a>
<a name="ln327">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln328"> </a>
<a name="ln329">    int delete_module = 0;</a>
<a name="ln330"> </a>
<a name="ln331">    // base modules are a special case</a>
<a name="ln332">    // most base modules won't be in history and must not be deleted</a>
<a name="ln333">    // but the user may have deleted a base instance of a multi-instance module</a>
<a name="ln334">    // and then undo and redo, so we will end up with two entries in dev-&gt;iop</a>
<a name="ln335">    // with multi_priority == 0, this can't happen and the extra one must be deleted</a>
<a name="ln336">    // dev-&gt;iop is sorted by (priority, multi_priority DESC), so if the next one is</a>
<a name="ln337">    // a base instance too, one must be deleted</a>
<a name="ln338">    if(mod-&gt;multi_priority == 0)</a>
<a name="ln339">    {</a>
<a name="ln340">      GList *modules_next = g_list_next(modules);</a>
<a name="ln341">      if(modules_next)</a>
<a name="ln342">      {</a>
<a name="ln343">        dt_iop_module_t *mod_next = (dt_iop_module_t *)modules_next-&gt;data;</a>
<a name="ln344">        if(strcmp(mod_next-&gt;op, mod-&gt;op) == 0 &amp;&amp; mod_next-&gt;multi_priority == 0)</a>
<a name="ln345">        {</a>
<a name="ln346">          // is the same one, check which one must be deleted</a>
<a name="ln347">          const int mod_in_history = (_search_history_by_module(history_list, mod) != NULL);</a>
<a name="ln348">          const int mod_next_in_history = (_search_history_by_module(history_list, mod_next) != NULL);</a>
<a name="ln349"> </a>
<a name="ln350">          // current is in history and next is not, delete next</a>
<a name="ln351">          if(mod_in_history &amp;&amp; !mod_next_in_history)</a>
<a name="ln352">          {</a>
<a name="ln353">            mod = mod_next;</a>
<a name="ln354">            modules = modules_next;</a>
<a name="ln355">            delete_module = 1;</a>
<a name="ln356">          }</a>
<a name="ln357">          // current is not in history and next is, delete current</a>
<a name="ln358">          else if(!mod_in_history &amp;&amp; mod_next_in_history)</a>
<a name="ln359">          {</a>
<a name="ln360">            delete_module = 1;</a>
<a name="ln361">          }</a>
<a name="ln362">          else</a>
<a name="ln363">          {</a>
<a name="ln364">            if(mod_in_history &amp;&amp; mod_next_in_history)</a>
<a name="ln365">              fprintf(</a>
<a name="ln366">                  stderr,</a>
<a name="ln367">                  &quot;[_check_deleted_instances] found duplicate module %s %s (%i) and %s %s (%i) both in history\n&quot;,</a>
<a name="ln368">                  mod-&gt;op, mod-&gt;multi_name, mod-&gt;multi_priority, mod_next-&gt;op, mod_next-&gt;multi_name,</a>
<a name="ln369">                  mod_next-&gt;multi_priority);</a>
<a name="ln370">            else</a>
<a name="ln371">              fprintf(</a>
<a name="ln372">                  stderr,</a>
<a name="ln373">                  &quot;[_check_deleted_instances] found duplicate module %s %s (%i) and %s %s (%i) none in history\n&quot;,</a>
<a name="ln374">                  mod-&gt;op, mod-&gt;multi_name, mod-&gt;multi_priority, mod_next-&gt;op, mod_next-&gt;multi_name,</a>
<a name="ln375">                  mod_next-&gt;multi_priority);</a>
<a name="ln376">          }</a>
<a name="ln377">        }</a>
<a name="ln378">      }</a>
<a name="ln379">    }</a>
<a name="ln380">    // this is a regular multi-instance and must be in history</a>
<a name="ln381">    else</a>
<a name="ln382">    {</a>
<a name="ln383">      delete_module = (_search_history_by_module(history_list, mod) == NULL);</a>
<a name="ln384">    }</a>
<a name="ln385"> </a>
<a name="ln386">    // if module is not in history we delete it</a>
<a name="ln387">    if(delete_module)</a>
<a name="ln388">    {</a>
<a name="ln389">      deleted_module_found = 1;</a>
<a name="ln390"> </a>
<a name="ln391">      if(darktable.develop-&gt;gui_module == mod) dt_iop_request_focus(NULL);</a>
<a name="ln392"> </a>
<a name="ln393">      const int reset = darktable.gui-&gt;reset;</a>
<a name="ln394">      darktable.gui-&gt;reset = 1;</a>
<a name="ln395"> </a>
<a name="ln396">      // we remove the plugin effectively</a>
<a name="ln397">      if(!dt_iop_is_hidden(mod))</a>
<a name="ln398">      {</a>
<a name="ln399">        // we just hide the module to avoid lots of gtk critical warnings</a>
<a name="ln400">        gtk_widget_hide(mod-&gt;expander);</a>
<a name="ln401"> </a>
<a name="ln402">        // this is copied from dt_iop_gui_delete_callback(), not sure why the above sentence...</a>
<a name="ln403">        gtk_widget_destroy(mod-&gt;widget);</a>
<a name="ln404">        dt_iop_gui_cleanup_module(mod);</a>
<a name="ln405">      }</a>
<a name="ln406"> </a>
<a name="ln407">      iop_list = g_list_remove_link(iop_list, modules);</a>
<a name="ln408"> </a>
<a name="ln409">      // remove it from all snapshots</a>
<a name="ln410">      dt_undo_iterate_internal(darktable.undo, DT_UNDO_HISTORY, mod, &amp;_history_invalidate_cb);</a>
<a name="ln411"> </a>
<a name="ln412">      // we cleanup the module</a>
<a name="ln413">      dt_accel_disconnect_list(mod-&gt;accel_closures);</a>
<a name="ln414">      dt_accel_cleanup_locals_iop(mod);</a>
<a name="ln415">      mod-&gt;accel_closures = NULL;</a>
<a name="ln416">      // don't delete the module, a pipe may still need it</a>
<a name="ln417">      dev-&gt;alliop = g_list_append(dev-&gt;alliop, mod);</a>
<a name="ln418"> </a>
<a name="ln419">      darktable.gui-&gt;reset = reset;</a>
<a name="ln420"> </a>
<a name="ln421">      // and reset the list</a>
<a name="ln422">      modules = g_list_first(iop_list);</a>
<a name="ln423">      continue;</a>
<a name="ln424">    }</a>
<a name="ln425"> </a>
<a name="ln426">    modules = g_list_next(modules);</a>
<a name="ln427">  }</a>
<a name="ln428">  if(deleted_module_found) iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln429"> </a>
<a name="ln430">  *_iop_list = iop_list;</a>
<a name="ln431"> </a>
<a name="ln432">  return deleted_module_found;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">static void _reorder_gui_module_list(dt_develop_t *dev)</a>
<a name="ln436">{</a>
<a name="ln437">  int pos_module = 0;</a>
<a name="ln438">  GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln439">  while(modules)</a>
<a name="ln440">  {</a>
<a name="ln441">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln442"> </a>
<a name="ln443">    GtkWidget *expander = module-&gt;expander;</a>
<a name="ln444">    if(expander)</a>
<a name="ln445">    {</a>
<a name="ln446">      gtk_box_reorder_child(dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER), expander,</a>
<a name="ln447">                            pos_module++);</a>
<a name="ln448">    }</a>
<a name="ln449"> </a>
<a name="ln450">    modules = g_list_previous(modules);</a>
<a name="ln451">  }</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">static int _rebuild_multi_priority(GList *history_list)</a>
<a name="ln455">{</a>
<a name="ln456">  int changed = 0;</a>
<a name="ln457">  GList *history = g_list_first(history_list);</a>
<a name="ln458">  while(history)</a>
<a name="ln459">  {</a>
<a name="ln460">    dt_dev_history_item_t *hitem = (dt_dev_history_item_t *)history-&gt;data;</a>
<a name="ln461"> </a>
<a name="ln462">    // if multi_priority is different in history and dev-&gt;iop</a>
<a name="ln463">    // we keep the history version</a>
<a name="ln464">    if(hitem-&gt;module &amp;&amp; hitem-&gt;module-&gt;multi_priority != hitem-&gt;multi_priority)</a>
<a name="ln465">    {</a>
<a name="ln466">      dt_iop_update_multi_priority(hitem-&gt;module, hitem-&gt;multi_priority);</a>
<a name="ln467">      changed = 1;</a>
<a name="ln468">    }</a>
<a name="ln469"> </a>
<a name="ln470">    history = g_list_next(history);</a>
<a name="ln471">  }</a>
<a name="ln472">  return changed;</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">static int _create_deleted_modules(GList **_iop_list, GList *history_list)</a>
<a name="ln476">{</a>
<a name="ln477">  GList *iop_list = *_iop_list;</a>
<a name="ln478">  int changed = 0;</a>
<a name="ln479">  gboolean done = FALSE;</a>
<a name="ln480"> </a>
<a name="ln481">  GList *l = g_list_first(history_list);</a>
<a name="ln482">  while(l)</a>
<a name="ln483">  {</a>
<a name="ln484">    GList *next = g_list_next(l);</a>
<a name="ln485">    dt_dev_history_item_t *hitem = (dt_dev_history_item_t *)l-&gt;data;</a>
<a name="ln486"> </a>
<a name="ln487">    // this fixes the duplicate module when undo: hitem-&gt;multi_priority = 0;</a>
<a name="ln488">    if(hitem-&gt;module == NULL)</a>
<a name="ln489">    {</a>
<a name="ln490">      changed = 1;</a>
<a name="ln491"> </a>
<a name="ln492">      const dt_iop_module_t *base_module = get_base_module(iop_list, hitem-&gt;op_name);</a>
<a name="ln493">      if(base_module == NULL)</a>
<a name="ln494">      {</a>
<a name="ln495">        fprintf(stderr, &quot;[_create_deleted_modules] can't find base module for %s\n&quot;, hitem-&gt;op_name);</a>
<a name="ln496">        return changed;</a>
<a name="ln497">      }</a>
<a name="ln498"> </a>
<a name="ln499">      // from there we create a new module for this base instance. The goal is to do a very minimal setup of the</a>
<a name="ln500">      // new module to be able to write the history items. From there we reload the whole history back and this</a>
<a name="ln501">      // will recreate the proper module instances.</a>
<a name="ln502">      dt_iop_module_t *module = (dt_iop_module_t *)calloc(1, sizeof(dt_iop_module_t));</a>
<a name="ln503">      if(dt_iop_load_module(module, base_module-&gt;so, base_module-&gt;dev))</a>
<a name="ln504">      {</a>
<a name="ln505">        return changed;</a>
<a name="ln506">      }</a>
<a name="ln507">      module-&gt;instance = base_module-&gt;instance;</a>
<a name="ln508"> </a>
<a name="ln509">      if(!dt_iop_is_hidden(module))</a>
<a name="ln510">      {</a>
<a name="ln511">        module-&gt;gui_init(module);</a>
<a name="ln512">      }</a>
<a name="ln513"> </a>
<a name="ln514">      // adjust the multi_name of the new module</a>
<a name="ln515">      g_strlcpy(module-&gt;multi_name, hitem-&gt;multi_name, sizeof(module-&gt;multi_name));</a>
<a name="ln516">      dt_iop_update_multi_priority(module, hitem-&gt;multi_priority);</a>
<a name="ln517">      module-&gt;iop_order = hitem-&gt;iop_order;</a>
<a name="ln518"> </a>
<a name="ln519">      // we insert this module into dev-&gt;iop</a>
<a name="ln520">      iop_list = g_list_insert_sorted(iop_list, module, dt_sort_iop_by_order);</a>
<a name="ln521"> </a>
<a name="ln522">      // add the expander, dt_dev_reload_history_items() don't work well without one</a>
<a name="ln523">      _add_module_expander(iop_list, module);</a>
<a name="ln524"> </a>
<a name="ln525">      // if not already done, set the module to all others same instance</a>
<a name="ln526">      if(!done)</a>
<a name="ln527">      {</a>
<a name="ln528">        _reset_module_instance(history_list, module, hitem-&gt;multi_priority);</a>
<a name="ln529"> </a>
<a name="ln530">        // and do that also in the undo/redo lists</a>
<a name="ln531">        struct _cb_data udata = { module, hitem-&gt;multi_priority };</a>
<a name="ln532">        dt_undo_iterate_internal(darktable.undo, DT_UNDO_HISTORY, &amp;udata, &amp;_undo_items_cb);</a>
<a name="ln533">        done = TRUE;</a>
<a name="ln534">      }</a>
<a name="ln535"> </a>
<a name="ln536">      hitem-&gt;module = module;</a>
<a name="ln537">    }</a>
<a name="ln538">    l = next;</a>
<a name="ln539">  }</a>
<a name="ln540"> </a>
<a name="ln541">  *_iop_list = iop_list;</a>
<a name="ln542"> </a>
<a name="ln543">  return changed;</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">static void _pop_undo(gpointer user_data, dt_undo_type_t type, dt_undo_data_t *data, dt_undo_action_t action)</a>
<a name="ln547">{</a>
<a name="ln548">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln549"> </a>
<a name="ln550">  if(type == DT_UNDO_HISTORY)</a>
<a name="ln551">  {</a>
<a name="ln552">    dt_lib_history_t *d = (dt_lib_history_t *)self-&gt;data;</a>
<a name="ln553">    dt_undo_history_t *hist = (dt_undo_history_t *)data;</a>
<a name="ln554">    dt_develop_t *dev = darktable.develop;</a>
<a name="ln555"> </a>
<a name="ln556">    // we will work on a copy of history and modules</a>
<a name="ln557">    // when we're done we'll replace dev-&gt;history and dev-&gt;iop</a>
<a name="ln558">    GList *history_temp = _duplicate_history(hist-&gt;snapshot);</a>
<a name="ln559">    const int hist_end = hist-&gt;end;</a>
<a name="ln560">    GList *iop_temp = g_list_copy(dev-&gt;iop);</a>
<a name="ln561"> </a>
<a name="ln562">    // topology has changed?</a>
<a name="ln563">    int pipe_remove = 0;</a>
<a name="ln564"> </a>
<a name="ln565">    // we have to check if multi_priority has changed since history was saved</a>
<a name="ln566">    // we will adjust it here</a>
<a name="ln567">    if(_rebuild_multi_priority(history_temp))</a>
<a name="ln568">    {</a>
<a name="ln569">      pipe_remove = 1;</a>
<a name="ln570">      iop_temp = g_list_sort(iop_temp, dt_sort_iop_by_order);</a>
<a name="ln571">    }</a>
<a name="ln572"> </a>
<a name="ln573">    // check if this undo a delete module and re-create it</a>
<a name="ln574">    if(_create_deleted_modules(&amp;iop_temp, history_temp))</a>
<a name="ln575">    {</a>
<a name="ln576">      pipe_remove = 1;</a>
<a name="ln577">    }</a>
<a name="ln578"> </a>
<a name="ln579">    // check if this is a redo of a delete module or an undo of an add module</a>
<a name="ln580">    if(_check_deleted_instances(dev, &amp;iop_temp, history_temp))</a>
<a name="ln581">    {</a>
<a name="ln582">      pipe_remove = 1;</a>
<a name="ln583">    }</a>
<a name="ln584"> </a>
<a name="ln585">    // disable recording undo as the _lib_history_change_callback will be triggered by the calls below</a>
<a name="ln586">    d-&gt;record_undo = FALSE;</a>
<a name="ln587"> </a>
<a name="ln588">    dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln589"> </a>
<a name="ln590">    // set history and modules to dev</a>
<a name="ln591">    GList *history_temp2 = dev-&gt;history;</a>
<a name="ln592">    dev-&gt;history = history_temp;</a>
<a name="ln593">    dev-&gt;history_end = hist_end;</a>
<a name="ln594">    g_list_free_full(history_temp2, dt_dev_free_history_item);</a>
<a name="ln595">    GList *iop_temp2 = dev-&gt;iop;</a>
<a name="ln596">    dev-&gt;iop = iop_temp;</a>
<a name="ln597">    g_list_free(iop_temp2);</a>
<a name="ln598"> </a>
<a name="ln599">    // topology has changed</a>
<a name="ln600">    if(pipe_remove)</a>
<a name="ln601">    {</a>
<a name="ln602">      // we refresh the pipe</a>
<a name="ln603">      dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln604">      dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln605">      dev-&gt;pipe-&gt;cache_obsolete = 1;</a>
<a name="ln606">      dev-&gt;preview_pipe-&gt;cache_obsolete = 1;</a>
<a name="ln607"> </a>
<a name="ln608">      // invalidate buffers and force redraw of darkroom</a>
<a name="ln609">      dt_dev_invalidate_all(dev);</a>
<a name="ln610">    }</a>
<a name="ln611"> </a>
<a name="ln612">    dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln613"> </a>
<a name="ln614">    // if dev-&gt;iop has changed reflect that on module list</a>
<a name="ln615">    if(pipe_remove) _reorder_gui_module_list(dev);</a>
<a name="ln616"> </a>
<a name="ln617">    // write new history and reload</a>
<a name="ln618">    dt_dev_write_history(dev);</a>
<a name="ln619">    dt_dev_reload_history_items(dev);</a>
<a name="ln620"> </a>
<a name="ln621">    dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln622">  }</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">static void _history_undo_data_free(gpointer data)</a>
<a name="ln626">{</a>
<a name="ln627">  dt_undo_history_t *hist = (dt_undo_history_t *)data;</a>
<a name="ln628">  GList *snapshot = hist-&gt;snapshot;</a>
<a name="ln629">  g_list_free_full(snapshot, dt_dev_free_history_item);</a>
<a name="ln630">  free(data);</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">static void _lib_history_module_remove_callback(gpointer instance, dt_iop_module_t *module, gpointer user_data)</a>
<a name="ln634">{</a>
<a name="ln635">  dt_undo_iterate(darktable.undo, DT_UNDO_HISTORY, module, &amp;_history_invalidate_cb);</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">static void _lib_history_change_callback(gpointer instance, gpointer user_data)</a>
<a name="ln639">{</a>
<a name="ln640">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln641">  dt_lib_history_t *d = (dt_lib_history_t *)self-&gt;data;</a>
<a name="ln642"> </a>
<a name="ln643">  /* first destroy all buttons in list */</a>
<a name="ln644">  gtk_container_foreach(GTK_CONTAINER(d-&gt;history_box), (GtkCallback)gtk_widget_destroy, 0);</a>
<a name="ln645"> </a>
<a name="ln646">  /* add default which always should be */</a>
<a name="ln647">  int num = -1;</a>
<a name="ln648">  gtk_box_pack_start(GTK_BOX(d-&gt;history_box),</a>
<a name="ln649">                     _lib_history_create_button(self, num, _(&quot;original&quot;), FALSE, darktable.develop-&gt;history_end == 0),</a>
<a name="ln650">                     TRUE, TRUE, 0);</a>
<a name="ln651">  num++;</a>
<a name="ln652"> </a>
<a name="ln653">  if (d-&gt;record_undo == TRUE)</a>
<a name="ln654">  {</a>
<a name="ln655">    /* record undo/redo history snapshot */</a>
<a name="ln656">    dt_undo_history_t *hist = malloc(sizeof(dt_undo_history_t));</a>
<a name="ln657">    hist-&gt;snapshot = _duplicate_history(darktable.develop-&gt;history);</a>
<a name="ln658">    hist-&gt;end = darktable.develop-&gt;history_end;</a>
<a name="ln659"> </a>
<a name="ln660">    dt_undo_record(darktable.undo, self, DT_UNDO_HISTORY, (dt_undo_data_t *)hist,</a>
<a name="ln661">                   _pop_undo, _history_undo_data_free);</a>
<a name="ln662">  }</a>
<a name="ln663">  else</a>
<a name="ln664">    d-&gt;record_undo = TRUE;</a>
<a name="ln665"> </a>
<a name="ln666">  /* lock history mutex */</a>
<a name="ln667">  dt_pthread_mutex_lock(&amp;darktable.develop-&gt;history_mutex);</a>
<a name="ln668"> </a>
<a name="ln669">  /* iterate over history items and add them to list*/</a>
<a name="ln670">  GList *history = g_list_first(darktable.develop-&gt;history);</a>
<a name="ln671">  while(history)</a>
<a name="ln672">  {</a>
<a name="ln673">    dt_dev_history_item_t *hitem = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln674"> </a>
<a name="ln675">    gchar *label;</a>
<a name="ln676">    if(!hitem-&gt;multi_name[0] || strcmp(hitem-&gt;multi_name, &quot;0&quot;) == 0)</a>
<a name="ln677">      label = g_strdup_printf(&quot;%s&quot;, hitem-&gt;module-&gt;name());</a>
<a name="ln678">    else</a>
<a name="ln679">      label = g_strdup_printf(&quot;%s %s&quot;, hitem-&gt;module-&gt;name(), hitem-&gt;multi_name);</a>
<a name="ln680"> </a>
<a name="ln681">    gboolean selected = (num == darktable.develop-&gt;history_end - 1);</a>
<a name="ln682">    GtkWidget *widget = _lib_history_create_button(self, num, label, (hitem-&gt;enabled || (strcmp(hitem-&gt;op_name, &quot;mask_manager&quot;) == 0)), selected);</a>
<a name="ln683">    g_free(label);</a>
<a name="ln684"> </a>
<a name="ln685">    gtk_box_pack_start(GTK_BOX(d-&gt;history_box), widget, TRUE, TRUE, 0);</a>
<a name="ln686">    gtk_box_reorder_child(GTK_BOX(d-&gt;history_box), widget, 0);</a>
<a name="ln687">    num++;</a>
<a name="ln688"> </a>
<a name="ln689">    history = g_list_next(history);</a>
<a name="ln690">  }</a>
<a name="ln691"> </a>
<a name="ln692">  /* show all widgets */</a>
<a name="ln693">  gtk_widget_show_all(d-&gt;history_box);</a>
<a name="ln694"> </a>
<a name="ln695">  dt_pthread_mutex_unlock(&amp;darktable.develop-&gt;history_mutex);</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">static void _lib_history_compress_clicked_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln699">{</a>
<a name="ln700">  const int imgid = darktable.develop-&gt;image_storage.id;</a>
<a name="ln701">  if(!imgid) return;</a>
<a name="ln702">  // make sure the right history is in there:</a>
<a name="ln703">  dt_dev_write_history(darktable.develop);</a>
<a name="ln704">  sqlite3_stmt *stmt;</a>
<a name="ln705"> </a>
<a name="ln706">  // compress history</a>
<a name="ln707">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1 AND num &quot;</a>
<a name="ln708">                                                             &quot;NOT IN (SELECT MAX(num) FROM main.history WHERE &quot;</a>
<a name="ln709">                                                             &quot;imgid = ?1 AND num &lt; ?2 GROUP BY operation, &quot;</a>
<a name="ln710">                                                             &quot;multi_priority)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln711">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln712">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, darktable.develop-&gt;history_end);</a>
<a name="ln713">  sqlite3_step(stmt);</a>
<a name="ln714">  sqlite3_finalize(stmt);</a>
<a name="ln715"> </a>
<a name="ln716">  // delete all mask_manager entries</a>
<a name="ln717">  int masks_count = 0;</a>
<a name="ln718">  char op_mask_manager[20] = {0};</a>
<a name="ln719">  g_strlcpy(op_mask_manager, &quot;mask_manager&quot;, sizeof(op_mask_manager));</a>
<a name="ln720"> </a>
<a name="ln721">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1 AND operation = ?2&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln722">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln723">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, op_mask_manager, -1, SQLITE_TRANSIENT);</a>
<a name="ln724">  sqlite3_step(stmt);</a>
<a name="ln725">  sqlite3_finalize(stmt);</a>
<a name="ln726"> </a>
<a name="ln727">  // compress masks history</a>
<a name="ln728">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.masks_history WHERE imgid = ?1 AND num &quot;</a>
<a name="ln729">                                                             &quot;NOT IN (SELECT MAX(num) FROM main.masks_history WHERE &quot;</a>
<a name="ln730">                                                             &quot;imgid = ?1 AND num &lt; ?2)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln731">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln732">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, darktable.develop-&gt;history_end);</a>
<a name="ln733">  sqlite3_step(stmt);</a>
<a name="ln734">  sqlite3_finalize(stmt);</a>
<a name="ln735"> </a>
<a name="ln736">  // if there's masks create a mask manage entry</a>
<a name="ln737">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln738">                              &quot;SELECT COUNT(*) FROM main.masks_history WHERE imgid = ?1&quot;,</a>
<a name="ln739">                              -1, &amp;stmt, NULL);</a>
<a name="ln740">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln741">  if(sqlite3_step(stmt) == SQLITE_ROW) masks_count = sqlite3_column_int(stmt, 0);</a>
<a name="ln742">  sqlite3_finalize(stmt);</a>
<a name="ln743"> </a>
<a name="ln744">  if(masks_count &gt; 0)</a>
<a name="ln745">  {</a>
<a name="ln746">    // set the masks history as first entry</a>
<a name="ln747">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;UPDATE main.masks_history SET num = 0 WHERE imgid = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln748">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln749">    sqlite3_step(stmt);</a>
<a name="ln750">    sqlite3_finalize(stmt);</a>
<a name="ln751"> </a>
<a name="ln752">    // make room for mask manager history entry</a>
<a name="ln753">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;UPDATE main.history SET num=num+1 WHERE imgid = ?1&quot;,</a>
<a name="ln754">        -1, &amp;stmt, NULL);</a>
<a name="ln755">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln756">    sqlite3_step(stmt);</a>
<a name="ln757">    sqlite3_finalize(stmt);</a>
<a name="ln758"> </a>
<a name="ln759">    // update history end</a>
<a name="ln760">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;UPDATE main.images SET history_end = history_end+1 WHERE id = ?1&quot;,</a>
<a name="ln761">        -1, &amp;stmt, NULL);</a>
<a name="ln762">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln763">    sqlite3_step(stmt);</a>
<a name="ln764">    sqlite3_finalize(stmt);</a>
<a name="ln765"> </a>
<a name="ln766">    const double iop_order = dt_ioppr_get_iop_order(darktable.develop-&gt;iop_order_list, op_mask_manager);</a>
<a name="ln767"> </a>
<a name="ln768">    // create a mask manager entry in history as first entry</a>
<a name="ln769">    DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln770">        dt_database_get(darktable.db),</a>
<a name="ln771">        &quot;INSERT INTO main.history (imgid, num, operation, op_params, module, enabled, &quot;</a>
<a name="ln772">             &quot;blendop_params, blendop_version, multi_priority, multi_name, iop_order) &quot;</a>
<a name="ln773">        &quot;VALUES(?1, 0, ?2, NULL, 1, 0, NULL, 0, 0, '', ?3)&quot;,</a>
<a name="ln774">        -1, &amp;stmt, NULL);</a>
<a name="ln775">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln776">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, op_mask_manager, -1, SQLITE_TRANSIENT);</a>
<a name="ln777">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 3, iop_order);</a>
<a name="ln778">    sqlite3_step(stmt);</a>
<a name="ln779">    sqlite3_finalize(stmt);</a>
<a name="ln780"> </a>
<a name="ln781">  }</a>
<a name="ln782"> </a>
<a name="ln783">  // load new history and write it back to ensure that all history are properly numbered without a gap</a>
<a name="ln784">  dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln785">  dt_dev_write_history(darktable.develop);</a>
<a name="ln786"> </a>
<a name="ln787">  // then we can get the item to select in the new clean-up history retrieve the position of the module</a>
<a name="ln788">  // corresponding to the history end.</a>
<a name="ln789">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT IFNULL(MAX(num)+1, 0) FROM main.history &quot;</a>
<a name="ln790">                                                             &quot;WHERE imgid=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln791">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln792"> </a>
<a name="ln793">  if (sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln794">    darktable.develop-&gt;history_end = sqlite3_column_int(stmt, 0);</a>
<a name="ln795">  sqlite3_finalize(stmt);</a>
<a name="ln796"> </a>
<a name="ln797">  // select the new history end corresponding to the one before the history compression</a>
<a name="ln798">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;UPDATE main.images SET history_end=?2 WHERE id=?1&quot;,</a>
<a name="ln799">                              -1, &amp;stmt, NULL);</a>
<a name="ln800">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln801">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, darktable.develop-&gt;history_end);</a>
<a name="ln802">  sqlite3_step(stmt);</a>
<a name="ln803">  sqlite3_finalize(stmt);</a>
<a name="ln804"> </a>
<a name="ln805">  dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln806">  dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809">static void _lib_history_button_clicked_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln810">{</a>
<a name="ln811">  static int reset = 0;</a>
<a name="ln812">  if(reset) return;</a>
<a name="ln813">  if(!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) return;</a>
<a name="ln814"> </a>
<a name="ln815">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln816">  dt_lib_history_t *d = (dt_lib_history_t *)self-&gt;data;</a>
<a name="ln817">  reset = 1;</a>
<a name="ln818"> </a>
<a name="ln819">  /* inactivate all toggle buttons */</a>
<a name="ln820">  GList *children = gtk_container_get_children(GTK_CONTAINER(d-&gt;history_box));</a>
<a name="ln821">  for(GList *l = children; l != NULL; l = g_list_next(l))</a>
<a name="ln822">  {</a>
<a name="ln823">    GtkToggleButton *b = GTK_TOGGLE_BUTTON(l-&gt;data);</a>
<a name="ln824">    if(b != GTK_TOGGLE_BUTTON(widget)) g_object_set(G_OBJECT(b), &quot;active&quot;, FALSE, (gchar *)0);</a>
<a name="ln825">  }</a>
<a name="ln826">  g_list_free(children);</a>
<a name="ln827"> </a>
<a name="ln828">  reset = 0;</a>
<a name="ln829">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln830"> </a>
<a name="ln831">  /* revert to given history item. */</a>
<a name="ln832">  int num = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), &quot;history-number&quot;));</a>
<a name="ln833">  dt_dev_pop_history_items(darktable.develop, num);</a>
<a name="ln834">  // set the module list order</a>
<a name="ln835">  dt_dev_reorder_gui_module_list(darktable.develop);</a>
<a name="ln836">  /* signal history changed */</a>
<a name="ln837">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE);</a>
<a name="ln838">  dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841">static void _lib_history_create_style_button_clicked_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln842">{</a>
<a name="ln843">  if(darktable.develop-&gt;image_storage.id)</a>
<a name="ln844">  {</a>
<a name="ln845">    dt_dev_write_history(darktable.develop);</a>
<a name="ln846">    dt_gui_styles_dialog_new(darktable.develop-&gt;image_storage.id);</a>
<a name="ln847">  }</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln851">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln852">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="212"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 212, 210.</p></div>
<div class="balloon" rel="236"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 236, 233.</p></div>
<div class="balloon" rel="237"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 237, 234.</p></div>
<div class="balloon" rel="507"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'module'. Check lines: 507, 502.</p></div>
<div class="balloon" rel="657"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'hist'. Check lines: 657, 656.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
