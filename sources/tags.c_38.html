
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010--2011 henrik andersson.</a>
<a name="ln4">    copyright (c) 2012 James C. McPherson</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;common/tags.h&quot;</a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/undo.h&quot;</a>
<a name="ln24">#include &quot;control/conf.h&quot;</a>
<a name="ln25">#include &quot;control/control.h&quot;</a>
<a name="ln26">#include &lt;glib.h&gt;</a>
<a name="ln27">#if defined (_WIN32)</a>
<a name="ln28">#include &quot;win/getdelim.h&quot;</a>
<a name="ln29">#endif // defined (_WIN32)</a>
<a name="ln30"> </a>
<a name="ln31">typedef struct dt_undo_tags_t</a>
<a name="ln32">{</a>
<a name="ln33">  int imgid;</a>
<a name="ln34">  GList *before; // list of tagid before</a>
<a name="ln35">  guint tagid;   // tag added or removed from before</a>
<a name="ln36">  gboolean add;</a>
<a name="ln37">} dt_undo_tags_t;</a>
<a name="ln38"> </a>
<a name="ln39">static void _attach_tag(guint tagid, gint imgid, gboolean undo_actif);</a>
<a name="ln40">static void _detach_tag(guint tagid, gint imgid, gboolean undo_actif);</a>
<a name="ln41"> </a>
<a name="ln42">static void _pop_undo(gpointer user_data, dt_undo_type_t type, dt_undo_data_t data, dt_undo_action_t action)</a>
<a name="ln43">{</a>
<a name="ln44">  if(type == DT_UNDO_TAGS)</a>
<a name="ln45">  {</a>
<a name="ln46">    sqlite3_stmt *stmt;</a>
<a name="ln47">    GList *list = (GList *)data;</a>
<a name="ln48"> </a>
<a name="ln49">    while(list)</a>
<a name="ln50">    {</a>
<a name="ln51">      dt_undo_tags_t *tags = (dt_undo_tags_t *)list-&gt;data;</a>
<a name="ln52"> </a>
<a name="ln53">      GList *tag_list = tags-&gt;before;</a>
<a name="ln54"> </a>
<a name="ln55">      // remove from tagged_images</a>
<a name="ln56">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln57">                                  &quot;DELETE FROM main.tagged_images WHERE imgid = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln58">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, tags-&gt;imgid);</a>
<a name="ln59">      sqlite3_step(stmt);</a>
<a name="ln60">      sqlite3_finalize(stmt);</a>
<a name="ln61"> </a>
<a name="ln62">      // iterate over tag_list and attach tagid to imgid</a>
<a name="ln63"> </a>
<a name="ln64">      while(tag_list)</a>
<a name="ln65">      {</a>
<a name="ln66">        const guint tagid = (guint)GPOINTER_TO_INT(tag_list-&gt;data);</a>
<a name="ln67">        _attach_tag(tagid, tags-&gt;imgid, FALSE);</a>
<a name="ln68">        tag_list = g_list_next(tag_list);</a>
<a name="ln69">      }</a>
<a name="ln70"> </a>
<a name="ln71">      if(action == DT_ACTION_REDO)</a>
<a name="ln72">      {</a>
<a name="ln73">        if(tags-&gt;add)</a>
<a name="ln74">          _attach_tag(tags-&gt;tagid, tags-&gt;imgid, FALSE);</a>
<a name="ln75">        else</a>
<a name="ln76">          _detach_tag(tags-&gt;tagid, tags-&gt;imgid, FALSE);</a>
<a name="ln77">      }</a>
<a name="ln78"> </a>
<a name="ln79">      dt_image_synch_xmp(tags-&gt;imgid);</a>
<a name="ln80"> </a>
<a name="ln81">      list = g_list_next(list);</a>
<a name="ln82">    }</a>
<a name="ln83"> </a>
<a name="ln84">    dt_tag_update_used_tags();</a>
<a name="ln85">    dt_collection_update_query(darktable.collection);</a>
<a name="ln86">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln87">  }</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">static dt_undo_tags_t *_get_tags(int imgid, guint tagid, gboolean add)</a>
<a name="ln91">{</a>
<a name="ln92">  dt_undo_tags_t *result = (dt_undo_tags_t *)malloc(sizeof(dt_undo_tags_t));</a>
<a name="ln93">  result-&gt;imgid  = imgid;</a>
<a name="ln94">  result-&gt;before = NULL;</a>
<a name="ln95">  result-&gt;tagid  = tagid;</a>
<a name="ln96">  result-&gt;add    = add;</a>
<a name="ln97"> </a>
<a name="ln98">  sqlite3_stmt *stmt;</a>
<a name="ln99"> </a>
<a name="ln100">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln101">                              &quot;SELECT tagid FROM main.tagged_images WHERE imgid=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln102">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln103"> </a>
<a name="ln104">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln105">  {</a>
<a name="ln106">    const guint tag = sqlite3_column_int(stmt, 0);</a>
<a name="ln107">    result-&gt;before = g_list_append(result-&gt;before, GINT_TO_POINTER(tag));</a>
<a name="ln108">  }</a>
<a name="ln109">  sqlite3_finalize(stmt);</a>
<a name="ln110"> </a>
<a name="ln111">  return result;</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">GList *_get_tags_selection(guint tagid, gboolean add)</a>
<a name="ln115">{</a>
<a name="ln116">  GList *result = NULL;</a>
<a name="ln117"> </a>
<a name="ln118">  sqlite3_stmt *stmt;</a>
<a name="ln119">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln120"> </a>
<a name="ln121">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln122">  {</a>
<a name="ln123">    const int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln124">    result = g_list_append(result, _get_tags(imgid, tagid, add));</a>
<a name="ln125">  }</a>
<a name="ln126"> </a>
<a name="ln127">  sqlite3_finalize(stmt);</a>
<a name="ln128"> </a>
<a name="ln129">  return result;</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">static void _undo_tags_free(gpointer data)</a>
<a name="ln133">{</a>
<a name="ln134">  dt_undo_tags_t *tag = (dt_undo_tags_t *)data;</a>
<a name="ln135">  g_list_free(tag-&gt;before);</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138">static void _tags_undo_data_free(gpointer data)</a>
<a name="ln139">{</a>
<a name="ln140">  GList *l = (GList *)data;</a>
<a name="ln141">  g_list_free_full(l, _undo_tags_free);</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">gboolean dt_tag_new(const char *name, guint *tagid)</a>
<a name="ln145">{</a>
<a name="ln146">  int rt;</a>
<a name="ln147">  sqlite3_stmt *stmt;</a>
<a name="ln148"> </a>
<a name="ln149">  if(!name || name[0] == '\0') return FALSE; // no tagid name.</a>
<a name="ln150"> </a>
<a name="ln151">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT id FROM data.tags WHERE name = ?1&quot;, -1, &amp;stmt,</a>
<a name="ln152">                              NULL);</a>
<a name="ln153">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, name, -1, SQLITE_TRANSIENT);</a>
<a name="ln154">  rt = sqlite3_step(stmt);</a>
<a name="ln155">  if(rt == SQLITE_ROW)</a>
<a name="ln156">  {</a>
<a name="ln157">    // tagid already exists.</a>
<a name="ln158">    if(tagid != NULL) *tagid = sqlite3_column_int64(stmt, 0);</a>
<a name="ln159">    sqlite3_finalize(stmt);</a>
<a name="ln160">    return TRUE;</a>
<a name="ln161">  }</a>
<a name="ln162">  sqlite3_finalize(stmt);</a>
<a name="ln163"> </a>
<a name="ln164">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;INSERT INTO data.tags (id, name) VALUES (NULL, ?1)&quot;,</a>
<a name="ln165">                              -1, &amp;stmt, NULL);</a>
<a name="ln166">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, name, -1, SQLITE_TRANSIENT);</a>
<a name="ln167">  sqlite3_step(stmt);</a>
<a name="ln168">  sqlite3_finalize(stmt);</a>
<a name="ln169"> </a>
<a name="ln170">  if(tagid != NULL)</a>
<a name="ln171">  {</a>
<a name="ln172">    *tagid = 0;</a>
<a name="ln173">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT id FROM data.tags WHERE name = ?1&quot;, -1,</a>
<a name="ln174">                                &amp;stmt, NULL);</a>
<a name="ln175">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, name, -1, SQLITE_TRANSIENT);</a>
<a name="ln176">    if(sqlite3_step(stmt) == SQLITE_ROW) *tagid = sqlite3_column_int(stmt, 0);</a>
<a name="ln177">    sqlite3_finalize(stmt);</a>
<a name="ln178">  }</a>
<a name="ln179"> </a>
<a name="ln180">  return TRUE;</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">gboolean dt_tag_new_from_gui(const char *name, guint *tagid)</a>
<a name="ln184">{</a>
<a name="ln185">  gboolean ret = dt_tag_new(name, tagid);</a>
<a name="ln186">  /* if everything went fine, raise signal of tags change to refresh keywords module in GUI */</a>
<a name="ln187">  if(ret) dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln188">  return ret;</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">guint dt_tag_remove(const guint tagid, gboolean final)</a>
<a name="ln192">{</a>
<a name="ln193">  int rv, count = -1;</a>
<a name="ln194">  sqlite3_stmt *stmt;</a>
<a name="ln195"> </a>
<a name="ln196">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln197">                              &quot;SELECT COUNT(*) FROM main.tagged_images WHERE tagid=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln198">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, tagid);</a>
<a name="ln199">  rv = sqlite3_step(stmt);</a>
<a name="ln200">  if(rv == SQLITE_ROW) count = sqlite3_column_int(stmt, 0);</a>
<a name="ln201">  sqlite3_finalize(stmt);</a>
<a name="ln202"> </a>
<a name="ln203">  if(final == TRUE)</a>
<a name="ln204">  {</a>
<a name="ln205">    // let's actually remove the tag</a>
<a name="ln206">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM data.tags WHERE id=?1&quot;, -1, &amp;stmt,</a>
<a name="ln207">                                NULL);</a>
<a name="ln208">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, tagid);</a>
<a name="ln209">    sqlite3_step(stmt);</a>
<a name="ln210">    sqlite3_finalize(stmt);</a>
<a name="ln211"> </a>
<a name="ln212">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.used_tags WHERE id=?1&quot;, -1, &amp;stmt,</a>
<a name="ln213">                                NULL);</a>
<a name="ln214">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, tagid);</a>
<a name="ln215">    sqlite3_step(stmt);</a>
<a name="ln216">    sqlite3_finalize(stmt);</a>
<a name="ln217"> </a>
<a name="ln218">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.tagged_images WHERE tagid=?1&quot;,</a>
<a name="ln219">                                -1, &amp;stmt, NULL);</a>
<a name="ln220">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, tagid);</a>
<a name="ln221">    sqlite3_step(stmt);</a>
<a name="ln222">    sqlite3_finalize(stmt);</a>
<a name="ln223"> </a>
<a name="ln224">    /* raise signal of tags change to refresh keywords module */</a>
<a name="ln225">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln226">  }</a>
<a name="ln227"> </a>
<a name="ln228">  return count;</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231">gchar *dt_tag_get_name(const guint tagid)</a>
<a name="ln232">{</a>
<a name="ln233">  int rt;</a>
<a name="ln234">  char *name = NULL;</a>
<a name="ln235">  sqlite3_stmt *stmt;</a>
<a name="ln236">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT name FROM data.tags WHERE id= ?1&quot;, -1, &amp;stmt,</a>
<a name="ln237">                              NULL);</a>
<a name="ln238">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, tagid);</a>
<a name="ln239">  rt = sqlite3_step(stmt);</a>
<a name="ln240">  if(rt == SQLITE_ROW) name = g_strdup((const char *)sqlite3_column_text(stmt, 0));</a>
<a name="ln241">  sqlite3_finalize(stmt);</a>
<a name="ln242"> </a>
<a name="ln243">  return name;</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">void dt_tag_reorganize(const gchar *source, const gchar *dest)</a>
<a name="ln247">{</a>
<a name="ln248">  sqlite3_stmt *stmt;</a>
<a name="ln249"> </a>
<a name="ln250">  if(!strcmp(source, dest)) return;</a>
<a name="ln251"> </a>
<a name="ln252">  gchar *tag = g_strrstr(source, &quot;|&quot;);</a>
<a name="ln253">  gchar *tag_to_free = NULL;</a>
<a name="ln254">  if(tag == NULL) tag_to_free = tag = g_strconcat(&quot;|&quot;, source, NULL);</a>
<a name="ln255"> </a>
<a name="ln256">  if(!strcmp(dest, &quot; &quot;))</a>
<a name="ln257">  {</a>
<a name="ln258">    tag++;</a>
<a name="ln259">    dest++;</a>
<a name="ln260">  }</a>
<a name="ln261"> </a>
<a name="ln262">  gchar *new_expr = g_strconcat(dest, tag, NULL);</a>
<a name="ln263">  gchar *source_expr = g_strconcat(source, &quot;%&quot;, NULL);</a>
<a name="ln264"> </a>
<a name="ln265">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln266">                              &quot;UPDATE data.tags SET name=REPLACE(name,?1,?2) WHERE name LIKE ?3&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln267">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, source, -1, SQLITE_TRANSIENT);</a>
<a name="ln268">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, new_expr, -1, SQLITE_TRANSIENT);</a>
<a name="ln269">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 3, source_expr, -1, SQLITE_TRANSIENT);</a>
<a name="ln270">  sqlite3_step(stmt);</a>
<a name="ln271">  sqlite3_finalize(stmt);</a>
<a name="ln272"> </a>
<a name="ln273">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln274">                              &quot;UPDATE main.used_tags SET name=REPLACE(name,?1,?2) WHERE name LIKE ?3&quot;,</a>
<a name="ln275">                              -1, &amp;stmt, NULL);</a>
<a name="ln276">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, source, -1, SQLITE_TRANSIENT);</a>
<a name="ln277">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, new_expr, -1, SQLITE_TRANSIENT);</a>
<a name="ln278">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 3, source_expr, -1, SQLITE_TRANSIENT);</a>
<a name="ln279">  sqlite3_step(stmt);</a>
<a name="ln280">  sqlite3_finalize(stmt);</a>
<a name="ln281"> </a>
<a name="ln282">  g_free(source_expr);</a>
<a name="ln283">  g_free(new_expr);</a>
<a name="ln284">  g_free(tag_to_free);</a>
<a name="ln285"> </a>
<a name="ln286">  /* raise signal of tags change to refresh keywords module */</a>
<a name="ln287">  // dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">gboolean dt_tag_exists(const char *name, guint *tagid)</a>
<a name="ln291">{</a>
<a name="ln292">  int rt;</a>
<a name="ln293">  sqlite3_stmt *stmt;</a>
<a name="ln294">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT id FROM data.tags WHERE name = ?1&quot;, -1, &amp;stmt,</a>
<a name="ln295">                              NULL);</a>
<a name="ln296">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, name, -1, SQLITE_TRANSIENT);</a>
<a name="ln297">  rt = sqlite3_step(stmt);</a>
<a name="ln298"> </a>
<a name="ln299">  if(rt == SQLITE_ROW)</a>
<a name="ln300">  {</a>
<a name="ln301">    if(tagid != NULL) *tagid = sqlite3_column_int64(stmt, 0);</a>
<a name="ln302">    sqlite3_finalize(stmt);</a>
<a name="ln303">    return TRUE;</a>
<a name="ln304">  }</a>
<a name="ln305"> </a>
<a name="ln306">  *tagid = -1;</a>
<a name="ln307">  sqlite3_finalize(stmt);</a>
<a name="ln308">  return FALSE;</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311">// we keep this separate so that updating the gui only happens once (and it's the caller's responsibility)</a>
<a name="ln312">static void _attach_tag(guint tagid, gint imgid, gboolean undo_actif)</a>
<a name="ln313">{</a>
<a name="ln314">  sqlite3_stmt *stmt;</a>
<a name="ln315">  GList *undo = NULL;</a>
<a name="ln316"> </a>
<a name="ln317">  if(undo_actif) dt_undo_start_group(darktable.undo, DT_UNDO_TAGS);</a>
<a name="ln318"> </a>
<a name="ln319">  if(imgid &gt; 0)</a>
<a name="ln320">  {</a>
<a name="ln321">    if(undo_actif) undo = g_list_append(undo, _get_tags(imgid, tagid, TRUE));</a>
<a name="ln322"> </a>
<a name="ln323">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln324">                                &quot;INSERT OR REPLACE INTO main.tagged_images (imgid, tagid) VALUES (?1, ?2)&quot;, -1,</a>
<a name="ln325">                                &amp;stmt, NULL);</a>
<a name="ln326">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln327">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, tagid);</a>
<a name="ln328">    sqlite3_step(stmt);</a>
<a name="ln329">    sqlite3_finalize(stmt);</a>
<a name="ln330">  }</a>
<a name="ln331">  else</a>
<a name="ln332">  {</a>
<a name="ln333">    if(undo_actif) undo = _get_tags_selection(tagid, TRUE);</a>
<a name="ln334"> </a>
<a name="ln335">    // insert into tagged_images if not there already.</a>
<a name="ln336">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln337">                                &quot;INSERT OR REPLACE INTO main.tagged_images SELECT imgid, ?1 &quot;</a>
<a name="ln338">                                &quot;FROM main.selected_images&quot;,</a>
<a name="ln339">                                -1, &amp;stmt, NULL);</a>
<a name="ln340">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, tagid);</a>
<a name="ln341">    sqlite3_step(stmt);</a>
<a name="ln342">    sqlite3_finalize(stmt);</a>
<a name="ln343">  }</a>
<a name="ln344"> </a>
<a name="ln345">  if(undo_actif)</a>
<a name="ln346">  {</a>
<a name="ln347">    dt_undo_record(darktable.undo, NULL, DT_UNDO_TAGS, (dt_undo_data_t)undo, _pop_undo, _tags_undo_data_free);</a>
<a name="ln348">    dt_undo_end_group(darktable.undo);</a>
<a name="ln349">  }</a>
<a name="ln350">}</a>
<a name="ln351"> </a>
<a name="ln352">gboolean _tag_is_attached(guint tagid, gint imgid)</a>
<a name="ln353">{</a>
<a name="ln354">  gboolean result = FALSE;</a>
<a name="ln355">  sqlite3_stmt *stmt;</a>
<a name="ln356"> </a>
<a name="ln357">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln358">                              &quot;SELECT tagid FROM main.tagged_images WHERE imgid=?1 AND tagid=?2&quot;, -1,</a>
<a name="ln359">                              &amp;stmt, NULL);</a>
<a name="ln360">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln361">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, tagid);</a>
<a name="ln362"> </a>
<a name="ln363">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln364">    result = TRUE;</a>
<a name="ln365"> </a>
<a name="ln366">  sqlite3_finalize(stmt);</a>
<a name="ln367">  return result;</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">void dt_tag_attach(guint tagid, gint imgid)</a>
<a name="ln371">{</a>
<a name="ln372">  if(!_tag_is_attached(tagid, imgid))</a>
<a name="ln373">  {</a>
<a name="ln374">    _attach_tag(tagid, imgid, TRUE);</a>
<a name="ln375"> </a>
<a name="ln376">    dt_tag_update_used_tags();</a>
<a name="ln377"> </a>
<a name="ln378">    dt_collection_update_query(darktable.collection);</a>
<a name="ln379">  }</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">void dt_tag_attach_list(GList *tags, gint imgid)</a>
<a name="ln383">{</a>
<a name="ln384">  GList *child = NULL;</a>
<a name="ln385">  if((child = g_list_first(tags)) != NULL) do</a>
<a name="ln386">    {</a>
<a name="ln387">      _attach_tag(GPOINTER_TO_INT(child-&gt;data), imgid, TRUE);</a>
<a name="ln388">    } while((child = g_list_next(child)) != NULL);</a>
<a name="ln389"> </a>
<a name="ln390">  dt_tag_update_used_tags();</a>
<a name="ln391"> </a>
<a name="ln392">  dt_collection_update_query(darktable.collection);</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">void dt_tag_attach_string_list(const gchar *tags, gint imgid)</a>
<a name="ln396">{</a>
<a name="ln397">  gchar **tokens = g_strsplit(tags, &quot;,&quot;, 0);</a>
<a name="ln398">  if(tokens)</a>
<a name="ln399">  {</a>
<a name="ln400">    gchar **entry = tokens;</a>
<a name="ln401">    while(*entry)</a>
<a name="ln402">    {</a>
<a name="ln403">      // remove leading and trailing spaces</a>
<a name="ln404">      char *e = *entry + strlen(*entry) - 1;</a>
<a name="ln405">      while(*e == ' ' &amp;&amp; e &gt; *entry) *e = '\0';</a>
<a name="ln406">      e = *entry;</a>
<a name="ln407">      while(*e == ' ' &amp;&amp; *e != '\0') e++;</a>
<a name="ln408">      if(*e)</a>
<a name="ln409">      {</a>
<a name="ln410">        // add the tag to the image</a>
<a name="ln411">        guint tagid = 0;</a>
<a name="ln412">        dt_tag_new(e, &amp;tagid);</a>
<a name="ln413">        _attach_tag(tagid, imgid, TRUE);</a>
<a name="ln414">      }</a>
<a name="ln415">      entry++;</a>
<a name="ln416">    }</a>
<a name="ln417"> </a>
<a name="ln418">    dt_tag_update_used_tags();</a>
<a name="ln419"> </a>
<a name="ln420">    dt_collection_update_query(darktable.collection);</a>
<a name="ln421">  }</a>
<a name="ln422">  g_strfreev(tokens);</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">void _detach_tag(guint tagid, gint imgid, gboolean undo_actif)</a>
<a name="ln426">{</a>
<a name="ln427">  sqlite3_stmt *stmt;</a>
<a name="ln428">  GList *undo = NULL;</a>
<a name="ln429"> </a>
<a name="ln430">  if(undo_actif) dt_undo_start_group(darktable.undo, DT_UNDO_TAGS);</a>
<a name="ln431"> </a>
<a name="ln432">  if(imgid &gt; 0)</a>
<a name="ln433">  {</a>
<a name="ln434">    if(undo_actif) undo = g_list_append(undo, _get_tags(imgid, tagid, FALSE));</a>
<a name="ln435"> </a>
<a name="ln436">    // remove from tagged_images</a>
<a name="ln437">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln438">                                &quot;DELETE FROM main.tagged_images WHERE tagid = ?1 AND imgid = ?2&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln439">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, tagid);</a>
<a name="ln440">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln441">    sqlite3_step(stmt);</a>
<a name="ln442">    sqlite3_finalize(stmt);</a>
<a name="ln443">  }</a>
<a name="ln444">  else</a>
<a name="ln445">  {</a>
<a name="ln446">    if(undo_actif) undo = _get_tags_selection(tagid, FALSE);</a>
<a name="ln447"> </a>
<a name="ln448">    // remove from tagged_images</a>
<a name="ln449">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln450">                                &quot;DELETE FROM main.tagged_images WHERE tagid = ?1 AND imgid IN &quot;</a>
<a name="ln451">                                &quot;(SELECT imgid FROM main.selected_images)&quot;,</a>
<a name="ln452">                                -1, &amp;stmt, NULL);</a>
<a name="ln453">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, tagid);</a>
<a name="ln454">    sqlite3_step(stmt);</a>
<a name="ln455">    sqlite3_finalize(stmt);</a>
<a name="ln456">  }</a>
<a name="ln457"> </a>
<a name="ln458">  if(undo_actif)</a>
<a name="ln459">  {</a>
<a name="ln460">    dt_undo_record(darktable.undo, NULL, DT_UNDO_TAGS, (dt_undo_data_t)undo, _pop_undo, _tags_undo_data_free);</a>
<a name="ln461">    dt_undo_end_group(darktable.undo);</a>
<a name="ln462">  }</a>
<a name="ln463"> </a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">void dt_tag_detach(guint tagid, gint imgid)</a>
<a name="ln467">{</a>
<a name="ln468">  _detach_tag(tagid, imgid, TRUE);</a>
<a name="ln469"> </a>
<a name="ln470">  dt_tag_update_used_tags();</a>
<a name="ln471"> </a>
<a name="ln472">  dt_collection_update_query(darktable.collection);</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">void dt_tag_detach_by_string(const char *name, gint imgid)</a>
<a name="ln476">{</a>
<a name="ln477">  sqlite3_stmt *stmt;</a>
<a name="ln478">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln479">                              &quot;DELETE FROM main.tagged_images WHERE tagid IN (SELECT id FROM &quot;</a>
<a name="ln480">                              &quot;data.tags WHERE name LIKE ?1) AND imgid = ?2;&quot;,</a>
<a name="ln481">                              -1, &amp;stmt, NULL);</a>
<a name="ln482">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, name, -1, SQLITE_TRANSIENT);</a>
<a name="ln483">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln484">  sqlite3_step(stmt);</a>
<a name="ln485">  sqlite3_finalize(stmt);</a>
<a name="ln486"> </a>
<a name="ln487">  dt_tag_update_used_tags();</a>
<a name="ln488"> </a>
<a name="ln489">  dt_collection_update_query(darktable.collection);</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492"> </a>
<a name="ln493">uint32_t dt_tag_get_attached(gint imgid, GList **result, gboolean ignore_dt_tags)</a>
<a name="ln494">{</a>
<a name="ln495">  sqlite3_stmt *stmt;</a>
<a name="ln496">  if(imgid &gt; 0)</a>
<a name="ln497">  {</a>
<a name="ln498">    char query[1024] = { 0 };</a>
<a name="ln499">    snprintf(query, sizeof(query), &quot;SELECT DISTINCT T.id, T.name FROM main.tagged_images AS I &quot;</a>
<a name="ln500">                                   &quot;JOIN data.tags T on T.id = I.tagid &quot;</a>
<a name="ln501">                                   &quot;WHERE I.imgid = %d %s ORDER BY T.name&quot;,</a>
<a name="ln502">             imgid, ignore_dt_tags ? &quot;AND NOT T.name LIKE \&quot;darktable|%\&quot;&quot; : &quot;&quot;);</a>
<a name="ln503">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln504">  }</a>
<a name="ln505">  else</a>
<a name="ln506">  {</a>
<a name="ln507">    if(ignore_dt_tags)</a>
<a name="ln508">      DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln509">          dt_database_get(darktable.db),</a>
<a name="ln510">          &quot;SELECT DISTINCT T.id, T.name &quot;</a>
<a name="ln511">          &quot;FROM main.tagged_images AS I, data.tags AS T &quot;</a>
<a name="ln512">          &quot;WHERE I.imgid IN (SELECT imgid FROM main.selected_images) &quot;</a>
<a name="ln513">          &quot;AND T.id = I.tagid AND NOT T.name LIKE \&quot;darktable|%\&quot; ORDER BY T.name&quot;,</a>
<a name="ln514">          -1, &amp;stmt, NULL);</a>
<a name="ln515">    else</a>
<a name="ln516">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln517">                                  &quot;SELECT DISTINCT T.id, T.name &quot;</a>
<a name="ln518">                                  &quot;FROM main.tagged_images AS I, data.tags AS T &quot;</a>
<a name="ln519">                                  &quot;WHERE I.imgid IN (SELECT imgid FROM main.selected_images) &quot;</a>
<a name="ln520">                                  &quot;AND T.id = I.tagid ORDER BY T.name&quot;,</a>
<a name="ln521">                                  -1, &amp;stmt, NULL);</a>
<a name="ln522">  }</a>
<a name="ln523"> </a>
<a name="ln524">  // Create result</a>
<a name="ln525">  uint32_t count = 0;</a>
<a name="ln526">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln527">  {</a>
<a name="ln528">    dt_tag_t *t = g_malloc(sizeof(dt_tag_t));</a>
<a name="ln529">    t-&gt;id = sqlite3_column_int(stmt, 0);</a>
<a name="ln530">    t-&gt;tag = g_strdup((char *)sqlite3_column_text(stmt, 1));</a>
<a name="ln531">    *result = g_list_append(*result, t);</a>
<a name="ln532">    count++;</a>
<a name="ln533">  }</a>
<a name="ln534">  sqlite3_finalize(stmt);</a>
<a name="ln535">  return count;</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538">GList *dt_tag_get_list(gint imgid)</a>
<a name="ln539">{</a>
<a name="ln540">  GList *taglist = NULL;</a>
<a name="ln541">  GList *tags = NULL;</a>
<a name="ln542"> </a>
<a name="ln543">  gboolean omit_tag_hierarchy = dt_conf_get_bool(&quot;omit_tag_hierarchy&quot;);</a>
<a name="ln544"> </a>
<a name="ln545">  uint32_t count = dt_tag_get_attached(imgid, &amp;taglist, TRUE);</a>
<a name="ln546"> </a>
<a name="ln547">  if(count &lt; 1) return NULL;</a>
<a name="ln548"> </a>
<a name="ln549">  for(; taglist; taglist = g_list_next(taglist))</a>
<a name="ln550">  {</a>
<a name="ln551">    dt_tag_t *t = (dt_tag_t *)taglist-&gt;data;</a>
<a name="ln552">    gchar *value = t-&gt;tag;</a>
<a name="ln553"> </a>
<a name="ln554">    size_t j = 0;</a>
<a name="ln555">    gchar **pch = g_strsplit(value, &quot;|&quot;, -1);</a>
<a name="ln556"> </a>
<a name="ln557">    if(pch != NULL)</a>
<a name="ln558">    {</a>
<a name="ln559">      if(omit_tag_hierarchy)</a>
<a name="ln560">      {</a>
<a name="ln561">        char **iter = pch;</a>
<a name="ln562">        for(; *iter &amp;&amp; *(iter + 1); iter++);</a>
<a name="ln563">        if(*iter) tags = g_list_prepend(tags, g_strdup(*iter));</a>
<a name="ln564">      }</a>
<a name="ln565">      else</a>
<a name="ln566">      {</a>
<a name="ln567">        while(pch[j] != NULL)</a>
<a name="ln568">        {</a>
<a name="ln569">          tags = g_list_prepend(tags, g_strdup(pch[j]));</a>
<a name="ln570">          j++;</a>
<a name="ln571">        }</a>
<a name="ln572">      }</a>
<a name="ln573">      g_strfreev(pch);</a>
<a name="ln574">    }</a>
<a name="ln575">  }</a>
<a name="ln576"> </a>
<a name="ln577">  g_list_free_full(taglist, g_free);</a>
<a name="ln578"> </a>
<a name="ln579">  return dt_util_glist_uniq(tags);</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">GList *dt_tag_get_hierarchical(gint imgid)</a>
<a name="ln583">{</a>
<a name="ln584">  GList *taglist = NULL;</a>
<a name="ln585">  GList *tags = NULL;</a>
<a name="ln586"> </a>
<a name="ln587">  int count = dt_tag_get_attached(imgid, &amp;taglist, TRUE);</a>
<a name="ln588"> </a>
<a name="ln589">  if(count &lt; 1) return NULL;</a>
<a name="ln590"> </a>
<a name="ln591">  while(taglist)</a>
<a name="ln592">  {</a>
<a name="ln593">    dt_tag_t *t = (dt_tag_t *)taglist-&gt;data;</a>
<a name="ln594"> </a>
<a name="ln595">    tags = g_list_prepend(tags, t-&gt;tag);</a>
<a name="ln596"> </a>
<a name="ln597">    taglist = g_list_next(taglist);</a>
<a name="ln598">  }</a>
<a name="ln599"> </a>
<a name="ln600">  g_list_free_full(taglist, g_free);</a>
<a name="ln601"> </a>
<a name="ln602">  tags = g_list_reverse(tags);</a>
<a name="ln603">  return tags;</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">GList *dt_tag_get_images_from_selection(gint imgid, gint tagid)</a>
<a name="ln607">{</a>
<a name="ln608">  GList *result = NULL;</a>
<a name="ln609">  sqlite3_stmt *stmt;</a>
<a name="ln610"> </a>
<a name="ln611">  if(imgid &gt; 0)</a>
<a name="ln612">  {</a>
<a name="ln613">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.tagged_images WHERE &quot;</a>
<a name="ln614">                                &quot;imgid = ?1 AND tagid = ?2&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln615">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln616">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, tagid);</a>
<a name="ln617">  }</a>
<a name="ln618">  else</a>
<a name="ln619">  {</a>
<a name="ln620">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.tagged_images WHERE &quot;</a>
<a name="ln621">                                &quot;tagid = ?1 AND imgid IN (SELECT imgid FROM main.selected_images)&quot;, -1, &amp;stmt,</a>
<a name="ln622">                                NULL);</a>
<a name="ln623">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, tagid);</a>
<a name="ln624">  }</a>
<a name="ln625"> </a>
<a name="ln626"> </a>
<a name="ln627">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln628">  {</a>
<a name="ln629">    int id = sqlite3_column_int(stmt, 0);</a>
<a name="ln630">    result = g_list_append(result, GINT_TO_POINTER(id));</a>
<a name="ln631">  }</a>
<a name="ln632"> </a>
<a name="ln633">  sqlite3_finalize(stmt);</a>
<a name="ln634"> </a>
<a name="ln635">  return result;</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">uint32_t dt_tag_get_suggestions(const gchar *keyword, GList **result)</a>
<a name="ln639">{</a>
<a name="ln640">  sqlite3_stmt *stmt;</a>
<a name="ln641">  /*</a>
<a name="ln642">   * Earlier versions of this function used a large collation of selects</a>
<a name="ln643">   * and joins, resulting in multi-*second* timings for sqlite3_exec().</a>
<a name="ln644">   *</a>
<a name="ln645">   * Breaking the query into several smaller ones allows the sqlite3</a>
<a name="ln646">   * execution engine to work more effectively, which is very important</a>
<a name="ln647">   * for interactive response since we call this function several times</a>
<a name="ln648">   * in quick succession (on every keystroke).</a>
<a name="ln649">   */</a>
<a name="ln650"> </a>
<a name="ln651">  /* Quick sanity check - is keyword empty? If so .. return 0 */</a>
<a name="ln652">  if(!keyword) return 0;</a>
<a name="ln653"> </a>
<a name="ln654">  gchar *keyword_expr = g_strdup_printf(&quot;%%%s%%&quot;, keyword);</a>
<a name="ln655"> </a>
<a name="ln656">  /* Only select tags that are similar to the one we are looking for once. */</a>
<a name="ln657">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln658">                              &quot;INSERT INTO memory.similar_tags (tagid) SELECT id FROM data.tags WHERE name LIKE ?1&quot;,</a>
<a name="ln659">                              -1, &amp;stmt, NULL);</a>
<a name="ln660">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, keyword_expr, -1, SQLITE_TRANSIENT);</a>
<a name="ln661">  sqlite3_step(stmt);</a>
<a name="ln662">  sqlite3_finalize(stmt);</a>
<a name="ln663"> </a>
<a name="ln664">  g_free(keyword_expr);</a>
<a name="ln665"> </a>
<a name="ln666">  /* Select tags that are similar to the keyword and are actually used to tag images*/</a>
<a name="ln667">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln668">                              &quot;INSERT INTO memory.taglist (id, count) SELECT tagid, 1000000+COUNT(*) &quot;</a>
<a name="ln669">                              &quot;FROM main.tagged_images &quot;</a>
<a name="ln670">                              &quot;WHERE tagid IN memory.similar_tags GROUP BY tagid &quot;,</a>
<a name="ln671">                              -1, &amp;stmt, NULL);</a>
<a name="ln672">  sqlite3_step(stmt);</a>
<a name="ln673">  sqlite3_finalize(stmt);</a>
<a name="ln674"> </a>
<a name="ln675">  /* Select tags that are similar to the keyword but were not used to tag any image*/</a>
<a name="ln676">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln677">                              &quot;INSERT INTO memory.taglist (id, count) SELECT tagid,1000000 FROM memory.similar_tags&quot;,</a>
<a name="ln678">                              -1, &amp;stmt, NULL);</a>
<a name="ln679">  sqlite3_step(stmt);</a>
<a name="ln680">  sqlite3_finalize(stmt);</a>
<a name="ln681"> </a>
<a name="ln682">  /* Select tags from tagged images when at least one tag is similar to the keyword and insert in temp table*/</a>
<a name="ln683">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln684">                              &quot;INSERT INTO memory.tagq (id) SELECT tagid FROM main.tagged_images WHERE imgid IN &quot;</a>
<a name="ln685">                              &quot;(SELECT DISTINCT imgid FROM main.tagged_images JOIN memory.similar_tags USING (tagid)) &quot;,</a>
<a name="ln686">                              -1, &amp;stmt, NULL);</a>
<a name="ln687">  sqlite3_step(stmt);</a>
<a name="ln688">  sqlite3_finalize(stmt);</a>
<a name="ln689"> </a>
<a name="ln690">  /* Select tags from temp table that are not similar to the keyword */</a>
<a name="ln691">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;INSERT INTO memory.taglist (id, count) SELECT id, &quot;</a>
<a name="ln692">                                                       &quot;COUNT(*) FROM memory.tagq WHERE id NOT IN (SELECT id FROM &quot;</a>
<a name="ln693">                                                       &quot;memory.taglist) GROUP BY id&quot;, NULL, NULL, NULL);</a>
<a name="ln694"> </a>
<a name="ln695">  /* Now put all the bits together */</a>
<a name="ln696">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln697">                              &quot;SELECT T.name, T.id FROM data.tags T &quot;</a>
<a name="ln698">                              &quot;JOIN memory.taglist MT ON MT.id = T.id &quot;</a>
<a name="ln699">                              &quot;WHERE T.id IN (SELECT DISTINCT(MT.id) FROM memory.taglist MT) &quot;</a>
<a name="ln700">                              &quot;AND T.name NOT LIKE 'darktable|%%' &quot;</a>
<a name="ln701">                              &quot;ORDER BY MT.count DESC&quot;,</a>
<a name="ln702">                              -1, &amp;stmt, NULL);</a>
<a name="ln703"> </a>
<a name="ln704">  /* ... and create the result list to send upwards */</a>
<a name="ln705">  uint32_t count = 0;</a>
<a name="ln706">  dt_tag_t *t;</a>
<a name="ln707">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln708">  {</a>
<a name="ln709">    t = g_malloc(sizeof(dt_tag_t));</a>
<a name="ln710">    t-&gt;tag = g_strdup((char *)sqlite3_column_text(stmt, 0));</a>
<a name="ln711">    t-&gt;id = sqlite3_column_int(stmt, 1);</a>
<a name="ln712">    *result = g_list_append((*result), t);</a>
<a name="ln713">    count++;</a>
<a name="ln714">  }</a>
<a name="ln715"> </a>
<a name="ln716">  sqlite3_finalize(stmt);</a>
<a name="ln717">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM memory.taglist&quot;, NULL, NULL, NULL);</a>
<a name="ln718">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM memory.tagq&quot;, NULL, NULL, NULL);</a>
<a name="ln719">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM memory.similar_tags&quot;, NULL, NULL, NULL);</a>
<a name="ln720"> </a>
<a name="ln721">  return count;</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724">static void _free_result_item(dt_tag_t *t, gpointer unused)</a>
<a name="ln725">{</a>
<a name="ln726">  g_free(t-&gt;tag);</a>
<a name="ln727">  g_free(t);</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730">void dt_tag_free_result(GList **result)</a>
<a name="ln731">{</a>
<a name="ln732">  if(result &amp;&amp; *result)</a>
<a name="ln733">  {</a>
<a name="ln734">    g_list_free_full(*result, (GDestroyNotify)_free_result_item);</a>
<a name="ln735">  }</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">uint32_t dt_tag_get_recent_used(GList **result)</a>
<a name="ln739">{</a>
<a name="ln740">  return 0;</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">/*</a>
<a name="ln744">  TODO</a>
<a name="ln745">  the file format allows to specify {synonyms} that are one hierarchy level deeper than the parent. those are not</a>
<a name="ln746">  to be shown in the gui but can be searched. when the parent or a synonym is attached then ALSO the rest of the</a>
<a name="ln747">  bunch is to be added. currently dt doesn't allow something like that but it would be really great if it could</a>
<a name="ln748">  be added. currently we don't import synonyms.</a>
<a name="ln749">  there is also a ~ prefix for tags that indicate that the tag order has to be kept instead of sorting them. that's</a>
<a name="ln750">  also not possible at the moment.</a>
<a name="ln751">*/</a>
<a name="ln752">ssize_t dt_tag_import(const char *filename)</a>
<a name="ln753">{</a>
<a name="ln754">  FILE *fd = g_fopen(filename, &quot;r&quot;);</a>
<a name="ln755"> </a>
<a name="ln756">  if(!fd) return -1;</a>
<a name="ln757"> </a>
<a name="ln758">  GList * hierarchy = NULL;</a>
<a name="ln759">  char *line = NULL;</a>
<a name="ln760">  size_t len = 0;</a>
<a name="ln761">  ssize_t count = 0;</a>
<a name="ln762"> </a>
<a name="ln763">  while(getline(&amp;line, &amp;len, fd) != -1)</a>
<a name="ln764">  {</a>
<a name="ln765">    // remove newlines and set start past the initial tabs</a>
<a name="ln766">    char *start = line;</a>
<a name="ln767">    while(*start == '\t') start++;</a>
<a name="ln768">    const int depth = start - line;</a>
<a name="ln769"> </a>
<a name="ln770">    char *end = line + strlen(line) - 1;</a>
<a name="ln771">    while((*end == '\n' || *end == '\r') &amp;&amp; end &gt;= start)</a>
<a name="ln772">    {</a>
<a name="ln773">      *end = '\0';</a>
<a name="ln774">      end--;</a>
<a name="ln775">    }</a>
<a name="ln776"> </a>
<a name="ln777">    // remove control characters from the string</a>
<a name="ln778">    // don't add the entry if it's a category</a>
<a name="ln779">    // TODO also ignore synonyms for now as our db can't express that concept.</a>
<a name="ln780">    gboolean skip = FALSE;</a>
<a name="ln781">    if((*start == '[' &amp;&amp; *end == ']') // categories</a>
<a name="ln782">      || (*start == '{' &amp;&amp; *end == '}')) // synonyms</a>
<a name="ln783">    {</a>
<a name="ln784">      skip = TRUE;</a>
<a name="ln785">      start++;</a>
<a name="ln786">      *end-- = '\0';</a>
<a name="ln787">    }</a>
<a name="ln788">    if(*start == '~') // fixed order. TODO not possible with our db</a>
<a name="ln789">    {</a>
<a name="ln790">      skip = TRUE;</a>
<a name="ln791">      start++;</a>
<a name="ln792">    }</a>
<a name="ln793"> </a>
<a name="ln794">    // remove everything past the current prefix from hierarchy</a>
<a name="ln795">    GList *iter = g_list_nth(hierarchy, depth);</a>
<a name="ln796">    while(iter)</a>
<a name="ln797">    {</a>
<a name="ln798">      GList *current = iter;</a>
<a name="ln799">      iter = g_list_next(iter);</a>
<a name="ln800">      hierarchy = g_list_delete_link(hierarchy, current);</a>
<a name="ln801">    }</a>
<a name="ln802"> </a>
<a name="ln803">    // add the current level</a>
<a name="ln804">    hierarchy = g_list_append(hierarchy, g_strdup(start));</a>
<a name="ln805"> </a>
<a name="ln806">    // add tag to db iff it's not something to be ignored</a>
<a name="ln807">    if(!skip)</a>
<a name="ln808">    {</a>
<a name="ln809">      count++;</a>
<a name="ln810">      char *tag = dt_util_glist_to_str(&quot;|&quot;, hierarchy);</a>
<a name="ln811">      dt_tag_new(tag, NULL);</a>
<a name="ln812">      g_free(tag);</a>
<a name="ln813">    }</a>
<a name="ln814">  }</a>
<a name="ln815"> </a>
<a name="ln816">  free(line);</a>
<a name="ln817">  g_list_free_full(hierarchy, g_free);</a>
<a name="ln818">  fclose(fd);</a>
<a name="ln819"> </a>
<a name="ln820">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln821"> </a>
<a name="ln822">  return count;</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">/*</a>
<a name="ln826">  TODO: there is one corner case where i am not sure if we are doing the correct thing. some examples i found</a>
<a name="ln827">  on the internet agreed with this version, some used an alternative:</a>
<a name="ln828">  consider two tags like &quot;foo|bar&quot; and &quot;foo|bar|baz&quot;. the &quot;foo|bar&quot; part is both a regular tag (from the 1st tag)</a>
<a name="ln829">  and also a category (from the 2nd tag). the two way to output are</a>
<a name="ln830"> </a>
<a name="ln831">  [foo]</a>
<a name="ln832">      bar</a>
<a name="ln833">          baz</a>
<a name="ln834"> </a>
<a name="ln835">  and</a>
<a name="ln836"> </a>
<a name="ln837">  [foo]</a>
<a name="ln838">      bar</a>
<a name="ln839">      [bar]</a>
<a name="ln840">          baz</a>
<a name="ln841"> </a>
<a name="ln842">  we are using the first (mostly because it was easier to implement ;)). if this poses problems with other programs</a>
<a name="ln843">  supporting these files then we should fix that.</a>
<a name="ln844">*/</a>
<a name="ln845">ssize_t dt_tag_export(const char *filename)</a>
<a name="ln846">{</a>
<a name="ln847">  FILE *fd = g_fopen(filename, &quot;w&quot;);</a>
<a name="ln848"> </a>
<a name="ln849">  if(!fd) return -1;</a>
<a name="ln850"> </a>
<a name="ln851">  sqlite3_stmt *stmt;</a>
<a name="ln852">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln853">                              &quot;SELECT name FROM data.tags WHERE name NOT LIKE \&quot;darktable|%\&quot; &quot;</a>
<a name="ln854">                              &quot;ORDER BY name COLLATE NOCASE ASC&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln855"> </a>
<a name="ln856"> </a>
<a name="ln857">  ssize_t count = 0;</a>
<a name="ln858">  gchar **hierarchy = NULL;</a>
<a name="ln859"> </a>
<a name="ln860">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln861">  {</a>
<a name="ln862">    const char *tag = (char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln863"> </a>
<a name="ln864">    gchar **tokens = g_strsplit(tag, &quot;|&quot;, -1);</a>
<a name="ln865"> </a>
<a name="ln866">    // find how many common levels are shared with the last tag</a>
<a name="ln867">    int common_start;</a>
<a name="ln868">    for(common_start = 0; hierarchy &amp;&amp; hierarchy[common_start] &amp;&amp; tokens &amp;&amp; tokens[common_start]; common_start++)</a>
<a name="ln869">    {</a>
<a name="ln870">      if(g_strcmp0(hierarchy[common_start], tokens[common_start])) break;</a>
<a name="ln871">    }</a>
<a name="ln872"> </a>
<a name="ln873">    g_strfreev(hierarchy);</a>
<a name="ln874">    hierarchy = tokens;</a>
<a name="ln875"> </a>
<a name="ln876">    int tabs = common_start;</a>
<a name="ln877">    for(size_t i = common_start; tokens &amp;&amp; tokens[i]; i++, tabs++)</a>
<a name="ln878">    {</a>
<a name="ln879">      for(int j = 0; j &lt; tabs; j++) fputc('\t', fd);</a>
<a name="ln880">      if(!tokens[i + 1])</a>
<a name="ln881">      {</a>
<a name="ln882">        count++;</a>
<a name="ln883">        fprintf(fd, &quot;%s\n&quot;, tokens[i]);</a>
<a name="ln884">      }</a>
<a name="ln885">      else</a>
<a name="ln886">        fprintf(fd, &quot;[%s]\n&quot;, tokens[i]);</a>
<a name="ln887">    }</a>
<a name="ln888">  }</a>
<a name="ln889"> </a>
<a name="ln890">  g_strfreev(hierarchy);</a>
<a name="ln891"> </a>
<a name="ln892">  sqlite3_finalize(stmt);</a>
<a name="ln893"> </a>
<a name="ln894">  fclose(fd);</a>
<a name="ln895"> </a>
<a name="ln896">  return count;</a>
<a name="ln897">}</a>
<a name="ln898"> </a>
<a name="ln899">void dt_tag_update_used_tags()</a>
<a name="ln900">{</a>
<a name="ln901">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM main.used_tags WHERE id NOT IN &quot;</a>
<a name="ln902">                                                       &quot;(SELECT tagid FROM main.tagged_images GROUP BY tagid)&quot;,</a>
<a name="ln903">                        NULL, NULL, NULL);</a>
<a name="ln904"> </a>
<a name="ln905">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;INSERT OR IGNORE INTO main.used_tags (id, name) &quot;</a>
<a name="ln906">                                                       &quot;SELECT t.id, t.name &quot;</a>
<a name="ln907">                                                       &quot;FROM data.tags AS t, main.tagged_images AS i &quot;</a>
<a name="ln908">                                                       &quot;ON t.id = i.tagid GROUP BY t.id&quot;,</a>
<a name="ln909">                        NULL, NULL, NULL);</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln913">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln914">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="93"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'result'. Check lines: 93, 92.</p></div>
<div class="balloon" rel="407"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v590/" target="_blank">V590</a> Consider inspecting the '* e == ' ' && * e != '\0'' expression. The expression is excessive or contains a misprint.</p></div>
<div class="balloon" rel="577"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="600"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="795"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_nth' function. Inspect the first argument.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
