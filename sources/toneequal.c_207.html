
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2018-2019 Aurélien Pierre.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">/*** DOCUMENTATION</a>
<a name="ln20"> *</a>
<a name="ln21"> * This module aims at relighting the scene by performing an exposure compensation</a>
<a name="ln22"> * selectively on specified exposures octaves, the same way HiFi audio equalizers allow to set</a>
<a name="ln23"> * a gain for each octave.</a>
<a name="ln24"> *</a>
<a name="ln25"> * It is intended to work in scene-linear camera RGB, to behave as if light was physically added</a>
<a name="ln26"> * or removed from the scene. As such, it should be put before input profile in the pipe, but preferably</a>
<a name="ln27"> * after exposure. It also need to be placed after the rotation, perspective and cropping modules</a>
<a name="ln28"> * for the interactive editing to work properly (so the image buffer overlap perfectly with the</a>
<a name="ln29"> * image preview).</a>
<a name="ln30"> *</a>
<a name="ln31"> * Because it works before camera RGB -&gt; XYZ conversion, the exposure cannot be computed from</a>
<a name="ln32"> * any human-based perceptual colour model (Y channel), hence why several RGB norms are provided as estimators of</a>
<a name="ln33"> * the pixel energy to compute a luminance map. None of them is perfect, and I'm still</a>
<a name="ln34"> * looking forward to a real spectral energy estimator. The best physically-accurate norm should be the euclidean</a>
<a name="ln35"> * norm, but the best looking is often the power norm, which has no theoretical background.</a>
<a name="ln36"> * The geometric mean also display interesting properties as it interprets saturated colours</a>
<a name="ln37"> * as low-lights, allowing to lighten and desaturate them in a realistic way.</a>
<a name="ln38"> *</a>
<a name="ln39"> * The exposure correction is computed as a series of each octave's gain weighted by the</a>
<a name="ln40"> * gaussian of the radial distance between the current pixel exposure and each octave's center.</a>
<a name="ln41"> * This allows for a smooth and continuous infinite-order interpolation, preserving exposure gradients</a>
<a name="ln42"> * as best as possible. The radius of the kernel is user-defined and can be tweaked to get</a>
<a name="ln43"> * a smoother interpolation (possibly generating oscillations), or a more monotonous one</a>
<a name="ln44"> * (possibly less smooth). The actual factors of the gaussian series are computed by</a>
<a name="ln45"> * solving the linear system taking the user-input parameters as target exposures compensations.</a>
<a name="ln46"> *</a>
<a name="ln47"> * Notice that every pixel operation is performed in linear space. The exposures in log2 (EV)</a>
<a name="ln48"> * are only used for user-input parameters and for the gaussian weights of the radial distance</a>
<a name="ln49"> * between pixel exposure and octave's centers.</a>
<a name="ln50"> *</a>
<a name="ln51"> * The details preservation modes make use of a fast guided filter optimized to perform</a>
<a name="ln52"> * an edge-aware surface blur on the luminance mask, in the same spirit as the bilateral</a>
<a name="ln53"> * filter, but without its classic issues of gradient reversal around sharp edges. This</a>
<a name="ln54"> * surface blur will allow to perform piece-wise smooth exposure compensation, so local contrast</a>
<a name="ln55"> * will be preserved inside contiguous regions. Various mask refinements are provided to help</a>
<a name="ln56"> * the edge-taping of the filter (feathering parameter) while keeping smooth contiguous region</a>
<a name="ln57"> * (quantization parameter), but also to translate (exposure boost) and dilate (contrast boost)</a>
<a name="ln58"> * the exposure histogram through the control octaves, to center it on the control view</a>
<a name="ln59"> * and make maximum use of the available channels.</a>
<a name="ln60"> *</a>
<a name="ln61"> * Users should be aware that not all the available octaves will be useful on every pictures.</a>
<a name="ln62"> * Some automatic options will help them to optimize the luminance mask, performing histogram</a>
<a name="ln63"> * analyse, mapping the average exposure to -4EV, and mapping the first and last deciles of</a>
<a name="ln64"> * the histogram on its average ± 4EV. These automatic helpers usually fail on X-Trans sensors,</a>
<a name="ln65"> * maybe because of bad demosaicing, possibly resulting in outliers\negative RGB values.</a>
<a name="ln66"> * Since they fail the same way on filmic's auto-tuner, we might need to investigate X-Trans</a>
<a name="ln67"> * algos at some point.</a>
<a name="ln68"> *</a>
<a name="ln69">***/</a>
<a name="ln70"> </a>
<a name="ln71">#ifdef HAVE_CONFIG_H</a>
<a name="ln72">#include &quot;config.h&quot;</a>
<a name="ln73">#endif</a>
<a name="ln74">#include &lt;assert.h&gt;</a>
<a name="ln75">#include &lt;math.h&gt;</a>
<a name="ln76">#include &lt;stdlib.h&gt;</a>
<a name="ln77">#include &lt;stdio.h&gt;</a>
<a name="ln78">#include &lt;string.h&gt;</a>
<a name="ln79">#include &lt;time.h&gt;</a>
<a name="ln80"> </a>
<a name="ln81">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln82">#include &quot;common/darktable.h&quot;</a>
<a name="ln83">#include &quot;common/fast_guided_filter.h&quot;</a>
<a name="ln84">#include &quot;common/interpolation.h&quot;</a>
<a name="ln85">#include &quot;common/luminance_mask.h&quot;</a>
<a name="ln86">#include &quot;common/opencl.h&quot;</a>
<a name="ln87">#include &quot;control/conf.h&quot;</a>
<a name="ln88">#include &quot;control/control.h&quot;</a>
<a name="ln89">#include &quot;develop/develop.h&quot;</a>
<a name="ln90">#include &quot;develop/imageop.h&quot;</a>
<a name="ln91">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln92">#include &quot;dtgtk/drawingarea.h&quot;</a>
<a name="ln93">#include &quot;dtgtk/expander.h&quot;</a>
<a name="ln94">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln95">#include &quot;gui/draw.h&quot;</a>
<a name="ln96">#include &quot;gui/gtk.h&quot;</a>
<a name="ln97">#include &quot;gui/presets.h&quot;</a>
<a name="ln98">#include &quot;gui/color_picker_proxy.h&quot;</a>
<a name="ln99">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln100">#include &quot;iop/choleski.h&quot;</a>
<a name="ln101">#include &quot;libs/colorpicker.h&quot;</a>
<a name="ln102">#include &quot;common/iop_group.h&quot;</a>
<a name="ln103"> </a>
<a name="ln104">#ifdef _OPENMP</a>
<a name="ln105">#include &lt;omp.h&gt;</a>
<a name="ln106">#endif</a>
<a name="ln107"> </a>
<a name="ln108"> </a>
<a name="ln109">DT_MODULE_INTROSPECTION(2, dt_iop_toneequalizer_params_t)</a>
<a name="ln110"> </a>
<a name="ln111"> </a>
<a name="ln112">/** Note :</a>
<a name="ln113"> * we use finite-math-only and fast-math because divisions by zero are manually avoided in the code</a>
<a name="ln114"> * fp-contract=fast enables hardware-accelerated Fused Multiply-Add</a>
<a name="ln115"> * the rest is loop reorganization and vectorization optimization</a>
<a name="ln116"> **/</a>
<a name="ln117">#if defined(__GNUC__)</a>
<a name="ln118">#pragma GCC optimize (&quot;unroll-loops&quot;, &quot;tree-loop-if-convert&quot;, \</a>
<a name="ln119">                      &quot;tree-loop-distribution&quot;, &quot;no-strict-aliasing&quot;, \</a>
<a name="ln120">                      &quot;loop-interchange&quot;, &quot;loop-nest-optimize&quot;, &quot;tree-loop-im&quot;, \</a>
<a name="ln121">                      &quot;unswitch-loops&quot;, &quot;tree-loop-ivcanon&quot;, &quot;ira-loop-pressure&quot;, \</a>
<a name="ln122">                      &quot;split-ivs-in-unroller&quot;, &quot;variable-expansion-in-unroller&quot;, \</a>
<a name="ln123">                      &quot;split-loops&quot;, &quot;ivopts&quot;, &quot;predictive-commoning&quot;,\</a>
<a name="ln124">                      &quot;tree-loop-linear&quot;, &quot;loop-block&quot;, &quot;loop-strip-mine&quot;, \</a>
<a name="ln125">                      &quot;finite-math-only&quot;, &quot;fp-contract=fast&quot;, &quot;fast-math&quot;, \</a>
<a name="ln126">                      &quot;tree-vectorize&quot;)</a>
<a name="ln127">#endif</a>
<a name="ln128"> </a>
<a name="ln129">#define UI_SAMPLES 256 // 128 is a bit small for 4K resolution</a>
<a name="ln130">#define CONTRAST_FULCRUM exp2f(-4.0f)</a>
<a name="ln131">#define MIN_FLOAT exp2f(-16.0f)</a>
<a name="ln132"> </a>
<a name="ln133">/**</a>
<a name="ln134"> * Build the exposures octaves : </a>
<a name="ln135"> * band-pass filters with gaussian windows spaced by 1 EV</a>
<a name="ln136">**/</a>
<a name="ln137"> </a>
<a name="ln138">#define CHANNELS 9</a>
<a name="ln139">#define PIXEL_CHAN 8</a>
<a name="ln140"> </a>
<a name="ln141">// radial distances used for pixel ops</a>
<a name="ln142">static const float centers_ops[PIXEL_CHAN] DT_ALIGNED_ARRAY = {-56.0f / 7.0f, // = -8.0f</a>
<a name="ln143">                                                               -48.0f / 7.0f,</a>
<a name="ln144">                                                               -40.0f / 7.0f,</a>
<a name="ln145">                                                               -32.0f / 7.0f,</a>
<a name="ln146">                                                               -24.0f / 7.0f,</a>
<a name="ln147">                                                               -16.0f / 7.0f,</a>
<a name="ln148">                                                                -8.0f / 7.0f,</a>
<a name="ln149">                                                                 0.0f / 7.0f}; // split 8 EV into 7 evenly-spaced channels</a>
<a name="ln150"> </a>
<a name="ln151">static const float centers_params[CHANNELS] DT_ALIGNED_ARRAY = { -8.0f, -7.0f, -6.0f, -5.0f,</a>
<a name="ln152">                                                                 -4.0f, -3.0f, -2.0f, -1.0f, 0.0f};</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">typedef enum dt_iop_toneequalizer_filter_t</a>
<a name="ln156">{</a>
<a name="ln157">  DT_TONEEQ_NONE = 0,</a>
<a name="ln158">  DT_TONEEQ_AVG_GUIDED,</a>
<a name="ln159">  DT_TONEEQ_GUIDED,</a>
<a name="ln160">} dt_iop_toneequalizer_filter_t;</a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163">typedef struct dt_iop_toneequalizer_params_t</a>
<a name="ln164">{</a>
<a name="ln165">  float noise, ultra_deep_blacks, deep_blacks, blacks, shadows, midtones, highlights, whites, speculars;</a>
<a name="ln166">  float blending, smoothing, feathering, quantization, contrast_boost, exposure_boost;</a>
<a name="ln167">  dt_iop_toneequalizer_filter_t details;</a>
<a name="ln168">  dt_iop_luminance_mask_method_t method;</a>
<a name="ln169">  int iterations;</a>
<a name="ln170">} dt_iop_toneequalizer_params_t;</a>
<a name="ln171"> </a>
<a name="ln172"> </a>
<a name="ln173">typedef struct dt_iop_toneequalizer_data_t</a>
<a name="ln174">{</a>
<a name="ln175">  float factors[PIXEL_CHAN] DT_ALIGNED_ARRAY;</a>
<a name="ln176">  float blending, feathering, contrast_boost, exposure_boost, quantization, smoothing;</a>
<a name="ln177">  float scale;</a>
<a name="ln178">  int radius;</a>
<a name="ln179">  int iterations;</a>
<a name="ln180">  dt_iop_luminance_mask_method_t method;</a>
<a name="ln181">  dt_iop_toneequalizer_filter_t details;</a>
<a name="ln182">} dt_iop_toneequalizer_data_t;</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185">typedef struct dt_iop_toneequalizer_global_data_t</a>
<a name="ln186">{</a>
<a name="ln187">  // TODO: put OpenCL kernels here at some point</a>
<a name="ln188">} dt_iop_toneequalizer_global_data_t;</a>
<a name="ln189"> </a>
<a name="ln190"> </a>
<a name="ln191">typedef struct dt_iop_toneequalizer_gui_data_t</a>
<a name="ln192">{</a>
<a name="ln193">  // Mem arrays 64-bits aligned - contiguous memory</a>
<a name="ln194">  float factors[PIXEL_CHAN] DT_ALIGNED_ARRAY;</a>
<a name="ln195">  float gui_lut[UI_SAMPLES] DT_ALIGNED_ARRAY; // LUT for the UI graph</a>
<a name="ln196">  float interpolation_matrix[CHANNELS * PIXEL_CHAN] DT_ALIGNED_ARRAY;</a>
<a name="ln197">  int histogram[UI_SAMPLES] DT_ALIGNED_ARRAY; // histogram for the UI graph</a>
<a name="ln198">  float temp_user_params[CHANNELS] DT_ALIGNED_ARRAY;</a>
<a name="ln199">  float cursor_exposure; // store the exposure value at current cursor position</a>
<a name="ln200">  float step; // scrolling step</a>
<a name="ln201"> </a>
<a name="ln202">  // 14 int to pack - contiguous memory</a>
<a name="ln203">  int mask_display;</a>
<a name="ln204">  int max_histogram;</a>
<a name="ln205">  int buf_width;</a>
<a name="ln206">  int buf_height;</a>
<a name="ln207">  int cursor_pos_x;</a>
<a name="ln208">  int cursor_pos_y;</a>
<a name="ln209">  int pipe_order;</a>
<a name="ln210"> </a>
<a name="ln211">  // 6 uint64 to pack - contiguous-ish memory</a>
<a name="ln212">  uint64_t ui_preview_hash;</a>
<a name="ln213">  uint64_t thumb_preview_hash;</a>
<a name="ln214">  size_t full_preview_buf_width, full_preview_buf_height;</a>
<a name="ln215">  size_t thumb_preview_buf_width, thumb_preview_buf_height;</a>
<a name="ln216"> </a>
<a name="ln217">  // Misc stuff, contiguity, length and alignment unknown</a>
<a name="ln218">  float scale;</a>
<a name="ln219">  float sigma;</a>
<a name="ln220">  float histogram_average;</a>
<a name="ln221">  float histogram_first_decile;</a>
<a name="ln222">  float histogram_last_decile;</a>
<a name="ln223">  dt_pthread_mutex_t lock;</a>
<a name="ln224"> </a>
<a name="ln225">  // Heap arrays, 64 bits-aligned, unknown length</a>
<a name="ln226">  float *thumb_preview_buf;</a>
<a name="ln227">  float *full_preview_buf;</a>
<a name="ln228"> </a>
<a name="ln229">  // GTK garbage, nobody cares, no SIMD here</a>
<a name="ln230">  GtkWidget *noise, *ultra_deep_blacks, *deep_blacks, *blacks, *shadows, *midtones, *highlights, *whites, *speculars;</a>
<a name="ln231">  GtkDrawingArea *area, *bar;</a>
<a name="ln232">  GtkWidget *colorpicker;</a>
<a name="ln233">  dt_iop_color_picker_t color_picker;</a>
<a name="ln234">  GtkWidget *blending, *smoothing, *quantization;</a>
<a name="ln235">  GtkWidget *method;</a>
<a name="ln236">  GtkWidget *details, *feathering, *contrast_boost, *iterations, *exposure_boost;</a>
<a name="ln237">  GtkNotebook *notebook;</a>
<a name="ln238">  GtkWidget *show_luminance_mask;</a>
<a name="ln239"> </a>
<a name="ln240">  // Cache Pango and Cairo stuff for the equalizer drawing</a>
<a name="ln241">  float line_height;</a>
<a name="ln242">  float sign_width;</a>
<a name="ln243">  float graph_width;</a>
<a name="ln244">  float graph_height;</a>
<a name="ln245">  float gradient_left_limit;</a>
<a name="ln246">  float gradient_right_limit;</a>
<a name="ln247">  float gradient_top_limit;</a>
<a name="ln248">  float gradient_width;</a>
<a name="ln249">  float legend_top_limit;</a>
<a name="ln250">  float x_label;</a>
<a name="ln251">  int inset;</a>
<a name="ln252">  int inner_padding;</a>
<a name="ln253"> </a>
<a name="ln254">  GtkAllocation allocation;</a>
<a name="ln255">  cairo_surface_t *cst;</a>
<a name="ln256">  cairo_t *cr;</a>
<a name="ln257">  PangoLayout *layout;</a>
<a name="ln258">  PangoRectangle ink;</a>
<a name="ln259">  PangoFontDescription *desc;</a>
<a name="ln260">  GtkStyleContext *context;</a>
<a name="ln261"> </a>
<a name="ln262">  // Event for equalizer drawing</a>
<a name="ln263">  float nodes_x[CHANNELS];</a>
<a name="ln264">  float nodes_y[CHANNELS];</a>
<a name="ln265">  float area_x; // x coordinate of cursor over graph/drawing area</a>
<a name="ln266">  float area_y; // y coordinate</a>
<a name="ln267">  int area_active_node;</a>
<a name="ln268"> </a>
<a name="ln269">  // Flags for UI events</a>
<a name="ln270">  int valid_nodes_x;        // TRUE if x coordinates of graph nodes have been inited</a>
<a name="ln271">  int valid_nodes_y;        // TRUE if y coordinates of graph nodes have been inited</a>
<a name="ln272">  int area_cursor_valid;    // TRUE if mouse cursor is over the graph area</a>
<a name="ln273">  int area_dragging;        // TRUE if left-button has been pushed but not released and cursor motion is recorded</a>
<a name="ln274">  int cursor_valid;         // TRUE if mouse cursor is over the preview image</a>
<a name="ln275"> </a>
<a name="ln276">  // Flags for buffer caches invalidation</a>
<a name="ln277">  int interpolation_valid;  // TRUE if the interpolation_matrix is ready</a>
<a name="ln278">  int luminance_valid;      // TRUE if the luminance cache is ready</a>
<a name="ln279">  int histogram_valid;      // TRUE if the histogram cache and stats are ready</a>
<a name="ln280">  int lut_valid;            // TRUE if the gui_lut is ready</a>
<a name="ln281">  int graph_valid;          // TRUE if the UI graph view is ready</a>
<a name="ln282">  int user_param_valid;     // TRUE if users params set in interactive view are in bounds</a>
<a name="ln283">  int factors_valid;        // TRUE if radial-basis coeffs are ready</a>
<a name="ln284"> </a>
<a name="ln285">} dt_iop_toneequalizer_gui_data_t;</a>
<a name="ln286"> </a>
<a name="ln287"> </a>
<a name="ln288">const char *name()</a>
<a name="ln289">{</a>
<a name="ln290">  return _(&quot;tone equalizer&quot;);</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293">int default_group()</a>
<a name="ln294">{</a>
<a name="ln295">  return IOP_GROUP_BASIC;</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">int flags()</a>
<a name="ln299">{</a>
<a name="ln300">  return IOP_FLAGS_INCLUDE_IN_STYLES | IOP_FLAGS_SUPPORTS_BLENDING;</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln304">{</a>
<a name="ln305">  return iop_cs_rgb;</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln309">{</a>
<a name="ln310">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;blacks&quot;));</a>
<a name="ln311">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;deep shadows&quot;));</a>
<a name="ln312">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;shadows&quot;));</a>
<a name="ln313">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;light shadows&quot;));</a>
<a name="ln314">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;midtones&quot;));</a>
<a name="ln315">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;dark highlights&quot;));</a>
<a name="ln316">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;highlights&quot;));</a>
<a name="ln317">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;whites&quot;));</a>
<a name="ln318">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;speculars&quot;));</a>
<a name="ln319">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;filter diffusion&quot;));</a>
<a name="ln320">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;smoothing diameter&quot;));</a>
<a name="ln321">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;edges refinement/feathering&quot;));</a>
<a name="ln322">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;mask quantization&quot;));</a>
<a name="ln323">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;mask exposure compensation&quot;));</a>
<a name="ln324">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;mask contrast compensation&quot;));</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln328">{</a>
<a name="ln329">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln330"> </a>
<a name="ln331">  dt_accel_connect_slider_iop(self, &quot;blacks&quot;, GTK_WIDGET(g-&gt;noise));</a>
<a name="ln332">  dt_accel_connect_slider_iop(self, &quot;deep shadows&quot;, GTK_WIDGET(g-&gt;ultra_deep_blacks));</a>
<a name="ln333">  dt_accel_connect_slider_iop(self, &quot;shadows&quot;, GTK_WIDGET(g-&gt;deep_blacks));</a>
<a name="ln334">  dt_accel_connect_slider_iop(self, &quot;light shadows&quot;, GTK_WIDGET(g-&gt;blacks));</a>
<a name="ln335">  dt_accel_connect_slider_iop(self, &quot;midtones&quot;, GTK_WIDGET(g-&gt;shadows));</a>
<a name="ln336">  dt_accel_connect_slider_iop(self, &quot;dark highlights&quot;, GTK_WIDGET(g-&gt;midtones));</a>
<a name="ln337">  dt_accel_connect_slider_iop(self, &quot;highlights&quot;, GTK_WIDGET(g-&gt;highlights));</a>
<a name="ln338">  dt_accel_connect_slider_iop(self, &quot;whites&quot;, GTK_WIDGET(g-&gt;whites));</a>
<a name="ln339">  dt_accel_connect_slider_iop(self, &quot;speculars&quot;, GTK_WIDGET(g-&gt;speculars));</a>
<a name="ln340">  dt_accel_connect_slider_iop(self, &quot;filter diffusion&quot;, GTK_WIDGET(g-&gt;iterations));</a>
<a name="ln341">  dt_accel_connect_slider_iop(self, &quot;smoothing diameter&quot;, GTK_WIDGET(g-&gt;blending));</a>
<a name="ln342">  dt_accel_connect_slider_iop(self, &quot;edges refinement/feathering&quot;, GTK_WIDGET(g-&gt;feathering));</a>
<a name="ln343">  dt_accel_connect_slider_iop(self, &quot;mask quantization&quot;, GTK_WIDGET(g-&gt;quantization));</a>
<a name="ln344">  dt_accel_connect_slider_iop(self, &quot;mask exposure compensation&quot;, GTK_WIDGET(g-&gt;exposure_boost));</a>
<a name="ln345">  dt_accel_connect_slider_iop(self, &quot;mask contrast compensation&quot;, GTK_WIDGET(g-&gt;contrast_boost));</a>
<a name="ln346"> </a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version, void *new_params,</a>
<a name="ln350">                  const int new_version)</a>
<a name="ln351">{</a>
<a name="ln352">  if(old_version == 1 &amp;&amp; new_version == 2)</a>
<a name="ln353">  {</a>
<a name="ln354">    typedef struct dt_iop_toneequalizer_params_v1_t</a>
<a name="ln355">    {</a>
<a name="ln356">      float noise, ultra_deep_blacks, deep_blacks, blacks, shadows, midtones, highlights, whites, speculars;</a>
<a name="ln357">      float blending, feathering, contrast_boost, exposure_boost;</a>
<a name="ln358">      dt_iop_toneequalizer_filter_t details;</a>
<a name="ln359">      int iterations;</a>
<a name="ln360">      dt_iop_luminance_mask_method_t method;</a>
<a name="ln361">    } dt_iop_toneequalizer_params_v1_t;</a>
<a name="ln362"> </a>
<a name="ln363">    dt_iop_toneequalizer_params_v1_t *o = (dt_iop_toneequalizer_params_v1_t *)old_params;</a>
<a name="ln364">    dt_iop_toneequalizer_params_t *n = (dt_iop_toneequalizer_params_t *)new_params;</a>
<a name="ln365">    dt_iop_toneequalizer_params_t *d = (dt_iop_toneequalizer_params_t *)self-&gt;default_params;</a>
<a name="ln366"> </a>
<a name="ln367">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln368"> </a>
<a name="ln369">    // Olds params</a>
<a name="ln370">    n-&gt;noise = o-&gt;noise;</a>
<a name="ln371">    n-&gt;ultra_deep_blacks = o-&gt;ultra_deep_blacks;</a>
<a name="ln372">    n-&gt;deep_blacks = o-&gt;deep_blacks;</a>
<a name="ln373">    n-&gt;blacks = o-&gt;blacks;</a>
<a name="ln374">    n-&gt;shadows = o-&gt;shadows;</a>
<a name="ln375">    n-&gt;midtones = o-&gt;midtones;</a>
<a name="ln376">    n-&gt;highlights = o-&gt;highlights;</a>
<a name="ln377">    n-&gt;whites = o-&gt;whites;</a>
<a name="ln378">    n-&gt;speculars = o-&gt;speculars;</a>
<a name="ln379"> </a>
<a name="ln380">    n-&gt;blending = o-&gt;blending;</a>
<a name="ln381">    n-&gt;feathering = o-&gt;feathering;</a>
<a name="ln382">    n-&gt;contrast_boost = o-&gt;contrast_boost;</a>
<a name="ln383">    n-&gt;exposure_boost = o-&gt;exposure_boost;</a>
<a name="ln384"> </a>
<a name="ln385">    n-&gt;details = o-&gt;details;</a>
<a name="ln386">    n-&gt;iterations = o-&gt;iterations;</a>
<a name="ln387">    n-&gt;method = o-&gt;method;</a>
<a name="ln388"> </a>
<a name="ln389">    // New params</a>
<a name="ln390">    n-&gt;quantization = 0.01f;</a>
<a name="ln391">    n-&gt;smoothing = sqrtf(2.0f);</a>
<a name="ln392">    return 0;</a>
<a name="ln393">  }</a>
<a name="ln394"> </a>
<a name="ln395">  return 1;</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">void init_presets(dt_iop_module_so_t *self)</a>
<a name="ln399">{</a>
<a name="ln400">  dt_iop_toneequalizer_params_t p;</a>
<a name="ln401">  memset(&amp;p, 0, sizeof(p));</a>
<a name="ln402"> </a>
<a name="ln403">  p.method = DT_TONEEQ_NORM_POWER;</a>
<a name="ln404">  p.contrast_boost = 0.0f;</a>
<a name="ln405">  p.details = DT_TONEEQ_NONE;</a>
<a name="ln406">  p.exposure_boost = 0.0f;</a>
<a name="ln407">  p.feathering = 1.0f;</a>
<a name="ln408">  p.iterations = 1;</a>
<a name="ln409">  p.smoothing = sqrtf(2.0f);</a>
<a name="ln410">  p.quantization = 0.0f;</a>
<a name="ln411"> </a>
<a name="ln412">  // Init exposure settings</a>
<a name="ln413">  p.noise = p.ultra_deep_blacks = p.deep_blacks = p.blacks = p.shadows = p.midtones = p.highlights = p.whites = p. speculars = 0.0f;</a>
<a name="ln414"> </a>
<a name="ln415">  // No blending</a>
<a name="ln416">  dt_gui_presets_add_generic(_(&quot;mask blending : none&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln417"> </a>
<a name="ln418">  // Simple utils blendings</a>
<a name="ln419">  p.details = DT_TONEEQ_GUIDED;</a>
<a name="ln420">  p.method = DT_TONEEQ_NORM_2;</a>
<a name="ln421"> </a>
<a name="ln422">  p.blending = 12.5f;</a>
<a name="ln423">  p.feathering = 5.0f;</a>
<a name="ln424">  p.iterations = 3;</a>
<a name="ln425">  p.quantization = 1.0f;</a>
<a name="ln426">  p.exposure_boost = -1.0f;</a>
<a name="ln427">  p.contrast_boost = 2.0f;</a>
<a name="ln428">  dt_gui_presets_add_generic(_(&quot;mask blending : landscapes&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln429"> </a>
<a name="ln430">  p.blending = 25.0f;</a>
<a name="ln431">  p.feathering = 5.0f;</a>
<a name="ln432">  p.iterations = 2;</a>
<a name="ln433">  p.quantization = 1.0f;</a>
<a name="ln434">  p.exposure_boost = -1.5f;</a>
<a name="ln435">  p.contrast_boost = 3.0f;</a>
<a name="ln436">  dt_gui_presets_add_generic(_(&quot;mask blending : all purposes&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln437"> </a>
<a name="ln438">  p.blending = 25.0f;</a>
<a name="ln439">  p.feathering = 25.0f;</a>
<a name="ln440">  p.iterations = 4;</a>
<a name="ln441">  p.quantization = 1.0f;</a>
<a name="ln442">  p.exposure_boost = -1.5f;</a>
<a name="ln443">  p.contrast_boost = 3.0f;</a>
<a name="ln444">  dt_gui_presets_add_generic(_(&quot;mask blending : isolated subjects&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln445"> </a>
<a name="ln446">  // Shadows/highlights presets</a>
<a name="ln447"> </a>
<a name="ln448">  p.blending = 25.0f;</a>
<a name="ln449">  p.feathering = 10.0f;</a>
<a name="ln450">  p.iterations = 2;</a>
<a name="ln451">  p.quantization = 1.0f;</a>
<a name="ln452">  p.exposure_boost = -1.5f;</a>
<a name="ln453">  p.contrast_boost = 3.0f;</a>
<a name="ln454"> </a>
<a name="ln455">  p.noise = 0.05f;</a>
<a name="ln456">  p.ultra_deep_blacks = 0.15f;</a>
<a name="ln457">  p.deep_blacks = 0.25f;</a>
<a name="ln458">  p.blacks = 0.55f;</a>
<a name="ln459">  p.shadows = 0.72f;</a>
<a name="ln460">  p.midtones = 0.55f;</a>
<a name="ln461">  p.highlights = 0.0f;</a>
<a name="ln462">  p.whites = -0.33f;</a>
<a name="ln463">  p.speculars = 0.0f;</a>
<a name="ln464"> </a>
<a name="ln465">  dt_gui_presets_add_generic(_(&quot;compress shadows/highlights : soft&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln466"> </a>
<a name="ln467">  p.blending = 12.5f;</a>
<a name="ln468">  p.feathering = 20.0f;</a>
<a name="ln469">  p.iterations = 3;</a>
<a name="ln470">  p.quantization = 1.0f;</a>
<a name="ln471">  p.exposure_boost = -1.0f;</a>
<a name="ln472">  p.contrast_boost = 2.0f;</a>
<a name="ln473"> </a>
<a name="ln474">  p.noise = 0.5f;</a>
<a name="ln475">  p.ultra_deep_blacks = 0.9f;</a>
<a name="ln476">  p.deep_blacks = 1.25f;</a>
<a name="ln477">  p.blacks = 1.40f;</a>
<a name="ln478">  p.shadows = 1.25f;</a>
<a name="ln479">  p.midtones = 0.72f;</a>
<a name="ln480">  p.highlights = -0.15f;</a>
<a name="ln481">  p.whites = -0.55f;</a>
<a name="ln482">  p.speculars = -0.2f;</a>
<a name="ln483"> </a>
<a name="ln484">  dt_gui_presets_add_generic(_(&quot;compress shadows/highlights : strong&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln485"> </a>
<a name="ln486">  p.blending = 25.0f;</a>
<a name="ln487">  p.feathering = 10.0f;</a>
<a name="ln488">  p.iterations = 2;</a>
<a name="ln489">  p.quantization = 1.0f;</a>
<a name="ln490">  p.exposure_boost = -1.5f;</a>
<a name="ln491">  p.contrast_boost = 3.0f;</a>
<a name="ln492"> </a>
<a name="ln493">  p.noise = 0.0f;</a>
<a name="ln494">  p.ultra_deep_blacks = 0.15f;</a>
<a name="ln495">  p.deep_blacks = 0.6f;</a>
<a name="ln496">  p.blacks = 1.15f;</a>
<a name="ln497">  p.shadows = 1.33f;</a>
<a name="ln498">  p.midtones = 1.15f;</a>
<a name="ln499">  p.highlights = 0.6f;</a>
<a name="ln500">  p.whites = 0.15f;</a>
<a name="ln501">  p.speculars = 0.0f;</a>
<a name="ln502"> </a>
<a name="ln503">  dt_gui_presets_add_generic(_(&quot;relight : fill-in&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln504"> </a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507"> </a>
<a name="ln508">/**</a>
<a name="ln509"> * Helper functions</a>
<a name="ln510"> **/</a>
<a name="ln511"> </a>
<a name="ln512">static gboolean in_mask_editing(dt_iop_module_t *self)</a>
<a name="ln513">{</a>
<a name="ln514">  const dt_develop_t *dev = self-&gt;dev;</a>
<a name="ln515">  return dev-&gt;form_gui &amp;&amp; dev-&gt;form_visible;</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">static void hash_set_get(uint64_t *hash_in, uint64_t *hash_out, dt_pthread_mutex_t *lock)</a>
<a name="ln519">{</a>
<a name="ln520">  // Set or get a hash in a struct the thread-safe way</a>
<a name="ln521">  dt_pthread_mutex_lock(lock);</a>
<a name="ln522">  *hash_out = *hash_in;</a>
<a name="ln523">  dt_pthread_mutex_unlock(lock);</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526"> </a>
<a name="ln527">static void invalidate_luminance_cache(dt_iop_module_t *self)</a>
<a name="ln528">{</a>
<a name="ln529">  // Invalidate the private luminance cache and histogram when</a>
<a name="ln530">  // the luminance mask extraction parameters have changed</a>
<a name="ln531">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln532"> </a>
<a name="ln533">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln534">  g-&gt;max_histogram = 1;</a>
<a name="ln535">  //g-&gt;luminance_valid = 0;</a>
<a name="ln536">  g-&gt;histogram_valid = 0;</a>
<a name="ln537">  g-&gt;thumb_preview_hash = 0;</a>
<a name="ln538">  g-&gt;ui_preview_hash = 0;</a>
<a name="ln539">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542"> </a>
<a name="ln543">static int sanity_check(dt_iop_module_t *self)</a>
<a name="ln544">{</a>
<a name="ln545">  // If tone equalizer is put after flip/orientation module,</a>
<a name="ln546">  // the pixel buffer will be in landscape orientation even for pictures displayed in portrait orientation</a>
<a name="ln547">  // so the interactive editing will fail. Disable the module and issue a warning then.</a>
<a name="ln548"> </a>
<a name="ln549">  const double position_self = self-&gt;iop_order;</a>
<a name="ln550">  const double position_min = dt_ioppr_get_iop_order(self-&gt;dev-&gt;iop_order_list, &quot;flip&quot;);</a>
<a name="ln551"> </a>
<a name="ln552">  if(position_self &lt; position_min &amp;&amp; self-&gt;enabled)</a>
<a name="ln553">  {</a>
<a name="ln554">    dt_control_log(_(&quot;tone equalizer needs to be after distorsion modules in the pipeline – disabled&quot;));</a>
<a name="ln555">    fprintf(stdout, &quot;tone equalizer needs to be after distorsion modules in the pipeline – disabled\n&quot;);</a>
<a name="ln556">    self-&gt;enabled = 0;</a>
<a name="ln557">    dt_dev_add_history_item(darktable.develop, self, FALSE);</a>
<a name="ln558"> </a>
<a name="ln559">    if(self-&gt;dev-&gt;gui_attached)</a>
<a name="ln560">    {</a>
<a name="ln561">      // Repaint the on/off icon</a>
<a name="ln562">      if(self-&gt;off)</a>
<a name="ln563">      {</a>
<a name="ln564">        const int reset = darktable.gui-&gt;reset;</a>
<a name="ln565">        darktable.gui-&gt;reset = 1;</a>
<a name="ln566">        gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self-&gt;off), self-&gt;enabled);</a>
<a name="ln567">        darktable.gui-&gt;reset = reset;</a>
<a name="ln568">      }</a>
<a name="ln569">    }</a>
<a name="ln570">    return 0;</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  return 1;</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">__DT_CLONE_TARGETS__</a>
<a name="ln577">static float get_luminance_from_buffer(const float *const buffer,</a>
<a name="ln578">                                       const size_t width, const size_t height,</a>
<a name="ln579">                                       const size_t x, const size_t y)</a>
<a name="ln580">{</a>
<a name="ln581">  // Get the weighted average luminance of the 3×3 pixels region centered in (x, y)</a>
<a name="ln582">  // x and y are ratios in [0, 1] of the width and height</a>
<a name="ln583"> </a>
<a name="ln584">  if(y &gt;= height || x &gt;= width) return NAN;</a>
<a name="ln585"> </a>
<a name="ln586">  const size_t y_abs[3] = { CLAMP(y - 1, 0, height - 1),    // previous line</a>
<a name="ln587">                            y,                              // center line</a>
<a name="ln588">                            CLAMP(y + 1, 0, height - 1) };  // next line</a>
<a name="ln589"> </a>
<a name="ln590">  const size_t x_abs[3] = { CLAMP(x - 1, 0, width - 1),     // previous column</a>
<a name="ln591">                            x,                              // center column</a>
<a name="ln592">                            CLAMP(x + 1, 0, width - 1) };   // next column</a>
<a name="ln593"> </a>
<a name="ln594">  // gaussian-ish kernel - sum is == 1.0f so we don't care much about actual coeffs</a>
<a name="ln595">  const float gauss_kernel[3][3] DT_ALIGNED_ARRAY =</a>
<a name="ln596">                                   { { 0.076555024f, 0.124401914f, 0.076555024f },</a>
<a name="ln597">                                     { 0.124401914f, 0.196172249f, 0.124401914f },</a>
<a name="ln598">                                     { 0.076555024f, 0.124401914f, 0.076555024f } };</a>
<a name="ln599"> </a>
<a name="ln600">  float luminance = 0.0f;</a>
<a name="ln601"> </a>
<a name="ln602">  // convolution</a>
<a name="ln603">  for(int i = 0; i &lt; 3; ++i)</a>
<a name="ln604">    for(int j = 0; j &lt; 3; ++j)</a>
<a name="ln605">      luminance += buffer[width * y_abs[i] + x_abs[j]] * gauss_kernel[i][j];</a>
<a name="ln606"> </a>
<a name="ln607">  return luminance;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610"> </a>
<a name="ln611">/***</a>
<a name="ln612"> * Exposure compensation computation</a>
<a name="ln613"> *</a>
<a name="ln614"> * Construct the final correction factor by summing the octaves channels gains weighted by</a>
<a name="ln615"> * the gaussian of the radial distance (pixel exposure - octave center)</a>
<a name="ln616"> *</a>
<a name="ln617"> ***/</a>
<a name="ln618"> </a>
<a name="ln619">#ifdef _OPENMP</a>
<a name="ln620">#pragma omp declare simd</a>
<a name="ln621">#endif</a>
<a name="ln622">__DT_CLONE_TARGETS__</a>
<a name="ln623">static float gaussian_denom(const float sigma)</a>
<a name="ln624">{</a>
<a name="ln625">  // Gaussian function denominator such that y = exp(- radius^2 / denominator)</a>
<a name="ln626">  // this is the constant factor of the exponential, so we don't need to recompute it</a>
<a name="ln627">  // for every single pixel</a>
<a name="ln628">  return 2.0f * sigma * sigma;</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631"> </a>
<a name="ln632">#ifdef _OPENMP</a>
<a name="ln633">#pragma omp declare simd</a>
<a name="ln634">#endif</a>
<a name="ln635">__DT_CLONE_TARGETS__</a>
<a name="ln636">static float gaussian_func(const float radius, const float denominator)</a>
<a name="ln637">{</a>
<a name="ln638">  // Gaussian function without normalization</a>
<a name="ln639">  // this is the variable part of the exponential</a>
<a name="ln640">  // the denominator should be evaluated with `gaussian_denom`</a>
<a name="ln641">  // ahead of the array loop for optimal performance</a>
<a name="ln642">  return expf(- radius * radius / denominator);</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645">__DT_CLONE_TARGETS__</a>
<a name="ln646">static inline void compute_correction(const float *const restrict luminance,</a>
<a name="ln647">                                      float *const restrict correction,</a>
<a name="ln648">                                      const float *const restrict factors,</a>
<a name="ln649">                                      const float sigma,</a>
<a name="ln650">                                      const size_t num_elem)</a>
<a name="ln651">{</a>
<a name="ln652">  const float gauss_denom = gaussian_denom(sigma);</a>
<a name="ln653"> </a>
<a name="ln654">#ifdef _OPENMP</a>
<a name="ln655">#pragma omp parallel for default(none) schedule(static) \</a>
<a name="ln656">  dt_omp_firstprivate(correction, num_elem, luminance, factors, centers_ops, gauss_denom)</a>
<a name="ln657">#endif</a>
<a name="ln658">  for(size_t k = 0; k &lt; num_elem; ++k)</a>
<a name="ln659">  {</a>
<a name="ln660">    // build the correction for the current pixel</a>
<a name="ln661">    // as the sum of the contribution of each luminance channelcorrection</a>
<a name="ln662">    float result = 0.0f;</a>
<a name="ln663">    const float exposure = log2f(luminance[k]);</a>
<a name="ln664"> </a>
<a name="ln665">#ifdef _OPENMP</a>
<a name="ln666">#pragma omp simd aligned(luminance, centers_ops, factors:64) safelen(PIXEL_CHAN) reduction(+:result)</a>
<a name="ln667">#endif</a>
<a name="ln668">    for(int i = 0; i &lt; PIXEL_CHAN; ++i)</a>
<a name="ln669">      result += gaussian_func(exposure - centers_ops[i], gauss_denom) * factors[i];</a>
<a name="ln670"> </a>
<a name="ln671">    correction[k] = result;</a>
<a name="ln672">  }</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675"> </a>
<a name="ln676">__DT_CLONE_TARGETS__</a>
<a name="ln677">static float pixel_correction(const float exposure,</a>
<a name="ln678">                              const float *const restrict factors,</a>
<a name="ln679">                              const float sigma)</a>
<a name="ln680">{</a>
<a name="ln681">  // build the correction for the current pixel</a>
<a name="ln682">  // as the sum of the contribution of each luminance channel</a>
<a name="ln683">  float result = 0.0f;</a>
<a name="ln684">  const float gauss_denom = gaussian_denom(sigma);</a>
<a name="ln685"> </a>
<a name="ln686">#ifdef _OPENMP</a>
<a name="ln687">#pragma omp simd aligned(centers_ops, factors:64) safelen(PIXEL_CHAN) reduction(+:result)</a>
<a name="ln688">#endif</a>
<a name="ln689">  for(int i = 0; i &lt; PIXEL_CHAN; ++i)</a>
<a name="ln690">    result += gaussian_func(exposure - centers_ops[i], gauss_denom) * factors[i];</a>
<a name="ln691"> </a>
<a name="ln692">  return result;</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695"> </a>
<a name="ln696">__DT_CLONE_TARGETS__</a>
<a name="ln697">static inline void compute_luminance_mask(const float *const restrict in, float *const restrict luminance,</a>
<a name="ln698">                                          const size_t width, const size_t height, const size_t ch,</a>
<a name="ln699">                                          const dt_iop_toneequalizer_data_t *const d)</a>
<a name="ln700">{</a>
<a name="ln701">  switch(d-&gt;details)</a>
<a name="ln702">  {</a>
<a name="ln703">    case(DT_TONEEQ_NONE):</a>
<a name="ln704">    {</a>
<a name="ln705">      // No contrast boost here</a>
<a name="ln706">      luminance_mask(in, luminance, width, height, ch, d-&gt;method, d-&gt;exposure_boost, 0.0f, 1.0f);</a>
<a name="ln707">      break;</a>
<a name="ln708">    }</a>
<a name="ln709"> </a>
<a name="ln710">    case(DT_TONEEQ_AVG_GUIDED):</a>
<a name="ln711">    {</a>
<a name="ln712">      // Still no contrast boost</a>
<a name="ln713">      luminance_mask(in, luminance, width, height, ch, d-&gt;method, d-&gt;exposure_boost, 0.0f, 1.0f);</a>
<a name="ln714">      fast_surface_blur(luminance, width, height, d-&gt;radius, d-&gt;feathering, d-&gt;iterations,</a>
<a name="ln715">                    DT_GF_BLENDING_GEOMEAN, d-&gt;scale, d-&gt;quantization, exp2f(-8.0f), 1.0f);</a>
<a name="ln716">      break;</a>
<a name="ln717">    }</a>
<a name="ln718"> </a>
<a name="ln719">    case(DT_TONEEQ_GUIDED):</a>
<a name="ln720">    {</a>
<a name="ln721">      // Contrast boosting is done around the average luminance of the mask.</a>
<a name="ln722">      // This is to make exposure corrections easier to control for users, by spreading</a>
<a name="ln723">      // the dynamic range along all exposure channels, because guided filters</a>
<a name="ln724">      // tend to flatten the luminance mask a lot around an average ± 2 EV</a>
<a name="ln725">      // which makes only 2-3 channels usable.</a>
<a name="ln726">      // we assume the distribution is centered around -4EV, e.g. the center of the nodes</a>
<a name="ln727">      // the exposure boost should be used to make this assumption true</a>
<a name="ln728">      luminance_mask(in, luminance, width, height, ch, d-&gt;method, d-&gt;exposure_boost,</a>
<a name="ln729">                      CONTRAST_FULCRUM, d-&gt;contrast_boost);</a>
<a name="ln730">      fast_surface_blur(luminance, width, height, d-&gt;radius, d-&gt;feathering, d-&gt;iterations,</a>
<a name="ln731">                    DT_GF_BLENDING_LINEAR, d-&gt;scale, d-&gt;quantization, exp2f(-8.0f), 1.0f);</a>
<a name="ln732">      break;</a>
<a name="ln733">    }</a>
<a name="ln734"> </a>
<a name="ln735">    default:</a>
<a name="ln736">    {</a>
<a name="ln737">      luminance_mask(in, luminance, width, height, ch, d-&gt;method, d-&gt;exposure_boost, 0.0f, 1.0f);</a>
<a name="ln738">      break;</a>
<a name="ln739">    }</a>
<a name="ln740">  }</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743"> </a>
<a name="ln744">/***</a>
<a name="ln745"> * Actual transfer functions</a>
<a name="ln746"> **/</a>
<a name="ln747"> </a>
<a name="ln748">__DT_CLONE_TARGETS__</a>
<a name="ln749">static inline void display_luminance_mask(const float *const restrict luminance,</a>
<a name="ln750">                                          float *const restrict out,</a>
<a name="ln751">                                          const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln752">                                          const size_t ch)</a>
<a name="ln753">{</a>
<a name="ln754">  const size_t offset_x = (roi_in-&gt;x &lt; roi_out-&gt;x) ? -roi_in-&gt;x + roi_out-&gt;x : 0;</a>
<a name="ln755">  const size_t offset_y = (roi_in-&gt;y &lt; roi_out-&gt;y) ? -roi_in-&gt;y + roi_out-&gt;y : 0;</a>
<a name="ln756"> </a>
<a name="ln757">  // The output dimensions need to be smaller or equal to the input ones</a>
<a name="ln758">  // there is no logical reason they shouldn't, except some weird bug in the pipe</a>
<a name="ln759">  // in this case, ensure we don't segfault</a>
<a name="ln760">  const size_t in_width = roi_in-&gt;width;</a>
<a name="ln761">  const size_t out_width = (roi_in-&gt;width &gt; roi_out-&gt;width) ? roi_out-&gt;width : roi_in-&gt;width;</a>
<a name="ln762">  const size_t out_height = (roi_in-&gt;height &gt; roi_out-&gt;height) ? roi_out-&gt;height : roi_in-&gt;height;</a>
<a name="ln763"> </a>
<a name="ln764">#ifdef _OPENMP</a>
<a name="ln765">#pragma omp parallel for simd default(none) \</a>
<a name="ln766">dt_omp_firstprivate(luminance, out, in_width, out_width, out_height, offset_x, offset_y, ch) \</a>
<a name="ln767">schedule(static) aligned(luminance, out:64) collapse(3)</a>
<a name="ln768">#endif</a>
<a name="ln769">  for(size_t i = 0 ; i &lt; out_height; ++i)</a>
<a name="ln770">    for(size_t j = 0; j &lt; out_width; ++j)</a>
<a name="ln771">      for(size_t c = 0; c &lt; ch; ++c)</a>
<a name="ln772">        out[(i * out_width + j) * ch + c] = luminance[(i + offset_y) * in_width  + (j + offset_x)];</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775"> </a>
<a name="ln776">__DT_CLONE_TARGETS__</a>
<a name="ln777">static inline void apply_exposure(const float *const restrict in, float *const restrict out,</a>
<a name="ln778">                                  const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln779">                                  const size_t ch,</a>
<a name="ln780">                                  const float *const restrict correction)</a>
<a name="ln781">{</a>
<a name="ln782">  const size_t offset_x = (roi_in-&gt;x &lt; roi_out-&gt;x) ? -roi_in-&gt;x + roi_out-&gt;x : 0;</a>
<a name="ln783">  const size_t offset_y = (roi_in-&gt;y &lt; roi_out-&gt;y) ? -roi_in-&gt;y + roi_out-&gt;y : 0;</a>
<a name="ln784"> </a>
<a name="ln785">  // The output dimensions need to be smaller or equal to the input ones</a>
<a name="ln786">  // there is no logical reason they shouldn't, except some weird bug in the pipe</a>
<a name="ln787">  // in this case, ensure we don't segfault</a>
<a name="ln788">  const size_t in_width = roi_in-&gt;width;</a>
<a name="ln789">  const size_t out_width = (roi_in-&gt;width &gt; roi_out-&gt;width) ? roi_out-&gt;width : roi_in-&gt;width;</a>
<a name="ln790">  const size_t out_height = (roi_in-&gt;height &gt; roi_out-&gt;height) ? roi_out-&gt;height : roi_in-&gt;height;</a>
<a name="ln791"> </a>
<a name="ln792">#ifdef _OPENMP</a>
<a name="ln793">#pragma omp parallel for simd default(none) schedule(static) \</a>
<a name="ln794">  dt_omp_firstprivate(in, out, in_width, out_height, out_width, offset_x, offset_y, ch, correction) \</a>
<a name="ln795">  aligned(in, out, correction:64) collapse(3)</a>
<a name="ln796">#endif</a>
<a name="ln797">  for(size_t i = 0 ; i &lt; out_height; ++i)</a>
<a name="ln798">    for(size_t j = 0; j &lt; out_width; ++j)</a>
<a name="ln799">      for(size_t c = 0; c &lt; ch; ++c)</a>
<a name="ln800">        out[(i * out_width + j) * ch + c] = in[((i + offset_y) * in_width + (j + offset_x)) * ch + c] *</a>
<a name="ln801">                                            correction[(i + offset_y) * in_width + (j + offset_x)];</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804"> </a>
<a name="ln805">__DT_CLONE_TARGETS__</a>
<a name="ln806">static inline void apply_toneequalizer(const float *const restrict in,</a>
<a name="ln807">                                       const float *const restrict luminance,</a>
<a name="ln808">                                       float *const restrict out,</a>
<a name="ln809">                                       const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln810">                                       const size_t ch,</a>
<a name="ln811">                                       const dt_iop_toneequalizer_data_t *const d)</a>
<a name="ln812">{</a>
<a name="ln813">  const size_t num_elem = roi_in-&gt;width * roi_in-&gt;height;</a>
<a name="ln814">  float *const restrict correction = dt_alloc_sse_ps(dt_round_size_sse(num_elem));</a>
<a name="ln815"> </a>
<a name="ln816">  if(correction)</a>
<a name="ln817">  {</a>
<a name="ln818">    compute_correction(luminance, correction, d-&gt;factors, d-&gt;smoothing, num_elem);</a>
<a name="ln819">    apply_exposure(in, out, roi_in, roi_out, ch, correction);</a>
<a name="ln820">    dt_free_align(correction);</a>
<a name="ln821">  }</a>
<a name="ln822">  else</a>
<a name="ln823">  {</a>
<a name="ln824">    dt_control_log(_(&quot;tone equalizer failed to allocate memory, check your RAM settings&quot;));</a>
<a name="ln825">    return;</a>
<a name="ln826">  }</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829"> </a>
<a name="ln830">__DT_CLONE_TARGETS__</a>
<a name="ln831">static</a>
<a name="ln832">void toneeq_process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln833">             const void *const restrict ivoid, void *const restrict ovoid,</a>
<a name="ln834">             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln835">{</a>
<a name="ln836">  const dt_iop_toneequalizer_data_t *const d = (const dt_iop_toneequalizer_data_t *const)piece-&gt;data;</a>
<a name="ln837">  dt_iop_toneequalizer_gui_data_t *const g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln838"> </a>
<a name="ln839">  const float *const restrict in = dt_check_sse_aligned((float *const)ivoid);</a>
<a name="ln840">  float *const restrict out = dt_check_sse_aligned((float *const)ovoid);</a>
<a name="ln841">  float *restrict luminance = NULL;</a>
<a name="ln842"> </a>
<a name="ln843">  if(in == NULL || out == NULL)</a>
<a name="ln844">  {</a>
<a name="ln845">    // Pointers are not 64-bits aligned, and SSE code will segfault</a>
<a name="ln846">    dt_control_log(_(&quot;tone equalizer in/out buffer are ill-aligned, please report the bug to the developers&quot;));</a>
<a name="ln847">    fprintf(stdout, &quot;tone equalizer in/out buffer are ill-aligned, please report the bug to the developers\n&quot;);</a>
<a name="ln848">    return;</a>
<a name="ln849">  }</a>
<a name="ln850"> </a>
<a name="ln851">  const size_t width = roi_in-&gt;width;</a>
<a name="ln852">  const size_t height = roi_in-&gt;height;</a>
<a name="ln853">  const size_t num_elem = width * height;</a>
<a name="ln854">  const size_t ch = 4;</a>
<a name="ln855"> </a>
<a name="ln856">  // Get the hash of the upstream pipe to track changes</a>
<a name="ln857">  int position = self-&gt;iop_order;</a>
<a name="ln858">  uint64_t hash = dt_dev_pixelpipe_cache_hash(piece-&gt;pipe-&gt;image.id, roi_out, piece-&gt;pipe, position);</a>
<a name="ln859"> </a>
<a name="ln860">  // Sanity checks</a>
<a name="ln861">  if(width &lt; 1 || height &lt; 1) return;</a>
<a name="ln862">  if(roi_in-&gt;width &lt; roi_out-&gt;width || roi_in-&gt;height &lt; roi_out-&gt;height) return; // input should be at least as large as output</a>
<a name="ln863">  if(piece-&gt;colors != 4) return;  // we need RGB signal</a>
<a name="ln864"> </a>
<a name="ln865">  if(!sanity_check(self))</a>
<a name="ln866">  {</a>
<a name="ln867">    // if module just got disabled by sanity checks, due to pipe position, just pass input through</a>
<a name="ln868">    dt_simd_memcpy(in, out, num_elem * ch);</a>
<a name="ln869">    return;</a>
<a name="ln870">  }</a>
<a name="ln871"> </a>
<a name="ln872">  // Init the luminance masks buffers</a>
<a name="ln873">  int cached = FALSE;</a>
<a name="ln874"> </a>
<a name="ln875">  if(self-&gt;dev-&gt;gui_attached)</a>
<a name="ln876">  {</a>
<a name="ln877">    // If the module instance has changed order in the pipe, invalidate the caches</a>
<a name="ln878">    if(g-&gt;pipe_order != position)</a>
<a name="ln879">    {</a>
<a name="ln880">      dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln881">      g-&gt;ui_preview_hash = 0;</a>
<a name="ln882">      g-&gt;thumb_preview_hash = 0;</a>
<a name="ln883">      g-&gt;pipe_order = position;</a>
<a name="ln884">      g-&gt;luminance_valid = 0;</a>
<a name="ln885">      g-&gt;histogram_valid = 0;</a>
<a name="ln886">      dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln887">    }</a>
<a name="ln888"> </a>
<a name="ln889">    if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_FULL)</a>
<a name="ln890">    {</a>
<a name="ln891">      // For DT_DEV_PIXELPIPE_FULL, we cache the luminance mask for performance</a>
<a name="ln892">      // but it's not accessed from GUI</a>
<a name="ln893">      // no need for threads lock since no other function is writing/reading that buffer</a>
<a name="ln894"> </a>
<a name="ln895">      // Re-allocate a new buffer if the full preview size has changed</a>
<a name="ln896">      if(g-&gt;full_preview_buf_width != width || g-&gt;full_preview_buf_height != height)</a>
<a name="ln897">      {</a>
<a name="ln898">        if(g-&gt;full_preview_buf) dt_free_align(g-&gt;full_preview_buf);</a>
<a name="ln899">        g-&gt;full_preview_buf = dt_alloc_sse_ps(num_elem);</a>
<a name="ln900">        g-&gt;full_preview_buf_width = width;</a>
<a name="ln901">        g-&gt;full_preview_buf_height = height;</a>
<a name="ln902">      }</a>
<a name="ln903"> </a>
<a name="ln904">      luminance = g-&gt;full_preview_buf;</a>
<a name="ln905">      cached = TRUE;</a>
<a name="ln906">    }</a>
<a name="ln907"> </a>
<a name="ln908">    else if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln909">    {</a>
<a name="ln910">      // For DT_DEV_PIXELPIPE_PREVIEW, we need to cache is too to compute the full image stats</a>
<a name="ln911">      // upon user request in GUI</a>
<a name="ln912">      // threads locks are required since GUI reads and writes on that buffer.</a>
<a name="ln913"> </a>
<a name="ln914">      // Re-allocate a new buffer if the thumb preview size has changed</a>
<a name="ln915">      dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln916">      if(g-&gt;thumb_preview_buf_width != width || g-&gt;thumb_preview_buf_height != height)</a>
<a name="ln917">      {</a>
<a name="ln918">        if(g-&gt;thumb_preview_buf) dt_free_align(g-&gt;thumb_preview_buf);</a>
<a name="ln919">        g-&gt;thumb_preview_buf = dt_alloc_sse_ps(num_elem);</a>
<a name="ln920">        g-&gt;thumb_preview_buf_width = width;</a>
<a name="ln921">        g-&gt;thumb_preview_buf_height = height;</a>
<a name="ln922">        g-&gt;luminance_valid = FALSE;</a>
<a name="ln923">      }</a>
<a name="ln924"> </a>
<a name="ln925">      luminance = g-&gt;thumb_preview_buf;</a>
<a name="ln926">      cached = TRUE;</a>
<a name="ln927"> </a>
<a name="ln928">      dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln929">    }</a>
<a name="ln930">    else // just to please GCC</a>
<a name="ln931">    {</a>
<a name="ln932">      luminance = dt_alloc_sse_ps(num_elem);</a>
<a name="ln933">    }</a>
<a name="ln934"> </a>
<a name="ln935">  }</a>
<a name="ln936">  else</a>
<a name="ln937">  {</a>
<a name="ln938">    // no interactive editing/caching : just allocate a local temp buffer</a>
<a name="ln939">    luminance = dt_alloc_sse_ps(num_elem);</a>
<a name="ln940">  }</a>
<a name="ln941"> </a>
<a name="ln942">  // Check if the luminance buffer exists</a>
<a name="ln943">  if(!luminance)</a>
<a name="ln944">  {</a>
<a name="ln945">    dt_control_log(_(&quot;tone equalizer failed to allocate memory, check your RAM settings&quot;));</a>
<a name="ln946">    return;</a>
<a name="ln947">  }</a>
<a name="ln948"> </a>
<a name="ln949">  // Compute the luminance mask</a>
<a name="ln950">  if(cached)</a>
<a name="ln951">  {</a>
<a name="ln952">    // caching path : store the luminance mask for GUI access</a>
<a name="ln953"> </a>
<a name="ln954">    if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_FULL)</a>
<a name="ln955">    {</a>
<a name="ln956">      uint64_t saved_hash;</a>
<a name="ln957">      hash_set_get(&amp;g-&gt;ui_preview_hash, &amp;saved_hash, &amp;g-&gt;lock);</a>
<a name="ln958"> </a>
<a name="ln959">      dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln960">      const int luminance_valid = g-&gt;luminance_valid;</a>
<a name="ln961">      dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln962"> </a>
<a name="ln963">      if(hash != saved_hash || !luminance_valid)</a>
<a name="ln964">      {</a>
<a name="ln965">        /* compute only if upstream pipe state has changed */</a>
<a name="ln966">        compute_luminance_mask(in, luminance, width, height, ch, d);</a>
<a name="ln967">        hash_set_get(&amp;hash, &amp;g-&gt;ui_preview_hash, &amp;g-&gt;lock);</a>
<a name="ln968">      }</a>
<a name="ln969">    }</a>
<a name="ln970"> </a>
<a name="ln971">    else if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln972">    {</a>
<a name="ln973">      uint64_t saved_hash;</a>
<a name="ln974">      hash_set_get(&amp;g-&gt;thumb_preview_hash, &amp;saved_hash, &amp;g-&gt;lock);</a>
<a name="ln975"> </a>
<a name="ln976">      dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln977">      const int luminance_valid = g-&gt;luminance_valid;</a>
<a name="ln978">      dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln979"> </a>
<a name="ln980">      if(saved_hash != hash || !luminance_valid)</a>
<a name="ln981">      {</a>
<a name="ln982">        /* compute only if upstream pipe state has changed */</a>
<a name="ln983">        dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln984">        g-&gt;thumb_preview_hash = hash;</a>
<a name="ln985">        g-&gt;histogram_valid = FALSE;</a>
<a name="ln986">        compute_luminance_mask(in, luminance, width, height, ch, d);</a>
<a name="ln987">        g-&gt;luminance_valid = TRUE;</a>
<a name="ln988">        dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln989">      }</a>
<a name="ln990">    }</a>
<a name="ln991"> </a>
<a name="ln992">    else // make it dummy-proof</a>
<a name="ln993">    {</a>
<a name="ln994">      compute_luminance_mask(in, luminance, width, height, ch, d);</a>
<a name="ln995">    }</a>
<a name="ln996">  }</a>
<a name="ln997">  else</a>
<a name="ln998">  {</a>
<a name="ln999">    // no caching path : compute no matter what</a>
<a name="ln1000">    compute_luminance_mask(in, luminance, width, height, ch, d);</a>
<a name="ln1001">  }</a>
<a name="ln1002"> </a>
<a name="ln1003">  // Display output</a>
<a name="ln1004">  if(self-&gt;dev-&gt;gui_attached &amp;&amp; piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_FULL)</a>
<a name="ln1005">  {</a>
<a name="ln1006">    if(g-&gt;mask_display)</a>
<a name="ln1007">      display_luminance_mask(luminance, out, roi_in, roi_out, ch);</a>
<a name="ln1008">    else</a>
<a name="ln1009">      apply_toneequalizer(in, luminance, out, roi_in, roi_out, ch, d);</a>
<a name="ln1010">  }</a>
<a name="ln1011">  else</a>
<a name="ln1012">  {</a>
<a name="ln1013">    apply_toneequalizer(in, luminance, out, roi_in, roi_out, ch, d);</a>
<a name="ln1014">  }</a>
<a name="ln1015"> </a>
<a name="ln1016">  if(!cached) dt_free_align(luminance);</a>
<a name="ln1017"> </a>
<a name="ln1018">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK)</a>
<a name="ln1019">    dt_iop_alpha_copy(in, out, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1023">             const void *const restrict ivoid, void *const restrict ovoid,</a>
<a name="ln1024">             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln1025">{</a>
<a name="ln1026">    toneeq_process(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029"> </a>
<a name="ln1030">void modify_roi_in(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1031">                   const dt_iop_roi_t *roi_out, dt_iop_roi_t *roi_in)</a>
<a name="ln1032">{</a>
<a name="ln1033">  // Pad the zoomed-in view to avoid weird stuff with local averages at the borders of</a>
<a name="ln1034">  // the preview</a>
<a name="ln1035"> </a>
<a name="ln1036">  dt_iop_toneequalizer_data_t *const d = (dt_iop_toneequalizer_data_t *const)piece-&gt;data;</a>
<a name="ln1037"> </a>
<a name="ln1038">  // Get the scaled window radius for the box average</a>
<a name="ln1039">  const int max_size = (piece-&gt;iwidth &gt; piece-&gt;iheight) ? piece-&gt;iwidth : piece-&gt;iheight;</a>
<a name="ln1040">  const float diameter = d-&gt;blending * max_size * roi_in-&gt;scale;</a>
<a name="ln1041">  const int radius = (int)((diameter - 1.0f) / ( 2.0f));</a>
<a name="ln1042">  d-&gt;radius = radius;</a>
<a name="ln1043"> </a>
<a name="ln1044">  // Enlarge the preview roi with padding if needed</a>
<a name="ln1045">  if(self-&gt;dev-&gt;gui_attached &amp;&amp; sanity_check(self))</a>
<a name="ln1046">  {</a>
<a name="ln1047">    int roiy = fmaxf(roi_in-&gt;y - radius, 0.0f);</a>
<a name="ln1048">    int roix = fmaxf(roi_in-&gt;x - radius, 0.0f);</a>
<a name="ln1049">    int roir = fminf(roix + roi_in-&gt;width + 2 * radius, piece-&gt;buf_in.width * roi_in-&gt;scale);</a>
<a name="ln1050">    int roib = fminf(roiy + roi_in-&gt;height + 2 * radius, piece-&gt;buf_in.height * roi_in-&gt;scale);</a>
<a name="ln1051"> </a>
<a name="ln1052">    // Set the values and check</a>
<a name="ln1053">    roi_in-&gt;x = roix;</a>
<a name="ln1054">    roi_in-&gt;y = roiy;</a>
<a name="ln1055">    roi_in-&gt;width = roir - roi_in-&gt;x;</a>
<a name="ln1056">    roi_in-&gt;height = roib - roi_in-&gt;y;</a>
<a name="ln1057">  }</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060"> </a>
<a name="ln1061">/***</a>
<a name="ln1062"> * Setters and Getters for parameters</a>
<a name="ln1063"> *</a>
<a name="ln1064"> * Remember the user params split the [-8; 0] EV range in 9 channels and define a set of (x, y)</a>
<a name="ln1065"> * coordinates, where x are the exposure channels (evenly-spaced by 1 EV in [-8; 0] EV)</a>
<a name="ln1066"> * and y are the desired exposure compensation for each channel.</a>
<a name="ln1067"> *</a>
<a name="ln1068"> * This (x, y) set is interpolated by radial-basis function using a series of 8 gaussians.</a>
<a name="ln1069"> * Losing 1 degree of freedom makes it an approximation rather than an interpolation but</a>
<a name="ln1070"> * helps reducing a bit the oscillations and fills a full AVX vector.</a>
<a name="ln1071"> *</a>
<a name="ln1072"> * The coefficients/factors used in the interpolation/approximation are linear, but keep in</a>
<a name="ln1073"> * mind that users params are expressed as log2 gains, so we always need to do the log2/exp2</a>
<a name="ln1074"> * flip/flop between both.</a>
<a name="ln1075"> *</a>
<a name="ln1076"> * User params of exposure compensation are expected between [-2 ; +2] EV for practical UI reasons</a>
<a name="ln1077"> * and probably numerical stability reasons, but there is no theoretical obstacle to enlarge</a>
<a name="ln1078"> * this range. The main reason for not allowing it is tone equalizer is mostly intended</a>
<a name="ln1079"> * to do local changes, and these don't look so well if you are too harsh on the changes.</a>
<a name="ln1080"> * For heavier tonemapping, it should be used in combination with a tone curve or filmic.</a>
<a name="ln1081"> *</a>
<a name="ln1082"> ***/</a>
<a name="ln1083"> </a>
<a name="ln1084"> </a>
<a name="ln1085">static void get_channels_gains(float factors[CHANNELS], const dt_iop_toneequalizer_params_t *p)</a>
<a name="ln1086">{</a>
<a name="ln1087">  assert(CHANNELS == 9);</a>
<a name="ln1088"> </a>
<a name="ln1089">  // Get user-set channels gains in EV (log2)</a>
<a name="ln1090">  factors[0] = p-&gt;noise; // -8 EV</a>
<a name="ln1091">  factors[1] = p-&gt;ultra_deep_blacks; // -7 EV</a>
<a name="ln1092">  factors[2] = p-&gt;deep_blacks;       // -6 EV</a>
<a name="ln1093">  factors[3] = p-&gt;blacks;            // -5 EV</a>
<a name="ln1094">  factors[4] = p-&gt;shadows;           // -4 EV</a>
<a name="ln1095">  factors[5] = p-&gt;midtones;          // -3 EV</a>
<a name="ln1096">  factors[6] = p-&gt;highlights;        // -2 EV</a>
<a name="ln1097">  factors[7] = p-&gt;whites;            // -1 EV</a>
<a name="ln1098">  factors[8] = p-&gt;speculars;         // +0 EV</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101"> </a>
<a name="ln1102">static void get_channels_factors(float factors[CHANNELS], const dt_iop_toneequalizer_params_t *p)</a>
<a name="ln1103">{</a>
<a name="ln1104">  assert(CHANNELS == 9);</a>
<a name="ln1105"> </a>
<a name="ln1106">  // Get user-set channels gains in EV (log2)</a>
<a name="ln1107">  get_channels_gains(factors, p);</a>
<a name="ln1108"> </a>
<a name="ln1109">  // Convert from EV offsets to linear factors</a>
<a name="ln1110">#ifdef _OPENMP</a>
<a name="ln1111">#pragma omp simd aligned(factors:64)</a>
<a name="ln1112">#endif</a>
<a name="ln1113">  for(int c = 0; c &lt; CHANNELS; ++c)</a>
<a name="ln1114">    factors[c] = exp2f(factors[c]);</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117"> </a>
<a name="ln1118">__DT_CLONE_TARGETS__</a>
<a name="ln1119">static int compute_channels_factors(const float factors[PIXEL_CHAN], float out[CHANNELS], const float sigma)</a>
<a name="ln1120">{</a>
<a name="ln1121">  // Input factors are the weights for the radial-basis curve approximation of user params</a>
<a name="ln1122">  // Output factors are the gains of the user parameters channels</a>
<a name="ln1123">  // aka the y coordinates of the approximation for x = { CHANNELS }</a>
<a name="ln1124">  assert(PIXEL_CHAN == 8);</a>
<a name="ln1125"> </a>
<a name="ln1126">  int valid = 1;</a>
<a name="ln1127"> </a>
<a name="ln1128">  #ifdef _OPENMP</a>
<a name="ln1129">  #pragma omp parallel for simd default(none) schedule(static) \</a>
<a name="ln1130">    aligned(factors, out, centers_params:64) dt_omp_firstprivate(factors, out, sigma, centers_params) shared(valid)</a>
<a name="ln1131">  #endif</a>
<a name="ln1132">  for(int i = 0; i &lt; CHANNELS; ++i)</a>
<a name="ln1133">  {</a>
<a name="ln1134">     // Compute the new channels factors</a>
<a name="ln1135">    out[i] = pixel_correction(centers_params[i], factors, sigma);</a>
<a name="ln1136"> </a>
<a name="ln1137">    // check they are in [-2, 2] EV and not NAN</a>
<a name="ln1138">    if(out[i] &lt; 0.25f || out[i] &gt; 4.0f || out[i] != out[i]) valid = 0;</a>
<a name="ln1139">  }</a>
<a name="ln1140"> </a>
<a name="ln1141">  return valid;</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144"> </a>
<a name="ln1145">__DT_CLONE_TARGETS__</a>
<a name="ln1146">static int compute_channels_gains(const float in[CHANNELS], float out[CHANNELS])</a>
<a name="ln1147">{</a>
<a name="ln1148">  // Helper function to compute the new channels gains (log) from the factors (linear)</a>
<a name="ln1149">  assert(PIXEL_CHAN == 8);</a>
<a name="ln1150"> </a>
<a name="ln1151">  const int valid = 1;</a>
<a name="ln1152"> </a>
<a name="ln1153">  for(int i = 0; i &lt; CHANNELS; ++i)</a>
<a name="ln1154">    out[i] = log2f(in[i]);</a>
<a name="ln1155"> </a>
<a name="ln1156">  return valid;</a>
<a name="ln1157">}</a>
<a name="ln1158"> </a>
<a name="ln1159"> </a>
<a name="ln1160">static int commit_channels_gains(const float factors[CHANNELS], dt_iop_toneequalizer_params_t *p)</a>
<a name="ln1161">{</a>
<a name="ln1162">  p-&gt;noise = factors[0];</a>
<a name="ln1163">  p-&gt;ultra_deep_blacks = factors[1];</a>
<a name="ln1164">  p-&gt;deep_blacks = factors[2];</a>
<a name="ln1165">  p-&gt;blacks = factors[3];</a>
<a name="ln1166">  p-&gt;shadows = factors[4];</a>
<a name="ln1167">  p-&gt;midtones = factors[5];</a>
<a name="ln1168">  p-&gt;highlights = factors[6];</a>
<a name="ln1169">  p-&gt;whites = factors[7];</a>
<a name="ln1170">  p-&gt;speculars = factors[8];</a>
<a name="ln1171"> </a>
<a name="ln1172">  return 1;</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175"> </a>
<a name="ln1176">/***</a>
<a name="ln1177"> * Cache invalidation and initializatiom</a>
<a name="ln1178"> ***/</a>
<a name="ln1179"> </a>
<a name="ln1180"> </a>
<a name="ln1181">static void gui_cache_init(struct dt_iop_module_t *self)</a>
<a name="ln1182">{</a>
<a name="ln1183">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1184">  if(g == NULL) return;</a>
<a name="ln1185"> </a>
<a name="ln1186">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln1187">  g-&gt;ui_preview_hash = 0;</a>
<a name="ln1188">  g-&gt;thumb_preview_hash = 0;</a>
<a name="ln1189">  g-&gt;max_histogram = 1;</a>
<a name="ln1190">  g-&gt;scale = 1.0f;</a>
<a name="ln1191">  g-&gt;sigma = sqrtf(2.0f);</a>
<a name="ln1192">  g-&gt;mask_display = FALSE;</a>
<a name="ln1193"> </a>
<a name="ln1194">  g-&gt;interpolation_valid = FALSE;  // TRUE if the interpolation_matrix is ready</a>
<a name="ln1195">  g-&gt;luminance_valid = FALSE;      // TRUE if the luminance cache is ready</a>
<a name="ln1196">  g-&gt;histogram_valid = FALSE;      // TRUE if the histogram cache and stats are ready</a>
<a name="ln1197">  g-&gt;lut_valid = FALSE;            // TRUE if the gui_lut is ready</a>
<a name="ln1198">  g-&gt;graph_valid = FALSE;          // TRUE if the UI graph view is ready</a>
<a name="ln1199">  g-&gt;user_param_valid = FALSE;     // TRUE if users params set in interactive view are in bounds</a>
<a name="ln1200">  g-&gt;factors_valid = TRUE;         // TRUE if radial-basis coeffs are ready</a>
<a name="ln1201"> </a>
<a name="ln1202">  g-&gt;valid_nodes_x = FALSE;        // TRUE if x coordinates of graph nodes have been inited</a>
<a name="ln1203">  g-&gt;valid_nodes_y = FALSE;        // TRUE if y coordinates of graph nodes have been inited</a>
<a name="ln1204">  g-&gt;area_cursor_valid = FALSE;    // TRUE if mouse cursor is over the graph area</a>
<a name="ln1205">  g-&gt;area_dragging = FALSE;        // TRUE if left-button has been pushed but not released and cursor motion is recorded</a>
<a name="ln1206">  g-&gt;cursor_valid = FALSE;         // TRUE if mouse cursor is over the preview image</a>
<a name="ln1207"> </a>
<a name="ln1208">  g-&gt;full_preview_buf = NULL;</a>
<a name="ln1209">  g-&gt;full_preview_buf_width = 0;</a>
<a name="ln1210">  g-&gt;full_preview_buf_height = 0;</a>
<a name="ln1211"> </a>
<a name="ln1212">  g-&gt;thumb_preview_buf = NULL;</a>
<a name="ln1213">  g-&gt;thumb_preview_buf_width = 0;</a>
<a name="ln1214">  g-&gt;thumb_preview_buf_height = 0;</a>
<a name="ln1215"> </a>
<a name="ln1216">  g-&gt;desc = NULL;</a>
<a name="ln1217">  g-&gt;layout = NULL;</a>
<a name="ln1218">  g-&gt;cr = NULL;</a>
<a name="ln1219">  g-&gt;cst = NULL;</a>
<a name="ln1220">  g-&gt;context = NULL;</a>
<a name="ln1221"> </a>
<a name="ln1222">  g-&gt;pipe_order = 0;</a>
<a name="ln1223">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln1224">}</a>
<a name="ln1225"> </a>
<a name="ln1226"> </a>
<a name="ln1227">static inline void build_interpolation_matrix(float A[CHANNELS * PIXEL_CHAN],</a>
<a name="ln1228">                                              const float sigma)</a>
<a name="ln1229">{</a>
<a name="ln1230">  // Build the symmetrical definite positive part of the augmented matrix</a>
<a name="ln1231">  // of the radial-basis interpolation weights</a>
<a name="ln1232"> </a>
<a name="ln1233">  const float gauss_denom = gaussian_denom(sigma);</a>
<a name="ln1234"> </a>
<a name="ln1235">#ifdef _OPENMP</a>
<a name="ln1236">#pragma omp simd aligned(A, centers_ops, centers_params:64) collapse(2)</a>
<a name="ln1237">#endif</a>
<a name="ln1238">  for(int i = 0; i &lt; CHANNELS; ++i)</a>
<a name="ln1239">    for(int j = 0; j &lt; PIXEL_CHAN; ++j)</a>
<a name="ln1240">      A[i * PIXEL_CHAN + j] = gaussian_func(centers_params[i] - centers_ops[j], gauss_denom);</a>
<a name="ln1241">}</a>
<a name="ln1242"> </a>
<a name="ln1243"> </a>
<a name="ln1244">__DT_CLONE_TARGETS__</a>
<a name="ln1245">static inline void compute_log_histogram(const float *const restrict luminance,</a>
<a name="ln1246">                                          int histogram[UI_SAMPLES],</a>
<a name="ln1247">                                          const size_t num_elem,</a>
<a name="ln1248">                                          int *max_histogram)</a>
<a name="ln1249">{</a>
<a name="ln1250">  // Compute an histogram of exposures, in log</a>
<a name="ln1251">  int temp_max_histogram = 0;</a>
<a name="ln1252"> </a>
<a name="ln1253">  // (Re)init the histogram</a>
<a name="ln1254">#ifdef _OPENMP</a>
<a name="ln1255">#pragma omp for simd schedule(simd:static) aligned(histogram:64)</a>
<a name="ln1256">#endif</a>
<a name="ln1257">  for(int k = 0; k &lt; UI_SAMPLES; k++)</a>
<a name="ln1258">    histogram[k] = 0;</a>
<a name="ln1259"> </a>
<a name="ln1260">  // Split exposure in bins</a>
<a name="ln1261">#ifdef _OPENMP</a>
<a name="ln1262">#pragma omp parallel for default(none) schedule(simd:static) \</a>
<a name="ln1263">  dt_omp_firstprivate(luminance, num_elem) \</a>
<a name="ln1264">  shared(temp_max_histogram, histogram)</a>
<a name="ln1265">#endif</a>
<a name="ln1266">  for(size_t k = 0; k &lt; num_elem; k++)</a>
<a name="ln1267">  {</a>
<a name="ln1268">    // the histogram shows bins between [-14; +2] EV remapped between [0 ; UI_SAMPLES[</a>
<a name="ln1269">    const int index = CLAMP((int)(((log2f(luminance[k]) + 8.0f) / 8.0f) * (float)UI_SAMPLES), 0, UI_SAMPLES - 1);</a>
<a name="ln1270">    histogram[index] += 1;</a>
<a name="ln1271"> </a>
<a name="ln1272">    // store the max numbers of elements in bins for later normalization</a>
<a name="ln1273">    temp_max_histogram = (histogram[index] &gt; temp_max_histogram) ? histogram[index] : temp_max_histogram;</a>
<a name="ln1274">  }</a>
<a name="ln1275"> </a>
<a name="ln1276">  *max_histogram = temp_max_histogram;</a>
<a name="ln1277">}</a>
<a name="ln1278"> </a>
<a name="ln1279"> </a>
<a name="ln1280"> </a>
<a name="ln1281">static inline void histogram_deciles(const int histogram[UI_SAMPLES], size_t hist_bins, size_t num_elem,</a>
<a name="ln1282">                              const float hist_span, const float hist_offset,</a>
<a name="ln1283">                              float *first_decile, float *last_decile)</a>
<a name="ln1284">{</a>
<a name="ln1285">  // Browse an histogram of `hist_bins` bins containing a population of `num_elems` elements</a>
<a name="ln1286">  // spanning from `hist_offset` to `hist_offset + hist_span`,</a>
<a name="ln1287">  // looking for the position of the first and last deciles,</a>
<a name="ln1288">  // and return their values scaled in the corresponding span</a>
<a name="ln1289"> </a>
<a name="ln1290">  const int first = (int)((float)num_elem * 0.1f);</a>
<a name="ln1291">  const int last = (int)((float)num_elem * 0.9f);</a>
<a name="ln1292">  int population = 0;</a>
<a name="ln1293">  int first_pos = 0;</a>
<a name="ln1294">  int last_pos = 0;</a>
<a name="ln1295"> </a>
<a name="ln1296">  // scout the histogram bins looking for deciles</a>
<a name="ln1297">  for(size_t k = 0; k &lt; hist_bins; ++k)</a>
<a name="ln1298">  {</a>
<a name="ln1299">    const size_t prev_population = population;</a>
<a name="ln1300">    population += histogram[k];</a>
<a name="ln1301">    if(prev_population &lt; first &amp;&amp; first &lt;= population) first_pos = k;</a>
<a name="ln1302">    if(prev_population &lt; last &amp;&amp; last &lt;= population) last_pos = k;</a>
<a name="ln1303">  }</a>
<a name="ln1304"> </a>
<a name="ln1305">  // Convert bins positions to exposures</a>
<a name="ln1306">  *first_decile = (hist_span * (((float)first_pos) / ((float)(hist_bins - 1)))) + hist_offset;</a>
<a name="ln1307">  *last_decile = (hist_span * (((float)last_pos) / ((float)(hist_bins - 1)))) + hist_offset;</a>
<a name="ln1308">}</a>
<a name="ln1309"> </a>
<a name="ln1310"> </a>
<a name="ln1311">static inline void update_histogram(struct dt_iop_toneequalizer_gui_data_t *g)</a>
<a name="ln1312">{</a>
<a name="ln1313">  if(g == NULL) return;</a>
<a name="ln1314"> </a>
<a name="ln1315">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln1316">  if(!g-&gt;histogram_valid &amp;&amp; g-&gt;luminance_valid)</a>
<a name="ln1317">  {</a>
<a name="ln1318">    const size_t num_elem = g-&gt;thumb_preview_buf_height * g-&gt;thumb_preview_buf_width;</a>
<a name="ln1319">    compute_log_histogram(g-&gt;thumb_preview_buf, g-&gt;histogram, num_elem, &amp;g-&gt;max_histogram);</a>
<a name="ln1320">    histogram_deciles(g-&gt;histogram, UI_SAMPLES, num_elem, 8.0f, -8.0f,</a>
<a name="ln1321">                      &amp;g-&gt;histogram_first_decile, &amp;g-&gt;histogram_last_decile);</a>
<a name="ln1322">    g-&gt;histogram_average = (g-&gt;histogram_first_decile + g-&gt;histogram_last_decile) / 2.0f;</a>
<a name="ln1323">    g-&gt;histogram_valid = TRUE;</a>
<a name="ln1324">  }</a>
<a name="ln1325">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328"> </a>
<a name="ln1329">__DT_CLONE_TARGETS__</a>
<a name="ln1330">static inline void compute_lut_correction(struct dt_iop_toneequalizer_gui_data_t *g,</a>
<a name="ln1331">                                          const float offset,</a>
<a name="ln1332">                                          const float scaling)</a>
<a name="ln1333">{</a>
<a name="ln1334">  // Compute the LUT of the exposure corrections in EV,</a>
<a name="ln1335">  // offset and scale it for display in GUI widget graph</a>
<a name="ln1336"> </a>
<a name="ln1337">  float *const restrict LUT = g-&gt;gui_lut;</a>
<a name="ln1338">  const float *const restrict factors = g-&gt;factors;</a>
<a name="ln1339">  const float sigma = g-&gt;sigma;</a>
<a name="ln1340"> </a>
<a name="ln1341">#ifdef _OPENMP</a>
<a name="ln1342">#pragma omp parallel for simd schedule(static) default(none) \</a>
<a name="ln1343">  dt_omp_firstprivate(factors, sigma, offset, scaling, LUT) \</a>
<a name="ln1344">  aligned(LUT, factors:64)</a>
<a name="ln1345">#endif</a>
<a name="ln1346">  for(int k = 0; k &lt; UI_SAMPLES; k++)</a>
<a name="ln1347">  {</a>
<a name="ln1348">    // build the inset graph curve LUT</a>
<a name="ln1349">    // the x range is [-14;+2] EV</a>
<a name="ln1350">    const float x = (8.0f * (((float)k) / ((float)(UI_SAMPLES - 1)))) - 8.0f;</a>
<a name="ln1351">    LUT[k] = offset - log2f(pixel_correction(x, factors, sigma)) / scaling;</a>
<a name="ln1352">  }</a>
<a name="ln1353">}</a>
<a name="ln1354"> </a>
<a name="ln1355"> </a>
<a name="ln1356"> </a>
<a name="ln1357">static inline gboolean update_curve_lut(struct dt_iop_module_t *self)</a>
<a name="ln1358">{</a>
<a name="ln1359">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1360">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1361"> </a>
<a name="ln1362">  if(g == NULL) return FALSE;</a>
<a name="ln1363"> </a>
<a name="ln1364">  gboolean valid = TRUE;</a>
<a name="ln1365"> </a>
<a name="ln1366">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln1367"> </a>
<a name="ln1368">  if(!g-&gt;interpolation_valid)</a>
<a name="ln1369">  {</a>
<a name="ln1370">    build_interpolation_matrix(g-&gt;interpolation_matrix, g-&gt;sigma);</a>
<a name="ln1371">    g-&gt;interpolation_valid = TRUE;</a>
<a name="ln1372">    g-&gt;factors_valid = FALSE;</a>
<a name="ln1373">  }</a>
<a name="ln1374"> </a>
<a name="ln1375">  if(!g-&gt;user_param_valid)</a>
<a name="ln1376">  {</a>
<a name="ln1377">    float factors[CHANNELS] DT_ALIGNED_ARRAY;</a>
<a name="ln1378">    get_channels_factors(factors, p);</a>
<a name="ln1379">    dt_simd_memcpy(factors, g-&gt;temp_user_params, CHANNELS);</a>
<a name="ln1380">    g-&gt;user_param_valid = TRUE;</a>
<a name="ln1381">    g-&gt;factors_valid = FALSE;</a>
<a name="ln1382">  }</a>
<a name="ln1383"> </a>
<a name="ln1384">  if(!g-&gt;factors_valid &amp;&amp; g-&gt;user_param_valid)</a>
<a name="ln1385">  {</a>
<a name="ln1386">    float factors[CHANNELS] DT_ALIGNED_ARRAY;</a>
<a name="ln1387">    dt_simd_memcpy(g-&gt;temp_user_params, factors, CHANNELS);</a>
<a name="ln1388">    valid = pseudo_solve(g-&gt;interpolation_matrix, factors, CHANNELS, PIXEL_CHAN, 1);</a>
<a name="ln1389">    dt_simd_memcpy(factors, g-&gt;factors, PIXEL_CHAN);</a>
<a name="ln1390">    g-&gt;factors_valid = TRUE;</a>
<a name="ln1391">    g-&gt;lut_valid = FALSE;</a>
<a name="ln1392">  }</a>
<a name="ln1393"> </a>
<a name="ln1394">  if(!g-&gt;lut_valid &amp;&amp; g-&gt;factors_valid)</a>
<a name="ln1395">  {</a>
<a name="ln1396">    compute_lut_correction(g, 0.5f, 4.0f);</a>
<a name="ln1397">    g-&gt;lut_valid = TRUE;</a>
<a name="ln1398">  }</a>
<a name="ln1399"> </a>
<a name="ln1400">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln1401"> </a>
<a name="ln1402">  return valid;</a>
<a name="ln1403">}</a>
<a name="ln1404"> </a>
<a name="ln1405"> </a>
<a name="ln1406">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln1407">{</a>
<a name="ln1408">  dt_iop_toneequalizer_global_data_t *gd</a>
<a name="ln1409">      = (dt_iop_toneequalizer_global_data_t *)malloc(sizeof(dt_iop_toneequalizer_global_data_t));</a>
<a name="ln1410"> </a>
<a name="ln1411">  module-&gt;data = gd;</a>
<a name="ln1412">}</a>
<a name="ln1413"> </a>
<a name="ln1414"> </a>
<a name="ln1415">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln1416">{</a>
<a name="ln1417">  free(module-&gt;data);</a>
<a name="ln1418">  module-&gt;data = NULL;</a>
<a name="ln1419">}</a>
<a name="ln1420"> </a>
<a name="ln1421"> </a>
<a name="ln1422">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln1423">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1424">{</a>
<a name="ln1425">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)p1;</a>
<a name="ln1426">  dt_iop_toneequalizer_data_t *d = (dt_iop_toneequalizer_data_t *)piece-&gt;data;</a>
<a name="ln1427">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1428"> </a>
<a name="ln1429">  // Trivial params passing</a>
<a name="ln1430">  d-&gt;method = p-&gt;method;</a>
<a name="ln1431">  d-&gt;details = p-&gt;details;</a>
<a name="ln1432">  d-&gt;iterations = p-&gt;iterations;</a>
<a name="ln1433">  d-&gt;smoothing = p-&gt;smoothing;</a>
<a name="ln1434">  d-&gt;quantization = p-&gt;quantization;</a>
<a name="ln1435"> </a>
<a name="ln1436">  // UI blending param is set in % of the largest image dimension</a>
<a name="ln1437">  d-&gt;blending = p-&gt;blending / 100.0f;</a>
<a name="ln1438"> </a>
<a name="ln1439">  // UI guided filter feathering param increases the edges taping</a>
<a name="ln1440">  // but the actual regularization params applied in guided filter behaves the other way</a>
<a name="ln1441">  d-&gt;feathering = 1.f / (p-&gt;feathering);</a>
<a name="ln1442"> </a>
<a name="ln1443">  // UI params are in log2 offsets (EV) : convert to linear factors</a>
<a name="ln1444">  d-&gt;contrast_boost = exp2f(p-&gt;contrast_boost);</a>
<a name="ln1445">  d-&gt;exposure_boost = exp2f(p-&gt;exposure_boost);</a>
<a name="ln1446"> </a>
<a name="ln1447">  /*</a>
<a name="ln1448">   * Perform a radial-based interpolation using a series gaussian functions</a>
<a name="ln1449">   */</a>
<a name="ln1450">  if(self-&gt;dev-&gt;gui_attached &amp;&amp; g)</a>
<a name="ln1451">  {</a>
<a name="ln1452">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln1453">    if(g-&gt;sigma != p-&gt;smoothing) g-&gt;interpolation_valid = FALSE;</a>
<a name="ln1454">    g-&gt;sigma = p-&gt;smoothing;</a>
<a name="ln1455">    g-&gt;user_param_valid = FALSE; // force updating channels factors</a>
<a name="ln1456">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln1457"> </a>
<a name="ln1458">    update_curve_lut(self);</a>
<a name="ln1459"> </a>
<a name="ln1460">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln1461">    dt_simd_memcpy(g-&gt;factors, d-&gt;factors, PIXEL_CHAN);</a>
<a name="ln1462">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln1463">  }</a>
<a name="ln1464">  else</a>
<a name="ln1465">  {</a>
<a name="ln1466">    // No cache : Build / Solve interpolation matrix</a>
<a name="ln1467">    float factors[CHANNELS] DT_ALIGNED_ARRAY;</a>
<a name="ln1468">    get_channels_factors(factors, p);</a>
<a name="ln1469"> </a>
<a name="ln1470">    float A[CHANNELS * PIXEL_CHAN] DT_ALIGNED_ARRAY;</a>
<a name="ln1471">    build_interpolation_matrix(A, p-&gt;smoothing);</a>
<a name="ln1472">    pseudo_solve(A, factors, CHANNELS, PIXEL_CHAN, 0);</a>
<a name="ln1473"> </a>
<a name="ln1474">    dt_simd_memcpy(factors, d-&gt;factors, PIXEL_CHAN);</a>
<a name="ln1475">  }</a>
<a name="ln1476">}</a>
<a name="ln1477"> </a>
<a name="ln1478"> </a>
<a name="ln1479">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1480">{</a>
<a name="ln1481">  piece-&gt;data = calloc(1, sizeof(dt_iop_toneequalizer_data_t));</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484"> </a>
<a name="ln1485">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1486">{</a>
<a name="ln1487">  free(piece-&gt;data);</a>
<a name="ln1488">  piece-&gt;data = NULL;</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">void init(dt_iop_module_t *module)</a>
<a name="ln1492">{</a>
<a name="ln1493">  module-&gt;params = calloc(1, sizeof(dt_iop_toneequalizer_params_t));</a>
<a name="ln1494">  module-&gt;default_params = calloc(1, sizeof(dt_iop_toneequalizer_params_t));</a>
<a name="ln1495">  module-&gt;default_enabled = 0;</a>
<a name="ln1496">  module-&gt;params_size = sizeof(dt_iop_toneequalizer_params_t);</a>
<a name="ln1497">  module-&gt;gui_data = NULL;</a>
<a name="ln1498"> </a>
<a name="ln1499">  dt_iop_toneequalizer_params_t tmp = (dt_iop_toneequalizer_params_t){.noise = 0.0f,</a>
<a name="ln1500">                                                                      .ultra_deep_blacks = 0.0f,</a>
<a name="ln1501">                                                                      .deep_blacks = 0.0f,</a>
<a name="ln1502">                                                                      .blacks = 0.0f,</a>
<a name="ln1503">                                                                      .shadows = 0.0f,</a>
<a name="ln1504">                                                                      .midtones = 0.0f,</a>
<a name="ln1505">                                                                      .highlights = 0.0f,</a>
<a name="ln1506">                                                                      .whites = 0.0f,</a>
<a name="ln1507">                                                                      .speculars = 0.0f,</a>
<a name="ln1508">                                                                      .quantization = 1.0f,</a>
<a name="ln1509">                                                                      .smoothing = sqrtf(2.0f),</a>
<a name="ln1510">                                                                      .iterations = 2,</a>
<a name="ln1511">                                                                      .method = DT_TONEEQ_NORM_2,</a>
<a name="ln1512">                                                                      .details = DT_TONEEQ_GUIDED,</a>
<a name="ln1513">                                                                      .blending = 25.0f,</a>
<a name="ln1514">                                                                      .feathering = 10.0f,</a>
<a name="ln1515">                                                                      .contrast_boost = 2.0f,</a>
<a name="ln1516">                                                                      .exposure_boost = -1.0f };</a>
<a name="ln1517">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_toneequalizer_params_t));</a>
<a name="ln1518">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_toneequalizer_params_t));</a>
<a name="ln1519">}</a>
<a name="ln1520"> </a>
<a name="ln1521">void cleanup(dt_iop_module_t *module)</a>
<a name="ln1522">{</a>
<a name="ln1523">  free(module-&gt;params);</a>
<a name="ln1524">  module-&gt;params = NULL;</a>
<a name="ln1525">}</a>
<a name="ln1526"> </a>
<a name="ln1527"> </a>
<a name="ln1528">void reload_defaults(struct dt_iop_module_t *self)</a>
<a name="ln1529">{</a>
<a name="ln1530">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1531">  if(g == NULL) return;</a>
<a name="ln1532"> </a>
<a name="ln1533">  invalidate_luminance_cache(self);</a>
<a name="ln1534">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1535">  dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln1536">  gui_cache_init(self);</a>
<a name="ln1537">}</a>
<a name="ln1538"> </a>
<a name="ln1539"> </a>
<a name="ln1540">void show_guiding_controls(struct dt_iop_module_t *self)</a>
<a name="ln1541">{</a>
<a name="ln1542">  dt_iop_module_t *module = (dt_iop_module_t *)self;</a>
<a name="ln1543">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1544">  const dt_iop_toneequalizer_params_t *p = (const dt_iop_toneequalizer_params_t *)module-&gt;params;</a>
<a name="ln1545"> </a>
<a name="ln1546">  switch(p-&gt;details)</a>
<a name="ln1547">  {</a>
<a name="ln1548">    case(DT_TONEEQ_NONE):</a>
<a name="ln1549">    {</a>
<a name="ln1550">      gtk_widget_set_visible(g-&gt;blending, FALSE);</a>
<a name="ln1551">      gtk_widget_set_visible(g-&gt;feathering, FALSE);</a>
<a name="ln1552">      gtk_widget_set_visible(g-&gt;iterations, FALSE);</a>
<a name="ln1553">      gtk_widget_set_visible(g-&gt;contrast_boost, FALSE);</a>
<a name="ln1554">      gtk_widget_set_visible(g-&gt;quantization, FALSE);</a>
<a name="ln1555">      break;</a>
<a name="ln1556">    }</a>
<a name="ln1557"> </a>
<a name="ln1558">    case(DT_TONEEQ_AVG_GUIDED):</a>
<a name="ln1559">    {</a>
<a name="ln1560">      gtk_widget_set_visible(g-&gt;blending, TRUE);</a>
<a name="ln1561">      gtk_widget_set_visible(g-&gt;feathering, TRUE);</a>
<a name="ln1562">      gtk_widget_set_visible(g-&gt;iterations, TRUE);</a>
<a name="ln1563">      gtk_widget_set_visible(g-&gt;contrast_boost, FALSE);</a>
<a name="ln1564">      gtk_widget_set_visible(g-&gt;quantization, TRUE);</a>
<a name="ln1565">      break;</a>
<a name="ln1566">    }</a>
<a name="ln1567"> </a>
<a name="ln1568">    case(DT_TONEEQ_GUIDED):</a>
<a name="ln1569">    {</a>
<a name="ln1570">      gtk_widget_set_visible(g-&gt;blending, TRUE);</a>
<a name="ln1571">      gtk_widget_set_visible(g-&gt;feathering, TRUE);</a>
<a name="ln1572">      gtk_widget_set_visible(g-&gt;iterations, TRUE);</a>
<a name="ln1573">      gtk_widget_set_visible(g-&gt;contrast_boost, TRUE);</a>
<a name="ln1574">      gtk_widget_set_visible(g-&gt;quantization, TRUE);</a>
<a name="ln1575">      break;</a>
<a name="ln1576">    }</a>
<a name="ln1577">  }</a>
<a name="ln1578">}</a>
<a name="ln1579"> </a>
<a name="ln1580">void update_exposure_sliders(dt_iop_toneequalizer_gui_data_t *g, dt_iop_toneequalizer_params_t *p)</a>
<a name="ln1581">{</a>
<a name="ln1582">  dt_bauhaus_slider_set_soft(g-&gt;noise, p-&gt;noise);</a>
<a name="ln1583">  dt_bauhaus_slider_set_soft(g-&gt;ultra_deep_blacks, p-&gt;ultra_deep_blacks);</a>
<a name="ln1584">  dt_bauhaus_slider_set_soft(g-&gt;deep_blacks, p-&gt;deep_blacks);</a>
<a name="ln1585">  dt_bauhaus_slider_set_soft(g-&gt;blacks, p-&gt;blacks);</a>
<a name="ln1586">  dt_bauhaus_slider_set_soft(g-&gt;shadows, p-&gt;shadows);</a>
<a name="ln1587">  dt_bauhaus_slider_set_soft(g-&gt;midtones, p-&gt;midtones);</a>
<a name="ln1588">  dt_bauhaus_slider_set_soft(g-&gt;highlights, p-&gt;highlights);</a>
<a name="ln1589">  dt_bauhaus_slider_set_soft(g-&gt;whites, p-&gt;whites);</a>
<a name="ln1590">  dt_bauhaus_slider_set_soft(g-&gt;speculars, p-&gt;speculars);</a>
<a name="ln1591">}</a>
<a name="ln1592"> </a>
<a name="ln1593"> </a>
<a name="ln1594">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln1595">{</a>
<a name="ln1596">  dt_iop_module_t *module = (dt_iop_module_t *)self;</a>
<a name="ln1597">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1598">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)module-&gt;params;</a>
<a name="ln1599"> </a>
<a name="ln1600">  update_exposure_sliders(g, p);</a>
<a name="ln1601"> </a>
<a name="ln1602">  dt_bauhaus_combobox_set(g-&gt;method, p-&gt;method);</a>
<a name="ln1603">  dt_bauhaus_combobox_set(g-&gt;details, p-&gt;details);</a>
<a name="ln1604">  dt_bauhaus_slider_set_soft(g-&gt;blending, p-&gt;blending);</a>
<a name="ln1605">  dt_bauhaus_slider_set_soft(g-&gt;feathering, p-&gt;feathering);</a>
<a name="ln1606">  dt_bauhaus_slider_set_soft(g-&gt;smoothing, logf(p-&gt;smoothing) / logf(sqrtf(2.0f)) - 1.0f);</a>
<a name="ln1607">  dt_bauhaus_slider_set_soft(g-&gt;iterations, p-&gt;iterations);</a>
<a name="ln1608">  dt_bauhaus_slider_set_soft(g-&gt;quantization, p-&gt;quantization);</a>
<a name="ln1609">  dt_bauhaus_slider_set_soft(g-&gt;contrast_boost, p-&gt;contrast_boost);</a>
<a name="ln1610">  dt_bauhaus_slider_set_soft(g-&gt;exposure_boost, p-&gt;exposure_boost);</a>
<a name="ln1611"> </a>
<a name="ln1612">  show_guiding_controls(self);</a>
<a name="ln1613">  gui_cache_init(self);</a>
<a name="ln1614"> </a>
<a name="ln1615">  dt_bauhaus_widget_set_quad_active(GTK_WIDGET(g-&gt;show_luminance_mask), g-&gt;mask_display);</a>
<a name="ln1616">}</a>
<a name="ln1617"> </a>
<a name="ln1618"> </a>
<a name="ln1619">static void noise_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1620">{</a>
<a name="ln1621">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1622">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1623"> </a>
<a name="ln1624">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1625">  p-&gt;noise = dt_bauhaus_slider_get(slider);</a>
<a name="ln1626">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1627">}</a>
<a name="ln1628"> </a>
<a name="ln1629"> </a>
<a name="ln1630">static void ultra_deep_blacks_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1631">{</a>
<a name="ln1632">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1633">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1634">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1635">  p-&gt;ultra_deep_blacks = dt_bauhaus_slider_get(slider);</a>
<a name="ln1636">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1637">}</a>
<a name="ln1638"> </a>
<a name="ln1639"> </a>
<a name="ln1640">static void deep_blacks_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1641">{</a>
<a name="ln1642">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1643">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1644">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1645">  p-&gt;deep_blacks = dt_bauhaus_slider_get(slider);</a>
<a name="ln1646">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1647">}</a>
<a name="ln1648"> </a>
<a name="ln1649"> </a>
<a name="ln1650">static void blacks_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1651">{</a>
<a name="ln1652">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1653">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1654">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1655">  p-&gt;blacks = dt_bauhaus_slider_get(slider);</a>
<a name="ln1656">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1657">}</a>
<a name="ln1658"> </a>
<a name="ln1659"> </a>
<a name="ln1660">static void shadows_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1661">{</a>
<a name="ln1662">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1663">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1664">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1665">  p-&gt;shadows = dt_bauhaus_slider_get(slider);</a>
<a name="ln1666">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1667">}</a>
<a name="ln1668"> </a>
<a name="ln1669"> </a>
<a name="ln1670">static void midtones_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1671">{</a>
<a name="ln1672">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1673">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1674">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1675">  p-&gt;midtones = dt_bauhaus_slider_get(slider);</a>
<a name="ln1676">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1677">}</a>
<a name="ln1678"> </a>
<a name="ln1679"> </a>
<a name="ln1680">static void highlights_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1681">{</a>
<a name="ln1682">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1683">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1684">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1685">  p-&gt;highlights = dt_bauhaus_slider_get(slider);</a>
<a name="ln1686">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1687">}</a>
<a name="ln1688"> </a>
<a name="ln1689"> </a>
<a name="ln1690">static void whites_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1691">{</a>
<a name="ln1692">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1693">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1694">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1695">  p-&gt;whites = dt_bauhaus_slider_get(slider);</a>
<a name="ln1696">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1697">}</a>
<a name="ln1698"> </a>
<a name="ln1699"> </a>
<a name="ln1700">static void speculars_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1701">{</a>
<a name="ln1702">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1703">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1704">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1705">  p-&gt;speculars = dt_bauhaus_slider_get(slider);</a>
<a name="ln1706">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1707">}</a>
<a name="ln1708"> </a>
<a name="ln1709"> </a>
<a name="ln1710">static void method_changed(GtkWidget *widget, gpointer user_data)</a>
<a name="ln1711">{</a>
<a name="ln1712">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1713">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1714">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1715"> </a>
<a name="ln1716">  p-&gt;method = dt_bauhaus_combobox_get(widget);</a>
<a name="ln1717">  invalidate_luminance_cache(self);</a>
<a name="ln1718">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1719">}</a>
<a name="ln1720"> </a>
<a name="ln1721"> </a>
<a name="ln1722">static void details_changed(GtkWidget *widget, gpointer user_data)</a>
<a name="ln1723">{</a>
<a name="ln1724">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1725">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1726">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1727"> </a>
<a name="ln1728">  p-&gt;details = dt_bauhaus_combobox_get(widget);</a>
<a name="ln1729">  invalidate_luminance_cache(self);</a>
<a name="ln1730">  show_guiding_controls(self);</a>
<a name="ln1731">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1732">}</a>
<a name="ln1733"> </a>
<a name="ln1734">static void blending_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1735">{</a>
<a name="ln1736">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1737">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1738">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1739"> </a>
<a name="ln1740">  p-&gt;blending = dt_bauhaus_slider_get(slider);</a>
<a name="ln1741">  invalidate_luminance_cache(self);</a>
<a name="ln1742">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1743">}</a>
<a name="ln1744"> </a>
<a name="ln1745">static void feathering_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1746">{</a>
<a name="ln1747">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1748">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1749">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1750"> </a>
<a name="ln1751">  p-&gt;feathering = dt_bauhaus_slider_get(slider);</a>
<a name="ln1752">  invalidate_luminance_cache(self);</a>
<a name="ln1753">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756">static void smoothing_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1757">{</a>
<a name="ln1758">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1759">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1760">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1761">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1762"> </a>
<a name="ln1763">  p-&gt;smoothing= powf(sqrtf(2.0f), 1.0f +  dt_bauhaus_slider_get(slider));</a>
<a name="ln1764"> </a>
<a name="ln1765">  float factors[CHANNELS] DT_ALIGNED_ARRAY;</a>
<a name="ln1766">  get_channels_factors(factors, p);</a>
<a name="ln1767"> </a>
<a name="ln1768">  // Solve the interpolation by least-squares to check the validity of the smoothing param</a>
<a name="ln1769">  const int valid = update_curve_lut(self);</a>
<a name="ln1770">  if(!valid) dt_control_log(_(&quot;the interpolation is unstable, decrease the curve smoothing&quot;));</a>
<a name="ln1771"> </a>
<a name="ln1772">  // Redraw graph before launching computation</a>
<a name="ln1773">  update_curve_lut(self);</a>
<a name="ln1774">  gtk_widget_queue_draw(GTK_WIDGET(g-&gt;area));</a>
<a name="ln1775">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1776">}</a>
<a name="ln1777"> </a>
<a name="ln1778">static void iterations_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1779">{</a>
<a name="ln1780">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1781">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1782">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1783"> </a>
<a name="ln1784">  p-&gt;iterations = dt_bauhaus_slider_get(slider);</a>
<a name="ln1785">  invalidate_luminance_cache(self);</a>
<a name="ln1786">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1787">}</a>
<a name="ln1788"> </a>
<a name="ln1789">static void quantization_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1790">{</a>
<a name="ln1791">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1792">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1793">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1794"> </a>
<a name="ln1795">  p-&gt;quantization = dt_bauhaus_slider_get(slider);</a>
<a name="ln1796">  invalidate_luminance_cache(self);</a>
<a name="ln1797">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1798">}</a>
<a name="ln1799"> </a>
<a name="ln1800">static void contrast_boost_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1801">{</a>
<a name="ln1802">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1803">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1804">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1805"> </a>
<a name="ln1806">  p-&gt;contrast_boost = dt_bauhaus_slider_get(slider);</a>
<a name="ln1807">  invalidate_luminance_cache(self);</a>
<a name="ln1808">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1809">}</a>
<a name="ln1810"> </a>
<a name="ln1811">static void exposure_boost_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1812">{</a>
<a name="ln1813">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1814">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1815">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1816"> </a>
<a name="ln1817">  p-&gt;exposure_boost = dt_bauhaus_slider_get(slider);</a>
<a name="ln1818">  invalidate_luminance_cache(self);</a>
<a name="ln1819">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1820">}</a>
<a name="ln1821"> </a>
<a name="ln1822">static void auto_adjust_exposure_boost(GtkWidget *quad, gpointer user_data)</a>
<a name="ln1823">{</a>
<a name="ln1824">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1825">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1826"> </a>
<a name="ln1827">  dt_iop_request_focus(self);</a>
<a name="ln1828"> </a>
<a name="ln1829">  if(!self-&gt;enabled)</a>
<a name="ln1830">  {</a>
<a name="ln1831">    // If module disabled, enable and do nothing</a>
<a name="ln1832">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1833">    return;</a>
<a name="ln1834">  }</a>
<a name="ln1835"> </a>
<a name="ln1836">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1837">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1838"> </a>
<a name="ln1839">  if(p-&gt;exposure_boost != 0.0f)</a>
<a name="ln1840">  {</a>
<a name="ln1841">    // Reset the contrast boost and do nothing</a>
<a name="ln1842">    p-&gt;exposure_boost = 0.0f;</a>
<a name="ln1843">    const int reset = darktable.gui-&gt;reset;</a>
<a name="ln1844">    darktable.gui-&gt;reset = 1;</a>
<a name="ln1845">    dt_bauhaus_slider_set_soft(g-&gt;exposure_boost, p-&gt;exposure_boost);</a>
<a name="ln1846">    darktable.gui-&gt;reset = reset;</a>
<a name="ln1847"> </a>
<a name="ln1848">    invalidate_luminance_cache(self);</a>
<a name="ln1849">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1850">    return;</a>
<a name="ln1851">  }</a>
<a name="ln1852"> </a>
<a name="ln1853">  if(!g-&gt;luminance_valid || self-&gt;dev-&gt;pipe-&gt;processing)</a>
<a name="ln1854">  {</a>
<a name="ln1855">    dt_control_log(_(&quot;wait for the preview to finish recomputing&quot;));</a>
<a name="ln1856">    return;</a>
<a name="ln1857">  }</a>
<a name="ln1858"> </a>
<a name="ln1859">  // The goal is to get the exposure distribution centered on the equalizer view</a>
<a name="ln1860">  // to spread it over as many nodes as possible for better exposure control.</a>
<a name="ln1861">  // Controls nodes are between -8 and 0 EV,</a>
<a name="ln1862">  // so we aim at centering the exposure distribution on -4 EV</a>
<a name="ln1863">  const float target = log2f(CONTRAST_FULCRUM);</a>
<a name="ln1864"> </a>
<a name="ln1865">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln1866">  g-&gt;histogram_valid = 0;</a>
<a name="ln1867">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln1868"> </a>
<a name="ln1869">  update_histogram(g);</a>
<a name="ln1870">  p-&gt;exposure_boost += target - g-&gt;histogram_average;</a>
<a name="ln1871"> </a>
<a name="ln1872">  // Update the GUI stuff</a>
<a name="ln1873">  const int reset = darktable.gui-&gt;reset;</a>
<a name="ln1874">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1875">  dt_bauhaus_slider_set_soft(g-&gt;exposure_boost, p-&gt;exposure_boost);</a>
<a name="ln1876">  darktable.gui-&gt;reset = reset;</a>
<a name="ln1877">  invalidate_luminance_cache(self);</a>
<a name="ln1878">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1879">}</a>
<a name="ln1880"> </a>
<a name="ln1881"> </a>
<a name="ln1882">static void auto_adjust_contrast_boost(GtkWidget *quad, gpointer user_data)</a>
<a name="ln1883">{</a>
<a name="ln1884">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1885">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1886"> </a>
<a name="ln1887">  dt_iop_request_focus(self);</a>
<a name="ln1888"> </a>
<a name="ln1889">  if(!self-&gt;enabled)</a>
<a name="ln1890">  {</a>
<a name="ln1891">    // If module disabled, enable and do nothing</a>
<a name="ln1892">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1893">    return;</a>
<a name="ln1894">  }</a>
<a name="ln1895"> </a>
<a name="ln1896">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln1897">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1898"> </a>
<a name="ln1899">  if(p-&gt;contrast_boost != 0.0f)</a>
<a name="ln1900">  {</a>
<a name="ln1901">    // Reset the contrast boost and do nothing</a>
<a name="ln1902">    p-&gt;contrast_boost = 0.0f;</a>
<a name="ln1903">    const int reset = darktable.gui-&gt;reset;</a>
<a name="ln1904">    darktable.gui-&gt;reset = 1;</a>
<a name="ln1905">    dt_bauhaus_slider_set_soft(g-&gt;contrast_boost, p-&gt;contrast_boost);</a>
<a name="ln1906">    darktable.gui-&gt;reset = reset;</a>
<a name="ln1907"> </a>
<a name="ln1908">    invalidate_luminance_cache(self);</a>
<a name="ln1909">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1910">    return;</a>
<a name="ln1911">  }</a>
<a name="ln1912"> </a>
<a name="ln1913">  if(!g-&gt;luminance_valid || self-&gt;dev-&gt;pipe-&gt;processing)</a>
<a name="ln1914">  {</a>
<a name="ln1915">    dt_control_log(_(&quot;wait for the preview to finish recomputing&quot;));</a>
<a name="ln1916">    return;</a>
<a name="ln1917">  }</a>
<a name="ln1918"> </a>
<a name="ln1919">  // The goal is to spread 80 % of the exposure histogram between -4 ± 3 EV</a>
<a name="ln1920">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln1921">  g-&gt;histogram_valid = 0;</a>
<a name="ln1922">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln1923"> </a>
<a name="ln1924">  const float target = log2f(CONTRAST_FULCRUM);</a>
<a name="ln1925">  update_histogram(g);</a>
<a name="ln1926">  const float span_left = fabsf(target - g-&gt;histogram_first_decile);</a>
<a name="ln1927">  const float span_right = fabsf(g-&gt;histogram_last_decile - target);</a>
<a name="ln1928">  const float origin = fmaxf(span_left, span_right);</a>
<a name="ln1929"> </a>
<a name="ln1930">  // Compute the correction</a>
<a name="ln1931">  p-&gt;contrast_boost = (3.0f - origin);</a>
<a name="ln1932"> </a>
<a name="ln1933">  // Update the GUI stuff</a>
<a name="ln1934">  const int reset = darktable.gui-&gt;reset;</a>
<a name="ln1935">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1936">  dt_bauhaus_slider_set_soft(g-&gt;contrast_boost, p-&gt;contrast_boost);</a>
<a name="ln1937">  darktable.gui-&gt;reset = reset;</a>
<a name="ln1938">  invalidate_luminance_cache(self);</a>
<a name="ln1939">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1940">}</a>
<a name="ln1941"> </a>
<a name="ln1942"> </a>
<a name="ln1943">static void show_luminance_mask_callback(GtkWidget *togglebutton, dt_iop_module_t *self)</a>
<a name="ln1944">{</a>
<a name="ln1945">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln1946">  dt_iop_request_focus(self);</a>
<a name="ln1947"> </a>
<a name="ln1948">  if(!self-&gt;enabled)</a>
<a name="ln1949">  {</a>
<a name="ln1950">    // If module disabled, enable and do nothing</a>
<a name="ln1951">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1952">    return;</a>
<a name="ln1953">  }</a>
<a name="ln1954"> </a>
<a name="ln1955">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1956"> </a>
<a name="ln1957">  // if blend module is displaying mask do not display it here</a>
<a name="ln1958">  if(self-&gt;request_mask_display)</a>
<a name="ln1959">  {</a>
<a name="ln1960">    dt_control_log(_(&quot;cannot display masks when the blending mask is displayed&quot;));</a>
<a name="ln1961">    dt_bauhaus_widget_set_quad_active(GTK_WIDGET(g-&gt;show_luminance_mask), FALSE);</a>
<a name="ln1962">    g-&gt;mask_display = 0;</a>
<a name="ln1963">    return;</a>
<a name="ln1964">  }</a>
<a name="ln1965">  else</a>
<a name="ln1966">    g-&gt;mask_display = !g-&gt;mask_display;</a>
<a name="ln1967"> </a>
<a name="ln1968">  dt_bauhaus_widget_set_quad_active(GTK_WIDGET(g-&gt;show_luminance_mask), g-&gt;mask_display);</a>
<a name="ln1969">  dt_dev_reprocess_center(self-&gt;dev);</a>
<a name="ln1970">}</a>
<a name="ln1971"> </a>
<a name="ln1972"> </a>
<a name="ln1973">/***</a>
<a name="ln1974"> * GUI Interactivity</a>
<a name="ln1975"> **/</a>
<a name="ln1976"> </a>
<a name="ln1977">static void switch_cursors(struct dt_iop_module_t *self)</a>
<a name="ln1978">{</a>
<a name="ln1979">  const dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1980">  if(g == NULL) return;</a>
<a name="ln1981"> </a>
<a name="ln1982">  GtkWidget *widget = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1983">  GdkCursor *cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;default&quot;);</a>
<a name="ln1984"> </a>
<a name="ln1985">  // if we are editing masks, do not display controls</a>
<a name="ln1986">  if(!sanity_check(self) || in_mask_editing(self))</a>
<a name="ln1987">  {</a>
<a name="ln1988">    // display default cursor</a>
<a name="ln1989">    gdk_window_set_cursor(gtk_widget_get_window(widget), cursor);</a>
<a name="ln1990">    dt_control_queue_redraw_center();</a>
<a name="ln1991">    g_object_unref(cursor);</a>
<a name="ln1992">    return;</a>
<a name="ln1993">  }</a>
<a name="ln1994"> </a>
<a name="ln1995">  if(!dtgtk_expander_get_expanded(DTGTK_EXPANDER(self-&gt;expander)) || !self-&gt;enabled)</a>
<a name="ln1996">  {</a>
<a name="ln1997">    // if module lost focus or is disabled</a>
<a name="ln1998">    // do nothing and let the app decide</a>
<a name="ln1999">  }</a>
<a name="ln2000">  else if( (self-&gt;dev-&gt;pipe-&gt;processing) ||</a>
<a name="ln2001">          (self-&gt;dev-&gt;image_status == DT_DEV_PIXELPIPE_DIRTY) ||</a>
<a name="ln2002">          (self-&gt;dev-&gt;preview_status == DT_DEV_PIXELPIPE_DIRTY) )</a>
<a name="ln2003">  {</a>
<a name="ln2004">    // display waiting cursor while pipe reprocess or will soon</a>
<a name="ln2005">    cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;wait&quot;);</a>
<a name="ln2006">    gdk_window_set_cursor(gtk_widget_get_window(widget), cursor);</a>
<a name="ln2007">    dt_control_queue_redraw_center();</a>
<a name="ln2008">  }</a>
<a name="ln2009">  else if(g-&gt;cursor_valid &amp;&amp; !self-&gt;dev-&gt;pipe-&gt;processing) // seems reduntand but is not</a>
<a name="ln2010">  {</a>
<a name="ln2011">    // hide GTK cursor because we display ours</a>
<a name="ln2012">    dt_control_change_cursor(GDK_BLANK_CURSOR);</a>
<a name="ln2013">    dt_control_queue_redraw_center();</a>
<a name="ln2014">  }</a>
<a name="ln2015">  else</a>
<a name="ln2016">  {</a>
<a name="ln2017">    // display default cursor</a>
<a name="ln2018">    gdk_window_set_cursor(gtk_widget_get_window(widget), cursor);</a>
<a name="ln2019">    dt_control_queue_redraw_center();</a>
<a name="ln2020">  }</a>
<a name="ln2021"> </a>
<a name="ln2022">  g_object_unref(cursor);</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025"> </a>
<a name="ln2026">int mouse_moved(struct dt_iop_module_t *self, double x, double y, double pressure, int which)</a>
<a name="ln2027">{</a>
<a name="ln2028">  // Whenever the mouse moves over the picture preview, store its coordinates in the GUI struct</a>
<a name="ln2029">  // for later use. This works only if dev-&gt;preview_pipe perfectly overlaps with the UI preview</a>
<a name="ln2030">  // meaning all distortions, cropping, rotations etc. are applied before this module in the pipe.</a>
<a name="ln2031"> </a>
<a name="ln2032">  dt_develop_t *dev = self-&gt;dev;</a>
<a name="ln2033">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2034">  if(!self-&gt;enabled) return 0;</a>
<a name="ln2035"> </a>
<a name="ln2036">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2037">  const int fail = (!sanity_check(self) || !g-&gt;luminance_valid);</a>
<a name="ln2038">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2039">  if(fail) return 0;</a>
<a name="ln2040"> </a>
<a name="ln2041">  const int wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln2042">  const int ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln2043"> </a>
<a name="ln2044">  if(g == NULL) return 0;</a>
<a name="ln2045">  if(wd &lt; 1 || ht &lt; 1) return 0;</a>
<a name="ln2046"> </a>
<a name="ln2047">  float pzx, pzy;</a>
<a name="ln2048">  dt_dev_get_pointer_zoom_pos(dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln2049">  pzx += 0.5f;</a>
<a name="ln2050">  pzy += 0.5f;</a>
<a name="ln2051"> </a>
<a name="ln2052">  const int x_pointer = pzx * wd;</a>
<a name="ln2053">  const int y_pointer = pzy * ht;</a>
<a name="ln2054"> </a>
<a name="ln2055">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2056">  // Cursor is valid if it's inside the picture frame</a>
<a name="ln2057">  if(x_pointer &gt;= 0 &amp;&amp; x_pointer &lt; wd &amp;&amp; y_pointer &gt;= 0 &amp;&amp; y_pointer &lt; ht)</a>
<a name="ln2058">  {</a>
<a name="ln2059">    g-&gt;cursor_valid = TRUE;</a>
<a name="ln2060">    g-&gt;cursor_pos_x = x_pointer;</a>
<a name="ln2061">    g-&gt;cursor_pos_y = y_pointer;</a>
<a name="ln2062">  }</a>
<a name="ln2063">  else</a>
<a name="ln2064">  {</a>
<a name="ln2065">    g-&gt;cursor_valid = FALSE;</a>
<a name="ln2066">    g-&gt;cursor_pos_x = 0;</a>
<a name="ln2067">    g-&gt;cursor_pos_y = 0;</a>
<a name="ln2068">  }</a>
<a name="ln2069">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2070"> </a>
<a name="ln2071">  // store the actual exposure too, to spare I/O op</a>
<a name="ln2072">  if(g-&gt;cursor_valid &amp;&amp; !dev-&gt;pipe-&gt;processing &amp;&amp; g-&gt;luminance_valid)</a>
<a name="ln2073">    g-&gt;cursor_exposure = log2f(get_luminance_from_buffer(g-&gt;thumb_preview_buf,</a>
<a name="ln2074">                                                         g-&gt;thumb_preview_buf_width,</a>
<a name="ln2075">                                                         g-&gt;thumb_preview_buf_height,</a>
<a name="ln2076">                                                         (size_t)x_pointer, (size_t)y_pointer));</a>
<a name="ln2077"> </a>
<a name="ln2078">  // Search for nearest node in graph and highlight it</a>
<a name="ln2079">  const float radius_threshold = 0.45f;</a>
<a name="ln2080">  g-&gt;area_active_node = -1;</a>
<a name="ln2081">  if(g-&gt;cursor_valid)</a>
<a name="ln2082">  {</a>
<a name="ln2083">    for(int i = 0; i &lt; CHANNELS; ++i)</a>
<a name="ln2084">    {</a>
<a name="ln2085">      const float delta_x = fabsf(g-&gt;cursor_exposure - centers_params[i]);</a>
<a name="ln2086">      if(delta_x &lt; radius_threshold)</a>
<a name="ln2087">      {</a>
<a name="ln2088">        g-&gt;area_active_node = i;</a>
<a name="ln2089">      }</a>
<a name="ln2090">    }</a>
<a name="ln2091">  }</a>
<a name="ln2092"> </a>
<a name="ln2093">  switch_cursors(self);</a>
<a name="ln2094">  gtk_widget_queue_draw(GTK_WIDGET(g-&gt;area));</a>
<a name="ln2095">  return 1;</a>
<a name="ln2096">}</a>
<a name="ln2097"> </a>
<a name="ln2098"> </a>
<a name="ln2099">int mouse_leave(struct dt_iop_module_t *self)</a>
<a name="ln2100">{</a>
<a name="ln2101">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2102"> </a>
<a name="ln2103">  if(g == NULL) return 0;</a>
<a name="ln2104"> </a>
<a name="ln2105">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2106">  g-&gt;cursor_valid = FALSE;</a>
<a name="ln2107">  g-&gt;area_active_node = -1;</a>
<a name="ln2108">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2109"> </a>
<a name="ln2110">  // display default cursor</a>
<a name="ln2111">  GtkWidget *widget = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln2112">  GdkCursor *cursor = gdk_cursor_new_from_name(gdk_display_get_default(), &quot;default&quot;);</a>
<a name="ln2113">  gdk_window_set_cursor(gtk_widget_get_window(widget), cursor);</a>
<a name="ln2114">  g_object_unref(cursor);</a>
<a name="ln2115">  dt_control_queue_redraw_center();</a>
<a name="ln2116">  gtk_widget_queue_draw(GTK_WIDGET(g-&gt;area));</a>
<a name="ln2117"> </a>
<a name="ln2118">  return 1;</a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121"> </a>
<a name="ln2122">static inline int set_new_params_interactive(const float control_exposure, const float exposure_offset, const float blending_sigma,</a>
<a name="ln2123">                                              dt_iop_toneequalizer_gui_data_t *g,  dt_iop_toneequalizer_params_t *p)</a>
<a name="ln2124">{</a>
<a name="ln2125">  // Apply an exposure offset optimized smoothly over all the exposure channels,</a>
<a name="ln2126">  // taking user instruction to apply exposure_offset EV at control_exposure EV,</a>
<a name="ln2127">  // and commit the new params is the solution is valid.</a>
<a name="ln2128"> </a>
<a name="ln2129">  // Raise the user params accordingly to control correction and distance from cursor exposure</a>
<a name="ln2130">  // to blend smoothly the desired correction</a>
<a name="ln2131">  const float std = gaussian_denom(blending_sigma);</a>
<a name="ln2132">  if(g-&gt;user_param_valid)</a>
<a name="ln2133">  {</a>
<a name="ln2134">    for(int i = 0; i &lt; CHANNELS; ++i)</a>
<a name="ln2135">      g-&gt;temp_user_params[i] *= exp2f(gaussian_func(centers_params[i] - control_exposure, std) * exposure_offset);</a>
<a name="ln2136">  }</a>
<a name="ln2137"> </a>
<a name="ln2138">  // Get the new weights for the radial-basis approximation</a>
<a name="ln2139">  float factors[CHANNELS] DT_ALIGNED_ARRAY;</a>
<a name="ln2140">  dt_simd_memcpy(g-&gt;temp_user_params, factors, CHANNELS);</a>
<a name="ln2141">  if(g-&gt;user_param_valid)</a>
<a name="ln2142">    g-&gt;user_param_valid = pseudo_solve(g-&gt;interpolation_matrix, factors, CHANNELS, PIXEL_CHAN, 1);;</a>
<a name="ln2143">  if(!g-&gt;user_param_valid) dt_control_log(_(&quot;the interpolation is unstable, decrease the curve smoothing&quot;));</a>
<a name="ln2144"> </a>
<a name="ln2145">  // Compute new user params for channels and store them locally</a>
<a name="ln2146">  if(g-&gt;user_param_valid)</a>
<a name="ln2147">    g-&gt;user_param_valid = compute_channels_factors(factors, g-&gt;temp_user_params, g-&gt;sigma);</a>
<a name="ln2148">  if(!g-&gt;user_param_valid) dt_control_log(_(&quot;some parameters are out-of-bounds&quot;));</a>
<a name="ln2149"> </a>
<a name="ln2150">  const int commit = g-&gt;user_param_valid;</a>
<a name="ln2151"> </a>
<a name="ln2152">  if(commit)</a>
<a name="ln2153">  {</a>
<a name="ln2154">    // Accept the solution</a>
<a name="ln2155">    dt_simd_memcpy(factors, g-&gt;factors, PIXEL_CHAN);</a>
<a name="ln2156">    g-&gt;lut_valid = 0;</a>
<a name="ln2157"> </a>
<a name="ln2158">    // Convert the linear temp parameters to log gains and commit</a>
<a name="ln2159">    float gains[CHANNELS] DT_ALIGNED_ARRAY;</a>
<a name="ln2160">    compute_channels_gains(g-&gt;temp_user_params, gains);</a>
<a name="ln2161">    commit_channels_gains(gains, p);</a>
<a name="ln2162">  }</a>
<a name="ln2163">  else</a>
<a name="ln2164">  {</a>
<a name="ln2165">    // Reset the GUI copy of user params</a>
<a name="ln2166">    get_channels_factors(factors, p);</a>
<a name="ln2167">    dt_simd_memcpy(factors, g-&gt;temp_user_params, CHANNELS);</a>
<a name="ln2168">    g-&gt;user_param_valid = 1;</a>
<a name="ln2169">  }</a>
<a name="ln2170"> </a>
<a name="ln2171">  return commit;</a>
<a name="ln2172">}</a>
<a name="ln2173"> </a>
<a name="ln2174"> </a>
<a name="ln2175">int scrolled(struct dt_iop_module_t *self, double x, double y, int up, uint32_t state)</a>
<a name="ln2176">{</a>
<a name="ln2177">  dt_develop_t *dev = self-&gt;dev;</a>
<a name="ln2178">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2179">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln2180"> </a>
<a name="ln2181">  if(!sanity_check(self)) return 0;</a>
<a name="ln2182">  if(self-&gt;dt-&gt;gui-&gt;reset) return 1;</a>
<a name="ln2183">  if(!self-&gt;enabled) return 0;</a>
<a name="ln2184">  if(g == NULL) return 0;</a>
<a name="ln2185"> </a>
<a name="ln2186">  // add an option to allow skip mouse events while editing masks</a>
<a name="ln2187">  if(darktable.develop-&gt;darkroom_skip_mouse_events || in_mask_editing(self)) return 0;</a>
<a name="ln2188"> </a>
<a name="ln2189">  // if GUI buffers not ready, exit but still handle the cursor</a>
<a name="ln2190">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2191">  const int fail = (!g-&gt;cursor_valid || !g-&gt;luminance_valid || !g-&gt;interpolation_valid || !g-&gt;user_param_valid || dev-&gt;pipe-&gt;processing);</a>
<a name="ln2192">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2193">  if(fail) return 1;</a>
<a name="ln2194"> </a>
<a name="ln2195">  // re-read the exposure in case it has changed</a>
<a name="ln2196">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2197">  g-&gt;cursor_exposure = log2f(get_luminance_from_buffer(g-&gt;thumb_preview_buf,</a>
<a name="ln2198">                                                       g-&gt;thumb_preview_buf_width,</a>
<a name="ln2199">                                                       g-&gt;thumb_preview_buf_height,</a>
<a name="ln2200">                                                       (size_t)g-&gt;cursor_pos_x, (size_t)g-&gt;cursor_pos_y));</a>
<a name="ln2201">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2202"> </a>
<a name="ln2203">  // Set the correction from mouse scroll input</a>
<a name="ln2204">  const float increment = (up) ? +1.0f : -1.0f;</a>
<a name="ln2205"> </a>
<a name="ln2206">  float step;</a>
<a name="ln2207">  if((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln2208">    step = 1.0f;  // coarse</a>
<a name="ln2209">  else if((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK)</a>
<a name="ln2210">    step = 0.1f;  // fine</a>
<a name="ln2211">  else</a>
<a name="ln2212">    step = 0.25f; // standard</a>
<a name="ln2213"> </a>
<a name="ln2214">  const float offset = step * ((float)increment);</a>
<a name="ln2215"> </a>
<a name="ln2216">  // Get the desired correction on exposure channels</a>
<a name="ln2217">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2218">  const int commit = set_new_params_interactive(g-&gt;cursor_exposure, offset, g-&gt;sigma * g-&gt;sigma / 2.0f, g, p);</a>
<a name="ln2219">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2220"> </a>
<a name="ln2221">  gtk_widget_queue_draw(GTK_WIDGET(g-&gt;area));</a>
<a name="ln2222"> </a>
<a name="ln2223">  if(commit)</a>
<a name="ln2224">  {</a>
<a name="ln2225">    // Update GUI with new params</a>
<a name="ln2226">    const int reset = self-&gt;dt-&gt;gui-&gt;reset;</a>
<a name="ln2227">    self-&gt;dt-&gt;gui-&gt;reset = 1;</a>
<a name="ln2228">    update_exposure_sliders(g, p);</a>
<a name="ln2229">    self-&gt;dt-&gt;gui-&gt;reset = reset;</a>
<a name="ln2230"> </a>
<a name="ln2231">    dt_dev_add_history_item(darktable.develop, self, FALSE);</a>
<a name="ln2232">  }</a>
<a name="ln2233"> </a>
<a name="ln2234">  return 1;</a>
<a name="ln2235">}</a>
<a name="ln2236"> </a>
<a name="ln2237">/***</a>
<a name="ln2238"> * GTK/Cairo drawings and custom widgets</a>
<a name="ln2239"> **/</a>
<a name="ln2240"> </a>
<a name="ln2241">static inline gboolean _init_drawing(GtkWidget *widget, dt_iop_toneequalizer_gui_data_t *g);</a>
<a name="ln2242"> </a>
<a name="ln2243"> </a>
<a name="ln2244">void cairo_draw_hatches(cairo_t *cr, double center[2], double span[2], int instances, double line_width, double shade)</a>
<a name="ln2245">{</a>
<a name="ln2246">  // center is the (x, y) coordinates of the region to draw</a>
<a name="ln2247">  // span is the distance of the region's bounds to the center, over (x, y) axes</a>
<a name="ln2248"> </a>
<a name="ln2249">  // Get the coordinates of the corners of the bounding box of the region</a>
<a name="ln2250">  double C0[2] = { center[0] - span[0], center[1] - span[1] };</a>
<a name="ln2251">  double C2[2] = { center[0] + span[0], center[1] + span[1] };</a>
<a name="ln2252"> </a>
<a name="ln2253">  double delta[2] = { 2.0 * span[0] / (double)instances,</a>
<a name="ln2254">                      2.0 * span[1] / (double)instances };</a>
<a name="ln2255"> </a>
<a name="ln2256">  cairo_set_line_width(cr, line_width);</a>
<a name="ln2257">  cairo_set_source_rgb(cr, shade, shade, shade);</a>
<a name="ln2258"> </a>
<a name="ln2259">  for(int i = -instances / 2 - 1; i &lt;= instances / 2 + 1; i++)</a>
<a name="ln2260">  {</a>
<a name="ln2261">    cairo_move_to(cr, C0[0] + (double)i * delta[0], C0[1]);</a>
<a name="ln2262">    cairo_line_to(cr, C2[0] + (double)i * delta[0], C2[1]);</a>
<a name="ln2263">    cairo_stroke(cr);</a>
<a name="ln2264">  }</a>
<a name="ln2265">}</a>
<a name="ln2266"> </a>
<a name="ln2267">static void get_shade_from_luminance(cairo_t *cr, const float luminance, const float alpha)</a>
<a name="ln2268">{</a>
<a name="ln2269">  // TODO: fetch screen gamma from ICC display profile</a>
<a name="ln2270">  const float gamma = 1.0f / 2.2f;</a>
<a name="ln2271">  const float shade = powf(luminance, gamma);</a>
<a name="ln2272">  cairo_set_source_rgba(cr, shade, shade, shade, alpha);</a>
<a name="ln2273">}</a>
<a name="ln2274"> </a>
<a name="ln2275"> </a>
<a name="ln2276">static void draw_exposure_cursor(cairo_t *cr, const double pointerx, const double pointery, const double radius, const float luminance, const float zoom_scale, const int instances, const float alpha)</a>
<a name="ln2277">{</a>
<a name="ln2278">  // Draw a circle cursor filled with a grey shade corresponding to a luminance value</a>
<a name="ln2279">  // or hatches if the value is above the overexposed threshold</a>
<a name="ln2280"> </a>
<a name="ln2281">  const double radius_z = radius / zoom_scale;</a>
<a name="ln2282"> </a>
<a name="ln2283">  get_shade_from_luminance(cr, luminance, alpha);</a>
<a name="ln2284">  cairo_arc(cr, pointerx, pointery, radius_z, 0, 2 * M_PI);</a>
<a name="ln2285">  cairo_fill_preserve(cr);</a>
<a name="ln2286">  cairo_save(cr);</a>
<a name="ln2287">  cairo_clip(cr);</a>
<a name="ln2288"> </a>
<a name="ln2289">  if(log2f(luminance) &gt; 0.0f)</a>
<a name="ln2290">  {</a>
<a name="ln2291">    // if overexposed, draw hatches</a>
<a name="ln2292">    double pointer_coord[2] = { pointerx, pointery };</a>
<a name="ln2293">    double span[2] = { radius_z, radius_z };</a>
<a name="ln2294">    cairo_draw_hatches(cr, pointer_coord, span, instances, DT_PIXEL_APPLY_DPI(1. / zoom_scale), 0.3);</a>
<a name="ln2295">  }</a>
<a name="ln2296">  cairo_restore(cr);</a>
<a name="ln2297">}</a>
<a name="ln2298"> </a>
<a name="ln2299"> </a>
<a name="ln2300">static void match_color_to_background(cairo_t *cr, const float exposure, const float alpha)</a>
<a name="ln2301">{</a>
<a name="ln2302">  float shade = 0.0f;</a>
<a name="ln2303">  // TODO: put that as a preference in darktablerc</a>
<a name="ln2304">  const float contrast = 1.0f;</a>
<a name="ln2305"> </a>
<a name="ln2306">  if(exposure &gt; -2.5f)</a>
<a name="ln2307">    shade = (fminf(exposure * contrast, 0.0f) - 2.5f);</a>
<a name="ln2308">  else</a>
<a name="ln2309">    shade = (fmaxf(exposure / contrast, -5.0f) + 2.5f);</a>
<a name="ln2310"> </a>
<a name="ln2311">  get_shade_from_luminance(cr, exp2f(shade), alpha);</a>
<a name="ln2312">}</a>
<a name="ln2313"> </a>
<a name="ln2314"> </a>
<a name="ln2315">void gui_post_expose(struct dt_iop_module_t *self, cairo_t *cr, int32_t width, int32_t height,</a>
<a name="ln2316">                     int32_t pointerx, int32_t pointery)</a>
<a name="ln2317">{</a>
<a name="ln2318">  // Draw the custom exposure cursor over the image preview</a>
<a name="ln2319"> </a>
<a name="ln2320">  dt_develop_t *dev = self-&gt;dev;</a>
<a name="ln2321">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2322"> </a>
<a name="ln2323">  // if we are editing masks, do not display controls</a>
<a name="ln2324">  if(in_mask_editing(self)) return;</a>
<a name="ln2325"> </a>
<a name="ln2326">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2327">  const int fail = (!g-&gt;cursor_valid || !g-&gt;interpolation_valid || !g-&gt;luminance_valid || dev-&gt;pipe-&gt;processing || !sanity_check(self));</a>
<a name="ln2328">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2329">  if(fail) return;</a>
<a name="ln2330"> </a>
<a name="ln2331">  if(!g-&gt;graph_valid)</a>
<a name="ln2332">    if(!_init_drawing(self-&gt;widget, g)) return;</a>
<a name="ln2333"> </a>
<a name="ln2334">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2335"> </a>
<a name="ln2336">  // re-read the exposure in case it has changed</a>
<a name="ln2337">  g-&gt;cursor_exposure = log2f(get_luminance_from_buffer(g-&gt;thumb_preview_buf,</a>
<a name="ln2338">                                                       g-&gt;thumb_preview_buf_width,</a>
<a name="ln2339">                                                       g-&gt;thumb_preview_buf_height,</a>
<a name="ln2340">                                                       (size_t)g-&gt;cursor_pos_x, (size_t)g-&gt;cursor_pos_y));</a>
<a name="ln2341"> </a>
<a name="ln2342">  // Get coordinates</a>
<a name="ln2343">  const float x_pointer = g-&gt;cursor_pos_x;</a>
<a name="ln2344">  const float y_pointer = g-&gt;cursor_pos_y;</a>
<a name="ln2345"> </a>
<a name="ln2346">  // Get the corresponding exposure</a>
<a name="ln2347">  const float exposure_in = g-&gt;cursor_exposure;</a>
<a name="ln2348">  const float luminance_in = exp2f(exposure_in);</a>
<a name="ln2349"> </a>
<a name="ln2350">  // Get the corresponding correction and compute resulting exposure</a>
<a name="ln2351">  const float correction = log2f(pixel_correction(exposure_in, g-&gt;factors, g-&gt;sigma));</a>
<a name="ln2352">  const float exposure_out = exposure_in + correction;</a>
<a name="ln2353">  const float luminance_out = exp2f(exposure_out);</a>
<a name="ln2354"> </a>
<a name="ln2355">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2356"> </a>
<a name="ln2357">  // Rescale and shift Cairo drawing coordinates</a>
<a name="ln2358">  const float wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln2359">  const float ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln2360">  const float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln2361">  const float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln2362">  const dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln2363">  const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln2364">  const float zoom_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln2365">  cairo_translate(cr, width / 2.0, height / 2.0);</a>
<a name="ln2366">  cairo_scale(cr, zoom_scale, zoom_scale);</a>
<a name="ln2367">  cairo_translate(cr, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln2368"> </a>
<a name="ln2369">  if(correction != correction || exposure_in != exposure_in) return; // something went wrong</a>
<a name="ln2370"> </a>
<a name="ln2371">  // set custom cursor dimensions</a>
<a name="ln2372">  const double outer_radius = 16.;</a>
<a name="ln2373">  const double inner_radius = outer_radius / 2.0;</a>
<a name="ln2374">  const double setting_scale = 2. * outer_radius / zoom_scale;</a>
<a name="ln2375">  const double setting_offset_x = (outer_radius + 4. * g-&gt;inner_padding) / zoom_scale;</a>
<a name="ln2376"> </a>
<a name="ln2377">  // setting fill bars</a>
<a name="ln2378">  match_color_to_background(cr, exposure_out, 1.0);</a>
<a name="ln2379">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(6. / zoom_scale));</a>
<a name="ln2380">  cairo_move_to(cr, x_pointer - setting_offset_x, y_pointer);</a>
<a name="ln2381">  cairo_line_to(cr, x_pointer - setting_offset_x, y_pointer - correction * setting_scale);</a>
<a name="ln2382">  cairo_stroke(cr);</a>
<a name="ln2383"> </a>
<a name="ln2384">  // setting ground level</a>
<a name="ln2385">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.5 / zoom_scale));</a>
<a name="ln2386">  cairo_move_to(cr, x_pointer + (outer_radius + 2. * g-&gt;inner_padding) / zoom_scale, y_pointer);</a>
<a name="ln2387">  cairo_line_to(cr, x_pointer + outer_radius / zoom_scale, y_pointer);</a>
<a name="ln2388">  cairo_move_to(cr, x_pointer - outer_radius / zoom_scale, y_pointer);</a>
<a name="ln2389">  cairo_line_to(cr, x_pointer - setting_offset_x - 4.0 * g-&gt;inner_padding / zoom_scale, y_pointer);</a>
<a name="ln2390">  cairo_stroke(cr);</a>
<a name="ln2391"> </a>
<a name="ln2392">  // don't display the setting bullets if we are waiting for a luminance computation to finish</a>
<a name="ln2393">  cairo_arc(cr, x_pointer - setting_offset_x, y_pointer - correction * setting_scale, DT_PIXEL_APPLY_DPI(7. / zoom_scale), 0, 2. * M_PI);</a>
<a name="ln2394">  cairo_fill(cr);</a>
<a name="ln2395"> </a>
<a name="ln2396">  // draw exposure cursor</a>
<a name="ln2397">  draw_exposure_cursor(cr, x_pointer, y_pointer, outer_radius, luminance_in, zoom_scale, 6, .9);</a>
<a name="ln2398">  draw_exposure_cursor(cr, x_pointer, y_pointer, inner_radius, luminance_out, zoom_scale, 3, .9);</a>
<a name="ln2399"> </a>
<a name="ln2400">  // Create Pango objects : texts</a>
<a name="ln2401">  char text[256];</a>
<a name="ln2402">  PangoLayout *layout;</a>
<a name="ln2403">  PangoRectangle ink;</a>
<a name="ln2404">  PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln2405"> </a>
<a name="ln2406">  // Avoid text resizing based on zoom level</a>
<a name="ln2407">  const int old_size = pango_font_description_get_size(desc);</a>
<a name="ln2408">  pango_font_description_set_size (desc, (int)(old_size / zoom_scale));</a>
<a name="ln2409">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln2410">  pango_layout_set_font_description(layout, desc);</a>
<a name="ln2411"> </a>
<a name="ln2412">  // Build text object</a>
<a name="ln2413">  snprintf(text, sizeof(text), &quot;%+.1f EV&quot;, exposure_in);</a>
<a name="ln2414">  pango_layout_set_text(layout, text, -1);</a>
<a name="ln2415">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln2416"> </a>
<a name="ln2417">  // Draw the text plain blackground</a>
<a name="ln2418">  get_shade_from_luminance(cr, luminance_out, 0.75);</a>
<a name="ln2419">  cairo_rectangle(cr, x_pointer + (outer_radius + 2. * g-&gt;inner_padding) / zoom_scale,</a>
<a name="ln2420">                      y_pointer - ink.y - ink.height / 2.0 - g-&gt;inner_padding / zoom_scale,</a>
<a name="ln2421">                      ink.width + 2.0 * ink.x + 4. * g-&gt;inner_padding / zoom_scale,</a>
<a name="ln2422">                      ink.height + 2.0 * ink.y + 2. * g-&gt;inner_padding / zoom_scale);</a>
<a name="ln2423">  cairo_fill(cr);</a>
<a name="ln2424"> </a>
<a name="ln2425">  // Display the EV reading</a>
<a name="ln2426">  match_color_to_background(cr, exposure_out, 1.0);</a>
<a name="ln2427">  cairo_move_to(cr, x_pointer + (outer_radius + 4. * g-&gt;inner_padding) / zoom_scale,</a>
<a name="ln2428">                    y_pointer - ink.y - ink.height / 2.);</a>
<a name="ln2429">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln2430">  cairo_stroke(cr);</a>
<a name="ln2431">}</a>
<a name="ln2432"> </a>
<a name="ln2433"> </a>
<a name="ln2434">static inline gboolean _init_drawing(GtkWidget *widget, dt_iop_toneequalizer_gui_data_t *g)</a>
<a name="ln2435">{</a>
<a name="ln2436">  // Cache the equalizer graph objects to avoid recomputing all the view at each redraw</a>
<a name="ln2437">  gtk_widget_get_allocation(widget, &amp;g-&gt;allocation);</a>
<a name="ln2438">  g-&gt;cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, g-&gt;allocation.width, g-&gt;allocation.height);</a>
<a name="ln2439">  g-&gt;cr = cairo_create(g-&gt;cst);</a>
<a name="ln2440">  g-&gt;layout = pango_cairo_create_layout(g-&gt;cr);</a>
<a name="ln2441">  g-&gt;desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln2442">  pango_layout_set_font_description(g-&gt;layout, g-&gt;desc);</a>
<a name="ln2443">  g-&gt;context = gtk_widget_get_style_context(widget);</a>
<a name="ln2444"> </a>
<a name="ln2445">  char text[256];</a>
<a name="ln2446"> </a>
<a name="ln2447">  // Get the text line height for spacing</a>
<a name="ln2448">  snprintf(text, sizeof(text), &quot;X&quot;);</a>
<a name="ln2449">  pango_layout_set_text(g-&gt;layout, text, -1);</a>
<a name="ln2450">  pango_layout_get_pixel_extents(g-&gt;layout, &amp;g-&gt;ink, NULL);</a>
<a name="ln2451">  g-&gt;line_height = g-&gt;ink.height;</a>
<a name="ln2452"> </a>
<a name="ln2453">  // Get the width of a minus sign for legend labels spacing</a>
<a name="ln2454">  snprintf(text, sizeof(text), &quot;-&quot;);</a>
<a name="ln2455">  pango_layout_set_text(g-&gt;layout, text, -1);</a>
<a name="ln2456">  pango_layout_get_pixel_extents(g-&gt;layout, &amp;g-&gt;ink, NULL);</a>
<a name="ln2457">  g-&gt;sign_width = g-&gt;ink.width / 2.0;</a>
<a name="ln2458"> </a>
<a name="ln2459">  // Set the sizes, margins and paddings</a>
<a name="ln2460">  g-&gt;inner_padding = 4; // TODO: INNER_PADDING value as defined in bauhaus.c macros, sync them</a>
<a name="ln2461">  g-&gt;inset = g-&gt;inner_padding + darktable.bauhaus-&gt;quad_width;</a>
<a name="ln2462">  g-&gt;graph_width = g-&gt;allocation.width - 2.0 * g-&gt;inset - 2.0 * g-&gt;line_height; // align the right border on sliders</a>
<a name="ln2463">  g-&gt;graph_height = g-&gt;graph_width; // give room to nodes</a>
<a name="ln2464">  g-&gt;gradient_left_limit = 0.0;</a>
<a name="ln2465">  g-&gt;gradient_right_limit = g-&gt;graph_width;</a>
<a name="ln2466">  g-&gt;gradient_top_limit = g-&gt;graph_height + 2 * g-&gt;inner_padding;</a>
<a name="ln2467">  g-&gt;gradient_width = g-&gt;gradient_right_limit - g-&gt;gradient_left_limit;</a>
<a name="ln2468">  g-&gt;legend_top_limit = -0.5 * g-&gt;line_height - 2.0 * g-&gt;inner_padding;</a>
<a name="ln2469">  g-&gt;x_label = g-&gt;graph_width + g-&gt;sign_width + 3.0 * g-&gt;inner_padding;</a>
<a name="ln2470"> </a>
<a name="ln2471">  gtk_render_background(g-&gt;context, g-&gt;cr, 0, 0, g-&gt;allocation.width, g-&gt;allocation.height);</a>
<a name="ln2472"> </a>
<a name="ln2473">  // set the graph as the origin of the coordinates</a>
<a name="ln2474">  cairo_translate(g-&gt;cr, g-&gt;line_height + 2 * g-&gt;inner_padding, g-&gt;line_height + 3 * g-&gt;inner_padding);</a>
<a name="ln2475"> </a>
<a name="ln2476">  // display x-axis and y-axis legends (EV)</a>
<a name="ln2477">  set_color(g-&gt;cr, darktable.bauhaus-&gt;graph_fg);</a>
<a name="ln2478"> </a>
<a name="ln2479">  float value = -8.0f;</a>
<a name="ln2480"> </a>
<a name="ln2481">  for(int k = 0; k &lt; CHANNELS; k++)</a>
<a name="ln2482">  {</a>
<a name="ln2483">    const float xn = (((float)k) / ((float)(CHANNELS - 1))) * g-&gt;graph_width - g-&gt;sign_width;</a>
<a name="ln2484">    snprintf(text, sizeof(text), &quot;%+.0f&quot;, value);</a>
<a name="ln2485">    pango_layout_set_text(g-&gt;layout, text, -1);</a>
<a name="ln2486">    pango_layout_get_pixel_extents(g-&gt;layout, &amp;g-&gt;ink, NULL);</a>
<a name="ln2487">    cairo_move_to(g-&gt;cr, xn - 0.5 * g-&gt;ink.width - g-&gt;ink.x,</a>
<a name="ln2488">                         g-&gt;legend_top_limit - 0.5 * g-&gt;ink.height - g-&gt;ink.y);</a>
<a name="ln2489">    pango_cairo_show_layout(g-&gt;cr, g-&gt;layout);</a>
<a name="ln2490">    cairo_stroke(g-&gt;cr);</a>
<a name="ln2491"> </a>
<a name="ln2492">    value += 1.0;</a>
<a name="ln2493">  }</a>
<a name="ln2494"> </a>
<a name="ln2495">  value = 2.0f;</a>
<a name="ln2496"> </a>
<a name="ln2497">  for(int k = 0; k &lt; 5; k++)</a>
<a name="ln2498">  {</a>
<a name="ln2499">    const float yn = (k / 4.0f) * g-&gt;graph_height;</a>
<a name="ln2500">    snprintf(text, sizeof(text), &quot;%+.0f&quot;, value);</a>
<a name="ln2501">    pango_layout_set_text(g-&gt;layout, text, -1);</a>
<a name="ln2502">    pango_layout_get_pixel_extents(g-&gt;layout, &amp;g-&gt;ink, NULL);</a>
<a name="ln2503">    cairo_move_to(g-&gt;cr, g-&gt;x_label - 0.5 * g-&gt;ink.width - g-&gt;ink.x,</a>
<a name="ln2504">                yn - 0.5 * g-&gt;ink.height - g-&gt;ink.y);</a>
<a name="ln2505">    pango_cairo_show_layout(g-&gt;cr, g-&gt;layout);</a>
<a name="ln2506">    cairo_stroke(g-&gt;cr);</a>
<a name="ln2507"> </a>
<a name="ln2508">    value -= 1.0;</a>
<a name="ln2509">  }</a>
<a name="ln2510"> </a>
<a name="ln2511">  /** x axis **/</a>
<a name="ln2512">  // Draw the perceptually even gradient</a>
<a name="ln2513">  cairo_pattern_t *grad;</a>
<a name="ln2514">  grad = cairo_pattern_create_linear(g-&gt;gradient_left_limit, 0.0, g-&gt;gradient_right_limit, 0.0);</a>
<a name="ln2515">  dt_cairo_perceptual_gradient(grad, 1.0);</a>
<a name="ln2516">  cairo_set_line_width(g-&gt;cr, 0.0);</a>
<a name="ln2517">  cairo_rectangle(g-&gt;cr, g-&gt;gradient_left_limit, g-&gt;gradient_top_limit, g-&gt;gradient_width, g-&gt;line_height);</a>
<a name="ln2518">  cairo_set_source(g-&gt;cr, grad);</a>
<a name="ln2519">  cairo_fill(g-&gt;cr);</a>
<a name="ln2520"> </a>
<a name="ln2521">  /** y axis **/</a>
<a name="ln2522">  // Draw the perceptually even gradient</a>
<a name="ln2523">  grad = cairo_pattern_create_linear(0.0, g-&gt;graph_height, 0.0, 0.0);</a>
<a name="ln2524">  dt_cairo_perceptual_gradient(grad, 1.0);</a>
<a name="ln2525">  cairo_set_line_width(g-&gt;cr, 0.0);</a>
<a name="ln2526">  cairo_rectangle(g-&gt;cr, -g-&gt;line_height - 2 * g-&gt;inner_padding, 0.0, g-&gt;line_height, g-&gt;graph_height);</a>
<a name="ln2527">  cairo_set_source(g-&gt;cr, grad);</a>
<a name="ln2528">  cairo_fill(g-&gt;cr);</a>
<a name="ln2529"> </a>
<a name="ln2530">  cairo_pattern_destroy(grad);</a>
<a name="ln2531"> </a>
<a name="ln2532">  // Draw frame borders</a>
<a name="ln2533">  cairo_set_line_width(g-&gt;cr, DT_PIXEL_APPLY_DPI(0.5));</a>
<a name="ln2534">  set_color(g-&gt;cr, darktable.bauhaus-&gt;graph_border);</a>
<a name="ln2535">  cairo_rectangle(g-&gt;cr, 0, 0, g-&gt;graph_width, g-&gt;graph_height);</a>
<a name="ln2536">  cairo_stroke_preserve(g-&gt;cr);</a>
<a name="ln2537"> </a>
<a name="ln2538">  // end of caching section, this will not be drawn again</a>
<a name="ln2539"> </a>
<a name="ln2540">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2541">  g-&gt;graph_valid = 1;</a>
<a name="ln2542">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2543"> </a>
<a name="ln2544">  return TRUE;</a>
<a name="ln2545">}</a>
<a name="ln2546"> </a>
<a name="ln2547"> </a>
<a name="ln2548">static inline void init_nodes_x(dt_iop_toneequalizer_gui_data_t *g)</a>
<a name="ln2549">{</a>
<a name="ln2550">  if(g == NULL) return;</a>
<a name="ln2551"> </a>
<a name="ln2552">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2553">  if(!g-&gt;valid_nodes_x &amp;&amp; g-&gt;graph_width &gt; 0)</a>
<a name="ln2554">  {</a>
<a name="ln2555">    for(int i = 0; i &lt; CHANNELS; ++i)</a>
<a name="ln2556">      g-&gt;nodes_x[i] = (((float)i) / ((float)(CHANNELS - 1))) * g-&gt;graph_width;</a>
<a name="ln2557">    g-&gt;valid_nodes_x = TRUE;</a>
<a name="ln2558">  }</a>
<a name="ln2559">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2560">}</a>
<a name="ln2561"> </a>
<a name="ln2562"> </a>
<a name="ln2563">static inline void init_nodes_y(dt_iop_toneequalizer_gui_data_t *g)</a>
<a name="ln2564">{</a>
<a name="ln2565">  if(g == NULL) return;</a>
<a name="ln2566"> </a>
<a name="ln2567">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2568">  if(g-&gt;user_param_valid &amp;&amp; g-&gt;graph_height &gt; 0)</a>
<a name="ln2569">  {</a>
<a name="ln2570">    for(int i = 0; i &lt; CHANNELS; ++i)</a>
<a name="ln2571">      g-&gt;nodes_y[i] =  (0.5 - log2f(g-&gt;temp_user_params[i]) / 4.0) * g-&gt;graph_height; // assumes factors in [-2 ; 2] EV</a>
<a name="ln2572">    g-&gt;valid_nodes_y = TRUE;</a>
<a name="ln2573">  }</a>
<a name="ln2574">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2575">}</a>
<a name="ln2576"> </a>
<a name="ln2577"> </a>
<a name="ln2578">static gboolean area_draw(GtkWidget *widget, cairo_t *cr, gpointer user_data)</a>
<a name="ln2579">{</a>
<a name="ln2580">  // Draw the widget equalizer view</a>
<a name="ln2581">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln2582">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2583">  if(g == NULL) return FALSE;</a>
<a name="ln2584"> </a>
<a name="ln2585">  // Init or refresh the drawing cache</a>
<a name="ln2586">  //if(!g-&gt;graph_valid)</a>
<a name="ln2587">  if(!_init_drawing(self-&gt;widget, g)) return FALSE; // this can be cached and drawn just once, but too lazy to debug a cache invalidation for Cairo objects</a>
<a name="ln2588"> </a>
<a name="ln2589">  // Refresh cached UI elements</a>
<a name="ln2590">  update_histogram(g);</a>
<a name="ln2591">  update_curve_lut(self);</a>
<a name="ln2592"> </a>
<a name="ln2593">  // Draw graph background</a>
<a name="ln2594">  cairo_set_line_width(g-&gt;cr, DT_PIXEL_APPLY_DPI(0.5));</a>
<a name="ln2595">  cairo_rectangle(g-&gt;cr, 0, 0, g-&gt;graph_width, g-&gt;graph_height);</a>
<a name="ln2596">  set_color(g-&gt;cr, darktable.bauhaus-&gt;graph_bg);</a>
<a name="ln2597">  cairo_fill(g-&gt;cr);</a>
<a name="ln2598"> </a>
<a name="ln2599">  // draw grid</a>
<a name="ln2600">  cairo_set_line_width(g-&gt;cr, DT_PIXEL_APPLY_DPI(0.5));</a>
<a name="ln2601">  set_color(g-&gt;cr, darktable.bauhaus-&gt;graph_border);</a>
<a name="ln2602">  dt_draw_grid(g-&gt;cr, 8, 0, 0, g-&gt;graph_width, g-&gt;graph_height);</a>
<a name="ln2603"> </a>
<a name="ln2604">  // draw ground level</a>
<a name="ln2605">  set_color(g-&gt;cr, darktable.bauhaus-&gt;graph_fg);</a>
<a name="ln2606">  cairo_set_line_width(g-&gt;cr, DT_PIXEL_APPLY_DPI(1));</a>
<a name="ln2607">  cairo_move_to(g-&gt;cr, 0, 0.5 * g-&gt;graph_height);</a>
<a name="ln2608">  cairo_line_to(g-&gt;cr, g-&gt;graph_width, 0.5 * g-&gt;graph_height);</a>
<a name="ln2609">  cairo_stroke(g-&gt;cr);</a>
<a name="ln2610"> </a>
<a name="ln2611">  if(g-&gt;histogram_valid &amp;&amp; self-&gt;enabled)</a>
<a name="ln2612">  {</a>
<a name="ln2613">    // draw the inset histogram</a>
<a name="ln2614">    set_color(g-&gt;cr, darktable.bauhaus-&gt;inset_histogram);</a>
<a name="ln2615">    cairo_set_line_width(g-&gt;cr, DT_PIXEL_APPLY_DPI(4.0));</a>
<a name="ln2616">    cairo_move_to(g-&gt;cr, 0, g-&gt;graph_height);</a>
<a name="ln2617"> </a>
<a name="ln2618">    for(int k = 0; k &lt; UI_SAMPLES; k++)</a>
<a name="ln2619">    {</a>
<a name="ln2620">      // the x range is [-8;+0] EV</a>
<a name="ln2621">      const float x_temp = (8.0 * (float)k / (float)(UI_SAMPLES - 1)) - 8.0;</a>
<a name="ln2622">      const float y_temp = (float)(g-&gt;histogram[k]) / (float)(g-&gt;max_histogram) * 0.96;</a>
<a name="ln2623">      cairo_line_to(g-&gt;cr, (x_temp + 8.0) * g-&gt;graph_width / 8.0,</a>
<a name="ln2624">                           (1.0 - y_temp) * g-&gt;graph_height );</a>
<a name="ln2625">    }</a>
<a name="ln2626">    cairo_line_to(g-&gt;cr, g-&gt;graph_width, g-&gt;graph_height);</a>
<a name="ln2627">    cairo_close_path(g-&gt;cr);</a>
<a name="ln2628">    cairo_fill(g-&gt;cr);</a>
<a name="ln2629">  }</a>
<a name="ln2630"> </a>
<a name="ln2631">  if(g-&gt;lut_valid)</a>
<a name="ln2632">  {</a>
<a name="ln2633">    // draw the interpolation curve</a>
<a name="ln2634">    set_color(g-&gt;cr, darktable.bauhaus-&gt;graph_fg);</a>
<a name="ln2635">    cairo_move_to(g-&gt;cr, 0, g-&gt;gui_lut[0] * g-&gt;graph_height);</a>
<a name="ln2636">    cairo_set_line_width(g-&gt;cr, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln2637"> </a>
<a name="ln2638">    for(int k = 1; k &lt; UI_SAMPLES; k++)</a>
<a name="ln2639">    {</a>
<a name="ln2640">      // the x range is [-8;+0] EV</a>
<a name="ln2641">      const float x_temp = (8.0f * (((float)k) / ((float)(UI_SAMPLES - 1)))) - 8.0f;</a>
<a name="ln2642">      const float y_temp = g-&gt;gui_lut[k];</a>
<a name="ln2643"> </a>
<a name="ln2644">      cairo_line_to(g-&gt;cr, (x_temp + 8.0f) * g-&gt;graph_width / 8.0f,</a>
<a name="ln2645">                            y_temp * g-&gt;graph_height );</a>
<a name="ln2646">    }</a>
<a name="ln2647">    cairo_stroke(g-&gt;cr);</a>
<a name="ln2648">  }</a>
<a name="ln2649"> </a>
<a name="ln2650">  init_nodes_x(g);</a>
<a name="ln2651">  init_nodes_y(g);</a>
<a name="ln2652"> </a>
<a name="ln2653">  if(g-&gt;user_param_valid)</a>
<a name="ln2654">  {</a>
<a name="ln2655">    // draw nodes positions</a>
<a name="ln2656">    for(int k = 0; k &lt; CHANNELS; k++)</a>
<a name="ln2657">    {</a>
<a name="ln2658">      const float xn = g-&gt;nodes_x[k];</a>
<a name="ln2659">      const float yn = g-&gt;nodes_y[k];</a>
<a name="ln2660"> </a>
<a name="ln2661">      // fill bars</a>
<a name="ln2662">      cairo_set_line_width(g-&gt;cr, DT_PIXEL_APPLY_DPI(6));</a>
<a name="ln2663">      set_color(g-&gt;cr, darktable.bauhaus-&gt;color_fill);</a>
<a name="ln2664">      cairo_move_to(g-&gt;cr, xn, 0.5 * g-&gt;graph_height);</a>
<a name="ln2665">      cairo_line_to(g-&gt;cr, xn, yn);</a>
<a name="ln2666">      cairo_stroke(g-&gt;cr);</a>
<a name="ln2667"> </a>
<a name="ln2668">      // bullets</a>
<a name="ln2669">      cairo_set_line_width(g-&gt;cr, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln2670">      cairo_arc(g-&gt;cr, xn, yn, DT_PIXEL_APPLY_DPI(4), 0, 2. * M_PI);</a>
<a name="ln2671">      set_color(g-&gt;cr, darktable.bauhaus-&gt;graph_fg);</a>
<a name="ln2672">      cairo_stroke_preserve(g-&gt;cr);</a>
<a name="ln2673"> </a>
<a name="ln2674">      if(g-&gt;area_active_node == k)</a>
<a name="ln2675">        set_color(g-&gt;cr, darktable.bauhaus-&gt;graph_fg);</a>
<a name="ln2676">      else</a>
<a name="ln2677">        set_color(g-&gt;cr, darktable.bauhaus-&gt;graph_bg);</a>
<a name="ln2678"> </a>
<a name="ln2679">      cairo_fill(g-&gt;cr);</a>
<a name="ln2680">    }</a>
<a name="ln2681">  }</a>
<a name="ln2682"> </a>
<a name="ln2683">  if(self-&gt;enabled)</a>
<a name="ln2684">  {</a>
<a name="ln2685">    if(g-&gt;area_cursor_valid)</a>
<a name="ln2686">    {</a>
<a name="ln2687">      const float radius = g-&gt;sigma * g-&gt;graph_width / 8.0f / sqrtf(2.0f);</a>
<a name="ln2688">      cairo_set_line_width(g-&gt;cr, DT_PIXEL_APPLY_DPI(1.5));</a>
<a name="ln2689">      const float y =g-&gt;gui_lut[(int)CLAMP(((UI_SAMPLES - 1) * g-&gt;area_x / g-&gt;graph_width), 0, UI_SAMPLES - 1)];</a>
<a name="ln2690">      cairo_arc(g-&gt;cr, g-&gt;area_x, y * g-&gt;graph_height, radius, 0, 2. * M_PI);</a>
<a name="ln2691">      set_color(g-&gt;cr, darktable.bauhaus-&gt;graph_fg);</a>
<a name="ln2692">      cairo_stroke(g-&gt;cr);</a>
<a name="ln2693">    }</a>
<a name="ln2694"> </a>
<a name="ln2695">    if(g-&gt;cursor_valid)</a>
<a name="ln2696">    {</a>
<a name="ln2697">      cairo_set_line_width(g-&gt;cr, DT_PIXEL_APPLY_DPI(1.5));</a>
<a name="ln2698">      set_color(g-&gt;cr, darktable.bauhaus-&gt;graph_fg);</a>
<a name="ln2699">      cairo_move_to(g-&gt;cr, (g-&gt;cursor_exposure + 8.0f) / 8.0f * g-&gt;graph_width, 0.0);</a>
<a name="ln2700">      cairo_line_to(g-&gt;cr,(g-&gt;cursor_exposure + 8.0f) / 8.0f * g-&gt;graph_width, g-&gt;graph_height);</a>
<a name="ln2701">      cairo_stroke(g-&gt;cr);</a>
<a name="ln2702">    }</a>
<a name="ln2703">  }</a>
<a name="ln2704"> </a>
<a name="ln2705">  // clean and exit</a>
<a name="ln2706">  cairo_set_source_surface(cr, g-&gt;cst, 0, 0);</a>
<a name="ln2707">  cairo_paint(cr);</a>
<a name="ln2708"> </a>
<a name="ln2709">  return TRUE;</a>
<a name="ln2710">}</a>
<a name="ln2711"> </a>
<a name="ln2712">static gboolean dt_iop_toneequalizer_bar_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln2713">{</a>
<a name="ln2714">  // Draw the widget equalizer view</a>
<a name="ln2715">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln2716">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2717"> </a>
<a name="ln2718">  update_histogram(g);</a>
<a name="ln2719"> </a>
<a name="ln2720">  GtkAllocation allocation;</a>
<a name="ln2721">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln2722">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, allocation.width, allocation.height);</a>
<a name="ln2723">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln2724"> </a>
<a name="ln2725">  // draw background</a>
<a name="ln2726">  set_color(cr, darktable.bauhaus-&gt;graph_bg);</a>
<a name="ln2727">  cairo_rectangle(cr, 0, 0, allocation.width, allocation.height);</a>
<a name="ln2728">  cairo_fill_preserve(cr);</a>
<a name="ln2729">  cairo_clip(cr);</a>
<a name="ln2730"> </a>
<a name="ln2731">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2732"> </a>
<a name="ln2733">  if(g-&gt;histogram_valid)</a>
<a name="ln2734">  {</a>
<a name="ln2735">    // draw histogram span</a>
<a name="ln2736">    const float left = (g-&gt;histogram_first_decile + 8.0f) / 8.0f;</a>
<a name="ln2737">    const float right = (g-&gt;histogram_last_decile + 8.0f) / 8.0f;</a>
<a name="ln2738">    const float width = (right - left);</a>
<a name="ln2739">    set_color(cr, darktable.bauhaus-&gt;inset_histogram);</a>
<a name="ln2740">    cairo_rectangle(cr, left * allocation.width, 0, width * allocation.width, allocation.height);</a>
<a name="ln2741">    cairo_fill(cr);</a>
<a name="ln2742"> </a>
<a name="ln2743">    // draw average bar</a>
<a name="ln2744">    set_color(cr, darktable.bauhaus-&gt;graph_fg);</a>
<a name="ln2745">    cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln2746">    const float average = (g-&gt;histogram_average + 8.0f) / 8.0f;</a>
<a name="ln2747">    cairo_move_to(cr, average * allocation.width, 0.0);</a>
<a name="ln2748">    cairo_line_to(cr, average * allocation.width, allocation.height);</a>
<a name="ln2749">    cairo_stroke(cr);</a>
<a name="ln2750"> </a>
<a name="ln2751">    // draw clipping bars</a>
<a name="ln2752">    cairo_set_source_rgb(cr, 0.75, 0.50, 0);</a>
<a name="ln2753">    cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(6));</a>
<a name="ln2754">    if(left &lt;= 0.0f)</a>
<a name="ln2755">    {</a>
<a name="ln2756">      cairo_move_to(cr, DT_PIXEL_APPLY_DPI(3), 0.0);</a>
<a name="ln2757">      cairo_line_to(cr, DT_PIXEL_APPLY_DPI(3), allocation.height);</a>
<a name="ln2758">      cairo_stroke(cr);</a>
<a name="ln2759">    }</a>
<a name="ln2760">    if(right &gt;= 1.0f)</a>
<a name="ln2761">    {</a>
<a name="ln2762">      cairo_move_to(cr, allocation.width - DT_PIXEL_APPLY_DPI(3), 0.0);</a>
<a name="ln2763">      cairo_line_to(cr, allocation.width - DT_PIXEL_APPLY_DPI(3), allocation.height);</a>
<a name="ln2764">      cairo_stroke(cr);</a>
<a name="ln2765">    }</a>
<a name="ln2766">  }</a>
<a name="ln2767"> </a>
<a name="ln2768">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2769"> </a>
<a name="ln2770">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln2771">  cairo_paint(crf);</a>
<a name="ln2772">  cairo_destroy(cr);</a>
<a name="ln2773">  cairo_surface_destroy(cst);</a>
<a name="ln2774">  return TRUE;</a>
<a name="ln2775">}</a>
<a name="ln2776"> </a>
<a name="ln2777"> </a>
<a name="ln2778">static gboolean area_enter_notify(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln2779">{</a>
<a name="ln2780">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln2781">  if(self-&gt;dt-&gt;gui-&gt;reset) return 1;</a>
<a name="ln2782">  if(!self-&gt;enabled) return 0;</a>
<a name="ln2783"> </a>
<a name="ln2784">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2785"> </a>
<a name="ln2786">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2787">  g-&gt;area_x = (event-&gt;x - g-&gt;inset);</a>
<a name="ln2788">  g-&gt;area_y = (event-&gt;y - g-&gt;inset);</a>
<a name="ln2789">  g-&gt;area_dragging = FALSE;</a>
<a name="ln2790">  g-&gt;area_active_node = -1;</a>
<a name="ln2791">  g-&gt;area_cursor_valid = (g-&gt;area_x &gt; 0.0f &amp;&amp; g-&gt;area_x &lt; g-&gt;graph_width &amp;&amp; g-&gt;area_y &gt; 0.0f &amp;&amp; g-&gt;area_y &lt; g-&gt;graph_height);</a>
<a name="ln2792">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2793"> </a>
<a name="ln2794">  gtk_widget_queue_draw(GTK_WIDGET(g-&gt;area));</a>
<a name="ln2795">  return TRUE;</a>
<a name="ln2796">}</a>
<a name="ln2797"> </a>
<a name="ln2798"> </a>
<a name="ln2799">static gboolean area_leave_notify(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln2800">{</a>
<a name="ln2801">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln2802">  if(self-&gt;dt-&gt;gui-&gt;reset) return 1;</a>
<a name="ln2803">  if(!self-&gt;enabled) return 0;</a>
<a name="ln2804"> </a>
<a name="ln2805">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2806"> </a>
<a name="ln2807">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2808">  g-&gt;area_x = (event-&gt;x - g-&gt;inset);</a>
<a name="ln2809">  g-&gt;area_y = (event-&gt;y - g-&gt;inset);</a>
<a name="ln2810">  g-&gt;area_dragging = FALSE;</a>
<a name="ln2811">  g-&gt;area_active_node = -1;</a>
<a name="ln2812">  g-&gt;area_cursor_valid = (g-&gt;area_x &gt; 0.0f &amp;&amp; g-&gt;area_x &lt; g-&gt;graph_width &amp;&amp; g-&gt;area_y &gt; 0.0f &amp;&amp; g-&gt;area_y &lt; g-&gt;graph_height);</a>
<a name="ln2813">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2814"> </a>
<a name="ln2815">  gtk_widget_queue_draw(GTK_WIDGET(g-&gt;area));</a>
<a name="ln2816">  return TRUE;</a>
<a name="ln2817">}</a>
<a name="ln2818"> </a>
<a name="ln2819"> </a>
<a name="ln2820">static gboolean area_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2821">{</a>
<a name="ln2822">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln2823">  if(self-&gt;dt-&gt;gui-&gt;reset) return 1;</a>
<a name="ln2824"> </a>
<a name="ln2825">  if(event-&gt;button == 1 &amp;&amp; event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln2826">  {</a>
<a name="ln2827">    dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln2828">    dt_iop_toneequalizer_params_t *d = (dt_iop_toneequalizer_params_t *)self-&gt;default_params;</a>
<a name="ln2829">    dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2830"> </a>
<a name="ln2831">    // reset nodes params</a>
<a name="ln2832">    p-&gt;noise = d-&gt;noise;</a>
<a name="ln2833">    p-&gt;ultra_deep_blacks = d-&gt;ultra_deep_blacks;</a>
<a name="ln2834">    p-&gt;deep_blacks = d-&gt;deep_blacks;</a>
<a name="ln2835">    p-&gt;blacks = d-&gt;blacks;</a>
<a name="ln2836">    p-&gt;shadows = d-&gt;shadows;</a>
<a name="ln2837">    p-&gt;midtones = d-&gt;midtones;</a>
<a name="ln2838">    p-&gt;highlights = d-&gt;highlights;</a>
<a name="ln2839">    p-&gt;whites = d-&gt;whites;</a>
<a name="ln2840">    p-&gt;speculars = d-&gt;speculars;</a>
<a name="ln2841"> </a>
<a name="ln2842">    // update UI sliders</a>
<a name="ln2843">    const int reset = self-&gt;dt-&gt;gui-&gt;reset;</a>
<a name="ln2844">    self-&gt;dt-&gt;gui-&gt;reset = 1;</a>
<a name="ln2845">    update_exposure_sliders(g, p);</a>
<a name="ln2846">    self-&gt;dt-&gt;gui-&gt;reset = reset;</a>
<a name="ln2847"> </a>
<a name="ln2848">    // Redraw graph</a>
<a name="ln2849">    gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln2850">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2851">    return TRUE;</a>
<a name="ln2852">  }</a>
<a name="ln2853">  else if(event-&gt;button == 1)</a>
<a name="ln2854">  {</a>
<a name="ln2855">    dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2856">    if(self-&gt;enabled)</a>
<a name="ln2857">    {</a>
<a name="ln2858">      g-&gt;area_dragging = 1;</a>
<a name="ln2859">      gtk_widget_queue_draw(GTK_WIDGET(g-&gt;area));</a>
<a name="ln2860">    }</a>
<a name="ln2861">    else</a>
<a name="ln2862">    {</a>
<a name="ln2863">      dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2864">    }</a>
<a name="ln2865">    return TRUE;</a>
<a name="ln2866">  }</a>
<a name="ln2867">  return FALSE;</a>
<a name="ln2868">}</a>
<a name="ln2869"> </a>
<a name="ln2870"> </a>
<a name="ln2871">static gboolean area_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln2872">{</a>
<a name="ln2873">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln2874">  if(self-&gt;dt-&gt;gui-&gt;reset) return 1;</a>
<a name="ln2875">  if(!self-&gt;enabled) return 0;</a>
<a name="ln2876"> </a>
<a name="ln2877">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2878">  dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln2879"> </a>
<a name="ln2880">  const float current_y = event-&gt;y - g-&gt;inset;</a>
<a name="ln2881">  const gboolean height_valid = (current_y &gt; 0.0f &amp;&amp; current_y &lt; g-&gt;graph_height);</a>
<a name="ln2882"> </a>
<a name="ln2883">  if(g-&gt;area_dragging &amp;&amp; height_valid)</a>
<a name="ln2884">  {</a>
<a name="ln2885">    // vertical distance travelled since button_pressed event</a>
<a name="ln2886">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2887">    const float previous_y = g-&gt;area_y;</a>
<a name="ln2888">    const float last_y = fminf(fmaxf((event-&gt;y - g-&gt;inset), 0.0f), g-&gt;graph_height);</a>
<a name="ln2889">    const float offset = (-last_y + previous_y) / g-&gt;graph_height * 4.0f; // graph spans over 4 EV</a>
<a name="ln2890">    const float cursor_exposure = g-&gt;area_x / g-&gt;graph_width * 8.0f - 8.0f;</a>
<a name="ln2891"> </a>
<a name="ln2892">    // Get the desired correction on exposure channels</a>
<a name="ln2893">    g-&gt;area_dragging = set_new_params_interactive(cursor_exposure, offset, g-&gt;sigma * g-&gt;sigma / 2.0f, g, p);</a>
<a name="ln2894">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2895">  }</a>
<a name="ln2896">  else if(g-&gt;area_dragging &amp;&amp; !height_valid)</a>
<a name="ln2897">  {</a>
<a name="ln2898">    // cursor left area : force commit to avoid glitches</a>
<a name="ln2899">    const int reset = self-&gt;dt-&gt;gui-&gt;reset;</a>
<a name="ln2900">    self-&gt;dt-&gt;gui-&gt;reset = 1;</a>
<a name="ln2901">    update_exposure_sliders(g, p);</a>
<a name="ln2902">    self-&gt;dt-&gt;gui-&gt;reset = reset;</a>
<a name="ln2903"> </a>
<a name="ln2904">    dt_dev_add_history_item(darktable.develop, self, FALSE);</a>
<a name="ln2905"> </a>
<a name="ln2906">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2907">    g-&gt;area_dragging= 0;</a>
<a name="ln2908">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2909">  }</a>
<a name="ln2910"> </a>
<a name="ln2911">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2912">  g-&gt;area_x = (event-&gt;x - g-&gt;inset);</a>
<a name="ln2913">  g-&gt;area_y = (event-&gt;y - g-&gt;inset);</a>
<a name="ln2914">  g-&gt;area_cursor_valid = (g-&gt;area_x &gt; 0.0f &amp;&amp; g-&gt;area_x &lt; g-&gt;graph_width &amp;&amp; g-&gt;area_y &gt; 0.0f &amp;&amp; g-&gt;area_y &lt; g-&gt;graph_height);</a>
<a name="ln2915">  g-&gt;area_active_node = -1;</a>
<a name="ln2916"> </a>
<a name="ln2917">  // Search if cursor is close to a node</a>
<a name="ln2918">  if(g-&gt;valid_nodes_x)</a>
<a name="ln2919">  {</a>
<a name="ln2920">    const float radius_threshold = fabsf(g-&gt;nodes_x[1] - g-&gt;nodes_x[0]) * 0.45f;</a>
<a name="ln2921">    for(int i = 0; i &lt; CHANNELS; ++i)</a>
<a name="ln2922">    {</a>
<a name="ln2923">      const float delta_x = fabsf(g-&gt;area_x - g-&gt;nodes_x[i]);</a>
<a name="ln2924">      if(delta_x &lt; radius_threshold)</a>
<a name="ln2925">      {</a>
<a name="ln2926">        g-&gt;area_active_node = i;</a>
<a name="ln2927">        g-&gt;area_cursor_valid = 1;</a>
<a name="ln2928">      }</a>
<a name="ln2929">    }</a>
<a name="ln2930">  }</a>
<a name="ln2931">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2932"> </a>
<a name="ln2933">  gtk_widget_queue_draw(GTK_WIDGET(g-&gt;area));</a>
<a name="ln2934">  return TRUE;</a>
<a name="ln2935">}</a>
<a name="ln2936"> </a>
<a name="ln2937"> </a>
<a name="ln2938">static gboolean area_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln2939">{</a>
<a name="ln2940">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln2941">  if(self-&gt;dt-&gt;gui-&gt;reset) return 1;</a>
<a name="ln2942">  if(!self-&gt;enabled) return 0;</a>
<a name="ln2943"> </a>
<a name="ln2944">  if(event-&gt;button == 1)</a>
<a name="ln2945">  {</a>
<a name="ln2946">    dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2947">    dt_iop_toneequalizer_params_t *p = (dt_iop_toneequalizer_params_t *)self-&gt;params;</a>
<a name="ln2948"> </a>
<a name="ln2949">    if(g-&gt;area_dragging)</a>
<a name="ln2950">    {</a>
<a name="ln2951">      // Update GUI with new params</a>
<a name="ln2952">      const int reset = self-&gt;dt-&gt;gui-&gt;reset;</a>
<a name="ln2953">      self-&gt;dt-&gt;gui-&gt;reset = 1;</a>
<a name="ln2954">      update_exposure_sliders(g, p);</a>
<a name="ln2955">      self-&gt;dt-&gt;gui-&gt;reset = reset;</a>
<a name="ln2956"> </a>
<a name="ln2957">      dt_dev_add_history_item(darktable.develop, self, FALSE);</a>
<a name="ln2958"> </a>
<a name="ln2959">      dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2960">      g-&gt;area_dragging= 0;</a>
<a name="ln2961">      dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2962"> </a>
<a name="ln2963">      return TRUE;</a>
<a name="ln2964">    }</a>
<a name="ln2965">  }</a>
<a name="ln2966">  return FALSE;</a>
<a name="ln2967">}</a>
<a name="ln2968"> </a>
<a name="ln2969"> </a>
<a name="ln2970">/**</a>
<a name="ln2971"> * Post pipe events</a>
<a name="ln2972"> **/</a>
<a name="ln2973"> </a>
<a name="ln2974"> </a>
<a name="ln2975">static void _develop_ui_pipe_started_callback(gpointer instance, gpointer user_data)</a>
<a name="ln2976">{</a>
<a name="ln2977">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln2978">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2979">  if(g == NULL) return;</a>
<a name="ln2980">  switch_cursors(self);</a>
<a name="ln2981"> </a>
<a name="ln2982">  if(!dtgtk_expander_get_expanded(DTGTK_EXPANDER(self-&gt;expander)))</a>
<a name="ln2983">  {</a>
<a name="ln2984">    // if module is not active, disable mask preview</a>
<a name="ln2985">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2986">    g-&gt;mask_display = 0;</a>
<a name="ln2987">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2988">  }</a>
<a name="ln2989"> </a>
<a name="ln2990">  const int reset = darktable.gui-&gt;reset;</a>
<a name="ln2991">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2992">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2993">  dt_bauhaus_widget_set_quad_active(GTK_WIDGET(g-&gt;show_luminance_mask), g-&gt;mask_display);</a>
<a name="ln2994">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2995">  darktable.gui-&gt;reset = reset;</a>
<a name="ln2996">}</a>
<a name="ln2997"> </a>
<a name="ln2998"> </a>
<a name="ln2999">static void _develop_preview_pipe_finished_callback(gpointer instance, gpointer user_data)</a>
<a name="ln3000">{</a>
<a name="ln3001">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln3002">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3003">  if(g == NULL) return;</a>
<a name="ln3004">  switch_cursors(self);</a>
<a name="ln3005">  gtk_widget_queue_draw(GTK_WIDGET(g-&gt;area));</a>
<a name="ln3006">  gtk_widget_queue_draw(GTK_WIDGET(g-&gt;bar));</a>
<a name="ln3007">}</a>
<a name="ln3008"> </a>
<a name="ln3009"> </a>
<a name="ln3010">static void _develop_ui_pipe_finished_callback(gpointer instance, gpointer user_data)</a>
<a name="ln3011">{</a>
<a name="ln3012">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln3013">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3014">  if(g == NULL) return;</a>
<a name="ln3015">  switch_cursors(self);</a>
<a name="ln3016">}</a>
<a name="ln3017"> </a>
<a name="ln3018"> </a>
<a name="ln3019">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln3020">{</a>
<a name="ln3021">  self-&gt;gui_data = malloc(sizeof(dt_iop_toneequalizer_gui_data_t));</a>
<a name="ln3022">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3023"> </a>
<a name="ln3024">  dt_pthread_mutex_init(&amp;g-&gt;lock, NULL);</a>
<a name="ln3025">  gui_cache_init(self);</a>
<a name="ln3026"> </a>
<a name="ln3027">  // Init GTK notebook</a>
<a name="ln3028">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln3029"> </a>
<a name="ln3030">  g-&gt;notebook = GTK_NOTEBOOK(gtk_notebook_new());</a>
<a name="ln3031">  GtkWidget *page1 = GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));</a>
<a name="ln3032">  GtkWidget *page2 = GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));</a>
<a name="ln3033">  GtkWidget *page3 = GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));</a>
<a name="ln3034"> </a>
<a name="ln3035">  gtk_notebook_append_page(GTK_NOTEBOOK(g-&gt;notebook), page1, gtk_label_new(_(&quot;simple&quot;)));</a>
<a name="ln3036">  gtk_notebook_append_page(GTK_NOTEBOOK(g-&gt;notebook), page2, gtk_label_new(_(&quot;advanced&quot;)));</a>
<a name="ln3037">  gtk_notebook_append_page(GTK_NOTEBOOK(g-&gt;notebook), page3, gtk_label_new(_(&quot;masking&quot;)));</a>
<a name="ln3038">  gtk_widget_show_all(GTK_WIDGET(gtk_notebook_get_nth_page(g-&gt;notebook, 0)));</a>
<a name="ln3039">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(g-&gt;notebook), FALSE, FALSE, 0);</a>
<a name="ln3040"> </a>
<a name="ln3041">  gtk_container_child_set(GTK_CONTAINER(g-&gt;notebook), page1, &quot;tab-expand&quot;, TRUE, &quot;tab-fill&quot;, TRUE, NULL);</a>
<a name="ln3042">  gtk_container_child_set(GTK_CONTAINER(g-&gt;notebook), page2, &quot;tab-expand&quot;, TRUE, &quot;tab-fill&quot;, TRUE, NULL);</a>
<a name="ln3043">  gtk_container_child_set(GTK_CONTAINER(g-&gt;notebook), page3, &quot;tab-expand&quot;, TRUE, &quot;tab-fill&quot;, TRUE, NULL);</a>
<a name="ln3044"> </a>
<a name="ln3045">  // Simple view</a>
<a name="ln3046">  const float top = 2.0;</a>
<a name="ln3047">  const float bottom = -2.0;</a>
<a name="ln3048"> </a>
<a name="ln3049">  g-&gt;noise = dt_bauhaus_slider_new_with_range(self, bottom, top, 0.1, 0.0, 2);</a>
<a name="ln3050">  dt_bauhaus_slider_set_format(g-&gt;noise, &quot;%+.2f EV&quot;);</a>
<a name="ln3051">  dt_bauhaus_widget_set_label(g-&gt;noise, NULL, _(&quot;-8 EV : blacks&quot;));</a>
<a name="ln3052">  gtk_box_pack_start(GTK_BOX(page1), g-&gt;noise, FALSE, FALSE, 0);</a>
<a name="ln3053">  g_signal_connect(G_OBJECT(g-&gt;noise), &quot;value-changed&quot;, G_CALLBACK(noise_callback), self);</a>
<a name="ln3054"> </a>
<a name="ln3055">  g-&gt;ultra_deep_blacks = dt_bauhaus_slider_new_with_range(self, bottom, top, 0.1, 0.0, 2);</a>
<a name="ln3056">  dt_bauhaus_slider_set_format(g-&gt;ultra_deep_blacks, &quot;%+.2f EV&quot;);</a>
<a name="ln3057">  dt_bauhaus_widget_set_label(g-&gt;ultra_deep_blacks, NULL, _(&quot;-7 EV : deep shadows&quot;));</a>
<a name="ln3058">  gtk_box_pack_start(GTK_BOX(page1), g-&gt;ultra_deep_blacks, FALSE, FALSE, 0);</a>
<a name="ln3059">  g_signal_connect(G_OBJECT(g-&gt;ultra_deep_blacks), &quot;value-changed&quot;, G_CALLBACK(ultra_deep_blacks_callback), self);</a>
<a name="ln3060"> </a>
<a name="ln3061">  g-&gt;deep_blacks = dt_bauhaus_slider_new_with_range(self, bottom, top, 0.1, 0.0, 2);</a>
<a name="ln3062">  dt_bauhaus_slider_set_format(g-&gt;deep_blacks, &quot;%+.2f EV&quot;);</a>
<a name="ln3063">  dt_bauhaus_widget_set_label(g-&gt;deep_blacks, NULL, _(&quot;-6 EV : shadows&quot;));</a>
<a name="ln3064">  gtk_box_pack_start(GTK_BOX(page1), g-&gt;deep_blacks, FALSE, FALSE, 0);</a>
<a name="ln3065">  g_signal_connect(G_OBJECT(g-&gt;deep_blacks), &quot;value-changed&quot;, G_CALLBACK(deep_blacks_callback), self);</a>
<a name="ln3066"> </a>
<a name="ln3067">  g-&gt;blacks = dt_bauhaus_slider_new_with_range(self, bottom, top, 0.1, 0.0, 2);</a>
<a name="ln3068">  dt_bauhaus_slider_set_format(g-&gt;blacks, &quot;%+.2f EV&quot;);</a>
<a name="ln3069">  dt_bauhaus_widget_set_label(g-&gt;blacks, NULL, _(&quot;-5 EV : light shadows&quot;));</a>
<a name="ln3070">  gtk_box_pack_start(GTK_BOX(page1), g-&gt;blacks, FALSE, FALSE, 0);</a>
<a name="ln3071">  g_signal_connect(G_OBJECT(g-&gt;blacks), &quot;value-changed&quot;, G_CALLBACK(blacks_callback), self);</a>
<a name="ln3072"> </a>
<a name="ln3073">  g-&gt;shadows = dt_bauhaus_slider_new_with_range(self, bottom, top, 0.1, 0.0, 2);</a>
<a name="ln3074">  dt_bauhaus_slider_set_format(g-&gt;shadows, &quot;%+.2f EV&quot;);</a>
<a name="ln3075">  dt_bauhaus_widget_set_label(g-&gt;shadows, NULL, _(&quot;-4 EV : midtones&quot;));</a>
<a name="ln3076">  gtk_box_pack_start(GTK_BOX(page1), g-&gt;shadows, FALSE, FALSE, 0);</a>
<a name="ln3077">  g_signal_connect(G_OBJECT(g-&gt;shadows), &quot;value-changed&quot;, G_CALLBACK(shadows_callback), self);</a>
<a name="ln3078"> </a>
<a name="ln3079">  g-&gt;midtones = dt_bauhaus_slider_new_with_range(self, bottom, top, 0.1, 0.0, 2);</a>
<a name="ln3080">  dt_bauhaus_slider_set_format(g-&gt;midtones, &quot;%+.2f EV&quot;);</a>
<a name="ln3081">  dt_bauhaus_widget_set_label(g-&gt;midtones, NULL, _(&quot;-3 EV : dark highlights&quot;));</a>
<a name="ln3082">  gtk_box_pack_start(GTK_BOX(page1), g-&gt;midtones, FALSE, FALSE, 0);</a>
<a name="ln3083">  g_signal_connect(G_OBJECT(g-&gt;midtones), &quot;value-changed&quot;, G_CALLBACK(midtones_callback), self);</a>
<a name="ln3084"> </a>
<a name="ln3085">  g-&gt;highlights = dt_bauhaus_slider_new_with_range(self, bottom, top, 0.1, 0.0, 2);</a>
<a name="ln3086">  dt_bauhaus_slider_set_format(g-&gt;highlights, &quot;%+.2f EV&quot;);</a>
<a name="ln3087">  dt_bauhaus_widget_set_label(g-&gt;highlights, NULL, _(&quot;-2 EV : highlights&quot;));</a>
<a name="ln3088">  gtk_box_pack_start(GTK_BOX(page1), g-&gt;highlights, FALSE, FALSE, 0);</a>
<a name="ln3089">  g_signal_connect(G_OBJECT(g-&gt;highlights), &quot;value-changed&quot;, G_CALLBACK(highlights_callback), self);</a>
<a name="ln3090"> </a>
<a name="ln3091">  g-&gt;whites = dt_bauhaus_slider_new_with_range(self, bottom, top, 0.1, 0.0, 2);</a>
<a name="ln3092">  dt_bauhaus_slider_set_format(g-&gt;whites, &quot;%+.2f EV&quot;);</a>
<a name="ln3093">  dt_bauhaus_widget_set_label(g-&gt;whites, NULL, _(&quot;-1 EV : whites&quot;));</a>
<a name="ln3094">  gtk_box_pack_start(GTK_BOX(page1), g-&gt;whites, FALSE, FALSE, 0);</a>
<a name="ln3095">  g_signal_connect(G_OBJECT(g-&gt;whites), &quot;value-changed&quot;, G_CALLBACK(whites_callback), self);</a>
<a name="ln3096"> </a>
<a name="ln3097">  g-&gt;speculars = dt_bauhaus_slider_new_with_range(self, bottom, top, 0.1, 0.0, 2);</a>
<a name="ln3098">  dt_bauhaus_slider_set_format(g-&gt;speculars, &quot;%+.2f EV&quot;);</a>
<a name="ln3099">  dt_bauhaus_widget_set_label(g-&gt;speculars, NULL, _(&quot;+0 EV : speculars&quot;));</a>
<a name="ln3100">  gtk_box_pack_start(GTK_BOX(page1), g-&gt;speculars, FALSE, FALSE, 0);</a>
<a name="ln3101">  g_signal_connect(G_OBJECT(g-&gt;speculars), &quot;value-changed&quot;, G_CALLBACK(speculars_callback), self);</a>
<a name="ln3102"> </a>
<a name="ln3103">  // Advanced view</a>
<a name="ln3104">  g-&gt;area = GTK_DRAWING_AREA(dtgtk_drawing_area_new_with_aspect_ratio(1.0));</a>
<a name="ln3105">  gtk_box_pack_start(GTK_BOX(page2), GTK_WIDGET(g-&gt;area), FALSE, FALSE, 0);</a>
<a name="ln3106">  gtk_widget_add_events(GTK_WIDGET(g-&gt;area), GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln3107">                                                 | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln3108">                                                 | GDK_LEAVE_NOTIFY_MASK | GDK_SCROLL_MASK</a>
<a name="ln3109">                                                 | darktable.gui-&gt;scroll_mask);</a>
<a name="ln3110">  gtk_widget_set_can_focus(GTK_WIDGET(g-&gt;area), TRUE);</a>
<a name="ln3111">  g_signal_connect(G_OBJECT(g-&gt;area), &quot;draw&quot;, G_CALLBACK(area_draw), self);</a>
<a name="ln3112">  g_signal_connect(G_OBJECT(g-&gt;area), &quot;button-press-event&quot;, G_CALLBACK(area_button_press), self);</a>
<a name="ln3113">  g_signal_connect(G_OBJECT(g-&gt;area), &quot;button-release-event&quot;, G_CALLBACK(area_button_release), self);</a>
<a name="ln3114">  g_signal_connect(G_OBJECT(g-&gt;area), &quot;leave-notify-event&quot;, G_CALLBACK(area_leave_notify), self);</a>
<a name="ln3115">  g_signal_connect(G_OBJECT(g-&gt;area), &quot;enter-notify-event&quot;, G_CALLBACK(area_enter_notify), self);</a>
<a name="ln3116">  g_signal_connect(G_OBJECT(g-&gt;area), &quot;motion-notify-event&quot;, G_CALLBACK(area_motion_notify), self);</a>
<a name="ln3117">  /*</a>
<a name="ln3118">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;scroll-event&quot;, G_CALLBACK(_scrolled), self);</a>
<a name="ln3119">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;key-press-event&quot;, G_CALLBACK(dt_iop_tonecurve_key_press), self);*/</a>
<a name="ln3120"> </a>
<a name="ln3121">  g-&gt;smoothing = dt_bauhaus_slider_new_with_range(self, -1.0f, +1.0f, 0.1, 0.0f, 2);</a>
<a name="ln3122">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;smoothing, -2.33f, 1.67f);</a>
<a name="ln3123">  dt_bauhaus_widget_set_label(g-&gt;smoothing, NULL, _(&quot;curve smoothing&quot;));</a>
<a name="ln3124">  g_object_set(G_OBJECT(g-&gt;smoothing), &quot;tooltip-text&quot;, _(&quot;positive values will produce more progressive tone transitions\n&quot;</a>
<a name="ln3125">                                                         &quot;but the curve might become oscillatory in some settings.\n&quot;</a>
<a name="ln3126">                                                         &quot;negative values will avoid oscillations and behave more robustly\n&quot;</a>
<a name="ln3127">                                                         &quot;but may produce brutal tone transitions and damage local contrast.&quot;), (char *)NULL);</a>
<a name="ln3128">  gtk_box_pack_start(GTK_BOX(page2), g-&gt;smoothing, FALSE, FALSE, 0);</a>
<a name="ln3129">  g_signal_connect(G_OBJECT(g-&gt;smoothing), &quot;value-changed&quot;, G_CALLBACK(smoothing_callback), self);</a>
<a name="ln3130"> </a>
<a name="ln3131">  // Masking options</a>
<a name="ln3132">  g-&gt;method = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln3133">  dt_bauhaus_widget_set_label(g-&gt;method, NULL, _(&quot;luminance estimator&quot;));</a>
<a name="ln3134">  gtk_box_pack_start(GTK_BOX(page3), g-&gt;method, FALSE, FALSE, 0);</a>
<a name="ln3135">  dt_bauhaus_combobox_add(g-&gt;method, &quot;RGB average&quot;);</a>
<a name="ln3136">  dt_bauhaus_combobox_add(g-&gt;method, &quot;HSL lightness&quot;);</a>
<a name="ln3137">  dt_bauhaus_combobox_add(g-&gt;method, &quot;HSV value / RGB max&quot;);</a>
<a name="ln3138">  dt_bauhaus_combobox_add(g-&gt;method, &quot;RGB sum&quot;);</a>
<a name="ln3139">  dt_bauhaus_combobox_add(g-&gt;method, &quot;RGB euclidean norm&quot;);</a>
<a name="ln3140">  dt_bauhaus_combobox_add(g-&gt;method, &quot;RGB power norm&quot;);</a>
<a name="ln3141">  dt_bauhaus_combobox_add(g-&gt;method, &quot;RGB geometric mean&quot;);</a>
<a name="ln3142">  g_signal_connect(G_OBJECT(g-&gt;method), &quot;value-changed&quot;, G_CALLBACK(method_changed), self);</a>
<a name="ln3143"> </a>
<a name="ln3144">  g-&gt;details = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln3145">  dt_bauhaus_widget_set_label(g-&gt;details, NULL, _(&quot;preserve details&quot;));</a>
<a name="ln3146">  gtk_box_pack_start(GTK_BOX(page3), g-&gt;details, FALSE, FALSE, 0);</a>
<a name="ln3147">  dt_bauhaus_combobox_add(g-&gt;details, &quot;no&quot;);</a>
<a name="ln3148">  dt_bauhaus_combobox_add(g-&gt;details, &quot;averaged guided filter&quot;);</a>
<a name="ln3149">  dt_bauhaus_combobox_add(g-&gt;details, &quot;guided filter&quot;);</a>
<a name="ln3150">  g_object_set(G_OBJECT(g-&gt;details), &quot;tooltip-text&quot;, _(&quot;'no' affects global and local contrast (safe if you only add contrast)\n&quot;</a>
<a name="ln3151">                                                       &quot;'guided filter' only affects global contrast and tries to preserve local contrast\n&quot;</a>
<a name="ln3152">                                                       &quot;'averaged guided filter' is a geometric mean of both methods&quot;), (char *)NULL);</a>
<a name="ln3153">  g_signal_connect(G_OBJECT(g-&gt;details), &quot;value-changed&quot;, G_CALLBACK(details_changed), self);</a>
<a name="ln3154"> </a>
<a name="ln3155">  g-&gt;iterations = dt_bauhaus_slider_new_with_range(self, 1, 5, 1, 1, 0);</a>
<a name="ln3156">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;iterations, 1, 20);</a>
<a name="ln3157">  dt_bauhaus_widget_set_label(g-&gt;iterations, NULL, _(&quot;filter diffusion&quot;));</a>
<a name="ln3158">  g_object_set(G_OBJECT(g-&gt;iterations), &quot;tooltip-text&quot;, _(&quot;number of passes of guided filter to apply\n&quot;</a>
<a name="ln3159">                                                          &quot;helps diffusing the edges of the filter at the expense of speed&quot;), (char *)NULL);</a>
<a name="ln3160">  gtk_box_pack_start(GTK_BOX(page3), g-&gt;iterations, FALSE, FALSE, 0);</a>
<a name="ln3161">  g_signal_connect(G_OBJECT(g-&gt;iterations), &quot;value-changed&quot;, G_CALLBACK(iterations_callback), self);</a>
<a name="ln3162"> </a>
<a name="ln3163">  g-&gt;blending = dt_bauhaus_slider_new_with_range(self, 5., 45.0, 1, 12.5, 2);</a>
<a name="ln3164">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;blending, 0.01, 100.0);</a>
<a name="ln3165">  dt_bauhaus_slider_set_format(g-&gt;blending, &quot;%.2f %%&quot;);</a>
<a name="ln3166">  dt_bauhaus_widget_set_label(g-&gt;blending, NULL, _(&quot;smoothing diameter&quot;));</a>
<a name="ln3167">  g_object_set(G_OBJECT(g-&gt;blending), &quot;tooltip-text&quot;, _(&quot;diameter of the blur in percent of the largest image size&quot;), (char *)NULL);</a>
<a name="ln3168">  gtk_box_pack_start(GTK_BOX(page3), g-&gt;blending, FALSE, FALSE, 0);</a>
<a name="ln3169">  g_signal_connect(G_OBJECT(g-&gt;blending), &quot;value-changed&quot;, G_CALLBACK(blending_callback), self);</a>
<a name="ln3170"> </a>
<a name="ln3171">  g-&gt;feathering = dt_bauhaus_slider_new_with_range(self, 1., 50., 0.2, 5., 2);</a>
<a name="ln3172">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;feathering, 0.01, 10000.0);</a>
<a name="ln3173">  dt_bauhaus_widget_set_label(g-&gt;feathering, NULL, _(&quot;edges refinement/feathering&quot;));</a>
<a name="ln3174">  g_object_set(G_OBJECT(g-&gt;feathering), &quot;tooltip-text&quot;, _(&quot;precision of the feathering :\n&quot;</a>
<a name="ln3175">                                                          &quot;higher values force the mask to follow edges more closely\n&quot;</a>
<a name="ln3176">                                                          &quot;but may void the effect of the smoothing\n&quot;</a>
<a name="ln3177">                                                          &quot;lower values give smoother gradients and better smoothing\n&quot;</a>
<a name="ln3178">                                                          &quot;but may lead to inaccurate edges taping&quot;), (char *)NULL);</a>
<a name="ln3179">  gtk_box_pack_start(GTK_BOX(page3), g-&gt;feathering, FALSE, FALSE, 0);</a>
<a name="ln3180">  g_signal_connect(G_OBJECT(g-&gt;feathering), &quot;value-changed&quot;, G_CALLBACK(feathering_callback), self);</a>
<a name="ln3181"> </a>
<a name="ln3182">  gtk_box_pack_start(GTK_BOX(page3), dt_ui_section_label_new(_(&quot;mask post-processing&quot;)), FALSE, FALSE, 0);</a>
<a name="ln3183"> </a>
<a name="ln3184">  g-&gt;bar = GTK_DRAWING_AREA(dtgtk_drawing_area_new_with_aspect_ratio(0.05));</a>
<a name="ln3185">  gtk_box_pack_start(GTK_BOX(page3), GTK_WIDGET(g-&gt;bar), FALSE, FALSE, 0);</a>
<a name="ln3186">  gtk_widget_set_can_focus(GTK_WIDGET(g-&gt;bar), TRUE);</a>
<a name="ln3187">  g_signal_connect(G_OBJECT(g-&gt;bar), &quot;draw&quot;, G_CALLBACK(dt_iop_toneequalizer_bar_draw), self);</a>
<a name="ln3188">  g_object_set(G_OBJECT(g-&gt;bar), &quot;tooltip-text&quot;, _(&quot;mask histogram span between the first and last deciles.\n&quot;</a>
<a name="ln3189">                                                   &quot;the central line shows the average. orange bars appear at extrema if clipping occurs.&quot;), (char *)NULL);</a>
<a name="ln3190"> </a>
<a name="ln3191"> </a>
<a name="ln3192">  g-&gt;quantization = dt_bauhaus_slider_new_with_range(self, 0.00, 2., 0.25, 0.0, 2);</a>
<a name="ln3193">  dt_bauhaus_widget_set_label(g-&gt;quantization, NULL, _(&quot;mask quantization&quot;));</a>
<a name="ln3194">  dt_bauhaus_slider_set_format(g-&gt;quantization, &quot;%+.2f EV&quot;);</a>
<a name="ln3195">  g_object_set(G_OBJECT(g-&gt;quantization), &quot;tooltip-text&quot;, _(&quot;0 disables the quantization.\n&quot;</a>
<a name="ln3196">                                                            &quot;higher values posterize the luminance mask to help the guiding\n&quot;</a>
<a name="ln3197">                                                            &quot;produce piece-wise smooth areas when using high feathering values&quot;), (char *)NULL);</a>
<a name="ln3198">  gtk_box_pack_start(GTK_BOX(page3), g-&gt;quantization, FALSE, FALSE, 0);</a>
<a name="ln3199">  g_signal_connect(G_OBJECT(g-&gt;quantization), &quot;value-changed&quot;, G_CALLBACK(quantization_callback), self);</a>
<a name="ln3200"> </a>
<a name="ln3201">  g-&gt;exposure_boost = dt_bauhaus_slider_new_with_range(self, -4., 4., 0.25, 0., 2);</a>
<a name="ln3202">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;exposure_boost, -16., 16.);</a>
<a name="ln3203">  dt_bauhaus_widget_set_label(g-&gt;exposure_boost, NULL, _(&quot;mask exposure compensation&quot;));</a>
<a name="ln3204">  dt_bauhaus_slider_set_format(g-&gt;exposure_boost, &quot;%+.2f EV&quot;);</a>
<a name="ln3205">  g_object_set(G_OBJECT(g-&gt;exposure_boost), &quot;tooltip-text&quot;, _(&quot;use this to slide the mask average exposure along channels\n&quot;</a>
<a name="ln3206">                                                              &quot;for better control of the exposure corrections.\n&quot;</a>
<a name="ln3207">                                                              &quot;the picker will auto-adjust the average exposure at -4EV.&quot;), (char *)NULL);</a>
<a name="ln3208">  gtk_box_pack_start(GTK_BOX(page3), g-&gt;exposure_boost, FALSE, FALSE, 0);</a>
<a name="ln3209">  g_signal_connect(G_OBJECT(g-&gt;exposure_boost), &quot;value-changed&quot;, G_CALLBACK(exposure_boost_callback), self);</a>
<a name="ln3210"> </a>
<a name="ln3211">  dt_bauhaus_widget_set_quad_paint(g-&gt;exposure_boost, dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln3212">  dt_bauhaus_widget_set_quad_toggle(g-&gt;exposure_boost, TRUE);</a>
<a name="ln3213">  g_signal_connect(G_OBJECT(g-&gt;exposure_boost), &quot;quad-pressed&quot;, G_CALLBACK(auto_adjust_exposure_boost), self);</a>
<a name="ln3214"> </a>
<a name="ln3215">  g-&gt;contrast_boost = dt_bauhaus_slider_new_with_range(self, -4., 4., 0.25, 0., 2);</a>
<a name="ln3216">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;contrast_boost, -16., 16.);</a>
<a name="ln3217">  dt_bauhaus_widget_set_label(g-&gt;contrast_boost, NULL, _(&quot;mask contrast compensation&quot;));</a>
<a name="ln3218">  dt_bauhaus_slider_set_format(g-&gt;contrast_boost, &quot;%+.2f EV&quot;);</a>
<a name="ln3219">  g_object_set(G_OBJECT(g-&gt;contrast_boost), &quot;tooltip-text&quot;, _(&quot;use this to dilate the mask contrast around its average exposure\n&quot;</a>
<a name="ln3220">                                                              &quot;this allows to spread the exposure histogram over more channels\n&quot;</a>
<a name="ln3221">                                                              &quot;for better control of the exposure corrections.&quot;), (char *)NULL);</a>
<a name="ln3222">  gtk_box_pack_start(GTK_BOX(page3), g-&gt;contrast_boost, FALSE, FALSE, 0);</a>
<a name="ln3223">  g_signal_connect(G_OBJECT(g-&gt;contrast_boost), &quot;value-changed&quot;, G_CALLBACK(contrast_boost_callback), self);</a>
<a name="ln3224"> </a>
<a name="ln3225">  dt_bauhaus_widget_set_quad_paint(g-&gt;contrast_boost, dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln3226">  dt_bauhaus_widget_set_quad_toggle(g-&gt;contrast_boost, TRUE);</a>
<a name="ln3227">  g_signal_connect(G_OBJECT(g-&gt;contrast_boost), &quot;quad-pressed&quot;, G_CALLBACK(auto_adjust_contrast_boost), self);</a>
<a name="ln3228"> </a>
<a name="ln3229"> </a>
<a name="ln3230">  g-&gt;show_luminance_mask = dt_bauhaus_combobox_new(self);</a>
<a name="ln3231">  dt_bauhaus_widget_set_label(g-&gt;show_luminance_mask, NULL, _(&quot;display exposure mask&quot;));</a>
<a name="ln3232">  dt_bauhaus_widget_set_quad_paint(g-&gt;show_luminance_mask, dtgtk_cairo_paint_showmask,</a>
<a name="ln3233">                                   CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln3234">  dt_bauhaus_widget_set_quad_toggle(g-&gt;show_luminance_mask, TRUE);</a>
<a name="ln3235">  g_object_set(G_OBJECT(g-&gt;show_luminance_mask), &quot;tooltip-text&quot;, _(&quot;display exposure mask&quot;), (char *)NULL);</a>
<a name="ln3236">  g_signal_connect(G_OBJECT(g-&gt;show_luminance_mask), &quot;quad-pressed&quot;, G_CALLBACK(show_luminance_mask_callback), self);</a>
<a name="ln3237">  gtk_box_pack_start(GTK_BOX(self-&gt;widget),  g-&gt;show_luminance_mask, TRUE, TRUE, 0);</a>
<a name="ln3238"> </a>
<a name="ln3239">  // Force UI redraws when pipe starts/finishes computing and switch cursors</a>
<a name="ln3240">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_PREVIEW_PIPE_FINISHED,</a>
<a name="ln3241">                            G_CALLBACK(_develop_preview_pipe_finished_callback), self);</a>
<a name="ln3242">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_UI_PIPE_FINISHED,</a>
<a name="ln3243">                            G_CALLBACK(_develop_ui_pipe_finished_callback), self);</a>
<a name="ln3244"> </a>
<a name="ln3245">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE,</a>
<a name="ln3246">                            G_CALLBACK(_develop_ui_pipe_started_callback), self);</a>
<a name="ln3247"> </a>
<a name="ln3248">  show_guiding_controls(self);</a>
<a name="ln3249">}</a>
<a name="ln3250"> </a>
<a name="ln3251"> </a>
<a name="ln3252">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln3253">{</a>
<a name="ln3254">  dt_iop_toneequalizer_gui_data_t *g = (dt_iop_toneequalizer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3255">  self-&gt;request_color_pick = DT_REQUEST_COLORPICK_OFF;</a>
<a name="ln3256"> </a>
<a name="ln3257">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_develop_ui_pipe_finished_callback), self);</a>
<a name="ln3258">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_develop_ui_pipe_started_callback), self);</a>
<a name="ln3259">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_develop_preview_pipe_finished_callback), self);</a>
<a name="ln3260"> </a>
<a name="ln3261">  if(g-&gt;desc) pango_font_description_free(g-&gt;desc);</a>
<a name="ln3262">  if(g-&gt;layout) g_object_unref(g-&gt;layout);</a>
<a name="ln3263">  if(g-&gt;cr) cairo_destroy(g-&gt;cr);</a>
<a name="ln3264">  if(g-&gt;cst) cairo_surface_destroy(g-&gt;cst);</a>
<a name="ln3265"> </a>
<a name="ln3266">  dt_pthread_mutex_destroy(&amp;g-&gt;lock);</a>
<a name="ln3267">  free(self-&gt;gui_data);</a>
<a name="ln3268">  self-&gt;gui_data = NULL;</a>
<a name="ln3269">}</a>
<a name="ln3270"> </a>
<a name="ln3271">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln3272">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln3273">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1138"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: out[i] != out[i].</p></div>
<div class="balloon" rel="1384"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: g->user_param_valid.</p></div>
<div class="balloon" rel="1394"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: g->factors_valid.</p></div>
<div class="balloon" rel="1517"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1517, 1493.</p></div>
<div class="balloon" rel="1518"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1518, 1494.</p></div>
<div class="balloon" rel="2009"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !self->dev->pipe->processing.</p></div>
<div class="balloon" rel="2072"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: g->luminance_valid.</p></div>
<div class="balloon" rel="3024"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 3024, 3021.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
