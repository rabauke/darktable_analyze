
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011-2012 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/collection.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/debug.h&quot;</a>
<a name="ln22">#include &quot;common/image_cache.h&quot;</a>
<a name="ln23">#include &quot;common/metadata.h&quot;</a>
<a name="ln24">#include &quot;common/tags.h&quot;</a>
<a name="ln25">#include &quot;control/conf.h&quot;</a>
<a name="ln26">#include &quot;control/control.h&quot;</a>
<a name="ln27">#include &quot;develop/develop.h&quot;</a>
<a name="ln28">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln29">#include &quot;gui/gtk.h&quot;</a>
<a name="ln30">#include &quot;libs/lib.h&quot;</a>
<a name="ln31">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln34">#include &lt;sys/param.h&gt;</a>
<a name="ln35">#ifdef USE_LUA</a>
<a name="ln36">#include &quot;lua/call.h&quot;</a>
<a name="ln37">#include &quot;lua/image.h&quot;</a>
<a name="ln38">#endif</a>
<a name="ln39"> </a>
<a name="ln40">#define SHOW_FLAGS 1</a>
<a name="ln41"> </a>
<a name="ln42">DT_MODULE(1)</a>
<a name="ln43"> </a>
<a name="ln44">enum</a>
<a name="ln45">{</a>
<a name="ln46">  /* internal */</a>
<a name="ln47">  md_internal_filmroll = 0,</a>
<a name="ln48">  md_internal_imgid,</a>
<a name="ln49">  md_internal_groupid,</a>
<a name="ln50">  md_internal_filename,</a>
<a name="ln51">  md_internal_version,</a>
<a name="ln52">  md_internal_fullpath,</a>
<a name="ln53">  md_internal_local_copy,</a>
<a name="ln54">#if SHOW_FLAGS</a>
<a name="ln55">  md_internal_flags,</a>
<a name="ln56">#endif</a>
<a name="ln57"> </a>
<a name="ln58">  /* exif */</a>
<a name="ln59">  md_exif_model,</a>
<a name="ln60">  md_exif_maker,</a>
<a name="ln61">  md_exif_lens,</a>
<a name="ln62">  md_exif_aperture,</a>
<a name="ln63">  md_exif_exposure,</a>
<a name="ln64">  md_exif_focal_length,</a>
<a name="ln65">  md_exif_focus_distance,</a>
<a name="ln66">  md_exif_iso,</a>
<a name="ln67">  md_exif_datetime,</a>
<a name="ln68">  md_exif_width,</a>
<a name="ln69">  md_exif_height,</a>
<a name="ln70"> </a>
<a name="ln71">  /* size of final image */</a>
<a name="ln72">  md_width,</a>
<a name="ln73">  md_height,</a>
<a name="ln74"> </a>
<a name="ln75">  /* xmp */</a>
<a name="ln76">  md_xmp_title,</a>
<a name="ln77">  md_xmp_creator,</a>
<a name="ln78">  md_xmp_rights,</a>
<a name="ln79"> </a>
<a name="ln80">  /* geotagging */</a>
<a name="ln81">  md_geotagging_lat,</a>
<a name="ln82">  md_geotagging_lon,</a>
<a name="ln83">  md_geotagging_ele,</a>
<a name="ln84"> </a>
<a name="ln85">  /* tags */</a>
<a name="ln86">  md_tag_names,</a>
<a name="ln87"> </a>
<a name="ln88">  /* entries, do not touch! */</a>
<a name="ln89">  md_size</a>
<a name="ln90">};</a>
<a name="ln91"> </a>
<a name="ln92">static gchar *_md_labels[md_size];</a>
<a name="ln93"> </a>
<a name="ln94">/* initialize the labels text */</a>
<a name="ln95">static void _lib_metatdata_view_init_labels()</a>
<a name="ln96">{</a>
<a name="ln97">  /* internal */</a>
<a name="ln98">  _md_labels[md_internal_filmroll] = _(&quot;filmroll&quot;);</a>
<a name="ln99">  _md_labels[md_internal_imgid] = _(&quot;image id&quot;);</a>
<a name="ln100">  _md_labels[md_internal_groupid] = _(&quot;group id&quot;);</a>
<a name="ln101">  _md_labels[md_internal_filename] = _(&quot;filename&quot;);</a>
<a name="ln102">  _md_labels[md_internal_version] = _(&quot;version&quot;);</a>
<a name="ln103">  _md_labels[md_internal_fullpath] = _(&quot;full path&quot;);</a>
<a name="ln104">  _md_labels[md_internal_local_copy] = _(&quot;local copy&quot;);</a>
<a name="ln105">#if SHOW_FLAGS</a>
<a name="ln106">  _md_labels[md_internal_flags] = _(&quot;flags&quot;);</a>
<a name="ln107">#endif</a>
<a name="ln108"> </a>
<a name="ln109">  /* exif */</a>
<a name="ln110">  _md_labels[md_exif_model] = _(&quot;model&quot;);</a>
<a name="ln111">  _md_labels[md_exif_maker] = _(&quot;maker&quot;);</a>
<a name="ln112">  _md_labels[md_exif_lens] = _(&quot;lens&quot;);</a>
<a name="ln113">  _md_labels[md_exif_aperture] = _(&quot;aperture&quot;);</a>
<a name="ln114">  _md_labels[md_exif_exposure] = _(&quot;exposure&quot;);</a>
<a name="ln115">  _md_labels[md_exif_focal_length] = _(&quot;focal length&quot;);</a>
<a name="ln116">  _md_labels[md_exif_focus_distance] = _(&quot;focus distance&quot;);</a>
<a name="ln117">  _md_labels[md_exif_iso] = _(&quot;ISO&quot;);</a>
<a name="ln118">  _md_labels[md_exif_datetime] = _(&quot;datetime&quot;);</a>
<a name="ln119">  _md_labels[md_exif_width] = _(&quot;width&quot;);</a>
<a name="ln120">  _md_labels[md_exif_height] = _(&quot;height&quot;);</a>
<a name="ln121"> </a>
<a name="ln122">  _md_labels[md_width] = _(&quot;export width&quot;);</a>
<a name="ln123">  _md_labels[md_height] = _(&quot;export height&quot;);</a>
<a name="ln124"> </a>
<a name="ln125">  /* xmp */</a>
<a name="ln126">  _md_labels[md_xmp_title] = _(&quot;title&quot;);</a>
<a name="ln127">  _md_labels[md_xmp_creator] = _(&quot;creator&quot;);</a>
<a name="ln128">  _md_labels[md_xmp_rights] = _(&quot;copyright&quot;);</a>
<a name="ln129"> </a>
<a name="ln130">  /* geotagging */</a>
<a name="ln131">  _md_labels[md_geotagging_lat] = _(&quot;latitude&quot;);</a>
<a name="ln132">  _md_labels[md_geotagging_lon] = _(&quot;longitude&quot;);</a>
<a name="ln133">  _md_labels[md_geotagging_ele] = _(&quot;elevation&quot;);</a>
<a name="ln134"> </a>
<a name="ln135">  /* tags */</a>
<a name="ln136">  _md_labels[md_tag_names] = _(&quot;tags&quot;);</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">typedef struct dt_lib_metadata_view_t</a>
<a name="ln141">{</a>
<a name="ln142">  GtkLabel *metadata[md_size];</a>
<a name="ln143">} dt_lib_metadata_view_t;</a>
<a name="ln144"> </a>
<a name="ln145">const char *name(dt_lib_module_t *self)</a>
<a name="ln146">{</a>
<a name="ln147">  return _(&quot;image information&quot;);</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">const char **views(dt_lib_module_t *self)</a>
<a name="ln151">{</a>
<a name="ln152">  static const char *v[] = {&quot;*&quot;, NULL};</a>
<a name="ln153">  return v;</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln157">{</a>
<a name="ln158">  return DT_UI_CONTAINER_PANEL_LEFT_CENTER;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">int position()</a>
<a name="ln162">{</a>
<a name="ln163">  return 299;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">/* helper which eliminates non-printable characters from a string</a>
<a name="ln167"> </a>
<a name="ln168">Strings which are already in valid UTF-8 are retained.</a>
<a name="ln169">*/</a>
<a name="ln170">static void _filter_non_printable(char *string, size_t length)</a>
<a name="ln171">{</a>
<a name="ln172">  /* explicitly tell the validator to ignore the trailing nulls, otherwise this fails */</a>
<a name="ln173">  if(g_utf8_validate(string, -1, 0)) return;</a>
<a name="ln174"> </a>
<a name="ln175">  unsigned char *str = (unsigned char *)string;</a>
<a name="ln176">  int n = 0;</a>
<a name="ln177"> </a>
<a name="ln178">  while(*str != '\000' &amp;&amp; n &lt; length)</a>
<a name="ln179">  {</a>
<a name="ln180">    if((*str &lt; 0x20) || (*str &gt;= 0x7f)) *str = '.';</a>
<a name="ln181"> </a>
<a name="ln182">    str++;</a>
<a name="ln183">    n++;</a>
<a name="ln184">  }</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">#define NODATA_STRING &quot;-&quot;</a>
<a name="ln188"> </a>
<a name="ln189">/* helper function for updating a metadata value */</a>
<a name="ln190">static void _metadata_update_value(GtkLabel *label, const char *value)</a>
<a name="ln191">{</a>
<a name="ln192">  gboolean validated = g_utf8_validate(value, -1, NULL);</a>
<a name="ln193">  const gchar *str = validated ? value : NODATA_STRING;</a>
<a name="ln194">  gtk_label_set_text(GTK_LABEL(label), str);</a>
<a name="ln195">  gtk_label_set_ellipsize(GTK_LABEL(label), PANGO_ELLIPSIZE_MIDDLE);</a>
<a name="ln196">  gtk_widget_set_tooltip_text(GTK_WIDGET(label), str);</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">static void _metadata_update_value_end(GtkLabel *label, const char *value)</a>
<a name="ln200">{</a>
<a name="ln201">  gboolean validated = g_utf8_validate(value, -1, NULL);</a>
<a name="ln202">  const gchar *str = validated ? value : NODATA_STRING;</a>
<a name="ln203">  gtk_label_set_text(GTK_LABEL(label), str);</a>
<a name="ln204">  gtk_label_set_ellipsize(GTK_LABEL(label), PANGO_ELLIPSIZE_END);</a>
<a name="ln205">  gtk_widget_set_tooltip_text(GTK_WIDGET(label), str);</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208"> </a>
<a name="ln209">#ifdef USE_LUA</a>
<a name="ln210">static int lua_update_metadata(lua_State*L);</a>
<a name="ln211">#endif</a>
<a name="ln212">/* update all values to reflect mouse over image id or no data at all */</a>
<a name="ln213">static void _metadata_view_update_values(dt_lib_module_t *self)</a>
<a name="ln214">{</a>
<a name="ln215">  dt_lib_metadata_view_t *d = (dt_lib_metadata_view_t *)self-&gt;data;</a>
<a name="ln216">  int32_t mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln217"> </a>
<a name="ln218">  if(mouse_over_id == -1)</a>
<a name="ln219">  {</a>
<a name="ln220">    const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln221">    if(cv-&gt;view((dt_view_t *)cv) == DT_VIEW_DARKROOM)</a>
<a name="ln222">    {</a>
<a name="ln223">      mouse_over_id = darktable.develop-&gt;image_storage.id;</a>
<a name="ln224">    }</a>
<a name="ln225">    else</a>
<a name="ln226">    {</a>
<a name="ln227">      sqlite3_stmt *stmt;</a>
<a name="ln228">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images LIMIT 1&quot;,</a>
<a name="ln229">                                  -1, &amp;stmt, NULL);</a>
<a name="ln230">      if(sqlite3_step(stmt) == SQLITE_ROW) mouse_over_id = sqlite3_column_int(stmt, 0);</a>
<a name="ln231">      sqlite3_finalize(stmt);</a>
<a name="ln232">    }</a>
<a name="ln233">  }</a>
<a name="ln234"> </a>
<a name="ln235">  if(mouse_over_id &gt;= 0)</a>
<a name="ln236">  {</a>
<a name="ln237">    char value[512];</a>
<a name="ln238">    char pathname[PATH_MAX] = { 0 };</a>
<a name="ln239"> </a>
<a name="ln240">    // get the size before locking the image!</a>
<a name="ln241">    // TODO: put that into dt_image_t and make sure it stays in sync</a>
<a name="ln242">    int width = 0, height = 0;</a>
<a name="ln243">//     dt_image_get_final_size(mouse_over_id, &amp;width, &amp;height); // kind of slow on some machines</a>
<a name="ln244"> </a>
<a name="ln245">    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, mouse_over_id, 'r');</a>
<a name="ln246">    if(!img) goto fill_minuses;</a>
<a name="ln247">    if(img-&gt;film_id == -1)</a>
<a name="ln248">    {</a>
<a name="ln249">      dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln250">      goto fill_minuses;</a>
<a name="ln251">    }</a>
<a name="ln252"> </a>
<a name="ln253">    /* update all metadata */</a>
<a name="ln254"> </a>
<a name="ln255">    dt_image_film_roll(img, value, sizeof(value));</a>
<a name="ln256">    _metadata_update_value(d-&gt;metadata[md_internal_filmroll], value);</a>
<a name="ln257"> </a>
<a name="ln258">    char tooltip[512];</a>
<a name="ln259">    snprintf(tooltip, sizeof(tooltip), _(&quot;double click to jump to film roll\n%s&quot;), value);</a>
<a name="ln260">    gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;metadata[md_internal_filmroll]), tooltip);</a>
<a name="ln261"> </a>
<a name="ln262">    snprintf(value, sizeof(value), &quot;%d&quot;, img-&gt;id);</a>
<a name="ln263">    _metadata_update_value(d-&gt;metadata[md_internal_imgid], value);</a>
<a name="ln264"> </a>
<a name="ln265">    snprintf(value, sizeof(value), &quot;%d&quot;, img-&gt;group_id);</a>
<a name="ln266">    _metadata_update_value(d-&gt;metadata[md_internal_groupid], value);</a>
<a name="ln267"> </a>
<a name="ln268">    _metadata_update_value(d-&gt;metadata[md_internal_filename], img-&gt;filename);</a>
<a name="ln269"> </a>
<a name="ln270">    snprintf(value, sizeof(value), &quot;%d&quot;, img-&gt;version);</a>
<a name="ln271">    _metadata_update_value(d-&gt;metadata[md_internal_version], value);</a>
<a name="ln272"> </a>
<a name="ln273">    gboolean from_cache = FALSE;</a>
<a name="ln274">    dt_image_full_path(img-&gt;id, pathname, sizeof(pathname), &amp;from_cache);</a>
<a name="ln275">    _metadata_update_value(d-&gt;metadata[md_internal_fullpath], pathname);</a>
<a name="ln276"> </a>
<a name="ln277">    snprintf(value, sizeof(value), &quot;%s&quot;, (img-&gt;flags &amp; DT_IMAGE_LOCAL_COPY) ? _(&quot;yes&quot;) : _(&quot;no&quot;));</a>
<a name="ln278">    _metadata_update_value(d-&gt;metadata[md_internal_local_copy], value);</a>
<a name="ln279"> </a>
<a name="ln280">    // TODO: decide if this should be removed for a release. maybe #ifdef'ing to only add it to git compiles?</a>
<a name="ln281"> </a>
<a name="ln282">    // the bits of the flags</a>
<a name="ln283">#if SHOW_FLAGS</a>
<a name="ln284">    {</a>
<a name="ln285">      #define EMPTY_FIELD '.'</a>
<a name="ln286">      #define FALSE_FIELD '.'</a>
<a name="ln287">      #define TRUE_FIELD '!'</a>
<a name="ln288"> </a>
<a name="ln289">      char *flags_tooltip = NULL;</a>
<a name="ln290">      char *flag_descriptions[] = { N_(&quot;unused&quot;),</a>
<a name="ln291">                                    N_(&quot;unused/deprecated&quot;),</a>
<a name="ln292">                                    N_(&quot;ldr&quot;),</a>
<a name="ln293">                                    N_(&quot;raw&quot;),</a>
<a name="ln294">                                    N_(&quot;hdr&quot;),</a>
<a name="ln295">                                    N_(&quot;marked for deletion&quot;),</a>
<a name="ln296">                                    N_(&quot;auto-applying presets applied&quot;),</a>
<a name="ln297">                                    N_(&quot;legacy flag. set for all new images&quot;),</a>
<a name="ln298">                                    N_(&quot;local copy&quot;),</a>
<a name="ln299">                                    N_(&quot;has .txt&quot;),</a>
<a name="ln300">                                    N_(&quot;has .wav&quot;)</a>
<a name="ln301">      };</a>
<a name="ln302">      char *tooltip_parts[14] = { 0 };</a>
<a name="ln303">      int next_tooltip_part = 0;</a>
<a name="ln304"> </a>
<a name="ln305">      memset(value, EMPTY_FIELD, sizeof(value));</a>
<a name="ln306"> </a>
<a name="ln307">      int stars = img-&gt;flags &amp; 0x7;</a>
<a name="ln308">      char *star_string = NULL;</a>
<a name="ln309">      if(stars == 6)</a>
<a name="ln310">      {</a>
<a name="ln311">        value[0] = 'x';</a>
<a name="ln312">        tooltip_parts[next_tooltip_part++] = _(&quot;image rejected&quot;);</a>
<a name="ln313">      }</a>
<a name="ln314">      else</a>
<a name="ln315">      {</a>
<a name="ln316">        value[0] = '0' + stars;</a>
<a name="ln317">        tooltip_parts[next_tooltip_part++] = star_string = g_strdup_printf(ngettext(&quot;image has %d star&quot;, &quot;image has %d stars&quot;, stars), stars);</a>
<a name="ln318">      }</a>
<a name="ln319"> </a>
<a name="ln320"> </a>
<a name="ln321">      if(img-&gt;flags &amp; 8)</a>
<a name="ln322">      {</a>
<a name="ln323">        value[1] = TRUE_FIELD;</a>
<a name="ln324">        tooltip_parts[next_tooltip_part++] = _(flag_descriptions[0]);</a>
<a name="ln325">      }</a>
<a name="ln326">      else</a>
<a name="ln327">        value[1] = FALSE_FIELD;</a>
<a name="ln328"> </a>
<a name="ln329">      if(img-&gt;flags &amp; DT_IMAGE_THUMBNAIL_DEPRECATED)</a>
<a name="ln330">      {</a>
<a name="ln331">        value[2] = TRUE_FIELD;</a>
<a name="ln332">        tooltip_parts[next_tooltip_part++] = _(flag_descriptions[1]);</a>
<a name="ln333">      }</a>
<a name="ln334">      else</a>
<a name="ln335">        value[2] = FALSE_FIELD;</a>
<a name="ln336"> </a>
<a name="ln337">      if(img-&gt;flags &amp; DT_IMAGE_LDR)</a>
<a name="ln338">      {</a>
<a name="ln339">        value[3] = 'l';</a>
<a name="ln340">        tooltip_parts[next_tooltip_part++] = _(flag_descriptions[2]);</a>
<a name="ln341">      }</a>
<a name="ln342"> </a>
<a name="ln343">      if(img-&gt;flags &amp; DT_IMAGE_RAW)</a>
<a name="ln344">      {</a>
<a name="ln345">        value[4] = 'r';</a>
<a name="ln346">        tooltip_parts[next_tooltip_part++] = _(flag_descriptions[3]);</a>
<a name="ln347">      }</a>
<a name="ln348"> </a>
<a name="ln349">      if(img-&gt;flags &amp; DT_IMAGE_HDR)</a>
<a name="ln350">      {</a>
<a name="ln351">        value[5] = 'h';</a>
<a name="ln352">        tooltip_parts[next_tooltip_part++] = _(flag_descriptions[4]);</a>
<a name="ln353">      }</a>
<a name="ln354"> </a>
<a name="ln355">      if(img-&gt;flags &amp; DT_IMAGE_REMOVE)</a>
<a name="ln356">      {</a>
<a name="ln357">        value[6] = 'd';</a>
<a name="ln358">        tooltip_parts[next_tooltip_part++] = _(flag_descriptions[5]);</a>
<a name="ln359">      }</a>
<a name="ln360"> </a>
<a name="ln361">      if(img-&gt;flags &amp; DT_IMAGE_AUTO_PRESETS_APPLIED)</a>
<a name="ln362">      {</a>
<a name="ln363">        value[7] = 'a';</a>
<a name="ln364">        tooltip_parts[next_tooltip_part++] = _(flag_descriptions[6]);</a>
<a name="ln365">      }</a>
<a name="ln366"> </a>
<a name="ln367">      if(img-&gt;flags &amp; DT_IMAGE_NO_LEGACY_PRESETS)</a>
<a name="ln368">      {</a>
<a name="ln369">        value[8] = 'p';</a>
<a name="ln370">        tooltip_parts[next_tooltip_part++] = _(flag_descriptions[7]);</a>
<a name="ln371">      }</a>
<a name="ln372"> </a>
<a name="ln373">      if(img-&gt;flags &amp; DT_IMAGE_LOCAL_COPY)</a>
<a name="ln374">      {</a>
<a name="ln375">        value[9] = 'c';</a>
<a name="ln376">        tooltip_parts[next_tooltip_part++] = _(flag_descriptions[8]);</a>
<a name="ln377">      }</a>
<a name="ln378"> </a>
<a name="ln379">      if(img-&gt;flags &amp; DT_IMAGE_HAS_TXT)</a>
<a name="ln380">      {</a>
<a name="ln381">        value[10] = 't';</a>
<a name="ln382">        tooltip_parts[next_tooltip_part++] = _(flag_descriptions[9]);</a>
<a name="ln383">      }</a>
<a name="ln384"> </a>
<a name="ln385">      if(img-&gt;flags &amp; DT_IMAGE_HAS_WAV)</a>
<a name="ln386">      {</a>
<a name="ln387">        value[11] = 'w';</a>
<a name="ln388">        tooltip_parts[next_tooltip_part++] = _(flag_descriptions[10]);</a>
<a name="ln389">      }</a>
<a name="ln390"> </a>
<a name="ln391">      static const struct</a>
<a name="ln392">      {</a>
<a name="ln393">        char *tooltip;</a>
<a name="ln394">        char flag;</a>
<a name="ln395">      } loaders[] =</a>
<a name="ln396">      {</a>
<a name="ln397">        { N_(&quot;unknown&quot;), EMPTY_FIELD},</a>
<a name="ln398">        { N_(&quot;tiff&quot;), 't'},</a>
<a name="ln399">        { N_(&quot;png&quot;), 'p'},</a>
<a name="ln400">        { N_(&quot;j2k&quot;), 'J'},</a>
<a name="ln401">        { N_(&quot;jpeg&quot;), 'j'},</a>
<a name="ln402">        { N_(&quot;exr&quot;), 'e'},</a>
<a name="ln403">        { N_(&quot;rgbe&quot;), 'R'},</a>
<a name="ln404">        { N_(&quot;pfm&quot;), 'P'},</a>
<a name="ln405">        { N_(&quot;GraphicsMagick&quot;), 'g'},</a>
<a name="ln406">        { N_(&quot;rawspeed&quot;), 'r'},</a>
<a name="ln407">        { N_(&quot;netpnm&quot;), 'n'},</a>
<a name="ln408">      };</a>
<a name="ln409"> </a>
<a name="ln410">      int loader = (unsigned int)img-&gt;loader &lt; sizeof(loaders) / sizeof(*loaders) ? img-&gt;loader : 0;</a>
<a name="ln411">      value[12] = loaders[loader].flag;</a>
<a name="ln412">      char *loader_tooltip = g_strdup_printf(_(&quot;loader: %s&quot;), _(loaders[loader].tooltip));</a>
<a name="ln413">      tooltip_parts[next_tooltip_part++] = loader_tooltip;</a>
<a name="ln414"> </a>
<a name="ln415">      value[13] = '\0';</a>
<a name="ln416"> </a>
<a name="ln417">      flags_tooltip = g_strjoinv(&quot;\n&quot;, tooltip_parts);</a>
<a name="ln418">      g_free(loader_tooltip);</a>
<a name="ln419"> </a>
<a name="ln420">      _metadata_update_value(d-&gt;metadata[md_internal_flags], value);</a>
<a name="ln421">      gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;metadata[md_internal_flags]), flags_tooltip);</a>
<a name="ln422"> </a>
<a name="ln423">      g_free(star_string);</a>
<a name="ln424">      g_free(flags_tooltip);</a>
<a name="ln425"> </a>
<a name="ln426">      #undef EMPTY_FIELD</a>
<a name="ln427">      #undef FALSE_FIELD</a>
<a name="ln428">      #undef TRUE_FIELD</a>
<a name="ln429">    }</a>
<a name="ln430">#endif // SHOW_FLAGS</a>
<a name="ln431"> </a>
<a name="ln432">    /* EXIF */</a>
<a name="ln433">    _metadata_update_value_end(d-&gt;metadata[md_exif_model], img-&gt;camera_alias);</a>
<a name="ln434">    _metadata_update_value_end(d-&gt;metadata[md_exif_lens], img-&gt;exif_lens);</a>
<a name="ln435">    _metadata_update_value_end(d-&gt;metadata[md_exif_maker], img-&gt;camera_maker);</a>
<a name="ln436"> </a>
<a name="ln437">    snprintf(value, sizeof(value), &quot;F/%.1f&quot;, img-&gt;exif_aperture);</a>
<a name="ln438">    _metadata_update_value(d-&gt;metadata[md_exif_aperture], value);</a>
<a name="ln439"> </a>
<a name="ln440">    if(img-&gt;exif_exposure &lt;= 0.5)</a>
<a name="ln441">      snprintf(value, sizeof(value), &quot;1/%.0f&quot;, 1.0 / img-&gt;exif_exposure);</a>
<a name="ln442">    else</a>
<a name="ln443">      snprintf(value, sizeof(value), &quot;%.1f''&quot;, img-&gt;exif_exposure);</a>
<a name="ln444">    _metadata_update_value(d-&gt;metadata[md_exif_exposure], value);</a>
<a name="ln445"> </a>
<a name="ln446">    snprintf(value, sizeof(value), &quot;%.0f mm&quot;, img-&gt;exif_focal_length);</a>
<a name="ln447">    _metadata_update_value(d-&gt;metadata[md_exif_focal_length], value);</a>
<a name="ln448"> </a>
<a name="ln449">    if(isnan(img-&gt;exif_focus_distance) || fpclassify(img-&gt;exif_focus_distance) == FP_ZERO)</a>
<a name="ln450">    {</a>
<a name="ln451">      _metadata_update_value(d-&gt;metadata[md_exif_focus_distance], NODATA_STRING);</a>
<a name="ln452">    }</a>
<a name="ln453">    else</a>
<a name="ln454">    {</a>
<a name="ln455">      snprintf(value, sizeof(value), &quot;%.2f m&quot;, img-&gt;exif_focus_distance);</a>
<a name="ln456">      _metadata_update_value(d-&gt;metadata[md_exif_focus_distance], value);</a>
<a name="ln457">    }</a>
<a name="ln458"> </a>
<a name="ln459">    snprintf(value, sizeof(value), &quot;%.0f&quot;, img-&gt;exif_iso);</a>
<a name="ln460">    _metadata_update_value(d-&gt;metadata[md_exif_iso], value);</a>
<a name="ln461"> </a>
<a name="ln462">    struct tm tt_exif = { 0 };</a>
<a name="ln463">    if(sscanf(img-&gt;exif_datetime_taken, &quot;%d:%d:%d %d:%d:%d&quot;, &amp;tt_exif.tm_year, &amp;tt_exif.tm_mon,</a>
<a name="ln464">      &amp;tt_exif.tm_mday, &amp;tt_exif.tm_hour, &amp;tt_exif.tm_min, &amp;tt_exif.tm_sec) == 6)</a>
<a name="ln465">    {</a>
<a name="ln466">      char datetime[200];</a>
<a name="ln467">      tt_exif.tm_year -= 1900;</a>
<a name="ln468">      tt_exif.tm_mon--;</a>
<a name="ln469">      tt_exif.tm_isdst = -1;</a>
<a name="ln470">      mktime(&amp;tt_exif);</a>
<a name="ln471">      // just %c is too long and includes a time zone that we don't know from exif</a>
<a name="ln472">      strftime(datetime, sizeof(datetime), &quot;%a %x %X&quot;, &amp;tt_exif);</a>
<a name="ln473">      _metadata_update_value(d-&gt;metadata[md_exif_datetime], datetime);</a>
<a name="ln474">    }</a>
<a name="ln475">    else</a>
<a name="ln476">      _metadata_update_value(d-&gt;metadata[md_exif_datetime], img-&gt;exif_datetime_taken);</a>
<a name="ln477"> </a>
<a name="ln478">    snprintf(value, sizeof(value), &quot;%d&quot;, img-&gt;height);</a>
<a name="ln479">    _metadata_update_value(d-&gt;metadata[md_exif_height], value);</a>
<a name="ln480">    snprintf(value, sizeof(value), &quot;%d&quot;, img-&gt;width);</a>
<a name="ln481">    _metadata_update_value(d-&gt;metadata[md_exif_width], value);</a>
<a name="ln482"> </a>
<a name="ln483">    snprintf(value, sizeof(value), &quot;%d&quot;, height);</a>
<a name="ln484">    _metadata_update_value(d-&gt;metadata[md_height], value);</a>
<a name="ln485">    snprintf(value, sizeof(value), &quot;%d&quot;, width);</a>
<a name="ln486">    _metadata_update_value(d-&gt;metadata[md_width], value);</a>
<a name="ln487"> </a>
<a name="ln488">    /* XMP */</a>
<a name="ln489">    GList *res;</a>
<a name="ln490">    if((res = dt_metadata_get(img-&gt;id, &quot;Xmp.dc.title&quot;, NULL)) != NULL)</a>
<a name="ln491">    {</a>
<a name="ln492">      snprintf(value, sizeof(value), &quot;%s&quot;, (char *)res-&gt;data);</a>
<a name="ln493">      _filter_non_printable(value, sizeof(value));</a>
<a name="ln494">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln495">    }</a>
<a name="ln496">    else</a>
<a name="ln497">      g_strlcpy(value, NODATA_STRING, sizeof(value));</a>
<a name="ln498">    _metadata_update_value(d-&gt;metadata[md_xmp_title], value);</a>
<a name="ln499"> </a>
<a name="ln500">    if((res = dt_metadata_get(img-&gt;id, &quot;Xmp.dc.creator&quot;, NULL)) != NULL)</a>
<a name="ln501">    {</a>
<a name="ln502">      snprintf(value, sizeof(value), &quot;%s&quot;, (char *)res-&gt;data);</a>
<a name="ln503">      _filter_non_printable(value, sizeof(value));</a>
<a name="ln504">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln505">    }</a>
<a name="ln506">    else</a>
<a name="ln507">      g_strlcpy(value, NODATA_STRING, sizeof(value));</a>
<a name="ln508">    _metadata_update_value(d-&gt;metadata[md_xmp_creator], value);</a>
<a name="ln509"> </a>
<a name="ln510">    if((res = dt_metadata_get(img-&gt;id, &quot;Xmp.dc.rights&quot;, NULL)) != NULL)</a>
<a name="ln511">    {</a>
<a name="ln512">      snprintf(value, sizeof(value), &quot;%s&quot;, (char *)res-&gt;data);</a>
<a name="ln513">      _filter_non_printable(value, sizeof(value));</a>
<a name="ln514">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln515">    }</a>
<a name="ln516">    else</a>
<a name="ln517">      g_strlcpy(value, NODATA_STRING, sizeof(value));</a>
<a name="ln518">    _metadata_update_value(d-&gt;metadata[md_xmp_rights], value);</a>
<a name="ln519"> </a>
<a name="ln520">    /* geotagging */</a>
<a name="ln521">    /* latitude */</a>
<a name="ln522">    if(isnan(img-&gt;geoloc.latitude))</a>
<a name="ln523">    {</a>
<a name="ln524">      _metadata_update_value(d-&gt;metadata[md_geotagging_lat], NODATA_STRING);</a>
<a name="ln525">    }</a>
<a name="ln526">    else</a>
<a name="ln527">    {</a>
<a name="ln528">      if(dt_conf_get_bool(&quot;plugins/lighttable/metadata_view/pretty_location&quot;))</a>
<a name="ln529">      {</a>
<a name="ln530">        gchar *latitude = dt_util_latitude_str(img-&gt;geoloc.latitude);</a>
<a name="ln531">        _metadata_update_value(d-&gt;metadata[md_geotagging_lat], latitude);</a>
<a name="ln532">        g_free(latitude);</a>
<a name="ln533">      }</a>
<a name="ln534">      else</a>
<a name="ln535">      {</a>
<a name="ln536">        const gchar NS = img-&gt;geoloc.latitude &lt; 0 ? 'S' : 'N';</a>
<a name="ln537">        snprintf(value, sizeof(value), &quot;%c %09.6f&quot;, NS, fabs(img-&gt;geoloc.latitude));</a>
<a name="ln538">        _metadata_update_value(d-&gt;metadata[md_geotagging_lat], value);</a>
<a name="ln539">      }</a>
<a name="ln540">    }</a>
<a name="ln541">    /* longitude */</a>
<a name="ln542">    if(isnan(img-&gt;geoloc.longitude))</a>
<a name="ln543">    {</a>
<a name="ln544">      _metadata_update_value(d-&gt;metadata[md_geotagging_lon], NODATA_STRING);</a>
<a name="ln545">    }</a>
<a name="ln546">    else</a>
<a name="ln547">    {</a>
<a name="ln548">      if(dt_conf_get_bool(&quot;plugins/lighttable/metadata_view/pretty_location&quot;))</a>
<a name="ln549">      {</a>
<a name="ln550">        gchar *longitude = dt_util_longitude_str(img-&gt;geoloc.longitude);</a>
<a name="ln551">        _metadata_update_value(d-&gt;metadata[md_geotagging_lon], longitude);</a>
<a name="ln552">        g_free(longitude);</a>
<a name="ln553">      }</a>
<a name="ln554">      else</a>
<a name="ln555">      {</a>
<a name="ln556">        const gchar EW = img-&gt;geoloc.longitude &lt; 0 ? 'W' : 'E';</a>
<a name="ln557">        snprintf(value, sizeof(value), &quot;%c %010.6f&quot;, EW, fabs(img-&gt;geoloc.longitude));</a>
<a name="ln558">        _metadata_update_value(d-&gt;metadata[md_geotagging_lon], value);</a>
<a name="ln559">      }</a>
<a name="ln560">    }</a>
<a name="ln561">    /* elevation */</a>
<a name="ln562">    if(isnan(img-&gt;geoloc.elevation))</a>
<a name="ln563">    {</a>
<a name="ln564">      _metadata_update_value(d-&gt;metadata[md_geotagging_ele], NODATA_STRING);</a>
<a name="ln565">    }</a>
<a name="ln566">    else</a>
<a name="ln567">    {</a>
<a name="ln568">      if(dt_conf_get_bool(&quot;plugins/lighttable/metadata_view/pretty_location&quot;))</a>
<a name="ln569">      {</a>
<a name="ln570">        gchar *elevation = dt_util_elevation_str(img-&gt;geoloc.elevation);</a>
<a name="ln571">        _metadata_update_value(d-&gt;metadata[md_geotagging_ele], elevation);</a>
<a name="ln572">        g_free(elevation);</a>
<a name="ln573">      }</a>
<a name="ln574">      else</a>
<a name="ln575">      {</a>
<a name="ln576">        snprintf(value, sizeof(value), &quot;%.2f %s&quot;, img-&gt;geoloc.elevation, _(&quot;m&quot;));</a>
<a name="ln577">        _metadata_update_value(d-&gt;metadata[md_geotagging_ele], value);</a>
<a name="ln578">      }</a>
<a name="ln579">    }</a>
<a name="ln580"> </a>
<a name="ln581">    /* tags */</a>
<a name="ln582">    GList *tags = NULL;</a>
<a name="ln583">    if(dt_tag_get_attached(mouse_over_id, &amp;tags, TRUE))</a>
<a name="ln584">    {</a>
<a name="ln585">      char *tagstring = NULL;</a>
<a name="ln586">      gint length = 0;</a>
<a name="ln587">      for(GList *taglist = tags; taglist; taglist = g_list_next(taglist))</a>
<a name="ln588">      {</a>
<a name="ln589">        const char *tagname = ((dt_tag_t *)taglist-&gt;data)-&gt;leave;</a>
<a name="ln590">        length = length + strlen(tagname) + 2;</a>
<a name="ln591">        if(length &lt; 45)</a>
<a name="ln592">          tagstring = dt_util_dstrcat(tagstring, &quot;%s, &quot;, tagname);</a>
<a name="ln593">        else</a>
<a name="ln594">        {</a>
<a name="ln595">          tagstring = dt_util_dstrcat(tagstring, &quot;\n%s, &quot;, tagname);</a>
<a name="ln596">          length = strlen(tagname) + 2;</a>
<a name="ln597">        }</a>
<a name="ln598">      }</a>
<a name="ln599">      if(tagstring) tagstring[strlen(tagstring)-2] = '\0';</a>
<a name="ln600">      _metadata_update_value(d-&gt;metadata[md_tag_names], tagstring);</a>
<a name="ln601">    }</a>
<a name="ln602">    else _metadata_update_value(d-&gt;metadata[md_tag_names], NODATA_STRING);</a>
<a name="ln603"> </a>
<a name="ln604">    dt_tag_free_result(&amp;tags);</a>
<a name="ln605"> </a>
<a name="ln606">    /* release img */</a>
<a name="ln607">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln608"> </a>
<a name="ln609">#ifdef USE_LUA</a>
<a name="ln610">    dt_lua_async_call_alien(lua_update_metadata,</a>
<a name="ln611">        0,NULL,NULL,</a>
<a name="ln612">        LUA_ASYNC_TYPENAME,&quot;void*&quot;,self,</a>
<a name="ln613">        LUA_ASYNC_TYPENAME,&quot;int32_t&quot;,mouse_over_id,LUA_ASYNC_DONE);</a>
<a name="ln614">#endif</a>
<a name="ln615">  }</a>
<a name="ln616"> </a>
<a name="ln617">  return;</a>
<a name="ln618"> </a>
<a name="ln619">/* reset */</a>
<a name="ln620">fill_minuses:</a>
<a name="ln621">  for(int k = 0; k &lt; md_size; k++) _metadata_update_value(d-&gt;metadata[k], NODATA_STRING);</a>
<a name="ln622">#ifdef USE_LUA</a>
<a name="ln623">  dt_lua_async_call_alien(lua_update_metadata,</a>
<a name="ln624">      0,NULL,NULL,</a>
<a name="ln625">        LUA_ASYNC_TYPENAME,&quot;void*&quot;,self,</a>
<a name="ln626">        LUA_ASYNC_TYPENAME,&quot;int32_t&quot;,-1,LUA_ASYNC_DONE);</a>
<a name="ln627">#endif</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">static void _jump_to()</a>
<a name="ln631">{</a>
<a name="ln632">  int32_t imgid = dt_control_get_mouse_over_id();</a>
<a name="ln633">  if(imgid == -1)</a>
<a name="ln634">  {</a>
<a name="ln635">    sqlite3_stmt *stmt;</a>
<a name="ln636"> </a>
<a name="ln637">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;, -1, &amp;stmt,</a>
<a name="ln638">                                NULL);</a>
<a name="ln639"> </a>
<a name="ln640">    if(sqlite3_step(stmt) == SQLITE_ROW) imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln641">    sqlite3_finalize(stmt);</a>
<a name="ln642">  }</a>
<a name="ln643">  if(imgid != -1)</a>
<a name="ln644">  {</a>
<a name="ln645">    char path[512];</a>
<a name="ln646">    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln647">    dt_image_film_roll_directory(img, path, sizeof(path));</a>
<a name="ln648">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln649">    char collect[1024];</a>
<a name="ln650">    snprintf(collect, sizeof(collect), &quot;1:0:0:%s$&quot;, path);</a>
<a name="ln651">    dt_collection_deserialize(collect);</a>
<a name="ln652">  }</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">static gboolean _filmroll_clicked(GtkWidget *widget, GdkEventButton *event, gpointer null)</a>
<a name="ln656">{</a>
<a name="ln657">  if(event-&gt;type != GDK_2BUTTON_PRESS) return FALSE;</a>
<a name="ln658">  _jump_to();</a>
<a name="ln659">  return TRUE;</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">static gboolean _jump_to_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln663">                               GdkModifierType modifier, gpointer data)</a>
<a name="ln664">{</a>
<a name="ln665">  _jump_to();</a>
<a name="ln666">  return TRUE;</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">/* callback for the mouse over image change signal */</a>
<a name="ln670">static void _mouse_over_image_callback(gpointer instance, gpointer user_data)</a>
<a name="ln671">{</a>
<a name="ln672">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln673">  if(dt_control_running()) _metadata_view_update_values(self);</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln677">{</a>
<a name="ln678">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;jump to film roll&quot;), GDK_KEY_j, GDK_CONTROL_MASK);</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln682">{</a>
<a name="ln683">  GClosure *closure = g_cclosure_new(G_CALLBACK(_jump_to_accel), (gpointer)self, NULL);</a>
<a name="ln684">  dt_accel_connect_lib(self, &quot;jump to film roll&quot;, closure);</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687">void gui_init(dt_lib_module_t *self)</a>
<a name="ln688">{</a>
<a name="ln689">  /* initialize ui widgets */</a>
<a name="ln690">  dt_lib_metadata_view_t *d = (dt_lib_metadata_view_t *)g_malloc0(sizeof(dt_lib_metadata_view_t));</a>
<a name="ln691">  self-&gt;data = (void *)d;</a>
<a name="ln692">  _lib_metatdata_view_init_labels();</a>
<a name="ln693"> </a>
<a name="ln694">  self-&gt;widget = gtk_grid_new();</a>
<a name="ln695">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln696">  gtk_grid_set_column_spacing(GTK_GRID(self-&gt;widget), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln697">//   GtkWidget *last = NULL;</a>
<a name="ln698"> </a>
<a name="ln699">  /* initialize the metadata name/value labels */</a>
<a name="ln700">  for(int k = 0; k &lt; md_size; k++)</a>
<a name="ln701">  {</a>
<a name="ln702">    GtkWidget *evb = gtk_event_box_new();</a>
<a name="ln703">    gtk_widget_set_name(evb, &quot;brightbg&quot;);</a>
<a name="ln704">    GtkLabel *name = GTK_LABEL(gtk_label_new(_md_labels[k]));</a>
<a name="ln705">    d-&gt;metadata[k] = GTK_LABEL(gtk_label_new(&quot;-&quot;));</a>
<a name="ln706">    gtk_label_set_selectable(d-&gt;metadata[k], TRUE);</a>
<a name="ln707">    gtk_container_add(GTK_CONTAINER(evb), GTK_WIDGET(d-&gt;metadata[k]));</a>
<a name="ln708">    if(k == md_internal_filmroll)</a>
<a name="ln709">    {</a>
<a name="ln710">      // film roll jump to:</a>
<a name="ln711">      g_signal_connect(G_OBJECT(evb), &quot;button-press-event&quot;, G_CALLBACK(_filmroll_clicked), NULL);</a>
<a name="ln712">    }</a>
<a name="ln713">    gtk_widget_set_halign(GTK_WIDGET(name), GTK_ALIGN_START);</a>
<a name="ln714">    gtk_widget_set_halign(GTK_WIDGET(d-&gt;metadata[k]), GTK_ALIGN_START);</a>
<a name="ln715">    gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(name), 0, k, 1, 1);</a>
<a name="ln716">    gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(evb), GTK_WIDGET(name), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln717">  }</a>
<a name="ln718"> </a>
<a name="ln719">  /* lets signup for mouse over image change signals */</a>
<a name="ln720">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_MOUSE_OVER_IMAGE_CHANGE,</a>
<a name="ln721">                            G_CALLBACK(_mouse_over_image_callback), self);</a>
<a name="ln722"> </a>
<a name="ln723">  /* lets signup for develop image changed signals */</a>
<a name="ln724">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_IMAGE_CHANGED,</a>
<a name="ln725">                            G_CALLBACK(_mouse_over_image_callback), self);</a>
<a name="ln726"> </a>
<a name="ln727">  /* signup for develop initialize to update info of current</a>
<a name="ln728">     image in darkroom when enter */</a>
<a name="ln729">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_INITIALIZE,</a>
<a name="ln730">                            G_CALLBACK(_mouse_over_image_callback), self);</a>
<a name="ln731">}</a>
<a name="ln732"> </a>
<a name="ln733">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln734">{</a>
<a name="ln735">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_mouse_over_image_callback), self);</a>
<a name="ln736">  g_free(self-&gt;data);</a>
<a name="ln737">  self-&gt;data = NULL;</a>
<a name="ln738">}</a>
<a name="ln739">#ifdef USE_LUA</a>
<a name="ln740">static int lua_update_widgets(lua_State*L)</a>
<a name="ln741">{</a>
<a name="ln742">  dt_lib_module_t *self = lua_touserdata(L, 1);</a>
<a name="ln743">  dt_lua_module_entry_push(L,&quot;lib&quot;,self-&gt;plugin_name);</a>
<a name="ln744">  lua_getuservalue(L,2);</a>
<a name="ln745">  lua_getfield(L,3,&quot;values&quot;);</a>
<a name="ln746">  lua_getfield(L,3,&quot;widgets&quot;);</a>
<a name="ln747">  lua_pushnil(L);</a>
<a name="ln748">  while(lua_next(L, 4) != 0)</a>
<a name="ln749">  {</a>
<a name="ln750">    lua_getfield(L,5,lua_tostring(L,-2));</a>
<a name="ln751">    GtkLabel *widget = lua_touserdata(L,-1);</a>
<a name="ln752">    _metadata_update_value_end(widget,luaL_checkstring(L,7));</a>
<a name="ln753">    lua_pop(L,2);</a>
<a name="ln754">  }</a>
<a name="ln755">  return 0;</a>
<a name="ln756">}</a>
<a name="ln757">static int lua_update_metadata(lua_State*L)</a>
<a name="ln758">{</a>
<a name="ln759">  dt_lib_module_t *self = lua_touserdata(L, 1);</a>
<a name="ln760">  int32_t imgid = lua_tointeger(L,2);</a>
<a name="ln761">  dt_lua_module_entry_push(L,&quot;lib&quot;,self-&gt;plugin_name);</a>
<a name="ln762">  lua_getuservalue(L,-1);</a>
<a name="ln763">  lua_getfield(L,4,&quot;callbacks&quot;);</a>
<a name="ln764">  lua_getfield(L,4,&quot;values&quot;);</a>
<a name="ln765">  lua_pushnil(L);</a>
<a name="ln766">  while(lua_next(L, 5) != 0)</a>
<a name="ln767">  {</a>
<a name="ln768">    lua_pushvalue(L,-1);</a>
<a name="ln769">    luaA_push(L,dt_lua_image_t,&amp;imgid);</a>
<a name="ln770">    lua_call(L,1,1);</a>
<a name="ln771">    lua_pushvalue(L,7);</a>
<a name="ln772">    lua_pushvalue(L,9);</a>
<a name="ln773">    lua_settable(L,6);</a>
<a name="ln774">    lua_pop(L, 2);</a>
<a name="ln775">  }</a>
<a name="ln776">  lua_pushcfunction(L,lua_update_widgets);</a>
<a name="ln777">  dt_lua_gtk_wrap(L);</a>
<a name="ln778">  lua_pushlightuserdata(L,self);</a>
<a name="ln779">  lua_call(L,1,0);</a>
<a name="ln780">  return 0;</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783">static int lua_register_info(lua_State *L)</a>
<a name="ln784">{</a>
<a name="ln785">  dt_lib_module_t *self = lua_touserdata(L, lua_upvalueindex(1));</a>
<a name="ln786">  dt_lua_module_entry_push(L,&quot;lib&quot;,self-&gt;plugin_name);</a>
<a name="ln787">  lua_getuservalue(L,-1);</a>
<a name="ln788">  const char* key = luaL_checkstring(L,1);</a>
<a name="ln789">  luaL_checktype(L,2,LUA_TFUNCTION);</a>
<a name="ln790">  {</a>
<a name="ln791">    lua_getfield(L,-1,&quot;callbacks&quot;);</a>
<a name="ln792">    lua_pushstring(L,key);</a>
<a name="ln793">    lua_pushvalue(L,2);</a>
<a name="ln794">    lua_settable(L,5);</a>
<a name="ln795">    lua_pop(L,1);</a>
<a name="ln796">  }</a>
<a name="ln797">  {</a>
<a name="ln798">    lua_getfield(L,-1,&quot;values&quot;);</a>
<a name="ln799">    lua_pushstring(L,key);</a>
<a name="ln800">    lua_pushstring(L,&quot;-&quot;);</a>
<a name="ln801">    lua_settable(L,5);</a>
<a name="ln802">    lua_pop(L,1);</a>
<a name="ln803">  }</a>
<a name="ln804">  {</a>
<a name="ln805">    GtkWidget *evb = gtk_event_box_new();</a>
<a name="ln806">    gtk_widget_set_name(evb, &quot;brightbg&quot;);</a>
<a name="ln807">    GtkLabel *name = GTK_LABEL(gtk_label_new(key));</a>
<a name="ln808">    GtkLabel *value = GTK_LABEL(gtk_label_new(&quot;-&quot;));</a>
<a name="ln809">    gtk_label_set_selectable(value, TRUE);</a>
<a name="ln810">    gtk_container_add(GTK_CONTAINER(evb), GTK_WIDGET(value));</a>
<a name="ln811">    gtk_widget_set_halign(GTK_WIDGET(name), GTK_ALIGN_START);</a>
<a name="ln812">    gtk_widget_set_halign(GTK_WIDGET(value), GTK_ALIGN_START);</a>
<a name="ln813">    gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(name), NULL, GTK_POS_BOTTOM, 1, 1);</a>
<a name="ln814">    gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(evb), GTK_WIDGET(name), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln815">    gtk_widget_show_all(self-&gt;widget);</a>
<a name="ln816">    {</a>
<a name="ln817">      lua_getfield(L,-1,&quot;widgets&quot;);</a>
<a name="ln818">      lua_pushstring(L,key);</a>
<a name="ln819">      lua_pushlightuserdata(L,value);</a>
<a name="ln820">      lua_settable(L,5);</a>
<a name="ln821">      lua_pop(L,1);</a>
<a name="ln822">    }</a>
<a name="ln823">  }</a>
<a name="ln824">  return 0;</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">void init(struct dt_lib_module_t *self)</a>
<a name="ln828">{</a>
<a name="ln829"> </a>
<a name="ln830">  lua_State *L = darktable.lua_state.state;</a>
<a name="ln831">  int my_type = dt_lua_module_entry_get_type(L, &quot;lib&quot;, self-&gt;plugin_name);</a>
<a name="ln832">  lua_pushlightuserdata(L, self);</a>
<a name="ln833">  lua_pushcclosure(L, lua_register_info,1);</a>
<a name="ln834">  dt_lua_gtk_wrap(L);</a>
<a name="ln835">  lua_pushcclosure(L, dt_lua_type_member_common, 1);</a>
<a name="ln836">  dt_lua_type_register_const_type(L, my_type, &quot;register_info&quot;);</a>
<a name="ln837"> </a>
<a name="ln838">  dt_lua_module_entry_push(L,&quot;lib&quot;,self-&gt;plugin_name);</a>
<a name="ln839">  lua_getuservalue(L,-1);</a>
<a name="ln840">  lua_newtable(L);</a>
<a name="ln841">  lua_setfield(L,-2,&quot;callbacks&quot;);</a>
<a name="ln842">  lua_newtable(L);</a>
<a name="ln843">  lua_setfield(L,-2,&quot;values&quot;);</a>
<a name="ln844">  lua_newtable(L);</a>
<a name="ln845">  lua_setfield(L,-2,&quot;widgets&quot;);</a>
<a name="ln846">  lua_pop(L,2);</a>
<a name="ln847">}</a>
<a name="ln848">#endif</a>
<a name="ln849">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln850">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln851">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="410"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
