
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010-2011 johannes hanika</a>
<a name="ln4">    copyright (c) 2010-2012 henrik andersson</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;control/jobs/control_jobs.h&quot;</a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/exif.h&quot;</a>
<a name="ln24">#include &quot;common/film.h&quot;</a>
<a name="ln25">#include &quot;common/gpx.h&quot;</a>
<a name="ln26">#include &quot;common/history.h&quot;</a>
<a name="ln27">#include &quot;common/image.h&quot;</a>
<a name="ln28">#include &quot;common/image_cache.h&quot;</a>
<a name="ln29">#include &quot;common/imageio.h&quot;</a>
<a name="ln30">#include &quot;common/imageio_dng.h&quot;</a>
<a name="ln31">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln32">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln33">#include &quot;common/tags.h&quot;</a>
<a name="ln34">#include &quot;common/undo.h&quot;</a>
<a name="ln35">#include &quot;control/conf.h&quot;</a>
<a name="ln36">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;gui/gtk.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;gio/gio.h&gt;</a>
<a name="ln41">#include &lt;glib.h&gt;</a>
<a name="ln42">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln43">#ifndef _WIN32</a>
<a name="ln44">#include &lt;glob.h&gt;</a>
<a name="ln45">#endif</a>
<a name="ln46">#ifdef __APPLE__</a>
<a name="ln47">#include &quot;osx/osx.h&quot;</a>
<a name="ln48">#endif</a>
<a name="ln49">#ifdef _WIN32</a>
<a name="ln50">#include &quot;win/dtwin.h&quot;</a>
<a name="ln51">#endif</a>
<a name="ln52"> </a>
<a name="ln53">typedef struct dt_control_time_offset_t</a>
<a name="ln54">{</a>
<a name="ln55">  long int offset;</a>
<a name="ln56">} dt_control_time_offset_t;</a>
<a name="ln57"> </a>
<a name="ln58">typedef struct dt_control_gpx_apply_t</a>
<a name="ln59">{</a>
<a name="ln60">  gchar *filename;</a>
<a name="ln61">  gchar *tz;</a>
<a name="ln62">} dt_control_gpx_apply_t;</a>
<a name="ln63"> </a>
<a name="ln64">typedef struct dt_control_export_t</a>
<a name="ln65">{</a>
<a name="ln66">  int max_width, max_height, format_index, storage_index;</a>
<a name="ln67">  dt_imageio_module_data_t *sdata; // needed since the gui thread resets things like overwrite once the export</a>
<a name="ln68">  // is dispatched, but we have to keep that information</a>
<a name="ln69">  gboolean high_quality, upscale;</a>
<a name="ln70">  char style[128];</a>
<a name="ln71">  gboolean style_append;</a>
<a name="ln72">  dt_colorspaces_color_profile_type_t icc_type;</a>
<a name="ln73">  gchar *icc_filename;</a>
<a name="ln74">  dt_iop_color_intent_t icc_intent;</a>
<a name="ln75">} dt_control_export_t;</a>
<a name="ln76"> </a>
<a name="ln77">typedef struct dt_control_image_enumerator_t</a>
<a name="ln78">{</a>
<a name="ln79">  GList *index;</a>
<a name="ln80">  int flag;</a>
<a name="ln81">  gpointer data;</a>
<a name="ln82">} dt_control_image_enumerator_t;</a>
<a name="ln83"> </a>
<a name="ln84">typedef struct dt_undo_geotag_t</a>
<a name="ln85">{</a>
<a name="ln86">  GList *before;</a>
<a name="ln87">  GList *after;</a>
<a name="ln88">} dt_undo_geotag_t;</a>
<a name="ln89"> </a>
<a name="ln90">/* enumerator of images from filmroll */</a>
<a name="ln91">static void dt_control_image_enumerator_job_film_init(dt_control_image_enumerator_t *t, int32_t filmid)</a>
<a name="ln92">{</a>
<a name="ln93">  g_list_free(t-&gt;index);</a>
<a name="ln94">  t-&gt;index = NULL;</a>
<a name="ln95"> </a>
<a name="ln96">  sqlite3_stmt *stmt;</a>
<a name="ln97">  /* get a list of images in filmroll */</a>
<a name="ln98">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT id FROM main.images WHERE film_id = ?1&quot;, -1,</a>
<a name="ln99">                              &amp;stmt, NULL);</a>
<a name="ln100">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, filmid);</a>
<a name="ln101"> </a>
<a name="ln102">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln103">  {</a>
<a name="ln104">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln105">    t-&gt;index = g_list_append(t-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln106">  }</a>
<a name="ln107">  sqlite3_finalize(stmt);</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">/* enumerator of selected images */</a>
<a name="ln111">static void dt_control_image_enumerator_job_selected_init(dt_control_image_enumerator_t *t)</a>
<a name="ln112">{</a>
<a name="ln113">  g_list_free(t-&gt;index);</a>
<a name="ln114">  t-&gt;index = NULL;</a>
<a name="ln115"> </a>
<a name="ln116">  int imgid = dt_view_get_image_to_act_on();</a>
<a name="ln117"> </a>
<a name="ln118">  if(imgid &lt; 0) /* get sorted list of selected images */</a>
<a name="ln119">    t-&gt;index = dt_collection_get_selected(darktable.collection, -1);</a>
<a name="ln120">  else</a>
<a name="ln121">    /* Create a list with only one image */</a>
<a name="ln122">    t-&gt;index = g_list_append(t-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">static int32_t _generic_dt_control_fileop_images_job_run(dt_job_t *job,</a>
<a name="ln126">                                                         int32_t (*fileop_callback)(const int32_t,</a>
<a name="ln127">                                                                                    const int32_t),</a>
<a name="ln128">                                                         const char *desc, const char *desc_pl)</a>
<a name="ln129">{</a>
<a name="ln130">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln131">  GList *t = params-&gt;index;</a>
<a name="ln132">  guint total = g_list_length(t);</a>
<a name="ln133">  char message[512] = { 0 };</a>
<a name="ln134">  double fraction = 0;</a>
<a name="ln135">  gchar *newdir = (gchar *)params-&gt;data;</a>
<a name="ln136"> </a>
<a name="ln137">  g_snprintf(message, sizeof(message), ngettext(desc, desc_pl, total), total);</a>
<a name="ln138">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln139"> </a>
<a name="ln140">  // create new film roll for the destination directory</a>
<a name="ln141">  dt_film_t new_film;</a>
<a name="ln142">  const int32_t film_id = dt_film_new(&amp;new_film, newdir);</a>
<a name="ln143">  g_free(newdir);</a>
<a name="ln144"> </a>
<a name="ln145">  if(film_id &lt;= 0)</a>
<a name="ln146">  {</a>
<a name="ln147">    dt_control_log(_(&quot;failed to create film roll for destination directory, aborting move..&quot;));</a>
<a name="ln148">    return -1;</a>
<a name="ln149">  }</a>
<a name="ln150"> </a>
<a name="ln151">  gboolean completeSuccess = TRUE;</a>
<a name="ln152">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln153">  {</a>
<a name="ln154">    completeSuccess &amp;= (fileop_callback(GPOINTER_TO_INT(t-&gt;data), film_id) != -1);</a>
<a name="ln155">    t = g_list_delete_link(t, t);</a>
<a name="ln156">    fraction += 1.0 / total;</a>
<a name="ln157">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln158">  }</a>
<a name="ln159">  params-&gt;index = NULL;</a>
<a name="ln160"> </a>
<a name="ln161">  if(completeSuccess)</a>
<a name="ln162">  {</a>
<a name="ln163">    char collect[1024];</a>
<a name="ln164">    snprintf(collect, sizeof(collect), &quot;1:0:0:%s$&quot;, new_film.dirname);</a>
<a name="ln165">    dt_collection_deserialize(collect);</a>
<a name="ln166">  }</a>
<a name="ln167">  dt_film_remove_empty();</a>
<a name="ln168">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln169">  dt_control_queue_redraw_center();</a>
<a name="ln170">  return 0;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">static void *dt_control_image_enumerator_alloc()</a>
<a name="ln174">{</a>
<a name="ln175">  dt_control_image_enumerator_t *params = calloc(1, sizeof(dt_control_image_enumerator_t));</a>
<a name="ln176">  if(!params) return NULL;</a>
<a name="ln177"> </a>
<a name="ln178">  return params;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">static void dt_control_image_enumerator_cleanup(void *p)</a>
<a name="ln182">{</a>
<a name="ln183">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln184"> </a>
<a name="ln185">  g_list_free(params-&gt;index);</a>
<a name="ln186"> </a>
<a name="ln187">  free(params);</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">typedef enum {PROGRESS_NONE, PROGRESS_SIMPLE, PROGRESS_CANCELLABLE} progress_type_t;</a>
<a name="ln191"> </a>
<a name="ln192">static dt_job_t *dt_control_generic_images_job_create(dt_job_execute_callback execute, const char *message,</a>
<a name="ln193">                                                      int flag, gpointer data, progress_type_t progress_type)</a>
<a name="ln194">{</a>
<a name="ln195">  dt_job_t *job = dt_control_job_create(execute, &quot;%s&quot;, message);</a>
<a name="ln196">  if(!job) return NULL;</a>
<a name="ln197">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln198">  if(!params)</a>
<a name="ln199">  {</a>
<a name="ln200">    dt_control_job_dispose(job);</a>
<a name="ln201">    return NULL;</a>
<a name="ln202">  }</a>
<a name="ln203">  if(progress_type != PROGRESS_NONE)</a>
<a name="ln204">    dt_control_job_add_progress(job, _(message), progress_type == PROGRESS_CANCELLABLE);</a>
<a name="ln205">  dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln206">  dt_control_job_set_params(job, params, dt_control_image_enumerator_cleanup);</a>
<a name="ln207"> </a>
<a name="ln208">  params-&gt;flag = flag;</a>
<a name="ln209">  params-&gt;data = data;</a>
<a name="ln210">  return job;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">static int32_t dt_control_write_sidecar_files_job_run(dt_job_t *job)</a>
<a name="ln214">{</a>
<a name="ln215">  int imgid = -1;</a>
<a name="ln216">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln217">  GList *t = params-&gt;index;</a>
<a name="ln218">  sqlite3_stmt *stmt;</a>
<a name="ln219">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln220">                              &quot;UPDATE main.images SET write_timestamp = STRFTIME('%s', 'now') WHERE id = ?1&quot;, -1,</a>
<a name="ln221">                              &amp;stmt, NULL);</a>
<a name="ln222">  while(t)</a>
<a name="ln223">  {</a>
<a name="ln224">    gboolean from_cache = FALSE;</a>
<a name="ln225">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln226">    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, (int32_t)imgid, 'r');</a>
<a name="ln227">    char dtfilename[PATH_MAX] = { 0 };</a>
<a name="ln228">    dt_image_full_path(img-&gt;id, dtfilename, sizeof(dtfilename), &amp;from_cache);</a>
<a name="ln229">    dt_image_path_append_version(img-&gt;id, dtfilename, sizeof(dtfilename));</a>
<a name="ln230">    g_strlcat(dtfilename, &quot;.xmp&quot;, sizeof(dtfilename));</a>
<a name="ln231">    if(!dt_exif_xmp_write(imgid, dtfilename))</a>
<a name="ln232">    {</a>
<a name="ln233">      // put the timestamp into db. this can't be done in exif.cc since that code gets called</a>
<a name="ln234">      // for the copy exporter, too</a>
<a name="ln235">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln236">      sqlite3_step(stmt);</a>
<a name="ln237">      sqlite3_reset(stmt);</a>
<a name="ln238">      sqlite3_clear_bindings(stmt);</a>
<a name="ln239">    }</a>
<a name="ln240">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln241">    t = g_list_delete_link(t, t);</a>
<a name="ln242">  }</a>
<a name="ln243">  params-&gt;index = NULL;</a>
<a name="ln244">  sqlite3_finalize(stmt);</a>
<a name="ln245">  return 0;</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">typedef struct dt_control_merge_hdr_t</a>
<a name="ln249">{</a>
<a name="ln250">  uint32_t first_imgid;</a>
<a name="ln251">  uint32_t first_filter;</a>
<a name="ln252">  uint8_t first_xtrans[6][6];</a>
<a name="ln253"> </a>
<a name="ln254">  float *pixels, *weight;</a>
<a name="ln255"> </a>
<a name="ln256">  int wd;</a>
<a name="ln257">  int ht;</a>
<a name="ln258">  dt_image_orientation_t orientation;</a>
<a name="ln259"> </a>
<a name="ln260">  float whitelevel;</a>
<a name="ln261">  float epsw;</a>
<a name="ln262"> </a>
<a name="ln263">  // 0 - ok; 1 - errors, abort</a>
<a name="ln264">  gboolean abort;</a>
<a name="ln265">} dt_control_merge_hdr_t;</a>
<a name="ln266"> </a>
<a name="ln267">typedef struct dt_control_merge_hdr_format_t</a>
<a name="ln268">{</a>
<a name="ln269">  dt_imageio_module_data_t parent;</a>
<a name="ln270">  dt_control_merge_hdr_t *d;</a>
<a name="ln271">} dt_control_merge_hdr_format_t;</a>
<a name="ln272"> </a>
<a name="ln273">static int dt_control_merge_hdr_bpp(dt_imageio_module_data_t *data)</a>
<a name="ln274">{</a>
<a name="ln275">  return 32;</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">static int dt_control_merge_hdr_levels(dt_imageio_module_data_t *data)</a>
<a name="ln279">{</a>
<a name="ln280">  return IMAGEIO_RGB | IMAGEIO_FLOAT;</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">static const char *dt_control_merge_hdr_mime(dt_imageio_module_data_t *data)</a>
<a name="ln284">{</a>
<a name="ln285">  return &quot;memory&quot;;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">static float envelope(const float xx)</a>
<a name="ln289">{</a>
<a name="ln290">  const float x = CLAMPS(xx, 0.0f, 1.0f);</a>
<a name="ln291">  // const float alpha = 2.0f;</a>
<a name="ln292">  const float beta = 0.5f;</a>
<a name="ln293">  if(x &lt; beta)</a>
<a name="ln294">  {</a>
<a name="ln295">    // return 1.0f-fabsf(x/beta-1.0f)^2</a>
<a name="ln296">    const float tmp = fabsf(x / beta - 1.0f);</a>
<a name="ln297">    return 1.0f - tmp * tmp;</a>
<a name="ln298">  }</a>
<a name="ln299">  else</a>
<a name="ln300">  {</a>
<a name="ln301">    const float tmp1 = (1.0f - x) / (1.0f - beta);</a>
<a name="ln302">    const float tmp2 = tmp1 * tmp1;</a>
<a name="ln303">    const float tmp3 = tmp2 * tmp1;</a>
<a name="ln304">    return 3.0f * tmp2 - 2.0f * tmp3;</a>
<a name="ln305">  }</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">static int dt_control_merge_hdr_process(dt_imageio_module_data_t *datai, const char *filename,</a>
<a name="ln309">                                        const void *const ivoid,</a>
<a name="ln310">                                        dt_colorspaces_color_profile_type_t over_type, const char *over_filename,</a>
<a name="ln311">                                        void *exif, int exif_len, int imgid, int num, int total,</a>
<a name="ln312">                                        dt_dev_pixelpipe_t *pipe)</a>
<a name="ln313">{</a>
<a name="ln314">  dt_control_merge_hdr_format_t *data = (dt_control_merge_hdr_format_t *)datai;</a>
<a name="ln315">  dt_control_merge_hdr_t *d = data-&gt;d;</a>
<a name="ln316"> </a>
<a name="ln317">  // just take a copy. also do it after blocking read, so filters will make sense.</a>
<a name="ln318">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln319">  const dt_image_t image = *img;</a>
<a name="ln320">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln321"> </a>
<a name="ln322">  if(!d-&gt;pixels)</a>
<a name="ln323">  {</a>
<a name="ln324">    d-&gt;first_imgid = imgid;</a>
<a name="ln325">    d-&gt;first_filter = image.buf_dsc.filters;</a>
<a name="ln326">    // sensor layout is just passed on to be written to dng.</a>
<a name="ln327">    // we offset it to the crop of the image here, so we don't</a>
<a name="ln328">    // need to load in the FCxtrans dependency into the dng writer.</a>
<a name="ln329">    // for some stupid reason the dng needs this layout wrt cropped</a>
<a name="ln330">    // offsets, not globally.</a>
<a name="ln331">    dt_iop_roi_t roi = {0};</a>
<a name="ln332">    roi.x = image.crop_x;</a>
<a name="ln333">    roi.y = image.crop_y;</a>
<a name="ln334">    for(int j=0;j&lt;6;j++)</a>
<a name="ln335">      for(int i = 0; i &lt; 6; i++) d-&gt;first_xtrans[j][i] = FCxtrans(j, i, &amp;roi, image.buf_dsc.xtrans);</a>
<a name="ln336">    d-&gt;pixels = calloc(datai-&gt;width * datai-&gt;height, sizeof(float));</a>
<a name="ln337">    d-&gt;weight = calloc(datai-&gt;width * datai-&gt;height, sizeof(float));</a>
<a name="ln338">    d-&gt;wd = datai-&gt;width;</a>
<a name="ln339">    d-&gt;ht = datai-&gt;height;</a>
<a name="ln340">    d-&gt;orientation = image.orientation;</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  if(image.buf_dsc.filters == 0u || image.buf_dsc.channels != 1 || image.buf_dsc.datatype != TYPE_UINT16)</a>
<a name="ln344">  {</a>
<a name="ln345">    dt_control_log(_(&quot;exposure bracketing only works on raw images.&quot;));</a>
<a name="ln346">    d-&gt;abort = TRUE;</a>
<a name="ln347">    return 1;</a>
<a name="ln348">  }</a>
<a name="ln349">  else if(datai-&gt;width != d-&gt;wd || datai-&gt;height != d-&gt;ht || d-&gt;first_filter != image.buf_dsc.filters</a>
<a name="ln350">          || d-&gt;orientation != image.orientation)</a>
<a name="ln351">  {</a>
<a name="ln352">    dt_control_log(_(&quot;images have to be of same size and orientation!&quot;));</a>
<a name="ln353">    d-&gt;abort = TRUE;</a>
<a name="ln354">    return 1;</a>
<a name="ln355">  }</a>
<a name="ln356"> </a>
<a name="ln357">  // if no valid exif data can be found, assume peleng fisheye at f/16, 8mm, with half of the light lost in</a>
<a name="ln358">  // the system =&gt; f/22</a>
<a name="ln359">  const float eap = image.exif_aperture &gt; 0.0f ? image.exif_aperture : 22.0f;</a>
<a name="ln360">  const float efl = image.exif_focal_length &gt; 0.0f ? image.exif_focal_length : 8.0f;</a>
<a name="ln361">  const float rad = .5f * efl / eap;</a>
<a name="ln362">  const float aperture = M_PI * rad * rad;</a>
<a name="ln363">  const float iso = image.exif_iso &gt; 0.0f ? image.exif_iso : 100.0f;</a>
<a name="ln364">  const float exp = image.exif_exposure &gt; 0.0f ? image.exif_exposure : 1.0f;</a>
<a name="ln365">  const float cal = 100.0f / (aperture * exp * iso);</a>
<a name="ln366">  // about proportional to how many photons we can expect from this shot:</a>
<a name="ln367">  const float photoncnt = 100.0f * aperture * exp / iso;</a>
<a name="ln368">  float saturation = 1.0f;</a>
<a name="ln369">  d-&gt;whitelevel = fmaxf(d-&gt;whitelevel, saturation * cal);</a>
<a name="ln370">#ifdef _OPENMP</a>
<a name="ln371">#pragma omp parallel for default(none) \</a>
<a name="ln372">  dt_omp_firstprivate(ivoid, cal, photoncnt) \</a>
<a name="ln373">  shared(d, saturation) \</a>
<a name="ln374">  schedule(static)</a>
<a name="ln375">#endif</a>
<a name="ln376">  for(int y = 0; y &lt; d-&gt;ht; y++)</a>
<a name="ln377">    for(int x = 0; x &lt; d-&gt;wd; x++)</a>
<a name="ln378">    {</a>
<a name="ln379">      // read unclamped raw value with subtracted black and rescaled to 1.0 saturation.</a>
<a name="ln380">      // this is the output of the rawprepare iop.</a>
<a name="ln381">      const float in = ((float *)ivoid)[x + d-&gt;wd * y];</a>
<a name="ln382">      // weights based on siggraph 12 poster</a>
<a name="ln383">      // zijian zhu, zhengguo li, susanto rahardja, pasi fraenti</a>
<a name="ln384">      // 2d denoising factor for high dynamic range imaging</a>
<a name="ln385">      float w = photoncnt;</a>
<a name="ln386"> </a>
<a name="ln387">      // need some safety margin due to upsampling and 16-bit quantization + dithering?</a>
<a name="ln388">      float offset = 3000.0f / (float)UINT16_MAX;</a>
<a name="ln389"> </a>
<a name="ln390">      // cannot do an envelope based on single pixel values here, need to get</a>
<a name="ln391">      // maximum value of all color channels. to find that, go through the</a>
<a name="ln392">      // pattern block (we conservatively do a 3x3 for bayer or xtrans):</a>
<a name="ln393">      int xx = x &amp; ~1, yy = y &amp; ~1;</a>
<a name="ln394">      float M = 0.0f, m = FLT_MAX;</a>
<a name="ln395">      if(xx &lt; d-&gt;wd - 2 &amp;&amp; yy &lt; d-&gt;ht - 2)</a>
<a name="ln396">      {</a>
<a name="ln397">        for(int i = 0; i &lt; 3; i++)</a>
<a name="ln398">          for(int j = 0; j &lt; 3; j++)</a>
<a name="ln399">          {</a>
<a name="ln400">            M = MAX(M, ((float *)ivoid)[xx + i + d-&gt;wd * (yy + j)]);</a>
<a name="ln401">            m = MIN(m, ((float *)ivoid)[xx + i + d-&gt;wd * (yy + j)]);</a>
<a name="ln402">          }</a>
<a name="ln403">        // move envelope a little to allow non-zero weight even for clipped regions.</a>
<a name="ln404">        // this is because even if the 2x2 block is clipped somewhere, the other channels</a>
<a name="ln405">        // might still prove useful. we'll check for individual channel saturation below.</a>
<a name="ln406">        w *= d-&gt;epsw + envelope((M + offset) / saturation);</a>
<a name="ln407">      }</a>
<a name="ln408"> </a>
<a name="ln409">      if(M + offset &gt;= saturation)</a>
<a name="ln410">      {</a>
<a name="ln411">        if(d-&gt;weight[x + d-&gt;wd * y] &lt;= 0.0f)</a>
<a name="ln412">        { // only consider saturated pixels in case we have nothing better:</a>
<a name="ln413">          if(d-&gt;weight[x + d-&gt;wd * y] == 0 || m &lt; -d-&gt;weight[x + d-&gt;wd * y])</a>
<a name="ln414">          {</a>
<a name="ln415">            if(m + offset &gt;= saturation)</a>
<a name="ln416">              d-&gt;pixels[x + d-&gt;wd * y] = 1.0f; // let's admit we were completely clipped, too</a>
<a name="ln417">            else</a>
<a name="ln418">              d-&gt;pixels[x + d-&gt;wd * y] = in * cal / d-&gt;whitelevel;</a>
<a name="ln419">            d-&gt;weight[x + d-&gt;wd * y]</a>
<a name="ln420">                = -m; // could use -cal here, but m is per pixel and safer for varying illumination conditions</a>
<a name="ln421">          }</a>
<a name="ln422">        }</a>
<a name="ln423">        // else silently ignore, others have filled in a better color here already</a>
<a name="ln424">      }</a>
<a name="ln425">      else</a>
<a name="ln426">      {</a>
<a name="ln427">        if(d-&gt;weight[x + d-&gt;wd * y] &lt;= 0.0)</a>
<a name="ln428">        { // cleanup potentially blown highlights from earlier images</a>
<a name="ln429">          d-&gt;pixels[x + d-&gt;wd * y] = 0.0f;</a>
<a name="ln430">          d-&gt;weight[x + d-&gt;wd * y] = 0.0f;</a>
<a name="ln431">        }</a>
<a name="ln432">        d-&gt;pixels[x + d-&gt;wd * y] += w * in * cal;</a>
<a name="ln433">        d-&gt;weight[x + d-&gt;wd * y] += w;</a>
<a name="ln434">      }</a>
<a name="ln435">    }</a>
<a name="ln436"> </a>
<a name="ln437">  return 0;</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">static int32_t dt_control_merge_hdr_job_run(dt_job_t *job)</a>
<a name="ln441">{</a>
<a name="ln442">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln443">  GList *t = params-&gt;index;</a>
<a name="ln444">  const guint total = g_list_length(t);</a>
<a name="ln445">  char message[512] = { 0 };</a>
<a name="ln446">  double fraction = 0;</a>
<a name="ln447">  snprintf(message, sizeof(message), ngettext(&quot;merging %d image&quot;, &quot;merging %d images&quot;, total), total);</a>
<a name="ln448"> </a>
<a name="ln449">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln450"> </a>
<a name="ln451">  dt_control_merge_hdr_t d = (dt_control_merge_hdr_t){.epsw = 1e-8f, .abort = FALSE };</a>
<a name="ln452"> </a>
<a name="ln453">  dt_imageio_module_format_t buf = (dt_imageio_module_format_t){.mime = dt_control_merge_hdr_mime,</a>
<a name="ln454">                                                                .levels = dt_control_merge_hdr_levels,</a>
<a name="ln455">                                                                .bpp = dt_control_merge_hdr_bpp,</a>
<a name="ln456">                                                                .write_image = dt_control_merge_hdr_process };</a>
<a name="ln457"> </a>
<a name="ln458">  dt_control_merge_hdr_format_t dat = (dt_control_merge_hdr_format_t){.parent = { 0 }, .d = &amp;d };</a>
<a name="ln459"> </a>
<a name="ln460">  int num = 1;</a>
<a name="ln461">  while(t)</a>
<a name="ln462">  {</a>
<a name="ln463">    if(d.abort) goto end;</a>
<a name="ln464"> </a>
<a name="ln465">    const uint32_t imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln466"> </a>
<a name="ln467">    dt_imageio_export_with_flags(imgid, &quot;unused&quot;, &amp;buf, (dt_imageio_module_data_t *)&amp;dat, TRUE, FALSE, FALSE, TRUE,</a>
<a name="ln468">                                 FALSE, &quot;pre:rawprepare&quot;, FALSE, DT_COLORSPACE_NONE, NULL, DT_INTENT_LAST, NULL, NULL,</a>
<a name="ln469">                                 num, total);</a>
<a name="ln470"> </a>
<a name="ln471">    t = g_list_delete_link(t, t);</a>
<a name="ln472"> </a>
<a name="ln473">    /* update the progress bar */</a>
<a name="ln474">    fraction += 1.0 / (total + 1);</a>
<a name="ln475">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln476">    num++;</a>
<a name="ln477">  }</a>
<a name="ln478">  params-&gt;index = NULL;</a>
<a name="ln479"> </a>
<a name="ln480">  if(d.abort) goto end;</a>
<a name="ln481"> </a>
<a name="ln482">// normalize by white level to make clipping at 1.0 work as expected</a>
<a name="ln483"> </a>
<a name="ln484">#ifdef _OPENMP</a>
<a name="ln485">#pragma omp parallel for schedule(static) default(none) shared(d)</a>
<a name="ln486">#endif</a>
<a name="ln487">  for(size_t k = 0; k &lt; (size_t)d.wd * d.ht; k++)</a>
<a name="ln488">  {</a>
<a name="ln489">    if(d.weight[k] &gt; 0.0) d.pixels[k] = fmaxf(0.0f, d.pixels[k] / (d.whitelevel * d.weight[k]));</a>
<a name="ln490">  }</a>
<a name="ln491"> </a>
<a name="ln492">  // output hdr as digital negative with exif data.</a>
<a name="ln493">  uint8_t *exif = NULL;</a>
<a name="ln494">  char pathname[PATH_MAX] = { 0 };</a>
<a name="ln495">  gboolean from_cache = TRUE;</a>
<a name="ln496">  dt_image_full_path(d.first_imgid, pathname, sizeof(pathname), &amp;from_cache);</a>
<a name="ln497"> </a>
<a name="ln498">  // last param is dng mode</a>
<a name="ln499">  const int exif_len = dt_exif_read_blob(&amp;exif, pathname, d.first_imgid, 0, d.wd, d.ht, 1);</a>
<a name="ln500">  char *c = pathname + strlen(pathname);</a>
<a name="ln501">  while(*c != '.' &amp;&amp; c &gt; pathname) c--;</a>
<a name="ln502">  g_strlcpy(c, &quot;-hdr.dng&quot;, sizeof(pathname) - (c - pathname));</a>
<a name="ln503">  dt_imageio_write_dng(pathname, d.pixels, d.wd, d.ht, exif, exif_len, d.first_filter, (const uint8_t (*)[6])d.first_xtrans, 1.0f);</a>
<a name="ln504">  free(exif);</a>
<a name="ln505"> </a>
<a name="ln506">  dt_control_job_set_progress(job, 1.0);</a>
<a name="ln507"> </a>
<a name="ln508">  while(*c != '/' &amp;&amp; c &gt; pathname) c--;</a>
<a name="ln509">  dt_control_log(_(&quot;wrote merged HDR `%s'&quot;), c + 1);</a>
<a name="ln510"> </a>
<a name="ln511">  // import new image</a>
<a name="ln512">  gchar *directory = g_path_get_dirname((const gchar *)pathname);</a>
<a name="ln513">  dt_film_t film;</a>
<a name="ln514">  const int filmid = dt_film_new(&amp;film, directory);</a>
<a name="ln515">  dt_image_import(filmid, pathname, TRUE);</a>
<a name="ln516">  g_free(directory);</a>
<a name="ln517"> </a>
<a name="ln518">end:</a>
<a name="ln519">  free(d.pixels);</a>
<a name="ln520">  free(d.weight);</a>
<a name="ln521"> </a>
<a name="ln522">  dt_control_queue_redraw_center();</a>
<a name="ln523">  return 0;</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526">static int32_t dt_control_duplicate_images_job_run(dt_job_t *job)</a>
<a name="ln527">{</a>
<a name="ln528">  int imgid = -1;</a>
<a name="ln529">  int newimgid = -1;</a>
<a name="ln530">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln531">  GList *t = params-&gt;index;</a>
<a name="ln532">  guint total = g_list_length(t);</a>
<a name="ln533">  char message[512] = { 0 };</a>
<a name="ln534">  double fraction = 0;</a>
<a name="ln535">  snprintf(message, sizeof(message), ngettext(&quot;duplicating %d image&quot;, &quot;duplicating %d images&quot;, total), total);</a>
<a name="ln536">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln537">  while(t)</a>
<a name="ln538">  {</a>
<a name="ln539">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln540">    newimgid = dt_image_duplicate(imgid);</a>
<a name="ln541">    if(newimgid != -1) dt_history_copy_and_paste_on_image(imgid, newimgid, FALSE, NULL);</a>
<a name="ln542">    t = g_list_delete_link(t, t);</a>
<a name="ln543">    fraction = 1.0 / total;</a>
<a name="ln544">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln545">  }</a>
<a name="ln546">  params-&gt;index = NULL;</a>
<a name="ln547">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln548">  dt_control_queue_redraw_center();</a>
<a name="ln549">  return 0;</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">static int32_t dt_control_flip_images_job_run(dt_job_t *job)</a>
<a name="ln553">{</a>
<a name="ln554">  int imgid = -1;</a>
<a name="ln555">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln556">  const int cw = params-&gt;flag;</a>
<a name="ln557">  GList *t = params-&gt;index;</a>
<a name="ln558">  guint total = g_list_length(t);</a>
<a name="ln559">  double fraction = 0;</a>
<a name="ln560">  char message[512] = { 0 };</a>
<a name="ln561">  snprintf(message, sizeof(message), ngettext(&quot;flipping %d image&quot;, &quot;flipping %d images&quot;, total), total);</a>
<a name="ln562">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln563">  while(t)</a>
<a name="ln564">  {</a>
<a name="ln565">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln566">    dt_image_flip(imgid, cw);</a>
<a name="ln567">    t = g_list_delete_link(t, t);</a>
<a name="ln568">    fraction = 1.0 / total;</a>
<a name="ln569">    dt_image_set_aspect_ratio(imgid);</a>
<a name="ln570">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln571">  }</a>
<a name="ln572">  params-&gt;index = NULL;</a>
<a name="ln573">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln574">  dt_control_queue_redraw_center();</a>
<a name="ln575">  return 0;</a>
<a name="ln576">}</a>
<a name="ln577"> </a>
<a name="ln578">static char *_get_image_list(GList *l)</a>
<a name="ln579">{</a>
<a name="ln580">  const guint size = g_list_length(l);</a>
<a name="ln581">  char num[8];</a>
<a name="ln582">  char *buffer = calloc(size, sizeof(num));</a>
<a name="ln583">  int imgid;</a>
<a name="ln584">  gboolean first = TRUE;</a>
<a name="ln585"> </a>
<a name="ln586">  buffer[0] = '\0';</a>
<a name="ln587"> </a>
<a name="ln588">  while(l)</a>
<a name="ln589">  {</a>
<a name="ln590">    imgid = GPOINTER_TO_INT(l-&gt;data);</a>
<a name="ln591">    snprintf(num, sizeof(num), &quot;%s%6d&quot;, first ? &quot;&quot; : &quot;,&quot;, imgid);</a>
<a name="ln592">    g_strlcat(buffer, num, size * sizeof(num));</a>
<a name="ln593">    l = g_list_next(l);</a>
<a name="ln594">    first = FALSE;</a>
<a name="ln595">  }</a>
<a name="ln596">  return buffer;</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599">static void _set_remove_flag(char *imgs)</a>
<a name="ln600">{</a>
<a name="ln601">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln602">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln603">                              &quot;UPDATE main.images SET flags = (flags|?1) WHERE id IN (?2)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln604">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, DT_IMAGE_REMOVE);</a>
<a name="ln605">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgs, -1, SQLITE_STATIC);</a>
<a name="ln606">  sqlite3_step(stmt);</a>
<a name="ln607">  sqlite3_finalize(stmt);</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">static GList *_get_full_pathname(char *imgs)</a>
<a name="ln611">{</a>
<a name="ln612">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln613">  GList *list = NULL;</a>
<a name="ln614"> </a>
<a name="ln615">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT DISTINCT folder || '&quot; G_DIR_SEPARATOR_S &quot;' || filename FROM &quot;</a>
<a name="ln616">                                                             &quot;main.images i, main.film_rolls f &quot;</a>
<a name="ln617">                                                             &quot;ON i.film_id = f.id WHERE i.id IN (?1)&quot;,</a>
<a name="ln618">                              -1, &amp;stmt, NULL);</a>
<a name="ln619">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, imgs, -1, SQLITE_STATIC);</a>
<a name="ln620">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln621">  {</a>
<a name="ln622">    list = g_list_append(list, g_strdup((const gchar *)sqlite3_column_text(stmt, 0)));</a>
<a name="ln623">  }</a>
<a name="ln624">  sqlite3_finalize(stmt);</a>
<a name="ln625">  return list;</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">static int32_t dt_control_remove_images_job_run(dt_job_t *job)</a>
<a name="ln629">{</a>
<a name="ln630">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln631">  GList *t = params-&gt;index;</a>
<a name="ln632">  char *imgs = _get_image_list(t);</a>
<a name="ln633">  guint total = g_list_length(t);</a>
<a name="ln634">  char message[512] = { 0 };</a>
<a name="ln635">  double fraction = 0;</a>
<a name="ln636">  snprintf(message, sizeof(message), ngettext(&quot;removing %d image&quot;, &quot;removing %d images&quot;, total), total);</a>
<a name="ln637">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln638">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln639"> </a>
<a name="ln640">  // check that we can safely remove the image</a>
<a name="ln641">  gboolean remove_ok = TRUE;</a>
<a name="ln642">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln643">                              &quot;SELECT id FROM main.images WHERE id IN (?2) AND flags&amp;?1=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln644">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, DT_IMAGE_LOCAL_COPY);</a>
<a name="ln645">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgs, -1, SQLITE_STATIC);</a>
<a name="ln646"> </a>
<a name="ln647">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln648">  {</a>
<a name="ln649">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln650">    if(!dt_image_safe_remove(imgid))</a>
<a name="ln651">    {</a>
<a name="ln652">      remove_ok = FALSE;</a>
<a name="ln653">      break;</a>
<a name="ln654">    }</a>
<a name="ln655">  }</a>
<a name="ln656">  sqlite3_finalize(stmt);</a>
<a name="ln657"> </a>
<a name="ln658">  if(!remove_ok)</a>
<a name="ln659">  {</a>
<a name="ln660">    dt_control_log(_(&quot;cannot remove local copy when the original file is not accessible.&quot;));</a>
<a name="ln661">    free(imgs);</a>
<a name="ln662">    return 0;</a>
<a name="ln663">  }</a>
<a name="ln664"> </a>
<a name="ln665">  // update remove status</a>
<a name="ln666">  _set_remove_flag(imgs);</a>
<a name="ln667"> </a>
<a name="ln668">  dt_collection_update(darktable.collection);</a>
<a name="ln669"> </a>
<a name="ln670">  // We need a list of files to regenerate .xmp files if there are duplicates</a>
<a name="ln671">  GList *list = _get_full_pathname(imgs);</a>
<a name="ln672"> </a>
<a name="ln673">  free(imgs);</a>
<a name="ln674"> </a>
<a name="ln675">  while(t)</a>
<a name="ln676">  {</a>
<a name="ln677">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln678">    dt_image_remove(imgid);</a>
<a name="ln679">    t = g_list_delete_link(t, t);</a>
<a name="ln680">    fraction = 1.0 / total;</a>
<a name="ln681">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln682">  }</a>
<a name="ln683">  params-&gt;index = NULL;</a>
<a name="ln684"> </a>
<a name="ln685">  char *imgname;</a>
<a name="ln686">  while(list)</a>
<a name="ln687">  {</a>
<a name="ln688">    imgname = (char *)list-&gt;data;</a>
<a name="ln689">    dt_image_synch_all_xmp(imgname);</a>
<a name="ln690">    list = g_list_delete_link(list, list);</a>
<a name="ln691">  }</a>
<a name="ln692">  dt_film_remove_empty();</a>
<a name="ln693">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln694">  dt_control_queue_redraw_center();</a>
<a name="ln695">  return 0;</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">typedef struct _dt_delete_modal_dialog_t</a>
<a name="ln699">{</a>
<a name="ln700">  int send_to_trash;</a>
<a name="ln701">  const char *filename;</a>
<a name="ln702">  const char *error_message;</a>
<a name="ln703"> </a>
<a name="ln704">  gint dialog_result;</a>
<a name="ln705"> </a>
<a name="ln706">  dt_pthread_mutex_t mutex;</a>
<a name="ln707">  pthread_cond_t cond;</a>
<a name="ln708">} _dt_delete_modal_dialog_t;</a>
<a name="ln709"> </a>
<a name="ln710">enum _dt_delete_status</a>
<a name="ln711">{</a>
<a name="ln712">  _DT_DELETE_STATUS_UNKNOWN = 0,</a>
<a name="ln713">  _DT_DELETE_STATUS_OK_TO_REMOVE = 1,</a>
<a name="ln714">  _DT_DELETE_STATUS_SKIP_FILE = 2,</a>
<a name="ln715">  _DT_DELETE_STATUS_STOP_PROCESSING = 3</a>
<a name="ln716">};</a>
<a name="ln717"> </a>
<a name="ln718">enum _dt_delete_dialog_choice</a>
<a name="ln719">{</a>
<a name="ln720">  _DT_DELETE_DIALOG_CHOICE_DELETE = 1,</a>
<a name="ln721">  _DT_DELETE_DIALOG_CHOICE_DELETE_ALL = 2,</a>
<a name="ln722">  _DT_DELETE_DIALOG_CHOICE_REMOVE = 3,</a>
<a name="ln723">  _DT_DELETE_DIALOG_CHOICE_CONTINUE = 4,</a>
<a name="ln724">  _DT_DELETE_DIALOG_CHOICE_STOP = 5</a>
<a name="ln725">};</a>
<a name="ln726"> </a>
<a name="ln727">static gboolean _dt_delete_dialog_main_thread(gpointer user_data)</a>
<a name="ln728">{</a>
<a name="ln729">  _dt_delete_modal_dialog_t* modal_dialog = (_dt_delete_modal_dialog_t*)user_data;</a>
<a name="ln730">  dt_pthread_mutex_lock(&amp;modal_dialog-&gt;mutex);</a>
<a name="ln731"> </a>
<a name="ln732">  GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln733">      GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)),</a>
<a name="ln734">      GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln735">      GTK_MESSAGE_QUESTION,</a>
<a name="ln736">      GTK_BUTTONS_NONE,</a>
<a name="ln737">      modal_dialog-&gt;send_to_trash</a>
<a name="ln738">        ? _(&quot;could not send %s to trash%s%s&quot;)</a>
<a name="ln739">        : _(&quot;could not physically delete %s%s%s&quot;),</a>
<a name="ln740">      modal_dialog-&gt;filename,</a>
<a name="ln741">      modal_dialog-&gt;error_message != NULL ? &quot;: &quot; : &quot;&quot;,</a>
<a name="ln742">      modal_dialog-&gt;error_message != NULL ? modal_dialog-&gt;error_message : &quot;&quot;);</a>
<a name="ln743">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln744">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln745">#endif</a>
<a name="ln746"> </a>
<a name="ln747">  if (modal_dialog-&gt;send_to_trash)</a>
<a name="ln748">  {</a>
<a name="ln749">    gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;physically delete&quot;), _DT_DELETE_DIALOG_CHOICE_DELETE);</a>
<a name="ln750">    gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;physically delete all files&quot;), _DT_DELETE_DIALOG_CHOICE_DELETE_ALL);</a>
<a name="ln751">  }</a>
<a name="ln752">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;only remove from the collection&quot;), _DT_DELETE_DIALOG_CHOICE_REMOVE);</a>
<a name="ln753">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;skip to next file&quot;), _DT_DELETE_DIALOG_CHOICE_CONTINUE);</a>
<a name="ln754">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;stop process&quot;), _DT_DELETE_DIALOG_CHOICE_STOP);</a>
<a name="ln755"> </a>
<a name="ln756">  gtk_window_set_title(</a>
<a name="ln757">      GTK_WINDOW(dialog),</a>
<a name="ln758">      modal_dialog-&gt;send_to_trash</a>
<a name="ln759">        ? _(&quot;trashing error&quot;)</a>
<a name="ln760">        : _(&quot;deletion error&quot;));</a>
<a name="ln761">  modal_dialog-&gt;dialog_result = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln762">  gtk_widget_destroy(dialog);</a>
<a name="ln763"> </a>
<a name="ln764">  pthread_cond_signal(&amp;modal_dialog-&gt;cond);</a>
<a name="ln765"> </a>
<a name="ln766">  dt_pthread_mutex_unlock(&amp;modal_dialog-&gt;mutex);</a>
<a name="ln767"> </a>
<a name="ln768">  // Don't call again on next idle time</a>
<a name="ln769">  return FALSE;</a>
<a name="ln770">}</a>
<a name="ln771"> </a>
<a name="ln772">static gint _dt_delete_file_display_modal_dialog(int send_to_trash, const char *filename, const char *error_message)</a>
<a name="ln773">{</a>
<a name="ln774">  _dt_delete_modal_dialog_t modal_dialog;</a>
<a name="ln775">  modal_dialog.send_to_trash = send_to_trash;</a>
<a name="ln776">  modal_dialog.filename = filename;</a>
<a name="ln777">  modal_dialog.error_message = error_message;</a>
<a name="ln778"> </a>
<a name="ln779">  modal_dialog.dialog_result = GTK_RESPONSE_NONE;</a>
<a name="ln780"> </a>
<a name="ln781">  dt_pthread_mutex_init(&amp;modal_dialog.mutex, NULL);</a>
<a name="ln782">  pthread_cond_init(&amp;modal_dialog.cond, NULL);</a>
<a name="ln783"> </a>
<a name="ln784">  dt_pthread_mutex_lock(&amp;modal_dialog.mutex);</a>
<a name="ln785"> </a>
<a name="ln786">  gdk_threads_add_idle(_dt_delete_dialog_main_thread, &amp;modal_dialog);</a>
<a name="ln787">  while (modal_dialog.dialog_result == GTK_RESPONSE_NONE)</a>
<a name="ln788">    dt_pthread_cond_wait(&amp;modal_dialog.cond, &amp;modal_dialog.mutex);</a>
<a name="ln789"> </a>
<a name="ln790">  dt_pthread_mutex_unlock(&amp;modal_dialog.mutex);</a>
<a name="ln791">  dt_pthread_mutex_destroy(&amp;modal_dialog.mutex);</a>
<a name="ln792">  pthread_cond_destroy(&amp;modal_dialog.cond);</a>
<a name="ln793"> </a>
<a name="ln794">  return modal_dialog.dialog_result;</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797">static enum _dt_delete_status delete_file_from_disk(const char *filename, gboolean *delete_on_trash_error)</a>
<a name="ln798">{</a>
<a name="ln799">  enum _dt_delete_status delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln800"> </a>
<a name="ln801">  GFile *gfile = g_file_new_for_path(filename);</a>
<a name="ln802">  int send_to_trash = dt_conf_get_bool(&quot;send_to_trash&quot;);</a>
<a name="ln803"> </a>
<a name="ln804">  while (delete_status == _DT_DELETE_STATUS_UNKNOWN)</a>
<a name="ln805">  {</a>
<a name="ln806">    gboolean delete_success = FALSE;</a>
<a name="ln807">    GError *gerror = NULL;</a>
<a name="ln808">    if (send_to_trash)</a>
<a name="ln809">    {</a>
<a name="ln810">#ifdef __APPLE__</a>
<a name="ln811">      delete_success = dt_osx_file_trash(filename, &amp;gerror);</a>
<a name="ln812">#elif defined(_WIN32)</a>
<a name="ln813">      delete_success = dt_win_file_trash(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln814">#else</a>
<a name="ln815">      delete_success = g_file_trash(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln816">#endif</a>
<a name="ln817">    }</a>
<a name="ln818">    else</a>
<a name="ln819">    {</a>
<a name="ln820">      delete_success = g_file_delete(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln821">    }</a>
<a name="ln822"> </a>
<a name="ln823">    // Delete is a success or the file does not exists: OK to remove from collection</a>
<a name="ln824">    if (delete_success</a>
<a name="ln825">        || g_error_matches(gerror, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))</a>
<a name="ln826">    {</a>
<a name="ln827">      delete_status = _DT_DELETE_STATUS_OK_TO_REMOVE;</a>
<a name="ln828">    }</a>
<a name="ln829">    else if (send_to_trash &amp;&amp; *delete_on_trash_error)</a>
<a name="ln830">    {</a>
<a name="ln831">      // Loop again, this time delete instead of trashing</a>
<a name="ln832">      delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln833">      send_to_trash = FALSE;</a>
<a name="ln834">    }</a>
<a name="ln835">    else</a>
<a name="ln836">    {</a>
<a name="ln837">      const char *filename_display = NULL;</a>
<a name="ln838">      GFileInfo *gfileinfo = g_file_query_info(</a>
<a name="ln839">          gfile,</a>
<a name="ln840">          G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,</a>
<a name="ln841">          G_FILE_QUERY_INFO_NONE,</a>
<a name="ln842">          NULL /*cancellable*/,</a>
<a name="ln843">          NULL /*error*/);</a>
<a name="ln844">      if (gfileinfo != NULL)</a>
<a name="ln845">        filename_display = g_file_info_get_attribute_string(</a>
<a name="ln846">            gfileinfo,</a>
<a name="ln847">            G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME);</a>
<a name="ln848"> </a>
<a name="ln849">      gint res = _dt_delete_file_display_modal_dialog(</a>
<a name="ln850">          send_to_trash,</a>
<a name="ln851">          filename_display == NULL ? filename : filename_display,</a>
<a name="ln852">          gerror == NULL ? NULL : gerror-&gt;message);</a>
<a name="ln853"> </a>
<a name="ln854">      if (send_to_trash &amp;&amp; res == _DT_DELETE_DIALOG_CHOICE_DELETE)</a>
<a name="ln855">      {</a>
<a name="ln856">        // Loop again, this time delete instead of trashing</a>
<a name="ln857">        delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln858">        send_to_trash = FALSE;</a>
<a name="ln859">      }</a>
<a name="ln860">      else if (send_to_trash &amp;&amp; res == _DT_DELETE_DIALOG_CHOICE_DELETE_ALL)</a>
<a name="ln861">      {</a>
<a name="ln862">        // Loop again, this time delete instead of trashing</a>
<a name="ln863">        delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln864">        send_to_trash = FALSE;</a>
<a name="ln865">        *delete_on_trash_error = TRUE;</a>
<a name="ln866">      }</a>
<a name="ln867">      else if (res == _DT_DELETE_DIALOG_CHOICE_REMOVE)</a>
<a name="ln868">      {</a>
<a name="ln869">        delete_status = _DT_DELETE_STATUS_OK_TO_REMOVE;</a>
<a name="ln870">      }</a>
<a name="ln871">      else if (res == _DT_DELETE_DIALOG_CHOICE_CONTINUE)</a>
<a name="ln872">      {</a>
<a name="ln873">        delete_status = _DT_DELETE_STATUS_SKIP_FILE;</a>
<a name="ln874">      }</a>
<a name="ln875">      else</a>
<a name="ln876">      {</a>
<a name="ln877">        delete_status = _DT_DELETE_STATUS_STOP_PROCESSING;</a>
<a name="ln878">      }</a>
<a name="ln879">    }</a>
<a name="ln880">    if (gerror != NULL)</a>
<a name="ln881">      g_error_free(gerror);</a>
<a name="ln882">  }</a>
<a name="ln883"> </a>
<a name="ln884">  if (gfile != NULL)</a>
<a name="ln885">    g_object_unref(gfile);</a>
<a name="ln886"> </a>
<a name="ln887">  return delete_status;</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890"> </a>
<a name="ln891">static int32_t dt_control_delete_images_job_run(dt_job_t *job)</a>
<a name="ln892">{</a>
<a name="ln893">  int imgid = -1;</a>
<a name="ln894">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln895">  GList *t = params-&gt;index;</a>
<a name="ln896">  char *imgs = _get_image_list(t);</a>
<a name="ln897">  char imgidstr[25] = { 0 };</a>
<a name="ln898">  guint total = g_list_length(t);</a>
<a name="ln899">  char message[512] = { 0 };</a>
<a name="ln900">  double fraction = 0;</a>
<a name="ln901">  gboolean delete_on_trash_error = FALSE;</a>
<a name="ln902">  if (dt_conf_get_bool(&quot;send_to_trash&quot;))</a>
<a name="ln903">    snprintf(message, sizeof(message), ngettext(&quot;trashing %d image&quot;, &quot;trashing %d images&quot;, total), total);</a>
<a name="ln904">  else</a>
<a name="ln905">    snprintf(message, sizeof(message), ngettext(&quot;deleting %d image&quot;, &quot;deleting %d images&quot;, total), total);</a>
<a name="ln906">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln907"> </a>
<a name="ln908">  sqlite3_stmt *stmt;</a>
<a name="ln909"> </a>
<a name="ln910">  dt_collection_update(darktable.collection);</a>
<a name="ln911"> </a>
<a name="ln912">  // We need a list of files to regenerate .xmp files if there are duplicates</a>
<a name="ln913">  GList *list = _get_full_pathname(imgs);</a>
<a name="ln914"> </a>
<a name="ln915">  free(imgs);</a>
<a name="ln916"> </a>
<a name="ln917">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln918">                              &quot;SELECT COUNT(*) FROM main.images WHERE filename IN (SELECT filename FROM &quot;</a>
<a name="ln919">                              &quot;main.images WHERE id = ?1) AND film_id IN (SELECT film_id FROM main.images WHERE &quot;</a>
<a name="ln920">                              &quot;id = ?1)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln921">  while(t)</a>
<a name="ln922">  {</a>
<a name="ln923">    enum _dt_delete_status delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln924">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln925">    char filename[PATH_MAX] = { 0 };</a>
<a name="ln926">    gboolean from_cache = FALSE;</a>
<a name="ln927">    dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln928"> </a>
<a name="ln929">#ifdef _WIN32</a>
<a name="ln930">    char *dirname = g_path_get_dirname(filename);</a>
<a name="ln931">#endif</a>
<a name="ln932"> </a>
<a name="ln933">    int duplicates = 0;</a>
<a name="ln934">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln935">    if(sqlite3_step(stmt) == SQLITE_ROW) duplicates = sqlite3_column_int(stmt, 0);</a>
<a name="ln936">    sqlite3_reset(stmt);</a>
<a name="ln937">    sqlite3_clear_bindings(stmt);</a>
<a name="ln938"> </a>
<a name="ln939">    // remove from disk:</a>
<a name="ln940">    if(duplicates == 1)</a>
<a name="ln941">    {</a>
<a name="ln942">      // first check for local copies, never delete a file whose original file is not accessible</a>
<a name="ln943">      if (dt_image_local_copy_reset(imgid))</a>
<a name="ln944">        goto delete_next_file;</a>
<a name="ln945"> </a>
<a name="ln946">      snprintf(imgidstr, sizeof(imgidstr), &quot;%d&quot;, imgid);</a>
<a name="ln947">      _set_remove_flag(imgidstr);</a>
<a name="ln948">      dt_image_remove(imgid);</a>
<a name="ln949"> </a>
<a name="ln950">      // there are no further duplicates so we can remove the source data file</a>
<a name="ln951">      delete_status = delete_file_from_disk(filename, &amp;delete_on_trash_error);</a>
<a name="ln952">      if (delete_status != _DT_DELETE_STATUS_OK_TO_REMOVE)</a>
<a name="ln953">        goto delete_next_file;</a>
<a name="ln954"> </a>
<a name="ln955">      // all sidecar files - including left-overs - can be deleted;</a>
<a name="ln956">      // left-overs can result when previously duplicates have been REMOVED;</a>
<a name="ln957">      // no need to keep them as the source data file is gone.</a>
<a name="ln958">      gchar pattern[PATH_MAX] = { 0 };</a>
<a name="ln959"> </a>
<a name="ln960">      // NULL terminated list of glob patterns; should include &quot;&quot; and can be extended if needed</a>
<a name="ln961">      static const gchar *glob_patterns[]</a>
<a name="ln962">          = { &quot;&quot;, &quot;_[0-9][0-9]&quot;, &quot;_[0-9][0-9][0-9]&quot;, &quot;_[0-9][0-9][0-9][0-9]&quot;, NULL };</a>
<a name="ln963"> </a>
<a name="ln964">      const gchar **glob_pattern = glob_patterns;</a>
<a name="ln965">      GList *files = NULL;</a>
<a name="ln966">      while(*glob_pattern)</a>
<a name="ln967">      {</a>
<a name="ln968">        snprintf(pattern, sizeof(pattern), &quot;%s&quot;, filename);</a>
<a name="ln969">        gchar *c1 = pattern + strlen(pattern);</a>
<a name="ln970">        while(*c1 != '.' &amp;&amp; c1 &gt; pattern) c1--;</a>
<a name="ln971">        snprintf(c1, pattern + sizeof(pattern) - c1, &quot;%s&quot;, *glob_pattern);</a>
<a name="ln972">        const gchar *c2 = filename + strlen(filename);</a>
<a name="ln973">        while(*c2 != '.' &amp;&amp; c2 &gt; filename) c2--;</a>
<a name="ln974">        snprintf(c1 + strlen(*glob_pattern), pattern + sizeof(pattern) - c1 - strlen(*glob_pattern), &quot;%s.xmp&quot;,</a>
<a name="ln975">                 c2);</a>
<a name="ln976"> </a>
<a name="ln977">#ifdef _WIN32</a>
<a name="ln978">        wchar_t *wpattern = g_utf8_to_utf16(pattern, -1, NULL, NULL, NULL);</a>
<a name="ln979">        WIN32_FIND_DATAW data;</a>
<a name="ln980">        HANDLE handle = FindFirstFileW(wpattern, &amp;data);</a>
<a name="ln981">        g_free(wpattern);</a>
<a name="ln982">        if(handle != INVALID_HANDLE_VALUE)</a>
<a name="ln983">        {</a>
<a name="ln984">          do</a>
<a name="ln985">          {</a>
<a name="ln986">            char *xmp_filename = g_utf16_to_utf8(data.cFileName, -1, NULL, NULL, NULL);</a>
<a name="ln987">            files = g_list_append(files, g_build_filename(dirname, xmp_filename, NULL));</a>
<a name="ln988">            g_free(xmp_filename);</a>
<a name="ln989">          }</a>
<a name="ln990">          while(FindNextFileW(handle, &amp;data));</a>
<a name="ln991">        }</a>
<a name="ln992">#else</a>
<a name="ln993">        glob_t globbuf;</a>
<a name="ln994">        if(!glob(pattern, 0, NULL, &amp;globbuf))</a>
<a name="ln995">        {</a>
<a name="ln996">          for(size_t i = 0; i &lt; globbuf.gl_pathc; i++)</a>
<a name="ln997">            files = g_list_append(files, g_strdup(globbuf.gl_pathv[i]));</a>
<a name="ln998">          globfree(&amp;globbuf);</a>
<a name="ln999">        }</a>
<a name="ln1000">#endif</a>
<a name="ln1001"> </a>
<a name="ln1002">        glob_pattern++;</a>
<a name="ln1003">      }</a>
<a name="ln1004"> </a>
<a name="ln1005">      GList *file_iter = g_list_first(files);</a>
<a name="ln1006">      while(file_iter != NULL)</a>
<a name="ln1007">      {</a>
<a name="ln1008">        delete_status = delete_file_from_disk(file_iter-&gt;data, &amp;delete_on_trash_error);</a>
<a name="ln1009">        if (delete_status != _DT_DELETE_STATUS_OK_TO_REMOVE)</a>
<a name="ln1010">          break;</a>
<a name="ln1011">        file_iter = g_list_next(file_iter);</a>
<a name="ln1012">      }</a>
<a name="ln1013"> </a>
<a name="ln1014">      g_list_free_full(files, g_free);</a>
<a name="ln1015">    }</a>
<a name="ln1016">    else</a>
<a name="ln1017">    {</a>
<a name="ln1018">      // don't remove the actual source data if there are further duplicates using it;</a>
<a name="ln1019">      // just delete the xmp file of the duplicate selected.</a>
<a name="ln1020"> </a>
<a name="ln1021">      dt_image_path_append_version(imgid, filename, sizeof(filename));</a>
<a name="ln1022">      g_strlcat(filename, &quot;.xmp&quot;, sizeof(filename));</a>
<a name="ln1023"> </a>
<a name="ln1024">      // remove image from db first ...</a>
<a name="ln1025">      snprintf(imgidstr, sizeof(imgidstr), &quot;%d&quot;, imgid);</a>
<a name="ln1026">      _set_remove_flag(imgidstr);</a>
<a name="ln1027">      dt_image_remove(imgid);</a>
<a name="ln1028"> </a>
<a name="ln1029">      // ... and delete afterwards because removing will re-write the XMP</a>
<a name="ln1030">      delete_status = delete_file_from_disk(filename, &amp;delete_on_trash_error);</a>
<a name="ln1031">    }</a>
<a name="ln1032"> </a>
<a name="ln1033">delete_next_file:</a>
<a name="ln1034">#ifdef _WIN32</a>
<a name="ln1035">    g_free(dirname);</a>
<a name="ln1036">#endif</a>
<a name="ln1037">    t = g_list_delete_link(t, t);</a>
<a name="ln1038">    fraction = 1.0 / total;</a>
<a name="ln1039">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1040">    if (delete_status == _DT_DELETE_STATUS_STOP_PROCESSING)</a>
<a name="ln1041">      break;</a>
<a name="ln1042">  }</a>
<a name="ln1043">  while (t)</a>
<a name="ln1044">    t = g_list_delete_link(t, t);</a>
<a name="ln1045">  params-&gt;index = NULL;</a>
<a name="ln1046">  sqlite3_finalize(stmt);</a>
<a name="ln1047"> </a>
<a name="ln1048">  char *imgname;</a>
<a name="ln1049">  while(list)</a>
<a name="ln1050">  {</a>
<a name="ln1051">    imgname = (char *)list-&gt;data;</a>
<a name="ln1052">    dt_image_synch_all_xmp(imgname);</a>
<a name="ln1053">    list = g_list_delete_link(list, list);</a>
<a name="ln1054">  }</a>
<a name="ln1055">  g_list_free(list);</a>
<a name="ln1056">  dt_film_remove_empty();</a>
<a name="ln1057">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln1058">  dt_control_queue_redraw_center();</a>
<a name="ln1059">  return 0;</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062">static void _pop_undo(gpointer user_data, dt_undo_type_t type, dt_undo_data_t item, dt_undo_action_t action)</a>
<a name="ln1063">{</a>
<a name="ln1064">  dt_undo_geotag_t *geotags = (dt_undo_geotag_t *)item;</a>
<a name="ln1065">  GList *l;</a>
<a name="ln1066"> </a>
<a name="ln1067">  if(action == DT_ACTION_UNDO)</a>
<a name="ln1068">    l = geotags-&gt;before;</a>
<a name="ln1069">  else</a>
<a name="ln1070">    l = geotags-&gt;after;</a>
<a name="ln1071"> </a>
<a name="ln1072">  while(l)</a>
<a name="ln1073">  {</a>
<a name="ln1074">    const int imgid = GPOINTER_TO_INT((dt_image_geoloc_t *)l-&gt;data);</a>
<a name="ln1075"> </a>
<a name="ln1076">    l = g_list_next(l);</a>
<a name="ln1077">    dt_image_geoloc_t *geoloc = (dt_image_geoloc_t *)l-&gt;data;</a>
<a name="ln1078">    dt_image_set_location_and_elevation(imgid, geoloc);</a>
<a name="ln1079"> </a>
<a name="ln1080">    l = g_list_next(l);</a>
<a name="ln1081">  }</a>
<a name="ln1082">}</a>
<a name="ln1083"> </a>
<a name="ln1084">void _geotags_free_undo_data_t(gpointer data)</a>
<a name="ln1085">{</a>
<a name="ln1086">  dt_undo_geotag_t *geotags = (dt_undo_geotag_t *)data;</a>
<a name="ln1087">  GList *lb = geotags-&gt;before;</a>
<a name="ln1088">  GList *la = geotags-&gt;after;</a>
<a name="ln1089"> </a>
<a name="ln1090">  do</a>
<a name="ln1091">  {</a>
<a name="ln1092">    if(la) la = g_list_next(la);</a>
<a name="ln1093">    if(la) g_free((dt_image_geoloc_t *)la-&gt;data);</a>
<a name="ln1094">    if(lb) lb = g_list_next(lb);</a>
<a name="ln1095">    if(lb) g_free((dt_image_geoloc_t *)lb-&gt;data);</a>
<a name="ln1096">    if(la) la = g_list_next(la);</a>
<a name="ln1097">    if(lb) lb = g_list_next(lb);</a>
<a name="ln1098">  } while(la || lb);</a>
<a name="ln1099"> </a>
<a name="ln1100">  g_list_free(geotags-&gt;before);</a>
<a name="ln1101">  g_list_free(geotags-&gt;after);</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104">static int32_t dt_control_gpx_apply_job_run(dt_job_t *job)</a>
<a name="ln1105">{</a>
<a name="ln1106">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln1107">  GList *t = params-&gt;index;</a>
<a name="ln1108">  struct dt_gpx_t *gpx = NULL;</a>
<a name="ln1109">  uint32_t cntr = 0;</a>
<a name="ln1110">  const dt_control_gpx_apply_t *d = params-&gt;data;</a>
<a name="ln1111">  const gchar *filename = d-&gt;filename;</a>
<a name="ln1112">  const gchar *tz = d-&gt;tz;</a>
<a name="ln1113"> </a>
<a name="ln1114">  /* do we have any selected images */</a>
<a name="ln1115">  if(!t) goto bail_out;</a>
<a name="ln1116"> </a>
<a name="ln1117">  /* try parse the gpx data */</a>
<a name="ln1118">  gpx = dt_gpx_new(filename);</a>
<a name="ln1119">  if(!gpx)</a>
<a name="ln1120">  {</a>
<a name="ln1121">    dt_control_log(_(&quot;failed to parse GPX file&quot;));</a>
<a name="ln1122">    goto bail_out;</a>
<a name="ln1123">  }</a>
<a name="ln1124"> </a>
<a name="ln1125">  GTimeZone *tz_camera = (tz == NULL) ? g_time_zone_new_utc() : g_time_zone_new(tz);</a>
<a name="ln1126">  if(!tz_camera) goto bail_out;</a>
<a name="ln1127">  GTimeZone *tz_utc = g_time_zone_new_utc();</a>
<a name="ln1128"> </a>
<a name="ln1129">  dt_undo_geotag_t *geotags = g_malloc0(sizeof(dt_undo_geotag_t));</a>
<a name="ln1130"> </a>
<a name="ln1131">  /* go thru each selected image and lookup location in gpx */</a>
<a name="ln1132">  do</a>
<a name="ln1133">  {</a>
<a name="ln1134">    GTimeVal timestamp;</a>
<a name="ln1135">    GDateTime *exif_time, *utc_time;</a>
<a name="ln1136">    dt_image_geoloc_t geoloc;</a>
<a name="ln1137">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1138"> </a>
<a name="ln1139">    /* get image */</a>
<a name="ln1140">    const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1141">    if(!cimg) continue;</a>
<a name="ln1142"> </a>
<a name="ln1143">    /* convert exif datetime</a>
<a name="ln1144">       TODO: exiv2 dates should be iso8601 and we are probably doing some ugly</a>
<a name="ln1145">       conversion before inserting into database.</a>
<a name="ln1146">     */</a>
<a name="ln1147">    gint year;</a>
<a name="ln1148">    gint month;</a>
<a name="ln1149">    gint day;</a>
<a name="ln1150">    gint hour;</a>
<a name="ln1151">    gint minute;</a>
<a name="ln1152">    gint seconds;</a>
<a name="ln1153"> </a>
<a name="ln1154">    if(sscanf(cimg-&gt;exif_datetime_taken, &quot;%d:%d:%d %d:%d:%d&quot;, (int *)&amp;year, (int *)&amp;month, (int *)&amp;day,</a>
<a name="ln1155">              (int *)&amp;hour, (int *)&amp;minute, (int *)&amp;seconds) != 6)</a>
<a name="ln1156">    {</a>
<a name="ln1157">      fprintf(stderr, &quot;broken exif time in db, '%s'\n&quot;, cimg-&gt;exif_datetime_taken);</a>
<a name="ln1158">      dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1159">      continue;</a>
<a name="ln1160">    }</a>
<a name="ln1161"> </a>
<a name="ln1162">    /* release the lock */</a>
<a name="ln1163">    dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1164"> </a>
<a name="ln1165">    exif_time = g_date_time_new(tz_camera, year, month, day, hour, minute, seconds);</a>
<a name="ln1166">    if(!exif_time) continue;</a>
<a name="ln1167">    utc_time = g_date_time_to_timezone(exif_time, tz_utc);</a>
<a name="ln1168">    g_date_time_unref(exif_time);</a>
<a name="ln1169">    if(!utc_time) continue;</a>
<a name="ln1170">    gboolean res = g_date_time_to_timeval(utc_time, &amp;timestamp);</a>
<a name="ln1171">    g_date_time_unref(utc_time);</a>
<a name="ln1172">    if(!res) continue;</a>
<a name="ln1173"> </a>
<a name="ln1174">    /* only update image location if time is within gpx tack range */</a>
<a name="ln1175">    if(dt_gpx_get_location(gpx, &amp;timestamp, &amp;geoloc))</a>
<a name="ln1176">    {</a>
<a name="ln1177">      dt_image_geoloc_t *before = g_malloc0(sizeof(dt_image_geoloc_t));</a>
<a name="ln1178">      dt_image_geoloc_t *after = g_malloc0(sizeof(dt_image_geoloc_t));</a>
<a name="ln1179">      memcpy(after, &amp;geoloc, sizeof(dt_image_geoloc_t));</a>
<a name="ln1180">      dt_image_get_location(imgid, before);</a>
<a name="ln1181"> </a>
<a name="ln1182">      // first the image id and then the position</a>
<a name="ln1183">      geotags-&gt;before = g_list_append(geotags-&gt;before, GINT_TO_POINTER(imgid));</a>
<a name="ln1184">      geotags-&gt;before = g_list_append(geotags-&gt;before, (gpointer)before);</a>
<a name="ln1185">      // likewise for the new position</a>
<a name="ln1186">      geotags-&gt;after = g_list_append(geotags-&gt;after, GINT_TO_POINTER(imgid));</a>
<a name="ln1187">      geotags-&gt;after = g_list_append(geotags-&gt;after, (gpointer)after);</a>
<a name="ln1188"> </a>
<a name="ln1189">      dt_image_set_location_and_elevation(imgid, &amp;geoloc);</a>
<a name="ln1190">      cntr++;</a>
<a name="ln1191">    }</a>
<a name="ln1192"> </a>
<a name="ln1193">  } while((t = g_list_next(t)) != NULL);</a>
<a name="ln1194"> </a>
<a name="ln1195">  if(geotags-&gt;before)</a>
<a name="ln1196">  {</a>
<a name="ln1197">    dt_undo_start_group(darktable.undo, DT_UNDO_LT_GEOTAG);</a>
<a name="ln1198">    dt_undo_record(darktable.undo, NULL, DT_UNDO_LT_GEOTAG, (dt_undo_data_t)geotags, _pop_undo, _geotags_free_undo_data_t);</a>
<a name="ln1199">    dt_undo_end_group(darktable.undo);</a>
<a name="ln1200">  }</a>
<a name="ln1201"> </a>
<a name="ln1202">  dt_control_log(ngettext(&quot;applied matched GPX location onto %d image&quot;, &quot;applied matched GPX location onto %d images&quot;, cntr), cntr);</a>
<a name="ln1203"> </a>
<a name="ln1204">  g_time_zone_unref(tz_camera);</a>
<a name="ln1205">  g_time_zone_unref(tz_utc);</a>
<a name="ln1206">  dt_gpx_destroy(gpx);</a>
<a name="ln1207">  return 0;</a>
<a name="ln1208"> </a>
<a name="ln1209">bail_out:</a>
<a name="ln1210">  if(gpx) dt_gpx_destroy(gpx);</a>
<a name="ln1211"> </a>
<a name="ln1212">  return 1;</a>
<a name="ln1213">}</a>
<a name="ln1214"> </a>
<a name="ln1215">static int32_t dt_control_move_images_job_run(dt_job_t *job)</a>
<a name="ln1216">{</a>
<a name="ln1217">  return _generic_dt_control_fileop_images_job_run(job, &amp;dt_image_move, _(&quot;moving %d image&quot;),</a>
<a name="ln1218">                                                   _(&quot;moving %d images&quot;));</a>
<a name="ln1219">}</a>
<a name="ln1220"> </a>
<a name="ln1221">static int32_t dt_control_copy_images_job_run(dt_job_t *job)</a>
<a name="ln1222">{</a>
<a name="ln1223">  return _generic_dt_control_fileop_images_job_run(job, &amp;dt_image_copy, _(&quot;copying %d image&quot;),</a>
<a name="ln1224">                                                   _(&quot;copying %d images&quot;));</a>
<a name="ln1225">}</a>
<a name="ln1226"> </a>
<a name="ln1227">static int32_t dt_control_local_copy_images_job_run(dt_job_t *job)</a>
<a name="ln1228">{</a>
<a name="ln1229">  int imgid = -1;</a>
<a name="ln1230">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1231">  GList *t = params-&gt;index;</a>
<a name="ln1232">  guint tagid = 0;</a>
<a name="ln1233">  const guint total = g_list_length(t);</a>
<a name="ln1234">  double fraction = 0;</a>
<a name="ln1235">  const gboolean is_copy = params-&gt;flag == 1;</a>
<a name="ln1236">  char message[512] = { 0 };</a>
<a name="ln1237"> </a>
<a name="ln1238">  if(is_copy)</a>
<a name="ln1239">    snprintf(message, sizeof(message),</a>
<a name="ln1240">             ngettext(&quot;creating local copy of %d image&quot;, &quot;creating local copies of %d images&quot;, total), total);</a>
<a name="ln1241">  else</a>
<a name="ln1242">    snprintf(message, sizeof(message),</a>
<a name="ln1243">             ngettext(&quot;removing local copy of %d image&quot;, &quot;removing local copies of %d images&quot;, total), total);</a>
<a name="ln1244"> </a>
<a name="ln1245">  dt_control_log(&quot;%s&quot;, message);</a>
<a name="ln1246">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1247"> </a>
<a name="ln1248">  dt_tag_new(&quot;darktable|local-copy&quot;, &amp;tagid);</a>
<a name="ln1249"> </a>
<a name="ln1250">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln1251">  {</a>
<a name="ln1252">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1253">    if(is_copy)</a>
<a name="ln1254">    {</a>
<a name="ln1255">      if (dt_image_local_copy_set(imgid) == 0)</a>
<a name="ln1256">        dt_tag_attach(tagid, imgid);</a>
<a name="ln1257">    }</a>
<a name="ln1258">    else</a>
<a name="ln1259">    {</a>
<a name="ln1260">      if (dt_image_local_copy_reset(imgid) == 0)</a>
<a name="ln1261">        dt_tag_detach(tagid, imgid);</a>
<a name="ln1262">    }</a>
<a name="ln1263">    t = g_list_delete_link(t, t);</a>
<a name="ln1264"> </a>
<a name="ln1265">    fraction += 1.0 / total;</a>
<a name="ln1266">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1267">  }</a>
<a name="ln1268">  params-&gt;index = NULL;</a>
<a name="ln1269"> </a>
<a name="ln1270">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln1271">  return 0;</a>
<a name="ln1272">}</a>
<a name="ln1273"> </a>
<a name="ln1274">static int32_t dt_control_export_job_run(dt_job_t *job)</a>
<a name="ln1275">{</a>
<a name="ln1276">  int imgid = -1;</a>
<a name="ln1277">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1278">  dt_control_export_t *settings = (dt_control_export_t *)params-&gt;data;</a>
<a name="ln1279">  GList *t = params-&gt;index;</a>
<a name="ln1280">  dt_imageio_module_format_t *mformat = dt_imageio_get_format_by_index(settings-&gt;format_index);</a>
<a name="ln1281">  g_assert(mformat);</a>
<a name="ln1282">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(settings-&gt;storage_index);</a>
<a name="ln1283">  g_assert(mstorage);</a>
<a name="ln1284">  dt_imageio_module_data_t *sdata = settings-&gt;sdata;</a>
<a name="ln1285"> </a>
<a name="ln1286">  // get a thread-safe fdata struct (one jpeg struct per thread etc):</a>
<a name="ln1287">  dt_imageio_module_data_t *fdata = mformat-&gt;get_params(mformat);</a>
<a name="ln1288"> </a>
<a name="ln1289">  if(mstorage-&gt;initialize_store)</a>
<a name="ln1290">  {</a>
<a name="ln1291">    if(mstorage-&gt;initialize_store(mstorage, sdata, &amp;mformat, &amp;fdata, &amp;t, settings-&gt;high_quality, settings-&gt;upscale))</a>
<a name="ln1292">    {</a>
<a name="ln1293">      // bail out, something went wrong</a>
<a name="ln1294">      goto end;</a>
<a name="ln1295">    }</a>
<a name="ln1296">    mformat-&gt;set_params(mformat, fdata, mformat-&gt;params_size(mformat));</a>
<a name="ln1297">    mstorage-&gt;set_params(mstorage, sdata, mstorage-&gt;params_size(mstorage));</a>
<a name="ln1298">  }</a>
<a name="ln1299"> </a>
<a name="ln1300">  // Get max dimensions...</a>
<a name="ln1301">  uint32_t w, h, fw, fh, sw, sh;</a>
<a name="ln1302">  fw = fh = sw = sh = 0;</a>
<a name="ln1303">  mstorage-&gt;dimension(mstorage, sdata, &amp;sw, &amp;sh);</a>
<a name="ln1304">  mformat-&gt;dimension(mformat, fdata, &amp;fw, &amp;fh);</a>
<a name="ln1305"> </a>
<a name="ln1306">  if(sw == 0 || fw == 0)</a>
<a name="ln1307">    w = sw &gt; fw ? sw : fw;</a>
<a name="ln1308">  else</a>
<a name="ln1309">    w = sw &lt; fw ? sw : fw;</a>
<a name="ln1310"> </a>
<a name="ln1311">  if(sh == 0 || fh == 0)</a>
<a name="ln1312">    h = sh &gt; fh ? sh : fh;</a>
<a name="ln1313">  else</a>
<a name="ln1314">    h = sh &lt; fh ? sh : fh;</a>
<a name="ln1315"> </a>
<a name="ln1316">  const guint total = g_list_length(t);</a>
<a name="ln1317">  dt_control_log(ngettext(&quot;exporting %d image..&quot;, &quot;exporting %d images..&quot;, total), total);</a>
<a name="ln1318">  char message[512] = { 0 };</a>
<a name="ln1319">  snprintf(message, sizeof(message), ngettext(&quot;exporting %d image to %s&quot;, &quot;exporting %d images to %s&quot;, total),</a>
<a name="ln1320">           total, mstorage-&gt;name(mstorage));</a>
<a name="ln1321">  // update the message. initialize_store() might have changed the number of images</a>
<a name="ln1322">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1323"> </a>
<a name="ln1324">  double fraction = 0;</a>
<a name="ln1325"> </a>
<a name="ln1326">  // set up the fdata struct</a>
<a name="ln1327">  fdata-&gt;max_width = (settings-&gt;max_width != 0 &amp;&amp; w != 0) ? MIN(w, settings-&gt;max_width) : MAX(w, settings-&gt;max_width);</a>
<a name="ln1328">  fdata-&gt;max_height = (settings-&gt;max_height != 0 &amp;&amp; h != 0) ? MIN(h, settings-&gt;max_height) : MAX(h, settings-&gt;max_height);</a>
<a name="ln1329">  g_strlcpy(fdata-&gt;style, settings-&gt;style, sizeof(fdata-&gt;style));</a>
<a name="ln1330">  fdata-&gt;style_append = settings-&gt;style_append;</a>
<a name="ln1331">  guint num = 0;</a>
<a name="ln1332">  // Invariant: the tagid for 'darktable|changed' will not change while this function runs. Is this a</a>
<a name="ln1333">  // sensible assumption?</a>
<a name="ln1334">  guint tagid = 0, etagid = 0;</a>
<a name="ln1335">  dt_tag_new(&quot;darktable|changed&quot;, &amp;tagid);</a>
<a name="ln1336">  dt_tag_new(&quot;darktable|exported&quot;, &amp;etagid);</a>
<a name="ln1337"> </a>
<a name="ln1338">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln1339">  {</a>
<a name="ln1340">    if(!t)</a>
<a name="ln1341">      imgid = 0;</a>
<a name="ln1342">    else</a>
<a name="ln1343">    {</a>
<a name="ln1344">      imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1345">      t = g_list_delete_link(t, t);</a>
<a name="ln1346">      num = total - g_list_length(t);</a>
<a name="ln1347">    }</a>
<a name="ln1348"> </a>
<a name="ln1349">    // remove 'changed' tag from image</a>
<a name="ln1350">    dt_tag_detach(tagid, imgid);</a>
<a name="ln1351">    // make sure the 'exported' tag is set on the image</a>
<a name="ln1352">    dt_tag_attach(etagid, imgid);</a>
<a name="ln1353">    // check if image still exists:</a>
<a name="ln1354">    char imgfilename[PATH_MAX] = { 0 };</a>
<a name="ln1355">    const dt_image_t *image = dt_image_cache_get(darktable.image_cache, (int32_t)imgid, 'r');</a>
<a name="ln1356">    if(image)</a>
<a name="ln1357">    {</a>
<a name="ln1358">      gboolean from_cache = TRUE;</a>
<a name="ln1359">      dt_image_full_path(image-&gt;id, imgfilename, sizeof(imgfilename), &amp;from_cache);</a>
<a name="ln1360">      if(!g_file_test(imgfilename, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln1361">      {</a>
<a name="ln1362">        dt_control_log(_(&quot;image `%s' is currently unavailable&quot;), image-&gt;filename);</a>
<a name="ln1363">        fprintf(stderr, &quot;image `%s' is currently unavailable\n&quot;, imgfilename);</a>
<a name="ln1364">        // dt_image_remove(imgid);</a>
<a name="ln1365">        dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1366">      }</a>
<a name="ln1367">      else</a>
<a name="ln1368">      {</a>
<a name="ln1369">        dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1370">        if(mstorage-&gt;store(mstorage, sdata, imgid, mformat, fdata, num, total, settings-&gt;high_quality, settings-&gt;upscale,</a>
<a name="ln1371">                           settings-&gt;icc_type, settings-&gt;icc_filename, settings-&gt;icc_intent) != 0)</a>
<a name="ln1372">          dt_control_job_cancel(job);</a>
<a name="ln1373">      }</a>
<a name="ln1374">    }</a>
<a name="ln1375"> </a>
<a name="ln1376">    fraction += 1.0 / total;</a>
<a name="ln1377">    if(fraction &gt; 1.0) fraction = 1.0;</a>
<a name="ln1378">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1379">  }</a>
<a name="ln1380">  params-&gt;index = NULL;</a>
<a name="ln1381"> </a>
<a name="ln1382">  if(mstorage-&gt;finalize_store) mstorage-&gt;finalize_store(mstorage, sdata);</a>
<a name="ln1383"> </a>
<a name="ln1384">end:</a>
<a name="ln1385">  // all threads free their fdata</a>
<a name="ln1386">  mformat-&gt;free_params(mformat, fdata);</a>
<a name="ln1387"> </a>
<a name="ln1388">  // notify the user via the window manager</a>
<a name="ln1389">  dt_ui_notify_user();</a>
<a name="ln1390"> </a>
<a name="ln1391">  return 0;</a>
<a name="ln1392">}</a>
<a name="ln1393"> </a>
<a name="ln1394">static dt_control_image_enumerator_t *dt_control_gpx_apply_alloc()</a>
<a name="ln1395">{</a>
<a name="ln1396">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1397">  if(!params) return NULL;</a>
<a name="ln1398"> </a>
<a name="ln1399">  params-&gt;data = calloc(1, sizeof(dt_control_gpx_apply_t));</a>
<a name="ln1400">  if(!params-&gt;data)</a>
<a name="ln1401">  {</a>
<a name="ln1402">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1403">    return NULL;</a>
<a name="ln1404">  }</a>
<a name="ln1405"> </a>
<a name="ln1406">  return params;</a>
<a name="ln1407">}</a>
<a name="ln1408"> </a>
<a name="ln1409">static void dt_control_gpx_apply_job_cleanup(void *p)</a>
<a name="ln1410">{</a>
<a name="ln1411">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln1412"> </a>
<a name="ln1413">  dt_control_gpx_apply_t *data = params-&gt;data;</a>
<a name="ln1414">  g_free(data-&gt;filename);</a>
<a name="ln1415">  g_free(data-&gt;tz);</a>
<a name="ln1416"> </a>
<a name="ln1417">  free(data);</a>
<a name="ln1418"> </a>
<a name="ln1419">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1420">}</a>
<a name="ln1421"> </a>
<a name="ln1422">static dt_job_t *dt_control_gpx_apply_job_create(const gchar *filename, int32_t filmid, const gchar *tz)</a>
<a name="ln1423">{</a>
<a name="ln1424">  dt_job_t *job = dt_control_job_create(&amp;dt_control_gpx_apply_job_run, &quot;gpx apply&quot;);</a>
<a name="ln1425">  if(!job) return NULL;</a>
<a name="ln1426">  dt_control_image_enumerator_t *params = dt_control_gpx_apply_alloc();</a>
<a name="ln1427">  if(!params)</a>
<a name="ln1428">  {</a>
<a name="ln1429">    dt_control_job_dispose(job);</a>
<a name="ln1430">    return NULL;</a>
<a name="ln1431">  }</a>
<a name="ln1432">  dt_control_job_set_params(job, params, dt_control_gpx_apply_job_cleanup);</a>
<a name="ln1433"> </a>
<a name="ln1434">  if(filmid != -1)</a>
<a name="ln1435">    dt_control_image_enumerator_job_film_init(params, filmid);</a>
<a name="ln1436">  else</a>
<a name="ln1437">    dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln1438"> </a>
<a name="ln1439">  dt_control_gpx_apply_t *data = params-&gt;data;</a>
<a name="ln1440">  data-&gt;filename = g_strdup(filename);</a>
<a name="ln1441">  data-&gt;tz = g_strdup(tz);</a>
<a name="ln1442"> </a>
<a name="ln1443">  return job;</a>
<a name="ln1444">}</a>
<a name="ln1445"> </a>
<a name="ln1446">void dt_control_merge_hdr()</a>
<a name="ln1447">{</a>
<a name="ln1448">  dt_control_add_job(</a>
<a name="ln1449">      darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1450">      dt_control_generic_images_job_create(&amp;dt_control_merge_hdr_job_run, N_(&quot;merge hdr image&quot;), 0, NULL,</a>
<a name="ln1451">                                           PROGRESS_CANCELLABLE));</a>
<a name="ln1452">}</a>
<a name="ln1453"> </a>
<a name="ln1454">void dt_control_gpx_apply(const gchar *filename, int32_t filmid, const gchar *tz)</a>
<a name="ln1455">{</a>
<a name="ln1456">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1457">                     dt_control_gpx_apply_job_create(filename, filmid, tz));</a>
<a name="ln1458">}</a>
<a name="ln1459"> </a>
<a name="ln1460">void dt_control_duplicate_images()</a>
<a name="ln1461">{</a>
<a name="ln1462">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1463">                     dt_control_generic_images_job_create(&amp;dt_control_duplicate_images_job_run,</a>
<a name="ln1464">                                                          N_(&quot;duplicate images&quot;), 0, NULL, PROGRESS_SIMPLE));</a>
<a name="ln1465">}</a>
<a name="ln1466"> </a>
<a name="ln1467">void dt_control_flip_images(const int32_t cw)</a>
<a name="ln1468">{</a>
<a name="ln1469">  dt_control_add_job(</a>
<a name="ln1470">      darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1471">      dt_control_generic_images_job_create(&amp;dt_control_flip_images_job_run, N_(&quot;flip images&quot;), cw, NULL,</a>
<a name="ln1472">                                           PROGRESS_SIMPLE));</a>
<a name="ln1473">}</a>
<a name="ln1474"> </a>
<a name="ln1475">gboolean dt_control_remove_images()</a>
<a name="ln1476">{</a>
<a name="ln1477">  // get all selected images now, to avoid the set changing during ui interaction</a>
<a name="ln1478">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_remove_images_job_run, N_(&quot;remove images&quot;), 0, NULL,</a>
<a name="ln1479">                                                       PROGRESS_SIMPLE);</a>
<a name="ln1480">  if(dt_conf_get_bool(&quot;ask_before_remove&quot;))</a>
<a name="ln1481">  {</a>
<a name="ln1482">    GtkWidget *dialog;</a>
<a name="ln1483">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1484"> </a>
<a name="ln1485">    int number;</a>
<a name="ln1486">    if (dt_view_get_image_to_act_on() != -1)</a>
<a name="ln1487">      number = 1;</a>
<a name="ln1488">    else</a>
<a name="ln1489">      number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1490"> </a>
<a name="ln1491">    // Do not show the dialog if no image is selected:</a>
<a name="ln1492">    if(number == 0)</a>
<a name="ln1493">    {</a>
<a name="ln1494">      dt_control_job_dispose(job);</a>
<a name="ln1495">      return TRUE;</a>
<a name="ln1496">    }</a>
<a name="ln1497"> </a>
<a name="ln1498">    dialog = gtk_message_dialog_new(</a>
<a name="ln1499">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1500">        ngettext(&quot;do you really want to remove %d selected image from the collection?&quot;,</a>
<a name="ln1501">                 &quot;do you really want to remove %d selected images from the collection?&quot;, number),</a>
<a name="ln1502">        number);</a>
<a name="ln1503">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1504">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1505">#endif</a>
<a name="ln1506"> </a>
<a name="ln1507">    gtk_window_set_title(GTK_WINDOW(dialog), _(&quot;remove images?&quot;));</a>
<a name="ln1508">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1509">    gtk_widget_destroy(dialog);</a>
<a name="ln1510">    if(res != GTK_RESPONSE_YES)</a>
<a name="ln1511">    {</a>
<a name="ln1512">      dt_control_job_dispose(job);</a>
<a name="ln1513">      return FALSE;</a>
<a name="ln1514">    }</a>
<a name="ln1515">  }</a>
<a name="ln1516">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1517">  return TRUE;</a>
<a name="ln1518">}</a>
<a name="ln1519"> </a>
<a name="ln1520">void dt_control_delete_images()</a>
<a name="ln1521">{</a>
<a name="ln1522">  // first get all selected images, to avoid the set changing during ui interaction</a>
<a name="ln1523">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_delete_images_job_run, N_(&quot;delete images&quot;), 0, NULL,</a>
<a name="ln1524">                                                       PROGRESS_SIMPLE);</a>
<a name="ln1525">  int send_to_trash = dt_conf_get_bool(&quot;send_to_trash&quot;);</a>
<a name="ln1526">  if(dt_conf_get_bool(&quot;ask_before_delete&quot;))</a>
<a name="ln1527">  {</a>
<a name="ln1528">    GtkWidget *dialog;</a>
<a name="ln1529">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1530"> </a>
<a name="ln1531">    int number;</a>
<a name="ln1532">    if (dt_view_get_image_to_act_on() != -1)</a>
<a name="ln1533">      number = 1;</a>
<a name="ln1534">    else</a>
<a name="ln1535">      number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1536"> </a>
<a name="ln1537">    // Do not show the dialog if no image is selected:</a>
<a name="ln1538">    if(number == 0)</a>
<a name="ln1539">    {</a>
<a name="ln1540">      dt_control_job_dispose(job);</a>
<a name="ln1541">      return;</a>
<a name="ln1542">    }</a>
<a name="ln1543"> </a>
<a name="ln1544">    dialog = gtk_message_dialog_new(</a>
<a name="ln1545">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1546">        send_to_trash</a>
<a name="ln1547">        ? ngettext(&quot;do you really want to send %d selected image to trash?&quot;,</a>
<a name="ln1548">          &quot;do you really want to send %d selected images to trash?&quot;, number)</a>
<a name="ln1549">        : ngettext(&quot;do you really want to physically delete %d selected image from disk?&quot;,</a>
<a name="ln1550">          &quot;do you really want to physically delete %d selected images from disk?&quot;, number),</a>
<a name="ln1551">        number);</a>
<a name="ln1552">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1553">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1554">#endif</a>
<a name="ln1555"> </a>
<a name="ln1556">    gtk_window_set_title(GTK_WINDOW(dialog), send_to_trash ? _(&quot;trash images?&quot;) : _(&quot;delete images?&quot;));</a>
<a name="ln1557">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1558">    gtk_widget_destroy(dialog);</a>
<a name="ln1559">    if(res != GTK_RESPONSE_YES)</a>
<a name="ln1560">    {</a>
<a name="ln1561">      dt_control_job_dispose(job);</a>
<a name="ln1562">      return;</a>
<a name="ln1563">    }</a>
<a name="ln1564">  }</a>
<a name="ln1565">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1566">}</a>
<a name="ln1567"> </a>
<a name="ln1568">void dt_control_move_images()</a>
<a name="ln1569">{</a>
<a name="ln1570">  // Open file chooser dialog</a>
<a name="ln1571">  gchar *dir = NULL;</a>
<a name="ln1572">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1573">  int number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1574"> </a>
<a name="ln1575">  // Do not show the dialog if no image is selected:</a>
<a name="ln1576">  if(number == 0) return;</a>
<a name="ln1577">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_move_images_job_run, N_(&quot;move images&quot;), 0, dir,</a>
<a name="ln1578">                                                       PROGRESS_CANCELLABLE);</a>
<a name="ln1579"> </a>
<a name="ln1580">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1581">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1582">      GTK_RESPONSE_CANCEL, _(&quot;_select as destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1583">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1584">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1585">#endif</a>
<a name="ln1586"> </a>
<a name="ln1587">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln1588">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1589">  {</a>
<a name="ln1590">    dir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1591">  }</a>
<a name="ln1592">  gtk_widget_destroy(filechooser);</a>
<a name="ln1593"> </a>
<a name="ln1594">  if(!dir || !g_file_test(dir, G_FILE_TEST_IS_DIR)) goto abort;</a>
<a name="ln1595"> </a>
<a name="ln1596">  // ugly, but we need to set this after constructing the job:</a>
<a name="ln1597">  ((dt_control_image_enumerator_t *)dt_control_job_get_params(job))-&gt;data = dir;</a>
<a name="ln1598"> </a>
<a name="ln1599">  if(dt_conf_get_bool(&quot;ask_before_move&quot;))</a>
<a name="ln1600">  {</a>
<a name="ln1601">    GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln1602">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1603">        ngettext(&quot;do you really want to physically move the %d selected image to %s?\n&quot;</a>
<a name="ln1604">                 &quot;(all unselected duplicates will be moved along)&quot;,</a>
<a name="ln1605">                 &quot;do you really want to physically move %d selected images to %s?\n&quot;</a>
<a name="ln1606">                 &quot;(all unselected duplicates will be moved along)&quot;,</a>
<a name="ln1607">                 number),</a>
<a name="ln1608">        number, dir);</a>
<a name="ln1609">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1610">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1611">#endif</a>
<a name="ln1612">    gtk_window_set_title(GTK_WINDOW(dialog), ngettext(&quot;move image?&quot;, &quot;move images?&quot;, number));</a>
<a name="ln1613"> </a>
<a name="ln1614">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1615">    gtk_widget_destroy(dialog);</a>
<a name="ln1616"> </a>
<a name="ln1617">    if(res != GTK_RESPONSE_YES) goto abort;</a>
<a name="ln1618">  }</a>
<a name="ln1619"> </a>
<a name="ln1620">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1621">  return;</a>
<a name="ln1622"> </a>
<a name="ln1623">abort:</a>
<a name="ln1624">  g_free(dir);</a>
<a name="ln1625">  dt_control_job_dispose(job);</a>
<a name="ln1626">}</a>
<a name="ln1627"> </a>
<a name="ln1628">void dt_control_copy_images()</a>
<a name="ln1629">{</a>
<a name="ln1630">  // Open file chooser dialog</a>
<a name="ln1631">  gchar *dir = NULL;</a>
<a name="ln1632">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1633">  int number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1634"> </a>
<a name="ln1635">  // Do not show the dialog if no image is selected:</a>
<a name="ln1636">  if(number == 0) return;</a>
<a name="ln1637">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_copy_images_job_run, N_(&quot;copy images&quot;), 0, dir,</a>
<a name="ln1638">                                                       PROGRESS_CANCELLABLE);</a>
<a name="ln1639"> </a>
<a name="ln1640">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1641">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1642">      GTK_RESPONSE_CANCEL, _(&quot;_select as destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1643">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1644">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1645">#endif</a>
<a name="ln1646"> </a>
<a name="ln1647">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln1648">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1649">  {</a>
<a name="ln1650">    dir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1651">  }</a>
<a name="ln1652">  gtk_widget_destroy(filechooser);</a>
<a name="ln1653"> </a>
<a name="ln1654">  if(!dir || !g_file_test(dir, G_FILE_TEST_IS_DIR)) goto abort;</a>
<a name="ln1655"> </a>
<a name="ln1656">  // ugly, but we need to set this after constructing the job:</a>
<a name="ln1657">  ((dt_control_image_enumerator_t *)dt_control_job_get_params(job))-&gt;data = dir;</a>
<a name="ln1658"> </a>
<a name="ln1659">  if(dt_conf_get_bool(&quot;ask_before_copy&quot;))</a>
<a name="ln1660">  {</a>
<a name="ln1661">    GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln1662">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1663">        ngettext(&quot;do you really want to physically copy the %d selected image to %s?&quot;,</a>
<a name="ln1664">                 &quot;do you really want to physically copy %d selected images to %s?&quot;, number),</a>
<a name="ln1665">        number, dir);</a>
<a name="ln1666">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1667">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1668">#endif</a>
<a name="ln1669">    gtk_window_set_title(GTK_WINDOW(dialog), ngettext(&quot;copy image?&quot;, &quot;copy images?&quot;, number));</a>
<a name="ln1670"> </a>
<a name="ln1671">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1672">    gtk_widget_destroy(dialog);</a>
<a name="ln1673"> </a>
<a name="ln1674">    if(res != GTK_RESPONSE_YES) goto abort;</a>
<a name="ln1675">  }</a>
<a name="ln1676"> </a>
<a name="ln1677">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1678">  return;</a>
<a name="ln1679"> </a>
<a name="ln1680">abort:</a>
<a name="ln1681">  g_free(dir);</a>
<a name="ln1682">  dt_control_job_dispose(job);</a>
<a name="ln1683">}</a>
<a name="ln1684"> </a>
<a name="ln1685">void dt_control_set_local_copy_images()</a>
<a name="ln1686">{</a>
<a name="ln1687">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1688">                     dt_control_generic_images_job_create(&amp;dt_control_local_copy_images_job_run,</a>
<a name="ln1689">                                                          N_(&quot;local copy images&quot;), 1, NULL, PROGRESS_CANCELLABLE));</a>
<a name="ln1690">}</a>
<a name="ln1691"> </a>
<a name="ln1692">void dt_control_reset_local_copy_images()</a>
<a name="ln1693">{</a>
<a name="ln1694">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1695">                     dt_control_generic_images_job_create(&amp;dt_control_local_copy_images_job_run,</a>
<a name="ln1696">                                                          N_(&quot;local copy images&quot;), 0, NULL, PROGRESS_CANCELLABLE));</a>
<a name="ln1697">}</a>
<a name="ln1698"> </a>
<a name="ln1699">static dt_control_image_enumerator_t *dt_control_export_alloc()</a>
<a name="ln1700">{</a>
<a name="ln1701">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1702">  if(!params) return NULL;</a>
<a name="ln1703"> </a>
<a name="ln1704">  params-&gt;data = calloc(1, sizeof(dt_control_export_t));</a>
<a name="ln1705">  if(!params-&gt;data)</a>
<a name="ln1706">  {</a>
<a name="ln1707">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1708">    return NULL;</a>
<a name="ln1709">  }</a>
<a name="ln1710"> </a>
<a name="ln1711">  return params;</a>
<a name="ln1712">}</a>
<a name="ln1713"> </a>
<a name="ln1714">static void dt_control_export_cleanup(void *p)</a>
<a name="ln1715">{</a>
<a name="ln1716">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln1717"> </a>
<a name="ln1718">  dt_control_export_t *settings = (dt_control_export_t *)params-&gt;data;</a>
<a name="ln1719">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(settings-&gt;storage_index);</a>
<a name="ln1720">  dt_imageio_module_data_t *sdata = settings-&gt;sdata;</a>
<a name="ln1721"> </a>
<a name="ln1722">  mstorage-&gt;free_params(mstorage, sdata);</a>
<a name="ln1723"> </a>
<a name="ln1724">  g_free(settings-&gt;icc_filename);</a>
<a name="ln1725">  free(params-&gt;data);</a>
<a name="ln1726"> </a>
<a name="ln1727">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730">void dt_control_export(GList *imgid_list, int max_width, int max_height, int format_index, int storage_index,</a>
<a name="ln1731">                       gboolean high_quality, gboolean upscale, char *style, gboolean style_append,</a>
<a name="ln1732">                       dt_colorspaces_color_profile_type_t icc_type, const gchar *icc_filename,</a>
<a name="ln1733">                       dt_iop_color_intent_t icc_intent)</a>
<a name="ln1734">{</a>
<a name="ln1735">  dt_job_t *job = dt_control_job_create(&amp;dt_control_export_job_run, &quot;export&quot;);</a>
<a name="ln1736">  if(!job) return;</a>
<a name="ln1737">  dt_control_image_enumerator_t *params = dt_control_export_alloc();</a>
<a name="ln1738">  if(!params)</a>
<a name="ln1739">  {</a>
<a name="ln1740">    dt_control_job_dispose(job);</a>
<a name="ln1741">    return;</a>
<a name="ln1742">  }</a>
<a name="ln1743">  dt_control_job_set_params(job, params, dt_control_export_cleanup);</a>
<a name="ln1744"> </a>
<a name="ln1745">  params-&gt;index = imgid_list;</a>
<a name="ln1746"> </a>
<a name="ln1747">  dt_control_export_t *data = params-&gt;data;</a>
<a name="ln1748">  data-&gt;max_width = max_width;</a>
<a name="ln1749">  data-&gt;max_height = max_height;</a>
<a name="ln1750">  data-&gt;format_index = format_index;</a>
<a name="ln1751">  data-&gt;storage_index = storage_index;</a>
<a name="ln1752">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(storage_index);</a>
<a name="ln1753">  g_assert(mstorage);</a>
<a name="ln1754">  // get shared storage param struct (global sequence counter, one picasa connection etc)</a>
<a name="ln1755">  dt_imageio_module_data_t *sdata = mstorage-&gt;get_params(mstorage);</a>
<a name="ln1756">  if(sdata == NULL)</a>
<a name="ln1757">  {</a>
<a name="ln1758">    dt_control_log(_(&quot;failed to get parameters from storage module `%s', aborting export..&quot;),</a>
<a name="ln1759">                   mstorage-&gt;name(mstorage));</a>
<a name="ln1760">    dt_control_job_dispose(job);</a>
<a name="ln1761">    return;</a>
<a name="ln1762">  }</a>
<a name="ln1763">  data-&gt;sdata = sdata;</a>
<a name="ln1764">  data-&gt;high_quality = high_quality;</a>
<a name="ln1765">  data-&gt;upscale = upscale;</a>
<a name="ln1766">  g_strlcpy(data-&gt;style, style, sizeof(data-&gt;style));</a>
<a name="ln1767">  data-&gt;style_append = style_append;</a>
<a name="ln1768">  data-&gt;icc_type = icc_type;</a>
<a name="ln1769">  data-&gt;icc_filename = g_strdup(icc_filename);</a>
<a name="ln1770">  data-&gt;icc_intent = icc_intent;</a>
<a name="ln1771"> </a>
<a name="ln1772">  dt_control_job_add_progress(job, _(&quot;export images&quot;), TRUE);</a>
<a name="ln1773">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_EXPORT, job);</a>
<a name="ln1774"> </a>
<a name="ln1775">  // tell the storage that we got its params for an export so it can reset itself to a safe state</a>
<a name="ln1776">  mstorage-&gt;export_dispatched(mstorage);</a>
<a name="ln1777">}</a>
<a name="ln1778"> </a>
<a name="ln1779">static int32_t dt_control_time_offset_job_run(dt_job_t *job)</a>
<a name="ln1780">{</a>
<a name="ln1781">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1782">  uint32_t cntr = 0;</a>
<a name="ln1783">  double fraction = 0.0;</a>
<a name="ln1784">  GList *t = params-&gt;index;</a>
<a name="ln1785">  const long int offset = ((dt_control_time_offset_t *)params-&gt;data)-&gt;offset;</a>
<a name="ln1786">  char message[512] = { 0 };</a>
<a name="ln1787"> </a>
<a name="ln1788">  /* do we have any selected images and is offset != 0 */</a>
<a name="ln1789">  if(!t || offset == 0)</a>
<a name="ln1790">  {</a>
<a name="ln1791">    return 1;</a>
<a name="ln1792">  }</a>
<a name="ln1793"> </a>
<a name="ln1794">  const guint total = g_list_length(t);</a>
<a name="ln1795"> </a>
<a name="ln1796">  snprintf(message, sizeof(message),</a>
<a name="ln1797">           ngettext(&quot;adding time offset to %d image&quot;, &quot;adding time offset to %d images&quot;, total), total);</a>
<a name="ln1798">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1799"> </a>
<a name="ln1800">  /* go thru each selected image and update datetime_taken */</a>
<a name="ln1801">  do</a>
<a name="ln1802">  {</a>
<a name="ln1803">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1804"> </a>
<a name="ln1805">    dt_image_add_time_offset(imgid, offset);</a>
<a name="ln1806">    cntr++;</a>
<a name="ln1807"> </a>
<a name="ln1808">    fraction = MAX(fraction, (1.0 * cntr) / total);</a>
<a name="ln1809">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1810">  } while((t = g_list_next(t)) != NULL);</a>
<a name="ln1811"> </a>
<a name="ln1812">  dt_control_log(ngettext(&quot;added time offset to %d image&quot;, &quot;added time offset to %d images&quot;, cntr), cntr);</a>
<a name="ln1813"> </a>
<a name="ln1814">  return 0;</a>
<a name="ln1815">}</a>
<a name="ln1816"> </a>
<a name="ln1817">static void *dt_control_time_offset_alloc()</a>
<a name="ln1818">{</a>
<a name="ln1819">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1820">  if(!params) return NULL;</a>
<a name="ln1821"> </a>
<a name="ln1822">  params-&gt;data = calloc(1, sizeof(dt_control_time_offset_t));</a>
<a name="ln1823">  if(!params-&gt;data)</a>
<a name="ln1824">  {</a>
<a name="ln1825">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1826">    return NULL;</a>
<a name="ln1827">  }</a>
<a name="ln1828"> </a>
<a name="ln1829">  return params;</a>
<a name="ln1830">}</a>
<a name="ln1831"> </a>
<a name="ln1832">static void dt_control_time_offset_job_cleanup(void *p)</a>
<a name="ln1833">{</a>
<a name="ln1834">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)p;</a>
<a name="ln1835"> </a>
<a name="ln1836">  free(params-&gt;data);</a>
<a name="ln1837"> </a>
<a name="ln1838">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1839">}</a>
<a name="ln1840"> </a>
<a name="ln1841">static dt_job_t *dt_control_time_offset_job_create(const long int offset, int imgid)</a>
<a name="ln1842">{</a>
<a name="ln1843">  dt_job_t *job = dt_control_job_create(&amp;dt_control_time_offset_job_run, &quot;time offset&quot;);</a>
<a name="ln1844">  if(!job) return NULL;</a>
<a name="ln1845">  dt_control_image_enumerator_t *params = dt_control_time_offset_alloc();</a>
<a name="ln1846">  if(!params)</a>
<a name="ln1847">  {</a>
<a name="ln1848">    dt_control_job_dispose(job);</a>
<a name="ln1849">    return NULL;</a>
<a name="ln1850">  }</a>
<a name="ln1851">  dt_control_job_add_progress(job, _(&quot;time offset&quot;), FALSE);</a>
<a name="ln1852">  dt_control_job_set_params(job, params, dt_control_time_offset_job_cleanup);</a>
<a name="ln1853"> </a>
<a name="ln1854">  if(imgid != -1)</a>
<a name="ln1855">    params-&gt;index = g_list_append(params-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln1856">  else</a>
<a name="ln1857">    dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln1858"> </a>
<a name="ln1859">  dt_control_time_offset_t *data = params-&gt;data;</a>
<a name="ln1860">  data-&gt;offset = offset;</a>
<a name="ln1861">  params-&gt;data = data;</a>
<a name="ln1862">  return job;</a>
<a name="ln1863">}</a>
<a name="ln1864"> </a>
<a name="ln1865">void dt_control_time_offset(const long int offset, int imgid)</a>
<a name="ln1866">{</a>
<a name="ln1867">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1868">                     dt_control_time_offset_job_create(offset, imgid));</a>
<a name="ln1869">}</a>
<a name="ln1870"> </a>
<a name="ln1871">void dt_control_write_sidecar_files()</a>
<a name="ln1872">{</a>
<a name="ln1873">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1874">                     dt_control_generic_images_job_create(&amp;dt_control_write_sidecar_files_job_run,</a>
<a name="ln1875">                                                          N_(&quot;write sidecar files&quot;), 0, NULL, PROGRESS_NONE));</a>
<a name="ln1876">}</a>
<a name="ln1877"> </a>
<a name="ln1878">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1879">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1880">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="586"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'buffer'. Check lines: 586, 582.</p></div>
<div class="balloon" rel="1055"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="1340"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!t' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
