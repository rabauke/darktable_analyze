
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011-2014 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/debug.h&quot;</a>
<a name="ln22">#include &quot;common/exif.h&quot;</a>
<a name="ln23">#include &quot;common/grealpath.h&quot;</a>
<a name="ln24">#include &quot;common/image_cache.h&quot;</a>
<a name="ln25">#include &quot;common/imageio.h&quot;</a>
<a name="ln26">#include &quot;common/imageio_jpeg.h&quot;</a>
<a name="ln27">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln28">#include &quot;control/conf.h&quot;</a>
<a name="ln29">#include &quot;control/jobs.h&quot;</a>
<a name="ln30">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;assert.h&gt;</a>
<a name="ln33">#include &lt;errno.h&gt;</a>
<a name="ln34">#include &lt;fcntl.h&gt;</a>
<a name="ln35">#include &lt;glib.h&gt;</a>
<a name="ln36">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln37">#include &lt;limits.h&gt;</a>
<a name="ln38">#include &lt;stdio.h&gt;</a>
<a name="ln39">#include &lt;stdlib.h&gt;</a>
<a name="ln40">#include &lt;string.h&gt;</a>
<a name="ln41">#include &lt;unistd.h&gt;</a>
<a name="ln42">#if defined(__SSE__)</a>
<a name="ln43">#include &lt;xmmintrin.h&gt;</a>
<a name="ln44">#endif</a>
<a name="ln45"> </a>
<a name="ln46">#if !defined(_WIN32)</a>
<a name="ln47">#include &lt;sys/statvfs.h&gt;</a>
<a name="ln48">#else </a>
<a name="ln49">//statvfs does not exist in Windows, providing implementation</a>
<a name="ln50">#include &quot;win/statvfs.h&quot;</a>
<a name="ln51">#endif</a>
<a name="ln52"> </a>
<a name="ln53">#define DT_MIPMAP_CACHE_FILE_MAGIC 0xD71337</a>
<a name="ln54">#define DT_MIPMAP_CACHE_FILE_VERSION 23</a>
<a name="ln55">#define DT_MIPMAP_CACHE_DEFAULT_FILE_NAME &quot;mipmaps&quot;</a>
<a name="ln56"> </a>
<a name="ln57">typedef enum dt_mipmap_buffer_dsc_flags</a>
<a name="ln58">{</a>
<a name="ln59">  DT_MIPMAP_BUFFER_DSC_FLAG_NONE = 0,</a>
<a name="ln60">  DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE = 1 &lt;&lt; 0,</a>
<a name="ln61">  DT_MIPMAP_BUFFER_DSC_FLAG_INVALIDATE = 1 &lt;&lt; 1</a>
<a name="ln62">} dt_mipmap_buffer_dsc_flags;</a>
<a name="ln63"> </a>
<a name="ln64">// the embedded Exif data to tag thumbnails as sRGB or AdobeRGB</a>
<a name="ln65">static const uint8_t dt_mipmap_cache_exif_data_srgb[] = {</a>
<a name="ln66">  0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x69,</a>
<a name="ln67">  0x87, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,</a>
<a name="ln68">  0x01, 0xa0, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</a>
<a name="ln69">};</a>
<a name="ln70">static const uint8_t dt_mipmap_cache_exif_data_adobergb[] = {</a>
<a name="ln71">  0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x69,</a>
<a name="ln72">  0x87, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,</a>
<a name="ln73">  0x01, 0xa0, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</a>
<a name="ln74">};</a>
<a name="ln75">static const int dt_mipmap_cache_exif_data_srgb_length</a>
<a name="ln76">                      = sizeof(dt_mipmap_cache_exif_data_srgb) / sizeof(*dt_mipmap_cache_exif_data_srgb);</a>
<a name="ln77">static const int dt_mipmap_cache_exif_data_adobergb_length</a>
<a name="ln78">                      = sizeof(dt_mipmap_cache_exif_data_adobergb) / sizeof(*dt_mipmap_cache_exif_data_adobergb);</a>
<a name="ln79"> </a>
<a name="ln80">struct dt_mipmap_buffer_dsc</a>
<a name="ln81">{</a>
<a name="ln82">  uint32_t width;</a>
<a name="ln83">  uint32_t height;</a>
<a name="ln84">  float iscale;</a>
<a name="ln85">  size_t size;</a>
<a name="ln86">  dt_mipmap_buffer_dsc_flags flags;</a>
<a name="ln87">  dt_colorspaces_color_profile_type_t color_space;</a>
<a name="ln88"> </a>
<a name="ln89">#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)</a>
<a name="ln90">  // do not touch!</a>
<a name="ln91">  // must be the last element.</a>
<a name="ln92">  // must be no less than 16bytes</a>
<a name="ln93">  char redzone[16];</a>
<a name="ln94">#endif</a>
<a name="ln95"> </a>
<a name="ln96">  /* NB: sizeof must be a multiple of 4*sizeof(float) */</a>
<a name="ln97">} __attribute__((packed, aligned(16)));</a>
<a name="ln98"> </a>
<a name="ln99">#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)</a>
<a name="ln100">static const size_t dt_mipmap_buffer_dsc_size __attribute__((unused))</a>
<a name="ln101">= sizeof(struct dt_mipmap_buffer_dsc) - sizeof(((struct dt_mipmap_buffer_dsc *)0)-&gt;redzone);</a>
<a name="ln102">#else</a>
<a name="ln103">static const size_t dt_mipmap_buffer_dsc_size __attribute__((unused)) = sizeof(struct dt_mipmap_buffer_dsc);</a>
<a name="ln104">#endif</a>
<a name="ln105"> </a>
<a name="ln106">// last resort mem alloc for dead images. sizeof(dt_mipmap_buffer_dsc) + dead image pixels (8x8)</a>
<a name="ln107">// Must be alignment to 4 * sizeof(float).</a>
<a name="ln108">static float dt_mipmap_cache_static_dead_image[sizeof(struct dt_mipmap_buffer_dsc) / sizeof(float) + 64 * 4]</a>
<a name="ln109">    __attribute__((aligned(16)));</a>
<a name="ln110"> </a>
<a name="ln111">static inline void dead_image_8(dt_mipmap_buffer_t *buf)</a>
<a name="ln112">{</a>
<a name="ln113">  if(!buf-&gt;buf) return;</a>
<a name="ln114">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;buf - 1;</a>
<a name="ln115">  dsc-&gt;width = dsc-&gt;height = 8;</a>
<a name="ln116">  dsc-&gt;iscale = 1.0f;</a>
<a name="ln117">  dsc-&gt;color_space = DT_COLORSPACE_DISPLAY;</a>
<a name="ln118">  assert(dsc-&gt;size &gt; 64 * sizeof(uint32_t));</a>
<a name="ln119">  const uint32_t X = 0xffffffffu;</a>
<a name="ln120">  const uint32_t o = 0u;</a>
<a name="ln121">  const uint32_t image[]</a>
<a name="ln122">      = { o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, X, o, X, X, o, X, o, o, X, X, X, X, X, X, o,</a>
<a name="ln123">          o, o, X, o, o, X, o, o, o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o, o, o };</a>
<a name="ln124">  memcpy(buf-&gt;buf, image, sizeof(uint32_t) * 64);</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">static inline void dead_image_f(dt_mipmap_buffer_t *buf)</a>
<a name="ln128">{</a>
<a name="ln129">  if(!buf-&gt;buf) return;</a>
<a name="ln130">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;buf - 1;</a>
<a name="ln131">  dsc-&gt;width = dsc-&gt;height = 8;</a>
<a name="ln132">  dsc-&gt;iscale = 1.0f;</a>
<a name="ln133">  dsc-&gt;color_space = DT_COLORSPACE_DISPLAY;</a>
<a name="ln134">  assert(dsc-&gt;size &gt; 64 * 4 * sizeof(float));</a>
<a name="ln135"> </a>
<a name="ln136">  if(darktable.codepath.OPENMP_SIMD)</a>
<a name="ln137">  {</a>
<a name="ln138">    const float X = 1.0f;</a>
<a name="ln139">    const float o = 0.0f;</a>
<a name="ln140"> </a>
<a name="ln141">    const float image[64 * 4]</a>
<a name="ln142">        = { o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o,</a>
<a name="ln143">            o, o, o, o, o, o, o, o, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, o, o, o, o, o, o, o, o,</a>
<a name="ln144">            o, o, o, o, X, X, X, X, o, o, o, o, X, X, X, X, X, X, X, X, o, o, o, o, X, X, X, X, o, o, o, o,</a>
<a name="ln145">            o, o, o, o, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, o, o, o, o,</a>
<a name="ln146">            o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o,</a>
<a name="ln147">            o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o,</a>
<a name="ln148">            o, o, o, o, o, o, o, o, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, o, o, o, o, o, o, o, o,</a>
<a name="ln149">            o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o };</a>
<a name="ln150"> </a>
<a name="ln151">    memcpy(buf-&gt;buf, image, sizeof(float) * 4 * 64);</a>
<a name="ln152">  }</a>
<a name="ln153">#if defined(__SSE__)</a>
<a name="ln154">  else if(darktable.codepath.SSE2)</a>
<a name="ln155">  {</a>
<a name="ln156">    const __m128 X = _mm_set1_ps(1.0f);</a>
<a name="ln157">    const __m128 o = _mm_set1_ps(0.0f);</a>
<a name="ln158">    const __m128 image[]</a>
<a name="ln159">        = { o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, X, o, X, X, o, X, o, o, X, X, X, X, X, X, o,</a>
<a name="ln160">            o, o, X, o, o, X, o, o, o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o, o, o };</a>
<a name="ln161"> </a>
<a name="ln162">    memcpy(buf-&gt;buf, image, sizeof(__m128) * 64);</a>
<a name="ln163">  }</a>
<a name="ln164">#endif</a>
<a name="ln165">  else</a>
<a name="ln166">    dt_unreachable_codepath();</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">#ifndef NDEBUG</a>
<a name="ln170">static inline int32_t buffer_is_broken(dt_mipmap_buffer_t *buf)</a>
<a name="ln171">{</a>
<a name="ln172">  if(!buf-&gt;buf) return 0;</a>
<a name="ln173">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;buf - 1;</a>
<a name="ln174">  if(buf-&gt;width != dsc-&gt;width) return 1;</a>
<a name="ln175">  if(buf-&gt;height != dsc-&gt;height) return 2;</a>
<a name="ln176">  // somewhat loose bound:</a>
<a name="ln177">  if(buf-&gt;width * buf-&gt;height &gt; dsc-&gt;size) return 3;</a>
<a name="ln178">  return 0;</a>
<a name="ln179">}</a>
<a name="ln180">#endif</a>
<a name="ln181"> </a>
<a name="ln182">static inline uint32_t get_key(const uint32_t imgid, const dt_mipmap_size_t size)</a>
<a name="ln183">{</a>
<a name="ln184">  // imgid can't be &gt;= 2^28 (~250 million images)</a>
<a name="ln185">  return (((uint32_t)size) &lt;&lt; 28) | (imgid - 1);</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">static inline uint32_t get_imgid(const uint32_t key)</a>
<a name="ln189">{</a>
<a name="ln190">  return (key &amp; 0xfffffff) + 1;</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">static inline dt_mipmap_size_t get_size(const uint32_t key)</a>
<a name="ln194">{</a>
<a name="ln195">  return (dt_mipmap_size_t)(key &gt;&gt; 28);</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">static int dt_mipmap_cache_get_filename(gchar *mipmapfilename, size_t size)</a>
<a name="ln199">{</a>
<a name="ln200">  int r = -1;</a>
<a name="ln201">  char *abspath = NULL;</a>
<a name="ln202"> </a>
<a name="ln203">  // Directory</a>
<a name="ln204">  char cachedir[PATH_MAX] = { 0 };</a>
<a name="ln205">  dt_loc_get_user_cache_dir(cachedir, sizeof(cachedir));</a>
<a name="ln206"> </a>
<a name="ln207">  // Build the mipmap filename</a>
<a name="ln208">  const gchar *dbfilename = dt_database_get_path(darktable.db);</a>
<a name="ln209">  if(!strcmp(dbfilename, &quot;:memory:&quot;))</a>
<a name="ln210">  {</a>
<a name="ln211">    mipmapfilename[0] = '\0';</a>
<a name="ln212">    r = 0;</a>
<a name="ln213">    goto exit;</a>
<a name="ln214">  }</a>
<a name="ln215"> </a>
<a name="ln216">  abspath = g_realpath(dbfilename);</a>
<a name="ln217">  if(!abspath) abspath = g_strdup(dbfilename);</a>
<a name="ln218"> </a>
<a name="ln219">  GChecksum *chk = g_checksum_new(G_CHECKSUM_SHA1);</a>
<a name="ln220">  g_checksum_update(chk, (guchar *)abspath, strlen(abspath));</a>
<a name="ln221">  const gchar *filename = g_checksum_get_string(chk);</a>
<a name="ln222"> </a>
<a name="ln223">  if(!filename || filename[0] == '\0')</a>
<a name="ln224">    snprintf(mipmapfilename, size, &quot;%s/%s&quot;, cachedir, DT_MIPMAP_CACHE_DEFAULT_FILE_NAME);</a>
<a name="ln225">  else</a>
<a name="ln226">    snprintf(mipmapfilename, size, &quot;%s/%s-%s&quot;, cachedir, DT_MIPMAP_CACHE_DEFAULT_FILE_NAME, filename);</a>
<a name="ln227"> </a>
<a name="ln228">  g_checksum_free(chk);</a>
<a name="ln229">  r = 0;</a>
<a name="ln230"> </a>
<a name="ln231">exit:</a>
<a name="ln232">  g_free(abspath);</a>
<a name="ln233"> </a>
<a name="ln234">  return r;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">static void _init_f(dt_mipmap_buffer_t *mipmap_buf, float *buf, uint32_t *width, uint32_t *height, float *iscale,</a>
<a name="ln238">                    const uint32_t imgid);</a>
<a name="ln239">static void _init_8(uint8_t *buf, uint32_t *width, uint32_t *height, float *iscale,</a>
<a name="ln240">                    dt_colorspaces_color_profile_type_t *color_space, const uint32_t imgid,</a>
<a name="ln241">                    const dt_mipmap_size_t size);</a>
<a name="ln242"> </a>
<a name="ln243">// callback for the imageio core to allocate memory.</a>
<a name="ln244">// only needed for _F and _FULL buffers, as they change size</a>
<a name="ln245">// with the input image. will allocate img-&gt;width*img-&gt;height*img-&gt;bpp bytes.</a>
<a name="ln246">void *dt_mipmap_cache_alloc(dt_mipmap_buffer_t *buf, const dt_image_t *img)</a>
<a name="ln247">{</a>
<a name="ln248">  assert(buf-&gt;size == DT_MIPMAP_FULL);</a>
<a name="ln249"> </a>
<a name="ln250">  dt_cache_entry_t *entry = buf-&gt;cache_entry;</a>
<a name="ln251">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln252"> </a>
<a name="ln253">  const int wd = img-&gt;width;</a>
<a name="ln254">  const int ht = img-&gt;height;</a>
<a name="ln255"> </a>
<a name="ln256">  const size_t bpp = dt_iop_buffer_dsc_to_bpp(&amp;img-&gt;buf_dsc);</a>
<a name="ln257">  const size_t buffer_size = (size_t)wd * ht * bpp + sizeof(*dsc);</a>
<a name="ln258"> </a>
<a name="ln259">  // buf might have been alloc'ed before,</a>
<a name="ln260">  // so only check size and re-alloc if necessary:</a>
<a name="ln261">  if(!buf-&gt;buf || ((void *)dsc == (void *)dt_mipmap_cache_static_dead_image) || (entry-&gt;data_size &lt; buffer_size))</a>
<a name="ln262">  {</a>
<a name="ln263">    if((void *)dsc != (void *)dt_mipmap_cache_static_dead_image) dt_free_align(entry-&gt;data);</a>
<a name="ln264"> </a>
<a name="ln265">    entry-&gt;data_size = 0;</a>
<a name="ln266"> </a>
<a name="ln267">    entry-&gt;data = dt_alloc_align(64, buffer_size);</a>
<a name="ln268"> </a>
<a name="ln269">    if(!entry-&gt;data)</a>
<a name="ln270">    {</a>
<a name="ln271">      // return fallback: at least alloc size for a dead image:</a>
<a name="ln272">      entry-&gt;data = (void *)dt_mipmap_cache_static_dead_image;</a>
<a name="ln273"> </a>
<a name="ln274">      // allocator holds the pointer. but let imageio client know that allocation failed:</a>
<a name="ln275">      return NULL;</a>
<a name="ln276">    }</a>
<a name="ln277"> </a>
<a name="ln278">    entry-&gt;data_size = buffer_size;</a>
<a name="ln279"> </a>
<a name="ln280">    // set buffer size only if we're making it larger.</a>
<a name="ln281">    dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln282">  }</a>
<a name="ln283"> </a>
<a name="ln284">  dsc-&gt;size = buffer_size;</a>
<a name="ln285"> </a>
<a name="ln286">  dsc-&gt;width = wd;</a>
<a name="ln287">  dsc-&gt;height = ht;</a>
<a name="ln288">  dsc-&gt;iscale = 1.0f;</a>
<a name="ln289">  dsc-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln290">  dsc-&gt;flags = DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE;</a>
<a name="ln291">  buf-&gt;buf = (uint8_t *)(dsc + 1);</a>
<a name="ln292"> </a>
<a name="ln293">  // fprintf(stderr, &quot;full buffer allocating img %u %d x %d = %u bytes (%p)\n&quot;, img-&gt;id, img-&gt;width,</a>
<a name="ln294">  // img-&gt;height, buffer_size, *buf);</a>
<a name="ln295"> </a>
<a name="ln296">  assert(entry-&gt;data_size);</a>
<a name="ln297">  assert(dsc-&gt;size);</a>
<a name="ln298">  assert(dsc-&gt;size &lt;= entry-&gt;data_size);</a>
<a name="ln299"> </a>
<a name="ln300">  ASAN_POISON_MEMORY_REGION(entry-&gt;data, entry-&gt;data_size);</a>
<a name="ln301">  ASAN_UNPOISON_MEMORY_REGION(dsc + 1, buffer_size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln302"> </a>
<a name="ln303">  // return pointer to start of payload</a>
<a name="ln304">  return dsc + 1;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">// callback for the cache backend to initialize payload pointers</a>
<a name="ln308">void dt_mipmap_cache_allocate_dynamic(void *data, dt_cache_entry_t *entry)</a>
<a name="ln309">{</a>
<a name="ln310">  dt_mipmap_cache_t *cache = (dt_mipmap_cache_t *)data;</a>
<a name="ln311">  // for full image buffers</a>
<a name="ln312">  struct dt_mipmap_buffer_dsc *dsc = entry-&gt;data;</a>
<a name="ln313">  const dt_mipmap_size_t mip = get_size(entry-&gt;key);</a>
<a name="ln314"> </a>
<a name="ln315">  // alloc mere minimum for the header + broken image buffer:</a>
<a name="ln316">  if(!dsc)</a>
<a name="ln317">  {</a>
<a name="ln318">    if(mip &lt;= DT_MIPMAP_F)</a>
<a name="ln319">    {</a>
<a name="ln320">      // these are fixed-size:</a>
<a name="ln321">      entry-&gt;data_size = cache-&gt;buffer_size[mip];</a>
<a name="ln322">    }</a>
<a name="ln323">    else</a>
<a name="ln324">    {</a>
<a name="ln325">      entry-&gt;data_size = sizeof(*dsc) + sizeof(float) * 4 * 64;</a>
<a name="ln326">    }</a>
<a name="ln327"> </a>
<a name="ln328">    entry-&gt;data = dt_alloc_align(16, entry-&gt;data_size);</a>
<a name="ln329"> </a>
<a name="ln330">    // fprintf(stderr, &quot;[mipmap cache] alloc dynamic for key %u %p\n&quot;, key, *buf);</a>
<a name="ln331">    if(!(entry-&gt;data))</a>
<a name="ln332">    {</a>
<a name="ln333">      fprintf(stderr, &quot;[mipmap cache] memory allocation failed!\n&quot;);</a>
<a name="ln334">      exit(1);</a>
<a name="ln335">    }</a>
<a name="ln336"> </a>
<a name="ln337">    dsc = entry-&gt;data;</a>
<a name="ln338"> </a>
<a name="ln339">    if(mip &lt;= DT_MIPMAP_F)</a>
<a name="ln340">    {</a>
<a name="ln341">      dsc-&gt;width = cache-&gt;max_width[mip];</a>
<a name="ln342">      dsc-&gt;height = cache-&gt;max_height[mip];</a>
<a name="ln343">      dsc-&gt;iscale = 1.0f;</a>
<a name="ln344">      dsc-&gt;size = entry-&gt;data_size;</a>
<a name="ln345">      dsc-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln346">    }</a>
<a name="ln347">    else</a>
<a name="ln348">    {</a>
<a name="ln349">      dsc-&gt;width = 0;</a>
<a name="ln350">      dsc-&gt;height = 0;</a>
<a name="ln351">      dsc-&gt;iscale = 0.0f;</a>
<a name="ln352">      dsc-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln353">      dsc-&gt;size = entry-&gt;data_size;</a>
<a name="ln354">    }</a>
<a name="ln355">  }</a>
<a name="ln356"> </a>
<a name="ln357">  assert(dsc-&gt;size &gt;= sizeof(*dsc));</a>
<a name="ln358"> </a>
<a name="ln359">  int loaded_from_disk = 0;</a>
<a name="ln360">  if(mip &lt; DT_MIPMAP_F)</a>
<a name="ln361">  {</a>
<a name="ln362">    if(cache-&gt;cachedir[0] &amp;&amp; dt_conf_get_bool(&quot;cache_disk_backend&quot;))</a>
<a name="ln363">    {</a>
<a name="ln364">      // try and load from disk, if successful set flag</a>
<a name="ln365">      char filename[PATH_MAX] = {0};</a>
<a name="ln366">      snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, get_imgid(entry-&gt;key));</a>
<a name="ln367">      FILE *f = g_fopen(filename, &quot;rb&quot;);</a>
<a name="ln368">      if(f)</a>
<a name="ln369">      {</a>
<a name="ln370">        long len = 0;</a>
<a name="ln371">        uint8_t *blob = 0;</a>
<a name="ln372">        fseek(f, 0, SEEK_END);</a>
<a name="ln373">        len = ftell(f);</a>
<a name="ln374">        if(len &lt;= 0) goto read_error; // coverity madness</a>
<a name="ln375">        blob = (uint8_t *)malloc(len);</a>
<a name="ln376">        if(!blob) goto read_error;</a>
<a name="ln377">        fseek(f, 0, SEEK_SET);</a>
<a name="ln378">        int rd = fread(blob, sizeof(uint8_t), len, f);</a>
<a name="ln379">        if(rd != len) goto read_error;</a>
<a name="ln380">        dt_colorspaces_color_profile_type_t color_space;</a>
<a name="ln381">        dt_imageio_jpeg_t jpg;</a>
<a name="ln382">        if(dt_imageio_jpeg_decompress_header(blob, len, &amp;jpg)</a>
<a name="ln383">           || (jpg.width &gt; cache-&gt;max_width[mip] || jpg.height &gt; cache-&gt;max_height[mip])</a>
<a name="ln384">           || ((color_space = dt_imageio_jpeg_read_color_space(&amp;jpg)) == DT_COLORSPACE_NONE) // pointless test to keep it in the if clause</a>
<a name="ln385">           || dt_imageio_jpeg_decompress(&amp;jpg, entry-&gt;data + sizeof(*dsc)))</a>
<a name="ln386">        {</a>
<a name="ln387">          fprintf(stderr, &quot;[mipmap_cache] failed to decompress thumbnail for image %d from `%s'!\n&quot;, get_imgid(entry-&gt;key), filename);</a>
<a name="ln388">          goto read_error;</a>
<a name="ln389">        }</a>
<a name="ln390">        dsc-&gt;width = jpg.width;</a>
<a name="ln391">        dsc-&gt;height = jpg.height;</a>
<a name="ln392">        dsc-&gt;iscale = 1.0f;</a>
<a name="ln393">        dsc-&gt;color_space = color_space;</a>
<a name="ln394">        loaded_from_disk = 1;</a>
<a name="ln395">        if(0)</a>
<a name="ln396">        {</a>
<a name="ln397">read_error:</a>
<a name="ln398">          g_unlink(filename);</a>
<a name="ln399">        }</a>
<a name="ln400">        free(blob);</a>
<a name="ln401">        fclose(f);</a>
<a name="ln402">      }</a>
<a name="ln403">    }</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  if(!loaded_from_disk)</a>
<a name="ln407">    dsc-&gt;flags = DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE;</a>
<a name="ln408">  else dsc-&gt;flags = 0;</a>
<a name="ln409"> </a>
<a name="ln410">  // cost is just flat one for the buffer, as the buffers might have different sizes,</a>
<a name="ln411">  // to make sure quota is meaningful.</a>
<a name="ln412">  if(mip &gt;= DT_MIPMAP_F) entry-&gt;cost = 1;</a>
<a name="ln413">  else entry-&gt;cost = cache-&gt;buffer_size[mip];</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">static void dt_mipmap_cache_unlink_ondisk_thumbnail(void *data, uint32_t imgid, dt_mipmap_size_t mip)</a>
<a name="ln417">{</a>
<a name="ln418">  dt_mipmap_cache_t *cache = (dt_mipmap_cache_t *)data;</a>
<a name="ln419"> </a>
<a name="ln420">  // also remove jpg backing (always try to do that, in case user just temporarily switched it off,</a>
<a name="ln421">  // to avoid inconsistencies.</a>
<a name="ln422">  // if(dt_conf_get_bool(&quot;cache_disk_backend&quot;))</a>
<a name="ln423">  if(cache-&gt;cachedir[0])</a>
<a name="ln424">  {</a>
<a name="ln425">    char filename[PATH_MAX] = { 0 };</a>
<a name="ln426">    snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, imgid);</a>
<a name="ln427">    g_unlink(filename);</a>
<a name="ln428">  }</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">void dt_mipmap_cache_deallocate_dynamic(void *data, dt_cache_entry_t *entry)</a>
<a name="ln432">{</a>
<a name="ln433">  dt_mipmap_cache_t *cache = (dt_mipmap_cache_t *)data;</a>
<a name="ln434">  const dt_mipmap_size_t mip = get_size(entry-&gt;key);</a>
<a name="ln435">  if(mip &lt; DT_MIPMAP_F)</a>
<a name="ln436">  {</a>
<a name="ln437">    struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln438">    // don't write skulls:</a>
<a name="ln439">    if(dsc-&gt;width &gt; 8 &amp;&amp; dsc-&gt;height &gt; 8)</a>
<a name="ln440">    {</a>
<a name="ln441">      if(dsc-&gt;flags &amp; DT_MIPMAP_BUFFER_DSC_FLAG_INVALIDATE)</a>
<a name="ln442">      {</a>
<a name="ln443">        dt_mipmap_cache_unlink_ondisk_thumbnail(data, get_imgid(entry-&gt;key), mip);</a>
<a name="ln444">      }</a>
<a name="ln445">      else if(cache-&gt;cachedir[0] &amp;&amp; dt_conf_get_bool(&quot;cache_disk_backend&quot;))</a>
<a name="ln446">      {</a>
<a name="ln447">        // serialize to disk</a>
<a name="ln448">        char filename[PATH_MAX] = {0};</a>
<a name="ln449">        snprintf(filename, sizeof(filename), &quot;%s.d/%d&quot;, cache-&gt;cachedir, mip);</a>
<a name="ln450">        int mkd = g_mkdir_with_parents(filename, 0750);</a>
<a name="ln451">        if(!mkd)</a>
<a name="ln452">        {</a>
<a name="ln453">          snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, get_imgid(entry-&gt;key));</a>
<a name="ln454">          // Don't write existing files as both performance and quality (lossy jpg) suffer</a>
<a name="ln455">          FILE *f = NULL;</a>
<a name="ln456">          if (!g_file_test(filename, G_FILE_TEST_EXISTS) &amp;&amp; (f = g_fopen(filename, &quot;wb&quot;)))</a>
<a name="ln457">          {</a>
<a name="ln458">            // first check the disk isn't full</a>
<a name="ln459">            struct statvfs vfsbuf;</a>
<a name="ln460">            if (!statvfs(filename, &amp;vfsbuf))</a>
<a name="ln461">            {</a>
<a name="ln462">              int64_t free_mb = ((vfsbuf.f_frsize * vfsbuf.f_bavail) &gt;&gt; 20);</a>
<a name="ln463">              if (free_mb &lt; 100)</a>
<a name="ln464">              {</a>
<a name="ln465">                fprintf(stderr, &quot;Aborting image write as only %&quot; PRId64 &quot; MB free to write %s\n&quot;, free_mb, filename);</a>
<a name="ln466">                goto write_error;</a>
<a name="ln467">              }</a>
<a name="ln468">            }</a>
<a name="ln469">            else</a>
<a name="ln470">            {</a>
<a name="ln471">              fprintf(stderr, &quot;Aborting image write since couldn't determine free space available to write %s\n&quot;, filename);</a>
<a name="ln472">              goto write_error;</a>
<a name="ln473">            }</a>
<a name="ln474"> </a>
<a name="ln475">            const int cache_quality = dt_conf_get_int(&quot;database_cache_quality&quot;);</a>
<a name="ln476">            const uint8_t *exif = NULL;</a>
<a name="ln477">            int exif_len = 0;</a>
<a name="ln478">            if(dsc-&gt;color_space == DT_COLORSPACE_SRGB)</a>
<a name="ln479">            {</a>
<a name="ln480">              exif = dt_mipmap_cache_exif_data_srgb;</a>
<a name="ln481">              exif_len = dt_mipmap_cache_exif_data_srgb_length;</a>
<a name="ln482">            }</a>
<a name="ln483">            else if(dsc-&gt;color_space == DT_COLORSPACE_ADOBERGB)</a>
<a name="ln484">            {</a>
<a name="ln485">              exif = dt_mipmap_cache_exif_data_adobergb;</a>
<a name="ln486">              exif_len = dt_mipmap_cache_exif_data_adobergb_length;</a>
<a name="ln487">            }</a>
<a name="ln488">            if(dt_imageio_jpeg_write(filename, entry-&gt;data + sizeof(*dsc), dsc-&gt;width, dsc-&gt;height, MIN(100, MAX(10, cache_quality)), exif, exif_len))</a>
<a name="ln489">            {</a>
<a name="ln490">write_error:</a>
<a name="ln491">              g_unlink(filename);</a>
<a name="ln492">            }</a>
<a name="ln493">          }</a>
<a name="ln494">          if(f) fclose(f);</a>
<a name="ln495">        }</a>
<a name="ln496">      }</a>
<a name="ln497">    }</a>
<a name="ln498">  }</a>
<a name="ln499">  dt_free_align(entry-&gt;data);</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">static uint32_t nearest_power_of_two(const uint32_t value)</a>
<a name="ln503">{</a>
<a name="ln504">  uint32_t rc = 1;</a>
<a name="ln505">  while(rc &lt; value) rc &lt;&lt;= 1;</a>
<a name="ln506">  return rc;</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509">void dt_mipmap_cache_init(dt_mipmap_cache_t *cache)</a>
<a name="ln510">{</a>
<a name="ln511">  dt_mipmap_cache_get_filename(cache-&gt;cachedir, sizeof(cache-&gt;cachedir));</a>
<a name="ln512">  // make sure static memory is initialized</a>
<a name="ln513">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)dt_mipmap_cache_static_dead_image;</a>
<a name="ln514">  dead_image_f((dt_mipmap_buffer_t *)(dsc + 1));</a>
<a name="ln515"> </a>
<a name="ln516">  // adjust numbers to be large enough to hold what mem limit suggests.</a>
<a name="ln517">  // we want at least 100MB, and consider 8G just still reasonable.</a>
<a name="ln518">  int64_t cache_memory = dt_conf_get_int64(&quot;cache_memory&quot;);</a>
<a name="ln519">  int worker_threads = dt_conf_get_int(&quot;worker_threads&quot;);</a>
<a name="ln520">  size_t max_mem = CLAMPS(cache_memory, 100u &lt;&lt; 20, ((size_t)8) &lt;&lt; 30);</a>
<a name="ln521">  const uint32_t parallel = CLAMP(worker_threads, 1, 8);</a>
<a name="ln522"> </a>
<a name="ln523">  // Fixed sizes for the thumbnail mip levels, selected for coverage of most screen sizes</a>
<a name="ln524">  int32_t mipsizes[DT_MIPMAP_F][2] = {</a>
<a name="ln525">    {180,  110},  // mip0 - ~1/2 size previous one</a>
<a name="ln526">    {360,  225},  // mip1 - 1/2 size previous one</a>
<a name="ln527">    {720,  450},  // mip2 - 1/2 size previous one</a>
<a name="ln528">    {1440, 900},  // mip3 - covers 720p and 1366x768</a>
<a name="ln529">    {1920, 1200}, // mip4 - covers 1080p and 1600x1200</a>
<a name="ln530">    {2560, 1600}, // mip5 - covers 2560x1440</a>
<a name="ln531">    {4096, 2560}, // mip6 - covers 4K and UHD</a>
<a name="ln532">    {5120, 3200}, // mip7 - covers 5120x2880 panels</a>
<a name="ln533">  };</a>
<a name="ln534">  // Set mipf to mip2 size as at most the user will be using an 8K screen and</a>
<a name="ln535">  // have a preview that's ~4x smaller</a>
<a name="ln536">  cache-&gt;max_width[DT_MIPMAP_F] = mipsizes[DT_MIPMAP_2][0];</a>
<a name="ln537">  cache-&gt;max_height[DT_MIPMAP_F] = mipsizes[DT_MIPMAP_2][1];</a>
<a name="ln538">  for(int k = DT_MIPMAP_F-1; k &gt;= 0; k--)</a>
<a name="ln539">  {</a>
<a name="ln540">    cache-&gt;max_width[k]  = mipsizes[k][0];</a>
<a name="ln541">    cache-&gt;max_height[k] = mipsizes[k][1];</a>
<a name="ln542">  }</a>
<a name="ln543">    // header + buffer</a>
<a name="ln544">  for(int k = DT_MIPMAP_F-1; k &gt;= 0; k--)</a>
<a name="ln545">    cache-&gt;buffer_size[k] = sizeof(struct dt_mipmap_buffer_dsc)</a>
<a name="ln546">                                + cache-&gt;max_width[k] * cache-&gt;max_height[k] * 4;</a>
<a name="ln547"> </a>
<a name="ln548">  // clear stats:</a>
<a name="ln549">  cache-&gt;mip_thumbs.stats_requests = 0;</a>
<a name="ln550">  cache-&gt;mip_thumbs.stats_near_match = 0;</a>
<a name="ln551">  cache-&gt;mip_thumbs.stats_misses = 0;</a>
<a name="ln552">  cache-&gt;mip_thumbs.stats_fetches = 0;</a>
<a name="ln553">  cache-&gt;mip_thumbs.stats_standin = 0;</a>
<a name="ln554">  cache-&gt;mip_f.stats_requests = 0;</a>
<a name="ln555">  cache-&gt;mip_f.stats_near_match = 0;</a>
<a name="ln556">  cache-&gt;mip_f.stats_misses = 0;</a>
<a name="ln557">  cache-&gt;mip_f.stats_fetches = 0;</a>
<a name="ln558">  cache-&gt;mip_f.stats_standin = 0;</a>
<a name="ln559">  cache-&gt;mip_full.stats_requests = 0;</a>
<a name="ln560">  cache-&gt;mip_full.stats_near_match = 0;</a>
<a name="ln561">  cache-&gt;mip_full.stats_misses = 0;</a>
<a name="ln562">  cache-&gt;mip_full.stats_fetches = 0;</a>
<a name="ln563">  cache-&gt;mip_full.stats_standin = 0;</a>
<a name="ln564"> </a>
<a name="ln565">  dt_cache_init(&amp;cache-&gt;mip_thumbs.cache, 0, max_mem);</a>
<a name="ln566">  dt_cache_set_allocate_callback(&amp;cache-&gt;mip_thumbs.cache, dt_mipmap_cache_allocate_dynamic, cache);</a>
<a name="ln567">  dt_cache_set_cleanup_callback(&amp;cache-&gt;mip_thumbs.cache, dt_mipmap_cache_deallocate_dynamic, cache);</a>
<a name="ln568"> </a>
<a name="ln569">  const int full_entries</a>
<a name="ln570">      = MAX(2, parallel); // even with one thread you want two buffers. one for dr one for thumbs.</a>
<a name="ln571">  int32_t max_mem_bufs = nearest_power_of_two(full_entries);</a>
<a name="ln572"> </a>
<a name="ln573">  // for this buffer, because it can be very busy during import</a>
<a name="ln574">  dt_cache_init(&amp;cache-&gt;mip_full.cache, 0, max_mem_bufs);</a>
<a name="ln575">  dt_cache_set_allocate_callback(&amp;cache-&gt;mip_full.cache, dt_mipmap_cache_allocate_dynamic, cache);</a>
<a name="ln576">  dt_cache_set_cleanup_callback(&amp;cache-&gt;mip_full.cache, dt_mipmap_cache_deallocate_dynamic, cache);</a>
<a name="ln577">  cache-&gt;buffer_size[DT_MIPMAP_FULL] = 0;</a>
<a name="ln578"> </a>
<a name="ln579">  // same for mipf:</a>
<a name="ln580">  dt_cache_init(&amp;cache-&gt;mip_f.cache, 0, max_mem_bufs);</a>
<a name="ln581">  dt_cache_set_allocate_callback(&amp;cache-&gt;mip_f.cache, dt_mipmap_cache_allocate_dynamic, cache);</a>
<a name="ln582">  dt_cache_set_cleanup_callback(&amp;cache-&gt;mip_f.cache, dt_mipmap_cache_deallocate_dynamic, cache);</a>
<a name="ln583">  cache-&gt;buffer_size[DT_MIPMAP_F] = sizeof(struct dt_mipmap_buffer_dsc)</a>
<a name="ln584">                                        + 4 * sizeof(float) * cache-&gt;max_width[DT_MIPMAP_F]</a>
<a name="ln585">                                          * cache-&gt;max_height[DT_MIPMAP_F];</a>
<a name="ln586">}</a>
<a name="ln587"> </a>
<a name="ln588">void dt_mipmap_cache_cleanup(dt_mipmap_cache_t *cache)</a>
<a name="ln589">{</a>
<a name="ln590">  dt_cache_cleanup(&amp;cache-&gt;mip_thumbs.cache);</a>
<a name="ln591">  dt_cache_cleanup(&amp;cache-&gt;mip_full.cache);</a>
<a name="ln592">  dt_cache_cleanup(&amp;cache-&gt;mip_f.cache);</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595">void dt_mipmap_cache_print(dt_mipmap_cache_t *cache)</a>
<a name="ln596">{</a>
<a name="ln597">  printf(&quot;[mipmap_cache] thumbs fill %.2f/%.2f MB (%.2f%%)\n&quot;,</a>
<a name="ln598">         cache-&gt;mip_thumbs.cache.cost / (1024.0 * 1024.0),</a>
<a name="ln599">         cache-&gt;mip_thumbs.cache.cost_quota / (1024.0 * 1024.0),</a>
<a name="ln600">         100.0f * (float)cache-&gt;mip_thumbs.cache.cost / (float)cache-&gt;mip_thumbs.cache.cost_quota);</a>
<a name="ln601">  printf(&quot;[mipmap_cache] float fill %d/%d slots (%.2f%%)\n&quot;,</a>
<a name="ln602">         (uint32_t)cache-&gt;mip_f.cache.cost, (uint32_t)cache-&gt;mip_f.cache.cost_quota,</a>
<a name="ln603">         100.0f * (float)cache-&gt;mip_f.cache.cost / (float)cache-&gt;mip_f.cache.cost_quota);</a>
<a name="ln604">  printf(&quot;[mipmap_cache] full  fill %d/%d slots (%.2f%%)\n&quot;,</a>
<a name="ln605">         (uint32_t)cache-&gt;mip_full.cache.cost, (uint32_t)cache-&gt;mip_full.cache.cost_quota,</a>
<a name="ln606">         100.0f * (float)cache-&gt;mip_full.cache.cost / (float)cache-&gt;mip_full.cache.cost_quota);</a>
<a name="ln607"> </a>
<a name="ln608">  uint64_t sum = 0;</a>
<a name="ln609">  uint64_t sum_fetches = 0;</a>
<a name="ln610">  uint64_t sum_standins = 0;</a>
<a name="ln611">  sum += cache-&gt;mip_thumbs.stats_requests;</a>
<a name="ln612">  sum_fetches += cache-&gt;mip_thumbs.stats_fetches;</a>
<a name="ln613">  sum_standins += cache-&gt;mip_thumbs.stats_standin;</a>
<a name="ln614">  sum += cache-&gt;mip_f.stats_requests;</a>
<a name="ln615">  sum_fetches += cache-&gt;mip_f.stats_fetches;</a>
<a name="ln616">  sum_standins += cache-&gt;mip_f.stats_standin;</a>
<a name="ln617">  sum += cache-&gt;mip_full.stats_requests;</a>
<a name="ln618">  sum_fetches += cache-&gt;mip_full.stats_fetches;</a>
<a name="ln619">  sum_standins += cache-&gt;mip_full.stats_standin;</a>
<a name="ln620">  printf(&quot;[mipmap_cache] level | near match | miss | stand-in | fetches | total rq\n&quot;);</a>
<a name="ln621">  printf(&quot;[mipmap_cache] thumb | %6.2f%% | %6.2f%% | %6.2f%%  | %6.2f%% | %6.2f%%\n&quot;,</a>
<a name="ln622">         100.0 * cache-&gt;mip_thumbs.stats_near_match / (float)cache-&gt;mip_thumbs.stats_requests,</a>
<a name="ln623">         100.0 * cache-&gt;mip_thumbs.stats_misses / (float)cache-&gt;mip_thumbs.stats_requests,</a>
<a name="ln624">         100.0 * cache-&gt;mip_thumbs.stats_standin / (float)sum_standins,</a>
<a name="ln625">         100.0 * cache-&gt;mip_thumbs.stats_fetches / (float)sum_fetches,</a>
<a name="ln626">         100.0 * cache-&gt;mip_thumbs.stats_requests / (float)sum);</a>
<a name="ln627">  printf(&quot;[mipmap_cache] float | %6.2f%% | %6.2f%% | %6.2f%%  | %6.2f%% | %6.2f%%\n&quot;,</a>
<a name="ln628">         100.0 * cache-&gt;mip_f.stats_near_match / (float)cache-&gt;mip_f.stats_requests,</a>
<a name="ln629">         100.0 * cache-&gt;mip_f.stats_misses / (float)cache-&gt;mip_f.stats_requests,</a>
<a name="ln630">         100.0 * cache-&gt;mip_f.stats_standin / (float)sum_standins,</a>
<a name="ln631">         100.0 * cache-&gt;mip_f.stats_fetches / (float)sum_fetches,</a>
<a name="ln632">         100.0 * cache-&gt;mip_f.stats_requests / (float)sum);</a>
<a name="ln633">  printf(&quot;[mipmap_cache] full  | %6.2f%% | %6.2f%% | %6.2f%%  | %6.2f%% | %6.2f%%\n&quot;,</a>
<a name="ln634">         100.0 * cache-&gt;mip_full.stats_near_match / (float)cache-&gt;mip_full.stats_requests,</a>
<a name="ln635">         100.0 * cache-&gt;mip_full.stats_misses / (float)cache-&gt;mip_full.stats_requests,</a>
<a name="ln636">         100.0 * cache-&gt;mip_full.stats_standin / (float)sum_standins,</a>
<a name="ln637">         100.0 * cache-&gt;mip_full.stats_fetches / (float)sum_fetches,</a>
<a name="ln638">         100.0 * cache-&gt;mip_full.stats_requests / (float)sum);</a>
<a name="ln639">  printf(&quot;\n\n&quot;);</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">static gboolean _raise_signal_mipmap_updated(gpointer user_data)</a>
<a name="ln643">{</a>
<a name="ln644">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_MIPMAP_UPDATED);</a>
<a name="ln645">  return FALSE; // only call once</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648">static dt_mipmap_cache_one_t *_get_cache(dt_mipmap_cache_t *cache, const dt_mipmap_size_t mip)</a>
<a name="ln649">{</a>
<a name="ln650">  switch(mip)</a>
<a name="ln651">  {</a>
<a name="ln652">    case DT_MIPMAP_FULL:</a>
<a name="ln653">      return &amp;cache-&gt;mip_full;</a>
<a name="ln654">    case DT_MIPMAP_F:</a>
<a name="ln655">      return &amp;cache-&gt;mip_f;</a>
<a name="ln656">    default:</a>
<a name="ln657">      return &amp;cache-&gt;mip_thumbs;</a>
<a name="ln658">  }</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661">void dt_mipmap_cache_get_with_caller(</a>
<a name="ln662">    dt_mipmap_cache_t *cache,</a>
<a name="ln663">    dt_mipmap_buffer_t *buf,</a>
<a name="ln664">    const uint32_t imgid,</a>
<a name="ln665">    const dt_mipmap_size_t mip,</a>
<a name="ln666">    const dt_mipmap_get_flags_t flags,</a>
<a name="ln667">    const char mode,</a>
<a name="ln668">    const char *file,</a>
<a name="ln669">    int line)</a>
<a name="ln670">{</a>
<a name="ln671">  const uint32_t key = get_key(imgid, mip);</a>
<a name="ln672">  if(flags == DT_MIPMAP_TESTLOCK)</a>
<a name="ln673">  {</a>
<a name="ln674">    // simple case: only get and lock if it's there.</a>
<a name="ln675">    dt_cache_entry_t *entry = dt_cache_testget(&amp;_get_cache(cache, mip)-&gt;cache, key, mode);</a>
<a name="ln676">    buf-&gt;cache_entry = entry;</a>
<a name="ln677">    if(entry)</a>
<a name="ln678">    {</a>
<a name="ln679">      ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln680">      struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln681">      buf-&gt;width = dsc-&gt;width;</a>
<a name="ln682">      buf-&gt;height = dsc-&gt;height;</a>
<a name="ln683">      buf-&gt;iscale = dsc-&gt;iscale;</a>
<a name="ln684">      buf-&gt;color_space = dsc-&gt;color_space;</a>
<a name="ln685">      buf-&gt;imgid = imgid;</a>
<a name="ln686">      buf-&gt;size = mip;</a>
<a name="ln687"> </a>
<a name="ln688">      // skip to next 8-byte alignment, for sse buffers.</a>
<a name="ln689">      buf-&gt;buf = (uint8_t *)(dsc + 1);</a>
<a name="ln690"> </a>
<a name="ln691">      ASAN_UNPOISON_MEMORY_REGION(buf-&gt;buf, dsc-&gt;size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln692">    }</a>
<a name="ln693">    else</a>
<a name="ln694">    {</a>
<a name="ln695">      // set to NULL if failed.</a>
<a name="ln696">      buf-&gt;width = buf-&gt;height = 0;</a>
<a name="ln697">      buf-&gt;iscale = 0.0f;</a>
<a name="ln698">      buf-&gt;imgid = 0;</a>
<a name="ln699">      buf-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln700">      buf-&gt;size = DT_MIPMAP_NONE;</a>
<a name="ln701">      buf-&gt;buf = NULL;</a>
<a name="ln702">    }</a>
<a name="ln703">  }</a>
<a name="ln704">  else if(flags == DT_MIPMAP_PREFETCH)</a>
<a name="ln705">  {</a>
<a name="ln706">    // and opposite: prefetch without locking</a>
<a name="ln707">    if(mip &gt; DT_MIPMAP_FULL || (int)mip &lt; DT_MIPMAP_0)</a>
<a name="ln708">      return; // remove the (int) once we no longer have to support gcc &lt; 4.8 :/</a>
<a name="ln709">    dt_control_add_job(darktable.control, DT_JOB_QUEUE_SYSTEM_FG, dt_image_load_job_create(imgid, mip));</a>
<a name="ln710">  }</a>
<a name="ln711">  else if(flags == DT_MIPMAP_PREFETCH_DISK)</a>
<a name="ln712">  {</a>
<a name="ln713">    // only prefetch if the disk cache exists:</a>
<a name="ln714">    if(!cache-&gt;cachedir[0]) return;</a>
<a name="ln715">    if(mip &gt; DT_MIPMAP_FULL || (int)mip &lt; DT_MIPMAP_0)</a>
<a name="ln716">      return; // remove the (int) once we no longer have to support gcc &lt; 4.8 :/</a>
<a name="ln717">    char filename[PATH_MAX] = {0};</a>
<a name="ln718">    snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, key);</a>
<a name="ln719">    // don't attempt to load if disk cache doesn't exist</a>
<a name="ln720">    if(!g_file_test(filename, G_FILE_TEST_EXISTS)) return;</a>
<a name="ln721">    dt_control_add_job(darktable.control, DT_JOB_QUEUE_SYSTEM_FG, dt_image_load_job_create(imgid, mip));</a>
<a name="ln722">  }</a>
<a name="ln723">  else if(flags == DT_MIPMAP_BLOCKING)</a>
<a name="ln724">  {</a>
<a name="ln725">    // simple case: blocking get</a>
<a name="ln726">    dt_cache_entry_t *entry =  dt_cache_get_with_caller(&amp;_get_cache(cache, mip)-&gt;cache, key, mode, file, line);</a>
<a name="ln727"> </a>
<a name="ln728">    ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln729"> </a>
<a name="ln730">    struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln731">    buf-&gt;cache_entry = entry;</a>
<a name="ln732"> </a>
<a name="ln733">    int mipmap_generated = 0;</a>
<a name="ln734">    if(dsc-&gt;flags &amp; DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE)</a>
<a name="ln735">    {</a>
<a name="ln736">      mipmap_generated = 1;</a>
<a name="ln737"> </a>
<a name="ln738">      __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_fetches), 1);</a>
<a name="ln739">      // fprintf(stderr, &quot;[mipmap cache get] now initializing buffer for img %u mip %d!\n&quot;, imgid, mip);</a>
<a name="ln740">      // we're write locked here, as requested by the alloc callback.</a>
<a name="ln741">      // now fill it with data:</a>
<a name="ln742">      if(mip == DT_MIPMAP_FULL)</a>
<a name="ln743">      {</a>
<a name="ln744">        // load the image:</a>
<a name="ln745">        // make sure we access the r/w lock as shortly as possible!</a>
<a name="ln746">        dt_image_t buffered_image;</a>
<a name="ln747">        const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln748">        buffered_image = *cimg;</a>
<a name="ln749">        // dt_image_t *img = dt_image_cache_write_get(darktable.image_cache, cimg);</a>
<a name="ln750">        // dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln751">        dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln752"> </a>
<a name="ln753">        char filename[PATH_MAX] = { 0 };</a>
<a name="ln754">        gboolean from_cache = TRUE;</a>
<a name="ln755">        dt_image_full_path(buffered_image.id, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln756"> </a>
<a name="ln757">        buf-&gt;imgid = imgid;</a>
<a name="ln758">        buf-&gt;size = mip;</a>
<a name="ln759">        buf-&gt;buf = 0;</a>
<a name="ln760">        buf-&gt;width = buf-&gt;height = 0;</a>
<a name="ln761">        buf-&gt;iscale = 0.0f;</a>
<a name="ln762">        buf-&gt;color_space = DT_COLORSPACE_NONE; // TODO: does the full buffer need to know this?</a>
<a name="ln763">        dt_imageio_retval_t ret = dt_imageio_open(&amp;buffered_image, filename, buf); // TODO: color_space?</a>
<a name="ln764">        // might have been reallocated:</a>
<a name="ln765">        ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln766">        dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;cache_entry-&gt;data;</a>
<a name="ln767">        if(ret != DT_IMAGEIO_OK)</a>
<a name="ln768">        {</a>
<a name="ln769">          // fprintf(stderr, &quot;[mipmap read get] error loading image: %d\n&quot;, ret);</a>
<a name="ln770">          //</a>
<a name="ln771">          // we can only return a zero dimension buffer if the buffer has been allocated.</a>
<a name="ln772">          // in case dsc couldn't be allocated and points to the static buffer, it contains</a>
<a name="ln773">          // a dead image already.</a>
<a name="ln774">          if((void *)dsc != (void *)dt_mipmap_cache_static_dead_image)</a>
<a name="ln775">          {</a>
<a name="ln776">            dsc-&gt;width = dsc-&gt;height = 0;</a>
<a name="ln777">            buf-&gt;iscale = 0.0f;</a>
<a name="ln778">            dsc-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln779">          }</a>
<a name="ln780">        }</a>
<a name="ln781">        else</a>
<a name="ln782">        {</a>
<a name="ln783">          // swap back new image data:</a>
<a name="ln784">          dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln785">          *img = buffered_image;</a>
<a name="ln786">          // fprintf(stderr, &quot;[mipmap read get] initializing full buffer img %u with %u %u -&gt; %d %d (%p)\n&quot;,</a>
<a name="ln787">          // imgid, data[0], data[1], img-&gt;width, img-&gt;height, data);</a>
<a name="ln788">          // don't write xmp for this (we only changed db stuff):</a>
<a name="ln789">          dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln790">        }</a>
<a name="ln791">      }</a>
<a name="ln792">      else if(mip == DT_MIPMAP_F)</a>
<a name="ln793">      {</a>
<a name="ln794">        ASAN_UNPOISON_MEMORY_REGION(dsc + 1, dsc-&gt;size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln795">        _init_f(buf, (float *)(dsc + 1), &amp;dsc-&gt;width, &amp;dsc-&gt;height, &amp;dsc-&gt;iscale, imgid);</a>
<a name="ln796">      }</a>
<a name="ln797">      else</a>
<a name="ln798">      {</a>
<a name="ln799">        // 8-bit thumbs</a>
<a name="ln800">        ASAN_UNPOISON_MEMORY_REGION(dsc + 1, dsc-&gt;size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln801">        _init_8((uint8_t *)(dsc + 1), &amp;dsc-&gt;width, &amp;dsc-&gt;height, &amp;dsc-&gt;iscale, &amp;buf-&gt;color_space, imgid, mip);</a>
<a name="ln802">      }</a>
<a name="ln803">      dsc-&gt;color_space = buf-&gt;color_space;</a>
<a name="ln804">      dsc-&gt;flags &amp;= ~DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE;</a>
<a name="ln805">    }</a>
<a name="ln806"> </a>
<a name="ln807">    // image cache is leaving the write lock in place in case the image has been newly allocated.</a>
<a name="ln808">    // this leads to a slight increase in thread contention, so we opt for dropping the write lock</a>
<a name="ln809">    // and acquiring a read lock immediately after. since this opens a small window for other threads</a>
<a name="ln810">    // to get in between, we need to take some care to re-init cache entries and dsc.</a>
<a name="ln811">    // note that concurrencykit has rw locks that can be demoted from w-&gt;r without losing the lock in between.</a>
<a name="ln812">    if(mode == 'r')</a>
<a name="ln813">    {</a>
<a name="ln814">      entry-&gt;_lock_demoting = 1;</a>
<a name="ln815">      // drop the write lock</a>
<a name="ln816">      dt_cache_release(&amp;_get_cache(cache, mip)-&gt;cache, entry);</a>
<a name="ln817">      // get a read lock</a>
<a name="ln818">      buf-&gt;cache_entry = entry = dt_cache_get(&amp;_get_cache(cache, mip)-&gt;cache, key, mode);</a>
<a name="ln819">      ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln820">      entry-&gt;_lock_demoting = 0;</a>
<a name="ln821">      dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;cache_entry-&gt;data;</a>
<a name="ln822">    }</a>
<a name="ln823"> </a>
<a name="ln824">#ifdef _DEBUG</a>
<a name="ln825">    const pthread_t writer = dt_pthread_rwlock_get_writer(&amp;(buf-&gt;cache_entry-&gt;lock));</a>
<a name="ln826">    if(mode == 'w')</a>
<a name="ln827">    {</a>
<a name="ln828">      assert(pthread_equal(writer, pthread_self()));</a>
<a name="ln829">    }</a>
<a name="ln830">    else</a>
<a name="ln831">    {</a>
<a name="ln832">      assert(!pthread_equal(writer, pthread_self()));</a>
<a name="ln833">    }</a>
<a name="ln834">#endif</a>
<a name="ln835"> </a>
<a name="ln836">    if(mipmap_generated)</a>
<a name="ln837">    {</a>
<a name="ln838">      /* raise signal that mipmaps has been flushed to cache */</a>
<a name="ln839">      g_idle_add(_raise_signal_mipmap_updated, 0);</a>
<a name="ln840">    }</a>
<a name="ln841"> </a>
<a name="ln842">    buf-&gt;width = dsc-&gt;width;</a>
<a name="ln843">    buf-&gt;height = dsc-&gt;height;</a>
<a name="ln844">    buf-&gt;iscale = dsc-&gt;iscale;</a>
<a name="ln845">    buf-&gt;color_space = dsc-&gt;color_space;</a>
<a name="ln846">    buf-&gt;imgid = imgid;</a>
<a name="ln847">    buf-&gt;size = mip;</a>
<a name="ln848"> </a>
<a name="ln849">    ASAN_UNPOISON_MEMORY_REGION(dsc + 1, dsc-&gt;size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln850">    buf-&gt;buf = (uint8_t *)(dsc + 1);</a>
<a name="ln851"> </a>
<a name="ln852">    if(dsc-&gt;width == 0 || dsc-&gt;height == 0)</a>
<a name="ln853">    {</a>
<a name="ln854">      // fprintf(stderr, &quot;[mipmap cache get] got a zero-sized image for img %u mip %d!\n&quot;, imgid, mip);</a>
<a name="ln855">      if(mip &lt; DT_MIPMAP_F)</a>
<a name="ln856">        dead_image_8(buf);</a>
<a name="ln857">      else if(mip == DT_MIPMAP_F)</a>
<a name="ln858">        dead_image_f(buf);</a>
<a name="ln859">      else</a>
<a name="ln860">        buf-&gt;buf = NULL; // full images with NULL buffer have to be handled, indicates `missing image', but still return locked slot</a>
<a name="ln861">    }</a>
<a name="ln862">  }</a>
<a name="ln863">  else if(flags == DT_MIPMAP_BEST_EFFORT)</a>
<a name="ln864">  {</a>
<a name="ln865">    __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_requests), 1);</a>
<a name="ln866">    // best-effort, might also return NULL.</a>
<a name="ln867">    // never decrease mip level for float buffer or full image:</a>
<a name="ln868">    dt_mipmap_size_t min_mip = (mip &gt;= DT_MIPMAP_F) ? mip : DT_MIPMAP_0;</a>
<a name="ln869">    for(int k = mip; k &gt;= min_mip &amp;&amp; k &gt;= 0; k--)</a>
<a name="ln870">    {</a>
<a name="ln871">      // already loaded?</a>
<a name="ln872">      dt_mipmap_cache_get(cache, buf, imgid, k, DT_MIPMAP_TESTLOCK, 'r');</a>
<a name="ln873">      if(buf-&gt;buf &amp;&amp; buf-&gt;width &gt; 0 &amp;&amp; buf-&gt;height &gt; 0)</a>
<a name="ln874">      {</a>
<a name="ln875">        if(mip != k) __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_standin), 1);</a>
<a name="ln876">        return;</a>
<a name="ln877">      }</a>
<a name="ln878">      // didn't succeed the first time? prefetch for later!</a>
<a name="ln879">      if(mip == k)</a>
<a name="ln880">      {</a>
<a name="ln881">        __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_near_match), 1);</a>
<a name="ln882">        dt_mipmap_cache_get(cache, buf, imgid, mip, DT_MIPMAP_PREFETCH, 'r');</a>
<a name="ln883">      }</a>
<a name="ln884">    }</a>
<a name="ln885">    // couldn't find a smaller thumb, try larger ones only now (these will be slightly slower due to cairo rescaling):</a>
<a name="ln886">    dt_mipmap_size_t max_mip = (mip &gt;= DT_MIPMAP_F) ? mip : DT_MIPMAP_F-1;</a>
<a name="ln887">    for(int k = mip+1; k &lt;= max_mip; k++)</a>
<a name="ln888">    {</a>
<a name="ln889">      // already loaded?</a>
<a name="ln890">      dt_mipmap_cache_get(cache, buf, imgid, k, DT_MIPMAP_TESTLOCK, 'r');</a>
<a name="ln891">      if(buf-&gt;buf &amp;&amp; buf-&gt;width &gt; 0 &amp;&amp; buf-&gt;height &gt; 0)</a>
<a name="ln892">      {</a>
<a name="ln893">        __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_standin), 1);</a>
<a name="ln894">        return;</a>
<a name="ln895">      }</a>
<a name="ln896">    }</a>
<a name="ln897">    __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_misses), 1);</a>
<a name="ln898">    // in case we don't even have a disk cache for our requested thumbnail,</a>
<a name="ln899">    // prefetch at least mip0, in case we have that in the disk caches:</a>
<a name="ln900">    if(cache-&gt;cachedir[0])</a>
<a name="ln901">    {</a>
<a name="ln902">      char filename[PATH_MAX] = {0};</a>
<a name="ln903">      snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, key);</a>
<a name="ln904">      if(g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln905">        dt_mipmap_cache_get(cache, 0, imgid, DT_MIPMAP_0, DT_MIPMAP_PREFETCH_DISK, 0);</a>
<a name="ln906">    }</a>
<a name="ln907">    // nothing found :(</a>
<a name="ln908">    buf-&gt;buf = NULL;</a>
<a name="ln909">    buf-&gt;imgid = 0;</a>
<a name="ln910">    buf-&gt;size = DT_MIPMAP_NONE;</a>
<a name="ln911">    buf-&gt;width = buf-&gt;height = 0;</a>
<a name="ln912">    buf-&gt;iscale = 0.0f;</a>
<a name="ln913">    buf-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln914">  }</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917">void dt_mipmap_cache_write_get_with_caller(dt_mipmap_cache_t *cache, dt_mipmap_buffer_t *buf, const uint32_t imgid, const int mip, const char *file, int line)</a>
<a name="ln918">{</a>
<a name="ln919">  dt_mipmap_cache_get_with_caller(cache, buf, imgid, mip, DT_MIPMAP_BLOCKING, 'w', file, line);</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922">void dt_mipmap_cache_release_with_caller(dt_mipmap_cache_t *cache, dt_mipmap_buffer_t *buf, const char *file,</a>
<a name="ln923">                                         int line)</a>
<a name="ln924">{</a>
<a name="ln925">  if(buf-&gt;size == DT_MIPMAP_NONE) return;</a>
<a name="ln926">  assert(buf-&gt;imgid &gt; 0);</a>
<a name="ln927">  // assert(buf-&gt;size &gt;= DT_MIPMAP_0); // breaks gcc-4.6/4.7 build</a>
<a name="ln928">  assert(buf-&gt;size &lt; DT_MIPMAP_NONE);</a>
<a name="ln929">  assert(buf-&gt;cache_entry);</a>
<a name="ln930">  dt_cache_release_with_caller(&amp;_get_cache(cache, buf-&gt;size)-&gt;cache, buf-&gt;cache_entry, file, line);</a>
<a name="ln931">  buf-&gt;size = DT_MIPMAP_NONE;</a>
<a name="ln932">  buf-&gt;buf = NULL;</a>
<a name="ln933">}</a>
<a name="ln934"> </a>
<a name="ln935"> </a>
<a name="ln936">// return the closest mipmap size</a>
<a name="ln937">dt_mipmap_size_t dt_mipmap_cache_get_matching_size(const dt_mipmap_cache_t *cache, const int32_t width,</a>
<a name="ln938">                                                   const int32_t height)</a>
<a name="ln939">{</a>
<a name="ln940">  const double ppd = (darktable.gui != NULL) ? darktable.gui-&gt;ppd : 1.0;</a>
<a name="ln941"> </a>
<a name="ln942">  // find `best' match to width and height.</a>
<a name="ln943">  int32_t error = 0x7fffffff;</a>
<a name="ln944">  dt_mipmap_size_t best = DT_MIPMAP_NONE;</a>
<a name="ln945">  for(int k = DT_MIPMAP_0; k &lt; DT_MIPMAP_F; k++)</a>
<a name="ln946">  {</a>
<a name="ln947">    // find closest l1 norm:</a>
<a name="ln948">    int32_t new_error = cache-&gt;max_width[k] + cache-&gt;max_height[k] - width * ppd - height * ppd;</a>
<a name="ln949">    // and allow the first one to be larger in pixel size to override the smaller mip</a>
<a name="ln950">    if(abs(new_error) &lt; abs(error) || (error &lt; 0 &amp;&amp; new_error &gt; 0))</a>
<a name="ln951">    {</a>
<a name="ln952">      best = k;</a>
<a name="ln953">      error = new_error;</a>
<a name="ln954">    }</a>
<a name="ln955">  }</a>
<a name="ln956">  return best;</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959">void dt_mipmap_cache_remove(dt_mipmap_cache_t *cache, const uint32_t imgid)</a>
<a name="ln960">{</a>
<a name="ln961">  // get rid of all ldr thumbnails:</a>
<a name="ln962"> </a>
<a name="ln963">  for(dt_mipmap_size_t k = DT_MIPMAP_0; k &lt; DT_MIPMAP_F; k++)</a>
<a name="ln964">  {</a>
<a name="ln965">    const uint32_t key = get_key(imgid, k);</a>
<a name="ln966">    dt_cache_entry_t *entry = dt_cache_testget(&amp;_get_cache(cache, k)-&gt;cache, key, 'w');</a>
<a name="ln967">    if(entry)</a>
<a name="ln968">    {</a>
<a name="ln969">      ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln970">      struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln971">      dsc-&gt;flags |= DT_MIPMAP_BUFFER_DSC_FLAG_INVALIDATE;</a>
<a name="ln972">      dt_cache_release(&amp;_get_cache(cache, k)-&gt;cache, entry);</a>
<a name="ln973"> </a>
<a name="ln974">      // due to DT_MIPMAP_BUFFER_DSC_FLAG_INVALIDATE, removes thumbnail from disc</a>
<a name="ln975">      dt_cache_remove(&amp;_get_cache(cache, k)-&gt;cache, key);</a>
<a name="ln976">    }</a>
<a name="ln977">    else</a>
<a name="ln978">    {</a>
<a name="ln979">      // ugly, but avoids alloc'ing thumb if it is not there.</a>
<a name="ln980">      dt_mipmap_cache_unlink_ondisk_thumbnail((&amp;_get_cache(cache, k)-&gt;cache)-&gt;cleanup_data, imgid, k);</a>
<a name="ln981">    }</a>
<a name="ln982">  }</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985">void dt_mimap_cache_evict(dt_mipmap_cache_t *cache, const uint32_t imgid)</a>
<a name="ln986">{</a>
<a name="ln987">  for(dt_mipmap_size_t k = DT_MIPMAP_0; k &lt; DT_MIPMAP_F; k++)</a>
<a name="ln988">  {</a>
<a name="ln989">    const uint32_t key = get_key(imgid, k);</a>
<a name="ln990"> </a>
<a name="ln991">    // write thumbnail to disc if not existing there</a>
<a name="ln992">    dt_cache_remove(&amp;_get_cache(cache, k)-&gt;cache, key);</a>
<a name="ln993">  }</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996">static void _init_f(dt_mipmap_buffer_t *mipmap_buf, float *out, uint32_t *width, uint32_t *height, float *iscale,</a>
<a name="ln997">                    const uint32_t imgid)</a>
<a name="ln998">{</a>
<a name="ln999">  const uint32_t wd = *width, ht = *height;</a>
<a name="ln1000"> </a>
<a name="ln1001">  /* do not even try to process file if it isn't available */</a>
<a name="ln1002">  char filename[PATH_MAX] = { 0 };</a>
<a name="ln1003">  gboolean from_cache = TRUE;</a>
<a name="ln1004">  dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln1005">  if(!*filename || !g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln1006">  {</a>
<a name="ln1007">    *width = *height = 0;</a>
<a name="ln1008">    *iscale = 0.0f;</a>
<a name="ln1009">    return;</a>
<a name="ln1010">  }</a>
<a name="ln1011"> </a>
<a name="ln1012">  dt_mipmap_buffer_t buf;</a>
<a name="ln1013">  dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, DT_MIPMAP_FULL, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln1014"> </a>
<a name="ln1015">  // lock image after we have the buffer, we might need to lock the image struct for</a>
<a name="ln1016">  // writing during raw loading, to write to width/height.</a>
<a name="ln1017">  const dt_image_t *image = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1018"> </a>
<a name="ln1019">  dt_iop_roi_t roi_in, roi_out;</a>
<a name="ln1020">  roi_in.x = roi_in.y = 0;</a>
<a name="ln1021">  roi_in.width = image-&gt;width;</a>
<a name="ln1022">  roi_in.height = image-&gt;height;</a>
<a name="ln1023">  roi_in.scale = 1.0f;</a>
<a name="ln1024"> </a>
<a name="ln1025">  roi_out.x = roi_out.y = 0;</a>
<a name="ln1026"> </a>
<a name="ln1027">  // now let's figure out the scaling...</a>
<a name="ln1028"> </a>
<a name="ln1029">  // MIP_F is 4 channels, and we do not demosaic here</a>
<a name="ln1030">  const float coeff = (image-&gt;buf_dsc.filters) ? 2.0f : 1.0f;</a>
<a name="ln1031"> </a>
<a name="ln1032">  roi_out.scale = fminf((coeff * (float)wd) / (float)image-&gt;width, (coeff * (float)ht) / (float)image-&gt;height);</a>
<a name="ln1033">  roi_out.width = roi_out.scale * roi_in.width;</a>
<a name="ln1034">  roi_out.height = roi_out.scale * roi_in.height;</a>
<a name="ln1035"> </a>
<a name="ln1036">  if(!buf.buf)</a>
<a name="ln1037">  {</a>
<a name="ln1038">    dt_control_log(_(&quot;image `%s' is not available!&quot;), image-&gt;filename);</a>
<a name="ln1039">    dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1040">    *width = *height = 0;</a>
<a name="ln1041">    *iscale = 0.0f;</a>
<a name="ln1042">    return;</a>
<a name="ln1043">  }</a>
<a name="ln1044"> </a>
<a name="ln1045">  assert(!buffer_is_broken(&amp;buf));</a>
<a name="ln1046"> </a>
<a name="ln1047">  mipmap_buf-&gt;color_space = DT_COLORSPACE_NONE; // TODO: do we need that information in this buffer?</a>
<a name="ln1048"> </a>
<a name="ln1049">  if(image-&gt;buf_dsc.filters)</a>
<a name="ln1050">  {</a>
<a name="ln1051">    if(image-&gt;buf_dsc.filters != 9u &amp;&amp; image-&gt;buf_dsc.datatype == TYPE_FLOAT)</a>
<a name="ln1052">    {</a>
<a name="ln1053">      dt_iop_clip_and_zoom_mosaic_half_size_f((float *const)out, (const float *const)buf.buf, &amp;roi_out, &amp;roi_in,</a>
<a name="ln1054">                                              roi_out.width, roi_in.width, image-&gt;buf_dsc.filters);</a>
<a name="ln1055">    }</a>
<a name="ln1056">    else if(image-&gt;buf_dsc.filters != 9u &amp;&amp; image-&gt;buf_dsc.datatype == TYPE_UINT16)</a>
<a name="ln1057">    {</a>
<a name="ln1058">      dt_iop_clip_and_zoom_mosaic_half_size((uint16_t * const)out, (const uint16_t *)buf.buf, &amp;roi_out, &amp;roi_in,</a>
<a name="ln1059">                                            roi_out.width, roi_in.width, image-&gt;buf_dsc.filters);</a>
<a name="ln1060">    }</a>
<a name="ln1061">    else if(image-&gt;buf_dsc.filters == 9u &amp;&amp; image-&gt;buf_dsc.datatype == TYPE_UINT16)</a>
<a name="ln1062">    {</a>
<a name="ln1063">      dt_iop_clip_and_zoom_mosaic_third_size_xtrans((uint16_t * const)out, (const uint16_t *)buf.buf, &amp;roi_out,</a>
<a name="ln1064">                                                    &amp;roi_in, roi_out.width, roi_in.width, image-&gt;buf_dsc.xtrans);</a>
<a name="ln1065">    }</a>
<a name="ln1066">    else if(image-&gt;buf_dsc.filters == 9u &amp;&amp; image-&gt;buf_dsc.datatype == TYPE_FLOAT)</a>
<a name="ln1067">    {</a>
<a name="ln1068">      dt_iop_clip_and_zoom_mosaic_third_size_xtrans_f(out, (const float *)buf.buf, &amp;roi_out, &amp;roi_in,</a>
<a name="ln1069">                                                      roi_out.width, roi_in.width, image-&gt;buf_dsc.xtrans);</a>
<a name="ln1070">    }</a>
<a name="ln1071">    else</a>
<a name="ln1072">    {</a>
<a name="ln1073">      dt_unreachable_codepath();</a>
<a name="ln1074">    }</a>
<a name="ln1075">  }</a>
<a name="ln1076">  else</a>
<a name="ln1077">  {</a>
<a name="ln1078">    // downsample</a>
<a name="ln1079">    dt_iop_clip_and_zoom(out, (const float *)buf.buf, &amp;roi_out, &amp;roi_in, roi_out.width, roi_in.width);</a>
<a name="ln1080">  }</a>
<a name="ln1081"> </a>
<a name="ln1082">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln1083"> </a>
<a name="ln1084">  *width = roi_out.width;</a>
<a name="ln1085">  *height = roi_out.height;</a>
<a name="ln1086">  *iscale = (float)image-&gt;width / (float)roi_out.width;</a>
<a name="ln1087"> </a>
<a name="ln1088">  dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091"> </a>
<a name="ln1092">// dummy functions for `export' to mipmap buffers:</a>
<a name="ln1093">typedef struct _dummy_data_t</a>
<a name="ln1094">{</a>
<a name="ln1095">  dt_imageio_module_data_t head;</a>
<a name="ln1096">  uint8_t *buf;</a>
<a name="ln1097">} _dummy_data_t;</a>
<a name="ln1098"> </a>
<a name="ln1099">static int _levels(dt_imageio_module_data_t *data)</a>
<a name="ln1100">{</a>
<a name="ln1101">  return IMAGEIO_RGB | IMAGEIO_INT8;</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104">static int _bpp(dt_imageio_module_data_t *data)</a>
<a name="ln1105">{</a>
<a name="ln1106">  return 8;</a>
<a name="ln1107">}</a>
<a name="ln1108"> </a>
<a name="ln1109">static int _write_image(dt_imageio_module_data_t *data, const char *filename, const void *in,</a>
<a name="ln1110">                        dt_colorspaces_color_profile_type_t over_type, const char *over_filename,</a>
<a name="ln1111">                        void *exif, int exif_len, int imgid, int num, int total, dt_dev_pixelpipe_t *pipe)</a>
<a name="ln1112">{</a>
<a name="ln1113">  _dummy_data_t *d = (_dummy_data_t *)data;</a>
<a name="ln1114">  memcpy(d-&gt;buf, in, data-&gt;width * data-&gt;height * sizeof(uint32_t));</a>
<a name="ln1115">  return 0;</a>
<a name="ln1116">}</a>
<a name="ln1117"> </a>
<a name="ln1118">static void _init_8(uint8_t *buf, uint32_t *width, uint32_t *height, float *iscale,</a>
<a name="ln1119">                    dt_colorspaces_color_profile_type_t *color_space, const uint32_t imgid,</a>
<a name="ln1120">                    const dt_mipmap_size_t size)</a>
<a name="ln1121">{</a>
<a name="ln1122">  *iscale = 1.0f;</a>
<a name="ln1123">  const uint32_t wd = *width, ht = *height;</a>
<a name="ln1124">  char filename[PATH_MAX] = { 0 };</a>
<a name="ln1125">  gboolean from_cache = TRUE;</a>
<a name="ln1126"> </a>
<a name="ln1127">  /* do not even try to process file if it isn't available */</a>
<a name="ln1128">  dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln1129">  if(!*filename || !g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln1130">  {</a>
<a name="ln1131">    *width = *height = 0;</a>
<a name="ln1132">    *iscale = 0.0f;</a>
<a name="ln1133">    *color_space = DT_COLORSPACE_NONE;</a>
<a name="ln1134">    return;</a>
<a name="ln1135">  }</a>
<a name="ln1136"> </a>
<a name="ln1137">  const int altered = dt_image_altered(imgid);</a>
<a name="ln1138">  int res = 1;</a>
<a name="ln1139"> </a>
<a name="ln1140">  const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1141">  // the orientation for this camera is not read correctly from exiv2, so we need</a>
<a name="ln1142">  // to go the full path (as the thumbnail will be flipped the wrong way round)</a>
<a name="ln1143">  const int incompatible = !strncmp(cimg-&gt;exif_maker, &quot;Phase One&quot;, 9);</a>
<a name="ln1144">  dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1145"> </a>
<a name="ln1146">  if(!altered &amp;&amp; !dt_conf_get_bool(&quot;never_use_embedded_thumb&quot;) &amp;&amp; !incompatible)</a>
<a name="ln1147">  {</a>
<a name="ln1148">    const dt_image_orientation_t orientation = dt_image_get_orientation(imgid);</a>
<a name="ln1149"> </a>
<a name="ln1150">    // try to load the embedded thumbnail in raw</a>
<a name="ln1151">    from_cache = TRUE;</a>
<a name="ln1152">    memset(filename, 0, sizeof(filename));</a>
<a name="ln1153">    dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln1154"> </a>
<a name="ln1155">    const char *c = filename + strlen(filename);</a>
<a name="ln1156">    while(*c != '.' &amp;&amp; c &gt; filename) c--;</a>
<a name="ln1157">    if(!strcasecmp(c, &quot;.jpg&quot;))</a>
<a name="ln1158">    {</a>
<a name="ln1159">      // try to load jpg</a>
<a name="ln1160">      dt_imageio_jpeg_t jpg;</a>
<a name="ln1161">      if(!dt_imageio_jpeg_read_header(filename, &amp;jpg))</a>
<a name="ln1162">      {</a>
<a name="ln1163">        uint8_t *tmp = (uint8_t *)malloc(sizeof(uint8_t) * jpg.width * jpg.height * 4);</a>
<a name="ln1164">        *color_space = dt_imageio_jpeg_read_color_space(&amp;jpg);</a>
<a name="ln1165">        if(!dt_imageio_jpeg_read(&amp;jpg, tmp))</a>
<a name="ln1166">        {</a>
<a name="ln1167">          // scale to fit</a>
<a name="ln1168">          dt_iop_flip_and_zoom_8(tmp, jpg.width, jpg.height, buf, wd, ht, orientation, width, height);</a>
<a name="ln1169">          res = 0;</a>
<a name="ln1170">        }</a>
<a name="ln1171">        free(tmp);</a>
<a name="ln1172">      }</a>
<a name="ln1173">    }</a>
<a name="ln1174">    else</a>
<a name="ln1175">    {</a>
<a name="ln1176">      uint8_t *tmp = 0;</a>
<a name="ln1177">      int32_t thumb_width, thumb_height;</a>
<a name="ln1178">      res = dt_imageio_large_thumbnail(filename, &amp;tmp, &amp;thumb_width, &amp;thumb_height, color_space);</a>
<a name="ln1179">      if(!res)</a>
<a name="ln1180">      {</a>
<a name="ln1181">        // scale to fit</a>
<a name="ln1182">        dt_iop_flip_and_zoom_8(tmp, thumb_width, thumb_height, buf, wd, ht, orientation, width, height);</a>
<a name="ln1183">        free(tmp);</a>
<a name="ln1184">      }</a>
<a name="ln1185">    }</a>
<a name="ln1186">  }</a>
<a name="ln1187"> </a>
<a name="ln1188">  if(res)</a>
<a name="ln1189">  {</a>
<a name="ln1190">    //try to generate mip from larger mip</a>
<a name="ln1191">    for(dt_mipmap_size_t k = size + 1; k &lt;= DT_MIPMAP_7; k++)</a>
<a name="ln1192">    {</a>
<a name="ln1193">      dt_mipmap_buffer_t tmp;</a>
<a name="ln1194">      dt_mipmap_cache_get(darktable.mipmap_cache, &amp;tmp, imgid, k, DT_MIPMAP_TESTLOCK, 'r');</a>
<a name="ln1195">      if(tmp.buf == NULL)</a>
<a name="ln1196">        continue;</a>
<a name="ln1197">      dt_print(DT_DEBUG_CACHE, &quot;[_init_8] generate mip %d for %s from level %d\n&quot;, size, filename, k);</a>
<a name="ln1198">      *color_space = tmp.color_space;</a>
<a name="ln1199">      // downsample</a>
<a name="ln1200">      dt_iop_flip_and_zoom_8(tmp.buf, tmp.width, tmp.height, buf, wd, ht, ORIENTATION_NONE, width, height);</a>
<a name="ln1201"> </a>
<a name="ln1202">      dt_mipmap_cache_release(darktable.mipmap_cache, &amp;tmp);</a>
<a name="ln1203">      res = 0;</a>
<a name="ln1204">      break;</a>
<a name="ln1205">    }</a>
<a name="ln1206">  }</a>
<a name="ln1207"> </a>
<a name="ln1208">  if(res)</a>
<a name="ln1209">  {</a>
<a name="ln1210">    // try the real thing: rawspeed + pixelpipe</a>
<a name="ln1211">    dt_imageio_module_format_t format;</a>
<a name="ln1212">    _dummy_data_t dat;</a>
<a name="ln1213">    format.bpp = _bpp;</a>
<a name="ln1214">    format.write_image = _write_image;</a>
<a name="ln1215">    format.levels = _levels;</a>
<a name="ln1216">    dat.head.max_width = wd;</a>
<a name="ln1217">    dat.head.max_height = ht;</a>
<a name="ln1218">    dat.buf = buf;</a>
<a name="ln1219">    // export with flags: ignore exif (don't load from disk), don't swap byte order, don't do hq processing,</a>
<a name="ln1220">    // no upscaling and signal we want thumbnail export</a>
<a name="ln1221">    res = dt_imageio_export_with_flags(imgid, &quot;unused&quot;, &amp;format, (dt_imageio_module_data_t *)&amp;dat, TRUE, FALSE, FALSE,</a>
<a name="ln1222">                                       FALSE, TRUE, NULL, FALSE, DT_COLORSPACE_NONE, NULL, DT_INTENT_LAST, NULL, NULL,</a>
<a name="ln1223">                                       1, 1);</a>
<a name="ln1224">    if(!res)</a>
<a name="ln1225">    {</a>
<a name="ln1226">      // might be smaller, or have a different aspect than what we got as input.</a>
<a name="ln1227">      *width = dat.head.width;</a>
<a name="ln1228">      *height = dat.head.height;</a>
<a name="ln1229">      *iscale = 1.0f;</a>
<a name="ln1230">      *color_space = dt_mipmap_cache_get_colorspace();</a>
<a name="ln1231">    }</a>
<a name="ln1232">  }</a>
<a name="ln1233"> </a>
<a name="ln1234">  // fprintf(stderr, &quot;[mipmap init 8] export image %u finished (sizes %d %d =&gt; %d %d)!\n&quot;, imgid, wd, ht,</a>
<a name="ln1235">  // dat.head.width, dat.head.height);</a>
<a name="ln1236"> </a>
<a name="ln1237">  // any errors?</a>
<a name="ln1238">  if(res)</a>
<a name="ln1239">  {</a>
<a name="ln1240">    // fprintf(stderr, &quot;[mipmap_cache] could not process thumbnail!\n&quot;);</a>
<a name="ln1241">    *width = *height = 0;</a>
<a name="ln1242">    *iscale = 0.0f;</a>
<a name="ln1243">    *color_space = DT_COLORSPACE_NONE;</a>
<a name="ln1244">    return;</a>
<a name="ln1245">  }</a>
<a name="ln1246"> </a>
<a name="ln1247">  // TODO: various speed optimizations:</a>
<a name="ln1248">  // TODO: also init all smaller mips!</a>
<a name="ln1249">  // TODO: use mipf, but:</a>
<a name="ln1250">  // TODO: if output is cropped, don't use mipf!</a>
<a name="ln1251">}</a>
<a name="ln1252"> </a>
<a name="ln1253">dt_colorspaces_color_profile_type_t dt_mipmap_cache_get_colorspace()</a>
<a name="ln1254">{</a>
<a name="ln1255">  if(dt_conf_get_bool(&quot;cache_color_managed&quot;))</a>
<a name="ln1256">    return DT_COLORSPACE_ADOBERGB;</a>
<a name="ln1257">  return DT_COLORSPACE_DISPLAY;</a>
<a name="ln1258">}</a>
<a name="ln1259"> </a>
<a name="ln1260">void dt_mipmap_cache_copy_thumbnails(const dt_mipmap_cache_t *cache, const uint32_t dst_imgid, const uint32_t src_imgid)</a>
<a name="ln1261">{</a>
<a name="ln1262">  if(cache-&gt;cachedir[0] &amp;&amp; dt_conf_get_bool(&quot;cache_disk_backend&quot;))</a>
<a name="ln1263">  {</a>
<a name="ln1264">    for(dt_mipmap_size_t mip = DT_MIPMAP_0; mip &lt; DT_MIPMAP_F; mip++)</a>
<a name="ln1265">    {</a>
<a name="ln1266">      // try and load from disk, if successful set flag</a>
<a name="ln1267">      char srcpath[PATH_MAX] = {0};</a>
<a name="ln1268">      char dstpath[PATH_MAX] = {0};</a>
<a name="ln1269">      snprintf(srcpath, sizeof(srcpath), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, src_imgid);</a>
<a name="ln1270">      snprintf(dstpath, sizeof(dstpath), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, dst_imgid);</a>
<a name="ln1271">      GFile *src = g_file_new_for_path(srcpath);</a>
<a name="ln1272">      GFile *dst = g_file_new_for_path(dstpath);</a>
<a name="ln1273">      GError *gerror = NULL;</a>
<a name="ln1274">      g_file_copy(src, dst, G_FILE_COPY_NONE, NULL, NULL, NULL, &amp;gerror);</a>
<a name="ln1275">      // ignore errors, we tried what we could.</a>
<a name="ln1276">      g_object_unref(dst);</a>
<a name="ln1277">      g_object_unref(src);</a>
<a name="ln1278">      g_clear_error(&amp;gerror);</a>
<a name="ln1279">    }</a>
<a name="ln1280">  }</a>
<a name="ln1281">}</a>
<a name="ln1282"> </a>
<a name="ln1283">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1284">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1285">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="707"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: (int) mip < DT_MIPMAP_0.</p></div>
<div class="balloon" rel="715"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: (int) mip < DT_MIPMAP_0.</p></div>
<div class="balloon" rel="869"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: k >= 0.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
