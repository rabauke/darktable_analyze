
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln22">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln23">#include &quot;common/darktable.h&quot;</a>
<a name="ln24">#include &quot;common/debug.h&quot;</a>
<a name="ln25">#include &quot;common/opencl.h&quot;</a>
<a name="ln26">#include &quot;control/conf.h&quot;</a>
<a name="ln27">#include &quot;control/control.h&quot;</a>
<a name="ln28">#include &quot;develop/develop.h&quot;</a>
<a name="ln29">#include &quot;dtgtk/drawingarea.h&quot;</a>
<a name="ln30">#include &quot;gui/draw.h&quot;</a>
<a name="ln31">#include &quot;gui/gtk.h&quot;</a>
<a name="ln32">#include &quot;gui/presets.h&quot;</a>
<a name="ln33">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;inttypes.h&gt;</a>
<a name="ln36">#include &lt;math.h&gt;</a>
<a name="ln37">#include &lt;stdlib.h&gt;</a>
<a name="ln38">#include &lt;string.h&gt;</a>
<a name="ln39"> </a>
<a name="ln40">DT_MODULE_INTROSPECTION(3, dt_iop_colorzones_params_t)</a>
<a name="ln41"> </a>
<a name="ln42">#define DT_IOP_COLORZONES_INSET DT_PIXEL_APPLY_DPI(5)</a>
<a name="ln43">#define DT_IOP_COLORZONES_CURVE_INFL .3f</a>
<a name="ln44">#define DT_IOP_COLORZONES_RES 64</a>
<a name="ln45">#define DT_IOP_COLORZONES_LUT_RES 0x10000</a>
<a name="ln46"> </a>
<a name="ln47">#define DT_IOP_COLORZONES_BANDS 8</a>
<a name="ln48">#define DT_IOP_COLORZONES1_BANDS 6</a>
<a name="ln49"> </a>
<a name="ln50">typedef enum dt_iop_colorzones_channel_t</a>
<a name="ln51">{</a>
<a name="ln52">  DT_IOP_COLORZONES_L = 0,</a>
<a name="ln53">  DT_IOP_COLORZONES_C = 1,</a>
<a name="ln54">  DT_IOP_COLORZONES_h = 2</a>
<a name="ln55">} dt_iop_colorzones_channel_t;</a>
<a name="ln56"> </a>
<a name="ln57">typedef struct dt_iop_colorzones_params_t</a>
<a name="ln58">{</a>
<a name="ln59">  int32_t channel;</a>
<a name="ln60">  float equalizer_x[3][DT_IOP_COLORZONES_BANDS], equalizer_y[3][DT_IOP_COLORZONES_BANDS];</a>
<a name="ln61">  float strength;</a>
<a name="ln62">} dt_iop_colorzones_params_t;</a>
<a name="ln63"> </a>
<a name="ln64">typedef struct dt_iop_colorzones_params2_t</a>
<a name="ln65">{</a>
<a name="ln66">  int32_t channel;</a>
<a name="ln67">  float equalizer_x[3][DT_IOP_COLORZONES_BANDS], equalizer_y[3][DT_IOP_COLORZONES_BANDS];</a>
<a name="ln68">} dt_iop_colorzones_params2_t;</a>
<a name="ln69"> </a>
<a name="ln70">typedef struct dt_iop_colorzones_params1_t</a>
<a name="ln71">{</a>
<a name="ln72">  int32_t channel;</a>
<a name="ln73">  float equalizer_x[3][DT_IOP_COLORZONES1_BANDS], equalizer_y[3][DT_IOP_COLORZONES1_BANDS];</a>
<a name="ln74">} dt_iop_colorzones_params1_t;</a>
<a name="ln75"> </a>
<a name="ln76">typedef struct dt_iop_colorzones_gui_data_t</a>
<a name="ln77">{</a>
<a name="ln78">  dt_draw_curve_t *minmax_curve; // curve for gui to draw</a>
<a name="ln79">  GtkBox *hbox;</a>
<a name="ln80">  GtkDrawingArea *area;</a>
<a name="ln81">  GtkNotebook *channel_tabs;</a>
<a name="ln82">  GtkWidget *select_by;</a>
<a name="ln83">  GtkWidget *strength;</a>
<a name="ln84">  double mouse_x, mouse_y, mouse_pick;</a>
<a name="ln85">  float mouse_radius;</a>
<a name="ln86">  dt_iop_colorzones_params_t drag_params;</a>
<a name="ln87">  int dragging;</a>
<a name="ln88">  int x_move;</a>
<a name="ln89">  GtkWidget *colorpicker;</a>
<a name="ln90">  dt_iop_colorzones_channel_t channel;</a>
<a name="ln91">  float draw_xs[DT_IOP_COLORZONES_RES], draw_ys[DT_IOP_COLORZONES_RES];</a>
<a name="ln92">  float draw_min_xs[DT_IOP_COLORZONES_RES], draw_min_ys[DT_IOP_COLORZONES_RES];</a>
<a name="ln93">  float draw_max_xs[DT_IOP_COLORZONES_RES], draw_max_ys[DT_IOP_COLORZONES_RES];</a>
<a name="ln94">  float band_hist[DT_IOP_COLORZONES_BANDS];</a>
<a name="ln95">  float band_max;</a>
<a name="ln96">  cmsHTRANSFORM xform;</a>
<a name="ln97">} dt_iop_colorzones_gui_data_t;</a>
<a name="ln98"> </a>
<a name="ln99">typedef struct dt_iop_colorzones_data_t</a>
<a name="ln100">{</a>
<a name="ln101">  dt_draw_curve_t *curve[3];</a>
<a name="ln102">  dt_iop_colorzones_channel_t channel;</a>
<a name="ln103">  float lut[4][DT_IOP_COLORZONES_LUT_RES];</a>
<a name="ln104">} dt_iop_colorzones_data_t;</a>
<a name="ln105"> </a>
<a name="ln106">typedef struct dt_iop_colorzones_global_data_t</a>
<a name="ln107">{</a>
<a name="ln108">  int kernel_colorzones;</a>
<a name="ln109">} dt_iop_colorzones_global_data_t;</a>
<a name="ln110"> </a>
<a name="ln111"> </a>
<a name="ln112">const char *name()</a>
<a name="ln113">{</a>
<a name="ln114">  return _(&quot;color zones&quot;);</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">int flags()</a>
<a name="ln118">{</a>
<a name="ln119">  return IOP_FLAGS_INCLUDE_IN_STYLES | IOP_FLAGS_SUPPORTS_BLENDING | IOP_FLAGS_ALLOW_TILING;</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">int default_group()</a>
<a name="ln123">{</a>
<a name="ln124">  return IOP_GROUP_COLOR;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln128">                  void *new_params, const int new_version)</a>
<a name="ln129">{</a>
<a name="ln130">  if(old_version == 1 &amp;&amp; new_version == 3)</a>
<a name="ln131">  {</a>
<a name="ln132">    const dt_iop_colorzones_params1_t *old = old_params;</a>
<a name="ln133">    dt_iop_colorzones_params_t *new = new_params;</a>
<a name="ln134"> </a>
<a name="ln135">    new-&gt;channel = old-&gt;channel;</a>
<a name="ln136"> </a>
<a name="ln137">    // keep first point</a>
<a name="ln138"> </a>
<a name="ln139">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln140">    {</a>
<a name="ln141">      new-&gt;equalizer_x[i][0] = old-&gt;equalizer_x[i][0];</a>
<a name="ln142">      new-&gt;equalizer_y[i][0] = old-&gt;equalizer_y[i][0];</a>
<a name="ln143">    }</a>
<a name="ln144"> </a>
<a name="ln145">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln146">      for(int k = 0; k &lt; 6; k++)</a>
<a name="ln147">      {</a>
<a name="ln148">        //  first+1 and last-1 are set to just after and before the first and last point</a>
<a name="ln149">        if(k == 0)</a>
<a name="ln150">          new-&gt;equalizer_x[i][k + 1] = old-&gt;equalizer_x[i][k] + 0.001;</a>
<a name="ln151">        else if(k == 5)</a>
<a name="ln152">          new-&gt;equalizer_x[i][k + 1] = old-&gt;equalizer_x[i][k] - 0.001;</a>
<a name="ln153">        else</a>
<a name="ln154">          new-&gt;equalizer_x[i][k + 1] = old-&gt;equalizer_x[i][k];</a>
<a name="ln155">        new-&gt;equalizer_y[i][k + 1] = old-&gt;equalizer_y[i][k];</a>
<a name="ln156">      }</a>
<a name="ln157"> </a>
<a name="ln158">    // keep last point</a>
<a name="ln159"> </a>
<a name="ln160">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln161">    {</a>
<a name="ln162">      new-&gt;equalizer_x[i][7] = old-&gt;equalizer_x[i][5];</a>
<a name="ln163">      new-&gt;equalizer_y[i][7] = old-&gt;equalizer_y[i][5];</a>
<a name="ln164">    }</a>
<a name="ln165">    new-&gt;strength = 0.0;</a>
<a name="ln166">    return 0;</a>
<a name="ln167">  }</a>
<a name="ln168">  if(old_version == 2 &amp;&amp; new_version == 3)</a>
<a name="ln169">  {</a>
<a name="ln170">    const dt_iop_colorzones_params2_t *old = old_params;</a>
<a name="ln171">    dt_iop_colorzones_params_t *new = new_params;</a>
<a name="ln172">    new-&gt;channel = old-&gt;channel;</a>
<a name="ln173"> </a>
<a name="ln174">    for(int b = 0; b &lt; DT_IOP_COLORZONES_BANDS; b++)</a>
<a name="ln175">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln176">      {</a>
<a name="ln177">        new-&gt;equalizer_x[c][b] = old-&gt;equalizer_x[c][b];</a>
<a name="ln178">        new-&gt;equalizer_y[c][b] = old-&gt;equalizer_y[c][b];</a>
<a name="ln179">      }</a>
<a name="ln180">    new-&gt;strength = 0.0;</a>
<a name="ln181">    return 0;</a>
<a name="ln182">  }</a>
<a name="ln183">  return 1;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">static float lookup(const float *lut, const float i)</a>
<a name="ln187">{</a>
<a name="ln188">  const int bin0 = MIN(0xffff, MAX(0, (int)(DT_IOP_COLORZONES_LUT_RES * i)));</a>
<a name="ln189">  const int bin1 = MIN(0xffff, MAX(0, (int)(DT_IOP_COLORZONES_LUT_RES * i) + 1));</a>
<a name="ln190">  const float f = DT_IOP_COLORZONES_LUT_RES * i - bin0;</a>
<a name="ln191">  return lut[bin1] * f + lut[bin0] * (1. - f);</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">static float strength(float value, float strength)</a>
<a name="ln195">{</a>
<a name="ln196">  return value + (value - 0.5) * (strength / 100.0);</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o,</a>
<a name="ln200">             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln201">{</a>
<a name="ln202">  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)(piece-&gt;data);</a>
<a name="ln203">  const int ch = piece-&gt;colors;</a>
<a name="ln204">#ifdef _OPENMP</a>
<a name="ln205">#pragma omp parallel for default(none) schedule(static) shared(d)</a>
<a name="ln206">#endif</a>
<a name="ln207">  for(size_t k = 0; k &lt; (size_t)roi_out-&gt;width * roi_out-&gt;height; k++)</a>
<a name="ln208">  {</a>
<a name="ln209">    float *in = (float *)i + ch * k;</a>
<a name="ln210">    float *out = (float *)o + ch * k;</a>
<a name="ln211">    const float a = in[1], b = in[2];</a>
<a name="ln212">    const float h = fmodf(atan2f(b, a) + 2.0 * M_PI, 2.0 * M_PI) / (2.0 * M_PI);</a>
<a name="ln213">    const float C = sqrtf(b * b + a * a);</a>
<a name="ln214">    float select = 0.0f;</a>
<a name="ln215">    float blend = 0.0f;</a>
<a name="ln216">    switch(d-&gt;channel)</a>
<a name="ln217">    {</a>
<a name="ln218">      case DT_IOP_COLORZONES_L:</a>
<a name="ln219">        select = fminf(1.0, in[0] / 100.0);</a>
<a name="ln220">        break;</a>
<a name="ln221">      case DT_IOP_COLORZONES_C:</a>
<a name="ln222">        select = fminf(1.0, C / 128.0);</a>
<a name="ln223">        break;</a>
<a name="ln224">      default:</a>
<a name="ln225">      case DT_IOP_COLORZONES_h:</a>
<a name="ln226">        select = h;</a>
<a name="ln227">        blend = powf(1.0f - C / 128.0f, 2.0f);</a>
<a name="ln228">        break;</a>
<a name="ln229">    }</a>
<a name="ln230">    const float Lm = (blend * .5f + (1.0f - blend) * lookup(d-&gt;lut[0], select)) - .5f;</a>
<a name="ln231">    const float hm = (blend * .5f + (1.0f - blend) * lookup(d-&gt;lut[2], select)) - .5f;</a>
<a name="ln232">    blend *= blend; // saturation isn't as prone to artifacts:</a>
<a name="ln233">    // const float Cm = 2.0 * (blend*.5f + (1.0f-blend)*lookup(d-&gt;lut[1], select));</a>
<a name="ln234">    const float Cm = 2.0 * lookup(d-&gt;lut[1], select);</a>
<a name="ln235">    const float L = in[0] * powf(2.0f, 4.0f * Lm);</a>
<a name="ln236">    out[0] = L;</a>
<a name="ln237">    out[1] = cosf(2.0 * M_PI * (h + hm)) * Cm * C;</a>
<a name="ln238">    out[2] = sinf(2.0 * M_PI * (h + hm)) * Cm * C;</a>
<a name="ln239">    out[3] = in[3];</a>
<a name="ln240">  }</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243">#ifdef HAVE_OPENCL</a>
<a name="ln244">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln245">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln246">{</a>
<a name="ln247">  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)piece-&gt;data;</a>
<a name="ln248">  dt_iop_colorzones_global_data_t *gd = (dt_iop_colorzones_global_data_t *)self-&gt;data;</a>
<a name="ln249">  cl_mem dev_L, dev_a, dev_b = NULL;</a>
<a name="ln250">  cl_int err = -999;</a>
<a name="ln251"> </a>
<a name="ln252">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln253">  const int width = roi_in-&gt;width;</a>
<a name="ln254">  const int height = roi_in-&gt;height;</a>
<a name="ln255"> </a>
<a name="ln256">  size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln257">  dev_L = dt_opencl_copy_host_to_device(devid, d-&gt;lut[0], 256, 256, sizeof(float));</a>
<a name="ln258">  dev_a = dt_opencl_copy_host_to_device(devid, d-&gt;lut[1], 256, 256, sizeof(float));</a>
<a name="ln259">  dev_b = dt_opencl_copy_host_to_device(devid, d-&gt;lut[2], 256, 256, sizeof(float));</a>
<a name="ln260">  if(dev_L == NULL || dev_a == NULL || dev_b == NULL) goto error;</a>
<a name="ln261"> </a>
<a name="ln262">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorzones, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln263">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorzones, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln264">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorzones, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln265">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorzones, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln266">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorzones, 4, sizeof(int), (void *)&amp;d-&gt;channel);</a>
<a name="ln267">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorzones, 5, sizeof(cl_mem), (void *)&amp;dev_L);</a>
<a name="ln268">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorzones, 6, sizeof(cl_mem), (void *)&amp;dev_a);</a>
<a name="ln269">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorzones, 7, sizeof(cl_mem), (void *)&amp;dev_b);</a>
<a name="ln270">  err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_colorzones, sizes);</a>
<a name="ln271"> </a>
<a name="ln272">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln273">  dt_opencl_release_mem_object(dev_L);</a>
<a name="ln274">  dt_opencl_release_mem_object(dev_a);</a>
<a name="ln275">  dt_opencl_release_mem_object(dev_b);</a>
<a name="ln276">  return TRUE;</a>
<a name="ln277"> </a>
<a name="ln278">error:</a>
<a name="ln279">  dt_opencl_release_mem_object(dev_L);</a>
<a name="ln280">  dt_opencl_release_mem_object(dev_a);</a>
<a name="ln281">  dt_opencl_release_mem_object(dev_b);</a>
<a name="ln282">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_colorzones] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln283">  return FALSE;</a>
<a name="ln284">}</a>
<a name="ln285">#endif</a>
<a name="ln286"> </a>
<a name="ln287">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln288">{</a>
<a name="ln289">  const int program = 2; // basic.cl, from programs.conf</a>
<a name="ln290">  dt_iop_colorzones_global_data_t *gd</a>
<a name="ln291">      = (dt_iop_colorzones_global_data_t *)malloc(sizeof(dt_iop_colorzones_global_data_t));</a>
<a name="ln292">  module-&gt;data = gd;</a>
<a name="ln293">  gd-&gt;kernel_colorzones = dt_opencl_create_kernel(program, &quot;colorzones&quot;);</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln297">{</a>
<a name="ln298">  dt_iop_colorzones_global_data_t *gd = (dt_iop_colorzones_global_data_t *)module-&gt;data;</a>
<a name="ln299">  dt_opencl_free_kernel(gd-&gt;kernel_colorzones);</a>
<a name="ln300">  free(module-&gt;data);</a>
<a name="ln301">  module-&gt;data = NULL;</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln305">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln306">{</a>
<a name="ln307">  // pull in new params to pipe</a>
<a name="ln308">  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)(piece-&gt;data);</a>
<a name="ln309">  dt_iop_colorzones_params_t *p = (dt_iop_colorzones_params_t *)p1;</a>
<a name="ln310"> </a>
<a name="ln311">#if 0 // print new preset</a>
<a name="ln312">  printf(&quot;p.channel = %d;\n&quot;, p-&gt;channel);</a>
<a name="ln313">  for(int k=0; k&lt;3; k++) for(int i=0; i&lt;DT_IOP_COLORZONES_BANDS; i++)</a>
<a name="ln314">    {</a>
<a name="ln315">      printf(&quot;p.equalizer_x[%d][%i] = %f;\n&quot;, k, i, p-&gt;equalizer_x[k][i]);</a>
<a name="ln316">      printf(&quot;p.equalizer_y[%d][%i] = %f;\n&quot;, k, i, p-&gt;equalizer_y[k][i]);</a>
<a name="ln317">    }</a>
<a name="ln318">#endif</a>
<a name="ln319">  d-&gt;channel = (dt_iop_colorzones_channel_t)p-&gt;channel;</a>
<a name="ln320">  for(int ch = 0; ch &lt; 3; ch++)</a>
<a name="ln321">  {</a>
<a name="ln322">    if(d-&gt;channel == DT_IOP_COLORZONES_h)</a>
<a name="ln323">      dt_draw_curve_set_point(d-&gt;curve[ch], 0, p-&gt;equalizer_x[ch][DT_IOP_COLORZONES_BANDS - 2] - 1.0,</a>
<a name="ln324">                              strength(p-&gt;equalizer_y[ch][DT_IOP_COLORZONES_BANDS - 2], p-&gt;strength));</a>
<a name="ln325">    else</a>
<a name="ln326">      dt_draw_curve_set_point(d-&gt;curve[ch], 0, p-&gt;equalizer_x[ch][DT_IOP_COLORZONES_BANDS - 2] - 1.0,</a>
<a name="ln327">                              strength(p-&gt;equalizer_y[ch][0], p-&gt;strength));</a>
<a name="ln328">    for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln329">      dt_draw_curve_set_point(d-&gt;curve[ch], k + 1, p-&gt;equalizer_x[ch][k],</a>
<a name="ln330">                              strength(p-&gt;equalizer_y[ch][k], p-&gt;strength));</a>
<a name="ln331">    if(d-&gt;channel == DT_IOP_COLORZONES_h)</a>
<a name="ln332">      dt_draw_curve_set_point(d-&gt;curve[ch], DT_IOP_COLORZONES_BANDS + 1, p-&gt;equalizer_x[ch][1] + 1.0,</a>
<a name="ln333">                              strength(p-&gt;equalizer_y[ch][1], p-&gt;strength));</a>
<a name="ln334">    else</a>
<a name="ln335">      dt_draw_curve_set_point(d-&gt;curve[ch], DT_IOP_COLORZONES_BANDS + 1, p-&gt;equalizer_x[ch][1] + 1.0,</a>
<a name="ln336">                              strength(p-&gt;equalizer_y[ch][DT_IOP_COLORZONES_BANDS - 1], p-&gt;strength));</a>
<a name="ln337">    dt_draw_curve_calc_values(d-&gt;curve[ch], 0.0, 1.0, DT_IOP_COLORZONES_LUT_RES, d-&gt;lut[3], d-&gt;lut[ch]);</a>
<a name="ln338">  }</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln342">{</a>
<a name="ln343">  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)malloc(sizeof(dt_iop_colorzones_data_t));</a>
<a name="ln344">  dt_iop_colorzones_params_t *default_params = (dt_iop_colorzones_params_t *)self-&gt;default_params;</a>
<a name="ln345">  piece-&gt;data = (void *)d;</a>
<a name="ln346">  for(int ch = 0; ch &lt; 3; ch++)</a>
<a name="ln347">  {</a>
<a name="ln348">    d-&gt;curve[ch] = dt_draw_curve_new(0.0, 1.0, CATMULL_ROM);</a>
<a name="ln349">    (void)dt_draw_curve_add_point(d-&gt;curve[ch],</a>
<a name="ln350">                                  default_params-&gt;equalizer_x[ch][DT_IOP_COLORZONES_BANDS - 2] - 1.0,</a>
<a name="ln351">                                  default_params-&gt;equalizer_y[ch][DT_IOP_COLORZONES_BANDS - 2]);</a>
<a name="ln352">    for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln353">      (void)dt_draw_curve_add_point(d-&gt;curve[ch], default_params-&gt;equalizer_x[ch][k],</a>
<a name="ln354">                                    default_params-&gt;equalizer_y[ch][k]);</a>
<a name="ln355">    (void)dt_draw_curve_add_point(d-&gt;curve[ch], default_params-&gt;equalizer_x[ch][1] + 1.0,</a>
<a name="ln356">                                  default_params-&gt;equalizer_y[ch][1]);</a>
<a name="ln357">  }</a>
<a name="ln358">  d-&gt;channel = (dt_iop_colorzones_channel_t)default_params-&gt;channel;</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln362">{</a>
<a name="ln363">// clean up everything again.</a>
<a name="ln364">  dt_iop_colorzones_data_t *d = (dt_iop_colorzones_data_t *)(piece-&gt;data);</a>
<a name="ln365"> </a>
<a name="ln366">  for(int ch = 0; ch &lt; 3; ch++) dt_draw_curve_destroy(d-&gt;curve[ch]);</a>
<a name="ln367">  free(piece-&gt;data);</a>
<a name="ln368">  piece-&gt;data = NULL;</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">void gui_reset(struct dt_iop_module_t *self)</a>
<a name="ln372">{</a>
<a name="ln373">  dt_iop_colorzones_gui_data_t *g = (dt_iop_colorzones_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln374">  self-&gt;request_color_pick = DT_REQUEST_COLORPICK_OFF;</a>
<a name="ln375">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;colorpicker), 0);</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln379">{</a>
<a name="ln380">  dt_iop_colorzones_gui_data_t *g = (dt_iop_colorzones_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln381">  dt_iop_colorzones_params_t *p = (dt_iop_colorzones_params_t *)self-&gt;params;</a>
<a name="ln382">  dt_bauhaus_combobox_set(g-&gt;select_by, 2 - p-&gt;channel);</a>
<a name="ln383">  dt_bauhaus_slider_set(g-&gt;strength, p-&gt;strength);</a>
<a name="ln384">  gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln385"> </a>
<a name="ln386">  if (self-&gt;request_color_pick == DT_REQUEST_COLORPICK_OFF)</a>
<a name="ln387">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;colorpicker), 0);</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">void init(dt_iop_module_t *module)</a>
<a name="ln391">{</a>
<a name="ln392">  module-&gt;params = calloc(1, sizeof(dt_iop_colorzones_params_t));</a>
<a name="ln393">  module-&gt;default_params = calloc(1, sizeof(dt_iop_colorzones_params_t));</a>
<a name="ln394">  module-&gt;default_enabled = 0; // we're a rather slow and rare op.</a>
<a name="ln395">  module-&gt;priority = 599; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln396">  module-&gt;params_size = sizeof(dt_iop_colorzones_params_t);</a>
<a name="ln397">  module-&gt;gui_data = NULL;</a>
<a name="ln398">  dt_iop_colorzones_params_t tmp;</a>
<a name="ln399">  for(int ch = 0; ch &lt; 3; ch++)</a>
<a name="ln400">  {</a>
<a name="ln401">    for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln402">      tmp.equalizer_x[ch][k] = k / (DT_IOP_COLORZONES_BANDS - 1.0);</a>
<a name="ln403">    for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++) tmp.equalizer_y[ch][k] = 0.5f;</a>
<a name="ln404">  }</a>
<a name="ln405">  tmp.strength = 0.0;</a>
<a name="ln406">  tmp.channel = DT_IOP_COLORZONES_h;</a>
<a name="ln407">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_colorzones_params_t));</a>
<a name="ln408">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_colorzones_params_t));</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">void cleanup(dt_iop_module_t *module)</a>
<a name="ln412">{</a>
<a name="ln413">  free(module-&gt;params);</a>
<a name="ln414">  module-&gt;params = NULL;</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">void init_presets(dt_iop_module_so_t *self)</a>
<a name="ln418">{</a>
<a name="ln419">  dt_iop_colorzones_params_t p;</a>
<a name="ln420"> </a>
<a name="ln421">  p.strength = 0.0;</a>
<a name="ln422"> </a>
<a name="ln423">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;BEGIN&quot;, NULL, NULL, NULL);</a>
<a name="ln424"> </a>
<a name="ln425">  // red black white</a>
<a name="ln426"> </a>
<a name="ln427">  p.channel = DT_IOP_COLORZONES_h;</a>
<a name="ln428">  for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln429">  {</a>
<a name="ln430">    p.equalizer_y[DT_IOP_COLORZONES_L][k] = .5f;</a>
<a name="ln431">    p.equalizer_y[DT_IOP_COLORZONES_C][k] = .0f;</a>
<a name="ln432">    p.equalizer_y[DT_IOP_COLORZONES_h][k] = .5f;</a>
<a name="ln433">    p.equalizer_x[DT_IOP_COLORZONES_L][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln434">    p.equalizer_x[DT_IOP_COLORZONES_C][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln435">    p.equalizer_x[DT_IOP_COLORZONES_h][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln436">  }</a>
<a name="ln437">  p.equalizer_y[DT_IOP_COLORZONES_C][0] = p.equalizer_y[DT_IOP_COLORZONES_C][DT_IOP_COLORZONES_BANDS - 1]</a>
<a name="ln438">      = 0.65;</a>
<a name="ln439">  p.equalizer_x[DT_IOP_COLORZONES_C][1] = 3. / 16.;</a>
<a name="ln440">  p.equalizer_x[DT_IOP_COLORZONES_C][3] = 0.50;</a>
<a name="ln441">  p.equalizer_x[DT_IOP_COLORZONES_C][4] = 0.51;</a>
<a name="ln442">  p.equalizer_x[DT_IOP_COLORZONES_C][6] = 15. / 16.;</a>
<a name="ln443">  dt_gui_presets_add_generic(_(&quot;red black white&quot;), self-&gt;op, 3, &amp;p, sizeof(p), 1);</a>
<a name="ln444"> </a>
<a name="ln445">  // black white and skin tones</a>
<a name="ln446"> </a>
<a name="ln447">  p.channel = DT_IOP_COLORZONES_h;</a>
<a name="ln448">  for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln449">  {</a>
<a name="ln450">    p.equalizer_y[DT_IOP_COLORZONES_L][k] = .5f;</a>
<a name="ln451">    p.equalizer_y[DT_IOP_COLORZONES_C][k] = .0f;</a>
<a name="ln452">    p.equalizer_y[DT_IOP_COLORZONES_h][k] = .5f;</a>
<a name="ln453">    p.equalizer_x[DT_IOP_COLORZONES_L][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln454">    p.equalizer_x[DT_IOP_COLORZONES_C][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln455">    p.equalizer_x[DT_IOP_COLORZONES_h][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln456">  }</a>
<a name="ln457">  p.equalizer_y[DT_IOP_COLORZONES_C][0] = p.equalizer_y[DT_IOP_COLORZONES_C][DT_IOP_COLORZONES_BANDS - 1]</a>
<a name="ln458">      = 0.5;</a>
<a name="ln459">  p.equalizer_x[DT_IOP_COLORZONES_C][2] = 0.25f;</a>
<a name="ln460">  p.equalizer_x[DT_IOP_COLORZONES_C][1] = 0.16f;</a>
<a name="ln461">  p.equalizer_y[DT_IOP_COLORZONES_C][1] = 0.3f;</a>
<a name="ln462">  dt_gui_presets_add_generic(_(&quot;black white and skin tones&quot;), self-&gt;op, 3, &amp;p, sizeof(p), 1);</a>
<a name="ln463"> </a>
<a name="ln464">  // polarizing filter</a>
<a name="ln465"> </a>
<a name="ln466">  p.channel = DT_IOP_COLORZONES_C;</a>
<a name="ln467">  for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln468">  {</a>
<a name="ln469">    p.equalizer_y[DT_IOP_COLORZONES_L][k] = .5f;</a>
<a name="ln470">    p.equalizer_y[DT_IOP_COLORZONES_C][k] = .5f;</a>
<a name="ln471">    p.equalizer_y[DT_IOP_COLORZONES_h][k] = .5f;</a>
<a name="ln472">    p.equalizer_x[DT_IOP_COLORZONES_L][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln473">    p.equalizer_x[DT_IOP_COLORZONES_C][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln474">    p.equalizer_x[DT_IOP_COLORZONES_h][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln475">  }</a>
<a name="ln476">  for(int k = 3; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln477">    p.equalizer_y[DT_IOP_COLORZONES_C][k] += (k - 2.5) / (DT_IOP_COLORZONES_BANDS - 2.0) * 0.25;</a>
<a name="ln478">  for(int k = 4; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln479">    p.equalizer_y[DT_IOP_COLORZONES_L][k] -= (k - 3.5) / (DT_IOP_COLORZONES_BANDS - 3.0) * 0.35;</a>
<a name="ln480">  dt_gui_presets_add_generic(_(&quot;polarizing filter&quot;), self-&gt;op, 3, &amp;p, sizeof(p), 1);</a>
<a name="ln481"> </a>
<a name="ln482">  // natural skin tone</a>
<a name="ln483"> </a>
<a name="ln484">  p.channel = DT_IOP_COLORZONES_h;</a>
<a name="ln485">  for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln486">  {</a>
<a name="ln487">    p.equalizer_y[DT_IOP_COLORZONES_L][k] = .5f;</a>
<a name="ln488">    p.equalizer_y[DT_IOP_COLORZONES_h][k] = .5f;</a>
<a name="ln489">    p.equalizer_x[DT_IOP_COLORZONES_L][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln490">    p.equalizer_x[DT_IOP_COLORZONES_h][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln491">  }</a>
<a name="ln492">  p.equalizer_x[DT_IOP_COLORZONES_C][0] = 0.000000;</a>
<a name="ln493">  p.equalizer_y[DT_IOP_COLORZONES_C][0] = 0.468932;</a>
<a name="ln494">  p.equalizer_x[DT_IOP_COLORZONES_C][1] = 0.010000;</a>
<a name="ln495">  p.equalizer_y[DT_IOP_COLORZONES_C][1] = 0.468932;</a>
<a name="ln496">  p.equalizer_x[DT_IOP_COLORZONES_C][2] = 0.120155;</a>
<a name="ln497">  p.equalizer_y[DT_IOP_COLORZONES_C][2] = 0.445975;</a>
<a name="ln498">  p.equalizer_x[DT_IOP_COLORZONES_C][3] = 0.248062;</a>
<a name="ln499">  p.equalizer_y[DT_IOP_COLORZONES_C][3] = 0.468932;</a>
<a name="ln500">  p.equalizer_x[DT_IOP_COLORZONES_C][4] = 0.500000;</a>
<a name="ln501">  p.equalizer_y[DT_IOP_COLORZONES_C][4] = 0.499667;</a>
<a name="ln502">  p.equalizer_x[DT_IOP_COLORZONES_C][5] = 0.748062;</a>
<a name="ln503">  p.equalizer_y[DT_IOP_COLORZONES_C][5] = 0.500000;</a>
<a name="ln504">  p.equalizer_x[DT_IOP_COLORZONES_C][6] = 0.990000;</a>
<a name="ln505">  p.equalizer_y[DT_IOP_COLORZONES_C][6] = 0.468932;</a>
<a name="ln506">  p.equalizer_x[DT_IOP_COLORZONES_C][7] = 1.000000;</a>
<a name="ln507">  p.equalizer_y[DT_IOP_COLORZONES_C][7] = 0.468932;</a>
<a name="ln508">  dt_gui_presets_add_generic(_(&quot;natural skin tones&quot;), self-&gt;op, 3, &amp;p, sizeof(p), 1);</a>
<a name="ln509"> </a>
<a name="ln510">  // black and white film</a>
<a name="ln511"> </a>
<a name="ln512">  p.channel = DT_IOP_COLORZONES_h;</a>
<a name="ln513">  for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln514">  {</a>
<a name="ln515">    p.equalizer_y[DT_IOP_COLORZONES_C][k] = .0f;</a>
<a name="ln516">    p.equalizer_y[DT_IOP_COLORZONES_h][k] = .5f;</a>
<a name="ln517">    p.equalizer_x[DT_IOP_COLORZONES_C][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln518">    p.equalizer_x[DT_IOP_COLORZONES_h][k] = k / (DT_IOP_COLORZONES_BANDS - 1.);</a>
<a name="ln519">  }</a>
<a name="ln520">  p.equalizer_x[DT_IOP_COLORZONES_L][0] = 0.000000;</a>
<a name="ln521">  p.equalizer_y[DT_IOP_COLORZONES_L][0] = 0.613040;</a>
<a name="ln522">  p.equalizer_x[DT_IOP_COLORZONES_L][1] = 0.010000;</a>
<a name="ln523">  p.equalizer_y[DT_IOP_COLORZONES_L][1] = 0.613040;</a>
<a name="ln524">  p.equalizer_x[DT_IOP_COLORZONES_L][2] = 0.245283;</a>
<a name="ln525">  p.equalizer_y[DT_IOP_COLORZONES_L][2] = 0.447962;</a>
<a name="ln526">  p.equalizer_x[DT_IOP_COLORZONES_L][3] = 0.498113;</a>
<a name="ln527">  p.equalizer_y[DT_IOP_COLORZONES_L][3] = 0.529201;</a>
<a name="ln528">  p.equalizer_x[DT_IOP_COLORZONES_L][4] = 0.641509;</a>
<a name="ln529">  p.equalizer_y[DT_IOP_COLORZONES_L][4] = 0.664967;</a>
<a name="ln530">  p.equalizer_x[DT_IOP_COLORZONES_L][5] = 0.879245;</a>
<a name="ln531">  p.equalizer_y[DT_IOP_COLORZONES_L][5] = 0.777294;</a>
<a name="ln532">  p.equalizer_x[DT_IOP_COLORZONES_L][6] = 0.990000;</a>
<a name="ln533">  p.equalizer_y[DT_IOP_COLORZONES_L][6] = 0.613040;</a>
<a name="ln534">  p.equalizer_x[DT_IOP_COLORZONES_L][7] = 1.000000;</a>
<a name="ln535">  p.equalizer_y[DT_IOP_COLORZONES_L][7] = 0.613040;</a>
<a name="ln536">  dt_gui_presets_add_generic(_(&quot;black &amp; white film&quot;), self-&gt;op, 3, &amp;p, sizeof(p), 1);</a>
<a name="ln537"> </a>
<a name="ln538">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">// fills in new parameters based on mouse position (in 0,1)</a>
<a name="ln542">static void dt_iop_colorzones_get_params(dt_iop_colorzones_params_t *p, const int ch, const double mouse_x,</a>
<a name="ln543">                                         const double mouse_y, const float rad)</a>
<a name="ln544">{</a>
<a name="ln545">  if(p-&gt;channel == DT_IOP_COLORZONES_h)</a>
<a name="ln546">  {</a>
<a name="ln547">    // periodic boundary</a>
<a name="ln548">    for(int k = 1; k &lt; DT_IOP_COLORZONES_BANDS - 1; k++)</a>
<a name="ln549">    {</a>
<a name="ln550">      const float f</a>
<a name="ln551">          = expf(-(mouse_x - p-&gt;equalizer_x[ch][k]) * (mouse_x - p-&gt;equalizer_x[ch][k]) / (rad * rad));</a>
<a name="ln552">      p-&gt;equalizer_y[ch][k] = (1 - f) * p-&gt;equalizer_y[ch][k] + f * mouse_y;</a>
<a name="ln553">    }</a>
<a name="ln554">    const int m = DT_IOP_COLORZONES_BANDS - 1;</a>
<a name="ln555">    const float mind = fminf((mouse_x - p-&gt;equalizer_x[ch][0]) * (mouse_x - p-&gt;equalizer_x[ch][0]),</a>
<a name="ln556">                             (mouse_x - p-&gt;equalizer_x[ch][m]) * (mouse_x - p-&gt;equalizer_x[ch][m]));</a>
<a name="ln557">    const float f = expf(-mind / (rad * rad));</a>
<a name="ln558">    p-&gt;equalizer_y[ch][0] = (1 - f) * p-&gt;equalizer_y[ch][0] + f * mouse_y;</a>
<a name="ln559">    p-&gt;equalizer_y[ch][m] = (1 - f) * p-&gt;equalizer_y[ch][m] + f * mouse_y;</a>
<a name="ln560">  }</a>
<a name="ln561">  else</a>
<a name="ln562">  {</a>
<a name="ln563">    for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln564">    {</a>
<a name="ln565">      const float f</a>
<a name="ln566">          = expf(-(mouse_x - p-&gt;equalizer_x[ch][k]) * (mouse_x - p-&gt;equalizer_x[ch][k]) / (rad * rad));</a>
<a name="ln567">      p-&gt;equalizer_y[ch][k] = (1 - f) * p-&gt;equalizer_y[ch][k] + f * mouse_y;</a>
<a name="ln568">    }</a>
<a name="ln569">  }</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">static gboolean colorzones_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln573">{</a>
<a name="ln574">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln575">  dt_iop_colorzones_gui_data_t *c = (dt_iop_colorzones_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln576">  dt_iop_colorzones_params_t p = *(dt_iop_colorzones_params_t *)self-&gt;params;</a>
<a name="ln577">  int ch = (int)c-&gt;channel;</a>
<a name="ln578">  if(p.channel == DT_IOP_COLORZONES_h)</a>
<a name="ln579">    dt_draw_curve_set_point(c-&gt;minmax_curve, 0, p.equalizer_x[ch][DT_IOP_COLORZONES_BANDS - 2] - 1.0,</a>
<a name="ln580">                            p.equalizer_y[ch][DT_IOP_COLORZONES_BANDS - 2]);</a>
<a name="ln581">  else</a>
<a name="ln582">    dt_draw_curve_set_point(c-&gt;minmax_curve, 0, p.equalizer_x[ch][DT_IOP_COLORZONES_BANDS - 2] - 1.0,</a>
<a name="ln583">                            p.equalizer_y[ch][0]);</a>
<a name="ln584">  for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln585">    dt_draw_curve_set_point(c-&gt;minmax_curve, k + 1, p.equalizer_x[ch][k], p.equalizer_y[ch][k]);</a>
<a name="ln586">  if(p.channel == DT_IOP_COLORZONES_h)</a>
<a name="ln587">    dt_draw_curve_set_point(c-&gt;minmax_curve, DT_IOP_COLORZONES_BANDS + 1, p.equalizer_x[ch][1] + 1.0,</a>
<a name="ln588">                            p.equalizer_y[ch][1]);</a>
<a name="ln589">  else</a>
<a name="ln590">    dt_draw_curve_set_point(c-&gt;minmax_curve, DT_IOP_COLORZONES_BANDS + 1, p.equalizer_x[ch][1] + 1.0,</a>
<a name="ln591">                            p.equalizer_y[ch][DT_IOP_COLORZONES_BANDS - 1]);</a>
<a name="ln592"> </a>
<a name="ln593">  GtkAllocation allocation;</a>
<a name="ln594">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln595">  const int inset = DT_IOP_COLORZONES_INSET;</a>
<a name="ln596">  int width = allocation.width, height = allocation.height;</a>
<a name="ln597">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln598">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln599">  // clear bg, match color of the notebook tabs:</a>
<a name="ln600">  GdkRGBA color;</a>
<a name="ln601">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln602">  gboolean color_found = gtk_style_context_lookup_color (context, &quot;selected_bg_color&quot;, &amp;color);</a>
<a name="ln603">  if(!color_found)</a>
<a name="ln604">  {</a>
<a name="ln605">    color.red = 1.0;</a>
<a name="ln606">    color.green = 0.0;</a>
<a name="ln607">    color.blue = 0.0;</a>
<a name="ln608">    color.alpha = 1.0;</a>
<a name="ln609">  }</a>
<a name="ln610">  gdk_cairo_set_source_rgba(cr, &amp;color);</a>
<a name="ln611">  cairo_paint(cr);</a>
<a name="ln612"> </a>
<a name="ln613">  cairo_translate(cr, inset, inset);</a>
<a name="ln614">  width -= 2 * inset;</a>
<a name="ln615">  height -= 2 * inset;</a>
<a name="ln616"> </a>
<a name="ln617">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.0));</a>
<a name="ln618">  cairo_set_source_rgb(cr, .1, .1, .1);</a>
<a name="ln619">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln620">  cairo_stroke(cr);</a>
<a name="ln621"> </a>
<a name="ln622">  cairo_set_source_rgb(cr, .3, .3, .3);</a>
<a name="ln623">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln624">  cairo_fill(cr);</a>
<a name="ln625"> </a>
<a name="ln626">  if(c-&gt;mouse_y &gt; 0 || c-&gt;dragging)</a>
<a name="ln627">  {</a>
<a name="ln628">    // draw min/max curves:</a>
<a name="ln629">    dt_iop_colorzones_get_params(&amp;p, c-&gt;channel, c-&gt;mouse_x, 1., c-&gt;mouse_radius);</a>
<a name="ln630">    if(p.channel == DT_IOP_COLORZONES_h)</a>
<a name="ln631">      dt_draw_curve_set_point(c-&gt;minmax_curve, 0, p.equalizer_x[ch][DT_IOP_COLORZONES_BANDS - 2] - 1.0,</a>
<a name="ln632">                              p.equalizer_y[ch][DT_IOP_COLORZONES_BANDS - 2]);</a>
<a name="ln633">    else</a>
<a name="ln634">      dt_draw_curve_set_point(c-&gt;minmax_curve, 0, p.equalizer_x[ch][DT_IOP_COLORZONES_BANDS - 2] - 1.0,</a>
<a name="ln635">                              p.equalizer_y[ch][0]);</a>
<a name="ln636">    for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln637">      dt_draw_curve_set_point(c-&gt;minmax_curve, k + 1, p.equalizer_x[ch][k], p.equalizer_y[ch][k]);</a>
<a name="ln638">    if(p.channel == DT_IOP_COLORZONES_h)</a>
<a name="ln639">      dt_draw_curve_set_point(c-&gt;minmax_curve, DT_IOP_COLORZONES_BANDS + 1, p.equalizer_x[ch][1] + 1.0,</a>
<a name="ln640">                              p.equalizer_y[ch][1]);</a>
<a name="ln641">    else</a>
<a name="ln642">      dt_draw_curve_set_point(c-&gt;minmax_curve, DT_IOP_COLORZONES_BANDS + 1, p.equalizer_x[ch][1] + 1.0,</a>
<a name="ln643">                              p.equalizer_y[ch][DT_IOP_COLORZONES_BANDS - 1]);</a>
<a name="ln644">    dt_draw_curve_calc_values(c-&gt;minmax_curve, 0.0, 1.0, DT_IOP_COLORZONES_RES, c-&gt;draw_min_xs,</a>
<a name="ln645">                              c-&gt;draw_min_ys);</a>
<a name="ln646"> </a>
<a name="ln647">    p = *(dt_iop_colorzones_params_t *)self-&gt;params;</a>
<a name="ln648">    dt_iop_colorzones_get_params(&amp;p, c-&gt;channel, c-&gt;mouse_x, .0, c-&gt;mouse_radius);</a>
<a name="ln649">    if(p.channel == DT_IOP_COLORZONES_h)</a>
<a name="ln650">      dt_draw_curve_set_point(c-&gt;minmax_curve, 0, p.equalizer_x[ch][DT_IOP_COLORZONES_BANDS - 2] - 1.0,</a>
<a name="ln651">                              p.equalizer_y[ch][DT_IOP_COLORZONES_BANDS - 2]);</a>
<a name="ln652">    else</a>
<a name="ln653">      dt_draw_curve_set_point(c-&gt;minmax_curve, 0, p.equalizer_x[ch][DT_IOP_COLORZONES_BANDS - 2] - 1.0,</a>
<a name="ln654">                              p.equalizer_y[ch][0]);</a>
<a name="ln655">    for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln656">      dt_draw_curve_set_point(c-&gt;minmax_curve, k + 1, p.equalizer_x[ch][k], p.equalizer_y[ch][k]);</a>
<a name="ln657">    if(p.channel == DT_IOP_COLORZONES_h)</a>
<a name="ln658">      dt_draw_curve_set_point(c-&gt;minmax_curve, DT_IOP_COLORZONES_BANDS + 1, p.equalizer_x[ch][1] + 1.0,</a>
<a name="ln659">                              p.equalizer_y[ch][1]);</a>
<a name="ln660">    else</a>
<a name="ln661">      dt_draw_curve_set_point(c-&gt;minmax_curve, DT_IOP_COLORZONES_BANDS + 1, p.equalizer_x[ch][1] + 1.0,</a>
<a name="ln662">                              p.equalizer_y[ch][DT_IOP_COLORZONES_BANDS - 1]);</a>
<a name="ln663">    dt_draw_curve_calc_values(c-&gt;minmax_curve, 0.0, 1.0, DT_IOP_COLORZONES_RES, c-&gt;draw_max_xs,</a>
<a name="ln664">                              c-&gt;draw_max_ys);</a>
<a name="ln665">  }</a>
<a name="ln666"> </a>
<a name="ln667">  if(self-&gt;picked_color_max[0] &lt; 0.0f || self-&gt;picked_color[0] == 0.0f)</a>
<a name="ln668">  {</a>
<a name="ln669">    self-&gt;picked_color[0] = 50.0f;</a>
<a name="ln670">    self-&gt;picked_color[1] = 0.0f;</a>
<a name="ln671">    self-&gt;picked_color[2] = -5.0f;</a>
<a name="ln672">  }</a>
<a name="ln673"> </a>
<a name="ln674">  cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE);</a>
<a name="ln675"> </a>
<a name="ln676">  const float pickC</a>
<a name="ln677">      = sqrtf(self-&gt;picked_color[1] * self-&gt;picked_color[1] + self-&gt;picked_color[2] * self-&gt;picked_color[2]);</a>
<a name="ln678">  const int cellsi = 16, cellsj = 9;</a>
<a name="ln679">  for(int j = 0; j &lt; cellsj; j++)</a>
<a name="ln680">    for(int i = 0; i &lt; cellsi; i++)</a>
<a name="ln681">    {</a>
<a name="ln682">      double rgb[3] = { 0.5, 0.5, 0.5 };</a>
<a name="ln683">      float jj = 1.0 - (j - .5) / (cellsj - 1.), ii = (i + .5) / (cellsi - 1.);</a>
<a name="ln684">      cmsCIELab Lab;</a>
<a name="ln685">      switch(p.channel)</a>
<a name="ln686">      {</a>
<a name="ln687">        // select by channel, abscissa:</a>
<a name="ln688">        case DT_IOP_COLORZONES_L:</a>
<a name="ln689">          Lab.L = ii * 100.0;</a>
<a name="ln690">          Lab.a = self-&gt;picked_color[1];</a>
<a name="ln691">          Lab.b = self-&gt;picked_color[2];</a>
<a name="ln692">          break;</a>
<a name="ln693">        case DT_IOP_COLORZONES_C:</a>
<a name="ln694">          Lab.L = 50.0;</a>
<a name="ln695">          Lab.a = 64.0 * ii * self-&gt;picked_color[1] / pickC;</a>
<a name="ln696">          Lab.b = 64.0 * ii * self-&gt;picked_color[2] / pickC;</a>
<a name="ln697">          break;</a>
<a name="ln698">        default: // case DT_IOP_COLORZONES_h:</a>
<a name="ln699">          Lab.L = 50.0;</a>
<a name="ln700">          Lab.a = cosf(2.0 * M_PI * ii) * 64.0f;</a>
<a name="ln701">          Lab.b = sinf(2.0 * M_PI * ii) * 64.0f;</a>
<a name="ln702">          break;</a>
<a name="ln703">      }</a>
<a name="ln704">      const float L0 = Lab.L;</a>
<a name="ln705">      const float angle = atan2f(Lab.b, Lab.a);</a>
<a name="ln706">      switch(c-&gt;channel)</a>
<a name="ln707">      {</a>
<a name="ln708">        // channel to be altered:</a>
<a name="ln709">        case DT_IOP_COLORZONES_L:</a>
<a name="ln710">          Lab.L += -50.0 + 100.0 * jj;</a>
<a name="ln711">          break;</a>
<a name="ln712">        case DT_IOP_COLORZONES_C:</a>
<a name="ln713">          Lab.a *= 2.0f * jj;</a>
<a name="ln714">          Lab.b *= 2.0f * jj;</a>
<a name="ln715">          break;</a>
<a name="ln716">        default: // DT_IOP_COLORZONES_h</a>
<a name="ln717">          Lab.a = cosf(angle + 2.0 * M_PI * (jj - .5f)) * 64.0;</a>
<a name="ln718">          Lab.b = sinf(angle + 2.0 * M_PI * (jj - .5f)) * 64.0;</a>
<a name="ln719">          if(p.channel == DT_IOP_COLORZONES_C)</a>
<a name="ln720">          {</a>
<a name="ln721">            Lab.a *= ii;</a>
<a name="ln722">            Lab.b *= ii;</a>
<a name="ln723">          }</a>
<a name="ln724">          break;</a>
<a name="ln725">      }</a>
<a name="ln726">      // gamut mapping magic from iop/exposure.c:</a>
<a name="ln727">      const float Lwhite = 100.0f, Lclip = 20.0f;</a>
<a name="ln728">      const float Lcap = fminf(100.0, Lab.L);</a>
<a name="ln729">      const float clip = 1.0</a>
<a name="ln730">                         - (Lcap - L0) * (1.0 / 100.0) * fminf(Lwhite - Lclip, fmaxf(0.0, Lab.L - Lclip))</a>
<a name="ln731">                           / (Lwhite - Lclip);</a>
<a name="ln732">      const float clip2 = clip * clip * clip;</a>
<a name="ln733">      Lab.a *= Lab.L / L0 * clip2;</a>
<a name="ln734">      Lab.b *= Lab.L / L0 * clip2;</a>
<a name="ln735">      cmsDoTransform(c-&gt;xform, &amp;Lab, rgb, 1);</a>
<a name="ln736">      cairo_set_source_rgb(cr, rgb[0], rgb[1], rgb[2]);</a>
<a name="ln737">      cairo_rectangle(cr, width * i / (float)cellsi, height * j / (float)cellsj,</a>
<a name="ln738">                      width / (float)cellsi - DT_PIXEL_APPLY_DPI(1),</a>
<a name="ln739">                      height / (float)cellsj - DT_PIXEL_APPLY_DPI(1));</a>
<a name="ln740">      cairo_fill(cr);</a>
<a name="ln741">    }</a>
<a name="ln742"> </a>
<a name="ln743">  cairo_set_antialias(cr, CAIRO_ANTIALIAS_DEFAULT);</a>
<a name="ln744"> </a>
<a name="ln745">  if(self-&gt;picked_color_max[0] &gt;= 0.0f)</a>
<a name="ln746">  {</a>
<a name="ln747">    // draw marker for currently selected color:</a>
<a name="ln748">    float picked_i = -1.0;</a>
<a name="ln749">    switch(p.channel)</a>
<a name="ln750">    {</a>
<a name="ln751">      // select by channel, abscissa:</a>
<a name="ln752">      case DT_IOP_COLORZONES_L:</a>
<a name="ln753">        picked_i = self-&gt;picked_color[0] / 100.0;</a>
<a name="ln754">        break;</a>
<a name="ln755">      case DT_IOP_COLORZONES_C:</a>
<a name="ln756">        picked_i = pickC / 128.0;</a>
<a name="ln757">        break;</a>
<a name="ln758">      default: // case DT_IOP_COLORZONES_h:</a>
<a name="ln759">        picked_i = fmodf(atan2f(self-&gt;picked_color[2], self-&gt;picked_color[1]) + 2.0 * M_PI, 2.0 * M_PI)</a>
<a name="ln760">                   / (2.0 * M_PI);</a>
<a name="ln761">        break;</a>
<a name="ln762">    }</a>
<a name="ln763">    cairo_save(cr);</a>
<a name="ln764">    cairo_set_source_rgb(cr, 1.0, 1.0, 1.0);</a>
<a name="ln765">    cairo_set_operator(cr, CAIRO_OPERATOR_XOR);</a>
<a name="ln766">    cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.));</a>
<a name="ln767">    cairo_move_to(cr, width * picked_i, 0.0);</a>
<a name="ln768">    cairo_line_to(cr, width * picked_i, height);</a>
<a name="ln769">    cairo_stroke(cr);</a>
<a name="ln770">    cairo_restore(cr);</a>
<a name="ln771">  }</a>
<a name="ln772"> </a>
<a name="ln773">  // draw x positions</a>
<a name="ln774">  cairo_set_source_rgb(cr, 0.6, 0.6, 0.6);</a>
<a name="ln775">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.));</a>
<a name="ln776">  const float arrw = DT_PIXEL_APPLY_DPI(7.0f);</a>
<a name="ln777">  for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln778">  {</a>
<a name="ln779">    cairo_move_to(cr, width * p.equalizer_x[c-&gt;channel][k], height + inset - DT_PIXEL_APPLY_DPI(1));</a>
<a name="ln780">    cairo_rel_line_to(cr, -arrw * .5f, 0);</a>
<a name="ln781">    cairo_rel_line_to(cr, arrw * .5f, -arrw);</a>
<a name="ln782">    cairo_rel_line_to(cr, arrw * .5f, arrw);</a>
<a name="ln783">    cairo_close_path(cr);</a>
<a name="ln784">    if(c-&gt;x_move == k)</a>
<a name="ln785">      cairo_fill(cr);</a>
<a name="ln786">    else</a>
<a name="ln787">      cairo_stroke(cr);</a>
<a name="ln788">  }</a>
<a name="ln789"> </a>
<a name="ln790">  // draw selected cursor</a>
<a name="ln791">  cairo_translate(cr, 0, height);</a>
<a name="ln792"> </a>
<a name="ln793">  // cairo_set_operator(cr, CAIRO_OPERATOR_ADD);</a>
<a name="ln794">  cairo_set_operator(cr, CAIRO_OPERATOR_OVER);</a>
<a name="ln795">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.));</a>
<a name="ln796">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln797">  {</a>
<a name="ln798">    // draw curves, selected last.</a>
<a name="ln799">    ch = ((int)c-&gt;channel + i + 1) % 3;</a>
<a name="ln800">    if(i == 2)</a>
<a name="ln801">      cairo_set_source_rgba(cr, .7, .7, .7, 1.0);</a>
<a name="ln802">    else</a>
<a name="ln803">      cairo_set_source_rgba(cr, .7, .7, .7, 0.3);</a>
<a name="ln804">    p = *(dt_iop_colorzones_params_t *)self-&gt;params;</a>
<a name="ln805">    if(p.channel == DT_IOP_COLORZONES_h)</a>
<a name="ln806">      dt_draw_curve_set_point(c-&gt;minmax_curve, 0, p.equalizer_x[ch][DT_IOP_COLORZONES_BANDS - 2] - 1.0,</a>
<a name="ln807">                              p.equalizer_y[ch][DT_IOP_COLORZONES_BANDS - 2]);</a>
<a name="ln808">    else</a>
<a name="ln809">      dt_draw_curve_set_point(c-&gt;minmax_curve, 0, p.equalizer_x[ch][DT_IOP_COLORZONES_BANDS - 2] - 1.0,</a>
<a name="ln810">                              p.equalizer_y[ch][0]);</a>
<a name="ln811">    for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln812">      dt_draw_curve_set_point(c-&gt;minmax_curve, k + 1, p.equalizer_x[ch][k], p.equalizer_y[ch][k]);</a>
<a name="ln813">    if(p.channel == DT_IOP_COLORZONES_h)</a>
<a name="ln814">      dt_draw_curve_set_point(c-&gt;minmax_curve, DT_IOP_COLORZONES_BANDS + 1, p.equalizer_x[ch][1] + 1.0,</a>
<a name="ln815">                              p.equalizer_y[ch][1]);</a>
<a name="ln816">    else</a>
<a name="ln817">      dt_draw_curve_set_point(c-&gt;minmax_curve, DT_IOP_COLORZONES_BANDS + 1, p.equalizer_x[ch][1] + 1.0,</a>
<a name="ln818">                              p.equalizer_y[ch][DT_IOP_COLORZONES_BANDS - 1]);</a>
<a name="ln819">    dt_draw_curve_calc_values(c-&gt;minmax_curve, 0.0, 1.0, DT_IOP_COLORZONES_RES, c-&gt;draw_xs, c-&gt;draw_ys);</a>
<a name="ln820">    cairo_move_to(cr, 0 * width / (float)(DT_IOP_COLORZONES_RES - 1), -height * c-&gt;draw_ys[0]);</a>
<a name="ln821">    for(int k = 1; k &lt; DT_IOP_COLORZONES_RES; k++)</a>
<a name="ln822">      cairo_line_to(cr, k * width / (float)(DT_IOP_COLORZONES_RES - 1), -height * c-&gt;draw_ys[k]);</a>
<a name="ln823">    cairo_stroke(cr);</a>
<a name="ln824">  }</a>
<a name="ln825"> </a>
<a name="ln826">  // draw dots on knots</a>
<a name="ln827">  cairo_set_source_rgb(cr, 0.7, 0.7, 0.7);</a>
<a name="ln828">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.));</a>
<a name="ln829">  for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln830">  {</a>
<a name="ln831">    cairo_arc(cr, width * p.equalizer_x[c-&gt;channel][k], -height * p.equalizer_y[c-&gt;channel][k],</a>
<a name="ln832">              DT_PIXEL_APPLY_DPI(3.0), 0.0, 2.0 * M_PI);</a>
<a name="ln833">    if(c-&gt;x_move == k)</a>
<a name="ln834">      cairo_fill(cr);</a>
<a name="ln835">    else</a>
<a name="ln836">      cairo_stroke(cr);</a>
<a name="ln837">  }</a>
<a name="ln838"> </a>
<a name="ln839">  if(c-&gt;mouse_y &gt; 0 || c-&gt;dragging)</a>
<a name="ln840">  {</a>
<a name="ln841">    // draw min/max, if selected</a>
<a name="ln842">    cairo_set_source_rgba(cr, .7, .7, .7, .6);</a>
<a name="ln843">    cairo_move_to(cr, 0, -height * c-&gt;draw_min_ys[0]);</a>
<a name="ln844">    for(int k = 1; k &lt; DT_IOP_COLORZONES_RES; k++)</a>
<a name="ln845">      cairo_line_to(cr, k * width / (float)(DT_IOP_COLORZONES_RES - 1), -height * c-&gt;draw_min_ys[k]);</a>
<a name="ln846">    for(int k = DT_IOP_COLORZONES_RES - 1; k &gt;= 0; k--)</a>
<a name="ln847">      cairo_line_to(cr, k * width / (float)(DT_IOP_COLORZONES_RES - 1), -height * c-&gt;draw_max_ys[k]);</a>
<a name="ln848">    cairo_close_path(cr);</a>
<a name="ln849">    cairo_fill(cr);</a>
<a name="ln850">    // draw mouse focus circle</a>
<a name="ln851">    cairo_set_source_rgba(cr, .9, .9, .9, .5);</a>
<a name="ln852">    const float pos = DT_IOP_COLORZONES_RES * c-&gt;mouse_x;</a>
<a name="ln853">    int k = (int)pos;</a>
<a name="ln854">    const float f = k - pos;</a>
<a name="ln855">    if(k &gt;= DT_IOP_COLORZONES_RES - 1) k = DT_IOP_COLORZONES_RES - 2;</a>
<a name="ln856">    float ht = -height * (f * c-&gt;draw_ys[k] + (1 - f) * c-&gt;draw_ys[k + 1]);</a>
<a name="ln857">    cairo_arc(cr, c-&gt;mouse_x * width, ht, c-&gt;mouse_radius * width, 0, 2. * M_PI);</a>
<a name="ln858">    cairo_stroke(cr);</a>
<a name="ln859">  }</a>
<a name="ln860"> </a>
<a name="ln861">  cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);</a>
<a name="ln862"> </a>
<a name="ln863">  cairo_destroy(cr);</a>
<a name="ln864">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln865">  cairo_paint(crf);</a>
<a name="ln866">  cairo_surface_destroy(cst);</a>
<a name="ln867">  return TRUE;</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">static gboolean colorzones_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln871">{</a>
<a name="ln872">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln873">  dt_iop_colorzones_gui_data_t *c = (dt_iop_colorzones_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln874">  dt_iop_colorzones_params_t *p = (dt_iop_colorzones_params_t *)self-&gt;params;</a>
<a name="ln875"> </a>
<a name="ln876">  GtkAllocation allocation;</a>
<a name="ln877">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln878">  const int inset = DT_IOP_COLORZONES_INSET;</a>
<a name="ln879">  int height = allocation.height - 2 * inset, width = allocation.width - 2 * inset;</a>
<a name="ln880">  if(!c-&gt;dragging) c-&gt;mouse_x = CLAMP(event-&gt;x - inset, 0, width) / (float)width;</a>
<a name="ln881">  c-&gt;mouse_y = 1.0 - CLAMP(event-&gt;y - inset, 0, height) / (float)height;</a>
<a name="ln882">  if(c-&gt;dragging)</a>
<a name="ln883">  {</a>
<a name="ln884">    *p = c-&gt;drag_params;</a>
<a name="ln885">    if(c-&gt;x_move &gt;= 0)</a>
<a name="ln886">    {</a>
<a name="ln887">      const float mx = CLAMP(event-&gt;x - inset, 0, width) / (float)width;</a>
<a name="ln888">      if(c-&gt;x_move &gt; 0 &amp;&amp; c-&gt;x_move &lt; DT_IOP_COLORZONES_BANDS - 1)</a>
<a name="ln889">      {</a>
<a name="ln890">        const float minx = p-&gt;equalizer_x[c-&gt;channel][c-&gt;x_move - 1] + 0.001f;</a>
<a name="ln891">        const float maxx = p-&gt;equalizer_x[c-&gt;channel][c-&gt;x_move + 1] - 0.001f;</a>
<a name="ln892">        p-&gt;equalizer_x[c-&gt;channel][c-&gt;x_move] = fminf(maxx, fmaxf(minx, mx));</a>
<a name="ln893">      }</a>
<a name="ln894">    }</a>
<a name="ln895">    else</a>
<a name="ln896">    {</a>
<a name="ln897">      dt_iop_colorzones_get_params(p, c-&gt;channel, c-&gt;mouse_x, c-&gt;mouse_y + c-&gt;mouse_pick, c-&gt;mouse_radius);</a>
<a name="ln898">    }</a>
<a name="ln899">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln900">  }</a>
<a name="ln901">  else if(event-&gt;y &gt; height)</a>
<a name="ln902">  {</a>
<a name="ln903">    c-&gt;x_move = 0;</a>
<a name="ln904">    float dist = fabs(p-&gt;equalizer_x[c-&gt;channel][0] - c-&gt;mouse_x);</a>
<a name="ln905">    for(int k = 1; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln906">    {</a>
<a name="ln907">      float d2 = fabs(p-&gt;equalizer_x[c-&gt;channel][k] - c-&gt;mouse_x);</a>
<a name="ln908">      if(d2 &lt; dist)</a>
<a name="ln909">      {</a>
<a name="ln910">        c-&gt;x_move = k;</a>
<a name="ln911">        dist = d2;</a>
<a name="ln912">      }</a>
<a name="ln913">    }</a>
<a name="ln914">  }</a>
<a name="ln915">  else</a>
<a name="ln916">  {</a>
<a name="ln917">    c-&gt;x_move = -1;</a>
<a name="ln918">  }</a>
<a name="ln919">  gtk_widget_queue_draw(widget);</a>
<a name="ln920">  return TRUE;</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923">static gboolean colorzones_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln924">{</a>
<a name="ln925">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln926">  dt_iop_colorzones_gui_data_t *c = (dt_iop_colorzones_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln927">  if(event-&gt;button == 1 &amp;&amp; event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln928">  {</a>
<a name="ln929">    // reset current curve</a>
<a name="ln930">    dt_iop_colorzones_params_t *p = (dt_iop_colorzones_params_t *)self-&gt;params;</a>
<a name="ln931">    dt_iop_colorzones_params_t *d = (dt_iop_colorzones_params_t *)self-&gt;default_params;</a>
<a name="ln932">    for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln933">    {</a>
<a name="ln934">      p-&gt;equalizer_x[c-&gt;channel][k] = d-&gt;equalizer_x[c-&gt;channel][k];</a>
<a name="ln935">      p-&gt;equalizer_y[c-&gt;channel][k] = d-&gt;equalizer_y[c-&gt;channel][k];</a>
<a name="ln936">    }</a>
<a name="ln937">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln938">    gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln939">  }</a>
<a name="ln940">  else if(event-&gt;button == 1)</a>
<a name="ln941">  {</a>
<a name="ln942">    c-&gt;drag_params = *(dt_iop_colorzones_params_t *)self-&gt;params;</a>
<a name="ln943"> </a>
<a name="ln944">    GtkAllocation allocation;</a>
<a name="ln945">    gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln946">    const int inset = DT_IOP_COLORZONES_INSET;</a>
<a name="ln947">    int height = allocation.height - 2 * inset, width = allocation.width - 2 * inset;</a>
<a name="ln948">    c-&gt;mouse_pick</a>
<a name="ln949">        = dt_draw_curve_calc_value(c-&gt;minmax_curve, CLAMP(event-&gt;x - inset, 0, width) / (float)width);</a>
<a name="ln950">    c-&gt;mouse_pick -= 1.0 - CLAMP(event-&gt;y - inset, 0, height) / (float)height;</a>
<a name="ln951">    c-&gt;dragging = 1;</a>
<a name="ln952">    return TRUE;</a>
<a name="ln953">  }</a>
<a name="ln954">  return FALSE;</a>
<a name="ln955">}</a>
<a name="ln956"> </a>
<a name="ln957">static gboolean colorzones_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln958">{</a>
<a name="ln959">  if(event-&gt;button == 1)</a>
<a name="ln960">  {</a>
<a name="ln961">    dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln962">    dt_iop_colorzones_gui_data_t *c = (dt_iop_colorzones_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln963">    c-&gt;dragging = 0;</a>
<a name="ln964">    return TRUE;</a>
<a name="ln965">  }</a>
<a name="ln966">  return FALSE;</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969">static gboolean colorzones_enter_notify(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln970">{</a>
<a name="ln971">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln972">  dt_iop_colorzones_gui_data_t *c = (dt_iop_colorzones_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln973">  c-&gt;mouse_y = fabs(c-&gt;mouse_y);</a>
<a name="ln974">  gtk_widget_queue_draw(widget);</a>
<a name="ln975">  return TRUE;</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978">static gboolean colorzones_leave_notify(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln979">{</a>
<a name="ln980">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln981">  dt_iop_colorzones_gui_data_t *c = (dt_iop_colorzones_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln982">  // for fluxbox</a>
<a name="ln983">  c-&gt;mouse_y = -fabs(c-&gt;mouse_y);</a>
<a name="ln984">  gtk_widget_queue_draw(widget);</a>
<a name="ln985">  return TRUE;</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">static gboolean colorzones_scrolled(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln989">{</a>
<a name="ln990">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln991">  dt_iop_colorzones_gui_data_t *c = (dt_iop_colorzones_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln992"> </a>
<a name="ln993">  gdouble delta_y;</a>
<a name="ln994">  if(dt_gui_get_scroll_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln995">  {</a>
<a name="ln996">    c-&gt;mouse_radius = CLAMP(c-&gt;mouse_radius * (1.0 + 0.1 * delta_y), 0.2 / DT_IOP_COLORZONES_BANDS, 1.0);</a>
<a name="ln997">    gtk_widget_queue_draw(widget);</a>
<a name="ln998">  }</a>
<a name="ln999"> </a>
<a name="ln1000">  return TRUE;</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003">static void colorzones_tab_switch(GtkNotebook *notebook, GtkWidget *page, guint page_num, gpointer user_data)</a>
<a name="ln1004">{</a>
<a name="ln1005">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1006">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1007">  dt_iop_colorzones_gui_data_t *c = (dt_iop_colorzones_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1008">  c-&gt;channel = (dt_iop_colorzones_channel_t)page_num;</a>
<a name="ln1009">  gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln1010">}</a>
<a name="ln1011"> </a>
<a name="ln1012">static void select_by_changed(GtkWidget *widget, gpointer user_data)</a>
<a name="ln1013">{</a>
<a name="ln1014">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1015">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1016">  dt_iop_colorzones_params_t *p = (dt_iop_colorzones_params_t *)self-&gt;params;</a>
<a name="ln1017">  memcpy(p, self-&gt;default_params, sizeof(dt_iop_colorzones_params_t));</a>
<a name="ln1018">  p-&gt;channel = 2 - (dt_iop_colorzones_channel_t)dt_bauhaus_combobox_get(widget);</a>
<a name="ln1019">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1020">  gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln1021">}</a>
<a name="ln1022"> </a>
<a name="ln1023">static void request_pick_toggled(GtkToggleButton *togglebutton, dt_iop_module_t *self)</a>
<a name="ln1024">{</a>
<a name="ln1025">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln1026"> </a>
<a name="ln1027">  self-&gt;request_color_pick</a>
<a name="ln1028">      = (gtk_toggle_button_get_active(togglebutton) ? DT_REQUEST_COLORPICK_MODULE : DT_REQUEST_COLORPICK_OFF);</a>
<a name="ln1029"> </a>
<a name="ln1030">  /* set the area sample size */</a>
<a name="ln1031">  if(self-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF)</a>
<a name="ln1032">  {</a>
<a name="ln1033">    dt_lib_colorpicker_set_point(darktable.lib, 0.5, 0.5);</a>
<a name="ln1034">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln1035">  }</a>
<a name="ln1036">  else</a>
<a name="ln1037">    dt_control_queue_redraw();</a>
<a name="ln1038"> </a>
<a name="ln1039">  if(self-&gt;off) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self-&gt;off), 1);</a>
<a name="ln1040">  dt_iop_request_focus(self);</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">static void strength_changed(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1044">{</a>
<a name="ln1045">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1046">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1047">  dt_iop_colorzones_params_t *p = (dt_iop_colorzones_params_t *)self-&gt;params;</a>
<a name="ln1048">  p-&gt;strength = dt_bauhaus_slider_get(slider);</a>
<a name="ln1049">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln1053">{</a>
<a name="ln1054">  self-&gt;gui_data = malloc(sizeof(dt_iop_colorzones_gui_data_t));</a>
<a name="ln1055">  dt_iop_colorzones_gui_data_t *c = (dt_iop_colorzones_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1056">  dt_iop_colorzones_params_t *p = (dt_iop_colorzones_params_t *)self-&gt;params;</a>
<a name="ln1057"> </a>
<a name="ln1058">  //   c-&gt;channel = DT_IOP_COLORZONES_C;</a>
<a name="ln1059">  c-&gt;channel = dt_conf_get_int(&quot;plugins/darkroom/colorzones/gui_channel&quot;);</a>
<a name="ln1060">  int ch = (int)c-&gt;channel;</a>
<a name="ln1061">  c-&gt;minmax_curve = dt_draw_curve_new(0.0, 1.0, CATMULL_ROM);</a>
<a name="ln1062">  (void)dt_draw_curve_add_point(c-&gt;minmax_curve, p-&gt;equalizer_x[ch][DT_IOP_COLORZONES_BANDS - 2] - 1.0,</a>
<a name="ln1063">                                p-&gt;equalizer_y[ch][DT_IOP_COLORZONES_BANDS - 2]);</a>
<a name="ln1064">  for(int k = 0; k &lt; DT_IOP_COLORZONES_BANDS; k++)</a>
<a name="ln1065">    (void)dt_draw_curve_add_point(c-&gt;minmax_curve, p-&gt;equalizer_x[ch][k], p-&gt;equalizer_y[ch][k]);</a>
<a name="ln1066">  (void)dt_draw_curve_add_point(c-&gt;minmax_curve, p-&gt;equalizer_x[ch][1] + 1.0, p-&gt;equalizer_y[ch][1]);</a>
<a name="ln1067">  c-&gt;mouse_x = c-&gt;mouse_y = c-&gt;mouse_pick = -1.0;</a>
<a name="ln1068">  c-&gt;dragging = 0;</a>
<a name="ln1069">  c-&gt;x_move = -1;</a>
<a name="ln1070">  c-&gt;mouse_radius = 1.0 / DT_IOP_COLORZONES_BANDS;</a>
<a name="ln1071"> </a>
<a name="ln1072">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln1073">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln1074"> </a>
<a name="ln1075">  // tabs</a>
<a name="ln1076">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1077">  GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1078">  gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);</a>
<a name="ln1079"> </a>
<a name="ln1080">  c-&gt;channel_tabs = GTK_NOTEBOOK(gtk_notebook_new());</a>
<a name="ln1081"> </a>
<a name="ln1082">  gtk_notebook_append_page(GTK_NOTEBOOK(c-&gt;channel_tabs),</a>
<a name="ln1083">                           GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0)),</a>
<a name="ln1084">                           gtk_label_new(_(&quot;lightness&quot;)));</a>
<a name="ln1085">  gtk_notebook_append_page(GTK_NOTEBOOK(c-&gt;channel_tabs),</a>
<a name="ln1086">                           GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0)),</a>
<a name="ln1087">                           gtk_label_new(_(&quot;saturation&quot;)));</a>
<a name="ln1088">  gtk_notebook_append_page(GTK_NOTEBOOK(c-&gt;channel_tabs),</a>
<a name="ln1089">                           GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0)), gtk_label_new(_(&quot;hue&quot;)));</a>
<a name="ln1090"> </a>
<a name="ln1091">  gtk_widget_show_all(GTK_WIDGET(gtk_notebook_get_nth_page(c-&gt;channel_tabs, c-&gt;channel)));</a>
<a name="ln1092">  gtk_notebook_set_current_page(GTK_NOTEBOOK(c-&gt;channel_tabs), c-&gt;channel);</a>
<a name="ln1093"> </a>
<a name="ln1094">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(c-&gt;channel_tabs), FALSE, FALSE, 0);</a>
<a name="ln1095">  GtkWidget *tb = dtgtk_togglebutton_new(dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT  | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1096">  gtk_widget_set_size_request(GTK_WIDGET(tb), DT_PIXEL_APPLY_DPI(14), DT_PIXEL_APPLY_DPI(14));</a>
<a name="ln1097">  gtk_widget_set_tooltip_text(tb, _(&quot;pick GUI color from image&quot;));</a>
<a name="ln1098">  g_signal_connect(G_OBJECT(tb), &quot;toggled&quot;, G_CALLBACK(request_pick_toggled), self);</a>
<a name="ln1099">  gtk_box_pack_end(GTK_BOX(hbox), tb, FALSE, FALSE, 0);</a>
<a name="ln1100">  c-&gt;colorpicker = tb;</a>
<a name="ln1101"> </a>
<a name="ln1102">  g_signal_connect(G_OBJECT(c-&gt;channel_tabs), &quot;switch_page&quot;, G_CALLBACK(colorzones_tab_switch), self);</a>
<a name="ln1103"> </a>
<a name="ln1104">  // the nice graph</a>
<a name="ln1105">  c-&gt;area = GTK_DRAWING_AREA(dtgtk_drawing_area_new_with_aspect_ratio(9.0 / 16.0));</a>
<a name="ln1106">  gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(c-&gt;area), TRUE, TRUE, 0);</a>
<a name="ln1107">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(vbox), TRUE, TRUE, 5);</a>
<a name="ln1108"> </a>
<a name="ln1109">  c-&gt;strength = dt_bauhaus_slider_new_with_range(self, -200, 200.0, 10.0, p-&gt;strength, 1);</a>
<a name="ln1110">  dt_bauhaus_slider_set_format(c-&gt;strength, &quot;%.01f%%&quot;);</a>
<a name="ln1111">  dt_bauhaus_widget_set_label(c-&gt;strength, NULL, _(&quot;mix&quot;));</a>
<a name="ln1112">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), c-&gt;strength, TRUE, TRUE, 0);</a>
<a name="ln1113">  gtk_widget_set_tooltip_text(c-&gt;strength, _(&quot;make effect stronger or weaker&quot;));</a>
<a name="ln1114">  g_signal_connect(G_OBJECT(c-&gt;strength), &quot;value-changed&quot;, G_CALLBACK(strength_changed), (gpointer)self);</a>
<a name="ln1115"> </a>
<a name="ln1116">  // select by which dimension</a>
<a name="ln1117">  c-&gt;select_by = dt_bauhaus_combobox_new(self);</a>
<a name="ln1118">  dt_bauhaus_widget_set_label(c-&gt;select_by, NULL, _(&quot;select by&quot;));</a>
<a name="ln1119">  gtk_widget_set_tooltip_text(c-&gt;select_by, _(&quot;choose selection criterion, will be the abscissa in the graph&quot;));</a>
<a name="ln1120">  dt_bauhaus_combobox_add(c-&gt;select_by, _(&quot;hue&quot;));</a>
<a name="ln1121">  dt_bauhaus_combobox_add(c-&gt;select_by, _(&quot;saturation&quot;));</a>
<a name="ln1122">  dt_bauhaus_combobox_add(c-&gt;select_by, _(&quot;lightness&quot;));</a>
<a name="ln1123">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), c-&gt;select_by, TRUE, TRUE, 0);</a>
<a name="ln1124">  g_signal_connect(G_OBJECT(c-&gt;select_by), &quot;value-changed&quot;, G_CALLBACK(select_by_changed), (gpointer)self);</a>
<a name="ln1125"> </a>
<a name="ln1126"> </a>
<a name="ln1127">  gtk_widget_add_events(GTK_WIDGET(c-&gt;area), GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln1128">                                             | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln1129">                                             | GDK_LEAVE_NOTIFY_MASK | darktable.gui-&gt;scroll_mask);</a>
<a name="ln1130">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;draw&quot;, G_CALLBACK(colorzones_draw), self);</a>
<a name="ln1131">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;button-press-event&quot;, G_CALLBACK(colorzones_button_press), self);</a>
<a name="ln1132">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;button-release-event&quot;, G_CALLBACK(colorzones_button_release), self);</a>
<a name="ln1133">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;motion-notify-event&quot;, G_CALLBACK(colorzones_motion_notify), self);</a>
<a name="ln1134">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;leave-notify-event&quot;, G_CALLBACK(colorzones_leave_notify), self);</a>
<a name="ln1135">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;enter-notify-event&quot;, G_CALLBACK(colorzones_enter_notify), self);</a>
<a name="ln1136">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;scroll-event&quot;, G_CALLBACK(colorzones_scrolled), self);</a>
<a name="ln1137"> </a>
<a name="ln1138"> </a>
<a name="ln1139">  cmsHPROFILE hsRGB = dt_colorspaces_get_profile(DT_COLORSPACE_SRGB, &quot;&quot;, DT_PROFILE_DIRECTION_IN)-&gt;profile;</a>
<a name="ln1140">  cmsHPROFILE hLab = dt_colorspaces_get_profile(DT_COLORSPACE_LAB, &quot;&quot;, DT_PROFILE_DIRECTION_ANY)-&gt;profile;</a>
<a name="ln1141">  c-&gt;xform = cmsCreateTransform(hLab, TYPE_Lab_DBL, hsRGB, TYPE_RGB_DBL, INTENT_PERCEPTUAL, 0);</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln1145">{</a>
<a name="ln1146">  dt_iop_colorzones_gui_data_t *c = (dt_iop_colorzones_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1147">  dt_conf_set_int(&quot;plugins/darkroom/colorzones/gui_channel&quot;, c-&gt;channel);</a>
<a name="ln1148">  cmsDeleteTransform(c-&gt;xform);</a>
<a name="ln1149">  dt_draw_curve_destroy(c-&gt;minmax_curve);</a>
<a name="ln1150">  free(self-&gt;gui_data);</a>
<a name="ln1151">  self-&gt;gui_data = NULL;</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1155">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1156">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="293"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 293, 291.</p></div>
<div class="balloon" rel="348"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 348, 343.</p></div>
<div class="balloon" rel="407"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 407, 392.</p></div>
<div class="balloon" rel="408"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 408, 393.</p></div>
<div class="balloon" rel="1059"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'c'. Check lines: 1059, 1054.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
