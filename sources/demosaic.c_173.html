
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4">    copyright (c) 2016 Ulrich Pegelow.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln21">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;common/interpolation.h&quot;</a>
<a name="ln24">#include &quot;common/opencl.h&quot;</a>
<a name="ln25">#include &quot;control/conf.h&quot;</a>
<a name="ln26">#include &quot;control/control.h&quot;</a>
<a name="ln27">#include &quot;develop/develop.h&quot;</a>
<a name="ln28">#include &quot;develop/imageop.h&quot;</a>
<a name="ln29">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln30">#include &quot;develop/tiling.h&quot;</a>
<a name="ln31">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln32">#include &quot;gui/gtk.h&quot;</a>
<a name="ln33">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;complex.h&gt;</a>
<a name="ln36">#include &lt;glib.h&gt;</a>
<a name="ln37">#include &lt;math.h&gt;</a>
<a name="ln38">#include &lt;memory.h&gt;</a>
<a name="ln39">#include &lt;stdlib.h&gt;</a>
<a name="ln40">#include &lt;string.h&gt;</a>
<a name="ln41"> </a>
<a name="ln42">// we assume people have -msee support.</a>
<a name="ln43">#if defined(__SSE__)</a>
<a name="ln44">#include &lt;xmmintrin.h&gt;</a>
<a name="ln45">#endif</a>
<a name="ln46"> </a>
<a name="ln47">DT_MODULE_INTROSPECTION(3, dt_iop_demosaic_params_t)</a>
<a name="ln48"> </a>
<a name="ln49">#define DEMOSAIC_XTRANS 1024 // masks for non-Bayer demosaic ops</a>
<a name="ln50">#define REDUCESIZE 64</a>
<a name="ln51"> </a>
<a name="ln52">typedef enum dt_iop_demosaic_method_t</a>
<a name="ln53">{</a>
<a name="ln54">  // methods for Bayer images</a>
<a name="ln55">  DT_IOP_DEMOSAIC_PPG = 0,</a>
<a name="ln56">  DT_IOP_DEMOSAIC_AMAZE = 1,</a>
<a name="ln57">  DT_IOP_DEMOSAIC_VNG4 = 2,</a>
<a name="ln58">  DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME = 3,</a>
<a name="ln59">  // methods for x-trans images</a>
<a name="ln60">  DT_IOP_DEMOSAIC_VNG = DEMOSAIC_XTRANS | 0,</a>
<a name="ln61">  DT_IOP_DEMOSAIC_MARKESTEIJN = DEMOSAIC_XTRANS | 1,</a>
<a name="ln62">  DT_IOP_DEMOSAIC_MARKESTEIJN_3 = DEMOSAIC_XTRANS | 2,</a>
<a name="ln63">  DT_IOP_DEMOSAIC_FDC = DEMOSAIC_XTRANS | 4</a>
<a name="ln64">} dt_iop_demosaic_method_t;</a>
<a name="ln65"> </a>
<a name="ln66">typedef enum dt_iop_demosaic_greeneq_t</a>
<a name="ln67">{</a>
<a name="ln68">  DT_IOP_GREEN_EQ_NO = 0,</a>
<a name="ln69">  DT_IOP_GREEN_EQ_LOCAL = 1,</a>
<a name="ln70">  DT_IOP_GREEN_EQ_FULL = 2,</a>
<a name="ln71">  DT_IOP_GREEN_EQ_BOTH = 3</a>
<a name="ln72">} dt_iop_demosaic_greeneq_t;</a>
<a name="ln73"> </a>
<a name="ln74">typedef enum dt_iop_demosaic_qual_flags_t</a>
<a name="ln75">{</a>
<a name="ln76">  // either perform full scale demosaicing or choose simple half scale</a>
<a name="ln77">  // or third scale interpolation instead</a>
<a name="ln78">  DEMOSAIC_FULL_SCALE              = 1 &lt;&lt; 0,</a>
<a name="ln79">  DEMOSAIC_ONLY_VNG_LINEAR         = 1 &lt;&lt; 1,</a>
<a name="ln80">  DEMOSAIC_XTRANS_FULL             = 1 &lt;&lt; 2,</a>
<a name="ln81">  DEMOSAIC_MEDIUM_QUAL             = 1 &lt;&lt; 3</a>
<a name="ln82">} dt_iop_demosaic_qual_flags_t;</a>
<a name="ln83"> </a>
<a name="ln84">typedef struct dt_iop_demosaic_params_t</a>
<a name="ln85">{</a>
<a name="ln86">  dt_iop_demosaic_greeneq_t green_eq;</a>
<a name="ln87">  float median_thrs;</a>
<a name="ln88">  uint32_t color_smoothing;</a>
<a name="ln89">  dt_iop_demosaic_method_t demosaicing_method;</a>
<a name="ln90">  uint32_t yet_unused_data_specific_to_demosaicing_method;</a>
<a name="ln91">} dt_iop_demosaic_params_t;</a>
<a name="ln92"> </a>
<a name="ln93">typedef struct dt_iop_demosaic_gui_data_t</a>
<a name="ln94">{</a>
<a name="ln95">  GtkWidget *box_raw;</a>
<a name="ln96">  GtkWidget *median_thrs;</a>
<a name="ln97">  GtkWidget *greeneq;</a>
<a name="ln98">  GtkWidget *color_smoothing;</a>
<a name="ln99">  GtkWidget *demosaic_method_bayer;</a>
<a name="ln100">  GtkWidget *demosaic_method_xtrans;</a>
<a name="ln101">  GtkWidget *label_non_raw;</a>
<a name="ln102">} dt_iop_demosaic_gui_data_t;</a>
<a name="ln103"> </a>
<a name="ln104">typedef struct dt_iop_demosaic_global_data_t</a>
<a name="ln105">{</a>
<a name="ln106">  // demosaic pattern</a>
<a name="ln107">  int kernel_green_eq_lavg;</a>
<a name="ln108">  int kernel_green_eq_favg_reduce_first;</a>
<a name="ln109">  int kernel_green_eq_favg_reduce_second;</a>
<a name="ln110">  int kernel_green_eq_favg_apply;</a>
<a name="ln111">  int kernel_pre_median;</a>
<a name="ln112">  int kernel_passthrough_monochrome;</a>
<a name="ln113">  int kernel_ppg_green;</a>
<a name="ln114">  int kernel_ppg_redblue;</a>
<a name="ln115">  int kernel_zoom_half_size;</a>
<a name="ln116">  int kernel_downsample;</a>
<a name="ln117">  int kernel_border_interpolate;</a>
<a name="ln118">  int kernel_color_smoothing;</a>
<a name="ln119">  int kernel_zoom_passthrough_monochrome;</a>
<a name="ln120">  int kernel_vng_border_interpolate;</a>
<a name="ln121">  int kernel_vng_lin_interpolate;</a>
<a name="ln122">  int kernel_zoom_third_size;</a>
<a name="ln123">  int kernel_vng_green_equilibrate;</a>
<a name="ln124">  int kernel_vng_interpolate;</a>
<a name="ln125">  int kernel_markesteijn_initial_copy;</a>
<a name="ln126">  int kernel_markesteijn_green_minmax;</a>
<a name="ln127">  int kernel_markesteijn_interpolate_green;</a>
<a name="ln128">  int kernel_markesteijn_solitary_green;</a>
<a name="ln129">  int kernel_markesteijn_recalculate_green;</a>
<a name="ln130">  int kernel_markesteijn_red_and_blue;</a>
<a name="ln131">  int kernel_markesteijn_interpolate_twoxtwo;</a>
<a name="ln132">  int kernel_markesteijn_convert_yuv;</a>
<a name="ln133">  int kernel_markesteijn_differentiate;</a>
<a name="ln134">  int kernel_markesteijn_homo_threshold;</a>
<a name="ln135">  int kernel_markesteijn_homo_set;</a>
<a name="ln136">  int kernel_markesteijn_homo_sum;</a>
<a name="ln137">  int kernel_markesteijn_homo_max;</a>
<a name="ln138">  int kernel_markesteijn_homo_max_corr;</a>
<a name="ln139">  int kernel_markesteijn_homo_quench;</a>
<a name="ln140">  int kernel_markesteijn_zero;</a>
<a name="ln141">  int kernel_markesteijn_accu;</a>
<a name="ln142">  int kernel_markesteijn_final;</a>
<a name="ln143">} dt_iop_demosaic_global_data_t;</a>
<a name="ln144"> </a>
<a name="ln145">typedef struct dt_iop_demosaic_data_t</a>
<a name="ln146">{</a>
<a name="ln147">  uint32_t green_eq;</a>
<a name="ln148">  uint32_t color_smoothing;</a>
<a name="ln149">  uint32_t demosaicing_method;</a>
<a name="ln150">  uint32_t yet_unused_data_specific_to_demosaicing_method;</a>
<a name="ln151">  float median_thrs;</a>
<a name="ln152">  double CAM_to_RGB[3][4];</a>
<a name="ln153">} dt_iop_demosaic_data_t;</a>
<a name="ln154"> </a>
<a name="ln155">void amaze_demosaic_RT(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln156">                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln157">                       const uint32_t filters);</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">const char *name()</a>
<a name="ln161">{</a>
<a name="ln162">  return _(&quot;demosaic&quot;);</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">int default_group()</a>
<a name="ln166">{</a>
<a name="ln167">  return IOP_GROUP_BASIC;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">int flags()</a>
<a name="ln171">{</a>
<a name="ln172">  return IOP_FLAGS_ALLOW_TILING | IOP_FLAGS_ONE_INSTANCE;</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln176">{</a>
<a name="ln177">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;edge threshold&quot;));</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln181">{</a>
<a name="ln182">  dt_accel_connect_slider_iop(self, &quot;edge threshold&quot;,</a>
<a name="ln183">                              GTK_WIDGET(((dt_iop_demosaic_gui_data_t *)self-&gt;gui_data)-&gt;median_thrs));</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln187">                  void *new_params, const int new_version)</a>
<a name="ln188">{</a>
<a name="ln189">  if(old_version == 2 &amp;&amp; new_version == 3)</a>
<a name="ln190">  {</a>
<a name="ln191">    dt_iop_demosaic_params_t *o = (dt_iop_demosaic_params_t *)old_params;</a>
<a name="ln192">    dt_iop_demosaic_params_t *n = (dt_iop_demosaic_params_t *)new_params;</a>
<a name="ln193">    n-&gt;green_eq = o-&gt;green_eq;</a>
<a name="ln194">    n-&gt;median_thrs = o-&gt;median_thrs;</a>
<a name="ln195">    n-&gt;color_smoothing = 0;</a>
<a name="ln196">    n-&gt;demosaicing_method = DT_IOP_DEMOSAIC_PPG;</a>
<a name="ln197">    n-&gt;yet_unused_data_specific_to_demosaicing_method = 0;</a>
<a name="ln198">    return 0;</a>
<a name="ln199">  }</a>
<a name="ln200">  return 1;</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">#ifdef HAVE_OPENCL</a>
<a name="ln204">static const char* method2string(dt_iop_demosaic_method_t method)</a>
<a name="ln205">{</a>
<a name="ln206">  const char *string;</a>
<a name="ln207"> </a>
<a name="ln208">  switch(method)</a>
<a name="ln209">  {</a>
<a name="ln210">    case DT_IOP_DEMOSAIC_PPG:</a>
<a name="ln211">      string = &quot;PPG&quot;;</a>
<a name="ln212">      break;</a>
<a name="ln213">    case DT_IOP_DEMOSAIC_AMAZE:</a>
<a name="ln214">      string = &quot;AMaZE&quot;;</a>
<a name="ln215">      break;</a>
<a name="ln216">    case DT_IOP_DEMOSAIC_VNG4:</a>
<a name="ln217">      string = &quot;VNG4&quot;;</a>
<a name="ln218">      break;</a>
<a name="ln219">    case DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME:</a>
<a name="ln220">      string = &quot;passthrough monochrome&quot;;</a>
<a name="ln221">      break;</a>
<a name="ln222">    case DT_IOP_DEMOSAIC_VNG:</a>
<a name="ln223">      string = &quot;VNG (xtrans)&quot;;</a>
<a name="ln224">      break;</a>
<a name="ln225">    case DT_IOP_DEMOSAIC_MARKESTEIJN:</a>
<a name="ln226">      string = &quot;Markesteijn-1 (xtrans)&quot;;</a>
<a name="ln227">      break;</a>
<a name="ln228">    case DT_IOP_DEMOSAIC_MARKESTEIJN_3:</a>
<a name="ln229">      string = &quot;Markesteijn-3 (xtrans)&quot;;</a>
<a name="ln230">      break;</a>
<a name="ln231">    case DT_IOP_DEMOSAIC_FDC:</a>
<a name="ln232">      string = &quot;Frequency Domain Chroma (xtrans)&quot;;</a>
<a name="ln233">      break;</a>
<a name="ln234">    default:</a>
<a name="ln235">      string = &quot;(unknown method)&quot;;</a>
<a name="ln236">  }</a>
<a name="ln237">  return string;</a>
<a name="ln238">}</a>
<a name="ln239">#endif</a>
<a name="ln240"> </a>
<a name="ln241">#define SWAP(a, b)                                                                                           \</a>
<a name="ln242">  {                                                                                                          \</a>
<a name="ln243">    const float tmp = (b);                                                                                   \</a>
<a name="ln244">    (b) = (a);                                                                                               \</a>
<a name="ln245">    (a) = tmp;                                                                                               \</a>
<a name="ln246">  }</a>
<a name="ln247"> </a>
<a name="ln248">static void pre_median_b(float *out, const float *const in, const dt_iop_roi_t *const roi, const uint32_t filters,</a>
<a name="ln249">                         const int num_passes, const float threshold)</a>
<a name="ln250">{</a>
<a name="ln251">#if 1</a>
<a name="ln252">  memcpy(out, in, (size_t)roi-&gt;width * roi-&gt;height * sizeof(float));</a>
<a name="ln253">#else</a>
<a name="ln254">  // colors:</a>
<a name="ln255">  const float thrsc = 2 * threshold;</a>
<a name="ln256">  for(int pass = 0; pass &lt; num_passes; pass++)</a>
<a name="ln257">  {</a>
<a name="ln258">    for(int c = 0; c &lt; 3; c += 2)</a>
<a name="ln259">    {</a>
<a name="ln260">      int rows = 3;</a>
<a name="ln261">      if(FC(rows, 3, filters) != c &amp;&amp; FC(rows, 4, filters) != c) rows++;</a>
<a name="ln262">#ifdef _OPENMP</a>
<a name="ln263">#pragma omp parallel for default(none) shared(rows, c, out) schedule(static)</a>
<a name="ln264">#endif</a>
<a name="ln265">      for(int row = rows; row &lt; roi-&gt;height - 3; row += 2)</a>
<a name="ln266">      {</a>
<a name="ln267">        float med[9];</a>
<a name="ln268">        int col = 3;</a>
<a name="ln269">        if(FC(row, col, filters) != c) col++;</a>
<a name="ln270">        float *pixo = out + (size_t)roi-&gt;width * row + col;</a>
<a name="ln271">        const float *pixi = in + (size_t)roi-&gt;width * row + col;</a>
<a name="ln272">        for(; col &lt; roi-&gt;width - 3; col += 2)</a>
<a name="ln273">        {</a>
<a name="ln274">          int cnt = 0;</a>
<a name="ln275">          for(int k = 0, i = -2 * roi-&gt;width; i &lt;= 2 * roi-&gt;width; i += 2 * roi-&gt;width)</a>
<a name="ln276">          {</a>
<a name="ln277">            for(int j = i - 2; j &lt;= i + 2; j += 2)</a>
<a name="ln278">            {</a>
<a name="ln279">              if(fabsf(pixi[j] - pixi[0]) &lt; thrsc)</a>
<a name="ln280">              {</a>
<a name="ln281">                med[k++] = pixi[j];</a>
<a name="ln282">                cnt++;</a>
<a name="ln283">              }</a>
<a name="ln284">              else</a>
<a name="ln285">                med[k++] = 64.0f + pixi[j];</a>
<a name="ln286">            }</a>
<a name="ln287">          }</a>
<a name="ln288">          for(int i = 0; i &lt; 8; i++)</a>
<a name="ln289">            for(int ii = i + 1; ii &lt; 9; ii++)</a>
<a name="ln290">              if(med[i] &gt; med[ii]) SWAP(med[i], med[ii]);</a>
<a name="ln291">#if 0</a>
<a name="ln292">          // cnt == 1 and no small edge in greens.</a>
<a name="ln293">          if(fabsf(pixi[-roi-&gt;width] - pixi[+roi-&gt;width]) + fabsf(pixi[-1] - pixi[+1])</a>
<a name="ln294">              + fabsf(pixi[-roi-&gt;width] - pixi[+1]) + fabsf(pixi[-1] - pixi[+roi-&gt;width])</a>
<a name="ln295">              + fabsf(pixi[+roi-&gt;width] - pixi[+1]) + fabsf(pixi[-1] - pixi[-roi-&gt;width])</a>
<a name="ln296">              &gt; 0.06)</a>
<a name="ln297">            pixo[0] = med[(cnt-1)/2];</a>
<a name="ln298">          else</a>
<a name="ln299">#endif</a>
<a name="ln300">          pixo[0] = (cnt == 1 ? med[4] - 64.0f : med[(cnt - 1) / 2]);</a>
<a name="ln301">          pixo += 2;</a>
<a name="ln302">          pixi += 2;</a>
<a name="ln303">        }</a>
<a name="ln304">      }</a>
<a name="ln305">    }</a>
<a name="ln306">  }</a>
<a name="ln307">#endif</a>
<a name="ln308"> </a>
<a name="ln309">  // now green:</a>
<a name="ln310">  const int lim[5] = { 0, 1, 2, 1, 0 };</a>
<a name="ln311">  for(int pass = 0; pass &lt; num_passes; pass++)</a>
<a name="ln312">  {</a>
<a name="ln313">#ifdef _OPENMP</a>
<a name="ln314">#pragma omp parallel for default(none) shared(out) schedule(static)</a>
<a name="ln315">#endif</a>
<a name="ln316">    for(int row = 3; row &lt; roi-&gt;height - 3; row++)</a>
<a name="ln317">    {</a>
<a name="ln318">      float med[9];</a>
<a name="ln319">      int col = 3;</a>
<a name="ln320">      if(FC(row, col, filters) != 1 &amp;&amp; FC(row, col, filters) != 3) col++;</a>
<a name="ln321">      float *pixo = out + (size_t)roi-&gt;width * row + col;</a>
<a name="ln322">      const float *pixi = in + (size_t)roi-&gt;width * row + col;</a>
<a name="ln323">      for(; col &lt; roi-&gt;width - 3; col += 2)</a>
<a name="ln324">      {</a>
<a name="ln325">        int cnt = 0;</a>
<a name="ln326">        for(int k = 0, i = 0; i &lt; 5; i++)</a>
<a name="ln327">        {</a>
<a name="ln328">          for(int j = -lim[i]; j &lt;= lim[i]; j += 2)</a>
<a name="ln329">          {</a>
<a name="ln330">            if(fabsf(pixi[roi-&gt;width * (i - 2) + j] - pixi[0]) &lt; threshold)</a>
<a name="ln331">            {</a>
<a name="ln332">              med[k++] = pixi[roi-&gt;width * (i - 2) + j];</a>
<a name="ln333">              cnt++;</a>
<a name="ln334">            }</a>
<a name="ln335">            else</a>
<a name="ln336">              med[k++] = 64.0f + pixi[roi-&gt;width * (i - 2) + j];</a>
<a name="ln337">          }</a>
<a name="ln338">        }</a>
<a name="ln339">        for(int i = 0; i &lt; 8; i++)</a>
<a name="ln340">          for(int ii = i + 1; ii &lt; 9; ii++)</a>
<a name="ln341">            if(med[i] &gt; med[ii]) SWAP(med[i], med[ii]);</a>
<a name="ln342">        pixo[0] = (cnt == 1 ? med[4] - 64.0f : med[(cnt - 1) / 2]);</a>
<a name="ln343">        // pixo[0] = med[(cnt-1)/2];</a>
<a name="ln344">        pixo += 2;</a>
<a name="ln345">        pixi += 2;</a>
<a name="ln346">      }</a>
<a name="ln347">    }</a>
<a name="ln348">  }</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">static void pre_median(float *out, const float *const in, const dt_iop_roi_t *const roi, const uint32_t filters,</a>
<a name="ln352">                       const int num_passes, const float threshold)</a>
<a name="ln353">{</a>
<a name="ln354">  pre_median_b(out, in, roi, filters, num_passes, threshold);</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">#define SWAPmed(I, J)                                                                                        \</a>
<a name="ln358">  if(med[I] &gt; med[J]) SWAP(med[I], med[J])</a>
<a name="ln359"> </a>
<a name="ln360">static void color_smoothing(float *out, const dt_iop_roi_t *const roi_out, const int num_passes)</a>
<a name="ln361">{</a>
<a name="ln362">  const int width4 = 4 * roi_out-&gt;width;</a>
<a name="ln363"> </a>
<a name="ln364">  for(int pass = 0; pass &lt; num_passes; pass++)</a>
<a name="ln365">  {</a>
<a name="ln366">    for(int c = 0; c &lt; 3; c += 2)</a>
<a name="ln367">    {</a>
<a name="ln368">      {</a>
<a name="ln369">        float *outp = out;</a>
<a name="ln370">        for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln371">          for(int i = 0; i &lt; roi_out-&gt;width; i++, outp += 4) outp[3] = outp[c];</a>
<a name="ln372">      }</a>
<a name="ln373">#ifdef _OPENMP</a>
<a name="ln374">#pragma omp parallel for schedule(static) default(none) shared(out, c)</a>
<a name="ln375">#endif</a>
<a name="ln376">      for(int j = 1; j &lt; roi_out-&gt;height - 1; j++)</a>
<a name="ln377">      {</a>
<a name="ln378">        float *outp = out + (size_t)4 * j * roi_out-&gt;width + 4;</a>
<a name="ln379">        for(int i = 1; i &lt; roi_out-&gt;width - 1; i++, outp += 4)</a>
<a name="ln380">        {</a>
<a name="ln381">          float med[9] = {</a>
<a name="ln382">            outp[-width4 - 4 + 3] - outp[-width4 - 4 + 1], outp[-width4 + 0 + 3] - outp[-width4 + 0 + 1],</a>
<a name="ln383">            outp[-width4 + 4 + 3] - outp[-width4 + 4 + 1], outp[-4 + 3] - outp[-4 + 1],</a>
<a name="ln384">            outp[+0 + 3] - outp[+0 + 1], outp[+4 + 3] - outp[+4 + 1],</a>
<a name="ln385">            outp[+width4 - 4 + 3] - outp[+width4 - 4 + 1], outp[+width4 + 0 + 3] - outp[+width4 + 0 + 1],</a>
<a name="ln386">            outp[+width4 + 4 + 3] - outp[+width4 + 4 + 1],</a>
<a name="ln387">          };</a>
<a name="ln388">          /* optimal 9-element median search */</a>
<a name="ln389">          SWAPmed(1, 2);</a>
<a name="ln390">          SWAPmed(4, 5);</a>
<a name="ln391">          SWAPmed(7, 8);</a>
<a name="ln392">          SWAPmed(0, 1);</a>
<a name="ln393">          SWAPmed(3, 4);</a>
<a name="ln394">          SWAPmed(6, 7);</a>
<a name="ln395">          SWAPmed(1, 2);</a>
<a name="ln396">          SWAPmed(4, 5);</a>
<a name="ln397">          SWAPmed(7, 8);</a>
<a name="ln398">          SWAPmed(0, 3);</a>
<a name="ln399">          SWAPmed(5, 8);</a>
<a name="ln400">          SWAPmed(4, 7);</a>
<a name="ln401">          SWAPmed(3, 6);</a>
<a name="ln402">          SWAPmed(1, 4);</a>
<a name="ln403">          SWAPmed(2, 5);</a>
<a name="ln404">          SWAPmed(4, 7);</a>
<a name="ln405">          SWAPmed(4, 2);</a>
<a name="ln406">          SWAPmed(6, 4);</a>
<a name="ln407">          SWAPmed(4, 2);</a>
<a name="ln408">          outp[c] = fmaxf(med[4] + outp[1], 0.0f);</a>
<a name="ln409">        }</a>
<a name="ln410">      }</a>
<a name="ln411">    }</a>
<a name="ln412">  }</a>
<a name="ln413">}</a>
<a name="ln414">#undef SWAP</a>
<a name="ln415"> </a>
<a name="ln416">static void green_equilibration_lavg(float *out, const float *const in, const int width, const int height,</a>
<a name="ln417">                                     const uint32_t filters, const int x, const int y, const float thr)</a>
<a name="ln418">{</a>
<a name="ln419">  const float maximum = 1.0f;</a>
<a name="ln420"> </a>
<a name="ln421">  int oj = 2, oi = 2;</a>
<a name="ln422">  if(FC(oj + y, oi + x, filters) != 1) oj++;</a>
<a name="ln423">  if(FC(oj + y, oi + x, filters) != 1) oi++;</a>
<a name="ln424">  if(FC(oj + y, oi + x, filters) != 1) oj--;</a>
<a name="ln425"> </a>
<a name="ln426">  memcpy(out, in, height * width * sizeof(float));</a>
<a name="ln427"> </a>
<a name="ln428">#ifdef _OPENMP</a>
<a name="ln429">#pragma omp parallel for schedule(static) default(none) shared(out, oi, oj)</a>
<a name="ln430">#endif</a>
<a name="ln431">  for(size_t j = oj; j &lt; height - 2; j += 2)</a>
<a name="ln432">  {</a>
<a name="ln433">    for(size_t i = oi; i &lt; width - 2; i += 2)</a>
<a name="ln434">    {</a>
<a name="ln435">      const float o1_1 = in[(j - 1) * width + i - 1];</a>
<a name="ln436">      const float o1_2 = in[(j - 1) * width + i + 1];</a>
<a name="ln437">      const float o1_3 = in[(j + 1) * width + i - 1];</a>
<a name="ln438">      const float o1_4 = in[(j + 1) * width + i + 1];</a>
<a name="ln439">      const float o2_1 = in[(j - 2) * width + i];</a>
<a name="ln440">      const float o2_2 = in[(j + 2) * width + i];</a>
<a name="ln441">      const float o2_3 = in[j * width + i - 2];</a>
<a name="ln442">      const float o2_4 = in[j * width + i + 2];</a>
<a name="ln443"> </a>
<a name="ln444">      const float m1 = (o1_1 + o1_2 + o1_3 + o1_4) / 4.0f;</a>
<a name="ln445">      const float m2 = (o2_1 + o2_2 + o2_3 + o2_4) / 4.0f;</a>
<a name="ln446"> </a>
<a name="ln447">      // prevent divide by zero and ...</a>
<a name="ln448">      // guard against m1/m2 becoming too large (due to m2 being too small) which results in hot pixels</a>
<a name="ln449">      if(m2 &gt; 0.0f &amp;&amp; m1 / m2 &lt; maximum * 2.0f)</a>
<a name="ln450">      {</a>
<a name="ln451">        const float c1 = (fabsf(o1_1 - o1_2) + fabsf(o1_1 - o1_3) + fabsf(o1_1 - o1_4) + fabsf(o1_2 - o1_3)</a>
<a name="ln452">                          + fabsf(o1_3 - o1_4) + fabsf(o1_2 - o1_4)) / 6.0f;</a>
<a name="ln453">        const float c2 = (fabsf(o2_1 - o2_2) + fabsf(o2_1 - o2_3) + fabsf(o2_1 - o2_4) + fabsf(o2_2 - o2_3)</a>
<a name="ln454">                          + fabsf(o2_3 - o2_4) + fabsf(o2_2 - o2_4)) / 6.0f;</a>
<a name="ln455">        if((in[j * width + i] &lt; maximum * 0.95f) &amp;&amp; (c1 &lt; maximum * thr) &amp;&amp; (c2 &lt; maximum * thr))</a>
<a name="ln456">        {</a>
<a name="ln457">          out[j * width + i] = in[j * width + i] * m1 / m2;</a>
<a name="ln458">        }</a>
<a name="ln459">      }</a>
<a name="ln460">    }</a>
<a name="ln461">  }</a>
<a name="ln462">}</a>
<a name="ln463"> </a>
<a name="ln464">static void green_equilibration_favg(float *out, const float *const in, const int width, const int height,</a>
<a name="ln465">                                     const uint32_t filters, const int x, const int y)</a>
<a name="ln466">{</a>
<a name="ln467">  int oj = 0, oi = 0;</a>
<a name="ln468">  // const float ratio_max = 1.1f;</a>
<a name="ln469">  double sum1 = 0.0, sum2 = 0.0, gr_ratio;</a>
<a name="ln470"> </a>
<a name="ln471">  if((FC(oj + y, oi + x, filters) &amp; 1) != 1) oi++;</a>
<a name="ln472">  const int g2_offset = oi ? -1 : 1;</a>
<a name="ln473">  memcpy(out, in, (size_t)height * width * sizeof(float));</a>
<a name="ln474">#ifdef _OPENMP</a>
<a name="ln475">#pragma omp parallel for schedule(static) default(none) reduction(+ : sum1, sum2) shared(oi, oj)</a>
<a name="ln476">#endif</a>
<a name="ln477">  for(size_t j = oj; j &lt; (height - 1); j += 2)</a>
<a name="ln478">  {</a>
<a name="ln479">    for(size_t i = oi; i &lt; (width - 1 - g2_offset); i += 2)</a>
<a name="ln480">    {</a>
<a name="ln481">      sum1 += in[j * width + i];</a>
<a name="ln482">      sum2 += in[(j + 1) * width + i + g2_offset];</a>
<a name="ln483">    }</a>
<a name="ln484">  }</a>
<a name="ln485"> </a>
<a name="ln486">  if(sum1 &gt; 0.0 &amp;&amp; sum2 &gt; 0.0)</a>
<a name="ln487">    gr_ratio = sum2 / sum1;</a>
<a name="ln488">  else</a>
<a name="ln489">    return;</a>
<a name="ln490"> </a>
<a name="ln491">#ifdef _OPENMP</a>
<a name="ln492">#pragma omp parallel for schedule(static) default(none) shared(out, oi, oj, gr_ratio)</a>
<a name="ln493">#endif</a>
<a name="ln494">  for(int j = oj; j &lt; (height - 1); j += 2)</a>
<a name="ln495">  {</a>
<a name="ln496">    for(int i = oi; i &lt; (width - 1 - g2_offset); i += 2)</a>
<a name="ln497">    {</a>
<a name="ln498">      out[(size_t)j * width + i] = in[(size_t)j * width + i] * gr_ratio;</a>
<a name="ln499">    }</a>
<a name="ln500">  }</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503"> </a>
<a name="ln504">//</a>
<a name="ln505">// x-trans specific demosaicing algorithms</a>
<a name="ln506">//</a>
<a name="ln507"> </a>
<a name="ln508">// xtrans_interpolate adapted from dcraw 9.20</a>
<a name="ln509"> </a>
<a name="ln510">#define SQR(x) ((x) * (x))</a>
<a name="ln511">// tile size, optimized to keep data in L2 cache</a>
<a name="ln512">#define TS 122</a>
<a name="ln513"> </a>
<a name="ln514">/** Lookup for allhex[], making sure that row/col aren't negative **/</a>
<a name="ln515">static inline const short *const hexmap(const int row, const int col,</a>
<a name="ln516">                                        short (*const allhex)[3][8])</a>
<a name="ln517">{</a>
<a name="ln518">  // Row and column offsets may be negative, but C's modulo function</a>
<a name="ln519">  // is not useful here with a negative dividend. To be safe, add a</a>
<a name="ln520">  // fairly large multiple of 3. In current code row and col will</a>
<a name="ln521">  // never be less than -9 (1-pass) or -14 (3-pass).</a>
<a name="ln522">  int irow = row + 600;</a>
<a name="ln523">  int icol = col + 600;</a>
<a name="ln524">  assert(irow &gt;= 0 &amp;&amp; icol &gt;= 0);</a>
<a name="ln525">  return allhex[irow % 3][icol % 3];</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">/*</a>
<a name="ln529">   Frank Markesteijn's algorithm for Fuji X-Trans sensors</a>
<a name="ln530"> */</a>
<a name="ln531">static void xtrans_markesteijn_interpolate(float *out, const float *const in,</a>
<a name="ln532">                                           const dt_iop_roi_t *const roi_out,</a>
<a name="ln533">                                           const dt_iop_roi_t *const roi_in,</a>
<a name="ln534">                                           const uint8_t (*const xtrans)[6], const int passes)</a>
<a name="ln535">{</a>
<a name="ln536">  static const short orth[12] = { 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1 },</a>
<a name="ln537">                     patt[2][16] = { { 0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0 },</a>
<a name="ln538">                                     { 0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1 } },</a>
<a name="ln539">                     dir[4] = { 1, TS, TS + 1, TS - 1 };</a>
<a name="ln540"> </a>
<a name="ln541">  short allhex[3][3][8];</a>
<a name="ln542">  // sgrow/sgcol is the offset in the sensor matrix of the solitary</a>
<a name="ln543">  // green pixels (initialized here only to avoid compiler warning)</a>
<a name="ln544">  unsigned short sgrow = 0, sgcol = 0;</a>
<a name="ln545"> </a>
<a name="ln546">  const int width = roi_out-&gt;width;</a>
<a name="ln547">  const int height = roi_out-&gt;height;</a>
<a name="ln548">  const int ndir = 4 &lt;&lt; (passes &gt; 1);</a>
<a name="ln549"> </a>
<a name="ln550">  const size_t buffer_size = (size_t)TS * TS * (ndir * 4 + 3) * sizeof(float);</a>
<a name="ln551">  char *const all_buffers = (char *)dt_alloc_align(64, dt_get_num_threads() * buffer_size);</a>
<a name="ln552">  if(!all_buffers)</a>
<a name="ln553">  {</a>
<a name="ln554">    printf(&quot;[demosaic] not able to allocate Markesteijn buffers\n&quot;);</a>
<a name="ln555">    return;</a>
<a name="ln556">  }</a>
<a name="ln557"> </a>
<a name="ln558">  /* Map a green hexagon around each non-green pixel and vice versa:    */</a>
<a name="ln559">  for(int row = 0; row &lt; 3; row++)</a>
<a name="ln560">    for(int col = 0; col &lt; 3; col++)</a>
<a name="ln561">      for(int ng = 0, d = 0; d &lt; 10; d += 2)</a>
<a name="ln562">      {</a>
<a name="ln563">        int g = FCxtrans(row, col, NULL, xtrans) == 1;</a>
<a name="ln564">        if(FCxtrans(row + orth[d], col + orth[d + 2], NULL, xtrans) == 1)</a>
<a name="ln565">          ng = 0;</a>
<a name="ln566">        else</a>
<a name="ln567">          ng++;</a>
<a name="ln568">        // if there are four non-green pixels adjacent in cardinal</a>
<a name="ln569">        // directions, this is the solitary green pixel</a>
<a name="ln570">        if(ng == 4)</a>
<a name="ln571">        {</a>
<a name="ln572">          sgrow = row;</a>
<a name="ln573">          sgcol = col;</a>
<a name="ln574">        }</a>
<a name="ln575">        if(ng == g + 1)</a>
<a name="ln576">          for(int c = 0; c &lt; 8; c++)</a>
<a name="ln577">          {</a>
<a name="ln578">            int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];</a>
<a name="ln579">            int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];</a>
<a name="ln580">            // offset within TSxTS buffer</a>
<a name="ln581">            allhex[row][col][c ^ (g * 2 &amp; d)] = h + v * TS;</a>
<a name="ln582">          }</a>
<a name="ln583">      }</a>
<a name="ln584"> </a>
<a name="ln585">  // extra passes propagates out errors at edges, hence need more padding</a>
<a name="ln586">  const int pad_tile = (passes == 1) ? 12 : 17;</a>
<a name="ln587">#ifdef _OPENMP</a>
<a name="ln588">#pragma omp parallel for default(none) shared(sgrow, sgcol, allhex, out) schedule(dynamic)</a>
<a name="ln589">#endif</a>
<a name="ln590">  // step through TSxTS cells of image, each tile overlapping the</a>
<a name="ln591">  // prior as interpolation needs a substantial border</a>
<a name="ln592">  for(int top = -pad_tile; top &lt; height - pad_tile; top += TS - (pad_tile*2))</a>
<a name="ln593">  {</a>
<a name="ln594">    char *const buffer = all_buffers + dt_get_thread_num() * buffer_size;</a>
<a name="ln595">    // rgb points to ndir TSxTS tiles of 3 channels (R, G, and B)</a>
<a name="ln596">    float(*rgb)[TS][TS][3] = (float(*)[TS][TS][3])buffer;</a>
<a name="ln597">    // yuv points to 3 channel (Y, u, and v) TSxTS tiles</a>
<a name="ln598">    // note that channels come before tiles to allow for a</a>
<a name="ln599">    // vectorization optimization when building drv[] from yuv[]</a>
<a name="ln600">    float (*const yuv)[TS][TS] = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln601">    // drv points to ndir TSxTS tiles, each a single chanel of derivatives</a>
<a name="ln602">    float (*const drv)[TS][TS] = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 3 + 3) * sizeof(float));</a>
<a name="ln603">    // gmin and gmax reuse memory which is used later by yuv buffer;</a>
<a name="ln604">    // each points to a TSxTS tile of single channel data</a>
<a name="ln605">    float (*const gmin)[TS] = (float(*)[TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln606">    float (*const gmax)[TS] = (float(*)[TS])(buffer + TS * TS * (ndir * 3 + 1) * sizeof(float));</a>
<a name="ln607">    // homo and homosum reuse memory which is used earlier in the</a>
<a name="ln608">    // loop; each points to ndir single-channel TSxTS tiles</a>
<a name="ln609">    uint8_t (*const homo)[TS][TS] = (uint8_t(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln610">    uint8_t (*const homosum)[TS][TS] = (uint8_t(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float)</a>
<a name="ln611">                                                            + TS * TS * ndir * sizeof(uint8_t));</a>
<a name="ln612"> </a>
<a name="ln613">    for(int left = -pad_tile; left &lt; width - pad_tile; left += TS - (pad_tile*2))</a>
<a name="ln614">    {</a>
<a name="ln615">      int mrow = MIN(top + TS, height + pad_tile);</a>
<a name="ln616">      int mcol = MIN(left + TS, width + pad_tile);</a>
<a name="ln617"> </a>
<a name="ln618">      // Copy current tile from in to image buffer. If border goes</a>
<a name="ln619">      // beyond edges of image, fill with mirrored/interpolated edges.</a>
<a name="ln620">      // The extra border avoids discontinuities at image edges.</a>
<a name="ln621">      for(int row = top; row &lt; mrow; row++)</a>
<a name="ln622">        for(int col = left; col &lt; mcol; col++)</a>
<a name="ln623">        {</a>
<a name="ln624">          float(*const pix) = rgb[0][row - top][col - left];</a>
<a name="ln625">          if((col &gt;= 0) &amp;&amp; (row &gt;= 0) &amp;&amp; (col &lt; width) &amp;&amp; (row &lt; height))</a>
<a name="ln626">          {</a>
<a name="ln627">            const int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln628">            for(int c = 0; c &lt; 3; c++) pix[c] = (c == f) ? in[roi_in-&gt;width * row + col] : 0.f;</a>
<a name="ln629">          }</a>
<a name="ln630">          else</a>
<a name="ln631">          {</a>
<a name="ln632">            // mirror a border pixel if beyond image edge</a>
<a name="ln633">            const int c = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln634">            for(int cc = 0; cc &lt; 3; cc++)</a>
<a name="ln635">              if(cc != c)</a>
<a name="ln636">                pix[cc] = 0.0f;</a>
<a name="ln637">              else</a>
<a name="ln638">              {</a>
<a name="ln639">#define TRANSLATE(n, size) ((n &gt;= size) ? (2 * size - n - 2) : abs(n))</a>
<a name="ln640">                const int cy = TRANSLATE(row, height), cx = TRANSLATE(col, width);</a>
<a name="ln641">                if(c == FCxtrans(cy, cx, roi_in, xtrans))</a>
<a name="ln642">                  pix[c] = in[roi_in-&gt;width * cy + cx];</a>
<a name="ln643">                else</a>
<a name="ln644">                {</a>
<a name="ln645">                  // interpolate if mirror pixel is a different color</a>
<a name="ln646">                  float sum = 0.0f;</a>
<a name="ln647">                  uint8_t count = 0;</a>
<a name="ln648">                  for(int y = row - 1; y &lt;= row + 1; y++)</a>
<a name="ln649">                    for(int x = col - 1; x &lt;= col + 1; x++)</a>
<a name="ln650">                    {</a>
<a name="ln651">                      const int yy = TRANSLATE(y, height), xx = TRANSLATE(x, width);</a>
<a name="ln652">                      const int ff = FCxtrans(yy, xx, roi_in, xtrans);</a>
<a name="ln653">                      if(ff == c)</a>
<a name="ln654">                      {</a>
<a name="ln655">                        sum += in[roi_in-&gt;width * yy + xx];</a>
<a name="ln656">                        count++;</a>
<a name="ln657">                      }</a>
<a name="ln658">                    }</a>
<a name="ln659">                  pix[c] = sum / count;</a>
<a name="ln660">                }</a>
<a name="ln661">              }</a>
<a name="ln662">          }</a>
<a name="ln663">        }</a>
<a name="ln664"> </a>
<a name="ln665">      // duplicate rgb[0] to rgb[1], rgb[2], and rgb[3]</a>
<a name="ln666">      for(int c = 1; c &lt;= 3; c++) memcpy(rgb[c], rgb[0], sizeof(*rgb));</a>
<a name="ln667"> </a>
<a name="ln668">      // note that successive calculations are inset within the tile</a>
<a name="ln669">      // so as to give enough border data, and there needs to be a 6</a>
<a name="ln670">      // pixel border initially to allow allhex to find neighboring</a>
<a name="ln671">      // pixels</a>
<a name="ln672"> </a>
<a name="ln673">      /* Set green1 and green3 to the minimum and maximum allowed values:   */</a>
<a name="ln674">      // Run through each red/blue or blue/red pair, setting their g1</a>
<a name="ln675">      // and g3 values to the min/max of green pixels surrounding the</a>
<a name="ln676">      // pair. Use a 3 pixel border as gmin/gmax is used by</a>
<a name="ln677">      // interpolate green which has a 3 pixel border.</a>
<a name="ln678">      const int pad_g1_g3 = 3;</a>
<a name="ln679">      for(int row = top + pad_g1_g3; row &lt; mrow - pad_g1_g3; row++)</a>
<a name="ln680">      {</a>
<a name="ln681">        // setting max to 0.0f signifies that this is a new pair, which</a>
<a name="ln682">        // requires a new min/max calculation of its neighboring greens</a>
<a name="ln683">        float min = FLT_MAX, max = 0.0f;</a>
<a name="ln684">        for(int col = left + pad_g1_g3; col &lt; mcol - pad_g1_g3; col++)</a>
<a name="ln685">        {</a>
<a name="ln686">          // if in row of horizontal red &amp; blue pairs (or processing</a>
<a name="ln687">          // vertical red &amp; blue pairs near image bottom), reset min/max</a>
<a name="ln688">          // between each pair</a>
<a name="ln689">          if(FCxtrans(row, col, roi_in, xtrans) == 1)</a>
<a name="ln690">          {</a>
<a name="ln691">            min = FLT_MAX, max = 0.0f;</a>
<a name="ln692">            continue;</a>
<a name="ln693">          }</a>
<a name="ln694">          // if at start of red &amp; blue pair, calculate min/max of green</a>
<a name="ln695">          // pixels surrounding it; note that while normally using == to</a>
<a name="ln696">          // compare floats is suspect, here the check is if 0.0f has</a>
<a name="ln697">          // explicitly been assigned to max (which signifies a new</a>
<a name="ln698">          // red/blue pair)</a>
<a name="ln699">          if(max == 0.0f)</a>
<a name="ln700">          {</a>
<a name="ln701">            float (*const pix)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln702">            const short *const hex = hexmap(row,col,allhex);</a>
<a name="ln703">            for(int c = 0; c &lt; 6; c++)</a>
<a name="ln704">            {</a>
<a name="ln705">              const float val = pix[hex[c]][1];</a>
<a name="ln706">              if(min &gt; val) min = val;</a>
<a name="ln707">              if(max &lt; val) max = val;</a>
<a name="ln708">            }</a>
<a name="ln709">          }</a>
<a name="ln710">          gmin[row - top][col - left] = min;</a>
<a name="ln711">          gmax[row - top][col - left] = max;</a>
<a name="ln712">          // handle vertical red/blue pairs</a>
<a name="ln713">          switch((row - sgrow) % 3)</a>
<a name="ln714">          {</a>
<a name="ln715">            // hop down a row to second pixel in vertical pair</a>
<a name="ln716">            case 1:</a>
<a name="ln717">              if(row &lt; mrow - 4) row++, col--;</a>
<a name="ln718">              break;</a>
<a name="ln719">            // then if not done with the row hop up and right to next</a>
<a name="ln720">            // vertical red/blue pair, resetting min/max</a>
<a name="ln721">            case 2:</a>
<a name="ln722">              min = FLT_MAX, max = 0.0f;</a>
<a name="ln723">              if((col += 2) &lt; mcol - 4 &amp;&amp; row &gt; top + 3) row--;</a>
<a name="ln724">          }</a>
<a name="ln725">        }</a>
<a name="ln726">      }</a>
<a name="ln727"> </a>
<a name="ln728">      /* Interpolate green horizontally, vertically, and along both diagonals: */</a>
<a name="ln729">      // need a 3 pixel border here as 3*hex[] can have a 3 unit offset</a>
<a name="ln730">      const int pad_g_interp = 3;</a>
<a name="ln731">      for(int row = top + pad_g_interp; row &lt; mrow - pad_g_interp; row++)</a>
<a name="ln732">        for(int col = left + pad_g_interp; col &lt; mcol - pad_g_interp; col++)</a>
<a name="ln733">        {</a>
<a name="ln734">          float color[8];</a>
<a name="ln735">          int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln736">          if(f == 1) continue;</a>
<a name="ln737">          float (*const pix)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln738">          const short *const hex = hexmap(row,col,allhex);</a>
<a name="ln739">          // TODO: these constants come from integer math constants in</a>
<a name="ln740">          // dcraw -- calculate them instead from interpolation math</a>
<a name="ln741">          color[0] = 0.6796875f * (pix[hex[1]][1] + pix[hex[0]][1])</a>
<a name="ln742">                     - 0.1796875f * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);</a>
<a name="ln743">          color[1] = 0.87109375f * pix[hex[3]][1] + pix[hex[2]][1] * 0.13f</a>
<a name="ln744">                     + 0.359375f * (pix[0][f] - pix[-hex[2]][f]);</a>
<a name="ln745">          for(int c = 0; c &lt; 2; c++)</a>
<a name="ln746">            color[2 + c] = 0.640625f * pix[hex[4 + c]][1] + 0.359375f * pix[-2 * hex[4 + c]][1]</a>
<a name="ln747">                           + 0.12890625f * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);</a>
<a name="ln748">          for(int c = 0; c &lt; 4; c++)</a>
<a name="ln749">            rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1]</a>
<a name="ln750">                = CLAMPS(color[c], gmin[row - top][col - left], gmax[row - top][col - left]);</a>
<a name="ln751">        }</a>
<a name="ln752"> </a>
<a name="ln753">      for(int pass = 0; pass &lt; passes; pass++)</a>
<a name="ln754">      {</a>
<a name="ln755">        if(pass == 1)</a>
<a name="ln756">        {</a>
<a name="ln757">          // if on second pass, copy rgb[0] to [3] into rgb[4] to [7],</a>
<a name="ln758">          // and process that second set of buffers</a>
<a name="ln759">          memcpy(rgb + 4, rgb, (size_t)4 * sizeof(*rgb));</a>
<a name="ln760">          rgb += 4;</a>
<a name="ln761">        }</a>
<a name="ln762"> </a>
<a name="ln763">        /* Recalculate green from interpolated values of closer pixels: */</a>
<a name="ln764">        if(pass)</a>
<a name="ln765">        {</a>
<a name="ln766">          const int pad_g_recalc = 6;</a>
<a name="ln767">          for(int row = top + pad_g_recalc; row &lt; mrow - pad_g_recalc; row++)</a>
<a name="ln768">            for(int col = left + pad_g_recalc; col &lt; mcol - pad_g_recalc; col++)</a>
<a name="ln769">            {</a>
<a name="ln770">              int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln771">              if(f == 1) continue;</a>
<a name="ln772">              const short *const hex = hexmap(row,col,allhex);</a>
<a name="ln773">              for(int d = 3; d &lt; 6; d++)</a>
<a name="ln774">              {</a>
<a name="ln775">                float(*rfx)[3] = &amp;rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];</a>
<a name="ln776">                float val = rfx[-2 * hex[d]][1] + 2 * rfx[hex[d]][1] - rfx[-2 * hex[d]][f]</a>
<a name="ln777">                            - 2 * rfx[hex[d]][f] + 3 * rfx[0][f];</a>
<a name="ln778">                rfx[0][1] = CLAMPS(val / 3.0f, gmin[row - top][col - left], gmax[row - top][col - left]);</a>
<a name="ln779">              }</a>
<a name="ln780">            }</a>
<a name="ln781">        }</a>
<a name="ln782"> </a>
<a name="ln783">        /* Interpolate red and blue values for solitary green pixels:   */</a>
<a name="ln784">        const int pad_rb_g = (passes == 1) ? 6 : 5;</a>
<a name="ln785">        for(int row = (top - sgrow + pad_rb_g + 2) / 3 * 3 + sgrow; row &lt; mrow - pad_rb_g; row += 3)</a>
<a name="ln786">          for(int col = (left - sgcol + pad_rb_g + 2) / 3 * 3 + sgcol; col &lt; mcol - pad_rb_g; col += 3)</a>
<a name="ln787">          {</a>
<a name="ln788">            float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln789">            int h = FCxtrans(row, col + 1, roi_in, xtrans);</a>
<a name="ln790">            float diff[6] = { 0.0f };</a>
<a name="ln791">            // interplated color: first index is red/blue, second is</a>
<a name="ln792">            // pass, is double actual result</a>
<a name="ln793">            float color[2][6];</a>
<a name="ln794">            // Six passes, alternating hori/vert interp (i),</a>
<a name="ln795">            // starting with R or B (h) depending on which is closest.</a>
<a name="ln796">            // Passes 0,1 to rgb[0], rgb[1] of hori/vert interp. Pass</a>
<a name="ln797">            // 3,5 to rgb[2], rgb[3] of best of interp hori/vert</a>
<a name="ln798">            // results. Each pass which outputs moves on to the next</a>
<a name="ln799">            // rgb[] for input of interp greens.</a>
<a name="ln800">            for(int i = 1, d = 0; d &lt; 6; d++, i ^= TS ^ 1, h ^= 2)</a>
<a name="ln801">            {</a>
<a name="ln802">              // look 1 and 2 pixels distance from solitary green to</a>
<a name="ln803">              // red then blue or blue then red</a>
<a name="ln804">              for(int c = 0; c &lt; 2; c++, h ^= 2)</a>
<a name="ln805">              {</a>
<a name="ln806">                // rate of change in greens between current pixel and</a>
<a name="ln807">                // interpolated pixels 1 or 2 distant: a quick</a>
<a name="ln808">                // derivative which will be divided by two later to be</a>
<a name="ln809">                // rate of luminance change for red/blue between known</a>
<a name="ln810">                // red/blue neighbors and the current unknown pixel</a>
<a name="ln811">                float g = 2 * rfx[0][1] - rfx[i &lt;&lt; c][1] - rfx[-(i &lt;&lt; c)][1];</a>
<a name="ln812">                // color is halved before being stored in rgb, hence</a>
<a name="ln813">                // this becomes green rate of change plus the average</a>
<a name="ln814">                // of the near red or blue pixels on current axis</a>
<a name="ln815">                color[h != 0][d] = g + rfx[i &lt;&lt; c][h] + rfx[-(i &lt;&lt; c)][h];</a>
<a name="ln816">                // Note that diff will become the slope for both red</a>
<a name="ln817">                // and blue differentials in the current direction.</a>
<a name="ln818">                // For 2nd and 3rd hori+vert passes, create a sum of</a>
<a name="ln819">                // steepness for both cardinal directions.</a>
<a name="ln820">                if(d &gt; 1)</a>
<a name="ln821">                  diff[d] += SQR(rfx[i &lt;&lt; c][1] - rfx[-(i &lt;&lt; c)][1] - rfx[i &lt;&lt; c][h] + rfx[-(i &lt;&lt; c)][h])</a>
<a name="ln822">                             + SQR(g);</a>
<a name="ln823">              }</a>
<a name="ln824">              if((d &lt; 2) || (d &amp; 1))</a>
<a name="ln825">              { // output for passes 0, 1, 3, 5</a>
<a name="ln826">                // for 0, 1 just use hori/vert, for 3, 5 use best of x/y dir</a>
<a name="ln827">                const int d_out = d - ((d &gt; 1) &amp;&amp; (diff[d-1] &lt; diff[d]));</a>
<a name="ln828">                rfx[0][0] = color[0][d_out] / 2.f;</a>
<a name="ln829">                rfx[0][2] = color[1][d_out] / 2.f;</a>
<a name="ln830">                rfx += TS * TS;</a>
<a name="ln831">              }</a>
<a name="ln832">            }</a>
<a name="ln833">          }</a>
<a name="ln834"> </a>
<a name="ln835">        /* Interpolate red for blue pixels and vice versa:              */</a>
<a name="ln836">        const int pad_rb_br = (passes == 1) ? 6 : 5;</a>
<a name="ln837">        for(int row = top + pad_rb_br; row &lt; mrow - pad_rb_br; row++)</a>
<a name="ln838">          for(int col = left + pad_rb_br; col &lt; mcol - pad_rb_br; col++)</a>
<a name="ln839">          {</a>
<a name="ln840">            int f = 2 - FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln841">            if(f == 1) continue;</a>
<a name="ln842">            float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln843">            int c = (row - sgrow) % 3 ? TS : 1;</a>
<a name="ln844">            int h = 3 * (c ^ TS ^ 1);</a>
<a name="ln845">            for(int d = 0; d &lt; 4; d++, rfx += TS * TS)</a>
<a name="ln846">            {</a>
<a name="ln847">              int i = d &gt; 1 || ((d ^ c) &amp; 1) ||</a>
<a name="ln848">                ((fabsf(rfx[0][1]-rfx[c][1]) + fabsf(rfx[0][1]-rfx[-c][1])) &lt;</a>
<a name="ln849">                 2.f*(fabsf(rfx[0][1]-rfx[h][1]) + fabsf(rfx[0][1]-rfx[-h][1]))) ? c:h;</a>
<a name="ln850">              rfx[0][f] = (rfx[i][f] + rfx[-i][f] + 2.f * rfx[0][1] - rfx[i][1] - rfx[-i][1]) / 2.f;</a>
<a name="ln851">            }</a>
<a name="ln852">          }</a>
<a name="ln853"> </a>
<a name="ln854">        /* Fill in red and blue for 2x2 blocks of green:                */</a>
<a name="ln855">        const int pad_g22 = (passes == 1) ? 8 : 4;</a>
<a name="ln856">        for(int row = top + pad_g22; row &lt; mrow - pad_g22; row++)</a>
<a name="ln857">          if((row - sgrow) % 3)</a>
<a name="ln858">            for(int col = left + pad_g22; col &lt; mcol - pad_g22; col++)</a>
<a name="ln859">              if((col - sgcol) % 3)</a>
<a name="ln860">              {</a>
<a name="ln861">                float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln862">                const short *const hex = hexmap(row,col,allhex);</a>
<a name="ln863">                for(int d = 0; d &lt; ndir; d += 2, rfx += TS * TS)</a>
<a name="ln864">                  if(hex[d] + hex[d + 1])</a>
<a name="ln865">                  {</a>
<a name="ln866">                    float g = 3.f * rfx[0][1] - 2.f * rfx[hex[d]][1] - rfx[hex[d + 1]][1];</a>
<a name="ln867">                    for(int c = 0; c &lt; 4; c += 2)</a>
<a name="ln868">                      rfx[0][c] = (g + 2.f * rfx[hex[d]][c] + rfx[hex[d + 1]][c]) / 3.f;</a>
<a name="ln869">                  }</a>
<a name="ln870">                  else</a>
<a name="ln871">                  {</a>
<a name="ln872">                    float g = 2.f * rfx[0][1] - rfx[hex[d]][1] - rfx[hex[d + 1]][1];</a>
<a name="ln873">                    for(int c = 0; c &lt; 4; c += 2)</a>
<a name="ln874">                      rfx[0][c] = (g + rfx[hex[d]][c] + rfx[hex[d + 1]][c]) / 2.f;</a>
<a name="ln875">                  }</a>
<a name="ln876">              }</a>
<a name="ln877">      } // end of multipass loop</a>
<a name="ln878"> </a>
<a name="ln879">      // jump back to the first set of rgb buffers (this is a nop</a>
<a name="ln880">      // unless on the second pass)</a>
<a name="ln881">      rgb = (float(*)[TS][TS][3])buffer;</a>
<a name="ln882">      // from here on out, mainly are working within the current tile</a>
<a name="ln883">      // rather than in reference to the image, so don't offset</a>
<a name="ln884">      // mrow/mcol by top/left of tile</a>
<a name="ln885">      mrow -= top;</a>
<a name="ln886">      mcol -= left;</a>
<a name="ln887"> </a>
<a name="ln888">      /* Convert to perceptual colorspace and differentiate in all directions:  */</a>
<a name="ln889">      // Original dcraw algorithm uses CIELab as perceptual space</a>
<a name="ln890">      // (presumably coming from original AHD) and converts taking</a>
<a name="ln891">      // camera matrix into account. Now use YPbPr which requires much</a>
<a name="ln892">      // less code and is nearly indistinguishable. It assumes the</a>
<a name="ln893">      // camera RGB is roughly linear.</a>
<a name="ln894">      for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln895">      {</a>
<a name="ln896">        const int pad_yuv = (passes == 1) ? 8 : 13;</a>
<a name="ln897">        for(int row = pad_yuv; row &lt; mrow - pad_yuv; row++)</a>
<a name="ln898">          for(int col = pad_yuv; col &lt; mcol - pad_yuv; col++)</a>
<a name="ln899">          {</a>
<a name="ln900">            float *rx = rgb[d][row][col];</a>
<a name="ln901">            // use ITU-R BT.2020 YPbPr, which is great, but could use</a>
<a name="ln902">            // a better/simpler choice? note that imageop.h provides</a>
<a name="ln903">            // dt_iop_RGB_to_YCbCr which uses Rec. 601 conversion,</a>
<a name="ln904">            // which appears less good with specular highlights</a>
<a name="ln905">            float y = 0.2627f * rx[0] + 0.6780f * rx[1] + 0.0593f * rx[2];</a>
<a name="ln906">            yuv[0][row][col] = y;</a>
<a name="ln907">            yuv[1][row][col] = (rx[2] - y) * 0.56433f;</a>
<a name="ln908">            yuv[2][row][col] = (rx[0] - y) * 0.67815f;</a>
<a name="ln909">          }</a>
<a name="ln910">        // Note that f can offset by a column (-1 or +1) and by a row</a>
<a name="ln911">        // (-TS or TS). The row-wise offsets cause the undefined</a>
<a name="ln912">        // behavior sanitizer to warn of an out of bounds index, but</a>
<a name="ln913">        // as yfx is multi-dimensional and there is sufficient</a>
<a name="ln914">        // padding, that is not actually so.</a>
<a name="ln915">        const int f = dir[d &amp; 3];</a>
<a name="ln916">        const int pad_drv = (passes == 1) ? 9 : 14;</a>
<a name="ln917">        for(int row = pad_drv; row &lt; mrow - pad_drv; row++)</a>
<a name="ln918">          for(int col = pad_drv; col &lt; mcol - pad_drv; col++)</a>
<a name="ln919">          {</a>
<a name="ln920">            float(*yfx)[TS][TS] = (float(*)[TS][TS]) &amp; yuv[0][row][col];</a>
<a name="ln921">            drv[d][row][col] = SQR(2 * yfx[0][0][0] - yfx[0][0][f] - yfx[0][0][-f])</a>
<a name="ln922">                               + SQR(2 * yfx[1][0][0] - yfx[1][0][f] - yfx[1][0][-f])</a>
<a name="ln923">                               + SQR(2 * yfx[2][0][0] - yfx[2][0][f] - yfx[2][0][-f]);</a>
<a name="ln924">          }</a>
<a name="ln925">      }</a>
<a name="ln926"> </a>
<a name="ln927">      /* Build homogeneity maps from the derivatives:                   */</a>
<a name="ln928">      memset(homo, 0, (size_t)ndir * TS * TS * sizeof(uint8_t));</a>
<a name="ln929">      const int pad_homo = (passes == 1) ? 10 : 15;</a>
<a name="ln930">      for(int row = pad_homo; row &lt; mrow - pad_homo; row++)</a>
<a name="ln931">        for(int col = pad_homo; col &lt; mcol - pad_homo; col++)</a>
<a name="ln932">        {</a>
<a name="ln933">          float tr = FLT_MAX;</a>
<a name="ln934">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln935">            if(tr &gt; drv[d][row][col]) tr = drv[d][row][col];</a>
<a name="ln936">          tr *= 8;</a>
<a name="ln937">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln938">            for(int v = -1; v &lt;= 1; v++)</a>
<a name="ln939">              for(int h = -1; h &lt;= 1; h++) homo[d][row][col] += ((drv[d][row + v][col + h] &lt;= tr) ? 1 : 0);</a>
<a name="ln940">        }</a>
<a name="ln941"> </a>
<a name="ln942">      /* Build 5x5 sum of homogeneity maps for each pixel &amp; direction */</a>
<a name="ln943">      for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln944">        for(int row = pad_tile; row &lt; mrow - pad_tile; row++)</a>
<a name="ln945">        {</a>
<a name="ln946">          // start before first column where homo[d][row][col+2] != 0,</a>
<a name="ln947">          // so can know v5sum and homosum[d][row][col] will be 0</a>
<a name="ln948">          int col = pad_tile-5;</a>
<a name="ln949">          uint8_t v5sum[5] = { 0 };</a>
<a name="ln950">          homosum[d][row][col] = 0;</a>
<a name="ln951">          // calculate by rolling through column sums</a>
<a name="ln952">          for(col++; col &lt; mcol - pad_tile; col++)</a>
<a name="ln953">          {</a>
<a name="ln954">            uint8_t colsum = 0;</a>
<a name="ln955">            for(int v = -2; v &lt;= 2; v++) colsum += homo[d][row + v][col + 2];</a>
<a name="ln956">            homosum[d][row][col] = homosum[d][row][col - 1] - v5sum[col % 5] + colsum;</a>
<a name="ln957">            v5sum[col % 5] = colsum;</a>
<a name="ln958">          }</a>
<a name="ln959">        }</a>
<a name="ln960"> </a>
<a name="ln961">      /* Average the most homogenous pixels for the final result:       */</a>
<a name="ln962">      for(int row = pad_tile; row &lt; mrow - pad_tile; row++)</a>
<a name="ln963">        for(int col = pad_tile; col &lt; mcol - pad_tile; col++)</a>
<a name="ln964">        {</a>
<a name="ln965">          uint8_t hm[8] = { 0 };</a>
<a name="ln966">          uint8_t maxval = 0;</a>
<a name="ln967">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln968">          {</a>
<a name="ln969">            hm[d] = homosum[d][row][col];</a>
<a name="ln970">            maxval = (maxval &lt; hm[d] ? hm[d] : maxval);</a>
<a name="ln971">          }</a>
<a name="ln972">          maxval -= maxval &gt;&gt; 3;</a>
<a name="ln973">          for(int d = 0; d &lt; ndir - 4; d++)</a>
<a name="ln974">            if(hm[d] &lt; hm[d + 4])</a>
<a name="ln975">              hm[d] = 0;</a>
<a name="ln976">            else if(hm[d] &gt; hm[d + 4])</a>
<a name="ln977">              hm[d + 4] = 0;</a>
<a name="ln978">          float avg[4] = { 0.0f };</a>
<a name="ln979">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln980">            if(hm[d] &gt;= maxval)</a>
<a name="ln981">            {</a>
<a name="ln982">              for(int c = 0; c &lt; 3; c++) avg[c] += rgb[d][row][col][c];</a>
<a name="ln983">              avg[3]++;</a>
<a name="ln984">            }</a>
<a name="ln985">          for(int c = 0; c &lt; 3; c++)</a>
<a name="ln986">            out[4 * (width * (row + top) + col + left) + c] =</a>
<a name="ln987">              avg[c]/avg[3];</a>
<a name="ln988">        }</a>
<a name="ln989">    }</a>
<a name="ln990">  }</a>
<a name="ln991">  dt_free_align(all_buffers);</a>
<a name="ln992">}</a>
<a name="ln993"> </a>
<a name="ln994">#undef TS</a>
<a name="ln995"> </a>
<a name="ln996">#define TS 122</a>
<a name="ln997">static void xtrans_fdc_interpolate(struct dt_iop_module_t *self, float *out, const float *const in,</a>
<a name="ln998">                                   const dt_iop_roi_t *const roi_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln999">                                   const uint8_t (*const xtrans)[6])</a>
<a name="ln1000">{</a>
<a name="ln1001"> </a>
<a name="ln1002">  static const short orth[12] = { 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1 },</a>
<a name="ln1003">                     patt[2][16] = { { 0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0 },</a>
<a name="ln1004">                                     { 0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1 } },</a>
<a name="ln1005">                     dir[4] = { 1, TS, TS + 1, TS - 1 };</a>
<a name="ln1006"> </a>
<a name="ln1007">  static const float directionality[8] = { 1.0f, 0.0f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f };</a>
<a name="ln1008"> </a>
<a name="ln1009">  short allhex[3][3][8];</a>
<a name="ln1010">  // sgrow/sgcol is the offset in the sensor matrix of the solitary</a>
<a name="ln1011">  // green pixels (initialized here only to avoid compiler warning)</a>
<a name="ln1012">  unsigned short sgrow = 0, sgcol = 0;</a>
<a name="ln1013"> </a>
<a name="ln1014">  const int width = roi_out-&gt;width;</a>
<a name="ln1015">  const int height = roi_out-&gt;height;</a>
<a name="ln1016">  static const int ndir = 4;</a>
<a name="ln1017"> </a>
<a name="ln1018">  static const float complex Minv[3][8] = {</a>
<a name="ln1019">    { 1.000000e+00f, 2.500000e-01f - 4.330127e-01f * _Complex_I, -2.500000e-01f - 4.330127e-01f * _Complex_I,</a>
<a name="ln1020">      -1.000000e+00f, 7.500000e-01f - 1.299038e+00f * _Complex_I, -2.500000e-01f + 4.330127e-01f * _Complex_I,</a>
<a name="ln1021">      7.500000e-01f + 1.299038e+00f * _Complex_I, 2.500000e-01f + 4.330127e-01f * _Complex_I },</a>
<a name="ln1022">    { 1.000000e+00f, -2.000000e-01f + 3.464102e-01f * _Complex_I, 2.000000e-01f + 3.464102e-01f * _Complex_I,</a>
<a name="ln1023">      8.000000e-01f, 0.0f, 2.000000e-01f - 3.464102e-01f * _Complex_I, 0.0f,</a>
<a name="ln1024">      -2.000000e-01f - 3.464102e-01f * _Complex_I },</a>
<a name="ln1025">    { 1.000000e+00f, 2.500000e-01f - 4.330127e-01f * _Complex_I, -2.500000e-01f - 4.330127e-01f * _Complex_I,</a>
<a name="ln1026">      -1.000000e+00f, -7.500000e-01f + 1.299038e+00f * _Complex_I, -2.500000e-01f + 4.330127e-01f * _Complex_I,</a>
<a name="ln1027">      -7.500000e-01f - 1.299038e+00f * _Complex_I, 2.500000e-01f + 4.330127e-01f * _Complex_I },</a>
<a name="ln1028">  };</a>
<a name="ln1029"> </a>
<a name="ln1030">  static const float complex modarr[6][6][8] = {</a>
<a name="ln1031">    { { 1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1032">        1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1033">        1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1034">        1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1035">      { -1.000000e+00f - 1.224647e-16f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1036">        -1.000000e+00f - 1.224647e-16f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1037">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1038">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1039">      { 1.000000e+00f + 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1040">        1.000000e+00f + 2.449294e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1041">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1042">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1043">      { -1.000000e+00f - 3.673940e-16f * _Complex_I, -1.000000e+00f + 1.224647e-16f * _Complex_I,</a>
<a name="ln1044">        -1.000000e+00f - 3.673940e-16f * _Complex_I, -1.000000e+00f - 1.224647e-16f * _Complex_I,</a>
<a name="ln1045">        1.000000e+00f - 2.449294e-16f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1046">        1.000000e+00f - 2.449294e-16f * _Complex_I, 1.000000e+00f + 2.449294e-16f * _Complex_I },</a>
<a name="ln1047">      { 1.000000e+00f + 4.898587e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1048">        1.000000e+00f + 4.898587e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1049">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1050">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1051">      { -1.000000e+00f - 6.123234e-16f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1052">        -1.000000e+00f - 6.123234e-16f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1053">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1054">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I } },</a>
<a name="ln1055">    { { 5.000000e-01f + 8.660254e-01f * _Complex_I, -1.000000e+00f + 1.224647e-16f * _Complex_I,</a>
<a name="ln1056">        5.000000e-01f - 8.660254e-01f * _Complex_I, -1.000000e+00f + 1.224647e-16f * _Complex_I,</a>
<a name="ln1057">        1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1058">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1059">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1060">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1061">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1062">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1063">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1064">        5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1065">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1066">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1067">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1068">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1069">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1070">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1071">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1072">        5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1073">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1074">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 2.449294e-16f * _Complex_I },</a>
<a name="ln1075">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1076">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1077">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1078">        1.000000e+00f - 2.266216e-15f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I } },</a>
<a name="ln1079">    { { -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1080">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1081">        1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1082">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1083">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1084">        5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1085">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1086">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1087">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1088">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1089">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1090">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1091">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, -1.000000e+00f + 3.673940e-16f * _Complex_I,</a>
<a name="ln1092">        5.000000e-01f + 8.660254e-01f * _Complex_I, -1.000000e+00f + 1.224647e-16f * _Complex_I,</a>
<a name="ln1093">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1094">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1095">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1096">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1097">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1098">        1.000000e+00f - 4.898587e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1099">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1100">        5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1101">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1102">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 1.133108e-15f * _Complex_I } },</a>
<a name="ln1103">    { { -1.000000e+00f + 1.224647e-16f * _Complex_I, -1.000000e+00f + 3.673940e-16f * _Complex_I,</a>
<a name="ln1104">        -1.000000e+00f - 1.224647e-16f * _Complex_I, -1.000000e+00f + 3.673940e-16f * _Complex_I,</a>
<a name="ln1105">        1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1106">        1.000000e+00f - 2.449294e-16f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I },</a>
<a name="ln1107">      { 1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1108">        1.000000e+00f + 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1109">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1110">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1111">      { -1.000000e+00f - 1.224647e-16f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1112">        -1.000000e+00f - 3.673940e-16f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1113">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1114">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1115">      { 1.000000e+00f + 2.449294e-16f * _Complex_I, 1.000000e+00f - 4.898587e-16f * _Complex_I,</a>
<a name="ln1116">        1.000000e+00f + 4.898587e-16f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1117">        1.000000e+00f - 2.449294e-16f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1118">        1.000000e+00f - 4.898587e-16f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1119">      { -1.000000e+00f - 3.673940e-16f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1120">        -1.000000e+00f - 6.123234e-16f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1121">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1122">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1123">      { 1.000000e+00f + 4.898587e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1124">        1.000000e+00f + 7.347881e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1125">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1126">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I } },</a>
<a name="ln1127">    { { -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 4.898587e-16f * _Complex_I,</a>
<a name="ln1128">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 4.898587e-16f * _Complex_I,</a>
<a name="ln1129">        1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1130">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1131">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1132">        5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1133">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1134">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I },</a>
<a name="ln1135">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1136">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1137">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1138">        1.000000e+00f - 4.898587e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1139">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, -1.000000e+00f + 6.123234e-16f * _Complex_I,</a>
<a name="ln1140">        5.000000e-01f - 8.660254e-01f * _Complex_I, -1.000000e+00f + 3.673940e-16f * _Complex_I,</a>
<a name="ln1141">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1142">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1143">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1144">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1145">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1146">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1147">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1148">        5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1149">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1150">        1.000000e+00f - 7.347881e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I } },</a>
<a name="ln1151">    { { 5.000000e-01f - 8.660254e-01f * _Complex_I, -1.000000e+00f + 6.123234e-16f * _Complex_I,</a>
<a name="ln1152">        5.000000e-01f + 8.660254e-01f * _Complex_I, -1.000000e+00f + 6.123234e-16f * _Complex_I,</a>
<a name="ln1153">        1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1154">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1155">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1156">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1157">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1158">        1.000000e+00f - 2.266216e-15f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1159">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1160">        5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1161">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1162">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 1.133108e-15f * _Complex_I },</a>
<a name="ln1163">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 7.347881e-16f * _Complex_I,</a>
<a name="ln1164">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 4.898587e-16f * _Complex_I,</a>
<a name="ln1165">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1166">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1167">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1168">        5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1169">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1170">        1.000000e+00f - 7.347881e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1171">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1172">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1173">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1174">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I } },</a>
<a name="ln1175">  };</a>
<a name="ln1176"> </a>
<a name="ln1177">  static const float complex harr[4][13][13]</a>
<a name="ln1178">      = { { { 1.326343e-03f - 1.299441e-18f * _Complex_I, 7.091837e-04f - 1.228342e-03f * _Complex_I,</a>
<a name="ln1179">              -6.278557e-04f - 1.087478e-03f * _Complex_I, -1.157216e-03f + 9.920263e-19f * _Complex_I,</a>
<a name="ln1180">              -4.887166e-04f + 8.464820e-04f * _Complex_I, 5.758687e-04f + 9.974338e-04f * _Complex_I,</a>
<a name="ln1181">              1.225183e-03f - 9.002496e-19f * _Complex_I, 5.758687e-04f - 9.974338e-04f * _Complex_I,</a>
<a name="ln1182">              -4.887166e-04f - 8.464820e-04f * _Complex_I, -1.157216e-03f + 7.085902e-19f * _Complex_I,</a>
<a name="ln1183">              -6.278557e-04f + 1.087478e-03f * _Complex_I, 7.091837e-04f + 1.228342e-03f * _Complex_I,</a>
<a name="ln1184">              1.326343e-03f - 6.497206e-19f * _Complex_I },</a>
<a name="ln1185">            { -1.980815e-03f + 1.698059e-18f * _Complex_I, -1.070384e-03f + 1.853959e-03f * _Complex_I,</a>
<a name="ln1186">              7.924697e-04f + 1.372598e-03f * _Complex_I, 1.876584e-03f - 1.378892e-18f * _Complex_I,</a>
<a name="ln1187">              1.225866e-03f - 2.123262e-03f * _Complex_I, -1.569320e-03f - 2.718142e-03f * _Complex_I,</a>
<a name="ln1188">              -3.273971e-03f + 2.004729e-18f * _Complex_I, -1.569320e-03f + 2.718142e-03f * _Complex_I,</a>
<a name="ln1189">              1.225866e-03f + 2.123262e-03f * _Complex_I, 1.876584e-03f - 9.192611e-19f * _Complex_I,</a>
<a name="ln1190">              7.924697e-04f - 1.372598e-03f * _Complex_I, -1.070384e-03f - 1.853959e-03f * _Complex_I,</a>
<a name="ln1191">              -1.980815e-03f + 7.277398e-19f * _Complex_I },</a>
<a name="ln1192">            { 1.457023e-03f - 1.070603e-18f * _Complex_I, 8.487143e-04f - 1.470016e-03f * _Complex_I,</a>
<a name="ln1193">              -6.873776e-04f - 1.190573e-03f * _Complex_I, -2.668335e-03f + 1.633884e-18f * _Complex_I,</a>
<a name="ln1194">              -2.459813e-03f + 4.260521e-03f * _Complex_I, 3.238772e-03f + 5.609717e-03f * _Complex_I,</a>
<a name="ln1195">              7.074895e-03f - 3.465699e-18f * _Complex_I, 3.238772e-03f - 5.609717e-03f * _Complex_I,</a>
<a name="ln1196">              -2.459813e-03f - 4.260521e-03f * _Complex_I, -2.668335e-03f + 9.803302e-19f * _Complex_I,</a>
<a name="ln1197">              -6.873776e-04f + 1.190573e-03f * _Complex_I, 8.487143e-04f + 1.470016e-03f * _Complex_I,</a>
<a name="ln1198">              1.457023e-03f - 3.568678e-19f * _Complex_I },</a>
<a name="ln1199">            { -1.017660e-03f + 6.231370e-19f * _Complex_I, -5.415171e-04f + 9.379351e-04f * _Complex_I,</a>
<a name="ln1200">              7.255109e-04f + 1.256622e-03f * _Complex_I, 3.699792e-03f - 1.812375e-18f * _Complex_I,</a>
<a name="ln1201">              4.090356e-03f - 7.084704e-03f * _Complex_I, -6.006283e-03f - 1.040319e-02f * _Complex_I,</a>
<a name="ln1202">              -1.391431e-02f + 5.112034e-18f * _Complex_I, -6.006283e-03f + 1.040319e-02f * _Complex_I,</a>
<a name="ln1203">              4.090356e-03f + 7.084704e-03f * _Complex_I, 3.699792e-03f - 9.061876e-19f * _Complex_I,</a>
<a name="ln1204">              7.255109e-04f - 1.256622e-03f * _Complex_I, -5.415171e-04f - 9.379351e-04f * _Complex_I,</a>
<a name="ln1205">              -1.017660e-03f + 1.246274e-19f * _Complex_I },</a>
<a name="ln1206">            { 9.198983e-04f - 4.506202e-19f * _Complex_I, 6.815900e-04f - 1.180548e-03f * _Complex_I,</a>
<a name="ln1207">              -1.287335e-03f - 2.229729e-03f * _Complex_I, -5.023856e-03f + 1.845735e-18f * _Complex_I,</a>
<a name="ln1208">              -5.499048e-03f + 9.524630e-03f * _Complex_I, 9.797672e-03f + 1.697006e-02f * _Complex_I,</a>
<a name="ln1209">              2.504795e-02f - 6.134977e-18f * _Complex_I, 9.797672e-03f - 1.697006e-02f * _Complex_I,</a>
<a name="ln1210">              -5.499048e-03f - 9.524630e-03f * _Complex_I, -5.023856e-03f + 6.152449e-19f * _Complex_I,</a>
<a name="ln1211">              -1.287335e-03f + 2.229729e-03f * _Complex_I, 6.815900e-04f + 1.180548e-03f * _Complex_I,</a>
<a name="ln1212">              9.198983e-04f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1213">            { -7.972663e-04f + 2.929109e-19f * _Complex_I, -1.145605e-03f + 1.984247e-03f * _Complex_I,</a>
<a name="ln1214">              1.983334e-03f + 3.435235e-03f * _Complex_I, 6.730096e-03f - 1.648398e-18f * _Complex_I,</a>
<a name="ln1215">              6.782033e-03f - 1.174683e-02f * _Complex_I, -1.392077e-02f - 2.411147e-02f * _Complex_I,</a>
<a name="ln1216">              -3.906939e-02f + 4.784620e-18f * _Complex_I, -1.392077e-02f + 2.411147e-02f * _Complex_I,</a>
<a name="ln1217">              6.782033e-03f + 1.174683e-02f * _Complex_I, 6.730096e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1218">              1.983334e-03f - 3.435235e-03f * _Complex_I, -1.145605e-03f - 1.984247e-03f * _Complex_I,</a>
<a name="ln1219">              -7.972663e-04f - 9.763696e-20f * _Complex_I },</a>
<a name="ln1220">            { 8.625458e-04f - 2.112628e-19f * _Complex_I, 1.431113e-03f - 2.478760e-03f * _Complex_I,</a>
<a name="ln1221">              -2.310309e-03f - 4.001572e-03f * _Complex_I, -7.706486e-03f + 9.437723e-19f * _Complex_I,</a>
<a name="ln1222">              -7.220186e-03f + 1.250573e-02f * _Complex_I, 1.587118e-02f + 2.748969e-02f * _Complex_I,</a>
<a name="ln1223">              4.765675e-02f + 0.000000e+00f * _Complex_I, 1.587118e-02f - 2.748969e-02f * _Complex_I,</a>
<a name="ln1224">              -7.220186e-03f - 1.250573e-02f * _Complex_I, -7.706486e-03f - 9.437723e-19f * _Complex_I,</a>
<a name="ln1225">              -2.310309e-03f + 4.001572e-03f * _Complex_I, 1.431113e-03f + 2.478760e-03f * _Complex_I,</a>
<a name="ln1226">              8.625458e-04f + 2.112628e-19f * _Complex_I },</a>
<a name="ln1227">            { -7.972663e-04f + 9.763696e-20f * _Complex_I, -1.145605e-03f + 1.984247e-03f * _Complex_I,</a>
<a name="ln1228">              1.983334e-03f + 3.435235e-03f * _Complex_I, 6.730096e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1229">              6.782033e-03f - 1.174683e-02f * _Complex_I, -1.392077e-02f - 2.411147e-02f * _Complex_I,</a>
<a name="ln1230">              -3.906939e-02f - 4.784620e-18f * _Complex_I, -1.392077e-02f + 2.411147e-02f * _Complex_I,</a>
<a name="ln1231">              6.782033e-03f + 1.174683e-02f * _Complex_I, 6.730096e-03f + 1.648398e-18f * _Complex_I,</a>
<a name="ln1232">              1.983334e-03f - 3.435235e-03f * _Complex_I, -1.145605e-03f - 1.984247e-03f * _Complex_I,</a>
<a name="ln1233">              -7.972663e-04f - 2.929109e-19f * _Complex_I },</a>
<a name="ln1234">            { 9.198983e-04f + 0.000000e+00f * _Complex_I, 6.815900e-04f - 1.180548e-03f * _Complex_I,</a>
<a name="ln1235">              -1.287335e-03f - 2.229729e-03f * _Complex_I, -5.023856e-03f - 6.152449e-19f * _Complex_I,</a>
<a name="ln1236">              -5.499048e-03f + 9.524630e-03f * _Complex_I, 9.797672e-03f + 1.697006e-02f * _Complex_I,</a>
<a name="ln1237">              2.504795e-02f + 6.134977e-18f * _Complex_I, 9.797672e-03f - 1.697006e-02f * _Complex_I,</a>
<a name="ln1238">              -5.499048e-03f - 9.524630e-03f * _Complex_I, -5.023856e-03f - 1.845735e-18f * _Complex_I,</a>
<a name="ln1239">              -1.287335e-03f + 2.229729e-03f * _Complex_I, 6.815900e-04f + 1.180548e-03f * _Complex_I,</a>
<a name="ln1240">              9.198983e-04f + 4.506202e-19f * _Complex_I },</a>
<a name="ln1241">            { -1.017660e-03f - 1.246274e-19f * _Complex_I, -5.415171e-04f + 9.379351e-04f * _Complex_I,</a>
<a name="ln1242">              7.255109e-04f + 1.256622e-03f * _Complex_I, 3.699792e-03f + 9.061876e-19f * _Complex_I,</a>
<a name="ln1243">              4.090356e-03f - 7.084704e-03f * _Complex_I, -6.006283e-03f - 1.040319e-02f * _Complex_I,</a>
<a name="ln1244">              -1.391431e-02f - 5.112034e-18f * _Complex_I, -6.006283e-03f + 1.040319e-02f * _Complex_I,</a>
<a name="ln1245">              4.090356e-03f + 7.084704e-03f * _Complex_I, 3.699792e-03f + 1.812375e-18f * _Complex_I,</a>
<a name="ln1246">              7.255109e-04f - 1.256622e-03f * _Complex_I, -5.415171e-04f - 9.379351e-04f * _Complex_I,</a>
<a name="ln1247">              -1.017660e-03f - 6.231370e-19f * _Complex_I },</a>
<a name="ln1248">            { 1.457023e-03f + 3.568678e-19f * _Complex_I, 8.487143e-04f - 1.470016e-03f * _Complex_I,</a>
<a name="ln1249">              -6.873776e-04f - 1.190573e-03f * _Complex_I, -2.668335e-03f - 9.803302e-19f * _Complex_I,</a>
<a name="ln1250">              -2.459813e-03f + 4.260521e-03f * _Complex_I, 3.238772e-03f + 5.609717e-03f * _Complex_I,</a>
<a name="ln1251">              7.074895e-03f + 3.465699e-18f * _Complex_I, 3.238772e-03f - 5.609717e-03f * _Complex_I,</a>
<a name="ln1252">              -2.459813e-03f - 4.260521e-03f * _Complex_I, -2.668335e-03f - 1.633884e-18f * _Complex_I,</a>
<a name="ln1253">              -6.873776e-04f + 1.190573e-03f * _Complex_I, 8.487143e-04f + 1.470016e-03f * _Complex_I,</a>
<a name="ln1254">              1.457023e-03f + 1.070603e-18f * _Complex_I },</a>
<a name="ln1255">            { -1.980815e-03f - 7.277398e-19f * _Complex_I, -1.070384e-03f + 1.853959e-03f * _Complex_I,</a>
<a name="ln1256">              7.924697e-04f + 1.372598e-03f * _Complex_I, 1.876584e-03f + 9.192611e-19f * _Complex_I,</a>
<a name="ln1257">              1.225866e-03f - 2.123262e-03f * _Complex_I, -1.569320e-03f - 2.718142e-03f * _Complex_I,</a>
<a name="ln1258">              -3.273971e-03f - 2.004729e-18f * _Complex_I, -1.569320e-03f + 2.718142e-03f * _Complex_I,</a>
<a name="ln1259">              1.225866e-03f + 2.123262e-03f * _Complex_I, 1.876584e-03f + 1.378892e-18f * _Complex_I,</a>
<a name="ln1260">              7.924697e-04f - 1.372598e-03f * _Complex_I, -1.070384e-03f - 1.853959e-03f * _Complex_I,</a>
<a name="ln1261">              -1.980815e-03f - 1.698059e-18f * _Complex_I },</a>
<a name="ln1262">            { 1.326343e-03f + 6.497206e-19f * _Complex_I, 7.091837e-04f - 1.228342e-03f * _Complex_I,</a>
<a name="ln1263">              -6.278557e-04f - 1.087478e-03f * _Complex_I, -1.157216e-03f - 7.085902e-19f * _Complex_I,</a>
<a name="ln1264">              -4.887166e-04f + 8.464820e-04f * _Complex_I, 5.758687e-04f + 9.974338e-04f * _Complex_I,</a>
<a name="ln1265">              1.225183e-03f + 9.002496e-19f * _Complex_I, 5.758687e-04f - 9.974338e-04f * _Complex_I,</a>
<a name="ln1266">              -4.887166e-04f - 8.464820e-04f * _Complex_I, -1.157216e-03f - 9.920263e-19f * _Complex_I,</a>
<a name="ln1267">              -6.278557e-04f + 1.087478e-03f * _Complex_I, 7.091837e-04f + 1.228342e-03f * _Complex_I,</a>
<a name="ln1268">              1.326343e-03f + 1.299441e-18f * _Complex_I } },</a>
<a name="ln1269">          { { 9.129120e-04f - 8.943958e-19f * _Complex_I, -5.925973e-04f - 1.026409e-03f * _Complex_I,</a>
<a name="ln1270">              -5.989682e-04f + 1.037443e-03f * _Complex_I, 1.158755e-03f - 8.514393e-19f * _Complex_I,</a>
<a name="ln1271">              -8.992493e-04f - 1.557545e-03f * _Complex_I, -1.283187e-03f + 2.222546e-03f * _Complex_I,</a>
<a name="ln1272">              2.730635e-03f - 1.337625e-18f * _Complex_I, -1.283187e-03f - 2.222546e-03f * _Complex_I,</a>
<a name="ln1273">              -8.992493e-04f + 1.557545e-03f * _Complex_I, 1.158755e-03f - 2.838131e-19f * _Complex_I,</a>
<a name="ln1274">              -5.989682e-04f - 1.037443e-03f * _Complex_I, -5.925973e-04f + 1.026409e-03f * _Complex_I,</a>
<a name="ln1275">              9.129120e-04f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1276">            { -5.588854e-04f - 9.680179e-04f * _Complex_I, -6.474856e-04f + 1.121478e-03f * _Complex_I,</a>
<a name="ln1277">              1.536588e-03f - 1.129066e-18f * _Complex_I, -9.123802e-04f - 1.580289e-03f * _Complex_I,</a>
<a name="ln1278">              -1.541434e-03f + 2.669842e-03f * _Complex_I, 4.379825e-03f - 9.925627e-18f * _Complex_I,</a>
<a name="ln1279">              -2.394173e-03f - 4.146830e-03f * _Complex_I, -2.189912e-03f + 3.793039e-03f * _Complex_I,</a>
<a name="ln1280">              3.082869e-03f - 3.493222e-18f * _Complex_I, -9.123802e-04f - 1.580289e-03f * _Complex_I,</a>
<a name="ln1281">              -7.682939e-04f + 1.330724e-03f * _Complex_I, 1.294971e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1282">              -5.588854e-04f - 9.680179e-04f * _Complex_I },</a>
<a name="ln1283">            { -5.883876e-04f + 1.019117e-03f * _Complex_I, 1.714796e-03f - 1.260012e-18f * _Complex_I,</a>
<a name="ln1284">              -1.180365e-03f - 2.044451e-03f * _Complex_I, -1.483082e-03f + 2.568774e-03f * _Complex_I,</a>
<a name="ln1285">              4.933362e-03f - 2.416651e-18f * _Complex_I, -3.296542e-03f - 5.709779e-03f * _Complex_I,</a>
<a name="ln1286">              -3.546477e-03f + 6.142678e-03f * _Complex_I, 6.593085e-03f - 1.614840e-18f * _Complex_I,</a>
<a name="ln1287">              -2.466681e-03f - 4.272417e-03f * _Complex_I, -1.483082e-03f + 2.568774e-03f * _Complex_I,</a>
<a name="ln1288">              2.360729e-03f + 0.000000e+00f * _Complex_I, -8.573982e-04f - 1.485057e-03f * _Complex_I,</a>
<a name="ln1289">              -5.883876e-04f + 1.019117e-03f * _Complex_I },</a>
<a name="ln1290">            { 1.483526e-03f - 1.090077e-18f * _Complex_I, -1.074793e-03f - 1.861596e-03f * _Complex_I,</a>
<a name="ln1291">              -1.447448e-03f + 2.507053e-03f * _Complex_I, 3.952416e-03f - 1.936126e-18f * _Complex_I,</a>
<a name="ln1292">              -3.496688e-03f - 6.056441e-03f * _Complex_I, -4.898024e-03f + 8.483627e-03f * _Complex_I,</a>
<a name="ln1293">              1.070518e-02f - 2.622012e-18f * _Complex_I, -4.898024e-03f - 8.483627e-03f * _Complex_I,</a>
<a name="ln1294">              -3.496688e-03f + 6.056441e-03f * _Complex_I, 3.952416e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1295">              -1.447448e-03f - 2.507053e-03f * _Complex_I, -1.074793e-03f + 1.861596e-03f * _Complex_I,</a>
<a name="ln1296">              1.483526e-03f + 3.633590e-19f * _Complex_I },</a>
<a name="ln1297">            { -9.966429e-04f - 1.726236e-03f * _Complex_I, -1.478281e-03f + 2.560458e-03f * _Complex_I,</a>
<a name="ln1298">              4.306274e-03f - 2.109466e-18f * _Complex_I, -3.294955e-03f - 5.707029e-03f * _Complex_I,</a>
<a name="ln1299">              -5.436890e-03f + 9.416970e-03f * _Complex_I, 1.556418e-02f - 3.812124e-18f * _Complex_I,</a>
<a name="ln1300">              -8.842875e-03f - 1.531631e-02f * _Complex_I, -7.782088e-03f + 1.347897e-02f * _Complex_I,</a>
<a name="ln1301">              1.087378e-02f + 0.000000e+00f * _Complex_I, -3.294955e-03f - 5.707029e-03f * _Complex_I,</a>
<a name="ln1302">              -2.153137e-03f + 3.729342e-03f * _Complex_I, 2.956562e-03f + 3.350104e-18f * _Complex_I,</a>
<a name="ln1303">              -9.966429e-04f - 1.726236e-03f * _Complex_I },</a>
<a name="ln1304">            { -1.291288e-03f + 2.236576e-03f * _Complex_I, 3.942788e-03f - 8.935208e-18f * _Complex_I,</a>
<a name="ln1305">              -2.798347e-03f - 4.846880e-03f * _Complex_I, -4.448869e-03f + 7.705666e-03f * _Complex_I,</a>
<a name="ln1306">              1.522441e-02f - 3.728906e-18f * _Complex_I, -1.175443e-02f - 2.035927e-02f * _Complex_I,</a>
<a name="ln1307">              -1.417872e-02f + 2.455826e-02f * _Complex_I, 2.350886e-02f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1308">              -7.612206e-03f - 1.318473e-02f * _Complex_I, -4.448869e-03f + 7.705666e-03f * _Complex_I,</a>
<a name="ln1309">              5.596695e-03f + 1.370795e-18f * _Complex_I, -1.971394e-03f - 3.414555e-03f * _Complex_I,</a>
<a name="ln1310">              -1.291288e-03f + 2.236576e-03f * _Complex_I },</a>
<a name="ln1311">            { 2.779286e-03f - 1.361458e-18f * _Complex_I, -2.194126e-03f - 3.800338e-03f * _Complex_I,</a>
<a name="ln1312">              -3.057720e-03f + 5.296126e-03f * _Complex_I, 9.725261e-03f - 2.382002e-18f * _Complex_I,</a>
<a name="ln1313">              -8.649261e-03f - 1.498096e-02f * _Complex_I, -1.417667e-02f + 2.455472e-02f * _Complex_I,</a>
<a name="ln1314">              3.552610e-02f + 0.000000e+00f * _Complex_I, -1.417667e-02f - 2.455472e-02f * _Complex_I,</a>
<a name="ln1315">              -8.649261e-03f + 1.498096e-02f * _Complex_I, 9.725261e-03f + 2.382002e-18f * _Complex_I,</a>
<a name="ln1316">              -3.057720e-03f - 5.296126e-03f * _Complex_I, -2.194126e-03f + 3.800338e-03f * _Complex_I,</a>
<a name="ln1317">              2.779286e-03f + 1.361458e-18f * _Complex_I },</a>
<a name="ln1318">            { -1.291288e-03f - 2.236576e-03f * _Complex_I, -1.971394e-03f + 3.414555e-03f * _Complex_I,</a>
<a name="ln1319">              5.596695e-03f - 1.370795e-18f * _Complex_I, -4.448869e-03f - 7.705666e-03f * _Complex_I,</a>
<a name="ln1320">              -7.612206e-03f + 1.318473e-02f * _Complex_I, 2.350886e-02f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1321">              -1.417872e-02f - 2.455826e-02f * _Complex_I, -1.175443e-02f + 2.035927e-02f * _Complex_I,</a>
<a name="ln1322">              1.522441e-02f + 3.728906e-18f * _Complex_I, -4.448869e-03f - 7.705666e-03f * _Complex_I,</a>
<a name="ln1323">              -2.798347e-03f + 4.846880e-03f * _Complex_I, 3.942788e-03f + 8.935208e-18f * _Complex_I,</a>
<a name="ln1324">              -1.291288e-03f - 2.236576e-03f * _Complex_I },</a>
<a name="ln1325">            { -9.966429e-04f + 1.726236e-03f * _Complex_I, 2.956562e-03f - 3.350104e-18f * _Complex_I,</a>
<a name="ln1326">              -2.153137e-03f - 3.729342e-03f * _Complex_I, -3.294955e-03f + 5.707029e-03f * _Complex_I,</a>
<a name="ln1327">              1.087378e-02f + 0.000000e+00f * _Complex_I, -7.782088e-03f - 1.347897e-02f * _Complex_I,</a>
<a name="ln1328">              -8.842875e-03f + 1.531631e-02f * _Complex_I, 1.556418e-02f + 3.812124e-18f * _Complex_I,</a>
<a name="ln1329">              -5.436890e-03f - 9.416970e-03f * _Complex_I, -3.294955e-03f + 5.707029e-03f * _Complex_I,</a>
<a name="ln1330">              4.306274e-03f + 2.109466e-18f * _Complex_I, -1.478281e-03f - 2.560458e-03f * _Complex_I,</a>
<a name="ln1331">              -9.966429e-04f + 1.726236e-03f * _Complex_I },</a>
<a name="ln1332">            { 1.483526e-03f - 3.633590e-19f * _Complex_I, -1.074793e-03f - 1.861596e-03f * _Complex_I,</a>
<a name="ln1333">              -1.447448e-03f + 2.507053e-03f * _Complex_I, 3.952416e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1334">              -3.496688e-03f - 6.056441e-03f * _Complex_I, -4.898024e-03f + 8.483627e-03f * _Complex_I,</a>
<a name="ln1335">              1.070518e-02f + 2.622012e-18f * _Complex_I, -4.898024e-03f - 8.483627e-03f * _Complex_I,</a>
<a name="ln1336">              -3.496688e-03f + 6.056441e-03f * _Complex_I, 3.952416e-03f + 1.936126e-18f * _Complex_I,</a>
<a name="ln1337">              -1.447448e-03f - 2.507053e-03f * _Complex_I, -1.074793e-03f + 1.861596e-03f * _Complex_I,</a>
<a name="ln1338">              1.483526e-03f + 1.090077e-18f * _Complex_I },</a>
<a name="ln1339">            { -5.883876e-04f - 1.019117e-03f * _Complex_I, -8.573982e-04f + 1.485057e-03f * _Complex_I,</a>
<a name="ln1340">              2.360729e-03f + 0.000000e+00f * _Complex_I, -1.483082e-03f - 2.568774e-03f * _Complex_I,</a>
<a name="ln1341">              -2.466681e-03f + 4.272417e-03f * _Complex_I, 6.593085e-03f + 1.614840e-18f * _Complex_I,</a>
<a name="ln1342">              -3.546477e-03f - 6.142678e-03f * _Complex_I, -3.296542e-03f + 5.709779e-03f * _Complex_I,</a>
<a name="ln1343">              4.933362e-03f + 2.416651e-18f * _Complex_I, -1.483082e-03f - 2.568774e-03f * _Complex_I,</a>
<a name="ln1344">              -1.180365e-03f + 2.044451e-03f * _Complex_I, 1.714796e-03f + 1.260012e-18f * _Complex_I,</a>
<a name="ln1345">              -5.883876e-04f - 1.019117e-03f * _Complex_I },</a>
<a name="ln1346">            { -5.588854e-04f + 9.680179e-04f * _Complex_I, 1.294971e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1347">              -7.682939e-04f - 1.330724e-03f * _Complex_I, -9.123802e-04f + 1.580289e-03f * _Complex_I,</a>
<a name="ln1348">              3.082869e-03f + 3.493222e-18f * _Complex_I, -2.189912e-03f - 3.793039e-03f * _Complex_I,</a>
<a name="ln1349">              -2.394173e-03f + 4.146830e-03f * _Complex_I, 4.379825e-03f + 9.925627e-18f * _Complex_I,</a>
<a name="ln1350">              -1.541434e-03f - 2.669842e-03f * _Complex_I, -9.123802e-04f + 1.580289e-03f * _Complex_I,</a>
<a name="ln1351">              1.536588e-03f + 1.129066e-18f * _Complex_I, -6.474856e-04f - 1.121478e-03f * _Complex_I,</a>
<a name="ln1352">              -5.588854e-04f + 9.680179e-04f * _Complex_I },</a>
<a name="ln1353">            { 9.129120e-04f + 0.000000e+00f * _Complex_I, -5.925973e-04f - 1.026409e-03f * _Complex_I,</a>
<a name="ln1354">              -5.989682e-04f + 1.037443e-03f * _Complex_I, 1.158755e-03f + 2.838131e-19f * _Complex_I,</a>
<a name="ln1355">              -8.992493e-04f - 1.557545e-03f * _Complex_I, -1.283187e-03f + 2.222546e-03f * _Complex_I,</a>
<a name="ln1356">              2.730635e-03f + 1.337625e-18f * _Complex_I, -1.283187e-03f - 2.222546e-03f * _Complex_I,</a>
<a name="ln1357">              -8.992493e-04f + 1.557545e-03f * _Complex_I, 1.158755e-03f + 8.514393e-19f * _Complex_I,</a>
<a name="ln1358">              -5.989682e-04f - 1.037443e-03f * _Complex_I, -5.925973e-04f + 1.026409e-03f * _Complex_I,</a>
<a name="ln1359">              9.129120e-04f + 8.943958e-19f * _Complex_I } },</a>
<a name="ln1360">          { { 8.228091e-04f + 0.000000e+00f * _Complex_I, -5.365069e-04f + 9.292572e-04f * _Complex_I,</a>
<a name="ln1361">              -6.011501e-04f - 1.041223e-03f * _Complex_I, 1.249890e-03f - 3.061346e-19f * _Complex_I,</a>
<a name="ln1362">              -7.632708e-04f + 1.322024e-03f * _Complex_I, -9.846035e-04f - 1.705383e-03f * _Complex_I,</a>
<a name="ln1363">              2.080486e-03f - 1.019144e-18f * _Complex_I, -9.846035e-04f + 1.705383e-03f * _Complex_I,</a>
<a name="ln1364">              -7.632708e-04f - 1.322024e-03f * _Complex_I, 1.249890e-03f - 9.184039e-19f * _Complex_I,</a>
<a name="ln1365">              -6.011501e-04f + 1.041223e-03f * _Complex_I, -5.365069e-04f - 9.292572e-04f * _Complex_I,</a>
<a name="ln1366">              8.228091e-04f - 8.061204e-19f * _Complex_I },</a>
<a name="ln1367">            { -5.616336e-04f - 9.727779e-04f * _Complex_I, 1.382894e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1368">              -8.694311e-04f + 1.505899e-03f * _Complex_I, -9.721139e-04f - 1.683751e-03f * _Complex_I,</a>
<a name="ln1369">              2.446785e-03f - 2.772471e-18f * _Complex_I, -1.605471e-03f + 2.780758e-03f * _Complex_I,</a>
<a name="ln1370">              -1.832781e-03f - 3.174469e-03f * _Complex_I, 3.210942e-03f - 7.276687e-18f * _Complex_I,</a>
<a name="ln1371">              -1.223392e-03f + 2.118978e-03f * _Complex_I, -9.721139e-04f - 1.683751e-03f * _Complex_I,</a>
<a name="ln1372">              1.738862e-03f - 1.277695e-18f * _Complex_I, -6.914471e-04f + 1.197621e-03f * _Complex_I,</a>
<a name="ln1373">              -5.616336e-04f - 9.727779e-04f * _Complex_I },</a>
<a name="ln1374">            { -5.723872e-04f + 9.914038e-04f * _Complex_I, -8.302721e-04f - 1.438073e-03f * _Complex_I,</a>
<a name="ln1375">              2.445280e-03f + 0.000000e+00f * _Complex_I, -1.378399e-03f + 2.387458e-03f * _Complex_I,</a>
<a name="ln1376">              -1.882898e-03f - 3.261274e-03f * _Complex_I, 4.921549e-03f - 1.205432e-18f * _Complex_I,</a>
<a name="ln1377">              -2.760152e-03f + 4.780723e-03f * _Complex_I, -2.460774e-03f - 4.262186e-03f * _Complex_I,</a>
<a name="ln1378">              3.765795e-03f - 1.844708e-18f * _Complex_I, -1.378399e-03f + 2.387458e-03f * _Complex_I,</a>
<a name="ln1379">              -1.222640e-03f - 2.117675e-03f * _Complex_I, 1.660544e-03f - 1.220148e-18f * _Complex_I,</a>
<a name="ln1380">              -5.723872e-04f + 9.914038e-04f * _Complex_I },</a>
<a name="ln1381">            { 1.226482e-03f + 3.004015e-19f * _Complex_I, -9.600816e-04f + 1.662910e-03f * _Complex_I,</a>
<a name="ln1382">              -1.495900e-03f - 2.590974e-03f * _Complex_I, 3.833507e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1383">              -3.167257e-03f + 5.485850e-03f * _Complex_I, -4.303595e-03f - 7.454046e-03f * _Complex_I,</a>
<a name="ln1384">              9.412791e-03f - 2.305469e-18f * _Complex_I, -4.303595e-03f + 7.454046e-03f * _Complex_I,</a>
<a name="ln1385">              -3.167257e-03f - 5.485850e-03f * _Complex_I, 3.833507e-03f - 1.877877e-18f * _Complex_I,</a>
<a name="ln1386">              -1.495900e-03f + 2.590974e-03f * _Complex_I, -9.600816e-04f - 1.662910e-03f * _Complex_I,</a>
<a name="ln1387">              1.226482e-03f - 9.012046e-19f * _Complex_I },</a>
<a name="ln1388">            { -9.898007e-04f - 1.714385e-03f * _Complex_I, 3.215120e-03f + 3.643077e-18f * _Complex_I,</a>
<a name="ln1389">              -2.507621e-03f + 4.343327e-03f * _Complex_I, -3.557798e-03f - 6.162286e-03f * _Complex_I,</a>
<a name="ln1390">              1.105198e-02f + 0.000000e+00f * _Complex_I, -7.691179e-03f + 1.332151e-02f * _Complex_I,</a>
<a name="ln1391">              -8.705793e-03f - 1.507888e-02f * _Complex_I, 1.538236e-02f - 3.767591e-18f * _Complex_I,</a>
<a name="ln1392">              -5.525988e-03f + 9.571292e-03f * _Complex_I, -3.557798e-03f - 6.162286e-03f * _Complex_I,</a>
<a name="ln1393">              5.015242e-03f - 2.456760e-18f * _Complex_I, -1.607560e-03f + 2.784375e-03f * _Complex_I,</a>
<a name="ln1394">              -9.898007e-04f - 1.714385e-03f * _Complex_I },</a>
<a name="ln1395">            { -1.414655e-03f + 2.450254e-03f * _Complex_I, -2.341263e-03f - 4.055186e-03f * _Complex_I,</a>
<a name="ln1396">              6.915775e-03f + 1.693876e-18f * _Complex_I, -5.086403e-03f + 8.809908e-03f * _Complex_I,</a>
<a name="ln1397">              -8.062191e-03f - 1.396412e-02f * _Complex_I, 2.415333e-02f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1398">              -1.451128e-02f + 2.513428e-02f * _Complex_I, -1.207667e-02f - 2.091740e-02f * _Complex_I,</a>
<a name="ln1399">              1.612438e-02f - 3.949335e-18f * _Complex_I, -5.086403e-03f + 8.809908e-03f * _Complex_I,</a>
<a name="ln1400">              -3.457887e-03f - 5.989237e-03f * _Complex_I, 4.682526e-03f - 1.061161e-17f * _Complex_I,</a>
<a name="ln1401">              -1.414655e-03f + 2.450254e-03f * _Complex_I },</a>
<a name="ln1402">            { 3.039574e-03f + 1.488962e-18f * _Complex_I, -2.598226e-03f + 4.500260e-03f * _Complex_I,</a>
<a name="ln1403">              -3.750909e-03f - 6.496765e-03f * _Complex_I, 1.119776e-02f + 2.742661e-18f * _Complex_I,</a>
<a name="ln1404">              -9.210579e-03f + 1.595319e-02f * _Complex_I, -1.464762e-02f - 2.537042e-02f * _Complex_I,</a>
<a name="ln1405">              3.672076e-02f + 0.000000e+00f * _Complex_I, -1.464762e-02f + 2.537042e-02f * _Complex_I,</a>
<a name="ln1406">              -9.210579e-03f - 1.595319e-02f * _Complex_I, 1.119776e-02f - 2.742661e-18f * _Complex_I,</a>
<a name="ln1407">              -3.750909e-03f + 6.496765e-03f * _Complex_I, -2.598226e-03f - 4.500260e-03f * _Complex_I,</a>
<a name="ln1408">              3.039574e-03f - 1.488962e-18f * _Complex_I },</a>
<a name="ln1409">            { -1.414655e-03f - 2.450254e-03f * _Complex_I, 4.682526e-03f + 1.061161e-17f * _Complex_I,</a>
<a name="ln1410">              -3.457887e-03f + 5.989237e-03f * _Complex_I, -5.086403e-03f - 8.809908e-03f * _Complex_I,</a>
<a name="ln1411">              1.612438e-02f + 3.949335e-18f * _Complex_I, -1.207667e-02f + 2.091740e-02f * _Complex_I,</a>
<a name="ln1412">              -1.451128e-02f - 2.513428e-02f * _Complex_I, 2.415333e-02f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1413">              -8.062191e-03f + 1.396412e-02f * _Complex_I, -5.086403e-03f - 8.809908e-03f * _Complex_I,</a>
<a name="ln1414">              6.915775e-03f - 1.693876e-18f * _Complex_I, -2.341263e-03f + 4.055186e-03f * _Complex_I,</a>
<a name="ln1415">              -1.414655e-03f - 2.450254e-03f * _Complex_I },</a>
<a name="ln1416">            { -9.898007e-04f + 1.714385e-03f * _Complex_I, -1.607560e-03f - 2.784375e-03f * _Complex_I,</a>
<a name="ln1417">              5.015242e-03f + 2.456760e-18f * _Complex_I, -3.557798e-03f + 6.162286e-03f * _Complex_I,</a>
<a name="ln1418">              -5.525988e-03f - 9.571292e-03f * _Complex_I, 1.538236e-02f + 3.767591e-18f * _Complex_I,</a>
<a name="ln1419">              -8.705793e-03f + 1.507888e-02f * _Complex_I, -7.691179e-03f - 1.332151e-02f * _Complex_I,</a>
<a name="ln1420">              1.105198e-02f + 0.000000e+00f * _Complex_I, -3.557798e-03f + 6.162286e-03f * _Complex_I,</a>
<a name="ln1421">              -2.507621e-03f - 4.343327e-03f * _Complex_I, 3.215120e-03f - 3.643077e-18f * _Complex_I,</a>
<a name="ln1422">              -9.898007e-04f + 1.714385e-03f * _Complex_I },</a>
<a name="ln1423">            { 1.226482e-03f + 9.012046e-19f * _Complex_I, -9.600816e-04f + 1.662910e-03f * _Complex_I,</a>
<a name="ln1424">              -1.495900e-03f - 2.590974e-03f * _Complex_I, 3.833507e-03f + 1.877877e-18f * _Complex_I,</a>
<a name="ln1425">              -3.167257e-03f + 5.485850e-03f * _Complex_I, -4.303595e-03f - 7.454046e-03f * _Complex_I,</a>
<a name="ln1426">              9.412791e-03f + 2.305469e-18f * _Complex_I, -4.303595e-03f + 7.454046e-03f * _Complex_I,</a>
<a name="ln1427">              -3.167257e-03f - 5.485850e-03f * _Complex_I, 3.833507e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1428">              -1.495900e-03f + 2.590974e-03f * _Complex_I, -9.600816e-04f - 1.662910e-03f * _Complex_I,</a>
<a name="ln1429">              1.226482e-03f - 3.004015e-19f * _Complex_I },</a>
<a name="ln1430">            { -5.723872e-04f - 9.914038e-04f * _Complex_I, 1.660544e-03f + 1.220148e-18f * _Complex_I,</a>
<a name="ln1431">              -1.222640e-03f + 2.117675e-03f * _Complex_I, -1.378399e-03f - 2.387458e-03f * _Complex_I,</a>
<a name="ln1432">              3.765795e-03f + 1.844708e-18f * _Complex_I, -2.460774e-03f + 4.262186e-03f * _Complex_I,</a>
<a name="ln1433">              -2.760152e-03f - 4.780723e-03f * _Complex_I, 4.921549e-03f + 1.205432e-18f * _Complex_I,</a>
<a name="ln1434">              -1.882898e-03f + 3.261274e-03f * _Complex_I, -1.378399e-03f - 2.387458e-03f * _Complex_I,</a>
<a name="ln1435">              2.445280e-03f + 0.000000e+00f * _Complex_I, -8.302721e-04f + 1.438073e-03f * _Complex_I,</a>
<a name="ln1436">              -5.723872e-04f - 9.914038e-04f * _Complex_I },</a>
<a name="ln1437">            { -5.616336e-04f + 9.727779e-04f * _Complex_I, -6.914471e-04f - 1.197621e-03f * _Complex_I,</a>
<a name="ln1438">              1.738862e-03f + 1.277695e-18f * _Complex_I, -9.721139e-04f + 1.683751e-03f * _Complex_I,</a>
<a name="ln1439">              -1.223392e-03f - 2.118978e-03f * _Complex_I, 3.210942e-03f + 7.276687e-18f * _Complex_I,</a>
<a name="ln1440">              -1.832781e-03f + 3.174469e-03f * _Complex_I, -1.605471e-03f - 2.780758e-03f * _Complex_I,</a>
<a name="ln1441">              2.446785e-03f + 2.772471e-18f * _Complex_I, -9.721139e-04f + 1.683751e-03f * _Complex_I,</a>
<a name="ln1442">              -8.694311e-04f - 1.505899e-03f * _Complex_I, 1.382894e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1443">              -5.616336e-04f + 9.727779e-04f * _Complex_I },</a>
<a name="ln1444">            { 8.228091e-04f + 8.061204e-19f * _Complex_I, -5.365069e-04f + 9.292572e-04f * _Complex_I,</a>
<a name="ln1445">              -6.011501e-04f - 1.041223e-03f * _Complex_I, 1.249890e-03f + 9.184039e-19f * _Complex_I,</a>
<a name="ln1446">              -7.632708e-04f + 1.322024e-03f * _Complex_I, -9.846035e-04f - 1.705383e-03f * _Complex_I,</a>
<a name="ln1447">              2.080486e-03f + 1.019144e-18f * _Complex_I, -9.846035e-04f + 1.705383e-03f * _Complex_I,</a>
<a name="ln1448">              -7.632708e-04f - 1.322024e-03f * _Complex_I, 1.249890e-03f + 3.061346e-19f * _Complex_I,</a>
<a name="ln1449">              -6.011501e-04f + 1.041223e-03f * _Complex_I, -5.365069e-04f - 9.292572e-04f * _Complex_I,</a>
<a name="ln1450">              8.228091e-04f + 0.000000e+00f * _Complex_I } },</a>
<a name="ln1451">          { { 1.221201e-03f + 5.982162e-19f * _Complex_I, -1.773498e-03f - 6.515727e-19f * _Complex_I,</a>
<a name="ln1452">              1.246697e-03f + 3.053526e-19f * _Complex_I, -8.215306e-04f - 1.006085e-19f * _Complex_I,</a>
<a name="ln1453">              7.609372e-04f + 0.000000e+00f * _Complex_I, -4.863927e-04f + 5.956592e-20f * _Complex_I,</a>
<a name="ln1454">              4.882100e-04f - 1.195770e-19f * _Complex_I, -4.863927e-04f + 1.786978e-19f * _Complex_I,</a>
<a name="ln1455">              7.609372e-04f - 3.727517e-19f * _Complex_I, -8.215306e-04f + 5.030424e-19f * _Complex_I,</a>
<a name="ln1456">              1.246697e-03f - 9.160579e-19f * _Complex_I, -1.773498e-03f + 1.520336e-18f * _Complex_I,</a>
<a name="ln1457">              1.221201e-03f - 1.196432e-18f * _Complex_I },</a>
<a name="ln1458">            { 7.406884e-04f - 1.282910e-03f * _Complex_I, -1.025411e-03f + 1.776065e-03f * _Complex_I,</a>
<a name="ln1459">              7.186273e-04f - 1.244699e-03f * _Complex_I, -4.025606e-04f + 6.972554e-04f * _Complex_I,</a>
<a name="ln1460">              5.908383e-04f - 1.023362e-03f * _Complex_I, -1.125190e-03f + 1.948886e-03f * _Complex_I,</a>
<a name="ln1461">              1.432695e-03f - 2.481501e-03f * _Complex_I, -1.125190e-03f + 1.948886e-03f * _Complex_I,</a>
<a name="ln1462">              5.908383e-04f - 1.023362e-03f * _Complex_I, -4.025606e-04f + 6.972554e-04f * _Complex_I,</a>
<a name="ln1463">              7.186273e-04f - 1.244699e-03f * _Complex_I, -1.025411e-03f + 1.776065e-03f * _Complex_I,</a>
<a name="ln1464">              7.406884e-04f - 1.282910e-03f * _Complex_I },</a>
<a name="ln1465">            { -7.162255e-04f - 1.240539e-03f * _Complex_I, 8.961176e-04f + 1.552121e-03f * _Complex_I,</a>
<a name="ln1466">              -6.705589e-04f - 1.161442e-03f * _Complex_I, 6.187140e-04f + 1.071644e-03f * _Complex_I,</a>
<a name="ln1467">              -1.165433e-03f - 2.018589e-03f * _Complex_I, 1.948120e-03f + 3.374242e-03f * _Complex_I,</a>
<a name="ln1468">              -2.297663e-03f - 3.979669e-03f * _Complex_I, 1.948120e-03f + 3.374242e-03f * _Complex_I,</a>
<a name="ln1469">              -1.165433e-03f - 2.018589e-03f * _Complex_I, 6.187140e-04f + 1.071644e-03f * _Complex_I,</a>
<a name="ln1470">              -6.705589e-04f - 1.161442e-03f * _Complex_I, 8.961176e-04f + 1.552121e-03f * _Complex_I,</a>
<a name="ln1471">              -7.162255e-04f - 1.240539e-03f * _Complex_I },</a>
<a name="ln1472">            { -1.280260e-03f - 7.839331e-19f * _Complex_I, 1.987108e-03f + 9.734024e-19f * _Complex_I,</a>
<a name="ln1473">              -2.614019e-03f - 9.603749e-19f * _Complex_I, 3.635167e-03f + 8.903590e-19f * _Complex_I,</a>
<a name="ln1474">              -4.954867e-03f - 6.067962e-19f * _Complex_I, 6.653220e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1475">              -7.600546e-03f + 9.307984e-19f * _Complex_I, 6.653220e-03f - 1.629569e-18f * _Complex_I,</a>
<a name="ln1476">              -4.954867e-03f + 1.820389e-18f * _Complex_I, 3.635167e-03f - 1.780718e-18f * _Complex_I,</a>
<a name="ln1477">              -2.614019e-03f + 1.600625e-18f * _Complex_I, 1.987108e-03f - 1.460104e-18f * _Complex_I,</a>
<a name="ln1478">              -1.280260e-03f + 1.097506e-18f * _Complex_I },</a>
<a name="ln1479">            { -5.756945e-04f + 9.971322e-04f * _Complex_I, 1.268614e-03f - 2.197304e-03f * _Complex_I,</a>
<a name="ln1480">              -2.421407e-03f + 4.194000e-03f * _Complex_I, 4.045715e-03f - 7.007384e-03f * _Complex_I,</a>
<a name="ln1481">              -5.527367e-03f + 9.573681e-03f * _Complex_I, 6.837207e-03f - 1.184239e-02f * _Complex_I,</a>
<a name="ln1482">              -7.288212e-03f + 1.262355e-02f * _Complex_I, 6.837207e-03f - 1.184239e-02f * _Complex_I,</a>
<a name="ln1483">              -5.527367e-03f + 9.573681e-03f * _Complex_I, 4.045715e-03f - 7.007384e-03f * _Complex_I,</a>
<a name="ln1484">              -2.421407e-03f + 4.194000e-03f * _Complex_I, 1.268614e-03f - 2.197304e-03f * _Complex_I,</a>
<a name="ln1485">              -5.756945e-04f + 9.971322e-04f * _Complex_I },</a>
<a name="ln1486">            { 7.349896e-04f + 1.273039e-03f * _Complex_I, -1.748057e-03f - 3.027723e-03f * _Complex_I,</a>
<a name="ln1487">              3.332671e-03f + 5.772355e-03f * _Complex_I, -6.051736e-03f - 1.048191e-02f * _Complex_I,</a>
<a name="ln1488">              9.842376e-03f + 1.704749e-02f * _Complex_I, -1.401169e-02f - 2.426897e-02f * _Complex_I,</a>
<a name="ln1489">              1.598601e-02f + 2.768858e-02f * _Complex_I, -1.401169e-02f - 2.426897e-02f * _Complex_I,</a>
<a name="ln1490">              9.842376e-03f + 1.704749e-02f * _Complex_I, -6.051736e-03f - 1.048191e-02f * _Complex_I,</a>
<a name="ln1491">              3.332671e-03f + 5.772355e-03f * _Complex_I, -1.748057e-03f - 3.027723e-03f * _Complex_I,</a>
<a name="ln1492">              7.349896e-04f + 1.273039e-03f * _Complex_I },</a>
<a name="ln1493">            { 1.400383e-03f + 1.028985e-18f * _Complex_I, -3.545886e-03f - 2.171229e-18f * _Complex_I,</a>
<a name="ln1494">              7.289370e-03f + 3.570761e-18f * _Complex_I, -1.418908e-02f - 5.212982e-18f * _Complex_I,</a>
<a name="ln1495">              2.520839e-02f + 6.174275e-18f * _Complex_I, -3.934772e-02f - 4.818706e-18f * _Complex_I,</a>
<a name="ln1496">              4.797481e-02f + 0.000000e+00f * _Complex_I, -3.934772e-02f + 4.818706e-18f * _Complex_I,</a>
<a name="ln1497">              2.520839e-02f - 6.174275e-18f * _Complex_I, -1.418908e-02f + 5.212982e-18f * _Complex_I,</a>
<a name="ln1498">              7.289370e-03f - 3.570761e-18f * _Complex_I, -3.545886e-03f + 2.171229e-18f * _Complex_I,</a>
<a name="ln1499">              1.400383e-03f - 1.028985e-18f * _Complex_I },</a>
<a name="ln1500">            { 7.349896e-04f - 1.273039e-03f * _Complex_I, -1.748057e-03f + 3.027723e-03f * _Complex_I,</a>
<a name="ln1501">              3.332671e-03f - 5.772355e-03f * _Complex_I, -6.051736e-03f + 1.048191e-02f * _Complex_I,</a>
<a name="ln1502">              9.842376e-03f - 1.704749e-02f * _Complex_I, -1.401169e-02f + 2.426897e-02f * _Complex_I,</a>
<a name="ln1503">              1.598601e-02f - 2.768858e-02f * _Complex_I, -1.401169e-02f + 2.426897e-02f * _Complex_I,</a>
<a name="ln1504">              9.842376e-03f - 1.704749e-02f * _Complex_I, -6.051736e-03f + 1.048191e-02f * _Complex_I,</a>
<a name="ln1505">              3.332671e-03f - 5.772355e-03f * _Complex_I, -1.748057e-03f + 3.027723e-03f * _Complex_I,</a>
<a name="ln1506">              7.349896e-04f - 1.273039e-03f * _Complex_I },</a>
<a name="ln1507">            { -5.756945e-04f - 9.971322e-04f * _Complex_I, 1.268614e-03f + 2.197304e-03f * _Complex_I,</a>
<a name="ln1508">              -2.421407e-03f - 4.194000e-03f * _Complex_I, 4.045715e-03f + 7.007384e-03f * _Complex_I,</a>
<a name="ln1509">              -5.527367e-03f - 9.573681e-03f * _Complex_I, 6.837207e-03f + 1.184239e-02f * _Complex_I,</a>
<a name="ln1510">              -7.288212e-03f - 1.262355e-02f * _Complex_I, 6.837207e-03f + 1.184239e-02f * _Complex_I,</a>
<a name="ln1511">              -5.527367e-03f - 9.573681e-03f * _Complex_I, 4.045715e-03f + 7.007384e-03f * _Complex_I,</a>
<a name="ln1512">              -2.421407e-03f - 4.194000e-03f * _Complex_I, 1.268614e-03f + 2.197304e-03f * _Complex_I,</a>
<a name="ln1513">              -5.756945e-04f - 9.971322e-04f * _Complex_I },</a>
<a name="ln1514">            { -1.280260e-03f - 1.097506e-18f * _Complex_I, 1.987108e-03f + 1.460104e-18f * _Complex_I,</a>
<a name="ln1515">              -2.614019e-03f - 1.600625e-18f * _Complex_I, 3.635167e-03f + 1.780718e-18f * _Complex_I,</a>
<a name="ln1516">              -4.954867e-03f - 1.820389e-18f * _Complex_I, 6.653220e-03f + 1.629569e-18f * _Complex_I,</a>
<a name="ln1517">              -7.600546e-03f - 9.307984e-19f * _Complex_I, 6.653220e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1518">              -4.954867e-03f + 6.067962e-19f * _Complex_I, 3.635167e-03f - 8.903590e-19f * _Complex_I,</a>
<a name="ln1519">              -2.614019e-03f + 9.603749e-19f * _Complex_I, 1.987108e-03f - 9.734024e-19f * _Complex_I,</a>
<a name="ln1520">              -1.280260e-03f + 7.839331e-19f * _Complex_I },</a>
<a name="ln1521">            { -7.162255e-04f + 1.240539e-03f * _Complex_I, 8.961176e-04f - 1.552121e-03f * _Complex_I,</a>
<a name="ln1522">              -6.705589e-04f + 1.161442e-03f * _Complex_I, 6.187140e-04f - 1.071644e-03f * _Complex_I,</a>
<a name="ln1523">              -1.165433e-03f + 2.018589e-03f * _Complex_I, 1.948120e-03f - 3.374242e-03f * _Complex_I,</a>
<a name="ln1524">              -2.297663e-03f + 3.979669e-03f * _Complex_I, 1.948120e-03f - 3.374242e-03f * _Complex_I,</a>
<a name="ln1525">              -1.165433e-03f + 2.018589e-03f * _Complex_I, 6.187140e-04f - 1.071644e-03f * _Complex_I,</a>
<a name="ln1526">              -6.705589e-04f + 1.161442e-03f * _Complex_I, 8.961176e-04f - 1.552121e-03f * _Complex_I,</a>
<a name="ln1527">              -7.162255e-04f + 1.240539e-03f * _Complex_I },</a>
<a name="ln1528">            { 7.406884e-04f + 1.282910e-03f * _Complex_I, -1.025411e-03f - 1.776065e-03f * _Complex_I,</a>
<a name="ln1529">              7.186273e-04f + 1.244699e-03f * _Complex_I, -4.025606e-04f - 6.972554e-04f * _Complex_I,</a>
<a name="ln1530">              5.908383e-04f + 1.023362e-03f * _Complex_I, -1.125190e-03f - 1.948886e-03f * _Complex_I,</a>
<a name="ln1531">              1.432695e-03f + 2.481501e-03f * _Complex_I, -1.125190e-03f - 1.948886e-03f * _Complex_I,</a>
<a name="ln1532">              5.908383e-04f + 1.023362e-03f * _Complex_I, -4.025606e-04f - 6.972554e-04f * _Complex_I,</a>
<a name="ln1533">              7.186273e-04f + 1.244699e-03f * _Complex_I, -1.025411e-03f - 1.776065e-03f * _Complex_I,</a>
<a name="ln1534">              7.406884e-04f + 1.282910e-03f * _Complex_I },</a>
<a name="ln1535">            { 1.221201e-03f + 1.196432e-18f * _Complex_I, -1.773498e-03f - 1.520336e-18f * _Complex_I,</a>
<a name="ln1536">              1.246697e-03f + 9.160579e-19f * _Complex_I, -8.215306e-04f - 5.030424e-19f * _Complex_I,</a>
<a name="ln1537">              7.609372e-04f + 3.727517e-19f * _Complex_I, -4.863927e-04f - 1.786978e-19f * _Complex_I,</a>
<a name="ln1538">              4.882100e-04f + 1.195770e-19f * _Complex_I, -4.863927e-04f - 5.956592e-20f * _Complex_I,</a>
<a name="ln1539">              7.609372e-04f + 0.000000e+00f * _Complex_I, -8.215306e-04f + 1.006085e-19f * _Complex_I,</a>
<a name="ln1540">              1.246697e-03f - 3.053526e-19f * _Complex_I, -1.773498e-03f + 6.515727e-19f * _Complex_I,</a>
<a name="ln1541">              1.221201e-03f - 5.982162e-19f * _Complex_I } } };</a>
<a name="ln1542"> </a>
<a name="ln1543">  const size_t buffer_size = (size_t)TS * TS * (ndir * 4 + 7) * sizeof(float);</a>
<a name="ln1544">  char *const all_buffers = (char *)dt_alloc_align(64, dt_get_num_threads() * buffer_size);</a>
<a name="ln1545">  if(!all_buffers)</a>
<a name="ln1546">  {</a>
<a name="ln1547">    fprintf(stderr, &quot;[demosaic] not able to allocate FDC base buffers\n&quot;);</a>
<a name="ln1548">    return;</a>
<a name="ln1549">  }</a>
<a name="ln1550"> </a>
<a name="ln1551">  /* Map a green hexagon around each non-green pixel and vice versa:    */</a>
<a name="ln1552">  for(int row = 0; row &lt; 3; row++)</a>
<a name="ln1553">    for(int col = 0; col &lt; 3; col++)</a>
<a name="ln1554">      for(int ng = 0, d = 0; d &lt; 10; d += 2)</a>
<a name="ln1555">      {</a>
<a name="ln1556">        int g = FCxtrans(row, col, NULL, xtrans) == 1;</a>
<a name="ln1557">        if(FCxtrans(row + orth[d], col + orth[d + 2], NULL, xtrans) == 1)</a>
<a name="ln1558">          ng = 0;</a>
<a name="ln1559">        else</a>
<a name="ln1560">          ng++;</a>
<a name="ln1561">        // if there are four non-green pixels adjacent in cardinal</a>
<a name="ln1562">        // directions, this is the solitary green pixel</a>
<a name="ln1563">        if(ng == 4)</a>
<a name="ln1564">        {</a>
<a name="ln1565">          sgrow = row;</a>
<a name="ln1566">          sgcol = col;</a>
<a name="ln1567">        }</a>
<a name="ln1568">        if(ng == g + 1)</a>
<a name="ln1569">          for(int c = 0; c &lt; 8; c++)</a>
<a name="ln1570">          {</a>
<a name="ln1571">            int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];</a>
<a name="ln1572">            int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];</a>
<a name="ln1573">            // offset within TSxTS buffer</a>
<a name="ln1574">            allhex[row][col][c ^ (g * 2 &amp; d)] = h + v * TS;</a>
<a name="ln1575">          }</a>
<a name="ln1576">      }</a>
<a name="ln1577"> </a>
<a name="ln1578">  // extra passes propagates out errors at edges, hence need more padding</a>
<a name="ln1579">  const int pad_tile = 13;</a>
<a name="ln1580"> </a>
<a name="ln1581">  // calculate offsets for this roi</a>
<a name="ln1582">  int rowoffset = 0;</a>
<a name="ln1583">  int coloffset = 0;</a>
<a name="ln1584">  for(int row = 0; row &lt; 6; row++)</a>
<a name="ln1585">  {</a>
<a name="ln1586">    if(!((row - sgrow) % 3))</a>
<a name="ln1587">    {</a>
<a name="ln1588">      for(int col = 0; col &lt; 6; col++)</a>
<a name="ln1589">      {</a>
<a name="ln1590">        if(!((col - sgcol) % 3) &amp;&amp; (FCxtrans(row, col + 1, roi_in, xtrans) == 0))</a>
<a name="ln1591">        {</a>
<a name="ln1592">          rowoffset = 37 - row - pad_tile; // 1 plus a generous multiple of 6</a>
<a name="ln1593">          coloffset = 37 - col - pad_tile; // to avoid that this value gets negative</a>
<a name="ln1594">          break;</a>
<a name="ln1595">        }</a>
<a name="ln1596">      }</a>
<a name="ln1597">      break;</a>
<a name="ln1598">    }</a>
<a name="ln1599">  }</a>
<a name="ln1600"> </a>
<a name="ln1601">  // depending on the iso, use either a hybrid approach for chroma, or pure fdc</a>
<a name="ln1602">  float hybrid_fdc[2] = { 1.0f, 0.0f };</a>
<a name="ln1603">  const int xover_iso = dt_conf_get_int(&quot;plugins/darkroom/demosaic/fdc_xover_iso&quot;);</a>
<a name="ln1604">  int iso = self-&gt;dev-&gt;image_storage.exif_iso;</a>
<a name="ln1605">  if(iso &gt; xover_iso)</a>
<a name="ln1606">  {</a>
<a name="ln1607">    hybrid_fdc[0] = 0.0f;</a>
<a name="ln1608">    hybrid_fdc[1] = 1.0f;</a>
<a name="ln1609">  }</a>
<a name="ln1610"> </a>
<a name="ln1611">#ifdef _OPENMP</a>
<a name="ln1612">#pragma omp parallel for default(none) shared(sgrow, sgcol, allhex, out, rowoffset, coloffset, hybrid_fdc) schedule(dynamic)</a>
<a name="ln1613">#endif</a>
<a name="ln1614">  // step through TSxTS cells of image, each tile overlapping the</a>
<a name="ln1615">  // prior as interpolation needs a substantial border</a>
<a name="ln1616">  for(int top = -pad_tile; top &lt; height - pad_tile; top += TS - (pad_tile * 2))</a>
<a name="ln1617">  {</a>
<a name="ln1618">    char *const buffer = all_buffers + dt_get_thread_num() * buffer_size;</a>
<a name="ln1619">    // rgb points to ndir TSxTS tiles of 3 channels (R, G, and B)</a>
<a name="ln1620">    float(*rgb)[TS][TS][3] = (float(*)[TS][TS][3])buffer;</a>
<a name="ln1621">    // yuv points to 3 channel (Y, u, and v) TSxTS tiles</a>
<a name="ln1622">    // note that channels come before tiles to allow for a</a>
<a name="ln1623">    // vectorization optimization when building drv[] from yuv[]</a>
<a name="ln1624">    float (*const yuv)[TS][TS] = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln1625">    // drv points to ndir TSxTS tiles, each a single chanel of derivatives</a>
<a name="ln1626">    float (*const drv)[TS][TS] = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 3 + 3) * sizeof(float));</a>
<a name="ln1627">    // gmin and gmax reuse memory which is used later by yuv buffer;</a>
<a name="ln1628">    // each points to a TSxTS tile of single channel data</a>
<a name="ln1629">    float (*const gmin)[TS] = (float(*)[TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln1630">    float (*const gmax)[TS] = (float(*)[TS])(buffer + TS * TS * (ndir * 3 + 1) * sizeof(float));</a>
<a name="ln1631">    // homo and homosum reuse memory which is used earlier in the</a>
<a name="ln1632">    // loop; each points to ndir single-channel TSxTS tiles</a>
<a name="ln1633">    uint8_t (*const homo)[TS][TS] = (uint8_t(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln1634">    uint8_t (*const homosum)[TS][TS]</a>
<a name="ln1635">        = (uint8_t(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float) + TS * TS * ndir * sizeof(uint8_t));</a>
<a name="ln1636">    // append all fdc related buffers</a>
<a name="ln1637">    float complex *fdc_buf_start = (float complex *)(buffer + TS * TS * (ndir * 4 + 3) * sizeof(float));</a>
<a name="ln1638">    const int fdc_buf_size = TS * TS;</a>
<a name="ln1639">    float(*const i_src) = (float *)fdc_buf_start;</a>
<a name="ln1640">    float complex(*const o_src) = fdc_buf_start + fdc_buf_size;</a>
<a name="ln1641">    // by the time the chroma values are calculated, o_src can be overwritten.</a>
<a name="ln1642">    float(*const fdc_chroma) = (float *)o_src;</a>
<a name="ln1643"> </a>
<a name="ln1644">    for(int left = -pad_tile; left &lt; width - pad_tile; left += TS - (pad_tile * 2))</a>
<a name="ln1645">    {</a>
<a name="ln1646">      int mrow = MIN(top + TS, height + pad_tile);</a>
<a name="ln1647">      int mcol = MIN(left + TS, width + pad_tile);</a>
<a name="ln1648"> </a>
<a name="ln1649">      // Copy current tile from in to image buffer. If border goes</a>
<a name="ln1650">      // beyond edges of image, fill with mirrored/interpolated edges.</a>
<a name="ln1651">      // The extra border avoids discontinuities at image edges.</a>
<a name="ln1652">      for(int row = top; row &lt; mrow; row++)</a>
<a name="ln1653">        for(int col = left; col &lt; mcol; col++)</a>
<a name="ln1654">        {</a>
<a name="ln1655">          float(*const pix) = rgb[0][row - top][col - left];</a>
<a name="ln1656">          if((col &gt;= 0) &amp;&amp; (row &gt;= 0) &amp;&amp; (col &lt; width) &amp;&amp; (row &lt; height))</a>
<a name="ln1657">          {</a>
<a name="ln1658">            const int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln1659">            for(int c = 0; c &lt; 3; c++) pix[c] = (c == f) ? in[roi_in-&gt;width * row + col] : 0.f;</a>
<a name="ln1660">            *(i_src + TS * (row - top) + (col - left)) = in[roi_in-&gt;width * row + col];</a>
<a name="ln1661">          }</a>
<a name="ln1662">          else</a>
<a name="ln1663">          {</a>
<a name="ln1664">            // mirror a border pixel if beyond image edge</a>
<a name="ln1665">            const int c = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln1666">            for(int cc = 0; cc &lt; 3; cc++)</a>
<a name="ln1667">              if(cc != c)</a>
<a name="ln1668">                pix[cc] = 0.0f;</a>
<a name="ln1669">              else</a>
<a name="ln1670">              {</a>
<a name="ln1671">#define TRANSLATE(n, size) ((n &gt;= size) ? (2 * size - n - 2) : abs(n))</a>
<a name="ln1672">                const int cy = TRANSLATE(row, height), cx = TRANSLATE(col, width);</a>
<a name="ln1673">                if(c == FCxtrans(cy, cx, roi_in, xtrans))</a>
<a name="ln1674">                {</a>
<a name="ln1675">                  pix[c] = in[roi_in-&gt;width * cy + cx];</a>
<a name="ln1676">                  *(i_src + TS * (row - top) + (col - left)) = in[roi_in-&gt;width * cy + cx];</a>
<a name="ln1677">                }</a>
<a name="ln1678">                else</a>
<a name="ln1679">                {</a>
<a name="ln1680">                  // interpolate if mirror pixel is a different color</a>
<a name="ln1681">                  float sum = 0.0f;</a>
<a name="ln1682">                  uint8_t count = 0;</a>
<a name="ln1683">                  for(int y = row - 1; y &lt;= row + 1; y++)</a>
<a name="ln1684">                    for(int x = col - 1; x &lt;= col + 1; x++)</a>
<a name="ln1685">                    {</a>
<a name="ln1686">                      const int yy = TRANSLATE(y, height), xx = TRANSLATE(x, width);</a>
<a name="ln1687">                      const int ff = FCxtrans(yy, xx, roi_in, xtrans);</a>
<a name="ln1688">                      if(ff == c)</a>
<a name="ln1689">                      {</a>
<a name="ln1690">                        sum += in[roi_in-&gt;width * yy + xx];</a>
<a name="ln1691">                        count++;</a>
<a name="ln1692">                      }</a>
<a name="ln1693">                    }</a>
<a name="ln1694">                  pix[c] = sum / count;</a>
<a name="ln1695">                  *(i_src + TS * (row - top) + (col - left)) = pix[c];</a>
<a name="ln1696">                }</a>
<a name="ln1697">              }</a>
<a name="ln1698">          }</a>
<a name="ln1699">        }</a>
<a name="ln1700"> </a>
<a name="ln1701">      // duplicate rgb[0] to rgb[1], rgb[2], and rgb[3]</a>
<a name="ln1702">      for(int c = 1; c &lt;= 3; c++) memcpy(rgb[c], rgb[0], sizeof(*rgb));</a>
<a name="ln1703"> </a>
<a name="ln1704">      // note that successive calculations are inset within the tile</a>
<a name="ln1705">      // so as to give enough border data, and there needs to be a 6</a>
<a name="ln1706">      // pixel border initially to allow allhex to find neighboring</a>
<a name="ln1707">      // pixels</a>
<a name="ln1708"> </a>
<a name="ln1709">      /* Set green1 and green3 to the minimum and maximum allowed values:   */</a>
<a name="ln1710">      // Run through each red/blue or blue/red pair, setting their g1</a>
<a name="ln1711">      // and g3 values to the min/max of green pixels surrounding the</a>
<a name="ln1712">      // pair. Use a 3 pixel border as gmin/gmax is used by</a>
<a name="ln1713">      // interpolate green which has a 3 pixel border.</a>
<a name="ln1714">      const int pad_g1_g3 = 3;</a>
<a name="ln1715">      for(int row = top + pad_g1_g3; row &lt; mrow - pad_g1_g3; row++)</a>
<a name="ln1716">      {</a>
<a name="ln1717">        // setting max to 0.0f signifies that this is a new pair, which</a>
<a name="ln1718">        // requires a new min/max calculation of its neighboring greens</a>
<a name="ln1719">        float min = FLT_MAX, max = 0.0f;</a>
<a name="ln1720">        for(int col = left + pad_g1_g3; col &lt; mcol - pad_g1_g3; col++)</a>
<a name="ln1721">        {</a>
<a name="ln1722">          // if in row of horizontal red &amp; blue pairs (or processing</a>
<a name="ln1723">          // vertical red &amp; blue pairs near image bottom), reset min/max</a>
<a name="ln1724">          // between each pair</a>
<a name="ln1725">          if(FCxtrans(row, col, roi_in, xtrans) == 1)</a>
<a name="ln1726">          {</a>
<a name="ln1727">            min = FLT_MAX, max = 0.0f;</a>
<a name="ln1728">            continue;</a>
<a name="ln1729">          }</a>
<a name="ln1730">          // if at start of red &amp; blue pair, calculate min/max of green</a>
<a name="ln1731">          // pixels surrounding it; note that while normally using == to</a>
<a name="ln1732">          // compare floats is suspect, here the check is if 0.0f has</a>
<a name="ln1733">          // explicitly been assigned to max (which signifies a new</a>
<a name="ln1734">          // red/blue pair)</a>
<a name="ln1735">          if(max == 0.0f)</a>
<a name="ln1736">          {</a>
<a name="ln1737">            float (*const pix)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1738">            const short *const hex = hexmap(row, col, allhex);</a>
<a name="ln1739">            for(int c = 0; c &lt; 6; c++)</a>
<a name="ln1740">            {</a>
<a name="ln1741">              const float val = pix[hex[c]][1];</a>
<a name="ln1742">              if(min &gt; val) min = val;</a>
<a name="ln1743">              if(max &lt; val) max = val;</a>
<a name="ln1744">            }</a>
<a name="ln1745">          }</a>
<a name="ln1746">          gmin[row - top][col - left] = min;</a>
<a name="ln1747">          gmax[row - top][col - left] = max;</a>
<a name="ln1748">          // handle vertical red/blue pairs</a>
<a name="ln1749">          switch((row - sgrow) % 3)</a>
<a name="ln1750">          {</a>
<a name="ln1751">            // hop down a row to second pixel in vertical pair</a>
<a name="ln1752">            case 1:</a>
<a name="ln1753">              if(row &lt; mrow - 4) row++, col--;</a>
<a name="ln1754">              break;</a>
<a name="ln1755">            // then if not done with the row hop up and right to next</a>
<a name="ln1756">            // vertical red/blue pair, resetting min/max</a>
<a name="ln1757">            case 2:</a>
<a name="ln1758">              min = FLT_MAX, max = 0.0f;</a>
<a name="ln1759">              if((col += 2) &lt; mcol - 4 &amp;&amp; row &gt; top + 3) row--;</a>
<a name="ln1760">          }</a>
<a name="ln1761">        }</a>
<a name="ln1762">      }</a>
<a name="ln1763"> </a>
<a name="ln1764">      /* Interpolate green horizontally, vertically, and along both diagonals: */</a>
<a name="ln1765">      // need a 3 pixel border here as 3*hex[] can have a 3 unit offset</a>
<a name="ln1766">      const int pad_g_interp = 3;</a>
<a name="ln1767">      for(int row = top + pad_g_interp; row &lt; mrow - pad_g_interp; row++)</a>
<a name="ln1768">        for(int col = left + pad_g_interp; col &lt; mcol - pad_g_interp; col++)</a>
<a name="ln1769">        {</a>
<a name="ln1770">          float color[8];</a>
<a name="ln1771">          int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln1772">          if(f == 1) continue;</a>
<a name="ln1773">          float (*const pix)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1774">          const short *const hex = hexmap(row, col, allhex);</a>
<a name="ln1775">          // TODO: these constants come from integer math constants in</a>
<a name="ln1776">          // dcraw -- calculate them instead from interpolation math</a>
<a name="ln1777">          color[0] = 0.6796875f * (pix[hex[1]][1] + pix[hex[0]][1])</a>
<a name="ln1778">                     - 0.1796875f * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);</a>
<a name="ln1779">          color[1] = 0.87109375f * pix[hex[3]][1] + pix[hex[2]][1] * 0.13f</a>
<a name="ln1780">                     + 0.359375f * (pix[0][f] - pix[-hex[2]][f]);</a>
<a name="ln1781">          for(int c = 0; c &lt; 2; c++)</a>
<a name="ln1782">            color[2 + c] = 0.640625f * pix[hex[4 + c]][1] + 0.359375f * pix[-2 * hex[4 + c]][1]</a>
<a name="ln1783">                           + 0.12890625f * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);</a>
<a name="ln1784">          for(int c = 0; c &lt; 4; c++)</a>
<a name="ln1785">            rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1]</a>
<a name="ln1786">                = CLAMPS(color[c], gmin[row - top][col - left], gmax[row - top][col - left]);</a>
<a name="ln1787">        }</a>
<a name="ln1788"> </a>
<a name="ln1789">      /* Interpolate red and blue values for solitary green pixels:   */</a>
<a name="ln1790">      const int pad_rb_g = 6;</a>
<a name="ln1791">      for(int row = (top - sgrow + pad_rb_g + 2) / 3 * 3 + sgrow; row &lt; mrow - pad_rb_g; row += 3)</a>
<a name="ln1792">        for(int col = (left - sgcol + pad_rb_g + 2) / 3 * 3 + sgcol; col &lt; mcol - pad_rb_g; col += 3)</a>
<a name="ln1793">        {</a>
<a name="ln1794">          float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1795">          int h = FCxtrans(row, col + 1, roi_in, xtrans);</a>
<a name="ln1796">          float diff[6] = { 0.0f };</a>
<a name="ln1797">          float color[3][8];</a>
<a name="ln1798">          for(int i = 1, d = 0; d &lt; 6; d++, i ^= TS ^ 1, h ^= 2)</a>
<a name="ln1799">          {</a>
<a name="ln1800">            for(int c = 0; c &lt; 2; c++, h ^= 2)</a>
<a name="ln1801">            {</a>
<a name="ln1802">              float g = 2 * rfx[0][1] - rfx[i &lt;&lt; c][1] - rfx[-(i &lt;&lt; c)][1];</a>
<a name="ln1803">              color[h][d] = g + rfx[i &lt;&lt; c][h] + rfx[-(i &lt;&lt; c)][h];</a>
<a name="ln1804">              if(d &gt; 1)</a>
<a name="ln1805">                diff[d] += SQR(rfx[i &lt;&lt; c][1] - rfx[-(i &lt;&lt; c)][1] - rfx[i &lt;&lt; c][h] + rfx[-(i &lt;&lt; c)][h]) + SQR(g);</a>
<a name="ln1806">            }</a>
<a name="ln1807">            if(d &gt; 1 &amp;&amp; (d &amp; 1))</a>
<a name="ln1808">              if(diff[d - 1] &lt; diff[d])</a>
<a name="ln1809">                for(int c = 0; c &lt; 2; c++) color[c * 2][d] = color[c * 2][d - 1];</a>
<a name="ln1810">            if(d &lt; 2 || (d &amp; 1))</a>
<a name="ln1811">            {</a>
<a name="ln1812">              for(int c = 0; c &lt; 2; c++) rfx[0][c * 2] = color[c * 2][d] / 2.f;</a>
<a name="ln1813">              rfx += TS * TS;</a>
<a name="ln1814">            }</a>
<a name="ln1815">          }</a>
<a name="ln1816">        }</a>
<a name="ln1817"> </a>
<a name="ln1818">      /* Interpolate red for blue pixels and vice versa:              */</a>
<a name="ln1819">      const int pad_rb_br = 6;</a>
<a name="ln1820">      for(int row = top + pad_rb_br; row &lt; mrow - pad_rb_br; row++)</a>
<a name="ln1821">        for(int col = left + pad_rb_br; col &lt; mcol - pad_rb_br; col++)</a>
<a name="ln1822">        {</a>
<a name="ln1823">          int f = 2 - FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln1824">          if(f == 1) continue;</a>
<a name="ln1825">          float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1826">          int c = (row - sgrow) % 3 ? TS : 1;</a>
<a name="ln1827">          int h = 3 * (c ^ TS ^ 1);</a>
<a name="ln1828">          for(int d = 0; d &lt; 4; d++, rfx += TS * TS)</a>
<a name="ln1829">          {</a>
<a name="ln1830">            int i = d &gt; 1 || ((d ^ c) &amp; 1)</a>
<a name="ln1831">                            || ((fabsf(rfx[0][1] - rfx[c][1]) + fabsf(rfx[0][1] - rfx[-c][1]))</a>
<a name="ln1832">                                &lt; 2.f * (fabsf(rfx[0][1] - rfx[h][1]) + fabsf(rfx[0][1] - rfx[-h][1]))) ? c : h;</a>
<a name="ln1833">            rfx[0][f] = (rfx[i][f] + rfx[-i][f] + 2.f * rfx[0][1] - rfx[i][1] - rfx[-i][1]) / 2.f;</a>
<a name="ln1834">          }</a>
<a name="ln1835">        }</a>
<a name="ln1836"> </a>
<a name="ln1837">      /* Fill in red and blue for 2x2 blocks of green:                */</a>
<a name="ln1838">      const int pad_g22 = 8;</a>
<a name="ln1839">      for(int row = top + pad_g22; row &lt; mrow - pad_g22; row++)</a>
<a name="ln1840">        if((row - sgrow) % 3)</a>
<a name="ln1841">          for(int col = left + pad_g22; col &lt; mcol - pad_g22; col++)</a>
<a name="ln1842">            if((col - sgcol) % 3)</a>
<a name="ln1843">            {</a>
<a name="ln1844">              float redblue[3][3];</a>
<a name="ln1845">              float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1846">              const short *const hex = hexmap(row, col, allhex);</a>
<a name="ln1847">              for(int d = 0; d &lt; ndir; d += 2, rfx += TS * TS)</a>
<a name="ln1848">                if(hex[d] + hex[d + 1])</a>
<a name="ln1849">                {</a>
<a name="ln1850">                  float g = 3.f * rfx[0][1] - 2.f * rfx[hex[d]][1] - rfx[hex[d + 1]][1];</a>
<a name="ln1851">                  for(int c = 0; c &lt; 4; c += 2)</a>
<a name="ln1852">                  {</a>
<a name="ln1853">                    rfx[0][c] = (g + 2.f * rfx[hex[d]][c] + rfx[hex[d + 1]][c]) / 3.f;</a>
<a name="ln1854">                    redblue[d][c] = rfx[0][c];</a>
<a name="ln1855">                  }</a>
<a name="ln1856">                }</a>
<a name="ln1857">                else</a>
<a name="ln1858">                {</a>
<a name="ln1859">                  float g = 2.f * rfx[0][1] - rfx[hex[d]][1] - rfx[hex[d + 1]][1];</a>
<a name="ln1860">                  for(int c = 0; c &lt; 4; c += 2)</a>
<a name="ln1861">                  {</a>
<a name="ln1862">                    rfx[0][c] = (g + rfx[hex[d]][c] + rfx[hex[d + 1]][c]) / 2.f;</a>
<a name="ln1863">                    redblue[d][c] = rfx[0][c];</a>
<a name="ln1864">                  }</a>
<a name="ln1865">                }</a>
<a name="ln1866">              // to fill in red and blue also for diagonal directions</a>
<a name="ln1867">              for(int d = 0; d &lt; ndir; d += 2, rfx += TS * TS)</a>
<a name="ln1868">                for(int c = 0; c &lt; 4; c += 2) rfx[0][c] = (redblue[0][c] + redblue[2][c]) * 0.5f;</a>
<a name="ln1869">           }</a>
<a name="ln1870"> </a>
<a name="ln1871">      // jump back to the first set of rgb buffers (this is a nop</a>
<a name="ln1872">      // unless on the second pass)</a>
<a name="ln1873">      rgb = (float(*)[TS][TS][3])buffer;</a>
<a name="ln1874">      // from here on out, mainly are working within the current tile</a>
<a name="ln1875">      // rather than in reference to the image, so don't offset</a>
<a name="ln1876">      // mrow/mcol by top/left of tile</a>
<a name="ln1877">      mrow -= top;</a>
<a name="ln1878">      mcol -= left;</a>
<a name="ln1879"> </a>
<a name="ln1880">      /* Convert to perceptual colorspace and differentiate in all directions:  */</a>
<a name="ln1881">      // Original dcraw algorithm uses CIELab as perceptual space</a>
<a name="ln1882">      // (presumably coming from original AHD) and converts taking</a>
<a name="ln1883">      // camera matrix into account. Now use YPbPr which requires much</a>
<a name="ln1884">      // less code and is nearly indistinguishable. It assumes the</a>
<a name="ln1885">      // camera RGB is roughly linear.</a>
<a name="ln1886">      for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1887">      {</a>
<a name="ln1888">        const int pad_yuv = 8;</a>
<a name="ln1889">        for(int row = pad_yuv; row &lt; mrow - pad_yuv; row++)</a>
<a name="ln1890">          for(int col = pad_yuv; col &lt; mcol - pad_yuv; col++)</a>
<a name="ln1891">          {</a>
<a name="ln1892">            float *rx = rgb[d][row][col];</a>
<a name="ln1893">            // use ITU-R BT.2020 YPbPr, which is great, but could use</a>
<a name="ln1894">            // a better/simpler choice? note that imageop.h provides</a>
<a name="ln1895">            // dt_iop_RGB_to_YCbCr which uses Rec. 601 conversion,</a>
<a name="ln1896">            // which appears less good with specular highlights</a>
<a name="ln1897">            float y = 0.2627f * rx[0] + 0.6780f * rx[1] + 0.0593f * rx[2];</a>
<a name="ln1898">            yuv[0][row][col] = y;</a>
<a name="ln1899">            yuv[1][row][col] = (rx[2] - y) * 0.56433f;</a>
<a name="ln1900">            yuv[2][row][col] = (rx[0] - y) * 0.67815f;</a>
<a name="ln1901">          }</a>
<a name="ln1902">        // Note that f can offset by a column (-1 or +1) and by a row</a>
<a name="ln1903">        // (-TS or TS). The row-wise offsets cause the undefined</a>
<a name="ln1904">        // behavior sanitizer to warn of an out of bounds index, but</a>
<a name="ln1905">        // as yfx is multi-dimensional and there is sufficient</a>
<a name="ln1906">        // padding, that is not actually so.</a>
<a name="ln1907">        const int f = dir[d &amp; 3];</a>
<a name="ln1908">        const int pad_drv = 9;</a>
<a name="ln1909">        for(int row = pad_drv; row &lt; mrow - pad_drv; row++)</a>
<a name="ln1910">          for(int col = pad_drv; col &lt; mcol - pad_drv; col++)</a>
<a name="ln1911">          {</a>
<a name="ln1912">            float(*yfx)[TS][TS] = (float(*)[TS][TS]) &amp; yuv[0][row][col];</a>
<a name="ln1913">            drv[d][row][col] = SQR(2 * yfx[0][0][0] - yfx[0][0][f] - yfx[0][0][-f])</a>
<a name="ln1914">                               + SQR(2 * yfx[1][0][0] - yfx[1][0][f] - yfx[1][0][-f])</a>
<a name="ln1915">                               + SQR(2 * yfx[2][0][0] - yfx[2][0][f] - yfx[2][0][-f]);</a>
<a name="ln1916">          }</a>
<a name="ln1917">      }</a>
<a name="ln1918"> </a>
<a name="ln1919">      /* Build homogeneity maps from the derivatives:                   */</a>
<a name="ln1920">      memset(homo, 0, (size_t)ndir * TS * TS * sizeof(uint8_t));</a>
<a name="ln1921">      const int pad_homo = 10;</a>
<a name="ln1922">      for(int row = pad_homo; row &lt; mrow - pad_homo; row++)</a>
<a name="ln1923">        for(int col = pad_homo; col &lt; mcol - pad_homo; col++)</a>
<a name="ln1924">        {</a>
<a name="ln1925">          float tr = FLT_MAX;</a>
<a name="ln1926">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1927">            if(tr &gt; drv[d][row][col]) tr = drv[d][row][col];</a>
<a name="ln1928">          tr *= 8;</a>
<a name="ln1929">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1930">            for(int v = -1; v &lt;= 1; v++)</a>
<a name="ln1931">              for(int h = -1; h &lt;= 1; h++) homo[d][row][col] += ((drv[d][row + v][col + h] &lt;= tr) ? 1 : 0);</a>
<a name="ln1932">        }</a>
<a name="ln1933"> </a>
<a name="ln1934">      /* Build 5x5 sum of homogeneity maps for each pixel &amp; direction */</a>
<a name="ln1935">      for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1936">        for(int row = pad_tile; row &lt; mrow - pad_tile; row++)</a>
<a name="ln1937">        {</a>
<a name="ln1938">          // start before first column where homo[d][row][col+2] != 0,</a>
<a name="ln1939">          // so can know v5sum and homosum[d][row][col] will be 0</a>
<a name="ln1940">          int col = pad_tile - 5;</a>
<a name="ln1941">          uint8_t v5sum[5] = { 0 };</a>
<a name="ln1942">          homosum[d][row][col] = 0;</a>
<a name="ln1943">          // calculate by rolling through column sums</a>
<a name="ln1944">          for(col++; col &lt; mcol - pad_tile; col++)</a>
<a name="ln1945">          {</a>
<a name="ln1946">            uint8_t colsum = 0;</a>
<a name="ln1947">            for(int v = -2; v &lt;= 2; v++) colsum += homo[d][row + v][col + 2];</a>
<a name="ln1948">            homosum[d][row][col] = homosum[d][row][col - 1] - v5sum[col % 5] + colsum;</a>
<a name="ln1949">            v5sum[col % 5] = colsum;</a>
<a name="ln1950">          }</a>
<a name="ln1951">        }</a>
<a name="ln1952"> </a>
<a name="ln1953">      /* Calculate chroma values in fdc:       */</a>
<a name="ln1954">      const int pad_fdc = 6;</a>
<a name="ln1955">      for(int row = pad_fdc; row &lt; mrow - pad_fdc; row++)</a>
<a name="ln1956">        for(int col = pad_fdc; col &lt; mcol - pad_fdc; col++)</a>
<a name="ln1957">        {</a>
<a name="ln1958">          int myrow, mycol;</a>
<a name="ln1959">          uint8_t hm[8] = { 0 };</a>
<a name="ln1960">          uint8_t maxval = 0;</a>
<a name="ln1961">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1962">          {</a>
<a name="ln1963">            hm[d] = homosum[d][row][col];</a>
<a name="ln1964">            maxval = (maxval &lt; hm[d] ? hm[d] : maxval);</a>
<a name="ln1965">          }</a>
<a name="ln1966">          maxval -= maxval &gt;&gt; 3;</a>
<a name="ln1967">          float dircount = 0;</a>
<a name="ln1968">          float dirsum = 0.f;</a>
<a name="ln1969">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1970">            if(hm[d] &gt;= maxval)</a>
<a name="ln1971">            {</a>
<a name="ln1972">              dircount++;</a>
<a name="ln1973">              dirsum += directionality[d];</a>
<a name="ln1974">            }</a>
<a name="ln1975">          float w = dirsum / (float)dircount;</a>
<a name="ln1976">          int fdc_row, fdc_col;</a>
<a name="ln1977">          float complex C2m, C5m, C7m, C10m;</a>
<a name="ln1978">#define CONV_FILT(VAR, FILT)                                                                                      \</a>
<a name="ln1979">  VAR = 0.0f + 0.0f * _Complex_I;                                                                                 \</a>
<a name="ln1980">  for(fdc_row = 0, myrow = row - 6; fdc_row &lt; 13; fdc_row++, myrow++)                                             \</a>
<a name="ln1981">    for(fdc_col = 0, mycol = col - 6; fdc_col &lt; 13; fdc_col++, mycol++)                                           \</a>
<a name="ln1982">      VAR += FILT[12 - fdc_row][12 - fdc_col] * *(i_src + TS * myrow + mycol);</a>
<a name="ln1983">          CONV_FILT(C2m, harr[0])</a>
<a name="ln1984">          CONV_FILT(C5m, harr[1])</a>
<a name="ln1985">          CONV_FILT(C7m, harr[2])</a>
<a name="ln1986">          CONV_FILT(C10m, harr[3])</a>
<a name="ln1987">#undef CONV_FILT</a>
<a name="ln1988">          // build the q vector components</a>
<a name="ln1989">          myrow = (row + rowoffset) % 6;</a>
<a name="ln1990">          mycol = (col + coloffset) % 6;</a>
<a name="ln1991">          float complex modulator[8];</a>
<a name="ln1992">          for(int c = 0; c &lt; 8; c++) modulator[c] = modarr[myrow][mycol][c];</a>
<a name="ln1993">          float complex qmat[8];</a>
<a name="ln1994">          qmat[4] = w * C10m * modulator[0] - (1.0f - w) * C2m * modulator[1];</a>
<a name="ln1995">          qmat[6] = conjf(qmat[4]);</a>
<a name="ln1996">          qmat[1] = C5m * modulator[6];</a>
<a name="ln1997">          qmat[2] = conjf(-0.5f * qmat[1]);</a>
<a name="ln1998">          qmat[5] = conjf(qmat[2]);</a>
<a name="ln1999">          qmat[3] = C7m * modulator[7];</a>
<a name="ln2000">          qmat[7] = conjf(qmat[1]);</a>
<a name="ln2001">          // get L</a>
<a name="ln2002">          C2m = qmat[4] * (conjf(modulator[0]) - conjf(modulator[1]));</a>
<a name="ln2003">          float complex C3m = qmat[6] * (modulator[2] - modulator[3]);</a>
<a name="ln2004">          float complex C6m = qmat[2] * (conjf(modulator[4]) + conjf(modulator[5]));</a>
<a name="ln2005">          float complex C12m = qmat[5] * (modulator[4] + modulator[5]);</a>
<a name="ln2006">          float complex C18m = qmat[7] * modulator[6];</a>
<a name="ln2007">          qmat[0] = *(i_src + row * TS + col) - C2m - C3m - C5m - C6m - 2.0f * C7m - C12m - C18m;</a>
<a name="ln2008">          // get the rgb components from fdc</a>
<a name="ln2009">          float rgbpix[3] = { 0.f, 0.f, 0.f };</a>
<a name="ln2010">          // multiply with the inverse matrix of M</a>
<a name="ln2011">          for(int color = 0; color &lt; 3; color++)</a>
<a name="ln2012">            for(int c = 0; c &lt; 8; c++)</a>
<a name="ln2013">            {</a>
<a name="ln2014">              rgbpix[color] += Minv[color][c] * qmat[c];</a>
<a name="ln2015">            }</a>
<a name="ln2016">          // now separate luma and chroma for</a>
<a name="ln2017">          // frequency domain chroma</a>
<a name="ln2018">          // and store it in fdc_chroma</a>
<a name="ln2019">          float uv[2];</a>
<a name="ln2020">          float y = 0.2627f * rgbpix[0] + 0.6780f * rgbpix[1] + 0.0593f * rgbpix[2];</a>
<a name="ln2021">          uv[0] = (rgbpix[2] - y) * 0.56433f;</a>
<a name="ln2022">          uv[1] = (rgbpix[0] - y) * 0.67815f;</a>
<a name="ln2023">          for(int c = 0; c &lt; 2; c++) *(fdc_chroma + c * TS * TS + row * TS + col) = uv[c];</a>
<a name="ln2024">        }</a>
<a name="ln2025"> </a>
<a name="ln2026">      /* Average the most homogenous pixels for the final result:       */</a>
<a name="ln2027">      for(int row = pad_tile; row &lt; mrow - pad_tile; row++)</a>
<a name="ln2028">        for(int col = pad_tile; col &lt; mcol - pad_tile; col++)</a>
<a name="ln2029">        {</a>
<a name="ln2030">          uint8_t hm[8] = { 0 };</a>
<a name="ln2031">          uint8_t maxval = 0;</a>
<a name="ln2032">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln2033">          {</a>
<a name="ln2034">            hm[d] = homosum[d][row][col];</a>
<a name="ln2035">            maxval = (maxval &lt; hm[d] ? hm[d] : maxval);</a>
<a name="ln2036">          }</a>
<a name="ln2037">          maxval -= maxval &gt;&gt; 3;</a>
<a name="ln2038">          for(int d = 0; d &lt; ndir - 4; d++)</a>
<a name="ln2039">            if(hm[d] &lt; hm[d + 4])</a>
<a name="ln2040">              hm[d] = 0;</a>
<a name="ln2041">            else if(hm[d] &gt; hm[d + 4])</a>
<a name="ln2042">              hm[d + 4] = 0;</a>
<a name="ln2043">          float avg[4] = { 0.f };</a>
<a name="ln2044">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln2045">            if(hm[d] &gt;= maxval)</a>
<a name="ln2046">            {</a>
<a name="ln2047">              for(int c = 0; c &lt; 3; c++) avg[c] += rgb[d][row][col][c];</a>
<a name="ln2048">              avg[3]++;</a>
<a name="ln2049">            }</a>
<a name="ln2050">          float rgbpix[3];</a>
<a name="ln2051">          for(int c = 0; c &lt; 3; c++) rgbpix[c] = avg[c] / avg[3];</a>
<a name="ln2052">          // preserve all components of Markesteijn for this pixel</a>
<a name="ln2053">          float y = 0.2627f * rgbpix[0] + 0.6780f * rgbpix[1] + 0.0593f * rgbpix[2];</a>
<a name="ln2054">          float um = (rgbpix[2] - y) * 0.56433f;</a>
<a name="ln2055">          float vm = (rgbpix[0] - y) * 0.67815f;</a>
<a name="ln2056">          float uvf[2];</a>
<a name="ln2057">          // macros for fast meadian filtering</a>
<a name="ln2058">#define PIX_SWAP(a, b)                                                                                            \</a>
<a name="ln2059">  {                                                                                                               \</a>
<a name="ln2060">    tempf = (a);                                                                                                  \</a>
<a name="ln2061">    (a) = (b);                                                                                                    \</a>
<a name="ln2062">    (b) = tempf;                                                                                                  \</a>
<a name="ln2063">  }</a>
<a name="ln2064">#define PIX_SORT(a, b)                                                                                            \</a>
<a name="ln2065">  {                                                                                                               \</a>
<a name="ln2066">    if((a) &gt; (b)) PIX_SWAP((a), (b));                                                                             \</a>
<a name="ln2067">  }</a>
<a name="ln2068">          // instead of merely reading the values, perform 5 pixel median filter</a>
<a name="ln2069">          // one median filter is required to avoid textile artifacts</a>
<a name="ln2070">          for(int chrm = 0; chrm &lt; 2; chrm++)</a>
<a name="ln2071">          {</a>
<a name="ln2072">            float temp[5];</a>
<a name="ln2073">            float tempf;</a>
<a name="ln2074">            // load the window into temp</a>
<a name="ln2075">            memcpy(&amp;temp[0], fdc_chroma + chrm * TS * TS + (row - 1) * TS + (col), 1 * sizeof(float));</a>
<a name="ln2076">            memcpy(&amp;temp[1], fdc_chroma + chrm * TS * TS + (row)*TS + (col - 1), 3 * sizeof(float));</a>
<a name="ln2077">            memcpy(&amp;temp[4], fdc_chroma + chrm * TS * TS + (row + 1) * TS + (col), 1 * sizeof(float));</a>
<a name="ln2078">            PIX_SORT(temp[0], temp[1]);</a>
<a name="ln2079">            PIX_SORT(temp[3], temp[4]);</a>
<a name="ln2080">            PIX_SORT(temp[0], temp[3]);</a>
<a name="ln2081">            PIX_SORT(temp[1], temp[4]);</a>
<a name="ln2082">            PIX_SORT(temp[1], temp[2]);</a>
<a name="ln2083">            PIX_SORT(temp[2], temp[3]);</a>
<a name="ln2084">            PIX_SORT(temp[1], temp[2]);</a>
<a name="ln2085">            uvf[chrm] = temp[2];</a>
<a name="ln2086">          }</a>
<a name="ln2087">          // use hybrid or pure fdc, depending on what was set above.</a>
<a name="ln2088">          // in case of hybrid, use the chroma that has the smallest</a>
<a name="ln2089">          // absolute value</a>
<a name="ln2090">          float uv[2];</a>
<a name="ln2091">          uv[0] = (((ABS(uvf[0]) &lt; ABS(um)) &amp; (ABS(uvf[1]) &lt; (1.02f * ABS(vm)))) ? uvf[0] : um) * hybrid_fdc[0] + uvf[0] * hybrid_fdc[1];</a>
<a name="ln2092">          uv[1] = (((ABS(uvf[1]) &lt; ABS(vm)) &amp; (ABS(uvf[0]) &lt; (1.02f * ABS(vm)))) ? uvf[1] : vm) * hybrid_fdc[0] + uvf[1] * hybrid_fdc[1];</a>
<a name="ln2093">          // combine the luma from Markesteijn with the chroma from above</a>
<a name="ln2094">          rgbpix[0] = y + 1.474600014746f * uv[1];</a>
<a name="ln2095">          rgbpix[1] = y - 0.15498578286403f * uv[0] - 0.571353132557189f * uv[1];</a>
<a name="ln2096">          rgbpix[2] = y + 1.77201282937288f * uv[0];</a>
<a name="ln2097">          for(int c = 0; c &lt; 3; c++) out[4 * (width * (row + top) + col + left) + c] = rgbpix[c];</a>
<a name="ln2098">        }</a>
<a name="ln2099">    }</a>
<a name="ln2100">  }</a>
<a name="ln2101">  dt_free_align(all_buffers);</a>
<a name="ln2102">}</a>
<a name="ln2103"> </a>
<a name="ln2104">#undef PIX_SWAP</a>
<a name="ln2105">#undef PIX_SORT</a>
<a name="ln2106">#undef CCLIP</a>
<a name="ln2107">#undef TS</a>
<a name="ln2108"> </a>
<a name="ln2109">/* taken from dcraw and demosaic_ppg below */</a>
<a name="ln2110"> </a>
<a name="ln2111">static void lin_interpolate(float *out, const float *const in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln2112">                            const dt_iop_roi_t *const roi_in, const uint32_t filters,</a>
<a name="ln2113">                            const uint8_t (*const xtrans)[6])</a>
<a name="ln2114">{</a>
<a name="ln2115">  const int colors = (filters == 9) ? 3 : 4;</a>
<a name="ln2116"> </a>
<a name="ln2117">// border interpolate</a>
<a name="ln2118">#ifdef _OPENMP</a>
<a name="ln2119">#pragma omp parallel for default(none) shared(out) schedule(static)</a>
<a name="ln2120">#endif</a>
<a name="ln2121">  for(int row = 0; row &lt; roi_out-&gt;height; row++)</a>
<a name="ln2122">    for(int col = 0; col &lt; roi_out-&gt;width; col++)</a>
<a name="ln2123">    {</a>
<a name="ln2124">      float sum[4] = { 0.0f };</a>
<a name="ln2125">      uint8_t count[4] = { 0 };</a>
<a name="ln2126">      if(col == 1 &amp;&amp; row &gt;= 1 &amp;&amp; row &lt; roi_out-&gt;height - 1) col = roi_out-&gt;width - 1;</a>
<a name="ln2127">      // average all the adjoining pixels inside image by color</a>
<a name="ln2128">      for(int y = row - 1; y != row + 2; y++)</a>
<a name="ln2129">        for(int x = col - 1; x != col + 2; x++)</a>
<a name="ln2130">          if(y &gt;= 0 &amp;&amp; x &gt;= 0 &amp;&amp; y &lt; roi_in-&gt;height &amp;&amp; x &lt; roi_in-&gt;width)</a>
<a name="ln2131">          {</a>
<a name="ln2132">            const int f = fcol(y + roi_in-&gt;y, x + roi_in-&gt;x, filters, xtrans);</a>
<a name="ln2133">            sum[f] += in[y * roi_in-&gt;width + x];</a>
<a name="ln2134">            count[f]++;</a>
<a name="ln2135">          }</a>
<a name="ln2136">      const int f = fcol(row + roi_in-&gt;y, col + roi_in-&gt;x, filters, xtrans);</a>
<a name="ln2137">      // for current cell, copy the current sensor's color data,</a>
<a name="ln2138">      // interpolate the other two colors from surrounding pixels of</a>
<a name="ln2139">      // their color</a>
<a name="ln2140">      for(int c = 0; c &lt; colors; c++)</a>
<a name="ln2141">      {</a>
<a name="ln2142">        if(c != f &amp;&amp; count[c] != 0)</a>
<a name="ln2143">          out[4 * (row * roi_out-&gt;width + col) + c] = sum[c] / count[c];</a>
<a name="ln2144">        else</a>
<a name="ln2145">          out[4 * (row * roi_out-&gt;width + col) + c] = in[row * roi_in-&gt;width + col];</a>
<a name="ln2146">      }</a>
<a name="ln2147">    }</a>
<a name="ln2148"> </a>
<a name="ln2149">  // build interpolation lookup table which for a given offset in the sensor</a>
<a name="ln2150">  // lists neighboring pixels from which to interpolate:</a>
<a name="ln2151">  // NUM_PIXELS                 # of neighboring pixels to read</a>
<a name="ln2152">  // for (1..NUM_PIXELS):</a>
<a name="ln2153">  //   OFFSET                   # in bytes from current pixel</a>
<a name="ln2154">  //   WEIGHT                   # how much weight to give this neighbor</a>
<a name="ln2155">  //   COLOR                    # sensor color</a>
<a name="ln2156">  // # weights of adjoining pixels not of this pixel's color</a>
<a name="ln2157">  // COLORA TOT_WEIGHT</a>
<a name="ln2158">  // COLORB TOT_WEIGHT</a>
<a name="ln2159">  // COLORPIX                   # color of center pixel</a>
<a name="ln2160"> </a>
<a name="ln2161">  int(*const lookup)[16][32] = malloc((size_t)16 * 16 * 32 * sizeof(int));</a>
<a name="ln2162"> </a>
<a name="ln2163">  const int size = (filters == 9) ? 6 : 16;</a>
<a name="ln2164">  for(int row = 0; row &lt; size; row++)</a>
<a name="ln2165">    for(int col = 0; col &lt; size; col++)</a>
<a name="ln2166">    {</a>
<a name="ln2167">      int *ip = lookup[row][col] + 1;</a>
<a name="ln2168">      int sum[4] = { 0 };</a>
<a name="ln2169">      const int f = fcol(row + roi_in-&gt;y, col + roi_in-&gt;x, filters, xtrans);</a>
<a name="ln2170">      // make list of adjoining pixel offsets by weight &amp; color</a>
<a name="ln2171">      for(int y = -1; y &lt;= 1; y++)</a>
<a name="ln2172">        for(int x = -1; x &lt;= 1; x++)</a>
<a name="ln2173">        {</a>
<a name="ln2174">          int weight = 1 &lt;&lt; ((y == 0) + (x == 0));</a>
<a name="ln2175">          const int color = fcol(row + y + roi_in-&gt;y, col + x + roi_in-&gt;x, filters, xtrans);</a>
<a name="ln2176">          if(color == f) continue;</a>
<a name="ln2177">          *ip++ = (roi_in-&gt;width * y + x);</a>
<a name="ln2178">          *ip++ = weight;</a>
<a name="ln2179">          *ip++ = color;</a>
<a name="ln2180">          sum[color] += weight;</a>
<a name="ln2181">        }</a>
<a name="ln2182">      lookup[row][col][0] = (ip - lookup[row][col]) / 3; /* # of neighboring pixels found */</a>
<a name="ln2183">      for(int c = 0; c &lt; colors; c++)</a>
<a name="ln2184">        if(c != f)</a>
<a name="ln2185">        {</a>
<a name="ln2186">          *ip++ = c;</a>
<a name="ln2187">          *ip++ = sum[c];</a>
<a name="ln2188">        }</a>
<a name="ln2189">      *ip = f;</a>
<a name="ln2190">    }</a>
<a name="ln2191"> </a>
<a name="ln2192">#ifdef _OPENMP</a>
<a name="ln2193">#pragma omp parallel for default(none) shared(out) schedule(static)</a>
<a name="ln2194">#endif</a>
<a name="ln2195">  for(int row = 1; row &lt; roi_out-&gt;height - 1; row++)</a>
<a name="ln2196">  {</a>
<a name="ln2197">    float *buf = out + 4 * roi_out-&gt;width * row + 4;</a>
<a name="ln2198">    const float *buf_in = in + roi_in-&gt;width * row + 1;</a>
<a name="ln2199">    for(int col = 1; col &lt; roi_out-&gt;width - 1; col++)</a>
<a name="ln2200">    {</a>
<a name="ln2201">      float sum[4] = { 0.0f };</a>
<a name="ln2202">      int *ip = lookup[row % size][col % size];</a>
<a name="ln2203">      // for each adjoining pixel not of this pixel's color, sum up its weighted values</a>
<a name="ln2204">      for(int i = *ip++; i--; ip += 3) sum[ip[2]] += buf_in[ip[0]] * ip[1];</a>
<a name="ln2205">      // for each interpolated color, load it into the pixel</a>
<a name="ln2206">      for(int i = colors; --i; ip += 2) buf[*ip] = sum[ip[0]] / ip[1];</a>
<a name="ln2207">      buf[*ip] = *buf_in;</a>
<a name="ln2208">      buf += 4;</a>
<a name="ln2209">      buf_in++;</a>
<a name="ln2210">    }</a>
<a name="ln2211">  }</a>
<a name="ln2212"> </a>
<a name="ln2213">  free(lookup);</a>
<a name="ln2214">}</a>
<a name="ln2215"> </a>
<a name="ln2216"> </a>
<a name="ln2217">// VNG interpolate adapted from dcraw 9.20</a>
<a name="ln2218"> </a>
<a name="ln2219">/*</a>
<a name="ln2220">   This algorithm is officially called:</a>
<a name="ln2221"> </a>
<a name="ln2222">   &quot;Interpolation using a Threshold-based variable number of gradients&quot;</a>
<a name="ln2223"> </a>
<a name="ln2224">   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html</a>
<a name="ln2225"> </a>
<a name="ln2226">   I've extended the basic idea to work with non-Bayer filter arrays.</a>
<a name="ln2227">   Gradients are numbered clockwise from NW=0 to W=7.</a>
<a name="ln2228"> */</a>
<a name="ln2229">static void vng_interpolate(float *out, const float *const in,</a>
<a name="ln2230">                            const dt_iop_roi_t *const roi_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln2231">                            const uint32_t filters, const uint8_t (*const xtrans)[6], const int only_vng_linear)</a>
<a name="ln2232">{</a>
<a name="ln2233">  static const signed char terms[]</a>
<a name="ln2234">      = { -2, -2, +0, -1, 1, 0x01, -2, -2, +0, +0, 2, 0x01, -2, -1, -1, +0, 1, 0x01, -2, -1, +0, -1, 1, 0x02,</a>
<a name="ln2235">          -2, -1, +0, +0, 1, 0x03, -2, -1, +0, +1, 2, 0x01, -2, +0, +0, -1, 1, 0x06, -2, +0, +0, +0, 2, 0x02,</a>
<a name="ln2236">          -2, +0, +0, +1, 1, 0x03, -2, +1, -1, +0, 1, 0x04, -2, +1, +0, -1, 2, 0x04, -2, +1, +0, +0, 1, 0x06,</a>
<a name="ln2237">          -2, +1, +0, +1, 1, 0x02, -2, +2, +0, +0, 2, 0x04, -2, +2, +0, +1, 1, 0x04, -1, -2, -1, +0, 1, 0x80,</a>
<a name="ln2238">          -1, -2, +0, -1, 1, 0x01, -1, -2, +1, -1, 1, 0x01, -1, -2, +1, +0, 2, 0x01, -1, -1, -1, +1, 1, 0x88,</a>
<a name="ln2239">          -1, -1, +1, -2, 1, 0x40, -1, -1, +1, -1, 1, 0x22, -1, -1, +1, +0, 1, 0x33, -1, -1, +1, +1, 2, 0x11,</a>
<a name="ln2240">          -1, +0, -1, +2, 1, 0x08, -1, +0, +0, -1, 1, 0x44, -1, +0, +0, +1, 1, 0x11, -1, +0, +1, -2, 2, 0x40,</a>
<a name="ln2241">          -1, +0, +1, -1, 1, 0x66, -1, +0, +1, +0, 2, 0x22, -1, +0, +1, +1, 1, 0x33, -1, +0, +1, +2, 2, 0x10,</a>
<a name="ln2242">          -1, +1, +1, -1, 2, 0x44, -1, +1, +1, +0, 1, 0x66, -1, +1, +1, +1, 1, 0x22, -1, +1, +1, +2, 1, 0x10,</a>
<a name="ln2243">          -1, +2, +0, +1, 1, 0x04, -1, +2, +1, +0, 2, 0x04, -1, +2, +1, +1, 1, 0x04, +0, -2, +0, +0, 2, 0x80,</a>
<a name="ln2244">          +0, -1, +0, +1, 2, 0x88, +0, -1, +1, -2, 1, 0x40, +0, -1, +1, +0, 1, 0x11, +0, -1, +2, -2, 1, 0x40,</a>
<a name="ln2245">          +0, -1, +2, -1, 1, 0x20, +0, -1, +2, +0, 1, 0x30, +0, -1, +2, +1, 2, 0x10, +0, +0, +0, +2, 2, 0x08,</a>
<a name="ln2246">          +0, +0, +2, -2, 2, 0x40, +0, +0, +2, -1, 1, 0x60, +0, +0, +2, +0, 2, 0x20, +0, +0, +2, +1, 1, 0x30,</a>
<a name="ln2247">          +0, +0, +2, +2, 2, 0x10, +0, +1, +1, +0, 1, 0x44, +0, +1, +1, +2, 1, 0x10, +0, +1, +2, -1, 2, 0x40,</a>
<a name="ln2248">          +0, +1, +2, +0, 1, 0x60, +0, +1, +2, +1, 1, 0x20, +0, +1, +2, +2, 1, 0x10, +1, -2, +1, +0, 1, 0x80,</a>
<a name="ln2249">          +1, -1, +1, +1, 1, 0x88, +1, +0, +1, +2, 1, 0x08, +1, +0, +2, -1, 1, 0x40, +1, +0, +2, +1, 1, 0x10 },</a>
<a name="ln2250">      chood[] = { -1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1 };</a>
<a name="ln2251">  int *ip, *code[16][16];</a>
<a name="ln2252">  // ring buffer pointing to three most recent rows processed (brow[3]</a>
<a name="ln2253">  // is only used for rotating the buffer</a>
<a name="ln2254">  float(*brow[4])[4];</a>
<a name="ln2255">  const int width = roi_out-&gt;width, height = roi_out-&gt;height;</a>
<a name="ln2256">  const int prow = (filters == 9) ? 6 : 8;</a>
<a name="ln2257">  const int pcol = (filters == 9) ? 6 : 2;</a>
<a name="ln2258">  const int colors = (filters == 9) ? 3 : 4;</a>
<a name="ln2259"> </a>
<a name="ln2260">  // separate out G1 and G2 in RGGB Bayer patterns</a>
<a name="ln2261">  uint32_t filters4 = filters;</a>
<a name="ln2262">  if(filters == 9 || FILTERS_ARE_4BAYER(filters)) // x-trans or CYGM/RGBE</a>
<a name="ln2263">    filters4 = filters;</a>
<a name="ln2264">  else if((filters &amp; 3) == 1)</a>
<a name="ln2265">    filters4 = filters | 0x03030303u;</a>
<a name="ln2266">  else</a>
<a name="ln2267">    filters4 = filters | 0x0c0c0c0cu;</a>
<a name="ln2268"> </a>
<a name="ln2269">  lin_interpolate(out, in, roi_out, roi_in, filters4, xtrans);</a>
<a name="ln2270"> </a>
<a name="ln2271">  // if only linear interpolation is requested we can stop it here</a>
<a name="ln2272">  if(only_vng_linear) return;</a>
<a name="ln2273"> </a>
<a name="ln2274">  char *buffer</a>
<a name="ln2275">      = (char *)dt_alloc_align(64, (size_t)sizeof(**brow) * width * 3 + sizeof(*ip) * prow * pcol * 320);</a>
<a name="ln2276">  if(!buffer)</a>
<a name="ln2277">  {</a>
<a name="ln2278">    fprintf(stderr, &quot;[demosaic] not able to allocate VNG buffer\n&quot;);</a>
<a name="ln2279">    return;</a>
<a name="ln2280">  }</a>
<a name="ln2281">  for(int row = 0; row &lt; 3; row++) brow[row] = (float(*)[4])buffer + row * width;</a>
<a name="ln2282">  ip = (int *)(buffer + (size_t)sizeof(**brow) * width * 3);</a>
<a name="ln2283"> </a>
<a name="ln2284">  for(int row = 0; row &lt; prow; row++) /* Precalculate for VNG */</a>
<a name="ln2285">    for(int col = 0; col &lt; pcol; col++)</a>
<a name="ln2286">    {</a>
<a name="ln2287">      code[row][col] = ip;</a>
<a name="ln2288">      const signed char *cp = terms;</a>
<a name="ln2289">      for(int t = 0; t &lt; 64; t++)</a>
<a name="ln2290">      {</a>
<a name="ln2291">        int y1 = *cp++, x1 = *cp++;</a>
<a name="ln2292">        int y2 = *cp++, x2 = *cp++;</a>
<a name="ln2293">        int weight = *cp++;</a>
<a name="ln2294">        int grads = *cp++;</a>
<a name="ln2295">        int color = fcol(row + y1, col + x1, filters4, xtrans);</a>
<a name="ln2296">        if(fcol(row + y2, col + x2, filters4, xtrans) != color) continue;</a>
<a name="ln2297">        int diag</a>
<a name="ln2298">            = (fcol(row, col + 1, filters4, xtrans) == color &amp;&amp; fcol(row + 1, col, filters4, xtrans) == color)</a>
<a name="ln2299">                  ? 2</a>
<a name="ln2300">                  : 1;</a>
<a name="ln2301">        if(abs(y1 - y2) == diag &amp;&amp; abs(x1 - x2) == diag) continue;</a>
<a name="ln2302">        *ip++ = (y1 * width + x1) * 4 + color;</a>
<a name="ln2303">        *ip++ = (y2 * width + x2) * 4 + color;</a>
<a name="ln2304">        *ip++ = weight;</a>
<a name="ln2305">        for(int g = 0; g &lt; 8; g++)</a>
<a name="ln2306">          if(grads &amp; 1 &lt;&lt; g) *ip++ = g;</a>
<a name="ln2307">        *ip++ = -1;</a>
<a name="ln2308">      }</a>
<a name="ln2309">      *ip++ = INT_MAX;</a>
<a name="ln2310">      cp = chood;</a>
<a name="ln2311">      for(int g = 0; g &lt; 8; g++)</a>
<a name="ln2312">      {</a>
<a name="ln2313">        int y = *cp++, x = *cp++;</a>
<a name="ln2314">        *ip++ = (y * width + x) * 4;</a>
<a name="ln2315">        int color = fcol(row, col, filters4, xtrans);</a>
<a name="ln2316">        if(fcol(row + y, col + x, filters4, xtrans) != color</a>
<a name="ln2317">           &amp;&amp; fcol(row + y * 2, col + x * 2, filters4, xtrans) == color)</a>
<a name="ln2318">          *ip++ = (y * width + x) * 8 + color;</a>
<a name="ln2319">        else</a>
<a name="ln2320">          *ip++ = 0;</a>
<a name="ln2321">      }</a>
<a name="ln2322">    }</a>
<a name="ln2323"> </a>
<a name="ln2324">  for(int row = 2; row &lt; height - 2; row++) /* Do VNG interpolation */</a>
<a name="ln2325">  {</a>
<a name="ln2326">#ifdef _OPENMP</a>
<a name="ln2327">#pragma omp parallel for default(none) shared(row, code, brow, out, filters4) private(ip) schedule(static)</a>
<a name="ln2328">#endif</a>
<a name="ln2329">    for(int col = 2; col &lt; width - 2; col++)</a>
<a name="ln2330">    {</a>
<a name="ln2331">      int g;</a>
<a name="ln2332">      float gval[8] = { 0.0f };</a>
<a name="ln2333">      float *pix = out + 4 * (row * width + col);</a>
<a name="ln2334">      ip = code[(row + roi_in-&gt;y) % prow][(col + roi_in-&gt;x) % pcol];</a>
<a name="ln2335">      while((g = ip[0]) != INT_MAX) /* Calculate gradients */</a>
<a name="ln2336">      {</a>
<a name="ln2337">        float diff = fabsf(pix[g] - pix[ip[1]]) * ip[2];</a>
<a name="ln2338">        gval[ip[3]] += diff;</a>
<a name="ln2339">        ip += 5;</a>
<a name="ln2340">        if((g = ip[-1]) == -1) continue;</a>
<a name="ln2341">        gval[g] += diff;</a>
<a name="ln2342">        while((g = *ip++) != -1) gval[g] += diff;</a>
<a name="ln2343">      }</a>
<a name="ln2344">      ip++;</a>
<a name="ln2345">      float gmin = gval[0], gmax = gval[0]; /* Choose a threshold */</a>
<a name="ln2346">      for(g = 1; g &lt; 8; g++)</a>
<a name="ln2347">      {</a>
<a name="ln2348">        if(gmin &gt; gval[g]) gmin = gval[g];</a>
<a name="ln2349">        if(gmax &lt; gval[g]) gmax = gval[g];</a>
<a name="ln2350">      }</a>
<a name="ln2351">      if(gmax == 0)</a>
<a name="ln2352">      {</a>
<a name="ln2353">        memcpy(brow[2][col], pix, (size_t)4 * sizeof(*out));</a>
<a name="ln2354">        continue;</a>
<a name="ln2355">      }</a>
<a name="ln2356">      float thold = gmin + (gmax * 0.5f);</a>
<a name="ln2357">      float sum[4] = { 0.0f };</a>
<a name="ln2358">      int color = fcol(row + roi_in-&gt;y, col + roi_in-&gt;x, filters4, xtrans);</a>
<a name="ln2359">      int num = 0;</a>
<a name="ln2360">      for(g = 0; g &lt; 8; g++, ip += 2) /* Average the neighbors */</a>
<a name="ln2361">      {</a>
<a name="ln2362">        if(gval[g] &lt;= thold)</a>
<a name="ln2363">        {</a>
<a name="ln2364">          for(int c = 0; c &lt; colors; c++)</a>
<a name="ln2365">            if(c == color &amp;&amp; ip[1])</a>
<a name="ln2366">              sum[c] += (pix[c] + pix[ip[1]]) * 0.5f;</a>
<a name="ln2367">            else</a>
<a name="ln2368">              sum[c] += pix[ip[0] + c];</a>
<a name="ln2369">          num++;</a>
<a name="ln2370">        }</a>
<a name="ln2371">      }</a>
<a name="ln2372">      for(int c = 0; c &lt; colors; c++) /* Save to buffer */</a>
<a name="ln2373">      {</a>
<a name="ln2374">        float tot = pix[color];</a>
<a name="ln2375">        if(c != color) tot += (sum[c] - sum[color]) / num;</a>
<a name="ln2376">        brow[2][col][c] = tot;</a>
<a name="ln2377">      }</a>
<a name="ln2378">    }</a>
<a name="ln2379">    if(row &gt; 3) /* Write buffer to image */</a>
<a name="ln2380">      memcpy(out + 4 * ((row - 2) * width + 2), brow[0] + 2, (size_t)(width - 4) * 4 * sizeof(*out));</a>
<a name="ln2381">    // rotate ring buffer</a>
<a name="ln2382">    for(int g = 0; g &lt; 4; g++) brow[(g - 1) &amp; 3] = brow[g];</a>
<a name="ln2383">  }</a>
<a name="ln2384">  // copy the final two rows to the image</a>
<a name="ln2385">  memcpy(out + (4 * ((height - 4) * width + 2)), brow[0] + 2, (size_t)(width - 4) * 4 * sizeof(*out));</a>
<a name="ln2386">  memcpy(out + (4 * ((height - 3) * width + 2)), brow[1] + 2, (size_t)(width - 4) * 4 * sizeof(*out));</a>
<a name="ln2387">  dt_free_align(buffer);</a>
<a name="ln2388"> </a>
<a name="ln2389">  if(filters != 9 &amp;&amp; !FILTERS_ARE_4BAYER(filters)) // x-trans or CYGM/RGBE</a>
<a name="ln2390">// for Bayer mix the two greens to make VNG4</a>
<a name="ln2391">#ifdef _OPENMP</a>
<a name="ln2392">#pragma omp parallel for default(none) shared(out) schedule(static)</a>
<a name="ln2393">#endif</a>
<a name="ln2394">    for(int i = 0; i &lt; height * width; i++) out[i * 4 + 1] = (out[i * 4 + 1] + out[i * 4 + 3]) / 2.0f;</a>
<a name="ln2395">}</a>
<a name="ln2396"> </a>
<a name="ln2397">/** 1:1 demosaic from in to out, in is full buf, out is translated/cropped (scale == 1.0!) */</a>
<a name="ln2398">static void passthrough_monochrome(float *out, const float *const in, dt_iop_roi_t *const roi_out,</a>
<a name="ln2399">                                   const dt_iop_roi_t *const roi_in)</a>
<a name="ln2400">{</a>
<a name="ln2401">  // we never want to access the input out of bounds though:</a>
<a name="ln2402">  assert(roi_in-&gt;width &gt;= roi_out-&gt;width);</a>
<a name="ln2403">  assert(roi_in-&gt;height &gt;= roi_out-&gt;height);</a>
<a name="ln2404"> </a>
<a name="ln2405">#ifdef _OPENMP</a>
<a name="ln2406">#pragma omp parallel for default(none) shared(out) schedule(static)</a>
<a name="ln2407">#endif</a>
<a name="ln2408">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln2409">  {</a>
<a name="ln2410">    for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln2411">    {</a>
<a name="ln2412">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2413">      {</a>
<a name="ln2414">        out[(size_t)4 * ((size_t)j * roi_out-&gt;width + i) + c]</a>
<a name="ln2415">            = in[(size_t)((size_t)j + roi_out-&gt;y) * roi_in-&gt;width + i + roi_out-&gt;x];</a>
<a name="ln2416">      }</a>
<a name="ln2417">    }</a>
<a name="ln2418">  }</a>
<a name="ln2419">}</a>
<a name="ln2420"> </a>
<a name="ln2421">/** 1:1 demosaic from in to out, in is full buf, out is translated/cropped (scale == 1.0!) */</a>
<a name="ln2422">static void demosaic_ppg(float *const out, const float *const in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln2423">                         const dt_iop_roi_t *const roi_in, const uint32_t filters, const float thrs)</a>
<a name="ln2424">{</a>
<a name="ln2425">  // offsets only where the buffer ends:</a>
<a name="ln2426">  const int offx = 3; // MAX(0, 3 - roi_out-&gt;x);</a>
<a name="ln2427">  const int offy = 3; // MAX(0, 3 - roi_out-&gt;y);</a>
<a name="ln2428">  const int offX = 3; // MAX(0, 3 - (roi_in-&gt;width  - (roi_out-&gt;x + roi_out-&gt;width)));</a>
<a name="ln2429">  const int offY = 3; // MAX(0, 3 - (roi_in-&gt;height - (roi_out-&gt;y + roi_out-&gt;height)));</a>
<a name="ln2430"> </a>
<a name="ln2431">  // these may differ a little, if you're unlucky enough to split a bayer block with cropping or similar.</a>
<a name="ln2432">  // we never want to access the input out of bounds though:</a>
<a name="ln2433">  assert(roi_in-&gt;width &gt;= roi_out-&gt;width);</a>
<a name="ln2434">  assert(roi_in-&gt;height &gt;= roi_out-&gt;height);</a>
<a name="ln2435">  // border interpolate</a>
<a name="ln2436">  float sum[8];</a>
<a name="ln2437">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln2438">    for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln2439">    {</a>
<a name="ln2440">      if(i == offx &amp;&amp; j &gt;= offy &amp;&amp; j &lt; roi_out-&gt;height - offY) i = roi_out-&gt;width - offX;</a>
<a name="ln2441">      if(i == roi_out-&gt;width) break;</a>
<a name="ln2442">      memset(sum, 0, sizeof(float) * 8);</a>
<a name="ln2443">      for(int y = j - 1; y != j + 2; y++)</a>
<a name="ln2444">        for(int x = i - 1; x != i + 2; x++)</a>
<a name="ln2445">        {</a>
<a name="ln2446">          const int yy = y + roi_out-&gt;y, xx = x + roi_out-&gt;x;</a>
<a name="ln2447">          if(yy &gt;= 0 &amp;&amp; xx &gt;= 0 &amp;&amp; yy &lt; roi_in-&gt;height &amp;&amp; xx &lt; roi_in-&gt;width)</a>
<a name="ln2448">          {</a>
<a name="ln2449">            int f = FC(y, x, filters);</a>
<a name="ln2450">            sum[f] += in[(size_t)yy * roi_in-&gt;width + xx];</a>
<a name="ln2451">            sum[f + 4]++;</a>
<a name="ln2452">          }</a>
<a name="ln2453">        }</a>
<a name="ln2454">      int f = FC(j, i, filters);</a>
<a name="ln2455">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2456">      {</a>
<a name="ln2457">        if(c != f &amp;&amp; sum[c + 4] &gt; 0.0f)</a>
<a name="ln2458">          out[4 * ((size_t)j * roi_out-&gt;width + i) + c] = sum[c] / sum[c + 4];</a>
<a name="ln2459">        else</a>
<a name="ln2460">          out[4 * ((size_t)j * roi_out-&gt;width + i) + c]</a>
<a name="ln2461">              = in[((size_t)j + roi_out-&gt;y) * roi_in-&gt;width + i + roi_out-&gt;x];</a>
<a name="ln2462">      }</a>
<a name="ln2463">    }</a>
<a name="ln2464">  const int median = thrs &gt; 0.0f;</a>
<a name="ln2465">  // if(median) fbdd_green(out, in, roi_out, roi_in, filters);</a>
<a name="ln2466">  const float *input = in;</a>
<a name="ln2467">  if(median)</a>
<a name="ln2468">  {</a>
<a name="ln2469">    float *med_in = (float *)dt_alloc_align(64, (size_t)roi_in-&gt;height * roi_in-&gt;width * sizeof(float));</a>
<a name="ln2470">    pre_median(med_in, in, roi_in, filters, 1, thrs);</a>
<a name="ln2471">    input = med_in;</a>
<a name="ln2472">  }</a>
<a name="ln2473">// for all pixels: interpolate green into float array, or copy color.</a>
<a name="ln2474">#ifdef _OPENMP</a>
<a name="ln2475">#pragma omp parallel for default(none) shared(input) schedule(static)</a>
<a name="ln2476">#endif</a>
<a name="ln2477">  for(int j = offy; j &lt; roi_out-&gt;height - offY; j++)</a>
<a name="ln2478">  {</a>
<a name="ln2479">    float *buf = out + (size_t)4 * roi_out-&gt;width * j + 4 * offx;</a>
<a name="ln2480">    const float *buf_in = input + (size_t)roi_in-&gt;width * (j + roi_out-&gt;y) + offx + roi_out-&gt;x;</a>
<a name="ln2481">    for(int i = offx; i &lt; roi_out-&gt;width - offX; i++)</a>
<a name="ln2482">    {</a>
<a name="ln2483">      const int c = FC(j, i, filters);</a>
<a name="ln2484">#if defined(__SSE__)</a>
<a name="ln2485">      // prefetch what we need soon (load to cpu caches)</a>
<a name="ln2486">      _mm_prefetch((char *)buf_in + 256, _MM_HINT_NTA); // TODO: try HINT_T0-3</a>
<a name="ln2487">      _mm_prefetch((char *)buf_in + roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2488">      _mm_prefetch((char *)buf_in + 2 * roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2489">      _mm_prefetch((char *)buf_in + 3 * roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2490">      _mm_prefetch((char *)buf_in - roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2491">      _mm_prefetch((char *)buf_in - 2 * roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2492">      _mm_prefetch((char *)buf_in - 3 * roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2493">#endif</a>
<a name="ln2494"> </a>
<a name="ln2495">#if defined(__SSE__)</a>
<a name="ln2496">      __m128 col = _mm_load_ps(buf);</a>
<a name="ln2497">      float *color = (float *)&amp;col;</a>
<a name="ln2498">#else</a>
<a name="ln2499">      float color[4] = { buf[0], buf[1], buf[2], buf[3] };</a>
<a name="ln2500">#endif</a>
<a name="ln2501">      const float pc = buf_in[0];</a>
<a name="ln2502">      // if(__builtin_expect(c == 0 || c == 2, 1))</a>
<a name="ln2503">      if(c == 0 || c == 2)</a>
<a name="ln2504">      {</a>
<a name="ln2505">        color[c] = pc;</a>
<a name="ln2506">        // get stuff (hopefully from cache)</a>
<a name="ln2507">        const float pym = buf_in[-roi_in-&gt;width * 1];</a>
<a name="ln2508">        const float pym2 = buf_in[-roi_in-&gt;width * 2];</a>
<a name="ln2509">        const float pym3 = buf_in[-roi_in-&gt;width * 3];</a>
<a name="ln2510">        const float pyM = buf_in[+roi_in-&gt;width * 1];</a>
<a name="ln2511">        const float pyM2 = buf_in[+roi_in-&gt;width * 2];</a>
<a name="ln2512">        const float pyM3 = buf_in[+roi_in-&gt;width * 3];</a>
<a name="ln2513">        const float pxm = buf_in[-1];</a>
<a name="ln2514">        const float pxm2 = buf_in[-2];</a>
<a name="ln2515">        const float pxm3 = buf_in[-3];</a>
<a name="ln2516">        const float pxM = buf_in[+1];</a>
<a name="ln2517">        const float pxM2 = buf_in[+2];</a>
<a name="ln2518">        const float pxM3 = buf_in[+3];</a>
<a name="ln2519"> </a>
<a name="ln2520">        const float guessx = (pxm + pc + pxM) * 2.0f - pxM2 - pxm2;</a>
<a name="ln2521">        const float diffx = (fabsf(pxm2 - pc) + fabsf(pxM2 - pc) + fabsf(pxm - pxM)) * 3.0f</a>
<a name="ln2522">                            + (fabsf(pxM3 - pxM) + fabsf(pxm3 - pxm)) * 2.0f;</a>
<a name="ln2523">        const float guessy = (pym + pc + pyM) * 2.0f - pyM2 - pym2;</a>
<a name="ln2524">        const float diffy = (fabsf(pym2 - pc) + fabsf(pyM2 - pc) + fabsf(pym - pyM)) * 3.0f</a>
<a name="ln2525">                            + (fabsf(pyM3 - pyM) + fabsf(pym3 - pym)) * 2.0f;</a>
<a name="ln2526">        if(diffx &gt; diffy)</a>
<a name="ln2527">        {</a>
<a name="ln2528">          // use guessy</a>
<a name="ln2529">          const float m = fminf(pym, pyM);</a>
<a name="ln2530">          const float M = fmaxf(pym, pyM);</a>
<a name="ln2531">          color[1] = fmaxf(fminf(guessy * .25f, M), m);</a>
<a name="ln2532">        }</a>
<a name="ln2533">        else</a>
<a name="ln2534">        {</a>
<a name="ln2535">          const float m = fminf(pxm, pxM);</a>
<a name="ln2536">          const float M = fmaxf(pxm, pxM);</a>
<a name="ln2537">          color[1] = fmaxf(fminf(guessx * .25f, M), m);</a>
<a name="ln2538">        }</a>
<a name="ln2539">      }</a>
<a name="ln2540">      else</a>
<a name="ln2541">        color[1] = pc;</a>
<a name="ln2542"> </a>
<a name="ln2543">      // write using MOVNTPS (write combine omitting caches)</a>
<a name="ln2544">      // _mm_stream_ps(buf, col);</a>
<a name="ln2545">      memcpy(buf, color, 4 * sizeof(float));</a>
<a name="ln2546">      buf += 4;</a>
<a name="ln2547">      buf_in++;</a>
<a name="ln2548">    }</a>
<a name="ln2549">  }</a>
<a name="ln2550">// SFENCE (make sure stuff is stored now)</a>
<a name="ln2551">// _mm_sfence();</a>
<a name="ln2552"> </a>
<a name="ln2553">// for all pixels: interpolate colors into float array</a>
<a name="ln2554">#ifdef _OPENMP</a>
<a name="ln2555">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln2556">#endif</a>
<a name="ln2557">  for(int j = 1; j &lt; roi_out-&gt;height - 1; j++)</a>
<a name="ln2558">  {</a>
<a name="ln2559">    float *buf = out + (size_t)4 * roi_out-&gt;width * j + 4;</a>
<a name="ln2560">    for(int i = 1; i &lt; roi_out-&gt;width - 1; i++)</a>
<a name="ln2561">    {</a>
<a name="ln2562">      // also prefetch direct nbs top/bottom</a>
<a name="ln2563">#if defined(__SSE__)</a>
<a name="ln2564">      _mm_prefetch((char *)buf + 256, _MM_HINT_NTA);</a>
<a name="ln2565">      _mm_prefetch((char *)buf - roi_out-&gt;width * 4 * sizeof(float) + 256, _MM_HINT_NTA);</a>
<a name="ln2566">      _mm_prefetch((char *)buf + roi_out-&gt;width * 4 * sizeof(float) + 256, _MM_HINT_NTA);</a>
<a name="ln2567">#endif</a>
<a name="ln2568"> </a>
<a name="ln2569">      const int c = FC(j, i, filters);</a>
<a name="ln2570">#if defined(__SSE__)</a>
<a name="ln2571">      __m128 col = _mm_load_ps(buf);</a>
<a name="ln2572">      float *color = (float *)&amp;col;</a>
<a name="ln2573">#else</a>
<a name="ln2574">      float color[4] = { buf[0], buf[1], buf[2], buf[3] };</a>
<a name="ln2575">#endif</a>
<a name="ln2576">      // fill all four pixels with correctly interpolated stuff: r/b for green1/2</a>
<a name="ln2577">      // b for r and r for b</a>
<a name="ln2578">      if(__builtin_expect(c &amp; 1, 1)) // c == 1 || c == 3)</a>
<a name="ln2579">      {</a>
<a name="ln2580">        // calculate red and blue for green pixels:</a>
<a name="ln2581">        // need 4-nbhood:</a>
<a name="ln2582">        const float *nt = buf - 4 * roi_out-&gt;width;</a>
<a name="ln2583">        const float *nb = buf + 4 * roi_out-&gt;width;</a>
<a name="ln2584">        const float *nl = buf - 4;</a>
<a name="ln2585">        const float *nr = buf + 4;</a>
<a name="ln2586">        if(FC(j, i + 1, filters) == 0) // red nb in same row</a>
<a name="ln2587">        {</a>
<a name="ln2588">          color[2] = (nt[2] + nb[2] + 2.0f * color[1] - nt[1] - nb[1]) * .5f;</a>
<a name="ln2589">          color[0] = (nl[0] + nr[0] + 2.0f * color[1] - nl[1] - nr[1]) * .5f;</a>
<a name="ln2590">        }</a>
<a name="ln2591">        else</a>
<a name="ln2592">        {</a>
<a name="ln2593">          // blue nb</a>
<a name="ln2594">          color[0] = (nt[0] + nb[0] + 2.0f * color[1] - nt[1] - nb[1]) * .5f;</a>
<a name="ln2595">          color[2] = (nl[2] + nr[2] + 2.0f * color[1] - nl[1] - nr[1]) * .5f;</a>
<a name="ln2596">        }</a>
<a name="ln2597">      }</a>
<a name="ln2598">      else</a>
<a name="ln2599">      {</a>
<a name="ln2600">        // get 4-star-nbhood:</a>
<a name="ln2601">        const float *ntl = buf - 4 - 4 * roi_out-&gt;width;</a>
<a name="ln2602">        const float *ntr = buf + 4 - 4 * roi_out-&gt;width;</a>
<a name="ln2603">        const float *nbl = buf - 4 + 4 * roi_out-&gt;width;</a>
<a name="ln2604">        const float *nbr = buf + 4 + 4 * roi_out-&gt;width;</a>
<a name="ln2605"> </a>
<a name="ln2606">        if(c == 0)</a>
<a name="ln2607">        {</a>
<a name="ln2608">          // red pixel, fill blue:</a>
<a name="ln2609">          const float diff1 = fabsf(ntl[2] - nbr[2]) + fabsf(ntl[1] - color[1]) + fabsf(nbr[1] - color[1]);</a>
<a name="ln2610">          const float guess1 = ntl[2] + nbr[2] + 2.0f * color[1] - ntl[1] - nbr[1];</a>
<a name="ln2611">          const float diff2 = fabsf(ntr[2] - nbl[2]) + fabsf(ntr[1] - color[1]) + fabsf(nbl[1] - color[1]);</a>
<a name="ln2612">          const float guess2 = ntr[2] + nbl[2] + 2.0f * color[1] - ntr[1] - nbl[1];</a>
<a name="ln2613">          if(diff1 &gt; diff2)</a>
<a name="ln2614">            color[2] = guess2 * .5f;</a>
<a name="ln2615">          else if(diff1 &lt; diff2)</a>
<a name="ln2616">            color[2] = guess1 * .5f;</a>
<a name="ln2617">          else</a>
<a name="ln2618">            color[2] = (guess1 + guess2) * .25f;</a>
<a name="ln2619">        }</a>
<a name="ln2620">        else // c == 2, blue pixel, fill red:</a>
<a name="ln2621">        {</a>
<a name="ln2622">          const float diff1 = fabsf(ntl[0] - nbr[0]) + fabsf(ntl[1] - color[1]) + fabsf(nbr[1] - color[1]);</a>
<a name="ln2623">          const float guess1 = ntl[0] + nbr[0] + 2.0f * color[1] - ntl[1] - nbr[1];</a>
<a name="ln2624">          const float diff2 = fabsf(ntr[0] - nbl[0]) + fabsf(ntr[1] - color[1]) + fabsf(nbl[1] - color[1]);</a>
<a name="ln2625">          const float guess2 = ntr[0] + nbl[0] + 2.0f * color[1] - ntr[1] - nbl[1];</a>
<a name="ln2626">          if(diff1 &gt; diff2)</a>
<a name="ln2627">            color[0] = guess2 * .5f;</a>
<a name="ln2628">          else if(diff1 &lt; diff2)</a>
<a name="ln2629">            color[0] = guess1 * .5f;</a>
<a name="ln2630">          else</a>
<a name="ln2631">            color[0] = (guess1 + guess2) * .25f;</a>
<a name="ln2632">        }</a>
<a name="ln2633">      }</a>
<a name="ln2634">      // _mm_stream_ps(buf, col);</a>
<a name="ln2635">      memcpy(buf, color, 4 * sizeof(float));</a>
<a name="ln2636">      buf += 4;</a>
<a name="ln2637">    }</a>
<a name="ln2638">  }</a>
<a name="ln2639">  // _mm_sfence();</a>
<a name="ln2640">  if(median) dt_free_align((float *)input);</a>
<a name="ln2641">}</a>
<a name="ln2642"> </a>
<a name="ln2643">void distort_mask(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln2644">                  float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2645">{</a>
<a name="ln2646">  const struct dt_interpolation *itor = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln2647">  dt_interpolation_resample_roi_1c(itor, out, roi_out, roi_out-&gt;width * sizeof(float), in, roi_in,</a>
<a name="ln2648">                                   roi_in-&gt;width * sizeof(float));</a>
<a name="ln2649">}</a>
<a name="ln2650"> </a>
<a name="ln2651">void modify_roi_out(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, dt_iop_roi_t *roi_out,</a>
<a name="ln2652">                    const dt_iop_roi_t *const roi_in)</a>
<a name="ln2653">{</a>
<a name="ln2654">  *roi_out = *roi_in;</a>
<a name="ln2655"> </a>
<a name="ln2656">  // snap to start of mosaic block:</a>
<a name="ln2657">  roi_out-&gt;x = 0; // MAX(0, roi_out-&gt;x &amp; ~1);</a>
<a name="ln2658">  roi_out-&gt;y = 0; // MAX(0, roi_out-&gt;y &amp; ~1);</a>
<a name="ln2659">}</a>
<a name="ln2660"> </a>
<a name="ln2661">// which roi input is needed to process to this output?</a>
<a name="ln2662">// roi_out is unchanged, full buffer in is full buffer out.</a>
<a name="ln2663">void modify_roi_in(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln2664">                   const dt_iop_roi_t *roi_out, dt_iop_roi_t *roi_in)</a>
<a name="ln2665">{</a>
<a name="ln2666">  // this op is disabled for preview pipe/filters == 0</a>
<a name="ln2667"> </a>
<a name="ln2668">  *roi_in = *roi_out;</a>
<a name="ln2669">  // need 1:1, demosaic and then sub-sample. or directly sample half-size</a>
<a name="ln2670">  roi_in-&gt;x /= roi_out-&gt;scale;</a>
<a name="ln2671">  roi_in-&gt;y /= roi_out-&gt;scale;</a>
<a name="ln2672">  roi_in-&gt;width /= roi_out-&gt;scale;</a>
<a name="ln2673">  roi_in-&gt;height /= roi_out-&gt;scale;</a>
<a name="ln2674">  roi_in-&gt;scale = 1.0f;</a>
<a name="ln2675">  // clamp to even x/y, to make demosaic pattern still hold..</a>
<a name="ln2676">  if(piece-&gt;pipe-&gt;dsc.filters != 9u)</a>
<a name="ln2677">  {</a>
<a name="ln2678">    roi_in-&gt;x = MAX(0, roi_in-&gt;x &amp; ~1);</a>
<a name="ln2679">    roi_in-&gt;y = MAX(0, roi_in-&gt;y &amp; ~1);</a>
<a name="ln2680">  }</a>
<a name="ln2681">  else</a>
<a name="ln2682">  {</a>
<a name="ln2683">    // Markesteijn needs factors of 3</a>
<a name="ln2684">    roi_in-&gt;x = MAX(0, roi_in-&gt;x - (roi_in-&gt;x % 3));</a>
<a name="ln2685">    roi_in-&gt;y = MAX(0, roi_in-&gt;y - (roi_in-&gt;y % 3));</a>
<a name="ln2686">  }</a>
<a name="ln2687"> </a>
<a name="ln2688">  // clamp numeric inaccuracies to full buffer, to avoid scaling/copying in pixelpipe:</a>
<a name="ln2689">  if(abs(piece-&gt;pipe-&gt;image.width - roi_in-&gt;width) &lt; MAX(ceilf(1.0f / roi_out-&gt;scale), 10))</a>
<a name="ln2690">    roi_in-&gt;width = piece-&gt;pipe-&gt;image.width;</a>
<a name="ln2691"> </a>
<a name="ln2692">  if(abs(piece-&gt;pipe-&gt;image.height - roi_in-&gt;height) &lt; MAX(ceilf(1.0f / roi_out-&gt;scale), 10))</a>
<a name="ln2693">    roi_in-&gt;height = piece-&gt;pipe-&gt;image.height;</a>
<a name="ln2694">}</a>
<a name="ln2695"> </a>
<a name="ln2696">static int get_quality()</a>
<a name="ln2697">{</a>
<a name="ln2698">  int qual = 1;</a>
<a name="ln2699">  gchar *quality = dt_conf_get_string(&quot;plugins/darkroom/demosaic/quality&quot;);</a>
<a name="ln2700">  if(quality)</a>
<a name="ln2701">  {</a>
<a name="ln2702">    if(!strcmp(quality, &quot;always bilinear (fast)&quot;))</a>
<a name="ln2703">      qual = 0;</a>
<a name="ln2704">    else if(!strcmp(quality, &quot;full (possibly slow)&quot;))</a>
<a name="ln2705">      qual = 2;</a>
<a name="ln2706">    g_free(quality);</a>
<a name="ln2707">  }</a>
<a name="ln2708">  return qual;</a>
<a name="ln2709">}</a>
<a name="ln2710"> </a>
<a name="ln2711">static int get_thumb_quality(int width, int height)</a>
<a name="ln2712">{</a>
<a name="ln2713">  // we check if we need ultra-high quality thumbnail for this size</a>
<a name="ln2714">  char *min = dt_conf_get_string(&quot;plugins/lighttable/thumbnail_hq_min_level&quot;);</a>
<a name="ln2715"> </a>
<a name="ln2716">  int level = dt_mipmap_cache_get_matching_size(darktable.mipmap_cache, width, height);</a>
<a name="ln2717">  int res = 0;</a>
<a name="ln2718">  if (strcmp(min, &quot;always&quot;)==0) res = 1;</a>
<a name="ln2719">  else if (strcmp(min, &quot;small&quot;)==0) res = ( level &gt;= 1 );</a>
<a name="ln2720">  else if (strcmp(min, &quot;VGA&quot;)==0) res = ( level &gt;= 2 );</a>
<a name="ln2721">  else if (strcmp(min, &quot;720p&quot;)==0) res = ( level &gt;= 3 );</a>
<a name="ln2722">  else if (strcmp(min, &quot;1080p&quot;)==0) res = ( level &gt;= 4 );</a>
<a name="ln2723">  else if (strcmp(min, &quot;WQXGA&quot;)==0) res = ( level &gt;= 5 );</a>
<a name="ln2724">  else if (strcmp(min, &quot;4k&quot;)==0) res = ( level &gt;= 6 );</a>
<a name="ln2725">  else if (strcmp(min, &quot;5K&quot;)==0) res = ( level &gt;= 7 );</a>
<a name="ln2726"> </a>
<a name="ln2727">  g_free(min);</a>
<a name="ln2728">  return res;</a>
<a name="ln2729">}</a>
<a name="ln2730"> </a>
<a name="ln2731">// set flags for demosaic quality based on factors besides demosaic</a>
<a name="ln2732">// method (e.g. config, scale, pixelpipe type)</a>
<a name="ln2733">static int demosaic_qual_flags(const dt_dev_pixelpipe_iop_t *const piece,</a>
<a name="ln2734">                               const dt_image_t *const img,</a>
<a name="ln2735">                               const dt_iop_roi_t *const roi_out)</a>
<a name="ln2736">{</a>
<a name="ln2737">  int flags = 0;</a>
<a name="ln2738">  switch (piece-&gt;pipe-&gt;type)</a>
<a name="ln2739">  {</a>
<a name="ln2740">    case DT_DEV_PIXELPIPE_FULL:</a>
<a name="ln2741">      {</a>
<a name="ln2742">        const int qual = get_quality();</a>
<a name="ln2743">        if (qual &gt; 0) flags |= DEMOSAIC_FULL_SCALE;</a>
<a name="ln2744">        if (qual &gt; 1) flags |= DEMOSAIC_XTRANS_FULL;</a>
<a name="ln2745">        if ((qual &lt; 2) &amp;&amp; (roi_out-&gt;scale &lt;= .99999f))</a>
<a name="ln2746">          flags |= DEMOSAIC_MEDIUM_QUAL;</a>
<a name="ln2747">      }</a>
<a name="ln2748">      break;</a>
<a name="ln2749">    case DT_DEV_PIXELPIPE_EXPORT:</a>
<a name="ln2750">      flags |= DEMOSAIC_FULL_SCALE | DEMOSAIC_XTRANS_FULL;</a>
<a name="ln2751">      break;</a>
<a name="ln2752">    case DT_DEV_PIXELPIPE_THUMBNAIL:</a>
<a name="ln2753">      // we check if we need ultra-high quality thumbnail for this size</a>
<a name="ln2754">      if (get_thumb_quality(roi_out-&gt;width, roi_out-&gt;height))</a>
<a name="ln2755">      {</a>
<a name="ln2756">        flags |= DEMOSAIC_FULL_SCALE | DEMOSAIC_XTRANS_FULL;</a>
<a name="ln2757">      }</a>
<a name="ln2758">      break;</a>
<a name="ln2759">    default: // make C not complain about missing enum members</a>
<a name="ln2760">      break;</a>
<a name="ln2761">  }</a>
<a name="ln2762"> </a>
<a name="ln2763">  // For suficiently small scaling, one or more repetitition of the</a>
<a name="ln2764">  // CFA pattern can be merged into a single pixel, hence it is</a>
<a name="ln2765">  // possible to skip the full demosaic and perform a quick downscale.</a>
<a name="ln2766">  // Note even though the X-Trans CFA is 6x6, for this purposes we can</a>
<a name="ln2767">  // see each 6x6 tile as four fairly similar 3x3 tiles</a>
<a name="ln2768">  if (roi_out-&gt;scale &gt; (piece-&gt;pipe-&gt;dsc.filters == 9u ? 0.333f : 0.5f))</a>
<a name="ln2769">  {</a>
<a name="ln2770">    flags |= DEMOSAIC_FULL_SCALE;</a>
<a name="ln2771">  }</a>
<a name="ln2772">  // half_size_f doesn't support 4bayer images</a>
<a name="ln2773">  if (img-&gt;flags &amp; DT_IMAGE_4BAYER) flags |= DEMOSAIC_FULL_SCALE;</a>
<a name="ln2774">  // we use full Markesteijn demosaicing on xtrans sensors if maximum</a>
<a name="ln2775">  // quality is required</a>
<a name="ln2776">  if (roi_out-&gt;scale &gt; 0.667f)</a>
<a name="ln2777">  {</a>
<a name="ln2778">    flags |= DEMOSAIC_XTRANS_FULL;</a>
<a name="ln2779">  }</a>
<a name="ln2780"> </a>
<a name="ln2781">  // we check if we can stop at the linear interpolation step in VNG</a>
<a name="ln2782">  // instead of going the full way</a>
<a name="ln2783">  if ((flags &amp; DEMOSAIC_FULL_SCALE) &amp;&amp;</a>
<a name="ln2784">      (roi_out-&gt;scale &lt; (piece-&gt;pipe-&gt;dsc.filters == 9u ? 0.5f : 0.667f)))</a>
<a name="ln2785">  {</a>
<a name="ln2786">    flags |= DEMOSAIC_ONLY_VNG_LINEAR;</a>
<a name="ln2787">  }</a>
<a name="ln2788"> </a>
<a name="ln2789">  return flags;</a>
<a name="ln2790">}</a>
<a name="ln2791"> </a>
<a name="ln2792">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o,</a>
<a name="ln2793">             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2794">{</a>
<a name="ln2795">  const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln2796">  const float threshold = 0.0001f * img-&gt;exif_iso;</a>
<a name="ln2797"> </a>
<a name="ln2798">  dt_iop_roi_t roi = *roi_in;</a>
<a name="ln2799">  dt_iop_roi_t roo = *roi_out;</a>
<a name="ln2800">  roo.x = roo.y = 0;</a>
<a name="ln2801">  // roi_out-&gt;scale = global scale: (iscale == 1.0, always when demosaic is on)</a>
<a name="ln2802"> </a>
<a name="ln2803">  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece-&gt;pipe-&gt;dsc.xtrans;</a>
<a name="ln2804"> </a>
<a name="ln2805">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln2806"> </a>
<a name="ln2807">  const int qual_flags = demosaic_qual_flags(piece, img, roi_out);</a>
<a name="ln2808">  int demosaicing_method = data-&gt;demosaicing_method;</a>
<a name="ln2809">  if((qual_flags &amp; DEMOSAIC_MEDIUM_QUAL)</a>
<a name="ln2810">     &amp;&amp; // only overwrite setting if quality &lt;&lt; requested and in dr mode</a>
<a name="ln2811">     (demosaicing_method != DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)) // do not touch this special method</a>
<a name="ln2812">    demosaicing_method = (piece-&gt;pipe-&gt;dsc.filters != 9u) ? DT_IOP_DEMOSAIC_PPG : DT_IOP_DEMOSAIC_MARKESTEIJN;</a>
<a name="ln2813"> </a>
<a name="ln2814">  const float *const pixels = (float *)i;</a>
<a name="ln2815"> </a>
<a name="ln2816">  if(qual_flags &amp; DEMOSAIC_FULL_SCALE)</a>
<a name="ln2817">  {</a>
<a name="ln2818">    // Full demosaic and then scaling if needed</a>
<a name="ln2819">    const int scaled = (roi_out-&gt;width != roi_in-&gt;width || roi_out-&gt;height != roi_in-&gt;height);</a>
<a name="ln2820">    float *tmp = (float *) o;</a>
<a name="ln2821">    if(scaled)</a>
<a name="ln2822">    {</a>
<a name="ln2823">      // demosaic and then clip and zoom</a>
<a name="ln2824">      // we demosaic at 1:1 the size of input roi, so make sure</a>
<a name="ln2825">      // we fit these bounds exactly, to avoid crashes..</a>
<a name="ln2826">      roo.width = roi_in-&gt;width;</a>
<a name="ln2827">      roo.height = roi_in-&gt;height;</a>
<a name="ln2828">      roo.scale = 1.0f;</a>
<a name="ln2829">      tmp = (float *)dt_alloc_align(64, (size_t)roo.width * roo.height * 4 * sizeof(float));</a>
<a name="ln2830">    }</a>
<a name="ln2831"> </a>
<a name="ln2832">    if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln2833">    {</a>
<a name="ln2834">      passthrough_monochrome(tmp, pixels, &amp;roo, &amp;roi);</a>
<a name="ln2835">    }</a>
<a name="ln2836">    else if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln2837">    {</a>
<a name="ln2838">      if(demosaicing_method == DT_IOP_DEMOSAIC_FDC &amp;&amp; (qual_flags &amp; DEMOSAIC_XTRANS_FULL))</a>
<a name="ln2839">        xtrans_fdc_interpolate(self, tmp, pixels, &amp;roo, &amp;roi, xtrans);</a>
<a name="ln2840">      else if(demosaicing_method &gt;= DT_IOP_DEMOSAIC_MARKESTEIJN &amp;&amp; (qual_flags &amp; DEMOSAIC_XTRANS_FULL))</a>
<a name="ln2841">        xtrans_markesteijn_interpolate(tmp, pixels, &amp;roo, &amp;roi, xtrans,</a>
<a name="ln2842">                                       1 + (demosaicing_method - DT_IOP_DEMOSAIC_MARKESTEIJN) * 2);</a>
<a name="ln2843">      else</a>
<a name="ln2844">        vng_interpolate(tmp, pixels, &amp;roo, &amp;roi, piece-&gt;pipe-&gt;dsc.filters, xtrans, qual_flags &amp; DEMOSAIC_ONLY_VNG_LINEAR);</a>
<a name="ln2845">    }</a>
<a name="ln2846">    else</a>
<a name="ln2847">    {</a>
<a name="ln2848">      float *in = (float *)pixels;</a>
<a name="ln2849">      float *aux;</a>
<a name="ln2850"> </a>
<a name="ln2851">      if(!(img-&gt;flags &amp; DT_IMAGE_4BAYER) &amp;&amp; data-&gt;green_eq != DT_IOP_GREEN_EQ_NO)</a>
<a name="ln2852">      {</a>
<a name="ln2853">        in = (float *)dt_alloc_align(64, (size_t)roi_in-&gt;height * roi_in-&gt;width * sizeof(float));</a>
<a name="ln2854">        switch(data-&gt;green_eq)</a>
<a name="ln2855">        {</a>
<a name="ln2856">          case DT_IOP_GREEN_EQ_FULL:</a>
<a name="ln2857">            green_equilibration_favg(in, pixels, roi_in-&gt;width, roi_in-&gt;height, piece-&gt;pipe-&gt;dsc.filters,</a>
<a name="ln2858">                                     roi_in-&gt;x, roi_in-&gt;y);</a>
<a name="ln2859">            break;</a>
<a name="ln2860">          case DT_IOP_GREEN_EQ_LOCAL:</a>
<a name="ln2861">            green_equilibration_lavg(in, pixels, roi_in-&gt;width, roi_in-&gt;height, piece-&gt;pipe-&gt;dsc.filters,</a>
<a name="ln2862">                                     roi_in-&gt;x, roi_in-&gt;y, threshold);</a>
<a name="ln2863">            break;</a>
<a name="ln2864">          case DT_IOP_GREEN_EQ_BOTH:</a>
<a name="ln2865">            aux = dt_alloc_align(64, (size_t)roi_in-&gt;height * roi_in-&gt;width * sizeof(float));</a>
<a name="ln2866">            green_equilibration_favg(aux, pixels, roi_in-&gt;width, roi_in-&gt;height, piece-&gt;pipe-&gt;dsc.filters,</a>
<a name="ln2867">                                     roi_in-&gt;x, roi_in-&gt;y);</a>
<a name="ln2868">            green_equilibration_lavg(in, aux, roi_in-&gt;width, roi_in-&gt;height, piece-&gt;pipe-&gt;dsc.filters, roi_in-&gt;x,</a>
<a name="ln2869">                                     roi_in-&gt;y, threshold);</a>
<a name="ln2870">            dt_free_align(aux);</a>
<a name="ln2871">            break;</a>
<a name="ln2872">        }</a>
<a name="ln2873">      }</a>
<a name="ln2874"> </a>
<a name="ln2875">      if(demosaicing_method == DT_IOP_DEMOSAIC_VNG4 || (img-&gt;flags &amp; DT_IMAGE_4BAYER))</a>
<a name="ln2876">      {</a>
<a name="ln2877">        vng_interpolate(tmp, in, &amp;roo, &amp;roi, piece-&gt;pipe-&gt;dsc.filters, xtrans, qual_flags &amp; DEMOSAIC_ONLY_VNG_LINEAR);</a>
<a name="ln2878">        if (img-&gt;flags &amp; DT_IMAGE_4BAYER)</a>
<a name="ln2879">        {</a>
<a name="ln2880">          dt_colorspaces_cygm_to_rgb(tmp, roo.width*roo.height, data-&gt;CAM_to_RGB);</a>
<a name="ln2881">          dt_colorspaces_cygm_to_rgb(piece-&gt;pipe-&gt;dsc.processed_maximum, 1, data-&gt;CAM_to_RGB);</a>
<a name="ln2882">        }</a>
<a name="ln2883">      }</a>
<a name="ln2884">      else if(demosaicing_method != DT_IOP_DEMOSAIC_AMAZE)</a>
<a name="ln2885">        demosaic_ppg(tmp, in, &amp;roo, &amp;roi, piece-&gt;pipe-&gt;dsc.filters,</a>
<a name="ln2886">                     data-&gt;median_thrs); // wanted ppg or zoomed out a lot and quality is limited to 1</a>
<a name="ln2887">      else</a>
<a name="ln2888">        amaze_demosaic_RT(self, piece, in, tmp, &amp;roi, &amp;roo, piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln2889"> </a>
<a name="ln2890">      if(!(img-&gt;flags &amp; DT_IMAGE_4BAYER) &amp;&amp; data-&gt;green_eq != DT_IOP_GREEN_EQ_NO) dt_free_align(in);</a>
<a name="ln2891">    }</a>
<a name="ln2892"> </a>
<a name="ln2893">    if(scaled)</a>
<a name="ln2894">    {</a>
<a name="ln2895">      roi = *roi_out;</a>
<a name="ln2896">      dt_iop_clip_and_zoom_roi((float *)o, tmp, &amp;roi, &amp;roo, roi.width, roo.width);</a>
<a name="ln2897">      dt_free_align(tmp);</a>
<a name="ln2898">    }</a>
<a name="ln2899">  }</a>
<a name="ln2900">  else</a>
<a name="ln2901">  {</a>
<a name="ln2902">    if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln2903">      dt_iop_clip_and_zoom_demosaic_passthrough_monochrome_f((float *)o, pixels, &amp;roo, &amp;roi, roo.width, roi.width);</a>
<a name="ln2904">    else // sample half-size raw (Bayer) or 1/3-size raw (X-Trans)</a>
<a name="ln2905">        if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln2906">      dt_iop_clip_and_zoom_demosaic_third_size_xtrans_f((float *)o, pixels, &amp;roo, &amp;roi, roo.width, roi.width,</a>
<a name="ln2907">                                                        xtrans);</a>
<a name="ln2908">    else</a>
<a name="ln2909">      dt_iop_clip_and_zoom_demosaic_half_size_f((float *)o, pixels, &amp;roo, &amp;roi, roo.width, roi.width,</a>
<a name="ln2910">                                                piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln2911">  }</a>
<a name="ln2912">  if(data-&gt;color_smoothing) color_smoothing(o, roi_out, data-&gt;color_smoothing);</a>
<a name="ln2913">}</a>
<a name="ln2914"> </a>
<a name="ln2915">#ifdef HAVE_OPENCL</a>
<a name="ln2916">// color smoothing step by multiple passes of median filtering</a>
<a name="ln2917">static int color_smoothing_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln2918">                              cl_mem dev_out, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2919">{</a>
<a name="ln2920">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln2921">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;data;</a>
<a name="ln2922"> </a>
<a name="ln2923">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln2924">  const int width = roi_out-&gt;width;</a>
<a name="ln2925">  const int height = roi_out-&gt;height;</a>
<a name="ln2926"> </a>
<a name="ln2927">  cl_int err = -999;</a>
<a name="ln2928"> </a>
<a name="ln2929">  cl_mem dev_tmp = dt_opencl_alloc_device(devid, width, height, 4 * sizeof(float));</a>
<a name="ln2930">  if(dev_tmp == NULL) goto error;</a>
<a name="ln2931"> </a>
<a name="ln2932">  dt_opencl_local_buffer_t locopt</a>
<a name="ln2933">    = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln2934">                                  .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln2935">                                  .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln2936"> </a>
<a name="ln2937">  if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_color_smoothing, &amp;locopt))</a>
<a name="ln2938">    goto error;</a>
<a name="ln2939"> </a>
<a name="ln2940">  // two buffer references for our ping-pong</a>
<a name="ln2941">  cl_mem dev_t1 = dev_out;</a>
<a name="ln2942">  cl_mem dev_t2 = dev_tmp;</a>
<a name="ln2943"> </a>
<a name="ln2944">  for(int pass = 0; pass &lt; data-&gt;color_smoothing; pass++)</a>
<a name="ln2945">  {</a>
<a name="ln2946">    size_t sizes[] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln2947">    size_t local[] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln2948">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 0, sizeof(cl_mem), &amp;dev_t1);</a>
<a name="ln2949">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 1, sizeof(cl_mem), &amp;dev_t2);</a>
<a name="ln2950">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 2, sizeof(int), &amp;width);</a>
<a name="ln2951">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 3, sizeof(int), &amp;height);</a>
<a name="ln2952">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 4,</a>
<a name="ln2953">                               (locopt.sizex + 2) * (locopt.sizey + 2) * 4 * sizeof(float), NULL);</a>
<a name="ln2954">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_color_smoothing, sizes, local);</a>
<a name="ln2955">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2956"> </a>
<a name="ln2957">    // swap dev_t1 and dev_t2</a>
<a name="ln2958">    cl_mem t = dev_t1;</a>
<a name="ln2959">    dev_t1 = dev_t2;</a>
<a name="ln2960">    dev_t2 = t;</a>
<a name="ln2961">  }</a>
<a name="ln2962"> </a>
<a name="ln2963">  // after last step we find final output in dev_t1.</a>
<a name="ln2964">  // let's see if this is in dev_tmp1 and needs to be copied to dev_out</a>
<a name="ln2965">  if(dev_t1 == dev_tmp)</a>
<a name="ln2966">  {</a>
<a name="ln2967">    // copy data from dev_tmp -&gt; dev_out</a>
<a name="ln2968">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln2969">    size_t region[] = { width, height, 1 };</a>
<a name="ln2970">    err = dt_opencl_enqueue_copy_image(devid, dev_tmp, dev_out, origin, origin, region);</a>
<a name="ln2971">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2972">  }</a>
<a name="ln2973"> </a>
<a name="ln2974">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln2975">  return TRUE;</a>
<a name="ln2976"> </a>
<a name="ln2977">error:</a>
<a name="ln2978">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln2979">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic_color_smoothing] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln2980">  return FALSE;</a>
<a name="ln2981">}</a>
<a name="ln2982"> </a>
<a name="ln2983">static int green_equilibration_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln2984">                                  cl_mem dev_out, const dt_iop_roi_t *const roi_in)</a>
<a name="ln2985">{</a>
<a name="ln2986">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln2987">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;data;</a>
<a name="ln2988"> </a>
<a name="ln2989">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln2990">  const int width = roi_in-&gt;width;</a>
<a name="ln2991">  const int height = roi_in-&gt;height;</a>
<a name="ln2992"> </a>
<a name="ln2993">  cl_mem dev_tmp = NULL;</a>
<a name="ln2994">  cl_mem dev_m = NULL;</a>
<a name="ln2995">  cl_mem dev_r = NULL;</a>
<a name="ln2996">  cl_mem dev_in1 = NULL;</a>
<a name="ln2997">  cl_mem dev_out1 = NULL;</a>
<a name="ln2998">  cl_mem dev_in2 = NULL;</a>
<a name="ln2999">  cl_mem dev_out2 = NULL;</a>
<a name="ln3000">  float *sumsum = NULL;</a>
<a name="ln3001"> </a>
<a name="ln3002">  cl_int err = -999;</a>
<a name="ln3003"> </a>
<a name="ln3004">  if(data-&gt;green_eq == DT_IOP_GREEN_EQ_BOTH)</a>
<a name="ln3005">  {</a>
<a name="ln3006">    dev_tmp = dt_opencl_alloc_device(devid, width, height, sizeof(float));</a>
<a name="ln3007">    if(dev_tmp == NULL) goto error;</a>
<a name="ln3008">  }</a>
<a name="ln3009"> </a>
<a name="ln3010">  switch(data-&gt;green_eq)</a>
<a name="ln3011">  {</a>
<a name="ln3012">    case DT_IOP_GREEN_EQ_FULL:</a>
<a name="ln3013">      dev_in1 = dev_in;</a>
<a name="ln3014">      dev_out1 = dev_out;</a>
<a name="ln3015">      break;</a>
<a name="ln3016">    case DT_IOP_GREEN_EQ_LOCAL:</a>
<a name="ln3017">      dev_in2 = dev_in;</a>
<a name="ln3018">      dev_out2 = dev_out;</a>
<a name="ln3019">      break;</a>
<a name="ln3020">    case DT_IOP_GREEN_EQ_BOTH:</a>
<a name="ln3021">      dev_in1 = dev_in;</a>
<a name="ln3022">      dev_out1 = dev_tmp;</a>
<a name="ln3023">      dev_in2 = dev_tmp;</a>
<a name="ln3024">      dev_out2 = dev_out;</a>
<a name="ln3025">      break;</a>
<a name="ln3026">    case DT_IOP_GREEN_EQ_NO:</a>
<a name="ln3027">    default:</a>
<a name="ln3028">      goto error;</a>
<a name="ln3029">  }</a>
<a name="ln3030"> </a>
<a name="ln3031">  if(data-&gt;green_eq == DT_IOP_GREEN_EQ_FULL || data-&gt;green_eq == DT_IOP_GREEN_EQ_BOTH)</a>
<a name="ln3032">  {</a>
<a name="ln3033">    dt_opencl_local_buffer_t flocopt</a>
<a name="ln3034">      = (dt_opencl_local_buffer_t){ .xoffset = 0, .xfactor = 1, .yoffset = 0, .yfactor = 1,</a>
<a name="ln3035">                                    .cellsize = 2 * sizeof(float), .overhead = 0,</a>
<a name="ln3036">                                    .sizex = 1 &lt;&lt; 4, .sizey = 1 &lt;&lt; 4 };</a>
<a name="ln3037"> </a>
<a name="ln3038">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_green_eq_favg_reduce_first, &amp;flocopt))</a>
<a name="ln3039">      goto error;</a>
<a name="ln3040"> </a>
<a name="ln3041">    const size_t bwidth = ROUNDUP(width, flocopt.sizex);</a>
<a name="ln3042">    const size_t bheight = ROUNDUP(height, flocopt.sizey);</a>
<a name="ln3043"> </a>
<a name="ln3044">    const int bufsize = (bwidth / flocopt.sizex) * (bheight / flocopt.sizey);</a>
<a name="ln3045"> </a>
<a name="ln3046">    dev_m = dt_opencl_alloc_device_buffer(devid, (size_t)bufsize * 2 * sizeof(float));</a>
<a name="ln3047">    if(dev_m == NULL) goto error;</a>
<a name="ln3048"> </a>
<a name="ln3049">    size_t fsizes[3] = { bwidth, bheight, 1 };</a>
<a name="ln3050">    size_t flocal[3] = { flocopt.sizex, flocopt.sizey, 1 };</a>
<a name="ln3051">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 0, sizeof(cl_mem), &amp;dev_in1);</a>
<a name="ln3052">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 1, sizeof(int), &amp;width);</a>
<a name="ln3053">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 2, sizeof(int), &amp;height);</a>
<a name="ln3054">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 3, sizeof(cl_mem), &amp;dev_m);</a>
<a name="ln3055">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 4, sizeof(uint32_t), (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3056">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 5, sizeof(int), &amp;roi_in-&gt;x);</a>
<a name="ln3057">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 6, sizeof(int), &amp;roi_in-&gt;y);</a>
<a name="ln3058">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 7,</a>
<a name="ln3059">                             flocopt.sizex * flocopt.sizey * 2 * sizeof(float), NULL);</a>
<a name="ln3060">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_green_eq_favg_reduce_first, fsizes,</a>
<a name="ln3061">                                                 flocal);</a>
<a name="ln3062">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3063"> </a>
<a name="ln3064">    dt_opencl_local_buffer_t slocopt</a>
<a name="ln3065">      = (dt_opencl_local_buffer_t){ .xoffset = 0, .xfactor = 1, .yoffset = 0, .yfactor = 1,</a>
<a name="ln3066">                                    .cellsize = 2 * sizeof(float), .overhead = 0,</a>
<a name="ln3067">                                    .sizex = 1 &lt;&lt; 16, .sizey = 1 };</a>
<a name="ln3068"> </a>
<a name="ln3069">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_green_eq_favg_reduce_second, &amp;slocopt))</a>
<a name="ln3070">      goto error;</a>
<a name="ln3071"> </a>
<a name="ln3072">    const int reducesize = MIN(REDUCESIZE, ROUNDUP(bufsize, slocopt.sizex) / slocopt.sizex);</a>
<a name="ln3073"> </a>
<a name="ln3074">    dev_r = dt_opencl_alloc_device_buffer(devid, (size_t)reducesize * 2 * sizeof(float));</a>
<a name="ln3075">    if(dev_r == NULL) goto error;</a>
<a name="ln3076"> </a>
<a name="ln3077">    size_t ssizes[3] = { reducesize * slocopt.sizex, 1, 1 };</a>
<a name="ln3078">    size_t slocal[3] = { slocopt.sizex, 1, 1 };</a>
<a name="ln3079">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_second, 0, sizeof(cl_mem), &amp;dev_m);</a>
<a name="ln3080">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_second, 1, sizeof(cl_mem), &amp;dev_r);</a>
<a name="ln3081">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_second, 2, sizeof(int), &amp;bufsize);</a>
<a name="ln3082">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_second, 3, slocopt.sizex * 2 * sizeof(float), NULL);</a>
<a name="ln3083">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_green_eq_favg_reduce_second, ssizes,</a>
<a name="ln3084">                                                 slocal);</a>
<a name="ln3085">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3086"> </a>
<a name="ln3087">    sumsum = dt_alloc_align(64, (size_t)reducesize * 2 * sizeof(float));</a>
<a name="ln3088">    if(sumsum == NULL) goto error;</a>
<a name="ln3089">    err = dt_opencl_read_buffer_from_device(devid, (void *)sumsum, dev_r, 0,</a>
<a name="ln3090">                                            (size_t)reducesize * 2 * sizeof(float), CL_TRUE);</a>
<a name="ln3091">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3092"> </a>
<a name="ln3093">    float sum1 = 0.0f, sum2 = 0.0f;</a>
<a name="ln3094">    for(int k = 0; k &lt; reducesize; k++)</a>
<a name="ln3095">    {</a>
<a name="ln3096">      sum1 += sumsum[2 * k];</a>
<a name="ln3097">      sum2 += sumsum[2 * k + 1];</a>
<a name="ln3098">    }</a>
<a name="ln3099"> </a>
<a name="ln3100">    const float gr_ratio = (sum1 &gt; 0.0f &amp;&amp; sum2 &gt; 0.0f) ? sum2 / sum1 : 1.0f;</a>
<a name="ln3101"> </a>
<a name="ln3102">    size_t asizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3103">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 0, sizeof(cl_mem), &amp;dev_in1);</a>
<a name="ln3104">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 1, sizeof(cl_mem), &amp;dev_out1);</a>
<a name="ln3105">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 2, sizeof(int), &amp;width);</a>
<a name="ln3106">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 3, sizeof(int), &amp;height);</a>
<a name="ln3107">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 4, sizeof(uint32_t), (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3108">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 5, sizeof(int), &amp;roi_in-&gt;x);</a>
<a name="ln3109">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 6, sizeof(int), &amp;roi_in-&gt;y);</a>
<a name="ln3110">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 7, sizeof(float), &amp;gr_ratio);</a>
<a name="ln3111">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_green_eq_favg_apply, asizes);</a>
<a name="ln3112">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3113">  }</a>
<a name="ln3114"> </a>
<a name="ln3115">  if(data-&gt;green_eq == DT_IOP_GREEN_EQ_LOCAL || data-&gt;green_eq == DT_IOP_GREEN_EQ_BOTH)</a>
<a name="ln3116">  {</a>
<a name="ln3117">    const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln3118">    const float threshold = 0.0001f * img-&gt;exif_iso;</a>
<a name="ln3119"> </a>
<a name="ln3120">    dt_opencl_local_buffer_t locopt</a>
<a name="ln3121">      = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln3122">                                    .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3123">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3124"> </a>
<a name="ln3125">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_green_eq_lavg, &amp;locopt))</a>
<a name="ln3126">      goto error;</a>
<a name="ln3127"> </a>
<a name="ln3128">    size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3129">    size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3130">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 0, sizeof(cl_mem), &amp;dev_in2);</a>
<a name="ln3131">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 1, sizeof(cl_mem), &amp;dev_out2);</a>
<a name="ln3132">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 2, sizeof(int), &amp;width);</a>
<a name="ln3133">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 3, sizeof(int), &amp;height);</a>
<a name="ln3134">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 4, sizeof(uint32_t), (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3135">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 5, sizeof(int), &amp;roi_in-&gt;x);</a>
<a name="ln3136">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 6, sizeof(int), &amp;roi_in-&gt;y);</a>
<a name="ln3137">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 7, sizeof(float), (void *)&amp;threshold);</a>
<a name="ln3138">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 8,</a>
<a name="ln3139">                           (locopt.sizex + 4) * (locopt.sizey + 4) * sizeof(float), NULL);</a>
<a name="ln3140">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_green_eq_lavg, sizes, local);</a>
<a name="ln3141">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3142">  }</a>
<a name="ln3143"> </a>
<a name="ln3144">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3145">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln3146">  dt_opencl_release_mem_object(dev_r);</a>
<a name="ln3147">  dt_free_align(sumsum);</a>
<a name="ln3148">  return TRUE;</a>
<a name="ln3149"> </a>
<a name="ln3150">error:</a>
<a name="ln3151">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3152">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln3153">  dt_opencl_release_mem_object(dev_r);</a>
<a name="ln3154">  dt_free_align(sumsum);</a>
<a name="ln3155">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic_green_equilibration] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3156">  return FALSE;</a>
<a name="ln3157">}</a>
<a name="ln3158"> </a>
<a name="ln3159"> </a>
<a name="ln3160">static int process_default_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln3161">                              cl_mem dev_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln3162">                              const dt_iop_roi_t *const roi_out)</a>
<a name="ln3163">{</a>
<a name="ln3164">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln3165">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;data;</a>
<a name="ln3166">  const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln3167"> </a>
<a name="ln3168">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3169">  const int qual_flags = demosaic_qual_flags(piece, img, roi_out);</a>
<a name="ln3170">  const int demosaicing_method = data-&gt;demosaicing_method;</a>
<a name="ln3171"> </a>
<a name="ln3172">  cl_mem dev_aux = NULL;</a>
<a name="ln3173">  cl_mem dev_tmp = NULL;</a>
<a name="ln3174">  cl_mem dev_green_eq = NULL;</a>
<a name="ln3175">  cl_int err = -999;</a>
<a name="ln3176"> </a>
<a name="ln3177"> </a>
<a name="ln3178">  if(qual_flags &amp; DEMOSAIC_FULL_SCALE)</a>
<a name="ln3179">  {</a>
<a name="ln3180">    // Full demosaic and then scaling if needed</a>
<a name="ln3181">    const int scaled = (roi_out-&gt;width != roi_in-&gt;width || roi_out-&gt;height != roi_in-&gt;height);</a>
<a name="ln3182"> </a>
<a name="ln3183">    int width = roi_out-&gt;width;</a>
<a name="ln3184">    int height = roi_out-&gt;height;</a>
<a name="ln3185"> </a>
<a name="ln3186">    // green equilibration</a>
<a name="ln3187">    if(data-&gt;green_eq != DT_IOP_GREEN_EQ_NO)</a>
<a name="ln3188">    {</a>
<a name="ln3189">      dev_green_eq = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, sizeof(float));</a>
<a name="ln3190">      if(dev_green_eq == NULL) goto error;</a>
<a name="ln3191"> </a>
<a name="ln3192">      if(!green_equilibration_cl(self, piece, dev_in, dev_green_eq, roi_in))</a>
<a name="ln3193">        goto error;</a>
<a name="ln3194"> </a>
<a name="ln3195">      dev_in = dev_green_eq;</a>
<a name="ln3196">    }</a>
<a name="ln3197"> </a>
<a name="ln3198">    // need to reserve scaled auxiliary buffer or use dev_out</a>
<a name="ln3199">    if(scaled)</a>
<a name="ln3200">    {</a>
<a name="ln3201">      dev_aux = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, 4 * sizeof(float));</a>
<a name="ln3202">      if(dev_aux == NULL) goto error;</a>
<a name="ln3203">      width = roi_in-&gt;width;</a>
<a name="ln3204">      height = roi_in-&gt;height;</a>
<a name="ln3205">    }</a>
<a name="ln3206">    else</a>
<a name="ln3207">      dev_aux = dev_out;</a>
<a name="ln3208"> </a>
<a name="ln3209">    if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln3210">    {</a>
<a name="ln3211">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3212">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_passthrough_monochrome, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln3213">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_passthrough_monochrome, 1, sizeof(cl_mem), &amp;dev_aux);</a>
<a name="ln3214">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_passthrough_monochrome, 2, sizeof(int), &amp;width);</a>
<a name="ln3215">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_passthrough_monochrome, 3, sizeof(int), &amp;height);</a>
<a name="ln3216">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_passthrough_monochrome, sizes);</a>
<a name="ln3217">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3218">    }</a>
<a name="ln3219">    else if(demosaicing_method == DT_IOP_DEMOSAIC_PPG)</a>
<a name="ln3220">    {</a>
<a name="ln3221">      if(data-&gt;median_thrs &gt; 0.0f)</a>
<a name="ln3222">      {</a>
<a name="ln3223">        dt_opencl_local_buffer_t locopt</a>
<a name="ln3224">          = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln3225">                                        .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3226">                                        .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3227"> </a>
<a name="ln3228">        if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_pre_median, &amp;locopt))</a>
<a name="ln3229">        goto error;</a>
<a name="ln3230"> </a>
<a name="ln3231">        size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3232">        size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3233">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln3234">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 1, sizeof(cl_mem), &amp;dev_aux);</a>
<a name="ln3235">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 2, sizeof(int), &amp;width);</a>
<a name="ln3236">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 3, sizeof(int), &amp;height);</a>
<a name="ln3237">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 4, sizeof(uint32_t),</a>
<a name="ln3238">                                 (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3239">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 5, sizeof(float), (void *)&amp;data-&gt;median_thrs);</a>
<a name="ln3240">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 6,</a>
<a name="ln3241">                             (locopt.sizex + 4) * (locopt.sizey + 4) * sizeof(float), NULL);</a>
<a name="ln3242">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_pre_median, sizes, local);</a>
<a name="ln3243">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3244">        dev_in = dev_aux;</a>
<a name="ln3245">      }</a>
<a name="ln3246"> </a>
<a name="ln3247">      dev_tmp = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, 4 * sizeof(float));</a>
<a name="ln3248">      if(dev_tmp == NULL) goto error;</a>
<a name="ln3249"> </a>
<a name="ln3250">      {</a>
<a name="ln3251">        dt_opencl_local_buffer_t locopt</a>
<a name="ln3252">          = (dt_opencl_local_buffer_t){ .xoffset = 2*3, .xfactor = 1, .yoffset = 2*3, .yfactor = 1,</a>
<a name="ln3253">                                        .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3254">                                        .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3255"> </a>
<a name="ln3256">        if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_ppg_green, &amp;locopt))</a>
<a name="ln3257">        goto error;</a>
<a name="ln3258"> </a>
<a name="ln3259">        size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3260">        size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3261">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln3262">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 1, sizeof(cl_mem), &amp;dev_tmp);</a>
<a name="ln3263">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 2, sizeof(int), &amp;width);</a>
<a name="ln3264">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 3, sizeof(int), &amp;height);</a>
<a name="ln3265">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 4, sizeof(uint32_t),</a>
<a name="ln3266">                                 (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3267">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 5,</a>
<a name="ln3268">                             (locopt.sizex + 2*3) * (locopt.sizey + 2*3) * sizeof(float), NULL);</a>
<a name="ln3269"> </a>
<a name="ln3270">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_ppg_green, sizes, local);</a>
<a name="ln3271">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3272">      }</a>
<a name="ln3273"> </a>
<a name="ln3274">      {</a>
<a name="ln3275">        dt_opencl_local_buffer_t locopt</a>
<a name="ln3276">          = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln3277">                                        .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln3278">                                        .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3279"> </a>
<a name="ln3280">        if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_ppg_redblue, &amp;locopt))</a>
<a name="ln3281">        goto error;</a>
<a name="ln3282"> </a>
<a name="ln3283">        size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3284">        size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3285">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 0, sizeof(cl_mem), &amp;dev_tmp);</a>
<a name="ln3286">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 1, sizeof(cl_mem), &amp;dev_aux);</a>
<a name="ln3287">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 2, sizeof(int), &amp;width);</a>
<a name="ln3288">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 3, sizeof(int), &amp;height);</a>
<a name="ln3289">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 4, sizeof(uint32_t),</a>
<a name="ln3290">                                 (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3291">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 5,</a>
<a name="ln3292">                             (locopt.sizex + 2) * (locopt.sizey + 2) * 4 * sizeof(float), NULL);</a>
<a name="ln3293"> </a>
<a name="ln3294">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_ppg_redblue, sizes, local);</a>
<a name="ln3295">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3296">      }</a>
<a name="ln3297"> </a>
<a name="ln3298">      {</a>
<a name="ln3299">        // manage borders</a>
<a name="ln3300">        size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3301">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln3302">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 1, sizeof(cl_mem), &amp;dev_aux);</a>
<a name="ln3303">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3304">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3305">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 4, sizeof(uint32_t),</a>
<a name="ln3306">                                 (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3307">        err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_border_interpolate, sizes);</a>
<a name="ln3308">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3309">      }</a>
<a name="ln3310">    }</a>
<a name="ln3311"> </a>
<a name="ln3312">    if(scaled)</a>
<a name="ln3313">    {</a>
<a name="ln3314">      // scale aux buffer to output buffer</a>
<a name="ln3315">      err = dt_iop_clip_and_zoom_roi_cl(devid, dev_out, dev_aux, roi_out, roi_in);</a>
<a name="ln3316">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3317">    }</a>
<a name="ln3318">  }</a>
<a name="ln3319">  else</a>
<a name="ln3320">  {</a>
<a name="ln3321">    if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln3322">    {</a>
<a name="ln3323">      // sample image:</a>
<a name="ln3324">      const int zero = 0;</a>
<a name="ln3325">      cl_mem dev_pix = dev_in;</a>
<a name="ln3326">      const int width = roi_out-&gt;width;</a>
<a name="ln3327">      const int height = roi_out-&gt;height;</a>
<a name="ln3328"> </a>
<a name="ln3329">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3330">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 0, sizeof(cl_mem), &amp;dev_pix);</a>
<a name="ln3331">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 1, sizeof(cl_mem), &amp;dev_out);</a>
<a name="ln3332">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 2, sizeof(int), &amp;width);</a>
<a name="ln3333">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 3, sizeof(int), &amp;height);</a>
<a name="ln3334">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 4, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3335">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 5, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3336">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 6, sizeof(int),</a>
<a name="ln3337">                               (void *)&amp;roi_in-&gt;width);</a>
<a name="ln3338">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 7, sizeof(int),</a>
<a name="ln3339">                               (void *)&amp;roi_in-&gt;height);</a>
<a name="ln3340">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 8, sizeof(float),</a>
<a name="ln3341">                               (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln3342">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 9, sizeof(uint32_t),</a>
<a name="ln3343">                               (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3344">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_passthrough_monochrome, sizes);</a>
<a name="ln3345">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3346">    }</a>
<a name="ln3347">    else</a>
<a name="ln3348">    {</a>
<a name="ln3349">      // sample half-size image:</a>
<a name="ln3350">      const int zero = 0;</a>
<a name="ln3351">      cl_mem dev_pix = dev_in;</a>
<a name="ln3352">      const int width = roi_out-&gt;width;</a>
<a name="ln3353">      const int height = roi_out-&gt;height;</a>
<a name="ln3354"> </a>
<a name="ln3355">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3356">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 0, sizeof(cl_mem), &amp;dev_pix);</a>
<a name="ln3357">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 1, sizeof(cl_mem), &amp;dev_out);</a>
<a name="ln3358">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 2, sizeof(int), &amp;width);</a>
<a name="ln3359">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 3, sizeof(int), &amp;height);</a>
<a name="ln3360">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 4, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3361">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 5, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3362">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 6, sizeof(int), (void *)&amp;roi_in-&gt;width);</a>
<a name="ln3363">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 7, sizeof(int), (void *)&amp;roi_in-&gt;height);</a>
<a name="ln3364">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 8, sizeof(float), (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln3365">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 9, sizeof(uint32_t),</a>
<a name="ln3366">                               (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3367">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_half_size, sizes);</a>
<a name="ln3368">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3369">    }</a>
<a name="ln3370">  }</a>
<a name="ln3371"> </a>
<a name="ln3372">  if(dev_aux != dev_out) dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln3373">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln3374">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3375">  dev_aux = dev_green_eq = dev_tmp = NULL;</a>
<a name="ln3376"> </a>
<a name="ln3377">  // color smoothing</a>
<a name="ln3378">  if(data-&gt;color_smoothing)</a>
<a name="ln3379">  {</a>
<a name="ln3380">    if(!color_smoothing_cl(self, piece, dev_out, dev_out, roi_out))</a>
<a name="ln3381">      goto error;</a>
<a name="ln3382">  }</a>
<a name="ln3383"> </a>
<a name="ln3384">  return TRUE;</a>
<a name="ln3385"> </a>
<a name="ln3386">error:</a>
<a name="ln3387">  if(dev_aux != dev_out) dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln3388">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln3389">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3390">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3391">  return FALSE;</a>
<a name="ln3392">}</a>
<a name="ln3393"> </a>
<a name="ln3394">static int process_vng_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln3395">                          cl_mem dev_out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln3396">{</a>
<a name="ln3397">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln3398">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;data;</a>
<a name="ln3399">  const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln3400"> </a>
<a name="ln3401">  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece-&gt;pipe-&gt;dsc.xtrans;</a>
<a name="ln3402"> </a>
<a name="ln3403">  // separate out G1 and G2 in Bayer patterns</a>
<a name="ln3404">  uint32_t filters4;</a>
<a name="ln3405">  if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln3406">    filters4 = piece-&gt;pipe-&gt;dsc.filters;</a>
<a name="ln3407">  else if((piece-&gt;pipe-&gt;dsc.filters &amp; 3) == 1)</a>
<a name="ln3408">    filters4 = piece-&gt;pipe-&gt;dsc.filters | 0x03030303u;</a>
<a name="ln3409">  else</a>
<a name="ln3410">    filters4 = piece-&gt;pipe-&gt;dsc.filters | 0x0c0c0c0cu;</a>
<a name="ln3411"> </a>
<a name="ln3412">  const int size = (filters4 == 9u) ? 6 : 16;</a>
<a name="ln3413">  const int colors = (filters4 == 9u) ? 3 : 4;</a>
<a name="ln3414">  const int prow = (filters4 == 9u) ? 6 : 8;</a>
<a name="ln3415">  const int pcol = (filters4 == 9u) ? 6 : 2;</a>
<a name="ln3416">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3417"> </a>
<a name="ln3418">  const float processed_maximum[4]</a>
<a name="ln3419">      = { piece-&gt;pipe-&gt;dsc.processed_maximum[0], piece-&gt;pipe-&gt;dsc.processed_maximum[1],</a>
<a name="ln3420">          piece-&gt;pipe-&gt;dsc.processed_maximum[2], 1.0f };</a>
<a name="ln3421"> </a>
<a name="ln3422">  const int qual_flags = demosaic_qual_flags(piece, img, roi_out);</a>
<a name="ln3423"> </a>
<a name="ln3424">  int *ips = NULL;</a>
<a name="ln3425"> </a>
<a name="ln3426">  cl_mem dev_tmp = NULL;</a>
<a name="ln3427">  cl_mem dev_aux = NULL;</a>
<a name="ln3428">  cl_mem dev_xtrans = NULL;</a>
<a name="ln3429">  cl_mem dev_lookup = NULL;</a>
<a name="ln3430">  cl_mem dev_code = NULL;</a>
<a name="ln3431">  cl_mem dev_ips = NULL;</a>
<a name="ln3432">  cl_mem dev_green_eq = NULL;</a>
<a name="ln3433">  cl_int err = -999;</a>
<a name="ln3434"> </a>
<a name="ln3435">  int32_t(*lookup)[16][32] = NULL;</a>
<a name="ln3436"> </a>
<a name="ln3437">  if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln3438">  {</a>
<a name="ln3439">    dev_xtrans</a>
<a name="ln3440">        = dt_opencl_copy_host_to_device_constant(devid, sizeof(piece-&gt;pipe-&gt;dsc.xtrans), piece-&gt;pipe-&gt;dsc.xtrans);</a>
<a name="ln3441">    if(dev_xtrans == NULL) goto error;</a>
<a name="ln3442">  }</a>
<a name="ln3443"> </a>
<a name="ln3444">  if(qual_flags &amp; DEMOSAIC_FULL_SCALE)</a>
<a name="ln3445">  {</a>
<a name="ln3446">    // Full demosaic and then scaling if needed</a>
<a name="ln3447">    const int scaled = (roi_out-&gt;width != roi_in-&gt;width || roi_out-&gt;height != roi_in-&gt;height);</a>
<a name="ln3448"> </a>
<a name="ln3449">    // build interpolation lookup table for linear interpolation which for a given offset in the sensor</a>
<a name="ln3450">    // lists neighboring pixels from which to interpolate:</a>
<a name="ln3451">    // NUM_PIXELS                 # of neighboring pixels to read</a>
<a name="ln3452">    // for (1..NUM_PIXELS):</a>
<a name="ln3453">    //   OFFSET                   # in bytes from current pixel</a>
<a name="ln3454">    //   WEIGHT                   # how much weight to give this neighbor</a>
<a name="ln3455">    //   COLOR                    # sensor color</a>
<a name="ln3456">    // # weights of adjoining pixels not of this pixel's color</a>
<a name="ln3457">    // COLORA TOT_WEIGHT</a>
<a name="ln3458">    // COLORB TOT_WEIGHT</a>
<a name="ln3459">    // COLORPIX                   # color of center pixel</a>
<a name="ln3460">    const size_t lookup_size = (size_t)16 * 16 * 32 * sizeof(int32_t);</a>
<a name="ln3461">    lookup = malloc(lookup_size);</a>
<a name="ln3462"> </a>
<a name="ln3463">    for(int row = 0; row &lt; size; row++)</a>
<a name="ln3464">      for(int col = 0; col &lt; size; col++)</a>
<a name="ln3465">      {</a>
<a name="ln3466">        int32_t *ip = lookup[row][col] + 1;</a>
<a name="ln3467">        int sum[4] = { 0 };</a>
<a name="ln3468">        const int f = fcol(row + roi_in-&gt;y, col + roi_in-&gt;x, filters4, xtrans);</a>
<a name="ln3469">        // make list of adjoining pixel offsets by weight &amp; color</a>
<a name="ln3470">        for(int y = -1; y &lt;= 1; y++)</a>
<a name="ln3471">          for(int x = -1; x &lt;= 1; x++)</a>
<a name="ln3472">          {</a>
<a name="ln3473">            int weight = 1 &lt;&lt; ((y == 0) + (x == 0));</a>
<a name="ln3474">            const int color = fcol(row + y + roi_in-&gt;y, col + x + roi_in-&gt;x, filters4, xtrans);</a>
<a name="ln3475">            if(color == f) continue;</a>
<a name="ln3476">            *ip++ = (y &lt;&lt; 16) | (x &amp; 0xffffu);</a>
<a name="ln3477">            *ip++ = weight;</a>
<a name="ln3478">            *ip++ = color;</a>
<a name="ln3479">            sum[color] += weight;</a>
<a name="ln3480">          }</a>
<a name="ln3481">        lookup[row][col][0] = (ip - lookup[row][col]) / 3; /* # of neighboring pixels found */</a>
<a name="ln3482">        for(int c = 0; c &lt; colors; c++)</a>
<a name="ln3483">          if(c != f)</a>
<a name="ln3484">          {</a>
<a name="ln3485">            *ip++ = c;</a>
<a name="ln3486">            *ip++ = sum[c];</a>
<a name="ln3487">          }</a>
<a name="ln3488">        *ip = f;</a>
<a name="ln3489">      }</a>
<a name="ln3490"> </a>
<a name="ln3491">    // Precalculate for VNG</a>
<a name="ln3492">    static const signed char terms[]</a>
<a name="ln3493">      = { -2, -2, +0, -1, 1, 0x01, -2, -2, +0, +0, 2, 0x01, -2, -1, -1, +0, 1, 0x01, -2, -1, +0, -1, 1, 0x02,</a>
<a name="ln3494">          -2, -1, +0, +0, 1, 0x03, -2, -1, +0, +1, 2, 0x01, -2, +0, +0, -1, 1, 0x06, -2, +0, +0, +0, 2, 0x02,</a>
<a name="ln3495">          -2, +0, +0, +1, 1, 0x03, -2, +1, -1, +0, 1, 0x04, -2, +1, +0, -1, 2, 0x04, -2, +1, +0, +0, 1, 0x06,</a>
<a name="ln3496">          -2, +1, +0, +1, 1, 0x02, -2, +2, +0, +0, 2, 0x04, -2, +2, +0, +1, 1, 0x04, -1, -2, -1, +0, 1, 0x80,</a>
<a name="ln3497">          -1, -2, +0, -1, 1, 0x01, -1, -2, +1, -1, 1, 0x01, -1, -2, +1, +0, 2, 0x01, -1, -1, -1, +1, 1, 0x88,</a>
<a name="ln3498">          -1, -1, +1, -2, 1, 0x40, -1, -1, +1, -1, 1, 0x22, -1, -1, +1, +0, 1, 0x33, -1, -1, +1, +1, 2, 0x11,</a>
<a name="ln3499">          -1, +0, -1, +2, 1, 0x08, -1, +0, +0, -1, 1, 0x44, -1, +0, +0, +1, 1, 0x11, -1, +0, +1, -2, 2, 0x40,</a>
<a name="ln3500">          -1, +0, +1, -1, 1, 0x66, -1, +0, +1, +0, 2, 0x22, -1, +0, +1, +1, 1, 0x33, -1, +0, +1, +2, 2, 0x10,</a>
<a name="ln3501">          -1, +1, +1, -1, 2, 0x44, -1, +1, +1, +0, 1, 0x66, -1, +1, +1, +1, 1, 0x22, -1, +1, +1, +2, 1, 0x10,</a>
<a name="ln3502">          -1, +2, +0, +1, 1, 0x04, -1, +2, +1, +0, 2, 0x04, -1, +2, +1, +1, 1, 0x04, +0, -2, +0, +0, 2, 0x80,</a>
<a name="ln3503">          +0, -1, +0, +1, 2, 0x88, +0, -1, +1, -2, 1, 0x40, +0, -1, +1, +0, 1, 0x11, +0, -1, +2, -2, 1, 0x40,</a>
<a name="ln3504">          +0, -1, +2, -1, 1, 0x20, +0, -1, +2, +0, 1, 0x30, +0, -1, +2, +1, 2, 0x10, +0, +0, +0, +2, 2, 0x08,</a>
<a name="ln3505">          +0, +0, +2, -2, 2, 0x40, +0, +0, +2, -1, 1, 0x60, +0, +0, +2, +0, 2, 0x20, +0, +0, +2, +1, 1, 0x30,</a>
<a name="ln3506">          +0, +0, +2, +2, 2, 0x10, +0, +1, +1, +0, 1, 0x44, +0, +1, +1, +2, 1, 0x10, +0, +1, +2, -1, 2, 0x40,</a>
<a name="ln3507">          +0, +1, +2, +0, 1, 0x60, +0, +1, +2, +1, 1, 0x20, +0, +1, +2, +2, 1, 0x10, +1, -2, +1, +0, 1, 0x80,</a>
<a name="ln3508">          +1, -1, +1, +1, 1, 0x88, +1, +0, +1, +2, 1, 0x08, +1, +0, +2, -1, 1, 0x40, +1, +0, +2, +1, 1, 0x10 };</a>
<a name="ln3509">    static const signed char chood[]</a>
<a name="ln3510">      = { -1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1 };</a>
<a name="ln3511"> </a>
<a name="ln3512">    const size_t ips_size = (size_t)prow * pcol * 352 * sizeof(int);</a>
<a name="ln3513">    ips = malloc(ips_size);</a>
<a name="ln3514"> </a>
<a name="ln3515">    int *ip = ips;</a>
<a name="ln3516">    int code[16][16];</a>
<a name="ln3517"> </a>
<a name="ln3518">    for(int row = 0; row &lt; prow; row++)</a>
<a name="ln3519">      for(int col = 0; col &lt; pcol; col++)</a>
<a name="ln3520">      {</a>
<a name="ln3521">        code[row][col] = ip - ips;</a>
<a name="ln3522">        const signed char *cp = terms;</a>
<a name="ln3523">        for(int t = 0; t &lt; 64; t++)</a>
<a name="ln3524">        {</a>
<a name="ln3525">          int y1 = *cp++, x1 = *cp++;</a>
<a name="ln3526">          int y2 = *cp++, x2 = *cp++;</a>
<a name="ln3527">          int weight = *cp++;</a>
<a name="ln3528">          int grads = *cp++;</a>
<a name="ln3529">          int color = fcol(row + y1, col + x1, filters4, xtrans);</a>
<a name="ln3530">          if(fcol(row + y2, col + x2, filters4, xtrans) != color) continue;</a>
<a name="ln3531">          int diag</a>
<a name="ln3532">              = (fcol(row, col + 1, filters4, xtrans) == color &amp;&amp; fcol(row + 1, col, filters4, xtrans) == color)</a>
<a name="ln3533">                    ? 2</a>
<a name="ln3534">                    : 1;</a>
<a name="ln3535">          if(abs(y1 - y2) == diag &amp;&amp; abs(x1 - x2) == diag) continue;</a>
<a name="ln3536">          *ip++ = (y1 &lt;&lt; 16) | (x1 &amp; 0xffffu);</a>
<a name="ln3537">          *ip++ = (y2 &lt;&lt; 16) | (x2 &amp; 0xffffu);</a>
<a name="ln3538">          *ip++ = (color &lt;&lt; 16) | (weight &amp; 0xffffu);</a>
<a name="ln3539">          for(int g = 0; g &lt; 8; g++)</a>
<a name="ln3540">            if(grads &amp; 1 &lt;&lt; g) *ip++ = g;</a>
<a name="ln3541">          *ip++ = -1;</a>
<a name="ln3542">        }</a>
<a name="ln3543">        *ip++ = INT_MAX;</a>
<a name="ln3544">        cp = chood;</a>
<a name="ln3545">        for(int g = 0; g &lt; 8; g++)</a>
<a name="ln3546">        {</a>
<a name="ln3547">          int y = *cp++, x = *cp++;</a>
<a name="ln3548">          *ip++ = (y &lt;&lt; 16) | (x &amp; 0xffffu);</a>
<a name="ln3549">          int color = fcol(row, col, filters4, xtrans);</a>
<a name="ln3550">          if(fcol(row + y, col + x, filters4, xtrans) != color</a>
<a name="ln3551">             &amp;&amp; fcol(row + y * 2, col + x * 2, filters4, xtrans) == color)</a>
<a name="ln3552">          {</a>
<a name="ln3553">            *ip++ = (2*y &lt;&lt; 16) | (2*x &amp; 0xffffu);</a>
<a name="ln3554">            *ip++ = color;</a>
<a name="ln3555">          }</a>
<a name="ln3556">          else</a>
<a name="ln3557">          {</a>
<a name="ln3558">            *ip++ = 0;</a>
<a name="ln3559">            *ip++ = 0;</a>
<a name="ln3560">          }</a>
<a name="ln3561">        }</a>
<a name="ln3562">      }</a>
<a name="ln3563"> </a>
<a name="ln3564"> </a>
<a name="ln3565">    dev_lookup = dt_opencl_copy_host_to_device_constant(devid, lookup_size, lookup);</a>
<a name="ln3566">    if(dev_lookup == NULL) goto error;</a>
<a name="ln3567"> </a>
<a name="ln3568">    dev_code = dt_opencl_copy_host_to_device_constant(devid, sizeof(code), code);</a>
<a name="ln3569">    if(dev_code == NULL) goto error;</a>
<a name="ln3570"> </a>
<a name="ln3571">    dev_ips = dt_opencl_copy_host_to_device_constant(devid, ips_size, ips);</a>
<a name="ln3572">    if(dev_ips == NULL) goto error;</a>
<a name="ln3573"> </a>
<a name="ln3574">    // green equilibration for Bayer sensors</a>
<a name="ln3575">    if(piece-&gt;pipe-&gt;dsc.filters != 9u &amp;&amp; data-&gt;green_eq != DT_IOP_GREEN_EQ_NO)</a>
<a name="ln3576">    {</a>
<a name="ln3577">      dev_green_eq = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, sizeof(float));</a>
<a name="ln3578">      if(dev_green_eq == NULL) goto error;</a>
<a name="ln3579"> </a>
<a name="ln3580">      if(!green_equilibration_cl(self, piece, dev_in, dev_green_eq, roi_in))</a>
<a name="ln3581">        goto error;</a>
<a name="ln3582"> </a>
<a name="ln3583">      dev_in = dev_green_eq;</a>
<a name="ln3584">    }</a>
<a name="ln3585"> </a>
<a name="ln3586">    int width = roi_out-&gt;width;</a>
<a name="ln3587">    int height = roi_out-&gt;height;</a>
<a name="ln3588"> </a>
<a name="ln3589">    // need to reserve scaled auxiliary buffer or use dev_out</a>
<a name="ln3590">    if(scaled)</a>
<a name="ln3591">    {</a>
<a name="ln3592">      dev_aux = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, 4 * sizeof(float));</a>
<a name="ln3593">      if(dev_aux == NULL) goto error;</a>
<a name="ln3594">      width = roi_in-&gt;width;</a>
<a name="ln3595">      height = roi_in-&gt;height;</a>
<a name="ln3596">    }</a>
<a name="ln3597">    else</a>
<a name="ln3598">      dev_aux = dev_out;</a>
<a name="ln3599"> </a>
<a name="ln3600">    dev_tmp = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, 4 * sizeof(float));</a>
<a name="ln3601">    if(dev_tmp == NULL) goto error;</a>
<a name="ln3602"> </a>
<a name="ln3603">    {</a>
<a name="ln3604">      // manage borders for linear interpolation part</a>
<a name="ln3605">      const int border = 1;</a>
<a name="ln3606"> </a>
<a name="ln3607">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3608">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3609">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3610">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3611">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3612">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 4, sizeof(int), (void *)&amp;border);</a>
<a name="ln3613">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 5, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3614">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 6, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3615">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 7, sizeof(uint32_t), (void *)&amp;filters4);</a>
<a name="ln3616">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3617">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_vng_border_interpolate, sizes);</a>
<a name="ln3618">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3619">    }</a>
<a name="ln3620"> </a>
<a name="ln3621">    {</a>
<a name="ln3622">      // do linear interpolation</a>
<a name="ln3623">      dt_opencl_local_buffer_t locopt</a>
<a name="ln3624">        = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln3625">                                      .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3626">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3627"> </a>
<a name="ln3628">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_vng_lin_interpolate, &amp;locopt))</a>
<a name="ln3629">        goto error;</a>
<a name="ln3630"> </a>
<a name="ln3631">      size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3632">      size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3633">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3634">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3635">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3636">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3637">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 4, sizeof(uint32_t), (void *)&amp;filters4);</a>
<a name="ln3638">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 5, sizeof(cl_mem), (void *)&amp;dev_lookup);</a>
<a name="ln3639">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 6,</a>
<a name="ln3640">                               (locopt.sizex + 2) * (locopt.sizey + 2) * sizeof(float), NULL);</a>
<a name="ln3641">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_vng_lin_interpolate, sizes, local);</a>
<a name="ln3642">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3643">    }</a>
<a name="ln3644"> </a>
<a name="ln3645"> </a>
<a name="ln3646">    if(qual_flags &amp; DEMOSAIC_ONLY_VNG_LINEAR)</a>
<a name="ln3647">    {</a>
<a name="ln3648">      // leave it at linear interpolation and skip VNG</a>
<a name="ln3649">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3650">      size_t region[] = { width, height, 1 };</a>
<a name="ln3651">      err = dt_opencl_enqueue_copy_image(devid, dev_tmp, dev_aux, origin, origin, region);</a>
<a name="ln3652">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3653">    }</a>
<a name="ln3654">    else</a>
<a name="ln3655">    {</a>
<a name="ln3656">      // do full VNG interpolation</a>
<a name="ln3657">      dt_opencl_local_buffer_t locopt</a>
<a name="ln3658">        = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln3659">                                      .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln3660">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3661"> </a>
<a name="ln3662">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_vng_interpolate, &amp;locopt))</a>
<a name="ln3663">        goto error;</a>
<a name="ln3664"> </a>
<a name="ln3665">      size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3666">      size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3667">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3668">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln3669">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3670">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3671">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3672">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3673">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 6, sizeof(uint32_t), (void *)&amp;filters4);</a>
<a name="ln3674">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 7, 4*sizeof(float), (void *)processed_maximum);</a>
<a name="ln3675">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3676">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 9, sizeof(cl_mem), (void *)&amp;dev_ips);</a>
<a name="ln3677">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 10, sizeof(cl_mem), (void *)&amp;dev_code);</a>
<a name="ln3678">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 11, (locopt.sizex + 4) * (locopt.sizey + 4) * 4 * sizeof(float), NULL);</a>
<a name="ln3679">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_vng_interpolate, sizes, local);</a>
<a name="ln3680">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3681">    }</a>
<a name="ln3682"> </a>
<a name="ln3683">    {</a>
<a name="ln3684">      // manage borders</a>
<a name="ln3685">      const int border = 2;</a>
<a name="ln3686"> </a>
<a name="ln3687">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3688">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3689">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln3690">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3691">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3692">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 4, sizeof(int), (void *)&amp;border);</a>
<a name="ln3693">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 5, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3694">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 6, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3695">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 7, sizeof(uint32_t), (void *)&amp;filters4);</a>
<a name="ln3696">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3697">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_vng_border_interpolate, sizes);</a>
<a name="ln3698">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3699">    }</a>
<a name="ln3700"> </a>
<a name="ln3701">    if(filters4 != 9)</a>
<a name="ln3702">    {</a>
<a name="ln3703">      // for Bayer sensors mix the two green channels</a>
<a name="ln3704">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3705">      size_t region[] = { width, height, 1 };</a>
<a name="ln3706">      err = dt_opencl_enqueue_copy_image(devid, dev_aux, dev_tmp, origin, origin, region);</a>
<a name="ln3707">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3708"> </a>
<a name="ln3709">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3710">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_green_equilibrate, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3711">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_green_equilibrate, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln3712">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_green_equilibrate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3713">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_green_equilibrate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3714">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_vng_green_equilibrate, sizes);</a>
<a name="ln3715">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3716">    }</a>
<a name="ln3717"> </a>
<a name="ln3718">    if(scaled)</a>
<a name="ln3719">    {</a>
<a name="ln3720">      // scale temp buffer to output buffer</a>
<a name="ln3721">      err = dt_iop_clip_and_zoom_roi_cl(devid, dev_out, dev_aux, roi_out, roi_in);</a>
<a name="ln3722">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3723">    }</a>
<a name="ln3724">  }</a>
<a name="ln3725">  else</a>
<a name="ln3726">  {</a>
<a name="ln3727">    // sample half-size or third-size image</a>
<a name="ln3728">    if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln3729">    {</a>
<a name="ln3730">      const int width = roi_out-&gt;width;</a>
<a name="ln3731">      const int height = roi_out-&gt;height;</a>
<a name="ln3732"> </a>
<a name="ln3733">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3734">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3735">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3736">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3737">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3738">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3739">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3740">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 6, sizeof(int), (void *)&amp;roi_in-&gt;width);</a>
<a name="ln3741">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 7, sizeof(int), (void *)&amp;roi_in-&gt;height);</a>
<a name="ln3742">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 8, sizeof(float), (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln3743">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 9, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3744">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_third_size, sizes);</a>
<a name="ln3745">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3746">    }</a>
<a name="ln3747">    else</a>
<a name="ln3748">    {</a>
<a name="ln3749">      const int zero = 0;</a>
<a name="ln3750">      const int width = roi_out-&gt;width;</a>
<a name="ln3751">      const int height = roi_out-&gt;height;</a>
<a name="ln3752"> </a>
<a name="ln3753">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3754">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3755">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3756">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3757">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3758">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 4, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3759">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 5, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3760">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 6, sizeof(int), (void *)&amp;roi_in-&gt;width);</a>
<a name="ln3761">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 7, sizeof(int), (void *)&amp;roi_in-&gt;height);</a>
<a name="ln3762">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 8, sizeof(float), (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln3763">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 9, sizeof(uint32_t),</a>
<a name="ln3764">                               (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3765">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_half_size, sizes);</a>
<a name="ln3766">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3767">    }</a>
<a name="ln3768">  }</a>
<a name="ln3769"> </a>
<a name="ln3770"> </a>
<a name="ln3771">  if(dev_aux != dev_out) dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln3772">  dev_aux = NULL;</a>
<a name="ln3773"> </a>
<a name="ln3774">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3775">  dev_tmp = NULL;</a>
<a name="ln3776"> </a>
<a name="ln3777">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln3778">  dev_xtrans = NULL;</a>
<a name="ln3779"> </a>
<a name="ln3780">  dt_opencl_release_mem_object(dev_lookup);</a>
<a name="ln3781">  dev_lookup = NULL;</a>
<a name="ln3782"> </a>
<a name="ln3783">  free(lookup);</a>
<a name="ln3784"> </a>
<a name="ln3785">  dt_opencl_release_mem_object(dev_code);</a>
<a name="ln3786">  dev_code = NULL;</a>
<a name="ln3787"> </a>
<a name="ln3788">  dt_opencl_release_mem_object(dev_ips);</a>
<a name="ln3789">  dev_ips = NULL;</a>
<a name="ln3790"> </a>
<a name="ln3791">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln3792">  dev_green_eq = NULL;</a>
<a name="ln3793"> </a>
<a name="ln3794">  free(ips);</a>
<a name="ln3795">  ips = NULL;</a>
<a name="ln3796"> </a>
<a name="ln3797">  // color smoothing</a>
<a name="ln3798">  if(data-&gt;color_smoothing)</a>
<a name="ln3799">  {</a>
<a name="ln3800">    if(!color_smoothing_cl(self, piece, dev_out, dev_out, roi_out))</a>
<a name="ln3801">      goto error;</a>
<a name="ln3802">  }</a>
<a name="ln3803"> </a>
<a name="ln3804">  return TRUE;</a>
<a name="ln3805"> </a>
<a name="ln3806">error:</a>
<a name="ln3807">  if(dev_aux != dev_out) dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln3808">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3809">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln3810">  dt_opencl_release_mem_object(dev_lookup);</a>
<a name="ln3811">  free(lookup);</a>
<a name="ln3812">  dt_opencl_release_mem_object(dev_code);</a>
<a name="ln3813">  dt_opencl_release_mem_object(dev_ips);</a>
<a name="ln3814">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln3815">  free(ips);</a>
<a name="ln3816">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3817">  return FALSE;</a>
<a name="ln3818">}</a>
<a name="ln3819"> </a>
<a name="ln3820">static int process_markesteijn_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln3821">                                  cl_mem dev_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln3822">                                  const dt_iop_roi_t *const roi_out)</a>
<a name="ln3823">{</a>
<a name="ln3824">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln3825">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;data;</a>
<a name="ln3826"> </a>
<a name="ln3827">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3828">  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece-&gt;pipe-&gt;dsc.xtrans;</a>
<a name="ln3829"> </a>
<a name="ln3830">  const float processed_maximum[4]</a>
<a name="ln3831">      = { piece-&gt;pipe-&gt;dsc.processed_maximum[0], piece-&gt;pipe-&gt;dsc.processed_maximum[1],</a>
<a name="ln3832">          piece-&gt;pipe-&gt;dsc.processed_maximum[2], 1.0f };</a>
<a name="ln3833"> </a>
<a name="ln3834">  const int qual_flags = demosaic_qual_flags(piece, &amp;self-&gt;dev-&gt;image_storage, roi_out);</a>
<a name="ln3835"> </a>
<a name="ln3836">  cl_mem dev_tmp = NULL;</a>
<a name="ln3837">  cl_mem dev_tmptmp = NULL;</a>
<a name="ln3838">  cl_mem dev_xtrans = NULL;</a>
<a name="ln3839">  cl_mem dev_green_eq = NULL;</a>
<a name="ln3840">  cl_mem dev_rgbv[8] = { NULL };</a>
<a name="ln3841">  cl_mem dev_drv[8] = { NULL };</a>
<a name="ln3842">  cl_mem dev_homo[8] = { NULL };</a>
<a name="ln3843">  cl_mem dev_homosum[8] = { NULL };</a>
<a name="ln3844">  cl_mem dev_gminmax = NULL;</a>
<a name="ln3845">  cl_mem dev_allhex = NULL;</a>
<a name="ln3846">  cl_mem dev_aux = NULL;</a>
<a name="ln3847">  cl_mem dev_edge_in = NULL;</a>
<a name="ln3848">  cl_mem dev_edge_out = NULL;</a>
<a name="ln3849">  cl_int err = -999;</a>
<a name="ln3850"> </a>
<a name="ln3851">  cl_mem *dev_rgb = dev_rgbv;</a>
<a name="ln3852"> </a>
<a name="ln3853">  dev_xtrans</a>
<a name="ln3854">      = dt_opencl_copy_host_to_device_constant(devid, sizeof(piece-&gt;pipe-&gt;dsc.xtrans), piece-&gt;pipe-&gt;dsc.xtrans);</a>
<a name="ln3855">  if(dev_xtrans == NULL) goto error;</a>
<a name="ln3856"> </a>
<a name="ln3857">  if(qual_flags &amp; DEMOSAIC_FULL_SCALE)</a>
<a name="ln3858">  {</a>
<a name="ln3859">    // Full demosaic and then scaling if needed</a>
<a name="ln3860">    const int scaled = (roi_out-&gt;width != roi_in-&gt;width || roi_out-&gt;height != roi_in-&gt;height);</a>
<a name="ln3861"> </a>
<a name="ln3862">    int width = roi_in-&gt;width;</a>
<a name="ln3863">    int height = roi_in-&gt;height;</a>
<a name="ln3864">    const int passes = (data-&gt;demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3) ? 3 : 1;</a>
<a name="ln3865">    const int ndir = 4 &lt;&lt; (passes &gt; 1);</a>
<a name="ln3866">    const int pad_tile = (passes == 1) ? 12 : 17;</a>
<a name="ln3867"> </a>
<a name="ln3868">    static const short orth[12] = { 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1 },</a>
<a name="ln3869">                       patt[2][16] = { { 0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0 },</a>
<a name="ln3870">                                       { 0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1 } };</a>
<a name="ln3871"> </a>
<a name="ln3872">    // allhex contains the offset coordinates (x,y) of a green hexagon around each</a>
<a name="ln3873">    // non-green pixel and vice versa</a>
<a name="ln3874">    char allhex[3][3][8][2];</a>
<a name="ln3875">    // sgreen is the offset in the sensor matrix of the solitary</a>
<a name="ln3876">    // green pixels (initialized here only to avoid compiler warning)</a>
<a name="ln3877">    char sgreen[2] = { 0 };</a>
<a name="ln3878"> </a>
<a name="ln3879">    // Map a green hexagon around each non-green pixel and vice versa:</a>
<a name="ln3880">    for(int row = 0; row &lt; 3; row++)</a>
<a name="ln3881">      for(int col = 0; col &lt; 3; col++)</a>
<a name="ln3882">        for(int ng = 0, d = 0; d &lt; 10; d += 2)</a>
<a name="ln3883">        {</a>
<a name="ln3884">          int g = FCxtrans(row, col, NULL, xtrans) == 1;</a>
<a name="ln3885">          if(FCxtrans(row + orth[d] + 6, col + orth[d + 2] + 6, NULL, xtrans) == 1)</a>
<a name="ln3886">            ng = 0;</a>
<a name="ln3887">          else</a>
<a name="ln3888">            ng++;</a>
<a name="ln3889">          // if there are four non-green pixels adjacent in cardinal</a>
<a name="ln3890">          // directions, this is the solitary green pixel</a>
<a name="ln3891">          if(ng == 4)</a>
<a name="ln3892">          {</a>
<a name="ln3893">            sgreen[0] = col;</a>
<a name="ln3894">            sgreen[1] = row;</a>
<a name="ln3895">          }</a>
<a name="ln3896">          if(ng == g + 1)</a>
<a name="ln3897">            for(int c = 0; c &lt; 8; c++)</a>
<a name="ln3898">            {</a>
<a name="ln3899">              int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];</a>
<a name="ln3900">              int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];</a>
<a name="ln3901"> </a>
<a name="ln3902">              allhex[row][col][c ^ (g * 2 &amp; d)][0] = h;</a>
<a name="ln3903">              allhex[row][col][c ^ (g * 2 &amp; d)][1] = v;</a>
<a name="ln3904">            }</a>
<a name="ln3905">        }</a>
<a name="ln3906"> </a>
<a name="ln3907">    dev_allhex = dt_opencl_copy_host_to_device_constant(devid, sizeof(allhex), allhex);</a>
<a name="ln3908">    if(dev_allhex == NULL) goto error;</a>
<a name="ln3909"> </a>
<a name="ln3910">    for(int n = 0; n &lt; ndir; n++)</a>
<a name="ln3911">    {</a>
<a name="ln3912">      dev_rgbv[n] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln3913">      if(dev_rgbv[n] == NULL) goto error;</a>
<a name="ln3914">    }</a>
<a name="ln3915"> </a>
<a name="ln3916">    dev_gminmax = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * 2 * sizeof(float));</a>
<a name="ln3917">    if(dev_gminmax == NULL) goto error;</a>
<a name="ln3918"> </a>
<a name="ln3919">    dev_aux = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln3920">    if(dev_aux == NULL) goto error;</a>
<a name="ln3921"> </a>
<a name="ln3922">    if(scaled)</a>
<a name="ln3923">    {</a>
<a name="ln3924">      // need to scale to right res</a>
<a name="ln3925">      dev_tmp = dt_opencl_alloc_device(devid, (size_t)width, height, 4 * sizeof(float));</a>
<a name="ln3926">      if(dev_tmp == NULL) goto error;</a>
<a name="ln3927">    }</a>
<a name="ln3928">    else</a>
<a name="ln3929">    {</a>
<a name="ln3930">      // scaling factor 1.0 --&gt; we can directly process into the output buffer</a>
<a name="ln3931">      dev_tmp = dev_out;</a>
<a name="ln3932">    }</a>
<a name="ln3933"> </a>
<a name="ln3934">    {</a>
<a name="ln3935">      // copy from dev_in to first rgb image buffer.</a>
<a name="ln3936">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3937">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3938">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 1, sizeof(cl_mem), (void *)&amp;dev_rgb[0]);</a>
<a name="ln3939">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3940">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3941">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3942">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3943">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 6, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3944">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_initial_copy, sizes);</a>
<a name="ln3945">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3946">    }</a>
<a name="ln3947"> </a>
<a name="ln3948"> </a>
<a name="ln3949">    // duplicate dev_rgb[0] to dev_rgb[1], dev_rgb[2], and dev_rgb[3]</a>
<a name="ln3950">    for(int c = 1; c &lt;= 3; c++)</a>
<a name="ln3951">    {</a>
<a name="ln3952">      err = dt_opencl_enqueue_copy_buffer_to_buffer(devid, dev_rgb[0], dev_rgb[c], 0, 0,</a>
<a name="ln3953">                                                    (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln3954">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3955">    }</a>
<a name="ln3956"> </a>
<a name="ln3957">    // find minimum and maximum allowed green values of red/blue pixel pairs</a>
<a name="ln3958">    const int pad_g1_g3 = 3;</a>
<a name="ln3959">    dt_opencl_local_buffer_t locopt_g1_g3</a>
<a name="ln3960">      = (dt_opencl_local_buffer_t){ .xoffset = 2*3, .xfactor = 1, .yoffset = 2*3, .yfactor = 1,</a>
<a name="ln3961">                                    .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3962">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3963"> </a>
<a name="ln3964">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_green_minmax, &amp;locopt_g1_g3))</a>
<a name="ln3965">      goto error;</a>
<a name="ln3966"> </a>
<a name="ln3967">    {</a>
<a name="ln3968">      size_t sizes[3] = { ROUNDUP(width, locopt_g1_g3.sizex), ROUNDUP(height, locopt_g1_g3.sizey), 1 };</a>
<a name="ln3969">      size_t local[3] = { locopt_g1_g3.sizex, locopt_g1_g3.sizey, 1 };</a>
<a name="ln3970">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[0]);</a>
<a name="ln3971">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 1, sizeof(cl_mem), (void *)&amp;dev_gminmax);</a>
<a name="ln3972">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3973">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3974">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 4, sizeof(int), (void *)&amp;pad_g1_g3);</a>
<a name="ln3975">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 5, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3976">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 6, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3977">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 7, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln3978">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3979">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 9, sizeof(cl_mem), (void *)&amp;dev_allhex);</a>
<a name="ln3980">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 10,</a>
<a name="ln3981">                               (locopt_g1_g3.sizex + 2*3) * (locopt_g1_g3.sizey + 2*3) * sizeof(float), NULL);</a>
<a name="ln3982">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_green_minmax, sizes, local);</a>
<a name="ln3983">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3984">    }</a>
<a name="ln3985"> </a>
<a name="ln3986">    // interpolate green horizontally, vertically, and along both diagonals</a>
<a name="ln3987">    const int pad_g_interp = 3;</a>
<a name="ln3988">    dt_opencl_local_buffer_t locopt_g_interp</a>
<a name="ln3989">      = (dt_opencl_local_buffer_t){ .xoffset = 2*6, .xfactor = 1, .yoffset = 2*6, .yfactor = 1,</a>
<a name="ln3990">                                    .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln3991">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3992"> </a>
<a name="ln3993">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_interpolate_green, &amp;locopt_g_interp))</a>
<a name="ln3994">      goto error;</a>
<a name="ln3995"> </a>
<a name="ln3996">    {</a>
<a name="ln3997">      size_t sizes[3] = { ROUNDUP(width, locopt_g_interp.sizex), ROUNDUP(height, locopt_g_interp.sizey), 1 };</a>
<a name="ln3998">      size_t local[3] = { locopt_g_interp.sizex, locopt_g_interp.sizey, 1 };</a>
<a name="ln3999">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[0]);</a>
<a name="ln4000">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 1, sizeof(cl_mem), (void *)&amp;dev_rgb[1]);</a>
<a name="ln4001">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 2, sizeof(cl_mem), (void *)&amp;dev_rgb[2]);</a>
<a name="ln4002">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 3, sizeof(cl_mem), (void *)&amp;dev_rgb[3]);</a>
<a name="ln4003">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 4, sizeof(cl_mem), (void *)&amp;dev_gminmax);</a>
<a name="ln4004">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 5, sizeof(int), (void *)&amp;width);</a>
<a name="ln4005">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 6, sizeof(int), (void *)&amp;height);</a>
<a name="ln4006">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 7, sizeof(int), (void *)&amp;pad_g_interp);</a>
<a name="ln4007">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 8, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4008">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 9, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4009">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 10, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4010">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 11, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4011">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 12, sizeof(cl_mem), (void *)&amp;dev_allhex);</a>
<a name="ln4012">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 13,</a>
<a name="ln4013">                               (locopt_g_interp.sizex + 2*6) * (locopt_g_interp.sizey + 2*6) * 4 * sizeof(float), NULL);</a>
<a name="ln4014">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_interpolate_green, sizes, local);</a>
<a name="ln4015">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4016">    }</a>
<a name="ln4017"> </a>
<a name="ln4018">    // multi-pass loop: one pass for Markesteijn-1 and three passes for Markesteijn-3</a>
<a name="ln4019">    for(int pass = 0; pass &lt; passes; pass++)</a>
<a name="ln4020">    {</a>
<a name="ln4021"> </a>
<a name="ln4022">      // if on second pass, copy rgb[0] to [3] into rgb[4] to [7] ....</a>
<a name="ln4023">      if(pass == 1)</a>
<a name="ln4024">      {</a>
<a name="ln4025">        for(int c = 0; c &lt; 4; c++)</a>
<a name="ln4026">        {</a>
<a name="ln4027">          err = dt_opencl_enqueue_copy_buffer_to_buffer(devid, dev_rgb[c], dev_rgb[c + 4], 0, 0,</a>
<a name="ln4028">                                                        (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln4029">          if(err != CL_SUCCESS) goto error;</a>
<a name="ln4030">        }</a>
<a name="ln4031">        // ... and process that second set of buffers</a>
<a name="ln4032">        dev_rgb += 4;</a>
<a name="ln4033">      }</a>
<a name="ln4034"> </a>
<a name="ln4035">      // second and third pass (only Markesteijn-3)</a>
<a name="ln4036">      if(pass)</a>
<a name="ln4037">      {</a>
<a name="ln4038">        // recalculate green from interpolated values of closer pixels</a>
<a name="ln4039">        const int pad_g_recalc = 6;</a>
<a name="ln4040">        size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4041">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[0]);</a>
<a name="ln4042">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 1, sizeof(cl_mem), (void *)&amp;dev_rgb[1]);</a>
<a name="ln4043">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 2, sizeof(cl_mem), (void *)&amp;dev_rgb[2]);</a>
<a name="ln4044">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 3, sizeof(cl_mem), (void *)&amp;dev_rgb[3]);</a>
<a name="ln4045">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 4, sizeof(cl_mem), (void *)&amp;dev_gminmax);</a>
<a name="ln4046">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 5, sizeof(int), (void *)&amp;width);</a>
<a name="ln4047">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 6, sizeof(int), (void *)&amp;height);</a>
<a name="ln4048">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 7, sizeof(int), (void *)&amp;pad_g_recalc);</a>
<a name="ln4049">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 8, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4050">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 9, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4051">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 10, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4052">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 11, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4053">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 12, sizeof(cl_mem), (void *)&amp;dev_allhex);</a>
<a name="ln4054">        err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_recalculate_green, sizes);</a>
<a name="ln4055">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln4056">      }</a>
<a name="ln4057"> </a>
<a name="ln4058">      // interpolate red and blue values for solitary green pixels</a>
<a name="ln4059">      const int pad_rb_g = (passes == 1) ? 6 : 5;</a>
<a name="ln4060">      dt_opencl_local_buffer_t locopt_rb_g</a>
<a name="ln4061">        = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln4062">                                      .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4063">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4064"> </a>
<a name="ln4065">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_solitary_green, &amp;locopt_rb_g))</a>
<a name="ln4066">      goto error;</a>
<a name="ln4067"> </a>
<a name="ln4068">      cl_mem *dev_trgb = dev_rgb;</a>
<a name="ln4069">      for(int d = 0, i = 1, h = 0; d &lt; 6; d++, i ^= 1, h ^= 2)</a>
<a name="ln4070">      {</a>
<a name="ln4071">        const char dir[2] = { i, i ^ 1 };</a>
<a name="ln4072"> </a>
<a name="ln4073">        // we use dev_aux to transport intermediate results from one loop run to the next</a>
<a name="ln4074">        size_t sizes[3] = { ROUNDUP(width, locopt_rb_g.sizex), ROUNDUP(height, locopt_rb_g.sizey), 1 };</a>
<a name="ln4075">        size_t local[3] = { locopt_rb_g.sizex, locopt_rb_g.sizey, 1 };</a>
<a name="ln4076">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 0, sizeof(cl_mem), (void *)&amp;dev_trgb[0]);</a>
<a name="ln4077">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4078">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4079">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4080">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 4, sizeof(int), (void *)&amp;pad_rb_g);</a>
<a name="ln4081">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 5, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4082">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 6, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4083">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 7, sizeof(int), (void *)&amp;d);</a>
<a name="ln4084">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 8, 2 * sizeof(char), (void *)dir);</a>
<a name="ln4085">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 9, sizeof(int), (void *)&amp;h);</a>
<a name="ln4086">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 10, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4087">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 11, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4088">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 12,</a>
<a name="ln4089">                                (locopt_rb_g.sizex + 2*2) * (locopt_rb_g.sizey + 2*2) * 4 * sizeof(float), NULL);</a>
<a name="ln4090">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_solitary_green, sizes, local);</a>
<a name="ln4091">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln4092"> </a>
<a name="ln4093">        if((d &lt; 2) || (d &amp; 1)) dev_trgb++;</a>
<a name="ln4094">      }</a>
<a name="ln4095"> </a>
<a name="ln4096">      // interpolate red for blue pixels and vice versa</a>
<a name="ln4097">      const int pad_rb_br = (passes == 1) ? 6 : 5;</a>
<a name="ln4098">      dt_opencl_local_buffer_t locopt_rb_br</a>
<a name="ln4099">        = (dt_opencl_local_buffer_t){ .xoffset = 2*3, .xfactor = 1, .yoffset = 2*3, .yfactor = 1,</a>
<a name="ln4100">                                      .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4101">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4102"> </a>
<a name="ln4103">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_red_and_blue, &amp;locopt_rb_br))</a>
<a name="ln4104">      goto error;</a>
<a name="ln4105"> </a>
<a name="ln4106">      for(int d = 0; d &lt; 4; d++)</a>
<a name="ln4107">      {</a>
<a name="ln4108">        size_t sizes[3] = { ROUNDUP(width, locopt_rb_br.sizex), ROUNDUP(height, locopt_rb_br.sizey), 1 };</a>
<a name="ln4109">        size_t local[3] = { locopt_rb_br.sizex, locopt_rb_br.sizey, 1 };</a>
<a name="ln4110">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[d]);</a>
<a name="ln4111">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln4112">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln4113">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 3, sizeof(int), (void *)&amp;pad_rb_br);</a>
<a name="ln4114">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4115">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4116">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 6, sizeof(int), (void *)&amp;d);</a>
<a name="ln4117">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 7, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4118">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4119">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 9,</a>
<a name="ln4120">                                (locopt_rb_br.sizex + 2*3) * (locopt_rb_br.sizey + 2*3) * 4 * sizeof(float), NULL);</a>
<a name="ln4121">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_red_and_blue, sizes, local);</a>
<a name="ln4122">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln4123">      }</a>
<a name="ln4124"> </a>
<a name="ln4125">      // interpolate red and blue for 2x2 blocks of green</a>
<a name="ln4126">      const int pad_g22 = (passes == 1) ? 8 : 4;</a>
<a name="ln4127">      dt_opencl_local_buffer_t locopt_g22</a>
<a name="ln4128">        = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln4129">                                      .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4130">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4131"> </a>
<a name="ln4132">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, &amp;locopt_g22))</a>
<a name="ln4133">      goto error;</a>
<a name="ln4134"> </a>
<a name="ln4135">      for(int d = 0, n = 0; d &lt; ndir; d += 2, n++)</a>
<a name="ln4136">      {</a>
<a name="ln4137">        size_t sizes[3] = { ROUNDUP(width, locopt_g22.sizex), ROUNDUP(height, locopt_g22.sizey), 1 };</a>
<a name="ln4138">        size_t local[3] = { locopt_g22.sizex, locopt_g22.sizey, 1 };</a>
<a name="ln4139">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[n]);</a>
<a name="ln4140">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln4141">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln4142">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 3, sizeof(int), (void *)&amp;pad_g22);</a>
<a name="ln4143">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4144">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4145">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 6, sizeof(int), (void *)&amp;d);</a>
<a name="ln4146">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 7, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4147">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4148">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 9, sizeof(cl_mem), (void *)&amp;dev_allhex);</a>
<a name="ln4149">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 10,</a>
<a name="ln4150">                                (locopt_g22.sizex + 2*2) * (locopt_g22.sizey + 2*2) * 4 * sizeof(float), NULL);</a>
<a name="ln4151">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, sizes, local);</a>
<a name="ln4152">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln4153">      }</a>
<a name="ln4154">    }</a>
<a name="ln4155">    // end of multi pass</a>
<a name="ln4156"> </a>
<a name="ln4157">    // gminmax data no longer needed</a>
<a name="ln4158">    dt_opencl_release_mem_object(dev_gminmax);</a>
<a name="ln4159">    dev_gminmax = NULL;</a>
<a name="ln4160"> </a>
<a name="ln4161">    // jump back to the first set of rgb buffers (this is a noop for Markesteijn-1)</a>
<a name="ln4162">    dev_rgb = dev_rgbv;</a>
<a name="ln4163"> </a>
<a name="ln4164">    // prepare derivatives buffers</a>
<a name="ln4165">    for(int n = 0; n &lt; ndir; n++)</a>
<a name="ln4166">    {</a>
<a name="ln4167">      dev_drv[n] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * sizeof(float));</a>
<a name="ln4168">      if(dev_drv[n] == NULL) goto error;</a>
<a name="ln4169">    }</a>
<a name="ln4170"> </a>
<a name="ln4171">    // convert to perceptual colorspace and differentiate in all directions</a>
<a name="ln4172">    const int pad_yuv = (passes == 1) ? 8 : 13;</a>
<a name="ln4173">    dt_opencl_local_buffer_t locopt_diff</a>
<a name="ln4174">      = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln4175">                                    .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4176">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4177"> </a>
<a name="ln4178">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_differentiate, &amp;locopt_diff))</a>
<a name="ln4179">    goto error;</a>
<a name="ln4180"> </a>
<a name="ln4181">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4182">    {</a>
<a name="ln4183">      // convert to perceptual YPbPr colorspace</a>
<a name="ln4184">      size_t sizes_yuv[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4185">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[d]);</a>
<a name="ln4186">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4187">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4188">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4189">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 4, sizeof(int), (void *)&amp;pad_yuv);</a>
<a name="ln4190">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_convert_yuv, sizes_yuv);</a>
<a name="ln4191">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4192"> </a>
<a name="ln4193"> </a>
<a name="ln4194">      // differentiate in all directions</a>
<a name="ln4195">      size_t sizes_diff[3] = { ROUNDUP(width, locopt_diff.sizex), ROUNDUP(height, locopt_diff.sizey), 1 };</a>
<a name="ln4196">      size_t local_diff[3] = { locopt_diff.sizex, locopt_diff.sizey, 1 };</a>
<a name="ln4197">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 0, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4198">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 1, sizeof(cl_mem), (void *)&amp;dev_drv[d]);</a>
<a name="ln4199">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4200">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4201">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 4, sizeof(int), (void *)&amp;pad_yuv);</a>
<a name="ln4202">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 5, sizeof(int), (void *)&amp;d);</a>
<a name="ln4203">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 6,</a>
<a name="ln4204">                              (locopt_diff.sizex + 2*1) * (locopt_diff.sizey + 2*1) * 4 * sizeof(float), NULL);</a>
<a name="ln4205">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_differentiate, sizes_diff, local_diff);</a>
<a name="ln4206">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4207">    }</a>
<a name="ln4208"> </a>
<a name="ln4209">    // reserve buffers for homogeneity maps and sum maps</a>
<a name="ln4210">    for(int n = 0; n &lt; ndir; n++)</a>
<a name="ln4211">    {</a>
<a name="ln4212">      dev_homo[n] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * sizeof(unsigned char));</a>
<a name="ln4213">      if(dev_homo[n] == NULL) goto error;</a>
<a name="ln4214"> </a>
<a name="ln4215">      dev_homosum[n] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * sizeof(unsigned char));</a>
<a name="ln4216">      if(dev_homosum[n] == NULL) goto error;</a>
<a name="ln4217">    }</a>
<a name="ln4218"> </a>
<a name="ln4219">    // get thresholds for homogeneity map (store them in dev_aux)</a>
<a name="ln4220">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4221">    {</a>
<a name="ln4222">      const int pad_homo = (passes == 1) ? 10 : 15;</a>
<a name="ln4223">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4224">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 0, sizeof(cl_mem), (void *)&amp;dev_drv[d]);</a>
<a name="ln4225">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4226">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4227">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4228">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 4, sizeof(int), (void *)&amp;pad_homo);</a>
<a name="ln4229">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 5, sizeof(int), (void *)&amp;d);</a>
<a name="ln4230">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_homo_threshold, sizes);</a>
<a name="ln4231">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4232">    }</a>
<a name="ln4233"> </a>
<a name="ln4234">    // set homogeneity maps</a>
<a name="ln4235">    const int pad_homo = (passes == 1) ? 10 : 15;</a>
<a name="ln4236">    dt_opencl_local_buffer_t locopt_homo</a>
<a name="ln4237">      = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln4238">                                    .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln4239">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4240"> </a>
<a name="ln4241">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_homo_set, &amp;locopt_homo))</a>
<a name="ln4242">    goto error;</a>
<a name="ln4243"> </a>
<a name="ln4244">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4245">    {</a>
<a name="ln4246">      size_t sizes[3] = { ROUNDUP(width, locopt_homo.sizex),ROUNDUP(height, locopt_homo.sizey), 1 };</a>
<a name="ln4247">      size_t local[3] = { locopt_homo.sizex, locopt_homo.sizey, 1 };</a>
<a name="ln4248">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 0, sizeof(cl_mem), (void *)&amp;dev_drv[d]);</a>
<a name="ln4249">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4250">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 2, sizeof(cl_mem), (void *)&amp;dev_homo[d]);</a>
<a name="ln4251">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 3, sizeof(int), (void *)&amp;width);</a>
<a name="ln4252">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 4, sizeof(int), (void *)&amp;height);</a>
<a name="ln4253">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 5, sizeof(int), (void *)&amp;pad_homo);</a>
<a name="ln4254">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 6,</a>
<a name="ln4255">                              (locopt_homo.sizex + 2*1) * (locopt_homo.sizey + 2*1) * sizeof(float), NULL);</a>
<a name="ln4256">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_homo_set, sizes, local);</a>
<a name="ln4257">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4258">    }</a>
<a name="ln4259"> </a>
<a name="ln4260">    // get rid of dev_drv buffers</a>
<a name="ln4261">    for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4262">    {</a>
<a name="ln4263">      dt_opencl_release_mem_object(dev_drv[n]);</a>
<a name="ln4264">      dev_drv[n] = NULL;</a>
<a name="ln4265">    }</a>
<a name="ln4266"> </a>
<a name="ln4267">    // build 5x5 sum of homogeneity maps for each pixel and direction</a>
<a name="ln4268">    dt_opencl_local_buffer_t locopt_homo_sum</a>
<a name="ln4269">      = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln4270">                                    .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln4271">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4272"> </a>
<a name="ln4273">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_homo_sum, &amp;locopt_homo_sum))</a>
<a name="ln4274">    goto error;</a>
<a name="ln4275"> </a>
<a name="ln4276">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4277">    {</a>
<a name="ln4278">      size_t sizes[3] = { ROUNDUP(width, locopt_homo_sum.sizex), ROUNDUP(height, locopt_homo_sum.sizey), 1 };</a>
<a name="ln4279">      size_t local[3] = { locopt_homo_sum.sizex, locopt_homo_sum.sizey, 1 };</a>
<a name="ln4280">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 0, sizeof(cl_mem), (void *)&amp;dev_homo[d]);</a>
<a name="ln4281">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 1, sizeof(cl_mem), (void *)&amp;dev_homosum[d]);</a>
<a name="ln4282">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4283">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4284">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 4, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4285">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 5,</a>
<a name="ln4286">                              (locopt_homo_sum.sizex + 2*2) * (locopt_homo_sum.sizey + 2*2) * sizeof(char), NULL);</a>
<a name="ln4287">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_homo_sum, sizes, local);</a>
<a name="ln4288">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4289">    }</a>
<a name="ln4290"> </a>
<a name="ln4291">    // get maximum of homogeneity maps (store in dev_aux)</a>
<a name="ln4292">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4293">    {</a>
<a name="ln4294">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4295">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 0, sizeof(cl_mem), (void *)&amp;dev_homosum[d]);</a>
<a name="ln4296">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4297">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4298">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4299">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 4, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4300">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 5, sizeof(int), (void *)&amp;d);</a>
<a name="ln4301">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_homo_max, sizes);</a>
<a name="ln4302">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4303">    }</a>
<a name="ln4304"> </a>
<a name="ln4305">    {</a>
<a name="ln4306">      // adjust maximum value</a>
<a name="ln4307">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4308">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max_corr, 0, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4309">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max_corr, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln4310">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max_corr, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln4311">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max_corr, 3, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4312">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_homo_max_corr, sizes);</a>
<a name="ln4313">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4314">    }</a>
<a name="ln4315"> </a>
<a name="ln4316">    // for Markesteijn-3: use only one of two directions if there is a difference in homogeneity</a>
<a name="ln4317">    for(int d = 0; d &lt; ndir - 4; d++)</a>
<a name="ln4318">    {</a>
<a name="ln4319">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4320">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 0, sizeof(cl_mem), (void *)&amp;dev_homosum[d]);</a>
<a name="ln4321">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 1, sizeof(cl_mem), (void *)&amp;dev_homosum[d + 4]);</a>
<a name="ln4322">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4323">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4324">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 4, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4325">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_homo_quench, sizes);</a>
<a name="ln4326">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4327">    }</a>
<a name="ln4328"> </a>
<a name="ln4329">    {</a>
<a name="ln4330">      // initialize output buffer to zero</a>
<a name="ln4331">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4332">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_zero, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln4333">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_zero, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln4334">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_zero, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln4335">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_zero, 3, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4336">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_zero, sizes);</a>
<a name="ln4337">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4338">    }</a>
<a name="ln4339"> </a>
<a name="ln4340">    // need to get another temp buffer for the output image (may use the space of dev_drv[] freed earlier)</a>
<a name="ln4341">    dev_tmptmp = dt_opencl_alloc_device(devid, (size_t)width, height, 4 * sizeof(float));</a>
<a name="ln4342">    if(dev_tmptmp == NULL) goto error;</a>
<a name="ln4343"> </a>
<a name="ln4344">    cl_mem dev_t1 = dev_tmp;</a>
<a name="ln4345">    cl_mem dev_t2 = dev_tmptmp;</a>
<a name="ln4346"> </a>
<a name="ln4347">    // accumulate all contributions</a>
<a name="ln4348">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4349">    {</a>
<a name="ln4350">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4351">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 0, sizeof(cl_mem), (void *)&amp;dev_t1);</a>
<a name="ln4352">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 1, sizeof(cl_mem), (void *)&amp;dev_t2);</a>
<a name="ln4353">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 2, sizeof(cl_mem), (void *)&amp;dev_rgbv[d]);</a>
<a name="ln4354">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 3, sizeof(cl_mem), (void *)&amp;dev_homosum[d]);</a>
<a name="ln4355">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 4, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4356">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 5, sizeof(int), (void *)&amp;width);</a>
<a name="ln4357">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 6, sizeof(int), (void *)&amp;height);</a>
<a name="ln4358">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 7, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4359">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_accu, sizes);</a>
<a name="ln4360">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4361"> </a>
<a name="ln4362">      // swap buffers</a>
<a name="ln4363">      cl_mem dev_t = dev_t2;</a>
<a name="ln4364">      dev_t2 = dev_t1;</a>
<a name="ln4365">      dev_t1 = dev_t;</a>
<a name="ln4366">    }</a>
<a name="ln4367"> </a>
<a name="ln4368">    // copy output to dev_tmptmp (if not already there)</a>
<a name="ln4369">    // note: we need to take swap of buffers into account, so current output lies in dev_t1</a>
<a name="ln4370">    if(dev_t1 != dev_tmptmp)</a>
<a name="ln4371">    {</a>
<a name="ln4372">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln4373">      size_t region[] = { width, height, 1 };</a>
<a name="ln4374">      err = dt_opencl_enqueue_copy_image(devid, dev_t1, dev_tmptmp, origin, origin, region);</a>
<a name="ln4375">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4376">    }</a>
<a name="ln4377"> </a>
<a name="ln4378">    {</a>
<a name="ln4379">      // process the final image</a>
<a name="ln4380">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4381">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 0, sizeof(cl_mem), (void *)&amp;dev_tmptmp);</a>
<a name="ln4382">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln4383">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4384">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4385">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 4, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4386">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 5, 4*sizeof(float), (void *)processed_maximum);</a>
<a name="ln4387">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_final, sizes);</a>
<a name="ln4388">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4389">    }</a>
<a name="ln4390"> </a>
<a name="ln4391">    // now it's time to get rid of most of the temporary buffers (except of dev_tmp and dev_xtrans)</a>
<a name="ln4392">    for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4393">    {</a>
<a name="ln4394">      dt_opencl_release_mem_object(dev_rgbv[n]);</a>
<a name="ln4395">      dev_rgbv[n] = NULL;</a>
<a name="ln4396">    }</a>
<a name="ln4397"> </a>
<a name="ln4398">    for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4399">    {</a>
<a name="ln4400">      dt_opencl_release_mem_object(dev_homo[n]);</a>
<a name="ln4401">      dev_homo[n] = NULL;</a>
<a name="ln4402">    }</a>
<a name="ln4403"> </a>
<a name="ln4404">    for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4405">    {</a>
<a name="ln4406">      dt_opencl_release_mem_object(dev_homosum[n]);</a>
<a name="ln4407">      dev_homosum[n] = NULL;</a>
<a name="ln4408">    }</a>
<a name="ln4409"> </a>
<a name="ln4410">    dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln4411">    dev_aux = NULL;</a>
<a name="ln4412"> </a>
<a name="ln4413">    dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln4414">    dev_xtrans = NULL;</a>
<a name="ln4415"> </a>
<a name="ln4416">    dt_opencl_release_mem_object(dev_allhex);</a>
<a name="ln4417">    dev_allhex = NULL;</a>
<a name="ln4418"> </a>
<a name="ln4419">    dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln4420">    dev_green_eq = NULL;</a>
<a name="ln4421"> </a>
<a name="ln4422">    dt_opencl_release_mem_object(dev_tmptmp);</a>
<a name="ln4423">    dev_tmptmp = NULL;</a>
<a name="ln4424"> </a>
<a name="ln4425">    // take care of image borders. the algorihm above leaves an unprocessed border of pad_tile pixels.</a>
<a name="ln4426">    // strategy: take the four edges and process them each with process_vng_cl(). as VNG produces</a>
<a name="ln4427">    // an image with a border with only linear interpolation we process edges of pad_tile+3px and</a>
<a name="ln4428">    // drop 3px on the inner side if possible</a>
<a name="ln4429"> </a>
<a name="ln4430">    // take care of some degenerate cases (which might happen if we are called in a tiling context)</a>
<a name="ln4431">    const int wd = (width &gt; pad_tile+3) ? pad_tile+3 : width;</a>
<a name="ln4432">    const int ht = (height &gt; pad_tile+3) ? pad_tile+3 : height;</a>
<a name="ln4433">    const int wdc = (wd &gt;= pad_tile+3) ? 3 : 0;</a>
<a name="ln4434">    const int htc = (ht &gt;= pad_tile+3) ? 3 : 0;</a>
<a name="ln4435"> </a>
<a name="ln4436">    // the data of all four edges:</a>
<a name="ln4437">    // total edge: x-offset, y-offset, width, height,</a>
<a name="ln4438">    // after dropping: x-offset adjust, y-offset adjust, width adjust, height adjust</a>
<a name="ln4439">    const int edges[4][8] = { { 0, 0, wd, height, 0, 0, -wdc, 0 },</a>
<a name="ln4440">                              { 0, 0, width, ht, 0, 0, 0, -htc },</a>
<a name="ln4441">                              { width - wd, 0, wd, height, wdc, 0, -wdc, 0 },</a>
<a name="ln4442">                              { 0, height - ht, width, ht, 0, htc, 0, -htc } };</a>
<a name="ln4443"> </a>
<a name="ln4444">    for(int n = 0; n &lt; 4; n++)</a>
<a name="ln4445">    {</a>
<a name="ln4446">      dt_iop_roi_t roi = { roi_in-&gt;x + edges[n][0], roi_in-&gt;y + edges[n][1], edges[n][2], edges[n][3], 1.0f };</a>
<a name="ln4447"> </a>
<a name="ln4448">      size_t iorigin[] = { edges[n][0], edges[n][1], 0 };</a>
<a name="ln4449">      size_t oorigin[] = { 0, 0, 0 };</a>
<a name="ln4450">      size_t region[] = { edges[n][2], edges[n][3], 1 };</a>
<a name="ln4451"> </a>
<a name="ln4452">      // reserve input buffer for image edge</a>
<a name="ln4453">      dev_edge_in = dt_opencl_alloc_device(devid, edges[n][2], edges[n][3], sizeof(float));</a>
<a name="ln4454">      if(dev_edge_in == NULL) goto error;</a>
<a name="ln4455"> </a>
<a name="ln4456">      // reserve output buffer for VNG processing of edge</a>
<a name="ln4457">      dev_edge_out = dt_opencl_alloc_device(devid, edges[n][2], edges[n][3], 4 * sizeof(float));</a>
<a name="ln4458">      if(dev_edge_out == NULL) goto error;</a>
<a name="ln4459"> </a>
<a name="ln4460">      // copy edge to input buffer</a>
<a name="ln4461">      err = dt_opencl_enqueue_copy_image(devid, dev_in, dev_edge_in, iorigin, oorigin, region);</a>
<a name="ln4462">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4463"> </a>
<a name="ln4464">      // VNG processing</a>
<a name="ln4465">      if(!process_vng_cl(self, piece, dev_edge_in, dev_edge_out, &amp;roi, &amp;roi))</a>
<a name="ln4466">        goto error;</a>
<a name="ln4467"> </a>
<a name="ln4468">      // adjust for &quot;good&quot; part, dropping linear border where possible</a>
<a name="ln4469">      iorigin[0] += edges[n][4];</a>
<a name="ln4470">      iorigin[1] += edges[n][5];</a>
<a name="ln4471">      oorigin[0] += edges[n][4];</a>
<a name="ln4472">      oorigin[1] += edges[n][5];</a>
<a name="ln4473">      region[0] += edges[n][6];</a>
<a name="ln4474">      region[1] += edges[n][7];</a>
<a name="ln4475"> </a>
<a name="ln4476">      // copy output</a>
<a name="ln4477">      err = dt_opencl_enqueue_copy_image(devid, dev_edge_out, dev_tmp, oorigin, iorigin, region);</a>
<a name="ln4478">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4479"> </a>
<a name="ln4480">      // release intermediate buffers</a>
<a name="ln4481">      dt_opencl_release_mem_object(dev_edge_in);</a>
<a name="ln4482">      dt_opencl_release_mem_object(dev_edge_out);</a>
<a name="ln4483">      dev_edge_in = dev_edge_out = NULL;</a>
<a name="ln4484">    }</a>
<a name="ln4485"> </a>
<a name="ln4486"> </a>
<a name="ln4487">    if(scaled)</a>
<a name="ln4488">    {</a>
<a name="ln4489">      // scale temp buffer to output buffer</a>
<a name="ln4490">      err = dt_iop_clip_and_zoom_roi_cl(devid, dev_out, dev_tmp, roi_out, roi_in);</a>
<a name="ln4491">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4492">    }</a>
<a name="ln4493">  }</a>
<a name="ln4494">  else</a>
<a name="ln4495">  {</a>
<a name="ln4496">    // sample third-size image</a>
<a name="ln4497">    const int width = roi_out-&gt;width;</a>
<a name="ln4498">    const int height = roi_out-&gt;height;</a>
<a name="ln4499"> </a>
<a name="ln4500">    size_t sizes[2] = { ROUNDUPWD(width), ROUNDUPHT(height) };</a>
<a name="ln4501">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln4502">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 1, sizeof(cl_mem), &amp;dev_out);</a>
<a name="ln4503">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 2, sizeof(int), &amp;width);</a>
<a name="ln4504">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 3, sizeof(int), &amp;height);</a>
<a name="ln4505">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4506">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4507">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 6, sizeof(int), (void *)&amp;roi_in-&gt;width);</a>
<a name="ln4508">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 7, sizeof(int), (void *)&amp;roi_in-&gt;height);</a>
<a name="ln4509">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 8, sizeof(float), (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln4510">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 9, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4511">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_third_size, sizes);</a>
<a name="ln4512">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln4513">  }</a>
<a name="ln4514"> </a>
<a name="ln4515">  // free remaining temporary buffers</a>
<a name="ln4516">  if(dev_tmp != dev_out) dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln4517">  dev_tmp = NULL;</a>
<a name="ln4518"> </a>
<a name="ln4519">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln4520">  dev_xtrans = NULL;</a>
<a name="ln4521"> </a>
<a name="ln4522"> </a>
<a name="ln4523">  // color smoothing</a>
<a name="ln4524">  if(data-&gt;color_smoothing)</a>
<a name="ln4525">  {</a>
<a name="ln4526">    if(!color_smoothing_cl(self, piece, dev_out, dev_out, roi_out))</a>
<a name="ln4527">      goto error;</a>
<a name="ln4528">  }</a>
<a name="ln4529"> </a>
<a name="ln4530">  return TRUE;</a>
<a name="ln4531"> </a>
<a name="ln4532">error:</a>
<a name="ln4533">  if(dev_tmp != dev_out) dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln4534"> </a>
<a name="ln4535">  for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4536">    dt_opencl_release_mem_object(dev_rgbv[n]);</a>
<a name="ln4537">  for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4538">    dt_opencl_release_mem_object(dev_drv[n]);</a>
<a name="ln4539">  for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4540">    dt_opencl_release_mem_object(dev_homo[n]);</a>
<a name="ln4541">  for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4542">    dt_opencl_release_mem_object(dev_homosum[n]);</a>
<a name="ln4543">  dt_opencl_release_mem_object(dev_gminmax);</a>
<a name="ln4544">  dt_opencl_release_mem_object(dev_tmptmp);</a>
<a name="ln4545">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln4546">  dt_opencl_release_mem_object(dev_allhex);</a>
<a name="ln4547">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln4548">  dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln4549">  dt_opencl_release_mem_object(dev_edge_in);</a>
<a name="ln4550">  dt_opencl_release_mem_object(dev_edge_out);</a>
<a name="ln4551">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln4552">  return FALSE;</a>
<a name="ln4553">}</a>
<a name="ln4554"> </a>
<a name="ln4555">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln4556">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln4557">{</a>
<a name="ln4558">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln4559">  const int demosaicing_method = data-&gt;demosaicing_method;</a>
<a name="ln4560">  const int qual_flags = demosaic_qual_flags(piece, &amp;self-&gt;dev-&gt;image_storage, roi_out);</a>
<a name="ln4561"> </a>
<a name="ln4562">  if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME || demosaicing_method == DT_IOP_DEMOSAIC_PPG)</a>
<a name="ln4563">  {</a>
<a name="ln4564">    return process_default_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln4565">  }</a>
<a name="ln4566">  else if(demosaicing_method ==  DT_IOP_DEMOSAIC_VNG4 || demosaicing_method == DT_IOP_DEMOSAIC_VNG)</a>
<a name="ln4567">  {</a>
<a name="ln4568">    return process_vng_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln4569">  }</a>
<a name="ln4570">  else if((demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN || demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3) &amp;&amp;</a>
<a name="ln4571">    !(qual_flags &amp; DEMOSAIC_XTRANS_FULL))</a>
<a name="ln4572">  {</a>
<a name="ln4573">    return process_vng_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln4574">  }</a>
<a name="ln4575">  else if(demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN || demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3)</a>
<a name="ln4576">  {</a>
<a name="ln4577">    return process_markesteijn_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln4578">  }</a>
<a name="ln4579">  else</a>
<a name="ln4580">  {</a>
<a name="ln4581">    dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic] demosaicing method '%s' not yet supported by opencl code\n&quot;, method2string(demosaicing_method));</a>
<a name="ln4582">    return FALSE;</a>
<a name="ln4583">  }</a>
<a name="ln4584">}</a>
<a name="ln4585">#endif</a>
<a name="ln4586"> </a>
<a name="ln4587">void tiling_callback(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln4588">                     const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out,</a>
<a name="ln4589">                     struct dt_develop_tiling_t *tiling)</a>
<a name="ln4590">{</a>
<a name="ln4591">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln4592"> </a>
<a name="ln4593">  const float ioratio = (float)roi_out-&gt;width * roi_out-&gt;height / ((float)roi_in-&gt;width * roi_in-&gt;height);</a>
<a name="ln4594">  const float smooth = data-&gt;color_smoothing ? ioratio : 0.0f;</a>
<a name="ln4595">  const float greeneq</a>
<a name="ln4596">      = ((piece-&gt;pipe-&gt;dsc.filters != 9u) &amp;&amp; (data-&gt;green_eq != DT_IOP_GREEN_EQ_NO)) ? 0.25f : 0.0f;</a>
<a name="ln4597">  const dt_iop_demosaic_method_t demosaicing_method = data-&gt;demosaicing_method;</a>
<a name="ln4598"> </a>
<a name="ln4599">  const int qual_flags = demosaic_qual_flags(piece, &amp;self-&gt;dev-&gt;image_storage, roi_out);</a>
<a name="ln4600">  const int full_scale_demosaicing = qual_flags &amp; DEMOSAIC_FULL_SCALE;</a>
<a name="ln4601"> </a>
<a name="ln4602">  // check if output buffer has same dimension as input buffer (thus avoiding one</a>
<a name="ln4603">  // additional temporary buffer)</a>
<a name="ln4604">  const int unscaled = (roi_out-&gt;width == roi_in-&gt;width &amp;&amp; roi_out-&gt;height == roi_in-&gt;height);</a>
<a name="ln4605"> </a>
<a name="ln4606">  if((demosaicing_method == DT_IOP_DEMOSAIC_PPG) ||</a>
<a name="ln4607">      (demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME) ||</a>
<a name="ln4608">      (demosaicing_method == DT_IOP_DEMOSAIC_AMAZE))</a>
<a name="ln4609">  {</a>
<a name="ln4610">    // Bayer pattern with PPG, Monochrome and Amaze</a>
<a name="ln4611">    tiling-&gt;factor = 1.0f + ioratio;         // in + out</a>
<a name="ln4612"> </a>
<a name="ln4613">    if(full_scale_demosaicing &amp;&amp; unscaled)</a>
<a name="ln4614">      tiling-&gt;factor += fmax(1.0f + greeneq, smooth);  // + tmp + geeneq | + smooth</a>
<a name="ln4615">    else if(full_scale_demosaicing)</a>
<a name="ln4616">      tiling-&gt;factor += fmax(2.0f + greeneq, smooth);  // + tmp + aux + greeneq | + smooth</a>
<a name="ln4617">    else</a>
<a name="ln4618">      tiling-&gt;factor += smooth;                        // + smooth</a>
<a name="ln4619"> </a>
<a name="ln4620">    tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln4621">    tiling-&gt;overhead = 0;</a>
<a name="ln4622">    tiling-&gt;xalign = 2;</a>
<a name="ln4623">    tiling-&gt;yalign = 2;</a>
<a name="ln4624">    tiling-&gt;overlap = 5; // take care of border handling</a>
<a name="ln4625">  }</a>
<a name="ln4626">  else if(((demosaicing_method ==  DT_IOP_DEMOSAIC_MARKESTEIJN) ||</a>
<a name="ln4627">           (demosaicing_method ==  DT_IOP_DEMOSAIC_MARKESTEIJN_3) ||</a>
<a name="ln4628">           (demosaicing_method == DT_IOP_DEMOSAIC_FDC)) &amp;&amp;</a>
<a name="ln4629">          (qual_flags &amp; DEMOSAIC_XTRANS_FULL))</a>
<a name="ln4630">  {</a>
<a name="ln4631">    // X-Trans pattern full Markesteijn processing</a>
<a name="ln4632">    const int ndir = (demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3) ? 8 : 4;</a>
<a name="ln4633">    const int overlap = (demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3) ? 17 : 12;</a>
<a name="ln4634"> </a>
<a name="ln4635">    tiling-&gt;factor = 1.0f + ioratio;</a>
<a name="ln4636">    tiling-&gt;factor += ndir * 1.0f      // rgb</a>
<a name="ln4637">                      + ndir * 0.25f   // drv</a>
<a name="ln4638">                      + ndir * 0.125f  // homo + homosum</a>
<a name="ln4639">                      + 1.0f;          // aux</a>
<a name="ln4640"> </a>
<a name="ln4641">    if(full_scale_demosaicing &amp;&amp; unscaled)</a>
<a name="ln4642">      tiling-&gt;factor += fmax(1.0f + greeneq, smooth);</a>
<a name="ln4643">    else if(full_scale_demosaicing)</a>
<a name="ln4644">      tiling-&gt;factor += fmax(2.0f + greeneq, smooth);</a>
<a name="ln4645">    else</a>
<a name="ln4646">      tiling-&gt;factor += smooth;</a>
<a name="ln4647"> </a>
<a name="ln4648">    tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln4649">    tiling-&gt;overhead = 0;</a>
<a name="ln4650">    tiling-&gt;xalign = 3;</a>
<a name="ln4651">    tiling-&gt;yalign = 3;</a>
<a name="ln4652">    tiling-&gt;overlap = overlap;</a>
<a name="ln4653">  }</a>
<a name="ln4654">  else</a>
<a name="ln4655">  {</a>
<a name="ln4656">    // VNG</a>
<a name="ln4657">    tiling-&gt;factor = 1.0f + ioratio;</a>
<a name="ln4658"> </a>
<a name="ln4659">    if(full_scale_demosaicing &amp;&amp; unscaled)</a>
<a name="ln4660">      tiling-&gt;factor += fmax(1.0f + greeneq, smooth);</a>
<a name="ln4661">    else if(full_scale_demosaicing)</a>
<a name="ln4662">      tiling-&gt;factor += fmax(2.0f + greeneq, smooth);</a>
<a name="ln4663">    else</a>
<a name="ln4664">      tiling-&gt;factor += smooth;</a>
<a name="ln4665"> </a>
<a name="ln4666">    tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln4667">    tiling-&gt;overhead = 0;</a>
<a name="ln4668">    tiling-&gt;xalign = 6; // covering Bayer pattern for VNG4 as well as xtrans for VNG</a>
<a name="ln4669">    tiling-&gt;yalign = 6; // covering Bayer pattern for VNG4 as well as xtrans for VNG</a>
<a name="ln4670">    tiling-&gt;overlap = 6;</a>
<a name="ln4671">  }</a>
<a name="ln4672">  return;</a>
<a name="ln4673">}</a>
<a name="ln4674"> </a>
<a name="ln4675"> </a>
<a name="ln4676"> </a>
<a name="ln4677">void init(dt_iop_module_t *module)</a>
<a name="ln4678">{</a>
<a name="ln4679">  module-&gt;params = calloc(1, sizeof(dt_iop_demosaic_params_t));</a>
<a name="ln4680">  module-&gt;default_params = calloc(1, sizeof(dt_iop_demosaic_params_t));</a>
<a name="ln4681">  module-&gt;default_enabled = 1;</a>
<a name="ln4682">  module-&gt;priority = 114; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln4683">  module-&gt;hide_enable_button = 1;</a>
<a name="ln4684">  module-&gt;params_size = sizeof(dt_iop_demosaic_params_t);</a>
<a name="ln4685">  module-&gt;gui_data = NULL;</a>
<a name="ln4686">}</a>
<a name="ln4687"> </a>
<a name="ln4688">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln4689">{</a>
<a name="ln4690">  const int program = 0; // from programs.conf</a>
<a name="ln4691">  dt_iop_demosaic_global_data_t *gd</a>
<a name="ln4692">      = (dt_iop_demosaic_global_data_t *)malloc(sizeof(dt_iop_demosaic_global_data_t));</a>
<a name="ln4693">  module-&gt;data = gd;</a>
<a name="ln4694">  gd-&gt;kernel_zoom_half_size = dt_opencl_create_kernel(program, &quot;clip_and_zoom_demosaic_half_size&quot;);</a>
<a name="ln4695">  gd-&gt;kernel_ppg_green = dt_opencl_create_kernel(program, &quot;ppg_demosaic_green&quot;);</a>
<a name="ln4696">  gd-&gt;kernel_green_eq_lavg = dt_opencl_create_kernel(program, &quot;green_equilibration_lavg&quot;);</a>
<a name="ln4697">  gd-&gt;kernel_green_eq_favg_reduce_first = dt_opencl_create_kernel(program, &quot;green_equilibration_favg_reduce_first&quot;);</a>
<a name="ln4698">  gd-&gt;kernel_green_eq_favg_reduce_second = dt_opencl_create_kernel(program, &quot;green_equilibration_favg_reduce_second&quot;);</a>
<a name="ln4699">  gd-&gt;kernel_green_eq_favg_apply = dt_opencl_create_kernel(program, &quot;green_equilibration_favg_apply&quot;);</a>
<a name="ln4700">  gd-&gt;kernel_pre_median = dt_opencl_create_kernel(program, &quot;pre_median&quot;);</a>
<a name="ln4701">  gd-&gt;kernel_ppg_redblue = dt_opencl_create_kernel(program, &quot;ppg_demosaic_redblue&quot;);</a>
<a name="ln4702">  gd-&gt;kernel_downsample = dt_opencl_create_kernel(program, &quot;clip_and_zoom&quot;);</a>
<a name="ln4703">  gd-&gt;kernel_border_interpolate = dt_opencl_create_kernel(program, &quot;border_interpolate&quot;);</a>
<a name="ln4704">  gd-&gt;kernel_color_smoothing = dt_opencl_create_kernel(program, &quot;color_smoothing&quot;);</a>
<a name="ln4705"> </a>
<a name="ln4706">  const int other = 14; // from programs.conf</a>
<a name="ln4707">  gd-&gt;kernel_passthrough_monochrome = dt_opencl_create_kernel(other, &quot;passthrough_monochrome&quot;);</a>
<a name="ln4708">  gd-&gt;kernel_zoom_passthrough_monochrome</a>
<a name="ln4709">      = dt_opencl_create_kernel(other, &quot;clip_and_zoom_demosaic_passthrough_monochrome&quot;);</a>
<a name="ln4710"> </a>
<a name="ln4711">  const int vng = 15; // from programs.conf</a>
<a name="ln4712">  gd-&gt;kernel_vng_border_interpolate = dt_opencl_create_kernel(vng, &quot;vng_border_interpolate&quot;);</a>
<a name="ln4713">  gd-&gt;kernel_vng_lin_interpolate = dt_opencl_create_kernel(vng, &quot;vng_lin_interpolate&quot;);</a>
<a name="ln4714">  gd-&gt;kernel_zoom_third_size = dt_opencl_create_kernel(vng, &quot;clip_and_zoom_demosaic_third_size_xtrans&quot;);</a>
<a name="ln4715">  gd-&gt;kernel_vng_green_equilibrate = dt_opencl_create_kernel(vng, &quot;vng_green_equilibrate&quot;);</a>
<a name="ln4716">  gd-&gt;kernel_vng_interpolate = dt_opencl_create_kernel(vng, &quot;vng_interpolate&quot;);</a>
<a name="ln4717"> </a>
<a name="ln4718">  const int markesteijn = 16; // from programs.conf</a>
<a name="ln4719">  gd-&gt;kernel_markesteijn_initial_copy = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_initial_copy&quot;);</a>
<a name="ln4720">  gd-&gt;kernel_markesteijn_green_minmax = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_green_minmax&quot;);</a>
<a name="ln4721">  gd-&gt;kernel_markesteijn_interpolate_green = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_interpolate_green&quot;);</a>
<a name="ln4722">  gd-&gt;kernel_markesteijn_solitary_green = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_solitary_green&quot;);</a>
<a name="ln4723">  gd-&gt;kernel_markesteijn_recalculate_green = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_recalculate_green&quot;);</a>
<a name="ln4724">  gd-&gt;kernel_markesteijn_red_and_blue = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_red_and_blue&quot;);</a>
<a name="ln4725">  gd-&gt;kernel_markesteijn_interpolate_twoxtwo = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_interpolate_twoxtwo&quot;);</a>
<a name="ln4726">  gd-&gt;kernel_markesteijn_convert_yuv = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_convert_yuv&quot;);</a>
<a name="ln4727">  gd-&gt;kernel_markesteijn_differentiate = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_differentiate&quot;);</a>
<a name="ln4728">  gd-&gt;kernel_markesteijn_homo_threshold = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_threshold&quot;);</a>
<a name="ln4729">  gd-&gt;kernel_markesteijn_homo_set = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_set&quot;);</a>
<a name="ln4730">  gd-&gt;kernel_markesteijn_homo_sum = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_sum&quot;);</a>
<a name="ln4731">  gd-&gt;kernel_markesteijn_homo_max = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_max&quot;);</a>
<a name="ln4732">  gd-&gt;kernel_markesteijn_homo_max_corr = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_max_corr&quot;);</a>
<a name="ln4733">  gd-&gt;kernel_markesteijn_homo_quench = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_quench&quot;);</a>
<a name="ln4734">  gd-&gt;kernel_markesteijn_zero = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_zero&quot;);</a>
<a name="ln4735">  gd-&gt;kernel_markesteijn_accu = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_accu&quot;);</a>
<a name="ln4736">  gd-&gt;kernel_markesteijn_final = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_final&quot;);</a>
<a name="ln4737">}</a>
<a name="ln4738"> </a>
<a name="ln4739">void cleanup(dt_iop_module_t *module)</a>
<a name="ln4740">{</a>
<a name="ln4741">  free(module-&gt;params);</a>
<a name="ln4742">  module-&gt;params = NULL;</a>
<a name="ln4743">}</a>
<a name="ln4744"> </a>
<a name="ln4745">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln4746">{</a>
<a name="ln4747">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)module-&gt;data;</a>
<a name="ln4748">  dt_opencl_free_kernel(gd-&gt;kernel_zoom_half_size);</a>
<a name="ln4749">  dt_opencl_free_kernel(gd-&gt;kernel_ppg_green);</a>
<a name="ln4750">  dt_opencl_free_kernel(gd-&gt;kernel_pre_median);</a>
<a name="ln4751">  dt_opencl_free_kernel(gd-&gt;kernel_green_eq_lavg);</a>
<a name="ln4752">  dt_opencl_free_kernel(gd-&gt;kernel_green_eq_favg_reduce_first);</a>
<a name="ln4753">  dt_opencl_free_kernel(gd-&gt;kernel_green_eq_favg_reduce_second);</a>
<a name="ln4754">  dt_opencl_free_kernel(gd-&gt;kernel_green_eq_favg_apply);</a>
<a name="ln4755">  dt_opencl_free_kernel(gd-&gt;kernel_ppg_redblue);</a>
<a name="ln4756">  dt_opencl_free_kernel(gd-&gt;kernel_downsample);</a>
<a name="ln4757">  dt_opencl_free_kernel(gd-&gt;kernel_border_interpolate);</a>
<a name="ln4758">  dt_opencl_free_kernel(gd-&gt;kernel_color_smoothing);</a>
<a name="ln4759">  dt_opencl_free_kernel(gd-&gt;kernel_passthrough_monochrome);</a>
<a name="ln4760">  dt_opencl_free_kernel(gd-&gt;kernel_zoom_passthrough_monochrome);</a>
<a name="ln4761">  dt_opencl_free_kernel(gd-&gt;kernel_vng_border_interpolate);</a>
<a name="ln4762">  dt_opencl_free_kernel(gd-&gt;kernel_vng_lin_interpolate);</a>
<a name="ln4763">  dt_opencl_free_kernel(gd-&gt;kernel_zoom_third_size);</a>
<a name="ln4764">  dt_opencl_free_kernel(gd-&gt;kernel_vng_green_equilibrate);</a>
<a name="ln4765">  dt_opencl_free_kernel(gd-&gt;kernel_vng_interpolate);</a>
<a name="ln4766">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_initial_copy);</a>
<a name="ln4767">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_green_minmax);</a>
<a name="ln4768">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_interpolate_green);</a>
<a name="ln4769">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_solitary_green);</a>
<a name="ln4770">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_recalculate_green);</a>
<a name="ln4771">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_red_and_blue);</a>
<a name="ln4772">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_interpolate_twoxtwo);</a>
<a name="ln4773">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_convert_yuv);</a>
<a name="ln4774">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_differentiate);</a>
<a name="ln4775">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_threshold);</a>
<a name="ln4776">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_set);</a>
<a name="ln4777">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_sum);</a>
<a name="ln4778">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_max);</a>
<a name="ln4779">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_max_corr);</a>
<a name="ln4780">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_quench);</a>
<a name="ln4781">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_zero);</a>
<a name="ln4782">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_accu);</a>
<a name="ln4783">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_final);</a>
<a name="ln4784">  free(module-&gt;data);</a>
<a name="ln4785">  module-&gt;data = NULL;</a>
<a name="ln4786">}</a>
<a name="ln4787"> </a>
<a name="ln4788">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *params, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln4789">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4790">{</a>
<a name="ln4791">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)params;</a>
<a name="ln4792">  dt_iop_demosaic_data_t *d = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln4793">  if(!(pipe-&gt;image.flags &amp; DT_IMAGE_RAW)) piece-&gt;enabled = 0;</a>
<a name="ln4794">  d-&gt;green_eq = p-&gt;green_eq;</a>
<a name="ln4795">  d-&gt;color_smoothing = p-&gt;color_smoothing;</a>
<a name="ln4796">  d-&gt;median_thrs = p-&gt;median_thrs;</a>
<a name="ln4797">  d-&gt;demosaicing_method = p-&gt;demosaicing_method;</a>
<a name="ln4798"> </a>
<a name="ln4799">  if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME</a>
<a name="ln4800">     || p-&gt;demosaicing_method == (DEMOSAIC_XTRANS | DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME))</a>
<a name="ln4801">  {</a>
<a name="ln4802">    d-&gt;demosaicing_method = DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME;</a>
<a name="ln4803">    d-&gt;green_eq = DT_IOP_GREEN_EQ_NO;</a>
<a name="ln4804">    d-&gt;color_smoothing = 0;</a>
<a name="ln4805">    d-&gt;median_thrs = 0.0f;</a>
<a name="ln4806">  }</a>
<a name="ln4807"> </a>
<a name="ln4808">  if(d-&gt;demosaicing_method == DT_IOP_DEMOSAIC_AMAZE)</a>
<a name="ln4809">  {</a>
<a name="ln4810">    d-&gt;median_thrs = 0.0f;</a>
<a name="ln4811">  }</a>
<a name="ln4812"> </a>
<a name="ln4813">  // OpenCL only supported by some of the demosaicing methods</a>
<a name="ln4814">  switch(d-&gt;demosaicing_method)</a>
<a name="ln4815">  {</a>
<a name="ln4816">    case DT_IOP_DEMOSAIC_PPG:</a>
<a name="ln4817">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4818">      break;</a>
<a name="ln4819">    case DT_IOP_DEMOSAIC_AMAZE:</a>
<a name="ln4820">      piece-&gt;process_cl_ready = 0;</a>
<a name="ln4821">      break;</a>
<a name="ln4822">    case DT_IOP_DEMOSAIC_VNG4:</a>
<a name="ln4823">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4824">      break;</a>
<a name="ln4825">    case DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME:</a>
<a name="ln4826">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4827">      break;</a>
<a name="ln4828">    case DT_IOP_DEMOSAIC_VNG:</a>
<a name="ln4829">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4830">      break;</a>
<a name="ln4831">    case DT_IOP_DEMOSAIC_MARKESTEIJN:</a>
<a name="ln4832">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4833">      break;</a>
<a name="ln4834">    case DT_IOP_DEMOSAIC_MARKESTEIJN_3:</a>
<a name="ln4835">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4836">      break;</a>
<a name="ln4837">    case DT_IOP_DEMOSAIC_FDC:</a>
<a name="ln4838">      piece-&gt;process_cl_ready = 0;</a>
<a name="ln4839">      break;</a>
<a name="ln4840">    default:</a>
<a name="ln4841">      piece-&gt;process_cl_ready = 0;</a>
<a name="ln4842">  }</a>
<a name="ln4843"> </a>
<a name="ln4844">  // green-equilibrate over full image excludes tiling</a>
<a name="ln4845">  if(d-&gt;green_eq == DT_IOP_GREEN_EQ_FULL || d-&gt;green_eq == DT_IOP_GREEN_EQ_BOTH) piece-&gt;process_tiling_ready = 0;</a>
<a name="ln4846"> </a>
<a name="ln4847">  if (self-&gt;dev-&gt;image_storage.flags &amp; DT_IMAGE_4BAYER)</a>
<a name="ln4848">  {</a>
<a name="ln4849">    // 4Bayer images not implemented in OpenCL yet</a>
<a name="ln4850">    piece-&gt;process_cl_ready = 0;</a>
<a name="ln4851"> </a>
<a name="ln4852">    // Get and store the matrix to go from camera to RGB for 4Bayer images</a>
<a name="ln4853">    char *camera = self-&gt;dev-&gt;image_storage.camera_makermodel;</a>
<a name="ln4854">    if (!dt_colorspaces_conversion_matrices_rgb(camera, NULL, d-&gt;CAM_to_RGB, NULL))</a>
<a name="ln4855">    {</a>
<a name="ln4856">      fprintf(stderr, &quot;[colorspaces] `%s' color matrix not found for 4bayer image!\n&quot;, camera);</a>
<a name="ln4857">      dt_control_log(_(&quot;`%s' color matrix not found for 4bayer image!&quot;), camera);</a>
<a name="ln4858">    }</a>
<a name="ln4859">  }</a>
<a name="ln4860">}</a>
<a name="ln4861"> </a>
<a name="ln4862">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4863">{</a>
<a name="ln4864">  piece-&gt;data = malloc(sizeof(dt_iop_demosaic_data_t));</a>
<a name="ln4865">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln4866">}</a>
<a name="ln4867"> </a>
<a name="ln4868">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4869">{</a>
<a name="ln4870">  free(piece-&gt;data);</a>
<a name="ln4871">  piece-&gt;data = NULL;</a>
<a name="ln4872">}</a>
<a name="ln4873"> </a>
<a name="ln4874">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln4875">{</a>
<a name="ln4876">  dt_iop_demosaic_gui_data_t *g = (dt_iop_demosaic_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4877">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln4878"> </a>
<a name="ln4879">  if(self-&gt;dev-&gt;image_storage.buf_dsc.filters != 9u)</a>
<a name="ln4880">  {</a>
<a name="ln4881">    gtk_widget_show(g-&gt;demosaic_method_bayer);</a>
<a name="ln4882">    gtk_widget_hide(g-&gt;demosaic_method_xtrans);</a>
<a name="ln4883">    gtk_widget_show(g-&gt;median_thrs);</a>
<a name="ln4884">    gtk_widget_show(g-&gt;greeneq);</a>
<a name="ln4885">    dt_bauhaus_combobox_set(g-&gt;demosaic_method_bayer, p-&gt;demosaicing_method);</a>
<a name="ln4886">  }</a>
<a name="ln4887">  else</a>
<a name="ln4888">  {</a>
<a name="ln4889">    gtk_widget_show(g-&gt;demosaic_method_xtrans);</a>
<a name="ln4890">    gtk_widget_hide(g-&gt;demosaic_method_bayer);</a>
<a name="ln4891">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln4892">    gtk_widget_hide(g-&gt;greeneq);</a>
<a name="ln4893">    dt_bauhaus_combobox_set(g-&gt;demosaic_method_xtrans, p-&gt;demosaicing_method &amp; ~DEMOSAIC_XTRANS);</a>
<a name="ln4894">  }</a>
<a name="ln4895"> </a>
<a name="ln4896">  if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln4897">  {</a>
<a name="ln4898">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln4899">    gtk_widget_hide(g-&gt;color_smoothing);</a>
<a name="ln4900">    gtk_widget_hide(g-&gt;greeneq);</a>
<a name="ln4901">  }</a>
<a name="ln4902"> </a>
<a name="ln4903">  if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_AMAZE || p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_VNG4)</a>
<a name="ln4904">  {</a>
<a name="ln4905">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln4906">  }</a>
<a name="ln4907"> </a>
<a name="ln4908">  dt_bauhaus_slider_set(g-&gt;median_thrs, p-&gt;median_thrs);</a>
<a name="ln4909">  dt_bauhaus_combobox_set(g-&gt;color_smoothing, p-&gt;color_smoothing);</a>
<a name="ln4910">  dt_bauhaus_combobox_set(g-&gt;greeneq, p-&gt;green_eq);</a>
<a name="ln4911"> </a>
<a name="ln4912">  if(self-&gt;default_enabled)</a>
<a name="ln4913">  {</a>
<a name="ln4914">    gtk_widget_show(g-&gt;box_raw);</a>
<a name="ln4915">    gtk_widget_hide(g-&gt;label_non_raw);</a>
<a name="ln4916">  }</a>
<a name="ln4917">  else</a>
<a name="ln4918">  {</a>
<a name="ln4919">    gtk_widget_hide(g-&gt;box_raw);</a>
<a name="ln4920">    gtk_widget_show(g-&gt;label_non_raw);</a>
<a name="ln4921">  }</a>
<a name="ln4922">}</a>
<a name="ln4923"> </a>
<a name="ln4924">void reload_defaults(dt_iop_module_t *module)</a>
<a name="ln4925">{</a>
<a name="ln4926">  dt_iop_demosaic_params_t tmp</a>
<a name="ln4927">      = (dt_iop_demosaic_params_t){ .green_eq = DT_IOP_GREEN_EQ_NO,</a>
<a name="ln4928">                                    .median_thrs = 0.0f,</a>
<a name="ln4929">                                    .color_smoothing = 0,</a>
<a name="ln4930">                                    .demosaicing_method = DT_IOP_DEMOSAIC_PPG,</a>
<a name="ln4931">                                    .yet_unused_data_specific_to_demosaicing_method = 0 };</a>
<a name="ln4932"> </a>
<a name="ln4933">  // we might be called from presets update infrastructure =&gt; there is no image</a>
<a name="ln4934">  if(!module-&gt;dev) goto end;</a>
<a name="ln4935"> </a>
<a name="ln4936">  if(dt_image_is_monochrome(&amp;module-&gt;dev-&gt;image_storage))</a>
<a name="ln4937">    tmp.demosaicing_method = DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME;</a>
<a name="ln4938"> </a>
<a name="ln4939">  // only on for raw images:</a>
<a name="ln4940">  if(dt_image_is_raw(&amp;module-&gt;dev-&gt;image_storage))</a>
<a name="ln4941">    module-&gt;default_enabled = 1;</a>
<a name="ln4942">  else</a>
<a name="ln4943">    module-&gt;default_enabled = 0;</a>
<a name="ln4944"> </a>
<a name="ln4945">  if(module-&gt;dev-&gt;image_storage.buf_dsc.filters == 9u) tmp.demosaicing_method = DT_IOP_DEMOSAIC_MARKESTEIJN;</a>
<a name="ln4946"> </a>
<a name="ln4947">end:</a>
<a name="ln4948">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_demosaic_params_t));</a>
<a name="ln4949">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_demosaic_params_t));</a>
<a name="ln4950">}</a>
<a name="ln4951"> </a>
<a name="ln4952">static void median_thrs_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4953">{</a>
<a name="ln4954">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4955">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4956">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln4957">  p-&gt;median_thrs = dt_bauhaus_slider_get(slider);</a>
<a name="ln4958">  if(p-&gt;median_thrs &lt; 0.001f) p-&gt;median_thrs = 0.0f;</a>
<a name="ln4959">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4960">}</a>
<a name="ln4961"> </a>
<a name="ln4962">static void color_smoothing_callback(GtkWidget *button, gpointer user_data)</a>
<a name="ln4963">{</a>
<a name="ln4964">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4965">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4966">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln4967">  p-&gt;color_smoothing = dt_bauhaus_combobox_get(button);</a>
<a name="ln4968">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4969">}</a>
<a name="ln4970"> </a>
<a name="ln4971">static void greeneq_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln4972">{</a>
<a name="ln4973">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln4974">  int active = dt_bauhaus_combobox_get(combo);</a>
<a name="ln4975">  switch(active)</a>
<a name="ln4976">  {</a>
<a name="ln4977">    case DT_IOP_GREEN_EQ_FULL:</a>
<a name="ln4978">      p-&gt;green_eq = DT_IOP_GREEN_EQ_FULL;</a>
<a name="ln4979">      break;</a>
<a name="ln4980">    case DT_IOP_GREEN_EQ_LOCAL:</a>
<a name="ln4981">      p-&gt;green_eq = DT_IOP_GREEN_EQ_LOCAL;</a>
<a name="ln4982">      break;</a>
<a name="ln4983">    case DT_IOP_GREEN_EQ_BOTH:</a>
<a name="ln4984">      p-&gt;green_eq = DT_IOP_GREEN_EQ_BOTH;</a>
<a name="ln4985">      break;</a>
<a name="ln4986">    default:</a>
<a name="ln4987">    case DT_IOP_GREEN_EQ_NO:</a>
<a name="ln4988">      p-&gt;green_eq = DT_IOP_GREEN_EQ_NO;</a>
<a name="ln4989">      break;</a>
<a name="ln4990">  }</a>
<a name="ln4991">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4992">}</a>
<a name="ln4993"> </a>
<a name="ln4994">static void demosaic_method_bayer_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln4995">{</a>
<a name="ln4996">  dt_iop_demosaic_gui_data_t *g = (dt_iop_demosaic_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4997">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln4998">  int active = dt_bauhaus_combobox_get(combo);</a>
<a name="ln4999"> </a>
<a name="ln5000">  switch(active)</a>
<a name="ln5001">  {</a>
<a name="ln5002">    case DT_IOP_DEMOSAIC_AMAZE:</a>
<a name="ln5003">      p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_AMAZE;</a>
<a name="ln5004">      break;</a>
<a name="ln5005">    case DT_IOP_DEMOSAIC_VNG4:</a>
<a name="ln5006">      p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_VNG4;</a>
<a name="ln5007">      break;</a>
<a name="ln5008">    case DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME:</a>
<a name="ln5009">      p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME;</a>
<a name="ln5010">      break;</a>
<a name="ln5011">    default:</a>
<a name="ln5012">    case DT_IOP_DEMOSAIC_PPG:</a>
<a name="ln5013">      p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_PPG;</a>
<a name="ln5014">      break;</a>
<a name="ln5015">  }</a>
<a name="ln5016"> </a>
<a name="ln5017">  if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln5018">  {</a>
<a name="ln5019">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln5020">    gtk_widget_hide(g-&gt;color_smoothing);</a>
<a name="ln5021">    gtk_widget_hide(g-&gt;greeneq);</a>
<a name="ln5022">  }</a>
<a name="ln5023">  else if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_AMAZE || p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_VNG4)</a>
<a name="ln5024">  {</a>
<a name="ln5025">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln5026">    gtk_widget_show(g-&gt;color_smoothing);</a>
<a name="ln5027">    gtk_widget_show(g-&gt;greeneq);</a>
<a name="ln5028">  }</a>
<a name="ln5029">  else</a>
<a name="ln5030">  {</a>
<a name="ln5031">    gtk_widget_show(g-&gt;median_thrs);</a>
<a name="ln5032">    gtk_widget_show(g-&gt;color_smoothing);</a>
<a name="ln5033">    gtk_widget_show(g-&gt;greeneq);</a>
<a name="ln5034">  }</a>
<a name="ln5035"> </a>
<a name="ln5036">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln5037">}</a>
<a name="ln5038"> </a>
<a name="ln5039">static void demosaic_method_xtrans_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln5040">{</a>
<a name="ln5041">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln5042">  p-&gt;demosaicing_method = dt_bauhaus_combobox_get(combo) | DEMOSAIC_XTRANS;</a>
<a name="ln5043">  if((p-&gt;demosaicing_method &gt; (DT_IOP_DEMOSAIC_FDC | DEMOSAIC_XTRANS))</a>
<a name="ln5044">     || (p-&gt;demosaicing_method &lt; (DT_IOP_DEMOSAIC_VNG | DEMOSAIC_XTRANS)))</a>
<a name="ln5045">    p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_MARKESTEIJN;</a>
<a name="ln5046">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln5047">}</a>
<a name="ln5048"> </a>
<a name="ln5049">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln5050">{</a>
<a name="ln5051">  self-&gt;gui_data = malloc(sizeof(dt_iop_demosaic_gui_data_t));</a>
<a name="ln5052">  dt_iop_demosaic_gui_data_t *g = (dt_iop_demosaic_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln5053">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln5054"> </a>
<a name="ln5055">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln5056">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln5057"> </a>
<a name="ln5058">  g-&gt;box_raw = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln5059"> </a>
<a name="ln5060">  g-&gt;demosaic_method_bayer = dt_bauhaus_combobox_new(self);</a>
<a name="ln5061">  dt_bauhaus_widget_set_label(g-&gt;demosaic_method_bayer, NULL, _(&quot;method&quot;));</a>
<a name="ln5062">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;demosaic_method_bayer, TRUE, TRUE, 0);</a>
<a name="ln5063">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_bayer, _(&quot;PPG (fast)&quot;));</a>
<a name="ln5064">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_bayer, _(&quot;AMaZE (slow)&quot;));</a>
<a name="ln5065">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_bayer, _(&quot;VNG4&quot;));</a>
<a name="ln5066">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_bayer, _(&quot;passthrough (monochrome) (experimental)&quot;));</a>
<a name="ln5067">  gtk_widget_set_tooltip_text(g-&gt;demosaic_method_bayer, _(&quot;demosaicing raw data method&quot;));</a>
<a name="ln5068"> </a>
<a name="ln5069">  g-&gt;demosaic_method_xtrans = dt_bauhaus_combobox_new(self);</a>
<a name="ln5070">  dt_bauhaus_widget_set_label(g-&gt;demosaic_method_xtrans, NULL, _(&quot;method&quot;));</a>
<a name="ln5071">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;demosaic_method_xtrans, TRUE, TRUE, 0);</a>
<a name="ln5072">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;VNG&quot;));</a>
<a name="ln5073">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;Markesteijn 1-pass&quot;));</a>
<a name="ln5074">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;Markesteijn 3-pass (slow)&quot;));</a>
<a name="ln5075">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;passthrough (monochrome) (experimental)&quot;));</a>
<a name="ln5076">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;frequency domain chroma (slow)&quot;));</a>
<a name="ln5077">  gtk_widget_set_tooltip_text(g-&gt;demosaic_method_xtrans, _(&quot;demosaicing raw data method&quot;));</a>
<a name="ln5078"> </a>
<a name="ln5079">  g-&gt;median_thrs = dt_bauhaus_slider_new_with_range(self, 0.0, 1.0, 0.001, p-&gt;median_thrs, 3);</a>
<a name="ln5080">  gtk_widget_set_tooltip_text(g-&gt;median_thrs, _(&quot;threshold for edge-aware median.\nset to 0.0 to switch off.\n&quot;</a>
<a name="ln5081">                                                &quot;set to 1.0 to ignore edges.&quot;));</a>
<a name="ln5082">  dt_bauhaus_widget_set_label(g-&gt;median_thrs, NULL, _(&quot;edge threshold&quot;));</a>
<a name="ln5083">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;median_thrs, TRUE, TRUE, 0);</a>
<a name="ln5084"> </a>
<a name="ln5085">  g-&gt;color_smoothing = dt_bauhaus_combobox_new(self);</a>
<a name="ln5086">  dt_bauhaus_widget_set_label(g-&gt;color_smoothing, NULL, _(&quot;color smoothing&quot;));</a>
<a name="ln5087">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;color_smoothing, TRUE, TRUE, 0);</a>
<a name="ln5088">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;off&quot;));</a>
<a name="ln5089">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;one time&quot;));</a>
<a name="ln5090">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;two times&quot;));</a>
<a name="ln5091">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;three times&quot;));</a>
<a name="ln5092">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;four times&quot;));</a>
<a name="ln5093">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;five times&quot;));</a>
<a name="ln5094">  gtk_widget_set_tooltip_text(g-&gt;color_smoothing, _(&quot;how many color smoothing median steps after demosaicing&quot;));</a>
<a name="ln5095"> </a>
<a name="ln5096">  g-&gt;greeneq = dt_bauhaus_combobox_new(self);</a>
<a name="ln5097">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;greeneq, TRUE, TRUE, 0);</a>
<a name="ln5098">  dt_bauhaus_widget_set_label(g-&gt;greeneq, NULL, _(&quot;match greens&quot;));</a>
<a name="ln5099">  dt_bauhaus_combobox_add(g-&gt;greeneq, _(&quot;disabled&quot;));</a>
<a name="ln5100">  dt_bauhaus_combobox_add(g-&gt;greeneq, _(&quot;local average&quot;));</a>
<a name="ln5101">  dt_bauhaus_combobox_add(g-&gt;greeneq, _(&quot;full average&quot;));</a>
<a name="ln5102">  dt_bauhaus_combobox_add(g-&gt;greeneq, _(&quot;full and local average&quot;));</a>
<a name="ln5103">  gtk_widget_set_tooltip_text(g-&gt;greeneq, _(&quot;green channels matching method&quot;));</a>
<a name="ln5104"> </a>
<a name="ln5105">  g_signal_connect(G_OBJECT(g-&gt;median_thrs), &quot;value-changed&quot;, G_CALLBACK(median_thrs_callback), self);</a>
<a name="ln5106">  g_signal_connect(G_OBJECT(g-&gt;color_smoothing), &quot;value-changed&quot;, G_CALLBACK(color_smoothing_callback), self);</a>
<a name="ln5107">  g_signal_connect(G_OBJECT(g-&gt;greeneq), &quot;value-changed&quot;, G_CALLBACK(greeneq_callback), self);</a>
<a name="ln5108">  g_signal_connect(G_OBJECT(g-&gt;demosaic_method_bayer), &quot;value-changed&quot;,</a>
<a name="ln5109">                   G_CALLBACK(demosaic_method_bayer_callback), self);</a>
<a name="ln5110">  g_signal_connect(G_OBJECT(g-&gt;demosaic_method_xtrans), &quot;value-changed&quot;,</a>
<a name="ln5111">                   G_CALLBACK(demosaic_method_xtrans_callback), self);</a>
<a name="ln5112"> </a>
<a name="ln5113">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;box_raw, FALSE, FALSE, 0);</a>
<a name="ln5114"> </a>
<a name="ln5115">  g-&gt;label_non_raw = gtk_label_new(_(&quot;demosaicing\nonly needed for raw images.&quot;));</a>
<a name="ln5116">  gtk_widget_set_halign(g-&gt;label_non_raw, GTK_ALIGN_START);</a>
<a name="ln5117">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;label_non_raw, FALSE, FALSE, 0);</a>
<a name="ln5118">}</a>
<a name="ln5119"> </a>
<a name="ln5120">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln5121">{</a>
<a name="ln5122">  free(self-&gt;gui_data);</a>
<a name="ln5123">  self-&gt;gui_data = NULL;</a>
<a name="ln5124">}</a>
<a name="ln5125"> </a>
<a name="ln5126">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln5127">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln5128">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="759"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v743/" target="_blank">V743</a> The memory areas must not overlap. Use 'memmove' function.</p></div>
<div class="balloon" rel="864"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'hex[d] + hex[d + 1]' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="868"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="868"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="874"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="874"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1848"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'hex[d] + hex[d + 1]' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="1853"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1853"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1854"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'd' index could reach 3.</p></div>
<div class="balloon" rel="1854"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1854"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1862"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1862"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1863"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'd' index could reach 3.</p></div>
<div class="balloon" rel="1863"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1863"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1868"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1868"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1913"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'f' index could reach 123.</p></div>
<div class="balloon" rel="1913"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of '-f' index could reach -123.</p></div>
<div class="balloon" rel="1914"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'f' index could reach 123.</p></div>
<div class="balloon" rel="1914"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of '-f' index could reach -123.</p></div>
<div class="balloon" rel="1915"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'f' index could reach 123.</p></div>
<div class="balloon" rel="1915"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of '-f' index could reach -123.</p></div>
<div class="balloon" rel="2038"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v654/" target="_blank">V654</a> The condition 'd < ndir - 4' of loop is always false.</p></div>
<div class="balloon" rel="2038"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v621/" target="_blank">V621</a> Consider inspecting the 'for' operator. It's possible that the loop will be executed incorrectly or won't be executed at all.</p></div>
<div class="balloon" rel="2167"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lookup'. Check lines: 2167, 2161.</p></div>
<div class="balloon" rel="2486"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2487"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2488"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2489"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2490"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2491"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2492"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2564"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2565"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2566"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="3466"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lookup'. Check lines: 3466, 3461.</p></div>
<div class="balloon" rel="3476"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '<<'. The left operand is negative ('y' = [-1..1]).</p></div>
<div class="balloon" rel="3521"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'ip' pointer in the 'ip - ips' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 3521, 3513.</p></div>
<div class="balloon" rel="3811"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v586/" target="_blank">V586</a> The 'free' function is called twice for deallocation of the same memory space.</p></div>
<div class="balloon" rel="4694"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 4694, 4692.</p></div>
<div class="balloon" rel="5043"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false.</p></div>
<div class="balloon" rel="5058"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 5058, 5051.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
