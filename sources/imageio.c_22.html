
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika.</a>
<a name="ln4">    copyright (c) 2010--2011 henrik andersson.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#ifdef HAVE_CONFIG_H</a>
<a name="ln20">#include &quot;config.h&quot;</a>
<a name="ln21">#endif</a>
<a name="ln22">#include &quot;common/colorlabels.h&quot;</a>
<a name="ln23">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln24">#include &quot;common/darktable.h&quot;</a>
<a name="ln25">#include &quot;common/debug.h&quot;</a>
<a name="ln26">#include &quot;common/exif.h&quot;</a>
<a name="ln27">#include &quot;common/image_cache.h&quot;</a>
<a name="ln28">#include &quot;common/imageio.h&quot;</a>
<a name="ln29">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln30">#ifdef HAVE_OPENEXR</a>
<a name="ln31">#include &quot;common/imageio_exr.h&quot;</a>
<a name="ln32">#endif</a>
<a name="ln33">#ifdef HAVE_OPENJPEG</a>
<a name="ln34">#include &quot;common/imageio_j2k.h&quot;</a>
<a name="ln35">#endif</a>
<a name="ln36">#include &quot;common/image_compression.h&quot;</a>
<a name="ln37">#include &quot;common/imageio_gm.h&quot;</a>
<a name="ln38">#include &quot;common/imageio_jpeg.h&quot;</a>
<a name="ln39">#include &quot;common/imageio_pfm.h&quot;</a>
<a name="ln40">#include &quot;common/imageio_png.h&quot;</a>
<a name="ln41">#include &quot;common/imageio_pnm.h&quot;</a>
<a name="ln42">#include &quot;common/imageio_rawspeed.h&quot;</a>
<a name="ln43">#include &quot;common/imageio_rgbe.h&quot;</a>
<a name="ln44">#include &quot;common/imageio_tiff.h&quot;</a>
<a name="ln45">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln46">#include &quot;common/styles.h&quot;</a>
<a name="ln47">#include &quot;control/conf.h&quot;</a>
<a name="ln48">#include &quot;control/control.h&quot;</a>
<a name="ln49">#include &quot;develop/blend.h&quot;</a>
<a name="ln50">#include &quot;develop/develop.h&quot;</a>
<a name="ln51">#include &quot;develop/imageop.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">#ifdef HAVE_GRAPHICSMAGICK</a>
<a name="ln54">#include &lt;magick/api.h&gt;</a>
<a name="ln55">#include &lt;magick/blob.h&gt;</a>
<a name="ln56">#endif</a>
<a name="ln57"> </a>
<a name="ln58">#include &lt;assert.h&gt;</a>
<a name="ln59">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln60">#include &lt;inttypes.h&gt;</a>
<a name="ln61">#include &lt;math.h&gt;</a>
<a name="ln62">#include &lt;stdio.h&gt;</a>
<a name="ln63">#include &lt;stdlib.h&gt;</a>
<a name="ln64">#include &lt;string.h&gt;</a>
<a name="ln65">#include &lt;strings.h&gt;</a>
<a name="ln66"> </a>
<a name="ln67">#ifdef USE_LUA</a>
<a name="ln68">#include &quot;lua/image.h&quot;</a>
<a name="ln69">#endif</a>
<a name="ln70"> </a>
<a name="ln71">// load a full-res thumbnail:</a>
<a name="ln72">int dt_imageio_large_thumbnail(const char *filename, uint8_t **buffer, int32_t *width, int32_t *height,</a>
<a name="ln73">                               dt_colorspaces_color_profile_type_t *color_space)</a>
<a name="ln74">{</a>
<a name="ln75">  int res = 1;</a>
<a name="ln76"> </a>
<a name="ln77">  uint8_t *buf = NULL;</a>
<a name="ln78">  char *mime_type = NULL;</a>
<a name="ln79">  size_t bufsize;</a>
<a name="ln80"> </a>
<a name="ln81">  // get the biggest thumb from exif</a>
<a name="ln82">  if(dt_exif_get_thumbnail(filename, &amp;buf, &amp;bufsize, &amp;mime_type)) goto error;</a>
<a name="ln83"> </a>
<a name="ln84">  if(strcmp(mime_type, &quot;image/jpeg&quot;) == 0)</a>
<a name="ln85">  {</a>
<a name="ln86">    // Decompress the JPG into our own memory format</a>
<a name="ln87">    dt_imageio_jpeg_t jpg;</a>
<a name="ln88">    if(dt_imageio_jpeg_decompress_header(buf, bufsize, &amp;jpg)) goto error;</a>
<a name="ln89">    *buffer = (uint8_t *)malloc((size_t)sizeof(uint8_t) * jpg.width * jpg.height * 4);</a>
<a name="ln90">    if(!*buffer) goto error;</a>
<a name="ln91"> </a>
<a name="ln92">    *width = jpg.width;</a>
<a name="ln93">    *height = jpg.height;</a>
<a name="ln94">    // TODO: check if the embedded thumbs have a color space set! currently we assume that it's always sRGB</a>
<a name="ln95">    *color_space = DT_COLORSPACE_SRGB;</a>
<a name="ln96">    if(dt_imageio_jpeg_decompress(&amp;jpg, *buffer))</a>
<a name="ln97">    {</a>
<a name="ln98">      free(*buffer);</a>
<a name="ln99">      *buffer = NULL;</a>
<a name="ln100">      goto error;</a>
<a name="ln101">    }</a>
<a name="ln102"> </a>
<a name="ln103">    res = 0;</a>
<a name="ln104">  }</a>
<a name="ln105">  else</a>
<a name="ln106">  {</a>
<a name="ln107">#ifdef HAVE_GRAPHICSMAGICK</a>
<a name="ln108">    ExceptionInfo exception;</a>
<a name="ln109">    Image *image = NULL;</a>
<a name="ln110">    ImageInfo *image_info = NULL;</a>
<a name="ln111"> </a>
<a name="ln112">    GetExceptionInfo(&amp;exception);</a>
<a name="ln113">    image_info = CloneImageInfo((ImageInfo *)NULL);</a>
<a name="ln114"> </a>
<a name="ln115">    image = BlobToImage(image_info, buf, bufsize, &amp;exception);</a>
<a name="ln116"> </a>
<a name="ln117">    if(exception.severity != UndefinedException) CatchException(&amp;exception);</a>
<a name="ln118"> </a>
<a name="ln119">    if(!image)</a>
<a name="ln120">    {</a>
<a name="ln121">      fprintf(stderr, &quot;[dt_imageio_large_thumbnail GM] thumbnail not found?\n&quot;);</a>
<a name="ln122">      goto error_gm;</a>
<a name="ln123">    }</a>
<a name="ln124"> </a>
<a name="ln125">    *width = image-&gt;columns;</a>
<a name="ln126">    *height = image-&gt;rows;</a>
<a name="ln127">    *color_space = DT_COLORSPACE_SRGB; // FIXME: this assumes that embedded thumbnails are always srgb</a>
<a name="ln128"> </a>
<a name="ln129">    *buffer = (uint8_t *)malloc((size_t)sizeof(uint8_t) * image-&gt;columns * image-&gt;rows * 4);</a>
<a name="ln130">    if(!*buffer) goto error_gm;</a>
<a name="ln131"> </a>
<a name="ln132">    for(uint32_t row = 0; row &lt; image-&gt;rows; row++)</a>
<a name="ln133">    {</a>
<a name="ln134">      uint8_t *bufprt = *buffer + (size_t)4 * row * image-&gt;columns;</a>
<a name="ln135">      int gm_ret = DispatchImage(image, 0, row, image-&gt;columns, 1, &quot;RGBP&quot;, CharPixel, bufprt, &amp;exception);</a>
<a name="ln136"> </a>
<a name="ln137">      if(exception.severity != UndefinedException) CatchException(&amp;exception);</a>
<a name="ln138"> </a>
<a name="ln139">      if(gm_ret != MagickPass)</a>
<a name="ln140">      {</a>
<a name="ln141">        fprintf(stderr, &quot;[dt_imageio_large_thumbnail GM] error_gm reading thumbnail\n&quot;);</a>
<a name="ln142">        free(*buffer);</a>
<a name="ln143">        *buffer = NULL;</a>
<a name="ln144">        goto error_gm;</a>
<a name="ln145">      }</a>
<a name="ln146">    }</a>
<a name="ln147"> </a>
<a name="ln148">    // fprintf(stderr, &quot;[dt_imageio_large_thumbnail GM] successfully decoded thumbnail\n&quot;);</a>
<a name="ln149">    res = 0;</a>
<a name="ln150"> </a>
<a name="ln151">  error_gm:</a>
<a name="ln152">    if(image) DestroyImage(image);</a>
<a name="ln153">    if(image_info) DestroyImageInfo(image_info);</a>
<a name="ln154">    DestroyExceptionInfo(&amp;exception);</a>
<a name="ln155">    if(res) goto error;</a>
<a name="ln156">#else</a>
<a name="ln157">    fprintf(stderr, &quot;[dt_imageio_large_thumbnail] error: The thumbnail image is not in JPEG format, but DT &quot;</a>
<a name="ln158">                    &quot;was built without GraphicsMagick. Please rebuild DT with GraphicsMagick support &quot;</a>
<a name="ln159">                    &quot;enabled.\n&quot;);</a>
<a name="ln160">#endif</a>
<a name="ln161">  }</a>
<a name="ln162"> </a>
<a name="ln163">  if(res)</a>
<a name="ln164">  {</a>
<a name="ln165">    fprintf(</a>
<a name="ln166">        stderr,</a>
<a name="ln167">        &quot;[dt_imageio_large_thumbnail] error: Not a supported thumbnail image format or broken thumbnail: %s\n&quot;,</a>
<a name="ln168">        mime_type);</a>
<a name="ln169">    goto error;</a>
<a name="ln170">  }</a>
<a name="ln171"> </a>
<a name="ln172">error:</a>
<a name="ln173">  free(mime_type);</a>
<a name="ln174">  free(buf);</a>
<a name="ln175">  return res;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">void dt_imageio_flip_buffers(char *out, const char *in, const size_t bpp, const int wd, const int ht,</a>
<a name="ln179">                             const int fwd, const int fht, const int stride,</a>
<a name="ln180">                             const dt_image_orientation_t orientation)</a>
<a name="ln181">{</a>
<a name="ln182">  if(!orientation)</a>
<a name="ln183">  {</a>
<a name="ln184">#ifdef _OPENMP</a>
<a name="ln185">#pragma omp parallel for default(none) \</a>
<a name="ln186">    dt_omp_firstprivate(ht, wd, bpp, stride) \</a>
<a name="ln187">    shared(in, out) \</a>
<a name="ln188">    schedule(static)</a>
<a name="ln189">#endif</a>
<a name="ln190">    for(int j = 0; j &lt; ht; j++) memcpy(out + (size_t)j * bpp * wd, in + (size_t)j * stride, bpp * wd);</a>
<a name="ln191">    return;</a>
<a name="ln192">  }</a>
<a name="ln193">  int ii = 0, jj = 0;</a>
<a name="ln194">  int si = bpp, sj = wd * bpp;</a>
<a name="ln195">  if(orientation &amp; ORIENTATION_SWAP_XY)</a>
<a name="ln196">  {</a>
<a name="ln197">    sj = bpp;</a>
<a name="ln198">    si = ht * bpp;</a>
<a name="ln199">  }</a>
<a name="ln200">  if(orientation &amp; ORIENTATION_FLIP_Y)</a>
<a name="ln201">  {</a>
<a name="ln202">    jj = (int)fht - jj - 1;</a>
<a name="ln203">    sj = -sj;</a>
<a name="ln204">  }</a>
<a name="ln205">  if(orientation &amp; ORIENTATION_FLIP_X)</a>
<a name="ln206">  {</a>
<a name="ln207">    ii = (int)fwd - ii - 1;</a>
<a name="ln208">    si = -si;</a>
<a name="ln209">  }</a>
<a name="ln210">#ifdef _OPENMP</a>
<a name="ln211">#pragma omp parallel for default(none) \</a>
<a name="ln212">  dt_omp_firstprivate(wd, bpp, ht, stride) \</a>
<a name="ln213">  shared(in, out, jj, ii, sj, si) \</a>
<a name="ln214">  schedule(static)</a>
<a name="ln215">#endif</a>
<a name="ln216">  for(int j = 0; j &lt; ht; j++)</a>
<a name="ln217">  {</a>
<a name="ln218">    char *out2 = out + (size_t)labs(sj) * jj + (size_t)labs(si) * ii + (size_t)sj * j;</a>
<a name="ln219">    const char *in2 = in + (size_t)stride * j;</a>
<a name="ln220">    for(int i = 0; i &lt; wd; i++)</a>
<a name="ln221">    {</a>
<a name="ln222">      memcpy(out2, in2, bpp);</a>
<a name="ln223">      in2 += bpp;</a>
<a name="ln224">      out2 += si;</a>
<a name="ln225">    }</a>
<a name="ln226">  }</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">void dt_imageio_flip_buffers_ui16_to_float(float *out, const uint16_t *in, const float black,</a>
<a name="ln230">                                           const float white, const int ch, const int wd, const int ht,</a>
<a name="ln231">                                           const int fwd, const int fht, const int stride,</a>
<a name="ln232">                                           const dt_image_orientation_t orientation)</a>
<a name="ln233">{</a>
<a name="ln234">  const float scale = 1.0f / (white - black);</a>
<a name="ln235">  if(!orientation)</a>
<a name="ln236">  {</a>
<a name="ln237">#ifdef _OPENMP</a>
<a name="ln238">#pragma omp parallel for default(none) \</a>
<a name="ln239">    dt_omp_firstprivate(wd, ch, scale, stride, black, ht) \</a>
<a name="ln240">    shared(in, out) \</a>
<a name="ln241">    schedule(static)</a>
<a name="ln242">#endif</a>
<a name="ln243">    for(int j = 0; j &lt; ht; j++)</a>
<a name="ln244">      for(int i = 0; i &lt; wd; i++)</a>
<a name="ln245">        for(int k = 0; k &lt; ch; k++)</a>
<a name="ln246">          out[4 * ((size_t)j * wd + i) + k] = (in[ch * ((size_t)j * stride + i) + k] - black) * scale;</a>
<a name="ln247">    return;</a>
<a name="ln248">  }</a>
<a name="ln249">  int ii = 0, jj = 0;</a>
<a name="ln250">  int si = 4, sj = wd * 4;</a>
<a name="ln251">  if(orientation &amp; ORIENTATION_SWAP_XY)</a>
<a name="ln252">  {</a>
<a name="ln253">    sj = 4;</a>
<a name="ln254">    si = ht * 4;</a>
<a name="ln255">  }</a>
<a name="ln256">  if(orientation &amp; ORIENTATION_FLIP_Y)</a>
<a name="ln257">  {</a>
<a name="ln258">    jj = (int)fht - jj - 1;</a>
<a name="ln259">    sj = -sj;</a>
<a name="ln260">  }</a>
<a name="ln261">  if(orientation &amp; ORIENTATION_FLIP_X)</a>
<a name="ln262">  {</a>
<a name="ln263">    ii = (int)fwd - ii - 1;</a>
<a name="ln264">    si = -si;</a>
<a name="ln265">  }</a>
<a name="ln266">#ifdef _OPENMP</a>
<a name="ln267">#pragma omp parallel for default(none) \</a>
<a name="ln268">  dt_omp_firstprivate(wd, ch, black, scale, stride, ht) \</a>
<a name="ln269">  shared(in, out, jj, ii, sj, si) \</a>
<a name="ln270">  schedule(static)</a>
<a name="ln271">#endif</a>
<a name="ln272">  for(int j = 0; j &lt; ht; j++)</a>
<a name="ln273">  {</a>
<a name="ln274">    float *out2 = out + (size_t)labs(sj) * jj + (size_t)labs(si) * ii + (size_t)sj * j;</a>
<a name="ln275">    const uint16_t *in2 = in + stride * j;</a>
<a name="ln276">    for(int i = 0; i &lt; wd; i++)</a>
<a name="ln277">    {</a>
<a name="ln278">      for(int k = 0; k &lt; ch; k++) out2[k] = (in2[k] - black) * scale;</a>
<a name="ln279">      in2 += ch;</a>
<a name="ln280">      out2 += si;</a>
<a name="ln281">    }</a>
<a name="ln282">  }</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">void dt_imageio_flip_buffers_ui8_to_float(float *out, const uint8_t *in, const float black, const float white,</a>
<a name="ln286">                                          const int ch, const int wd, const int ht, const int fwd,</a>
<a name="ln287">                                          const int fht, const int stride,</a>
<a name="ln288">                                          const dt_image_orientation_t orientation)</a>
<a name="ln289">{</a>
<a name="ln290">  const float scale = 1.0f / (white - black);</a>
<a name="ln291">  if(!orientation)</a>
<a name="ln292">  {</a>
<a name="ln293">#ifdef _OPENMP</a>
<a name="ln294">#pragma omp parallel for default(none) \</a>
<a name="ln295">    dt_omp_firstprivate(wd, scale, black, ht, ch, stride) \</a>
<a name="ln296">    shared(in, out) \</a>
<a name="ln297">    schedule(static)</a>
<a name="ln298">#endif</a>
<a name="ln299">    for(int j = 0; j &lt; ht; j++)</a>
<a name="ln300">      for(int i = 0; i &lt; wd; i++)</a>
<a name="ln301">        for(int k = 0; k &lt; ch; k++)</a>
<a name="ln302">          out[4 * ((size_t)j * wd + i) + k] = (in[(size_t)j * stride + ch * i + k] - black) * scale;</a>
<a name="ln303">    return;</a>
<a name="ln304">  }</a>
<a name="ln305">  int ii = 0, jj = 0;</a>
<a name="ln306">  int si = 4, sj = wd * 4;</a>
<a name="ln307">  if(orientation &amp; ORIENTATION_SWAP_XY)</a>
<a name="ln308">  {</a>
<a name="ln309">    sj = 4;</a>
<a name="ln310">    si = ht * 4;</a>
<a name="ln311">  }</a>
<a name="ln312">  if(orientation &amp; ORIENTATION_FLIP_Y)</a>
<a name="ln313">  {</a>
<a name="ln314">    jj = (int)fht - jj - 1;</a>
<a name="ln315">    sj = -sj;</a>
<a name="ln316">  }</a>
<a name="ln317">  if(orientation &amp; ORIENTATION_FLIP_X)</a>
<a name="ln318">  {</a>
<a name="ln319">    ii = (int)fwd - ii - 1;</a>
<a name="ln320">    si = -si;</a>
<a name="ln321">  }</a>
<a name="ln322">#ifdef _OPENMP</a>
<a name="ln323">#pragma omp parallel for default(none) \</a>
<a name="ln324">  dt_omp_firstprivate(wd, ch, scale, black, stride, ht) \</a>
<a name="ln325">  shared(in, out, jj, ii, sj, si) \</a>
<a name="ln326">  schedule(static)</a>
<a name="ln327">#endif</a>
<a name="ln328">  for(int j = 0; j &lt; ht; j++)</a>
<a name="ln329">  {</a>
<a name="ln330">    float *out2 = out + (size_t)labs(sj) * jj + (size_t)labs(si) * ii + sj * j;</a>
<a name="ln331">    const uint8_t *in2 = in + (size_t)stride * j;</a>
<a name="ln332">    for(int i = 0; i &lt; wd; i++)</a>
<a name="ln333">    {</a>
<a name="ln334">      for(int k = 0; k &lt; ch; k++) out2[k] = (in2[k] - black) * scale;</a>
<a name="ln335">      in2 += ch;</a>
<a name="ln336">      out2 += si;</a>
<a name="ln337">    }</a>
<a name="ln338">  }</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">size_t dt_imageio_write_pos(int i, int j, int wd, int ht, float fwd, float fht,</a>
<a name="ln342">                            dt_image_orientation_t orientation)</a>
<a name="ln343">{</a>
<a name="ln344">  int ii = i, jj = j, w = wd, fw = fwd, fh = fht;</a>
<a name="ln345">  if(orientation &amp; ORIENTATION_SWAP_XY)</a>
<a name="ln346">  {</a>
<a name="ln347">    w = ht;</a>
<a name="ln348">    ii = j;</a>
<a name="ln349">    jj = i;</a>
<a name="ln350">    fw = fht;</a>
<a name="ln351">    fh = fwd;</a>
<a name="ln352">  }</a>
<a name="ln353">  if(orientation &amp; ORIENTATION_FLIP_X) ii = (int)fw - ii - 1;</a>
<a name="ln354">  if(orientation &amp; ORIENTATION_FLIP_Y) jj = (int)fh - jj - 1;</a>
<a name="ln355">  return (size_t)jj * w + ii;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">dt_imageio_retval_t dt_imageio_open_hdr(dt_image_t *img, const char *filename, dt_mipmap_buffer_t *buf)</a>
<a name="ln359">{</a>
<a name="ln360">  // if buf is NULL, don't proceed</a>
<a name="ln361">  if(!buf) return DT_IMAGEIO_OK;</a>
<a name="ln362">  // needed to alloc correct buffer size:</a>
<a name="ln363">  img-&gt;buf_dsc.channels = 4;</a>
<a name="ln364">  img-&gt;buf_dsc.datatype = TYPE_FLOAT;</a>
<a name="ln365">  img-&gt;buf_dsc.cst = iop_cs_rgb;</a>
<a name="ln366">  dt_imageio_retval_t ret;</a>
<a name="ln367">  dt_image_loader_t loader;</a>
<a name="ln368">#ifdef HAVE_OPENEXR</a>
<a name="ln369">  loader = LOADER_EXR;</a>
<a name="ln370">  ret = dt_imageio_open_exr(img, filename, buf);</a>
<a name="ln371">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL) goto return_label;</a>
<a name="ln372">#endif</a>
<a name="ln373">  loader = LOADER_RGBE;</a>
<a name="ln374">  ret = dt_imageio_open_rgbe(img, filename, buf);</a>
<a name="ln375">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL) goto return_label;</a>
<a name="ln376">  loader = LOADER_PFM;</a>
<a name="ln377">  ret = dt_imageio_open_pfm(img, filename, buf);</a>
<a name="ln378">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL) goto return_label;</a>
<a name="ln379">return_label:</a>
<a name="ln380">  if(ret == DT_IMAGEIO_OK)</a>
<a name="ln381">  {</a>
<a name="ln382">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln383">    img-&gt;flags &amp;= ~DT_IMAGE_LDR;</a>
<a name="ln384">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln385">    img-&gt;flags |= DT_IMAGE_HDR;</a>
<a name="ln386">    img-&gt;loader = loader;</a>
<a name="ln387">  }</a>
<a name="ln388">  return ret;</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">/* magic data: exclusion,offset,length, xx, yy, ...</a>
<a name="ln392">    just add magic bytes to match to this struct</a>
<a name="ln393">    to extend mathc on ldr formats.</a>
<a name="ln394">*/</a>
<a name="ln395">static const uint8_t _imageio_ldr_magic[] = {</a>
<a name="ln396">  /* jpeg magics */</a>
<a name="ln397">  0x00, 0x00, 0x02, 0xff, 0xd8, // SOI marker</a>
<a name="ln398"> </a>
<a name="ln399">#ifdef HAVE_OPENJPEG</a>
<a name="ln400">  /* jpeg 2000, jp2 format */</a>
<a name="ln401">  0x00, 0x00, 0x0c, 0x0,  0x0,  0x0,  0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A,</a>
<a name="ln402"> </a>
<a name="ln403">  /* jpeg 2000, j2k format */</a>
<a name="ln404">  0x00, 0x00, 0x05, 0xFF, 0x4F, 0xFF, 0x51, 0x00,</a>
<a name="ln405">#endif</a>
<a name="ln406"> </a>
<a name="ln407">  /* png image */</a>
<a name="ln408">  0x00, 0x01, 0x03, 0x50, 0x4E, 0x47, // ASCII 'PNG'</a>
<a name="ln409"> </a>
<a name="ln410"> </a>
<a name="ln411">  /* Canon CR2/CRW is like TIFF with additional magic numbers so must come</a>
<a name="ln412">     before tiff as an exclusion */</a>
<a name="ln413"> </a>
<a name="ln414">  /* Most CR2 */</a>
<a name="ln415">  0x01, 0x00, 0x0a, 0x49, 0x49, 0x2a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x43, 0x52,</a>
<a name="ln416"> </a>
<a name="ln417">  /* CR3 (ISO Media) */</a>
<a name="ln418">  0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 'f', 't', 'y', 'p', 'c', 'r', 'x', ' ', 0x00, 0x00, 0x00, 0x01, 'c', 'r', 'x', ' ', 'i', 's', 'o', 'm',</a>
<a name="ln419"> </a>
<a name="ln420">  // Older Canon RAW format with TIF Extension (i.e. 1Ds and 1D)</a>
<a name="ln421">  0x01, 0x00, 0x0a, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x10, 0xba, 0xb0,</a>
<a name="ln422"> </a>
<a name="ln423">  // Older Canon RAW format with TIF Extension (i.e. D2000)</a>
<a name="ln424">  0x01, 0x00, 0x0a, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x11, 0x34, 0x00, 0x04,</a>
<a name="ln425"> </a>
<a name="ln426">  // Older Canon RAW format with TIF Extension (i.e. DCS1)</a>
<a name="ln427">  0x01, 0x00, 0x0a, 0x49, 0x49, 0x2a, 0x00, 0x00, 0x03, 0x00, 0x00, 0xff, 0x01,</a>
<a name="ln428"> </a>
<a name="ln429">  // Older Kodak RAW format with TIF Extension (i.e. DCS520C)</a>
<a name="ln430">  0x01, 0x00, 0x0a, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x11, 0xa8, 0x00, 0x04,</a>
<a name="ln431"> </a>
<a name="ln432">  // Older Kodak RAW format with TIF Extension (i.e. DCS560C)</a>
<a name="ln433">  0x01, 0x00, 0x0a, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x11, 0x76, 0x00, 0x04,</a>
<a name="ln434"> </a>
<a name="ln435">  // Older Kodak RAW format with TIF Extension (i.e. DCS460D)</a>
<a name="ln436">  0x01, 0x00, 0x0a, 0x49, 0x49, 0x2a, 0x00, 0x00, 0x03, 0x00, 0x00, 0x7c, 0x01,</a>
<a name="ln437"> </a>
<a name="ln438">  /* IIQ raw images, may be either .IIQ, or .TIF */</a>
<a name="ln439">  0x01, 0x08, 0x04, 0x49, 0x49, 0x49, 0x49,</a>
<a name="ln440"> </a>
<a name="ln441">  /* tiff image, intel */</a>
<a name="ln442">  0x00, 0x00, 0x04, 0x4d, 0x4d, 0x00, 0x2a,</a>
<a name="ln443"> </a>
<a name="ln444">  /* tiff image, motorola */</a>
<a name="ln445">  0x00, 0x00, 0x04, 0x49, 0x49, 0x2a, 0x00,</a>
<a name="ln446"> </a>
<a name="ln447">  /* binary NetPNM images: pbm, pgm and pbm */</a>
<a name="ln448">  0x00, 0x00, 0x02, 0x50, 0x34,</a>
<a name="ln449">  0x00, 0x00, 0x02, 0x50, 0x35,</a>
<a name="ln450">  0x00, 0x00, 0x02, 0x50, 0x36</a>
<a name="ln451">};</a>
<a name="ln452"> </a>
<a name="ln453">gboolean dt_imageio_is_ldr(const char *filename)</a>
<a name="ln454">{</a>
<a name="ln455">  size_t offset = 0;</a>
<a name="ln456">  uint8_t block[32] = { 0 }; // keep this big enough for whatever magic size we want to compare to!</a>
<a name="ln457">  FILE *fin = g_fopen(filename, &quot;rb&quot;);</a>
<a name="ln458">  if(fin)</a>
<a name="ln459">  {</a>
<a name="ln460">    /* read block from file */</a>
<a name="ln461">    size_t s = fread(block, sizeof(block), 1, fin);</a>
<a name="ln462">    fclose(fin);</a>
<a name="ln463"> </a>
<a name="ln464">    /* compare magic's */</a>
<a name="ln465">    while(s)</a>
<a name="ln466">    {</a>
<a name="ln467">      if(_imageio_ldr_magic[offset + 2] &gt; sizeof(block)</a>
<a name="ln468">        || offset + 3 + _imageio_ldr_magic[offset + 2] &gt; sizeof(_imageio_ldr_magic))</a>
<a name="ln469">      {</a>
<a name="ln470">        fprintf(stderr, &quot;error: buffer in %s is too small!\n&quot;, __FUNCTION__);</a>
<a name="ln471">        return FALSE;</a>
<a name="ln472">      }</a>
<a name="ln473">      if(memcmp(_imageio_ldr_magic + offset + 3, block + _imageio_ldr_magic[offset + 1],</a>
<a name="ln474">                _imageio_ldr_magic[offset + 2]) == 0)</a>
<a name="ln475">      {</a>
<a name="ln476">        if(_imageio_ldr_magic[offset] == 0x01)</a>
<a name="ln477">          return FALSE;</a>
<a name="ln478">        else</a>
<a name="ln479">          return TRUE;</a>
<a name="ln480">      }</a>
<a name="ln481">      offset += 3 + (_imageio_ldr_magic + offset)[2];</a>
<a name="ln482"> </a>
<a name="ln483">      /* check if finished */</a>
<a name="ln484">      if(offset &gt;= sizeof(_imageio_ldr_magic)) break;</a>
<a name="ln485">    }</a>
<a name="ln486">  }</a>
<a name="ln487">  return FALSE;</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490">int dt_imageio_is_hdr(const char *filename)</a>
<a name="ln491">{</a>
<a name="ln492">  const char *c = filename + strlen(filename);</a>
<a name="ln493">  while(c &gt; filename &amp;&amp; *c != '.') c--;</a>
<a name="ln494">  if(*c == '.')</a>
<a name="ln495">    if(!strcasecmp(c, &quot;.pfm&quot;) || !strcasecmp(c, &quot;.hdr&quot;)</a>
<a name="ln496">#ifdef HAVE_OPENEXR</a>
<a name="ln497">       || !strcasecmp(c, &quot;.exr&quot;)</a>
<a name="ln498">#endif</a>
<a name="ln499">           )</a>
<a name="ln500">      return 1;</a>
<a name="ln501">  return 0;</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">// transparent read method to load ldr image to dt_raw_image_t with exif and so on.</a>
<a name="ln505">dt_imageio_retval_t dt_imageio_open_ldr(dt_image_t *img, const char *filename, dt_mipmap_buffer_t *buf)</a>
<a name="ln506">{</a>
<a name="ln507">  // if buf is NULL, don't proceed</a>
<a name="ln508">  if(!buf) return DT_IMAGEIO_OK;</a>
<a name="ln509">  dt_imageio_retval_t ret;</a>
<a name="ln510"> </a>
<a name="ln511">  ret = dt_imageio_open_jpeg(img, filename, buf);</a>
<a name="ln512">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln513">  {</a>
<a name="ln514">    img-&gt;buf_dsc.cst = iop_cs_rgb; // jpeg is always RGB</a>
<a name="ln515">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln516">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln517">    img-&gt;flags &amp;= ~DT_IMAGE_HDR;</a>
<a name="ln518">    img-&gt;flags |= DT_IMAGE_LDR;</a>
<a name="ln519">    img-&gt;loader = LOADER_JPEG;</a>
<a name="ln520">    return ret;</a>
<a name="ln521">  }</a>
<a name="ln522"> </a>
<a name="ln523">  ret = dt_imageio_open_tiff(img, filename, buf);</a>
<a name="ln524">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln525">  {</a>
<a name="ln526">    // cst is set by dt_imageio_open_tiff()</a>
<a name="ln527">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln528">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln529">    img-&gt;flags &amp;= ~DT_IMAGE_HDR;</a>
<a name="ln530">    img-&gt;flags |= DT_IMAGE_LDR;</a>
<a name="ln531">    img-&gt;loader = LOADER_TIFF;</a>
<a name="ln532">    return ret;</a>
<a name="ln533">  }</a>
<a name="ln534"> </a>
<a name="ln535">  ret = dt_imageio_open_png(img, filename, buf);</a>
<a name="ln536">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln537">  {</a>
<a name="ln538">    img-&gt;buf_dsc.cst = iop_cs_rgb; // png is always RGB</a>
<a name="ln539">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln540">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln541">    img-&gt;flags &amp;= ~DT_IMAGE_HDR;</a>
<a name="ln542">    img-&gt;flags |= DT_IMAGE_LDR;</a>
<a name="ln543">    img-&gt;loader = LOADER_PNG;</a>
<a name="ln544">    return ret;</a>
<a name="ln545">  }</a>
<a name="ln546"> </a>
<a name="ln547">#ifdef HAVE_OPENJPEG</a>
<a name="ln548">  ret = dt_imageio_open_j2k(img, filename, buf);</a>
<a name="ln549">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln550">  {</a>
<a name="ln551">    img-&gt;buf_dsc.cst = iop_cs_rgb; // j2k is always RGB</a>
<a name="ln552">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln553">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln554">    img-&gt;flags &amp;= ~DT_IMAGE_HDR;</a>
<a name="ln555">    img-&gt;flags |= DT_IMAGE_LDR;</a>
<a name="ln556">    img-&gt;loader = LOADER_J2K;</a>
<a name="ln557">    return ret;</a>
<a name="ln558">  }</a>
<a name="ln559">#endif</a>
<a name="ln560"> </a>
<a name="ln561">  ret = dt_imageio_open_pnm(img, filename, buf);</a>
<a name="ln562">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln563">  {</a>
<a name="ln564">    img-&gt;buf_dsc.cst = iop_cs_rgb; // pnm is always RGB</a>
<a name="ln565">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln566">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln567">    img-&gt;flags &amp;= ~DT_IMAGE_HDR;</a>
<a name="ln568">    img-&gt;flags |= DT_IMAGE_LDR;</a>
<a name="ln569">    img-&gt;loader = LOADER_PNM;</a>
<a name="ln570">    return ret;</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  return DT_IMAGEIO_FILE_CORRUPTED;</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">void dt_imageio_to_fractional(float in, uint32_t *num, uint32_t *den)</a>
<a name="ln577">{</a>
<a name="ln578">  if(!(in &gt;= 0))</a>
<a name="ln579">  {</a>
<a name="ln580">    *num = *den = 0;</a>
<a name="ln581">    return;</a>
<a name="ln582">  }</a>
<a name="ln583">  *den = 1;</a>
<a name="ln584">  *num = (int)(in * *den + .5f);</a>
<a name="ln585">  while(fabsf(*num / (float)*den - in) &gt; 0.001f)</a>
<a name="ln586">  {</a>
<a name="ln587">    *den *= 10;</a>
<a name="ln588">    *num = (int)(in * *den + .5f);</a>
<a name="ln589">  }</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">int dt_imageio_export(const uint32_t imgid, const char *filename, dt_imageio_module_format_t *format,</a>
<a name="ln593">                      dt_imageio_module_data_t *format_params, const gboolean high_quality, const gboolean upscale,</a>
<a name="ln594">                      const gboolean copy_metadata, dt_colorspaces_color_profile_type_t icc_type,</a>
<a name="ln595">                      const gchar *icc_filename, dt_iop_color_intent_t icc_intent,</a>
<a name="ln596">                      dt_imageio_module_storage_t *storage, dt_imageio_module_data_t *storage_params, int num,</a>
<a name="ln597">                      int total)</a>
<a name="ln598">{</a>
<a name="ln599">  if(strcmp(format-&gt;mime(format_params), &quot;x-copy&quot;) == 0)</a>
<a name="ln600">    /* This is a just a copy, skip process and just export */</a>
<a name="ln601">    return format-&gt;write_image(format_params, filename, NULL, icc_type, icc_filename, NULL, 0, imgid, num, total, NULL);</a>
<a name="ln602">  else</a>
<a name="ln603">    return dt_imageio_export_with_flags(imgid, filename, format, format_params, FALSE, FALSE, high_quality, upscale,</a>
<a name="ln604">                                        FALSE, NULL, copy_metadata, icc_type, icc_filename, icc_intent, storage,</a>
<a name="ln605">                                        storage_params, num, total);</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">// internal function: to avoid exif blob reading + 8-bit byteorder flag + high-quality override</a>
<a name="ln609">int dt_imageio_export_with_flags(const uint32_t imgid, const char *filename,</a>
<a name="ln610">                                 dt_imageio_module_format_t *format, dt_imageio_module_data_t *format_params,</a>
<a name="ln611">                                 const gboolean ignore_exif, const gboolean display_byteorder,</a>
<a name="ln612">                                 const gboolean high_quality, const gboolean upscale, const gboolean thumbnail_export,</a>
<a name="ln613">                                 const char *filter, const gboolean copy_metadata,</a>
<a name="ln614">                                 dt_colorspaces_color_profile_type_t icc_type, const gchar *icc_filename,</a>
<a name="ln615">                                 dt_iop_color_intent_t icc_intent,</a>
<a name="ln616">                                 dt_imageio_module_storage_t *storage,</a>
<a name="ln617">                                 dt_imageio_module_data_t *storage_params, int num, int total)</a>
<a name="ln618">{</a>
<a name="ln619">  dt_develop_t dev;</a>
<a name="ln620">  dt_dev_init(&amp;dev, 0);</a>
<a name="ln621">  dt_dev_load_image(&amp;dev, imgid);</a>
<a name="ln622"> </a>
<a name="ln623">  const int buf_is_downscaled</a>
<a name="ln624">      = (thumbnail_export &amp;&amp; dt_conf_get_bool(&quot;plugins/lighttable/low_quality_thumbnails&quot;));</a>
<a name="ln625"> </a>
<a name="ln626">  dt_mipmap_buffer_t buf;</a>
<a name="ln627">  if(buf_is_downscaled)</a>
<a name="ln628">    dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, DT_MIPMAP_F, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln629">  else</a>
<a name="ln630">    dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, DT_MIPMAP_FULL, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln631"> </a>
<a name="ln632">  const dt_image_t *img = &amp;dev.image_storage;</a>
<a name="ln633"> </a>
<a name="ln634">  if(!buf.buf || !buf.width || !buf.height)</a>
<a name="ln635">  {</a>
<a name="ln636">    fprintf(stderr, &quot;allocation failed???\n&quot;);</a>
<a name="ln637">    dt_control_log(_(&quot;image `%s' is not available!&quot;), img-&gt;filename);</a>
<a name="ln638">    goto error_early;</a>
<a name="ln639">  }</a>
<a name="ln640"> </a>
<a name="ln641">  const int wd = img-&gt;width;</a>
<a name="ln642">  const int ht = img-&gt;height;</a>
<a name="ln643"> </a>
<a name="ln644"> </a>
<a name="ln645">  int res = 0;</a>
<a name="ln646"> </a>
<a name="ln647">  dt_times_t start;</a>
<a name="ln648">  dt_get_times(&amp;start);</a>
<a name="ln649">  dt_dev_pixelpipe_t pipe;</a>
<a name="ln650">  res = thumbnail_export ? dt_dev_pixelpipe_init_thumbnail(&amp;pipe, wd, ht)</a>
<a name="ln651">                         : dt_dev_pixelpipe_init_export(&amp;pipe, wd, ht, format-&gt;levels(format_params), TRUE); // TODO</a>
<a name="ln652">  if(!res)</a>
<a name="ln653">  {</a>
<a name="ln654">    dt_control_log(</a>
<a name="ln655">        _(&quot;failed to allocate memory for %s, please lower the threads used for export or buy more memory.&quot;),</a>
<a name="ln656">        thumbnail_export ? C_(&quot;noun&quot;, &quot;thumbnail export&quot;) : C_(&quot;noun&quot;, &quot;export&quot;));</a>
<a name="ln657">    goto error;</a>
<a name="ln658">  }</a>
<a name="ln659"> </a>
<a name="ln660">  //  If a style is to be applied during export, add the iop params into the history</a>
<a name="ln661">  if(!thumbnail_export &amp;&amp; format_params-&gt;style[0] != '\0')</a>
<a name="ln662">  {</a>
<a name="ln663">    GList *style_items = dt_styles_get_item_list(format_params-&gt;style, TRUE, -1);</a>
<a name="ln664">    if(!style_items)</a>
<a name="ln665">    {</a>
<a name="ln666">      dt_control_log(_(&quot;cannot find the style '%s' to apply during export.&quot;), format_params-&gt;style);</a>
<a name="ln667">      goto error;</a>
<a name="ln668">    }</a>
<a name="ln669"> </a>
<a name="ln670">    GList *modules_used = NULL;</a>
<a name="ln671"> </a>
<a name="ln672">    dt_dev_pop_history_items_ext(&amp;dev, dev.history_end);</a>
<a name="ln673"> </a>
<a name="ln674">    GList *st_items = g_list_last(style_items);</a>
<a name="ln675">    while(st_items)</a>
<a name="ln676">    {</a>
<a name="ln677">      dt_style_item_t *st_item = (dt_style_item_t *)(st_items-&gt;data);</a>
<a name="ln678"> </a>
<a name="ln679">      dt_styles_apply_style_item(&amp;dev, st_item, &amp;modules_used, format_params-&gt;style_append);</a>
<a name="ln680"> </a>
<a name="ln681">      st_items = g_list_previous(st_items);</a>
<a name="ln682">    }</a>
<a name="ln683"> </a>
<a name="ln684">    g_list_free(modules_used);</a>
<a name="ln685">    g_list_free_full(style_items, dt_style_item_free);</a>
<a name="ln686">  }</a>
<a name="ln687"> </a>
<a name="ln688">  dt_dev_pixelpipe_set_icc(&amp;pipe, icc_type, icc_filename, icc_intent);</a>
<a name="ln689">  dt_dev_pixelpipe_set_input(&amp;pipe, &amp;dev, (float *)buf.buf, buf.width, buf.height, buf.iscale);</a>
<a name="ln690">  dt_dev_pixelpipe_create_nodes(&amp;pipe, &amp;dev);</a>
<a name="ln691">  dt_dev_pixelpipe_synch_all(&amp;pipe, &amp;dev);</a>
<a name="ln692"> </a>
<a name="ln693">  if(filter)</a>
<a name="ln694">  {</a>
<a name="ln695">    if(!strncmp(filter, &quot;pre:&quot;, 4)) dt_dev_pixelpipe_disable_after(&amp;pipe, filter + 4);</a>
<a name="ln696">    if(!strncmp(filter, &quot;post:&quot;, 5)) dt_dev_pixelpipe_disable_before(&amp;pipe, filter + 5);</a>
<a name="ln697">  }</a>
<a name="ln698"> </a>
<a name="ln699">  dt_dev_pixelpipe_get_dimensions(&amp;pipe, &amp;dev, pipe.iwidth, pipe.iheight, &amp;pipe.processed_width,</a>
<a name="ln700">                                  &amp;pipe.processed_height);</a>
<a name="ln701"> </a>
<a name="ln702">  dt_show_times(&amp;start, &quot;[export] creating pixelpipe&quot;);</a>
<a name="ln703"> </a>
<a name="ln704">  // find output color profile for this image:</a>
<a name="ln705">  int sRGB = 1;</a>
<a name="ln706">  if(icc_type == DT_COLORSPACE_SRGB)</a>
<a name="ln707">  {</a>
<a name="ln708">    sRGB = 1;</a>
<a name="ln709">  }</a>
<a name="ln710">  else if(icc_type == DT_COLORSPACE_NONE)</a>
<a name="ln711">  {</a>
<a name="ln712">    GList *modules = dev.iop;</a>
<a name="ln713">    dt_iop_module_t *colorout = NULL;</a>
<a name="ln714">    while(modules)</a>
<a name="ln715">    {</a>
<a name="ln716">      colorout = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln717">      if(colorout-&gt;get_p &amp;&amp; strcmp(colorout-&gt;op, &quot;colorout&quot;) == 0)</a>
<a name="ln718">      {</a>
<a name="ln719">        const dt_colorspaces_color_profile_type_t *type = colorout-&gt;get_p(colorout-&gt;params, &quot;type&quot;);</a>
<a name="ln720">        sRGB = (!type || *type == DT_COLORSPACE_SRGB);</a>
<a name="ln721">        break; // colorout can't have &gt; 1 instance</a>
<a name="ln722">      }</a>
<a name="ln723">      modules = g_list_next(modules);</a>
<a name="ln724">    }</a>
<a name="ln725">  }</a>
<a name="ln726">  else</a>
<a name="ln727">  {</a>
<a name="ln728">    sRGB = 0;</a>
<a name="ln729">  }</a>
<a name="ln730"> </a>
<a name="ln731">  // get only once at the beginning, in case the user changes it on the way:</a>
<a name="ln732">  const gboolean high_quality_processing</a>
<a name="ln733">      = ((format_params-&gt;max_width == 0 || format_params-&gt;max_width &gt;= pipe.processed_width)</a>
<a name="ln734">         &amp;&amp; (format_params-&gt;max_height == 0 || format_params-&gt;max_height &gt;= pipe.processed_height))</a>
<a name="ln735">            ? FALSE</a>
<a name="ln736">            : high_quality;</a>
<a name="ln737"> </a>
<a name="ln738">  const int width = format_params-&gt;max_width;</a>
<a name="ln739">  const int height = format_params-&gt;max_height;</a>
<a name="ln740"> </a>
<a name="ln741">  const float max_scale = ( upscale &amp;&amp; ( width &gt; 0 || height &gt; 0 )) ? 100.0 : 1.0;</a>
<a name="ln742"> </a>
<a name="ln743">  const double scalex = width &gt; 0 ? fminf(width / (double)pipe.processed_width, max_scale) : max_scale;</a>
<a name="ln744">  const double scaley = height &gt; 0 ? fminf(height / (double)pipe.processed_height, max_scale) : max_scale;</a>
<a name="ln745">  const double scale = fminf(scalex, scaley);</a>
<a name="ln746"> </a>
<a name="ln747">  const int processed_width = scale * pipe.processed_width + .5f;</a>
<a name="ln748">  const int processed_height = scale * pipe.processed_height + .5f;</a>
<a name="ln749"> </a>
<a name="ln750">  const int bpp = format-&gt;bpp(format_params);</a>
<a name="ln751"> </a>
<a name="ln752">  dt_get_times(&amp;start);</a>
<a name="ln753">  if(high_quality_processing)</a>
<a name="ln754">  {</a>
<a name="ln755">    /*</a>
<a name="ln756">     * if high quality processing was requested, downsampling will be done</a>
<a name="ln757">     * at the very end of the pipe (just before border and watermark)</a>
<a name="ln758">     */</a>
<a name="ln759">    dt_dev_pixelpipe_process_no_gamma(&amp;pipe, &amp;dev, 0, 0, processed_width, processed_height, scale);</a>
<a name="ln760">  }</a>
<a name="ln761">  else</a>
<a name="ln762">  {</a>
<a name="ln763">    // else, downsampling will be right after demosaic</a>
<a name="ln764"> </a>
<a name="ln765">    // so we need to turn temporarily disable in-pipe late downsampling iop.</a>
<a name="ln766"> </a>
<a name="ln767">    // find the finalscale module</a>
<a name="ln768">    dt_dev_pixelpipe_iop_t *finalscale = NULL;</a>
<a name="ln769">    {</a>
<a name="ln770">      GList *nodes = g_list_last(pipe.nodes);</a>
<a name="ln771">      while(nodes)</a>
<a name="ln772">      {</a>
<a name="ln773">        dt_dev_pixelpipe_iop_t *node = (dt_dev_pixelpipe_iop_t *)(nodes-&gt;data);</a>
<a name="ln774">        if(!strcmp(node-&gt;module-&gt;op, &quot;finalscale&quot;))</a>
<a name="ln775">        {</a>
<a name="ln776">          finalscale = node;</a>
<a name="ln777">          break;</a>
<a name="ln778">        }</a>
<a name="ln779">        nodes = g_list_previous(nodes);</a>
<a name="ln780">      }</a>
<a name="ln781">    }</a>
<a name="ln782"> </a>
<a name="ln783">    if(finalscale) finalscale-&gt;enabled = 0;</a>
<a name="ln784"> </a>
<a name="ln785">    // do the processing (8-bit with special treatment, to make sure we can use openmp further down):</a>
<a name="ln786">    if(bpp == 8)</a>
<a name="ln787">      dt_dev_pixelpipe_process(&amp;pipe, &amp;dev, 0, 0, processed_width, processed_height, scale);</a>
<a name="ln788">    else</a>
<a name="ln789">      dt_dev_pixelpipe_process_no_gamma(&amp;pipe, &amp;dev, 0, 0, processed_width, processed_height, scale);</a>
<a name="ln790"> </a>
<a name="ln791">    if(finalscale) finalscale-&gt;enabled = 1;</a>
<a name="ln792">  }</a>
<a name="ln793">  dt_show_times(&amp;start, thumbnail_export ? &quot;[dev_process_thumbnail] pixel pipeline processing&quot;</a>
<a name="ln794">                                         : &quot;[dev_process_export] pixel pipeline processing&quot;);</a>
<a name="ln795"> </a>
<a name="ln796">  uint8_t *outbuf = pipe.backbuf;</a>
<a name="ln797"> </a>
<a name="ln798">  // downconversion to low-precision formats:</a>
<a name="ln799">  if(bpp == 8)</a>
<a name="ln800">  {</a>
<a name="ln801">    if(display_byteorder)</a>
<a name="ln802">    {</a>
<a name="ln803">      if(high_quality_processing)</a>
<a name="ln804">      {</a>
<a name="ln805">        const float *const inbuf = (float *)outbuf;</a>
<a name="ln806">        for(size_t k = 0; k &lt; (size_t)processed_width * processed_height; k++)</a>
<a name="ln807">        {</a>
<a name="ln808">          // convert in place, this is unfortunately very serial..</a>
<a name="ln809">          const uint8_t r = CLAMP(inbuf[4 * k + 2] * 0xff, 0, 0xff);</a>
<a name="ln810">          const uint8_t g = CLAMP(inbuf[4 * k + 1] * 0xff, 0, 0xff);</a>
<a name="ln811">          const uint8_t b = CLAMP(inbuf[4 * k + 0] * 0xff, 0, 0xff);</a>
<a name="ln812">          outbuf[4 * k + 0] = r;</a>
<a name="ln813">          outbuf[4 * k + 1] = g;</a>
<a name="ln814">          outbuf[4 * k + 2] = b;</a>
<a name="ln815">        }</a>
<a name="ln816">      }</a>
<a name="ln817">      // else processing output was 8-bit already, and no need to swap order</a>
<a name="ln818">    }</a>
<a name="ln819">    else // need to flip</a>
<a name="ln820">    {</a>
<a name="ln821">      // ldr output: char</a>
<a name="ln822">      if(high_quality_processing)</a>
<a name="ln823">      {</a>
<a name="ln824">        const float *const inbuf = (float *)outbuf;</a>
<a name="ln825">        for(size_t k = 0; k &lt; (size_t)processed_width * processed_height; k++)</a>
<a name="ln826">        {</a>
<a name="ln827">          // convert in place, this is unfortunately very serial..</a>
<a name="ln828">          const uint8_t r = CLAMP(inbuf[4 * k + 0] * 0xff, 0, 0xff);</a>
<a name="ln829">          const uint8_t g = CLAMP(inbuf[4 * k + 1] * 0xff, 0, 0xff);</a>
<a name="ln830">          const uint8_t b = CLAMP(inbuf[4 * k + 2] * 0xff, 0, 0xff);</a>
<a name="ln831">          outbuf[4 * k + 0] = r;</a>
<a name="ln832">          outbuf[4 * k + 1] = g;</a>
<a name="ln833">          outbuf[4 * k + 2] = b;</a>
<a name="ln834">        }</a>
<a name="ln835">      }</a>
<a name="ln836">      else</a>
<a name="ln837">      { // !display_byteorder, need to swap:</a>
<a name="ln838">        uint8_t *const buf8 = pipe.backbuf;</a>
<a name="ln839">#ifdef _OPENMP</a>
<a name="ln840">#pragma omp parallel for default(none) \</a>
<a name="ln841">  dt_omp_firstprivate(processed_width, processed_height, buf8) \</a>
<a name="ln842">  schedule(static)</a>
<a name="ln843">#endif</a>
<a name="ln844">        // just flip byte order</a>
<a name="ln845">        for(size_t k = 0; k &lt; (size_t)processed_width * processed_height; k++)</a>
<a name="ln846">        {</a>
<a name="ln847">          uint8_t tmp = buf8[4 * k + 0];</a>
<a name="ln848">          buf8[4 * k + 0] = buf8[4 * k + 2];</a>
<a name="ln849">          buf8[4 * k + 2] = tmp;</a>
<a name="ln850">        }</a>
<a name="ln851">      }</a>
<a name="ln852">    }</a>
<a name="ln853">  }</a>
<a name="ln854">  else if(bpp == 16)</a>
<a name="ln855">  {</a>
<a name="ln856">    // uint16_t per color channel</a>
<a name="ln857">    float *buff = (float *)outbuf;</a>
<a name="ln858">    uint16_t *buf16 = (uint16_t *)outbuf;</a>
<a name="ln859">    for(int y = 0; y &lt; processed_height; y++)</a>
<a name="ln860">      for(int x = 0; x &lt; processed_width; x++)</a>
<a name="ln861">      {</a>
<a name="ln862">        // convert in place</a>
<a name="ln863">        const size_t k = (size_t)processed_width * y + x;</a>
<a name="ln864">        for(int i = 0; i &lt; 3; i++) buf16[4 * k + i] = CLAMP(buff[4 * k + i] * 0x10000, 0, 0xffff);</a>
<a name="ln865">      }</a>
<a name="ln866">  }</a>
<a name="ln867">  // else output float, no further harm done to the pixels :)</a>
<a name="ln868"> </a>
<a name="ln869">  format_params-&gt;width = processed_width;</a>
<a name="ln870">  format_params-&gt;height = processed_height;</a>
<a name="ln871"> </a>
<a name="ln872">  if(!ignore_exif)</a>
<a name="ln873">  {</a>
<a name="ln874">    int length;</a>
<a name="ln875">    uint8_t *exif_profile = NULL; // Exif data should be 65536 bytes max, but if original size is close to that,</a>
<a name="ln876">                                  // adding new tags could make it go over that... so let it be and see what</a>
<a name="ln877">                                  // happens when we write the image</a>
<a name="ln878">    char pathname[PATH_MAX] = { 0 };</a>
<a name="ln879">    gboolean from_cache = TRUE;</a>
<a name="ln880">    dt_image_full_path(imgid, pathname, sizeof(pathname), &amp;from_cache);</a>
<a name="ln881">    // last param is dng mode, it's false here</a>
<a name="ln882">    length = dt_exif_read_blob(&amp;exif_profile, pathname, imgid, sRGB, processed_width, processed_height, 0);</a>
<a name="ln883"> </a>
<a name="ln884">    res = format-&gt;write_image(format_params, filename, outbuf, icc_type, icc_filename, exif_profile, length, imgid,</a>
<a name="ln885">                              num, total, &amp;pipe);</a>
<a name="ln886"> </a>
<a name="ln887">    free(exif_profile);</a>
<a name="ln888">  }</a>
<a name="ln889">  else</a>
<a name="ln890">  {</a>
<a name="ln891">    res = format-&gt;write_image(format_params, filename, outbuf, icc_type, icc_filename, NULL, 0, imgid, num, total,</a>
<a name="ln892">                              &amp;pipe);</a>
<a name="ln893">  }</a>
<a name="ln894"> </a>
<a name="ln895">  dt_dev_pixelpipe_cleanup(&amp;pipe);</a>
<a name="ln896">  dt_dev_cleanup(&amp;dev);</a>
<a name="ln897">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln898"> </a>
<a name="ln899">  /* now write xmp into that container, if possible */</a>
<a name="ln900">  if(copy_metadata &amp;&amp; (format-&gt;flags(format_params) &amp; FORMAT_FLAGS_SUPPORT_XMP))</a>
<a name="ln901">  {</a>
<a name="ln902">    dt_exif_xmp_attach(imgid, filename);</a>
<a name="ln903">    // no need to cancel the export if this fail</a>
<a name="ln904">  }</a>
<a name="ln905"> </a>
<a name="ln906">  if(!thumbnail_export &amp;&amp; strcmp(format-&gt;mime(format_params), &quot;memory&quot;)</a>
<a name="ln907">    &amp;&amp; !(format-&gt;flags(format_params) &amp; FORMAT_FLAGS_NO_TMPFILE))</a>
<a name="ln908">  {</a>
<a name="ln909">#ifdef USE_LUA</a>
<a name="ln910">    //Synchronous calling of lua intermediate-export-image events</a>
<a name="ln911">    dt_lua_lock();</a>
<a name="ln912"> </a>
<a name="ln913">    lua_State *L = darktable.lua_state.state;</a>
<a name="ln914"> </a>
<a name="ln915">    luaA_push(L, dt_lua_image_t, &amp;imgid);</a>
<a name="ln916"> </a>
<a name="ln917">    lua_pushstring(L, filename);</a>
<a name="ln918"> </a>
<a name="ln919">    luaA_push_type(L, format-&gt;parameter_lua_type, format_params);</a>
<a name="ln920"> </a>
<a name="ln921">    if (storage)</a>
<a name="ln922">      luaA_push_type(L, storage-&gt;parameter_lua_type, storage_params);</a>
<a name="ln923">    else</a>
<a name="ln924">      lua_pushnil(L);</a>
<a name="ln925"> </a>
<a name="ln926">    dt_lua_event_trigger(L, &quot;intermediate-export-image&quot;, 4);</a>
<a name="ln927"> </a>
<a name="ln928">    dt_lua_unlock();</a>
<a name="ln929">#endif</a>
<a name="ln930"> </a>
<a name="ln931">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_IMAGE_EXPORT_TMPFILE, imgid, filename, format,</a>
<a name="ln932">                            format_params, storage, storage_params);</a>
<a name="ln933">  }</a>
<a name="ln934"> </a>
<a name="ln935">  return res;</a>
<a name="ln936"> </a>
<a name="ln937">error:</a>
<a name="ln938">  dt_dev_pixelpipe_cleanup(&amp;pipe);</a>
<a name="ln939">error_early:</a>
<a name="ln940">  dt_dev_cleanup(&amp;dev);</a>
<a name="ln941">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln942">  return 1;</a>
<a name="ln943">}</a>
<a name="ln944"> </a>
<a name="ln945"> </a>
<a name="ln946">// fallback read method in case file could not be opened yet.</a>
<a name="ln947">// use GraphicsMagick (if supported) to read exotic LDRs</a>
<a name="ln948">dt_imageio_retval_t dt_imageio_open_exotic(dt_image_t *img, const char *filename,</a>
<a name="ln949">                                           dt_mipmap_buffer_t *buf)</a>
<a name="ln950">{</a>
<a name="ln951">  // if buf is NULL, don't proceed</a>
<a name="ln952">  if(!buf) return DT_IMAGEIO_OK;</a>
<a name="ln953">#ifdef HAVE_GRAPHICSMAGICK</a>
<a name="ln954">  dt_imageio_retval_t ret = dt_imageio_open_gm(img, filename, buf);</a>
<a name="ln955">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln956">  {</a>
<a name="ln957">    img-&gt;buf_dsc.cst = iop_cs_rgb;</a>
<a name="ln958">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln959">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln960">    img-&gt;flags &amp;= ~DT_IMAGE_HDR;</a>
<a name="ln961">    img-&gt;flags |= DT_IMAGE_LDR;</a>
<a name="ln962">    img-&gt;loader = LOADER_GM;</a>
<a name="ln963">    return ret;</a>
<a name="ln964">  }</a>
<a name="ln965">#endif</a>
<a name="ln966"> </a>
<a name="ln967">  return DT_IMAGEIO_FILE_CORRUPTED;</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970"> </a>
<a name="ln971">// =================================================</a>
<a name="ln972">//   combined reading</a>
<a name="ln973">// =================================================</a>
<a name="ln974"> </a>
<a name="ln975">dt_imageio_retval_t dt_imageio_open(dt_image_t *img,               // non-const * means you hold a write lock!</a>
<a name="ln976">                                    const char *filename,          // full path</a>
<a name="ln977">                                    dt_mipmap_buffer_t *buf)</a>
<a name="ln978">{</a>
<a name="ln979">  /* first of all, check if file exists, don't bother to test loading if not exists */</a>
<a name="ln980">  if(!g_file_test(filename, G_FILE_TEST_IS_REGULAR)) return !DT_IMAGEIO_OK;</a>
<a name="ln981"> </a>
<a name="ln982">  dt_imageio_retval_t ret = DT_IMAGEIO_FILE_CORRUPTED;</a>
<a name="ln983">  img-&gt;loader = LOADER_UNKNOWN;</a>
<a name="ln984"> </a>
<a name="ln985">  /* check if file is ldr using magic's */</a>
<a name="ln986">  if(dt_imageio_is_ldr(filename)) ret = dt_imageio_open_ldr(img, filename, buf);</a>
<a name="ln987"> </a>
<a name="ln988">  /* silly check using file extensions: */</a>
<a name="ln989">  if(ret != DT_IMAGEIO_OK &amp;&amp; ret != DT_IMAGEIO_CACHE_FULL &amp;&amp; dt_imageio_is_hdr(filename))</a>
<a name="ln990">    ret = dt_imageio_open_hdr(img, filename, buf);</a>
<a name="ln991"> </a>
<a name="ln992">  /* use rawspeed to load the raw */</a>
<a name="ln993">  if(ret != DT_IMAGEIO_OK &amp;&amp; ret != DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln994">  {</a>
<a name="ln995">    ret = dt_imageio_open_rawspeed(img, filename, buf);</a>
<a name="ln996">    if(ret == DT_IMAGEIO_OK)</a>
<a name="ln997">    {</a>
<a name="ln998">      img-&gt;buf_dsc.cst = iop_cs_RAW;</a>
<a name="ln999">      img-&gt;loader = LOADER_RAWSPEED;</a>
<a name="ln1000">    }</a>
<a name="ln1001">  }</a>
<a name="ln1002"> </a>
<a name="ln1003">  /* fallback that tries to open file via GraphicsMagick */</a>
<a name="ln1004">  if(ret != DT_IMAGEIO_OK &amp;&amp; ret != DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln1005">    ret = dt_imageio_open_exotic(img, filename, buf);</a>
<a name="ln1006"> </a>
<a name="ln1007">  return ret;</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1011">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1012">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'res' is always false.</p></div>
<div class="balloon" rel="980"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The enumeration constant 'DT_IMAGEIO_OK' is used as a variable of a Boolean-type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
