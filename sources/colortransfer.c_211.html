
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln22">#include &quot;common/points.h&quot;</a>
<a name="ln23">#include &quot;control/control.h&quot;</a>
<a name="ln24">#include &quot;develop/develop.h&quot;</a>
<a name="ln25">#include &quot;develop/imageop.h&quot;</a>
<a name="ln26">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln27">#include &quot;gui/gtk.h&quot;</a>
<a name="ln28">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln31">#include &lt;inttypes.h&gt;</a>
<a name="ln32">#include &lt;math.h&gt;</a>
<a name="ln33">#include &lt;stdlib.h&gt;</a>
<a name="ln34">#include &lt;string.h&gt;</a>
<a name="ln35">#include &lt;strings.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">/**</a>
<a name="ln38"> * color transfer somewhat based on the glorious paper `color transfer between images'</a>
<a name="ln39"> * by erik reinhard, michael ashikhmin, bruce gooch, and peter shirley, 2001.</a>
<a name="ln40"> * chosen because it officially cites the playboy.</a>
<a name="ln41"> *</a>
<a name="ln42"> * workflow:</a>
<a name="ln43"> * - open the target image, press acquire button</a>
<a name="ln44"> * - right click store as preset</a>
<a name="ln45"> * - open image you want to transfer the color to</a>
<a name="ln46"> * - right click and apply the preset</a>
<a name="ln47"> */</a>
<a name="ln48"> </a>
<a name="ln49">DT_MODULE_INTROSPECTION(1, dt_iop_colortransfer_params_t)</a>
<a name="ln50"> </a>
<a name="ln51">#define HISTN (1 &lt;&lt; 11)</a>
<a name="ln52">#define MAXN 5</a>
<a name="ln53"> </a>
<a name="ln54">typedef enum dt_iop_colortransfer_flag_t</a>
<a name="ln55">{</a>
<a name="ln56">  ACQUIRE = 0,</a>
<a name="ln57">  ACQUIRE2 = 1,</a>
<a name="ln58">  ACQUIRE3 = 2,</a>
<a name="ln59">  ACQUIRED = 3,</a>
<a name="ln60">  APPLY = 4,</a>
<a name="ln61">  NEUTRAL = 5</a>
<a name="ln62">} dt_iop_colortransfer_flag_t;</a>
<a name="ln63"> </a>
<a name="ln64">typedef struct dt_iop_colortransfer_params_t</a>
<a name="ln65">{</a>
<a name="ln66">  dt_iop_colortransfer_flag_t flag;</a>
<a name="ln67">  // hist matching table</a>
<a name="ln68">  float hist[HISTN];</a>
<a name="ln69">  // n-means (max 5?) with mean/variance</a>
<a name="ln70">  float mean[MAXN][2];</a>
<a name="ln71">  float var[MAXN][2];</a>
<a name="ln72">  // number of gaussians used.</a>
<a name="ln73">  int n;</a>
<a name="ln74">} dt_iop_colortransfer_params_t;</a>
<a name="ln75"> </a>
<a name="ln76">typedef struct dt_iop_colortransfer_gui_data_t</a>
<a name="ln77">{</a>
<a name="ln78">  int flowback_set;</a>
<a name="ln79">  dt_iop_colortransfer_params_t flowback;</a>
<a name="ln80">  GtkWidget *apply_button;</a>
<a name="ln81">  GtkWidget *acquire_button;</a>
<a name="ln82">  GtkSpinButton *spinbutton;</a>
<a name="ln83">  GtkWidget *area;</a>
<a name="ln84">  cmsHTRANSFORM xform;</a>
<a name="ln85">} dt_iop_colortransfer_gui_data_t;</a>
<a name="ln86"> </a>
<a name="ln87">typedef struct dt_iop_colortransfer_data_t</a>
<a name="ln88">{</a>
<a name="ln89">  // same as params. (need duplicate because database table preset contains params_t)</a>
<a name="ln90">  dt_iop_colortransfer_flag_t flag;</a>
<a name="ln91">  float hist[HISTN];</a>
<a name="ln92">  float mean[MAXN][2];</a>
<a name="ln93">  float var[MAXN][2];</a>
<a name="ln94">  int n;</a>
<a name="ln95">} dt_iop_colortransfer_data_t;</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">const char *name()</a>
<a name="ln99">{</a>
<a name="ln100">  return _(&quot;color transfer&quot;);</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">int default_group()</a>
<a name="ln104">{</a>
<a name="ln105">  return IOP_GROUP_COLOR;</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">int flags()</a>
<a name="ln109">{</a>
<a name="ln110">  return IOP_FLAGS_DEPRECATED | IOP_FLAGS_ONE_INSTANCE | IOP_FLAGS_PREVIEW_NON_OPENCL;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">#if 0</a>
<a name="ln114">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln115">{</a>
<a name="ln116">  dt_accel_register_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;acquire&quot;), 0, 0);</a>
<a name="ln117">  dt_accel_register_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;apply&quot;), 0, 0);</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln121">{</a>
<a name="ln122">  dt_iop_colortransfer_gui_data_t *g =</a>
<a name="ln123">    (dt_iop_colortransfer_gui_data_t*)self-&gt;gui_data;</a>
<a name="ln124"> </a>
<a name="ln125">  dt_accel_connect_button_iop(self, &quot;acquire&quot;, g-&gt;acquire_button);</a>
<a name="ln126">  dt_accel_connect_button_iop(self, &quot;apply&quot;, g-&gt;apply_button);</a>
<a name="ln127">}</a>
<a name="ln128">#endif</a>
<a name="ln129"> </a>
<a name="ln130">static void capture_histogram(const float *col, const dt_iop_roi_t *roi, int *hist)</a>
<a name="ln131">{</a>
<a name="ln132">  // build separate histogram</a>
<a name="ln133">  memset(hist, 0, HISTN * sizeof(int));</a>
<a name="ln134">  for(int k = 0; k &lt; roi-&gt;height; k++)</a>
<a name="ln135">    for(int i = 0; i &lt; roi-&gt;width; i++)</a>
<a name="ln136">    {</a>
<a name="ln137">      const int bin = CLAMP(HISTN * col[3 * (k * roi-&gt;width + i) + 0] / 100.0, 0, HISTN - 1);</a>
<a name="ln138">      hist[bin]++;</a>
<a name="ln139">    }</a>
<a name="ln140"> </a>
<a name="ln141">  // accumulated start distribution of G1 G2</a>
<a name="ln142">  for(int k = 1; k &lt; HISTN; k++) hist[k] += hist[k - 1];</a>
<a name="ln143">  for(int k = 0; k &lt; HISTN; k++)</a>
<a name="ln144">    hist[k] = (int)CLAMP(hist[k] * (HISTN / (float)hist[HISTN - 1]), 0, HISTN - 1);</a>
<a name="ln145">  // for(int i=0;i&lt;100;i++) printf(&quot;#[%d] %d \n&quot;, i, hist[(int)CLAMP(HISTN*i/100.0, 0, HISTN-1)]);</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">static void invert_histogram(const int *hist, float *inv_hist)</a>
<a name="ln149">{</a>
<a name="ln150">// invert non-normalised accumulated hist</a>
<a name="ln151">#if 0</a>
<a name="ln152">  int last = 0;</a>
<a name="ln153">  for(int i=0; i&lt;HISTN; i++) for(int k=last; k&lt;HISTN; k++)</a>
<a name="ln154">      if(hist[k] &gt;= i)</a>
<a name="ln155">      {</a>
<a name="ln156">        last = k;</a>
<a name="ln157">        inv_hist[i] = 100.0*k/(float)HISTN;</a>
<a name="ln158">        break;</a>
<a name="ln159">      }</a>
<a name="ln160">#else</a>
<a name="ln161">  int last = 31;</a>
<a name="ln162">  for(int i = 0; i &lt;= last; i++) inv_hist[i] = 100.0 * i / (float)HISTN;</a>
<a name="ln163">  for(int i = last + 1; i &lt; HISTN; i++)</a>
<a name="ln164">    for(int k = last; k &lt; HISTN; k++)</a>
<a name="ln165">      if(hist[k] &gt;= i)</a>
<a name="ln166">      {</a>
<a name="ln167">        last = k;</a>
<a name="ln168">        inv_hist[i] = 100.0 * k / (float)HISTN;</a>
<a name="ln169">        break;</a>
<a name="ln170">      }</a>
<a name="ln171">#endif</a>
<a name="ln172"> </a>
<a name="ln173">  // printf(&quot;inv histogram debug:\n&quot;);</a>
<a name="ln174">  // for(int i=0;i&lt;100;i++) printf(&quot;%d =&gt; %f\n&quot;, i, inv_hist[hist[(int)CLAMP(HISTN*i/100.0, 0, HISTN-1)]]);</a>
<a name="ln175">  // for(int i=0;i&lt;100;i++) printf(&quot;[%d] %f =&gt; %f\n&quot;, i, hist[(int)CLAMP(HISTN*i/100.0, 0,</a>
<a name="ln176">  // HISTN-1)]/(float)HISTN, inv_hist[(int)CLAMP(HISTN*i/100.0, 0, HISTN-1)]);</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">#pragma GCC diagnostic push</a>
<a name="ln180">#pragma GCC diagnostic warning &quot;-Wvla&quot;</a>
<a name="ln181"> </a>
<a name="ln182">static void get_cluster_mapping(const int n, float mi[n][2], float mo[n][2], int mapio[n])</a>
<a name="ln183">{</a>
<a name="ln184">  for(int ki = 0; ki &lt; n; ki++)</a>
<a name="ln185">  {</a>
<a name="ln186">    // for each input cluster</a>
<a name="ln187">    float mdist = FLT_MAX;</a>
<a name="ln188">    for(int ko = 0; ko &lt; n; ko++)</a>
<a name="ln189">    {</a>
<a name="ln190">      // find the best target cluster (the same could be used more than once)</a>
<a name="ln191">      const float dist = (mo[ko][0] - mi[ki][0]) * (mo[ko][0] - mi[ki][0])</a>
<a name="ln192">                         + (mo[ko][1] - mi[ki][1]) * (mo[ko][1] - mi[ki][1]);</a>
<a name="ln193">      if(dist &lt; mdist)</a>
<a name="ln194">      {</a>
<a name="ln195">        mdist = dist;</a>
<a name="ln196">        mapio[ki] = ko;</a>
<a name="ln197">      }</a>
<a name="ln198">    }</a>
<a name="ln199">  }</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">static void get_clusters(const float *col, const int n, float mean[n][2], float *weight)</a>
<a name="ln203">{</a>
<a name="ln204">  float Mdist = 0.0f, mdist = FLT_MAX;</a>
<a name="ln205">  for(int k = 0; k &lt; n; k++)</a>
<a name="ln206">  {</a>
<a name="ln207">    const float dist = (col[1] - mean[k][0]) * (col[1] - mean[k][0])</a>
<a name="ln208">                       + (col[2] - mean[k][1]) * (col[2] - mean[k][1]);</a>
<a name="ln209">    weight[k] = dist;</a>
<a name="ln210">    if(dist &lt; mdist) mdist = dist;</a>
<a name="ln211">    if(dist &gt; Mdist) Mdist = dist;</a>
<a name="ln212">  }</a>
<a name="ln213">  if(Mdist - mdist &gt; 0)</a>
<a name="ln214">    for(int k = 0; k &lt; n; k++) weight[k] = (weight[k] - mdist) / (Mdist - mdist);</a>
<a name="ln215">  float sum = 0.0f;</a>
<a name="ln216">  for(int k = 0; k &lt; n; k++) sum += weight[k];</a>
<a name="ln217">  if(sum &gt; 0)</a>
<a name="ln218">    for(int k = 0; k &lt; n; k++) weight[k] /= sum;</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">static int get_cluster(const float *col, const int n, float mean[n][2])</a>
<a name="ln222">{</a>
<a name="ln223">  float mdist = FLT_MAX;</a>
<a name="ln224">  int cluster = 0;</a>
<a name="ln225">  for(int k = 0; k &lt; n; k++)</a>
<a name="ln226">  {</a>
<a name="ln227">    const float dist = (col[1] - mean[k][0]) * (col[1] - mean[k][0])</a>
<a name="ln228">                       + (col[2] - mean[k][1]) * (col[2] - mean[k][1]);</a>
<a name="ln229">    if(dist &lt; mdist)</a>
<a name="ln230">    {</a>
<a name="ln231">      mdist = dist;</a>
<a name="ln232">      cluster = k;</a>
<a name="ln233">    }</a>
<a name="ln234">  }</a>
<a name="ln235">  return cluster;</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">static void kmeans(const float *col, const dt_iop_roi_t *const roi, const int n, float mean_out[n][2],</a>
<a name="ln239">                   float var_out[n][2])</a>
<a name="ln240">{</a>
<a name="ln241">  // TODO: check params here:</a>
<a name="ln242">  const int nit = 10;                                 // number of iterations</a>
<a name="ln243">  const int samples = roi-&gt;width * roi-&gt;height * 0.2; // samples: only a fraction of the buffer.</a>
<a name="ln244"> </a>
<a name="ln245">  float(*const mean)[2] = malloc(2 * n * sizeof(float));</a>
<a name="ln246">  float(*const var)[2] = malloc(2 * n * sizeof(float));</a>
<a name="ln247">  int *const cnt = malloc(n * sizeof(int));</a>
<a name="ln248"> </a>
<a name="ln249">  // init n clusters for a, b channels at random</a>
<a name="ln250">  for(int k = 0; k &lt; n; k++)</a>
<a name="ln251">  {</a>
<a name="ln252">    mean_out[k][0] = 20.0f - 40.0f * dt_points_get();</a>
<a name="ln253">    mean_out[k][1] = 20.0f - 40.0f * dt_points_get();</a>
<a name="ln254">    var_out[k][0] = var_out[k][1] = 0.0f;</a>
<a name="ln255">    mean[k][0] = mean[k][1] = var[k][0] = var[k][1] = 0.0f;</a>
<a name="ln256">  }</a>
<a name="ln257">  for(int it = 0; it &lt; nit; it++)</a>
<a name="ln258">  {</a>
<a name="ln259">    for(int k = 0; k &lt; n; k++) cnt[k] = 0;</a>
<a name="ln260">// randomly sample col positions inside roi</a>
<a name="ln261">#ifdef _OPENMP</a>
<a name="ln262">#pragma omp parallel for default(none) schedule(static) shared(col, mean_out)</a>
<a name="ln263">#endif</a>
<a name="ln264">    for(int s = 0; s &lt; samples; s++)</a>
<a name="ln265">    {</a>
<a name="ln266">      const int j = dt_points_get() * roi-&gt;height, i = dt_points_get() * roi-&gt;width;</a>
<a name="ln267">      // for each sample: determine cluster, update new mean, update var</a>
<a name="ln268">      for(int k = 0; k &lt; n; k++)</a>
<a name="ln269">      {</a>
<a name="ln270">        const float L = col[3 * (roi-&gt;width * j + i)];</a>
<a name="ln271">        const float Lab[3] = { L, col[3 * (roi-&gt;width * j + i) + 1], col[3 * (roi-&gt;width * j + i) + 2] };</a>
<a name="ln272">        // determine dist to mean_out</a>
<a name="ln273">        const int c = get_cluster(Lab, n, mean_out);</a>
<a name="ln274">#ifdef _OPENMP</a>
<a name="ln275">#pragma omp atomic</a>
<a name="ln276">#endif</a>
<a name="ln277">        cnt[c]++;</a>
<a name="ln278">// update mean, var</a>
<a name="ln279">#ifdef _OPENMP</a>
<a name="ln280">#pragma omp atomic</a>
<a name="ln281">#endif</a>
<a name="ln282">        var[c][0] += Lab[1] * Lab[1];</a>
<a name="ln283">#ifdef _OPENMP</a>
<a name="ln284">#pragma omp atomic</a>
<a name="ln285">#endif</a>
<a name="ln286">        var[c][1] += Lab[2] * Lab[2];</a>
<a name="ln287">#ifdef _OPENMP</a>
<a name="ln288">#pragma omp atomic</a>
<a name="ln289">#endif</a>
<a name="ln290">        mean[c][0] += Lab[1];</a>
<a name="ln291">#ifdef _OPENMP</a>
<a name="ln292">#pragma omp atomic</a>
<a name="ln293">#endif</a>
<a name="ln294">        mean[c][1] += Lab[2];</a>
<a name="ln295">      }</a>
<a name="ln296">    }</a>
<a name="ln297">    // swap old/new means</a>
<a name="ln298">    for(int k = 0; k &lt; n; k++)</a>
<a name="ln299">    {</a>
<a name="ln300">      if(cnt[k] == 0) continue;</a>
<a name="ln301">      mean_out[k][0] = mean[k][0] / cnt[k];</a>
<a name="ln302">      mean_out[k][1] = mean[k][1] / cnt[k];</a>
<a name="ln303">      var_out[k][0] = var[k][0] / cnt[k] - mean_out[k][0] * mean_out[k][0];</a>
<a name="ln304">      var_out[k][1] = var[k][1] / cnt[k] - mean_out[k][1] * mean_out[k][1];</a>
<a name="ln305">      mean[k][0] = mean[k][1] = var[k][0] = var[k][1] = 0.0f;</a>
<a name="ln306">    }</a>
<a name="ln307">    // printf(&quot;it %d  %d means:\n&quot;, it, n);</a>
<a name="ln308">    // for(int k=0;k&lt;n;k++) printf(&quot;%f %f -- var %f %f\n&quot;, mean_out[k][0], mean_out[k][1], var_out[k][0],</a>
<a name="ln309">    // var_out[k][1]);</a>
<a name="ln310">  }</a>
<a name="ln311">  free(cnt);</a>
<a name="ln312">  free(var);</a>
<a name="ln313">  free(mean);</a>
<a name="ln314">  for(int k = 0; k &lt; n; k++)</a>
<a name="ln315">  {</a>
<a name="ln316">    // we actually want the std deviation.</a>
<a name="ln317">    var_out[k][0] = sqrtf(var_out[k][0]);</a>
<a name="ln318">    var_out[k][1] = sqrtf(var_out[k][1]);</a>
<a name="ln319">  }</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322">#pragma GCC diagnostic pop</a>
<a name="ln323"> </a>
<a name="ln324">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln325">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln326">{</a>
<a name="ln327">  // FIXME: this returns nan!!</a>
<a name="ln328">  dt_iop_colortransfer_data_t *data = (dt_iop_colortransfer_data_t *)piece-&gt;data;</a>
<a name="ln329">  float *in = (float *)ivoid;</a>
<a name="ln330">  float *out = (float *)ovoid;</a>
<a name="ln331">  const int ch = piece-&gt;colors;</a>
<a name="ln332"> </a>
<a name="ln333">  if(data-&gt;flag == ACQUIRE)</a>
<a name="ln334">  {</a>
<a name="ln335">    if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln336">    {</a>
<a name="ln337">      // only get stuff from the preview pipe, rest stays untouched.</a>
<a name="ln338">      int hist[HISTN];</a>
<a name="ln339">      // get histogram of L</a>
<a name="ln340">      capture_histogram(in, roi_in, hist);</a>
<a name="ln341">      // invert histogram of L</a>
<a name="ln342">      invert_histogram(hist, data-&gt;hist);</a>
<a name="ln343"> </a>
<a name="ln344">      // get n clusters</a>
<a name="ln345">      kmeans(in, roi_in, data-&gt;n, data-&gt;mean, data-&gt;var);</a>
<a name="ln346"> </a>
<a name="ln347">      // notify gui that commit_params should let stuff flow back!</a>
<a name="ln348">      data-&gt;flag = ACQUIRED;</a>
<a name="ln349">      dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln350">      p-&gt;flag = ACQUIRE2;</a>
<a name="ln351">    }</a>
<a name="ln352">    memcpy(out, in, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln353">  }</a>
<a name="ln354">  else if(data-&gt;flag == APPLY)</a>
<a name="ln355">  {</a>
<a name="ln356">    // apply histogram of L and clustering of (a,b)</a>
<a name="ln357">    int hist[HISTN];</a>
<a name="ln358">    capture_histogram(in, roi_in, hist);</a>
<a name="ln359">#ifdef _OPENMP</a>
<a name="ln360">#pragma omp parallel for default(none) schedule(static) shared(data, in, out, hist)</a>
<a name="ln361">#endif</a>
<a name="ln362">    for(int k = 0; k &lt; roi_out-&gt;height; k++)</a>
<a name="ln363">    {</a>
<a name="ln364">      size_t j = (size_t)ch * roi_out-&gt;width * k;</a>
<a name="ln365">      for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln366">      {</a>
<a name="ln367">        // L: match histogram</a>
<a name="ln368">        out[j] = data-&gt;hist[hist[(int)CLAMP(HISTN * in[j] / 100.0, 0, HISTN - 1)]];</a>
<a name="ln369">        out[j] = CLAMP(out[j], 0, 100);</a>
<a name="ln370">        j += ch;</a>
<a name="ln371">      }</a>
<a name="ln372">    }</a>
<a name="ln373"> </a>
<a name="ln374">    // cluster input buffer</a>
<a name="ln375">    float(*const mean)[2] = malloc(2 * data-&gt;n * sizeof(float));</a>
<a name="ln376">    float(*const var)[2] = malloc(2 * data-&gt;n * sizeof(float));</a>
<a name="ln377"> </a>
<a name="ln378">    kmeans(in, roi_in, data-&gt;n, mean, var);</a>
<a name="ln379"> </a>
<a name="ln380">    // get mapping from input clusters to target clusters</a>
<a name="ln381">    int *const mapio = malloc(data-&gt;n * sizeof(int));</a>
<a name="ln382"> </a>
<a name="ln383">    get_cluster_mapping(data-&gt;n, mean, data-&gt;mean, mapio);</a>
<a name="ln384"> </a>
<a name="ln385">// for all pixels: find input cluster, transfer to mapped target cluster</a>
<a name="ln386">#ifdef _OPENMP</a>
<a name="ln387">#pragma omp parallel for default(none) schedule(static) shared(data, in, out)</a>
<a name="ln388">#endif</a>
<a name="ln389">    for(int k = 0; k &lt; roi_out-&gt;height; k++)</a>
<a name="ln390">    {</a>
<a name="ln391">      float weight[MAXN];</a>
<a name="ln392">      size_t j = (size_t)ch * roi_out-&gt;width * k;</a>
<a name="ln393">      for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln394">      {</a>
<a name="ln395">        const float L = in[j];</a>
<a name="ln396">        const float Lab[3] = { L, in[j + 1], in[j + 2] };</a>
<a name="ln397">// a, b: subtract mean, scale nvar/var, add nmean</a>
<a name="ln398">#if 0 // single cluster, gives color banding</a>
<a name="ln399">        const int ki = get_cluster(in + j, data-&gt;n, mean);</a>
<a name="ln400">        out[j+1] = 100.0/out[j] * ((Lab[1] - mean[ki][0])*data-&gt;var[mapio[ki]][0]/var[ki][0] + data-&gt;mean[mapio[ki]][0]);</a>
<a name="ln401">        out[j+2] = 100.0/out[j] * ((Lab[2] - mean[ki][1])*data-&gt;var[mapio[ki]][1]/var[ki][1] + data-&gt;mean[mapio[ki]][1]);</a>
<a name="ln402">#else // fuzzy weighting</a>
<a name="ln403">        get_clusters(in + j, data-&gt;n, mean, weight);</a>
<a name="ln404">        out[j + 1] = out[j + 2] = 0.0f;</a>
<a name="ln405">        for(int c = 0; c &lt; data-&gt;n; c++)</a>
<a name="ln406">        {</a>
<a name="ln407">          out[j + 1] += weight[c] * ((Lab[1] - mean[c][0]) * data-&gt;var[mapio[c]][0] / var[c][0]</a>
<a name="ln408">                                     + data-&gt;mean[mapio[c]][0]);</a>
<a name="ln409">          out[j + 2] += weight[c] * ((Lab[2] - mean[c][1]) * data-&gt;var[mapio[c]][1] / var[c][1]</a>
<a name="ln410">                                     + data-&gt;mean[mapio[c]][1]);</a>
<a name="ln411">        }</a>
<a name="ln412">#endif</a>
<a name="ln413">        out[j + 3] = in[j + 3];</a>
<a name="ln414">        j += ch;</a>
<a name="ln415">      }</a>
<a name="ln416">    }</a>
<a name="ln417"> </a>
<a name="ln418">    free(mapio);</a>
<a name="ln419">    free(var);</a>
<a name="ln420">    free(mean);</a>
<a name="ln421">  }</a>
<a name="ln422">  else</a>
<a name="ln423">  {</a>
<a name="ln424">    memcpy(out, in, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln425">  }</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">#if 0</a>
<a name="ln429">static void</a>
<a name="ln430">spinbutton_changed (GtkSpinButton *button, dt_iop_module_t *self)</a>
<a name="ln431">{</a>
<a name="ln432">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln433">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln434">//  dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln435">  p-&gt;n = gtk_spin_button_get_value(button);</a>
<a name="ln436">  memset(p-&gt;hist,0, sizeof(float)*HISTN);</a>
<a name="ln437">  memset(p-&gt;mean,0, sizeof(float)*MAXN*2);</a>
<a name="ln438">  memset(p-&gt;var,0,  sizeof(float)*MAXN*2);</a>
<a name="ln439">  dt_control_queue_redraw_widget(self-&gt;widget);</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">static void</a>
<a name="ln443">acquire_button_pressed (GtkButton *button, dt_iop_module_t *self)</a>
<a name="ln444">{</a>
<a name="ln445">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln446">  // request color pick</a>
<a name="ln447">  // needed to trigger expose events:</a>
<a name="ln448">  self-&gt;request_color_pick = DT_REQUEST_COLORPICK_MODULE;</a>
<a name="ln449">  self-&gt;color_picker_box[0] = self-&gt;color_picker_box[1] = 0.0f;</a>
<a name="ln450">  self-&gt;color_picker_box[2] = self-&gt;color_picker_box[3] = 1.0f;</a>
<a name="ln451">  self-&gt;color_picker_point[0] = self-&gt;color_picker_point[1] = 0.5f;</a>
<a name="ln452">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln453">  p-&gt;flag = ACQUIRE;</a>
<a name="ln454">  if(self-&gt;off) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self-&gt;off), 1);</a>
<a name="ln455">  dt_dev_add_history_item(darktable.develop, self, TRUE); // FIXME: Why do we need to add this to the history?</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">static void</a>
<a name="ln459">apply_button_pressed (GtkButton *button, dt_iop_module_t *self)</a>
<a name="ln460">{</a>
<a name="ln461">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln462">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln463">  dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln464">  memcpy(p, &amp;(g-&gt;flowback), self-&gt;params_size);</a>
<a name="ln465">  p-&gt;flag = APPLY;</a>
<a name="ln466">  if(self-&gt;off) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self-&gt;off), 1);</a>
<a name="ln467">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">static gboolean</a>
<a name="ln471">expose (GtkWidget *widget, GdkEventExpose *event, dt_iop_module_t *self)</a>
<a name="ln472">{</a>
<a name="ln473">  // this is called whenever the pipeline finishes processing (i.e. after a color pick)</a>
<a name="ln474">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln475">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln476">  if(p-&gt;flag == ACQUIRED)</a>
<a name="ln477">  {</a>
<a name="ln478">    // clear the color picking request if we got the cluster data</a>
<a name="ln479">    self-&gt;request_color_pick = DT_REQUEST_COLORPICK_OFF;</a>
<a name="ln480">    p-&gt;flag = NEUTRAL;</a>
<a name="ln481">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln482">  }</a>
<a name="ln483">  else if(p-&gt;flag == ACQUIRE2)</a>
<a name="ln484">  {</a>
<a name="ln485">    // color pick is still on, so the data has to be still in the pipe,</a>
<a name="ln486">    // toggle a commit_params</a>
<a name="ln487">    p-&gt;flag = ACQUIRE3;</a>
<a name="ln488">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln489">    self-&gt;request_color_pick = DT_REQUEST_COLORPICK_OFF;</a>
<a name="ln490">  }</a>
<a name="ln491">  return FALSE;</a>
<a name="ln492">}</a>
<a name="ln493"> </a>
<a name="ln494">void commit_params (struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln495">{</a>
<a name="ln496">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)p1;</a>
<a name="ln497">  dt_iop_colortransfer_data_t *d = (dt_iop_colortransfer_data_t *)piece-&gt;data;</a>
<a name="ln498">  if(p-&gt;flag == ACQUIRE3 &amp;&amp; d-&gt;flag == ACQUIRED)</a>
<a name="ln499">  {</a>
<a name="ln500">    // if data is flagged ACQUIRED, actually copy data back from pipe!</a>
<a name="ln501">    d-&gt;flag = NEUTRAL;</a>
<a name="ln502">    p-&gt;flag = ACQUIRED; // let gui know the data is there.</a>
<a name="ln503">    if(self-&gt;dev == darktable.develop &amp;&amp; self-&gt;gui_data)</a>
<a name="ln504">    {</a>
<a name="ln505">      dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln506">      memcpy (&amp;g-&gt;flowback, d, self-&gt;params_size);</a>
<a name="ln507">      g-&gt;flowback_set = 1;</a>
<a name="ln508">      FILE *f = g_fopen(&quot;/tmp/dt_colortransfer_loaded&quot;, &quot;wb&quot;);</a>
<a name="ln509">      if(f)</a>
<a name="ln510">      {</a>
<a name="ln511">        if(fwrite(&amp;g-&gt;flowback, self-&gt;params_size, 1, f) &gt; 0) g-&gt;flowback.flag = APPLY;</a>
<a name="ln512">        fclose(f);</a>
<a name="ln513">      }</a>
<a name="ln514">      dt_control_queue_redraw_widget(self-&gt;widget);</a>
<a name="ln515">    }</a>
<a name="ln516">  }</a>
<a name="ln517">  else</a>
<a name="ln518">  {</a>
<a name="ln519">    // dt_iop_colortransfer_flag_t flag = d-&gt;flag;</a>
<a name="ln520">    memcpy(d, p, self-&gt;params_size);</a>
<a name="ln521">    // only allow apply and acquire commands from gui.</a>
<a name="ln522">    // if(p-&gt;flag != APPLY &amp;&amp; p-&gt;flag != ACQUIRE &amp;&amp; p-&gt;flag != NEUTRAL) d-&gt;flag = flag;</a>
<a name="ln523">    if(p-&gt;flag == ACQUIRE2) d-&gt;flag = ACQUIRE;</a>
<a name="ln524">    if(p-&gt;flag == ACQUIRE3) d-&gt;flag = NEUTRAL;</a>
<a name="ln525">    if(p-&gt;flag == ACQUIRED) d-&gt;flag = NEUTRAL;</a>
<a name="ln526">    // if(p-&gt;flag == ACQUIRE) p-&gt;flag = ACQUIRE2;</a>
<a name="ln527">  }</a>
<a name="ln528">}</a>
<a name="ln529">#endif</a>
<a name="ln530"> </a>
<a name="ln531">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln532">{</a>
<a name="ln533">  piece-&gt;data = malloc(sizeof(dt_iop_colortransfer_data_t));</a>
<a name="ln534">  dt_iop_colortransfer_data_t *d = (dt_iop_colortransfer_data_t *)piece-&gt;data;</a>
<a name="ln535">  d-&gt;flag = NEUTRAL;</a>
<a name="ln536">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln540">{</a>
<a name="ln541">  free(piece-&gt;data);</a>
<a name="ln542">  piece-&gt;data = NULL;</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln546">{</a>
<a name="ln547">#if 0</a>
<a name="ln548">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln549">  dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln550">  gtk_spin_button_set_value(g-&gt;spinbutton, p-&gt;n);</a>
<a name="ln551">  //gtk_widget_set_size_request(GTK_WIDGET(g-&gt;area), 300, MIN(100, 300/p-&gt;n));</a>
<a name="ln552">  // redraw color cluster preview</a>
<a name="ln553">  dt_control_queue_redraw_widget(self-&gt;widget);</a>
<a name="ln554">#endif</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">void init(dt_iop_module_t *module)</a>
<a name="ln558">{</a>
<a name="ln559">  // module-&gt;data = malloc(sizeof(dt_iop_colortransfer_data_t));</a>
<a name="ln560">  module-&gt;params = calloc(1, sizeof(dt_iop_colortransfer_params_t));</a>
<a name="ln561">  module-&gt;default_params = calloc(1, sizeof(dt_iop_colortransfer_params_t));</a>
<a name="ln562">  module-&gt;default_enabled = 0;</a>
<a name="ln563">  module-&gt;priority = 485; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln564">  module-&gt;params_size = sizeof(dt_iop_colortransfer_params_t);</a>
<a name="ln565">  module-&gt;gui_data = NULL;</a>
<a name="ln566">  dt_iop_colortransfer_params_t tmp;</a>
<a name="ln567">  tmp.flag = NEUTRAL;</a>
<a name="ln568">  memset(tmp.hist, 0, sizeof(float) * HISTN);</a>
<a name="ln569">  memset(tmp.mean, 0, sizeof(float) * MAXN * 2);</a>
<a name="ln570">  memset(tmp.var, 0, sizeof(float) * MAXN * 2);</a>
<a name="ln571">  tmp.n = 3;</a>
<a name="ln572">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_colortransfer_params_t));</a>
<a name="ln573">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_colortransfer_params_t));</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">void cleanup(dt_iop_module_t *module)</a>
<a name="ln577">{</a>
<a name="ln578">  free(module-&gt;params);</a>
<a name="ln579">  module-&gt;params = NULL;</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">#if 0</a>
<a name="ln583">static gboolean</a>
<a name="ln584">cluster_preview_draw (GtkWidget *widget, cairo_t *crf, dt_iop_module_t *self)</a>
<a name="ln585">{</a>
<a name="ln586">  // dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln587">  dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln588">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)&amp;g-&gt;flowback;</a>
<a name="ln589">  if(!g-&gt;flowback_set) p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln590">  const int inset = 5;</a>
<a name="ln591">  int width = allocation.width, height = allocation.height;</a>
<a name="ln592">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln593">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln594">  cairo_set_source_rgb (cr, .2, .2, .2);</a>
<a name="ln595">  cairo_paint(cr);</a>
<a name="ln596"> </a>
<a name="ln597">  cairo_translate(cr, inset, inset);</a>
<a name="ln598">  width -= 2*inset;</a>
<a name="ln599">  height -= 2*inset;</a>
<a name="ln600"> </a>
<a name="ln601">  if(g-&gt;flowback_set) gtk_widget_set_sensitive(g-&gt;apply_button, TRUE);</a>
<a name="ln602">#if 0</a>
<a name="ln603">  if(g-&gt;flowback_set)</a>
<a name="ln604">  {</a>
<a name="ln605">    memcpy(self-&gt;params, &amp;g-&gt;flowback, self-&gt;params_size);</a>
<a name="ln606">    g-&gt;flowback_set = 0;</a>
<a name="ln607">    p-&gt;flag = APPLY;</a>
<a name="ln608">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln609">  }</a>
<a name="ln610">#endif</a>
<a name="ln611"> </a>
<a name="ln612">  const float sep = 2.0;</a>
<a name="ln613">  const float qwd = (width-(p-&gt;n-1)*sep)/(float)p-&gt;n;</a>
<a name="ln614">  for(int cl=0; cl&lt;p-&gt;n; cl++)</a>
<a name="ln615">  {</a>
<a name="ln616">    // draw cluster</a>
<a name="ln617">    for(int j=-1; j&lt;=1; j++) for(int i=-1; i&lt;=1; i++)</a>
<a name="ln618">      {</a>
<a name="ln619">        // draw 9x9 grid showing mean and variance of this cluster.</a>
<a name="ln620">        double rgb[3] = {0.5, 0.5, 0.5};</a>
<a name="ln621">        cmsCIELab Lab;</a>
<a name="ln622">        Lab.L = 5.0;//53.390011;</a>
<a name="ln623">        Lab.a = (p-&gt;mean[cl][0] + i*p-&gt;var[cl][0]);// / Lab.L;</a>
<a name="ln624">        Lab.b = (p-&gt;mean[cl][1] + j*p-&gt;var[cl][1]);// / Lab.L;</a>
<a name="ln625">        Lab.L = 53.390011;</a>
<a name="ln626">        cmsDoTransform(g-&gt;xform, &amp;Lab, rgb, 1);</a>
<a name="ln627">        cairo_set_source_rgb (cr, rgb[0], rgb[1], rgb[2]);</a>
<a name="ln628">        cairo_rectangle(cr, qwd*(i+1)/3.0, height*(j+1)/3.0, qwd/3.0-.5, height/3.0-.5);</a>
<a name="ln629">        cairo_fill(cr);</a>
<a name="ln630">      }</a>
<a name="ln631">    cairo_translate (cr, qwd + sep, 0);</a>
<a name="ln632">  }</a>
<a name="ln633"> </a>
<a name="ln634">  cairo_destroy(cr);</a>
<a name="ln635">  cairo_set_source_surface (crf, cst, 0, 0);</a>
<a name="ln636">  cairo_paint(crf);</a>
<a name="ln637">  cairo_surface_destroy(cst);</a>
<a name="ln638">  return TRUE;</a>
<a name="ln639">}</a>
<a name="ln640">#endif</a>
<a name="ln641"> </a>
<a name="ln642">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln643">{</a>
<a name="ln644"> </a>
<a name="ln645">  self-&gt;gui_data = malloc(sizeof(dt_iop_colortransfer_gui_data_t));</a>
<a name="ln646">  self-&gt;widget = gtk_label_new(_(&quot;this module will be removed in the future\nand is only here so you can &quot;</a>
<a name="ln647">                                 &quot;switch it off\nand move to the new color mapping module.&quot;));</a>
<a name="ln648">  gtk_widget_set_halign(self-&gt;widget, GTK_ALIGN_START);</a>
<a name="ln649"> </a>
<a name="ln650">#if 0</a>
<a name="ln651">  self-&gt;gui_data = malloc(sizeof(dt_iop_colortransfer_gui_data_t));</a>
<a name="ln652">  dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln653">  // dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln654"> </a>
<a name="ln655">  g-&gt;flowback_set = 0;</a>
<a name="ln656">  cmsHPROFILE hsRGB = dt_colorspaces_get_profile(DT_COLORSPACE_SRGB, &quot;&quot;, DT_PROFILE_DIRECTION_IN)-&gt;profile;</a>
<a name="ln657">  cmsHPROFILE hLab  = dt_colorspaces_get_profile(DT_COLORSPACE_LAB, &quot;&quot;, DT_PROFILE_DIRECTION_ANY)-&gt;profile;</a>
<a name="ln658">  g-&gt;xform = cmsCreateTransform(hLab, TYPE_Lab_DBL, hsRGB, TYPE_RGB_DBL, INTENT_PERCEPTUAL, 0);</a>
<a name="ln659"> </a>
<a name="ln660">  self-&gt;widget = GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_GUI_IOP_MODULE_CONTROL_SPACING));</a>
<a name="ln661">  g_signal_connect (G_OBJECT(self-&gt;widget), &quot;draw&quot;,</a>
<a name="ln662">                    G_CALLBACK(draw), self);</a>
<a name="ln663"> </a>
<a name="ln664">  g-&gt;area = gtk_drawing_area_new();</a>
<a name="ln665">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;area), 300, 100);</a>
<a name="ln666">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;area, TRUE, TRUE, 0);</a>
<a name="ln667">  g_signal_connect (G_OBJECT (g-&gt;area), &quot;draw&quot;, G_CALLBACK (cluster_preview_draw), self);</a>
<a name="ln668"> </a>
<a name="ln669">  GtkBox *box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5));</a>
<a name="ln670">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(box), TRUE, TRUE, 0);</a>
<a name="ln671">  GtkWidget *button;</a>
<a name="ln672">  g-&gt;spinbutton = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(1, MAXN, 1));</a>
<a name="ln673">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;spinbutton), _(&quot;number of clusters to find in image&quot;));</a>
<a name="ln674">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;spinbutton), FALSE, FALSE, 0);</a>
<a name="ln675">  g_signal_connect(G_OBJECT(g-&gt;spinbutton), &quot;value-changed&quot;, G_CALLBACK(spinbutton_changed), (gpointer)self);</a>
<a name="ln676"> </a>
<a name="ln677">  button = gtk_button_new_with_label(_(&quot;acquire&quot;));</a>
<a name="ln678">  g-&gt;acquire_button = button;</a>
<a name="ln679">  gtk_widget_set_tooltip_text(button, _(&quot;analyze this image&quot;));</a>
<a name="ln680">  gtk_box_pack_start(box, button, TRUE, TRUE, 0);</a>
<a name="ln681">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(acquire_button_pressed), (gpointer)self);</a>
<a name="ln682"> </a>
<a name="ln683">  g-&gt;apply_button = gtk_button_new_with_label(_(&quot;apply&quot;));</a>
<a name="ln684">  gtk_widget_set_tooltip_text(g-&gt;apply_button, _(&quot;apply previously analyzed image look to this image&quot;));</a>
<a name="ln685">  gtk_box_pack_start(box, g-&gt;apply_button, TRUE, TRUE, 0);</a>
<a name="ln686">  g_signal_connect(G_OBJECT(g-&gt;apply_button), &quot;clicked&quot;, G_CALLBACK(apply_button_pressed), (gpointer)self);</a>
<a name="ln687">  FILE *f = g_fopen(&quot;/tmp/dt_colortransfer_loaded&quot;, &quot;rb&quot;);</a>
<a name="ln688">  if(f)</a>
<a name="ln689">  {</a>
<a name="ln690">    if(fread(&amp;g-&gt;flowback, self-&gt;params_size, 1, f) &gt; 0) g-&gt;flowback_set = 1;</a>
<a name="ln691">    fclose(f);</a>
<a name="ln692">  }</a>
<a name="ln693">  else gtk_widget_set_sensitive(GTK_WIDGET(g-&gt;apply_button), FALSE);</a>
<a name="ln694">#endif</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln698">{</a>
<a name="ln699">  //  dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln700">  //  cmsDeleteTransform(g-&gt;xform);</a>
<a name="ln701">  free(self-&gt;gui_data);</a>
<a name="ln702">  self-&gt;gui_data = NULL;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln706">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln707">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="255"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'mean'. Check lines: 255, 245.</p></div>
<div class="balloon" rel="255"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'var'. Check lines: 255, 246.</p></div>
<div class="balloon" rel="259"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'cnt'. Check lines: 259, 247.</p></div>
<div class="balloon" rel="407"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'mean'. Check lines: 407, 375.</p></div>
<div class="balloon" rel="407"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'mapio'. Check lines: 407, 381.</p></div>
<div class="balloon" rel="407"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'var'. Check lines: 407, 376.</p></div>
<div class="balloon" rel="535"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 535, 533.</p></div>
<div class="balloon" rel="572"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 572, 560.</p></div>
<div class="balloon" rel="573"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 573, 561.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
