
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2013 johannes hanika.</a>
<a name="ln4">    copyright (c) 2015 LebedevRI.</a>
<a name="ln5">    copyright (c) 2016 Pedro CÃ´rte-Real</a>
<a name="ln6"> </a>
<a name="ln7">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln8">    it under the terms of the GNU General Public License as published by</a>
<a name="ln9">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln10">    (at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln13">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">    GNU General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">    You should have received a copy of the GNU General Public License</a>
<a name="ln18">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln19">*/</a>
<a name="ln20">#ifdef HAVE_CONFIG_H</a>
<a name="ln21">#include &quot;config.h&quot;</a>
<a name="ln22">#endif</a>
<a name="ln23">#if defined(__SSE__)</a>
<a name="ln24">#include &lt;xmmintrin.h&gt;</a>
<a name="ln25">#endif</a>
<a name="ln26">#include &lt;assert.h&gt;</a>
<a name="ln27">#include &lt;lcms2.h&gt;</a>
<a name="ln28">#include &lt;math.h&gt;</a>
<a name="ln29">#include &lt;stdlib.h&gt;</a>
<a name="ln30">#include &lt;string.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln33">#include &quot;common/colorspaces_inline_conversions.h&quot;</a>
<a name="ln34">#include &quot;common/darktable.h&quot;</a>
<a name="ln35">#include &quot;common/opencl.h&quot;</a>
<a name="ln36">#include &quot;control/control.h&quot;</a>
<a name="ln37">#include &quot;develop/develop.h&quot;</a>
<a name="ln38">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln39">#include &quot;develop/tiling.h&quot;</a>
<a name="ln40">#include &quot;external/wb_presets.c&quot;</a>
<a name="ln41">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln42">#include &quot;gui/gtk.h&quot;</a>
<a name="ln43">#include &quot;gui/color_picker_proxy.h&quot;</a>
<a name="ln44">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">// for Kelvin temperature and bogus WB</a>
<a name="ln47">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln48">#include &quot;external/cie_colorimetric_tables.c&quot;</a>
<a name="ln49"> </a>
<a name="ln50">DT_MODULE_INTROSPECTION(3, dt_iop_temperature_params_t)</a>
<a name="ln51"> </a>
<a name="ln52">#define INITIALBLACKBODYTEMPERATURE 4000</a>
<a name="ln53"> </a>
<a name="ln54">#define DT_IOP_LOWEST_TEMPERATURE 1901</a>
<a name="ln55">#define DT_IOP_HIGHEST_TEMPERATURE 25000</a>
<a name="ln56"> </a>
<a name="ln57">#define DT_IOP_LOWEST_TINT 0.135</a>
<a name="ln58">#define DT_IOP_HIGHEST_TINT 2.326</a>
<a name="ln59"> </a>
<a name="ln60">#define DT_IOP_NUM_OF_STD_TEMP_PRESETS 3</a>
<a name="ln61"> </a>
<a name="ln62">#define COLORED_SLIDERS 0</a>
<a name="ln63"> </a>
<a name="ln64">//storing the last picked color (if any)</a>
<a name="ln65">static float old[4] = { 0.0f, 0.0f, 0.0f, 0.0f };</a>
<a name="ln66"> </a>
<a name="ln67">static void gui_sliders_update(struct dt_iop_module_t *self);</a>
<a name="ln68"> </a>
<a name="ln69">typedef struct dt_iop_temperature_params_t</a>
<a name="ln70">{</a>
<a name="ln71">  float coeffs[4];</a>
<a name="ln72">} dt_iop_temperature_params_t;</a>
<a name="ln73"> </a>
<a name="ln74">typedef struct dt_iop_temperature_gui_data_t</a>
<a name="ln75">{</a>
<a name="ln76">  GtkWidget *scale_k, *scale_tint, *coeff_widgets, *scale_r, *scale_g, *scale_b, *scale_g2;</a>
<a name="ln77">  GtkWidget *presets;</a>
<a name="ln78">  GtkWidget *finetune;</a>
<a name="ln79">  GtkWidget *box_enabled;</a>
<a name="ln80">  GtkWidget *label_disabled;</a>
<a name="ln81">  GtkWidget *stack;</a>
<a name="ln82">  GtkWidget *colorpicker;</a>
<a name="ln83">  int preset_cnt;</a>
<a name="ln84">  int preset_num[50];</a>
<a name="ln85">  double daylight_wb[4];</a>
<a name="ln86">  double XYZ_to_CAM[4][3], CAM_to_XYZ[3][4];</a>
<a name="ln87">  dt_iop_color_picker_t color_picker;</a>
<a name="ln88">} dt_iop_temperature_gui_data_t;</a>
<a name="ln89"> </a>
<a name="ln90">typedef struct dt_iop_temperature_data_t</a>
<a name="ln91">{</a>
<a name="ln92">  float coeffs[4];</a>
<a name="ln93">} dt_iop_temperature_data_t;</a>
<a name="ln94"> </a>
<a name="ln95"> </a>
<a name="ln96">typedef struct dt_iop_temperature_global_data_t</a>
<a name="ln97">{</a>
<a name="ln98">  int kernel_whitebalance_4f;</a>
<a name="ln99">  int kernel_whitebalance_1f;</a>
<a name="ln100">  int kernel_whitebalance_1f_xtrans;</a>
<a name="ln101">} dt_iop_temperature_global_data_t;</a>
<a name="ln102"> </a>
<a name="ln103">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln104">                  void *new_params, const int new_version)</a>
<a name="ln105">{</a>
<a name="ln106">  if(old_version == 2 &amp;&amp; new_version == 3)</a>
<a name="ln107">  {</a>
<a name="ln108">    typedef struct dt_iop_temperature_params_v2_t</a>
<a name="ln109">    {</a>
<a name="ln110">      float temp_out;</a>
<a name="ln111">      float coeffs[3];</a>
<a name="ln112">    } dt_iop_temperature_params_v2_t;</a>
<a name="ln113"> </a>
<a name="ln114">    dt_iop_temperature_params_v2_t *o = (dt_iop_temperature_params_v2_t *)old_params;</a>
<a name="ln115">    dt_iop_temperature_params_t *n = (dt_iop_temperature_params_t *)new_params;</a>
<a name="ln116"> </a>
<a name="ln117">    n-&gt;coeffs[0] = o-&gt;coeffs[0];</a>
<a name="ln118">    n-&gt;coeffs[1] = o-&gt;coeffs[1];</a>
<a name="ln119">    n-&gt;coeffs[2] = o-&gt;coeffs[2];</a>
<a name="ln120">    n-&gt;coeffs[3] = NAN;</a>
<a name="ln121"> </a>
<a name="ln122">    return 0;</a>
<a name="ln123">  }</a>
<a name="ln124">  return 1;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">static int ignore_missing_wb(dt_image_t *img)</a>
<a name="ln128">{</a>
<a name="ln129">  // Ignore files that end with &quot;-hdr.dng&quot; since these are broken files we</a>
<a name="ln130">  // generated without any proper WB tagged</a>
<a name="ln131">  if(g_str_has_suffix(img-&gt;filename,&quot;-hdr.dng&quot;))</a>
<a name="ln132">    return TRUE;</a>
<a name="ln133"> </a>
<a name="ln134">  static const char *const ignored_cameras[] = {</a>
<a name="ln135">    &quot;Canon PowerShot A610&quot;,</a>
<a name="ln136">    &quot;Canon PowerShot S3 IS&quot;,</a>
<a name="ln137">    &quot;Canon PowerShot A620&quot;,</a>
<a name="ln138">    &quot;Canon PowerShot A720 IS&quot;,</a>
<a name="ln139">    &quot;Canon PowerShot A630&quot;,</a>
<a name="ln140">    &quot;Canon PowerShot A640&quot;,</a>
<a name="ln141">    &quot;Canon PowerShot A650&quot;,</a>
<a name="ln142">    &quot;Canon PowerShot SX110 IS&quot;,</a>
<a name="ln143">    &quot;Mamiya ZD&quot;,</a>
<a name="ln144">    &quot;Canon EOS D2000C&quot;,</a>
<a name="ln145">    &quot;Kodak EOS DCS 1&quot;,</a>
<a name="ln146">    &quot;Kodak DCS560C&quot;,</a>
<a name="ln147">    &quot;Kodak DCS460D&quot;,</a>
<a name="ln148">    &quot;Nikon E5700&quot;,</a>
<a name="ln149">    &quot;Sony DSC-F828&quot;,</a>
<a name="ln150">    &quot;GITUP GIT2&quot;,</a>
<a name="ln151">  };</a>
<a name="ln152"> </a>
<a name="ln153">  for(int i=0; i &lt; sizeof(ignored_cameras)/sizeof(ignored_cameras[1]); i++)</a>
<a name="ln154">    if(!strcmp(img-&gt;camera_makermodel, ignored_cameras[i]))</a>
<a name="ln155">      return TRUE;</a>
<a name="ln156"> </a>
<a name="ln157">  return FALSE;</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160"> </a>
<a name="ln161">const char *name()</a>
<a name="ln162">{</a>
<a name="ln163">  return C_(&quot;modulename&quot;, &quot;white balance&quot;);</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">int default_group()</a>
<a name="ln167">{</a>
<a name="ln168">  return IOP_GROUP_BASIC;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">int flags()</a>
<a name="ln172">{</a>
<a name="ln173">  return IOP_FLAGS_ALLOW_TILING | IOP_FLAGS_ONE_INSTANCE;</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln177">{</a>
<a name="ln178">  return iop_cs_RAW;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">static gboolean _set_preset_camera(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln182">                                   GdkModifierType modifier, gpointer data)</a>
<a name="ln183">{</a>
<a name="ln184">  dt_iop_module_t *self = data;</a>
<a name="ln185">  dt_iop_temperature_gui_data_t *g = self-&gt;gui_data;</a>
<a name="ln186">  dt_bauhaus_combobox_set(g-&gt;presets, 0);</a>
<a name="ln187">  return TRUE;</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">static gboolean _set_preset_camera_neutral(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln191">                                           GdkModifierType modifier, gpointer data)</a>
<a name="ln192">{</a>
<a name="ln193">  dt_iop_module_t *self = data;</a>
<a name="ln194">  dt_iop_temperature_gui_data_t *g = self-&gt;gui_data;</a>
<a name="ln195">  dt_bauhaus_combobox_set(g-&gt;presets, 1);</a>
<a name="ln196">  return TRUE;</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">static gboolean _set_preset_spot(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln200">                                 GdkModifierType modifier, gpointer data)</a>
<a name="ln201">{</a>
<a name="ln202">  dt_iop_module_t *self = data;</a>
<a name="ln203">  dt_iop_temperature_gui_data_t *g = self-&gt;gui_data;</a>
<a name="ln204">  dt_bauhaus_combobox_set(g-&gt;presets, 2);</a>
<a name="ln205">  return TRUE;</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln209">{</a>
<a name="ln210">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;tint&quot;));</a>
<a name="ln211">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;temperature&quot;));</a>
<a name="ln212">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;red&quot;));</a>
<a name="ln213">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;green&quot;));</a>
<a name="ln214">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;blue&quot;));</a>
<a name="ln215"> </a>
<a name="ln216">  dt_accel_register_iop(self, TRUE, NC_(&quot;accel&quot;, &quot;preset/camera&quot;), 0, 0);</a>
<a name="ln217">  dt_accel_register_iop(self, TRUE, NC_(&quot;accel&quot;, &quot;preset/camera neutral&quot;), 0, 0);</a>
<a name="ln218">  dt_accel_register_iop(self, TRUE, NC_(&quot;accel&quot;, &quot;preset/spot&quot;), 0, 0);</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln222">{</a>
<a name="ln223">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln224"> </a>
<a name="ln225">  dt_accel_connect_slider_iop(self, &quot;tint&quot;, GTK_WIDGET(g-&gt;scale_tint));</a>
<a name="ln226">  dt_accel_connect_slider_iop(self, &quot;temperature&quot;, GTK_WIDGET(g-&gt;scale_k));</a>
<a name="ln227">  dt_accel_connect_slider_iop(self, &quot;red&quot;, GTK_WIDGET(g-&gt;scale_r));</a>
<a name="ln228">  dt_accel_connect_slider_iop(self, &quot;green&quot;, GTK_WIDGET(g-&gt;scale_g));</a>
<a name="ln229">  dt_accel_connect_slider_iop(self, &quot;blue&quot;, GTK_WIDGET(g-&gt;scale_b));</a>
<a name="ln230">  dt_accel_connect_slider_iop(self, &quot;green2&quot;, GTK_WIDGET(g-&gt;scale_g2));</a>
<a name="ln231"> </a>
<a name="ln232">  GClosure *closure;</a>
<a name="ln233"> </a>
<a name="ln234">  closure = g_cclosure_new(G_CALLBACK(_set_preset_camera), (gpointer)self, NULL);</a>
<a name="ln235">  dt_accel_connect_iop(self, &quot;preset/camera&quot;, closure);</a>
<a name="ln236"> </a>
<a name="ln237">  closure = g_cclosure_new(G_CALLBACK(_set_preset_camera_neutral), (gpointer)self, NULL);</a>
<a name="ln238">  dt_accel_connect_iop(self, &quot;preset/camera neutral&quot;, closure);</a>
<a name="ln239"> </a>
<a name="ln240">  closure = g_cclosure_new(G_CALLBACK(_set_preset_spot), (gpointer)self, NULL);</a>
<a name="ln241">  dt_accel_connect_iop(self, &quot;preset/spot&quot;, closure);</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">/*</a>
<a name="ln245"> * Spectral power distribution functions</a>
<a name="ln246"> * https://en.wikipedia.org/wiki/Spectral_power_distribution</a>
<a name="ln247"> */</a>
<a name="ln248">typedef double((*spd)(unsigned long int wavelength, double TempK));</a>
<a name="ln249"> </a>
<a name="ln250">/*</a>
<a name="ln251"> * Bruce Lindbloom, &quot;Spectral Power Distribution of a Blackbody Radiator&quot;</a>
<a name="ln252"> * http://www.brucelindbloom.com/Eqn_Blackbody.html</a>
<a name="ln253"> */</a>
<a name="ln254">static double spd_blackbody(unsigned long int wavelength, double TempK)</a>
<a name="ln255">{</a>
<a name="ln256">  // convert wavelength from nm to m</a>
<a name="ln257">  const long double lambda = (double)wavelength * 1e-9;</a>
<a name="ln258"> </a>
<a name="ln259">/*</a>
<a name="ln260"> * these 2 constants were computed using following Sage code:</a>
<a name="ln261"> *</a>
<a name="ln262"> * (from http://physics.nist.gov/cgi-bin/cuu/Value?h)</a>
<a name="ln263"> * h = 6.62606957 * 10^-34 # Planck</a>
<a name="ln264"> * c= 299792458 # speed of light in vacuum</a>
<a name="ln265"> * k = 1.3806488 * 10^-23 # Boltzmann</a>
<a name="ln266"> *</a>
<a name="ln267"> * c_1 = 2 * pi * h * c^2</a>
<a name="ln268"> * c_2 = h * c / k</a>
<a name="ln269"> *</a>
<a name="ln270"> * print 'c_1 = ', c_1, ' ~= ', RealField(128)(c_1)</a>
<a name="ln271"> * print 'c_2 = ', c_2, ' ~= ', RealField(128)(c_2)</a>
<a name="ln272"> */</a>
<a name="ln273"> </a>
<a name="ln274">#define c1 3.7417715246641281639549488324352159753e-16L</a>
<a name="ln275">#define c2 0.014387769599838156481252937624049081933L</a>
<a name="ln276"> </a>
<a name="ln277">  return (double)(c1 / (powl(lambda, 5) * (expl(c2 / (lambda * TempK)) - 1.0L)));</a>
<a name="ln278"> </a>
<a name="ln279">#undef c2</a>
<a name="ln280">#undef c1</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">/*</a>
<a name="ln284"> * Bruce Lindbloom, &quot;Spectral Power Distribution of a CIE D-Illuminant&quot;</a>
<a name="ln285"> * http://www.brucelindbloom.com/Eqn_DIlluminant.html</a>
<a name="ln286"> * and https://en.wikipedia.org/wiki/Standard_illuminant#Illuminant_series_D</a>
<a name="ln287"> */</a>
<a name="ln288">static double spd_daylight(unsigned long int wavelength, double TempK)</a>
<a name="ln289">{</a>
<a name="ln290">  cmsCIExyY WhitePoint = { 0.3127, 0.3290, 1.0 };</a>
<a name="ln291"> </a>
<a name="ln292">  /*</a>
<a name="ln293">   * Bruce Lindbloom, &quot;TempK to xy&quot;</a>
<a name="ln294">   * http://www.brucelindbloom.com/Eqn_T_to_xy.html</a>
<a name="ln295">   */</a>
<a name="ln296">  cmsWhitePointFromTemp(&amp;WhitePoint, TempK);</a>
<a name="ln297"> </a>
<a name="ln298">  const double M = (0.0241 + 0.2562 * WhitePoint.x - 0.7341 * WhitePoint.y),</a>
<a name="ln299">               m1 = (-1.3515 - 1.7703 * WhitePoint.x + 5.9114 * WhitePoint.y) / M,</a>
<a name="ln300">               m2 = (0.0300 - 31.4424 * WhitePoint.x + 30.0717 * WhitePoint.y) / M;</a>
<a name="ln301"> </a>
<a name="ln302">  const unsigned long int j</a>
<a name="ln303">      = ((wavelength - cie_daylight_components[0].wavelength)</a>
<a name="ln304">         / (cie_daylight_components[1].wavelength - cie_daylight_components[0].wavelength));</a>
<a name="ln305"> </a>
<a name="ln306">  return (cie_daylight_components[j].S[0] + m1 * cie_daylight_components[j].S[1]</a>
<a name="ln307">          + m2 * cie_daylight_components[j].S[2]);</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">/*</a>
<a name="ln311"> * Bruce Lindbloom, &quot;Computing XYZ From Spectral Data (Emissive Case)&quot;</a>
<a name="ln312"> * http://www.brucelindbloom.com/Eqn_Spect_to_XYZ.html</a>
<a name="ln313"> */</a>
<a name="ln314">static cmsCIEXYZ spectrum_to_XYZ(double TempK, spd I)</a>
<a name="ln315">{</a>
<a name="ln316">  cmsCIEXYZ Source = {.X = 0.0, .Y = 0.0, .Z = 0.0 };</a>
<a name="ln317"> </a>
<a name="ln318">  /*</a>
<a name="ln319">   * Color matching functions</a>
<a name="ln320">   * https://en.wikipedia.org/wiki/CIE_1931_color_space#Color_matching_functions</a>
<a name="ln321">   */</a>
<a name="ln322">  for(size_t i = 0; i &lt; cie_1931_std_colorimetric_observer_count; i++)</a>
<a name="ln323">  {</a>
<a name="ln324">    const unsigned long int lambda = cie_1931_std_colorimetric_observer[0].wavelength</a>
<a name="ln325">                                     + (cie_1931_std_colorimetric_observer[1].wavelength</a>
<a name="ln326">                                        - cie_1931_std_colorimetric_observer[0].wavelength) * i;</a>
<a name="ln327">    const double P = I(lambda, TempK);</a>
<a name="ln328">    Source.X += P * cie_1931_std_colorimetric_observer[i].xyz.X;</a>
<a name="ln329">    Source.Y += P * cie_1931_std_colorimetric_observer[i].xyz.Y;</a>
<a name="ln330">    Source.Z += P * cie_1931_std_colorimetric_observer[i].xyz.Z;</a>
<a name="ln331">  }</a>
<a name="ln332"> </a>
<a name="ln333">  // normalize so that each component is in [0.0, 1.0] range</a>
<a name="ln334">  const double _max = MAX(MAX(Source.X, Source.Y), Source.Z);</a>
<a name="ln335">  Source.X /= _max;</a>
<a name="ln336">  Source.Y /= _max;</a>
<a name="ln337">  Source.Z /= _max;</a>
<a name="ln338"> </a>
<a name="ln339">  return Source;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">//</a>
<a name="ln343">static cmsCIEXYZ temperature_to_XYZ(double TempK)</a>
<a name="ln344">{</a>
<a name="ln345">  if(TempK &lt; DT_IOP_LOWEST_TEMPERATURE) TempK = DT_IOP_LOWEST_TEMPERATURE;</a>
<a name="ln346">  if(TempK &gt; DT_IOP_HIGHEST_TEMPERATURE) TempK = DT_IOP_HIGHEST_TEMPERATURE;</a>
<a name="ln347"> </a>
<a name="ln348">  if(TempK &lt; INITIALBLACKBODYTEMPERATURE)</a>
<a name="ln349">  {</a>
<a name="ln350">    // if temperature is less than 4000K we use blackbody,</a>
<a name="ln351">    // because there will be no Daylight reference below 4000K...</a>
<a name="ln352">    return spectrum_to_XYZ(TempK, spd_blackbody);</a>
<a name="ln353">  }</a>
<a name="ln354">  else</a>
<a name="ln355">  {</a>
<a name="ln356">    return spectrum_to_XYZ(TempK, spd_daylight);</a>
<a name="ln357">  }</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">// binary search inversion</a>
<a name="ln361">static void XYZ_to_temperature(cmsCIEXYZ XYZ, double *TempK, double *tint)</a>
<a name="ln362">{</a>
<a name="ln363">  double maxtemp = DT_IOP_HIGHEST_TEMPERATURE, mintemp = DT_IOP_LOWEST_TEMPERATURE;</a>
<a name="ln364">  cmsCIEXYZ _xyz;</a>
<a name="ln365"> </a>
<a name="ln366">  for(*TempK = (maxtemp + mintemp) / 2.0; (maxtemp - mintemp) &gt; 1.0; *TempK = (maxtemp + mintemp) / 2.0)</a>
<a name="ln367">  {</a>
<a name="ln368">    _xyz = temperature_to_XYZ(*TempK);</a>
<a name="ln369">    if(_xyz.Z / _xyz.X &gt; XYZ.Z / XYZ.X)</a>
<a name="ln370">      maxtemp = *TempK;</a>
<a name="ln371">    else</a>
<a name="ln372">      mintemp = *TempK;</a>
<a name="ln373">  }</a>
<a name="ln374"> </a>
<a name="ln375">  *tint = (_xyz.Y / _xyz.X) / (XYZ.Y / XYZ.X);</a>
<a name="ln376"> </a>
<a name="ln377">  if(*TempK &lt; DT_IOP_LOWEST_TEMPERATURE) *TempK = DT_IOP_LOWEST_TEMPERATURE;</a>
<a name="ln378">  if(*TempK &gt; DT_IOP_HIGHEST_TEMPERATURE) *TempK = DT_IOP_HIGHEST_TEMPERATURE;</a>
<a name="ln379">  if(*tint &lt; DT_IOP_LOWEST_TINT) *tint = DT_IOP_LOWEST_TINT;</a>
<a name="ln380">  if(*tint &gt; DT_IOP_HIGHEST_TINT) *tint = DT_IOP_HIGHEST_TINT;</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">static void xyz2mul(dt_iop_module_t *self, cmsCIEXYZ xyz, double mul[4])</a>
<a name="ln384">{</a>
<a name="ln385">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln386"> </a>
<a name="ln387">  double XYZ[3] = { xyz.X, xyz.Y, xyz.Z };</a>
<a name="ln388"> </a>
<a name="ln389">  double CAM[4];</a>
<a name="ln390">  for(int k = 0; k &lt; 4; k++)</a>
<a name="ln391">  {</a>
<a name="ln392">    CAM[k] = 0.0;</a>
<a name="ln393">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln394">    {</a>
<a name="ln395">      CAM[k] += g-&gt;XYZ_to_CAM[k][i] * XYZ[i];</a>
<a name="ln396">    }</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  for(int k = 0; k &lt; 4; k++) mul[k] = 1.0 / CAM[k];</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">static void temp2mul(dt_iop_module_t *self, double TempK, double tint, double mul[4])</a>
<a name="ln403">{</a>
<a name="ln404">  cmsCIEXYZ xyz = temperature_to_XYZ(TempK);</a>
<a name="ln405"> </a>
<a name="ln406">  xyz.Y /= tint;</a>
<a name="ln407"> </a>
<a name="ln408">  xyz2mul(self, xyz, mul);</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">static cmsCIEXYZ mul2xyz(dt_iop_module_t *self, const float coeffs[4])</a>
<a name="ln412">{</a>
<a name="ln413">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln414"> </a>
<a name="ln415">  double CAM[4];</a>
<a name="ln416">  for(int k = 0; k &lt; 4; k++) CAM[k] = coeffs[k] &gt; 0.0f ? 1.0 / coeffs[k] : 0.0f;</a>
<a name="ln417"> </a>
<a name="ln418">  double XYZ[3];</a>
<a name="ln419">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln420">  {</a>
<a name="ln421">    XYZ[k] = 0.0;</a>
<a name="ln422">    for(int i = 0; i &lt; 4; i++)</a>
<a name="ln423">    {</a>
<a name="ln424">      XYZ[k] += g-&gt;CAM_to_XYZ[k][i] * CAM[i];</a>
<a name="ln425">    }</a>
<a name="ln426">  }</a>
<a name="ln427"> </a>
<a name="ln428">  return (cmsCIEXYZ){ XYZ[0], XYZ[1], XYZ[2] };</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">static void mul2temp(dt_iop_module_t *self, float coeffs[4], double *TempK, double *tint)</a>
<a name="ln432">{</a>
<a name="ln433">  XYZ_to_temperature(mul2xyz(self, coeffs), TempK, tint);</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">/*</a>
<a name="ln437"> * interpolate values from p1 and p2 into out.</a>
<a name="ln438"> */</a>
<a name="ln439">static void dt_wb_preset_interpolate(const wb_data *const p1, // the smaller tuning</a>
<a name="ln440">                                     const wb_data *const p2, // the larger tuning (can't be == p1)</a>
<a name="ln441">                                     wb_data *out)            // has tuning initialized</a>
<a name="ln442">{</a>
<a name="ln443">  const double t = CLAMP((double)(out-&gt;tuning - p1-&gt;tuning) / (double)(p2-&gt;tuning - p1-&gt;tuning), 0.0, 1.0);</a>
<a name="ln444">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln445">  {</a>
<a name="ln446">    out-&gt;channel[k] = 1.0 / (((1.0 - t) / p1-&gt;channel[k]) + (t / p2-&gt;channel[k]));</a>
<a name="ln447">  }</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln451">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln452">{</a>
<a name="ln453">  const uint32_t filters = piece-&gt;pipe-&gt;dsc.filters;</a>
<a name="ln454">  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece-&gt;pipe-&gt;dsc.xtrans;</a>
<a name="ln455">  const dt_iop_temperature_data_t *const d = (dt_iop_temperature_data_t *)piece-&gt;data;</a>
<a name="ln456"> </a>
<a name="ln457">  const float *const in = (const float *const)ivoid;</a>
<a name="ln458">  float *const out = (float *const)ovoid;</a>
<a name="ln459"> </a>
<a name="ln460">  if(filters == 9u)</a>
<a name="ln461">  { // xtrans float mosaiced</a>
<a name="ln462">#ifdef _OPENMP</a>
<a name="ln463">#pragma omp parallel for SIMD() default(none) schedule(static) collapse(2)</a>
<a name="ln464">#endif</a>
<a name="ln465">    for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln466">    {</a>
<a name="ln467">      for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln468">      {</a>
<a name="ln469">        const size_t p = (size_t)j * roi_out-&gt;width + i;</a>
<a name="ln470">        out[p] = in[p] * d-&gt;coeffs[FCxtrans(j, i, roi_out, xtrans)];</a>
<a name="ln471">      }</a>
<a name="ln472">    }</a>
<a name="ln473">  }</a>
<a name="ln474">  else if(filters)</a>
<a name="ln475">  { // bayer float mosaiced</a>
<a name="ln476">#ifdef _OPENMP</a>
<a name="ln477">#pragma omp parallel for SIMD() default(none) schedule(static) collapse(2)</a>
<a name="ln478">#endif</a>
<a name="ln479">    for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln480">    {</a>
<a name="ln481">      for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln482">      {</a>
<a name="ln483">        const size_t p = (size_t)j * roi_out-&gt;width + i;</a>
<a name="ln484">        out[p] = in[p] * d-&gt;coeffs[FC(j + roi_out-&gt;y, i + roi_out-&gt;x, filters)];</a>
<a name="ln485">      }</a>
<a name="ln486">    }</a>
<a name="ln487">  }</a>
<a name="ln488">  else</a>
<a name="ln489">  { // non-mosaiced</a>
<a name="ln490">    const int ch = piece-&gt;colors;</a>
<a name="ln491"> </a>
<a name="ln492">#ifdef _OPENMP</a>
<a name="ln493">#pragma omp parallel for SIMD() default(none) schedule(static) collapse(2)</a>
<a name="ln494">#endif</a>
<a name="ln495">    for(size_t k = 0; k &lt; (size_t)ch * roi_out-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln496">    {</a>
<a name="ln497">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln498">      {</a>
<a name="ln499">        const size_t p = (size_t)k + c;</a>
<a name="ln500">        out[p] = in[p] * d-&gt;coeffs[c];</a>
<a name="ln501">      }</a>
<a name="ln502">    }</a>
<a name="ln503"> </a>
<a name="ln504">    if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln505">  }</a>
<a name="ln506"> </a>
<a name="ln507">  piece-&gt;pipe-&gt;dsc.temperature.enabled = 1;</a>
<a name="ln508">  for(int k = 0; k &lt; 4; k++)</a>
<a name="ln509">  {</a>
<a name="ln510">    piece-&gt;pipe-&gt;dsc.temperature.coeffs[k] = d-&gt;coeffs[k];</a>
<a name="ln511">    piece-&gt;pipe-&gt;dsc.processed_maximum[k] = d-&gt;coeffs[k] * piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln512">  }</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">#if defined(__SSE__)</a>
<a name="ln516">void process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln517">                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln518">{</a>
<a name="ln519">  const uint32_t filters = piece-&gt;pipe-&gt;dsc.filters;</a>
<a name="ln520">  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece-&gt;pipe-&gt;dsc.xtrans;</a>
<a name="ln521">  dt_iop_temperature_data_t *d = (dt_iop_temperature_data_t *)piece-&gt;data;</a>
<a name="ln522">  if(filters == 9u)</a>
<a name="ln523">  { // xtrans float mosaiced</a>
<a name="ln524">#ifdef _OPENMP</a>
<a name="ln525">#pragma omp parallel for default(none) shared(d) schedule(static)</a>
<a name="ln526">#endif</a>
<a name="ln527">    for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln528">    {</a>
<a name="ln529">      const float *in = ((float *)ivoid) + (size_t)j * roi_out-&gt;width;</a>
<a name="ln530">      float *out = ((float *)ovoid) + (size_t)j * roi_out-&gt;width;</a>
<a name="ln531"> </a>
<a name="ln532">      int i = 0;</a>
<a name="ln533">      int alignment = ((4 - (j * roi_out-&gt;width &amp; (4 - 1))) &amp; (4 - 1));</a>
<a name="ln534"> </a>
<a name="ln535">      // process unaligned pixels</a>
<a name="ln536">      for(; i &lt; alignment &amp;&amp; i &lt; roi_out-&gt;width; i++, out++, in++)</a>
<a name="ln537">        *out = *in * d-&gt;coeffs[FCxtrans(j, i, roi_out, xtrans)];</a>
<a name="ln538"> </a>
<a name="ln539">      const __m128 coeffs[3] = {</a>
<a name="ln540">        _mm_set_ps(d-&gt;coeffs[FCxtrans(j, i + 3, roi_out, xtrans)], d-&gt;coeffs[FCxtrans(j, i + 2, roi_out, xtrans)],</a>
<a name="ln541">                   d-&gt;coeffs[FCxtrans(j, i + 1, roi_out, xtrans)], d-&gt;coeffs[FCxtrans(j, i + 0, roi_out, xtrans)]),</a>
<a name="ln542">        _mm_set_ps(d-&gt;coeffs[FCxtrans(j, i + 7, roi_out, xtrans)], d-&gt;coeffs[FCxtrans(j, i + 6, roi_out, xtrans)],</a>
<a name="ln543">                   d-&gt;coeffs[FCxtrans(j, i + 5, roi_out, xtrans)], d-&gt;coeffs[FCxtrans(j, i + 4, roi_out, xtrans)]),</a>
<a name="ln544">        _mm_set_ps(d-&gt;coeffs[FCxtrans(j, i + 11, roi_out, xtrans)], d-&gt;coeffs[FCxtrans(j, i + 10, roi_out, xtrans)],</a>
<a name="ln545">                   d-&gt;coeffs[FCxtrans(j, i + 9, roi_out, xtrans)], d-&gt;coeffs[FCxtrans(j, i + 8, roi_out, xtrans)])</a>
<a name="ln546">      };</a>
<a name="ln547"> </a>
<a name="ln548">      // process aligned pixels with SSE</a>
<a name="ln549">      for(int c = 0; c &lt; 3 &amp;&amp; i &lt; roi_out-&gt;width - (4 - 1); c++, i += 4, in += 4, out += 4)</a>
<a name="ln550">      {</a>
<a name="ln551">        __m128 v;</a>
<a name="ln552"> </a>
<a name="ln553">        v = _mm_load_ps(in);</a>
<a name="ln554">        v = _mm_mul_ps(v, coeffs[c]);</a>
<a name="ln555">        _mm_stream_ps(out, v);</a>
<a name="ln556">      }</a>
<a name="ln557"> </a>
<a name="ln558">      // process the rest</a>
<a name="ln559">      for(; i &lt; roi_out-&gt;width; i++, out++, in++) *out = *in * d-&gt;coeffs[FCxtrans(j, i, roi_out, xtrans)];</a>
<a name="ln560">    }</a>
<a name="ln561">    _mm_sfence();</a>
<a name="ln562">  }</a>
<a name="ln563">  else if(filters)</a>
<a name="ln564">  { // bayer float mosaiced</a>
<a name="ln565">#ifdef _OPENMP</a>
<a name="ln566">#pragma omp parallel for default(none) shared(d) schedule(static)</a>
<a name="ln567">#endif</a>
<a name="ln568">    for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln569">    {</a>
<a name="ln570">      const float *in = ((float *)ivoid) + (size_t)j * roi_out-&gt;width;</a>
<a name="ln571">      float *out = ((float *)ovoid) + (size_t)j * roi_out-&gt;width;</a>
<a name="ln572"> </a>
<a name="ln573">      int i = 0;</a>
<a name="ln574">      int alignment = ((4 - (j * roi_out-&gt;width &amp; (4 - 1))) &amp; (4 - 1));</a>
<a name="ln575"> </a>
<a name="ln576">      // process unaligned pixels</a>
<a name="ln577">      for(; i &lt; alignment &amp;&amp; i &lt; roi_out-&gt;width; i++, out++, in++)</a>
<a name="ln578">        *out = *in * d-&gt;coeffs[FC(j + roi_out-&gt;y, i + roi_out-&gt;x, filters)];</a>
<a name="ln579"> </a>
<a name="ln580">      const __m128 coeffs = _mm_set_ps(d-&gt;coeffs[FC(j + roi_out-&gt;y, roi_out-&gt;x + i + 3, filters)],</a>
<a name="ln581">                                       d-&gt;coeffs[FC(j + roi_out-&gt;y, roi_out-&gt;x + i + 2, filters)],</a>
<a name="ln582">                                       d-&gt;coeffs[FC(j + roi_out-&gt;y, roi_out-&gt;x + i + 1, filters)],</a>
<a name="ln583">                                       d-&gt;coeffs[FC(j + roi_out-&gt;y, roi_out-&gt;x + i, filters)]);</a>
<a name="ln584"> </a>
<a name="ln585">      // process aligned pixels with SSE</a>
<a name="ln586">      for(; i &lt; roi_out-&gt;width - (4 - 1); i += 4, in += 4, out += 4)</a>
<a name="ln587">      {</a>
<a name="ln588">        const __m128 input = _mm_load_ps(in);</a>
<a name="ln589"> </a>
<a name="ln590">        const __m128 multiplied = _mm_mul_ps(input, coeffs);</a>
<a name="ln591"> </a>
<a name="ln592">        _mm_stream_ps(out, multiplied);</a>
<a name="ln593">      }</a>
<a name="ln594"> </a>
<a name="ln595">      // process the rest</a>
<a name="ln596">      for(; i &lt; roi_out-&gt;width; i++, out++, in++)</a>
<a name="ln597">        *out = *in * d-&gt;coeffs[FC(j + roi_out-&gt;y, i + roi_out-&gt;x, filters)];</a>
<a name="ln598">    }</a>
<a name="ln599">    _mm_sfence();</a>
<a name="ln600">  }</a>
<a name="ln601">  else</a>
<a name="ln602">  { // non-mosaiced</a>
<a name="ln603">    const int ch = piece-&gt;colors;</a>
<a name="ln604"> </a>
<a name="ln605">    const __m128 coeffs = _mm_set_ps(1.0f, d-&gt;coeffs[2], d-&gt;coeffs[1], d-&gt;coeffs[0]);</a>
<a name="ln606"> </a>
<a name="ln607">#ifdef _OPENMP</a>
<a name="ln608">#pragma omp parallel for default(none) shared(d) schedule(static)</a>
<a name="ln609">#endif</a>
<a name="ln610">    for(int k = 0; k &lt; roi_out-&gt;height; k++)</a>
<a name="ln611">    {</a>
<a name="ln612">      const float *in = ((float *)ivoid) + (size_t)ch * k * roi_out-&gt;width;</a>
<a name="ln613">      float *out = ((float *)ovoid) + (size_t)ch * k * roi_out-&gt;width;</a>
<a name="ln614">      for(int j = 0; j &lt; roi_out-&gt;width; j++, in += ch, out += ch)</a>
<a name="ln615">      {</a>
<a name="ln616">        const __m128 input = _mm_load_ps(in);</a>
<a name="ln617">        const __m128 multiplied = _mm_mul_ps(input, coeffs);</a>
<a name="ln618">        _mm_stream_ps(out, multiplied);</a>
<a name="ln619">      }</a>
<a name="ln620">    }</a>
<a name="ln621">    _mm_sfence();</a>
<a name="ln622"> </a>
<a name="ln623">    if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln624">  }</a>
<a name="ln625"> </a>
<a name="ln626">  piece-&gt;pipe-&gt;dsc.temperature.enabled = 1;</a>
<a name="ln627">  for(int k = 0; k &lt; 4; k++)</a>
<a name="ln628">  {</a>
<a name="ln629">    piece-&gt;pipe-&gt;dsc.temperature.coeffs[k] = d-&gt;coeffs[k];</a>
<a name="ln630">    piece-&gt;pipe-&gt;dsc.processed_maximum[k] = d-&gt;coeffs[k] * piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln631">  }</a>
<a name="ln632">}</a>
<a name="ln633">#endif</a>
<a name="ln634"> </a>
<a name="ln635">#ifdef HAVE_OPENCL</a>
<a name="ln636">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln637">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln638">{</a>
<a name="ln639">  dt_iop_temperature_data_t *d = (dt_iop_temperature_data_t *)piece-&gt;data;</a>
<a name="ln640">  dt_iop_temperature_global_data_t *gd = (dt_iop_temperature_global_data_t *)self-&gt;data;</a>
<a name="ln641"> </a>
<a name="ln642">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln643">  const uint32_t filters = piece-&gt;pipe-&gt;dsc.filters;</a>
<a name="ln644">  cl_mem dev_coeffs = NULL;</a>
<a name="ln645">  cl_mem dev_xtrans = NULL;</a>
<a name="ln646">  cl_int err = -999;</a>
<a name="ln647">  int kernel = -1;</a>
<a name="ln648"> </a>
<a name="ln649">  if(filters == 9u)</a>
<a name="ln650">  {</a>
<a name="ln651">    kernel = gd-&gt;kernel_whitebalance_1f_xtrans;</a>
<a name="ln652">  }</a>
<a name="ln653">  else if(filters)</a>
<a name="ln654">  {</a>
<a name="ln655">    kernel = gd-&gt;kernel_whitebalance_1f;</a>
<a name="ln656">  }</a>
<a name="ln657">  else</a>
<a name="ln658">  {</a>
<a name="ln659">    kernel = gd-&gt;kernel_whitebalance_4f;</a>
<a name="ln660">  }</a>
<a name="ln661"> </a>
<a name="ln662">  if(filters == 9u)</a>
<a name="ln663">  {</a>
<a name="ln664">    dev_xtrans</a>
<a name="ln665">        = dt_opencl_copy_host_to_device_constant(devid, sizeof(piece-&gt;pipe-&gt;dsc.xtrans), piece-&gt;pipe-&gt;dsc.xtrans);</a>
<a name="ln666">    if(dev_xtrans == NULL) goto error;</a>
<a name="ln667">  }</a>
<a name="ln668"> </a>
<a name="ln669">  dev_coeffs = dt_opencl_copy_host_to_device_constant(devid, sizeof(float) * 3, d-&gt;coeffs);</a>
<a name="ln670">  if(dev_coeffs == NULL) goto error;</a>
<a name="ln671"> </a>
<a name="ln672">  const int width = roi_in-&gt;width;</a>
<a name="ln673">  const int height = roi_in-&gt;height;</a>
<a name="ln674"> </a>
<a name="ln675">  size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln676">  dt_opencl_set_kernel_arg(devid, kernel, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln677">  dt_opencl_set_kernel_arg(devid, kernel, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln678">  dt_opencl_set_kernel_arg(devid, kernel, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln679">  dt_opencl_set_kernel_arg(devid, kernel, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln680">  dt_opencl_set_kernel_arg(devid, kernel, 4, sizeof(cl_mem), (void *)&amp;dev_coeffs);</a>
<a name="ln681">  dt_opencl_set_kernel_arg(devid, kernel, 5, sizeof(uint32_t), (void *)&amp;filters);</a>
<a name="ln682">  dt_opencl_set_kernel_arg(devid, kernel, 6, sizeof(uint32_t), (void *)&amp;roi_out-&gt;x);</a>
<a name="ln683">  dt_opencl_set_kernel_arg(devid, kernel, 7, sizeof(uint32_t), (void *)&amp;roi_out-&gt;y);</a>
<a name="ln684">  dt_opencl_set_kernel_arg(devid, kernel, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln685">  err = dt_opencl_enqueue_kernel_2d(devid, kernel, sizes);</a>
<a name="ln686">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln687"> </a>
<a name="ln688">  dt_opencl_release_mem_object(dev_coeffs);</a>
<a name="ln689">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln690"> </a>
<a name="ln691">  piece-&gt;pipe-&gt;dsc.temperature.enabled = 1;</a>
<a name="ln692">  for(int k = 0; k &lt; 4; k++)</a>
<a name="ln693">  {</a>
<a name="ln694">    piece-&gt;pipe-&gt;dsc.temperature.coeffs[k] = d-&gt;coeffs[k];</a>
<a name="ln695">    piece-&gt;pipe-&gt;dsc.processed_maximum[k] = d-&gt;coeffs[k] * piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln696">  }</a>
<a name="ln697">  return TRUE;</a>
<a name="ln698"> </a>
<a name="ln699">error:</a>
<a name="ln700">  dt_opencl_release_mem_object(dev_coeffs);</a>
<a name="ln701">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln702">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_white_balance] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln703">  return FALSE;</a>
<a name="ln704">}</a>
<a name="ln705">#endif</a>
<a name="ln706"> </a>
<a name="ln707">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln708">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln709">{</a>
<a name="ln710">  dt_iop_temperature_params_t *p = (dt_iop_temperature_params_t *)p1;</a>
<a name="ln711">  dt_iop_temperature_data_t *d = (dt_iop_temperature_data_t *)piece-&gt;data;</a>
<a name="ln712"> </a>
<a name="ln713">  if(self-&gt;hide_enable_button)</a>
<a name="ln714">  {</a>
<a name="ln715">    piece-&gt;enabled = 0;</a>
<a name="ln716">    return;</a>
<a name="ln717">  }</a>
<a name="ln718"> </a>
<a name="ln719">  for(int k = 0; k &lt; 4; k++) d-&gt;coeffs[k] = p-&gt;coeffs[k];</a>
<a name="ln720"> </a>
<a name="ln721">  // 4Bayer images not implemented in OpenCL yet</a>
<a name="ln722">  if(self-&gt;dev-&gt;image_storage.flags &amp; DT_IMAGE_4BAYER) piece-&gt;process_cl_ready = 0;</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln726">{</a>
<a name="ln727">  piece-&gt;data = malloc(sizeof(dt_iop_temperature_data_t));</a>
<a name="ln728">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln732">{</a>
<a name="ln733">  free(piece-&gt;data);</a>
<a name="ln734">  piece-&gt;data = NULL;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln738">{</a>
<a name="ln739">  dt_iop_module_t *module = (dt_iop_module_t *)self;</a>
<a name="ln740">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln741">  dt_iop_temperature_params_t *p = (dt_iop_temperature_params_t *)module-&gt;params;</a>
<a name="ln742">  dt_iop_temperature_params_t *fp = (dt_iop_temperature_params_t *)module-&gt;default_params;</a>
<a name="ln743"> </a>
<a name="ln744">  if(self-&gt;hide_enable_button)</a>
<a name="ln745">  {</a>
<a name="ln746">    gtk_stack_set_visible_child_name(GTK_STACK(g-&gt;stack), &quot;disabled&quot;);</a>
<a name="ln747">    return;</a>
<a name="ln748">  }</a>
<a name="ln749">  gtk_stack_set_visible_child_name(GTK_STACK(g-&gt;stack), &quot;enabled&quot;);</a>
<a name="ln750"> </a>
<a name="ln751">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln752">  gtk_widget_hide(g-&gt;colorpicker);</a>
<a name="ln753"> </a>
<a name="ln754">  double TempK, tint;</a>
<a name="ln755">  mul2temp(self, p-&gt;coeffs, &amp;TempK, &amp;tint);</a>
<a name="ln756"> </a>
<a name="ln757">  dt_bauhaus_slider_set(g-&gt;scale_r, p-&gt;coeffs[0]);</a>
<a name="ln758">  dt_bauhaus_slider_set(g-&gt;scale_g, p-&gt;coeffs[1]);</a>
<a name="ln759">  dt_bauhaus_slider_set(g-&gt;scale_b, p-&gt;coeffs[2]);</a>
<a name="ln760">  dt_bauhaus_slider_set(g-&gt;scale_g2, p-&gt;coeffs[3]);</a>
<a name="ln761">  dt_bauhaus_slider_set(g-&gt;scale_k, TempK);</a>
<a name="ln762">  dt_bauhaus_slider_set(g-&gt;scale_tint, tint);</a>
<a name="ln763"> </a>
<a name="ln764">  gui_sliders_update(self);</a>
<a name="ln765"> </a>
<a name="ln766">  dt_bauhaus_combobox_clear(g-&gt;presets);</a>
<a name="ln767">  dt_bauhaus_combobox_add(g-&gt;presets, C_(&quot;white balance&quot;, &quot;camera&quot;));</a>
<a name="ln768">  dt_bauhaus_combobox_add(g-&gt;presets, C_(&quot;white balance&quot;, &quot;camera neutral&quot;));</a>
<a name="ln769">  dt_bauhaus_combobox_add(g-&gt;presets, C_(&quot;white balance&quot;, &quot;spot&quot;));</a>
<a name="ln770">  g-&gt;preset_cnt = DT_IOP_NUM_OF_STD_TEMP_PRESETS;</a>
<a name="ln771">  memset(g-&gt;preset_num, 0, sizeof(g-&gt;preset_num));</a>
<a name="ln772"> </a>
<a name="ln773">  dt_bauhaus_combobox_set(g-&gt;presets, -1);</a>
<a name="ln774">  dt_bauhaus_slider_set(g-&gt;finetune, 0);</a>
<a name="ln775">  gtk_widget_set_sensitive(g-&gt;finetune, 0);</a>
<a name="ln776"> </a>
<a name="ln777">  const char *wb_name = NULL;</a>
<a name="ln778">  if(!dt_image_is_ldr(&amp;self-&gt;dev-&gt;image_storage))</a>
<a name="ln779">    for(int i = 0; i &lt; wb_preset_count; i++)</a>
<a name="ln780">    {</a>
<a name="ln781">      if(g-&gt;preset_cnt &gt;= 50) break;</a>
<a name="ln782">      if(!strcmp(wb_preset[i].make, self-&gt;dev-&gt;image_storage.camera_maker)</a>
<a name="ln783">         &amp;&amp; !strcmp(wb_preset[i].model, self-&gt;dev-&gt;image_storage.camera_model))</a>
<a name="ln784">      {</a>
<a name="ln785">        if(!wb_name || strcmp(wb_name, wb_preset[i].name))</a>
<a name="ln786">        {</a>
<a name="ln787">          wb_name = wb_preset[i].name;</a>
<a name="ln788">          dt_bauhaus_combobox_add(g-&gt;presets, _(wb_preset[i].name));</a>
<a name="ln789">          g-&gt;preset_num[g-&gt;preset_cnt] = i;</a>
<a name="ln790">          g-&gt;preset_cnt++;</a>
<a name="ln791">        }</a>
<a name="ln792">      }</a>
<a name="ln793">    }</a>
<a name="ln794"> </a>
<a name="ln795">  gboolean found = FALSE;</a>
<a name="ln796">  // is this a camera white balance?</a>
<a name="ln797">  if(memcmp(p-&gt;coeffs, fp-&gt;coeffs, 3 * sizeof(float)) == 0)</a>
<a name="ln798">  {</a>
<a name="ln799">    dt_bauhaus_combobox_set(g-&gt;presets, 0);</a>
<a name="ln800">    found = TRUE;</a>
<a name="ln801">  }</a>
<a name="ln802">  else</a>
<a name="ln803">  {</a>
<a name="ln804">    // is this a &quot;camera neutral white balance&quot;?</a>
<a name="ln805">    if((p-&gt;coeffs[0] == (float)g-&gt;daylight_wb[0]) &amp;&amp; (p-&gt;coeffs[1] == (float)g-&gt;daylight_wb[1])</a>
<a name="ln806">       &amp;&amp; (p-&gt;coeffs[2] == (float)g-&gt;daylight_wb[2]))</a>
<a name="ln807">    {</a>
<a name="ln808">      dt_bauhaus_combobox_set(g-&gt;presets, 1);</a>
<a name="ln809">      found = TRUE;</a>
<a name="ln810">    }</a>
<a name="ln811">  }</a>
<a name="ln812"> </a>
<a name="ln813">  if(!found)</a>
<a name="ln814">  {</a>
<a name="ln815">    // look through all added presets</a>
<a name="ln816">    for(int j = DT_IOP_NUM_OF_STD_TEMP_PRESETS; !found &amp;&amp; (j &lt; g-&gt;preset_cnt); j++)</a>
<a name="ln817">    {</a>
<a name="ln818">      // look through all variants of this preset, with different tuning</a>
<a name="ln819">      for(int i = g-&gt;preset_num[j]; !found &amp;&amp; (i &lt; wb_preset_count)</a>
<a name="ln820">                                    &amp;&amp; !strcmp(wb_preset[i].make, self-&gt;dev-&gt;image_storage.camera_maker)</a>
<a name="ln821">                                    &amp;&amp; !strcmp(wb_preset[i].model, self-&gt;dev-&gt;image_storage.camera_model)</a>
<a name="ln822">                                    &amp;&amp; !strcmp(wb_preset[i].name, wb_preset[g-&gt;preset_num[j]].name);</a>
<a name="ln823">          i++)</a>
<a name="ln824">      {</a>
<a name="ln825">        float coeffs[3];</a>
<a name="ln826">        for(int k = 0; k &lt; 3; k++) coeffs[k] = wb_preset[i].channel[k];</a>
<a name="ln827"> </a>
<a name="ln828">        if(memcmp(coeffs, p-&gt;coeffs, 3 * sizeof(float)) == 0)</a>
<a name="ln829">        {</a>
<a name="ln830">          // got exact match!</a>
<a name="ln831">          dt_bauhaus_combobox_set(g-&gt;presets, j);</a>
<a name="ln832">          gtk_widget_set_sensitive(g-&gt;finetune, 1);</a>
<a name="ln833">          dt_bauhaus_slider_set(g-&gt;finetune, wb_preset[i].tuning);</a>
<a name="ln834">          found = TRUE;</a>
<a name="ln835">          break;</a>
<a name="ln836">        }</a>
<a name="ln837">      }</a>
<a name="ln838">    }</a>
<a name="ln839"> </a>
<a name="ln840">    if(!found)</a>
<a name="ln841">    {</a>
<a name="ln842">      // ok, we haven't found exact match, maybe this was interpolated?</a>
<a name="ln843"> </a>
<a name="ln844">      // look through all added presets</a>
<a name="ln845">      for(int j = DT_IOP_NUM_OF_STD_TEMP_PRESETS; !found &amp;&amp; (j &lt; g-&gt;preset_cnt); j++)</a>
<a name="ln846">      {</a>
<a name="ln847">        // look through all variants of this preset, with different tuning</a>
<a name="ln848">        int i = g-&gt;preset_num[j] + 1;</a>
<a name="ln849">        while(!found &amp;&amp; (i &lt; wb_preset_count) &amp;&amp; !strcmp(wb_preset[i].make, self-&gt;dev-&gt;image_storage.camera_maker)</a>
<a name="ln850">              &amp;&amp; !strcmp(wb_preset[i].model, self-&gt;dev-&gt;image_storage.camera_maker)</a>
<a name="ln851">              &amp;&amp; !strcmp(wb_preset[i].name, wb_preset[g-&gt;preset_num[j]].name))</a>
<a name="ln852">        {</a>
<a name="ln853">          // let's find gaps</a>
<a name="ln854">          if(wb_preset[i - 1].tuning + 1 == wb_preset[i].tuning)</a>
<a name="ln855">          {</a>
<a name="ln856">            i++;</a>
<a name="ln857">            continue;</a>
<a name="ln858">          }</a>
<a name="ln859"> </a>
<a name="ln860">          // we have a gap!</a>
<a name="ln861"> </a>
<a name="ln862">          // we do not know what finetuning value was set, we need to bruteforce to find it</a>
<a name="ln863">          for(int tune = wb_preset[i - 1].tuning + 1; !found &amp;&amp; (tune &lt; wb_preset[i].tuning); tune++)</a>
<a name="ln864">          {</a>
<a name="ln865">            wb_data interpolated = {.tuning = tune };</a>
<a name="ln866">            dt_wb_preset_interpolate(&amp;wb_preset[i - 1], &amp;wb_preset[i], &amp;interpolated);</a>
<a name="ln867"> </a>
<a name="ln868">            float coeffs[3];</a>
<a name="ln869">            for(int k = 0; k &lt; 3; k++) coeffs[k] = interpolated.channel[k];</a>
<a name="ln870"> </a>
<a name="ln871">            if(memcmp(coeffs, p-&gt;coeffs, 3 * sizeof(float)) == 0)</a>
<a name="ln872">            {</a>
<a name="ln873">              // got exact match!</a>
<a name="ln874"> </a>
<a name="ln875">              dt_bauhaus_combobox_set(g-&gt;presets, j);</a>
<a name="ln876">              gtk_widget_set_sensitive(g-&gt;finetune, 1);</a>
<a name="ln877">              dt_bauhaus_slider_set(g-&gt;finetune, tune);</a>
<a name="ln878">              found = TRUE;</a>
<a name="ln879">              break;</a>
<a name="ln880">            }</a>
<a name="ln881">          }</a>
<a name="ln882">          i++;</a>
<a name="ln883">        }</a>
<a name="ln884">      }</a>
<a name="ln885">    }</a>
<a name="ln886">  }</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">static int calculate_bogus_daylight_wb(dt_iop_module_t *module, double bwb[4])</a>
<a name="ln890">{</a>
<a name="ln891">  if(!dt_image_is_raw(&amp;module-&gt;dev-&gt;image_storage))</a>
<a name="ln892">  {</a>
<a name="ln893">    bwb[0] = 1.0;</a>
<a name="ln894">    bwb[2] = 1.0;</a>
<a name="ln895">    bwb[1] = 1.0;</a>
<a name="ln896">    bwb[3] = 1.0;</a>
<a name="ln897"> </a>
<a name="ln898">    return 0;</a>
<a name="ln899">  }</a>
<a name="ln900"> </a>
<a name="ln901">  double mul[4];</a>
<a name="ln902">  if (dt_colorspaces_conversion_matrices_rgb(module-&gt;dev-&gt;image_storage.camera_makermodel, NULL, NULL, mul))</a>
<a name="ln903">  {</a>
<a name="ln904">    // normalize green:</a>
<a name="ln905">    bwb[0] = mul[0] / mul[1];</a>
<a name="ln906">    bwb[2] = mul[2] / mul[1];</a>
<a name="ln907">    bwb[1] = 1.0;</a>
<a name="ln908">    bwb[3] = mul[3] / mul[1];</a>
<a name="ln909"> </a>
<a name="ln910">    return 0;</a>
<a name="ln911">  }</a>
<a name="ln912"> </a>
<a name="ln913">  return 1;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916">static void prepare_matrices(dt_iop_module_t *module)</a>
<a name="ln917">{</a>
<a name="ln918">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln919"> </a>
<a name="ln920">  // sRGB D65</a>
<a name="ln921">  const double RGB_to_XYZ[3][4] = { { 0.4124564, 0.3575761, 0.1804375, 0 },</a>
<a name="ln922">                                    { 0.2126729, 0.7151522, 0.0721750, 0 },</a>
<a name="ln923">                                    { 0.0193339, 0.1191920, 0.9503041, 0 } };</a>
<a name="ln924"> </a>
<a name="ln925">  // sRGB D65</a>
<a name="ln926">  const double XYZ_to_RGB[4][3] = { { 3.2404542, -1.5371385, -0.4985314 },</a>
<a name="ln927">                                    { -0.9692660, 1.8760108, 0.0415560 },</a>
<a name="ln928">                                    { 0.0556434, -0.2040259, 1.0572252 },</a>
<a name="ln929">                                    { 0, 0, 0 } };</a>
<a name="ln930"> </a>
<a name="ln931">  if(!dt_image_is_raw(&amp;module-&gt;dev-&gt;image_storage))</a>
<a name="ln932">  {</a>
<a name="ln933">    // let's just assume for now(TM) that if it is not raw, it is sRGB</a>
<a name="ln934">    memcpy(g-&gt;XYZ_to_CAM, XYZ_to_RGB, sizeof(g-&gt;XYZ_to_CAM));</a>
<a name="ln935">    memcpy(g-&gt;CAM_to_XYZ, RGB_to_XYZ, sizeof(g-&gt;CAM_to_XYZ));</a>
<a name="ln936">    return;</a>
<a name="ln937">  }</a>
<a name="ln938"> </a>
<a name="ln939">  char *camera = module-&gt;dev-&gt;image_storage.camera_makermodel;</a>
<a name="ln940">  if (!dt_colorspaces_conversion_matrices_xyz(camera, module-&gt;dev-&gt;image_storage.d65_color_matrix,</a>
<a name="ln941">                                                      g-&gt;XYZ_to_CAM, g-&gt;CAM_to_XYZ))</a>
<a name="ln942">  {</a>
<a name="ln943">    fprintf(stderr, &quot;[temperature] `%s' color matrix not found for image\n&quot;, camera);</a>
<a name="ln944">    dt_control_log(_(&quot;`%s' color matrix not found for image&quot;), camera);</a>
<a name="ln945">  }</a>
<a name="ln946">}</a>
<a name="ln947"> </a>
<a name="ln948">static void find_coeffs(dt_iop_module_t *module, float coeffs[4])</a>
<a name="ln949">{</a>
<a name="ln950">  const dt_image_t *img = &amp;module-&gt;dev-&gt;image_storage;</a>
<a name="ln951"> </a>
<a name="ln952">  // the raw should provide wb coeffs:</a>
<a name="ln953">  int ok = 1;</a>
<a name="ln954">  // Only check the first three values, the fourth is usually NAN for RGB</a>
<a name="ln955">  int num_coeffs = (img-&gt;flags &amp; DT_IMAGE_4BAYER) ? 4 : 3;</a>
<a name="ln956">  for(int k = 0; ok &amp;&amp; k &lt; num_coeffs; k++)</a>
<a name="ln957">  {</a>
<a name="ln958">    if(!isnormal(img-&gt;wb_coeffs[k]) || img-&gt;wb_coeffs[k] == 0.0f) ok = 0;</a>
<a name="ln959">  }</a>
<a name="ln960">  if(ok)</a>
<a name="ln961">  {</a>
<a name="ln962">    for(int k = 0; k &lt; 4; k++) coeffs[k] = img-&gt;wb_coeffs[k];</a>
<a name="ln963">    return;</a>
<a name="ln964">  }</a>
<a name="ln965"> </a>
<a name="ln966">  if(!ignore_missing_wb(&amp;(module-&gt;dev-&gt;image_storage)))</a>
<a name="ln967">  {</a>
<a name="ln968">    dt_control_log(_(&quot;failed to read camera white balance information from `%s'!&quot;),</a>
<a name="ln969">                   img-&gt;filename);</a>
<a name="ln970">    fprintf(stderr, &quot;[temperature] failed to read camera white balance information from `%s'!\n&quot;,</a>
<a name="ln971">            img-&gt;filename);</a>
<a name="ln972">  }</a>
<a name="ln973"> </a>
<a name="ln974">  double bwb[4];</a>
<a name="ln975">  if(!calculate_bogus_daylight_wb(module, bwb))</a>
<a name="ln976">  {</a>
<a name="ln977">    // found camera matrix and used it to calculate bogus daylight wb</a>
<a name="ln978">    for(int c = 0; c &lt; 4; c++) coeffs[c] = bwb[c];</a>
<a name="ln979">    return;</a>
<a name="ln980">  }</a>
<a name="ln981"> </a>
<a name="ln982">  // no cam matrix??? try presets:</a>
<a name="ln983">  for(int i = 0; i &lt; wb_preset_count; i++)</a>
<a name="ln984">  {</a>
<a name="ln985">    if(!strcmp(wb_preset[i].make, img-&gt;camera_maker)</a>
<a name="ln986">       &amp;&amp; !strcmp(wb_preset[i].model, img-&gt;camera_model))</a>
<a name="ln987">    {</a>
<a name="ln988">      // just take the first preset we find for this camera</a>
<a name="ln989">      for(int k = 0; k &lt; 3; k++) coeffs[k] = wb_preset[i].channel[k];</a>
<a name="ln990">      return;</a>
<a name="ln991">    }</a>
<a name="ln992">  }</a>
<a name="ln993"> </a>
<a name="ln994">  // did not find preset either?</a>
<a name="ln995">  // final security net: hardcoded default that fits most cams.</a>
<a name="ln996">  coeffs[0] = 2.0f;</a>
<a name="ln997">  coeffs[1] = 1.0f;</a>
<a name="ln998">  coeffs[2] = 1.5f;</a>
<a name="ln999">  coeffs[3] = 1.0f;</a>
<a name="ln1000">}</a>
<a name="ln1001"> </a>
<a name="ln1002">void reload_defaults(dt_iop_module_t *module)</a>
<a name="ln1003">{</a>
<a name="ln1004">  dt_iop_temperature_params_t tmp</a>
<a name="ln1005">      = (dt_iop_temperature_params_t){.coeffs = { 1.0, 1.0, 1.0, 1.0 } };</a>
<a name="ln1006"> </a>
<a name="ln1007">  // we might be called from presets update infrastructure =&gt; there is no image</a>
<a name="ln1008">  if(!module-&gt;dev) goto end;</a>
<a name="ln1009"> </a>
<a name="ln1010">  const int is_raw = dt_image_is_raw(&amp;module-&gt;dev-&gt;image_storage);</a>
<a name="ln1011"> </a>
<a name="ln1012">  module-&gt;default_enabled = 0;</a>
<a name="ln1013">  module-&gt;hide_enable_button = 0;</a>
<a name="ln1014"> </a>
<a name="ln1015">  // White balance module doesn't need to be enabled for monochrome raws (like</a>
<a name="ln1016">  // for leica monochrom cameras). prepare_matrices is a noop as well, as there</a>
<a name="ln1017">  // isn't a color matrix, so we can skip that as well.</a>
<a name="ln1018">  if(is_raw &amp;&amp; dt_image_is_monochrome(&amp;(module-&gt;dev-&gt;image_storage)))</a>
<a name="ln1019">  {</a>
<a name="ln1020">    module-&gt;hide_enable_button = 1;</a>
<a name="ln1021">  }</a>
<a name="ln1022">  else</a>
<a name="ln1023">  {</a>
<a name="ln1024">    if(module-&gt;gui_data) prepare_matrices(module);</a>
<a name="ln1025"> </a>
<a name="ln1026">    /* check if file is raw / hdr */</a>
<a name="ln1027">    if(is_raw)</a>
<a name="ln1028">    {</a>
<a name="ln1029">      // raw images need wb:</a>
<a name="ln1030">      module-&gt;default_enabled = 1;</a>
<a name="ln1031"> </a>
<a name="ln1032">      // do best to find starting coeffs</a>
<a name="ln1033">      find_coeffs(module, tmp.coeffs);</a>
<a name="ln1034">      tmp.coeffs[0] /= tmp.coeffs[1];</a>
<a name="ln1035">      tmp.coeffs[2] /= tmp.coeffs[1];</a>
<a name="ln1036">      tmp.coeffs[3] /= tmp.coeffs[1];</a>
<a name="ln1037">      tmp.coeffs[1] = 1.0f;</a>
<a name="ln1038">    }</a>
<a name="ln1039">  }</a>
<a name="ln1040"> </a>
<a name="ln1041">  // remember daylight wb used for temperature/tint conversion,</a>
<a name="ln1042">  // assuming it corresponds to CIE daylight (D65)</a>
<a name="ln1043">  if(module-&gt;gui_data)</a>
<a name="ln1044">  {</a>
<a name="ln1045">    dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln1046"> </a>
<a name="ln1047">    dt_bauhaus_slider_set_default(g-&gt;scale_r, tmp.coeffs[0]);</a>
<a name="ln1048">    dt_bauhaus_slider_set_default(g-&gt;scale_g, tmp.coeffs[1]);</a>
<a name="ln1049">    dt_bauhaus_slider_set_default(g-&gt;scale_b, tmp.coeffs[2]);</a>
<a name="ln1050">    dt_bauhaus_slider_set_default(g-&gt;scale_g2, tmp.coeffs[3]);</a>
<a name="ln1051"> </a>
<a name="ln1052">    // to have at least something and definitely not crash</a>
<a name="ln1053">    for(int c = 0; c &lt; 4; c++) g-&gt;daylight_wb[c] = tmp.coeffs[c];</a>
<a name="ln1054"> </a>
<a name="ln1055">    if(!calculate_bogus_daylight_wb(module, g-&gt;daylight_wb))</a>
<a name="ln1056">    {</a>
<a name="ln1057">      // found camera matrix and used it to calculate bogus daylight wb</a>
<a name="ln1058">    }</a>
<a name="ln1059">    else</a>
<a name="ln1060">    {</a>
<a name="ln1061">      // if we didn't find anything for daylight wb, look for a wb preset with appropriate name.</a>
<a name="ln1062">      // we're normalizing that to be D65</a>
<a name="ln1063">      for(int i = 0; i &lt; wb_preset_count; i++)</a>
<a name="ln1064">      {</a>
<a name="ln1065">        if(!strcmp(wb_preset[i].make, module-&gt;dev-&gt;image_storage.camera_maker)</a>
<a name="ln1066">           &amp;&amp; !strcmp(wb_preset[i].model, module-&gt;dev-&gt;image_storage.camera_model)</a>
<a name="ln1067">           &amp;&amp; !strcmp(wb_preset[i].name, Daylight) &amp;&amp; wb_preset[i].tuning == 0)</a>
<a name="ln1068">        {</a>
<a name="ln1069">          for(int k = 0; k &lt; 4; k++) g-&gt;daylight_wb[k] = wb_preset[i].channel[k];</a>
<a name="ln1070">          break;</a>
<a name="ln1071">        }</a>
<a name="ln1072">      }</a>
<a name="ln1073">    }</a>
<a name="ln1074"> </a>
<a name="ln1075">    double TempK, tint;</a>
<a name="ln1076">    mul2temp(module, tmp.coeffs, &amp;TempK, &amp;tint);</a>
<a name="ln1077"> </a>
<a name="ln1078">    dt_bauhaus_slider_set_default(g-&gt;scale_k, TempK);</a>
<a name="ln1079">    dt_bauhaus_slider_set_default(g-&gt;scale_tint, tint);</a>
<a name="ln1080"> </a>
<a name="ln1081">#if COLORED_SLIDERS</a>
<a name="ln1082">    const float neutral_stop_tint = (tint - DT_IOP_LOWEST_TINT) / (DT_IOP_HIGHEST_TINT - DT_IOP_LOWEST_TINT);</a>
<a name="ln1083">    dt_bauhaus_slider_clear_stops(g-&gt;scale_tint);</a>
<a name="ln1084">    dt_bauhaus_slider_set_stop(g-&gt;scale_tint, 0.0, 1.0, 0.0, 1.0);</a>
<a name="ln1085">    dt_bauhaus_slider_set_stop(g-&gt;scale_tint, neutral_stop_tint, 1.0, 1.0, 1.0);</a>
<a name="ln1086">    dt_bauhaus_slider_set_stop(g-&gt;scale_tint, 1.0, 0.0, 1.0, 0.0);</a>
<a name="ln1087">#endif</a>
<a name="ln1088">  }</a>
<a name="ln1089"> </a>
<a name="ln1090">end:</a>
<a name="ln1091">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_temperature_params_t));</a>
<a name="ln1092">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_temperature_params_t));</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln1096">{</a>
<a name="ln1097">  const int program = 2; // basic.cl, from programs.conf</a>
<a name="ln1098">  dt_iop_temperature_global_data_t *gd</a>
<a name="ln1099">      = (dt_iop_temperature_global_data_t *)malloc(sizeof(dt_iop_temperature_global_data_t));</a>
<a name="ln1100">  module-&gt;data = gd;</a>
<a name="ln1101">  gd-&gt;kernel_whitebalance_4f = dt_opencl_create_kernel(program, &quot;whitebalance_4f&quot;);</a>
<a name="ln1102">  gd-&gt;kernel_whitebalance_1f = dt_opencl_create_kernel(program, &quot;whitebalance_1f&quot;);</a>
<a name="ln1103">  gd-&gt;kernel_whitebalance_1f_xtrans = dt_opencl_create_kernel(program, &quot;whitebalance_1f_xtrans&quot;);</a>
<a name="ln1104">}</a>
<a name="ln1105"> </a>
<a name="ln1106">void init(dt_iop_module_t *module)</a>
<a name="ln1107">{</a>
<a name="ln1108">  module-&gt;params = calloc(1, sizeof(dt_iop_temperature_params_t));</a>
<a name="ln1109">  module-&gt;default_params = calloc(1, sizeof(dt_iop_temperature_params_t));</a>
<a name="ln1110">  module-&gt;params_size = sizeof(dt_iop_temperature_params_t);</a>
<a name="ln1111">  module-&gt;gui_data = NULL;</a>
<a name="ln1112">}</a>
<a name="ln1113"> </a>
<a name="ln1114">void cleanup(dt_iop_module_t *module)</a>
<a name="ln1115">{</a>
<a name="ln1116">  free(module-&gt;params);</a>
<a name="ln1117">  module-&gt;params = NULL;</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln1121">{</a>
<a name="ln1122">  dt_iop_temperature_global_data_t *gd = (dt_iop_temperature_global_data_t *)module-&gt;data;</a>
<a name="ln1123">  dt_opencl_free_kernel(gd-&gt;kernel_whitebalance_4f);</a>
<a name="ln1124">  dt_opencl_free_kernel(gd-&gt;kernel_whitebalance_1f);</a>
<a name="ln1125">  dt_opencl_free_kernel(gd-&gt;kernel_whitebalance_1f_xtrans);</a>
<a name="ln1126">  free(module-&gt;data);</a>
<a name="ln1127">  module-&gt;data = NULL;</a>
<a name="ln1128">}</a>
<a name="ln1129"> </a>
<a name="ln1130">static void gui_update_from_coeffs(dt_iop_module_t *self)</a>
<a name="ln1131">{</a>
<a name="ln1132">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1133">  dt_iop_temperature_params_t *p = (dt_iop_temperature_params_t *)self-&gt;params;</a>
<a name="ln1134"> </a>
<a name="ln1135">  double TempK, tint;</a>
<a name="ln1136">  mul2temp(self, p-&gt;coeffs, &amp;TempK, &amp;tint);</a>
<a name="ln1137"> </a>
<a name="ln1138">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1139">  dt_bauhaus_slider_set(g-&gt;scale_k, TempK);</a>
<a name="ln1140">  dt_bauhaus_slider_set(g-&gt;scale_tint, tint);</a>
<a name="ln1141">  dt_bauhaus_slider_set(g-&gt;scale_r, p-&gt;coeffs[0]);</a>
<a name="ln1142">  dt_bauhaus_slider_set(g-&gt;scale_g, p-&gt;coeffs[1]);</a>
<a name="ln1143">  dt_bauhaus_slider_set(g-&gt;scale_b, p-&gt;coeffs[2]);</a>
<a name="ln1144">  dt_bauhaus_slider_set(g-&gt;scale_g2, p-&gt;coeffs[3]);</a>
<a name="ln1145">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1146">}</a>
<a name="ln1147"> </a>
<a name="ln1148">static void temp_changed(dt_iop_module_t *self)</a>
<a name="ln1149">{</a>
<a name="ln1150">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1151">  dt_iop_temperature_params_t *p = (dt_iop_temperature_params_t *)self-&gt;params;</a>
<a name="ln1152"> </a>
<a name="ln1153">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1154">  </a>
<a name="ln1155">  const double TempK = dt_bauhaus_slider_get(g-&gt;scale_k);</a>
<a name="ln1156">  const double tint = dt_bauhaus_slider_get(g-&gt;scale_tint);</a>
<a name="ln1157"> </a>
<a name="ln1158">  double coeffs[4];</a>
<a name="ln1159">  temp2mul(self, TempK, tint, coeffs);</a>
<a name="ln1160"> </a>
<a name="ln1161">  // normalize</a>
<a name="ln1162">  coeffs[0] /= coeffs[1];</a>
<a name="ln1163">  coeffs[2] /= coeffs[1];</a>
<a name="ln1164">  coeffs[3] /= coeffs[1];</a>
<a name="ln1165">  coeffs[1] = 1.0;</a>
<a name="ln1166"> </a>
<a name="ln1167">  for(int c = 0; c &lt; 4; c++) p-&gt;coeffs[c] = coeffs[c];</a>
<a name="ln1168"> </a>
<a name="ln1169">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1170">  dt_bauhaus_slider_set(g-&gt;scale_r, p-&gt;coeffs[0]);</a>
<a name="ln1171">  dt_bauhaus_slider_set(g-&gt;scale_g, p-&gt;coeffs[1]);</a>
<a name="ln1172">  dt_bauhaus_slider_set(g-&gt;scale_b, p-&gt;coeffs[2]);</a>
<a name="ln1173">  dt_bauhaus_slider_set(g-&gt;scale_g2, p-&gt;coeffs[3]);</a>
<a name="ln1174">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1175">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1176">}</a>
<a name="ln1177"> </a>
<a name="ln1178">static void tint_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1179">{</a>
<a name="ln1180">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1181">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1182">  temp_changed(self);</a>
<a name="ln1183">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1184">  dt_bauhaus_combobox_set(g-&gt;presets, -1);</a>
<a name="ln1185">}</a>
<a name="ln1186"> </a>
<a name="ln1187">static void temp_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1188">{</a>
<a name="ln1189">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1190">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1191">  temp_changed(self);</a>
<a name="ln1192">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1193">  dt_bauhaus_combobox_set(g-&gt;presets, -1);</a>
<a name="ln1194">}</a>
<a name="ln1195"> </a>
<a name="ln1196">static void rgb_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1197">{</a>
<a name="ln1198">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1199">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1200">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1201">  dt_iop_temperature_params_t *p = (dt_iop_temperature_params_t *)self-&gt;params;</a>
<a name="ln1202">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1203">  const float value = dt_bauhaus_slider_get(slider);</a>
<a name="ln1204">  if(slider == g-&gt;scale_r)</a>
<a name="ln1205">    p-&gt;coeffs[0] = value;</a>
<a name="ln1206">  else if(slider == g-&gt;scale_g)</a>
<a name="ln1207">    p-&gt;coeffs[1] = value;</a>
<a name="ln1208">  else if(slider == g-&gt;scale_b)</a>
<a name="ln1209">    p-&gt;coeffs[2] = value;</a>
<a name="ln1210">  else if(slider == g-&gt;scale_g2)</a>
<a name="ln1211">    p-&gt;coeffs[3] = value;</a>
<a name="ln1212"> </a>
<a name="ln1213">  gui_update_from_coeffs(self);</a>
<a name="ln1214">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1215">  dt_bauhaus_combobox_set(g-&gt;presets, -1);</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">static void apply_preset(dt_iop_module_t *self)</a>
<a name="ln1219">{</a>
<a name="ln1220">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1221">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1222">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1223">  dt_iop_temperature_params_t *p = (dt_iop_temperature_params_t *)self-&gt;params;</a>
<a name="ln1224">  dt_iop_temperature_params_t *fp = (dt_iop_temperature_params_t *)self-&gt;default_params;</a>
<a name="ln1225">  const int tune = dt_bauhaus_slider_get(g-&gt;finetune);</a>
<a name="ln1226">  const int pos = dt_bauhaus_combobox_get(g-&gt;presets);</a>
<a name="ln1227">  switch(pos)</a>
<a name="ln1228">  {</a>
<a name="ln1229">    case -1: // just un-setting.</a>
<a name="ln1230">      return;</a>
<a name="ln1231">    case 0: // camera wb</a>
<a name="ln1232">      for(int k = 0; k &lt; 4; k++) p-&gt;coeffs[k] = fp-&gt;coeffs[k];</a>
<a name="ln1233">      break;</a>
<a name="ln1234">    case 1: // camera neutral wb</a>
<a name="ln1235">      for(int k = 0; k &lt; 4; k++) p-&gt;coeffs[k] = g-&gt;daylight_wb[k];</a>
<a name="ln1236">      break;</a>
<a name="ln1237">    case 2: // spot wb, expose callback will set p-&gt;coeffs.</a>
<a name="ln1238"> </a>
<a name="ln1239">      //reset previously stored color picker information</a>
<a name="ln1240">      for(int k = 0; k &lt; 4; k++) old[k] = 0.0f;</a>
<a name="ln1241">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;colorpicker), TRUE);</a>
<a name="ln1242">      break;</a>
<a name="ln1243">    default: // camera WB presets</a>
<a name="ln1244">    {</a>
<a name="ln1245">      gboolean found = FALSE;</a>
<a name="ln1246">      // look through all variants of this preset, with different tuning</a>
<a name="ln1247">      for(int i = g-&gt;preset_num[pos]; (i &lt; wb_preset_count)</a>
<a name="ln1248">                                      &amp;&amp; !strcmp(wb_preset[i].make, self-&gt;dev-&gt;image_storage.camera_maker)</a>
<a name="ln1249">                                      &amp;&amp; !strcmp(wb_preset[i].model, self-&gt;dev-&gt;image_storage.camera_model)</a>
<a name="ln1250">                                      &amp;&amp; !strcmp(wb_preset[i].name, wb_preset[g-&gt;preset_num[pos]].name);</a>
<a name="ln1251">          i++)</a>
<a name="ln1252">      {</a>
<a name="ln1253">        if(wb_preset[i].tuning == tune)</a>
<a name="ln1254">        {</a>
<a name="ln1255">          // got exact match!</a>
<a name="ln1256">          for(int k = 0; k &lt; 4; k++) p-&gt;coeffs[k] = wb_preset[i].channel[k];</a>
<a name="ln1257">          found = TRUE;</a>
<a name="ln1258">          break;</a>
<a name="ln1259">        }</a>
<a name="ln1260">      }</a>
<a name="ln1261"> </a>
<a name="ln1262">      if(!found)</a>
<a name="ln1263">      {</a>
<a name="ln1264">        // ok, we haven't found exact match, need to interpolate</a>
<a name="ln1265"> </a>
<a name="ln1266">        // let's find 2 most closest tunings with needed_tuning in-between</a>
<a name="ln1267">        int min_id = INT_MIN, max_id = INT_MIN;</a>
<a name="ln1268"> </a>
<a name="ln1269">        // look through all variants of this preset, with different tuning, starting from second entry (if</a>
<a name="ln1270">        // any)</a>
<a name="ln1271">        int i = g-&gt;preset_num[pos] + 1;</a>
<a name="ln1272">        while((i &lt; wb_preset_count) &amp;&amp; !strcmp(wb_preset[i].make, self-&gt;dev-&gt;image_storage.camera_maker)</a>
<a name="ln1273">              &amp;&amp; !strcmp(wb_preset[i].model, self-&gt;dev-&gt;image_storage.camera_model)</a>
<a name="ln1274">              &amp;&amp; !strcmp(wb_preset[i].name, wb_preset[g-&gt;preset_num[pos]].name))</a>
<a name="ln1275">        {</a>
<a name="ln1276">          if(wb_preset[i - 1].tuning &lt; tune &amp;&amp; wb_preset[i].tuning &gt; tune)</a>
<a name="ln1277">          {</a>
<a name="ln1278">            min_id = i - 1;</a>
<a name="ln1279">            max_id = i;</a>
<a name="ln1280">            break;</a>
<a name="ln1281">          }</a>
<a name="ln1282"> </a>
<a name="ln1283">          i++;</a>
<a name="ln1284">        }</a>
<a name="ln1285"> </a>
<a name="ln1286">        // have we found enough good data?</a>
<a name="ln1287">        if(min_id == INT_MIN || max_id == INT_MIN || min_id == max_id) break; // hysteresis</a>
<a name="ln1288"> </a>
<a name="ln1289">        wb_data interpolated = {.tuning = tune };</a>
<a name="ln1290">        dt_wb_preset_interpolate(&amp;wb_preset[min_id], &amp;wb_preset[max_id], &amp;interpolated);</a>
<a name="ln1291">        for(int k = 0; k &lt; 4; k++) p-&gt;coeffs[k] = interpolated.channel[k];</a>
<a name="ln1292">      }</a>
<a name="ln1293">    }</a>
<a name="ln1294">    break;</a>
<a name="ln1295">  }</a>
<a name="ln1296">  if(self-&gt;off) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self-&gt;off), 1);</a>
<a name="ln1297">  gui_update_from_coeffs(self);</a>
<a name="ln1298">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1299">}</a>
<a name="ln1300"> </a>
<a name="ln1301">static void presets_changed(GtkWidget *widget, gpointer user_data)</a>
<a name="ln1302">{</a>
<a name="ln1303">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1304">  apply_preset(self);</a>
<a name="ln1305">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln1306">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1307">  gtk_widget_set_sensitive(g-&gt;finetune, pos &gt;= DT_IOP_NUM_OF_STD_TEMP_PRESETS);</a>
<a name="ln1308">}</a>
<a name="ln1309"> </a>
<a name="ln1310">static void finetune_changed(GtkWidget *widget, gpointer user_data)</a>
<a name="ln1311">{</a>
<a name="ln1312">  apply_preset((dt_iop_module_t *)user_data);</a>
<a name="ln1313">}</a>
<a name="ln1314"> </a>
<a name="ln1315">static void _iop_color_picker_apply(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1316">{</a>
<a name="ln1317">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1318"> </a>
<a name="ln1319">  // capture gui color picked event.</a>
<a name="ln1320">  if(self-&gt;picked_color_max[0] &lt; self-&gt;picked_color_min[0]) return;</a>
<a name="ln1321">  const float *grayrgb = self-&gt;picked_color;</a>
<a name="ln1322">  //test the newly picked color: if the same as the last, do not process further</a>
<a name="ln1323">  if(grayrgb[0] == old[0] &amp;&amp; grayrgb[1] == old[1] &amp;&amp; grayrgb[2] == old[2] &amp;&amp; grayrgb[3] == old[3]) return;</a>
<a name="ln1324">  for(int k = 0; k &lt; 4; k++) old[k] = grayrgb[k];</a>
<a name="ln1325">  dt_iop_temperature_params_t *p = (dt_iop_temperature_params_t *)self-&gt;params;</a>
<a name="ln1326">  for(int k = 0; k &lt; 4; k++) p-&gt;coeffs[k] = (grayrgb[k] &gt; 0.001f) ? 1.0f / grayrgb[k] : 1.0f;</a>
<a name="ln1327">  // normalize green:</a>
<a name="ln1328">  p-&gt;coeffs[0] /= p-&gt;coeffs[1];</a>
<a name="ln1329">  p-&gt;coeffs[2] /= p-&gt;coeffs[1];</a>
<a name="ln1330">  p-&gt;coeffs[3] /= p-&gt;coeffs[1];</a>
<a name="ln1331">  p-&gt;coeffs[1] = 1.0;</a>
<a name="ln1332">  // clamp</a>
<a name="ln1333">  for(int k = 0; k &lt; 4; k++) p-&gt;coeffs[k] = fmaxf(0.0f, fminf(8.0f, p-&gt;coeffs[k]));</a>
<a name="ln1334"> </a>
<a name="ln1335">  gui_update_from_coeffs(self);</a>
<a name="ln1336">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1337">}</a>
<a name="ln1338"> </a>
<a name="ln1339">static void gui_sliders_update(struct dt_iop_module_t *self)</a>
<a name="ln1340">{</a>
<a name="ln1341">  const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln1342">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1343"> </a>
<a name="ln1344">  if(FILTERS_ARE_CYGM(img-&gt;buf_dsc.filters))</a>
<a name="ln1345">  {</a>
<a name="ln1346">    dt_bauhaus_widget_set_label(g-&gt;scale_r, NULL, _(&quot;green&quot;));</a>
<a name="ln1347">    dt_bauhaus_widget_set_label(g-&gt;scale_g, NULL, _(&quot;magenta&quot;));</a>
<a name="ln1348">    dt_bauhaus_widget_set_label(g-&gt;scale_b, NULL, _(&quot;cyan&quot;));</a>
<a name="ln1349">    dt_bauhaus_widget_set_label(g-&gt;scale_g2, NULL, _(&quot;yellow&quot;));</a>
<a name="ln1350"> </a>
<a name="ln1351">    gtk_box_reorder_child(GTK_BOX(g-&gt;coeff_widgets), g-&gt;scale_b, 0);</a>
<a name="ln1352">    gtk_box_reorder_child(GTK_BOX(g-&gt;coeff_widgets), g-&gt;scale_g2, 1);</a>
<a name="ln1353">    gtk_box_reorder_child(GTK_BOX(g-&gt;coeff_widgets), g-&gt;scale_g, 2);</a>
<a name="ln1354">    gtk_box_reorder_child(GTK_BOX(g-&gt;coeff_widgets), g-&gt;scale_r, 3);</a>
<a name="ln1355">  }</a>
<a name="ln1356">  else</a>
<a name="ln1357">  {</a>
<a name="ln1358">    dt_bauhaus_widget_set_label(g-&gt;scale_r, NULL, _(&quot;red&quot;));</a>
<a name="ln1359">    dt_bauhaus_widget_set_label(g-&gt;scale_g, NULL, _(&quot;green&quot;));</a>
<a name="ln1360">    dt_bauhaus_widget_set_label(g-&gt;scale_b, NULL, _(&quot;blue&quot;));</a>
<a name="ln1361">    dt_bauhaus_widget_set_label(g-&gt;scale_g2, NULL, _(&quot;emerald&quot;));</a>
<a name="ln1362">    gtk_box_reorder_child(GTK_BOX(g-&gt;coeff_widgets), g-&gt;scale_r, 0);</a>
<a name="ln1363">    gtk_box_reorder_child(GTK_BOX(g-&gt;coeff_widgets), g-&gt;scale_g, 1);</a>
<a name="ln1364">    gtk_box_reorder_child(GTK_BOX(g-&gt;coeff_widgets), g-&gt;scale_b, 2);</a>
<a name="ln1365">    gtk_box_reorder_child(GTK_BOX(g-&gt;coeff_widgets), g-&gt;scale_g2, 3);</a>
<a name="ln1366">  }</a>
<a name="ln1367"> </a>
<a name="ln1368">  gtk_widget_set_visible(GTK_WIDGET(g-&gt;scale_g2), (img-&gt;flags &amp; DT_IMAGE_4BAYER));</a>
<a name="ln1369">}</a>
<a name="ln1370"> </a>
<a name="ln1371">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln1372">{</a>
<a name="ln1373">  self-&gt;gui_data = calloc(1, sizeof(dt_iop_temperature_gui_data_t));</a>
<a name="ln1374">  dt_iop_temperature_gui_data_t *g = (dt_iop_temperature_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1375">  dt_iop_temperature_params_t *p = (dt_iop_temperature_params_t *)self-&gt;default_params;</a>
<a name="ln1376"> </a>
<a name="ln1377">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1378">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln1379"> </a>
<a name="ln1380">  g-&gt;stack = gtk_stack_new();</a>
<a name="ln1381">  gtk_stack_set_homogeneous(GTK_STACK(g-&gt;stack), FALSE);</a>
<a name="ln1382">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;stack, TRUE, TRUE, 0);</a>
<a name="ln1383"> </a>
<a name="ln1384">  g-&gt;box_enabled = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln1385"> </a>
<a name="ln1386">  for(int k = 0; k &lt; 4; k++) g-&gt;daylight_wb[k] = 1.0;</a>
<a name="ln1387">  g-&gt;scale_tint</a>
<a name="ln1388">      = dt_bauhaus_slider_new_with_range(self, DT_IOP_LOWEST_TINT, DT_IOP_HIGHEST_TINT, .01, 1.0, 3);</a>
<a name="ln1389">  g-&gt;scale_k = dt_bauhaus_slider_new_with_range(self, DT_IOP_LOWEST_TEMPERATURE, DT_IOP_HIGHEST_TEMPERATURE,</a>
<a name="ln1390">                                                10., 5000.0, 0);</a>
<a name="ln1391"> </a>
<a name="ln1392">  g-&gt;coeff_widgets = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln1393">  g-&gt;scale_r = dt_bauhaus_slider_new_with_range(self, 0.0, 8.0, .001, p-&gt;coeffs[0], 3);</a>
<a name="ln1394">  g-&gt;scale_g = dt_bauhaus_slider_new_with_range(self, 0.0, 8.0, .001, p-&gt;coeffs[1], 3);</a>
<a name="ln1395">  g-&gt;scale_b = dt_bauhaus_slider_new_with_range(self, 0.0, 8.0, .001, p-&gt;coeffs[2], 3);</a>
<a name="ln1396">  g-&gt;scale_g2 = dt_bauhaus_slider_new_with_range(self, 0.0, 8.0, .001, p-&gt;coeffs[3], 3);</a>
<a name="ln1397"> </a>
<a name="ln1398">#if COLORED_SLIDERS</a>
<a name="ln1399">  // reflect actual black body colors for the temperature slider</a>
<a name="ln1400">  const double temp_step = (double)(DT_IOP_HIGHEST_TEMPERATURE - DT_IOP_LOWEST_TEMPERATURE) / (DT_BAUHAUS_SLIDER_MAX_STOPS - 1.0);</a>
<a name="ln1401">  for(int i = 0; i &lt; DT_BAUHAUS_SLIDER_MAX_STOPS; i++)</a>
<a name="ln1402">  {</a>
<a name="ln1403">    const float stop = i / (DT_BAUHAUS_SLIDER_MAX_STOPS - 1.0);</a>
<a name="ln1404">    const double K = DT_IOP_LOWEST_TEMPERATURE + i * temp_step;</a>
<a name="ln1405">    cmsCIEXYZ cmsXYZ = temperature_to_XYZ(K);</a>
<a name="ln1406">    float sRGB[3], XYZ[3] = {cmsXYZ.X, cmsXYZ.Y, cmsXYZ.Z};</a>
<a name="ln1407">    dt_XYZ_to_sRGB_clipped(XYZ, sRGB);</a>
<a name="ln1408">    dt_bauhaus_slider_set_stop(g-&gt;scale_k, stop, sRGB[0], sRGB[1], sRGB[2]);</a>
<a name="ln1409">  }</a>
<a name="ln1410"> </a>
<a name="ln1411">  dt_bauhaus_slider_set_stop(g-&gt;scale_tint, 0.0, 1.0, 0.0, 1.0);</a>
<a name="ln1412">  dt_bauhaus_slider_set_stop(g-&gt;scale_tint, 1.0, 0.0, 1.0, 0.0);</a>
<a name="ln1413">  dt_bauhaus_slider_set_stop(g-&gt;scale_r, 0.0, 0.0, 0.0, 0.0);</a>
<a name="ln1414">  dt_bauhaus_slider_set_stop(g-&gt;scale_r, 1.0, 1.0, 0.0, 0.0);</a>
<a name="ln1415">  dt_bauhaus_slider_set_stop(g-&gt;scale_g, 0.0, 0.0, 0.0, 0.0);</a>
<a name="ln1416">  dt_bauhaus_slider_set_stop(g-&gt;scale_g, 1.0, 0.0, 1.0, 0.0);</a>
<a name="ln1417">  dt_bauhaus_slider_set_stop(g-&gt;scale_b, 0.0, 0.0, 0.0, 0.0);</a>
<a name="ln1418">  dt_bauhaus_slider_set_stop(g-&gt;scale_b, 1.0, 0.0, 0.0, 1.0);</a>
<a name="ln1419">  dt_bauhaus_slider_set_stop(g-&gt;scale_g2, 0.0, 0.0, 0.0, 0.0);</a>
<a name="ln1420">  dt_bauhaus_slider_set_stop(g-&gt;scale_g2, 1.0, 0.0, 1.0, 0.0);</a>
<a name="ln1421">#endif</a>
<a name="ln1422"> </a>
<a name="ln1423">  dt_bauhaus_slider_set_format(g-&gt;scale_k, &quot;%.0fK&quot;);</a>
<a name="ln1424">  dt_bauhaus_widget_set_label(g-&gt;scale_tint, NULL, _(&quot;tint&quot;));</a>
<a name="ln1425">  dt_bauhaus_widget_set_label(g-&gt;scale_k, NULL, _(&quot;temperature&quot;));</a>
<a name="ln1426"> </a>
<a name="ln1427">  gtk_box_pack_start(GTK_BOX(g-&gt;box_enabled), g-&gt;scale_tint, TRUE, TRUE, 0);</a>
<a name="ln1428">  gtk_box_pack_start(GTK_BOX(g-&gt;box_enabled), g-&gt;scale_k, TRUE, TRUE, 0);</a>
<a name="ln1429">  gtk_box_pack_start(GTK_BOX(g-&gt;coeff_widgets), g-&gt;scale_r, TRUE, TRUE, 0);</a>
<a name="ln1430">  gtk_box_pack_start(GTK_BOX(g-&gt;coeff_widgets), g-&gt;scale_g, TRUE, TRUE, 0);</a>
<a name="ln1431">  gtk_box_pack_start(GTK_BOX(g-&gt;coeff_widgets), g-&gt;scale_b, TRUE, TRUE, 0);</a>
<a name="ln1432">  gtk_box_pack_start(GTK_BOX(g-&gt;coeff_widgets), g-&gt;scale_g2, TRUE, TRUE, 0);</a>
<a name="ln1433">  gtk_box_pack_start(GTK_BOX(g-&gt;box_enabled), g-&gt;coeff_widgets, TRUE, TRUE, 0);</a>
<a name="ln1434">  gtk_widget_set_no_show_all(g-&gt;scale_g2, TRUE);</a>
<a name="ln1435"> </a>
<a name="ln1436">  gui_sliders_update(self);</a>
<a name="ln1437"> </a>
<a name="ln1438">  g-&gt;presets = dt_bauhaus_combobox_new(self);</a>
<a name="ln1439">  dt_bauhaus_widget_set_label(g-&gt;presets, NULL, _(&quot;preset&quot;));</a>
<a name="ln1440">  gtk_box_pack_start(GTK_BOX(g-&gt;box_enabled), g-&gt;presets, TRUE, TRUE, 0);</a>
<a name="ln1441">  gtk_widget_set_tooltip_text(g-&gt;presets, _(&quot;choose white balance preset from camera&quot;));</a>
<a name="ln1442"> </a>
<a name="ln1443">  g-&gt;finetune = dt_bauhaus_slider_new_with_range(self, -9.0, 9.0, 1.0, 0.0, 0);</a>
<a name="ln1444">  dt_bauhaus_widget_set_label(g-&gt;finetune, NULL, _(&quot;finetune&quot;));</a>
<a name="ln1445">  dt_bauhaus_slider_set_format(g-&gt;finetune, _(&quot;%.0f mired&quot;));</a>
<a name="ln1446">  // initially doesn't have fine tuning stuff (camera wb)</a>
<a name="ln1447">  gtk_widget_set_sensitive(g-&gt;finetune, FALSE);</a>
<a name="ln1448">  gtk_box_pack_start(GTK_BOX(g-&gt;box_enabled), g-&gt;finetune, TRUE, TRUE, 0);</a>
<a name="ln1449">  gtk_widget_set_tooltip_text(g-&gt;finetune, _(&quot;fine tune white balance preset&quot;));</a>
<a name="ln1450"> </a>
<a name="ln1451">  gtk_widget_show_all(g-&gt;box_enabled);</a>
<a name="ln1452">  gtk_stack_add_named(GTK_STACK(g-&gt;stack), g-&gt;box_enabled, &quot;enabled&quot;);</a>
<a name="ln1453"> </a>
<a name="ln1454">  g-&gt;label_disabled = gtk_label_new(_(&quot;white balance disabled for camera&quot;));</a>
<a name="ln1455">  gtk_widget_set_halign(g-&gt;label_disabled, GTK_ALIGN_START);</a>
<a name="ln1456"> </a>
<a name="ln1457">  gtk_widget_show_all(g-&gt;label_disabled);</a>
<a name="ln1458">  gtk_stack_add_named(GTK_STACK(g-&gt;stack), g-&gt;label_disabled, &quot;disabled&quot;);</a>
<a name="ln1459"> </a>
<a name="ln1460">  gtk_stack_set_visible_child_name(GTK_STACK(g-&gt;stack), self-&gt;hide_enable_button ? &quot;disabled&quot; : &quot;enabled&quot;);</a>
<a name="ln1461"> </a>
<a name="ln1462">  g-&gt;colorpicker = dtgtk_togglebutton_new(dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1463">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;colorpicker), DT_PIXEL_APPLY_DPI(14), DT_PIXEL_APPLY_DPI(14));</a>
<a name="ln1464">  gtk_box_pack_start(GTK_BOX(g-&gt;box_enabled), GTK_WIDGET(g-&gt;colorpicker), FALSE, FALSE, 0);</a>
<a name="ln1465">  g_signal_connect(G_OBJECT(g-&gt;colorpicker), &quot;toggled&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln1466">  gtk_widget_show_all(g-&gt;colorpicker);</a>
<a name="ln1467"> </a>
<a name="ln1468">  dt_iop_init_single_picker(&amp;g-&gt;color_picker,</a>
<a name="ln1469">                     self,</a>
<a name="ln1470">                     GTK_WIDGET(g-&gt;colorpicker),</a>
<a name="ln1471">                     DT_COLOR_PICKER_AREA,</a>
<a name="ln1472">                     _iop_color_picker_apply);</a>
<a name="ln1473"> </a>
<a name="ln1474">  self-&gt;gui_update(self);</a>
<a name="ln1475"> </a>
<a name="ln1476">  g_signal_connect(G_OBJECT(g-&gt;scale_tint), &quot;value-changed&quot;, G_CALLBACK(tint_callback), self);</a>
<a name="ln1477">  g_signal_connect(G_OBJECT(g-&gt;scale_k), &quot;value-changed&quot;, G_CALLBACK(temp_callback), self);</a>
<a name="ln1478">  g_signal_connect(G_OBJECT(g-&gt;scale_r), &quot;value-changed&quot;, G_CALLBACK(rgb_callback), self);</a>
<a name="ln1479">  g_signal_connect(G_OBJECT(g-&gt;scale_g), &quot;value-changed&quot;, G_CALLBACK(rgb_callback), self);</a>
<a name="ln1480">  g_signal_connect(G_OBJECT(g-&gt;scale_b), &quot;value-changed&quot;, G_CALLBACK(rgb_callback), self);</a>
<a name="ln1481">  g_signal_connect(G_OBJECT(g-&gt;scale_g2), &quot;value-changed&quot;, G_CALLBACK(rgb_callback), self);</a>
<a name="ln1482">  g_signal_connect(G_OBJECT(g-&gt;presets), &quot;value-changed&quot;, G_CALLBACK(presets_changed), self);</a>
<a name="ln1483">  g_signal_connect(G_OBJECT(g-&gt;finetune), &quot;value-changed&quot;, G_CALLBACK(finetune_changed), self);</a>
<a name="ln1484">}</a>
<a name="ln1485"> </a>
<a name="ln1486">void gui_reset(struct dt_iop_module_t *self)</a>
<a name="ln1487">{</a>
<a name="ln1488">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1489">  gui_sliders_update(self);</a>
<a name="ln1490">}</a>
<a name="ln1491"> </a>
<a name="ln1492">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln1493">{</a>
<a name="ln1494">  free(self-&gt;gui_data);</a>
<a name="ln1495">  self-&gt;gui_data = NULL;</a>
<a name="ln1496">}</a>
<a name="ln1497"> </a>
<a name="ln1498">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1499">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1500">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="797"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcmp' function will lead to underflow of the buffer 'p->coeffs'.</p></div>
<div class="balloon" rel="797"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcmp' function will lead to underflow of the buffer 'fp->coeffs'.</p></div>
<div class="balloon" rel="819"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !found.</p></div>
<div class="balloon" rel="863"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !found.</p></div>
<div class="balloon" rel="1101"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 1101, 1099.</p></div>
<div class="balloon" rel="1380"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 1380, 1373.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
