
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">http://www.youtube.com/watch?v=JVoUgR6bhBc</a>
<a name="ln3"> */</a>
<a name="ln4"> </a>
<a name="ln5">/*</a>
<a name="ln6">    This file is part of darktable,</a>
<a name="ln7">    copyright (c) 2013 tobias ellinghaus.</a>
<a name="ln8">    copyright (c) 2018 Aur√©lien Pierre.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln11">    it under the terms of the GNU General Public License as published by</a>
<a name="ln12">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln13">    (at your option) any later version.</a>
<a name="ln14"> </a>
<a name="ln15">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln16">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln17">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln18">    GNU General Public License for more details.</a>
<a name="ln19"> </a>
<a name="ln20">    You should have received a copy of the GNU General Public License</a>
<a name="ln21">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln22">*/</a>
<a name="ln23">#ifdef HAVE_CONFIG_H</a>
<a name="ln24">#include &quot;config.h&quot;</a>
<a name="ln25">#endif</a>
<a name="ln26">// our includes go first:</a>
<a name="ln27">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln28">#include &quot;common/exif.h&quot;</a>
<a name="ln29">#include &quot;common/colorspaces_inline_conversions.h&quot;</a>
<a name="ln30">#include &quot;common/opencl.h&quot;</a>
<a name="ln31">#include &quot;develop/blend.h&quot;</a>
<a name="ln32">#include &quot;develop/imageop.h&quot;</a>
<a name="ln33">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln34">#include &quot;dtgtk/gradientslider.h&quot;</a>
<a name="ln35">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln36">#include &quot;gui/gtk.h&quot;</a>
<a name="ln37">#include &quot;gui/presets.h&quot;</a>
<a name="ln38">#include &quot;gui/color_picker_proxy.h&quot;</a>
<a name="ln39">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">//#include &lt;gtk/gtk.h&gt;</a>
<a name="ln42">#include &lt;stdlib.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">// these are not in a state to be useful. but they look nice. too bad i couldn't map the enhanced mode with</a>
<a name="ln45">// negative values to the wheels :(</a>
<a name="ln46">//#define SHOW_COLOR_WHEELS</a>
<a name="ln47"> </a>
<a name="ln48">DT_MODULE_INTROSPECTION(3, dt_iop_colorbalance_params_t)</a>
<a name="ln49"> </a>
<a name="ln50">/*</a>
<a name="ln51"> </a>
<a name="ln52">  Meaning of the values:</a>
<a name="ln53">   0 --&gt; 100%</a>
<a name="ln54">  -1 --&gt;   0%</a>
<a name="ln55">   1 --&gt; 200%</a>
<a name="ln56"> */</a>
<a name="ln57"> </a>
<a name="ln58">typedef enum dt_iop_colorbalance_mode_t</a>
<a name="ln59">{</a>
<a name="ln60">  LIFT_GAMMA_GAIN = 0,</a>
<a name="ln61">  SLOPE_OFFSET_POWER = 1,</a>
<a name="ln62">  LEGACY = 2</a>
<a name="ln63">} dt_iop_colorbalance_mode_t;</a>
<a name="ln64"> </a>
<a name="ln65">typedef enum _colorbalance_channel_t</a>
<a name="ln66">{</a>
<a name="ln67">  CHANNEL_FACTOR = 0,</a>
<a name="ln68">  CHANNEL_RED,</a>
<a name="ln69">  CHANNEL_GREEN,</a>
<a name="ln70">  CHANNEL_BLUE,</a>
<a name="ln71">  CHANNEL_SIZE</a>
<a name="ln72">} _colorbalance_channel_t;</a>
<a name="ln73"> </a>
<a name="ln74">typedef enum _colorbalance_levels_t</a>
<a name="ln75">{</a>
<a name="ln76">  LIFT = 0,</a>
<a name="ln77">  GAMMA,</a>
<a name="ln78">  GAIN,</a>
<a name="ln79">  LEVELS</a>
<a name="ln80">} _colorbalance_levels_t;</a>
<a name="ln81"> </a>
<a name="ln82">typedef enum _controls_t</a>
<a name="ln83">{</a>
<a name="ln84">  HSL,</a>
<a name="ln85">  RGBL,</a>
<a name="ln86">  BOTH</a>
<a name="ln87">} _controls_t;</a>
<a name="ln88"> </a>
<a name="ln89">typedef enum _colorbalance_patch_t</a>
<a name="ln90">{</a>
<a name="ln91">  INVALID,</a>
<a name="ln92">  USER_SELECTED,</a>
<a name="ln93">  AUTO_SELECTED</a>
<a name="ln94">} _colorbalance_patch_t;</a>
<a name="ln95"> </a>
<a name="ln96">typedef enum dt_iop_colorbalance_pickcolor_type_t</a>
<a name="ln97">{</a>
<a name="ln98">  DT_PICKCOLBAL_NONE = 0,</a>
<a name="ln99">  DT_PICKCOLBAL_HUE_LIFT = 1,</a>
<a name="ln100">  DT_PICKCOLBAL_HUE_GAMMA = 2,</a>
<a name="ln101">  DT_PICKCOLBAL_HUE_GAIN = 3,</a>
<a name="ln102">  DT_PICKCOLBAL_LIFT_FACTOR = 4,</a>
<a name="ln103">  DT_PICKCOLBAL_GAMMA_FACTOR = 5,</a>
<a name="ln104">  DT_PICKCOLBAL_GAIN_FACTOR = 6,</a>
<a name="ln105">  DT_PICKCOLBAL_GREY = 7,</a>
<a name="ln106">  DT_PICKCOLBAL_AUTOLUMA = 8,</a>
<a name="ln107">  DT_PICKCOLBAL_AUTOCOLOR = 9</a>
<a name="ln108">} dt_iop_colorbalance_pickcolor_type_t;</a>
<a name="ln109"> </a>
<a name="ln110">typedef struct dt_iop_colorbalance_params_t</a>
<a name="ln111">{</a>
<a name="ln112">  dt_iop_colorbalance_mode_t mode;</a>
<a name="ln113">  float lift[CHANNEL_SIZE], gamma[CHANNEL_SIZE], gain[CHANNEL_SIZE];</a>
<a name="ln114">  float saturation, contrast, grey, saturation_out;</a>
<a name="ln115">} dt_iop_colorbalance_params_t;</a>
<a name="ln116"> </a>
<a name="ln117">typedef struct dt_iop_colorbalance_gui_data_t</a>
<a name="ln118">{</a>
<a name="ln119">  dt_pthread_mutex_t lock;</a>
<a name="ln120">  GtkWidget *master_box;</a>
<a name="ln121">  GtkWidget *mode;</a>
<a name="ln122">  GtkWidget *controls;</a>
<a name="ln123">  GtkWidget *hue_lift, *hue_gamma, *hue_gain;</a>
<a name="ln124">  GtkWidget *sat_lift, *sat_gamma, *sat_gain;</a>
<a name="ln125">  GtkWidget *lift_r, *lift_g, *lift_b, *lift_factor;</a>
<a name="ln126">  GtkWidget *gamma_r, *gamma_g, *gamma_b, *gamma_factor;</a>
<a name="ln127">  GtkWidget *gain_r, *gain_g, *gain_b, *gain_factor;</a>
<a name="ln128">  GtkWidget *saturation, *contrast, *grey, *saturation_out;</a>
<a name="ln129">  GtkWidget *masterbox;</a>
<a name="ln130">  GtkWidget *optim_label;</a>
<a name="ln131">  GtkWidget *auto_luma;</a>
<a name="ln132">  GtkWidget *auto_color;</a>
<a name="ln133">  float color_patches_lift[3];</a>
<a name="ln134">  float color_patches_gamma[3];</a>
<a name="ln135">  float color_patches_gain[3];</a>
<a name="ln136">  _colorbalance_patch_t color_patches_flags[LEVELS];</a>
<a name="ln137">  float luma_patches[LEVELS];</a>
<a name="ln138">  _colorbalance_patch_t luma_patches_flags[LEVELS];</a>
<a name="ln139">  dt_iop_color_picker_t color_picker;</a>
<a name="ln140">} dt_iop_colorbalance_gui_data_t;</a>
<a name="ln141"> </a>
<a name="ln142">typedef struct dt_iop_colorbalance_data_t</a>
<a name="ln143">{</a>
<a name="ln144">  dt_iop_colorbalance_mode_t mode;</a>
<a name="ln145">  float lift[CHANNEL_SIZE], gamma[CHANNEL_SIZE], gain[CHANNEL_SIZE];</a>
<a name="ln146">  float saturation, contrast, grey, saturation_out;</a>
<a name="ln147">} dt_iop_colorbalance_data_t;</a>
<a name="ln148"> </a>
<a name="ln149">typedef struct dt_iop_colorbalance_global_data_t</a>
<a name="ln150">{</a>
<a name="ln151">  int kernel_colorbalance;</a>
<a name="ln152">  int kernel_colorbalance_cdl;</a>
<a name="ln153">  int kernel_colorbalance_lgg;</a>
<a name="ln154">} dt_iop_colorbalance_global_data_t;</a>
<a name="ln155"> </a>
<a name="ln156"> </a>
<a name="ln157">const char *name()</a>
<a name="ln158">{</a>
<a name="ln159">  return _(&quot;color balance&quot;);</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">const char *description()</a>
<a name="ln163">{</a>
<a name="ln164">  return _(&quot;lift/gamma/gain controls as seen in video editors&quot;);</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">int flags()</a>
<a name="ln168">{</a>
<a name="ln169">  return IOP_FLAGS_INCLUDE_IN_STYLES | IOP_FLAGS_SUPPORTS_BLENDING;</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">int default_group()</a>
<a name="ln173">{</a>
<a name="ln174">  return IOP_GROUP_COLOR;</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version, void *new_params,</a>
<a name="ln178">                  const int new_version)</a>
<a name="ln179">{</a>
<a name="ln180">  if(old_version == 1 &amp;&amp; new_version == 3)</a>
<a name="ln181">  {</a>
<a name="ln182">    typedef struct dt_iop_colorbalance_params_v1_t</a>
<a name="ln183">    {</a>
<a name="ln184">      float lift[CHANNEL_SIZE], gamma[CHANNEL_SIZE], gain[CHANNEL_SIZE];</a>
<a name="ln185">    } dt_iop_colorbalance_params_v1_t;</a>
<a name="ln186"> </a>
<a name="ln187">    dt_iop_colorbalance_params_v1_t *o = (dt_iop_colorbalance_params_v1_t *)old_params;</a>
<a name="ln188">    dt_iop_colorbalance_params_t *n = (dt_iop_colorbalance_params_t *)new_params;</a>
<a name="ln189">    dt_iop_colorbalance_params_t *d = (dt_iop_colorbalance_params_t *)self-&gt;default_params;</a>
<a name="ln190"> </a>
<a name="ln191">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln192"> </a>
<a name="ln193">    for(int i = 0; i &lt; CHANNEL_SIZE; i++)</a>
<a name="ln194">    {</a>
<a name="ln195">      n-&gt;lift[i] = o-&gt;lift[i];</a>
<a name="ln196">      n-&gt;gamma[i] = o-&gt;gamma[i];</a>
<a name="ln197">      n-&gt;gain[i] = o-&gt;gain[i];</a>
<a name="ln198">    }</a>
<a name="ln199">    n-&gt;mode = LEGACY;</a>
<a name="ln200">    return 0;</a>
<a name="ln201">  }</a>
<a name="ln202"> </a>
<a name="ln203">  if(old_version == 2 &amp;&amp; new_version == 3)</a>
<a name="ln204">  {</a>
<a name="ln205">    typedef struct dt_iop_colorbalance_params_v2_t</a>
<a name="ln206">    {</a>
<a name="ln207">      dt_iop_colorbalance_mode_t mode;</a>
<a name="ln208">      float lift[CHANNEL_SIZE], gamma[CHANNEL_SIZE], gain[CHANNEL_SIZE];</a>
<a name="ln209">      float saturation, contrast, grey;</a>
<a name="ln210">    } dt_iop_colorbalance_params_v2_t;</a>
<a name="ln211"> </a>
<a name="ln212">    dt_iop_colorbalance_params_v2_t *o = (dt_iop_colorbalance_params_v2_t *)old_params;</a>
<a name="ln213">    dt_iop_colorbalance_params_t *n = (dt_iop_colorbalance_params_t *)new_params;</a>
<a name="ln214">    dt_iop_colorbalance_params_t *d = (dt_iop_colorbalance_params_t *)self-&gt;default_params;</a>
<a name="ln215"> </a>
<a name="ln216">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln217"> </a>
<a name="ln218">    for(int i = 0; i &lt; CHANNEL_SIZE; i++)</a>
<a name="ln219">    {</a>
<a name="ln220">      n-&gt;lift[i] = o-&gt;lift[i];</a>
<a name="ln221">      n-&gt;gamma[i] = o-&gt;gamma[i];</a>
<a name="ln222">      n-&gt;gain[i] = o-&gt;gain[i];</a>
<a name="ln223">    }</a>
<a name="ln224">    n-&gt;mode = o-&gt;mode;</a>
<a name="ln225">    n-&gt;contrast = o-&gt;contrast;</a>
<a name="ln226">    n-&gt;saturation = o-&gt;saturation;</a>
<a name="ln227">    n-&gt;contrast = o-&gt;contrast;</a>
<a name="ln228">    n-&gt;grey = o-&gt;grey;</a>
<a name="ln229">    return 0;</a>
<a name="ln230">  }</a>
<a name="ln231">  return 1;</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234">// taken from denoiseprofile.c</a>
<a name="ln235">static void add_preset(dt_iop_module_so_t *self, const char *name,</a>
<a name="ln236">                       const char *pi, const int version, const char *bpi, const int blendop_version)</a>
<a name="ln237">{</a>
<a name="ln238">  int len, blen;</a>
<a name="ln239">  uint8_t *p  = dt_exif_xmp_decode(pi, strlen(pi), &amp;len);</a>
<a name="ln240">  uint8_t *bp = dt_exif_xmp_decode(bpi, strlen(bpi), &amp;blen);</a>
<a name="ln241">  if(blendop_version != dt_develop_blend_version())</a>
<a name="ln242">  {</a>
<a name="ln243">    // update to current blendop params format</a>
<a name="ln244">    void *bp_new = malloc(sizeof(dt_develop_blend_params_t));</a>
<a name="ln245"> </a>
<a name="ln246">    if(dt_develop_blend_legacy_params_from_so(self, bp, blendop_version, bp_new, dt_develop_blend_version(),</a>
<a name="ln247">      blen) == 0)</a>
<a name="ln248">    {</a>
<a name="ln249">      free(bp);</a>
<a name="ln250">      bp = bp_new;</a>
<a name="ln251">      blen = sizeof(dt_develop_blend_params_t);</a>
<a name="ln252">    }</a>
<a name="ln253">    else</a>
<a name="ln254">    {</a>
<a name="ln255">      free(bp);</a>
<a name="ln256">      free(bp_new);</a>
<a name="ln257">      bp = NULL;</a>
<a name="ln258">    }</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  if(p &amp;&amp; bp)</a>
<a name="ln262">    dt_gui_presets_add_with_blendop(name, self-&gt;op, version, p, len, bp, 1);</a>
<a name="ln263">  free(bp);</a>
<a name="ln264">  free(p);</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">void init_presets(dt_iop_module_so_t *self)</a>
<a name="ln268">{</a>
<a name="ln269">  // these blobs were exported as dtstyle and copied from there:</a>
<a name="ln270">  add_preset(self, _(&quot;split-toning teal-orange (2nd instance)&quot;),</a>
<a name="ln271">             &quot;gz02eJxjZGBg8HhYZX99cYN9kkCDfdCOOnsGhgZ7ruvN9m8CK+yXFNTaz5w50z5PqBku9u9/PVjNv//9jqfP+NgDAHs0HIc=&quot;, 3,</a>
<a name="ln272">             &quot;gz05eJxjZWBgYGUAgRNODFDAzszAxMBQ5cwI4Tow4AUNdkBsD8E3gGwue9x8uB6q8s+c8bEF8Z9Y9Nnt2f3bbluCN03tg/EBIBckVg==&quot;, 8);</a>
<a name="ln273">  add_preset(self, _(&quot;split-toning teal-orange (1st instance)&quot;),</a>
<a name="ln274">             &quot;gz02eJxjZACBBvugHXX2E3fU219f3GAP4n/TqLFvfd1oL8HZaH/2jI/9prn1cLHUtDSwGgaGCY7//tfbAwBRixpm&quot;, 3,</a>
<a name="ln275">             &quot;gz04eJxjZWBgYGUAgRNODFDApgwiq5wZIVyHD4E7bBnwggZ7CIYBRiBbBA8fXT1l/P5DX21i+pnA/Pfv8uw6OzzIMq9I5rgtSH//4wii1AMASbIlcw==&quot;, 8);</a>
<a name="ln276"> </a>
<a name="ln277">  add_preset(self, _(&quot;generic film&quot;),</a>
<a name="ln278">             &quot;gz02eJxjZACBBntN5gb7op/19u5AGsSX3dFgr+jYaL+vttb+0NcM+1Pnq+3XyFTZr/rYBJZPS0sD0hMcQDQA29kXSQ==&quot;, 3,</a>
<a name="ln279">             &quot;gz11eJxjYGBgkGAAgRNODGiAEV0AJ2iwh+CRxQcA5qIZBA==&quot;, 8);</a>
<a name="ln280"> </a>
<a name="ln281">  add_preset(self, _(&quot;similar to Kodak Portra&quot;),</a>
<a name="ln282">             &quot;gz02eJxjZACBBnsQfh3YYK8VU28P43s8rLKP6W+yP/Q1w36deyMYLymoBcsZGxcDaQGHs2d87AGnphWu&quot;, 3,</a>
<a name="ln283">             &quot;gz11eJxjYGBgkGAAgRNODGiAEV0AJ2iwh+CRxQcA5qIZBA==&quot;, 8);</a>
<a name="ln284"> </a>
<a name="ln285">  add_preset(self, _(&quot;similar to Kodak Ektar&quot;),</a>
<a name="ln286">             &quot;gz02eJxjZACBBvvrixvsrXIb7IN21NnD+CA2iOa6nmxvZFxsX15ebp+e1gaWNwbyGRgEHNLS0uwBE7wWhw==&quot;, 3,</a>
<a name="ln287">             &quot;gz11eJxjYGBgkGAAgRNODGiAEV0AJ2iwh+CRxQcA5qIZBA==&quot;, 8);</a>
<a name="ln288"> </a>
<a name="ln289">  add_preset(self, _(&quot;similar to Kodachrome&quot;),</a>
<a name="ln290">             &quot;gz02eJxjZACBBvvrixvsrXIb7IN21NnD+CA2iG59HWhvZFxsX15ebp+e1gaWT0tLA9ICDrNmRtoDACjOF7c=&quot;, 3,</a>
<a name="ln291">             &quot;gz11eJxjYGBgkGAAgRNODGiAEV0AJ2iwh+CRxQcA5qIZBA==&quot;, 8);</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln295">{</a>
<a name="ln296">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;mode&quot;));</a>
<a name="ln297">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;controls&quot;));</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln301">{</a>
<a name="ln302">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln303"> </a>
<a name="ln304">  dt_accel_connect_slider_iop(self, &quot;mode&quot;, GTK_WIDGET(g-&gt;mode));</a>
<a name="ln305">  dt_accel_connect_slider_iop(self, &quot;controls&quot;, GTK_WIDGET(g-&gt;controls));</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">static inline float CDL(float x, float slope, float offset, float power)</a>
<a name="ln309">{</a>
<a name="ln310">  float out;</a>
<a name="ln311">  out = slope * x + offset;</a>
<a name="ln312">  out = (out &lt;= 0.0f) ? 0.0f : powf(out, power);</a>
<a name="ln313">  return out;</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">// see http://www.brucelindbloom.com/Eqn_RGB_XYZ_Matrix.html for the transformation matrices</a>
<a name="ln317">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln318">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln319">{</a>
<a name="ln320">  dt_iop_colorbalance_data_t *d = (dt_iop_colorbalance_data_t *)piece-&gt;data;</a>
<a name="ln321">  const int ch = piece-&gt;colors;</a>
<a name="ln322"> </a>
<a name="ln323">  // these are RGB values!</a>
<a name="ln324">  const float gain[3] = { d-&gt;gain[CHANNEL_RED] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln325">                          d-&gt;gain[CHANNEL_GREEN] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln326">                          d-&gt;gain[CHANNEL_BLUE] * d-&gt;gain[CHANNEL_FACTOR] },</a>
<a name="ln327">              contrast = (d-&gt;contrast != 0.0f) ? 1.0f / d-&gt;contrast : 1000000.0f,</a>
<a name="ln328">              grey = d-&gt;grey / 100.0f;</a>
<a name="ln329"> </a>
<a name="ln330">  // For neutral parameters, skip the computations doing x^1 or (x-a)*1 + a to save time</a>
<a name="ln331">  const int run_contrast = (d-&gt;contrast == 1.0f) ? 0 : 1;</a>
<a name="ln332">  const int run_saturation = (d-&gt;saturation == 1.0f) ? 0: 1;</a>
<a name="ln333">  const int run_saturation_out = (d-&gt;saturation_out == 1.0f) ? 0: 1;</a>
<a name="ln334"> </a>
<a name="ln335">  switch (d-&gt;mode)</a>
<a name="ln336">  {</a>
<a name="ln337">    case LEGACY:</a>
<a name="ln338">    {</a>
<a name="ln339">      // these are RGB values!</a>
<a name="ln340">      const float lift[3] = { 2.0 - (d-&gt;lift[CHANNEL_RED] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln341">                              2.0 - (d-&gt;lift[CHANNEL_GREEN] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln342">                              2.0 - (d-&gt;lift[CHANNEL_BLUE] * d-&gt;lift[CHANNEL_FACTOR]) },</a>
<a name="ln343">                 gamma[3] = { d-&gt;gamma[CHANNEL_RED] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln344">                              d-&gt;gamma[CHANNEL_GREEN] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln345">                              d-&gt;gamma[CHANNEL_BLUE] * d-&gt;gamma[CHANNEL_FACTOR] },</a>
<a name="ln346">             gamma_inv[3] = { (gamma[0] != 0.0) ? 1.0 / gamma[0] : 1000000.0,</a>
<a name="ln347">                              (gamma[1] != 0.0) ? 1.0 / gamma[1] : 1000000.0,</a>
<a name="ln348">                              (gamma[2] != 0.0) ? 1.0 / gamma[2] : 1000000.0 };</a>
<a name="ln349"> </a>
<a name="ln350">#ifdef _OPENMP</a>
<a name="ln351">#pragma omp parallel for SIMD() default(none) shared(d) schedule(static)</a>
<a name="ln352">#endif</a>
<a name="ln353">      for(size_t k = 0; k &lt; (size_t)ch * roi_in-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln354">      {</a>
<a name="ln355">        float *in = ((float *)ivoid) + k;</a>
<a name="ln356">        float *out = ((float *)ovoid) + k;</a>
<a name="ln357"> </a>
<a name="ln358">        // transform the pixel to sRGB:</a>
<a name="ln359">        // Lab -&gt; XYZ</a>
<a name="ln360">        float XYZ[3] = { 0.0f };</a>
<a name="ln361">        dt_Lab_to_XYZ(in, XYZ);</a>
<a name="ln362"> </a>
<a name="ln363">        // XYZ -&gt; sRGB</a>
<a name="ln364">        float rgb[3] = { 0.0f };</a>
<a name="ln365">        dt_XYZ_to_sRGB(XYZ, rgb);</a>
<a name="ln366"> </a>
<a name="ln367">        // do the calculation in RGB space</a>
<a name="ln368">        for(int c = 0; c &lt; 3; c++)</a>
<a name="ln369">        {</a>
<a name="ln370">          // lift gamma gain</a>
<a name="ln371">          rgb[c] = ((( rgb[c]  - 1.0f) * lift[c]) + 1.0f) * gain[c];</a>
<a name="ln372">          rgb[c] = (rgb[c] &lt; 0.0f) ? 0.0f : powf(rgb[c], gamma_inv[c]);</a>
<a name="ln373">        }</a>
<a name="ln374"> </a>
<a name="ln375">        // transform the result back to Lab</a>
<a name="ln376">        // sRGB -&gt; XYZ</a>
<a name="ln377">        dt_sRGB_to_XYZ(rgb, XYZ);</a>
<a name="ln378"> </a>
<a name="ln379">        // XYZ -&gt; Lab</a>
<a name="ln380">        dt_XYZ_to_Lab(XYZ, out);</a>
<a name="ln381">      }</a>
<a name="ln382">      break;</a>
<a name="ln383">    }</a>
<a name="ln384">    case LIFT_GAMMA_GAIN:</a>
<a name="ln385">    {</a>
<a name="ln386">      // these are RGB values!</a>
<a name="ln387">      const float lift[3] = { 2.0 - (d-&gt;lift[CHANNEL_RED] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln388">                              2.0 - (d-&gt;lift[CHANNEL_GREEN] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln389">                              2.0 - (d-&gt;lift[CHANNEL_BLUE] * d-&gt;lift[CHANNEL_FACTOR]) },</a>
<a name="ln390">                 gamma[3] = { d-&gt;gamma[CHANNEL_RED] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln391">                              d-&gt;gamma[CHANNEL_GREEN] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln392">                              d-&gt;gamma[CHANNEL_BLUE] * d-&gt;gamma[CHANNEL_FACTOR] },</a>
<a name="ln393">             gamma_inv[3] = { (gamma[0] != 0.0) ? 1.0 / gamma[0] : 1000000.0,</a>
<a name="ln394">                              (gamma[1] != 0.0) ? 1.0 / gamma[1] : 1000000.0,</a>
<a name="ln395">                              (gamma[2] != 0.0) ? 1.0 / gamma[2] : 1000000.0 };</a>
<a name="ln396"> </a>
<a name="ln397">#ifdef _OPENMP</a>
<a name="ln398">#pragma omp parallel for SIMD() default(none) shared(d) schedule(static)</a>
<a name="ln399">#endif</a>
<a name="ln400">      for(size_t k = 0; k &lt; (size_t)ch * roi_in-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln401">      {</a>
<a name="ln402">        float *in = ((float *)ivoid) + k;</a>
<a name="ln403">        float *out = ((float *)ovoid) + k;</a>
<a name="ln404"> </a>
<a name="ln405">        // transform the pixel to sRGB:</a>
<a name="ln406">        // Lab -&gt; XYZ</a>
<a name="ln407">        float XYZ[3] = { 0.0f };</a>
<a name="ln408">        dt_Lab_to_XYZ(in, XYZ);</a>
<a name="ln409"> </a>
<a name="ln410">        // XYZ -&gt; sRGB</a>
<a name="ln411">        float rgb[3] = { 0.0f };</a>
<a name="ln412">        dt_XYZ_to_prophotorgb(XYZ, rgb);</a>
<a name="ln413"> </a>
<a name="ln414">        float luma = XYZ[1]; // the Y channel is the relative luminance</a>
<a name="ln415"> </a>
<a name="ln416">        // do the calculation in RGB space</a>
<a name="ln417">        for(int c = 0; c &lt; 3; c++)</a>
<a name="ln418">        {</a>
<a name="ln419">          // main saturation input</a>
<a name="ln420">          if (run_saturation) rgb[c] = luma + d-&gt;saturation * (rgb[c] - luma);</a>
<a name="ln421"> </a>
<a name="ln422">          // RGB gamma correction</a>
<a name="ln423">          rgb[c] = (rgb[c] &lt;= 0.0f) ? 0.0f : powf(rgb[c], 1.0f/2.2f);</a>
<a name="ln424"> </a>
<a name="ln425">          // lift gamma gain</a>
<a name="ln426">          rgb[c] = ((( rgb[c]  - 1.0f) * lift[c]) + 1.0f) * gain[c];</a>
<a name="ln427">          rgb[c] = (rgb[c] &lt;= 0.0f) ? 0.0f : powf(rgb[c], gamma_inv[c] * 2.2f);</a>
<a name="ln428">        }</a>
<a name="ln429"> </a>
<a name="ln430">        // main saturation output</a>
<a name="ln431">        if (run_saturation_out)</a>
<a name="ln432">        {</a>
<a name="ln433">          dt_prophotorgb_to_XYZ(rgb, XYZ);</a>
<a name="ln434">          luma = XYZ[1];</a>
<a name="ln435">          for(int c = 0; c &lt; 3; c++) rgb[c] = luma + d-&gt;saturation_out * (rgb[c] - luma);</a>
<a name="ln436">        }</a>
<a name="ln437"> </a>
<a name="ln438">        // fulcrum contrat</a>
<a name="ln439">        if (run_contrast) for(int c = 0; c &lt; 3; c++) rgb[c] = (rgb[c] &lt;= 0.0f) ? 0.0f : powf(rgb[c] / grey, contrast) * grey;</a>
<a name="ln440"> </a>
<a name="ln441">        // transform the result back to Lab</a>
<a name="ln442">        // sRGB -&gt; XYZ</a>
<a name="ln443">        dt_prophotorgb_to_XYZ(rgb, XYZ);</a>
<a name="ln444"> </a>
<a name="ln445">        // XYZ -&gt; Lab</a>
<a name="ln446">        dt_XYZ_to_Lab(XYZ, out);</a>
<a name="ln447">      }</a>
<a name="ln448">      break;</a>
<a name="ln449">   }</a>
<a name="ln450">    case SLOPE_OFFSET_POWER:</a>
<a name="ln451">    {</a>
<a name="ln452">      // these are RGB values!</a>
<a name="ln453"> </a>
<a name="ln454">      const float lift[3] = { ( d-&gt;lift[CHANNEL_RED] + d-&gt;lift[CHANNEL_FACTOR] - 2.0f),</a>
<a name="ln455">                              ( d-&gt;lift[CHANNEL_GREEN] + d-&gt;lift[CHANNEL_FACTOR] - 2.0f),</a>
<a name="ln456">                              ( d-&gt;lift[CHANNEL_BLUE] + d-&gt;lift[CHANNEL_FACTOR] - 2.0f)},</a>
<a name="ln457">                 gamma[3] = { (2.0f - d-&gt;gamma[CHANNEL_RED]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln458">                              (2.0f - d-&gt;gamma[CHANNEL_GREEN]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln459">                              (2.0f - d-&gt;gamma[CHANNEL_BLUE]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR])};</a>
<a name="ln460"> </a>
<a name="ln461">#ifdef _OPENMP</a>
<a name="ln462">#pragma omp parallel for SIMD() default(none) shared(d) schedule(static)</a>
<a name="ln463">#endif</a>
<a name="ln464">      for(size_t k = 0; k &lt; (size_t)ch * roi_in-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln465">      {</a>
<a name="ln466">        float *in = ((float *)ivoid) + k;</a>
<a name="ln467">        float *out = ((float *)ovoid) + k;</a>
<a name="ln468"> </a>
<a name="ln469">        // transform the pixel to RGB:</a>
<a name="ln470">        // Lab -&gt; XYZ</a>
<a name="ln471">        float XYZ[3];</a>
<a name="ln472">        dt_Lab_to_XYZ(in, XYZ);</a>
<a name="ln473"> </a>
<a name="ln474">        // XYZ -&gt; RGB</a>
<a name="ln475">        float rgb[3];</a>
<a name="ln476">        dt_XYZ_to_prophotorgb(XYZ, rgb);</a>
<a name="ln477"> </a>
<a name="ln478">        float luma = XYZ[1]; // the Y channel is the RGB luminance</a>
<a name="ln479"> </a>
<a name="ln480">        // do the calculation in RGB space</a>
<a name="ln481">        for(int c = 0; c &lt; 3; c++)</a>
<a name="ln482">        {</a>
<a name="ln483">          // main saturation input</a>
<a name="ln484">          if (run_saturation) rgb[c] = luma + d-&gt;saturation * (rgb[c] - luma);</a>
<a name="ln485"> </a>
<a name="ln486">          // channel CDL</a>
<a name="ln487">          rgb[c] = CDL(rgb[c], gain[c], lift[c], gamma[c]);</a>
<a name="ln488">        }</a>
<a name="ln489"> </a>
<a name="ln490">        // main saturation output</a>
<a name="ln491">        if (run_saturation_out)</a>
<a name="ln492">        {</a>
<a name="ln493">          dt_prophotorgb_to_XYZ(rgb, XYZ);</a>
<a name="ln494">          luma = XYZ[1];</a>
<a name="ln495">          for(int c = 0; c &lt; 3; c++) rgb[c] = luma + d-&gt;saturation_out * (rgb[c] - luma);</a>
<a name="ln496">        }</a>
<a name="ln497"> </a>
<a name="ln498">        // fulcrum contrat</a>
<a name="ln499">        if (run_contrast) for(int c = 0; c &lt; 3; c++) rgb[c] = (rgb[c] &lt;= 0.0f) ? 0.0f : powf(rgb[c] / grey, contrast) * grey;</a>
<a name="ln500"> </a>
<a name="ln501">        // transform the result back to Lab</a>
<a name="ln502">        // sRGB -&gt; XYZ</a>
<a name="ln503">        dt_prophotorgb_to_XYZ(rgb , XYZ);</a>
<a name="ln504"> </a>
<a name="ln505">        // XYZ -&gt; Lab</a>
<a name="ln506">        dt_XYZ_to_Lab(XYZ, out);</a>
<a name="ln507">      }</a>
<a name="ln508">      break;</a>
<a name="ln509">    }</a>
<a name="ln510">  }</a>
<a name="ln511">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">#if defined(__SSE__)</a>
<a name="ln515">void process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln516">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln517">{</a>
<a name="ln518">  dt_iop_colorbalance_data_t *d = (dt_iop_colorbalance_data_t *)piece-&gt;data;</a>
<a name="ln519">  const int ch = piece-&gt;colors;</a>
<a name="ln520">  const __m128 gain = _mm_setr_ps(d-&gt;gain[CHANNEL_RED] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln521">                                  d-&gt;gain[CHANNEL_GREEN] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln522">                                  d-&gt;gain[CHANNEL_BLUE] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln523">                                  0.0f);</a>
<a name="ln524"> </a>
<a name="ln525">  float contrast_inv = (d-&gt;contrast != 0.0f) ? 1.0f / d-&gt;contrast : 1000000.0f;</a>
<a name="ln526">  const __m128 contrast = _mm_setr_ps(contrast_inv, contrast_inv, contrast_inv, 0.0f);</a>
<a name="ln527">  float grey_corr = d-&gt;grey / 100.0f;</a>
<a name="ln528">  const __m128 grey = _mm_setr_ps(grey_corr, grey_corr, grey_corr, 0.0f);</a>
<a name="ln529">  const __m128 saturation = _mm_setr_ps(d-&gt;saturation, d-&gt;saturation, d-&gt;saturation, 0.0f);</a>
<a name="ln530">  const __m128 saturation_out = _mm_setr_ps(d-&gt;saturation_out, d-&gt;saturation_out, d-&gt;saturation_out, 0.0f);</a>
<a name="ln531">  const __m128 zero = _mm_setzero_ps();</a>
<a name="ln532">  const __m128 one = _mm_set1_ps(1.0);</a>
<a name="ln533"> </a>
<a name="ln534">  // For neutral parameters, skip the computations doing x^1 or (x-a)*1 + a to save time</a>
<a name="ln535">  const int run_contrast = (d-&gt;contrast == 1.0f) ? 0 : 1;</a>
<a name="ln536">  const int run_saturation = (d-&gt;saturation == 1.0f) ? 0: 1;</a>
<a name="ln537">  const int run_saturation_out = (d-&gt;saturation_out == 1.0f) ? 0: 1;</a>
<a name="ln538"> </a>
<a name="ln539">  switch (d-&gt;mode)</a>
<a name="ln540">  {</a>
<a name="ln541">    case LEGACY:</a>
<a name="ln542">    {</a>
<a name="ln543">      // these are RGB values!</a>
<a name="ln544">      const __m128 lift = _mm_setr_ps(2.0 - (d-&gt;lift[CHANNEL_RED] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln545">                                      2.0 - (d-&gt;lift[CHANNEL_GREEN] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln546">                                      2.0 - (d-&gt;lift[CHANNEL_BLUE] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln547">                                      0.0f);</a>
<a name="ln548"> </a>
<a name="ln549">      const __m128 gamma = _mm_setr_ps(d-&gt;gamma[CHANNEL_RED] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln550">                                   d-&gt;gamma[CHANNEL_GREEN] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln551">                                   d-&gt;gamma[CHANNEL_BLUE] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln552">                                   0.0f);</a>
<a name="ln553"> </a>
<a name="ln554">      const __m128 gamma_inv = _mm_setr_ps((gamma[0] != 0.0) ? 1.0 / gamma[0] : 1000000.0,</a>
<a name="ln555">                                       (gamma[1] != 0.0) ? 1.0 / gamma[1] : 1000000.0,</a>
<a name="ln556">                                       (gamma[2] != 0.0) ? 1.0 / gamma[2] : 1000000.0,</a>
<a name="ln557">                                       0.0f);</a>
<a name="ln558"> </a>
<a name="ln559">#ifdef _OPENMP</a>
<a name="ln560">#pragma omp parallel for SIMD() default(none) schedule(static)</a>
<a name="ln561">#endif</a>
<a name="ln562">      for(size_t k = 0; k &lt; (size_t)ch * roi_in-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln563">      {</a>
<a name="ln564">        float *in = ((float *)ivoid) + k;</a>
<a name="ln565">        float *out = ((float *)ovoid) + k;</a>
<a name="ln566"> </a>
<a name="ln567">        // transform the pixel to sRGB:</a>
<a name="ln568">        // Lab -&gt; XYZ</a>
<a name="ln569">        __m128 XYZ = dt_Lab_to_XYZ_sse2(_mm_load_ps(in));</a>
<a name="ln570">        // XYZ -&gt; sRGB</a>
<a name="ln571">        __m128 rgb = dt_XYZ_to_sRGB_sse2(XYZ);</a>
<a name="ln572"> </a>
<a name="ln573">        // do the calculation in RGB space</a>
<a name="ln574">        // regular lift gamma gain</a>
<a name="ln575">        rgb = ((rgb - one) * lift + one) * gain;</a>
<a name="ln576">        rgb = _mm_max_ps(rgb, zero);</a>
<a name="ln577">        rgb = _mm_pow_ps(rgb, gamma_inv);</a>
<a name="ln578"> </a>
<a name="ln579">        // transform the result back to Lab</a>
<a name="ln580">        // sRGB -&gt; XYZ</a>
<a name="ln581">        XYZ = dt_sRGB_to_XYZ_sse2(rgb);</a>
<a name="ln582">        // XYZ -&gt; Lab</a>
<a name="ln583">        _mm_stream_ps(out, dt_XYZ_to_Lab_sse2(XYZ));</a>
<a name="ln584">      }</a>
<a name="ln585">      break;</a>
<a name="ln586">    }</a>
<a name="ln587"> </a>
<a name="ln588">    case LIFT_GAMMA_GAIN:</a>
<a name="ln589">    {</a>
<a name="ln590">      // these are RGB values!</a>
<a name="ln591">      const __m128 lift = _mm_setr_ps(2.0f - (d-&gt;lift[CHANNEL_RED] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln592">                                      2.0f - (d-&gt;lift[CHANNEL_GREEN] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln593">                                      2.0f - (d-&gt;lift[CHANNEL_BLUE] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln594">                                      0.0f);</a>
<a name="ln595">      const __m128 gamma = _mm_setr_ps(d-&gt;gamma[CHANNEL_RED] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln596">                                       d-&gt;gamma[CHANNEL_GREEN] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln597">                                       d-&gt;gamma[CHANNEL_BLUE] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln598">                                       0.0f);</a>
<a name="ln599">      const __m128 gamma_inv = _mm_setr_ps((gamma[0] != 0.0) ? 1.0 / gamma[0] : 1000000.0,</a>
<a name="ln600">                                           (gamma[1] != 0.0) ? 1.0 / gamma[1] : 1000000.0,</a>
<a name="ln601">                                           (gamma[2] != 0.0) ? 1.0 / gamma[2] : 1000000.0,</a>
<a name="ln602">                                           0.0f);</a>
<a name="ln603"> </a>
<a name="ln604">      const __m128 gamma_RGB = _mm_set1_ps(2.2f);</a>
<a name="ln605">      const __m128 gamma_inv_RGB = _mm_set1_ps(1.0f/2.2f);</a>
<a name="ln606"> </a>
<a name="ln607">#ifdef _OPENMP</a>
<a name="ln608">#pragma omp parallel for SIMD()default(none) schedule(static)</a>
<a name="ln609">#endif</a>
<a name="ln610">      for(size_t k = 0; k &lt; (size_t)ch * roi_in-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln611">      {</a>
<a name="ln612">        float *in = ((float *)ivoid) + k;</a>
<a name="ln613">        float *out = ((float *)ovoid) + k;</a>
<a name="ln614"> </a>
<a name="ln615">        // transform the pixel to sRGB:</a>
<a name="ln616">        // Lab -&gt; XYZ</a>
<a name="ln617">        __m128 XYZ = dt_Lab_to_XYZ_sse2(_mm_load_ps(in));</a>
<a name="ln618">        // XYZ -&gt; sRGB</a>
<a name="ln619">        __m128 rgb = dt_XYZ_to_prophotoRGB_sse2(XYZ);</a>
<a name="ln620"> </a>
<a name="ln621">        __m128 luma;</a>
<a name="ln622"> </a>
<a name="ln623">        // adjust main saturation input</a>
<a name="ln624">        if (run_saturation)</a>
<a name="ln625">        {</a>
<a name="ln626">          luma = _mm_set1_ps(XYZ[1]); // the Y channel is the relative luminance</a>
<a name="ln627">          rgb = luma + saturation * (rgb - luma);</a>
<a name="ln628">        }</a>
<a name="ln629"> </a>
<a name="ln630">        // RGB gamma adjustement</a>
<a name="ln631">        rgb = _mm_pow_ps(_mm_max_ps(rgb, zero), gamma_inv_RGB);</a>
<a name="ln632"> </a>
<a name="ln633">        // regular lift gamma gain</a>
<a name="ln634">        rgb = ((rgb - one) * lift + one) * gain;</a>
<a name="ln635">        rgb = _mm_max_ps(rgb, zero);</a>
<a name="ln636">        rgb = _mm_pow_ps(rgb, gamma_inv * gamma_RGB);</a>
<a name="ln637"> </a>
<a name="ln638">        // adjust main saturation output</a>
<a name="ln639">        if (run_saturation_out)</a>
<a name="ln640">        {</a>
<a name="ln641">          XYZ = dt_prophotoRGB_to_XYZ_sse2(rgb);</a>
<a name="ln642">          luma = _mm_set1_ps(XYZ[1]); // the Y channel is the relative luminance</a>
<a name="ln643">          rgb = luma + saturation_out * (rgb - luma);</a>
<a name="ln644">        }</a>
<a name="ln645"> </a>
<a name="ln646">        // fulcrum contrast</a>
<a name="ln647">        if (run_contrast)</a>
<a name="ln648">        {</a>
<a name="ln649">          rgb = _mm_max_ps(rgb, zero);</a>
<a name="ln650">          rgb = _mm_pow_ps(rgb / grey, contrast) * grey;</a>
<a name="ln651">        }</a>
<a name="ln652"> </a>
<a name="ln653">        // transform the result back to Lab</a>
<a name="ln654">        // sRGB -&gt; XYZ</a>
<a name="ln655">        XYZ = dt_prophotoRGB_to_XYZ_sse2(rgb);</a>
<a name="ln656">        // XYZ -&gt; Lab</a>
<a name="ln657">        _mm_stream_ps(out, dt_XYZ_to_Lab_sse2(XYZ));</a>
<a name="ln658">      }</a>
<a name="ln659"> </a>
<a name="ln660">      break;</a>
<a name="ln661">    }</a>
<a name="ln662"> </a>
<a name="ln663">    case SLOPE_OFFSET_POWER:</a>
<a name="ln664">    {</a>
<a name="ln665">      // these are RGB values!</a>
<a name="ln666">      const __m128 lift = _mm_setr_ps((d-&gt;lift[CHANNEL_RED] + d-&gt;lift[CHANNEL_FACTOR] - 2.f),</a>
<a name="ln667">                                      (d-&gt;lift[CHANNEL_GREEN] + d-&gt;lift[CHANNEL_FACTOR] - 2.f),</a>
<a name="ln668">                                      (d-&gt;lift[CHANNEL_BLUE] + d-&gt;lift[CHANNEL_FACTOR] - 2.f),</a>
<a name="ln669">                                      0.0f);</a>
<a name="ln670">      const __m128 gamma = _mm_setr_ps((2.0f - d-&gt;gamma[CHANNEL_RED]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln671">                                      (2.0f - d-&gt;gamma[CHANNEL_GREEN]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln672">                                      (2.0f - d-&gt;gamma[CHANNEL_BLUE]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln673">                                      0.0f);</a>
<a name="ln674"> </a>
<a name="ln675">#ifdef _OPENMP</a>
<a name="ln676">#pragma omp parallel for SIMD() default(none) schedule(static)</a>
<a name="ln677">#endif</a>
<a name="ln678">      for(size_t k = 0; k &lt; (size_t)ch * roi_in-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln679">      {</a>
<a name="ln680">        float *in = ((float *)ivoid) + k;</a>
<a name="ln681">        float *out = ((float *)ovoid) + k;</a>
<a name="ln682"> </a>
<a name="ln683">        // transform the pixel to sRGB:</a>
<a name="ln684">        // Lab -&gt; XYZ</a>
<a name="ln685">        __m128 XYZ = dt_Lab_to_XYZ_sse2(_mm_load_ps(in));</a>
<a name="ln686">        // XYZ -&gt; sRGB</a>
<a name="ln687">        __m128 rgb = dt_XYZ_to_prophotoRGB_sse2(XYZ);</a>
<a name="ln688"> </a>
<a name="ln689">        __m128 luma;</a>
<a name="ln690"> </a>
<a name="ln691">        // adjust main saturation</a>
<a name="ln692">        if (run_saturation)</a>
<a name="ln693">        {</a>
<a name="ln694">          luma = _mm_set1_ps(XYZ[1]); // the Y channel is the relative luminance</a>
<a name="ln695">          rgb = luma + saturation * (rgb - luma);</a>
<a name="ln696">        }</a>
<a name="ln697"> </a>
<a name="ln698">        // slope offset</a>
<a name="ln699">        rgb = rgb * gain + lift;</a>
<a name="ln700"> </a>
<a name="ln701">        //power</a>
<a name="ln702">        rgb = _mm_max_ps(rgb, zero);</a>
<a name="ln703">        rgb = _mm_pow_ps(rgb, gamma);</a>
<a name="ln704"> </a>
<a name="ln705">        // adjust main saturation output</a>
<a name="ln706">        if (run_saturation_out)</a>
<a name="ln707">        {</a>
<a name="ln708">          XYZ = dt_prophotoRGB_to_XYZ_sse2(rgb);</a>
<a name="ln709">          luma = _mm_set1_ps(XYZ[1]); // the Y channel is the relative luminance</a>
<a name="ln710">          rgb = luma + saturation_out * (rgb - luma);</a>
<a name="ln711">        }</a>
<a name="ln712"> </a>
<a name="ln713">        // fulcrum contrast</a>
<a name="ln714">        if (run_contrast)</a>
<a name="ln715">        {</a>
<a name="ln716">          rgb = _mm_max_ps(rgb, zero);</a>
<a name="ln717">          rgb = _mm_pow_ps(rgb / grey, contrast) * grey;</a>
<a name="ln718">        }</a>
<a name="ln719"> </a>
<a name="ln720">        // transform the result back to Lab</a>
<a name="ln721">        // sRGB -&gt; XYZ</a>
<a name="ln722">        XYZ = dt_prophotoRGB_to_XYZ_sse2(rgb);</a>
<a name="ln723">        // XYZ -&gt; Lab</a>
<a name="ln724">        _mm_stream_ps(out, dt_XYZ_to_Lab_sse2(XYZ));</a>
<a name="ln725">      }</a>
<a name="ln726">      break;</a>
<a name="ln727">    }</a>
<a name="ln728">  }</a>
<a name="ln729">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln730">}</a>
<a name="ln731">#endif</a>
<a name="ln732"> </a>
<a name="ln733">#ifdef HAVE_OPENCL</a>
<a name="ln734">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln735">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln736">{</a>
<a name="ln737">  dt_iop_colorbalance_data_t *d = (dt_iop_colorbalance_data_t *)piece-&gt;data;</a>
<a name="ln738">  dt_iop_colorbalance_global_data_t *gd = (dt_iop_colorbalance_global_data_t *)self-&gt;data;</a>
<a name="ln739"> </a>
<a name="ln740">  cl_int err = -999;</a>
<a name="ln741">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln742">  const int width = roi_in-&gt;width;</a>
<a name="ln743">  const int height = roi_in-&gt;height;</a>
<a name="ln744">  size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln745"> </a>
<a name="ln746">  switch (d-&gt;mode)</a>
<a name="ln747">  {</a>
<a name="ln748">    case LEGACY:</a>
<a name="ln749">    {</a>
<a name="ln750">      const float lift[4] = { 2.0f - (d-&gt;lift[CHANNEL_RED] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln751">                              2.0f - (d-&gt;lift[CHANNEL_GREEN] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln752">                              2.0f - (d-&gt;lift[CHANNEL_BLUE] * d-&gt;lift[CHANNEL_FACTOR]), 0.0f },</a>
<a name="ln753">                  gamma[4] = { d-&gt;gamma[CHANNEL_RED] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln754">                               d-&gt;gamma[CHANNEL_GREEN] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln755">                               d-&gt;gamma[CHANNEL_BLUE] * d-&gt;gamma[CHANNEL_FACTOR], 0.0f },</a>
<a name="ln756">                  gamma_inv[4] = { (gamma[0] != 0.0f) ? 1.0f / gamma[0] : 1000000.0f,</a>
<a name="ln757">                                   (gamma[1] != 0.0f) ? 1.0f / gamma[1] : 1000000.0f,</a>
<a name="ln758">                                   (gamma[2] != 0.0f) ? 1.0f / gamma[2] : 1000000.0f, 0.0f },</a>
<a name="ln759">                  gain[4] = { d-&gt;gain[CHANNEL_RED] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln760">                              d-&gt;gain[CHANNEL_GREEN] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln761">                              d-&gt;gain[CHANNEL_BLUE] * d-&gt;gain[CHANNEL_FACTOR], 0.0f },</a>
<a name="ln762">                  contrast = (d-&gt;contrast != 0.0f) ? 1.0f / d-&gt;contrast : 1000000.0f,</a>
<a name="ln763">                  grey = d-&gt;grey / 100.0f,</a>
<a name="ln764">                  saturation = d-&gt;saturation;</a>
<a name="ln765"> </a>
<a name="ln766">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln767">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln768">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln769">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln770">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 4, 4 * sizeof(float), (void *)&amp;lift);</a>
<a name="ln771">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 5, 4 * sizeof(float), (void *)&amp;gain);</a>
<a name="ln772">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 6, 4 * sizeof(float), (void *)&amp;gamma_inv);</a>
<a name="ln773">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 7, sizeof(float), (void *)&amp;saturation);</a>
<a name="ln774">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 8, sizeof(float), (void *)&amp;contrast);</a>
<a name="ln775">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 9, sizeof(float), (void *)&amp;grey);</a>
<a name="ln776">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_colorbalance, sizes);</a>
<a name="ln777">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln778">      return TRUE;</a>
<a name="ln779"> </a>
<a name="ln780">      break;</a>
<a name="ln781">    }</a>
<a name="ln782">    case LIFT_GAMMA_GAIN:</a>
<a name="ln783">    {</a>
<a name="ln784">      const float lift[4] = { 2.0f - (d-&gt;lift[CHANNEL_RED] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln785">                              2.0f - (d-&gt;lift[CHANNEL_GREEN] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln786">                              2.0f - (d-&gt;lift[CHANNEL_BLUE] * d-&gt;lift[CHANNEL_FACTOR]), 0.0f },</a>
<a name="ln787">                  gamma[4] = { d-&gt;gamma[CHANNEL_RED] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln788">                               d-&gt;gamma[CHANNEL_GREEN] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln789">                               d-&gt;gamma[CHANNEL_BLUE] * d-&gt;gamma[CHANNEL_FACTOR], 0.0f },</a>
<a name="ln790">                  gamma_inv[4] = { (gamma[0] != 0.0f) ? 1.0f / gamma[0] : 1000000.0f,</a>
<a name="ln791">                                   (gamma[1] != 0.0f) ? 1.0f / gamma[1] : 1000000.0f,</a>
<a name="ln792">                                   (gamma[2] != 0.0f) ? 1.0f / gamma[2] : 1000000.0f, 0.0f },</a>
<a name="ln793">                  gain[4] = { d-&gt;gain[CHANNEL_RED] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln794">                              d-&gt;gain[CHANNEL_GREEN] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln795">                              d-&gt;gain[CHANNEL_BLUE] * d-&gt;gain[CHANNEL_FACTOR], 0.0f },</a>
<a name="ln796">                  contrast = (d-&gt;contrast != 0.0f) ? 1.0f / d-&gt;contrast : 1000000.0f,</a>
<a name="ln797">                  grey = d-&gt;grey / 100.0f,</a>
<a name="ln798">                  saturation = d-&gt;saturation,</a>
<a name="ln799">                  saturation_out = d-&gt;saturation_out;</a>
<a name="ln800"> </a>
<a name="ln801">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln802">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln803">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln804">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln805">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 4, 4 * sizeof(float), (void *)&amp;lift);</a>
<a name="ln806">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 5, 4 * sizeof(float), (void *)&amp;gain);</a>
<a name="ln807">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 6, 4 * sizeof(float), (void *)&amp;gamma_inv);</a>
<a name="ln808">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 7, sizeof(float), (void *)&amp;saturation);</a>
<a name="ln809">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 8, sizeof(float), (void *)&amp;contrast);</a>
<a name="ln810">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 9, sizeof(float), (void *)&amp;grey);</a>
<a name="ln811">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 10, sizeof(float), (void *)&amp;saturation_out);</a>
<a name="ln812">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_colorbalance_lgg, sizes);</a>
<a name="ln813">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln814">      return TRUE;</a>
<a name="ln815"> </a>
<a name="ln816">      break;</a>
<a name="ln817">    }</a>
<a name="ln818">    case SLOPE_OFFSET_POWER:</a>
<a name="ln819">    {</a>
<a name="ln820">      const float lift[4] = { ( d-&gt;lift[CHANNEL_RED] + d-&gt;lift[CHANNEL_FACTOR] - 2.0f ),</a>
<a name="ln821">                              ( d-&gt;lift[CHANNEL_GREEN] + d-&gt;lift[CHANNEL_FACTOR] - 2.0f ),</a>
<a name="ln822">                              ( d-&gt;lift[CHANNEL_BLUE] + d-&gt;lift[CHANNEL_FACTOR] - 2.0f ),</a>
<a name="ln823">                              0.0f },</a>
<a name="ln824">                  gamma[4] = { (2.0f - d-&gt;gamma[CHANNEL_RED]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln825">                               (2.0f - d-&gt;gamma[CHANNEL_GREEN]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln826">                               (2.0f - d-&gt;gamma[CHANNEL_BLUE]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln827">                               0.0f },</a>
<a name="ln828">                  gain[4] = { d-&gt;gain[CHANNEL_RED] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln829">                              d-&gt;gain[CHANNEL_GREEN] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln830">                              d-&gt;gain[CHANNEL_BLUE] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln831">                              0.0f },</a>
<a name="ln832">                  contrast = (d-&gt;contrast != 0.0f) ? 1.0f / d-&gt;contrast : 1000000.0f,</a>
<a name="ln833">                  grey = d-&gt;grey / 100.0f,</a>
<a name="ln834">                  saturation = d-&gt;saturation,</a>
<a name="ln835">                  saturation_out = d-&gt;saturation_out;</a>
<a name="ln836"> </a>
<a name="ln837">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln838">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln839">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln840">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln841">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 4, 4 * sizeof(float), (void *)&amp;lift);</a>
<a name="ln842">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 5, 4 * sizeof(float), (void *)&amp;gain);</a>
<a name="ln843">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 6, 4 * sizeof(float), (void *)&amp;gamma);</a>
<a name="ln844">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 7, sizeof(float), (void *)&amp;saturation);</a>
<a name="ln845">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 8, sizeof(float), (void *)&amp;contrast);</a>
<a name="ln846">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 9, sizeof(float), (void *)&amp;grey);</a>
<a name="ln847">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 10, sizeof(float), (void *)&amp;saturation_out);</a>
<a name="ln848">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_colorbalance_cdl, sizes);</a>
<a name="ln849">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln850">      return TRUE;</a>
<a name="ln851"> </a>
<a name="ln852">      break;</a>
<a name="ln853">    }</a>
<a name="ln854">  }</a>
<a name="ln855"> </a>
<a name="ln856">error:</a>
<a name="ln857">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_colorbalance] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln858">  return FALSE;</a>
<a name="ln859">}</a>
<a name="ln860">#endif</a>
<a name="ln861"> </a>
<a name="ln862">static inline void update_saturation_slider_color(GtkWidget *slider, float hue)</a>
<a name="ln863">{</a>
<a name="ln864">  float rgb[3];</a>
<a name="ln865">  if(hue != -1)</a>
<a name="ln866">  {</a>
<a name="ln867">    hsl2rgb(rgb, hue, 1.0, 0.5);</a>
<a name="ln868">    dt_bauhaus_slider_set_stop(slider, 1.0, rgb[0], rgb[1], rgb[2]);</a>
<a name="ln869">    hsl2rgb(rgb, hue, 0.0, 0.5);</a>
<a name="ln870">    dt_bauhaus_slider_set_stop(slider, 0.0, rgb[0], rgb[1], rgb[2]);</a>
<a name="ln871">    gtk_widget_queue_draw(GTK_WIDGET(slider));</a>
<a name="ln872">  }</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">static inline void set_RGB_sliders(GtkWidget *R, GtkWidget *G, GtkWidget *B, float hsl[3], float *p, int mode)</a>
<a name="ln876">{</a>
<a name="ln877"> </a>
<a name="ln878">  float rgb[3] = { 0.0f };</a>
<a name="ln879">  hsl2rgb(rgb, hsl[0], hsl[1], hsl[2]);</a>
<a name="ln880"> </a>
<a name="ln881">  if(hsl[0] != -1)</a>
<a name="ln882">  {</a>
<a name="ln883">    p[CHANNEL_RED] = rgb[0] * 2.0f;</a>
<a name="ln884">    p[CHANNEL_GREEN] = rgb[1] * 2.0f;</a>
<a name="ln885">    p[CHANNEL_BLUE] = rgb[2] * 2.0f;</a>
<a name="ln886"> </a>
<a name="ln887">    darktable.gui-&gt;reset = 1;</a>
<a name="ln888">    dt_bauhaus_slider_set_soft(R, p[CHANNEL_RED] - 1.0f);</a>
<a name="ln889">    dt_bauhaus_slider_set_soft(G, p[CHANNEL_GREEN] - 1.0f);</a>
<a name="ln890">    dt_bauhaus_slider_set_soft(B, p[CHANNEL_BLUE] - 1.0f);</a>
<a name="ln891">    darktable.gui-&gt;reset = 0;</a>
<a name="ln892">  }</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895">static inline void set_HSL_sliders(GtkWidget *hue, GtkWidget *sat, float RGB[4])</a>
<a name="ln896">{</a>
<a name="ln897">  /** HSL sliders are set from the RGB values at any time.</a>
<a name="ln898">  * Only the RGB values are saved and used in the computations.</a>
<a name="ln899">  * The HSL sliders are merely an interface.</a>
<a name="ln900">  */</a>
<a name="ln901">  float RGB_norm[3] = { (RGB[CHANNEL_RED] / 2.0f), (RGB[CHANNEL_GREEN] / 2.0f), (RGB[CHANNEL_BLUE] / 2.0f) };</a>
<a name="ln902"> </a>
<a name="ln903">  float h, s, l;</a>
<a name="ln904">  rgb2hsl(RGB_norm, &amp;h, &amp;s, &amp;l);</a>
<a name="ln905"> </a>
<a name="ln906">  if(h != -1.0f)</a>
<a name="ln907">  {</a>
<a name="ln908">    dt_bauhaus_slider_set_soft(hue, h * 360.0f);</a>
<a name="ln909">    dt_bauhaus_slider_set_soft(sat, s * 100.0f);</a>
<a name="ln910">    update_saturation_slider_color(GTK_WIDGET(sat), h);</a>
<a name="ln911">    gtk_widget_queue_draw(GTK_WIDGET(sat));</a>
<a name="ln912">  }</a>
<a name="ln913">  else</a>
<a name="ln914">  {</a>
<a name="ln915">    dt_bauhaus_slider_set_soft(hue, -1.0f);</a>
<a name="ln916">    dt_bauhaus_slider_set_soft(sat, 0.0f);</a>
<a name="ln917">    gtk_widget_queue_draw(GTK_WIDGET(sat));</a>
<a name="ln918">  }</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921">static inline void _check_tuner_picker_labels(dt_iop_module_t *self)</a>
<a name="ln922">{</a>
<a name="ln923">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln924"> </a>
<a name="ln925">  if(g-&gt;luma_patches_flags[GAIN] == USER_SELECTED &amp;&amp; g-&gt;luma_patches_flags[GAMMA] == USER_SELECTED</a>
<a name="ln926">     &amp;&amp; g-&gt;luma_patches_flags[LIFT] == USER_SELECTED)</a>
<a name="ln927">    dt_bauhaus_widget_set_label(g-&gt;auto_luma, NULL, _(&quot;optimize luma from patches&quot;));</a>
<a name="ln928">  else</a>
<a name="ln929">    dt_bauhaus_widget_set_label(g-&gt;auto_luma, NULL, _(&quot;optimize luma&quot;));</a>
<a name="ln930"> </a>
<a name="ln931">  if(g-&gt;color_patches_flags[GAIN] == USER_SELECTED &amp;&amp; g-&gt;color_patches_flags[GAMMA] == USER_SELECTED</a>
<a name="ln932">     &amp;&amp; g-&gt;color_patches_flags[LIFT] == USER_SELECTED)</a>
<a name="ln933">    dt_bauhaus_widget_set_label(g-&gt;auto_color, NULL, _(&quot;neutralize colors from patches&quot;));</a>
<a name="ln934">  else</a>
<a name="ln935">    dt_bauhaus_widget_set_label(g-&gt;auto_color, NULL, _(&quot;neutralize colors&quot;));</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938"> </a>
<a name="ln939">static void apply_autogrey(dt_iop_module_t *self)</a>
<a name="ln940">{</a>
<a name="ln941">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln942">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln943">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln944"> </a>
<a name="ln945">  float XYZ[3] = { 0.0f };</a>
<a name="ln946">  float rgb[3] = { 0.0f };</a>
<a name="ln947">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln948">  dt_XYZ_to_prophotorgb((const float *)XYZ, rgb);</a>
<a name="ln949"> </a>
<a name="ln950">  const float lift[3]</a>
<a name="ln951">      = { (p-&gt;lift[CHANNEL_RED] + p-&gt;lift[CHANNEL_FACTOR] - 2.0f),</a>
<a name="ln952">          (p-&gt;lift[CHANNEL_GREEN] + p-&gt;lift[CHANNEL_FACTOR] - 2.0f),</a>
<a name="ln953">          (p-&gt;lift[CHANNEL_BLUE] + p-&gt;lift[CHANNEL_FACTOR] - 2.0f) },</a>
<a name="ln954">      gamma[3]</a>
<a name="ln955">      = { p-&gt;gamma[CHANNEL_RED] * p-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln956">          p-&gt;gamma[CHANNEL_GREEN] * p-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln957">          p-&gt;gamma[CHANNEL_BLUE] * p-&gt;gamma[CHANNEL_FACTOR] },</a>
<a name="ln958">      gain[3] = { p-&gt;gain[CHANNEL_RED] * p-&gt;gain[CHANNEL_FACTOR], p-&gt;gain[CHANNEL_GREEN] * p-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln959">                  p-&gt;gain[CHANNEL_BLUE] * p-&gt;gain[CHANNEL_FACTOR] };</a>
<a name="ln960"> </a>
<a name="ln961">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln962">  {</a>
<a name="ln963">    rgb[c] = CDL(rgb[c], gain[c], lift[c], 2.0f - gamma[c]);</a>
<a name="ln964">    rgb[c] = CLAMP(rgb[c], 0.0f, 1.0f);</a>
<a name="ln965">  }</a>
<a name="ln966"> </a>
<a name="ln967">  dt_prophotorgb_to_XYZ((const float *)rgb, XYZ);</a>
<a name="ln968"> </a>
<a name="ln969">  p-&gt;grey = XYZ[1] * 100.0f;</a>
<a name="ln970"> </a>
<a name="ln971">  darktable.gui-&gt;reset = 1;</a>
<a name="ln972">  dt_bauhaus_slider_set_soft(g-&gt;grey, p-&gt;grey);</a>
<a name="ln973">  darktable.gui-&gt;reset = 0;</a>
<a name="ln974"> </a>
<a name="ln975">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978">static void apply_lift_neutralize(dt_iop_module_t *self)</a>
<a name="ln979">{</a>
<a name="ln980">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln981">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln982">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln983"> </a>
<a name="ln984">  float XYZ[3] = { 0.0f };</a>
<a name="ln985">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln986">  float RGB[3] = { 0.0f };</a>
<a name="ln987">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln988"> </a>
<a name="ln989">// Save the patch color for the optimization</a>
<a name="ln990">  for(int c = 0; c &lt; 3; ++c) g-&gt;color_patches_lift[c] = RGB[c];</a>
<a name="ln991">  g-&gt;color_patches_flags[LIFT] = USER_SELECTED;</a>
<a name="ln992"> </a>
<a name="ln993">  // Compute the RGB values after the CDL factors</a>
<a name="ln994">  for(int c = 0; c &lt; 3; ++c)</a>
<a name="ln995">    RGB[c] = CDL(RGB[c], p-&gt;gain[CHANNEL_FACTOR], p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 2.0f - p-&gt;gamma[CHANNEL_FACTOR]);</a>
<a name="ln996"> </a>
<a name="ln997">  // Compute the luminance of the average grey</a>
<a name="ln998">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln999"> </a>
<a name="ln1000">  // Get the parameter</a>
<a name="ln1001">  for(int c = 0; c &lt; 3; ++c) RGB[c] = powf(XYZ[1], 1.0f/(2.0f - p-&gt;gamma[c+1])) - RGB[c] * p-&gt;gain[c+1];</a>
<a name="ln1002"> </a>
<a name="ln1003">  p-&gt;lift[CHANNEL_RED] = RGB[0] + 1.0f;</a>
<a name="ln1004">  p-&gt;lift[CHANNEL_GREEN] = RGB[1] + 1.0f;</a>
<a name="ln1005">  p-&gt;lift[CHANNEL_BLUE] = RGB[2] + 1.0f;</a>
<a name="ln1006"> </a>
<a name="ln1007">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1008">  dt_bauhaus_slider_set_soft(g-&gt;lift_r, RGB[0]);</a>
<a name="ln1009">  dt_bauhaus_slider_set_soft(g-&gt;lift_g, RGB[1]);</a>
<a name="ln1010">  dt_bauhaus_slider_set_soft(g-&gt;lift_b, RGB[2]);</a>
<a name="ln1011">  set_HSL_sliders(g-&gt;hue_lift, g-&gt;sat_lift, p-&gt;lift);</a>
<a name="ln1012">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1013"> </a>
<a name="ln1014">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1015">}</a>
<a name="ln1016"> </a>
<a name="ln1017">static void apply_gamma_neutralize(dt_iop_module_t *self)</a>
<a name="ln1018">{</a>
<a name="ln1019">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1020">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1021">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1022"> </a>
<a name="ln1023">  float XYZ[3] = { 0.0f };</a>
<a name="ln1024">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln1025">  float RGB[3] = { 0.0f };</a>
<a name="ln1026">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1027"> </a>
<a name="ln1028">// Save the patch color for the optimization</a>
<a name="ln1029">  for(int c = 0; c &lt; 3; ++c) g-&gt;color_patches_gamma[c] = RGB[c];</a>
<a name="ln1030">  g-&gt;color_patches_flags[GAMMA] = USER_SELECTED;</a>
<a name="ln1031"> </a>
<a name="ln1032">  // Compute the RGB values after the CDL factors</a>
<a name="ln1033">  for(int c = 0; c &lt; 3; ++c)</a>
<a name="ln1034">    RGB[c] = CDL(RGB[c], p-&gt;gain[CHANNEL_FACTOR], p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 2.0f - p-&gt;gamma[CHANNEL_FACTOR]);</a>
<a name="ln1035"> </a>
<a name="ln1036">  // Compute the luminance of the average grey</a>
<a name="ln1037">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1038"> </a>
<a name="ln1039">  // Get the parameter</a>
<a name="ln1040">  for(int c = 0; c &lt; 3; ++c) RGB[c] = logf(XYZ[1])/ logf(RGB[c] * p-&gt;gain[c + 1] + p-&gt;lift[c + 1] - 1.0f);</a>
<a name="ln1041"> </a>
<a name="ln1042">  p-&gt;gamma[CHANNEL_RED] = CLAMP(2.0 - RGB[0], 0.0001f, 2.0f);</a>
<a name="ln1043">  p-&gt;gamma[CHANNEL_GREEN] = CLAMP(2.0 - RGB[1], 0.0001f, 2.0f);</a>
<a name="ln1044">  p-&gt;gamma[CHANNEL_BLUE] = CLAMP(2.0 - RGB[2], 0.0001f, 2.0f);</a>
<a name="ln1045"> </a>
<a name="ln1046">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1047">  dt_bauhaus_slider_set_soft(g-&gt;gamma_r, -RGB[0] + 1.0f);</a>
<a name="ln1048">  dt_bauhaus_slider_set_soft(g-&gt;gamma_g, -RGB[1] + 1.0f);</a>
<a name="ln1049">  dt_bauhaus_slider_set_soft(g-&gt;gamma_b, -RGB[2] + 1.0f);</a>
<a name="ln1050">  set_HSL_sliders(g-&gt;hue_gamma, g-&gt;sat_gamma, p-&gt;gamma);</a>
<a name="ln1051">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1052"> </a>
<a name="ln1053">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1054">}</a>
<a name="ln1055"> </a>
<a name="ln1056">static void apply_gain_neutralize(dt_iop_module_t *self)</a>
<a name="ln1057">{</a>
<a name="ln1058">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1059">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1060">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1061"> </a>
<a name="ln1062">  float XYZ[3] = { 0.0f };</a>
<a name="ln1063">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln1064">  float RGB[3] = { 0.0f };</a>
<a name="ln1065">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1066"> </a>
<a name="ln1067">// Save the patch color for the optimization</a>
<a name="ln1068">  for(int c = 0; c &lt; 3; c++) g-&gt;color_patches_gain[c] = RGB[c];</a>
<a name="ln1069">  g-&gt;color_patches_flags[GAIN] = USER_SELECTED;</a>
<a name="ln1070"> </a>
<a name="ln1071">  // Compute the RGB values after the CDL factors</a>
<a name="ln1072">  for(int c = 0; c &lt; 3; ++c)</a>
<a name="ln1073">    RGB[c] = CDL(RGB[c], p-&gt;gain[CHANNEL_FACTOR], p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 2.0f - p-&gt;gamma[CHANNEL_FACTOR]);</a>
<a name="ln1074"> </a>
<a name="ln1075">  // Compute the luminance of the average grey</a>
<a name="ln1076">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1077"> </a>
<a name="ln1078">  // Get the parameter</a>
<a name="ln1079">  for(int c = 0; c &lt; 3; ++c) RGB[c] = (powf(XYZ[1], 1.0f/(2.0f - p-&gt;gamma[c+1])) - p-&gt;lift[c+1] + 1.0f) / MAX(RGB[c], 0.000001f);</a>
<a name="ln1080"> </a>
<a name="ln1081">  p-&gt;gain[CHANNEL_RED] = RGB[0];</a>
<a name="ln1082">  p-&gt;gain[CHANNEL_GREEN] = RGB[1];</a>
<a name="ln1083">  p-&gt;gain[CHANNEL_BLUE] = RGB[2];</a>
<a name="ln1084"> </a>
<a name="ln1085">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1086">  dt_bauhaus_slider_set_soft(g-&gt;gain_r, RGB[0] - 1.0f);</a>
<a name="ln1087">  dt_bauhaus_slider_set_soft(g-&gt;gain_g, RGB[1] - 1.0f);</a>
<a name="ln1088">  dt_bauhaus_slider_set_soft(g-&gt;gain_b, RGB[2] - 1.0f);</a>
<a name="ln1089">  set_HSL_sliders(g-&gt;hue_gain, g-&gt;sat_gain, p-&gt;gain);</a>
<a name="ln1090">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1091"> </a>
<a name="ln1092">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">static void apply_lift_auto(dt_iop_module_t *self)</a>
<a name="ln1096">{</a>
<a name="ln1097">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1098">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1099">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1100"> </a>
<a name="ln1101">  float XYZ[3] = { 0.0f };</a>
<a name="ln1102">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color_min, XYZ);</a>
<a name="ln1103"> </a>
<a name="ln1104">  g-&gt;luma_patches[LIFT] = XYZ[1];</a>
<a name="ln1105">  g-&gt;luma_patches_flags[LIFT] = USER_SELECTED;</a>
<a name="ln1106"> </a>
<a name="ln1107">  float RGB[3] = { 0.0f };</a>
<a name="ln1108">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1109"> </a>
<a name="ln1110">  p-&gt;lift[CHANNEL_FACTOR] = -p-&gt;gain[CHANNEL_FACTOR] * XYZ[1] + 1.0f;</a>
<a name="ln1111"> </a>
<a name="ln1112">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1113">  dt_bauhaus_slider_set_soft(g-&gt;lift_factor, (p-&gt;lift[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1114">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1115"> </a>
<a name="ln1116">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1117">}</a>
<a name="ln1118"> </a>
<a name="ln1119">static void apply_gamma_auto(dt_iop_module_t *self)</a>
<a name="ln1120">{</a>
<a name="ln1121">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1122">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1123">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1124"> </a>
<a name="ln1125">  float XYZ[3] = { 0.0f };</a>
<a name="ln1126">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln1127"> </a>
<a name="ln1128">  g-&gt;luma_patches[GAMMA] = XYZ[1];</a>
<a name="ln1129">  g-&gt;luma_patches_flags[GAMMA] = USER_SELECTED;</a>
<a name="ln1130"> </a>
<a name="ln1131">  float RGB[3] = { 0.0f };</a>
<a name="ln1132">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1133"> </a>
<a name="ln1134">  p-&gt;gamma[CHANNEL_FACTOR]</a>
<a name="ln1135">      = 2.0f - logf(0.1842f) / logf(MAX(p-&gt;gain[CHANNEL_FACTOR] * XYZ[1] + p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 0.000001f));</a>
<a name="ln1136"> </a>
<a name="ln1137">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1138">  dt_bauhaus_slider_set_soft(g-&gt;gamma_factor, (p-&gt;gamma[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1139">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1140"> </a>
<a name="ln1141">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144">static void apply_gain_auto(dt_iop_module_t *self)</a>
<a name="ln1145">{</a>
<a name="ln1146">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1147">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1148">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1149"> </a>
<a name="ln1150">  float XYZ[3] = { 0.0f };</a>
<a name="ln1151">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color_max, XYZ);</a>
<a name="ln1152"> </a>
<a name="ln1153">  g-&gt;luma_patches[GAIN] = XYZ[1];</a>
<a name="ln1154">  g-&gt;luma_patches_flags[GAIN] = USER_SELECTED;</a>
<a name="ln1155"> </a>
<a name="ln1156">  float RGB[3] = { 0.0f };</a>
<a name="ln1157">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1158"> </a>
<a name="ln1159">  p-&gt;gain[CHANNEL_FACTOR] = p-&gt;lift[CHANNEL_FACTOR] / (XYZ[1]);</a>
<a name="ln1160"> </a>
<a name="ln1161">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1162">  dt_bauhaus_slider_set_soft(g-&gt;gain_factor, (p-&gt;gain[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1163">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1164"> </a>
<a name="ln1165">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1166">}</a>
<a name="ln1167"> </a>
<a name="ln1168">static void apply_autocolor(dt_iop_module_t *self)</a>
<a name="ln1169">{</a>
<a name="ln1170">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1171">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1172"> </a>
<a name="ln1173">  if(g-&gt;color_patches_flags[GAIN] == INVALID || g-&gt;color_patches_flags[GAMMA] == INVALID</a>
<a name="ln1174">     || g-&gt;color_patches_flags[LIFT] == INVALID)</a>
<a name="ln1175">  {</a>
<a name="ln1176">    /*</a>
<a name="ln1177">     * Some color patches were not picked by the user. Take a</a>
<a name="ln1178">     * picture-wide patch for these.</a>
<a name="ln1179">     */</a>
<a name="ln1180">    float XYZ[3] = { 0.0f };</a>
<a name="ln1181">    dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln1182">    float RGB[3] = { 0.0f };</a>
<a name="ln1183">    dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1184"> </a>
<a name="ln1185">    // Save the patch color for the optimization</a>
<a name="ln1186">    if(g-&gt;color_patches_flags[LIFT] == INVALID)</a>
<a name="ln1187">    {</a>
<a name="ln1188">      for(int c = 0; c &lt; 3; c++) g-&gt;color_patches_lift[c] = RGB[c];</a>
<a name="ln1189">      g-&gt;color_patches_flags[LIFT] = AUTO_SELECTED;</a>
<a name="ln1190">    }</a>
<a name="ln1191">    if(g-&gt;color_patches_flags[GAMMA] == INVALID)</a>
<a name="ln1192">    {</a>
<a name="ln1193">      for(int c = 0; c &lt; 3; c++) g-&gt;color_patches_gamma[c] = RGB[c];</a>
<a name="ln1194">      g-&gt;color_patches_flags[GAMMA] = AUTO_SELECTED;</a>
<a name="ln1195">    }</a>
<a name="ln1196">    if(g-&gt;color_patches_flags[GAIN] == INVALID)</a>
<a name="ln1197">    {</a>
<a name="ln1198">      for(int c = 0; c &lt; 3; c++) g-&gt;color_patches_gain[c] = RGB[c];</a>
<a name="ln1199">      g-&gt;color_patches_flags[GAIN] = AUTO_SELECTED;</a>
<a name="ln1200">    }</a>
<a name="ln1201">  }</a>
<a name="ln1202"> </a>
<a name="ln1203">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1204"> </a>
<a name="ln1205">  // Build the CDL-corrected samples (after the factors)</a>
<a name="ln1206">  float samples_lift[3] = { 0.f };</a>
<a name="ln1207">  float samples_gamma[3] = { 0.f };</a>
<a name="ln1208">  float samples_gain[3] = { 0.f };</a>
<a name="ln1209"> </a>
<a name="ln1210">  for (int c = 0; c &lt; 3; ++c)</a>
<a name="ln1211">  {</a>
<a name="ln1212">    samples_lift[c] = CDL(g-&gt;color_patches_lift[c], p-&gt;gain[CHANNEL_FACTOR], p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 2.0f - p-&gt;gamma[CHANNEL_FACTOR]);</a>
<a name="ln1213">    samples_gamma[c] = CDL(g-&gt;color_patches_gamma[c], p-&gt;gain[CHANNEL_FACTOR], p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 2.0f - p-&gt;gamma[CHANNEL_FACTOR]);</a>
<a name="ln1214">    samples_gain[c] = CDL(g-&gt;color_patches_gain[c], p-&gt;gain[CHANNEL_FACTOR], p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 2.0f - p-&gt;gamma[CHANNEL_FACTOR]);</a>
<a name="ln1215">  }</a>
<a name="ln1216"> </a>
<a name="ln1217">  // Get the average patches luma value (= neutral grey equivalents) after the CDL factors</a>
<a name="ln1218">  float greys[3] = { 0.0 };</a>
<a name="ln1219">  float XYZ[3] = { 0.0 };</a>
<a name="ln1220">  dt_prophotorgb_to_XYZ((const float *)samples_lift, (float *)XYZ);</a>
<a name="ln1221">  greys[0] = XYZ[1];</a>
<a name="ln1222">  dt_prophotorgb_to_XYZ((const float *)samples_gamma, (float *)XYZ);</a>
<a name="ln1223">  greys[1] = XYZ[1];</a>
<a name="ln1224">  dt_prophotorgb_to_XYZ((const float *)samples_gain, (float *)XYZ);</a>
<a name="ln1225">  greys[2] = XYZ[1];</a>
<a name="ln1226"> </a>
<a name="ln1227">  // Get the current params</a>
<a name="ln1228">  float RGB_lift[3] = { p-&gt;lift[CHANNEL_RED] - 1.0f, p-&gt;lift[CHANNEL_GREEN] - 1.0f, p-&gt;lift[CHANNEL_BLUE] - 1.0f };</a>
<a name="ln1229">  float RGB_gamma[3] = { p-&gt;gamma[CHANNEL_RED], p-&gt;gamma[CHANNEL_GREEN], p-&gt;gamma[CHANNEL_BLUE] };</a>
<a name="ln1230">  float RGB_gain[3] = { p-&gt;gain[CHANNEL_RED], p-&gt;gain[CHANNEL_GREEN], p-&gt;gain[CHANNEL_BLUE] };</a>
<a name="ln1231"> </a>
<a name="ln1232">  /** Optimization loop :</a>
<a name="ln1233">  * We try to find the CDL curves that neutralize the 3 input color patches, while not affecting the overall lightness.</a>
<a name="ln1234">  * But this is a non-linear overconstrained problem with tainted inputs, so the best we can do is a numerical optimization.</a>
<a name="ln1235">  * To do so, we compute each parameter of each RGB curve from the input color and the 2 other parameters.</a>
<a name="ln1236">  * Then, we loop over the previous optimization until the difference between 2 updates is insignificant.</a>
<a name="ln1237">  * This would need a proper stopping criterion based on convergence analysis, but it would be overkill here since</a>
<a name="ln1238">  * it should converge usually in 20 iterations, and maximum in 100.</a>
<a name="ln1239">  * Also, the convergence has not been proven formally.</a>
<a name="ln1240">  * For better color accuracy, we compute on luminance corrected RGB values (after the main factors corrections).</a>
<a name="ln1241">  * To avoid divergence, we constrain the parameters between +- 0.25 around the neutral value.</a>
<a name="ln1242">  * Experimentally, nothing good happens out of these bounds.</a>
<a name="ln1243">  */</a>
<a name="ln1244">  for (int runs = 0 ; runs &lt; 1000 ; ++runs)</a>
<a name="ln1245">  {</a>
<a name="ln1246">    // compute RGB slope/gain (powf(XYZ[1], 1.0f/(2.0f - p-&gt;gamma[c+1])) - p-&gt;lift[c+1] + 1.0f) / MAX(RGB[c], 0.000001f);</a>
<a name="ln1247">    for (int c = 0; c &lt; 3; ++c) RGB_gain[c] = CLAMP((powf(greys[GAIN], 1.0f / (2.0f - RGB_gamma[c])) - RGB_lift[c]) / MAX(samples_gain[c], 0.000001f), 0.75f, 1.25f);</a>
<a name="ln1248">    // compute RGB offset/lift powf(XYZ[1], 1.0f/(2.0f - p-&gt;gamma[c+1])) - RGB[c] * p-&gt;gain[c+1];</a>
<a name="ln1249">    for (int c = 0; c &lt; 3; ++c) RGB_lift[c] = CLAMP(powf(greys[LIFT], 1.0f / (2.0f - RGB_gamma[c])) - samples_lift[c] * RGB_gain[c], -0.025f, 0.025f);</a>
<a name="ln1250">    // compute  power/gamma 2.0f - logf(0.1842f) / logf(MAX(p-&gt;gain[CHANNEL_FACTOR] * XYZ[1] + p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 0.000001f));</a>
<a name="ln1251">    for (int c = 0; c &lt; 3; ++c) RGB_gamma[c] = 2.0f - CLAMP(logf(MAX(greys[GAMMA], 0.000001f)) / logf(MAX(RGB_gain[c] * samples_gamma[c] + RGB_lift[c], 0.000001f)), 0.75f, 1.25f);</a>
<a name="ln1252">  }</a>
<a name="ln1253"> </a>
<a name="ln1254">  // save</a>
<a name="ln1255">  p-&gt;lift[CHANNEL_RED] = RGB_lift[0] + 1.0f;</a>
<a name="ln1256">  p-&gt;lift[CHANNEL_GREEN] = RGB_lift[1] + 1.0f;</a>
<a name="ln1257">  p-&gt;lift[CHANNEL_BLUE] = RGB_lift[2] + 1.0f;</a>
<a name="ln1258">  p-&gt;gamma[CHANNEL_RED] = RGB_gamma[0];</a>
<a name="ln1259">  p-&gt;gamma[CHANNEL_GREEN] = RGB_gamma[1];</a>
<a name="ln1260">  p-&gt;gamma[CHANNEL_BLUE] = RGB_gamma[2];</a>
<a name="ln1261">  p-&gt;gain[CHANNEL_RED] = RGB_gain[0];</a>
<a name="ln1262">  p-&gt;gain[CHANNEL_GREEN] = RGB_gain[1];</a>
<a name="ln1263">  p-&gt;gain[CHANNEL_BLUE] = RGB_gain[2];</a>
<a name="ln1264"> </a>
<a name="ln1265">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1266">  dt_bauhaus_slider_set_soft(g-&gt;lift_r, RGB_lift[0]);</a>
<a name="ln1267">  dt_bauhaus_slider_set_soft(g-&gt;lift_g, RGB_lift[1]);</a>
<a name="ln1268">  dt_bauhaus_slider_set_soft(g-&gt;lift_b, RGB_lift[2]);</a>
<a name="ln1269"> </a>
<a name="ln1270">  dt_bauhaus_slider_set_soft(g-&gt;gamma_r, RGB_gamma[0] - 1.0f);</a>
<a name="ln1271">  dt_bauhaus_slider_set_soft(g-&gt;gamma_g, RGB_gamma[1] - 1.0f);</a>
<a name="ln1272">  dt_bauhaus_slider_set_soft(g-&gt;gamma_b, RGB_gamma[2] - 1.0f);</a>
<a name="ln1273"> </a>
<a name="ln1274">  dt_bauhaus_slider_set_soft(g-&gt;gain_r, RGB_gain[0] - 1.0f);</a>
<a name="ln1275">  dt_bauhaus_slider_set_soft(g-&gt;gain_g, RGB_gain[1] - 1.0f);</a>
<a name="ln1276">  dt_bauhaus_slider_set_soft(g-&gt;gain_b, RGB_gain[2] - 1.0f);</a>
<a name="ln1277"> </a>
<a name="ln1278">  set_HSL_sliders(g-&gt;hue_lift, g-&gt;sat_lift, p-&gt;lift);</a>
<a name="ln1279">  set_HSL_sliders(g-&gt;hue_gamma, g-&gt;sat_gamma, p-&gt;gamma);</a>
<a name="ln1280">  set_HSL_sliders(g-&gt;hue_gain, g-&gt;sat_gain, p-&gt;gain);</a>
<a name="ln1281">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1282"> </a>
<a name="ln1283">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1284">}</a>
<a name="ln1285"> </a>
<a name="ln1286">static void apply_autoluma(dt_iop_module_t *self)</a>
<a name="ln1287">{</a>
<a name="ln1288">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1289">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1290"> </a>
<a name="ln1291">  /*</a>
<a name="ln1292">   * If some luma patches were not picked by the user, take a</a>
<a name="ln1293">   * picture-wide patch for these.</a>
<a name="ln1294">   */</a>
<a name="ln1295">  if(g-&gt;luma_patches_flags[LIFT] == INVALID)</a>
<a name="ln1296">  {</a>
<a name="ln1297">    float XYZ[3] = { 0.0f };</a>
<a name="ln1298">    dt_Lab_to_XYZ((const float *)self-&gt;picked_color_min, XYZ);</a>
<a name="ln1299">    g-&gt;luma_patches[LIFT] = XYZ[1];</a>
<a name="ln1300">    g-&gt;luma_patches_flags[LIFT] = AUTO_SELECTED;</a>
<a name="ln1301">  }</a>
<a name="ln1302">  if(g-&gt;luma_patches_flags[GAMMA] == INVALID)</a>
<a name="ln1303">  {</a>
<a name="ln1304">    float XYZ[3] = { 0.0f };</a>
<a name="ln1305">    dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln1306">    g-&gt;luma_patches[GAMMA] = XYZ[1];</a>
<a name="ln1307">    g-&gt;luma_patches_flags[GAMMA] = AUTO_SELECTED;</a>
<a name="ln1308">  }</a>
<a name="ln1309">  if(g-&gt;luma_patches_flags[GAIN] == INVALID)</a>
<a name="ln1310">  {</a>
<a name="ln1311">    float XYZ[3] = { 0.0f };</a>
<a name="ln1312">    dt_Lab_to_XYZ((const float *)self-&gt;picked_color_max, XYZ);</a>
<a name="ln1313">    g-&gt;luma_patches[GAIN] = XYZ[1];</a>
<a name="ln1314">    g-&gt;luma_patches_flags[GAIN] = AUTO_SELECTED;</a>
<a name="ln1315">  }</a>
<a name="ln1316"> </a>
<a name="ln1317">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1318"> </a>
<a name="ln1319">  /** Optimization loop :</a>
<a name="ln1320">  * We try to find the CDL curves that neutralize the 3 input luma patches</a>
<a name="ln1321">  */</a>
<a name="ln1322">  for (int runs = 0 ; runs &lt; 100 ; ++runs)</a>
<a name="ln1323">  {</a>
<a name="ln1324">    p-&gt;gain[CHANNEL_FACTOR] = CLAMP(p-&gt;lift[CHANNEL_FACTOR] / g-&gt;luma_patches[GAIN], 0.0f, 2.0f);</a>
<a name="ln1325">    p-&gt;lift[CHANNEL_FACTOR] = CLAMP(-p-&gt;gain[CHANNEL_FACTOR] * g-&gt;luma_patches[LIFT] + 1.0f, 0.0f, 2.0f);</a>
<a name="ln1326">    p-&gt;gamma[CHANNEL_FACTOR] = CLAMP(2.0f - logf(0.1842f) / logf(MAX(p-&gt;gain[CHANNEL_FACTOR] * g-&gt;luma_patches[GAMMA] + p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 0.000001f)), 0.0f, 2.0f);</a>
<a name="ln1327">  }</a>
<a name="ln1328"> </a>
<a name="ln1329">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1330">  dt_bauhaus_slider_set_soft(g-&gt;lift_factor, (p-&gt;lift[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1331">  dt_bauhaus_slider_set_soft(g-&gt;gamma_factor, (p-&gt;gamma[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1332">  dt_bauhaus_slider_set_soft(g-&gt;gain_factor, (p-&gt;gain[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1333">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1334"> </a>
<a name="ln1335">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1336">}</a>
<a name="ln1337"> </a>
<a name="ln1338">static void _iop_color_picker_update(dt_iop_module_t *self)</a>
<a name="ln1339">{</a>
<a name="ln1340">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1341">  const int which_colorpicker = g-&gt;color_picker.current_picker;</a>
<a name="ln1342"> </a>
<a name="ln1343">  dt_bauhaus_widget_set_quad_active(g-&gt;hue_lift, which_colorpicker == DT_PICKCOLBAL_HUE_LIFT);</a>
<a name="ln1344">  dt_bauhaus_widget_set_quad_active(g-&gt;hue_gamma, which_colorpicker == DT_PICKCOLBAL_HUE_GAMMA);</a>
<a name="ln1345">  dt_bauhaus_widget_set_quad_active(g-&gt;hue_gain, which_colorpicker == DT_PICKCOLBAL_HUE_GAIN);</a>
<a name="ln1346">  dt_bauhaus_widget_set_quad_active(g-&gt;lift_factor, which_colorpicker == DT_PICKCOLBAL_LIFT_FACTOR);</a>
<a name="ln1347">  dt_bauhaus_widget_set_quad_active(g-&gt;gamma_factor, which_colorpicker == DT_PICKCOLBAL_GAMMA_FACTOR);</a>
<a name="ln1348">  dt_bauhaus_widget_set_quad_active(g-&gt;gain_factor, which_colorpicker == DT_PICKCOLBAL_GAIN_FACTOR);</a>
<a name="ln1349">  dt_bauhaus_widget_set_quad_active(g-&gt;grey, which_colorpicker == DT_PICKCOLBAL_GREY);</a>
<a name="ln1350">  dt_bauhaus_widget_set_quad_active(g-&gt;auto_luma, which_colorpicker == DT_PICKCOLBAL_AUTOLUMA);</a>
<a name="ln1351">  dt_bauhaus_widget_set_quad_active(g-&gt;auto_color, which_colorpicker == DT_PICKCOLBAL_AUTOCOLOR);</a>
<a name="ln1352">}</a>
<a name="ln1353"> </a>
<a name="ln1354">static void _iop_color_picker_apply(struct dt_iop_module_t *self)</a>
<a name="ln1355">{</a>
<a name="ln1356">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1357">  switch(g-&gt;color_picker.current_picker)</a>
<a name="ln1358">  {</a>
<a name="ln1359">    case DT_PICKCOLBAL_HUE_LIFT:</a>
<a name="ln1360">      apply_lift_neutralize(self);</a>
<a name="ln1361">      break;</a>
<a name="ln1362">    case DT_PICKCOLBAL_HUE_GAMMA:</a>
<a name="ln1363">      apply_gamma_neutralize(self);</a>
<a name="ln1364">      break;</a>
<a name="ln1365">    case DT_PICKCOLBAL_HUE_GAIN:</a>
<a name="ln1366">      apply_gain_neutralize(self);</a>
<a name="ln1367">      break;</a>
<a name="ln1368">    case DT_PICKCOLBAL_LIFT_FACTOR:</a>
<a name="ln1369">      apply_lift_auto(self);</a>
<a name="ln1370">      break;</a>
<a name="ln1371">    case DT_PICKCOLBAL_GAMMA_FACTOR:</a>
<a name="ln1372">      apply_gamma_auto(self);</a>
<a name="ln1373">      break;</a>
<a name="ln1374">    case DT_PICKCOLBAL_GAIN_FACTOR:</a>
<a name="ln1375">      apply_gain_auto(self);</a>
<a name="ln1376">      break;</a>
<a name="ln1377">    case DT_PICKCOLBAL_GREY:</a>
<a name="ln1378">      apply_autogrey(self);</a>
<a name="ln1379">      break;</a>
<a name="ln1380">    case DT_PICKCOLBAL_AUTOLUMA:</a>
<a name="ln1381">      apply_autoluma(self);</a>
<a name="ln1382">      break;</a>
<a name="ln1383">    case DT_PICKCOLBAL_AUTOCOLOR:</a>
<a name="ln1384">      apply_autocolor(self);</a>
<a name="ln1385">      break;</a>
<a name="ln1386">    default:</a>
<a name="ln1387">      break;</a>
<a name="ln1388">  }</a>
<a name="ln1389">  _check_tuner_picker_labels(self);</a>
<a name="ln1390">}</a>
<a name="ln1391"> </a>
<a name="ln1392">static int _iop_color_picker_get_set(dt_iop_module_t *self, GtkWidget *button)</a>
<a name="ln1393">{</a>
<a name="ln1394">  dt_iop_colorbalance_gui_data_t *g =  (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1395">  const int current_picker = g-&gt;color_picker.current_picker;</a>
<a name="ln1396"> </a>
<a name="ln1397">  if(button == g-&gt;hue_lift)</a>
<a name="ln1398">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_HUE_LIFT;</a>
<a name="ln1399">  else if(button == g-&gt;hue_gamma)</a>
<a name="ln1400">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_HUE_GAMMA;</a>
<a name="ln1401">  else if(button == g-&gt;hue_gain)</a>
<a name="ln1402">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_HUE_GAIN;</a>
<a name="ln1403">  else if(button == g-&gt;lift_factor)</a>
<a name="ln1404">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_LIFT_FACTOR;</a>
<a name="ln1405">  else if(button == g-&gt;gamma_factor)</a>
<a name="ln1406">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_GAMMA_FACTOR;</a>
<a name="ln1407">  else if(button == g-&gt;gain_factor)</a>
<a name="ln1408">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_GAIN_FACTOR;</a>
<a name="ln1409">  else if(button == g-&gt;grey)</a>
<a name="ln1410">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_GREY;</a>
<a name="ln1411">  else if(button == g-&gt;auto_luma)</a>
<a name="ln1412">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_AUTOLUMA;</a>
<a name="ln1413">  else if(button == g-&gt;auto_color)</a>
<a name="ln1414">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_AUTOCOLOR;</a>
<a name="ln1415"> </a>
<a name="ln1416">  if (current_picker == g-&gt;color_picker.current_picker)</a>
<a name="ln1417">    return ALREADY_SELECTED;</a>
<a name="ln1418">  else</a>
<a name="ln1419">    return g-&gt;color_picker.current_picker;</a>
<a name="ln1420">}</a>
<a name="ln1421"> </a>
<a name="ln1422">void gui_focus(struct dt_iop_module_t *self, gboolean in)</a>
<a name="ln1423">{</a>
<a name="ln1424">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1425">  if(!in) dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1426">}</a>
<a name="ln1427"> </a>
<a name="ln1428">void init(dt_iop_module_t *module)</a>
<a name="ln1429">{</a>
<a name="ln1430">  module-&gt;params = calloc(1, sizeof(dt_iop_colorbalance_params_t));</a>
<a name="ln1431">  module-&gt;default_params = calloc(1, sizeof(dt_iop_colorbalance_params_t));</a>
<a name="ln1432">  module-&gt;default_enabled = 0;</a>
<a name="ln1433">  module-&gt;priority = 457; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln1434">  module-&gt;params_size = sizeof(dt_iop_colorbalance_params_t);</a>
<a name="ln1435">  module-&gt;gui_data = NULL;</a>
<a name="ln1436">  dt_iop_colorbalance_params_t tmp = (dt_iop_colorbalance_params_t){ SLOPE_OFFSET_POWER,</a>
<a name="ln1437">                                                                     { 1.0f, 1.0f, 1.0f, 1.0f },</a>
<a name="ln1438">                                                                     { 1.0f, 1.0f, 1.0f, 1.0f },</a>
<a name="ln1439">                                                                     { 1.0f, 1.0f, 1.0f, 1.0f },</a>
<a name="ln1440">                                                                     1.0f,</a>
<a name="ln1441">                                                                     1.0f,</a>
<a name="ln1442">                                                                     18.0f,</a>
<a name="ln1443">                                                                     1.0f };</a>
<a name="ln1444"> </a>
<a name="ln1445">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_colorbalance_params_t));</a>
<a name="ln1446">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_colorbalance_params_t));</a>
<a name="ln1447">}</a>
<a name="ln1448"> </a>
<a name="ln1449">void cleanup(dt_iop_module_t *module)</a>
<a name="ln1450">{</a>
<a name="ln1451">  free(module-&gt;params);</a>
<a name="ln1452">  module-&gt;params = NULL;</a>
<a name="ln1453">}</a>
<a name="ln1454"> </a>
<a name="ln1455">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln1456">{</a>
<a name="ln1457">  const int program = 8; // extended.cl, from programs.conf</a>
<a name="ln1458">  dt_iop_colorbalance_global_data_t *gd</a>
<a name="ln1459">      = (dt_iop_colorbalance_global_data_t *)malloc(sizeof(dt_iop_colorbalance_global_data_t));</a>
<a name="ln1460">  module-&gt;data = gd;</a>
<a name="ln1461">  gd-&gt;kernel_colorbalance = dt_opencl_create_kernel(program, &quot;colorbalance&quot;);</a>
<a name="ln1462">  gd-&gt;kernel_colorbalance_lgg = dt_opencl_create_kernel(program, &quot;colorbalance_lgg&quot;);</a>
<a name="ln1463">  gd-&gt;kernel_colorbalance_cdl = dt_opencl_create_kernel(program, &quot;colorbalance_cdl&quot;);</a>
<a name="ln1464">}</a>
<a name="ln1465"> </a>
<a name="ln1466">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln1467">{</a>
<a name="ln1468">  dt_iop_colorbalance_global_data_t *gd = (dt_iop_colorbalance_global_data_t *)module-&gt;data;</a>
<a name="ln1469">  dt_opencl_free_kernel(gd-&gt;kernel_colorbalance);</a>
<a name="ln1470">  dt_opencl_free_kernel(gd-&gt;kernel_colorbalance_lgg);</a>
<a name="ln1471">  dt_opencl_free_kernel(gd-&gt;kernel_colorbalance_cdl);</a>
<a name="ln1472">  free(module-&gt;data);</a>
<a name="ln1473">  module-&gt;data = NULL;</a>
<a name="ln1474">}</a>
<a name="ln1475"> </a>
<a name="ln1476">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln1477">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1478">{</a>
<a name="ln1479">  dt_iop_colorbalance_data_t *d = (dt_iop_colorbalance_data_t *)(piece-&gt;data);</a>
<a name="ln1480">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)p1;</a>
<a name="ln1481"> </a>
<a name="ln1482">  d-&gt;mode = p-&gt;mode;</a>
<a name="ln1483"> </a>
<a name="ln1484">  switch(d-&gt;mode)</a>
<a name="ln1485">  {</a>
<a name="ln1486">    case SLOPE_OFFSET_POWER:</a>
<a name="ln1487">    {</a>
<a name="ln1488">      // Correct the luminance in RGB parameters so we don't affect it</a>
<a name="ln1489">      float XYZ[3];</a>
<a name="ln1490"> </a>
<a name="ln1491">      dt_prophotorgb_to_XYZ((const float *)&amp;p-&gt;lift[CHANNEL_RED], XYZ);</a>
<a name="ln1492">      d-&gt;lift[CHANNEL_FACTOR] = p-&gt;lift[CHANNEL_FACTOR];</a>
<a name="ln1493">      d-&gt;lift[CHANNEL_RED] = (p-&gt;lift[CHANNEL_RED] - XYZ[1]) + 1.f;</a>
<a name="ln1494">      d-&gt;lift[CHANNEL_GREEN] = (p-&gt;lift[CHANNEL_GREEN] - XYZ[1]) + 1.f;</a>
<a name="ln1495">      d-&gt;lift[CHANNEL_BLUE] = (p-&gt;lift[CHANNEL_BLUE] - XYZ[1]) + 1.f;</a>
<a name="ln1496"> </a>
<a name="ln1497">      dt_prophotorgb_to_XYZ((const float *)&amp;p-&gt;gamma[CHANNEL_RED], XYZ);</a>
<a name="ln1498">      d-&gt;gamma[CHANNEL_FACTOR] = p-&gt;gamma[CHANNEL_FACTOR];</a>
<a name="ln1499">      d-&gt;gamma[CHANNEL_RED] = (p-&gt;gamma[CHANNEL_RED] - XYZ[1]) + 1.f;</a>
<a name="ln1500">      d-&gt;gamma[CHANNEL_GREEN] = (p-&gt;gamma[CHANNEL_GREEN] - XYZ[1]) + 1.f;</a>
<a name="ln1501">      d-&gt;gamma[CHANNEL_BLUE] = (p-&gt;gamma[CHANNEL_BLUE] - XYZ[1]) + 1.f;</a>
<a name="ln1502"> </a>
<a name="ln1503">      dt_prophotorgb_to_XYZ((const float *)&amp;p-&gt;gain[CHANNEL_RED], XYZ);</a>
<a name="ln1504">      d-&gt;gain[CHANNEL_FACTOR] = p-&gt;gain[CHANNEL_FACTOR];</a>
<a name="ln1505">      d-&gt;gain[CHANNEL_RED] = (p-&gt;gain[CHANNEL_RED] - XYZ[1]) + 1.f;</a>
<a name="ln1506">      d-&gt;gain[CHANNEL_GREEN] = (p-&gt;gain[CHANNEL_GREEN] - XYZ[1]) + 1.f;</a>
<a name="ln1507">      d-&gt;gain[CHANNEL_BLUE] = (p-&gt;gain[CHANNEL_BLUE] - XYZ[1]) + 1.f;</a>
<a name="ln1508"> </a>
<a name="ln1509">      break;</a>
<a name="ln1510">    }</a>
<a name="ln1511"> </a>
<a name="ln1512">    case LEGACY:</a>
<a name="ln1513">    {</a>
<a name="ln1514">      // Luminance is not corrected in lift/gamma/gain for compatibility</a>
<a name="ln1515">      for(int i = 0; i &lt; CHANNEL_SIZE; i++)</a>
<a name="ln1516">      {</a>
<a name="ln1517">        d-&gt;lift[i] = p-&gt;lift[i];</a>
<a name="ln1518">        d-&gt;gamma[i] = p-&gt;gamma[i];</a>
<a name="ln1519">        d-&gt;gain[i] = p-&gt;gain[i];</a>
<a name="ln1520">      }</a>
<a name="ln1521"> </a>
<a name="ln1522">      break;</a>
<a name="ln1523">    }</a>
<a name="ln1524"> </a>
<a name="ln1525">    case LIFT_GAMMA_GAIN:</a>
<a name="ln1526">    {</a>
<a name="ln1527">      // Correct the luminance in RGB parameters so we don't affect it</a>
<a name="ln1528">      float XYZ[3];</a>
<a name="ln1529">      dt_prophotorgb_to_XYZ((const float *)&amp;p-&gt;lift[CHANNEL_RED], XYZ);</a>
<a name="ln1530">      d-&gt;lift[CHANNEL_FACTOR] = p-&gt;lift[CHANNEL_FACTOR];</a>
<a name="ln1531">      d-&gt;lift[CHANNEL_RED] = (p-&gt;lift[CHANNEL_RED] - XYZ[1]) + 1.f;</a>
<a name="ln1532">      d-&gt;lift[CHANNEL_GREEN] = (p-&gt;lift[CHANNEL_GREEN] - XYZ[1]) + 1.f;</a>
<a name="ln1533">      d-&gt;lift[CHANNEL_BLUE] = (p-&gt;lift[CHANNEL_BLUE] - XYZ[1]) + 1.f;</a>
<a name="ln1534"> </a>
<a name="ln1535">      dt_prophotorgb_to_XYZ((const float *)&amp;p-&gt;gamma[CHANNEL_RED], XYZ);</a>
<a name="ln1536">      d-&gt;gamma[CHANNEL_FACTOR] = p-&gt;gamma[CHANNEL_FACTOR];</a>
<a name="ln1537">      d-&gt;gamma[CHANNEL_RED] = (p-&gt;gamma[CHANNEL_RED] - XYZ[1]) + 1.f;</a>
<a name="ln1538">      d-&gt;gamma[CHANNEL_GREEN] = (p-&gt;gamma[CHANNEL_GREEN] - XYZ[1]) + 1.f;</a>
<a name="ln1539">      d-&gt;gamma[CHANNEL_BLUE] = (p-&gt;gamma[CHANNEL_BLUE] - XYZ[1]) + 1.f;</a>
<a name="ln1540"> </a>
<a name="ln1541">      dt_prophotorgb_to_XYZ((const float *)&amp;p-&gt;gain[CHANNEL_RED], XYZ);</a>
<a name="ln1542">      d-&gt;gain[CHANNEL_FACTOR] = p-&gt;gain[CHANNEL_FACTOR];</a>
<a name="ln1543">      d-&gt;gain[CHANNEL_RED] = (p-&gt;gain[CHANNEL_RED] - XYZ[1]) + 1.f;</a>
<a name="ln1544">      d-&gt;gain[CHANNEL_GREEN] = (p-&gt;gain[CHANNEL_GREEN] - XYZ[1]) + 1.f;</a>
<a name="ln1545">      d-&gt;gain[CHANNEL_BLUE] = (p-&gt;gain[CHANNEL_BLUE] - XYZ[1]) + 1.f;</a>
<a name="ln1546"> </a>
<a name="ln1547">      break;</a>
<a name="ln1548">    }</a>
<a name="ln1549">  }</a>
<a name="ln1550"> </a>
<a name="ln1551">  d-&gt;grey = p-&gt;grey;</a>
<a name="ln1552">  d-&gt;saturation = p-&gt;saturation;</a>
<a name="ln1553">  d-&gt;saturation_out = p-&gt;saturation_out;</a>
<a name="ln1554">  d-&gt;contrast = p-&gt;contrast;</a>
<a name="ln1555">}</a>
<a name="ln1556"> </a>
<a name="ln1557">void init_pipe(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1558">{</a>
<a name="ln1559">  piece-&gt;data = calloc(1, sizeof(dt_iop_colorbalance_data_t));</a>
<a name="ln1560">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln1561">}</a>
<a name="ln1562"> </a>
<a name="ln1563">void cleanup_pipe(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1564">{</a>
<a name="ln1565">  free(piece-&gt;data);</a>
<a name="ln1566">  piece-&gt;data = NULL;</a>
<a name="ln1567">}</a>
<a name="ln1568"> </a>
<a name="ln1569">void gui_update(dt_iop_module_t *self)</a>
<a name="ln1570">{</a>
<a name="ln1571">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1572">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1573"> </a>
<a name="ln1574">  self-&gt;color_picker_box[0] = self-&gt;color_picker_box[1] = .25f;</a>
<a name="ln1575">  self-&gt;color_picker_box[2] = self-&gt;color_picker_box[3] = .75f;</a>
<a name="ln1576">  self-&gt;color_picker_point[0] = self-&gt;color_picker_point[1] = 0.5f;</a>
<a name="ln1577"> </a>
<a name="ln1578">  dt_bauhaus_combobox_set(g-&gt;mode, p-&gt;mode);</a>
<a name="ln1579"> </a>
<a name="ln1580">  dt_bauhaus_slider_set_soft(g-&gt;grey, p-&gt;grey);</a>
<a name="ln1581">  dt_bauhaus_slider_set_soft(g-&gt;saturation, p-&gt;saturation * 100.0);</a>
<a name="ln1582">  dt_bauhaus_slider_set_soft(g-&gt;saturation_out, p-&gt;saturation_out * 100.0f);</a>
<a name="ln1583">  dt_bauhaus_slider_set_soft(g-&gt;contrast, (1.0f - p-&gt;contrast) * 100.0f);</a>
<a name="ln1584"> </a>
<a name="ln1585">  dt_bauhaus_slider_set_soft(g-&gt;lift_factor, (p-&gt;lift[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1586">  dt_bauhaus_slider_set_soft(g-&gt;lift_r, p-&gt;lift[CHANNEL_RED] - 1.0f);</a>
<a name="ln1587">  dt_bauhaus_slider_set_soft(g-&gt;lift_g, p-&gt;lift[CHANNEL_GREEN] - 1.0f);</a>
<a name="ln1588">  dt_bauhaus_slider_set_soft(g-&gt;lift_b, p-&gt;lift[CHANNEL_BLUE] - 1.0f);</a>
<a name="ln1589"> </a>
<a name="ln1590">  dt_bauhaus_slider_set_soft(g-&gt;gamma_factor, (p-&gt;gamma[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1591">  dt_bauhaus_slider_set_soft(g-&gt;gamma_r, p-&gt;gamma[CHANNEL_RED] - 1.0f);</a>
<a name="ln1592">  dt_bauhaus_slider_set_soft(g-&gt;gamma_g, p-&gt;gamma[CHANNEL_GREEN] - 1.0f);</a>
<a name="ln1593">  dt_bauhaus_slider_set_soft(g-&gt;gamma_b, p-&gt;gamma[CHANNEL_BLUE] - 1.0f);</a>
<a name="ln1594"> </a>
<a name="ln1595">  dt_bauhaus_slider_set_soft(g-&gt;gain_factor, (p-&gt;gain[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1596">  dt_bauhaus_slider_set_soft(g-&gt;gain_r, p-&gt;gain[CHANNEL_RED] - 1.0f);</a>
<a name="ln1597">  dt_bauhaus_slider_set_soft(g-&gt;gain_g, p-&gt;gain[CHANNEL_GREEN] - 1.0f);</a>
<a name="ln1598">  dt_bauhaus_slider_set_soft(g-&gt;gain_b, p-&gt;gain[CHANNEL_BLUE] - 1.0f);</a>
<a name="ln1599"> </a>
<a name="ln1600">  if(p-&gt;mode == LEGACY || p-&gt;mode == LIFT_GAMMA_GAIN)</a>
<a name="ln1601">  {</a>
<a name="ln1602">    gtk_widget_set_visible(g-&gt;optim_label, FALSE);</a>
<a name="ln1603">    gtk_widget_set_visible(g-&gt;auto_color, FALSE);</a>
<a name="ln1604">    gtk_widget_set_visible(g-&gt;auto_luma, FALSE);</a>
<a name="ln1605">  }</a>
<a name="ln1606">  else</a>
<a name="ln1607">  {</a>
<a name="ln1608">    gtk_widget_set_visible(g-&gt;optim_label, TRUE);</a>
<a name="ln1609">    gtk_widget_set_visible(g-&gt;auto_color, TRUE);</a>
<a name="ln1610">    gtk_widget_set_visible(g-&gt;auto_luma, TRUE);</a>
<a name="ln1611">  }</a>
<a name="ln1612"> </a>
<a name="ln1613">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1614">  _check_tuner_picker_labels(self);</a>
<a name="ln1615"> </a>
<a name="ln1616">  if(p-&gt;mode == LEGACY)</a>
<a name="ln1617">  {</a>
<a name="ln1618">    gtk_widget_set_visible(g-&gt;master_box, FALSE);</a>
<a name="ln1619">  }</a>
<a name="ln1620">  else</a>
<a name="ln1621">  {</a>
<a name="ln1622">    gtk_widget_set_visible(g-&gt;master_box, TRUE);</a>
<a name="ln1623">  }</a>
<a name="ln1624"> </a>
<a name="ln1625">  set_HSL_sliders(g-&gt;hue_lift, g-&gt;sat_lift, p-&gt;lift);</a>
<a name="ln1626">  set_HSL_sliders(g-&gt;hue_gamma, g-&gt;sat_gamma, p-&gt;gamma);</a>
<a name="ln1627">  set_HSL_sliders(g-&gt;hue_gain, g-&gt;sat_gain, p-&gt;gain);</a>
<a name="ln1628"> </a>
<a name="ln1629">  const int control_mode = dt_bauhaus_combobox_get(g-&gt;controls);</a>
<a name="ln1630"> </a>
<a name="ln1631">  switch (control_mode)</a>
<a name="ln1632">  {</a>
<a name="ln1633">    case HSL:</a>
<a name="ln1634">    {</a>
<a name="ln1635">      gtk_widget_set_visible(g-&gt;lift_r, FALSE);</a>
<a name="ln1636">      gtk_widget_set_visible(g-&gt;lift_g, FALSE);</a>
<a name="ln1637">      gtk_widget_set_visible(g-&gt;lift_b, FALSE);</a>
<a name="ln1638">      gtk_widget_set_visible(g-&gt;gamma_r, FALSE);</a>
<a name="ln1639">      gtk_widget_set_visible(g-&gt;gamma_g, FALSE);</a>
<a name="ln1640">      gtk_widget_set_visible(g-&gt;gamma_b, FALSE);</a>
<a name="ln1641">      gtk_widget_set_visible(g-&gt;gain_r, FALSE);</a>
<a name="ln1642">      gtk_widget_set_visible(g-&gt;gain_g, FALSE);</a>
<a name="ln1643">      gtk_widget_set_visible(g-&gt;gain_b, FALSE);</a>
<a name="ln1644"> </a>
<a name="ln1645">      gtk_widget_set_visible(g-&gt;hue_lift, TRUE);</a>
<a name="ln1646">      gtk_widget_set_visible(g-&gt;sat_lift, TRUE);</a>
<a name="ln1647">      gtk_widget_set_visible(g-&gt;hue_gamma, TRUE);</a>
<a name="ln1648">      gtk_widget_set_visible(g-&gt;sat_gamma, TRUE);</a>
<a name="ln1649">      gtk_widget_set_visible(g-&gt;hue_gain, TRUE);</a>
<a name="ln1650">      gtk_widget_set_visible(g-&gt;sat_gain, TRUE);</a>
<a name="ln1651">      break;</a>
<a name="ln1652">    }</a>
<a name="ln1653">    case RGBL:</a>
<a name="ln1654">    {</a>
<a name="ln1655">      gtk_widget_set_visible(g-&gt;lift_r, TRUE);</a>
<a name="ln1656">      gtk_widget_set_visible(g-&gt;lift_g, TRUE);</a>
<a name="ln1657">      gtk_widget_set_visible(g-&gt;lift_b, TRUE);</a>
<a name="ln1658">      gtk_widget_set_visible(g-&gt;gamma_r, TRUE);</a>
<a name="ln1659">      gtk_widget_set_visible(g-&gt;gamma_g, TRUE);</a>
<a name="ln1660">      gtk_widget_set_visible(g-&gt;gamma_b, TRUE);</a>
<a name="ln1661">      gtk_widget_set_visible(g-&gt;gain_r, TRUE);</a>
<a name="ln1662">      gtk_widget_set_visible(g-&gt;gain_g, TRUE);</a>
<a name="ln1663">      gtk_widget_set_visible(g-&gt;gain_b, TRUE);</a>
<a name="ln1664"> </a>
<a name="ln1665">      gtk_widget_set_visible(g-&gt;hue_lift, FALSE);</a>
<a name="ln1666">      gtk_widget_set_visible(g-&gt;sat_lift, FALSE);</a>
<a name="ln1667">      gtk_widget_set_visible(g-&gt;hue_gamma, FALSE);</a>
<a name="ln1668">      gtk_widget_set_visible(g-&gt;sat_gamma, FALSE);</a>
<a name="ln1669">      gtk_widget_set_visible(g-&gt;hue_gain, FALSE);</a>
<a name="ln1670">      gtk_widget_set_visible(g-&gt;sat_gain, FALSE);</a>
<a name="ln1671">      break;</a>
<a name="ln1672">    }</a>
<a name="ln1673">    case BOTH:</a>
<a name="ln1674">    {</a>
<a name="ln1675">      gtk_widget_set_visible(g-&gt;lift_r, TRUE);</a>
<a name="ln1676">      gtk_widget_set_visible(g-&gt;lift_g, TRUE);</a>
<a name="ln1677">      gtk_widget_set_visible(g-&gt;lift_b, TRUE);</a>
<a name="ln1678">      gtk_widget_set_visible(g-&gt;gamma_r, TRUE);</a>
<a name="ln1679">      gtk_widget_set_visible(g-&gt;gamma_g, TRUE);</a>
<a name="ln1680">      gtk_widget_set_visible(g-&gt;gamma_b, TRUE);</a>
<a name="ln1681">      gtk_widget_set_visible(g-&gt;gain_r, TRUE);</a>
<a name="ln1682">      gtk_widget_set_visible(g-&gt;gain_g, TRUE);</a>
<a name="ln1683">      gtk_widget_set_visible(g-&gt;gain_b, TRUE);</a>
<a name="ln1684"> </a>
<a name="ln1685">      gtk_widget_set_visible(g-&gt;hue_lift, TRUE);</a>
<a name="ln1686">      gtk_widget_set_visible(g-&gt;sat_lift, TRUE);</a>
<a name="ln1687">      gtk_widget_set_visible(g-&gt;hue_gamma, TRUE);</a>
<a name="ln1688">      gtk_widget_set_visible(g-&gt;sat_gamma, TRUE);</a>
<a name="ln1689">      gtk_widget_set_visible(g-&gt;hue_gain, TRUE);</a>
<a name="ln1690">      gtk_widget_set_visible(g-&gt;sat_gain, TRUE);</a>
<a name="ln1691">      break;</a>
<a name="ln1692">    }</a>
<a name="ln1693">  }</a>
<a name="ln1694">}</a>
<a name="ln1695"> </a>
<a name="ln1696">void gui_reset(dt_iop_module_t *self)</a>
<a name="ln1697">{</a>
<a name="ln1698">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1699"> </a>
<a name="ln1700">  for (int k=0; k&lt;LEVELS; k++)</a>
<a name="ln1701">  {</a>
<a name="ln1702">    g-&gt;color_patches_flags[k] = INVALID;</a>
<a name="ln1703">    g-&gt;luma_patches_flags[k] = INVALID;</a>
<a name="ln1704">  }</a>
<a name="ln1705">  _check_tuner_picker_labels(self);</a>
<a name="ln1706"> </a>
<a name="ln1707">  dt_bauhaus_combobox_set(g-&gt;controls, HSL);</a>
<a name="ln1708"> </a>
<a name="ln1709">  gtk_widget_set_visible(g-&gt;lift_r, FALSE);</a>
<a name="ln1710">  gtk_widget_set_visible(g-&gt;lift_g, FALSE);</a>
<a name="ln1711">  gtk_widget_set_visible(g-&gt;lift_b, FALSE);</a>
<a name="ln1712">  gtk_widget_set_visible(g-&gt;gamma_r, FALSE);</a>
<a name="ln1713">  gtk_widget_set_visible(g-&gt;gamma_g, FALSE);</a>
<a name="ln1714">  gtk_widget_set_visible(g-&gt;gamma_b, FALSE);</a>
<a name="ln1715">  gtk_widget_set_visible(g-&gt;gain_r, FALSE);</a>
<a name="ln1716">  gtk_widget_set_visible(g-&gt;gain_g, FALSE);</a>
<a name="ln1717">  gtk_widget_set_visible(g-&gt;gain_b, FALSE);</a>
<a name="ln1718"> </a>
<a name="ln1719">  gtk_widget_set_visible(g-&gt;hue_lift, TRUE);</a>
<a name="ln1720">  gtk_widget_set_visible(g-&gt;sat_lift, TRUE);</a>
<a name="ln1721">  gtk_widget_set_visible(g-&gt;hue_gamma, TRUE);</a>
<a name="ln1722">  gtk_widget_set_visible(g-&gt;sat_gamma, TRUE);</a>
<a name="ln1723">  gtk_widget_set_visible(g-&gt;hue_gain, TRUE);</a>
<a name="ln1724">  gtk_widget_set_visible(g-&gt;sat_gain, TRUE);</a>
<a name="ln1725"> </a>
<a name="ln1726">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1727">}</a>
<a name="ln1728"> </a>
<a name="ln1729">static void mode_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln1730">{</a>
<a name="ln1731">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1732">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1733"> </a>
<a name="ln1734">  p-&gt;mode = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1735">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1736"> </a>
<a name="ln1737">  if (p-&gt;mode == LEGACY || p-&gt;mode == LIFT_GAMMA_GAIN)</a>
<a name="ln1738">  {</a>
<a name="ln1739">    gtk_widget_set_visible(g-&gt;optim_label, FALSE);</a>
<a name="ln1740">    gtk_widget_set_visible(g-&gt;auto_color, FALSE);</a>
<a name="ln1741">    gtk_widget_set_visible(g-&gt;auto_luma, FALSE);</a>
<a name="ln1742">  }</a>
<a name="ln1743">  else</a>
<a name="ln1744">  {</a>
<a name="ln1745">    gtk_widget_set_visible(g-&gt;optim_label, TRUE);</a>
<a name="ln1746">    gtk_widget_set_visible(g-&gt;auto_color, TRUE);</a>
<a name="ln1747">    gtk_widget_set_visible(g-&gt;auto_luma, TRUE);</a>
<a name="ln1748">  }</a>
<a name="ln1749"> </a>
<a name="ln1750">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1751"> </a>
<a name="ln1752">  if (p-&gt;mode == LEGACY)</a>
<a name="ln1753">  {</a>
<a name="ln1754">    gtk_widget_set_visible(g-&gt;master_box, FALSE);</a>
<a name="ln1755">  }</a>
<a name="ln1756">  else</a>
<a name="ln1757">  {</a>
<a name="ln1758">    gtk_widget_set_visible(g-&gt;master_box, TRUE);</a>
<a name="ln1759">  }</a>
<a name="ln1760"> </a>
<a name="ln1761">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1762">}</a>
<a name="ln1763"> </a>
<a name="ln1764">static void controls_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln1765">{</a>
<a name="ln1766">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1767">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1768">  const int control_mode = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1769"> </a>
<a name="ln1770">  switch (control_mode)</a>
<a name="ln1771">  {</a>
<a name="ln1772">    case HSL:</a>
<a name="ln1773">    {</a>
<a name="ln1774">      gtk_widget_set_visible(g-&gt;lift_r, FALSE);</a>
<a name="ln1775">      gtk_widget_set_visible(g-&gt;lift_g, FALSE);</a>
<a name="ln1776">      gtk_widget_set_visible(g-&gt;lift_b, FALSE);</a>
<a name="ln1777">      gtk_widget_set_visible(g-&gt;gamma_r, FALSE);</a>
<a name="ln1778">      gtk_widget_set_visible(g-&gt;gamma_g, FALSE);</a>
<a name="ln1779">      gtk_widget_set_visible(g-&gt;gamma_b, FALSE);</a>
<a name="ln1780">      gtk_widget_set_visible(g-&gt;gain_r, FALSE);</a>
<a name="ln1781">      gtk_widget_set_visible(g-&gt;gain_g, FALSE);</a>
<a name="ln1782">      gtk_widget_set_visible(g-&gt;gain_b, FALSE);</a>
<a name="ln1783"> </a>
<a name="ln1784">      gtk_widget_set_visible(g-&gt;hue_lift, TRUE);</a>
<a name="ln1785">      gtk_widget_set_visible(g-&gt;sat_lift, TRUE);</a>
<a name="ln1786">      gtk_widget_set_visible(g-&gt;hue_gamma, TRUE);</a>
<a name="ln1787">      gtk_widget_set_visible(g-&gt;sat_gamma, TRUE);</a>
<a name="ln1788">      gtk_widget_set_visible(g-&gt;hue_gain, TRUE);</a>
<a name="ln1789">      gtk_widget_set_visible(g-&gt;sat_gain, TRUE);</a>
<a name="ln1790">      break;</a>
<a name="ln1791">    }</a>
<a name="ln1792">    case RGBL:</a>
<a name="ln1793">    {</a>
<a name="ln1794">      gtk_widget_set_visible(g-&gt;lift_r, TRUE);</a>
<a name="ln1795">      gtk_widget_set_visible(g-&gt;lift_g, TRUE);</a>
<a name="ln1796">      gtk_widget_set_visible(g-&gt;lift_b, TRUE);</a>
<a name="ln1797">      gtk_widget_set_visible(g-&gt;gamma_r, TRUE);</a>
<a name="ln1798">      gtk_widget_set_visible(g-&gt;gamma_g, TRUE);</a>
<a name="ln1799">      gtk_widget_set_visible(g-&gt;gamma_b, TRUE);</a>
<a name="ln1800">      gtk_widget_set_visible(g-&gt;gain_r, TRUE);</a>
<a name="ln1801">      gtk_widget_set_visible(g-&gt;gain_g, TRUE);</a>
<a name="ln1802">      gtk_widget_set_visible(g-&gt;gain_b, TRUE);</a>
<a name="ln1803"> </a>
<a name="ln1804">      gtk_widget_set_visible(g-&gt;hue_lift, FALSE);</a>
<a name="ln1805">      gtk_widget_set_visible(g-&gt;sat_lift, FALSE);</a>
<a name="ln1806">      gtk_widget_set_visible(g-&gt;hue_gamma, FALSE);</a>
<a name="ln1807">      gtk_widget_set_visible(g-&gt;sat_gamma, FALSE);</a>
<a name="ln1808">      gtk_widget_set_visible(g-&gt;hue_gain, FALSE);</a>
<a name="ln1809">      gtk_widget_set_visible(g-&gt;sat_gain, FALSE);</a>
<a name="ln1810">      break;</a>
<a name="ln1811">    }</a>
<a name="ln1812">    case BOTH:</a>
<a name="ln1813">    {</a>
<a name="ln1814">      gtk_widget_set_visible(g-&gt;lift_r, TRUE);</a>
<a name="ln1815">      gtk_widget_set_visible(g-&gt;lift_g, TRUE);</a>
<a name="ln1816">      gtk_widget_set_visible(g-&gt;lift_b, TRUE);</a>
<a name="ln1817">      gtk_widget_set_visible(g-&gt;gamma_r, TRUE);</a>
<a name="ln1818">      gtk_widget_set_visible(g-&gt;gamma_g, TRUE);</a>
<a name="ln1819">      gtk_widget_set_visible(g-&gt;gamma_b, TRUE);</a>
<a name="ln1820">      gtk_widget_set_visible(g-&gt;gain_r, TRUE);</a>
<a name="ln1821">      gtk_widget_set_visible(g-&gt;gain_g, TRUE);</a>
<a name="ln1822">      gtk_widget_set_visible(g-&gt;gain_b, TRUE);</a>
<a name="ln1823"> </a>
<a name="ln1824">      gtk_widget_set_visible(g-&gt;hue_lift, TRUE);</a>
<a name="ln1825">      gtk_widget_set_visible(g-&gt;sat_lift, TRUE);</a>
<a name="ln1826">      gtk_widget_set_visible(g-&gt;hue_gamma, TRUE);</a>
<a name="ln1827">      gtk_widget_set_visible(g-&gt;sat_gamma, TRUE);</a>
<a name="ln1828">      gtk_widget_set_visible(g-&gt;hue_gain, TRUE);</a>
<a name="ln1829">      gtk_widget_set_visible(g-&gt;sat_gain, TRUE);</a>
<a name="ln1830">    }</a>
<a name="ln1831">  }</a>
<a name="ln1832">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1833">}</a>
<a name="ln1834"> </a>
<a name="ln1835">static void hue_lift_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1836">{</a>
<a name="ln1837">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1838">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1839">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1840">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1841"> </a>
<a name="ln1842">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1843"> </a>
<a name="ln1844">  float hsl[3] = {dt_bauhaus_slider_get(slider) / 360.0f,</a>
<a name="ln1845">                  dt_bauhaus_slider_get(g-&gt;sat_lift) / 100.0f,</a>
<a name="ln1846">                  0.5f};</a>
<a name="ln1847"> </a>
<a name="ln1848">  update_saturation_slider_color(g-&gt;sat_lift, hsl[0]);</a>
<a name="ln1849">  set_RGB_sliders(g-&gt;lift_r, g-&gt;lift_g, g-&gt;lift_b, hsl, p-&gt;lift, p-&gt;mode);</a>
<a name="ln1850"> </a>
<a name="ln1851">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1852">}</a>
<a name="ln1853"> </a>
<a name="ln1854"> </a>
<a name="ln1855">static void sat_lift_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1856">{</a>
<a name="ln1857">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1858">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1859">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1860">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1861"> </a>
<a name="ln1862">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1863"> </a>
<a name="ln1864">  float hsl[3] = {dt_bauhaus_slider_get(g-&gt;hue_lift) / 360.0f,</a>
<a name="ln1865">                  dt_bauhaus_slider_get(slider) / 100.0f,</a>
<a name="ln1866">                  0.5f};</a>
<a name="ln1867"> </a>
<a name="ln1868">  set_RGB_sliders(g-&gt;lift_r, g-&gt;lift_g, g-&gt;lift_b, hsl, p-&gt;lift, p-&gt;mode);</a>
<a name="ln1869">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1870">}</a>
<a name="ln1871"> </a>
<a name="ln1872">static void hue_gamma_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1873">{</a>
<a name="ln1874">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1875">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1876">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1877">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1878"> </a>
<a name="ln1879">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1880"> </a>
<a name="ln1881">  float hsl[3] = {dt_bauhaus_slider_get(slider) / 360.0f,</a>
<a name="ln1882">                  dt_bauhaus_slider_get(g-&gt;sat_gamma) / 100.0f,</a>
<a name="ln1883">                  0.5f};</a>
<a name="ln1884"> </a>
<a name="ln1885">  update_saturation_slider_color(g-&gt;sat_gamma, hsl[0]);</a>
<a name="ln1886">  set_RGB_sliders(g-&gt;gamma_r, g-&gt;gamma_g, g-&gt;gamma_b, hsl, p-&gt;gamma, p-&gt;mode);</a>
<a name="ln1887"> </a>
<a name="ln1888">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1889">}</a>
<a name="ln1890"> </a>
<a name="ln1891"> </a>
<a name="ln1892">static void sat_gamma_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1893">{</a>
<a name="ln1894">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1895">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1896">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1897">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1898"> </a>
<a name="ln1899">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1900"> </a>
<a name="ln1901">  float hsl[3] = {dt_bauhaus_slider_get(g-&gt;hue_gamma) / 360.0f,</a>
<a name="ln1902">                  dt_bauhaus_slider_get(slider) / 100.0f,</a>
<a name="ln1903">                  0.5f};</a>
<a name="ln1904"> </a>
<a name="ln1905">  set_RGB_sliders(g-&gt;gamma_r, g-&gt;gamma_g, g-&gt;gamma_b, hsl, p-&gt;gamma, p-&gt;mode);</a>
<a name="ln1906"> </a>
<a name="ln1907">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1908">}</a>
<a name="ln1909"> </a>
<a name="ln1910">static void hue_gain_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1911">{</a>
<a name="ln1912">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1913">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1914">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1915">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1916"> </a>
<a name="ln1917">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1918"> </a>
<a name="ln1919">  float hsl[3] = {dt_bauhaus_slider_get(slider) / 360.0f,</a>
<a name="ln1920">                  dt_bauhaus_slider_get(g-&gt;sat_gain) / 100.0f,</a>
<a name="ln1921">                  0.5f};</a>
<a name="ln1922"> </a>
<a name="ln1923">  update_saturation_slider_color(g-&gt;sat_gain, hsl[0]);</a>
<a name="ln1924">  set_RGB_sliders(g-&gt;gain_r, g-&gt;gain_g, g-&gt;gain_b, hsl, p-&gt;gain, p-&gt;mode);</a>
<a name="ln1925"> </a>
<a name="ln1926">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1927">}</a>
<a name="ln1928"> </a>
<a name="ln1929"> </a>
<a name="ln1930">static void sat_gain_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1931">{</a>
<a name="ln1932">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1933">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1934">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1935">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1936"> </a>
<a name="ln1937">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1938"> </a>
<a name="ln1939">  float hsl[3] = {dt_bauhaus_slider_get(g-&gt;hue_gain) / 360.0f,</a>
<a name="ln1940">                  dt_bauhaus_slider_get(slider) / 100.0f,</a>
<a name="ln1941">                  0.5f};</a>
<a name="ln1942"> </a>
<a name="ln1943">  set_RGB_sliders(g-&gt;gain_r, g-&gt;gain_g, g-&gt;gain_b, hsl, p-&gt;gain, p-&gt;mode);</a>
<a name="ln1944"> </a>
<a name="ln1945">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1946">}</a>
<a name="ln1947"> </a>
<a name="ln1948">static void saturation_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln1949">{</a>
<a name="ln1950">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1951">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1952">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1953"> </a>
<a name="ln1954">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1955"> </a>
<a name="ln1956">  p-&gt;saturation = dt_bauhaus_slider_get(slider) / 100.0f;</a>
<a name="ln1957">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1958">}</a>
<a name="ln1959"> </a>
<a name="ln1960">static void saturation_out_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln1961">{</a>
<a name="ln1962">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1963">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1964">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1965"> </a>
<a name="ln1966">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1967"> </a>
<a name="ln1968">  p-&gt;saturation_out = dt_bauhaus_slider_get(slider) / 100.0f;</a>
<a name="ln1969">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1970">}</a>
<a name="ln1971"> </a>
<a name="ln1972">static void contrast_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln1973">{</a>
<a name="ln1974">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1975">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1976">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1977"> </a>
<a name="ln1978">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1979"> </a>
<a name="ln1980">  p-&gt;contrast = - dt_bauhaus_slider_get(slider) / 100.0f + 1.0f;</a>
<a name="ln1981">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1982">}</a>
<a name="ln1983"> </a>
<a name="ln1984">static void grey_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln1985">{</a>
<a name="ln1986">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1987">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1988">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1989"> </a>
<a name="ln1990">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln1991"> </a>
<a name="ln1992">  p-&gt;grey = dt_bauhaus_slider_get(slider);</a>
<a name="ln1993">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1994">}</a>
<a name="ln1995"> </a>
<a name="ln1996">static void lift_factor_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln1997">{</a>
<a name="ln1998">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1999">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2000">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2001"> </a>
<a name="ln2002">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln2003"> </a>
<a name="ln2004">  p-&gt;lift[CHANNEL_FACTOR] = dt_bauhaus_slider_get(slider) / 100.0f + 1.0f;</a>
<a name="ln2005">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2006">}</a>
<a name="ln2007">static void lift_red_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2008">{</a>
<a name="ln2009">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2010">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2011">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2012"> </a>
<a name="ln2013">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln2014"> </a>
<a name="ln2015">  p-&gt;lift[CHANNEL_RED] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2016"> </a>
<a name="ln2017">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2018">  set_HSL_sliders(g-&gt;hue_lift, g-&gt;sat_lift, p-&gt;lift);</a>
<a name="ln2019">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2020"> </a>
<a name="ln2021">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2022">}</a>
<a name="ln2023">static void lift_green_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2024">{</a>
<a name="ln2025">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2026">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2027">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2028"> </a>
<a name="ln2029">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln2030"> </a>
<a name="ln2031">  p-&gt;lift[CHANNEL_GREEN] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2032"> </a>
<a name="ln2033">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2034">  set_HSL_sliders(g-&gt;hue_lift, g-&gt;sat_lift, p-&gt;lift);</a>
<a name="ln2035">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2036"> </a>
<a name="ln2037">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2038">}</a>
<a name="ln2039">static void lift_blue_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2040">{</a>
<a name="ln2041">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2042">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2043">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2044"> </a>
<a name="ln2045">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln2046"> </a>
<a name="ln2047">  p-&gt;lift[CHANNEL_BLUE] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2048"> </a>
<a name="ln2049">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2050">  set_HSL_sliders(g-&gt;hue_lift, g-&gt;sat_lift, p-&gt;lift);</a>
<a name="ln2051">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2052"> </a>
<a name="ln2053">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2054">}</a>
<a name="ln2055"> </a>
<a name="ln2056">static void gamma_factor_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2057">{</a>
<a name="ln2058">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2059">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2060">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2061"> </a>
<a name="ln2062">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln2063"> </a>
<a name="ln2064">  p-&gt;gamma[CHANNEL_FACTOR] = dt_bauhaus_slider_get(slider) / 100.0f + 1.0f;</a>
<a name="ln2065">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2066">}</a>
<a name="ln2067">static void gamma_red_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2068">{</a>
<a name="ln2069">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2070">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2071">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2072"> </a>
<a name="ln2073">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln2074"> </a>
<a name="ln2075">  p-&gt;gamma[CHANNEL_RED] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2076"> </a>
<a name="ln2077">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2078">  set_HSL_sliders(g-&gt;hue_gamma, g-&gt;sat_gamma, p-&gt;gamma);</a>
<a name="ln2079">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2080">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2081">}</a>
<a name="ln2082">static void gamma_green_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2083">{</a>
<a name="ln2084">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2085">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2086">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2087"> </a>
<a name="ln2088">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln2089"> </a>
<a name="ln2090">  p-&gt;gamma[CHANNEL_GREEN] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2091"> </a>
<a name="ln2092">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2093">  set_HSL_sliders(g-&gt;hue_gamma, g-&gt;sat_gamma, p-&gt;gamma);</a>
<a name="ln2094">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2095"> </a>
<a name="ln2096">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2097">}</a>
<a name="ln2098">static void gamma_blue_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2099">{</a>
<a name="ln2100">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2101">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2102">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2103"> </a>
<a name="ln2104">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln2105"> </a>
<a name="ln2106">  p-&gt;gamma[CHANNEL_BLUE] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2107"> </a>
<a name="ln2108">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2109">  set_HSL_sliders(g-&gt;hue_gamma, g-&gt;sat_gamma, p-&gt;gamma);</a>
<a name="ln2110">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2111">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2112">}</a>
<a name="ln2113"> </a>
<a name="ln2114">static void gain_factor_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2115">{</a>
<a name="ln2116">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2117">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2118">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2119"> </a>
<a name="ln2120">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln2121"> </a>
<a name="ln2122">  p-&gt;gain[CHANNEL_FACTOR] = dt_bauhaus_slider_get(slider) / 100.0f + 1.0f;</a>
<a name="ln2123">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2124">}</a>
<a name="ln2125">static void gain_red_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2126">{</a>
<a name="ln2127">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2128">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2129">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2130"> </a>
<a name="ln2131">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln2132"> </a>
<a name="ln2133">  p-&gt;gain[CHANNEL_RED] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2134"> </a>
<a name="ln2135">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2136">  set_HSL_sliders(g-&gt;hue_gain, g-&gt;sat_gain, p-&gt;gain);</a>
<a name="ln2137">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2138"> </a>
<a name="ln2139">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2140">}</a>
<a name="ln2141">static void gain_green_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2142">{</a>
<a name="ln2143">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2144">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2145">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2146"> </a>
<a name="ln2147">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln2148"> </a>
<a name="ln2149">  p-&gt;gain[CHANNEL_GREEN] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2150"> </a>
<a name="ln2151">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2152">  set_HSL_sliders(g-&gt;hue_gain, g-&gt;sat_gain, p-&gt;gain);</a>
<a name="ln2153">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2154">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2155">}</a>
<a name="ln2156">static void gain_blue_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2157">{</a>
<a name="ln2158">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2159">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2160">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2161"> </a>
<a name="ln2162">  dt_iop_color_picker_reset(&amp;g-&gt;color_picker, TRUE);</a>
<a name="ln2163"> </a>
<a name="ln2164">  p-&gt;gain[CHANNEL_BLUE] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2165"> </a>
<a name="ln2166">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2167">  set_HSL_sliders(g-&gt;hue_gain, g-&gt;sat_gain, p-&gt;gain);</a>
<a name="ln2168">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2169">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2170">}</a>
<a name="ln2171"> </a>
<a name="ln2172">#if 0</a>
<a name="ln2173">static gboolean dt_iop_area_draw(GtkWidget *widget, cairo_t *cr, dt_iop_module_t *self)</a>
<a name="ln2174">{</a>
<a name="ln2175">  float flt_bg = 0.5;</a>
<a name="ln2176">  if(gtk_widget_get_state_flags(widget) &amp; GTK_STATE_FLAG_SELECTED) flt_bg = 0.6;</a>
<a name="ln2177">  float flt_dark = flt_bg / 1.5, flt_light = flt_bg * 1.5;</a>
<a name="ln2178"> </a>
<a name="ln2179">  uint32_t bg = ((255 &lt;&lt; 24) | ((int)floor(flt_bg * 255 + 0.5) &lt;&lt; 16) | ((int)floor(flt_bg * 255 + 0.5) &lt;&lt; 8)</a>
<a name="ln2180">                 | (int)floor(flt_bg * 255 + 0.5));</a>
<a name="ln2181">  // bg = 0xffffffff;</a>
<a name="ln2182">  //   uint32_t dark = ((255 &lt;&lt; 24) |</a>
<a name="ln2183">  //                  ((int)floor(flt_dark * 255 + 0.5) &lt;&lt; 16) |</a>
<a name="ln2184">  //                  ((int)floor(flt_dark * 255 + 0.5) &lt;&lt; 8) |</a>
<a name="ln2185">  //                  (int)floor(flt_dark * 255 + 0.5));</a>
<a name="ln2186">  uint32_t light = ((255 &lt;&lt; 24) | ((int)floor(flt_light * 255 + 0.5) &lt;&lt; 16)</a>
<a name="ln2187">                    | ((int)floor(flt_light * 255 + 0.5) &lt;&lt; 8) | (int)floor(flt_light * 255 + 0.5));</a>
<a name="ln2188"> </a>
<a name="ln2189">  GtkAllocation allocation;</a>
<a name="ln2190">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln2191">  int width = allocation.width, height = allocation.height;</a>
<a name="ln2192">  if(width % 2 == 0) width--;</a>
<a name="ln2193">  if(height % 2 == 0) height--;</a>
<a name="ln2194">  double center_x = (float)width / 2.0, center_y = (float)height / 2.0;</a>
<a name="ln2195">  double diameter = MIN(width, height) - 4;</a>
<a name="ln2196">  double r_outside = diameter / 2.0, r_inside = r_outside * 0.87;</a>
<a name="ln2197">  double r_outside_2 = r_outside * r_outside, r_inside_2 = r_inside * r_inside;</a>
<a name="ln2198"> </a>
<a name="ln2199">  // clear the background</a>
<a name="ln2200">  cairo_set_source_rgb(cr, flt_bg, flt_bg, flt_bg);</a>
<a name="ln2201">  cairo_paint(cr);</a>
<a name="ln2202"> </a>
<a name="ln2203">  /* Create an image initialized with the ring colors */</a>
<a name="ln2204">  gint stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, width);</a>
<a name="ln2205">  guint32 *buf = (guint32 *)malloc(sizeof(guint32) * height * stride / 4);</a>
<a name="ln2206"> </a>
<a name="ln2207">  for(int y = 0; y &lt; height; y++)</a>
<a name="ln2208">  {</a>
<a name="ln2209">    guint32 *p = buf + y * width;</a>
<a name="ln2210"> </a>
<a name="ln2211">    double dy = -(y + 0.5 - center_y);</a>
<a name="ln2212"> </a>
<a name="ln2213">    for(int x = 0; x &lt; width; x++)</a>
<a name="ln2214">    {</a>
<a name="ln2215">      double dx = x + 0.5 - center_x;</a>
<a name="ln2216">      double dist = dx * dx + dy * dy;</a>
<a name="ln2217">      if(dist &lt; r_inside_2 || dist &gt; r_outside_2)</a>
<a name="ln2218">      {</a>
<a name="ln2219">        uint32_t col = bg;</a>
<a name="ln2220">        if((abs(dx) &lt; 1 &amp;&amp; abs(dy) &lt; 3) || (abs(dx) &lt; 3 &amp;&amp; abs(dy) &lt; 1)) col = light;</a>
<a name="ln2221">        *p++ = col;</a>
<a name="ln2222">        continue;</a>
<a name="ln2223">      }</a>
<a name="ln2224"> </a>
<a name="ln2225">      double angle = atan2(dy, dx) - M_PI_2;</a>
<a name="ln2226">      if(angle &lt; 0.0) angle += 2.0 * M_PI;</a>
<a name="ln2227"> </a>
<a name="ln2228">      double hue = angle / (2.0 * M_PI);</a>
<a name="ln2229"> </a>
<a name="ln2230">      float rgb[3];</a>
<a name="ln2231">      hsl2rgb(rgb, hue, 1.0, 0.5);</a>
<a name="ln2232"> </a>
<a name="ln2233">      *p++ = (((int)floor(rgb[0] * 255 + 0.5) &lt;&lt; 16) | ((int)floor(rgb[1] * 255 + 0.5) &lt;&lt; 8)</a>
<a name="ln2234">              | (int)floor(rgb[2] * 255 + 0.5));</a>
<a name="ln2235">    }</a>
<a name="ln2236">  }</a>
<a name="ln2237"> </a>
<a name="ln2238">  cairo_surface_t *source</a>
<a name="ln2239">      = cairo_image_surface_create_for_data((unsigned char *)buf, CAIRO_FORMAT_RGB24, width, height, stride);</a>
<a name="ln2240"> </a>
<a name="ln2241">  cairo_set_source_surface(cr, source, 0.0, 0.0);</a>
<a name="ln2242">  cairo_paint(cr);</a>
<a name="ln2243">  free(buf);</a>
<a name="ln2244"> </a>
<a name="ln2245">  // draw border</a>
<a name="ln2246">  float line_width = 1;</a>
<a name="ln2247">  cairo_set_line_width(cr, line_width);</a>
<a name="ln2248"> </a>
<a name="ln2249">  cairo_set_source_rgb(cr, flt_bg, flt_bg, flt_bg);</a>
<a name="ln2250">  cairo_new_path(cr);</a>
<a name="ln2251">  cairo_arc(cr, center_x, center_y, r_outside, 0.0, 2.0 * M_PI);</a>
<a name="ln2252">  cairo_stroke(cr);</a>
<a name="ln2253">  cairo_arc(cr, center_x, center_y, r_inside, 0.0, 2.0 * M_PI);</a>
<a name="ln2254">  cairo_stroke(cr);</a>
<a name="ln2255"> </a>
<a name="ln2256">  cairo_set_source_rgb(cr, flt_dark, flt_dark, flt_dark);</a>
<a name="ln2257">  cairo_new_path(cr);</a>
<a name="ln2258">  cairo_arc(cr, center_x, center_y, r_outside, M_PI, 1.5 * M_PI);</a>
<a name="ln2259">  cairo_stroke(cr);</a>
<a name="ln2260">  cairo_arc(cr, center_x, center_y, r_inside, 0.0, 0.5 * M_PI);</a>
<a name="ln2261">  cairo_stroke(cr);</a>
<a name="ln2262"> </a>
<a name="ln2263">  cairo_set_source_rgb(cr, flt_light, flt_light, flt_light);</a>
<a name="ln2264">  cairo_new_path(cr);</a>
<a name="ln2265">  cairo_arc(cr, center_x, center_y, r_outside, 0.0, 0.5 * M_PI);</a>
<a name="ln2266">  cairo_stroke(cr);</a>
<a name="ln2267">  cairo_arc(cr, center_x, center_y, r_inside, M_PI, 1.5 * M_PI);</a>
<a name="ln2268">  cairo_stroke(cr);</a>
<a name="ln2269"> </a>
<a name="ln2270">  // draw selector</a>
<a name="ln2271">  double r = 255 / 255.0, g = 155 / 255.0, b = 40 / 255.0;</a>
<a name="ln2272">  double h, s, v;</a>
<a name="ln2273"> </a>
<a name="ln2274">  gtk_rgb_to_hsv(r, g, b, &amp;h, &amp;s, &amp;v);</a>
<a name="ln2275"> </a>
<a name="ln2276">  cairo_save(cr);</a>
<a name="ln2277">  cairo_set_source_rgba(cr, 1.0, 1.0, 1.0, 0.7);</a>
<a name="ln2278"> </a>
<a name="ln2279">  cairo_translate(cr, center_x, center_y);</a>
<a name="ln2280">  cairo_rotate(cr, h * 2.0 * M_PI - M_PI_2);</a>
<a name="ln2281"> </a>
<a name="ln2282">  cairo_arc(cr, r_inside * v, 0.0, 3.0, 0, 2.0 * M_PI);</a>
<a name="ln2283">  cairo_stroke(cr);</a>
<a name="ln2284"> </a>
<a name="ln2285">  cairo_restore(cr);</a>
<a name="ln2286"> </a>
<a name="ln2287">  cairo_surface_destroy(source);</a>
<a name="ln2288"> </a>
<a name="ln2289">  return TRUE;</a>
<a name="ln2290">}</a>
<a name="ln2291">#endif</a>
<a name="ln2292"> </a>
<a name="ln2293">static void draw_hue_slider(GtkWidget *slider)</a>
<a name="ln2294">{</a>
<a name="ln2295">  dt_bauhaus_slider_set_stop(slider, 0.0f, 1.0f, 0.0f, 0.0f);</a>
<a name="ln2296">  dt_bauhaus_slider_set_stop(slider, 0.166f, 1.0f, 1.0f, 0.0f);</a>
<a name="ln2297">  dt_bauhaus_slider_set_stop(slider, 0.322f, 0.0f, 1.0f, 0.0f);</a>
<a name="ln2298">  dt_bauhaus_slider_set_stop(slider, 0.498f, 0.0f, 1.0f, 1.0f);</a>
<a name="ln2299">  dt_bauhaus_slider_set_stop(slider, 0.664f, 0.0f, 0.0f, 1.0f);</a>
<a name="ln2300">  dt_bauhaus_slider_set_stop(slider, 0.830f, 1.0f, 0.0f, 1.0f);</a>
<a name="ln2301">  dt_bauhaus_slider_set_stop(slider, 1.0f, 1.0f, 0.0f, 0.0f);</a>
<a name="ln2302">}</a>
<a name="ln2303"> </a>
<a name="ln2304">void gui_init(dt_iop_module_t *self)</a>
<a name="ln2305">{</a>
<a name="ln2306">  self-&gt;gui_data = malloc(sizeof(dt_iop_colorbalance_gui_data_t));</a>
<a name="ln2307">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2308">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2309"> </a>
<a name="ln2310">  g-&gt;mode = NULL;</a>
<a name="ln2311"> </a>
<a name="ln2312">  for (int k=0; k&lt;LEVELS; k++)</a>
<a name="ln2313">  {</a>
<a name="ln2314">    g-&gt;color_patches_flags[k] = INVALID;</a>
<a name="ln2315">    g-&gt;luma_patches_flags[k] = INVALID;</a>
<a name="ln2316">  }</a>
<a name="ln2317"> </a>
<a name="ln2318">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln2319">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln2320"> </a>
<a name="ln2321">  // mode choice</a>
<a name="ln2322">  g-&gt;mode = dt_bauhaus_combobox_new(self);</a>
<a name="ln2323">  dt_bauhaus_widget_set_label(g-&gt;mode, NULL, _(&quot;mode&quot;));</a>
<a name="ln2324">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;lift, gamma, gain (ProPhotoRGB)&quot;));</a>
<a name="ln2325">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;slope, offset, power (ProPhotoRGB)&quot;));</a>
<a name="ln2326">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;lift, gamma, gain (sRGB)&quot;));</a>
<a name="ln2327">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(g-&gt;mode), TRUE, TRUE, 0);</a>
<a name="ln2328">  gtk_widget_set_tooltip_text(g-&gt;mode, _(&quot;color-grading mapping method&quot;));</a>
<a name="ln2329">  g_signal_connect(G_OBJECT(g-&gt;mode), &quot;value-changed&quot;, G_CALLBACK(mode_callback), self);</a>
<a name="ln2330"> </a>
<a name="ln2331">  // control choice</a>
<a name="ln2332">  g-&gt;controls = dt_bauhaus_combobox_new(self);</a>
<a name="ln2333">  dt_bauhaus_widget_set_label(g-&gt;controls, NULL, _(&quot;color control sliders&quot;));</a>
<a name="ln2334">  dt_bauhaus_combobox_add(g-&gt;controls, _(&quot;HSL&quot;));</a>
<a name="ln2335">  dt_bauhaus_combobox_add(g-&gt;controls, _(&quot;RGBL&quot;));</a>
<a name="ln2336">  dt_bauhaus_combobox_add(g-&gt;controls, _(&quot;both&quot;));</a>
<a name="ln2337">  dt_bauhaus_combobox_set_default(g-&gt;controls, HSL);</a>
<a name="ln2338">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(g-&gt;controls), TRUE, TRUE, 0);</a>
<a name="ln2339">  gtk_widget_set_tooltip_text(g-&gt;controls, _(&quot;color-grading mapping method&quot;));</a>
<a name="ln2340">  g_signal_connect(G_OBJECT(g-&gt;controls), &quot;value-changed&quot;, G_CALLBACK(controls_callback), self);</a>
<a name="ln2341"> </a>
<a name="ln2342">  // master</a>
<a name="ln2343">  g-&gt;master_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln2344">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(g-&gt;master_box), TRUE, TRUE, 0);</a>
<a name="ln2345"> </a>
<a name="ln2346">  gtk_box_pack_start(GTK_BOX(g-&gt;master_box), dt_ui_section_label_new(_(&quot;master&quot;)), FALSE, FALSE, 2);</a>
<a name="ln2347"> </a>
<a name="ln2348">  g-&gt;saturation = dt_bauhaus_slider_new_with_range(self, 50.0, 150.0, 0.5, p-&gt;saturation * 100.0, 2);</a>
<a name="ln2349">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;saturation, 0.0f, 200.0f);</a>
<a name="ln2350">  dt_bauhaus_slider_set_format(g-&gt;saturation, &quot;%.2f %%&quot;);</a>
<a name="ln2351">  dt_bauhaus_widget_set_label(g-&gt;saturation, NULL, _(&quot;input saturation&quot;));</a>
<a name="ln2352">  gtk_box_pack_start(GTK_BOX(g-&gt;master_box), g-&gt;saturation, TRUE, TRUE, 0);</a>
<a name="ln2353">  gtk_widget_set_tooltip_text(g-&gt;saturation, _(&quot;saturation correction before the color balance&quot;));</a>
<a name="ln2354">  g_signal_connect(G_OBJECT(g-&gt;saturation), &quot;value-changed&quot;, G_CALLBACK(saturation_callback), self);</a>
<a name="ln2355"> </a>
<a name="ln2356">  g-&gt;saturation_out = dt_bauhaus_slider_new_with_range(self, 50.0, 150.0, 0.5, p-&gt;saturation_out * 100.0, 2);</a>
<a name="ln2357">  dt_bauhaus_slider_set_format(g-&gt;saturation_out, &quot;%.2f %%&quot;);</a>
<a name="ln2358">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;saturation_out, 0.0, 200.0f);</a>
<a name="ln2359">  dt_bauhaus_widget_set_label(g-&gt;saturation_out, NULL, _(&quot;output saturation&quot;));</a>
<a name="ln2360">  gtk_box_pack_start(GTK_BOX(g-&gt;master_box), g-&gt;saturation_out, TRUE, TRUE, 0);</a>
<a name="ln2361">  gtk_widget_set_tooltip_text(g-&gt;saturation_out, _(&quot;saturation correction after the color balance&quot;));</a>
<a name="ln2362">  g_signal_connect(G_OBJECT(g-&gt;saturation_out), &quot;value-changed&quot;, G_CALLBACK(saturation_out_callback), self);</a>
<a name="ln2363"> </a>
<a name="ln2364">  g-&gt;grey = dt_bauhaus_slider_new_with_range(self, 0.1, 100., 0.5, p-&gt;grey, 2);</a>
<a name="ln2365">  dt_bauhaus_widget_set_label(g-&gt;grey, NULL, _(&quot;contrast fulcrum&quot;));</a>
<a name="ln2366">  gtk_box_pack_start(GTK_BOX(g-&gt;master_box), g-&gt;grey, TRUE, TRUE, 0);</a>
<a name="ln2367">  dt_bauhaus_slider_set_format(g-&gt;grey, &quot;%.2f %%&quot;);</a>
<a name="ln2368">  gtk_widget_set_tooltip_text(g-&gt;grey, _(&quot;adjust to match a neutral tone&quot;));</a>
<a name="ln2369">  g_signal_connect(G_OBJECT(g-&gt;grey), &quot;value-changed&quot;, G_CALLBACK(grey_callback), self);</a>
<a name="ln2370">  dt_bauhaus_widget_set_quad_paint(g-&gt;grey, dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2371">  dt_bauhaus_widget_set_quad_toggle(g-&gt;grey, TRUE);</a>
<a name="ln2372">  g_signal_connect(G_OBJECT(g-&gt;grey), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2373"> </a>
<a name="ln2374">  g-&gt;contrast = dt_bauhaus_slider_new_with_range(self, -50, 50, 0.5, (p-&gt;contrast - 1.0f)*100.0f, 2);</a>
<a name="ln2375">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;contrast, -99, 99);</a>
<a name="ln2376">  dt_bauhaus_slider_set_format(g-&gt;contrast, &quot;%+.2f %%&quot;);</a>
<a name="ln2377">  dt_bauhaus_widget_set_label(g-&gt;contrast, NULL, _(&quot;contrast&quot;));</a>
<a name="ln2378">  gtk_box_pack_start(GTK_BOX(g-&gt;master_box), g-&gt;contrast, TRUE, TRUE, 0);</a>
<a name="ln2379">  gtk_widget_set_tooltip_text(g-&gt;contrast, _(&quot;contrast&quot;));</a>
<a name="ln2380">  g_signal_connect(G_OBJECT(g-&gt;contrast), &quot;value-changed&quot;, G_CALLBACK(contrast_callback), self);</a>
<a name="ln2381"> </a>
<a name="ln2382"> </a>
<a name="ln2383">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, DT_BAUHAUS_SPACE);</a>
<a name="ln2384">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), hbox, FALSE, FALSE, 0);</a>
<a name="ln2385"> </a>
<a name="ln2386">#if 0//def SHOW_COLOR_WHEELS</a>
<a name="ln2387">  GtkWidget *area = dtgtk_drawing_area_new_with_aspect_ratio(1.0);</a>
<a name="ln2388">  gtk_box_pack_start(GTK_BOX(hbox), area, TRUE, TRUE, 0);</a>
<a name="ln2389"> </a>
<a name="ln2390">  //   gtk_widget_add_events(g-&gt;area,</a>
<a name="ln2391">  //                         GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |</a>
<a name="ln2392">  //                         GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_LEAVE_NOTIFY_MASK);</a>
<a name="ln2393">  g_signal_connect(G_OBJECT(area), &quot;draw&quot;, G_CALLBACK(dt_iop_area_draw), self);</a>
<a name="ln2394">  //   g_signal_connect (G_OBJECT (area), &quot;button-press-event&quot;,</a>
<a name="ln2395">  //                     G_CALLBACK (dt_iop_colorbalance_button_press), self);</a>
<a name="ln2396">  //   g_signal_connect (G_OBJECT (area), &quot;motion-notify-event&quot;,</a>
<a name="ln2397">  //                     G_CALLBACK (dt_iop_colorbalance_motion_notify), self);</a>
<a name="ln2398">  //   g_signal_connect (G_OBJECT (area), &quot;leave-notify-event&quot;,</a>
<a name="ln2399">  //                     G_CALLBACK (dt_iop_colorbalance_leave_notify), self);</a>
<a name="ln2400"> </a>
<a name="ln2401">  area = dtgtk_drawing_area_new_with_aspect_ratio(1.0);</a>
<a name="ln2402">  gtk_box_pack_start(GTK_BOX(hbox), area, TRUE, TRUE, 0);</a>
<a name="ln2403"> </a>
<a name="ln2404">  //   gtk_widget_add_events(g-&gt;area,</a>
<a name="ln2405">  //                         GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |</a>
<a name="ln2406">  //                         GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_LEAVE_NOTIFY_MASK);</a>
<a name="ln2407">  g_signal_connect(G_OBJECT(area), &quot;draw&quot;, G_CALLBACK(dt_iop_area_draw), self);</a>
<a name="ln2408">  //   g_signal_connect (G_OBJECT (area), &quot;button-press-event&quot;,</a>
<a name="ln2409">  //                     G_CALLBACK (dt_iop_colorbalance_button_press), self);</a>
<a name="ln2410">  //   g_signal_connect (G_OBJECT (area), &quot;motion-notify-event&quot;,</a>
<a name="ln2411">  //                     G_CALLBACK (dt_iop_colorbalance_motion_notify), self);</a>
<a name="ln2412">  //   g_signal_connect (G_OBJECT (area), &quot;leave-notify-event&quot;,</a>
<a name="ln2413">  //                     G_CALLBACK (dt_iop_colorbalance_leave_notify), self);</a>
<a name="ln2414"> </a>
<a name="ln2415">  area = dtgtk_drawing_area_new_with_aspect_ratio(1.0);</a>
<a name="ln2416">  gtk_box_pack_start(GTK_BOX(hbox), area, TRUE, TRUE, 0);</a>
<a name="ln2417"> </a>
<a name="ln2418">  //   gtk_widget_add_events(g-&gt;area,</a>
<a name="ln2419">  //                         GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |</a>
<a name="ln2420">  //                         GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_LEAVE_NOTIFY_MASK);</a>
<a name="ln2421">  g_signal_connect(G_OBJECT(area), &quot;draw&quot;, G_CALLBACK(dt_iop_area_draw), self);</a>
<a name="ln2422">//   g_signal_connect (G_OBJECT (area), &quot;button-press-event&quot;,</a>
<a name="ln2423">//                     G_CALLBACK (dt_iop_colorbalance_button_press), self);</a>
<a name="ln2424">//   g_signal_connect (G_OBJECT (area), &quot;motion-notify-event&quot;,</a>
<a name="ln2425">//                     G_CALLBACK (dt_iop_colorbalance_motion_notify), self);</a>
<a name="ln2426">//   g_signal_connect (G_OBJECT (area), &quot;leave-notify-event&quot;,</a>
<a name="ln2427">//                     G_CALLBACK (dt_iop_colorbalance_leave_notify), self);</a>
<a name="ln2428">#endif</a>
<a name="ln2429"> </a>
<a name="ln2430">#define ADD_FACTOR(which)                                                                                         \</a>
<a name="ln2431">  g-&gt;which##_factor = dt_bauhaus_slider_new_with_range_and_feedback(self, -50.0, 50.0, 0.5,                      \</a>
<a name="ln2432">                                                                    (p-&gt;which[CHANNEL_FACTOR] - 1.0f) * 100.0f, 2, 0);       \</a>
<a name="ln2433">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;which##_factor, -100.0, 100.0);                                         \</a>
<a name="ln2434">  dt_bauhaus_slider_set_format(g-&gt;which##_factor, &quot;%.2f %%&quot;);                                                     \</a>
<a name="ln2435">  dt_bauhaus_slider_set_stop(g-&gt;which##_factor, 0.0, 0.0, 0.0, 0.0);                                              \</a>
<a name="ln2436">  dt_bauhaus_slider_set_stop(g-&gt;which##_factor, 1.0, 1.0, 1.0, 1.0);                                              \</a>
<a name="ln2437">  gtk_widget_set_tooltip_text(g-&gt;which##_factor, _(&quot;factor of &quot; #which));                                         \</a>
<a name="ln2438">  dt_bauhaus_widget_set_label(g-&gt;which##_factor, _(#which), _(&quot;factor&quot;));                                         \</a>
<a name="ln2439">  g_signal_connect(G_OBJECT(g-&gt;which##_factor), &quot;value-changed&quot;, G_CALLBACK(which##_factor_callback), self);      \</a>
<a name="ln2440">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;which##_factor, TRUE, TRUE, 0);                                    \</a>
<a name="ln2441">  dt_bauhaus_widget_set_quad_paint(g-&gt;which##_factor, dtgtk_cairo_paint_colorpicker,                              \</a>
<a name="ln2442">                                   CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);                                 \</a>
<a name="ln2443">  dt_bauhaus_widget_set_quad_toggle(g-&gt;which##_factor, TRUE);                                                     \</a>
<a name="ln2444">  g_signal_connect(G_OBJECT(g-&gt;which##_factor), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2445"> </a>
<a name="ln2446">#define ADD_CHANNEL(which, c, n, N) \</a>
<a name="ln2447">  g-&gt;which##_##c = dt_bauhaus_slider_new_with_range_and_feedback(self, -0.5, 0.5, 0.0005, p-&gt;which[CHANNEL_##N] - 1.0f, 5, 0);\</a>
<a name="ln2448">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;which##_##c, -1.0, 1.0); \</a>
<a name="ln2449">  gtk_widget_set_tooltip_text(g-&gt;which##_##c, _(&quot;factor of &quot; #n &quot; for &quot; #which));\</a>
<a name="ln2450">  dt_bauhaus_widget_set_label(g-&gt;which##_##c, _(#which), _(#n));\</a>
<a name="ln2451">  g_signal_connect(G_OBJECT(g-&gt;which##_##c), &quot;value-changed&quot;, G_CALLBACK(which##_##n##_callback), self);\</a>
<a name="ln2452">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;which##_##c, TRUE, TRUE, 0);</a>
<a name="ln2453"> </a>
<a name="ln2454">  /* lift */</a>
<a name="ln2455">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), dt_ui_section_label_new(_(&quot;shadows : lift / offset&quot;)), FALSE, FALSE, 5);</a>
<a name="ln2456"> </a>
<a name="ln2457">  static const char *lift_messages[] = { N_(&quot;factor of lift&quot;), N_(&quot;lift&quot;) };</a>
<a name="ln2458">  (void)lift_messages;</a>
<a name="ln2459">  ADD_FACTOR(lift)</a>
<a name="ln2460"> </a>
<a name="ln2461">  g-&gt;hue_lift = dt_bauhaus_slider_new_with_range_and_feedback(self, 0.0f, 360.0f, 0.5f, 0.0f, 2, 0);</a>
<a name="ln2462">  dt_bauhaus_widget_set_label(g-&gt;hue_lift, NULL, _(&quot;hue&quot;));</a>
<a name="ln2463">  dt_bauhaus_slider_set_format(g-&gt;hue_lift, &quot;%.2f ¬∞&quot;);</a>
<a name="ln2464">  draw_hue_slider(g-&gt;hue_lift);</a>
<a name="ln2465">  gtk_widget_set_tooltip_text(g-&gt;hue_lift, _(&quot;select the hue&quot;));</a>
<a name="ln2466">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;hue_lift, TRUE, TRUE, 0);</a>
<a name="ln2467">  g_signal_connect(G_OBJECT(g-&gt;hue_lift), &quot;value-changed&quot;, G_CALLBACK(hue_lift_callback), self);</a>
<a name="ln2468">  dt_bauhaus_widget_set_quad_paint(g-&gt;hue_lift, dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2469">  dt_bauhaus_widget_set_quad_toggle(g-&gt;hue_lift, TRUE);</a>
<a name="ln2470">  g_signal_connect(G_OBJECT(g-&gt;hue_lift), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2471"> </a>
<a name="ln2472">  g-&gt;sat_lift = dt_bauhaus_slider_new_with_range_and_feedback(self, 0.0f, 25.0f, 0.5f, 0.0f, 2, 0);</a>
<a name="ln2473">  dt_bauhaus_slider_set_format(g-&gt;sat_lift, &quot;%.2f %%&quot;);</a>
<a name="ln2474">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;sat_lift, 0.0f, 100.0f);</a>
<a name="ln2475">  dt_bauhaus_widget_set_label(g-&gt;sat_lift, NULL, _(&quot;saturation&quot;));</a>
<a name="ln2476">  dt_bauhaus_slider_set_stop(g-&gt;sat_lift, 0.0f, 0.2f, 0.2f, 0.2f);</a>
<a name="ln2477">  dt_bauhaus_slider_set_stop(g-&gt;sat_lift, 1.0f, 1.0f, 1.0f, 1.0f);</a>
<a name="ln2478">  gtk_widget_set_tooltip_text(g-&gt;sat_lift, _(&quot;select the saturation&quot;));</a>
<a name="ln2479">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;sat_lift, TRUE, TRUE, 0);</a>
<a name="ln2480">  g_signal_connect(G_OBJECT(g-&gt;sat_lift), &quot;value-changed&quot;, G_CALLBACK(sat_lift_callback), self);</a>
<a name="ln2481"> </a>
<a name="ln2482"> </a>
<a name="ln2483">  static const char *lift_red_messages[] = { N_(&quot;factor of red for lift&quot;), N_(&quot;red&quot;) };</a>
<a name="ln2484">  (void)lift_red_messages;</a>
<a name="ln2485">  ADD_CHANNEL(lift, r, red, RED)</a>
<a name="ln2486">  dt_bauhaus_slider_set_stop(g-&gt;lift_r, 0.0, 0.0, 1.0, 1.0);</a>
<a name="ln2487">  dt_bauhaus_slider_set_stop(g-&gt;lift_r, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2488">  dt_bauhaus_slider_set_stop(g-&gt;lift_r, 1.0, 1.0, 0.0, 0.0);</a>
<a name="ln2489"> </a>
<a name="ln2490">  static const char *lift_green_messages[] = { N_(&quot;factor of green for lift&quot;), N_(&quot;green&quot;) };</a>
<a name="ln2491">  (void)lift_green_messages;</a>
<a name="ln2492">  ADD_CHANNEL(lift, g, green, GREEN)</a>
<a name="ln2493">  dt_bauhaus_slider_set_stop(g-&gt;lift_g, 0.0, 1.0, 0.0, 1.0);</a>
<a name="ln2494">  dt_bauhaus_slider_set_stop(g-&gt;lift_g, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2495">  dt_bauhaus_slider_set_stop(g-&gt;lift_g, 1.0, 0.0, 1.0, 0.0);</a>
<a name="ln2496"> </a>
<a name="ln2497">  static const char *lift_blue_messages[] = { N_(&quot;factor of blue for lift&quot;), N_(&quot;blue&quot;) };</a>
<a name="ln2498">  (void)lift_blue_messages;</a>
<a name="ln2499">  ADD_CHANNEL(lift, b, blue, BLUE)</a>
<a name="ln2500">  dt_bauhaus_slider_set_stop(g-&gt;lift_b, 0.0, 1.0, 1.0, 0.0);</a>
<a name="ln2501">  dt_bauhaus_slider_set_stop(g-&gt;lift_b, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2502">  dt_bauhaus_slider_set_stop(g-&gt;lift_b, 1.0, 0.0, 0.0, 1.0);</a>
<a name="ln2503"> </a>
<a name="ln2504">  /* gamma */</a>
<a name="ln2505">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), dt_ui_section_label_new(_(&quot;mid-tones : gamma / power&quot;)), FALSE, FALSE, 5);</a>
<a name="ln2506"> </a>
<a name="ln2507">  static const char *gamma_messages[] = { N_(&quot;factor of gamma&quot;), N_(&quot;gamma&quot;) };</a>
<a name="ln2508">  (void)gamma_messages;</a>
<a name="ln2509">  ADD_FACTOR(gamma)</a>
<a name="ln2510"> </a>
<a name="ln2511">  g-&gt;hue_gamma = dt_bauhaus_slider_new_with_range_and_feedback(self, 0.0f, 360.0f, 0.5f, 0.0f, 2, 0);</a>
<a name="ln2512">  dt_bauhaus_widget_set_label(g-&gt;hue_gamma, NULL, _(&quot;hue&quot;));</a>
<a name="ln2513">  dt_bauhaus_slider_set_format(g-&gt;hue_gamma, &quot;%.2f ¬∞&quot;);</a>
<a name="ln2514">  draw_hue_slider(g-&gt;hue_gamma);</a>
<a name="ln2515">  gtk_widget_set_tooltip_text(g-&gt;hue_gamma, _(&quot;select the hue&quot;));</a>
<a name="ln2516">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;hue_gamma, TRUE, TRUE, 0);</a>
<a name="ln2517">  g_signal_connect(G_OBJECT(g-&gt;hue_gamma), &quot;value-changed&quot;, G_CALLBACK(hue_gamma_callback), self);</a>
<a name="ln2518">  dt_bauhaus_widget_set_quad_paint(g-&gt;hue_gamma, dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2519">  dt_bauhaus_widget_set_quad_toggle(g-&gt;hue_gamma, TRUE);</a>
<a name="ln2520">  g_signal_connect(G_OBJECT(g-&gt;hue_gamma), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2521"> </a>
<a name="ln2522">  g-&gt;sat_gamma = dt_bauhaus_slider_new_with_range_and_feedback(self, 0.0f, 25.0f, 0.5f, 0.0f, 2, 0);</a>
<a name="ln2523">  dt_bauhaus_slider_set_format(g-&gt;sat_gamma, &quot;%.2f %%&quot;);</a>
<a name="ln2524">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;sat_gamma, 0.0f, 100.0f);</a>
<a name="ln2525">  dt_bauhaus_widget_set_label(g-&gt;sat_gamma, NULL, _(&quot;saturation&quot;));</a>
<a name="ln2526">  dt_bauhaus_slider_set_stop(g-&gt;sat_gamma, 0.0f, 0.2f, 0.2f, 0.2f);</a>
<a name="ln2527">  dt_bauhaus_slider_set_stop(g-&gt;sat_gamma, 1.0f, 1.0f, 1.0f, 1.0f);</a>
<a name="ln2528">  gtk_widget_set_tooltip_text(g-&gt;sat_gamma, _(&quot;select the saturation&quot;));</a>
<a name="ln2529">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;sat_gamma, TRUE, TRUE, 0);</a>
<a name="ln2530">  g_signal_connect(G_OBJECT(g-&gt;sat_gamma), &quot;value-changed&quot;, G_CALLBACK(sat_gamma_callback), self);</a>
<a name="ln2531"> </a>
<a name="ln2532">  static const char *gamma_red_messages[] = { N_(&quot;factor of red for gamma&quot;) };</a>
<a name="ln2533">  (void)gamma_red_messages;</a>
<a name="ln2534">  ADD_CHANNEL(gamma, r, red, RED)</a>
<a name="ln2535">  dt_bauhaus_slider_set_stop(g-&gt;gamma_r, 0.0, 0.0, 1.0, 1.0);</a>
<a name="ln2536">  dt_bauhaus_slider_set_stop(g-&gt;gamma_r, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2537">  dt_bauhaus_slider_set_stop(g-&gt;gamma_r, 1.0, 1.0, 0.0, 0.0);</a>
<a name="ln2538"> </a>
<a name="ln2539">  static const char *gamma_green_messages[] = { N_(&quot;factor of green for gamma&quot;) };</a>
<a name="ln2540">  (void)gamma_green_messages;</a>
<a name="ln2541">  ADD_CHANNEL(gamma, g, green, GREEN)</a>
<a name="ln2542">  dt_bauhaus_slider_set_stop(g-&gt;gamma_g, 0.0, 1.0, 0.0, 1.0);</a>
<a name="ln2543">  dt_bauhaus_slider_set_stop(g-&gt;gamma_g, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2544">  dt_bauhaus_slider_set_stop(g-&gt;gamma_g, 1.0, 0.0, 1.0, 0.0);</a>
<a name="ln2545"> </a>
<a name="ln2546">  static const char *gamma_blue_messages[] = { N_(&quot;factor of blue for gamma&quot;) };</a>
<a name="ln2547">  (void)gamma_blue_messages;</a>
<a name="ln2548">  ADD_CHANNEL(gamma, b, blue, BLUE)</a>
<a name="ln2549">  dt_bauhaus_slider_set_stop(g-&gt;gamma_b, 0.0, 1.0, 1.0, 0.0);</a>
<a name="ln2550">  dt_bauhaus_slider_set_stop(g-&gt;gamma_b, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2551">  dt_bauhaus_slider_set_stop(g-&gt;gamma_b, 1.0, 0.0, 0.0, 1.0);</a>
<a name="ln2552"> </a>
<a name="ln2553">  /* gain */</a>
<a name="ln2554">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), dt_ui_section_label_new(_(&quot;highlights : gain / slope&quot;)), FALSE, FALSE, 5);</a>
<a name="ln2555"> </a>
<a name="ln2556">  static const char *gain_messages[] = { N_(&quot;factor of gain&quot;), N_(&quot;gain&quot;) };</a>
<a name="ln2557">  (void)gain_messages;</a>
<a name="ln2558">  ADD_FACTOR(gain)</a>
<a name="ln2559"> </a>
<a name="ln2560">  g-&gt;hue_gain = dt_bauhaus_slider_new_with_range_and_feedback(self, 0.0f, 360.0f, 0.05f, 0.0f, 2, 0);</a>
<a name="ln2561">  dt_bauhaus_widget_set_label(g-&gt;hue_gain, NULL, _(&quot;hue&quot;));</a>
<a name="ln2562">  dt_bauhaus_slider_set_format(g-&gt;hue_gain, &quot;%.2f ¬∞&quot;);</a>
<a name="ln2563">  draw_hue_slider(g-&gt;hue_gain);</a>
<a name="ln2564">  gtk_widget_set_tooltip_text(g-&gt;hue_gain, _(&quot;select the hue&quot;));</a>
<a name="ln2565">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;hue_gain, TRUE, TRUE, 0);</a>
<a name="ln2566">  g_signal_connect(G_OBJECT(g-&gt;hue_gain), &quot;value-changed&quot;, G_CALLBACK(hue_gain_callback), self);</a>
<a name="ln2567">  dt_bauhaus_widget_set_quad_paint(g-&gt;hue_gain, dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2568">  dt_bauhaus_widget_set_quad_toggle(g-&gt;hue_gain, TRUE);</a>
<a name="ln2569">  g_signal_connect(G_OBJECT(g-&gt;hue_gain), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2570"> </a>
<a name="ln2571">  g-&gt;sat_gain = dt_bauhaus_slider_new_with_range_and_feedback(self, 0.0f, 25.0f, 0.5f, 0.0f, 2, 0);</a>
<a name="ln2572">  dt_bauhaus_slider_set_format(g-&gt;sat_gain, &quot;%.2f %%&quot;);</a>
<a name="ln2573">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;sat_gain, 0.0f, 100.0f);</a>
<a name="ln2574">  dt_bauhaus_widget_set_label(g-&gt;sat_gain, NULL, _(&quot;saturation&quot;));</a>
<a name="ln2575">  dt_bauhaus_slider_set_stop(g-&gt;sat_gain, 0.0f, 0.2f, 0.2f, 0.2f);</a>
<a name="ln2576">  dt_bauhaus_slider_set_stop(g-&gt;sat_gain, 1.0f, 1.0f, 1.0f, 1.0f);</a>
<a name="ln2577">  gtk_widget_set_tooltip_text(g-&gt;sat_gain, _(&quot;select the saturation&quot;));</a>
<a name="ln2578">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;sat_gain, TRUE, TRUE, 0);</a>
<a name="ln2579">  g_signal_connect(G_OBJECT(g-&gt;sat_gain), &quot;value-changed&quot;, G_CALLBACK(sat_gain_callback), self);</a>
<a name="ln2580"> </a>
<a name="ln2581">  static const char *gain_red_messages[] = { N_(&quot;factor of red for gain&quot;) };</a>
<a name="ln2582">  (void)gain_red_messages;</a>
<a name="ln2583">  ADD_CHANNEL(gain, r, red, RED)</a>
<a name="ln2584">  dt_bauhaus_slider_set_stop(g-&gt;gain_r, 0.0, 0.0, 1.0, 1.0);</a>
<a name="ln2585">  dt_bauhaus_slider_set_stop(g-&gt;gain_r, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2586">  dt_bauhaus_slider_set_stop(g-&gt;gain_r, 1.0, 1.0, 0.0, 0.0);</a>
<a name="ln2587"> </a>
<a name="ln2588">  static const char *gain_green_messages[] = { N_(&quot;factor of green for gain&quot;) };</a>
<a name="ln2589">  (void)gain_green_messages;</a>
<a name="ln2590">  ADD_CHANNEL(gain, g, green, GREEN)</a>
<a name="ln2591">  dt_bauhaus_slider_set_stop(g-&gt;gain_g, 0.0, 1.0, 0.0, 1.0);</a>
<a name="ln2592">  dt_bauhaus_slider_set_stop(g-&gt;gain_g, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2593">  dt_bauhaus_slider_set_stop(g-&gt;gain_g, 1.0, 0.0, 1.0, 0.0);</a>
<a name="ln2594"> </a>
<a name="ln2595">  static const char *gain_blue_messages[] = { N_(&quot;factor of blue for gain&quot;) };</a>
<a name="ln2596">  (void)gain_blue_messages;</a>
<a name="ln2597">  ADD_CHANNEL(gain, b, blue, BLUE)</a>
<a name="ln2598">  dt_bauhaus_slider_set_stop(g-&gt;gain_b, 0.0, 1.0, 1.0, 0.0);</a>
<a name="ln2599">  dt_bauhaus_slider_set_stop(g-&gt;gain_b, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2600">  dt_bauhaus_slider_set_stop(g-&gt;gain_b, 1.0, 0.0, 0.0, 1.0);</a>
<a name="ln2601"> </a>
<a name="ln2602">  g-&gt;optim_label =  dt_ui_section_label_new(_(&quot;auto optimizers&quot;));</a>
<a name="ln2603">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;optim_label, FALSE, FALSE, 5);</a>
<a name="ln2604"> </a>
<a name="ln2605">  GtkBox *box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5));</a>
<a name="ln2606">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(box), TRUE, TRUE, 0);</a>
<a name="ln2607"> </a>
<a name="ln2608">  g-&gt;auto_luma = dt_bauhaus_combobox_new(self);</a>
<a name="ln2609">  dt_bauhaus_widget_set_label(g-&gt;auto_luma, NULL, _(&quot;optimize luma&quot;));</a>
<a name="ln2610">  dt_bauhaus_widget_set_quad_paint(g-&gt;auto_luma, dtgtk_cairo_paint_colorpicker,</a>
<a name="ln2611">                                   CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2612">  dt_bauhaus_widget_set_quad_toggle(g-&gt;auto_luma, TRUE);</a>
<a name="ln2613">  g_signal_connect(G_OBJECT(g-&gt;auto_luma), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2614">  gtk_widget_set_tooltip_text(g-&gt;auto_luma, _(&quot;fit the whole histogram and center the average luma&quot;));</a>
<a name="ln2615">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;auto_luma, TRUE, TRUE, 0);</a>
<a name="ln2616"> </a>
<a name="ln2617">  g-&gt;auto_color = dt_bauhaus_combobox_new(self);</a>
<a name="ln2618">  dt_bauhaus_widget_set_label(g-&gt;auto_color, NULL, _(&quot;neutralize colors&quot;));</a>
<a name="ln2619">  dt_bauhaus_widget_set_quad_paint(g-&gt;auto_color, dtgtk_cairo_paint_colorpicker,</a>
<a name="ln2620">                                   CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2621">  dt_bauhaus_widget_set_quad_toggle(g-&gt;auto_color, TRUE);</a>
<a name="ln2622">  g_signal_connect(G_OBJECT(g-&gt;auto_color), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2623">  gtk_widget_set_tooltip_text(g-&gt;auto_color, _(&quot;optimize the RGB curves to remove color casts&quot;));</a>
<a name="ln2624">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;auto_color, TRUE, TRUE, 0);</a>
<a name="ln2625"> </a>
<a name="ln2626">  // default control is HSL</a>
<a name="ln2627">  gtk_widget_set_visible(g-&gt;lift_r, FALSE);</a>
<a name="ln2628">  gtk_widget_set_visible(g-&gt;lift_g, FALSE);</a>
<a name="ln2629">  gtk_widget_set_visible(g-&gt;lift_b, FALSE);</a>
<a name="ln2630">  gtk_widget_set_visible(g-&gt;gamma_r, FALSE);</a>
<a name="ln2631">  gtk_widget_set_visible(g-&gt;gamma_g, FALSE);</a>
<a name="ln2632">  gtk_widget_set_visible(g-&gt;gamma_b, FALSE);</a>
<a name="ln2633">  gtk_widget_set_visible(g-&gt;gain_r, FALSE);</a>
<a name="ln2634">  gtk_widget_set_visible(g-&gt;gain_g, FALSE);</a>
<a name="ln2635">  gtk_widget_set_visible(g-&gt;gain_b, FALSE);</a>
<a name="ln2636"> </a>
<a name="ln2637">  gtk_widget_set_visible(g-&gt;hue_lift, TRUE);</a>
<a name="ln2638">  gtk_widget_set_visible(g-&gt;sat_lift, TRUE);</a>
<a name="ln2639">  gtk_widget_set_visible(g-&gt;hue_gamma, TRUE);</a>
<a name="ln2640">  gtk_widget_set_visible(g-&gt;sat_gamma, TRUE);</a>
<a name="ln2641">  gtk_widget_set_visible(g-&gt;hue_gain, TRUE);</a>
<a name="ln2642">  gtk_widget_set_visible(g-&gt;sat_gain, TRUE);</a>
<a name="ln2643"> </a>
<a name="ln2644">#undef ADD_FACTOR</a>
<a name="ln2645">#undef ADD_CHANNEL</a>
<a name="ln2646"> </a>
<a name="ln2647">  init_picker(&amp;g-&gt;color_picker,</a>
<a name="ln2648">              self,</a>
<a name="ln2649">              DT_COLOR_PICKER_AREA,</a>
<a name="ln2650">              _iop_color_picker_get_set,</a>
<a name="ln2651">              _iop_color_picker_apply,</a>
<a name="ln2652">              _iop_color_picker_update);</a>
<a name="ln2653"> </a>
<a name="ln2654">}</a>
<a name="ln2655"> </a>
<a name="ln2656">void gui_cleanup(dt_iop_module_t *self)</a>
<a name="ln2657">{</a>
<a name="ln2658">  // nothing else necessary, gtk will clean up the slider.</a>
<a name="ln2659">  free(self-&gt;gui_data);</a>
<a name="ln2660">  self-&gt;gui_data = NULL;</a>
<a name="ln2661">}</a>
<a name="ln2662"> </a>
<a name="ln2663">/** additional, optional callbacks to capture darkroom center events. */</a>
<a name="ln2664">// int mouse_moved(dt_iop_module_t *self, double x, double y, double pressure, int which);</a>
<a name="ln2665">// int button_pressed(dt_iop_module_t *self, double x, double y, double pressure, int which, int type,</a>
<a name="ln2666">// uint32_t state);</a>
<a name="ln2667">// int button_released(struct dt_iop_module_t *self, double x, double y, int which, uint32_t state);</a>
<a name="ln2668">// int scrolled(dt_iop_module_t *self, double x, double y, int up, uint32_t state);</a>
<a name="ln2669"> </a>
<a name="ln2670">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2671">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2672">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="227"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'n->contrast' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 225, 227.</p></div>
<div class="balloon" rel="1445"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1445, 1430.</p></div>
<div class="balloon" rel="1446"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1446, 1431.</p></div>
<div class="balloon" rel="1461"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 1461, 1459.</p></div>
<div class="balloon" rel="2310"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 2310, 2306.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
