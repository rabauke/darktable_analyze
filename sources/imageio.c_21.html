
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika.</a>
<a name="ln4">    copyright (c) 2010--2011 henrik andersson.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#ifdef HAVE_CONFIG_H</a>
<a name="ln20">#include &quot;config.h&quot;</a>
<a name="ln21">#endif</a>
<a name="ln22">#include &quot;common/colorlabels.h&quot;</a>
<a name="ln23">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln24">#include &quot;common/darktable.h&quot;</a>
<a name="ln25">#include &quot;common/debug.h&quot;</a>
<a name="ln26">#include &quot;common/exif.h&quot;</a>
<a name="ln27">#include &quot;common/image_cache.h&quot;</a>
<a name="ln28">#include &quot;common/imageio.h&quot;</a>
<a name="ln29">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln30">#ifdef HAVE_OPENEXR</a>
<a name="ln31">#include &quot;common/imageio_exr.h&quot;</a>
<a name="ln32">#endif</a>
<a name="ln33">#ifdef HAVE_OPENJPEG</a>
<a name="ln34">#include &quot;common/imageio_j2k.h&quot;</a>
<a name="ln35">#endif</a>
<a name="ln36">#include &quot;common/image_compression.h&quot;</a>
<a name="ln37">#include &quot;common/imageio_gm.h&quot;</a>
<a name="ln38">#include &quot;common/imageio_jpeg.h&quot;</a>
<a name="ln39">#include &quot;common/imageio_pfm.h&quot;</a>
<a name="ln40">#include &quot;common/imageio_png.h&quot;</a>
<a name="ln41">#include &quot;common/imageio_pnm.h&quot;</a>
<a name="ln42">#include &quot;common/imageio_rawspeed.h&quot;</a>
<a name="ln43">#include &quot;common/imageio_rgbe.h&quot;</a>
<a name="ln44">#include &quot;common/imageio_tiff.h&quot;</a>
<a name="ln45">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln46">#include &quot;common/styles.h&quot;</a>
<a name="ln47">#include &quot;control/conf.h&quot;</a>
<a name="ln48">#include &quot;control/control.h&quot;</a>
<a name="ln49">#include &quot;develop/blend.h&quot;</a>
<a name="ln50">#include &quot;develop/develop.h&quot;</a>
<a name="ln51">#include &quot;develop/imageop.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">#ifdef HAVE_GRAPHICSMAGICK</a>
<a name="ln54">#include &lt;magick/api.h&gt;</a>
<a name="ln55">#include &lt;magick/blob.h&gt;</a>
<a name="ln56">#endif</a>
<a name="ln57"> </a>
<a name="ln58">#include &lt;assert.h&gt;</a>
<a name="ln59">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln60">#include &lt;inttypes.h&gt;</a>
<a name="ln61">#include &lt;math.h&gt;</a>
<a name="ln62">#include &lt;stdio.h&gt;</a>
<a name="ln63">#include &lt;stdlib.h&gt;</a>
<a name="ln64">#include &lt;string.h&gt;</a>
<a name="ln65">#include &lt;strings.h&gt;</a>
<a name="ln66"> </a>
<a name="ln67">#ifdef USE_LUA</a>
<a name="ln68">#include &quot;lua/image.h&quot;</a>
<a name="ln69">#endif</a>
<a name="ln70"> </a>
<a name="ln71">// load a full-res thumbnail:</a>
<a name="ln72">int dt_imageio_large_thumbnail(const char *filename, uint8_t **buffer, int32_t *width, int32_t *height,</a>
<a name="ln73">                               dt_colorspaces_color_profile_type_t *color_space)</a>
<a name="ln74">{</a>
<a name="ln75">  int res = 1;</a>
<a name="ln76"> </a>
<a name="ln77">  uint8_t *buf = NULL;</a>
<a name="ln78">  char *mime_type = NULL;</a>
<a name="ln79">  size_t bufsize;</a>
<a name="ln80"> </a>
<a name="ln81">  // get the biggest thumb from exif</a>
<a name="ln82">  if(dt_exif_get_thumbnail(filename, &amp;buf, &amp;bufsize, &amp;mime_type)) goto error;</a>
<a name="ln83"> </a>
<a name="ln84">  if(strcmp(mime_type, &quot;image/jpeg&quot;) == 0)</a>
<a name="ln85">  {</a>
<a name="ln86">    // Decompress the JPG into our own memory format</a>
<a name="ln87">    dt_imageio_jpeg_t jpg;</a>
<a name="ln88">    if(dt_imageio_jpeg_decompress_header(buf, bufsize, &amp;jpg)) goto error;</a>
<a name="ln89">    *buffer = (uint8_t *)malloc((size_t)sizeof(uint8_t) * jpg.width * jpg.height * 4);</a>
<a name="ln90">    if(!*buffer) goto error;</a>
<a name="ln91"> </a>
<a name="ln92">    *width = jpg.width;</a>
<a name="ln93">    *height = jpg.height;</a>
<a name="ln94">    // TODO: check if the embedded thumbs have a color space set! currently we assume that it's always sRGB</a>
<a name="ln95">    *color_space = DT_COLORSPACE_SRGB;</a>
<a name="ln96">    if(dt_imageio_jpeg_decompress(&amp;jpg, *buffer))</a>
<a name="ln97">    {</a>
<a name="ln98">      free(*buffer);</a>
<a name="ln99">      *buffer = NULL;</a>
<a name="ln100">      goto error;</a>
<a name="ln101">    }</a>
<a name="ln102"> </a>
<a name="ln103">    res = 0;</a>
<a name="ln104">  }</a>
<a name="ln105">  else</a>
<a name="ln106">  {</a>
<a name="ln107">#ifdef HAVE_GRAPHICSMAGICK</a>
<a name="ln108">    ExceptionInfo exception;</a>
<a name="ln109">    Image *image = NULL;</a>
<a name="ln110">    ImageInfo *image_info = NULL;</a>
<a name="ln111"> </a>
<a name="ln112">    GetExceptionInfo(&amp;exception);</a>
<a name="ln113">    image_info = CloneImageInfo((ImageInfo *)NULL);</a>
<a name="ln114"> </a>
<a name="ln115">    image = BlobToImage(image_info, buf, bufsize, &amp;exception);</a>
<a name="ln116"> </a>
<a name="ln117">    if(exception.severity != UndefinedException) CatchException(&amp;exception);</a>
<a name="ln118"> </a>
<a name="ln119">    if(!image)</a>
<a name="ln120">    {</a>
<a name="ln121">      fprintf(stderr, &quot;[dt_imageio_large_thumbnail GM] thumbnail not found?\n&quot;);</a>
<a name="ln122">      goto error_gm;</a>
<a name="ln123">    }</a>
<a name="ln124"> </a>
<a name="ln125">    *width = image-&gt;columns;</a>
<a name="ln126">    *height = image-&gt;rows;</a>
<a name="ln127">    *color_space = DT_COLORSPACE_SRGB; // FIXME: this assumes that embedded thumbnails are always srgb</a>
<a name="ln128"> </a>
<a name="ln129">    *buffer = (uint8_t *)malloc((size_t)sizeof(uint8_t) * image-&gt;columns * image-&gt;rows * 4);</a>
<a name="ln130">    if(!*buffer) goto error_gm;</a>
<a name="ln131"> </a>
<a name="ln132">    for(uint32_t row = 0; row &lt; image-&gt;rows; row++)</a>
<a name="ln133">    {</a>
<a name="ln134">      uint8_t *bufprt = *buffer + (size_t)4 * row * image-&gt;columns;</a>
<a name="ln135">      int gm_ret = DispatchImage(image, 0, row, image-&gt;columns, 1, &quot;RGBP&quot;, CharPixel, bufprt, &amp;exception);</a>
<a name="ln136"> </a>
<a name="ln137">      if(exception.severity != UndefinedException) CatchException(&amp;exception);</a>
<a name="ln138"> </a>
<a name="ln139">      if(gm_ret != MagickPass)</a>
<a name="ln140">      {</a>
<a name="ln141">        fprintf(stderr, &quot;[dt_imageio_large_thumbnail GM] error_gm reading thumbnail\n&quot;);</a>
<a name="ln142">        free(*buffer);</a>
<a name="ln143">        *buffer = NULL;</a>
<a name="ln144">        goto error_gm;</a>
<a name="ln145">      }</a>
<a name="ln146">    }</a>
<a name="ln147"> </a>
<a name="ln148">    // fprintf(stderr, &quot;[dt_imageio_large_thumbnail GM] successfully decoded thumbnail\n&quot;);</a>
<a name="ln149">    res = 0;</a>
<a name="ln150"> </a>
<a name="ln151">  error_gm:</a>
<a name="ln152">    if(image) DestroyImage(image);</a>
<a name="ln153">    if(image_info) DestroyImageInfo(image_info);</a>
<a name="ln154">    DestroyExceptionInfo(&amp;exception);</a>
<a name="ln155">    if(res) goto error;</a>
<a name="ln156">#else</a>
<a name="ln157">    fprintf(stderr, &quot;[dt_imageio_large_thumbnail] error: The thumbnail image is not in JPEG format, but DT &quot;</a>
<a name="ln158">                    &quot;was built without GraphicsMagick. Please rebuild DT with GraphicsMagick support &quot;</a>
<a name="ln159">                    &quot;enabled.\n&quot;);</a>
<a name="ln160">#endif</a>
<a name="ln161">  }</a>
<a name="ln162"> </a>
<a name="ln163">  if(res)</a>
<a name="ln164">  {</a>
<a name="ln165">    fprintf(</a>
<a name="ln166">        stderr,</a>
<a name="ln167">        &quot;[dt_imageio_large_thumbnail] error: Not a supported thumbnail image format or broken thumbnail: %s\n&quot;,</a>
<a name="ln168">        mime_type);</a>
<a name="ln169">    goto error;</a>
<a name="ln170">  }</a>
<a name="ln171"> </a>
<a name="ln172">error:</a>
<a name="ln173">  free(mime_type);</a>
<a name="ln174">  free(buf);</a>
<a name="ln175">  return res;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">void dt_imageio_flip_buffers(char *out, const char *in, const size_t bpp, const int wd, const int ht,</a>
<a name="ln179">                             const int fwd, const int fht, const int stride,</a>
<a name="ln180">                             const dt_image_orientation_t orientation)</a>
<a name="ln181">{</a>
<a name="ln182">  if(!orientation)</a>
<a name="ln183">  {</a>
<a name="ln184">#ifdef _OPENMP</a>
<a name="ln185">#pragma omp parallel for schedule(static) default(none) shared(in, out)</a>
<a name="ln186">#endif</a>
<a name="ln187">    for(int j = 0; j &lt; ht; j++) memcpy(out + (size_t)j * bpp * wd, in + (size_t)j * stride, bpp * wd);</a>
<a name="ln188">    return;</a>
<a name="ln189">  }</a>
<a name="ln190">  int ii = 0, jj = 0;</a>
<a name="ln191">  int si = bpp, sj = wd * bpp;</a>
<a name="ln192">  if(orientation &amp; ORIENTATION_SWAP_XY)</a>
<a name="ln193">  {</a>
<a name="ln194">    sj = bpp;</a>
<a name="ln195">    si = ht * bpp;</a>
<a name="ln196">  }</a>
<a name="ln197">  if(orientation &amp; ORIENTATION_FLIP_X)</a>
<a name="ln198">  {</a>
<a name="ln199">    jj = (int)fht - jj - 1;</a>
<a name="ln200">    sj = -sj;</a>
<a name="ln201">  }</a>
<a name="ln202">  if(orientation &amp; ORIENTATION_FLIP_Y)</a>
<a name="ln203">  {</a>
<a name="ln204">    ii = (int)fwd - ii - 1;</a>
<a name="ln205">    si = -si;</a>
<a name="ln206">  }</a>
<a name="ln207">#ifdef _OPENMP</a>
<a name="ln208">#pragma omp parallel for schedule(static) default(none) shared(in, out, jj, ii, sj, si)</a>
<a name="ln209">#endif</a>
<a name="ln210">  for(int j = 0; j &lt; ht; j++)</a>
<a name="ln211">  {</a>
<a name="ln212">    char *out2 = out + (size_t)labs(sj) * jj + (size_t)labs(si) * ii + (size_t)sj * j;</a>
<a name="ln213">    const char *in2 = in + (size_t)stride * j;</a>
<a name="ln214">    for(int i = 0; i &lt; wd; i++)</a>
<a name="ln215">    {</a>
<a name="ln216">      memcpy(out2, in2, bpp);</a>
<a name="ln217">      in2 += bpp;</a>
<a name="ln218">      out2 += si;</a>
<a name="ln219">    }</a>
<a name="ln220">  }</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">void dt_imageio_flip_buffers_ui16_to_float(float *out, const uint16_t *in, const float black,</a>
<a name="ln224">                                           const float white, const int ch, const int wd, const int ht,</a>
<a name="ln225">                                           const int fwd, const int fht, const int stride,</a>
<a name="ln226">                                           const dt_image_orientation_t orientation)</a>
<a name="ln227">{</a>
<a name="ln228">  const float scale = 1.0f / (white - black);</a>
<a name="ln229">  if(!orientation)</a>
<a name="ln230">  {</a>
<a name="ln231">#ifdef _OPENMP</a>
<a name="ln232">#pragma omp parallel for schedule(static) default(none) shared(in, out)</a>
<a name="ln233">#endif</a>
<a name="ln234">    for(int j = 0; j &lt; ht; j++)</a>
<a name="ln235">      for(int i = 0; i &lt; wd; i++)</a>
<a name="ln236">        for(int k = 0; k &lt; ch; k++)</a>
<a name="ln237">          out[4 * ((size_t)j * wd + i) + k] = (in[ch * ((size_t)j * stride + i) + k] - black) * scale;</a>
<a name="ln238">    return;</a>
<a name="ln239">  }</a>
<a name="ln240">  int ii = 0, jj = 0;</a>
<a name="ln241">  int si = 4, sj = wd * 4;</a>
<a name="ln242">  if(orientation &amp; ORIENTATION_SWAP_XY)</a>
<a name="ln243">  {</a>
<a name="ln244">    sj = 4;</a>
<a name="ln245">    si = ht * 4;</a>
<a name="ln246">  }</a>
<a name="ln247">  if(orientation &amp; ORIENTATION_FLIP_X)</a>
<a name="ln248">  {</a>
<a name="ln249">    jj = (int)fht - jj - 1;</a>
<a name="ln250">    sj = -sj;</a>
<a name="ln251">  }</a>
<a name="ln252">  if(orientation &amp; ORIENTATION_FLIP_Y)</a>
<a name="ln253">  {</a>
<a name="ln254">    ii = (int)fwd - ii - 1;</a>
<a name="ln255">    si = -si;</a>
<a name="ln256">  }</a>
<a name="ln257">#ifdef _OPENMP</a>
<a name="ln258">#pragma omp parallel for schedule(static) default(none) shared(in, out, jj, ii, sj, si)</a>
<a name="ln259">#endif</a>
<a name="ln260">  for(int j = 0; j &lt; ht; j++)</a>
<a name="ln261">  {</a>
<a name="ln262">    float *out2 = out + (size_t)labs(sj) * jj + (size_t)labs(si) * ii + (size_t)sj * j;</a>
<a name="ln263">    const uint16_t *in2 = in + stride * j;</a>
<a name="ln264">    for(int i = 0; i &lt; wd; i++)</a>
<a name="ln265">    {</a>
<a name="ln266">      for(int k = 0; k &lt; ch; k++) out2[k] = (in2[k] - black) * scale;</a>
<a name="ln267">      in2 += ch;</a>
<a name="ln268">      out2 += si;</a>
<a name="ln269">    }</a>
<a name="ln270">  }</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">void dt_imageio_flip_buffers_ui8_to_float(float *out, const uint8_t *in, const float black, const float white,</a>
<a name="ln274">                                          const int ch, const int wd, const int ht, const int fwd,</a>
<a name="ln275">                                          const int fht, const int stride,</a>
<a name="ln276">                                          const dt_image_orientation_t orientation)</a>
<a name="ln277">{</a>
<a name="ln278">  const float scale = 1.0f / (white - black);</a>
<a name="ln279">  if(!orientation)</a>
<a name="ln280">  {</a>
<a name="ln281">#ifdef _OPENMP</a>
<a name="ln282">#pragma omp parallel for schedule(static) default(none) shared(in, out)</a>
<a name="ln283">#endif</a>
<a name="ln284">    for(int j = 0; j &lt; ht; j++)</a>
<a name="ln285">      for(int i = 0; i &lt; wd; i++)</a>
<a name="ln286">        for(int k = 0; k &lt; ch; k++)</a>
<a name="ln287">          out[4 * ((size_t)j * wd + i) + k] = (in[(size_t)j * stride + ch * i + k] - black) * scale;</a>
<a name="ln288">    return;</a>
<a name="ln289">  }</a>
<a name="ln290">  int ii = 0, jj = 0;</a>
<a name="ln291">  int si = 4, sj = wd * 4;</a>
<a name="ln292">  if(orientation &amp; ORIENTATION_SWAP_XY)</a>
<a name="ln293">  {</a>
<a name="ln294">    sj = 4;</a>
<a name="ln295">    si = ht * 4;</a>
<a name="ln296">  }</a>
<a name="ln297">  if(orientation &amp; ORIENTATION_FLIP_X)</a>
<a name="ln298">  {</a>
<a name="ln299">    jj = (int)fht - jj - 1;</a>
<a name="ln300">    sj = -sj;</a>
<a name="ln301">  }</a>
<a name="ln302">  if(orientation &amp; ORIENTATION_FLIP_Y)</a>
<a name="ln303">  {</a>
<a name="ln304">    ii = (int)fwd - ii - 1;</a>
<a name="ln305">    si = -si;</a>
<a name="ln306">  }</a>
<a name="ln307">#ifdef _OPENMP</a>
<a name="ln308">#pragma omp parallel for schedule(static) default(none) shared(in, out, jj, ii, sj, si)</a>
<a name="ln309">#endif</a>
<a name="ln310">  for(int j = 0; j &lt; ht; j++)</a>
<a name="ln311">  {</a>
<a name="ln312">    float *out2 = out + (size_t)labs(sj) * jj + (size_t)labs(si) * ii + sj * j;</a>
<a name="ln313">    const uint8_t *in2 = in + (size_t)stride * j;</a>
<a name="ln314">    for(int i = 0; i &lt; wd; i++)</a>
<a name="ln315">    {</a>
<a name="ln316">      for(int k = 0; k &lt; ch; k++) out2[k] = (in2[k] - black) * scale;</a>
<a name="ln317">      in2 += ch;</a>
<a name="ln318">      out2 += si;</a>
<a name="ln319">    }</a>
<a name="ln320">  }</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">size_t dt_imageio_write_pos(int i, int j, int wd, int ht, float fwd, float fht,</a>
<a name="ln324">                            dt_image_orientation_t orientation)</a>
<a name="ln325">{</a>
<a name="ln326">  int ii = i, jj = j, w = wd, fw = fwd, fh = fht;</a>
<a name="ln327">  if(orientation &amp; ORIENTATION_SWAP_XY)</a>
<a name="ln328">  {</a>
<a name="ln329">    w = ht;</a>
<a name="ln330">    ii = j;</a>
<a name="ln331">    jj = i;</a>
<a name="ln332">    fw = fht;</a>
<a name="ln333">    fh = fwd;</a>
<a name="ln334">  }</a>
<a name="ln335">  if(orientation &amp; ORIENTATION_FLIP_X) ii = (int)fw - ii - 1;</a>
<a name="ln336">  if(orientation &amp; ORIENTATION_FLIP_Y) jj = (int)fh - jj - 1;</a>
<a name="ln337">  return (size_t)jj * w + ii;</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340">dt_imageio_retval_t dt_imageio_open_hdr(dt_image_t *img, const char *filename, dt_mipmap_buffer_t *buf)</a>
<a name="ln341">{</a>
<a name="ln342">  // needed to alloc correct buffer size:</a>
<a name="ln343">  img-&gt;buf_dsc.channels = 4;</a>
<a name="ln344">  img-&gt;buf_dsc.datatype = TYPE_FLOAT;</a>
<a name="ln345">  dt_imageio_retval_t ret;</a>
<a name="ln346">  dt_image_loader_t loader;</a>
<a name="ln347">#ifdef HAVE_OPENEXR</a>
<a name="ln348">  loader = LOADER_EXR;</a>
<a name="ln349">  ret = dt_imageio_open_exr(img, filename, buf);</a>
<a name="ln350">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL) goto return_label;</a>
<a name="ln351">#endif</a>
<a name="ln352">  loader = LOADER_RGBE;</a>
<a name="ln353">  ret = dt_imageio_open_rgbe(img, filename, buf);</a>
<a name="ln354">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL) goto return_label;</a>
<a name="ln355">  loader = LOADER_PFM;</a>
<a name="ln356">  ret = dt_imageio_open_pfm(img, filename, buf);</a>
<a name="ln357">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL) goto return_label;</a>
<a name="ln358">return_label:</a>
<a name="ln359">  if(ret == DT_IMAGEIO_OK)</a>
<a name="ln360">  {</a>
<a name="ln361">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln362">    img-&gt;flags &amp;= ~DT_IMAGE_LDR;</a>
<a name="ln363">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln364">    img-&gt;flags |= DT_IMAGE_HDR;</a>
<a name="ln365">    img-&gt;loader = loader;</a>
<a name="ln366">  }</a>
<a name="ln367">  return ret;</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">/* magic data: exclusion,offset,length, xx, yy, ...</a>
<a name="ln371">    just add magic bytes to match to this struct</a>
<a name="ln372">    to extend mathc on ldr formats.</a>
<a name="ln373">*/</a>
<a name="ln374">static const uint8_t _imageio_ldr_magic[] = {</a>
<a name="ln375">  /* jpeg magics */</a>
<a name="ln376">  0x00, 0x00, 0x02, 0xff, 0xd8, // SOI marker</a>
<a name="ln377"> </a>
<a name="ln378">#ifdef HAVE_OPENJPEG</a>
<a name="ln379">  /* jpeg 2000, jp2 format */</a>
<a name="ln380">  0x00, 0x00, 0x0c, 0x0,  0x0,  0x0,  0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A,</a>
<a name="ln381"> </a>
<a name="ln382">  /* jpeg 2000, j2k format */</a>
<a name="ln383">  0x00, 0x00, 0x05, 0xFF, 0x4F, 0xFF, 0x51, 0x00,</a>
<a name="ln384">#endif</a>
<a name="ln385"> </a>
<a name="ln386">  /* png image */</a>
<a name="ln387">  0x00, 0x01, 0x03, 0x50, 0x4E, 0x47, // ASCII 'PNG'</a>
<a name="ln388"> </a>
<a name="ln389"> </a>
<a name="ln390">  /* Canon CR2/CRW is like TIFF with additional magic numbers so must come</a>
<a name="ln391">     before tiff as an exclusion */</a>
<a name="ln392"> </a>
<a name="ln393">  /* Most CR2 */</a>
<a name="ln394">  0x01, 0x00, 0x0a, 0x49, 0x49, 0x2a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x43, 0x52,</a>
<a name="ln395"> </a>
<a name="ln396">  /* CR3 (ISO Media) */</a>
<a name="ln397">  0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 'f', 't', 'y', 'p', 'c', 'r', 'x', ' ', 0x00, 0x00, 0x00, 0x01, 'c', 'r', 'x', ' ', 'i', 's', 'o', 'm',</a>
<a name="ln398"> </a>
<a name="ln399">  // Older Canon RAW format with TIF Extension (i.e. 1Ds and 1D)</a>
<a name="ln400">  0x01, 0x00, 0x0a, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x10, 0xba, 0xb0,</a>
<a name="ln401"> </a>
<a name="ln402">  // Older Canon RAW format with TIF Extension (i.e. D2000)</a>
<a name="ln403">  0x01, 0x00, 0x0a, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x11, 0x34, 0x00, 0x04,</a>
<a name="ln404"> </a>
<a name="ln405">  // Older Canon RAW format with TIF Extension (i.e. DCS1)</a>
<a name="ln406">  0x01, 0x00, 0x0a, 0x49, 0x49, 0x2a, 0x00, 0x00, 0x03, 0x00, 0x00, 0xff, 0x01,</a>
<a name="ln407"> </a>
<a name="ln408">  // Older Kodak RAW format with TIF Extension (i.e. DCS520C)</a>
<a name="ln409">  0x01, 0x00, 0x0a, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x11, 0xa8, 0x00, 0x04,</a>
<a name="ln410"> </a>
<a name="ln411">  // Older Kodak RAW format with TIF Extension (i.e. DCS560C)</a>
<a name="ln412">  0x01, 0x00, 0x0a, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x11, 0x76, 0x00, 0x04,</a>
<a name="ln413"> </a>
<a name="ln414">  // Older Kodak RAW format with TIF Extension (i.e. DCS460D)</a>
<a name="ln415">  0x01, 0x00, 0x0a, 0x49, 0x49, 0x2a, 0x00, 0x00, 0x03, 0x00, 0x00, 0x7c, 0x01,</a>
<a name="ln416"> </a>
<a name="ln417">  /* IIQ raw images, may be either .IIQ, or .TIF */</a>
<a name="ln418">  0x01, 0x08, 0x04, 0x49, 0x49, 0x49, 0x49,</a>
<a name="ln419"> </a>
<a name="ln420">  /* tiff image, intel */</a>
<a name="ln421">  0x00, 0x00, 0x04, 0x4d, 0x4d, 0x00, 0x2a,</a>
<a name="ln422"> </a>
<a name="ln423">  /* tiff image, motorola */</a>
<a name="ln424">  0x00, 0x00, 0x04, 0x49, 0x49, 0x2a, 0x00,</a>
<a name="ln425"> </a>
<a name="ln426">  /* binary NetPNM images: pbm, pgm and pbm */</a>
<a name="ln427">  0x00, 0x00, 0x02, 0x50, 0x34,</a>
<a name="ln428">  0x00, 0x00, 0x02, 0x50, 0x35,</a>
<a name="ln429">  0x00, 0x00, 0x02, 0x50, 0x36</a>
<a name="ln430">};</a>
<a name="ln431"> </a>
<a name="ln432">gboolean dt_imageio_is_ldr(const char *filename)</a>
<a name="ln433">{</a>
<a name="ln434">  size_t offset = 0;</a>
<a name="ln435">  uint8_t block[32] = { 0 }; // keep this big enough for whatever magic size we want to compare to!</a>
<a name="ln436">  FILE *fin = g_fopen(filename, &quot;rb&quot;);</a>
<a name="ln437">  if(fin)</a>
<a name="ln438">  {</a>
<a name="ln439">    /* read block from file */</a>
<a name="ln440">    size_t s = fread(block, sizeof(block), 1, fin);</a>
<a name="ln441">    fclose(fin);</a>
<a name="ln442"> </a>
<a name="ln443">    /* compare magic's */</a>
<a name="ln444">    while(s)</a>
<a name="ln445">    {</a>
<a name="ln446">      if(_imageio_ldr_magic[offset + 2] &gt; sizeof(block)</a>
<a name="ln447">        || offset + 3 + _imageio_ldr_magic[offset + 2] &gt; sizeof(_imageio_ldr_magic))</a>
<a name="ln448">      {</a>
<a name="ln449">        fprintf(stderr, &quot;error: buffer in %s is too small!\n&quot;, __FUNCTION__);</a>
<a name="ln450">        return FALSE;</a>
<a name="ln451">      }</a>
<a name="ln452">      if(memcmp(_imageio_ldr_magic + offset + 3, block + _imageio_ldr_magic[offset + 1],</a>
<a name="ln453">                _imageio_ldr_magic[offset + 2]) == 0)</a>
<a name="ln454">      {</a>
<a name="ln455">        if(_imageio_ldr_magic[offset] == 0x01)</a>
<a name="ln456">          return FALSE;</a>
<a name="ln457">        else</a>
<a name="ln458">          return TRUE;</a>
<a name="ln459">      }</a>
<a name="ln460">      offset += 3 + (_imageio_ldr_magic + offset)[2];</a>
<a name="ln461"> </a>
<a name="ln462">      /* check if finished */</a>
<a name="ln463">      if(offset &gt;= sizeof(_imageio_ldr_magic)) break;</a>
<a name="ln464">    }</a>
<a name="ln465">  }</a>
<a name="ln466">  return FALSE;</a>
<a name="ln467">}</a>
<a name="ln468"> </a>
<a name="ln469">int dt_imageio_is_hdr(const char *filename)</a>
<a name="ln470">{</a>
<a name="ln471">  const char *c = filename + strlen(filename);</a>
<a name="ln472">  while(c &gt; filename &amp;&amp; *c != '.') c--;</a>
<a name="ln473">  if(*c == '.')</a>
<a name="ln474">    if(!strcasecmp(c, &quot;.pfm&quot;) || !strcasecmp(c, &quot;.hdr&quot;)</a>
<a name="ln475">#ifdef HAVE_OPENEXR</a>
<a name="ln476">       || !strcasecmp(c, &quot;.exr&quot;)</a>
<a name="ln477">#endif</a>
<a name="ln478">           )</a>
<a name="ln479">      return 1;</a>
<a name="ln480">  return 0;</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">// transparent read method to load ldr image to dt_raw_image_t with exif and so on.</a>
<a name="ln484">dt_imageio_retval_t dt_imageio_open_ldr(dt_image_t *img, const char *filename, dt_mipmap_buffer_t *buf)</a>
<a name="ln485">{</a>
<a name="ln486">  dt_imageio_retval_t ret;</a>
<a name="ln487"> </a>
<a name="ln488">  ret = dt_imageio_open_jpeg(img, filename, buf);</a>
<a name="ln489">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln490">  {</a>
<a name="ln491">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln492">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln493">    img-&gt;flags &amp;= ~DT_IMAGE_HDR;</a>
<a name="ln494">    img-&gt;flags |= DT_IMAGE_LDR;</a>
<a name="ln495">    img-&gt;loader = LOADER_JPEG;</a>
<a name="ln496">    return ret;</a>
<a name="ln497">  }</a>
<a name="ln498"> </a>
<a name="ln499">  ret = dt_imageio_open_tiff(img, filename, buf);</a>
<a name="ln500">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln501">  {</a>
<a name="ln502">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln503">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln504">    img-&gt;flags &amp;= ~DT_IMAGE_HDR;</a>
<a name="ln505">    img-&gt;flags |= DT_IMAGE_LDR;</a>
<a name="ln506">    img-&gt;loader = LOADER_TIFF;</a>
<a name="ln507">    return ret;</a>
<a name="ln508">  }</a>
<a name="ln509"> </a>
<a name="ln510">  ret = dt_imageio_open_png(img, filename, buf);</a>
<a name="ln511">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln512">  {</a>
<a name="ln513">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln514">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln515">    img-&gt;flags &amp;= ~DT_IMAGE_HDR;</a>
<a name="ln516">    img-&gt;flags |= DT_IMAGE_LDR;</a>
<a name="ln517">    img-&gt;loader = LOADER_PNG;</a>
<a name="ln518">    return ret;</a>
<a name="ln519">  }</a>
<a name="ln520"> </a>
<a name="ln521">#ifdef HAVE_OPENJPEG</a>
<a name="ln522">  ret = dt_imageio_open_j2k(img, filename, buf);</a>
<a name="ln523">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln524">  {</a>
<a name="ln525">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln526">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln527">    img-&gt;flags &amp;= ~DT_IMAGE_HDR;</a>
<a name="ln528">    img-&gt;flags |= DT_IMAGE_LDR;</a>
<a name="ln529">    img-&gt;loader = LOADER_J2K;</a>
<a name="ln530">    return ret;</a>
<a name="ln531">  }</a>
<a name="ln532">#endif</a>
<a name="ln533"> </a>
<a name="ln534">  ret = dt_imageio_open_pnm(img, filename, buf);</a>
<a name="ln535">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln536">  {</a>
<a name="ln537">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln538">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln539">    img-&gt;flags &amp;= ~DT_IMAGE_HDR;</a>
<a name="ln540">    img-&gt;flags |= DT_IMAGE_LDR;</a>
<a name="ln541">    img-&gt;loader = LOADER_PNM;</a>
<a name="ln542">    return ret;</a>
<a name="ln543">  }</a>
<a name="ln544"> </a>
<a name="ln545">  return DT_IMAGEIO_FILE_CORRUPTED;</a>
<a name="ln546">}</a>
<a name="ln547"> </a>
<a name="ln548">void dt_imageio_to_fractional(float in, uint32_t *num, uint32_t *den)</a>
<a name="ln549">{</a>
<a name="ln550">  if(!(in &gt;= 0))</a>
<a name="ln551">  {</a>
<a name="ln552">    *num = *den = 0;</a>
<a name="ln553">    return;</a>
<a name="ln554">  }</a>
<a name="ln555">  *den = 1;</a>
<a name="ln556">  *num = (int)(in * *den + .5f);</a>
<a name="ln557">  while(fabsf(*num / (float)*den - in) &gt; 0.001f)</a>
<a name="ln558">  {</a>
<a name="ln559">    *den *= 10;</a>
<a name="ln560">    *num = (int)(in * *den + .5f);</a>
<a name="ln561">  }</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564">int dt_imageio_export(const uint32_t imgid, const char *filename, dt_imageio_module_format_t *format,</a>
<a name="ln565">                      dt_imageio_module_data_t *format_params, const gboolean high_quality, const gboolean upscale,</a>
<a name="ln566">                      const gboolean copy_metadata, dt_colorspaces_color_profile_type_t icc_type,</a>
<a name="ln567">                      const gchar *icc_filename, dt_iop_color_intent_t icc_intent,</a>
<a name="ln568">                      dt_imageio_module_storage_t *storage, dt_imageio_module_data_t *storage_params, int num,</a>
<a name="ln569">                      int total)</a>
<a name="ln570">{</a>
<a name="ln571">  if(strcmp(format-&gt;mime(format_params), &quot;x-copy&quot;) == 0)</a>
<a name="ln572">    /* This is a just a copy, skip process and just export */</a>
<a name="ln573">    return format-&gt;write_image(format_params, filename, NULL, icc_type, icc_filename, NULL, 0, imgid, num, total, NULL);</a>
<a name="ln574">  else</a>
<a name="ln575">    return dt_imageio_export_with_flags(imgid, filename, format, format_params, FALSE, FALSE, high_quality, upscale,</a>
<a name="ln576">                                        FALSE, NULL, copy_metadata, icc_type, icc_filename, icc_intent, storage,</a>
<a name="ln577">                                        storage_params, num, total);</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">// internal function: to avoid exif blob reading + 8-bit byteorder flag + high-quality override</a>
<a name="ln581">int dt_imageio_export_with_flags(const uint32_t imgid, const char *filename,</a>
<a name="ln582">                                 dt_imageio_module_format_t *format, dt_imageio_module_data_t *format_params,</a>
<a name="ln583">                                 const gboolean ignore_exif, const gboolean display_byteorder,</a>
<a name="ln584">                                 const gboolean high_quality, const gboolean upscale, const gboolean thumbnail_export,</a>
<a name="ln585">                                 const char *filter, const gboolean copy_metadata,</a>
<a name="ln586">                                 dt_colorspaces_color_profile_type_t icc_type, const gchar *icc_filename,</a>
<a name="ln587">                                 dt_iop_color_intent_t icc_intent,</a>
<a name="ln588">                                 dt_imageio_module_storage_t *storage,</a>
<a name="ln589">                                 dt_imageio_module_data_t *storage_params, int num, int total)</a>
<a name="ln590">{</a>
<a name="ln591">  dt_develop_t dev;</a>
<a name="ln592">  dt_dev_init(&amp;dev, 0);</a>
<a name="ln593">  dt_dev_load_image(&amp;dev, imgid);</a>
<a name="ln594"> </a>
<a name="ln595">  const int buf_is_downscaled</a>
<a name="ln596">      = (thumbnail_export &amp;&amp; dt_conf_get_bool(&quot;plugins/lighttable/low_quality_thumbnails&quot;));</a>
<a name="ln597"> </a>
<a name="ln598">  dt_mipmap_buffer_t buf;</a>
<a name="ln599">  if(buf_is_downscaled)</a>
<a name="ln600">    dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, DT_MIPMAP_F, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln601">  else</a>
<a name="ln602">    dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, DT_MIPMAP_FULL, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln603"> </a>
<a name="ln604">  const dt_image_t *img = &amp;dev.image_storage;</a>
<a name="ln605"> </a>
<a name="ln606">  if(!buf.buf || !buf.width || !buf.height)</a>
<a name="ln607">  {</a>
<a name="ln608">    fprintf(stderr, &quot;allocation failed???\n&quot;);</a>
<a name="ln609">    dt_control_log(_(&quot;image `%s' is not available!&quot;), img-&gt;filename);</a>
<a name="ln610">    goto error_early;</a>
<a name="ln611">  }</a>
<a name="ln612"> </a>
<a name="ln613">  const int wd = img-&gt;width;</a>
<a name="ln614">  const int ht = img-&gt;height;</a>
<a name="ln615"> </a>
<a name="ln616"> </a>
<a name="ln617">  int res = 0;</a>
<a name="ln618"> </a>
<a name="ln619">  dt_times_t start;</a>
<a name="ln620">  dt_get_times(&amp;start);</a>
<a name="ln621">  dt_dev_pixelpipe_t pipe;</a>
<a name="ln622">  res = thumbnail_export ? dt_dev_pixelpipe_init_thumbnail(&amp;pipe, wd, ht)</a>
<a name="ln623">                         : dt_dev_pixelpipe_init_export(&amp;pipe, wd, ht, format-&gt;levels(format_params), TRUE); // TODO</a>
<a name="ln624">  if(!res)</a>
<a name="ln625">  {</a>
<a name="ln626">    dt_control_log(</a>
<a name="ln627">        _(&quot;failed to allocate memory for %s, please lower the threads used for export or buy more memory.&quot;),</a>
<a name="ln628">        thumbnail_export ? C_(&quot;noun&quot;, &quot;thumbnail export&quot;) : C_(&quot;noun&quot;, &quot;export&quot;));</a>
<a name="ln629">    goto error;</a>
<a name="ln630">  }</a>
<a name="ln631"> </a>
<a name="ln632">  //  If a style is to be applied during export, add the iop params into the history</a>
<a name="ln633">  if(!thumbnail_export &amp;&amp; format_params-&gt;style[0] != '\0')</a>
<a name="ln634">  {</a>
<a name="ln635">    GList *style_items = dt_styles_get_item_list(format_params-&gt;style, TRUE, -1);</a>
<a name="ln636">    if(!style_items)</a>
<a name="ln637">    {</a>
<a name="ln638">      dt_control_log(_(&quot;cannot find the style '%s' to apply during export.&quot;), format_params-&gt;style);</a>
<a name="ln639">      goto error;</a>
<a name="ln640">    }</a>
<a name="ln641"> </a>
<a name="ln642">    // remove everything above history_end</a>
<a name="ln643">    GList *history = g_list_nth(dev.history, dev.history_end);</a>
<a name="ln644">    while(history)</a>
<a name="ln645">    {</a>
<a name="ln646">      GList *next = g_list_next(history);</a>
<a name="ln647">      dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln648">      free(hist-&gt;params);</a>
<a name="ln649">      free(hist-&gt;blend_params);</a>
<a name="ln650">      free(history-&gt;data);</a>
<a name="ln651">      dev.history = g_list_delete_link(dev.history, history);</a>
<a name="ln652">      history = next;</a>
<a name="ln653">    }</a>
<a name="ln654"> </a>
<a name="ln655">    // Add each params</a>
<a name="ln656">    for(GList *iter = style_items; iter; iter = g_list_next(iter))</a>
<a name="ln657">    {</a>
<a name="ln658">      dt_style_item_t *s = (dt_style_item_t *)iter-&gt;data;</a>
<a name="ln659"> </a>
<a name="ln660">      for(GList *module = dev.iop; module; module = g_list_next(module))</a>
<a name="ln661">      {</a>
<a name="ln662">        dt_iop_module_t *m = (dt_iop_module_t *)module-&gt;data;</a>
<a name="ln663"> </a>
<a name="ln664">        if(!strcmp(m-&gt;op, s-&gt;operation))</a>
<a name="ln665">        {</a>
<a name="ln666">          dt_dev_history_item_t *h = malloc(sizeof(dt_dev_history_item_t));</a>
<a name="ln667">          dt_iop_module_t *style_module = m;</a>
<a name="ln668"> </a>
<a name="ln669">          if((format_params-&gt;style_append &amp;&amp; !(m-&gt;flags() &amp; IOP_FLAGS_ONE_INSTANCE)) || m-&gt;multi_priority != s-&gt;multi_priority)</a>
<a name="ln670">          {</a>
<a name="ln671">            // dt_dev_module_duplicate() doesn't work here, it's trying too hard to be clever</a>
<a name="ln672">            style_module = (dt_iop_module_t *)calloc(1, sizeof(dt_iop_module_t));</a>
<a name="ln673">            if(style_module &amp;&amp; !dt_iop_load_module(style_module, m-&gt;so, m-&gt;dev))</a>
<a name="ln674">            {</a>
<a name="ln675">              style_module-&gt;instance = m-&gt;instance;</a>
<a name="ln676">              style_module-&gt;multi_priority = s-&gt;multi_priority;</a>
<a name="ln677">              snprintf(style_module-&gt;multi_name, sizeof(style_module-&gt;multi_name), &quot;%s&quot;, s-&gt;name);</a>
<a name="ln678">              dev.iop = g_list_insert_sorted(dev.iop, style_module, sort_plugins);</a>
<a name="ln679">            }</a>
<a name="ln680">            else</a>
<a name="ln681">            {</a>
<a name="ln682">              free(h);</a>
<a name="ln683">              goto error;</a>
<a name="ln684">            }</a>
<a name="ln685">          }</a>
<a name="ln686"> </a>
<a name="ln687">          h-&gt;params = s-&gt;params;</a>
<a name="ln688">          h-&gt;blend_params = s-&gt;blendop_params;</a>
<a name="ln689">          h-&gt;enabled = s-&gt;enabled;</a>
<a name="ln690">          h-&gt;module = style_module;</a>
<a name="ln691">          h-&gt;multi_priority = s-&gt;multi_priority;</a>
<a name="ln692">          g_strlcpy(h-&gt;multi_name, s-&gt;name, sizeof(h-&gt;multi_name));</a>
<a name="ln693">          g_strlcpy(h-&gt;op_name, m-&gt;op, sizeof(h-&gt;op_name));</a>
<a name="ln694"> </a>
<a name="ln695">          if(m-&gt;legacy_params &amp;&amp; (s-&gt;module_version != m-&gt;version()))</a>
<a name="ln696">          {</a>
<a name="ln697">            void *new_params = malloc(m-&gt;params_size);</a>
<a name="ln698">            m-&gt;legacy_params(m, h-&gt;params, s-&gt;module_version, new_params, labs(m-&gt;version()));</a>
<a name="ln699"> </a>
<a name="ln700">            free(h-&gt;params);</a>
<a name="ln701">            h-&gt;params = new_params;</a>
<a name="ln702">          }</a>
<a name="ln703"> </a>
<a name="ln704">          dev.history_end++;</a>
<a name="ln705">          dev.history = g_list_append(dev.history, h);</a>
<a name="ln706"> </a>
<a name="ln707">          // make sure that dt_style_item_free doesn't free data we still use</a>
<a name="ln708">          s-&gt;params = NULL;</a>
<a name="ln709">          s-&gt;blendop_params = NULL;</a>
<a name="ln710"> </a>
<a name="ln711">          break;</a>
<a name="ln712">        }</a>
<a name="ln713">      }</a>
<a name="ln714">    }</a>
<a name="ln715">    g_list_free_full(style_items, dt_style_item_free);</a>
<a name="ln716">  }</a>
<a name="ln717"> </a>
<a name="ln718">  dt_dev_pixelpipe_set_icc(&amp;pipe, icc_type, icc_filename, icc_intent);</a>
<a name="ln719">  dt_dev_pixelpipe_set_input(&amp;pipe, &amp;dev, (float *)buf.buf, buf.width, buf.height, buf.iscale);</a>
<a name="ln720">  dt_dev_pixelpipe_create_nodes(&amp;pipe, &amp;dev);</a>
<a name="ln721">  dt_dev_pixelpipe_synch_all(&amp;pipe, &amp;dev);</a>
<a name="ln722"> </a>
<a name="ln723">  if(filter)</a>
<a name="ln724">  {</a>
<a name="ln725">    if(!strncmp(filter, &quot;pre:&quot;, 4)) dt_dev_pixelpipe_disable_after(&amp;pipe, filter + 4);</a>
<a name="ln726">    if(!strncmp(filter, &quot;post:&quot;, 5)) dt_dev_pixelpipe_disable_before(&amp;pipe, filter + 5);</a>
<a name="ln727">  }</a>
<a name="ln728"> </a>
<a name="ln729">  dt_dev_pixelpipe_get_dimensions(&amp;pipe, &amp;dev, pipe.iwidth, pipe.iheight, &amp;pipe.processed_width,</a>
<a name="ln730">                                  &amp;pipe.processed_height);</a>
<a name="ln731"> </a>
<a name="ln732">  dt_show_times(&amp;start, &quot;[export] creating pixelpipe&quot;, NULL);</a>
<a name="ln733"> </a>
<a name="ln734">  // find output color profile for this image:</a>
<a name="ln735">  int sRGB = 1;</a>
<a name="ln736">  if(icc_type == DT_COLORSPACE_SRGB)</a>
<a name="ln737">  {</a>
<a name="ln738">    sRGB = 1;</a>
<a name="ln739">  }</a>
<a name="ln740">  else if(icc_type == DT_COLORSPACE_NONE)</a>
<a name="ln741">  {</a>
<a name="ln742">    GList *modules = dev.iop;</a>
<a name="ln743">    dt_iop_module_t *colorout = NULL;</a>
<a name="ln744">    while(modules)</a>
<a name="ln745">    {</a>
<a name="ln746">      colorout = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln747">      if(colorout-&gt;get_p &amp;&amp; strcmp(colorout-&gt;op, &quot;colorout&quot;) == 0)</a>
<a name="ln748">      {</a>
<a name="ln749">        const dt_colorspaces_color_profile_type_t *type = colorout-&gt;get_p(colorout-&gt;params, &quot;type&quot;);</a>
<a name="ln750">        sRGB = (!type || *type == DT_COLORSPACE_SRGB);</a>
<a name="ln751">        break; // colorout can't have &gt; 1 instance</a>
<a name="ln752">      }</a>
<a name="ln753">      modules = g_list_next(modules);</a>
<a name="ln754">    }</a>
<a name="ln755">  }</a>
<a name="ln756">  else</a>
<a name="ln757">  {</a>
<a name="ln758">    sRGB = 0;</a>
<a name="ln759">  }</a>
<a name="ln760"> </a>
<a name="ln761">  // get only once at the beginning, in case the user changes it on the way:</a>
<a name="ln762">  const gboolean high_quality_processing</a>
<a name="ln763">      = ((format_params-&gt;max_width == 0 || format_params-&gt;max_width &gt;= pipe.processed_width)</a>
<a name="ln764">         &amp;&amp; (format_params-&gt;max_height == 0 || format_params-&gt;max_height &gt;= pipe.processed_height))</a>
<a name="ln765">            ? FALSE</a>
<a name="ln766">            : high_quality;</a>
<a name="ln767"> </a>
<a name="ln768">  const int width = format_params-&gt;max_width;</a>
<a name="ln769">  const int height = format_params-&gt;max_height;</a>
<a name="ln770"> </a>
<a name="ln771">  const float max_scale = ( upscale &amp;&amp; ( width &gt; 0 || height &gt; 0 )) ? 100.0 : 1.0;</a>
<a name="ln772"> </a>
<a name="ln773">  const double scalex = width &gt; 0 ? fminf(width / (double)pipe.processed_width, max_scale) : max_scale;</a>
<a name="ln774">  const double scaley = height &gt; 0 ? fminf(height / (double)pipe.processed_height, max_scale) : max_scale;</a>
<a name="ln775">  const double scale = fminf(scalex, scaley);</a>
<a name="ln776"> </a>
<a name="ln777">  const int processed_width = scale * pipe.processed_width + .5f;</a>
<a name="ln778">  const int processed_height = scale * pipe.processed_height + .5f;</a>
<a name="ln779"> </a>
<a name="ln780">  const int bpp = format-&gt;bpp(format_params);</a>
<a name="ln781"> </a>
<a name="ln782">  dt_get_times(&amp;start);</a>
<a name="ln783">  if(high_quality_processing)</a>
<a name="ln784">  {</a>
<a name="ln785">    /*</a>
<a name="ln786">     * if high quality processing was requested, downsampling will be done</a>
<a name="ln787">     * at the very end of the pipe (just before border and watermark)</a>
<a name="ln788">     */</a>
<a name="ln789">    dt_dev_pixelpipe_process_no_gamma(&amp;pipe, &amp;dev, 0, 0, processed_width, processed_height, scale);</a>
<a name="ln790">  }</a>
<a name="ln791">  else</a>
<a name="ln792">  {</a>
<a name="ln793">    // else, downsampling will be right after demosaic</a>
<a name="ln794"> </a>
<a name="ln795">    // so we need to turn temporarily disable in-pipe late downsampling iop.</a>
<a name="ln796"> </a>
<a name="ln797">    // find the finalscale module</a>
<a name="ln798">    dt_dev_pixelpipe_iop_t *finalscale = NULL;</a>
<a name="ln799">    {</a>
<a name="ln800">      GList *nodes = g_list_last(pipe.nodes);</a>
<a name="ln801">      while(nodes)</a>
<a name="ln802">      {</a>
<a name="ln803">        dt_dev_pixelpipe_iop_t *node = (dt_dev_pixelpipe_iop_t *)(nodes-&gt;data);</a>
<a name="ln804">        if(!strcmp(node-&gt;module-&gt;op, &quot;finalscale&quot;))</a>
<a name="ln805">        {</a>
<a name="ln806">          finalscale = node;</a>
<a name="ln807">          break;</a>
<a name="ln808">        }</a>
<a name="ln809">        nodes = g_list_previous(nodes);</a>
<a name="ln810">      }</a>
<a name="ln811">    }</a>
<a name="ln812"> </a>
<a name="ln813">    if(finalscale) finalscale-&gt;enabled = 0;</a>
<a name="ln814"> </a>
<a name="ln815">    // do the processing (8-bit with special treatment, to make sure we can use openmp further down):</a>
<a name="ln816">    if(bpp == 8)</a>
<a name="ln817">      dt_dev_pixelpipe_process(&amp;pipe, &amp;dev, 0, 0, processed_width, processed_height, scale);</a>
<a name="ln818">    else</a>
<a name="ln819">      dt_dev_pixelpipe_process_no_gamma(&amp;pipe, &amp;dev, 0, 0, processed_width, processed_height, scale);</a>
<a name="ln820"> </a>
<a name="ln821">    if(finalscale) finalscale-&gt;enabled = 1;</a>
<a name="ln822">  }</a>
<a name="ln823">  dt_show_times(&amp;start, thumbnail_export ? &quot;[dev_process_thumbnail] pixel pipeline processing&quot;</a>
<a name="ln824">                                         : &quot;[dev_process_export] pixel pipeline processing&quot;,</a>
<a name="ln825">                NULL);</a>
<a name="ln826"> </a>
<a name="ln827">  uint8_t *outbuf = pipe.backbuf;</a>
<a name="ln828"> </a>
<a name="ln829">  // downconversion to low-precision formats:</a>
<a name="ln830">  if(bpp == 8)</a>
<a name="ln831">  {</a>
<a name="ln832">    if(display_byteorder)</a>
<a name="ln833">    {</a>
<a name="ln834">      if(high_quality_processing)</a>
<a name="ln835">      {</a>
<a name="ln836">        const float *const inbuf = (float *)outbuf;</a>
<a name="ln837">        for(size_t k = 0; k &lt; (size_t)processed_width * processed_height; k++)</a>
<a name="ln838">        {</a>
<a name="ln839">          // convert in place, this is unfortunately very serial..</a>
<a name="ln840">          const uint8_t r = CLAMP(inbuf[4 * k + 2] * 0xff, 0, 0xff);</a>
<a name="ln841">          const uint8_t g = CLAMP(inbuf[4 * k + 1] * 0xff, 0, 0xff);</a>
<a name="ln842">          const uint8_t b = CLAMP(inbuf[4 * k + 0] * 0xff, 0, 0xff);</a>
<a name="ln843">          outbuf[4 * k + 0] = r;</a>
<a name="ln844">          outbuf[4 * k + 1] = g;</a>
<a name="ln845">          outbuf[4 * k + 2] = b;</a>
<a name="ln846">        }</a>
<a name="ln847">      }</a>
<a name="ln848">      // else processing output was 8-bit already, and no need to swap order</a>
<a name="ln849">    }</a>
<a name="ln850">    else // need to flip</a>
<a name="ln851">    {</a>
<a name="ln852">      // ldr output: char</a>
<a name="ln853">      if(high_quality_processing)</a>
<a name="ln854">      {</a>
<a name="ln855">        const float *const inbuf = (float *)outbuf;</a>
<a name="ln856">        for(size_t k = 0; k &lt; (size_t)processed_width * processed_height; k++)</a>
<a name="ln857">        {</a>
<a name="ln858">          // convert in place, this is unfortunately very serial..</a>
<a name="ln859">          const uint8_t r = CLAMP(inbuf[4 * k + 0] * 0xff, 0, 0xff);</a>
<a name="ln860">          const uint8_t g = CLAMP(inbuf[4 * k + 1] * 0xff, 0, 0xff);</a>
<a name="ln861">          const uint8_t b = CLAMP(inbuf[4 * k + 2] * 0xff, 0, 0xff);</a>
<a name="ln862">          outbuf[4 * k + 0] = r;</a>
<a name="ln863">          outbuf[4 * k + 1] = g;</a>
<a name="ln864">          outbuf[4 * k + 2] = b;</a>
<a name="ln865">        }</a>
<a name="ln866">      }</a>
<a name="ln867">      else</a>
<a name="ln868">      { // !display_byteorder, need to swap:</a>
<a name="ln869">        uint8_t *const buf8 = pipe.backbuf;</a>
<a name="ln870">#ifdef _OPENMP</a>
<a name="ln871">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln872">#endif</a>
<a name="ln873">        // just flip byte order</a>
<a name="ln874">        for(size_t k = 0; k &lt; (size_t)processed_width * processed_height; k++)</a>
<a name="ln875">        {</a>
<a name="ln876">          uint8_t tmp = buf8[4 * k + 0];</a>
<a name="ln877">          buf8[4 * k + 0] = buf8[4 * k + 2];</a>
<a name="ln878">          buf8[4 * k + 2] = tmp;</a>
<a name="ln879">        }</a>
<a name="ln880">      }</a>
<a name="ln881">    }</a>
<a name="ln882">  }</a>
<a name="ln883">  else if(bpp == 16)</a>
<a name="ln884">  {</a>
<a name="ln885">    // uint16_t per color channel</a>
<a name="ln886">    float *buff = (float *)outbuf;</a>
<a name="ln887">    uint16_t *buf16 = (uint16_t *)outbuf;</a>
<a name="ln888">    for(int y = 0; y &lt; processed_height; y++)</a>
<a name="ln889">      for(int x = 0; x &lt; processed_width; x++)</a>
<a name="ln890">      {</a>
<a name="ln891">        // convert in place</a>
<a name="ln892">        const size_t k = (size_t)processed_width * y + x;</a>
<a name="ln893">        for(int i = 0; i &lt; 3; i++) buf16[4 * k + i] = CLAMP(buff[4 * k + i] * 0x10000, 0, 0xffff);</a>
<a name="ln894">      }</a>
<a name="ln895">  }</a>
<a name="ln896">  // else output float, no further harm done to the pixels :)</a>
<a name="ln897"> </a>
<a name="ln898">  format_params-&gt;width = processed_width;</a>
<a name="ln899">  format_params-&gt;height = processed_height;</a>
<a name="ln900"> </a>
<a name="ln901">  if(!ignore_exif)</a>
<a name="ln902">  {</a>
<a name="ln903">    int length;</a>
<a name="ln904">    uint8_t *exif_profile = NULL; // Exif data should be 65536 bytes max, but if original size is close to that,</a>
<a name="ln905">                                  // adding new tags could make it go over that... so let it be and see what</a>
<a name="ln906">                                  // happens when we write the image</a>
<a name="ln907">    char pathname[PATH_MAX] = { 0 };</a>
<a name="ln908">    gboolean from_cache = TRUE;</a>
<a name="ln909">    dt_image_full_path(imgid, pathname, sizeof(pathname), &amp;from_cache);</a>
<a name="ln910">    // last param is dng mode, it's false here</a>
<a name="ln911">    length = dt_exif_read_blob(&amp;exif_profile, pathname, imgid, sRGB, processed_width, processed_height, 0);</a>
<a name="ln912"> </a>
<a name="ln913">    res = format-&gt;write_image(format_params, filename, outbuf, icc_type, icc_filename, exif_profile, length, imgid,</a>
<a name="ln914">                              num, total, &amp;pipe);</a>
<a name="ln915"> </a>
<a name="ln916">    free(exif_profile);</a>
<a name="ln917">  }</a>
<a name="ln918">  else</a>
<a name="ln919">  {</a>
<a name="ln920">    res = format-&gt;write_image(format_params, filename, outbuf, icc_type, icc_filename, NULL, 0, imgid, num, total,</a>
<a name="ln921">                              &amp;pipe);</a>
<a name="ln922">  }</a>
<a name="ln923"> </a>
<a name="ln924">  dt_dev_pixelpipe_cleanup(&amp;pipe);</a>
<a name="ln925">  dt_dev_cleanup(&amp;dev);</a>
<a name="ln926">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln927"> </a>
<a name="ln928">  /* now write xmp into that container, if possible */</a>
<a name="ln929">  if(copy_metadata &amp;&amp; (format-&gt;flags(format_params) &amp; FORMAT_FLAGS_SUPPORT_XMP))</a>
<a name="ln930">  {</a>
<a name="ln931">    dt_exif_xmp_attach(imgid, filename);</a>
<a name="ln932">    // no need to cancel the export if this fail</a>
<a name="ln933">  }</a>
<a name="ln934"> </a>
<a name="ln935">  if(!thumbnail_export &amp;&amp; strcmp(format-&gt;mime(format_params), &quot;memory&quot;)</a>
<a name="ln936">    &amp;&amp; !(format-&gt;flags(format_params) &amp; FORMAT_FLAGS_NO_TMPFILE))</a>
<a name="ln937">  {</a>
<a name="ln938">#ifdef USE_LUA</a>
<a name="ln939">    //Synchronous calling of lua intermediate-export-image events</a>
<a name="ln940">    dt_lua_lock();</a>
<a name="ln941"> </a>
<a name="ln942">    lua_State *L = darktable.lua_state.state;</a>
<a name="ln943"> </a>
<a name="ln944">    luaA_push(L, dt_lua_image_t, &amp;imgid);</a>
<a name="ln945"> </a>
<a name="ln946">    lua_pushstring(L, filename);</a>
<a name="ln947"> </a>
<a name="ln948">    luaA_push_type(L, format-&gt;parameter_lua_type, format_params);</a>
<a name="ln949"> </a>
<a name="ln950">    if (storage)</a>
<a name="ln951">      luaA_push_type(L, storage-&gt;parameter_lua_type, storage_params);</a>
<a name="ln952">    else</a>
<a name="ln953">      lua_pushnil(L);</a>
<a name="ln954"> </a>
<a name="ln955">    dt_lua_event_trigger(L, &quot;intermediate-export-image&quot;, 4);</a>
<a name="ln956"> </a>
<a name="ln957">    dt_lua_unlock();</a>
<a name="ln958">#endif</a>
<a name="ln959"> </a>
<a name="ln960">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_IMAGE_EXPORT_TMPFILE, imgid, filename, format,</a>
<a name="ln961">                            format_params, storage, storage_params);</a>
<a name="ln962">  }</a>
<a name="ln963"> </a>
<a name="ln964">  return res;</a>
<a name="ln965"> </a>
<a name="ln966">error:</a>
<a name="ln967">  dt_dev_pixelpipe_cleanup(&amp;pipe);</a>
<a name="ln968">error_early:</a>
<a name="ln969">  dt_dev_cleanup(&amp;dev);</a>
<a name="ln970">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln971">  return 1;</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974"> </a>
<a name="ln975">// fallback read method in case file could not be opened yet.</a>
<a name="ln976">// use GraphicsMagick (if supported) to read exotic LDRs</a>
<a name="ln977">dt_imageio_retval_t dt_imageio_open_exotic(dt_image_t *img, const char *filename,</a>
<a name="ln978">                                           dt_mipmap_buffer_t *buf)</a>
<a name="ln979">{</a>
<a name="ln980">#ifdef HAVE_GRAPHICSMAGICK</a>
<a name="ln981">  dt_imageio_retval_t ret = dt_imageio_open_gm(img, filename, buf);</a>
<a name="ln982">  if(ret == DT_IMAGEIO_OK || ret == DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln983">  {</a>
<a name="ln984">    img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln985">    img-&gt;flags &amp;= ~DT_IMAGE_RAW;</a>
<a name="ln986">    img-&gt;flags &amp;= ~DT_IMAGE_HDR;</a>
<a name="ln987">    img-&gt;flags |= DT_IMAGE_LDR;</a>
<a name="ln988">    img-&gt;loader = LOADER_GM;</a>
<a name="ln989">    return ret;</a>
<a name="ln990">  }</a>
<a name="ln991">#endif</a>
<a name="ln992"> </a>
<a name="ln993">  return DT_IMAGEIO_FILE_CORRUPTED;</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996"> </a>
<a name="ln997">// =================================================</a>
<a name="ln998">//   combined reading</a>
<a name="ln999">// =================================================</a>
<a name="ln1000"> </a>
<a name="ln1001">dt_imageio_retval_t dt_imageio_open(dt_image_t *img,               // non-const * means you hold a write lock!</a>
<a name="ln1002">                                    const char *filename,          // full path</a>
<a name="ln1003">                                    dt_mipmap_buffer_t *buf)</a>
<a name="ln1004">{</a>
<a name="ln1005">  /* first of all, check if file exists, don't bother to test loading if not exists */</a>
<a name="ln1006">  if(!g_file_test(filename, G_FILE_TEST_IS_REGULAR)) return !DT_IMAGEIO_OK;</a>
<a name="ln1007"> </a>
<a name="ln1008">  dt_imageio_retval_t ret = DT_IMAGEIO_FILE_CORRUPTED;</a>
<a name="ln1009">  img-&gt;loader = LOADER_UNKNOWN;</a>
<a name="ln1010"> </a>
<a name="ln1011">  /* check if file is ldr using magic's */</a>
<a name="ln1012">  if(dt_imageio_is_ldr(filename)) ret = dt_imageio_open_ldr(img, filename, buf);</a>
<a name="ln1013"> </a>
<a name="ln1014">  /* silly check using file extensions: */</a>
<a name="ln1015">  if(ret != DT_IMAGEIO_OK &amp;&amp; ret != DT_IMAGEIO_CACHE_FULL &amp;&amp; dt_imageio_is_hdr(filename))</a>
<a name="ln1016">    ret = dt_imageio_open_hdr(img, filename, buf);</a>
<a name="ln1017"> </a>
<a name="ln1018">  /* use rawspeed to load the raw */</a>
<a name="ln1019">  if(ret != DT_IMAGEIO_OK &amp;&amp; ret != DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln1020">  {</a>
<a name="ln1021">    ret = dt_imageio_open_rawspeed(img, filename, buf);</a>
<a name="ln1022">    if(ret == DT_IMAGEIO_OK) img-&gt;loader = LOADER_RAWSPEED;</a>
<a name="ln1023">  }</a>
<a name="ln1024"> </a>
<a name="ln1025">  /* fallback that tries to open file via GraphicsMagick */</a>
<a name="ln1026">  if(ret != DT_IMAGEIO_OK &amp;&amp; ret != DT_IMAGEIO_CACHE_FULL)</a>
<a name="ln1027">    ret = dt_imageio_open_exotic(img, filename, buf);</a>
<a name="ln1028"> </a>
<a name="ln1029">  return ret;</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1033">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1034">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'res' is always false.</p></div>
<div class="balloon" rel="687"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'h'. Check lines: 687, 666.</p></div>
<div class="balloon" rel="1006"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The enumeration constant 'DT_IMAGEIO_OK' is used as a variable of a Boolean-type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
