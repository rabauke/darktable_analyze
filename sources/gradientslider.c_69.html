
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c)2010--2012 Henrik Andersson.</a>
<a name="ln4">    copyright (c)2012 Ulrich Pegelow.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;assert.h&gt;</a>
<a name="ln21">#include &lt;math.h&gt;</a>
<a name="ln22">#include &lt;stdlib.h&gt;</a>
<a name="ln23">#include &lt;string.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;common/darktable.h&quot;</a>
<a name="ln26">#include &quot;develop/develop.h&quot;</a>
<a name="ln27">#include &quot;gradientslider.h&quot;</a>
<a name="ln28">#include &quot;gui/gtk.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#define CLAMP_RANGE(x, y, z) (CLAMP(x, y, z))</a>
<a name="ln31"> </a>
<a name="ln32">#define DTGTK_GRADIENT_SLIDER_VALUE_CHANGED_DELAY_MAX 50</a>
<a name="ln33">#define DTGTK_GRADIENT_SLIDER_VALUE_CHANGED_DELAY_MIN 10</a>
<a name="ln34">#define DTGTK_GRADIENT_SLIDER_DEFAULT_INCREMENT 0.01</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">static void _gradient_slider_class_init(GtkDarktableGradientSliderClass *klass);</a>
<a name="ln38">static void _gradient_slider_init(GtkDarktableGradientSlider *slider);</a>
<a name="ln39">static void _gradient_slider_realize(GtkWidget *widget);</a>
<a name="ln40">static gboolean _gradient_slider_draw(GtkWidget *widget, cairo_t *cr);</a>
<a name="ln41">static void _gradient_slider_destroy(GtkWidget *widget);</a>
<a name="ln42"> </a>
<a name="ln43">// Events</a>
<a name="ln44">static gboolean _gradient_slider_enter_notify_event(GtkWidget *widget, GdkEventCrossing *event);</a>
<a name="ln45">static gboolean _gradient_slider_button_press(GtkWidget *widget, GdkEventButton *event);</a>
<a name="ln46">static gboolean _gradient_slider_button_release(GtkWidget *widget, GdkEventButton *event);</a>
<a name="ln47">static gboolean _gradient_slider_motion_notify(GtkWidget *widget, GdkEventMotion *event);</a>
<a name="ln48">static gboolean _gradient_slider_scroll_event(GtkWidget *widget, GdkEventScroll *event);</a>
<a name="ln49">static gboolean _gradient_slider_key_press_event(GtkWidget *widget, GdkEventKey *event);</a>
<a name="ln50"> </a>
<a name="ln51">enum</a>
<a name="ln52">{</a>
<a name="ln53">  VALUE_CHANGED,</a>
<a name="ln54">  LAST_SIGNAL</a>
<a name="ln55">};</a>
<a name="ln56"> </a>
<a name="ln57">static guint _signals[LAST_SIGNAL] = { 0 };</a>
<a name="ln58"> </a>
<a name="ln59">static gboolean _gradient_slider_postponed_value_change(gpointer data)</a>
<a name="ln60">{</a>
<a name="ln61">  if(!GTK_IS_WIDGET(data)) return 0;</a>
<a name="ln62"> </a>
<a name="ln63">  if(DTGTK_GRADIENT_SLIDER(data)-&gt;is_changed == TRUE)</a>
<a name="ln64">  {</a>
<a name="ln65">    g_signal_emit_by_name(G_OBJECT(data), &quot;value-changed&quot;);</a>
<a name="ln66">    DTGTK_GRADIENT_SLIDER(data)-&gt;is_changed = FALSE;</a>
<a name="ln67">  }</a>
<a name="ln68"> </a>
<a name="ln69">  if(!DTGTK_GRADIENT_SLIDER(data)-&gt;is_dragging) DTGTK_GRADIENT_SLIDER(data)-&gt;timeout_handle = 0;</a>
<a name="ln70"> </a>
<a name="ln71">  return DTGTK_GRADIENT_SLIDER(data)-&gt;is_dragging; // This is called by the gtk mainloop and is threadsafe</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">static inline gdouble _screen_to_scale(GtkWidget *widget, gint screen)</a>
<a name="ln76">{</a>
<a name="ln77">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln78"> </a>
<a name="ln79">  GtkAllocation allocation;</a>
<a name="ln80">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln81">  return ((gdouble)screen - gslider-&gt;margins) / ((gdouble)allocation.width - 2 * gslider-&gt;margins);</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84">static inline gint _scale_to_screen(GtkWidget *widget, gdouble scale)</a>
<a name="ln85">{</a>
<a name="ln86">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln87"> </a>
<a name="ln88">  GtkAllocation allocation;</a>
<a name="ln89">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln90">  return (gint)(scale * (allocation.width - 2 * gslider-&gt;margins) + gslider-&gt;margins);</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93"> </a>
<a name="ln94">static gdouble _slider_move(GtkWidget *widget, gint k, gdouble value, gint direction)</a>
<a name="ln95">{</a>
<a name="ln96">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln97"> </a>
<a name="ln98">  gdouble newvalue = value;</a>
<a name="ln99">  gdouble leftnext = (k == 0) ? 0.0f : gslider-&gt;position[k - 1];</a>
<a name="ln100">  gdouble rightnext = (k == gslider-&gt;positions - 1) ? 1.0f : gslider-&gt;position[k + 1];</a>
<a name="ln101"> </a>
<a name="ln102">  switch(direction)</a>
<a name="ln103">  {</a>
<a name="ln104">    case MOVE_LEFT:</a>
<a name="ln105">      if(value &lt; leftnext)</a>
<a name="ln106">      {</a>
<a name="ln107">        newvalue = (k == 0) ? fmax(value, 0.0f) : _slider_move(widget, k - 1, value, direction);</a>
<a name="ln108">      }</a>
<a name="ln109">      break;</a>
<a name="ln110">    case MOVE_RIGHT:</a>
<a name="ln111">      if(value &gt; rightnext)</a>
<a name="ln112">      {</a>
<a name="ln113">        newvalue = (k == gslider-&gt;positions - 1) ? fmin(value, 1.0f)</a>
<a name="ln114">                                                 : _slider_move(widget, k + 1, value, direction);</a>
<a name="ln115">      }</a>
<a name="ln116">      break;</a>
<a name="ln117">  }</a>
<a name="ln118"> </a>
<a name="ln119">  gslider-&gt;position[k] = newvalue;</a>
<a name="ln120"> </a>
<a name="ln121">  return newvalue;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124"> </a>
<a name="ln125">static gboolean _gradient_slider_enter_notify_event(GtkWidget *widget, GdkEventCrossing *event)</a>
<a name="ln126">{</a>
<a name="ln127">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln128">  gtk_widget_set_state_flags(widget, GTK_STATE_FLAG_PRELIGHT, TRUE);</a>
<a name="ln129">  gslider-&gt;is_entered = TRUE;</a>
<a name="ln130">  gtk_widget_queue_draw(widget);</a>
<a name="ln131">  DTGTK_GRADIENT_SLIDER(widget)-&gt;prev_x_root = event-&gt;x_root;</a>
<a name="ln132">  return FALSE;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">static gboolean _gradient_slider_leave_notify_event(GtkWidget *widget, GdkEventCrossing *event)</a>
<a name="ln136">{</a>
<a name="ln137">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln138">  gtk_widget_set_state_flags(widget, GTK_STATE_FLAG_NORMAL, TRUE);</a>
<a name="ln139">  gslider-&gt;is_entered = FALSE;</a>
<a name="ln140">  gtk_widget_queue_draw(widget);</a>
<a name="ln141">  DTGTK_GRADIENT_SLIDER(widget)-&gt;prev_x_root = event-&gt;x_root;</a>
<a name="ln142">  return FALSE;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">static gboolean _gradient_slider_button_press(GtkWidget *widget, GdkEventButton *event)</a>
<a name="ln146">{</a>
<a name="ln147">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln148"> </a>
<a name="ln149">  if(event-&gt;button == 1 &amp;&amp; event-&gt;type == GDK_2BUTTON_PRESS &amp;&amp; gslider-&gt;is_resettable)</a>
<a name="ln150">  {</a>
<a name="ln151">    gslider-&gt;is_dragging = FALSE;</a>
<a name="ln152">    gslider-&gt;do_reset = TRUE;</a>
<a name="ln153">    gslider-&gt;selected = -1;</a>
<a name="ln154">    for(int k = 0; k &lt; gslider-&gt;positions; k++) gslider-&gt;position[k] = gslider-&gt;resetvalue[k];</a>
<a name="ln155">    gtk_widget_queue_draw(widget);</a>
<a name="ln156">    g_signal_emit_by_name(G_OBJECT(widget), &quot;value-changed&quot;);</a>
<a name="ln157">  }</a>
<a name="ln158">  else if((event-&gt;button == 1 || event-&gt;button == 3) &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS)</a>
<a name="ln159">  {</a>
<a name="ln160">    gint lselected = -1;</a>
<a name="ln161">    gdouble newposition = roundf(_screen_to_scale(widget, event-&gt;x) / gslider-&gt;increment)</a>
<a name="ln162">                          * gslider-&gt;increment;</a>
<a name="ln163">    gslider-&gt;prev_x_root = event-&gt;x_root;</a>
<a name="ln164"> </a>
<a name="ln165">    assert(gslider-&gt;positions &gt; 0);</a>
<a name="ln166"> </a>
<a name="ln167">    if(gslider-&gt;positions == 1)</a>
<a name="ln168">    {</a>
<a name="ln169">      lselected = 0;</a>
<a name="ln170">    }</a>
<a name="ln171">    else if(newposition &lt;= gslider-&gt;position[0])</a>
<a name="ln172">    {</a>
<a name="ln173">      lselected = 0;</a>
<a name="ln174">    }</a>
<a name="ln175">    else if(newposition &gt;= gslider-&gt;position[gslider-&gt;positions - 1])</a>
<a name="ln176">    {</a>
<a name="ln177">      lselected = gslider-&gt;positions - 1;</a>
<a name="ln178">    }</a>
<a name="ln179">    else</a>
<a name="ln180">      for(int k = 0; k &lt;= gslider-&gt;positions - 2; k++)</a>
<a name="ln181">      {</a>
<a name="ln182">        if(newposition &gt;= gslider-&gt;position[k] &amp;&amp; newposition &lt;= gslider-&gt;position[k + 1])</a>
<a name="ln183">        {</a>
<a name="ln184">          lselected = newposition - gslider-&gt;position[k] &lt; gslider-&gt;position[k + 1] - newposition ? k : k + 1;</a>
<a name="ln185">          break;</a>
<a name="ln186">        }</a>
<a name="ln187">      }</a>
<a name="ln188"> </a>
<a name="ln189">    assert(lselected &gt;= 0);</a>
<a name="ln190">    assert(lselected &lt;= gslider-&gt;positions - 1);</a>
<a name="ln191"> </a>
<a name="ln192"> </a>
<a name="ln193">    if(event-&gt;button == 1 &amp;&amp; lselected &gt;= 0) // left mouse button : select and start dragging</a>
<a name="ln194">    {</a>
<a name="ln195">      gslider-&gt;selected = lselected;</a>
<a name="ln196">      gslider-&gt;do_reset = FALSE;</a>
<a name="ln197"> </a>
<a name="ln198">      newposition = CLAMP_RANGE(newposition, 0.0, 1.0);</a>
<a name="ln199"> </a>
<a name="ln200">      gint direction = gslider-&gt;position[gslider-&gt;selected] &lt;= newposition ? MOVE_RIGHT : MOVE_LEFT;</a>
<a name="ln201"> </a>
<a name="ln202">      _slider_move(widget, gslider-&gt;selected, newposition, direction);</a>
<a name="ln203">      gslider-&gt;min = gslider-&gt;selected == 0 ? 0.0f : gslider-&gt;position[gslider-&gt;selected - 1];</a>
<a name="ln204">      gslider-&gt;max = gslider-&gt;selected == gslider-&gt;positions - 1 ? 1.0f</a>
<a name="ln205">                                                                 : gslider-&gt;position[gslider-&gt;selected + 1];</a>
<a name="ln206"> </a>
<a name="ln207">      gslider-&gt;is_changed = TRUE;</a>
<a name="ln208">      gslider-&gt;is_dragging = TRUE;</a>
<a name="ln209">      // timeout_handle should always be zero here, but check just in case</a>
<a name="ln210">      int delay = CLAMP_RANGE(darktable.develop-&gt;average_delay * 3 / 2,</a>
<a name="ln211">                              DTGTK_GRADIENT_SLIDER_VALUE_CHANGED_DELAY_MIN,</a>
<a name="ln212">                              DTGTK_GRADIENT_SLIDER_VALUE_CHANGED_DELAY_MAX);</a>
<a name="ln213">      if(!gslider-&gt;timeout_handle)</a>
<a name="ln214">        gslider-&gt;timeout_handle = g_timeout_add(delay, _gradient_slider_postponed_value_change, widget);</a>
<a name="ln215">    }</a>
<a name="ln216">    else if(gslider-&gt;positions</a>
<a name="ln217">            &gt; 1) // right mouse button: switch on/off selection (only if we have more than one marker)</a>
<a name="ln218">    {</a>
<a name="ln219">      gslider-&gt;is_dragging = FALSE;</a>
<a name="ln220">      gslider-&gt;do_reset = FALSE;</a>
<a name="ln221"> </a>
<a name="ln222">      if(gslider-&gt;selected != lselected)</a>
<a name="ln223">      {</a>
<a name="ln224">        gslider-&gt;selected = lselected;</a>
<a name="ln225">        gslider-&gt;min = gslider-&gt;selected == 0 ? 0.0f : gslider-&gt;position[gslider-&gt;selected - 1];</a>
<a name="ln226">        gslider-&gt;max = gslider-&gt;selected == gslider-&gt;positions - 1 ? 1.0f</a>
<a name="ln227">                                                                   : gslider-&gt;position[gslider-&gt;selected + 1];</a>
<a name="ln228">      }</a>
<a name="ln229">      else</a>
<a name="ln230">        gslider-&gt;selected = -1;</a>
<a name="ln231"> </a>
<a name="ln232">      gtk_widget_queue_draw(widget);</a>
<a name="ln233">    }</a>
<a name="ln234">  }</a>
<a name="ln235"> </a>
<a name="ln236">  return TRUE;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">static gboolean _gradient_slider_motion_notify(GtkWidget *widget, GdkEventMotion *event)</a>
<a name="ln240">{</a>
<a name="ln241">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln242"> </a>
<a name="ln243">  if(gslider-&gt;is_dragging == TRUE &amp;&amp; gslider-&gt;selected != -1 &amp;&amp; gslider-&gt;do_reset == FALSE)</a>
<a name="ln244">  {</a>
<a name="ln245">    assert(gslider-&gt;timeout_handle &gt; 0);</a>
<a name="ln246"> </a>
<a name="ln247">    gdouble newposition = roundf(_screen_to_scale(widget, event-&gt;x) / gslider-&gt;increment)</a>
<a name="ln248">                          * gslider-&gt;increment;</a>
<a name="ln249"> </a>
<a name="ln250">    newposition = CLAMP_RANGE(newposition, 0.0, 1.0);</a>
<a name="ln251"> </a>
<a name="ln252">    gint direction = gslider-&gt;position[gslider-&gt;selected] &lt;= newposition ? MOVE_RIGHT : MOVE_LEFT;</a>
<a name="ln253"> </a>
<a name="ln254">    _slider_move(widget, gslider-&gt;selected, newposition, direction);</a>
<a name="ln255">    gslider-&gt;min = gslider-&gt;selected == 0 ? 0.0f : gslider-&gt;position[gslider-&gt;selected - 1];</a>
<a name="ln256">    gslider-&gt;max = gslider-&gt;selected == gslider-&gt;positions - 1 ? 1.0f</a>
<a name="ln257">                                                               : gslider-&gt;position[gslider-&gt;selected + 1];</a>
<a name="ln258"> </a>
<a name="ln259">    gslider-&gt;is_changed = TRUE;</a>
<a name="ln260"> </a>
<a name="ln261">    gtk_widget_queue_draw(widget);</a>
<a name="ln262">  }</a>
<a name="ln263"> </a>
<a name="ln264">  if(gslider-&gt;selected != -1) gtk_widget_grab_focus(widget);</a>
<a name="ln265"> </a>
<a name="ln266">  return TRUE;</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">static gboolean _gradient_slider_button_release(GtkWidget *widget, GdkEventButton *event)</a>
<a name="ln270">{</a>
<a name="ln271">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln272">  if(event-&gt;button == 1 &amp;&amp; gslider-&gt;selected != -1 &amp;&amp; gslider-&gt;do_reset == FALSE)</a>
<a name="ln273">  {</a>
<a name="ln274">    // First get some dimension info</a>
<a name="ln275">    gslider-&gt;is_changed = TRUE;</a>
<a name="ln276">    gdouble newposition = roundf(_screen_to_scale(widget, event-&gt;x) / gslider-&gt;increment)</a>
<a name="ln277">                          * gslider-&gt;increment;</a>
<a name="ln278"> </a>
<a name="ln279">    newposition = CLAMP_RANGE(newposition, 0.0, 1.0);</a>
<a name="ln280"> </a>
<a name="ln281">    gint direction = gslider-&gt;position[gslider-&gt;selected] &lt;= newposition ? MOVE_RIGHT : MOVE_LEFT;</a>
<a name="ln282"> </a>
<a name="ln283">    _slider_move(widget, gslider-&gt;selected, newposition, direction);</a>
<a name="ln284">    gslider-&gt;min = gslider-&gt;selected == 0 ? 0.0f : gslider-&gt;position[gslider-&gt;selected - 1];</a>
<a name="ln285">    gslider-&gt;max = gslider-&gt;selected == gslider-&gt;positions - 1 ? 1.0f</a>
<a name="ln286">                                                               : gslider-&gt;position[gslider-&gt;selected + 1];</a>
<a name="ln287"> </a>
<a name="ln288">    gtk_widget_queue_draw(widget);</a>
<a name="ln289">    gslider-&gt;prev_x_root = event-&gt;x_root;</a>
<a name="ln290">    gslider-&gt;is_dragging = FALSE;</a>
<a name="ln291">    if(gslider-&gt;timeout_handle) g_source_remove(gslider-&gt;timeout_handle);</a>
<a name="ln292">    gslider-&gt;timeout_handle = 0;</a>
<a name="ln293">    g_signal_emit_by_name(G_OBJECT(widget), &quot;value-changed&quot;);</a>
<a name="ln294">  }</a>
<a name="ln295">  return TRUE;</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">static gboolean _gradient_slider_add_delta_internal(GtkWidget *widget, gdouble delta, guint state)</a>
<a name="ln299">{</a>
<a name="ln300">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln301"> </a>
<a name="ln302">  if(gslider-&gt;selected == -1) return TRUE;</a>
<a name="ln303"> </a>
<a name="ln304">  float multiplier;</a>
<a name="ln305"> </a>
<a name="ln306">  GdkModifierType modifiers = gtk_accelerator_get_default_mod_mask();</a>
<a name="ln307">  if((state &amp; modifiers) == GDK_SHIFT_MASK)</a>
<a name="ln308">  {</a>
<a name="ln309">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_rough_step_multiplier&quot;);</a>
<a name="ln310">  }</a>
<a name="ln311">  else if((state &amp; modifiers) == GDK_CONTROL_MASK)</a>
<a name="ln312">  {</a>
<a name="ln313">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_precise_step_multiplier&quot;);</a>
<a name="ln314">  }</a>
<a name="ln315">  else</a>
<a name="ln316">  {</a>
<a name="ln317">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_step_multiplier&quot;);</a>
<a name="ln318">  }</a>
<a name="ln319"> </a>
<a name="ln320">  delta *= multiplier;</a>
<a name="ln321"> </a>
<a name="ln322">  gdouble newvalue = gslider-&gt;position[gslider-&gt;selected] + delta;</a>
<a name="ln323"> </a>
<a name="ln324">  gslider-&gt;position[gslider-&gt;selected] = CLAMP(newvalue, gslider-&gt;min, gslider-&gt;max);</a>
<a name="ln325"> </a>
<a name="ln326">  gtk_widget_queue_draw(widget);</a>
<a name="ln327">  g_signal_emit_by_name(G_OBJECT(widget), &quot;value-changed&quot;);</a>
<a name="ln328"> </a>
<a name="ln329">  return TRUE;</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332">static gboolean _gradient_slider_scroll_event(GtkWidget *widget, GdkEventScroll *event)</a>
<a name="ln333">{</a>
<a name="ln334">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln335"> </a>
<a name="ln336">  if(gslider-&gt;selected == -1) return TRUE;</a>
<a name="ln337"> </a>
<a name="ln338">  gdouble delta_y;</a>
<a name="ln339">  if(dt_gui_get_scroll_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln340">  {</a>
<a name="ln341">    delta_y *= -gslider-&gt;increment;</a>
<a name="ln342">    return _gradient_slider_add_delta_internal(widget, delta_y, event-&gt;state);</a>
<a name="ln343">  }</a>
<a name="ln344"> </a>
<a name="ln345">  return TRUE;</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">static gboolean _gradient_slider_key_press_event(GtkWidget *widget, GdkEventKey *event)</a>
<a name="ln349">{</a>
<a name="ln350">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln351"> </a>
<a name="ln352">  if(gslider-&gt;selected == -1) return TRUE;</a>
<a name="ln353"> </a>
<a name="ln354">  int handled = 0;</a>
<a name="ln355">  float delta = 0.0f;</a>
<a name="ln356"> </a>
<a name="ln357">  if(event-&gt;keyval == GDK_KEY_Up || event-&gt;keyval == GDK_KEY_KP_Up || event-&gt;keyval == GDK_KEY_Right</a>
<a name="ln358">     || event-&gt;keyval == GDK_KEY_KP_Right)</a>
<a name="ln359">  {</a>
<a name="ln360">    handled = 1;</a>
<a name="ln361">    delta = gslider-&gt;increment;</a>
<a name="ln362">  }</a>
<a name="ln363">  else if(event-&gt;keyval == GDK_KEY_Down || event-&gt;keyval == GDK_KEY_KP_Down || event-&gt;keyval == GDK_KEY_Left</a>
<a name="ln364">          || event-&gt;keyval == GDK_KEY_KP_Left)</a>
<a name="ln365">  {</a>
<a name="ln366">    handled = 1;</a>
<a name="ln367">    delta = -gslider-&gt;increment;</a>
<a name="ln368">  }</a>
<a name="ln369"> </a>
<a name="ln370">  if(!handled) return TRUE;</a>
<a name="ln371"> </a>
<a name="ln372">  return _gradient_slider_add_delta_internal(widget, delta, event-&gt;state);</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">static void _gradient_slider_class_init(GtkDarktableGradientSliderClass *klass)</a>
<a name="ln376">{</a>
<a name="ln377">  GtkWidgetClass *widget_class = (GtkWidgetClass *)klass;</a>
<a name="ln378"> </a>
<a name="ln379">  widget_class-&gt;realize = _gradient_slider_realize;</a>
<a name="ln380">  widget_class-&gt;draw = _gradient_slider_draw;</a>
<a name="ln381">  widget_class-&gt;destroy = _gradient_slider_destroy;</a>
<a name="ln382"> </a>
<a name="ln383">  widget_class-&gt;enter_notify_event = _gradient_slider_enter_notify_event;</a>
<a name="ln384">  widget_class-&gt;leave_notify_event = _gradient_slider_leave_notify_event;</a>
<a name="ln385">  widget_class-&gt;button_press_event = _gradient_slider_button_press;</a>
<a name="ln386">  widget_class-&gt;button_release_event = _gradient_slider_button_release;</a>
<a name="ln387">  widget_class-&gt;motion_notify_event = _gradient_slider_motion_notify;</a>
<a name="ln388">  widget_class-&gt;scroll_event = _gradient_slider_scroll_event;</a>
<a name="ln389">  widget_class-&gt;key_press_event = _gradient_slider_key_press_event;</a>
<a name="ln390"> </a>
<a name="ln391">  _signals[VALUE_CHANGED] = g_signal_new(&quot;value-changed&quot;, G_TYPE_FROM_CLASS(klass), G_SIGNAL_RUN_LAST, 0,</a>
<a name="ln392">                                         NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">static void _gradient_slider_init(GtkDarktableGradientSlider *slider)</a>
<a name="ln396">{</a>
<a name="ln397">  slider-&gt;prev_x_root = slider-&gt;is_dragging = slider-&gt;is_changed = slider-&gt;do_reset = slider-&gt;is_entered = 0;</a>
<a name="ln398">  slider-&gt;timeout_handle = 0;</a>
<a name="ln399">  slider-&gt;selected = slider-&gt;positions == 1 ? 0 : -1;</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">static void _gradient_slider_realize(GtkWidget *widget)</a>
<a name="ln403">{</a>
<a name="ln404">  GdkWindowAttr attributes;</a>
<a name="ln405">  guint attributes_mask;</a>
<a name="ln406"> </a>
<a name="ln407">  g_return_if_fail(widget != NULL);</a>
<a name="ln408">  g_return_if_fail(DTGTK_IS_GRADIENT_SLIDER(widget));</a>
<a name="ln409"> </a>
<a name="ln410">  gtk_widget_set_realized(widget, TRUE);</a>
<a name="ln411"> </a>
<a name="ln412">  GtkAllocation allocation;</a>
<a name="ln413">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln414">  attributes.window_type = GDK_WINDOW_CHILD;</a>
<a name="ln415">  attributes.x = allocation.x;</a>
<a name="ln416">  attributes.y = allocation.y;</a>
<a name="ln417">  attributes.width = DT_PIXEL_APPLY_DPI(100);</a>
<a name="ln418">  attributes.height = DT_PIXEL_APPLY_DPI(17);</a>
<a name="ln419"> </a>
<a name="ln420">  attributes.wclass = GDK_INPUT_OUTPUT;</a>
<a name="ln421">  attributes.event_mask = gtk_widget_get_events(widget) | GDK_EXPOSURE_MASK | GDK_BUTTON_PRESS_MASK</a>
<a name="ln422">                          | GDK_BUTTON_RELEASE_MASK | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK</a>
<a name="ln423">                          | GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK | GDK_POINTER_MOTION_MASK</a>
<a name="ln424">                          | darktable.gui-&gt;scroll_mask;</a>
<a name="ln425">  attributes_mask = GDK_WA_X | GDK_WA_Y;</a>
<a name="ln426"> </a>
<a name="ln427">  gtk_widget_set_can_focus(GTK_WIDGET(widget), TRUE);</a>
<a name="ln428"> </a>
<a name="ln429">  gtk_widget_set_window(widget,</a>
<a name="ln430">                        gdk_window_new(gtk_widget_get_parent_window(widget), &amp;attributes, attributes_mask));</a>
<a name="ln431"> </a>
<a name="ln432">  gdk_window_set_user_data(gtk_widget_get_window(widget), widget);</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435"> </a>
<a name="ln436">static void _gradient_slider_destroy(GtkWidget *widget)</a>
<a name="ln437">{</a>
<a name="ln438">  GtkDarktableGradientSliderClass *klass;</a>
<a name="ln439">  g_return_if_fail(widget != NULL);</a>
<a name="ln440">  g_return_if_fail(DTGTK_IS_GRADIENT_SLIDER(widget));</a>
<a name="ln441"> </a>
<a name="ln442">  if(DTGTK_GRADIENT_SLIDER(widget)-&gt;timeout_handle)</a>
<a name="ln443">    g_source_remove(DTGTK_GRADIENT_SLIDER(widget)-&gt;timeout_handle);</a>
<a name="ln444">  DTGTK_GRADIENT_SLIDER(widget)-&gt;timeout_handle = 0;</a>
<a name="ln445"> </a>
<a name="ln446">  if(DTGTK_GRADIENT_SLIDER(widget)-&gt;colors)</a>
<a name="ln447">  {</a>
<a name="ln448">    g_list_free_full(DTGTK_GRADIENT_SLIDER(widget)-&gt;colors, g_free);</a>
<a name="ln449">    DTGTK_GRADIENT_SLIDER(widget)-&gt;colors = NULL;</a>
<a name="ln450">  }</a>
<a name="ln451"> </a>
<a name="ln452">  // FIXME: or it should be g_type_class_ref () ?</a>
<a name="ln453">  klass = g_type_class_peek(gtk_widget_get_type());</a>
<a name="ln454">  if(GTK_WIDGET_CLASS(klass)-&gt;destroy)</a>
<a name="ln455">  {</a>
<a name="ln456">    (*GTK_WIDGET_CLASS(klass)-&gt;destroy)(widget);</a>
<a name="ln457">  }</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">static gboolean _gradient_slider_draw(GtkWidget *widget, cairo_t *cr)</a>
<a name="ln461">{</a>
<a name="ln462">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln463"> </a>
<a name="ln464">  assert(gslider-&gt;position &gt; 0);</a>
<a name="ln465"> </a>
<a name="ln466">  g_return_val_if_fail(widget != NULL, FALSE);</a>
<a name="ln467">  g_return_val_if_fail(DTGTK_IS_GRADIENT_SLIDER(widget), FALSE);</a>
<a name="ln468"> </a>
<a name="ln469">  GdkRGBA color;</a>
<a name="ln470">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln471">  gtk_style_context_get_color(context, gtk_widget_get_state_flags(widget), &amp;color);</a>
<a name="ln472"> </a>
<a name="ln473">  GtkAllocation allocation;</a>
<a name="ln474">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln475">  int width = allocation.width;</a>
<a name="ln476">  int height = allocation.height;</a>
<a name="ln477">  int margins = gslider-&gt;margins;</a>
<a name="ln478"> </a>
<a name="ln479">  // Begin cairo drawing</a>
<a name="ln480">  // First build the cairo gradient and then fill the gradient</a>
<a name="ln481">  float gheight = height / 2.0;</a>
<a name="ln482">  float gwidth = width - 2 * margins;</a>
<a name="ln483">  GList *current = NULL;</a>
<a name="ln484">  cairo_pattern_t *gradient = NULL;</a>
<a name="ln485">  if((current = g_list_first(gslider-&gt;colors)) != NULL)</a>
<a name="ln486">  {</a>
<a name="ln487">    gradient = cairo_pattern_create_linear(0, 0, gwidth, gheight);</a>
<a name="ln488">    do</a>
<a name="ln489">    {</a>
<a name="ln490">      _gradient_slider_stop_t *stop = (_gradient_slider_stop_t *)current-&gt;data;</a>
<a name="ln491">      cairo_pattern_add_color_stop_rgb(gradient, stop-&gt;position, stop-&gt;color.red, stop-&gt;color.green,</a>
<a name="ln492">                                       stop-&gt;color.blue);</a>
<a name="ln493">    } while((current = g_list_next(current)) != NULL);</a>
<a name="ln494">  }</a>
<a name="ln495"> </a>
<a name="ln496">  if(gradient != NULL) // Do we got a gradient, lets draw it</a>
<a name="ln497">  {</a>
<a name="ln498">    cairo_set_line_width(cr, 0.1);</a>
<a name="ln499">    cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln500">    cairo_set_source(cr, gradient);</a>
<a name="ln501">    cairo_rectangle(cr, margins, (height - gheight) / 2.0, gwidth, gheight);</a>
<a name="ln502">    cairo_fill(cr);</a>
<a name="ln503">    cairo_stroke(cr);</a>
<a name="ln504">    cairo_pattern_destroy(gradient);</a>
<a name="ln505">  }</a>
<a name="ln506"> </a>
<a name="ln507">  // Lets draw position arrows</a>
<a name="ln508"> </a>
<a name="ln509">  cairo_set_source_rgba(cr, color.red, color.green, color.blue, 1.0);</a>
<a name="ln510"> </a>
<a name="ln511"> </a>
<a name="ln512">  // do we have a picker value to draw?</a>
<a name="ln513">  if(!isnan(gslider-&gt;picker[0]))</a>
<a name="ln514">  {</a>
<a name="ln515">    int vx_min = _scale_to_screen(widget, CLAMP_RANGE(gslider-&gt;picker[1], 0.0, 1.0));</a>
<a name="ln516">    int vx_max = _scale_to_screen(widget, CLAMP_RANGE(gslider-&gt;picker[2], 0.0, 1.0));</a>
<a name="ln517">    int vx_avg = _scale_to_screen(widget, CLAMP_RANGE(gslider-&gt;picker[0], 0.0, 1.0));</a>
<a name="ln518"> </a>
<a name="ln519">    cairo_set_source_rgba(cr, color.red, color.green, color.blue, 0.33);</a>
<a name="ln520"> </a>
<a name="ln521">    cairo_rectangle(cr, vx_min, (height - gheight) / 2.0, fmax((float)vx_max - vx_min, 0.0f), gheight);</a>
<a name="ln522">    cairo_fill(cr);</a>
<a name="ln523"> </a>
<a name="ln524">    cairo_set_source_rgba(cr, color.red, color.green, color.blue, 1.0);</a>
<a name="ln525"> </a>
<a name="ln526">    cairo_move_to(cr, vx_avg, (height - gheight) / 2.0);</a>
<a name="ln527">    cairo_line_to(cr, vx_avg, (height + gheight) / 2.0);</a>
<a name="ln528">    cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE);</a>
<a name="ln529">    cairo_set_line_width(cr, 1.0);</a>
<a name="ln530">    cairo_stroke(cr);</a>
<a name="ln531">  }</a>
<a name="ln532"> </a>
<a name="ln533">  int indirect[GRADIENT_SLIDER_MAX_POSITIONS];</a>
<a name="ln534">  for(int k = 0; k &lt; gslider-&gt;positions; k++)</a>
<a name="ln535">    indirect[k] = gslider-&gt;selected == -1 ? k : (gslider-&gt;selected + 1 + k) % gslider-&gt;positions;</a>
<a name="ln536"> </a>
<a name="ln537"> </a>
<a name="ln538">  for(int k = 0; k &lt; gslider-&gt;positions; k++)</a>
<a name="ln539">  {</a>
<a name="ln540">    int l = indirect[k];</a>
<a name="ln541">    int vx = _scale_to_screen(widget, gslider-&gt;position[l]);</a>
<a name="ln542">    int mk = gslider-&gt;marker[l];</a>
<a name="ln543">    int sz = (mk &amp; (1 &lt;&lt; 3)) ? 13 : 10; // big or small marker?</a>
<a name="ln544"> </a>
<a name="ln545">    if(l == gslider-&gt;selected &amp;&amp; (gslider-&gt;is_entered == TRUE || gslider-&gt;is_dragging == TRUE))</a>
<a name="ln546">    {</a>
<a name="ln547">      cairo_set_source_rgba(cr, color.red, color.green, color.blue, 1.0);</a>
<a name="ln548">    }</a>
<a name="ln549">    else</a>
<a name="ln550">    {</a>
<a name="ln551">      cairo_set_source_rgba(cr, color.red * 0.8, color.green * 0.8, color.blue * 0.8, 1.0);</a>
<a name="ln552">    }</a>
<a name="ln553"> </a>
<a name="ln554"> </a>
<a name="ln555">    cairo_set_antialias(cr, CAIRO_ANTIALIAS_DEFAULT);</a>
<a name="ln556"> </a>
<a name="ln557">    if(mk &amp; 0x04) /* upper arrow */</a>
<a name="ln558">    {</a>
<a name="ln559">      if(mk &amp; 0x01) /* filled */</a>
<a name="ln560">        dtgtk_cairo_paint_solid_triangle(cr, (vx - DT_PIXEL_APPLY_DPI(sz) * 0.5),</a>
<a name="ln561">                                         sz &lt; 10 ? DT_PIXEL_APPLY_DPI(1) : DT_PIXEL_APPLY_DPI(-2),</a>
<a name="ln562">                                         DT_PIXEL_APPLY_DPI(sz), DT_PIXEL_APPLY_DPI(sz), CPF_DIRECTION_DOWN, NULL);</a>
<a name="ln563">      else</a>
<a name="ln564">        dtgtk_cairo_paint_triangle(cr, (vx - DT_PIXEL_APPLY_DPI(sz) * 0.5),</a>
<a name="ln565">                                   sz &lt; 10 ? DT_PIXEL_APPLY_DPI(1) : DT_PIXEL_APPLY_DPI(-2),</a>
<a name="ln566">                                   DT_PIXEL_APPLY_DPI(sz), DT_PIXEL_APPLY_DPI(sz), CPF_DIRECTION_DOWN, NULL);</a>
<a name="ln567">    }</a>
<a name="ln568"> </a>
<a name="ln569">    if(mk &amp; 0x02) /* lower arrow */</a>
<a name="ln570">    {</a>
<a name="ln571">      if(mk &amp; 0x01) /* filled */</a>
<a name="ln572">        dtgtk_cairo_paint_solid_triangle(cr, (vx - DT_PIXEL_APPLY_DPI(sz) * 0.5),</a>
<a name="ln573">                                         sz &lt; 10 ? height - DT_PIXEL_APPLY_DPI(6) : height</a>
<a name="ln574">                                                                                    - DT_PIXEL_APPLY_DPI(11),</a>
<a name="ln575">                                         DT_PIXEL_APPLY_DPI(sz), DT_PIXEL_APPLY_DPI(sz), CPF_DIRECTION_UP, NULL);</a>
<a name="ln576">      else</a>
<a name="ln577">        dtgtk_cairo_paint_triangle(cr, (vx - DT_PIXEL_APPLY_DPI(sz) * 0.5),</a>
<a name="ln578">                                   sz &lt; 10 ? height - DT_PIXEL_APPLY_DPI(6) : height - DT_PIXEL_APPLY_DPI(11),</a>
<a name="ln579">                                   DT_PIXEL_APPLY_DPI(sz), DT_PIXEL_APPLY_DPI(sz), CPF_DIRECTION_UP, NULL);</a>
<a name="ln580">    }</a>
<a name="ln581">  }</a>
<a name="ln582"> </a>
<a name="ln583">  return FALSE;</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586">// Public functions for multivalue type</a>
<a name="ln587">GtkWidget *dtgtk_gradient_slider_multivalue_new(gint positions)</a>
<a name="ln588">{</a>
<a name="ln589">  assert(positions &lt;= GRADIENT_SLIDER_MAX_POSITIONS);</a>
<a name="ln590"> </a>
<a name="ln591">  GtkDarktableGradientSlider *gslider;</a>
<a name="ln592">  gslider = g_object_new(dtgtk_gradient_slider_get_type(), NULL);</a>
<a name="ln593">  gslider-&gt;positions = positions;</a>
<a name="ln594">  gslider-&gt;is_resettable = FALSE;</a>
<a name="ln595">  gslider-&gt;is_entered = FALSE;</a>
<a name="ln596">  gslider-&gt;picker[0] = gslider-&gt;picker[1] = gslider-&gt;picker[2] = NAN;</a>
<a name="ln597">  gslider-&gt;selected = positions == 1 ? 0 : -1;</a>
<a name="ln598">  gslider-&gt;min = 0.0;</a>
<a name="ln599">  gslider-&gt;max = 1.0;</a>
<a name="ln600">  gslider-&gt;increment = DTGTK_GRADIENT_SLIDER_DEFAULT_INCREMENT;</a>
<a name="ln601">  gslider-&gt;margins = GRADIENT_SLIDER_MARGINS_DEFAULT;</a>
<a name="ln602">  for(int k = 0; k &lt; positions; k++) gslider-&gt;position[k] = 0.0;</a>
<a name="ln603">  for(int k = 0; k &lt; positions; k++) gslider-&gt;resetvalue[k] = 0.0;</a>
<a name="ln604">  for(int k = 0; k &lt; positions; k++) gslider-&gt;marker[k] = GRADIENT_SLIDER_MARKER_LOWER_FILLED;</a>
<a name="ln605">  return (GtkWidget *)gslider;</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608"> </a>
<a name="ln609">GtkWidget *dtgtk_gradient_slider_multivalue_new_with_color(GdkRGBA start, GdkRGBA end, gint positions)</a>
<a name="ln610">{</a>
<a name="ln611">  assert(positions &lt;= GRADIENT_SLIDER_MAX_POSITIONS);</a>
<a name="ln612"> </a>
<a name="ln613">  GtkDarktableGradientSlider *gslider;</a>
<a name="ln614">  gslider = g_object_new(dtgtk_gradient_slider_get_type(), NULL);</a>
<a name="ln615">  gslider-&gt;positions = positions;</a>
<a name="ln616">  gslider-&gt;is_resettable = FALSE;</a>
<a name="ln617">  gslider-&gt;is_entered = FALSE;</a>
<a name="ln618">  gslider-&gt;picker[0] = gslider-&gt;picker[1] = gslider-&gt;picker[2] = NAN;</a>
<a name="ln619">  gslider-&gt;selected = positions == 1 ? 0 : -1;</a>
<a name="ln620">  gslider-&gt;min = 0.0;</a>
<a name="ln621">  gslider-&gt;max = 1.0;</a>
<a name="ln622">  gslider-&gt;increment = DTGTK_GRADIENT_SLIDER_DEFAULT_INCREMENT;</a>
<a name="ln623">  gslider-&gt;margins = GRADIENT_SLIDER_MARGINS_DEFAULT;</a>
<a name="ln624">  for(int k = 0; k &lt; positions; k++) gslider-&gt;position[k] = 0.0;</a>
<a name="ln625">  for(int k = 0; k &lt; positions; k++) gslider-&gt;resetvalue[k] = 0.0;</a>
<a name="ln626">  for(int k = 0; k &lt; positions; k++) gslider-&gt;marker[k] = GRADIENT_SLIDER_MARKER_LOWER_FILLED;</a>
<a name="ln627"> </a>
<a name="ln628">  // Construct gradient start color</a>
<a name="ln629">  _gradient_slider_stop_t *gc = (_gradient_slider_stop_t *)g_malloc(sizeof(_gradient_slider_stop_t));</a>
<a name="ln630">  gc-&gt;position = 0.0;</a>
<a name="ln631">  memcpy(&amp;gc-&gt;color, &amp;start, sizeof(GdkRGBA));</a>
<a name="ln632">  gslider-&gt;colors = g_list_append(gslider-&gt;colors, gc);</a>
<a name="ln633"> </a>
<a name="ln634">  // Construct gradient stop color</a>
<a name="ln635">  gc = (_gradient_slider_stop_t *)g_malloc(sizeof(_gradient_slider_stop_t));</a>
<a name="ln636">  gc-&gt;position = 1.0;</a>
<a name="ln637">  memcpy(&amp;gc-&gt;color, &amp;end, sizeof(GdkRGBA));</a>
<a name="ln638">  gslider-&gt;colors = g_list_append(gslider-&gt;colors, gc);</a>
<a name="ln639"> </a>
<a name="ln640"> </a>
<a name="ln641">  return (GtkWidget *)gslider;</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644"> </a>
<a name="ln645">gint _list_find_by_position(gconstpointer a, gconstpointer b)</a>
<a name="ln646">{</a>
<a name="ln647">  _gradient_slider_stop_t *stop = (_gradient_slider_stop_t *)a;</a>
<a name="ln648">  gfloat position = *((gfloat *)b);</a>
<a name="ln649">  return (gint)((stop-&gt;position * 100.0) - (position * 100.0));</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">void dtgtk_gradient_slider_multivalue_set_stop(GtkDarktableGradientSlider *gslider, gfloat position,</a>
<a name="ln653">                                               GdkRGBA color)</a>
<a name="ln654">{</a>
<a name="ln655">  // First find color at position, if exists update color, otherwise create a new stop at position.</a>
<a name="ln656">  GList *current = g_list_find_custom(gslider-&gt;colors, (gpointer)&amp;position, _list_find_by_position);</a>
<a name="ln657">  if(current != NULL)</a>
<a name="ln658">  {</a>
<a name="ln659">    memcpy(&amp;((_gradient_slider_stop_t *)current-&gt;data)-&gt;color, &amp;color, sizeof(GdkRGBA));</a>
<a name="ln660">  }</a>
<a name="ln661">  else</a>
<a name="ln662">  {</a>
<a name="ln663">    // stop didn't exist lets add it</a>
<a name="ln664">    _gradient_slider_stop_t *gc = (_gradient_slider_stop_t *)g_malloc(sizeof(_gradient_slider_stop_t));</a>
<a name="ln665">    gc-&gt;position = position;</a>
<a name="ln666">    memcpy(&amp;gc-&gt;color, &amp;color, sizeof(GdkRGBA));</a>
<a name="ln667">    gslider-&gt;colors = g_list_append(gslider-&gt;colors, gc);</a>
<a name="ln668">  }</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">void dtgtk_gradient_slider_multivalue_clear_stops(GtkDarktableGradientSlider *gslider)</a>
<a name="ln672">{</a>
<a name="ln673">  g_list_free_full(gslider-&gt;colors, g_free);</a>
<a name="ln674">  gslider-&gt;colors = NULL;</a>
<a name="ln675">}</a>
<a name="ln676"> </a>
<a name="ln677">GType dtgtk_gradient_slider_multivalue_get_type()</a>
<a name="ln678">{</a>
<a name="ln679">  static GType dtgtk_gradient_slider_type = 0;</a>
<a name="ln680">  if(!dtgtk_gradient_slider_type)</a>
<a name="ln681">  {</a>
<a name="ln682">    static const GTypeInfo dtgtk_gradient_slider_info = {</a>
<a name="ln683">      sizeof(GtkDarktableGradientSliderClass), (GBaseInitFunc)NULL, (GBaseFinalizeFunc)NULL,</a>
<a name="ln684">      (GClassInitFunc)_gradient_slider_class_init, NULL, /* class_finalize */</a>
<a name="ln685">      NULL,                                              /* class_data */</a>
<a name="ln686">      sizeof(GtkDarktableGradientSlider), 0,             /* n_preallocs */</a>
<a name="ln687">      (GInstanceInitFunc)_gradient_slider_init,</a>
<a name="ln688">    };</a>
<a name="ln689">    dtgtk_gradient_slider_type = g_type_register_static(GTK_TYPE_WIDGET, &quot;GtkDarktableGradientSlider&quot;,</a>
<a name="ln690">                                                        &amp;dtgtk_gradient_slider_info, 0);</a>
<a name="ln691">  }</a>
<a name="ln692">  return dtgtk_gradient_slider_type;</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">gdouble dtgtk_gradient_slider_multivalue_get_value(GtkDarktableGradientSlider *gslider, gint pos)</a>
<a name="ln696">{</a>
<a name="ln697">  assert(pos &lt;= gslider-&gt;positions);</a>
<a name="ln698"> </a>
<a name="ln699">  return gslider-&gt;position[pos];</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">void dtgtk_gradient_slider_multivalue_set_value(GtkDarktableGradientSlider *gslider, gdouble value, gint pos)</a>
<a name="ln703">{</a>
<a name="ln704">  assert(pos &lt;= gslider-&gt;positions);</a>
<a name="ln705"> </a>
<a name="ln706">  gslider-&gt;position[pos] = value;</a>
<a name="ln707">  gslider-&gt;selected = gslider-&gt;positions == 1 ? 0 : -1;</a>
<a name="ln708">  g_signal_emit_by_name(G_OBJECT(gslider), &quot;value-changed&quot;);</a>
<a name="ln709">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712">void dtgtk_gradient_slider_multivalue_set_values(GtkDarktableGradientSlider *gslider, gdouble *values)</a>
<a name="ln713">{</a>
<a name="ln714">  for(int k = 0; k &lt; gslider-&gt;positions; k++) gslider-&gt;position[k] = values[k];</a>
<a name="ln715">  gslider-&gt;selected = gslider-&gt;positions == 1 ? 0 : -1;</a>
<a name="ln716">  g_signal_emit_by_name(G_OBJECT(gslider), &quot;value-changed&quot;);</a>
<a name="ln717">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">void dtgtk_gradient_slider_multivalue_set_marker(GtkDarktableGradientSlider *gslider, gint mark, gint pos)</a>
<a name="ln721">{</a>
<a name="ln722">  assert(pos &lt;= gslider-&gt;positions);</a>
<a name="ln723"> </a>
<a name="ln724">  gslider-&gt;marker[pos] = mark;</a>
<a name="ln725">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">void dtgtk_gradient_slider_multivalue_set_markers(GtkDarktableGradientSlider *gslider, gint *markers)</a>
<a name="ln729">{</a>
<a name="ln730">  for(int k = 0; k &lt; gslider-&gt;positions; k++) gslider-&gt;marker[k] = markers[k];</a>
<a name="ln731">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln732">}</a>
<a name="ln733"> </a>
<a name="ln734">void dtgtk_gradient_slider_multivalue_set_resetvalue(GtkDarktableGradientSlider *gslider, gdouble value,</a>
<a name="ln735">                                                     gint pos)</a>
<a name="ln736">{</a>
<a name="ln737">  assert(pos &lt;= gslider-&gt;positions);</a>
<a name="ln738"> </a>
<a name="ln739">  gslider-&gt;resetvalue[pos] = value;</a>
<a name="ln740">  gslider-&gt;is_resettable = TRUE;</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">void dtgtk_gradient_slider_multivalue_set_resetvalues(GtkDarktableGradientSlider *gslider, gdouble *values)</a>
<a name="ln744">{</a>
<a name="ln745">  for(int k = 0; k &lt; gslider-&gt;positions; k++) gslider-&gt;resetvalue[k] = values[k];</a>
<a name="ln746">  gslider-&gt;is_resettable = TRUE;</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">void dtgtk_gradient_slider_multivalue_set_picker(GtkDarktableGradientSlider *gslider, gdouble value)</a>
<a name="ln750">{</a>
<a name="ln751">  gslider-&gt;picker[0] = gslider-&gt;picker[1] = gslider-&gt;picker[2] = value;</a>
<a name="ln752">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">void dtgtk_gradient_slider_multivalue_set_picker_meanminmax(GtkDarktableGradientSlider *gslider, gdouble mean,</a>
<a name="ln756">                                                            gdouble min, gdouble max)</a>
<a name="ln757">{</a>
<a name="ln758">  gslider-&gt;picker[0] = mean;</a>
<a name="ln759">  gslider-&gt;picker[1] = min;</a>
<a name="ln760">  gslider-&gt;picker[2] = max;</a>
<a name="ln761">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764">void dtgtk_gradient_slider_multivalue_set_margins(GtkDarktableGradientSlider *gslider, gint value)</a>
<a name="ln765">{</a>
<a name="ln766">  gslider-&gt;margins = value;</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769"> </a>
<a name="ln770">gboolean dtgtk_gradient_slider_multivalue_is_dragging(GtkDarktableGradientSlider *gslider)</a>
<a name="ln771">{</a>
<a name="ln772">  return gslider-&gt;is_dragging;</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775">void dtgtk_gradient_slider_multivalue_set_increment(GtkDarktableGradientSlider *gslider, gdouble value)</a>
<a name="ln776">{</a>
<a name="ln777">  gslider-&gt;increment = value;</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780">// Public functions for single value type</a>
<a name="ln781">GtkWidget *dtgtk_gradient_slider_new()</a>
<a name="ln782">{</a>
<a name="ln783">  return dtgtk_gradient_slider_multivalue_new(1);</a>
<a name="ln784">}</a>
<a name="ln785"> </a>
<a name="ln786">GtkWidget *dtgtk_gradient_slider_new_with_color(GdkRGBA start, GdkRGBA end)</a>
<a name="ln787">{</a>
<a name="ln788">  return dtgtk_gradient_slider_multivalue_new_with_color(start, end, 1);</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">void dtgtk_gradient_slider_set_stop(GtkDarktableGradientSlider *gslider, gfloat position, GdkRGBA color)</a>
<a name="ln792">{</a>
<a name="ln793">  dtgtk_gradient_slider_multivalue_set_stop(gslider, position, color);</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">GType dtgtk_gradient_slider_get_type()</a>
<a name="ln797">{</a>
<a name="ln798">  return dtgtk_gradient_slider_multivalue_get_type();</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801">gdouble dtgtk_gradient_slider_get_value(GtkDarktableGradientSlider *gslider)</a>
<a name="ln802">{</a>
<a name="ln803">  return dtgtk_gradient_slider_multivalue_get_value(gslider, 0);</a>
<a name="ln804">}</a>
<a name="ln805"> </a>
<a name="ln806">void dtgtk_gradient_slider_multivalue_get_values(GtkDarktableGradientSlider *gslider, gdouble *values)</a>
<a name="ln807">{</a>
<a name="ln808">  for(int k = 0; k &lt; gslider-&gt;positions; k++) values[k] = gslider-&gt;position[k];</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">void dtgtk_gradient_slider_set_value(GtkDarktableGradientSlider *gslider, gdouble value)</a>
<a name="ln812">{</a>
<a name="ln813">  dtgtk_gradient_slider_multivalue_set_value(gslider, value, 0);</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">void dtgtk_gradient_slider_set_marker(GtkDarktableGradientSlider *gslider, gint mark)</a>
<a name="ln817">{</a>
<a name="ln818">  dtgtk_gradient_slider_multivalue_set_marker(gslider, mark, 0);</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">void dtgtk_gradient_slider_set_resetvalue(GtkDarktableGradientSlider *gslider, gdouble value)</a>
<a name="ln822">{</a>
<a name="ln823">  dtgtk_gradient_slider_multivalue_set_resetvalue(gslider, value, 0);</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">void dtgtk_gradient_slider_set_picker(GtkDarktableGradientSlider *gslider, gdouble value)</a>
<a name="ln827">{</a>
<a name="ln828">  gslider-&gt;picker[0] = gslider-&gt;picker[1] = gslider-&gt;picker[2] = value;</a>
<a name="ln829">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">void dtgtk_gradient_slider_set_picker_meanminmax(GtkDarktableGradientSlider *gslider, gdouble mean,</a>
<a name="ln833">                                                 gdouble min, gdouble max)</a>
<a name="ln834">{</a>
<a name="ln835">  gslider-&gt;picker[0] = mean;</a>
<a name="ln836">  gslider-&gt;picker[1] = min;</a>
<a name="ln837">  gslider-&gt;picker[2] = max;</a>
<a name="ln838">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841">void dtgtk_gradient_slider_set_margins(GtkDarktableGradientSlider *gslider, gint value)</a>
<a name="ln842">{</a>
<a name="ln843">  gslider-&gt;margins = value;</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">gboolean dtgtk_gradient_slider_is_dragging(GtkDarktableGradientSlider *gslider)</a>
<a name="ln847">{</a>
<a name="ln848">  return gslider-&gt;is_dragging;</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851">void dtgtk_gradient_slider_set_increment(GtkDarktableGradientSlider *gslider, gdouble value)</a>
<a name="ln852">{</a>
<a name="ln853">  gslider-&gt;increment = value;</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856"> </a>
<a name="ln857">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln858">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln859">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="561"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'sz < 10' is always false.</p></div>
<div class="balloon" rel="565"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'sz < 10' is always false.</p></div>
<div class="balloon" rel="573"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'sz < 10' is always false.</p></div>
<div class="balloon" rel="578"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'sz < 10' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
