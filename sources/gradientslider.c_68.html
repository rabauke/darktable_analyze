
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c)2010--2012 Henrik Andersson.</a>
<a name="ln4">    copyright (c)2012 Ulrich Pegelow.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;assert.h&gt;</a>
<a name="ln21">#include &lt;math.h&gt;</a>
<a name="ln22">#include &lt;stdlib.h&gt;</a>
<a name="ln23">#include &lt;string.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;common/darktable.h&quot;</a>
<a name="ln26">#include &quot;develop/develop.h&quot;</a>
<a name="ln27">#include &quot;gradientslider.h&quot;</a>
<a name="ln28">#include &quot;gui/gtk.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#define CLAMP_RANGE(x, y, z) (CLAMP(x, y, z))</a>
<a name="ln31"> </a>
<a name="ln32">#define DTGTK_GRADIENT_SLIDER_VALUE_CHANGED_DELAY_MAX 50</a>
<a name="ln33">#define DTGTK_GRADIENT_SLIDER_VALUE_CHANGED_DELAY_MIN 10</a>
<a name="ln34">#define DTGTK_GRADIENT_SLIDER_DEFAULT_INCREMENT 0.01</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">static void _gradient_slider_class_init(GtkDarktableGradientSliderClass *klass);</a>
<a name="ln38">static void _gradient_slider_init(GtkDarktableGradientSlider *slider);</a>
<a name="ln39">static void _gradient_slider_realize(GtkWidget *widget);</a>
<a name="ln40">static gboolean _gradient_slider_draw(GtkWidget *widget, cairo_t *cr);</a>
<a name="ln41">static void _gradient_slider_destroy(GtkWidget *widget);</a>
<a name="ln42"> </a>
<a name="ln43">// Events</a>
<a name="ln44">static gboolean _gradient_slider_enter_notify_event(GtkWidget *widget, GdkEventCrossing *event);</a>
<a name="ln45">static gboolean _gradient_slider_button_press(GtkWidget *widget, GdkEventButton *event);</a>
<a name="ln46">static gboolean _gradient_slider_button_release(GtkWidget *widget, GdkEventButton *event);</a>
<a name="ln47">static gboolean _gradient_slider_motion_notify(GtkWidget *widget, GdkEventMotion *event);</a>
<a name="ln48">static gboolean _gradient_slider_scroll_event(GtkWidget *widget, GdkEventScroll *event);</a>
<a name="ln49">static gboolean _gradient_slider_key_press_event(GtkWidget *widget, GdkEventKey *event);</a>
<a name="ln50"> </a>
<a name="ln51">enum</a>
<a name="ln52">{</a>
<a name="ln53">  VALUE_CHANGED,</a>
<a name="ln54">  LAST_SIGNAL</a>
<a name="ln55">};</a>
<a name="ln56"> </a>
<a name="ln57">static guint _signals[LAST_SIGNAL] = { 0 };</a>
<a name="ln58"> </a>
<a name="ln59">static gboolean _gradient_slider_postponed_value_change(gpointer data)</a>
<a name="ln60">{</a>
<a name="ln61">  if(!GTK_IS_WIDGET(data)) return 0;</a>
<a name="ln62"> </a>
<a name="ln63">  if(DTGTK_GRADIENT_SLIDER(data)-&gt;is_changed == TRUE)</a>
<a name="ln64">  {</a>
<a name="ln65">    g_signal_emit_by_name(G_OBJECT(data), &quot;value-changed&quot;);</a>
<a name="ln66">    DTGTK_GRADIENT_SLIDER(data)-&gt;is_changed = FALSE;</a>
<a name="ln67">  }</a>
<a name="ln68"> </a>
<a name="ln69">  if(!DTGTK_GRADIENT_SLIDER(data)-&gt;is_dragging) DTGTK_GRADIENT_SLIDER(data)-&gt;timeout_handle = 0;</a>
<a name="ln70"> </a>
<a name="ln71">  return DTGTK_GRADIENT_SLIDER(data)-&gt;is_dragging; // This is called by the gtk mainloop and is threadsafe</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">static inline gboolean _test_if_marker_is_upper_or_down(const gint marker, const gboolean up)</a>
<a name="ln75">{</a>
<a name="ln76">  if(up &amp;&amp; (marker == GRADIENT_SLIDER_MARKER_LOWER_OPEN ||</a>
<a name="ln77">                  marker == GRADIENT_SLIDER_MARKER_LOWER_FILLED ||</a>
<a name="ln78">                  marker == GRADIENT_SLIDER_MARKER_LOWER_OPEN_BIG ||</a>
<a name="ln79">                  marker == GRADIENT_SLIDER_MARKER_LOWER_FILLED_BIG))</a>
<a name="ln80">    return FALSE;</a>
<a name="ln81">  else if(!up &amp;&amp; (marker == GRADIENT_SLIDER_MARKER_UPPER_OPEN ||</a>
<a name="ln82">                  marker == GRADIENT_SLIDER_MARKER_UPPER_FILLED ||</a>
<a name="ln83">                  marker == GRADIENT_SLIDER_MARKER_UPPER_OPEN_BIG ||</a>
<a name="ln84">                  marker == GRADIENT_SLIDER_MARKER_UPPER_FILLED_BIG))</a>
<a name="ln85">    return FALSE;</a>
<a name="ln86">  else</a>
<a name="ln87">    return TRUE; // must be a DOUBLE</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">static inline gdouble _screen_to_scale(GtkWidget *widget, gint screen)</a>
<a name="ln91">{</a>
<a name="ln92">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln93"> </a>
<a name="ln94">  GtkAllocation allocation;</a>
<a name="ln95">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln96">  return ((gdouble)screen - gslider-&gt;margins) / ((gdouble)allocation.width - 2 * gslider-&gt;margins);</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">static inline gint _scale_to_screen(GtkWidget *widget, gdouble scale)</a>
<a name="ln100">{</a>
<a name="ln101">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln102"> </a>
<a name="ln103">  GtkAllocation allocation;</a>
<a name="ln104">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln105">  return (gint)(scale * (allocation.width - 2 * gslider-&gt;margins) + gslider-&gt;margins);</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">static inline gdouble _get_position_from_screen(GtkWidget *widget, const gdouble x)</a>
<a name="ln109">{</a>
<a name="ln110">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln111">  gdouble position = roundf(_screen_to_scale(widget, x) / gslider-&gt;increment) * gslider-&gt;increment;</a>
<a name="ln112">  return CLAMP_RANGE(position, 0., 1.);</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">static inline gint _get_active_marker(GtkDarktableGradientSlider *gslider)</a>
<a name="ln116">{</a>
<a name="ln117">  return (gslider-&gt;selected &gt;= 0) ? gslider-&gt;selected : gslider-&gt;active;</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">static inline void _clamp_marker(GtkDarktableGradientSlider *gslider, const gint selected)</a>
<a name="ln121">{</a>
<a name="ln122">  const gdouble min = (selected == 0) ? 0.0f : gslider-&gt;position[selected - 1];</a>
<a name="ln123">  const gdouble max = (selected == gslider-&gt;positions - 1) ? 1.0f : gslider-&gt;position[selected + 1];</a>
<a name="ln124">  gslider-&gt;position[selected] = CLAMP(gslider-&gt;position[selected], min, max);</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">static gint _get_active_marker_internal(GtkWidget *widget, const gdouble x, const gboolean up)</a>
<a name="ln128">{</a>
<a name="ln129">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln130">  gint lselected = -1;</a>
<a name="ln131">  const gdouble newposition = _get_position_from_screen(widget, x);</a>
<a name="ln132"> </a>
<a name="ln133">  assert(gslider-&gt;positions &gt; 0);</a>
<a name="ln134"> </a>
<a name="ln135">  for(int k = 0; k &lt; gslider-&gt;positions; k++)</a>
<a name="ln136">  {</a>
<a name="ln137">    if(_test_if_marker_is_upper_or_down(gslider-&gt;marker[k], up))</a>
<a name="ln138">    {</a>
<a name="ln139">      if(lselected &lt; 0) lselected = k;</a>
<a name="ln140">      if(fabs(newposition - gslider-&gt;position[k]) &lt; fabs(newposition - gslider-&gt;position[lselected]))</a>
<a name="ln141">      {</a>
<a name="ln142">        lselected = k;</a>
<a name="ln143">        break;</a>
<a name="ln144">      }</a>
<a name="ln145">    }</a>
<a name="ln146">  }</a>
<a name="ln147"> </a>
<a name="ln148">  return lselected;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">static gint _get_active_marker_from_screen(GtkWidget *widget, const gdouble x, const gdouble y)</a>
<a name="ln152">{</a>
<a name="ln153">  GtkAllocation allocation;</a>
<a name="ln154">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln155"> </a>
<a name="ln156">  gboolean up = (y &lt;= allocation.height / 2.f);</a>
<a name="ln157">  gint lselected = _get_active_marker_internal(widget, x, up);</a>
<a name="ln158">  if(lselected &lt; 0) lselected = _get_active_marker_internal(widget, x, !up);</a>
<a name="ln159"> </a>
<a name="ln160">  assert(lselected &gt;= 0);</a>
<a name="ln161"> </a>
<a name="ln162">  return lselected;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">static gdouble _slider_move(GtkWidget *widget, gint k, gdouble value, gint direction)</a>
<a name="ln166">{</a>
<a name="ln167">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln168"> </a>
<a name="ln169">  gdouble newvalue = value;</a>
<a name="ln170">  const gdouble leftnext = (k == 0) ? 0.0f : gslider-&gt;position[k - 1];</a>
<a name="ln171">  const gdouble rightnext = (k == gslider-&gt;positions - 1) ? 1.0f : gslider-&gt;position[k + 1];</a>
<a name="ln172"> </a>
<a name="ln173">  switch(direction)</a>
<a name="ln174">  {</a>
<a name="ln175">    case MOVE_LEFT:</a>
<a name="ln176">      if(value &lt; leftnext)</a>
<a name="ln177">      {</a>
<a name="ln178">        newvalue = (k == 0) ? fmax(value, 0.0f) : _slider_move(widget, k - 1, value, direction);</a>
<a name="ln179">      }</a>
<a name="ln180">      break;</a>
<a name="ln181">    case MOVE_RIGHT:</a>
<a name="ln182">      if(value &gt; rightnext)</a>
<a name="ln183">      {</a>
<a name="ln184">        newvalue = (k == gslider-&gt;positions - 1) ? fmin(value, 1.0f)</a>
<a name="ln185">                                                 : _slider_move(widget, k + 1, value, direction);</a>
<a name="ln186">      }</a>
<a name="ln187">      break;</a>
<a name="ln188">  }</a>
<a name="ln189"> </a>
<a name="ln190">  gslider-&gt;position[k] = newvalue;</a>
<a name="ln191"> </a>
<a name="ln192">  return newvalue;</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">static gboolean _gradient_slider_add_delta_internal(GtkWidget *widget, gdouble delta, guint state, const gint selected)</a>
<a name="ln196">{</a>
<a name="ln197">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln198"> </a>
<a name="ln199">  if(selected == -1) return TRUE;</a>
<a name="ln200"> </a>
<a name="ln201">  float multiplier;</a>
<a name="ln202"> </a>
<a name="ln203">  GdkModifierType modifiers = gtk_accelerator_get_default_mod_mask();</a>
<a name="ln204">  if((state &amp; modifiers) == GDK_SHIFT_MASK)</a>
<a name="ln205">  {</a>
<a name="ln206">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_rough_step_multiplier&quot;);</a>
<a name="ln207">  }</a>
<a name="ln208">  else if((state &amp; modifiers) == GDK_CONTROL_MASK)</a>
<a name="ln209">  {</a>
<a name="ln210">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_precise_step_multiplier&quot;);</a>
<a name="ln211">  }</a>
<a name="ln212">  else</a>
<a name="ln213">  {</a>
<a name="ln214">    multiplier = dt_conf_get_float(&quot;darkroom/ui/scale_step_multiplier&quot;);</a>
<a name="ln215">  }</a>
<a name="ln216"> </a>
<a name="ln217">  delta *= multiplier;</a>
<a name="ln218"> </a>
<a name="ln219">  gslider-&gt;position[selected] = gslider-&gt;position[selected] + delta;</a>
<a name="ln220">  _clamp_marker(gslider, selected);</a>
<a name="ln221"> </a>
<a name="ln222">  gtk_widget_queue_draw(widget);</a>
<a name="ln223">  g_signal_emit_by_name(G_OBJECT(widget), &quot;value-changed&quot;);</a>
<a name="ln224"> </a>
<a name="ln225">  return TRUE;</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">static gboolean _gradient_slider_enter_notify_event(GtkWidget *widget, GdkEventCrossing *event)</a>
<a name="ln229">{</a>
<a name="ln230">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln231">  gtk_widget_set_state_flags(widget, GTK_STATE_FLAG_PRELIGHT, TRUE);</a>
<a name="ln232">  gslider-&gt;is_entered = TRUE;</a>
<a name="ln233">  gtk_widget_queue_draw(widget);</a>
<a name="ln234">  return FALSE;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">static gboolean _gradient_slider_leave_notify_event(GtkWidget *widget, GdkEventCrossing *event)</a>
<a name="ln238">{</a>
<a name="ln239">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln240">  gtk_widget_set_state_flags(widget, GTK_STATE_FLAG_NORMAL, TRUE);</a>
<a name="ln241">  gslider-&gt;is_entered = FALSE;</a>
<a name="ln242">  gslider-&gt;active = -1;</a>
<a name="ln243">  gtk_widget_queue_draw(widget);</a>
<a name="ln244">  return FALSE;</a>
<a name="ln245">}</a>
<a name="ln246"> </a>
<a name="ln247">static gboolean _gradient_slider_button_press(GtkWidget *widget, GdkEventButton *event)</a>
<a name="ln248">{</a>
<a name="ln249">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln250"> </a>
<a name="ln251">  // reset slider</a>
<a name="ln252">  if(event-&gt;button == 1 &amp;&amp; event-&gt;type == GDK_2BUTTON_PRESS &amp;&amp; gslider-&gt;is_resettable)</a>
<a name="ln253">  {</a>
<a name="ln254">    gslider-&gt;is_dragging = FALSE;</a>
<a name="ln255">    gslider-&gt;do_reset = TRUE;</a>
<a name="ln256">    gslider-&gt;selected = -1;</a>
<a name="ln257">    for(int k = 0; k &lt; gslider-&gt;positions; k++) gslider-&gt;position[k] = gslider-&gt;resetvalue[k];</a>
<a name="ln258">    gtk_widget_queue_draw(widget);</a>
<a name="ln259">    g_signal_emit_by_name(G_OBJECT(widget), &quot;value-changed&quot;);</a>
<a name="ln260">  }</a>
<a name="ln261">  else if((event-&gt;button == 1 || event-&gt;button == 3) &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS)</a>
<a name="ln262">  {</a>
<a name="ln263">    const gint lselected = _get_active_marker_from_screen(widget, event-&gt;x, event-&gt;y);</a>
<a name="ln264"> </a>
<a name="ln265">    assert(lselected &gt;= 0);</a>
<a name="ln266">    assert(lselected &lt;= gslider-&gt;positions - 1);</a>
<a name="ln267"> </a>
<a name="ln268">    if(event-&gt;button == 1) // left mouse button : select and start dragging</a>
<a name="ln269">    {</a>
<a name="ln270">      gslider-&gt;selected = lselected;</a>
<a name="ln271">      gslider-&gt;do_reset = FALSE;</a>
<a name="ln272"> </a>
<a name="ln273">      const gdouble newposition = _get_position_from_screen(widget, event-&gt;x);</a>
<a name="ln274">      const gint direction = gslider-&gt;position[gslider-&gt;selected] &lt;= newposition ? MOVE_RIGHT : MOVE_LEFT;</a>
<a name="ln275"> </a>
<a name="ln276">      _slider_move(widget, gslider-&gt;selected, newposition, direction);</a>
<a name="ln277"> </a>
<a name="ln278">      gslider-&gt;is_changed = TRUE;</a>
<a name="ln279">      gslider-&gt;is_dragging = TRUE;</a>
<a name="ln280">      // timeout_handle should always be zero here, but check just in case</a>
<a name="ln281">      int delay = CLAMP_RANGE(darktable.develop-&gt;average_delay * 3 / 2,</a>
<a name="ln282">                              DTGTK_GRADIENT_SLIDER_VALUE_CHANGED_DELAY_MIN,</a>
<a name="ln283">                              DTGTK_GRADIENT_SLIDER_VALUE_CHANGED_DELAY_MAX);</a>
<a name="ln284">      if(!gslider-&gt;timeout_handle)</a>
<a name="ln285">        gslider-&gt;timeout_handle = g_timeout_add(delay, _gradient_slider_postponed_value_change, widget);</a>
<a name="ln286">    }</a>
<a name="ln287">    else if(gslider-&gt;positions</a>
<a name="ln288">            &gt; 1) // right mouse button: switch on/off selection (only if we have more than one marker)</a>
<a name="ln289">    {</a>
<a name="ln290">      gslider-&gt;is_dragging = FALSE;</a>
<a name="ln291">      gslider-&gt;do_reset = FALSE;</a>
<a name="ln292"> </a>
<a name="ln293">      if(gslider-&gt;selected != lselected)</a>
<a name="ln294">      {</a>
<a name="ln295">        gslider-&gt;selected = lselected;</a>
<a name="ln296">      }</a>
<a name="ln297">      else</a>
<a name="ln298">        gslider-&gt;selected = -1;</a>
<a name="ln299"> </a>
<a name="ln300">      gtk_widget_queue_draw(widget);</a>
<a name="ln301">    }</a>
<a name="ln302">  }</a>
<a name="ln303"> </a>
<a name="ln304">  return TRUE;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">static gboolean _gradient_slider_motion_notify(GtkWidget *widget, GdkEventMotion *event)</a>
<a name="ln308">{</a>
<a name="ln309">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln310"> </a>
<a name="ln311">  if(gslider-&gt;is_dragging == TRUE &amp;&amp; gslider-&gt;selected != -1 &amp;&amp; gslider-&gt;do_reset == FALSE)</a>
<a name="ln312">  {</a>
<a name="ln313">    assert(gslider-&gt;timeout_handle &gt; 0);</a>
<a name="ln314"> </a>
<a name="ln315">    const gdouble newposition = _get_position_from_screen(widget, event-&gt;x);</a>
<a name="ln316">    const gint direction = gslider-&gt;position[gslider-&gt;selected] &lt;= newposition ? MOVE_RIGHT : MOVE_LEFT;</a>
<a name="ln317"> </a>
<a name="ln318">    _slider_move(widget, gslider-&gt;selected, newposition, direction);</a>
<a name="ln319"> </a>
<a name="ln320">    gslider-&gt;is_changed = TRUE;</a>
<a name="ln321"> </a>
<a name="ln322">    gtk_widget_queue_draw(widget);</a>
<a name="ln323">  }</a>
<a name="ln324">  else</a>
<a name="ln325">  {</a>
<a name="ln326">    gslider-&gt;active = _get_active_marker_from_screen(widget, event-&gt;x, event-&gt;y);</a>
<a name="ln327">  }</a>
<a name="ln328"> </a>
<a name="ln329">  if(gslider-&gt;selected != -1) gtk_widget_grab_focus(widget);</a>
<a name="ln330"> </a>
<a name="ln331">  return TRUE;</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">static gboolean _gradient_slider_button_release(GtkWidget *widget, GdkEventButton *event)</a>
<a name="ln335">{</a>
<a name="ln336">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln337">  const gint selected = _get_active_marker(gslider);</a>
<a name="ln338"> </a>
<a name="ln339">  if(event-&gt;button == 1 &amp;&amp; selected != -1 &amp;&amp; gslider-&gt;do_reset == FALSE)</a>
<a name="ln340">  {</a>
<a name="ln341">    // First get some dimension info</a>
<a name="ln342">    gslider-&gt;is_changed = TRUE;</a>
<a name="ln343">    const gdouble newposition = _get_position_from_screen(widget, event-&gt;x);</a>
<a name="ln344">    const gint direction = gslider-&gt;position[selected] &lt;= newposition ? MOVE_RIGHT : MOVE_LEFT;</a>
<a name="ln345"> </a>
<a name="ln346">    _slider_move(widget, selected, newposition, direction);</a>
<a name="ln347"> </a>
<a name="ln348">    gtk_widget_queue_draw(widget);</a>
<a name="ln349"> </a>
<a name="ln350">    gslider-&gt;is_dragging = FALSE;</a>
<a name="ln351">    if(gslider-&gt;timeout_handle) g_source_remove(gslider-&gt;timeout_handle);</a>
<a name="ln352">    gslider-&gt;timeout_handle = 0;</a>
<a name="ln353">    g_signal_emit_by_name(G_OBJECT(widget), &quot;value-changed&quot;);</a>
<a name="ln354">  }</a>
<a name="ln355">  return TRUE;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">static gboolean _gradient_slider_scroll_event(GtkWidget *widget, GdkEventScroll *event)</a>
<a name="ln359">{</a>
<a name="ln360">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln361">  const gint selected = _get_active_marker(gslider);</a>
<a name="ln362">  if(selected == -1) return TRUE;</a>
<a name="ln363"> </a>
<a name="ln364">  gtk_widget_grab_focus(widget);</a>
<a name="ln365"> </a>
<a name="ln366">  gdouble delta_y;</a>
<a name="ln367">  if(dt_gui_get_scroll_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln368">  {</a>
<a name="ln369">    delta_y *= -gslider-&gt;increment;</a>
<a name="ln370">    return _gradient_slider_add_delta_internal(widget, delta_y, event-&gt;state, selected);</a>
<a name="ln371">  }</a>
<a name="ln372"> </a>
<a name="ln373">  return TRUE;</a>
<a name="ln374">}</a>
<a name="ln375"> </a>
<a name="ln376">static gboolean _gradient_slider_key_press_event(GtkWidget *widget, GdkEventKey *event)</a>
<a name="ln377">{</a>
<a name="ln378">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln379"> </a>
<a name="ln380">  const gint selected = _get_active_marker(gslider);</a>
<a name="ln381">  if(selected == -1) return TRUE;</a>
<a name="ln382"> </a>
<a name="ln383">  int handled = 0;</a>
<a name="ln384">  float delta = 0.0f;</a>
<a name="ln385"> </a>
<a name="ln386">  if(event-&gt;keyval == GDK_KEY_Up || event-&gt;keyval == GDK_KEY_KP_Up || event-&gt;keyval == GDK_KEY_Right</a>
<a name="ln387">     || event-&gt;keyval == GDK_KEY_KP_Right)</a>
<a name="ln388">  {</a>
<a name="ln389">    handled = 1;</a>
<a name="ln390">    delta = gslider-&gt;increment;</a>
<a name="ln391">  }</a>
<a name="ln392">  else if(event-&gt;keyval == GDK_KEY_Down || event-&gt;keyval == GDK_KEY_KP_Down || event-&gt;keyval == GDK_KEY_Left</a>
<a name="ln393">          || event-&gt;keyval == GDK_KEY_KP_Left)</a>
<a name="ln394">  {</a>
<a name="ln395">    handled = 1;</a>
<a name="ln396">    delta = -gslider-&gt;increment;</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  if(!handled) return TRUE;</a>
<a name="ln400"> </a>
<a name="ln401">  return _gradient_slider_add_delta_internal(widget, delta, event-&gt;state, selected);</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">static void _gradient_slider_class_init(GtkDarktableGradientSliderClass *klass)</a>
<a name="ln405">{</a>
<a name="ln406">  GtkWidgetClass *widget_class = (GtkWidgetClass *)klass;</a>
<a name="ln407"> </a>
<a name="ln408">  widget_class-&gt;realize = _gradient_slider_realize;</a>
<a name="ln409">  widget_class-&gt;draw = _gradient_slider_draw;</a>
<a name="ln410">  widget_class-&gt;destroy = _gradient_slider_destroy;</a>
<a name="ln411"> </a>
<a name="ln412">  widget_class-&gt;enter_notify_event = _gradient_slider_enter_notify_event;</a>
<a name="ln413">  widget_class-&gt;leave_notify_event = _gradient_slider_leave_notify_event;</a>
<a name="ln414">  widget_class-&gt;button_press_event = _gradient_slider_button_press;</a>
<a name="ln415">  widget_class-&gt;button_release_event = _gradient_slider_button_release;</a>
<a name="ln416">  widget_class-&gt;motion_notify_event = _gradient_slider_motion_notify;</a>
<a name="ln417">  widget_class-&gt;scroll_event = _gradient_slider_scroll_event;</a>
<a name="ln418">  widget_class-&gt;key_press_event = _gradient_slider_key_press_event;</a>
<a name="ln419"> </a>
<a name="ln420">  _signals[VALUE_CHANGED] = g_signal_new(&quot;value-changed&quot;, G_TYPE_FROM_CLASS(klass), G_SIGNAL_RUN_LAST, 0,</a>
<a name="ln421">                                         NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">static void _gradient_slider_init(GtkDarktableGradientSlider *slider)</a>
<a name="ln425">{</a>
<a name="ln426">  slider-&gt;is_dragging = slider-&gt;is_changed = slider-&gt;do_reset = slider-&gt;is_entered = 0;</a>
<a name="ln427">  slider-&gt;timeout_handle = 0;</a>
<a name="ln428">  slider-&gt;selected = slider-&gt;positions == 1 ? 0 : -1;</a>
<a name="ln429">  slider-&gt;active = -1;</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432">static void _gradient_slider_realize(GtkWidget *widget)</a>
<a name="ln433">{</a>
<a name="ln434">  GdkWindowAttr attributes;</a>
<a name="ln435">  guint attributes_mask;</a>
<a name="ln436"> </a>
<a name="ln437">  g_return_if_fail(widget != NULL);</a>
<a name="ln438">  g_return_if_fail(DTGTK_IS_GRADIENT_SLIDER(widget));</a>
<a name="ln439"> </a>
<a name="ln440">  gtk_widget_set_realized(widget, TRUE);</a>
<a name="ln441"> </a>
<a name="ln442">  GtkAllocation allocation;</a>
<a name="ln443">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln444">  attributes.window_type = GDK_WINDOW_CHILD;</a>
<a name="ln445">  attributes.x = allocation.x;</a>
<a name="ln446">  attributes.y = allocation.y;</a>
<a name="ln447">  attributes.width = DT_PIXEL_APPLY_DPI(100);</a>
<a name="ln448">  attributes.height = DT_PIXEL_APPLY_DPI(17);</a>
<a name="ln449"> </a>
<a name="ln450">  attributes.wclass = GDK_INPUT_OUTPUT;</a>
<a name="ln451">  attributes.event_mask = gtk_widget_get_events(widget) | GDK_EXPOSURE_MASK | GDK_BUTTON_PRESS_MASK</a>
<a name="ln452">                          | GDK_BUTTON_RELEASE_MASK | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK</a>
<a name="ln453">                          | GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK | GDK_POINTER_MOTION_MASK</a>
<a name="ln454">                          | darktable.gui-&gt;scroll_mask;</a>
<a name="ln455">  attributes_mask = GDK_WA_X | GDK_WA_Y;</a>
<a name="ln456"> </a>
<a name="ln457">  gtk_widget_set_can_focus(GTK_WIDGET(widget), TRUE);</a>
<a name="ln458"> </a>
<a name="ln459">  gtk_widget_set_window(widget,</a>
<a name="ln460">                        gdk_window_new(gtk_widget_get_parent_window(widget), &amp;attributes, attributes_mask));</a>
<a name="ln461"> </a>
<a name="ln462">  gdk_window_set_user_data(gtk_widget_get_window(widget), widget);</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465"> </a>
<a name="ln466">static void _gradient_slider_destroy(GtkWidget *widget)</a>
<a name="ln467">{</a>
<a name="ln468">  GtkDarktableGradientSliderClass *klass;</a>
<a name="ln469">  g_return_if_fail(widget != NULL);</a>
<a name="ln470">  g_return_if_fail(DTGTK_IS_GRADIENT_SLIDER(widget));</a>
<a name="ln471"> </a>
<a name="ln472">  if(DTGTK_GRADIENT_SLIDER(widget)-&gt;timeout_handle)</a>
<a name="ln473">    g_source_remove(DTGTK_GRADIENT_SLIDER(widget)-&gt;timeout_handle);</a>
<a name="ln474">  DTGTK_GRADIENT_SLIDER(widget)-&gt;timeout_handle = 0;</a>
<a name="ln475"> </a>
<a name="ln476">  if(DTGTK_GRADIENT_SLIDER(widget)-&gt;colors)</a>
<a name="ln477">  {</a>
<a name="ln478">    g_list_free_full(DTGTK_GRADIENT_SLIDER(widget)-&gt;colors, g_free);</a>
<a name="ln479">    DTGTK_GRADIENT_SLIDER(widget)-&gt;colors = NULL;</a>
<a name="ln480">  }</a>
<a name="ln481"> </a>
<a name="ln482">  // FIXME: or it should be g_type_class_ref () ?</a>
<a name="ln483">  klass = g_type_class_peek(gtk_widget_get_type());</a>
<a name="ln484">  if(GTK_WIDGET_CLASS(klass)-&gt;destroy)</a>
<a name="ln485">  {</a>
<a name="ln486">    (*GTK_WIDGET_CLASS(klass)-&gt;destroy)(widget);</a>
<a name="ln487">  }</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490">static gboolean _gradient_slider_draw(GtkWidget *widget, cairo_t *cr)</a>
<a name="ln491">{</a>
<a name="ln492">  GtkDarktableGradientSlider *gslider = DTGTK_GRADIENT_SLIDER(widget);</a>
<a name="ln493"> </a>
<a name="ln494">  assert(gslider-&gt;position &gt; 0);</a>
<a name="ln495"> </a>
<a name="ln496">  g_return_val_if_fail(widget != NULL, FALSE);</a>
<a name="ln497">  g_return_val_if_fail(DTGTK_IS_GRADIENT_SLIDER(widget), FALSE);</a>
<a name="ln498"> </a>
<a name="ln499">  GdkRGBA color;</a>
<a name="ln500">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln501">  gtk_style_context_get_color(context, gtk_widget_get_state_flags(widget), &amp;color);</a>
<a name="ln502"> </a>
<a name="ln503">  GtkAllocation allocation;</a>
<a name="ln504">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln505">  int width = allocation.width;</a>
<a name="ln506">  int height = allocation.height;</a>
<a name="ln507">  int margins = gslider-&gt;margins;</a>
<a name="ln508"> </a>
<a name="ln509">  // Begin cairo drawing</a>
<a name="ln510">  // First build the cairo gradient and then fill the gradient</a>
<a name="ln511">  float gheight = height / 2.0;</a>
<a name="ln512">  float gwidth = width - 2 * margins;</a>
<a name="ln513">  GList *current = NULL;</a>
<a name="ln514">  cairo_pattern_t *gradient = NULL;</a>
<a name="ln515">  if((current = g_list_first(gslider-&gt;colors)) != NULL)</a>
<a name="ln516">  {</a>
<a name="ln517">    gradient = cairo_pattern_create_linear(0, 0, gwidth, gheight);</a>
<a name="ln518">    do</a>
<a name="ln519">    {</a>
<a name="ln520">      _gradient_slider_stop_t *stop = (_gradient_slider_stop_t *)current-&gt;data;</a>
<a name="ln521">      cairo_pattern_add_color_stop_rgb(gradient, stop-&gt;position, stop-&gt;color.red, stop-&gt;color.green,</a>
<a name="ln522">                                       stop-&gt;color.blue);</a>
<a name="ln523">    } while((current = g_list_next(current)) != NULL);</a>
<a name="ln524">  }</a>
<a name="ln525"> </a>
<a name="ln526">  if(gradient != NULL) // Do we got a gradient, lets draw it</a>
<a name="ln527">  {</a>
<a name="ln528">    cairo_set_line_width(cr, 0.1);</a>
<a name="ln529">    cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln530">    cairo_set_source(cr, gradient);</a>
<a name="ln531">    cairo_rectangle(cr, margins, (height - gheight) / 2.0, gwidth, gheight);</a>
<a name="ln532">    cairo_fill(cr);</a>
<a name="ln533">    cairo_stroke(cr);</a>
<a name="ln534">    cairo_pattern_destroy(gradient);</a>
<a name="ln535">  }</a>
<a name="ln536"> </a>
<a name="ln537">  // Lets draw position arrows</a>
<a name="ln538"> </a>
<a name="ln539">  cairo_set_source_rgba(cr, color.red, color.green, color.blue, 1.0);</a>
<a name="ln540"> </a>
<a name="ln541"> </a>
<a name="ln542">  // do we have a picker value to draw?</a>
<a name="ln543">  if(!isnan(gslider-&gt;picker[0]))</a>
<a name="ln544">  {</a>
<a name="ln545">    int vx_min = _scale_to_screen(widget, CLAMP_RANGE(gslider-&gt;picker[1], 0.0, 1.0));</a>
<a name="ln546">    int vx_max = _scale_to_screen(widget, CLAMP_RANGE(gslider-&gt;picker[2], 0.0, 1.0));</a>
<a name="ln547">    int vx_avg = _scale_to_screen(widget, CLAMP_RANGE(gslider-&gt;picker[0], 0.0, 1.0));</a>
<a name="ln548"> </a>
<a name="ln549">    cairo_set_source_rgba(cr, color.red, color.green, color.blue, 0.33);</a>
<a name="ln550"> </a>
<a name="ln551">    cairo_rectangle(cr, vx_min, (height - gheight) / 2.0, fmax((float)vx_max - vx_min, 0.0f), gheight);</a>
<a name="ln552">    cairo_fill(cr);</a>
<a name="ln553"> </a>
<a name="ln554">    cairo_set_source_rgba(cr, color.red, color.green, color.blue, 1.0);</a>
<a name="ln555"> </a>
<a name="ln556">    cairo_move_to(cr, vx_avg, (height - gheight) / 2.0);</a>
<a name="ln557">    cairo_line_to(cr, vx_avg, (height + gheight) / 2.0);</a>
<a name="ln558">    cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE);</a>
<a name="ln559">    cairo_set_line_width(cr, 1.0);</a>
<a name="ln560">    cairo_stroke(cr);</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">  int indirect[GRADIENT_SLIDER_MAX_POSITIONS];</a>
<a name="ln564">  const gint selected = _get_active_marker(gslider);</a>
<a name="ln565">  for(int k = 0; k &lt; gslider-&gt;positions; k++)</a>
<a name="ln566">    indirect[k] = (selected == -1) ? k : (selected + 1 + k) % gslider-&gt;positions;</a>
<a name="ln567"> </a>
<a name="ln568"> </a>
<a name="ln569">  for(int k = 0; k &lt; gslider-&gt;positions; k++)</a>
<a name="ln570">  {</a>
<a name="ln571">    const int l = indirect[k];</a>
<a name="ln572">    const int vx = _scale_to_screen(widget, gslider-&gt;position[l]);</a>
<a name="ln573">    const int mk = gslider-&gt;marker[l];</a>
<a name="ln574">    const int sz = (mk &amp; (1 &lt;&lt; 3)) ? 13 : 10; // big or small marker?</a>
<a name="ln575"> </a>
<a name="ln576">    // FIXME: enable this when enter/leave event is working again</a>
<a name="ln577">    if(l == selected /*&amp;&amp; (gslider-&gt;is_entered == TRUE || gslider-&gt;is_dragging == TRUE)*/)</a>
<a name="ln578">    {</a>
<a name="ln579">      cairo_set_source_rgba(cr, color.red, color.green, color.blue, 1.0);</a>
<a name="ln580">    }</a>
<a name="ln581">    else</a>
<a name="ln582">    {</a>
<a name="ln583">      cairo_set_source_rgba(cr, color.red * 0.8, color.green * 0.8, color.blue * 0.8, 1.0);</a>
<a name="ln584">    }</a>
<a name="ln585"> </a>
<a name="ln586"> </a>
<a name="ln587">    cairo_set_antialias(cr, CAIRO_ANTIALIAS_DEFAULT);</a>
<a name="ln588"> </a>
<a name="ln589">    if(mk &amp; 0x04) /* upper arrow */</a>
<a name="ln590">    {</a>
<a name="ln591">      if(mk &amp; 0x01) /* filled */</a>
<a name="ln592">        dtgtk_cairo_paint_solid_triangle(cr, (vx - DT_PIXEL_APPLY_DPI(sz) * 0.5),</a>
<a name="ln593">                                         sz &lt; 10 ? DT_PIXEL_APPLY_DPI(1) : DT_PIXEL_APPLY_DPI(-2),</a>
<a name="ln594">                                         DT_PIXEL_APPLY_DPI(sz), DT_PIXEL_APPLY_DPI(sz), CPF_DIRECTION_DOWN, NULL);</a>
<a name="ln595">      else</a>
<a name="ln596">        dtgtk_cairo_paint_triangle(cr, (vx - DT_PIXEL_APPLY_DPI(sz) * 0.5),</a>
<a name="ln597">                                   sz &lt; 10 ? DT_PIXEL_APPLY_DPI(1) : DT_PIXEL_APPLY_DPI(-2),</a>
<a name="ln598">                                   DT_PIXEL_APPLY_DPI(sz), DT_PIXEL_APPLY_DPI(sz), CPF_DIRECTION_DOWN, NULL);</a>
<a name="ln599">    }</a>
<a name="ln600"> </a>
<a name="ln601">    if(mk &amp; 0x02) /* lower arrow */</a>
<a name="ln602">    {</a>
<a name="ln603">      if(mk &amp; 0x01) /* filled */</a>
<a name="ln604">        dtgtk_cairo_paint_solid_triangle(cr, (vx - DT_PIXEL_APPLY_DPI(sz) * 0.5),</a>
<a name="ln605">                                         sz &lt; 10 ? height - DT_PIXEL_APPLY_DPI(6) : height</a>
<a name="ln606">                                                                                    - DT_PIXEL_APPLY_DPI(11),</a>
<a name="ln607">                                         DT_PIXEL_APPLY_DPI(sz), DT_PIXEL_APPLY_DPI(sz), CPF_DIRECTION_UP, NULL);</a>
<a name="ln608">      else</a>
<a name="ln609">        dtgtk_cairo_paint_triangle(cr, (vx - DT_PIXEL_APPLY_DPI(sz) * 0.5),</a>
<a name="ln610">                                   sz &lt; 10 ? height - DT_PIXEL_APPLY_DPI(6) : height - DT_PIXEL_APPLY_DPI(11),</a>
<a name="ln611">                                   DT_PIXEL_APPLY_DPI(sz), DT_PIXEL_APPLY_DPI(sz), CPF_DIRECTION_UP, NULL);</a>
<a name="ln612">    }</a>
<a name="ln613">  }</a>
<a name="ln614"> </a>
<a name="ln615">  return FALSE;</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">// Public functions for multivalue type</a>
<a name="ln619">GtkWidget *dtgtk_gradient_slider_multivalue_new(gint positions)</a>
<a name="ln620">{</a>
<a name="ln621">  assert(positions &lt;= GRADIENT_SLIDER_MAX_POSITIONS);</a>
<a name="ln622"> </a>
<a name="ln623">  GtkDarktableGradientSlider *gslider;</a>
<a name="ln624">  gslider = g_object_new(dtgtk_gradient_slider_get_type(), NULL);</a>
<a name="ln625">  gslider-&gt;positions = positions;</a>
<a name="ln626">  gslider-&gt;is_resettable = FALSE;</a>
<a name="ln627">  gslider-&gt;is_entered = FALSE;</a>
<a name="ln628">  gslider-&gt;picker[0] = gslider-&gt;picker[1] = gslider-&gt;picker[2] = NAN;</a>
<a name="ln629">  gslider-&gt;selected = positions == 1 ? 0 : -1;</a>
<a name="ln630">  gslider-&gt;active = -1;</a>
<a name="ln631">  gslider-&gt;increment = DTGTK_GRADIENT_SLIDER_DEFAULT_INCREMENT;</a>
<a name="ln632">  gslider-&gt;margins = GRADIENT_SLIDER_MARGINS_DEFAULT;</a>
<a name="ln633">  for(int k = 0; k &lt; positions; k++) gslider-&gt;position[k] = 0.0;</a>
<a name="ln634">  for(int k = 0; k &lt; positions; k++) gslider-&gt;resetvalue[k] = 0.0;</a>
<a name="ln635">  for(int k = 0; k &lt; positions; k++) gslider-&gt;marker[k] = GRADIENT_SLIDER_MARKER_LOWER_FILLED;</a>
<a name="ln636">  return (GtkWidget *)gslider;</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639"> </a>
<a name="ln640">GtkWidget *dtgtk_gradient_slider_multivalue_new_with_color(GdkRGBA start, GdkRGBA end, gint positions)</a>
<a name="ln641">{</a>
<a name="ln642">  assert(positions &lt;= GRADIENT_SLIDER_MAX_POSITIONS);</a>
<a name="ln643"> </a>
<a name="ln644">  GtkDarktableGradientSlider *gslider;</a>
<a name="ln645">  gslider = g_object_new(dtgtk_gradient_slider_get_type(), NULL);</a>
<a name="ln646">  gslider-&gt;positions = positions;</a>
<a name="ln647">  gslider-&gt;is_resettable = FALSE;</a>
<a name="ln648">  gslider-&gt;is_entered = FALSE;</a>
<a name="ln649">  gslider-&gt;picker[0] = gslider-&gt;picker[1] = gslider-&gt;picker[2] = NAN;</a>
<a name="ln650">  gslider-&gt;selected = positions == 1 ? 0 : -1;</a>
<a name="ln651">  gslider-&gt;active = -1;</a>
<a name="ln652">  gslider-&gt;increment = DTGTK_GRADIENT_SLIDER_DEFAULT_INCREMENT;</a>
<a name="ln653">  gslider-&gt;margins = GRADIENT_SLIDER_MARGINS_DEFAULT;</a>
<a name="ln654">  for(int k = 0; k &lt; positions; k++) gslider-&gt;position[k] = 0.0;</a>
<a name="ln655">  for(int k = 0; k &lt; positions; k++) gslider-&gt;resetvalue[k] = 0.0;</a>
<a name="ln656">  for(int k = 0; k &lt; positions; k++) gslider-&gt;marker[k] = GRADIENT_SLIDER_MARKER_LOWER_FILLED;</a>
<a name="ln657"> </a>
<a name="ln658">  // Construct gradient start color</a>
<a name="ln659">  _gradient_slider_stop_t *gc = (_gradient_slider_stop_t *)g_malloc(sizeof(_gradient_slider_stop_t));</a>
<a name="ln660">  gc-&gt;position = 0.0;</a>
<a name="ln661">  memcpy(&amp;gc-&gt;color, &amp;start, sizeof(GdkRGBA));</a>
<a name="ln662">  gslider-&gt;colors = g_list_append(gslider-&gt;colors, gc);</a>
<a name="ln663"> </a>
<a name="ln664">  // Construct gradient stop color</a>
<a name="ln665">  gc = (_gradient_slider_stop_t *)g_malloc(sizeof(_gradient_slider_stop_t));</a>
<a name="ln666">  gc-&gt;position = 1.0;</a>
<a name="ln667">  memcpy(&amp;gc-&gt;color, &amp;end, sizeof(GdkRGBA));</a>
<a name="ln668">  gslider-&gt;colors = g_list_append(gslider-&gt;colors, gc);</a>
<a name="ln669"> </a>
<a name="ln670"> </a>
<a name="ln671">  return (GtkWidget *)gslider;</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674"> </a>
<a name="ln675">gint _list_find_by_position(gconstpointer a, gconstpointer b)</a>
<a name="ln676">{</a>
<a name="ln677">  _gradient_slider_stop_t *stop = (_gradient_slider_stop_t *)a;</a>
<a name="ln678">  gfloat position = *((gfloat *)b);</a>
<a name="ln679">  return (gint)((stop-&gt;position * 100.0) - (position * 100.0));</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">void dtgtk_gradient_slider_multivalue_set_stop(GtkDarktableGradientSlider *gslider, gfloat position,</a>
<a name="ln683">                                               GdkRGBA color)</a>
<a name="ln684">{</a>
<a name="ln685">  // First find color at position, if exists update color, otherwise create a new stop at position.</a>
<a name="ln686">  GList *current = g_list_find_custom(gslider-&gt;colors, (gpointer)&amp;position, _list_find_by_position);</a>
<a name="ln687">  if(current != NULL)</a>
<a name="ln688">  {</a>
<a name="ln689">    memcpy(&amp;((_gradient_slider_stop_t *)current-&gt;data)-&gt;color, &amp;color, sizeof(GdkRGBA));</a>
<a name="ln690">  }</a>
<a name="ln691">  else</a>
<a name="ln692">  {</a>
<a name="ln693">    // stop didn't exist lets add it</a>
<a name="ln694">    _gradient_slider_stop_t *gc = (_gradient_slider_stop_t *)g_malloc(sizeof(_gradient_slider_stop_t));</a>
<a name="ln695">    gc-&gt;position = position;</a>
<a name="ln696">    memcpy(&amp;gc-&gt;color, &amp;color, sizeof(GdkRGBA));</a>
<a name="ln697">    gslider-&gt;colors = g_list_append(gslider-&gt;colors, gc);</a>
<a name="ln698">  }</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">void dtgtk_gradient_slider_multivalue_clear_stops(GtkDarktableGradientSlider *gslider)</a>
<a name="ln702">{</a>
<a name="ln703">  g_list_free_full(gslider-&gt;colors, g_free);</a>
<a name="ln704">  gslider-&gt;colors = NULL;</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707">GType dtgtk_gradient_slider_multivalue_get_type()</a>
<a name="ln708">{</a>
<a name="ln709">  static GType dtgtk_gradient_slider_type = 0;</a>
<a name="ln710">  if(!dtgtk_gradient_slider_type)</a>
<a name="ln711">  {</a>
<a name="ln712">    static const GTypeInfo dtgtk_gradient_slider_info = {</a>
<a name="ln713">      sizeof(GtkDarktableGradientSliderClass), (GBaseInitFunc)NULL, (GBaseFinalizeFunc)NULL,</a>
<a name="ln714">      (GClassInitFunc)_gradient_slider_class_init, NULL, /* class_finalize */</a>
<a name="ln715">      NULL,                                              /* class_data */</a>
<a name="ln716">      sizeof(GtkDarktableGradientSlider), 0,             /* n_preallocs */</a>
<a name="ln717">      (GInstanceInitFunc)_gradient_slider_init,</a>
<a name="ln718">    };</a>
<a name="ln719">    dtgtk_gradient_slider_type = g_type_register_static(GTK_TYPE_WIDGET, &quot;GtkDarktableGradientSlider&quot;,</a>
<a name="ln720">                                                        &amp;dtgtk_gradient_slider_info, 0);</a>
<a name="ln721">  }</a>
<a name="ln722">  return dtgtk_gradient_slider_type;</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725">gdouble dtgtk_gradient_slider_multivalue_get_value(GtkDarktableGradientSlider *gslider, gint pos)</a>
<a name="ln726">{</a>
<a name="ln727">  assert(pos &lt;= gslider-&gt;positions);</a>
<a name="ln728"> </a>
<a name="ln729">  return gslider-&gt;position[pos];</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">void dtgtk_gradient_slider_multivalue_set_value(GtkDarktableGradientSlider *gslider, gdouble value, gint pos)</a>
<a name="ln733">{</a>
<a name="ln734">  assert(pos &lt;= gslider-&gt;positions);</a>
<a name="ln735"> </a>
<a name="ln736">  gslider-&gt;position[pos] = value;</a>
<a name="ln737">  gslider-&gt;selected = gslider-&gt;positions == 1 ? 0 : -1;</a>
<a name="ln738">  g_signal_emit_by_name(G_OBJECT(gslider), &quot;value-changed&quot;);</a>
<a name="ln739">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">void dtgtk_gradient_slider_multivalue_set_values(GtkDarktableGradientSlider *gslider, gdouble *values)</a>
<a name="ln743">{</a>
<a name="ln744">  for(int k = 0; k &lt; gslider-&gt;positions; k++) gslider-&gt;position[k] = values[k];</a>
<a name="ln745">  gslider-&gt;selected = gslider-&gt;positions == 1 ? 0 : -1;</a>
<a name="ln746">  g_signal_emit_by_name(G_OBJECT(gslider), &quot;value-changed&quot;);</a>
<a name="ln747">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">void dtgtk_gradient_slider_multivalue_set_marker(GtkDarktableGradientSlider *gslider, gint mark, gint pos)</a>
<a name="ln751">{</a>
<a name="ln752">  assert(pos &lt;= gslider-&gt;positions);</a>
<a name="ln753"> </a>
<a name="ln754">  gslider-&gt;marker[pos] = mark;</a>
<a name="ln755">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758">void dtgtk_gradient_slider_multivalue_set_markers(GtkDarktableGradientSlider *gslider, gint *markers)</a>
<a name="ln759">{</a>
<a name="ln760">  for(int k = 0; k &lt; gslider-&gt;positions; k++) gslider-&gt;marker[k] = markers[k];</a>
<a name="ln761">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764">void dtgtk_gradient_slider_multivalue_set_resetvalue(GtkDarktableGradientSlider *gslider, gdouble value,</a>
<a name="ln765">                                                     gint pos)</a>
<a name="ln766">{</a>
<a name="ln767">  assert(pos &lt;= gslider-&gt;positions);</a>
<a name="ln768"> </a>
<a name="ln769">  gslider-&gt;resetvalue[pos] = value;</a>
<a name="ln770">  gslider-&gt;is_resettable = TRUE;</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">void dtgtk_gradient_slider_multivalue_set_resetvalues(GtkDarktableGradientSlider *gslider, gdouble *values)</a>
<a name="ln774">{</a>
<a name="ln775">  for(int k = 0; k &lt; gslider-&gt;positions; k++) gslider-&gt;resetvalue[k] = values[k];</a>
<a name="ln776">  gslider-&gt;is_resettable = TRUE;</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779">void dtgtk_gradient_slider_multivalue_set_picker(GtkDarktableGradientSlider *gslider, gdouble value)</a>
<a name="ln780">{</a>
<a name="ln781">  gslider-&gt;picker[0] = gslider-&gt;picker[1] = gslider-&gt;picker[2] = value;</a>
<a name="ln782">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785">void dtgtk_gradient_slider_multivalue_set_picker_meanminmax(GtkDarktableGradientSlider *gslider, gdouble mean,</a>
<a name="ln786">                                                            gdouble min, gdouble max)</a>
<a name="ln787">{</a>
<a name="ln788">  gslider-&gt;picker[0] = mean;</a>
<a name="ln789">  gslider-&gt;picker[1] = min;</a>
<a name="ln790">  gslider-&gt;picker[2] = max;</a>
<a name="ln791">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">void dtgtk_gradient_slider_multivalue_set_margins(GtkDarktableGradientSlider *gslider, gint value)</a>
<a name="ln795">{</a>
<a name="ln796">  gslider-&gt;margins = value;</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799"> </a>
<a name="ln800">gboolean dtgtk_gradient_slider_multivalue_is_dragging(GtkDarktableGradientSlider *gslider)</a>
<a name="ln801">{</a>
<a name="ln802">  return gslider-&gt;is_dragging;</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">void dtgtk_gradient_slider_multivalue_set_increment(GtkDarktableGradientSlider *gslider, gdouble value)</a>
<a name="ln806">{</a>
<a name="ln807">  gslider-&gt;increment = value;</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810">// Public functions for single value type</a>
<a name="ln811">GtkWidget *dtgtk_gradient_slider_new()</a>
<a name="ln812">{</a>
<a name="ln813">  return dtgtk_gradient_slider_multivalue_new(1);</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">GtkWidget *dtgtk_gradient_slider_new_with_color(GdkRGBA start, GdkRGBA end)</a>
<a name="ln817">{</a>
<a name="ln818">  return dtgtk_gradient_slider_multivalue_new_with_color(start, end, 1);</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">void dtgtk_gradient_slider_set_stop(GtkDarktableGradientSlider *gslider, gfloat position, GdkRGBA color)</a>
<a name="ln822">{</a>
<a name="ln823">  dtgtk_gradient_slider_multivalue_set_stop(gslider, position, color);</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">GType dtgtk_gradient_slider_get_type()</a>
<a name="ln827">{</a>
<a name="ln828">  return dtgtk_gradient_slider_multivalue_get_type();</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831">gdouble dtgtk_gradient_slider_get_value(GtkDarktableGradientSlider *gslider)</a>
<a name="ln832">{</a>
<a name="ln833">  return dtgtk_gradient_slider_multivalue_get_value(gslider, 0);</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836">void dtgtk_gradient_slider_multivalue_get_values(GtkDarktableGradientSlider *gslider, gdouble *values)</a>
<a name="ln837">{</a>
<a name="ln838">  for(int k = 0; k &lt; gslider-&gt;positions; k++) values[k] = gslider-&gt;position[k];</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841">void dtgtk_gradient_slider_set_value(GtkDarktableGradientSlider *gslider, gdouble value)</a>
<a name="ln842">{</a>
<a name="ln843">  dtgtk_gradient_slider_multivalue_set_value(gslider, value, 0);</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">void dtgtk_gradient_slider_set_marker(GtkDarktableGradientSlider *gslider, gint mark)</a>
<a name="ln847">{</a>
<a name="ln848">  dtgtk_gradient_slider_multivalue_set_marker(gslider, mark, 0);</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851">void dtgtk_gradient_slider_set_resetvalue(GtkDarktableGradientSlider *gslider, gdouble value)</a>
<a name="ln852">{</a>
<a name="ln853">  dtgtk_gradient_slider_multivalue_set_resetvalue(gslider, value, 0);</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">void dtgtk_gradient_slider_set_picker(GtkDarktableGradientSlider *gslider, gdouble value)</a>
<a name="ln857">{</a>
<a name="ln858">  gslider-&gt;picker[0] = gslider-&gt;picker[1] = gslider-&gt;picker[2] = value;</a>
<a name="ln859">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">void dtgtk_gradient_slider_set_picker_meanminmax(GtkDarktableGradientSlider *gslider, gdouble mean,</a>
<a name="ln863">                                                 gdouble min, gdouble max)</a>
<a name="ln864">{</a>
<a name="ln865">  gslider-&gt;picker[0] = mean;</a>
<a name="ln866">  gslider-&gt;picker[1] = min;</a>
<a name="ln867">  gslider-&gt;picker[2] = max;</a>
<a name="ln868">  gtk_widget_queue_draw(GTK_WIDGET(gslider));</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871">void dtgtk_gradient_slider_set_margins(GtkDarktableGradientSlider *gslider, gint value)</a>
<a name="ln872">{</a>
<a name="ln873">  gslider-&gt;margins = value;</a>
<a name="ln874">}</a>
<a name="ln875"> </a>
<a name="ln876">gboolean dtgtk_gradient_slider_is_dragging(GtkDarktableGradientSlider *gslider)</a>
<a name="ln877">{</a>
<a name="ln878">  return gslider-&gt;is_dragging;</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">void dtgtk_gradient_slider_set_increment(GtkDarktableGradientSlider *gslider, gdouble value)</a>
<a name="ln882">{</a>
<a name="ln883">  gslider-&gt;increment = value;</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886"> </a>
<a name="ln887">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln888">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln889">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="593"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'sz < 10' is always false.</p></div>
<div class="balloon" rel="597"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'sz < 10' is always false.</p></div>
<div class="balloon" rel="605"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'sz < 10' is always false.</p></div>
<div class="balloon" rel="610"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'sz < 10' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
