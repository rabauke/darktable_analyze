
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1"> </a>
<a name="ln2">/*</a>
<a name="ln3">    This file is part of darktable,</a>
<a name="ln4">    copyright (c) 2009--2014 johannes hanika, henrik andersson</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;common/darktable.h&quot;</a>
<a name="ln20">#ifdef HAVE_GPHOTO2</a>
<a name="ln21">#include &quot;common/camera_control.h&quot;</a>
<a name="ln22">#endif</a>
<a name="ln23">#include &quot;common/collection.h&quot;</a>
<a name="ln24">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln25">#include &quot;common/image.h&quot;</a>
<a name="ln26">#include &quot;common/image_cache.h&quot;</a>
<a name="ln27">#include &quot;develop/develop.h&quot;</a>
<a name="ln28">#include &quot;develop/imageop.h&quot;</a>
<a name="ln29">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln30">#include &quot;dtgtk/sidepanel.h&quot;</a>
<a name="ln31">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln32">#include &quot;gui/gtk.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;common/styles.h&quot;</a>
<a name="ln35">#include &quot;control/conf.h&quot;</a>
<a name="ln36">#include &quot;control/control.h&quot;</a>
<a name="ln37">#include &quot;control/jobs.h&quot;</a>
<a name="ln38">#include &quot;control/signal.h&quot;</a>
<a name="ln39">#include &quot;gui/presets.h&quot;</a>
<a name="ln40">#include &quot;views/view.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln43">#ifdef GDK_WINDOWING_WAYLAND</a>
<a name="ln44">#include &lt;gdk/gdkwayland.h&gt;</a>
<a name="ln45">#endif</a>
<a name="ln46">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln47">#include &lt;math.h&gt;</a>
<a name="ln48">#include &lt;stdlib.h&gt;</a>
<a name="ln49">#include &lt;string.h&gt;</a>
<a name="ln50">#include &lt;unistd.h&gt;</a>
<a name="ln51">#ifdef MAC_INTEGRATION</a>
<a name="ln52">#include &lt;gtkosxapplication.h&gt;</a>
<a name="ln53">#endif</a>
<a name="ln54">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln55">#include &quot;osx/osx.h&quot;</a>
<a name="ln56">#endif</a>
<a name="ln57">#include &lt;pthread.h&gt;</a>
<a name="ln58"> </a>
<a name="ln59">/*</a>
<a name="ln60"> * NEW UI API</a>
<a name="ln61"> */</a>
<a name="ln62"> </a>
<a name="ln63">#define DT_UI_PANEL_MODULE_SPACING 3</a>
<a name="ln64"> </a>
<a name="ln65">typedef enum dt_gui_view_switch_t</a>
<a name="ln66">{</a>
<a name="ln67">  DT_GUI_VIEW_SWITCH_TO_TETHERING = 1,</a>
<a name="ln68">  DT_GUI_VIEW_SWITCH_TO_LIGHTTABLE,</a>
<a name="ln69">  DT_GUI_VIEW_SWITCH_TO_DARKROOM,</a>
<a name="ln70">  DT_GUI_VIEW_SWITCH_TO_MAP,</a>
<a name="ln71">  DT_GUI_VIEW_SWITCH_TO_SLIDESHOW,</a>
<a name="ln72">  DT_GUI_VIEW_SWITCH_TO_PRINT</a>
<a name="ln73">} dt_gui_view_switch_to_t;</a>
<a name="ln74"> </a>
<a name="ln75">const char *_ui_panel_config_names[]</a>
<a name="ln76">    = { &quot;header&quot;, &quot;toolbar_top&quot;, &quot;toolbar_bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;bottom&quot; };</a>
<a name="ln77"> </a>
<a name="ln78">typedef struct dt_ui_t</a>
<a name="ln79">{</a>
<a name="ln80">  /* container widgets */</a>
<a name="ln81">  GtkWidget *containers[DT_UI_CONTAINER_SIZE];</a>
<a name="ln82"> </a>
<a name="ln83">  /* border widgets */</a>
<a name="ln84">  GtkWidget *borders[DT_UI_BORDER_SIZE];</a>
<a name="ln85"> </a>
<a name="ln86">  /* panel widgets */</a>
<a name="ln87">  GtkWidget *panels[DT_UI_PANEL_SIZE];</a>
<a name="ln88"> </a>
<a name="ln89">  /* center widget */</a>
<a name="ln90">  GtkWidget *center;</a>
<a name="ln91">  /* main widget */</a>
<a name="ln92">  GtkWidget *main_window;</a>
<a name="ln93">} dt_ui_t;</a>
<a name="ln94"> </a>
<a name="ln95">/* initialize the whole left panel */</a>
<a name="ln96">static void _ui_init_panel_left(struct dt_ui_t *ui, GtkWidget *container);</a>
<a name="ln97">/* initialize the whole right panel */</a>
<a name="ln98">static void _ui_init_panel_right(dt_ui_t *ui, GtkWidget *container);</a>
<a name="ln99">/* initialize the top container of panel */</a>
<a name="ln100">static GtkWidget *_ui_init_panel_container_top(GtkWidget *container);</a>
<a name="ln101">/* initialize the center container of panel */</a>
<a name="ln102">static GtkWidget *_ui_init_panel_container_center(GtkWidget *container, gboolean left);</a>
<a name="ln103">/* initialize the bottom container of panel */</a>
<a name="ln104">static GtkWidget *_ui_init_panel_container_bottom(GtkWidget *container);</a>
<a name="ln105">/* initialize the top container of panel */</a>
<a name="ln106">static void _ui_init_panel_top(dt_ui_t *ui, GtkWidget *container);</a>
<a name="ln107">/* initialize the center top panel */</a>
<a name="ln108">static void _ui_init_panel_center_top(dt_ui_t *ui, GtkWidget *container);</a>
<a name="ln109">/* initialize the center bottom panel */</a>
<a name="ln110">static void _ui_init_panel_center_bottom(dt_ui_t *ui, GtkWidget *container);</a>
<a name="ln111">/* initialize the bottom panel */</a>
<a name="ln112">static void _ui_init_panel_bottom(dt_ui_t *ui, GtkWidget *container);</a>
<a name="ln113">/* generic callback for redraw widget signals */</a>
<a name="ln114">static void _ui_widget_redraw_callback(gpointer instance, GtkWidget *widget);</a>
<a name="ln115"> </a>
<a name="ln116">/* Set the HiDPI stuff */</a>
<a name="ln117">static void configure_ppd_dpi(dt_gui_gtk_t *gui);</a>
<a name="ln118"> </a>
<a name="ln119">/*</a>
<a name="ln120"> * OLD UI API</a>
<a name="ln121"> */</a>
<a name="ln122">static void init_widgets(dt_gui_gtk_t *gui);</a>
<a name="ln123"> </a>
<a name="ln124">static void init_main_table(GtkWidget *container);</a>
<a name="ln125"> </a>
<a name="ln126">static void key_accel_changed(GtkAccelMap *object, gchar *accel_path, guint accel_key,</a>
<a name="ln127">                              GdkModifierType accel_mods, gpointer user_data)</a>
<a name="ln128">{</a>
<a name="ln129">  char path[256];</a>
<a name="ln130"> </a>
<a name="ln131">  // Updating all the stored accelerator keys/mods for key_pressed shortcuts</a>
<a name="ln132"> </a>
<a name="ln133">  dt_accel_path_view(path, sizeof(path), &quot;filmstrip&quot;, &quot;scroll forward&quot;);</a>
<a name="ln134">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.filmstrip_forward);</a>
<a name="ln135">  dt_accel_path_view(path, sizeof(path), &quot;filmstrip&quot;, &quot;scroll back&quot;);</a>
<a name="ln136">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.filmstrip_back);</a>
<a name="ln137"> </a>
<a name="ln138">  // slideshow</a>
<a name="ln139">  dt_accel_path_view(path, sizeof(path), &quot;slideshow&quot;, &quot;start and stop&quot;);</a>
<a name="ln140">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.slideshow_start);</a>
<a name="ln141">  // Lighttable</a>
<a name="ln142">  dt_accel_path_view(path, sizeof(path), &quot;lighttable&quot;, &quot;scroll up&quot;);</a>
<a name="ln143">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.lighttable_up);</a>
<a name="ln144">  dt_accel_path_view(path, sizeof(path), &quot;lighttable&quot;, &quot;scroll down&quot;);</a>
<a name="ln145">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.lighttable_down);</a>
<a name="ln146">  dt_accel_path_view(path, sizeof(path), &quot;lighttable&quot;, &quot;scroll left&quot;);</a>
<a name="ln147">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.lighttable_left);</a>
<a name="ln148">  dt_accel_path_view(path, sizeof(path), &quot;lighttable&quot;, &quot;scroll right&quot;);</a>
<a name="ln149">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.lighttable_right);</a>
<a name="ln150">  dt_accel_path_view(path, sizeof(path), &quot;lighttable&quot;, &quot;scroll center&quot;);</a>
<a name="ln151">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.lighttable_center);</a>
<a name="ln152">  dt_accel_path_view(path, sizeof(path), &quot;lighttable&quot;, &quot;preview&quot;);</a>
<a name="ln153">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.lighttable_preview);</a>
<a name="ln154">  dt_accel_path_view(path, sizeof(path), &quot;lighttable&quot;, &quot;preview with focus detection&quot;);</a>
<a name="ln155">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.lighttable_preview_display_focus);</a>
<a name="ln156">  dt_accel_path_view(path, sizeof(path), &quot;lighttable&quot;, &quot;sticky preview&quot;);</a>
<a name="ln157">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.lighttable_preview_sticky);</a>
<a name="ln158">  dt_accel_path_view(path, sizeof(path), &quot;lighttable&quot;, &quot;sticky preview with focus detection&quot;);</a>
<a name="ln159">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.lighttable_preview_sticky_focus);</a>
<a name="ln160">  dt_accel_path_view(path, sizeof(path), &quot;lighttable&quot;, &quot;exit sticky preview&quot;);</a>
<a name="ln161">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.lighttable_preview_sticky_exit);</a>
<a name="ln162">  // darkroom</a>
<a name="ln163">  dt_accel_path_view(path, sizeof(path), &quot;darkroom&quot;, &quot;full preview&quot;);</a>
<a name="ln164">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.darkroom_preview);</a>
<a name="ln165">  // add an option to allow skip mouse events while editing masks</a>
<a name="ln166">  dt_accel_path_view(path, sizeof(path), &quot;darkroom&quot;, &quot;allow to pan &amp; zoom while editing masks&quot;);</a>
<a name="ln167">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.darkroom_skip_mouse_events);</a>
<a name="ln168"> </a>
<a name="ln169">  // Global</a>
<a name="ln170">  dt_accel_path_global(path, sizeof(path), &quot;toggle side borders&quot;);</a>
<a name="ln171">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.global_sideborders);</a>
<a name="ln172"> </a>
<a name="ln173">  dt_accel_path_global(path, sizeof(path), &quot;toggle header&quot;);</a>
<a name="ln174">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.global_header);</a>
<a name="ln175"> </a>
<a name="ln176">  dt_accel_path_global(path, sizeof(path), &quot;zoom in&quot;);</a>
<a name="ln177">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.global_zoom_in);</a>
<a name="ln178"> </a>
<a name="ln179">  dt_accel_path_global(path, sizeof(path), &quot;zoom out&quot;);</a>
<a name="ln180">  gtk_accel_map_lookup_entry(path, &amp;darktable.control-&gt;accels.global_zoom_out);</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">static gboolean fullscreen_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable,</a>
<a name="ln184">                                              guint keyval, GdkModifierType modifier, gpointer data)</a>
<a name="ln185">{</a>
<a name="ln186">  GtkWidget *widget;</a>
<a name="ln187">  int fullscreen;</a>
<a name="ln188"> </a>
<a name="ln189">  if(data)</a>
<a name="ln190">  {</a>
<a name="ln191">    widget = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln192">    fullscreen = gdk_window_get_state(gtk_widget_get_window(widget)) &amp; GDK_WINDOW_STATE_FULLSCREEN;</a>
<a name="ln193">    if(fullscreen)</a>
<a name="ln194">      gtk_window_unfullscreen(GTK_WINDOW(widget));</a>
<a name="ln195">    else</a>
<a name="ln196">      gtk_window_fullscreen(GTK_WINDOW(widget));</a>
<a name="ln197">    dt_dev_invalidate(darktable.develop);</a>
<a name="ln198">  }</a>
<a name="ln199">  else</a>
<a name="ln200">  {</a>
<a name="ln201">    widget = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln202">    gtk_window_unfullscreen(GTK_WINDOW(widget));</a>
<a name="ln203">    dt_dev_invalidate(darktable.develop);</a>
<a name="ln204">  }</a>
<a name="ln205"> </a>
<a name="ln206">  /* redraw center view */</a>
<a name="ln207">  gtk_widget_queue_draw(dt_ui_center(darktable.gui-&gt;ui));</a>
<a name="ln208">#ifdef __APPLE__</a>
<a name="ln209">  // workaround for GTK Quartz backend bug</a>
<a name="ln210">  gtk_window_set_title(GTK_WINDOW(widget), &quot;Darktable&quot;);</a>
<a name="ln211">#endif</a>
<a name="ln212">  return TRUE;</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">static gboolean view_switch_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable,</a>
<a name="ln216">                                               guint keyval, GdkModifierType modifier, gpointer data)</a>
<a name="ln217">{</a>
<a name="ln218">  dt_ctl_switch_mode();</a>
<a name="ln219">  gtk_widget_queue_draw(dt_ui_center(darktable.gui-&gt;ui));</a>
<a name="ln220">  return TRUE;</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">static gboolean borders_button_pressed(GtkWidget *w, GdkEventButton *event, gpointer user_data)</a>
<a name="ln224">{</a>
<a name="ln225">  dt_ui_t *ui = (dt_ui_t *)user_data;</a>
<a name="ln226">  const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln227">  char key[512];</a>
<a name="ln228"> </a>
<a name="ln229"> </a>
<a name="ln230">  int which = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(w), &quot;border&quot;));</a>
<a name="ln231">  switch(which)</a>
<a name="ln232">  {</a>
<a name="ln233">    case 0: // left border</a>
<a name="ln234">    {</a>
<a name="ln235">      g_snprintf(key, sizeof(key), &quot;%s/ui/%s_visible&quot;, cv-&gt;module_name,</a>
<a name="ln236">                 _ui_panel_config_names[DT_UI_PANEL_LEFT]);</a>
<a name="ln237">      dt_ui_panel_show(ui, DT_UI_PANEL_LEFT, !dt_conf_get_bool(key), TRUE);</a>
<a name="ln238">    }</a>
<a name="ln239">    break;</a>
<a name="ln240"> </a>
<a name="ln241">    case 1: // right border</a>
<a name="ln242">    {</a>
<a name="ln243">      g_snprintf(key, sizeof(key), &quot;%s/ui/%s_visible&quot;, cv-&gt;module_name,</a>
<a name="ln244">                 _ui_panel_config_names[DT_UI_PANEL_RIGHT]);</a>
<a name="ln245">      dt_ui_panel_show(ui, DT_UI_PANEL_RIGHT, !dt_conf_get_bool(key), TRUE);</a>
<a name="ln246">    }</a>
<a name="ln247">    break;</a>
<a name="ln248"> </a>
<a name="ln249">    case 2: // top border</a>
<a name="ln250">    {</a>
<a name="ln251">      g_snprintf(key, sizeof(key), &quot;%s/ui/%s_visible&quot;, cv-&gt;module_name,</a>
<a name="ln252">                 _ui_panel_config_names[DT_UI_PANEL_CENTER_TOP]);</a>
<a name="ln253">      gboolean show = !dt_conf_get_bool(key);</a>
<a name="ln254">      dt_ui_panel_show(ui, DT_UI_PANEL_CENTER_TOP, show, TRUE);</a>
<a name="ln255"> </a>
<a name="ln256">      /* special case show header */</a>
<a name="ln257">      g_snprintf(key, sizeof(key), &quot;%s/ui/show_header&quot;, cv-&gt;module_name);</a>
<a name="ln258">      if(dt_conf_get_bool(key)) dt_ui_panel_show(ui, DT_UI_PANEL_TOP, show, TRUE);</a>
<a name="ln259">    }</a>
<a name="ln260">    break;</a>
<a name="ln261"> </a>
<a name="ln262">    case 4: // bottom border</a>
<a name="ln263">    default:</a>
<a name="ln264">    {</a>
<a name="ln265">      g_snprintf(key, sizeof(key), &quot;%s/ui/%s_visible&quot;, cv-&gt;module_name,</a>
<a name="ln266">                 _ui_panel_config_names[DT_UI_PANEL_CENTER_BOTTOM]);</a>
<a name="ln267">      gboolean show = !dt_conf_get_bool(key);</a>
<a name="ln268">      dt_ui_panel_show(ui, DT_UI_PANEL_CENTER_BOTTOM, show, TRUE);</a>
<a name="ln269">      dt_ui_panel_show(ui, DT_UI_PANEL_BOTTOM, show, TRUE);</a>
<a name="ln270">    }</a>
<a name="ln271">    break;</a>
<a name="ln272">  }</a>
<a name="ln273"> </a>
<a name="ln274">  gtk_widget_queue_draw(w);</a>
<a name="ln275"> </a>
<a name="ln276">  return TRUE;</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">gboolean dt_gui_get_scroll_deltas(const GdkEventScroll *event, gdouble *delta_x, gdouble *delta_y)</a>
<a name="ln280">{</a>
<a name="ln281">  gboolean handled = FALSE;</a>
<a name="ln282">  switch(event-&gt;direction)</a>
<a name="ln283">  {</a>
<a name="ln284">    // is one-unit cardinal, e.g. from a mouse scroll wheel</a>
<a name="ln285">    case GDK_SCROLL_LEFT:</a>
<a name="ln286">      if(delta_x) *delta_x = -1.0;</a>
<a name="ln287">      if(delta_y) *delta_y = 0.0;</a>
<a name="ln288">      handled = TRUE;</a>
<a name="ln289">      break;</a>
<a name="ln290">    case GDK_SCROLL_RIGHT:</a>
<a name="ln291">      if(delta_x) *delta_x = 1.0;</a>
<a name="ln292">      if(delta_y) *delta_y = 0.0;</a>
<a name="ln293">      handled = TRUE;</a>
<a name="ln294">      break;</a>
<a name="ln295">    case GDK_SCROLL_UP:</a>
<a name="ln296">      if(delta_x) *delta_x = 0.0;</a>
<a name="ln297">      if(delta_y) *delta_y = -1.0;</a>
<a name="ln298">      handled = TRUE;</a>
<a name="ln299">      break;</a>
<a name="ln300">    case GDK_SCROLL_DOWN:</a>
<a name="ln301">      if(delta_x) *delta_x = 0.0;</a>
<a name="ln302">      if(delta_y) *delta_y = 1.0;</a>
<a name="ln303">      handled = TRUE;</a>
<a name="ln304">      break;</a>
<a name="ln305">    // is trackpad (or touch) scroll</a>
<a name="ln306">    case GDK_SCROLL_SMOOTH:</a>
<a name="ln307">      if(delta_x) *delta_x = event-&gt;delta_x;</a>
<a name="ln308">      if(delta_y) *delta_y = event-&gt;delta_y;</a>
<a name="ln309">      handled = TRUE;</a>
<a name="ln310">    default:</a>
<a name="ln311">      break;</a>
<a name="ln312">    }</a>
<a name="ln313">  return handled;</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">gboolean dt_gui_get_scroll_unit_deltas(const GdkEventScroll *event, int *delta_x, int *delta_y)</a>
<a name="ln317">{</a>
<a name="ln318">  // accumulates scrolling regardless of source or the widget being scrolled</a>
<a name="ln319">  static gdouble acc_x = 0.0, acc_y = 0.0;</a>
<a name="ln320">  gboolean handled = FALSE;</a>
<a name="ln321"> </a>
<a name="ln322">  switch(event-&gt;direction)</a>
<a name="ln323">  {</a>
<a name="ln324">    // is one-unit cardinal, e.g. from a mouse scroll wheel</a>
<a name="ln325">    case GDK_SCROLL_LEFT:</a>
<a name="ln326">      if(delta_x) *delta_x = -1;</a>
<a name="ln327">      if(delta_y) *delta_y = 0;</a>
<a name="ln328">      handled = TRUE;</a>
<a name="ln329">      break;</a>
<a name="ln330">    case GDK_SCROLL_RIGHT:</a>
<a name="ln331">      if(delta_x) *delta_x = 1;</a>
<a name="ln332">      if(delta_y) *delta_y = 0;</a>
<a name="ln333">      handled = TRUE;</a>
<a name="ln334">      break;</a>
<a name="ln335">    case GDK_SCROLL_UP:</a>
<a name="ln336">      if(delta_x) *delta_x = 0;</a>
<a name="ln337">      if(delta_y) *delta_y = -1;</a>
<a name="ln338">      handled = TRUE;</a>
<a name="ln339">      break;</a>
<a name="ln340">    case GDK_SCROLL_DOWN:</a>
<a name="ln341">      if(delta_x) *delta_x = 0;</a>
<a name="ln342">      if(delta_y) *delta_y = 1;</a>
<a name="ln343">      handled = TRUE;</a>
<a name="ln344">      break;</a>
<a name="ln345">    // is trackpad (or touch) scroll</a>
<a name="ln346">    case GDK_SCROLL_SMOOTH:</a>
<a name="ln347">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln348">      // stop events reset accumulated delta</a>
<a name="ln349">      if(event-&gt;is_stop)</a>
<a name="ln350">      {</a>
<a name="ln351">        acc_x = acc_y = 0.0;</a>
<a name="ln352">        break;</a>
<a name="ln353">      }</a>
<a name="ln354">#endif</a>
<a name="ln355">      // accumulate trackpad/touch scrolls until they make a unit</a>
<a name="ln356">      // scroll, and only then tell caller that there is a scroll to</a>
<a name="ln357">      // handle</a>
<a name="ln358">      acc_x += event-&gt;delta_x;</a>
<a name="ln359">      acc_y += event-&gt;delta_y;</a>
<a name="ln360">      if(fabs(acc_x) &gt;= 1.0)</a>
<a name="ln361">      {</a>
<a name="ln362">        gdouble amt = trunc(acc_x);</a>
<a name="ln363">        acc_x -= amt;</a>
<a name="ln364">        if(delta_x) *delta_x = (int)amt;</a>
<a name="ln365">        if(delta_y) *delta_y = 0;</a>
<a name="ln366">        handled = TRUE;</a>
<a name="ln367">      }</a>
<a name="ln368">      if(fabs(acc_y) &gt;= 1.0)</a>
<a name="ln369">      {</a>
<a name="ln370">        gdouble amt = trunc(acc_y);</a>
<a name="ln371">        acc_y -= amt;</a>
<a name="ln372">        if(delta_x &amp;&amp; !handled) *delta_x = 0;</a>
<a name="ln373">        if(delta_y) *delta_y = (int)amt;</a>
<a name="ln374">        handled = TRUE;</a>
<a name="ln375">      }</a>
<a name="ln376">      break;</a>
<a name="ln377">    default:</a>
<a name="ln378">      break;</a>
<a name="ln379">  }</a>
<a name="ln380">  return handled;</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">static gboolean _widget_focus_in_block_key_accelerators(GtkWidget *widget, GdkEventFocus *event, gpointer data)</a>
<a name="ln384">{</a>
<a name="ln385">  dt_control_key_accelerators_off(darktable.control);</a>
<a name="ln386">  return FALSE;</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">static gboolean _widget_focus_out_unblock_key_accelerators(GtkWidget *widget, GdkEventFocus *event,</a>
<a name="ln390">                                                           gpointer data)</a>
<a name="ln391">{</a>
<a name="ln392">  dt_control_key_accelerators_on(darktable.control);</a>
<a name="ln393">  return FALSE;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">void dt_gui_key_accel_block_on_focus_disconnect(GtkWidget *w)</a>
<a name="ln397">{</a>
<a name="ln398">  g_signal_handlers_disconnect_by_func(G_OBJECT(w), _widget_focus_in_block_key_accelerators, (gpointer)w);</a>
<a name="ln399">  g_signal_handlers_disconnect_by_func(G_OBJECT(w), _widget_focus_out_unblock_key_accelerators, (gpointer)w);</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">void dt_gui_key_accel_block_on_focus_connect(GtkWidget *w)</a>
<a name="ln403">{</a>
<a name="ln404">  /* first off add focus change event mask */</a>
<a name="ln405">  gtk_widget_add_events(w, GDK_FOCUS_CHANGE_MASK);</a>
<a name="ln406"> </a>
<a name="ln407">  /* connect the signals */</a>
<a name="ln408">  g_signal_connect(G_OBJECT(w), &quot;focus-in-event&quot;, G_CALLBACK(_widget_focus_in_block_key_accelerators),</a>
<a name="ln409">                   (gpointer)w);</a>
<a name="ln410">  g_signal_connect(G_OBJECT(w), &quot;focus-out-event&quot;, G_CALLBACK(_widget_focus_out_unblock_key_accelerators),</a>
<a name="ln411">                   (gpointer)w);</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414">static gboolean draw_borders(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln415">{</a>
<a name="ln416">  // draw arrows on borders</a>
<a name="ln417">  if(!dt_control_running()) return TRUE;</a>
<a name="ln418">  int which = GPOINTER_TO_INT(user_data);</a>
<a name="ln419">  GtkAllocation allocation;</a>
<a name="ln420">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln421">  float width = allocation.width, height = allocation.height;</a>
<a name="ln422">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln423">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln424"> </a>
<a name="ln425">  GdkRGBA color;</a>
<a name="ln426">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln427">  gboolean color_found = gtk_style_context_lookup_color (context, &quot;selected_bg_color&quot;, &amp;color);</a>
<a name="ln428">  if(!color_found)</a>
<a name="ln429">  {</a>
<a name="ln430">    color.red = 1.0;</a>
<a name="ln431">    color.green = 0.0;</a>
<a name="ln432">    color.blue = 0.0;</a>
<a name="ln433">    color.alpha = 1.0;</a>
<a name="ln434">  }</a>
<a name="ln435">  gdk_cairo_set_source_rgba(cr, &amp;color);</a>
<a name="ln436">  cairo_paint(cr);</a>
<a name="ln437"> </a>
<a name="ln438">  // draw scrollbar indicators</a>
<a name="ln439">  const dt_view_t *view = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln440">  color_found = gtk_style_context_lookup_color (context, &quot;bg_color&quot;, &amp;color);</a>
<a name="ln441">  if(!color_found)</a>
<a name="ln442">  {</a>
<a name="ln443">    color.red = 1.0;</a>
<a name="ln444">    color.green = 0.0;</a>
<a name="ln445">    color.blue = 0.0;</a>
<a name="ln446">    color.alpha = 1.0;</a>
<a name="ln447">  }</a>
<a name="ln448">  gdk_cairo_set_source_rgba(cr, &amp;color);</a>
<a name="ln449">  const float border = 0.3;</a>
<a name="ln450">  if(!view)</a>
<a name="ln451">    cairo_paint(cr);</a>
<a name="ln452">  else</a>
<a name="ln453">  {</a>
<a name="ln454">    switch(which)</a>
<a name="ln455">    {</a>
<a name="ln456">      case 0:</a>
<a name="ln457">      case 1: // left, right: vertical</a>
<a name="ln458">        cairo_rectangle(cr, 0.0,</a>
<a name="ln459">                        (view-&gt;vscroll_pos - view-&gt;vscroll_lower) / (view-&gt;vscroll_size - view-&gt;vscroll_lower) * height,</a>
<a name="ln460">                        width,</a>
<a name="ln461">                        MAX(DT_PIXEL_APPLY_DPI(5),</a>
<a name="ln462">                            view-&gt;vscroll_viewport_size / (view-&gt;vscroll_size - view-&gt;vscroll_lower) * height));</a>
<a name="ln463">        break;</a>
<a name="ln464">      default: // bottom, top: horizontal</a>
<a name="ln465">        cairo_rectangle(cr,</a>
<a name="ln466">                        (view-&gt;hscroll_pos - view-&gt;hscroll_lower) / (view-&gt;hscroll_size - view-&gt;hscroll_lower) * width,</a>
<a name="ln467">                        0.0,</a>
<a name="ln468">                        MAX(DT_PIXEL_APPLY_DPI(5),</a>
<a name="ln469">                            view-&gt;hscroll_viewport_size / (view-&gt;hscroll_size - view-&gt;hscroll_lower) * width), height);</a>
<a name="ln470">        break;</a>
<a name="ln471">    }</a>
<a name="ln472">    cairo_fill(cr);</a>
<a name="ln473">    switch(which)</a>
<a name="ln474">    {</a>
<a name="ln475">      case 0:</a>
<a name="ln476">        cairo_rectangle(cr, (1.0 - border) * width, 0.0, border * width, height);</a>
<a name="ln477">        break;</a>
<a name="ln478">      case 1:</a>
<a name="ln479">        cairo_rectangle(cr, 0.0, 0.0, border * width, height);</a>
<a name="ln480">        break;</a>
<a name="ln481">      case 2:</a>
<a name="ln482">        cairo_rectangle(cr, (1.0 - border) * height, (1.0 - border) * height,</a>
<a name="ln483">                        width - 2 * (1.0 - border) * height, border * height);</a>
<a name="ln484">        break;</a>
<a name="ln485">      default:</a>
<a name="ln486">        cairo_rectangle(cr, (1.0 - border) * height, 0.0, width - 2 * (1.0 - border) * height,</a>
<a name="ln487">                        border * height);</a>
<a name="ln488">        break;</a>
<a name="ln489">    }</a>
<a name="ln490">    cairo_fill(cr);</a>
<a name="ln491">  }</a>
<a name="ln492"> </a>
<a name="ln493">  // draw gui arrows.</a>
<a name="ln494">  color_found = gtk_style_context_lookup_color (context, &quot;fg_color&quot;, &amp;color);</a>
<a name="ln495">  if(!color_found)</a>
<a name="ln496">  {</a>
<a name="ln497">    color.red = 1.0;</a>
<a name="ln498">    color.green = 0.0;</a>
<a name="ln499">    color.blue = 0.0;</a>
<a name="ln500">    color.alpha = 1.0;</a>
<a name="ln501">  }</a>
<a name="ln502">  gdk_cairo_set_source_rgba(cr, &amp;color);</a>
<a name="ln503"> </a>
<a name="ln504">  switch(which)</a>
<a name="ln505">  {</a>
<a name="ln506">    case 0: // left</a>
<a name="ln507">      if(dt_ui_panel_visible(darktable.gui-&gt;ui, DT_UI_PANEL_LEFT))</a>
<a name="ln508">      {</a>
<a name="ln509">        cairo_move_to(cr, width, height / 2 - width);</a>
<a name="ln510">        cairo_rel_line_to(cr, 0.0, 2 * width);</a>
<a name="ln511">        cairo_rel_line_to(cr, -width, -width);</a>
<a name="ln512">      }</a>
<a name="ln513">      else</a>
<a name="ln514">      {</a>
<a name="ln515">        cairo_move_to(cr, 0.0, height / 2 - width);</a>
<a name="ln516">        cairo_rel_line_to(cr, 0.0, 2 * width);</a>
<a name="ln517">        cairo_rel_line_to(cr, width, -width);</a>
<a name="ln518">      }</a>
<a name="ln519">      break;</a>
<a name="ln520">    case 1: // right</a>
<a name="ln521">      if(dt_ui_panel_visible(darktable.gui-&gt;ui, DT_UI_PANEL_RIGHT))</a>
<a name="ln522">      {</a>
<a name="ln523">        cairo_move_to(cr, 0.0, height / 2 - width);</a>
<a name="ln524">        cairo_rel_line_to(cr, 0.0, 2 * width);</a>
<a name="ln525">        cairo_rel_line_to(cr, width, -width);</a>
<a name="ln526">      }</a>
<a name="ln527">      else</a>
<a name="ln528">      {</a>
<a name="ln529">        cairo_move_to(cr, width, height / 2 - width);</a>
<a name="ln530">        cairo_rel_line_to(cr, 0.0, 2 * width);</a>
<a name="ln531">        cairo_rel_line_to(cr, -width, -width);</a>
<a name="ln532">      }</a>
<a name="ln533">      break;</a>
<a name="ln534">    case 2: // top</a>
<a name="ln535">      if(dt_ui_panel_visible(darktable.gui-&gt;ui, DT_UI_PANEL_CENTER_TOP))</a>
<a name="ln536">      {</a>
<a name="ln537">        cairo_move_to(cr, width / 2 - height, height);</a>
<a name="ln538">        cairo_rel_line_to(cr, 2 * height, 0.0);</a>
<a name="ln539">        cairo_rel_line_to(cr, -height, -height);</a>
<a name="ln540">      }</a>
<a name="ln541">      else</a>
<a name="ln542">      {</a>
<a name="ln543">        cairo_move_to(cr, width / 2 - height, 0.0);</a>
<a name="ln544">        cairo_rel_line_to(cr, 2 * height, 0.0);</a>
<a name="ln545">        cairo_rel_line_to(cr, -height, height);</a>
<a name="ln546">      }</a>
<a name="ln547">      break;</a>
<a name="ln548">    default: // bottom</a>
<a name="ln549">      if(dt_ui_panel_visible(darktable.gui-&gt;ui, DT_UI_PANEL_CENTER_BOTTOM))</a>
<a name="ln550">      {</a>
<a name="ln551">        cairo_move_to(cr, width / 2 - height, 0.0);</a>
<a name="ln552">        cairo_rel_line_to(cr, 2 * height, 0.0);</a>
<a name="ln553">        cairo_rel_line_to(cr, -height, height);</a>
<a name="ln554">      }</a>
<a name="ln555">      else</a>
<a name="ln556">      {</a>
<a name="ln557">        cairo_move_to(cr, width / 2 - height, height);</a>
<a name="ln558">        cairo_rel_line_to(cr, 2 * height, 0.0);</a>
<a name="ln559">        cairo_rel_line_to(cr, -height, -height);</a>
<a name="ln560">      }</a>
<a name="ln561">      break;</a>
<a name="ln562">  }</a>
<a name="ln563">  cairo_close_path(cr);</a>
<a name="ln564">  cairo_fill(cr);</a>
<a name="ln565"> </a>
<a name="ln566">  cairo_destroy(cr);</a>
<a name="ln567">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln568">  cairo_paint(crf);</a>
<a name="ln569">  cairo_surface_destroy(cst);</a>
<a name="ln570">  return TRUE;</a>
<a name="ln571">}</a>
<a name="ln572"> </a>
<a name="ln573">static gboolean draw(GtkWidget *da, cairo_t *cr, gpointer user_data)</a>
<a name="ln574">{</a>
<a name="ln575">  dt_control_expose(NULL);</a>
<a name="ln576">  if(darktable.gui-&gt;surface)</a>
<a name="ln577">  {</a>
<a name="ln578">    cairo_set_source_surface(cr, darktable.gui-&gt;surface, 0, 0);</a>
<a name="ln579">    cairo_paint(cr);</a>
<a name="ln580">  }</a>
<a name="ln581"> </a>
<a name="ln582">  if(darktable.lib-&gt;proxy.colorpicker.module)</a>
<a name="ln583">  {</a>
<a name="ln584">    darktable.lib-&gt;proxy.colorpicker.update_panel(darktable.lib-&gt;proxy.colorpicker.module);</a>
<a name="ln585">    darktable.lib-&gt;proxy.colorpicker.update_samples(darktable.lib-&gt;proxy.colorpicker.module);</a>
<a name="ln586">  }</a>
<a name="ln587"> </a>
<a name="ln588">  return TRUE;</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">static gboolean scrolled(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln592">{</a>
<a name="ln593">  int delta_y;</a>
<a name="ln594">  if(dt_gui_get_scroll_unit_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln595">  {</a>
<a name="ln596">    dt_view_manager_scrolled(darktable.view_manager, event-&gt;x, event-&gt;y,</a>
<a name="ln597">                             delta_y &lt; 0,</a>
<a name="ln598">                             event-&gt;state &amp; 0xf);</a>
<a name="ln599">    gtk_widget_queue_draw(widget);</a>
<a name="ln600">  }</a>
<a name="ln601"> </a>
<a name="ln602">  return TRUE;</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605">static gboolean borders_scrolled(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln606">{</a>
<a name="ln607">  // pass the scroll event to the matching side panel</a>
<a name="ln608">  gboolean res;</a>
<a name="ln609">  g_signal_emit_by_name(G_OBJECT(user_data), &quot;scroll-event&quot;, event, &amp;res);</a>
<a name="ln610"> </a>
<a name="ln611">  return TRUE;</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">static gboolean scrollbar_changed(GtkWidget *widget, gpointer user_data)</a>
<a name="ln615">{</a>
<a name="ln616">  gdouble value_x, value_y;</a>
<a name="ln617"> </a>
<a name="ln618">  GtkAdjustment *adjustment_x = gtk_range_get_adjustment(GTK_RANGE(darktable.gui-&gt;scrollbars.hscrollbar));</a>
<a name="ln619">  GtkAdjustment *adjustment_y = gtk_range_get_adjustment(GTK_RANGE(darktable.gui-&gt;scrollbars.vscrollbar));</a>
<a name="ln620"> </a>
<a name="ln621">  value_x = gtk_adjustment_get_value (adjustment_x);</a>
<a name="ln622">  value_y = gtk_adjustment_get_value (adjustment_y);</a>
<a name="ln623"> </a>
<a name="ln624">  dt_view_manager_scrollbar_changed(darktable.view_manager, value_x, value_y);</a>
<a name="ln625"> </a>
<a name="ln626">  return TRUE;</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">static gboolean scrollbar_press_event(GtkWidget *widget, gpointer user_data)</a>
<a name="ln630">{</a>
<a name="ln631">  darktable.gui-&gt;scrollbars.dragging = TRUE;</a>
<a name="ln632">  return FALSE;</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">static gboolean scrollbar_release_event(GtkWidget *widget, gpointer user_data)</a>
<a name="ln636">{</a>
<a name="ln637">  darktable.gui-&gt;scrollbars.dragging = FALSE;</a>
<a name="ln638">  return FALSE;</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641">int dt_gui_gtk_load_config()</a>
<a name="ln642">{</a>
<a name="ln643">  GtkWidget *widget = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln644">  int width = dt_conf_get_int(&quot;ui_last/window_w&quot;);</a>
<a name="ln645">  int height = dt_conf_get_int(&quot;ui_last/window_h&quot;);</a>
<a name="ln646">  gint x = MAX(0, dt_conf_get_int(&quot;ui_last/window_x&quot;));</a>
<a name="ln647">  gint y = MAX(0, dt_conf_get_int(&quot;ui_last/window_y&quot;));</a>
<a name="ln648">  gtk_window_move(GTK_WINDOW(widget), x, y);</a>
<a name="ln649">  gtk_window_resize(GTK_WINDOW(widget), width, height);</a>
<a name="ln650">  int fullscreen = dt_conf_get_bool(&quot;ui_last/fullscreen&quot;);</a>
<a name="ln651">  if(fullscreen)</a>
<a name="ln652">    gtk_window_fullscreen(GTK_WINDOW(widget));</a>
<a name="ln653">  else</a>
<a name="ln654">  {</a>
<a name="ln655">    gtk_window_unfullscreen(GTK_WINDOW(widget));</a>
<a name="ln656">    int maximized = dt_conf_get_bool(&quot;ui_last/maximized&quot;);</a>
<a name="ln657">    if(maximized)</a>
<a name="ln658">      gtk_window_maximize(GTK_WINDOW(widget));</a>
<a name="ln659">    else</a>
<a name="ln660">      gtk_window_unmaximize(GTK_WINDOW(widget));</a>
<a name="ln661">  }</a>
<a name="ln662">  return 0;</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">int dt_gui_gtk_write_config()</a>
<a name="ln666">{</a>
<a name="ln667">  GtkWidget *widget = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln668">  GtkAllocation allocation;</a>
<a name="ln669">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln670">  gint x, y;</a>
<a name="ln671">  gtk_window_get_position(GTK_WINDOW(widget), &amp;x, &amp;y);</a>
<a name="ln672">  dt_conf_set_int(&quot;ui_last/window_x&quot;, x);</a>
<a name="ln673">  dt_conf_set_int(&quot;ui_last/window_y&quot;, y);</a>
<a name="ln674">  dt_conf_set_int(&quot;ui_last/window_w&quot;, allocation.width);</a>
<a name="ln675">  dt_conf_set_int(&quot;ui_last/window_h&quot;, allocation.height);</a>
<a name="ln676">  dt_conf_set_bool(&quot;ui_last/maximized&quot;,</a>
<a name="ln677">                   (gdk_window_get_state(gtk_widget_get_window(widget)) &amp; GDK_WINDOW_STATE_MAXIMIZED));</a>
<a name="ln678">  dt_conf_set_bool(&quot;ui_last/fullscreen&quot;,</a>
<a name="ln679">                   (gdk_window_get_state(gtk_widget_get_window(widget)) &amp; GDK_WINDOW_STATE_FULLSCREEN));</a>
<a name="ln680"> </a>
<a name="ln681">  return 0;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">void dt_gui_gtk_set_source_rgb(cairo_t *cr, dt_gui_color_t color)</a>
<a name="ln685">{</a>
<a name="ln686">  GdkRGBA bc = darktable.gui-&gt;colors[color];</a>
<a name="ln687">  cairo_set_source_rgb(cr, bc.red, bc.green, bc.blue);</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690">void dt_gui_gtk_set_source_rgba(cairo_t *cr, dt_gui_color_t color, float opacity_coef)</a>
<a name="ln691">{</a>
<a name="ln692">  GdkRGBA bc = darktable.gui-&gt;colors[color];</a>
<a name="ln693">  cairo_set_source_rgba(cr, bc.red, bc.green, bc.blue, bc.alpha * opacity_coef);</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">void dt_gui_gtk_quit()</a>
<a name="ln697">{</a>
<a name="ln698">  GtkWindow *win = GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui));</a>
<a name="ln699"> </a>
<a name="ln700">  // Write out windows dimension before miminizing</a>
<a name="ln701">  dt_gui_gtk_write_config();</a>
<a name="ln702">  gtk_window_iconify(win);</a>
<a name="ln703"> </a>
<a name="ln704">  GtkWidget *widget;</a>
<a name="ln705">  widget = darktable.gui-&gt;widgets.left_border;</a>
<a name="ln706">  g_signal_handlers_block_by_func(widget, draw_borders, GINT_TO_POINTER(0));</a>
<a name="ln707">  widget = darktable.gui-&gt;widgets.right_border;</a>
<a name="ln708">  g_signal_handlers_block_by_func(widget, draw_borders, GINT_TO_POINTER(1));</a>
<a name="ln709">  widget = darktable.gui-&gt;widgets.top_border;</a>
<a name="ln710">  g_signal_handlers_block_by_func(widget, draw_borders, GINT_TO_POINTER(2));</a>
<a name="ln711">  widget = darktable.gui-&gt;widgets.bottom_border;</a>
<a name="ln712">  g_signal_handlers_block_by_func(widget, draw_borders, GINT_TO_POINTER(3));</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715">gboolean dt_gui_quit_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln716">{</a>
<a name="ln717">  dt_control_quit();</a>
<a name="ln718">  return TRUE;</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721">void dt_gui_store_last_preset(const char *name)</a>
<a name="ln722">{</a>
<a name="ln723">  g_free(darktable.gui-&gt;last_preset);</a>
<a name="ln724">  darktable.gui-&gt;last_preset = g_strdup(name);</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">static gboolean _gui_switch_view_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable,</a>
<a name="ln728">                                                    guint keyval, GdkModifierType modifier, gpointer p)</a>
<a name="ln729">{</a>
<a name="ln730">  int view = GPOINTER_TO_INT(p);</a>
<a name="ln731">  const char *mode = &quot;&quot;;</a>
<a name="ln732">  /* do some setup before switch view*/</a>
<a name="ln733">  switch(view)</a>
<a name="ln734">  {</a>
<a name="ln735">    case DT_GUI_VIEW_SWITCH_TO_TETHERING:</a>
<a name="ln736">      mode = &quot;tethering&quot;;</a>
<a name="ln737">      break;</a>
<a name="ln738"> </a>
<a name="ln739">    case DT_GUI_VIEW_SWITCH_TO_DARKROOM:</a>
<a name="ln740">      mode = &quot;darkroom&quot;;</a>
<a name="ln741">      break;</a>
<a name="ln742"> </a>
<a name="ln743">    case DT_GUI_VIEW_SWITCH_TO_LIGHTTABLE:</a>
<a name="ln744">      mode = &quot;lighttable&quot;;</a>
<a name="ln745">      break;</a>
<a name="ln746"> </a>
<a name="ln747">    case DT_GUI_VIEW_SWITCH_TO_MAP:</a>
<a name="ln748">      mode = &quot;map&quot;;</a>
<a name="ln749">      break;</a>
<a name="ln750"> </a>
<a name="ln751">    case DT_GUI_VIEW_SWITCH_TO_SLIDESHOW:</a>
<a name="ln752">      mode = &quot;slideshow&quot;;</a>
<a name="ln753">      break;</a>
<a name="ln754"> </a>
<a name="ln755">    case DT_GUI_VIEW_SWITCH_TO_PRINT:</a>
<a name="ln756">      mode = &quot;print&quot;;</a>
<a name="ln757">      break;</a>
<a name="ln758">  }</a>
<a name="ln759"> </a>
<a name="ln760">  /* try switch to mode */</a>
<a name="ln761">  if(*mode) dt_ctl_switch_mode_to(mode);</a>
<a name="ln762">  return TRUE;</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">static gboolean quit_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln766">                              GdkModifierType modifier)</a>
<a name="ln767">{</a>
<a name="ln768">  dt_control_quit();</a>
<a name="ln769">  return TRUE; // for the sake of completeness ...</a>
<a name="ln770">}</a>
<a name="ln771"> </a>
<a name="ln772">#ifdef MAC_INTEGRATION</a>
<a name="ln773">#ifdef GTK_TYPE_OSX_APPLICATION</a>
<a name="ln774">static gboolean osx_quit_callback(GtkOSXApplication *OSXapp, gpointer user_data)</a>
<a name="ln775">#else</a>
<a name="ln776">static gboolean osx_quit_callback(GtkosxApplication *OSXapp, gpointer user_data)</a>
<a name="ln777">#endif</a>
<a name="ln778">{</a>
<a name="ln779">  GList *windows, *window;</a>
<a name="ln780">  windows = gtk_window_list_toplevels();</a>
<a name="ln781">  for(window = g_list_first(windows); window != NULL; window = g_list_next(window))</a>
<a name="ln782">    if(gtk_window_get_modal(GTK_WINDOW(window-&gt;data)) &amp;&amp; gtk_widget_get_visible(GTK_WIDGET(window-&gt;data)))</a>
<a name="ln783">      break;</a>
<a name="ln784">  if(window == NULL) dt_control_quit();</a>
<a name="ln785">  g_list_free(windows);</a>
<a name="ln786">  return TRUE;</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">#ifdef GTK_TYPE_OSX_APPLICATION</a>
<a name="ln790">static gboolean osx_openfile_callback(GtkOSXApplication *OSXapp, gchar *path, gpointer user_data)</a>
<a name="ln791">#else</a>
<a name="ln792">static gboolean osx_openfile_callback(GtkosxApplication *OSXapp, gchar *path, gpointer user_data)</a>
<a name="ln793">#endif</a>
<a name="ln794">{</a>
<a name="ln795">  return dt_load_from_string(path, TRUE, NULL) &gt; 0;</a>
<a name="ln796">}</a>
<a name="ln797">#endif</a>
<a name="ln798"> </a>
<a name="ln799">static gboolean configure(GtkWidget *da, GdkEventConfigure *event, gpointer user_data)</a>
<a name="ln800">{</a>
<a name="ln801">  static int oldw = 0;</a>
<a name="ln802">  static int oldh = 0;</a>
<a name="ln803">  // make our selves a properly sized pixmap if our window has been resized</a>
<a name="ln804">  if(oldw != event-&gt;width || oldh != event-&gt;height)</a>
<a name="ln805">  {</a>
<a name="ln806">    // create our new pixmap with the correct size.</a>
<a name="ln807">    cairo_surface_t *tmpsurface</a>
<a name="ln808">        = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, event-&gt;width, event-&gt;height);</a>
<a name="ln809">    // copy the contents of the old pixmap to the new pixmap.  This keeps ugly uninitialized</a>
<a name="ln810">    // pixmaps from being painted upon resize</a>
<a name="ln811">    //     int minw = oldw, minh = oldh;</a>
<a name="ln812">    //     if(event-&gt;width  &lt; minw) minw = event-&gt;width;</a>
<a name="ln813">    //     if(event-&gt;height &lt; minh) minh = event-&gt;height;</a>
<a name="ln814"> </a>
<a name="ln815">    cairo_t *cr = cairo_create(tmpsurface);</a>
<a name="ln816">    cairo_set_source_surface(cr, darktable.gui-&gt;surface, 0, 0);</a>
<a name="ln817">    cairo_paint(cr);</a>
<a name="ln818">    cairo_destroy(cr);</a>
<a name="ln819"> </a>
<a name="ln820">    // we're done with our old pixmap, so we can get rid of it and replace it with our properly-sized one.</a>
<a name="ln821">    cairo_surface_destroy(darktable.gui-&gt;surface);</a>
<a name="ln822">    darktable.gui-&gt;surface = tmpsurface;</a>
<a name="ln823">    dt_colorspaces_set_display_profile(); // maybe we are on another screen now with &gt; 50% of the area</a>
<a name="ln824">  }</a>
<a name="ln825">  oldw = event-&gt;width;</a>
<a name="ln826">  oldh = event-&gt;height;</a>
<a name="ln827"> </a>
<a name="ln828">#ifndef GDK_WINDOWING_QUARTZ</a>
<a name="ln829">  configure_ppd_dpi((dt_gui_gtk_t *) user_data);</a>
<a name="ln830">#endif</a>
<a name="ln831"> </a>
<a name="ln832">  return dt_control_configure(da, event, user_data);</a>
<a name="ln833">}</a>
<a name="ln834"> </a>
<a name="ln835">static gboolean window_configure(GtkWidget *da, GdkEvent *event, gpointer user_data)</a>
<a name="ln836">{</a>
<a name="ln837">  static int oldx = 0;</a>
<a name="ln838">  static int oldy = 0;</a>
<a name="ln839">  if(oldx != event-&gt;configure.x || oldy != event-&gt;configure.y)</a>
<a name="ln840">  {</a>
<a name="ln841">    dt_colorspaces_set_display_profile(); // maybe we are on another screen now with &gt; 50% of the area</a>
<a name="ln842">    oldx = event-&gt;configure.x;</a>
<a name="ln843">    oldy = event-&gt;configure.y;</a>
<a name="ln844">  }</a>
<a name="ln845">  return FALSE;</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848">static gboolean key_pressed_override(GtkWidget *w, GdkEventKey *event, gpointer user_data)</a>
<a name="ln849">{</a>
<a name="ln850">  return dt_control_key_pressed_override(event-&gt;keyval, event-&gt;state &amp; KEY_STATE_MASK);</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853">static gboolean key_pressed(GtkWidget *w, GdkEventKey *event, gpointer user_data)</a>
<a name="ln854">{</a>
<a name="ln855">  return dt_control_key_pressed(gdk_keyval_to_lower(event-&gt;keyval), event-&gt;state &amp; KEY_STATE_MASK);</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">static gboolean key_released(GtkWidget *w, GdkEventKey *event, gpointer user_data)</a>
<a name="ln859">{</a>
<a name="ln860">  return dt_control_key_released(gdk_keyval_to_lower(event-&gt;keyval), event-&gt;state &amp; KEY_STATE_MASK);</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">static gboolean button_pressed(GtkWidget *w, GdkEventButton *event, gpointer user_data)</a>
<a name="ln864">{</a>
<a name="ln865">  double pressure = 1.0;</a>
<a name="ln866">  GdkDevice *device = gdk_event_get_source_device((GdkEvent *)event);</a>
<a name="ln867"> </a>
<a name="ln868">  if(device &amp;&amp; gdk_device_get_source(device) == GDK_SOURCE_PEN)</a>
<a name="ln869">  {</a>
<a name="ln870">    gdk_event_get_axis ((GdkEvent *)event, GDK_AXIS_PRESSURE, &amp;pressure);</a>
<a name="ln871">  }</a>
<a name="ln872">  dt_control_button_pressed(event-&gt;x, event-&gt;y, pressure, event-&gt;button, event-&gt;type, event-&gt;state &amp; 0xf);</a>
<a name="ln873">  gtk_widget_grab_focus(w);</a>
<a name="ln874">  gtk_widget_queue_draw(w);</a>
<a name="ln875">  return FALSE;</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">static gboolean button_released(GtkWidget *w, GdkEventButton *event, gpointer user_data)</a>
<a name="ln879">{</a>
<a name="ln880">  dt_control_button_released(event-&gt;x, event-&gt;y, event-&gt;button, event-&gt;state &amp; 0xf);</a>
<a name="ln881">  gtk_widget_queue_draw(w);</a>
<a name="ln882">  return TRUE;</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885">static gboolean mouse_moved(GtkWidget *w, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln886">{</a>
<a name="ln887">  double pressure = 1.0;</a>
<a name="ln888">  GdkDevice *device = gdk_event_get_source_device((GdkEvent *)event);</a>
<a name="ln889"> </a>
<a name="ln890">  if(device &amp;&amp; gdk_device_get_source(device) == GDK_SOURCE_PEN)</a>
<a name="ln891">  {</a>
<a name="ln892">    gdk_event_get_axis ((GdkEvent *)event, GDK_AXIS_PRESSURE, &amp;pressure);</a>
<a name="ln893">  }</a>
<a name="ln894">  dt_control_mouse_moved(event-&gt;x, event-&gt;y, pressure, event-&gt;state &amp; 0xf);</a>
<a name="ln895">  return FALSE;</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898">static gboolean center_leave(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln899">{</a>
<a name="ln900">  dt_control_mouse_leave();</a>
<a name="ln901">  return TRUE;</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904">static gboolean center_enter(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln905">{</a>
<a name="ln906">  dt_control_mouse_enter();</a>
<a name="ln907">  return TRUE;</a>
<a name="ln908">}</a>
<a name="ln909"> </a>
<a name="ln910">static const char* get_source_name(int pos)</a>
<a name="ln911">{</a>
<a name="ln912">  static const gchar *SOURCE_NAMES[]</a>
<a name="ln913">    = { &quot;GDK_SOURCE_MOUSE&quot;,    &quot;GDK_SOURCE_PEN&quot;,         &quot;GDK_SOURCE_ERASER&quot;,   &quot;GDK_SOURCE_CURSOR&quot;,</a>
<a name="ln914">        &quot;GDK_SOURCE_KEYBOARD&quot;, &quot;GDK_SOURCE_TOUCHSCREEN&quot;, &quot;GDK_SOURCE_TOUCHPAD&quot;, &quot;GDK_SOURCE_TRACKPOINT&quot;,</a>
<a name="ln915">        &quot;GDK_SOURCE_TABLET_PAD&quot; };</a>
<a name="ln916">  if(pos &gt;= G_N_ELEMENTS(SOURCE_NAMES)) return &quot;&lt;UNKNOWN&gt;&quot;;</a>
<a name="ln917">  return SOURCE_NAMES[pos];</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">static const char* get_mode_name(int pos)</a>
<a name="ln921">{</a>
<a name="ln922">  static const gchar *MODE_NAMES[] = { &quot;GDK_MODE_DISABLED&quot;, &quot;GDK_MODE_SCREEN&quot;, &quot;GDK_MODE_WINDOW&quot; };</a>
<a name="ln923">  if(pos &gt;= G_N_ELEMENTS(MODE_NAMES)) return &quot;&lt;UNKNOWN&gt;&quot;;</a>
<a name="ln924">  return MODE_NAMES[pos];</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927">static const char* get_axis_name(int pos)</a>
<a name="ln928">{</a>
<a name="ln929">  static const gchar *AXIS_NAMES[]</a>
<a name="ln930">    = { &quot;GDK_AXIS_IGNORE&quot;,   &quot;GDK_AXIS_X&quot;,      &quot;GDK_AXIS_Y&quot;,     &quot;GDK_AXIS_PRESSURE&quot;,</a>
<a name="ln931">        &quot;GDK_AXIS_XTILT&quot;,    &quot;GDK_AXIS_YTILT&quot;,  &quot;GDK_AXIS_WHEEL&quot;, &quot;GDK_AXIS_DISTANCE&quot;,</a>
<a name="ln932">        &quot;GDK_AXIS_ROTATION&quot;, &quot;GDK_AXIS_SLIDER&quot;, &quot;GDK_AXIS_LAST&quot; };</a>
<a name="ln933">  if(pos &gt;= G_N_ELEMENTS(AXIS_NAMES)) return &quot;&lt;UNKNOWN&gt;&quot;;</a>
<a name="ln934">  return AXIS_NAMES[pos];</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937">int dt_gui_gtk_init(dt_gui_gtk_t *gui)</a>
<a name="ln938">{</a>
<a name="ln939">  /* lets zero mem */</a>
<a name="ln940">  memset(gui, 0, sizeof(dt_gui_gtk_t));</a>
<a name="ln941"> </a>
<a name="ln942">  // force gtk3 to use normal scroll bars instead of the popup thing. they get in the way of controls</a>
<a name="ln943">  // the alternative would be to gtk_scrolled_window_set_overlay_scrolling(..., FALSE); every single widget</a>
<a name="ln944">  // that might have scroll bars</a>
<a name="ln945">  g_setenv(&quot;GTK_OVERLAY_SCROLLING&quot;, &quot;0&quot;, 0);</a>
<a name="ln946"> </a>
<a name="ln947">  // same for ubuntus overlay-scrollbar-gtk3</a>
<a name="ln948">  g_setenv(&quot;LIBOVERLAY_SCROLLBAR&quot;, &quot;0&quot;, 0);</a>
<a name="ln949"> </a>
<a name="ln950">  // unset gtk rc from kde:</a>
<a name="ln951">  char path[PATH_MAX] = { 0 }, datadir[PATH_MAX] = { 0 }, configdir[PATH_MAX] = { 0 };</a>
<a name="ln952">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln953">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln954"> </a>
<a name="ln955">  const gchar *css_theme = dt_conf_get_string(&quot;ui_last/theme&quot;);</a>
<a name="ln956">  if(css_theme)</a>
<a name="ln957">    g_snprintf(gui-&gt;gtkrc, sizeof(gui-&gt;gtkrc), &quot;%s&quot;, css_theme);</a>
<a name="ln958">  else</a>
<a name="ln959">    g_snprintf(gui-&gt;gtkrc, sizeof(gui-&gt;gtkrc), &quot;darktable&quot;);</a>
<a name="ln960"> </a>
<a name="ln961">#ifdef MAC_INTEGRATION</a>
<a name="ln962">#ifdef GTK_TYPE_OSX_APPLICATION</a>
<a name="ln963">  GtkOSXApplication *OSXApp = g_object_new(GTK_TYPE_OSX_APPLICATION, NULL);</a>
<a name="ln964">  gtk_osxapplication_set_menu_bar(</a>
<a name="ln965">      OSXApp, GTK_MENU_SHELL(gtk_menu_bar_new())); // needed for default entries to show up</a>
<a name="ln966">#else</a>
<a name="ln967">  GtkosxApplication *OSXApp = g_object_new(GTKOSX_TYPE_APPLICATION, NULL);</a>
<a name="ln968">  gtkosx_application_set_menu_bar(</a>
<a name="ln969">      OSXApp, GTK_MENU_SHELL(gtk_menu_bar_new())); // needed for default entries to show up</a>
<a name="ln970">#endif</a>
<a name="ln971">  g_signal_connect(G_OBJECT(OSXApp), &quot;NSApplicationBlockTermination&quot;, G_CALLBACK(osx_quit_callback), NULL);</a>
<a name="ln972">  g_signal_connect(G_OBJECT(OSXApp), &quot;NSApplicationOpenFile&quot;, G_CALLBACK(osx_openfile_callback), NULL);</a>
<a name="ln973">#endif</a>
<a name="ln974"> </a>
<a name="ln975">  GtkWidget *widget;</a>
<a name="ln976">  gui-&gt;ui = g_malloc0(sizeof(dt_ui_t));</a>
<a name="ln977">  gui-&gt;surface = NULL;</a>
<a name="ln978">  gui-&gt;center_tooltip = 0;</a>
<a name="ln979">  gui-&gt;grouping = dt_conf_get_bool(&quot;ui_last/grouping&quot;);</a>
<a name="ln980">  gui-&gt;expanded_group_id = -1;</a>
<a name="ln981">  gui-&gt;show_overlays = dt_conf_get_bool(&quot;lighttable/ui/expose_statuses&quot;);</a>
<a name="ln982">  gui-&gt;presets_popup_menu = NULL;</a>
<a name="ln983">  gui-&gt;last_preset = NULL;</a>
<a name="ln984"> </a>
<a name="ln985">  // load the style / theme</a>
<a name="ln986">  GtkSettings *settings = gtk_settings_get_default();</a>
<a name="ln987">  g_object_set(G_OBJECT(settings), &quot;gtk-application-prefer-dark-theme&quot;, TRUE, (gchar *)0);</a>
<a name="ln988">  g_object_set(G_OBJECT(settings), &quot;gtk-theme-name&quot;, &quot;Adwaita&quot;, (gchar *)0);</a>
<a name="ln989">  g_object_unref(settings);</a>
<a name="ln990"> </a>
<a name="ln991">  // Initializing the shortcut groups</a>
<a name="ln992">  darktable.control-&gt;accelerators = gtk_accel_group_new();</a>
<a name="ln993"> </a>
<a name="ln994">  darktable.control-&gt;accelerator_list = NULL;</a>
<a name="ln995"> </a>
<a name="ln996">  // Connecting the callback to update keyboard accels for key_pressed</a>
<a name="ln997">  g_signal_connect(G_OBJECT(gtk_accel_map_get()), &quot;changed&quot;, G_CALLBACK(key_accel_changed), NULL);</a>
<a name="ln998"> </a>
<a name="ln999">  // smooth scrolling must be enabled for Wayland to handle</a>
<a name="ln1000">  // trackpad/touch events, but due to problem reports for Quartz &amp;</a>
<a name="ln1001">  // X11, leave it off in other cases</a>
<a name="ln1002">  gui-&gt;scroll_mask = GDK_SCROLL_MASK;</a>
<a name="ln1003">#ifdef GDK_WINDOWING_WAYLAND</a>
<a name="ln1004">  if (GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) gui-&gt;scroll_mask |= GDK_SMOOTH_SCROLL_MASK;</a>
<a name="ln1005">#endif</a>
<a name="ln1006"> </a>
<a name="ln1007">  // Initializing widgets</a>
<a name="ln1008">  init_widgets(gui);</a>
<a name="ln1009"> </a>
<a name="ln1010">  // Adding the global shortcut group to the main window</a>
<a name="ln1011">  gtk_window_add_accel_group(GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)),</a>
<a name="ln1012">                             darktable.control-&gt;accelerators);</a>
<a name="ln1013"> </a>
<a name="ln1014">  //  dt_gui_background_jobs_init();</a>
<a name="ln1015"> </a>
<a name="ln1016">  /* Have the delete event (window close) end the program */</a>
<a name="ln1017">  snprintf(path, sizeof(path), &quot;%s/icons&quot;, datadir);</a>
<a name="ln1018">  gtk_icon_theme_append_search_path(gtk_icon_theme_get_default(), path);</a>
<a name="ln1019">  snprintf(path, sizeof(path), &quot;%s/icons&quot;, DARKTABLE_SHAREDIR);</a>
<a name="ln1020">  gtk_icon_theme_append_search_path(gtk_icon_theme_get_default(), path);</a>
<a name="ln1021"> </a>
<a name="ln1022">  widget = dt_ui_center(darktable.gui-&gt;ui);</a>
<a name="ln1023"> </a>
<a name="ln1024">  g_signal_connect(G_OBJECT(widget), &quot;key-press-event&quot;, G_CALLBACK(key_pressed), NULL);</a>
<a name="ln1025">  g_signal_connect(G_OBJECT(widget), &quot;configure-event&quot;, G_CALLBACK(configure), gui);</a>
<a name="ln1026">  g_signal_connect(G_OBJECT(widget), &quot;draw&quot;, G_CALLBACK(draw), NULL);</a>
<a name="ln1027">  g_signal_connect(G_OBJECT(widget), &quot;motion-notify-event&quot;, G_CALLBACK(mouse_moved), NULL);</a>
<a name="ln1028">  g_signal_connect(G_OBJECT(widget), &quot;leave-notify-event&quot;, G_CALLBACK(center_leave), NULL);</a>
<a name="ln1029">  g_signal_connect(G_OBJECT(widget), &quot;enter-notify-event&quot;, G_CALLBACK(center_enter), NULL);</a>
<a name="ln1030">  g_signal_connect(G_OBJECT(widget), &quot;button-press-event&quot;, G_CALLBACK(button_pressed), NULL);</a>
<a name="ln1031">  g_signal_connect(G_OBJECT(widget), &quot;button-release-event&quot;, G_CALLBACK(button_released), NULL);</a>
<a name="ln1032">  g_signal_connect(G_OBJECT(widget), &quot;scroll-event&quot;, G_CALLBACK(scrolled), NULL);</a>
<a name="ln1033"> </a>
<a name="ln1034">  // TODO: left, right, top, bottom:</a>
<a name="ln1035">  // leave-notify-event</a>
<a name="ln1036"> </a>
<a name="ln1037">  widget = darktable.gui-&gt;scrollbars.vscrollbar;</a>
<a name="ln1038">  g_signal_connect(G_OBJECT(widget), &quot;value-changed&quot;, G_CALLBACK(scrollbar_changed), NULL);</a>
<a name="ln1039">  g_signal_connect(G_OBJECT(widget), &quot;button-press-event&quot;, G_CALLBACK(scrollbar_press_event), NULL);</a>
<a name="ln1040">  g_signal_connect(G_OBJECT(widget), &quot;button-release-event&quot;, G_CALLBACK(scrollbar_release_event), NULL);</a>
<a name="ln1041"> </a>
<a name="ln1042">  widget = darktable.gui-&gt;scrollbars.hscrollbar;</a>
<a name="ln1043">  g_signal_connect(G_OBJECT(widget), &quot;value-changed&quot;, G_CALLBACK(scrollbar_changed), NULL);</a>
<a name="ln1044">  g_signal_connect(G_OBJECT(widget), &quot;button-press-event&quot;, G_CALLBACK(scrollbar_press_event), NULL);</a>
<a name="ln1045">  g_signal_connect(G_OBJECT(widget), &quot;button-release-event&quot;, G_CALLBACK(scrollbar_release_event), NULL);</a>
<a name="ln1046"> </a>
<a name="ln1047">  widget = darktable.gui-&gt;widgets.left_border;</a>
<a name="ln1048">  g_signal_connect(G_OBJECT(widget), &quot;draw&quot;, G_CALLBACK(draw_borders), GINT_TO_POINTER(0));</a>
<a name="ln1049">  g_signal_connect(G_OBJECT(widget), &quot;button-press-event&quot;, G_CALLBACK(borders_button_pressed),</a>
<a name="ln1050">                   darktable.gui-&gt;ui);</a>
<a name="ln1051">  g_object_set_data(G_OBJECT(widget), &quot;border&quot;, GINT_TO_POINTER(0));</a>
<a name="ln1052">  widget = darktable.gui-&gt;widgets.right_border;</a>
<a name="ln1053">  g_signal_connect(G_OBJECT(widget), &quot;draw&quot;, G_CALLBACK(draw_borders), GINT_TO_POINTER(1));</a>
<a name="ln1054">  g_signal_connect(G_OBJECT(widget), &quot;button-press-event&quot;, G_CALLBACK(borders_button_pressed),</a>
<a name="ln1055">                   darktable.gui-&gt;ui);</a>
<a name="ln1056">  g_object_set_data(G_OBJECT(widget), &quot;border&quot;, GINT_TO_POINTER(1));</a>
<a name="ln1057">  widget = darktable.gui-&gt;widgets.top_border;</a>
<a name="ln1058">  g_signal_connect(G_OBJECT(widget), &quot;draw&quot;, G_CALLBACK(draw_borders), GINT_TO_POINTER(2));</a>
<a name="ln1059">  g_signal_connect(G_OBJECT(widget), &quot;button-press-event&quot;, G_CALLBACK(borders_button_pressed),</a>
<a name="ln1060">                   darktable.gui-&gt;ui);</a>
<a name="ln1061">  g_object_set_data(G_OBJECT(widget), &quot;border&quot;, GINT_TO_POINTER(2));</a>
<a name="ln1062">  widget = darktable.gui-&gt;widgets.bottom_border;</a>
<a name="ln1063">  g_signal_connect(G_OBJECT(widget), &quot;draw&quot;, G_CALLBACK(draw_borders), GINT_TO_POINTER(3));</a>
<a name="ln1064">  g_signal_connect(G_OBJECT(widget), &quot;button-press-event&quot;, G_CALLBACK(borders_button_pressed),</a>
<a name="ln1065">                   darktable.gui-&gt;ui);</a>
<a name="ln1066">  g_object_set_data(G_OBJECT(widget), &quot;border&quot;, GINT_TO_POINTER(3));</a>
<a name="ln1067">  dt_gui_presets_init();</a>
<a name="ln1068"> </a>
<a name="ln1069">  widget = dt_ui_center(darktable.gui-&gt;ui);</a>
<a name="ln1070">  gtk_widget_set_app_paintable(widget, TRUE);</a>
<a name="ln1071"> </a>
<a name="ln1072">  // TODO: make this work as: libgnomeui testgnome.c</a>
<a name="ln1073">  /*  GtkContainer *box = GTK_CONTAINER(darktable.gui-&gt;widgets.plugins_vbox);</a>
<a name="ln1074">  GtkScrolledWindow *swin = GTK_SCROLLED_WINDOW(darktable.gui-&gt;</a>
<a name="ln1075">                                                widgets.right_scrolled_window);</a>
<a name="ln1076">  gtk_container_set_focus_vadjustment (box, gtk_scrolled_window_get_vadjustment (swin));</a>
<a name="ln1077">  */</a>
<a name="ln1078">  dt_colorspaces_set_display_profile();</a>
<a name="ln1079">  // update the profile when the window is moved. resize is already handled in configure()</a>
<a name="ln1080">  widget = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1081">  g_signal_connect(G_OBJECT(widget), &quot;configure-event&quot;, G_CALLBACK(window_configure), NULL);</a>
<a name="ln1082"> </a>
<a name="ln1083">  // register keys for view switching</a>
<a name="ln1084">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;tethering view&quot;), GDK_KEY_t, 0);</a>
<a name="ln1085">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;lighttable view&quot;), GDK_KEY_l, 0);</a>
<a name="ln1086">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;darkroom view&quot;), GDK_KEY_d, 0);</a>
<a name="ln1087">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;map view&quot;), GDK_KEY_m, 0);</a>
<a name="ln1088">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;slideshow view&quot;), GDK_KEY_s, 0);</a>
<a name="ln1089">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;print view&quot;), GDK_KEY_p, 0);</a>
<a name="ln1090"> </a>
<a name="ln1091">  dt_accel_connect_global(&quot;tethering view&quot;,</a>
<a name="ln1092">                          g_cclosure_new(G_CALLBACK(_gui_switch_view_key_accel_callback),</a>
<a name="ln1093">                                         GINT_TO_POINTER(DT_GUI_VIEW_SWITCH_TO_TETHERING), NULL));</a>
<a name="ln1094">  dt_accel_connect_global(&quot;lighttable view&quot;,</a>
<a name="ln1095">                          g_cclosure_new(G_CALLBACK(_gui_switch_view_key_accel_callback),</a>
<a name="ln1096">                                         GINT_TO_POINTER(DT_GUI_VIEW_SWITCH_TO_LIGHTTABLE), NULL));</a>
<a name="ln1097">  dt_accel_connect_global(&quot;darkroom view&quot;,</a>
<a name="ln1098">                          g_cclosure_new(G_CALLBACK(_gui_switch_view_key_accel_callback),</a>
<a name="ln1099">                                         GINT_TO_POINTER(DT_GUI_VIEW_SWITCH_TO_DARKROOM), NULL));</a>
<a name="ln1100">  dt_accel_connect_global(&quot;map view&quot;, g_cclosure_new(G_CALLBACK(_gui_switch_view_key_accel_callback),</a>
<a name="ln1101">                                                     GINT_TO_POINTER(DT_GUI_VIEW_SWITCH_TO_MAP), NULL));</a>
<a name="ln1102">  dt_accel_connect_global(&quot;slideshow view&quot;,</a>
<a name="ln1103">                          g_cclosure_new(G_CALLBACK(_gui_switch_view_key_accel_callback),</a>
<a name="ln1104">                                         GINT_TO_POINTER(DT_GUI_VIEW_SWITCH_TO_SLIDESHOW), NULL));</a>
<a name="ln1105">  dt_accel_connect_global(&quot;print view&quot;, g_cclosure_new(G_CALLBACK(_gui_switch_view_key_accel_callback),</a>
<a name="ln1106">                                                     GINT_TO_POINTER(DT_GUI_VIEW_SWITCH_TO_PRINT), NULL));</a>
<a name="ln1107"> </a>
<a name="ln1108">  // register_keys for applying styles</a>
<a name="ln1109">  init_styles_key_accels();</a>
<a name="ln1110">  connect_styles_key_accels();</a>
<a name="ln1111">  // register ctrl-q to quit:</a>
<a name="ln1112">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;quit&quot;), GDK_KEY_q, GDK_CONTROL_MASK);</a>
<a name="ln1113"> </a>
<a name="ln1114">  dt_accel_connect_global(&quot;quit&quot;, g_cclosure_new(G_CALLBACK(quit_callback), NULL, NULL));</a>
<a name="ln1115"> </a>
<a name="ln1116">  // Full-screen accelerators</a>
<a name="ln1117">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;toggle fullscreen&quot;), GDK_KEY_F11, 0);</a>
<a name="ln1118">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;leave fullscreen&quot;), GDK_KEY_Escape, 0);</a>
<a name="ln1119"> </a>
<a name="ln1120">  dt_accel_connect_global(&quot;toggle fullscreen&quot;, g_cclosure_new(G_CALLBACK(fullscreen_key_accel_callback),</a>
<a name="ln1121">                                                              GINT_TO_POINTER(1), NULL));</a>
<a name="ln1122">  dt_accel_connect_global(&quot;leave fullscreen&quot;, g_cclosure_new(G_CALLBACK(fullscreen_key_accel_callback),</a>
<a name="ln1123">                                                             GINT_TO_POINTER(0), NULL));</a>
<a name="ln1124"> </a>
<a name="ln1125">  // Side-border hide/show</a>
<a name="ln1126">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;toggle side borders&quot;), GDK_KEY_Tab, 0);</a>
<a name="ln1127"> </a>
<a name="ln1128">  // toggle view of header</a>
<a name="ln1129">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;toggle header&quot;), GDK_KEY_h, GDK_CONTROL_MASK);</a>
<a name="ln1130"> </a>
<a name="ln1131">  // View-switch</a>
<a name="ln1132">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;switch view&quot;), GDK_KEY_period, 0);</a>
<a name="ln1133"> </a>
<a name="ln1134">  dt_accel_connect_global(&quot;switch view&quot;,</a>
<a name="ln1135">                          g_cclosure_new(G_CALLBACK(view_switch_key_accel_callback), NULL, NULL));</a>
<a name="ln1136"> </a>
<a name="ln1137">  // Global zoom in &amp; zoom out</a>
<a name="ln1138">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;zoom in&quot;), GDK_KEY_plus, GDK_CONTROL_MASK);</a>
<a name="ln1139">  dt_accel_register_global(NC_(&quot;accel&quot;, &quot;zoom out&quot;), GDK_KEY_minus, GDK_CONTROL_MASK);</a>
<a name="ln1140"> </a>
<a name="ln1141">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1142"> </a>
<a name="ln1143">  // load theme</a>
<a name="ln1144">  dt_gui_load_theme(gui-&gt;gtkrc);</a>
<a name="ln1145"> </a>
<a name="ln1146">  // let's try to support pressure sensitive input devices like tablets for mask drawing</a>
<a name="ln1147">  dt_print(DT_DEBUG_INPUT, &quot;[input device] Input devices found:\n\n&quot;);</a>
<a name="ln1148"> </a>
<a name="ln1149">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln1150">  GList *input_devices</a>
<a name="ln1151">      = gdk_seat_get_slaves(gdk_display_get_default_seat(gdk_display_get_default()), GDK_SEAT_CAPABILITY_ALL);</a>
<a name="ln1152">#else</a>
<a name="ln1153">  GList *input_devices = gdk_device_manager_list_devices(gdk_display_get_device_manager(gdk_display_get_default()),</a>
<a name="ln1154">                                                         GDK_DEVICE_TYPE_MASTER);</a>
<a name="ln1155">#endif</a>
<a name="ln1156">  for(GList *l = input_devices; l != NULL; l = g_list_next(l))</a>
<a name="ln1157">  {</a>
<a name="ln1158">    GdkDevice *device = (GdkDevice *)l-&gt;data;</a>
<a name="ln1159">    GdkInputSource source = gdk_device_get_source(device);</a>
<a name="ln1160">    gint n_axes = (source == GDK_SOURCE_KEYBOARD ? 0 : gdk_device_get_n_axes(device));</a>
<a name="ln1161"> </a>
<a name="ln1162">    dt_print(DT_DEBUG_INPUT, &quot;%s (%s), source: %s, mode: %s, %d axes, %d keys\n&quot;, gdk_device_get_name(device),</a>
<a name="ln1163">             (source != GDK_SOURCE_KEYBOARD) &amp;&amp; gdk_device_get_has_cursor(device) ? &quot;with cursor&quot; : &quot;no cursor&quot;,</a>
<a name="ln1164">             get_source_name(source), get_mode_name(gdk_device_get_mode(device)), n_axes,</a>
<a name="ln1165">             source != GDK_SOURCE_KEYBOARD ? gdk_device_get_n_keys(device) : 0);</a>
<a name="ln1166"> </a>
<a name="ln1167">    for(int i = 0; i &lt; n_axes; i++)</a>
<a name="ln1168">    {</a>
<a name="ln1169">      dt_print(DT_DEBUG_INPUT, &quot;  %s\n&quot;, get_axis_name(gdk_device_get_axis_use(device, i)));</a>
<a name="ln1170">    }</a>
<a name="ln1171">    dt_print(DT_DEBUG_INPUT, &quot;\n&quot;);</a>
<a name="ln1172">  }</a>
<a name="ln1173">  g_list_free(input_devices);</a>
<a name="ln1174"> </a>
<a name="ln1175">  // finally set the cursor to be the default.</a>
<a name="ln1176">  // for some reason this is needed on some systems to pick up the correctly themed cursor</a>
<a name="ln1177">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln1178"> </a>
<a name="ln1179">  return 0;</a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182">void dt_gui_gtk_run(dt_gui_gtk_t *gui)</a>
<a name="ln1183">{</a>
<a name="ln1184">  GtkWidget *widget = dt_ui_center(darktable.gui-&gt;ui);</a>
<a name="ln1185">  GtkAllocation allocation;</a>
<a name="ln1186">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1187">  darktable.gui-&gt;surface</a>
<a name="ln1188">      = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, allocation.width, allocation.height);</a>
<a name="ln1189">  // need to pre-configure views to avoid crash caused by draw coming before configure-event</a>
<a name="ln1190">  darktable.control-&gt;tabborder = 8;</a>
<a name="ln1191">  int tb = darktable.control-&gt;tabborder;</a>
<a name="ln1192">  dt_view_manager_configure(darktable.view_manager, allocation.width - 2 * tb, allocation.height - 2 * tb);</a>
<a name="ln1193">#ifdef MAC_INTEGRATION</a>
<a name="ln1194">#ifdef GTK_TYPE_OSX_APPLICATION</a>
<a name="ln1195">  gtk_osxapplication_ready(g_object_new(GTK_TYPE_OSX_APPLICATION, NULL));</a>
<a name="ln1196">#else</a>
<a name="ln1197">  gtkosx_application_ready(g_object_new(GTKOSX_TYPE_APPLICATION, NULL));</a>
<a name="ln1198">#endif</a>
<a name="ln1199">#endif</a>
<a name="ln1200">  /* start the event loop */</a>
<a name="ln1201">  gtk_main();</a>
<a name="ln1202"> </a>
<a name="ln1203">  dt_cleanup();</a>
<a name="ln1204">}</a>
<a name="ln1205"> </a>
<a name="ln1206">static void configure_ppd_dpi(dt_gui_gtk_t *gui)</a>
<a name="ln1207">{</a>
<a name="ln1208">  GtkWidget *widget = gui-&gt;ui-&gt;main_window;</a>
<a name="ln1209"> </a>
<a name="ln1210">  // check if in HiDPI mode</a>
<a name="ln1211">#if (CAIRO_VERSION &gt;= CAIRO_VERSION_ENCODE(1, 13, 1))</a>
<a name="ln1212">  float screen_ppd_overwrite = dt_conf_get_float(&quot;screen_ppd_overwrite&quot;);</a>
<a name="ln1213">  if(screen_ppd_overwrite &gt; 0.0)</a>
<a name="ln1214">  {</a>
<a name="ln1215">    gui-&gt;ppd = screen_ppd_overwrite;</a>
<a name="ln1216">    dt_print(DT_DEBUG_CONTROL, &quot;[HiDPI] setting ppd to %f as specified in the configuration file\n&quot;, screen_ppd_overwrite);</a>
<a name="ln1217">  }</a>
<a name="ln1218">  else</a>
<a name="ln1219">  {</a>
<a name="ln1220">#ifndef GDK_WINDOWING_QUARTZ</a>
<a name="ln1221">    gui-&gt;ppd = gtk_widget_get_scale_factor(widget);</a>
<a name="ln1222">#else</a>
<a name="ln1223">    gui-&gt;ppd = dt_osx_get_ppd();</a>
<a name="ln1224">#endif</a>
<a name="ln1225">    if(gui-&gt;ppd &lt; 0.0)</a>
<a name="ln1226">    {</a>
<a name="ln1227">      gui-&gt;ppd = 1.0;</a>
<a name="ln1228">      dt_print(DT_DEBUG_CONTROL, &quot;[HiDPI] can't detect screen settings, switching off\n&quot;);</a>
<a name="ln1229">    }</a>
<a name="ln1230">    else</a>
<a name="ln1231">      dt_print(DT_DEBUG_CONTROL, &quot;[HiDPI] setting ppd to %f\n&quot;, gui-&gt;ppd);</a>
<a name="ln1232">  }</a>
<a name="ln1233">#else</a>
<a name="ln1234">  gui-&gt;ppd = 1.0;</a>
<a name="ln1235">#endif</a>
<a name="ln1236">  // get the screen resolution</a>
<a name="ln1237">  float screen_dpi_overwrite = dt_conf_get_float(&quot;screen_dpi_overwrite&quot;);</a>
<a name="ln1238">  if(screen_dpi_overwrite &gt; 0.0)</a>
<a name="ln1239">  {</a>
<a name="ln1240">    gui-&gt;dpi = screen_dpi_overwrite;</a>
<a name="ln1241">    gdk_screen_set_resolution(gtk_widget_get_screen(widget), screen_dpi_overwrite);</a>
<a name="ln1242">    dt_print(DT_DEBUG_CONTROL, &quot;[screen resolution] setting the screen resolution to %f dpi as specified in &quot;</a>
<a name="ln1243">                               &quot;the configuration file\n&quot;,</a>
<a name="ln1244">             screen_dpi_overwrite);</a>
<a name="ln1245">  }</a>
<a name="ln1246">  else</a>
<a name="ln1247">  {</a>
<a name="ln1248">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1249">    dt_osx_autoset_dpi(widget);</a>
<a name="ln1250">#endif</a>
<a name="ln1251">    gui-&gt;dpi = gdk_screen_get_resolution(gtk_widget_get_screen(widget));</a>
<a name="ln1252">    if(gui-&gt;dpi &lt; 0.0)</a>
<a name="ln1253">    {</a>
<a name="ln1254">      gui-&gt;dpi = 96.0;</a>
<a name="ln1255">      gdk_screen_set_resolution(gtk_widget_get_screen(widget), 96.0);</a>
<a name="ln1256">      dt_print(DT_DEBUG_CONTROL, &quot;[screen resolution] setting the screen resolution to the default 96 dpi\n&quot;);</a>
<a name="ln1257">    }</a>
<a name="ln1258">    else</a>
<a name="ln1259">      dt_print(DT_DEBUG_CONTROL, &quot;[screen resolution] setting the screen resolution to %f dpi\n&quot;, gui-&gt;dpi);</a>
<a name="ln1260">  }</a>
<a name="ln1261">  gui-&gt;dpi_factor</a>
<a name="ln1262">      = gui-&gt;dpi / 96; // according to man xrandr and the docs of gdk_screen_set_resolution 96 is the default</a>
<a name="ln1263">}</a>
<a name="ln1264"> </a>
<a name="ln1265">static gboolean _focus_in_out_event(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1266">{</a>
<a name="ln1267">  gtk_window_set_urgency_hint(GTK_WINDOW(user_data), FALSE);</a>
<a name="ln1268">  return FALSE;</a>
<a name="ln1269">}</a>
<a name="ln1270"> </a>
<a name="ln1271">static void init_widgets(dt_gui_gtk_t *gui)</a>
<a name="ln1272">{</a>
<a name="ln1273"> </a>
<a name="ln1274">  GtkWidget *container;</a>
<a name="ln1275">  GtkWidget *widget;</a>
<a name="ln1276"> </a>
<a name="ln1277">  // Creating the main window</a>
<a name="ln1278">  widget = gtk_window_new(GTK_WINDOW_TOPLEVEL);</a>
<a name="ln1279">  gtk_widget_set_name(widget, &quot;main_window&quot;);</a>
<a name="ln1280">  gui-&gt;ui-&gt;main_window = widget;</a>
<a name="ln1281"> </a>
<a name="ln1282">  configure_ppd_dpi(gui);</a>
<a name="ln1283"> </a>
<a name="ln1284">  // set constant width from conf key</a>
<a name="ln1285">  int panel_width = dt_conf_get_int(&quot;panel_width&quot;);</a>
<a name="ln1286">  if(panel_width &lt; 20 || panel_width &gt; 1000)</a>
<a name="ln1287">  {</a>
<a name="ln1288">    // fix for unset/insane values.</a>
<a name="ln1289">    panel_width = 300 * gui-&gt;dpi_factor;</a>
<a name="ln1290">    dt_conf_set_int(&quot;panel_width&quot;, panel_width);</a>
<a name="ln1291">  }</a>
<a name="ln1292"> </a>
<a name="ln1293">  gtk_window_set_default_size(GTK_WINDOW(widget), DT_PIXEL_APPLY_DPI(900), DT_PIXEL_APPLY_DPI(500));</a>
<a name="ln1294"> </a>
<a name="ln1295">  gtk_window_set_icon_name(GTK_WINDOW(widget), &quot;darktable&quot;);</a>
<a name="ln1296">  gtk_window_set_title(GTK_WINDOW(widget), &quot;darktable&quot;);</a>
<a name="ln1297"> </a>
<a name="ln1298">  g_signal_connect(G_OBJECT(widget), &quot;delete_event&quot;, G_CALLBACK(dt_gui_quit_callback), NULL);</a>
<a name="ln1299">  g_signal_connect(G_OBJECT(widget), &quot;key-press-event&quot;, G_CALLBACK(key_pressed_override), NULL);</a>
<a name="ln1300">  g_signal_connect(G_OBJECT(widget), &quot;key-release-event&quot;, G_CALLBACK(key_released), NULL);</a>
<a name="ln1301">  g_signal_connect(G_OBJECT(widget), &quot;focus-in-event&quot;, G_CALLBACK(_focus_in_out_event), widget);</a>
<a name="ln1302">  g_signal_connect(G_OBJECT(widget), &quot;focus-out-event&quot;, G_CALLBACK(_focus_in_out_event), widget);</a>
<a name="ln1303"> </a>
<a name="ln1304">  container = widget;</a>
<a name="ln1305"> </a>
<a name="ln1306">  // Adding the outermost vbox</a>
<a name="ln1307">  widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1308">  gtk_container_add(GTK_CONTAINER(container), widget);</a>
<a name="ln1309">  gtk_widget_show(widget);</a>
<a name="ln1310"> </a>
<a name="ln1311">  /* connect to signal redraw all */</a>
<a name="ln1312">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_CONTROL_REDRAW_ALL,</a>
<a name="ln1313">                            G_CALLBACK(_ui_widget_redraw_callback), gui-&gt;ui-&gt;main_window);</a>
<a name="ln1314"> </a>
<a name="ln1315">  container = widget;</a>
<a name="ln1316"> </a>
<a name="ln1317">  // Initializing the top border</a>
<a name="ln1318">  widget = gtk_drawing_area_new();</a>
<a name="ln1319">  gui-&gt;widgets.top_border = widget;</a>
<a name="ln1320">  gtk_box_pack_start(GTK_BOX(container), widget, FALSE, TRUE, 0);</a>
<a name="ln1321">  gtk_widget_set_size_request(widget, -1, DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln1322">  gtk_widget_set_app_paintable(widget, TRUE);</a>
<a name="ln1323">  gtk_widget_set_events(widget, GDK_EXPOSURE_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln1324">                                | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK | GDK_STRUCTURE_MASK</a>
<a name="ln1325">                                | GDK_SCROLL_MASK);</a>
<a name="ln1326">  gtk_widget_show(widget);</a>
<a name="ln1327"> </a>
<a name="ln1328">  // Initializing the main table</a>
<a name="ln1329">  init_main_table(container);</a>
<a name="ln1330"> </a>
<a name="ln1331">  // Initializing the bottom border</a>
<a name="ln1332">  widget = gtk_drawing_area_new();</a>
<a name="ln1333">  gui-&gt;widgets.bottom_border = widget;</a>
<a name="ln1334">  gtk_box_pack_start(GTK_BOX(container), widget, FALSE, TRUE, 0);</a>
<a name="ln1335">  gtk_widget_set_size_request(widget, -1, DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln1336">  gtk_widget_set_app_paintable(widget, TRUE);</a>
<a name="ln1337">  gtk_widget_set_events(widget, GDK_EXPOSURE_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln1338">                                | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK | GDK_STRUCTURE_MASK</a>
<a name="ln1339">                                | GDK_SCROLL_MASK);</a>
<a name="ln1340">  gtk_widget_show(widget);</a>
<a name="ln1341"> </a>
<a name="ln1342">  // Showing everything</a>
<a name="ln1343">  gtk_widget_show_all(dt_ui_main_window(gui-&gt;ui));</a>
<a name="ln1344"> </a>
<a name="ln1345">  /* hide panels depending on last ui state */</a>
<a name="ln1346">  for(int k = 0; k &lt; DT_UI_PANEL_SIZE; k++)</a>
<a name="ln1347">  {</a>
<a name="ln1348">    /* prevent show all */</a>
<a name="ln1349">    gtk_widget_set_no_show_all(GTK_WIDGET(gui-&gt;ui-&gt;containers[k]), TRUE);</a>
<a name="ln1350"> </a>
<a name="ln1351">    /* check last visible state of panel */</a>
<a name="ln1352">    char key[512];</a>
<a name="ln1353">    g_snprintf(key, sizeof(key), &quot;ui_last/%s/visible&quot;, _ui_panel_config_names[k]);</a>
<a name="ln1354"> </a>
<a name="ln1355">    /* if no key, lets default to TRUE*/</a>
<a name="ln1356">    if(!dt_conf_key_exists(key)) dt_conf_set_bool(key, TRUE);</a>
<a name="ln1357"> </a>
<a name="ln1358">    if(!dt_conf_get_bool(key)) gtk_widget_set_visible(gui-&gt;ui-&gt;panels[k], FALSE);</a>
<a name="ln1359">  }</a>
<a name="ln1360"> </a>
<a name="ln1361">  gtk_widget_set_visible(gui-&gt;scrollbars.hscrollbar, FALSE);</a>
<a name="ln1362">  gtk_widget_set_visible(gui-&gt;scrollbars.vscrollbar, FALSE);</a>
<a name="ln1363">}</a>
<a name="ln1364"> </a>
<a name="ln1365">static void init_main_table(GtkWidget *container)</a>
<a name="ln1366">{</a>
<a name="ln1367">  GtkWidget *widget;</a>
<a name="ln1368"> </a>
<a name="ln1369">  // Creating the table</a>
<a name="ln1370">  widget = gtk_grid_new();</a>
<a name="ln1371">  gtk_box_pack_start(GTK_BOX(container), widget, TRUE, TRUE, 0);</a>
<a name="ln1372">  gtk_widget_show(widget);</a>
<a name="ln1373"> </a>
<a name="ln1374">  container = widget;</a>
<a name="ln1375"> </a>
<a name="ln1376">  // Adding the left border</a>
<a name="ln1377">  widget = gtk_drawing_area_new();</a>
<a name="ln1378">  darktable.gui-&gt;widgets.left_border = widget;</a>
<a name="ln1379"> </a>
<a name="ln1380">  gtk_widget_set_size_request(widget, DT_PIXEL_APPLY_DPI(10), -1);</a>
<a name="ln1381">  gtk_widget_set_app_paintable(widget, TRUE);</a>
<a name="ln1382">  gtk_widget_set_events(widget, GDK_EXPOSURE_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln1383">                                | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK | GDK_STRUCTURE_MASK</a>
<a name="ln1384">                                | GDK_SCROLL_MASK);</a>
<a name="ln1385">  gtk_grid_attach(GTK_GRID(container), widget, 0, 0, 1, 2);</a>
<a name="ln1386">  gtk_widget_show(widget);</a>
<a name="ln1387"> </a>
<a name="ln1388">  // Adding the right border</a>
<a name="ln1389">  widget = gtk_drawing_area_new();</a>
<a name="ln1390">  darktable.gui-&gt;widgets.right_border = widget;</a>
<a name="ln1391"> </a>
<a name="ln1392">  gtk_widget_set_size_request(widget, DT_PIXEL_APPLY_DPI(10), -1);</a>
<a name="ln1393">  gtk_widget_set_app_paintable(widget, TRUE);</a>
<a name="ln1394">  gtk_widget_set_events(widget, GDK_EXPOSURE_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln1395">                                | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK | GDK_STRUCTURE_MASK</a>
<a name="ln1396">                                | GDK_SCROLL_MASK);</a>
<a name="ln1397">  gtk_grid_attach(GTK_GRID(container), widget, 4, 0, 1, 2);</a>
<a name="ln1398">  gtk_widget_show(widget);</a>
<a name="ln1399"> </a>
<a name="ln1400">  /* initialize the top container */</a>
<a name="ln1401">  _ui_init_panel_top(darktable.gui-&gt;ui, container);</a>
<a name="ln1402"> </a>
<a name="ln1403">  /*</a>
<a name="ln1404">   * initialize the center top/center/bottom</a>
<a name="ln1405">   */</a>
<a name="ln1406">  widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1407">  gtk_widget_set_hexpand(GTK_WIDGET(widget), TRUE);</a>
<a name="ln1408">  gtk_widget_set_vexpand(GTK_WIDGET(widget), TRUE);</a>
<a name="ln1409">  gtk_grid_attach(GTK_GRID(container), widget, 2, 1, 1, 1);</a>
<a name="ln1410"> </a>
<a name="ln1411">  /* initiialize the center top panel */</a>
<a name="ln1412">  _ui_init_panel_center_top(darktable.gui-&gt;ui, widget);</a>
<a name="ln1413"> </a>
<a name="ln1414">  GtkWidget *centergrid = gtk_grid_new();</a>
<a name="ln1415">  gtk_box_pack_start(GTK_BOX(widget), centergrid, TRUE, TRUE, 0);</a>
<a name="ln1416"> </a>
<a name="ln1417">  /* setup center drawing area */</a>
<a name="ln1418">  GtkWidget *cda = gtk_drawing_area_new();</a>
<a name="ln1419">  gtk_widget_set_size_request(cda, DT_PIXEL_APPLY_DPI(50), DT_PIXEL_APPLY_DPI(200));</a>
<a name="ln1420">  gtk_widget_set_hexpand(cda, TRUE);</a>
<a name="ln1421">  gtk_widget_set_vexpand(cda, TRUE);</a>
<a name="ln1422">  gtk_widget_set_margin_start(cda, DT_PIXEL_APPLY_DPI(6));</a>
<a name="ln1423">  gtk_widget_set_margin_end(cda, DT_PIXEL_APPLY_DPI(6));</a>
<a name="ln1424">  gtk_widget_set_margin_top(cda, DT_PIXEL_APPLY_DPI(6));</a>
<a name="ln1425">  gtk_widget_set_margin_bottom(cda, DT_PIXEL_APPLY_DPI(6));</a>
<a name="ln1426">  gtk_widget_set_app_paintable(cda, TRUE);</a>
<a name="ln1427">  gtk_widget_set_events(cda, GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK</a>
<a name="ln1428">                             | GDK_BUTTON_RELEASE_MASK | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK</a>
<a name="ln1429">                             | darktable.gui-&gt;scroll_mask);</a>
<a name="ln1430">  gtk_widget_set_can_focus(cda, TRUE);</a>
<a name="ln1431">  gtk_widget_set_visible(cda, TRUE);</a>
<a name="ln1432"> </a>
<a name="ln1433">  gtk_grid_attach(GTK_GRID(centergrid), cda, 0, 0, 1, 1);</a>
<a name="ln1434">  darktable.gui-&gt;ui-&gt;center = cda;</a>
<a name="ln1435"> </a>
<a name="ln1436">  /* center should redraw when signal redraw center is raised*/</a>
<a name="ln1437">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_CONTROL_REDRAW_CENTER,</a>
<a name="ln1438">                            G_CALLBACK(_ui_widget_redraw_callback), darktable.gui-&gt;ui-&gt;center);</a>
<a name="ln1439"> </a>
<a name="ln1440">  // Adding the scrollbars</a>
<a name="ln1441">  GtkWidget *vscrollBar = gtk_scrollbar_new(GTK_ORIENTATION_VERTICAL, NULL);</a>
<a name="ln1442">  GtkWidget *hscrollBar = gtk_scrollbar_new(GTK_ORIENTATION_HORIZONTAL, NULL);</a>
<a name="ln1443"> </a>
<a name="ln1444">  gtk_grid_attach_next_to(GTK_GRID(centergrid), vscrollBar, cda, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1445">  gtk_grid_attach_next_to(GTK_GRID(centergrid), hscrollBar, cda, GTK_POS_BOTTOM, 1, 1);</a>
<a name="ln1446"> </a>
<a name="ln1447">  darktable.gui-&gt;scrollbars.vscrollbar = vscrollBar;</a>
<a name="ln1448">  darktable.gui-&gt;scrollbars.hscrollbar = hscrollBar;</a>
<a name="ln1449"> </a>
<a name="ln1450">  /* initialize the center bottom panel */</a>
<a name="ln1451">  _ui_init_panel_center_bottom(darktable.gui-&gt;ui, widget);</a>
<a name="ln1452"> </a>
<a name="ln1453">  /* initialize the bottom panel */</a>
<a name="ln1454">  _ui_init_panel_bottom(darktable.gui-&gt;ui, container);</a>
<a name="ln1455"> </a>
<a name="ln1456">  /* initialize  left panel */</a>
<a name="ln1457">  _ui_init_panel_left(darktable.gui-&gt;ui, container);</a>
<a name="ln1458"> </a>
<a name="ln1459">  /* initialize right panel */</a>
<a name="ln1460">  _ui_init_panel_right(darktable.gui-&gt;ui, container);</a>
<a name="ln1461">}</a>
<a name="ln1462"> </a>
<a name="ln1463">GtkBox *dt_ui_get_container(struct dt_ui_t *ui, const dt_ui_container_t c)</a>
<a name="ln1464">{</a>
<a name="ln1465">  return GTK_BOX(ui-&gt;containers[c]);</a>
<a name="ln1466">}</a>
<a name="ln1467">void dt_ui_container_add_widget(dt_ui_t *ui, const dt_ui_container_t c, GtkWidget *w)</a>
<a name="ln1468">{</a>
<a name="ln1469">  //  if(!GTK_IS_BOX(ui-&gt;containers[c])) return;</a>
<a name="ln1470">  g_return_if_fail(GTK_IS_BOX(ui-&gt;containers[c]));</a>
<a name="ln1471">  switch(c)</a>
<a name="ln1472">  {</a>
<a name="ln1473">    /* if box is right lets pack at end for nicer alignment */</a>
<a name="ln1474">    case DT_UI_CONTAINER_PANEL_TOP_RIGHT:</a>
<a name="ln1475">    case DT_UI_CONTAINER_PANEL_CENTER_TOP_RIGHT:</a>
<a name="ln1476">    case DT_UI_CONTAINER_PANEL_CENTER_BOTTOM_RIGHT:</a>
<a name="ln1477">      gtk_box_pack_end(GTK_BOX(ui-&gt;containers[c]), w, FALSE, FALSE, 2);</a>
<a name="ln1478">      break;</a>
<a name="ln1479"> </a>
<a name="ln1480">    /* if box is center we want it to fill as much as it can */</a>
<a name="ln1481">    case DT_UI_CONTAINER_PANEL_TOP_CENTER:</a>
<a name="ln1482">    case DT_UI_CONTAINER_PANEL_CENTER_TOP_CENTER:</a>
<a name="ln1483">    case DT_UI_CONTAINER_PANEL_CENTER_BOTTOM_CENTER:</a>
<a name="ln1484">    case DT_UI_CONTAINER_PANEL_BOTTOM:</a>
<a name="ln1485">      gtk_box_pack_start(GTK_BOX(ui-&gt;containers[c]), w, TRUE, TRUE, 2);</a>
<a name="ln1486">      break;</a>
<a name="ln1487"> </a>
<a name="ln1488">    default:</a>
<a name="ln1489">    {</a>
<a name="ln1490">      gtk_box_pack_start(GTK_BOX(ui-&gt;containers[c]), w, FALSE, FALSE, 2);</a>
<a name="ln1491">    }</a>
<a name="ln1492">    break;</a>
<a name="ln1493">  }</a>
<a name="ln1494">  gtk_widget_show_all(w);</a>
<a name="ln1495">}</a>
<a name="ln1496"> </a>
<a name="ln1497">void dt_ui_container_focus_widget(dt_ui_t *ui, const dt_ui_container_t c, GtkWidget *w)</a>
<a name="ln1498">{</a>
<a name="ln1499">  g_return_if_fail(GTK_IS_CONTAINER(ui-&gt;containers[c]));</a>
<a name="ln1500"> </a>
<a name="ln1501">  if(GTK_WIDGET(ui-&gt;containers[c]) != gtk_widget_get_parent(w)) return;</a>
<a name="ln1502"> </a>
<a name="ln1503">  gtk_container_set_focus_child(GTK_CONTAINER(ui-&gt;containers[c]), w);</a>
<a name="ln1504">  gtk_widget_queue_draw(ui-&gt;containers[c]);</a>
<a name="ln1505">}</a>
<a name="ln1506"> </a>
<a name="ln1507">void dt_ui_container_foreach(struct dt_ui_t *ui, const dt_ui_container_t c, GtkCallback callback)</a>
<a name="ln1508">{</a>
<a name="ln1509">  g_return_if_fail(GTK_IS_CONTAINER(ui-&gt;containers[c]));</a>
<a name="ln1510">  gtk_container_foreach(GTK_CONTAINER(ui-&gt;containers[c]), callback, (gpointer)ui-&gt;containers[c]);</a>
<a name="ln1511">}</a>
<a name="ln1512">void dt_ui_container_destroy_children(struct dt_ui_t *ui, const dt_ui_container_t c)</a>
<a name="ln1513">{</a>
<a name="ln1514">  g_return_if_fail(GTK_IS_CONTAINER(ui-&gt;containers[c]));</a>
<a name="ln1515">  gtk_container_foreach(GTK_CONTAINER(ui-&gt;containers[c]), (GtkCallback)gtk_widget_destroy, (gpointer)c);</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518">void dt_ui_toggle_panels_visibility(struct dt_ui_t *ui)</a>
<a name="ln1519">{</a>
<a name="ln1520">  char key[512];</a>
<a name="ln1521">  const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln1522">  g_snprintf(key, sizeof(key), &quot;%s/ui/panel_collaps_state&quot;, cv-&gt;module_name);</a>
<a name="ln1523">  uint32_t state = dt_conf_get_int(key);</a>
<a name="ln1524"> </a>
<a name="ln1525">  if(state)</a>
<a name="ln1526">  {</a>
<a name="ln1527">    /* restore previous panel view states */</a>
<a name="ln1528">    for(int k = 0; k &lt; DT_UI_PANEL_SIZE; k++) dt_ui_panel_show(ui, k, (state &gt;&gt; k) &amp; 1, TRUE);</a>
<a name="ln1529"> </a>
<a name="ln1530">    /* reset state */</a>
<a name="ln1531">    state = 0;</a>
<a name="ln1532">  }</a>
<a name="ln1533">  else</a>
<a name="ln1534">  {</a>
<a name="ln1535">    /* store current panel view state */</a>
<a name="ln1536">    for(int k = 0; k &lt; DT_UI_PANEL_SIZE; k++) state |= (uint32_t)(dt_ui_panel_visible(ui, k)) &lt;&lt; k;</a>
<a name="ln1537"> </a>
<a name="ln1538">    /* hide all panels */</a>
<a name="ln1539">    for(int k = 0; k &lt; DT_UI_PANEL_SIZE; k++) dt_ui_panel_show(ui, k, FALSE, TRUE);</a>
<a name="ln1540">  }</a>
<a name="ln1541"> </a>
<a name="ln1542">  /* store new state */</a>
<a name="ln1543">  dt_conf_set_int(key, state);</a>
<a name="ln1544">}</a>
<a name="ln1545"> </a>
<a name="ln1546">void dt_ui_notify_user()</a>
<a name="ln1547">{</a>
<a name="ln1548">  if(darktable.gui &amp;&amp; !gtk_window_is_active(GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui))))</a>
<a name="ln1549">  {</a>
<a name="ln1550">    gtk_window_set_urgency_hint(GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)), TRUE);</a>
<a name="ln1551">#ifdef MAC_INTEGRATION</a>
<a name="ln1552">#ifdef GTK_TYPE_OSX_APPLICATION</a>
<a name="ln1553">    gtk_osxapplication_attention_request(g_object_new(GTK_TYPE_OSX_APPLICATION, NULL), INFO_REQUEST);</a>
<a name="ln1554">#else</a>
<a name="ln1555">    gtkosx_application_attention_request(g_object_new(GTKOSX_TYPE_APPLICATION, NULL), INFO_REQUEST);</a>
<a name="ln1556">#endif</a>
<a name="ln1557">#endif</a>
<a name="ln1558">  }</a>
<a name="ln1559">}</a>
<a name="ln1560"> </a>
<a name="ln1561">void dt_ui_restore_panels(dt_ui_t *ui)</a>
<a name="ln1562">{</a>
<a name="ln1563">  /* restore visible state of panels for current view */</a>
<a name="ln1564">  const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln1565">  char key[512];</a>
<a name="ln1566"> </a>
<a name="ln1567">  /* restore from a previous collapse all panel state if enabled */</a>
<a name="ln1568">  g_snprintf(key, sizeof(key), &quot;%s/ui/panel_collaps_state&quot;, cv-&gt;module_name);</a>
<a name="ln1569">  uint32_t state = dt_conf_get_int(key);</a>
<a name="ln1570">  if(state)</a>
<a name="ln1571">  {</a>
<a name="ln1572">    /* hide all panels */</a>
<a name="ln1573">    for(int k = 0; k &lt; DT_UI_PANEL_SIZE; k++) dt_ui_panel_show(ui, k, FALSE, TRUE);</a>
<a name="ln1574">  }</a>
<a name="ln1575">  else</a>
<a name="ln1576">  {</a>
<a name="ln1577">    /* restore the visible state of panels */</a>
<a name="ln1578">    for(int k = 0; k &lt; DT_UI_PANEL_SIZE; k++)</a>
<a name="ln1579">    {</a>
<a name="ln1580">      g_snprintf(key, sizeof(key), &quot;%s/ui/%s_visible&quot;, cv-&gt;module_name, _ui_panel_config_names[k]);</a>
<a name="ln1581">      if(dt_conf_key_exists(key))</a>
<a name="ln1582">        gtk_widget_set_visible(ui-&gt;panels[k], dt_conf_get_bool(key));</a>
<a name="ln1583">      else</a>
<a name="ln1584">        gtk_widget_set_visible(ui-&gt;panels[k], 1);</a>
<a name="ln1585">    }</a>
<a name="ln1586">  }</a>
<a name="ln1587">}</a>
<a name="ln1588"> </a>
<a name="ln1589">void dt_ui_update_scrollbars(dt_ui_t *ui)</a>
<a name="ln1590">{</a>
<a name="ln1591">  if (!darktable.gui-&gt;scrollbars.visible) return;</a>
<a name="ln1592"> </a>
<a name="ln1593">  /* update scrollbars for current view */</a>
<a name="ln1594">  const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln1595"> </a>
<a name="ln1596">  if(cv-&gt;vscroll_size &gt; cv-&gt;vscroll_viewport_size){</a>
<a name="ln1597">    gtk_adjustment_configure(gtk_range_get_adjustment(GTK_RANGE(darktable.gui-&gt;scrollbars.vscrollbar)),</a>
<a name="ln1598">                             cv-&gt;vscroll_pos, cv-&gt;vscroll_lower, cv-&gt;vscroll_size, 0, cv-&gt;vscroll_viewport_size,</a>
<a name="ln1599">                             cv-&gt;vscroll_viewport_size);</a>
<a name="ln1600">    gtk_widget_set_margin_end(dt_ui_center(darktable.gui-&gt;ui), DT_PIXEL_APPLY_DPI(0));</a>
<a name="ln1601">  } else {</a>
<a name="ln1602">	gtk_widget_set_margin_end(dt_ui_center(darktable.gui-&gt;ui), DT_PIXEL_APPLY_DPI(6));</a>
<a name="ln1603">  }</a>
<a name="ln1604"> </a>
<a name="ln1605">  if(cv-&gt;hscroll_size &gt; cv-&gt;hscroll_viewport_size){</a>
<a name="ln1606">    gtk_adjustment_configure(gtk_range_get_adjustment(GTK_RANGE(darktable.gui-&gt;scrollbars.hscrollbar)),</a>
<a name="ln1607">                             cv-&gt;hscroll_pos, cv-&gt;hscroll_lower, cv-&gt;hscroll_size, 0, cv-&gt;hscroll_viewport_size,</a>
<a name="ln1608">                             cv-&gt;hscroll_viewport_size);</a>
<a name="ln1609">	gtk_widget_set_margin_bottom(dt_ui_center(darktable.gui-&gt;ui), DT_PIXEL_APPLY_DPI(0));</a>
<a name="ln1610">  } else {</a>
<a name="ln1611">	gtk_widget_set_margin_bottom(dt_ui_center(darktable.gui-&gt;ui), DT_PIXEL_APPLY_DPI(6));</a>
<a name="ln1612">  }</a>
<a name="ln1613"> </a>
<a name="ln1614">  gtk_widget_set_visible(darktable.gui-&gt;scrollbars.vscrollbar, cv-&gt;vscroll_size &gt; cv-&gt;vscroll_viewport_size);</a>
<a name="ln1615">  gtk_widget_set_visible(darktable.gui-&gt;scrollbars.hscrollbar, cv-&gt;hscroll_size &gt; cv-&gt;hscroll_viewport_size);</a>
<a name="ln1616">}</a>
<a name="ln1617"> </a>
<a name="ln1618">void dt_ui_scrollbars_show(dt_ui_t *ui, gboolean show)</a>
<a name="ln1619">{</a>
<a name="ln1620">  darktable.gui-&gt;scrollbars.visible = show;</a>
<a name="ln1621"> </a>
<a name="ln1622">  if (show)</a>
<a name="ln1623">  {</a>
<a name="ln1624">    dt_ui_update_scrollbars(ui);</a>
<a name="ln1625">  }</a>
<a name="ln1626">  else</a>
<a name="ln1627">  {</a>
<a name="ln1628">    gtk_widget_hide(darktable.gui-&gt;scrollbars.vscrollbar);</a>
<a name="ln1629">    gtk_widget_hide(darktable.gui-&gt;scrollbars.hscrollbar);</a>
<a name="ln1630">    gtk_widget_set_margin_end(dt_ui_center(ui), DT_PIXEL_APPLY_DPI(6));</a>
<a name="ln1631">    gtk_widget_set_margin_bottom(dt_ui_center(ui), DT_PIXEL_APPLY_DPI(6));</a>
<a name="ln1632">  }</a>
<a name="ln1633">}</a>
<a name="ln1634"> </a>
<a name="ln1635">void dt_ui_border_show(dt_ui_t *ui, gboolean show)</a>
<a name="ln1636">{</a>
<a name="ln1637">  if(show)</a>
<a name="ln1638">  {</a>
<a name="ln1639">    gtk_widget_show(darktable.gui-&gt;widgets.left_border);</a>
<a name="ln1640">    gtk_widget_show(darktable.gui-&gt;widgets.right_border);</a>
<a name="ln1641">    gtk_widget_show(darktable.gui-&gt;widgets.top_border);</a>
<a name="ln1642">    gtk_widget_show(darktable.gui-&gt;widgets.bottom_border);</a>
<a name="ln1643">  }</a>
<a name="ln1644">  else</a>
<a name="ln1645">  {</a>
<a name="ln1646">    gtk_widget_hide(darktable.gui-&gt;widgets.left_border);</a>
<a name="ln1647">    gtk_widget_hide(darktable.gui-&gt;widgets.right_border);</a>
<a name="ln1648">    gtk_widget_hide(darktable.gui-&gt;widgets.top_border);</a>
<a name="ln1649">    gtk_widget_hide(darktable.gui-&gt;widgets.bottom_border);</a>
<a name="ln1650">  }</a>
<a name="ln1651">}</a>
<a name="ln1652"> </a>
<a name="ln1653">void dt_ui_panel_show(dt_ui_t *ui, const dt_ui_panel_t p, gboolean show, gboolean write)</a>
<a name="ln1654">{</a>
<a name="ln1655">  // if(!GTK_IS_WIDGET(ui-&gt;panels[p])) return;</a>
<a name="ln1656">  g_return_if_fail(GTK_IS_WIDGET(ui-&gt;panels[p]));</a>
<a name="ln1657"> </a>
<a name="ln1658">  const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln1659">  if(write)</a>
<a name="ln1660">  {</a>
<a name="ln1661">    char key[512];</a>
<a name="ln1662">    g_snprintf(key, sizeof(key), &quot;%s/ui/%s_visible&quot;, cv-&gt;module_name, _ui_panel_config_names[p]);</a>
<a name="ln1663">    dt_conf_set_bool(key, show);</a>
<a name="ln1664">  }</a>
<a name="ln1665"> </a>
<a name="ln1666">  if(show)</a>
<a name="ln1667">    gtk_widget_show(ui-&gt;panels[p]);</a>
<a name="ln1668">  else</a>
<a name="ln1669">    gtk_widget_hide(ui-&gt;panels[p]);</a>
<a name="ln1670">}</a>
<a name="ln1671"> </a>
<a name="ln1672">gboolean dt_ui_panel_visible(dt_ui_t *ui, const dt_ui_panel_t p)</a>
<a name="ln1673">{</a>
<a name="ln1674">  // if(!GTK_IS_WIDGET(ui-&gt;panels[p])) return FALSE;</a>
<a name="ln1675">  g_return_val_if_fail(GTK_IS_WIDGET(ui-&gt;panels[p]), FALSE);</a>
<a name="ln1676">  return gtk_widget_get_visible(ui-&gt;panels[p]);</a>
<a name="ln1677">}</a>
<a name="ln1678"> </a>
<a name="ln1679">GtkWidget *dt_ui_center(dt_ui_t *ui)</a>
<a name="ln1680">{</a>
<a name="ln1681">  return ui-&gt;center;</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684">GtkWidget *dt_ui_main_window(dt_ui_t *ui)</a>
<a name="ln1685">{</a>
<a name="ln1686">  return ui-&gt;main_window;</a>
<a name="ln1687">}</a>
<a name="ln1688"> </a>
<a name="ln1689">static GtkWidget *_ui_init_panel_container_top(GtkWidget *container)</a>
<a name="ln1690">{</a>
<a name="ln1691">  GtkWidget *w = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1692">  gtk_box_pack_start(GTK_BOX(container), w, FALSE, FALSE, 4);</a>
<a name="ln1693">  return w;</a>
<a name="ln1694">}</a>
<a name="ln1695"> </a>
<a name="ln1696">static gboolean _ui_init_panel_container_center_scroll_event(GtkWidget *widget, GdkEventScroll *event)</a>
<a name="ln1697">{</a>
<a name="ln1698">  // just make sure nothing happens:</a>
<a name="ln1699">  return TRUE;</a>
<a name="ln1700">}</a>
<a name="ln1701"> </a>
<a name="ln1702">// this should work as long as everything happens in the gui thread</a>
<a name="ln1703">static void _ui_panel_size_changed(GtkAdjustment *adjustment, GParamSpec *pspec, gpointer user_data)</a>
<a name="ln1704">{</a>
<a name="ln1705">  GtkAllocation allocation;</a>
<a name="ln1706">  static float last_height[2] = { 0 };</a>
<a name="ln1707"> </a>
<a name="ln1708">  int side = GPOINTER_TO_INT(user_data);</a>
<a name="ln1709"> </a>
<a name="ln1710">  // don't do anything when the size didn't actually change.</a>
<a name="ln1711">  float height = gtk_adjustment_get_upper(adjustment) - gtk_adjustment_get_lower(adjustment);</a>
<a name="ln1712">  if(height == last_height[side]) return;</a>
<a name="ln1713">  last_height[side] = height;</a>
<a name="ln1714"> </a>
<a name="ln1715">  if(!darktable.gui-&gt;scroll_to[side]) return;</a>
<a name="ln1716"> </a>
<a name="ln1717">  gtk_widget_get_allocation(darktable.gui-&gt;scroll_to[side], &amp;allocation);</a>
<a name="ln1718">  gtk_adjustment_set_value(adjustment, allocation.y);</a>
<a name="ln1719"> </a>
<a name="ln1720">  darktable.gui-&gt;scroll_to[side] = NULL;</a>
<a name="ln1721">}</a>
<a name="ln1722"> </a>
<a name="ln1723">static GtkWidget *_ui_init_panel_container_center(GtkWidget *container, gboolean left)</a>
<a name="ln1724">{</a>
<a name="ln1725">  GtkWidget *widget;</a>
<a name="ln1726">  GtkAdjustment *a[4];</a>
<a name="ln1727"> </a>
<a name="ln1728">  a[0] = GTK_ADJUSTMENT(gtk_adjustment_new(0, 0, 100, 1, 10, 10));</a>
<a name="ln1729">  a[1] = GTK_ADJUSTMENT(gtk_adjustment_new(0, 0, 100, 1, 10, 10));</a>
<a name="ln1730">  a[2] = GTK_ADJUSTMENT(gtk_adjustment_new(0, 0, 100, 1, 10, 10));</a>
<a name="ln1731">  a[3] = GTK_ADJUSTMENT(gtk_adjustment_new(0, 0, 100, 1, 10, 10));</a>
<a name="ln1732"> </a>
<a name="ln1733">  /* create the scrolled window */</a>
<a name="ln1734">  widget = gtk_scrolled_window_new(a[0], a[1]);</a>
<a name="ln1735">  gtk_widget_set_can_focus(widget, TRUE);</a>
<a name="ln1736">  gtk_scrolled_window_set_placement(GTK_SCROLLED_WINDOW(widget),</a>
<a name="ln1737">                                    left ? GTK_CORNER_TOP_LEFT : GTK_CORNER_TOP_RIGHT);</a>
<a name="ln1738">  gtk_box_pack_start(GTK_BOX(container), widget, TRUE, TRUE, 0);</a>
<a name="ln1739">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(widget), GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);</a>
<a name="ln1740"> </a>
<a name="ln1741">  g_signal_connect(G_OBJECT(gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(widget))), &quot;notify::lower&quot;,</a>
<a name="ln1742">                   G_CALLBACK(_ui_panel_size_changed), GINT_TO_POINTER(left ? 1 : 0));</a>
<a name="ln1743">  // we want the left/right window border to scroll the module lists</a>
<a name="ln1744">  g_signal_connect(G_OBJECT(left ? darktable.gui-&gt;widgets.right_border : darktable.gui-&gt;widgets.left_border),</a>
<a name="ln1745">                   &quot;scroll-event&quot;, G_CALLBACK(borders_scrolled), widget);</a>
<a name="ln1746"> </a>
<a name="ln1747">  /* create the scrolled viewport */</a>
<a name="ln1748">  container = widget;</a>
<a name="ln1749">  widget = gtk_viewport_new(a[2], a[3]);</a>
<a name="ln1750">  gtk_viewport_set_shadow_type(GTK_VIEWPORT(widget), GTK_SHADOW_NONE);</a>
<a name="ln1751">  gtk_container_add(GTK_CONTAINER(container), widget);</a>
<a name="ln1752"> </a>
<a name="ln1753">  /* avoid scrolling with wheel, it's distracting (you'll end up over a control, and scroll it's value) */</a>
<a name="ln1754">  container = widget;</a>
<a name="ln1755">  widget = gtk_event_box_new();</a>
<a name="ln1756">  gtk_widget_add_events(GTK_WIDGET(widget), GDK_SCROLL_MASK);</a>
<a name="ln1757">  // gtk_widget_add_events(GTK_WIDGET(widget), GDK_SMOOTH_SCROLL_MASK);</a>
<a name="ln1758">  g_signal_connect(G_OBJECT(widget), &quot;scroll-event&quot;, G_CALLBACK(_ui_init_panel_container_center_scroll_event),</a>
<a name="ln1759">                   NULL);</a>
<a name="ln1760">  gtk_container_add(GTK_CONTAINER(container), widget);</a>
<a name="ln1761"> </a>
<a name="ln1762">  /* create the container */</a>
<a name="ln1763">  container = widget;</a>
<a name="ln1764">  widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1765">  gtk_widget_set_name(widget, &quot;plugins_vbox_left&quot;);</a>
<a name="ln1766">  gtk_container_add(GTK_CONTAINER(container), widget);</a>
<a name="ln1767"> </a>
<a name="ln1768">  return widget;</a>
<a name="ln1769">}</a>
<a name="ln1770"> </a>
<a name="ln1771">static GtkWidget *_ui_init_panel_container_bottom(GtkWidget *container)</a>
<a name="ln1772">{</a>
<a name="ln1773">  GtkWidget *w = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1774">  gtk_box_pack_start(GTK_BOX(container), w, FALSE, FALSE, DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1775">  return w;</a>
<a name="ln1776">}</a>
<a name="ln1777"> </a>
<a name="ln1778">static void _ui_init_panel_left(dt_ui_t *ui, GtkWidget *container)</a>
<a name="ln1779">{</a>
<a name="ln1780">  GtkWidget *widget;</a>
<a name="ln1781"> </a>
<a name="ln1782">  /* create left panel main widget and add it to ui */</a>
<a name="ln1783">  widget = ui-&gt;panels[DT_UI_PANEL_LEFT] = dtgtk_side_panel_new();</a>
<a name="ln1784">  gtk_widget_set_name(widget, &quot;left&quot;);</a>
<a name="ln1785">//   gtk_widget_set_margin_left(widget, DT_PIXEL_APPLY_DPI(5)); // i prefer it with less blank space</a>
<a name="ln1786">  gtk_grid_attach(GTK_GRID(container), widget, 1, 1, 1, 1);</a>
<a name="ln1787"> </a>
<a name="ln1788">  /* add top,center,bottom*/</a>
<a name="ln1789">  container = widget;</a>
<a name="ln1790">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_LEFT_TOP] = _ui_init_panel_container_top(container);</a>
<a name="ln1791">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_LEFT_CENTER] = _ui_init_panel_container_center(container, FALSE);</a>
<a name="ln1792">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_LEFT_BOTTOM] = _ui_init_panel_container_bottom(container);</a>
<a name="ln1793"> </a>
<a name="ln1794">  /* lets show all widgets */</a>
<a name="ln1795">  gtk_widget_show_all(ui-&gt;panels[DT_UI_PANEL_LEFT]);</a>
<a name="ln1796">}</a>
<a name="ln1797"> </a>
<a name="ln1798">static void _ui_init_panel_right(dt_ui_t *ui, GtkWidget *container)</a>
<a name="ln1799">{</a>
<a name="ln1800">  GtkWidget *widget;</a>
<a name="ln1801"> </a>
<a name="ln1802">  /* create left panel main widget and add it to ui */</a>
<a name="ln1803">  widget = ui-&gt;panels[DT_UI_PANEL_RIGHT] = dtgtk_side_panel_new();</a>
<a name="ln1804">  gtk_widget_set_name(widget, &quot;right&quot;);</a>
<a name="ln1805">//   gtk_widget_set_margin_right(widget, DT_PIXEL_APPLY_DPI(5)); // i prefer it with less blank space</a>
<a name="ln1806">  gtk_grid_attach(GTK_GRID(container), widget, 3, 1, 1, 1);</a>
<a name="ln1807"> </a>
<a name="ln1808">  /* add top,center,bottom*/</a>
<a name="ln1809">  container = widget;</a>
<a name="ln1810">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_RIGHT_TOP] = _ui_init_panel_container_top(container);</a>
<a name="ln1811">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_RIGHT_CENTER] = _ui_init_panel_container_center(container, TRUE);</a>
<a name="ln1812">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_RIGHT_BOTTOM] = _ui_init_panel_container_bottom(container);</a>
<a name="ln1813"> </a>
<a name="ln1814">  /* lets show all widgets */</a>
<a name="ln1815">  gtk_widget_show_all(ui-&gt;panels[DT_UI_PANEL_RIGHT]);</a>
<a name="ln1816">}</a>
<a name="ln1817"> </a>
<a name="ln1818">static void _ui_init_panel_top(dt_ui_t *ui, GtkWidget *container)</a>
<a name="ln1819">{</a>
<a name="ln1820">  GtkWidget *widget;</a>
<a name="ln1821"> </a>
<a name="ln1822">  /* create the panel box */</a>
<a name="ln1823">  ui-&gt;panels[DT_UI_PANEL_TOP] = widget = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1824">  gtk_widget_set_hexpand(GTK_WIDGET(widget), TRUE);</a>
<a name="ln1825">  gtk_grid_attach(GTK_GRID(container), widget, 1, 0, 3, 1);</a>
<a name="ln1826"> </a>
<a name="ln1827">  /* add container for top left */</a>
<a name="ln1828">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_TOP_LEFT] = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1829">  gtk_box_pack_start(GTK_BOX(widget), ui-&gt;containers[DT_UI_CONTAINER_PANEL_TOP_LEFT], FALSE, FALSE,</a>
<a name="ln1830">                     DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1831"> </a>
<a name="ln1832">  /* add container for top center */</a>
<a name="ln1833">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_TOP_CENTER] = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1834">  gtk_box_pack_start(GTK_BOX(widget), ui-&gt;containers[DT_UI_CONTAINER_PANEL_TOP_CENTER], TRUE, TRUE,</a>
<a name="ln1835">                     DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1836"> </a>
<a name="ln1837">  /* add container for top right */</a>
<a name="ln1838">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_TOP_RIGHT] = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1839">  gtk_box_pack_end(GTK_BOX(widget), ui-&gt;containers[DT_UI_CONTAINER_PANEL_TOP_RIGHT], FALSE, FALSE,</a>
<a name="ln1840">                   DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1841">}</a>
<a name="ln1842"> </a>
<a name="ln1843">static void _ui_init_panel_bottom(dt_ui_t *ui, GtkWidget *container)</a>
<a name="ln1844">{</a>
<a name="ln1845">  GtkWidget *widget;</a>
<a name="ln1846"> </a>
<a name="ln1847">  /* create the panel box */</a>
<a name="ln1848">  ui-&gt;panels[DT_UI_PANEL_BOTTOM] = widget = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1849">  gtk_widget_set_hexpand(GTK_WIDGET(widget), TRUE);</a>
<a name="ln1850">  gtk_grid_attach(GTK_GRID(container), widget, 1, 2, 3, 1);</a>
<a name="ln1851"> </a>
<a name="ln1852">  /* add the container */</a>
<a name="ln1853">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_BOTTOM] = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1854">  gtk_box_pack_start(GTK_BOX(widget), ui-&gt;containers[DT_UI_CONTAINER_PANEL_BOTTOM], TRUE, TRUE,</a>
<a name="ln1855">                     DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1856">}</a>
<a name="ln1857"> </a>
<a name="ln1858"> </a>
<a name="ln1859">static void _ui_init_panel_center_top(dt_ui_t *ui, GtkWidget *container)</a>
<a name="ln1860">{</a>
<a name="ln1861">  GtkWidget *widget;</a>
<a name="ln1862"> </a>
<a name="ln1863">  /* create the panel box */</a>
<a name="ln1864">  ui-&gt;panels[DT_UI_PANEL_CENTER_TOP] = widget = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1865">  gtk_box_pack_start(GTK_BOX(container), widget, FALSE, TRUE, 0);</a>
<a name="ln1866"> </a>
<a name="ln1867">  /* add container for center top left */</a>
<a name="ln1868">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_CENTER_TOP_LEFT] = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1869">  gtk_box_pack_start(GTK_BOX(widget), ui-&gt;containers[DT_UI_CONTAINER_PANEL_CENTER_TOP_LEFT], FALSE, FALSE,</a>
<a name="ln1870">                     DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1871"> </a>
<a name="ln1872">  /* add container for center top center */</a>
<a name="ln1873">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_CENTER_TOP_CENTER] = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1874">  gtk_box_pack_start(GTK_BOX(widget), ui-&gt;containers[DT_UI_CONTAINER_PANEL_CENTER_TOP_CENTER], TRUE, TRUE,</a>
<a name="ln1875">                     DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1876"> </a>
<a name="ln1877">  /* add container for center top right */</a>
<a name="ln1878">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_CENTER_TOP_RIGHT] = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1879">  gtk_box_pack_end(GTK_BOX(widget), ui-&gt;containers[DT_UI_CONTAINER_PANEL_CENTER_TOP_RIGHT], FALSE, FALSE,</a>
<a name="ln1880">                   DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1881">}</a>
<a name="ln1882"> </a>
<a name="ln1883">static void _ui_init_panel_center_bottom(dt_ui_t *ui, GtkWidget *container)</a>
<a name="ln1884">{</a>
<a name="ln1885">  GtkWidget *widget;</a>
<a name="ln1886"> </a>
<a name="ln1887">  /* create the panel box */</a>
<a name="ln1888">  ui-&gt;panels[DT_UI_PANEL_CENTER_BOTTOM] = widget = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1889">  gtk_box_pack_start(GTK_BOX(container), widget, FALSE, TRUE, 0);</a>
<a name="ln1890"> </a>
<a name="ln1891">  /* adding the center bottom left toolbox */</a>
<a name="ln1892">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_CENTER_BOTTOM_LEFT] = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1893">  gtk_box_pack_start(GTK_BOX(widget), ui-&gt;containers[DT_UI_CONTAINER_PANEL_CENTER_BOTTOM_LEFT], TRUE, TRUE,</a>
<a name="ln1894">                     DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1895"> </a>
<a name="ln1896">  /* adding the center box */</a>
<a name="ln1897">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_CENTER_BOTTOM_CENTER] = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1898">  gtk_box_pack_start(GTK_BOX(widget), ui-&gt;containers[DT_UI_CONTAINER_PANEL_CENTER_BOTTOM_CENTER], FALSE, TRUE,</a>
<a name="ln1899">                     DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1900"> </a>
<a name="ln1901">  /* adding the right toolbox */</a>
<a name="ln1902">  ui-&gt;containers[DT_UI_CONTAINER_PANEL_CENTER_BOTTOM_RIGHT] = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1903">  gtk_box_pack_start(GTK_BOX(widget), ui-&gt;containers[DT_UI_CONTAINER_PANEL_CENTER_BOTTOM_RIGHT], TRUE, TRUE,</a>
<a name="ln1904">                     DT_UI_PANEL_MODULE_SPACING);</a>
<a name="ln1905">}</a>
<a name="ln1906"> </a>
<a name="ln1907">/* this is called as a signal handler, the signal raising logic asserts the gdk lock. */</a>
<a name="ln1908">static void _ui_widget_redraw_callback(gpointer instance, GtkWidget *widget)</a>
<a name="ln1909">{</a>
<a name="ln1910">  gtk_widget_queue_draw(widget);</a>
<a name="ln1911">}</a>
<a name="ln1912"> </a>
<a name="ln1913">void dt_ellipsize_combo(GtkComboBox *cbox)</a>
<a name="ln1914">{</a>
<a name="ln1915">  GList *renderers = gtk_cell_layout_get_cells(GTK_CELL_LAYOUT(cbox));</a>
<a name="ln1916">  GList *it = renderers;</a>
<a name="ln1917">  while(it)</a>
<a name="ln1918">  {</a>
<a name="ln1919">    GtkCellRendererText *tr = GTK_CELL_RENDERER_TEXT(it-&gt;data);</a>
<a name="ln1920">    g_object_set(G_OBJECT(tr), &quot;ellipsize&quot;, PANGO_ELLIPSIZE_MIDDLE, (gchar *)0);</a>
<a name="ln1921">    it = g_list_next(it);</a>
<a name="ln1922">  }</a>
<a name="ln1923">  g_list_free(renderers);</a>
<a name="ln1924">}</a>
<a name="ln1925"> </a>
<a name="ln1926">typedef struct result_t</a>
<a name="ln1927">{</a>
<a name="ln1928">  enum {RESULT_NONE, RESULT_NO, RESULT_YES} result;</a>
<a name="ln1929">  GtkWidget *window;</a>
<a name="ln1930">} result_t;</a>
<a name="ln1931"> </a>
<a name="ln1932">static void _yes_no_button_handler_no(GtkButton *button, gpointer data)</a>
<a name="ln1933">{</a>
<a name="ln1934">  result_t *result = (result_t *)data;</a>
<a name="ln1935">  result-&gt;result = RESULT_NO;</a>
<a name="ln1936">  gtk_widget_destroy(result-&gt;window);</a>
<a name="ln1937">  gtk_main_quit();</a>
<a name="ln1938">}</a>
<a name="ln1939"> </a>
<a name="ln1940">static void _yes_no_button_handler_yes(GtkButton *button, gpointer data)</a>
<a name="ln1941">{</a>
<a name="ln1942">  result_t *result = (result_t *)data;</a>
<a name="ln1943">  result-&gt;result = RESULT_YES;</a>
<a name="ln1944">  gtk_widget_destroy(result-&gt;window);</a>
<a name="ln1945">  gtk_main_quit();</a>
<a name="ln1946">}</a>
<a name="ln1947"> </a>
<a name="ln1948">gboolean dt_gui_show_standalone_yes_no_dialog(const char *title, const char *markup, const char *no_text,</a>
<a name="ln1949">                                              const char *yes_text)</a>
<a name="ln1950">{</a>
<a name="ln1951">  GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</a>
<a name="ln1952">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1953">  dt_osx_disallow_fullscreen(window);</a>
<a name="ln1954">#endif</a>
<a name="ln1955"> </a>
<a name="ln1956">  gtk_window_set_icon_name(GTK_WINDOW(window), &quot;darktable&quot;);</a>
<a name="ln1957">  gtk_window_set_title(GTK_WINDOW(window), title);</a>
<a name="ln1958">  g_signal_connect(window, &quot;destroy&quot;, G_CALLBACK(gtk_main_quit), NULL);</a>
<a name="ln1959"> </a>
<a name="ln1960">  GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln1961">  gtk_widget_set_margin_start(vbox, 10);</a>
<a name="ln1962">  gtk_widget_set_margin_end(vbox, 10);</a>
<a name="ln1963">  gtk_widget_set_margin_top(vbox, 7);</a>
<a name="ln1964">  gtk_widget_set_margin_bottom(vbox, 5);</a>
<a name="ln1965">  gtk_container_add(GTK_CONTAINER(window), vbox);</a>
<a name="ln1966"> </a>
<a name="ln1967">  GtkWidget *label = gtk_label_new(NULL);</a>
<a name="ln1968">  gtk_label_set_markup(GTK_LABEL(label), markup);</a>
<a name="ln1969">  gtk_box_pack_start(GTK_BOX(vbox), label, TRUE, TRUE, 0);</a>
<a name="ln1970"> </a>
<a name="ln1971">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln1972">  gtk_widget_set_margin_top(hbox, 10);</a>
<a name="ln1973">  gtk_box_pack_start(GTK_BOX(vbox), hbox, TRUE, TRUE, 0);</a>
<a name="ln1974"> </a>
<a name="ln1975">  result_t result = {.result = RESULT_NONE, .window = window};</a>
<a name="ln1976"> </a>
<a name="ln1977">  GtkWidget *button;</a>
<a name="ln1978"> </a>
<a name="ln1979">  if(no_text)</a>
<a name="ln1980">  {</a>
<a name="ln1981">    button = gtk_button_new_with_label(no_text);</a>
<a name="ln1982">    g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(_yes_no_button_handler_no), &amp;result);</a>
<a name="ln1983">    gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, TRUE, 0);</a>
<a name="ln1984">  }</a>
<a name="ln1985"> </a>
<a name="ln1986">  if(yes_text)</a>
<a name="ln1987">  {</a>
<a name="ln1988">    button = gtk_button_new_with_label(yes_text);</a>
<a name="ln1989">    g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(_yes_no_button_handler_yes), &amp;result);</a>
<a name="ln1990">    gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, TRUE, 0);</a>
<a name="ln1991">  }</a>
<a name="ln1992"> </a>
<a name="ln1993">  gtk_widget_show_all(window);</a>
<a name="ln1994">  gtk_main();</a>
<a name="ln1995"> </a>
<a name="ln1996">  return result.result == RESULT_YES;</a>
<a name="ln1997">}</a>
<a name="ln1998"> </a>
<a name="ln1999">// TODO: should that go to another place than gtk.c?</a>
<a name="ln2000">void dt_gui_add_help_link(GtkWidget *widget, const char *link)</a>
<a name="ln2001">{</a>
<a name="ln2002">  g_object_set_data(G_OBJECT(widget), &quot;dt-help-url&quot;, (void *)link);</a>
<a name="ln2003">  gtk_widget_add_events(widget, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006">// load a CSS theme</a>
<a name="ln2007">void dt_gui_load_theme(const char *theme)</a>
<a name="ln2008">{</a>
<a name="ln2009">  char path[PATH_MAX] = { 0 }, datadir[PATH_MAX] = { 0 }, configdir[PATH_MAX] = { 0 };</a>
<a name="ln2010">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln2011">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln2012"> </a>
<a name="ln2013">  // user dir them</a>
<a name="ln2014">  g_snprintf(path, sizeof(path), &quot;%s/themes/%s.css&quot;, configdir, theme);</a>
<a name="ln2015">  if(!g_file_test(path, G_FILE_TEST_EXISTS))</a>
<a name="ln2016">  {</a>
<a name="ln2017">    // dt dir theme</a>
<a name="ln2018">    g_snprintf(path, sizeof(path), &quot;%s/themes/%s.css&quot;, datadir, theme);</a>
<a name="ln2019">    if(!g_file_test(path, G_FILE_TEST_EXISTS))</a>
<a name="ln2020">    {</a>
<a name="ln2021">      // fallback to default theme</a>
<a name="ln2022">      g_snprintf(path, sizeof(path), &quot;%s/themes/darktable.css&quot;, datadir);</a>
<a name="ln2023">      dt_conf_set_string(&quot;ui_last/theme&quot;, &quot;darktable&quot;);</a>
<a name="ln2024">    }</a>
<a name="ln2025">    else</a>
<a name="ln2026">      dt_conf_set_string(&quot;ui_last/theme&quot;, theme);</a>
<a name="ln2027">  }</a>
<a name="ln2028">  else</a>
<a name="ln2029">    dt_conf_set_string(&quot;ui_last/theme&quot;, theme);</a>
<a name="ln2030"> </a>
<a name="ln2031">  GError *error = NULL;</a>
<a name="ln2032">  GtkStyleProvider *themes_style_provider = GTK_STYLE_PROVIDER(gtk_css_provider_new());</a>
<a name="ln2033">  gtk_style_context_add_provider_for_screen</a>
<a name="ln2034">    (gdk_screen_get_default(), themes_style_provider, GTK_STYLE_PROVIDER_PRIORITY_USER + 1);</a>
<a name="ln2035"> </a>
<a name="ln2036">  if(!gtk_css_provider_load_from_path(GTK_CSS_PROVIDER(themes_style_provider), path, &amp;error))</a>
<a name="ln2037">  {</a>
<a name="ln2038">    printf(&quot;%s: error parsing %s: %s\n&quot;, G_STRFUNC, path, error-&gt;message);</a>
<a name="ln2039">    g_clear_error(&amp;error);</a>
<a name="ln2040">  }</a>
<a name="ln2041"> </a>
<a name="ln2042">  g_object_unref(themes_style_provider);</a>
<a name="ln2043"> </a>
<a name="ln2044">  // setup the colors</a>
<a name="ln2045"> </a>
<a name="ln2046">  GdkRGBA *c = darktable.gui-&gt;colors;</a>
<a name="ln2047">  GtkWidget *main_window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln2048">  GtkStyleContext *ctx = gtk_widget_get_style_context(main_window);</a>
<a name="ln2049"> </a>
<a name="ln2050">  c[DT_GUI_COLOR_BG] = (GdkRGBA){ 0.1333, 0.1333, 0.1333, 1.0 };</a>
<a name="ln2051"> </a>
<a name="ln2052">  struct color_init</a>
<a name="ln2053">  {</a>
<a name="ln2054">    const char *name;</a>
<a name="ln2055">    GdkRGBA default_col;</a>
<a name="ln2056">  } init[DT_GUI_COLOR_LAST] = {</a>
<a name="ln2057">    [DT_GUI_COLOR_DARKROOM_BG] = { &quot;darkroom_bg_color&quot;, { .2, .2, .2, 1.0 } },</a>
<a name="ln2058">    [DT_GUI_COLOR_DARKROOM_PREVIEW_BG] = { &quot;darkroom_preview_bg_color&quot;, { .1, .1, .1, 1.0 } },</a>
<a name="ln2059">    [DT_GUI_COLOR_LIGHTTABLE_BG] = { &quot;lighttable_bg_color&quot;, { .2, .2, .2, 1.0 } },</a>
<a name="ln2060">    [DT_GUI_COLOR_LIGHTTABLE_PREVIEW_BG] = { &quot;lighttable_preview_bg_color&quot;, { .1, .1, .1, 1.0 } },</a>
<a name="ln2061">    [DT_GUI_COLOR_BRUSH_CURSOR] = { &quot;brush_cursor&quot;, { 1., 1., 1., 0.9 } },</a>
<a name="ln2062">    [DT_GUI_COLOR_BRUSH_TRACE] = { &quot;brush_trace&quot;, { 0., 0., 0., 0.8 } },</a>
<a name="ln2063">    [DT_GUI_COLOR_THUMBNAIL_BG] = { &quot;thumbnail_bg_color&quot;, { 0.4, 0.4, 0.4, 1.0 } },</a>
<a name="ln2064">    [DT_GUI_COLOR_THUMBNAIL_SELECTED_BG] = { &quot;thumbnail_selected_bg_color&quot;, { 0.6, 0.6, 0.6, 1.0 } },</a>
<a name="ln2065">    [DT_GUI_COLOR_THUMBNAIL_HOVER_BG] = { &quot;thumbnail_hover_bg_color&quot;, { 0.8, 0.8, 0.8, 1.0 } },</a>
<a name="ln2066">    [DT_GUI_COLOR_THUMBNAIL_OUTLINE] = { &quot;thumbnail_outline_color&quot;, { 0.2, 0.2, 0.2, 1.0 } },</a>
<a name="ln2067">    [DT_GUI_COLOR_THUMBNAIL_SELECTED_OUTLINE] = { &quot;thumbnail_selected_outline_color&quot;, { 0.4, 0.4, 0.4, 1.0 } },</a>
<a name="ln2068">    [DT_GUI_COLOR_THUMBNAIL_HOVER_OUTLINE] = { &quot;thumbnail_hover_outline_color&quot;, { 0.6, 0.6, 0.6, 1.0 } },</a>
<a name="ln2069">    [DT_GUI_COLOR_THUMBNAIL_FONT] = { &quot;thumbnail_font_color&quot;, { 0.425, 0.425, 0.425, 1.0 } },</a>
<a name="ln2070">    [DT_GUI_COLOR_THUMBNAIL_SELECTED_FONT] = { &quot;thumbnail_selected_font_color&quot;, { 0.5, 0.5, 0.5, 1.0 } },</a>
<a name="ln2071">    [DT_GUI_COLOR_THUMBNAIL_HOVER_FONT] = { &quot;thumbnail_hover_font_color&quot;, { 0.7, 0.7, 0.7, 1.0 } },</a>
<a name="ln2072">    [DT_GUI_COLOR_THUMBNAIL_BORDER] = { &quot;thumbnail_border_color&quot;, { 0.1, 0.1, 0.1, 1.0 } },</a>
<a name="ln2073">    [DT_GUI_COLOR_THUMBNAIL_SELECTED_BORDER] = { &quot;thumbnail_selected_border_color&quot;, { 0.9, 0.9, 0.9, 1.0 } },</a>
<a name="ln2074">    [DT_GUI_COLOR_FILMSTRIP_BG] = { &quot;filmstrip_bg_color&quot;, { 0.2, 0.2, 0.2, 1.0 } },</a>
<a name="ln2075">  };</a>
<a name="ln2076"> </a>
<a name="ln2077">  // starting from 1 as DT_GUI_COLOR_BG is not part of this table</a>
<a name="ln2078">  for(int i = 1; i &lt; DT_GUI_COLOR_LAST; i++)</a>
<a name="ln2079">  {</a>
<a name="ln2080">    if(!gtk_style_context_lookup_color(ctx, init[i].name, &amp;c[i]))</a>
<a name="ln2081">    {</a>
<a name="ln2082">      c[i] = init[i].default_col;</a>
<a name="ln2083">    }</a>
<a name="ln2084">  }</a>
<a name="ln2085">}</a>
<a name="ln2086"> </a>
<a name="ln2087">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2088">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2089">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1179"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'css_theme' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
