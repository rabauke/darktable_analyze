
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/* </a>
<a name="ln2"> * svdcomp - SVD decomposition routine. </a>
<a name="ln3"> * Takes an mxn matrix a and decomposes it into udv, where u,v are</a>
<a name="ln4"> * left and right orthogonal transformation matrices, and d is a </a>
<a name="ln5"> * diagonal matrix of singular values.</a>
<a name="ln6"> *</a>
<a name="ln7"> * This routine is adapted from svdecomp.c in XLISP-STAT 2.1 which is </a>
<a name="ln8"> * adapted by Luke Tierney and David Betz.</a>
<a name="ln9"> *</a>
<a name="ln10"> * the now dead xlisp-stat package seems to have been distributed</a>
<a name="ln11"> * under some sort of BSD license.</a>
<a name="ln12"> *</a>
<a name="ln13"> * Input to dsvd is as follows:</a>
<a name="ln14"> *   a = mxn matrix to be decomposed, gets overwritten with u</a>
<a name="ln15"> *   m = row dimension of a</a>
<a name="ln16"> *   n = column dimension of a</a>
<a name="ln17"> *   w = returns the vector of singular values of a</a>
<a name="ln18"> *   v = returns the right orthogonal transformation matrix</a>
<a name="ln19">*/</a>
<a name="ln20"> </a>
<a name="ln21">#pragma once</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;math.h&gt;</a>
<a name="ln24">#include &lt;stdio.h&gt;</a>
<a name="ln25">#include &lt;stdlib.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#define SIGN(a, b) copysign(a, b)</a>
<a name="ln28"> </a>
<a name="ln29">static inline double PYTHAG(double a, double b)</a>
<a name="ln30">{</a>
<a name="ln31">  double at = fabs(a), bt = fabs(b), ct, result;</a>
<a name="ln32"> </a>
<a name="ln33">  if (at &gt; bt)       { ct = bt / at; result = at * sqrt(1.0 + ct * ct); }</a>
<a name="ln34">  else if (bt &gt; 0.0) { ct = at / bt; result = bt * sqrt(1.0 + ct * ct); }</a>
<a name="ln35">  else result = 0.0;</a>
<a name="ln36">  return result;</a>
<a name="ln37">}</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">// decompose (m &gt;= n)</a>
<a name="ln41">//      n             n               n</a>
<a name="ln42">//   |      |      |     |   n     |     |</a>
<a name="ln43">// m |  a   |  = m |  u  | diag(w) | v^t | n</a>
<a name="ln44">//   |      |      |     |         |     |</a>
<a name="ln45">//</a>
<a name="ln46">// where the data layout of a (in) and u (out) is strided by str for every row</a>
<a name="ln47">static inline int dsvd(</a>
<a name="ln48">    double *a,    // input matrix a[j*str + i] is j-th row and i-th column. will be overwritten by u</a>
<a name="ln49">    int m,        // number of rows of a and u</a>
<a name="ln50">    int n,        // number of cols of a and u</a>
<a name="ln51">    int str,      // row stride of a and u</a>
<a name="ln52">    double *w,    // output singular values w[n]</a>
<a name="ln53">    double *v)    // output v matrix v[n*n]</a>
<a name="ln54">{</a>
<a name="ln55">  int flag, i, its, j, jj, k, l, nm;</a>
<a name="ln56">  double c, f, h, s, x, y, z;</a>
<a name="ln57">  double anorm = 0.0, g = 0.0, scale = 0.0;</a>
<a name="ln58"> </a>
<a name="ln59">  if (m &lt; n) </a>
<a name="ln60">  {</a>
<a name="ln61">    fprintf(stderr, &quot;[svd] #rows must be &gt;= #cols \n&quot;);</a>
<a name="ln62">    return(0);</a>
<a name="ln63">  }</a>
<a name="ln64"> </a>
<a name="ln65">  double *rv1 = malloc(n * sizeof(double));</a>
<a name="ln66"> </a>
<a name="ln67">  /* Householder reduction to bidiagonal form */</a>
<a name="ln68">  for (i = 0; i &lt; n; i++) </a>
<a name="ln69">  {</a>
<a name="ln70">    /* left-hand reduction */</a>
<a name="ln71">    l = i + 1;</a>
<a name="ln72">    rv1[i] = scale * g;</a>
<a name="ln73">    g = s = scale = 0.0;</a>
<a name="ln74">    if (i &lt; m) </a>
<a name="ln75">    {</a>
<a name="ln76">      for (k = i; k &lt; m; k++) </a>
<a name="ln77">        scale += fabs(a[k*str+i]);</a>
<a name="ln78">      if (scale) </a>
<a name="ln79">      {</a>
<a name="ln80">        for (k = i; k &lt; m; k++) </a>
<a name="ln81">        {</a>
<a name="ln82">          a[k*str+i] = a[k*str+i]/scale;</a>
<a name="ln83">          s += a[k*str+i] * a[k*str+i];</a>
<a name="ln84">        }</a>
<a name="ln85">        f = a[i*str+i];</a>
<a name="ln86">        g = -SIGN(sqrt(s), f);</a>
<a name="ln87">        h = f * g - s;</a>
<a name="ln88">        a[i*str+i] = f - g;</a>
<a name="ln89">        if (i != n - 1) </a>
<a name="ln90">        {</a>
<a name="ln91">          for (j = l; j &lt; n; j++) </a>
<a name="ln92">          {</a>
<a name="ln93">            for (s = 0.0, k = i; k &lt; m; k++) </a>
<a name="ln94">              s += a[k*str+i] * a[k*str+j];</a>
<a name="ln95">            f = s / h;</a>
<a name="ln96">            for (k = i; k &lt; m; k++) </a>
<a name="ln97">              a[k*str+j] += f * a[k*str+i];</a>
<a name="ln98">          }</a>
<a name="ln99">        }</a>
<a name="ln100">        for (k = i; k &lt; m; k++) </a>
<a name="ln101">          a[k*str+i] = a[k*str+i]*scale;</a>
<a name="ln102">      }</a>
<a name="ln103">    }</a>
<a name="ln104">    w[i] = scale * g;</a>
<a name="ln105"> </a>
<a name="ln106">    /* right-hand reduction */</a>
<a name="ln107">    g = s = scale = 0.0;</a>
<a name="ln108">    if (i &lt; m &amp;&amp; i != n - 1) </a>
<a name="ln109">    {</a>
<a name="ln110">      for (k = l; k &lt; n; k++) </a>
<a name="ln111">        scale += fabs(a[i*str+k]);</a>
<a name="ln112">      if (scale) </a>
<a name="ln113">      {</a>
<a name="ln114">        for (k = l; k &lt; n; k++) </a>
<a name="ln115">        {</a>
<a name="ln116">          a[i*str+k] = a[i*str+k]/scale;</a>
<a name="ln117">          s += a[i*str+k] * a[i*str+k];</a>
<a name="ln118">        }</a>
<a name="ln119">        f = a[i*str+l];</a>
<a name="ln120">        g = -SIGN(sqrt(s), f);</a>
<a name="ln121">        h = f * g - s;</a>
<a name="ln122">        a[i*str+l] = f - g;</a>
<a name="ln123">        for (k = l; k &lt; n; k++) </a>
<a name="ln124">          rv1[k] = a[i*str+k] / h;</a>
<a name="ln125">        if (i != m - 1) </a>
<a name="ln126">        {</a>
<a name="ln127">          for (j = l; j &lt; m; j++) </a>
<a name="ln128">          {</a>
<a name="ln129">            for (s = 0.0, k = l; k &lt; n; k++) </a>
<a name="ln130">              s += a[j*str+k] * a[i*str+k];</a>
<a name="ln131">            for (k = l; k &lt; n; k++) </a>
<a name="ln132">              a[j*str+k] += s * rv1[k];</a>
<a name="ln133">          }</a>
<a name="ln134">        }</a>
<a name="ln135">        for (k = l; k &lt; n; k++) </a>
<a name="ln136">          a[i*str+k] = a[i*str+k]*scale;</a>
<a name="ln137">      }</a>
<a name="ln138">    }</a>
<a name="ln139">    anorm = MAX(anorm, (fabs(w[i]) + fabs(rv1[i])));</a>
<a name="ln140">  }</a>
<a name="ln141"> </a>
<a name="ln142">  /* accumulate the right-hand transformation */</a>
<a name="ln143">  for (i = n - 1; i &gt;= 0; i--) </a>
<a name="ln144">  {</a>
<a name="ln145">    if (i &lt; n - 1) </a>
<a name="ln146">    {</a>
<a name="ln147">      if (g) </a>
<a name="ln148">      {</a>
<a name="ln149">        for (j = l; j &lt; n; j++)</a>
<a name="ln150">          v[j*n+i] = a[i*str+j] / a[i*str+l] / g;</a>
<a name="ln151">        /* double division to avoid underflow */</a>
<a name="ln152">        for (j = l; j &lt; n; j++) </a>
<a name="ln153">        {</a>
<a name="ln154">          for (s = 0.0, k = l; k &lt; n; k++) </a>
<a name="ln155">            s += a[i*str+k] * v[k*n+j];</a>
<a name="ln156">          for (k = l; k &lt; n; k++) </a>
<a name="ln157">            v[k*n+j] += s * v[k*n+i];</a>
<a name="ln158">        }</a>
<a name="ln159">      }</a>
<a name="ln160">      for (j = l; j &lt; n; j++) </a>
<a name="ln161">        v[i*n+j] = v[j*n+i] = 0.0;</a>
<a name="ln162">    }</a>
<a name="ln163">    v[i*n+i] = 1.0;</a>
<a name="ln164">    g = rv1[i];</a>
<a name="ln165">    l = i;</a>
<a name="ln166">  }</a>
<a name="ln167"> </a>
<a name="ln168">  /* accumulate the left-hand transformation */</a>
<a name="ln169">  for (i = n - 1; i &gt;= 0; i--) </a>
<a name="ln170">  {</a>
<a name="ln171">    l = i + 1;</a>
<a name="ln172">    g = w[i];</a>
<a name="ln173">    if (i &lt; n - 1) </a>
<a name="ln174">      for (j = l; j &lt; n; j++) </a>
<a name="ln175">        a[i*str+j] = 0.0;</a>
<a name="ln176">    if (g) </a>
<a name="ln177">    {</a>
<a name="ln178">      g = 1.0 / g;</a>
<a name="ln179">      if (i != n - 1) </a>
<a name="ln180">      {</a>
<a name="ln181">        for (j = l; j &lt; n; j++) </a>
<a name="ln182">        {</a>
<a name="ln183">          for (s = 0.0, k = l; k &lt; m; k++) </a>
<a name="ln184">            s += a[k*str+i] * a[k*str+j];</a>
<a name="ln185">          f = (s / a[i*str+i]) * g;</a>
<a name="ln186">          for (k = i; k &lt; m; k++) </a>
<a name="ln187">            a[k*str+j] += f * a[k*str+i];</a>
<a name="ln188">        }</a>
<a name="ln189">      }</a>
<a name="ln190">      for (j = i; j &lt; m; j++) </a>
<a name="ln191">        a[j*str+i] = a[j*str+i]*g;</a>
<a name="ln192">    }</a>
<a name="ln193">    else </a>
<a name="ln194">    {</a>
<a name="ln195">      for (j = i; j &lt; m; j++) </a>
<a name="ln196">        a[j*str+i] = 0.0;</a>
<a name="ln197">    }</a>
<a name="ln198">    ++a[i*str+i];</a>
<a name="ln199">  }</a>
<a name="ln200"> </a>
<a name="ln201">  /* diagonalize the bidiagonal form */</a>
<a name="ln202">  for (k = n - 1; k &gt;= 0; k--) </a>
<a name="ln203">  {                             /* loop over singular values */</a>
<a name="ln204">    for (its = 0; its &lt; 30; its++) </a>
<a name="ln205">    {                         /* loop over allowed iterations */</a>
<a name="ln206">      flag = 1;</a>
<a name="ln207">      for (l = k; l &gt;= 0; l--) </a>
<a name="ln208">      {                     /* test for splitting */</a>
<a name="ln209">        nm = MAX(0, l - 1);</a>
<a name="ln210">        if (fabs(rv1[l]) + anorm == anorm) </a>
<a name="ln211">        {</a>
<a name="ln212">          flag = 0;</a>
<a name="ln213">          break;</a>
<a name="ln214">        }</a>
<a name="ln215">        if (l == 0 || fabs(w[nm]) + anorm == anorm)</a>
<a name="ln216">          break;</a>
<a name="ln217">      }</a>
<a name="ln218">      if (flag) </a>
<a name="ln219">      {</a>
<a name="ln220">        c = 0.0;</a>
<a name="ln221">        s = 1.0;</a>
<a name="ln222">        for (i = l; i &lt;= k; i++) </a>
<a name="ln223">        {</a>
<a name="ln224">          f = s * rv1[i];</a>
<a name="ln225">          if (fabs(f) + anorm != anorm) </a>
<a name="ln226">          {</a>
<a name="ln227">            g = w[i];</a>
<a name="ln228">            h = PYTHAG(f, g);</a>
<a name="ln229">            w[i] = h; </a>
<a name="ln230">            h = 1.0 / h;</a>
<a name="ln231">            c = g * h;</a>
<a name="ln232">            s = (- f * h);</a>
<a name="ln233">            for (j = 0; j &lt; m; j++) </a>
<a name="ln234">            {</a>
<a name="ln235">              y = a[j*str+nm];</a>
<a name="ln236">              z = a[j*str+i];</a>
<a name="ln237">              a[j*str+nm] = y * c + z * s;</a>
<a name="ln238">              a[j*str+i]  = z * c - y * s;</a>
<a name="ln239">            }</a>
<a name="ln240">          }</a>
<a name="ln241">        }</a>
<a name="ln242">      }</a>
<a name="ln243">      z = w[k];</a>
<a name="ln244">      if (l == k) </a>
<a name="ln245">      {                  /* convergence */</a>
<a name="ln246">        if (z &lt; 0.0) </a>
<a name="ln247">        {              /* make singular value nonnegative */</a>
<a name="ln248">          w[k] = -z;</a>
<a name="ln249">          for (j = 0; j &lt; n; j++) </a>
<a name="ln250">            v[j*n+k] = (-v[j*n+k]);</a>
<a name="ln251">        }</a>
<a name="ln252">        break;</a>
<a name="ln253">      }</a>
<a name="ln254">      if (its &gt;= 30) {</a>
<a name="ln255">        fprintf(stderr, &quot;[svd] no convergence after 30,000! iterations\n&quot;);</a>
<a name="ln256">        free(rv1);</a>
<a name="ln257">        return 0;</a>
<a name="ln258">      }</a>
<a name="ln259"> </a>
<a name="ln260">      /* shift from bottom 2 x 2 minor */</a>
<a name="ln261">      x = w[l];</a>
<a name="ln262">      nm = k - 1;</a>
<a name="ln263">      y = w[nm];</a>
<a name="ln264">      g = rv1[nm];</a>
<a name="ln265">      h = rv1[k];</a>
<a name="ln266">      f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);</a>
<a name="ln267">      g = PYTHAG(f, 1.0);</a>
<a name="ln268">      f = ((x - z) * (x + z) + h * ((y / (f + SIGN(g, f))) - h)) / x;</a>
<a name="ln269"> </a>
<a name="ln270">      /* next QR transformation */</a>
<a name="ln271">      c = s = 1.0;</a>
<a name="ln272">      for (j = l; j &lt;= nm; j++) </a>
<a name="ln273">      {</a>
<a name="ln274">        i = j + 1;</a>
<a name="ln275">        g = rv1[i];</a>
<a name="ln276">        y = w[i];</a>
<a name="ln277">        h = s * g;</a>
<a name="ln278">        g = c * g;</a>
<a name="ln279">        z = PYTHAG(f, h);</a>
<a name="ln280">        rv1[j] = z;</a>
<a name="ln281">        c = f / z;</a>
<a name="ln282">        s = h / z;</a>
<a name="ln283">        f = x * c + g * s;</a>
<a name="ln284">        g = g * c - x * s;</a>
<a name="ln285">        h = y * s;</a>
<a name="ln286">        y = y * c;</a>
<a name="ln287">        for (jj = 0; jj &lt; n; jj++) </a>
<a name="ln288">        {</a>
<a name="ln289">          x = v[jj*n+j];</a>
<a name="ln290">          z = v[jj*n+i];</a>
<a name="ln291">          v[jj*n+j] = x * c + z * s;</a>
<a name="ln292">          v[jj*n+i] = z * c - x * s;</a>
<a name="ln293">        }</a>
<a name="ln294">        z = PYTHAG(f, h);</a>
<a name="ln295">        w[j] = z;</a>
<a name="ln296">        if (z) </a>
<a name="ln297">        {</a>
<a name="ln298">          z = 1.0 / z;</a>
<a name="ln299">          c = f * z;</a>
<a name="ln300">          s = h * z;</a>
<a name="ln301">        }</a>
<a name="ln302">        f = (c * g) + (s * y);</a>
<a name="ln303">        x = (c * y) - (s * g);</a>
<a name="ln304">        for (jj = 0; jj &lt; m; jj++) </a>
<a name="ln305">        {</a>
<a name="ln306">          y = a[jj*str+j];</a>
<a name="ln307">          z = a[jj*str+i];</a>
<a name="ln308">          a[jj*str+j] = y * c + z * s;</a>
<a name="ln309">          a[jj*str+i] = z * c - y * s;</a>
<a name="ln310">        }</a>
<a name="ln311">      }</a>
<a name="ln312">      rv1[l] = 0.0;</a>
<a name="ln313">      rv1[k] = f;</a>
<a name="ln314">      w[k] = x;</a>
<a name="ln315">    }</a>
<a name="ln316">  }</a>
<a name="ln317">  free(rv1);</a>
<a name="ln318">  return 1;</a>
<a name="ln319">}</a>
<a name="ln320"> </a>

</code></pre>
<div class="balloon" rel="72"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'rv1'. Check lines: 72, 65.</p></div>
<div class="balloon" rel="254"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'its >= 30' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
