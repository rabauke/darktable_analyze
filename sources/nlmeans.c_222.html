
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln22">#include &quot;common/opencl.h&quot;</a>
<a name="ln23">#include &quot;control/control.h&quot;</a>
<a name="ln24">#include &quot;develop/imageop.h&quot;</a>
<a name="ln25">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln26">#include &quot;develop/tiling.h&quot;</a>
<a name="ln27">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln28">#include &quot;gui/gtk.h&quot;</a>
<a name="ln29">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln30">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln31">#include &lt;stdlib.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#if defined(__SSE__)</a>
<a name="ln34">#include &lt;xmmintrin.h&gt;</a>
<a name="ln35">#endif</a>
<a name="ln36"> </a>
<a name="ln37">#define NUM_BUCKETS 4</a>
<a name="ln38"> </a>
<a name="ln39">// this is the version of the modules parameters,</a>
<a name="ln40">// and includes version information about compile-time dt</a>
<a name="ln41">DT_MODULE_INTROSPECTION(2, dt_iop_nlmeans_params_t)</a>
<a name="ln42"> </a>
<a name="ln43">typedef struct dt_iop_nlmeans_params_v1_t</a>
<a name="ln44">{</a>
<a name="ln45">  float luma;</a>
<a name="ln46">  float chroma;</a>
<a name="ln47">} dt_iop_nlmeans_params_v1_t;</a>
<a name="ln48"> </a>
<a name="ln49">typedef struct dt_iop_nlmeans_params_t</a>
<a name="ln50">{</a>
<a name="ln51">  // these are stored in db.</a>
<a name="ln52">  float radius;</a>
<a name="ln53">  float strength;</a>
<a name="ln54">  float luma;</a>
<a name="ln55">  float chroma;</a>
<a name="ln56">} dt_iop_nlmeans_params_t;</a>
<a name="ln57"> </a>
<a name="ln58">typedef struct dt_iop_nlmeans_gui_data_t</a>
<a name="ln59">{</a>
<a name="ln60">  GtkWidget *radius;</a>
<a name="ln61">  GtkWidget *strength;</a>
<a name="ln62">  GtkWidget *luma;</a>
<a name="ln63">  GtkWidget *chroma;</a>
<a name="ln64">} dt_iop_nlmeans_gui_data_t;</a>
<a name="ln65"> </a>
<a name="ln66">typedef dt_iop_nlmeans_params_t dt_iop_nlmeans_data_t;</a>
<a name="ln67"> </a>
<a name="ln68">typedef struct dt_iop_nlmeans_global_data_t</a>
<a name="ln69">{</a>
<a name="ln70">  int kernel_nlmeans_init;</a>
<a name="ln71">  int kernel_nlmeans_dist;</a>
<a name="ln72">  int kernel_nlmeans_horiz;</a>
<a name="ln73">  int kernel_nlmeans_vert;</a>
<a name="ln74">  int kernel_nlmeans_accu;</a>
<a name="ln75">  int kernel_nlmeans_finish;</a>
<a name="ln76">} dt_iop_nlmeans_global_data_t;</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">const char *name()</a>
<a name="ln80">{</a>
<a name="ln81">  return _(&quot;denoise (non-local means)&quot;);</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln85">{</a>
<a name="ln86">  return iop_cs_Lab;</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln90">                  void *new_params, const int new_version)</a>
<a name="ln91">{</a>
<a name="ln92">  if(old_version == 1 &amp;&amp; new_version == 2)</a>
<a name="ln93">  {</a>
<a name="ln94">    dt_iop_nlmeans_params_v1_t *o = (dt_iop_nlmeans_params_v1_t *)old_params;</a>
<a name="ln95">    dt_iop_nlmeans_params_t *n = (dt_iop_nlmeans_params_t *)new_params;</a>
<a name="ln96">    n-&gt;luma = o-&gt;luma;</a>
<a name="ln97">    n-&gt;chroma = o-&gt;chroma;</a>
<a name="ln98">    n-&gt;strength = 100.0f;</a>
<a name="ln99">    n-&gt;radius = 3;</a>
<a name="ln100">    return 0;</a>
<a name="ln101">  }</a>
<a name="ln102">  return 1;</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">int default_group()</a>
<a name="ln106">{</a>
<a name="ln107">  return IOP_GROUP_CORRECT;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">int flags()</a>
<a name="ln111">{</a>
<a name="ln112">  return IOP_FLAGS_SUPPORTS_BLENDING | IOP_FLAGS_ALLOW_TILING;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln116">{</a>
<a name="ln117">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;luma&quot;));</a>
<a name="ln118">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;chroma&quot;));</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln122">{</a>
<a name="ln123">  dt_iop_nlmeans_gui_data_t *g = (dt_iop_nlmeans_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln124"> </a>
<a name="ln125">  dt_accel_connect_slider_iop(self, &quot;luma&quot;, GTK_WIDGET(g-&gt;luma));</a>
<a name="ln126">  dt_accel_connect_slider_iop(self, &quot;chroma&quot;, GTK_WIDGET(g-&gt;chroma));</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129"> </a>
<a name="ln130">typedef union floatint_t</a>
<a name="ln131">{</a>
<a name="ln132">  float f;</a>
<a name="ln133">  uint32_t i;</a>
<a name="ln134">} floatint_t;</a>
<a name="ln135"> </a>
<a name="ln136">static inline float fast_mexp2f(const float x)</a>
<a name="ln137">{</a>
<a name="ln138">  const float i1 = (float)0x3f800000u; // 2^0</a>
<a name="ln139">  const float i2 = (float)0x3f000000u; // 2^-1</a>
<a name="ln140">  const float k0 = i1 + x * (i2 - i1);</a>
<a name="ln141">  floatint_t k;</a>
<a name="ln142">  k.i = k0 &gt;= (float)0x800000u ? k0 : 0;</a>
<a name="ln143">  return k.f;</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">static float gh(const float f, const float sharpness)</a>
<a name="ln147">{</a>
<a name="ln148">  const float f2 = f * sharpness;</a>
<a name="ln149">  return fast_mexp2f(f2);</a>
<a name="ln150">  // return 0.0001f + dt_fast_expf(-fabsf(f)*800.0f);</a>
<a name="ln151">  // return 1.0f/(1.0f + f*f);</a>
<a name="ln152">  // make spread bigger: less smoothing</a>
<a name="ln153">  // const float spread = 100.f;</a>
<a name="ln154">  // return 1.0f/(1.0f + fabsf(f)*spread);</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">#ifdef HAVE_OPENCL</a>
<a name="ln158">static int bucket_next(unsigned int *state, unsigned int max)</a>
<a name="ln159">{</a>
<a name="ln160">  unsigned int current = *state;</a>
<a name="ln161">  unsigned int next = (current &gt;= max - 1 ? 0 : current + 1);</a>
<a name="ln162"> </a>
<a name="ln163">  *state = next;</a>
<a name="ln164"> </a>
<a name="ln165">  return next;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln169">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln170">{</a>
<a name="ln171">  dt_iop_nlmeans_params_t *d = (dt_iop_nlmeans_params_t *)piece-&gt;data;</a>
<a name="ln172">  dt_iop_nlmeans_global_data_t *gd = (dt_iop_nlmeans_global_data_t *)self-&gt;global_data;</a>
<a name="ln173"> </a>
<a name="ln174"> </a>
<a name="ln175">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln176">  const int width = roi_in-&gt;width;</a>
<a name="ln177">  const int height = roi_in-&gt;height;</a>
<a name="ln178"> </a>
<a name="ln179">  cl_mem dev_U2 = NULL;</a>
<a name="ln180">  cl_mem dev_U4 = NULL;</a>
<a name="ln181">  cl_mem dev_U4_t = NULL;</a>
<a name="ln182">  cl_mem dev_U4_tt = NULL;</a>
<a name="ln183"> </a>
<a name="ln184">  unsigned int state = 0;</a>
<a name="ln185">  cl_mem buckets[NUM_BUCKETS] = { NULL };</a>
<a name="ln186"> </a>
<a name="ln187">  cl_int err = -999;</a>
<a name="ln188"> </a>
<a name="ln189">  const int P = ceilf(d-&gt;radius * fmin(roi_in-&gt;scale, 2.0f) / fmax(piece-&gt;iscale, 1.0f)); // pixel filter size</a>
<a name="ln190">  const int K = ceilf(7 * fmin(roi_in-&gt;scale, 2.0f) / fmax(piece-&gt;iscale, 1.0f));         // nbhood</a>
<a name="ln191">  const float sharpness = 3000.0f / (1.0f + d-&gt;strength);</a>
<a name="ln192"> </a>
<a name="ln193">  float max_L = 120.0f, max_C = 512.0f;</a>
<a name="ln194">  float nL = 1.0f / max_L, nC = 1.0f / max_C;</a>
<a name="ln195">  float nL2 = nL * nL, nC2 = nC * nC;</a>
<a name="ln196">  // float weight[4] = { powf(d-&gt;luma, 0.6), powf(d-&gt;chroma, 0.6), powf(d-&gt;chroma, 0.6), 1.0f };</a>
<a name="ln197">  float weight[4] = { d-&gt;luma, d-&gt;chroma, d-&gt;chroma, 1.0f };</a>
<a name="ln198"> </a>
<a name="ln199">  dev_U2 = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln200">  if(dev_U2 == NULL) goto error;</a>
<a name="ln201"> </a>
<a name="ln202">  for(int k = 0; k &lt; NUM_BUCKETS; k++)</a>
<a name="ln203">  {</a>
<a name="ln204">    buckets[k] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * sizeof(float));</a>
<a name="ln205">    if(buckets[k] == NULL) goto error;</a>
<a name="ln206">  }</a>
<a name="ln207"> </a>
<a name="ln208">  int hblocksize;</a>
<a name="ln209">  dt_opencl_local_buffer_t hlocopt</a>
<a name="ln210">    = (dt_opencl_local_buffer_t){ .xoffset = 2 * P, .xfactor = 1, .yoffset = 0, .yfactor = 1,</a>
<a name="ln211">                                  .cellsize = sizeof(float), .overhead = 0,</a>
<a name="ln212">                                  .sizex = 1 &lt;&lt; 16, .sizey = 1 };</a>
<a name="ln213"> </a>
<a name="ln214">  if(dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_nlmeans_horiz, &amp;hlocopt))</a>
<a name="ln215">    hblocksize = hlocopt.sizex;</a>
<a name="ln216">  else</a>
<a name="ln217">    hblocksize = 1;</a>
<a name="ln218"> </a>
<a name="ln219">  int vblocksize;</a>
<a name="ln220">  dt_opencl_local_buffer_t vlocopt</a>
<a name="ln221">    = (dt_opencl_local_buffer_t){ .xoffset = 1, .xfactor = 1, .yoffset = 2 * P, .yfactor = 1,</a>
<a name="ln222">                                  .cellsize = sizeof(float), .overhead = 0,</a>
<a name="ln223">                                  .sizex = 1, .sizey = 1 &lt;&lt; 16 };</a>
<a name="ln224"> </a>
<a name="ln225">  if(dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_nlmeans_vert, &amp;vlocopt))</a>
<a name="ln226">    vblocksize = vlocopt.sizey;</a>
<a name="ln227">  else</a>
<a name="ln228">    vblocksize = 1;</a>
<a name="ln229"> </a>
<a name="ln230"> </a>
<a name="ln231">  const size_t bwidth = ROUNDUP(width, hblocksize);</a>
<a name="ln232">  const size_t bheight = ROUNDUP(height, vblocksize);</a>
<a name="ln233"> </a>
<a name="ln234">  size_t sizesl[3];</a>
<a name="ln235">  size_t local[3];</a>
<a name="ln236">  size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln237"> </a>
<a name="ln238">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_init, 0, sizeof(cl_mem), (void *)&amp;dev_U2);</a>
<a name="ln239">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_init, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln240">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_init, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln241">  err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_nlmeans_init, sizes);</a>
<a name="ln242">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln243"> </a>
<a name="ln244"> </a>
<a name="ln245"> </a>
<a name="ln246">  for(int j = -K; j &lt;= 0; j++)</a>
<a name="ln247">    for(int i = -K; i &lt;= K; i++)</a>
<a name="ln248">    {</a>
<a name="ln249">      int q[2] = { i, j };</a>
<a name="ln250"> </a>
<a name="ln251">      dev_U4 = buckets[bucket_next(&amp;state, NUM_BUCKETS)];</a>
<a name="ln252">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_dist, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln253">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_dist, 1, sizeof(cl_mem), (void *)&amp;dev_U4);</a>
<a name="ln254">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_dist, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln255">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_dist, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln256">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_dist, 4, 2 * sizeof(int), (void *)&amp;q);</a>
<a name="ln257">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_dist, 5, sizeof(float), (void *)&amp;nL2);</a>
<a name="ln258">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_dist, 6, sizeof(float), (void *)&amp;nC2);</a>
<a name="ln259">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_nlmeans_dist, sizes);</a>
<a name="ln260">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln261"> </a>
<a name="ln262">      sizesl[0] = bwidth;</a>
<a name="ln263">      sizesl[1] = ROUNDUPHT(height);</a>
<a name="ln264">      sizesl[2] = 1;</a>
<a name="ln265">      local[0] = hblocksize;</a>
<a name="ln266">      local[1] = 1;</a>
<a name="ln267">      local[2] = 1;</a>
<a name="ln268">      dev_U4_t = buckets[bucket_next(&amp;state, NUM_BUCKETS)];</a>
<a name="ln269">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_horiz, 0, sizeof(cl_mem), (void *)&amp;dev_U4);</a>
<a name="ln270">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_horiz, 1, sizeof(cl_mem), (void *)&amp;dev_U4_t);</a>
<a name="ln271">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_horiz, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln272">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_horiz, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln273">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_horiz, 4, 2 * sizeof(int), (void *)&amp;q);</a>
<a name="ln274">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_horiz, 5, sizeof(int), (void *)&amp;P);</a>
<a name="ln275">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_horiz, 6, (hblocksize + 2 * P) * sizeof(float), NULL);</a>
<a name="ln276">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_nlmeans_horiz, sizesl, local);</a>
<a name="ln277">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln278"> </a>
<a name="ln279"> </a>
<a name="ln280">      sizesl[0] = ROUNDUPWD(width);</a>
<a name="ln281">      sizesl[1] = bheight;</a>
<a name="ln282">      sizesl[2] = 1;</a>
<a name="ln283">      local[0] = 1;</a>
<a name="ln284">      local[1] = vblocksize;</a>
<a name="ln285">      local[2] = 1;</a>
<a name="ln286">      dev_U4_tt = buckets[bucket_next(&amp;state, NUM_BUCKETS)];</a>
<a name="ln287">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_vert, 0, sizeof(cl_mem), (void *)&amp;dev_U4_t);</a>
<a name="ln288">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_vert, 1, sizeof(cl_mem), (void *)&amp;dev_U4_tt);</a>
<a name="ln289">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_vert, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln290">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_vert, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln291">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_vert, 4, 2 * sizeof(int), (void *)&amp;q);</a>
<a name="ln292">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_vert, 5, sizeof(int), (void *)&amp;P);</a>
<a name="ln293">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_vert, 6, sizeof(float), (void *)&amp;sharpness);</a>
<a name="ln294">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_vert, 7, (vblocksize + 2 * P) * sizeof(float), NULL);</a>
<a name="ln295">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_nlmeans_vert, sizesl, local);</a>
<a name="ln296">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln297"> </a>
<a name="ln298"> </a>
<a name="ln299">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_accu, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln300">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_accu, 1, sizeof(cl_mem), (void *)&amp;dev_U2);</a>
<a name="ln301">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_accu, 2, sizeof(cl_mem), (void *)&amp;dev_U4_tt);</a>
<a name="ln302">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_accu, 3, sizeof(int), (void *)&amp;width);</a>
<a name="ln303">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_accu, 4, sizeof(int), (void *)&amp;height);</a>
<a name="ln304">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_accu, 5, 2 * sizeof(int), (void *)&amp;q);</a>
<a name="ln305">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_nlmeans_accu, sizes);</a>
<a name="ln306">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln307"> </a>
<a name="ln308">      if(!darktable.opencl-&gt;async_pixelpipe || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_EXPORT)</a>
<a name="ln309">        dt_opencl_finish(devid);</a>
<a name="ln310"> </a>
<a name="ln311">      // indirectly give gpu some air to breathe (and to do display related stuff)</a>
<a name="ln312">      dt_iop_nap(darktable.opencl-&gt;micro_nap);</a>
<a name="ln313">    }</a>
<a name="ln314"> </a>
<a name="ln315">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_finish, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln316">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_finish, 1, sizeof(cl_mem), (void *)&amp;dev_U2);</a>
<a name="ln317">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_finish, 2, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln318">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_finish, 3, sizeof(int), (void *)&amp;width);</a>
<a name="ln319">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_finish, 4, sizeof(int), (void *)&amp;height);</a>
<a name="ln320">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_nlmeans_finish, 5, 4 * sizeof(float), (void *)&amp;weight);</a>
<a name="ln321">  err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_nlmeans_finish, sizes);</a>
<a name="ln322">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln323"> </a>
<a name="ln324">  dt_opencl_release_mem_object(dev_U2);</a>
<a name="ln325">  for(int k = 0; k &lt; NUM_BUCKETS; k++)</a>
<a name="ln326">  {</a>
<a name="ln327">    dt_opencl_release_mem_object(buckets[k]);</a>
<a name="ln328">  }</a>
<a name="ln329">  return TRUE;</a>
<a name="ln330"> </a>
<a name="ln331">error:</a>
<a name="ln332">  dt_opencl_release_mem_object(dev_U2);</a>
<a name="ln333">  for(int k = 0; k &lt; NUM_BUCKETS; k++)</a>
<a name="ln334">  {</a>
<a name="ln335">    dt_opencl_release_mem_object(buckets[k]);</a>
<a name="ln336">  }</a>
<a name="ln337"> </a>
<a name="ln338">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_nlmeans] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln339">  return FALSE;</a>
<a name="ln340">}</a>
<a name="ln341">#endif</a>
<a name="ln342"> </a>
<a name="ln343"> </a>
<a name="ln344">void tiling_callback(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln345">                     const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out,</a>
<a name="ln346">                     struct dt_develop_tiling_t *tiling)</a>
<a name="ln347">{</a>
<a name="ln348">  dt_iop_nlmeans_params_t *d = (dt_iop_nlmeans_params_t *)piece-&gt;data;</a>
<a name="ln349">  const int P = ceilf(d-&gt;radius * fmin(roi_in-&gt;scale, 2.0f) / fmax(piece-&gt;iscale, 1.0f)); // pixel filter size</a>
<a name="ln350">  const int K = ceilf(7 * fmin(roi_in-&gt;scale, 2.0f) / fmax(piece-&gt;iscale, 1.0f));         // nbhood</a>
<a name="ln351"> </a>
<a name="ln352">  tiling-&gt;factor = 2.0f + 1.0f + 0.25 * NUM_BUCKETS; // in + out + tmp</a>
<a name="ln353">  tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln354">  tiling-&gt;overhead = 0;</a>
<a name="ln355">  tiling-&gt;overlap = P + K;</a>
<a name="ln356">  tiling-&gt;xalign = 1;</a>
<a name="ln357">  tiling-&gt;yalign = 1;</a>
<a name="ln358">  return;</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln362">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln363">{</a>
<a name="ln364">  // this is called for preview and full pipe separately, each with its own pixelpipe piece.</a>
<a name="ln365">  // get our data struct:</a>
<a name="ln366">  const dt_iop_nlmeans_params_t *const d = (dt_iop_nlmeans_params_t *)piece-&gt;data;</a>
<a name="ln367"> </a>
<a name="ln368">  const int ch = piece-&gt;colors;</a>
<a name="ln369"> </a>
<a name="ln370">  // adjust to zoom size:</a>
<a name="ln371">  const int P = ceilf(d-&gt;radius * fmin(roi_in-&gt;scale, 2.0f) / fmax(piece-&gt;iscale, 1.0f)); // pixel filter size</a>
<a name="ln372">  const int K = ceilf(7 * fmin(roi_in-&gt;scale, 2.0f) / fmax(piece-&gt;iscale, 1.0f));         // nbhood</a>
<a name="ln373">  const float sharpness = 3000.0f / (1.0f + d-&gt;strength);</a>
<a name="ln374"> </a>
<a name="ln375">  // adjust to Lab, make L more important</a>
<a name="ln376">  // float max_L = 100.0f, max_C = 256.0f;</a>
<a name="ln377">  // float nL = 1.0f/(d-&gt;luma*max_L), nC = 1.0f/(d-&gt;chroma*max_C);</a>
<a name="ln378">  float max_L = 120.0f, max_C = 512.0f;</a>
<a name="ln379">  float nL = 1.0f / max_L, nC = 1.0f / max_C;</a>
<a name="ln380">  const float norm2[4] = { nL * nL, nC * nC, nC * nC, 1.0f };</a>
<a name="ln381"> </a>
<a name="ln382">  float *Sa = dt_alloc_align(64, (size_t)sizeof(float) * roi_out-&gt;width * dt_get_num_threads());</a>
<a name="ln383">  // we want to sum up weights in col[3], so need to init to 0:</a>
<a name="ln384">  memset(ovoid, 0x0, (size_t)sizeof(float) * roi_out-&gt;width * roi_out-&gt;height * 4);</a>
<a name="ln385"> </a>
<a name="ln386">  // for each shift vector</a>
<a name="ln387">  for(int kj = -K; kj &lt;= K; kj++)</a>
<a name="ln388">  {</a>
<a name="ln389">    for(int ki = -K; ki &lt;= K; ki++)</a>
<a name="ln390">    {</a>
<a name="ln391">      int inited_slide = 0;</a>
<a name="ln392">// don't construct summed area tables but use sliding window! (applies to cpu version res &lt; 1k only, or else</a>
<a name="ln393">// we will add up errors)</a>
<a name="ln394">// do this in parallel with a little threading overhead. could parallelize the outer loops with a bit more</a>
<a name="ln395">// memory</a>
<a name="ln396">#ifdef _OPENMP</a>
<a name="ln397">#pragma omp parallel for default(none) \</a>
<a name="ln398">      dt_omp_firstprivate(ivoid, norm2, ovoid, P, roi_in, roi_out, sharpness) \</a>
<a name="ln399">      firstprivate(inited_slide) \</a>
<a name="ln400">      shared(kj, ki, Sa) \</a>
<a name="ln401">      schedule(static)</a>
<a name="ln402">#endif</a>
<a name="ln403">      for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln404">      {</a>
<a name="ln405">        if(j + kj &lt; 0 || j + kj &gt;= roi_out-&gt;height) continue;</a>
<a name="ln406">        float *S = Sa + (size_t)dt_get_thread_num() * roi_out-&gt;width;</a>
<a name="ln407">        const float *ins = ((float *)ivoid) + 4 * ((size_t)roi_in-&gt;width * (j + kj) + ki);</a>
<a name="ln408">        float *out = ((float *)ovoid) + 4 * (size_t)roi_out-&gt;width * j;</a>
<a name="ln409"> </a>
<a name="ln410">        const int Pm = MIN(MIN(P, j + kj), j);</a>
<a name="ln411">        const int PM = MIN(MIN(P, roi_out-&gt;height - 1 - j - kj), roi_out-&gt;height - 1 - j);</a>
<a name="ln412">        // first line of every thread</a>
<a name="ln413">        // TODO: also every once in a while to assert numerical precision!</a>
<a name="ln414">        if(!inited_slide)</a>
<a name="ln415">        {</a>
<a name="ln416">          // sum up a line</a>
<a name="ln417">          memset(S, 0x0, sizeof(float) * roi_out-&gt;width);</a>
<a name="ln418">          for(int jj = -Pm; jj &lt;= PM; jj++)</a>
<a name="ln419">          {</a>
<a name="ln420">            int i = MAX(0, -ki);</a>
<a name="ln421">            float *s = S + i;</a>
<a name="ln422">            const float *inp = ((float *)ivoid) + 4 * i + 4 * (size_t)roi_in-&gt;width * (j + jj);</a>
<a name="ln423">            const float *inps = ((float *)ivoid) + 4 * i + 4 * ((size_t)roi_in-&gt;width * (j + jj + kj) + ki);</a>
<a name="ln424">            const int last = roi_out-&gt;width + MIN(0, -ki);</a>
<a name="ln425">            for(; i &lt; last; i++, inp += 4, inps += 4, s++)</a>
<a name="ln426">            {</a>
<a name="ln427">              for(int k = 0; k &lt; 3; k++) s[0] += (inp[k] - inps[k]) * (inp[k] - inps[k]) * norm2[k];</a>
<a name="ln428">            }</a>
<a name="ln429">          }</a>
<a name="ln430">          // only reuse this if we had a full stripe</a>
<a name="ln431">          if(Pm == P &amp;&amp; PM == P) inited_slide = 1;</a>
<a name="ln432">        }</a>
<a name="ln433"> </a>
<a name="ln434">        // sliding window for this line:</a>
<a name="ln435">        float *s = S;</a>
<a name="ln436">        float slide = 0.0f;</a>
<a name="ln437">        // sum up the first -P..P</a>
<a name="ln438">        for(int i = 0; i &lt; 2 * P + 1; i++) slide += s[i];</a>
<a name="ln439">        for(int i = 0; i &lt; roi_out-&gt;width; i++, s++, ins += 4, out += 4)</a>
<a name="ln440">        {</a>
<a name="ln441">          if(i - P &gt; 0 &amp;&amp; i + P &lt; roi_out-&gt;width) slide += s[P] - s[-P - 1];</a>
<a name="ln442">          if(i + ki &gt;= 0 &amp;&amp; i + ki &lt; roi_out-&gt;width)</a>
<a name="ln443">          {</a>
<a name="ln444">            const float iv[4] = { ins[0], ins[1], ins[2], 1.0f };</a>
<a name="ln445">#if defined(_OPENMP) &amp;&amp; defined(OPENMP_SIMD_)</a>
<a name="ln446">#pragma omp SIMD()</a>
<a name="ln447">#endif</a>
<a name="ln448">            for(size_t c = 0; c &lt; 4; c++)</a>
<a name="ln449">            {</a>
<a name="ln450">              out[c] += iv[c] * gh(slide, sharpness);</a>
<a name="ln451">            }</a>
<a name="ln452">          }</a>
<a name="ln453">        }</a>
<a name="ln454">        if(inited_slide &amp;&amp; j + P + 1 + MAX(0, kj) &lt; roi_out-&gt;height)</a>
<a name="ln455">        {</a>
<a name="ln456">          // sliding window in j direction:</a>
<a name="ln457">          int i = MAX(0, -ki);</a>
<a name="ln458">          s = S + i;</a>
<a name="ln459">          const float *inp = ((float *)ivoid) + 4 * i + 4 * (size_t)roi_in-&gt;width * (j + P + 1);</a>
<a name="ln460">          const float *inps = ((float *)ivoid) + 4 * i + 4 * ((size_t)roi_in-&gt;width * (j + P + 1 + kj) + ki);</a>
<a name="ln461">          const float *inm = ((float *)ivoid) + 4 * i + 4 * (size_t)roi_in-&gt;width * (j - P);</a>
<a name="ln462">          const float *inms = ((float *)ivoid) + 4 * i + 4 * ((size_t)roi_in-&gt;width * (j - P + kj) + ki);</a>
<a name="ln463">          const int last = roi_out-&gt;width + MIN(0, -ki);</a>
<a name="ln464">          for(; i &lt; last; i++, inp += 4, inps += 4, inm += 4, inms += 4, s++)</a>
<a name="ln465">          {</a>
<a name="ln466">            float stmp = s[0];</a>
<a name="ln467">            for(int k = 0; k &lt; 3; k++)</a>
<a name="ln468">              stmp += ((inp[k] - inps[k]) * (inp[k] - inps[k]) - (inm[k] - inms[k]) * (inm[k] - inms[k]))</a>
<a name="ln469">                      * norm2[k];</a>
<a name="ln470">            s[0] = stmp;</a>
<a name="ln471">          }</a>
<a name="ln472">        }</a>
<a name="ln473">        else</a>
<a name="ln474">          inited_slide = 0;</a>
<a name="ln475">      }</a>
<a name="ln476">    }</a>
<a name="ln477">  }</a>
<a name="ln478"> </a>
<a name="ln479">  // normalize and apply chroma/luma blending</a>
<a name="ln480">  const float weight[4] = { d-&gt;luma, d-&gt;chroma, d-&gt;chroma, 1.0f };</a>
<a name="ln481">  const float invert[4] = { 1.0f - d-&gt;luma, 1.0f - d-&gt;chroma, 1.0f - d-&gt;chroma, 0.0f };</a>
<a name="ln482"> </a>
<a name="ln483">  const float *const in = ((const float *const)ivoid);</a>
<a name="ln484">  float *const out = ((float *const)ovoid);</a>
<a name="ln485"> </a>
<a name="ln486">#ifdef _OPENMP</a>
<a name="ln487">#pragma omp parallel for SIMD() default(none) \</a>
<a name="ln488">  dt_omp_firstprivate(ch, in, invert, out, roi_out, weight) \</a>
<a name="ln489">  schedule(static) \</a>
<a name="ln490">  collapse(2)</a>
<a name="ln491">#endif</a>
<a name="ln492">  for(size_t k = 0; k &lt; (size_t)ch * roi_out-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln493">  {</a>
<a name="ln494">    for(size_t c = 0; c &lt; 4; c++)</a>
<a name="ln495">    {</a>
<a name="ln496">      out[k + c] = (in[k + c] * invert[c]) + (out[k + c] * (weight[c] / out[k + 3]));</a>
<a name="ln497">    }</a>
<a name="ln498">  }</a>
<a name="ln499"> </a>
<a name="ln500">  // free shared tmp memory:</a>
<a name="ln501">  dt_free_align(Sa);</a>
<a name="ln502"> </a>
<a name="ln503">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">#if defined(__SSE__)</a>
<a name="ln507">/** process, all real work is done here. */</a>
<a name="ln508">void process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln509">                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln510">{</a>
<a name="ln511">  // this is called for preview and full pipe separately, each with its own pixelpipe piece.</a>
<a name="ln512">  // get our data struct:</a>
<a name="ln513">  dt_iop_nlmeans_params_t *d = (dt_iop_nlmeans_params_t *)piece-&gt;data;</a>
<a name="ln514"> </a>
<a name="ln515">  // adjust to zoom size:</a>
<a name="ln516">  const int P = ceilf(d-&gt;radius * fmin(roi_in-&gt;scale, 2.0f) / fmax(piece-&gt;iscale, 1.0f)); // pixel filter size</a>
<a name="ln517">  const int K = ceilf(7 * fmin(roi_in-&gt;scale, 2.0f) / fmax(piece-&gt;iscale, 1.0f));         // nbhood</a>
<a name="ln518">  const float sharpness = 3000.0f / (1.0f + d-&gt;strength);</a>
<a name="ln519"> </a>
<a name="ln520">  // adjust to Lab, make L more important</a>
<a name="ln521">  // float max_L = 100.0f, max_C = 256.0f;</a>
<a name="ln522">  // float nL = 1.0f/(d-&gt;luma*max_L), nC = 1.0f/(d-&gt;chroma*max_C);</a>
<a name="ln523">  float max_L = 120.0f, max_C = 512.0f;</a>
<a name="ln524">  float nL = 1.0f / max_L, nC = 1.0f / max_C;</a>
<a name="ln525">  const float norm2[4] = { nL * nL, nC * nC, nC * nC, 1.0f };</a>
<a name="ln526"> </a>
<a name="ln527">  float *Sa = dt_alloc_align(64, (size_t)sizeof(float) * roi_out-&gt;width * dt_get_num_threads());</a>
<a name="ln528">  // we want to sum up weights in col[3], so need to init to 0:</a>
<a name="ln529">  memset(ovoid, 0x0, (size_t)sizeof(float) * roi_out-&gt;width * roi_out-&gt;height * 4);</a>
<a name="ln530"> </a>
<a name="ln531">  // for each shift vector</a>
<a name="ln532">  for(int kj = -K; kj &lt;= K; kj++)</a>
<a name="ln533">  {</a>
<a name="ln534">    for(int ki = -K; ki &lt;= K; ki++)</a>
<a name="ln535">    {</a>
<a name="ln536">      int inited_slide = 0;</a>
<a name="ln537">// don't construct summed area tables but use sliding window! (applies to cpu version res &lt; 1k only, or else</a>
<a name="ln538">// we will add up errors)</a>
<a name="ln539">// do this in parallel with a little threading overhead. could parallelize the outer loops with a bit more</a>
<a name="ln540">// memory</a>
<a name="ln541">#ifdef _OPENMP</a>
<a name="ln542">#pragma omp parallel for default(none) \</a>
<a name="ln543">  dt_omp_firstprivate(ivoid, norm2, ovoid, P, roi_in, roi_out, sharpness) \</a>
<a name="ln544">  firstprivate(inited_slide) \</a>
<a name="ln545">  shared(kj, ki, Sa) \</a>
<a name="ln546">  schedule(static)</a>
<a name="ln547">#endif</a>
<a name="ln548">      for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln549">      {</a>
<a name="ln550">        if(j + kj &lt; 0 || j + kj &gt;= roi_out-&gt;height) continue;</a>
<a name="ln551">        float *S = Sa + (size_t)dt_get_thread_num() * roi_out-&gt;width;</a>
<a name="ln552">        const float *ins = ((float *)ivoid) + 4 * ((size_t)roi_in-&gt;width * (j + kj) + ki);</a>
<a name="ln553">        float *out = ((float *)ovoid) + 4 * (size_t)roi_out-&gt;width * j;</a>
<a name="ln554"> </a>
<a name="ln555">        const int Pm = MIN(MIN(P, j + kj), j);</a>
<a name="ln556">        const int PM = MIN(MIN(P, roi_out-&gt;height - 1 - j - kj), roi_out-&gt;height - 1 - j);</a>
<a name="ln557">        // first line of every thread</a>
<a name="ln558">        // TODO: also every once in a while to assert numerical precision!</a>
<a name="ln559">        if(!inited_slide)</a>
<a name="ln560">        {</a>
<a name="ln561">          // sum up a line</a>
<a name="ln562">          memset(S, 0x0, sizeof(float) * roi_out-&gt;width);</a>
<a name="ln563">          for(int jj = -Pm; jj &lt;= PM; jj++)</a>
<a name="ln564">          {</a>
<a name="ln565">            int i = MAX(0, -ki);</a>
<a name="ln566">            float *s = S + i;</a>
<a name="ln567">            const float *inp = ((float *)ivoid) + 4 * i + 4 * (size_t)roi_in-&gt;width * (j + jj);</a>
<a name="ln568">            const float *inps = ((float *)ivoid) + 4 * i + 4 * ((size_t)roi_in-&gt;width * (j + jj + kj) + ki);</a>
<a name="ln569">            const int last = roi_out-&gt;width + MIN(0, -ki);</a>
<a name="ln570">            for(; i &lt; last; i++, inp += 4, inps += 4, s++)</a>
<a name="ln571">            {</a>
<a name="ln572">              for(int k = 0; k &lt; 3; k++) s[0] += (inp[k] - inps[k]) * (inp[k] - inps[k]) * norm2[k];</a>
<a name="ln573">            }</a>
<a name="ln574">          }</a>
<a name="ln575">          // only reuse this if we had a full stripe</a>
<a name="ln576">          if(Pm == P &amp;&amp; PM == P) inited_slide = 1;</a>
<a name="ln577">        }</a>
<a name="ln578"> </a>
<a name="ln579">        // sliding window for this line:</a>
<a name="ln580">        float *s = S;</a>
<a name="ln581">        float slide = 0.0f;</a>
<a name="ln582">        // sum up the first -P..P</a>
<a name="ln583">        for(int i = 0; i &lt; 2 * P + 1; i++) slide += s[i];</a>
<a name="ln584">        for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln585">        {</a>
<a name="ln586">          if(i - P &gt; 0 &amp;&amp; i + P &lt; roi_out-&gt;width) slide += s[P] - s[-P - 1];</a>
<a name="ln587">          if(i + ki &gt;= 0 &amp;&amp; i + ki &lt; roi_out-&gt;width)</a>
<a name="ln588">          {</a>
<a name="ln589">            const __m128 iv = { ins[0], ins[1], ins[2], 1.0f };</a>
<a name="ln590">            _mm_store_ps(out, _mm_load_ps(out) + iv * _mm_set1_ps(gh(slide, sharpness)));</a>
<a name="ln591">          }</a>
<a name="ln592">          s++;</a>
<a name="ln593">          ins += 4;</a>
<a name="ln594">          out += 4;</a>
<a name="ln595">        }</a>
<a name="ln596">        if(inited_slide &amp;&amp; j + P + 1 + MAX(0, kj) &lt; roi_out-&gt;height)</a>
<a name="ln597">        {</a>
<a name="ln598">          // sliding window in j direction:</a>
<a name="ln599">          int i = MAX(0, -ki);</a>
<a name="ln600">          s = S + i;</a>
<a name="ln601">          const float *inp = ((float *)ivoid) + 4 * i + 4 * (size_t)roi_in-&gt;width * (j + P + 1);</a>
<a name="ln602">          const float *inps = ((float *)ivoid) + 4 * i + 4 * ((size_t)roi_in-&gt;width * (j + P + 1 + kj) + ki);</a>
<a name="ln603">          const float *inm = ((float *)ivoid) + 4 * i + 4 * (size_t)roi_in-&gt;width * (j - P);</a>
<a name="ln604">          const float *inms = ((float *)ivoid) + 4 * i + 4 * ((size_t)roi_in-&gt;width * (j - P + kj) + ki);</a>
<a name="ln605">          const int last = roi_out-&gt;width + MIN(0, -ki);</a>
<a name="ln606">          for(; ((intptr_t)s &amp; 0xf) != 0 &amp;&amp; i &lt; last; i++, inp += 4, inps += 4, inm += 4, inms += 4, s++)</a>
<a name="ln607">          {</a>
<a name="ln608">            float stmp = s[0];</a>
<a name="ln609">            for(int k = 0; k &lt; 3; k++)</a>
<a name="ln610">              stmp += ((inp[k] - inps[k]) * (inp[k] - inps[k]) - (inm[k] - inms[k]) * (inm[k] - inms[k]))</a>
<a name="ln611">                      * norm2[k];</a>
<a name="ln612">            s[0] = stmp;</a>
<a name="ln613">          }</a>
<a name="ln614">          /* Process most of the line 4 pixels at a time */</a>
<a name="ln615">          for(; i &lt; last - 4; i += 4, inp += 16, inps += 16, inm += 16, inms += 16, s += 4)</a>
<a name="ln616">          {</a>
<a name="ln617">            __m128 sv = _mm_load_ps(s);</a>
<a name="ln618">            const __m128 inp1 = _mm_load_ps(inp) - _mm_load_ps(inps);</a>
<a name="ln619">            const __m128 inp2 = _mm_load_ps(inp + 4) - _mm_load_ps(inps + 4);</a>
<a name="ln620">            const __m128 inp3 = _mm_load_ps(inp + 8) - _mm_load_ps(inps + 8);</a>
<a name="ln621">            const __m128 inp4 = _mm_load_ps(inp + 12) - _mm_load_ps(inps + 12);</a>
<a name="ln622"> </a>
<a name="ln623">            const __m128 inp12lo = _mm_unpacklo_ps(inp1, inp2);</a>
<a name="ln624">            const __m128 inp34lo = _mm_unpacklo_ps(inp3, inp4);</a>
<a name="ln625">            const __m128 inp12hi = _mm_unpackhi_ps(inp1, inp2);</a>
<a name="ln626">            const __m128 inp34hi = _mm_unpackhi_ps(inp3, inp4);</a>
<a name="ln627"> </a>
<a name="ln628">            const __m128 inpv0 = _mm_movelh_ps(inp12lo, inp34lo);</a>
<a name="ln629">            sv += inpv0 * inpv0 * _mm_set1_ps(norm2[0]);</a>
<a name="ln630"> </a>
<a name="ln631">            const __m128 inpv1 = _mm_movehl_ps(inp34lo, inp12lo);</a>
<a name="ln632">            sv += inpv1 * inpv1 * _mm_set1_ps(norm2[1]);</a>
<a name="ln633"> </a>
<a name="ln634">            const __m128 inpv2 = _mm_movelh_ps(inp12hi, inp34hi);</a>
<a name="ln635">            sv += inpv2 * inpv2 * _mm_set1_ps(norm2[2]);</a>
<a name="ln636"> </a>
<a name="ln637">            const __m128 inm1 = _mm_load_ps(inm) - _mm_load_ps(inms);</a>
<a name="ln638">            const __m128 inm2 = _mm_load_ps(inm + 4) - _mm_load_ps(inms + 4);</a>
<a name="ln639">            const __m128 inm3 = _mm_load_ps(inm + 8) - _mm_load_ps(inms + 8);</a>
<a name="ln640">            const __m128 inm4 = _mm_load_ps(inm + 12) - _mm_load_ps(inms + 12);</a>
<a name="ln641"> </a>
<a name="ln642">            const __m128 inm12lo = _mm_unpacklo_ps(inm1, inm2);</a>
<a name="ln643">            const __m128 inm34lo = _mm_unpacklo_ps(inm3, inm4);</a>
<a name="ln644">            const __m128 inm12hi = _mm_unpackhi_ps(inm1, inm2);</a>
<a name="ln645">            const __m128 inm34hi = _mm_unpackhi_ps(inm3, inm4);</a>
<a name="ln646"> </a>
<a name="ln647">            const __m128 inmv0 = _mm_movelh_ps(inm12lo, inm34lo);</a>
<a name="ln648">            sv -= inmv0 * inmv0 * _mm_set1_ps(norm2[0]);</a>
<a name="ln649"> </a>
<a name="ln650">            const __m128 inmv1 = _mm_movehl_ps(inm34lo, inm12lo);</a>
<a name="ln651">            sv -= inmv1 * inmv1 * _mm_set1_ps(norm2[1]);</a>
<a name="ln652"> </a>
<a name="ln653">            const __m128 inmv2 = _mm_movelh_ps(inm12hi, inm34hi);</a>
<a name="ln654">            sv -= inmv2 * inmv2 * _mm_set1_ps(norm2[2]);</a>
<a name="ln655"> </a>
<a name="ln656">            _mm_store_ps(s, sv);</a>
<a name="ln657">          }</a>
<a name="ln658">          for(; i &lt; last; i++, inp += 4, inps += 4, inm += 4, inms += 4, s++)</a>
<a name="ln659">          {</a>
<a name="ln660">            float stmp = s[0];</a>
<a name="ln661">            for(int k = 0; k &lt; 3; k++)</a>
<a name="ln662">              stmp += ((inp[k] - inps[k]) * (inp[k] - inps[k]) - (inm[k] - inms[k]) * (inm[k] - inms[k]))</a>
<a name="ln663">                      * norm2[k];</a>
<a name="ln664">            s[0] = stmp;</a>
<a name="ln665">          }</a>
<a name="ln666">        }</a>
<a name="ln667">        else</a>
<a name="ln668">          inited_slide = 0;</a>
<a name="ln669">      }</a>
<a name="ln670">    }</a>
<a name="ln671">  }</a>
<a name="ln672">  // normalize and apply chroma/luma blending</a>
<a name="ln673">  // bias a bit towards higher values for low input values:</a>
<a name="ln674">  // const __m128 weight = _mm_set_ps(1.0f, powf(d-&gt;chroma, 0.6), powf(d-&gt;chroma, 0.6), powf(d-&gt;luma, 0.6));</a>
<a name="ln675">  const __m128 weight = _mm_set_ps(1.0f, d-&gt;chroma, d-&gt;chroma, d-&gt;luma);</a>
<a name="ln676">  const __m128 invert = _mm_sub_ps(_mm_set1_ps(1.0f), weight);</a>
<a name="ln677">#ifdef _OPENMP</a>
<a name="ln678">#pragma omp parallel for default(none) \</a>
<a name="ln679">  dt_omp_firstprivate(invert, ivoid, ovoid, roi_out, weight) \</a>
<a name="ln680">  shared(d) \</a>
<a name="ln681">  schedule(static)</a>
<a name="ln682">#endif</a>
<a name="ln683">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln684">  {</a>
<a name="ln685">    float *out = ((float *)ovoid) + 4 * (size_t)roi_out-&gt;width * j;</a>
<a name="ln686">    float *in = ((float *)ivoid) + 4 * (size_t)roi_out-&gt;width * j;</a>
<a name="ln687">    for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln688">    {</a>
<a name="ln689">      _mm_store_ps(out, _mm_add_ps(_mm_mul_ps(_mm_load_ps(in), invert),</a>
<a name="ln690">                                   _mm_mul_ps(_mm_load_ps(out), _mm_div_ps(weight, _mm_set1_ps(out[3])))));</a>
<a name="ln691">      out += 4;</a>
<a name="ln692">      in += 4;</a>
<a name="ln693">    }</a>
<a name="ln694">  }</a>
<a name="ln695">  // free shared tmp memory:</a>
<a name="ln696">  dt_free_align(Sa);</a>
<a name="ln697"> </a>
<a name="ln698">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln699">}</a>
<a name="ln700">#endif</a>
<a name="ln701"> </a>
<a name="ln702">/** this will be called to init new defaults if a new image is loaded from film strip mode. */</a>
<a name="ln703">void reload_defaults(dt_iop_module_t *module)</a>
<a name="ln704">{</a>
<a name="ln705">  // our module is disabled by default</a>
<a name="ln706">  module-&gt;default_enabled = 0;</a>
<a name="ln707">  // init defaults:</a>
<a name="ln708">  dt_iop_nlmeans_params_t tmp = (dt_iop_nlmeans_params_t){ 2.0f, 50.0f, 0.5f, 1.0f };</a>
<a name="ln709">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_nlmeans_params_t));</a>
<a name="ln710">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_nlmeans_params_t));</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">/** init, cleanup, commit to pipeline */</a>
<a name="ln714">void init(dt_iop_module_t *module)</a>
<a name="ln715">{</a>
<a name="ln716">  module-&gt;params = calloc(1, sizeof(dt_iop_nlmeans_params_t));</a>
<a name="ln717">  module-&gt;default_params = calloc(1, sizeof(dt_iop_nlmeans_params_t));</a>
<a name="ln718">  // about the first thing to do in Lab space:</a>
<a name="ln719">  module-&gt;params_size = sizeof(dt_iop_nlmeans_params_t);</a>
<a name="ln720">  module-&gt;gui_data = NULL;</a>
<a name="ln721">  module-&gt;global_data = NULL;</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724">void cleanup(dt_iop_module_t *module)</a>
<a name="ln725">{</a>
<a name="ln726">  free(module-&gt;params);</a>
<a name="ln727">  module-&gt;params = NULL;</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln731">{</a>
<a name="ln732">  const int program = 5; // nlmeans.cl, from programs.conf</a>
<a name="ln733">  dt_iop_nlmeans_global_data_t *gd</a>
<a name="ln734">      = (dt_iop_nlmeans_global_data_t *)malloc(sizeof(dt_iop_nlmeans_global_data_t));</a>
<a name="ln735">  module-&gt;data = gd;</a>
<a name="ln736">  gd-&gt;kernel_nlmeans_init = dt_opencl_create_kernel(program, &quot;nlmeans_init&quot;);</a>
<a name="ln737">  gd-&gt;kernel_nlmeans_dist = dt_opencl_create_kernel(program, &quot;nlmeans_dist&quot;);</a>
<a name="ln738">  gd-&gt;kernel_nlmeans_horiz = dt_opencl_create_kernel(program, &quot;nlmeans_horiz&quot;);</a>
<a name="ln739">  gd-&gt;kernel_nlmeans_vert = dt_opencl_create_kernel(program, &quot;nlmeans_vert&quot;);</a>
<a name="ln740">  gd-&gt;kernel_nlmeans_accu = dt_opencl_create_kernel(program, &quot;nlmeans_accu&quot;);</a>
<a name="ln741">  gd-&gt;kernel_nlmeans_finish = dt_opencl_create_kernel(program, &quot;nlmeans_finish&quot;);</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln745">{</a>
<a name="ln746">  dt_iop_nlmeans_global_data_t *gd = (dt_iop_nlmeans_global_data_t *)module-&gt;data;</a>
<a name="ln747">  dt_opencl_free_kernel(gd-&gt;kernel_nlmeans_init);</a>
<a name="ln748">  dt_opencl_free_kernel(gd-&gt;kernel_nlmeans_dist);</a>
<a name="ln749">  dt_opencl_free_kernel(gd-&gt;kernel_nlmeans_horiz);</a>
<a name="ln750">  dt_opencl_free_kernel(gd-&gt;kernel_nlmeans_vert);</a>
<a name="ln751">  dt_opencl_free_kernel(gd-&gt;kernel_nlmeans_accu);</a>
<a name="ln752">  dt_opencl_free_kernel(gd-&gt;kernel_nlmeans_finish);</a>
<a name="ln753">  free(module-&gt;data);</a>
<a name="ln754">  module-&gt;data = NULL;</a>
<a name="ln755">}</a>
<a name="ln756"> </a>
<a name="ln757">/** commit is the synch point between core and gui, so it copies params to pipe data. */</a>
<a name="ln758">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *params, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln759">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln760">{</a>
<a name="ln761">  dt_iop_nlmeans_params_t *p = (dt_iop_nlmeans_params_t *)params;</a>
<a name="ln762">  dt_iop_nlmeans_data_t *d = (dt_iop_nlmeans_data_t *)piece-&gt;data;</a>
<a name="ln763">  memcpy(d, p, sizeof(*d));</a>
<a name="ln764">  d-&gt;luma = MAX(0.0001f, p-&gt;luma);</a>
<a name="ln765">  d-&gt;chroma = MAX(0.0001f, p-&gt;chroma);</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln769">{</a>
<a name="ln770">  piece-&gt;data = malloc(sizeof(dt_iop_nlmeans_data_t));</a>
<a name="ln771">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln775">{</a>
<a name="ln776">  free(piece-&gt;data);</a>
<a name="ln777">  piece-&gt;data = NULL;</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780">static void radius_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln781">{</a>
<a name="ln782">  // this is important to avoid cycles!</a>
<a name="ln783">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln784">  dt_iop_nlmeans_params_t *p = (dt_iop_nlmeans_params_t *)self-&gt;params;</a>
<a name="ln785">  p-&gt;radius = (int)dt_bauhaus_slider_get(w);</a>
<a name="ln786">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln787">}</a>
<a name="ln788">static void strength_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln789">{</a>
<a name="ln790">  // this is important to avoid cycles!</a>
<a name="ln791">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln792">  dt_iop_nlmeans_params_t *p = (dt_iop_nlmeans_params_t *)self-&gt;params;</a>
<a name="ln793">  p-&gt;strength = dt_bauhaus_slider_get(w);</a>
<a name="ln794">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln795">}</a>
<a name="ln796">static void luma_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln797">{</a>
<a name="ln798">  // this is important to avoid cycles!</a>
<a name="ln799">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln800">  dt_iop_nlmeans_params_t *p = (dt_iop_nlmeans_params_t *)self-&gt;params;</a>
<a name="ln801">  p-&gt;luma = dt_bauhaus_slider_get(w) * (1.0f / 100.0f);</a>
<a name="ln802">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">static void chroma_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln806">{</a>
<a name="ln807">  // this is important to avoid cycles!</a>
<a name="ln808">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln809">  dt_iop_nlmeans_params_t *p = (dt_iop_nlmeans_params_t *)self-&gt;params;</a>
<a name="ln810">  p-&gt;chroma = dt_bauhaus_slider_get(w) * (1.0f / 100.0f);</a>
<a name="ln811">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814">/** gui callbacks, these are needed. */</a>
<a name="ln815">void gui_update(dt_iop_module_t *self)</a>
<a name="ln816">{</a>
<a name="ln817">  // let gui slider match current parameters:</a>
<a name="ln818">  dt_iop_nlmeans_gui_data_t *g = (dt_iop_nlmeans_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln819">  dt_iop_nlmeans_params_t *p = (dt_iop_nlmeans_params_t *)self-&gt;params;</a>
<a name="ln820">  dt_bauhaus_slider_set_soft(g-&gt;radius, p-&gt;radius);</a>
<a name="ln821">  dt_bauhaus_slider_set_soft(g-&gt;strength, p-&gt;strength);</a>
<a name="ln822">  dt_bauhaus_slider_set(g-&gt;luma, p-&gt;luma * 100.f);</a>
<a name="ln823">  dt_bauhaus_slider_set(g-&gt;chroma, p-&gt;chroma * 100.f);</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">void gui_init(dt_iop_module_t *self)</a>
<a name="ln827">{</a>
<a name="ln828">  // init the slider (more sophisticated layouts are possible with gtk tables and boxes):</a>
<a name="ln829">  self-&gt;gui_data = malloc(sizeof(dt_iop_nlmeans_gui_data_t));</a>
<a name="ln830">  dt_iop_nlmeans_gui_data_t *g = (dt_iop_nlmeans_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln831">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln832">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln833">  g-&gt;radius = dt_bauhaus_slider_new_with_range(self, 1.0f, 4.0f, 1., 2.f, 0);</a>
<a name="ln834">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;radius, 0.0, 10.0);</a>
<a name="ln835">  g-&gt;strength = dt_bauhaus_slider_new_with_range(self, 0.0f, 100.0f, 1., 50.f, 0);</a>
<a name="ln836">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;strength, 0.0f, 100000.0f);</a>
<a name="ln837">  g-&gt;luma = dt_bauhaus_slider_new_with_range(self, 0.0f, 100.0f, 1., 50.f, 0);</a>
<a name="ln838">  g-&gt;chroma = dt_bauhaus_slider_new_with_range(self, 0.0f, 100.0f, 1., 100.f, 0);</a>
<a name="ln839">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;radius, TRUE, TRUE, 0);</a>
<a name="ln840">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;strength, TRUE, TRUE, 0);</a>
<a name="ln841">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;luma, TRUE, TRUE, 0);</a>
<a name="ln842">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;chroma, TRUE, TRUE, 0);</a>
<a name="ln843">  dt_bauhaus_widget_set_label(g-&gt;radius, NULL, _(&quot;patch size&quot;));</a>
<a name="ln844">  dt_bauhaus_slider_set_format(g-&gt;radius, &quot;%.0f&quot;);</a>
<a name="ln845">  dt_bauhaus_widget_set_label(g-&gt;strength, NULL, _(&quot;strength&quot;));</a>
<a name="ln846">  dt_bauhaus_slider_set_format(g-&gt;strength, &quot;%.0f%%&quot;);</a>
<a name="ln847">  dt_bauhaus_widget_set_label(g-&gt;luma, NULL, _(&quot;luma&quot;));</a>
<a name="ln848">  dt_bauhaus_slider_set_format(g-&gt;luma, &quot;%.0f%%&quot;);</a>
<a name="ln849">  dt_bauhaus_widget_set_label(g-&gt;chroma, NULL, _(&quot;chroma&quot;));</a>
<a name="ln850">  dt_bauhaus_slider_set_format(g-&gt;chroma, &quot;%.0f%%&quot;);</a>
<a name="ln851">  gtk_widget_set_tooltip_text(g-&gt;radius, _(&quot;radius of the patches to match&quot;));</a>
<a name="ln852">  gtk_widget_set_tooltip_text(g-&gt;strength, _(&quot;strength of the effect&quot;));</a>
<a name="ln853">  gtk_widget_set_tooltip_text(g-&gt;luma, _(&quot;how much to smooth brightness&quot;));</a>
<a name="ln854">  gtk_widget_set_tooltip_text(g-&gt;chroma, _(&quot;how much to smooth colors&quot;));</a>
<a name="ln855">  g_signal_connect(G_OBJECT(g-&gt;radius), &quot;value-changed&quot;, G_CALLBACK(radius_callback), self);</a>
<a name="ln856">  g_signal_connect(G_OBJECT(g-&gt;strength), &quot;value-changed&quot;, G_CALLBACK(strength_callback), self);</a>
<a name="ln857">  g_signal_connect(G_OBJECT(g-&gt;luma), &quot;value-changed&quot;, G_CALLBACK(luma_callback), self);</a>
<a name="ln858">  g_signal_connect(G_OBJECT(g-&gt;chroma), &quot;value-changed&quot;, G_CALLBACK(chroma_callback), self);</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861">void gui_cleanup(dt_iop_module_t *self)</a>
<a name="ln862">{</a>
<a name="ln863">  // nothing else necessary, gtk will clean up the slider.</a>
<a name="ln864">  free(self-&gt;gui_data);</a>
<a name="ln865">  self-&gt;gui_data = NULL;</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln869">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln870">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="736"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 736, 734.</p></div>
<div class="balloon" rel="833"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 833, 829.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
