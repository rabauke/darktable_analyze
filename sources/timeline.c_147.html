
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2018-2019 Aldric Renaudin.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/collection.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/debug.h&quot;</a>
<a name="ln22">#include &quot;control/control.h&quot;</a>
<a name="ln23">#include &quot;develop/develop.h&quot;</a>
<a name="ln24">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln25">#include &quot;gui/gtk.h&quot;</a>
<a name="ln26">#include &quot;libs/lib.h&quot;</a>
<a name="ln27">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln28">#include &quot;views/view.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">DT_MODULE(1)</a>
<a name="ln31"> </a>
<a name="ln32">typedef enum dt_lib_timeline_zooms_t {</a>
<a name="ln33">  DT_LIB_TIMELINE_ZOOM_YEAR = 0,</a>
<a name="ln34">  DT_LIB_TIMELINE_ZOOM_4MONTH,</a>
<a name="ln35">  DT_LIB_TIMELINE_ZOOM_MONTH,</a>
<a name="ln36">  DT_LIB_TIMELINE_ZOOM_10DAY,</a>
<a name="ln37">  DT_LIB_TIMELINE_ZOOM_DAY,</a>
<a name="ln38">  DT_LIB_TIMELINE_ZOOM_6HOUR,</a>
<a name="ln39">  DT_LIB_TIMELINE_ZOOM_HOUR,</a>
<a name="ln40">  DT_LIB_TIMELINE_ZOOM_10MINUTE,</a>
<a name="ln41">  DT_LIB_TIMELINE_ZOOM_MINUTE</a>
<a name="ln42">} dt_lib_timeline_zooms_t;</a>
<a name="ln43"> </a>
<a name="ln44">typedef enum dt_lib_timeline_mode_t {</a>
<a name="ln45">  DT_LIB_TIMELINE_MODE_AND = 0,</a>
<a name="ln46">  DT_LIB_TIMELINE_MODE_RESET</a>
<a name="ln47">} dt_lib_timeline_mode_t;</a>
<a name="ln48"> </a>
<a name="ln49">typedef struct dt_lib_timeline_time_t</a>
<a name="ln50">{</a>
<a name="ln51">  int year;</a>
<a name="ln52">  int month;</a>
<a name="ln53">  int day;</a>
<a name="ln54">  int hour;</a>
<a name="ln55">  int minute;</a>
<a name="ln56"> </a>
<a name="ln57">} dt_lib_timeline_time_t;</a>
<a name="ln58"> </a>
<a name="ln59">typedef struct dt_lib_timeline_block_t</a>
<a name="ln60">{</a>
<a name="ln61">  gchar *name;</a>
<a name="ln62">  int *values;</a>
<a name="ln63">  int *collect_values;</a>
<a name="ln64">  int values_count;</a>
<a name="ln65">  dt_lib_timeline_time_t init;</a>
<a name="ln66">  int width;</a>
<a name="ln67"> </a>
<a name="ln68">} dt_lib_timeline_block_t;</a>
<a name="ln69"> </a>
<a name="ln70"> </a>
<a name="ln71"> </a>
<a name="ln72">typedef struct dt_lib_timeline_t</a>
<a name="ln73">{</a>
<a name="ln74">  dt_lib_timeline_time_t time_mini;</a>
<a name="ln75">  dt_lib_timeline_time_t time_maxi;</a>
<a name="ln76">  dt_lib_timeline_time_t time_pos;</a>
<a name="ln77"> </a>
<a name="ln78">  GtkWidget *timeline;</a>
<a name="ln79">  cairo_surface_t *surface;</a>
<a name="ln80">  int surface_width;</a>
<a name="ln81">  int surface_height;</a>
<a name="ln82">  int32_t panel_width;</a>
<a name="ln83"> </a>
<a name="ln84">  GList *blocks;</a>
<a name="ln85">  dt_lib_timeline_zooms_t zoom;</a>
<a name="ln86">  dt_lib_timeline_zooms_t precision;</a>
<a name="ln87"> </a>
<a name="ln88">  int start_x;</a>
<a name="ln89">  int stop_x;</a>
<a name="ln90">  int current_x;</a>
<a name="ln91">  dt_lib_timeline_time_t start_t;</a>
<a name="ln92">  dt_lib_timeline_time_t stop_t;</a>
<a name="ln93">  gboolean has_selection;</a>
<a name="ln94">  gboolean selecting;</a>
<a name="ln95">  gboolean move_edge;</a>
<a name="ln96"> </a>
<a name="ln97">  gboolean autoscroll;</a>
<a name="ln98">  gboolean in;</a>
<a name="ln99"> </a>
<a name="ln100">  gboolean size_handle_is_dragging;</a>
<a name="ln101">  gint size_handle_x, size_handle_y;</a>
<a name="ln102">  int32_t size_handle_height;</a>
<a name="ln103"> </a>
<a name="ln104">} dt_lib_timeline_t;</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107"> </a>
<a name="ln108">const char *name(dt_lib_module_t *self)</a>
<a name="ln109">{</a>
<a name="ln110">  return _(&quot;timeline&quot;);</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">const char **views(dt_lib_module_t *self)</a>
<a name="ln114">{</a>
<a name="ln115">  static const char *v[] = { &quot;lighttable&quot;, NULL };</a>
<a name="ln116">  return v;</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln120">{</a>
<a name="ln121">  return DT_UI_CONTAINER_PANEL_BOTTOM;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">int expandable(dt_lib_module_t *self)</a>
<a name="ln125">{</a>
<a name="ln126">  return 0;</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">int position()</a>
<a name="ln130">{</a>
<a name="ln131">  return 1002;</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">// get the number of days in a given month</a>
<a name="ln135">static int _time_days_in_month(int year, int month)</a>
<a name="ln136">{</a>
<a name="ln137">  switch(month)</a>
<a name="ln138">  {</a>
<a name="ln139">    case 2:</a>
<a name="ln140">      if((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0))</a>
<a name="ln141">        return 29;</a>
<a name="ln142">      else</a>
<a name="ln143">        return 28;</a>
<a name="ln144">    case 1:</a>
<a name="ln145">    case 3:</a>
<a name="ln146">    case 5:</a>
<a name="ln147">    case 7:</a>
<a name="ln148">    case 8:</a>
<a name="ln149">    case 10:</a>
<a name="ln150">    case 12:</a>
<a name="ln151">      return 31;</a>
<a name="ln152">    default:</a>
<a name="ln153">      return 30;</a>
<a name="ln154">  }</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">// free blocks</a>
<a name="ln158">static void _block_free(gpointer data)</a>
<a name="ln159">{</a>
<a name="ln160">  dt_lib_timeline_block_t *bloc = (dt_lib_timeline_block_t *)data;</a>
<a name="ln161">  if(bloc)</a>
<a name="ln162">  {</a>
<a name="ln163">    g_free(bloc-&gt;name);</a>
<a name="ln164">    free(bloc-&gt;values);</a>
<a name="ln165">    free(bloc-&gt;collect_values);</a>
<a name="ln166">    free(bloc);</a>
<a name="ln167">  }</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">// get the width of each bar in the graph, depending of the zoom level</a>
<a name="ln171">static int _block_get_bar_width(dt_lib_timeline_zooms_t zoom)</a>
<a name="ln172">{</a>
<a name="ln173">  if(zoom == DT_LIB_TIMELINE_ZOOM_YEAR)</a>
<a name="ln174">    return 10;</a>
<a name="ln175">  else if(zoom == DT_LIB_TIMELINE_ZOOM_4MONTH)</a>
<a name="ln176">    return 1;</a>
<a name="ln177">  else if(zoom == DT_LIB_TIMELINE_ZOOM_MONTH)</a>
<a name="ln178">    return 4;</a>
<a name="ln179">  else if(zoom == DT_LIB_TIMELINE_ZOOM_10DAY)</a>
<a name="ln180">    return 1;</a>
<a name="ln181">  else if(zoom == DT_LIB_TIMELINE_ZOOM_DAY)</a>
<a name="ln182">    return 5;</a>
<a name="ln183">  else if(zoom == DT_LIB_TIMELINE_ZOOM_6HOUR)</a>
<a name="ln184">    return 1;</a>
<a name="ln185">  else if(zoom == DT_LIB_TIMELINE_ZOOM_HOUR)</a>
<a name="ln186">    return 2;</a>
<a name="ln187">  return 1; /* dummy value */</a>
<a name="ln188">}</a>
<a name="ln189">// get the number of bar in a block</a>
<a name="ln190">static int _block_get_bar_count(dt_lib_timeline_time_t t, dt_lib_timeline_zooms_t zoom)</a>
<a name="ln191">{</a>
<a name="ln192">  if(zoom == DT_LIB_TIMELINE_ZOOM_YEAR)</a>
<a name="ln193">    return 12;</a>
<a name="ln194">  else if(zoom == DT_LIB_TIMELINE_ZOOM_4MONTH)</a>
<a name="ln195">  {</a>
<a name="ln196">    int ti = (t.month - 1) / 4 * 4 + 1;</a>
<a name="ln197">    return _time_days_in_month(t.year, ti) + _time_days_in_month(t.year, ti + 1)</a>
<a name="ln198">           + _time_days_in_month(t.year, ti + 2) + _time_days_in_month(t.year, ti + 3);</a>
<a name="ln199">  }</a>
<a name="ln200">  else if(zoom == DT_LIB_TIMELINE_ZOOM_MONTH)</a>
<a name="ln201">    return _time_days_in_month(t.year, t.month);</a>
<a name="ln202">  else if(zoom == DT_LIB_TIMELINE_ZOOM_10DAY)</a>
<a name="ln203">    return 120;</a>
<a name="ln204">  else if(zoom == DT_LIB_TIMELINE_ZOOM_DAY)</a>
<a name="ln205">    return 24;</a>
<a name="ln206">  else if(zoom == DT_LIB_TIMELINE_ZOOM_6HOUR)</a>
<a name="ln207">    return 120;</a>
<a name="ln208">  else if(zoom == DT_LIB_TIMELINE_ZOOM_HOUR)</a>
<a name="ln209">    return 60;</a>
<a name="ln210">  return 1; /* dummy value */</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">static int _block_get_bar_height(int nb, int max_height)</a>
<a name="ln214">{</a>
<a name="ln215">  // we want height to be between 0 and max_height</a>
<a name="ln216">  // small value should have visible height</a>
<a name="ln217">  return max_height * (1.0 - 2.0 / sqrtf(nb + 4.0));</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220">// init time</a>
<a name="ln221">static dt_lib_timeline_time_t _time_init()</a>
<a name="ln222">{</a>
<a name="ln223">  dt_lib_timeline_time_t tt = { 0 };</a>
<a name="ln224">  // we don't want 0 values for month and day</a>
<a name="ln225">  tt.month = tt.day = 1;</a>
<a name="ln226">  return tt;</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">// compare times</a>
<a name="ln230">static int _time_compare_at_zoom(dt_lib_timeline_time_t t1, dt_lib_timeline_time_t t2, dt_lib_timeline_zooms_t zoom)</a>
<a name="ln231">{</a>
<a name="ln232">  if(t1.year != t2.year) return (t1.year - t2.year);</a>
<a name="ln233">  if(zoom &gt;= DT_LIB_TIMELINE_ZOOM_YEAR)</a>
<a name="ln234">  {</a>
<a name="ln235">    if(t1.month != t2.month) return (t1.month - t2.month);</a>
<a name="ln236">    if(zoom &gt;= DT_LIB_TIMELINE_ZOOM_4MONTH)</a>
<a name="ln237">    {</a>
<a name="ln238">      if(t1.day != t2.day) return (t1.day - t2.day);</a>
<a name="ln239">      if(zoom &gt;= DT_LIB_TIMELINE_ZOOM_10DAY)</a>
<a name="ln240">      {</a>
<a name="ln241">        if(t1.hour / 2 != t2.hour / 2) return (t1.hour / 2 - t2.hour / 2);</a>
<a name="ln242">        if(zoom &gt;= DT_LIB_TIMELINE_ZOOM_DAY)</a>
<a name="ln243">        {</a>
<a name="ln244">          if(t1.hour != t2.hour) return (t1.hour - t2.hour);</a>
<a name="ln245">          if(zoom &gt;= DT_LIB_TIMELINE_ZOOM_6HOUR)</a>
<a name="ln246">          {</a>
<a name="ln247">            if(t1.minute / 3 != t2.minute / 3) return (t1.minute / 3 - t2.minute / 3);</a>
<a name="ln248">            if(zoom &gt;= DT_LIB_TIMELINE_ZOOM_HOUR)</a>
<a name="ln249">            {</a>
<a name="ln250">              if(t1.minute != t2.minute) return (t1.minute - t2.minute);</a>
<a name="ln251">            }</a>
<a name="ln252">          }</a>
<a name="ln253">        }</a>
<a name="ln254">      }</a>
<a name="ln255">    }</a>
<a name="ln256">  }</a>
<a name="ln257"> </a>
<a name="ln258">  return 0;</a>
<a name="ln259">}</a>
<a name="ln260">static int _time_compare(dt_lib_timeline_time_t t1, dt_lib_timeline_time_t t2)</a>
<a name="ln261">{</a>
<a name="ln262">  if(t1.year != t2.year) return (t1.year - t2.year);</a>
<a name="ln263">  if(t1.month != t2.month) return (t1.month - t2.month);</a>
<a name="ln264">  if(t1.day != t2.day) return (t1.day - t2.day);</a>
<a name="ln265">  if(t1.hour != t2.hour) return (t1.hour - t2.hour);</a>
<a name="ln266">  if(t1.minute != t2.minute) return (t1.minute - t2.minute);</a>
<a name="ln267"> </a>
<a name="ln268">  return 0;</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">// add/substract value to a time at certain level</a>
<a name="ln272">static void _time_add(dt_lib_timeline_time_t *t, int val, dt_lib_timeline_zooms_t level)</a>
<a name="ln273">{</a>
<a name="ln274">  if(level == DT_LIB_TIMELINE_ZOOM_YEAR)</a>
<a name="ln275">  {</a>
<a name="ln276">    t-&gt;year += val;</a>
<a name="ln277">  }</a>
<a name="ln278">  else if(level == DT_LIB_TIMELINE_ZOOM_4MONTH)</a>
<a name="ln279">  {</a>
<a name="ln280">    t-&gt;month += val * 4;</a>
<a name="ln281">    while(t-&gt;month &gt; 12)</a>
<a name="ln282">    {</a>
<a name="ln283">      t-&gt;year++;</a>
<a name="ln284">      t-&gt;month -= 12;</a>
<a name="ln285">    }</a>
<a name="ln286">    while(t-&gt;month &lt; 1)</a>
<a name="ln287">    {</a>
<a name="ln288">      t-&gt;year--;</a>
<a name="ln289">      t-&gt;month += 12;</a>
<a name="ln290">    }</a>
<a name="ln291">  }</a>
<a name="ln292">  else if(level == DT_LIB_TIMELINE_ZOOM_MONTH)</a>
<a name="ln293">  {</a>
<a name="ln294">    t-&gt;month += val;</a>
<a name="ln295">    while(t-&gt;month &gt; 12)</a>
<a name="ln296">    {</a>
<a name="ln297">      t-&gt;year++;</a>
<a name="ln298">      t-&gt;month -= 12;</a>
<a name="ln299">    }</a>
<a name="ln300">    while(t-&gt;month &lt; 1)</a>
<a name="ln301">    {</a>
<a name="ln302">      t-&gt;year--;</a>
<a name="ln303">      t-&gt;month += 12;</a>
<a name="ln304">    }</a>
<a name="ln305">  }</a>
<a name="ln306">  else if(level == DT_LIB_TIMELINE_ZOOM_10DAY)</a>
<a name="ln307">  {</a>
<a name="ln308">    t-&gt;day += val * 10;</a>
<a name="ln309">    while(t-&gt;day &gt; _time_days_in_month(t-&gt;year, t-&gt;month))</a>
<a name="ln310">    {</a>
<a name="ln311">      t-&gt;day -= _time_days_in_month(t-&gt;year, t-&gt;month);</a>
<a name="ln312">      _time_add(t, 1, DT_LIB_TIMELINE_ZOOM_MONTH);</a>
<a name="ln313">    }</a>
<a name="ln314">    while(t-&gt;day &lt; 1)</a>
<a name="ln315">    {</a>
<a name="ln316">      _time_add(t, -1, DT_LIB_TIMELINE_ZOOM_MONTH);</a>
<a name="ln317">      t-&gt;day += _time_days_in_month(t-&gt;year, t-&gt;month);</a>
<a name="ln318">    }</a>
<a name="ln319">  }</a>
<a name="ln320">  else if(level == DT_LIB_TIMELINE_ZOOM_DAY)</a>
<a name="ln321">  {</a>
<a name="ln322">    t-&gt;day += val;</a>
<a name="ln323">    while(t-&gt;day &gt; _time_days_in_month(t-&gt;year, t-&gt;month))</a>
<a name="ln324">    {</a>
<a name="ln325">      t-&gt;day -= _time_days_in_month(t-&gt;year, t-&gt;month);</a>
<a name="ln326">      _time_add(t, 1, DT_LIB_TIMELINE_ZOOM_MONTH);</a>
<a name="ln327">    }</a>
<a name="ln328">    while(t-&gt;day &lt; 1)</a>
<a name="ln329">    {</a>
<a name="ln330">      _time_add(t, -1, DT_LIB_TIMELINE_ZOOM_MONTH);</a>
<a name="ln331">      t-&gt;day += _time_days_in_month(t-&gt;year, t-&gt;month);</a>
<a name="ln332">    }</a>
<a name="ln333">  }</a>
<a name="ln334">  else if(level == DT_LIB_TIMELINE_ZOOM_6HOUR)</a>
<a name="ln335">  {</a>
<a name="ln336">    t-&gt;hour += val * 6;</a>
<a name="ln337">    while(t-&gt;hour &gt; 23)</a>
<a name="ln338">    {</a>
<a name="ln339">      t-&gt;hour -= 24;</a>
<a name="ln340">      _time_add(t, 1, DT_LIB_TIMELINE_ZOOM_DAY);</a>
<a name="ln341">    }</a>
<a name="ln342">    while(t-&gt;hour &lt; 0)</a>
<a name="ln343">    {</a>
<a name="ln344">      t-&gt;hour += 24;</a>
<a name="ln345">      _time_add(t, -1, DT_LIB_TIMELINE_ZOOM_DAY);</a>
<a name="ln346">    }</a>
<a name="ln347">  }</a>
<a name="ln348">  else if(level == DT_LIB_TIMELINE_ZOOM_HOUR)</a>
<a name="ln349">  {</a>
<a name="ln350">    t-&gt;hour += val;</a>
<a name="ln351">    while(t-&gt;hour &gt; 23)</a>
<a name="ln352">    {</a>
<a name="ln353">      t-&gt;hour -= 24;</a>
<a name="ln354">      _time_add(t, 1, DT_LIB_TIMELINE_ZOOM_DAY);</a>
<a name="ln355">    }</a>
<a name="ln356">    while(t-&gt;hour &lt; 0)</a>
<a name="ln357">    {</a>
<a name="ln358">      t-&gt;hour += 24;</a>
<a name="ln359">      _time_add(t, -1, DT_LIB_TIMELINE_ZOOM_DAY);</a>
<a name="ln360">    }</a>
<a name="ln361">  }</a>
<a name="ln362">  else if(level == DT_LIB_TIMELINE_ZOOM_MINUTE)</a>
<a name="ln363">  {</a>
<a name="ln364">    t-&gt;minute += val;</a>
<a name="ln365">    while(t-&gt;minute &gt; 59)</a>
<a name="ln366">    {</a>
<a name="ln367">      t-&gt;minute -= 60;</a>
<a name="ln368">      _time_add(t, 1, DT_LIB_TIMELINE_ZOOM_HOUR);</a>
<a name="ln369">    }</a>
<a name="ln370">    while(t-&gt;minute &lt; 0)</a>
<a name="ln371">    {</a>
<a name="ln372">      t-&gt;hour += 60;</a>
<a name="ln373">      _time_add(t, -1, DT_LIB_TIMELINE_ZOOM_HOUR);</a>
<a name="ln374">    }</a>
<a name="ln375">  }</a>
<a name="ln376"> </a>
<a name="ln377">  // fix for date with year set to 0 (bug ?)</a>
<a name="ln378">  if(t-&gt;year &lt; 0) t-&gt;year = 0;</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">// retrieve the date from the position at given zoom level</a>
<a name="ln382">static dt_lib_timeline_time_t _time_get_from_pos(int pos, dt_lib_timeline_t *strip)</a>
<a name="ln383">{</a>
<a name="ln384">  dt_lib_timeline_time_t tt = _time_init();</a>
<a name="ln385"> </a>
<a name="ln386">  int x = 0;</a>
<a name="ln387">  GList *bl = strip-&gt;blocks;</a>
<a name="ln388">  while(bl)</a>
<a name="ln389">  {</a>
<a name="ln390">    dt_lib_timeline_block_t *blo = bl-&gt;data;</a>
<a name="ln391">    if(pos &lt; x + blo-&gt;width)</a>
<a name="ln392">    {</a>
<a name="ln393">      tt.year = blo-&gt;init.year;</a>
<a name="ln394">      if(strip-&gt;zoom &gt;= DT_LIB_TIMELINE_ZOOM_4MONTH) tt.month = blo-&gt;init.month;</a>
<a name="ln395">      if(strip-&gt;zoom &gt;= DT_LIB_TIMELINE_ZOOM_10DAY) tt.day = blo-&gt;init.day;</a>
<a name="ln396">      if(strip-&gt;zoom &gt;= DT_LIB_TIMELINE_ZOOM_6HOUR) tt.hour = blo-&gt;init.hour;</a>
<a name="ln397"> </a>
<a name="ln398">      if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_YEAR)</a>
<a name="ln399">      {</a>
<a name="ln400">        tt.month = (pos - x) / _block_get_bar_width(strip-&gt;zoom) + 1;</a>
<a name="ln401">        if(tt.month &lt; 1) tt.month = 1;</a>
<a name="ln402">      }</a>
<a name="ln403">      else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_4MONTH)</a>
<a name="ln404">      {</a>
<a name="ln405">        int nb = (pos - x) / _block_get_bar_width(strip-&gt;zoom) + 1;</a>
<a name="ln406">        _time_add(&amp;tt, nb, DT_LIB_TIMELINE_ZOOM_DAY);</a>
<a name="ln407">        if(tt.day &lt; 1) tt.day = 1;</a>
<a name="ln408">      }</a>
<a name="ln409">      else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_MONTH)</a>
<a name="ln410">      {</a>
<a name="ln411">        tt.day = (pos - x) / _block_get_bar_width(strip-&gt;zoom) + 1;</a>
<a name="ln412">        if(tt.day &lt; 1) tt.day = 1;</a>
<a name="ln413">      }</a>
<a name="ln414">      else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_10DAY)</a>
<a name="ln415">      {</a>
<a name="ln416">        int nb = (pos - x) / _block_get_bar_width(strip-&gt;zoom) + 1;</a>
<a name="ln417">        _time_add(&amp;tt, nb * 2, DT_LIB_TIMELINE_ZOOM_HOUR);</a>
<a name="ln418">        if(tt.hour &lt; 0) tt.hour = 0;</a>
<a name="ln419">      }</a>
<a name="ln420">      else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_DAY)</a>
<a name="ln421">      {</a>
<a name="ln422">        tt.hour = (pos - x) / _block_get_bar_width(strip-&gt;zoom) + 1;</a>
<a name="ln423">        if(tt.hour &lt; 0) tt.hour = 0;</a>
<a name="ln424">      }</a>
<a name="ln425">      else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_6HOUR)</a>
<a name="ln426">      {</a>
<a name="ln427">        int nb = (pos - x) / _block_get_bar_width(strip-&gt;zoom) + 1;</a>
<a name="ln428">        _time_add(&amp;tt, nb * 3, DT_LIB_TIMELINE_ZOOM_MINUTE);</a>
<a name="ln429">        if(tt.minute &lt; 0) tt.minute = 0;</a>
<a name="ln430">      }</a>
<a name="ln431">      else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_HOUR)</a>
<a name="ln432">      {</a>
<a name="ln433">        tt.minute = (pos - x) / _block_get_bar_width(strip-&gt;zoom) + 1;</a>
<a name="ln434">        if(tt.minute &lt; 0) tt.minute = 0;</a>
<a name="ln435">      }</a>
<a name="ln436"> </a>
<a name="ln437">      return tt;</a>
<a name="ln438">    }</a>
<a name="ln439">    x += blo-&gt;width + 2;</a>
<a name="ln440">    bl = bl-&gt;next;</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443">  return tt;</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446">static dt_lib_timeline_time_t _time_compute_offset_for_zoom(int pos, dt_lib_timeline_t *strip,</a>
<a name="ln447">                                                            dt_lib_timeline_zooms_t new_zoom)</a>
<a name="ln448">{</a>
<a name="ln449">  if(new_zoom == strip-&gt;zoom) return strip-&gt;time_pos;</a>
<a name="ln450"> </a>
<a name="ln451">  dt_lib_timeline_time_t tt = _time_get_from_pos(pos, strip);</a>
<a name="ln452"> </a>
<a name="ln453">  // we search the number of the bloc under pos</a>
<a name="ln454">  int bloc_nb = 0;</a>
<a name="ln455">  int x = 0;</a>
<a name="ln456">  GList *bl = strip-&gt;blocks;</a>
<a name="ln457">  while(bl)</a>
<a name="ln458">  {</a>
<a name="ln459">    dt_lib_timeline_block_t *blo = bl-&gt;data;</a>
<a name="ln460">    if(pos &lt; x + blo-&gt;width) break;</a>
<a name="ln461">    x += blo-&gt;width + 2;</a>
<a name="ln462">    bl = bl-&gt;next;</a>
<a name="ln463">    bloc_nb++;</a>
<a name="ln464">  }</a>
<a name="ln465">  if(!bl)</a>
<a name="ln466">  {</a>
<a name="ln467">    // we are outside the timeline</a>
<a name="ln468">  }</a>
<a name="ln469"> </a>
<a name="ln470">  // we translate to the new date_pos at new_zoom level</a>
<a name="ln471">  _time_add(&amp;tt, -bloc_nb, new_zoom);</a>
<a name="ln472"> </a>
<a name="ln473">  // we need to verify that we are not out of the bounds</a>
<a name="ln474">  if(_time_compare(tt, strip-&gt;time_mini) &lt; 0) tt = strip-&gt;time_mini;</a>
<a name="ln475">  return tt;</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">static gchar *_time_format_for_ui(dt_lib_timeline_time_t t, dt_lib_timeline_zooms_t zoom)</a>
<a name="ln479">{</a>
<a name="ln480">  if(zoom == DT_LIB_TIMELINE_ZOOM_YEAR)</a>
<a name="ln481">  {</a>
<a name="ln482">    return g_strdup_printf(&quot;%04d&quot;, t.year);</a>
<a name="ln483">  }</a>
<a name="ln484">  else if(zoom == DT_LIB_TIMELINE_ZOOM_4MONTH)</a>
<a name="ln485">  {</a>
<a name="ln486">    int x = (t.month - 1) / 4 * 4 + 1; // This is NOT a no-op (rounding)</a>
<a name="ln487">    return g_strdup_printf(&quot;(%02d-%02d)/%04d&quot;, x, x + 3, t.year);</a>
<a name="ln488">  }</a>
<a name="ln489">  else if(zoom == DT_LIB_TIMELINE_ZOOM_MONTH)</a>
<a name="ln490">  {</a>
<a name="ln491">    return g_strdup_printf(&quot;%02d/%04d&quot;, t.month, t.year);</a>
<a name="ln492">  }</a>
<a name="ln493">  else if(zoom == DT_LIB_TIMELINE_ZOOM_10DAY)</a>
<a name="ln494">  {</a>
<a name="ln495">    int x = (t.day - 1) / 10 * 10 + 1; // This is NOT a no-op (rounding)</a>
<a name="ln496">    int x2 = x + 9;</a>
<a name="ln497">    if(x2 == 30) x2 = _time_days_in_month(t.year, t.month);</a>
<a name="ln498">    return g_strdup_printf(&quot;(%02d-%02d)/%02d/%02d&quot;, x, x2, t.month, t.year % 100);</a>
<a name="ln499">  }</a>
<a name="ln500">  else if(zoom == DT_LIB_TIMELINE_ZOOM_DAY)</a>
<a name="ln501">  {</a>
<a name="ln502">    return g_strdup_printf(&quot;%02d/%02d/%02d&quot;, t.day, t.month, t.year % 100);</a>
<a name="ln503">  }</a>
<a name="ln504">  else if(zoom == DT_LIB_TIMELINE_ZOOM_6HOUR)</a>
<a name="ln505">  {</a>
<a name="ln506">    return g_strdup_printf(&quot;%02d/%02d/%02d (%02dh-%02dh)&quot;, t.day, t.month, t.year % 100, t.hour / 6 * 6,</a>
<a name="ln507">                           t.hour / 6 * 6 + 5);</a>
<a name="ln508">  }</a>
<a name="ln509">  else if(zoom == DT_LIB_TIMELINE_ZOOM_HOUR)</a>
<a name="ln510">  {</a>
<a name="ln511">    return g_strdup_printf(&quot;%02d/%02d/%02d %02dh&quot;, t.day, t.month, t.year % 100, t.hour);</a>
<a name="ln512">  }</a>
<a name="ln513">  else if(zoom == DT_LIB_TIMELINE_ZOOM_10MINUTE)</a>
<a name="ln514">  {</a>
<a name="ln515">    return g_strdup_printf(&quot;%02d/%02d/%02d %02dh(%02d-%02d)&quot;, t.day, t.month, t.year % 100, t.hour,</a>
<a name="ln516">                           t.minute / 10 * 10, t.minute / 10 * 10 + 9);</a>
<a name="ln517">  }</a>
<a name="ln518">  else if(zoom == DT_LIB_TIMELINE_ZOOM_MINUTE)</a>
<a name="ln519">  {</a>
<a name="ln520">    return g_strdup_printf(&quot;%02d/%02d/%02d %02dh%02d&quot;, t.day, t.month, t.year % 100, t.hour, t.minute);</a>
<a name="ln521">  }</a>
<a name="ln522"> </a>
<a name="ln523">  return NULL;</a>
<a name="ln524">}</a>
<a name="ln525">static gchar *_time_format_for_db(dt_lib_timeline_time_t t, dt_lib_timeline_zooms_t zoom, gboolean full)</a>
<a name="ln526">{</a>
<a name="ln527">  if(zoom == DT_LIB_TIMELINE_ZOOM_YEAR)</a>
<a name="ln528">  {</a>
<a name="ln529">    if(full)</a>
<a name="ln530">      return g_strdup_printf(&quot;%04d:01:01 00:00:00&quot;, t.year);</a>
<a name="ln531">    else</a>
<a name="ln532">      return g_strdup_printf(&quot;%04d&quot;, t.year);</a>
<a name="ln533">  }</a>
<a name="ln534">  else if(zoom == DT_LIB_TIMELINE_ZOOM_4MONTH || zoom == DT_LIB_TIMELINE_ZOOM_MONTH)</a>
<a name="ln535">  {</a>
<a name="ln536">    if(full)</a>
<a name="ln537">      return g_strdup_printf(&quot;%04d:%02d:01 00:00:00&quot;, t.year, t.month);</a>
<a name="ln538">    else</a>
<a name="ln539">      return g_strdup_printf(&quot;%04d:%02d&quot;, t.year, t.month);</a>
<a name="ln540">  }</a>
<a name="ln541">  else if(zoom == DT_LIB_TIMELINE_ZOOM_10DAY || zoom == DT_LIB_TIMELINE_ZOOM_DAY)</a>
<a name="ln542">  {</a>
<a name="ln543">    if(full)</a>
<a name="ln544">      return g_strdup_printf(&quot;%04d:%02d:%02d 00:00:00&quot;, t.year, t.month, t.day);</a>
<a name="ln545">    else</a>
<a name="ln546">      return g_strdup_printf(&quot;%04d:%02d:%02d&quot;, t.year, t.month, t.day);</a>
<a name="ln547">  }</a>
<a name="ln548">  else if(zoom == DT_LIB_TIMELINE_ZOOM_6HOUR || zoom == DT_LIB_TIMELINE_ZOOM_HOUR)</a>
<a name="ln549">  {</a>
<a name="ln550">    if(full)</a>
<a name="ln551">      return g_strdup_printf(&quot;%04d:%02d:%02d %02d:00:00&quot;, t.year, t.month, t.day, t.hour);</a>
<a name="ln552">    else</a>
<a name="ln553">      return g_strdup_printf(&quot;%04d:%02d:%02d %02d&quot;, t.year, t.month, t.day, t.hour);</a>
<a name="ln554">  }</a>
<a name="ln555">  else if(zoom == DT_LIB_TIMELINE_ZOOM_10MINUTE || zoom == DT_LIB_TIMELINE_ZOOM_MINUTE)</a>
<a name="ln556">  {</a>
<a name="ln557">    if(full)</a>
<a name="ln558">      return g_strdup_printf(&quot;%04d:%02d:%02d %02d:%02d:00&quot;, t.year, t.month, t.day, t.hour, t.minute);</a>
<a name="ln559">    else</a>
<a name="ln560">      return g_strdup_printf(&quot;%04d:%02d:%02d %02d:%02d&quot;, t.year, t.month, t.day, t.hour, t.minute);</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">  return NULL;</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">// get all the datetimes from the database</a>
<a name="ln567">static gboolean _time_read_bounds_from_db(dt_lib_module_t *self)</a>
<a name="ln568">{</a>
<a name="ln569">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln570"> </a>
<a name="ln571">  sqlite3_stmt *stmt;</a>
<a name="ln572">  const char *query = &quot;SELECT datetime_taken FROM main.images WHERE LENGTH(datetime_taken) = 19 AND &quot;</a>
<a name="ln573">                      &quot;datetime_taken &gt; '0001:01:01 00:00:00' ORDER BY &quot;</a>
<a name="ln574">                      &quot;datetime_taken ASC LIMIT 1&quot;;</a>
<a name="ln575">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln576"> </a>
<a name="ln577">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln578">  {</a>
<a name="ln579">    const char *tx = (const char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln580">    strip-&gt;time_mini.year = MAX(strtol(tx, NULL, 10), 0);</a>
<a name="ln581">    strip-&gt;time_mini.month = CLAMP(strtol(tx + 5, NULL, 10), 1, 12);</a>
<a name="ln582">    strip-&gt;time_mini.day</a>
<a name="ln583">        = CLAMP(strtol(tx + 8, NULL, 10), 1, _time_days_in_month(strip-&gt;time_mini.year, strip-&gt;time_mini.month));</a>
<a name="ln584">    strip-&gt;time_mini.hour = CLAMP(strtol(tx + 11, NULL, 10), 0, 23);</a>
<a name="ln585">    strip-&gt;time_mini.minute = CLAMP(strtol(tx + 14, NULL, 10), 0, 59);</a>
<a name="ln586">    strip-&gt;has_selection = TRUE;</a>
<a name="ln587">  }</a>
<a name="ln588">  else</a>
<a name="ln589">    strip-&gt;has_selection = FALSE;</a>
<a name="ln590">  sqlite3_finalize(stmt);</a>
<a name="ln591"> </a>
<a name="ln592">  const char *query2 = &quot;SELECT datetime_taken FROM main.images WHERE LENGTH(datetime_taken) = 19 AND &quot;</a>
<a name="ln593">                       &quot;datetime_taken &gt; '0001:01:01 00:00:00' ORDER BY &quot;</a>
<a name="ln594">                       &quot;datetime_taken DESC LIMIT 1&quot;;</a>
<a name="ln595">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query2, -1, &amp;stmt, NULL);</a>
<a name="ln596"> </a>
<a name="ln597">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln598">  {</a>
<a name="ln599">    const char *tx = (const char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln600">    strip-&gt;time_maxi.year = MAX(strtol(tx, NULL, 10), 0);</a>
<a name="ln601">    strip-&gt;time_maxi.month = CLAMP(strtol(tx + 5, NULL, 10), 1, 12);</a>
<a name="ln602">    strip-&gt;time_maxi.day</a>
<a name="ln603">        = CLAMP(strtol(tx + 8, NULL, 10), 1, _time_days_in_month(strip-&gt;time_mini.year, strip-&gt;time_mini.month));</a>
<a name="ln604">    strip-&gt;time_maxi.hour = CLAMP(strtol(tx + 11, NULL, 10), 0, 23);</a>
<a name="ln605">    strip-&gt;time_maxi.minute = CLAMP(strtol(tx + 14, NULL, 10), 0, 59);</a>
<a name="ln606">  }</a>
<a name="ln607">  sqlite3_finalize(stmt);</a>
<a name="ln608"> </a>
<a name="ln609">  return TRUE;</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">// get all the datetimes from the actual collection</a>
<a name="ln613">static gboolean _time_read_bounds_from_collection(dt_lib_module_t *self)</a>
<a name="ln614">{</a>
<a name="ln615">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln616"> </a>
<a name="ln617">  sqlite3_stmt *stmt;</a>
<a name="ln618">  const char *query = &quot;SELECT db.datetime_taken FROM main.images AS db, memory.collected_images AS col WHERE &quot;</a>
<a name="ln619">                      &quot;db.id=col.imgid AND LENGTH(db.datetime_taken) = 19 AND db.datetime_taken &gt; '0001:01:01 &quot;</a>
<a name="ln620">                      &quot;00:00:00' ORDER BY &quot;</a>
<a name="ln621">                      &quot;db.datetime_taken ASC LIMIT 1&quot;;</a>
<a name="ln622">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln623"> </a>
<a name="ln624">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln625">  {</a>
<a name="ln626">    const char *tx = (const char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln627">    strip-&gt;start_t.year = MAX(strtol(tx, NULL, 10), 0);</a>
<a name="ln628">    strip-&gt;start_t.month = CLAMP(strtol(tx + 5, NULL, 10), 1, 12);</a>
<a name="ln629">    strip-&gt;start_t.day</a>
<a name="ln630">        = CLAMP(strtol(tx + 8, NULL, 10), 1, _time_days_in_month(strip-&gt;time_mini.year, strip-&gt;time_mini.month));</a>
<a name="ln631">    strip-&gt;start_t.hour = CLAMP(strtol(tx + 11, NULL, 10), 0, 23);</a>
<a name="ln632">    strip-&gt;start_t.minute = CLAMP(strtol(tx + 14, NULL, 10), 0, 59);</a>
<a name="ln633">    strip-&gt;has_selection = TRUE;</a>
<a name="ln634">  }</a>
<a name="ln635">  else</a>
<a name="ln636">    strip-&gt;has_selection = FALSE;</a>
<a name="ln637">  sqlite3_finalize(stmt);</a>
<a name="ln638"> </a>
<a name="ln639">  const char *query2 = &quot;SELECT db.datetime_taken FROM main.images AS db, memory.collected_images AS col WHERE &quot;</a>
<a name="ln640">                       &quot;db.id=col.imgid AND LENGTH(db.datetime_taken) = 19 AND db.datetime_taken &gt; '0001:01:01 &quot;</a>
<a name="ln641">                       &quot;00:00:00' ORDER BY &quot;</a>
<a name="ln642">                       &quot;db.datetime_taken DESC LIMIT 1&quot;;</a>
<a name="ln643">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query2, -1, &amp;stmt, NULL);</a>
<a name="ln644"> </a>
<a name="ln645">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln646">  {</a>
<a name="ln647">    const char *tx = (const char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln648">    strip-&gt;stop_t.year = MAX(strtol(tx, NULL, 10), 0);</a>
<a name="ln649">    strip-&gt;stop_t.month = CLAMP(strtol(tx + 5, NULL, 10), 1, 12);</a>
<a name="ln650">    strip-&gt;stop_t.day</a>
<a name="ln651">        = CLAMP(strtol(tx + 8, NULL, 10), 1, _time_days_in_month(strip-&gt;time_mini.year, strip-&gt;time_mini.month));</a>
<a name="ln652">    strip-&gt;stop_t.hour = CLAMP(strtol(tx + 11, NULL, 10), 0, 23);</a>
<a name="ln653">    strip-&gt;stop_t.minute = CLAMP(strtol(tx + 14, NULL, 10), 0, 59);</a>
<a name="ln654">  }</a>
<a name="ln655">  sqlite3_finalize(stmt);</a>
<a name="ln656"> </a>
<a name="ln657">  return TRUE;</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660"> </a>
<a name="ln661">static dt_lib_timeline_time_t _time_get_from_db(gchar *tx, gboolean last)</a>
<a name="ln662">{</a>
<a name="ln663">  dt_lib_timeline_time_t tt = _time_init();</a>
<a name="ln664">  if(strlen(tx) &gt; 3) tt.year = CLAMP(strtol(tx, NULL, 10), 0, 4000);</a>
<a name="ln665">  if(strlen(tx) &gt; 6) tt.month = CLAMP(strtol(tx + 5, NULL, 10), 1, 12);</a>
<a name="ln666">  if(strlen(tx) &gt; 9) tt.day = CLAMP(strtol(tx + 8, NULL, 10), 1, _time_days_in_month(tt.year, tt.month));</a>
<a name="ln667">  if(strlen(tx) &gt; 12) tt.hour = CLAMP(strtol(tx + 11, NULL, 10), 0, 23);</a>
<a name="ln668">  if(strlen(tx) &gt; 15) tt.minute = CLAMP(strtol(tx + 14, NULL, 10), 0, 59);</a>
<a name="ln669"> </a>
<a name="ln670">  // if we need to complete a non full date to get the last one (&quot;2012&quot; &gt; &quot;2012:12:31 23:59&quot;)</a>
<a name="ln671">  if(last)</a>
<a name="ln672">  {</a>
<a name="ln673">    if(strlen(tx) &lt; 16)</a>
<a name="ln674">    {</a>
<a name="ln675">      tt.minute = 59;</a>
<a name="ln676">      if(strlen(tx) &lt; 13)</a>
<a name="ln677">      {</a>
<a name="ln678">        tt.hour = 23;</a>
<a name="ln679">        if(strlen(tx) &lt; 7)</a>
<a name="ln680">        {</a>
<a name="ln681">          tt.month = 12;</a>
<a name="ln682">        }</a>
<a name="ln683">        if(strlen(tx) &lt; 10)</a>
<a name="ln684">        {</a>
<a name="ln685">          tt.day = _time_days_in_month(tt.year, tt.month);</a>
<a name="ln686">        }</a>
<a name="ln687">      }</a>
<a name="ln688">    }</a>
<a name="ln689">  }</a>
<a name="ln690">  return tt;</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">// get the time of the first block of the strip in order to show the selection</a>
<a name="ln694">static dt_lib_timeline_time_t _selection_scroll_to(dt_lib_timeline_time_t t, dt_lib_timeline_t *strip)</a>
<a name="ln695">{</a>
<a name="ln696">  dt_lib_timeline_time_t tt = t;</a>
<a name="ln697">  int nb = strip-&gt;panel_width / 122;</a>
<a name="ln698"> </a>
<a name="ln699">  for(int i = 0; i &lt; nb; i++)</a>
<a name="ln700">  {</a>
<a name="ln701">    // we ensure that we are not before the strip bound</a>
<a name="ln702">    if(_time_compare(tt, strip-&gt;time_mini) &lt;= 0) return strip-&gt;time_mini;</a>
<a name="ln703"> </a>
<a name="ln704">    // and we dont want to display blocks after the bounds too</a>
<a name="ln705">    dt_lib_timeline_time_t ttt = tt;</a>
<a name="ln706">    _time_add(&amp;ttt, nb - 1, strip-&gt;zoom);</a>
<a name="ln707">    if(_time_compare(ttt, strip-&gt;time_maxi) &lt;= 0) return tt;</a>
<a name="ln708"> </a>
<a name="ln709">    // we test the previous date</a>
<a name="ln710">    _time_add(&amp;tt, -1, strip-&gt;zoom);</a>
<a name="ln711">  }</a>
<a name="ln712">  // if we are here that means we fail to scroll... why ?</a>
<a name="ln713">  return t;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">// computes blocks at the current zoom level</a>
<a name="ln717">static int _block_get_at_zoom(dt_lib_module_t *self, int width)</a>
<a name="ln718">{</a>
<a name="ln719">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln720"> </a>
<a name="ln721">  // we erase previous blocks if any</a>
<a name="ln722">  if(strip-&gt;blocks)</a>
<a name="ln723">  {</a>
<a name="ln724">    g_list_free_full(strip-&gt;blocks, _block_free);</a>
<a name="ln725">    strip-&gt;blocks = NULL;</a>
<a name="ln726">  }</a>
<a name="ln727"> </a>
<a name="ln728">  int w = 0;</a>
<a name="ln729"> </a>
<a name="ln730">  // if selection start/stop if lower than the begiining of the strip</a>
<a name="ln731">  if(_time_compare_at_zoom(strip-&gt;start_t, strip-&gt;time_pos, strip-&gt;zoom) &lt; 0) strip-&gt;start_x = -2;</a>
<a name="ln732">  if(_time_compare_at_zoom(strip-&gt;stop_t, strip-&gt;time_pos, strip-&gt;zoom) &lt; 0) strip-&gt;stop_x = -1;</a>
<a name="ln733"> </a>
<a name="ln734">  sqlite3_stmt *stmt;</a>
<a name="ln735">  gchar *query = g_strdup_printf(&quot;SELECT db.datetime_taken, col.imgid FROM main.images AS db LEFT JOIN &quot;</a>
<a name="ln736">                                 &quot;memory.collected_images AS col ON db.id=col.imgid WHERE &quot;</a>
<a name="ln737">                                 &quot;LENGTH(db.datetime_taken) = 19 AND &quot;</a>
<a name="ln738">                                 &quot;db.datetime_taken &gt; '%s' ORDER BY db.datetime_taken ASC&quot;,</a>
<a name="ln739">                                 _time_format_for_db(strip-&gt;time_pos, strip-&gt;zoom, TRUE));</a>
<a name="ln740">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln741"> </a>
<a name="ln742">  char *tx = &quot;&quot;;</a>
<a name="ln743">  int id = 0;</a>
<a name="ln744">  int stat = sqlite3_step(stmt);</a>
<a name="ln745">  if(stat == SQLITE_ROW)</a>
<a name="ln746">  {</a>
<a name="ln747">    tx = (char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln748">    id = sqlite3_column_int(stmt, 1);</a>
<a name="ln749">  }</a>
<a name="ln750">  else</a>
<a name="ln751">    return 0;</a>
<a name="ln752"> </a>
<a name="ln753">  dt_lib_timeline_time_t tt = strip-&gt;time_pos;</a>
<a name="ln754">  // we round correctly this date</a>
<a name="ln755">  if(strip-&gt;zoom &lt;= DT_LIB_TIMELINE_ZOOM_HOUR)</a>
<a name="ln756">  {</a>
<a name="ln757">    tt.minute = 0;</a>
<a name="ln758">    if(strip-&gt;zoom &lt;= DT_LIB_TIMELINE_ZOOM_6HOUR)</a>
<a name="ln759">    {</a>
<a name="ln760">      tt.hour = tt.hour / 6 * 6;</a>
<a name="ln761">      if(strip-&gt;zoom &lt;= DT_LIB_TIMELINE_ZOOM_DAY)</a>
<a name="ln762">      {</a>
<a name="ln763">        tt.hour = 0;</a>
<a name="ln764">        if(strip-&gt;zoom &lt;= DT_LIB_TIMELINE_ZOOM_10DAY)</a>
<a name="ln765">        {</a>
<a name="ln766">          tt.day = (tt.day - 1) / 10 * 10 + 1;</a>
<a name="ln767">          if(strip-&gt;zoom &lt;= DT_LIB_TIMELINE_ZOOM_MONTH)</a>
<a name="ln768">          {</a>
<a name="ln769">            tt.day = 1;</a>
<a name="ln770">            if(strip-&gt;zoom &lt;= DT_LIB_TIMELINE_ZOOM_4MONTH)</a>
<a name="ln771">            {</a>
<a name="ln772">              tt.month = (tt.month - 1) / 4 * 4 + 1;</a>
<a name="ln773">              if(strip-&gt;zoom &lt;= DT_LIB_TIMELINE_ZOOM_YEAR)</a>
<a name="ln774">              {</a>
<a name="ln775">                tt.month = 1;</a>
<a name="ln776">              }</a>
<a name="ln777">            }</a>
<a name="ln778">          }</a>
<a name="ln779">        }</a>
<a name="ln780">      }</a>
<a name="ln781">    }</a>
<a name="ln782">  }</a>
<a name="ln783"> </a>
<a name="ln784">  while(TRUE)</a>
<a name="ln785">  {</a>
<a name="ln786">    dt_lib_timeline_block_t *bloc = (dt_lib_timeline_block_t *)calloc(1, sizeof(dt_lib_timeline_block_t));</a>
<a name="ln787">    bloc-&gt;name = _time_format_for_ui(tt, strip-&gt;zoom);</a>
<a name="ln788">    bloc-&gt;init = tt;</a>
<a name="ln789">    bloc-&gt;values_count = _block_get_bar_count(tt, strip-&gt;zoom);</a>
<a name="ln790">    bloc-&gt;values = (int *)calloc(bloc-&gt;values_count, sizeof(int));</a>
<a name="ln791">    bloc-&gt;collect_values = (int *)calloc(bloc-&gt;values_count, sizeof(int));</a>
<a name="ln792">    bloc-&gt;width = bloc-&gt;values_count * _block_get_bar_width(strip-&gt;zoom);</a>
<a name="ln793"> </a>
<a name="ln794">    if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_YEAR)</a>
<a name="ln795">      tt.month = 1;</a>
<a name="ln796">    else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_4MONTH || strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_MONTH)</a>
<a name="ln797">      tt.day = 1;</a>
<a name="ln798">    else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_10DAY || strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_DAY)</a>
<a name="ln799">      tt.hour = 0;</a>
<a name="ln800">    else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_6HOUR || strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_HOUR)</a>
<a name="ln801">      tt.minute = 0;</a>
<a name="ln802">    // we count the number of photos per month</a>
<a name="ln803">    for(int i = 0; i &lt; bloc-&gt;values_count; i++)</a>
<a name="ln804">    {</a>
<a name="ln805"> </a>
<a name="ln806">      // if it's the selection start/stop time, we set the x value accordindgly</a>
<a name="ln807">      if(_time_compare_at_zoom(strip-&gt;start_t, tt, strip-&gt;zoom) == 0)</a>
<a name="ln808">        strip-&gt;start_x = w + i * _block_get_bar_width(strip-&gt;zoom);</a>
<a name="ln809">      if(_time_compare_at_zoom(strip-&gt;stop_t, tt, strip-&gt;zoom) == 0)</a>
<a name="ln810">        strip-&gt;stop_x = w + (i + 1) * _block_get_bar_width(strip-&gt;zoom);</a>
<a name="ln811">      // and we count how many photos we have for this time</a>
<a name="ln812">      while(stat == SQLITE_ROW &amp;&amp; _time_compare_at_zoom(tt, _time_get_from_db(tx, FALSE), strip-&gt;zoom) == 0)</a>
<a name="ln813">      {</a>
<a name="ln814">        bloc-&gt;values[i]++;</a>
<a name="ln815">        if(id &gt; 0) bloc-&gt;collect_values[i]++;</a>
<a name="ln816">        stat = sqlite3_step(stmt);</a>
<a name="ln817">        tx = (char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln818">        id = sqlite3_column_int(stmt, 1);</a>
<a name="ln819">      }</a>
<a name="ln820"> </a>
<a name="ln821">      // and we jump to next date</a>
<a name="ln822">      // if (i+1 &gt;= bloc-&gt;values_count) break;</a>
<a name="ln823">      if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_YEAR)</a>
<a name="ln824">        _time_add(&amp;tt, 1, DT_LIB_TIMELINE_ZOOM_MONTH);</a>
<a name="ln825">      else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_4MONTH || strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_MONTH)</a>
<a name="ln826">        _time_add(&amp;tt, 1, DT_LIB_TIMELINE_ZOOM_DAY);</a>
<a name="ln827">      else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_10DAY)</a>
<a name="ln828">        _time_add(&amp;tt, 2, DT_LIB_TIMELINE_ZOOM_HOUR);</a>
<a name="ln829">      else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_DAY)</a>
<a name="ln830">        _time_add(&amp;tt, 1, DT_LIB_TIMELINE_ZOOM_HOUR);</a>
<a name="ln831">      else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_6HOUR)</a>
<a name="ln832">        _time_add(&amp;tt, 3, DT_LIB_TIMELINE_ZOOM_MINUTE);</a>
<a name="ln833">      else if(strip-&gt;zoom == DT_LIB_TIMELINE_ZOOM_HOUR)</a>
<a name="ln834">        _time_add(&amp;tt, 1, DT_LIB_TIMELINE_ZOOM_MINUTE);</a>
<a name="ln835">    }</a>
<a name="ln836">    strip-&gt;blocks = g_list_append(strip-&gt;blocks, bloc);</a>
<a name="ln837"> </a>
<a name="ln838">    w += bloc-&gt;width + 2;</a>
<a name="ln839">    if(w &gt; width || stat != SQLITE_ROW)</a>
<a name="ln840">    {</a>
<a name="ln841">      // if selection start/stop times are greater than the last time</a>
<a name="ln842">      if(_time_compare_at_zoom(strip-&gt;start_t, tt, strip-&gt;zoom) &gt;= 0) strip-&gt;start_x = strip-&gt;panel_width + 1;</a>
<a name="ln843">      if(_time_compare_at_zoom(strip-&gt;stop_t, tt, strip-&gt;zoom) &gt;= 0) strip-&gt;stop_x = strip-&gt;panel_width + 2;</a>
<a name="ln844">      break;</a>
<a name="ln845">    }</a>
<a name="ln846">  }</a>
<a name="ln847">  sqlite3_finalize(stmt);</a>
<a name="ln848">  g_free(query);</a>
<a name="ln849"> </a>
<a name="ln850">  // and we return the width of the strip</a>
<a name="ln851">  return w;</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">static gboolean _time_is_visible(dt_lib_timeline_time_t t, dt_lib_timeline_t *strip)</a>
<a name="ln855">{</a>
<a name="ln856">  // first case, the date is before the strip</a>
<a name="ln857">  if(_time_compare_at_zoom(t, strip-&gt;time_pos, strip-&gt;zoom) &lt; 0) return FALSE;</a>
<a name="ln858"> </a>
<a name="ln859">  // now the end of the visible strip</a>
<a name="ln860">  // if the date is in the last block, we consider it's outside, because the last block can be partially hidden</a>
<a name="ln861">  GList *bl = g_list_last(strip-&gt;blocks);</a>
<a name="ln862">  if(bl)</a>
<a name="ln863">  {</a>
<a name="ln864">    dt_lib_timeline_block_t *blo = bl-&gt;data;</a>
<a name="ln865">    if(_time_compare_at_zoom(t, blo-&gt;init, strip-&gt;zoom) &gt; 0) return FALSE;</a>
<a name="ln866">  }</a>
<a name="ln867"> </a>
<a name="ln868">  return TRUE;</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871">static void _lib_timeline_collection_changed(gpointer instance, gpointer user_data)</a>
<a name="ln872">{</a>
<a name="ln873">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln874">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln875"> </a>
<a name="ln876">  // we read the collect bounds</a>
<a name="ln877">  _time_read_bounds_from_collection(self);</a>
<a name="ln878"> </a>
<a name="ln879">  // if the start in not visible, we recompute the start of the strip</a>
<a name="ln880">  if(!_time_is_visible(strip-&gt;start_t, strip))</a>
<a name="ln881">  {</a>
<a name="ln882">    strip-&gt;time_pos = _selection_scroll_to(strip-&gt;start_t, strip);</a>
<a name="ln883">  }</a>
<a name="ln884"> </a>
<a name="ln885">  // in any case we redraw the strip (to reflect any selected image change)</a>
<a name="ln886">  cairo_surface_destroy(strip-&gt;surface);</a>
<a name="ln887">  strip-&gt;surface = NULL;</a>
<a name="ln888">  gtk_widget_queue_draw(strip-&gt;timeline);</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891"> </a>
<a name="ln892">// add the selected portions to the collect</a>
<a name="ln893">static void _selection_collect(dt_lib_timeline_t *strip, dt_lib_timeline_mode_t mode)</a>
<a name="ln894">{</a>
<a name="ln895">  // if the last rule is date-time type or is empty, we modify it</a>
<a name="ln896">  // else we add a new rule date-time rule</a>
<a name="ln897"> </a>
<a name="ln898">  int new_rule = 0;</a>
<a name="ln899">  const int nb_rules = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln900">  if(nb_rules &gt; 0 &amp;&amp; mode != DT_LIB_TIMELINE_MODE_RESET)</a>
<a name="ln901">  {</a>
<a name="ln902">    char confname[200] = { 0 };</a>
<a name="ln903">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, nb_rules - 1);</a>
<a name="ln904">    dt_collection_properties_t prop = dt_conf_get_int(confname);</a>
<a name="ln905">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, nb_rules - 1);</a>
<a name="ln906">    int rmode = dt_conf_get_int(confname);</a>
<a name="ln907">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, nb_rules - 1);</a>
<a name="ln908">    gchar *string = dt_conf_get_string(confname);</a>
<a name="ln909">    string = g_strstrip(string);</a>
<a name="ln910">    if((prop == DT_COLLECTION_PROP_TIME &amp;&amp; rmode == 0) || !string || strlen(string) == 0</a>
<a name="ln911">       || g_strcmp0(string, &quot;%&quot;) == 0)</a>
<a name="ln912">      new_rule = nb_rules - 1;</a>
<a name="ln913">    else</a>
<a name="ln914">      new_rule = nb_rules;</a>
<a name="ln915">    g_free(string);</a>
<a name="ln916">  }</a>
<a name="ln917"> </a>
<a name="ln918">  // we construct the rule</a>
<a name="ln919">  gchar *coll = NULL;</a>
<a name="ln920">  if(strip-&gt;start_x == strip-&gt;stop_x)</a>
<a name="ln921">  {</a>
<a name="ln922">    coll = _time_format_for_db(strip-&gt;start_t, (strip-&gt;zoom + 1) / 2 * 2 + 2, FALSE);</a>
<a name="ln923">  }</a>
<a name="ln924">  else</a>
<a name="ln925">  {</a>
<a name="ln926">    dt_lib_timeline_time_t start = strip-&gt;start_t;</a>
<a name="ln927">    dt_lib_timeline_time_t stop = strip-&gt;stop_t;</a>
<a name="ln928">    if(strip-&gt;start_x &gt; strip-&gt;stop_x)</a>
<a name="ln929">    {</a>
<a name="ln930">      // we exchange the values</a>
<a name="ln931">      start = strip-&gt;stop_t;</a>
<a name="ln932">      stop = strip-&gt;start_t;</a>
<a name="ln933">    }</a>
<a name="ln934">    gchar *d1 = _time_format_for_db(start, (strip-&gt;zoom + 1) / 2 * 2 + 2, FALSE);</a>
<a name="ln935">    gchar *d2 = _time_format_for_db(stop, (strip-&gt;zoom + 1) / 2 * 2 + 2, FALSE);</a>
<a name="ln936">    if(d1 &amp;&amp; d2) coll = g_strdup_printf(&quot;[%s;%s]&quot;, d1, d2);</a>
<a name="ln937">    g_free(d1);</a>
<a name="ln938">    g_free(d2);</a>
<a name="ln939">  }</a>
<a name="ln940"> </a>
<a name="ln941">  if(coll)</a>
<a name="ln942">  {</a>
<a name="ln943">    dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, new_rule + 1);</a>
<a name="ln944">    char confname[200] = { 0 };</a>
<a name="ln945">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, new_rule);</a>
<a name="ln946">    dt_conf_set_int(confname, DT_COLLECTION_PROP_TIME);</a>
<a name="ln947">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, new_rule);</a>
<a name="ln948">    dt_conf_set_int(confname, 0);</a>
<a name="ln949">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, new_rule);</a>
<a name="ln950">    dt_conf_set_string(confname, coll);</a>
<a name="ln951">    g_free(coll);</a>
<a name="ln952"> </a>
<a name="ln953">    dt_collection_update_query(darktable.collection);</a>
<a name="ln954">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_QUERY_CHANGED);</a>
<a name="ln955">  }</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958">static gboolean _lib_timeline_draw_callback(GtkWidget *widget, cairo_t *wcr, gpointer user_data)</a>
<a name="ln959">{</a>
<a name="ln960">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln961">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln962"> </a>
<a name="ln963">  GtkAllocation allocation;</a>
<a name="ln964">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln965">  const int32_t width = allocation.width;</a>
<a name="ln966"> </a>
<a name="ln967">  // windows could have been expanded for example, we need to create a new surface of the good size and redraw</a>
<a name="ln968">  if(width != strip-&gt;panel_width)</a>
<a name="ln969">  {</a>
<a name="ln970">    // if it's the first show, we need to recompute the scroll too</a>
<a name="ln971">    if(strip-&gt;panel_width == 0)</a>
<a name="ln972">    {</a>
<a name="ln973">      strip-&gt;panel_width = width;</a>
<a name="ln974">      strip-&gt;time_pos = _selection_scroll_to(strip-&gt;start_t, strip);</a>
<a name="ln975">    }</a>
<a name="ln976">    if(strip-&gt;surface)</a>
<a name="ln977">    {</a>
<a name="ln978">      cairo_surface_destroy(strip-&gt;surface);</a>
<a name="ln979">      strip-&gt;surface = NULL;</a>
<a name="ln980">    }</a>
<a name="ln981">  }</a>
<a name="ln982"> </a>
<a name="ln983">  // create the persistent surface if it does not exists.</a>
<a name="ln984">  if(!strip-&gt;surface)</a>
<a name="ln985">  {</a>
<a name="ln986">    strip-&gt;surface_width = _block_get_at_zoom(self, width);</a>
<a name="ln987">    strip-&gt;panel_width = width;</a>
<a name="ln988">    strip-&gt;surface_height = allocation.height;</a>
<a name="ln989"> </a>
<a name="ln990">    // we set the width of a unit (bar) in the drawing (depending of the zoom level)</a>
<a name="ln991">    int wu = _block_get_bar_width(strip-&gt;zoom);</a>
<a name="ln992"> </a>
<a name="ln993">    strip-&gt;surface = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, allocation.width, allocation.height);</a>
<a name="ln994"> </a>
<a name="ln995">    // get cairo drawing handle</a>
<a name="ln996">    cairo_t *cr = cairo_create(strip-&gt;surface);</a>
<a name="ln997"> </a>
<a name="ln998">    /* fill background */</a>
<a name="ln999">    dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_FILMSTRIP_BG);</a>
<a name="ln1000">    cairo_paint(cr);</a>
<a name="ln1001"> </a>
<a name="ln1002">    // draw content depending of zoom level</a>
<a name="ln1003">    GList *bl = strip-&gt;blocks;</a>
<a name="ln1004">    int posx = 0;</a>
<a name="ln1005">    while(bl)</a>
<a name="ln1006">    {</a>
<a name="ln1007">      dt_lib_timeline_block_t *blo = bl-&gt;data;</a>
<a name="ln1008"> </a>
<a name="ln1009">      // width of this block</a>
<a name="ln1010">      int wb = blo-&gt;values_count * wu;</a>
<a name="ln1011"> </a>
<a name="ln1012">      cairo_text_extents_t te;</a>
<a name="ln1013">      dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_BRUSH_CURSOR);</a>
<a name="ln1014">      cairo_set_font_size(cr, 10);</a>
<a name="ln1015">      cairo_text_extents(cr, blo-&gt;name, &amp;te);</a>
<a name="ln1016">      int bh = allocation.height - te.height - 4;</a>
<a name="ln1017">      cairo_move_to(cr, posx + (wb - te.width) / 2 - te.x_bearing, allocation.height - 2);</a>
<a name="ln1018">      cairo_show_text(cr, blo-&gt;name);</a>
<a name="ln1019"> </a>
<a name="ln1020">      dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_THUMBNAIL_BG);</a>
<a name="ln1021">      cairo_rectangle(cr, posx, 0, wb, bh);</a>
<a name="ln1022">      cairo_fill(cr);</a>
<a name="ln1023"> </a>
<a name="ln1024">      for(int i = 0; i &lt; blo-&gt;values_count; i++)</a>
<a name="ln1025">      {</a>
<a name="ln1026">        dt_gui_gtk_set_source_rgba(cr, DT_GUI_COLOR_THUMBNAIL_HOVER_BG, 0.5);</a>
<a name="ln1027">        int h = _block_get_bar_height(blo-&gt;values[i], bh);</a>
<a name="ln1028">        cairo_rectangle(cr, posx + (i * wu), bh - h, wu, h);</a>
<a name="ln1029">        cairo_fill(cr);</a>
<a name="ln1030">        dt_gui_gtk_set_source_rgba(cr, DT_GUI_COLOR_THUMBNAIL_HOVER_BG, 1.0);</a>
<a name="ln1031">        h = _block_get_bar_height(blo-&gt;collect_values[i], bh);</a>
<a name="ln1032">        cairo_rectangle(cr, posx + (i * wu), bh - h, wu, h);</a>
<a name="ln1033">        cairo_fill(cr);</a>
<a name="ln1034">      }</a>
<a name="ln1035"> </a>
<a name="ln1036">      bl = bl-&gt;next;</a>
<a name="ln1037">      posx += wb + 2;</a>
<a name="ln1038">      if(posx &gt;= allocation.width) break;</a>
<a name="ln1039">    }</a>
<a name="ln1040"> </a>
<a name="ln1041">    // copy back the new content into the cairo handle of the draw callback</a>
<a name="ln1042">    cairo_destroy(cr);</a>
<a name="ln1043">  }</a>
<a name="ln1044">  cairo_set_source_surface(wcr, strip-&gt;surface, 0, 0);</a>
<a name="ln1045">  cairo_paint(wcr);</a>
<a name="ln1046"> </a>
<a name="ln1047">  // we draw the selection</a>
<a name="ln1048">  if(strip-&gt;has_selection)</a>
<a name="ln1049">  {</a>
<a name="ln1050">    int stop = 0;</a>
<a name="ln1051">    int start = 0;</a>
<a name="ln1052">    if(strip-&gt;selecting)</a>
<a name="ln1053">      stop = strip-&gt;current_x;</a>
<a name="ln1054">    else</a>
<a name="ln1055">      stop = strip-&gt;stop_x;</a>
<a name="ln1056">    if(stop &gt; strip-&gt;start_x)</a>
<a name="ln1057">      start = strip-&gt;start_x;</a>
<a name="ln1058">    else</a>
<a name="ln1059">    {</a>
<a name="ln1060">      start = stop;</a>
<a name="ln1061">      stop = strip-&gt;start_x;</a>
<a name="ln1062">    }</a>
<a name="ln1063">    // we verify that the selection is not in a hidden zone</a>
<a name="ln1064">    if(!(start &lt; 0 &amp;&amp; stop &lt; 0) &amp;&amp; !(start &gt; strip-&gt;panel_width &amp;&amp; stop &gt; strip-&gt;panel_width))</a>
<a name="ln1065">    {</a>
<a name="ln1066">      // we draw the selection</a>
<a name="ln1067">      if(start &gt;= 0)</a>
<a name="ln1068">      {</a>
<a name="ln1069">        // dt_gui_gtk_set_source_rgb(wcr, DT_GUI_COLOR_THUMBNAIL_HOVER_BG);</a>
<a name="ln1070">        dt_gui_gtk_set_source_rgba(wcr, DT_GUI_COLOR_THUMBNAIL_HOVER_BG, 0.8);</a>
<a name="ln1071">        cairo_move_to(wcr, start, 0);</a>
<a name="ln1072">        cairo_line_to(wcr, start, allocation.height);</a>
<a name="ln1073">        cairo_stroke(wcr);</a>
<a name="ln1074">        dt_gui_gtk_set_source_rgba(wcr, DT_GUI_COLOR_FILMSTRIP_BG, 0.3);</a>
<a name="ln1075">        cairo_move_to(wcr, start, 0);</a>
<a name="ln1076">        cairo_line_to(wcr, start, allocation.height);</a>
<a name="ln1077">        cairo_stroke(wcr);</a>
<a name="ln1078">      }</a>
<a name="ln1079">      dt_gui_gtk_set_source_rgba(wcr, DT_GUI_COLOR_THUMBNAIL_HOVER_BG, 0.5);</a>
<a name="ln1080">      cairo_rectangle(wcr, start, 0, stop - start, allocation.height);</a>
<a name="ln1081">      cairo_fill(wcr);</a>
<a name="ln1082">      if(stop &lt;= strip-&gt;panel_width)</a>
<a name="ln1083">      {</a>
<a name="ln1084">        dt_gui_gtk_set_source_rgba(wcr, DT_GUI_COLOR_THUMBNAIL_HOVER_BG, 0.8);</a>
<a name="ln1085">        cairo_move_to(wcr, stop, 0);</a>
<a name="ln1086">        cairo_line_to(wcr, stop, allocation.height);</a>
<a name="ln1087">        cairo_stroke(wcr);</a>
<a name="ln1088">        dt_gui_gtk_set_source_rgba(wcr, DT_GUI_COLOR_FILMSTRIP_BG, 0.3);</a>
<a name="ln1089">        cairo_move_to(wcr, stop, 0);</a>
<a name="ln1090">        cairo_line_to(wcr, stop, allocation.height);</a>
<a name="ln1091">        cairo_stroke(wcr);</a>
<a name="ln1092">      }</a>
<a name="ln1093">    }</a>
<a name="ln1094">  }</a>
<a name="ln1095"> </a>
<a name="ln1096">  // we draw the line under cursor and the date-time</a>
<a name="ln1097">  if(strip-&gt;in &amp;&amp; strip-&gt;current_x &gt; 0)</a>
<a name="ln1098">  {</a>
<a name="ln1099">    dt_lib_timeline_time_t tt;</a>
<a name="ln1100">    if(strip-&gt;selecting)</a>
<a name="ln1101">      tt = strip-&gt;stop_t;</a>
<a name="ln1102">    else</a>
<a name="ln1103">      tt = _time_get_from_pos(strip-&gt;current_x, strip);</a>
<a name="ln1104"> </a>
<a name="ln1105">    // we don't display NULL date (if it's outside bounds)</a>
<a name="ln1106">    if(_time_compare(tt, _time_init()) != 0)</a>
<a name="ln1107">    {</a>
<a name="ln1108">      dt_gui_gtk_set_source_rgb(wcr, DT_GUI_COLOR_BRUSH_TRACE);</a>
<a name="ln1109">      cairo_move_to(wcr, strip-&gt;current_x, 0);</a>
<a name="ln1110">      cairo_line_to(wcr, strip-&gt;current_x, allocation.height);</a>
<a name="ln1111">      cairo_stroke(wcr);</a>
<a name="ln1112">      gchar *dte = _time_format_for_ui(tt, strip-&gt;precision);</a>
<a name="ln1113">      cairo_text_extents_t te2;</a>
<a name="ln1114">      cairo_set_font_size(wcr, 10);</a>
<a name="ln1115">      cairo_text_extents(wcr, dte, &amp;te2);</a>
<a name="ln1116">      cairo_rectangle(wcr, strip-&gt;current_x, 8, te2.width + 4, te2.height + 4);</a>
<a name="ln1117">      dt_gui_gtk_set_source_rgb(wcr, DT_GUI_COLOR_BRUSH_TRACE);</a>
<a name="ln1118">      cairo_fill(wcr);</a>
<a name="ln1119">      cairo_move_to(wcr, strip-&gt;current_x + 2, 10 + te2.height);</a>
<a name="ln1120">      dt_gui_gtk_set_source_rgb(wcr, DT_GUI_COLOR_BRUSH_CURSOR);</a>
<a name="ln1121">      cairo_show_text(wcr, dte);</a>
<a name="ln1122">      g_free(dte);</a>
<a name="ln1123">    }</a>
<a name="ln1124">  }</a>
<a name="ln1125"> </a>
<a name="ln1126">  return TRUE;</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129">static gboolean _lib_timeline_button_press_callback(GtkWidget *w, GdkEventButton *e, gpointer user_data)</a>
<a name="ln1130">{</a>
<a name="ln1131">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1132">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln1133"> </a>
<a name="ln1134">  if(e-&gt;button == 1)</a>
<a name="ln1135">  {</a>
<a name="ln1136">    if(e-&gt;type == GDK_BUTTON_PRESS)</a>
<a name="ln1137">    {</a>
<a name="ln1138">      if(e-&gt;x - strip-&gt;start_x &lt; 2 &amp;&amp; e-&gt;x - strip-&gt;start_x &gt; -2)</a>
<a name="ln1139">      {</a>
<a name="ln1140">        strip-&gt;start_x = strip-&gt;stop_x;</a>
<a name="ln1141">        strip-&gt;start_t = strip-&gt;stop_t;</a>
<a name="ln1142">        strip-&gt;stop_x = e-&gt;x;</a>
<a name="ln1143">        strip-&gt;stop_t = _time_get_from_pos(e-&gt;x, strip);</a>
<a name="ln1144">        strip-&gt;move_edge = TRUE;</a>
<a name="ln1145">      }</a>
<a name="ln1146">      else if(e-&gt;x - strip-&gt;stop_x &lt; 2 &amp;&amp; e-&gt;x - strip-&gt;stop_x &gt; -2)</a>
<a name="ln1147">      {</a>
<a name="ln1148">        strip-&gt;stop_x = e-&gt;x;</a>
<a name="ln1149">        strip-&gt;stop_t = _time_get_from_pos(e-&gt;x, strip);</a>
<a name="ln1150">        strip-&gt;move_edge = TRUE;</a>
<a name="ln1151">      }</a>
<a name="ln1152">      else</a>
<a name="ln1153">      {</a>
<a name="ln1154">        strip-&gt;start_x = strip-&gt;stop_x = e-&gt;x;</a>
<a name="ln1155">        strip-&gt;start_t = strip-&gt;stop_t = _time_get_from_pos(e-&gt;x, strip);</a>
<a name="ln1156">        strip-&gt;move_edge = FALSE;</a>
<a name="ln1157">      }</a>
<a name="ln1158">      strip-&gt;selecting = TRUE;</a>
<a name="ln1159">      strip-&gt;has_selection = TRUE;</a>
<a name="ln1160">      gtk_widget_queue_draw(strip-&gt;timeline);</a>
<a name="ln1161">    }</a>
<a name="ln1162">  }</a>
<a name="ln1163">  else if(e-&gt;button == 3)</a>
<a name="ln1164">  {</a>
<a name="ln1165">    // we remove the last rule if it's a datetime one</a>
<a name="ln1166">    const int nb_rules = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1167">    if(nb_rules &gt; 0)</a>
<a name="ln1168">    {</a>
<a name="ln1169">      char confname[200] = { 0 };</a>
<a name="ln1170">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, nb_rules - 1);</a>
<a name="ln1171">      if(dt_conf_get_int(confname) == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1172">      {</a>
<a name="ln1173">        dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, nb_rules - 1);</a>
<a name="ln1174">        dt_collection_update_query(darktable.collection);</a>
<a name="ln1175"> </a>
<a name="ln1176">        strip-&gt;selecting = FALSE;</a>
<a name="ln1177">      }</a>
<a name="ln1178">    }</a>
<a name="ln1179">  }</a>
<a name="ln1180"> </a>
<a name="ln1181">  return FALSE;</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184">static gboolean _lib_timeline_button_release_callback(GtkWidget *w, GdkEventButton *e, gpointer user_data)</a>
<a name="ln1185">{</a>
<a name="ln1186">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1187">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln1188"> </a>
<a name="ln1189">  if(strip-&gt;selecting)</a>
<a name="ln1190">  {</a>
<a name="ln1191">    strip-&gt;stop_x = e-&gt;x;</a>
<a name="ln1192">    strip-&gt;stop_t = _time_get_from_pos(e-&gt;x, strip);</a>
<a name="ln1193">    // we want to be at the &quot;end&quot; of this date</a>
<a name="ln1194">    if(strip-&gt;zoom &lt;= DT_LIB_TIMELINE_ZOOM_DAY)</a>
<a name="ln1195">    {</a>
<a name="ln1196">      strip-&gt;stop_t.minute = 59;</a>
<a name="ln1197">      if(strip-&gt;zoom &lt;= DT_LIB_TIMELINE_ZOOM_MONTH)</a>
<a name="ln1198">      {</a>
<a name="ln1199">        strip-&gt;stop_t.hour = 23;</a>
<a name="ln1200">        if(strip-&gt;zoom &lt;= DT_LIB_TIMELINE_ZOOM_YEAR)</a>
<a name="ln1201">        {</a>
<a name="ln1202">          strip-&gt;stop_t.day = _time_days_in_month(strip-&gt;stop_t.year, strip-&gt;stop_t.month);</a>
<a name="ln1203">        }</a>
<a name="ln1204">      }</a>
<a name="ln1205">    }</a>
<a name="ln1206">    strip-&gt;selecting = FALSE;</a>
<a name="ln1207"> </a>
<a name="ln1208">    if(!strip-&gt;move_edge &amp;&amp; (e-&gt;state &amp; GDK_SHIFT_MASK))</a>
<a name="ln1209">      _selection_collect(strip, DT_LIB_TIMELINE_MODE_RESET);</a>
<a name="ln1210">    else</a>
<a name="ln1211">      _selection_collect(strip, DT_LIB_TIMELINE_MODE_AND);</a>
<a name="ln1212">    gtk_widget_queue_draw(strip-&gt;timeline);</a>
<a name="ln1213">  }</a>
<a name="ln1214"> </a>
<a name="ln1215">  return TRUE;</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">static gboolean _selection_start(GtkAccelGroup *accel_group, GObject *aceeleratable, guint keyval,</a>
<a name="ln1219">                                 GdkModifierType modifier, gpointer data)</a>
<a name="ln1220">{</a>
<a name="ln1221">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)data;</a>
<a name="ln1222"> </a>
<a name="ln1223">  strip-&gt;start_x = strip-&gt;current_x;</a>
<a name="ln1224">  strip-&gt;start_t = _time_get_from_pos(strip-&gt;current_x, strip);</a>
<a name="ln1225"> </a>
<a name="ln1226">  strip-&gt;stop_x = strip-&gt;start_x;</a>
<a name="ln1227">  strip-&gt;stop_t = strip-&gt;start_t;</a>
<a name="ln1228">  strip-&gt;selecting = TRUE;</a>
<a name="ln1229"> </a>
<a name="ln1230">  gtk_widget_queue_draw(strip-&gt;timeline);</a>
<a name="ln1231">  return TRUE;</a>
<a name="ln1232">}</a>
<a name="ln1233">static gboolean _selection_stop(GtkAccelGroup *accel_group, GObject *aceeleratable, guint keyval,</a>
<a name="ln1234">                                GdkModifierType modifier, gpointer data)</a>
<a name="ln1235">{</a>
<a name="ln1236">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)data;</a>
<a name="ln1237"> </a>
<a name="ln1238">  strip-&gt;stop_x = strip-&gt;current_x;</a>
<a name="ln1239">  strip-&gt;stop_t = _time_get_from_pos(strip-&gt;current_x, strip);</a>
<a name="ln1240">  // we want to be at the &quot;end&quot; of this date</a>
<a name="ln1241">  if(strip-&gt;zoom &lt; DT_LIB_TIMELINE_ZOOM_HOUR)</a>
<a name="ln1242">  {</a>
<a name="ln1243">    strip-&gt;stop_t.minute = 59;</a>
<a name="ln1244">    if(strip-&gt;zoom &lt; DT_LIB_TIMELINE_ZOOM_DAY)</a>
<a name="ln1245">    {</a>
<a name="ln1246">      strip-&gt;stop_t.hour = 23;</a>
<a name="ln1247">      if(strip-&gt;zoom &lt; DT_LIB_TIMELINE_ZOOM_MONTH)</a>
<a name="ln1248">      {</a>
<a name="ln1249">        strip-&gt;stop_t.day = _time_days_in_month(strip-&gt;stop_t.year, strip-&gt;stop_t.month);</a>
<a name="ln1250">      }</a>
<a name="ln1251">    }</a>
<a name="ln1252">  }</a>
<a name="ln1253"> </a>
<a name="ln1254">  strip-&gt;selecting = FALSE;</a>
<a name="ln1255">  _selection_collect(strip, DT_LIB_TIMELINE_MODE_AND);</a>
<a name="ln1256">  gtk_widget_queue_draw(strip-&gt;timeline);</a>
<a name="ln1257">  return TRUE;</a>
<a name="ln1258">}</a>
<a name="ln1259">static gboolean _block_autoscroll(gpointer user_data)</a>
<a name="ln1260">{</a>
<a name="ln1261">  // this function is called repetidly until the pointer is not more in the autoscoll zone</a>
<a name="ln1262">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1263">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln1264"> </a>
<a name="ln1265">  if(!strip-&gt;in)</a>
<a name="ln1266">  {</a>
<a name="ln1267">    strip-&gt;autoscroll = FALSE;</a>
<a name="ln1268">    return FALSE;</a>
<a name="ln1269">  }</a>
<a name="ln1270"> </a>
<a name="ln1271">  int move = 0;</a>
<a name="ln1272">  if(strip-&gt;current_x &lt; 10)</a>
<a name="ln1273">    move = -1;</a>
<a name="ln1274">  else if(strip-&gt;current_x &gt; strip-&gt;panel_width - 10)</a>
<a name="ln1275">    move = 1;</a>
<a name="ln1276"> </a>
<a name="ln1277">  if(move == 0)</a>
<a name="ln1278">  {</a>
<a name="ln1279">    strip-&gt;autoscroll = FALSE;</a>
<a name="ln1280">    return FALSE;</a>
<a name="ln1281">  }</a>
<a name="ln1282"> </a>
<a name="ln1283">  _time_add(&amp;(strip-&gt;time_pos), move, strip-&gt;zoom);</a>
<a name="ln1284">  // we ensure that the fimlstrip stay in the bounds</a>
<a name="ln1285">  dt_lib_timeline_time_t tt = _selection_scroll_to(strip-&gt;time_pos, strip);</a>
<a name="ln1286">  if(_time_compare(tt, strip-&gt;time_pos) != 0)</a>
<a name="ln1287">  {</a>
<a name="ln1288">    strip-&gt;autoscroll = FALSE;</a>
<a name="ln1289">    return FALSE;</a>
<a name="ln1290">  }</a>
<a name="ln1291"> </a>
<a name="ln1292">  cairo_surface_destroy(strip-&gt;surface);</a>
<a name="ln1293">  strip-&gt;surface = NULL;</a>
<a name="ln1294">  gtk_widget_queue_draw(strip-&gt;timeline);</a>
<a name="ln1295">  return TRUE;</a>
<a name="ln1296">}</a>
<a name="ln1297"> </a>
<a name="ln1298">static gboolean _lib_timeline_motion_notify_callback(GtkWidget *w, GdkEventMotion *e, gpointer user_data)</a>
<a name="ln1299">{</a>
<a name="ln1300">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1301">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln1302"> </a>
<a name="ln1303">  strip-&gt;in = TRUE;</a>
<a name="ln1304"> </a>
<a name="ln1305">  // auto-scroll if cursor is at one end of the panel</a>
<a name="ln1306">  if((e-&gt;x &lt; 10 || e-&gt;x &gt; strip-&gt;panel_width - 10) &amp;&amp; !strip-&gt;autoscroll)</a>
<a name="ln1307">  {</a>
<a name="ln1308">    // first scroll immediately and then every 400ms until cursor quit the &quot;auto-zone&quot;</a>
<a name="ln1309">    if(_block_autoscroll(user_data))</a>
<a name="ln1310">    {</a>
<a name="ln1311">      strip-&gt;autoscroll = TRUE;</a>
<a name="ln1312">      g_timeout_add(400, _block_autoscroll, user_data);</a>
<a name="ln1313">    }</a>
<a name="ln1314">  }</a>
<a name="ln1315"> </a>
<a name="ln1316">  strip-&gt;current_x = e-&gt;x;</a>
<a name="ln1317"> </a>
<a name="ln1318">  if(strip-&gt;selecting)</a>
<a name="ln1319">  {</a>
<a name="ln1320">    strip-&gt;stop_x = e-&gt;x;</a>
<a name="ln1321">    strip-&gt;stop_t = _time_get_from_pos(e-&gt;x, strip);</a>
<a name="ln1322">    dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln1323">  }</a>
<a name="ln1324">  else</a>
<a name="ln1325">  {</a>
<a name="ln1326">    // we change the cursor if we are close enough of a selection limit</a>
<a name="ln1327">    if(e-&gt;x - strip-&gt;start_x &lt; 2 &amp;&amp; e-&gt;x - strip-&gt;start_x &gt; -2)</a>
<a name="ln1328">    {</a>
<a name="ln1329">      dt_control_change_cursor(GDK_LEFT_SIDE);</a>
<a name="ln1330">    }</a>
<a name="ln1331">    else if(e-&gt;x - strip-&gt;stop_x &lt; 2 &amp;&amp; e-&gt;x - strip-&gt;stop_x &gt; -2)</a>
<a name="ln1332">    {</a>
<a name="ln1333">      dt_control_change_cursor(GDK_RIGHT_SIDE);</a>
<a name="ln1334">    }</a>
<a name="ln1335">    else</a>
<a name="ln1336">    {</a>
<a name="ln1337">      dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln1338">    }</a>
<a name="ln1339">  }</a>
<a name="ln1340">  gtk_widget_queue_draw(strip-&gt;timeline);</a>
<a name="ln1341">  return TRUE;</a>
<a name="ln1342">}</a>
<a name="ln1343"> </a>
<a name="ln1344">static gboolean _lib_timeline_scroll_callback(GtkWidget *w, GdkEventScroll *e, gpointer user_data)</a>
<a name="ln1345">{</a>
<a name="ln1346">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1347">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln1348"> </a>
<a name="ln1349">  // zoom change (with Ctrl key)</a>
<a name="ln1350">  if(e-&gt;state &amp; GDK_CONTROL_MASK)</a>
<a name="ln1351">  {</a>
<a name="ln1352">    int z = strip-&gt;zoom;</a>
<a name="ln1353">    if(e-&gt;direction == GDK_SCROLL_UP)</a>
<a name="ln1354">    {</a>
<a name="ln1355">      if(z != DT_LIB_TIMELINE_ZOOM_HOUR) z++;</a>
<a name="ln1356">    }</a>
<a name="ln1357">    else if(e-&gt;direction == GDK_SCROLL_DOWN)</a>
<a name="ln1358">    {</a>
<a name="ln1359">      if(z != DT_LIB_TIMELINE_ZOOM_YEAR) z--;</a>
<a name="ln1360">    }</a>
<a name="ln1361"> </a>
<a name="ln1362">    // if the zoom as changed, we need to recompute blocks and redraw</a>
<a name="ln1363">    if(z != strip-&gt;zoom)</a>
<a name="ln1364">    {</a>
<a name="ln1365">      dt_conf_set_int(&quot;plugins/lighttable/timeline/last_zoom&quot;, z);</a>
<a name="ln1366">      strip-&gt;time_pos = _time_compute_offset_for_zoom(strip-&gt;current_x, strip, z);</a>
<a name="ln1367">      strip-&gt;zoom = z;</a>
<a name="ln1368">      if(z % 2 == 0)</a>
<a name="ln1369">        strip-&gt;precision = z + 2;</a>
<a name="ln1370">      else</a>
<a name="ln1371">        strip-&gt;precision = z + 1;</a>
<a name="ln1372">      cairo_surface_destroy(strip-&gt;surface);</a>
<a name="ln1373">      strip-&gt;surface = NULL;</a>
<a name="ln1374">      gtk_widget_queue_draw(strip-&gt;timeline);</a>
<a name="ln1375">    }</a>
<a name="ln1376">    return TRUE;</a>
<a name="ln1377">  }</a>
<a name="ln1378">  else</a>
<a name="ln1379">  {</a>
<a name="ln1380">    int delta_x, delta_y;</a>
<a name="ln1381">    if(dt_gui_get_scroll_unit_deltas(e, &amp;delta_x, &amp;delta_y))</a>
<a name="ln1382">    {</a>
<a name="ln1383">      int move = -delta_x - delta_y;</a>
<a name="ln1384">      if(e-&gt;state &amp; GDK_SHIFT_MASK) move *= 2;</a>
<a name="ln1385"> </a>
<a name="ln1386">      _time_add(&amp;(strip-&gt;time_pos), move, strip-&gt;zoom);</a>
<a name="ln1387">      // we ensure that the fimlstrip stay in the bounds</a>
<a name="ln1388">      strip-&gt;time_pos = _selection_scroll_to(strip-&gt;time_pos, strip);</a>
<a name="ln1389"> </a>
<a name="ln1390">      cairo_surface_destroy(strip-&gt;surface);</a>
<a name="ln1391">      strip-&gt;surface = NULL;</a>
<a name="ln1392">      gtk_widget_queue_draw(strip-&gt;timeline);</a>
<a name="ln1393">    }</a>
<a name="ln1394">  }</a>
<a name="ln1395">  return FALSE;</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398">static gboolean _lib_timeline_mouse_leave_callback(GtkWidget *w, GdkEventCrossing *e, gpointer user_data)</a>
<a name="ln1399">{</a>
<a name="ln1400">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1401">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln1402"> </a>
<a name="ln1403">  strip-&gt;in = FALSE;</a>
<a name="ln1404"> </a>
<a name="ln1405">  gtk_widget_queue_draw(strip-&gt;timeline);</a>
<a name="ln1406">  return TRUE;</a>
<a name="ln1407">}</a>
<a name="ln1408"> </a>
<a name="ln1409">static gboolean _lib_timeline_size_handle_cursor_callback(GtkWidget *w, GdkEventCrossing *e, gpointer user_data)</a>
<a name="ln1410">{</a>
<a name="ln1411">  dt_control_change_cursor((e-&gt;type == GDK_ENTER_NOTIFY) ? GDK_SB_V_DOUBLE_ARROW : GDK_LEFT_PTR);</a>
<a name="ln1412">  return TRUE;</a>
<a name="ln1413">}</a>
<a name="ln1414"> </a>
<a name="ln1415">static gboolean _lib_timeline_size_handle_button_callback(GtkWidget *w, GdkEventButton *e, gpointer user_data)</a>
<a name="ln1416">{</a>
<a name="ln1417">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1418">  dt_lib_timeline_t *d = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln1419"> </a>
<a name="ln1420">  if(e-&gt;button == 1)</a>
<a name="ln1421">  {</a>
<a name="ln1422">    if(e-&gt;type == GDK_BUTTON_PRESS)</a>
<a name="ln1423">    {</a>
<a name="ln1424">/* store current  mousepointer position */</a>
<a name="ln1425">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln1426">      gdk_window_get_device_position(e-&gt;window,</a>
<a name="ln1427">                                     gdk_seat_get_pointer(gdk_display_get_default_seat(gdk_window_get_display(</a>
<a name="ln1428">                                         gtk_widget_get_window(dt_ui_main_window(darktable.gui-&gt;ui))))),</a>
<a name="ln1429">                                     &amp;d-&gt;size_handle_x, &amp;d-&gt;size_handle_y, 0);</a>
<a name="ln1430">#else</a>
<a name="ln1431">      gdk_window_get_device_position(</a>
<a name="ln1432">          gtk_widget_get_window(dt_ui_main_window(darktable.gui-&gt;ui)),</a>
<a name="ln1433">          gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(</a>
<a name="ln1434">              gdk_window_get_display(gtk_widget_get_window(dt_ui_main_window(darktable.gui-&gt;ui))))),</a>
<a name="ln1435">          &amp;d-&gt;size_handle_x, &amp;d-&gt;size_handle_y, NULL);</a>
<a name="ln1436">#endif</a>
<a name="ln1437"> </a>
<a name="ln1438">      gtk_widget_get_size_request(d-&gt;timeline, NULL, &amp;d-&gt;size_handle_height);</a>
<a name="ln1439">      d-&gt;size_handle_is_dragging = TRUE;</a>
<a name="ln1440">      cairo_surface_destroy(d-&gt;surface);</a>
<a name="ln1441">      d-&gt;surface = NULL;</a>
<a name="ln1442">    }</a>
<a name="ln1443">    else if(e-&gt;type == GDK_BUTTON_RELEASE)</a>
<a name="ln1444">      d-&gt;size_handle_is_dragging = FALSE;</a>
<a name="ln1445">  }</a>
<a name="ln1446">  return TRUE;</a>
<a name="ln1447">}</a>
<a name="ln1448"> </a>
<a name="ln1449">static gboolean _lib_timeline_size_handle_motion_notify_callback(GtkWidget *w, GdkEventButton *e,</a>
<a name="ln1450">                                                                 gpointer user_data)</a>
<a name="ln1451">{</a>
<a name="ln1452">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1453">  dt_lib_timeline_t *d = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln1454">  if(d-&gt;size_handle_is_dragging)</a>
<a name="ln1455">  {</a>
<a name="ln1456">    gint x, y, sx, sy;</a>
<a name="ln1457">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln1458">    gdk_window_get_device_position(e-&gt;window,</a>
<a name="ln1459">                                   gdk_seat_get_pointer(gdk_display_get_default_seat(gdk_window_get_display(</a>
<a name="ln1460">                                       gtk_widget_get_window(dt_ui_main_window(darktable.gui-&gt;ui))))),</a>
<a name="ln1461">                                   &amp;x, &amp;y, 0);</a>
<a name="ln1462">#else</a>
<a name="ln1463">    gdk_window_get_device_position(</a>
<a name="ln1464">        gtk_widget_get_window(dt_ui_main_window(darktable.gui-&gt;ui)),</a>
<a name="ln1465">        gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(</a>
<a name="ln1466">            gdk_window_get_display(gtk_widget_get_window(dt_ui_main_window(darktable.gui-&gt;ui))))),</a>
<a name="ln1467">        &amp;x, &amp;y, NULL);</a>
<a name="ln1468">#endif</a>
<a name="ln1469"> </a>
<a name="ln1470">    gtk_widget_get_size_request(d-&gt;timeline, &amp;sx, &amp;sy);</a>
<a name="ln1471">    sy = CLAMP(d-&gt;size_handle_height + (d-&gt;size_handle_y - y), DT_PIXEL_APPLY_DPI(64), DT_PIXEL_APPLY_DPI(400));</a>
<a name="ln1472"> </a>
<a name="ln1473">    dt_conf_set_int(&quot;plugins/lighttable/timeline/height&quot;, sy);</a>
<a name="ln1474"> </a>
<a name="ln1475">    cairo_surface_destroy(d-&gt;surface);</a>
<a name="ln1476">    d-&gt;surface = NULL;</a>
<a name="ln1477">    gtk_widget_set_size_request(d-&gt;timeline, -1, sy);</a>
<a name="ln1478"> </a>
<a name="ln1479">    return TRUE;</a>
<a name="ln1480">  }</a>
<a name="ln1481"> </a>
<a name="ln1482">  return FALSE;</a>
<a name="ln1483">}</a>
<a name="ln1484"> </a>
<a name="ln1485">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln1486">{</a>
<a name="ln1487">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;start selection&quot;), GDK_KEY_bracketleft, 0);</a>
<a name="ln1488">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;stop selection&quot;), GDK_KEY_bracketright, 0);</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln1492">{</a>
<a name="ln1493">  GClosure *closure = g_cclosure_new(G_CALLBACK(_selection_start), (gpointer)self-&gt;data, NULL);</a>
<a name="ln1494">  dt_accel_connect_lib(self, &quot;start selection&quot;, closure);</a>
<a name="ln1495">  closure = g_cclosure_new(G_CALLBACK(_selection_stop), (gpointer)self-&gt;data, NULL);</a>
<a name="ln1496">  dt_accel_connect_lib(self, &quot;stop selection&quot;, closure);</a>
<a name="ln1497">}</a>
<a name="ln1498"> </a>
<a name="ln1499">void gui_init(dt_lib_module_t *self)</a>
<a name="ln1500">{</a>
<a name="ln1501">  /* initialize ui widgets */</a>
<a name="ln1502">  dt_lib_timeline_t *d = (dt_lib_timeline_t *)calloc(1, sizeof(dt_lib_timeline_t));</a>
<a name="ln1503">  self-&gt;data = (void *)d;</a>
<a name="ln1504"> </a>
<a name="ln1505">  d-&gt;zoom = CLAMP(dt_conf_get_int(&quot;plugins/lighttable/timeline/last_zoom&quot;), 0, 8);</a>
<a name="ln1506">  if(d-&gt;zoom % 2 == 0)</a>
<a name="ln1507">    d-&gt;precision = d-&gt;zoom + 2;</a>
<a name="ln1508">  else</a>
<a name="ln1509">    d-&gt;precision = d-&gt;zoom + 1;</a>
<a name="ln1510"> </a>
<a name="ln1511">  d-&gt;time_mini = _time_init();</a>
<a name="ln1512">  d-&gt;time_maxi = _time_init();</a>
<a name="ln1513">  d-&gt;start_t = _time_init();</a>
<a name="ln1514">  d-&gt;stop_t = _time_init();</a>
<a name="ln1515"> </a>
<a name="ln1516">  _time_read_bounds_from_db(self);</a>
<a name="ln1517">  d-&gt;time_pos = d-&gt;time_mini;</a>
<a name="ln1518">  /* creating drawing area */</a>
<a name="ln1519">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1520"> </a>
<a name="ln1521">  /* creating timeline box*/</a>
<a name="ln1522">  d-&gt;timeline = gtk_event_box_new();</a>
<a name="ln1523"> </a>
<a name="ln1524">  /* set size of timeline */</a>
<a name="ln1525">  int32_t height = dt_conf_get_int(&quot;plugins/lighttable/timeline/height&quot;);</a>
<a name="ln1526">  gtk_widget_set_size_request(d-&gt;timeline, -1, CLAMP(height, DT_PIXEL_APPLY_DPI(64), DT_PIXEL_APPLY_DPI(400)));</a>
<a name="ln1527"> </a>
<a name="ln1528">  gtk_widget_add_events(d-&gt;timeline, GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK</a>
<a name="ln1529">                                         | GDK_BUTTON_RELEASE_MASK | darktable.gui-&gt;scroll_mask</a>
<a name="ln1530">                                         | GDK_LEAVE_NOTIFY_MASK);</a>
<a name="ln1531"> </a>
<a name="ln1532">  g_signal_connect(G_OBJECT(d-&gt;timeline), &quot;draw&quot;, G_CALLBACK(_lib_timeline_draw_callback), self);</a>
<a name="ln1533">  g_signal_connect(G_OBJECT(d-&gt;timeline), &quot;button-press-event&quot;, G_CALLBACK(_lib_timeline_button_press_callback),</a>
<a name="ln1534">                   self);</a>
<a name="ln1535">  g_signal_connect(G_OBJECT(d-&gt;timeline), &quot;button-release-event&quot;,</a>
<a name="ln1536">                   G_CALLBACK(_lib_timeline_button_release_callback), self);</a>
<a name="ln1537">  g_signal_connect(G_OBJECT(d-&gt;timeline), &quot;scroll-event&quot;, G_CALLBACK(_lib_timeline_scroll_callback), self);</a>
<a name="ln1538">  g_signal_connect(G_OBJECT(d-&gt;timeline), &quot;motion-notify-event&quot;, G_CALLBACK(_lib_timeline_motion_notify_callback),</a>
<a name="ln1539">                   self);</a>
<a name="ln1540">  g_signal_connect(G_OBJECT(d-&gt;timeline), &quot;leave-notify-event&quot;, G_CALLBACK(_lib_timeline_mouse_leave_callback),</a>
<a name="ln1541">                   self);</a>
<a name="ln1542">  /* create the resize handle */</a>
<a name="ln1543">  GtkWidget *size_handle = gtk_event_box_new();</a>
<a name="ln1544">  gtk_widget_set_size_request(size_handle, -1, DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln1545">  gtk_widget_add_events(size_handle, GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK</a>
<a name="ln1546">                                         | GDK_BUTTON_RELEASE_MASK | GDK_ENTER_NOTIFY_MASK</a>
<a name="ln1547">                                         | GDK_LEAVE_NOTIFY_MASK);</a>
<a name="ln1548">  g_signal_connect(G_OBJECT(size_handle), &quot;button-press-event&quot;,</a>
<a name="ln1549">                   G_CALLBACK(_lib_timeline_size_handle_button_callback), self);</a>
<a name="ln1550">  g_signal_connect(G_OBJECT(size_handle), &quot;button-release-event&quot;,</a>
<a name="ln1551">                   G_CALLBACK(_lib_timeline_size_handle_button_callback), self);</a>
<a name="ln1552">  g_signal_connect(G_OBJECT(size_handle), &quot;motion-notify-event&quot;,</a>
<a name="ln1553">                   G_CALLBACK(_lib_timeline_size_handle_motion_notify_callback), self);</a>
<a name="ln1554">  g_signal_connect(G_OBJECT(size_handle), &quot;leave-notify-event&quot;,</a>
<a name="ln1555">                   G_CALLBACK(_lib_timeline_size_handle_cursor_callback), self);</a>
<a name="ln1556">  g_signal_connect(G_OBJECT(size_handle), &quot;enter-notify-event&quot;,</a>
<a name="ln1557">                   G_CALLBACK(_lib_timeline_size_handle_cursor_callback), self);</a>
<a name="ln1558"> </a>
<a name="ln1559">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), size_handle, FALSE, FALSE, 0);</a>
<a name="ln1560">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), d-&gt;timeline, FALSE, FALSE, 0);</a>
<a name="ln1561"> </a>
<a name="ln1562">  // we update the selection with actual collect rules</a>
<a name="ln1563">  _lib_timeline_collection_changed(NULL, self);</a>
<a name="ln1564"> </a>
<a name="ln1565">  /* initialize view manager proxy */</a>
<a name="ln1566">  darktable.view_manager-&gt;proxy.timeline.module = self;</a>
<a name="ln1567"> </a>
<a name="ln1568">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED,</a>
<a name="ln1569">                            G_CALLBACK(_lib_timeline_collection_changed), (gpointer)self);</a>
<a name="ln1570">}</a>
<a name="ln1571"> </a>
<a name="ln1572">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln1573">{</a>
<a name="ln1574">  /* cleanup */</a>
<a name="ln1575">  dt_lib_timeline_t *strip = (dt_lib_timeline_t *)self-&gt;data;</a>
<a name="ln1576">  if(strip-&gt;blocks) g_list_free_full(strip-&gt;blocks, _block_free);</a>
<a name="ln1577">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_timeline_collection_changed), self);</a>
<a name="ln1578">  /* unset viewmanager proxy */</a>
<a name="ln1579">  darktable.view_manager-&gt;proxy.timeline.module = NULL;</a>
<a name="ln1580">  free(self-&gt;data);</a>
<a name="ln1581">  self-&gt;data = NULL;</a>
<a name="ln1582">}</a>
<a name="ln1583"> </a>
<a name="ln1584"> </a>
<a name="ln1585">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1586">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1587">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="233"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1016/" target="_blank">V1016</a> Expression 'zoom >= DT_LIB_TIMELINE_ZOOM_YEAR' is always true.</p></div>
<div class="balloon" rel="555"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: zoom == DT_LIB_TIMELINE_ZOOM_MINUTE.</p></div>
<div class="balloon" rel="787"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'bloc'. Check lines: 787, 786.</p></div>
<div class="balloon" rel="814"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'bloc->values'. Check lines: 814, 790.</p></div>
<div class="balloon" rel="815"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'bloc->collect_values'. Check lines: 815, 791.</p></div>
<div class="balloon" rel="1505"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 1505, 1502.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
