
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4">    copyright (c) 2011-2014 henrik andersson.</a>
<a name="ln5">    copyright (c) 2012 tobias ellinghaus.</a>
<a name="ln6"> </a>
<a name="ln7">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln8">    it under the terms of the GNU General Public License as published by</a>
<a name="ln9">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln10">    (at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln13">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">    GNU General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">    You should have received a copy of the GNU General Public License</a>
<a name="ln18">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln19">*/</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;views/view.h&quot;</a>
<a name="ln22">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln23">#include &quot;common/collection.h&quot;</a>
<a name="ln24">#include &quot;common/darktable.h&quot;</a>
<a name="ln25">#include &quot;common/debug.h&quot;</a>
<a name="ln26">#include &quot;common/history.h&quot;</a>
<a name="ln27">#include &quot;common/image_cache.h&quot;</a>
<a name="ln28">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln29">#include &quot;common/module.h&quot;</a>
<a name="ln30">#include &quot;common/undo.h&quot;</a>
<a name="ln31">#include &quot;common/usermanual_url.h&quot;</a>
<a name="ln32">#include &quot;control/conf.h&quot;</a>
<a name="ln33">#include &quot;control/control.h&quot;</a>
<a name="ln34">#include &quot;develop/develop.h&quot;</a>
<a name="ln35">#include &quot;dtgtk/expander.h&quot;</a>
<a name="ln36">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln37">#include &quot;gui/draw.h&quot;</a>
<a name="ln38">#include &quot;gui/gtk.h&quot;</a>
<a name="ln39">#include &quot;libs/lib.h&quot;</a>
<a name="ln40">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln41">#include &quot;osx/osx.h&quot;</a>
<a name="ln42">#endif</a>
<a name="ln43"> </a>
<a name="ln44">#include &lt;glib.h&gt;</a>
<a name="ln45">#include &lt;math.h&gt;</a>
<a name="ln46">#include &lt;stdio.h&gt;</a>
<a name="ln47">#include &lt;stdlib.h&gt;</a>
<a name="ln48">#include &lt;string.h&gt;</a>
<a name="ln49">#include &lt;strings.h&gt;</a>
<a name="ln50"> </a>
<a name="ln51">#define DECORATION_SIZE_LIMIT 40</a>
<a name="ln52"> </a>
<a name="ln53">static void dt_view_manager_load_modules(dt_view_manager_t *vm);</a>
<a name="ln54">static int dt_view_load_module(void *v, const char *libname, const char *module_name);</a>
<a name="ln55">static void dt_view_unload_module(dt_view_t *view);</a>
<a name="ln56"> </a>
<a name="ln57">void dt_view_manager_init(dt_view_manager_t *vm)</a>
<a name="ln58">{</a>
<a name="ln59">  /* prepare statements */</a>
<a name="ln60">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images &quot;</a>
<a name="ln61">                              &quot;WHERE imgid = ?1&quot;, -1, &amp;vm-&gt;statements.is_selected, NULL);</a>
<a name="ln62">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images WHERE imgid = ?1&quot;,</a>
<a name="ln63">                              -1, &amp;vm-&gt;statements.delete_from_selected, NULL);</a>
<a name="ln64">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln65">                              &quot;INSERT OR IGNORE INTO main.selected_images VALUES (?1)&quot;, -1,</a>
<a name="ln66">                              &amp;vm-&gt;statements.make_selected, NULL);</a>
<a name="ln67">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT num FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln68">                              &amp;vm-&gt;statements.have_history, NULL);</a>
<a name="ln69">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT color FROM main.color_labels WHERE imgid=?1&quot;,</a>
<a name="ln70">                              -1, &amp;vm-&gt;statements.get_color, NULL);</a>
<a name="ln71">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln72">      dt_database_get(darktable.db),</a>
<a name="ln73">      &quot;SELECT id FROM main.images WHERE group_id = (SELECT group_id FROM main.images WHERE id=?1) AND id != ?2&quot;,</a>
<a name="ln74">      -1, &amp;vm-&gt;statements.get_grouped, NULL);</a>
<a name="ln75"> </a>
<a name="ln76">  dt_view_manager_load_modules(vm);</a>
<a name="ln77"> </a>
<a name="ln78">  // Modules loaded, let's handle specific cases</a>
<a name="ln79">  for(GList *iter = vm-&gt;views; iter; iter = g_list_next(iter))</a>
<a name="ln80">  {</a>
<a name="ln81">    dt_view_t *view = (dt_view_t *)iter-&gt;data;</a>
<a name="ln82">    if(!strcmp(view-&gt;module_name, &quot;darkroom&quot;))</a>
<a name="ln83">    {</a>
<a name="ln84">      darktable.develop = (dt_develop_t *)view-&gt;data;</a>
<a name="ln85">      break;</a>
<a name="ln86">    }</a>
<a name="ln87">  }</a>
<a name="ln88"> </a>
<a name="ln89">  vm-&gt;current_view = NULL;</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">void dt_view_manager_gui_init(dt_view_manager_t *vm)</a>
<a name="ln93">{</a>
<a name="ln94">  for(GList *iter = vm-&gt;views; iter; iter = g_list_next(iter))</a>
<a name="ln95">  {</a>
<a name="ln96">    dt_view_t *view = (dt_view_t *)iter-&gt;data;</a>
<a name="ln97">    if(view-&gt;gui_init) view-&gt;gui_init(view);</a>
<a name="ln98">  }</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">void dt_view_manager_cleanup(dt_view_manager_t *vm)</a>
<a name="ln102">{</a>
<a name="ln103">  for(GList *iter = vm-&gt;views; iter; iter = g_list_next(iter)) dt_view_unload_module((dt_view_t *)iter-&gt;data);</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">const dt_view_t *dt_view_manager_get_current_view(dt_view_manager_t *vm)</a>
<a name="ln107">{</a>
<a name="ln108">  return vm-&gt;current_view;</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">// we want a stable order of views, for example for viewswitcher.</a>
<a name="ln112">// anything not hardcoded will be put alphabetically wrt. localised names.</a>
<a name="ln113">static gint sort_views(gconstpointer a, gconstpointer b)</a>
<a name="ln114">{</a>
<a name="ln115">  static const char *view_order[] = {&quot;lighttable&quot;, &quot;darkroom&quot;};</a>
<a name="ln116">  static const int n_view_order = G_N_ELEMENTS(view_order);</a>
<a name="ln117"> </a>
<a name="ln118">  dt_view_t *av = (dt_view_t *)a;</a>
<a name="ln119">  dt_view_t *bv = (dt_view_t *)b;</a>
<a name="ln120">  const char *aname = av-&gt;name(av);</a>
<a name="ln121">  const char *bname = bv-&gt;name(bv);</a>
<a name="ln122">  int apos = n_view_order;</a>
<a name="ln123">  int bpos = n_view_order;</a>
<a name="ln124"> </a>
<a name="ln125">  for(int i = 0; i &lt; n_view_order; i++)</a>
<a name="ln126">  {</a>
<a name="ln127">    if(!strcmp(av-&gt;module_name, view_order[i])) apos = i;</a>
<a name="ln128">    if(!strcmp(bv-&gt;module_name, view_order[i])) bpos = i;</a>
<a name="ln129">  }</a>
<a name="ln130"> </a>
<a name="ln131">  // order will be zero iff apos == bpos which can only happen when both views are not in view_order</a>
<a name="ln132">  const int order = apos - bpos;</a>
<a name="ln133">  return order ? order : strcmp(aname, bname);</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">static void dt_view_manager_load_modules(dt_view_manager_t *vm)</a>
<a name="ln137">{</a>
<a name="ln138">  vm-&gt;views = dt_module_load_modules(&quot;/views&quot;, sizeof(dt_view_t), dt_view_load_module, NULL, sort_views);</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141">/* default flags for view which does not implement the flags() function */</a>
<a name="ln142">static uint32_t default_flags()</a>
<a name="ln143">{</a>
<a name="ln144">  return 0;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">/** load a view module */</a>
<a name="ln148">static int dt_view_load_module(void *v, const char *libname, const char *module_name)</a>
<a name="ln149">{</a>
<a name="ln150">  dt_view_t *view = (dt_view_t *)v;</a>
<a name="ln151"> </a>
<a name="ln152">  view-&gt;data = NULL;</a>
<a name="ln153">  view-&gt;vscroll_size = view-&gt;vscroll_viewport_size = 1.0;</a>
<a name="ln154">  view-&gt;hscroll_size = view-&gt;hscroll_viewport_size = 1.0;</a>
<a name="ln155">  view-&gt;vscroll_pos = view-&gt;hscroll_pos = 0.0;</a>
<a name="ln156">  view-&gt;height = view-&gt;width = 100; // set to non-insane defaults before first expose/configure.</a>
<a name="ln157">  g_strlcpy(view-&gt;module_name, module_name, sizeof(view-&gt;module_name));</a>
<a name="ln158">  dt_print(DT_DEBUG_CONTROL, &quot;[view_load_module] loading view `%s' from %s\n&quot;, module_name, libname);</a>
<a name="ln159">  view-&gt;module = g_module_open(libname, G_MODULE_BIND_LAZY | G_MODULE_BIND_LOCAL);</a>
<a name="ln160">  if(!view-&gt;module)</a>
<a name="ln161">  {</a>
<a name="ln162">    fprintf(stderr, &quot;[view_load_module] could not open %s (%s)!\n&quot;, libname, g_module_error());</a>
<a name="ln163">    goto error;</a>
<a name="ln164">  }</a>
<a name="ln165">  int (*version)();</a>
<a name="ln166">  if(!g_module_symbol(view-&gt;module, &quot;dt_module_dt_version&quot;, (gpointer) &amp; (version))) goto error;</a>
<a name="ln167">  if(version() != dt_version())</a>
<a name="ln168">  {</a>
<a name="ln169">    fprintf(stderr, &quot;[view_load_module] `%s' is compiled for another version of dt (module %d != dt %d) !\n&quot;,</a>
<a name="ln170">            libname, version(), dt_version());</a>
<a name="ln171">    goto error;</a>
<a name="ln172">  }</a>
<a name="ln173">  if(!g_module_symbol(view-&gt;module, &quot;name&quot;, (gpointer) &amp; (view-&gt;name))) view-&gt;name = NULL;</a>
<a name="ln174">  if(!g_module_symbol(view-&gt;module, &quot;view&quot;, (gpointer) &amp; (view-&gt;view))) view-&gt;view = NULL;</a>
<a name="ln175">  if(!g_module_symbol(view-&gt;module, &quot;flags&quot;, (gpointer) &amp; (view-&gt;flags))) view-&gt;flags = default_flags;</a>
<a name="ln176">  if(!g_module_symbol(view-&gt;module, &quot;init&quot;, (gpointer) &amp; (view-&gt;init))) view-&gt;init = NULL;</a>
<a name="ln177">  if(!g_module_symbol(view-&gt;module, &quot;gui_init&quot;, (gpointer) &amp; (view-&gt;gui_init))) view-&gt;gui_init = NULL;</a>
<a name="ln178">  if(!g_module_symbol(view-&gt;module, &quot;cleanup&quot;, (gpointer) &amp; (view-&gt;cleanup))) view-&gt;cleanup = NULL;</a>
<a name="ln179">  if(!g_module_symbol(view-&gt;module, &quot;expose&quot;, (gpointer) &amp; (view-&gt;expose))) view-&gt;expose = NULL;</a>
<a name="ln180">  if(!g_module_symbol(view-&gt;module, &quot;try_enter&quot;, (gpointer) &amp; (view-&gt;try_enter))) view-&gt;try_enter = NULL;</a>
<a name="ln181">  if(!g_module_symbol(view-&gt;module, &quot;enter&quot;, (gpointer) &amp; (view-&gt;enter))) view-&gt;enter = NULL;</a>
<a name="ln182">  if(!g_module_symbol(view-&gt;module, &quot;leave&quot;, (gpointer) &amp; (view-&gt;leave))) view-&gt;leave = NULL;</a>
<a name="ln183">  if(!g_module_symbol(view-&gt;module, &quot;reset&quot;, (gpointer) &amp; (view-&gt;reset))) view-&gt;reset = NULL;</a>
<a name="ln184">  if(!g_module_symbol(view-&gt;module, &quot;mouse_enter&quot;, (gpointer) &amp; (view-&gt;mouse_enter)))</a>
<a name="ln185">    view-&gt;mouse_enter = NULL;</a>
<a name="ln186">  if(!g_module_symbol(view-&gt;module, &quot;mouse_leave&quot;, (gpointer) &amp; (view-&gt;mouse_leave)))</a>
<a name="ln187">    view-&gt;mouse_leave = NULL;</a>
<a name="ln188">  if(!g_module_symbol(view-&gt;module, &quot;mouse_moved&quot;, (gpointer) &amp; (view-&gt;mouse_moved)))</a>
<a name="ln189">    view-&gt;mouse_moved = NULL;</a>
<a name="ln190">  if(!g_module_symbol(view-&gt;module, &quot;button_released&quot;, (gpointer) &amp; (view-&gt;button_released)))</a>
<a name="ln191">    view-&gt;button_released = NULL;</a>
<a name="ln192">  if(!g_module_symbol(view-&gt;module, &quot;button_pressed&quot;, (gpointer) &amp; (view-&gt;button_pressed)))</a>
<a name="ln193">    view-&gt;button_pressed = NULL;</a>
<a name="ln194">  if(!g_module_symbol(view-&gt;module, &quot;key_pressed&quot;, (gpointer) &amp; (view-&gt;key_pressed)))</a>
<a name="ln195">    view-&gt;key_pressed = NULL;</a>
<a name="ln196">  if(!g_module_symbol(view-&gt;module, &quot;key_released&quot;, (gpointer) &amp; (view-&gt;key_released)))</a>
<a name="ln197">    view-&gt;key_released = NULL;</a>
<a name="ln198">  if(!g_module_symbol(view-&gt;module, &quot;configure&quot;, (gpointer) &amp; (view-&gt;configure))) view-&gt;configure = NULL;</a>
<a name="ln199">  if(!g_module_symbol(view-&gt;module, &quot;scrolled&quot;, (gpointer) &amp; (view-&gt;scrolled))) view-&gt;scrolled = NULL;</a>
<a name="ln200">  if(!g_module_symbol(view-&gt;module, &quot;scrollbar_changed&quot;, (gpointer) &amp; (view-&gt;scrollbar_changed)))</a>
<a name="ln201">    view-&gt;scrollbar_changed = NULL;</a>
<a name="ln202">  if(!g_module_symbol(view-&gt;module, &quot;init_key_accels&quot;, (gpointer) &amp; (view-&gt;init_key_accels)))</a>
<a name="ln203">    view-&gt;init_key_accels = NULL;</a>
<a name="ln204">  if(!g_module_symbol(view-&gt;module, &quot;connect_key_accels&quot;, (gpointer) &amp; (view-&gt;connect_key_accels)))</a>
<a name="ln205">    view-&gt;connect_key_accels = NULL;</a>
<a name="ln206"> </a>
<a name="ln207">  view-&gt;accel_closures = NULL;</a>
<a name="ln208"> </a>
<a name="ln209">  if(!strcmp(view-&gt;module_name, &quot;darkroom&quot;)) darktable.develop = (dt_develop_t *)view-&gt;data;</a>
<a name="ln210"> </a>
<a name="ln211">#ifdef USE_LUA</a>
<a name="ln212">  dt_lua_register_view(darktable.lua_state.state, view);</a>
<a name="ln213">#endif</a>
<a name="ln214"> </a>
<a name="ln215">  if(view-&gt;init) view-&gt;init(view);</a>
<a name="ln216">  if(darktable.gui &amp;&amp; view-&gt;init_key_accels) view-&gt;init_key_accels(view);</a>
<a name="ln217"> </a>
<a name="ln218">  return 0;</a>
<a name="ln219"> </a>
<a name="ln220">error:</a>
<a name="ln221">  if(view-&gt;module) g_module_close(view-&gt;module);</a>
<a name="ln222">  return 1;</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">/** unload, cleanup */</a>
<a name="ln226">static void dt_view_unload_module(dt_view_t *view)</a>
<a name="ln227">{</a>
<a name="ln228">  if(view-&gt;cleanup) view-&gt;cleanup(view);</a>
<a name="ln229"> </a>
<a name="ln230">  g_slist_free(view-&gt;accel_closures);</a>
<a name="ln231"> </a>
<a name="ln232">  if(view-&gt;module) g_module_close(view-&gt;module);</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">void dt_vm_remove_child(GtkWidget *widget, gpointer data)</a>
<a name="ln236">{</a>
<a name="ln237">  gtk_container_remove(GTK_CONTAINER(data), widget);</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">/*</a>
<a name="ln241">   When expanders get destoyed, they destroy the child</a>
<a name="ln242">   so remove the child before that</a>
<a name="ln243">   */</a>
<a name="ln244">static void _remove_child(GtkWidget *child,GtkContainer *container)</a>
<a name="ln245">{</a>
<a name="ln246">    if(DTGTK_IS_EXPANDER(child))</a>
<a name="ln247">    {</a>
<a name="ln248">      GtkWidget * evb = dtgtk_expander_get_body_event_box(DTGTK_EXPANDER(child));</a>
<a name="ln249">      gtk_container_remove(GTK_CONTAINER(evb),dtgtk_expander_get_body(DTGTK_EXPANDER(child)));</a>
<a name="ln250">      gtk_widget_destroy(child);</a>
<a name="ln251">    }</a>
<a name="ln252">    else</a>
<a name="ln253">    {</a>
<a name="ln254">      gtk_container_remove(container,child);</a>
<a name="ln255">    }</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">int dt_view_manager_switch(dt_view_manager_t *vm, const char *view_name)</a>
<a name="ln259">{</a>
<a name="ln260">  gboolean switching_to_none = *view_name == '\0';</a>
<a name="ln261">  dt_view_t *new_view = NULL;</a>
<a name="ln262"> </a>
<a name="ln263">  if(!switching_to_none)</a>
<a name="ln264">  {</a>
<a name="ln265">    for(GList *iter = vm-&gt;views; iter; iter = g_list_next(iter))</a>
<a name="ln266">    {</a>
<a name="ln267">      dt_view_t *v = (dt_view_t *)iter-&gt;data;</a>
<a name="ln268">      if(!strcmp(v-&gt;module_name, view_name))</a>
<a name="ln269">      {</a>
<a name="ln270">        new_view = v;</a>
<a name="ln271">        break;</a>
<a name="ln272">      }</a>
<a name="ln273">    }</a>
<a name="ln274">    if(!new_view) return 1; // the requested view doesn't exist</a>
<a name="ln275">  }</a>
<a name="ln276"> </a>
<a name="ln277">  return dt_view_manager_switch_by_view(vm, new_view);</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">int dt_view_manager_switch_by_view(dt_view_manager_t *vm, const dt_view_t *nv)</a>
<a name="ln281">{</a>
<a name="ln282">  dt_view_t *old_view = vm-&gt;current_view;</a>
<a name="ln283">  dt_view_t *new_view = (dt_view_t *)nv; // views belong to us, we can de-const them :-)</a>
<a name="ln284"> </a>
<a name="ln285">  // Before switching views, restore accelerators if disabled</a>
<a name="ln286">  if(!darktable.control-&gt;key_accelerators_on) dt_control_key_accelerators_on(darktable.control);</a>
<a name="ln287"> </a>
<a name="ln288">  // reset the cursor to the default one</a>
<a name="ln289">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln290"> </a>
<a name="ln291">  // also ignore what scrolling there was previously happening</a>
<a name="ln292">  memset(darktable.gui-&gt;scroll_to, 0, sizeof(darktable.gui-&gt;scroll_to));</a>
<a name="ln293"> </a>
<a name="ln294">  // destroy old module list</a>
<a name="ln295"> </a>
<a name="ln296">  /*  clear the undo list, for now we do this inconditionally. At some point we will probably want to clear</a>
<a name="ln297">     only part</a>
<a name="ln298">      of the undo list. This should probably done with a view proxy routine returning the type of undo to</a>
<a name="ln299">     remove. */</a>
<a name="ln300">  dt_undo_clear(darktable.undo, DT_UNDO_ALL);</a>
<a name="ln301"> </a>
<a name="ln302">  /* Special case when entering nothing (just before leaving dt) */</a>
<a name="ln303">  if(!new_view)</a>
<a name="ln304">  {</a>
<a name="ln305">    if(old_view)</a>
<a name="ln306">    {</a>
<a name="ln307">      /* leave the current view*/</a>
<a name="ln308">      if(old_view-&gt;leave) old_view-&gt;leave(old_view);</a>
<a name="ln309"> </a>
<a name="ln310">      /* iterator plugins and cleanup plugins in current view */</a>
<a name="ln311">      for(GList *iter = darktable.lib-&gt;plugins; iter; iter = g_list_next(iter))</a>
<a name="ln312">      {</a>
<a name="ln313">        dt_lib_module_t *plugin = (dt_lib_module_t *)(iter-&gt;data);</a>
<a name="ln314"> </a>
<a name="ln315">        /* does this module belong to current view ?*/</a>
<a name="ln316">        if(dt_lib_is_visible_in_view(plugin, old_view))</a>
<a name="ln317">        {</a>
<a name="ln318">          if(plugin-&gt;view_leave) plugin-&gt;view_leave(plugin, old_view, NULL);</a>
<a name="ln319">          plugin-&gt;gui_cleanup(plugin);</a>
<a name="ln320">          plugin-&gt;data = NULL;</a>
<a name="ln321">          dt_accel_disconnect_list(plugin-&gt;accel_closures);</a>
<a name="ln322">          plugin-&gt;accel_closures = NULL;</a>
<a name="ln323">          plugin-&gt;widget = NULL;</a>
<a name="ln324">        }</a>
<a name="ln325">      }</a>
<a name="ln326">    }</a>
<a name="ln327"> </a>
<a name="ln328">    /* remove all widgets in all containers */</a>
<a name="ln329">    for(int l = 0; l &lt; DT_UI_CONTAINER_SIZE; l++)</a>
<a name="ln330">      dt_ui_container_destroy_children(darktable.gui-&gt;ui, l);</a>
<a name="ln331">    vm-&gt;current_view = NULL;</a>
<a name="ln332">    return 0;</a>
<a name="ln333">  }</a>
<a name="ln334"> </a>
<a name="ln335">  // invariant: new_view != NULL after this point</a>
<a name="ln336">  assert(new_view != NULL);</a>
<a name="ln337"> </a>
<a name="ln338">  if(new_view-&gt;try_enter)</a>
<a name="ln339">  {</a>
<a name="ln340">    int error = new_view-&gt;try_enter(new_view);</a>
<a name="ln341">    if(error) return error;</a>
<a name="ln342">  }</a>
<a name="ln343"> </a>
<a name="ln344">  /* cleanup current view before initialization of new  */</a>
<a name="ln345">  if(old_view)</a>
<a name="ln346">  {</a>
<a name="ln347">    /* leave current view */</a>
<a name="ln348">    if(old_view-&gt;leave) old_view-&gt;leave(old_view);</a>
<a name="ln349">    dt_accel_disconnect_list(old_view-&gt;accel_closures);</a>
<a name="ln350">    old_view-&gt;accel_closures = NULL;</a>
<a name="ln351"> </a>
<a name="ln352">    /* iterator plugins and cleanup plugins in current view */</a>
<a name="ln353">    for(GList *iter = darktable.lib-&gt;plugins; iter; iter = g_list_next(iter))</a>
<a name="ln354">    {</a>
<a name="ln355">      dt_lib_module_t *plugin = (dt_lib_module_t *)(iter-&gt;data);</a>
<a name="ln356"> </a>
<a name="ln357">      /* does this module belong to current view ?*/</a>
<a name="ln358">      if(dt_lib_is_visible_in_view(plugin, old_view))</a>
<a name="ln359">      {</a>
<a name="ln360">        if(plugin-&gt;view_leave) plugin-&gt;view_leave(plugin, old_view, new_view);</a>
<a name="ln361">        dt_accel_disconnect_list(plugin-&gt;accel_closures);</a>
<a name="ln362">        plugin-&gt;accel_closures = NULL;</a>
<a name="ln363">      }</a>
<a name="ln364">    }</a>
<a name="ln365"> </a>
<a name="ln366">    /* remove all widets in all containers */</a>
<a name="ln367">    for(int l = 0; l &lt; DT_UI_CONTAINER_SIZE; l++)</a>
<a name="ln368">      dt_ui_container_foreach(darktable.gui-&gt;ui, l,(GtkCallback)_remove_child);</a>
<a name="ln369">  }</a>
<a name="ln370"> </a>
<a name="ln371">  /* change current view to the new view */</a>
<a name="ln372">  vm-&gt;current_view = new_view;</a>
<a name="ln373"> </a>
<a name="ln374">  /* restore visible stat of panels for the new view */</a>
<a name="ln375">  dt_ui_restore_panels(darktable.gui-&gt;ui);</a>
<a name="ln376"> </a>
<a name="ln377">  /* lets add plugins related to new view into panels.</a>
<a name="ln378">   * this has to be done in reverse order to have the lowest position at the bottom! */</a>
<a name="ln379">  for(GList *iter = g_list_last(darktable.lib-&gt;plugins); iter; iter = g_list_previous(iter))</a>
<a name="ln380">  {</a>
<a name="ln381">    dt_lib_module_t *plugin = (dt_lib_module_t *)(iter-&gt;data);</a>
<a name="ln382">    if(dt_lib_is_visible_in_view(plugin, new_view))</a>
<a name="ln383">    {</a>
<a name="ln384"> </a>
<a name="ln385">      /* try get the module expander  */</a>
<a name="ln386">      GtkWidget *w = dt_lib_gui_get_expander(plugin);</a>
<a name="ln387"> </a>
<a name="ln388">      if(plugin-&gt;connect_key_accels) plugin-&gt;connect_key_accels(plugin);</a>
<a name="ln389">      dt_lib_connect_common_accels(plugin);</a>
<a name="ln390"> </a>
<a name="ln391">      /* if we didn't get an expander let's add the widget */</a>
<a name="ln392">      if(!w) w = plugin-&gt;widget;</a>
<a name="ln393"> </a>
<a name="ln394">      dt_gui_add_help_link(w, dt_get_help_url(plugin-&gt;plugin_name));</a>
<a name="ln395">      // some plugins help links depend on the view</a>
<a name="ln396">      if(!strcmp(plugin-&gt;plugin_name,&quot;module_toolbox&quot;)</a>
<a name="ln397">        || !strcmp(plugin-&gt;plugin_name,&quot;view_toolbox&quot;))</a>
<a name="ln398">      {</a>
<a name="ln399">        dt_view_type_flags_t view_type = new_view-&gt;view(new_view);</a>
<a name="ln400">        if(view_type == DT_VIEW_LIGHTTABLE)</a>
<a name="ln401">          dt_gui_add_help_link(w,&quot;lighttable_chapter.html#lighttable_overview&quot;);</a>
<a name="ln402">        if(view_type == DT_VIEW_DARKROOM)</a>
<a name="ln403">          dt_gui_add_help_link(w,&quot;darkroom_bottom_panel.html#darkroom_bottom_panel&quot;);</a>
<a name="ln404">      }</a>
<a name="ln405"> </a>
<a name="ln406"> </a>
<a name="ln407">      /* add module to its container */</a>
<a name="ln408">      dt_ui_container_add_widget(darktable.gui-&gt;ui, plugin-&gt;container(plugin), w);</a>
<a name="ln409">    }</a>
<a name="ln410">  }</a>
<a name="ln411"> </a>
<a name="ln412">  /* hide/show modules as last config */</a>
<a name="ln413">  for(GList *iter = darktable.lib-&gt;plugins; iter; iter = g_list_next(iter))</a>
<a name="ln414">  {</a>
<a name="ln415">    dt_lib_module_t *plugin = (dt_lib_module_t *)(iter-&gt;data);</a>
<a name="ln416">    if(dt_lib_is_visible_in_view(plugin, new_view))</a>
<a name="ln417">    {</a>
<a name="ln418">      /* set expanded if last mode was that */</a>
<a name="ln419">      char var[1024];</a>
<a name="ln420">      gboolean expanded = FALSE;</a>
<a name="ln421">      gboolean visible = dt_lib_is_visible(plugin);</a>
<a name="ln422">      if(plugin-&gt;expandable(plugin))</a>
<a name="ln423">      {</a>
<a name="ln424">        snprintf(var, sizeof(var), &quot;plugins/%s/%s/expanded&quot;, new_view-&gt;module_name, plugin-&gt;plugin_name);</a>
<a name="ln425">        expanded = dt_conf_get_bool(var);</a>
<a name="ln426"> </a>
<a name="ln427">        dt_lib_gui_set_expanded(plugin, expanded);</a>
<a name="ln428">      }</a>
<a name="ln429">      else</a>
<a name="ln430">      {</a>
<a name="ln431">        /* show/hide plugin widget depending on expanded flag or if plugin</a>
<a name="ln432">            not is expandeable() */</a>
<a name="ln433">        if(visible)</a>
<a name="ln434">          gtk_widget_show_all(plugin-&gt;widget);</a>
<a name="ln435">        else</a>
<a name="ln436">          gtk_widget_hide(plugin-&gt;widget);</a>
<a name="ln437">      }</a>
<a name="ln438">      if(plugin-&gt;view_enter) plugin-&gt;view_enter(plugin, old_view, new_view);</a>
<a name="ln439">    }</a>
<a name="ln440">  }</a>
<a name="ln441"> </a>
<a name="ln442">  /* enter view. crucially, do this before initing the plugins below,</a>
<a name="ln443">      as e.g. modulegroups requires the dr stuff to be inited. */</a>
<a name="ln444">  if(new_view-&gt;enter) new_view-&gt;enter(new_view);</a>
<a name="ln445">  if(new_view-&gt;connect_key_accels) new_view-&gt;connect_key_accels(new_view);</a>
<a name="ln446"> </a>
<a name="ln447">  /* update the scrollbars */</a>
<a name="ln448">  dt_ui_update_scrollbars(darktable.gui-&gt;ui);</a>
<a name="ln449"> </a>
<a name="ln450">  /* raise view changed signal */</a>
<a name="ln451">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_VIEWMANAGER_VIEW_CHANGED, old_view, new_view);</a>
<a name="ln452"> </a>
<a name="ln453">  return 0;</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">const char *dt_view_manager_name(dt_view_manager_t *vm)</a>
<a name="ln457">{</a>
<a name="ln458">  if(!vm-&gt;current_view) return &quot;&quot;;</a>
<a name="ln459">  if(vm-&gt;current_view-&gt;name)</a>
<a name="ln460">    return vm-&gt;current_view-&gt;name(vm-&gt;current_view);</a>
<a name="ln461">  else</a>
<a name="ln462">    return vm-&gt;current_view-&gt;module_name;</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">void dt_view_manager_expose(dt_view_manager_t *vm, cairo_t *cr, int32_t width, int32_t height,</a>
<a name="ln466">                            int32_t pointerx, int32_t pointery)</a>
<a name="ln467">{</a>
<a name="ln468">  if(!vm-&gt;current_view)</a>
<a name="ln469">  {</a>
<a name="ln470">    dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_BG);</a>
<a name="ln471">    cairo_paint(cr);</a>
<a name="ln472">    return;</a>
<a name="ln473">  }</a>
<a name="ln474">  vm-&gt;current_view-&gt;width = width;</a>
<a name="ln475">  vm-&gt;current_view-&gt;height = height;</a>
<a name="ln476"> </a>
<a name="ln477">  if(vm-&gt;current_view-&gt;expose)</a>
<a name="ln478">  {</a>
<a name="ln479">    /* expose the view */</a>
<a name="ln480">    cairo_rectangle(cr, 0, 0, vm-&gt;current_view-&gt;width, vm-&gt;current_view-&gt;height);</a>
<a name="ln481">    cairo_clip(cr);</a>
<a name="ln482">    cairo_new_path(cr);</a>
<a name="ln483">    cairo_save(cr);</a>
<a name="ln484">    float px = pointerx, py = pointery;</a>
<a name="ln485">    if(pointery &gt; vm-&gt;current_view-&gt;height)</a>
<a name="ln486">    {</a>
<a name="ln487">      px = 10000.0;</a>
<a name="ln488">      py = -1.0;</a>
<a name="ln489">    }</a>
<a name="ln490">    vm-&gt;current_view-&gt;expose(vm-&gt;current_view, cr, vm-&gt;current_view-&gt;width, vm-&gt;current_view-&gt;height, px, py);</a>
<a name="ln491"> </a>
<a name="ln492">    cairo_restore(cr);</a>
<a name="ln493">    /* expose plugins */</a>
<a name="ln494">    GList *plugins = g_list_last(darktable.lib-&gt;plugins);</a>
<a name="ln495">    while(plugins)</a>
<a name="ln496">    {</a>
<a name="ln497">      dt_lib_module_t *plugin = (dt_lib_module_t *)(plugins-&gt;data);</a>
<a name="ln498"> </a>
<a name="ln499">      /* does this module belong to current view ?*/</a>
<a name="ln500">      if(plugin-&gt;gui_post_expose &amp;&amp; dt_lib_is_visible_in_view(plugin, vm-&gt;current_view))</a>
<a name="ln501">        plugin-&gt;gui_post_expose(plugin, cr, vm-&gt;current_view-&gt;width, vm-&gt;current_view-&gt;height, px, py);</a>
<a name="ln502"> </a>
<a name="ln503">      /* get next plugin */</a>
<a name="ln504">      plugins = g_list_previous(plugins);</a>
<a name="ln505">    }</a>
<a name="ln506">  }</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509">void dt_view_manager_reset(dt_view_manager_t *vm)</a>
<a name="ln510">{</a>
<a name="ln511">  if(!vm-&gt;current_view) return;</a>
<a name="ln512">  if(vm-&gt;current_view-&gt;reset) vm-&gt;current_view-&gt;reset(vm-&gt;current_view);</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">void dt_view_manager_mouse_leave(dt_view_manager_t *vm)</a>
<a name="ln516">{</a>
<a name="ln517">  if(!vm-&gt;current_view) return;</a>
<a name="ln518">  dt_view_t *v = vm-&gt;current_view;</a>
<a name="ln519"> </a>
<a name="ln520">  /* lets check if any plugins want to handle mouse move */</a>
<a name="ln521">  gboolean handled = FALSE;</a>
<a name="ln522">  GList *plugins = g_list_last(darktable.lib-&gt;plugins);</a>
<a name="ln523">  while(plugins)</a>
<a name="ln524">  {</a>
<a name="ln525">    dt_lib_module_t *plugin = (dt_lib_module_t *)(plugins-&gt;data);</a>
<a name="ln526"> </a>
<a name="ln527">    /* does this module belong to current view ?*/</a>
<a name="ln528">    if(plugin-&gt;mouse_leave &amp;&amp; dt_lib_is_visible_in_view(plugin, v))</a>
<a name="ln529">      if(plugin-&gt;mouse_leave(plugin)) handled = TRUE;</a>
<a name="ln530"> </a>
<a name="ln531">    /* get next plugin */</a>
<a name="ln532">    plugins = g_list_previous(plugins);</a>
<a name="ln533">  }</a>
<a name="ln534"> </a>
<a name="ln535">  /* if not handled by any plugin let pass to view handler*/</a>
<a name="ln536">  if(!handled &amp;&amp; v-&gt;mouse_leave) v-&gt;mouse_leave(v);</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539">void dt_view_manager_mouse_enter(dt_view_manager_t *vm)</a>
<a name="ln540">{</a>
<a name="ln541">  if(!vm-&gt;current_view) return;</a>
<a name="ln542">  if(vm-&gt;current_view-&gt;mouse_enter) vm-&gt;current_view-&gt;mouse_enter(vm-&gt;current_view);</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">void dt_view_manager_mouse_moved(dt_view_manager_t *vm, double x, double y, double pressure, int which)</a>
<a name="ln546">{</a>
<a name="ln547">  if(!vm-&gt;current_view) return;</a>
<a name="ln548">  dt_view_t *v = vm-&gt;current_view;</a>
<a name="ln549"> </a>
<a name="ln550">  /* lets check if any plugins want to handle mouse move */</a>
<a name="ln551">  gboolean handled = FALSE;</a>
<a name="ln552">  GList *plugins = g_list_last(darktable.lib-&gt;plugins);</a>
<a name="ln553">  while(plugins)</a>
<a name="ln554">  {</a>
<a name="ln555">    dt_lib_module_t *plugin = (dt_lib_module_t *)(plugins-&gt;data);</a>
<a name="ln556"> </a>
<a name="ln557">    /* does this module belong to current view ?*/</a>
<a name="ln558">    if(plugin-&gt;mouse_moved &amp;&amp; dt_lib_is_visible_in_view(plugin, v))</a>
<a name="ln559">      if(plugin-&gt;mouse_moved(plugin, x, y, pressure, which)) handled = TRUE;</a>
<a name="ln560"> </a>
<a name="ln561">    /* get next plugin */</a>
<a name="ln562">    plugins = g_list_previous(plugins);</a>
<a name="ln563">  }</a>
<a name="ln564"> </a>
<a name="ln565">  /* if not handled by any plugin let pass to view handler*/</a>
<a name="ln566">  if(!handled &amp;&amp; v-&gt;mouse_moved) v-&gt;mouse_moved(v, x, y, pressure, which);</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">int dt_view_manager_button_released(dt_view_manager_t *vm, double x, double y, int which, uint32_t state)</a>
<a name="ln570">{</a>
<a name="ln571">  if(!vm-&gt;current_view) return 0;</a>
<a name="ln572">  dt_view_t *v = vm-&gt;current_view;</a>
<a name="ln573"> </a>
<a name="ln574">  /* lets check if any plugins want to handle button press */</a>
<a name="ln575">  gboolean handled = FALSE;</a>
<a name="ln576">  GList *plugins = g_list_last(darktable.lib-&gt;plugins);</a>
<a name="ln577">  while(plugins)</a>
<a name="ln578">  {</a>
<a name="ln579">    dt_lib_module_t *plugin = (dt_lib_module_t *)(plugins-&gt;data);</a>
<a name="ln580"> </a>
<a name="ln581">    /* does this module belong to current view ?*/</a>
<a name="ln582">    if(plugin-&gt;button_released &amp;&amp; dt_lib_is_visible_in_view(plugin, v))</a>
<a name="ln583">      if(plugin-&gt;button_released(plugin, x, y, which, state)) handled = TRUE;</a>
<a name="ln584"> </a>
<a name="ln585">    /* get next plugin */</a>
<a name="ln586">    plugins = g_list_previous(plugins);</a>
<a name="ln587">  }</a>
<a name="ln588"> </a>
<a name="ln589">  if(handled) return 1;</a>
<a name="ln590">  /* if not handled by any plugin let pass to view handler*/</a>
<a name="ln591">  else if(v-&gt;button_released)</a>
<a name="ln592">    v-&gt;button_released(v, x, y, which, state);</a>
<a name="ln593"> </a>
<a name="ln594">  return 0;</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597">int dt_view_manager_button_pressed(dt_view_manager_t *vm, double x, double y, double pressure, int which,</a>
<a name="ln598">                                   int type, uint32_t state)</a>
<a name="ln599">{</a>
<a name="ln600">  if(!vm-&gt;current_view) return 0;</a>
<a name="ln601">  dt_view_t *v = vm-&gt;current_view;</a>
<a name="ln602"> </a>
<a name="ln603">  /* lets check if any plugins want to handle button press */</a>
<a name="ln604">  gboolean handled = FALSE;</a>
<a name="ln605">  GList *plugins = g_list_last(darktable.lib-&gt;plugins);</a>
<a name="ln606">  while(plugins &amp;&amp; !handled)</a>
<a name="ln607">  {</a>
<a name="ln608">    dt_lib_module_t *plugin = (dt_lib_module_t *)(plugins-&gt;data);</a>
<a name="ln609"> </a>
<a name="ln610">    /* does this module belong to current view ?*/</a>
<a name="ln611">    if(plugin-&gt;button_pressed &amp;&amp; dt_lib_is_visible_in_view(plugin, v))</a>
<a name="ln612">      if(plugin-&gt;button_pressed(plugin, x, y, pressure, which, type, state)) handled = TRUE;</a>
<a name="ln613"> </a>
<a name="ln614">    /* get next plugin */</a>
<a name="ln615">    plugins = g_list_previous(plugins);</a>
<a name="ln616">  }</a>
<a name="ln617"> </a>
<a name="ln618">  if(handled) return 1;</a>
<a name="ln619">  /* if not handled by any plugin let pass to view handler*/</a>
<a name="ln620">  else if(v-&gt;button_pressed)</a>
<a name="ln621">    return v-&gt;button_pressed(v, x, y, pressure, which, type, state);</a>
<a name="ln622"> </a>
<a name="ln623">  return 0;</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">int dt_view_manager_key_pressed(dt_view_manager_t *vm, guint key, guint state)</a>
<a name="ln627">{</a>
<a name="ln628">  int film_strip_result = 0;</a>
<a name="ln629">  if(!vm-&gt;current_view) return 0;</a>
<a name="ln630">  if(vm-&gt;current_view-&gt;key_pressed)</a>
<a name="ln631">    return vm-&gt;current_view-&gt;key_pressed(vm-&gt;current_view, key, state) || film_strip_result;</a>
<a name="ln632">  return 0;</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">int dt_view_manager_key_released(dt_view_manager_t *vm, guint key, guint state)</a>
<a name="ln636">{</a>
<a name="ln637">  int film_strip_result = 0;</a>
<a name="ln638">  if(!vm-&gt;current_view) return 0;</a>
<a name="ln639">  if(vm-&gt;current_view-&gt;key_released)</a>
<a name="ln640">    return vm-&gt;current_view-&gt;key_released(vm-&gt;current_view, key, state) || film_strip_result;</a>
<a name="ln641">  return 0;</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">void dt_view_manager_configure(dt_view_manager_t *vm, int width, int height)</a>
<a name="ln645">{</a>
<a name="ln646">  for(GList *iter = vm-&gt;views; iter; iter = g_list_next(iter))</a>
<a name="ln647">  {</a>
<a name="ln648">    // this is necessary for all</a>
<a name="ln649">    dt_view_t *v = (dt_view_t *)iter-&gt;data;</a>
<a name="ln650">    v-&gt;width = width;</a>
<a name="ln651">    v-&gt;height = height;</a>
<a name="ln652">    if(v-&gt;configure) v-&gt;configure(v, width, height);</a>
<a name="ln653">  }</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656">void dt_view_manager_scrolled(dt_view_manager_t *vm, double x, double y, int up, int state)</a>
<a name="ln657">{</a>
<a name="ln658">  if(!vm-&gt;current_view) return;</a>
<a name="ln659">  if(vm-&gt;current_view-&gt;scrolled) vm-&gt;current_view-&gt;scrolled(vm-&gt;current_view, x, y, up, state);</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">void dt_view_manager_scrollbar_changed(dt_view_manager_t *vm, double x, double y)</a>
<a name="ln663">{</a>
<a name="ln664">  if(!vm-&gt;current_view) return;</a>
<a name="ln665">  if(vm-&gt;current_view-&gt;scrollbar_changed) vm-&gt;current_view-&gt;scrollbar_changed(vm-&gt;current_view, x, y);</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668">void dt_view_set_scrollbar(dt_view_t *view, float hpos, float hlower, float hsize, float hwinsize,</a>
<a name="ln669">                           float vpos, float vlower, float vsize,float vwinsize)</a>
<a name="ln670">{</a>
<a name="ln671">  if (view-&gt;vscroll_pos == vpos &amp;&amp; view-&gt;vscroll_lower == vlower &amp;&amp; view-&gt;vscroll_size == vsize &amp;&amp;</a>
<a name="ln672">      view-&gt;vscroll_viewport_size == vwinsize &amp;&amp; view-&gt;hscroll_pos == hpos &amp;&amp; view-&gt;hscroll_lower == hlower &amp;&amp;</a>
<a name="ln673">      view-&gt;hscroll_size == hsize &amp;&amp; view-&gt;hscroll_viewport_size == hwinsize)</a>
<a name="ln674">    return;</a>
<a name="ln675"> </a>
<a name="ln676">  view-&gt;vscroll_pos = vpos;</a>
<a name="ln677">  view-&gt;vscroll_lower = vlower;</a>
<a name="ln678">  view-&gt;vscroll_size = vsize;</a>
<a name="ln679">  view-&gt;vscroll_viewport_size = vwinsize;</a>
<a name="ln680">  view-&gt;hscroll_pos = hpos;</a>
<a name="ln681">  view-&gt;hscroll_lower = hlower;</a>
<a name="ln682">  view-&gt;hscroll_size = hsize;</a>
<a name="ln683">  view-&gt;hscroll_viewport_size = hwinsize;</a>
<a name="ln684"> </a>
<a name="ln685">  GtkWidget *widget;</a>
<a name="ln686">  widget = darktable.gui-&gt;widgets.left_border;</a>
<a name="ln687">  gtk_widget_queue_draw(widget);</a>
<a name="ln688">  widget = darktable.gui-&gt;widgets.right_border;</a>
<a name="ln689">  gtk_widget_queue_draw(widget);</a>
<a name="ln690">  widget = darktable.gui-&gt;widgets.bottom_border;</a>
<a name="ln691">  gtk_widget_queue_draw(widget);</a>
<a name="ln692">  widget = darktable.gui-&gt;widgets.top_border;</a>
<a name="ln693">  gtk_widget_queue_draw(widget);</a>
<a name="ln694"> </a>
<a name="ln695">  if (!darktable.gui-&gt;scrollbars.dragging) dt_ui_update_scrollbars(darktable.gui-&gt;ui);</a>
<a name="ln696"> </a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">static inline void dt_view_draw_altered(cairo_t *cr, const float x, const float y, const float r)</a>
<a name="ln700">{</a>
<a name="ln701">  cairo_new_sub_path(cr);</a>
<a name="ln702">  cairo_arc(cr, x, y, r, 0, 2.0f * M_PI);</a>
<a name="ln703">  const float dx = r * cosf(M_PI / 8.0f), dy = r * sinf(M_PI / 8.0f);</a>
<a name="ln704">  cairo_move_to(cr, x - dx, y - dy);</a>
<a name="ln705">  cairo_curve_to(cr, x, y - 2 * dy, x, y + 2 * dy, x + dx, y + dy);</a>
<a name="ln706">  cairo_move_to(cr, x - .20 * dx, y + .8 * dy);</a>
<a name="ln707">  cairo_line_to(cr, x - .80 * dx, y + .8 * dy);</a>
<a name="ln708">  cairo_move_to(cr, x + .20 * dx, y - .8 * dy);</a>
<a name="ln709">  cairo_line_to(cr, x + .80 * dx, y - .8 * dy);</a>
<a name="ln710">  cairo_move_to(cr, x + .50 * dx, y - .8 * dy - 0.3 * dx);</a>
<a name="ln711">  cairo_line_to(cr, x + .50 * dx, y - .8 * dy + 0.3 * dx);</a>
<a name="ln712">  cairo_stroke(cr);</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715">static inline void dt_view_draw_audio(cairo_t *cr, const float x, const float y, const float r)</a>
<a name="ln716">{</a>
<a name="ln717">  const float d = 2.0 * r;</a>
<a name="ln718"> </a>
<a name="ln719">  cairo_save(cr);</a>
<a name="ln720"> </a>
<a name="ln721">  cairo_translate(cr, x - (d / 2.0), y - (d / 2.0));</a>
<a name="ln722">  cairo_scale(cr, d, d);</a>
<a name="ln723"> </a>
<a name="ln724">  cairo_rectangle(cr, 0.05, 0.4, 0.2, 0.2);</a>
<a name="ln725">  cairo_move_to(cr, 0.25, 0.6);</a>
<a name="ln726">  cairo_line_to(cr, 0.45, 0.77);</a>
<a name="ln727">  cairo_line_to(cr, 0.45, 0.23);</a>
<a name="ln728">  cairo_line_to(cr, 0.25, 0.4);</a>
<a name="ln729"> </a>
<a name="ln730">  cairo_new_sub_path(cr);</a>
<a name="ln731">  cairo_arc(cr, 0.2, 0.5, 0.45, -(35.0 / 180.0) * M_PI, (35.0 / 180.0) * M_PI);</a>
<a name="ln732">  cairo_new_sub_path(cr);</a>
<a name="ln733">  cairo_arc(cr, 0.2, 0.5, 0.6, -(35.0 / 180.0) * M_PI, (35.0 / 180.0) * M_PI);</a>
<a name="ln734">  cairo_new_sub_path(cr);</a>
<a name="ln735">  cairo_arc(cr, 0.2, 0.5, 0.75, -(35.0 / 180.0) * M_PI, (35.0 / 180.0) * M_PI);</a>
<a name="ln736"> </a>
<a name="ln737">  cairo_restore(cr);</a>
<a name="ln738">  cairo_stroke(cr);</a>
<a name="ln739">}</a>
<a name="ln740"> </a>
<a name="ln741">int32_t dt_view_get_image_to_act_on()</a>
<a name="ln742">{</a>
<a name="ln743">  // this works as follows:</a>
<a name="ln744">  // - if mouse hovers over an image, that's the one, except:</a>
<a name="ln745">  // - if images are selected and the mouse hovers over the selection,</a>
<a name="ln746">  //   in which case it affects the whole selection.</a>
<a name="ln747">  // - if the mouse is outside the center view (or no image hovered over otherwise)</a>
<a name="ln748">  //   it only affects the selection.</a>
<a name="ln749">  const int32_t mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln750"> </a>
<a name="ln751">  const int zoom = darktable.view_manager-&gt;proxy.lighttable.get_images_in_row(</a>
<a name="ln752">      darktable.view_manager-&gt;proxy.lighttable.view);</a>
<a name="ln753"> </a>
<a name="ln754">  const int full_preview_id = darktable.view_manager-&gt;proxy.lighttable.get_full_preview_id(</a>
<a name="ln755">      darktable.view_manager-&gt;proxy.lighttable.view);</a>
<a name="ln756"> </a>
<a name="ln757">  const int layout = darktable.view_manager-&gt;proxy.lighttable.get_layout(</a>
<a name="ln758">      darktable.view_manager-&gt;proxy.lighttable.module);</a>
<a name="ln759"> </a>
<a name="ln760">  if(zoom == 1 || full_preview_id &gt; 1 || layout == DT_LIGHTTABLE_LAYOUT_EXPOSE</a>
<a name="ln761">     || layout == DT_LIGHTTABLE_LAYOUT_CULLING)</a>
<a name="ln762">  {</a>
<a name="ln763">    return mouse_over_id;</a>
<a name="ln764">  }</a>
<a name="ln765">  else</a>
<a name="ln766">  {</a>
<a name="ln767">    /* clear and reset statement */</a>
<a name="ln768">    DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln769">    DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln770"> </a>
<a name="ln771">    /* setup statement and iterate over rows */</a>
<a name="ln772">    DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.is_selected, 1, mouse_over_id);</a>
<a name="ln773"> </a>
<a name="ln774">    if(mouse_over_id &lt;= 0 || sqlite3_step(darktable.view_manager-&gt;statements.is_selected) == SQLITE_ROW)</a>
<a name="ln775">      return -1;</a>
<a name="ln776">    else</a>
<a name="ln777">      return mouse_over_id;</a>
<a name="ln778">  }</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781">// Draw one of the controls that overlay thumbnails (e.g. stars) and check if the pointer is hovering it.</a>
<a name="ln782">// cr == NULL --&gt; only check for pointer hovering</a>
<a name="ln783">// active --&gt; non zero if the control can be activated by the mouse hovering it</a>
<a name="ln784">// return value non zero --&gt; mouse is hovering</a>
<a name="ln785"> </a>
<a name="ln786">int dt_view_process_image_over(dt_view_image_over_t what, int active, cairo_t *cr, const dt_image_t *img,</a>
<a name="ln787">                               int32_t width, int32_t height, int32_t zoom, int32_t px, int32_t py,</a>
<a name="ln788">                               dt_gui_color_t outlinecol, dt_gui_color_t fontcol)</a>
<a name="ln789">{</a>
<a name="ln790">  int ret = 0; // return value</a>
<a name="ln791"> </a>
<a name="ln792">  float fscale = DT_PIXEL_APPLY_DPI(fminf(width, height));</a>
<a name="ln793">  float r1, r2;</a>
<a name="ln794">  if(zoom != 1)</a>
<a name="ln795">  {</a>
<a name="ln796">    r1 = 0.05 * width;</a>
<a name="ln797">    r2 = 0.022 * width;</a>
<a name="ln798">  }</a>
<a name="ln799">  else</a>
<a name="ln800">  {</a>
<a name="ln801">    r1 = 0.015 * fscale;</a>
<a name="ln802">    r2 = 0.007 * fscale;</a>
<a name="ln803">  }</a>
<a name="ln804"> </a>
<a name="ln805">  if(cr)</a>
<a name="ln806">  {</a>
<a name="ln807">    cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1));</a>
<a name="ln808">    cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln809">  }</a>
<a name="ln810"> </a>
<a name="ln811">  gboolean extended_thumb_overlay = dt_conf_get_bool(&quot;plugins/lighttable/extended_thumb_overlay&quot;);</a>
<a name="ln812">  float x, y;</a>
<a name="ln813">  if(zoom != 1)</a>
<a name="ln814">    y = (extended_thumb_overlay ? 0.93 : 0.9) * height;</a>
<a name="ln815">  else</a>
<a name="ln816">    y = .12 * fscale;</a>
<a name="ln817"> </a>
<a name="ln818">  int rejected = img &amp;&amp; (img-&gt;flags &amp; 0x7) == 6;</a>
<a name="ln819"> </a>
<a name="ln820">  switch(what)</a>
<a name="ln821">  {</a>
<a name="ln822">    case DT_VIEW_STAR_1:</a>
<a name="ln823">    case DT_VIEW_STAR_2:</a>
<a name="ln824">    case DT_VIEW_STAR_3:</a>
<a name="ln825">    case DT_VIEW_STAR_4:</a>
<a name="ln826">    case DT_VIEW_STAR_5:</a>
<a name="ln827">      if(zoom != 1)</a>
<a name="ln828">        x = (0.26 + (what - DT_VIEW_STAR_1) * 0.12) * width;</a>
<a name="ln829">      else</a>
<a name="ln830">        x = (.08 + (what - DT_VIEW_STAR_1) * 0.04) * fscale;</a>
<a name="ln831"> </a>
<a name="ln832">      if(cr) dt_draw_star(cr, x, y, r1, r2);</a>
<a name="ln833"> </a>
<a name="ln834">      if(active &amp;&amp; (px - x) * (px - x) + (py - y) * (py - y) &lt; r1 * r1)</a>
<a name="ln835">      {</a>
<a name="ln836">        ret = 1;</a>
<a name="ln837">        if(cr) cairo_fill(cr);</a>
<a name="ln838">      }</a>
<a name="ln839">      else if(cr &amp;&amp; img &amp;&amp; (img-&gt;flags &amp; 0x7) &gt; what - DT_VIEW_STAR_1)</a>
<a name="ln840">      {</a>
<a name="ln841">        cairo_fill_preserve(cr);</a>
<a name="ln842">        dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_THUMBNAIL_SELECTED_BORDER);</a>
<a name="ln843">        cairo_stroke(cr);</a>
<a name="ln844">        dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln845">      }</a>
<a name="ln846">      else if(cr)</a>
<a name="ln847">        cairo_stroke(cr);</a>
<a name="ln848"> </a>
<a name="ln849">      break;</a>
<a name="ln850"> </a>
<a name="ln851">    case DT_VIEW_REJECT:</a>
<a name="ln852">      if(zoom != 1)</a>
<a name="ln853">        x = 0.08 * width;</a>
<a name="ln854">      else</a>
<a name="ln855">        x = .04 * fscale;</a>
<a name="ln856"> </a>
<a name="ln857">      if(cr &amp;&amp; rejected) cairo_set_source_rgb(cr, 1., 0., 0.);</a>
<a name="ln858"> </a>
<a name="ln859">      if(active &amp;&amp; (px - x) * (px - x) + (py - y) * (py - y) &lt; r1 * r1)</a>
<a name="ln860">      {</a>
<a name="ln861">        ret = 1;</a>
<a name="ln862">        if(cr)</a>
<a name="ln863">        {</a>
<a name="ln864">          cairo_new_sub_path(cr);</a>
<a name="ln865">          cairo_arc(cr, x, y, (r1 + r2) * .5, 0, 2.0f * M_PI);</a>
<a name="ln866">          cairo_stroke(cr);</a>
<a name="ln867">        }</a>
<a name="ln868">      }</a>
<a name="ln869"> </a>
<a name="ln870">      if(cr)</a>
<a name="ln871">      {</a>
<a name="ln872">        if(rejected) cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2));</a>
<a name="ln873"> </a>
<a name="ln874">        // reject cross:</a>
<a name="ln875">        cairo_move_to(cr, x - r2, y - r2);</a>
<a name="ln876">        cairo_line_to(cr, x + r2, y + r2);</a>
<a name="ln877">        cairo_move_to(cr, x + r2, y - r2);</a>
<a name="ln878">        cairo_line_to(cr, x - r2, y + r2);</a>
<a name="ln879">        cairo_close_path(cr);</a>
<a name="ln880">        cairo_stroke(cr);</a>
<a name="ln881">        dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln882">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1));</a>
<a name="ln883">      }</a>
<a name="ln884"> </a>
<a name="ln885">      break;</a>
<a name="ln886"> </a>
<a name="ln887">    case DT_VIEW_GROUP:</a>
<a name="ln888">    {</a>
<a name="ln889">      // draw grouping icon and border if the current group is expanded</a>
<a name="ln890">      // align to the right, left of altered</a>
<a name="ln891">      float s = (r1 + r2) * .5;</a>
<a name="ln892">      if(zoom != 1)</a>
<a name="ln893">      {</a>
<a name="ln894">        x = width * 0.9 - s * 2.5;</a>
<a name="ln895">        y = height * 0.1 - s * .4;</a>
<a name="ln896">      }</a>
<a name="ln897">      else</a>
<a name="ln898">      {</a>
<a name="ln899">        x = (.04 + 8 * 0.04 - 1.1 * .04) * fscale;</a>
<a name="ln900">        y = y - (.17 * .04) * fscale;</a>
<a name="ln901">      }</a>
<a name="ln902">      if(cr)</a>
<a name="ln903">      {</a>
<a name="ln904">        cairo_save(cr);</a>
<a name="ln905">        if(img &amp;&amp; (img-&gt;id != img-&gt;group_id)) dt_gui_gtk_set_source_rgb(cr, fontcol);</a>
<a name="ln906">        dtgtk_cairo_paint_grouping(cr, x, y, s, s, 23, NULL);</a>
<a name="ln907">        cairo_restore(cr);</a>
<a name="ln908">      }</a>
<a name="ln909"> </a>
<a name="ln910">      if(active &amp;&amp; fabs(px - x - .5 * s) &lt;= .8 * s &amp;&amp; fabs(py - y - .5 * s) &lt;= .8 * s) ret = 1;</a>
<a name="ln911"> </a>
<a name="ln912">      break;</a>
<a name="ln913">    }</a>
<a name="ln914"> </a>
<a name="ln915">    case DT_VIEW_AUDIO:</a>
<a name="ln916">    {</a>
<a name="ln917">      // align to right</a>
<a name="ln918">      float s = (r1 + r2) * .5;</a>
<a name="ln919">      if(zoom != 1)</a>
<a name="ln920">      {</a>
<a name="ln921">        x = width * 0.9 - s * 5;</a>
<a name="ln922">        y = height * 0.1;</a>
<a name="ln923">      }</a>
<a name="ln924">      else</a>
<a name="ln925">        x = (.04 + 8 * 0.04 - 1.9 * .04) * fscale;</a>
<a name="ln926">      if(cr) dt_view_draw_audio(cr, x, y, s);</a>
<a name="ln927">      // mouse is over the audio icon</a>
<a name="ln928">      if(active &amp;&amp; fabsf(px - x) &lt;= 1.2 * s &amp;&amp; fabsf(py - y) &lt;= 1.2 * s) ret = 1;</a>
<a name="ln929"> </a>
<a name="ln930">      break;</a>
<a name="ln931">    }</a>
<a name="ln932"> </a>
<a name="ln933">    case DT_VIEW_ALTERED:</a>
<a name="ln934">    {</a>
<a name="ln935">      // align to right</a>
<a name="ln936">      float s = (r1 + r2) * .5;</a>
<a name="ln937">      if(zoom != 1)</a>
<a name="ln938">      {</a>
<a name="ln939">        x = width * 0.9;</a>
<a name="ln940">        y = height * 0.1;</a>
<a name="ln941">      }</a>
<a name="ln942">      else</a>
<a name="ln943">        x = (.04 + 8 * 0.04) * fscale;</a>
<a name="ln944">      if(cr) dt_view_draw_altered(cr, x, y, s);</a>
<a name="ln945">      if(active &amp;&amp; fabsf(px - x) &lt;= 1.2 * s &amp;&amp; fabsf(py - y) &lt;= 1.2 * s) ret = 1;</a>
<a name="ln946"> </a>
<a name="ln947">      break;</a>
<a name="ln948">    }</a>
<a name="ln949"> </a>
<a name="ln950">    default: // if what == DT_VIEW_DESERT just return 0</a>
<a name="ln951">      return 0;</a>
<a name="ln952">  }</a>
<a name="ln953"> </a>
<a name="ln954">  return ret;</a>
<a name="ln955">}</a>
<a name="ln956"> </a>
<a name="ln957">dt_view_image_over_t dt_view_guess_image_over(int32_t width, int32_t height, int32_t zoom, int32_t px, int32_t py)</a>
<a name="ln958">{</a>
<a name="ln959">  // active if zoom&gt;1 or in the proper area</a>
<a name="ln960">  gboolean in_metadata_zone = (px &lt; width &amp;&amp; py &lt; height / 2) || (zoom &gt; 1);</a>
<a name="ln961"> </a>
<a name="ln962">  gboolean draw_metadata = darktable.gui-&gt;show_overlays || in_metadata_zone;</a>
<a name="ln963"> </a>
<a name="ln964">  if(draw_metadata &amp;&amp; width &gt; DECORATION_SIZE_LIMIT)</a>
<a name="ln965">  {</a>
<a name="ln966">    dt_view_image_over_t i;</a>
<a name="ln967">    for(i = DT_VIEW_ERR; i &lt; DT_VIEW_END; i++)</a>
<a name="ln968">      if(dt_view_process_image_over(i, 1, NULL, NULL, width, height, zoom, px, py, 0, 0)) return i;</a>
<a name="ln969">  }</a>
<a name="ln970"> </a>
<a name="ln971">  return DT_VIEW_DESERT;</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974">int dt_view_image_expose(dt_view_image_expose_t *vals)</a>
<a name="ln975">{</a>
<a name="ln976">  int missing = 0;</a>
<a name="ln977">  const double start = dt_get_wtime();</a>
<a name="ln978">// some performance tuning stuff, for your pleasure.</a>
<a name="ln979">// on my machine with 7 image per row it seems grouping has the largest</a>
<a name="ln980">// impact from around 400ms -&gt; 55ms per redraw.</a>
<a name="ln981"> </a>
<a name="ln982">  // this is a gui thread only thing. no mutex required:</a>
<a name="ln983">  const int imgsel = dt_control_get_mouse_over_id(); //  darktable.control-&gt;global_settings.lib_image_mouse_over_id;</a>
<a name="ln984"> </a>
<a name="ln985">  dt_view_image_over_t *image_over = vals-&gt;image_over;</a>
<a name="ln986">  uint32_t imgid = vals-&gt;imgid;</a>
<a name="ln987">  cairo_t *cr = vals-&gt;cr;</a>
<a name="ln988">  int32_t width = vals-&gt;width;</a>
<a name="ln989">  int32_t height = vals-&gt;height;</a>
<a name="ln990">  int32_t zoom = vals-&gt;zoom;</a>
<a name="ln991">  int32_t px = vals-&gt;px;</a>
<a name="ln992">  int32_t py = vals-&gt;py;</a>
<a name="ln993">  gboolean full_preview = vals-&gt;full_preview;</a>
<a name="ln994">  gboolean image_only = vals-&gt;image_only;</a>
<a name="ln995">  float full_zoom = vals-&gt;full_zoom;</a>
<a name="ln996">  float full_x = vals-&gt;full_x;</a>
<a name="ln997">  float full_y = vals-&gt;full_y;</a>
<a name="ln998"> </a>
<a name="ln999">  // active if zoom&gt;1 or in the proper area</a>
<a name="ln1000">  const gboolean in_metadata_zone = (px &lt; width &amp;&amp; py &lt; height / 2) || (zoom &gt; 1);</a>
<a name="ln1001"> </a>
<a name="ln1002">  const gboolean draw_thumb = TRUE;</a>
<a name="ln1003">  const gboolean draw_colorlabels = !image_only &amp;&amp; (darktable.gui-&gt;show_overlays || in_metadata_zone);</a>
<a name="ln1004">  const gboolean draw_local_copy = !image_only &amp;&amp; (darktable.gui-&gt;show_overlays || in_metadata_zone);</a>
<a name="ln1005">  const gboolean draw_grouping = !image_only;</a>
<a name="ln1006">  const gboolean draw_selected = !image_only;</a>
<a name="ln1007">  const gboolean draw_history = !image_only;</a>
<a name="ln1008">  const gboolean draw_metadata = !image_only &amp;&amp; (darktable.gui-&gt;show_overlays || in_metadata_zone);</a>
<a name="ln1009">  const gboolean draw_audio = !image_only;</a>
<a name="ln1010"> </a>
<a name="ln1011">  cairo_save(cr);</a>
<a name="ln1012">  dt_gui_color_t bgcol = DT_GUI_COLOR_THUMBNAIL_BG;</a>
<a name="ln1013">  dt_gui_color_t fontcol = DT_GUI_COLOR_THUMBNAIL_FONT;</a>
<a name="ln1014">  dt_gui_color_t outlinecol = DT_GUI_COLOR_THUMBNAIL_OUTLINE;</a>
<a name="ln1015"> </a>
<a name="ln1016">  int selected = 0, is_grouped = 0;</a>
<a name="ln1017"> </a>
<a name="ln1018">  if (draw_selected)</a>
<a name="ln1019">  {</a>
<a name="ln1020">    /* clear and reset statements */</a>
<a name="ln1021">    DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln1022">    DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln1023">    /* bind imgid to prepared statements */</a>
<a name="ln1024">    DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.is_selected, 1, imgid);</a>
<a name="ln1025">    /* lets check if imgid is selected */</a>
<a name="ln1026">    if(sqlite3_step(darktable.view_manager-&gt;statements.is_selected) == SQLITE_ROW) selected = 1;</a>
<a name="ln1027">  }</a>
<a name="ln1028"> </a>
<a name="ln1029">  dt_image_t buffered_image;</a>
<a name="ln1030">  const dt_image_t *img;</a>
<a name="ln1031">  // if darktable.gui-&gt;show_overlays is set or the user points at this image, we really want it:</a>
<a name="ln1032">  if(darktable.gui-&gt;show_overlays || imgsel == imgid || zoom == 1)</a>
<a name="ln1033">    img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1034">  else</a>
<a name="ln1035">    img = dt_image_cache_testget(darktable.image_cache, imgid, 'r');</a>
<a name="ln1036"> </a>
<a name="ln1037">  if(selected == 1 &amp;&amp; zoom != 1) // If zoom == 1 there is no need to set colors here</a>
<a name="ln1038">  {</a>
<a name="ln1039">    outlinecol = DT_GUI_COLOR_THUMBNAIL_SELECTED_OUTLINE;</a>
<a name="ln1040">    bgcol = DT_GUI_COLOR_THUMBNAIL_SELECTED_BG;</a>
<a name="ln1041">    fontcol = DT_GUI_COLOR_THUMBNAIL_SELECTED_FONT;</a>
<a name="ln1042">  }</a>
<a name="ln1043">  if(imgsel == imgid || zoom == 1)</a>
<a name="ln1044">  {</a>
<a name="ln1045">    // mouse over</a>
<a name="ln1046">    bgcol = DT_GUI_COLOR_THUMBNAIL_HOVER_BG;</a>
<a name="ln1047">    fontcol = DT_GUI_COLOR_THUMBNAIL_HOVER_FONT;</a>
<a name="ln1048">    outlinecol = DT_GUI_COLOR_THUMBNAIL_HOVER_OUTLINE;</a>
<a name="ln1049">  }</a>
<a name="ln1050">  // release image cache lock as early as possible, to avoid deadlocks (mipmap cache might need to lock it, too)</a>
<a name="ln1051">  if(img)</a>
<a name="ln1052">  {</a>
<a name="ln1053">    buffered_image = *img;</a>
<a name="ln1054">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln1055">    img = &amp;buffered_image;</a>
<a name="ln1056">  }</a>
<a name="ln1057"> </a>
<a name="ln1058">  gboolean draw_thumb_background = FALSE;</a>
<a name="ln1059">  float imgwd = 0.90f;</a>
<a name="ln1060">  if (image_only)</a>
<a name="ln1061">  {</a>
<a name="ln1062">    imgwd = 1.0;</a>
<a name="ln1063">  }</a>
<a name="ln1064">  else if(zoom == 1)</a>
<a name="ln1065">  {</a>
<a name="ln1066">    imgwd = .97f;</a>
<a name="ln1067">    // cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE);</a>
<a name="ln1068">  }</a>
<a name="ln1069">  else</a>
<a name="ln1070">  {</a>
<a name="ln1071">    draw_thumb_background = TRUE;</a>
<a name="ln1072">  }</a>
<a name="ln1073"> </a>
<a name="ln1074">  dt_mipmap_cache_t *cache = darktable.mipmap_cache;</a>
<a name="ln1075">  if(vals-&gt;full_surface_id &amp;&amp; vals-&gt;full_zoom100 &amp;&amp; *(vals-&gt;full_surface_id) != imgid)</a>
<a name="ln1076">    *(vals-&gt;full_zoom100) = 40.0f;</a>
<a name="ln1077">  float fz = 1.0f;</a>
<a name="ln1078">  if(full_zoom &gt; 0.0f) fz = full_zoom;</a>
<a name="ln1079">  if(vals-&gt;full_zoom100 &amp;&amp; *(vals-&gt;full_zoom100) &gt; 0.0f) fz = fminf(*(vals-&gt;full_zoom100), fz);</a>
<a name="ln1080">  dt_mipmap_size_t mip = dt_mipmap_cache_get_matching_size(cache, imgwd * width * fz, imgwd * height * fz);</a>
<a name="ln1081"> </a>
<a name="ln1082">  // if needed, we load the mimap buffer</a>
<a name="ln1083">  dt_mipmap_buffer_t buf;</a>
<a name="ln1084">  gboolean buf_sizeok = TRUE;</a>
<a name="ln1085">  gboolean buf_ok = TRUE;</a>
<a name="ln1086">  gboolean buf_mipmap = FALSE;</a>
<a name="ln1087">  int buf_wd = 0;</a>
<a name="ln1088">  int buf_ht = 0;</a>
<a name="ln1089">  if(vals-&gt;full_surface &amp;&amp; *(vals-&gt;full_surface) &amp;&amp; !*(vals-&gt;full_surface_w_lock)</a>
<a name="ln1090">     &amp;&amp; (*(vals-&gt;full_surface_id) != imgid || *(vals-&gt;full_surface_mip) != mip || !full_preview))</a>
<a name="ln1091">  {</a>
<a name="ln1092">    cairo_surface_destroy(*(vals-&gt;full_surface));</a>
<a name="ln1093">    if(vals-&gt;full_rgbbuf &amp;&amp; *(vals-&gt;full_rgbbuf))</a>
<a name="ln1094">    {</a>
<a name="ln1095">      free(*(vals-&gt;full_rgbbuf));</a>
<a name="ln1096">      *(vals-&gt;full_rgbbuf) = NULL;</a>
<a name="ln1097">    }</a>
<a name="ln1098">    *(vals-&gt;full_surface) = NULL;</a>
<a name="ln1099">  }</a>
<a name="ln1100">  if(!vals-&gt;full_surface || !*(vals-&gt;full_surface) || *(vals-&gt;full_surface_w_lock))</a>
<a name="ln1101">  {</a>
<a name="ln1102">    dt_mipmap_cache_get(cache, &amp;buf, imgid, mip, DT_MIPMAP_BEST_EFFORT, 'r');</a>
<a name="ln1103">    buf_wd = buf.width;</a>
<a name="ln1104">    buf_ht = buf.height;</a>
<a name="ln1105">    if(!buf.buf)</a>
<a name="ln1106">    {</a>
<a name="ln1107">      buf_ok = FALSE;</a>
<a name="ln1108">      buf_sizeok = FALSE;</a>
<a name="ln1109">    }</a>
<a name="ln1110">    if(mip != buf.size) buf_sizeok = FALSE;</a>
<a name="ln1111">    buf_mipmap = TRUE;</a>
<a name="ln1112">  }</a>
<a name="ln1113">  else</a>
<a name="ln1114">  {</a>
<a name="ln1115">    buf_wd = *(vals-&gt;full_surface_wd);</a>
<a name="ln1116">    buf_ht = *(vals-&gt;full_surface_ht);</a>
<a name="ln1117">  }</a>
<a name="ln1118">  // we want to sanitize full_zoom value to be sure not to exceed 100%</a>
<a name="ln1119">  if(fz &gt; 1.0f &amp;&amp; buf_sizeok)</a>
<a name="ln1120">  {</a>
<a name="ln1121">    // is the mipmap loaded the full one ?</a>
<a name="ln1122">    if(cache-&gt;max_width[mip] &gt; buf_wd + 4 &amp;&amp; cache-&gt;max_height[mip] &gt; buf_ht + 4)</a>
<a name="ln1123">    {</a>
<a name="ln1124">      float zoom_100 = fmaxf((float)buf_wd / ((float)width * imgwd), (float)buf_ht / ((float)height * imgwd));</a>
<a name="ln1125">      if(zoom_100 &lt; 1.0f) zoom_100 = 1.0f;</a>
<a name="ln1126">      if(vals-&gt;full_zoom100) *(vals-&gt;full_zoom100) = zoom_100;</a>
<a name="ln1127">      if(fz &gt; zoom_100)</a>
<a name="ln1128">      {</a>
<a name="ln1129">        fz = zoom_100;</a>
<a name="ln1130">      }</a>
<a name="ln1131">    }</a>
<a name="ln1132">  }</a>
<a name="ln1133"> </a>
<a name="ln1134">  if(draw_thumb_background)</a>
<a name="ln1135">  {</a>
<a name="ln1136">    double x0 = DT_PIXEL_APPLY_DPI(1), y0 = DT_PIXEL_APPLY_DPI(1), rect_width = width - DT_PIXEL_APPLY_DPI(2),</a>
<a name="ln1137">           rect_height = height - DT_PIXEL_APPLY_DPI(2), radius = DT_PIXEL_APPLY_DPI(5);</a>
<a name="ln1138">    double x1, y1, off, off1;</a>
<a name="ln1139"> </a>
<a name="ln1140">    x1 = x0 + rect_width;</a>
<a name="ln1141">    y1 = y0 + rect_height;</a>
<a name="ln1142">    off = radius * 0.666;</a>
<a name="ln1143">    off1 = radius - off;</a>
<a name="ln1144">    cairo_move_to(cr, x0, y0 + radius);</a>
<a name="ln1145">    cairo_curve_to(cr, x0, y0 + off1, x0 + off1, y0, x0 + radius, y0);</a>
<a name="ln1146">    cairo_line_to(cr, x1 - radius, y0);</a>
<a name="ln1147">    cairo_curve_to(cr, x1 - off1, y0, x1, y0 + off1, x1, y0 + radius);</a>
<a name="ln1148">    cairo_line_to(cr, x1, y1 - radius);</a>
<a name="ln1149">    cairo_curve_to(cr, x1, y1 - off1, x1 - off1, y1, x1 - radius, y1);</a>
<a name="ln1150">    cairo_line_to(cr, x0 + radius, y1);</a>
<a name="ln1151">    cairo_curve_to(cr, x0 + off1, y1, x0, y1 - off1, x0, y1 - radius);</a>
<a name="ln1152">    cairo_close_path(cr);</a>
<a name="ln1153">    dt_gui_gtk_set_source_rgb(cr, bgcol);</a>
<a name="ln1154">    cairo_fill_preserve(cr);</a>
<a name="ln1155">    cairo_set_line_width(cr, 0.005 * width);</a>
<a name="ln1156">    dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln1157">    cairo_stroke(cr);</a>
<a name="ln1158"> </a>
<a name="ln1159">    if(img)</a>
<a name="ln1160">    {</a>
<a name="ln1161">      PangoLayout *layout;</a>
<a name="ln1162">      PangoRectangle ink;</a>
<a name="ln1163">      PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln1164">      pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln1165">      const int fontsize = 0.20 * width;</a>
<a name="ln1166">      pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);</a>
<a name="ln1167">      layout = pango_cairo_create_layout(cr);</a>
<a name="ln1168">      pango_layout_set_font_description(layout, desc);</a>
<a name="ln1169">      const char *ext = img-&gt;filename + strlen(img-&gt;filename);</a>
<a name="ln1170">      while(ext &gt; img-&gt;filename &amp;&amp; *ext != '.') ext--;</a>
<a name="ln1171">      ext++;</a>
<a name="ln1172">      dt_gui_gtk_set_source_rgb(cr, fontcol);</a>
<a name="ln1173"> </a>
<a name="ln1174">      char* upcase_ext = g_ascii_strup(ext, -1);  // extension in capital letters to avoid character descenders</a>
<a name="ln1175"> </a>
<a name="ln1176">      if(buf_ht &gt; buf_wd)</a>
<a name="ln1177">      {</a>
<a name="ln1178">        int max_chr_width = 0;</a>
<a name="ln1179">        for (int i = 0; upcase_ext[i] != 0; i++)</a>
<a name="ln1180">        {</a>
<a name="ln1181">          pango_layout_set_text(layout, &amp;upcase_ext[i], 1);</a>
<a name="ln1182">          pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln1183">          max_chr_width = MAX(max_chr_width, ink.width);</a>
<a name="ln1184">        }</a>
<a name="ln1185"> </a>
<a name="ln1186">        for (int i = 0, yoffs = fontsize;  upcase_ext[i] != 0; i++,  yoffs -= fontsize)</a>
<a name="ln1187">        {</a>
<a name="ln1188">          pango_layout_set_text(layout, &amp;upcase_ext[i], 1);</a>
<a name="ln1189">          pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln1190">          cairo_move_to(cr, .025 * width - ink.x + (max_chr_width - ink.width) / 2, .2 * height - yoffs);</a>
<a name="ln1191">          pango_cairo_show_layout(cr, layout);</a>
<a name="ln1192">        }</a>
<a name="ln1193">      }</a>
<a name="ln1194">      else</a>
<a name="ln1195">      {</a>
<a name="ln1196">        pango_layout_set_text(layout, upcase_ext, -1);</a>
<a name="ln1197">        pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln1198">        cairo_move_to(cr, .025 * width - ink.x, .2 * height - fontsize);</a>
<a name="ln1199">        pango_cairo_show_layout(cr, layout);</a>
<a name="ln1200">      }</a>
<a name="ln1201">      g_free(upcase_ext);</a>
<a name="ln1202">      pango_font_description_free(desc);</a>
<a name="ln1203">      g_object_unref(layout);</a>
<a name="ln1204"> </a>
<a name="ln1205">    }</a>
<a name="ln1206">  }</a>
<a name="ln1207"> </a>
<a name="ln1208">  // if we got a different mip than requested, and it's not a skull (8x8 px), we count</a>
<a name="ln1209">  // this thumbnail as missing (to trigger re-exposure)</a>
<a name="ln1210">  if(!buf_sizeok &amp;&amp; buf_wd != 8 &amp;&amp; buf_ht != 8) missing = 1;</a>
<a name="ln1211"> </a>
<a name="ln1212">  if (draw_thumb)</a>
<a name="ln1213">  {</a>
<a name="ln1214">    float scale = 1.0;</a>
<a name="ln1215">    cairo_surface_t *surface = NULL;</a>
<a name="ln1216">    uint8_t *rgbbuf = NULL;</a>
<a name="ln1217"> </a>
<a name="ln1218">    if(vals-&gt;full_surface &amp;&amp; *(vals-&gt;full_surface) &amp;&amp; !*(vals-&gt;full_surface_w_lock))</a>
<a name="ln1219">    {</a>
<a name="ln1220">      surface = *(vals-&gt;full_surface);</a>
<a name="ln1221">      rgbbuf = *(vals-&gt;full_rgbbuf);</a>
<a name="ln1222">    }</a>
<a name="ln1223">    else</a>
<a name="ln1224">    {</a>
<a name="ln1225">      if(buf_ok)</a>
<a name="ln1226">      {</a>
<a name="ln1227">        rgbbuf = (uint8_t *)calloc(buf_wd * buf_ht * 4, sizeof(uint8_t));</a>
<a name="ln1228">        if(rgbbuf)</a>
<a name="ln1229">        {</a>
<a name="ln1230">          gboolean have_lock = FALSE;</a>
<a name="ln1231">          cmsHTRANSFORM transform = NULL;</a>
<a name="ln1232"> </a>
<a name="ln1233">          if(dt_conf_get_bool(&quot;cache_color_managed&quot;))</a>
<a name="ln1234">          {</a>
<a name="ln1235">            pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1236">            have_lock = TRUE;</a>
<a name="ln1237"> </a>
<a name="ln1238">            // we only color manage when a thumbnail is sRGB or AdobeRGB. everything else just gets dumped to the</a>
<a name="ln1239">            // screen</a>
<a name="ln1240">            if(buf.color_space == DT_COLORSPACE_SRGB &amp;&amp; darktable.color_profiles-&gt;transform_srgb_to_display)</a>
<a name="ln1241">            {</a>
<a name="ln1242">              transform = darktable.color_profiles-&gt;transform_srgb_to_display;</a>
<a name="ln1243">            }</a>
<a name="ln1244">            else if(buf.color_space == DT_COLORSPACE_ADOBERGB</a>
<a name="ln1245">                    &amp;&amp; darktable.color_profiles-&gt;transform_adobe_rgb_to_display)</a>
<a name="ln1246">            {</a>
<a name="ln1247">              transform = darktable.color_profiles-&gt;transform_adobe_rgb_to_display;</a>
<a name="ln1248">            }</a>
<a name="ln1249">            else</a>
<a name="ln1250">            {</a>
<a name="ln1251">              pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1252">              have_lock = FALSE;</a>
<a name="ln1253">              if(buf.color_space == DT_COLORSPACE_NONE)</a>
<a name="ln1254">              {</a>
<a name="ln1255">                fprintf(stderr,</a>
<a name="ln1256">                        &quot;oops, there seems to be a code path not setting the color space of thumbnails!\n&quot;);</a>
<a name="ln1257">              }</a>
<a name="ln1258">              else if(buf.color_space != DT_COLORSPACE_DISPLAY &amp;&amp; buf.color_space != DT_COLORSPACE_DISPLAY2)</a>
<a name="ln1259">              {</a>
<a name="ln1260">                fprintf(</a>
<a name="ln1261">                    stderr,</a>
<a name="ln1262">                    &quot;oops, there seems to be a code path setting an unhandled color space of thumbnails (%s)!\n&quot;,</a>
<a name="ln1263">                    dt_colorspaces_get_name(buf.color_space, &quot;from file&quot;));</a>
<a name="ln1264">              }</a>
<a name="ln1265">            }</a>
<a name="ln1266">          }</a>
<a name="ln1267"> </a>
<a name="ln1268">#ifdef _OPENMP</a>
<a name="ln1269">  #pragma omp parallel for schedule(static) default(none) shared(buf, rgbbuf, transform)</a>
<a name="ln1270">#endif</a>
<a name="ln1271">          for(int i = 0; i &lt; buf.height; i++)</a>
<a name="ln1272">          {</a>
<a name="ln1273">            const uint8_t *in = buf.buf + i * buf.width * 4;</a>
<a name="ln1274">            uint8_t *out = rgbbuf + i * buf.width * 4;</a>
<a name="ln1275"> </a>
<a name="ln1276">            if(transform)</a>
<a name="ln1277">            {</a>
<a name="ln1278">              cmsDoTransform(transform, in, out, buf.width);</a>
<a name="ln1279">            }</a>
<a name="ln1280">            else</a>
<a name="ln1281">            {</a>
<a name="ln1282">              for(int j = 0; j &lt; buf.width; j++, in += 4, out += 4)</a>
<a name="ln1283">              {</a>
<a name="ln1284">                out[0] = in[2];</a>
<a name="ln1285">                out[1] = in[1];</a>
<a name="ln1286">                out[2] = in[0];</a>
<a name="ln1287">              }</a>
<a name="ln1288">            }</a>
<a name="ln1289">          }</a>
<a name="ln1290">          if(have_lock) pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1291"> </a>
<a name="ln1292">          const int32_t stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, buf_wd);</a>
<a name="ln1293">          surface = cairo_image_surface_create_for_data(rgbbuf, CAIRO_FORMAT_RGB24, buf_wd, buf_ht, stride);</a>
<a name="ln1294"> </a>
<a name="ln1295">          // we save the surface for later use</a>
<a name="ln1296">          if(!missing &amp;&amp; vals-&gt;full_surface &amp;&amp; !*(vals-&gt;full_surface_w_lock))</a>
<a name="ln1297">          {</a>
<a name="ln1298">            *(vals-&gt;full_surface_w_lock) = 1;</a>
<a name="ln1299">            *(vals-&gt;full_surface) = surface;</a>
<a name="ln1300">            *(vals-&gt;full_rgbbuf) = rgbbuf;</a>
<a name="ln1301">            *(vals-&gt;full_surface_ht) = buf_ht;</a>
<a name="ln1302">            *(vals-&gt;full_surface_wd) = buf_wd;</a>
<a name="ln1303">            *(vals-&gt;full_surface_mip) = mip;</a>
<a name="ln1304">            *(vals-&gt;full_surface_id) = imgid;</a>
<a name="ln1305">            *(vals-&gt;full_surface_w_lock) = 0;</a>
<a name="ln1306">          }</a>
<a name="ln1307">        }</a>
<a name="ln1308">      }</a>
<a name="ln1309">    }</a>
<a name="ln1310"> </a>
<a name="ln1311">    if(surface)</a>
<a name="ln1312">    {</a>
<a name="ln1313">      if(zoom == 1 &amp;&amp; !image_only)</a>
<a name="ln1314">      {</a>
<a name="ln1315">        const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln1316">        scale = fminf((width - 2 * tb) / (float)buf_wd, (height - 2 * tb) / (float)buf_ht) * fz;</a>
<a name="ln1317">      }</a>
<a name="ln1318">      else</a>
<a name="ln1319">        scale = fminf(width * imgwd / (float)buf_wd, height * imgwd / (float)buf_ht) * fz;</a>
<a name="ln1320">    }</a>
<a name="ln1321">    // draw centered and fitted:</a>
<a name="ln1322">    cairo_save(cr);</a>
<a name="ln1323"> </a>
<a name="ln1324">    if (image_only) // in this case we want to display the picture exactly at (px, py)</a>
<a name="ln1325">      cairo_translate(cr, px, py);</a>
<a name="ln1326">    else</a>
<a name="ln1327">      cairo_translate(cr, width / 2.0, height / 2.0);</a>
<a name="ln1328"> </a>
<a name="ln1329">    cairo_scale(cr, scale, scale);</a>
<a name="ln1330"> </a>
<a name="ln1331">    float rectw = width;</a>
<a name="ln1332">    float recth = height;</a>
<a name="ln1333">    float rectx = 0.0f;</a>
<a name="ln1334">    float recty = 0.0f;</a>
<a name="ln1335">    if(buf_ok)</a>
<a name="ln1336">    {</a>
<a name="ln1337">      rectw = buf_wd;</a>
<a name="ln1338">      recth = buf_ht;</a>
<a name="ln1339">    }</a>
<a name="ln1340"> </a>
<a name="ln1341">    if(surface)</a>
<a name="ln1342">    {</a>
<a name="ln1343">      // we move the full preview</a>
<a name="ln1344">      float fx = 0.0f;</a>
<a name="ln1345">      float fy = 0.0f;</a>
<a name="ln1346">      if(fz &gt; 1.0f)</a>
<a name="ln1347">      {</a>
<a name="ln1348">        int w = width;</a>
<a name="ln1349">        int h = height;</a>
<a name="ln1350">        if(zoom == 1 &amp;&amp; !image_only)</a>
<a name="ln1351">        {</a>
<a name="ln1352">          const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln1353">          w -= 2 * tb;</a>
<a name="ln1354">          h -= 2 * tb;</a>
<a name="ln1355">        }</a>
<a name="ln1356">        // we want to be sure the image stay in the window</a>
<a name="ln1357">        if(buf_sizeok &amp;&amp; vals-&gt;full_maxdx &amp;&amp; vals-&gt;full_maxdy)</a>
<a name="ln1358">        {</a>
<a name="ln1359">          *(vals-&gt;full_maxdx) = fmaxf(0.0f, (buf_wd * scale - w) / 2);</a>
<a name="ln1360">          *(vals-&gt;full_maxdy) = fmaxf(0.0f, (buf_ht * scale - h) / 2);</a>
<a name="ln1361">        }</a>
<a name="ln1362">        fx = fminf((buf_wd * scale - w) / 2, fabsf(full_x));</a>
<a name="ln1363">        if(full_x &lt; 0) fx = -fx;</a>
<a name="ln1364">        if(buf_wd * scale &lt;= w) fx = 0;</a>
<a name="ln1365">        fy = fminf((buf_ht * scale - h) / 2, fabsf(full_y));</a>
<a name="ln1366">        if(full_y &lt; 0) fy = -fy;</a>
<a name="ln1367">        if(buf_ht * scale &lt;= h) fy = 0;</a>
<a name="ln1368"> </a>
<a name="ln1369">        // and we determine the rectangle where the image is display</a>
<a name="ln1370">        rectw = fminf(w / scale, rectw);</a>
<a name="ln1371">        recth = fminf(h / scale, recth);</a>
<a name="ln1372">        rectx = 0.5 * buf_wd - fx / scale - 0.5 * rectw;</a>
<a name="ln1373">        recty = 0.5 * buf_ht - fy / scale - 0.5 * recth;</a>
<a name="ln1374">      }</a>
<a name="ln1375"> </a>
<a name="ln1376">      if(buf_ok &amp;&amp; fz == 1.0f &amp;&amp; vals-&gt;full_w1 &amp;&amp; vals-&gt;full_h1)</a>
<a name="ln1377">      {</a>
<a name="ln1378">        *(vals-&gt;full_w1) = buf_wd * scale;</a>
<a name="ln1379">        *(vals-&gt;full_h1) = buf_ht * scale;</a>
<a name="ln1380">      }</a>
<a name="ln1381"> </a>
<a name="ln1382">      if(!image_only) cairo_translate(cr, -0.5 * buf_wd + fx / scale, -0.5 * buf_ht + fy / scale);</a>
<a name="ln1383">      cairo_set_source_surface(cr, surface, 0, 0);</a>
<a name="ln1384">      // set filter no nearest:</a>
<a name="ln1385">      // in skull mode, we want to see big pixels.</a>
<a name="ln1386">      // in 1 iir mode for the right mip, we want to see exactly what the pipe gave us, 1:1 pixel for pixel.</a>
<a name="ln1387">      // in between, filtering just makes stuff go unsharp.</a>
<a name="ln1388">      if((buf_wd &lt;= 8 &amp;&amp; buf_ht &lt;= 8) || fabsf(scale - 1.0f) &lt; 0.01f)</a>
<a name="ln1389">        cairo_pattern_set_filter(cairo_get_source(cr), CAIRO_FILTER_NEAREST);</a>
<a name="ln1390"> </a>
<a name="ln1391">      cairo_rectangle(cr, rectx, recty, rectw, recth);</a>
<a name="ln1392"> </a>
<a name="ln1393">      cairo_fill(cr);</a>
<a name="ln1394">      if(!vals-&gt;full_surface || !*(vals-&gt;full_surface)) cairo_surface_destroy(surface);</a>
<a name="ln1395"> </a>
<a name="ln1396">      cairo_rectangle(cr, rectx, recty, rectw, recth);</a>
<a name="ln1397">    }</a>
<a name="ln1398"> </a>
<a name="ln1399">    if(!vals-&gt;full_rgbbuf || !*(vals-&gt;full_rgbbuf)) free(rgbbuf);</a>
<a name="ln1400"> </a>
<a name="ln1401">    if (image_only)</a>
<a name="ln1402">    {</a>
<a name="ln1403">      cairo_restore(cr);</a>
<a name="ln1404">      cairo_save(cr);</a>
<a name="ln1405">      cairo_new_path(cr);</a>
<a name="ln1406">    }</a>
<a name="ln1407">    else</a>
<a name="ln1408">    {</a>
<a name="ln1409">      // border around image</a>
<a name="ln1410">      dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_THUMBNAIL_BORDER);</a>
<a name="ln1411">      if(buf_ok &amp;&amp; (selected || zoom == 1))</a>
<a name="ln1412">      {</a>
<a name="ln1413">        const float border = zoom == 1 ? DT_PIXEL_APPLY_DPI(16 / scale) : DT_PIXEL_APPLY_DPI(2 / scale);</a>
<a name="ln1414">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1. / scale));</a>
<a name="ln1415">        if(zoom == 1)</a>
<a name="ln1416">        {</a>
<a name="ln1417">          cairo_stroke(cr);</a>
<a name="ln1418">          cairo_set_fill_rule(cr, CAIRO_FILL_RULE_EVEN_ODD);</a>
<a name="ln1419">          float alpha = 1.0f;</a>
<a name="ln1420">          for(int k = 0; k &lt; 16; k++)</a>
<a name="ln1421">          {</a>
<a name="ln1422">            cairo_rectangle(cr, rectx, recty, rectw, recth);</a>
<a name="ln1423">            cairo_new_sub_path(cr);</a>
<a name="ln1424">            cairo_rectangle(cr, rectx - k / scale, recty - k / scale, rectw + 2. * k / scale,</a>
<a name="ln1425">                            recth + 2. * k / scale);</a>
<a name="ln1426">            cairo_set_source_rgba(cr, 0, 0, 0, alpha);</a>
<a name="ln1427">            alpha *= 0.6f;</a>
<a name="ln1428">            cairo_fill(cr);</a>
<a name="ln1429">          }</a>
<a name="ln1430">        }</a>
<a name="ln1431">        else</a>
<a name="ln1432">        {</a>
<a name="ln1433">          cairo_set_fill_rule(cr, CAIRO_FILL_RULE_EVEN_ODD);</a>
<a name="ln1434">          cairo_new_sub_path(cr);</a>
<a name="ln1435">          cairo_rectangle(cr, rectx - border, recty - border, rectw + 2. * border, recth + 2. * border);</a>
<a name="ln1436">          cairo_stroke_preserve(cr);</a>
<a name="ln1437">          dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_THUMBNAIL_SELECTED_BORDER);</a>
<a name="ln1438">          cairo_fill(cr);</a>
<a name="ln1439">        }</a>
<a name="ln1440">      }</a>
<a name="ln1441">      else if(buf_ok)</a>
<a name="ln1442">      {</a>
<a name="ln1443">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(0.5 / scale));</a>
<a name="ln1444">        cairo_stroke(cr);</a>
<a name="ln1445">      }</a>
<a name="ln1446">    }</a>
<a name="ln1447">  }</a>
<a name="ln1448">  cairo_restore(cr);</a>
<a name="ln1449"> </a>
<a name="ln1450">  if(buf_mipmap) dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln1451">  if(buf_mipmap &amp;&amp; !missing &amp;&amp; vals-&gt;full_surface &amp;&amp; !*(vals-&gt;full_surface_w_lock))</a>
<a name="ln1452">  {</a>
<a name="ln1453">    // we don't need this in the cache anymore, as we already have it in memory for zoom&amp;pan</a>
<a name="ln1454">    // let's drop it to free space. This reduce the risk of getting out of space...</a>
<a name="ln1455">    dt_mipmap_cache_remove_at_size(cache, imgid, mip);</a>
<a name="ln1456">  }</a>
<a name="ln1457"> </a>
<a name="ln1458">  cairo_save(cr);</a>
<a name="ln1459"> </a>
<a name="ln1460">  const float fscale = DT_PIXEL_APPLY_DPI(fminf(width, height));</a>
<a name="ln1461">  if(imgsel == imgid || full_preview || darktable.gui-&gt;show_overlays || zoom == 1)</a>
<a name="ln1462">  {</a>
<a name="ln1463">    if(draw_metadata &amp;&amp; width &gt; DECORATION_SIZE_LIMIT)</a>
<a name="ln1464">    {</a>
<a name="ln1465">      // draw mouseover hover effects, set event hook for mouse button down!</a>
<a name="ln1466">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1));</a>
<a name="ln1467">      dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln1468">      cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);</a>
<a name="ln1469"> </a>
<a name="ln1470">      const gboolean extended_thumb_overlay = dt_conf_get_bool(&quot;plugins/lighttable/extended_thumb_overlay&quot;);</a>
<a name="ln1471">      const gboolean image_is_rejected = (img &amp;&amp; ((img-&gt;flags &amp; 0x7) == 6));</a>
<a name="ln1472"> </a>
<a name="ln1473">      if(img)</a>
<a name="ln1474">      {</a>
<a name="ln1475">        if (zoom != 1 &amp;&amp; (!darktable.gui-&gt;show_overlays || imgsel == imgid) &amp;&amp; extended_thumb_overlay)</a>
<a name="ln1476">        {</a>
<a name="ln1477">          const double overlay_height = 0.26 * height;</a>
<a name="ln1478">          const int exif_offset = DT_PIXEL_APPLY_DPI(3);</a>
<a name="ln1479">          const int fontsize = 0.18 * overlay_height;</a>
<a name="ln1480">          const double line_offs = 1.15 * fontsize;</a>
<a name="ln1481"> </a>
<a name="ln1482"> </a>
<a name="ln1483">          double x0 = DT_PIXEL_APPLY_DPI(1);</a>
<a name="ln1484">          double y0 = height - overlay_height;</a>
<a name="ln1485">          double rect_width = width - DT_PIXEL_APPLY_DPI(2);</a>
<a name="ln1486">          double rect_height = overlay_height - DT_PIXEL_APPLY_DPI(2);</a>
<a name="ln1487">          double radius = DT_PIXEL_APPLY_DPI(5);</a>
<a name="ln1488">          double x1, y1, off, off1;</a>
<a name="ln1489"> </a>
<a name="ln1490">          x1 = x0 + rect_width;</a>
<a name="ln1491">          y1 = y0 + rect_height;</a>
<a name="ln1492">          off = radius * 0.666;</a>
<a name="ln1493">          off1 = radius - off;</a>
<a name="ln1494">          cairo_save(cr);</a>
<a name="ln1495">          cairo_move_to(cr, x0, y0 + radius);</a>
<a name="ln1496">          cairo_curve_to(cr, x0, y0 + off1, x0 + off1, y0, x0 + radius, y0);</a>
<a name="ln1497">          cairo_line_to(cr, x1 - radius, y0);</a>
<a name="ln1498">          cairo_curve_to(cr, x1 - off1, y0, x1, y0 + off1, x1, y0 + radius);</a>
<a name="ln1499">          cairo_line_to(cr, x1, y1 - radius);</a>
<a name="ln1500">          cairo_curve_to(cr, x1, y1 - off1, x1 - off1, y1, x1 - radius, y1);</a>
<a name="ln1501">          cairo_line_to(cr, x0 + radius, y1);</a>
<a name="ln1502">          cairo_curve_to(cr, x0 + off1, y1, x0, y1 - off1, x0, y1 - radius);</a>
<a name="ln1503">          cairo_close_path(cr);</a>
<a name="ln1504">          dt_gui_gtk_set_source_rgb(cr, bgcol);</a>
<a name="ln1505">          cairo_fill_preserve(cr);</a>
<a name="ln1506">          cairo_set_line_width(cr, 0.005 * width);</a>
<a name="ln1507">          dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln1508">          cairo_stroke(cr);</a>
<a name="ln1509"> </a>
<a name="ln1510">          // some exif data</a>
<a name="ln1511">          PangoLayout *layout;</a>
<a name="ln1512">          PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln1513">          pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln1514">          layout = pango_cairo_create_layout(cr);</a>
<a name="ln1515">          pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);</a>
<a name="ln1516">          pango_layout_set_font_description(layout, desc);</a>
<a name="ln1517">          dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln1518"> </a>
<a name="ln1519">          cairo_move_to(cr, x0 + exif_offset, y0 + exif_offset);</a>
<a name="ln1520">          pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_MIDDLE);</a>
<a name="ln1521">          pango_layout_set_width(layout, (int)(PANGO_SCALE * (width - 2 * exif_offset)));</a>
<a name="ln1522">          pango_layout_set_text(layout, img-&gt;filename, -1);</a>
<a name="ln1523">          pango_cairo_show_layout(cr, layout);</a>
<a name="ln1524">          char exifline[50];</a>
<a name="ln1525">          cairo_move_to(cr, x0 + exif_offset, y0 + exif_offset + line_offs);</a>
<a name="ln1526">          dt_image_print_exif(img, exifline, sizeof(exifline));</a>
<a name="ln1527">          pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_END);</a>
<a name="ln1528">          pango_layout_set_text(layout, exifline, -1);</a>
<a name="ln1529">          pango_cairo_show_layout(cr, layout);</a>
<a name="ln1530"> </a>
<a name="ln1531">          pango_font_description_free(desc);</a>
<a name="ln1532">          g_object_unref(layout);</a>
<a name="ln1533">          cairo_restore(cr);</a>
<a name="ln1534">        }</a>
<a name="ln1535"> </a>
<a name="ln1536">        if(!image_is_rejected) // if rejected: draw no stars</a>
<a name="ln1537">        {</a>
<a name="ln1538">          for(int k = 0; k &lt; 5; k++)</a>
<a name="ln1539">          {</a>
<a name="ln1540">            dt_view_image_over_t star = DT_VIEW_STAR_1 + k;</a>
<a name="ln1541">            if(dt_view_process_image_over(star, imgsel == imgid || zoom == 1, cr, img,</a>
<a name="ln1542">                                          width, height, zoom, px, py, outlinecol, fontcol))</a>
<a name="ln1543">              *image_over = star;</a>
<a name="ln1544">          }</a>
<a name="ln1545">        }</a>
<a name="ln1546">      }</a>
<a name="ln1547"> </a>
<a name="ln1548">      if(dt_view_process_image_over(DT_VIEW_REJECT, imgsel == imgid || zoom == 1, cr, img,</a>
<a name="ln1549">                                    width, height, zoom, px, py, outlinecol, fontcol))</a>
<a name="ln1550">        *image_over = DT_VIEW_REJECT;</a>
<a name="ln1551"> </a>
<a name="ln1552">      if(draw_audio &amp;&amp; img &amp;&amp; (img-&gt;flags &amp; DT_IMAGE_HAS_WAV))</a>
<a name="ln1553">      {</a>
<a name="ln1554">        if(dt_view_process_image_over(DT_VIEW_AUDIO, imgsel == imgid || zoom == 1, cr, img,</a>
<a name="ln1555">                                      width, height, zoom, px, py, outlinecol, fontcol))</a>
<a name="ln1556">          *image_over = DT_VIEW_AUDIO;</a>
<a name="ln1557">      }</a>
<a name="ln1558"> </a>
<a name="ln1559">      if(draw_grouping)</a>
<a name="ln1560">      {</a>
<a name="ln1561">        DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.get_grouped);</a>
<a name="ln1562">        DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.get_grouped);</a>
<a name="ln1563">        DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.get_grouped, 1, imgid);</a>
<a name="ln1564">        DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.get_grouped, 2, imgid);</a>
<a name="ln1565"> </a>
<a name="ln1566">        /* lets check if imgid is in a group */</a>
<a name="ln1567">        if(sqlite3_step(darktable.view_manager-&gt;statements.get_grouped) == SQLITE_ROW)</a>
<a name="ln1568">          is_grouped = 1;</a>
<a name="ln1569">        else if(img &amp;&amp; darktable.gui-&gt;expanded_group_id == img-&gt;group_id)</a>
<a name="ln1570">          darktable.gui-&gt;expanded_group_id = -1;</a>
<a name="ln1571">      }</a>
<a name="ln1572"> </a>
<a name="ln1573">      // image part of a group?</a>
<a name="ln1574">      if(is_grouped &amp;&amp; darktable.gui &amp;&amp; darktable.gui-&gt;grouping)</a>
<a name="ln1575">      {</a>
<a name="ln1576">        if(dt_view_process_image_over(DT_VIEW_GROUP, img != NULL, cr, img,</a>
<a name="ln1577">                                      width, height, zoom, px, py, outlinecol, fontcol))</a>
<a name="ln1578">          *image_over = DT_VIEW_GROUP;</a>
<a name="ln1579">      }</a>
<a name="ln1580"> </a>
<a name="ln1581">      // image altered?</a>
<a name="ln1582">      if(draw_history &amp;&amp; dt_image_altered(imgid))</a>
<a name="ln1583">      {</a>
<a name="ln1584">        if(dt_view_process_image_over(DT_VIEW_ALTERED, img != NULL, cr, img,</a>
<a name="ln1585">                                      width, height, zoom, px, py, outlinecol, fontcol))</a>
<a name="ln1586">          darktable.gui-&gt;center_tooltip = 1;</a>
<a name="ln1587">      }</a>
<a name="ln1588">    }</a>
<a name="ln1589">  }</a>
<a name="ln1590">  cairo_restore(cr);</a>
<a name="ln1591"> </a>
<a name="ln1592">  // kill all paths, in case img was not loaded yet, or is blocked:</a>
<a name="ln1593">  cairo_new_path(cr);</a>
<a name="ln1594"> </a>
<a name="ln1595">  if (draw_colorlabels &amp;&amp; (darktable.gui-&gt;show_overlays || imgsel == imgid || full_preview || zoom == 1))</a>
<a name="ln1596">  {</a>
<a name="ln1597">    // TODO: cache in image struct!</a>
<a name="ln1598"> </a>
<a name="ln1599">    // TODO: there is a branch that sets the bg == colorlabel</a>
<a name="ln1600">    //       this might help if zoom &gt; 15</a>
<a name="ln1601">    if(width &gt; DECORATION_SIZE_LIMIT)</a>
<a name="ln1602">    {</a>
<a name="ln1603">      // color labels:</a>
<a name="ln1604">      const float x[] = {0.84, 0.92, 0.88, 0.84, 0.92};</a>
<a name="ln1605">      const float y[] = {0.84, 0.84, 0.88, 0.92, 0.92};</a>
<a name="ln1606">      const float x_zoom[] = {0.27, 0.30, 0.285, 0.27, 0.30};</a>
<a name="ln1607">      const float y_zoom[] = {0.095, 0.095, 0.11, 0.125, 0.125};</a>
<a name="ln1608">      const int max_col = sizeof(x) / sizeof(x[0]);</a>
<a name="ln1609">      const float r = zoom == 1 ? 0.01 * fscale : 0.03 * width;</a>
<a name="ln1610"> </a>
<a name="ln1611">      gboolean colorlabel_painted = FALSE;</a>
<a name="ln1612">      gboolean painted_col[] = {FALSE, FALSE, FALSE, FALSE, FALSE};</a>
<a name="ln1613"> </a>
<a name="ln1614">      /* clear and reset prepared statement */</a>
<a name="ln1615">      DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.get_color);</a>
<a name="ln1616">      DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.get_color);</a>
<a name="ln1617"> </a>
<a name="ln1618">      /* setup statement and iterate rows */</a>
<a name="ln1619">      DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.get_color, 1, imgid);</a>
<a name="ln1620">      while(sqlite3_step(darktable.view_manager-&gt;statements.get_color) == SQLITE_ROW)</a>
<a name="ln1621">      {</a>
<a name="ln1622">        cairo_save(cr);</a>
<a name="ln1623">        const int col = sqlite3_column_int(darktable.view_manager-&gt;statements.get_color, 0);</a>
<a name="ln1624">        if (col &lt; max_col)</a>
<a name="ln1625">        {</a>
<a name="ln1626">          // see src/dtgtk/paint.c</a>
<a name="ln1627">          if (zoom != 1)</a>
<a name="ln1628">            dtgtk_cairo_paint_label(cr, x[col]  * width, y[col] * height, r * 2, r * 2, col, NULL);</a>
<a name="ln1629">          else</a>
<a name="ln1630">            dtgtk_cairo_paint_label(cr, x_zoom[col]  * fscale, y_zoom[col] * fscale, r * 2, r * 2, col, NULL);</a>
<a name="ln1631">          colorlabel_painted = colorlabel_painted || TRUE;</a>
<a name="ln1632">          painted_col[col] = TRUE;</a>
<a name="ln1633">        }</a>
<a name="ln1634">        cairo_restore(cr);</a>
<a name="ln1635">      }</a>
<a name="ln1636">      if (colorlabel_painted)</a>
<a name="ln1637">      {</a>
<a name="ln1638">        const int dont_fill_col = 7;</a>
<a name="ln1639">        for(int i = 0; i &lt; max_col; i++)</a>
<a name="ln1640">        {</a>
<a name="ln1641">          if (!painted_col[i])</a>
<a name="ln1642">          {</a>
<a name="ln1643">            cairo_save(cr);</a>
<a name="ln1644">            if (zoom != 1)</a>
<a name="ln1645">              dtgtk_cairo_paint_label(cr, x[i]  * width, y[i] * height, r * 2, r * 2, dont_fill_col, NULL);</a>
<a name="ln1646">            else</a>
<a name="ln1647">              dtgtk_cairo_paint_label(cr, x_zoom[i]  * fscale, y_zoom[i] * fscale, r * 2, r * 2, dont_fill_col, NULL);</a>
<a name="ln1648">            cairo_restore(cr);</a>
<a name="ln1649">          }</a>
<a name="ln1650">        }</a>
<a name="ln1651">      }</a>
<a name="ln1652">    }</a>
<a name="ln1653">  }</a>
<a name="ln1654"> </a>
<a name="ln1655">  if (draw_local_copy)</a>
<a name="ln1656">  {</a>
<a name="ln1657">    if(img &amp;&amp; width &gt; DECORATION_SIZE_LIMIT)</a>
<a name="ln1658">    {</a>
<a name="ln1659">      const gboolean has_local_copy = (img &amp;&amp; (img-&gt;flags &amp; DT_IMAGE_LOCAL_COPY));</a>
<a name="ln1660"> </a>
<a name="ln1661">      if (has_local_copy)</a>
<a name="ln1662">      {</a>
<a name="ln1663">        cairo_save(cr);</a>
<a name="ln1664"> </a>
<a name="ln1665">        if (zoom != 1)</a>
<a name="ln1666">        {</a>
<a name="ln1667">          const double x0 = DT_PIXEL_APPLY_DPI(1), y0 = DT_PIXEL_APPLY_DPI(1), rect_width = width - DT_PIXEL_APPLY_DPI(2),</a>
<a name="ln1668">                radius = DT_PIXEL_APPLY_DPI(5);</a>
<a name="ln1669">          double x1, off, off1;</a>
<a name="ln1670"> </a>
<a name="ln1671">          x1 = x0 + rect_width;</a>
<a name="ln1672">          off = radius * 0.666;</a>
<a name="ln1673">          off1 = radius - off;</a>
<a name="ln1674"> </a>
<a name="ln1675">          cairo_move_to(cr, x1 - width * 0.08, y0);</a>
<a name="ln1676">          cairo_line_to(cr, x1 - radius, y0);</a>
<a name="ln1677">          cairo_curve_to(cr, x1 - off1, y0, x1, y0 + off1, x1, y0 + radius);</a>
<a name="ln1678">          cairo_line_to(cr, x1, y0 + height * 0.08);</a>
<a name="ln1679">          cairo_close_path(cr);</a>
<a name="ln1680">          cairo_set_source_rgb(cr, 1, 1, 1);</a>
<a name="ln1681">          cairo_fill_preserve(cr);</a>
<a name="ln1682">          cairo_set_line_width(cr, 0.005 * width);</a>
<a name="ln1683">          dt_gui_gtk_set_source_rgb(cr, outlinecol);</a>
<a name="ln1684">          cairo_stroke(cr);</a>
<a name="ln1685">        }</a>
<a name="ln1686">        else</a>
<a name="ln1687">        {</a>
<a name="ln1688">          const float x_zoom = 0.280;</a>
<a name="ln1689">          const float y_zoom = 0.110;</a>
<a name="ln1690">          const float edge_length = 0.018 * fscale;</a>
<a name="ln1691"> </a>
<a name="ln1692">          cairo_rectangle(cr, x_zoom * fscale, y_zoom * fscale, edge_length, edge_length);</a>
<a name="ln1693">          cairo_set_source_rgb(cr, 0.5, 0.5, 0.5);</a>
<a name="ln1694">          cairo_set_line_width(cr, 0.002 * fscale);</a>
<a name="ln1695">          cairo_stroke(cr);</a>
<a name="ln1696"> </a>
<a name="ln1697">          cairo_move_to(cr, x_zoom * fscale + edge_length * 0.1, y_zoom * fscale);</a>
<a name="ln1698">          cairo_line_to(cr, x_zoom * fscale + edge_length, y_zoom * fscale);</a>
<a name="ln1699">          cairo_line_to(cr, x_zoom * fscale + edge_length, y_zoom * fscale + edge_length * 0.9);</a>
<a name="ln1700">          cairo_close_path(cr);</a>
<a name="ln1701">          cairo_set_source_rgb(cr, 1, 1, 1);</a>
<a name="ln1702">          cairo_fill_preserve(cr);</a>
<a name="ln1703">          cairo_set_source_rgb(cr, 0.5, 0.5, 0.5);</a>
<a name="ln1704">          cairo_stroke(cr);</a>
<a name="ln1705">        }</a>
<a name="ln1706">        cairo_restore(cr);</a>
<a name="ln1707">      }</a>
<a name="ln1708">    }</a>
<a name="ln1709">  }</a>
<a name="ln1710"> </a>
<a name="ln1711">  if(draw_metadata &amp;&amp; img &amp;&amp; (zoom == 1))</a>
<a name="ln1712">  {</a>
<a name="ln1713">    // some exif data</a>
<a name="ln1714">    PangoLayout *layout;</a>
<a name="ln1715">    PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln1716">    pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln1717">    layout = pango_cairo_create_layout(cr);</a>
<a name="ln1718">    const int fontsize = 0.025 * fscale;</a>
<a name="ln1719">    pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);</a>
<a name="ln1720">    pango_layout_set_font_description(layout, desc);</a>
<a name="ln1721">    cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);</a>
<a name="ln1722">    cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0));</a>
<a name="ln1723">    cairo_set_source_rgb(cr, 0.3, 0.3, 0.3);</a>
<a name="ln1724"> </a>
<a name="ln1725">    cairo_move_to(cr, .02 * fscale, .04 * fscale - fontsize);</a>
<a name="ln1726">    pango_layout_set_text(layout, img-&gt;filename, -1);</a>
<a name="ln1727">    pango_cairo_layout_path(cr, layout);</a>
<a name="ln1728">    char exifline[50];</a>
<a name="ln1729">    cairo_move_to(cr, .02 * fscale, .08 * fscale - fontsize);</a>
<a name="ln1730">    dt_image_print_exif(img, exifline, sizeof(exifline));</a>
<a name="ln1731">    pango_layout_set_text(layout, exifline, -1);</a>
<a name="ln1732">    pango_cairo_layout_path(cr, layout);</a>
<a name="ln1733">    cairo_stroke_preserve(cr);</a>
<a name="ln1734">    cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln1735">    cairo_fill(cr);</a>
<a name="ln1736">    pango_font_description_free(desc);</a>
<a name="ln1737">    g_object_unref(layout);</a>
<a name="ln1738"> </a>
<a name="ln1739">  }</a>
<a name="ln1740"> </a>
<a name="ln1741">  // draw custom metadata from accompanying text file:</a>
<a name="ln1742">  if(draw_metadata &amp;&amp; img &amp;&amp; (img-&gt;flags &amp; DT_IMAGE_HAS_TXT) &amp;&amp; dt_conf_get_bool(&quot;plugins/lighttable/draw_custom_metadata&quot;)</a>
<a name="ln1743">     &amp;&amp; (zoom == 1))</a>
<a name="ln1744">  {</a>
<a name="ln1745">    char *path = dt_image_get_text_path(img-&gt;id);</a>
<a name="ln1746">    if(path)</a>
<a name="ln1747">    {</a>
<a name="ln1748">      FILE *f = g_fopen(path, &quot;rb&quot;);</a>
<a name="ln1749">      if(f)</a>
<a name="ln1750">      {</a>
<a name="ln1751">        char line[2048];</a>
<a name="ln1752">        PangoLayout *layout;</a>
<a name="ln1753">        PangoFontDescription *desc = pango_font_description_from_string(&quot;monospace bold&quot;);</a>
<a name="ln1754">        layout = pango_cairo_create_layout(cr);</a>
<a name="ln1755">        const float fontsize = 0.015 * fscale;</a>
<a name="ln1756">        pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);</a>
<a name="ln1757">        pango_layout_set_font_description(layout, desc);</a>
<a name="ln1758">        // cairo_set_operator(cr, CAIRO_OPERATOR_XOR);</a>
<a name="ln1759">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0));</a>
<a name="ln1760">        cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);</a>
<a name="ln1761">        int k = 0;</a>
<a name="ln1762">        while(!feof(f))</a>
<a name="ln1763">        {</a>
<a name="ln1764">          gchar *line_pattern = g_strdup_printf(&quot;%%%zu[^\n]&quot;, sizeof(line) - 1);</a>
<a name="ln1765">          const int read = fscanf(f, line_pattern, line);</a>
<a name="ln1766">          g_free(line_pattern);</a>
<a name="ln1767">          if(read != 1) break;</a>
<a name="ln1768">          fgetc(f); // munch \n</a>
<a name="ln1769"> </a>
<a name="ln1770">          cairo_move_to(cr, .02 * fscale, .20 * fscale + .017 * fscale * k - fontsize);</a>
<a name="ln1771">          cairo_set_source_rgb(cr, 0.3, 0.3, 0.3);</a>
<a name="ln1772">          pango_layout_set_text(layout, line, -1);</a>
<a name="ln1773">          pango_cairo_layout_path(cr, layout);</a>
<a name="ln1774">          cairo_stroke_preserve(cr);</a>
<a name="ln1775">          cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln1776">          cairo_fill(cr);</a>
<a name="ln1777">          k++;</a>
<a name="ln1778">        }</a>
<a name="ln1779">        fclose(f);</a>
<a name="ln1780">        pango_font_description_free(desc);</a>
<a name="ln1781">        g_object_unref(layout);</a>
<a name="ln1782"> </a>
<a name="ln1783">      }</a>
<a name="ln1784">      g_free(path);</a>
<a name="ln1785">    }</a>
<a name="ln1786">  }</a>
<a name="ln1787"> </a>
<a name="ln1788">  cairo_restore(cr);</a>
<a name="ln1789">  // if(zoom == 1) cairo_set_antialias(cr, CAIRO_ANTIALIAS_DEFAULT);</a>
<a name="ln1790"> </a>
<a name="ln1791">  const double end = dt_get_wtime();</a>
<a name="ln1792">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1793">    dt_print(DT_DEBUG_LIGHTTABLE, &quot;[lighttable] image expose took %0.04f sec\n&quot;, end - start);</a>
<a name="ln1794">  return missing;</a>
<a name="ln1795">}</a>
<a name="ln1796"> </a>
<a name="ln1797">void</a>
<a name="ln1798">dt_view_image_only_expose(</a>
<a name="ln1799">  uint32_t imgid,</a>
<a name="ln1800">  cairo_t *cr,</a>
<a name="ln1801">  int32_t width,</a>
<a name="ln1802">  int32_t height,</a>
<a name="ln1803">  int32_t offsetx,</a>
<a name="ln1804">  int32_t offsety)</a>
<a name="ln1805">{</a>
<a name="ln1806">  dt_view_image_over_t image_over;</a>
<a name="ln1807">  dt_view_image_expose_t params = { 0 };</a>
<a name="ln1808">  params.image_over = &amp;image_over;</a>
<a name="ln1809">  params.imgid = imgid;</a>
<a name="ln1810">  params.cr = cr;</a>
<a name="ln1811">  params.width = width;</a>
<a name="ln1812">  params.height = height;</a>
<a name="ln1813">  params.px = offsetx;</a>
<a name="ln1814">  params.py = offsety;</a>
<a name="ln1815">  params.zoom = 1;</a>
<a name="ln1816">  params.image_only = TRUE;</a>
<a name="ln1817">  params.full_preview = TRUE;</a>
<a name="ln1818"> </a>
<a name="ln1819">  dt_view_image_expose(&amp;params);</a>
<a name="ln1820">}</a>
<a name="ln1821"> </a>
<a name="ln1822"> </a>
<a name="ln1823">/**</a>
<a name="ln1824"> * \brief Set the selection bit to a given value for the specified image</a>
<a name="ln1825"> * \param[in] imgid The image id</a>
<a name="ln1826"> * \param[in] value The boolean value for the bit</a>
<a name="ln1827"> */</a>
<a name="ln1828">void dt_view_set_selection(int imgid, int value)</a>
<a name="ln1829">{</a>
<a name="ln1830">  /* clear and reset statement */</a>
<a name="ln1831">  DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln1832">  DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln1833"> </a>
<a name="ln1834">  /* setup statement and iterate over rows */</a>
<a name="ln1835">  DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.is_selected, 1, imgid);</a>
<a name="ln1836"> </a>
<a name="ln1837">  if(sqlite3_step(darktable.view_manager-&gt;statements.is_selected) == SQLITE_ROW)</a>
<a name="ln1838">  {</a>
<a name="ln1839">    if(!value)</a>
<a name="ln1840">    {</a>
<a name="ln1841">      /* Value is set and should be unset; get rid of it */</a>
<a name="ln1842"> </a>
<a name="ln1843">      /* clear and reset statement */</a>
<a name="ln1844">      DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.delete_from_selected);</a>
<a name="ln1845">      DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.delete_from_selected);</a>
<a name="ln1846"> </a>
<a name="ln1847">      /* setup statement and execute */</a>
<a name="ln1848">      DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.delete_from_selected, 1, imgid);</a>
<a name="ln1849">      sqlite3_step(darktable.view_manager-&gt;statements.delete_from_selected);</a>
<a name="ln1850">    }</a>
<a name="ln1851">  }</a>
<a name="ln1852">  else if(value)</a>
<a name="ln1853">  {</a>
<a name="ln1854">    /* Select bit is unset and should be set; add it */</a>
<a name="ln1855"> </a>
<a name="ln1856">    /* clear and reset statement */</a>
<a name="ln1857">    DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1858">    DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1859"> </a>
<a name="ln1860">    /* setup statement and execute */</a>
<a name="ln1861">    DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.make_selected, 1, imgid);</a>
<a name="ln1862">    sqlite3_step(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1863">  }</a>
<a name="ln1864">}</a>
<a name="ln1865"> </a>
<a name="ln1866">/**</a>
<a name="ln1867"> * \brief Toggle the selection bit in the database for the specified image</a>
<a name="ln1868"> * \param[in] imgid The image id</a>
<a name="ln1869"> */</a>
<a name="ln1870">void dt_view_toggle_selection(int imgid)</a>
<a name="ln1871">{</a>
<a name="ln1872"> </a>
<a name="ln1873">  /* clear and reset statement */</a>
<a name="ln1874">  DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln1875">  DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.is_selected);</a>
<a name="ln1876"> </a>
<a name="ln1877">  /* setup statement and iterate over rows */</a>
<a name="ln1878">  DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.is_selected, 1, imgid);</a>
<a name="ln1879">  if(sqlite3_step(darktable.view_manager-&gt;statements.is_selected) == SQLITE_ROW)</a>
<a name="ln1880">  {</a>
<a name="ln1881">    /* clear and reset statement */</a>
<a name="ln1882">    DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.delete_from_selected);</a>
<a name="ln1883">    DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.delete_from_selected);</a>
<a name="ln1884"> </a>
<a name="ln1885">    /* setup statement and execute */</a>
<a name="ln1886">    DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.delete_from_selected, 1, imgid);</a>
<a name="ln1887">    sqlite3_step(darktable.view_manager-&gt;statements.delete_from_selected);</a>
<a name="ln1888">  }</a>
<a name="ln1889">  else</a>
<a name="ln1890">  {</a>
<a name="ln1891">    /* clear and reset statement */</a>
<a name="ln1892">    DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1893">    DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1894"> </a>
<a name="ln1895">    /* setup statement and execute */</a>
<a name="ln1896">    DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.make_selected, 1, imgid);</a>
<a name="ln1897">    sqlite3_step(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1898">  }</a>
<a name="ln1899">}</a>
<a name="ln1900"> </a>
<a name="ln1901">/**</a>
<a name="ln1902"> * \brief Reset filter</a>
<a name="ln1903"> */</a>
<a name="ln1904">void dt_view_filter_reset(const dt_view_manager_t *vm, gboolean smart_filter)</a>
<a name="ln1905">{</a>
<a name="ln1906">  if(vm-&gt;proxy.filter.module &amp;&amp; vm-&gt;proxy.filter.reset_filter)</a>
<a name="ln1907">    vm-&gt;proxy.filter.reset_filter(vm-&gt;proxy.filter.module, smart_filter);</a>
<a name="ln1908">}</a>
<a name="ln1909"> </a>
<a name="ln1910">void dt_view_filmstrip_scroll_relative(const int diff, int offset)</a>
<a name="ln1911">{</a>
<a name="ln1912">  const gchar *qin = dt_collection_get_query(darktable.collection);</a>
<a name="ln1913">  if(qin)</a>
<a name="ln1914">  {</a>
<a name="ln1915">    sqlite3_stmt *stmt;</a>
<a name="ln1916"> </a>
<a name="ln1917">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), qin, -1, &amp;stmt, NULL);</a>
<a name="ln1918">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, offset + diff);</a>
<a name="ln1919">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, 1);</a>
<a name="ln1920">    if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1921">    {</a>
<a name="ln1922">      const int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1923"> </a>
<a name="ln1924">      if(!darktable.develop-&gt;image_loading)</a>
<a name="ln1925">      {</a>
<a name="ln1926">        dt_view_filmstrip_scroll_to_image(darktable.view_manager, imgid, TRUE);</a>
<a name="ln1927">      }</a>
<a name="ln1928">    }</a>
<a name="ln1929">    sqlite3_finalize(stmt);</a>
<a name="ln1930">  }</a>
<a name="ln1931">}</a>
<a name="ln1932"> </a>
<a name="ln1933">void dt_view_filmstrip_scroll_to_image(dt_view_manager_t *vm, const int imgid, gboolean activate)</a>
<a name="ln1934">{</a>
<a name="ln1935">  // g_return_if_fail(vm-&gt;proxy.filmstrip.module!=NULL); // This can happen here for debugging</a>
<a name="ln1936">  // g_return_if_fail(vm-&gt;proxy.filmstrip.scroll_to_image!=NULL);</a>
<a name="ln1937"> </a>
<a name="ln1938">  if(vm-&gt;proxy.filmstrip.module &amp;&amp; vm-&gt;proxy.filmstrip.scroll_to_image)</a>
<a name="ln1939">    vm-&gt;proxy.filmstrip.scroll_to_image(vm-&gt;proxy.filmstrip.module, imgid, activate);</a>
<a name="ln1940">}</a>
<a name="ln1941"> </a>
<a name="ln1942">int32_t dt_view_filmstrip_get_activated_imgid(dt_view_manager_t *vm)</a>
<a name="ln1943">{</a>
<a name="ln1944">  // g_return_val_if_fail(vm-&gt;proxy.filmstrip.module!=NULL, 0); // This can happen here for debugging</a>
<a name="ln1945">  // g_return_val_if_fail(vm-&gt;proxy.filmstrip.activated_image!=NULL, 0);</a>
<a name="ln1946"> </a>
<a name="ln1947">  if(vm-&gt;proxy.filmstrip.module &amp;&amp; vm-&gt;proxy.filmstrip.activated_image)</a>
<a name="ln1948">    return vm-&gt;proxy.filmstrip.activated_image(vm-&gt;proxy.filmstrip.module);</a>
<a name="ln1949"> </a>
<a name="ln1950">  return 0;</a>
<a name="ln1951">}</a>
<a name="ln1952"> </a>
<a name="ln1953">void dt_view_filmstrip_set_active_image(dt_view_manager_t *vm, int iid)</a>
<a name="ln1954">{</a>
<a name="ln1955">  /* First off clear all selected images... */</a>
<a name="ln1956">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images&quot;, NULL, NULL, NULL);</a>
<a name="ln1957"> </a>
<a name="ln1958">  /* clear and reset statement */</a>
<a name="ln1959">  DT_DEBUG_SQLITE3_CLEAR_BINDINGS(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1960">  DT_DEBUG_SQLITE3_RESET(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1961"> </a>
<a name="ln1962">  /* setup statement and execute */</a>
<a name="ln1963">  DT_DEBUG_SQLITE3_BIND_INT(darktable.view_manager-&gt;statements.make_selected, 1, iid);</a>
<a name="ln1964">  sqlite3_step(darktable.view_manager-&gt;statements.make_selected);</a>
<a name="ln1965"> </a>
<a name="ln1966">  dt_view_filmstrip_scroll_to_image(vm, iid, TRUE);</a>
<a name="ln1967">}</a>
<a name="ln1968"> </a>
<a name="ln1969">void dt_view_filmstrip_prefetch()</a>
<a name="ln1970">{</a>
<a name="ln1971">  const gchar *qin = dt_collection_get_query(darktable.collection);</a>
<a name="ln1972">  if(!qin) return;</a>
<a name="ln1973"> </a>
<a name="ln1974">  int offset = 0;</a>
<a name="ln1975">  if(qin)</a>
<a name="ln1976">  {</a>
<a name="ln1977">    int imgid = -1;</a>
<a name="ln1978">    sqlite3_stmt *stmt;</a>
<a name="ln1979">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;, -1, &amp;stmt,</a>
<a name="ln1980">                                NULL);</a>
<a name="ln1981">    if(sqlite3_step(stmt) == SQLITE_ROW) imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1982">    sqlite3_finalize(stmt);</a>
<a name="ln1983"> </a>
<a name="ln1984">    offset = dt_collection_image_offset(imgid);</a>
<a name="ln1985">  }</a>
<a name="ln1986"> </a>
<a name="ln1987">  sqlite3_stmt *stmt;</a>
<a name="ln1988">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), qin, -1, &amp;stmt, NULL);</a>
<a name="ln1989">  // only get one more image:</a>
<a name="ln1990">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, offset + 1);</a>
<a name="ln1991">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, offset + 2);</a>
<a name="ln1992">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1993">  {</a>
<a name="ln1994">    const uint32_t prefetchid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1995">    // dt_control_log(&quot;prefetching image %u&quot;, prefetchid);</a>
<a name="ln1996">    dt_mipmap_cache_get(darktable.mipmap_cache, NULL, prefetchid, DT_MIPMAP_FULL, DT_MIPMAP_PREFETCH, 'r');</a>
<a name="ln1997">  }</a>
<a name="ln1998">  sqlite3_finalize(stmt);</a>
<a name="ln1999">}</a>
<a name="ln2000"> </a>
<a name="ln2001">void dt_view_manager_view_toolbox_add(dt_view_manager_t *vm, GtkWidget *tool, dt_view_type_flags_t views)</a>
<a name="ln2002">{</a>
<a name="ln2003">  if(vm-&gt;proxy.view_toolbox.module) vm-&gt;proxy.view_toolbox.add(vm-&gt;proxy.view_toolbox.module, tool, views);</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006">void dt_view_manager_module_toolbox_add(dt_view_manager_t *vm, GtkWidget *tool, dt_view_type_flags_t views)</a>
<a name="ln2007">{</a>
<a name="ln2008">  if(vm-&gt;proxy.module_toolbox.module) vm-&gt;proxy.module_toolbox.add(vm-&gt;proxy.module_toolbox.module, tool, views);</a>
<a name="ln2009">}</a>
<a name="ln2010"> </a>
<a name="ln2011">void dt_view_lighttable_set_zoom(dt_view_manager_t *vm, gint zoom)</a>
<a name="ln2012">{</a>
<a name="ln2013">  if(vm-&gt;proxy.lighttable.module) vm-&gt;proxy.lighttable.set_zoom(vm-&gt;proxy.lighttable.module, zoom);</a>
<a name="ln2014">}</a>
<a name="ln2015"> </a>
<a name="ln2016">gint dt_view_lighttable_get_zoom(dt_view_manager_t *vm)</a>
<a name="ln2017">{</a>
<a name="ln2018">  if(vm-&gt;proxy.lighttable.module)</a>
<a name="ln2019">    return vm-&gt;proxy.lighttable.get_zoom(vm-&gt;proxy.lighttable.module);</a>
<a name="ln2020">  else</a>
<a name="ln2021">    return 10;</a>
<a name="ln2022">}</a>
<a name="ln2023"> </a>
<a name="ln2024">void dt_view_lighttable_set_display_num_images(dt_view_manager_t *vm, const int display_num_images)</a>
<a name="ln2025">{</a>
<a name="ln2026">  if(vm-&gt;proxy.lighttable.module)</a>
<a name="ln2027">    vm-&gt;proxy.lighttable.set_display_num_images(vm-&gt;proxy.lighttable.module, display_num_images);</a>
<a name="ln2028">}</a>
<a name="ln2029"> </a>
<a name="ln2030">int dt_view_lighttable_get_display_num_images(dt_view_manager_t *vm)</a>
<a name="ln2031">{</a>
<a name="ln2032">  if(vm-&gt;proxy.lighttable.module)</a>
<a name="ln2033">    return vm-&gt;proxy.lighttable.get_display_num_images(vm-&gt;proxy.lighttable.module);</a>
<a name="ln2034">  else</a>
<a name="ln2035">    return 2;</a>
<a name="ln2036">}</a>
<a name="ln2037"> </a>
<a name="ln2038">void dt_view_lighttable_force_expose_all(dt_view_manager_t *vm)</a>
<a name="ln2039">{</a>
<a name="ln2040">  if(vm-&gt;proxy.lighttable.view)</a>
<a name="ln2041">    vm-&gt;proxy.lighttable.force_expose_all(vm-&gt;proxy.lighttable.view);</a>
<a name="ln2042">}</a>
<a name="ln2043"> </a>
<a name="ln2044">dt_lighttable_layout_t dt_view_lighttable_get_layout(dt_view_manager_t *vm)</a>
<a name="ln2045">{</a>
<a name="ln2046">  if(vm-&gt;proxy.lighttable.module)</a>
<a name="ln2047">    return vm-&gt;proxy.lighttable.get_layout(vm-&gt;proxy.lighttable.module);</a>
<a name="ln2048">  else</a>
<a name="ln2049">    return DT_LIGHTTABLE_LAYOUT_FILEMANAGER;</a>
<a name="ln2050">}</a>
<a name="ln2051"> </a>
<a name="ln2052">gboolean dt_view_lighttable_preview_state(dt_view_manager_t *vm)</a>
<a name="ln2053">{</a>
<a name="ln2054">  if(vm-&gt;proxy.lighttable.module)</a>
<a name="ln2055">    return (vm-&gt;proxy.lighttable.get_full_preview_id(vm-&gt;proxy.lighttable.view) != -1);</a>
<a name="ln2056">  else</a>
<a name="ln2057">    return FALSE;</a>
<a name="ln2058">}</a>
<a name="ln2059"> </a>
<a name="ln2060">void dt_view_lighttable_set_position(dt_view_manager_t *vm, uint32_t pos)</a>
<a name="ln2061">{</a>
<a name="ln2062">  if(vm-&gt;proxy.lighttable.view) vm-&gt;proxy.lighttable.set_position(vm-&gt;proxy.lighttable.view, pos);</a>
<a name="ln2063"> </a>
<a name="ln2064">  // ugh. but will go away once module guis are persistent between views:</a>
<a name="ln2065">  dt_conf_set_int(&quot;plugins/lighttable/recentcollect/pos0&quot;, pos);</a>
<a name="ln2066">}</a>
<a name="ln2067"> </a>
<a name="ln2068">uint32_t dt_view_lighttable_get_position(dt_view_manager_t *vm)</a>
<a name="ln2069">{</a>
<a name="ln2070">  if(vm-&gt;proxy.lighttable.view) return vm-&gt;proxy.lighttable.get_position(vm-&gt;proxy.lighttable.view);</a>
<a name="ln2071">  return 0;</a>
<a name="ln2072">}</a>
<a name="ln2073"> </a>
<a name="ln2074">void dt_view_collection_update(const dt_view_manager_t *vm)</a>
<a name="ln2075">{</a>
<a name="ln2076">  if(vm-&gt;proxy.module_collect.module) vm-&gt;proxy.module_collect.update(vm-&gt;proxy.module_collect.module);</a>
<a name="ln2077">}</a>
<a name="ln2078"> </a>
<a name="ln2079"> </a>
<a name="ln2080">int32_t dt_view_tethering_get_selected_imgid(const dt_view_manager_t *vm)</a>
<a name="ln2081">{</a>
<a name="ln2082">  if(vm-&gt;proxy.tethering.view) return vm-&gt;proxy.tethering.get_selected_imgid(vm-&gt;proxy.tethering.view);</a>
<a name="ln2083"> </a>
<a name="ln2084">  return -1;</a>
<a name="ln2085">}</a>
<a name="ln2086"> </a>
<a name="ln2087">void dt_view_tethering_set_job_code(const dt_view_manager_t *vm, const char *name)</a>
<a name="ln2088">{</a>
<a name="ln2089">  if(vm-&gt;proxy.tethering.view) vm-&gt;proxy.tethering.set_job_code(vm-&gt;proxy.tethering.view, name);</a>
<a name="ln2090">}</a>
<a name="ln2091"> </a>
<a name="ln2092">const char *dt_view_tethering_get_job_code(const dt_view_manager_t *vm)</a>
<a name="ln2093">{</a>
<a name="ln2094">  if(vm-&gt;proxy.tethering.view) return vm-&gt;proxy.tethering.get_job_code(vm-&gt;proxy.tethering.view);</a>
<a name="ln2095">  return NULL;</a>
<a name="ln2096">}</a>
<a name="ln2097"> </a>
<a name="ln2098">#ifdef HAVE_MAP</a>
<a name="ln2099">void dt_view_map_center_on_location(const dt_view_manager_t *vm, gdouble lon, gdouble lat, gdouble zoom)</a>
<a name="ln2100">{</a>
<a name="ln2101">  if(vm-&gt;proxy.map.view) vm-&gt;proxy.map.center_on_location(vm-&gt;proxy.map.view, lon, lat, zoom);</a>
<a name="ln2102">}</a>
<a name="ln2103"> </a>
<a name="ln2104">void dt_view_map_center_on_bbox(const dt_view_manager_t *vm, gdouble lon1, gdouble lat1, gdouble lon2, gdouble lat2)</a>
<a name="ln2105">{</a>
<a name="ln2106">  if(vm-&gt;proxy.map.view) vm-&gt;proxy.map.center_on_bbox(vm-&gt;proxy.map.view, lon1, lat1, lon2, lat2);</a>
<a name="ln2107">}</a>
<a name="ln2108"> </a>
<a name="ln2109">void dt_view_map_show_osd(const dt_view_manager_t *vm, gboolean enabled)</a>
<a name="ln2110">{</a>
<a name="ln2111">  if(vm-&gt;proxy.map.view) vm-&gt;proxy.map.show_osd(vm-&gt;proxy.map.view, enabled);</a>
<a name="ln2112">}</a>
<a name="ln2113"> </a>
<a name="ln2114">void dt_view_map_set_map_source(const dt_view_manager_t *vm, OsmGpsMapSource_t map_source)</a>
<a name="ln2115">{</a>
<a name="ln2116">  if(vm-&gt;proxy.map.view) vm-&gt;proxy.map.set_map_source(vm-&gt;proxy.map.view, map_source);</a>
<a name="ln2117">}</a>
<a name="ln2118"> </a>
<a name="ln2119">GObject *dt_view_map_add_marker(const dt_view_manager_t *vm, dt_geo_map_display_t type, GList *points)</a>
<a name="ln2120">{</a>
<a name="ln2121">  if(vm-&gt;proxy.map.view) return vm-&gt;proxy.map.add_marker(vm-&gt;proxy.map.view, type, points);</a>
<a name="ln2122">  return NULL;</a>
<a name="ln2123">}</a>
<a name="ln2124"> </a>
<a name="ln2125">gboolean dt_view_map_remove_marker(const dt_view_manager_t *vm, dt_geo_map_display_t type, GObject *marker)</a>
<a name="ln2126">{</a>
<a name="ln2127">  if(vm-&gt;proxy.map.view) return vm-&gt;proxy.map.remove_marker(vm-&gt;proxy.map.view, type, marker);</a>
<a name="ln2128">  return FALSE;</a>
<a name="ln2129">}</a>
<a name="ln2130">#endif</a>
<a name="ln2131"> </a>
<a name="ln2132">#ifdef HAVE_PRINT</a>
<a name="ln2133">void dt_view_print_settings(const dt_view_manager_t *vm, dt_print_info_t *pinfo)</a>
<a name="ln2134">{</a>
<a name="ln2135">  if (vm-&gt;proxy.print.view)</a>
<a name="ln2136">    vm-&gt;proxy.print.print_settings(vm-&gt;proxy.print.view, pinfo);</a>
<a name="ln2137">}</a>
<a name="ln2138">#endif</a>
<a name="ln2139"> </a>
<a name="ln2140">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2141">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2142">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1570"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'darktable.gui' pointer was utilized before it was verified against nullptr. Check lines: 1570, 1574.</p></div>
<div class="balloon" rel="1659"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: img.</p></div>
<div class="balloon" rel="1975"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'qin' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
