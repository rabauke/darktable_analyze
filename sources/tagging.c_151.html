
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4">    copyright (c) 2011 henrik andersson.</a>
<a name="ln5">    copyright (c) 2019 philippe weyland.</a>
<a name="ln6"> </a>
<a name="ln7">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln8">    it under the terms of the GNU General Public License as published by</a>
<a name="ln9">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln10">    (at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln13">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">    GNU General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">    You should have received a copy of the GNU General Public License</a>
<a name="ln18">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln19">*/</a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/tags.h&quot;</a>
<a name="ln24">#include &quot;control/conf.h&quot;</a>
<a name="ln25">#include &quot;control/control.h&quot;</a>
<a name="ln26">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln27">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln28">#include &quot;gui/gtk.h&quot;</a>
<a name="ln29">#include &quot;libs/lib.h&quot;</a>
<a name="ln30">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln31">#include &quot;views/view.h&quot;</a>
<a name="ln32">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln33">#include &quot;osx/osx.h&quot;</a>
<a name="ln34">#endif</a>
<a name="ln35">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln36">#include &lt;math.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#define FLOATING_ENTRY_WIDTH DT_PIXEL_APPLY_DPI(150)</a>
<a name="ln39"> </a>
<a name="ln40">DT_MODULE(1)</a>
<a name="ln41"> </a>
<a name="ln42">static gboolean _lib_tagging_tag_show(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln43">                                      GdkModifierType modifier, dt_lib_module_t *self);</a>
<a name="ln44"> </a>
<a name="ln45">typedef struct dt_lib_tagging_t</a>
<a name="ln46">{</a>
<a name="ln47">  char keyword[1024];</a>
<a name="ln48">  GtkEntry *entry;</a>
<a name="ln49">  GtkTreeView *attached_view, *dictionary_view;</a>
<a name="ln50">  int imgsel;</a>
<a name="ln51">  GtkWidget *attach_button, *detach_button, *new_button, *import_button, *export_button, *attached_window, *dictionary_window;</a>
<a name="ln52">  GtkWidget *toggle_tree_button, *toggle_suggestion_button, *toggle_sort_button, *toggle_hide_button, *toggle_dttags_button;</a>
<a name="ln53">  gulong tree_button_handler, suggestion_button_handler, sort_button_handler, hide_button_handler;</a>
<a name="ln54">  GtkListStore *attached_liststore, *dictionary_liststore;</a>
<a name="ln55">  GtkTreeStore *dictionary_treestore;</a>
<a name="ln56">  GtkTreeModelFilter *dictionary_listfilter, *dictionary_treefilter;</a>
<a name="ln57">  GtkWidget *floating_tag_window;</a>
<a name="ln58">  int floating_tag_imgid;</a>
<a name="ln59">  gboolean tree_flag, suggestion_flag, sort_count_flag, hide_path_flag, dttags_flag;</a>
<a name="ln60">  char *collection;</a>
<a name="ln61">  GtkEntryCompletion *completion;</a>
<a name="ln62">} dt_lib_tagging_t;</a>
<a name="ln63"> </a>
<a name="ln64">typedef struct dt_tag_op_t</a>
<a name="ln65">{</a>
<a name="ln66">  gint tagid;</a>
<a name="ln67">  guint count;</a>
<a name="ln68">  char *newtagname;</a>
<a name="ln69">  char *oldtagname;</a>
<a name="ln70">  int select;</a>
<a name="ln71">  gboolean tree_flag, suggestion_flag;</a>
<a name="ln72">} dt_tag_op_t;</a>
<a name="ln73"> </a>
<a name="ln74">typedef enum dt_lib_tagging_cols_t</a>
<a name="ln75">{</a>
<a name="ln76">  DT_LIB_TAGGING_COL_TAG = 0,</a>
<a name="ln77">  DT_LIB_TAGGING_COL_ID,</a>
<a name="ln78">  DT_LIB_TAGGING_COL_PATH,</a>
<a name="ln79">  DT_LIB_TAGGING_COL_SYNONYM,</a>
<a name="ln80">  DT_LIB_TAGGING_COL_COUNT,</a>
<a name="ln81">  DT_LIB_TAGGING_COL_SEL,</a>
<a name="ln82">  DT_LIB_TAGGING_COL_FLAGS,</a>
<a name="ln83">  DT_LIB_TAGGING_COL_VISIBLE,</a>
<a name="ln84">  DT_LIB_TAGGING_NUM_COLS</a>
<a name="ln85">} dt_lib_tagging_cols_t;</a>
<a name="ln86"> </a>
<a name="ln87">typedef enum dt_tag_sort_id</a>
<a name="ln88">{</a>
<a name="ln89">  DT_TAG_SORT_PATH_ID,</a>
<a name="ln90">  DT_TAG_SORT_NAME_ID,</a>
<a name="ln91">  DT_TAG_SORT_COUNT_ID</a>
<a name="ln92">} dt_tag_sort_id;</a>
<a name="ln93"> </a>
<a name="ln94">const char *name(dt_lib_module_t *self)</a>
<a name="ln95">{</a>
<a name="ln96">  return _(&quot;tagging&quot;);</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">const char **views(dt_lib_module_t *self)</a>
<a name="ln100">{</a>
<a name="ln101">  static const char *v1[] = {&quot;lighttable&quot;, &quot;darkroom&quot;, &quot;map&quot;, &quot;tethering&quot;, NULL};</a>
<a name="ln102">  static const char *v2[] = {&quot;lighttable&quot;, &quot;map&quot;, &quot;tethering&quot;, NULL};</a>
<a name="ln103"> </a>
<a name="ln104">  if(dt_conf_get_bool(&quot;plugins/darktable/tagging/visible&quot;))</a>
<a name="ln105">    return v1;</a>
<a name="ln106">  else</a>
<a name="ln107">    return v2;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln111">{</a>
<a name="ln112">  const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln113">  if(cv-&gt;view((dt_view_t *)cv) == DT_VIEW_DARKROOM)</a>
<a name="ln114">    return DT_UI_CONTAINER_PANEL_LEFT_CENTER;</a>
<a name="ln115">  else</a>
<a name="ln116">    return DT_UI_CONTAINER_PANEL_RIGHT_CENTER;</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln120">{</a>
<a name="ln121">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;attach&quot;), 0, 0);</a>
<a name="ln122">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;detach&quot;), 0, 0);</a>
<a name="ln123">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;new&quot;), 0, 0);</a>
<a name="ln124">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;tag&quot;), GDK_KEY_t, GDK_CONTROL_MASK);</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln128">{</a>
<a name="ln129">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln130"> </a>
<a name="ln131">  dt_accel_connect_button_lib(self, &quot;attach&quot;, d-&gt;attach_button);</a>
<a name="ln132">  dt_accel_connect_button_lib(self, &quot;detach&quot;, d-&gt;detach_button);</a>
<a name="ln133">  dt_accel_connect_button_lib(self, &quot;new&quot;, d-&gt;new_button);</a>
<a name="ln134">  dt_accel_connect_lib(self, &quot;tag&quot;, g_cclosure_new(G_CALLBACK(_lib_tagging_tag_show), self, NULL));</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">static void propagate_sel_to_parents(GtkTreeModel *model, GtkTreeIter *iter)</a>
<a name="ln138">{</a>
<a name="ln139">  guint sel;</a>
<a name="ln140">  GtkTreeIter parent, child = *iter;</a>
<a name="ln141">  while(gtk_tree_model_iter_parent(model, &amp;parent, &amp;child))</a>
<a name="ln142">  {</a>
<a name="ln143">    gtk_tree_model_get(model, &amp;parent, DT_LIB_TAGGING_COL_SEL, &amp;sel, -1);</a>
<a name="ln144">    if (!sel)</a>
<a name="ln145">      gtk_tree_store_set(GTK_TREE_STORE(model), &amp;parent, DT_LIB_TAGGING_COL_SEL, 1, -1);</a>
<a name="ln146">    child = parent;</a>
<a name="ln147">  }</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">static gboolean set_matching_tag_visibility(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, dt_lib_module_t *self)</a>
<a name="ln151">{</a>
<a name="ln152">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln153">  gboolean visible;</a>
<a name="ln154">  gchar *tagname = NULL;</a>
<a name="ln155">  gchar *synonyms = NULL;</a>
<a name="ln156">  gtk_tree_model_get(model, iter, DT_LIB_TAGGING_COL_PATH, &amp;tagname, DT_LIB_TAGGING_COL_SYNONYM, &amp;synonyms, -1);</a>
<a name="ln157">  if (!d-&gt;keyword[0])</a>
<a name="ln158">    visible = TRUE;</a>
<a name="ln159">  else</a>
<a name="ln160">  {</a>
<a name="ln161">    if (synonyms &amp;&amp; synonyms[0]) tagname = dt_util_dstrcat(tagname, &quot;, %s&quot;, synonyms);</a>
<a name="ln162">    gchar *haystack = g_utf8_strdown(tagname, -1);</a>
<a name="ln163">    gchar *needle = g_utf8_strdown(d-&gt;keyword, -1);</a>
<a name="ln164">    visible = (g_strrstr(haystack, needle) != NULL);</a>
<a name="ln165">    g_free(haystack);</a>
<a name="ln166">    g_free(needle);</a>
<a name="ln167">  }</a>
<a name="ln168">  if (d-&gt;tree_flag)</a>
<a name="ln169">    gtk_tree_store_set(GTK_TREE_STORE(model), iter, DT_LIB_TAGGING_COL_VISIBLE, visible, -1);</a>
<a name="ln170">  else</a>
<a name="ln171">    gtk_list_store_set(GTK_LIST_STORE(model), iter, DT_LIB_TAGGING_COL_VISIBLE, visible, -1);</a>
<a name="ln172">  g_free(tagname);</a>
<a name="ln173">  g_free(synonyms);</a>
<a name="ln174">  return FALSE;</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">static gboolean tree_reveal_func(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln178">{</a>
<a name="ln179">  gboolean state;</a>
<a name="ln180">  GtkTreeIter parent, child = *iter;</a>
<a name="ln181"> </a>
<a name="ln182">  gtk_tree_model_get(model, iter, DT_LIB_TAGGING_COL_VISIBLE, &amp;state, -1);</a>
<a name="ln183">  if(!state) return FALSE;</a>
<a name="ln184"> </a>
<a name="ln185">  while(gtk_tree_model_iter_parent(model, &amp;parent, &amp;child))</a>
<a name="ln186">  {</a>
<a name="ln187">    gtk_tree_model_get(model, &amp;parent, DT_LIB_TAGGING_COL_VISIBLE, &amp;state, -1);</a>
<a name="ln188">    gtk_tree_store_set(GTK_TREE_STORE(model), &amp;parent, DT_LIB_TAGGING_COL_VISIBLE, TRUE, -1);</a>
<a name="ln189">    child = parent;</a>
<a name="ln190">  }</a>
<a name="ln191">  return FALSE;</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">static void sort_attached_list(dt_lib_module_t *self, gboolean force)</a>
<a name="ln195">{</a>
<a name="ln196">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln197">  if (force &amp;&amp; d-&gt;sort_count_flag)</a>
<a name="ln198">  {</a>
<a name="ln199">    // ugly but when sorted by count tree_tagname_show() is not triggered</a>
<a name="ln200">    gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(d-&gt;attached_liststore), DT_TAG_SORT_NAME_ID, GTK_SORT_ASCENDING);</a>
<a name="ln201">  }</a>
<a name="ln202">  const gint sort = d-&gt;sort_count_flag ? DT_TAG_SORT_COUNT_ID : d-&gt;hide_path_flag ? DT_TAG_SORT_NAME_ID : DT_TAG_SORT_PATH_ID;</a>
<a name="ln203">  gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(d-&gt;attached_liststore), sort, GTK_SORT_ASCENDING);</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">static void sort_dictionary_list(dt_lib_module_t *self, gboolean force)</a>
<a name="ln207">{</a>
<a name="ln208">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln209">  if (!d-&gt;tree_flag)</a>
<a name="ln210">  {</a>
<a name="ln211">    if (force &amp;&amp; d-&gt;sort_count_flag)</a>
<a name="ln212">    {</a>
<a name="ln213">      // ugly but when sorted by count tree_tagname_show() is not triggered</a>
<a name="ln214">      gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(d-&gt;dictionary_liststore), DT_TAG_SORT_NAME_ID, GTK_SORT_ASCENDING);</a>
<a name="ln215">    }</a>
<a name="ln216">    const gint sort = d-&gt;sort_count_flag ? DT_TAG_SORT_COUNT_ID : d-&gt;hide_path_flag ? DT_TAG_SORT_NAME_ID : DT_TAG_SORT_PATH_ID;</a>
<a name="ln217">    gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(d-&gt;dictionary_liststore), sort, GTK_SORT_ASCENDING);</a>
<a name="ln218">  }</a>
<a name="ln219">  else</a>
<a name="ln220">    gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(d-&gt;dictionary_treestore), DT_TAG_SORT_PATH_ID, GTK_SORT_ASCENDING);</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">static void init_treeview(dt_lib_module_t *self, int which)</a>
<a name="ln224">{</a>
<a name="ln225">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln226">  GList *tags = NULL;</a>
<a name="ln227">  uint32_t count;</a>
<a name="ln228">  GtkTreeIter iter;</a>
<a name="ln229">  GtkTreeView *view;</a>
<a name="ln230">  GtkTreeModel *store;</a>
<a name="ln231">  GtkTreeModel *model;</a>
<a name="ln232"> </a>
<a name="ln233">  if(which == 0) // tags of selected images</a>
<a name="ln234">  {</a>
<a name="ln235">    const int imgsel = dt_control_get_mouse_over_id();</a>
<a name="ln236">    d-&gt;imgsel = imgsel;</a>
<a name="ln237">    count = dt_tag_get_attached(imgsel, &amp;tags, d-&gt;dttags_flag ? FALSE : TRUE);</a>
<a name="ln238">    view = d-&gt;attached_view;</a>
<a name="ln239">    model = gtk_tree_view_get_model(GTK_TREE_VIEW(view));</a>
<a name="ln240">    store = model;</a>
<a name="ln241">  }</a>
<a name="ln242">  else // dictionary_view tags of typed text</a>
<a name="ln243">  {</a>
<a name="ln244">    if (!d-&gt;tree_flag &amp;&amp; d-&gt;suggestion_flag)</a>
<a name="ln245">      count = dt_tag_get_suggestions(&amp;tags);</a>
<a name="ln246">    else</a>
<a name="ln247">      count = dt_tag_get_with_usage(&amp;tags);</a>
<a name="ln248">    view = d-&gt;dictionary_view;</a>
<a name="ln249">    model = gtk_tree_view_get_model(GTK_TREE_VIEW(view));</a>
<a name="ln250">    if (d-&gt;tree_flag)</a>
<a name="ln251">      store = GTK_TREE_MODEL(d-&gt;dictionary_treestore);</a>
<a name="ln252">    else</a>
<a name="ln253">      store = GTK_TREE_MODEL(d-&gt;dictionary_liststore);</a>
<a name="ln254">  }</a>
<a name="ln255">  g_object_ref(model);</a>
<a name="ln256">  gtk_tree_view_set_model(GTK_TREE_VIEW(view), NULL);</a>
<a name="ln257"> </a>
<a name="ln258">  gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(store), GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID, GTK_SORT_ASCENDING);</a>
<a name="ln259">  if (which &amp;&amp; d-&gt;tree_flag)</a>
<a name="ln260">  {</a>
<a name="ln261">    gtk_tree_store_clear(GTK_TREE_STORE(store));</a>
<a name="ln262">    {</a>
<a name="ln263">      char **last_tokens = NULL;</a>
<a name="ln264">      int last_tokens_length = 0;</a>
<a name="ln265">      GtkTreeIter last_parent = { 0 };</a>
<a name="ln266">      GList *sorted_tags = dt_sort_tag(tags, 0);  // ordered by full tag name</a>
<a name="ln267">      tags = sorted_tags;</a>
<a name="ln268">      for(GList *taglist = tags; taglist; taglist = g_list_next(taglist))</a>
<a name="ln269">      {</a>
<a name="ln270">        const gchar *tag = ((dt_tag_t *)taglist-&gt;data)-&gt;tag;</a>
<a name="ln271">        if(tag == NULL) continue;</a>
<a name="ln272">        char **tokens;</a>
<a name="ln273">        tokens = g_strsplit(tag, &quot;|&quot;, -1);</a>
<a name="ln274">        if(tokens)</a>
<a name="ln275">        {</a>
<a name="ln276">          // find the number of common parts at the beginning of tokens and last_tokens</a>
<a name="ln277">          GtkTreeIter parent = last_parent;</a>
<a name="ln278">          const int tokens_length = g_strv_length(tokens);</a>
<a name="ln279">          int common_length = 0;</a>
<a name="ln280">          if(last_tokens)</a>
<a name="ln281">          {</a>
<a name="ln282">            while(tokens[common_length] &amp;&amp; last_tokens[common_length] &amp;&amp;</a>
<a name="ln283">                  !g_strcmp0(tokens[common_length], last_tokens[common_length]))</a>
<a name="ln284">            {</a>
<a name="ln285">              common_length++;</a>
<a name="ln286">            }</a>
<a name="ln287"> </a>
<a name="ln288">            // point parent iter to where the entries should be added</a>
<a name="ln289">            for(int i = common_length; i &lt; last_tokens_length; i++)</a>
<a name="ln290">            {</a>
<a name="ln291">              gtk_tree_model_iter_parent(GTK_TREE_MODEL(store), &amp;parent, &amp;last_parent);</a>
<a name="ln292">              last_parent = parent;</a>
<a name="ln293">            }</a>
<a name="ln294">          }</a>
<a name="ln295"> </a>
<a name="ln296">          // insert everything from tokens past the common part</a>
<a name="ln297">          char *pth = NULL;</a>
<a name="ln298">          for(int i = 0; i &lt; common_length; i++)</a>
<a name="ln299">            pth = dt_util_dstrcat(pth, &quot;%s|&quot;, tokens[i]);</a>
<a name="ln300"> </a>
<a name="ln301">          for(char **token = &amp;tokens[common_length]; *token; token++)</a>
<a name="ln302">          {</a>
<a name="ln303">            pth = dt_util_dstrcat(pth, &quot;%s|&quot;, *token);</a>
<a name="ln304">            gchar *pth2 = g_strdup(pth);</a>
<a name="ln305">            pth2[strlen(pth2) - 1] = '\0';</a>
<a name="ln306">            gtk_tree_store_insert(GTK_TREE_STORE(store), &amp;iter, common_length &gt; 0 ? &amp;parent : NULL, -1);</a>
<a name="ln307">            gtk_tree_store_set(GTK_TREE_STORE(store), &amp;iter,</a>
<a name="ln308">                              DT_LIB_TAGGING_COL_TAG, *token,</a>
<a name="ln309">                              DT_LIB_TAGGING_COL_ID, (token == &amp;tokens[tokens_length-1]) ? ((dt_tag_t *)taglist-&gt;data)-&gt;id : 0,</a>
<a name="ln310">                              DT_LIB_TAGGING_COL_PATH, pth2,</a>
<a name="ln311">                              DT_LIB_TAGGING_COL_COUNT, (token == &amp;tokens[tokens_length-1]) ? ((dt_tag_t *)taglist-&gt;data)-&gt;count : 0,</a>
<a name="ln312">                              DT_LIB_TAGGING_COL_SEL, ((dt_tag_t *)taglist-&gt;data)-&gt;select,</a>
<a name="ln313">                              DT_LIB_TAGGING_COL_FLAGS, ((dt_tag_t *)taglist-&gt;data)-&gt;flags,</a>
<a name="ln314">                              DT_LIB_TAGGING_COL_SYNONYM, ((dt_tag_t *)taglist-&gt;data)-&gt;synonym,</a>
<a name="ln315">                              DT_LIB_TAGGING_COL_VISIBLE, TRUE,</a>
<a name="ln316">                              -1);</a>
<a name="ln317">            if (((dt_tag_t *)taglist-&gt;data)-&gt;select)</a>
<a name="ln318">              propagate_sel_to_parents(GTK_TREE_MODEL(store), &amp;iter);</a>
<a name="ln319">            common_length++;</a>
<a name="ln320">            parent = iter;</a>
<a name="ln321">            g_free(pth2);</a>
<a name="ln322">          }</a>
<a name="ln323">          g_free(pth);</a>
<a name="ln324"> </a>
<a name="ln325">          // remember things for the next round</a>
<a name="ln326">          if(last_tokens) g_strfreev(last_tokens);</a>
<a name="ln327">          last_tokens = tokens;</a>
<a name="ln328">          last_parent = parent;</a>
<a name="ln329">          last_tokens_length = tokens_length;</a>
<a name="ln330">        }</a>
<a name="ln331">      }</a>
<a name="ln332">      g_strfreev(last_tokens);</a>
<a name="ln333">    }</a>
<a name="ln334">    if (d-&gt;keyword[0])</a>
<a name="ln335">    {</a>
<a name="ln336">      gtk_tree_model_foreach(store, (GtkTreeModelForeachFunc)set_matching_tag_visibility, self);</a>
<a name="ln337">      gtk_tree_model_foreach(store, (GtkTreeModelForeachFunc)tree_reveal_func, NULL);</a>
<a name="ln338">      gtk_tree_view_set_model(GTK_TREE_VIEW(view), model);</a>
<a name="ln339">      gtk_tree_view_expand_all(d-&gt;dictionary_view);</a>
<a name="ln340">    }</a>
<a name="ln341">    else gtk_tree_view_set_model(GTK_TREE_VIEW(view), model);</a>
<a name="ln342">    g_object_unref(model);</a>
<a name="ln343">  }</a>
<a name="ln344">  else</a>
<a name="ln345">  {</a>
<a name="ln346">    gtk_list_store_clear(GTK_LIST_STORE(store));</a>
<a name="ln347">    if(count &gt; 0 &amp;&amp; tags)</a>
<a name="ln348">    {</a>
<a name="ln349">      for (GList *tag = tags; tag; tag = g_list_next(tag))</a>
<a name="ln350">      {</a>
<a name="ln351">        const char *subtag = g_strrstr(((dt_tag_t *)tag-&gt;data)-&gt;tag, &quot;|&quot;);</a>
<a name="ln352">        gtk_list_store_append(GTK_LIST_STORE(store), &amp;iter);</a>
<a name="ln353">        gtk_list_store_set(GTK_LIST_STORE(store), &amp;iter,</a>
<a name="ln354">                          DT_LIB_TAGGING_COL_TAG, !subtag ? ((dt_tag_t *)tag-&gt;data)-&gt;tag : subtag + 1,</a>
<a name="ln355">                          DT_LIB_TAGGING_COL_ID, ((dt_tag_t *)tag-&gt;data)-&gt;id,</a>
<a name="ln356">                          DT_LIB_TAGGING_COL_PATH, ((dt_tag_t *)tag-&gt;data)-&gt;tag,</a>
<a name="ln357">                          DT_LIB_TAGGING_COL_COUNT, ((dt_tag_t *)tag-&gt;data)-&gt;count,</a>
<a name="ln358">                          DT_LIB_TAGGING_COL_SEL, ((dt_tag_t *)tag-&gt;data)-&gt;select,</a>
<a name="ln359">                          DT_LIB_TAGGING_COL_FLAGS, ((dt_tag_t *)tag-&gt;data)-&gt;flags,</a>
<a name="ln360">                          DT_LIB_TAGGING_COL_SYNONYM, ((dt_tag_t *)tag-&gt;data)-&gt;synonym,</a>
<a name="ln361">                          DT_LIB_TAGGING_COL_VISIBLE, TRUE,</a>
<a name="ln362">                          -1);</a>
<a name="ln363">      }</a>
<a name="ln364">    }</a>
<a name="ln365">    if (which &amp;&amp; d-&gt;keyword[0])</a>
<a name="ln366">    {</a>
<a name="ln367">      gtk_tree_model_foreach(store, (GtkTreeModelForeachFunc)set_matching_tag_visibility, self);</a>
<a name="ln368">    }</a>
<a name="ln369">    gtk_tree_view_set_model(GTK_TREE_VIEW(view), model);</a>
<a name="ln370">    g_object_unref(model);</a>
<a name="ln371">  }</a>
<a name="ln372">  if (which)</a>
<a name="ln373">    sort_dictionary_list(self, FALSE);</a>
<a name="ln374">  else</a>
<a name="ln375">    sort_attached_list(self, FALSE);</a>
<a name="ln376">  // Free result...</a>
<a name="ln377">  dt_tag_free_result(&amp;tags);</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">void tree_tagname_show(GtkTreeViewColumn *col, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter,</a>
<a name="ln381">                     gpointer data, gboolean dictionary_view)</a>
<a name="ln382">{</a>
<a name="ln383">  dt_lib_module_t *self = (dt_lib_module_t *)data;</a>
<a name="ln384">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln385">  guint id;</a>
<a name="ln386">  gchar *name;</a>
<a name="ln387">  gchar *path;</a>
<a name="ln388">  guint count;</a>
<a name="ln389">  gchar *coltext;</a>
<a name="ln390">  gint flags;</a>
<a name="ln391"> </a>
<a name="ln392">  gtk_tree_model_get(model, iter, DT_LIB_TAGGING_COL_ID, &amp;id, DT_LIB_TAGGING_COL_TAG, &amp;name,</a>
<a name="ln393">                  DT_LIB_TAGGING_COL_COUNT, &amp;count, DT_LIB_TAGGING_COL_FLAGS, &amp;flags,</a>
<a name="ln394">                  DT_LIB_TAGGING_COL_PATH, &amp;path, -1);</a>
<a name="ln395">  const gboolean hide = dictionary_view ? (d-&gt;tree_flag ? TRUE : d-&gt;hide_path_flag) : d-&gt;hide_path_flag;</a>
<a name="ln396">  const gboolean istag = id &amp;&amp; !(flags &amp; DT_TF_CATEGORY);</a>
<a name="ln397">  if ((dictionary_view &amp;&amp; !count) || (!dictionary_view &amp;&amp; count &lt;= 1))</a>
<a name="ln398">  {</a>
<a name="ln399">    coltext = g_markup_printf_escaped(istag ? &quot;%s&quot; : &quot;&lt;i&gt;%s&lt;/i&gt;&quot;, hide ? name : path);</a>
<a name="ln400">  }</a>
<a name="ln401">  else</a>
<a name="ln402">  {</a>
<a name="ln403">    coltext = g_markup_printf_escaped(istag ? &quot;%s (%d)&quot; : &quot;&lt;i&gt;%s&lt;/i&gt; (%d)&quot;, hide ? name : path, count);</a>
<a name="ln404">  }</a>
<a name="ln405">  g_object_set(renderer, &quot;markup&quot;, coltext, NULL);</a>
<a name="ln406">  g_free(coltext);</a>
<a name="ln407">  g_free(name);</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">void tree_tagname_show_attached(GtkTreeViewColumn *col, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter,</a>
<a name="ln411">                     gpointer data)</a>
<a name="ln412">{</a>
<a name="ln413">  tree_tagname_show(col, renderer, model, iter, data, 0);</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">void tree_tagname_show_dictionary(GtkTreeViewColumn *col, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter,</a>
<a name="ln417">                     gpointer data)</a>
<a name="ln418">{</a>
<a name="ln419">  tree_tagname_show(col, renderer, model, iter, data, 1);</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">void tree_select_show(GtkTreeViewColumn *col, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter,</a>
<a name="ln423">                     gpointer data)</a>
<a name="ln424">{</a>
<a name="ln425">  guint id;</a>
<a name="ln426">  guint select;</a>
<a name="ln427">  gboolean active = FALSE;</a>
<a name="ln428">  gboolean inconsistent = FALSE;</a>
<a name="ln429"> </a>
<a name="ln430">  gtk_tree_model_get(model, iter, DT_LIB_TAGGING_COL_ID, &amp;id, DT_LIB_TAGGING_COL_SEL, &amp;select, -1);</a>
<a name="ln431">  if (!id)</a>
<a name="ln432">  {</a>
<a name="ln433">    if (select) inconsistent = TRUE;</a>
<a name="ln434">  }</a>
<a name="ln435">  else</a>
<a name="ln436">  {</a>
<a name="ln437">    if (select == 2) active = TRUE;</a>
<a name="ln438">    else if (select == 1) inconsistent = TRUE;</a>
<a name="ln439">  }</a>
<a name="ln440">  g_object_set(renderer, &quot;active&quot;, active, &quot;inconsistent&quot;, inconsistent, NULL);</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">static void _lib_tagging_redraw_callback(gpointer instance, dt_lib_module_t *self)</a>
<a name="ln444">{</a>
<a name="ln445">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln446">  int imgsel = dt_control_get_mouse_over_id();</a>
<a name="ln447">  if(imgsel != d-&gt;imgsel)</a>
<a name="ln448">  {</a>
<a name="ln449">    init_treeview(self, 0);</a>
<a name="ln450">  }</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">static void _lib_tagging_tags_changed_callback(gpointer instance, dt_lib_module_t *self)</a>
<a name="ln454">{</a>
<a name="ln455">  init_treeview(self, 0);</a>
<a name="ln456">  init_treeview(self, 1);</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">static void collection_updated_callback(gpointer instance, dt_lib_module_t *self)</a>
<a name="ln460">{</a>
<a name="ln461">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln462">  d-&gt;collection[0] = '\0';</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">static void raise_signal_tag_changed(dt_lib_module_t *self)</a>
<a name="ln466">{</a>
<a name="ln467">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln468">  // when collection is on tag any attach &amp; detach becomes very slow</a>
<a name="ln469">  // speeding up when jumping from tag collection to the other</a>
<a name="ln470">  // the cost is that tag collection doesn't reflect the tag changes real time</a>
<a name="ln471">  if (!d-&gt;collection[0])</a>
<a name="ln472">  {</a>
<a name="ln473">    // raises change only for other modules</a>
<a name="ln474">    dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(collection_updated_callback), self);</a>
<a name="ln475">    dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(_lib_tagging_tags_changed_callback), self);</a>
<a name="ln476">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln477">    dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(_lib_tagging_tags_changed_callback), self);</a>
<a name="ln478">    dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(collection_updated_callback), self);</a>
<a name="ln479">  }</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">// find a tag on the tree</a>
<a name="ln483">static gboolean find_tag_iter_tagid(GtkTreeModel *model, GtkTreeIter *iter, gint tagid)</a>
<a name="ln484">{</a>
<a name="ln485">  gint tag;</a>
<a name="ln486">  do</a>
<a name="ln487">  {</a>
<a name="ln488">    gtk_tree_model_get(model, iter, DT_LIB_TAGGING_COL_ID, &amp;tag, -1);</a>
<a name="ln489">    if (tag == tagid)</a>
<a name="ln490">    {</a>
<a name="ln491">      return TRUE;</a>
<a name="ln492">    }</a>
<a name="ln493">    GtkTreeIter child, parent = *iter;</a>
<a name="ln494">    if (gtk_tree_model_iter_children(model, &amp;child, &amp;parent))</a>
<a name="ln495">      if (find_tag_iter_tagid(model, &amp;child, tagid))</a>
<a name="ln496">      {</a>
<a name="ln497">        *iter = child;</a>
<a name="ln498">        return TRUE;</a>
<a name="ln499">      }</a>
<a name="ln500">  } while (gtk_tree_model_iter_next(model, iter));</a>
<a name="ln501">  return FALSE;</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">// calculate the indeterminated state (1) where needed on the tree</a>
<a name="ln505">static void calculate_sel_on_path(GtkTreeModel *model, GtkTreeIter *iter, gboolean root)</a>
<a name="ln506">{</a>
<a name="ln507">  GtkTreeIter child, parent = *iter;</a>
<a name="ln508">  do</a>
<a name="ln509">  {</a>
<a name="ln510">    gint sel = 0;</a>
<a name="ln511">    gtk_tree_model_get(model, &amp;parent, DT_LIB_TAGGING_COL_SEL, &amp;sel, -1);</a>
<a name="ln512">    if (sel == 2)</a>
<a name="ln513">    {</a>
<a name="ln514">      propagate_sel_to_parents(model, &amp;parent);</a>
<a name="ln515">    }</a>
<a name="ln516">    if (gtk_tree_model_iter_children(model, &amp;child, &amp;parent))</a>
<a name="ln517">      calculate_sel_on_path(model, &amp;child, FALSE);</a>
<a name="ln518">  } while (!root &amp;&amp; gtk_tree_model_iter_next(model, &amp;parent));</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521">// reset the indeterminated selection (1) on the tree</a>
<a name="ln522">static void reset_sel_on_path(GtkTreeModel *model, GtkTreeIter *iter, gboolean root)</a>
<a name="ln523">{</a>
<a name="ln524">  GtkTreeIter child, parent = *iter;</a>
<a name="ln525">  do</a>
<a name="ln526">  {</a>
<a name="ln527">    if (gtk_tree_model_iter_children(model, &amp;child, &amp;parent))</a>
<a name="ln528">    {</a>
<a name="ln529">      gint sel = 0;</a>
<a name="ln530">      gtk_tree_model_get(model, &amp;parent, DT_LIB_TAGGING_COL_SEL, &amp;sel, -1);</a>
<a name="ln531">      if (sel == 1)</a>
<a name="ln532">      {</a>
<a name="ln533">        gtk_tree_store_set(GTK_TREE_STORE(model), &amp;parent, DT_LIB_TAGGING_COL_SEL, 0, -1);</a>
<a name="ln534">      }</a>
<a name="ln535">      reset_sel_on_path(model, &amp;child, FALSE);</a>
<a name="ln536">    }</a>
<a name="ln537">  } while (!root &amp;&amp; gtk_tree_model_iter_next(model, &amp;parent));</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">// reset all selection (1 &amp; 2) on the tree</a>
<a name="ln541">static void reset_sel_on_path_full(GtkTreeModel *model, GtkTreeIter *iter, gboolean root)</a>
<a name="ln542">{</a>
<a name="ln543">  GtkTreeIter child, parent = *iter;</a>
<a name="ln544">  do</a>
<a name="ln545">  {</a>
<a name="ln546">    if(GTK_IS_TREE_STORE(model))</a>
<a name="ln547">    {</a>
<a name="ln548">      gtk_tree_store_set(GTK_TREE_STORE(model), &amp;parent, DT_LIB_TAGGING_COL_SEL, 0, -1);</a>
<a name="ln549">      if (gtk_tree_model_iter_children(model, &amp;child, &amp;parent))</a>
<a name="ln550">        reset_sel_on_path_full(model, &amp;child, FALSE);</a>
<a name="ln551">    }</a>
<a name="ln552">    else</a>
<a name="ln553">    {</a>
<a name="ln554">      gtk_list_store_set(GTK_LIST_STORE(model), &amp;parent, DT_LIB_TAGGING_COL_SEL, 0, -1);</a>
<a name="ln555">    }</a>
<a name="ln556">  } while (!root &amp;&amp; gtk_tree_model_iter_next(model, &amp;parent));</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">//  try to find a node fully attached (2) which is the root of the update loop. If not the full tree will be used</a>
<a name="ln560">static void find_root_iter_iter(GtkTreeModel *model, GtkTreeIter *iter, GtkTreeIter *parent)</a>
<a name="ln561">{</a>
<a name="ln562">  guint sel;</a>
<a name="ln563">  GtkTreeIter child = *iter;</a>
<a name="ln564">  while (gtk_tree_model_iter_parent(model, parent, &amp;child))</a>
<a name="ln565">  {</a>
<a name="ln566">    gtk_tree_model_get(model, parent, DT_LIB_TAGGING_COL_SEL, &amp;sel, -1);</a>
<a name="ln567">    if (sel == 2)</a>
<a name="ln568">    {</a>
<a name="ln569">      char *path = NULL;</a>
<a name="ln570">      gtk_tree_model_get(model, parent, DT_LIB_TAGGING_COL_PATH, &amp;path, -1);</a>
<a name="ln571">      g_free(path);</a>
<a name="ln572">      return; // no need to go further</a>
<a name="ln573">    }</a>
<a name="ln574">    child = *parent;</a>
<a name="ln575">  }</a>
<a name="ln576">  *parent = child;  // last before root</a>
<a name="ln577">  char *path = NULL;</a>
<a name="ln578">  gtk_tree_model_get(model, parent, DT_LIB_TAGGING_COL_PATH, &amp;path, -1);</a>
<a name="ln579">  g_free(path);</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">// with tag detach update the tree selection</a>
<a name="ln583">static void calculate_sel_on_tree(GtkTreeModel *model, GtkTreeIter *iter)</a>
<a name="ln584">{</a>
<a name="ln585">  GtkTreeIter parent;</a>
<a name="ln586">  if (iter)</a>
<a name="ln587">  {</a>
<a name="ln588">    // only on sub-tree</a>
<a name="ln589">    find_root_iter_iter(model, iter, &amp;parent);</a>
<a name="ln590">    reset_sel_on_path(model, &amp;parent, TRUE);</a>
<a name="ln591">    calculate_sel_on_path(model, &amp;parent, TRUE);</a>
<a name="ln592">  }</a>
<a name="ln593">  else</a>
<a name="ln594">  {</a>
<a name="ln595">    // on full tree</a>
<a name="ln596">    gtk_tree_model_get_iter_first(model, &amp;parent);</a>
<a name="ln597">    reset_sel_on_path(model, &amp;parent, FALSE);</a>
<a name="ln598">    calculate_sel_on_path(model, &amp;parent, FALSE);</a>
<a name="ln599">  }</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">// get the new selected images and update the tree selection</a>
<a name="ln603">static void update_sel_on_tree(GtkTreeModel *model)</a>
<a name="ln604">{</a>
<a name="ln605">  GList *tags = NULL;</a>
<a name="ln606">  const guint count = dt_tag_get_attached(-1, &amp;tags, TRUE);</a>
<a name="ln607">  if(count &gt; 0 &amp;&amp; tags)</a>
<a name="ln608">  {</a>
<a name="ln609">    GtkTreeIter parent;</a>
<a name="ln610">    gtk_tree_model_get_iter_first(model, &amp;parent);</a>
<a name="ln611">    reset_sel_on_path_full(model, &amp;parent, FALSE);</a>
<a name="ln612">    for (GList *tag = tags; tag; tag = g_list_next(tag))</a>
<a name="ln613">    {</a>
<a name="ln614">      GtkTreeIter iter = parent;</a>
<a name="ln615">      if (find_tag_iter_tagid(model, &amp;iter, ((dt_tag_t *)tag-&gt;data)-&gt;id))</a>
<a name="ln616">      {</a>
<a name="ln617">        if(GTK_IS_TREE_STORE(model))</a>
<a name="ln618">        {</a>
<a name="ln619">          gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, DT_LIB_TAGGING_COL_SEL, ((dt_tag_t *)tag-&gt;data)-&gt;select, -1);</a>
<a name="ln620">          propagate_sel_to_parents(model, &amp;iter);</a>
<a name="ln621">        }</a>
<a name="ln622">        else</a>
<a name="ln623">        {</a>
<a name="ln624">          gtk_list_store_set(GTK_LIST_STORE(model), &amp;iter, DT_LIB_TAGGING_COL_SEL, ((dt_tag_t *)tag-&gt;data)-&gt;select, -1);</a>
<a name="ln625">        }</a>
<a name="ln626">      }</a>
<a name="ln627">    }</a>
<a name="ln628">  }</a>
<a name="ln629">  dt_tag_free_result(&amp;tags);</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">// delete a tag in the tree (tree or list)</a>
<a name="ln633">static void delete_tree_tag(GtkTreeModel *model, GtkTreeIter *iter, gboolean tree)</a>
<a name="ln634">{</a>
<a name="ln635">  guint tagid = 0;</a>
<a name="ln636">  gtk_tree_model_get(model, iter, DT_LIB_TAGGING_COL_ID, &amp;tagid, -1);</a>
<a name="ln637">  if (tree)</a>
<a name="ln638">  {</a>
<a name="ln639">    if (tagid)</a>
<a name="ln640">    {</a>
<a name="ln641">      gtk_tree_store_set(GTK_TREE_STORE(model), iter, DT_LIB_TAGGING_COL_SEL, 0,</a>
<a name="ln642">          DT_LIB_TAGGING_COL_ID, 0, DT_LIB_TAGGING_COL_COUNT, 0, -1);</a>
<a name="ln643">      calculate_sel_on_tree(model, iter);</a>
<a name="ln644">      GtkTreeIter child, parent = *iter;</a>
<a name="ln645">      if (!gtk_tree_model_iter_children(model, &amp;child, &amp;parent))</a>
<a name="ln646">        gtk_tree_store_remove(GTK_TREE_STORE(model), iter);</a>
<a name="ln647">    }</a>
<a name="ln648">  }</a>
<a name="ln649">  else</a>
<a name="ln650">  {</a>
<a name="ln651">    gtk_list_store_remove(GTK_LIST_STORE(model), iter);</a>
<a name="ln652">  }</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">// delete a branch of the tag tree</a>
<a name="ln656">static void delete_tree_path(GtkTreeModel *model, GtkTreeIter *iter, gboolean root, gboolean tree)</a>
<a name="ln657">{</a>
<a name="ln658">  if (tree) // the treeview is tree. It handles the hierarchy itself (parent / child)</a>
<a name="ln659">  {</a>
<a name="ln660">    GtkTreeIter child, parent = *iter;</a>
<a name="ln661">    gboolean valid = TRUE;</a>
<a name="ln662">    do</a>
<a name="ln663">    {</a>
<a name="ln664">      if (gtk_tree_model_iter_children(model, &amp;child, &amp;parent))</a>
<a name="ln665">        delete_tree_path(model, &amp;child, FALSE, tree);</a>
<a name="ln666">      GtkTreeIter tobedel = parent;</a>
<a name="ln667">      valid = gtk_tree_model_iter_next(model, &amp;parent);</a>
<a name="ln668">      if (root)</a>
<a name="ln669">      {</a>
<a name="ln670">        gtk_tree_store_set(GTK_TREE_STORE(model), &amp;tobedel, DT_LIB_TAGGING_COL_SEL, 0,</a>
<a name="ln671">            DT_LIB_TAGGING_COL_COUNT, 0, -1);</a>
<a name="ln672"> </a>
<a name="ln673">        char *path2 = NULL;</a>
<a name="ln674">        gtk_tree_model_get(model, &amp;tobedel, DT_LIB_TAGGING_COL_PATH, &amp;path2, -1);</a>
<a name="ln675">        g_free(path2);</a>
<a name="ln676"> </a>
<a name="ln677">        calculate_sel_on_tree(model, &amp;tobedel);</a>
<a name="ln678">      }</a>
<a name="ln679">      char *path = NULL;</a>
<a name="ln680">      gtk_tree_model_get(model, &amp;tobedel, DT_LIB_TAGGING_COL_PATH, &amp;path, -1);</a>
<a name="ln681">      g_free(path);</a>
<a name="ln682">      gtk_tree_store_remove(GTK_TREE_STORE(model), &amp;tobedel);</a>
<a name="ln683">    } while (!root &amp;&amp; valid);</a>
<a name="ln684">  }</a>
<a name="ln685">  else  // treeview is a list. The hierarchy of tags is found with the root (left part) of tagname</a>
<a name="ln686">  {</a>
<a name="ln687">    GtkTreeIter child;</a>
<a name="ln688">    char *path = NULL;</a>
<a name="ln689">    gtk_tree_model_get(model, iter, DT_LIB_TAGGING_COL_PATH, &amp;path, -1);</a>
<a name="ln690">    guint pathlen = strlen(path);</a>
<a name="ln691">    gboolean valid = gtk_tree_model_get_iter_first(model, &amp;child);</a>
<a name="ln692">    while(valid)</a>
<a name="ln693">    {</a>
<a name="ln694">      char *path2 = NULL;</a>
<a name="ln695">      gtk_tree_model_get(model, &amp;child, DT_LIB_TAGGING_COL_PATH, &amp;path2, -1);</a>
<a name="ln696">      GtkTreeIter tobedel = child;</a>
<a name="ln697">      valid = gtk_tree_model_iter_next (model, &amp;child);</a>
<a name="ln698">      if (strlen(path2) &gt;= pathlen)</a>
<a name="ln699">      {</a>
<a name="ln700">        char letter = path2[pathlen];</a>
<a name="ln701">        path2[pathlen] = '\0';</a>
<a name="ln702">        if (g_strcmp0(path, path2) == 0)</a>
<a name="ln703">        {</a>
<a name="ln704">          path2[pathlen] = letter;</a>
<a name="ln705">          gtk_list_store_remove(GTK_LIST_STORE(model), &amp;tobedel);</a>
<a name="ln706">        }</a>
<a name="ln707">      }</a>
<a name="ln708">      g_free(path2);</a>
<a name="ln709">    }</a>
<a name="ln710">    g_free(path);</a>
<a name="ln711">  }</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">static void _lib_selection_changed_callback(gpointer instance, dt_lib_module_t *self)</a>
<a name="ln715">{</a>
<a name="ln716">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln717">  init_treeview(self, 0);</a>
<a name="ln718">  if (!d-&gt;tree_flag &amp;&amp; d-&gt;suggestion_flag)</a>
<a name="ln719">  {</a>
<a name="ln720">    init_treeview(self, 1);</a>
<a name="ln721">  }</a>
<a name="ln722">  else</a>
<a name="ln723">    update_sel_on_tree(d-&gt;tree_flag ? GTK_TREE_MODEL(d-&gt;dictionary_treestore)</a>
<a name="ln724">                                    : GTK_TREE_MODEL(d-&gt;dictionary_liststore));</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">static void set_keyword(dt_lib_module_t *self)</a>
<a name="ln728">{</a>
<a name="ln729">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln730">  const gchar *beg = g_strrstr(gtk_entry_get_text(d-&gt;entry), &quot;,&quot;);</a>
<a name="ln731"> </a>
<a name="ln732">  if(!beg)</a>
<a name="ln733">    beg = gtk_entry_get_text(d-&gt;entry);</a>
<a name="ln734">  else</a>
<a name="ln735">  {</a>
<a name="ln736">    if(*beg == ',') beg++;</a>
<a name="ln737">    if(*beg == ' ') beg++;</a>
<a name="ln738">  }</a>
<a name="ln739">  snprintf(d-&gt;keyword, sizeof(d-&gt;keyword), &quot;%s&quot;, beg);</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">static gboolean update_tag_name_per_id(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, dt_tag_op_t *to)</a>
<a name="ln743">{</a>
<a name="ln744">  gint tag;</a>
<a name="ln745">  gtk_tree_model_get(model, iter, DT_LIB_TAGGING_COL_ID, &amp;tag, -1);</a>
<a name="ln746">  if (tag == to-&gt;tagid)</a>
<a name="ln747">  {</a>
<a name="ln748">    char *newtagname = to-&gt;newtagname;</a>
<a name="ln749">    if (!to-&gt;suggestion_flag)</a>
<a name="ln750">    {</a>
<a name="ln751">      if (!to-&gt;tree_flag)</a>
<a name="ln752">      {</a>
<a name="ln753">        gtk_list_store_set(GTK_LIST_STORE(model), iter, DT_LIB_TAGGING_COL_PATH, newtagname,</a>
<a name="ln754">                                    DT_LIB_TAGGING_COL_TAG, newtagname, -1);</a>
<a name="ln755">      }</a>
<a name="ln756">      else</a>
<a name="ln757">      {</a>
<a name="ln758">        char *subtag = g_strrstr(to-&gt;newtagname, &quot;|&quot;);</a>
<a name="ln759">        subtag = (!subtag) ? newtagname : subtag + 1;</a>
<a name="ln760">        gtk_tree_store_set(GTK_TREE_STORE(model), iter, DT_LIB_TAGGING_COL_PATH, newtagname,</a>
<a name="ln761">                                    DT_LIB_TAGGING_COL_TAG, subtag, -1);</a>
<a name="ln762">      }</a>
<a name="ln763">    }</a>
<a name="ln764">    return TRUE;</a>
<a name="ln765">  }</a>
<a name="ln766">  return FALSE;</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">static gboolean update_tag_name_per_name(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, dt_tag_op_t *to)</a>
<a name="ln770">{</a>
<a name="ln771">  char *tagname;</a>
<a name="ln772">  char *newtagname = to-&gt;newtagname;</a>
<a name="ln773">  char *oldtagname = to-&gt;oldtagname;</a>
<a name="ln774">  gtk_tree_model_get(model, iter, DT_LIB_TAGGING_COL_PATH, &amp;tagname, -1);</a>
<a name="ln775">  if (g_strcmp0(tagname, oldtagname) == 0)</a>
<a name="ln776">  {</a>
<a name="ln777">    char *subtag = g_strrstr(to-&gt;newtagname, &quot;|&quot;);</a>
<a name="ln778">    subtag = (!subtag) ? newtagname : subtag + 1;</a>
<a name="ln779">    gtk_tree_store_set(GTK_TREE_STORE(model), iter, DT_LIB_TAGGING_COL_PATH, newtagname,</a>
<a name="ln780">                                DT_LIB_TAGGING_COL_TAG, subtag, -1);</a>
<a name="ln781">    g_free(tagname);</a>
<a name="ln782">    return TRUE;</a>
<a name="ln783">  }</a>
<a name="ln784">  g_free(tagname);</a>
<a name="ln785">  return FALSE;</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788">void init_presets(dt_lib_module_t *self)</a>
<a name="ln789">{</a>
<a name="ln790"> </a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793">void *get_params(dt_lib_module_t *self, int *size)</a>
<a name="ln794">{</a>
<a name="ln795">  char *params = NULL;</a>
<a name="ln796">  *size = 0;</a>
<a name="ln797">  GList *tags = NULL;</a>
<a name="ln798">  const guint count = dt_tag_get_attached(-1, &amp;tags, TRUE);</a>
<a name="ln799"> </a>
<a name="ln800">  if(count)</a>
<a name="ln801">  {</a>
<a name="ln802">    for(GList *taglist = tags; taglist; taglist = g_list_next(taglist))</a>
<a name="ln803">    {</a>
<a name="ln804">      params = dt_util_dstrcat(params, &quot;%d,&quot;, ((dt_tag_t *)taglist-&gt;data)-&gt;id);</a>
<a name="ln805">    }</a>
<a name="ln806">    dt_tag_free_result(&amp;tags);</a>
<a name="ln807">    *size = strlen(params);</a>
<a name="ln808">    params[*size-1]='\0';</a>
<a name="ln809">  }</a>
<a name="ln810">  return params;</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">int set_params(dt_lib_module_t *self, const void *params, int size)</a>
<a name="ln814">{</a>
<a name="ln815">  if(!params || !size) return 1;</a>
<a name="ln816">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln817"> </a>
<a name="ln818">  const char *buf = (char *)params;</a>
<a name="ln819">  if (buf &amp;&amp; buf[0])</a>
<a name="ln820">  {</a>
<a name="ln821">    GtkTreeModel *model = gtk_tree_view_get_model(d-&gt;dictionary_view);</a>
<a name="ln822">    GtkTreeModel *store = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model));</a>
<a name="ln823">    GtkTreeIter iter;</a>
<a name="ln824">    const int imgsel = dt_view_get_image_to_act_on();</a>
<a name="ln825">    gchar **tokens = g_strsplit(buf, &quot;,&quot;, 0);</a>
<a name="ln826">    if(tokens)</a>
<a name="ln827">    {</a>
<a name="ln828">      gchar **entry = tokens;</a>
<a name="ln829">      while(*entry)</a>
<a name="ln830">      {</a>
<a name="ln831">        guint tagid = strtoul(*entry, NULL, 0);</a>
<a name="ln832"> </a>
<a name="ln833">        dt_tag_attach(tagid, imgsel);</a>
<a name="ln834"> </a>
<a name="ln835">        const guint count = dt_tag_images_count(tagid);</a>
<a name="ln836">        gtk_tree_model_get_iter_first(store, &amp;iter);</a>
<a name="ln837">        if (find_tag_iter_tagid(store, &amp;iter, tagid))</a>
<a name="ln838">        {</a>
<a name="ln839">          if (d-&gt;tree_flag)</a>
<a name="ln840">          {</a>
<a name="ln841">            gtk_tree_store_set(GTK_TREE_STORE(store), &amp;iter, DT_LIB_TAGGING_COL_COUNT, count,</a>
<a name="ln842">                                    DT_LIB_TAGGING_COL_SEL, 2, -1);</a>
<a name="ln843">            calculate_sel_on_tree(GTK_TREE_MODEL(store), &amp;iter);</a>
<a name="ln844">          }</a>
<a name="ln845">          else</a>
<a name="ln846">          {</a>
<a name="ln847">            gtk_list_store_set(GTK_LIST_STORE(store), &amp;iter, DT_LIB_TAGGING_COL_COUNT, count,</a>
<a name="ln848">                                    DT_LIB_TAGGING_COL_SEL, 2, -1);</a>
<a name="ln849">          }</a>
<a name="ln850">        }</a>
<a name="ln851">        entry++;</a>
<a name="ln852">      }</a>
<a name="ln853">    }</a>
<a name="ln854">    g_strfreev(tokens);</a>
<a name="ln855">    init_treeview(self, 0);</a>
<a name="ln856"> </a>
<a name="ln857">    raise_signal_tag_changed(self);</a>
<a name="ln858">    dt_image_synch_xmp(imgsel);</a>
<a name="ln859">  }</a>
<a name="ln860">  return 0;</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">static void attach_selected_tag(dt_lib_module_t *self, dt_lib_tagging_t *d)</a>
<a name="ln864">{</a>
<a name="ln865">  GtkTreeIter iter;</a>
<a name="ln866">  GtkTreeModel *model = NULL;</a>
<a name="ln867">  GtkTreeSelection *selection = gtk_tree_view_get_selection(d-&gt;dictionary_view);</a>
<a name="ln868">  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)</a>
<a name="ln869">     &amp;&amp; !gtk_tree_model_get_iter_first(model, &amp;iter))</a>
<a name="ln870">    return;</a>
<a name="ln871">  guint tagid;</a>
<a name="ln872">  gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_ID, &amp;tagid, -1);</a>
<a name="ln873"> </a>
<a name="ln874">  int imgsel = -1;</a>
<a name="ln875">  if(tagid &lt;= 0) return;</a>
<a name="ln876"> </a>
<a name="ln877">  imgsel = dt_view_get_image_to_act_on();</a>
<a name="ln878">  dt_tag_attach(tagid, imgsel);</a>
<a name="ln879"> </a>
<a name="ln880">  init_treeview(self, 0);</a>
<a name="ln881">  if (d-&gt;tree_flag || !d-&gt;suggestion_flag)</a>
<a name="ln882">  {</a>
<a name="ln883">    const uint32_t count = dt_tag_images_count(tagid);</a>
<a name="ln884">    GtkTreeIter store_iter;</a>
<a name="ln885">    GtkTreeModel *store = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model));</a>
<a name="ln886">    gtk_tree_model_filter_convert_iter_to_child_iter(GTK_TREE_MODEL_FILTER(model),</a>
<a name="ln887">                              &amp;store_iter, &amp;iter);</a>
<a name="ln888">    if (d-&gt;tree_flag)</a>
<a name="ln889">    {</a>
<a name="ln890">      gtk_tree_store_set(GTK_TREE_STORE(store), &amp;store_iter, DT_LIB_TAGGING_COL_COUNT, count,</a>
<a name="ln891">                DT_LIB_TAGGING_COL_SEL, 2, -1);</a>
<a name="ln892">      propagate_sel_to_parents(GTK_TREE_MODEL(store), &amp;store_iter);</a>
<a name="ln893">    }</a>
<a name="ln894">    else</a>
<a name="ln895">    {</a>
<a name="ln896">      gtk_list_store_set(GTK_LIST_STORE(store), &amp;store_iter, DT_LIB_TAGGING_COL_COUNT, count,</a>
<a name="ln897">                DT_LIB_TAGGING_COL_SEL, 2, -1);</a>
<a name="ln898">    }</a>
<a name="ln899">  }</a>
<a name="ln900">  else</a>
<a name="ln901">  {</a>
<a name="ln902">    init_treeview(self, 1);</a>
<a name="ln903">  }</a>
<a name="ln904">  raise_signal_tag_changed(self);</a>
<a name="ln905">  dt_image_synch_xmp(imgsel);</a>
<a name="ln906">}</a>
<a name="ln907"> </a>
<a name="ln908">static void detach_selected_tag(GtkTreeView *view, dt_lib_module_t *self, dt_lib_tagging_t *d)</a>
<a name="ln909">{</a>
<a name="ln910">  GtkTreeIter iter;</a>
<a name="ln911">  GtkTreeModel *model = NULL;</a>
<a name="ln912">  GtkTreeSelection *selection = gtk_tree_view_get_selection(view);</a>
<a name="ln913">  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)) return;</a>
<a name="ln914">  guint tagid;</a>
<a name="ln915">  gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_ID, &amp;tagid, -1);</a>
<a name="ln916"> </a>
<a name="ln917">  int imgsel = -1;</a>
<a name="ln918">  if(tagid &lt;= 0) return;</a>
<a name="ln919"> </a>
<a name="ln920">  imgsel = dt_view_get_image_to_act_on();</a>
<a name="ln921">  GList *affected_images = dt_tag_get_images_from_selection(imgsel, tagid);</a>
<a name="ln922"> </a>
<a name="ln923">  dt_tag_detach(tagid, imgsel);</a>
<a name="ln924"> </a>
<a name="ln925">  init_treeview(self, 0);</a>
<a name="ln926">  if (d-&gt;tree_flag || !d-&gt;suggestion_flag)</a>
<a name="ln927">  {</a>
<a name="ln928">    const guint count = dt_tag_images_count(tagid);</a>
<a name="ln929">    model = gtk_tree_view_get_model(d-&gt;dictionary_view);</a>
<a name="ln930">    GtkTreeModel *store = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model));</a>
<a name="ln931">    gtk_tree_model_get_iter_first(store, &amp;iter);</a>
<a name="ln932">    if (find_tag_iter_tagid(store, &amp;iter, tagid))</a>
<a name="ln933">    {</a>
<a name="ln934">      if (d-&gt;tree_flag)</a>
<a name="ln935">      {</a>
<a name="ln936">        gtk_tree_store_set(GTK_TREE_STORE(store), &amp;iter, DT_LIB_TAGGING_COL_COUNT, count,</a>
<a name="ln937">                                DT_LIB_TAGGING_COL_SEL, 0, -1);</a>
<a name="ln938">        calculate_sel_on_tree(GTK_TREE_MODEL(store), &amp;iter);</a>
<a name="ln939">      }</a>
<a name="ln940">      else</a>
<a name="ln941">      {</a>
<a name="ln942">        gtk_list_store_set(GTK_LIST_STORE(store), &amp;iter, DT_LIB_TAGGING_COL_COUNT, count,</a>
<a name="ln943">                                DT_LIB_TAGGING_COL_SEL, 0, -1);</a>
<a name="ln944">      }</a>
<a name="ln945">    }</a>
<a name="ln946">  }</a>
<a name="ln947">  else</a>
<a name="ln948">  {</a>
<a name="ln949">    init_treeview(self, 1);</a>
<a name="ln950">  }</a>
<a name="ln951">  raise_signal_tag_changed(self);</a>
<a name="ln952"> </a>
<a name="ln953">  // we have to check the conf option as dt_image_synch_xmp() doesn't when called for a single image</a>
<a name="ln954">  if(dt_conf_get_bool(&quot;write_sidecar_files&quot;))</a>
<a name="ln955">  {</a>
<a name="ln956">    for(GList *image_iter = affected_images; image_iter; image_iter = g_list_next(image_iter))</a>
<a name="ln957">    {</a>
<a name="ln958">      int imgid = GPOINTER_TO_INT(image_iter-&gt;data);</a>
<a name="ln959">      dt_image_synch_xmp(imgid);</a>
<a name="ln960">    }</a>
<a name="ln961">  }</a>
<a name="ln962">  g_list_free(affected_images);</a>
<a name="ln963">}</a>
<a name="ln964"> </a>
<a name="ln965">static void attach_button_clicked(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln966">{</a>
<a name="ln967">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln968">  attach_selected_tag(self, d);</a>
<a name="ln969">}</a>
<a name="ln970"> </a>
<a name="ln971">static void detach_button_clicked(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln972">{</a>
<a name="ln973">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln974">  detach_selected_tag(d-&gt;attached_view, self, d);</a>
<a name="ln975">}</a>
<a name="ln976"> </a>
<a name="ln977">static void pop_menu_attached_attach_to_all(GtkWidget *menuitem, dt_lib_module_t *self)</a>
<a name="ln978">{</a>
<a name="ln979">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln980">  GtkTreeIter iter;</a>
<a name="ln981">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(d-&gt;attached_view));</a>
<a name="ln982">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(d-&gt;attached_view));</a>
<a name="ln983">  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln984">    return;</a>
<a name="ln985">  guint tagid;</a>
<a name="ln986">  gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_ID, &amp;tagid, -1);</a>
<a name="ln987"> </a>
<a name="ln988">  int imgsel = -1;</a>
<a name="ln989">  if(tagid &lt;= 0) return;</a>
<a name="ln990"> </a>
<a name="ln991">  imgsel = dt_view_get_image_to_act_on();</a>
<a name="ln992">  dt_tag_attach(tagid, imgsel);</a>
<a name="ln993"> </a>
<a name="ln994">  init_treeview(self, 0);</a>
<a name="ln995"> </a>
<a name="ln996">  const uint32_t count = dt_tag_images_count(tagid);</a>
<a name="ln997">  model = gtk_tree_view_get_model(GTK_TREE_VIEW(d-&gt;dictionary_view));</a>
<a name="ln998">  gtk_tree_model_get_iter_first(model, &amp;iter);</a>
<a name="ln999">  if(find_tag_iter_tagid(model, &amp;iter, tagid))</a>
<a name="ln1000">  {</a>
<a name="ln1001">    GtkTreeIter store_iter;</a>
<a name="ln1002">    GtkTreeModel *store = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model));</a>
<a name="ln1003">    gtk_tree_model_filter_convert_iter_to_child_iter(GTK_TREE_MODEL_FILTER(model),</a>
<a name="ln1004">                              &amp;store_iter, &amp;iter);</a>
<a name="ln1005">    if (d-&gt;tree_flag)</a>
<a name="ln1006">    {</a>
<a name="ln1007">      gtk_tree_store_set(GTK_TREE_STORE(store), &amp;store_iter, DT_LIB_TAGGING_COL_COUNT, count, -1);</a>
<a name="ln1008">    }</a>
<a name="ln1009">    else</a>
<a name="ln1010">    {</a>
<a name="ln1011">      gtk_list_store_set(GTK_LIST_STORE(store), &amp;store_iter, DT_LIB_TAGGING_COL_COUNT, count, -1);</a>
<a name="ln1012">    }</a>
<a name="ln1013">  }</a>
<a name="ln1014"> </a>
<a name="ln1015">  raise_signal_tag_changed(self);</a>
<a name="ln1016">  dt_image_synch_xmp(imgsel);</a>
<a name="ln1017">}</a>
<a name="ln1018"> </a>
<a name="ln1019">static void pop_menu_attached_detach(GtkWidget *menuitem, dt_lib_module_t *self)</a>
<a name="ln1020">{</a>
<a name="ln1021">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1022">  detach_selected_tag(d-&gt;attached_view, self, d);</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">static void pop_menu_attached(GtkWidget *treeview, GdkEventButton *event, dt_lib_module_t *self)</a>
<a name="ln1026">{</a>
<a name="ln1027">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1028">  GtkWidget *menu, *menuitem;</a>
<a name="ln1029">  menu = gtk_menu_new();</a>
<a name="ln1030"> </a>
<a name="ln1031">  GtkTreeIter iter;</a>
<a name="ln1032">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(d-&gt;attached_view));</a>
<a name="ln1033">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(d-&gt;attached_view));</a>
<a name="ln1034">  if(gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln1035">  {</a>
<a name="ln1036">    guint sel;</a>
<a name="ln1037">    gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_SEL, &amp;sel, -1);</a>
<a name="ln1038">    if (sel == 1)</a>
<a name="ln1039">    {</a>
<a name="ln1040">      menuitem = gtk_menu_item_new_with_label(_(&quot;attach tag to all&quot;));</a>
<a name="ln1041">      g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)pop_menu_attached_attach_to_all, self);</a>
<a name="ln1042">      gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1043">      menuitem = gtk_separator_menu_item_new();</a>
<a name="ln1044">      gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1045">    }</a>
<a name="ln1046">  }</a>
<a name="ln1047"> </a>
<a name="ln1048">  menuitem = gtk_menu_item_new_with_label(_(&quot;detach tag&quot;));</a>
<a name="ln1049">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1050">  g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)pop_menu_attached_detach, self);</a>
<a name="ln1051"> </a>
<a name="ln1052">  gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln1053"> </a>
<a name="ln1054">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln1055">  gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln1056">#else</a>
<a name="ln1057">  /* Note: event can be NULL here when called from view_onPopupMenu;</a>
<a name="ln1058">   *  gdk_event_get_time() accepts a NULL argument */</a>
<a name="ln1059">  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, (event != NULL) ? event-&gt;button : 0,</a>
<a name="ln1060">                 gdk_event_get_time((GdkEvent *)event));</a>
<a name="ln1061">#endif</a>
<a name="ln1062">}</a>
<a name="ln1063"> </a>
<a name="ln1064">static gboolean click_on_view_attached(GtkWidget *view, GdkEventButton *event, dt_lib_module_t *self)</a>
<a name="ln1065">{</a>
<a name="ln1066">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1067"> </a>
<a name="ln1068">  if((event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3)</a>
<a name="ln1069">    || (event-&gt;type == GDK_2BUTTON_PRESS &amp;&amp; event-&gt;button == 1))</a>
<a name="ln1070">  {</a>
<a name="ln1071">    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln1072">    GtkTreePath *path = NULL;</a>
<a name="ln1073">    // Get tree path for row that was clicked</a>
<a name="ln1074">    if(gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(view), (gint)event-&gt;x, (gint)event-&gt;y, &amp;path, NULL, NULL, NULL))</a>
<a name="ln1075">    {</a>
<a name="ln1076">      gtk_tree_selection_select_path(selection, path);</a>
<a name="ln1077">      if(event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3)</a>
<a name="ln1078">      {</a>
<a name="ln1079">        pop_menu_attached(view, event, self);</a>
<a name="ln1080">        gtk_tree_path_free(path);</a>
<a name="ln1081">        return TRUE;</a>
<a name="ln1082">      }</a>
<a name="ln1083">      else if(event-&gt;type == GDK_2BUTTON_PRESS &amp;&amp; event-&gt;button == 1)</a>
<a name="ln1084">      {</a>
<a name="ln1085">        detach_selected_tag(d-&gt;attached_view, self, d);</a>
<a name="ln1086">        gtk_tree_path_free(path);</a>
<a name="ln1087">        return TRUE;</a>
<a name="ln1088">      }</a>
<a name="ln1089">    }</a>
<a name="ln1090">    gtk_tree_path_free(path);</a>
<a name="ln1091">  }</a>
<a name="ln1092">  return FALSE;</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">static void new_button_clicked(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln1096">{</a>
<a name="ln1097">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1098">  const gchar *tag = gtk_entry_get_text(d-&gt;entry);</a>
<a name="ln1099">  if(!tag || tag[0] == '\0') return;</a>
<a name="ln1100"> </a>
<a name="ln1101">  /** attach tag to selected images  */</a>
<a name="ln1102">  dt_tag_attach_string_list(tag, -1);</a>
<a name="ln1103">  dt_image_synch_xmp(-1);</a>
<a name="ln1104"> </a>
<a name="ln1105">  /** clear input box */</a>
<a name="ln1106">  gtk_entry_set_text(d-&gt;entry, &quot;&quot;);</a>
<a name="ln1107"> </a>
<a name="ln1108">  init_treeview(self, 0);</a>
<a name="ln1109">  init_treeview(self, 1);</a>
<a name="ln1110">  raise_signal_tag_changed(self);</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">static void entry_activated(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln1114">{</a>
<a name="ln1115">  new_button_clicked(NULL, self);</a>
<a name="ln1116">}</a>
<a name="ln1117"> </a>
<a name="ln1118">static void clear_entry_button_callback(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln1119">{</a>
<a name="ln1120">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1121">  /** clear input box */</a>
<a name="ln1122">  gtk_entry_set_text(d-&gt;entry, &quot;&quot;);</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125">static void tag_name_changed(GtkEntry *entry, dt_lib_module_t *self)</a>
<a name="ln1126">{</a>
<a name="ln1127">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1128">  set_keyword(self);</a>
<a name="ln1129">  GtkTreeModel *model = gtk_tree_view_get_model(d-&gt;dictionary_view);</a>
<a name="ln1130">  GtkTreeModel *store = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model));</a>
<a name="ln1131">  gtk_tree_model_foreach(store, (GtkTreeModelForeachFunc)set_matching_tag_visibility, self);</a>
<a name="ln1132">  if (d-&gt;tree_flag &amp;&amp; d-&gt;keyword[0])</a>
<a name="ln1133">  {</a>
<a name="ln1134">    gtk_tree_model_foreach(store, (GtkTreeModelForeachFunc)tree_reveal_func, NULL);</a>
<a name="ln1135">    gtk_tree_view_expand_all(d-&gt;dictionary_view);</a>
<a name="ln1136">  }</a>
<a name="ln1137">}</a>
<a name="ln1138"> </a>
<a name="ln1139">static void pop_menu_dictionary_delete_tag(GtkWidget *menuitem, dt_lib_module_t *self, gboolean branch)</a>
<a name="ln1140">{</a>
<a name="ln1141">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1142"> </a>
<a name="ln1143">  int res = GTK_RESPONSE_YES;</a>
<a name="ln1144"> </a>
<a name="ln1145">  char *tagname;</a>
<a name="ln1146">  gint tagid;</a>
<a name="ln1147">  gchar *text;</a>
<a name="ln1148">  GtkWidget *label;</a>
<a name="ln1149">  GtkTreeIter iter;</a>
<a name="ln1150">  GtkTreeModel *model = NULL;</a>
<a name="ln1151">  GtkTreeView *view = d-&gt;dictionary_view;</a>
<a name="ln1152">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln1153">  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)) return;</a>
<a name="ln1154"> </a>
<a name="ln1155">  gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_PATH, &amp;tagname,</a>
<a name="ln1156">          DT_LIB_TAGGING_COL_ID, &amp;tagid, -1);</a>
<a name="ln1157">  if (!tagid) return;</a>
<a name="ln1158">  const guint img_count = dt_tag_remove(tagid, FALSE);</a>
<a name="ln1159"> </a>
<a name="ln1160">  if (img_count &gt; 0 || dt_conf_get_bool(&quot;plugins/lighttable/tagging/ask_before_delete_tag&quot;))</a>
<a name="ln1161">  {</a>
<a name="ln1162">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1163">    GtkWidget *dialog = gtk_dialog_new_with_buttons(_(&quot;delete tag?&quot;), GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln1164">                                  _(&quot;delete&quot;), GTK_RESPONSE_YES, _(&quot;cancel&quot;), GTK_RESPONSE_NONE, NULL);</a>
<a name="ln1165">    gtk_window_set_default_size(GTK_WINDOW(dialog), 300, -1);</a>
<a name="ln1166">    GtkWidget *area = gtk_dialog_get_content_area(GTK_DIALOG(dialog));</a>
<a name="ln1167">    GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 8);</a>
<a name="ln1168">    gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);</a>
<a name="ln1169">    gtk_container_add(GTK_CONTAINER(area), vbox);</a>
<a name="ln1170">    text = g_strdup_printf(_(&quot;tag: %s &quot;), tagname);</a>
<a name="ln1171">    label = gtk_label_new(text);</a>
<a name="ln1172">    gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, TRUE, 0);</a>
<a name="ln1173">    g_free(text);</a>
<a name="ln1174"> </a>
<a name="ln1175">    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln1176">    gtk_box_pack_start(GTK_BOX(vbox), box, FALSE, TRUE, 0);</a>
<a name="ln1177">    text = g_strdup_printf(ngettext(&quot;do you really want to delete the tag `%s'?\n%d image is assigned this tag!&quot;,</a>
<a name="ln1178">             &quot;do you really want to delete the tag `%s'?\n%d images are assigned this tag!&quot;, img_count), tagname, img_count);</a>
<a name="ln1179">    label = gtk_label_new(NULL);</a>
<a name="ln1180">    gtk_label_set_markup(GTK_LABEL(label), text);</a>
<a name="ln1181">    gtk_box_pack_start(GTK_BOX(box), label, FALSE, TRUE, 0);</a>
<a name="ln1182">    g_free(text);</a>
<a name="ln1183"> </a>
<a name="ln1184">  #ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1185">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1186">  #endif</a>
<a name="ln1187">    gtk_widget_show_all(dialog);</a>
<a name="ln1188"> </a>
<a name="ln1189">    res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1190">    gtk_widget_destroy(dialog);</a>
<a name="ln1191">  }</a>
<a name="ln1192">  if(res != GTK_RESPONSE_YES)</a>
<a name="ln1193">  {</a>
<a name="ln1194">    g_free(tagname);</a>
<a name="ln1195">    return;</a>
<a name="ln1196">  }</a>
<a name="ln1197"> </a>
<a name="ln1198">  GList *tagged_images = NULL;</a>
<a name="ln1199">  sqlite3_stmt *stmt;</a>
<a name="ln1200">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.tagged_images WHERE tagid=?1&quot;,</a>
<a name="ln1201">                              -1, &amp;stmt, NULL);</a>
<a name="ln1202">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, tagid);</a>
<a name="ln1203">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1204">  {</a>
<a name="ln1205">    tagged_images = g_list_append(tagged_images, GINT_TO_POINTER(sqlite3_column_int(stmt, 0)));</a>
<a name="ln1206">  }</a>
<a name="ln1207">  sqlite3_finalize(stmt);</a>
<a name="ln1208"> </a>
<a name="ln1209">  // dt_tag_remove raises DT_SIGNAL_TAG_CHANGED. We don't want to reintialize the tree</a>
<a name="ln1210">  dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(_lib_tagging_tags_changed_callback), self);</a>
<a name="ln1211">  dt_tag_remove(tagid, TRUE);</a>
<a name="ln1212">  dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(_lib_tagging_tags_changed_callback), self);</a>
<a name="ln1213">  dt_control_log(_(&quot;tag %s removed&quot;), tagname);</a>
<a name="ln1214"> </a>
<a name="ln1215">  GtkTreeIter store_iter;</a>
<a name="ln1216">  GtkTreeModel *store = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model));</a>
<a name="ln1217">  gtk_tree_model_filter_convert_iter_to_child_iter(GTK_TREE_MODEL_FILTER(model),</a>
<a name="ln1218">                            &amp;store_iter, &amp;iter);</a>
<a name="ln1219">  delete_tree_tag(GTK_TREE_MODEL(store), &amp;store_iter, d-&gt;tree_flag);</a>
<a name="ln1220">  init_treeview(self, 0);</a>
<a name="ln1221"> </a>
<a name="ln1222">  GList *list_iter;</a>
<a name="ln1223">  if((list_iter = g_list_first(tagged_images)) != NULL)</a>
<a name="ln1224">  {</a>
<a name="ln1225">    do</a>
<a name="ln1226">    {</a>
<a name="ln1227">      dt_image_synch_xmp(GPOINTER_TO_INT(list_iter-&gt;data));</a>
<a name="ln1228">    } while((list_iter = g_list_next(list_iter)) != NULL);</a>
<a name="ln1229">  }</a>
<a name="ln1230">  g_list_free(tagged_images);</a>
<a name="ln1231">  g_free(tagname);</a>
<a name="ln1232">  raise_signal_tag_changed(self);</a>
<a name="ln1233">}</a>
<a name="ln1234"> </a>
<a name="ln1235">static void pop_menu_dictionary_delete_path(GtkWidget *menuitem, dt_lib_module_t *self)</a>
<a name="ln1236">{</a>
<a name="ln1237">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1238"> </a>
<a name="ln1239">  int res = GTK_RESPONSE_YES;</a>
<a name="ln1240"> </a>
<a name="ln1241">  char *tagname;</a>
<a name="ln1242">  gint tagid;</a>
<a name="ln1243">  gchar *text;</a>
<a name="ln1244">  GtkWidget *label;</a>
<a name="ln1245">  GtkTreeIter iter;</a>
<a name="ln1246">  GtkTreeModel *model = NULL;</a>
<a name="ln1247">  GtkTreeView *view = d-&gt;dictionary_view;</a>
<a name="ln1248">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln1249">  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)) return;</a>
<a name="ln1250"> </a>
<a name="ln1251">  gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_PATH, &amp;tagname,</a>
<a name="ln1252">          DT_LIB_TAGGING_COL_ID, &amp;tagid, -1);</a>
<a name="ln1253"> </a>
<a name="ln1254">  gint tag_count = 0;</a>
<a name="ln1255">  gint img_count = 0;</a>
<a name="ln1256">  dt_tag_count_tags_images(tagname, &amp;tag_count, &amp;img_count);</a>
<a name="ln1257">  if (tag_count == 0) return;</a>
<a name="ln1258"> </a>
<a name="ln1259">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1260">  GtkWidget *dialog = gtk_dialog_new_with_buttons( _(&quot;delete branch&quot;), GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln1261">                                _(&quot;delete&quot;), GTK_RESPONSE_YES, _(&quot;cancel&quot;), GTK_RESPONSE_NONE, NULL);</a>
<a name="ln1262">  gtk_window_set_default_size(GTK_WINDOW(dialog), 300, -1);</a>
<a name="ln1263">  GtkWidget *area = gtk_dialog_get_content_area(GTK_DIALOG(dialog));</a>
<a name="ln1264">  GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 8);</a>
<a name="ln1265">  gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);</a>
<a name="ln1266">  gtk_container_add(GTK_CONTAINER(area), vbox);</a>
<a name="ln1267">  text = g_strdup_printf(_(&quot;tag: %s &quot;), tagname);</a>
<a name="ln1268">  label = gtk_label_new(text);</a>
<a name="ln1269">  gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, TRUE, 0);</a>
<a name="ln1270">  g_free(text);</a>
<a name="ln1271"> </a>
<a name="ln1272">  GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln1273">  gtk_box_pack_start(GTK_BOX(vbox), box, FALSE, TRUE, 0);</a>
<a name="ln1274">  text = g_strdup_printf(ngettext(&quot;&lt;u&gt;%d&lt;/u&gt; tag will be deleted.&quot;, &quot;&lt;u&gt;%d&lt;/u&gt; tags will be deleted.&quot;, tag_count), tag_count);</a>
<a name="ln1275">  label = gtk_label_new(NULL);</a>
<a name="ln1276">  gtk_label_set_markup(GTK_LABEL(label), text);</a>
<a name="ln1277">  gtk_box_pack_start(GTK_BOX(box), label, FALSE, TRUE, 0);</a>
<a name="ln1278">  g_free(text);</a>
<a name="ln1279">  text = g_strdup_printf(ngettext(&quot;&lt;u&gt;%d&lt;/u&gt; image will be updated&quot;, &quot;&lt;u&gt;%d&lt;/u&gt; images will be updated &quot;, img_count), img_count);</a>
<a name="ln1280">  label = gtk_label_new(NULL);</a>
<a name="ln1281">  gtk_label_set_markup(GTK_LABEL(label), text);</a>
<a name="ln1282">  gtk_box_pack_start(GTK_BOX(box), label, FALSE, TRUE, 0);</a>
<a name="ln1283">  g_free(text);</a>
<a name="ln1284"> </a>
<a name="ln1285">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1286">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1287">#endif</a>
<a name="ln1288">  gtk_widget_show_all(dialog);</a>
<a name="ln1289"> </a>
<a name="ln1290">  res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1291">  gtk_widget_destroy(dialog);</a>
<a name="ln1292">  if (res != GTK_RESPONSE_YES)</a>
<a name="ln1293">  {</a>
<a name="ln1294">    g_free(tagname);</a>
<a name="ln1295">    return;</a>
<a name="ln1296">  }</a>
<a name="ln1297"> </a>
<a name="ln1298">  GList *tag_family = NULL;</a>
<a name="ln1299">  GList *tagged_images = NULL;</a>
<a name="ln1300">  dt_tag_get_tags_images(tagname, &amp;tag_family, &amp;tagged_images);</a>
<a name="ln1301"> </a>
<a name="ln1302">  dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(_lib_tagging_tags_changed_callback), self);</a>
<a name="ln1303">  tag_count = dt_tag_remove_list(tag_family);</a>
<a name="ln1304">  dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(_lib_tagging_tags_changed_callback), self);</a>
<a name="ln1305">  dt_control_log(_(&quot;%d tags removed&quot;), tag_count);</a>
<a name="ln1306"> </a>
<a name="ln1307">  GtkTreeIter store_iter;</a>
<a name="ln1308">  GtkTreeModel *store = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model));</a>
<a name="ln1309">  gtk_tree_model_filter_convert_iter_to_child_iter(GTK_TREE_MODEL_FILTER(model),</a>
<a name="ln1310">                            &amp;store_iter, &amp;iter);</a>
<a name="ln1311">  delete_tree_path(GTK_TREE_MODEL(store), &amp;store_iter, TRUE, d-&gt;tree_flag);</a>
<a name="ln1312">  init_treeview(self, 0);</a>
<a name="ln1313"> </a>
<a name="ln1314">  GList *list_iter;</a>
<a name="ln1315">  if((list_iter = g_list_first(tagged_images)) != NULL)</a>
<a name="ln1316">  {</a>
<a name="ln1317">    do</a>
<a name="ln1318">    {</a>
<a name="ln1319">      dt_image_synch_xmp(GPOINTER_TO_INT(list_iter-&gt;data));</a>
<a name="ln1320">    } while((list_iter = g_list_next(list_iter)) != NULL);</a>
<a name="ln1321">  }</a>
<a name="ln1322">  dt_tag_free_result(&amp;tag_family);</a>
<a name="ln1323">  g_list_free(tagged_images);</a>
<a name="ln1324">  raise_signal_tag_changed(self);</a>
<a name="ln1325">  g_free(tagname);</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328">// ecreate tag allows the user to create a single tag, which can be an element of the hierarchy or not</a>
<a name="ln1329">static void pop_menu_dictionary_create_tag(GtkWidget *menuitem, dt_lib_module_t *self)</a>
<a name="ln1330">{</a>
<a name="ln1331">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1332"> </a>
<a name="ln1333">  char *tagname;</a>
<a name="ln1334">  char *path;</a>
<a name="ln1335">  gint tagid;</a>
<a name="ln1336">  gchar *text;</a>
<a name="ln1337">  GtkWidget *label;</a>
<a name="ln1338">  GtkTreeIter iter;</a>
<a name="ln1339">  GtkTreeModel *model = NULL;</a>
<a name="ln1340">  GtkTreeView *view = d-&gt;dictionary_view;</a>
<a name="ln1341">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln1342">  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)) return;</a>
<a name="ln1343"> </a>
<a name="ln1344">  gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_TAG, &amp;tagname,</a>
<a name="ln1345">        DT_LIB_TAGGING_COL_PATH, &amp;path, DT_LIB_TAGGING_COL_ID, &amp;tagid, -1);</a>
<a name="ln1346"> </a>
<a name="ln1347">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1348">  GtkWidget *dialog = gtk_dialog_new_with_buttons(_(&quot;create tag&quot;), GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln1349">                                       _(&quot;save&quot;), GTK_RESPONSE_YES, _(&quot;cancel&quot;), GTK_RESPONSE_NONE, NULL);</a>
<a name="ln1350">  gtk_window_set_default_size(GTK_WINDOW(dialog), 300, -1);</a>
<a name="ln1351">  GtkWidget *area = gtk_dialog_get_content_area(GTK_DIALOG(dialog));</a>
<a name="ln1352">  GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 8);</a>
<a name="ln1353">  gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);</a>
<a name="ln1354">  gtk_container_add(GTK_CONTAINER(area), vbox);</a>
<a name="ln1355"> </a>
<a name="ln1356">  GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1357">  gtk_box_pack_start(GTK_BOX(vbox), box, FALSE, TRUE, 0);</a>
<a name="ln1358">  label = gtk_label_new(_(&quot;name: &quot;));</a>
<a name="ln1359">  gtk_box_pack_start(GTK_BOX(box), label, FALSE, TRUE, 0);</a>
<a name="ln1360">  GtkWidget *entry = gtk_entry_new();</a>
<a name="ln1361">  gtk_box_pack_end(GTK_BOX(box), entry, TRUE, TRUE, 0);</a>
<a name="ln1362"> </a>
<a name="ln1363">  GtkWidget *category;</a>
<a name="ln1364">  GtkWidget *private;</a>
<a name="ln1365">  GtkWidget *parent;</a>
<a name="ln1366">  GtkTextBuffer *buffer = NULL;</a>
<a name="ln1367">  GtkWidget *vbox2 = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1368">  gtk_box_pack_start(GTK_BOX(vbox), vbox2, FALSE, TRUE, 0);</a>
<a name="ln1369">  if (tagid)</a>
<a name="ln1370">  {</a>
<a name="ln1371">    text = g_strdup_printf(_(&quot;add to: \&quot;%s\&quot; &quot;), path);</a>
<a name="ln1372">    parent = gtk_check_button_new_with_label(text);</a>
<a name="ln1373">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(parent), TRUE);</a>
<a name="ln1374">    gtk_box_pack_end(GTK_BOX(vbox2), parent, FALSE, TRUE, 0);</a>
<a name="ln1375">    g_free(text);</a>
<a name="ln1376">  }</a>
<a name="ln1377">  category = gtk_check_button_new_with_label(_(&quot;category&quot;));</a>
<a name="ln1378">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(category), FALSE);</a>
<a name="ln1379">  gtk_box_pack_end(GTK_BOX(vbox2), category, FALSE, TRUE, 0);</a>
<a name="ln1380">  private = gtk_check_button_new_with_label(_(&quot;private&quot;));</a>
<a name="ln1381">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(private), FALSE);</a>
<a name="ln1382">  gtk_box_pack_end(GTK_BOX(vbox2), private, FALSE, TRUE, 0);</a>
<a name="ln1383"> </a>
<a name="ln1384">  box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1385">  gtk_box_pack_end(GTK_BOX(vbox), box, TRUE, TRUE, 0);</a>
<a name="ln1386">  label = gtk_label_new(_(&quot;synonyms: &quot;));</a>
<a name="ln1387">  gtk_box_pack_start(GTK_BOX(box), label, FALSE, TRUE, 0);</a>
<a name="ln1388">  GtkWidget *synonyms = gtk_text_view_new();</a>
<a name="ln1389">  gtk_box_pack_end(GTK_BOX(box), synonyms, TRUE, TRUE, 0);</a>
<a name="ln1390">  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(synonyms), GTK_WRAP_WORD);</a>
<a name="ln1391">  buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(synonyms));</a>
<a name="ln1392"> </a>
<a name="ln1393">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1394">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1395">#endif</a>
<a name="ln1396">  gtk_widget_show_all(dialog);</a>
<a name="ln1397"> </a>
<a name="ln1398">  if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_YES)</a>
<a name="ln1399">  {</a>
<a name="ln1400">    const char *newtag = gtk_entry_get_text(GTK_ENTRY(entry));</a>
<a name="ln1401">    char *message = NULL;</a>
<a name="ln1402">    if (!newtag[0])</a>
<a name="ln1403">      message = _(&quot;empty tag is not allowed, aborting&quot;);</a>
<a name="ln1404">    if(strchr(newtag, '|') != 0)</a>
<a name="ln1405">      message = _(&quot;'|' character is not allowed to create a tag. aborting.&quot;);</a>
<a name="ln1406">    char *new_tagname = NULL;</a>
<a name="ln1407">    gboolean root = TRUE;</a>
<a name="ln1408">    if (tagid)</a>
<a name="ln1409">    {</a>
<a name="ln1410">      root = !gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(parent));</a>
<a name="ln1411">    }</a>
<a name="ln1412">    if (!root)</a>
<a name="ln1413">    {</a>
<a name="ln1414">      new_tagname = g_strdup(path);</a>
<a name="ln1415">      new_tagname = dt_util_dstrcat(new_tagname, &quot;|%s&quot;, newtag);</a>
<a name="ln1416">    }</a>
<a name="ln1417">    else new_tagname = g_strdup(newtag);</a>
<a name="ln1418"> </a>
<a name="ln1419">    if (dt_tag_exists(new_tagname, NULL))</a>
<a name="ln1420">      message = _(&quot;tag name already exists. aborting.&quot;);</a>
<a name="ln1421">    if (message)</a>
<a name="ln1422">    {</a>
<a name="ln1423">      GtkWidget *warning_dialog = gtk_message_dialog_new(GTK_WINDOW(dialog), GTK_DIALOG_MODAL,</a>
<a name="ln1424">                      GTK_MESSAGE_INFO, GTK_BUTTONS_CLOSE, &quot;%s&quot;, message);</a>
<a name="ln1425">      gtk_dialog_run(GTK_DIALOG(warning_dialog));</a>
<a name="ln1426">      gtk_widget_destroy(warning_dialog);</a>
<a name="ln1427">      gtk_widget_destroy(dialog);</a>
<a name="ln1428">      g_free(tagname);</a>
<a name="ln1429">      return;</a>
<a name="ln1430">    }</a>
<a name="ln1431">    guint new_tagid = 0;</a>
<a name="ln1432">    if (dt_tag_new(new_tagname, &amp;new_tagid))</a>
<a name="ln1433">    {</a>
<a name="ln1434">      const gint new_flags = ((gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(category)) ? DT_TF_CATEGORY : 0) |</a>
<a name="ln1435">                      (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(private)) ? DT_TF_PRIVATE : 0));</a>
<a name="ln1436">      GtkTextIter start, end;</a>
<a name="ln1437">      gtk_text_buffer_get_start_iter(buffer, &amp;start);</a>
<a name="ln1438">      gtk_text_buffer_get_end_iter(buffer, &amp;end);</a>
<a name="ln1439">      gchar *new_synonyms_list = gtk_text_buffer_get_text(buffer, &amp;start, &amp;end, FALSE);</a>
<a name="ln1440"> </a>
<a name="ln1441">      GtkTreeIter store_iter, store_parent;</a>
<a name="ln1442">      GtkTreeModel *store = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model));</a>
<a name="ln1443">      if (!d-&gt;tree_flag)</a>
<a name="ln1444">      {</a>
<a name="ln1445">        gtk_list_store_append(GTK_LIST_STORE(store), &amp;store_iter);</a>
<a name="ln1446">        gtk_list_store_set(GTK_LIST_STORE(store), &amp;store_iter,</a>
<a name="ln1447">            DT_LIB_TAGGING_COL_ID, new_tagid,</a>
<a name="ln1448">            DT_LIB_TAGGING_COL_TAG, newtag,</a>
<a name="ln1449">            DT_LIB_TAGGING_COL_PATH, new_tagname,</a>
<a name="ln1450">            DT_LIB_TAGGING_COL_COUNT, 0,</a>
<a name="ln1451">            DT_LIB_TAGGING_COL_SEL, 0,</a>
<a name="ln1452">            DT_LIB_TAGGING_COL_FLAGS, new_flags,</a>
<a name="ln1453">            DT_LIB_TAGGING_COL_SYNONYM, new_synonyms_list,</a>
<a name="ln1454">            DT_LIB_TAGGING_COL_VISIBLE, TRUE, -1);</a>
<a name="ln1455">      }</a>
<a name="ln1456">      else</a>
<a name="ln1457">      {</a>
<a name="ln1458">        if (root)</a>
<a name="ln1459">        {</a>
<a name="ln1460">          gtk_tree_model_get_iter_first(model, &amp;iter);</a>
<a name="ln1461">          gtk_tree_store_insert(GTK_TREE_STORE(store), &amp;store_iter, NULL, -1);</a>
<a name="ln1462">        }</a>
<a name="ln1463">        else</a>
<a name="ln1464">        {</a>
<a name="ln1465">          gtk_tree_model_filter_convert_iter_to_child_iter(GTK_TREE_MODEL_FILTER(model),</a>
<a name="ln1466">                                    &amp;store_parent, &amp;iter);</a>
<a name="ln1467">          gtk_tree_store_insert(GTK_TREE_STORE(store), &amp;store_iter, &amp;store_parent, -1);</a>
<a name="ln1468">        }</a>
<a name="ln1469">        gtk_tree_store_set(GTK_TREE_STORE(store), &amp;store_iter,</a>
<a name="ln1470">            DT_LIB_TAGGING_COL_ID, new_tagid,</a>
<a name="ln1471">            DT_LIB_TAGGING_COL_TAG, newtag,</a>
<a name="ln1472">            DT_LIB_TAGGING_COL_PATH, new_tagname,</a>
<a name="ln1473">            DT_LIB_TAGGING_COL_COUNT, 0,</a>
<a name="ln1474">            DT_LIB_TAGGING_COL_SEL, 0,</a>
<a name="ln1475">            DT_LIB_TAGGING_COL_FLAGS, new_flags,</a>
<a name="ln1476">            DT_LIB_TAGGING_COL_SYNONYM, new_synonyms_list,</a>
<a name="ln1477">            DT_LIB_TAGGING_COL_VISIBLE, TRUE, -1);</a>
<a name="ln1478">      }</a>
<a name="ln1479">      g_free(new_synonyms_list);</a>
<a name="ln1480">    }</a>
<a name="ln1481">    g_free(new_tagname);</a>
<a name="ln1482">  }</a>
<a name="ln1483">  init_treeview(self, 0);</a>
<a name="ln1484">  gtk_widget_destroy(dialog);</a>
<a name="ln1485">  g_free(tagname);</a>
<a name="ln1486">}</a>
<a name="ln1487"> </a>
<a name="ln1488">// edit tag allows the user to rename a single tag, which can be an element of the hierarchy and change other parameters</a>
<a name="ln1489">static void pop_menu_dictionary_edit_tag(GtkWidget *menuitem, dt_lib_module_t *self)</a>
<a name="ln1490">{</a>
<a name="ln1491">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1492"> </a>
<a name="ln1493">  char *tagname;</a>
<a name="ln1494">  char *synonyms_list;</a>
<a name="ln1495">  gint tagid;</a>
<a name="ln1496">  gchar *text;</a>
<a name="ln1497">  GtkWidget *label;</a>
<a name="ln1498">  GtkTreeIter iter;</a>
<a name="ln1499">  GtkTreeModel *model = NULL;</a>
<a name="ln1500">  GtkTreeView *view = d-&gt;dictionary_view;</a>
<a name="ln1501">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln1502">  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)) return;</a>
<a name="ln1503"> </a>
<a name="ln1504">  gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_PATH, &amp;tagname,</a>
<a name="ln1505">          DT_LIB_TAGGING_COL_SYNONYM, &amp;synonyms_list, DT_LIB_TAGGING_COL_ID, &amp;tagid, -1);</a>
<a name="ln1506">  char *subtag = g_strrstr(tagname, &quot;|&quot;);</a>
<a name="ln1507"> </a>
<a name="ln1508">  gint tag_count;</a>
<a name="ln1509">  gint img_count;</a>
<a name="ln1510">  dt_tag_count_tags_images(tagname, &amp;tag_count, &amp;img_count);</a>
<a name="ln1511">  if (tag_count == 0) return;</a>
<a name="ln1512"> </a>
<a name="ln1513">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1514">  GtkWidget *dialog = gtk_dialog_new_with_buttons(_(&quot;edit tag&quot;), GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln1515">                                       _(&quot;save&quot;), GTK_RESPONSE_YES, _(&quot;cancel&quot;), GTK_RESPONSE_NONE, NULL);</a>
<a name="ln1516">  gtk_window_set_default_size(GTK_WINDOW(dialog), 300, -1);</a>
<a name="ln1517">  GtkWidget *area = gtk_dialog_get_content_area(GTK_DIALOG(dialog));</a>
<a name="ln1518">  GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 8);</a>
<a name="ln1519">  gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);</a>
<a name="ln1520">  gtk_container_add(GTK_CONTAINER(area), vbox);</a>
<a name="ln1521">  text = g_strdup_printf(_(&quot;tag: %s &quot;), tagname);</a>
<a name="ln1522">  label = gtk_label_new(text);</a>
<a name="ln1523">  gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, TRUE, 0);</a>
<a name="ln1524">  g_free(text);</a>
<a name="ln1525"> </a>
<a name="ln1526">  GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln1527">  gtk_box_pack_start(GTK_BOX(vbox), box, FALSE, TRUE, 0);</a>
<a name="ln1528">  text = g_strdup_printf(ngettext(&quot;&lt;u&gt;%d&lt;/u&gt; tag will be updated.&quot;, &quot;&lt;u&gt;%d&lt;/u&gt; tags will be updated.&quot;, tag_count), tag_count);</a>
<a name="ln1529">  label = gtk_label_new(NULL);</a>
<a name="ln1530">  gtk_label_set_markup(GTK_LABEL(label), text);</a>
<a name="ln1531">  gtk_box_pack_start(GTK_BOX(box), label, FALSE, TRUE, 0);</a>
<a name="ln1532">  g_free(text);</a>
<a name="ln1533">  text = g_strdup_printf(ngettext(&quot;&lt;u&gt;%d&lt;/u&gt; image will be updated&quot;, &quot;&lt;u&gt;%d&lt;/u&gt; images will be updated &quot;, img_count), img_count);</a>
<a name="ln1534">  label = gtk_label_new(NULL);</a>
<a name="ln1535">  gtk_label_set_markup(GTK_LABEL(label), text);</a>
<a name="ln1536">  gtk_box_pack_start(GTK_BOX(box), label, FALSE, TRUE, 0);</a>
<a name="ln1537">  g_free(text);</a>
<a name="ln1538"> </a>
<a name="ln1539">  box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1540">  gtk_box_pack_start(GTK_BOX(vbox), box, FALSE, TRUE, 0);</a>
<a name="ln1541">  label = gtk_label_new(_(&quot;name: &quot;));</a>
<a name="ln1542">  gtk_box_pack_start(GTK_BOX(box), label, FALSE, TRUE, 0);</a>
<a name="ln1543">  GtkWidget *entry = gtk_entry_new();</a>
<a name="ln1544">  gtk_entry_set_text(GTK_ENTRY(entry), subtag ? subtag + 1 : tagname);</a>
<a name="ln1545">  gtk_box_pack_end(GTK_BOX(box), entry, TRUE, TRUE, 0);</a>
<a name="ln1546"> </a>
<a name="ln1547">  gint flags = 0;</a>
<a name="ln1548">  GtkWidget *category;</a>
<a name="ln1549">  GtkWidget *private;</a>
<a name="ln1550">  GtkTextBuffer *buffer = NULL;</a>
<a name="ln1551">  if (tagid)</a>
<a name="ln1552">  {</a>
<a name="ln1553">    GtkWidget *vbox2 = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1554">    gtk_box_pack_start(GTK_BOX(vbox), vbox2, FALSE, TRUE, 0);</a>
<a name="ln1555">    flags = dt_tag_get_flags(tagid);</a>
<a name="ln1556">    category = gtk_check_button_new_with_label(_(&quot;category&quot;));</a>
<a name="ln1557">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(category), flags &amp; DT_TF_CATEGORY);</a>
<a name="ln1558">    gtk_box_pack_end(GTK_BOX(vbox2), category, FALSE, TRUE, 0);</a>
<a name="ln1559">    private = gtk_check_button_new_with_label(_(&quot;private&quot;));</a>
<a name="ln1560">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(private), flags &amp; DT_TF_PRIVATE);</a>
<a name="ln1561">    gtk_box_pack_end(GTK_BOX(vbox2), private, FALSE, TRUE, 0);</a>
<a name="ln1562"> </a>
<a name="ln1563">    box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1564">    gtk_box_pack_end(GTK_BOX(vbox), box, TRUE, TRUE, 0);</a>
<a name="ln1565">    label = gtk_label_new(_(&quot;synonyms: &quot;));</a>
<a name="ln1566">    gtk_box_pack_start(GTK_BOX(box), label, FALSE, TRUE, 0);</a>
<a name="ln1567">    GtkWidget *synonyms = gtk_text_view_new();</a>
<a name="ln1568">    gtk_box_pack_end(GTK_BOX(box), synonyms, TRUE, TRUE, 0);</a>
<a name="ln1569">    gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(synonyms), GTK_WRAP_WORD);</a>
<a name="ln1570">    buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(synonyms));</a>
<a name="ln1571">    if (synonyms_list) gtk_text_buffer_set_text(buffer, synonyms_list, -1);</a>
<a name="ln1572">  }</a>
<a name="ln1573"> </a>
<a name="ln1574">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1575">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1576">#endif</a>
<a name="ln1577">  gtk_widget_show_all(dialog);</a>
<a name="ln1578"> </a>
<a name="ln1579">  if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_YES)</a>
<a name="ln1580">  {</a>
<a name="ln1581">    const char *newtag = gtk_entry_get_text(GTK_ENTRY(entry));</a>
<a name="ln1582">    if (g_strcmp0(newtag, subtag ? subtag + 1 : tagname) != 0)</a>
<a name="ln1583">    {</a>
<a name="ln1584">      char *message = NULL;</a>
<a name="ln1585">      if (!newtag[0])</a>
<a name="ln1586">        message = _(&quot;empty tag is not allowed, aborting&quot;);</a>
<a name="ln1587">      if(strchr(newtag, '|') != 0)</a>
<a name="ln1588">        message = _(&quot;'|' character is not allowed for renaming tag.\nto modify the hierachy use rename path instead. Aborting.&quot;);</a>
<a name="ln1589">      if (message)</a>
<a name="ln1590">      {</a>
<a name="ln1591">        GtkWidget *warning_dialog = gtk_message_dialog_new(GTK_WINDOW(dialog), GTK_DIALOG_MODAL,</a>
<a name="ln1592">                        GTK_MESSAGE_INFO, GTK_BUTTONS_CLOSE, &quot;%s&quot;, message);</a>
<a name="ln1593">        gtk_dialog_run(GTK_DIALOG(warning_dialog));</a>
<a name="ln1594">        gtk_widget_destroy(warning_dialog);</a>
<a name="ln1595">        gtk_widget_destroy(dialog);</a>
<a name="ln1596">        g_free(tagname);</a>
<a name="ln1597">        return;</a>
<a name="ln1598">      }</a>
<a name="ln1599"> </a>
<a name="ln1600">      GList *tag_family = NULL;</a>
<a name="ln1601">      GList *tagged_images = NULL;</a>
<a name="ln1602">      dt_tag_get_tags_images(tagname, &amp;tag_family, &amp;tagged_images);</a>
<a name="ln1603"> </a>
<a name="ln1604">      const int tagname_len = strlen(tagname);</a>
<a name="ln1605">      char *new_prefix_tag;</a>
<a name="ln1606">      if (subtag)</a>
<a name="ln1607">      {</a>
<a name="ln1608">        const char letter = tagname[tagname_len - strlen(subtag) + 1];</a>
<a name="ln1609">        tagname[tagname_len - strlen(subtag) + 1] = '\0';</a>
<a name="ln1610">        new_prefix_tag = g_strconcat(tagname, newtag, NULL);</a>
<a name="ln1611">        tagname[tagname_len - strlen(subtag) + 1] = letter;</a>
<a name="ln1612">      }</a>
<a name="ln1613">      else</a>
<a name="ln1614">        new_prefix_tag = (char *)newtag;</a>
<a name="ln1615"> </a>
<a name="ln1616">      // check if one of the new tagnames already exists.</a>
<a name="ln1617">      gboolean tagname_exists = FALSE;</a>
<a name="ln1618">      for (GList *taglist = tag_family; taglist &amp;&amp; !tagname_exists; taglist = g_list_next(taglist))</a>
<a name="ln1619">      {</a>
<a name="ln1620">        char *new_tagname = g_strconcat(new_prefix_tag, &amp;((dt_tag_t *)taglist-&gt;data)-&gt;tag[tagname_len], NULL);</a>
<a name="ln1621">        tagname_exists = dt_tag_exists(new_tagname, NULL);</a>
<a name="ln1622">        if (tagname_exists)</a>
<a name="ln1623">        {</a>
<a name="ln1624">          GtkWidget *warning_dialog = gtk_message_dialog_new(GTK_WINDOW(dialog), GTK_DIALOG_MODAL,</a>
<a name="ln1625">                          GTK_MESSAGE_INFO, GTK_BUTTONS_CLOSE,</a>
<a name="ln1626">                          _(&quot;at least one new tag name (%s) already exists, aborting&quot;), new_tagname);</a>
<a name="ln1627">          gtk_dialog_run(GTK_DIALOG(warning_dialog));</a>
<a name="ln1628">          gtk_widget_destroy(warning_dialog);</a>
<a name="ln1629">        };</a>
<a name="ln1630">        g_free(new_tagname);</a>
<a name="ln1631">      }</a>
<a name="ln1632"> </a>
<a name="ln1633">      if (!tagname_exists)</a>
<a name="ln1634">      {</a>
<a name="ln1635">        dt_tag_op_t *to = g_malloc(sizeof(dt_tag_op_t));</a>
<a name="ln1636">        to-&gt;tree_flag = d-&gt;tree_flag;</a>
<a name="ln1637">        to-&gt;suggestion_flag = d-&gt;suggestion_flag;</a>
<a name="ln1638">        GtkTreeModel *store = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model));</a>
<a name="ln1639">        for (GList *taglist = tag_family; taglist; taglist = g_list_next(taglist))</a>
<a name="ln1640">        {</a>
<a name="ln1641">          char *new_tagname = g_strconcat(new_prefix_tag, &amp;((dt_tag_t *)taglist-&gt;data)-&gt;tag[tagname_len], NULL);</a>
<a name="ln1642">          dt_tag_rename(((dt_tag_t *)taglist-&gt;data)-&gt;id, new_tagname);</a>
<a name="ln1643">          // when possible refresh the tree to not collapse it</a>
<a name="ln1644">          if (d-&gt;tree_flag || !d-&gt;suggestion_flag)</a>
<a name="ln1645">          {</a>
<a name="ln1646">            to-&gt;tagid = ((dt_tag_t *)taglist-&gt;data)-&gt;id;</a>
<a name="ln1647">            to-&gt;newtagname = new_tagname;</a>
<a name="ln1648">            gtk_tree_model_foreach(GTK_TREE_MODEL(store), (GtkTreeModelForeachFunc)update_tag_name_per_id, to);</a>
<a name="ln1649">          }</a>
<a name="ln1650">          g_free(new_tagname);</a>
<a name="ln1651">        }</a>
<a name="ln1652">        if (!tagid &amp;&amp; d-&gt;tree_flag) // the node is not a tag. must be refreshed too.</a>
<a name="ln1653">        {</a>
<a name="ln1654">          to-&gt;oldtagname = tagname;</a>
<a name="ln1655">          to-&gt;newtagname = new_prefix_tag;</a>
<a name="ln1656">          gtk_tree_model_foreach(store, (GtkTreeModelForeachFunc)update_tag_name_per_name, to);</a>
<a name="ln1657">        }</a>
<a name="ln1658">        if (subtag) g_free(new_prefix_tag);</a>
<a name="ln1659">        g_free(to);</a>
<a name="ln1660"> </a>
<a name="ln1661">        if(dt_conf_get_bool(&quot;write_sidecar_files&quot;))</a>
<a name="ln1662">        {</a>
<a name="ln1663">          for (GList *imagelist = tagged_images; imagelist; imagelist = g_list_next(imagelist))</a>
<a name="ln1664">          {</a>
<a name="ln1665">            dt_image_synch_xmp(GPOINTER_TO_INT(imagelist-&gt;data));</a>
<a name="ln1666">          }</a>
<a name="ln1667">        }</a>
<a name="ln1668">        raise_signal_tag_changed(self);</a>
<a name="ln1669">      }</a>
<a name="ln1670">      dt_tag_free_result(&amp;tag_family);</a>
<a name="ln1671">      g_list_free(tagged_images);</a>
<a name="ln1672">    }</a>
<a name="ln1673"> </a>
<a name="ln1674">    if (tagid)</a>
<a name="ln1675">    {</a>
<a name="ln1676">      gint new_flags = ((gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(category)) ? DT_TF_CATEGORY : 0) |</a>
<a name="ln1677">                      (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(private)) ? DT_TF_PRIVATE : 0));</a>
<a name="ln1678">      GtkTextIter start, end;</a>
<a name="ln1679">      gtk_text_buffer_get_start_iter(buffer, &amp;start);</a>
<a name="ln1680">      gtk_text_buffer_get_end_iter(buffer, &amp;end);</a>
<a name="ln1681">      gchar *new_synonyms_list = gtk_text_buffer_get_text(buffer, &amp;start, &amp;end, FALSE);</a>
<a name="ln1682">      GtkTreeIter store_iter;</a>
<a name="ln1683">      GtkTreeModel *store = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model));</a>
<a name="ln1684">      gtk_tree_model_filter_convert_iter_to_child_iter(GTK_TREE_MODEL_FILTER(model),</a>
<a name="ln1685">                                &amp;store_iter, &amp;iter);</a>
<a name="ln1686">      if (new_flags != flags)</a>
<a name="ln1687">      {</a>
<a name="ln1688">        dt_tag_set_flags(tagid, new_flags);</a>
<a name="ln1689">        if (!d-&gt;tree_flag)</a>
<a name="ln1690">          gtk_list_store_set(GTK_LIST_STORE(store), &amp;store_iter, DT_LIB_TAGGING_COL_FLAGS, new_flags, -1);</a>
<a name="ln1691">        else</a>
<a name="ln1692">          gtk_tree_store_set(GTK_TREE_STORE(store), &amp;store_iter, DT_LIB_TAGGING_COL_FLAGS, new_flags, -1);</a>
<a name="ln1693">      }</a>
<a name="ln1694">      if (new_synonyms_list &amp;&amp; g_strcmp0(synonyms_list, new_synonyms_list) != 0)</a>
<a name="ln1695">      {</a>
<a name="ln1696">        dt_tag_set_synonyms(tagid, new_synonyms_list);</a>
<a name="ln1697">        if (!d-&gt;tree_flag)</a>
<a name="ln1698">          gtk_list_store_set(GTK_LIST_STORE(store), &amp;store_iter, DT_LIB_TAGGING_COL_SYNONYM, new_synonyms_list, -1);</a>
<a name="ln1699">        else</a>
<a name="ln1700">          gtk_tree_store_set(GTK_TREE_STORE(store), &amp;store_iter, DT_LIB_TAGGING_COL_SYNONYM, new_synonyms_list, -1);</a>
<a name="ln1701">      }</a>
<a name="ln1702">      g_free(new_synonyms_list);</a>
<a name="ln1703">    }</a>
<a name="ln1704">  }</a>
<a name="ln1705">  init_treeview(self, 0);</a>
<a name="ln1706">  gtk_widget_destroy(dialog);</a>
<a name="ln1707">  g_free(tagname);</a>
<a name="ln1708">}</a>
<a name="ln1709"> </a>
<a name="ln1710">// rename path allows the user to redefine a hierarchy</a>
<a name="ln1711">static void pop_menu_dictionary_rename_path(GtkWidget *menuitem, dt_lib_module_t *self)</a>
<a name="ln1712">{</a>
<a name="ln1713">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1714"> </a>
<a name="ln1715">  char *tagname;</a>
<a name="ln1716">  gint tagid;</a>
<a name="ln1717">  gchar *text;</a>
<a name="ln1718">  GtkWidget *label;</a>
<a name="ln1719">  GtkTreeIter iter;</a>
<a name="ln1720">  GtkTreeModel *model = NULL;</a>
<a name="ln1721">  GtkTreeView *view = d-&gt;dictionary_view;</a>
<a name="ln1722">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln1723">  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)) return;</a>
<a name="ln1724"> </a>
<a name="ln1725">  gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_PATH, &amp;tagname,</a>
<a name="ln1726">          DT_LIB_TAGGING_COL_ID, &amp;tagid, -1);</a>
<a name="ln1727"> </a>
<a name="ln1728">  gint tag_count;</a>
<a name="ln1729">  gint img_count;</a>
<a name="ln1730">  dt_tag_count_tags_images(tagname, &amp;tag_count, &amp;img_count);</a>
<a name="ln1731">  if (tag_count == 0) return;</a>
<a name="ln1732"> </a>
<a name="ln1733">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1734">  GtkWidget *dialog = gtk_dialog_new_with_buttons(_(&quot;rename path?&quot;), GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln1735">                                       _(&quot;rename&quot;), GTK_RESPONSE_YES, _(&quot;cancel&quot;), GTK_RESPONSE_NONE, NULL);</a>
<a name="ln1736">  gtk_window_set_default_size(GTK_WINDOW(dialog), 300, -1);</a>
<a name="ln1737">  GtkWidget *area = gtk_dialog_get_content_area(GTK_DIALOG(dialog));</a>
<a name="ln1738">  GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 8);</a>
<a name="ln1739">  gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);</a>
<a name="ln1740">  gtk_container_add(GTK_CONTAINER(area), vbox);</a>
<a name="ln1741">  text = g_strdup_printf(_(&quot;selected path: %s &quot;), tagname);</a>
<a name="ln1742">  label = gtk_label_new(text);</a>
<a name="ln1743">  gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, TRUE, 0);</a>
<a name="ln1744">  g_free(text);</a>
<a name="ln1745"> </a>
<a name="ln1746">  GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln1747">  gtk_box_pack_start(GTK_BOX(vbox), box, FALSE, TRUE, 0);</a>
<a name="ln1748">  text = g_strdup_printf(ngettext(&quot;&lt;u&gt;%d&lt;/u&gt; tag will be updated.&quot;, &quot;&lt;u&gt;%d&lt;/u&gt; tags will be updated.&quot;, tag_count), tag_count);</a>
<a name="ln1749">  label = gtk_label_new(NULL);</a>
<a name="ln1750">  gtk_label_set_markup(GTK_LABEL(label), text);</a>
<a name="ln1751">  gtk_box_pack_start(GTK_BOX(box), label, FALSE, TRUE, 0);</a>
<a name="ln1752">  g_free(text);</a>
<a name="ln1753">  text = g_strdup_printf(ngettext(&quot;&lt;u&gt;%d&lt;/u&gt; image will be updated&quot;, &quot;&lt;u&gt;%d&lt;/u&gt; images will be updated &quot;, img_count), img_count);</a>
<a name="ln1754">  label = gtk_label_new(NULL);</a>
<a name="ln1755">  gtk_label_set_markup(GTK_LABEL(label), text);</a>
<a name="ln1756">  gtk_box_pack_start(GTK_BOX(box), label, FALSE, TRUE, 0);</a>
<a name="ln1757">  g_free(text);</a>
<a name="ln1758"> </a>
<a name="ln1759">  GtkWidget *entry = gtk_entry_new();</a>
<a name="ln1760">  gtk_entry_set_text(GTK_ENTRY(entry), tagname);</a>
<a name="ln1761">  gtk_box_pack_start(GTK_BOX(vbox), entry, FALSE, TRUE, 0);</a>
<a name="ln1762"> </a>
<a name="ln1763">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1764">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1765">#endif</a>
<a name="ln1766">  gtk_widget_show_all(dialog);</a>
<a name="ln1767"> </a>
<a name="ln1768">  if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_YES)</a>
<a name="ln1769">  {</a>
<a name="ln1770">    const char *newtag = gtk_entry_get_text(GTK_ENTRY(entry));</a>
<a name="ln1771">    if (g_strcmp0(newtag, tagname) == 0)</a>
<a name="ln1772">      return;  // no change</a>
<a name="ln1773">    char *message = NULL;</a>
<a name="ln1774">    if (!newtag[0])</a>
<a name="ln1775">      message = _(&quot;empty tag is not allowed, aborting&quot;);</a>
<a name="ln1776">    if (strchr(newtag, '|') == &amp;newtag[0] || strchr(newtag, '|') == &amp;newtag[strlen(newtag)-1] || strstr(newtag, &quot;||&quot;))</a>
<a name="ln1777">      message = _(&quot;'|' misplaced, empty tag is not allowed, aborting&quot;);</a>
<a name="ln1778">    if (message)</a>
<a name="ln1779">    {</a>
<a name="ln1780">      GtkWidget *warning_dialog = gtk_message_dialog_new(GTK_WINDOW(dialog), GTK_DIALOG_MODAL,</a>
<a name="ln1781">                      GTK_MESSAGE_INFO, GTK_BUTTONS_CLOSE, &quot;%s&quot;, message);</a>
<a name="ln1782">      gtk_dialog_run(GTK_DIALOG(warning_dialog));</a>
<a name="ln1783">      gtk_widget_destroy(warning_dialog);</a>
<a name="ln1784">      gtk_widget_destroy(dialog);</a>
<a name="ln1785">      g_free(tagname);</a>
<a name="ln1786">      return;</a>
<a name="ln1787">    }</a>
<a name="ln1788">    GList *tag_family = NULL;</a>
<a name="ln1789">    GList *tagged_images = NULL;</a>
<a name="ln1790">    dt_tag_get_tags_images(tagname, &amp;tag_family, &amp;tagged_images);</a>
<a name="ln1791"> </a>
<a name="ln1792">    // check if one of the new tagnames already exists.</a>
<a name="ln1793">    const int tagname_len = strlen(tagname);</a>
<a name="ln1794">    gboolean tagname_exists = FALSE;</a>
<a name="ln1795">    for (GList *taglist = tag_family; taglist &amp;&amp; !tagname_exists; taglist = g_list_next(taglist))</a>
<a name="ln1796">    {</a>
<a name="ln1797">      char *new_tagname = g_strconcat(newtag, &amp;((dt_tag_t *)taglist-&gt;data)-&gt;tag[tagname_len], NULL);</a>
<a name="ln1798">      tagname_exists = dt_tag_exists(new_tagname, NULL);</a>
<a name="ln1799">      if (tagname_exists)</a>
<a name="ln1800">      {</a>
<a name="ln1801">        GtkWidget *warning_dialog = gtk_message_dialog_new(GTK_WINDOW(dialog), GTK_DIALOG_MODAL,</a>
<a name="ln1802">                        GTK_MESSAGE_INFO, GTK_BUTTONS_CLOSE,</a>
<a name="ln1803">                        _(&quot;at least one new tagname (%s) already exists, aborting.&quot;), new_tagname);</a>
<a name="ln1804">        gtk_dialog_run(GTK_DIALOG(warning_dialog));</a>
<a name="ln1805">        gtk_widget_destroy(warning_dialog);</a>
<a name="ln1806">      };</a>
<a name="ln1807">      g_free(new_tagname);</a>
<a name="ln1808">    }</a>
<a name="ln1809"> </a>
<a name="ln1810">    if (!tagname_exists)</a>
<a name="ln1811">    {</a>
<a name="ln1812">      for (GList *taglist = tag_family; taglist; taglist = g_list_next(taglist))</a>
<a name="ln1813">      {</a>
<a name="ln1814">        char *new_tagname = g_strconcat(newtag, &amp;((dt_tag_t *)taglist-&gt;data)-&gt;tag[tagname_len], NULL);</a>
<a name="ln1815">        dt_tag_rename(((dt_tag_t *)taglist-&gt;data)-&gt;id, new_tagname);</a>
<a name="ln1816">        g_free(new_tagname);</a>
<a name="ln1817">      }</a>
<a name="ln1818">      // TODO see if we could update without reinit</a>
<a name="ln1819">      init_treeview(self, 0);</a>
<a name="ln1820">      init_treeview(self, 1);</a>
<a name="ln1821"> </a>
<a name="ln1822">      if(dt_conf_get_bool(&quot;write_sidecar_files&quot;))</a>
<a name="ln1823">      {</a>
<a name="ln1824">        for (GList *imagelist = tagged_images; imagelist; imagelist = g_list_next(imagelist))</a>
<a name="ln1825">        {</a>
<a name="ln1826">          dt_image_synch_xmp(GPOINTER_TO_INT(imagelist-&gt;data));</a>
<a name="ln1827">        }</a>
<a name="ln1828">      }</a>
<a name="ln1829">      raise_signal_tag_changed(self);</a>
<a name="ln1830">    }</a>
<a name="ln1831">    dt_tag_free_result(&amp;tag_family);</a>
<a name="ln1832">    g_list_free(tagged_images);</a>
<a name="ln1833">  }</a>
<a name="ln1834">  gtk_widget_destroy(dialog);</a>
<a name="ln1835">  g_free(tagname);</a>
<a name="ln1836">}</a>
<a name="ln1837"> </a>
<a name="ln1838">static void pop_menu_dictionary_goto_tag_collection(GtkWidget *menuitem, dt_lib_module_t *self)</a>
<a name="ln1839">{</a>
<a name="ln1840">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1841">  GtkTreeIter iter;</a>
<a name="ln1842">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(d-&gt;dictionary_view));</a>
<a name="ln1843">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(d-&gt;dictionary_view));</a>
<a name="ln1844">  if(gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln1845">  {</a>
<a name="ln1846">    char *path;</a>
<a name="ln1847">    guint count;</a>
<a name="ln1848">    gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_PATH, &amp;path, DT_LIB_TAGGING_COL_COUNT, &amp;count, -1);</a>
<a name="ln1849">    if (count)</a>
<a name="ln1850">    {</a>
<a name="ln1851">      if (!d-&gt;collection[0]) dt_collection_serialize(d-&gt;collection, 4096);</a>
<a name="ln1852">      char *tag_collection = NULL;</a>
<a name="ln1853">      tag_collection = dt_util_dstrcat(tag_collection, &quot;1:0:3:%s$&quot;, path);</a>
<a name="ln1854">      dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(collection_updated_callback), self);</a>
<a name="ln1855">      dt_collection_deserialize(tag_collection);</a>
<a name="ln1856">      dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(collection_updated_callback), self);</a>
<a name="ln1857">      g_free(tag_collection);</a>
<a name="ln1858">    }</a>
<a name="ln1859">    g_free(path);</a>
<a name="ln1860">  }</a>
<a name="ln1861">}</a>
<a name="ln1862"> </a>
<a name="ln1863">static void pop_menu_dictionary_goto_collection_back(GtkWidget *menuitem, dt_lib_module_t *self)</a>
<a name="ln1864">{</a>
<a name="ln1865">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1866">  if (d-&gt;collection[0])</a>
<a name="ln1867">  {</a>
<a name="ln1868">    dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(collection_updated_callback), self);</a>
<a name="ln1869">    dt_collection_deserialize(d-&gt;collection);</a>
<a name="ln1870">    dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(collection_updated_callback), self);</a>
<a name="ln1871">    d-&gt;collection[0] = '\0';</a>
<a name="ln1872">  }</a>
<a name="ln1873">}</a>
<a name="ln1874"> </a>
<a name="ln1875">static void pop_menu_dictionary_copy_tag(GtkWidget *menuitem, dt_lib_module_t *self)</a>
<a name="ln1876">{</a>
<a name="ln1877">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1878">  GtkTreeIter iter;</a>
<a name="ln1879">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(d-&gt;dictionary_view));</a>
<a name="ln1880">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(d-&gt;dictionary_view));</a>
<a name="ln1881">  if(gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln1882">  {</a>
<a name="ln1883">    char *tag;</a>
<a name="ln1884">    gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_PATH, &amp;tag, -1);</a>
<a name="ln1885">    gtk_entry_set_text(d-&gt;entry, tag);</a>
<a name="ln1886">    g_free(tag);</a>
<a name="ln1887">    gtk_entry_grab_focus_without_selecting(d-&gt;entry);</a>
<a name="ln1888">  }</a>
<a name="ln1889">}</a>
<a name="ln1890"> </a>
<a name="ln1891">static void pop_menu_dictionary_attach_tag(GtkWidget *menuitem, dt_lib_module_t *self)</a>
<a name="ln1892">{</a>
<a name="ln1893">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1894">  attach_selected_tag(self, d);</a>
<a name="ln1895">}</a>
<a name="ln1896"> </a>
<a name="ln1897">static void pop_menu_dictionary_detach_tag(GtkWidget *menuitem, dt_lib_module_t *self)</a>
<a name="ln1898">{</a>
<a name="ln1899">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1900">  detach_selected_tag(d-&gt;dictionary_view, self, d);</a>
<a name="ln1901">}</a>
<a name="ln1902"> </a>
<a name="ln1903">static void pop_menu_dictionary(GtkWidget *treeview, GdkEventButton *event, dt_lib_module_t *self)</a>
<a name="ln1904">{</a>
<a name="ln1905">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln1906">  GtkWidget *menu, *menuitem;</a>
<a name="ln1907">  menu = gtk_menu_new();</a>
<a name="ln1908"> </a>
<a name="ln1909">  menuitem = gtk_menu_item_new_with_label(_(&quot;attach tag&quot;));</a>
<a name="ln1910">  g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)pop_menu_dictionary_attach_tag, self);</a>
<a name="ln1911">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1912"> </a>
<a name="ln1913">  menuitem = gtk_menu_item_new_with_label(_(&quot;detach tag&quot;));</a>
<a name="ln1914">  g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)pop_menu_dictionary_detach_tag, self);</a>
<a name="ln1915">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1916"> </a>
<a name="ln1917">  if (d-&gt;tree_flag || !d-&gt;suggestion_flag)</a>
<a name="ln1918">  {</a>
<a name="ln1919">    menuitem = gtk_separator_menu_item_new();</a>
<a name="ln1920">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1921">    menuitem = gtk_menu_item_new_with_label(_(&quot;delete tag&quot;));</a>
<a name="ln1922">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1923">    g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)pop_menu_dictionary_delete_tag, self);</a>
<a name="ln1924"> </a>
<a name="ln1925">    menuitem = gtk_menu_item_new_with_label(_(&quot;delete branch&quot;));</a>
<a name="ln1926">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1927">    g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)pop_menu_dictionary_delete_path, self);</a>
<a name="ln1928"> </a>
<a name="ln1929">    menuitem = gtk_separator_menu_item_new();</a>
<a name="ln1930">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1931">    menuitem = gtk_menu_item_new_with_label(_(&quot;create tag...&quot;));</a>
<a name="ln1932">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1933">    g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)pop_menu_dictionary_create_tag, self);</a>
<a name="ln1934"> </a>
<a name="ln1935">    menuitem = gtk_menu_item_new_with_label(_(&quot;edit tag...&quot;));</a>
<a name="ln1936">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1937">    g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)pop_menu_dictionary_edit_tag, self);</a>
<a name="ln1938">  }</a>
<a name="ln1939"> </a>
<a name="ln1940">  if (d-&gt;tree_flag)</a>
<a name="ln1941">  {</a>
<a name="ln1942">    menuitem = gtk_separator_menu_item_new();</a>
<a name="ln1943">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1944">    menuitem = gtk_menu_item_new_with_label(_(&quot;rename path...&quot;));</a>
<a name="ln1945">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1946">    g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)pop_menu_dictionary_rename_path, self);</a>
<a name="ln1947">  }</a>
<a name="ln1948"> </a>
<a name="ln1949">  menuitem = gtk_separator_menu_item_new();</a>
<a name="ln1950">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1951">  menuitem = gtk_menu_item_new_with_label(_(&quot;copy to entry&quot;));</a>
<a name="ln1952">  g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)pop_menu_dictionary_copy_tag, self);</a>
<a name="ln1953">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1954"> </a>
<a name="ln1955">  GtkTreeIter iter;</a>
<a name="ln1956">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(d-&gt;dictionary_view));</a>
<a name="ln1957">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(d-&gt;dictionary_view));</a>
<a name="ln1958">  if(gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln1959">  {</a>
<a name="ln1960">    if (d-&gt;collection[0])</a>
<a name="ln1961">    {</a>
<a name="ln1962">      char *collection = g_malloc(4096);</a>
<a name="ln1963">      dt_collection_serialize(collection, 4096);</a>
<a name="ln1964">      if (g_strcmp0(d-&gt;collection, collection) == 0) d-&gt;collection[0] = '\0';</a>
<a name="ln1965">      g_free(collection);</a>
<a name="ln1966">    }</a>
<a name="ln1967">    guint count;</a>
<a name="ln1968">    gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_COUNT, &amp;count, -1);</a>
<a name="ln1969">    if (count || d-&gt;collection[0])</a>
<a name="ln1970">    {</a>
<a name="ln1971">      menuitem = gtk_separator_menu_item_new();</a>
<a name="ln1972">      gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1973">      if (count)</a>
<a name="ln1974">      {</a>
<a name="ln1975">        menuitem = gtk_menu_item_new_with_label(_(&quot;go to tag collection&quot;));</a>
<a name="ln1976">        g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)pop_menu_dictionary_goto_tag_collection, self);</a>
<a name="ln1977">        gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1978">      }</a>
<a name="ln1979">      if (d-&gt;collection[0])</a>
<a name="ln1980">      {</a>
<a name="ln1981">        menuitem = gtk_menu_item_new_with_label(_(&quot;go back to work&quot;));</a>
<a name="ln1982">        g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)pop_menu_dictionary_goto_collection_back, self);</a>
<a name="ln1983">        gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln1984">      }</a>
<a name="ln1985">    }</a>
<a name="ln1986">  }</a>
<a name="ln1987"> </a>
<a name="ln1988">  gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln1989"> </a>
<a name="ln1990">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln1991">  gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln1992">#else</a>
<a name="ln1993">  /* Note: event can be NULL here when called from view_onPopupMenu;</a>
<a name="ln1994">   *  gdk_event_get_time() accepts a NULL argument */</a>
<a name="ln1995">  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, (event != NULL) ? event-&gt;button : 0,</a>
<a name="ln1996">                 gdk_event_get_time((GdkEvent *)event));</a>
<a name="ln1997">#endif</a>
<a name="ln1998">}</a>
<a name="ln1999"> </a>
<a name="ln2000">static gboolean click_on_view_dictionary(GtkWidget *view, GdkEventButton *event, dt_lib_module_t *self)</a>
<a name="ln2001">{</a>
<a name="ln2002">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln2003"> </a>
<a name="ln2004">  if((event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3)</a>
<a name="ln2005">    || (d-&gt;tree_flag &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 1 &amp;&amp; event-&gt;state &amp; GDK_SHIFT_MASK)</a>
<a name="ln2006">    || (event-&gt;type == GDK_2BUTTON_PRESS &amp;&amp; event-&gt;button == 1))</a>
<a name="ln2007">  {</a>
<a name="ln2008">    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln2009">    GtkTreePath *path = NULL;</a>
<a name="ln2010">    // Get tree path for row that was clicked</a>
<a name="ln2011">    if(gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(view), (gint)event-&gt;x, (gint)event-&gt;y, &amp;path, NULL, NULL, NULL))</a>
<a name="ln2012">    {</a>
<a name="ln2013">      gtk_tree_selection_select_path(selection, path);</a>
<a name="ln2014">      if(event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3)</a>
<a name="ln2015">      {</a>
<a name="ln2016">        pop_menu_dictionary(view, event, self);</a>
<a name="ln2017">        gtk_tree_path_free(path);</a>
<a name="ln2018">        return TRUE;</a>
<a name="ln2019">      }</a>
<a name="ln2020">      else if(d-&gt;tree_flag &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 1 &amp;&amp; event-&gt;state &amp; GDK_SHIFT_MASK)</a>
<a name="ln2021">      {</a>
<a name="ln2022">        gtk_tree_view_expand_row(GTK_TREE_VIEW(view), path, TRUE);</a>
<a name="ln2023">        return TRUE;</a>
<a name="ln2024">      }</a>
<a name="ln2025">      else if(event-&gt;type == GDK_2BUTTON_PRESS &amp;&amp; event-&gt;button == 1)</a>
<a name="ln2026">      {</a>
<a name="ln2027">        attach_selected_tag(self, d);</a>
<a name="ln2028">        gtk_tree_path_free(path);</a>
<a name="ln2029">        return TRUE;</a>
<a name="ln2030">      }</a>
<a name="ln2031">    }</a>
<a name="ln2032">    gtk_tree_path_free(path);</a>
<a name="ln2033">  }</a>
<a name="ln2034">  return FALSE;</a>
<a name="ln2035">}</a>
<a name="ln2036"> </a>
<a name="ln2037">static gboolean mouse_scroll_attached(GtkWidget *treeview, GdkEventScroll *event, dt_lib_module_t *self)</a>
<a name="ln2038">{</a>
<a name="ln2039">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln2040">  if (event-&gt;state &amp; GDK_CONTROL_MASK)</a>
<a name="ln2041">  {</a>
<a name="ln2042">    gint width, height;</a>
<a name="ln2043">    gtk_widget_get_size_request (GTK_WIDGET(d-&gt;attached_window), &amp;width, &amp;height);</a>
<a name="ln2044">    height = height + 10.0 * event-&gt;delta_y;</a>
<a name="ln2045">    height = (height &lt; 100.0) ? 100.0 : (height &gt; 500.0) ? 500.0 : height;</a>
<a name="ln2046">    gtk_widget_set_size_request(GTK_WIDGET(d-&gt;attached_window), -1, DT_PIXEL_APPLY_DPI((gint)height));</a>
<a name="ln2047">    dt_conf_set_int(&quot;plugins/lighttable/tagging/heightattachedwindow&quot;, (gint)height);</a>
<a name="ln2048">    return TRUE;</a>
<a name="ln2049">  }</a>
<a name="ln2050">  return FALSE;</a>
<a name="ln2051">}</a>
<a name="ln2052"> </a>
<a name="ln2053">static gboolean mouse_scroll_dictionary(GtkWidget *treeview, GdkEventScroll *event, dt_lib_module_t *self)</a>
<a name="ln2054">{</a>
<a name="ln2055">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln2056">  if (event-&gt;state &amp; GDK_CONTROL_MASK)</a>
<a name="ln2057">  {</a>
<a name="ln2058">    gint width, height;</a>
<a name="ln2059">    gtk_widget_get_size_request (GTK_WIDGET(d-&gt;dictionary_window), &amp;width, &amp;height);</a>
<a name="ln2060">    height = height + 10.0 * event-&gt;delta_y;</a>
<a name="ln2061">    height = (height &lt; 100.0) ? 100.0 : (height &gt; 1000.0) ? 1000.0 : height;</a>
<a name="ln2062">    gtk_widget_set_size_request(GTK_WIDGET(d-&gt;dictionary_window), -1, DT_PIXEL_APPLY_DPI((gint)height));</a>
<a name="ln2063">    dt_conf_set_int(&quot;plugins/lighttable/tagging/heightdictionarywindow&quot;, (gint)height);</a>
<a name="ln2064">    return TRUE;</a>
<a name="ln2065">  }</a>
<a name="ln2066">  return FALSE;</a>
<a name="ln2067">}</a>
<a name="ln2068"> </a>
<a name="ln2069">static gboolean row_tooltip_setup(GtkWidget *treeview, gint x, gint y, gboolean kb_mode,</a>
<a name="ln2070">      GtkTooltip* tooltip, dt_lib_module_t *self)</a>
<a name="ln2071">{</a>
<a name="ln2072">  gboolean res = FALSE;</a>
<a name="ln2073">  GtkTreePath *path = NULL;</a>
<a name="ln2074">  // Get tree path mouse position</a>
<a name="ln2075">  if(gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(treeview), x, y, &amp;path, NULL, NULL, NULL))</a>
<a name="ln2076">  {</a>
<a name="ln2077">    GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(treeview));</a>
<a name="ln2078">    GtkTreeIter iter;</a>
<a name="ln2079">    if (gtk_tree_model_get_iter(model, &amp;iter, path))</a>
<a name="ln2080">    {</a>
<a name="ln2081">      char *tagname;</a>
<a name="ln2082">      guint tagid;</a>
<a name="ln2083">      guint flags;</a>
<a name="ln2084">      char *synonyms;</a>
<a name="ln2085">      gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_ID, &amp;tagid, DT_LIB_TAGGING_COL_TAG, &amp;tagname,</a>
<a name="ln2086">              DT_LIB_TAGGING_COL_FLAGS, &amp;flags, DT_LIB_TAGGING_COL_SYNONYM, &amp;synonyms, -1);</a>
<a name="ln2087">      if (tagid)</a>
<a name="ln2088">      {</a>
<a name="ln2089">        if ((flags &amp; DT_TF_PRIVATE) || (synonyms &amp;&amp; synonyms[0]))</a>
<a name="ln2090">        {</a>
<a name="ln2091">          char *text = dt_util_dstrcat(NULL, _(&quot;%s&quot;), tagname);</a>
<a name="ln2092">          text = dt_util_dstrcat(text, &quot; %s\n&quot;, (flags &amp; DT_TF_PRIVATE) ? _(&quot;(private)&quot;) : &quot;&quot;);</a>
<a name="ln2093">          text = dt_util_dstrcat(text, &quot;synonyms: %s&quot;, (synonyms &amp;&amp; synonyms[0]) ? synonyms : &quot; - &quot;);</a>
<a name="ln2094">          gtk_tooltip_set_text(tooltip, text);</a>
<a name="ln2095">          g_free(text);</a>
<a name="ln2096">          res = TRUE;</a>
<a name="ln2097">        }</a>
<a name="ln2098">        g_free(synonyms);</a>
<a name="ln2099">      }</a>
<a name="ln2100">      g_free(tagname);</a>
<a name="ln2101">    }</a>
<a name="ln2102">  }</a>
<a name="ln2103">  gtk_tree_path_free(path);</a>
<a name="ln2104"> </a>
<a name="ln2105">  return res;</a>
<a name="ln2106">}</a>
<a name="ln2107"> </a>
<a name="ln2108">static void import_button_clicked(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln2109">{</a>
<a name="ln2110">  char *last_dirname = dt_conf_get_string(&quot;plugins/lighttable/tagging/last_import_export_location&quot;);</a>
<a name="ln2111">  if(!last_dirname || !*last_dirname)</a>
<a name="ln2112">  {</a>
<a name="ln2113">    g_free(last_dirname);</a>
<a name="ln2114">    last_dirname = g_strdup(g_get_home_dir());</a>
<a name="ln2115">  }</a>
<a name="ln2116"> </a>
<a name="ln2117">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln2118">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(_(&quot;Select a keyword file&quot;), GTK_WINDOW(win),</a>
<a name="ln2119">                                                       GTK_FILE_CHOOSER_ACTION_OPEN,</a>
<a name="ln2120">                                                       _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL,</a>
<a name="ln2121">                                                       _(&quot;_import&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln2122">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln2123">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln2124">#endif</a>
<a name="ln2125">  gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(filechooser), last_dirname);</a>
<a name="ln2126">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln2127"> </a>
<a name="ln2128">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln2129">  {</a>
<a name="ln2130">    char *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln2131">    char *dirname = g_path_get_dirname(filename);</a>
<a name="ln2132">    dt_conf_set_string(&quot;plugins/lighttable/tagging/last_import_export_location&quot;, dirname);</a>
<a name="ln2133">    ssize_t count = dt_tag_import(filename);</a>
<a name="ln2134">    if(count &lt; 0)</a>
<a name="ln2135">      dt_control_log(_(&quot;error importing tags&quot;));</a>
<a name="ln2136">    else</a>
<a name="ln2137">      dt_control_log(_(&quot;%zd tags imported&quot;), count);</a>
<a name="ln2138">    g_free(filename);</a>
<a name="ln2139">    g_free(dirname);</a>
<a name="ln2140">  }</a>
<a name="ln2141"> </a>
<a name="ln2142">  g_free(last_dirname);</a>
<a name="ln2143">  gtk_widget_destroy(filechooser);</a>
<a name="ln2144">  init_treeview(self, 1);</a>
<a name="ln2145">}</a>
<a name="ln2146"> </a>
<a name="ln2147">static void export_button_clicked(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln2148">{</a>
<a name="ln2149">  GDateTime *now = g_date_time_new_now_local();</a>
<a name="ln2150">  char *export_filename = g_date_time_format(now, &quot;darktable_tags_%F_%R.txt&quot;);</a>
<a name="ln2151">  char *last_dirname = dt_conf_get_string(&quot;plugins/lighttable/tagging/last_import_export_location&quot;);</a>
<a name="ln2152">  if(!last_dirname || !*last_dirname)</a>
<a name="ln2153">  {</a>
<a name="ln2154">    g_free(last_dirname);</a>
<a name="ln2155">    last_dirname = g_strdup(g_get_home_dir());</a>
<a name="ln2156">  }</a>
<a name="ln2157"> </a>
<a name="ln2158">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln2159">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(_(&quot;Select file to export to&quot;), GTK_WINDOW(win),</a>
<a name="ln2160">                                                       GTK_FILE_CHOOSER_ACTION_SAVE,</a>
<a name="ln2161">                                                       _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL,</a>
<a name="ln2162">                                                       _(&quot;_export&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln2163">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln2164">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln2165">#endif</a>
<a name="ln2166">  gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(filechooser), TRUE);</a>
<a name="ln2167">  gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(filechooser), last_dirname);</a>
<a name="ln2168">  gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(filechooser), export_filename);</a>
<a name="ln2169"> </a>
<a name="ln2170">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln2171">  {</a>
<a name="ln2172">    char *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln2173">    char *dirname = g_path_get_dirname(filename);</a>
<a name="ln2174">    dt_conf_set_string(&quot;plugins/lighttable/tagging/last_import_export_location&quot;, dirname);</a>
<a name="ln2175">    const ssize_t count = dt_tag_export(filename);</a>
<a name="ln2176">    if(count &lt; 0)</a>
<a name="ln2177">      dt_control_log(_(&quot;error exporting tags&quot;));</a>
<a name="ln2178">    else</a>
<a name="ln2179">      dt_control_log(_(&quot;%zd tags exported&quot;), count);</a>
<a name="ln2180">    g_free(filename);</a>
<a name="ln2181">    g_free(dirname);</a>
<a name="ln2182">  }</a>
<a name="ln2183"> </a>
<a name="ln2184">  g_date_time_unref(now);</a>
<a name="ln2185">  g_free(last_dirname);</a>
<a name="ln2186">  g_free(export_filename);</a>
<a name="ln2187">  gtk_widget_destroy(filechooser);</a>
<a name="ln2188">}</a>
<a name="ln2189"> </a>
<a name="ln2190">static void update_layout(dt_lib_module_t *self)</a>
<a name="ln2191">{</a>
<a name="ln2192">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln2193">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(d-&gt;dictionary_view));</a>
<a name="ln2194"> </a>
<a name="ln2195">  const gboolean active_s = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(d-&gt;toggle_suggestion_button));</a>
<a name="ln2196">  d-&gt;suggestion_flag = !dt_conf_get_bool(&quot;plugins/lighttable/tagging/nosuggestion&quot;);</a>
<a name="ln2197">  if (active_s != d-&gt;suggestion_flag)</a>
<a name="ln2198">  {</a>
<a name="ln2199">    g_signal_handler_block (d-&gt;toggle_suggestion_button, d-&gt;suggestion_button_handler);</a>
<a name="ln2200">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;toggle_suggestion_button), d-&gt;suggestion_flag);</a>
<a name="ln2201">    g_signal_handler_unblock (d-&gt;toggle_suggestion_button, d-&gt;suggestion_button_handler);</a>
<a name="ln2202">  }</a>
<a name="ln2203"> </a>
<a name="ln2204">  const gboolean active_t = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(d-&gt;toggle_tree_button));</a>
<a name="ln2205">  d-&gt;tree_flag = dt_conf_get_bool(&quot;plugins/lighttable/tagging/treeview&quot;);</a>
<a name="ln2206">  if (active_t != d-&gt;tree_flag)</a>
<a name="ln2207">  {</a>
<a name="ln2208">    g_signal_handler_block (d-&gt;toggle_tree_button, d-&gt;tree_button_handler);</a>
<a name="ln2209">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;toggle_tree_button), d-&gt;tree_flag);</a>
<a name="ln2210">    g_signal_handler_unblock (d-&gt;toggle_tree_button, d-&gt;tree_button_handler);</a>
<a name="ln2211">  }</a>
<a name="ln2212"> </a>
<a name="ln2213">  if (d-&gt;tree_flag)</a>
<a name="ln2214">  {</a>
<a name="ln2215">    if (model == GTK_TREE_MODEL(d-&gt;dictionary_listfilter))</a>
<a name="ln2216">    {</a>
<a name="ln2217">      g_object_ref(model);</a>
<a name="ln2218">      gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;dictionary_view), NULL);</a>
<a name="ln2219">      GtkTreeModel *store = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model));</a>
<a name="ln2220">      gtk_list_store_clear(GTK_LIST_STORE(store));</a>
<a name="ln2221">      gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;dictionary_view), GTK_TREE_MODEL(d-&gt;dictionary_treefilter));</a>
<a name="ln2222">      g_object_unref(d-&gt;dictionary_treefilter);</a>
<a name="ln2223">      if (d-&gt;completion) gtk_entry_set_completion(d-&gt;entry, NULL);</a>
<a name="ln2224">    }</a>
<a name="ln2225">    gtk_widget_set_sensitive(GTK_WIDGET(d-&gt;toggle_suggestion_button), FALSE);</a>
<a name="ln2226">  }</a>
<a name="ln2227">  else</a>
<a name="ln2228">  {</a>
<a name="ln2229">    if (model == GTK_TREE_MODEL(d-&gt;dictionary_treefilter))</a>
<a name="ln2230">    {</a>
<a name="ln2231">      g_object_ref(model);</a>
<a name="ln2232">      gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;dictionary_view), NULL);</a>
<a name="ln2233">      GtkTreeModel *store = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model));</a>
<a name="ln2234">      gtk_tree_store_clear(GTK_TREE_STORE(store));</a>
<a name="ln2235">      gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;dictionary_view), GTK_TREE_MODEL(d-&gt;dictionary_listfilter));</a>
<a name="ln2236">      g_object_unref(d-&gt;dictionary_listfilter);</a>
<a name="ln2237">      if (d-&gt;completion) gtk_entry_set_completion(d-&gt;entry, d-&gt;completion);</a>
<a name="ln2238">    }</a>
<a name="ln2239">    gtk_widget_set_sensitive(GTK_WIDGET(d-&gt;toggle_suggestion_button), TRUE);</a>
<a name="ln2240">  }</a>
<a name="ln2241"> </a>
<a name="ln2242">  const gboolean active_c = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(d-&gt;toggle_sort_button));</a>
<a name="ln2243">  d-&gt;sort_count_flag = dt_conf_get_bool(&quot;plugins/lighttable/tagging/listsortedbycount&quot;);</a>
<a name="ln2244">  if (active_c != d-&gt;sort_count_flag)</a>
<a name="ln2245">  {</a>
<a name="ln2246">    g_signal_handler_block (d-&gt;toggle_sort_button, d-&gt;sort_button_handler);</a>
<a name="ln2247">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;toggle_sort_button), d-&gt;sort_count_flag);</a>
<a name="ln2248">    g_signal_handler_unblock (d-&gt;toggle_sort_button, d-&gt;sort_button_handler);</a>
<a name="ln2249">  }</a>
<a name="ln2250"> </a>
<a name="ln2251">  const gboolean active_h = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(d-&gt;toggle_hide_button));</a>
<a name="ln2252">  d-&gt;hide_path_flag = dt_conf_get_bool(&quot;plugins/lighttable/tagging/hidehierarchy&quot;);</a>
<a name="ln2253">  if (active_h != d-&gt;hide_path_flag)</a>
<a name="ln2254">  {</a>
<a name="ln2255">    g_signal_handler_block (d-&gt;toggle_hide_button, d-&gt;hide_button_handler);</a>
<a name="ln2256">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;toggle_hide_button), d-&gt;hide_path_flag);</a>
<a name="ln2257">    g_signal_handler_unblock (d-&gt;toggle_hide_button, d-&gt;hide_button_handler);</a>
<a name="ln2258">  }</a>
<a name="ln2259">}</a>
<a name="ln2260"> </a>
<a name="ln2261">static void toggle_suggestion_button_callback(GtkToggleButton *source, dt_lib_module_t *self)</a>
<a name="ln2262">{</a>
<a name="ln2263">  if (dt_conf_get_bool(&quot;plugins/lighttable/tagging/nosuggestion&quot;))</a>
<a name="ln2264">  {</a>
<a name="ln2265">    dt_conf_set_bool(&quot;plugins/lighttable/tagging/nosuggestion&quot;, FALSE);</a>
<a name="ln2266">  }</a>
<a name="ln2267">  else</a>
<a name="ln2268">  {</a>
<a name="ln2269">    dt_conf_set_bool(&quot;plugins/lighttable/tagging/nosuggestion&quot;, TRUE);</a>
<a name="ln2270">  }</a>
<a name="ln2271">  update_layout(self);</a>
<a name="ln2272">  init_treeview(self, 1);</a>
<a name="ln2273">}</a>
<a name="ln2274"> </a>
<a name="ln2275">static void toggle_tree_button_callback(GtkToggleButton *source, dt_lib_module_t *self)</a>
<a name="ln2276">{</a>
<a name="ln2277">  if (dt_conf_get_bool(&quot;plugins/lighttable/tagging/treeview&quot;))</a>
<a name="ln2278">  {</a>
<a name="ln2279">    dt_conf_set_bool(&quot;plugins/lighttable/tagging/treeview&quot;, FALSE);</a>
<a name="ln2280">  }</a>
<a name="ln2281">  else</a>
<a name="ln2282">  {</a>
<a name="ln2283">    dt_conf_set_bool(&quot;plugins/lighttable/tagging/treeview&quot;, TRUE);</a>
<a name="ln2284">  }</a>
<a name="ln2285">  update_layout(self);</a>
<a name="ln2286">  init_treeview(self, 1);</a>
<a name="ln2287">}</a>
<a name="ln2288"> </a>
<a name="ln2289">static gint sort_tree_count_func(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, dt_lib_module_t *self)</a>
<a name="ln2290">{</a>
<a name="ln2291">  guint count_a = 0;</a>
<a name="ln2292">  guint count_b = 0;</a>
<a name="ln2293">  gtk_tree_model_get(model, a, DT_LIB_TAGGING_COL_COUNT, &amp;count_a, -1);</a>
<a name="ln2294">  gtk_tree_model_get(model, b, DT_LIB_TAGGING_COL_COUNT, &amp;count_b, -1);</a>
<a name="ln2295">  return (count_b - count_a);</a>
<a name="ln2296">}</a>
<a name="ln2297"> </a>
<a name="ln2298">static gint sort_tree_tag_func(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, dt_lib_module_t *self)</a>
<a name="ln2299">{</a>
<a name="ln2300">  char *tag_a = 0;</a>
<a name="ln2301">  char *tag_b = 0;</a>
<a name="ln2302">  gtk_tree_model_get(model, a, DT_LIB_TAGGING_COL_TAG, &amp;tag_a, -1);</a>
<a name="ln2303">  gtk_tree_model_get(model, b, DT_LIB_TAGGING_COL_TAG, &amp;tag_b, -1);</a>
<a name="ln2304">  const gboolean sort = g_ascii_strcasecmp(tag_a, tag_b);</a>
<a name="ln2305">  g_free(tag_a);</a>
<a name="ln2306">  g_free(tag_b);</a>
<a name="ln2307">  return sort;</a>
<a name="ln2308">}</a>
<a name="ln2309"> </a>
<a name="ln2310">static gint sort_tree_path_func(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, dt_lib_module_t *self)</a>
<a name="ln2311">{</a>
<a name="ln2312">  char *tag_a = 0;</a>
<a name="ln2313">  char *tag_b = 0;</a>
<a name="ln2314">  gtk_tree_model_get(model, a, DT_LIB_TAGGING_COL_PATH, &amp;tag_a, -1);</a>
<a name="ln2315">  gtk_tree_model_get(model, b, DT_LIB_TAGGING_COL_PATH, &amp;tag_b, -1);</a>
<a name="ln2316">  for(char *letter = tag_a; *letter; letter++)</a>
<a name="ln2317">    if(*letter == '|') *letter = '\1';</a>
<a name="ln2318">  for(char *letter = tag_b; *letter; letter++)</a>
<a name="ln2319">    if(*letter == '|') *letter = '\1';</a>
<a name="ln2320">  const gboolean sort = g_ascii_strcasecmp(tag_a, tag_b);</a>
<a name="ln2321">  g_free(tag_a);</a>
<a name="ln2322">  g_free(tag_b);</a>
<a name="ln2323">  return sort;</a>
<a name="ln2324">}</a>
<a name="ln2325"> </a>
<a name="ln2326">static void toggle_sort_button_callback(GtkToggleButton *source, dt_lib_module_t *self)</a>
<a name="ln2327">{</a>
<a name="ln2328">  if (dt_conf_get_bool(&quot;plugins/lighttable/tagging/listsortedbycount&quot;))</a>
<a name="ln2329">  {</a>
<a name="ln2330">    dt_conf_set_bool(&quot;plugins/lighttable/tagging/listsortedbycount&quot;, FALSE);</a>
<a name="ln2331">  }</a>
<a name="ln2332">  else</a>
<a name="ln2333">  {</a>
<a name="ln2334">    dt_conf_set_bool(&quot;plugins/lighttable/tagging/listsortedbycount&quot;, TRUE);</a>
<a name="ln2335">  }</a>
<a name="ln2336">  update_layout(self);</a>
<a name="ln2337">  sort_attached_list(self, FALSE);</a>
<a name="ln2338">  sort_dictionary_list(self, FALSE);</a>
<a name="ln2339">}</a>
<a name="ln2340"> </a>
<a name="ln2341">static void toggle_hide_button_callback(GtkToggleButton *source, dt_lib_module_t *self)</a>
<a name="ln2342">{</a>
<a name="ln2343">  if (dt_conf_get_bool(&quot;plugins/lighttable/tagging/hidehierarchy&quot;))</a>
<a name="ln2344">  {</a>
<a name="ln2345">    dt_conf_set_bool(&quot;plugins/lighttable/tagging/hidehierarchy&quot;, FALSE);</a>
<a name="ln2346">  }</a>
<a name="ln2347">  else</a>
<a name="ln2348">  {</a>
<a name="ln2349">    dt_conf_set_bool(&quot;plugins/lighttable/tagging/hidehierarchy&quot;, TRUE);</a>
<a name="ln2350">  }</a>
<a name="ln2351">  update_layout(self);</a>
<a name="ln2352">  sort_attached_list(self, TRUE);</a>
<a name="ln2353">  sort_dictionary_list(self, TRUE);</a>
<a name="ln2354">}</a>
<a name="ln2355"> </a>
<a name="ln2356">static void toggle_dttags_button_callback(GtkToggleButton *source, dt_lib_module_t *self)</a>
<a name="ln2357">{</a>
<a name="ln2358">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln2359">  d-&gt;dttags_flag = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(d-&gt;toggle_dttags_button));</a>
<a name="ln2360">  init_treeview(self, 0);</a>
<a name="ln2361">}</a>
<a name="ln2362"> </a>
<a name="ln2363">void gui_reset(dt_lib_module_t *self)</a>
<a name="ln2364">{</a>
<a name="ln2365">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln2366">  // clear entry box and query</a>
<a name="ln2367">  gtk_entry_set_text(d-&gt;entry, &quot;&quot;);</a>
<a name="ln2368">  set_keyword(self);</a>
<a name="ln2369">  init_treeview(self, 1);</a>
<a name="ln2370">}</a>
<a name="ln2371"> </a>
<a name="ln2372">int position()</a>
<a name="ln2373">{</a>
<a name="ln2374">  return 500;</a>
<a name="ln2375">}</a>
<a name="ln2376"> </a>
<a name="ln2377">static gboolean _match_selected_func(GtkEntryCompletion *completion, GtkTreeModel *model, GtkTreeIter *iter, gpointer user_data)</a>
<a name="ln2378">{</a>
<a name="ln2379">  const int column = gtk_entry_completion_get_text_column(completion);</a>
<a name="ln2380">  char *tag = NULL;</a>
<a name="ln2381"> </a>
<a name="ln2382">  if(gtk_tree_model_get_column_type(model, column) != G_TYPE_STRING) return TRUE;</a>
<a name="ln2383"> </a>
<a name="ln2384">  GtkEditable *e = (GtkEditable *)gtk_entry_completion_get_entry(completion);</a>
<a name="ln2385">  if(!GTK_IS_EDITABLE(e))</a>
<a name="ln2386">  {</a>
<a name="ln2387">    return FALSE;</a>
<a name="ln2388">  }</a>
<a name="ln2389"> </a>
<a name="ln2390">  gtk_tree_model_get(model, iter, column, &amp;tag, -1);</a>
<a name="ln2391"> </a>
<a name="ln2392">  gint cut_off, cur_pos = gtk_editable_get_position(e);</a>
<a name="ln2393"> </a>
<a name="ln2394">  gchar *currentText = gtk_editable_get_chars(e, 0, -1);</a>
<a name="ln2395">  const gchar *lastTag = g_strrstr(currentText, &quot;,&quot;);</a>
<a name="ln2396">  if(lastTag == NULL)</a>
<a name="ln2397">  {</a>
<a name="ln2398">    cut_off = 0;</a>
<a name="ln2399">  }</a>
<a name="ln2400">  else</a>
<a name="ln2401">  {</a>
<a name="ln2402">    cut_off = (int)(g_utf8_strlen(currentText, -1) - g_utf8_strlen(lastTag, -1))+1;</a>
<a name="ln2403">  }</a>
<a name="ln2404">  free(currentText);</a>
<a name="ln2405"> </a>
<a name="ln2406">  gtk_editable_delete_text(e, cut_off, cur_pos);</a>
<a name="ln2407">  cur_pos = cut_off;</a>
<a name="ln2408">  gtk_editable_insert_text(e, tag, -1, &amp;cur_pos);</a>
<a name="ln2409">  gtk_editable_set_position(e, cur_pos);</a>
<a name="ln2410">  return TRUE;</a>
<a name="ln2411">}</a>
<a name="ln2412"> </a>
<a name="ln2413">static gboolean _completion_match_func(GtkEntryCompletion *completion, const gchar *key, GtkTreeIter *iter,</a>
<a name="ln2414">                                       gpointer user_data)</a>
<a name="ln2415">{</a>
<a name="ln2416">  gboolean res = FALSE;</a>
<a name="ln2417"> </a>
<a name="ln2418">  GtkEditable *e = (GtkEditable *)gtk_entry_completion_get_entry(completion);</a>
<a name="ln2419"> </a>
<a name="ln2420">  if(!GTK_IS_EDITABLE(e))</a>
<a name="ln2421">  {</a>
<a name="ln2422">    return FALSE;</a>
<a name="ln2423">  }</a>
<a name="ln2424"> </a>
<a name="ln2425">  const gint cur_pos = gtk_editable_get_position(e);</a>
<a name="ln2426">  const gboolean onLastTag = (g_strstr_len(&amp;key[cur_pos], -1, &quot;,&quot;) == NULL);</a>
<a name="ln2427">  if(!onLastTag)</a>
<a name="ln2428">  {</a>
<a name="ln2429">    return FALSE;</a>
<a name="ln2430">  }</a>
<a name="ln2431"> </a>
<a name="ln2432">  GtkTreeModel *model = gtk_entry_completion_get_model(completion);</a>
<a name="ln2433">  const int column = gtk_entry_completion_get_text_column(completion);</a>
<a name="ln2434">  char *tag = NULL;</a>
<a name="ln2435"> </a>
<a name="ln2436">  if(gtk_tree_model_get_column_type(model, column) != G_TYPE_STRING)</a>
<a name="ln2437">  {</a>
<a name="ln2438">    return FALSE;</a>
<a name="ln2439">  }</a>
<a name="ln2440"> </a>
<a name="ln2441">  gtk_tree_model_get(model, iter, column, &amp;tag, -1);</a>
<a name="ln2442"> </a>
<a name="ln2443">  const gchar *lastTag = g_strrstr(key, &quot;,&quot;);</a>
<a name="ln2444">  if(lastTag != NULL)</a>
<a name="ln2445">  {</a>
<a name="ln2446">    lastTag++;</a>
<a name="ln2447">  }</a>
<a name="ln2448">  else</a>
<a name="ln2449">  {</a>
<a name="ln2450">    lastTag = key;</a>
<a name="ln2451">  }</a>
<a name="ln2452">  if(lastTag[0] == '\0' &amp;&amp; key[0] != '\0')</a>
<a name="ln2453">  {</a>
<a name="ln2454">    return FALSE;</a>
<a name="ln2455">  }</a>
<a name="ln2456"> </a>
<a name="ln2457">  if(tag)</a>
<a name="ln2458">  {</a>
<a name="ln2459">    char *normalized = g_utf8_normalize(tag, -1, G_NORMALIZE_ALL);</a>
<a name="ln2460">    if(normalized)</a>
<a name="ln2461">    {</a>
<a name="ln2462">      char *casefold = g_utf8_casefold(normalized, -1);</a>
<a name="ln2463">      if(casefold)</a>
<a name="ln2464">      {</a>
<a name="ln2465">        res = g_strstr_len(casefold, -1, lastTag) != NULL;</a>
<a name="ln2466">      }</a>
<a name="ln2467">      g_free(casefold);</a>
<a name="ln2468">    }</a>
<a name="ln2469">    g_free(normalized);</a>
<a name="ln2470">    g_free(tag);</a>
<a name="ln2471">  }</a>
<a name="ln2472"> </a>
<a name="ln2473">  return res;</a>
<a name="ln2474">}</a>
<a name="ln2475"> </a>
<a name="ln2476">void gui_init(dt_lib_module_t *self)</a>
<a name="ln2477">{</a>
<a name="ln2478">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)malloc(sizeof(dt_lib_tagging_t));</a>
<a name="ln2479">  self-&gt;data = (void *)d;</a>
<a name="ln2480">  d-&gt;imgsel = -1;</a>
<a name="ln2481"> </a>
<a name="ln2482">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln2483">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln2484"> </a>
<a name="ln2485">  GtkBox *box, *hbox;</a>
<a name="ln2486">  GtkWidget *button;</a>
<a name="ln2487">  GtkWidget *w;</a>
<a name="ln2488">  GtkTreeView *view;</a>
<a name="ln2489">  GtkTreeModel *model;</a>
<a name="ln2490">  GtkListStore *liststore;</a>
<a name="ln2491">  GtkTreeStore *treestore;</a>
<a name="ln2492">  GtkTreeViewColumn *col;</a>
<a name="ln2493">  GtkCellRenderer *renderer;</a>
<a name="ln2494">  gint height;</a>
<a name="ln2495"> </a>
<a name="ln2496">  // attached_view</a>
<a name="ln2497">  box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));</a>
<a name="ln2498"> </a>
<a name="ln2499">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(box), TRUE, TRUE, 0);</a>
<a name="ln2500">  w = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln2501">  d-&gt;attached_window = w;</a>
<a name="ln2502">  height = dt_conf_get_int(&quot;plugins/lighttable/tagging/heightattachedwindow&quot;);</a>
<a name="ln2503">  gtk_widget_set_size_request(w, -1, DT_PIXEL_APPLY_DPI(height ? height : 100));</a>
<a name="ln2504">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(w), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln2505">  gtk_box_pack_start(box, w, TRUE, TRUE, 0);</a>
<a name="ln2506">  view = GTK_TREE_VIEW(gtk_tree_view_new());</a>
<a name="ln2507">  d-&gt;attached_view = view;</a>
<a name="ln2508">  gtk_tree_view_set_headers_visible(view, FALSE);</a>
<a name="ln2509">  liststore = gtk_list_store_new(DT_LIB_TAGGING_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING,</a>
<a name="ln2510">                                G_TYPE_STRING, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_BOOLEAN);</a>
<a name="ln2511">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(liststore), DT_TAG_SORT_PATH_ID,</a>
<a name="ln2512">                  (GtkTreeIterCompareFunc)sort_tree_path_func, self, NULL);</a>
<a name="ln2513">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(liststore), DT_TAG_SORT_NAME_ID,</a>
<a name="ln2514">                  (GtkTreeIterCompareFunc)sort_tree_tag_func, self, NULL);</a>
<a name="ln2515">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(liststore), DT_TAG_SORT_COUNT_ID,</a>
<a name="ln2516">                  (GtkTreeIterCompareFunc)sort_tree_count_func, self, NULL);</a>
<a name="ln2517">  d-&gt;attached_liststore = liststore;</a>
<a name="ln2518">  g_object_set(G_OBJECT(view), &quot;has-tooltip&quot;, TRUE, NULL);</a>
<a name="ln2519">  g_signal_connect(G_OBJECT(view), &quot;query-tooltip&quot;, G_CALLBACK(row_tooltip_setup), (gpointer)self);</a>
<a name="ln2520"> </a>
<a name="ln2521">  col = gtk_tree_view_column_new();</a>
<a name="ln2522">  gtk_tree_view_append_column(view, col);</a>
<a name="ln2523">  renderer = gtk_cell_renderer_toggle_new();</a>
<a name="ln2524">  gtk_tree_view_column_pack_start(col, renderer, TRUE);</a>
<a name="ln2525">  gtk_tree_view_column_set_cell_data_func(col, renderer, tree_select_show, NULL, NULL);</a>
<a name="ln2526">  g_object_set(renderer, &quot;indicator-size&quot;, 8, NULL);  // too big by default</a>
<a name="ln2527"> </a>
<a name="ln2528">  col = gtk_tree_view_column_new();</a>
<a name="ln2529">  gtk_tree_view_append_column(view, col);</a>
<a name="ln2530">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln2531">  gtk_tree_view_column_pack_start(col, renderer, TRUE);</a>
<a name="ln2532">  gtk_tree_view_column_set_cell_data_func(col, renderer, tree_tagname_show_attached, (gpointer)self, NULL);</a>
<a name="ln2533"> </a>
<a name="ln2534">  gtk_tree_selection_set_mode(gtk_tree_view_get_selection(view), GTK_SELECTION_SINGLE);</a>
<a name="ln2535">  gtk_tree_view_set_model(view, GTK_TREE_MODEL(liststore));</a>
<a name="ln2536">  g_object_unref(liststore);</a>
<a name="ln2537">  gtk_widget_set_tooltip_text(GTK_WIDGET(view), _(&quot;attached tags,\ndouble-click to detach&quot;</a>
<a name="ln2538">                                                  &quot;\nright-click for other actions on attached tag,&quot;</a>
<a name="ln2539">                                                  &quot;\nctrl-wheel scroll to resize the window&quot;));</a>
<a name="ln2540">  dt_gui_add_help_link(GTK_WIDGET(view), &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2541">  g_signal_connect(G_OBJECT(view), &quot;button-press-event&quot;, G_CALLBACK(click_on_view_attached), (gpointer)self);</a>
<a name="ln2542">  g_signal_connect(G_OBJECT(view), &quot;scroll-event&quot;, G_CALLBACK(mouse_scroll_attached), (gpointer)self);</a>
<a name="ln2543">  gtk_container_add(GTK_CONTAINER(w), GTK_WIDGET(view));</a>
<a name="ln2544"> </a>
<a name="ln2545">  // attach/detach buttons</a>
<a name="ln2546">  hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln2547"> </a>
<a name="ln2548">  button = gtk_button_new_with_label(_(&quot;attach&quot;));</a>
<a name="ln2549">  d-&gt;attach_button = button;</a>
<a name="ln2550">  gtk_widget_set_hexpand(button, TRUE);</a>
<a name="ln2551">  gtk_widget_set_tooltip_text(button, _(&quot;attach tag to all selected images&quot;));</a>
<a name="ln2552">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2553">  gtk_box_pack_start(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln2554">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(attach_button_clicked), (gpointer)self);</a>
<a name="ln2555"> </a>
<a name="ln2556">  button = gtk_button_new_with_label(_(&quot;detach&quot;));</a>
<a name="ln2557">  d-&gt;detach_button = button;</a>
<a name="ln2558">  gtk_widget_set_hexpand(button, TRUE);</a>
<a name="ln2559">  gtk_widget_set_tooltip_text(button, _(&quot;detach tag from all selected images&quot;));</a>
<a name="ln2560">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2561">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(detach_button_clicked), (gpointer)self);</a>
<a name="ln2562">  gtk_box_pack_start(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln2563"> </a>
<a name="ln2564">  button = dtgtk_togglebutton_new(dtgtk_cairo_paint_minus_simple, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2565">  d-&gt;toggle_hide_button = button;</a>
<a name="ln2566">  gtk_widget_set_tooltip_text(button, _(&quot;toggle list with / without hierarchy&quot;));</a>
<a name="ln2567">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2568">  gtk_box_pack_end(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln2569">  d-&gt;hide_button_handler = g_signal_connect(G_OBJECT(button), &quot;clicked&quot;,</a>
<a name="ln2570">                                            G_CALLBACK(toggle_hide_button_callback), (gpointer)self);</a>
<a name="ln2571"> </a>
<a name="ln2572">  button = dtgtk_togglebutton_new(dtgtk_cairo_paint_sorting, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2573">  d-&gt;toggle_sort_button = button;</a>
<a name="ln2574">  gtk_widget_set_tooltip_text(button, _(&quot;toggle sort by name or by count&quot;));</a>
<a name="ln2575">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2576">  gtk_box_pack_end(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln2577">  d-&gt;sort_button_handler = g_signal_connect(G_OBJECT(button), &quot;clicked&quot;,</a>
<a name="ln2578">                                            G_CALLBACK(toggle_sort_button_callback), (gpointer)self);</a>
<a name="ln2579"> </a>
<a name="ln2580">  button = dtgtk_togglebutton_new(dtgtk_cairo_paint_check_mark, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2581">  d-&gt;toggle_dttags_button = button;</a>
<a name="ln2582">  d-&gt;dttags_flag = FALSE;</a>
<a name="ln2583">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;toggle_dttags_button), FALSE);</a>
<a name="ln2584">  gtk_widget_set_tooltip_text(button, _(&quot;toggle show or not darktable tags&quot;));</a>
<a name="ln2585">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2586">  gtk_box_pack_end(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln2587">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(toggle_dttags_button_callback), (gpointer)self);</a>
<a name="ln2588"> </a>
<a name="ln2589">  gtk_box_pack_start(box, GTK_WIDGET(hbox), FALSE, TRUE, 0);</a>
<a name="ln2590"> </a>
<a name="ln2591">  // dictionary_view</a>
<a name="ln2592">  box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));</a>
<a name="ln2593">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(box), TRUE, TRUE, 0);</a>
<a name="ln2594"> </a>
<a name="ln2595">  hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln2596"> </a>
<a name="ln2597">  // text entry</a>
<a name="ln2598">  w = gtk_entry_new();</a>
<a name="ln2599">  gtk_entry_set_text(GTK_ENTRY(w), &quot;&quot;);</a>
<a name="ln2600">  gtk_widget_set_tooltip_text(w, _(&quot;enter tag name&quot;));</a>
<a name="ln2601">  dt_gui_add_help_link(w, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2602">  gtk_box_pack_start(hbox, w, TRUE, TRUE, 0);</a>
<a name="ln2603">  gtk_widget_add_events(GTK_WIDGET(w), GDK_KEY_RELEASE_MASK);</a>
<a name="ln2604">  g_signal_connect(G_OBJECT(w), &quot;changed&quot;, G_CALLBACK(tag_name_changed), (gpointer)self);</a>
<a name="ln2605">  g_signal_connect(G_OBJECT(w), &quot;activate&quot;, G_CALLBACK(entry_activated), (gpointer)self);</a>
<a name="ln2606">  d-&gt;entry = GTK_ENTRY(w);</a>
<a name="ln2607">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;entry));</a>
<a name="ln2608"> </a>
<a name="ln2609">  button = dtgtk_button_new(dtgtk_cairo_paint_multiply_small, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2610">  gtk_widget_set_tooltip_text(button, _(&quot;clear entry&quot;));</a>
<a name="ln2611">  gtk_box_pack_end(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln2612">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(clear_entry_button_callback), (gpointer)self);</a>
<a name="ln2613">  gtk_box_pack_start(box, GTK_WIDGET(hbox), FALSE, TRUE, 0);</a>
<a name="ln2614"> </a>
<a name="ln2615">  // dictionary_view tree view</a>
<a name="ln2616">  w = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln2617">  d-&gt;dictionary_window = w;</a>
<a name="ln2618">  height = dt_conf_get_int(&quot;plugins/lighttable/tagging/heightdictionarywindow&quot;);</a>
<a name="ln2619">  gtk_widget_set_size_request(w, -1, DT_PIXEL_APPLY_DPI(height ? height : 300));</a>
<a name="ln2620">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(w), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln2621">  gtk_box_pack_start(box, w, TRUE, TRUE, 0);</a>
<a name="ln2622">  view = GTK_TREE_VIEW(gtk_tree_view_new());</a>
<a name="ln2623">  d-&gt;dictionary_view = view;</a>
<a name="ln2624">  gtk_tree_view_set_headers_visible(view, FALSE);</a>
<a name="ln2625">  liststore = gtk_list_store_new(DT_LIB_TAGGING_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING,</a>
<a name="ln2626">                                G_TYPE_STRING, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_BOOLEAN);</a>
<a name="ln2627">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(liststore), DT_TAG_SORT_PATH_ID,</a>
<a name="ln2628">                  (GtkTreeIterCompareFunc)sort_tree_path_func, self, NULL);</a>
<a name="ln2629">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(liststore), DT_TAG_SORT_NAME_ID,</a>
<a name="ln2630">                  (GtkTreeIterCompareFunc)sort_tree_tag_func, self, NULL);</a>
<a name="ln2631">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(liststore), DT_TAG_SORT_COUNT_ID,</a>
<a name="ln2632">                  (GtkTreeIterCompareFunc)sort_tree_count_func, self, NULL);</a>
<a name="ln2633">  d-&gt;dictionary_liststore = liststore;</a>
<a name="ln2634">  model = gtk_tree_model_filter_new(GTK_TREE_MODEL(liststore), NULL);</a>
<a name="ln2635">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(model), DT_LIB_TAGGING_COL_VISIBLE);</a>
<a name="ln2636">  d-&gt;dictionary_listfilter = GTK_TREE_MODEL_FILTER(model);</a>
<a name="ln2637">  treestore = gtk_tree_store_new(DT_LIB_TAGGING_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING,</a>
<a name="ln2638">                                G_TYPE_STRING, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_BOOLEAN);</a>
<a name="ln2639">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(treestore), DT_TAG_SORT_PATH_ID,</a>
<a name="ln2640">                  (GtkTreeIterCompareFunc)sort_tree_path_func, self, NULL);</a>
<a name="ln2641">  d-&gt;dictionary_treestore = treestore;</a>
<a name="ln2642">  model = gtk_tree_model_filter_new(GTK_TREE_MODEL(treestore), NULL);</a>
<a name="ln2643">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(model), DT_LIB_TAGGING_COL_VISIBLE);</a>
<a name="ln2644">  d-&gt;dictionary_treefilter = GTK_TREE_MODEL_FILTER(model);</a>
<a name="ln2645"> </a>
<a name="ln2646">  col = gtk_tree_view_column_new();</a>
<a name="ln2647">  gtk_tree_view_append_column(view, col);</a>
<a name="ln2648">  renderer = gtk_cell_renderer_toggle_new();</a>
<a name="ln2649">  gtk_tree_view_column_pack_start(col, renderer, TRUE);</a>
<a name="ln2650">  gtk_cell_renderer_toggle_set_activatable(GTK_CELL_RENDERER_TOGGLE(renderer), TRUE);</a>
<a name="ln2651">  gtk_tree_view_column_set_cell_data_func(col, renderer, tree_select_show, NULL, NULL);</a>
<a name="ln2652">  g_object_set(renderer, &quot;indicator-size&quot;, 8, NULL);  // too big by default</a>
<a name="ln2653"> </a>
<a name="ln2654">  col = gtk_tree_view_column_new();</a>
<a name="ln2655">  gtk_tree_view_append_column(view, col);</a>
<a name="ln2656">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln2657">  gtk_tree_view_column_pack_start(col, renderer, TRUE);</a>
<a name="ln2658">  gtk_tree_view_column_set_cell_data_func(col, renderer, tree_tagname_show_dictionary, (gpointer)self, NULL);</a>
<a name="ln2659">  gtk_tree_view_set_expander_column(view, col);</a>
<a name="ln2660"> </a>
<a name="ln2661">  gtk_tree_selection_set_mode(gtk_tree_view_get_selection(view), GTK_SELECTION_SINGLE);</a>
<a name="ln2662">  gtk_widget_set_tooltip_text(GTK_WIDGET(view), _(&quot;tag dictionary,\ndouble-click to attach,&quot;</a>
<a name="ln2663">                                                      &quot;\nright-click for other actions on selected tag,&quot;</a>
<a name="ln2664">                                                      &quot;\nctrl-wheel scroll to resize the window&quot;));</a>
<a name="ln2665">  dt_gui_add_help_link(GTK_WIDGET(view), &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2666">  g_signal_connect(G_OBJECT(view), &quot;button-press-event&quot;, G_CALLBACK(click_on_view_dictionary), (gpointer)self);</a>
<a name="ln2667">  g_signal_connect(G_OBJECT(view), &quot;scroll-event&quot;, G_CALLBACK(mouse_scroll_dictionary), (gpointer)self);</a>
<a name="ln2668">  gtk_container_add(GTK_CONTAINER(w), GTK_WIDGET(view));</a>
<a name="ln2669">  gtk_tree_view_set_model(view, GTK_TREE_MODEL(d-&gt;dictionary_listfilter));</a>
<a name="ln2670">  g_object_unref(d-&gt;dictionary_listfilter);</a>
<a name="ln2671">  g_object_set(G_OBJECT(view), &quot;has-tooltip&quot;, TRUE, NULL);</a>
<a name="ln2672">  g_signal_connect(G_OBJECT(view), &quot;query-tooltip&quot;, G_CALLBACK(row_tooltip_setup), (gpointer)self);</a>
<a name="ln2673"> </a>
<a name="ln2674">  // buttons</a>
<a name="ln2675">  hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln2676"> </a>
<a name="ln2677">  button = gtk_button_new_with_label(_(&quot;new&quot;));</a>
<a name="ln2678">  d-&gt;new_button = button;</a>
<a name="ln2679">  gtk_widget_set_hexpand(button, TRUE);</a>
<a name="ln2680">  gtk_widget_set_tooltip_text(button, _(&quot;create a new tag with the\nname you entered&quot;));</a>
<a name="ln2681">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2682">  gtk_box_pack_start(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln2683">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(new_button_clicked), (gpointer)self);</a>
<a name="ln2684"> </a>
<a name="ln2685">  button = gtk_button_new_with_label(C_(&quot;verb&quot;, &quot;import&quot;));</a>
<a name="ln2686">  d-&gt;import_button = button;</a>
<a name="ln2687">  gtk_widget_set_hexpand(button, TRUE);</a>
<a name="ln2688">  gtk_widget_set_tooltip_text(button, _(&quot;import tags from a Lightroom keyword file&quot;));</a>
<a name="ln2689">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2690">  gtk_box_pack_start(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln2691">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_button_clicked), (gpointer)self);</a>
<a name="ln2692"> </a>
<a name="ln2693">  button = gtk_button_new_with_label(C_(&quot;verb&quot;, &quot;export&quot;));</a>
<a name="ln2694">  d-&gt;export_button = button;</a>
<a name="ln2695">  gtk_widget_set_hexpand(button, TRUE);</a>
<a name="ln2696">  gtk_widget_set_tooltip_text(button, _(&quot;export all tags to a Lightroom keyword file&quot;));</a>
<a name="ln2697">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2698">  gtk_box_pack_start(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln2699">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(export_button_clicked), (gpointer)self);</a>
<a name="ln2700"> </a>
<a name="ln2701">  button = dtgtk_togglebutton_new(dtgtk_cairo_paint_treelist, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2702">  d-&gt;toggle_tree_button = button;</a>
<a name="ln2703">  gtk_widget_set_tooltip_text(button, _(&quot;toggle list / tree view&quot;));</a>
<a name="ln2704">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2705">  gtk_box_pack_end(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln2706">  d-&gt;tree_button_handler = g_signal_connect(G_OBJECT(button), &quot;clicked&quot;,</a>
<a name="ln2707">                                            G_CALLBACK(toggle_tree_button_callback), (gpointer)self);</a>
<a name="ln2708"> </a>
<a name="ln2709">  button = dtgtk_togglebutton_new(dtgtk_cairo_paint_plus_simple, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2710">  d-&gt;toggle_suggestion_button = button;</a>
<a name="ln2711">  gtk_widget_set_tooltip_text(button, _(&quot;toggle list with / without suggestion&quot;));</a>
<a name="ln2712">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln2713">  gtk_box_pack_end(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln2714">  d-&gt;suggestion_button_handler = g_signal_connect(G_OBJECT(button), &quot;clicked&quot;,</a>
<a name="ln2715">                                            G_CALLBACK(toggle_suggestion_button_callback), (gpointer)self);</a>
<a name="ln2716"> </a>
<a name="ln2717">  gtk_box_pack_start(box, GTK_WIDGET(hbox), FALSE, TRUE, 0);</a>
<a name="ln2718"> </a>
<a name="ln2719">  if (!dt_conf_get_bool(&quot;plugins/lighttable/tagging/no_entry_completion&quot;))</a>
<a name="ln2720">  {</a>
<a name="ln2721">    // add entry completion</a>
<a name="ln2722">    GtkEntryCompletion *completion = gtk_entry_completion_new();</a>
<a name="ln2723">    gtk_entry_completion_set_model(completion, gtk_tree_view_get_model(GTK_TREE_VIEW(d-&gt;dictionary_view)));</a>
<a name="ln2724">    gtk_entry_completion_set_text_column(completion, DT_LIB_TAGGING_COL_PATH);</a>
<a name="ln2725">    gtk_entry_completion_set_inline_completion(completion, TRUE);</a>
<a name="ln2726">    gtk_entry_completion_set_match_func(completion, _completion_match_func, NULL, NULL);</a>
<a name="ln2727">    gtk_entry_set_completion(d-&gt;entry, completion);</a>
<a name="ln2728">    d-&gt;completion = completion;</a>
<a name="ln2729">  }</a>
<a name="ln2730">  else d-&gt;completion = NULL;</a>
<a name="ln2731"> </a>
<a name="ln2732">  /* connect to mouse over id */</a>
<a name="ln2733">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_MOUSE_OVER_IMAGE_CHANGE,</a>
<a name="ln2734">                            G_CALLBACK(_lib_tagging_redraw_callback), self);</a>
<a name="ln2735">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_TAG_CHANGED,</a>
<a name="ln2736">                            G_CALLBACK(_lib_tagging_tags_changed_callback), self);</a>
<a name="ln2737">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_SELECTION_CHANGED,</a>
<a name="ln2738">                            G_CALLBACK(_lib_selection_changed_callback), self);</a>
<a name="ln2739">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED,</a>
<a name="ln2740">                            G_CALLBACK(collection_updated_callback), self);</a>
<a name="ln2741"> </a>
<a name="ln2742">  d-&gt;collection = g_malloc(4096);</a>
<a name="ln2743">  update_layout(self);</a>
<a name="ln2744">  init_treeview(self, 0);</a>
<a name="ln2745">  set_keyword(self);</a>
<a name="ln2746">  init_treeview(self, 1);</a>
<a name="ln2747">}</a>
<a name="ln2748"> </a>
<a name="ln2749">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln2750">{</a>
<a name="ln2751">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln2752">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(d-&gt;entry));</a>
<a name="ln2753">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_tagging_redraw_callback), self);</a>
<a name="ln2754">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_tagging_tags_changed_callback), self);</a>
<a name="ln2755">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_selection_changed_callback), self);</a>
<a name="ln2756">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(collection_updated_callback), self);</a>
<a name="ln2757">  g_free(d-&gt;collection);</a>
<a name="ln2758">  free(self-&gt;data);</a>
<a name="ln2759">  self-&gt;data = NULL;</a>
<a name="ln2760">}</a>
<a name="ln2761"> </a>
<a name="ln2762">// http://stackoverflow.com/questions/4631388/transparent-floating-gtkentry</a>
<a name="ln2763">static gboolean _lib_tagging_tag_key_press(GtkWidget *entry, GdkEventKey *event, dt_lib_module_t *self)</a>
<a name="ln2764">{</a>
<a name="ln2765">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln2766">  switch(event-&gt;keyval)</a>
<a name="ln2767">  {</a>
<a name="ln2768">    case GDK_KEY_Escape:</a>
<a name="ln2769">      gtk_widget_destroy(d-&gt;floating_tag_window);</a>
<a name="ln2770">      return TRUE;</a>
<a name="ln2771">    case GDK_KEY_Tab:</a>
<a name="ln2772">      return TRUE;</a>
<a name="ln2773">    case GDK_KEY_Return:</a>
<a name="ln2774">    case GDK_KEY_KP_Enter:</a>
<a name="ln2775">    {</a>
<a name="ln2776">      const gchar *tag = gtk_entry_get_text(GTK_ENTRY(entry));</a>
<a name="ln2777">      // both these functions can deal with -1 for all selected images. no need for extra code in here!</a>
<a name="ln2778">      dt_tag_attach_string_list(tag, d-&gt;floating_tag_imgid);</a>
<a name="ln2779">      dt_image_synch_xmp(d-&gt;floating_tag_imgid);</a>
<a name="ln2780">      init_treeview(self, 0);</a>
<a name="ln2781">      init_treeview(self, 1);</a>
<a name="ln2782">      gtk_widget_destroy(d-&gt;floating_tag_window);</a>
<a name="ln2783">      dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln2784">      return TRUE;</a>
<a name="ln2785">    }</a>
<a name="ln2786">  }</a>
<a name="ln2787">  return FALSE; /* event not handled */</a>
<a name="ln2788">}</a>
<a name="ln2789"> </a>
<a name="ln2790">static gboolean _lib_tagging_tag_destroy(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln2791">{</a>
<a name="ln2792">  gtk_widget_destroy(GTK_WIDGET(user_data));</a>
<a name="ln2793">  return FALSE;</a>
<a name="ln2794">}</a>
<a name="ln2795"> </a>
<a name="ln2796">static gboolean _lib_tagging_tag_show(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln2797">                                      GdkModifierType modifier, dt_lib_module_t *self)</a>
<a name="ln2798">{</a>
<a name="ln2799">  const int zoom = dt_conf_get_int(&quot;plugins/lighttable/images_in_row&quot;);</a>
<a name="ln2800">  int mouse_over_id = -1;</a>
<a name="ln2801"> </a>
<a name="ln2802">  // the order is:</a>
<a name="ln2803">  // if(zoom == 1) =&gt; currently shown image</a>
<a name="ln2804">  // else if(selection not empty) =&gt; selected images</a>
<a name="ln2805">  // else if(cursor over image) =&gt; hovered image</a>
<a name="ln2806">  // else =&gt; return</a>
<a name="ln2807">  if(zoom == 1 || dt_collection_get_selected_count(darktable.collection) == 0)</a>
<a name="ln2808">  {</a>
<a name="ln2809">    mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln2810">    if(mouse_over_id &lt; 0) return TRUE;</a>
<a name="ln2811">  }</a>
<a name="ln2812"> </a>
<a name="ln2813">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln2814">  if (d-&gt;tree_flag)</a>
<a name="ln2815">  {</a>
<a name="ln2816">    dt_control_log(_(&quot;tag shortcut is not active with tag tree view. please switch to list view&quot;));</a>
<a name="ln2817">    return TRUE;  // doesn't work properly with tree treeview</a>
<a name="ln2818">  }</a>
<a name="ln2819">  d-&gt;floating_tag_imgid = mouse_over_id;</a>
<a name="ln2820"> </a>
<a name="ln2821">  gint x, y;</a>
<a name="ln2822">  gint px, py, w, h;</a>
<a name="ln2823">  GtkWidget *window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln2824">  GtkWidget *center = dt_ui_center(darktable.gui-&gt;ui);</a>
<a name="ln2825">  gdk_window_get_origin(gtk_widget_get_window(center), &amp;px, &amp;py);</a>
<a name="ln2826"> </a>
<a name="ln2827">  w = gdk_window_get_width(gtk_widget_get_window(center));</a>
<a name="ln2828">  h = gdk_window_get_height(gtk_widget_get_window(center));</a>
<a name="ln2829"> </a>
<a name="ln2830">  x = px + 0.5 * (w - FLOATING_ENTRY_WIDTH);</a>
<a name="ln2831">  y = py + h - 50;</a>
<a name="ln2832"> </a>
<a name="ln2833">  /* put the floating box at the mouse pointer */</a>
<a name="ln2834">  //   gint pointerx, pointery;</a>
<a name="ln2835">  //   GdkDevice *device =</a>
<a name="ln2836">  //   gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gtk_widget_get_display(widget)));</a>
<a name="ln2837">  //   gdk_window_get_device_position (gtk_widget_get_window (widget), device, &amp;pointerx, &amp;pointery, NULL);</a>
<a name="ln2838">  //   x = px + pointerx + 1;</a>
<a name="ln2839">  //   y = py + pointery + 1;</a>
<a name="ln2840"> </a>
<a name="ln2841">  d-&gt;floating_tag_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</a>
<a name="ln2842">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln2843">  dt_osx_disallow_fullscreen(d-&gt;floating_tag_window);</a>
<a name="ln2844">#endif</a>
<a name="ln2845">  /* stackoverflow.com/questions/1925568/how-to-give-keyboard-focus-to-a-pop-up-gtk-window */</a>
<a name="ln2846">  gtk_widget_set_can_focus(d-&gt;floating_tag_window, TRUE);</a>
<a name="ln2847">  gtk_window_set_decorated(GTK_WINDOW(d-&gt;floating_tag_window), FALSE);</a>
<a name="ln2848">  gtk_window_set_type_hint(GTK_WINDOW(d-&gt;floating_tag_window), GDK_WINDOW_TYPE_HINT_POPUP_MENU);</a>
<a name="ln2849">  gtk_window_set_transient_for(GTK_WINDOW(d-&gt;floating_tag_window), GTK_WINDOW(window));</a>
<a name="ln2850">  gtk_widget_set_opacity(d-&gt;floating_tag_window, 0.8);</a>
<a name="ln2851">  gtk_window_move(GTK_WINDOW(d-&gt;floating_tag_window), x, y);</a>
<a name="ln2852"> </a>
<a name="ln2853">  GtkWidget *entry = gtk_entry_new();</a>
<a name="ln2854">  gtk_widget_set_size_request(entry, FLOATING_ENTRY_WIDTH, -1);</a>
<a name="ln2855">  gtk_widget_add_events(entry, GDK_FOCUS_CHANGE_MASK);</a>
<a name="ln2856"> </a>
<a name="ln2857">  GtkEntryCompletion *completion = gtk_entry_completion_new();</a>
<a name="ln2858">  gtk_entry_completion_set_model(completion, gtk_tree_view_get_model(GTK_TREE_VIEW(d-&gt;dictionary_view)));</a>
<a name="ln2859">  gtk_entry_completion_set_text_column(completion, DT_LIB_TAGGING_COL_PATH);</a>
<a name="ln2860">  gtk_entry_completion_set_inline_completion(completion, TRUE);</a>
<a name="ln2861">  gtk_entry_completion_set_popup_set_width(completion, FALSE);</a>
<a name="ln2862">  g_signal_connect(G_OBJECT(completion), &quot;match-selected&quot;, G_CALLBACK(_match_selected_func), self);</a>
<a name="ln2863">  gtk_entry_completion_set_match_func(completion, _completion_match_func, NULL, NULL);</a>
<a name="ln2864">  gtk_entry_set_completion(GTK_ENTRY(entry), completion);</a>
<a name="ln2865"> </a>
<a name="ln2866">  gtk_editable_select_region(GTK_EDITABLE(entry), 0, -1);</a>
<a name="ln2867">  gtk_container_add(GTK_CONTAINER(d-&gt;floating_tag_window), entry);</a>
<a name="ln2868">  g_signal_connect(entry, &quot;focus-out-event&quot;, G_CALLBACK(_lib_tagging_tag_destroy), d-&gt;floating_tag_window);</a>
<a name="ln2869">  g_signal_connect(entry, &quot;key-press-event&quot;, G_CALLBACK(_lib_tagging_tag_key_press), self);</a>
<a name="ln2870"> </a>
<a name="ln2871">  gtk_widget_show_all(d-&gt;floating_tag_window);</a>
<a name="ln2872">  gtk_widget_grab_focus(entry);</a>
<a name="ln2873">  gtk_window_present(GTK_WINDOW(d-&gt;floating_tag_window));</a>
<a name="ln2874"> </a>
<a name="ln2875">  return TRUE;</a>
<a name="ln2876">}</a>
<a name="ln2877"> </a>
<a name="ln2878">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2879">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2880">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="819"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: buf.</p></div>
<div class="balloon" rel="2480"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 2480, 2478.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
