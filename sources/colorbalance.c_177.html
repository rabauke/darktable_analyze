
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">http://www.youtube.com/watch?v=JVoUgR6bhBc</a>
<a name="ln3"> */</a>
<a name="ln4"> </a>
<a name="ln5">/*</a>
<a name="ln6">    This file is part of darktable,</a>
<a name="ln7">    copyright (c) 2013 tobias ellinghaus.</a>
<a name="ln8">    copyright (c) 2018 Aur√©lien Pierre.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln11">    it under the terms of the GNU General Public License as published by</a>
<a name="ln12">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln13">    (at your option) any later version.</a>
<a name="ln14"> </a>
<a name="ln15">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln16">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln17">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln18">    GNU General Public License for more details.</a>
<a name="ln19"> </a>
<a name="ln20">    You should have received a copy of the GNU General Public License</a>
<a name="ln21">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln22">*/</a>
<a name="ln23">#ifdef HAVE_CONFIG_H</a>
<a name="ln24">#include &quot;config.h&quot;</a>
<a name="ln25">#endif</a>
<a name="ln26">// our includes go first:</a>
<a name="ln27">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln28">#include &quot;common/exif.h&quot;</a>
<a name="ln29">#include &quot;common/colorspaces_inline_conversions.h&quot;</a>
<a name="ln30">#include &quot;common/opencl.h&quot;</a>
<a name="ln31">#include &quot;develop/blend.h&quot;</a>
<a name="ln32">#include &quot;develop/imageop.h&quot;</a>
<a name="ln33">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln34">#include &quot;dtgtk/gradientslider.h&quot;</a>
<a name="ln35">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln36">#include &quot;gui/gtk.h&quot;</a>
<a name="ln37">#include &quot;gui/presets.h&quot;</a>
<a name="ln38">#include &quot;gui/color_picker_proxy.h&quot;</a>
<a name="ln39">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">//#include &lt;gtk/gtk.h&gt;</a>
<a name="ln42">#include &lt;stdlib.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">// these are not in a state to be useful. but they look nice. too bad i couldn't map the enhanced mode with</a>
<a name="ln45">// negative values to the wheels :(</a>
<a name="ln46">//#define SHOW_COLOR_WHEELS</a>
<a name="ln47"> </a>
<a name="ln48">DT_MODULE_INTROSPECTION(3, dt_iop_colorbalance_params_t)</a>
<a name="ln49"> </a>
<a name="ln50">/*</a>
<a name="ln51"> </a>
<a name="ln52">  Meaning of the values:</a>
<a name="ln53">   0 --&gt; 100%</a>
<a name="ln54">  -1 --&gt;   0%</a>
<a name="ln55">   1 --&gt; 200%</a>
<a name="ln56"> */</a>
<a name="ln57"> </a>
<a name="ln58">typedef enum dt_iop_colorbalance_mode_t</a>
<a name="ln59">{</a>
<a name="ln60">  LIFT_GAMMA_GAIN = 0,</a>
<a name="ln61">  SLOPE_OFFSET_POWER = 1,</a>
<a name="ln62">  LEGACY = 2</a>
<a name="ln63">} dt_iop_colorbalance_mode_t;</a>
<a name="ln64"> </a>
<a name="ln65">typedef enum _colorbalance_channel_t</a>
<a name="ln66">{</a>
<a name="ln67">  CHANNEL_FACTOR = 0,</a>
<a name="ln68">  CHANNEL_RED,</a>
<a name="ln69">  CHANNEL_GREEN,</a>
<a name="ln70">  CHANNEL_BLUE,</a>
<a name="ln71">  CHANNEL_SIZE</a>
<a name="ln72">} _colorbalance_channel_t;</a>
<a name="ln73"> </a>
<a name="ln74">typedef enum _colorbalance_levels_t</a>
<a name="ln75">{</a>
<a name="ln76">  LIFT = 0,</a>
<a name="ln77">  GAMMA,</a>
<a name="ln78">  GAIN,</a>
<a name="ln79">  LEVELS</a>
<a name="ln80">} _colorbalance_levels_t;</a>
<a name="ln81"> </a>
<a name="ln82">typedef enum _controls_t</a>
<a name="ln83">{</a>
<a name="ln84">  HSL,</a>
<a name="ln85">  RGBL,</a>
<a name="ln86">  BOTH</a>
<a name="ln87">} _controls_t;</a>
<a name="ln88"> </a>
<a name="ln89">typedef enum _colorbalance_patch_t</a>
<a name="ln90">{</a>
<a name="ln91">  INVALID,</a>
<a name="ln92">  USER_SELECTED,</a>
<a name="ln93">  AUTO_SELECTED</a>
<a name="ln94">} _colorbalance_patch_t;</a>
<a name="ln95"> </a>
<a name="ln96">typedef enum dt_iop_colorbalance_pickcolor_type_t</a>
<a name="ln97">{</a>
<a name="ln98">  DT_PICKCOLBAL_NONE = 0,</a>
<a name="ln99">  DT_PICKCOLBAL_HUE_LIFT = 1,</a>
<a name="ln100">  DT_PICKCOLBAL_HUE_GAMMA = 2,</a>
<a name="ln101">  DT_PICKCOLBAL_HUE_GAIN = 3,</a>
<a name="ln102">  DT_PICKCOLBAL_LIFT_FACTOR = 4,</a>
<a name="ln103">  DT_PICKCOLBAL_GAMMA_FACTOR = 5,</a>
<a name="ln104">  DT_PICKCOLBAL_GAIN_FACTOR = 6,</a>
<a name="ln105">  DT_PICKCOLBAL_GREY = 7,</a>
<a name="ln106">  DT_PICKCOLBAL_AUTOLUMA = 8,</a>
<a name="ln107">  DT_PICKCOLBAL_AUTOCOLOR = 9</a>
<a name="ln108">} dt_iop_colorbalance_pickcolor_type_t;</a>
<a name="ln109"> </a>
<a name="ln110">typedef struct dt_iop_colorbalance_params_t</a>
<a name="ln111">{</a>
<a name="ln112">  dt_iop_colorbalance_mode_t mode;</a>
<a name="ln113">  float lift[CHANNEL_SIZE], gamma[CHANNEL_SIZE], gain[CHANNEL_SIZE];</a>
<a name="ln114">  float saturation, contrast, grey, saturation_out;</a>
<a name="ln115">} dt_iop_colorbalance_params_t;</a>
<a name="ln116"> </a>
<a name="ln117">typedef struct dt_iop_colorbalance_gui_data_t</a>
<a name="ln118">{</a>
<a name="ln119">  dt_pthread_mutex_t lock;</a>
<a name="ln120">  GtkWidget *master_box;</a>
<a name="ln121">  GtkWidget *mode;</a>
<a name="ln122">  GtkWidget *controls;</a>
<a name="ln123">  GtkWidget *hue_lift, *hue_gamma, *hue_gain;</a>
<a name="ln124">  GtkWidget *sat_lift, *sat_gamma, *sat_gain;</a>
<a name="ln125">  GtkWidget *lift_r, *lift_g, *lift_b, *lift_factor;</a>
<a name="ln126">  GtkWidget *gamma_r, *gamma_g, *gamma_b, *gamma_factor;</a>
<a name="ln127">  GtkWidget *gain_r, *gain_g, *gain_b, *gain_factor;</a>
<a name="ln128">  GtkWidget *saturation, *contrast, *grey, *saturation_out;</a>
<a name="ln129">  GtkWidget *masterbox;</a>
<a name="ln130">  GtkWidget *optim_label;</a>
<a name="ln131">  GtkWidget *auto_luma;</a>
<a name="ln132">  GtkWidget *auto_color;</a>
<a name="ln133">  float color_patches_lift[3];</a>
<a name="ln134">  float color_patches_gamma[3];</a>
<a name="ln135">  float color_patches_gain[3];</a>
<a name="ln136">  _colorbalance_patch_t color_patches_flags[LEVELS];</a>
<a name="ln137">  float luma_patches[LEVELS];</a>
<a name="ln138">  _colorbalance_patch_t luma_patches_flags[LEVELS];</a>
<a name="ln139">  dt_iop_color_picker_t color_picker;</a>
<a name="ln140">} dt_iop_colorbalance_gui_data_t;</a>
<a name="ln141"> </a>
<a name="ln142">typedef struct dt_iop_colorbalance_data_t</a>
<a name="ln143">{</a>
<a name="ln144">  dt_iop_colorbalance_mode_t mode;</a>
<a name="ln145">  float lift[CHANNEL_SIZE], gamma[CHANNEL_SIZE], gain[CHANNEL_SIZE];</a>
<a name="ln146">  float saturation, contrast, grey, saturation_out;</a>
<a name="ln147">} dt_iop_colorbalance_data_t;</a>
<a name="ln148"> </a>
<a name="ln149">typedef struct dt_iop_colorbalance_global_data_t</a>
<a name="ln150">{</a>
<a name="ln151">  int kernel_colorbalance;</a>
<a name="ln152">  int kernel_colorbalance_cdl;</a>
<a name="ln153">  int kernel_colorbalance_lgg;</a>
<a name="ln154">} dt_iop_colorbalance_global_data_t;</a>
<a name="ln155"> </a>
<a name="ln156"> </a>
<a name="ln157">const char *name()</a>
<a name="ln158">{</a>
<a name="ln159">  return _(&quot;color balance&quot;);</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">const char *description()</a>
<a name="ln163">{</a>
<a name="ln164">  return _(&quot;lift/gamma/gain controls as seen in video editors&quot;);</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">int flags()</a>
<a name="ln168">{</a>
<a name="ln169">  return IOP_FLAGS_INCLUDE_IN_STYLES | IOP_FLAGS_SUPPORTS_BLENDING;</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">int default_group()</a>
<a name="ln173">{</a>
<a name="ln174">  return IOP_GROUP_COLOR;</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln178">{</a>
<a name="ln179">  return iop_cs_Lab;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version, void *new_params,</a>
<a name="ln183">                  const int new_version)</a>
<a name="ln184">{</a>
<a name="ln185">  if(old_version == 1 &amp;&amp; new_version == 3)</a>
<a name="ln186">  {</a>
<a name="ln187">    typedef struct dt_iop_colorbalance_params_v1_t</a>
<a name="ln188">    {</a>
<a name="ln189">      float lift[CHANNEL_SIZE], gamma[CHANNEL_SIZE], gain[CHANNEL_SIZE];</a>
<a name="ln190">    } dt_iop_colorbalance_params_v1_t;</a>
<a name="ln191"> </a>
<a name="ln192">    dt_iop_colorbalance_params_v1_t *o = (dt_iop_colorbalance_params_v1_t *)old_params;</a>
<a name="ln193">    dt_iop_colorbalance_params_t *n = (dt_iop_colorbalance_params_t *)new_params;</a>
<a name="ln194">    dt_iop_colorbalance_params_t *d = (dt_iop_colorbalance_params_t *)self-&gt;default_params;</a>
<a name="ln195"> </a>
<a name="ln196">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln197"> </a>
<a name="ln198">    for(int i = 0; i &lt; CHANNEL_SIZE; i++)</a>
<a name="ln199">    {</a>
<a name="ln200">      n-&gt;lift[i] = o-&gt;lift[i];</a>
<a name="ln201">      n-&gt;gamma[i] = o-&gt;gamma[i];</a>
<a name="ln202">      n-&gt;gain[i] = o-&gt;gain[i];</a>
<a name="ln203">    }</a>
<a name="ln204">    n-&gt;mode = LEGACY;</a>
<a name="ln205">    return 0;</a>
<a name="ln206">  }</a>
<a name="ln207"> </a>
<a name="ln208">  if(old_version == 2 &amp;&amp; new_version == 3)</a>
<a name="ln209">  {</a>
<a name="ln210">    typedef struct dt_iop_colorbalance_params_v2_t</a>
<a name="ln211">    {</a>
<a name="ln212">      dt_iop_colorbalance_mode_t mode;</a>
<a name="ln213">      float lift[CHANNEL_SIZE], gamma[CHANNEL_SIZE], gain[CHANNEL_SIZE];</a>
<a name="ln214">      float saturation, contrast, grey;</a>
<a name="ln215">    } dt_iop_colorbalance_params_v2_t;</a>
<a name="ln216"> </a>
<a name="ln217">    dt_iop_colorbalance_params_v2_t *o = (dt_iop_colorbalance_params_v2_t *)old_params;</a>
<a name="ln218">    dt_iop_colorbalance_params_t *n = (dt_iop_colorbalance_params_t *)new_params;</a>
<a name="ln219">    dt_iop_colorbalance_params_t *d = (dt_iop_colorbalance_params_t *)self-&gt;default_params;</a>
<a name="ln220"> </a>
<a name="ln221">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln222"> </a>
<a name="ln223">    for(int i = 0; i &lt; CHANNEL_SIZE; i++)</a>
<a name="ln224">    {</a>
<a name="ln225">      n-&gt;lift[i] = o-&gt;lift[i];</a>
<a name="ln226">      n-&gt;gamma[i] = o-&gt;gamma[i];</a>
<a name="ln227">      n-&gt;gain[i] = o-&gt;gain[i];</a>
<a name="ln228">    }</a>
<a name="ln229">    n-&gt;mode = o-&gt;mode;</a>
<a name="ln230">    n-&gt;contrast = o-&gt;contrast;</a>
<a name="ln231">    n-&gt;saturation = o-&gt;saturation;</a>
<a name="ln232">    n-&gt;contrast = o-&gt;contrast;</a>
<a name="ln233">    n-&gt;grey = o-&gt;grey;</a>
<a name="ln234">    return 0;</a>
<a name="ln235">  }</a>
<a name="ln236">  return 1;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">// taken from denoiseprofile.c</a>
<a name="ln240">static void add_preset(dt_iop_module_so_t *self, const char *name,</a>
<a name="ln241">                       const char *pi, const int version, const char *bpi, const int blendop_version)</a>
<a name="ln242">{</a>
<a name="ln243">  int len, blen;</a>
<a name="ln244">  uint8_t *p  = dt_exif_xmp_decode(pi, strlen(pi), &amp;len);</a>
<a name="ln245">  uint8_t *bp = dt_exif_xmp_decode(bpi, strlen(bpi), &amp;blen);</a>
<a name="ln246">  if(blendop_version != dt_develop_blend_version())</a>
<a name="ln247">  {</a>
<a name="ln248">    // update to current blendop params format</a>
<a name="ln249">    void *bp_new = malloc(sizeof(dt_develop_blend_params_t));</a>
<a name="ln250"> </a>
<a name="ln251">    if(dt_develop_blend_legacy_params_from_so(self, bp, blendop_version, bp_new, dt_develop_blend_version(),</a>
<a name="ln252">      blen) == 0)</a>
<a name="ln253">    {</a>
<a name="ln254">      free(bp);</a>
<a name="ln255">      bp = bp_new;</a>
<a name="ln256">      blen = sizeof(dt_develop_blend_params_t);</a>
<a name="ln257">    }</a>
<a name="ln258">    else</a>
<a name="ln259">    {</a>
<a name="ln260">      free(bp);</a>
<a name="ln261">      free(bp_new);</a>
<a name="ln262">      bp = NULL;</a>
<a name="ln263">    }</a>
<a name="ln264">  }</a>
<a name="ln265"> </a>
<a name="ln266">  if(p &amp;&amp; bp)</a>
<a name="ln267">    dt_gui_presets_add_with_blendop(name, self-&gt;op, version, p, len, bp, 1);</a>
<a name="ln268">  free(bp);</a>
<a name="ln269">  free(p);</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">void init_presets(dt_iop_module_so_t *self)</a>
<a name="ln273">{</a>
<a name="ln274">  // these blobs were exported as dtstyle and copied from there:</a>
<a name="ln275">  add_preset(self, _(&quot;split-toning teal-orange (2nd instance)&quot;),</a>
<a name="ln276">             &quot;gz02eJxjZGBg8HhYZX99cYN9kkCDfdCOOnsGhgZ7ruvN9m8CK+yXFNTaz5w50z5PqBku9u9/PVjNv//9jqfP+NgDAHs0HIc=&quot;, 3,</a>
<a name="ln277">             &quot;gz05eJxjZWBgYGUAgRNODFDAzszAxMBQ5cwI4Tow4AUNdkBsD8E3gGwue9x8uB6q8s+c8bEF8Z9Y9Nnt2f3bbluCN03tg/EBIBckVg==&quot;, 8);</a>
<a name="ln278">  add_preset(self, _(&quot;split-toning teal-orange (1st instance)&quot;),</a>
<a name="ln279">             &quot;gz02eJxjZACBBvugHXX2E3fU219f3GAP4n/TqLFvfd1oL8HZaH/2jI/9prn1cLHUtDSwGgaGCY7//tfbAwBRixpm&quot;, 3,</a>
<a name="ln280">             &quot;gz04eJxjZWBgYGUAgRNODFDApgwiq5wZIVyHD4E7bBnwggZ7CIYBRiBbBA8fXT1l/P5DX21i+pnA/Pfv8uw6OzzIMq9I5rgtSH//4wii1AMASbIlcw==&quot;, 8);</a>
<a name="ln281"> </a>
<a name="ln282">  add_preset(self, _(&quot;generic film&quot;),</a>
<a name="ln283">             &quot;gz02eJxjZACBBntN5gb7op/19u5AGsSX3dFgr+jYaL+vttb+0NcM+1Pnq+3XyFTZr/rYBJZPS0sD0hMcQDQA29kXSQ==&quot;, 3,</a>
<a name="ln284">             &quot;gz11eJxjYGBgkGAAgRNODGiAEV0AJ2iwh+CRxQcA5qIZBA==&quot;, 8);</a>
<a name="ln285"> </a>
<a name="ln286">  add_preset(self, _(&quot;similar to Kodak Portra&quot;),</a>
<a name="ln287">             &quot;gz02eJxjZACBBnsQfh3YYK8VU28P43s8rLKP6W+yP/Q1w36deyMYLymoBcsZGxcDaQGHs2d87AGnphWu&quot;, 3,</a>
<a name="ln288">             &quot;gz11eJxjYGBgkGAAgRNODGiAEV0AJ2iwh+CRxQcA5qIZBA==&quot;, 8);</a>
<a name="ln289"> </a>
<a name="ln290">  add_preset(self, _(&quot;similar to Kodak Ektar&quot;),</a>
<a name="ln291">             &quot;gz02eJxjZACBBvvrixvsrXIb7IN21NnD+CA2iOa6nmxvZFxsX15ebp+e1gaWNwbyGRgEHNLS0uwBE7wWhw==&quot;, 3,</a>
<a name="ln292">             &quot;gz11eJxjYGBgkGAAgRNODGiAEV0AJ2iwh+CRxQcA5qIZBA==&quot;, 8);</a>
<a name="ln293"> </a>
<a name="ln294">  add_preset(self, _(&quot;similar to Kodachrome&quot;),</a>
<a name="ln295">             &quot;gz02eJxjZACBBvvrixvsrXIb7IN21NnD+CA2iG59HWhvZFxsX15ebp+e1gaWT0tLA9ICDrNmRtoDACjOF7c=&quot;, 3,</a>
<a name="ln296">             &quot;gz11eJxjYGBgkGAAgRNODGiAEV0AJ2iwh+CRxQcA5qIZBA==&quot;, 8);</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln300">{</a>
<a name="ln301">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;mode&quot;));</a>
<a name="ln302">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;controls&quot;));</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln306">{</a>
<a name="ln307">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln308"> </a>
<a name="ln309">  dt_accel_connect_slider_iop(self, &quot;mode&quot;, GTK_WIDGET(g-&gt;mode));</a>
<a name="ln310">  dt_accel_connect_slider_iop(self, &quot;controls&quot;, GTK_WIDGET(g-&gt;controls));</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313">static inline float CDL(float x, float slope, float offset, float power)</a>
<a name="ln314">{</a>
<a name="ln315">  float out;</a>
<a name="ln316">  out = slope * x + offset;</a>
<a name="ln317">  out = (out &lt;= 0.0f) ? 0.0f : powf(out, power);</a>
<a name="ln318">  return out;</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">// see http://www.brucelindbloom.com/Eqn_RGB_XYZ_Matrix.html for the transformation matrices</a>
<a name="ln322">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln323">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln324">{</a>
<a name="ln325">  dt_iop_colorbalance_data_t *d = (dt_iop_colorbalance_data_t *)piece-&gt;data;</a>
<a name="ln326">  const int ch = piece-&gt;colors;</a>
<a name="ln327"> </a>
<a name="ln328">  // these are RGB values!</a>
<a name="ln329">  const float gain[3] = { d-&gt;gain[CHANNEL_RED] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln330">                          d-&gt;gain[CHANNEL_GREEN] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln331">                          d-&gt;gain[CHANNEL_BLUE] * d-&gt;gain[CHANNEL_FACTOR] },</a>
<a name="ln332">              contrast = (d-&gt;contrast != 0.0f) ? 1.0f / d-&gt;contrast : 1000000.0f,</a>
<a name="ln333">              grey = d-&gt;grey / 100.0f;</a>
<a name="ln334"> </a>
<a name="ln335">  // For neutral parameters, skip the computations doing x^1 or (x-a)*1 + a to save time</a>
<a name="ln336">  const int run_contrast = (d-&gt;contrast == 1.0f) ? 0 : 1;</a>
<a name="ln337">  const int run_saturation = (d-&gt;saturation == 1.0f) ? 0: 1;</a>
<a name="ln338">  const int run_saturation_out = (d-&gt;saturation_out == 1.0f) ? 0: 1;</a>
<a name="ln339"> </a>
<a name="ln340">  switch (d-&gt;mode)</a>
<a name="ln341">  {</a>
<a name="ln342">    case LEGACY:</a>
<a name="ln343">    {</a>
<a name="ln344">      // these are RGB values!</a>
<a name="ln345">      const float lift[3] = { 2.0 - (d-&gt;lift[CHANNEL_RED] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln346">                              2.0 - (d-&gt;lift[CHANNEL_GREEN] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln347">                              2.0 - (d-&gt;lift[CHANNEL_BLUE] * d-&gt;lift[CHANNEL_FACTOR]) },</a>
<a name="ln348">                 gamma[3] = { d-&gt;gamma[CHANNEL_RED] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln349">                              d-&gt;gamma[CHANNEL_GREEN] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln350">                              d-&gt;gamma[CHANNEL_BLUE] * d-&gt;gamma[CHANNEL_FACTOR] },</a>
<a name="ln351">             gamma_inv[3] = { (gamma[0] != 0.0) ? 1.0 / gamma[0] : 1000000.0,</a>
<a name="ln352">                              (gamma[1] != 0.0) ? 1.0 / gamma[1] : 1000000.0,</a>
<a name="ln353">                              (gamma[2] != 0.0) ? 1.0 / gamma[2] : 1000000.0 };</a>
<a name="ln354"> </a>
<a name="ln355">#ifdef _OPENMP</a>
<a name="ln356">#pragma omp parallel for SIMD() default(none) shared(d) schedule(static)</a>
<a name="ln357">#endif</a>
<a name="ln358">      for(size_t k = 0; k &lt; (size_t)ch * roi_in-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln359">      {</a>
<a name="ln360">        float *in = ((float *)ivoid) + k;</a>
<a name="ln361">        float *out = ((float *)ovoid) + k;</a>
<a name="ln362"> </a>
<a name="ln363">        // transform the pixel to sRGB:</a>
<a name="ln364">        // Lab -&gt; XYZ</a>
<a name="ln365">        float XYZ[3] = { 0.0f };</a>
<a name="ln366">        dt_Lab_to_XYZ(in, XYZ);</a>
<a name="ln367"> </a>
<a name="ln368">        // XYZ -&gt; sRGB</a>
<a name="ln369">        float rgb[3] = { 0.0f };</a>
<a name="ln370">        dt_XYZ_to_sRGB(XYZ, rgb);</a>
<a name="ln371"> </a>
<a name="ln372">        // do the calculation in RGB space</a>
<a name="ln373">        for(int c = 0; c &lt; 3; c++)</a>
<a name="ln374">        {</a>
<a name="ln375">          // lift gamma gain</a>
<a name="ln376">          rgb[c] = ((( rgb[c]  - 1.0f) * lift[c]) + 1.0f) * gain[c];</a>
<a name="ln377">          rgb[c] = (rgb[c] &lt; 0.0f) ? 0.0f : powf(rgb[c], gamma_inv[c]);</a>
<a name="ln378">        }</a>
<a name="ln379"> </a>
<a name="ln380">        // transform the result back to Lab</a>
<a name="ln381">        // sRGB -&gt; XYZ</a>
<a name="ln382">        dt_sRGB_to_XYZ(rgb, XYZ);</a>
<a name="ln383"> </a>
<a name="ln384">        // XYZ -&gt; Lab</a>
<a name="ln385">        dt_XYZ_to_Lab(XYZ, out);</a>
<a name="ln386">      }</a>
<a name="ln387">      break;</a>
<a name="ln388">    }</a>
<a name="ln389">    case LIFT_GAMMA_GAIN:</a>
<a name="ln390">    {</a>
<a name="ln391">      // these are RGB values!</a>
<a name="ln392">      const float lift[3] = { 2.0 - (d-&gt;lift[CHANNEL_RED] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln393">                              2.0 - (d-&gt;lift[CHANNEL_GREEN] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln394">                              2.0 - (d-&gt;lift[CHANNEL_BLUE] * d-&gt;lift[CHANNEL_FACTOR]) },</a>
<a name="ln395">                 gamma[3] = { d-&gt;gamma[CHANNEL_RED] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln396">                              d-&gt;gamma[CHANNEL_GREEN] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln397">                              d-&gt;gamma[CHANNEL_BLUE] * d-&gt;gamma[CHANNEL_FACTOR] },</a>
<a name="ln398">             gamma_inv[3] = { (gamma[0] != 0.0) ? 1.0 / gamma[0] : 1000000.0,</a>
<a name="ln399">                              (gamma[1] != 0.0) ? 1.0 / gamma[1] : 1000000.0,</a>
<a name="ln400">                              (gamma[2] != 0.0) ? 1.0 / gamma[2] : 1000000.0 };</a>
<a name="ln401"> </a>
<a name="ln402">#ifdef _OPENMP</a>
<a name="ln403">#pragma omp parallel for SIMD() default(none) shared(d) schedule(static)</a>
<a name="ln404">#endif</a>
<a name="ln405">      for(size_t k = 0; k &lt; (size_t)ch * roi_in-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln406">      {</a>
<a name="ln407">        float *in = ((float *)ivoid) + k;</a>
<a name="ln408">        float *out = ((float *)ovoid) + k;</a>
<a name="ln409"> </a>
<a name="ln410">        // transform the pixel to sRGB:</a>
<a name="ln411">        // Lab -&gt; XYZ</a>
<a name="ln412">        float XYZ[3] = { 0.0f };</a>
<a name="ln413">        dt_Lab_to_XYZ(in, XYZ);</a>
<a name="ln414"> </a>
<a name="ln415">        // XYZ -&gt; sRGB</a>
<a name="ln416">        float rgb[3] = { 0.0f };</a>
<a name="ln417">        dt_XYZ_to_prophotorgb(XYZ, rgb);</a>
<a name="ln418"> </a>
<a name="ln419">        float luma = XYZ[1]; // the Y channel is the relative luminance</a>
<a name="ln420"> </a>
<a name="ln421">        // do the calculation in RGB space</a>
<a name="ln422">        for(int c = 0; c &lt; 3; c++)</a>
<a name="ln423">        {</a>
<a name="ln424">          // main saturation input</a>
<a name="ln425">          if (run_saturation) rgb[c] = luma + d-&gt;saturation * (rgb[c] - luma);</a>
<a name="ln426"> </a>
<a name="ln427">          // RGB gamma correction</a>
<a name="ln428">          rgb[c] = (rgb[c] &lt;= 0.0f) ? 0.0f : powf(rgb[c], 1.0f/2.2f);</a>
<a name="ln429"> </a>
<a name="ln430">          // lift gamma gain</a>
<a name="ln431">          rgb[c] = ((( rgb[c]  - 1.0f) * lift[c]) + 1.0f) * gain[c];</a>
<a name="ln432">          rgb[c] = (rgb[c] &lt;= 0.0f) ? 0.0f : powf(rgb[c], gamma_inv[c] * 2.2f);</a>
<a name="ln433">        }</a>
<a name="ln434"> </a>
<a name="ln435">        // main saturation output</a>
<a name="ln436">        if (run_saturation_out)</a>
<a name="ln437">        {</a>
<a name="ln438">          dt_prophotorgb_to_XYZ(rgb, XYZ);</a>
<a name="ln439">          luma = XYZ[1];</a>
<a name="ln440">          for(int c = 0; c &lt; 3; c++) rgb[c] = luma + d-&gt;saturation_out * (rgb[c] - luma);</a>
<a name="ln441">        }</a>
<a name="ln442"> </a>
<a name="ln443">        // fulcrum contrat</a>
<a name="ln444">        if (run_contrast) for(int c = 0; c &lt; 3; c++) rgb[c] = (rgb[c] &lt;= 0.0f) ? 0.0f : powf(rgb[c] / grey, contrast) * grey;</a>
<a name="ln445"> </a>
<a name="ln446">        // transform the result back to Lab</a>
<a name="ln447">        // sRGB -&gt; XYZ</a>
<a name="ln448">        dt_prophotorgb_to_XYZ(rgb, XYZ);</a>
<a name="ln449"> </a>
<a name="ln450">        // XYZ -&gt; Lab</a>
<a name="ln451">        dt_XYZ_to_Lab(XYZ, out);</a>
<a name="ln452">      }</a>
<a name="ln453">      break;</a>
<a name="ln454">   }</a>
<a name="ln455">    case SLOPE_OFFSET_POWER:</a>
<a name="ln456">    {</a>
<a name="ln457">      // these are RGB values!</a>
<a name="ln458"> </a>
<a name="ln459">      const float lift[3] = { ( d-&gt;lift[CHANNEL_RED] + d-&gt;lift[CHANNEL_FACTOR] - 2.0f),</a>
<a name="ln460">                              ( d-&gt;lift[CHANNEL_GREEN] + d-&gt;lift[CHANNEL_FACTOR] - 2.0f),</a>
<a name="ln461">                              ( d-&gt;lift[CHANNEL_BLUE] + d-&gt;lift[CHANNEL_FACTOR] - 2.0f)},</a>
<a name="ln462">                 gamma[3] = { (2.0f - d-&gt;gamma[CHANNEL_RED]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln463">                              (2.0f - d-&gt;gamma[CHANNEL_GREEN]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln464">                              (2.0f - d-&gt;gamma[CHANNEL_BLUE]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR])};</a>
<a name="ln465"> </a>
<a name="ln466">#ifdef _OPENMP</a>
<a name="ln467">#pragma omp parallel for SIMD() default(none) shared(d) schedule(static)</a>
<a name="ln468">#endif</a>
<a name="ln469">      for(size_t k = 0; k &lt; (size_t)ch * roi_in-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln470">      {</a>
<a name="ln471">        float *in = ((float *)ivoid) + k;</a>
<a name="ln472">        float *out = ((float *)ovoid) + k;</a>
<a name="ln473"> </a>
<a name="ln474">        // transform the pixel to RGB:</a>
<a name="ln475">        // Lab -&gt; XYZ</a>
<a name="ln476">        float XYZ[3];</a>
<a name="ln477">        dt_Lab_to_XYZ(in, XYZ);</a>
<a name="ln478"> </a>
<a name="ln479">        // XYZ -&gt; RGB</a>
<a name="ln480">        float rgb[3];</a>
<a name="ln481">        dt_XYZ_to_prophotorgb(XYZ, rgb);</a>
<a name="ln482"> </a>
<a name="ln483">        float luma = XYZ[1]; // the Y channel is the RGB luminance</a>
<a name="ln484"> </a>
<a name="ln485">        // do the calculation in RGB space</a>
<a name="ln486">        for(int c = 0; c &lt; 3; c++)</a>
<a name="ln487">        {</a>
<a name="ln488">          // main saturation input</a>
<a name="ln489">          if (run_saturation) rgb[c] = luma + d-&gt;saturation * (rgb[c] - luma);</a>
<a name="ln490"> </a>
<a name="ln491">          // channel CDL</a>
<a name="ln492">          rgb[c] = CDL(rgb[c], gain[c], lift[c], gamma[c]);</a>
<a name="ln493">        }</a>
<a name="ln494"> </a>
<a name="ln495">        // main saturation output</a>
<a name="ln496">        if (run_saturation_out)</a>
<a name="ln497">        {</a>
<a name="ln498">          dt_prophotorgb_to_XYZ(rgb, XYZ);</a>
<a name="ln499">          luma = XYZ[1];</a>
<a name="ln500">          for(int c = 0; c &lt; 3; c++) rgb[c] = luma + d-&gt;saturation_out * (rgb[c] - luma);</a>
<a name="ln501">        }</a>
<a name="ln502"> </a>
<a name="ln503">        // fulcrum contrat</a>
<a name="ln504">        if (run_contrast) for(int c = 0; c &lt; 3; c++) rgb[c] = (rgb[c] &lt;= 0.0f) ? 0.0f : powf(rgb[c] / grey, contrast) * grey;</a>
<a name="ln505"> </a>
<a name="ln506">        // transform the result back to Lab</a>
<a name="ln507">        // sRGB -&gt; XYZ</a>
<a name="ln508">        dt_prophotorgb_to_XYZ(rgb , XYZ);</a>
<a name="ln509"> </a>
<a name="ln510">        // XYZ -&gt; Lab</a>
<a name="ln511">        dt_XYZ_to_Lab(XYZ, out);</a>
<a name="ln512">      }</a>
<a name="ln513">      break;</a>
<a name="ln514">    }</a>
<a name="ln515">  }</a>
<a name="ln516">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">#if defined(__SSE__)</a>
<a name="ln520">void process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln521">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln522">{</a>
<a name="ln523">  dt_iop_colorbalance_data_t *d = (dt_iop_colorbalance_data_t *)piece-&gt;data;</a>
<a name="ln524">  const int ch = piece-&gt;colors;</a>
<a name="ln525">  const __m128 gain = _mm_setr_ps(d-&gt;gain[CHANNEL_RED] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln526">                                  d-&gt;gain[CHANNEL_GREEN] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln527">                                  d-&gt;gain[CHANNEL_BLUE] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln528">                                  0.0f);</a>
<a name="ln529"> </a>
<a name="ln530">  float contrast_inv = (d-&gt;contrast != 0.0f) ? 1.0f / d-&gt;contrast : 1000000.0f;</a>
<a name="ln531">  const __m128 contrast = _mm_setr_ps(contrast_inv, contrast_inv, contrast_inv, 0.0f);</a>
<a name="ln532">  float grey_corr = d-&gt;grey / 100.0f;</a>
<a name="ln533">  const __m128 grey = _mm_setr_ps(grey_corr, grey_corr, grey_corr, 0.0f);</a>
<a name="ln534">  const __m128 saturation = _mm_setr_ps(d-&gt;saturation, d-&gt;saturation, d-&gt;saturation, 0.0f);</a>
<a name="ln535">  const __m128 saturation_out = _mm_setr_ps(d-&gt;saturation_out, d-&gt;saturation_out, d-&gt;saturation_out, 0.0f);</a>
<a name="ln536">  const __m128 zero = _mm_setzero_ps();</a>
<a name="ln537">  const __m128 one = _mm_set1_ps(1.0);</a>
<a name="ln538"> </a>
<a name="ln539">  // For neutral parameters, skip the computations doing x^1 or (x-a)*1 + a to save time</a>
<a name="ln540">  const int run_contrast = (d-&gt;contrast == 1.0f) ? 0 : 1;</a>
<a name="ln541">  const int run_saturation = (d-&gt;saturation == 1.0f) ? 0: 1;</a>
<a name="ln542">  const int run_saturation_out = (d-&gt;saturation_out == 1.0f) ? 0: 1;</a>
<a name="ln543"> </a>
<a name="ln544">  switch (d-&gt;mode)</a>
<a name="ln545">  {</a>
<a name="ln546">    case LEGACY:</a>
<a name="ln547">    {</a>
<a name="ln548">      // these are RGB values!</a>
<a name="ln549">      const __m128 lift = _mm_setr_ps(2.0 - (d-&gt;lift[CHANNEL_RED] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln550">                                      2.0 - (d-&gt;lift[CHANNEL_GREEN] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln551">                                      2.0 - (d-&gt;lift[CHANNEL_BLUE] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln552">                                      0.0f);</a>
<a name="ln553"> </a>
<a name="ln554">      const __m128 gamma = _mm_setr_ps(d-&gt;gamma[CHANNEL_RED] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln555">                                   d-&gt;gamma[CHANNEL_GREEN] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln556">                                   d-&gt;gamma[CHANNEL_BLUE] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln557">                                   0.0f);</a>
<a name="ln558"> </a>
<a name="ln559">      const __m128 gamma_inv = _mm_setr_ps((gamma[0] != 0.0) ? 1.0 / gamma[0] : 1000000.0,</a>
<a name="ln560">                                       (gamma[1] != 0.0) ? 1.0 / gamma[1] : 1000000.0,</a>
<a name="ln561">                                       (gamma[2] != 0.0) ? 1.0 / gamma[2] : 1000000.0,</a>
<a name="ln562">                                       0.0f);</a>
<a name="ln563"> </a>
<a name="ln564">#ifdef _OPENMP</a>
<a name="ln565">#pragma omp parallel for SIMD() default(none) schedule(static)</a>
<a name="ln566">#endif</a>
<a name="ln567">      for(size_t k = 0; k &lt; (size_t)ch * roi_in-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln568">      {</a>
<a name="ln569">        float *in = ((float *)ivoid) + k;</a>
<a name="ln570">        float *out = ((float *)ovoid) + k;</a>
<a name="ln571"> </a>
<a name="ln572">        // transform the pixel to sRGB:</a>
<a name="ln573">        // Lab -&gt; XYZ</a>
<a name="ln574">        __m128 XYZ = dt_Lab_to_XYZ_sse2(_mm_load_ps(in));</a>
<a name="ln575">        // XYZ -&gt; sRGB</a>
<a name="ln576">        __m128 rgb = dt_XYZ_to_sRGB_sse2(XYZ);</a>
<a name="ln577"> </a>
<a name="ln578">        // do the calculation in RGB space</a>
<a name="ln579">        // regular lift gamma gain</a>
<a name="ln580">        rgb = ((rgb - one) * lift + one) * gain;</a>
<a name="ln581">        rgb = _mm_max_ps(rgb, zero);</a>
<a name="ln582">        rgb = _mm_pow_ps(rgb, gamma_inv);</a>
<a name="ln583"> </a>
<a name="ln584">        // transform the result back to Lab</a>
<a name="ln585">        // sRGB -&gt; XYZ</a>
<a name="ln586">        XYZ = dt_sRGB_to_XYZ_sse2(rgb);</a>
<a name="ln587">        // XYZ -&gt; Lab</a>
<a name="ln588">        _mm_stream_ps(out, dt_XYZ_to_Lab_sse2(XYZ));</a>
<a name="ln589">      }</a>
<a name="ln590">      break;</a>
<a name="ln591">    }</a>
<a name="ln592"> </a>
<a name="ln593">    case LIFT_GAMMA_GAIN:</a>
<a name="ln594">    {</a>
<a name="ln595">      // these are RGB values!</a>
<a name="ln596">      const __m128 lift = _mm_setr_ps(2.0f - (d-&gt;lift[CHANNEL_RED] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln597">                                      2.0f - (d-&gt;lift[CHANNEL_GREEN] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln598">                                      2.0f - (d-&gt;lift[CHANNEL_BLUE] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln599">                                      0.0f);</a>
<a name="ln600">      const __m128 gamma = _mm_setr_ps(d-&gt;gamma[CHANNEL_RED] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln601">                                       d-&gt;gamma[CHANNEL_GREEN] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln602">                                       d-&gt;gamma[CHANNEL_BLUE] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln603">                                       0.0f);</a>
<a name="ln604">      const __m128 gamma_inv = _mm_setr_ps((gamma[0] != 0.0) ? 1.0 / gamma[0] : 1000000.0,</a>
<a name="ln605">                                           (gamma[1] != 0.0) ? 1.0 / gamma[1] : 1000000.0,</a>
<a name="ln606">                                           (gamma[2] != 0.0) ? 1.0 / gamma[2] : 1000000.0,</a>
<a name="ln607">                                           0.0f);</a>
<a name="ln608"> </a>
<a name="ln609">      const __m128 gamma_RGB = _mm_set1_ps(2.2f);</a>
<a name="ln610">      const __m128 gamma_inv_RGB = _mm_set1_ps(1.0f/2.2f);</a>
<a name="ln611"> </a>
<a name="ln612">#ifdef _OPENMP</a>
<a name="ln613">#pragma omp parallel for SIMD()default(none) schedule(static)</a>
<a name="ln614">#endif</a>
<a name="ln615">      for(size_t k = 0; k &lt; (size_t)ch * roi_in-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln616">      {</a>
<a name="ln617">        float *in = ((float *)ivoid) + k;</a>
<a name="ln618">        float *out = ((float *)ovoid) + k;</a>
<a name="ln619"> </a>
<a name="ln620">        // transform the pixel to sRGB:</a>
<a name="ln621">        // Lab -&gt; XYZ</a>
<a name="ln622">        __m128 XYZ = dt_Lab_to_XYZ_sse2(_mm_load_ps(in));</a>
<a name="ln623">        // XYZ -&gt; sRGB</a>
<a name="ln624">        __m128 rgb = dt_XYZ_to_prophotoRGB_sse2(XYZ);</a>
<a name="ln625"> </a>
<a name="ln626">        __m128 luma;</a>
<a name="ln627"> </a>
<a name="ln628">        // adjust main saturation input</a>
<a name="ln629">        if (run_saturation)</a>
<a name="ln630">        {</a>
<a name="ln631">          luma = _mm_set1_ps(XYZ[1]); // the Y channel is the relative luminance</a>
<a name="ln632">          rgb = luma + saturation * (rgb - luma);</a>
<a name="ln633">        }</a>
<a name="ln634"> </a>
<a name="ln635">        // RGB gamma adjustement</a>
<a name="ln636">        rgb = _mm_pow_ps(_mm_max_ps(rgb, zero), gamma_inv_RGB);</a>
<a name="ln637"> </a>
<a name="ln638">        // regular lift gamma gain</a>
<a name="ln639">        rgb = ((rgb - one) * lift + one) * gain;</a>
<a name="ln640">        rgb = _mm_max_ps(rgb, zero);</a>
<a name="ln641">        rgb = _mm_pow_ps(rgb, gamma_inv * gamma_RGB);</a>
<a name="ln642"> </a>
<a name="ln643">        // adjust main saturation output</a>
<a name="ln644">        if (run_saturation_out)</a>
<a name="ln645">        {</a>
<a name="ln646">          XYZ = dt_prophotoRGB_to_XYZ_sse2(rgb);</a>
<a name="ln647">          luma = _mm_set1_ps(XYZ[1]); // the Y channel is the relative luminance</a>
<a name="ln648">          rgb = luma + saturation_out * (rgb - luma);</a>
<a name="ln649">        }</a>
<a name="ln650"> </a>
<a name="ln651">        // fulcrum contrast</a>
<a name="ln652">        if (run_contrast)</a>
<a name="ln653">        {</a>
<a name="ln654">          rgb = _mm_max_ps(rgb, zero);</a>
<a name="ln655">          rgb = _mm_pow_ps(rgb / grey, contrast) * grey;</a>
<a name="ln656">        }</a>
<a name="ln657"> </a>
<a name="ln658">        // transform the result back to Lab</a>
<a name="ln659">        // sRGB -&gt; XYZ</a>
<a name="ln660">        XYZ = dt_prophotoRGB_to_XYZ_sse2(rgb);</a>
<a name="ln661">        // XYZ -&gt; Lab</a>
<a name="ln662">        _mm_stream_ps(out, dt_XYZ_to_Lab_sse2(XYZ));</a>
<a name="ln663">      }</a>
<a name="ln664"> </a>
<a name="ln665">      break;</a>
<a name="ln666">    }</a>
<a name="ln667"> </a>
<a name="ln668">    case SLOPE_OFFSET_POWER:</a>
<a name="ln669">    {</a>
<a name="ln670">      // these are RGB values!</a>
<a name="ln671">      const __m128 lift = _mm_setr_ps((d-&gt;lift[CHANNEL_RED] + d-&gt;lift[CHANNEL_FACTOR] - 2.f),</a>
<a name="ln672">                                      (d-&gt;lift[CHANNEL_GREEN] + d-&gt;lift[CHANNEL_FACTOR] - 2.f),</a>
<a name="ln673">                                      (d-&gt;lift[CHANNEL_BLUE] + d-&gt;lift[CHANNEL_FACTOR] - 2.f),</a>
<a name="ln674">                                      0.0f);</a>
<a name="ln675">      const __m128 gamma = _mm_setr_ps((2.0f - d-&gt;gamma[CHANNEL_RED]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln676">                                      (2.0f - d-&gt;gamma[CHANNEL_GREEN]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln677">                                      (2.0f - d-&gt;gamma[CHANNEL_BLUE]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln678">                                      0.0f);</a>
<a name="ln679"> </a>
<a name="ln680">#ifdef _OPENMP</a>
<a name="ln681">#pragma omp parallel for SIMD() default(none) schedule(static)</a>
<a name="ln682">#endif</a>
<a name="ln683">      for(size_t k = 0; k &lt; (size_t)ch * roi_in-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln684">      {</a>
<a name="ln685">        float *in = ((float *)ivoid) + k;</a>
<a name="ln686">        float *out = ((float *)ovoid) + k;</a>
<a name="ln687"> </a>
<a name="ln688">        // transform the pixel to sRGB:</a>
<a name="ln689">        // Lab -&gt; XYZ</a>
<a name="ln690">        __m128 XYZ = dt_Lab_to_XYZ_sse2(_mm_load_ps(in));</a>
<a name="ln691">        // XYZ -&gt; sRGB</a>
<a name="ln692">        __m128 rgb = dt_XYZ_to_prophotoRGB_sse2(XYZ);</a>
<a name="ln693"> </a>
<a name="ln694">        __m128 luma;</a>
<a name="ln695"> </a>
<a name="ln696">        // adjust main saturation</a>
<a name="ln697">        if (run_saturation)</a>
<a name="ln698">        {</a>
<a name="ln699">          luma = _mm_set1_ps(XYZ[1]); // the Y channel is the relative luminance</a>
<a name="ln700">          rgb = luma + saturation * (rgb - luma);</a>
<a name="ln701">        }</a>
<a name="ln702"> </a>
<a name="ln703">        // slope offset</a>
<a name="ln704">        rgb = rgb * gain + lift;</a>
<a name="ln705"> </a>
<a name="ln706">        //power</a>
<a name="ln707">        rgb = _mm_max_ps(rgb, zero);</a>
<a name="ln708">        rgb = _mm_pow_ps(rgb, gamma);</a>
<a name="ln709"> </a>
<a name="ln710">        // adjust main saturation output</a>
<a name="ln711">        if (run_saturation_out)</a>
<a name="ln712">        {</a>
<a name="ln713">          XYZ = dt_prophotoRGB_to_XYZ_sse2(rgb);</a>
<a name="ln714">          luma = _mm_set1_ps(XYZ[1]); // the Y channel is the relative luminance</a>
<a name="ln715">          rgb = luma + saturation_out * (rgb - luma);</a>
<a name="ln716">        }</a>
<a name="ln717"> </a>
<a name="ln718">        // fulcrum contrast</a>
<a name="ln719">        if (run_contrast)</a>
<a name="ln720">        {</a>
<a name="ln721">          rgb = _mm_max_ps(rgb, zero);</a>
<a name="ln722">          rgb = _mm_pow_ps(rgb / grey, contrast) * grey;</a>
<a name="ln723">        }</a>
<a name="ln724"> </a>
<a name="ln725">        // transform the result back to Lab</a>
<a name="ln726">        // sRGB -&gt; XYZ</a>
<a name="ln727">        XYZ = dt_prophotoRGB_to_XYZ_sse2(rgb);</a>
<a name="ln728">        // XYZ -&gt; Lab</a>
<a name="ln729">        _mm_stream_ps(out, dt_XYZ_to_Lab_sse2(XYZ));</a>
<a name="ln730">      }</a>
<a name="ln731">      break;</a>
<a name="ln732">    }</a>
<a name="ln733">  }</a>
<a name="ln734">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln735">}</a>
<a name="ln736">#endif</a>
<a name="ln737"> </a>
<a name="ln738">#ifdef HAVE_OPENCL</a>
<a name="ln739">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln740">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln741">{</a>
<a name="ln742">  dt_iop_colorbalance_data_t *d = (dt_iop_colorbalance_data_t *)piece-&gt;data;</a>
<a name="ln743">  dt_iop_colorbalance_global_data_t *gd = (dt_iop_colorbalance_global_data_t *)self-&gt;data;</a>
<a name="ln744"> </a>
<a name="ln745">  cl_int err = -999;</a>
<a name="ln746">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln747">  const int width = roi_in-&gt;width;</a>
<a name="ln748">  const int height = roi_in-&gt;height;</a>
<a name="ln749">  size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln750"> </a>
<a name="ln751">  switch (d-&gt;mode)</a>
<a name="ln752">  {</a>
<a name="ln753">    case LEGACY:</a>
<a name="ln754">    {</a>
<a name="ln755">      const float lift[4] = { 2.0f - (d-&gt;lift[CHANNEL_RED] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln756">                              2.0f - (d-&gt;lift[CHANNEL_GREEN] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln757">                              2.0f - (d-&gt;lift[CHANNEL_BLUE] * d-&gt;lift[CHANNEL_FACTOR]), 0.0f },</a>
<a name="ln758">                  gamma[4] = { d-&gt;gamma[CHANNEL_RED] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln759">                               d-&gt;gamma[CHANNEL_GREEN] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln760">                               d-&gt;gamma[CHANNEL_BLUE] * d-&gt;gamma[CHANNEL_FACTOR], 0.0f },</a>
<a name="ln761">                  gamma_inv[4] = { (gamma[0] != 0.0f) ? 1.0f / gamma[0] : 1000000.0f,</a>
<a name="ln762">                                   (gamma[1] != 0.0f) ? 1.0f / gamma[1] : 1000000.0f,</a>
<a name="ln763">                                   (gamma[2] != 0.0f) ? 1.0f / gamma[2] : 1000000.0f, 0.0f },</a>
<a name="ln764">                  gain[4] = { d-&gt;gain[CHANNEL_RED] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln765">                              d-&gt;gain[CHANNEL_GREEN] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln766">                              d-&gt;gain[CHANNEL_BLUE] * d-&gt;gain[CHANNEL_FACTOR], 0.0f },</a>
<a name="ln767">                  contrast = (d-&gt;contrast != 0.0f) ? 1.0f / d-&gt;contrast : 1000000.0f,</a>
<a name="ln768">                  grey = d-&gt;grey / 100.0f,</a>
<a name="ln769">                  saturation = d-&gt;saturation;</a>
<a name="ln770"> </a>
<a name="ln771">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln772">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln773">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln774">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln775">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 4, 4 * sizeof(float), (void *)&amp;lift);</a>
<a name="ln776">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 5, 4 * sizeof(float), (void *)&amp;gain);</a>
<a name="ln777">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 6, 4 * sizeof(float), (void *)&amp;gamma_inv);</a>
<a name="ln778">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 7, sizeof(float), (void *)&amp;saturation);</a>
<a name="ln779">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 8, sizeof(float), (void *)&amp;contrast);</a>
<a name="ln780">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance, 9, sizeof(float), (void *)&amp;grey);</a>
<a name="ln781">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_colorbalance, sizes);</a>
<a name="ln782">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln783">      return TRUE;</a>
<a name="ln784"> </a>
<a name="ln785">      break;</a>
<a name="ln786">    }</a>
<a name="ln787">    case LIFT_GAMMA_GAIN:</a>
<a name="ln788">    {</a>
<a name="ln789">      const float lift[4] = { 2.0f - (d-&gt;lift[CHANNEL_RED] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln790">                              2.0f - (d-&gt;lift[CHANNEL_GREEN] * d-&gt;lift[CHANNEL_FACTOR]),</a>
<a name="ln791">                              2.0f - (d-&gt;lift[CHANNEL_BLUE] * d-&gt;lift[CHANNEL_FACTOR]), 0.0f },</a>
<a name="ln792">                  gamma[4] = { d-&gt;gamma[CHANNEL_RED] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln793">                               d-&gt;gamma[CHANNEL_GREEN] * d-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln794">                               d-&gt;gamma[CHANNEL_BLUE] * d-&gt;gamma[CHANNEL_FACTOR], 0.0f },</a>
<a name="ln795">                  gamma_inv[4] = { (gamma[0] != 0.0f) ? 1.0f / gamma[0] : 1000000.0f,</a>
<a name="ln796">                                   (gamma[1] != 0.0f) ? 1.0f / gamma[1] : 1000000.0f,</a>
<a name="ln797">                                   (gamma[2] != 0.0f) ? 1.0f / gamma[2] : 1000000.0f, 0.0f },</a>
<a name="ln798">                  gain[4] = { d-&gt;gain[CHANNEL_RED] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln799">                              d-&gt;gain[CHANNEL_GREEN] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln800">                              d-&gt;gain[CHANNEL_BLUE] * d-&gt;gain[CHANNEL_FACTOR], 0.0f },</a>
<a name="ln801">                  contrast = (d-&gt;contrast != 0.0f) ? 1.0f / d-&gt;contrast : 1000000.0f,</a>
<a name="ln802">                  grey = d-&gt;grey / 100.0f,</a>
<a name="ln803">                  saturation = d-&gt;saturation,</a>
<a name="ln804">                  saturation_out = d-&gt;saturation_out;</a>
<a name="ln805"> </a>
<a name="ln806">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln807">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln808">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln809">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln810">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 4, 4 * sizeof(float), (void *)&amp;lift);</a>
<a name="ln811">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 5, 4 * sizeof(float), (void *)&amp;gain);</a>
<a name="ln812">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 6, 4 * sizeof(float), (void *)&amp;gamma_inv);</a>
<a name="ln813">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 7, sizeof(float), (void *)&amp;saturation);</a>
<a name="ln814">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 8, sizeof(float), (void *)&amp;contrast);</a>
<a name="ln815">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 9, sizeof(float), (void *)&amp;grey);</a>
<a name="ln816">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_lgg, 10, sizeof(float), (void *)&amp;saturation_out);</a>
<a name="ln817">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_colorbalance_lgg, sizes);</a>
<a name="ln818">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln819">      return TRUE;</a>
<a name="ln820"> </a>
<a name="ln821">      break;</a>
<a name="ln822">    }</a>
<a name="ln823">    case SLOPE_OFFSET_POWER:</a>
<a name="ln824">    {</a>
<a name="ln825">      const float lift[4] = { ( d-&gt;lift[CHANNEL_RED] + d-&gt;lift[CHANNEL_FACTOR] - 2.0f ),</a>
<a name="ln826">                              ( d-&gt;lift[CHANNEL_GREEN] + d-&gt;lift[CHANNEL_FACTOR] - 2.0f ),</a>
<a name="ln827">                              ( d-&gt;lift[CHANNEL_BLUE] + d-&gt;lift[CHANNEL_FACTOR] - 2.0f ),</a>
<a name="ln828">                              0.0f },</a>
<a name="ln829">                  gamma[4] = { (2.0f - d-&gt;gamma[CHANNEL_RED]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln830">                               (2.0f - d-&gt;gamma[CHANNEL_GREEN]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln831">                               (2.0f - d-&gt;gamma[CHANNEL_BLUE]) * (2.0f - d-&gt;gamma[CHANNEL_FACTOR]),</a>
<a name="ln832">                               0.0f },</a>
<a name="ln833">                  gain[4] = { d-&gt;gain[CHANNEL_RED] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln834">                              d-&gt;gain[CHANNEL_GREEN] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln835">                              d-&gt;gain[CHANNEL_BLUE] * d-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln836">                              0.0f },</a>
<a name="ln837">                  contrast = (d-&gt;contrast != 0.0f) ? 1.0f / d-&gt;contrast : 1000000.0f,</a>
<a name="ln838">                  grey = d-&gt;grey / 100.0f,</a>
<a name="ln839">                  saturation = d-&gt;saturation,</a>
<a name="ln840">                  saturation_out = d-&gt;saturation_out;</a>
<a name="ln841"> </a>
<a name="ln842">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln843">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln844">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln845">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln846">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 4, 4 * sizeof(float), (void *)&amp;lift);</a>
<a name="ln847">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 5, 4 * sizeof(float), (void *)&amp;gain);</a>
<a name="ln848">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 6, 4 * sizeof(float), (void *)&amp;gamma);</a>
<a name="ln849">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 7, sizeof(float), (void *)&amp;saturation);</a>
<a name="ln850">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 8, sizeof(float), (void *)&amp;contrast);</a>
<a name="ln851">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 9, sizeof(float), (void *)&amp;grey);</a>
<a name="ln852">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_colorbalance_cdl, 10, sizeof(float), (void *)&amp;saturation_out);</a>
<a name="ln853">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_colorbalance_cdl, sizes);</a>
<a name="ln854">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln855">      return TRUE;</a>
<a name="ln856"> </a>
<a name="ln857">      break;</a>
<a name="ln858">    }</a>
<a name="ln859">  }</a>
<a name="ln860"> </a>
<a name="ln861">error:</a>
<a name="ln862">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_colorbalance] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln863">  return FALSE;</a>
<a name="ln864">}</a>
<a name="ln865">#endif</a>
<a name="ln866"> </a>
<a name="ln867">static inline void update_saturation_slider_color(GtkWidget *slider, float hue)</a>
<a name="ln868">{</a>
<a name="ln869">  float rgb[3];</a>
<a name="ln870">  if(hue != -1)</a>
<a name="ln871">  {</a>
<a name="ln872">    hsl2rgb(rgb, hue, 1.0, 0.5);</a>
<a name="ln873">    dt_bauhaus_slider_set_stop(slider, 1.0, rgb[0], rgb[1], rgb[2]);</a>
<a name="ln874">    hsl2rgb(rgb, hue, 0.0, 0.5);</a>
<a name="ln875">    dt_bauhaus_slider_set_stop(slider, 0.0, rgb[0], rgb[1], rgb[2]);</a>
<a name="ln876">    gtk_widget_queue_draw(GTK_WIDGET(slider));</a>
<a name="ln877">  }</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880">static inline void set_RGB_sliders(GtkWidget *R, GtkWidget *G, GtkWidget *B, float hsl[3], float *p, int mode)</a>
<a name="ln881">{</a>
<a name="ln882"> </a>
<a name="ln883">  float rgb[3] = { 0.0f };</a>
<a name="ln884">  hsl2rgb(rgb, hsl[0], hsl[1], hsl[2]);</a>
<a name="ln885"> </a>
<a name="ln886">  if(hsl[0] != -1)</a>
<a name="ln887">  {</a>
<a name="ln888">    p[CHANNEL_RED] = rgb[0] * 2.0f;</a>
<a name="ln889">    p[CHANNEL_GREEN] = rgb[1] * 2.0f;</a>
<a name="ln890">    p[CHANNEL_BLUE] = rgb[2] * 2.0f;</a>
<a name="ln891"> </a>
<a name="ln892">    darktable.gui-&gt;reset = 1;</a>
<a name="ln893">    dt_bauhaus_slider_set_soft(R, p[CHANNEL_RED] - 1.0f);</a>
<a name="ln894">    dt_bauhaus_slider_set_soft(G, p[CHANNEL_GREEN] - 1.0f);</a>
<a name="ln895">    dt_bauhaus_slider_set_soft(B, p[CHANNEL_BLUE] - 1.0f);</a>
<a name="ln896">    darktable.gui-&gt;reset = 0;</a>
<a name="ln897">  }</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900">static inline void set_HSL_sliders(GtkWidget *hue, GtkWidget *sat, float RGB[4])</a>
<a name="ln901">{</a>
<a name="ln902">  /** HSL sliders are set from the RGB values at any time.</a>
<a name="ln903">  * Only the RGB values are saved and used in the computations.</a>
<a name="ln904">  * The HSL sliders are merely an interface.</a>
<a name="ln905">  */</a>
<a name="ln906">  float RGB_norm[3] = { (RGB[CHANNEL_RED] / 2.0f), (RGB[CHANNEL_GREEN] / 2.0f), (RGB[CHANNEL_BLUE] / 2.0f) };</a>
<a name="ln907"> </a>
<a name="ln908">  float h, s, l;</a>
<a name="ln909">  rgb2hsl(RGB_norm, &amp;h, &amp;s, &amp;l);</a>
<a name="ln910"> </a>
<a name="ln911">  if(h != -1.0f)</a>
<a name="ln912">  {</a>
<a name="ln913">    dt_bauhaus_slider_set_soft(hue, h * 360.0f);</a>
<a name="ln914">    dt_bauhaus_slider_set_soft(sat, s * 100.0f);</a>
<a name="ln915">    update_saturation_slider_color(GTK_WIDGET(sat), h);</a>
<a name="ln916">    gtk_widget_queue_draw(GTK_WIDGET(sat));</a>
<a name="ln917">  }</a>
<a name="ln918">  else</a>
<a name="ln919">  {</a>
<a name="ln920">    dt_bauhaus_slider_set_soft(hue, -1.0f);</a>
<a name="ln921">    dt_bauhaus_slider_set_soft(sat, 0.0f);</a>
<a name="ln922">    gtk_widget_queue_draw(GTK_WIDGET(sat));</a>
<a name="ln923">  }</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926">static inline void _check_tuner_picker_labels(dt_iop_module_t *self)</a>
<a name="ln927">{</a>
<a name="ln928">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln929"> </a>
<a name="ln930">  if(g-&gt;luma_patches_flags[GAIN] == USER_SELECTED &amp;&amp; g-&gt;luma_patches_flags[GAMMA] == USER_SELECTED</a>
<a name="ln931">     &amp;&amp; g-&gt;luma_patches_flags[LIFT] == USER_SELECTED)</a>
<a name="ln932">    dt_bauhaus_widget_set_label(g-&gt;auto_luma, NULL, _(&quot;optimize luma from patches&quot;));</a>
<a name="ln933">  else</a>
<a name="ln934">    dt_bauhaus_widget_set_label(g-&gt;auto_luma, NULL, _(&quot;optimize luma&quot;));</a>
<a name="ln935"> </a>
<a name="ln936">  if(g-&gt;color_patches_flags[GAIN] == USER_SELECTED &amp;&amp; g-&gt;color_patches_flags[GAMMA] == USER_SELECTED</a>
<a name="ln937">     &amp;&amp; g-&gt;color_patches_flags[LIFT] == USER_SELECTED)</a>
<a name="ln938">    dt_bauhaus_widget_set_label(g-&gt;auto_color, NULL, _(&quot;neutralize colors from patches&quot;));</a>
<a name="ln939">  else</a>
<a name="ln940">    dt_bauhaus_widget_set_label(g-&gt;auto_color, NULL, _(&quot;neutralize colors&quot;));</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943"> </a>
<a name="ln944">static void apply_autogrey(dt_iop_module_t *self)</a>
<a name="ln945">{</a>
<a name="ln946">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln947">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln948">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln949"> </a>
<a name="ln950">  float XYZ[3] = { 0.0f };</a>
<a name="ln951">  float rgb[3] = { 0.0f };</a>
<a name="ln952">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln953">  dt_XYZ_to_prophotorgb((const float *)XYZ, rgb);</a>
<a name="ln954"> </a>
<a name="ln955">  const float lift[3]</a>
<a name="ln956">      = { (p-&gt;lift[CHANNEL_RED] + p-&gt;lift[CHANNEL_FACTOR] - 2.0f),</a>
<a name="ln957">          (p-&gt;lift[CHANNEL_GREEN] + p-&gt;lift[CHANNEL_FACTOR] - 2.0f),</a>
<a name="ln958">          (p-&gt;lift[CHANNEL_BLUE] + p-&gt;lift[CHANNEL_FACTOR] - 2.0f) },</a>
<a name="ln959">      gamma[3]</a>
<a name="ln960">      = { p-&gt;gamma[CHANNEL_RED] * p-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln961">          p-&gt;gamma[CHANNEL_GREEN] * p-&gt;gamma[CHANNEL_FACTOR],</a>
<a name="ln962">          p-&gt;gamma[CHANNEL_BLUE] * p-&gt;gamma[CHANNEL_FACTOR] },</a>
<a name="ln963">      gain[3] = { p-&gt;gain[CHANNEL_RED] * p-&gt;gain[CHANNEL_FACTOR], p-&gt;gain[CHANNEL_GREEN] * p-&gt;gain[CHANNEL_FACTOR],</a>
<a name="ln964">                  p-&gt;gain[CHANNEL_BLUE] * p-&gt;gain[CHANNEL_FACTOR] };</a>
<a name="ln965"> </a>
<a name="ln966">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln967">  {</a>
<a name="ln968">    rgb[c] = CDL(rgb[c], gain[c], lift[c], 2.0f - gamma[c]);</a>
<a name="ln969">    rgb[c] = CLAMP(rgb[c], 0.0f, 1.0f);</a>
<a name="ln970">  }</a>
<a name="ln971"> </a>
<a name="ln972">  dt_prophotorgb_to_XYZ((const float *)rgb, XYZ);</a>
<a name="ln973"> </a>
<a name="ln974">  p-&gt;grey = XYZ[1] * 100.0f;</a>
<a name="ln975"> </a>
<a name="ln976">  darktable.gui-&gt;reset = 1;</a>
<a name="ln977">  dt_bauhaus_slider_set_soft(g-&gt;grey, p-&gt;grey);</a>
<a name="ln978">  darktable.gui-&gt;reset = 0;</a>
<a name="ln979"> </a>
<a name="ln980">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983">static void apply_lift_neutralize(dt_iop_module_t *self)</a>
<a name="ln984">{</a>
<a name="ln985">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln986">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln987">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln988"> </a>
<a name="ln989">  float XYZ[3] = { 0.0f };</a>
<a name="ln990">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln991">  float RGB[3] = { 0.0f };</a>
<a name="ln992">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln993"> </a>
<a name="ln994">// Save the patch color for the optimization</a>
<a name="ln995">  for(int c = 0; c &lt; 3; ++c) g-&gt;color_patches_lift[c] = RGB[c];</a>
<a name="ln996">  g-&gt;color_patches_flags[LIFT] = USER_SELECTED;</a>
<a name="ln997"> </a>
<a name="ln998">  // Compute the RGB values after the CDL factors</a>
<a name="ln999">  for(int c = 0; c &lt; 3; ++c)</a>
<a name="ln1000">    RGB[c] = CDL(RGB[c], p-&gt;gain[CHANNEL_FACTOR], p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 2.0f - p-&gt;gamma[CHANNEL_FACTOR]);</a>
<a name="ln1001"> </a>
<a name="ln1002">  // Compute the luminance of the average grey</a>
<a name="ln1003">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1004"> </a>
<a name="ln1005">  // Get the parameter</a>
<a name="ln1006">  for(int c = 0; c &lt; 3; ++c) RGB[c] = powf(XYZ[1], 1.0f/(2.0f - p-&gt;gamma[c+1])) - RGB[c] * p-&gt;gain[c+1];</a>
<a name="ln1007"> </a>
<a name="ln1008">  p-&gt;lift[CHANNEL_RED] = RGB[0] + 1.0f;</a>
<a name="ln1009">  p-&gt;lift[CHANNEL_GREEN] = RGB[1] + 1.0f;</a>
<a name="ln1010">  p-&gt;lift[CHANNEL_BLUE] = RGB[2] + 1.0f;</a>
<a name="ln1011"> </a>
<a name="ln1012">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1013">  dt_bauhaus_slider_set_soft(g-&gt;lift_r, RGB[0]);</a>
<a name="ln1014">  dt_bauhaus_slider_set_soft(g-&gt;lift_g, RGB[1]);</a>
<a name="ln1015">  dt_bauhaus_slider_set_soft(g-&gt;lift_b, RGB[2]);</a>
<a name="ln1016">  set_HSL_sliders(g-&gt;hue_lift, g-&gt;sat_lift, p-&gt;lift);</a>
<a name="ln1017">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1018"> </a>
<a name="ln1019">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022">static void apply_gamma_neutralize(dt_iop_module_t *self)</a>
<a name="ln1023">{</a>
<a name="ln1024">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1025">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1026">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1027"> </a>
<a name="ln1028">  float XYZ[3] = { 0.0f };</a>
<a name="ln1029">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln1030">  float RGB[3] = { 0.0f };</a>
<a name="ln1031">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1032"> </a>
<a name="ln1033">// Save the patch color for the optimization</a>
<a name="ln1034">  for(int c = 0; c &lt; 3; ++c) g-&gt;color_patches_gamma[c] = RGB[c];</a>
<a name="ln1035">  g-&gt;color_patches_flags[GAMMA] = USER_SELECTED;</a>
<a name="ln1036"> </a>
<a name="ln1037">  // Compute the RGB values after the CDL factors</a>
<a name="ln1038">  for(int c = 0; c &lt; 3; ++c)</a>
<a name="ln1039">    RGB[c] = CDL(RGB[c], p-&gt;gain[CHANNEL_FACTOR], p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 2.0f - p-&gt;gamma[CHANNEL_FACTOR]);</a>
<a name="ln1040"> </a>
<a name="ln1041">  // Compute the luminance of the average grey</a>
<a name="ln1042">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1043"> </a>
<a name="ln1044">  // Get the parameter</a>
<a name="ln1045">  for(int c = 0; c &lt; 3; ++c) RGB[c] = logf(XYZ[1])/ logf(RGB[c] * p-&gt;gain[c + 1] + p-&gt;lift[c + 1] - 1.0f);</a>
<a name="ln1046"> </a>
<a name="ln1047">  p-&gt;gamma[CHANNEL_RED] = CLAMP(2.0 - RGB[0], 0.0001f, 2.0f);</a>
<a name="ln1048">  p-&gt;gamma[CHANNEL_GREEN] = CLAMP(2.0 - RGB[1], 0.0001f, 2.0f);</a>
<a name="ln1049">  p-&gt;gamma[CHANNEL_BLUE] = CLAMP(2.0 - RGB[2], 0.0001f, 2.0f);</a>
<a name="ln1050"> </a>
<a name="ln1051">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1052">  dt_bauhaus_slider_set_soft(g-&gt;gamma_r, -RGB[0] + 1.0f);</a>
<a name="ln1053">  dt_bauhaus_slider_set_soft(g-&gt;gamma_g, -RGB[1] + 1.0f);</a>
<a name="ln1054">  dt_bauhaus_slider_set_soft(g-&gt;gamma_b, -RGB[2] + 1.0f);</a>
<a name="ln1055">  set_HSL_sliders(g-&gt;hue_gamma, g-&gt;sat_gamma, p-&gt;gamma);</a>
<a name="ln1056">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1057"> </a>
<a name="ln1058">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061">static void apply_gain_neutralize(dt_iop_module_t *self)</a>
<a name="ln1062">{</a>
<a name="ln1063">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1064">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1065">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1066"> </a>
<a name="ln1067">  float XYZ[3] = { 0.0f };</a>
<a name="ln1068">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln1069">  float RGB[3] = { 0.0f };</a>
<a name="ln1070">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1071"> </a>
<a name="ln1072">// Save the patch color for the optimization</a>
<a name="ln1073">  for(int c = 0; c &lt; 3; c++) g-&gt;color_patches_gain[c] = RGB[c];</a>
<a name="ln1074">  g-&gt;color_patches_flags[GAIN] = USER_SELECTED;</a>
<a name="ln1075"> </a>
<a name="ln1076">  // Compute the RGB values after the CDL factors</a>
<a name="ln1077">  for(int c = 0; c &lt; 3; ++c)</a>
<a name="ln1078">    RGB[c] = CDL(RGB[c], p-&gt;gain[CHANNEL_FACTOR], p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 2.0f - p-&gt;gamma[CHANNEL_FACTOR]);</a>
<a name="ln1079"> </a>
<a name="ln1080">  // Compute the luminance of the average grey</a>
<a name="ln1081">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1082"> </a>
<a name="ln1083">  // Get the parameter</a>
<a name="ln1084">  for(int c = 0; c &lt; 3; ++c) RGB[c] = (powf(XYZ[1], 1.0f/(2.0f - p-&gt;gamma[c+1])) - p-&gt;lift[c+1] + 1.0f) / MAX(RGB[c], 0.000001f);</a>
<a name="ln1085"> </a>
<a name="ln1086">  p-&gt;gain[CHANNEL_RED] = RGB[0];</a>
<a name="ln1087">  p-&gt;gain[CHANNEL_GREEN] = RGB[1];</a>
<a name="ln1088">  p-&gt;gain[CHANNEL_BLUE] = RGB[2];</a>
<a name="ln1089"> </a>
<a name="ln1090">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1091">  dt_bauhaus_slider_set_soft(g-&gt;gain_r, RGB[0] - 1.0f);</a>
<a name="ln1092">  dt_bauhaus_slider_set_soft(g-&gt;gain_g, RGB[1] - 1.0f);</a>
<a name="ln1093">  dt_bauhaus_slider_set_soft(g-&gt;gain_b, RGB[2] - 1.0f);</a>
<a name="ln1094">  set_HSL_sliders(g-&gt;hue_gain, g-&gt;sat_gain, p-&gt;gain);</a>
<a name="ln1095">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1096"> </a>
<a name="ln1097">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">static void apply_lift_auto(dt_iop_module_t *self)</a>
<a name="ln1101">{</a>
<a name="ln1102">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1103">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1104">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1105"> </a>
<a name="ln1106">  float XYZ[3] = { 0.0f };</a>
<a name="ln1107">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color_min, XYZ);</a>
<a name="ln1108"> </a>
<a name="ln1109">  g-&gt;luma_patches[LIFT] = XYZ[1];</a>
<a name="ln1110">  g-&gt;luma_patches_flags[LIFT] = USER_SELECTED;</a>
<a name="ln1111"> </a>
<a name="ln1112">  float RGB[3] = { 0.0f };</a>
<a name="ln1113">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1114"> </a>
<a name="ln1115">  p-&gt;lift[CHANNEL_FACTOR] = -p-&gt;gain[CHANNEL_FACTOR] * XYZ[1] + 1.0f;</a>
<a name="ln1116"> </a>
<a name="ln1117">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1118">  dt_bauhaus_slider_set_soft(g-&gt;lift_factor, (p-&gt;lift[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1119">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1120"> </a>
<a name="ln1121">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">static void apply_gamma_auto(dt_iop_module_t *self)</a>
<a name="ln1125">{</a>
<a name="ln1126">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1127">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1128">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1129"> </a>
<a name="ln1130">  float XYZ[3] = { 0.0f };</a>
<a name="ln1131">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln1132"> </a>
<a name="ln1133">  g-&gt;luma_patches[GAMMA] = XYZ[1];</a>
<a name="ln1134">  g-&gt;luma_patches_flags[GAMMA] = USER_SELECTED;</a>
<a name="ln1135"> </a>
<a name="ln1136">  float RGB[3] = { 0.0f };</a>
<a name="ln1137">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1138"> </a>
<a name="ln1139">  p-&gt;gamma[CHANNEL_FACTOR]</a>
<a name="ln1140">      = 2.0f - logf(0.1842f) / logf(MAX(p-&gt;gain[CHANNEL_FACTOR] * XYZ[1] + p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 0.000001f));</a>
<a name="ln1141"> </a>
<a name="ln1142">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1143">  dt_bauhaus_slider_set_soft(g-&gt;gamma_factor, (p-&gt;gamma[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1144">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1145"> </a>
<a name="ln1146">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1147">}</a>
<a name="ln1148"> </a>
<a name="ln1149">static void apply_gain_auto(dt_iop_module_t *self)</a>
<a name="ln1150">{</a>
<a name="ln1151">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1152">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1153">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1154"> </a>
<a name="ln1155">  float XYZ[3] = { 0.0f };</a>
<a name="ln1156">  dt_Lab_to_XYZ((const float *)self-&gt;picked_color_max, XYZ);</a>
<a name="ln1157"> </a>
<a name="ln1158">  g-&gt;luma_patches[GAIN] = XYZ[1];</a>
<a name="ln1159">  g-&gt;luma_patches_flags[GAIN] = USER_SELECTED;</a>
<a name="ln1160"> </a>
<a name="ln1161">  float RGB[3] = { 0.0f };</a>
<a name="ln1162">  dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1163"> </a>
<a name="ln1164">  p-&gt;gain[CHANNEL_FACTOR] = p-&gt;lift[CHANNEL_FACTOR] / (XYZ[1]);</a>
<a name="ln1165"> </a>
<a name="ln1166">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1167">  dt_bauhaus_slider_set_soft(g-&gt;gain_factor, (p-&gt;gain[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1168">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1169"> </a>
<a name="ln1170">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1171">}</a>
<a name="ln1172"> </a>
<a name="ln1173">static void apply_autocolor(dt_iop_module_t *self)</a>
<a name="ln1174">{</a>
<a name="ln1175">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1176">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1177"> </a>
<a name="ln1178">  if(g-&gt;color_patches_flags[GAIN] == INVALID || g-&gt;color_patches_flags[GAMMA] == INVALID</a>
<a name="ln1179">     || g-&gt;color_patches_flags[LIFT] == INVALID)</a>
<a name="ln1180">  {</a>
<a name="ln1181">    /*</a>
<a name="ln1182">     * Some color patches were not picked by the user. Take a</a>
<a name="ln1183">     * picture-wide patch for these.</a>
<a name="ln1184">     */</a>
<a name="ln1185">    float XYZ[3] = { 0.0f };</a>
<a name="ln1186">    dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln1187">    float RGB[3] = { 0.0f };</a>
<a name="ln1188">    dt_XYZ_to_prophotorgb((const float *)XYZ, RGB);</a>
<a name="ln1189"> </a>
<a name="ln1190">    // Save the patch color for the optimization</a>
<a name="ln1191">    if(g-&gt;color_patches_flags[LIFT] == INVALID)</a>
<a name="ln1192">    {</a>
<a name="ln1193">      for(int c = 0; c &lt; 3; c++) g-&gt;color_patches_lift[c] = RGB[c];</a>
<a name="ln1194">      g-&gt;color_patches_flags[LIFT] = AUTO_SELECTED;</a>
<a name="ln1195">    }</a>
<a name="ln1196">    if(g-&gt;color_patches_flags[GAMMA] == INVALID)</a>
<a name="ln1197">    {</a>
<a name="ln1198">      for(int c = 0; c &lt; 3; c++) g-&gt;color_patches_gamma[c] = RGB[c];</a>
<a name="ln1199">      g-&gt;color_patches_flags[GAMMA] = AUTO_SELECTED;</a>
<a name="ln1200">    }</a>
<a name="ln1201">    if(g-&gt;color_patches_flags[GAIN] == INVALID)</a>
<a name="ln1202">    {</a>
<a name="ln1203">      for(int c = 0; c &lt; 3; c++) g-&gt;color_patches_gain[c] = RGB[c];</a>
<a name="ln1204">      g-&gt;color_patches_flags[GAIN] = AUTO_SELECTED;</a>
<a name="ln1205">    }</a>
<a name="ln1206">  }</a>
<a name="ln1207"> </a>
<a name="ln1208">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1209"> </a>
<a name="ln1210">  // Build the CDL-corrected samples (after the factors)</a>
<a name="ln1211">  float samples_lift[3] = { 0.f };</a>
<a name="ln1212">  float samples_gamma[3] = { 0.f };</a>
<a name="ln1213">  float samples_gain[3] = { 0.f };</a>
<a name="ln1214"> </a>
<a name="ln1215">  for (int c = 0; c &lt; 3; ++c)</a>
<a name="ln1216">  {</a>
<a name="ln1217">    samples_lift[c] = CDL(g-&gt;color_patches_lift[c], p-&gt;gain[CHANNEL_FACTOR], p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 2.0f - p-&gt;gamma[CHANNEL_FACTOR]);</a>
<a name="ln1218">    samples_gamma[c] = CDL(g-&gt;color_patches_gamma[c], p-&gt;gain[CHANNEL_FACTOR], p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 2.0f - p-&gt;gamma[CHANNEL_FACTOR]);</a>
<a name="ln1219">    samples_gain[c] = CDL(g-&gt;color_patches_gain[c], p-&gt;gain[CHANNEL_FACTOR], p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 2.0f - p-&gt;gamma[CHANNEL_FACTOR]);</a>
<a name="ln1220">  }</a>
<a name="ln1221"> </a>
<a name="ln1222">  // Get the average patches luma value (= neutral grey equivalents) after the CDL factors</a>
<a name="ln1223">  float greys[3] = { 0.0 };</a>
<a name="ln1224">  float XYZ[3] = { 0.0 };</a>
<a name="ln1225">  dt_prophotorgb_to_XYZ((const float *)samples_lift, (float *)XYZ);</a>
<a name="ln1226">  greys[0] = XYZ[1];</a>
<a name="ln1227">  dt_prophotorgb_to_XYZ((const float *)samples_gamma, (float *)XYZ);</a>
<a name="ln1228">  greys[1] = XYZ[1];</a>
<a name="ln1229">  dt_prophotorgb_to_XYZ((const float *)samples_gain, (float *)XYZ);</a>
<a name="ln1230">  greys[2] = XYZ[1];</a>
<a name="ln1231"> </a>
<a name="ln1232">  // Get the current params</a>
<a name="ln1233">  float RGB_lift[3] = { p-&gt;lift[CHANNEL_RED] - 1.0f, p-&gt;lift[CHANNEL_GREEN] - 1.0f, p-&gt;lift[CHANNEL_BLUE] - 1.0f };</a>
<a name="ln1234">  float RGB_gamma[3] = { p-&gt;gamma[CHANNEL_RED], p-&gt;gamma[CHANNEL_GREEN], p-&gt;gamma[CHANNEL_BLUE] };</a>
<a name="ln1235">  float RGB_gain[3] = { p-&gt;gain[CHANNEL_RED], p-&gt;gain[CHANNEL_GREEN], p-&gt;gain[CHANNEL_BLUE] };</a>
<a name="ln1236"> </a>
<a name="ln1237">  /** Optimization loop :</a>
<a name="ln1238">  * We try to find the CDL curves that neutralize the 3 input color patches, while not affecting the overall lightness.</a>
<a name="ln1239">  * But this is a non-linear overconstrained problem with tainted inputs, so the best we can do is a numerical optimization.</a>
<a name="ln1240">  * To do so, we compute each parameter of each RGB curve from the input color and the 2 other parameters.</a>
<a name="ln1241">  * Then, we loop over the previous optimization until the difference between 2 updates is insignificant.</a>
<a name="ln1242">  * This would need a proper stopping criterion based on convergence analysis, but it would be overkill here since</a>
<a name="ln1243">  * it should converge usually in 20 iterations, and maximum in 100.</a>
<a name="ln1244">  * Also, the convergence has not been proven formally.</a>
<a name="ln1245">  * For better color accuracy, we compute on luminance corrected RGB values (after the main factors corrections).</a>
<a name="ln1246">  * To avoid divergence, we constrain the parameters between +- 0.25 around the neutral value.</a>
<a name="ln1247">  * Experimentally, nothing good happens out of these bounds.</a>
<a name="ln1248">  */</a>
<a name="ln1249">  for (int runs = 0 ; runs &lt; 1000 ; ++runs)</a>
<a name="ln1250">  {</a>
<a name="ln1251">    // compute RGB slope/gain (powf(XYZ[1], 1.0f/(2.0f - p-&gt;gamma[c+1])) - p-&gt;lift[c+1] + 1.0f) / MAX(RGB[c], 0.000001f);</a>
<a name="ln1252">    for (int c = 0; c &lt; 3; ++c) RGB_gain[c] = CLAMP((powf(greys[GAIN], 1.0f / (2.0f - RGB_gamma[c])) - RGB_lift[c]) / MAX(samples_gain[c], 0.000001f), 0.75f, 1.25f);</a>
<a name="ln1253">    // compute RGB offset/lift powf(XYZ[1], 1.0f/(2.0f - p-&gt;gamma[c+1])) - RGB[c] * p-&gt;gain[c+1];</a>
<a name="ln1254">    for (int c = 0; c &lt; 3; ++c) RGB_lift[c] = CLAMP(powf(greys[LIFT], 1.0f / (2.0f - RGB_gamma[c])) - samples_lift[c] * RGB_gain[c], -0.025f, 0.025f);</a>
<a name="ln1255">    // compute  power/gamma 2.0f - logf(0.1842f) / logf(MAX(p-&gt;gain[CHANNEL_FACTOR] * XYZ[1] + p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 0.000001f));</a>
<a name="ln1256">    for (int c = 0; c &lt; 3; ++c) RGB_gamma[c] = 2.0f - CLAMP(logf(MAX(greys[GAMMA], 0.000001f)) / logf(MAX(RGB_gain[c] * samples_gamma[c] + RGB_lift[c], 0.000001f)), 0.75f, 1.25f);</a>
<a name="ln1257">  }</a>
<a name="ln1258"> </a>
<a name="ln1259">  // save</a>
<a name="ln1260">  p-&gt;lift[CHANNEL_RED] = RGB_lift[0] + 1.0f;</a>
<a name="ln1261">  p-&gt;lift[CHANNEL_GREEN] = RGB_lift[1] + 1.0f;</a>
<a name="ln1262">  p-&gt;lift[CHANNEL_BLUE] = RGB_lift[2] + 1.0f;</a>
<a name="ln1263">  p-&gt;gamma[CHANNEL_RED] = RGB_gamma[0];</a>
<a name="ln1264">  p-&gt;gamma[CHANNEL_GREEN] = RGB_gamma[1];</a>
<a name="ln1265">  p-&gt;gamma[CHANNEL_BLUE] = RGB_gamma[2];</a>
<a name="ln1266">  p-&gt;gain[CHANNEL_RED] = RGB_gain[0];</a>
<a name="ln1267">  p-&gt;gain[CHANNEL_GREEN] = RGB_gain[1];</a>
<a name="ln1268">  p-&gt;gain[CHANNEL_BLUE] = RGB_gain[2];</a>
<a name="ln1269"> </a>
<a name="ln1270">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1271">  dt_bauhaus_slider_set_soft(g-&gt;lift_r, RGB_lift[0]);</a>
<a name="ln1272">  dt_bauhaus_slider_set_soft(g-&gt;lift_g, RGB_lift[1]);</a>
<a name="ln1273">  dt_bauhaus_slider_set_soft(g-&gt;lift_b, RGB_lift[2]);</a>
<a name="ln1274"> </a>
<a name="ln1275">  dt_bauhaus_slider_set_soft(g-&gt;gamma_r, RGB_gamma[0] - 1.0f);</a>
<a name="ln1276">  dt_bauhaus_slider_set_soft(g-&gt;gamma_g, RGB_gamma[1] - 1.0f);</a>
<a name="ln1277">  dt_bauhaus_slider_set_soft(g-&gt;gamma_b, RGB_gamma[2] - 1.0f);</a>
<a name="ln1278"> </a>
<a name="ln1279">  dt_bauhaus_slider_set_soft(g-&gt;gain_r, RGB_gain[0] - 1.0f);</a>
<a name="ln1280">  dt_bauhaus_slider_set_soft(g-&gt;gain_g, RGB_gain[1] - 1.0f);</a>
<a name="ln1281">  dt_bauhaus_slider_set_soft(g-&gt;gain_b, RGB_gain[2] - 1.0f);</a>
<a name="ln1282"> </a>
<a name="ln1283">  set_HSL_sliders(g-&gt;hue_lift, g-&gt;sat_lift, p-&gt;lift);</a>
<a name="ln1284">  set_HSL_sliders(g-&gt;hue_gamma, g-&gt;sat_gamma, p-&gt;gamma);</a>
<a name="ln1285">  set_HSL_sliders(g-&gt;hue_gain, g-&gt;sat_gain, p-&gt;gain);</a>
<a name="ln1286">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1287"> </a>
<a name="ln1288">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1289">}</a>
<a name="ln1290"> </a>
<a name="ln1291">static void apply_autoluma(dt_iop_module_t *self)</a>
<a name="ln1292">{</a>
<a name="ln1293">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1294">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1295"> </a>
<a name="ln1296">  /*</a>
<a name="ln1297">   * If some luma patches were not picked by the user, take a</a>
<a name="ln1298">   * picture-wide patch for these.</a>
<a name="ln1299">   */</a>
<a name="ln1300">  if(g-&gt;luma_patches_flags[LIFT] == INVALID)</a>
<a name="ln1301">  {</a>
<a name="ln1302">    float XYZ[3] = { 0.0f };</a>
<a name="ln1303">    dt_Lab_to_XYZ((const float *)self-&gt;picked_color_min, XYZ);</a>
<a name="ln1304">    g-&gt;luma_patches[LIFT] = XYZ[1];</a>
<a name="ln1305">    g-&gt;luma_patches_flags[LIFT] = AUTO_SELECTED;</a>
<a name="ln1306">  }</a>
<a name="ln1307">  if(g-&gt;luma_patches_flags[GAMMA] == INVALID)</a>
<a name="ln1308">  {</a>
<a name="ln1309">    float XYZ[3] = { 0.0f };</a>
<a name="ln1310">    dt_Lab_to_XYZ((const float *)self-&gt;picked_color, XYZ);</a>
<a name="ln1311">    g-&gt;luma_patches[GAMMA] = XYZ[1];</a>
<a name="ln1312">    g-&gt;luma_patches_flags[GAMMA] = AUTO_SELECTED;</a>
<a name="ln1313">  }</a>
<a name="ln1314">  if(g-&gt;luma_patches_flags[GAIN] == INVALID)</a>
<a name="ln1315">  {</a>
<a name="ln1316">    float XYZ[3] = { 0.0f };</a>
<a name="ln1317">    dt_Lab_to_XYZ((const float *)self-&gt;picked_color_max, XYZ);</a>
<a name="ln1318">    g-&gt;luma_patches[GAIN] = XYZ[1];</a>
<a name="ln1319">    g-&gt;luma_patches_flags[GAIN] = AUTO_SELECTED;</a>
<a name="ln1320">  }</a>
<a name="ln1321"> </a>
<a name="ln1322">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1323"> </a>
<a name="ln1324">  /** Optimization loop :</a>
<a name="ln1325">  * We try to find the CDL curves that neutralize the 3 input luma patches</a>
<a name="ln1326">  */</a>
<a name="ln1327">  for (int runs = 0 ; runs &lt; 100 ; ++runs)</a>
<a name="ln1328">  {</a>
<a name="ln1329">    p-&gt;gain[CHANNEL_FACTOR] = CLAMP(p-&gt;lift[CHANNEL_FACTOR] / g-&gt;luma_patches[GAIN], 0.0f, 2.0f);</a>
<a name="ln1330">    p-&gt;lift[CHANNEL_FACTOR] = CLAMP(-p-&gt;gain[CHANNEL_FACTOR] * g-&gt;luma_patches[LIFT] + 1.0f, 0.0f, 2.0f);</a>
<a name="ln1331">    p-&gt;gamma[CHANNEL_FACTOR] = CLAMP(2.0f - logf(0.1842f) / logf(MAX(p-&gt;gain[CHANNEL_FACTOR] * g-&gt;luma_patches[GAMMA] + p-&gt;lift[CHANNEL_FACTOR] - 1.0f, 0.000001f)), 0.0f, 2.0f);</a>
<a name="ln1332">  }</a>
<a name="ln1333"> </a>
<a name="ln1334">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1335">  dt_bauhaus_slider_set_soft(g-&gt;lift_factor, (p-&gt;lift[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1336">  dt_bauhaus_slider_set_soft(g-&gt;gamma_factor, (p-&gt;gamma[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1337">  dt_bauhaus_slider_set_soft(g-&gt;gain_factor, (p-&gt;gain[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1338">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1339"> </a>
<a name="ln1340">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1341">}</a>
<a name="ln1342"> </a>
<a name="ln1343">static void _iop_color_picker_update(dt_iop_module_t *self)</a>
<a name="ln1344">{</a>
<a name="ln1345">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1346">  const int which_colorpicker = g-&gt;color_picker.current_picker;</a>
<a name="ln1347"> </a>
<a name="ln1348">  dt_bauhaus_widget_set_quad_active(g-&gt;hue_lift, which_colorpicker == DT_PICKCOLBAL_HUE_LIFT);</a>
<a name="ln1349">  dt_bauhaus_widget_set_quad_active(g-&gt;hue_gamma, which_colorpicker == DT_PICKCOLBAL_HUE_GAMMA);</a>
<a name="ln1350">  dt_bauhaus_widget_set_quad_active(g-&gt;hue_gain, which_colorpicker == DT_PICKCOLBAL_HUE_GAIN);</a>
<a name="ln1351">  dt_bauhaus_widget_set_quad_active(g-&gt;lift_factor, which_colorpicker == DT_PICKCOLBAL_LIFT_FACTOR);</a>
<a name="ln1352">  dt_bauhaus_widget_set_quad_active(g-&gt;gamma_factor, which_colorpicker == DT_PICKCOLBAL_GAMMA_FACTOR);</a>
<a name="ln1353">  dt_bauhaus_widget_set_quad_active(g-&gt;gain_factor, which_colorpicker == DT_PICKCOLBAL_GAIN_FACTOR);</a>
<a name="ln1354">  dt_bauhaus_widget_set_quad_active(g-&gt;grey, which_colorpicker == DT_PICKCOLBAL_GREY);</a>
<a name="ln1355">  dt_bauhaus_widget_set_quad_active(g-&gt;auto_luma, which_colorpicker == DT_PICKCOLBAL_AUTOLUMA);</a>
<a name="ln1356">  dt_bauhaus_widget_set_quad_active(g-&gt;auto_color, which_colorpicker == DT_PICKCOLBAL_AUTOCOLOR);</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>
<a name="ln1359">static void _iop_color_picker_apply(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1360">{</a>
<a name="ln1361">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1362">  switch(g-&gt;color_picker.current_picker)</a>
<a name="ln1363">  {</a>
<a name="ln1364">    case DT_PICKCOLBAL_HUE_LIFT:</a>
<a name="ln1365">      apply_lift_neutralize(self);</a>
<a name="ln1366">      break;</a>
<a name="ln1367">    case DT_PICKCOLBAL_HUE_GAMMA:</a>
<a name="ln1368">      apply_gamma_neutralize(self);</a>
<a name="ln1369">      break;</a>
<a name="ln1370">    case DT_PICKCOLBAL_HUE_GAIN:</a>
<a name="ln1371">      apply_gain_neutralize(self);</a>
<a name="ln1372">      break;</a>
<a name="ln1373">    case DT_PICKCOLBAL_LIFT_FACTOR:</a>
<a name="ln1374">      apply_lift_auto(self);</a>
<a name="ln1375">      break;</a>
<a name="ln1376">    case DT_PICKCOLBAL_GAMMA_FACTOR:</a>
<a name="ln1377">      apply_gamma_auto(self);</a>
<a name="ln1378">      break;</a>
<a name="ln1379">    case DT_PICKCOLBAL_GAIN_FACTOR:</a>
<a name="ln1380">      apply_gain_auto(self);</a>
<a name="ln1381">      break;</a>
<a name="ln1382">    case DT_PICKCOLBAL_GREY:</a>
<a name="ln1383">      apply_autogrey(self);</a>
<a name="ln1384">      break;</a>
<a name="ln1385">    case DT_PICKCOLBAL_AUTOLUMA:</a>
<a name="ln1386">      apply_autoluma(self);</a>
<a name="ln1387">      break;</a>
<a name="ln1388">    case DT_PICKCOLBAL_AUTOCOLOR:</a>
<a name="ln1389">      apply_autocolor(self);</a>
<a name="ln1390">      break;</a>
<a name="ln1391">    default:</a>
<a name="ln1392">      break;</a>
<a name="ln1393">  }</a>
<a name="ln1394">  _check_tuner_picker_labels(self);</a>
<a name="ln1395">}</a>
<a name="ln1396"> </a>
<a name="ln1397">static int _iop_color_picker_get_set(dt_iop_module_t *self, GtkWidget *button)</a>
<a name="ln1398">{</a>
<a name="ln1399">  dt_iop_colorbalance_gui_data_t *g =  (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1400">  const int current_picker = g-&gt;color_picker.current_picker;</a>
<a name="ln1401"> </a>
<a name="ln1402">  if(button == g-&gt;hue_lift)</a>
<a name="ln1403">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_HUE_LIFT;</a>
<a name="ln1404">  else if(button == g-&gt;hue_gamma)</a>
<a name="ln1405">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_HUE_GAMMA;</a>
<a name="ln1406">  else if(button == g-&gt;hue_gain)</a>
<a name="ln1407">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_HUE_GAIN;</a>
<a name="ln1408">  else if(button == g-&gt;lift_factor)</a>
<a name="ln1409">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_LIFT_FACTOR;</a>
<a name="ln1410">  else if(button == g-&gt;gamma_factor)</a>
<a name="ln1411">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_GAMMA_FACTOR;</a>
<a name="ln1412">  else if(button == g-&gt;gain_factor)</a>
<a name="ln1413">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_GAIN_FACTOR;</a>
<a name="ln1414">  else if(button == g-&gt;grey)</a>
<a name="ln1415">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_GREY;</a>
<a name="ln1416">  else if(button == g-&gt;auto_luma)</a>
<a name="ln1417">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_AUTOLUMA;</a>
<a name="ln1418">  else if(button == g-&gt;auto_color)</a>
<a name="ln1419">    g-&gt;color_picker.current_picker = DT_PICKCOLBAL_AUTOCOLOR;</a>
<a name="ln1420"> </a>
<a name="ln1421">  if (current_picker == g-&gt;color_picker.current_picker)</a>
<a name="ln1422">    return DT_COLOR_PICKER_ALREADY_SELECTED;</a>
<a name="ln1423">  else</a>
<a name="ln1424">    return g-&gt;color_picker.current_picker;</a>
<a name="ln1425">}</a>
<a name="ln1426"> </a>
<a name="ln1427">void gui_focus(struct dt_iop_module_t *self, gboolean in)</a>
<a name="ln1428">{</a>
<a name="ln1429">  if(!in) dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1430">}</a>
<a name="ln1431"> </a>
<a name="ln1432">void init(dt_iop_module_t *module)</a>
<a name="ln1433">{</a>
<a name="ln1434">  module-&gt;params = calloc(1, sizeof(dt_iop_colorbalance_params_t));</a>
<a name="ln1435">  module-&gt;default_params = calloc(1, sizeof(dt_iop_colorbalance_params_t));</a>
<a name="ln1436">  module-&gt;default_enabled = 0;</a>
<a name="ln1437">  module-&gt;params_size = sizeof(dt_iop_colorbalance_params_t);</a>
<a name="ln1438">  module-&gt;gui_data = NULL;</a>
<a name="ln1439">  dt_iop_colorbalance_params_t tmp = (dt_iop_colorbalance_params_t){ SLOPE_OFFSET_POWER,</a>
<a name="ln1440">                                                                     { 1.0f, 1.0f, 1.0f, 1.0f },</a>
<a name="ln1441">                                                                     { 1.0f, 1.0f, 1.0f, 1.0f },</a>
<a name="ln1442">                                                                     { 1.0f, 1.0f, 1.0f, 1.0f },</a>
<a name="ln1443">                                                                     1.0f,</a>
<a name="ln1444">                                                                     1.0f,</a>
<a name="ln1445">                                                                     18.0f,</a>
<a name="ln1446">                                                                     1.0f };</a>
<a name="ln1447"> </a>
<a name="ln1448">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_colorbalance_params_t));</a>
<a name="ln1449">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_colorbalance_params_t));</a>
<a name="ln1450">}</a>
<a name="ln1451"> </a>
<a name="ln1452">void cleanup(dt_iop_module_t *module)</a>
<a name="ln1453">{</a>
<a name="ln1454">  free(module-&gt;params);</a>
<a name="ln1455">  module-&gt;params = NULL;</a>
<a name="ln1456">}</a>
<a name="ln1457"> </a>
<a name="ln1458">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln1459">{</a>
<a name="ln1460">  const int program = 8; // extended.cl, from programs.conf</a>
<a name="ln1461">  dt_iop_colorbalance_global_data_t *gd</a>
<a name="ln1462">      = (dt_iop_colorbalance_global_data_t *)malloc(sizeof(dt_iop_colorbalance_global_data_t));</a>
<a name="ln1463">  module-&gt;data = gd;</a>
<a name="ln1464">  gd-&gt;kernel_colorbalance = dt_opencl_create_kernel(program, &quot;colorbalance&quot;);</a>
<a name="ln1465">  gd-&gt;kernel_colorbalance_lgg = dt_opencl_create_kernel(program, &quot;colorbalance_lgg&quot;);</a>
<a name="ln1466">  gd-&gt;kernel_colorbalance_cdl = dt_opencl_create_kernel(program, &quot;colorbalance_cdl&quot;);</a>
<a name="ln1467">}</a>
<a name="ln1468"> </a>
<a name="ln1469">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln1470">{</a>
<a name="ln1471">  dt_iop_colorbalance_global_data_t *gd = (dt_iop_colorbalance_global_data_t *)module-&gt;data;</a>
<a name="ln1472">  dt_opencl_free_kernel(gd-&gt;kernel_colorbalance);</a>
<a name="ln1473">  dt_opencl_free_kernel(gd-&gt;kernel_colorbalance_lgg);</a>
<a name="ln1474">  dt_opencl_free_kernel(gd-&gt;kernel_colorbalance_cdl);</a>
<a name="ln1475">  free(module-&gt;data);</a>
<a name="ln1476">  module-&gt;data = NULL;</a>
<a name="ln1477">}</a>
<a name="ln1478"> </a>
<a name="ln1479">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln1480">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1481">{</a>
<a name="ln1482">  dt_iop_colorbalance_data_t *d = (dt_iop_colorbalance_data_t *)(piece-&gt;data);</a>
<a name="ln1483">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)p1;</a>
<a name="ln1484"> </a>
<a name="ln1485">  d-&gt;mode = p-&gt;mode;</a>
<a name="ln1486"> </a>
<a name="ln1487">  switch(d-&gt;mode)</a>
<a name="ln1488">  {</a>
<a name="ln1489">    case SLOPE_OFFSET_POWER:</a>
<a name="ln1490">    {</a>
<a name="ln1491">      // Correct the luminance in RGB parameters so we don't affect it</a>
<a name="ln1492">      float XYZ[3];</a>
<a name="ln1493"> </a>
<a name="ln1494">      dt_prophotorgb_to_XYZ((const float *)&amp;p-&gt;lift[CHANNEL_RED], XYZ);</a>
<a name="ln1495">      d-&gt;lift[CHANNEL_FACTOR] = p-&gt;lift[CHANNEL_FACTOR];</a>
<a name="ln1496">      d-&gt;lift[CHANNEL_RED] = (p-&gt;lift[CHANNEL_RED] - XYZ[1]) + 1.f;</a>
<a name="ln1497">      d-&gt;lift[CHANNEL_GREEN] = (p-&gt;lift[CHANNEL_GREEN] - XYZ[1]) + 1.f;</a>
<a name="ln1498">      d-&gt;lift[CHANNEL_BLUE] = (p-&gt;lift[CHANNEL_BLUE] - XYZ[1]) + 1.f;</a>
<a name="ln1499"> </a>
<a name="ln1500">      dt_prophotorgb_to_XYZ((const float *)&amp;p-&gt;gamma[CHANNEL_RED], XYZ);</a>
<a name="ln1501">      d-&gt;gamma[CHANNEL_FACTOR] = p-&gt;gamma[CHANNEL_FACTOR];</a>
<a name="ln1502">      d-&gt;gamma[CHANNEL_RED] = (p-&gt;gamma[CHANNEL_RED] - XYZ[1]) + 1.f;</a>
<a name="ln1503">      d-&gt;gamma[CHANNEL_GREEN] = (p-&gt;gamma[CHANNEL_GREEN] - XYZ[1]) + 1.f;</a>
<a name="ln1504">      d-&gt;gamma[CHANNEL_BLUE] = (p-&gt;gamma[CHANNEL_BLUE] - XYZ[1]) + 1.f;</a>
<a name="ln1505"> </a>
<a name="ln1506">      dt_prophotorgb_to_XYZ((const float *)&amp;p-&gt;gain[CHANNEL_RED], XYZ);</a>
<a name="ln1507">      d-&gt;gain[CHANNEL_FACTOR] = p-&gt;gain[CHANNEL_FACTOR];</a>
<a name="ln1508">      d-&gt;gain[CHANNEL_RED] = (p-&gt;gain[CHANNEL_RED] - XYZ[1]) + 1.f;</a>
<a name="ln1509">      d-&gt;gain[CHANNEL_GREEN] = (p-&gt;gain[CHANNEL_GREEN] - XYZ[1]) + 1.f;</a>
<a name="ln1510">      d-&gt;gain[CHANNEL_BLUE] = (p-&gt;gain[CHANNEL_BLUE] - XYZ[1]) + 1.f;</a>
<a name="ln1511"> </a>
<a name="ln1512">      break;</a>
<a name="ln1513">    }</a>
<a name="ln1514"> </a>
<a name="ln1515">    case LEGACY:</a>
<a name="ln1516">    {</a>
<a name="ln1517">      // Luminance is not corrected in lift/gamma/gain for compatibility</a>
<a name="ln1518">      for(int i = 0; i &lt; CHANNEL_SIZE; i++)</a>
<a name="ln1519">      {</a>
<a name="ln1520">        d-&gt;lift[i] = p-&gt;lift[i];</a>
<a name="ln1521">        d-&gt;gamma[i] = p-&gt;gamma[i];</a>
<a name="ln1522">        d-&gt;gain[i] = p-&gt;gain[i];</a>
<a name="ln1523">      }</a>
<a name="ln1524"> </a>
<a name="ln1525">      break;</a>
<a name="ln1526">    }</a>
<a name="ln1527"> </a>
<a name="ln1528">    case LIFT_GAMMA_GAIN:</a>
<a name="ln1529">    {</a>
<a name="ln1530">      // Correct the luminance in RGB parameters so we don't affect it</a>
<a name="ln1531">      float XYZ[3];</a>
<a name="ln1532">      dt_prophotorgb_to_XYZ((const float *)&amp;p-&gt;lift[CHANNEL_RED], XYZ);</a>
<a name="ln1533">      d-&gt;lift[CHANNEL_FACTOR] = p-&gt;lift[CHANNEL_FACTOR];</a>
<a name="ln1534">      d-&gt;lift[CHANNEL_RED] = (p-&gt;lift[CHANNEL_RED] - XYZ[1]) + 1.f;</a>
<a name="ln1535">      d-&gt;lift[CHANNEL_GREEN] = (p-&gt;lift[CHANNEL_GREEN] - XYZ[1]) + 1.f;</a>
<a name="ln1536">      d-&gt;lift[CHANNEL_BLUE] = (p-&gt;lift[CHANNEL_BLUE] - XYZ[1]) + 1.f;</a>
<a name="ln1537"> </a>
<a name="ln1538">      dt_prophotorgb_to_XYZ((const float *)&amp;p-&gt;gamma[CHANNEL_RED], XYZ);</a>
<a name="ln1539">      d-&gt;gamma[CHANNEL_FACTOR] = p-&gt;gamma[CHANNEL_FACTOR];</a>
<a name="ln1540">      d-&gt;gamma[CHANNEL_RED] = (p-&gt;gamma[CHANNEL_RED] - XYZ[1]) + 1.f;</a>
<a name="ln1541">      d-&gt;gamma[CHANNEL_GREEN] = (p-&gt;gamma[CHANNEL_GREEN] - XYZ[1]) + 1.f;</a>
<a name="ln1542">      d-&gt;gamma[CHANNEL_BLUE] = (p-&gt;gamma[CHANNEL_BLUE] - XYZ[1]) + 1.f;</a>
<a name="ln1543"> </a>
<a name="ln1544">      dt_prophotorgb_to_XYZ((const float *)&amp;p-&gt;gain[CHANNEL_RED], XYZ);</a>
<a name="ln1545">      d-&gt;gain[CHANNEL_FACTOR] = p-&gt;gain[CHANNEL_FACTOR];</a>
<a name="ln1546">      d-&gt;gain[CHANNEL_RED] = (p-&gt;gain[CHANNEL_RED] - XYZ[1]) + 1.f;</a>
<a name="ln1547">      d-&gt;gain[CHANNEL_GREEN] = (p-&gt;gain[CHANNEL_GREEN] - XYZ[1]) + 1.f;</a>
<a name="ln1548">      d-&gt;gain[CHANNEL_BLUE] = (p-&gt;gain[CHANNEL_BLUE] - XYZ[1]) + 1.f;</a>
<a name="ln1549"> </a>
<a name="ln1550">      break;</a>
<a name="ln1551">    }</a>
<a name="ln1552">  }</a>
<a name="ln1553"> </a>
<a name="ln1554">  d-&gt;grey = p-&gt;grey;</a>
<a name="ln1555">  d-&gt;saturation = p-&gt;saturation;</a>
<a name="ln1556">  d-&gt;saturation_out = p-&gt;saturation_out;</a>
<a name="ln1557">  d-&gt;contrast = p-&gt;contrast;</a>
<a name="ln1558">}</a>
<a name="ln1559"> </a>
<a name="ln1560">void init_pipe(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1561">{</a>
<a name="ln1562">  piece-&gt;data = calloc(1, sizeof(dt_iop_colorbalance_data_t));</a>
<a name="ln1563">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln1564">}</a>
<a name="ln1565"> </a>
<a name="ln1566">void cleanup_pipe(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1567">{</a>
<a name="ln1568">  free(piece-&gt;data);</a>
<a name="ln1569">  piece-&gt;data = NULL;</a>
<a name="ln1570">}</a>
<a name="ln1571"> </a>
<a name="ln1572">void gui_update(dt_iop_module_t *self)</a>
<a name="ln1573">{</a>
<a name="ln1574">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1575">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1576"> </a>
<a name="ln1577">  self-&gt;color_picker_box[0] = self-&gt;color_picker_box[1] = .25f;</a>
<a name="ln1578">  self-&gt;color_picker_box[2] = self-&gt;color_picker_box[3] = .75f;</a>
<a name="ln1579">  self-&gt;color_picker_point[0] = self-&gt;color_picker_point[1] = 0.5f;</a>
<a name="ln1580"> </a>
<a name="ln1581">  dt_bauhaus_combobox_set(g-&gt;mode, p-&gt;mode);</a>
<a name="ln1582"> </a>
<a name="ln1583">  dt_bauhaus_slider_set_soft(g-&gt;grey, p-&gt;grey);</a>
<a name="ln1584">  dt_bauhaus_slider_set_soft(g-&gt;saturation, p-&gt;saturation * 100.0);</a>
<a name="ln1585">  dt_bauhaus_slider_set_soft(g-&gt;saturation_out, p-&gt;saturation_out * 100.0f);</a>
<a name="ln1586">  dt_bauhaus_slider_set_soft(g-&gt;contrast, (1.0f - p-&gt;contrast) * 100.0f);</a>
<a name="ln1587"> </a>
<a name="ln1588">  dt_bauhaus_slider_set_soft(g-&gt;lift_factor, (p-&gt;lift[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1589">  dt_bauhaus_slider_set_soft(g-&gt;lift_r, p-&gt;lift[CHANNEL_RED] - 1.0f);</a>
<a name="ln1590">  dt_bauhaus_slider_set_soft(g-&gt;lift_g, p-&gt;lift[CHANNEL_GREEN] - 1.0f);</a>
<a name="ln1591">  dt_bauhaus_slider_set_soft(g-&gt;lift_b, p-&gt;lift[CHANNEL_BLUE] - 1.0f);</a>
<a name="ln1592"> </a>
<a name="ln1593">  dt_bauhaus_slider_set_soft(g-&gt;gamma_factor, (p-&gt;gamma[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1594">  dt_bauhaus_slider_set_soft(g-&gt;gamma_r, p-&gt;gamma[CHANNEL_RED] - 1.0f);</a>
<a name="ln1595">  dt_bauhaus_slider_set_soft(g-&gt;gamma_g, p-&gt;gamma[CHANNEL_GREEN] - 1.0f);</a>
<a name="ln1596">  dt_bauhaus_slider_set_soft(g-&gt;gamma_b, p-&gt;gamma[CHANNEL_BLUE] - 1.0f);</a>
<a name="ln1597"> </a>
<a name="ln1598">  dt_bauhaus_slider_set_soft(g-&gt;gain_factor, (p-&gt;gain[CHANNEL_FACTOR] - 1.0f) * 100.0f);</a>
<a name="ln1599">  dt_bauhaus_slider_set_soft(g-&gt;gain_r, p-&gt;gain[CHANNEL_RED] - 1.0f);</a>
<a name="ln1600">  dt_bauhaus_slider_set_soft(g-&gt;gain_g, p-&gt;gain[CHANNEL_GREEN] - 1.0f);</a>
<a name="ln1601">  dt_bauhaus_slider_set_soft(g-&gt;gain_b, p-&gt;gain[CHANNEL_BLUE] - 1.0f);</a>
<a name="ln1602"> </a>
<a name="ln1603">  if(p-&gt;mode == LEGACY || p-&gt;mode == LIFT_GAMMA_GAIN)</a>
<a name="ln1604">  {</a>
<a name="ln1605">    gtk_widget_set_visible(g-&gt;optim_label, FALSE);</a>
<a name="ln1606">    gtk_widget_set_visible(g-&gt;auto_color, FALSE);</a>
<a name="ln1607">    gtk_widget_set_visible(g-&gt;auto_luma, FALSE);</a>
<a name="ln1608">  }</a>
<a name="ln1609">  else</a>
<a name="ln1610">  {</a>
<a name="ln1611">    gtk_widget_set_visible(g-&gt;optim_label, TRUE);</a>
<a name="ln1612">    gtk_widget_set_visible(g-&gt;auto_color, TRUE);</a>
<a name="ln1613">    gtk_widget_set_visible(g-&gt;auto_luma, TRUE);</a>
<a name="ln1614">  }</a>
<a name="ln1615"> </a>
<a name="ln1616">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1617">  _check_tuner_picker_labels(self);</a>
<a name="ln1618"> </a>
<a name="ln1619">  if(p-&gt;mode == LEGACY)</a>
<a name="ln1620">  {</a>
<a name="ln1621">    gtk_widget_set_visible(g-&gt;master_box, FALSE);</a>
<a name="ln1622">  }</a>
<a name="ln1623">  else</a>
<a name="ln1624">  {</a>
<a name="ln1625">    gtk_widget_set_visible(g-&gt;master_box, TRUE);</a>
<a name="ln1626">  }</a>
<a name="ln1627"> </a>
<a name="ln1628">  set_HSL_sliders(g-&gt;hue_lift, g-&gt;sat_lift, p-&gt;lift);</a>
<a name="ln1629">  set_HSL_sliders(g-&gt;hue_gamma, g-&gt;sat_gamma, p-&gt;gamma);</a>
<a name="ln1630">  set_HSL_sliders(g-&gt;hue_gain, g-&gt;sat_gain, p-&gt;gain);</a>
<a name="ln1631"> </a>
<a name="ln1632">  const int control_mode = dt_bauhaus_combobox_get(g-&gt;controls);</a>
<a name="ln1633"> </a>
<a name="ln1634">  switch (control_mode)</a>
<a name="ln1635">  {</a>
<a name="ln1636">    case HSL:</a>
<a name="ln1637">    {</a>
<a name="ln1638">      gtk_widget_set_visible(g-&gt;lift_r, FALSE);</a>
<a name="ln1639">      gtk_widget_set_visible(g-&gt;lift_g, FALSE);</a>
<a name="ln1640">      gtk_widget_set_visible(g-&gt;lift_b, FALSE);</a>
<a name="ln1641">      gtk_widget_set_visible(g-&gt;gamma_r, FALSE);</a>
<a name="ln1642">      gtk_widget_set_visible(g-&gt;gamma_g, FALSE);</a>
<a name="ln1643">      gtk_widget_set_visible(g-&gt;gamma_b, FALSE);</a>
<a name="ln1644">      gtk_widget_set_visible(g-&gt;gain_r, FALSE);</a>
<a name="ln1645">      gtk_widget_set_visible(g-&gt;gain_g, FALSE);</a>
<a name="ln1646">      gtk_widget_set_visible(g-&gt;gain_b, FALSE);</a>
<a name="ln1647"> </a>
<a name="ln1648">      gtk_widget_set_visible(g-&gt;hue_lift, TRUE);</a>
<a name="ln1649">      gtk_widget_set_visible(g-&gt;sat_lift, TRUE);</a>
<a name="ln1650">      gtk_widget_set_visible(g-&gt;hue_gamma, TRUE);</a>
<a name="ln1651">      gtk_widget_set_visible(g-&gt;sat_gamma, TRUE);</a>
<a name="ln1652">      gtk_widget_set_visible(g-&gt;hue_gain, TRUE);</a>
<a name="ln1653">      gtk_widget_set_visible(g-&gt;sat_gain, TRUE);</a>
<a name="ln1654">      break;</a>
<a name="ln1655">    }</a>
<a name="ln1656">    case RGBL:</a>
<a name="ln1657">    {</a>
<a name="ln1658">      gtk_widget_set_visible(g-&gt;lift_r, TRUE);</a>
<a name="ln1659">      gtk_widget_set_visible(g-&gt;lift_g, TRUE);</a>
<a name="ln1660">      gtk_widget_set_visible(g-&gt;lift_b, TRUE);</a>
<a name="ln1661">      gtk_widget_set_visible(g-&gt;gamma_r, TRUE);</a>
<a name="ln1662">      gtk_widget_set_visible(g-&gt;gamma_g, TRUE);</a>
<a name="ln1663">      gtk_widget_set_visible(g-&gt;gamma_b, TRUE);</a>
<a name="ln1664">      gtk_widget_set_visible(g-&gt;gain_r, TRUE);</a>
<a name="ln1665">      gtk_widget_set_visible(g-&gt;gain_g, TRUE);</a>
<a name="ln1666">      gtk_widget_set_visible(g-&gt;gain_b, TRUE);</a>
<a name="ln1667"> </a>
<a name="ln1668">      gtk_widget_set_visible(g-&gt;hue_lift, FALSE);</a>
<a name="ln1669">      gtk_widget_set_visible(g-&gt;sat_lift, FALSE);</a>
<a name="ln1670">      gtk_widget_set_visible(g-&gt;hue_gamma, FALSE);</a>
<a name="ln1671">      gtk_widget_set_visible(g-&gt;sat_gamma, FALSE);</a>
<a name="ln1672">      gtk_widget_set_visible(g-&gt;hue_gain, FALSE);</a>
<a name="ln1673">      gtk_widget_set_visible(g-&gt;sat_gain, FALSE);</a>
<a name="ln1674">      break;</a>
<a name="ln1675">    }</a>
<a name="ln1676">    case BOTH:</a>
<a name="ln1677">    {</a>
<a name="ln1678">      gtk_widget_set_visible(g-&gt;lift_r, TRUE);</a>
<a name="ln1679">      gtk_widget_set_visible(g-&gt;lift_g, TRUE);</a>
<a name="ln1680">      gtk_widget_set_visible(g-&gt;lift_b, TRUE);</a>
<a name="ln1681">      gtk_widget_set_visible(g-&gt;gamma_r, TRUE);</a>
<a name="ln1682">      gtk_widget_set_visible(g-&gt;gamma_g, TRUE);</a>
<a name="ln1683">      gtk_widget_set_visible(g-&gt;gamma_b, TRUE);</a>
<a name="ln1684">      gtk_widget_set_visible(g-&gt;gain_r, TRUE);</a>
<a name="ln1685">      gtk_widget_set_visible(g-&gt;gain_g, TRUE);</a>
<a name="ln1686">      gtk_widget_set_visible(g-&gt;gain_b, TRUE);</a>
<a name="ln1687"> </a>
<a name="ln1688">      gtk_widget_set_visible(g-&gt;hue_lift, TRUE);</a>
<a name="ln1689">      gtk_widget_set_visible(g-&gt;sat_lift, TRUE);</a>
<a name="ln1690">      gtk_widget_set_visible(g-&gt;hue_gamma, TRUE);</a>
<a name="ln1691">      gtk_widget_set_visible(g-&gt;sat_gamma, TRUE);</a>
<a name="ln1692">      gtk_widget_set_visible(g-&gt;hue_gain, TRUE);</a>
<a name="ln1693">      gtk_widget_set_visible(g-&gt;sat_gain, TRUE);</a>
<a name="ln1694">      break;</a>
<a name="ln1695">    }</a>
<a name="ln1696">  }</a>
<a name="ln1697">}</a>
<a name="ln1698"> </a>
<a name="ln1699">void gui_reset(dt_iop_module_t *self)</a>
<a name="ln1700">{</a>
<a name="ln1701">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1702"> </a>
<a name="ln1703">  for (int k=0; k&lt;LEVELS; k++)</a>
<a name="ln1704">  {</a>
<a name="ln1705">    g-&gt;color_patches_flags[k] = INVALID;</a>
<a name="ln1706">    g-&gt;luma_patches_flags[k] = INVALID;</a>
<a name="ln1707">  }</a>
<a name="ln1708">  _check_tuner_picker_labels(self);</a>
<a name="ln1709"> </a>
<a name="ln1710">  dt_bauhaus_combobox_set(g-&gt;controls, HSL);</a>
<a name="ln1711"> </a>
<a name="ln1712">  gtk_widget_set_visible(g-&gt;lift_r, FALSE);</a>
<a name="ln1713">  gtk_widget_set_visible(g-&gt;lift_g, FALSE);</a>
<a name="ln1714">  gtk_widget_set_visible(g-&gt;lift_b, FALSE);</a>
<a name="ln1715">  gtk_widget_set_visible(g-&gt;gamma_r, FALSE);</a>
<a name="ln1716">  gtk_widget_set_visible(g-&gt;gamma_g, FALSE);</a>
<a name="ln1717">  gtk_widget_set_visible(g-&gt;gamma_b, FALSE);</a>
<a name="ln1718">  gtk_widget_set_visible(g-&gt;gain_r, FALSE);</a>
<a name="ln1719">  gtk_widget_set_visible(g-&gt;gain_g, FALSE);</a>
<a name="ln1720">  gtk_widget_set_visible(g-&gt;gain_b, FALSE);</a>
<a name="ln1721"> </a>
<a name="ln1722">  gtk_widget_set_visible(g-&gt;hue_lift, TRUE);</a>
<a name="ln1723">  gtk_widget_set_visible(g-&gt;sat_lift, TRUE);</a>
<a name="ln1724">  gtk_widget_set_visible(g-&gt;hue_gamma, TRUE);</a>
<a name="ln1725">  gtk_widget_set_visible(g-&gt;sat_gamma, TRUE);</a>
<a name="ln1726">  gtk_widget_set_visible(g-&gt;hue_gain, TRUE);</a>
<a name="ln1727">  gtk_widget_set_visible(g-&gt;sat_gain, TRUE);</a>
<a name="ln1728"> </a>
<a name="ln1729">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1730">}</a>
<a name="ln1731"> </a>
<a name="ln1732">static void mode_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln1733">{</a>
<a name="ln1734">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1735">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1736"> </a>
<a name="ln1737">  p-&gt;mode = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1738">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1739"> </a>
<a name="ln1740">  if (p-&gt;mode == LEGACY || p-&gt;mode == LIFT_GAMMA_GAIN)</a>
<a name="ln1741">  {</a>
<a name="ln1742">    gtk_widget_set_visible(g-&gt;optim_label, FALSE);</a>
<a name="ln1743">    gtk_widget_set_visible(g-&gt;auto_color, FALSE);</a>
<a name="ln1744">    gtk_widget_set_visible(g-&gt;auto_luma, FALSE);</a>
<a name="ln1745">  }</a>
<a name="ln1746">  else</a>
<a name="ln1747">  {</a>
<a name="ln1748">    gtk_widget_set_visible(g-&gt;optim_label, TRUE);</a>
<a name="ln1749">    gtk_widget_set_visible(g-&gt;auto_color, TRUE);</a>
<a name="ln1750">    gtk_widget_set_visible(g-&gt;auto_luma, TRUE);</a>
<a name="ln1751">  }</a>
<a name="ln1752"> </a>
<a name="ln1753">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1754"> </a>
<a name="ln1755">  if (p-&gt;mode == LEGACY)</a>
<a name="ln1756">  {</a>
<a name="ln1757">    gtk_widget_set_visible(g-&gt;master_box, FALSE);</a>
<a name="ln1758">  }</a>
<a name="ln1759">  else</a>
<a name="ln1760">  {</a>
<a name="ln1761">    gtk_widget_set_visible(g-&gt;master_box, TRUE);</a>
<a name="ln1762">  }</a>
<a name="ln1763"> </a>
<a name="ln1764">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1765">}</a>
<a name="ln1766"> </a>
<a name="ln1767">static void controls_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln1768">{</a>
<a name="ln1769">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1770">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1771">  const int control_mode = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1772"> </a>
<a name="ln1773">  switch (control_mode)</a>
<a name="ln1774">  {</a>
<a name="ln1775">    case HSL:</a>
<a name="ln1776">    {</a>
<a name="ln1777">      gtk_widget_set_visible(g-&gt;lift_r, FALSE);</a>
<a name="ln1778">      gtk_widget_set_visible(g-&gt;lift_g, FALSE);</a>
<a name="ln1779">      gtk_widget_set_visible(g-&gt;lift_b, FALSE);</a>
<a name="ln1780">      gtk_widget_set_visible(g-&gt;gamma_r, FALSE);</a>
<a name="ln1781">      gtk_widget_set_visible(g-&gt;gamma_g, FALSE);</a>
<a name="ln1782">      gtk_widget_set_visible(g-&gt;gamma_b, FALSE);</a>
<a name="ln1783">      gtk_widget_set_visible(g-&gt;gain_r, FALSE);</a>
<a name="ln1784">      gtk_widget_set_visible(g-&gt;gain_g, FALSE);</a>
<a name="ln1785">      gtk_widget_set_visible(g-&gt;gain_b, FALSE);</a>
<a name="ln1786"> </a>
<a name="ln1787">      gtk_widget_set_visible(g-&gt;hue_lift, TRUE);</a>
<a name="ln1788">      gtk_widget_set_visible(g-&gt;sat_lift, TRUE);</a>
<a name="ln1789">      gtk_widget_set_visible(g-&gt;hue_gamma, TRUE);</a>
<a name="ln1790">      gtk_widget_set_visible(g-&gt;sat_gamma, TRUE);</a>
<a name="ln1791">      gtk_widget_set_visible(g-&gt;hue_gain, TRUE);</a>
<a name="ln1792">      gtk_widget_set_visible(g-&gt;sat_gain, TRUE);</a>
<a name="ln1793">      break;</a>
<a name="ln1794">    }</a>
<a name="ln1795">    case RGBL:</a>
<a name="ln1796">    {</a>
<a name="ln1797">      gtk_widget_set_visible(g-&gt;lift_r, TRUE);</a>
<a name="ln1798">      gtk_widget_set_visible(g-&gt;lift_g, TRUE);</a>
<a name="ln1799">      gtk_widget_set_visible(g-&gt;lift_b, TRUE);</a>
<a name="ln1800">      gtk_widget_set_visible(g-&gt;gamma_r, TRUE);</a>
<a name="ln1801">      gtk_widget_set_visible(g-&gt;gamma_g, TRUE);</a>
<a name="ln1802">      gtk_widget_set_visible(g-&gt;gamma_b, TRUE);</a>
<a name="ln1803">      gtk_widget_set_visible(g-&gt;gain_r, TRUE);</a>
<a name="ln1804">      gtk_widget_set_visible(g-&gt;gain_g, TRUE);</a>
<a name="ln1805">      gtk_widget_set_visible(g-&gt;gain_b, TRUE);</a>
<a name="ln1806"> </a>
<a name="ln1807">      gtk_widget_set_visible(g-&gt;hue_lift, FALSE);</a>
<a name="ln1808">      gtk_widget_set_visible(g-&gt;sat_lift, FALSE);</a>
<a name="ln1809">      gtk_widget_set_visible(g-&gt;hue_gamma, FALSE);</a>
<a name="ln1810">      gtk_widget_set_visible(g-&gt;sat_gamma, FALSE);</a>
<a name="ln1811">      gtk_widget_set_visible(g-&gt;hue_gain, FALSE);</a>
<a name="ln1812">      gtk_widget_set_visible(g-&gt;sat_gain, FALSE);</a>
<a name="ln1813">      break;</a>
<a name="ln1814">    }</a>
<a name="ln1815">    case BOTH:</a>
<a name="ln1816">    {</a>
<a name="ln1817">      gtk_widget_set_visible(g-&gt;lift_r, TRUE);</a>
<a name="ln1818">      gtk_widget_set_visible(g-&gt;lift_g, TRUE);</a>
<a name="ln1819">      gtk_widget_set_visible(g-&gt;lift_b, TRUE);</a>
<a name="ln1820">      gtk_widget_set_visible(g-&gt;gamma_r, TRUE);</a>
<a name="ln1821">      gtk_widget_set_visible(g-&gt;gamma_g, TRUE);</a>
<a name="ln1822">      gtk_widget_set_visible(g-&gt;gamma_b, TRUE);</a>
<a name="ln1823">      gtk_widget_set_visible(g-&gt;gain_r, TRUE);</a>
<a name="ln1824">      gtk_widget_set_visible(g-&gt;gain_g, TRUE);</a>
<a name="ln1825">      gtk_widget_set_visible(g-&gt;gain_b, TRUE);</a>
<a name="ln1826"> </a>
<a name="ln1827">      gtk_widget_set_visible(g-&gt;hue_lift, TRUE);</a>
<a name="ln1828">      gtk_widget_set_visible(g-&gt;sat_lift, TRUE);</a>
<a name="ln1829">      gtk_widget_set_visible(g-&gt;hue_gamma, TRUE);</a>
<a name="ln1830">      gtk_widget_set_visible(g-&gt;sat_gamma, TRUE);</a>
<a name="ln1831">      gtk_widget_set_visible(g-&gt;hue_gain, TRUE);</a>
<a name="ln1832">      gtk_widget_set_visible(g-&gt;sat_gain, TRUE);</a>
<a name="ln1833">    }</a>
<a name="ln1834">  }</a>
<a name="ln1835">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1836">}</a>
<a name="ln1837"> </a>
<a name="ln1838">static void hue_lift_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1839">{</a>
<a name="ln1840">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1841">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1842">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1843">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1844"> </a>
<a name="ln1845">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1846"> </a>
<a name="ln1847">  float hsl[3] = {dt_bauhaus_slider_get(slider) / 360.0f,</a>
<a name="ln1848">                  dt_bauhaus_slider_get(g-&gt;sat_lift) / 100.0f,</a>
<a name="ln1849">                  0.5f};</a>
<a name="ln1850"> </a>
<a name="ln1851">  update_saturation_slider_color(g-&gt;sat_lift, hsl[0]);</a>
<a name="ln1852">  set_RGB_sliders(g-&gt;lift_r, g-&gt;lift_g, g-&gt;lift_b, hsl, p-&gt;lift, p-&gt;mode);</a>
<a name="ln1853"> </a>
<a name="ln1854">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1855">}</a>
<a name="ln1856"> </a>
<a name="ln1857"> </a>
<a name="ln1858">static void sat_lift_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1859">{</a>
<a name="ln1860">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1861">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1862">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1863">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1864"> </a>
<a name="ln1865">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1866"> </a>
<a name="ln1867">  float hsl[3] = {dt_bauhaus_slider_get(g-&gt;hue_lift) / 360.0f,</a>
<a name="ln1868">                  dt_bauhaus_slider_get(slider) / 100.0f,</a>
<a name="ln1869">                  0.5f};</a>
<a name="ln1870"> </a>
<a name="ln1871">  set_RGB_sliders(g-&gt;lift_r, g-&gt;lift_g, g-&gt;lift_b, hsl, p-&gt;lift, p-&gt;mode);</a>
<a name="ln1872">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1873">}</a>
<a name="ln1874"> </a>
<a name="ln1875">static void hue_gamma_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1876">{</a>
<a name="ln1877">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1878">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1879">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1880">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1881"> </a>
<a name="ln1882">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1883"> </a>
<a name="ln1884">  float hsl[3] = {dt_bauhaus_slider_get(slider) / 360.0f,</a>
<a name="ln1885">                  dt_bauhaus_slider_get(g-&gt;sat_gamma) / 100.0f,</a>
<a name="ln1886">                  0.5f};</a>
<a name="ln1887"> </a>
<a name="ln1888">  update_saturation_slider_color(g-&gt;sat_gamma, hsl[0]);</a>
<a name="ln1889">  set_RGB_sliders(g-&gt;gamma_r, g-&gt;gamma_g, g-&gt;gamma_b, hsl, p-&gt;gamma, p-&gt;mode);</a>
<a name="ln1890"> </a>
<a name="ln1891">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1892">}</a>
<a name="ln1893"> </a>
<a name="ln1894"> </a>
<a name="ln1895">static void sat_gamma_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1896">{</a>
<a name="ln1897">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1898">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1899">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1900">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1901"> </a>
<a name="ln1902">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1903"> </a>
<a name="ln1904">  float hsl[3] = {dt_bauhaus_slider_get(g-&gt;hue_gamma) / 360.0f,</a>
<a name="ln1905">                  dt_bauhaus_slider_get(slider) / 100.0f,</a>
<a name="ln1906">                  0.5f};</a>
<a name="ln1907"> </a>
<a name="ln1908">  set_RGB_sliders(g-&gt;gamma_r, g-&gt;gamma_g, g-&gt;gamma_b, hsl, p-&gt;gamma, p-&gt;mode);</a>
<a name="ln1909"> </a>
<a name="ln1910">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1911">}</a>
<a name="ln1912"> </a>
<a name="ln1913">static void hue_gain_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1914">{</a>
<a name="ln1915">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1916">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1917">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1918">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1919"> </a>
<a name="ln1920">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1921"> </a>
<a name="ln1922">  float hsl[3] = {dt_bauhaus_slider_get(slider) / 360.0f,</a>
<a name="ln1923">                  dt_bauhaus_slider_get(g-&gt;sat_gain) / 100.0f,</a>
<a name="ln1924">                  0.5f};</a>
<a name="ln1925"> </a>
<a name="ln1926">  update_saturation_slider_color(g-&gt;sat_gain, hsl[0]);</a>
<a name="ln1927">  set_RGB_sliders(g-&gt;gain_r, g-&gt;gain_g, g-&gt;gain_b, hsl, p-&gt;gain, p-&gt;mode);</a>
<a name="ln1928"> </a>
<a name="ln1929">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1930">}</a>
<a name="ln1931"> </a>
<a name="ln1932"> </a>
<a name="ln1933">static void sat_gain_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1934">{</a>
<a name="ln1935">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1936">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1937">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1938">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1939"> </a>
<a name="ln1940">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1941"> </a>
<a name="ln1942">  float hsl[3] = {dt_bauhaus_slider_get(g-&gt;hue_gain) / 360.0f,</a>
<a name="ln1943">                  dt_bauhaus_slider_get(slider) / 100.0f,</a>
<a name="ln1944">                  0.5f};</a>
<a name="ln1945"> </a>
<a name="ln1946">  set_RGB_sliders(g-&gt;gain_r, g-&gt;gain_g, g-&gt;gain_b, hsl, p-&gt;gain, p-&gt;mode);</a>
<a name="ln1947"> </a>
<a name="ln1948">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1949">}</a>
<a name="ln1950"> </a>
<a name="ln1951">static void saturation_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln1952">{</a>
<a name="ln1953">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1954">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1955"> </a>
<a name="ln1956">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1957"> </a>
<a name="ln1958">  p-&gt;saturation = dt_bauhaus_slider_get(slider) / 100.0f;</a>
<a name="ln1959">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1960">}</a>
<a name="ln1961"> </a>
<a name="ln1962">static void saturation_out_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln1963">{</a>
<a name="ln1964">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1965">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1966"> </a>
<a name="ln1967">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1968"> </a>
<a name="ln1969">  p-&gt;saturation_out = dt_bauhaus_slider_get(slider) / 100.0f;</a>
<a name="ln1970">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1971">}</a>
<a name="ln1972"> </a>
<a name="ln1973">static void contrast_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln1974">{</a>
<a name="ln1975">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1976">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1977"> </a>
<a name="ln1978">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1979"> </a>
<a name="ln1980">  p-&gt;contrast = - dt_bauhaus_slider_get(slider) / 100.0f + 1.0f;</a>
<a name="ln1981">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1982">}</a>
<a name="ln1983"> </a>
<a name="ln1984">static void grey_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln1985">{</a>
<a name="ln1986">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1987">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1988"> </a>
<a name="ln1989">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln1990"> </a>
<a name="ln1991">  p-&gt;grey = dt_bauhaus_slider_get(slider);</a>
<a name="ln1992">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1993">}</a>
<a name="ln1994"> </a>
<a name="ln1995">static void lift_factor_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln1996">{</a>
<a name="ln1997">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln1998">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1999"> </a>
<a name="ln2000">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln2001"> </a>
<a name="ln2002">  p-&gt;lift[CHANNEL_FACTOR] = dt_bauhaus_slider_get(slider) / 100.0f + 1.0f;</a>
<a name="ln2003">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2004">}</a>
<a name="ln2005">static void lift_red_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2006">{</a>
<a name="ln2007">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2008">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2009">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2010"> </a>
<a name="ln2011">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln2012"> </a>
<a name="ln2013">  p-&gt;lift[CHANNEL_RED] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2014"> </a>
<a name="ln2015">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2016">  set_HSL_sliders(g-&gt;hue_lift, g-&gt;sat_lift, p-&gt;lift);</a>
<a name="ln2017">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2018"> </a>
<a name="ln2019">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2020">}</a>
<a name="ln2021">static void lift_green_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2022">{</a>
<a name="ln2023">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2024">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2025">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2026"> </a>
<a name="ln2027">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln2028"> </a>
<a name="ln2029">  p-&gt;lift[CHANNEL_GREEN] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2030"> </a>
<a name="ln2031">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2032">  set_HSL_sliders(g-&gt;hue_lift, g-&gt;sat_lift, p-&gt;lift);</a>
<a name="ln2033">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2034"> </a>
<a name="ln2035">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2036">}</a>
<a name="ln2037">static void lift_blue_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2038">{</a>
<a name="ln2039">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2040">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2041">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2042"> </a>
<a name="ln2043">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln2044"> </a>
<a name="ln2045">  p-&gt;lift[CHANNEL_BLUE] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2046"> </a>
<a name="ln2047">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2048">  set_HSL_sliders(g-&gt;hue_lift, g-&gt;sat_lift, p-&gt;lift);</a>
<a name="ln2049">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2050"> </a>
<a name="ln2051">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2052">}</a>
<a name="ln2053"> </a>
<a name="ln2054">static void gamma_factor_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2055">{</a>
<a name="ln2056">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2057">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2058"> </a>
<a name="ln2059">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln2060"> </a>
<a name="ln2061">  p-&gt;gamma[CHANNEL_FACTOR] = dt_bauhaus_slider_get(slider) / 100.0f + 1.0f;</a>
<a name="ln2062">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2063">}</a>
<a name="ln2064">static void gamma_red_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2065">{</a>
<a name="ln2066">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2067">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2068">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2069"> </a>
<a name="ln2070">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln2071"> </a>
<a name="ln2072">  p-&gt;gamma[CHANNEL_RED] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2073"> </a>
<a name="ln2074">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2075">  set_HSL_sliders(g-&gt;hue_gamma, g-&gt;sat_gamma, p-&gt;gamma);</a>
<a name="ln2076">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2077">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2078">}</a>
<a name="ln2079">static void gamma_green_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2080">{</a>
<a name="ln2081">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2082">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2083">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2084"> </a>
<a name="ln2085">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln2086"> </a>
<a name="ln2087">  p-&gt;gamma[CHANNEL_GREEN] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2088"> </a>
<a name="ln2089">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2090">  set_HSL_sliders(g-&gt;hue_gamma, g-&gt;sat_gamma, p-&gt;gamma);</a>
<a name="ln2091">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2092"> </a>
<a name="ln2093">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2094">}</a>
<a name="ln2095">static void gamma_blue_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2096">{</a>
<a name="ln2097">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2098">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2099">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2100"> </a>
<a name="ln2101">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln2102"> </a>
<a name="ln2103">  p-&gt;gamma[CHANNEL_BLUE] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2104"> </a>
<a name="ln2105">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2106">  set_HSL_sliders(g-&gt;hue_gamma, g-&gt;sat_gamma, p-&gt;gamma);</a>
<a name="ln2107">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2108">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2109">}</a>
<a name="ln2110"> </a>
<a name="ln2111">static void gain_factor_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2112">{</a>
<a name="ln2113">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2114">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2115"> </a>
<a name="ln2116">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln2117"> </a>
<a name="ln2118">  p-&gt;gain[CHANNEL_FACTOR] = dt_bauhaus_slider_get(slider) / 100.0f + 1.0f;</a>
<a name="ln2119">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2120">}</a>
<a name="ln2121">static void gain_red_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2122">{</a>
<a name="ln2123">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2124">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2125">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2126"> </a>
<a name="ln2127">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln2128"> </a>
<a name="ln2129">  p-&gt;gain[CHANNEL_RED] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2130"> </a>
<a name="ln2131">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2132">  set_HSL_sliders(g-&gt;hue_gain, g-&gt;sat_gain, p-&gt;gain);</a>
<a name="ln2133">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2134"> </a>
<a name="ln2135">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2136">}</a>
<a name="ln2137">static void gain_green_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2138">{</a>
<a name="ln2139">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2140">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2141">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2142"> </a>
<a name="ln2143">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln2144"> </a>
<a name="ln2145">  p-&gt;gain[CHANNEL_GREEN] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2146"> </a>
<a name="ln2147">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2148">  set_HSL_sliders(g-&gt;hue_gain, g-&gt;sat_gain, p-&gt;gain);</a>
<a name="ln2149">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2150">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2151">}</a>
<a name="ln2152">static void gain_blue_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln2153">{</a>
<a name="ln2154">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2155">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2156">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln2157"> </a>
<a name="ln2158">  dt_iop_color_picker_reset(self, TRUE);</a>
<a name="ln2159"> </a>
<a name="ln2160">  p-&gt;gain[CHANNEL_BLUE] = dt_bauhaus_slider_get(slider) + 1.0f;</a>
<a name="ln2161"> </a>
<a name="ln2162">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2163">  set_HSL_sliders(g-&gt;hue_gain, g-&gt;sat_gain, p-&gt;gain);</a>
<a name="ln2164">  darktable.gui-&gt;reset = 0;</a>
<a name="ln2165">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2166">}</a>
<a name="ln2167"> </a>
<a name="ln2168">#if 0</a>
<a name="ln2169">static gboolean dt_iop_area_draw(GtkWidget *widget, cairo_t *cr, dt_iop_module_t *self)</a>
<a name="ln2170">{</a>
<a name="ln2171">  float flt_bg = 0.5;</a>
<a name="ln2172">  if(gtk_widget_get_state_flags(widget) &amp; GTK_STATE_FLAG_SELECTED) flt_bg = 0.6;</a>
<a name="ln2173">  float flt_dark = flt_bg / 1.5, flt_light = flt_bg * 1.5;</a>
<a name="ln2174"> </a>
<a name="ln2175">  uint32_t bg = ((255 &lt;&lt; 24) | ((int)floor(flt_bg * 255 + 0.5) &lt;&lt; 16) | ((int)floor(flt_bg * 255 + 0.5) &lt;&lt; 8)</a>
<a name="ln2176">                 | (int)floor(flt_bg * 255 + 0.5));</a>
<a name="ln2177">  // bg = 0xffffffff;</a>
<a name="ln2178">  //   uint32_t dark = ((255 &lt;&lt; 24) |</a>
<a name="ln2179">  //                  ((int)floor(flt_dark * 255 + 0.5) &lt;&lt; 16) |</a>
<a name="ln2180">  //                  ((int)floor(flt_dark * 255 + 0.5) &lt;&lt; 8) |</a>
<a name="ln2181">  //                  (int)floor(flt_dark * 255 + 0.5));</a>
<a name="ln2182">  uint32_t light = ((255 &lt;&lt; 24) | ((int)floor(flt_light * 255 + 0.5) &lt;&lt; 16)</a>
<a name="ln2183">                    | ((int)floor(flt_light * 255 + 0.5) &lt;&lt; 8) | (int)floor(flt_light * 255 + 0.5));</a>
<a name="ln2184"> </a>
<a name="ln2185">  GtkAllocation allocation;</a>
<a name="ln2186">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln2187">  int width = allocation.width, height = allocation.height;</a>
<a name="ln2188">  if(width % 2 == 0) width--;</a>
<a name="ln2189">  if(height % 2 == 0) height--;</a>
<a name="ln2190">  double center_x = (float)width / 2.0, center_y = (float)height / 2.0;</a>
<a name="ln2191">  double diameter = MIN(width, height) - 4;</a>
<a name="ln2192">  double r_outside = diameter / 2.0, r_inside = r_outside * 0.87;</a>
<a name="ln2193">  double r_outside_2 = r_outside * r_outside, r_inside_2 = r_inside * r_inside;</a>
<a name="ln2194"> </a>
<a name="ln2195">  // clear the background</a>
<a name="ln2196">  cairo_set_source_rgb(cr, flt_bg, flt_bg, flt_bg);</a>
<a name="ln2197">  cairo_paint(cr);</a>
<a name="ln2198"> </a>
<a name="ln2199">  /* Create an image initialized with the ring colors */</a>
<a name="ln2200">  gint stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, width);</a>
<a name="ln2201">  guint32 *buf = (guint32 *)malloc(sizeof(guint32) * height * stride / 4);</a>
<a name="ln2202"> </a>
<a name="ln2203">  for(int y = 0; y &lt; height; y++)</a>
<a name="ln2204">  {</a>
<a name="ln2205">    guint32 *p = buf + y * width;</a>
<a name="ln2206"> </a>
<a name="ln2207">    double dy = -(y + 0.5 - center_y);</a>
<a name="ln2208"> </a>
<a name="ln2209">    for(int x = 0; x &lt; width; x++)</a>
<a name="ln2210">    {</a>
<a name="ln2211">      double dx = x + 0.5 - center_x;</a>
<a name="ln2212">      double dist = dx * dx + dy * dy;</a>
<a name="ln2213">      if(dist &lt; r_inside_2 || dist &gt; r_outside_2)</a>
<a name="ln2214">      {</a>
<a name="ln2215">        uint32_t col = bg;</a>
<a name="ln2216">        if((abs(dx) &lt; 1 &amp;&amp; abs(dy) &lt; 3) || (abs(dx) &lt; 3 &amp;&amp; abs(dy) &lt; 1)) col = light;</a>
<a name="ln2217">        *p++ = col;</a>
<a name="ln2218">        continue;</a>
<a name="ln2219">      }</a>
<a name="ln2220"> </a>
<a name="ln2221">      double angle = atan2(dy, dx) - M_PI_2;</a>
<a name="ln2222">      if(angle &lt; 0.0) angle += 2.0 * M_PI;</a>
<a name="ln2223"> </a>
<a name="ln2224">      double hue = angle / (2.0 * M_PI);</a>
<a name="ln2225"> </a>
<a name="ln2226">      float rgb[3];</a>
<a name="ln2227">      hsl2rgb(rgb, hue, 1.0, 0.5);</a>
<a name="ln2228"> </a>
<a name="ln2229">      *p++ = (((int)floor(rgb[0] * 255 + 0.5) &lt;&lt; 16) | ((int)floor(rgb[1] * 255 + 0.5) &lt;&lt; 8)</a>
<a name="ln2230">              | (int)floor(rgb[2] * 255 + 0.5));</a>
<a name="ln2231">    }</a>
<a name="ln2232">  }</a>
<a name="ln2233"> </a>
<a name="ln2234">  cairo_surface_t *source</a>
<a name="ln2235">      = cairo_image_surface_create_for_data((unsigned char *)buf, CAIRO_FORMAT_RGB24, width, height, stride);</a>
<a name="ln2236"> </a>
<a name="ln2237">  cairo_set_source_surface(cr, source, 0.0, 0.0);</a>
<a name="ln2238">  cairo_paint(cr);</a>
<a name="ln2239">  free(buf);</a>
<a name="ln2240"> </a>
<a name="ln2241">  // draw border</a>
<a name="ln2242">  float line_width = 1;</a>
<a name="ln2243">  cairo_set_line_width(cr, line_width);</a>
<a name="ln2244"> </a>
<a name="ln2245">  cairo_set_source_rgb(cr, flt_bg, flt_bg, flt_bg);</a>
<a name="ln2246">  cairo_new_path(cr);</a>
<a name="ln2247">  cairo_arc(cr, center_x, center_y, r_outside, 0.0, 2.0 * M_PI);</a>
<a name="ln2248">  cairo_stroke(cr);</a>
<a name="ln2249">  cairo_arc(cr, center_x, center_y, r_inside, 0.0, 2.0 * M_PI);</a>
<a name="ln2250">  cairo_stroke(cr);</a>
<a name="ln2251"> </a>
<a name="ln2252">  cairo_set_source_rgb(cr, flt_dark, flt_dark, flt_dark);</a>
<a name="ln2253">  cairo_new_path(cr);</a>
<a name="ln2254">  cairo_arc(cr, center_x, center_y, r_outside, M_PI, 1.5 * M_PI);</a>
<a name="ln2255">  cairo_stroke(cr);</a>
<a name="ln2256">  cairo_arc(cr, center_x, center_y, r_inside, 0.0, 0.5 * M_PI);</a>
<a name="ln2257">  cairo_stroke(cr);</a>
<a name="ln2258"> </a>
<a name="ln2259">  cairo_set_source_rgb(cr, flt_light, flt_light, flt_light);</a>
<a name="ln2260">  cairo_new_path(cr);</a>
<a name="ln2261">  cairo_arc(cr, center_x, center_y, r_outside, 0.0, 0.5 * M_PI);</a>
<a name="ln2262">  cairo_stroke(cr);</a>
<a name="ln2263">  cairo_arc(cr, center_x, center_y, r_inside, M_PI, 1.5 * M_PI);</a>
<a name="ln2264">  cairo_stroke(cr);</a>
<a name="ln2265"> </a>
<a name="ln2266">  // draw selector</a>
<a name="ln2267">  double r = 255 / 255.0, g = 155 / 255.0, b = 40 / 255.0;</a>
<a name="ln2268">  double h, s, v;</a>
<a name="ln2269"> </a>
<a name="ln2270">  gtk_rgb_to_hsv(r, g, b, &amp;h, &amp;s, &amp;v);</a>
<a name="ln2271"> </a>
<a name="ln2272">  cairo_save(cr);</a>
<a name="ln2273">  cairo_set_source_rgba(cr, 1.0, 1.0, 1.0, 0.7);</a>
<a name="ln2274"> </a>
<a name="ln2275">  cairo_translate(cr, center_x, center_y);</a>
<a name="ln2276">  cairo_rotate(cr, h * 2.0 * M_PI - M_PI_2);</a>
<a name="ln2277"> </a>
<a name="ln2278">  cairo_arc(cr, r_inside * v, 0.0, 3.0, 0, 2.0 * M_PI);</a>
<a name="ln2279">  cairo_stroke(cr);</a>
<a name="ln2280"> </a>
<a name="ln2281">  cairo_restore(cr);</a>
<a name="ln2282"> </a>
<a name="ln2283">  cairo_surface_destroy(source);</a>
<a name="ln2284"> </a>
<a name="ln2285">  return TRUE;</a>
<a name="ln2286">}</a>
<a name="ln2287">#endif</a>
<a name="ln2288"> </a>
<a name="ln2289">static void draw_hue_slider(GtkWidget *slider)</a>
<a name="ln2290">{</a>
<a name="ln2291">  dt_bauhaus_slider_set_stop(slider, 0.0f, 1.0f, 0.0f, 0.0f);</a>
<a name="ln2292">  dt_bauhaus_slider_set_stop(slider, 0.166f, 1.0f, 1.0f, 0.0f);</a>
<a name="ln2293">  dt_bauhaus_slider_set_stop(slider, 0.322f, 0.0f, 1.0f, 0.0f);</a>
<a name="ln2294">  dt_bauhaus_slider_set_stop(slider, 0.498f, 0.0f, 1.0f, 1.0f);</a>
<a name="ln2295">  dt_bauhaus_slider_set_stop(slider, 0.664f, 0.0f, 0.0f, 1.0f);</a>
<a name="ln2296">  dt_bauhaus_slider_set_stop(slider, 0.830f, 1.0f, 0.0f, 1.0f);</a>
<a name="ln2297">  dt_bauhaus_slider_set_stop(slider, 1.0f, 1.0f, 0.0f, 0.0f);</a>
<a name="ln2298">}</a>
<a name="ln2299"> </a>
<a name="ln2300">void gui_init(dt_iop_module_t *self)</a>
<a name="ln2301">{</a>
<a name="ln2302">  self-&gt;gui_data = malloc(sizeof(dt_iop_colorbalance_gui_data_t));</a>
<a name="ln2303">  dt_iop_colorbalance_gui_data_t *g = (dt_iop_colorbalance_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2304">  dt_iop_colorbalance_params_t *p = (dt_iop_colorbalance_params_t *)self-&gt;params;</a>
<a name="ln2305"> </a>
<a name="ln2306">  g-&gt;mode = NULL;</a>
<a name="ln2307"> </a>
<a name="ln2308">  for (int k=0; k&lt;LEVELS; k++)</a>
<a name="ln2309">  {</a>
<a name="ln2310">    g-&gt;color_patches_flags[k] = INVALID;</a>
<a name="ln2311">    g-&gt;luma_patches_flags[k] = INVALID;</a>
<a name="ln2312">  }</a>
<a name="ln2313"> </a>
<a name="ln2314">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln2315">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln2316"> </a>
<a name="ln2317">  // mode choice</a>
<a name="ln2318">  g-&gt;mode = dt_bauhaus_combobox_new(self);</a>
<a name="ln2319">  dt_bauhaus_widget_set_label(g-&gt;mode, NULL, _(&quot;mode&quot;));</a>
<a name="ln2320">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;lift, gamma, gain (ProPhotoRGB)&quot;));</a>
<a name="ln2321">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;slope, offset, power (ProPhotoRGB)&quot;));</a>
<a name="ln2322">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;lift, gamma, gain (sRGB)&quot;));</a>
<a name="ln2323">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(g-&gt;mode), TRUE, TRUE, 0);</a>
<a name="ln2324">  gtk_widget_set_tooltip_text(g-&gt;mode, _(&quot;color-grading mapping method&quot;));</a>
<a name="ln2325">  g_signal_connect(G_OBJECT(g-&gt;mode), &quot;value-changed&quot;, G_CALLBACK(mode_callback), self);</a>
<a name="ln2326"> </a>
<a name="ln2327">  // control choice</a>
<a name="ln2328">  g-&gt;controls = dt_bauhaus_combobox_new(self);</a>
<a name="ln2329">  dt_bauhaus_widget_set_label(g-&gt;controls, NULL, _(&quot;color control sliders&quot;));</a>
<a name="ln2330">  dt_bauhaus_combobox_add(g-&gt;controls, _(&quot;HSL&quot;));</a>
<a name="ln2331">  dt_bauhaus_combobox_add(g-&gt;controls, _(&quot;RGBL&quot;));</a>
<a name="ln2332">  dt_bauhaus_combobox_add(g-&gt;controls, _(&quot;both&quot;));</a>
<a name="ln2333">  dt_bauhaus_combobox_set_default(g-&gt;controls, HSL);</a>
<a name="ln2334">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(g-&gt;controls), TRUE, TRUE, 0);</a>
<a name="ln2335">  gtk_widget_set_tooltip_text(g-&gt;controls, _(&quot;color-grading mapping method&quot;));</a>
<a name="ln2336">  g_signal_connect(G_OBJECT(g-&gt;controls), &quot;value-changed&quot;, G_CALLBACK(controls_callback), self);</a>
<a name="ln2337"> </a>
<a name="ln2338">  // master</a>
<a name="ln2339">  g-&gt;master_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln2340">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(g-&gt;master_box), TRUE, TRUE, 0);</a>
<a name="ln2341"> </a>
<a name="ln2342">  gtk_box_pack_start(GTK_BOX(g-&gt;master_box), dt_ui_section_label_new(_(&quot;master&quot;)), FALSE, FALSE, 2);</a>
<a name="ln2343"> </a>
<a name="ln2344">  g-&gt;saturation = dt_bauhaus_slider_new_with_range(self, 50.0, 150.0, 0.5, p-&gt;saturation * 100.0, 2);</a>
<a name="ln2345">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;saturation, 0.0f, 200.0f);</a>
<a name="ln2346">  dt_bauhaus_slider_set_format(g-&gt;saturation, &quot;%.2f %%&quot;);</a>
<a name="ln2347">  dt_bauhaus_widget_set_label(g-&gt;saturation, NULL, _(&quot;input saturation&quot;));</a>
<a name="ln2348">  gtk_box_pack_start(GTK_BOX(g-&gt;master_box), g-&gt;saturation, TRUE, TRUE, 0);</a>
<a name="ln2349">  gtk_widget_set_tooltip_text(g-&gt;saturation, _(&quot;saturation correction before the color balance&quot;));</a>
<a name="ln2350">  g_signal_connect(G_OBJECT(g-&gt;saturation), &quot;value-changed&quot;, G_CALLBACK(saturation_callback), self);</a>
<a name="ln2351"> </a>
<a name="ln2352">  g-&gt;saturation_out = dt_bauhaus_slider_new_with_range(self, 50.0, 150.0, 0.5, p-&gt;saturation_out * 100.0, 2);</a>
<a name="ln2353">  dt_bauhaus_slider_set_format(g-&gt;saturation_out, &quot;%.2f %%&quot;);</a>
<a name="ln2354">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;saturation_out, 0.0, 200.0f);</a>
<a name="ln2355">  dt_bauhaus_widget_set_label(g-&gt;saturation_out, NULL, _(&quot;output saturation&quot;));</a>
<a name="ln2356">  gtk_box_pack_start(GTK_BOX(g-&gt;master_box), g-&gt;saturation_out, TRUE, TRUE, 0);</a>
<a name="ln2357">  gtk_widget_set_tooltip_text(g-&gt;saturation_out, _(&quot;saturation correction after the color balance&quot;));</a>
<a name="ln2358">  g_signal_connect(G_OBJECT(g-&gt;saturation_out), &quot;value-changed&quot;, G_CALLBACK(saturation_out_callback), self);</a>
<a name="ln2359"> </a>
<a name="ln2360">  g-&gt;grey = dt_bauhaus_slider_new_with_range(self, 0.1, 100., 0.5, p-&gt;grey, 2);</a>
<a name="ln2361">  dt_bauhaus_widget_set_label(g-&gt;grey, NULL, _(&quot;contrast fulcrum&quot;));</a>
<a name="ln2362">  gtk_box_pack_start(GTK_BOX(g-&gt;master_box), g-&gt;grey, TRUE, TRUE, 0);</a>
<a name="ln2363">  dt_bauhaus_slider_set_format(g-&gt;grey, &quot;%.2f %%&quot;);</a>
<a name="ln2364">  gtk_widget_set_tooltip_text(g-&gt;grey, _(&quot;adjust to match a neutral tone&quot;));</a>
<a name="ln2365">  g_signal_connect(G_OBJECT(g-&gt;grey), &quot;value-changed&quot;, G_CALLBACK(grey_callback), self);</a>
<a name="ln2366">  dt_bauhaus_widget_set_quad_paint(g-&gt;grey, dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2367">  dt_bauhaus_widget_set_quad_toggle(g-&gt;grey, TRUE);</a>
<a name="ln2368">  g_signal_connect(G_OBJECT(g-&gt;grey), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2369"> </a>
<a name="ln2370">  g-&gt;contrast = dt_bauhaus_slider_new_with_range(self, -50, 50, 0.5, (p-&gt;contrast - 1.0f)*100.0f, 2);</a>
<a name="ln2371">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;contrast, -99, 99);</a>
<a name="ln2372">  dt_bauhaus_slider_set_format(g-&gt;contrast, &quot;%+.2f %%&quot;);</a>
<a name="ln2373">  dt_bauhaus_widget_set_label(g-&gt;contrast, NULL, _(&quot;contrast&quot;));</a>
<a name="ln2374">  gtk_box_pack_start(GTK_BOX(g-&gt;master_box), g-&gt;contrast, TRUE, TRUE, 0);</a>
<a name="ln2375">  gtk_widget_set_tooltip_text(g-&gt;contrast, _(&quot;contrast&quot;));</a>
<a name="ln2376">  g_signal_connect(G_OBJECT(g-&gt;contrast), &quot;value-changed&quot;, G_CALLBACK(contrast_callback), self);</a>
<a name="ln2377"> </a>
<a name="ln2378"> </a>
<a name="ln2379">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, DT_BAUHAUS_SPACE);</a>
<a name="ln2380">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), hbox, FALSE, FALSE, 0);</a>
<a name="ln2381"> </a>
<a name="ln2382">#if 0//def SHOW_COLOR_WHEELS</a>
<a name="ln2383">  GtkWidget *area = dtgtk_drawing_area_new_with_aspect_ratio(1.0);</a>
<a name="ln2384">  gtk_box_pack_start(GTK_BOX(hbox), area, TRUE, TRUE, 0);</a>
<a name="ln2385"> </a>
<a name="ln2386">  //   gtk_widget_add_events(g-&gt;area,</a>
<a name="ln2387">  //                         GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |</a>
<a name="ln2388">  //                         GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_LEAVE_NOTIFY_MASK);</a>
<a name="ln2389">  g_signal_connect(G_OBJECT(area), &quot;draw&quot;, G_CALLBACK(dt_iop_area_draw), self);</a>
<a name="ln2390">  //   g_signal_connect (G_OBJECT (area), &quot;button-press-event&quot;,</a>
<a name="ln2391">  //                     G_CALLBACK (dt_iop_colorbalance_button_press), self);</a>
<a name="ln2392">  //   g_signal_connect (G_OBJECT (area), &quot;motion-notify-event&quot;,</a>
<a name="ln2393">  //                     G_CALLBACK (dt_iop_colorbalance_motion_notify), self);</a>
<a name="ln2394">  //   g_signal_connect (G_OBJECT (area), &quot;leave-notify-event&quot;,</a>
<a name="ln2395">  //                     G_CALLBACK (dt_iop_colorbalance_leave_notify), self);</a>
<a name="ln2396"> </a>
<a name="ln2397">  area = dtgtk_drawing_area_new_with_aspect_ratio(1.0);</a>
<a name="ln2398">  gtk_box_pack_start(GTK_BOX(hbox), area, TRUE, TRUE, 0);</a>
<a name="ln2399"> </a>
<a name="ln2400">  //   gtk_widget_add_events(g-&gt;area,</a>
<a name="ln2401">  //                         GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |</a>
<a name="ln2402">  //                         GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_LEAVE_NOTIFY_MASK);</a>
<a name="ln2403">  g_signal_connect(G_OBJECT(area), &quot;draw&quot;, G_CALLBACK(dt_iop_area_draw), self);</a>
<a name="ln2404">  //   g_signal_connect (G_OBJECT (area), &quot;button-press-event&quot;,</a>
<a name="ln2405">  //                     G_CALLBACK (dt_iop_colorbalance_button_press), self);</a>
<a name="ln2406">  //   g_signal_connect (G_OBJECT (area), &quot;motion-notify-event&quot;,</a>
<a name="ln2407">  //                     G_CALLBACK (dt_iop_colorbalance_motion_notify), self);</a>
<a name="ln2408">  //   g_signal_connect (G_OBJECT (area), &quot;leave-notify-event&quot;,</a>
<a name="ln2409">  //                     G_CALLBACK (dt_iop_colorbalance_leave_notify), self);</a>
<a name="ln2410"> </a>
<a name="ln2411">  area = dtgtk_drawing_area_new_with_aspect_ratio(1.0);</a>
<a name="ln2412">  gtk_box_pack_start(GTK_BOX(hbox), area, TRUE, TRUE, 0);</a>
<a name="ln2413"> </a>
<a name="ln2414">  //   gtk_widget_add_events(g-&gt;area,</a>
<a name="ln2415">  //                         GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |</a>
<a name="ln2416">  //                         GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_LEAVE_NOTIFY_MASK);</a>
<a name="ln2417">  g_signal_connect(G_OBJECT(area), &quot;draw&quot;, G_CALLBACK(dt_iop_area_draw), self);</a>
<a name="ln2418">//   g_signal_connect (G_OBJECT (area), &quot;button-press-event&quot;,</a>
<a name="ln2419">//                     G_CALLBACK (dt_iop_colorbalance_button_press), self);</a>
<a name="ln2420">//   g_signal_connect (G_OBJECT (area), &quot;motion-notify-event&quot;,</a>
<a name="ln2421">//                     G_CALLBACK (dt_iop_colorbalance_motion_notify), self);</a>
<a name="ln2422">//   g_signal_connect (G_OBJECT (area), &quot;leave-notify-event&quot;,</a>
<a name="ln2423">//                     G_CALLBACK (dt_iop_colorbalance_leave_notify), self);</a>
<a name="ln2424">#endif</a>
<a name="ln2425"> </a>
<a name="ln2426">#define ADD_FACTOR(which)                                                                                         \</a>
<a name="ln2427">  g-&gt;which##_factor = dt_bauhaus_slider_new_with_range_and_feedback(self, -50.0, 50.0, 0.5,                      \</a>
<a name="ln2428">                                                                    (p-&gt;which[CHANNEL_FACTOR] - 1.0f) * 100.0f, 2, 0);       \</a>
<a name="ln2429">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;which##_factor, -100.0, 100.0);                                         \</a>
<a name="ln2430">  dt_bauhaus_slider_set_format(g-&gt;which##_factor, &quot;%.2f %%&quot;);                                                     \</a>
<a name="ln2431">  dt_bauhaus_slider_set_stop(g-&gt;which##_factor, 0.0, 0.0, 0.0, 0.0);                                              \</a>
<a name="ln2432">  dt_bauhaus_slider_set_stop(g-&gt;which##_factor, 1.0, 1.0, 1.0, 1.0);                                              \</a>
<a name="ln2433">  gtk_widget_set_tooltip_text(g-&gt;which##_factor, _(&quot;factor of &quot; #which));                                         \</a>
<a name="ln2434">  dt_bauhaus_widget_set_label(g-&gt;which##_factor, _(#which), _(&quot;factor&quot;));                                         \</a>
<a name="ln2435">  g_signal_connect(G_OBJECT(g-&gt;which##_factor), &quot;value-changed&quot;, G_CALLBACK(which##_factor_callback), self);      \</a>
<a name="ln2436">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;which##_factor, TRUE, TRUE, 0);                                    \</a>
<a name="ln2437">  dt_bauhaus_widget_set_quad_paint(g-&gt;which##_factor, dtgtk_cairo_paint_colorpicker,                              \</a>
<a name="ln2438">                                   CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);                                 \</a>
<a name="ln2439">  dt_bauhaus_widget_set_quad_toggle(g-&gt;which##_factor, TRUE);                                                     \</a>
<a name="ln2440">  g_signal_connect(G_OBJECT(g-&gt;which##_factor), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2441"> </a>
<a name="ln2442">#define ADD_CHANNEL(which, c, n, N) \</a>
<a name="ln2443">  g-&gt;which##_##c = dt_bauhaus_slider_new_with_range_and_feedback(self, -0.5, 0.5, 0.0005, p-&gt;which[CHANNEL_##N] - 1.0f, 5, 0);\</a>
<a name="ln2444">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;which##_##c, -1.0, 1.0); \</a>
<a name="ln2445">  gtk_widget_set_tooltip_text(g-&gt;which##_##c, _(&quot;factor of &quot; #n &quot; for &quot; #which));\</a>
<a name="ln2446">  dt_bauhaus_widget_set_label(g-&gt;which##_##c, _(#which), _(#n));\</a>
<a name="ln2447">  g_signal_connect(G_OBJECT(g-&gt;which##_##c), &quot;value-changed&quot;, G_CALLBACK(which##_##n##_callback), self);\</a>
<a name="ln2448">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;which##_##c, TRUE, TRUE, 0);</a>
<a name="ln2449"> </a>
<a name="ln2450">  /* lift */</a>
<a name="ln2451">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), dt_ui_section_label_new(_(&quot;shadows : lift / offset&quot;)), FALSE, FALSE, 5);</a>
<a name="ln2452"> </a>
<a name="ln2453">  static const char *lift_messages[] = { N_(&quot;factor of lift&quot;), N_(&quot;lift&quot;) };</a>
<a name="ln2454">  (void)lift_messages;</a>
<a name="ln2455">  ADD_FACTOR(lift)</a>
<a name="ln2456"> </a>
<a name="ln2457">  g-&gt;hue_lift = dt_bauhaus_slider_new_with_range_and_feedback(self, 0.0f, 360.0f, 0.5f, 0.0f, 2, 0);</a>
<a name="ln2458">  dt_bauhaus_widget_set_label(g-&gt;hue_lift, NULL, _(&quot;hue&quot;));</a>
<a name="ln2459">  dt_bauhaus_slider_set_format(g-&gt;hue_lift, &quot;%.2f ¬∞&quot;);</a>
<a name="ln2460">  draw_hue_slider(g-&gt;hue_lift);</a>
<a name="ln2461">  gtk_widget_set_tooltip_text(g-&gt;hue_lift, _(&quot;select the hue&quot;));</a>
<a name="ln2462">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;hue_lift, TRUE, TRUE, 0);</a>
<a name="ln2463">  g_signal_connect(G_OBJECT(g-&gt;hue_lift), &quot;value-changed&quot;, G_CALLBACK(hue_lift_callback), self);</a>
<a name="ln2464">  dt_bauhaus_widget_set_quad_paint(g-&gt;hue_lift, dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2465">  dt_bauhaus_widget_set_quad_toggle(g-&gt;hue_lift, TRUE);</a>
<a name="ln2466">  g_signal_connect(G_OBJECT(g-&gt;hue_lift), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2467"> </a>
<a name="ln2468">  g-&gt;sat_lift = dt_bauhaus_slider_new_with_range_and_feedback(self, 0.0f, 25.0f, 0.5f, 0.0f, 2, 0);</a>
<a name="ln2469">  dt_bauhaus_slider_set_format(g-&gt;sat_lift, &quot;%.2f %%&quot;);</a>
<a name="ln2470">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;sat_lift, 0.0f, 100.0f);</a>
<a name="ln2471">  dt_bauhaus_widget_set_label(g-&gt;sat_lift, NULL, _(&quot;saturation&quot;));</a>
<a name="ln2472">  dt_bauhaus_slider_set_stop(g-&gt;sat_lift, 0.0f, 0.2f, 0.2f, 0.2f);</a>
<a name="ln2473">  dt_bauhaus_slider_set_stop(g-&gt;sat_lift, 1.0f, 1.0f, 1.0f, 1.0f);</a>
<a name="ln2474">  gtk_widget_set_tooltip_text(g-&gt;sat_lift, _(&quot;select the saturation&quot;));</a>
<a name="ln2475">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;sat_lift, TRUE, TRUE, 0);</a>
<a name="ln2476">  g_signal_connect(G_OBJECT(g-&gt;sat_lift), &quot;value-changed&quot;, G_CALLBACK(sat_lift_callback), self);</a>
<a name="ln2477"> </a>
<a name="ln2478"> </a>
<a name="ln2479">  static const char *lift_red_messages[] = { N_(&quot;factor of red for lift&quot;), N_(&quot;red&quot;) };</a>
<a name="ln2480">  (void)lift_red_messages;</a>
<a name="ln2481">  ADD_CHANNEL(lift, r, red, RED)</a>
<a name="ln2482">  dt_bauhaus_slider_set_stop(g-&gt;lift_r, 0.0, 0.0, 1.0, 1.0);</a>
<a name="ln2483">  dt_bauhaus_slider_set_stop(g-&gt;lift_r, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2484">  dt_bauhaus_slider_set_stop(g-&gt;lift_r, 1.0, 1.0, 0.0, 0.0);</a>
<a name="ln2485"> </a>
<a name="ln2486">  static const char *lift_green_messages[] = { N_(&quot;factor of green for lift&quot;), N_(&quot;green&quot;) };</a>
<a name="ln2487">  (void)lift_green_messages;</a>
<a name="ln2488">  ADD_CHANNEL(lift, g, green, GREEN)</a>
<a name="ln2489">  dt_bauhaus_slider_set_stop(g-&gt;lift_g, 0.0, 1.0, 0.0, 1.0);</a>
<a name="ln2490">  dt_bauhaus_slider_set_stop(g-&gt;lift_g, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2491">  dt_bauhaus_slider_set_stop(g-&gt;lift_g, 1.0, 0.0, 1.0, 0.0);</a>
<a name="ln2492"> </a>
<a name="ln2493">  static const char *lift_blue_messages[] = { N_(&quot;factor of blue for lift&quot;), N_(&quot;blue&quot;) };</a>
<a name="ln2494">  (void)lift_blue_messages;</a>
<a name="ln2495">  ADD_CHANNEL(lift, b, blue, BLUE)</a>
<a name="ln2496">  dt_bauhaus_slider_set_stop(g-&gt;lift_b, 0.0, 1.0, 1.0, 0.0);</a>
<a name="ln2497">  dt_bauhaus_slider_set_stop(g-&gt;lift_b, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2498">  dt_bauhaus_slider_set_stop(g-&gt;lift_b, 1.0, 0.0, 0.0, 1.0);</a>
<a name="ln2499"> </a>
<a name="ln2500">  /* gamma */</a>
<a name="ln2501">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), dt_ui_section_label_new(_(&quot;mid-tones : gamma / power&quot;)), FALSE, FALSE, 5);</a>
<a name="ln2502"> </a>
<a name="ln2503">  static const char *gamma_messages[] = { N_(&quot;factor of gamma&quot;), N_(&quot;gamma&quot;) };</a>
<a name="ln2504">  (void)gamma_messages;</a>
<a name="ln2505">  ADD_FACTOR(gamma)</a>
<a name="ln2506"> </a>
<a name="ln2507">  g-&gt;hue_gamma = dt_bauhaus_slider_new_with_range_and_feedback(self, 0.0f, 360.0f, 0.5f, 0.0f, 2, 0);</a>
<a name="ln2508">  dt_bauhaus_widget_set_label(g-&gt;hue_gamma, NULL, _(&quot;hue&quot;));</a>
<a name="ln2509">  dt_bauhaus_slider_set_format(g-&gt;hue_gamma, &quot;%.2f ¬∞&quot;);</a>
<a name="ln2510">  draw_hue_slider(g-&gt;hue_gamma);</a>
<a name="ln2511">  gtk_widget_set_tooltip_text(g-&gt;hue_gamma, _(&quot;select the hue&quot;));</a>
<a name="ln2512">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;hue_gamma, TRUE, TRUE, 0);</a>
<a name="ln2513">  g_signal_connect(G_OBJECT(g-&gt;hue_gamma), &quot;value-changed&quot;, G_CALLBACK(hue_gamma_callback), self);</a>
<a name="ln2514">  dt_bauhaus_widget_set_quad_paint(g-&gt;hue_gamma, dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2515">  dt_bauhaus_widget_set_quad_toggle(g-&gt;hue_gamma, TRUE);</a>
<a name="ln2516">  g_signal_connect(G_OBJECT(g-&gt;hue_gamma), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2517"> </a>
<a name="ln2518">  g-&gt;sat_gamma = dt_bauhaus_slider_new_with_range_and_feedback(self, 0.0f, 25.0f, 0.5f, 0.0f, 2, 0);</a>
<a name="ln2519">  dt_bauhaus_slider_set_format(g-&gt;sat_gamma, &quot;%.2f %%&quot;);</a>
<a name="ln2520">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;sat_gamma, 0.0f, 100.0f);</a>
<a name="ln2521">  dt_bauhaus_widget_set_label(g-&gt;sat_gamma, NULL, _(&quot;saturation&quot;));</a>
<a name="ln2522">  dt_bauhaus_slider_set_stop(g-&gt;sat_gamma, 0.0f, 0.2f, 0.2f, 0.2f);</a>
<a name="ln2523">  dt_bauhaus_slider_set_stop(g-&gt;sat_gamma, 1.0f, 1.0f, 1.0f, 1.0f);</a>
<a name="ln2524">  gtk_widget_set_tooltip_text(g-&gt;sat_gamma, _(&quot;select the saturation&quot;));</a>
<a name="ln2525">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;sat_gamma, TRUE, TRUE, 0);</a>
<a name="ln2526">  g_signal_connect(G_OBJECT(g-&gt;sat_gamma), &quot;value-changed&quot;, G_CALLBACK(sat_gamma_callback), self);</a>
<a name="ln2527"> </a>
<a name="ln2528">  static const char *gamma_red_messages[] = { N_(&quot;factor of red for gamma&quot;) };</a>
<a name="ln2529">  (void)gamma_red_messages;</a>
<a name="ln2530">  ADD_CHANNEL(gamma, r, red, RED)</a>
<a name="ln2531">  dt_bauhaus_slider_set_stop(g-&gt;gamma_r, 0.0, 0.0, 1.0, 1.0);</a>
<a name="ln2532">  dt_bauhaus_slider_set_stop(g-&gt;gamma_r, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2533">  dt_bauhaus_slider_set_stop(g-&gt;gamma_r, 1.0, 1.0, 0.0, 0.0);</a>
<a name="ln2534"> </a>
<a name="ln2535">  static const char *gamma_green_messages[] = { N_(&quot;factor of green for gamma&quot;) };</a>
<a name="ln2536">  (void)gamma_green_messages;</a>
<a name="ln2537">  ADD_CHANNEL(gamma, g, green, GREEN)</a>
<a name="ln2538">  dt_bauhaus_slider_set_stop(g-&gt;gamma_g, 0.0, 1.0, 0.0, 1.0);</a>
<a name="ln2539">  dt_bauhaus_slider_set_stop(g-&gt;gamma_g, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2540">  dt_bauhaus_slider_set_stop(g-&gt;gamma_g, 1.0, 0.0, 1.0, 0.0);</a>
<a name="ln2541"> </a>
<a name="ln2542">  static const char *gamma_blue_messages[] = { N_(&quot;factor of blue for gamma&quot;) };</a>
<a name="ln2543">  (void)gamma_blue_messages;</a>
<a name="ln2544">  ADD_CHANNEL(gamma, b, blue, BLUE)</a>
<a name="ln2545">  dt_bauhaus_slider_set_stop(g-&gt;gamma_b, 0.0, 1.0, 1.0, 0.0);</a>
<a name="ln2546">  dt_bauhaus_slider_set_stop(g-&gt;gamma_b, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2547">  dt_bauhaus_slider_set_stop(g-&gt;gamma_b, 1.0, 0.0, 0.0, 1.0);</a>
<a name="ln2548"> </a>
<a name="ln2549">  /* gain */</a>
<a name="ln2550">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), dt_ui_section_label_new(_(&quot;highlights : gain / slope&quot;)), FALSE, FALSE, 5);</a>
<a name="ln2551"> </a>
<a name="ln2552">  static const char *gain_messages[] = { N_(&quot;factor of gain&quot;), N_(&quot;gain&quot;) };</a>
<a name="ln2553">  (void)gain_messages;</a>
<a name="ln2554">  ADD_FACTOR(gain)</a>
<a name="ln2555"> </a>
<a name="ln2556">  g-&gt;hue_gain = dt_bauhaus_slider_new_with_range_and_feedback(self, 0.0f, 360.0f, 0.05f, 0.0f, 2, 0);</a>
<a name="ln2557">  dt_bauhaus_widget_set_label(g-&gt;hue_gain, NULL, _(&quot;hue&quot;));</a>
<a name="ln2558">  dt_bauhaus_slider_set_format(g-&gt;hue_gain, &quot;%.2f ¬∞&quot;);</a>
<a name="ln2559">  draw_hue_slider(g-&gt;hue_gain);</a>
<a name="ln2560">  gtk_widget_set_tooltip_text(g-&gt;hue_gain, _(&quot;select the hue&quot;));</a>
<a name="ln2561">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;hue_gain, TRUE, TRUE, 0);</a>
<a name="ln2562">  g_signal_connect(G_OBJECT(g-&gt;hue_gain), &quot;value-changed&quot;, G_CALLBACK(hue_gain_callback), self);</a>
<a name="ln2563">  dt_bauhaus_widget_set_quad_paint(g-&gt;hue_gain, dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2564">  dt_bauhaus_widget_set_quad_toggle(g-&gt;hue_gain, TRUE);</a>
<a name="ln2565">  g_signal_connect(G_OBJECT(g-&gt;hue_gain), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2566"> </a>
<a name="ln2567">  g-&gt;sat_gain = dt_bauhaus_slider_new_with_range_and_feedback(self, 0.0f, 25.0f, 0.5f, 0.0f, 2, 0);</a>
<a name="ln2568">  dt_bauhaus_slider_set_format(g-&gt;sat_gain, &quot;%.2f %%&quot;);</a>
<a name="ln2569">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;sat_gain, 0.0f, 100.0f);</a>
<a name="ln2570">  dt_bauhaus_widget_set_label(g-&gt;sat_gain, NULL, _(&quot;saturation&quot;));</a>
<a name="ln2571">  dt_bauhaus_slider_set_stop(g-&gt;sat_gain, 0.0f, 0.2f, 0.2f, 0.2f);</a>
<a name="ln2572">  dt_bauhaus_slider_set_stop(g-&gt;sat_gain, 1.0f, 1.0f, 1.0f, 1.0f);</a>
<a name="ln2573">  gtk_widget_set_tooltip_text(g-&gt;sat_gain, _(&quot;select the saturation&quot;));</a>
<a name="ln2574">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;sat_gain, TRUE, TRUE, 0);</a>
<a name="ln2575">  g_signal_connect(G_OBJECT(g-&gt;sat_gain), &quot;value-changed&quot;, G_CALLBACK(sat_gain_callback), self);</a>
<a name="ln2576"> </a>
<a name="ln2577">  static const char *gain_red_messages[] = { N_(&quot;factor of red for gain&quot;) };</a>
<a name="ln2578">  (void)gain_red_messages;</a>
<a name="ln2579">  ADD_CHANNEL(gain, r, red, RED)</a>
<a name="ln2580">  dt_bauhaus_slider_set_stop(g-&gt;gain_r, 0.0, 0.0, 1.0, 1.0);</a>
<a name="ln2581">  dt_bauhaus_slider_set_stop(g-&gt;gain_r, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2582">  dt_bauhaus_slider_set_stop(g-&gt;gain_r, 1.0, 1.0, 0.0, 0.0);</a>
<a name="ln2583"> </a>
<a name="ln2584">  static const char *gain_green_messages[] = { N_(&quot;factor of green for gain&quot;) };</a>
<a name="ln2585">  (void)gain_green_messages;</a>
<a name="ln2586">  ADD_CHANNEL(gain, g, green, GREEN)</a>
<a name="ln2587">  dt_bauhaus_slider_set_stop(g-&gt;gain_g, 0.0, 1.0, 0.0, 1.0);</a>
<a name="ln2588">  dt_bauhaus_slider_set_stop(g-&gt;gain_g, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2589">  dt_bauhaus_slider_set_stop(g-&gt;gain_g, 1.0, 0.0, 1.0, 0.0);</a>
<a name="ln2590"> </a>
<a name="ln2591">  static const char *gain_blue_messages[] = { N_(&quot;factor of blue for gain&quot;) };</a>
<a name="ln2592">  (void)gain_blue_messages;</a>
<a name="ln2593">  ADD_CHANNEL(gain, b, blue, BLUE)</a>
<a name="ln2594">  dt_bauhaus_slider_set_stop(g-&gt;gain_b, 0.0, 1.0, 1.0, 0.0);</a>
<a name="ln2595">  dt_bauhaus_slider_set_stop(g-&gt;gain_b, 0.5, 1.0, 1.0, 1.0);</a>
<a name="ln2596">  dt_bauhaus_slider_set_stop(g-&gt;gain_b, 1.0, 0.0, 0.0, 1.0);</a>
<a name="ln2597"> </a>
<a name="ln2598">  g-&gt;optim_label =  dt_ui_section_label_new(_(&quot;auto optimizers&quot;));</a>
<a name="ln2599">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;optim_label, FALSE, FALSE, 5);</a>
<a name="ln2600"> </a>
<a name="ln2601">  GtkBox *box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5));</a>
<a name="ln2602">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(box), TRUE, TRUE, 0);</a>
<a name="ln2603"> </a>
<a name="ln2604">  g-&gt;auto_luma = dt_bauhaus_combobox_new(self);</a>
<a name="ln2605">  dt_bauhaus_widget_set_label(g-&gt;auto_luma, NULL, _(&quot;optimize luma&quot;));</a>
<a name="ln2606">  dt_bauhaus_widget_set_quad_paint(g-&gt;auto_luma, dtgtk_cairo_paint_colorpicker,</a>
<a name="ln2607">                                   CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2608">  dt_bauhaus_widget_set_quad_toggle(g-&gt;auto_luma, TRUE);</a>
<a name="ln2609">  g_signal_connect(G_OBJECT(g-&gt;auto_luma), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2610">  gtk_widget_set_tooltip_text(g-&gt;auto_luma, _(&quot;fit the whole histogram and center the average luma&quot;));</a>
<a name="ln2611">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;auto_luma, TRUE, TRUE, 0);</a>
<a name="ln2612"> </a>
<a name="ln2613">  g-&gt;auto_color = dt_bauhaus_combobox_new(self);</a>
<a name="ln2614">  dt_bauhaus_widget_set_label(g-&gt;auto_color, NULL, _(&quot;neutralize colors&quot;));</a>
<a name="ln2615">  dt_bauhaus_widget_set_quad_paint(g-&gt;auto_color, dtgtk_cairo_paint_colorpicker,</a>
<a name="ln2616">                                   CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2617">  dt_bauhaus_widget_set_quad_toggle(g-&gt;auto_color, TRUE);</a>
<a name="ln2618">  g_signal_connect(G_OBJECT(g-&gt;auto_color), &quot;quad-pressed&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln2619">  gtk_widget_set_tooltip_text(g-&gt;auto_color, _(&quot;optimize the RGB curves to remove color casts&quot;));</a>
<a name="ln2620">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;auto_color, TRUE, TRUE, 0);</a>
<a name="ln2621"> </a>
<a name="ln2622">  // default control is HSL</a>
<a name="ln2623">  gtk_widget_set_visible(g-&gt;lift_r, FALSE);</a>
<a name="ln2624">  gtk_widget_set_visible(g-&gt;lift_g, FALSE);</a>
<a name="ln2625">  gtk_widget_set_visible(g-&gt;lift_b, FALSE);</a>
<a name="ln2626">  gtk_widget_set_visible(g-&gt;gamma_r, FALSE);</a>
<a name="ln2627">  gtk_widget_set_visible(g-&gt;gamma_g, FALSE);</a>
<a name="ln2628">  gtk_widget_set_visible(g-&gt;gamma_b, FALSE);</a>
<a name="ln2629">  gtk_widget_set_visible(g-&gt;gain_r, FALSE);</a>
<a name="ln2630">  gtk_widget_set_visible(g-&gt;gain_g, FALSE);</a>
<a name="ln2631">  gtk_widget_set_visible(g-&gt;gain_b, FALSE);</a>
<a name="ln2632"> </a>
<a name="ln2633">  gtk_widget_set_visible(g-&gt;hue_lift, TRUE);</a>
<a name="ln2634">  gtk_widget_set_visible(g-&gt;sat_lift, TRUE);</a>
<a name="ln2635">  gtk_widget_set_visible(g-&gt;hue_gamma, TRUE);</a>
<a name="ln2636">  gtk_widget_set_visible(g-&gt;sat_gamma, TRUE);</a>
<a name="ln2637">  gtk_widget_set_visible(g-&gt;hue_gain, TRUE);</a>
<a name="ln2638">  gtk_widget_set_visible(g-&gt;sat_gain, TRUE);</a>
<a name="ln2639"> </a>
<a name="ln2640">#undef ADD_FACTOR</a>
<a name="ln2641">#undef ADD_CHANNEL</a>
<a name="ln2642"> </a>
<a name="ln2643">  dt_iop_init_picker(&amp;g-&gt;color_picker,</a>
<a name="ln2644">              self,</a>
<a name="ln2645">              DT_COLOR_PICKER_AREA,</a>
<a name="ln2646">              _iop_color_picker_get_set,</a>
<a name="ln2647">              _iop_color_picker_apply,</a>
<a name="ln2648">              _iop_color_picker_update);</a>
<a name="ln2649"> </a>
<a name="ln2650">}</a>
<a name="ln2651"> </a>
<a name="ln2652">void gui_cleanup(dt_iop_module_t *self)</a>
<a name="ln2653">{</a>
<a name="ln2654">  // nothing else necessary, gtk will clean up the slider.</a>
<a name="ln2655">  free(self-&gt;gui_data);</a>
<a name="ln2656">  self-&gt;gui_data = NULL;</a>
<a name="ln2657">}</a>
<a name="ln2658"> </a>
<a name="ln2659">/** additional, optional callbacks to capture darkroom center events. */</a>
<a name="ln2660">// int mouse_moved(dt_iop_module_t *self, double x, double y, double pressure, int which);</a>
<a name="ln2661">// int button_pressed(dt_iop_module_t *self, double x, double y, double pressure, int which, int type,</a>
<a name="ln2662">// uint32_t state);</a>
<a name="ln2663">// int button_released(struct dt_iop_module_t *self, double x, double y, int which, uint32_t state);</a>
<a name="ln2664">// int scrolled(dt_iop_module_t *self, double x, double y, int up, uint32_t state);</a>
<a name="ln2665"> </a>
<a name="ln2666">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2667">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2668">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="232"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'n->contrast' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 230, 232.</p></div>
<div class="balloon" rel="1448"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1448, 1434.</p></div>
<div class="balloon" rel="1449"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1449, 1435.</p></div>
<div class="balloon" rel="1464"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 1464, 1462.</p></div>
<div class="balloon" rel="2306"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 2306, 2302.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
