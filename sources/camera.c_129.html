
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010 - 2014 henrik andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln19">#include &quot;common/camera_control.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;control/conf.h&quot;</a>
<a name="ln22">#include &quot;control/control.h&quot;</a>
<a name="ln23">#include &quot;control/jobs.h&quot;</a>
<a name="ln24">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln25">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln26">#include &quot;gui/gtk.h&quot;</a>
<a name="ln27">#include &quot;libs/lib.h&quot;</a>
<a name="ln28">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln29">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">DT_MODULE(1)</a>
<a name="ln32"> </a>
<a name="ln33">typedef struct dt_lib_camera_property_t</a>
<a name="ln34">{</a>
<a name="ln35">  /** the visual property name */</a>
<a name="ln36">  gchar *name;</a>
<a name="ln37">  /** the property name */</a>
<a name="ln38">  gchar *property_name;</a>
<a name="ln39">  /**Combobox of values available for the property*/</a>
<a name="ln40">  GtkWidget *values;</a>
<a name="ln41">  /** Show property OSD */</a>
<a name="ln42">  GtkDarktableToggleButton *osd;</a>
<a name="ln43">} dt_lib_camera_property_t;</a>
<a name="ln44"> </a>
<a name="ln45">typedef struct dt_lib_camera_t</a>
<a name="ln46">{</a>
<a name="ln47">  /** Gui part of the module */</a>
<a name="ln48">  struct</a>
<a name="ln49">  {</a>
<a name="ln50">    GtkGrid *main_grid;</a>
<a name="ln51">    GtkDarktableToggleButton *toggle_timer, *toggle_sequence, *toggle_bracket;</a>
<a name="ln52">    GtkWidget *timer, *count, *brackets, *steps;</a>
<a name="ln53">    GtkWidget *button1;</a>
<a name="ln54"> </a>
<a name="ln55">    int rows; // the number of row in the grid</a>
<a name="ln56">    int prop_start; // the row of the grid above the first property</a>
<a name="ln57">    int prop_end; // the row of the grid where to insert new properties</a>
<a name="ln58"> </a>
<a name="ln59">    GtkWidget *plabel, *pname; // propertylabel,widget</a>
<a name="ln60">    GList *properties;         // a list of dt_lib_camera_property_t</a>
<a name="ln61"> </a>
<a name="ln62">    GtkMenu *properties_menu; // available properties</a>
<a name="ln63"> </a>
<a name="ln64">  } gui;</a>
<a name="ln65"> </a>
<a name="ln66">  /** Data part of the module */</a>
<a name="ln67">  struct</a>
<a name="ln68">  {</a>
<a name="ln69">    const gchar *camera_model;</a>
<a name="ln70">    dt_camctl_listener_t *listener;</a>
<a name="ln71">  } data;</a>
<a name="ln72">} dt_lib_camera_t;</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">const char *name(dt_lib_module_t *self)</a>
<a name="ln77">{</a>
<a name="ln78">  return _(&quot;camera settings&quot;);</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">const char **views(dt_lib_module_t *self)</a>
<a name="ln82">{</a>
<a name="ln83">  static const char *v[] = {&quot;tethering&quot;, NULL};</a>
<a name="ln84">  return v;</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln88">{</a>
<a name="ln89">  return DT_UI_CONTAINER_PANEL_RIGHT_CENTER;</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">void gui_reset(dt_lib_module_t *self)</a>
<a name="ln94">{</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">int position()</a>
<a name="ln98">{</a>
<a name="ln99">  return 997;</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln103">{</a>
<a name="ln104">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;capture image(s)&quot;), 0, 0);</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln108">{</a>
<a name="ln109">  dt_lib_camera_t *lib = (dt_lib_camera_t *)self-&gt;data;</a>
<a name="ln110"> </a>
<a name="ln111">  dt_accel_connect_button_lib(self, &quot;capture image(s)&quot;, GTK_WIDGET(lib-&gt;gui.button1));</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">/** Property changed*/</a>
<a name="ln115">static void property_changed_callback(GtkComboBox *cb, gpointer data)</a>
<a name="ln116">{</a>
<a name="ln117">  dt_lib_camera_property_t *prop = (dt_lib_camera_property_t *)data;</a>
<a name="ln118">  dt_camctl_camera_set_property_string(darktable.camctl, NULL, prop-&gt;property_name,</a>
<a name="ln119">                                       dt_bauhaus_combobox_get_text(prop-&gt;values));</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">/** Add  a new property of camera to the gui */</a>
<a name="ln123">static dt_lib_camera_property_t *_lib_property_add_new(dt_lib_camera_t *lib, const gchar *label,</a>
<a name="ln124">                                                       const gchar *propertyname)</a>
<a name="ln125">{</a>
<a name="ln126">  if(dt_camctl_camera_property_exists(darktable.camctl, NULL, propertyname))</a>
<a name="ln127">  {</a>
<a name="ln128">    const char *value;</a>
<a name="ln129">    if((value = dt_camctl_camera_property_get_first_choice(darktable.camctl, NULL, propertyname)) != NULL)</a>
<a name="ln130">    {</a>
<a name="ln131">      // We got a value for property lets construct the gui for the property and add values</a>
<a name="ln132">      int i = 0;</a>
<a name="ln133">      const char *current_value = dt_camctl_camera_get_property(darktable.camctl, NULL, propertyname);</a>
<a name="ln134">      dt_lib_camera_property_t *prop = calloc(1, sizeof(dt_lib_camera_property_t));</a>
<a name="ln135">      prop-&gt;name = strdup(label);</a>
<a name="ln136">      prop-&gt;property_name = strdup(propertyname);</a>
<a name="ln137">      prop-&gt;values = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln138">      dt_bauhaus_widget_set_label(prop-&gt;values, NULL, label);</a>
<a name="ln139">      g_object_ref_sink(prop-&gt;values);</a>
<a name="ln140"> </a>
<a name="ln141">      prop-&gt;osd = DTGTK_TOGGLEBUTTON(dtgtk_togglebutton_new(dtgtk_cairo_paint_eye, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln142">      g_object_ref_sink(prop-&gt;osd);</a>
<a name="ln143">      gtk_widget_set_tooltip_text(GTK_WIDGET(prop-&gt;osd), _(&quot;toggle view property in center view&quot;));</a>
<a name="ln144">      do</a>
<a name="ln145">      {</a>
<a name="ln146">        dt_bauhaus_combobox_add(prop-&gt;values, g_dgettext(&quot;libgphoto2-2&quot;, value));</a>
<a name="ln147">        if(!strcmp(current_value, g_dgettext(&quot;libgphoto2-2&quot;, value)))</a>
<a name="ln148">          dt_bauhaus_combobox_set(prop-&gt;values, i);</a>
<a name="ln149">        i++;</a>
<a name="ln150">      } while((value = dt_camctl_camera_property_get_next_choice(darktable.camctl, NULL, propertyname))</a>
<a name="ln151">              != NULL);</a>
<a name="ln152">      lib-&gt;gui.properties = g_list_append(lib-&gt;gui.properties, prop);</a>
<a name="ln153">      // Does dead lock!!!</a>
<a name="ln154">      g_signal_connect(G_OBJECT(prop-&gt;values), &quot;value-changed&quot;, G_CALLBACK(property_changed_callback),</a>
<a name="ln155">                       (gpointer)prop);</a>
<a name="ln156">      return prop;</a>
<a name="ln157">    }</a>
<a name="ln158">  }</a>
<a name="ln159">  return NULL;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">static void _lib_property_free(gpointer data)</a>
<a name="ln163">{</a>
<a name="ln164">  dt_lib_camera_property_t * prop = (dt_lib_camera_property_t *)data;</a>
<a name="ln165">  g_object_unref(prop-&gt;osd);</a>
<a name="ln166">  g_object_unref(prop-&gt;values);</a>
<a name="ln167">  free(prop-&gt;name);</a>
<a name="ln168">  free(prop-&gt;property_name);</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">static gint _compare_property_by_name(gconstpointer a, gconstpointer b)</a>
<a name="ln172">{</a>
<a name="ln173">  dt_lib_camera_property_t *ca = (dt_lib_camera_property_t *)a;</a>
<a name="ln174">  return strcmp(ca-&gt;property_name, (char *)b);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">/** Invoked when a value of a property is changed. */</a>
<a name="ln178">static void _camera_property_value_changed(const dt_camera_t *camera, const char *name, const char *value,</a>
<a name="ln179">                                           void *data)</a>
<a name="ln180">{</a>
<a name="ln181">  dt_lib_camera_t *lib = (dt_lib_camera_t *)data;</a>
<a name="ln182">  // Find the property in lib-&gt;data.properties, update value</a>
<a name="ln183">  GList *citem;</a>
<a name="ln184">  if((citem = g_list_find_custom(lib-&gt;gui.properties, name, _compare_property_by_name)) != NULL)</a>
<a name="ln185">  {</a>
<a name="ln186">    dt_lib_camera_property_t *prop = (dt_lib_camera_property_t *)citem-&gt;data;</a>
<a name="ln187">    dt_bauhaus_combobox_set_from_text(prop-&gt;values, value);</a>
<a name="ln188">  }</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">/** Invoked when accesibility of a property is changed. */</a>
<a name="ln192">static void _camera_property_accessibility_changed(const dt_camera_t *camera, const char *name,</a>
<a name="ln193">                                                   gboolean read_only, void *data)</a>
<a name="ln194">{</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">static gboolean _bailout_of_tethering(gpointer user_data)</a>
<a name="ln198">{</a>
<a name="ln199">  /* consider all error types as failure and bailout of tethering mode */</a>
<a name="ln200">  dt_lib_camera_t *lib = (dt_lib_camera_t *)user_data;</a>
<a name="ln201">  dt_camctl_tether_mode(darktable.camctl, NULL, FALSE);</a>
<a name="ln202">  dt_camctl_unregister_listener(darktable.camctl, lib-&gt;data.listener);</a>
<a name="ln203"> </a>
<a name="ln204">  /* switch back to library mode */</a>
<a name="ln205">  dt_ctl_switch_mode_to(&quot;lighttable&quot;);</a>
<a name="ln206"> </a>
<a name="ln207">  return FALSE;</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">/** Invoked when camera error appear */</a>
<a name="ln211">static void _camera_error_callback(const dt_camera_t *camera, dt_camera_error_t error, void *user_data)</a>
<a name="ln212">{</a>
<a name="ln213">  dt_control_log(_(&quot;connection with camera lost, exiting tethering mode&quot;));</a>
<a name="ln214">  g_idle_add(_bailout_of_tethering, user_data);</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">static void _capture_button_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln218">{</a>
<a name="ln219">  const char *jobcode = NULL;</a>
<a name="ln220">  dt_lib_camera_t *lib = (dt_lib_camera_t *)user_data;</a>
<a name="ln221">  uint32_t delay = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(lib-&gt;gui.toggle_timer)) == TRUE</a>
<a name="ln222">                       ? (uint32_t)gtk_spin_button_get_value(GTK_SPIN_BUTTON(lib-&gt;gui.timer))</a>
<a name="ln223">                       : 0;</a>
<a name="ln224">  uint32_t count = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(lib-&gt;gui.toggle_sequence)) == TRUE</a>
<a name="ln225">                       ? (uint32_t)gtk_spin_button_get_value(GTK_SPIN_BUTTON(lib-&gt;gui.count))</a>
<a name="ln226">                       : 1;</a>
<a name="ln227">  uint32_t brackets = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(lib-&gt;gui.toggle_bracket)) == TRUE</a>
<a name="ln228">                          ? (uint32_t)gtk_spin_button_get_value(GTK_SPIN_BUTTON(lib-&gt;gui.brackets))</a>
<a name="ln229">                          : 0;</a>
<a name="ln230">  uint32_t steps = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(lib-&gt;gui.toggle_bracket)) == TRUE</a>
<a name="ln231">                       ? (uint32_t)gtk_spin_button_get_value(GTK_SPIN_BUTTON(lib-&gt;gui.steps))</a>
<a name="ln232">                       : 0;</a>
<a name="ln233"> </a>
<a name="ln234">  /* create a capture background job */</a>
<a name="ln235">  jobcode = dt_view_tethering_get_job_code(darktable.view_manager);</a>
<a name="ln236">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln237">                     dt_camera_capture_job_create(jobcode, delay, count, brackets, steps));</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240"> </a>
<a name="ln241">static void _osd_button_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln242">{</a>
<a name="ln243">  dt_control_queue_redraw_center();</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">static void _property_choice_callback(GtkMenuItem *item, gpointer user_data)</a>
<a name="ln247">{</a>
<a name="ln248">  dt_lib_camera_t *lib = (dt_lib_camera_t *)user_data;</a>
<a name="ln249">  gtk_entry_set_text(GTK_ENTRY(lib-&gt;gui.pname), gtk_menu_item_get_label(item));</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252"> </a>
<a name="ln253">static void _show_property_popupmenu_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln254">{</a>
<a name="ln255">  dt_lib_camera_t *lib = (dt_lib_camera_t *)user_data;</a>
<a name="ln256"> </a>
<a name="ln257">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln258">  gtk_menu_popup_at_pointer(lib-&gt;gui.properties_menu, NULL);</a>
<a name="ln259">#else</a>
<a name="ln260">  gtk_menu_popup(lib-&gt;gui.properties_menu, NULL, NULL, NULL, NULL, 1, gtk_get_current_event_time());</a>
<a name="ln261">#endif</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264">static void _lib_property_add_to_gui(dt_lib_camera_property_t *prop, dt_lib_camera_t *lib)</a>
<a name="ln265">{</a>
<a name="ln266">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln267">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(prop-&gt;values), TRUE, TRUE, 0);</a>
<a name="ln268">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(prop-&gt;osd), FALSE, FALSE, 0);</a>
<a name="ln269">  gtk_grid_insert_row(lib-&gt;gui.main_grid, lib-&gt;gui.prop_end); // make space for the new row</a>
<a name="ln270">  gtk_grid_attach(lib-&gt;gui.main_grid, GTK_WIDGET(hbox), 0, lib-&gt;gui.prop_end, 2, 1);</a>
<a name="ln271">  g_signal_connect(G_OBJECT(prop-&gt;osd), &quot;clicked&quot;, G_CALLBACK(_osd_button_clicked), prop);</a>
<a name="ln272">  gtk_widget_show_all(GTK_WIDGET(hbox));</a>
<a name="ln273">  lib-&gt;gui.rows++;</a>
<a name="ln274">  lib-&gt;gui.prop_end++;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">static void _add_property_button_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln278">{</a>
<a name="ln279">  dt_lib_camera_t *lib = (dt_lib_camera_t *)user_data;</a>
<a name="ln280">  const gchar *label = gtk_entry_get_text(GTK_ENTRY(lib-&gt;gui.plabel));</a>
<a name="ln281">  const gchar *property = gtk_entry_get_text(GTK_ENTRY(lib-&gt;gui.pname));</a>
<a name="ln282"> </a>
<a name="ln283">  /* let's try to add property */</a>
<a name="ln284">  if(label &amp;&amp; property)</a>
<a name="ln285">  {</a>
<a name="ln286">    dt_lib_camera_property_t *prop = NULL;</a>
<a name="ln287"> </a>
<a name="ln288">    if((prop = _lib_property_add_new(lib, label, property)) != NULL)</a>
<a name="ln289">    {</a>
<a name="ln290">      _lib_property_add_to_gui(prop, lib);</a>
<a name="ln291"> </a>
<a name="ln292">      gchar key[256] = { &quot;plugins/capture/tethering/properties/&quot; };</a>
<a name="ln293">      g_strlcat(key, label, sizeof(key));</a>
<a name="ln294">      gchar *p = key;</a>
<a name="ln295">      const char *end = key + strlen(key);</a>
<a name="ln296">      while(p++ &lt; end)</a>
<a name="ln297">        if(*p == ' ') *p = '_';</a>
<a name="ln298">      dt_conf_set_string(key, property);</a>
<a name="ln299"> </a>
<a name="ln300">      /* clean entries */</a>
<a name="ln301">      gtk_entry_set_text(GTK_ENTRY(lib-&gt;gui.plabel), &quot;&quot;);</a>
<a name="ln302">      gtk_entry_set_text(GTK_ENTRY(lib-&gt;gui.pname), &quot;&quot;);</a>
<a name="ln303">    }</a>
<a name="ln304">  }</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307"> </a>
<a name="ln308">static void _toggle_capture_mode_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln309">{</a>
<a name="ln310">  dt_lib_camera_t *lib = (dt_lib_camera_t *)user_data;</a>
<a name="ln311">  GtkWidget *w = NULL;</a>
<a name="ln312">  if(widget == GTK_WIDGET(lib-&gt;gui.toggle_timer))</a>
<a name="ln313">    w = lib-&gt;gui.timer;</a>
<a name="ln314">  else if(widget == GTK_WIDGET(lib-&gt;gui.toggle_sequence))</a>
<a name="ln315">    w = lib-&gt;gui.count;</a>
<a name="ln316">  else if(widget == GTK_WIDGET(lib-&gt;gui.toggle_bracket))</a>
<a name="ln317">  {</a>
<a name="ln318">    gtk_widget_set_sensitive(lib-&gt;gui.brackets, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)));</a>
<a name="ln319">    gtk_widget_set_sensitive(lib-&gt;gui.steps, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)));</a>
<a name="ln320">  }</a>
<a name="ln321"> </a>
<a name="ln322">  if(w) gtk_widget_set_sensitive(w, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)));</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">#define BAR_HEIGHT DT_PIXEL_APPLY_DPI(18) /* also change in views/tethering.c */</a>
<a name="ln327">static void _expose_info_bar(dt_lib_module_t *self, cairo_t *cr, int32_t width, int32_t height,</a>
<a name="ln328">                             int32_t pointerx, int32_t pointery)</a>
<a name="ln329">{</a>
<a name="ln330">  dt_lib_camera_t *lib = (dt_lib_camera_t *)self-&gt;data;</a>
<a name="ln331"> </a>
<a name="ln332">  // Draw infobar background at top</a>
<a name="ln333">  cairo_set_source_rgb(cr, .0, .0, .0);</a>
<a name="ln334">  cairo_rectangle(cr, 0, 0, width, BAR_HEIGHT);</a>
<a name="ln335">  cairo_fill(cr);</a>
<a name="ln336"> </a>
<a name="ln337">  cairo_set_source_rgb(cr, .8, .8, .8);</a>
<a name="ln338"> </a>
<a name="ln339">  // Draw left aligned value camera model value</a>
<a name="ln340">  PangoLayout *layout;</a>
<a name="ln341">  PangoRectangle ink;</a>
<a name="ln342">  PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln343">  pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln344">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln345">  const int fontsize = DT_PIXEL_APPLY_DPI(11.5);</a>
<a name="ln346">  pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);</a>
<a name="ln347">  pango_layout_set_font_description(layout, desc);</a>
<a name="ln348">  char model[4096] = { 0 };</a>
<a name="ln349">  snprintf(model, strlen(model), &quot;%s&quot;, lib-&gt;data.camera_model);</a>
<a name="ln350">  pango_layout_set_text(layout, model, -1);</a>
<a name="ln351">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln352">  cairo_move_to(cr, DT_PIXEL_APPLY_DPI(5), DT_PIXEL_APPLY_DPI(1) + BAR_HEIGHT - ink.height / 2 - fontsize);</a>
<a name="ln353">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln354"> </a>
<a name="ln355">  // Draw right aligned battery value</a>
<a name="ln356">  const char *battery_value = dt_camctl_camera_get_property(darktable.camctl, NULL, &quot;batterylevel&quot;);</a>
<a name="ln357">  char battery[4096] = { 0 };</a>
<a name="ln358">  snprintf(battery, sizeof(battery), &quot;%s: %s&quot;, _(&quot;battery&quot;), battery_value ? battery_value : _(&quot;n/a&quot;));</a>
<a name="ln359">  pango_layout_set_text(layout, battery, -1);</a>
<a name="ln360">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln361">  cairo_move_to(cr, width - ink.width - DT_PIXEL_APPLY_DPI(5), DT_PIXEL_APPLY_DPI(1) + BAR_HEIGHT - ink.height / 2 - fontsize);</a>
<a name="ln362">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln363"> </a>
<a name="ln364">  // Let's cook up the middle part of infobar</a>
<a name="ln365">  gchar center[1024] = { 0 };</a>
<a name="ln366">  for(guint i = 0; i &lt; g_list_length(lib-&gt;gui.properties); i++)</a>
<a name="ln367">  {</a>
<a name="ln368">    dt_lib_camera_property_t *prop = (dt_lib_camera_property_t *)g_list_nth_data(lib-&gt;gui.properties, i);</a>
<a name="ln369">    if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(prop-&gt;osd)) == TRUE)</a>
<a name="ln370">    {</a>
<a name="ln371">      g_strlcat(center, &quot;      &quot;, sizeof(center));</a>
<a name="ln372">      g_strlcat(center, prop-&gt;name, sizeof(center));</a>
<a name="ln373">      g_strlcat(center, &quot;: &quot;, sizeof(center));</a>
<a name="ln374">      g_strlcat(center, dt_bauhaus_combobox_get_text(prop-&gt;values), sizeof(center));</a>
<a name="ln375">    }</a>
<a name="ln376">  }</a>
<a name="ln377">  g_strlcat(center, &quot;      &quot;, sizeof(center));</a>
<a name="ln378"> </a>
<a name="ln379">  // Now lets put it in center view...</a>
<a name="ln380">  pango_layout_set_text(layout, center, -1);</a>
<a name="ln381">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln382">  cairo_move_to(cr, (width / 2) - (ink.width / 2), DT_PIXEL_APPLY_DPI(1) + BAR_HEIGHT - ink.height / 2 - fontsize);</a>
<a name="ln383">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln384">  pango_font_description_free(desc);</a>
<a name="ln385">  g_object_unref(layout);</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388">static void _expose_settings_bar(dt_lib_module_t *self, cairo_t *cr, int32_t width, int32_t height,</a>
<a name="ln389">                                 int32_t pointerx, int32_t pointery)</a>
<a name="ln390">{</a>
<a name="ln391">  /*// Draw control bar at bottom</a>
<a name="ln392">  cairo_set_source_rgb (cr, .0,.0,.0);</a>
<a name="ln393">  cairo_rectangle(cr, 0, height-BAR_HEIGHT, width, BAR_HEIGHT);</a>
<a name="ln394">  cairo_fill (cr);*/</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">void gui_post_expose(dt_lib_module_t *self, cairo_t *cr, int32_t width, int32_t height, int32_t pointerx,</a>
<a name="ln398">                     int32_t pointery)</a>
<a name="ln399">{</a>
<a name="ln400">  // Setup cairo font..</a>
<a name="ln401">  cairo_set_font_size(cr, 11.5);</a>
<a name="ln402">  //cairo_select_font_face(cr, &quot;Sans&quot;, CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);</a>
<a name="ln403"> </a>
<a name="ln404">  _expose_info_bar(self, cr, width, height, pointerx, pointery);</a>
<a name="ln405">  _expose_settings_bar(self, cr, width, height, pointerx, pointery);</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">void gui_init(dt_lib_module_t *self)</a>
<a name="ln409">{</a>
<a name="ln410">  self-&gt;data = calloc(1, sizeof(dt_lib_camera_t));</a>
<a name="ln411"> </a>
<a name="ln412">  // Setup lib data</a>
<a name="ln413">  dt_lib_camera_t *lib = self-&gt;data;</a>
<a name="ln414">  lib-&gt;data.listener = calloc(1, sizeof(dt_camctl_listener_t));</a>
<a name="ln415">  lib-&gt;data.listener-&gt;data = lib;</a>
<a name="ln416">  lib-&gt;data.listener-&gt;camera_error = _camera_error_callback;</a>
<a name="ln417">  lib-&gt;data.listener-&gt;camera_property_value_changed = _camera_property_value_changed;</a>
<a name="ln418">  lib-&gt;data.listener-&gt;camera_property_accessibility_changed = _camera_property_accessibility_changed;</a>
<a name="ln419"> </a>
<a name="ln420">  // Setup gui</a>
<a name="ln421">  lib-&gt;gui.rows = 0;</a>
<a name="ln422">  lib-&gt;gui.prop_end = 0;</a>
<a name="ln423">  self-&gt;widget = gtk_grid_new();</a>
<a name="ln424">  gtk_grid_set_column_spacing(GTK_GRID(self-&gt;widget), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln425">  lib-&gt;gui.main_grid = GTK_GRID(self-&gt;widget);</a>
<a name="ln426">  gtk_grid_set_row_spacing(GTK_GRID(self-&gt;widget), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln427"> </a>
<a name="ln428">  GtkBox *hbox;</a>
<a name="ln429"> </a>
<a name="ln430">  // Camera control</a>
<a name="ln431">  GtkWidget *label = dt_ui_section_label_new(_(&quot;camera control&quot;));</a>
<a name="ln432">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, lib-&gt;gui.rows++, 0, 2, 1);</a>
<a name="ln433">  dt_gui_add_help_link(self-&gt;widget, &quot;camera_settings.html#camera_settings&quot;);</a>
<a name="ln434"> </a>
<a name="ln435">  GtkWidget *modes_label = gtk_label_new(_(&quot;modes&quot;));</a>
<a name="ln436">  GtkWidget *timer_label = gtk_label_new(_(&quot;timer (s)&quot;));</a>
<a name="ln437">  GtkWidget *count_label = gtk_label_new(_(&quot;count&quot;));</a>
<a name="ln438">  GtkWidget *brackets_label = gtk_label_new(_(&quot;brackets&quot;));</a>
<a name="ln439">  GtkWidget *steps_label = gtk_label_new(_(&quot;bkt. steps&quot;));</a>
<a name="ln440">  gtk_widget_set_halign(GTK_WIDGET(modes_label), GTK_ALIGN_START);</a>
<a name="ln441">  gtk_widget_set_halign(GTK_WIDGET(timer_label), GTK_ALIGN_START);</a>
<a name="ln442">  gtk_widget_set_halign(GTK_WIDGET(count_label), GTK_ALIGN_START);</a>
<a name="ln443">  gtk_widget_set_halign(GTK_WIDGET(brackets_label), GTK_ALIGN_START);</a>
<a name="ln444">  gtk_widget_set_halign(GTK_WIDGET(steps_label), GTK_ALIGN_START);</a>
<a name="ln445"> </a>
<a name="ln446">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(modes_label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln447">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(timer_label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln448">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(count_label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln449">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(brackets_label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln450">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(steps_label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln451"> </a>
<a name="ln452">  // capture modes buttons</a>
<a name="ln453">  lib-&gt;gui.toggle_timer = DTGTK_TOGGLEBUTTON(</a>
<a name="ln454">      dtgtk_togglebutton_new(dtgtk_cairo_paint_timer, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln455">  lib-&gt;gui.toggle_sequence = DTGTK_TOGGLEBUTTON(</a>
<a name="ln456">      dtgtk_togglebutton_new(dtgtk_cairo_paint_filmstrip, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln457">  lib-&gt;gui.toggle_bracket = DTGTK_TOGGLEBUTTON(</a>
<a name="ln458">      dtgtk_togglebutton_new(dtgtk_cairo_paint_bracket, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln459"> </a>
<a name="ln460">  hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln461">  gtk_box_pack_start(hbox, GTK_WIDGET(lib-&gt;gui.toggle_timer), TRUE, TRUE, 0);</a>
<a name="ln462">  gtk_box_pack_start(hbox, GTK_WIDGET(lib-&gt;gui.toggle_sequence), TRUE, TRUE, 0);</a>
<a name="ln463">  gtk_box_pack_start(hbox, GTK_WIDGET(lib-&gt;gui.toggle_bracket), TRUE, TRUE, 0);</a>
<a name="ln464">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(hbox), GTK_WIDGET(modes_label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln465"> </a>
<a name="ln466">  lib-&gt;gui.timer = gtk_spin_button_new_with_range(1, 60, 1);</a>
<a name="ln467">  lib-&gt;gui.count = gtk_spin_button_new_with_range(1, 500, 1);</a>
<a name="ln468">  lib-&gt;gui.brackets = gtk_spin_button_new_with_range(1, 5, 1);</a>
<a name="ln469">  lib-&gt;gui.steps = gtk_spin_button_new_with_range(1, 9, 1);</a>
<a name="ln470">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(lib-&gt;gui.timer), GTK_WIDGET(timer_label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln471">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(lib-&gt;gui.count), GTK_WIDGET(count_label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln472">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(lib-&gt;gui.brackets), GTK_WIDGET(brackets_label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln473">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(lib-&gt;gui.steps), GTK_WIDGET(steps_label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln474"> </a>
<a name="ln475">  lib-&gt;gui.button1 = gtk_button_new_with_label(_(&quot;capture image(s)&quot;));</a>
<a name="ln476">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(lib-&gt;gui.button1), 0, lib-&gt;gui.rows++, 2, 1);</a>
<a name="ln477"> </a>
<a name="ln478">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.toggle_timer), _(&quot;toggle delayed capture mode&quot;));</a>
<a name="ln479">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.toggle_sequence), _(&quot;toggle sequenced capture mode&quot;));</a>
<a name="ln480">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.toggle_bracket), _(&quot;toggle bracketed capture mode&quot;));</a>
<a name="ln481">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.timer), _(&quot;the count of seconds before actually doing a capture&quot;));</a>
<a name="ln482">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.count),</a>
<a name="ln483">               _(&quot;the amount of images to capture in a sequence,\nyou can use this in conjunction with &quot;</a>
<a name="ln484">                 &quot;delayed mode to create stop-motion sequences.&quot;));</a>
<a name="ln485">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.brackets),</a>
<a name="ln486">               _(&quot;the amount of brackets on each side of centered shoot, amount of images = (brackets*2)+1.&quot;));</a>
<a name="ln487">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.steps),</a>
<a name="ln488">               _(&quot;the amount of steps per bracket, steps is camera configurable and usually 3 steps per &quot;</a>
<a name="ln489">                 &quot;stop\nwith other words, 3 steps is 1EV exposure step between brackets.&quot;));</a>
<a name="ln490"> </a>
<a name="ln491">  g_signal_connect(G_OBJECT(lib-&gt;gui.toggle_timer), &quot;clicked&quot;, G_CALLBACK(_toggle_capture_mode_clicked), lib);</a>
<a name="ln492">  g_signal_connect(G_OBJECT(lib-&gt;gui.toggle_sequence), &quot;clicked&quot;, G_CALLBACK(_toggle_capture_mode_clicked), lib);</a>
<a name="ln493">  g_signal_connect(G_OBJECT(lib-&gt;gui.toggle_bracket), &quot;clicked&quot;, G_CALLBACK(_toggle_capture_mode_clicked), lib);</a>
<a name="ln494">  g_signal_connect(G_OBJECT(lib-&gt;gui.button1), &quot;clicked&quot;, G_CALLBACK(_capture_button_clicked), lib);</a>
<a name="ln495"> </a>
<a name="ln496">  gtk_widget_set_sensitive(GTK_WIDGET(lib-&gt;gui.timer), FALSE);</a>
<a name="ln497">  gtk_widget_set_sensitive(GTK_WIDGET(lib-&gt;gui.count), FALSE);</a>
<a name="ln498">  gtk_widget_set_sensitive(GTK_WIDGET(lib-&gt;gui.brackets), FALSE);</a>
<a name="ln499">  gtk_widget_set_sensitive(GTK_WIDGET(lib-&gt;gui.steps), FALSE);</a>
<a name="ln500"> </a>
<a name="ln501">  dt_gui_key_accel_block_on_focus_connect(lib-&gt;gui.timer);</a>
<a name="ln502">  dt_gui_key_accel_block_on_focus_connect(lib-&gt;gui.count);</a>
<a name="ln503">  dt_gui_key_accel_block_on_focus_connect(lib-&gt;gui.brackets);</a>
<a name="ln504">  dt_gui_key_accel_block_on_focus_connect(lib-&gt;gui.steps);</a>
<a name="ln505"> </a>
<a name="ln506"> </a>
<a name="ln507">  // Camera settings</a>
<a name="ln508">  label = dt_ui_section_label_new(_(&quot;properties&quot;));</a>
<a name="ln509">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(label), 0, lib-&gt;gui.rows++, 2, 1);</a>
<a name="ln510">  dt_gui_add_help_link(self-&gt;widget, &quot;camera_settings.html#camera_settings&quot;);</a>
<a name="ln511"> </a>
<a name="ln512">  lib-&gt;gui.prop_start = lib-&gt;gui.rows -1;</a>
<a name="ln513">  lib-&gt;gui.prop_end = lib-&gt;gui.rows;</a>
<a name="ln514"> </a>
<a name="ln515"> </a>
<a name="ln516">  // user specified properties</a>
<a name="ln517">  label = dt_ui_section_label_new(_(&quot;additional properties&quot;));</a>
<a name="ln518">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(label), 0, lib-&gt;gui.rows++, 2, 1);</a>
<a name="ln519">  dt_gui_add_help_link(self-&gt;widget, &quot;camera_settings.html#camera_settings&quot;);</a>
<a name="ln520"> </a>
<a name="ln521">  label = gtk_label_new(_(&quot;label&quot;));</a>
<a name="ln522">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln523">  lib-&gt;gui.plabel = gtk_entry_new();</a>
<a name="ln524">  gtk_entry_set_width_chars(GTK_ENTRY(lib-&gt;gui.plabel), 0);</a>
<a name="ln525">  dt_gui_key_accel_block_on_focus_connect(lib-&gt;gui.plabel);</a>
<a name="ln526">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln527">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(lib-&gt;gui.plabel), GTK_WIDGET(label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln528"> </a>
<a name="ln529">  hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln530">  label = gtk_label_new(_(&quot;property&quot;));</a>
<a name="ln531">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln532">  GtkWidget *widget = gtk_button_new_with_label(&quot;O&quot;);</a>
<a name="ln533">  g_signal_connect(G_OBJECT(widget), &quot;clicked&quot;, G_CALLBACK(_show_property_popupmenu_clicked), lib);</a>
<a name="ln534">  lib-&gt;gui.pname = gtk_entry_new();</a>
<a name="ln535">  gtk_entry_set_width_chars(GTK_ENTRY(lib-&gt;gui.pname), 0);</a>
<a name="ln536">  dt_gui_key_accel_block_on_focus_connect(lib-&gt;gui.pname);</a>
<a name="ln537">  gtk_box_pack_start(hbox, GTK_WIDGET(lib-&gt;gui.pname), TRUE, TRUE, 0);</a>
<a name="ln538">  gtk_box_pack_start(hbox, GTK_WIDGET(widget), FALSE, FALSE, 0);</a>
<a name="ln539">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln540">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(hbox), GTK_WIDGET(label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln541"> </a>
<a name="ln542"> </a>
<a name="ln543">  widget = gtk_button_new_with_label(_(&quot;add user property&quot;));</a>
<a name="ln544">  g_signal_connect(G_OBJECT(widget), &quot;clicked&quot;, G_CALLBACK(_add_property_button_clicked), lib);</a>
<a name="ln545">  gtk_widget_show(widget);</a>
<a name="ln546">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(widget), 0, lib-&gt;gui.rows++, 2, 1);</a>
<a name="ln547"> </a>
<a name="ln548"> </a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln552">{</a>
<a name="ln553">  dt_lib_camera_t *lib = self-&gt;data;</a>
<a name="ln554">  dt_gui_key_accel_block_on_focus_disconnect(lib-&gt;gui.plabel);</a>
<a name="ln555">  dt_gui_key_accel_block_on_focus_disconnect(lib-&gt;gui.pname);</a>
<a name="ln556">  free(lib-&gt;data.listener);</a>
<a name="ln557">  lib-&gt;data.listener = NULL;</a>
<a name="ln558">  free(self-&gt;data);</a>
<a name="ln559">  self-&gt;data = NULL;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">void view_enter(struct dt_lib_module_t *self,struct dt_view_t *old_view,struct dt_view_t *new_view)</a>
<a name="ln563">{</a>
<a name="ln564">  dt_lib_camera_t *lib = self-&gt;data;</a>
<a name="ln565">  /* add all camera properties to the widget */</a>
<a name="ln566">  dt_lib_camera_property_t *prop;</a>
<a name="ln567">  if((prop = _lib_property_add_new(lib, _(&quot;program&quot;), &quot;expprogram&quot;)) != NULL)</a>
<a name="ln568">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln569"> </a>
<a name="ln570">  if((prop = _lib_property_add_new(lib, _(&quot;focus mode&quot;), &quot;focusmode&quot;)) != NULL)</a>
<a name="ln571">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln572">  else if((prop = _lib_property_add_new(lib, _(&quot;focus mode&quot;), &quot;drivemode&quot;)) != NULL)</a>
<a name="ln573">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln574"> </a>
<a name="ln575">  if((prop = _lib_property_add_new(lib, _(&quot;aperture&quot;), &quot;f-number&quot;)) != NULL)</a>
<a name="ln576">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln577">  else if((prop = _lib_property_add_new(lib, _(&quot;aperture&quot;), &quot;aperture&quot;)) != NULL) // for Canon cameras</a>
<a name="ln578">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln579"> </a>
<a name="ln580">  if((prop = _lib_property_add_new(lib, _(&quot;focal length&quot;), &quot;focallength&quot;)) != NULL)</a>
<a name="ln581">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln582"> </a>
<a name="ln583">  if((prop = _lib_property_add_new(lib, _(&quot;shutterspeed2&quot;), &quot;shutterspeed2&quot;)) != NULL)</a>
<a name="ln584">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln585">  else if((prop = _lib_property_add_new(lib, _(&quot;shutterspeed&quot;), &quot;shutterspeed&quot;)) != NULL) // Canon, again</a>
<a name="ln586">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln587"> </a>
<a name="ln588">  if((prop = _lib_property_add_new(lib, _(&quot;ISO&quot;), &quot;iso&quot;)) != NULL)</a>
<a name="ln589">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln590"> </a>
<a name="ln591">  if((prop = _lib_property_add_new(lib, _(&quot;WB&quot;), &quot;whitebalance&quot;)) != NULL)</a>
<a name="ln592">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln593"> </a>
<a name="ln594">  if((prop = _lib_property_add_new(lib, _(&quot;quality&quot;), &quot;imagequality&quot;)) != NULL)</a>
<a name="ln595">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln596"> </a>
<a name="ln597">  if((prop = _lib_property_add_new(lib, _(&quot;size&quot;), &quot;imagesize&quot;)) != NULL)</a>
<a name="ln598">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln599"> </a>
<a name="ln600">  /* add user widgets */</a>
<a name="ln601">  GSList *options = dt_conf_all_string_entries(&quot;plugins/capture/tethering/properties&quot;);</a>
<a name="ln602">  if(options)</a>
<a name="ln603">  {</a>
<a name="ln604">    GSList *item = options;</a>
<a name="ln605">    do</a>
<a name="ln606">    {</a>
<a name="ln607">      dt_conf_string_entry_t *entry = (dt_conf_string_entry_t *)item-&gt;data;</a>
<a name="ln608"> </a>
<a name="ln609">      /* get the label from key */</a>
<a name="ln610">      char *p = entry-&gt;key;</a>
<a name="ln611">      const char *end = entry-&gt;key + strlen(entry-&gt;key);</a>
<a name="ln612">      while(p++ &lt; end)</a>
<a name="ln613">        if(*p == '_') *p = ' ';</a>
<a name="ln614"> </a>
<a name="ln615">      if((prop = _lib_property_add_new(lib, entry-&gt;key, entry-&gt;value)) != NULL)</a>
<a name="ln616">        _lib_property_add_to_gui(prop, lib);</a>
<a name="ln617">    } while((item = g_slist_next(item)) != NULL);</a>
<a name="ln618">    g_slist_free_full(options, dt_conf_string_entry_free);</a>
<a name="ln619">  }</a>
<a name="ln620">  /* build the propertymenu  we do it now because it needs an actual camera */</a>
<a name="ln621">  dt_camctl_camera_build_property_menu(darktable.camctl, NULL, &amp;lib-&gt;gui.properties_menu,</a>
<a name="ln622">                                       G_CALLBACK(_property_choice_callback), lib);</a>
<a name="ln623"> </a>
<a name="ln624">  // Register listener</a>
<a name="ln625">  dt_camctl_register_listener(darktable.camctl, lib-&gt;data.listener);</a>
<a name="ln626">  dt_camctl_tether_mode(darktable.camctl, NULL, TRUE);</a>
<a name="ln627">  // Get camera model name</a>
<a name="ln628">  lib-&gt;data.camera_model = dt_camctl_camera_get_model(darktable.camctl, NULL);</a>
<a name="ln629">}</a>
<a name="ln630">void view_leave(struct dt_lib_module_t *self,struct dt_view_t *old_view,struct dt_view_t *new_view)</a>
<a name="ln631">{</a>
<a name="ln632">  dt_lib_camera_t *lib = self-&gt;data;</a>
<a name="ln633">  // remove listener from camera control..</a>
<a name="ln634">  dt_camctl_tether_mode(darktable.camctl, NULL, FALSE);</a>
<a name="ln635">  dt_camctl_unregister_listener(darktable.camctl, lib-&gt;data.listener);</a>
<a name="ln636">  gtk_widget_destroy(GTK_WIDGET(lib-&gt;gui.properties_menu));</a>
<a name="ln637">  lib-&gt;gui.properties_menu = NULL;</a>
<a name="ln638">  // remove all properties</a>
<a name="ln639">  while(lib-&gt;gui.prop_end &gt; lib-&gt;gui.prop_start +1) {</a>
<a name="ln640">    gtk_grid_remove_row(lib-&gt;gui.main_grid,lib-&gt;gui.prop_start +1);</a>
<a name="ln641">    lib-&gt;gui.rows--;</a>
<a name="ln642">    lib-&gt;gui.prop_end--;</a>
<a name="ln643">  }</a>
<a name="ln644">  // no need to free widgets, they are freed when the line of the grid is destroyed</a>
<a name="ln645">  g_list_free_full(lib-&gt;gui.properties,_lib_property_free);</a>
<a name="ln646">  lib-&gt;gui.properties = NULL;</a>
<a name="ln647">}</a>
<a name="ln648">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln649">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln650">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="135"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'prop'. Check lines: 135, 134.</p></div>
<div class="balloon" rel="327"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v751/" target="_blank">V751</a> Parameter 'height' is not used inside function body.</p></div>
<div class="balloon" rel="414"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lib'. Check lines: 414, 410.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
