
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln20">#include &quot;common/tags.h&quot;</a>
<a name="ln21">#include &quot;control/control.h&quot;</a>
<a name="ln22">#include &quot;develop/develop.h&quot;</a>
<a name="ln23">#include &quot;develop/imageop.h&quot;</a>
<a name="ln24">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln25">#include &quot;dtgtk/resetlabel.h&quot;</a>
<a name="ln26">#include &quot;dtgtk/togglebutton.h&quot;</a>
<a name="ln27">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln28">#include &quot;gui/color_picker_proxy.h&quot;</a>
<a name="ln29">#include &quot;gui/gtk.h&quot;</a>
<a name="ln30">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln31">#include &lt;assert.h&gt;</a>
<a name="ln32">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln33">#include &lt;inttypes.h&gt;</a>
<a name="ln34">#include &lt;math.h&gt;</a>
<a name="ln35">#include &lt;stdlib.h&gt;</a>
<a name="ln36">#include &lt;string.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;librsvg/rsvg.h&gt;</a>
<a name="ln39">// ugh, ugly hack. why do people break stuff all the time?</a>
<a name="ln40">#ifndef RSVG_CAIRO_H</a>
<a name="ln41">#include &lt;librsvg/rsvg-cairo.h&gt;</a>
<a name="ln42">#endif</a>
<a name="ln43"> </a>
<a name="ln44">#include &quot;common/file_location.h&quot;</a>
<a name="ln45">#include &quot;common/metadata.h&quot;</a>
<a name="ln46">#include &quot;common/utility.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">#define CLIP(x) ((x &lt; 0) ? 0.0 : (x &gt; 1.0) ? 1.0 : x)</a>
<a name="ln49">DT_MODULE_INTROSPECTION(4, dt_iop_watermark_params_t)</a>
<a name="ln50"> </a>
<a name="ln51">// gchar *checksum = g_compute_checksum_for_data(G_CHECKSUM_MD5,data,length);</a>
<a name="ln52"> </a>
<a name="ln53">typedef enum dt_iop_watermark_base_scale_t</a>
<a name="ln54">{</a>
<a name="ln55">  DT_SCALE_IMAGE = 0,</a>
<a name="ln56">  DT_SCALE_LARGER_BORDER = 1,</a>
<a name="ln57">  DT_SCALE_SMALLER_BORDER = 2</a>
<a name="ln58">} dt_iop_watermark_base_scale_t;</a>
<a name="ln59"> </a>
<a name="ln60">typedef struct dt_iop_watermark_params_t</a>
<a name="ln61">{</a>
<a name="ln62">  /** opacity value of rendering watermark */</a>
<a name="ln63">  float opacity;</a>
<a name="ln64">  /** scale value of rendering watermark */</a>
<a name="ln65">  float scale;</a>
<a name="ln66">  /** Pixel independent xoffset, 0 to 1 */</a>
<a name="ln67">  float xoffset;</a>
<a name="ln68">  /** Pixel independent yoffset, 0 to 1 */</a>
<a name="ln69">  float yoffset;</a>
<a name="ln70">  /** Alignment value 0-8 3x3 */</a>
<a name="ln71">  int alignment;</a>
<a name="ln72">  /** Rotation **/</a>
<a name="ln73">  float rotate;</a>
<a name="ln74">  dt_iop_watermark_base_scale_t sizeto;</a>
<a name="ln75">  char filename[64];</a>
<a name="ln76">  /* simple text */</a>
<a name="ln77">  char text[64];</a>
<a name="ln78">  /* text color */</a>
<a name="ln79">  float color[3];</a>
<a name="ln80">  /* text font */</a>
<a name="ln81">  char font[64];</a>
<a name="ln82">} dt_iop_watermark_params_t;</a>
<a name="ln83"> </a>
<a name="ln84">typedef struct dt_iop_watermark_data_t</a>
<a name="ln85">{</a>
<a name="ln86">  float opacity;</a>
<a name="ln87">  float scale;</a>
<a name="ln88">  float xoffset;</a>
<a name="ln89">  float yoffset;</a>
<a name="ln90">  int alignment;</a>
<a name="ln91">  float rotate;</a>
<a name="ln92">  dt_iop_watermark_base_scale_t sizeto;</a>
<a name="ln93">  char filename[64];</a>
<a name="ln94">  char text[64];</a>
<a name="ln95">  float color[3];</a>
<a name="ln96">  char font[64];</a>
<a name="ln97">} dt_iop_watermark_data_t;</a>
<a name="ln98"> </a>
<a name="ln99">typedef struct dt_iop_watermark_gui_data_t</a>
<a name="ln100">{</a>
<a name="ln101">  GtkWidget *watermarks;                             // watermark</a>
<a name="ln102">  GList     *watermarks_filenames;                   // the actual filenames. the dropdown lacks file extensions</a>
<a name="ln103">  GtkWidget *refresh;                                // refresh watermarks...</a>
<a name="ln104">  GtkWidget *align[9];                               // Alignment buttons</a>
<a name="ln105">  GtkWidget *opacity, *scale, *x_offset, *y_offset;  // opacity, scale, xoffs, yoffs</a>
<a name="ln106">  GtkWidget *sizeto;                                 // relative size to</a>
<a name="ln107">  GtkWidget *rotate;</a>
<a name="ln108">  GtkWidget *text;</a>
<a name="ln109">  GtkWidget *colorpick;</a>
<a name="ln110">  GtkWidget *fontsel;</a>
<a name="ln111">  GtkToggleButton *color_picker_button;</a>
<a name="ln112">  dt_iop_color_picker_t color_picker;</a>
<a name="ln113">} dt_iop_watermark_gui_data_t;</a>
<a name="ln114"> </a>
<a name="ln115">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln116">                  void *new_params, const int new_version)</a>
<a name="ln117">{</a>
<a name="ln118">  if(old_version == 1 &amp;&amp; new_version == 4)</a>
<a name="ln119">  {</a>
<a name="ln120">    typedef struct dt_iop_watermark_params_v1_t</a>
<a name="ln121">    {</a>
<a name="ln122">      /** opacity value of rendering watermark */</a>
<a name="ln123">      float opacity;</a>
<a name="ln124">      /** scale value of rendering watermark */</a>
<a name="ln125">      float scale;</a>
<a name="ln126">      /** Pixel independent xoffset, 0 to 1 */</a>
<a name="ln127">      float xoffset;</a>
<a name="ln128">      /** Pixel independent yoffset, 0 to 1 */</a>
<a name="ln129">      float yoffset;</a>
<a name="ln130">      /** Alignment value 0-8 3x3 */</a>
<a name="ln131">      int alignment;</a>
<a name="ln132">      char filename[64];</a>
<a name="ln133">    } dt_iop_watermark_params_v1_t;</a>
<a name="ln134"> </a>
<a name="ln135">    dt_iop_watermark_params_v1_t *o = (dt_iop_watermark_params_v1_t *)old_params;</a>
<a name="ln136">    dt_iop_watermark_params_t *n = (dt_iop_watermark_params_t *)new_params;</a>
<a name="ln137">    dt_iop_watermark_params_t *d = (dt_iop_watermark_params_t *)self-&gt;default_params;</a>
<a name="ln138"> </a>
<a name="ln139">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln140"> </a>
<a name="ln141">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln142">    n-&gt;scale = o-&gt;scale;</a>
<a name="ln143">    n-&gt;xoffset = o-&gt;xoffset;</a>
<a name="ln144">    n-&gt;yoffset = o-&gt;yoffset;</a>
<a name="ln145">    n-&gt;alignment = o-&gt;alignment;</a>
<a name="ln146">    n-&gt;rotate = 0.0;</a>
<a name="ln147">    n-&gt;sizeto = DT_SCALE_IMAGE;</a>
<a name="ln148">    g_strlcpy(n-&gt;filename, o-&gt;filename, sizeof(n-&gt;filename));</a>
<a name="ln149">    g_strlcpy(n-&gt;text, &quot;&quot;, sizeof(n-&gt;text));</a>
<a name="ln150">    g_strlcpy(n-&gt;font, &quot;DejaVu Sans 10&quot;, sizeof(n-&gt;font));</a>
<a name="ln151">    n-&gt;color[0] = n-&gt;color[1] = n-&gt;color[2] = 0;</a>
<a name="ln152">    return 0;</a>
<a name="ln153">  }</a>
<a name="ln154">  else if(old_version == 2 &amp;&amp; new_version == 4)</a>
<a name="ln155">  {</a>
<a name="ln156">    typedef struct dt_iop_watermark_params_v2_t</a>
<a name="ln157">    {</a>
<a name="ln158">      /** opacity value of rendering watermark */</a>
<a name="ln159">      float opacity;</a>
<a name="ln160">      /** scale value of rendering watermark */</a>
<a name="ln161">      float scale;</a>
<a name="ln162">      /** Pixel independent xoffset, 0 to 1 */</a>
<a name="ln163">      float xoffset;</a>
<a name="ln164">      /** Pixel independent yoffset, 0 to 1 */</a>
<a name="ln165">      float yoffset;</a>
<a name="ln166">      /** Alignment value 0-8 3x3 */</a>
<a name="ln167">      int alignment;</a>
<a name="ln168">      dt_iop_watermark_base_scale_t sizeto;</a>
<a name="ln169">      char filename[64];</a>
<a name="ln170">    } dt_iop_watermark_params_v2_t;</a>
<a name="ln171"> </a>
<a name="ln172">    dt_iop_watermark_params_v2_t *o = (dt_iop_watermark_params_v2_t *)old_params;</a>
<a name="ln173">    dt_iop_watermark_params_t *n = (dt_iop_watermark_params_t *)new_params;</a>
<a name="ln174">    dt_iop_watermark_params_t *d = (dt_iop_watermark_params_t *)self-&gt;default_params;</a>
<a name="ln175"> </a>
<a name="ln176">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln177"> </a>
<a name="ln178">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln179">    n-&gt;scale = o-&gt;scale;</a>
<a name="ln180">    n-&gt;xoffset = o-&gt;xoffset;</a>
<a name="ln181">    n-&gt;yoffset = o-&gt;yoffset;</a>
<a name="ln182">    n-&gt;alignment = o-&gt;alignment;</a>
<a name="ln183">    n-&gt;rotate = 0.0;</a>
<a name="ln184">    n-&gt;sizeto = DT_SCALE_IMAGE;</a>
<a name="ln185">    g_strlcpy(n-&gt;filename, o-&gt;filename, sizeof(n-&gt;filename));</a>
<a name="ln186">    g_strlcpy(n-&gt;text, &quot;&quot;, sizeof(n-&gt;text));</a>
<a name="ln187">    g_strlcpy(n-&gt;font, &quot;DejaVu Sans 10&quot;, sizeof(n-&gt;font));</a>
<a name="ln188">    n-&gt;color[0] = n-&gt;color[1] = n-&gt;color[2] = 0;</a>
<a name="ln189">    return 0;</a>
<a name="ln190">  }</a>
<a name="ln191">  else if(old_version == 3 &amp;&amp; new_version == 4)</a>
<a name="ln192">  {</a>
<a name="ln193">    typedef struct dt_iop_watermark_params_v3_t</a>
<a name="ln194">    {</a>
<a name="ln195">      /** opacity value of rendering watermark */</a>
<a name="ln196">      float opacity;</a>
<a name="ln197">      /** scale value of rendering watermark */</a>
<a name="ln198">      float scale;</a>
<a name="ln199">      /** Pixel independent xoffset, 0 to 1 */</a>
<a name="ln200">      float xoffset;</a>
<a name="ln201">      /** Pixel independent yoffset, 0 to 1 */</a>
<a name="ln202">      float yoffset;</a>
<a name="ln203">      /** Alignment value 0-8 3x3 */</a>
<a name="ln204">      int alignment;</a>
<a name="ln205">      /** Rotation **/</a>
<a name="ln206">      float rotate;</a>
<a name="ln207">      dt_iop_watermark_base_scale_t sizeto;</a>
<a name="ln208">      char filename[64];</a>
<a name="ln209">    } dt_iop_watermark_params_v3_t;</a>
<a name="ln210"> </a>
<a name="ln211">    dt_iop_watermark_params_v3_t *o = (dt_iop_watermark_params_v3_t *)old_params;</a>
<a name="ln212">    dt_iop_watermark_params_t *n = (dt_iop_watermark_params_t *)new_params;</a>
<a name="ln213">    dt_iop_watermark_params_t *d = (dt_iop_watermark_params_t *)self-&gt;default_params;</a>
<a name="ln214"> </a>
<a name="ln215">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln216"> </a>
<a name="ln217">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln218">    n-&gt;scale = o-&gt;scale;</a>
<a name="ln219">    n-&gt;xoffset = o-&gt;xoffset;</a>
<a name="ln220">    n-&gt;yoffset = o-&gt;yoffset;</a>
<a name="ln221">    n-&gt;alignment = o-&gt;alignment;</a>
<a name="ln222">    n-&gt;rotate = o-&gt;rotate;</a>
<a name="ln223">    n-&gt;sizeto = o-&gt;sizeto;</a>
<a name="ln224">    g_strlcpy(n-&gt;filename, o-&gt;filename, sizeof(n-&gt;filename));</a>
<a name="ln225">    g_strlcpy(n-&gt;text, &quot;&quot;, sizeof(n-&gt;text));</a>
<a name="ln226">    g_strlcpy(n-&gt;font, &quot;DejaVu Sans 10&quot;, sizeof(n-&gt;font));</a>
<a name="ln227">    n-&gt;color[0] = n-&gt;color[1] = n-&gt;color[2] = 0;</a>
<a name="ln228">    return 0;</a>
<a name="ln229">  }</a>
<a name="ln230">  return 1;</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233"> </a>
<a name="ln234">const char *name()</a>
<a name="ln235">{</a>
<a name="ln236">  return _(&quot;watermark&quot;);</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">int flags()</a>
<a name="ln240">{</a>
<a name="ln241">  return IOP_FLAGS_INCLUDE_IN_STYLES | IOP_FLAGS_SUPPORTS_BLENDING;</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">int default_group()</a>
<a name="ln245">{</a>
<a name="ln246">  return IOP_GROUP_EFFECT;</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">int operation_tags()</a>
<a name="ln250">{</a>
<a name="ln251">  return IOP_TAG_DECORATION;</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln255">{</a>
<a name="ln256">  return iop_cs_rgb;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln260">{</a>
<a name="ln261">  dt_accel_register_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;refresh&quot;), 0, 0);</a>
<a name="ln262">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;opacity&quot;));</a>
<a name="ln263">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;scale&quot;));</a>
<a name="ln264">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;rotation&quot;));</a>
<a name="ln265">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;x offset&quot;));</a>
<a name="ln266">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;y offset&quot;));</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln270">{</a>
<a name="ln271">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln272"> </a>
<a name="ln273">  dt_accel_connect_button_iop(self, &quot;refresh&quot;, GTK_WIDGET(g-&gt;refresh));</a>
<a name="ln274">  dt_accel_connect_slider_iop(self, &quot;opacity&quot;, GTK_WIDGET(g-&gt;opacity));</a>
<a name="ln275">  dt_accel_connect_slider_iop(self, &quot;scale&quot;, GTK_WIDGET(g-&gt;scale));</a>
<a name="ln276">  dt_accel_connect_slider_iop(self, &quot;rotation&quot;, GTK_WIDGET(g-&gt;rotate));</a>
<a name="ln277">  dt_accel_connect_slider_iop(self, &quot;x offset&quot;, GTK_WIDGET(g-&gt;x_offset));</a>
<a name="ln278">  dt_accel_connect_slider_iop(self, &quot;y offset&quot;, GTK_WIDGET(g-&gt;y_offset));</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">static void _combo_box_set_active_text(dt_iop_watermark_gui_data_t *g, gchar *text)</a>
<a name="ln282">{</a>
<a name="ln283">  int i = 0;</a>
<a name="ln284">  for(const GList *iter = g-&gt;watermarks_filenames; iter; iter = g_list_next(iter))</a>
<a name="ln285">  {</a>
<a name="ln286">    if(!g_strcmp0((gchar *)iter-&gt;data, text))</a>
<a name="ln287">    {</a>
<a name="ln288">      dt_bauhaus_combobox_set(g-&gt;watermarks, i);</a>
<a name="ln289">      return;</a>
<a name="ln290">    }</a>
<a name="ln291">    i++;</a>
<a name="ln292">  }</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">// replace &lt; and &gt; with &amp;lt; and &amp;gt;. any more? Yes! &amp; -&gt; &amp;amp;</a>
<a name="ln296">static gchar *_string_escape(const gchar *string)</a>
<a name="ln297">{</a>
<a name="ln298">  gchar *result, *result_old;</a>
<a name="ln299">  result = dt_util_str_replace(string, &quot;&amp;&quot;, &quot;&amp;amp;&quot;);</a>
<a name="ln300"> </a>
<a name="ln301">  result_old = result;</a>
<a name="ln302">  result = dt_util_str_replace(result_old, &quot;&lt;&quot;, &quot;&amp;lt;&quot;);</a>
<a name="ln303">  g_free(result_old);</a>
<a name="ln304"> </a>
<a name="ln305">  result_old = result;</a>
<a name="ln306">  result = dt_util_str_replace(result_old, &quot;&gt;&quot;, &quot;&amp;gt;&quot;);</a>
<a name="ln307">  g_free(result_old);</a>
<a name="ln308"> </a>
<a name="ln309">  return result;</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312">static gchar *_string_substitute(gchar *string, const gchar *search, const gchar *replace)</a>
<a name="ln313">{</a>
<a name="ln314">  gchar *_replace = _string_escape(replace);</a>
<a name="ln315">  gchar *result = dt_util_str_replace(string, search, _replace);</a>
<a name="ln316">  g_free(_replace);</a>
<a name="ln317">  return result;</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">static gchar *_watermark_get_svgdoc(dt_iop_module_t *self, dt_iop_watermark_data_t *data,</a>
<a name="ln321">                                    const dt_image_t *image)</a>
<a name="ln322">{</a>
<a name="ln323">  gsize length;</a>
<a name="ln324"> </a>
<a name="ln325">  gchar *svgdoc = NULL;</a>
<a name="ln326">  gchar configdir[PATH_MAX] = { 0 };</a>
<a name="ln327">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln328">  gchar *filename;</a>
<a name="ln329">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln330">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln331">  g_strlcat(datadir, &quot;/watermarks/&quot;, sizeof(datadir));</a>
<a name="ln332">  g_strlcat(configdir, &quot;/watermarks/&quot;, sizeof(configdir));</a>
<a name="ln333">  g_strlcat(datadir, data-&gt;filename, sizeof(datadir));</a>
<a name="ln334">  g_strlcat(configdir, data-&gt;filename, sizeof(configdir));</a>
<a name="ln335"> </a>
<a name="ln336">  if(g_file_test(configdir, G_FILE_TEST_EXISTS))</a>
<a name="ln337">    filename = configdir;</a>
<a name="ln338">  else if(g_file_test(datadir, G_FILE_TEST_EXISTS))</a>
<a name="ln339">    filename = datadir;</a>
<a name="ln340">  else</a>
<a name="ln341">    return NULL;</a>
<a name="ln342"> </a>
<a name="ln343">  gchar *svgdata = NULL;</a>
<a name="ln344">  char datetime[200];</a>
<a name="ln345"> </a>
<a name="ln346">  // EXIF datetime</a>
<a name="ln347">  struct tm tt_exif = { 0 };</a>
<a name="ln348">  if(sscanf(image-&gt;exif_datetime_taken, &quot;%d:%d:%d %d:%d:%d&quot;, &amp;tt_exif.tm_year, &amp;tt_exif.tm_mon,</a>
<a name="ln349">            &amp;tt_exif.tm_mday, &amp;tt_exif.tm_hour, &amp;tt_exif.tm_min, &amp;tt_exif.tm_sec) == 6)</a>
<a name="ln350">  {</a>
<a name="ln351">    tt_exif.tm_year -= 1900;</a>
<a name="ln352">    tt_exif.tm_mon--;</a>
<a name="ln353">  }</a>
<a name="ln354"> </a>
<a name="ln355">  // Current datetime</a>
<a name="ln356">  struct tm tt_cur = { 0 };</a>
<a name="ln357">  time_t t = time(NULL);</a>
<a name="ln358">  (void)localtime_r(&amp;t, &amp;tt_cur);</a>
<a name="ln359"> </a>
<a name="ln360">  if(g_file_get_contents(filename, &amp;svgdata, &amp;length, NULL))</a>
<a name="ln361">  {</a>
<a name="ln362">    // File is loaded lets substitute strings if found...</a>
<a name="ln363"> </a>
<a name="ln364">    // Darktable internal</a>
<a name="ln365">    svgdoc = _string_substitute(svgdata, &quot;$(DARKTABLE.NAME)&quot;, PACKAGE_NAME);</a>
<a name="ln366">    if(svgdoc != svgdata)</a>
<a name="ln367">    {</a>
<a name="ln368">      g_free(svgdata);</a>
<a name="ln369">      svgdata = svgdoc;</a>
<a name="ln370">    }</a>
<a name="ln371">    svgdoc = _string_substitute(svgdata, &quot;$(DARKTABLE.VERSION)&quot;, darktable_package_version);</a>
<a name="ln372">    if(svgdoc != svgdata)</a>
<a name="ln373">    {</a>
<a name="ln374">      g_free(svgdata);</a>
<a name="ln375">      svgdata = svgdoc;</a>
<a name="ln376">    }</a>
<a name="ln377"> </a>
<a name="ln378">    // Simple text from watermark module</a>
<a name="ln379">    gchar buffer[1024];</a>
<a name="ln380"> </a>
<a name="ln381">    if (data-&gt;font[0] &amp;&amp; data-&gt;text[0])</a>
<a name="ln382">    {</a>
<a name="ln383">      g_snprintf(buffer, sizeof(buffer), &quot;%s&quot;, data-&gt;text);</a>
<a name="ln384">      svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_TEXT)&quot;, buffer);</a>
<a name="ln385">      if(svgdoc != svgdata)</a>
<a name="ln386">      {</a>
<a name="ln387">        g_free(svgdata);</a>
<a name="ln388">        svgdata = svgdoc;</a>
<a name="ln389">      }</a>
<a name="ln390"> </a>
<a name="ln391">      PangoFontDescription *font = pango_font_description_from_string(data-&gt;font);</a>
<a name="ln392">      const PangoStyle font_style = pango_font_description_get_style(font);</a>
<a name="ln393">      const int font_weight = (int)pango_font_description_get_weight(font);</a>
<a name="ln394"> </a>
<a name="ln395">      g_snprintf(buffer, sizeof(buffer), &quot;%s&quot;, pango_font_description_get_family(font));</a>
<a name="ln396">      svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_FONT_FAMILY)&quot;, buffer);</a>
<a name="ln397">      if(svgdoc != svgdata)</a>
<a name="ln398">      {</a>
<a name="ln399">        g_free(svgdata);</a>
<a name="ln400">        svgdata = svgdoc;</a>
<a name="ln401">      }</a>
<a name="ln402"> </a>
<a name="ln403">      switch (font_style)</a>
<a name="ln404">      {</a>
<a name="ln405">      case PANGO_STYLE_OBLIQUE:</a>
<a name="ln406">        g_strlcpy(buffer, &quot;oblique&quot;, sizeof(buffer));</a>
<a name="ln407">        break;</a>
<a name="ln408">      case PANGO_STYLE_ITALIC:</a>
<a name="ln409">        g_strlcpy(buffer, &quot;italic&quot;, sizeof(buffer));</a>
<a name="ln410">        break;</a>
<a name="ln411">      default:</a>
<a name="ln412">        g_strlcpy(buffer, &quot;normal&quot;, sizeof(buffer));</a>
<a name="ln413">        break;</a>
<a name="ln414">      }</a>
<a name="ln415">      svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_FONT_STYLE)&quot;, buffer);</a>
<a name="ln416">      if(svgdoc != svgdata)</a>
<a name="ln417">      {</a>
<a name="ln418">        g_free(svgdata);</a>
<a name="ln419">        svgdata = svgdoc;</a>
<a name="ln420">      }</a>
<a name="ln421"> </a>
<a name="ln422">      g_snprintf(buffer, sizeof(buffer), &quot;%d&quot;, font_weight);</a>
<a name="ln423">      svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_FONT_WEIGHT)&quot;, buffer);</a>
<a name="ln424">      if(svgdoc != svgdata)</a>
<a name="ln425">      {</a>
<a name="ln426">        g_free(svgdata);</a>
<a name="ln427">        svgdata = svgdoc;</a>
<a name="ln428">      }</a>
<a name="ln429"> </a>
<a name="ln430">      pango_font_description_free(font);</a>
<a name="ln431">    }</a>
<a name="ln432"> </a>
<a name="ln433">    // watermark color</a>
<a name="ln434">    GdkRGBA c = { data-&gt;color[0], data-&gt;color[1], data-&gt;color[2], 1.0f };</a>
<a name="ln435">    g_snprintf(buffer, sizeof(buffer), &quot;%s&quot;, gdk_rgba_to_string(&amp;c));</a>
<a name="ln436">    svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_COLOR)&quot;, buffer);</a>
<a name="ln437">    if(svgdoc != svgdata)</a>
<a name="ln438">    {</a>
<a name="ln439">      g_free(svgdata);</a>
<a name="ln440">      svgdata = svgdoc;</a>
<a name="ln441">    }</a>
<a name="ln442"> </a>
<a name="ln443">    // Current image ID</a>
<a name="ln444">    g_snprintf(buffer, sizeof(buffer), &quot;%d&quot;, image-&gt;id);</a>
<a name="ln445">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.ID)&quot;, buffer);</a>
<a name="ln446">    if(svgdoc != svgdata)</a>
<a name="ln447">    {</a>
<a name="ln448">      g_free(svgdata);</a>
<a name="ln449">      svgdata = svgdoc;</a>
<a name="ln450">    }</a>
<a name="ln451"> </a>
<a name="ln452">    // Current image</a>
<a name="ln453">    dt_image_print_exif(image, buffer, sizeof(buffer));</a>
<a name="ln454">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.EXIF)&quot;, buffer);</a>
<a name="ln455">    if(svgdoc != svgdata)</a>
<a name="ln456">    {</a>
<a name="ln457">      g_free(svgdata);</a>
<a name="ln458">      svgdata = svgdoc;</a>
<a name="ln459">    }</a>
<a name="ln460"> </a>
<a name="ln461">    // Image exif</a>
<a name="ln462">    // EXIF date</a>
<a name="ln463">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE)&quot;, image-&gt;exif_datetime_taken);</a>
<a name="ln464">    if(svgdoc != svgdata)</a>
<a name="ln465">    {</a>
<a name="ln466">      g_free(svgdata);</a>
<a name="ln467">      svgdata = svgdoc;</a>
<a name="ln468">    }</a>
<a name="ln469">    // $(EXIF.DATE.SECOND) -- 00..60</a>
<a name="ln470">    strftime(datetime, sizeof(datetime), &quot;%S&quot;, &amp;tt_exif);</a>
<a name="ln471">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.SECOND)&quot;, datetime);</a>
<a name="ln472">    if(svgdoc != svgdata)</a>
<a name="ln473">    {</a>
<a name="ln474">      g_free(svgdata);</a>
<a name="ln475">      svgdata = svgdoc;</a>
<a name="ln476">    }</a>
<a name="ln477">    // $(EXIF.DATE.MINUTE) -- 00..59</a>
<a name="ln478">    strftime(datetime, sizeof(datetime), &quot;%M&quot;, &amp;tt_exif);</a>
<a name="ln479">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.MINUTE)&quot;, datetime);</a>
<a name="ln480">    if(svgdoc != svgdata)</a>
<a name="ln481">    {</a>
<a name="ln482">      g_free(svgdata);</a>
<a name="ln483">      svgdata = svgdoc;</a>
<a name="ln484">    }</a>
<a name="ln485">    // $(EXIF.DATE.HOUR) -- 00..23</a>
<a name="ln486">    strftime(datetime, sizeof(datetime), &quot;%H&quot;, &amp;tt_exif);</a>
<a name="ln487">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.HOUR)&quot;, datetime);</a>
<a name="ln488">    if(svgdoc != svgdata)</a>
<a name="ln489">    {</a>
<a name="ln490">      g_free(svgdata);</a>
<a name="ln491">      svgdata = svgdoc;</a>
<a name="ln492">    }</a>
<a name="ln493">    // $(EXIF.DATE.HOUR_AMPM) -- 01..12</a>
<a name="ln494">    strftime(datetime, sizeof(datetime), &quot;%I %p&quot;, &amp;tt_exif);</a>
<a name="ln495">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.HOUR_AMPM)&quot;, datetime);</a>
<a name="ln496">    if(svgdoc != svgdata)</a>
<a name="ln497">    {</a>
<a name="ln498">      g_free(svgdata);</a>
<a name="ln499">      svgdata = svgdoc;</a>
<a name="ln500">    }</a>
<a name="ln501">    // $(EXIF.DATE.DAY) -- 01..31</a>
<a name="ln502">    strftime(datetime, sizeof(datetime), &quot;%d&quot;, &amp;tt_exif);</a>
<a name="ln503">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.DAY)&quot;, datetime);</a>
<a name="ln504">    if(svgdoc != svgdata)</a>
<a name="ln505">    {</a>
<a name="ln506">      g_free(svgdata);</a>
<a name="ln507">      svgdata = svgdoc;</a>
<a name="ln508">    }</a>
<a name="ln509">    // $(EXIF.DATE.MONTH) -- 01..12</a>
<a name="ln510">    strftime(datetime, sizeof(datetime), &quot;%m&quot;, &amp;tt_exif);</a>
<a name="ln511">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.MONTH)&quot;, datetime);</a>
<a name="ln512">    if(svgdoc != svgdata)</a>
<a name="ln513">    {</a>
<a name="ln514">      g_free(svgdata);</a>
<a name="ln515">      svgdata = svgdoc;</a>
<a name="ln516">    }</a>
<a name="ln517">    // $(EXIF.DATE.SHORT_MONTH) -- Jan, Feb, .., Dec, localized</a>
<a name="ln518">    strftime(datetime, sizeof(datetime), &quot;%b&quot;, &amp;tt_exif);</a>
<a name="ln519">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.SHORT_MONTH)&quot;, datetime);</a>
<a name="ln520">    if(svgdoc != svgdata)</a>
<a name="ln521">    {</a>
<a name="ln522">      g_free(svgdata);</a>
<a name="ln523">      svgdata = svgdoc;</a>
<a name="ln524">    }</a>
<a name="ln525">    // $(EXIF.DATE.LONG_MONTH) -- January, February, .., December, localized</a>
<a name="ln526">    strftime(datetime, sizeof(datetime), &quot;%B&quot;, &amp;tt_exif);</a>
<a name="ln527">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.LONG_MONTH)&quot;, datetime);</a>
<a name="ln528">    if(svgdoc != svgdata)</a>
<a name="ln529">    {</a>
<a name="ln530">      g_free(svgdata);</a>
<a name="ln531">      svgdata = svgdoc;</a>
<a name="ln532">    }</a>
<a name="ln533">    // $(EXIF.DATE.SHORT_YEAR) -- 12</a>
<a name="ln534">    strftime(datetime, sizeof(datetime), &quot;%y&quot;, &amp;tt_exif);</a>
<a name="ln535">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.SHORT_YEAR)&quot;, datetime);</a>
<a name="ln536">    if(svgdoc != svgdata)</a>
<a name="ln537">    {</a>
<a name="ln538">      g_free(svgdata);</a>
<a name="ln539">      svgdata = svgdoc;</a>
<a name="ln540">    }</a>
<a name="ln541">    // $(EXIF.DATE.LONG_YEAR) -- 2012</a>
<a name="ln542">    strftime(datetime, sizeof(datetime), &quot;%Y&quot;, &amp;tt_exif);</a>
<a name="ln543">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.LONG_YEAR)&quot;, datetime);</a>
<a name="ln544">    if(svgdoc != svgdata)</a>
<a name="ln545">    {</a>
<a name="ln546">      g_free(svgdata);</a>
<a name="ln547">      svgdata = svgdoc;</a>
<a name="ln548">    }</a>
<a name="ln549"> </a>
<a name="ln550">    // Current date</a>
<a name="ln551">    // $(DATE) -- YYYY:</a>
<a name="ln552">    dt_gettime_t(datetime, sizeof(datetime), t);</a>
<a name="ln553">    svgdoc = _string_substitute(svgdata, &quot;$(DATE)&quot;, datetime);</a>
<a name="ln554">    if(svgdoc != svgdata)</a>
<a name="ln555">    {</a>
<a name="ln556">      g_free(svgdata);</a>
<a name="ln557">      svgdata = svgdoc;</a>
<a name="ln558">    }</a>
<a name="ln559">    // $(DATE.SECOND) -- 00..60</a>
<a name="ln560">    strftime(datetime, sizeof(datetime), &quot;%S&quot;, &amp;tt_cur);</a>
<a name="ln561">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.SECOND)&quot;, datetime);</a>
<a name="ln562">    if(svgdoc != svgdata)</a>
<a name="ln563">    {</a>
<a name="ln564">      g_free(svgdata);</a>
<a name="ln565">      svgdata = svgdoc;</a>
<a name="ln566">    }</a>
<a name="ln567">    // $(DATE.MINUTE) -- 00..59</a>
<a name="ln568">    strftime(datetime, sizeof(datetime), &quot;%M&quot;, &amp;tt_cur);</a>
<a name="ln569">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.MINUTE)&quot;, datetime);</a>
<a name="ln570">    if(svgdoc != svgdata)</a>
<a name="ln571">    {</a>
<a name="ln572">      g_free(svgdata);</a>
<a name="ln573">      svgdata = svgdoc;</a>
<a name="ln574">    }</a>
<a name="ln575">    // $(DATE.HOUR) -- 00..23</a>
<a name="ln576">    strftime(datetime, sizeof(datetime), &quot;%H&quot;, &amp;tt_cur);</a>
<a name="ln577">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.HOUR)&quot;, datetime);</a>
<a name="ln578">    if(svgdoc != svgdata)</a>
<a name="ln579">    {</a>
<a name="ln580">      g_free(svgdata);</a>
<a name="ln581">      svgdata = svgdoc;</a>
<a name="ln582">    }</a>
<a name="ln583">    // $(DATE.HOUR_AMPM) -- 01..12</a>
<a name="ln584">    strftime(datetime, sizeof(datetime), &quot;%I %p&quot;, &amp;tt_cur);</a>
<a name="ln585">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.HOUR_AMPM)&quot;, datetime);</a>
<a name="ln586">    if(svgdoc != svgdata)</a>
<a name="ln587">    {</a>
<a name="ln588">      g_free(svgdata);</a>
<a name="ln589">      svgdata = svgdoc;</a>
<a name="ln590">    }</a>
<a name="ln591">    // $(DATE.DAY) -- 01..31</a>
<a name="ln592">    strftime(datetime, sizeof(datetime), &quot;%d&quot;, &amp;tt_cur);</a>
<a name="ln593">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.DAY)&quot;, datetime);</a>
<a name="ln594">    if(svgdoc != svgdata)</a>
<a name="ln595">    {</a>
<a name="ln596">      g_free(svgdata);</a>
<a name="ln597">      svgdata = svgdoc;</a>
<a name="ln598">    }</a>
<a name="ln599">    // $(DATE.MONTH) -- 01..12</a>
<a name="ln600">    strftime(datetime, sizeof(datetime), &quot;%m&quot;, &amp;tt_cur);</a>
<a name="ln601">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.MONTH)&quot;, datetime);</a>
<a name="ln602">    if(svgdoc != svgdata)</a>
<a name="ln603">    {</a>
<a name="ln604">      g_free(svgdata);</a>
<a name="ln605">      svgdata = svgdoc;</a>
<a name="ln606">    }</a>
<a name="ln607">    // $(DATE.SHORT_MONTH) -- Jan, Feb, .., Dec, localized</a>
<a name="ln608">    strftime(datetime, sizeof(datetime), &quot;%b&quot;, &amp;tt_cur);</a>
<a name="ln609">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.SHORT_MONTH)&quot;, datetime);</a>
<a name="ln610">    if(svgdoc != svgdata)</a>
<a name="ln611">    {</a>
<a name="ln612">      g_free(svgdata);</a>
<a name="ln613">      svgdata = svgdoc;</a>
<a name="ln614">    }</a>
<a name="ln615">    // $(DATE.LONG_MONTH) -- January, February, .., December, localized</a>
<a name="ln616">    strftime(datetime, sizeof(datetime), &quot;%B&quot;, &amp;tt_cur);</a>
<a name="ln617">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.LONG_MONTH)&quot;, datetime);</a>
<a name="ln618">    if(svgdoc != svgdata)</a>
<a name="ln619">    {</a>
<a name="ln620">      g_free(svgdata);</a>
<a name="ln621">      svgdata = svgdoc;</a>
<a name="ln622">    }</a>
<a name="ln623">    // $(DATE.SHORT_YEAR) -- 12</a>
<a name="ln624">    strftime(datetime, sizeof(datetime), &quot;%y&quot;, &amp;tt_cur);</a>
<a name="ln625">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.SHORT_YEAR)&quot;, datetime);</a>
<a name="ln626">    if(svgdoc != svgdata)</a>
<a name="ln627">    {</a>
<a name="ln628">      g_free(svgdata);</a>
<a name="ln629">      svgdata = svgdoc;</a>
<a name="ln630">    }</a>
<a name="ln631">    // $(DATE.LONG_YEAR) -- 2012</a>
<a name="ln632">    strftime(datetime, sizeof(datetime), &quot;%Y&quot;, &amp;tt_cur);</a>
<a name="ln633">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.LONG_YEAR)&quot;, datetime);</a>
<a name="ln634">    if(svgdoc != svgdata)</a>
<a name="ln635">    {</a>
<a name="ln636">      g_free(svgdata);</a>
<a name="ln637">      svgdata = svgdoc;</a>
<a name="ln638">    }</a>
<a name="ln639"> </a>
<a name="ln640">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.MAKER)&quot;, image-&gt;camera_maker);</a>
<a name="ln641">    if(svgdoc != svgdata)</a>
<a name="ln642">    {</a>
<a name="ln643">      g_free(svgdata);</a>
<a name="ln644">      svgdata = svgdoc;</a>
<a name="ln645">    }</a>
<a name="ln646">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.MODEL)&quot;, image-&gt;camera_model);</a>
<a name="ln647">    if(svgdoc != svgdata)</a>
<a name="ln648">    {</a>
<a name="ln649">      g_free(svgdata);</a>
<a name="ln650">      svgdata = svgdoc;</a>
<a name="ln651">    }</a>
<a name="ln652">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.LENS)&quot;, image-&gt;exif_lens);</a>
<a name="ln653">    if(svgdoc != svgdata)</a>
<a name="ln654">    {</a>
<a name="ln655">      g_free(svgdata);</a>
<a name="ln656">      svgdata = svgdoc;</a>
<a name="ln657">    }</a>
<a name="ln658"> </a>
<a name="ln659">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.FILENAME)&quot;, image-&gt;filename);</a>
<a name="ln660">    if(svgdoc != svgdata)</a>
<a name="ln661">    {</a>
<a name="ln662">      g_free(svgdata);</a>
<a name="ln663">      svgdata = svgdoc;</a>
<a name="ln664">    }</a>
<a name="ln665"> </a>
<a name="ln666">    gchar *basename = g_path_get_basename(image-&gt;filename);</a>
<a name="ln667">    if(g_strrstr(basename, &quot;.&quot;)) *(g_strrstr(basename, &quot;.&quot;)) = '\0';</a>
<a name="ln668">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.BASENAME)&quot;, basename);</a>
<a name="ln669">    if(svgdoc != svgdata)</a>
<a name="ln670">    {</a>
<a name="ln671">      g_free(svgdata);</a>
<a name="ln672">      svgdata = svgdoc;</a>
<a name="ln673">    }</a>
<a name="ln674">    g_free(basename);</a>
<a name="ln675"> </a>
<a name="ln676">    // TODO: auto generate that code?</a>
<a name="ln677">    GList *res;</a>
<a name="ln678">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.creator&quot;, NULL);</a>
<a name="ln679">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.creator)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln680">    if(svgdoc != svgdata)</a>
<a name="ln681">    {</a>
<a name="ln682">      g_free(svgdata);</a>
<a name="ln683">      svgdata = svgdoc;</a>
<a name="ln684">    }</a>
<a name="ln685">    if(res)</a>
<a name="ln686">    {</a>
<a name="ln687">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln688">    }</a>
<a name="ln689"> </a>
<a name="ln690">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.publisher&quot;, NULL);</a>
<a name="ln691">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.publisher)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln692">    if(svgdoc != svgdata)</a>
<a name="ln693">    {</a>
<a name="ln694">      g_free(svgdata);</a>
<a name="ln695">      svgdata = svgdoc;</a>
<a name="ln696">    }</a>
<a name="ln697">    if(res)</a>
<a name="ln698">    {</a>
<a name="ln699">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln700">    }</a>
<a name="ln701"> </a>
<a name="ln702">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.title&quot;, NULL);</a>
<a name="ln703">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.title)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln704">    if(svgdoc != svgdata)</a>
<a name="ln705">    {</a>
<a name="ln706">      g_free(svgdata);</a>
<a name="ln707">      svgdata = svgdoc;</a>
<a name="ln708">    }</a>
<a name="ln709">    if(res)</a>
<a name="ln710">    {</a>
<a name="ln711">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln712">    }</a>
<a name="ln713"> </a>
<a name="ln714">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.description&quot;, NULL);</a>
<a name="ln715">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.description)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln716">    if(svgdoc != svgdata)</a>
<a name="ln717">    {</a>
<a name="ln718">      g_free(svgdata);</a>
<a name="ln719">      svgdata = svgdoc;</a>
<a name="ln720">    }</a>
<a name="ln721">    if(res)</a>
<a name="ln722">    {</a>
<a name="ln723">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln724">    }</a>
<a name="ln725"> </a>
<a name="ln726">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.rights&quot;, NULL);</a>
<a name="ln727">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.rights)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln728">    if(svgdoc != svgdata)</a>
<a name="ln729">    {</a>
<a name="ln730">      g_free(svgdata);</a>
<a name="ln731">      svgdata = svgdoc;</a>
<a name="ln732">    }</a>
<a name="ln733">    if(res)</a>
<a name="ln734">    {</a>
<a name="ln735">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln736">    }</a>
<a name="ln737"> </a>
<a name="ln738">    res = dt_tag_get_list(image-&gt;id);</a>
<a name="ln739">    gchar *keywords = dt_util_glist_to_str(&quot;, &quot;, res);</a>
<a name="ln740">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.TAGS)&quot;, (keywords ? keywords : &quot;&quot;));</a>
<a name="ln741">    if(svgdoc != svgdata)</a>
<a name="ln742">    {</a>
<a name="ln743">      g_free(svgdata);</a>
<a name="ln744">      svgdata = svgdoc;</a>
<a name="ln745">    }</a>
<a name="ln746">    g_free(keywords);</a>
<a name="ln747">    if(res)</a>
<a name="ln748">    {</a>
<a name="ln749">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln750">    }</a>
<a name="ln751"> </a>
<a name="ln752">    const int stars = image-&gt;flags &amp; 0x7;</a>
<a name="ln753">    const char *const rating_str[] = { &quot;☆☆☆☆☆&quot;, &quot;★☆☆☆☆&quot;, &quot;★★☆☆☆&quot;, &quot;★★★☆☆&quot;, &quot;★★★★☆&quot;, &quot;★★★★★&quot;, &quot;❌&quot;, &quot;&quot; };</a>
<a name="ln754">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.xmp.Rating)&quot;, rating_str[stars]);</a>
<a name="ln755">    if(svgdoc != svgdata)</a>
<a name="ln756">    {</a>
<a name="ln757">      g_free(svgdata);</a>
<a name="ln758">      svgdata = svgdoc;</a>
<a name="ln759">    }</a>
<a name="ln760"> </a>
<a name="ln761">    // geolocation</a>
<a name="ln762">    gchar *latitude = NULL, *longitude = NULL, *elevation = NULL;</a>
<a name="ln763">    if(dt_conf_get_bool(&quot;plugins/lighttable/metadata_view/pretty_location&quot;))</a>
<a name="ln764">    {</a>
<a name="ln765">      latitude = dt_util_latitude_str(image-&gt;geoloc.latitude);</a>
<a name="ln766">      longitude = dt_util_longitude_str(image-&gt;geoloc.longitude);</a>
<a name="ln767">      elevation = dt_util_elevation_str(image-&gt;geoloc.elevation);</a>
<a name="ln768">    }</a>
<a name="ln769">    else</a>
<a name="ln770">    {</a>
<a name="ln771">      const gchar NS = image-&gt;geoloc.latitude &lt; 0 ? 'S' : 'N';</a>
<a name="ln772">      const gchar EW = image-&gt;geoloc.longitude &lt; 0 ? 'W' : 'E';</a>
<a name="ln773">      if(image-&gt;geoloc.latitude) latitude = g_strdup_printf(&quot;%c %09.6f&quot;, NS, fabs(image-&gt;geoloc.latitude));</a>
<a name="ln774">      if(image-&gt;geoloc.longitude) longitude = g_strdup_printf(&quot;%c %010.6f&quot;, EW, fabs(image-&gt;geoloc.longitude));</a>
<a name="ln775">      if(image-&gt;geoloc.elevation) elevation = g_strdup_printf(&quot;%.2f %s&quot;, image-&gt;geoloc.elevation, _(&quot;m&quot;));</a>
<a name="ln776">    }</a>
<a name="ln777">    gchar *parts[4] = { 0 };</a>
<a name="ln778">    int i = 0;</a>
<a name="ln779">    if(latitude) parts[i++] = latitude;</a>
<a name="ln780">    if(longitude) parts[i++] = longitude;</a>
<a name="ln781">    if(elevation) parts[i++] = elevation;</a>
<a name="ln782">    gchar *location = g_strjoinv(&quot;, &quot;, parts);</a>
<a name="ln783">    svgdoc = _string_substitute(svgdata, &quot;$(GPS.LATITUDE)&quot;, (latitude ? latitude : &quot;-&quot;));</a>
<a name="ln784">    if(svgdoc != svgdata)</a>
<a name="ln785">    {</a>
<a name="ln786">      g_free(svgdata);</a>
<a name="ln787">      svgdata = svgdoc;</a>
<a name="ln788">    }</a>
<a name="ln789">    svgdoc = _string_substitute(svgdata, &quot;$(GPS.LONGITUDE)&quot;, (longitude ? longitude : &quot;-&quot;));</a>
<a name="ln790">    if(svgdoc != svgdata)</a>
<a name="ln791">    {</a>
<a name="ln792">      g_free(svgdata);</a>
<a name="ln793">      svgdata = svgdoc;</a>
<a name="ln794">    }</a>
<a name="ln795">    svgdoc = _string_substitute(svgdata, &quot;$(GPS.ELEVATION)&quot;, (elevation ? elevation : &quot;-&quot;));</a>
<a name="ln796">    if(svgdoc != svgdata)</a>
<a name="ln797">    {</a>
<a name="ln798">      g_free(svgdata);</a>
<a name="ln799">      svgdata = svgdoc;</a>
<a name="ln800">    }</a>
<a name="ln801">    svgdoc = _string_substitute(svgdata, &quot;$(GPS.LOCATION)&quot;, location);</a>
<a name="ln802">    if(svgdoc != svgdata)</a>
<a name="ln803">    {</a>
<a name="ln804">      g_free(svgdata);</a>
<a name="ln805">      svgdata = svgdoc;</a>
<a name="ln806">    }</a>
<a name="ln807">    g_free(latitude);</a>
<a name="ln808">    g_free(longitude);</a>
<a name="ln809">    g_free(elevation);</a>
<a name="ln810">    g_free(location);</a>
<a name="ln811"> </a>
<a name="ln812">  }</a>
<a name="ln813">  return svgdoc;</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln817">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln818">{</a>
<a name="ln819">  dt_iop_watermark_data_t *data = (dt_iop_watermark_data_t *)piece-&gt;data;</a>
<a name="ln820">  float *in = (float *)ivoid;</a>
<a name="ln821">  float *out = (float *)ovoid;</a>
<a name="ln822">  const int ch = piece-&gt;colors;</a>
<a name="ln823">  const float angle = (M_PI / 180) * (-data-&gt;rotate);</a>
<a name="ln824"> </a>
<a name="ln825">  /* Load svg if not loaded */</a>
<a name="ln826">  gchar *svgdoc = _watermark_get_svgdoc(self, data, &amp;piece-&gt;pipe-&gt;image);</a>
<a name="ln827">  if(!svgdoc)</a>
<a name="ln828">  {</a>
<a name="ln829">    memcpy(ovoid, ivoid, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln830">    return;</a>
<a name="ln831">  }</a>
<a name="ln832"> </a>
<a name="ln833">  /* setup stride for performance */</a>
<a name="ln834">  int stride = cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, roi_out-&gt;width);</a>
<a name="ln835"> </a>
<a name="ln836">  /* create cairo memory surface */</a>
<a name="ln837">  guint8 *image = (guint8 *)g_malloc0_n(roi_out-&gt;height, stride);</a>
<a name="ln838">  cairo_surface_t *surface = cairo_image_surface_create_for_data(image, CAIRO_FORMAT_ARGB32, roi_out-&gt;width,</a>
<a name="ln839">                                                                 roi_out-&gt;height, stride);</a>
<a name="ln840">  if(cairo_surface_status(surface) != CAIRO_STATUS_SUCCESS)</a>
<a name="ln841">  {</a>
<a name="ln842">    //   fprintf(stderr,&quot;Cairo surface error: %s\n&quot;,cairo_status_to_string(cairo_surface_status(surface)));</a>
<a name="ln843">    g_free(image);</a>
<a name="ln844">    memcpy(ovoid, ivoid, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln845">    return;</a>
<a name="ln846">  }</a>
<a name="ln847"> </a>
<a name="ln848">  /* create cairo context and setup transformation/scale */</a>
<a name="ln849">  cairo_t *cr = cairo_create(surface);</a>
<a name="ln850"> </a>
<a name="ln851">  // rsvg (or some part of cairo which is used underneath) isn't thread safe, for example when handling fonts</a>
<a name="ln852">  dt_pthread_mutex_lock(&amp;darktable.plugin_threadsafe);</a>
<a name="ln853"> </a>
<a name="ln854">  /* create the rsvghandle from parsed svg data */</a>
<a name="ln855">  GError *error = NULL;</a>
<a name="ln856">  RsvgHandle *svg = rsvg_handle_new_from_data((const guint8 *)svgdoc, strlen(svgdoc), &amp;error);</a>
<a name="ln857">  g_free(svgdoc);</a>
<a name="ln858">  if(!svg || error)</a>
<a name="ln859">  {</a>
<a name="ln860">    g_free(image);</a>
<a name="ln861">    memcpy(ovoid, ivoid, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln862">    dt_pthread_mutex_unlock(&amp;darktable.plugin_threadsafe);</a>
<a name="ln863">    fprintf(stderr, &quot;[watermark] error processing svg file: %s\n&quot;, error-&gt;message);</a>
<a name="ln864">    g_error_free(error);</a>
<a name="ln865">    return;</a>
<a name="ln866">  }</a>
<a name="ln867"> </a>
<a name="ln868">  /* get the dimension of svg */</a>
<a name="ln869">  RsvgDimensionData dimension;</a>
<a name="ln870">  rsvg_handle_get_dimensions(svg, &amp;dimension);</a>
<a name="ln871"> </a>
<a name="ln872">  //  width/height of current (possibly cropped) image</a>
<a name="ln873">  const float iw = piece-&gt;buf_in.width;</a>
<a name="ln874">  const float ih = piece-&gt;buf_in.height;</a>
<a name="ln875">  const float uscale = data-&gt;scale / 100.0f; // user scale, from GUI in percent</a>
<a name="ln876"> </a>
<a name="ln877">  // wbase, hbase are the base width and height, this is the multiplicator used for the offset computing</a>
<a name="ln878">  // scale is the scale of the watermark itself and is used only to render it.</a>
<a name="ln879"> </a>
<a name="ln880">  float wbase, hbase, scale;</a>
<a name="ln881"> </a>
<a name="ln882">  if(data-&gt;sizeto == DT_SCALE_IMAGE)</a>
<a name="ln883">  {</a>
<a name="ln884">    // in image mode, the wbase and hbase are just the image width and height</a>
<a name="ln885">    wbase = iw;</a>
<a name="ln886">    hbase = ih;</a>
<a name="ln887">    if(dimension.width &gt; dimension.height)</a>
<a name="ln888">      scale = (iw * roi_out-&gt;scale) / dimension.width;</a>
<a name="ln889">    else</a>
<a name="ln890">      scale = (ih * roi_out-&gt;scale) / dimension.height;</a>
<a name="ln891">  }</a>
<a name="ln892">  else</a>
<a name="ln893">  {</a>
<a name="ln894">    // in larger/smaller side mode, set wbase and hbase to the largest or smallest side of the image</a>
<a name="ln895">    float larger;</a>
<a name="ln896">    if(dimension.width &gt; dimension.height)</a>
<a name="ln897">      larger = (float)dimension.width;</a>
<a name="ln898">    else</a>
<a name="ln899">      larger = (float)dimension.height;</a>
<a name="ln900"> </a>
<a name="ln901">    if(iw &gt; ih)</a>
<a name="ln902">    {</a>
<a name="ln903">      wbase = hbase = (data-&gt;sizeto == DT_SCALE_LARGER_BORDER) ? iw : ih;</a>
<a name="ln904">      scale = (data-&gt;sizeto == DT_SCALE_LARGER_BORDER) ? (iw / larger) : (ih / larger);</a>
<a name="ln905">    }</a>
<a name="ln906">    else</a>
<a name="ln907">    {</a>
<a name="ln908">      wbase = hbase = (data-&gt;sizeto == DT_SCALE_SMALLER_BORDER) ? iw : ih;</a>
<a name="ln909">      scale = (data-&gt;sizeto == DT_SCALE_SMALLER_BORDER) ? (iw / larger) : (ih / larger);</a>
<a name="ln910">    }</a>
<a name="ln911">    scale *= roi_out-&gt;scale;</a>
<a name="ln912">  }</a>
<a name="ln913"> </a>
<a name="ln914">  scale *= uscale;</a>
<a name="ln915"> </a>
<a name="ln916">  // compute the width and height of the SVG object in image dimension. This is only used to properly</a>
<a name="ln917">  // layout the watermark based on the alignment.</a>
<a name="ln918"> </a>
<a name="ln919">  float svg_width, svg_height;</a>
<a name="ln920"> </a>
<a name="ln921">  if(dimension.width &gt; dimension.height)</a>
<a name="ln922">  {</a>
<a name="ln923">    if(data-&gt;sizeto == DT_SCALE_IMAGE || (iw &gt; ih &amp;&amp; data-&gt;sizeto == DT_SCALE_LARGER_BORDER)</a>
<a name="ln924">       || (iw &lt; ih &amp;&amp; data-&gt;sizeto == DT_SCALE_SMALLER_BORDER))</a>
<a name="ln925">    {</a>
<a name="ln926">      svg_width = iw * uscale;</a>
<a name="ln927">      svg_height = dimension.height * (svg_width / dimension.width);</a>
<a name="ln928">    }</a>
<a name="ln929">    else</a>
<a name="ln930">    {</a>
<a name="ln931">      svg_width = ih * uscale;</a>
<a name="ln932">      svg_height = dimension.height * (svg_width / dimension.width);</a>
<a name="ln933">    }</a>
<a name="ln934">  }</a>
<a name="ln935">  else</a>
<a name="ln936">  {</a>
<a name="ln937">    if(data-&gt;sizeto == DT_SCALE_IMAGE || (ih &gt; iw &amp;&amp; data-&gt;sizeto == DT_SCALE_LARGER_BORDER)</a>
<a name="ln938">       || (ih &lt; iw &amp;&amp; data-&gt;sizeto == DT_SCALE_SMALLER_BORDER))</a>
<a name="ln939">    {</a>
<a name="ln940">      svg_height = ih * uscale;</a>
<a name="ln941">      svg_width = dimension.width * (svg_height / dimension.height);</a>
<a name="ln942">    }</a>
<a name="ln943">    else</a>
<a name="ln944">    {</a>
<a name="ln945">      svg_height = iw * uscale;</a>
<a name="ln946">      svg_width = dimension.width * (svg_height / dimension.height);</a>
<a name="ln947">    }</a>
<a name="ln948">  }</a>
<a name="ln949"> </a>
<a name="ln950">  // compute bounding box of rotated watermark</a>
<a name="ln951">  const float bb_width = fabsf(svg_width * cosf(angle)) + fabsf(svg_height * sinf(angle));</a>
<a name="ln952">  const float bb_height = fabsf(svg_width * sinf(angle)) + fabsf(svg_height * cosf(angle));</a>
<a name="ln953">  const float bX = bb_width / 2.0f - svg_width / 2.0f;</a>
<a name="ln954">  const float bY = bb_height / 2.0f - svg_height / 2.0f;</a>
<a name="ln955"> </a>
<a name="ln956">  // compute translation for the given alignment in image dimension</a>
<a name="ln957"> </a>
<a name="ln958">  float ty = 0, tx = 0;</a>
<a name="ln959">  if(data-&gt;alignment &gt;= 0 &amp;&amp; data-&gt;alignment &lt; 3) // Align to verttop</a>
<a name="ln960">    ty = bY;</a>
<a name="ln961">  else if(data-&gt;alignment &gt;= 3 &amp;&amp; data-&gt;alignment &lt; 6) // Align to vertcenter</a>
<a name="ln962">    ty = (ih / 2.0f) - (svg_height / 2.0f);</a>
<a name="ln963">  else if(data-&gt;alignment &gt;= 6 &amp;&amp; data-&gt;alignment &lt; 9) // Align to vertbottom</a>
<a name="ln964">    ty = ih - svg_height - bY;</a>
<a name="ln965"> </a>
<a name="ln966">  if(data-&gt;alignment == 0 || data-&gt;alignment == 3 || data-&gt;alignment == 6)</a>
<a name="ln967">    tx = bX;</a>
<a name="ln968">  else if(data-&gt;alignment == 1 || data-&gt;alignment == 4 || data-&gt;alignment == 7)</a>
<a name="ln969">    tx = (iw / 2.0f) - (svg_width / 2.0f);</a>
<a name="ln970">  else if(data-&gt;alignment == 2 || data-&gt;alignment == 5 || data-&gt;alignment == 8)</a>
<a name="ln971">    tx = iw - svg_width - bX;</a>
<a name="ln972"> </a>
<a name="ln973">  // translate to position</a>
<a name="ln974">  cairo_translate(cr, -roi_in-&gt;x, -roi_in-&gt;y);</a>
<a name="ln975"> </a>
<a name="ln976">  // add translation for the given value in GUI (xoffset,yoffset)</a>
<a name="ln977">  tx += data-&gt;xoffset * wbase;</a>
<a name="ln978">  ty += data-&gt;yoffset * hbase;</a>
<a name="ln979"> </a>
<a name="ln980">  cairo_translate(cr, tx * roi_out-&gt;scale, ty * roi_out-&gt;scale);</a>
<a name="ln981"> </a>
<a name="ln982">  // compute the center of the svg to rotate from the center</a>
<a name="ln983">  const float cX = svg_width / 2.0f * roi_out-&gt;scale;</a>
<a name="ln984">  const float cY = svg_height / 2.0f * roi_out-&gt;scale;</a>
<a name="ln985"> </a>
<a name="ln986">  cairo_translate(cr, cX, cY);</a>
<a name="ln987">  cairo_rotate(cr, angle);</a>
<a name="ln988">  cairo_translate(cr, -cX, -cY);</a>
<a name="ln989"> </a>
<a name="ln990">  // now set proper scale for the watermark itself</a>
<a name="ln991">  cairo_scale(cr, scale, scale);</a>
<a name="ln992"> </a>
<a name="ln993">  /* render svg into surface*/</a>
<a name="ln994">  rsvg_handle_render_cairo(svg, cr);</a>
<a name="ln995"> </a>
<a name="ln996">  // no more non-thread safe rsvg usage</a>
<a name="ln997">  dt_pthread_mutex_unlock(&amp;darktable.plugin_threadsafe);</a>
<a name="ln998"> </a>
<a name="ln999">  cairo_destroy(cr);</a>
<a name="ln1000"> </a>
<a name="ln1001">  /* ensure that all operations on surface finishing up */</a>
<a name="ln1002">  cairo_surface_flush(surface);</a>
<a name="ln1003"> </a>
<a name="ln1004">  /* render surface on output */</a>
<a name="ln1005">  guint8 *sd = image;</a>
<a name="ln1006">  const float opacity = data-&gt;opacity / 100.0f;</a>
<a name="ln1007">  /*</a>
<a name="ln1008">  #ifdef _OPENMP</a>
<a name="ln1009">    #pragma omp parallel for default(none) shared(in, out,sd,opacity) schedule(static)</a>
<a name="ln1010">  #endif</a>
<a name="ln1011">  */</a>
<a name="ln1012">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln1013">    for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln1014">    {</a>
<a name="ln1015">      const float alpha = (sd[3] / 255.0f) * opacity;</a>
<a name="ln1016">      /* svg uses a premultiplied alpha, so only use opacity for the blending */</a>
<a name="ln1017">      out[0] = ((1.0f - alpha) * in[0]) + (opacity * (sd[2] / 255.0f));</a>
<a name="ln1018">      out[1] = ((1.0f - alpha) * in[1]) + (opacity * (sd[1] / 255.0f));</a>
<a name="ln1019">      out[2] = ((1.0f - alpha) * in[2]) + (opacity * (sd[0] / 255.0f));</a>
<a name="ln1020">      out[3] = in[3];</a>
<a name="ln1021"> </a>
<a name="ln1022">      out += ch;</a>
<a name="ln1023">      in += ch;</a>
<a name="ln1024">      sd += 4;</a>
<a name="ln1025">    }</a>
<a name="ln1026"> </a>
<a name="ln1027"> </a>
<a name="ln1028">  /* clean up */</a>
<a name="ln1029">  cairo_surface_destroy(surface);</a>
<a name="ln1030">  g_object_unref(svg);</a>
<a name="ln1031">  g_free(image);</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034">static void watermark_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln1035">{</a>
<a name="ln1036">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1037">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1038"> </a>
<a name="ln1039">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1040">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1041">  memset(p-&gt;filename, 0, sizeof(p-&gt;filename));</a>
<a name="ln1042">  int n = dt_bauhaus_combobox_get(g-&gt;watermarks);</a>
<a name="ln1043">  snprintf(p-&gt;filename, sizeof(p-&gt;filename), &quot;%s&quot;, (char *)g_list_nth_data(g-&gt;watermarks_filenames, n));</a>
<a name="ln1044">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">static void _iop_color_picker_apply(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1048">{</a>
<a name="ln1049">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1050">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1051"> </a>
<a name="ln1052">  if(fabsf(p-&gt;color[0] - self-&gt;picked_color[0]) &lt; 0.0001f</a>
<a name="ln1053">     &amp;&amp; fabsf(p-&gt;color[1] - self-&gt;picked_color[1]) &lt; 0.0001f</a>
<a name="ln1054">     &amp;&amp; fabsf(p-&gt;color[2] - self-&gt;picked_color[2]) &lt; 0.0001f)</a>
<a name="ln1055">  {</a>
<a name="ln1056">    // interrupt infinite loops</a>
<a name="ln1057">    return;</a>
<a name="ln1058">  }</a>
<a name="ln1059"> </a>
<a name="ln1060">  GdkRGBA c = {.red   = self-&gt;picked_color[0],</a>
<a name="ln1061">               .green = self-&gt;picked_color[1],</a>
<a name="ln1062">               .blue  = self-&gt;picked_color[2],</a>
<a name="ln1063">               .alpha = 1.0 };</a>
<a name="ln1064"> </a>
<a name="ln1065">  p-&gt;color[0] = self-&gt;picked_color[0];</a>
<a name="ln1066">  p-&gt;color[1] = self-&gt;picked_color[1];</a>
<a name="ln1067">  p-&gt;color[2] = self-&gt;picked_color[2];</a>
<a name="ln1068">  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g-&gt;colorpick), &amp;c);</a>
<a name="ln1069"> </a>
<a name="ln1070">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1071">}</a>
<a name="ln1072"> </a>
<a name="ln1073">static void load_watermarks(const char *basedir, dt_iop_watermark_gui_data_t *g)</a>
<a name="ln1074">{</a>
<a name="ln1075">  GList *files = NULL;</a>
<a name="ln1076">  char *watermarks_dir = g_build_filename(basedir, &quot;watermarks&quot;, NULL);</a>
<a name="ln1077">  GDir *dir = g_dir_open(watermarks_dir, 0, NULL);</a>
<a name="ln1078">  if(dir)</a>
<a name="ln1079">  {</a>
<a name="ln1080">    const gchar *d_name;</a>
<a name="ln1081">    while((d_name = g_dir_read_name(dir)))</a>
<a name="ln1082">      files = g_list_append(files, g_strdup(d_name));</a>
<a name="ln1083">    g_dir_close(dir);</a>
<a name="ln1084">  }</a>
<a name="ln1085"> </a>
<a name="ln1086">  files = g_list_sort(files, (GCompareFunc)g_strcmp0);</a>
<a name="ln1087">  for(GList *iter = files; iter; iter = g_list_next(iter))</a>
<a name="ln1088">  {</a>
<a name="ln1089">    char *filename = iter-&gt;data;</a>
<a name="ln1090">    // remember the whole filename for later</a>
<a name="ln1091">    g-&gt;watermarks_filenames = g_list_append(g-&gt;watermarks_filenames, g_strdup(filename));</a>
<a name="ln1092">    // ... and remove the file extension from the string shown in the gui</a>
<a name="ln1093">    char *c = filename + strlen(filename);</a>
<a name="ln1094">    while(c &gt;= filename &amp;&amp; *c != '.') *c-- = '\0';</a>
<a name="ln1095">    if(*c == '.') *c = '\0';</a>
<a name="ln1096">    dt_bauhaus_combobox_add(g-&gt;watermarks, filename);</a>
<a name="ln1097">  }</a>
<a name="ln1098"> </a>
<a name="ln1099">  g_list_free_full(files, g_free);</a>
<a name="ln1100">  g_free(watermarks_dir);</a>
<a name="ln1101">}</a>
<a name="ln1102"> </a>
<a name="ln1103">static void refresh_watermarks(dt_iop_module_t *self)</a>
<a name="ln1104">{</a>
<a name="ln1105">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1106">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1107"> </a>
<a name="ln1108">  g_signal_handlers_block_by_func(g-&gt;watermarks, watermark_callback, self);</a>
<a name="ln1109"> </a>
<a name="ln1110">  // Clear combobox...</a>
<a name="ln1111">  dt_bauhaus_combobox_clear(g-&gt;watermarks);</a>
<a name="ln1112">  g_list_free_full(g-&gt;watermarks_filenames, g_free);</a>
<a name="ln1113">  g-&gt;watermarks_filenames = NULL;</a>
<a name="ln1114"> </a>
<a name="ln1115">  // check watermarkdir and update combo with entries...</a>
<a name="ln1116">  gchar configdir[PATH_MAX] = { 0 };</a>
<a name="ln1117">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln1118">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln1119">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln1120"> </a>
<a name="ln1121">  load_watermarks(datadir, g);</a>
<a name="ln1122">  load_watermarks(configdir, g);</a>
<a name="ln1123"> </a>
<a name="ln1124">  _combo_box_set_active_text(g, p-&gt;filename);</a>
<a name="ln1125"> </a>
<a name="ln1126">  g_signal_handlers_unblock_by_func(g-&gt;watermarks, watermark_callback, self);</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129">static void refresh_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln1130">{</a>
<a name="ln1131">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1132">  refresh_watermarks(self);</a>
<a name="ln1133">}</a>
<a name="ln1134"> </a>
<a name="ln1135"> </a>
<a name="ln1136"> </a>
<a name="ln1137">static void alignment_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln1138">{</a>
<a name="ln1139">  int index = -1;</a>
<a name="ln1140">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1141">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1142"> </a>
<a name="ln1143">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1144">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1145"> </a>
<a name="ln1146"> </a>
<a name="ln1147">  for(int i = 0; i &lt; 9; i++)</a>
<a name="ln1148">  {</a>
<a name="ln1149">    /* block signal handler */</a>
<a name="ln1150">    g_signal_handlers_block_by_func(g-&gt;align[i], alignment_callback, user_data);</a>
<a name="ln1151"> </a>
<a name="ln1152">    if(GTK_WIDGET(g-&gt;align[i]) == tb)</a>
<a name="ln1153">    {</a>
<a name="ln1154">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;align[i]), TRUE);</a>
<a name="ln1155">      index = i;</a>
<a name="ln1156">    }</a>
<a name="ln1157">    else</a>
<a name="ln1158">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;align[i]), FALSE);</a>
<a name="ln1159"> </a>
<a name="ln1160">    /* unblock signal handler */</a>
<a name="ln1161">    g_signal_handlers_unblock_by_func(g-&gt;align[i], alignment_callback, user_data);</a>
<a name="ln1162">  }</a>
<a name="ln1163">  p-&gt;alignment = index;</a>
<a name="ln1164">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1165">}</a>
<a name="ln1166"> </a>
<a name="ln1167">static void opacity_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1168">{</a>
<a name="ln1169">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1170">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1171">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1172">  p-&gt;opacity = dt_bauhaus_slider_get(slider);</a>
<a name="ln1173">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1174">}</a>
<a name="ln1175"> </a>
<a name="ln1176">static void text_callback(GtkWidget *entry, gpointer user_data)</a>
<a name="ln1177">{</a>
<a name="ln1178">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1179">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1180">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1181">  snprintf(p-&gt;text, sizeof(p-&gt;text), &quot;%s&quot;, gtk_entry_get_text(GTK_ENTRY(entry)));</a>
<a name="ln1182">  dt_conf_set_string(&quot;plugins/darkroom/watermark/text&quot;, p-&gt;text);</a>
<a name="ln1183">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186">static void colorpick_color_set(GtkColorButton *widget, gpointer user_data)</a>
<a name="ln1187">{</a>
<a name="ln1188">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1189">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1190">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1191"> </a>
<a name="ln1192">  GdkRGBA c;</a>
<a name="ln1193">  gtk_color_chooser_get_rgba(GTK_COLOR_CHOOSER(widget), &amp;c);</a>
<a name="ln1194">  p-&gt;color[0] = c.red;</a>
<a name="ln1195">  p-&gt;color[1] = c.green;</a>
<a name="ln1196">  p-&gt;color[2] = c.blue;</a>
<a name="ln1197"> </a>
<a name="ln1198">  dt_conf_set_float(&quot;plugins/darkroom/watermark/color_red&quot;, p-&gt;color[0]);</a>
<a name="ln1199">  dt_conf_set_float(&quot;plugins/darkroom/watermark/color_green&quot;, p-&gt;color[1]);</a>
<a name="ln1200">  dt_conf_set_float(&quot;plugins/darkroom/watermark/color_blue&quot;, p-&gt;color[2]);</a>
<a name="ln1201">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1202">}</a>
<a name="ln1203"> </a>
<a name="ln1204">static void fontsel_callback(GtkWidget *button, gpointer user_data)</a>
<a name="ln1205">{</a>
<a name="ln1206">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1207">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1208">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1209"> </a>
<a name="ln1210">  snprintf(p-&gt;font, sizeof(p-&gt;font), &quot;%s&quot;, gtk_font_button_get_font_name(GTK_FONT_BUTTON(button)));</a>
<a name="ln1211">  dt_conf_set_string(&quot;plugins/darkroom/watermark/font&quot;, p-&gt;font);</a>
<a name="ln1212">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1213">}</a>
<a name="ln1214"> </a>
<a name="ln1215">static void xoffset_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1216">{</a>
<a name="ln1217">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1218">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1219">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1220">  p-&gt;xoffset = dt_bauhaus_slider_get(slider);</a>
<a name="ln1221">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">static void yoffset_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1225">{</a>
<a name="ln1226">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1227">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1228">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1229">  p-&gt;yoffset = dt_bauhaus_slider_get(slider);</a>
<a name="ln1230">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1231">}</a>
<a name="ln1232"> </a>
<a name="ln1233">static void scale_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1234">{</a>
<a name="ln1235">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1236">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1237">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1238">  p-&gt;scale = dt_bauhaus_slider_get(slider);</a>
<a name="ln1239">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1240">}</a>
<a name="ln1241"> </a>
<a name="ln1242">static void rotate_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1243">{</a>
<a name="ln1244">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1245">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1246">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1247">  p-&gt;rotate = dt_bauhaus_slider_get(slider);</a>
<a name="ln1248">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1249">}</a>
<a name="ln1250"> </a>
<a name="ln1251">static void sizeto_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln1252">{</a>
<a name="ln1253">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1254"> </a>
<a name="ln1255">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln1256">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1257">  p-&gt;sizeto = dt_bauhaus_combobox_get(tb);</a>
<a name="ln1258">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1259">}</a>
<a name="ln1260"> </a>
<a name="ln1261">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln1262">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1263">{</a>
<a name="ln1264">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)p1;</a>
<a name="ln1265">  dt_iop_watermark_data_t *d = (dt_iop_watermark_data_t *)piece-&gt;data;</a>
<a name="ln1266"> </a>
<a name="ln1267">  d-&gt;opacity = p-&gt;opacity;</a>
<a name="ln1268">  d-&gt;scale = p-&gt;scale;</a>
<a name="ln1269">  d-&gt;rotate = p-&gt;rotate;</a>
<a name="ln1270">  d-&gt;xoffset = p-&gt;xoffset;</a>
<a name="ln1271">  d-&gt;yoffset = p-&gt;yoffset;</a>
<a name="ln1272">  d-&gt;alignment = p-&gt;alignment;</a>
<a name="ln1273">  d-&gt;sizeto = p-&gt;sizeto;</a>
<a name="ln1274">  memset(d-&gt;filename, 0, sizeof(d-&gt;filename));</a>
<a name="ln1275">  snprintf(d-&gt;filename, sizeof(d-&gt;filename), &quot;%s&quot;, p-&gt;filename);</a>
<a name="ln1276">  memset(d-&gt;text, 0, sizeof(d-&gt;text));</a>
<a name="ln1277">  snprintf(d-&gt;text, sizeof(d-&gt;text), &quot;%s&quot;, p-&gt;text);</a>
<a name="ln1278">  for (int k=0; k&lt;3; k++)</a>
<a name="ln1279">    d-&gt;color[k] = p-&gt;color[k];</a>
<a name="ln1280">  memset(d-&gt;font, 0, sizeof(d-&gt;font));</a>
<a name="ln1281">  snprintf(d-&gt;font, sizeof(d-&gt;font), &quot;%s&quot;, p-&gt;font);</a>
<a name="ln1282"> </a>
<a name="ln1283">// fprintf(stderr,&quot;Commit params: %s...\n&quot;,d-&gt;filename);</a>
<a name="ln1284">}</a>
<a name="ln1285"> </a>
<a name="ln1286">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1287">{</a>
<a name="ln1288">  piece-&gt;data = malloc(sizeof(dt_iop_watermark_data_t));</a>
<a name="ln1289">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln1290">}</a>
<a name="ln1291"> </a>
<a name="ln1292">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1293">{</a>
<a name="ln1294">  free(piece-&gt;data);</a>
<a name="ln1295">  piece-&gt;data = NULL;</a>
<a name="ln1296">}</a>
<a name="ln1297"> </a>
<a name="ln1298"> </a>
<a name="ln1299">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln1300">{</a>
<a name="ln1301">  dt_iop_module_t *module = (dt_iop_module_t *)self;</a>
<a name="ln1302">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1303">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)module-&gt;params;</a>
<a name="ln1304">  dt_bauhaus_slider_set(g-&gt;opacity, p-&gt;opacity);</a>
<a name="ln1305">  dt_bauhaus_slider_set_soft(g-&gt;scale, p-&gt;scale);</a>
<a name="ln1306">  dt_bauhaus_slider_set(g-&gt;rotate, p-&gt;rotate);</a>
<a name="ln1307">  dt_bauhaus_slider_set(g-&gt;x_offset, p-&gt;xoffset);</a>
<a name="ln1308">  dt_bauhaus_slider_set(g-&gt;y_offset, p-&gt;yoffset);</a>
<a name="ln1309">  for(int i = 0; i &lt; 9; i++)</a>
<a name="ln1310">  {</a>
<a name="ln1311">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;align[i]), FALSE);</a>
<a name="ln1312">  }</a>
<a name="ln1313">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;align[p-&gt;alignment]), TRUE);</a>
<a name="ln1314">  _combo_box_set_active_text(g, p-&gt;filename);</a>
<a name="ln1315">  dt_bauhaus_combobox_set(g-&gt;sizeto, p-&gt;sizeto);</a>
<a name="ln1316">  gtk_entry_set_text(GTK_ENTRY(g-&gt;text), p-&gt;text);</a>
<a name="ln1317">  GdkRGBA color = (GdkRGBA){.red = p-&gt;color[0], .green = p-&gt;color[1], .blue = p-&gt;color[2], .alpha = 1.0 };</a>
<a name="ln1318">  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g-&gt;colorpick), &amp;color);</a>
<a name="ln1319">  gtk_font_button_set_font_name(GTK_FONT_BUTTON(g-&gt;fontsel), p-&gt;font);</a>
<a name="ln1320">}</a>
<a name="ln1321"> </a>
<a name="ln1322">void init(dt_iop_module_t *module)</a>
<a name="ln1323">{</a>
<a name="ln1324">  module-&gt;params = calloc(1, sizeof(dt_iop_watermark_params_t));</a>
<a name="ln1325">  module-&gt;params_size = sizeof(dt_iop_watermark_params_t);</a>
<a name="ln1326">  module-&gt;default_params = calloc(1, sizeof(dt_iop_watermark_params_t));</a>
<a name="ln1327">  module-&gt;default_enabled = 0;</a>
<a name="ln1328">  module-&gt;gui_data = NULL;</a>
<a name="ln1329">  dt_iop_watermark_params_t tmp = {</a>
<a name="ln1330">    100.0, 100.0, 0.0, 0.0, 4, 0.0, DT_SCALE_IMAGE, { &quot;darktable.svg&quot; }, { &quot;&quot; }, {0.0, 0.0, 0.0}, {&quot;DejaVu Sans 10&quot;}</a>
<a name="ln1331">  }; // opacity,scale,xoffs,yoffs,alignment</a>
<a name="ln1332">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_watermark_params_t));</a>
<a name="ln1333">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_watermark_params_t));</a>
<a name="ln1334">}</a>
<a name="ln1335"> </a>
<a name="ln1336">void cleanup(dt_iop_module_t *module)</a>
<a name="ln1337">{</a>
<a name="ln1338">  free(module-&gt;params);</a>
<a name="ln1339">  module-&gt;params = NULL;</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln1343">{</a>
<a name="ln1344">  self-&gt;gui_data = calloc(1, sizeof(dt_iop_watermark_gui_data_t));</a>
<a name="ln1345">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1346">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1347"> </a>
<a name="ln1348">  int line = 0;</a>
<a name="ln1349">  self-&gt;widget = gtk_grid_new();</a>
<a name="ln1350">  gtk_grid_set_row_spacing(GTK_GRID(self-&gt;widget), DT_BAUHAUS_SPACE);</a>
<a name="ln1351">  gtk_grid_set_column_spacing(GTK_GRID(self-&gt;widget), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln1352">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln1353"> </a>
<a name="ln1354">  gtk_grid_attach(GTK_GRID(self-&gt;widget), dt_ui_section_label_new(_(&quot;content&quot;)), 0, line++, 3, 1);</a>
<a name="ln1355"> </a>
<a name="ln1356">  // Add the marker combobox</a>
<a name="ln1357">  gchar configdir[PATH_MAX] = { 0 };</a>
<a name="ln1358">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln1359">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln1360">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln1361">  GtkWidget *label = dtgtk_reset_label_new(_(&quot;marker&quot;), self, &amp;p-&gt;filename, sizeof(p-&gt;filename));</a>
<a name="ln1362">  g-&gt;watermarks = dt_bauhaus_combobox_new(self);</a>
<a name="ln1363">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;watermarks), TRUE);</a>
<a name="ln1364">  char *tooltip = g_strdup_printf(_(&quot;SVG watermarks in %s/watermarks or %s/watermarks&quot;), configdir, datadir);</a>
<a name="ln1365">  gtk_widget_set_tooltip_text(g-&gt;watermarks, tooltip);</a>
<a name="ln1366">  g_free(tooltip);</a>
<a name="ln1367">  g-&gt;refresh = dtgtk_button_new(dtgtk_cairo_paint_refresh, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1368">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1369">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), g-&gt;watermarks, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1370">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), g-&gt;refresh, g-&gt;watermarks, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1371"> </a>
<a name="ln1372"> </a>
<a name="ln1373">  // Watermark color</a>
<a name="ln1374">  float red = dt_conf_get_float(&quot;plugins/darkroom/watermark/color_red&quot;);</a>
<a name="ln1375">  float green = dt_conf_get_float(&quot;plugins/darkroom/watermark/color_green&quot;);</a>
<a name="ln1376">  float blue = dt_conf_get_float(&quot;plugins/darkroom/watermark/color_blue&quot;);</a>
<a name="ln1377">  GdkRGBA color = (GdkRGBA){.red = red, .green = green, .blue = blue, .alpha = 1.0 };</a>
<a name="ln1378"> </a>
<a name="ln1379">  GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1380"> </a>
<a name="ln1381">  label = dtgtk_reset_label_new(_(&quot;color&quot;), self, &amp;p-&gt;color, 3 * sizeof(float));</a>
<a name="ln1382">  g-&gt;colorpick = gtk_color_button_new_with_rgba(&amp;color);</a>
<a name="ln1383">  gtk_widget_set_tooltip_text(g-&gt;colorpick, _(&quot;watermark color, tag:\n$(WATERMARK_COLOR)&quot;));</a>
<a name="ln1384">  gtk_color_chooser_set_use_alpha(GTK_COLOR_CHOOSER(g-&gt;colorpick), FALSE);</a>
<a name="ln1385">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;colorpick), DT_PIXEL_APPLY_DPI(24), DT_PIXEL_APPLY_DPI(24));</a>
<a name="ln1386">  gtk_color_button_set_title(GTK_COLOR_BUTTON(g-&gt;colorpick), _(&quot;select watermark color&quot;));</a>
<a name="ln1387"> </a>
<a name="ln1388">  g-&gt;color_picker_button = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT, NULL));</a>
<a name="ln1389">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;color_picker_button), _(&quot;pick color from image&quot;));</a>
<a name="ln1390">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;color_picker_button), DT_PIXEL_APPLY_DPI(24), DT_PIXEL_APPLY_DPI(24));</a>
<a name="ln1391">  g_signal_connect(G_OBJECT(g-&gt;color_picker_button), &quot;toggled&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln1392"> </a>
<a name="ln1393">  gtk_box_pack_start(GTK_BOX(box), g-&gt;colorpick, TRUE, TRUE, 0);</a>
<a name="ln1394">  gtk_box_pack_start(GTK_BOX(box), GTK_WIDGET(g-&gt;color_picker_button), FALSE, TRUE, 0);</a>
<a name="ln1395"> </a>
<a name="ln1396">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1397">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), box, label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1398"> </a>
<a name="ln1399">  // Simple text</a>
<a name="ln1400">  label = gtk_label_new(_(&quot;text&quot;));</a>
<a name="ln1401">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1402">  g-&gt;text = gtk_entry_new();</a>
<a name="ln1403">  gtk_entry_set_width_chars(GTK_ENTRY(g-&gt;text), 1);</a>
<a name="ln1404">  gtk_widget_set_tooltip_text(g-&gt;text, _(&quot;text string, tag:\n$(WATERMARK_TEXT)&quot;));</a>
<a name="ln1405">  dt_gui_key_accel_block_on_focus_connect(g-&gt;text);</a>
<a name="ln1406">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1407">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), g-&gt;text, label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1408"> </a>
<a name="ln1409">  gchar *str = dt_conf_get_string(&quot;plugins/darkroom/watermark/text&quot;);</a>
<a name="ln1410">  gtk_entry_set_text(GTK_ENTRY(g-&gt;text), str);</a>
<a name="ln1411">  g_free(str);</a>
<a name="ln1412"> </a>
<a name="ln1413">  // Text font</a>
<a name="ln1414">  label = dtgtk_reset_label_new(_(&quot;font&quot;), self, &amp;p-&gt;font, sizeof(p-&gt;font));</a>
<a name="ln1415">  str = dt_conf_get_string(&quot;plugins/darkroom/watermark/font&quot;);</a>
<a name="ln1416">  g-&gt;fontsel = gtk_font_button_new_with_font(str==NULL?&quot;DejaVu Sans 10&quot;:str);</a>
<a name="ln1417">  GList *childs = gtk_container_get_children(GTK_CONTAINER(gtk_bin_get_child(GTK_BIN(g-&gt;fontsel))));</a>
<a name="ln1418">  gtk_label_set_ellipsize(GTK_LABEL(childs-&gt;data), PANGO_ELLIPSIZE_MIDDLE);</a>
<a name="ln1419">  g_list_free(childs);</a>
<a name="ln1420">  gtk_widget_set_tooltip_text(g-&gt;fontsel, _(&quot;text font, tags:\n$(WATERMARK_FONT_FAMILY)\n&quot;</a>
<a name="ln1421">                                            &quot;$(WATERMARK_FONT_STYLE)\n$(WATERMARK_FONT_WEIGHT)&quot;));</a>
<a name="ln1422">  gtk_font_button_set_show_size (GTK_FONT_BUTTON(g-&gt;fontsel), FALSE);</a>
<a name="ln1423">  g_free(str);</a>
<a name="ln1424">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1425">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), g-&gt;fontsel, label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1426"> </a>
<a name="ln1427">  gtk_grid_attach(GTK_GRID(self-&gt;widget), dt_ui_section_label_new(_(&quot;properties&quot;)), 0, line++, 3, 1);</a>
<a name="ln1428"> </a>
<a name="ln1429">  // Add opacity/scale sliders to table</a>
<a name="ln1430">  g-&gt;opacity = dt_bauhaus_slider_new_with_range(self, 0.0, 100.0, 1.0, p-&gt;opacity, 0);</a>
<a name="ln1431">  dt_bauhaus_slider_set_format(g-&gt;opacity, &quot;%.f%%&quot;);</a>
<a name="ln1432">  dt_bauhaus_widget_set_label(g-&gt;opacity, NULL, _(&quot;opacity&quot;));</a>
<a name="ln1433">  g-&gt;scale = dt_bauhaus_slider_new_with_range(self, 1.0, 100.0, 1.0, p-&gt;scale, 0);</a>
<a name="ln1434">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;scale, 1.0, 500.0);</a>
<a name="ln1435">  dt_bauhaus_slider_set_format(g-&gt;scale, &quot;%.f%%&quot;);</a>
<a name="ln1436">  dt_bauhaus_widget_set_label(g-&gt;scale, NULL, _(&quot;scale&quot;));</a>
<a name="ln1437">  g-&gt;rotate = dt_bauhaus_slider_new_with_range(self, -180.0, 180.0, 1.0, p-&gt;rotate, 2);</a>
<a name="ln1438">  dt_bauhaus_slider_set_format(g-&gt;rotate, &quot;%.02f°&quot;);</a>
<a name="ln1439">  dt_bauhaus_widget_set_label(g-&gt;rotate, NULL, _(&quot;rotation&quot;));</a>
<a name="ln1440">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;opacity, 0, line++, 3, 1);</a>
<a name="ln1441">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;scale, 0, line++, 3, 1);</a>
<a name="ln1442">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;rotate, 0, line++, 3, 1);</a>
<a name="ln1443"> </a>
<a name="ln1444">  g-&gt;sizeto = dt_bauhaus_combobox_new(self);</a>
<a name="ln1445">  dt_bauhaus_combobox_add(g-&gt;sizeto, C_(&quot;size&quot;, &quot;image&quot;));</a>
<a name="ln1446">  dt_bauhaus_combobox_add(g-&gt;sizeto, _(&quot;larger border&quot;));</a>
<a name="ln1447">  dt_bauhaus_combobox_add(g-&gt;sizeto, _(&quot;smaller border&quot;));</a>
<a name="ln1448">  dt_bauhaus_combobox_set(g-&gt;sizeto, p-&gt;sizeto);</a>
<a name="ln1449">  dt_bauhaus_widget_set_label(g-&gt;sizeto, NULL, _(&quot;scale on&quot;));</a>
<a name="ln1450">  gtk_widget_set_tooltip_text(g-&gt;sizeto, _(&quot;size is relative to&quot;));</a>
<a name="ln1451">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;sizeto, 0, line++, 3, 1);</a>
<a name="ln1452"> </a>
<a name="ln1453">  gtk_grid_attach(GTK_GRID(self-&gt;widget), dt_ui_section_label_new(_(&quot;position&quot;)), 0, line++, 3, 1);</a>
<a name="ln1454"> </a>
<a name="ln1455">  // Create the 3x3 gtk table toggle button table...</a>
<a name="ln1456">  label = dtgtk_reset_label_new(_(&quot;alignment&quot;), self, &amp;p-&gt;alignment, sizeof(p-&gt;alignment));</a>
<a name="ln1457">  GtkWidget *bat = gtk_grid_new();</a>
<a name="ln1458">  gtk_grid_set_row_spacing(GTK_GRID(bat), DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1459">  gtk_grid_set_column_spacing(GTK_GRID(bat), DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1460">  for(int i = 0; i &lt; 9; i++)</a>
<a name="ln1461">  {</a>
<a name="ln1462">    g-&gt;align[i] = dtgtk_togglebutton_new(dtgtk_cairo_paint_alignment, CPF_STYLE_FLAT | (CPF_SPECIAL_FLAG &lt;&lt; i), NULL);</a>
<a name="ln1463">    gtk_widget_set_size_request(GTK_WIDGET(g-&gt;align[i]), DT_PIXEL_APPLY_DPI(16), DT_PIXEL_APPLY_DPI(16));</a>
<a name="ln1464">    gtk_grid_attach(GTK_GRID(bat), GTK_WIDGET(g-&gt;align[i]), i%3, i/3, 1, 1);</a>
<a name="ln1465">    g_signal_connect(G_OBJECT(g-&gt;align[i]), &quot;toggled&quot;, G_CALLBACK(alignment_callback), self);</a>
<a name="ln1466">  }</a>
<a name="ln1467">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1468">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), bat, label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1469"> </a>
<a name="ln1470">  // x/y offset</a>
<a name="ln1471">  g-&gt;x_offset = dt_bauhaus_slider_new_with_range(self, -1.0, 1.0, 0.001, p-&gt;xoffset, 3);</a>
<a name="ln1472">  dt_bauhaus_slider_set_format(g-&gt;x_offset, &quot;%.3f&quot;);</a>
<a name="ln1473">  dt_bauhaus_widget_set_label(g-&gt;x_offset, NULL, _(&quot;x offset&quot;));</a>
<a name="ln1474">  g-&gt;y_offset = dt_bauhaus_slider_new_with_range(self, -1.0, 1.0, 0.001, p-&gt;yoffset, 3);</a>
<a name="ln1475">  dt_bauhaus_slider_set_format(g-&gt;y_offset, &quot;%.3f&quot;);</a>
<a name="ln1476">  dt_bauhaus_widget_set_label(g-&gt;y_offset, NULL, _(&quot;y offset&quot;));</a>
<a name="ln1477">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;x_offset, 0, line++, 3, 1);</a>
<a name="ln1478">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;y_offset, 0, line++, 3, 1);</a>
<a name="ln1479"> </a>
<a name="ln1480">  // Let's add some tooltips and hook up some signals...</a>
<a name="ln1481">  gtk_widget_set_tooltip_text(g-&gt;opacity, _(&quot;the opacity of the watermark&quot;));</a>
<a name="ln1482">  gtk_widget_set_tooltip_text(g-&gt;scale, _(&quot;the scale of the watermark&quot;));</a>
<a name="ln1483">  gtk_widget_set_tooltip_text(g-&gt;rotate, _(&quot;the rotation of the watermark&quot;));</a>
<a name="ln1484"> </a>
<a name="ln1485">  g_signal_connect(G_OBJECT(g-&gt;opacity), &quot;value-changed&quot;, G_CALLBACK(opacity_callback), self);</a>
<a name="ln1486">  g_signal_connect(G_OBJECT(g-&gt;scale), &quot;value-changed&quot;, G_CALLBACK(scale_callback), self);</a>
<a name="ln1487">  g_signal_connect(G_OBJECT(g-&gt;rotate), &quot;value-changed&quot;, G_CALLBACK(rotate_callback), self);</a>
<a name="ln1488"> </a>
<a name="ln1489">  g_signal_connect(G_OBJECT(g-&gt;x_offset), &quot;value-changed&quot;, G_CALLBACK(xoffset_callback), self);</a>
<a name="ln1490"> </a>
<a name="ln1491">  g_signal_connect(G_OBJECT(g-&gt;y_offset), &quot;value-changed&quot;, G_CALLBACK(yoffset_callback), self);</a>
<a name="ln1492"> </a>
<a name="ln1493"> </a>
<a name="ln1494">  g_signal_connect(G_OBJECT(g-&gt;refresh), &quot;clicked&quot;, G_CALLBACK(refresh_callback), self);</a>
<a name="ln1495"> </a>
<a name="ln1496">  refresh_watermarks(self);</a>
<a name="ln1497"> </a>
<a name="ln1498">  g_signal_connect(G_OBJECT(g-&gt;watermarks), &quot;value-changed&quot;, G_CALLBACK(watermark_callback), self);</a>
<a name="ln1499">  g_signal_connect(G_OBJECT(g-&gt;sizeto), &quot;value-changed&quot;, G_CALLBACK(sizeto_callback), self);</a>
<a name="ln1500"> </a>
<a name="ln1501">  g_signal_connect(G_OBJECT(g-&gt;text), &quot;changed&quot;, G_CALLBACK(text_callback), self);</a>
<a name="ln1502">  g_signal_connect(G_OBJECT(g-&gt;colorpick), &quot;color-set&quot;, G_CALLBACK(colorpick_color_set), self);</a>
<a name="ln1503">  g_signal_connect(G_OBJECT(g-&gt;fontsel), &quot;font-set&quot;, G_CALLBACK(fontsel_callback), self);</a>
<a name="ln1504"> </a>
<a name="ln1505">  dt_iop_init_single_picker(&amp;g-&gt;color_picker,</a>
<a name="ln1506">                     self,</a>
<a name="ln1507">                     GTK_WIDGET(g-&gt;color_picker_button),</a>
<a name="ln1508">                     DT_COLOR_PICKER_POINT,</a>
<a name="ln1509">                     _iop_color_picker_apply);</a>
<a name="ln1510">}</a>
<a name="ln1511"> </a>
<a name="ln1512">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln1513">{</a>
<a name="ln1514"> </a>
<a name="ln1515">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1516">  g_list_free_full(g-&gt;watermarks_filenames, g_free);</a>
<a name="ln1517">  g-&gt;watermarks_filenames = NULL;</a>
<a name="ln1518">  free(self-&gt;gui_data);</a>
<a name="ln1519">  self-&gt;gui_data = NULL;</a>
<a name="ln1520">}</a>
<a name="ln1521"> </a>
<a name="ln1522">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1523">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1524">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1332"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1332, 1324.</p></div>
<div class="balloon" rel="1333"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1333, 1326.</p></div>
<div class="balloon" rel="1362"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 1362, 1344.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
