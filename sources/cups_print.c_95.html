
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2014-2018 pascal obry.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;cups/cups.h&gt;</a>
<a name="ln20">#include &lt;cups/ppd.h&gt;</a>
<a name="ln21">#include &lt;glib.h&gt;</a>
<a name="ln22">#include &lt;stdio.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;common/image.h&quot;</a>
<a name="ln25">#include &quot;common/image_cache.h&quot;</a>
<a name="ln26">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln27">#include &quot;common/pdf.h&quot;</a>
<a name="ln28">#include &quot;control/jobs/control_jobs.h&quot;</a>
<a name="ln29">#include &quot;cups_print.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;</a>
<a name="ln32">// some platforms are starting to provide CUPS 2.2.9 and there the</a>
<a name="ln33">// CUPS API deprecated routines ate now flagged as such and reported as</a>
<a name="ln34">// warning preventing the compilation.</a>
<a name="ln35">//</a>
<a name="ln36">// this seems wrong and PPD should be removed from this unit. but there</a>
<a name="ln37">// still one missing piece discussed with the CUPS maintainers about the</a>
<a name="ln38">// way to get media-type using the IPP API. nothing close to working at</a>
<a name="ln39">// this stage, so instead of breaking the compilation on platforms using</a>
<a name="ln40">// recent CUPS version we kill the warning.</a>
<a name="ln41"> </a>
<a name="ln42">typedef struct dt_prtctl_t</a>
<a name="ln43">{</a>
<a name="ln44">  void (*cb)(dt_printer_info_t *, void *);</a>
<a name="ln45">  void *user_data;</a>
<a name="ln46">} dt_prtctl_t;</a>
<a name="ln47"> </a>
<a name="ln48">// initialize the pinfo structure</a>
<a name="ln49">void dt_init_print_info(dt_print_info_t *pinfo)</a>
<a name="ln50">{</a>
<a name="ln51">  memset(&amp;pinfo-&gt;printer, 0, sizeof(dt_printer_info_t));</a>
<a name="ln52">  memset(&amp;pinfo-&gt;page, 0, sizeof(dt_page_setup_t));</a>
<a name="ln53">  memset(&amp;pinfo-&gt;paper, 0, sizeof(dt_paper_info_t));</a>
<a name="ln54">  pinfo-&gt;printer.intent = DT_INTENT_PERCEPTUAL;</a>
<a name="ln55">  pinfo-&gt;printer.is_turboprint = FALSE;</a>
<a name="ln56">  *pinfo-&gt;printer.profile = '\0';</a>
<a name="ln57">}</a>
<a name="ln58"> </a>
<a name="ln59">void dt_get_printer_info(const char *printer_name, dt_printer_info_t *pinfo)</a>
<a name="ln60">{</a>
<a name="ln61">  cups_dest_t *dests;</a>
<a name="ln62">  int num_dests = cupsGetDests(&amp;dests);</a>
<a name="ln63">  cups_dest_t *dest = cupsGetDest(printer_name, NULL, num_dests, dests);</a>
<a name="ln64"> </a>
<a name="ln65">  if (dest)</a>
<a name="ln66">  {</a>
<a name="ln67">    const char *PPDFile = cupsGetPPD (printer_name);</a>
<a name="ln68">    g_strlcpy(pinfo-&gt;name, dest-&gt;name, MAX_NAME);</a>
<a name="ln69">    ppd_file_t *ppd = ppdOpenFile(PPDFile);</a>
<a name="ln70"> </a>
<a name="ln71">    if (ppd)</a>
<a name="ln72">    {</a>
<a name="ln73">      ppdMarkDefaults(ppd);</a>
<a name="ln74">      cupsMarkOptions(ppd, dest-&gt;num_options, dest-&gt;options);</a>
<a name="ln75"> </a>
<a name="ln76">      // first check if this is turboprint drived printer, two solutions:</a>
<a name="ln77">      // 1. ModelName constains TurboPrint</a>
<a name="ln78">      // 2. zedoPrinterDriver exists</a>
<a name="ln79">      ppd_attr_t *attr = ppdFindAttr(ppd, &quot;ModelName&quot;, NULL);</a>
<a name="ln80"> </a>
<a name="ln81">      if (attr)</a>
<a name="ln82">      {</a>
<a name="ln83">        pinfo-&gt;is_turboprint = strstr(attr-&gt;value, &quot;TurboPrint&quot;) != NULL;</a>
<a name="ln84">      }</a>
<a name="ln85"> </a>
<a name="ln86">      // hardware margins</a>
<a name="ln87"> </a>
<a name="ln88">      attr = ppdFindAttr(ppd, &quot;HWMargins&quot;, NULL);</a>
<a name="ln89"> </a>
<a name="ln90">      if (attr)</a>
<a name="ln91">      {</a>
<a name="ln92">        sscanf(attr-&gt;value, &quot;%lf %lf %lf %lf&quot;,</a>
<a name="ln93">               &amp;pinfo-&gt;hw_margin_left, &amp;pinfo-&gt;hw_margin_bottom,</a>
<a name="ln94">               &amp;pinfo-&gt;hw_margin_right, &amp;pinfo-&gt;hw_margin_top);</a>
<a name="ln95"> </a>
<a name="ln96">        pinfo-&gt;hw_margin_left   = dt_pdf_point_to_mm (pinfo-&gt;hw_margin_left);</a>
<a name="ln97">        pinfo-&gt;hw_margin_bottom = dt_pdf_point_to_mm (pinfo-&gt;hw_margin_bottom);</a>
<a name="ln98">        pinfo-&gt;hw_margin_right  = dt_pdf_point_to_mm (pinfo-&gt;hw_margin_right);</a>
<a name="ln99">        pinfo-&gt;hw_margin_top    = dt_pdf_point_to_mm (pinfo-&gt;hw_margin_top);</a>
<a name="ln100">      }</a>
<a name="ln101"> </a>
<a name="ln102">      // default resolution</a>
<a name="ln103"> </a>
<a name="ln104">      attr = ppdFindAttr(ppd, &quot;DefaultResolution&quot;, NULL);</a>
<a name="ln105"> </a>
<a name="ln106">      if (attr)</a>
<a name="ln107">      {</a>
<a name="ln108">        char *x = strstr(attr-&gt;value, &quot;x&quot;);</a>
<a name="ln109"> </a>
<a name="ln110">        if (x)</a>
<a name="ln111">          sscanf (x+1, &quot;%ddpi&quot;, &amp;pinfo-&gt;resolution);</a>
<a name="ln112">        else</a>
<a name="ln113">          sscanf (attr-&gt;value, &quot;%ddpi&quot;, &amp;pinfo-&gt;resolution);</a>
<a name="ln114">      }</a>
<a name="ln115">      else</a>
<a name="ln116">        pinfo-&gt;resolution = 300;</a>
<a name="ln117"> </a>
<a name="ln118">      while(pinfo-&gt;resolution&gt;360)</a>
<a name="ln119">        pinfo-&gt;resolution /= 2.0;</a>
<a name="ln120"> </a>
<a name="ln121">      ppdClose(ppd);</a>
<a name="ln122">      g_unlink(PPDFile);</a>
<a name="ln123">    }</a>
<a name="ln124">  }</a>
<a name="ln125"> </a>
<a name="ln126">  cupsFreeDests(num_dests, dests);</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">static int _dest_cb(void *user_data, unsigned flags, cups_dest_t *dest)</a>
<a name="ln130">{</a>
<a name="ln131">  const dt_prtctl_t *pctl = (dt_prtctl_t *)user_data;</a>
<a name="ln132">  const char *psvalue = cupsGetOption(&quot;printer-state&quot;, dest-&gt;num_options, dest-&gt;options);</a>
<a name="ln133"> </a>
<a name="ln134">  // check that the printer is ready</a>
<a name="ln135">  if (psvalue!=NULL &amp;&amp; strtol(psvalue, NULL, 10) &lt; IPP_PRINTER_STOPPED)</a>
<a name="ln136">  {</a>
<a name="ln137">    dt_printer_info_t pr;</a>
<a name="ln138">    memset(&amp;pr, 0, sizeof(pr));</a>
<a name="ln139">    dt_get_printer_info(dest-&gt;name, &amp;pr);</a>
<a name="ln140">    if (pctl-&gt;cb) pctl-&gt;cb(&amp;pr, pctl-&gt;user_data);</a>
<a name="ln141">    dt_print(DT_DEBUG_PRINT, &quot;[print] new printer %s found\n&quot;, dest-&gt;name);</a>
<a name="ln142">  }</a>
<a name="ln143">  else</a>
<a name="ln144">    dt_print(DT_DEBUG_PRINT, &quot;[print] skip printer %s as stopped\n&quot;, dest-&gt;name);</a>
<a name="ln145"> </a>
<a name="ln146">  return 1;</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">static int _cancel = 0;</a>
<a name="ln150"> </a>
<a name="ln151">static int _detect_printers_callback(dt_job_t *job)</a>
<a name="ln152">{</a>
<a name="ln153">  dt_prtctl_t *pctl = dt_control_job_get_params(job);</a>
<a name="ln154">  int res;</a>
<a name="ln155">#if ((CUPS_VERSION_MAJOR == 1) &amp;&amp; (CUPS_VERSION_MINOR &gt;= 6)) || CUPS_VERSION_MAJOR &gt; 1</a>
<a name="ln156">#if defined(__APPLE__) &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &lt; MAC_OS_X_VERSION_10_8</a>
<a name="ln157">  if (cupsEnumDests != NULL)</a>
<a name="ln158">#endif</a>
<a name="ln159">    res = cupsEnumDests(CUPS_MEDIA_FLAGS_DEFAULT, 30000, &amp;_cancel, 0, 0, _dest_cb, pctl);</a>
<a name="ln160">#if defined(__APPLE__) &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &lt; MAC_OS_X_VERSION_10_8</a>
<a name="ln161">  else</a>
<a name="ln162">#endif</a>
<a name="ln163">#endif</a>
<a name="ln164">#if defined(__APPLE__) &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &lt; MAC_OS_X_VERSION_10_8 || !(((CUPS_VERSION_MAJOR == 1) &amp;&amp; (CUPS_VERSION_MINOR &gt;= 6)) || CUPS_VERSION_MAJOR &gt; 1)</a>
<a name="ln165">  {</a>
<a name="ln166">    cups_dest_t *dests;</a>
<a name="ln167">    const int num_dests = cupsGetDests(&amp;dests);</a>
<a name="ln168">    for (int k=0; k&lt;num_dests; k++)</a>
<a name="ln169">    {</a>
<a name="ln170">      _dest_cb((void *)pctl, 0, &amp;dests[k]);</a>
<a name="ln171">    }</a>
<a name="ln172">    cupsFreeDests(num_dests, dests);</a>
<a name="ln173">    res=1;</a>
<a name="ln174">  }</a>
<a name="ln175">#endif</a>
<a name="ln176">  return !res;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">void dt_printers_abort_discovery(void)</a>
<a name="ln180">{</a>
<a name="ln181">  _cancel = 1;</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">void dt_printers_discovery(void (*cb)(dt_printer_info_t *pr, void *user_data), void *user_data)</a>
<a name="ln185">{</a>
<a name="ln186">  // asynchronously checks for available printers</a>
<a name="ln187">  dt_job_t *job = dt_control_job_create(&amp;_detect_printers_callback, &quot;detect connected printers&quot;);</a>
<a name="ln188">  if(job)</a>
<a name="ln189">  {</a>
<a name="ln190">    dt_prtctl_t *prtctl = g_malloc0(sizeof(dt_prtctl_t));</a>
<a name="ln191"> </a>
<a name="ln192">    prtctl-&gt;cb = cb;</a>
<a name="ln193">    prtctl-&gt;user_data = user_data;</a>
<a name="ln194"> </a>
<a name="ln195">    dt_control_job_set_params(job, prtctl, g_free);</a>
<a name="ln196">    dt_control_add_job(darktable.control, DT_JOB_QUEUE_SYSTEM_BG, job);</a>
<a name="ln197">  }</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">static int paper_exists(GList *papers, const char *name)</a>
<a name="ln201">{</a>
<a name="ln202">  if (strstr(name,&quot;custom_&quot;) == name)</a>
<a name="ln203">    return 1;</a>
<a name="ln204"> </a>
<a name="ln205">  GList *p = papers;</a>
<a name="ln206">  while (p)</a>
<a name="ln207">  {</a>
<a name="ln208">    const dt_paper_info_t *pi = (dt_paper_info_t*)p-&gt;data;</a>
<a name="ln209">    if (!strcmp(pi-&gt;name,name) || !strcmp(pi-&gt;common_name,name))</a>
<a name="ln210">      return 1;</a>
<a name="ln211">    p = g_list_next (p);</a>
<a name="ln212">  }</a>
<a name="ln213">  return 0;</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">dt_paper_info_t *dt_get_paper(GList *papers, const char *name)</a>
<a name="ln217">{</a>
<a name="ln218">  GList *p = papers;</a>
<a name="ln219">  dt_paper_info_t *result = NULL;</a>
<a name="ln220"> </a>
<a name="ln221">  while (p)</a>
<a name="ln222">  {</a>
<a name="ln223">    dt_paper_info_t *pi = (dt_paper_info_t*)p-&gt;data;</a>
<a name="ln224">    if (!strcmp(pi-&gt;name,name) || !strcmp(pi-&gt;common_name,name))</a>
<a name="ln225">    {</a>
<a name="ln226">      result = pi;</a>
<a name="ln227">      break;</a>
<a name="ln228">    }</a>
<a name="ln229">    p = g_list_next (p);</a>
<a name="ln230">  }</a>
<a name="ln231">  return result;</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234">static gint</a>
<a name="ln235">sort_papers (gconstpointer p1, gconstpointer p2)</a>
<a name="ln236">{</a>
<a name="ln237">  const dt_paper_info_t *n1 = (dt_paper_info_t *)p1;</a>
<a name="ln238">  const dt_paper_info_t *n2 = (dt_paper_info_t *)p2;</a>
<a name="ln239">  const int l1 = strlen(n1-&gt;common_name);</a>
<a name="ln240">  const int l2 = strlen(n2-&gt;common_name);</a>
<a name="ln241">  return l1==l2 ? strcmp(n1-&gt;common_name, n2-&gt;common_name) : (l1 &lt; l2 ? -1 : +1);</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">GList *dt_get_papers(const dt_printer_info_t *printer)</a>
<a name="ln245">{</a>
<a name="ln246">  const char *printer_name = printer-&gt;name;</a>
<a name="ln247">  GList *result = NULL;</a>
<a name="ln248"> </a>
<a name="ln249">#if ((CUPS_VERSION_MAJOR == 1) &amp;&amp; (CUPS_VERSION_MINOR &gt;= 7)) || CUPS_VERSION_MAJOR &gt; 1</a>
<a name="ln250">#if defined(__APPLE__) &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &lt; MAC_OS_X_VERSION_10_9</a>
<a name="ln251">  if (cupsConnectDest != NULL &amp;&amp; cupsCopyDestInfo != NULL &amp;&amp; cupsGetDestMediaCount != NULL &amp;&amp;</a>
<a name="ln252">      cupsGetDestMediaByIndex != NULL &amp;&amp; cupsFreeDestInfo != NULL)</a>
<a name="ln253">#endif</a>
<a name="ln254">  {</a>
<a name="ln255">    cups_dest_t *dests;</a>
<a name="ln256">    int num_dests = cupsGetDests(&amp;dests);</a>
<a name="ln257">    cups_dest_t *dest = cupsGetDest(printer_name, NULL, num_dests, dests);</a>
<a name="ln258"> </a>
<a name="ln259">    int cancel = 0; // important</a>
<a name="ln260"> </a>
<a name="ln261">    char resource[1024];</a>
<a name="ln262"> </a>
<a name="ln263">    if (dest)</a>
<a name="ln264">    {</a>
<a name="ln265">      http_t *hcon = cupsConnectDest(dest, 0, 2000, &amp;cancel, resource, sizeof(resource), NULL, (void *)NULL);</a>
<a name="ln266"> </a>
<a name="ln267">      if (hcon)</a>
<a name="ln268">      {</a>
<a name="ln269">        cups_size_t size;</a>
<a name="ln270">        cups_dinfo_t *info = cupsCopyDestInfo (hcon, dest);</a>
<a name="ln271">        const int count = cupsGetDestMediaCount(hcon, dest, info, CUPS_MEDIA_FLAGS_DEFAULT);</a>
<a name="ln272">        for (int k=0; k&lt;count; k++)</a>
<a name="ln273">        {</a>
<a name="ln274">          if (cupsGetDestMediaByIndex(hcon, dest, info, k, CUPS_MEDIA_FLAGS_DEFAULT, &amp;size))</a>
<a name="ln275">          {</a>
<a name="ln276">            if (size.width!=0 &amp;&amp; size.length!=0 &amp;&amp; !paper_exists(result, size.media))</a>
<a name="ln277">            {</a>
<a name="ln278">              pwg_media_t *med = pwgMediaForPWG (size.media);</a>
<a name="ln279">              char common_name[MAX_NAME] = { 0 };</a>
<a name="ln280"> </a>
<a name="ln281">              if (med-&gt;ppd)</a>
<a name="ln282">                g_strlcpy(common_name, med-&gt;ppd, sizeof(common_name));</a>
<a name="ln283">              else</a>
<a name="ln284">                g_strlcpy(common_name, size.media, sizeof(common_name));</a>
<a name="ln285"> </a>
<a name="ln286">              dt_paper_info_t *paper = (dt_paper_info_t*)malloc(sizeof(dt_paper_info_t));</a>
<a name="ln287">              g_strlcpy(paper-&gt;name, size.media, sizeof(paper-&gt;name));</a>
<a name="ln288">              g_strlcpy(paper-&gt;common_name, common_name, sizeof(paper-&gt;common_name));</a>
<a name="ln289">              paper-&gt;width = (double)size.width / 100.0;</a>
<a name="ln290">              paper-&gt;height = (double)size.length / 100.0;</a>
<a name="ln291">              result = g_list_append (result, paper);</a>
<a name="ln292"> </a>
<a name="ln293">              dt_print(DT_DEBUG_PRINT,</a>
<a name="ln294">                       &quot;[print] new media paper %4d %6.2f x %6.2f (%s) (%s)\n&quot;,</a>
<a name="ln295">                       k, paper-&gt;width, paper-&gt;height, paper-&gt;name, paper-&gt;common_name);</a>
<a name="ln296">            }</a>
<a name="ln297">          }</a>
<a name="ln298">        }</a>
<a name="ln299"> </a>
<a name="ln300">        cupsFreeDestInfo(info);</a>
<a name="ln301">        httpClose(hcon);</a>
<a name="ln302">      }</a>
<a name="ln303">      else</a>
<a name="ln304">        dt_print(DT_DEBUG_PRINT, &quot;[print] cannot connect to printer %s (cancel=%d)\n&quot;, printer_name, cancel);</a>
<a name="ln305">    }</a>
<a name="ln306"> </a>
<a name="ln307">    cupsFreeDests(num_dests, dests);</a>
<a name="ln308">  }</a>
<a name="ln309">#endif</a>
<a name="ln310"> </a>
<a name="ln311">  // check now PPD page sizes</a>
<a name="ln312"> </a>
<a name="ln313">  const char *PPDFile = cupsGetPPD(printer_name);</a>
<a name="ln314">  ppd_file_t *ppd = ppdOpenFile(PPDFile);</a>
<a name="ln315"> </a>
<a name="ln316">  if (ppd)</a>
<a name="ln317">  {</a>
<a name="ln318">    ppd_size_t *size = ppd-&gt;sizes;</a>
<a name="ln319"> </a>
<a name="ln320">    for (int k=0; k&lt;ppd-&gt;num_sizes; k++)</a>
<a name="ln321">    {</a>
<a name="ln322">      if (size-&gt;width!=0 &amp;&amp; size-&gt;length!=0 &amp;&amp; !paper_exists(result, size-&gt;name))</a>
<a name="ln323">      {</a>
<a name="ln324">        dt_paper_info_t *paper = (dt_paper_info_t*)malloc(sizeof(dt_paper_info_t));</a>
<a name="ln325">        g_strlcpy(paper-&gt;name, size-&gt;name, MAX_NAME);</a>
<a name="ln326">        g_strlcpy(paper-&gt;common_name, size-&gt;name, MAX_NAME);</a>
<a name="ln327">        paper-&gt;width = (double)dt_pdf_point_to_mm(size-&gt;width);</a>
<a name="ln328">        paper-&gt;height = (double)dt_pdf_point_to_mm(size-&gt;length);</a>
<a name="ln329">        result = g_list_append (result, paper);</a>
<a name="ln330"> </a>
<a name="ln331">        dt_print(DT_DEBUG_PRINT,</a>
<a name="ln332">                 &quot;[print] new ppd paper %4d %6.2f x %6.2f (%s) (%s)\n&quot;,</a>
<a name="ln333">                 k, paper-&gt;width, paper-&gt;height, paper-&gt;name, paper-&gt;common_name);</a>
<a name="ln334">      }</a>
<a name="ln335">      size++;</a>
<a name="ln336">    }</a>
<a name="ln337"> </a>
<a name="ln338">    ppdClose(ppd);</a>
<a name="ln339">    g_unlink(PPDFile);</a>
<a name="ln340">  }</a>
<a name="ln341"> </a>
<a name="ln342">  result = g_list_sort_with_data (result, (GCompareDataFunc)sort_papers, NULL);</a>
<a name="ln343">  return result;</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">GList *dt_get_media_type(const dt_printer_info_t *printer)</a>
<a name="ln347">{</a>
<a name="ln348">  const char *printer_name = printer-&gt;name;</a>
<a name="ln349">  GList *result = NULL;</a>
<a name="ln350"> </a>
<a name="ln351">  // check now PPD media type</a>
<a name="ln352"> </a>
<a name="ln353">  const char *PPDFile = cupsGetPPD(printer_name);</a>
<a name="ln354">  ppd_file_t *ppd = ppdOpenFile(PPDFile);</a>
<a name="ln355"> </a>
<a name="ln356">  if (ppd)</a>
<a name="ln357">  {</a>
<a name="ln358">      ppd_option_t *opt = ppdFindOption(ppd, &quot;MediaType&quot;);</a>
<a name="ln359"> </a>
<a name="ln360">      if (opt)</a>
<a name="ln361">      {</a>
<a name="ln362">        ppd_choice_t *choice = opt-&gt;choices;</a>
<a name="ln363"> </a>
<a name="ln364">        for (int k=0; k&lt;opt-&gt;num_choices; k++)</a>
<a name="ln365">        {</a>
<a name="ln366">          dt_medium_info_t *media = (dt_medium_info_t*)malloc(sizeof(dt_medium_info_t));</a>
<a name="ln367">          g_strlcpy(media-&gt;name, choice-&gt;choice, MAX_NAME);</a>
<a name="ln368">          g_strlcpy(media-&gt;common_name, choice-&gt;text, MAX_NAME);</a>
<a name="ln369">          result = g_list_append (result, media);</a>
<a name="ln370"> </a>
<a name="ln371">          dt_print(DT_DEBUG_PRINT, &quot;[print] new media %2d (%s) (%s)\n&quot;, k, media-&gt;name, media-&gt;common_name);</a>
<a name="ln372">          choice++;</a>
<a name="ln373">        }</a>
<a name="ln374">      }</a>
<a name="ln375">  }</a>
<a name="ln376"> </a>
<a name="ln377">  ppdClose(ppd);</a>
<a name="ln378">  g_unlink(PPDFile);</a>
<a name="ln379"> </a>
<a name="ln380">  return result;</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">dt_medium_info_t *dt_get_medium(GList *media, const char *name)</a>
<a name="ln384">{</a>
<a name="ln385">  GList *m = media;</a>
<a name="ln386">  dt_medium_info_t *result = NULL;</a>
<a name="ln387"> </a>
<a name="ln388">  while (m)</a>
<a name="ln389">  {</a>
<a name="ln390">    dt_medium_info_t *mi = (dt_medium_info_t*)m-&gt;data;</a>
<a name="ln391">    if (!strcmp(mi-&gt;name, name) || !strcmp(mi-&gt;common_name, name))</a>
<a name="ln392">    {</a>
<a name="ln393">      result = mi;</a>
<a name="ln394">      break;</a>
<a name="ln395">    }</a>
<a name="ln396">    m = g_list_next (m);</a>
<a name="ln397">  }</a>
<a name="ln398">  return result;</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">void dt_print_file(const int32_t imgid, const char *filename, const char *job_title, const dt_print_info_t *pinfo)</a>
<a name="ln402">{</a>
<a name="ln403">  // first for safety check that filename exists and is readable</a>
<a name="ln404"> </a>
<a name="ln405">  if (!g_file_test(filename, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln406">  {</a>
<a name="ln407">    dt_control_log(_(&quot;file `%s' to print not found for image %d on `%s'&quot;), filename, imgid, pinfo-&gt;printer.name);</a>
<a name="ln408">    return;</a>
<a name="ln409">  }</a>
<a name="ln410"> </a>
<a name="ln411">  cups_option_t *options = NULL;</a>
<a name="ln412">  int num_options = 0;</a>
<a name="ln413"> </a>
<a name="ln414">  // for turboprint drived printer, use the turboprint dialog</a>
<a name="ln415">  if (pinfo-&gt;printer.is_turboprint)</a>
<a name="ln416">  {</a>
<a name="ln417">    const char *tp_intent_name[] = { &quot;perception_0&quot;, &quot;colorimetric-relative_1&quot;, &quot;saturation_1&quot;, &quot;colorimetric-absolute_1&quot; };</a>
<a name="ln418">    char tmpfile[PATH_MAX] = { 0 };</a>
<a name="ln419"> </a>
<a name="ln420">    dt_loc_get_tmp_dir(tmpfile, sizeof(tmpfile));</a>
<a name="ln421">    g_strlcat(tmpfile, &quot;/dt_cups_opts_XXXXXX&quot;, sizeof(tmpfile));</a>
<a name="ln422"> </a>
<a name="ln423">    gint fd = g_mkstemp(tmpfile);</a>
<a name="ln424">    if(fd == -1)</a>
<a name="ln425">    {</a>
<a name="ln426">      dt_control_log(_(&quot;failed to create temporary file for printing options&quot;));</a>
<a name="ln427">      fprintf(stderr, &quot;failed to create temporary pdf for printing options\n&quot;);</a>
<a name="ln428">      return;</a>
<a name="ln429">    }</a>
<a name="ln430">    close(fd);</a>
<a name="ln431"> </a>
<a name="ln432">    // ensure that intent is in the range, may happen if at some point we add new intent in the list</a>
<a name="ln433">    const int intent = (pinfo-&gt;printer.intent &lt; 4) ? pinfo-&gt;printer.intent : 0;</a>
<a name="ln434"> </a>
<a name="ln435">    // spawn turboprint command</a>
<a name="ln436">    gchar * argv[15] = { 0 };</a>
<a name="ln437"> </a>
<a name="ln438">    argv[0] = &quot;turboprint&quot;;</a>
<a name="ln439">    argv[1] = g_strdup_printf(&quot;--printer=%s&quot;, pinfo-&gt;printer.name);</a>
<a name="ln440">    argv[2] = &quot;--options&quot;;</a>
<a name="ln441">    argv[3] = g_strdup_printf(&quot;--output=%s&quot;, tmpfile);</a>
<a name="ln442">    argv[4] = &quot;-o&quot;;</a>
<a name="ln443">    argv[5] = &quot;copies=1&quot;;</a>
<a name="ln444">    argv[6] = &quot;-o&quot;;</a>
<a name="ln445">    argv[7] = g_strdup_printf(&quot;PageSize=%s&quot;, pinfo-&gt;paper.common_name);</a>
<a name="ln446">    argv[8] = &quot;-o&quot;;</a>
<a name="ln447">    argv[9] = &quot;InputSlot=AutoSelect&quot;;</a>
<a name="ln448">    argv[10] = &quot;-o&quot;;</a>
<a name="ln449">    argv[11] = g_strdup_printf(&quot;zedoIntent=%s&quot;, tp_intent_name[intent]);</a>
<a name="ln450">    argv[12] = &quot;-o&quot;;</a>
<a name="ln451">    argv[13] = g_strdup_printf(&quot;MediaType=%s&quot;, pinfo-&gt;medium.name);</a>
<a name="ln452">    argv[14] = NULL;</a>
<a name="ln453"> </a>
<a name="ln454">    gint exit_status = 0;</a>
<a name="ln455"> </a>
<a name="ln456">    g_spawn_sync (NULL, argv, NULL, G_SPAWN_SEARCH_PATH | G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,</a>
<a name="ln457">                  NULL, NULL, NULL, NULL, &amp;exit_status, NULL);</a>
<a name="ln458"> </a>
<a name="ln459">    g_free(argv[1]);</a>
<a name="ln460">    g_free(argv[3]);</a>
<a name="ln461">    g_free(argv[7]);</a>
<a name="ln462">    g_free(argv[11]);</a>
<a name="ln463">    g_free(argv[13]);</a>
<a name="ln464"> </a>
<a name="ln465">    if(exit_status==0)</a>
<a name="ln466">    {</a>
<a name="ln467">      FILE *stream = g_fopen(tmpfile, &quot;rb&quot;);</a>
<a name="ln468"> </a>
<a name="ln469">      while(1)</a>
<a name="ln470">      {</a>
<a name="ln471">        char optname[100];</a>
<a name="ln472">        char optvalue[100];</a>
<a name="ln473">        const int ropt = fscanf(stream, &quot;%*s %99[^= ]=%99s&quot;, optname, optvalue);</a>
<a name="ln474"> </a>
<a name="ln475">        // if we parsed an option name=value</a>
<a name="ln476">        if (ropt==2)</a>
<a name="ln477">        {</a>
<a name="ln478">          char *v = optvalue;</a>
<a name="ln479"> </a>
<a name="ln480">          // remove possible single quote around value</a>
<a name="ln481">          if (*v == '\'') v++;</a>
<a name="ln482">          if (v[strlen(v)-1] == '\'') v[strlen(v)-1] = '\0';</a>
<a name="ln483"> </a>
<a name="ln484">          num_options = cupsAddOption(optname, v, num_options, &amp;options);</a>
<a name="ln485">        }</a>
<a name="ln486">        else if (ropt == EOF)</a>
<a name="ln487">          break;</a>
<a name="ln488">      }</a>
<a name="ln489">      fclose(stream);</a>
<a name="ln490">      g_unlink(tmpfile);</a>
<a name="ln491">    }</a>
<a name="ln492">    else</a>
<a name="ln493">    {</a>
<a name="ln494">      dt_control_log(_(&quot;printing on `%s' cancelled&quot;), pinfo-&gt;printer.name);</a>
<a name="ln495">      dt_print(DT_DEBUG_PRINT, &quot;[print]   command fails with %d, cancel printing\n&quot;, exit_status);</a>
<a name="ln496">      return;</a>
<a name="ln497">    }</a>
<a name="ln498">  }</a>
<a name="ln499">  else</a>
<a name="ln500">  {</a>
<a name="ln501">    cups_dest_t *dests;</a>
<a name="ln502">    int num_dests = cupsGetDests(&amp;dests);</a>
<a name="ln503">    cups_dest_t *dest = cupsGetDest(pinfo-&gt;printer.name, NULL, num_dests, dests);</a>
<a name="ln504"> </a>
<a name="ln505">    for (int j = 0; j &lt; dest-&gt;num_options; j ++)</a>
<a name="ln506">      if (cupsGetOption(dest-&gt;options[j].name, num_options,</a>
<a name="ln507">                        options) == NULL)</a>
<a name="ln508">        num_options = cupsAddOption(dest-&gt;options[j].name,</a>
<a name="ln509">                                    dest-&gt;options[j].value,</a>
<a name="ln510">                                    num_options, &amp;options);</a>
<a name="ln511"> </a>
<a name="ln512">    cupsFreeDests(num_dests, dests);</a>
<a name="ln513"> </a>
<a name="ln514">    // if we have a profile, disable cm on CUPS, this is important as dt does the cm</a>
<a name="ln515"> </a>
<a name="ln516">    num_options = cupsAddOption(&quot;cm-calibration&quot;, *pinfo-&gt;printer.profile ? &quot;true&quot; : &quot;false&quot;, num_options, &amp;options);</a>
<a name="ln517"> </a>
<a name="ln518">    // media to print on</a>
<a name="ln519"> </a>
<a name="ln520">    num_options = cupsAddOption(&quot;media&quot;, pinfo-&gt;paper.name, num_options, &amp;options);</a>
<a name="ln521"> </a>
<a name="ln522">    // the media type to print on</a>
<a name="ln523"> </a>
<a name="ln524">    num_options = cupsAddOption(&quot;MediaType&quot;, pinfo-&gt;medium.name, num_options, &amp;options);</a>
<a name="ln525"> </a>
<a name="ln526">    // never print two-side</a>
<a name="ln527"> </a>
<a name="ln528">    num_options = cupsAddOption(&quot;sides&quot;, &quot;one-sided&quot;, num_options, &amp;options);</a>
<a name="ln529"> </a>
<a name="ln530">    // and a single image per page</a>
<a name="ln531"> </a>
<a name="ln532">    num_options = cupsAddOption(&quot;number-up&quot;, &quot;1&quot;, num_options, &amp;options);</a>
<a name="ln533"> </a>
<a name="ln534">    // if the printer has no hardward margins activate the borderless mode</a>
<a name="ln535"> </a>
<a name="ln536">    if (pinfo-&gt;printer.hw_margin_top == 0 || pinfo-&gt;printer.hw_margin_bottom == 0</a>
<a name="ln537">        || pinfo-&gt;printer.hw_margin_left == 0 || pinfo-&gt;printer.hw_margin_right == 0)</a>
<a name="ln538">    {</a>
<a name="ln539">      // there is many variant for this parameter</a>
<a name="ln540">      num_options = cupsAddOption(&quot;StpFullBleed&quot;, &quot;true&quot;, num_options, &amp;options);</a>
<a name="ln541">      num_options = cupsAddOption(&quot;STP_FullBleed&quot;, &quot;true&quot;, num_options, &amp;options);</a>
<a name="ln542">      num_options = cupsAddOption(&quot;Borderless&quot;, &quot;true&quot;, num_options, &amp;options);</a>
<a name="ln543">    }</a>
<a name="ln544"> </a>
<a name="ln545">    num_options = cupsAddOption(&quot;landscape&quot;, pinfo-&gt;page.landscape ? &quot;true&quot; : &quot;false&quot;, num_options, &amp;options);</a>
<a name="ln546">  }</a>
<a name="ln547"> </a>
<a name="ln548">  // print lp options</a>
<a name="ln549"> </a>
<a name="ln550">  dt_print(DT_DEBUG_PRINT, &quot;[print] printer options (%d)\n&quot;, num_options);</a>
<a name="ln551">  for (int k=0; k&lt;num_options; k++)</a>
<a name="ln552">    dt_print(DT_DEBUG_PRINT, &quot;[print]   %2d  %s=%s\n&quot;, k+1, options[k].name, options[k].value);</a>
<a name="ln553"> </a>
<a name="ln554">  const int job_id = cupsPrintFile(pinfo-&gt;printer.name, filename, job_title, num_options, options);</a>
<a name="ln555"> </a>
<a name="ln556">  if (job_id == 0)</a>
<a name="ln557">    dt_control_log(_(&quot;error while printing `%s' on `%s'&quot;), job_title, pinfo-&gt;printer.name);</a>
<a name="ln558">  else</a>
<a name="ln559">    dt_control_log(_(&quot;printing `%s' on `%s'&quot;), job_title, pinfo-&gt;printer.name);</a>
<a name="ln560"> </a>
<a name="ln561">  cupsFreeOptions (num_options, options);</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564">void dt_get_print_layout(const int32_t imgid, const dt_print_info_t *prt,</a>
<a name="ln565">                         const int32_t area_width, const int32_t area_height,</a>
<a name="ln566">                         int32_t *iwpix, int32_t *ihpix,</a>
<a name="ln567">                         int32_t *px,    int32_t *py,    int32_t *pwidth, int32_t *pheight,</a>
<a name="ln568">                         int32_t *ax,    int32_t *ay,    int32_t *awidth, int32_t *aheight,</a>
<a name="ln569">                         int32_t *ix,    int32_t *iy,    int32_t *iwidth, int32_t *iheight)</a>
<a name="ln570">{</a>
<a name="ln571">  /* this is where the layout is done for the display and for the print too. So this routine is one</a>
<a name="ln572">     of the most critical for the print circuitry. */</a>
<a name="ln573"> </a>
<a name="ln574">  double width, height;</a>
<a name="ln575"> </a>
<a name="ln576">  // page w/h</a>
<a name="ln577">  double pg_width  = prt-&gt;paper.width;</a>
<a name="ln578">  double pg_height = prt-&gt;paper.height;</a>
<a name="ln579"> </a>
<a name="ln580">  if (area_width==0)</a>
<a name="ln581">    width = pg_width;</a>
<a name="ln582">  else</a>
<a name="ln583">    width = area_width;</a>
<a name="ln584"> </a>
<a name="ln585">  if (area_height==0)</a>
<a name="ln586">    height = pg_height;</a>
<a name="ln587">  else</a>
<a name="ln588">    height = area_height;</a>
<a name="ln589"> </a>
<a name="ln590">  /* here, width and height correspond to the area for the picture */</a>
<a name="ln591"> </a>
<a name="ln592">  // non-printable</a>
<a name="ln593">  double np_top = prt-&gt;printer.hw_margin_top;</a>
<a name="ln594">  double np_left = prt-&gt;printer.hw_margin_left;</a>
<a name="ln595">  double np_right = prt-&gt;printer.hw_margin_right;</a>
<a name="ln596">  double np_bottom = prt-&gt;printer.hw_margin_bottom;</a>
<a name="ln597"> </a>
<a name="ln598">  /* do some arrangements for the landscape mode. */</a>
<a name="ln599"> </a>
<a name="ln600">  if (prt-&gt;page.landscape)</a>
<a name="ln601">  {</a>
<a name="ln602">    double tmp = pg_width;</a>
<a name="ln603">    pg_width = pg_height;</a>
<a name="ln604">    pg_height = tmp;</a>
<a name="ln605"> </a>
<a name="ln606">    //  only invert if we did not get a specific area</a>
<a name="ln607">    if (area_width == 0 &amp;&amp; area_height == 0)</a>
<a name="ln608">    {</a>
<a name="ln609">      tmp = width;</a>
<a name="ln610">      width = height;</a>
<a name="ln611">      height = tmp;</a>
<a name="ln612">    }</a>
<a name="ln613"> </a>
<a name="ln614">    // rotate the non-printable margins</a>
<a name="ln615">    tmp       = np_top;</a>
<a name="ln616">    np_top    = np_right;</a>
<a name="ln617">    np_right  = np_bottom;</a>
<a name="ln618">    np_bottom = np_left;</a>
<a name="ln619">    np_left   = tmp;</a>
<a name="ln620">  }</a>
<a name="ln621"> </a>
<a name="ln622">  // the image area aspect</a>
<a name="ln623">  const double a_aspect = (double)width / (double)height;</a>
<a name="ln624"> </a>
<a name="ln625">  // page aspect</a>
<a name="ln626">  const double pg_aspect = pg_width / pg_height;</a>
<a name="ln627"> </a>
<a name="ln628">  // display page</a>
<a name="ln629">  int32_t p_bottom, p_right;</a>
<a name="ln630"> </a>
<a name="ln631">  if (a_aspect &gt; pg_aspect)</a>
<a name="ln632">  {</a>
<a name="ln633">    *px = (width - (height * pg_aspect)) / 2;</a>
<a name="ln634">    *py = 0;</a>
<a name="ln635">    p_bottom = height;</a>
<a name="ln636">    p_right = width - *px;</a>
<a name="ln637">  }</a>
<a name="ln638">  else</a>
<a name="ln639">  {</a>
<a name="ln640">    *px = 0;</a>
<a name="ln641">    *py = (height - (width / pg_aspect)) / 2;</a>
<a name="ln642">    p_right = width;</a>
<a name="ln643">    p_bottom = height - *py;</a>
<a name="ln644">  }</a>
<a name="ln645"> </a>
<a name="ln646">  *pwidth = p_right - *px;</a>
<a name="ln647">  *pheight = p_bottom - *py;</a>
<a name="ln648"> </a>
<a name="ln649">  // page margins, note that we do not want to change those values for the landscape mode.</a>
<a name="ln650">  // these margins are those set by the user from the GUI, and the top margin is *always*</a>
<a name="ln651">  // at the top of the screen.</a>
<a name="ln652"> </a>
<a name="ln653">  const double border_top = prt-&gt;page.margin_top;</a>
<a name="ln654">  const double border_left = prt-&gt;page.margin_left;</a>
<a name="ln655">  const double border_right = prt-&gt;page.margin_right;</a>
<a name="ln656">  const double border_bottom = prt-&gt;page.margin_bottom;</a>
<a name="ln657"> </a>
<a name="ln658">  // display picture area, that is removing the non printable areas and user's margins</a>
<a name="ln659"> </a>
<a name="ln660">  const int32_t bx = *px + ((np_left + border_left) / pg_width) * (*pwidth);</a>
<a name="ln661">  const int32_t by = *py + ((np_top + border_top)/ pg_height) * (*pheight);</a>
<a name="ln662">  const int32_t bb = p_bottom - ((np_bottom + border_bottom) / pg_height) * (*pheight);</a>
<a name="ln663">  const int32_t br = p_right - ((np_right + border_right) / pg_width) * (*pwidth);</a>
<a name="ln664"> </a>
<a name="ln665">  // now we have the printable area (ax, ay) -&gt; (ax + awidth, ay + aheight)</a>
<a name="ln666"> </a>
<a name="ln667">  *ax      = bx;</a>
<a name="ln668">  *ay      = by;</a>
<a name="ln669">  *awidth  = br - bx;</a>
<a name="ln670">  *aheight = bb - by;</a>
<a name="ln671"> </a>
<a name="ln672">  // get the image dimensions if needed</a>
<a name="ln673"> </a>
<a name="ln674">  if (*iwpix &lt;= 0 || *ihpix &lt;= 0)</a>
<a name="ln675">    dt_image_get_final_size(imgid, iwpix, ihpix);</a>
<a name="ln676"> </a>
<a name="ln677">  // compute the scaling for the image to fit into the printable area</a>
<a name="ln678"> </a>
<a name="ln679">  double scale;</a>
<a name="ln680"> </a>
<a name="ln681">  *iwidth = *iwpix;</a>
<a name="ln682">  *iheight = *ihpix;</a>
<a name="ln683"> </a>
<a name="ln684">  if (*iwidth &gt; *awidth)</a>
<a name="ln685">  {</a>
<a name="ln686">    scale =  (double)(*awidth) / (double)*iwidth;</a>
<a name="ln687">    *iwidth = *awidth;</a>
<a name="ln688">    *iheight = (int32_t)(((double)*iheight + 0.5) * scale);</a>
<a name="ln689">  }</a>
<a name="ln690"> </a>
<a name="ln691">  if (*iheight &gt; *aheight)</a>
<a name="ln692">  {</a>
<a name="ln693">    scale = (double)(*aheight) / (double)*iheight;</a>
<a name="ln694">    *iheight = *aheight;</a>
<a name="ln695">    *iwidth = (int32_t)(((double)*iwidth + 0.5) * scale);</a>
<a name="ln696">  }</a>
<a name="ln697"> </a>
<a name="ln698">  // now the image position (top-left corner coordinates) in the display area depending on the page</a>
<a name="ln699">  // alignment set by the user.</a>
<a name="ln700"> </a>
<a name="ln701">  switch (prt-&gt;page.alignment)</a>
<a name="ln702">  {</a>
<a name="ln703">    case ALIGNMENT_TOP_LEFT:</a>
<a name="ln704">      *ix = bx;</a>
<a name="ln705">      *iy = by;</a>
<a name="ln706">      break;</a>
<a name="ln707">    case ALIGNMENT_TOP:</a>
<a name="ln708">      *ix = bx + (*awidth - *iwidth) / 2;</a>
<a name="ln709">      *iy = by;</a>
<a name="ln710">      break;</a>
<a name="ln711">    case ALIGNMENT_TOP_RIGHT:</a>
<a name="ln712">      *ix = br - *iwidth;</a>
<a name="ln713">      *iy = by;</a>
<a name="ln714">      break;</a>
<a name="ln715">    case ALIGNMENT_LEFT:</a>
<a name="ln716">      *ix = bx;</a>
<a name="ln717">      *iy = by + (*aheight - *iheight) / 2;</a>
<a name="ln718">      break;</a>
<a name="ln719">    case ALIGNMENT_CENTER:</a>
<a name="ln720">      *ix = bx + (*awidth - *iwidth) / 2;</a>
<a name="ln721">      *iy = by + (*aheight - *iheight) / 2;</a>
<a name="ln722">      break;</a>
<a name="ln723">    case ALIGNMENT_RIGHT:</a>
<a name="ln724">      *ix = br - *iwidth;</a>
<a name="ln725">      *iy = by + (*aheight - *iheight) / 2;</a>
<a name="ln726">      break;</a>
<a name="ln727">    case ALIGNMENT_BOTTOM_LEFT:</a>
<a name="ln728">      *ix = bx;</a>
<a name="ln729">      *iy = bb - *iheight;</a>
<a name="ln730">      break;</a>
<a name="ln731">    case ALIGNMENT_BOTTOM:</a>
<a name="ln732">      *ix = bx + (*awidth - *iwidth) / 2;</a>
<a name="ln733">      *iy = bb - *iheight;</a>
<a name="ln734">      break;</a>
<a name="ln735">    case ALIGNMENT_BOTTOM_RIGHT:</a>
<a name="ln736">      *ix = br - *iwidth;</a>
<a name="ln737">      *iy = bb - *iheight;</a>
<a name="ln738">      break;</a>
<a name="ln739">  }</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln743">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln744">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="287"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'paper'. Check lines: 287, 286.</p></div>
<div class="balloon" rel="325"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'paper'. Check lines: 325, 324.</p></div>
<div class="balloon" rel="367"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'media'. Check lines: 367, 366.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
