
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 henrik andersson.</a>
<a name="ln4">    copyright (c) 2016 tobias ellinghaus.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/geo.h&quot;</a>
<a name="ln22">#include &quot;common/curl_tools.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;control/jobs.h&quot;</a>
<a name="ln26">#include &quot;dtgtk/icon.h&quot;</a>
<a name="ln27">#include &quot;gui/gtk.h&quot;</a>
<a name="ln28">#include &quot;libs/lib.h&quot;</a>
<a name="ln29">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln30">#include &lt;curl/curl.h&gt;</a>
<a name="ln31">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">DT_MODULE(1)</a>
<a name="ln34"> </a>
<a name="ln35">typedef enum _lib_location_type_t</a>
<a name="ln36">{</a>
<a name="ln37">  LOCATION_TYPE_VILLAGE,</a>
<a name="ln38">  LOCATION_TYPE_HAMLET,</a>
<a name="ln39">  LOCATION_TYPE_CITY,</a>
<a name="ln40">  LOCATION_TYPE_ADMINISTRATIVE,</a>
<a name="ln41">  LOCATION_TYPE_RESIDENTAL,</a>
<a name="ln42">  LOCATION_TYPE_UNKNOWN</a>
<a name="ln43">} _lib_location_type_t;</a>
<a name="ln44"> </a>
<a name="ln45">typedef struct _lib_location_result_t</a>
<a name="ln46">{</a>
<a name="ln47">  int32_t relevance;</a>
<a name="ln48">  _lib_location_type_t type;</a>
<a name="ln49">  float lon;</a>
<a name="ln50">  float lat;</a>
<a name="ln51">  float bbox_lon1, bbox_lat1, bbox_lon2, bbox_lat2;</a>
<a name="ln52">  dt_geo_map_display_t marker_type;</a>
<a name="ln53">  GList *marker_points;</a>
<a name="ln54">  gchar *name;</a>
<a name="ln55">} _lib_location_result_t;</a>
<a name="ln56"> </a>
<a name="ln57">typedef struct dt_lib_location_t</a>
<a name="ln58">{</a>
<a name="ln59">  GtkEntry *search;</a>
<a name="ln60">  GtkWidget *result;</a>
<a name="ln61">  GList *callback_params;</a>
<a name="ln62"> </a>
<a name="ln63">  GList *places;</a>
<a name="ln64"> </a>
<a name="ln65">  /* result buffer written to by */</a>
<a name="ln66">  gchar *response;</a>
<a name="ln67">  size_t response_size;</a>
<a name="ln68"> </a>
<a name="ln69">  /* pin, track or polygon currently shown on the map */</a>
<a name="ln70">  GObject *marker;</a>
<a name="ln71">  dt_geo_map_display_t marker_type;</a>
<a name="ln72"> </a>
<a name="ln73">  /* remember the currently selected search result so we can put it into a preset */</a>
<a name="ln74">  _lib_location_result_t *selected_location;</a>
<a name="ln75">} dt_lib_location_t;</a>
<a name="ln76"> </a>
<a name="ln77">typedef struct _callback_param_t</a>
<a name="ln78">{</a>
<a name="ln79">  dt_lib_location_t *lib;</a>
<a name="ln80">  _lib_location_result_t *result;</a>
<a name="ln81">} _callback_param_t;</a>
<a name="ln82"> </a>
<a name="ln83">#define LIMIT_RESULT 5</a>
<a name="ln84"> </a>
<a name="ln85">/* entry value committed, perform a search */</a>
<a name="ln86">static void _lib_location_entry_activated(GtkButton *button, gpointer user_data);</a>
<a name="ln87"> </a>
<a name="ln88">static gboolean _lib_location_result_item_activated(GtkButton *button, GdkEventButton *ev, gpointer user_data);</a>
<a name="ln89"> </a>
<a name="ln90">static void _lib_location_parser_start_element(GMarkupParseContext *cxt, const char *element_name,</a>
<a name="ln91">                                               const char **attribute_names, const gchar **attribute_values,</a>
<a name="ln92">                                               gpointer user_data, GError **error);</a>
<a name="ln93"> </a>
<a name="ln94">static void clear_search(dt_lib_location_t *lib);</a>
<a name="ln95"> </a>
<a name="ln96">const char *name(dt_lib_module_t *self)</a>
<a name="ln97">{</a>
<a name="ln98">  return _(&quot;find location&quot;);</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">const char **views(dt_lib_module_t *self)</a>
<a name="ln102">{</a>
<a name="ln103">  static const char *v[] = {&quot;map&quot;, NULL};</a>
<a name="ln104">  return v;</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln108">{</a>
<a name="ln109">  return DT_UI_CONTAINER_PANEL_RIGHT_CENTER;</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112"> </a>
<a name="ln113">void gui_reset(dt_lib_module_t *self)</a>
<a name="ln114">{</a>
<a name="ln115">  dt_lib_location_t *lib = (dt_lib_location_t *)self-&gt;data;</a>
<a name="ln116">  gtk_entry_set_text(lib-&gt;search, &quot;&quot;);</a>
<a name="ln117">  clear_search(lib);</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">int position()</a>
<a name="ln121">{</a>
<a name="ln122">  return 999;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">/*</a>
<a name="ln126">  https://nominatim.openstreetmap.org/search/norrk√∂ping?format=xml&amp;limit=5</a>
<a name="ln127"> */</a>
<a name="ln128">void gui_init(dt_lib_module_t *self)</a>
<a name="ln129">{</a>
<a name="ln130">  self-&gt;data = calloc(1, sizeof(dt_lib_location_t));</a>
<a name="ln131">  dt_lib_location_t *lib = self-&gt;data;</a>
<a name="ln132"> </a>
<a name="ln133">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln134">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln135"> </a>
<a name="ln136">  /* add search box */</a>
<a name="ln137">  lib-&gt;search = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln138">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(lib-&gt;search));</a>
<a name="ln139">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(lib-&gt;search), FALSE, FALSE, 0);</a>
<a name="ln140"> </a>
<a name="ln141">  g_signal_connect(G_OBJECT(lib-&gt;search), &quot;activate&quot;, G_CALLBACK(_lib_location_entry_activated),</a>
<a name="ln142">                   (gpointer)self);</a>
<a name="ln143"> </a>
<a name="ln144">  /* add result vbox */</a>
<a name="ln145">  lib-&gt;result = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln146">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(lib-&gt;result), TRUE, FALSE, DT_PIXEL_APPLY_DPI(2));</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln150">{</a>
<a name="ln151">  dt_lib_location_t *lib = self-&gt;data;</a>
<a name="ln152">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(lib-&gt;search));</a>
<a name="ln153">  free(self-&gt;data);</a>
<a name="ln154">  self-&gt;data = NULL;</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">static GtkWidget *_lib_location_place_widget_new(dt_lib_location_t *lib, _lib_location_result_t *place)</a>
<a name="ln158">{</a>
<a name="ln159">  GtkWidget *eb, *hb, *vb, *w;</a>
<a name="ln160">  eb = gtk_event_box_new();</a>
<a name="ln161">  hb = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, DT_PIXEL_APPLY_DPI(2));</a>
<a name="ln162">  vb = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_PIXEL_APPLY_DPI(2));</a>
<a name="ln163"> </a>
<a name="ln164">  /* add name */</a>
<a name="ln165">  w = gtk_label_new(place-&gt;name);</a>
<a name="ln166">  gtk_label_set_line_wrap(GTK_LABEL(w), TRUE);</a>
<a name="ln167">  gtk_widget_set_halign(w, GTK_ALIGN_START);</a>
<a name="ln168">  g_object_set(G_OBJECT(w), &quot;xalign&quot;, 0.0, (gchar *)0);</a>
<a name="ln169">  gtk_box_pack_start(GTK_BOX(vb), w, FALSE, FALSE, 0);</a>
<a name="ln170"> </a>
<a name="ln171">  /* add location coord */</a>
<a name="ln172">  gchar *lat = dt_util_latitude_str(place-&gt;lat);</a>
<a name="ln173">  gchar *lon = dt_util_longitude_str(place-&gt;lon);</a>
<a name="ln174">  gchar *location = g_strconcat(lat, &quot;, &quot;, lon, NULL);</a>
<a name="ln175">  w = gtk_label_new(location);</a>
<a name="ln176">  g_free(lat);</a>
<a name="ln177">  g_free(lon);</a>
<a name="ln178">  g_free(location);</a>
<a name="ln179">  gtk_label_set_line_wrap(GTK_LABEL(w), TRUE);</a>
<a name="ln180">  gtk_widget_set_halign(w, GTK_ALIGN_START);</a>
<a name="ln181">  gtk_box_pack_start(GTK_BOX(vb), w, FALSE, FALSE, 0);</a>
<a name="ln182"> </a>
<a name="ln183">  /* type icon */</a>
<a name="ln184">  GtkWidget *icon = dtgtk_icon_new(dtgtk_cairo_paint_triangle, CPF_DIRECTION_LEFT, NULL);</a>
<a name="ln185">  gtk_widget_set_size_request(icon, DT_PIXEL_APPLY_DPI(10), -1);</a>
<a name="ln186"> </a>
<a name="ln187">  /* setup layout */</a>
<a name="ln188">  gtk_box_pack_start(GTK_BOX(hb), icon, FALSE, FALSE, DT_PIXEL_APPLY_DPI(2));</a>
<a name="ln189">  gtk_box_pack_start(GTK_BOX(hb), vb, FALSE, FALSE, DT_PIXEL_APPLY_DPI(2));</a>
<a name="ln190">  gtk_container_add(GTK_CONTAINER(eb), hb);</a>
<a name="ln191"> </a>
<a name="ln192">  gtk_widget_show_all(eb);</a>
<a name="ln193"> </a>
<a name="ln194">  /* connect button press signal for result item */</a>
<a name="ln195">  _callback_param_t *param = (_callback_param_t *)malloc(sizeof(_callback_param_t));</a>
<a name="ln196">  lib-&gt;callback_params = g_list_append(lib-&gt;callback_params, param);</a>
<a name="ln197">  param-&gt;lib = lib;</a>
<a name="ln198">  param-&gt;result = place;</a>
<a name="ln199">  g_signal_connect(G_OBJECT(eb), &quot;button-press-event&quot;, G_CALLBACK(_lib_location_result_item_activated),</a>
<a name="ln200">                   (gpointer)param);</a>
<a name="ln201"> </a>
<a name="ln202"> </a>
<a name="ln203">  return eb;</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">static size_t _lib_location_curl_write_data(void *buffer, size_t size, size_t nmemb, void *userp)</a>
<a name="ln207">{</a>
<a name="ln208">  dt_lib_location_t *lib = (dt_lib_location_t *)userp;</a>
<a name="ln209"> </a>
<a name="ln210">  char *newdata = g_malloc0(lib-&gt;response_size + nmemb + 1);</a>
<a name="ln211">  if(lib-&gt;response != NULL) memcpy(newdata, lib-&gt;response, lib-&gt;response_size);</a>
<a name="ln212">  memcpy(newdata + lib-&gt;response_size, buffer, nmemb);</a>
<a name="ln213">  g_free(lib-&gt;response);</a>
<a name="ln214">  lib-&gt;response = newdata;</a>
<a name="ln215">  lib-&gt;response_size += nmemb;</a>
<a name="ln216"> </a>
<a name="ln217">  return nmemb;</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220"> </a>
<a name="ln221">static GMarkupParser _lib_location_parser = { _lib_location_parser_start_element, NULL, NULL, NULL, NULL };</a>
<a name="ln222"> </a>
<a name="ln223"> </a>
<a name="ln224">static int32_t _lib_location_place_get_zoom(_lib_location_result_t *place)</a>
<a name="ln225">{</a>
<a name="ln226">  switch(place-&gt;type)</a>
<a name="ln227">  {</a>
<a name="ln228">    case LOCATION_TYPE_RESIDENTAL:</a>
<a name="ln229">      return 18;</a>
<a name="ln230"> </a>
<a name="ln231">    case LOCATION_TYPE_ADMINISTRATIVE:</a>
<a name="ln232">      return 17;</a>
<a name="ln233"> </a>
<a name="ln234">    case LOCATION_TYPE_VILLAGE:</a>
<a name="ln235">      return 12;</a>
<a name="ln236"> </a>
<a name="ln237">    case LOCATION_TYPE_HAMLET:</a>
<a name="ln238">    case LOCATION_TYPE_CITY:</a>
<a name="ln239">    case LOCATION_TYPE_UNKNOWN:</a>
<a name="ln240">    default:</a>
<a name="ln241">      return 8;</a>
<a name="ln242">  }</a>
<a name="ln243"> </a>
<a name="ln244">  /* should never get here */</a>
<a name="ln245">  return 0;</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">static void _clear_markers(dt_lib_location_t *lib)</a>
<a name="ln249">{</a>
<a name="ln250">  if(lib-&gt;marker_type == MAP_DISPLAY_NONE) return;</a>
<a name="ln251">  dt_view_map_remove_marker(darktable.view_manager, lib-&gt;marker_type, lib-&gt;marker);</a>
<a name="ln252">  g_object_unref(lib-&gt;marker);</a>
<a name="ln253">  lib-&gt;marker = NULL;</a>
<a name="ln254">  lib-&gt;marker_type = MAP_DISPLAY_NONE;</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">static void free_location(_lib_location_result_t *location)</a>
<a name="ln258">{</a>
<a name="ln259">  g_free(location-&gt;name);</a>
<a name="ln260">  g_list_free_full(location-&gt;marker_points, free);</a>
<a name="ln261">  free(location);</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264">static void clear_search(dt_lib_location_t *lib)</a>
<a name="ln265">{</a>
<a name="ln266">  g_free(lib-&gt;response);</a>
<a name="ln267">  lib-&gt;response = NULL;</a>
<a name="ln268">  lib-&gt;response_size = 0;</a>
<a name="ln269">  lib-&gt;selected_location = NULL;</a>
<a name="ln270"> </a>
<a name="ln271">  g_list_free_full(lib-&gt;places, (GDestroyNotify)free_location);</a>
<a name="ln272">  lib-&gt;places = NULL;</a>
<a name="ln273"> </a>
<a name="ln274">  gtk_container_foreach(GTK_CONTAINER(lib-&gt;result), (GtkCallback)gtk_widget_destroy, NULL);</a>
<a name="ln275">  g_list_free_full(lib-&gt;callback_params, free);</a>
<a name="ln276">  lib-&gt;callback_params = NULL;</a>
<a name="ln277"> </a>
<a name="ln278">  _clear_markers(lib);</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">static void _show_location(dt_lib_location_t *lib, _lib_location_result_t *p)</a>
<a name="ln282">{</a>
<a name="ln283">  if(isnan(p-&gt;bbox_lon1) || isnan(p-&gt;bbox_lat1) || isnan(p-&gt;bbox_lon2) || isnan(p-&gt;bbox_lat2))</a>
<a name="ln284">  {</a>
<a name="ln285">    int32_t zoom = _lib_location_place_get_zoom(p);</a>
<a name="ln286">    dt_view_map_center_on_location(darktable.view_manager, p-&gt;lon, p-&gt;lat, zoom);</a>
<a name="ln287">  }</a>
<a name="ln288">  else</a>
<a name="ln289">  {</a>
<a name="ln290">    dt_view_map_center_on_bbox(darktable.view_manager, p-&gt;bbox_lon1, p-&gt;bbox_lat1, p-&gt;bbox_lon2, p-&gt;bbox_lat2);</a>
<a name="ln291">  }</a>
<a name="ln292"> </a>
<a name="ln293">  _clear_markers(lib);</a>
<a name="ln294"> </a>
<a name="ln295">  lib-&gt;marker = dt_view_map_add_marker(darktable.view_manager, p-&gt;marker_type, p-&gt;marker_points);</a>
<a name="ln296">  lib-&gt;marker_type = p-&gt;marker_type;</a>
<a name="ln297">  lib-&gt;selected_location = p;</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">/* called when search job has been processed and</a>
<a name="ln301">   result has been parsed */</a>
<a name="ln302">static void _lib_location_search_finish(gpointer user_data)</a>
<a name="ln303">{</a>
<a name="ln304">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln305">  dt_lib_location_t *lib = (dt_lib_location_t *)self-&gt;data;</a>
<a name="ln306"> </a>
<a name="ln307">  /* check if search gave us some result */</a>
<a name="ln308">  if(!lib-&gt;places) return;</a>
<a name="ln309"> </a>
<a name="ln310">  /* for each location found populate the result list */</a>
<a name="ln311">  GList *item = lib-&gt;places;</a>
<a name="ln312">  do</a>
<a name="ln313">  {</a>
<a name="ln314">    _lib_location_result_t *place = (_lib_location_result_t *)item-&gt;data;</a>
<a name="ln315">    gtk_box_pack_start(GTK_BOX(lib-&gt;result), _lib_location_place_widget_new(lib, place), TRUE, TRUE, 0);</a>
<a name="ln316">    gtk_widget_show(lib-&gt;result);</a>
<a name="ln317">  } while((item = g_list_next(item)) != NULL);</a>
<a name="ln318"> </a>
<a name="ln319">  /* if we only got one search result back lets</a>
<a name="ln320">     set center location and zoom based on place type  */</a>
<a name="ln321">  if(g_list_length(lib-&gt;places) == 1)</a>
<a name="ln322">  {</a>
<a name="ln323">    _lib_location_result_t *place = (_lib_location_result_t *)lib-&gt;places-&gt;data;</a>
<a name="ln324">    _show_location(lib, place);</a>
<a name="ln325">  }</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">static gboolean _lib_location_search(gpointer user_data)</a>
<a name="ln329">{</a>
<a name="ln330">  GMarkupParseContext *ctx = NULL;</a>
<a name="ln331">  CURL *curl = NULL;</a>
<a name="ln332">  CURLcode res;</a>
<a name="ln333">  GError *err = NULL;</a>
<a name="ln334"> </a>
<a name="ln335">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln336">  dt_lib_location_t *lib = (dt_lib_location_t *)self-&gt;data;</a>
<a name="ln337">  gchar *query = NULL, *text = NULL, *search_url = NULL;</a>
<a name="ln338"> </a>
<a name="ln339">  /* get escaped search text */</a>
<a name="ln340">  text = g_uri_escape_string(gtk_entry_get_text(lib-&gt;search), NULL, FALSE);</a>
<a name="ln341"> </a>
<a name="ln342">  if(!(text &amp;&amp; *text)) goto bail_out;</a>
<a name="ln343"> </a>
<a name="ln344">  /* clean up previous results before adding new */</a>
<a name="ln345">  clear_search(lib);</a>
<a name="ln346"> </a>
<a name="ln347">  /* build the query url */</a>
<a name="ln348">  search_url = dt_conf_get_string(&quot;plugins/map/geotagging_search_url&quot;);</a>
<a name="ln349">  query = dt_util_dstrcat(query, search_url, text, LIMIT_RESULT);</a>
<a name="ln350">  /* load url */</a>
<a name="ln351">  curl = curl_easy_init();</a>
<a name="ln352">  if(!curl) goto bail_out;</a>
<a name="ln353"> </a>
<a name="ln354">  dt_curl_init(curl, FALSE);</a>
<a name="ln355"> </a>
<a name="ln356">  curl_easy_setopt(curl, CURLOPT_URL, query);</a>
<a name="ln357">  curl_easy_setopt(curl, CURLOPT_WRITEDATA, lib);</a>
<a name="ln358">  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, _lib_location_curl_write_data);</a>
<a name="ln359">  curl_easy_setopt(curl, CURLOPT_USERAGENT, (char *)darktable_package_string);</a>
<a name="ln360">  curl_easy_setopt(curl, CURLOPT_TIMEOUT, 20L);</a>
<a name="ln361"> </a>
<a name="ln362">  res = curl_easy_perform(curl);</a>
<a name="ln363">  if(res != 0) goto bail_out;</a>
<a name="ln364"> </a>
<a name="ln365">  if(!lib-&gt;response) goto bail_out;</a>
<a name="ln366"> </a>
<a name="ln367">  /* parse xml response and populate the result list */</a>
<a name="ln368">  ctx = g_markup_parse_context_new(&amp;_lib_location_parser, 0, lib, NULL);</a>
<a name="ln369">  g_markup_parse_context_parse(ctx, lib-&gt;response, lib-&gt;response_size, &amp;err);</a>
<a name="ln370">  if(err) goto bail_out;</a>
<a name="ln371"> </a>
<a name="ln372">  /* add the places into the result list */</a>
<a name="ln373">  GList *item = lib-&gt;places;</a>
<a name="ln374">  if(!item) goto bail_out;</a>
<a name="ln375"> </a>
<a name="ln376">//   while(item)</a>
<a name="ln377">//   {</a>
<a name="ln378">//     _lib_location_result_t *p = (_lib_location_result_t *)item-&gt;data;</a>
<a name="ln379">//     fprintf(stderr, &quot;(%f,%f) %s\n&quot;, p-&gt;lon, p-&gt;lat, p-&gt;name);</a>
<a name="ln380">//     item = g_list_next(item);</a>
<a name="ln381">//   }</a>
<a name="ln382"> </a>
<a name="ln383">/* cleanup an exit search job */</a>
<a name="ln384">bail_out:</a>
<a name="ln385">  if(err)</a>
<a name="ln386">  {</a>
<a name="ln387">    fprintf(stderr, &quot;location search: %s\n&quot;, err-&gt;message);</a>
<a name="ln388">    g_error_free(err);</a>
<a name="ln389">  }</a>
<a name="ln390"> </a>
<a name="ln391">  if(curl) curl_easy_cleanup(curl);</a>
<a name="ln392"> </a>
<a name="ln393">  g_free(text);</a>
<a name="ln394">  g_free(query);</a>
<a name="ln395">  g_free(search_url);</a>
<a name="ln396"> </a>
<a name="ln397">  if(ctx) g_markup_parse_context_free(ctx);</a>
<a name="ln398"> </a>
<a name="ln399">  /* enable the widgets */</a>
<a name="ln400">  gtk_widget_set_sensitive(GTK_WIDGET(lib-&gt;search), TRUE);</a>
<a name="ln401">  // gtk_widget_set_sensitive(lib-&gt;result, FALSE);</a>
<a name="ln402"> </a>
<a name="ln403">  return FALSE;</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">gboolean _lib_location_result_item_activated(GtkButton *button, GdkEventButton *ev, gpointer user_data)</a>
<a name="ln407">{</a>
<a name="ln408">  _callback_param_t *param = (_callback_param_t *)user_data;</a>
<a name="ln409">  dt_lib_location_t *lib = param-&gt;lib;</a>
<a name="ln410">  _lib_location_result_t *result = param-&gt;result;</a>
<a name="ln411">  _show_location(lib, result);</a>
<a name="ln412">  return TRUE;</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">void _lib_location_entry_activated(GtkButton *button, gpointer user_data)</a>
<a name="ln416">{</a>
<a name="ln417">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln418">  dt_lib_location_t *lib = (dt_lib_location_t *)self-&gt;data;</a>
<a name="ln419">  const gchar *text = gtk_entry_get_text(lib-&gt;search);</a>
<a name="ln420">  if(!text || text[0] == '\0') return;</a>
<a name="ln421"> </a>
<a name="ln422">  /* lock the widget while search job is performing */</a>
<a name="ln423">  gtk_widget_set_sensitive(GTK_WIDGET(lib-&gt;search), FALSE);</a>
<a name="ln424">  // gtk_widget_set_sensitive(lib-&gt;result, FALSE);</a>
<a name="ln425"> </a>
<a name="ln426">  /* start a bg job for fetching results of a search */</a>
<a name="ln427">  g_idle_add_full(G_PRIORITY_DEFAULT_IDLE, _lib_location_search, user_data, _lib_location_search_finish);</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430"> </a>
<a name="ln431">static void _lib_location_parser_start_element(GMarkupParseContext *cxt, const char *element_name,</a>
<a name="ln432">                                               const char **attribute_names, const gchar **attribute_values,</a>
<a name="ln433">                                               gpointer user_data, GError **e)</a>
<a name="ln434">{</a>
<a name="ln435">  dt_lib_location_t *lib = (dt_lib_location_t *)user_data;</a>
<a name="ln436"> </a>
<a name="ln437">  /* only interested in place element */</a>
<a name="ln438">  if(strcmp(element_name, &quot;place&quot;) != 0) return;</a>
<a name="ln439"> </a>
<a name="ln440">  /* create new place */</a>
<a name="ln441">  _lib_location_result_t *place = g_malloc0(sizeof(_lib_location_result_t));</a>
<a name="ln442">  if(!place) return;</a>
<a name="ln443"> </a>
<a name="ln444">  place-&gt;lon = NAN;</a>
<a name="ln445">  place-&gt;lat = NAN;</a>
<a name="ln446">  place-&gt;bbox_lon1 = NAN;</a>
<a name="ln447">  place-&gt;bbox_lat1 = NAN;</a>
<a name="ln448">  place-&gt;bbox_lon2 = NAN;</a>
<a name="ln449">  place-&gt;bbox_lat2 = NAN;</a>
<a name="ln450">  place-&gt;marker_type = MAP_DISPLAY_NONE;</a>
<a name="ln451">  place-&gt;marker_points = NULL;</a>
<a name="ln452"> </a>
<a name="ln453">  gboolean show_outline = dt_conf_get_bool(&quot;plugins/map/show_outline&quot;);</a>
<a name="ln454">  int max_outline_nodes = dt_conf_get_int(&quot;plugins/map/max_outline_nodes&quot;);</a>
<a name="ln455"> </a>
<a name="ln456">  /* handle the element attribute values */</a>
<a name="ln457">  const gchar **aname = attribute_names;</a>
<a name="ln458">  const gchar **avalue = attribute_values;</a>
<a name="ln459">  if(*aname)</a>
<a name="ln460">  {</a>
<a name="ln461">    while(*aname)</a>
<a name="ln462">    {</a>
<a name="ln463">      if(strcmp(*aname, &quot;display_name&quot;) == 0)</a>
<a name="ln464">      {</a>
<a name="ln465">        place-&gt;name = g_strdup(*avalue);</a>
<a name="ln466">        if(!(place-&gt;name)) goto bail_out;</a>
<a name="ln467">      }</a>
<a name="ln468">      else if(strcmp(*aname, &quot;lon&quot;) == 0)</a>
<a name="ln469">        place-&gt;lon = g_strtod(*avalue, NULL);</a>
<a name="ln470">      else if(strcmp(*aname, &quot;lat&quot;) == 0)</a>
<a name="ln471">        place-&gt;lat = g_strtod(*avalue, NULL);</a>
<a name="ln472">      else if(strcmp(*aname, &quot;boundingbox&quot;) == 0)</a>
<a name="ln473">      {</a>
<a name="ln474">        char *endptr;</a>
<a name="ln475">        float lon1, lat1, lon2, lat2;</a>
<a name="ln476"> </a>
<a name="ln477">        lat1 = g_ascii_strtod(*avalue, &amp;endptr);</a>
<a name="ln478">        if(*endptr != ',') goto broken_bbox;</a>
<a name="ln479">        endptr++;</a>
<a name="ln480"> </a>
<a name="ln481">        lat2 = g_ascii_strtod(endptr, &amp;endptr);</a>
<a name="ln482">        if(*endptr != ',') goto broken_bbox;</a>
<a name="ln483">        endptr++;</a>
<a name="ln484"> </a>
<a name="ln485">        lon1 = g_ascii_strtod(endptr, &amp;endptr);</a>
<a name="ln486">        if(*endptr != ',') goto broken_bbox;</a>
<a name="ln487">        endptr++;</a>
<a name="ln488"> </a>
<a name="ln489">        lon2 = g_ascii_strtod(endptr, &amp;endptr);</a>
<a name="ln490">        if(*endptr != '\0') goto broken_bbox;</a>
<a name="ln491"> </a>
<a name="ln492">        place-&gt;bbox_lon1 = lon1;</a>
<a name="ln493">        place-&gt;bbox_lat1 = lat1;</a>
<a name="ln494">        place-&gt;bbox_lon2 = lon2;</a>
<a name="ln495">        place-&gt;bbox_lat2 = lat2;</a>
<a name="ln496">broken_bbox:</a>
<a name="ln497">        ;</a>
<a name="ln498">      }</a>
<a name="ln499">      // only use the first 'geotext' entry</a>
<a name="ln500">      else if(show_outline &amp;&amp;</a>
<a name="ln501">              strcmp(*aname, &quot;geotext&quot;) == 0 &amp;&amp;</a>
<a name="ln502">              place-&gt;marker_type == MAP_DISPLAY_NONE)</a>
<a name="ln503">      {</a>
<a name="ln504">        if(g_str_has_prefix(*avalue, &quot;POINT&quot;))</a>
<a name="ln505">        {</a>
<a name="ln506">          char *endptr;</a>
<a name="ln507">          float lon = g_ascii_strtod(*avalue + strlen(&quot;POINT(&quot;), &amp;endptr);</a>
<a name="ln508">          float lat = g_ascii_strtod(endptr, &amp;endptr);</a>
<a name="ln509">          if(*endptr == ')')</a>
<a name="ln510">          {</a>
<a name="ln511">            place-&gt;marker_type = MAP_DISPLAY_POINT;</a>
<a name="ln512">            dt_geo_map_display_point_t *p = malloc(sizeof(dt_geo_map_display_point_t));</a>
<a name="ln513">            p-&gt;lon = lon;</a>
<a name="ln514">            p-&gt;lat = lat;</a>
<a name="ln515">            place-&gt;marker_points = g_list_append(place-&gt;marker_points, p);</a>
<a name="ln516">          }</a>
<a name="ln517">        }</a>
<a name="ln518">        else if(g_str_has_prefix(*avalue, &quot;LINESTRING&quot;)</a>
<a name="ln519">#ifdef HAVE_OSMGPSMAP_110_OR_NEWER</a>
<a name="ln520">                || g_str_has_prefix(*avalue, &quot;POLYGON&quot;)</a>
<a name="ln521">                || g_str_has_prefix(*avalue, &quot;MULTIPOLYGON&quot;)</a>
<a name="ln522">#endif</a>
<a name="ln523">        )</a>
<a name="ln524">        {</a>
<a name="ln525">          gboolean error = FALSE;</a>
<a name="ln526">          const char *startptr = *avalue;</a>
<a name="ln527">          char *endptr;</a>
<a name="ln528">          while(startptr &amp;&amp; (*startptr == ' ' || *startptr == '(' || (*startptr &gt;= 'A' &amp;&amp; *startptr &lt;= 'Z')))</a>
<a name="ln529">            startptr++;</a>
<a name="ln530"> </a>
<a name="ln531">          int i = 0;</a>
<a name="ln532">          while(1)</a>
<a name="ln533">          {</a>
<a name="ln534">            float lon = g_ascii_strtod(startptr, &amp;endptr);</a>
<a name="ln535">            float lat = g_ascii_strtod(endptr, &amp;endptr);</a>
<a name="ln536"> </a>
<a name="ln537">            if(*endptr == ')') break; // TODO: support holes in POLYGON and several forms in MULTIPOLYGON?</a>
<a name="ln538">            if(*endptr != ',' || i &gt; max_outline_nodes) // don't go too big for speed reasons</a>
<a name="ln539">            {</a>
<a name="ln540">              error = TRUE;</a>
<a name="ln541">              break;</a>
<a name="ln542">            }</a>
<a name="ln543">            dt_geo_map_display_point_t *p = malloc(sizeof(dt_geo_map_display_point_t));</a>
<a name="ln544">            p-&gt;lon = lon;</a>
<a name="ln545">            p-&gt;lat = lat;</a>
<a name="ln546">            place-&gt;marker_points = g_list_append(place-&gt;marker_points, p);</a>
<a name="ln547">            startptr = endptr+1;</a>
<a name="ln548">            i++;</a>
<a name="ln549">          }</a>
<a name="ln550"> </a>
<a name="ln551">          if(error)</a>
<a name="ln552">          {</a>
<a name="ln553">            g_list_free_full(place-&gt;marker_points, free);</a>
<a name="ln554">            place-&gt;marker_points = NULL;</a>
<a name="ln555">          }</a>
<a name="ln556">          else</a>
<a name="ln557">          {</a>
<a name="ln558">            place-&gt;marker_type = g_str_has_prefix(*avalue, &quot;LINESTRING&quot;) ? MAP_DISPLAY_TRACK : MAP_DISPLAY_POLYGON;</a>
<a name="ln559">          }</a>
<a name="ln560">        }</a>
<a name="ln561">        else</a>
<a name="ln562">        {</a>
<a name="ln563">          gchar *s = g_strndup(*avalue, 100);</a>
<a name="ln564">          fprintf(stderr, &quot;unsupported outline: %s%s\n&quot;, s, strlen(s) == strlen(*avalue) ? &quot;&quot; : &quot; ...&quot;);</a>
<a name="ln565">          g_free(s);</a>
<a name="ln566">        }</a>
<a name="ln567">      }</a>
<a name="ln568">      else if(strcmp(*aname, &quot;type&quot;) == 0)</a>
<a name="ln569">      {</a>
<a name="ln570"> </a>
<a name="ln571">        if(strcmp(*avalue, &quot;village&quot;) == 0)</a>
<a name="ln572">          place-&gt;type = LOCATION_TYPE_RESIDENTAL;</a>
<a name="ln573">        else if(strcmp(*avalue, &quot;hamlet&quot;) == 0)</a>
<a name="ln574">          place-&gt;type = LOCATION_TYPE_HAMLET;</a>
<a name="ln575">        else if(strcmp(*avalue, &quot;city&quot;) == 0)</a>
<a name="ln576">          place-&gt;type = LOCATION_TYPE_CITY;</a>
<a name="ln577">        else if(strcmp(*avalue, &quot;administrative&quot;) == 0)</a>
<a name="ln578">          place-&gt;type = LOCATION_TYPE_ADMINISTRATIVE;</a>
<a name="ln579">        else if(strcmp(*avalue, &quot;residental&quot;) == 0)</a>
<a name="ln580">          place-&gt;type = LOCATION_TYPE_RESIDENTAL;</a>
<a name="ln581">      }</a>
<a name="ln582"> </a>
<a name="ln583">      aname++;</a>
<a name="ln584">      avalue++;</a>
<a name="ln585">    }</a>
<a name="ln586">  }</a>
<a name="ln587"> </a>
<a name="ln588">  /* check if we got sane data */</a>
<a name="ln589">  if(isnan(place-&gt;lon) || isnan(place-&gt;lat)) goto bail_out;</a>
<a name="ln590"> </a>
<a name="ln591">  /* add place to result list */</a>
<a name="ln592">  lib-&gt;places = g_list_append(lib-&gt;places, place);</a>
<a name="ln593"> </a>
<a name="ln594">  return;</a>
<a name="ln595"> </a>
<a name="ln596">bail_out:</a>
<a name="ln597">  g_free(place-&gt;name);</a>
<a name="ln598">  g_free(place);</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">void init_presets(dt_lib_module_t *self)</a>
<a name="ln602">{}</a>
<a name="ln603"> </a>
<a name="ln604">struct params_fixed_t</a>
<a name="ln605">{</a>
<a name="ln606">  int32_t relevance;</a>
<a name="ln607">  _lib_location_type_t type;</a>
<a name="ln608">  float lon;</a>
<a name="ln609">  float lat;</a>
<a name="ln610">  float bbox_lon1, bbox_lat1, bbox_lon2, bbox_lat2;</a>
<a name="ln611">  dt_geo_map_display_t marker_type;</a>
<a name="ln612">} __attribute__((packed));</a>
<a name="ln613"> </a>
<a name="ln614">void *get_params(dt_lib_module_t *self, int *size)</a>
<a name="ln615">{</a>
<a name="ln616">  dt_lib_location_t *lib = (dt_lib_location_t *)self-&gt;data;</a>
<a name="ln617">  _lib_location_result_t *location = lib-&gt;selected_location;</a>
<a name="ln618"> </a>
<a name="ln619">  // we have nothing to store when the user hasn't picked a search result</a>
<a name="ln620">  if(location == NULL) return NULL;</a>
<a name="ln621"> </a>
<a name="ln622">  const size_t size_fixed = sizeof(struct params_fixed_t);</a>
<a name="ln623">  const size_t size_name = strlen(location-&gt;name) + 1;</a>
<a name="ln624">  const size_t size_points = 2 * sizeof(float) * g_list_length(location-&gt;marker_points);</a>
<a name="ln625">  const size_t size_total = size_fixed + size_name + size_points;</a>
<a name="ln626"> </a>
<a name="ln627">  void *params = malloc(size_total);</a>
<a name="ln628">  struct params_fixed_t *params_fixed = (struct params_fixed_t *)params;</a>
<a name="ln629">  params_fixed-&gt;relevance = location-&gt;relevance;</a>
<a name="ln630">  params_fixed-&gt;type = location-&gt;type;</a>
<a name="ln631">  params_fixed-&gt;lon = location-&gt;lon;</a>
<a name="ln632">  params_fixed-&gt;lat = location-&gt;lat;</a>
<a name="ln633">  params_fixed-&gt;bbox_lon1 = location-&gt;bbox_lon1;</a>
<a name="ln634">  params_fixed-&gt;bbox_lat1 = location-&gt;bbox_lat1;</a>
<a name="ln635">  params_fixed-&gt;bbox_lon2 = location-&gt;bbox_lon2;</a>
<a name="ln636">  params_fixed-&gt;bbox_lat2 = location-&gt;bbox_lat2;</a>
<a name="ln637">  params_fixed-&gt;marker_type = location-&gt;marker_type;</a>
<a name="ln638"> </a>
<a name="ln639">  memcpy(params + size_fixed, location-&gt;name, size_name);</a>
<a name="ln640"> </a>
<a name="ln641">  float *points = (float *)(params + size_fixed + size_name);</a>
<a name="ln642">  for(GList *iter = location-&gt;marker_points; iter; iter = g_list_next(iter), points += 2)</a>
<a name="ln643">  {</a>
<a name="ln644">    dt_geo_map_display_point_t *point = (dt_geo_map_display_point_t *)iter-&gt;data;</a>
<a name="ln645">    points[0] = point-&gt;lat;</a>
<a name="ln646">    points[1] = point-&gt;lon;</a>
<a name="ln647">  }</a>
<a name="ln648"> </a>
<a name="ln649">  *size = size_total;</a>
<a name="ln650">  return params;</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">int set_params(dt_lib_module_t *self, const void *params, int size)</a>
<a name="ln654">{</a>
<a name="ln655">  dt_lib_location_t *lib = (dt_lib_location_t *)self-&gt;data;</a>
<a name="ln656"> </a>
<a name="ln657">  const size_t size_fixed = sizeof(struct params_fixed_t);</a>
<a name="ln658"> </a>
<a name="ln659">  if(size &lt; size_fixed) return 1;</a>
<a name="ln660"> </a>
<a name="ln661">  const struct params_fixed_t *params_fixed = (struct params_fixed_t *)params;</a>
<a name="ln662">  const char *name = (char *)(params + size_fixed);</a>
<a name="ln663">  const size_t size_name = strlen(name) + 1;</a>
<a name="ln664"> </a>
<a name="ln665">  if(size_fixed + size_name &gt; size) return 1;</a>
<a name="ln666"> </a>
<a name="ln667">  const size_t size_points = size - (size_fixed + size_name);</a>
<a name="ln668"> </a>
<a name="ln669">  if(size_points % 2 * sizeof(float) != 0) return 1;</a>
<a name="ln670"> </a>
<a name="ln671">  _lib_location_result_t *location = (_lib_location_result_t *)malloc(sizeof(_lib_location_result_t));</a>
<a name="ln672"> </a>
<a name="ln673">  location-&gt;relevance = params_fixed-&gt;relevance;</a>
<a name="ln674">  location-&gt;type = params_fixed-&gt;type;</a>
<a name="ln675">  location-&gt;lon = params_fixed-&gt;lon;</a>
<a name="ln676">  location-&gt;lat = params_fixed-&gt;lat;</a>
<a name="ln677">  location-&gt;bbox_lon1 = params_fixed-&gt;bbox_lon1;</a>
<a name="ln678">  location-&gt;bbox_lat1 = params_fixed-&gt;bbox_lat1;</a>
<a name="ln679">  location-&gt;bbox_lon2 = params_fixed-&gt;bbox_lon2;</a>
<a name="ln680">  location-&gt;bbox_lat2 = params_fixed-&gt;bbox_lat2;</a>
<a name="ln681">  location-&gt;marker_type = params_fixed-&gt;marker_type;</a>
<a name="ln682">  location-&gt;name = g_strdup(name);</a>
<a name="ln683">  location-&gt;marker_points = NULL;</a>
<a name="ln684"> </a>
<a name="ln685">  for(const float *points = (float *)(params + size_fixed + size_name); (void *)points &lt; params + size; points += 2)</a>
<a name="ln686">  {</a>
<a name="ln687">    dt_geo_map_display_point_t *p = (dt_geo_map_display_point_t *)malloc(sizeof(dt_geo_map_display_point_t));</a>
<a name="ln688">    p-&gt;lat = points[0];</a>
<a name="ln689">    p-&gt;lon = points[1];</a>
<a name="ln690">    location-&gt;marker_points = g_list_append(location-&gt;marker_points, p);</a>
<a name="ln691">  }</a>
<a name="ln692"> </a>
<a name="ln693">  clear_search(lib);</a>
<a name="ln694">  lib-&gt;places = g_list_append(lib-&gt;places, location);</a>
<a name="ln695">  gtk_entry_set_text(lib-&gt;search, &quot;&quot;);</a>
<a name="ln696">  _lib_location_search_finish(self);</a>
<a name="ln697"> </a>
<a name="ln698">  return 0;</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln702">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln703">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="137"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lib'. Check lines: 137, 130.</p></div>
<div class="balloon" rel="197"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'param'. Check lines: 197, 195.</p></div>
<div class="balloon" rel="357"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'lib' class object.</p></div>
<div class="balloon" rel="513"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'p'. Check lines: 513, 512.</p></div>
<div class="balloon" rel="544"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'p'. Check lines: 544, 543.</p></div>
<div class="balloon" rel="629"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'params_fixed'. Check lines: 629, 627.</p></div>
<div class="balloon" rel="639"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'params' pointer in the 'params + size_fixed' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 639, 627.</p></div>
<div class="balloon" rel="673"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'location'. Check lines: 673, 671.</p></div>
<div class="balloon" rel="688"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'p'. Check lines: 688, 687.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
