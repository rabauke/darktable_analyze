
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011--2014 Ulrich Pegelow.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;develop/tiling.h&quot;</a>
<a name="ln21">#include &quot;common/opencl.h&quot;</a>
<a name="ln22">#include &quot;control/control.h&quot;</a>
<a name="ln23">#include &quot;develop/blend.h&quot;</a>
<a name="ln24">#include &quot;develop/pixelpipe.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;assert.h&gt;</a>
<a name="ln27">#include &lt;math.h&gt;</a>
<a name="ln28">#include &lt;stdlib.h&gt;</a>
<a name="ln29">#include &lt;string.h&gt;</a>
<a name="ln30">#include &lt;strings.h&gt;</a>
<a name="ln31">#include &lt;unistd.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#define CLAMPI(a, mn, mx) ((a) &lt; (mn) ? (mn) : ((a) &gt; (mx) ? (mx) : (a)))</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">/* this defines an additional alignment requirement for opencl image width.</a>
<a name="ln37">   It can have strong effects on processing speed. Reasonable values are a</a>
<a name="ln38">   power of 2. set to 1 for no effect. */</a>
<a name="ln39">#define CL_ALIGNMENT 4</a>
<a name="ln40"> </a>
<a name="ln41">/* parameter RESERVE for extended roi_in sizes due to inaccuracies when doing</a>
<a name="ln42">   roi_out -&gt; roi_in estimations.</a>
<a name="ln43">   Needs to be increased if tiling fails due to insufficient buffer sizes. */</a>
<a name="ln44">#define RESERVE 5</a>
<a name="ln45"> </a>
<a name="ln46"> </a>
<a name="ln47">/* greatest common divisor */</a>
<a name="ln48">static unsigned _gcd(unsigned a, unsigned b)</a>
<a name="ln49">{</a>
<a name="ln50">  unsigned t;</a>
<a name="ln51">  while(b != 0)</a>
<a name="ln52">  {</a>
<a name="ln53">    t = b;</a>
<a name="ln54">    b = a % b;</a>
<a name="ln55">    a = t;</a>
<a name="ln56">  }</a>
<a name="ln57">  return a;</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">/* least common multiple */</a>
<a name="ln61">static unsigned _lcm(unsigned a, unsigned b)</a>
<a name="ln62">{</a>
<a name="ln63">  return (((unsigned long)a * b) / _gcd(a, b));</a>
<a name="ln64">}</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">static inline int _min(int a, int b)</a>
<a name="ln68">{</a>
<a name="ln69">  return a &lt; b ? a : b;</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">static inline int _max(int a, int b)</a>
<a name="ln73">{</a>
<a name="ln74">  return a &gt; b ? a : b;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">static inline int _align_up(int n, int a)</a>
<a name="ln79">{</a>
<a name="ln80">  return n % a != 0 ? (n / a + 1) * a : n;</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">static inline int _align_down(int n, int a)</a>
<a name="ln84">{</a>
<a name="ln85">  return n % a != 0 ? (n / a) * a : n;</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88"> </a>
<a name="ln89">void _print_roi(const dt_iop_roi_t *roi, const char *label)</a>
<a name="ln90">{</a>
<a name="ln91">  printf(&quot;{ %5d  %5d  %5d  %5d  %.6f } %s\n&quot;, roi-&gt;x, roi-&gt;y, roi-&gt;width, roi-&gt;height, roi-&gt;scale, label);</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">#if 0</a>
<a name="ln96">static void</a>
<a name="ln97">_nm_constraints(double x[], int n)</a>
<a name="ln98">{</a>
<a name="ln99">  x[0] = fabs(x[0]);</a>
<a name="ln100">  x[1] = fabs(x[1]);</a>
<a name="ln101">  x[2] = fabs(x[2]);</a>
<a name="ln102">  x[3] = fabs(x[3]);</a>
<a name="ln103"> </a>
<a name="ln104">  if(x[0] &gt; 1.0) x[0] = 1.0 - x[0];</a>
<a name="ln105">  if(x[1] &gt; 1.0) x[1] = 1.0 - x[1];</a>
<a name="ln106">  if(x[2] &gt; 1.0) x[2] = 1.0 - x[2];</a>
<a name="ln107">  if(x[3] &gt; 1.0) x[3] = 1.0 - x[3];</a>
<a name="ln108"> </a>
<a name="ln109">}</a>
<a name="ln110">#endif</a>
<a name="ln111"> </a>
<a name="ln112">static double _nm_fitness(double x[], void *rest[])</a>
<a name="ln113">{</a>
<a name="ln114">  struct dt_iop_module_t *self = (struct dt_iop_module_t *)rest[0];</a>
<a name="ln115">  struct dt_dev_pixelpipe_iop_t *piece = (struct dt_dev_pixelpipe_iop_t *)rest[1];</a>
<a name="ln116">  struct dt_iop_roi_t *iroi = (struct dt_iop_roi_t *)rest[2];</a>
<a name="ln117">  struct dt_iop_roi_t *oroi = (struct dt_iop_roi_t *)rest[3];</a>
<a name="ln118"> </a>
<a name="ln119">  dt_iop_roi_t oroi_test = *oroi;</a>
<a name="ln120">  oroi_test.x = x[0] * piece-&gt;iwidth;</a>
<a name="ln121">  oroi_test.y = x[1] * piece-&gt;iheight;</a>
<a name="ln122">  oroi_test.width = x[2] * piece-&gt;iwidth;</a>
<a name="ln123">  oroi_test.height = x[3] * piece-&gt;iheight;</a>
<a name="ln124"> </a>
<a name="ln125">  dt_iop_roi_t iroi_probe = *iroi;</a>
<a name="ln126">  self-&gt;modify_roi_in(self, piece, &amp;oroi_test, &amp;iroi_probe);</a>
<a name="ln127"> </a>
<a name="ln128">  double fitness = 0.0;</a>
<a name="ln129"> </a>
<a name="ln130">  fitness += (double)(iroi_probe.x - iroi-&gt;x) * (iroi_probe.x - iroi-&gt;x);</a>
<a name="ln131">  fitness += (double)(iroi_probe.y - iroi-&gt;y) * (iroi_probe.y - iroi-&gt;y);</a>
<a name="ln132">  fitness += (double)(iroi_probe.width - iroi-&gt;width) * (iroi_probe.width - iroi-&gt;width);</a>
<a name="ln133">  fitness += (double)(iroi_probe.height - iroi-&gt;height) * (iroi_probe.height - iroi-&gt;height);</a>
<a name="ln134"> </a>
<a name="ln135">  return fitness;</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138"> </a>
<a name="ln139">/* We use a Nelder-Mead simplex algorithm based on an implementation of Michael F. Hutt.</a>
<a name="ln140">   It is covered by the following copyright notice: */</a>
<a name="ln141">/*</a>
<a name="ln142"> * Program: nmsimplex.c</a>
<a name="ln143"> * Author : Michael F. Hutt</a>
<a name="ln144"> * http://www.mikehutt.com</a>
<a name="ln145"> * 11/3/97</a>
<a name="ln146"> *</a>
<a name="ln147"> * An implementation of the Nelder-Mead simplex method.</a>
<a name="ln148"> *</a>
<a name="ln149"> * Copyright (c) 1997-2011 &lt;Michael F. Hutt&gt;</a>
<a name="ln150"> *</a>
<a name="ln151"> * Permission is hereby granted, free of charge, to any person obtaining</a>
<a name="ln152"> * a copy of this software and associated documentation files (the</a>
<a name="ln153"> * &quot;Software&quot;), to deal in the Software without restriction, including</a>
<a name="ln154"> * without limitation the rights to use, copy, modify, merge, publish,</a>
<a name="ln155"> * distribute, sublicense, and/or sell copies of the Software, and to</a>
<a name="ln156"> * permit persons to whom the Software is furnished to do so, subject to</a>
<a name="ln157"> * the following conditions:</a>
<a name="ln158"> *</a>
<a name="ln159"> * The above copyright notice and this permission notice shall be</a>
<a name="ln160"> * included in all copies or substantial portions of the Software.</a>
<a name="ln161"> *</a>
<a name="ln162"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</a>
<a name="ln163"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</a>
<a name="ln164"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</a>
<a name="ln165"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</a>
<a name="ln166"> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</a>
<a name="ln167"> * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</a>
<a name="ln168"> * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln169"> *</a>
<a name="ln170"> */</a>
<a name="ln171"> </a>
<a name="ln172">#define MAX_IT 1000 /* maximum number of iterations */</a>
<a name="ln173">#define ALPHA 1.0   /* reflection coefficient */</a>
<a name="ln174">#define BETA 0.5    /* contraction coefficient */</a>
<a name="ln175">#define GAMMA 2.0   /* expansion coefficient */</a>
<a name="ln176"> </a>
<a name="ln177">static int _simplex(double (*objfunc)(double[], void *[]), double start[], int n, double EPSILON,</a>
<a name="ln178">                    double scale, int maxiter, void (*constrain)(double[], int n), void *rest[])</a>
<a name="ln179">{</a>
<a name="ln180"> </a>
<a name="ln181">  int vs; /* vertex with smallest value */</a>
<a name="ln182">  int vh; /* vertex with next smallest value */</a>
<a name="ln183">  int vg; /* vertex with largest value */</a>
<a name="ln184"> </a>
<a name="ln185">  int i, j = 0, m, row;</a>
<a name="ln186">  int k;   /* track the number of function evaluations */</a>
<a name="ln187">  int itr; /* track the number of iterations */</a>
<a name="ln188"> </a>
<a name="ln189">  double **v;    /* holds vertices of simplex */</a>
<a name="ln190">  double pn, qn; /* values used to create initial simplex */</a>
<a name="ln191">  double *f;     /* value of function at each vertex */</a>
<a name="ln192">  double fr;     /* value of function at reflection point */</a>
<a name="ln193">  double fe;     /* value of function at expansion point */</a>
<a name="ln194">  double fc;     /* value of function at contraction point */</a>
<a name="ln195">  double *vr;    /* reflection - coordinates */</a>
<a name="ln196">  double *ve;    /* expansion - coordinates */</a>
<a name="ln197">  double *vc;    /* contraction - coordinates */</a>
<a name="ln198">  double *vm;    /* centroid - coordinates */</a>
<a name="ln199"> </a>
<a name="ln200">  double fsum, favg, s, cent;</a>
<a name="ln201"> </a>
<a name="ln202">  /* dynamically allocate arrays */</a>
<a name="ln203"> </a>
<a name="ln204">  /* allocate the rows of the arrays */</a>
<a name="ln205">  v = (double **)malloc((n + 1) * sizeof(double *));</a>
<a name="ln206">  f = (double *)malloc((n + 1) * sizeof(double));</a>
<a name="ln207">  vr = (double *)malloc(n * sizeof(double));</a>
<a name="ln208">  ve = (double *)malloc(n * sizeof(double));</a>
<a name="ln209">  vc = (double *)malloc(n * sizeof(double));</a>
<a name="ln210">  vm = (double *)malloc(n * sizeof(double));</a>
<a name="ln211"> </a>
<a name="ln212">  /* allocate the columns of the arrays */</a>
<a name="ln213">  for(i = 0; i &lt;= n; i++)</a>
<a name="ln214">  {</a>
<a name="ln215">    v[i] = (double *)malloc(n * sizeof(double));</a>
<a name="ln216">  }</a>
<a name="ln217"> </a>
<a name="ln218">  /* create the initial simplex */</a>
<a name="ln219">  /* assume one of the vertices is 0,0 */</a>
<a name="ln220"> </a>
<a name="ln221">  pn = scale * (sqrt(n + 1) - 1 + n) / (n * sqrt(2));</a>
<a name="ln222">  qn = scale * (sqrt(n + 1) - 1) / (n * sqrt(2));</a>
<a name="ln223"> </a>
<a name="ln224">  for(i = 0; i &lt; n; i++)</a>
<a name="ln225">  {</a>
<a name="ln226">    v[0][i] = start[i];</a>
<a name="ln227">  }</a>
<a name="ln228"> </a>
<a name="ln229">  for(i = 1; i &lt;= n; i++)</a>
<a name="ln230">  {</a>
<a name="ln231">    for(j = 0; j &lt; n; j++)</a>
<a name="ln232">    {</a>
<a name="ln233">      if(i - 1 == j)</a>
<a name="ln234">      {</a>
<a name="ln235">        v[i][j] = pn + start[j];</a>
<a name="ln236">      }</a>
<a name="ln237">      else</a>
<a name="ln238">      {</a>
<a name="ln239">        v[i][j] = qn + start[j];</a>
<a name="ln240">      }</a>
<a name="ln241">    }</a>
<a name="ln242">  }</a>
<a name="ln243"> </a>
<a name="ln244">  if(constrain != NULL)</a>
<a name="ln245">  {</a>
<a name="ln246">    constrain(v[j], n);</a>
<a name="ln247">  }</a>
<a name="ln248">  /* find the initial function values */</a>
<a name="ln249">  for(j = 0; j &lt;= n; j++)</a>
<a name="ln250">  {</a>
<a name="ln251">    f[j] = objfunc(v[j], rest);</a>
<a name="ln252">  }</a>
<a name="ln253"> </a>
<a name="ln254">  k = n + 1;</a>
<a name="ln255"> </a>
<a name="ln256">#if 0</a>
<a name="ln257">  /* print out the initial values */</a>
<a name="ln258">  printf (&quot;Initial Values\n&quot;);</a>
<a name="ln259">  for (j = 0; j &lt;= n; j++)</a>
<a name="ln260">  {</a>
<a name="ln261">    for (i = 0; i &lt; n; i++)</a>
<a name="ln262">    {</a>
<a name="ln263">      printf (&quot;%f %f\n&quot;, v[j][i], f[j]);</a>
<a name="ln264">    }</a>
<a name="ln265">  }</a>
<a name="ln266">#endif</a>
<a name="ln267"> </a>
<a name="ln268">  /* begin the main loop of the minimization */</a>
<a name="ln269">  for(itr = 1; itr &lt;= maxiter; itr++)</a>
<a name="ln270">  {</a>
<a name="ln271">    /* find the index of the largest value */</a>
<a name="ln272">    vg = 0;</a>
<a name="ln273">    for(j = 0; j &lt;= n; j++)</a>
<a name="ln274">    {</a>
<a name="ln275">      if(f[j] &gt; f[vg])</a>
<a name="ln276">      {</a>
<a name="ln277">        vg = j;</a>
<a name="ln278">      }</a>
<a name="ln279">    }</a>
<a name="ln280"> </a>
<a name="ln281">    /* find the index of the smallest value */</a>
<a name="ln282">    vs = 0;</a>
<a name="ln283">    for(j = 0; j &lt;= n; j++)</a>
<a name="ln284">    {</a>
<a name="ln285">      if(f[j] &lt; f[vs])</a>
<a name="ln286">      {</a>
<a name="ln287">        vs = j;</a>
<a name="ln288">      }</a>
<a name="ln289">    }</a>
<a name="ln290"> </a>
<a name="ln291">    /* find the index of the second largest value */</a>
<a name="ln292">    vh = vs;</a>
<a name="ln293">    for(j = 0; j &lt;= n; j++)</a>
<a name="ln294">    {</a>
<a name="ln295">      if(f[j] &gt; f[vh] &amp;&amp; f[j] &lt; f[vg])</a>
<a name="ln296">      {</a>
<a name="ln297">        vh = j;</a>
<a name="ln298">      }</a>
<a name="ln299">    }</a>
<a name="ln300"> </a>
<a name="ln301">    /* calculate the centroid */</a>
<a name="ln302">    for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln303">    {</a>
<a name="ln304">      cent = 0.0;</a>
<a name="ln305">      for(m = 0; m &lt;= n; m++)</a>
<a name="ln306">      {</a>
<a name="ln307">        if(m != vg)</a>
<a name="ln308">        {</a>
<a name="ln309">          cent += v[m][j];</a>
<a name="ln310">        }</a>
<a name="ln311">      }</a>
<a name="ln312">      vm[j] = cent / n;</a>
<a name="ln313">    }</a>
<a name="ln314"> </a>
<a name="ln315">    /* reflect vg to new vertex vr */</a>
<a name="ln316">    for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln317">    {</a>
<a name="ln318">      /*vr[j] = (1+ALPHA)*vm[j] - ALPHA*v[vg][j]; */</a>
<a name="ln319">      vr[j] = vm[j] + ALPHA * (vm[j] - v[vg][j]);</a>
<a name="ln320">    }</a>
<a name="ln321">    if(constrain != NULL)</a>
<a name="ln322">    {</a>
<a name="ln323">      constrain(vr, n);</a>
<a name="ln324">    }</a>
<a name="ln325">    fr = objfunc(vr, rest);</a>
<a name="ln326">    k++;</a>
<a name="ln327"> </a>
<a name="ln328">    if(fr &lt; f[vh] &amp;&amp; fr &gt;= f[vs])</a>
<a name="ln329">    {</a>
<a name="ln330">      for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln331">      {</a>
<a name="ln332">        v[vg][j] = vr[j];</a>
<a name="ln333">      }</a>
<a name="ln334">      f[vg] = fr;</a>
<a name="ln335">    }</a>
<a name="ln336"> </a>
<a name="ln337">    /* investigate a step further in this direction */</a>
<a name="ln338">    if(fr &lt; f[vs])</a>
<a name="ln339">    {</a>
<a name="ln340">      for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln341">      {</a>
<a name="ln342">        /*ve[j] = GAMMA*vr[j] + (1-GAMMA)*vm[j]; */</a>
<a name="ln343">        ve[j] = vm[j] + GAMMA * (vr[j] - vm[j]);</a>
<a name="ln344">      }</a>
<a name="ln345">      if(constrain != NULL)</a>
<a name="ln346">      {</a>
<a name="ln347">        constrain(ve, n);</a>
<a name="ln348">      }</a>
<a name="ln349">      fe = objfunc(ve, rest);</a>
<a name="ln350">      k++;</a>
<a name="ln351"> </a>
<a name="ln352">      /* by making fe &lt; fr as opposed to fe &lt; f[vs],</a>
<a name="ln353">         Rosenbrocks function takes 63 iterations as opposed</a>
<a name="ln354">         to 64 when using double variables. */</a>
<a name="ln355"> </a>
<a name="ln356">      if(fe &lt; fr)</a>
<a name="ln357">      {</a>
<a name="ln358">        for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln359">        {</a>
<a name="ln360">          v[vg][j] = ve[j];</a>
<a name="ln361">        }</a>
<a name="ln362">        f[vg] = fe;</a>
<a name="ln363">      }</a>
<a name="ln364">      else</a>
<a name="ln365">      {</a>
<a name="ln366">        for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln367">        {</a>
<a name="ln368">          v[vg][j] = vr[j];</a>
<a name="ln369">        }</a>
<a name="ln370">        f[vg] = fr;</a>
<a name="ln371">      }</a>
<a name="ln372">    }</a>
<a name="ln373"> </a>
<a name="ln374">    /* check to see if a contraction is necessary */</a>
<a name="ln375">    if(fr &gt;= f[vh])</a>
<a name="ln376">    {</a>
<a name="ln377">      if(fr &lt; f[vg] &amp;&amp; fr &gt;= f[vh])</a>
<a name="ln378">      {</a>
<a name="ln379">        /* perform outside contraction */</a>
<a name="ln380">        for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln381">        {</a>
<a name="ln382">          /*vc[j] = BETA*v[vg][j] + (1-BETA)*vm[j]; */</a>
<a name="ln383">          vc[j] = vm[j] + BETA * (vr[j] - vm[j]);</a>
<a name="ln384">        }</a>
<a name="ln385">        if(constrain != NULL)</a>
<a name="ln386">        {</a>
<a name="ln387">          constrain(vc, n);</a>
<a name="ln388">        }</a>
<a name="ln389">        fc = objfunc(vc, rest);</a>
<a name="ln390">        k++;</a>
<a name="ln391">      }</a>
<a name="ln392">      else</a>
<a name="ln393">      {</a>
<a name="ln394">        /* perform inside contraction */</a>
<a name="ln395">        for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln396">        {</a>
<a name="ln397">          /*vc[j] = BETA*v[vg][j] + (1-BETA)*vm[j]; */</a>
<a name="ln398">          vc[j] = vm[j] - BETA * (vm[j] - v[vg][j]);</a>
<a name="ln399">        }</a>
<a name="ln400">        if(constrain != NULL)</a>
<a name="ln401">        {</a>
<a name="ln402">          constrain(vc, n);</a>
<a name="ln403">        }</a>
<a name="ln404">        fc = objfunc(vc, rest);</a>
<a name="ln405">        k++;</a>
<a name="ln406">      }</a>
<a name="ln407"> </a>
<a name="ln408"> </a>
<a name="ln409">      if(fc &lt; f[vg])</a>
<a name="ln410">      {</a>
<a name="ln411">        for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln412">        {</a>
<a name="ln413">          v[vg][j] = vc[j];</a>
<a name="ln414">        }</a>
<a name="ln415">        f[vg] = fc;</a>
<a name="ln416">      }</a>
<a name="ln417">      /* at this point the contraction is not successful,</a>
<a name="ln418">         we must halve the distance from vs to all the</a>
<a name="ln419">         vertices of the simplex and then continue.</a>
<a name="ln420">         10/31/97 - modified to account for ALL vertices.</a>
<a name="ln421">       */</a>
<a name="ln422">      else</a>
<a name="ln423">      {</a>
<a name="ln424">        for(row = 0; row &lt;= n; row++)</a>
<a name="ln425">        {</a>
<a name="ln426">          if(row != vs)</a>
<a name="ln427">          {</a>
<a name="ln428">            for(j = 0; j &lt;= n - 1; j++)</a>
<a name="ln429">            {</a>
<a name="ln430">              v[row][j] = v[vs][j] + (v[row][j] - v[vs][j]) / 2.0;</a>
<a name="ln431">            }</a>
<a name="ln432">          }</a>
<a name="ln433">        }</a>
<a name="ln434">        if(constrain != NULL)</a>
<a name="ln435">        {</a>
<a name="ln436">          constrain(v[vg], n);</a>
<a name="ln437">        }</a>
<a name="ln438">        f[vg] = objfunc(v[vg], rest);</a>
<a name="ln439">        k++;</a>
<a name="ln440">        if(constrain != NULL)</a>
<a name="ln441">        {</a>
<a name="ln442">          constrain(v[vh], n);</a>
<a name="ln443">        }</a>
<a name="ln444">        f[vh] = objfunc(v[vh], rest);</a>
<a name="ln445">        k++;</a>
<a name="ln446">      }</a>
<a name="ln447">    }</a>
<a name="ln448"> </a>
<a name="ln449">#if 0</a>
<a name="ln450">    /* print out the value at each iteration */</a>
<a name="ln451">    printf (&quot;Iteration %d\n&quot;, itr);</a>
<a name="ln452">    for (j = 0; j &lt;= n; j++)</a>
<a name="ln453">    {</a>
<a name="ln454">      for (i = 0; i &lt; n; i++)</a>
<a name="ln455">      {</a>
<a name="ln456">        printf (&quot;%f %f\n&quot;, v[j][i], f[j]);</a>
<a name="ln457">      }</a>
<a name="ln458">    }</a>
<a name="ln459">#endif</a>
<a name="ln460"> </a>
<a name="ln461">    /* test for convergence */</a>
<a name="ln462">    fsum = 0.0;</a>
<a name="ln463">    for(j = 0; j &lt;= n; j++)</a>
<a name="ln464">    {</a>
<a name="ln465">      fsum += f[j];</a>
<a name="ln466">    }</a>
<a name="ln467">    favg = fsum / (n + 1);</a>
<a name="ln468">    s = 0.0;</a>
<a name="ln469">    for(j = 0; j &lt;= n; j++)</a>
<a name="ln470">    {</a>
<a name="ln471">      s += pow((f[j] - favg), 2.0) / (n);</a>
<a name="ln472">    }</a>
<a name="ln473">    s = sqrt(s);</a>
<a name="ln474">    if(s &lt; EPSILON) break;</a>
<a name="ln475">  }</a>
<a name="ln476">  /* end main loop of the minimization */</a>
<a name="ln477"> </a>
<a name="ln478">  /* find the index of the smallest value */</a>
<a name="ln479">  vs = 0;</a>
<a name="ln480">  for(j = 0; j &lt;= n; j++)</a>
<a name="ln481">  {</a>
<a name="ln482">    if(f[j] &lt; f[vs])</a>
<a name="ln483">    {</a>
<a name="ln484">      vs = j;</a>
<a name="ln485">    }</a>
<a name="ln486">  }</a>
<a name="ln487"> </a>
<a name="ln488">#if 0</a>
<a name="ln489">  printf (&quot;The minimum was found at\n&quot;);</a>
<a name="ln490">  for (j = 0; j &lt; n; j++)</a>
<a name="ln491">  {</a>
<a name="ln492">    printf (&quot;%e\n&quot;, v[vs][j]);</a>
<a name="ln493">    start[j] = v[vs][j];</a>
<a name="ln494">  }</a>
<a name="ln495">  double min = objfunc (v[vs], rest);</a>
<a name="ln496">  printf (&quot;Function value at minimum %f\n&quot;, min);</a>
<a name="ln497">  k++;</a>
<a name="ln498">  printf (&quot;%d Function Evaluations\n&quot;, k);</a>
<a name="ln499">  printf (&quot;%d Iterations through program\n&quot;, itr);</a>
<a name="ln500">#endif</a>
<a name="ln501"> </a>
<a name="ln502">  free(f);</a>
<a name="ln503">  free(vr);</a>
<a name="ln504">  free(ve);</a>
<a name="ln505">  free(vc);</a>
<a name="ln506">  free(vm);</a>
<a name="ln507">  for(i = 0; i &lt;= n; i++)</a>
<a name="ln508">  {</a>
<a name="ln509">    free(v[i]);</a>
<a name="ln510">  }</a>
<a name="ln511">  free(v);</a>
<a name="ln512">  return itr;</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515"> </a>
<a name="ln516">static int _nm_fit_output_to_input_roi(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln517">                                       const dt_iop_roi_t *iroi, dt_iop_roi_t *oroi, int delta)</a>
<a name="ln518">{</a>
<a name="ln519">  void *rest[4] = { (void *)self, (void *)piece, (void *)iroi, (void *)oroi };</a>
<a name="ln520">  double start[4] = { (float)oroi-&gt;x / piece-&gt;iwidth, (float)oroi-&gt;y / piece-&gt;iheight,</a>
<a name="ln521">                      (float)oroi-&gt;width / piece-&gt;iwidth, (float)oroi-&gt;height / piece-&gt;iheight };</a>
<a name="ln522">  double epsilon = (double)delta / MIN(piece-&gt;iwidth, piece-&gt;iheight);</a>
<a name="ln523">  int maxiter = 1000;</a>
<a name="ln524"> </a>
<a name="ln525">  int iter = _simplex(_nm_fitness, start, 4, epsilon, 1.0, maxiter, NULL, rest);</a>
<a name="ln526"> </a>
<a name="ln527">  // printf(&quot;_simplex: %d, delta: %d, epsilon: %f\n&quot;, iter, delta, epsilon);</a>
<a name="ln528"> </a>
<a name="ln529">  oroi-&gt;x = start[0] * piece-&gt;iwidth;</a>
<a name="ln530">  oroi-&gt;y = start[1] * piece-&gt;iheight;</a>
<a name="ln531">  oroi-&gt;width = start[2] * piece-&gt;iwidth;</a>
<a name="ln532">  oroi-&gt;height = start[3] * piece-&gt;iheight;</a>
<a name="ln533"> </a>
<a name="ln534">  return (iter &lt;= maxiter);</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">/* find a matching oroi_full by probing start value of oroi and get corresponding input roi into iroi_probe.</a>
<a name="ln540">   We search in two steps. first by a simplicistic iterative search which will succeed in most cases.</a>
<a name="ln541">   If this does not converge, we do a downhill simplex (nelder-mead) fitting */</a>
<a name="ln542">static int _fit_output_to_input_roi(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln543">                                    const dt_iop_roi_t *iroi, dt_iop_roi_t *oroi, int delta, int iter)</a>
<a name="ln544">{</a>
<a name="ln545">  dt_iop_roi_t iroi_probe = *iroi;</a>
<a name="ln546">  dt_iop_roi_t save_oroi = *oroi;</a>
<a name="ln547"> </a>
<a name="ln548">  // try to go the easy way. this works in many cases where output is</a>
<a name="ln549">  // just like input, only scaled down</a>
<a name="ln550">  self-&gt;modify_roi_in(self, piece, oroi, &amp;iroi_probe);</a>
<a name="ln551">  while((abs((int)iroi_probe.x - (int)iroi-&gt;x) &gt; delta || abs((int)iroi_probe.y - (int)iroi-&gt;y) &gt; delta</a>
<a name="ln552">         || abs((int)iroi_probe.width - (int)iroi-&gt;width) &gt; delta</a>
<a name="ln553">         || abs((int)iroi_probe.height - (int)iroi-&gt;height) &gt; delta) &amp;&amp; iter &gt; 0)</a>
<a name="ln554">  {</a>
<a name="ln555">    //_print_roi(&amp;iroi_probe, &quot;tile iroi_probe&quot;);</a>
<a name="ln556">    //_print_roi(oroi, &quot;tile oroi old&quot;);</a>
<a name="ln557"> </a>
<a name="ln558">    oroi-&gt;x += (iroi-&gt;x - iroi_probe.x) * oroi-&gt;scale / iroi-&gt;scale;</a>
<a name="ln559">    oroi-&gt;y += (iroi-&gt;y - iroi_probe.y) * oroi-&gt;scale / iroi-&gt;scale;</a>
<a name="ln560">    oroi-&gt;width += (iroi-&gt;width - iroi_probe.width) * oroi-&gt;scale / iroi-&gt;scale;</a>
<a name="ln561">    oroi-&gt;height += (iroi-&gt;height - iroi_probe.height) * oroi-&gt;scale / iroi-&gt;scale;</a>
<a name="ln562"> </a>
<a name="ln563">    //_print_roi(oroi, &quot;tile oroi new&quot;);</a>
<a name="ln564"> </a>
<a name="ln565">    self-&gt;modify_roi_in(self, piece, oroi, &amp;iroi_probe);</a>
<a name="ln566">    iter--;</a>
<a name="ln567">  }</a>
<a name="ln568"> </a>
<a name="ln569">  if(iter &gt; 0) return TRUE;</a>
<a name="ln570"> </a>
<a name="ln571">  *oroi = save_oroi;</a>
<a name="ln572"> </a>
<a name="ln573">  // simplicistic approach did not converge.</a>
<a name="ln574">  // try simplex downhill fitting now.</a>
<a name="ln575">  // it's crucial that we have a good starting point in oroi, else this</a>
<a name="ln576">  // will not converge as well.</a>
<a name="ln577">  int fit = _nm_fit_output_to_input_roi(self, piece, iroi, oroi, delta);</a>
<a name="ln578">  return fit;</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">/* simple tiling algorithm for roi_in == roi_out, i.e. for pixel to pixel modules/operations */</a>
<a name="ln583">static void _default_process_tiling_ptp(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln584">                                        const void *const ivoid, void *const ovoid,</a>
<a name="ln585">                                        const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln586">                                        const int in_bpp)</a>
<a name="ln587">{</a>
<a name="ln588">  void *input = NULL;</a>
<a name="ln589">  void *output = NULL;</a>
<a name="ln590">  dt_iop_buffer_dsc_t dsc;</a>
<a name="ln591">  self-&gt;output_format(self, piece-&gt;pipe, piece, &amp;dsc);</a>
<a name="ln592">  const int out_bpp = dt_iop_buffer_dsc_to_bpp(&amp;dsc);</a>
<a name="ln593"> </a>
<a name="ln594">  const int ipitch = roi_in-&gt;width * in_bpp;</a>
<a name="ln595">  const int opitch = roi_out-&gt;width * out_bpp;</a>
<a name="ln596">  const int max_bpp = _max(in_bpp, out_bpp);</a>
<a name="ln597"> </a>
<a name="ln598">  /* get tiling requirements of module */</a>
<a name="ln599">  dt_develop_tiling_t tiling = { 0 };</a>
<a name="ln600">  self-&gt;tiling_callback(self, piece, roi_in, roi_out, &amp;tiling);</a>
<a name="ln601"> </a>
<a name="ln602">  /* tiling really does not make sense in these cases. standard process() is not better or worse than we are</a>
<a name="ln603">   */</a>
<a name="ln604">  if(tiling.factor &lt; 2.2f &amp;&amp; tiling.overhead &lt; 0.2f * roi_in-&gt;width * roi_in-&gt;height * max_bpp)</a>
<a name="ln605">  {</a>
<a name="ln606">    dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_ptp] no need to use tiling for module '%s' as no real &quot;</a>
<a name="ln607">                           &quot;memory saving to be expected\n&quot;,</a>
<a name="ln608">             self-&gt;op);</a>
<a name="ln609">    goto fallback;</a>
<a name="ln610">  }</a>
<a name="ln611"> </a>
<a name="ln612">  /* calculate optimal size of tiles */</a>
<a name="ln613">  float available = dt_conf_get_float(&quot;host_memory_limit&quot;) * 1024.0f * 1024.0f;</a>
<a name="ln614">  assert(available &gt;= 500.0f * 1024.0f * 1024.0f);</a>
<a name="ln615">  /* correct for size of ivoid and ovoid which are needed on top of tiling */</a>
<a name="ln616">  available = fmax(available - ((float)roi_out-&gt;width * roi_out-&gt;height * out_bpp)</a>
<a name="ln617">                   - ((float)roi_in-&gt;width * roi_in-&gt;height * in_bpp) - tiling.overhead,</a>
<a name="ln618">                   0);</a>
<a name="ln619"> </a>
<a name="ln620">  /* we ignore the above value if singlebuffer_limit (is defined and) is higher than available/tiling.factor.</a>
<a name="ln621">     this will mainly allow tiling for modules with high and &quot;unpredictable&quot; memory demand which is</a>
<a name="ln622">     reflected in high values of tiling.factor (take bilateral noise reduction as an example). */</a>
<a name="ln623">  float singlebuffer = dt_conf_get_float(&quot;singlebuffer_limit&quot;) * 1024.0f * 1024.0f;</a>
<a name="ln624">  singlebuffer = fmax(singlebuffer, 2.0f * 1024.0f * 1024.0f);</a>
<a name="ln625">  float factor = fmax(tiling.factor, 1.0f);</a>
<a name="ln626">  float maxbuf = fmax(tiling.maxbuf, 1.0f);</a>
<a name="ln627">  singlebuffer = fmax(available / factor, singlebuffer);</a>
<a name="ln628"> </a>
<a name="ln629">  int width = roi_in-&gt;width;</a>
<a name="ln630">  int height = roi_in-&gt;height;</a>
<a name="ln631"> </a>
<a name="ln632">  /* shrink tile size in case it would exceed singlebuffer size */</a>
<a name="ln633">  if((float)width * height * max_bpp * maxbuf &gt; singlebuffer)</a>
<a name="ln634">  {</a>
<a name="ln635">    const float scale = singlebuffer / ((float)width * height * max_bpp * maxbuf);</a>
<a name="ln636"> </a>
<a name="ln637">    /* TODO: can we make this more efficient to minimize total overlap between tiles? */</a>
<a name="ln638">    if(width &lt; height &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln639">    {</a>
<a name="ln640">      height = floorf(height * scale);</a>
<a name="ln641">    }</a>
<a name="ln642">    else if(height &lt;= width &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln643">    {</a>
<a name="ln644">      width = floorf(width * scale);</a>
<a name="ln645">    }</a>
<a name="ln646">    else</a>
<a name="ln647">    {</a>
<a name="ln648">      width = floorf(width * sqrt(scale));</a>
<a name="ln649">      height = floorf(height * sqrt(scale));</a>
<a name="ln650">    }</a>
<a name="ln651">  }</a>
<a name="ln652"> </a>
<a name="ln653">  /* make sure we have a reasonably effective tile dimension. if not try square tiles */</a>
<a name="ln654">  if(3 * tiling.overlap &gt; width || 3 * tiling.overlap &gt; height)</a>
<a name="ln655">  {</a>
<a name="ln656">    width = height = floorf(sqrtf((float)width * height));</a>
<a name="ln657">  }</a>
<a name="ln658"> </a>
<a name="ln659">  /* Alignment rules: we need to make sure that alignment requirements of module are fulfilled.</a>
<a name="ln660">     Modules will report alignment requirements via xalign and yalign within tiling_callback().</a>
<a name="ln661">     Typical use case is demosaic where Bayer pattern requires alignment to a multiple of 2 in x and y</a>
<a name="ln662">     direction.</a>
<a name="ln663">     We guarantee alignment by selecting image width/height and overlap accordingly. For a tile width/height</a>
<a name="ln664">     that is identical to image width/height no special alignment is needed. */</a>
<a name="ln665"> </a>
<a name="ln666">  const unsigned int xyalign = _lcm(tiling.xalign, tiling.yalign);</a>
<a name="ln667"> </a>
<a name="ln668">  assert(xyalign != 0);</a>
<a name="ln669"> </a>
<a name="ln670">  /* properly align tile width and height by making them smaller if needed */</a>
<a name="ln671">  if(width &lt; roi_in-&gt;width) width = (width / xyalign) * xyalign;</a>
<a name="ln672">  if(height &lt; roi_in-&gt;height) height = (height / xyalign) * xyalign;</a>
<a name="ln673"> </a>
<a name="ln674">  /* also make sure that overlap follows alignment rules by making it wider when needed */</a>
<a name="ln675">  const int overlap = tiling.overlap % xyalign != 0 ? (tiling.overlap / xyalign + 1) * xyalign</a>
<a name="ln676">                                                    : tiling.overlap;</a>
<a name="ln677"> </a>
<a name="ln678">  /* calculate effective tile size */</a>
<a name="ln679">  const int tile_wd = width - 2 * overlap &gt; 0 ? width - 2 * overlap : 1;</a>
<a name="ln680">  const int tile_ht = height - 2 * overlap &gt; 0 ? height - 2 * overlap : 1;</a>
<a name="ln681"> </a>
<a name="ln682">  /* calculate number of tiles */</a>
<a name="ln683">  const int tiles_x = width &lt; roi_in-&gt;width ? ceilf(roi_in-&gt;width / (float)tile_wd) : 1;</a>
<a name="ln684">  const int tiles_y = height &lt; roi_in-&gt;height ? ceilf(roi_in-&gt;height / (float)tile_ht) : 1;</a>
<a name="ln685"> </a>
<a name="ln686">  /* sanity check: don't run wild on too many tiles */</a>
<a name="ln687">  if(tiles_x * tiles_y &gt; dt_conf_get_int(&quot;maximum_number_tiles&quot;))</a>
<a name="ln688">  {</a>
<a name="ln689">    dt_print(DT_DEBUG_DEV,</a>
<a name="ln690">             &quot;[default_process_tiling_ptp] gave up tiling for module '%s'. too many tiles: %d x %d\n&quot;,</a>
<a name="ln691">             self-&gt;op, tiles_x, tiles_y);</a>
<a name="ln692">    goto error;</a>
<a name="ln693">  }</a>
<a name="ln694"> </a>
<a name="ln695"> </a>
<a name="ln696">  dt_print(DT_DEBUG_DEV,</a>
<a name="ln697">           &quot;[default_process_tiling_ptp] use tiling on module '%s' for image with full size %d x %d\n&quot;,</a>
<a name="ln698">           self-&gt;op, roi_in-&gt;width, roi_in-&gt;height);</a>
<a name="ln699">  dt_print(DT_DEBUG_DEV,</a>
<a name="ln700">           &quot;[default_process_tiling_ptp] (%d x %d) tiles with max dimensions %d x %d and overlap %d\n&quot;,</a>
<a name="ln701">           tiles_x, tiles_y, width, height, overlap);</a>
<a name="ln702"> </a>
<a name="ln703">  /* reserve input and output buffers for tiles */</a>
<a name="ln704">  input = dt_alloc_align(64, (size_t)width * height * in_bpp);</a>
<a name="ln705">  if(input == NULL)</a>
<a name="ln706">  {</a>
<a name="ln707">    dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_ptp] could not alloc input buffer for module '%s'\n&quot;,</a>
<a name="ln708">             self-&gt;op);</a>
<a name="ln709">    goto error;</a>
<a name="ln710">  }</a>
<a name="ln711">  output = dt_alloc_align(64, (size_t)width * height * out_bpp);</a>
<a name="ln712">  if(output == NULL)</a>
<a name="ln713">  {</a>
<a name="ln714">    dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_ptp] could not alloc output buffer for module '%s'\n&quot;,</a>
<a name="ln715">             self-&gt;op);</a>
<a name="ln716">    goto error;</a>
<a name="ln717">  }</a>
<a name="ln718"> </a>
<a name="ln719">  /* store processed_maximum to be re-used and aggregated */</a>
<a name="ln720">  float processed_maximum_saved[4];</a>
<a name="ln721">  float processed_maximum_new[4] = { 1.0f };</a>
<a name="ln722">  for(int k = 0; k &lt; 4; k++) processed_maximum_saved[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln723"> </a>
<a name="ln724"> </a>
<a name="ln725">  /* iterate over tiles */</a>
<a name="ln726">  for(size_t tx = 0; tx &lt; tiles_x; tx++)</a>
<a name="ln727">  {</a>
<a name="ln728">    const size_t wd = tx * tile_wd + width &gt; roi_in-&gt;width ? roi_in-&gt;width - tx * tile_wd : width;</a>
<a name="ln729">    for(size_t ty = 0; ty &lt; tiles_y; ty++)</a>
<a name="ln730">    {</a>
<a name="ln731">      piece-&gt;pipe-&gt;tiling = 1;</a>
<a name="ln732"> </a>
<a name="ln733">      const size_t ht = ty * tile_ht + height &gt; roi_in-&gt;height ? roi_in-&gt;height - ty * tile_ht : height;</a>
<a name="ln734"> </a>
<a name="ln735">      /* no need to process end-tiles that are smaller than the total overlap area */</a>
<a name="ln736">      if((wd &lt;= 2 * overlap &amp;&amp; tx &gt; 0) || (ht &lt;= 2 * overlap &amp;&amp; ty &gt; 0)) continue;</a>
<a name="ln737"> </a>
<a name="ln738">      /* origin and region of effective part of tile, which we want to store later */</a>
<a name="ln739">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln740">      size_t region[] = { wd, ht, 1 };</a>
<a name="ln741"> </a>
<a name="ln742">      /* roi_in and roi_out for process_cl on subbuffer */</a>
<a name="ln743">      dt_iop_roi_t iroi = { roi_in-&gt;x + tx * tile_wd, roi_in-&gt;y + ty * tile_ht, wd, ht, roi_in-&gt;scale };</a>
<a name="ln744">      dt_iop_roi_t oroi = { roi_out-&gt;x + tx * tile_wd, roi_out-&gt;y + ty * tile_ht, wd, ht, roi_out-&gt;scale };</a>
<a name="ln745"> </a>
<a name="ln746">      /* offsets of tile into ivoid and ovoid */</a>
<a name="ln747">      size_t ioffs = (ty * tile_ht) * ipitch + (tx * tile_wd) * in_bpp;</a>
<a name="ln748">      size_t ooffs = (ty * tile_ht) * opitch + (tx * tile_wd) * out_bpp;</a>
<a name="ln749"> </a>
<a name="ln750"> </a>
<a name="ln751">      dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_ptp] tile (%zu, %zu) with %zu x %zu at origin [%zu, %zu]\n&quot;,</a>
<a name="ln752">               tx, ty, wd, ht, tx * tile_wd, ty * tile_ht);</a>
<a name="ln753"> </a>
<a name="ln754">/* prepare input tile buffer */</a>
<a name="ln755">#ifdef _OPENMP</a>
<a name="ln756">#pragma omp parallel for default(none) shared(input, width, ioffs) schedule(static)</a>
<a name="ln757">#endif</a>
<a name="ln758">      for(size_t j = 0; j &lt; ht; j++)</a>
<a name="ln759">        memcpy((char *)input + j * wd * in_bpp, (char *)ivoid + ioffs + j * ipitch, (size_t)wd * in_bpp);</a>
<a name="ln760"> </a>
<a name="ln761">      /* take original processed_maximum as starting point */</a>
<a name="ln762">      for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_saved[k];</a>
<a name="ln763"> </a>
<a name="ln764">      /* call process() of module */</a>
<a name="ln765">      self-&gt;process(self, piece, input, output, &amp;iroi, &amp;oroi);</a>
<a name="ln766"> </a>
<a name="ln767">      /* aggregate resulting processed_maximum */</a>
<a name="ln768">      /* TODO: check if there really can be differences between tiles and take</a>
<a name="ln769">               appropriate action (calculate minimum, maximum, average, ...?) */</a>
<a name="ln770">      for(int k = 0; k &lt; 4; k++)</a>
<a name="ln771">      {</a>
<a name="ln772">        if(tx + ty &gt; 0 &amp;&amp; fabs(processed_maximum_new[k] - piece-&gt;pipe-&gt;dsc.processed_maximum[k]) &gt; 1.0e-6f)</a>
<a name="ln773">          dt_print(</a>
<a name="ln774">              DT_DEBUG_DEV,</a>
<a name="ln775">              &quot;[default_process_tiling_ptp] processed_maximum[%d] differs between tiles in module '%s'\n&quot;, k,</a>
<a name="ln776">              self-&gt;op);</a>
<a name="ln777">        processed_maximum_new[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln778">      }</a>
<a name="ln779"> </a>
<a name="ln780">      /* correct origin and region of tile for overlap.</a>
<a name="ln781">         make sure that we only copy back the &quot;good&quot; part. */</a>
<a name="ln782">      if(tx &gt; 0)</a>
<a name="ln783">      {</a>
<a name="ln784">        origin[0] += overlap;</a>
<a name="ln785">        region[0] -= overlap;</a>
<a name="ln786">        ooffs += overlap * out_bpp;</a>
<a name="ln787">      }</a>
<a name="ln788">      if(ty &gt; 0)</a>
<a name="ln789">      {</a>
<a name="ln790">        origin[1] += overlap;</a>
<a name="ln791">        region[1] -= overlap;</a>
<a name="ln792">        ooffs += overlap * opitch;</a>
<a name="ln793">      }</a>
<a name="ln794"> </a>
<a name="ln795">/* copy &quot;good&quot; part of tile to output buffer */</a>
<a name="ln796">#ifdef _OPENMP</a>
<a name="ln797">#pragma omp parallel for default(none) shared(ooffs, output, width, origin, region) schedule(static)</a>
<a name="ln798">#endif</a>
<a name="ln799">      for(size_t j = 0; j &lt; region[1]; j++)</a>
<a name="ln800">        memcpy((char *)ovoid + ooffs + j * opitch,</a>
<a name="ln801">               (char *)output + ((j + origin[1]) * wd + origin[0]) * out_bpp, (size_t)region[0] * out_bpp);</a>
<a name="ln802">    }</a>
<a name="ln803">  }</a>
<a name="ln804"> </a>
<a name="ln805">  /* copy back final processed_maximum */</a>
<a name="ln806">  for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_new[k];</a>
<a name="ln807"> </a>
<a name="ln808">  if(input != NULL) dt_free_align(input);</a>
<a name="ln809">  if(output != NULL) dt_free_align(output);</a>
<a name="ln810">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln811">  return;</a>
<a name="ln812"> </a>
<a name="ln813">error:</a>
<a name="ln814">  dt_control_log(_(&quot;tiling failed for module '%s'. output might be garbled.&quot;), self-&gt;op);</a>
<a name="ln815">// fall through</a>
<a name="ln816"> </a>
<a name="ln817">fallback:</a>
<a name="ln818">  if(input != NULL) dt_free_align(input);</a>
<a name="ln819">  if(output != NULL) dt_free_align(output);</a>
<a name="ln820">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln821">  dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_ptp] fall back to standard processing for module '%s'\n&quot;,</a>
<a name="ln822">           self-&gt;op);</a>
<a name="ln823">  self-&gt;process(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln824">  return;</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827"> </a>
<a name="ln828"> </a>
<a name="ln829">/* more elaborate tiling algorithm for roi_in != roi_out: slower than the ptp variant,</a>
<a name="ln830">   more tiles and larger overlap */</a>
<a name="ln831">static void _default_process_tiling_roi(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln832">                                        const void *const ivoid, void *const ovoid,</a>
<a name="ln833">                                        const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln834">                                        const int in_bpp)</a>
<a name="ln835">{</a>
<a name="ln836">  void *input = NULL;</a>
<a name="ln837">  void *output = NULL;</a>
<a name="ln838"> </a>
<a name="ln839">  //_print_roi(roi_in, &quot;module roi_in&quot;);</a>
<a name="ln840">  //_print_roi(roi_out, &quot;module roi_out&quot;);</a>
<a name="ln841"> </a>
<a name="ln842">  dt_iop_buffer_dsc_t dsc;</a>
<a name="ln843">  self-&gt;output_format(self, piece-&gt;pipe, piece, &amp;dsc);</a>
<a name="ln844">  const int out_bpp = dt_iop_buffer_dsc_to_bpp(&amp;dsc);</a>
<a name="ln845"> </a>
<a name="ln846">  const int ipitch = roi_in-&gt;width * in_bpp;</a>
<a name="ln847">  const int opitch = roi_out-&gt;width * out_bpp;</a>
<a name="ln848">  const int max_bpp = _max(in_bpp, out_bpp);</a>
<a name="ln849"> </a>
<a name="ln850">  float fullscale = fmax(roi_in-&gt;scale / roi_out-&gt;scale, sqrt(((float)roi_in-&gt;width * roi_in-&gt;height)</a>
<a name="ln851">                                                              / ((float)roi_out-&gt;width * roi_out-&gt;height)));</a>
<a name="ln852"> </a>
<a name="ln853">  /* inaccuracy for roi_in elements in roi_out -&gt; roi_in calculations */</a>
<a name="ln854">  const int delta = ceilf(fullscale);</a>
<a name="ln855"> </a>
<a name="ln856">  /* estimate for additional (space) requirement in buffer dimensions due to inaccuracies */</a>
<a name="ln857">  const int inacc = RESERVE * delta;</a>
<a name="ln858"> </a>
<a name="ln859">  /* get tiling requirements of module */</a>
<a name="ln860">  dt_develop_tiling_t tiling = { 0 };</a>
<a name="ln861">  self-&gt;tiling_callback(self, piece, roi_in, roi_out, &amp;tiling);</a>
<a name="ln862"> </a>
<a name="ln863">  /* tiling really does not make sense in these cases. standard process() is not better or worse than we are</a>
<a name="ln864">   */</a>
<a name="ln865">  if(tiling.factor &lt; 2.2f &amp;&amp; tiling.overhead &lt; 0.2f * roi_in-&gt;width * roi_in-&gt;height * max_bpp)</a>
<a name="ln866">  {</a>
<a name="ln867">    dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] no need to use tiling for module '%s' as no real &quot;</a>
<a name="ln868">                           &quot;memory saving to be expected\n&quot;,</a>
<a name="ln869">             self-&gt;op);</a>
<a name="ln870">    goto fallback;</a>
<a name="ln871">  }</a>
<a name="ln872"> </a>
<a name="ln873">  /* calculate optimal size of tiles */</a>
<a name="ln874">  float available = dt_conf_get_float(&quot;host_memory_limit&quot;) * 1024.0f * 1024.0f;</a>
<a name="ln875">  assert(available &gt;= 500.0f * 1024.0f * 1024.0f);</a>
<a name="ln876">  /* correct for size of ivoid and ovoid which are needed on top of tiling */</a>
<a name="ln877">  available = fmax(available - ((float)roi_out-&gt;width * roi_out-&gt;height * out_bpp)</a>
<a name="ln878">                   - ((float)roi_in-&gt;width * roi_in-&gt;height * in_bpp) - tiling.overhead,</a>
<a name="ln879">                   0);</a>
<a name="ln880"> </a>
<a name="ln881">  /* we ignore the above value if singlebuffer_limit (is defined and) is higher than available/tiling.factor.</a>
<a name="ln882">     this will mainly allow tiling for modules with high and &quot;unpredictable&quot; memory demand which is</a>
<a name="ln883">     reflected in high values of tiling.factor (take bilateral noise reduction as an example). */</a>
<a name="ln884">  float singlebuffer = dt_conf_get_float(&quot;singlebuffer_limit&quot;) * 1024.0f * 1024.0f;</a>
<a name="ln885">  singlebuffer = fmax(singlebuffer, 2.0f * 1024.0f * 1024.0f);</a>
<a name="ln886">  float factor = fmax(tiling.factor, 1.0f);</a>
<a name="ln887">  float maxbuf = fmax(tiling.maxbuf, 1.0f);</a>
<a name="ln888">  singlebuffer = fmax(available / factor, singlebuffer);</a>
<a name="ln889"> </a>
<a name="ln890">  int width = _max(roi_in-&gt;width, roi_out-&gt;width);</a>
<a name="ln891">  int height = _max(roi_in-&gt;height, roi_out-&gt;height);</a>
<a name="ln892"> </a>
<a name="ln893">  /* shrink tile size in case it would exceed singlebuffer size */</a>
<a name="ln894">  if((float)width * height * max_bpp * maxbuf &gt; singlebuffer)</a>
<a name="ln895">  {</a>
<a name="ln896">    const float scale = singlebuffer / ((float)width * height * max_bpp * maxbuf);</a>
<a name="ln897"> </a>
<a name="ln898">    /* TODO: can we make this more efficient to minimize total overlap between tiles? */</a>
<a name="ln899">    if(width &lt; height &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln900">    {</a>
<a name="ln901">      height = floorf(height * scale);</a>
<a name="ln902">    }</a>
<a name="ln903">    else if(height &lt;= width &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln904">    {</a>
<a name="ln905">      width = floorf(width * scale);</a>
<a name="ln906">    }</a>
<a name="ln907">    else</a>
<a name="ln908">    {</a>
<a name="ln909">      width = floorf(width * sqrt(scale));</a>
<a name="ln910">      height = floorf(height * sqrt(scale));</a>
<a name="ln911">    }</a>
<a name="ln912">  }</a>
<a name="ln913"> </a>
<a name="ln914">  /* make sure we have a reasonably effective tile dimension. if not try square tiles */</a>
<a name="ln915">  if(3 * tiling.overlap &gt; width || 3 * tiling.overlap &gt; height)</a>
<a name="ln916">  {</a>
<a name="ln917">    width = height = floorf(sqrtf((float)width * height));</a>
<a name="ln918">  }</a>
<a name="ln919"> </a>
<a name="ln920">  /* Alignment rules: we need to make sure that alignment requirements of module are fulfilled.</a>
<a name="ln921">     Modules will report alignment requirements via xalign and yalign within tiling_callback().</a>
<a name="ln922">     Typical use case is demosaic where Bayer pattern requires alignment to a multiple of 2 in x and y</a>
<a name="ln923">     direction. */</a>
<a name="ln924"> </a>
<a name="ln925">  /* for simplicity reasons we use only one alignment that fits to x and y requirements at the same time */</a>
<a name="ln926">  unsigned int xyalign = _lcm(tiling.xalign, tiling.yalign);</a>
<a name="ln927"> </a>
<a name="ln928">  assert(xyalign != 0);</a>
<a name="ln929"> </a>
<a name="ln930">  /* make sure that overlap follows alignment rules by making it wider when needed.</a>
<a name="ln931">     overlap_in needs to be aligned, overlap_out is only here to calculate output buffer size */</a>
<a name="ln932">  const int overlap_in = _align_up(tiling.overlap, xyalign);</a>
<a name="ln933">  const int overlap_out = ceilf((float)overlap_in / fullscale);</a>
<a name="ln934"> </a>
<a name="ln935">  int tiles_x = 1, tiles_y = 1;</a>
<a name="ln936"> </a>
<a name="ln937">  /* calculate number of tiles taking the larger buffer (input or output) as a guiding one.</a>
<a name="ln938">     normally it is roi_in &gt; roi_out; but let's be prepared */</a>
<a name="ln939">  if(roi_in-&gt;width &gt; roi_out-&gt;width)</a>
<a name="ln940">    tiles_x = width &lt; roi_in-&gt;width</a>
<a name="ln941">                  ? ceilf((float)roi_in-&gt;width / (float)_max(width - 2 * overlap_in - inacc, 1))</a>
<a name="ln942">                  : 1;</a>
<a name="ln943">  else</a>
<a name="ln944">    tiles_x = width &lt; roi_out-&gt;width ? ceilf((float)roi_out-&gt;width / (float)_max(width - 2 * overlap_out, 1))</a>
<a name="ln945">                                     : 1;</a>
<a name="ln946"> </a>
<a name="ln947">  if(roi_in-&gt;height &gt; roi_out-&gt;height)</a>
<a name="ln948">    tiles_y = height &lt; roi_in-&gt;height</a>
<a name="ln949">                  ? ceilf((float)roi_in-&gt;height / (float)_max(height - 2 * overlap_in - inacc, 1))</a>
<a name="ln950">                  : 1;</a>
<a name="ln951">  else</a>
<a name="ln952">    tiles_y = height &lt; roi_out-&gt;height</a>
<a name="ln953">                  ? ceilf((float)roi_out-&gt;height / (float)_max(height - 2 * overlap_out, 1))</a>
<a name="ln954">                  : 1;</a>
<a name="ln955"> </a>
<a name="ln956">  /* sanity check: don't run wild on too many tiles */</a>
<a name="ln957">  if(tiles_x * tiles_y &gt; dt_conf_get_int(&quot;maximum_number_tiles&quot;))</a>
<a name="ln958">  {</a>
<a name="ln959">    dt_print(DT_DEBUG_DEV,</a>
<a name="ln960">             &quot;[default_process_tiling_roi] gave up tiling for module '%s'. too many tiles: %d x %d\n&quot;,</a>
<a name="ln961">             self-&gt;op, tiles_x, tiles_y);</a>
<a name="ln962">    goto error;</a>
<a name="ln963">  }</a>
<a name="ln964"> </a>
<a name="ln965"> </a>
<a name="ln966">  /* calculate tile width and height excl. overlap (i.e. the good part) for output.</a>
<a name="ln967">     values are important for all following processing steps. */</a>
<a name="ln968">  const int tile_wd = _align_up(</a>
<a name="ln969">      roi_out-&gt;width % tiles_x == 0 ? roi_out-&gt;width / tiles_x : roi_out-&gt;width / tiles_x + 1, xyalign);</a>
<a name="ln970">  const int tile_ht = _align_up(</a>
<a name="ln971">      roi_out-&gt;height % tiles_y == 0 ? roi_out-&gt;height / tiles_y : roi_out-&gt;height / tiles_y + 1, xyalign);</a>
<a name="ln972"> </a>
<a name="ln973">  dt_print(DT_DEBUG_DEV,</a>
<a name="ln974">           &quot;[default_process_tiling_roi] use tiling on module '%s' for image with full input size %d x %d\n&quot;,</a>
<a name="ln975">           self-&gt;op, roi_in-&gt;width, roi_in-&gt;height);</a>
<a name="ln976">  dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] (%d x %d) tiles with max dimensions %d x %d\n&quot;,</a>
<a name="ln977">           tiles_x, tiles_y, width, height);</a>
<a name="ln978"> </a>
<a name="ln979"> </a>
<a name="ln980">  /* store processed_maximum to be re-used and aggregated */</a>
<a name="ln981">  float processed_maximum_saved[4];</a>
<a name="ln982">  float processed_maximum_new[4] = { 1.0f };</a>
<a name="ln983">  for(int k = 0; k &lt; 4; k++) processed_maximum_saved[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln984"> </a>
<a name="ln985">  /* iterate over tiles */</a>
<a name="ln986">  for(size_t tx = 0; tx &lt; tiles_x; tx++)</a>
<a name="ln987">    for(size_t ty = 0; ty &lt; tiles_y; ty++)</a>
<a name="ln988">    {</a>
<a name="ln989">      piece-&gt;pipe-&gt;tiling = 1;</a>
<a name="ln990"> </a>
<a name="ln991">      /* the output dimensions of the good part of this specific tile */</a>
<a name="ln992">      size_t wd = (tx + 1) * tile_wd &gt; roi_out-&gt;width ? roi_out-&gt;width - tx * tile_wd : tile_wd;</a>
<a name="ln993">      size_t ht = (ty + 1) * tile_ht &gt; roi_out-&gt;height ? roi_out-&gt;height - ty * tile_ht : tile_ht;</a>
<a name="ln994"> </a>
<a name="ln995">      /* roi_in and roi_out of good part: oroi_good easy to calculate based on number and dimension of tile.</a>
<a name="ln996">         iroi_good is calculated by modify_roi_in() of respective module */</a>
<a name="ln997">      dt_iop_roi_t iroi_good = { roi_in-&gt;x + tx * tile_wd, roi_in-&gt;y + ty * tile_ht, wd, ht, roi_in-&gt;scale };</a>
<a name="ln998">      dt_iop_roi_t oroi_good</a>
<a name="ln999">          = { roi_out-&gt;x + tx * tile_wd, roi_out-&gt;y + ty * tile_ht, wd, ht, roi_out-&gt;scale };</a>
<a name="ln1000"> </a>
<a name="ln1001">      self-&gt;modify_roi_in(self, piece, &amp;oroi_good, &amp;iroi_good);</a>
<a name="ln1002"> </a>
<a name="ln1003">      /* clamp iroi_good to not exceed roi_in */</a>
<a name="ln1004">      iroi_good.x = _max(iroi_good.x, roi_in-&gt;x);</a>
<a name="ln1005">      iroi_good.y = _max(iroi_good.y, roi_in-&gt;y);</a>
<a name="ln1006">      iroi_good.width = _min(iroi_good.width, roi_in-&gt;width + roi_in-&gt;x - iroi_good.x);</a>
<a name="ln1007">      iroi_good.height = _min(iroi_good.height, roi_in-&gt;height + roi_in-&gt;y - iroi_good.y);</a>
<a name="ln1008"> </a>
<a name="ln1009">      //_print_roi(&amp;iroi_good, &quot;tile iroi_good&quot;);</a>
<a name="ln1010">      //_print_roi(&amp;oroi_good, &quot;tile oroi_good&quot;);</a>
<a name="ln1011"> </a>
<a name="ln1012">      /* now we need to calculate full region of this tile: increase input roi to take care of overlap</a>
<a name="ln1013">         requirements</a>
<a name="ln1014">         and alignment and add additional delta to correct for possible rounding errors in modify_roi_in()</a>
<a name="ln1015">         -&gt; generates first estimate of iroi_full */</a>
<a name="ln1016">      const int x_in = iroi_good.x;</a>
<a name="ln1017">      const int y_in = iroi_good.y;</a>
<a name="ln1018">      const int width_in = iroi_good.width;</a>
<a name="ln1019">      const int height_in = iroi_good.height;</a>
<a name="ln1020">      const int new_x_in = _max(_align_down(x_in - overlap_in - delta, xyalign), roi_in-&gt;x);</a>
<a name="ln1021">      const int new_y_in = _max(_align_down(y_in - overlap_in - delta, xyalign), roi_in-&gt;y);</a>
<a name="ln1022">      const int new_width_in = _min(_align_up(width_in + overlap_in + delta + (x_in - new_x_in), xyalign),</a>
<a name="ln1023">                                    roi_in-&gt;width + roi_in-&gt;x - new_x_in);</a>
<a name="ln1024">      const int new_height_in = _min(_align_up(height_in + overlap_in + delta + (y_in - new_y_in), xyalign),</a>
<a name="ln1025">                                     roi_in-&gt;height + roi_in-&gt;y - new_y_in);</a>
<a name="ln1026"> </a>
<a name="ln1027">      /* iroi_full based on calculated numbers and dimensions. oroi_full just set as a starting point for the</a>
<a name="ln1028">       * following iterative search */</a>
<a name="ln1029">      dt_iop_roi_t iroi_full = { new_x_in, new_y_in, new_width_in, new_height_in, iroi_good.scale };</a>
<a name="ln1030">      dt_iop_roi_t oroi_full = oroi_good; // a good starting point for optimization</a>
<a name="ln1031"> </a>
<a name="ln1032">      //_print_roi(&amp;iroi_full, &quot;tile iroi_full before optimization&quot;);</a>
<a name="ln1033">      //_print_roi(&amp;oroi_full, &quot;tile oroi_full before optimization&quot;);</a>
<a name="ln1034"> </a>
<a name="ln1035">      /* try to find a matching oroi_full */</a>
<a name="ln1036">      if(!_fit_output_to_input_roi(self, piece, &amp;iroi_full, &amp;oroi_full, delta, 10))</a>
<a name="ln1037">      {</a>
<a name="ln1038">        dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] can not handle requested roi's. tiling for &quot;</a>
<a name="ln1039">                               &quot;module '%s' not possible.\n&quot;,</a>
<a name="ln1040">                 self-&gt;op);</a>
<a name="ln1041">        goto error;</a>
<a name="ln1042">      }</a>
<a name="ln1043"> </a>
<a name="ln1044">      //_print_roi(&amp;iroi_full, &quot;tile iroi_full after optimization&quot;);</a>
<a name="ln1045">      //_print_roi(&amp;oroi_full, &quot;tile oroi_full after optimization&quot;);</a>
<a name="ln1046"> </a>
<a name="ln1047">      /* make sure that oroi_full at least covers the range of oroi_good.</a>
<a name="ln1048">         this step is needed due to the possibility of rounding errors */</a>
<a name="ln1049">      oroi_full.x = _min(oroi_full.x, oroi_good.x);</a>
<a name="ln1050">      oroi_full.y = _min(oroi_full.y, oroi_good.y);</a>
<a name="ln1051">      oroi_full.width = _max(oroi_full.width, oroi_good.x + oroi_good.width - oroi_full.x);</a>
<a name="ln1052">      oroi_full.height = _max(oroi_full.height, oroi_good.y + oroi_good.height - oroi_full.y);</a>
<a name="ln1053"> </a>
<a name="ln1054">      /* clamp oroi_full to not exceed roi_out */</a>
<a name="ln1055">      oroi_full.x = _max(oroi_full.x, roi_out-&gt;x);</a>
<a name="ln1056">      oroi_full.y = _max(oroi_full.y, roi_out-&gt;y);</a>
<a name="ln1057">      oroi_full.width = _min(oroi_full.width, roi_out-&gt;width + roi_out-&gt;x - oroi_full.x);</a>
<a name="ln1058">      oroi_full.height = _min(oroi_full.height, roi_out-&gt;height + roi_out-&gt;y - oroi_full.y);</a>
<a name="ln1059"> </a>
<a name="ln1060">      /* calculate final iroi_full */</a>
<a name="ln1061">      self-&gt;modify_roi_in(self, piece, &amp;oroi_full, &amp;iroi_full);</a>
<a name="ln1062"> </a>
<a name="ln1063">      /* clamp iroi_full to not exceed roi_in */</a>
<a name="ln1064">      iroi_full.x = _max(iroi_full.x, roi_in-&gt;x);</a>
<a name="ln1065">      iroi_full.y = _max(iroi_full.y, roi_in-&gt;y);</a>
<a name="ln1066">      iroi_full.width = _min(iroi_full.width, roi_in-&gt;width + roi_in-&gt;x - iroi_full.x);</a>
<a name="ln1067">      iroi_full.height = _min(iroi_full.height, roi_in-&gt;height + roi_in-&gt;y - iroi_full.y);</a>
<a name="ln1068"> </a>
<a name="ln1069"> </a>
<a name="ln1070">      //_print_roi(&amp;iroi_full, &quot;tile iroi_full final&quot;);</a>
<a name="ln1071">      //_print_roi(&amp;oroi_full, &quot;tile oroi_full final&quot;);</a>
<a name="ln1072"> </a>
<a name="ln1073">      /* offsets of tile into ivoid and ovoid */</a>
<a name="ln1074">      size_t ioffs = ((size_t)iroi_full.y - roi_in-&gt;y) * ipitch + ((size_t)iroi_full.x - roi_in-&gt;x) * in_bpp;</a>
<a name="ln1075">      size_t ooffs = ((size_t)oroi_good.y - roi_out-&gt;y) * opitch</a>
<a name="ln1076">                     + ((size_t)oroi_good.x - roi_out-&gt;x) * out_bpp;</a>
<a name="ln1077"> </a>
<a name="ln1078">      dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] tile (%zu, %zu) with %d x %d at origin [%d, %d]\n&quot;,</a>
<a name="ln1079">               tx, ty, iroi_full.width, iroi_full.height, iroi_full.x, iroi_full.y);</a>
<a name="ln1080"> </a>
<a name="ln1081"> </a>
<a name="ln1082">      /* prepare input tile buffer */</a>
<a name="ln1083">      input = dt_alloc_align(64, (size_t)iroi_full.width * iroi_full.height * in_bpp);</a>
<a name="ln1084">      if(input == NULL)</a>
<a name="ln1085">      {</a>
<a name="ln1086">        dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] could not alloc input buffer for module '%s'\n&quot;,</a>
<a name="ln1087">                 self-&gt;op);</a>
<a name="ln1088">        goto error;</a>
<a name="ln1089">      }</a>
<a name="ln1090">      output = dt_alloc_align(64, (size_t)oroi_full.width * oroi_full.height * out_bpp);</a>
<a name="ln1091">      if(output == NULL)</a>
<a name="ln1092">      {</a>
<a name="ln1093">        dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] could not alloc output buffer for module '%s'\n&quot;,</a>
<a name="ln1094">                 self-&gt;op);</a>
<a name="ln1095">        goto error;</a>
<a name="ln1096">      }</a>
<a name="ln1097"> </a>
<a name="ln1098">#ifdef _OPENMP</a>
<a name="ln1099">#pragma omp parallel for default(none) shared(input, ioffs, iroi_full) schedule(static)</a>
<a name="ln1100">#endif</a>
<a name="ln1101">      for(size_t j = 0; j &lt; iroi_full.height; j++)</a>
<a name="ln1102">        memcpy((char *)input + j * iroi_full.width * in_bpp, (char *)ivoid + ioffs + j * ipitch,</a>
<a name="ln1103">               (size_t)iroi_full.width * in_bpp);</a>
<a name="ln1104"> </a>
<a name="ln1105">      /* take original processed_maximum as starting point */</a>
<a name="ln1106">      for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_saved[k];</a>
<a name="ln1107"> </a>
<a name="ln1108">      /* call process() of module */</a>
<a name="ln1109">      self-&gt;process(self, piece, input, output, &amp;iroi_full, &amp;oroi_full);</a>
<a name="ln1110"> </a>
<a name="ln1111">      /* aggregate resulting processed_maximum */</a>
<a name="ln1112">      /* TODO: check if there really can be differences between tiles and take</a>
<a name="ln1113">               appropriate action (calculate minimum, maximum, average, ...?) */</a>
<a name="ln1114">      for(int k = 0; k &lt; 4; k++)</a>
<a name="ln1115">      {</a>
<a name="ln1116">        if(tx + ty &gt; 0 &amp;&amp; fabs(processed_maximum_new[k] - piece-&gt;pipe-&gt;dsc.processed_maximum[k]) &gt; 1.0e-6f)</a>
<a name="ln1117">          dt_print(</a>
<a name="ln1118">              DT_DEBUG_DEV,</a>
<a name="ln1119">              &quot;[default_process_tiling_roi] processed_maximum[%d] differs between tiles in module '%s'\n&quot;, k,</a>
<a name="ln1120">              self-&gt;op);</a>
<a name="ln1121">        processed_maximum_new[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln1122">      }</a>
<a name="ln1123"> </a>
<a name="ln1124">      /* copy &quot;good&quot; part of tile to output buffer */</a>
<a name="ln1125">      const int origin_x = oroi_good.x - oroi_full.x;</a>
<a name="ln1126">      const int origin_y = oroi_good.y - oroi_full.y;</a>
<a name="ln1127">#ifdef _OPENMP</a>
<a name="ln1128">#pragma omp parallel for default(none) shared(ooffs, output, oroi_good, oroi_full) schedule(static)</a>
<a name="ln1129">#endif</a>
<a name="ln1130">      for(size_t j = 0; j &lt; oroi_good.height; j++)</a>
<a name="ln1131">        memcpy((char *)ovoid + ooffs + j * opitch,</a>
<a name="ln1132">               (char *)output + ((j + origin_y) * oroi_full.width + origin_x) * out_bpp,</a>
<a name="ln1133">               (size_t)oroi_good.width * out_bpp);</a>
<a name="ln1134"> </a>
<a name="ln1135">      dt_free_align(input);</a>
<a name="ln1136">      dt_free_align(output);</a>
<a name="ln1137">      input = output = NULL;</a>
<a name="ln1138">    }</a>
<a name="ln1139"> </a>
<a name="ln1140">  /* copy back final processed_maximum */</a>
<a name="ln1141">  for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_new[k];</a>
<a name="ln1142"> </a>
<a name="ln1143">  if(input != NULL) dt_free_align(input);</a>
<a name="ln1144">  if(output != NULL) dt_free_align(output);</a>
<a name="ln1145">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln1146">  return;</a>
<a name="ln1147"> </a>
<a name="ln1148">error:</a>
<a name="ln1149">  dt_control_log(_(&quot;tiling failed for module '%s'. output might be garbled.&quot;), self-&gt;op);</a>
<a name="ln1150">// fall through</a>
<a name="ln1151"> </a>
<a name="ln1152">fallback:</a>
<a name="ln1153">  if(input != NULL) dt_free_align(input);</a>
<a name="ln1154">  if(output != NULL) dt_free_align(output);</a>
<a name="ln1155">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln1156">  dt_print(DT_DEBUG_DEV, &quot;[default_process_tiling_roi] fall back to standard processing for module '%s'\n&quot;,</a>
<a name="ln1157">           self-&gt;op);</a>
<a name="ln1158">  self-&gt;process(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln1159">  return;</a>
<a name="ln1160">}</a>
<a name="ln1161"> </a>
<a name="ln1162"> </a>
<a name="ln1163"> </a>
<a name="ln1164">/* if a module does not implement process_tiling() by itself, this function is called instead.</a>
<a name="ln1165">   _default_process_tiling_ptp() is able to handle standard cases where pixels do not change their places.</a>
<a name="ln1166">   _default_process_tiling_roi() takes care of all other cases where image gets distorted and for module</a>
<a name="ln1167">   &quot;clipping&quot;,</a>
<a name="ln1168">   &quot;flip&quot; as this may flip or mirror the image. */</a>
<a name="ln1169">void default_process_tiling(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1170">                            const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln1171">                            const dt_iop_roi_t *const roi_out, const int in_bpp)</a>
<a name="ln1172">{</a>
<a name="ln1173">  if(memcmp(roi_in, roi_out, sizeof(struct dt_iop_roi_t)) || (self-&gt;flags() &amp; IOP_FLAGS_TILING_FULL_ROI))</a>
<a name="ln1174">    _default_process_tiling_roi(self, piece, ivoid, ovoid, roi_in, roi_out, in_bpp);</a>
<a name="ln1175">  else</a>
<a name="ln1176">    _default_process_tiling_ptp(self, piece, ivoid, ovoid, roi_in, roi_out, in_bpp);</a>
<a name="ln1177">  return;</a>
<a name="ln1178">}</a>
<a name="ln1179"> </a>
<a name="ln1180"> </a>
<a name="ln1181"> </a>
<a name="ln1182">#ifdef HAVE_OPENCL</a>
<a name="ln1183">/* simple tiling algorithm for roi_in == roi_out, i.e. for pixel to pixel modules/operations */</a>
<a name="ln1184">static int _default_process_tiling_cl_ptp(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1185">                                          const void *const ivoid, void *const ovoid,</a>
<a name="ln1186">                                          const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln1187">                                          const int in_bpp)</a>
<a name="ln1188">{</a>
<a name="ln1189">  cl_int err = -999;</a>
<a name="ln1190">  cl_mem input = NULL;</a>
<a name="ln1191">  cl_mem output = NULL;</a>
<a name="ln1192">  cl_mem pinned_input = NULL;</a>
<a name="ln1193">  cl_mem pinned_output = NULL;</a>
<a name="ln1194">  void *input_buffer = NULL;</a>
<a name="ln1195">  void *output_buffer = NULL;</a>
<a name="ln1196"> </a>
<a name="ln1197">  dt_iop_buffer_dsc_t dsc;</a>
<a name="ln1198">  self-&gt;output_format(self, piece-&gt;pipe, piece, &amp;dsc);</a>
<a name="ln1199">  const int out_bpp = dt_iop_buffer_dsc_to_bpp(&amp;dsc);</a>
<a name="ln1200"> </a>
<a name="ln1201">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln1202">  const int ipitch = roi_in-&gt;width * in_bpp;</a>
<a name="ln1203">  const int opitch = roi_out-&gt;width * out_bpp;</a>
<a name="ln1204">  const int max_bpp = _max(in_bpp, out_bpp);</a>
<a name="ln1205"> </a>
<a name="ln1206">  /* get tiling requirements of module */</a>
<a name="ln1207">  dt_develop_tiling_t tiling = { 0 };</a>
<a name="ln1208">  self-&gt;tiling_callback(self, piece, roi_in, roi_out, &amp;tiling);</a>
<a name="ln1209"> </a>
<a name="ln1210">  /* shall we use pinned memory transfers? */</a>
<a name="ln1211">  int use_pinned_memory = dt_conf_get_bool(&quot;opencl_use_pinned_memory&quot;);</a>
<a name="ln1212">  const int pinned_buffer_overhead = use_pinned_memory ? 2 : 0; // add two additional pinned memory buffers</a>
<a name="ln1213">                                                                // which seemingly get allocated not only on</a>
<a name="ln1214">                                                                // host but also on device (why???)</a>
<a name="ln1215">  const float pinned_buffer_slack</a>
<a name="ln1216">      = use_pinned_memory</a>
<a name="ln1217">            ? 0.85f</a>
<a name="ln1218">            : 1.0f; // avoid problems when pinned buffer size gets too close to max_mem_alloc size</a>
<a name="ln1219"> </a>
<a name="ln1220">  /* calculate optimal size of tiles */</a>
<a name="ln1221">  float headroom = dt_conf_get_float(&quot;opencl_memory_headroom&quot;) * 1024.0f * 1024.0f;</a>
<a name="ln1222">  headroom = fmin(fmax(headroom, 0.0f), (float)darktable.opencl-&gt;dev[devid].max_global_mem);</a>
<a name="ln1223">  const float available = darktable.opencl-&gt;dev[devid].max_global_mem - headroom;</a>
<a name="ln1224">  float factor = fmax(tiling.factor + pinned_buffer_overhead, 1.0f);</a>
<a name="ln1225">  const float singlebuffer = fmin(fmax((available - tiling.overhead) / factor, 0.0f),</a>
<a name="ln1226">                                  pinned_buffer_slack * darktable.opencl-&gt;dev[devid].max_mem_alloc);</a>
<a name="ln1227">  float maxbuf = fmax(tiling.maxbuf, 1.0f);</a>
<a name="ln1228">  int width = _min(roi_in-&gt;width, darktable.opencl-&gt;dev[devid].max_image_width);</a>
<a name="ln1229">  int height = _min(roi_in-&gt;height, darktable.opencl-&gt;dev[devid].max_image_height);</a>
<a name="ln1230"> </a>
<a name="ln1231">  /* shrink tile size in case it would exceed singlebuffer size */</a>
<a name="ln1232">  if((float)width * height * max_bpp * maxbuf &gt; singlebuffer)</a>
<a name="ln1233">  {</a>
<a name="ln1234">    const float scale = singlebuffer / ((float)width * height * max_bpp * maxbuf);</a>
<a name="ln1235"> </a>
<a name="ln1236">    if(width &lt; height &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln1237">    {</a>
<a name="ln1238">      height = floorf(height * scale);</a>
<a name="ln1239">    }</a>
<a name="ln1240">    else if(height &lt;= width &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln1241">    {</a>
<a name="ln1242">      width = floorf(width * scale);</a>
<a name="ln1243">    }</a>
<a name="ln1244">    else</a>
<a name="ln1245">    {</a>
<a name="ln1246">      width = floorf(width * sqrt(scale));</a>
<a name="ln1247">      height = floorf(height * sqrt(scale));</a>
<a name="ln1248">    }</a>
<a name="ln1249">  }</a>
<a name="ln1250"> </a>
<a name="ln1251">  /* make sure we have a reasonably effective tile dimension. if not try square tiles */</a>
<a name="ln1252">  if(3 * tiling.overlap &gt; width || 3 * tiling.overlap &gt; height)</a>
<a name="ln1253">  {</a>
<a name="ln1254">    width = height = floorf(sqrtf((float)width * height));</a>
<a name="ln1255">  }</a>
<a name="ln1256"> </a>
<a name="ln1257"> </a>
<a name="ln1258">  /* Alignment rules: we need to make sure that alignment requirements of module are fulfilled.</a>
<a name="ln1259">     Modules will report alignment requirements via xalign and yalign within tiling_callback().</a>
<a name="ln1260">     Typical use case is demosaic where Bayer pattern requires alignment to a multiple of 2 in x and y</a>
<a name="ln1261">     direction. Additional alignment requirements are set via definition of CL_ALIGNMENT.</a>
<a name="ln1262">     We guarantee alignment by selecting image width/height and overlap accordingly. For a tile width/height</a>
<a name="ln1263">     that is identical to image width/height no special alignment is done. */</a>
<a name="ln1264"> </a>
<a name="ln1265">  /* for simplicity reasons we use only one alignment that fits to x and y requirements at the same time */</a>
<a name="ln1266">  const unsigned int xyalign = _lcm(tiling.xalign, tiling.yalign);</a>
<a name="ln1267"> </a>
<a name="ln1268">  /* determining alignment requirement for tile width/height.</a>
<a name="ln1269">     in case of tile width also align according to definition of CL_ALIGNMENT */</a>
<a name="ln1270">  const unsigned int walign = _lcm(xyalign, CL_ALIGNMENT);</a>
<a name="ln1271">  const unsigned int halign = xyalign;</a>
<a name="ln1272"> </a>
<a name="ln1273">  assert(xyalign != 0 &amp;&amp; walign != 0 &amp;&amp; halign != 0);</a>
<a name="ln1274"> </a>
<a name="ln1275">  /* properly align tile width and height by making them smaller if needed */</a>
<a name="ln1276">  if(width &lt; roi_in-&gt;width) width = (width / walign) * walign;</a>
<a name="ln1277">  if(height &lt; roi_in-&gt;height) height = (height / halign) * halign;</a>
<a name="ln1278"> </a>
<a name="ln1279">  /* also make sure that overlap follows alignment rules by making it wider when needed */</a>
<a name="ln1280">  const int overlap = tiling.overlap % xyalign != 0 ? (tiling.overlap / xyalign + 1) * xyalign</a>
<a name="ln1281">                                                    : tiling.overlap;</a>
<a name="ln1282"> </a>
<a name="ln1283"> </a>
<a name="ln1284">  /* calculate effective tile size */</a>
<a name="ln1285">  const int tile_wd = width - 2 * overlap &gt; 0 ? width - 2 * overlap : 1;</a>
<a name="ln1286">  const int tile_ht = height - 2 * overlap &gt; 0 ? height - 2 * overlap : 1;</a>
<a name="ln1287"> </a>
<a name="ln1288"> </a>
<a name="ln1289">  /* calculate number of tiles */</a>
<a name="ln1290">  const int tiles_x = width &lt; roi_in-&gt;width ? ceilf(roi_in-&gt;width / (float)tile_wd) : 1;</a>
<a name="ln1291">  const int tiles_y = height &lt; roi_in-&gt;height ? ceilf(roi_in-&gt;height / (float)tile_ht) : 1;</a>
<a name="ln1292"> </a>
<a name="ln1293">  /* sanity check: don't run wild on too many tiles */</a>
<a name="ln1294">  if(tiles_x * tiles_y &gt; dt_conf_get_int(&quot;maximum_number_tiles&quot;))</a>
<a name="ln1295">  {</a>
<a name="ln1296">    dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1297">             &quot;[default_process_tiling_cl_ptp] aborted tiling for module '%s'. too many tiles: %d x %d\n&quot;,</a>
<a name="ln1298">             self-&gt;op, tiles_x, tiles_y);</a>
<a name="ln1299">    return FALSE;</a>
<a name="ln1300">  }</a>
<a name="ln1301"> </a>
<a name="ln1302"> </a>
<a name="ln1303">  dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1304">           &quot;[default_process_tiling_cl_ptp] use tiling on module '%s' for image with full size %d x %d\n&quot;,</a>
<a name="ln1305">           self-&gt;op, roi_in-&gt;width, roi_in-&gt;height);</a>
<a name="ln1306">  dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1307">           &quot;[default_process_tiling_cl_ptp] (%d x %d) tiles with max dimensions %d x %d and overlap %d\n&quot;,</a>
<a name="ln1308">           tiles_x, tiles_y, width, height, overlap);</a>
<a name="ln1309"> </a>
<a name="ln1310">  /* store processed_maximum to be re-used and aggregated */</a>
<a name="ln1311">  float processed_maximum_saved[4];</a>
<a name="ln1312">  float processed_maximum_new[4] = { 1.0f };</a>
<a name="ln1313">  for(int k = 0; k &lt; 4; k++) processed_maximum_saved[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln1314"> </a>
<a name="ln1315">  /* reserve pinned input and output memory for host&lt;-&gt;device data transfer */</a>
<a name="ln1316">  if(use_pinned_memory)</a>
<a name="ln1317">  {</a>
<a name="ln1318">    pinned_input = dt_opencl_alloc_device_buffer_with_flags(devid, (size_t)width * height * in_bpp,</a>
<a name="ln1319">                                                            CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR);</a>
<a name="ln1320">    if(pinned_input == NULL)</a>
<a name="ln1321">    {</a>
<a name="ln1322">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1323">               &quot;[default_process_tiling_cl_ptp] could not alloc pinned input buffer for module '%s'\n&quot;,</a>
<a name="ln1324">               self-&gt;op);</a>
<a name="ln1325">      use_pinned_memory = 0;</a>
<a name="ln1326">    }</a>
<a name="ln1327">  }</a>
<a name="ln1328"> </a>
<a name="ln1329">  if(use_pinned_memory)</a>
<a name="ln1330">  {</a>
<a name="ln1331"> </a>
<a name="ln1332">    input_buffer = dt_opencl_map_buffer(devid, pinned_input, CL_TRUE, CL_MAP_WRITE, 0,</a>
<a name="ln1333">                                        (size_t)width * height * in_bpp);</a>
<a name="ln1334">    if(input_buffer == NULL)</a>
<a name="ln1335">    {</a>
<a name="ln1336">      dt_print(DT_DEBUG_OPENCL, &quot;[default_process_tiling_cl_ptp] could not map pinned input buffer to host &quot;</a>
<a name="ln1337">                                &quot;memory for module '%s'\n&quot;,</a>
<a name="ln1338">               self-&gt;op);</a>
<a name="ln1339">      use_pinned_memory = 0;</a>
<a name="ln1340">    }</a>
<a name="ln1341">  }</a>
<a name="ln1342"> </a>
<a name="ln1343">  if(use_pinned_memory)</a>
<a name="ln1344">  {</a>
<a name="ln1345"> </a>
<a name="ln1346">    pinned_output = dt_opencl_alloc_device_buffer_with_flags(devid, (size_t)width * height * out_bpp,</a>
<a name="ln1347">                                                             CL_MEM_WRITE_ONLY | CL_MEM_ALLOC_HOST_PTR);</a>
<a name="ln1348">    if(pinned_output == NULL)</a>
<a name="ln1349">    {</a>
<a name="ln1350">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1351">               &quot;[default_process_tiling_cl_ptp] could not alloc pinned output buffer for module '%s'\n&quot;,</a>
<a name="ln1352">               self-&gt;op);</a>
<a name="ln1353">      use_pinned_memory = 0;</a>
<a name="ln1354">    }</a>
<a name="ln1355">  }</a>
<a name="ln1356"> </a>
<a name="ln1357">  if(use_pinned_memory)</a>
<a name="ln1358">  {</a>
<a name="ln1359"> </a>
<a name="ln1360">    output_buffer = dt_opencl_map_buffer(devid, pinned_output, CL_TRUE, CL_MAP_READ, 0,</a>
<a name="ln1361">                                         (size_t)width * height * out_bpp);</a>
<a name="ln1362">    if(output_buffer == NULL)</a>
<a name="ln1363">    {</a>
<a name="ln1364">      dt_print(DT_DEBUG_OPENCL, &quot;[default_process_tiling_cl_ptp] could not map pinned output buffer to host &quot;</a>
<a name="ln1365">                                &quot;memory for module '%s'\n&quot;,</a>
<a name="ln1366">               self-&gt;op);</a>
<a name="ln1367">      use_pinned_memory = 0;</a>
<a name="ln1368">    }</a>
<a name="ln1369">  }</a>
<a name="ln1370"> </a>
<a name="ln1371">  /* iterate over tiles */</a>
<a name="ln1372">  for(size_t tx = 0; tx &lt; tiles_x; tx++)</a>
<a name="ln1373">    for(size_t ty = 0; ty &lt; tiles_y; ty++)</a>
<a name="ln1374">    {</a>
<a name="ln1375">      piece-&gt;pipe-&gt;tiling = 1;</a>
<a name="ln1376"> </a>
<a name="ln1377">      size_t wd = tx * tile_wd + width &gt; roi_in-&gt;width ? roi_in-&gt;width - tx * tile_wd : width;</a>
<a name="ln1378">      size_t ht = ty * tile_ht + height &gt; roi_in-&gt;height ? roi_in-&gt;height - ty * tile_ht : height;</a>
<a name="ln1379"> </a>
<a name="ln1380">      /* no need to process (end)tiles that are smaller than the total overlap area */</a>
<a name="ln1381">      if((wd &lt;= 2 * overlap &amp;&amp; tx &gt; 0) || (ht &lt;= 2 * overlap &amp;&amp; ty &gt; 0)) continue;</a>
<a name="ln1382"> </a>
<a name="ln1383">      /* origin and region of effective part of tile, which we want to store later */</a>
<a name="ln1384">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln1385">      size_t region[] = { wd, ht, 1 };</a>
<a name="ln1386"> </a>
<a name="ln1387">      /* roi_in and roi_out for process_cl on subbuffer */</a>
<a name="ln1388">      dt_iop_roi_t iroi = { roi_in-&gt;x + tx * tile_wd, roi_in-&gt;y + ty * tile_ht, wd, ht, roi_in-&gt;scale };</a>
<a name="ln1389">      dt_iop_roi_t oroi = { roi_out-&gt;x + tx * tile_wd, roi_out-&gt;y + ty * tile_ht, wd, ht, roi_out-&gt;scale };</a>
<a name="ln1390"> </a>
<a name="ln1391"> </a>
<a name="ln1392">      /* offsets of tile into ivoid and ovoid */</a>
<a name="ln1393">      size_t ioffs = (ty * tile_ht) * ipitch + (tx * tile_wd) * in_bpp;</a>
<a name="ln1394">      size_t ooffs = (ty * tile_ht) * opitch + (tx * tile_wd) * out_bpp;</a>
<a name="ln1395"> </a>
<a name="ln1396"> </a>
<a name="ln1397">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1398">               &quot;[default_process_tiling_cl_ptp] tile (%zu, %zu) with %zu x %zu at origin [%zu, %zu]\n&quot;, tx, ty, wd,</a>
<a name="ln1399">               ht, tx * tile_wd, ty * tile_ht);</a>
<a name="ln1400"> </a>
<a name="ln1401">      /* get input and output buffers */</a>
<a name="ln1402">      input = dt_opencl_alloc_device(devid, wd, ht, in_bpp);</a>
<a name="ln1403">      if(input == NULL) goto error;</a>
<a name="ln1404">      output = dt_opencl_alloc_device(devid, wd, ht, out_bpp);</a>
<a name="ln1405">      if(output == NULL) goto error;</a>
<a name="ln1406"> </a>
<a name="ln1407">      if(use_pinned_memory)</a>
<a name="ln1408">      {</a>
<a name="ln1409">/* prepare pinned input tile buffer: copy part of input image */</a>
<a name="ln1410">#ifdef _OPENMP</a>
<a name="ln1411">#pragma omp parallel for default(none) shared(input_buffer, width, ioffs, wd, ht) schedule(static)</a>
<a name="ln1412">#endif</a>
<a name="ln1413">        for(size_t j = 0; j &lt; ht; j++)</a>
<a name="ln1414">          memcpy((char *)input_buffer + j * wd * in_bpp, (char *)ivoid + ioffs + j * ipitch,</a>
<a name="ln1415">                 (size_t)wd * in_bpp);</a>
<a name="ln1416"> </a>
<a name="ln1417">        /* blocking memory transfer: pinned host input buffer -&gt; opencl/device tile */</a>
<a name="ln1418">        err = dt_opencl_write_host_to_device_raw(devid, (char *)input_buffer, input, origin, region,</a>
<a name="ln1419">                                                 wd * in_bpp, CL_TRUE);</a>
<a name="ln1420">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1421">      }</a>
<a name="ln1422">      else</a>
<a name="ln1423">      {</a>
<a name="ln1424">        /* blocking direct memory transfer: host input image -&gt; opencl/device tile */</a>
<a name="ln1425">        err = dt_opencl_write_host_to_device_raw(devid, (char *)ivoid + ioffs, input, origin, region, ipitch,</a>
<a name="ln1426">                                                 CL_TRUE);</a>
<a name="ln1427">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1428">      }</a>
<a name="ln1429"> </a>
<a name="ln1430">      /* take original processed_maximum as starting point */</a>
<a name="ln1431">      for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_saved[k];</a>
<a name="ln1432"> </a>
<a name="ln1433">      /* call process_cl of module */</a>
<a name="ln1434">      if(!self-&gt;process_cl(self, piece, input, output, &amp;iroi, &amp;oroi)) goto error;</a>
<a name="ln1435"> </a>
<a name="ln1436">      /* aggregate resulting processed_maximum */</a>
<a name="ln1437">      /* TODO: check if there really can be differences between tiles and take</a>
<a name="ln1438">               appropriate action (calculate minimum, maximum, average, ...?) */</a>
<a name="ln1439">      for(int k = 0; k &lt; 4; k++)</a>
<a name="ln1440">      {</a>
<a name="ln1441">        if(tx + ty &gt; 0 &amp;&amp; fabs(processed_maximum_new[k] - piece-&gt;pipe-&gt;dsc.processed_maximum[k]) &gt; 1.0e-6f)</a>
<a name="ln1442">          dt_print(</a>
<a name="ln1443">              DT_DEBUG_OPENCL,</a>
<a name="ln1444">              &quot;[default_process_tiling_cl_ptp] processed_maximum[%d] differs between tiles in module '%s'\n&quot;,</a>
<a name="ln1445">              k, self-&gt;op);</a>
<a name="ln1446">        processed_maximum_new[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln1447">      }</a>
<a name="ln1448"> </a>
<a name="ln1449">      if(use_pinned_memory)</a>
<a name="ln1450">      {</a>
<a name="ln1451">        /* blocking memory transfer: complete opencl/device tile -&gt; pinned host output buffer */</a>
<a name="ln1452">        err = dt_opencl_read_host_from_device_raw(devid, (char *)output_buffer, output, origin, region,</a>
<a name="ln1453">                                                  wd * out_bpp, CL_TRUE);</a>
<a name="ln1454">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1455">      }</a>
<a name="ln1456"> </a>
<a name="ln1457">      /* correct origin and region of tile for overlap.</a>
<a name="ln1458">         makes sure that we only copy back the &quot;good&quot; part. */</a>
<a name="ln1459">      if(tx &gt; 0)</a>
<a name="ln1460">      {</a>
<a name="ln1461">        origin[0] += overlap;</a>
<a name="ln1462">        region[0] -= overlap;</a>
<a name="ln1463">        ooffs += overlap * out_bpp;</a>
<a name="ln1464">      }</a>
<a name="ln1465">      if(ty &gt; 0)</a>
<a name="ln1466">      {</a>
<a name="ln1467">        origin[1] += overlap;</a>
<a name="ln1468">        region[1] -= overlap;</a>
<a name="ln1469">        ooffs += overlap * opitch;</a>
<a name="ln1470">      }</a>
<a name="ln1471"> </a>
<a name="ln1472">      if(use_pinned_memory)</a>
<a name="ln1473">      {</a>
<a name="ln1474">/* copy &quot;good&quot; part of tile from pinned output buffer to output image */</a>
<a name="ln1475">#if 0 // def _OPENMP</a>
<a name="ln1476">#pragma omp parallel for default(none) shared(ovoid, ooffs, output_buffer, width, origin, region,            \</a>
<a name="ln1477">                                              wd) schedule(static)</a>
<a name="ln1478">#endif</a>
<a name="ln1479">        for(size_t j = 0; j &lt; region[1]; j++)</a>
<a name="ln1480">          memcpy((char *)ovoid + ooffs + j * opitch,</a>
<a name="ln1481">                 (char *)output_buffer + ((j + origin[1]) * wd + origin[0]) * out_bpp,</a>
<a name="ln1482">                 (size_t)region[0] * out_bpp);</a>
<a name="ln1483">      }</a>
<a name="ln1484">      else</a>
<a name="ln1485">      {</a>
<a name="ln1486">        /* blocking direct memory transfer: good part of opencl/device tile -&gt; host output image */</a>
<a name="ln1487">        err = dt_opencl_read_host_from_device_raw(devid, (char *)ovoid + ooffs, output, origin, region,</a>
<a name="ln1488">                                                  opitch, CL_TRUE);</a>
<a name="ln1489">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1490">      }</a>
<a name="ln1491"> </a>
<a name="ln1492">      /* release input and output buffers */</a>
<a name="ln1493">      dt_opencl_release_mem_object(input);</a>
<a name="ln1494">      input = NULL;</a>
<a name="ln1495">      dt_opencl_release_mem_object(output);</a>
<a name="ln1496">      output = NULL;</a>
<a name="ln1497"> </a>
<a name="ln1498">      /* block until opencl queue has finished to free all used event handlers */</a>
<a name="ln1499">      if(!darktable.opencl-&gt;async_pixelpipe || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_EXPORT)</a>
<a name="ln1500">        dt_opencl_finish(devid);</a>
<a name="ln1501">    }</a>
<a name="ln1502"> </a>
<a name="ln1503">  /* copy back final processed_maximum */</a>
<a name="ln1504">  for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_new[k];</a>
<a name="ln1505"> </a>
<a name="ln1506">  if(input_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_input, input_buffer);</a>
<a name="ln1507">  dt_opencl_release_mem_object(pinned_input);</a>
<a name="ln1508">  if(output_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_output, output_buffer);</a>
<a name="ln1509">  dt_opencl_release_mem_object(pinned_output);</a>
<a name="ln1510">  dt_opencl_release_mem_object(input);</a>
<a name="ln1511">  dt_opencl_release_mem_object(output);</a>
<a name="ln1512">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln1513">  return TRUE;</a>
<a name="ln1514"> </a>
<a name="ln1515">error:</a>
<a name="ln1516">  /* copy back stored processed_maximum */</a>
<a name="ln1517">  for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_saved[k];</a>
<a name="ln1518">  if(input_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_input, input_buffer);</a>
<a name="ln1519">  dt_opencl_release_mem_object(pinned_input);</a>
<a name="ln1520">  if(output_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_output, output_buffer);</a>
<a name="ln1521">  dt_opencl_release_mem_object(pinned_output);</a>
<a name="ln1522">  dt_opencl_release_mem_object(input);</a>
<a name="ln1523">  dt_opencl_release_mem_object(output);</a>
<a name="ln1524">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln1525">  dt_print(</a>
<a name="ln1526">      DT_DEBUG_OPENCL,</a>
<a name="ln1527">      &quot;[default_process_tiling_opencl_ptp] couldn't run process_cl() for module '%s' in tiling mode: %d\n&quot;,</a>
<a name="ln1528">      self-&gt;op, err);</a>
<a name="ln1529">  return FALSE;</a>
<a name="ln1530">}</a>
<a name="ln1531"> </a>
<a name="ln1532"> </a>
<a name="ln1533">/* more elaborate tiling algorithm for roi_in != roi_out: slower than the ptp variant,</a>
<a name="ln1534">   more tiles and larger overlap */</a>
<a name="ln1535">static int _default_process_tiling_cl_roi(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1536">                                          const void *const ivoid, void *const ovoid,</a>
<a name="ln1537">                                          const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln1538">                                          const int in_bpp)</a>
<a name="ln1539">{</a>
<a name="ln1540">  cl_int err = -999;</a>
<a name="ln1541">  cl_mem input = NULL;</a>
<a name="ln1542">  cl_mem output = NULL;</a>
<a name="ln1543">  cl_mem pinned_input = NULL;</a>
<a name="ln1544">  cl_mem pinned_output = NULL;</a>
<a name="ln1545">  void *input_buffer = NULL;</a>
<a name="ln1546">  void *output_buffer = NULL;</a>
<a name="ln1547"> </a>
<a name="ln1548"> </a>
<a name="ln1549">  //_print_roi(roi_in, &quot;module roi_in&quot;);</a>
<a name="ln1550">  //_print_roi(roi_out, &quot;module roi_out&quot;);</a>
<a name="ln1551"> </a>
<a name="ln1552">  dt_iop_buffer_dsc_t dsc;</a>
<a name="ln1553">  self-&gt;output_format(self, piece-&gt;pipe, piece, &amp;dsc);</a>
<a name="ln1554">  const int out_bpp = dt_iop_buffer_dsc_to_bpp(&amp;dsc);</a>
<a name="ln1555"> </a>
<a name="ln1556">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln1557">  const int ipitch = roi_in-&gt;width * in_bpp;</a>
<a name="ln1558">  const int opitch = roi_out-&gt;width * out_bpp;</a>
<a name="ln1559">  const int max_bpp = _max(in_bpp, out_bpp);</a>
<a name="ln1560"> </a>
<a name="ln1561">  float fullscale = fmax(roi_in-&gt;scale / roi_out-&gt;scale, sqrt(((float)roi_in-&gt;width * roi_in-&gt;height)</a>
<a name="ln1562">                                                              / ((float)roi_out-&gt;width * roi_out-&gt;height)));</a>
<a name="ln1563"> </a>
<a name="ln1564">  /* inaccuracy for roi_in elements in roi_out -&gt; roi_in calculations */</a>
<a name="ln1565">  const int delta = ceilf(fullscale);</a>
<a name="ln1566"> </a>
<a name="ln1567">  /* estimate for additional (space) requirement in buffer dimensions due to inaccuracies */</a>
<a name="ln1568">  const int inacc = RESERVE * delta;</a>
<a name="ln1569"> </a>
<a name="ln1570">  /* get tiling requirements of module */</a>
<a name="ln1571">  dt_develop_tiling_t tiling = { 0 };</a>
<a name="ln1572">  self-&gt;tiling_callback(self, piece, roi_in, roi_out, &amp;tiling);</a>
<a name="ln1573"> </a>
<a name="ln1574">  /* shall we use pinned memory transfers? */</a>
<a name="ln1575">  int use_pinned_memory = dt_conf_get_bool(&quot;opencl_use_pinned_memory&quot;);</a>
<a name="ln1576">  const int pinned_buffer_overhead = use_pinned_memory ? 2 : 0; // add two additional pinned memory buffers</a>
<a name="ln1577">                                                                // which seemingly get allocated not only on</a>
<a name="ln1578">                                                                // host but also on device (why???)</a>
<a name="ln1579">  const float pinned_buffer_slack</a>
<a name="ln1580">      = use_pinned_memory</a>
<a name="ln1581">            ? 0.85f</a>
<a name="ln1582">            : 1.0f; // avoid problems when pinned buffer size gets too close to max_mem_alloc size</a>
<a name="ln1583"> </a>
<a name="ln1584">  /* calculate optimal size of tiles */</a>
<a name="ln1585">  float headroom = dt_conf_get_float(&quot;opencl_memory_headroom&quot;) * 1024.0f * 1024.0f;</a>
<a name="ln1586">  headroom = fmin(fmax(headroom, 0.0f), (float)darktable.opencl-&gt;dev[devid].max_global_mem);</a>
<a name="ln1587">  const float available = darktable.opencl-&gt;dev[devid].max_global_mem - headroom;</a>
<a name="ln1588">  float factor = fmax(tiling.factor + pinned_buffer_overhead, 1.0f);</a>
<a name="ln1589">  const float singlebuffer = fmin(fmax((available - tiling.overhead) / factor, 0.0f),</a>
<a name="ln1590">                                  pinned_buffer_slack * darktable.opencl-&gt;dev[devid].max_mem_alloc);</a>
<a name="ln1591">  float maxbuf = fmax(tiling.maxbuf, 1.0f);</a>
<a name="ln1592"> </a>
<a name="ln1593">  int width = _min(_max(roi_in-&gt;width, roi_out-&gt;width), darktable.opencl-&gt;dev[devid].max_image_width);</a>
<a name="ln1594">  int height = _min(_max(roi_in-&gt;height, roi_out-&gt;height), darktable.opencl-&gt;dev[devid].max_image_height);</a>
<a name="ln1595"> </a>
<a name="ln1596">  /* shrink tile size in case it would exceed singlebuffer size */</a>
<a name="ln1597">  if((float)width * height * max_bpp * maxbuf &gt; singlebuffer)</a>
<a name="ln1598">  {</a>
<a name="ln1599">    const float scale = singlebuffer / ((float)width * height * max_bpp * maxbuf);</a>
<a name="ln1600"> </a>
<a name="ln1601">    if(width &lt; height &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln1602">    {</a>
<a name="ln1603">      height = floorf(height * scale);</a>
<a name="ln1604">    }</a>
<a name="ln1605">    else if(height &lt;= width &amp;&amp; scale &gt;= 0.333f)</a>
<a name="ln1606">    {</a>
<a name="ln1607">      width = floorf(width * scale);</a>
<a name="ln1608">    }</a>
<a name="ln1609">    else</a>
<a name="ln1610">    {</a>
<a name="ln1611">      width = floorf(width * sqrt(scale));</a>
<a name="ln1612">      height = floorf(height * sqrt(scale));</a>
<a name="ln1613">    }</a>
<a name="ln1614">  }</a>
<a name="ln1615"> </a>
<a name="ln1616">  /* make sure we have a reasonably effective tile dimension. if not try square tiles */</a>
<a name="ln1617">  if(3 * tiling.overlap &gt; width || 3 * tiling.overlap &gt; height)</a>
<a name="ln1618">  {</a>
<a name="ln1619">    width = height = floorf(sqrtf((float)width * height));</a>
<a name="ln1620">  }</a>
<a name="ln1621"> </a>
<a name="ln1622"> </a>
<a name="ln1623">  /* Alignment rules: we need to make sure that alignment requirements of module are fulfilled.</a>
<a name="ln1624">     Modules will report alignment requirements via xalign and yalign within tiling_callback().</a>
<a name="ln1625">     Typical use case is demosaic where Bayer pattern requires alignment to a multiple of 2 in x and y</a>
<a name="ln1626">     direction. Additional alignment requirements are set via definition of CL_ALIGNMENT. */</a>
<a name="ln1627"> </a>
<a name="ln1628">  /* for simplicity reasons we use only one alignment that fits to x and y requirements at the same time */</a>
<a name="ln1629">  unsigned int xyalign = _lcm(tiling.xalign, tiling.yalign);</a>
<a name="ln1630">  xyalign = _lcm(xyalign, CL_ALIGNMENT);</a>
<a name="ln1631"> </a>
<a name="ln1632">  assert(xyalign != 0);</a>
<a name="ln1633"> </a>
<a name="ln1634">  /* make sure that overlap follows alignment rules by making it wider when needed.</a>
<a name="ln1635">     overlap_in needs to be aligned, overlap_out is only here to calculate output buffer size */</a>
<a name="ln1636">  const int overlap_in = _align_up(tiling.overlap, xyalign);</a>
<a name="ln1637">  const int overlap_out = ceilf((float)overlap_in / fullscale);</a>
<a name="ln1638"> </a>
<a name="ln1639">  int tiles_x = 1, tiles_y = 1;</a>
<a name="ln1640"> </a>
<a name="ln1641">  /* calculate number of tiles taking the larger buffer (input or output) as a guiding one.</a>
<a name="ln1642">     normally it is roi_in &gt; roi_out; but let's be prepared */</a>
<a name="ln1643">  if(roi_in-&gt;width &gt; roi_out-&gt;width)</a>
<a name="ln1644">    tiles_x = width &lt; roi_in-&gt;width</a>
<a name="ln1645">                  ? ceilf((float)roi_in-&gt;width / (float)_max(width - 2 * overlap_in - inacc, 1))</a>
<a name="ln1646">                  : 1;</a>
<a name="ln1647">  else</a>
<a name="ln1648">    tiles_x = width &lt; roi_out-&gt;width ? ceilf((float)roi_out-&gt;width / (float)_max(width - 2 * overlap_out, 1))</a>
<a name="ln1649">                                     : 1;</a>
<a name="ln1650"> </a>
<a name="ln1651">  if(roi_in-&gt;height &gt; roi_out-&gt;height)</a>
<a name="ln1652">    tiles_y = height &lt; roi_in-&gt;height</a>
<a name="ln1653">                  ? ceilf((float)roi_in-&gt;height / (float)_max(height - 2 * overlap_in - inacc, 1))</a>
<a name="ln1654">                  : 1;</a>
<a name="ln1655">  else</a>
<a name="ln1656">    tiles_y = height &lt; roi_out-&gt;height</a>
<a name="ln1657">                  ? ceilf((float)roi_out-&gt;height / (float)_max(height - 2 * overlap_out, 1))</a>
<a name="ln1658">                  : 1;</a>
<a name="ln1659"> </a>
<a name="ln1660">  /* sanity check: don't run wild on too many tiles */</a>
<a name="ln1661">  if(tiles_x * tiles_y &gt; dt_conf_get_int(&quot;maximum_number_tiles&quot;))</a>
<a name="ln1662">  {</a>
<a name="ln1663">    dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1664">             &quot;[default_process_tiling_cl_roi] aborted tiling for module '%s'. too many tiles: %d x %d\n&quot;,</a>
<a name="ln1665">             self-&gt;op, tiles_x, tiles_y);</a>
<a name="ln1666">    return FALSE;</a>
<a name="ln1667">  }</a>
<a name="ln1668"> </a>
<a name="ln1669">  /* calculate tile width and height excl. overlap (i.e. the good part) for output.</a>
<a name="ln1670">     important for all following processing steps. */</a>
<a name="ln1671">  const int tile_wd = _align_up(</a>
<a name="ln1672">      roi_out-&gt;width % tiles_x == 0 ? roi_out-&gt;width / tiles_x : roi_out-&gt;width / tiles_x + 1, xyalign);</a>
<a name="ln1673">  const int tile_ht = _align_up(</a>
<a name="ln1674">      roi_out-&gt;height % tiles_y == 0 ? roi_out-&gt;height / tiles_y : roi_out-&gt;height / tiles_y + 1, xyalign);</a>
<a name="ln1675"> </a>
<a name="ln1676"> </a>
<a name="ln1677">  dt_print(</a>
<a name="ln1678">      DT_DEBUG_OPENCL,</a>
<a name="ln1679">      &quot;[default_process_tiling_cl_roi] use tiling on module '%s' for image with full input size %d x %d\n&quot;,</a>
<a name="ln1680">      self-&gt;op, roi_in-&gt;width, roi_in-&gt;height);</a>
<a name="ln1681">  dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1682">           &quot;[default_process_tiling_cl_roi] (%d x %d) tiles with max input dimensions %d x %d\n&quot;, tiles_x,</a>
<a name="ln1683">           tiles_y, width, height);</a>
<a name="ln1684"> </a>
<a name="ln1685"> </a>
<a name="ln1686">  /* store processed_maximum to be re-used and aggregated */</a>
<a name="ln1687">  float processed_maximum_saved[4];</a>
<a name="ln1688">  float processed_maximum_new[4] = { 1.0f };</a>
<a name="ln1689">  for(int k = 0; k &lt; 4; k++) processed_maximum_saved[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln1690"> </a>
<a name="ln1691">  /* reserve pinned input and output memory for host&lt;-&gt;device data transfer */</a>
<a name="ln1692">  if(use_pinned_memory)</a>
<a name="ln1693">  {</a>
<a name="ln1694">    pinned_input = dt_opencl_alloc_device_buffer_with_flags(devid, (size_t)width * height * in_bpp,</a>
<a name="ln1695">                                                            CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR);</a>
<a name="ln1696">    if(pinned_input == NULL)</a>
<a name="ln1697">    {</a>
<a name="ln1698">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1699">               &quot;[default_process_tiling_cl_roi] could not alloc pinned input buffer for module '%s'\n&quot;,</a>
<a name="ln1700">               self-&gt;op);</a>
<a name="ln1701">      use_pinned_memory = 0;</a>
<a name="ln1702">    }</a>
<a name="ln1703">  }</a>
<a name="ln1704"> </a>
<a name="ln1705">  if(use_pinned_memory)</a>
<a name="ln1706">  {</a>
<a name="ln1707"> </a>
<a name="ln1708">    input_buffer = dt_opencl_map_buffer(devid, pinned_input, CL_TRUE, CL_MAP_WRITE, 0,</a>
<a name="ln1709">                                        (size_t)width * height * in_bpp);</a>
<a name="ln1710">    if(input_buffer == NULL)</a>
<a name="ln1711">    {</a>
<a name="ln1712">      dt_print(DT_DEBUG_OPENCL, &quot;[default_process_tiling_cl_roi] could not map pinned input buffer to host &quot;</a>
<a name="ln1713">                                &quot;memory for module '%s'\n&quot;,</a>
<a name="ln1714">               self-&gt;op);</a>
<a name="ln1715">      use_pinned_memory = 0;</a>
<a name="ln1716">    }</a>
<a name="ln1717">  }</a>
<a name="ln1718"> </a>
<a name="ln1719">  if(use_pinned_memory)</a>
<a name="ln1720">  {</a>
<a name="ln1721"> </a>
<a name="ln1722">    pinned_output = dt_opencl_alloc_device_buffer_with_flags(devid, (size_t)width * height * out_bpp,</a>
<a name="ln1723">                                                             CL_MEM_WRITE_ONLY | CL_MEM_ALLOC_HOST_PTR);</a>
<a name="ln1724">    if(pinned_output == NULL)</a>
<a name="ln1725">    {</a>
<a name="ln1726">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1727">               &quot;[default_process_tiling_cl_roi] could not alloc pinned output buffer for module '%s'\n&quot;,</a>
<a name="ln1728">               self-&gt;op);</a>
<a name="ln1729">      use_pinned_memory = 0;</a>
<a name="ln1730">    }</a>
<a name="ln1731">  }</a>
<a name="ln1732"> </a>
<a name="ln1733">  if(use_pinned_memory)</a>
<a name="ln1734">  {</a>
<a name="ln1735"> </a>
<a name="ln1736">    output_buffer = dt_opencl_map_buffer(devid, pinned_output, CL_TRUE, CL_MAP_READ, 0,</a>
<a name="ln1737">                                         (size_t)width * height * out_bpp);</a>
<a name="ln1738">    if(output_buffer == NULL)</a>
<a name="ln1739">    {</a>
<a name="ln1740">      dt_print(DT_DEBUG_OPENCL, &quot;[default_process_tiling_cl_roi] could not map pinned output buffer to host &quot;</a>
<a name="ln1741">                                &quot;memory for module '%s'\n&quot;,</a>
<a name="ln1742">               self-&gt;op);</a>
<a name="ln1743">      use_pinned_memory = 0;</a>
<a name="ln1744">    }</a>
<a name="ln1745">  }</a>
<a name="ln1746"> </a>
<a name="ln1747"> </a>
<a name="ln1748">  /* iterate over tiles */</a>
<a name="ln1749">  for(size_t tx = 0; tx &lt; tiles_x; tx++)</a>
<a name="ln1750">    for(size_t ty = 0; ty &lt; tiles_y; ty++)</a>
<a name="ln1751">    {</a>
<a name="ln1752">      piece-&gt;pipe-&gt;tiling = 1;</a>
<a name="ln1753"> </a>
<a name="ln1754">      /* the output dimensions of the good part of this specific tile */</a>
<a name="ln1755">      size_t wd = (tx + 1) * tile_wd &gt; roi_out-&gt;width ? roi_out-&gt;width - tx * tile_wd : tile_wd;</a>
<a name="ln1756">      size_t ht = (ty + 1) * tile_ht &gt; roi_out-&gt;height ? roi_out-&gt;height - ty * tile_ht : tile_ht;</a>
<a name="ln1757"> </a>
<a name="ln1758">      /* roi_in and roi_out of good part: oroi_good easy to calculate based on number and dimension of tile.</a>
<a name="ln1759">         iroi_good is calculated by modify_roi_in() of respective module */</a>
<a name="ln1760">      dt_iop_roi_t iroi_good = { roi_in-&gt;x + tx * tile_wd, roi_in-&gt;y + ty * tile_ht, wd, ht, roi_in-&gt;scale };</a>
<a name="ln1761">      dt_iop_roi_t oroi_good</a>
<a name="ln1762">          = { roi_out-&gt;x + tx * tile_wd, roi_out-&gt;y + ty * tile_ht, wd, ht, roi_out-&gt;scale };</a>
<a name="ln1763"> </a>
<a name="ln1764">      self-&gt;modify_roi_in(self, piece, &amp;oroi_good, &amp;iroi_good);</a>
<a name="ln1765"> </a>
<a name="ln1766">      /* clamp iroi_good to not exceed roi_in */</a>
<a name="ln1767">      iroi_good.x = _max(iroi_good.x, roi_in-&gt;x);</a>
<a name="ln1768">      iroi_good.y = _max(iroi_good.y, roi_in-&gt;y);</a>
<a name="ln1769">      iroi_good.width = _min(iroi_good.width, roi_in-&gt;width + roi_in-&gt;x - iroi_good.x);</a>
<a name="ln1770">      iroi_good.height = _min(iroi_good.height, roi_in-&gt;height + roi_in-&gt;y - iroi_good.y);</a>
<a name="ln1771"> </a>
<a name="ln1772">      //_print_roi(&amp;iroi_good, &quot;tile iroi_good&quot;);</a>
<a name="ln1773">      //_print_roi(&amp;oroi_good, &quot;tile oroi_good&quot;);</a>
<a name="ln1774"> </a>
<a name="ln1775">      /* now we need to calculate full region of this tile: increase input roi to take care of overlap</a>
<a name="ln1776">         requirements</a>
<a name="ln1777">         and alignment and add additional delta to correct for possible rounding errors in modify_roi_in()</a>
<a name="ln1778">         -&gt; generates first estimate of iroi_full */</a>
<a name="ln1779">      const int x_in = iroi_good.x;</a>
<a name="ln1780">      const int y_in = iroi_good.y;</a>
<a name="ln1781">      const int width_in = iroi_good.width;</a>
<a name="ln1782">      const int height_in = iroi_good.height;</a>
<a name="ln1783">      const int new_x_in = _max(_align_down(x_in - overlap_in - delta, xyalign), roi_in-&gt;x);</a>
<a name="ln1784">      const int new_y_in = _max(_align_down(y_in - overlap_in - delta, xyalign), roi_in-&gt;y);</a>
<a name="ln1785">      const int new_width_in = _min(_align_up(width_in + overlap_in + delta + (x_in - new_x_in), xyalign),</a>
<a name="ln1786">                                    roi_in-&gt;width + roi_in-&gt;x - new_x_in);</a>
<a name="ln1787">      const int new_height_in = _min(_align_up(height_in + overlap_in + delta + (y_in - new_y_in), xyalign),</a>
<a name="ln1788">                                     roi_in-&gt;height + roi_in-&gt;y - new_y_in);</a>
<a name="ln1789"> </a>
<a name="ln1790">      /* iroi_full based on calculated numbers and dimensions. oroi_full just set as a starting point for the</a>
<a name="ln1791">       * following iterative search */</a>
<a name="ln1792">      dt_iop_roi_t iroi_full = { new_x_in, new_y_in, new_width_in, new_height_in, iroi_good.scale };</a>
<a name="ln1793">      dt_iop_roi_t oroi_full = oroi_good; // a good starting point for optimization</a>
<a name="ln1794"> </a>
<a name="ln1795">      //_print_roi(&amp;iroi_full, &quot;tile iroi_full before optimization&quot;);</a>
<a name="ln1796">      //_print_roi(&amp;oroi_full, &quot;tile oroi_full before optimization&quot;);</a>
<a name="ln1797"> </a>
<a name="ln1798">      /* try to find a matching oroi_full */</a>
<a name="ln1799">      if(!_fit_output_to_input_roi(self, piece, &amp;iroi_full, &amp;oroi_full, delta, 10))</a>
<a name="ln1800">      {</a>
<a name="ln1801">        dt_print(DT_DEBUG_OPENCL, &quot;[default_process_tiling_cl_roi] can not handle requested roi's. tiling &quot;</a>
<a name="ln1802">                                  &quot;for module '%s' not possible.\n&quot;,</a>
<a name="ln1803">                 self-&gt;op);</a>
<a name="ln1804">        goto error;</a>
<a name="ln1805">      }</a>
<a name="ln1806"> </a>
<a name="ln1807"> </a>
<a name="ln1808">      /* make sure that oroi_full at least covers the range of oroi_good.</a>
<a name="ln1809">         this step is needed due to the possibility of rounding errors */</a>
<a name="ln1810">      oroi_full.x = _min(oroi_full.x, oroi_good.x);</a>
<a name="ln1811">      oroi_full.y = _min(oroi_full.y, oroi_good.y);</a>
<a name="ln1812">      oroi_full.width = _max(oroi_full.width, oroi_good.x + oroi_good.width - oroi_full.x);</a>
<a name="ln1813">      oroi_full.height = _max(oroi_full.height, oroi_good.y + oroi_good.height - oroi_full.y);</a>
<a name="ln1814"> </a>
<a name="ln1815">      /* clamp oroi_full to not exceed roi_out */</a>
<a name="ln1816">      oroi_full.x = _max(oroi_full.x, roi_out-&gt;x);</a>
<a name="ln1817">      oroi_full.y = _max(oroi_full.y, roi_out-&gt;y);</a>
<a name="ln1818">      oroi_full.width = _min(oroi_full.width, roi_out-&gt;width + roi_out-&gt;x - oroi_full.x);</a>
<a name="ln1819">      oroi_full.height = _min(oroi_full.height, roi_out-&gt;height + roi_out-&gt;y - oroi_full.y);</a>
<a name="ln1820"> </a>
<a name="ln1821"> </a>
<a name="ln1822">      /* calculate final iroi_full */</a>
<a name="ln1823">      self-&gt;modify_roi_in(self, piece, &amp;oroi_full, &amp;iroi_full);</a>
<a name="ln1824"> </a>
<a name="ln1825">      /* clamp iroi_full to not exceed roi_in */</a>
<a name="ln1826">      iroi_full.x = _max(iroi_full.x, roi_in-&gt;x);</a>
<a name="ln1827">      iroi_full.y = _max(iroi_full.y, roi_in-&gt;y);</a>
<a name="ln1828">      iroi_full.width = _min(iroi_full.width, roi_in-&gt;width + roi_in-&gt;x - iroi_full.x);</a>
<a name="ln1829">      iroi_full.height = _min(iroi_full.height, roi_in-&gt;height + roi_in-&gt;y - iroi_full.y);</a>
<a name="ln1830"> </a>
<a name="ln1831">      //_print_roi(&amp;iroi_full, &quot;tile iroi_full&quot;);</a>
<a name="ln1832">      //_print_roi(&amp;oroi_full, &quot;tile oroi_full&quot;);</a>
<a name="ln1833"> </a>
<a name="ln1834">      /* offsets of tile into ivoid and ovoid */</a>
<a name="ln1835">      size_t ioffs = ((size_t)iroi_full.y - roi_in-&gt;y) * ipitch + ((size_t)iroi_full.x - roi_in-&gt;x) * in_bpp;</a>
<a name="ln1836">      size_t ooffs = ((size_t)oroi_good.y - roi_out-&gt;y) * opitch</a>
<a name="ln1837">                     + ((size_t)oroi_good.x - roi_out-&gt;x) * out_bpp;</a>
<a name="ln1838"> </a>
<a name="ln1839">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1840">               &quot;[default_process_tiling_cl_roi] tile (%zu, %zu) with %d x %d at origin [%d, %d]\n&quot;, tx, ty,</a>
<a name="ln1841">               iroi_full.width, iroi_full.height, iroi_full.x, iroi_full.y);</a>
<a name="ln1842"> </a>
<a name="ln1843">      /* origin and region of full input tile */</a>
<a name="ln1844">      size_t iorigin[] = { 0, 0, 0 };</a>
<a name="ln1845">      size_t iregion[] = { iroi_full.width, iroi_full.height, 1 };</a>
<a name="ln1846"> </a>
<a name="ln1847">      /* origin and region of full output tile */</a>
<a name="ln1848">      size_t oforigin[] = { 0, 0, 0 };</a>
<a name="ln1849">      size_t ofregion[] = { oroi_full.width, oroi_full.height, 1 };</a>
<a name="ln1850"> </a>
<a name="ln1851">      /* origin and region of good part of output tile */</a>
<a name="ln1852">      size_t oorigin[] = { oroi_good.x - oroi_full.x, oroi_good.y - oroi_full.y, 0 };</a>
<a name="ln1853">      size_t oregion[] = { oroi_good.width, oroi_good.height, 1 };</a>
<a name="ln1854"> </a>
<a name="ln1855">      /* get opencl input and output buffers */</a>
<a name="ln1856">      input = dt_opencl_alloc_device(devid, iroi_full.width, iroi_full.height, in_bpp);</a>
<a name="ln1857">      if(input == NULL) goto error;</a>
<a name="ln1858"> </a>
<a name="ln1859">      output = dt_opencl_alloc_device(devid, oroi_full.width, oroi_full.height, out_bpp);</a>
<a name="ln1860">      if(output == NULL) goto error;</a>
<a name="ln1861"> </a>
<a name="ln1862">      if(use_pinned_memory)</a>
<a name="ln1863">      {</a>
<a name="ln1864">/* prepare pinned input tile buffer: copy part of input image */</a>
<a name="ln1865">#ifdef _OPENMP</a>
<a name="ln1866">#pragma omp parallel for default(none) shared(input_buffer, width, ioffs, iroi_full) schedule(static)</a>
<a name="ln1867">#endif</a>
<a name="ln1868">        for(size_t j = 0; j &lt; iroi_full.height; j++)</a>
<a name="ln1869">          memcpy((char *)input_buffer + j * iroi_full.width * in_bpp, (char *)ivoid + ioffs + j * ipitch,</a>
<a name="ln1870">                 (size_t)iroi_full.width * in_bpp);</a>
<a name="ln1871"> </a>
<a name="ln1872">        /* blocking memory transfer: pinned host input buffer -&gt; opencl/device tile */</a>
<a name="ln1873">        err = dt_opencl_write_host_to_device_raw(devid, (char *)input_buffer, input, iorigin, iregion,</a>
<a name="ln1874">                                                 (size_t)iroi_full.width * in_bpp, CL_TRUE);</a>
<a name="ln1875">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1876">      }</a>
<a name="ln1877">      else</a>
<a name="ln1878">      {</a>
<a name="ln1879">        /* blocking direct memory transfer: host input image -&gt; opencl/device tile */</a>
<a name="ln1880">        err = dt_opencl_write_host_to_device_raw(devid, (char *)ivoid + ioffs, input, iorigin, iregion,</a>
<a name="ln1881">                                                 ipitch, CL_TRUE);</a>
<a name="ln1882">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1883">      }</a>
<a name="ln1884"> </a>
<a name="ln1885">      /* take original processed_maximum as starting point */</a>
<a name="ln1886">      for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_saved[k];</a>
<a name="ln1887"> </a>
<a name="ln1888">      /* call process_cl of module */</a>
<a name="ln1889">      if(!self-&gt;process_cl(self, piece, input, output, &amp;iroi_full, &amp;oroi_full)) goto error;</a>
<a name="ln1890"> </a>
<a name="ln1891">      /* aggregate resulting processed_maximum */</a>
<a name="ln1892">      /* TODO: check if there really can be differences between tiles and take</a>
<a name="ln1893">               appropriate action (calculate minimum, maximum, average, ...?) */</a>
<a name="ln1894">      for(int k = 0; k &lt; 4; k++)</a>
<a name="ln1895">      {</a>
<a name="ln1896">        if(tx + ty &gt; 0 &amp;&amp; fabs(processed_maximum_new[k] - piece-&gt;pipe-&gt;dsc.processed_maximum[k]) &gt; 1.0e-6f)</a>
<a name="ln1897">          dt_print(</a>
<a name="ln1898">              DT_DEBUG_OPENCL,</a>
<a name="ln1899">              &quot;[default_process_tiling_cl_roi] processed_maximum[%d] differs between tiles in module '%s'\n&quot;,</a>
<a name="ln1900">              k, self-&gt;op);</a>
<a name="ln1901">        processed_maximum_new[k] = piece-&gt;pipe-&gt;dsc.processed_maximum[k];</a>
<a name="ln1902">      }</a>
<a name="ln1903"> </a>
<a name="ln1904">      if(use_pinned_memory)</a>
<a name="ln1905">      {</a>
<a name="ln1906">        /* blocking memory transfer: complete opencl/device tile -&gt; pinned host output buffer */</a>
<a name="ln1907">        err = dt_opencl_read_host_from_device_raw(devid, (char *)output_buffer, output, oforigin, ofregion,</a>
<a name="ln1908">                                                  (size_t)oroi_full.width * out_bpp, CL_TRUE);</a>
<a name="ln1909">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1910"> </a>
<a name="ln1911">/* copy &quot;good&quot; part of tile from pinned output buffer to output image */</a>
<a name="ln1912">#ifdef _OPENMP</a>
<a name="ln1913">#pragma omp parallel for default(none) shared(ooffs, output_buffer, oroi_full, oorigin,                      \</a>
<a name="ln1914">                                              oregion) schedule(static)</a>
<a name="ln1915">#endif</a>
<a name="ln1916">        for(size_t j = 0; j &lt; oregion[1]; j++)</a>
<a name="ln1917">          memcpy((char *)ovoid + ooffs + j * opitch,</a>
<a name="ln1918">                 (char *)output_buffer + ((j + oorigin[1]) * oroi_full.width + oorigin[0]) * out_bpp,</a>
<a name="ln1919">                 (size_t)oregion[0] * out_bpp);</a>
<a name="ln1920">      }</a>
<a name="ln1921">      else</a>
<a name="ln1922">      {</a>
<a name="ln1923">        /* blocking direct memory transfer: good part of opencl/device tile -&gt; host output image */</a>
<a name="ln1924">        err = dt_opencl_read_host_from_device_raw(devid, (char *)ovoid + ooffs, output, oorigin, oregion,</a>
<a name="ln1925">                                                  opitch, CL_TRUE);</a>
<a name="ln1926">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln1927">      }</a>
<a name="ln1928"> </a>
<a name="ln1929">      /* release input and output buffers */</a>
<a name="ln1930">      dt_opencl_release_mem_object(input);</a>
<a name="ln1931">      input = NULL;</a>
<a name="ln1932">      dt_opencl_release_mem_object(output);</a>
<a name="ln1933">      output = NULL;</a>
<a name="ln1934"> </a>
<a name="ln1935">      /* block until opencl queue has finished to free all used event handlers */</a>
<a name="ln1936">      if(!darktable.opencl-&gt;async_pixelpipe || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_EXPORT)</a>
<a name="ln1937">        dt_opencl_finish(devid);</a>
<a name="ln1938">    }</a>
<a name="ln1939"> </a>
<a name="ln1940">  /* copy back final processed_maximum */</a>
<a name="ln1941">  for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_new[k];</a>
<a name="ln1942">  if(input_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_input, input_buffer);</a>
<a name="ln1943">  dt_opencl_release_mem_object(pinned_input);</a>
<a name="ln1944">  if(output_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_output, output_buffer);</a>
<a name="ln1945">  dt_opencl_release_mem_object(pinned_output);</a>
<a name="ln1946">  dt_opencl_release_mem_object(input);</a>
<a name="ln1947">  dt_opencl_release_mem_object(output);</a>
<a name="ln1948">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln1949">  return TRUE;</a>
<a name="ln1950"> </a>
<a name="ln1951">error:</a>
<a name="ln1952">  /* copy back stored processed_maximum */</a>
<a name="ln1953">  for(int k = 0; k &lt; 4; k++) piece-&gt;pipe-&gt;dsc.processed_maximum[k] = processed_maximum_saved[k];</a>
<a name="ln1954">  if(input_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_input, input_buffer);</a>
<a name="ln1955">  dt_opencl_release_mem_object(pinned_input);</a>
<a name="ln1956">  if(output_buffer != NULL) dt_opencl_unmap_mem_object(devid, pinned_output, output_buffer);</a>
<a name="ln1957">  dt_opencl_release_mem_object(pinned_output);</a>
<a name="ln1958">  dt_opencl_release_mem_object(input);</a>
<a name="ln1959">  dt_opencl_release_mem_object(output);</a>
<a name="ln1960">  piece-&gt;pipe-&gt;tiling = 0;</a>
<a name="ln1961">  dt_print(</a>
<a name="ln1962">      DT_DEBUG_OPENCL,</a>
<a name="ln1963">      &quot;[default_process_tiling_opencl_roi] couldn't run process_cl() for module '%s' in tiling mode: %d\n&quot;,</a>
<a name="ln1964">      self-&gt;op, err);</a>
<a name="ln1965">  return FALSE;</a>
<a name="ln1966">}</a>
<a name="ln1967"> </a>
<a name="ln1968"> </a>
<a name="ln1969"> </a>
<a name="ln1970">/* if a module does not implement process_tiling_cl() by itself, this function is called instead.</a>
<a name="ln1971">   _default_process_tiling_cl_ptp() is able to handle standard cases where pixels do not change their places.</a>
<a name="ln1972">   _default_process_tiling_cl_roi() takes care of all other cases where image gets distorted. */</a>
<a name="ln1973">int default_process_tiling_cl(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1974">                              const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln1975">                              const dt_iop_roi_t *const roi_out, const int in_bpp)</a>
<a name="ln1976">{</a>
<a name="ln1977">  if(memcmp(roi_in, roi_out, sizeof(struct dt_iop_roi_t)) || (self-&gt;flags() &amp; IOP_FLAGS_TILING_FULL_ROI))</a>
<a name="ln1978">    return _default_process_tiling_cl_roi(self, piece, ivoid, ovoid, roi_in, roi_out, in_bpp);</a>
<a name="ln1979">  else</a>
<a name="ln1980">    return _default_process_tiling_cl_ptp(self, piece, ivoid, ovoid, roi_in, roi_out, in_bpp);</a>
<a name="ln1981">}</a>
<a name="ln1982"> </a>
<a name="ln1983">#else</a>
<a name="ln1984">int default_process_tiling_cl(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1985">                              const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln1986">                              const dt_iop_roi_t *const roi_out, const int in_bpp)</a>
<a name="ln1987">{</a>
<a name="ln1988">  return FALSE;</a>
<a name="ln1989">}</a>
<a name="ln1990">#endif</a>
<a name="ln1991"> </a>
<a name="ln1992"> </a>
<a name="ln1993">/* If a module does not implement tiling_callback() by itself, this function is called instead.</a>
<a name="ln1994">   Default is an image size factor of 2 (i.e. input + output buffer needed), no overhead (1),</a>
<a name="ln1995">   no overlap between tiles, and an pixel alignment of 1 in x and y direction, i.e. no special</a>
<a name="ln1996">   alignment required. Simple pixel to pixel modules (take tonecurve as an example) can happily</a>
<a name="ln1997">   live with that.</a>
<a name="ln1998">   (1) Small overhead like look-up-tables in tonecurve can be ignored safely. */</a>
<a name="ln1999">void default_tiling_callback(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln2000">                             const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out,</a>
<a name="ln2001">                             struct dt_develop_tiling_t *tiling)</a>
<a name="ln2002">{</a>
<a name="ln2003">  const float ioratio</a>
<a name="ln2004">      = ((float)roi_out-&gt;width * (float)roi_out-&gt;height) / ((float)roi_in-&gt;width * (float)roi_in-&gt;height);</a>
<a name="ln2005"> </a>
<a name="ln2006">  tiling-&gt;factor = 1.0f + ioratio;</a>
<a name="ln2007">  tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln2008">  tiling-&gt;overhead = 0;</a>
<a name="ln2009">  tiling-&gt;overlap = 0;</a>
<a name="ln2010">  tiling-&gt;xalign = 1;</a>
<a name="ln2011">  tiling-&gt;yalign = 1;</a>
<a name="ln2012"> </a>
<a name="ln2013">  if((self-&gt;flags() &amp; IOP_FLAGS_TILING_FULL_ROI) == IOP_FLAGS_TILING_FULL_ROI) tiling-&gt;overlap = 4;</a>
<a name="ln2014"> </a>
<a name="ln2015">  if(self-&gt;iop_order &gt; dt_ioppr_get_iop_order(piece-&gt;pipe-&gt;iop_order_list, &quot;demosaic&quot;)) return;</a>
<a name="ln2016"> </a>
<a name="ln2017">  // all operations that work with mosaiced data should respect pattern size!</a>
<a name="ln2018"> </a>
<a name="ln2019">  if(!piece-&gt;pipe-&gt;dsc.filters) return;</a>
<a name="ln2020"> </a>
<a name="ln2021">  if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln2022">  {</a>
<a name="ln2023">    // X-Trans, sensor is 6x6</a>
<a name="ln2024">    tiling-&gt;xalign = 6;</a>
<a name="ln2025">    tiling-&gt;yalign = 6;</a>
<a name="ln2026">  }</a>
<a name="ln2027">  else</a>
<a name="ln2028">  {</a>
<a name="ln2029">    // Bayer, good old 2x2</a>
<a name="ln2030">    tiling-&gt;xalign = 2;</a>
<a name="ln2031">    tiling-&gt;yalign = 2;</a>
<a name="ln2032">  }</a>
<a name="ln2033"> </a>
<a name="ln2034">  return;</a>
<a name="ln2035">}</a>
<a name="ln2036"> </a>
<a name="ln2037">int dt_tiling_piece_fits_host_memory(const size_t width, const size_t height, const unsigned bpp,</a>
<a name="ln2038">                                     const float factor, const size_t overhead)</a>
<a name="ln2039">{</a>
<a name="ln2040">  static int host_memory_limit = -1;</a>
<a name="ln2041"> </a>
<a name="ln2042">  /* first time run */</a>
<a name="ln2043">  if(host_memory_limit &lt; 0)</a>
<a name="ln2044">  {</a>
<a name="ln2045">    host_memory_limit = dt_conf_get_int(&quot;host_memory_limit&quot;);</a>
<a name="ln2046"> </a>
<a name="ln2047">    /* don't let the user play games with us */</a>
<a name="ln2048">    if(host_memory_limit != 0) host_memory_limit = CLAMPI(host_memory_limit, 500, 50000);</a>
<a name="ln2049">    dt_conf_set_int(&quot;host_memory_limit&quot;, host_memory_limit);</a>
<a name="ln2050">  }</a>
<a name="ln2051"> </a>
<a name="ln2052">  float requirement = factor * width * height * bpp + overhead;</a>
<a name="ln2053"> </a>
<a name="ln2054">  if(host_memory_limit == 0 || requirement &lt;= host_memory_limit * 1024.0f * 1024.0f) return TRUE;</a>
<a name="ln2055"> </a>
<a name="ln2056">  return FALSE;</a>
<a name="ln2057">}</a>
<a name="ln2058"> </a>
<a name="ln2059">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2060">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2061">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="215"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'v'. Check lines: 215, 205.</p></div>
<div class="balloon" rel="251"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'f'. Check lines: 251, 206.</p></div>
<div class="balloon" rel="312"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'vm'. Check lines: 312, 210.</p></div>
<div class="balloon" rel="319"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'vr'. Check lines: 319, 207.</p></div>
<div class="balloon" rel="343"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 've'. Check lines: 343, 208.</p></div>
<div class="balloon" rel="383"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'vc'. Check lines: 383, 209.</p></div>
<div class="balloon" rel="377"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v571/" target="_blank">V571</a> Recurring check. The 'fr >= f[vh]' condition was already verified in line 375.</p></div>
<div class="balloon" rel="801"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v767/" target="_blank">V767</a> Suspicious access to element of 'region' array by a constant index inside a loop.</p></div>
<div class="balloon" rel="808"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'input != NULL' is always true.</p></div>
<div class="balloon" rel="809"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'output != NULL' is always true.</p></div>
<div class="balloon" rel="819"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'output != NULL' is always false.</p></div>
<div class="balloon" rel="1482"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v767/" target="_blank">V767</a> Suspicious access to element of 'region' array by a constant index inside a loop.</p></div>
<div class="balloon" rel="1919"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v767/" target="_blank">V767</a> Suspicious access to element of 'oregion' array by a constant index inside a loop.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
