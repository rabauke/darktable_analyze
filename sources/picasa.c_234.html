
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012 Pierre Lamot</a>
<a name="ln4">    copyright (c) 2013-2014 Jose Carlos Garcia Sogo</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/image.h&quot;</a>
<a name="ln22">#include &quot;common/image_cache.h&quot;</a>
<a name="ln23">#include &quot;common/imageio.h&quot;</a>
<a name="ln24">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln25">#include &quot;common/metadata.h&quot;</a>
<a name="ln26">#include &quot;common/pwstorage/pwstorage.h&quot;</a>
<a name="ln27">#include &quot;common/tags.h&quot;</a>
<a name="ln28">#include &quot;common/curl_tools.h&quot;</a>
<a name="ln29">#include &quot;control/conf.h&quot;</a>
<a name="ln30">#include &quot;control/control.h&quot;</a>
<a name="ln31">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln32">#include &quot;gui/gtk.h&quot;</a>
<a name="ln33">#include &quot;imageio/storage/imageio_storage_api.h&quot;</a>
<a name="ln34">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln35">#include &quot;osx/osx.h&quot;</a>
<a name="ln36">#endif</a>
<a name="ln37">#include &lt;curl/curl.h&gt;</a>
<a name="ln38">#include &lt;json-glib/json-glib.h&gt;</a>
<a name="ln39">#include &lt;libxml/parser.h&gt;</a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;unistd.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">DT_MODULE(2)</a>
<a name="ln45"> </a>
<a name="ln46">#define GOOGLE_WS_BASE_URL &quot;https://accounts.google.com/&quot;</a>
<a name="ln47">#define GOOGLE_API_BASE_URL &quot;https://www.googleapis.com/&quot;</a>
<a name="ln48">#define GOOGLE_API_KEY &quot;428088086479.apps.googleusercontent.com&quot;</a>
<a name="ln49">#define GOOGLE_API_SECRET &quot;tIIL4FUs46Nc9nQWKeg3H_Hy&quot;</a>
<a name="ln50">#define GOOGLE_URI &quot;urn:ietf:wg:oauth:2.0:oob&quot;</a>
<a name="ln51">#define GOOGLE_PICASA &quot;https://picasaweb.google.com/&quot;</a>
<a name="ln52"> </a>
<a name="ln53">#define GOOGLE_IMAGE_MAX_SIZE 960</a>
<a name="ln54"> </a>
<a name="ln55">#define MSGCOLOR_RED &quot;#e07f7f&quot;</a>
<a name="ln56">#define MSGCOLOR_GREEN &quot;#7fe07f&quot;</a>
<a name="ln57"> </a>
<a name="ln58">#define picasa_EXTRA_VERBOSE FALSE</a>
<a name="ln59"> </a>
<a name="ln60">/** Authenticate against google picasa service*/</a>
<a name="ln61">typedef struct _buffer_t</a>
<a name="ln62">{</a>
<a name="ln63">  char *data;</a>
<a name="ln64">  size_t size;</a>
<a name="ln65">  size_t offset;</a>
<a name="ln66">} _buffer_t;</a>
<a name="ln67"> </a>
<a name="ln68">typedef enum ComboUserModel</a>
<a name="ln69">{</a>
<a name="ln70">  COMBO_USER_MODEL_NAME_COL = 0,</a>
<a name="ln71">  COMBO_USER_MODEL_TOKEN_COL,</a>
<a name="ln72">  COMBO_USER_MODEL_REFRESH_TOKEN_COL,</a>
<a name="ln73">  COMBO_USER_MODEL_ID_COL,</a>
<a name="ln74">  COMBO_USER_MODEL_NB_COL</a>
<a name="ln75">} ComboUserModel;</a>
<a name="ln76"> </a>
<a name="ln77">typedef enum ComboAlbumModel</a>
<a name="ln78">{</a>
<a name="ln79">  COMBO_ALBUM_MODEL_NAME_COL = 0,</a>
<a name="ln80">  COMBO_ALBUM_MODEL_ID_COL,</a>
<a name="ln81">  COMBO_ALBUM_MODEL_NB_COL</a>
<a name="ln82">} ComboAlbumModel;</a>
<a name="ln83"> </a>
<a name="ln84">typedef enum PicasaAlbumPrivacyPolicy</a>
<a name="ln85">{</a>
<a name="ln86">  PICASA_ALBUM_PRIVACY_PUBLIC,</a>
<a name="ln87">  PICASA_ALBUM_PRIVACY_PRIVATE,</a>
<a name="ln88">} PicasaAlbumPrivacyPolicy;</a>
<a name="ln89"> </a>
<a name="ln90">/**</a>
<a name="ln91"> * Represents information about an album</a>
<a name="ln92"> */</a>
<a name="ln93">typedef struct PicasaAlbum</a>
<a name="ln94">{</a>
<a name="ln95">  gchar *id;</a>
<a name="ln96">  gchar *name;</a>
<a name="ln97">  PicasaAlbumPrivacyPolicy privacy;</a>
<a name="ln98">} PicasaAlbum;</a>
<a name="ln99"> </a>
<a name="ln100">static PicasaAlbum *picasa_album_init()</a>
<a name="ln101">{</a>
<a name="ln102">  return (PicasaAlbum *)g_malloc0(sizeof(PicasaAlbum));</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">static void picasa_album_destroy(PicasaAlbum *album)</a>
<a name="ln106">{</a>
<a name="ln107">  if(album == NULL) return;</a>
<a name="ln108">  g_free(album-&gt;id);</a>
<a name="ln109">  g_free(album-&gt;name);</a>
<a name="ln110">  g_free(album);</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">/**</a>
<a name="ln114"> * Represents information about an account</a>
<a name="ln115"> */</a>
<a name="ln116">typedef struct PicasaAccountInfo</a>
<a name="ln117">{</a>
<a name="ln118">  gchar *id;</a>
<a name="ln119">  gchar *username;</a>
<a name="ln120">  gchar *token;</a>
<a name="ln121">  gchar *refresh_token;</a>
<a name="ln122">} PicasaAccountInfo;</a>
<a name="ln123"> </a>
<a name="ln124">static PicasaAccountInfo *picasa_account_info_init()</a>
<a name="ln125">{</a>
<a name="ln126">  return (PicasaAccountInfo *)g_malloc0(sizeof(PicasaAccountInfo));</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">static void picasa_account_info_destroy(PicasaAccountInfo *account)</a>
<a name="ln130">{</a>
<a name="ln131">  if(account == NULL) return;</a>
<a name="ln132">  g_free(account-&gt;id);</a>
<a name="ln133">  g_free(account-&gt;username);</a>
<a name="ln134">  g_free(account);</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">typedef struct PicasaContext</a>
<a name="ln138">{</a>
<a name="ln139">  gchar album_id[1024];</a>
<a name="ln140">  gchar userid[1024];</a>
<a name="ln141"> </a>
<a name="ln142">  int album_permission;</a>
<a name="ln143"> </a>
<a name="ln144">  /// curl context</a>
<a name="ln145">  CURL *curl_ctx;</a>
<a name="ln146">  /// Json parser context</a>
<a name="ln147">  JsonParser *json_parser;</a>
<a name="ln148"> </a>
<a name="ln149">  GString *errmsg;</a>
<a name="ln150"> </a>
<a name="ln151">  /// authorization token</a>
<a name="ln152">  gchar *token;</a>
<a name="ln153">  gchar *refresh_token;</a>
<a name="ln154">} PicasaContext;</a>
<a name="ln155"> </a>
<a name="ln156">typedef struct dt_storage_picasa_gui_data_t</a>
<a name="ln157">{</a>
<a name="ln158">  // == ui elements ==</a>
<a name="ln159">  GtkLabel *label_status;</a>
<a name="ln160"> </a>
<a name="ln161">  GtkComboBox *comboBox_username;</a>
<a name="ln162">  GtkButton *button_login;</a>
<a name="ln163"> </a>
<a name="ln164">  GtkDarktableButton *dtbutton_refresh_album;</a>
<a name="ln165">  GtkComboBox *comboBox_album;</a>
<a name="ln166"> </a>
<a name="ln167">  // == context ==</a>
<a name="ln168">  gboolean connected;</a>
<a name="ln169">  PicasaContext *picasa_api;</a>
<a name="ln170">} dt_storage_picasa_gui_data_t;</a>
<a name="ln171"> </a>
<a name="ln172"> </a>
<a name="ln173">static PicasaContext *picasa_api_init()</a>
<a name="ln174">{</a>
<a name="ln175">  PicasaContext *ctx = (PicasaContext *)g_malloc0(sizeof(PicasaContext));</a>
<a name="ln176">  ctx-&gt;curl_ctx = curl_easy_init();</a>
<a name="ln177">  ctx-&gt;errmsg = g_string_new(&quot;&quot;);</a>
<a name="ln178">  ctx-&gt;json_parser = json_parser_new();</a>
<a name="ln179">  return ctx;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">static void picasa_api_destroy(PicasaContext *ctx)</a>
<a name="ln183">{</a>
<a name="ln184">  if(ctx == NULL) return;</a>
<a name="ln185">  curl_easy_cleanup(ctx-&gt;curl_ctx);</a>
<a name="ln186">  g_free(ctx-&gt;token);</a>
<a name="ln187">  g_free(ctx-&gt;refresh_token);</a>
<a name="ln188">  g_object_unref(ctx-&gt;json_parser);</a>
<a name="ln189">  g_string_free(ctx-&gt;errmsg, TRUE);</a>
<a name="ln190">  g_free(ctx);</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193"> </a>
<a name="ln194">typedef struct dt_storage_picasa_param_t</a>
<a name="ln195">{</a>
<a name="ln196">  gint64 hash;</a>
<a name="ln197">  PicasaContext *picasa_ctx;</a>
<a name="ln198">} dt_storage_picasa_param_t;</a>
<a name="ln199"> </a>
<a name="ln200"> </a>
<a name="ln201">static gchar *picasa_get_user_refresh_token(PicasaContext *ctx);</a>
<a name="ln202"> </a>
<a name="ln203">//////////////////////////// curl requests related functions</a>
<a name="ln204"> </a>
<a name="ln205">/** Grow and fill _buffer_t with received data... */</a>
<a name="ln206">static size_t _picasa_api_buffer_write_func(void *ptr, size_t size, size_t nmemb, void *stream)</a>
<a name="ln207">{</a>
<a name="ln208">  _buffer_t *buffer = (_buffer_t *)stream;</a>
<a name="ln209">  char *newdata = g_malloc0(buffer-&gt;size + nmemb + 1);</a>
<a name="ln210">  if(buffer-&gt;data != NULL) memcpy(newdata, buffer-&gt;data, buffer-&gt;size);</a>
<a name="ln211">  memcpy(newdata + buffer-&gt;size, ptr, nmemb);</a>
<a name="ln212">  g_free(buffer-&gt;data);</a>
<a name="ln213">  buffer-&gt;data = newdata;</a>
<a name="ln214">  buffer-&gt;size += nmemb;</a>
<a name="ln215">  return nmemb;</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">static size_t _picasa_api_buffer_read_func(void *ptr, size_t size, size_t nmemb, void *stream)</a>
<a name="ln219">{</a>
<a name="ln220">  _buffer_t *buffer = (_buffer_t *)stream;</a>
<a name="ln221">  size_t dsize = 0;</a>
<a name="ln222">  if((buffer-&gt;size - buffer-&gt;offset) &gt; nmemb)</a>
<a name="ln223">    dsize = nmemb;</a>
<a name="ln224">  else</a>
<a name="ln225">    dsize = (buffer-&gt;size - buffer-&gt;offset);</a>
<a name="ln226"> </a>
<a name="ln227">  memcpy(ptr, buffer-&gt;data + buffer-&gt;offset, dsize);</a>
<a name="ln228">  buffer-&gt;offset += dsize;</a>
<a name="ln229">  return dsize;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">static size_t curl_write_data_cb(void *ptr, size_t size, size_t nmemb, void *data)</a>
<a name="ln233">{</a>
<a name="ln234">  GString *string = (GString *)data;</a>
<a name="ln235">  g_string_append_len(string, ptr, size * nmemb);</a>
<a name="ln236">#if picasa_EXTRA_VERBOSE == TRUE</a>
<a name="ln237">  g_printf(&quot;server reply: %s\n&quot;, string-&gt;str);</a>
<a name="ln238">#endif</a>
<a name="ln239">  return size * nmemb;</a>
<a name="ln240">}</a>
<a name="ln241"> </a>
<a name="ln242">static JsonObject *picasa_parse_response(PicasaContext *ctx, GString *response)</a>
<a name="ln243">{</a>
<a name="ln244">  GError *error = NULL;</a>
<a name="ln245">  gboolean ret = json_parser_load_from_data(ctx-&gt;json_parser, response-&gt;str, response-&gt;len, &amp;error);</a>
<a name="ln246">  g_return_val_if_fail((ret), NULL);</a>
<a name="ln247"> </a>
<a name="ln248">  JsonNode *root = json_parser_get_root(ctx-&gt;json_parser);</a>
<a name="ln249">  // we should always have a dict</a>
<a name="ln250">  g_return_val_if_fail((json_node_get_node_type(root) == JSON_NODE_OBJECT), NULL);</a>
<a name="ln251"> </a>
<a name="ln252">  JsonObject *rootdict = json_node_get_object(root);</a>
<a name="ln253">  if(json_object_has_member(rootdict, &quot;error&quot;))</a>
<a name="ln254">  {</a>
<a name="ln255">    JsonObject *errorstruct = json_object_get_object_member(rootdict, &quot;error&quot;);</a>
<a name="ln256">    g_return_val_if_fail((errorstruct != NULL), NULL);</a>
<a name="ln257">    const gchar *errormessage = json_object_get_string_member(errorstruct, &quot;message&quot;);</a>
<a name="ln258">    g_return_val_if_fail((errormessage != NULL), NULL);</a>
<a name="ln259">    g_string_assign(ctx-&gt;errmsg, errormessage);</a>
<a name="ln260">    return NULL;</a>
<a name="ln261">  }</a>
<a name="ln262"> </a>
<a name="ln263">  return rootdict;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266"> </a>
<a name="ln267">static void picasa_query_get_add_url_arguments(GString *key, GString *value, GString *url)</a>
<a name="ln268">{</a>
<a name="ln269">  g_string_append(url, &quot;&amp;&quot;);</a>
<a name="ln270">  g_string_append(url, key-&gt;str);</a>
<a name="ln271">  g_string_append(url, &quot;=&quot;);</a>
<a name="ln272">  g_string_append(url, value-&gt;str);</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">/**</a>
<a name="ln276"> * perform a GET request on picasa/google api</a>
<a name="ln277"> *</a>
<a name="ln278"> * @note use this one to read information (user info, existing albums, ...)</a>
<a name="ln279"> *</a>
<a name="ln280"> * @param ctx picasa context (token field must be set)</a>
<a name="ln281"> * @param method the method to call on the google API, the methods should not start with '/' example:</a>
<a name="ln282"> *&quot;me/albums&quot;</a>
<a name="ln283"> * @param args hashtable of the arguments to be added to the requests, must be in the form key (string) =</a>
<a name="ln284"> *value (string)</a>
<a name="ln285"> * @returns NULL if the request fails, or a JsonObject of the reply</a>
<a name="ln286"> */</a>
<a name="ln287">static JsonObject *picasa_query_get(PicasaContext *ctx, const gchar *method, GHashTable *args, gboolean picasa)</a>
<a name="ln288">{</a>
<a name="ln289">  g_return_val_if_fail(ctx != NULL, NULL);</a>
<a name="ln290">  g_return_val_if_fail(ctx-&gt;token != NULL, NULL);</a>
<a name="ln291">  // build the query</a>
<a name="ln292">  GString *url;</a>
<a name="ln293">  if(picasa == TRUE)</a>
<a name="ln294">    url = g_string_new(GOOGLE_PICASA);</a>
<a name="ln295">  else</a>
<a name="ln296">    url = g_string_new(GOOGLE_API_BASE_URL);</a>
<a name="ln297"> </a>
<a name="ln298">  g_string_append(url, method);</a>
<a name="ln299"> </a>
<a name="ln300">  if(picasa == TRUE)</a>
<a name="ln301">  {</a>
<a name="ln302">    g_string_append(url, &quot;?alt=json&amp;access_token=&quot;);</a>
<a name="ln303">    g_string_append(url, ctx-&gt;token);</a>
<a name="ln304">  }</a>
<a name="ln305">  else</a>
<a name="ln306">  {</a>
<a name="ln307">    g_string_append(url, &quot;?alt=json&amp;access_token=&quot;);</a>
<a name="ln308">    g_string_append(url, ctx-&gt;token);</a>
<a name="ln309">  }</a>
<a name="ln310">  if(args != NULL) g_hash_table_foreach(args, (GHFunc)picasa_query_get_add_url_arguments, url);</a>
<a name="ln311"> </a>
<a name="ln312">  // send the request</a>
<a name="ln313">  GString *response = g_string_new(&quot;&quot;);</a>
<a name="ln314"> </a>
<a name="ln315">  dt_curl_init(ctx-&gt;curl_ctx, picasa_EXTRA_VERBOSE);</a>
<a name="ln316"> </a>
<a name="ln317">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_URL, url-&gt;str);</a>
<a name="ln318">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEFUNCTION, curl_write_data_cb);</a>
<a name="ln319">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEDATA, response);</a>
<a name="ln320">  int res = curl_easy_perform(ctx-&gt;curl_ctx);</a>
<a name="ln321"> </a>
<a name="ln322">  if(res != CURLE_OK)</a>
<a name="ln323">  {</a>
<a name="ln324">    g_string_free(url, TRUE);</a>
<a name="ln325">    g_string_free(response, TRUE);</a>
<a name="ln326">    return NULL;</a>
<a name="ln327">  }</a>
<a name="ln328">  // parse the response</a>
<a name="ln329">  JsonObject *respobj = picasa_parse_response(ctx, response);</a>
<a name="ln330"> </a>
<a name="ln331">  g_string_free(response, TRUE);</a>
<a name="ln332">  g_string_free(url, TRUE);</a>
<a name="ln333">  return respobj;</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">typedef struct</a>
<a name="ln337">{</a>
<a name="ln338">  struct curl_httppost *formpost;</a>
<a name="ln339">  struct curl_httppost *lastptr;</a>
<a name="ln340">} HttppostFormList;</a>
<a name="ln341"> </a>
<a name="ln342"> </a>
<a name="ln343">/**</a>
<a name="ln344"> * perform a POST request on google api to get the auth token</a>
<a name="ln345"> *</a>
<a name="ln346"> * @param ctx picasa context (token field must be set)</a>
<a name="ln347"> * @param method the method to call on the google API, the methods should not start with '/' example:</a>
<a name="ln348"> *&quot;me/albums&quot;</a>
<a name="ln349"> * @param args hashtable of the arguments to be added to the requests, might be null if none</a>
<a name="ln350"> * @returns NULL if the request fails, or a JsonObject of the reply</a>
<a name="ln351"> */</a>
<a name="ln352"> </a>
<a name="ln353">static JsonObject *picasa_query_post_auth(PicasaContext *ctx, const gchar *method, gchar *args)</a>
<a name="ln354">{</a>
<a name="ln355">  g_return_val_if_fail(ctx != NULL, NULL);</a>
<a name="ln356"> </a>
<a name="ln357">  GString *url = NULL;</a>
<a name="ln358"> </a>
<a name="ln359">  url = g_string_new(GOOGLE_WS_BASE_URL);</a>
<a name="ln360">  g_string_append(url, method);</a>
<a name="ln361"> </a>
<a name="ln362">  // send the requests</a>
<a name="ln363">  GString *response = g_string_new(&quot;&quot;);</a>
<a name="ln364"> </a>
<a name="ln365">  dt_curl_init(ctx-&gt;curl_ctx, picasa_EXTRA_VERBOSE);</a>
<a name="ln366"> </a>
<a name="ln367">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_URL, url-&gt;str);</a>
<a name="ln368">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_POST, 1);</a>
<a name="ln369">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_COPYPOSTFIELDS, args);</a>
<a name="ln370">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEFUNCTION, curl_write_data_cb);</a>
<a name="ln371">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEDATA, response);</a>
<a name="ln372"> </a>
<a name="ln373">  int res = curl_easy_perform(ctx-&gt;curl_ctx);</a>
<a name="ln374">  g_string_free(url, TRUE);</a>
<a name="ln375">  if(res != CURLE_OK) return NULL;</a>
<a name="ln376">  // parse the response</a>
<a name="ln377">  JsonObject *respobj = picasa_parse_response(ctx, response);</a>
<a name="ln378">  g_string_free(response, TRUE);</a>
<a name="ln379">  return respobj;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">//////////////////////////// picasa api functions</a>
<a name="ln383"> </a>
<a name="ln384">/**</a>
<a name="ln385"> * @returns TRUE if the current token is valid</a>
<a name="ln386"> */</a>
<a name="ln387">static gboolean picasa_test_auth_token(PicasaContext *ctx)</a>
<a name="ln388">{</a>
<a name="ln389">  gchar *access_token = NULL;</a>
<a name="ln390">  access_token = picasa_get_user_refresh_token(ctx);</a>
<a name="ln391"> </a>
<a name="ln392">  if(access_token != NULL) ctx-&gt;token = access_token;</a>
<a name="ln393"> </a>
<a name="ln394">  return access_token != NULL;</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">/**</a>
<a name="ln398"> * @return a GList of PicasaAlbums associated to the user</a>
<a name="ln399"> */</a>
<a name="ln400">static GList *picasa_get_album_list(PicasaContext *ctx, gboolean *ok)</a>
<a name="ln401">{</a>
<a name="ln402">  if(!ok) return NULL;</a>
<a name="ln403"> </a>
<a name="ln404">  *ok = TRUE;</a>
<a name="ln405">  GList *album_list = NULL;</a>
<a name="ln406"> </a>
<a name="ln407">  JsonObject *reply = picasa_query_get(ctx, &quot;data/feed/api/user/default&quot;, NULL, TRUE);</a>
<a name="ln408">  if(reply == NULL) goto error;</a>
<a name="ln409"> </a>
<a name="ln410">  JsonObject *feed = json_object_get_object_member(reply, &quot;feed&quot;);</a>
<a name="ln411">  if(feed == NULL) goto error;</a>
<a name="ln412"> </a>
<a name="ln413">  JsonArray *jsalbums = json_object_get_array_member(feed, &quot;entry&quot;);</a>
<a name="ln414"> </a>
<a name="ln415">  guint i;</a>
<a name="ln416">  for(i = 0; i &lt; json_array_get_length(jsalbums); i++)</a>
<a name="ln417">  {</a>
<a name="ln418">    JsonObject *obj = json_array_get_object_element(jsalbums, i);</a>
<a name="ln419">    if(obj == NULL) continue;</a>
<a name="ln420"> </a>
<a name="ln421">    PicasaAlbum *album = picasa_album_init();</a>
<a name="ln422">    if(album == NULL) goto error;</a>
<a name="ln423"> </a>
<a name="ln424">    JsonObject *jsid = json_object_get_object_member(obj, &quot;gphoto$id&quot;);</a>
<a name="ln425">    JsonObject *jstitle = json_object_get_object_member(obj, &quot;title&quot;);</a>
<a name="ln426"> </a>
<a name="ln427">    const char *id = json_object_get_string_member(jsid, &quot;$t&quot;);</a>
<a name="ln428">    const char *name = json_object_get_string_member(jstitle, &quot;$t&quot;);</a>
<a name="ln429">    if(id == NULL || name == NULL)</a>
<a name="ln430">    {</a>
<a name="ln431">      picasa_album_destroy(album);</a>
<a name="ln432">      goto error;</a>
<a name="ln433">    }</a>
<a name="ln434">    album-&gt;id = g_strdup(id);</a>
<a name="ln435">    album-&gt;name = g_strdup(name);</a>
<a name="ln436">    album_list = g_list_append(album_list, album);</a>
<a name="ln437">  }</a>
<a name="ln438">  return album_list;</a>
<a name="ln439"> </a>
<a name="ln440">error:</a>
<a name="ln441">  *ok = FALSE;</a>
<a name="ln442">  g_list_free_full(album_list, (GDestroyNotify)picasa_album_destroy);</a>
<a name="ln443">  return NULL;</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446">/**</a>
<a name="ln447"> * @see https://developers.google.com/picasa-web/docs/2.0/developers_guide_protocol#PostPhotos</a>
<a name="ln448"> * @return the id of the uploaded photo</a>
<a name="ln449"> */</a>
<a name="ln450">static const gchar *picasa_upload_photo_to_album(PicasaContext *ctx, gchar *albumid, gchar *fname,</a>
<a name="ln451">                                                 gchar *title, gchar *summary, const int imgid)</a>
<a name="ln452">{</a>
<a name="ln453">  _buffer_t buffer = { 0 };</a>
<a name="ln454">  gchar *photo_id = NULL;</a>
<a name="ln455"> </a>
<a name="ln456">  char uri[4096] = { 0 };</a>
<a name="ln457"> </a>
<a name="ln458">  // Open the temp file and read image to memory</a>
<a name="ln459">  GMappedFile *imgfile = g_mapped_file_new(fname, FALSE, NULL);</a>
<a name="ln460">  const int size = g_mapped_file_get_length(imgfile);</a>
<a name="ln461">  gchar *data = g_mapped_file_get_contents(imgfile);</a>
<a name="ln462"> </a>
<a name="ln463">  gchar *entry = g_markup_printf_escaped(&quot;&lt;entry xmlns='http://www.w3.org/2005/Atom'&gt;\n&quot;</a>
<a name="ln464">                                         &quot;&lt;title&gt;%s&lt;/title&gt;\n&quot;</a>
<a name="ln465">                                         &quot;&lt;summary&gt;%s&lt;/summary&gt;\n&quot;</a>
<a name="ln466">                                         &quot;&lt;category scheme=\&quot;http://schemas.google.com/g/2005#kind\&quot;\n&quot;</a>
<a name="ln467">                                         &quot; term=\&quot;http://schemas.google.com/photos/2007#photo\&quot;/&gt;&quot;</a>
<a name="ln468">                                         &quot;&lt;/entry&gt;&quot;,</a>
<a name="ln469">                                         title, summary);</a>
<a name="ln470"> </a>
<a name="ln471">  gchar *authHeader = NULL;</a>
<a name="ln472">  authHeader = dt_util_dstrcat(authHeader, &quot;Authorization: OAuth %s&quot;, ctx-&gt;token);</a>
<a name="ln473"> </a>
<a name="ln474">  // Hack for nonform multipart post...</a>
<a name="ln475">  gchar mpart1[4096] = { 0 };</a>
<a name="ln476">  gchar *mpart_format = &quot;\nMedia multipart posting\n--END_OF_PART\nContent-Type: &quot;</a>
<a name="ln477">                        &quot;application/atom+xml\n\n%s\n--END_OF_PART\nContent-Type: image/jpeg\n\n&quot;;</a>
<a name="ln478">  snprintf(mpart1, sizeof(mpart1), mpart_format, entry);</a>
<a name="ln479">  g_free(entry);</a>
<a name="ln480"> </a>
<a name="ln481">  const int mpart1size = strlen(mpart1);</a>
<a name="ln482">  const int postdata_length = mpart1size + size + strlen(&quot;\n--END_OF_PART--&quot;);</a>
<a name="ln483">  gchar *postdata = g_malloc(postdata_length);</a>
<a name="ln484">  memcpy(postdata, mpart1, mpart1size);</a>
<a name="ln485">  memcpy(postdata + mpart1size, data, size);</a>
<a name="ln486">  memcpy(postdata + mpart1size + size, &quot;\n--END_OF_PART--&quot;, strlen(&quot;\n--END_OF_PART--&quot;));</a>
<a name="ln487"> </a>
<a name="ln488">  g_mapped_file_unref(imgfile);</a>
<a name="ln489"> </a>
<a name="ln490">  struct curl_slist *headers = NULL;</a>
<a name="ln491">  headers = curl_slist_append(headers, &quot;Content-Type: multipart/related; boundary=\&quot;END_OF_PART\&quot;&quot;);</a>
<a name="ln492">  headers = curl_slist_append(headers, &quot;MIME-version: 1.0&quot;);</a>
<a name="ln493">  headers = curl_slist_append(headers, &quot;GData-Version: 3&quot;);</a>
<a name="ln494">  headers = curl_slist_append(headers, authHeader);</a>
<a name="ln495"> </a>
<a name="ln496">  dt_curl_init(ctx-&gt;curl_ctx, picasa_EXTRA_VERBOSE);</a>
<a name="ln497"> </a>
<a name="ln498">  snprintf(uri, sizeof(uri), &quot;https://picasaweb.google.com/data/feed/api/user/default/albumid/%s&quot;, albumid);</a>
<a name="ln499">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_URL, uri);</a>
<a name="ln500">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_HTTPHEADER, headers);</a>
<a name="ln501">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_UPLOAD, 0); // A post request !</a>
<a name="ln502">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_POST, 1);</a>
<a name="ln503">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_FOLLOWLOCATION, 1);</a>
<a name="ln504">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_POSTFIELDS, postdata);</a>
<a name="ln505">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_POSTFIELDSIZE, postdata_length);</a>
<a name="ln506">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEFUNCTION, _picasa_api_buffer_write_func);</a>
<a name="ln507">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEDATA, &amp;buffer);</a>
<a name="ln508"> </a>
<a name="ln509">  int res = curl_easy_perform(ctx-&gt;curl_ctx);</a>
<a name="ln510"> </a>
<a name="ln511">  curl_slist_free_all(headers);</a>
<a name="ln512"> </a>
<a name="ln513">  if(res != CURLE_OK)</a>
<a name="ln514">  {</a>
<a name="ln515">    fprintf(stderr, &quot;[picasa] error uploading photo: %s\n&quot;, curl_easy_strerror(res));</a>
<a name="ln516">    return NULL;</a>
<a name="ln517">  }</a>
<a name="ln518"> </a>
<a name="ln519">#if picasa_EXTRA_VERBOSE == TRUE</a>
<a name="ln520">  printf(&quot;Uploading: %s\n&quot;, buffer.data);</a>
<a name="ln521">#endif</a>
<a name="ln522"> </a>
<a name="ln523">  long result;</a>
<a name="ln524">  curl_easy_getinfo(ctx-&gt;curl_ctx, CURLINFO_RESPONSE_CODE, &amp;result);</a>
<a name="ln525"> </a>
<a name="ln526">  // If we want to add tags let's do...</a>
<a name="ln527">  if(result == 201 &amp;&amp; imgid &gt; 0)</a>
<a name="ln528">  {</a>
<a name="ln529">    // Image was created , fine.. and result have the fully created photo xml entry..</a>
<a name="ln530">    // Let's perform an update of the photos keywords with tags passed along to this function..</a>
<a name="ln531">    // and use picasa photo update api to add keywords to the photo...</a>
<a name="ln532"> </a>
<a name="ln533">    // Build the keywords content string</a>
<a name="ln534">    GList *keywords_list = dt_tag_get_list(imgid);</a>
<a name="ln535">    gchar *keywords = dt_util_glist_to_str(&quot;,&quot;, keywords_list);</a>
<a name="ln536"> </a>
<a name="ln537">    xmlDocPtr doc;</a>
<a name="ln538">    xmlNodePtr entryNode;</a>
<a name="ln539">    // Parse xml document</a>
<a name="ln540">    if((doc = xmlParseDoc((xmlChar *)buffer.data)) == NULL) return 0;</a>
<a name="ln541">    entryNode = xmlDocGetRootElement(doc);</a>
<a name="ln542">    if(!xmlStrcmp(entryNode-&gt;name, (const xmlChar *)&quot;entry&quot;))</a>
<a name="ln543">    {</a>
<a name="ln544">      // Let's get the gd:etag attribute of entry...</a>
<a name="ln545">      // For now, we force update using &quot;If-Match: *&quot;</a>
<a name="ln546">      /*</a>
<a name="ln547">        if( !xmlHasProp(entryNode, (const xmlChar*)&quot;gd:etag&quot;) ) return 0;</a>
<a name="ln548">        xmlChar *etag = xmlGetProp(entryNode,(const xmlChar*)&quot;gd:etag&quot;);</a>
<a name="ln549">      */</a>
<a name="ln550"> </a>
<a name="ln551">      gchar *updateUri = NULL;</a>
<a name="ln552">      xmlNodePtr entryChilds = entryNode-&gt;xmlChildrenNode;</a>
<a name="ln553">      if(entryChilds != NULL)</a>
<a name="ln554">      {</a>
<a name="ln555">        do</a>
<a name="ln556">        {</a>
<a name="ln557">          if((!xmlStrcmp(entryChilds-&gt;name, (const xmlChar *)&quot;id&quot;)))</a>
<a name="ln558">          {</a>
<a name="ln559">            // Get the photo id used in uri for update</a>
<a name="ln560">            xmlChar *id = xmlNodeListGetString(doc, entryChilds-&gt;xmlChildrenNode, 1);</a>
<a name="ln561">            if(xmlStrncmp(id, (const xmlChar *)&quot;http://&quot;, 7)) photo_id = g_strdup((const char *)id);</a>
<a name="ln562">            xmlFree(id);</a>
<a name="ln563">          }</a>
<a name="ln564">          else if((!xmlStrcmp(entryChilds-&gt;name, (const xmlChar *)&quot;group&quot;)))</a>
<a name="ln565">          {</a>
<a name="ln566">            // Got the media:group entry lets find the child media:keywords</a>
<a name="ln567">            xmlNodePtr mediaChilds = entryChilds-&gt;xmlChildrenNode;</a>
<a name="ln568">            if(mediaChilds != NULL)</a>
<a name="ln569">            {</a>
<a name="ln570">              do</a>
<a name="ln571">              {</a>
<a name="ln572">                // Got the keywords tag, let's set the tags</a>
<a name="ln573">                if((!xmlStrcmp(mediaChilds-&gt;name, (const xmlChar *)&quot;keywords&quot;)))</a>
<a name="ln574">                  xmlNodeSetContent(mediaChilds, (xmlChar *)keywords);</a>
<a name="ln575">              } while((mediaChilds = mediaChilds-&gt;next) != NULL);</a>
<a name="ln576">            }</a>
<a name="ln577">          }</a>
<a name="ln578">          else if((!xmlStrcmp(entryChilds-&gt;name, (const xmlChar *)&quot;link&quot;)))</a>
<a name="ln579">          {</a>
<a name="ln580">            xmlChar *rel = xmlGetProp(entryChilds, (const xmlChar *)&quot;rel&quot;);</a>
<a name="ln581">            if(!xmlStrcmp(rel, (const xmlChar *)&quot;edit&quot;))</a>
<a name="ln582">            {</a>
<a name="ln583">              updateUri = (char *)xmlGetProp(entryChilds, (const xmlChar *)&quot;href&quot;);</a>
<a name="ln584">            }</a>
<a name="ln585">            xmlFree(rel);</a>
<a name="ln586">          }</a>
<a name="ln587">        } while((entryChilds = entryChilds-&gt;next) != NULL);</a>
<a name="ln588">      }</a>
<a name="ln589"> </a>
<a name="ln590">      // Let's update the photo</a>
<a name="ln591">      headers = NULL;</a>
<a name="ln592">      headers = curl_slist_append(headers, &quot;Content-Type: application/atom+xml&quot;);</a>
<a name="ln593">      headers = curl_slist_append(headers, &quot;If-Match: *&quot;);</a>
<a name="ln594">      headers = curl_slist_append(headers, &quot;GData-Version: 3&quot;);</a>
<a name="ln595">      headers = curl_slist_append(headers, authHeader);</a>
<a name="ln596"> </a>
<a name="ln597">      _buffer_t response = { 0 };</a>
<a name="ln598"> </a>
<a name="ln599">      // Setup data to send..</a>
<a name="ln600">      _buffer_t writebuffer;</a>
<a name="ln601">      int datasize;</a>
<a name="ln602">      xmlDocDumpMemory(doc, (xmlChar **)&amp;writebuffer.data, &amp;datasize);</a>
<a name="ln603">      writebuffer.size = datasize;</a>
<a name="ln604">      writebuffer.offset = 0;</a>
<a name="ln605"> </a>
<a name="ln606">      dt_curl_init(ctx-&gt;curl_ctx, picasa_EXTRA_VERBOSE);</a>
<a name="ln607"> </a>
<a name="ln608">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_URL, updateUri);</a>
<a name="ln609">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_HTTPHEADER, headers);</a>
<a name="ln610">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_UPLOAD, 1); // A put request</a>
<a name="ln611">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_READDATA, &amp;writebuffer);</a>
<a name="ln612">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_INFILESIZE, writebuffer.size);</a>
<a name="ln613">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_READFUNCTION, _picasa_api_buffer_read_func);</a>
<a name="ln614">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEFUNCTION, _picasa_api_buffer_write_func);</a>
<a name="ln615">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEDATA, &amp;response);</a>
<a name="ln616">      res = curl_easy_perform(ctx-&gt;curl_ctx);</a>
<a name="ln617"> </a>
<a name="ln618">      if(res != CURLE_OK)</a>
<a name="ln619">        fprintf(stderr, &quot;[picasa] error updating photo: %s\n&quot;, curl_easy_strerror(res));</a>
<a name="ln620"> </a>
<a name="ln621">#if picasa_EXTRA_VERBOSE == TRUE</a>
<a name="ln622">      printf(&quot;Uploading: %s\n&quot;, response.data);</a>
<a name="ln623">#endif</a>
<a name="ln624"> </a>
<a name="ln625">      xmlFree(updateUri);</a>
<a name="ln626">      xmlFree(writebuffer.data);</a>
<a name="ln627">      g_free(response.data);</a>
<a name="ln628"> </a>
<a name="ln629">      curl_slist_free_all(headers);</a>
<a name="ln630">    }</a>
<a name="ln631"> </a>
<a name="ln632">    xmlFreeDoc(doc);</a>
<a name="ln633">    g_free(keywords);</a>
<a name="ln634">    g_list_free_full(keywords_list, g_free);</a>
<a name="ln635">  }</a>
<a name="ln636">  return photo_id;</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639">/**</a>
<a name="ln640"> * @see https://developers.google.com/accounts/docs/OAuth2InstalledApp#callinganapi</a>
<a name="ln641"> * @return basic information about the account</a>
<a name="ln642"> */</a>
<a name="ln643">static PicasaAccountInfo *picasa_get_account_info(PicasaContext *ctx)</a>
<a name="ln644">{</a>
<a name="ln645">  JsonObject *obj = picasa_query_get(ctx, &quot;oauth2/v1/userinfo&quot;, NULL, FALSE);</a>
<a name="ln646">  g_return_val_if_fail((obj != NULL), NULL);</a>
<a name="ln647">  /* Using the email instead of the username as it is unique */</a>
<a name="ln648">  /* To change it to use the username, change &quot;email&quot; by &quot;name&quot; */</a>
<a name="ln649">  const gchar *user_name = json_object_get_string_member(obj, &quot;given_name&quot;);</a>
<a name="ln650">  const gchar *email = json_object_get_string_member(obj, &quot;email&quot;);</a>
<a name="ln651">  const gchar *user_id = json_object_get_string_member(obj, &quot;id&quot;);</a>
<a name="ln652">  g_return_val_if_fail(user_name != NULL &amp;&amp; user_id != NULL, NULL);</a>
<a name="ln653"> </a>
<a name="ln654">  gchar *name = NULL;</a>
<a name="ln655">  name = dt_util_dstrcat(name, &quot;%s - %s&quot;, user_name, email);</a>
<a name="ln656"> </a>
<a name="ln657">  PicasaAccountInfo *accountinfo = picasa_account_info_init();</a>
<a name="ln658">  accountinfo-&gt;id = g_strdup(user_id);</a>
<a name="ln659">  accountinfo-&gt;username = g_strdup(name);</a>
<a name="ln660">  accountinfo-&gt;token = g_strdup(ctx-&gt;token);</a>
<a name="ln661">  accountinfo-&gt;refresh_token = g_strdup(ctx-&gt;refresh_token);</a>
<a name="ln662"> </a>
<a name="ln663">  g_snprintf(ctx-&gt;userid, sizeof(ctx-&gt;userid), &quot;%s&quot;, user_id);</a>
<a name="ln664">  g_free(name);</a>
<a name="ln665">  return accountinfo;</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668"> </a>
<a name="ln669">///////////////////////////////// UI functions</a>
<a name="ln670"> </a>
<a name="ln671">static gboolean combobox_separator(GtkTreeModel *model, GtkTreeIter *iter, gpointer data)</a>
<a name="ln672">{</a>
<a name="ln673">  GValue value = {</a>
<a name="ln674">    0,</a>
<a name="ln675">  };</a>
<a name="ln676">  gtk_tree_model_get_value(model, iter, 0, &amp;value);</a>
<a name="ln677">  gchar *v = NULL;</a>
<a name="ln678">  if(G_VALUE_HOLDS_STRING(&amp;value))</a>
<a name="ln679">  {</a>
<a name="ln680">    if((v = (gchar *)g_value_get_string(&amp;value)) != NULL &amp;&amp; *v == '\0') return TRUE;</a>
<a name="ln681">  }</a>
<a name="ln682">  g_value_unset(&amp;value);</a>
<a name="ln683">  return FALSE;</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686">static gchar *picasa_get_user_refresh_token(PicasaContext *ctx)</a>
<a name="ln687">{</a>
<a name="ln688">  gchar *refresh_token = NULL;</a>
<a name="ln689">  JsonObject *reply;</a>
<a name="ln690">  gchar *params = NULL;</a>
<a name="ln691"> </a>
<a name="ln692">  params = dt_util_dstrcat(params, &quot;refresh_token=%s&amp;client_id=&quot; GOOGLE_API_KEY</a>
<a name="ln693">                                   &quot;&amp;client_secret=&quot; GOOGLE_API_SECRET &quot;&amp;grant_type=refresh_token&quot;,</a>
<a name="ln694">                           ctx-&gt;refresh_token);</a>
<a name="ln695"> </a>
<a name="ln696">  reply = picasa_query_post_auth(ctx, &quot;o/oauth2/token&quot;, params);</a>
<a name="ln697"> </a>
<a name="ln698">  refresh_token = g_strdup(json_object_get_string_member(reply, &quot;access_token&quot;));</a>
<a name="ln699"> </a>
<a name="ln700">  g_free(params);</a>
<a name="ln701"> </a>
<a name="ln702">  return refresh_token;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">/**</a>
<a name="ln706"> * @see https://developers.google.com/accounts/docs/OAuth2InstalledApp</a>
<a name="ln707"> * @returns NULL if the user cancels the operation or a valid token</a>
<a name="ln708"> */</a>
<a name="ln709">static int picasa_get_user_auth_token(dt_storage_picasa_gui_data_t *ui)</a>
<a name="ln710">{</a>
<a name="ln711">  ///////////// open the authentication url in a browser</a>
<a name="ln712">  GError *error = NULL;</a>
<a name="ln713">  if(!gtk_show_uri(</a>
<a name="ln714">         gdk_screen_get_default(), GOOGLE_WS_BASE_URL</a>
<a name="ln715">         &quot;o/oauth2/auth?&quot;</a>
<a name="ln716">         &quot;client_id=&quot; GOOGLE_API_KEY &quot;&amp;redirect_uri=urn:ietf:wg:oauth:2.0:oob&quot;</a>
<a name="ln717">         &quot;&amp;scope=https://picasaweb.google.com/data/ https://www.googleapis.com/auth/userinfo.profile&quot;</a>
<a name="ln718">         &quot; https://www.googleapis.com/auth/userinfo.email&quot;</a>
<a name="ln719">         &quot;&amp;response_type=code&quot;,</a>
<a name="ln720">         gtk_get_current_event_time(), &amp;error))</a>
<a name="ln721">  {</a>
<a name="ln722">    fprintf(stderr, &quot;[picasa] error opening browser: %s\n&quot;, error-&gt;message);</a>
<a name="ln723">    g_error_free(error);</a>
<a name="ln724">  }</a>
<a name="ln725"> </a>
<a name="ln726">  ////////////// build &amp; show the validation dialog</a>
<a name="ln727">  const gchar *text1 = _(&quot;step 1: a new window or tab of your browser should have been &quot;</a>
<a name="ln728">                         &quot;loaded. you have to login into your google account there &quot;</a>
<a name="ln729">                         &quot;and authorize darktable to upload photos before continuing.&quot;);</a>
<a name="ln730">  const gchar *text2 = _(&quot;step 2: paste the verification code shown to you in the browser &quot;</a>
<a name="ln731">                         &quot;and click the OK button once you are done.&quot;);</a>
<a name="ln732"> </a>
<a name="ln733">  GtkWidget *window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln734">  GtkDialog *picasa_auth_dialog = GTK_DIALOG(</a>
<a name="ln735">      gtk_message_dialog_new(GTK_WINDOW(window), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION,</a>
<a name="ln736">                             GTK_BUTTONS_OK_CANCEL, _(&quot;google authentication&quot;)));</a>
<a name="ln737">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln738">  dt_osx_disallow_fullscreen(GTK_WIDGET(picasa_auth_dialog));</a>
<a name="ln739">#endif</a>
<a name="ln740">  gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(picasa_auth_dialog), &quot;%s\n\n%s&quot;, text1, text2);</a>
<a name="ln741"> </a>
<a name="ln742">  GtkWidget *entry = gtk_entry_new();</a>
<a name="ln743">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln744">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtk_label_new(_(&quot;verification code:&quot;))), FALSE, FALSE, 0);</a>
<a name="ln745">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(entry), TRUE, TRUE, 0);</a>
<a name="ln746"> </a>
<a name="ln747">  GtkWidget *picasaauthdialog_vbox</a>
<a name="ln748">      = gtk_message_dialog_get_message_area(GTK_MESSAGE_DIALOG(picasa_auth_dialog));</a>
<a name="ln749">  gtk_box_pack_end(GTK_BOX(picasaauthdialog_vbox), hbox, TRUE, TRUE, 0);</a>
<a name="ln750"> </a>
<a name="ln751">  gtk_widget_show_all(GTK_WIDGET(picasa_auth_dialog));</a>
<a name="ln752"> </a>
<a name="ln753">  ////////////// wait for the user to enter the verification code</a>
<a name="ln754">  gint result;</a>
<a name="ln755">  gchar *token = NULL;</a>
<a name="ln756">  const char *replycode;</a>
<a name="ln757">  while(TRUE)</a>
<a name="ln758">  {</a>
<a name="ln759">    result = gtk_dialog_run(GTK_DIALOG(picasa_auth_dialog));</a>
<a name="ln760">    if(result == GTK_RESPONSE_CANCEL) break;</a>
<a name="ln761">    replycode = gtk_entry_get_text(GTK_ENTRY(entry));</a>
<a name="ln762">    if(replycode == NULL || g_strcmp0(replycode, &quot;&quot;) == 0)</a>
<a name="ln763">    {</a>
<a name="ln764">      gtk_message_dialog_format_secondary_markup(GTK_MESSAGE_DIALOG(picasa_auth_dialog),</a>
<a name="ln765">                                                 &quot;%s\n\n%s\n\n&lt;span foreground=\&quot;&quot; MSGCOLOR_RED</a>
<a name="ln766">                                                 &quot;\&quot; &gt;&lt;small&gt;%s&lt;/small&gt;&lt;/span&gt;&quot;,</a>
<a name="ln767">                                                 text1, text2, _(&quot;please enter the verification code&quot;));</a>
<a name="ln768">      continue;</a>
<a name="ln769">    }</a>
<a name="ln770">    else</a>
<a name="ln771">    {</a>
<a name="ln772">      token = g_strdup(replycode);</a>
<a name="ln773">      break;</a>
<a name="ln774">    }</a>
<a name="ln775">  }</a>
<a name="ln776">  gtk_widget_destroy(GTK_WIDGET(picasa_auth_dialog));</a>
<a name="ln777"> </a>
<a name="ln778">  if(result == GTK_RESPONSE_CANCEL)</a>
<a name="ln779">    return 1;</a>
<a name="ln780"> </a>
<a name="ln781">  // Interchange now the authorization_code for an access_token and refresh_token</a>
<a name="ln782">  JsonObject *reply;</a>
<a name="ln783"> </a>
<a name="ln784">  gchar *params = NULL;</a>
<a name="ln785">  params = dt_util_dstrcat(params, &quot;code=%s&amp;client_id=&quot; GOOGLE_API_KEY &quot;&amp;client_secret=&quot; GOOGLE_API_SECRET</a>
<a name="ln786">                                   &quot;&amp;redirect_uri=&quot; GOOGLE_URI &quot;&amp;grant_type=authorization_code&quot;,</a>
<a name="ln787">                           token);</a>
<a name="ln788"> </a>
<a name="ln789">  g_free(token);</a>
<a name="ln790"> </a>
<a name="ln791">  reply = picasa_query_post_auth(ui-&gt;picasa_api, &quot;o/oauth2/token&quot;, params);</a>
<a name="ln792"> </a>
<a name="ln793">  gchar *access_token = g_strdup(json_object_get_string_member(reply, &quot;access_token&quot;));</a>
<a name="ln794"> </a>
<a name="ln795">  gchar *refresh_token = g_strdup(json_object_get_string_member(reply, &quot;refresh_token&quot;));</a>
<a name="ln796"> </a>
<a name="ln797">  ui-&gt;picasa_api-&gt;token = access_token;</a>
<a name="ln798">  ui-&gt;picasa_api-&gt;refresh_token = refresh_token;</a>
<a name="ln799"> </a>
<a name="ln800">  g_free(params);</a>
<a name="ln801"> </a>
<a name="ln802">  return 0; // FIXME</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805"> </a>
<a name="ln806">static void load_account_info_fill(gchar *key, gchar *value, GSList **accountlist)</a>
<a name="ln807">{</a>
<a name="ln808">  JsonParser *parser = json_parser_new();</a>
<a name="ln809">  json_parser_load_from_data(parser, value, strlen(value), NULL);</a>
<a name="ln810">  JsonNode *root = json_parser_get_root(parser);</a>
<a name="ln811"> </a>
<a name="ln812">  // defensive check, root can be null while parsing the account info</a>
<a name="ln813">  if(root)</a>
<a name="ln814">  {</a>
<a name="ln815">    JsonObject *obj = json_node_get_object(root);</a>
<a name="ln816">    PicasaAccountInfo *info = picasa_account_info_init();</a>
<a name="ln817">    info-&gt;id = g_strdup(key);</a>
<a name="ln818">    info-&gt;token = g_strdup(json_object_get_string_member(obj, &quot;token&quot;));</a>
<a name="ln819">    info-&gt;username = g_strdup(json_object_get_string_member(obj, &quot;username&quot;));</a>
<a name="ln820">    info-&gt;id = g_strdup(json_object_get_string_member(obj, &quot;userid&quot;));</a>
<a name="ln821">    info-&gt;refresh_token = g_strdup(json_object_get_string_member(obj, &quot;refresh_token&quot;));</a>
<a name="ln822">    *accountlist = g_slist_prepend(*accountlist, info);</a>
<a name="ln823">  }</a>
<a name="ln824">  g_object_unref(parser);</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">/**</a>
<a name="ln828"> * @return a GSList of saved PicasaAccountInfo</a>
<a name="ln829"> */</a>
<a name="ln830">static GSList *load_account_info()</a>
<a name="ln831">{</a>
<a name="ln832">  GSList *accountlist = NULL;</a>
<a name="ln833"> </a>
<a name="ln834">  GHashTable *table = dt_pwstorage_get(&quot;picasa2&quot;);</a>
<a name="ln835">  g_hash_table_foreach(table, (GHFunc)load_account_info_fill, &amp;accountlist);</a>
<a name="ln836">  g_hash_table_destroy(table);</a>
<a name="ln837">  return accountlist;</a>
<a name="ln838">}</a>
<a name="ln839"> </a>
<a name="ln840">static void save_account_info(dt_storage_picasa_gui_data_t *ui, PicasaAccountInfo *accountinfo)</a>
<a name="ln841">{</a>
<a name="ln842">  PicasaContext *ctx = ui-&gt;picasa_api;</a>
<a name="ln843">  g_return_if_fail(ctx != NULL);</a>
<a name="ln844"> </a>
<a name="ln845">  /// serialize data;</a>
<a name="ln846">  JsonBuilder *builder = json_builder_new();</a>
<a name="ln847">  json_builder_begin_object(builder);</a>
<a name="ln848">  json_builder_set_member_name(builder, &quot;username&quot;);</a>
<a name="ln849">  json_builder_add_string_value(builder, accountinfo-&gt;username);</a>
<a name="ln850">  json_builder_set_member_name(builder, &quot;userid&quot;);</a>
<a name="ln851">  json_builder_add_string_value(builder, accountinfo-&gt;id);</a>
<a name="ln852">  json_builder_set_member_name(builder, &quot;token&quot;);</a>
<a name="ln853">  json_builder_add_string_value(builder, accountinfo-&gt;token);</a>
<a name="ln854">  json_builder_set_member_name(builder, &quot;refresh_token&quot;);</a>
<a name="ln855">  json_builder_add_string_value(builder, accountinfo-&gt;refresh_token);</a>
<a name="ln856"> </a>
<a name="ln857">  json_builder_end_object(builder);</a>
<a name="ln858"> </a>
<a name="ln859">  JsonNode *node = json_builder_get_root(builder);</a>
<a name="ln860">  JsonGenerator *generator = json_generator_new();</a>
<a name="ln861">  json_generator_set_root(generator, node);</a>
<a name="ln862">#if JSON_CHECK_VERSION(0, 14, 0)</a>
<a name="ln863">  json_generator_set_pretty(generator, FALSE);</a>
<a name="ln864">#endif</a>
<a name="ln865">  gchar *data = json_generator_to_data(generator, NULL);</a>
<a name="ln866"> </a>
<a name="ln867">  json_node_free(node);</a>
<a name="ln868">  g_object_unref(generator);</a>
<a name="ln869">  g_object_unref(builder);</a>
<a name="ln870"> </a>
<a name="ln871">  GHashTable *table = dt_pwstorage_get(&quot;picasa2&quot;);</a>
<a name="ln872">  g_hash_table_insert(table, g_strdup(accountinfo-&gt;id), data);</a>
<a name="ln873">  dt_pwstorage_set(&quot;picasa2&quot;, table);</a>
<a name="ln874"> </a>
<a name="ln875">  g_hash_table_destroy(table);</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">static void remove_account_info(const gchar *accountid)</a>
<a name="ln879">{</a>
<a name="ln880">  GHashTable *table = dt_pwstorage_get(&quot;picasa2&quot;);</a>
<a name="ln881">  g_hash_table_remove(table, accountid);</a>
<a name="ln882">  dt_pwstorage_set(&quot;picasa2&quot;, table);</a>
<a name="ln883">  g_hash_table_destroy(table);</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">static void ui_refresh_users_fill(PicasaAccountInfo *value, gpointer dataptr)</a>
<a name="ln887">{</a>
<a name="ln888">  GtkListStore *liststore = GTK_LIST_STORE(dataptr);</a>
<a name="ln889">  GtkTreeIter iter;</a>
<a name="ln890">  gtk_list_store_append(liststore, &amp;iter);</a>
<a name="ln891">  gtk_list_store_set(liststore, &amp;iter, COMBO_USER_MODEL_NAME_COL, value-&gt;username, COMBO_USER_MODEL_TOKEN_COL,</a>
<a name="ln892">                     value-&gt;token, COMBO_USER_MODEL_REFRESH_TOKEN_COL, value-&gt;refresh_token,</a>
<a name="ln893">                     COMBO_USER_MODEL_ID_COL, value-&gt;id, -1);</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896">static void ui_refresh_users(dt_storage_picasa_gui_data_t *ui)</a>
<a name="ln897">{</a>
<a name="ln898">  GSList *accountlist = load_account_info();</a>
<a name="ln899">  GtkListStore *list_store = GTK_LIST_STORE(gtk_combo_box_get_model(ui-&gt;comboBox_username));</a>
<a name="ln900">  GtkTreeIter iter;</a>
<a name="ln901"> </a>
<a name="ln902">  gtk_list_store_clear(list_store);</a>
<a name="ln903">  gtk_list_store_append(list_store, &amp;iter);</a>
<a name="ln904"> </a>
<a name="ln905">  if(g_slist_length(accountlist) == 0)</a>
<a name="ln906">  {</a>
<a name="ln907">    gtk_list_store_set(list_store, &amp;iter, COMBO_USER_MODEL_NAME_COL, _(&quot;new account&quot;),</a>
<a name="ln908">                       COMBO_USER_MODEL_TOKEN_COL, NULL, COMBO_USER_MODEL_ID_COL, NULL, -1);</a>
<a name="ln909">  }</a>
<a name="ln910">  else</a>
<a name="ln911">  {</a>
<a name="ln912">    gtk_list_store_set(list_store, &amp;iter, COMBO_USER_MODEL_NAME_COL, _(&quot;other account&quot;),</a>
<a name="ln913">                       COMBO_USER_MODEL_TOKEN_COL, NULL, COMBO_USER_MODEL_ID_COL, NULL, -1);</a>
<a name="ln914">    gtk_list_store_append(list_store, &amp;iter);</a>
<a name="ln915">    gtk_list_store_set(list_store, &amp;iter, COMBO_USER_MODEL_NAME_COL, &quot;&quot;, COMBO_USER_MODEL_TOKEN_COL, NULL,</a>
<a name="ln916">                       COMBO_USER_MODEL_ID_COL, NULL, -1); // separator</a>
<a name="ln917">  }</a>
<a name="ln918"> </a>
<a name="ln919">  g_slist_foreach(accountlist, (GFunc)ui_refresh_users_fill, list_store);</a>
<a name="ln920">  gtk_combo_box_set_active(ui-&gt;comboBox_username, 0);</a>
<a name="ln921"> </a>
<a name="ln922">  g_slist_free_full(accountlist, (GDestroyNotify)picasa_account_info_destroy);</a>
<a name="ln923">  gtk_combo_box_set_row_separator_func(ui-&gt;comboBox_username, combobox_separator, ui-&gt;comboBox_username, NULL);</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926">static void ui_refresh_albums_fill(PicasaAlbum *album, GtkListStore *list_store)</a>
<a name="ln927">{</a>
<a name="ln928">  GtkTreeIter iter;</a>
<a name="ln929">  gtk_list_store_append(list_store, &amp;iter);</a>
<a name="ln930">  gtk_list_store_set(list_store, &amp;iter, COMBO_ALBUM_MODEL_NAME_COL, album-&gt;name, COMBO_ALBUM_MODEL_ID_COL,</a>
<a name="ln931">                     album-&gt;id, -1);</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934">static void ui_refresh_albums(dt_storage_picasa_gui_data_t *ui)</a>
<a name="ln935">{</a>
<a name="ln936"> </a>
<a name="ln937">  gboolean getlistok;</a>
<a name="ln938">  GList *albumList = picasa_get_album_list(ui-&gt;picasa_api, &amp;getlistok);</a>
<a name="ln939">  if(!getlistok)</a>
<a name="ln940">  {</a>
<a name="ln941">    dt_control_log(_(&quot;unable to retrieve the album list&quot;));</a>
<a name="ln942">    goto cleanup;</a>
<a name="ln943">  }</a>
<a name="ln944"> </a>
<a name="ln945">  int current_index = gtk_combo_box_get_active(ui-&gt;comboBox_album);</a>
<a name="ln946"> </a>
<a name="ln947">  GtkListStore *model_album = GTK_LIST_STORE(gtk_combo_box_get_model(ui-&gt;comboBox_album));</a>
<a name="ln948">  GtkTreeIter iter;</a>
<a name="ln949">  gtk_list_store_clear(model_album);</a>
<a name="ln950">  gtk_list_store_append(model_album, &amp;iter);</a>
<a name="ln951">  gtk_list_store_set(model_album, &amp;iter, COMBO_ALBUM_MODEL_NAME_COL, _(&quot;drop box&quot;),</a>
<a name="ln952">                     COMBO_ALBUM_MODEL_ID_COL, NULL, -1);</a>
<a name="ln953">  if(albumList != NULL)</a>
<a name="ln954">  {</a>
<a name="ln955">    gtk_list_store_append(model_album, &amp;iter);</a>
<a name="ln956">    gtk_list_store_set(model_album, &amp;iter, COMBO_ALBUM_MODEL_NAME_COL, &quot;&quot;, COMBO_ALBUM_MODEL_ID_COL, NULL,</a>
<a name="ln957">                       -1); // separator</a>
<a name="ln958">  }</a>
<a name="ln959">  g_list_foreach(albumList, (GFunc)ui_refresh_albums_fill, model_album);</a>
<a name="ln960"> </a>
<a name="ln961">  if (albumList != NULL &amp;&amp; current_index != -1)</a>
<a name="ln962">    gtk_combo_box_set_active(ui-&gt;comboBox_album, current_index);</a>
<a name="ln963">  else</a>
<a name="ln964">    gtk_combo_box_set_active(ui-&gt;comboBox_album, 0);</a>
<a name="ln965"> </a>
<a name="ln966">  gtk_widget_show_all(GTK_WIDGET(ui-&gt;comboBox_album));</a>
<a name="ln967">  g_list_free_full(albumList, (GDestroyNotify)picasa_album_destroy);</a>
<a name="ln968"> </a>
<a name="ln969">cleanup:</a>
<a name="ln970">  return;</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973">static void ui_combo_username_changed(GtkComboBox *combo, struct dt_storage_picasa_gui_data_t *ui)</a>
<a name="ln974">{</a>
<a name="ln975">  GtkTreeIter iter;</a>
<a name="ln976">  gchar *token = NULL;</a>
<a name="ln977">  gchar *refresh_token = NULL;</a>
<a name="ln978">  gchar *userid = NULL;</a>
<a name="ln979">  if(!gtk_combo_box_get_active_iter(combo, &amp;iter)) return; // ie: list is empty while clearing the combo</a>
<a name="ln980">  GtkTreeModel *model = gtk_combo_box_get_model(combo);</a>
<a name="ln981">  gtk_tree_model_get(model, &amp;iter, COMBO_USER_MODEL_TOKEN_COL, &amp;token, -1); // get the selected token</a>
<a name="ln982">  gtk_tree_model_get(model, &amp;iter, COMBO_USER_MODEL_REFRESH_TOKEN_COL, &amp;refresh_token, -1);</a>
<a name="ln983">  gtk_tree_model_get(model, &amp;iter, COMBO_USER_MODEL_ID_COL, &amp;userid, -1);</a>
<a name="ln984"> </a>
<a name="ln985">  ui-&gt;picasa_api-&gt;token = g_strdup(token);</a>
<a name="ln986">  ui-&gt;picasa_api-&gt;refresh_token = g_strdup(refresh_token);</a>
<a name="ln987">  g_snprintf(ui-&gt;picasa_api-&gt;userid, sizeof(ui-&gt;picasa_api-&gt;userid), &quot;%s&quot;, userid);</a>
<a name="ln988"> </a>
<a name="ln989">  if(ui-&gt;picasa_api-&gt;token != NULL &amp;&amp; picasa_test_auth_token(ui-&gt;picasa_api))</a>
<a name="ln990">  {</a>
<a name="ln991">    ui-&gt;connected = TRUE;</a>
<a name="ln992">    gtk_button_set_label(ui-&gt;button_login, _(&quot;logout&quot;));</a>
<a name="ln993">    ui_refresh_albums(ui);</a>
<a name="ln994">    gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;comboBox_album), TRUE);</a>
<a name="ln995">  }</a>
<a name="ln996">  else</a>
<a name="ln997">  {</a>
<a name="ln998">    gtk_button_set_label(ui-&gt;button_login, _(&quot;login&quot;));</a>
<a name="ln999">    g_free(ui-&gt;picasa_api-&gt;token);</a>
<a name="ln1000">    g_free(ui-&gt;picasa_api-&gt;refresh_token);</a>
<a name="ln1001">    ui-&gt;picasa_api-&gt;token = ui-&gt;picasa_api-&gt;refresh_token = NULL;</a>
<a name="ln1002">    gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;comboBox_album), FALSE);</a>
<a name="ln1003">    GtkListStore *model_album = GTK_LIST_STORE(gtk_combo_box_get_model(ui-&gt;comboBox_album));</a>
<a name="ln1004">    gtk_list_store_clear(model_album);</a>
<a name="ln1005">  }</a>
<a name="ln1006">}</a>
<a name="ln1007"> </a>
<a name="ln1008">static void ui_combo_album_changed(GtkComboBox *combo, gpointer data)</a>
<a name="ln1009">{</a>
<a name="ln1010">  GtkTreeIter iter;</a>
<a name="ln1011">  gchar *albumid = NULL;</a>
<a name="ln1012">  if(gtk_combo_box_get_active_iter(combo, &amp;iter))</a>
<a name="ln1013">  {</a>
<a name="ln1014">    GtkTreeModel *model = gtk_combo_box_get_model(combo);</a>
<a name="ln1015">    gtk_tree_model_get(model, &amp;iter, COMBO_ALBUM_MODEL_ID_COL, &amp;albumid, -1); // get the album id</a>
<a name="ln1016">  }</a>
<a name="ln1017">}</a>
<a name="ln1018"> </a>
<a name="ln1019"> </a>
<a name="ln1020">static gboolean ui_authenticate(dt_storage_picasa_gui_data_t *ui)</a>
<a name="ln1021">{</a>
<a name="ln1022">  if(ui-&gt;picasa_api == NULL)</a>
<a name="ln1023">  {</a>
<a name="ln1024">    ui-&gt;picasa_api = picasa_api_init();</a>
<a name="ln1025">  }</a>
<a name="ln1026"> </a>
<a name="ln1027">  PicasaContext *ctx = ui-&gt;picasa_api;</a>
<a name="ln1028">  gboolean mustsaveaccount = FALSE;</a>
<a name="ln1029"> </a>
<a name="ln1030">  gchar *uiselectedaccounttoken = NULL;</a>
<a name="ln1031">  gchar *uiselectedaccountrefreshtoken = NULL;</a>
<a name="ln1032">  gchar *uiselecteduserid = NULL;</a>
<a name="ln1033">  GtkTreeIter iter;</a>
<a name="ln1034">  gtk_combo_box_get_active_iter(ui-&gt;comboBox_username, &amp;iter);</a>
<a name="ln1035">  GtkTreeModel *accountModel = gtk_combo_box_get_model(ui-&gt;comboBox_username);</a>
<a name="ln1036">  gtk_tree_model_get(accountModel, &amp;iter, COMBO_USER_MODEL_TOKEN_COL, &amp;uiselectedaccounttoken, -1);</a>
<a name="ln1037">  gtk_tree_model_get(accountModel, &amp;iter, COMBO_USER_MODEL_REFRESH_TOKEN_COL, &amp;uiselectedaccountrefreshtoken,</a>
<a name="ln1038">                     -1);</a>
<a name="ln1039">  gtk_tree_model_get(accountModel, &amp;iter, COMBO_USER_MODEL_ID_COL, &amp;uiselecteduserid, -1);</a>
<a name="ln1040"> </a>
<a name="ln1041">  if(ctx-&gt;token != NULL)</a>
<a name="ln1042">  {</a>
<a name="ln1043">    g_free(ctx-&gt;token);</a>
<a name="ln1044">    g_free(ctx-&gt;refresh_token);</a>
<a name="ln1045">    ctx-&gt;userid[0] = 0;</a>
<a name="ln1046">    ctx-&gt;token = ctx-&gt;refresh_token = NULL;</a>
<a name="ln1047">  }</a>
<a name="ln1048"> </a>
<a name="ln1049">  if(uiselectedaccounttoken != NULL)</a>
<a name="ln1050">  {</a>
<a name="ln1051">    ctx-&gt;token = g_strdup(uiselectedaccounttoken);</a>
<a name="ln1052">    ctx-&gt;refresh_token = g_strdup(uiselectedaccountrefreshtoken);</a>
<a name="ln1053">    g_snprintf(ctx-&gt;userid, sizeof(ctx-&gt;userid), &quot;%s&quot;, uiselecteduserid);</a>
<a name="ln1054">  }</a>
<a name="ln1055">  // check selected token if we already have one</a>
<a name="ln1056">  if(ctx-&gt;token != NULL &amp;&amp; !picasa_test_auth_token(ctx))</a>
<a name="ln1057">  {</a>
<a name="ln1058">    g_free(ctx-&gt;token);</a>
<a name="ln1059">    g_free(ctx-&gt;refresh_token);</a>
<a name="ln1060">    ctx-&gt;userid[0] = 0;</a>
<a name="ln1061">    ctx-&gt;token = ctx-&gt;refresh_token = NULL;</a>
<a name="ln1062">  }</a>
<a name="ln1063"> </a>
<a name="ln1064">  int ret = 0;</a>
<a name="ln1065">  if(ctx-&gt;token == NULL)</a>
<a name="ln1066">  {</a>
<a name="ln1067">    mustsaveaccount = TRUE;</a>
<a name="ln1068">    ret = picasa_get_user_auth_token(ui); // ask user to log in</a>
<a name="ln1069">  }</a>
<a name="ln1070"> </a>
<a name="ln1071">  if(ctx-&gt;token == NULL || ctx-&gt;refresh_token == NULL || ret != 0)</a>
<a name="ln1072">  {</a>
<a name="ln1073">    return FALSE;</a>
<a name="ln1074">  }</a>
<a name="ln1075">  else</a>
<a name="ln1076">  {</a>
<a name="ln1077">    if(mustsaveaccount)</a>
<a name="ln1078">    {</a>
<a name="ln1079">      // Get first the refresh token</a>
<a name="ln1080">      PicasaAccountInfo *accountinfo = picasa_get_account_info(ui-&gt;picasa_api);</a>
<a name="ln1081">      g_return_val_if_fail(accountinfo != NULL, FALSE);</a>
<a name="ln1082">      save_account_info(ui, accountinfo);</a>
<a name="ln1083"> </a>
<a name="ln1084">      // add account to user list and select it</a>
<a name="ln1085">      GtkListStore *model = GTK_LIST_STORE(gtk_combo_box_get_model(ui-&gt;comboBox_username));</a>
<a name="ln1086">      gboolean r;</a>
<a name="ln1087">      gchar *uid;</a>
<a name="ln1088"> </a>
<a name="ln1089">      gboolean updated = FALSE;</a>
<a name="ln1090"> </a>
<a name="ln1091">      for(r = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &amp;iter); r == TRUE;</a>
<a name="ln1092">          r = gtk_tree_model_iter_next(GTK_TREE_MODEL(model), &amp;iter))</a>
<a name="ln1093">      {</a>
<a name="ln1094">        gtk_tree_model_get(GTK_TREE_MODEL(model), &amp;iter, COMBO_USER_MODEL_ID_COL, &amp;uid, -1);</a>
<a name="ln1095"> </a>
<a name="ln1096">        if(g_strcmp0(uid, accountinfo-&gt;id) == 0)</a>
<a name="ln1097">        {</a>
<a name="ln1098">          gtk_list_store_set(model, &amp;iter, COMBO_USER_MODEL_NAME_COL, accountinfo-&gt;username,</a>
<a name="ln1099">                             COMBO_USER_MODEL_TOKEN_COL, accountinfo-&gt;token,</a>
<a name="ln1100">                             COMBO_USER_MODEL_REFRESH_TOKEN_COL, accountinfo-&gt;refresh_token, -1);</a>
<a name="ln1101">          updated = TRUE;</a>
<a name="ln1102">          break;</a>
<a name="ln1103">        }</a>
<a name="ln1104">      }</a>
<a name="ln1105"> </a>
<a name="ln1106">      if(!updated)</a>
<a name="ln1107">      {</a>
<a name="ln1108">        gtk_list_store_append(model, &amp;iter);</a>
<a name="ln1109">        gtk_list_store_set(model, &amp;iter, COMBO_USER_MODEL_NAME_COL, accountinfo-&gt;username,</a>
<a name="ln1110">                           COMBO_USER_MODEL_TOKEN_COL, accountinfo-&gt;token, COMBO_USER_MODEL_REFRESH_TOKEN_COL,</a>
<a name="ln1111">                           accountinfo-&gt;refresh_token, COMBO_USER_MODEL_ID_COL, accountinfo-&gt;id, -1);</a>
<a name="ln1112">      }</a>
<a name="ln1113">      g_signal_handlers_block_matched(ui-&gt;comboBox_username, G_SIGNAL_MATCH_FUNC, 0, 0, NULL,</a>
<a name="ln1114">                                      ui_combo_username_changed, NULL);</a>
<a name="ln1115">      gtk_combo_box_set_active_iter(ui-&gt;comboBox_username, &amp;iter);</a>
<a name="ln1116">      g_signal_handlers_unblock_matched(ui-&gt;comboBox_username, G_SIGNAL_MATCH_FUNC, 0, 0, NULL,</a>
<a name="ln1117">                                        ui_combo_username_changed, NULL);</a>
<a name="ln1118"> </a>
<a name="ln1119">      picasa_account_info_destroy(accountinfo);</a>
<a name="ln1120">    }</a>
<a name="ln1121">    return TRUE;</a>
<a name="ln1122">  }</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125"> </a>
<a name="ln1126">static void ui_login_clicked(GtkButton *button, gpointer data)</a>
<a name="ln1127">{</a>
<a name="ln1128">  dt_storage_picasa_gui_data_t *ui = (dt_storage_picasa_gui_data_t *)data;</a>
<a name="ln1129">  gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;comboBox_album), FALSE);</a>
<a name="ln1130">  if(ui-&gt;connected == FALSE)</a>
<a name="ln1131">  {</a>
<a name="ln1132">    if(ui_authenticate(ui))</a>
<a name="ln1133">    {</a>
<a name="ln1134">      ui_refresh_albums(ui);</a>
<a name="ln1135">      ui-&gt;connected = TRUE;</a>
<a name="ln1136">      gtk_button_set_label(ui-&gt;button_login, _(&quot;logout&quot;));</a>
<a name="ln1137">    }</a>
<a name="ln1138">    else</a>
<a name="ln1139">    {</a>
<a name="ln1140">      gtk_button_set_label(ui-&gt;button_login, _(&quot;login&quot;));</a>
<a name="ln1141">    }</a>
<a name="ln1142">  }</a>
<a name="ln1143">  else // disconnect user</a>
<a name="ln1144">  {</a>
<a name="ln1145">    if(ui-&gt;connected == TRUE &amp;&amp; ui-&gt;picasa_api-&gt;token != NULL)</a>
<a name="ln1146">    {</a>
<a name="ln1147">      GtkTreeModel *model = gtk_combo_box_get_model(ui-&gt;comboBox_username);</a>
<a name="ln1148">      GtkTreeIter iter;</a>
<a name="ln1149">      gtk_combo_box_get_active_iter(ui-&gt;comboBox_username, &amp;iter);</a>
<a name="ln1150">      gchar *userid;</a>
<a name="ln1151">      gtk_tree_model_get(model, &amp;iter, COMBO_USER_MODEL_ID_COL, &amp;userid, -1);</a>
<a name="ln1152">      remove_account_info(userid);</a>
<a name="ln1153">      gtk_button_set_label(ui-&gt;button_login, _(&quot;login&quot;));</a>
<a name="ln1154">      ui_refresh_users(ui);</a>
<a name="ln1155">      ui-&gt;connected = FALSE;</a>
<a name="ln1156">    }</a>
<a name="ln1157">  }</a>
<a name="ln1158">  gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;comboBox_album), TRUE);</a>
<a name="ln1159">}</a>
<a name="ln1160"> </a>
<a name="ln1161"> </a>
<a name="ln1162"> </a>
<a name="ln1163">////////////////////////// darktable library interface</a>
<a name="ln1164"> </a>
<a name="ln1165">/* plugin name */</a>
<a name="ln1166">const char *name(const struct dt_imageio_module_storage_t *self)</a>
<a name="ln1167">{</a>
<a name="ln1168">  return _(&quot;google photos&quot;);</a>
<a name="ln1169">}</a>
<a name="ln1170"> </a>
<a name="ln1171">/* construct widget above */</a>
<a name="ln1172">void gui_init(struct dt_imageio_module_storage_t *self)</a>
<a name="ln1173">{</a>
<a name="ln1174">  self-&gt;gui_data = g_malloc0(sizeof(dt_storage_picasa_gui_data_t));</a>
<a name="ln1175">  dt_storage_picasa_gui_data_t *ui = self-&gt;gui_data;</a>
<a name="ln1176">  ui-&gt;picasa_api = picasa_api_init();</a>
<a name="ln1177"> </a>
<a name="ln1178">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1179"> </a>
<a name="ln1180">  // create entries</a>
<a name="ln1181">  GtkListStore *model_username</a>
<a name="ln1182">      = gtk_list_store_new(COMBO_USER_MODEL_NB_COL, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING,</a>
<a name="ln1183">                           G_TYPE_STRING); // text, token, refresh_token, id</a>
<a name="ln1184">  ui-&gt;comboBox_username = GTK_COMBO_BOX(gtk_combo_box_new_with_model(GTK_TREE_MODEL(model_username)));</a>
<a name="ln1185">  GtkCellRenderer *p_cell = gtk_cell_renderer_text_new();</a>
<a name="ln1186">  g_object_set(G_OBJECT(p_cell), &quot;ellipsize&quot;, PANGO_ELLIPSIZE_MIDDLE, &quot;ellipsize-set&quot;, TRUE, &quot;width-chars&quot;, 35,</a>
<a name="ln1187">               (gchar *)0);</a>
<a name="ln1188">  gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(ui-&gt;comboBox_username), p_cell, FALSE);</a>
<a name="ln1189">  gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(ui-&gt;comboBox_username), p_cell, &quot;text&quot;, 0, NULL);</a>
<a name="ln1190"> </a>
<a name="ln1191">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(ui-&gt;comboBox_username));</a>
<a name="ln1192"> </a>
<a name="ln1193">  // retrieve saved accounts</a>
<a name="ln1194">  ui_refresh_users(ui);</a>
<a name="ln1195"> </a>
<a name="ln1196">  //////// album list /////////</a>
<a name="ln1197">  GtkWidget *albumlist = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1198">  GtkListStore *model_album</a>
<a name="ln1199">      = gtk_list_store_new(COMBO_ALBUM_MODEL_NB_COL, G_TYPE_STRING, G_TYPE_STRING); // name, id</a>
<a name="ln1200">  ui-&gt;comboBox_album = GTK_COMBO_BOX(gtk_combo_box_new_with_model(GTK_TREE_MODEL(model_album)));</a>
<a name="ln1201">  p_cell = gtk_cell_renderer_text_new();</a>
<a name="ln1202">  g_object_set(G_OBJECT(p_cell), &quot;ellipsize&quot;, PANGO_ELLIPSIZE_MIDDLE, &quot;ellipsize-set&quot;, TRUE, &quot;width-chars&quot;, 35,</a>
<a name="ln1203">               (gchar *)0);</a>
<a name="ln1204">  gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(ui-&gt;comboBox_album), p_cell, FALSE);</a>
<a name="ln1205">  gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(ui-&gt;comboBox_album), p_cell, &quot;text&quot;, 0, NULL);</a>
<a name="ln1206"> </a>
<a name="ln1207">  gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;comboBox_album), FALSE);</a>
<a name="ln1208">  gtk_combo_box_set_row_separator_func(ui-&gt;comboBox_album, combobox_separator, ui-&gt;comboBox_album, NULL);</a>
<a name="ln1209">  gtk_box_pack_start(GTK_BOX(albumlist), GTK_WIDGET(ui-&gt;comboBox_album), TRUE, TRUE, 0);</a>
<a name="ln1210"> </a>
<a name="ln1211">  ui-&gt;button_login = GTK_BUTTON(gtk_button_new_with_label(_(&quot;login&quot;)));</a>
<a name="ln1212">  ui-&gt;connected = FALSE;</a>
<a name="ln1213"> </a>
<a name="ln1214">  // pack the ui</a>
<a name="ln1215">  ////the auth box</a>
<a name="ln1216">  GtkWidget *hbox_auth = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln1217">  GtkWidget *vbox_auth_labels = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1218">  GtkWidget *vbox_auth_fields = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1219">  gtk_box_pack_start(GTK_BOX(hbox_auth), vbox_auth_labels, FALSE, FALSE, 0);</a>
<a name="ln1220">  gtk_box_pack_start(GTK_BOX(hbox_auth), vbox_auth_fields, TRUE, TRUE, 0);</a>
<a name="ln1221">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hbox_auth), TRUE, FALSE, 2);</a>
<a name="ln1222">  gtk_box_pack_start(GTK_BOX(vbox_auth_fields), GTK_WIDGET(ui-&gt;comboBox_username), TRUE, FALSE, 2);</a>
<a name="ln1223"> </a>
<a name="ln1224">  gtk_box_pack_start(GTK_BOX(vbox_auth_labels), GTK_WIDGET(gtk_label_new(&quot;&quot;)), TRUE, TRUE, 2);</a>
<a name="ln1225">  gtk_box_pack_start(GTK_BOX(vbox_auth_fields), GTK_WIDGET(ui-&gt;button_login), TRUE, FALSE, 2);</a>
<a name="ln1226"> </a>
<a name="ln1227">  gtk_box_pack_start(GTK_BOX(vbox_auth_fields), GTK_WIDGET(albumlist), TRUE, FALSE, 2);</a>
<a name="ln1228"> </a>
<a name="ln1229">  // connect buttons to signals</a>
<a name="ln1230">  g_signal_connect(G_OBJECT(ui-&gt;button_login), &quot;clicked&quot;, G_CALLBACK(ui_login_clicked), (gpointer)ui);</a>
<a name="ln1231">  g_signal_connect(G_OBJECT(ui-&gt;comboBox_username), &quot;changed&quot;, G_CALLBACK(ui_combo_username_changed),</a>
<a name="ln1232">                   (gpointer)ui);</a>
<a name="ln1233">  g_signal_connect(G_OBJECT(ui-&gt;comboBox_album), &quot;changed&quot;, G_CALLBACK(ui_combo_album_changed), (gpointer)ui);</a>
<a name="ln1234"> </a>
<a name="ln1235">  g_object_unref(model_username);</a>
<a name="ln1236">  g_object_unref(model_album);</a>
<a name="ln1237">}</a>
<a name="ln1238"> </a>
<a name="ln1239">/* destroy resources */</a>
<a name="ln1240">void gui_cleanup(struct dt_imageio_module_storage_t *self)</a>
<a name="ln1241">{</a>
<a name="ln1242">  dt_storage_picasa_gui_data_t *ui = self-&gt;gui_data;</a>
<a name="ln1243">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ui-&gt;comboBox_username));</a>
<a name="ln1244">  if(ui-&gt;picasa_api != NULL) picasa_api_destroy(ui-&gt;picasa_api);</a>
<a name="ln1245">  g_free(self-&gt;gui_data);</a>
<a name="ln1246">}</a>
<a name="ln1247"> </a>
<a name="ln1248">/* reset options to defaults */</a>
<a name="ln1249">void gui_reset(struct dt_imageio_module_storage_t *self)</a>
<a name="ln1250">{</a>
<a name="ln1251">  // TODO?</a>
<a name="ln1252">}</a>
<a name="ln1253"> </a>
<a name="ln1254">/* try and see if this format is supported? */</a>
<a name="ln1255">int supported(struct dt_imageio_module_storage_t *self, struct dt_imageio_module_format_t *format)</a>
<a name="ln1256">{</a>
<a name="ln1257">  if(strcmp(format-&gt;mime(NULL), &quot;image/jpeg&quot;) == 0) return 1;</a>
<a name="ln1258">  return 0;</a>
<a name="ln1259">}</a>
<a name="ln1260"> </a>
<a name="ln1261">/* this actually does the work */</a>
<a name="ln1262">int store(dt_imageio_module_storage_t *self, struct dt_imageio_module_data_t *sdata, const int imgid,</a>
<a name="ln1263">          dt_imageio_module_format_t *format, dt_imageio_module_data_t *fdata, const int num, const int total,</a>
<a name="ln1264">          const gboolean high_quality, const gboolean upscale, dt_colorspaces_color_profile_type_t icc_type,</a>
<a name="ln1265">          const gchar *icc_filename, dt_iop_color_intent_t icc_intent)</a>
<a name="ln1266">{</a>
<a name="ln1267">  gint result = 1;</a>
<a name="ln1268">  PicasaContext *ctx = (PicasaContext *)sdata;</a>
<a name="ln1269"> </a>
<a name="ln1270">  const char *ext = format-&gt;extension(fdata);</a>
<a name="ln1271">  char fname[PATH_MAX] = { 0 };</a>
<a name="ln1272">  dt_loc_get_tmp_dir(fname, sizeof(fname));</a>
<a name="ln1273">  g_strlcat(fname, &quot;/darktable.XXXXXX.&quot;, sizeof(fname));</a>
<a name="ln1274">  g_strlcat(fname, ext, sizeof(fname));</a>
<a name="ln1275"> </a>
<a name="ln1276">  gint fd = g_mkstemp(fname);</a>
<a name="ln1277">  if(fd == -1)</a>
<a name="ln1278">  {</a>
<a name="ln1279">    dt_control_log(&quot;failed to create temporary image for google photos export&quot;);</a>
<a name="ln1280">    return 1;</a>
<a name="ln1281">  }</a>
<a name="ln1282">  close(fd);</a>
<a name="ln1283"> </a>
<a name="ln1284">  // get metadata</a>
<a name="ln1285">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1286">  char *title = NULL;</a>
<a name="ln1287">  char *summary = NULL;</a>
<a name="ln1288">  GList *meta_title = NULL;</a>
<a name="ln1289"> </a>
<a name="ln1290">  title = g_path_get_basename(img-&gt;filename);</a>
<a name="ln1291">  (g_strrstr(title, &quot;.&quot;))[0] = '\0'; // Chop extension...</a>
<a name="ln1292"> </a>
<a name="ln1293">  meta_title = dt_metadata_get(img-&gt;id, &quot;Xmp.dc.title&quot;, NULL);</a>
<a name="ln1294">  summary = meta_title != NULL ? meta_title-&gt;data : &quot;&quot;;</a>
<a name="ln1295"> </a>
<a name="ln1296">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln1297"> </a>
<a name="ln1298">  if(dt_imageio_export(imgid, fname, format, fdata, high_quality, upscale, FALSE, icc_type, icc_filename, icc_intent,</a>
<a name="ln1299">                       self, sdata, num, total) != 0)</a>
<a name="ln1300">  {</a>
<a name="ln1301">    g_printerr(&quot;[picasa] could not export to file: `%s'!\n&quot;, fname);</a>
<a name="ln1302">    dt_control_log(_(&quot;could not export to file `%s'!&quot;), fname);</a>
<a name="ln1303">    result = 0;</a>
<a name="ln1304">    goto cleanup;</a>
<a name="ln1305">  }</a>
<a name="ln1306"> </a>
<a name="ln1307">  const char *photoid = picasa_upload_photo_to_album(ctx, ctx-&gt;album_id, fname, title, summary, imgid);</a>
<a name="ln1308">  if(photoid == NULL)</a>
<a name="ln1309">  {</a>
<a name="ln1310">    dt_control_log(_(&quot;unable to export to google photos album&quot;));</a>
<a name="ln1311">    result = 0;</a>
<a name="ln1312">    goto cleanup;</a>
<a name="ln1313">  }</a>
<a name="ln1314"> </a>
<a name="ln1315">cleanup:</a>
<a name="ln1316">  g_unlink(fname);</a>
<a name="ln1317">  g_free(title);</a>
<a name="ln1318">  g_list_free_full(meta_title, &amp;g_free);</a>
<a name="ln1319"> </a>
<a name="ln1320">  if(result)</a>
<a name="ln1321">  {</a>
<a name="ln1322">    // this makes sense only if the export was successful</a>
<a name="ln1323">    dt_control_log(ngettext(&quot;%d/%d exported to google photos album&quot;, &quot;%d/%d exported to google photos album&quot;, num), num, total);</a>
<a name="ln1324">  }</a>
<a name="ln1325">  return 0;</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328">static gboolean _finalize_store(gpointer user_data)</a>
<a name="ln1329">{</a>
<a name="ln1330">  dt_storage_picasa_gui_data_t *ui = (dt_storage_picasa_gui_data_t *)user_data;</a>
<a name="ln1331">  ui_refresh_albums(ui);</a>
<a name="ln1332"> </a>
<a name="ln1333">  return FALSE;</a>
<a name="ln1334">}</a>
<a name="ln1335"> </a>
<a name="ln1336">void finalize_store(struct dt_imageio_module_storage_t *self, dt_imageio_module_data_t *data)</a>
<a name="ln1337">{</a>
<a name="ln1338">  g_main_context_invoke(NULL, _finalize_store, self-&gt;gui_data);</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341"> </a>
<a name="ln1342">size_t params_size(dt_imageio_module_storage_t *self)</a>
<a name="ln1343">{</a>
<a name="ln1344">  return sizeof(PicasaContext) - 8 * sizeof(void *);</a>
<a name="ln1345">}</a>
<a name="ln1346"> </a>
<a name="ln1347">void init(dt_imageio_module_storage_t *self)</a>
<a name="ln1348">{</a>
<a name="ln1349">}</a>
<a name="ln1350">void *get_params(struct dt_imageio_module_storage_t *self)</a>
<a name="ln1351">{</a>
<a name="ln1352">  dt_storage_picasa_gui_data_t *ui = (dt_storage_picasa_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1353">  if(!ui) return NULL; // gui not initialized, CLI mode</a>
<a name="ln1354">  if(ui-&gt;picasa_api == NULL || ui-&gt;picasa_api-&gt;token == NULL)</a>
<a name="ln1355">  {</a>
<a name="ln1356">    return NULL;</a>
<a name="ln1357">  }</a>
<a name="ln1358">  PicasaContext *p = (PicasaContext *)g_malloc0(sizeof(PicasaContext));</a>
<a name="ln1359"> </a>
<a name="ln1360">  p-&gt;curl_ctx = ui-&gt;picasa_api-&gt;curl_ctx;</a>
<a name="ln1361">  p-&gt;json_parser = ui-&gt;picasa_api-&gt;json_parser;</a>
<a name="ln1362">  p-&gt;errmsg = ui-&gt;picasa_api-&gt;errmsg;</a>
<a name="ln1363">  p-&gt;token = g_strdup(ui-&gt;picasa_api-&gt;token);</a>
<a name="ln1364">  p-&gt;refresh_token = g_strdup(ui-&gt;picasa_api-&gt;refresh_token);</a>
<a name="ln1365"> </a>
<a name="ln1366">  int index = gtk_combo_box_get_active(ui-&gt;comboBox_album);</a>
<a name="ln1367">  if(index &lt; 0)</a>
<a name="ln1368">  {</a>
<a name="ln1369">    picasa_api_destroy(p);</a>
<a name="ln1370">    return NULL;</a>
<a name="ln1371">  }</a>
<a name="ln1372">  else if(index == 0)</a>
<a name="ln1373">  {</a>
<a name="ln1374">    g_snprintf(p-&gt;album_id, sizeof(p-&gt;album_id), &quot;default&quot;);</a>
<a name="ln1375"> </a>
<a name="ln1376">    /* Hardcode the album as private, to avoid problems with the old Picasa interface */</a>
<a name="ln1377">    p-&gt;album_permission = 1;</a>
<a name="ln1378">  }</a>
<a name="ln1379">  else</a>
<a name="ln1380">  {</a>
<a name="ln1381">    GtkTreeModel *model = gtk_combo_box_get_model(ui-&gt;comboBox_album);</a>
<a name="ln1382">    GtkTreeIter iter;</a>
<a name="ln1383">    gchar *albumid = NULL;</a>
<a name="ln1384">    gtk_combo_box_get_active_iter(ui-&gt;comboBox_album, &amp;iter);</a>
<a name="ln1385">    gtk_tree_model_get(model, &amp;iter, COMBO_ALBUM_MODEL_ID_COL, &amp;albumid, -1);</a>
<a name="ln1386">    g_snprintf(p-&gt;album_id, sizeof(p-&gt;album_id), &quot;%s&quot;, albumid);</a>
<a name="ln1387">  }</a>
<a name="ln1388"> </a>
<a name="ln1389">  g_snprintf(p-&gt;userid, sizeof(p-&gt;userid), &quot;%s&quot;, ui-&gt;picasa_api-&gt;userid);</a>
<a name="ln1390"> </a>
<a name="ln1391">  // recreate a new context for further usages</a>
<a name="ln1392">  ui-&gt;picasa_api = picasa_api_init();</a>
<a name="ln1393">  ui-&gt;picasa_api-&gt;token = g_strdup(p-&gt;token);</a>
<a name="ln1394">  ui-&gt;picasa_api-&gt;refresh_token = g_strdup(p-&gt;refresh_token);</a>
<a name="ln1395">  g_snprintf(ui-&gt;picasa_api-&gt;userid, sizeof(ui-&gt;picasa_api-&gt;userid), &quot;%s&quot;, p-&gt;userid);</a>
<a name="ln1396"> </a>
<a name="ln1397">  return p;</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400"> </a>
<a name="ln1401">void free_params(struct dt_imageio_module_storage_t *self, dt_imageio_module_data_t *data)</a>
<a name="ln1402">{</a>
<a name="ln1403">  if(!data) return;</a>
<a name="ln1404">  PicasaContext *ctx = (PicasaContext *)data;</a>
<a name="ln1405">  picasa_api_destroy(ctx);</a>
<a name="ln1406">}</a>
<a name="ln1407"> </a>
<a name="ln1408">int set_params(struct dt_imageio_module_storage_t *self, const void *params, const int size)</a>
<a name="ln1409">{</a>
<a name="ln1410">  if(size != self-&gt;params_size(self)) return 1;</a>
<a name="ln1411"> </a>
<a name="ln1412">  PicasaContext *d = (PicasaContext *)params;</a>
<a name="ln1413">  dt_storage_picasa_gui_data_t *g = (dt_storage_picasa_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1414"> </a>
<a name="ln1415">  g_snprintf(g-&gt;picasa_api-&gt;album_id, sizeof(g-&gt;picasa_api-&gt;album_id), &quot;%s&quot;, d-&gt;album_id);</a>
<a name="ln1416">  g_snprintf(g-&gt;picasa_api-&gt;userid, sizeof(g-&gt;picasa_api-&gt;userid), &quot;%s&quot;, d-&gt;userid);</a>
<a name="ln1417"> </a>
<a name="ln1418">  GtkListStore *model = GTK_LIST_STORE(gtk_combo_box_get_model(g-&gt;comboBox_username));</a>
<a name="ln1419">  GtkTreeIter iter;</a>
<a name="ln1420">  gboolean r;</a>
<a name="ln1421">  gchar *uid = NULL;</a>
<a name="ln1422">  gchar *albumid = NULL;</a>
<a name="ln1423"> </a>
<a name="ln1424">  for(r = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &amp;iter); r == TRUE;</a>
<a name="ln1425">      r = gtk_tree_model_iter_next(GTK_TREE_MODEL(model), &amp;iter))</a>
<a name="ln1426">  {</a>
<a name="ln1427">    gtk_tree_model_get(GTK_TREE_MODEL(model), &amp;iter, COMBO_USER_MODEL_ID_COL, &amp;uid, -1);</a>
<a name="ln1428">    if(g_strcmp0(uid, g-&gt;picasa_api-&gt;userid) == 0)</a>
<a name="ln1429">    {</a>
<a name="ln1430">      gtk_combo_box_set_active_iter(g-&gt;comboBox_username, &amp;iter);</a>
<a name="ln1431">      break;</a>
<a name="ln1432">    }</a>
<a name="ln1433">  }</a>
<a name="ln1434">  g_free(uid);</a>
<a name="ln1435"> </a>
<a name="ln1436">  model = GTK_LIST_STORE(gtk_combo_box_get_model(g-&gt;comboBox_album));</a>
<a name="ln1437">  for(r = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &amp;iter); r == TRUE;</a>
<a name="ln1438">      r = gtk_tree_model_iter_next(GTK_TREE_MODEL(model), &amp;iter))</a>
<a name="ln1439">  {</a>
<a name="ln1440">    gtk_tree_model_get(GTK_TREE_MODEL(model), &amp;iter, COMBO_ALBUM_MODEL_ID_COL, &amp;albumid, -1);</a>
<a name="ln1441">    if(g_strcmp0(albumid, g-&gt;picasa_api-&gt;album_id) == 0)</a>
<a name="ln1442">    {</a>
<a name="ln1443">      gtk_combo_box_set_active_iter(g-&gt;comboBox_album, &amp;iter);</a>
<a name="ln1444">      break;</a>
<a name="ln1445">    }</a>
<a name="ln1446">  }</a>
<a name="ln1447">  g_free(albumid);</a>
<a name="ln1448"> </a>
<a name="ln1449">  return 0;</a>
<a name="ln1450">}</a>
<a name="ln1451"> </a>
<a name="ln1452">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1453">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1454">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="306"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="319"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'response' class object.</p></div>
<div class="balloon" rel="371"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'response' class object.</p></div>
<div class="balloon" rel="486"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The 'memcpy' function doesn't copy the whole string. Use 'strcpy / strcpy_s' function to preserve terminal null.</p></div>
<div class="balloon" rel="500"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'headers' class object.</p></div>
<div class="balloon" rel="609"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'headers' class object.</p></div>
<div class="balloon" rel="779"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'token' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="959"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'albumList' pointer was used unsafely after it was verified against nullptr. Check lines: 953, 959.</p></div>
<div class="balloon" rel="959"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'albumList' pointer was utilized before it was verified against nullptr. Check lines: 959, 961.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
