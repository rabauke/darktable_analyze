
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012 Pierre Lamot</a>
<a name="ln4">    copyright (c) 2013-2014 Jose Carlos Garcia Sogo</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/image.h&quot;</a>
<a name="ln22">#include &quot;common/image_cache.h&quot;</a>
<a name="ln23">#include &quot;common/imageio.h&quot;</a>
<a name="ln24">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln25">#include &quot;common/metadata.h&quot;</a>
<a name="ln26">#include &quot;common/pwstorage/pwstorage.h&quot;</a>
<a name="ln27">#include &quot;common/tags.h&quot;</a>
<a name="ln28">#include &quot;control/conf.h&quot;</a>
<a name="ln29">#include &quot;control/control.h&quot;</a>
<a name="ln30">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln31">#include &quot;gui/gtk.h&quot;</a>
<a name="ln32">#include &quot;imageio/storage/imageio_storage_api.h&quot;</a>
<a name="ln33">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln34">#include &quot;osx/osx.h&quot;</a>
<a name="ln35">#endif</a>
<a name="ln36">#include &lt;curl/curl.h&gt;</a>
<a name="ln37">#include &lt;json-glib/json-glib.h&gt;</a>
<a name="ln38">#include &lt;libxml/parser.h&gt;</a>
<a name="ln39">#include &lt;stdio.h&gt;</a>
<a name="ln40">#include &lt;stdlib.h&gt;</a>
<a name="ln41">#include &lt;unistd.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">DT_MODULE(2)</a>
<a name="ln44"> </a>
<a name="ln45">#define GOOGLE_WS_BASE_URL &quot;https://accounts.google.com/&quot;</a>
<a name="ln46">#define GOOGLE_API_BASE_URL &quot;https://www.googleapis.com/&quot;</a>
<a name="ln47">#define GOOGLE_API_KEY &quot;428088086479.apps.googleusercontent.com&quot;</a>
<a name="ln48">#define GOOGLE_API_SECRET &quot;tIIL4FUs46Nc9nQWKeg3H_Hy&quot;</a>
<a name="ln49">#define GOOGLE_URI &quot;urn:ietf:wg:oauth:2.0:oob&quot;</a>
<a name="ln50">#define GOOGLE_PICASA &quot;https://picasaweb.google.com/&quot;</a>
<a name="ln51"> </a>
<a name="ln52">#define GOOGLE_IMAGE_MAX_SIZE 960</a>
<a name="ln53"> </a>
<a name="ln54">#define MSGCOLOR_RED &quot;#e07f7f&quot;</a>
<a name="ln55">#define MSGCOLOR_GREEN &quot;#7fe07f&quot;</a>
<a name="ln56"> </a>
<a name="ln57">/** Authenticate against google picasa service*/</a>
<a name="ln58">typedef struct _buffer_t</a>
<a name="ln59">{</a>
<a name="ln60">  char *data;</a>
<a name="ln61">  size_t size;</a>
<a name="ln62">  size_t offset;</a>
<a name="ln63">} _buffer_t;</a>
<a name="ln64"> </a>
<a name="ln65">typedef enum ComboUserModel</a>
<a name="ln66">{</a>
<a name="ln67">  COMBO_USER_MODEL_NAME_COL = 0,</a>
<a name="ln68">  COMBO_USER_MODEL_TOKEN_COL,</a>
<a name="ln69">  COMBO_USER_MODEL_REFRESH_TOKEN_COL,</a>
<a name="ln70">  COMBO_USER_MODEL_ID_COL,</a>
<a name="ln71">  COMBO_USER_MODEL_NB_COL</a>
<a name="ln72">} ComboUserModel;</a>
<a name="ln73"> </a>
<a name="ln74">typedef enum ComboAlbumModel</a>
<a name="ln75">{</a>
<a name="ln76">  COMBO_ALBUM_MODEL_NAME_COL = 0,</a>
<a name="ln77">  COMBO_ALBUM_MODEL_ID_COL,</a>
<a name="ln78">  COMBO_ALBUM_MODEL_NB_COL</a>
<a name="ln79">} ComboAlbumModel;</a>
<a name="ln80"> </a>
<a name="ln81">typedef enum PicasaAlbumPrivacyPolicy</a>
<a name="ln82">{</a>
<a name="ln83">  PICASA_ALBUM_PRIVACY_PUBLIC,</a>
<a name="ln84">  PICASA_ALBUM_PRIVACY_PRIVATE,</a>
<a name="ln85">} PicasaAlbumPrivacyPolicy;</a>
<a name="ln86"> </a>
<a name="ln87">/**</a>
<a name="ln88"> * Represents information about an album</a>
<a name="ln89"> */</a>
<a name="ln90">typedef struct PicasaAlbum</a>
<a name="ln91">{</a>
<a name="ln92">  gchar *id;</a>
<a name="ln93">  gchar *name;</a>
<a name="ln94">  PicasaAlbumPrivacyPolicy privacy;</a>
<a name="ln95">} PicasaAlbum;</a>
<a name="ln96"> </a>
<a name="ln97">static PicasaAlbum *picasa_album_init()</a>
<a name="ln98">{</a>
<a name="ln99">  return (PicasaAlbum *)g_malloc0(sizeof(PicasaAlbum));</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">static void picasa_album_destroy(PicasaAlbum *album)</a>
<a name="ln103">{</a>
<a name="ln104">  if(album == NULL) return;</a>
<a name="ln105">  g_free(album-&gt;id);</a>
<a name="ln106">  g_free(album-&gt;name);</a>
<a name="ln107">  g_free(album);</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">/**</a>
<a name="ln111"> * Represents information about an account</a>
<a name="ln112"> */</a>
<a name="ln113">typedef struct PicasaAccountInfo</a>
<a name="ln114">{</a>
<a name="ln115">  gchar *id;</a>
<a name="ln116">  gchar *username;</a>
<a name="ln117">  gchar *token;</a>
<a name="ln118">  gchar *refresh_token;</a>
<a name="ln119">} PicasaAccountInfo;</a>
<a name="ln120"> </a>
<a name="ln121">static PicasaAccountInfo *picasa_account_info_init()</a>
<a name="ln122">{</a>
<a name="ln123">  return (PicasaAccountInfo *)g_malloc0(sizeof(PicasaAccountInfo));</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">static void picasa_account_info_destroy(PicasaAccountInfo *account)</a>
<a name="ln127">{</a>
<a name="ln128">  if(account == NULL) return;</a>
<a name="ln129">  g_free(account-&gt;id);</a>
<a name="ln130">  g_free(account-&gt;username);</a>
<a name="ln131">  g_free(account);</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">typedef struct PicasaContext</a>
<a name="ln135">{</a>
<a name="ln136">  gchar album_id[1024];</a>
<a name="ln137">  gchar userid[1024];</a>
<a name="ln138"> </a>
<a name="ln139">  int album_permission;</a>
<a name="ln140"> </a>
<a name="ln141">  /// curl context</a>
<a name="ln142">  CURL *curl_ctx;</a>
<a name="ln143">  /// Json parser context</a>
<a name="ln144">  JsonParser *json_parser;</a>
<a name="ln145"> </a>
<a name="ln146">  GString *errmsg;</a>
<a name="ln147"> </a>
<a name="ln148">  /// authorization token</a>
<a name="ln149">  gchar *token;</a>
<a name="ln150">  gchar *refresh_token;</a>
<a name="ln151">} PicasaContext;</a>
<a name="ln152"> </a>
<a name="ln153">typedef struct dt_storage_picasa_gui_data_t</a>
<a name="ln154">{</a>
<a name="ln155">  // == ui elements ==</a>
<a name="ln156">  GtkLabel *label_status;</a>
<a name="ln157"> </a>
<a name="ln158">  GtkComboBox *comboBox_username;</a>
<a name="ln159">  GtkButton *button_login;</a>
<a name="ln160"> </a>
<a name="ln161">  GtkDarktableButton *dtbutton_refresh_album;</a>
<a name="ln162">  GtkComboBox *comboBox_album;</a>
<a name="ln163"> </a>
<a name="ln164">  // == context ==</a>
<a name="ln165">  gboolean connected;</a>
<a name="ln166">  PicasaContext *picasa_api;</a>
<a name="ln167">} dt_storage_picasa_gui_data_t;</a>
<a name="ln168"> </a>
<a name="ln169"> </a>
<a name="ln170">static PicasaContext *picasa_api_init()</a>
<a name="ln171">{</a>
<a name="ln172">  PicasaContext *ctx = (PicasaContext *)g_malloc0(sizeof(PicasaContext));</a>
<a name="ln173">  ctx-&gt;curl_ctx = curl_easy_init();</a>
<a name="ln174">  ctx-&gt;errmsg = g_string_new(&quot;&quot;);</a>
<a name="ln175">  ctx-&gt;json_parser = json_parser_new();</a>
<a name="ln176">  return ctx;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">static void picasa_api_destroy(PicasaContext *ctx)</a>
<a name="ln180">{</a>
<a name="ln181">  if(ctx == NULL) return;</a>
<a name="ln182">  curl_easy_cleanup(ctx-&gt;curl_ctx);</a>
<a name="ln183">  g_free(ctx-&gt;token);</a>
<a name="ln184">  g_free(ctx-&gt;refresh_token);</a>
<a name="ln185">  g_object_unref(ctx-&gt;json_parser);</a>
<a name="ln186">  g_string_free(ctx-&gt;errmsg, TRUE);</a>
<a name="ln187">  g_free(ctx);</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190"> </a>
<a name="ln191">typedef struct dt_storage_picasa_param_t</a>
<a name="ln192">{</a>
<a name="ln193">  gint64 hash;</a>
<a name="ln194">  PicasaContext *picasa_ctx;</a>
<a name="ln195">} dt_storage_picasa_param_t;</a>
<a name="ln196"> </a>
<a name="ln197"> </a>
<a name="ln198">static gchar *picasa_get_user_refresh_token(PicasaContext *ctx);</a>
<a name="ln199"> </a>
<a name="ln200">//////////////////////////// curl requests related functions</a>
<a name="ln201"> </a>
<a name="ln202">/** Grow and fill _buffer_t with received data... */</a>
<a name="ln203">static size_t _picasa_api_buffer_write_func(void *ptr, size_t size, size_t nmemb, void *stream)</a>
<a name="ln204">{</a>
<a name="ln205">  _buffer_t *buffer = (_buffer_t *)stream;</a>
<a name="ln206">  char *newdata = g_malloc0(buffer-&gt;size + nmemb + 1);</a>
<a name="ln207">  if(buffer-&gt;data != NULL) memcpy(newdata, buffer-&gt;data, buffer-&gt;size);</a>
<a name="ln208">  memcpy(newdata + buffer-&gt;size, ptr, nmemb);</a>
<a name="ln209">  g_free(buffer-&gt;data);</a>
<a name="ln210">  buffer-&gt;data = newdata;</a>
<a name="ln211">  buffer-&gt;size += nmemb;</a>
<a name="ln212">  return nmemb;</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">static size_t _picasa_api_buffer_read_func(void *ptr, size_t size, size_t nmemb, void *stream)</a>
<a name="ln216">{</a>
<a name="ln217">  _buffer_t *buffer = (_buffer_t *)stream;</a>
<a name="ln218">  size_t dsize = 0;</a>
<a name="ln219">  if((buffer-&gt;size - buffer-&gt;offset) &gt; nmemb)</a>
<a name="ln220">    dsize = nmemb;</a>
<a name="ln221">  else</a>
<a name="ln222">    dsize = (buffer-&gt;size - buffer-&gt;offset);</a>
<a name="ln223"> </a>
<a name="ln224">  memcpy(ptr, buffer-&gt;data + buffer-&gt;offset, dsize);</a>
<a name="ln225">  buffer-&gt;offset += dsize;</a>
<a name="ln226">  return dsize;</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">static size_t curl_write_data_cb(void *ptr, size_t size, size_t nmemb, void *data)</a>
<a name="ln230">{</a>
<a name="ln231">  GString *string = (GString *)data;</a>
<a name="ln232">  g_string_append_len(string, ptr, size * nmemb);</a>
<a name="ln233">#ifdef picasa_EXTRA_VERBOSE</a>
<a name="ln234">  g_printf(&quot;server reply: %s\n&quot;, string-&gt;str);</a>
<a name="ln235">#endif</a>
<a name="ln236">  return size * nmemb;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">static JsonObject *picasa_parse_response(PicasaContext *ctx, GString *response)</a>
<a name="ln240">{</a>
<a name="ln241">  GError *error = NULL;</a>
<a name="ln242">  gboolean ret = json_parser_load_from_data(ctx-&gt;json_parser, response-&gt;str, response-&gt;len, &amp;error);</a>
<a name="ln243">  g_return_val_if_fail((ret), NULL);</a>
<a name="ln244"> </a>
<a name="ln245">  JsonNode *root = json_parser_get_root(ctx-&gt;json_parser);</a>
<a name="ln246">  // we should always have a dict</a>
<a name="ln247">  g_return_val_if_fail((json_node_get_node_type(root) == JSON_NODE_OBJECT), NULL);</a>
<a name="ln248"> </a>
<a name="ln249">  JsonObject *rootdict = json_node_get_object(root);</a>
<a name="ln250">  if(json_object_has_member(rootdict, &quot;error&quot;))</a>
<a name="ln251">  {</a>
<a name="ln252">    JsonObject *errorstruct = json_object_get_object_member(rootdict, &quot;error&quot;);</a>
<a name="ln253">    g_return_val_if_fail((errorstruct != NULL), NULL);</a>
<a name="ln254">    const gchar *errormessage = json_object_get_string_member(errorstruct, &quot;message&quot;);</a>
<a name="ln255">    g_return_val_if_fail((errormessage != NULL), NULL);</a>
<a name="ln256">    g_string_assign(ctx-&gt;errmsg, errormessage);</a>
<a name="ln257">    return NULL;</a>
<a name="ln258">  }</a>
<a name="ln259"> </a>
<a name="ln260">  return rootdict;</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263"> </a>
<a name="ln264">static void picasa_query_get_add_url_arguments(GString *key, GString *value, GString *url)</a>
<a name="ln265">{</a>
<a name="ln266">  g_string_append(url, &quot;&amp;&quot;);</a>
<a name="ln267">  g_string_append(url, key-&gt;str);</a>
<a name="ln268">  g_string_append(url, &quot;=&quot;);</a>
<a name="ln269">  g_string_append(url, value-&gt;str);</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">/**</a>
<a name="ln273"> * perform a GET request on picasa/google api</a>
<a name="ln274"> *</a>
<a name="ln275"> * @note use this one to read information (user info, existing albums, ...)</a>
<a name="ln276"> *</a>
<a name="ln277"> * @param ctx picasa context (token field must be set)</a>
<a name="ln278"> * @param method the method to call on the google API, the methods should not start with '/' example:</a>
<a name="ln279"> *&quot;me/albums&quot;</a>
<a name="ln280"> * @param args hashtable of the arguments to be added to the requests, must be in the form key (string) =</a>
<a name="ln281"> *value (string)</a>
<a name="ln282"> * @returns NULL if the request fails, or a JsonObject of the reply</a>
<a name="ln283"> */</a>
<a name="ln284">static JsonObject *picasa_query_get(PicasaContext *ctx, const gchar *method, GHashTable *args, gboolean picasa)</a>
<a name="ln285">{</a>
<a name="ln286">  g_return_val_if_fail(ctx != NULL, NULL);</a>
<a name="ln287">  g_return_val_if_fail(ctx-&gt;token != NULL, NULL);</a>
<a name="ln288">  // build the query</a>
<a name="ln289">  GString *url;</a>
<a name="ln290">  if(picasa == TRUE)</a>
<a name="ln291">    url = g_string_new(GOOGLE_PICASA);</a>
<a name="ln292">  else</a>
<a name="ln293">    url = g_string_new(GOOGLE_API_BASE_URL);</a>
<a name="ln294"> </a>
<a name="ln295">  g_string_append(url, method);</a>
<a name="ln296"> </a>
<a name="ln297">  if(picasa == TRUE)</a>
<a name="ln298">  {</a>
<a name="ln299">    g_string_append(url, &quot;?alt=json&amp;access_token=&quot;);</a>
<a name="ln300">    g_string_append(url, ctx-&gt;token);</a>
<a name="ln301">  }</a>
<a name="ln302">  else</a>
<a name="ln303">  {</a>
<a name="ln304">    g_string_append(url, &quot;?alt=json&amp;access_token=&quot;);</a>
<a name="ln305">    g_string_append(url, ctx-&gt;token);</a>
<a name="ln306">  }</a>
<a name="ln307">  if(args != NULL) g_hash_table_foreach(args, (GHFunc)picasa_query_get_add_url_arguments, url);</a>
<a name="ln308"> </a>
<a name="ln309">  // send the request</a>
<a name="ln310">  GString *response = g_string_new(&quot;&quot;);</a>
<a name="ln311">  curl_easy_reset(ctx-&gt;curl_ctx);</a>
<a name="ln312">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_URL, url-&gt;str);</a>
<a name="ln313">#ifdef picasa_EXTRA_VERBOSE</a>
<a name="ln314">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_VERBOSE, 2);</a>
<a name="ln315">#endif</a>
<a name="ln316">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEFUNCTION, curl_write_data_cb);</a>
<a name="ln317">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_SSL_VERIFYPEER, FALSE);</a>
<a name="ln318">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEDATA, response);</a>
<a name="ln319">  int res = curl_easy_perform(ctx-&gt;curl_ctx);</a>
<a name="ln320"> </a>
<a name="ln321">  if(res != CURLE_OK)</a>
<a name="ln322">  {</a>
<a name="ln323">    g_string_free(url, TRUE);</a>
<a name="ln324">    g_string_free(response, TRUE);</a>
<a name="ln325">    return NULL;</a>
<a name="ln326">  }</a>
<a name="ln327">  // parse the response</a>
<a name="ln328">  JsonObject *respobj = picasa_parse_response(ctx, response);</a>
<a name="ln329"> </a>
<a name="ln330">  g_string_free(response, TRUE);</a>
<a name="ln331">  g_string_free(url, TRUE);</a>
<a name="ln332">  return respobj;</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335">typedef struct</a>
<a name="ln336">{</a>
<a name="ln337">  struct curl_httppost *formpost;</a>
<a name="ln338">  struct curl_httppost *lastptr;</a>
<a name="ln339">} HttppostFormList;</a>
<a name="ln340"> </a>
<a name="ln341"> </a>
<a name="ln342">/**</a>
<a name="ln343"> * perform a POST request on google api to get the auth token</a>
<a name="ln344"> *</a>
<a name="ln345"> * @param ctx picasa context (token field must be set)</a>
<a name="ln346"> * @param method the method to call on the google API, the methods should not start with '/' example:</a>
<a name="ln347"> *&quot;me/albums&quot;</a>
<a name="ln348"> * @param args hashtable of the arguments to be added to the requests, might be null if none</a>
<a name="ln349"> * @returns NULL if the request fails, or a JsonObject of the reply</a>
<a name="ln350"> */</a>
<a name="ln351"> </a>
<a name="ln352">static JsonObject *picasa_query_post_auth(PicasaContext *ctx, const gchar *method, gchar *args)</a>
<a name="ln353">{</a>
<a name="ln354">  g_return_val_if_fail(ctx != NULL, NULL);</a>
<a name="ln355"> </a>
<a name="ln356">  GString *url = NULL;</a>
<a name="ln357"> </a>
<a name="ln358">  url = g_string_new(GOOGLE_WS_BASE_URL);</a>
<a name="ln359">  g_string_append(url, method);</a>
<a name="ln360"> </a>
<a name="ln361">  // send the requests</a>
<a name="ln362">  GString *response = g_string_new(&quot;&quot;);</a>
<a name="ln363">  curl_easy_reset(ctx-&gt;curl_ctx);</a>
<a name="ln364">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_URL, url-&gt;str);</a>
<a name="ln365">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_POST, 1);</a>
<a name="ln366">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_COPYPOSTFIELDS, args);</a>
<a name="ln367">#ifdef picasa_EXTRA_VERBOSE</a>
<a name="ln368">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_VERBOSE, 2);</a>
<a name="ln369">#endif</a>
<a name="ln370">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_SSL_VERIFYPEER, FALSE);</a>
<a name="ln371">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEFUNCTION, curl_write_data_cb);</a>
<a name="ln372">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEDATA, response);</a>
<a name="ln373"> </a>
<a name="ln374">  int res = curl_easy_perform(ctx-&gt;curl_ctx);</a>
<a name="ln375">  g_string_free(url, TRUE);</a>
<a name="ln376">  if(res != CURLE_OK) return NULL;</a>
<a name="ln377">  // parse the response</a>
<a name="ln378">  JsonObject *respobj = picasa_parse_response(ctx, response);</a>
<a name="ln379">  g_string_free(response, TRUE);</a>
<a name="ln380">  return respobj;</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">//////////////////////////// picasa api functions</a>
<a name="ln384"> </a>
<a name="ln385">/**</a>
<a name="ln386"> * @returns TRUE if the current token is valid</a>
<a name="ln387"> */</a>
<a name="ln388">static gboolean picasa_test_auth_token(PicasaContext *ctx)</a>
<a name="ln389">{</a>
<a name="ln390">  gchar *access_token = NULL;</a>
<a name="ln391">  access_token = picasa_get_user_refresh_token(ctx);</a>
<a name="ln392"> </a>
<a name="ln393">  if(access_token != NULL) ctx-&gt;token = access_token;</a>
<a name="ln394"> </a>
<a name="ln395">  return access_token != NULL;</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">/**</a>
<a name="ln399"> * @return a GList of PicasaAlbums associated to the user</a>
<a name="ln400"> */</a>
<a name="ln401">static GList *picasa_get_album_list(PicasaContext *ctx, gboolean *ok)</a>
<a name="ln402">{</a>
<a name="ln403">  if(!ok) return NULL;</a>
<a name="ln404"> </a>
<a name="ln405">  *ok = TRUE;</a>
<a name="ln406">  GList *album_list = NULL;</a>
<a name="ln407"> </a>
<a name="ln408">  JsonObject *reply = picasa_query_get(ctx, &quot;data/feed/api/user/default&quot;, NULL, TRUE);</a>
<a name="ln409">  if(reply == NULL) goto error;</a>
<a name="ln410"> </a>
<a name="ln411">  JsonObject *feed = json_object_get_object_member(reply, &quot;feed&quot;);</a>
<a name="ln412">  if(feed == NULL) goto error;</a>
<a name="ln413"> </a>
<a name="ln414">  JsonArray *jsalbums = json_object_get_array_member(feed, &quot;entry&quot;);</a>
<a name="ln415"> </a>
<a name="ln416">  guint i;</a>
<a name="ln417">  for(i = 0; i &lt; json_array_get_length(jsalbums); i++)</a>
<a name="ln418">  {</a>
<a name="ln419">    JsonObject *obj = json_array_get_object_element(jsalbums, i);</a>
<a name="ln420">    if(obj == NULL) continue;</a>
<a name="ln421"> </a>
<a name="ln422">    PicasaAlbum *album = picasa_album_init();</a>
<a name="ln423">    if(album == NULL) goto error;</a>
<a name="ln424"> </a>
<a name="ln425">    JsonObject *jsid = json_object_get_object_member(obj, &quot;gphoto$id&quot;);</a>
<a name="ln426">    JsonObject *jstitle = json_object_get_object_member(obj, &quot;title&quot;);</a>
<a name="ln427"> </a>
<a name="ln428">    const char *id = json_object_get_string_member(jsid, &quot;$t&quot;);</a>
<a name="ln429">    const char *name = json_object_get_string_member(jstitle, &quot;$t&quot;);</a>
<a name="ln430">    if(id == NULL || name == NULL)</a>
<a name="ln431">    {</a>
<a name="ln432">      picasa_album_destroy(album);</a>
<a name="ln433">      goto error;</a>
<a name="ln434">    }</a>
<a name="ln435">    album-&gt;id = g_strdup(id);</a>
<a name="ln436">    album-&gt;name = g_strdup(name);</a>
<a name="ln437">    album_list = g_list_append(album_list, album);</a>
<a name="ln438">  }</a>
<a name="ln439">  return album_list;</a>
<a name="ln440"> </a>
<a name="ln441">error:</a>
<a name="ln442">  *ok = FALSE;</a>
<a name="ln443">  g_list_free_full(album_list, (GDestroyNotify)picasa_album_destroy);</a>
<a name="ln444">  return NULL;</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447">/**</a>
<a name="ln448"> * @see https://developers.google.com/picasa-web/docs/2.0/developers_guide_protocol#PostPhotos</a>
<a name="ln449"> * @return the id of the uploaded photo</a>
<a name="ln450"> */</a>
<a name="ln451">static const gchar *picasa_upload_photo_to_album(PicasaContext *ctx, gchar *albumid, gchar *fname,</a>
<a name="ln452">                                                 gchar *title, gchar *summary, const int imgid)</a>
<a name="ln453">{</a>
<a name="ln454">  _buffer_t buffer = { 0 };</a>
<a name="ln455">  gchar *photo_id = NULL;</a>
<a name="ln456"> </a>
<a name="ln457">  char uri[4096] = { 0 };</a>
<a name="ln458"> </a>
<a name="ln459">  // Open the temp file and read image to memory</a>
<a name="ln460">  GMappedFile *imgfile = g_mapped_file_new(fname, FALSE, NULL);</a>
<a name="ln461">  const int size = g_mapped_file_get_length(imgfile);</a>
<a name="ln462">  gchar *data = g_mapped_file_get_contents(imgfile);</a>
<a name="ln463"> </a>
<a name="ln464">  gchar *entry = g_markup_printf_escaped(&quot;&lt;entry xmlns='http://www.w3.org/2005/Atom'&gt;\n&quot;</a>
<a name="ln465">                                         &quot;&lt;title&gt;%s&lt;/title&gt;\n&quot;</a>
<a name="ln466">                                         &quot;&lt;summary&gt;%s&lt;/summary&gt;\n&quot;</a>
<a name="ln467">                                         &quot;&lt;category scheme=\&quot;http://schemas.google.com/g/2005#kind\&quot;\n&quot;</a>
<a name="ln468">                                         &quot; term=\&quot;http://schemas.google.com/photos/2007#photo\&quot;/&gt;&quot;</a>
<a name="ln469">                                         &quot;&lt;/entry&gt;&quot;,</a>
<a name="ln470">                                         title, summary);</a>
<a name="ln471"> </a>
<a name="ln472">  gchar *authHeader = NULL;</a>
<a name="ln473">  authHeader = dt_util_dstrcat(authHeader, &quot;Authorization: OAuth %s&quot;, ctx-&gt;token);</a>
<a name="ln474"> </a>
<a name="ln475">  // Hack for nonform multipart post...</a>
<a name="ln476">  gchar mpart1[4096] = { 0 };</a>
<a name="ln477">  gchar *mpart_format = &quot;\nMedia multipart posting\n--END_OF_PART\nContent-Type: &quot;</a>
<a name="ln478">                        &quot;application/atom+xml\n\n%s\n--END_OF_PART\nContent-Type: image/jpeg\n\n&quot;;</a>
<a name="ln479">  snprintf(mpart1, sizeof(mpart1), mpart_format, entry);</a>
<a name="ln480">  g_free(entry);</a>
<a name="ln481"> </a>
<a name="ln482">  const int mpart1size = strlen(mpart1);</a>
<a name="ln483">  const int postdata_length = mpart1size + size + strlen(&quot;\n--END_OF_PART--&quot;);</a>
<a name="ln484">  gchar *postdata = g_malloc(postdata_length);</a>
<a name="ln485">  memcpy(postdata, mpart1, mpart1size);</a>
<a name="ln486">  memcpy(postdata + mpart1size, data, size);</a>
<a name="ln487">  memcpy(postdata + mpart1size + size, &quot;\n--END_OF_PART--&quot;, strlen(&quot;\n--END_OF_PART--&quot;));</a>
<a name="ln488"> </a>
<a name="ln489">  g_mapped_file_unref(imgfile);</a>
<a name="ln490"> </a>
<a name="ln491">  struct curl_slist *headers = NULL;</a>
<a name="ln492">  headers = curl_slist_append(headers, &quot;Content-Type: multipart/related; boundary=\&quot;END_OF_PART\&quot;&quot;);</a>
<a name="ln493">  headers = curl_slist_append(headers, &quot;MIME-version: 1.0&quot;);</a>
<a name="ln494">  headers = curl_slist_append(headers, &quot;GData-Version: 3&quot;);</a>
<a name="ln495">  headers = curl_slist_append(headers, authHeader);</a>
<a name="ln496"> </a>
<a name="ln497">  snprintf(uri, sizeof(uri), &quot;https://picasaweb.google.com/data/feed/api/user/default/albumid/%s&quot;, albumid);</a>
<a name="ln498">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_URL, uri);</a>
<a name="ln499">#ifdef picasa_EXTRA_VERBOSE</a>
<a name="ln500">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_VERBOSE, 2);</a>
<a name="ln501">#endif</a>
<a name="ln502">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_HTTPHEADER, headers);</a>
<a name="ln503">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_UPLOAD, 0); // A post request !</a>
<a name="ln504">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_POST, 1);</a>
<a name="ln505">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_FOLLOWLOCATION, 1);</a>
<a name="ln506">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_POSTFIELDS, postdata);</a>
<a name="ln507">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_POSTFIELDSIZE, postdata_length);</a>
<a name="ln508">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEFUNCTION, _picasa_api_buffer_write_func);</a>
<a name="ln509">  curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEDATA, &amp;buffer);</a>
<a name="ln510"> </a>
<a name="ln511">  int res = curl_easy_perform(ctx-&gt;curl_ctx);</a>
<a name="ln512"> </a>
<a name="ln513">  curl_slist_free_all(headers);</a>
<a name="ln514"> </a>
<a name="ln515">  if(res != CURLE_OK)</a>
<a name="ln516">  {</a>
<a name="ln517">    fprintf(stderr, &quot;[picasa] error uploading photo: %s\n&quot;, curl_easy_strerror(res));</a>
<a name="ln518">    return NULL;</a>
<a name="ln519">  }</a>
<a name="ln520"> </a>
<a name="ln521">#ifdef picasa_EXTRA_VERBOSE</a>
<a name="ln522">  printf(&quot;Uploading: %s\n&quot;, buffer.data);</a>
<a name="ln523">#endif</a>
<a name="ln524"> </a>
<a name="ln525">  long result;</a>
<a name="ln526">  curl_easy_getinfo(ctx-&gt;curl_ctx, CURLINFO_RESPONSE_CODE, &amp;result);</a>
<a name="ln527"> </a>
<a name="ln528">  // If we want to add tags let's do...</a>
<a name="ln529">  if(result == 201 &amp;&amp; imgid &gt; 0)</a>
<a name="ln530">  {</a>
<a name="ln531">    // Image was created , fine.. and result have the fully created photo xml entry..</a>
<a name="ln532">    // Let's perform an update of the photos keywords with tags passed along to this function..</a>
<a name="ln533">    // and use picasa photo update api to add keywords to the photo...</a>
<a name="ln534"> </a>
<a name="ln535">    // Build the keywords content string</a>
<a name="ln536">    GList *keywords_list = dt_tag_get_list(imgid);</a>
<a name="ln537">    gchar *keywords = dt_util_glist_to_str(&quot;,&quot;, keywords_list);</a>
<a name="ln538"> </a>
<a name="ln539">    xmlDocPtr doc;</a>
<a name="ln540">    xmlNodePtr entryNode;</a>
<a name="ln541">    // Parse xml document</a>
<a name="ln542">    if((doc = xmlParseDoc((xmlChar *)buffer.data)) == NULL) return 0;</a>
<a name="ln543">    entryNode = xmlDocGetRootElement(doc);</a>
<a name="ln544">    if(!xmlStrcmp(entryNode-&gt;name, (const xmlChar *)&quot;entry&quot;))</a>
<a name="ln545">    {</a>
<a name="ln546">      // Let's get the gd:etag attribute of entry...</a>
<a name="ln547">      // For now, we force update using &quot;If-Match: *&quot;</a>
<a name="ln548">      /*</a>
<a name="ln549">        if( !xmlHasProp(entryNode, (const xmlChar*)&quot;gd:etag&quot;) ) return 0;</a>
<a name="ln550">        xmlChar *etag = xmlGetProp(entryNode,(const xmlChar*)&quot;gd:etag&quot;);</a>
<a name="ln551">      */</a>
<a name="ln552"> </a>
<a name="ln553">      gchar *updateUri = NULL;</a>
<a name="ln554">      xmlNodePtr entryChilds = entryNode-&gt;xmlChildrenNode;</a>
<a name="ln555">      if(entryChilds != NULL)</a>
<a name="ln556">      {</a>
<a name="ln557">        do</a>
<a name="ln558">        {</a>
<a name="ln559">          if((!xmlStrcmp(entryChilds-&gt;name, (const xmlChar *)&quot;id&quot;)))</a>
<a name="ln560">          {</a>
<a name="ln561">            // Get the photo id used in uri for update</a>
<a name="ln562">            xmlChar *id = xmlNodeListGetString(doc, entryChilds-&gt;xmlChildrenNode, 1);</a>
<a name="ln563">            if(xmlStrncmp(id, (const xmlChar *)&quot;http://&quot;, 7)) photo_id = g_strdup((const char *)id);</a>
<a name="ln564">            xmlFree(id);</a>
<a name="ln565">          }</a>
<a name="ln566">          else if((!xmlStrcmp(entryChilds-&gt;name, (const xmlChar *)&quot;group&quot;)))</a>
<a name="ln567">          {</a>
<a name="ln568">            // Got the media:group entry lets find the child media:keywords</a>
<a name="ln569">            xmlNodePtr mediaChilds = entryChilds-&gt;xmlChildrenNode;</a>
<a name="ln570">            if(mediaChilds != NULL)</a>
<a name="ln571">            {</a>
<a name="ln572">              do</a>
<a name="ln573">              {</a>
<a name="ln574">                // Got the keywords tag, let's set the tags</a>
<a name="ln575">                if((!xmlStrcmp(mediaChilds-&gt;name, (const xmlChar *)&quot;keywords&quot;)))</a>
<a name="ln576">                  xmlNodeSetContent(mediaChilds, (xmlChar *)keywords);</a>
<a name="ln577">              } while((mediaChilds = mediaChilds-&gt;next) != NULL);</a>
<a name="ln578">            }</a>
<a name="ln579">          }</a>
<a name="ln580">          else if((!xmlStrcmp(entryChilds-&gt;name, (const xmlChar *)&quot;link&quot;)))</a>
<a name="ln581">          {</a>
<a name="ln582">            xmlChar *rel = xmlGetProp(entryChilds, (const xmlChar *)&quot;rel&quot;);</a>
<a name="ln583">            if(!xmlStrcmp(rel, (const xmlChar *)&quot;edit&quot;))</a>
<a name="ln584">            {</a>
<a name="ln585">              updateUri = (char *)xmlGetProp(entryChilds, (const xmlChar *)&quot;href&quot;);</a>
<a name="ln586">            }</a>
<a name="ln587">            xmlFree(rel);</a>
<a name="ln588">          }</a>
<a name="ln589">        } while((entryChilds = entryChilds-&gt;next) != NULL);</a>
<a name="ln590">      }</a>
<a name="ln591"> </a>
<a name="ln592">      // Let's update the photo</a>
<a name="ln593">      headers = NULL;</a>
<a name="ln594">      headers = curl_slist_append(headers, &quot;Content-Type: application/atom+xml&quot;);</a>
<a name="ln595">      headers = curl_slist_append(headers, &quot;If-Match: *&quot;);</a>
<a name="ln596">      headers = curl_slist_append(headers, &quot;GData-Version: 3&quot;);</a>
<a name="ln597">      headers = curl_slist_append(headers, authHeader);</a>
<a name="ln598"> </a>
<a name="ln599">      _buffer_t response = { 0 };</a>
<a name="ln600"> </a>
<a name="ln601">      // Setup data to send..</a>
<a name="ln602">      _buffer_t writebuffer;</a>
<a name="ln603">      int datasize;</a>
<a name="ln604">      xmlDocDumpMemory(doc, (xmlChar **)&amp;writebuffer.data, &amp;datasize);</a>
<a name="ln605">      writebuffer.size = datasize;</a>
<a name="ln606">      writebuffer.offset = 0;</a>
<a name="ln607"> </a>
<a name="ln608">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_URL, updateUri);</a>
<a name="ln609">#ifdef picasa_iEXTRA_VERBOSE</a>
<a name="ln610">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_VERBOSE, 2);</a>
<a name="ln611">#endif</a>
<a name="ln612">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_HTTPHEADER, headers);</a>
<a name="ln613">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_UPLOAD, 1); // A put request</a>
<a name="ln614">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_READDATA, &amp;writebuffer);</a>
<a name="ln615">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_INFILESIZE, writebuffer.size);</a>
<a name="ln616">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_READFUNCTION, _picasa_api_buffer_read_func);</a>
<a name="ln617">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEFUNCTION, _picasa_api_buffer_write_func);</a>
<a name="ln618">      curl_easy_setopt(ctx-&gt;curl_ctx, CURLOPT_WRITEDATA, &amp;response);</a>
<a name="ln619">      res = curl_easy_perform(ctx-&gt;curl_ctx);</a>
<a name="ln620"> </a>
<a name="ln621">      if(res != CURLE_OK)</a>
<a name="ln622">        fprintf(stderr, &quot;[picasa] error updating photo: %s\n&quot;, curl_easy_strerror(res));</a>
<a name="ln623"> </a>
<a name="ln624">#ifdef picasa_EXTRA_VERBOSE</a>
<a name="ln625">      printf(&quot;Uploading: %s\n&quot;, response.data);</a>
<a name="ln626">#endif</a>
<a name="ln627"> </a>
<a name="ln628">      xmlFree(updateUri);</a>
<a name="ln629">      xmlFree(writebuffer.data);</a>
<a name="ln630">      g_free(response.data);</a>
<a name="ln631"> </a>
<a name="ln632">      curl_slist_free_all(headers);</a>
<a name="ln633">    }</a>
<a name="ln634"> </a>
<a name="ln635">    xmlFreeDoc(doc);</a>
<a name="ln636">    g_free(keywords);</a>
<a name="ln637">    g_list_free_full(keywords_list, g_free);</a>
<a name="ln638">  }</a>
<a name="ln639">  return photo_id;</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">/**</a>
<a name="ln643"> * @see https://developers.google.com/accounts/docs/OAuth2InstalledApp#callinganapi</a>
<a name="ln644"> * @return basic information about the account</a>
<a name="ln645"> */</a>
<a name="ln646">static PicasaAccountInfo *picasa_get_account_info(PicasaContext *ctx)</a>
<a name="ln647">{</a>
<a name="ln648">  JsonObject *obj = picasa_query_get(ctx, &quot;oauth2/v1/userinfo&quot;, NULL, FALSE);</a>
<a name="ln649">  g_return_val_if_fail((obj != NULL), NULL);</a>
<a name="ln650">  /* Using the email instead of the username as it is unique */</a>
<a name="ln651">  /* To change it to use the username, change &quot;email&quot; by &quot;name&quot; */</a>
<a name="ln652">  const gchar *user_name = json_object_get_string_member(obj, &quot;given_name&quot;);</a>
<a name="ln653">  const gchar *email = json_object_get_string_member(obj, &quot;email&quot;);</a>
<a name="ln654">  const gchar *user_id = json_object_get_string_member(obj, &quot;id&quot;);</a>
<a name="ln655">  g_return_val_if_fail(user_name != NULL &amp;&amp; user_id != NULL, NULL);</a>
<a name="ln656"> </a>
<a name="ln657">  gchar *name = NULL;</a>
<a name="ln658">  name = dt_util_dstrcat(name, &quot;%s - %s&quot;, user_name, email);</a>
<a name="ln659"> </a>
<a name="ln660">  PicasaAccountInfo *accountinfo = picasa_account_info_init();</a>
<a name="ln661">  accountinfo-&gt;id = g_strdup(user_id);</a>
<a name="ln662">  accountinfo-&gt;username = g_strdup(name);</a>
<a name="ln663">  accountinfo-&gt;token = g_strdup(ctx-&gt;token);</a>
<a name="ln664">  accountinfo-&gt;refresh_token = g_strdup(ctx-&gt;refresh_token);</a>
<a name="ln665"> </a>
<a name="ln666">  g_snprintf(ctx-&gt;userid, sizeof(ctx-&gt;userid), &quot;%s&quot;, user_id);</a>
<a name="ln667">  g_free(name);</a>
<a name="ln668">  return accountinfo;</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671"> </a>
<a name="ln672">///////////////////////////////// UI functions</a>
<a name="ln673"> </a>
<a name="ln674">static gboolean combobox_separator(GtkTreeModel *model, GtkTreeIter *iter, gpointer data)</a>
<a name="ln675">{</a>
<a name="ln676">  GValue value = {</a>
<a name="ln677">    0,</a>
<a name="ln678">  };</a>
<a name="ln679">  gtk_tree_model_get_value(model, iter, 0, &amp;value);</a>
<a name="ln680">  gchar *v = NULL;</a>
<a name="ln681">  if(G_VALUE_HOLDS_STRING(&amp;value))</a>
<a name="ln682">  {</a>
<a name="ln683">    if((v = (gchar *)g_value_get_string(&amp;value)) != NULL &amp;&amp; *v == '\0') return TRUE;</a>
<a name="ln684">  }</a>
<a name="ln685">  g_value_unset(&amp;value);</a>
<a name="ln686">  return FALSE;</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">static gchar *picasa_get_user_refresh_token(PicasaContext *ctx)</a>
<a name="ln690">{</a>
<a name="ln691">  gchar *refresh_token = NULL;</a>
<a name="ln692">  JsonObject *reply;</a>
<a name="ln693">  gchar *params = NULL;</a>
<a name="ln694"> </a>
<a name="ln695">  params = dt_util_dstrcat(params, &quot;refresh_token=%s&amp;client_id=&quot; GOOGLE_API_KEY</a>
<a name="ln696">                                   &quot;&amp;client_secret=&quot; GOOGLE_API_SECRET &quot;&amp;grant_type=refresh_token&quot;,</a>
<a name="ln697">                           ctx-&gt;refresh_token);</a>
<a name="ln698"> </a>
<a name="ln699">  reply = picasa_query_post_auth(ctx, &quot;o/oauth2/token&quot;, params);</a>
<a name="ln700"> </a>
<a name="ln701">  refresh_token = g_strdup(json_object_get_string_member(reply, &quot;access_token&quot;));</a>
<a name="ln702"> </a>
<a name="ln703">  g_free(params);</a>
<a name="ln704"> </a>
<a name="ln705">  return refresh_token;</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708">/**</a>
<a name="ln709"> * @see https://developers.google.com/accounts/docs/OAuth2InstalledApp</a>
<a name="ln710"> * @returns NULL if the user cancels the operation or a valid token</a>
<a name="ln711"> */</a>
<a name="ln712">static int picasa_get_user_auth_token(dt_storage_picasa_gui_data_t *ui)</a>
<a name="ln713">{</a>
<a name="ln714">  ///////////// open the authentication url in a browser</a>
<a name="ln715">  GError *error = NULL;</a>
<a name="ln716">  if(!gtk_show_uri(</a>
<a name="ln717">         gdk_screen_get_default(), GOOGLE_WS_BASE_URL</a>
<a name="ln718">         &quot;o/oauth2/auth?&quot;</a>
<a name="ln719">         &quot;client_id=&quot; GOOGLE_API_KEY &quot;&amp;redirect_uri=urn:ietf:wg:oauth:2.0:oob&quot;</a>
<a name="ln720">         &quot;&amp;scope=https://picasaweb.google.com/data/ https://www.googleapis.com/auth/userinfo.profile&quot;</a>
<a name="ln721">         &quot; https://www.googleapis.com/auth/userinfo.email&quot;</a>
<a name="ln722">         &quot;&amp;response_type=code&quot;,</a>
<a name="ln723">         gtk_get_current_event_time(), &amp;error))</a>
<a name="ln724">  {</a>
<a name="ln725">    fprintf(stderr, &quot;[picasa] error opening browser: %s\n&quot;, error-&gt;message);</a>
<a name="ln726">    g_error_free(error);</a>
<a name="ln727">  }</a>
<a name="ln728"> </a>
<a name="ln729">  ////////////// build &amp; show the validation dialog</a>
<a name="ln730">  const gchar *text1 = _(&quot;step 1: a new window or tab of your browser should have been &quot;</a>
<a name="ln731">                         &quot;loaded. you have to login into your google account there &quot;</a>
<a name="ln732">                         &quot;and authorize darktable to upload photos before continuing.&quot;);</a>
<a name="ln733">  const gchar *text2 = _(&quot;step 2: paste the verification code shown to you in the browser &quot;</a>
<a name="ln734">                         &quot;and click the OK button once you are done.&quot;);</a>
<a name="ln735"> </a>
<a name="ln736">  GtkWidget *window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln737">  GtkDialog *picasa_auth_dialog = GTK_DIALOG(</a>
<a name="ln738">      gtk_message_dialog_new(GTK_WINDOW(window), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION,</a>
<a name="ln739">                             GTK_BUTTONS_OK_CANCEL, _(&quot;google authentication&quot;)));</a>
<a name="ln740">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln741">  dt_osx_disallow_fullscreen(GTK_WIDGET(picasa_auth_dialog));</a>
<a name="ln742">#endif</a>
<a name="ln743">  gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(picasa_auth_dialog), &quot;%s\n\n%s&quot;, text1, text2);</a>
<a name="ln744"> </a>
<a name="ln745">  GtkWidget *entry = gtk_entry_new();</a>
<a name="ln746">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln747">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtk_label_new(_(&quot;verification code:&quot;))), FALSE, FALSE, 0);</a>
<a name="ln748">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(entry), TRUE, TRUE, 0);</a>
<a name="ln749"> </a>
<a name="ln750">  GtkWidget *picasaauthdialog_vbox</a>
<a name="ln751">      = gtk_message_dialog_get_message_area(GTK_MESSAGE_DIALOG(picasa_auth_dialog));</a>
<a name="ln752">  gtk_box_pack_end(GTK_BOX(picasaauthdialog_vbox), hbox, TRUE, TRUE, 0);</a>
<a name="ln753"> </a>
<a name="ln754">  gtk_widget_show_all(GTK_WIDGET(picasa_auth_dialog));</a>
<a name="ln755"> </a>
<a name="ln756">  ////////////// wait for the user to enter the verification code</a>
<a name="ln757">  gint result;</a>
<a name="ln758">  gchar *token = NULL;</a>
<a name="ln759">  const char *replycode;</a>
<a name="ln760">  while(TRUE)</a>
<a name="ln761">  {</a>
<a name="ln762">    result = gtk_dialog_run(GTK_DIALOG(picasa_auth_dialog));</a>
<a name="ln763">    if(result == GTK_RESPONSE_CANCEL) break;</a>
<a name="ln764">    replycode = gtk_entry_get_text(GTK_ENTRY(entry));</a>
<a name="ln765">    if(replycode == NULL || g_strcmp0(replycode, &quot;&quot;) == 0)</a>
<a name="ln766">    {</a>
<a name="ln767">      gtk_message_dialog_format_secondary_markup(GTK_MESSAGE_DIALOG(picasa_auth_dialog),</a>
<a name="ln768">                                                 &quot;%s\n\n%s\n\n&lt;span foreground=\&quot;&quot; MSGCOLOR_RED</a>
<a name="ln769">                                                 &quot;\&quot; &gt;&lt;small&gt;%s&lt;/small&gt;&lt;/span&gt;&quot;,</a>
<a name="ln770">                                                 text1, text2, _(&quot;please enter the verification code&quot;));</a>
<a name="ln771">      continue;</a>
<a name="ln772">    }</a>
<a name="ln773">    else</a>
<a name="ln774">    {</a>
<a name="ln775">      token = g_strdup(replycode);</a>
<a name="ln776">      break;</a>
<a name="ln777">    }</a>
<a name="ln778">  }</a>
<a name="ln779">  gtk_widget_destroy(GTK_WIDGET(picasa_auth_dialog));</a>
<a name="ln780"> </a>
<a name="ln781">  if(result == GTK_RESPONSE_CANCEL)</a>
<a name="ln782">    return 1;</a>
<a name="ln783"> </a>
<a name="ln784">  // Interchange now the authorization_code for an access_token and refresh_token</a>
<a name="ln785">  JsonObject *reply;</a>
<a name="ln786"> </a>
<a name="ln787">  gchar *params = NULL;</a>
<a name="ln788">  params = dt_util_dstrcat(params, &quot;code=%s&amp;client_id=&quot; GOOGLE_API_KEY &quot;&amp;client_secret=&quot; GOOGLE_API_SECRET</a>
<a name="ln789">                                   &quot;&amp;redirect_uri=&quot; GOOGLE_URI &quot;&amp;grant_type=authorization_code&quot;,</a>
<a name="ln790">                           token);</a>
<a name="ln791"> </a>
<a name="ln792">  g_free(token);</a>
<a name="ln793"> </a>
<a name="ln794">  reply = picasa_query_post_auth(ui-&gt;picasa_api, &quot;o/oauth2/token&quot;, params);</a>
<a name="ln795"> </a>
<a name="ln796">  gchar *access_token = g_strdup(json_object_get_string_member(reply, &quot;access_token&quot;));</a>
<a name="ln797"> </a>
<a name="ln798">  gchar *refresh_token = g_strdup(json_object_get_string_member(reply, &quot;refresh_token&quot;));</a>
<a name="ln799"> </a>
<a name="ln800">  ui-&gt;picasa_api-&gt;token = access_token;</a>
<a name="ln801">  ui-&gt;picasa_api-&gt;refresh_token = refresh_token;</a>
<a name="ln802"> </a>
<a name="ln803">  g_free(params);</a>
<a name="ln804"> </a>
<a name="ln805">  return 0; // FIXME</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808"> </a>
<a name="ln809">static void load_account_info_fill(gchar *key, gchar *value, GSList **accountlist)</a>
<a name="ln810">{</a>
<a name="ln811">  JsonParser *parser = json_parser_new();</a>
<a name="ln812">  json_parser_load_from_data(parser, value, strlen(value), NULL);</a>
<a name="ln813">  JsonNode *root = json_parser_get_root(parser);</a>
<a name="ln814"> </a>
<a name="ln815">  // defensive check, root can be null while parsing the account info</a>
<a name="ln816">  if(root)</a>
<a name="ln817">  {</a>
<a name="ln818">    JsonObject *obj = json_node_get_object(root);</a>
<a name="ln819">    PicasaAccountInfo *info = picasa_account_info_init();</a>
<a name="ln820">    info-&gt;id = g_strdup(key);</a>
<a name="ln821">    info-&gt;token = g_strdup(json_object_get_string_member(obj, &quot;token&quot;));</a>
<a name="ln822">    info-&gt;username = g_strdup(json_object_get_string_member(obj, &quot;username&quot;));</a>
<a name="ln823">    info-&gt;id = g_strdup(json_object_get_string_member(obj, &quot;userid&quot;));</a>
<a name="ln824">    info-&gt;refresh_token = g_strdup(json_object_get_string_member(obj, &quot;refresh_token&quot;));</a>
<a name="ln825">    *accountlist = g_slist_prepend(*accountlist, info);</a>
<a name="ln826">  }</a>
<a name="ln827">  g_object_unref(parser);</a>
<a name="ln828">}</a>
<a name="ln829"> </a>
<a name="ln830">/**</a>
<a name="ln831"> * @return a GSList of saved PicasaAccountInfo</a>
<a name="ln832"> */</a>
<a name="ln833">static GSList *load_account_info()</a>
<a name="ln834">{</a>
<a name="ln835">  GSList *accountlist = NULL;</a>
<a name="ln836"> </a>
<a name="ln837">  GHashTable *table = dt_pwstorage_get(&quot;picasa2&quot;);</a>
<a name="ln838">  g_hash_table_foreach(table, (GHFunc)load_account_info_fill, &amp;accountlist);</a>
<a name="ln839">  g_hash_table_destroy(table);</a>
<a name="ln840">  return accountlist;</a>
<a name="ln841">}</a>
<a name="ln842"> </a>
<a name="ln843">static void save_account_info(dt_storage_picasa_gui_data_t *ui, PicasaAccountInfo *accountinfo)</a>
<a name="ln844">{</a>
<a name="ln845">  PicasaContext *ctx = ui-&gt;picasa_api;</a>
<a name="ln846">  g_return_if_fail(ctx != NULL);</a>
<a name="ln847"> </a>
<a name="ln848">  /// serialize data;</a>
<a name="ln849">  JsonBuilder *builder = json_builder_new();</a>
<a name="ln850">  json_builder_begin_object(builder);</a>
<a name="ln851">  json_builder_set_member_name(builder, &quot;username&quot;);</a>
<a name="ln852">  json_builder_add_string_value(builder, accountinfo-&gt;username);</a>
<a name="ln853">  json_builder_set_member_name(builder, &quot;userid&quot;);</a>
<a name="ln854">  json_builder_add_string_value(builder, accountinfo-&gt;id);</a>
<a name="ln855">  json_builder_set_member_name(builder, &quot;token&quot;);</a>
<a name="ln856">  json_builder_add_string_value(builder, accountinfo-&gt;token);</a>
<a name="ln857">  json_builder_set_member_name(builder, &quot;refresh_token&quot;);</a>
<a name="ln858">  json_builder_add_string_value(builder, accountinfo-&gt;refresh_token);</a>
<a name="ln859"> </a>
<a name="ln860">  json_builder_end_object(builder);</a>
<a name="ln861"> </a>
<a name="ln862">  JsonNode *node = json_builder_get_root(builder);</a>
<a name="ln863">  JsonGenerator *generator = json_generator_new();</a>
<a name="ln864">  json_generator_set_root(generator, node);</a>
<a name="ln865">#if JSON_CHECK_VERSION(0, 14, 0)</a>
<a name="ln866">  json_generator_set_pretty(generator, FALSE);</a>
<a name="ln867">#endif</a>
<a name="ln868">  gchar *data = json_generator_to_data(generator, NULL);</a>
<a name="ln869"> </a>
<a name="ln870">  json_node_free(node);</a>
<a name="ln871">  g_object_unref(generator);</a>
<a name="ln872">  g_object_unref(builder);</a>
<a name="ln873"> </a>
<a name="ln874">  GHashTable *table = dt_pwstorage_get(&quot;picasa2&quot;);</a>
<a name="ln875">  g_hash_table_insert(table, g_strdup(accountinfo-&gt;id), data);</a>
<a name="ln876">  dt_pwstorage_set(&quot;picasa2&quot;, table);</a>
<a name="ln877"> </a>
<a name="ln878">  g_hash_table_destroy(table);</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">static void remove_account_info(const gchar *accountid)</a>
<a name="ln882">{</a>
<a name="ln883">  GHashTable *table = dt_pwstorage_get(&quot;picasa2&quot;);</a>
<a name="ln884">  g_hash_table_remove(table, accountid);</a>
<a name="ln885">  dt_pwstorage_set(&quot;picasa2&quot;, table);</a>
<a name="ln886">  g_hash_table_destroy(table);</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">static void ui_refresh_users_fill(PicasaAccountInfo *value, gpointer dataptr)</a>
<a name="ln890">{</a>
<a name="ln891">  GtkListStore *liststore = GTK_LIST_STORE(dataptr);</a>
<a name="ln892">  GtkTreeIter iter;</a>
<a name="ln893">  gtk_list_store_append(liststore, &amp;iter);</a>
<a name="ln894">  gtk_list_store_set(liststore, &amp;iter, COMBO_USER_MODEL_NAME_COL, value-&gt;username, COMBO_USER_MODEL_TOKEN_COL,</a>
<a name="ln895">                     value-&gt;token, COMBO_USER_MODEL_REFRESH_TOKEN_COL, value-&gt;refresh_token,</a>
<a name="ln896">                     COMBO_USER_MODEL_ID_COL, value-&gt;id, -1);</a>
<a name="ln897">}</a>
<a name="ln898"> </a>
<a name="ln899">static void ui_refresh_users(dt_storage_picasa_gui_data_t *ui)</a>
<a name="ln900">{</a>
<a name="ln901">  GSList *accountlist = load_account_info();</a>
<a name="ln902">  GtkListStore *list_store = GTK_LIST_STORE(gtk_combo_box_get_model(ui-&gt;comboBox_username));</a>
<a name="ln903">  GtkTreeIter iter;</a>
<a name="ln904"> </a>
<a name="ln905">  gtk_list_store_clear(list_store);</a>
<a name="ln906">  gtk_list_store_append(list_store, &amp;iter);</a>
<a name="ln907"> </a>
<a name="ln908">  if(g_slist_length(accountlist) == 0)</a>
<a name="ln909">  {</a>
<a name="ln910">    gtk_list_store_set(list_store, &amp;iter, COMBO_USER_MODEL_NAME_COL, _(&quot;new account&quot;),</a>
<a name="ln911">                       COMBO_USER_MODEL_TOKEN_COL, NULL, COMBO_USER_MODEL_ID_COL, NULL, -1);</a>
<a name="ln912">  }</a>
<a name="ln913">  else</a>
<a name="ln914">  {</a>
<a name="ln915">    gtk_list_store_set(list_store, &amp;iter, COMBO_USER_MODEL_NAME_COL, _(&quot;other account&quot;),</a>
<a name="ln916">                       COMBO_USER_MODEL_TOKEN_COL, NULL, COMBO_USER_MODEL_ID_COL, NULL, -1);</a>
<a name="ln917">    gtk_list_store_append(list_store, &amp;iter);</a>
<a name="ln918">    gtk_list_store_set(list_store, &amp;iter, COMBO_USER_MODEL_NAME_COL, &quot;&quot;, COMBO_USER_MODEL_TOKEN_COL, NULL,</a>
<a name="ln919">                       COMBO_USER_MODEL_ID_COL, NULL, -1); // separator</a>
<a name="ln920">  }</a>
<a name="ln921"> </a>
<a name="ln922">  g_slist_foreach(accountlist, (GFunc)ui_refresh_users_fill, list_store);</a>
<a name="ln923">  gtk_combo_box_set_active(ui-&gt;comboBox_username, 0);</a>
<a name="ln924"> </a>
<a name="ln925">  g_slist_free_full(accountlist, (GDestroyNotify)picasa_account_info_destroy);</a>
<a name="ln926">  gtk_combo_box_set_row_separator_func(ui-&gt;comboBox_username, combobox_separator, ui-&gt;comboBox_username, NULL);</a>
<a name="ln927">}</a>
<a name="ln928"> </a>
<a name="ln929">static void ui_refresh_albums_fill(PicasaAlbum *album, GtkListStore *list_store)</a>
<a name="ln930">{</a>
<a name="ln931">  GtkTreeIter iter;</a>
<a name="ln932">  gtk_list_store_append(list_store, &amp;iter);</a>
<a name="ln933">  gtk_list_store_set(list_store, &amp;iter, COMBO_ALBUM_MODEL_NAME_COL, album-&gt;name, COMBO_ALBUM_MODEL_ID_COL,</a>
<a name="ln934">                     album-&gt;id, -1);</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937">static void ui_refresh_albums(dt_storage_picasa_gui_data_t *ui)</a>
<a name="ln938">{</a>
<a name="ln939"> </a>
<a name="ln940">  gboolean getlistok;</a>
<a name="ln941">  GList *albumList = picasa_get_album_list(ui-&gt;picasa_api, &amp;getlistok);</a>
<a name="ln942">  if(!getlistok)</a>
<a name="ln943">  {</a>
<a name="ln944">    dt_control_log(_(&quot;unable to retrieve the album list&quot;));</a>
<a name="ln945">    goto cleanup;</a>
<a name="ln946">  }</a>
<a name="ln947"> </a>
<a name="ln948">  int current_index = gtk_combo_box_get_active(ui-&gt;comboBox_album);</a>
<a name="ln949"> </a>
<a name="ln950">  GtkListStore *model_album = GTK_LIST_STORE(gtk_combo_box_get_model(ui-&gt;comboBox_album));</a>
<a name="ln951">  GtkTreeIter iter;</a>
<a name="ln952">  gtk_list_store_clear(model_album);</a>
<a name="ln953">  gtk_list_store_append(model_album, &amp;iter);</a>
<a name="ln954">  gtk_list_store_set(model_album, &amp;iter, COMBO_ALBUM_MODEL_NAME_COL, _(&quot;drop box&quot;),</a>
<a name="ln955">                     COMBO_ALBUM_MODEL_ID_COL, NULL, -1);</a>
<a name="ln956">  if(albumList != NULL)</a>
<a name="ln957">  {</a>
<a name="ln958">    gtk_list_store_append(model_album, &amp;iter);</a>
<a name="ln959">    gtk_list_store_set(model_album, &amp;iter, COMBO_ALBUM_MODEL_NAME_COL, &quot;&quot;, COMBO_ALBUM_MODEL_ID_COL, NULL,</a>
<a name="ln960">                       -1); // separator</a>
<a name="ln961">  }</a>
<a name="ln962">  g_list_foreach(albumList, (GFunc)ui_refresh_albums_fill, model_album);</a>
<a name="ln963"> </a>
<a name="ln964">  if (albumList != NULL &amp;&amp; current_index != -1)</a>
<a name="ln965">    gtk_combo_box_set_active(ui-&gt;comboBox_album, current_index);</a>
<a name="ln966">  else</a>
<a name="ln967">    gtk_combo_box_set_active(ui-&gt;comboBox_album, 0);</a>
<a name="ln968"> </a>
<a name="ln969">  gtk_widget_show_all(GTK_WIDGET(ui-&gt;comboBox_album));</a>
<a name="ln970">  g_list_free_full(albumList, (GDestroyNotify)picasa_album_destroy);</a>
<a name="ln971"> </a>
<a name="ln972">cleanup:</a>
<a name="ln973">  return;</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976">static void ui_combo_username_changed(GtkComboBox *combo, struct dt_storage_picasa_gui_data_t *ui)</a>
<a name="ln977">{</a>
<a name="ln978">  GtkTreeIter iter;</a>
<a name="ln979">  gchar *token = NULL;</a>
<a name="ln980">  gchar *refresh_token = NULL;</a>
<a name="ln981">  gchar *userid = NULL;</a>
<a name="ln982">  if(!gtk_combo_box_get_active_iter(combo, &amp;iter)) return; // ie: list is empty while clearing the combo</a>
<a name="ln983">  GtkTreeModel *model = gtk_combo_box_get_model(combo);</a>
<a name="ln984">  gtk_tree_model_get(model, &amp;iter, COMBO_USER_MODEL_TOKEN_COL, &amp;token, -1); // get the selected token</a>
<a name="ln985">  gtk_tree_model_get(model, &amp;iter, COMBO_USER_MODEL_REFRESH_TOKEN_COL, &amp;refresh_token, -1);</a>
<a name="ln986">  gtk_tree_model_get(model, &amp;iter, COMBO_USER_MODEL_ID_COL, &amp;userid, -1);</a>
<a name="ln987"> </a>
<a name="ln988">  ui-&gt;picasa_api-&gt;token = g_strdup(token);</a>
<a name="ln989">  ui-&gt;picasa_api-&gt;refresh_token = g_strdup(refresh_token);</a>
<a name="ln990">  g_snprintf(ui-&gt;picasa_api-&gt;userid, sizeof(ui-&gt;picasa_api-&gt;userid), &quot;%s&quot;, userid);</a>
<a name="ln991"> </a>
<a name="ln992">  if(ui-&gt;picasa_api-&gt;token != NULL &amp;&amp; picasa_test_auth_token(ui-&gt;picasa_api))</a>
<a name="ln993">  {</a>
<a name="ln994">    ui-&gt;connected = TRUE;</a>
<a name="ln995">    gtk_button_set_label(ui-&gt;button_login, _(&quot;logout&quot;));</a>
<a name="ln996">    ui_refresh_albums(ui);</a>
<a name="ln997">    gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;comboBox_album), TRUE);</a>
<a name="ln998">  }</a>
<a name="ln999">  else</a>
<a name="ln1000">  {</a>
<a name="ln1001">    gtk_button_set_label(ui-&gt;button_login, _(&quot;login&quot;));</a>
<a name="ln1002">    g_free(ui-&gt;picasa_api-&gt;token);</a>
<a name="ln1003">    g_free(ui-&gt;picasa_api-&gt;refresh_token);</a>
<a name="ln1004">    ui-&gt;picasa_api-&gt;token = ui-&gt;picasa_api-&gt;refresh_token = NULL;</a>
<a name="ln1005">    gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;comboBox_album), FALSE);</a>
<a name="ln1006">    GtkListStore *model_album = GTK_LIST_STORE(gtk_combo_box_get_model(ui-&gt;comboBox_album));</a>
<a name="ln1007">    gtk_list_store_clear(model_album);</a>
<a name="ln1008">  }</a>
<a name="ln1009">}</a>
<a name="ln1010"> </a>
<a name="ln1011">static void ui_combo_album_changed(GtkComboBox *combo, gpointer data)</a>
<a name="ln1012">{</a>
<a name="ln1013">  GtkTreeIter iter;</a>
<a name="ln1014">  gchar *albumid = NULL;</a>
<a name="ln1015">  if(gtk_combo_box_get_active_iter(combo, &amp;iter))</a>
<a name="ln1016">  {</a>
<a name="ln1017">    GtkTreeModel *model = gtk_combo_box_get_model(combo);</a>
<a name="ln1018">    gtk_tree_model_get(model, &amp;iter, COMBO_ALBUM_MODEL_ID_COL, &amp;albumid, -1); // get the album id</a>
<a name="ln1019">  }</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022"> </a>
<a name="ln1023">static gboolean ui_authenticate(dt_storage_picasa_gui_data_t *ui)</a>
<a name="ln1024">{</a>
<a name="ln1025">  if(ui-&gt;picasa_api == NULL)</a>
<a name="ln1026">  {</a>
<a name="ln1027">    ui-&gt;picasa_api = picasa_api_init();</a>
<a name="ln1028">  }</a>
<a name="ln1029"> </a>
<a name="ln1030">  PicasaContext *ctx = ui-&gt;picasa_api;</a>
<a name="ln1031">  gboolean mustsaveaccount = FALSE;</a>
<a name="ln1032"> </a>
<a name="ln1033">  gchar *uiselectedaccounttoken = NULL;</a>
<a name="ln1034">  gchar *uiselectedaccountrefreshtoken = NULL;</a>
<a name="ln1035">  gchar *uiselecteduserid = NULL;</a>
<a name="ln1036">  GtkTreeIter iter;</a>
<a name="ln1037">  gtk_combo_box_get_active_iter(ui-&gt;comboBox_username, &amp;iter);</a>
<a name="ln1038">  GtkTreeModel *accountModel = gtk_combo_box_get_model(ui-&gt;comboBox_username);</a>
<a name="ln1039">  gtk_tree_model_get(accountModel, &amp;iter, COMBO_USER_MODEL_TOKEN_COL, &amp;uiselectedaccounttoken, -1);</a>
<a name="ln1040">  gtk_tree_model_get(accountModel, &amp;iter, COMBO_USER_MODEL_REFRESH_TOKEN_COL, &amp;uiselectedaccountrefreshtoken,</a>
<a name="ln1041">                     -1);</a>
<a name="ln1042">  gtk_tree_model_get(accountModel, &amp;iter, COMBO_USER_MODEL_ID_COL, &amp;uiselecteduserid, -1);</a>
<a name="ln1043"> </a>
<a name="ln1044">  if(ctx-&gt;token != NULL)</a>
<a name="ln1045">  {</a>
<a name="ln1046">    g_free(ctx-&gt;token);</a>
<a name="ln1047">    g_free(ctx-&gt;refresh_token);</a>
<a name="ln1048">    ctx-&gt;userid[0] = 0;</a>
<a name="ln1049">    ctx-&gt;token = ctx-&gt;refresh_token = NULL;</a>
<a name="ln1050">  }</a>
<a name="ln1051"> </a>
<a name="ln1052">  if(uiselectedaccounttoken != NULL)</a>
<a name="ln1053">  {</a>
<a name="ln1054">    ctx-&gt;token = g_strdup(uiselectedaccounttoken);</a>
<a name="ln1055">    ctx-&gt;refresh_token = g_strdup(uiselectedaccountrefreshtoken);</a>
<a name="ln1056">    g_snprintf(ctx-&gt;userid, sizeof(ctx-&gt;userid), &quot;%s&quot;, uiselecteduserid);</a>
<a name="ln1057">  }</a>
<a name="ln1058">  // check selected token if we already have one</a>
<a name="ln1059">  if(ctx-&gt;token != NULL &amp;&amp; !picasa_test_auth_token(ctx))</a>
<a name="ln1060">  {</a>
<a name="ln1061">    g_free(ctx-&gt;token);</a>
<a name="ln1062">    g_free(ctx-&gt;refresh_token);</a>
<a name="ln1063">    ctx-&gt;userid[0] = 0;</a>
<a name="ln1064">    ctx-&gt;token = ctx-&gt;refresh_token = NULL;</a>
<a name="ln1065">  }</a>
<a name="ln1066"> </a>
<a name="ln1067">  int ret = 0;</a>
<a name="ln1068">  if(ctx-&gt;token == NULL)</a>
<a name="ln1069">  {</a>
<a name="ln1070">    mustsaveaccount = TRUE;</a>
<a name="ln1071">    ret = picasa_get_user_auth_token(ui); // ask user to log in</a>
<a name="ln1072">  }</a>
<a name="ln1073"> </a>
<a name="ln1074">  if(ctx-&gt;token == NULL || ctx-&gt;refresh_token == NULL || ret != 0)</a>
<a name="ln1075">  {</a>
<a name="ln1076">    return FALSE;</a>
<a name="ln1077">  }</a>
<a name="ln1078">  else</a>
<a name="ln1079">  {</a>
<a name="ln1080">    if(mustsaveaccount)</a>
<a name="ln1081">    {</a>
<a name="ln1082">      // Get first the refresh token</a>
<a name="ln1083">      PicasaAccountInfo *accountinfo = picasa_get_account_info(ui-&gt;picasa_api);</a>
<a name="ln1084">      g_return_val_if_fail(accountinfo != NULL, FALSE);</a>
<a name="ln1085">      save_account_info(ui, accountinfo);</a>
<a name="ln1086"> </a>
<a name="ln1087">      // add account to user list and select it</a>
<a name="ln1088">      GtkListStore *model = GTK_LIST_STORE(gtk_combo_box_get_model(ui-&gt;comboBox_username));</a>
<a name="ln1089">      gboolean r;</a>
<a name="ln1090">      gchar *uid;</a>
<a name="ln1091"> </a>
<a name="ln1092">      gboolean updated = FALSE;</a>
<a name="ln1093"> </a>
<a name="ln1094">      for(r = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &amp;iter); r == TRUE;</a>
<a name="ln1095">          r = gtk_tree_model_iter_next(GTK_TREE_MODEL(model), &amp;iter))</a>
<a name="ln1096">      {</a>
<a name="ln1097">        gtk_tree_model_get(GTK_TREE_MODEL(model), &amp;iter, COMBO_USER_MODEL_ID_COL, &amp;uid, -1);</a>
<a name="ln1098"> </a>
<a name="ln1099">        if(g_strcmp0(uid, accountinfo-&gt;id) == 0)</a>
<a name="ln1100">        {</a>
<a name="ln1101">          gtk_list_store_set(model, &amp;iter, COMBO_USER_MODEL_NAME_COL, accountinfo-&gt;username,</a>
<a name="ln1102">                             COMBO_USER_MODEL_TOKEN_COL, accountinfo-&gt;token,</a>
<a name="ln1103">                             COMBO_USER_MODEL_REFRESH_TOKEN_COL, accountinfo-&gt;refresh_token, -1);</a>
<a name="ln1104">          updated = TRUE;</a>
<a name="ln1105">          break;</a>
<a name="ln1106">        }</a>
<a name="ln1107">      }</a>
<a name="ln1108"> </a>
<a name="ln1109">      if(!updated)</a>
<a name="ln1110">      {</a>
<a name="ln1111">        gtk_list_store_append(model, &amp;iter);</a>
<a name="ln1112">        gtk_list_store_set(model, &amp;iter, COMBO_USER_MODEL_NAME_COL, accountinfo-&gt;username,</a>
<a name="ln1113">                           COMBO_USER_MODEL_TOKEN_COL, accountinfo-&gt;token, COMBO_USER_MODEL_REFRESH_TOKEN_COL,</a>
<a name="ln1114">                           accountinfo-&gt;refresh_token, COMBO_USER_MODEL_ID_COL, accountinfo-&gt;id, -1);</a>
<a name="ln1115">      }</a>
<a name="ln1116">      g_signal_handlers_block_matched(ui-&gt;comboBox_username, G_SIGNAL_MATCH_FUNC, 0, 0, NULL,</a>
<a name="ln1117">                                      ui_combo_username_changed, NULL);</a>
<a name="ln1118">      gtk_combo_box_set_active_iter(ui-&gt;comboBox_username, &amp;iter);</a>
<a name="ln1119">      g_signal_handlers_unblock_matched(ui-&gt;comboBox_username, G_SIGNAL_MATCH_FUNC, 0, 0, NULL,</a>
<a name="ln1120">                                        ui_combo_username_changed, NULL);</a>
<a name="ln1121"> </a>
<a name="ln1122">      picasa_account_info_destroy(accountinfo);</a>
<a name="ln1123">    }</a>
<a name="ln1124">    return TRUE;</a>
<a name="ln1125">  }</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128"> </a>
<a name="ln1129">static void ui_login_clicked(GtkButton *button, gpointer data)</a>
<a name="ln1130">{</a>
<a name="ln1131">  dt_storage_picasa_gui_data_t *ui = (dt_storage_picasa_gui_data_t *)data;</a>
<a name="ln1132">  gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;comboBox_album), FALSE);</a>
<a name="ln1133">  if(ui-&gt;connected == FALSE)</a>
<a name="ln1134">  {</a>
<a name="ln1135">    if(ui_authenticate(ui))</a>
<a name="ln1136">    {</a>
<a name="ln1137">      ui_refresh_albums(ui);</a>
<a name="ln1138">      ui-&gt;connected = TRUE;</a>
<a name="ln1139">      gtk_button_set_label(ui-&gt;button_login, _(&quot;logout&quot;));</a>
<a name="ln1140">    }</a>
<a name="ln1141">    else</a>
<a name="ln1142">    {</a>
<a name="ln1143">      gtk_button_set_label(ui-&gt;button_login, _(&quot;login&quot;));</a>
<a name="ln1144">    }</a>
<a name="ln1145">  }</a>
<a name="ln1146">  else // disconnect user</a>
<a name="ln1147">  {</a>
<a name="ln1148">    if(ui-&gt;connected == TRUE &amp;&amp; ui-&gt;picasa_api-&gt;token != NULL)</a>
<a name="ln1149">    {</a>
<a name="ln1150">      GtkTreeModel *model = gtk_combo_box_get_model(ui-&gt;comboBox_username);</a>
<a name="ln1151">      GtkTreeIter iter;</a>
<a name="ln1152">      gtk_combo_box_get_active_iter(ui-&gt;comboBox_username, &amp;iter);</a>
<a name="ln1153">      gchar *userid;</a>
<a name="ln1154">      gtk_tree_model_get(model, &amp;iter, COMBO_USER_MODEL_ID_COL, &amp;userid, -1);</a>
<a name="ln1155">      remove_account_info(userid);</a>
<a name="ln1156">      gtk_button_set_label(ui-&gt;button_login, _(&quot;login&quot;));</a>
<a name="ln1157">      ui_refresh_users(ui);</a>
<a name="ln1158">      ui-&gt;connected = FALSE;</a>
<a name="ln1159">    }</a>
<a name="ln1160">  }</a>
<a name="ln1161">  gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;comboBox_album), TRUE);</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164"> </a>
<a name="ln1165"> </a>
<a name="ln1166">////////////////////////// darktable library interface</a>
<a name="ln1167"> </a>
<a name="ln1168">/* plugin name */</a>
<a name="ln1169">const char *name(const struct dt_imageio_module_storage_t *self)</a>
<a name="ln1170">{</a>
<a name="ln1171">  return _(&quot;google photos&quot;);</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174">/* construct widget above */</a>
<a name="ln1175">void gui_init(struct dt_imageio_module_storage_t *self)</a>
<a name="ln1176">{</a>
<a name="ln1177">  self-&gt;gui_data = g_malloc0(sizeof(dt_storage_picasa_gui_data_t));</a>
<a name="ln1178">  dt_storage_picasa_gui_data_t *ui = self-&gt;gui_data;</a>
<a name="ln1179">  ui-&gt;picasa_api = picasa_api_init();</a>
<a name="ln1180"> </a>
<a name="ln1181">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1182"> </a>
<a name="ln1183">  // create entries</a>
<a name="ln1184">  GtkListStore *model_username</a>
<a name="ln1185">      = gtk_list_store_new(COMBO_USER_MODEL_NB_COL, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING,</a>
<a name="ln1186">                           G_TYPE_STRING); // text, token, refresh_token, id</a>
<a name="ln1187">  ui-&gt;comboBox_username = GTK_COMBO_BOX(gtk_combo_box_new_with_model(GTK_TREE_MODEL(model_username)));</a>
<a name="ln1188">  GtkCellRenderer *p_cell = gtk_cell_renderer_text_new();</a>
<a name="ln1189">  g_object_set(G_OBJECT(p_cell), &quot;ellipsize&quot;, PANGO_ELLIPSIZE_MIDDLE, &quot;ellipsize-set&quot;, TRUE, &quot;width-chars&quot;, 35,</a>
<a name="ln1190">               (gchar *)0);</a>
<a name="ln1191">  gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(ui-&gt;comboBox_username), p_cell, FALSE);</a>
<a name="ln1192">  gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(ui-&gt;comboBox_username), p_cell, &quot;text&quot;, 0, NULL);</a>
<a name="ln1193"> </a>
<a name="ln1194">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(ui-&gt;comboBox_username));</a>
<a name="ln1195"> </a>
<a name="ln1196">  // retrieve saved accounts</a>
<a name="ln1197">  ui_refresh_users(ui);</a>
<a name="ln1198"> </a>
<a name="ln1199">  //////// album list /////////</a>
<a name="ln1200">  GtkWidget *albumlist = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1201">  GtkListStore *model_album</a>
<a name="ln1202">      = gtk_list_store_new(COMBO_ALBUM_MODEL_NB_COL, G_TYPE_STRING, G_TYPE_STRING); // name, id</a>
<a name="ln1203">  ui-&gt;comboBox_album = GTK_COMBO_BOX(gtk_combo_box_new_with_model(GTK_TREE_MODEL(model_album)));</a>
<a name="ln1204">  p_cell = gtk_cell_renderer_text_new();</a>
<a name="ln1205">  g_object_set(G_OBJECT(p_cell), &quot;ellipsize&quot;, PANGO_ELLIPSIZE_MIDDLE, &quot;ellipsize-set&quot;, TRUE, &quot;width-chars&quot;, 35,</a>
<a name="ln1206">               (gchar *)0);</a>
<a name="ln1207">  gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(ui-&gt;comboBox_album), p_cell, FALSE);</a>
<a name="ln1208">  gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(ui-&gt;comboBox_album), p_cell, &quot;text&quot;, 0, NULL);</a>
<a name="ln1209"> </a>
<a name="ln1210">  gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;comboBox_album), FALSE);</a>
<a name="ln1211">  gtk_combo_box_set_row_separator_func(ui-&gt;comboBox_album, combobox_separator, ui-&gt;comboBox_album, NULL);</a>
<a name="ln1212">  gtk_box_pack_start(GTK_BOX(albumlist), GTK_WIDGET(ui-&gt;comboBox_album), TRUE, TRUE, 0);</a>
<a name="ln1213"> </a>
<a name="ln1214">  ui-&gt;button_login = GTK_BUTTON(gtk_button_new_with_label(_(&quot;login&quot;)));</a>
<a name="ln1215">  ui-&gt;connected = FALSE;</a>
<a name="ln1216"> </a>
<a name="ln1217">  // pack the ui</a>
<a name="ln1218">  ////the auth box</a>
<a name="ln1219">  GtkWidget *hbox_auth = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln1220">  GtkWidget *vbox_auth_labels = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1221">  GtkWidget *vbox_auth_fields = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1222">  gtk_box_pack_start(GTK_BOX(hbox_auth), vbox_auth_labels, FALSE, FALSE, 0);</a>
<a name="ln1223">  gtk_box_pack_start(GTK_BOX(hbox_auth), vbox_auth_fields, TRUE, TRUE, 0);</a>
<a name="ln1224">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hbox_auth), TRUE, FALSE, 2);</a>
<a name="ln1225">  gtk_box_pack_start(GTK_BOX(vbox_auth_fields), GTK_WIDGET(ui-&gt;comboBox_username), TRUE, FALSE, 2);</a>
<a name="ln1226"> </a>
<a name="ln1227">  gtk_box_pack_start(GTK_BOX(vbox_auth_labels), GTK_WIDGET(gtk_label_new(&quot;&quot;)), TRUE, TRUE, 2);</a>
<a name="ln1228">  gtk_box_pack_start(GTK_BOX(vbox_auth_fields), GTK_WIDGET(ui-&gt;button_login), TRUE, FALSE, 2);</a>
<a name="ln1229"> </a>
<a name="ln1230">  gtk_box_pack_start(GTK_BOX(vbox_auth_fields), GTK_WIDGET(albumlist), TRUE, FALSE, 2);</a>
<a name="ln1231"> </a>
<a name="ln1232">  // connect buttons to signals</a>
<a name="ln1233">  g_signal_connect(G_OBJECT(ui-&gt;button_login), &quot;clicked&quot;, G_CALLBACK(ui_login_clicked), (gpointer)ui);</a>
<a name="ln1234">  g_signal_connect(G_OBJECT(ui-&gt;comboBox_username), &quot;changed&quot;, G_CALLBACK(ui_combo_username_changed),</a>
<a name="ln1235">                   (gpointer)ui);</a>
<a name="ln1236">  g_signal_connect(G_OBJECT(ui-&gt;comboBox_album), &quot;changed&quot;, G_CALLBACK(ui_combo_album_changed), (gpointer)ui);</a>
<a name="ln1237"> </a>
<a name="ln1238">  g_object_unref(model_username);</a>
<a name="ln1239">  g_object_unref(model_album);</a>
<a name="ln1240">}</a>
<a name="ln1241"> </a>
<a name="ln1242">/* destroy resources */</a>
<a name="ln1243">void gui_cleanup(struct dt_imageio_module_storage_t *self)</a>
<a name="ln1244">{</a>
<a name="ln1245">  dt_storage_picasa_gui_data_t *ui = self-&gt;gui_data;</a>
<a name="ln1246">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ui-&gt;comboBox_username));</a>
<a name="ln1247">  if(ui-&gt;picasa_api != NULL) picasa_api_destroy(ui-&gt;picasa_api);</a>
<a name="ln1248">  g_free(self-&gt;gui_data);</a>
<a name="ln1249">}</a>
<a name="ln1250"> </a>
<a name="ln1251">/* reset options to defaults */</a>
<a name="ln1252">void gui_reset(struct dt_imageio_module_storage_t *self)</a>
<a name="ln1253">{</a>
<a name="ln1254">  // TODO?</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257">/* try and see if this format is supported? */</a>
<a name="ln1258">int supported(struct dt_imageio_module_storage_t *self, struct dt_imageio_module_format_t *format)</a>
<a name="ln1259">{</a>
<a name="ln1260">  if(strcmp(format-&gt;mime(NULL), &quot;image/jpeg&quot;) == 0) return 1;</a>
<a name="ln1261">  return 0;</a>
<a name="ln1262">}</a>
<a name="ln1263"> </a>
<a name="ln1264">/* this actually does the work */</a>
<a name="ln1265">int store(dt_imageio_module_storage_t *self, struct dt_imageio_module_data_t *sdata, const int imgid,</a>
<a name="ln1266">          dt_imageio_module_format_t *format, dt_imageio_module_data_t *fdata, const int num, const int total,</a>
<a name="ln1267">          const gboolean high_quality, const gboolean upscale, dt_colorspaces_color_profile_type_t icc_type,</a>
<a name="ln1268">          const gchar *icc_filename, dt_iop_color_intent_t icc_intent)</a>
<a name="ln1269">{</a>
<a name="ln1270">  gint result = 1;</a>
<a name="ln1271">  PicasaContext *ctx = (PicasaContext *)sdata;</a>
<a name="ln1272"> </a>
<a name="ln1273">  const char *ext = format-&gt;extension(fdata);</a>
<a name="ln1274">  char fname[PATH_MAX] = { 0 };</a>
<a name="ln1275">  dt_loc_get_tmp_dir(fname, sizeof(fname));</a>
<a name="ln1276">  g_strlcat(fname, &quot;/darktable.XXXXXX.&quot;, sizeof(fname));</a>
<a name="ln1277">  g_strlcat(fname, ext, sizeof(fname));</a>
<a name="ln1278"> </a>
<a name="ln1279">  gint fd = g_mkstemp(fname);</a>
<a name="ln1280">  if(fd == -1)</a>
<a name="ln1281">  {</a>
<a name="ln1282">    dt_control_log(&quot;failed to create temporary image for google photos export&quot;);</a>
<a name="ln1283">    return 1;</a>
<a name="ln1284">  }</a>
<a name="ln1285">  close(fd);</a>
<a name="ln1286"> </a>
<a name="ln1287">  // get metadata</a>
<a name="ln1288">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1289">  char *title = NULL;</a>
<a name="ln1290">  char *summary = NULL;</a>
<a name="ln1291">  GList *meta_title = NULL;</a>
<a name="ln1292"> </a>
<a name="ln1293">  title = g_path_get_basename(img-&gt;filename);</a>
<a name="ln1294">  (g_strrstr(title, &quot;.&quot;))[0] = '\0'; // Chop extension...</a>
<a name="ln1295"> </a>
<a name="ln1296">  meta_title = dt_metadata_get(img-&gt;id, &quot;Xmp.dc.title&quot;, NULL);</a>
<a name="ln1297">  summary = meta_title != NULL ? meta_title-&gt;data : &quot;&quot;;</a>
<a name="ln1298"> </a>
<a name="ln1299">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln1300"> </a>
<a name="ln1301">  if(dt_imageio_export(imgid, fname, format, fdata, high_quality, upscale, FALSE, icc_type, icc_filename, icc_intent,</a>
<a name="ln1302">                       self, sdata, num, total) != 0)</a>
<a name="ln1303">  {</a>
<a name="ln1304">    g_printerr(&quot;[picasa] could not export to file: `%s'!\n&quot;, fname);</a>
<a name="ln1305">    dt_control_log(_(&quot;could not export to file `%s'!&quot;), fname);</a>
<a name="ln1306">    result = 0;</a>
<a name="ln1307">    goto cleanup;</a>
<a name="ln1308">  }</a>
<a name="ln1309"> </a>
<a name="ln1310">  const char *photoid = picasa_upload_photo_to_album(ctx, ctx-&gt;album_id, fname, title, summary, imgid);</a>
<a name="ln1311">  if(photoid == NULL)</a>
<a name="ln1312">  {</a>
<a name="ln1313">    dt_control_log(_(&quot;unable to export to google photos album&quot;));</a>
<a name="ln1314">    result = 0;</a>
<a name="ln1315">    goto cleanup;</a>
<a name="ln1316">  }</a>
<a name="ln1317"> </a>
<a name="ln1318">cleanup:</a>
<a name="ln1319">  g_unlink(fname);</a>
<a name="ln1320">  g_free(title);</a>
<a name="ln1321">  g_list_free_full(meta_title, &amp;g_free);</a>
<a name="ln1322"> </a>
<a name="ln1323">  if(result)</a>
<a name="ln1324">  {</a>
<a name="ln1325">    // this makes sense only if the export was successful</a>
<a name="ln1326">    dt_control_log(ngettext(&quot;%d/%d exported to google photos album&quot;, &quot;%d/%d exported to google photos album&quot;, num), num, total);</a>
<a name="ln1327">  }</a>
<a name="ln1328">  return 0;</a>
<a name="ln1329">}</a>
<a name="ln1330"> </a>
<a name="ln1331">static gboolean _finalize_store(gpointer user_data)</a>
<a name="ln1332">{</a>
<a name="ln1333">  dt_storage_picasa_gui_data_t *ui = (dt_storage_picasa_gui_data_t *)user_data;</a>
<a name="ln1334">  ui_refresh_albums(ui);</a>
<a name="ln1335"> </a>
<a name="ln1336">  return FALSE;</a>
<a name="ln1337">}</a>
<a name="ln1338"> </a>
<a name="ln1339">void finalize_store(struct dt_imageio_module_storage_t *self, dt_imageio_module_data_t *data)</a>
<a name="ln1340">{</a>
<a name="ln1341">  g_main_context_invoke(NULL, _finalize_store, self-&gt;gui_data);</a>
<a name="ln1342">}</a>
<a name="ln1343"> </a>
<a name="ln1344"> </a>
<a name="ln1345">size_t params_size(dt_imageio_module_storage_t *self)</a>
<a name="ln1346">{</a>
<a name="ln1347">  return sizeof(PicasaContext) - 8 * sizeof(void *);</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350">void init(dt_imageio_module_storage_t *self)</a>
<a name="ln1351">{</a>
<a name="ln1352">}</a>
<a name="ln1353">void *get_params(struct dt_imageio_module_storage_t *self)</a>
<a name="ln1354">{</a>
<a name="ln1355">  dt_storage_picasa_gui_data_t *ui = (dt_storage_picasa_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1356">  if(!ui) return NULL; // gui not initialized, CLI mode</a>
<a name="ln1357">  if(ui-&gt;picasa_api == NULL || ui-&gt;picasa_api-&gt;token == NULL)</a>
<a name="ln1358">  {</a>
<a name="ln1359">    return NULL;</a>
<a name="ln1360">  }</a>
<a name="ln1361">  PicasaContext *p = (PicasaContext *)g_malloc0(sizeof(PicasaContext));</a>
<a name="ln1362"> </a>
<a name="ln1363">  p-&gt;curl_ctx = ui-&gt;picasa_api-&gt;curl_ctx;</a>
<a name="ln1364">  p-&gt;json_parser = ui-&gt;picasa_api-&gt;json_parser;</a>
<a name="ln1365">  p-&gt;errmsg = ui-&gt;picasa_api-&gt;errmsg;</a>
<a name="ln1366">  p-&gt;token = g_strdup(ui-&gt;picasa_api-&gt;token);</a>
<a name="ln1367">  p-&gt;refresh_token = g_strdup(ui-&gt;picasa_api-&gt;refresh_token);</a>
<a name="ln1368"> </a>
<a name="ln1369">  int index = gtk_combo_box_get_active(ui-&gt;comboBox_album);</a>
<a name="ln1370">  if(index &lt; 0)</a>
<a name="ln1371">  {</a>
<a name="ln1372">    picasa_api_destroy(p);</a>
<a name="ln1373">    return NULL;</a>
<a name="ln1374">  }</a>
<a name="ln1375">  else if(index == 0)</a>
<a name="ln1376">  {</a>
<a name="ln1377">    g_snprintf(p-&gt;album_id, sizeof(p-&gt;album_id), &quot;default&quot;);</a>
<a name="ln1378"> </a>
<a name="ln1379">    /* Hardcode the album as private, to avoid problems with the old Picasa interface */</a>
<a name="ln1380">    p-&gt;album_permission = 1;</a>
<a name="ln1381">  }</a>
<a name="ln1382">  else</a>
<a name="ln1383">  {</a>
<a name="ln1384">    GtkTreeModel *model = gtk_combo_box_get_model(ui-&gt;comboBox_album);</a>
<a name="ln1385">    GtkTreeIter iter;</a>
<a name="ln1386">    gchar *albumid = NULL;</a>
<a name="ln1387">    gtk_combo_box_get_active_iter(ui-&gt;comboBox_album, &amp;iter);</a>
<a name="ln1388">    gtk_tree_model_get(model, &amp;iter, COMBO_ALBUM_MODEL_ID_COL, &amp;albumid, -1);</a>
<a name="ln1389">    g_snprintf(p-&gt;album_id, sizeof(p-&gt;album_id), &quot;%s&quot;, albumid);</a>
<a name="ln1390">  }</a>
<a name="ln1391"> </a>
<a name="ln1392">  g_snprintf(p-&gt;userid, sizeof(p-&gt;userid), &quot;%s&quot;, ui-&gt;picasa_api-&gt;userid);</a>
<a name="ln1393"> </a>
<a name="ln1394">  // recreate a new context for further usages</a>
<a name="ln1395">  ui-&gt;picasa_api = picasa_api_init();</a>
<a name="ln1396">  ui-&gt;picasa_api-&gt;token = g_strdup(p-&gt;token);</a>
<a name="ln1397">  ui-&gt;picasa_api-&gt;refresh_token = g_strdup(p-&gt;refresh_token);</a>
<a name="ln1398">  g_snprintf(ui-&gt;picasa_api-&gt;userid, sizeof(ui-&gt;picasa_api-&gt;userid), &quot;%s&quot;, p-&gt;userid);</a>
<a name="ln1399"> </a>
<a name="ln1400">  return p;</a>
<a name="ln1401">}</a>
<a name="ln1402"> </a>
<a name="ln1403"> </a>
<a name="ln1404">void free_params(struct dt_imageio_module_storage_t *self, dt_imageio_module_data_t *data)</a>
<a name="ln1405">{</a>
<a name="ln1406">  if(!data) return;</a>
<a name="ln1407">  PicasaContext *ctx = (PicasaContext *)data;</a>
<a name="ln1408">  picasa_api_destroy(ctx);</a>
<a name="ln1409">}</a>
<a name="ln1410"> </a>
<a name="ln1411">int set_params(struct dt_imageio_module_storage_t *self, const void *params, const int size)</a>
<a name="ln1412">{</a>
<a name="ln1413">  if(size != self-&gt;params_size(self)) return 1;</a>
<a name="ln1414"> </a>
<a name="ln1415">  PicasaContext *d = (PicasaContext *)params;</a>
<a name="ln1416">  dt_storage_picasa_gui_data_t *g = (dt_storage_picasa_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1417"> </a>
<a name="ln1418">  g_snprintf(g-&gt;picasa_api-&gt;album_id, sizeof(g-&gt;picasa_api-&gt;album_id), &quot;%s&quot;, d-&gt;album_id);</a>
<a name="ln1419">  g_snprintf(g-&gt;picasa_api-&gt;userid, sizeof(g-&gt;picasa_api-&gt;userid), &quot;%s&quot;, d-&gt;userid);</a>
<a name="ln1420"> </a>
<a name="ln1421">  GtkListStore *model = GTK_LIST_STORE(gtk_combo_box_get_model(g-&gt;comboBox_username));</a>
<a name="ln1422">  GtkTreeIter iter;</a>
<a name="ln1423">  gboolean r;</a>
<a name="ln1424">  gchar *uid = NULL;</a>
<a name="ln1425">  gchar *albumid = NULL;</a>
<a name="ln1426"> </a>
<a name="ln1427">  for(r = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &amp;iter); r == TRUE;</a>
<a name="ln1428">      r = gtk_tree_model_iter_next(GTK_TREE_MODEL(model), &amp;iter))</a>
<a name="ln1429">  {</a>
<a name="ln1430">    gtk_tree_model_get(GTK_TREE_MODEL(model), &amp;iter, COMBO_USER_MODEL_ID_COL, &amp;uid, -1);</a>
<a name="ln1431">    if(g_strcmp0(uid, g-&gt;picasa_api-&gt;userid) == 0)</a>
<a name="ln1432">    {</a>
<a name="ln1433">      gtk_combo_box_set_active_iter(g-&gt;comboBox_username, &amp;iter);</a>
<a name="ln1434">      break;</a>
<a name="ln1435">    }</a>
<a name="ln1436">  }</a>
<a name="ln1437">  g_free(uid);</a>
<a name="ln1438"> </a>
<a name="ln1439">  model = GTK_LIST_STORE(gtk_combo_box_get_model(g-&gt;comboBox_album));</a>
<a name="ln1440">  for(r = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &amp;iter); r == TRUE;</a>
<a name="ln1441">      r = gtk_tree_model_iter_next(GTK_TREE_MODEL(model), &amp;iter))</a>
<a name="ln1442">  {</a>
<a name="ln1443">    gtk_tree_model_get(GTK_TREE_MODEL(model), &amp;iter, COMBO_ALBUM_MODEL_ID_COL, &amp;albumid, -1);</a>
<a name="ln1444">    if(g_strcmp0(albumid, g-&gt;picasa_api-&gt;album_id) == 0)</a>
<a name="ln1445">    {</a>
<a name="ln1446">      gtk_combo_box_set_active_iter(g-&gt;comboBox_album, &amp;iter);</a>
<a name="ln1447">      break;</a>
<a name="ln1448">    }</a>
<a name="ln1449">  }</a>
<a name="ln1450">  g_free(albumid);</a>
<a name="ln1451"> </a>
<a name="ln1452">  return 0;</a>
<a name="ln1453">}</a>
<a name="ln1454"> </a>
<a name="ln1455">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1456">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1457">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="303"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="317"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v627/" target="_blank">V627</a> Consider inspecting the expression. The argument of sizeof() is the macro which expands to a number.</p></div>
<div class="balloon" rel="318"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'response' class object.</p></div>
<div class="balloon" rel="370"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v627/" target="_blank">V627</a> Consider inspecting the expression. The argument of sizeof() is the macro which expands to a number.</p></div>
<div class="balloon" rel="372"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'response' class object.</p></div>
<div class="balloon" rel="487"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The 'memcpy' function doesn't copy the whole string. Use 'strcpy / strcpy_s' function to preserve terminal null.</p></div>
<div class="balloon" rel="502"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'headers' class object.</p></div>
<div class="balloon" rel="612"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'headers' class object.</p></div>
<div class="balloon" rel="782"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'token' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="962"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'albumList' pointer was used unsafely after it was verified against nullptr. Check lines: 956, 962.</p></div>
<div class="balloon" rel="962"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'albumList' pointer was utilized before it was verified against nullptr. Check lines: 962, 964.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
