
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012--2013 aldric renaudin.</a>
<a name="ln4">    copyright (c) 2013--2016 Ulrich Pegelow.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;common/debug.h&quot;</a>
<a name="ln20">#include &quot;control/conf.h&quot;</a>
<a name="ln21">#include &quot;control/control.h&quot;</a>
<a name="ln22">#include &quot;develop/blend.h&quot;</a>
<a name="ln23">#include &quot;develop/imageop.h&quot;</a>
<a name="ln24">#include &quot;develop/masks.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">static inline void _ellipse_point_transform(const float xref, const float yref, const float x, const float y,</a>
<a name="ln27">                                            const float sinr, const float cosr, const float scalea,</a>
<a name="ln28">                                            const float scaleb, const float sinv, const float cosv,</a>
<a name="ln29">                                            float *xnew, float *ynew)</a>
<a name="ln30">{</a>
<a name="ln31">  float xtmp = (scaleb * sinr * sinr + scalea * cosr * cosr) * (x - xref)</a>
<a name="ln32">               + (scalea * cosr * sinr - scaleb * cosr * sinr) * (y - yref);</a>
<a name="ln33">  float ytmp = (scalea * cosr * sinr - scaleb * cosr * sinr) * (x - xref)</a>
<a name="ln34">               + (scalea * sinr * sinr + scaleb * cosr * cosr) * (y - yref);</a>
<a name="ln35"> </a>
<a name="ln36">  *xnew = xref + cosv * xtmp - sinv * ytmp;</a>
<a name="ln37">  *ynew = yref + sinv * xtmp + cosv * ytmp;</a>
<a name="ln38">}</a>
<a name="ln39"> </a>
<a name="ln40">// Jordan's point in polygon test</a>
<a name="ln41">static int dt_ellipse_cross_test(float x, float y, float *point_1, float *point_2)</a>
<a name="ln42">{</a>
<a name="ln43">  float x_a = x;</a>
<a name="ln44">  float y_a = y;</a>
<a name="ln45">  float x_b = point_1[0];</a>
<a name="ln46">  float y_b = point_1[1];</a>
<a name="ln47">  float x_c = point_2[0];</a>
<a name="ln48">  float y_c = point_2[1];</a>
<a name="ln49"> </a>
<a name="ln50">  if(y_a == y_b &amp;&amp; y_b == y_c)</a>
<a name="ln51">  {</a>
<a name="ln52">    if((x_b &lt;= x_a &amp;&amp; x_a &lt;= x_c) || (x_c &lt;= x_a &amp;&amp; x_a &lt;= x_b))</a>
<a name="ln53">      return 0;</a>
<a name="ln54">    else</a>
<a name="ln55">      return 1;</a>
<a name="ln56">  }</a>
<a name="ln57"> </a>
<a name="ln58">  if(y_b &gt; y_c)</a>
<a name="ln59">  {</a>
<a name="ln60">    float tmp;</a>
<a name="ln61">    tmp = x_b, x_b = x_c, x_c = tmp;</a>
<a name="ln62">    tmp = y_b, y_b = y_c, y_c = tmp;</a>
<a name="ln63">  }</a>
<a name="ln64"> </a>
<a name="ln65">  if(y_a == y_b &amp;&amp; x_a == x_b) return 0;</a>
<a name="ln66"> </a>
<a name="ln67">  if(y_a &lt;= y_b || y_a &gt; y_c) return 1;</a>
<a name="ln68"> </a>
<a name="ln69">  float delta = (x_b - x_a) * (y_c - y_a) - (y_b - y_a) * (x_c - x_a);</a>
<a name="ln70"> </a>
<a name="ln71">  if(delta &gt; 0)</a>
<a name="ln72">    return -1;</a>
<a name="ln73">  else if(delta &lt; 0)</a>
<a name="ln74">    return 1;</a>
<a name="ln75">  else</a>
<a name="ln76">    return 0;</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">static int dt_ellipse_point_in_polygon(float x, float y, float *points, int points_count)</a>
<a name="ln80">{</a>
<a name="ln81">  int t = -1;</a>
<a name="ln82"> </a>
<a name="ln83">  t *= dt_ellipse_cross_test(x, y, points + 2 * (points_count - 1), points);</a>
<a name="ln84"> </a>
<a name="ln85">  for(int i = 0; i &lt; points_count - 2; i++)</a>
<a name="ln86">    t *= dt_ellipse_cross_test(x, y, points + 2 * i, points + 2 * (i + 1));</a>
<a name="ln87"> </a>
<a name="ln88">  return t;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">// check if point is close to path - segment by segment</a>
<a name="ln92">static int dt_ellipse_point_close_to_path(float x, float y, float as, float *points, int points_count)</a>
<a name="ln93">{</a>
<a name="ln94">  float as2 = as * as;</a>
<a name="ln95"> </a>
<a name="ln96">  float lastx = points[2 * (points_count - 1)];</a>
<a name="ln97">  float lasty = points[2 * (points_count - 1) + 1];</a>
<a name="ln98"> </a>
<a name="ln99">  for(int i = 0; i &lt; points_count; i++)</a>
<a name="ln100">  {</a>
<a name="ln101">    float px = points[2 * i];</a>
<a name="ln102">    float py = points[2 * i + 1];</a>
<a name="ln103"> </a>
<a name="ln104">    float r1 = x - lastx;</a>
<a name="ln105">    float r2 = y - lasty;</a>
<a name="ln106">    float r3 = px - lastx;</a>
<a name="ln107">    float r4 = py - lasty;</a>
<a name="ln108"> </a>
<a name="ln109">    float d = r1 * r3 + r2 * r4;</a>
<a name="ln110">    float l = r3 * r3 + r4 * r4;</a>
<a name="ln111">    float p = d / l;</a>
<a name="ln112"> </a>
<a name="ln113">    float xx, yy;</a>
<a name="ln114"> </a>
<a name="ln115">    if(p &lt; 0 || (px == lastx &amp;&amp; py == lasty))</a>
<a name="ln116">    {</a>
<a name="ln117">      xx = lastx;</a>
<a name="ln118">      yy = lasty;</a>
<a name="ln119">    }</a>
<a name="ln120">    else if(p &gt; 1)</a>
<a name="ln121">    {</a>
<a name="ln122">      xx = px;</a>
<a name="ln123">      yy = py;</a>
<a name="ln124">    }</a>
<a name="ln125">    else</a>
<a name="ln126">    {</a>
<a name="ln127">      xx = lastx + p * r3;</a>
<a name="ln128">      yy = lasty + p * r4;</a>
<a name="ln129">    }</a>
<a name="ln130"> </a>
<a name="ln131">    float dx = x - xx;</a>
<a name="ln132">    float dy = y - yy;</a>
<a name="ln133"> </a>
<a name="ln134">    if(dx * dx + dy * dy &lt; as2) return 1;</a>
<a name="ln135">  }</a>
<a name="ln136">  return 0;</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139">static void dt_ellipse_get_distance(float x, int y, float as, dt_masks_form_gui_t *gui, int index,</a>
<a name="ln140">                                    int *inside, int *inside_border, int *near, int *inside_source)</a>
<a name="ln141">{</a>
<a name="ln142">  if(!gui) return;</a>
<a name="ln143"> </a>
<a name="ln144">  dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln145">  if(!gpt) return;</a>
<a name="ln146"> </a>
<a name="ln147"> </a>
<a name="ln148">  // we first check if we are inside the source form</a>
<a name="ln149">  if(gpt-&gt;source_count &gt; 10)</a>
<a name="ln150">  {</a>
<a name="ln151">    if(dt_ellipse_point_in_polygon(x, y, gpt-&gt;source + 10, gpt-&gt;source_count - 5) &gt;= 0)</a>
<a name="ln152">    {</a>
<a name="ln153">      *inside_source = 1;</a>
<a name="ln154">      *inside = 1;</a>
<a name="ln155">      *inside_border = 0;</a>
<a name="ln156">      *near = -1;</a>
<a name="ln157">      return;</a>
<a name="ln158">    }</a>
<a name="ln159">  }</a>
<a name="ln160"> </a>
<a name="ln161">  *inside_source = 0;</a>
<a name="ln162"> </a>
<a name="ln163">  // we check if it's inside borders</a>
<a name="ln164">  if(dt_ellipse_point_in_polygon(x, y, gpt-&gt;border + 10, gpt-&gt;border_count - 5) &lt; 0)</a>
<a name="ln165">  {</a>
<a name="ln166">    *inside = 0;</a>
<a name="ln167">    *inside_border = 0;</a>
<a name="ln168">    *near = -1;</a>
<a name="ln169">    return;</a>
<a name="ln170">  }</a>
<a name="ln171"> </a>
<a name="ln172">  *inside = 1;</a>
<a name="ln173">  *near = 0;</a>
<a name="ln174">  *inside_border = 1;</a>
<a name="ln175"> </a>
<a name="ln176">  if(dt_ellipse_point_in_polygon(x, y, gpt-&gt;points + 10, gpt-&gt;points_count - 5) &gt;= 0) *inside_border = 0;</a>
<a name="ln177">  if(dt_ellipse_point_close_to_path(x, y, as, gpt-&gt;points + 10, gpt-&gt;points_count - 5)) *near = 1;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">static void dt_ellipse_draw_shape(cairo_t *cr, double *dashed, const int selected, const float zoom_scale,</a>
<a name="ln181">                                  const float dx, const float dy, const float xref, const float yref,</a>
<a name="ln182">                                  const float sinv, const float cosv, const float scalea, const float scaleb,</a>
<a name="ln183">                                  float *points, const int points_count)</a>
<a name="ln184">{</a>
<a name="ln185">  if(points_count &lt;= 10) return;</a>
<a name="ln186"> </a>
<a name="ln187">  const float r = atan2(points[3] - points[1], points[2] - points[0]);</a>
<a name="ln188">  const float sinr = sin(r);</a>
<a name="ln189">  const float cosr = cos(r);</a>
<a name="ln190"> </a>
<a name="ln191">  float x = 0.f;</a>
<a name="ln192">  float y = 0.f;</a>
<a name="ln193"> </a>
<a name="ln194">  cairo_set_dash(cr, dashed, 0, 0);</a>
<a name="ln195">  if(selected)</a>
<a name="ln196">    cairo_set_line_width(cr, 5.0 / zoom_scale);</a>
<a name="ln197">  else</a>
<a name="ln198">    cairo_set_line_width(cr, 3.0 / zoom_scale);</a>
<a name="ln199">  cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln200"> </a>
<a name="ln201">  _ellipse_point_transform(xref, yref, points[10] + dx, points[11] + dy, sinr, cosr, scalea, scaleb, sinv, cosv,</a>
<a name="ln202">                           &amp;x, &amp;y);</a>
<a name="ln203">  cairo_move_to(cr, x, y);</a>
<a name="ln204">  for(int i = 6; i &lt; points_count; i++)</a>
<a name="ln205">  {</a>
<a name="ln206">    _ellipse_point_transform(xref, yref, points[i * 2] + dx, points[i * 2 + 1] + dy, sinr, cosr, scalea, scaleb,</a>
<a name="ln207">                             sinv, cosv, &amp;x, &amp;y);</a>
<a name="ln208">    cairo_line_to(cr, x, y);</a>
<a name="ln209">  }</a>
<a name="ln210">  _ellipse_point_transform(xref, yref, points[10] + dx, points[11] + dy, sinr, cosr, scalea, scaleb, sinv, cosv,</a>
<a name="ln211">                           &amp;x, &amp;y);</a>
<a name="ln212">  cairo_line_to(cr, x, y);</a>
<a name="ln213">  cairo_stroke_preserve(cr);</a>
<a name="ln214">  if(selected)</a>
<a name="ln215">    cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln216">  else</a>
<a name="ln217">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln218">  cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln219">  cairo_stroke(cr);</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">static void dt_ellipse_draw_border(cairo_t *cr, double *dashed, const float len, const int selected,</a>
<a name="ln223">                                   const float zoom_scale, const float dx, const float dy, const float xref,</a>
<a name="ln224">                                   const float yref, const float sinv, const float cosv, const float scaleab,</a>
<a name="ln225">                                   const float scalebb, float *border, const int border_count)</a>
<a name="ln226">{</a>
<a name="ln227">  if(border_count &lt;= 10) return;</a>
<a name="ln228"> </a>
<a name="ln229">  const float r = atan2(border[3] - border[1], border[2] - border[0]);</a>
<a name="ln230">  const float sinr = sin(r);</a>
<a name="ln231">  const float cosr = cos(r);</a>
<a name="ln232"> </a>
<a name="ln233">  float x = 0.f;</a>
<a name="ln234">  float y = 0.f;</a>
<a name="ln235"> </a>
<a name="ln236">  cairo_set_dash(cr, dashed, len, 0);</a>
<a name="ln237">  if(selected)</a>
<a name="ln238">    cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln239">  else</a>
<a name="ln240">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln241">  cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln242"> </a>
<a name="ln243">  _ellipse_point_transform(xref, yref, border[10] + dx, border[11] + dy, sinr, cosr, scaleab, scalebb, sinv, cosv,</a>
<a name="ln244">                           &amp;x, &amp;y);</a>
<a name="ln245">  cairo_move_to(cr, x, y);</a>
<a name="ln246">  for(int i = 6; i &lt; border_count; i++)</a>
<a name="ln247">  {</a>
<a name="ln248">    _ellipse_point_transform(xref, yref, border[i * 2] + dx, border[i * 2 + 1] + dy, sinr, cosr, scaleab, scalebb,</a>
<a name="ln249">                             sinv, cosv, &amp;x, &amp;y);</a>
<a name="ln250">    cairo_line_to(cr, x, y);</a>
<a name="ln251">  }</a>
<a name="ln252">  _ellipse_point_transform(xref, yref, border[10] + dx, border[11] + dy, sinr, cosr, scaleab, scalebb, sinv, cosv,</a>
<a name="ln253">                           &amp;x, &amp;y);</a>
<a name="ln254">  cairo_line_to(cr, x, y);</a>
<a name="ln255"> </a>
<a name="ln256">  cairo_stroke_preserve(cr);</a>
<a name="ln257">  if(selected)</a>
<a name="ln258">    cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln259">  else</a>
<a name="ln260">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln261">  cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln262">  cairo_set_dash(cr, dashed, len, 4);</a>
<a name="ln263">  cairo_stroke(cr);</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">static int dt_ellipse_get_points(dt_develop_t *dev, float xx, float yy, float radius_a, float radius_b,</a>
<a name="ln267">                                 float rotation, float **points, int *points_count)</a>
<a name="ln268">{</a>
<a name="ln269">  const float wd = dev-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln270">  const float ht = dev-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln271">  const float v1 = (rotation / 180.0f) * M_PI;</a>
<a name="ln272">  const float v2 = (rotation - 90.0f) / 180.0f * M_PI;</a>
<a name="ln273">  float a, b, v;</a>
<a name="ln274"> </a>
<a name="ln275">  if(radius_a &gt;= radius_b)</a>
<a name="ln276">  {</a>
<a name="ln277">    a = radius_a * MIN(wd, ht);</a>
<a name="ln278">    b = radius_b * MIN(wd, ht);</a>
<a name="ln279">    v = v1;</a>
<a name="ln280">  }</a>
<a name="ln281">  else</a>
<a name="ln282">  {</a>
<a name="ln283">    a = radius_b * MIN(wd, ht);</a>
<a name="ln284">    b = radius_a * MIN(wd, ht);</a>
<a name="ln285">    v = v2;</a>
<a name="ln286">  }</a>
<a name="ln287"> </a>
<a name="ln288">  const float sinv = sinf(v);</a>
<a name="ln289">  const float cosv = cosf(v);</a>
<a name="ln290"> </a>
<a name="ln291"> </a>
<a name="ln292">  // how many points do we need? we only take every nth point and rely on interpolation (only affecting GUI</a>
<a name="ln293">  // anyhow)</a>
<a name="ln294">  const int n = 10;</a>
<a name="ln295">  const float lambda = (a - b) / (a + b);</a>
<a name="ln296">  const int l = MAX(</a>
<a name="ln297">      100, (int)((M_PI * (a + b)</a>
<a name="ln298">                  * (1.0f + (3.0f * lambda * lambda) / (10.0f + sqrtf(4.0f - 3.0f * lambda * lambda)))) / n));</a>
<a name="ln299"> </a>
<a name="ln300">  // buffer allocations</a>
<a name="ln301">  *points = calloc(2 * (l + 5), sizeof(float));</a>
<a name="ln302">  *points_count = l + 5;</a>
<a name="ln303"> </a>
<a name="ln304">  // now we set the points</a>
<a name="ln305">  const float x = (*points)[0] = xx * wd;</a>
<a name="ln306">  const float y = (*points)[1] = yy * ht;</a>
<a name="ln307"> </a>
<a name="ln308">  (*points)[2] = x + a * cos(v);</a>
<a name="ln309">  (*points)[3] = y + a * sin(v);</a>
<a name="ln310">  (*points)[4] = x - a * cos(v);</a>
<a name="ln311">  (*points)[5] = y - a * sin(v);</a>
<a name="ln312"> </a>
<a name="ln313">  (*points)[6] = x + b * cos(v - M_PI / 2.0f);</a>
<a name="ln314">  (*points)[7] = y + b * sin(v - M_PI / 2.0f);</a>
<a name="ln315">  (*points)[8] = x - b * cos(v - M_PI / 2.0f);</a>
<a name="ln316">  (*points)[9] = y - b * sin(v - M_PI / 2.0f);</a>
<a name="ln317"> </a>
<a name="ln318"> </a>
<a name="ln319">  for(int i = 5; i &lt; l + 5; i++)</a>
<a name="ln320">  {</a>
<a name="ln321">    float alpha = (i - 5) * 2.0 * M_PI / (float)l;</a>
<a name="ln322">    (*points)[i * 2] = x + a * cosf(alpha) * cosv - b * sinf(alpha) * sinv;</a>
<a name="ln323">    (*points)[i * 2 + 1] = y + a * cosf(alpha) * sinv + b * sinf(alpha) * cosv;</a>
<a name="ln324">  }</a>
<a name="ln325"> </a>
<a name="ln326">  // and we transform them with all distorted modules</a>
<a name="ln327">  if(dt_dev_distort_transform(dev, *points, l + 5)) return 1;</a>
<a name="ln328"> </a>
<a name="ln329">  // if we failed, then free all and return</a>
<a name="ln330">  free(*points);</a>
<a name="ln331">  *points = NULL;</a>
<a name="ln332">  *points_count = 0;</a>
<a name="ln333">  return 0;</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">static int dt_ellipse_events_mouse_scrolled(struct dt_iop_module_t *module, float pzx, float pzy, int up,</a>
<a name="ln337">                                            uint32_t state, dt_masks_form_t *form, int parentid,</a>
<a name="ln338">                                            dt_masks_form_gui_t *gui, int index)</a>
<a name="ln339">{</a>
<a name="ln340">  // add a preview when creating an ellipse</a>
<a name="ln341">  if(gui-&gt;creation)</a>
<a name="ln342">  {</a>
<a name="ln343">    if((state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK)) == (GDK_SHIFT_MASK | GDK_CONTROL_MASK))</a>
<a name="ln344">    {</a>
<a name="ln345">      float rotation;</a>
<a name="ln346"> </a>
<a name="ln347">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln348">        rotation = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_rotation&quot;);</a>
<a name="ln349">      else</a>
<a name="ln350">        rotation = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/rotation&quot;);</a>
<a name="ln351"> </a>
<a name="ln352">      if(up)</a>
<a name="ln353">        rotation -= 10.f;</a>
<a name="ln354">      else</a>
<a name="ln355">        rotation += 10.f;</a>
<a name="ln356">      rotation = fmodf(rotation, 360.0f);</a>
<a name="ln357"> </a>
<a name="ln358">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln359">        dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_rotation&quot;, rotation);</a>
<a name="ln360">      else</a>
<a name="ln361">        dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/rotation&quot;, rotation);</a>
<a name="ln362">    }</a>
<a name="ln363">    else if((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln364">    {</a>
<a name="ln365">      float masks_border;</a>
<a name="ln366">      int flags;</a>
<a name="ln367">      float radius_a;</a>
<a name="ln368">      float radius_b;</a>
<a name="ln369"> </a>
<a name="ln370">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln371">      {</a>
<a name="ln372">        masks_border = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_border&quot;);</a>
<a name="ln373">        flags = dt_conf_get_int(&quot;plugins/darkroom/spots/ellipse_flags&quot;);</a>
<a name="ln374">        radius_a = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;);</a>
<a name="ln375">        radius_b = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;);</a>
<a name="ln376">      }</a>
<a name="ln377">      else</a>
<a name="ln378">      {</a>
<a name="ln379">        masks_border = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/border&quot;);</a>
<a name="ln380">        flags = dt_conf_get_int(&quot;plugins/darkroom/masks/ellipse/flags&quot;);</a>
<a name="ln381">        radius_a = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;);</a>
<a name="ln382">        radius_b = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;);</a>
<a name="ln383">      }</a>
<a name="ln384"> </a>
<a name="ln385">      const float reference = (flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? 1.0f / fmin(radius_a, radius_b) : 1.0f);</a>
<a name="ln386">      if(up &amp;&amp; masks_border &gt; 0.001f * reference)</a>
<a name="ln387">        masks_border *= 0.97f;</a>
<a name="ln388">      else if(!up &amp;&amp; masks_border &lt; 1.0f * reference)</a>
<a name="ln389">        masks_border *= 1.0f / 0.97f;</a>
<a name="ln390">      else</a>
<a name="ln391">        return 1;</a>
<a name="ln392">      masks_border = CLAMP(masks_border, 0.001f * reference, reference);</a>
<a name="ln393"> </a>
<a name="ln394">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln395">        dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_border&quot;, masks_border);</a>
<a name="ln396">      else</a>
<a name="ln397">        dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/border&quot;, masks_border);</a>
<a name="ln398">    }</a>
<a name="ln399">    else if(state == 0)</a>
<a name="ln400">    {</a>
<a name="ln401">      float radius_a;</a>
<a name="ln402">      float radius_b;</a>
<a name="ln403"> </a>
<a name="ln404">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln405">      {</a>
<a name="ln406">        radius_a = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;);</a>
<a name="ln407">        radius_b = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;);</a>
<a name="ln408">      }</a>
<a name="ln409">      else</a>
<a name="ln410">      {</a>
<a name="ln411">        radius_a = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;);</a>
<a name="ln412">        radius_b = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;);</a>
<a name="ln413">      }</a>
<a name="ln414"> </a>
<a name="ln415">      const float oldradius = radius_a;</a>
<a name="ln416"> </a>
<a name="ln417">      if(up &amp;&amp; radius_a &gt; 0.001f)</a>
<a name="ln418">        radius_a *= 0.97f;</a>
<a name="ln419">      else if(!up &amp;&amp; radius_a &lt; 1.0f)</a>
<a name="ln420">        radius_a *= 1.0f / 0.97f;</a>
<a name="ln421">      else</a>
<a name="ln422">        return 1;</a>
<a name="ln423"> </a>
<a name="ln424">      radius_a = CLAMP(radius_a, 0.001f, 1.0f);</a>
<a name="ln425"> </a>
<a name="ln426">      const float factor = radius_a / oldradius;</a>
<a name="ln427">      radius_b *= factor;</a>
<a name="ln428"> </a>
<a name="ln429">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln430">      {</a>
<a name="ln431">        dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;, radius_a);</a>
<a name="ln432">        dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;, radius_b);</a>
<a name="ln433">      }</a>
<a name="ln434">      else</a>
<a name="ln435">      {</a>
<a name="ln436">        dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;, radius_a);</a>
<a name="ln437">        dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;, radius_b);</a>
<a name="ln438">      }</a>
<a name="ln439">    }</a>
<a name="ln440">    return 1;</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443">  if(gui-&gt;form_selected)</a>
<a name="ln444">  {</a>
<a name="ln445">    // we register the current position</a>
<a name="ln446">    if(gui-&gt;scrollx == 0.0f &amp;&amp; gui-&gt;scrolly == 0.0f)</a>
<a name="ln447">    {</a>
<a name="ln448">      gui-&gt;scrollx = pzx;</a>
<a name="ln449">      gui-&gt;scrolly = pzy;</a>
<a name="ln450">    }</a>
<a name="ln451">    if((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK &amp;&amp; !((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK))</a>
<a name="ln452">    {</a>
<a name="ln453">      // we try to change the opacity</a>
<a name="ln454">      dt_masks_form_change_opacity(form, parentid, up);</a>
<a name="ln455">    }</a>
<a name="ln456">    else</a>
<a name="ln457">    {</a>
<a name="ln458">      dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln459">      if((state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK)) == (GDK_SHIFT_MASK | GDK_CONTROL_MASK)</a>
<a name="ln460">         &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln461">      {</a>
<a name="ln462">        // we try to change the rotation</a>
<a name="ln463">        if(up)</a>
<a name="ln464">          ellipse-&gt;rotation -= 10.f;</a>
<a name="ln465">        else</a>
<a name="ln466">          ellipse-&gt;rotation += 10.f;</a>
<a name="ln467">        ellipse-&gt;rotation = fmodf(ellipse-&gt;rotation, 360.0f);</a>
<a name="ln468"> </a>
<a name="ln469">        dt_masks_write_form(form, darktable.develop);</a>
<a name="ln470">        dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln471">        dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln472">        if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln473">          dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_rotation&quot;, ellipse-&gt;rotation);</a>
<a name="ln474">        else</a>
<a name="ln475">          dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/rotation&quot;, ellipse-&gt;rotation);</a>
<a name="ln476">      }</a>
<a name="ln477">      // resize don't care where the mouse is inside a shape</a>
<a name="ln478">      if((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln479">      {</a>
<a name="ln480">        const float reference = (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? 1.0f/fmin(ellipse-&gt;radius[0], ellipse-&gt;radius[1]) : 1.0f);</a>
<a name="ln481">        if(up &amp;&amp; ellipse-&gt;border &gt; 0.001f * reference)</a>
<a name="ln482">          ellipse-&gt;border *= 0.97f;</a>
<a name="ln483">        else if(!up &amp;&amp; ellipse-&gt;border &lt; 1.0f * reference)</a>
<a name="ln484">          ellipse-&gt;border *= 1.0f/0.97f;</a>
<a name="ln485">        else return 1;</a>
<a name="ln486">        ellipse-&gt;border = CLAMP(ellipse-&gt;border, 0.001f * reference, reference);</a>
<a name="ln487">        dt_masks_write_form(form, darktable.develop);</a>
<a name="ln488">        dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln489">        dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln490">        if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln491">          dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_border&quot;, ellipse-&gt;border);</a>
<a name="ln492">        else</a>
<a name="ln493">          dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/border&quot;, ellipse-&gt;border);</a>
<a name="ln494">      }</a>
<a name="ln495">      else if(gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln496">      {</a>
<a name="ln497">        const float oldradius = ellipse-&gt;radius[0];</a>
<a name="ln498"> </a>
<a name="ln499">        if(up &amp;&amp; ellipse-&gt;radius[0] &gt; 0.001f)</a>
<a name="ln500">          ellipse-&gt;radius[0] *= 0.97f;</a>
<a name="ln501">        else if(!up &amp;&amp; ellipse-&gt;radius[0] &lt; 1.0f)</a>
<a name="ln502">          ellipse-&gt;radius[0] *= 1.0f / 0.97f;</a>
<a name="ln503">        else return 1;</a>
<a name="ln504"> </a>
<a name="ln505">        ellipse-&gt;radius[0] = CLAMP(ellipse-&gt;radius[0], 0.001f, 1.0f);</a>
<a name="ln506"> </a>
<a name="ln507">        const float factor = ellipse-&gt;radius[0] / oldradius;</a>
<a name="ln508">        ellipse-&gt;radius[1] *= factor;</a>
<a name="ln509"> </a>
<a name="ln510">        dt_masks_write_form(form, darktable.develop);</a>
<a name="ln511">        dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln512">        dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln513">        if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln514">        {</a>
<a name="ln515">          dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;, ellipse-&gt;radius[0]);</a>
<a name="ln516">          dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;, ellipse-&gt;radius[1]);</a>
<a name="ln517">        }</a>
<a name="ln518">        else</a>
<a name="ln519">        {</a>
<a name="ln520">          dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;, ellipse-&gt;radius[0]);</a>
<a name="ln521">          dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;, ellipse-&gt;radius[1]);</a>
<a name="ln522">        }</a>
<a name="ln523">      }</a>
<a name="ln524">      else</a>
<a name="ln525">      {</a>
<a name="ln526">        return 0;</a>
<a name="ln527">      }</a>
<a name="ln528">      dt_masks_update_image(darktable.develop);</a>
<a name="ln529">    }</a>
<a name="ln530">    return 1;</a>
<a name="ln531">  }</a>
<a name="ln532">  return 0;</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">static int dt_ellipse_events_button_pressed(struct dt_iop_module_t *module, float pzx, float pzy,</a>
<a name="ln536">                                            double pressure, int which, int type, uint32_t state,</a>
<a name="ln537">                                            dt_masks_form_t *form, int parentid, dt_masks_form_gui_t *gui,</a>
<a name="ln538">                                            int index)</a>
<a name="ln539">{</a>
<a name="ln540">  if(!gui) return 0;</a>
<a name="ln541">  if(gui-&gt;source_selected &amp;&amp; !gui-&gt;creation &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln542">  {</a>
<a name="ln543">    dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln544">    if(!gpt) return 0;</a>
<a name="ln545">    // we start the source dragging</a>
<a name="ln546">    gui-&gt;source_dragging = TRUE;</a>
<a name="ln547">    gui-&gt;dx = gpt-&gt;source[0] - gui-&gt;posx;</a>
<a name="ln548">    gui-&gt;dy = gpt-&gt;source[1] - gui-&gt;posy;</a>
<a name="ln549">    return 1;</a>
<a name="ln550">  }</a>
<a name="ln551">  else if(gui-&gt;point_selected &gt;= 1 &amp;&amp; !gui-&gt;creation &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL</a>
<a name="ln552">          &amp;&amp; !((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK))</a>
<a name="ln553">  {</a>
<a name="ln554">    dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln555">    if(!gpt) return 0;</a>
<a name="ln556">    gui-&gt;point_dragging = gui-&gt;point_selected;</a>
<a name="ln557">    gui-&gt;dx = gpt-&gt;points[0] - gui-&gt;posx;</a>
<a name="ln558">    gui-&gt;dy = gpt-&gt;points[1] - gui-&gt;posy;</a>
<a name="ln559">    return 1;</a>
<a name="ln560">  }</a>
<a name="ln561">  else if(gui-&gt;form_selected &amp;&amp; !gui-&gt;creation &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL</a>
<a name="ln562">          &amp;&amp; !((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK))</a>
<a name="ln563">  {</a>
<a name="ln564">    dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln565">    if(!gpt) return 0;</a>
<a name="ln566">    // we start the form dragging or rotating</a>
<a name="ln567">    if((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK)</a>
<a name="ln568">      gui-&gt;form_rotating = TRUE;</a>
<a name="ln569">    else</a>
<a name="ln570">      gui-&gt;form_dragging = TRUE;</a>
<a name="ln571">    gui-&gt;dx = gpt-&gt;points[0] - gui-&gt;posx;</a>
<a name="ln572">    gui-&gt;dy = gpt-&gt;points[1] - gui-&gt;posy;</a>
<a name="ln573">    return 1;</a>
<a name="ln574">  }</a>
<a name="ln575">  else if(gui-&gt;form_selected &amp;&amp; !gui-&gt;creation &amp;&amp; ((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK))</a>
<a name="ln576">  {</a>
<a name="ln577">    dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln578">    if(!gpt) return 0;</a>
<a name="ln579"> </a>
<a name="ln580">    gui-&gt;border_toggling = TRUE;</a>
<a name="ln581"> </a>
<a name="ln582">    return 1;</a>
<a name="ln583">  }</a>
<a name="ln584">  else if(gui-&gt;creation &amp;&amp; (which == 3))</a>
<a name="ln585">  {</a>
<a name="ln586">    gui-&gt;creation_continuous = FALSE;</a>
<a name="ln587">    gui-&gt;creation_continuous_module = NULL;</a>
<a name="ln588">    dt_masks_set_edit_mode(module, DT_MASKS_EDIT_FULL);</a>
<a name="ln589">    dt_masks_iop_update(module);</a>
<a name="ln590">    dt_control_queue_redraw_center();</a>
<a name="ln591">    return 1;</a>
<a name="ln592">  }</a>
<a name="ln593">  else if(gui-&gt;creation &amp;&amp; which == 1</a>
<a name="ln594">          &amp;&amp; (((state &amp; (GDK_CONTROL_MASK | GDK_SHIFT_MASK)) == (GDK_CONTROL_MASK | GDK_SHIFT_MASK))</a>
<a name="ln595">              || ((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)))</a>
<a name="ln596">  {</a>
<a name="ln597">    // set some absolute or relative position for the source of the clone mask</a>
<a name="ln598">    if(form-&gt;type &amp; DT_MASKS_CLONE) dt_masks_set_source_pos_initial_state(gui, state, pzx, pzy);</a>
<a name="ln599"> </a>
<a name="ln600">    return 1;</a>
<a name="ln601">  }</a>
<a name="ln602">  else if(gui-&gt;creation)</a>
<a name="ln603">  {</a>
<a name="ln604">    dt_iop_module_t *crea_module = gui-&gt;creation_module;</a>
<a name="ln605">    // we create the ellipse</a>
<a name="ln606">    dt_masks_point_ellipse_t *ellipse</a>
<a name="ln607">        = (dt_masks_point_ellipse_t *)(malloc(sizeof(dt_masks_point_ellipse_t)));</a>
<a name="ln608"> </a>
<a name="ln609">    // we change the center value</a>
<a name="ln610">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln611">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln612">    float pts[2] = { pzx * wd, pzy * ht };</a>
<a name="ln613">    dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln614">    ellipse-&gt;center[0] = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln615">    ellipse-&gt;center[1] = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln616"> </a>
<a name="ln617">    if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln618">    {</a>
<a name="ln619">      const float a = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;);</a>
<a name="ln620">      const float b = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;);</a>
<a name="ln621">      const float ellipse_border = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_border&quot;);</a>
<a name="ln622">      const float rotation = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_rotation&quot;);</a>
<a name="ln623">      const int flags = dt_conf_get_int(&quot;plugins/darkroom/spots/ellipse_flags&quot;);</a>
<a name="ln624">      ellipse-&gt;radius[0] = MAX(0.001f, MIN(0.5f, a));</a>
<a name="ln625">      ellipse-&gt;radius[1] = MAX(0.001f, MIN(0.5f, b));</a>
<a name="ln626">      ellipse-&gt;flags = flags;</a>
<a name="ln627">      ellipse-&gt;rotation = rotation;</a>
<a name="ln628">      const float min_radius = fmin(ellipse-&gt;radius[0], ellipse-&gt;radius[1]);</a>
<a name="ln629">      const float reference = (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? 1.0f/min_radius : 1.0f);</a>
<a name="ln630">      ellipse-&gt;border = MAX(0.005f * reference, MIN(0.5f * reference, ellipse_border));</a>
<a name="ln631">      if(form-&gt;type &amp; DT_MASKS_CLONE)</a>
<a name="ln632">      {</a>
<a name="ln633">        dt_masks_set_source_pos_initial_value(gui, DT_MASKS_ELLIPSE, form, pzx, pzy);</a>
<a name="ln634">      }</a>
<a name="ln635">      else</a>
<a name="ln636">      {</a>
<a name="ln637">        // not used for regular masks</a>
<a name="ln638">        form-&gt;source[0] = form-&gt;source[1] = 0.0f;</a>
<a name="ln639">      }</a>
<a name="ln640">    }</a>
<a name="ln641">    else</a>
<a name="ln642">    {</a>
<a name="ln643">      const float a = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;);</a>
<a name="ln644">      const float b = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;);</a>
<a name="ln645">      const float ellipse_border = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/border&quot;);</a>
<a name="ln646">      const float rotation = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/rotation&quot;);</a>
<a name="ln647">      const int flags = dt_conf_get_int(&quot;plugins/darkroom/masks/ellipse/flags&quot;);</a>
<a name="ln648">      ellipse-&gt;radius[0] = MAX(0.001f, MIN(0.5f, a));</a>
<a name="ln649">      ellipse-&gt;radius[1] = MAX(0.001f, MIN(0.5f, b));</a>
<a name="ln650">      ellipse-&gt;flags = flags;</a>
<a name="ln651">      ellipse-&gt;rotation = rotation;</a>
<a name="ln652">      const float min_radius = fmin(ellipse-&gt;radius[0], ellipse-&gt;radius[1]);</a>
<a name="ln653">      const float reference = (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? 1.0f/min_radius : 1.0f);</a>
<a name="ln654">      ellipse-&gt;border = MAX(0.005f * reference, MIN(0.5f * reference, ellipse_border));</a>
<a name="ln655">      // not used for masks</a>
<a name="ln656">      form-&gt;source[0] = form-&gt;source[1] = 0.0f;</a>
<a name="ln657">    }</a>
<a name="ln658">    form-&gt;points = g_list_append(form-&gt;points, ellipse);</a>
<a name="ln659">    dt_masks_gui_form_save_creation(darktable.develop, crea_module, form, gui);</a>
<a name="ln660"> </a>
<a name="ln661">    if(crea_module)</a>
<a name="ln662">    {</a>
<a name="ln663">      // we save the move</a>
<a name="ln664">      dt_dev_add_history_item(darktable.develop, crea_module, TRUE);</a>
<a name="ln665">      // and we switch in edit mode to show all the forms</a>
<a name="ln666">      if(gui-&gt;creation_continuous)</a>
<a name="ln667">        dt_masks_set_edit_mode_single_form(crea_module, form-&gt;formid, DT_MASKS_EDIT_FULL);</a>
<a name="ln668">      else</a>
<a name="ln669">        dt_masks_set_edit_mode(crea_module, DT_MASKS_EDIT_FULL);</a>
<a name="ln670">      dt_masks_iop_update(crea_module);</a>
<a name="ln671">      gui-&gt;creation_module = NULL;</a>
<a name="ln672">    }</a>
<a name="ln673">    else</a>
<a name="ln674">    {</a>
<a name="ln675">      // we select the new form</a>
<a name="ln676">      dt_dev_masks_selection_change(darktable.develop, form-&gt;formid, TRUE);</a>
<a name="ln677">    }</a>
<a name="ln678"> </a>
<a name="ln679">    // if we draw a clone ellipse, we start now the source dragging</a>
<a name="ln680">    if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln681">    {</a>
<a name="ln682">      dt_masks_form_t *grp = darktable.develop-&gt;form_visible;</a>
<a name="ln683">      if(!grp || !(grp-&gt;type &amp; DT_MASKS_GROUP)) return 1;</a>
<a name="ln684">      int pos3 = 0, pos2 = -1;</a>
<a name="ln685">      GList *fs = g_list_first(grp-&gt;points);</a>
<a name="ln686">      while(fs)</a>
<a name="ln687">      {</a>
<a name="ln688">        dt_masks_point_group_t *pt = (dt_masks_point_group_t *)fs-&gt;data;</a>
<a name="ln689">        if(pt-&gt;formid == form-&gt;formid)</a>
<a name="ln690">        {</a>
<a name="ln691">          pos2 = pos3;</a>
<a name="ln692">          break;</a>
<a name="ln693">        }</a>
<a name="ln694">        pos3++;</a>
<a name="ln695">        fs = g_list_next(fs);</a>
<a name="ln696">      }</a>
<a name="ln697">      if(pos2 &lt; 0) return 1;</a>
<a name="ln698">      dt_masks_form_gui_t *gui2 = darktable.develop-&gt;form_gui;</a>
<a name="ln699">      if(!gui2) return 1;</a>
<a name="ln700">      if(form-&gt;type &amp; DT_MASKS_CLONE)</a>
<a name="ln701">        gui2-&gt;source_dragging = TRUE;</a>
<a name="ln702">      else</a>
<a name="ln703">        gui2-&gt;form_dragging = TRUE;</a>
<a name="ln704">      gui2-&gt;group_edited = gui2-&gt;group_selected = pos2;</a>
<a name="ln705">      gui2-&gt;posx = pzx * darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln706">      gui2-&gt;posy = pzy * darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln707">      gui2-&gt;dx = 0.0;</a>
<a name="ln708">      gui2-&gt;dy = 0.0;</a>
<a name="ln709">      gui2-&gt;scrollx = pzx;</a>
<a name="ln710">      gui2-&gt;scrolly = pzy;</a>
<a name="ln711">      gui2-&gt;form_selected = TRUE; // we also want to be selected after button released</a>
<a name="ln712"> </a>
<a name="ln713">      dt_masks_select_form(module, dt_masks_get_from_id(darktable.develop, form-&gt;formid));</a>
<a name="ln714">    }</a>
<a name="ln715">    return 1;</a>
<a name="ln716">  }</a>
<a name="ln717">  return 0;</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">static int dt_ellipse_events_button_released(struct dt_iop_module_t *module, float pzx, float pzy, int which,</a>
<a name="ln721">                                             uint32_t state, dt_masks_form_t *form, int parentid,</a>
<a name="ln722">                                             dt_masks_form_gui_t *gui, int index)</a>
<a name="ln723">{</a>
<a name="ln724">  if(which == 3 &amp;&amp; parentid &gt; 0 &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln725">  {</a>
<a name="ln726">    // we hide the form</a>
<a name="ln727">    if(!(darktable.develop-&gt;form_visible-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln728">      dt_masks_change_form_gui(NULL);</a>
<a name="ln729">    else if(g_list_length(darktable.develop-&gt;form_visible-&gt;points) &lt; 2)</a>
<a name="ln730">      dt_masks_change_form_gui(NULL);</a>
<a name="ln731">    else</a>
<a name="ln732">    {</a>
<a name="ln733">      dt_masks_clear_form_gui(darktable.develop);</a>
<a name="ln734">      GList *forms = g_list_first(darktable.develop-&gt;form_visible-&gt;points);</a>
<a name="ln735">      while(forms)</a>
<a name="ln736">      {</a>
<a name="ln737">        dt_masks_point_group_t *gpt = (dt_masks_point_group_t *)forms-&gt;data;</a>
<a name="ln738">        if(gpt-&gt;formid == form-&gt;formid)</a>
<a name="ln739">        {</a>
<a name="ln740">          darktable.develop-&gt;form_visible-&gt;points</a>
<a name="ln741">              = g_list_remove(darktable.develop-&gt;form_visible-&gt;points, gpt);</a>
<a name="ln742">          free(gpt);</a>
<a name="ln743">          break;</a>
<a name="ln744">        }</a>
<a name="ln745">        forms = g_list_next(forms);</a>
<a name="ln746">      }</a>
<a name="ln747">      gui-&gt;edit_mode = DT_MASKS_EDIT_FULL;</a>
<a name="ln748">    }</a>
<a name="ln749"> </a>
<a name="ln750">    // we remove the shape</a>
<a name="ln751">    dt_dev_masks_list_remove(darktable.develop, form-&gt;formid, parentid);</a>
<a name="ln752">    dt_masks_form_remove(module, dt_masks_get_from_id(darktable.develop, parentid), form);</a>
<a name="ln753">    return 1;</a>
<a name="ln754">  }</a>
<a name="ln755">  if(gui-&gt;form_dragging)</a>
<a name="ln756">  {</a>
<a name="ln757">    // we get the ellipse</a>
<a name="ln758">    dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln759"> </a>
<a name="ln760">    // we end the form dragging</a>
<a name="ln761">    gui-&gt;form_dragging = FALSE;</a>
<a name="ln762"> </a>
<a name="ln763">    // we change the center value</a>
<a name="ln764">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln765">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln766">    float pts[2] = { pzx * wd + gui-&gt;dx, pzy * ht + gui-&gt;dy };</a>
<a name="ln767">    dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln768">    ellipse-&gt;center[0] = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln769">    ellipse-&gt;center[1] = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln770">    dt_masks_write_form(form, darktable.develop);</a>
<a name="ln771"> </a>
<a name="ln772">    // we recreate the form points</a>
<a name="ln773">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln774">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln775"> </a>
<a name="ln776">    // we save the move</a>
<a name="ln777">    dt_masks_update_image(darktable.develop);</a>
<a name="ln778"> </a>
<a name="ln779">    if(gui-&gt;creation_continuous)</a>
<a name="ln780">    {</a>
<a name="ln781">      dt_masks_form_t *form_new = dt_masks_create(form-&gt;type);</a>
<a name="ln782">      dt_masks_change_form_gui(form_new);</a>
<a name="ln783"> </a>
<a name="ln784">      darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln785">      darktable.develop-&gt;form_gui-&gt;creation_module = gui-&gt;creation_continuous_module;</a>
<a name="ln786">    }</a>
<a name="ln787">    return 1;</a>
<a name="ln788">  }</a>
<a name="ln789">  else if(gui-&gt;border_toggling)</a>
<a name="ln790">  {</a>
<a name="ln791">    // we get the ellipse</a>
<a name="ln792">    dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln793"> </a>
<a name="ln794">    // we end the border toggling</a>
<a name="ln795">    gui-&gt;border_toggling = FALSE;</a>
<a name="ln796"> </a>
<a name="ln797">    // toggle feathering type of border and adjust border radius accordingly</a>
<a name="ln798">    if(ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL)</a>
<a name="ln799">    {</a>
<a name="ln800">      const float min_radius = fmin(ellipse-&gt;radius[0], ellipse-&gt;radius[1]);</a>
<a name="ln801">      ellipse-&gt;border = ellipse-&gt;border * min_radius;</a>
<a name="ln802">      ellipse-&gt;border = CLAMP(ellipse-&gt;border, 0.001f, 1.0f);</a>
<a name="ln803"> </a>
<a name="ln804">      ellipse-&gt;flags &amp;= ~DT_MASKS_ELLIPSE_PROPORTIONAL;</a>
<a name="ln805">    }</a>
<a name="ln806">    else</a>
<a name="ln807">    {</a>
<a name="ln808">      const float min_radius = fmin(ellipse-&gt;radius[0], ellipse-&gt;radius[1]);</a>
<a name="ln809">      ellipse-&gt;border = ellipse-&gt;border/min_radius;</a>
<a name="ln810">      ellipse-&gt;border = CLAMP(ellipse-&gt;border, 0.001f/min_radius, 1.0f/min_radius);</a>
<a name="ln811"> </a>
<a name="ln812">      ellipse-&gt;flags |= DT_MASKS_ELLIPSE_PROPORTIONAL;</a>
<a name="ln813">    }</a>
<a name="ln814"> </a>
<a name="ln815">    if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln816">    {</a>
<a name="ln817">      dt_conf_set_int(&quot;plugins/darkroom/spots/ellipse_flags&quot;, ellipse-&gt;flags);</a>
<a name="ln818">      dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_border&quot;, ellipse-&gt;border);</a>
<a name="ln819">    }</a>
<a name="ln820">    else</a>
<a name="ln821">    {</a>
<a name="ln822">      dt_conf_set_int(&quot;plugins/darkroom/masks/ellipse/flags&quot;, ellipse-&gt;flags);</a>
<a name="ln823">      dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/border&quot;, ellipse-&gt;border);</a>
<a name="ln824">    }</a>
<a name="ln825"> </a>
<a name="ln826">    dt_masks_write_form(form, darktable.develop);</a>
<a name="ln827"> </a>
<a name="ln828">    // we recreate the form points</a>
<a name="ln829">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln830">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln831"> </a>
<a name="ln832">    // we save the new parameters</a>
<a name="ln833">    dt_masks_update_image(darktable.develop);</a>
<a name="ln834"> </a>
<a name="ln835">    return 1;</a>
<a name="ln836">  }</a>
<a name="ln837">  else if(gui-&gt;form_rotating &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln838">  {</a>
<a name="ln839">    // we get the ellipse</a>
<a name="ln840">    dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln841"> </a>
<a name="ln842">    // we end the form rotating</a>
<a name="ln843">    gui-&gt;form_rotating = FALSE;</a>
<a name="ln844"> </a>
<a name="ln845">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln846">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln847">    float x = pzx * wd;</a>
<a name="ln848">    float y = pzy * ht;</a>
<a name="ln849"> </a>
<a name="ln850">    // we need the reference point</a>
<a name="ln851">    dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln852">    if(!gpt) return 0;</a>
<a name="ln853">    float xref = gpt-&gt;points[0];</a>
<a name="ln854">    float yref = gpt-&gt;points[1];</a>
<a name="ln855"> </a>
<a name="ln856">    float dv = atan2(y - yref, x - xref) - atan2(-gui-&gt;dy, -gui-&gt;dx);</a>
<a name="ln857"> </a>
<a name="ln858">    ellipse-&gt;rotation += dv / M_PI * 180.0f;</a>
<a name="ln859">    ellipse-&gt;rotation = fmodf(ellipse-&gt;rotation, 360.0f);</a>
<a name="ln860"> </a>
<a name="ln861">    if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln862">      dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_rotation&quot;, ellipse-&gt;rotation);</a>
<a name="ln863">    else</a>
<a name="ln864">      dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/rotation&quot;, ellipse-&gt;rotation);</a>
<a name="ln865"> </a>
<a name="ln866">    dt_masks_write_form(form, darktable.develop);</a>
<a name="ln867"> </a>
<a name="ln868">    // we recreate the form points</a>
<a name="ln869">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln870">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln871"> </a>
<a name="ln872">    // we save the rotation</a>
<a name="ln873">    dt_masks_update_image(darktable.develop);</a>
<a name="ln874"> </a>
<a name="ln875">    return 1;</a>
<a name="ln876">  }</a>
<a name="ln877">  else if(gui-&gt;point_dragging &gt;= 1 &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln878">  {</a>
<a name="ln879">    // we get the ellipse</a>
<a name="ln880">    dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln881"> </a>
<a name="ln882">    const int k = gui-&gt;point_dragging;</a>
<a name="ln883"> </a>
<a name="ln884">    // we end the point dragging</a>
<a name="ln885">    gui-&gt;point_dragging = -1;</a>
<a name="ln886"> </a>
<a name="ln887">    // we need the reference points</a>
<a name="ln888">    dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln889">    if(!gpt) return 0;</a>
<a name="ln890"> </a>
<a name="ln891">    const float xref = gpt-&gt;points[0];</a>
<a name="ln892">    const float yref = gpt-&gt;points[1];</a>
<a name="ln893">    const float rx = gpt-&gt;points[k * 2] - xref;</a>
<a name="ln894">    const float ry = gpt-&gt;points[k * 2 + 1] - yref;</a>
<a name="ln895">    const float deltax = gui-&gt;posx + gui-&gt;dx - xref;</a>
<a name="ln896">    const float deltay = gui-&gt;posy + gui-&gt;dy - yref;</a>
<a name="ln897"> </a>
<a name="ln898">    const float r = sqrtf(rx * rx + ry * ry);</a>
<a name="ln899">    const float d = (rx * deltax + ry * deltay) / r;</a>
<a name="ln900">    const float s = fmaxf(r &gt; 0.0f ? (r + d) / r : 0.0f, 0.0f);</a>
<a name="ln901"> </a>
<a name="ln902">    // make sure we adjust the right radius: anchor points and 1 and 2 correspond to the ellipse's longer axis</a>
<a name="ln903">    if(((k == 1 || k == 2) &amp;&amp; ellipse-&gt;radius[0] &gt; ellipse-&gt;radius[1])</a>
<a name="ln904">       || ((k == 3 || k == 4) &amp;&amp; ellipse-&gt;radius[0] &lt;= ellipse-&gt;radius[1]))</a>
<a name="ln905">    {</a>
<a name="ln906">      ellipse-&gt;radius[0] = MAX(0.002f, ellipse-&gt;radius[0] * s);</a>
<a name="ln907">      if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln908">        dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;, ellipse-&gt;radius[0]);</a>
<a name="ln909">      else</a>
<a name="ln910">        dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;, ellipse-&gt;radius[0]);</a>
<a name="ln911">    }</a>
<a name="ln912">    else</a>
<a name="ln913">    {</a>
<a name="ln914">      ellipse-&gt;radius[1] = MAX(0.002f, ellipse-&gt;radius[1] * s);</a>
<a name="ln915">      if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln916">        dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;, ellipse-&gt;radius[1]);</a>
<a name="ln917">      else</a>
<a name="ln918">        dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;, ellipse-&gt;radius[1]);</a>
<a name="ln919">    }</a>
<a name="ln920"> </a>
<a name="ln921">    dt_masks_write_form(form, darktable.develop);</a>
<a name="ln922">    // we recreate the form points</a>
<a name="ln923">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln924">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln925"> </a>
<a name="ln926">    // we save the rotation</a>
<a name="ln927">    dt_masks_update_image(darktable.develop);</a>
<a name="ln928"> </a>
<a name="ln929">    return 1;</a>
<a name="ln930">  }</a>
<a name="ln931">  else if(gui-&gt;source_dragging)</a>
<a name="ln932">  {</a>
<a name="ln933">    // we end the form dragging</a>
<a name="ln934">    gui-&gt;source_dragging = FALSE;</a>
<a name="ln935">    if(gui-&gt;scrollx != 0.0 || gui-&gt;scrolly != 0.0)</a>
<a name="ln936">    {</a>
<a name="ln937">      // if there's no dragging the source is calculated in dt_ellipse_events_button_pressed()</a>
<a name="ln938">    }</a>
<a name="ln939">    else</a>
<a name="ln940">    {</a>
<a name="ln941">      // we change the center value</a>
<a name="ln942">      float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln943">      float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln944">      float pts[2] = { pzx * wd + gui-&gt;dx, pzy * ht + gui-&gt;dy };</a>
<a name="ln945"> </a>
<a name="ln946">      dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln947"> </a>
<a name="ln948">      form-&gt;source[0] = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln949">      form-&gt;source[1] = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln950">    }</a>
<a name="ln951">    dt_masks_write_form(form, darktable.develop);</a>
<a name="ln952"> </a>
<a name="ln953">    // we recreate the form points</a>
<a name="ln954">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln955">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln956"> </a>
<a name="ln957">    // we save the move</a>
<a name="ln958">    dt_masks_update_image(darktable.develop);</a>
<a name="ln959"> </a>
<a name="ln960">    if(gui-&gt;creation_continuous)</a>
<a name="ln961">    {</a>
<a name="ln962">      dt_masks_form_t *form_new = dt_masks_create(form-&gt;type);</a>
<a name="ln963">      dt_masks_change_form_gui(form_new);</a>
<a name="ln964"> </a>
<a name="ln965">      darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln966">      darktable.develop-&gt;form_gui-&gt;creation_module = gui-&gt;creation_continuous_module;</a>
<a name="ln967">    }</a>
<a name="ln968">    return 1;</a>
<a name="ln969">  }</a>
<a name="ln970">  return 0;</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973">static int dt_ellipse_events_mouse_moved(struct dt_iop_module_t *module, float pzx, float pzy,</a>
<a name="ln974">                                         double pressure, int which, dt_masks_form_t *form, int parentid,</a>
<a name="ln975">                                         dt_masks_form_gui_t *gui, int index)</a>
<a name="ln976">{</a>
<a name="ln977">  if(gui-&gt;form_dragging || gui-&gt;form_rotating || gui-&gt;source_dragging || gui-&gt;point_dragging &gt;= 1)</a>
<a name="ln978">  {</a>
<a name="ln979">    dt_control_queue_redraw_center();</a>
<a name="ln980">    return 1;</a>
<a name="ln981">  }</a>
<a name="ln982">  else if(!gui-&gt;creation)</a>
<a name="ln983">  {</a>
<a name="ln984">    dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln985">    int closeup = dt_control_get_dev_closeup();</a>
<a name="ln986">    float zoom_scale = dt_dev_get_zoom_scale(darktable.develop, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln987">    float as = 0.005f / zoom_scale * darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln988">    float x = pzx * darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln989">    float y = pzy * darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln990">    int in = 0, inb = 0, near = 0, ins = 0; // FIXME gcc7 false-positive</a>
<a name="ln991">    dt_ellipse_get_distance(pzx * darktable.develop-&gt;preview_pipe-&gt;backbuf_width,</a>
<a name="ln992">                            pzy * darktable.develop-&gt;preview_pipe-&gt;backbuf_height, as, gui, index, &amp;in, &amp;inb,</a>
<a name="ln993">                            &amp;near, &amp;ins);</a>
<a name="ln994">    if(ins)</a>
<a name="ln995">    {</a>
<a name="ln996">      gui-&gt;form_selected = TRUE;</a>
<a name="ln997">      gui-&gt;source_selected = TRUE;</a>
<a name="ln998">      gui-&gt;border_selected = FALSE;</a>
<a name="ln999">    }</a>
<a name="ln1000">    else if(inb)</a>
<a name="ln1001">    {</a>
<a name="ln1002">      gui-&gt;form_selected = TRUE;</a>
<a name="ln1003">      gui-&gt;border_selected = TRUE;</a>
<a name="ln1004">      gui-&gt;source_selected = FALSE;</a>
<a name="ln1005">    }</a>
<a name="ln1006">    else if(in)</a>
<a name="ln1007">    {</a>
<a name="ln1008">      gui-&gt;form_selected = TRUE;</a>
<a name="ln1009">      gui-&gt;border_selected = FALSE;</a>
<a name="ln1010">      gui-&gt;source_selected = FALSE;</a>
<a name="ln1011">    }</a>
<a name="ln1012">    else</a>
<a name="ln1013">    {</a>
<a name="ln1014">      gui-&gt;form_selected = FALSE;</a>
<a name="ln1015">      gui-&gt;border_selected = FALSE;</a>
<a name="ln1016">      gui-&gt;source_selected = FALSE;</a>
<a name="ln1017">    }</a>
<a name="ln1018"> </a>
<a name="ln1019">    // see if we are close to one of the anchor points</a>
<a name="ln1020">    gui-&gt;point_selected = -1;</a>
<a name="ln1021">    if(gui-&gt;form_selected)</a>
<a name="ln1022">    {</a>
<a name="ln1023">      dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln1024">      for(int i = 1; i &lt; 5; i++)</a>
<a name="ln1025">      {</a>
<a name="ln1026">        if(x - gpt-&gt;points[i * 2] &gt; -as &amp;&amp; x - gpt-&gt;points[i * 2] &lt; as &amp;&amp; y - gpt-&gt;points[i * 2 + 1] &gt; -as</a>
<a name="ln1027">           &amp;&amp; y - gpt-&gt;points[i * 2 + 1] &lt; as)</a>
<a name="ln1028">        {</a>
<a name="ln1029">          gui-&gt;point_selected = i;</a>
<a name="ln1030">          break;</a>
<a name="ln1031">        }</a>
<a name="ln1032">      }</a>
<a name="ln1033">    }</a>
<a name="ln1034"> </a>
<a name="ln1035">    dt_control_queue_redraw_center();</a>
<a name="ln1036">    if(!gui-&gt;form_selected &amp;&amp; !gui-&gt;border_selected) return 0;</a>
<a name="ln1037">    if(gui-&gt;edit_mode != DT_MASKS_EDIT_FULL) return 0;</a>
<a name="ln1038">    return 1;</a>
<a name="ln1039">  }</a>
<a name="ln1040">  // add a preview when creating an ellipse</a>
<a name="ln1041">  else if(gui-&gt;creation)</a>
<a name="ln1042">  {</a>
<a name="ln1043">    dt_control_queue_redraw_center();</a>
<a name="ln1044">    return 1;</a>
<a name="ln1045">  }</a>
<a name="ln1046"> </a>
<a name="ln1047">  return 0;</a>
<a name="ln1048">}</a>
<a name="ln1049"> </a>
<a name="ln1050">static void dt_ellipse_events_post_expose(cairo_t *cr, float zoom_scale, dt_masks_form_gui_t *gui, int index)</a>
<a name="ln1051">{</a>
<a name="ln1052">  double dashed[] = { 4.0, 4.0 };</a>
<a name="ln1053">  dashed[0] /= zoom_scale;</a>
<a name="ln1054">  dashed[1] /= zoom_scale;</a>
<a name="ln1055">  int len = sizeof(dashed) / sizeof(dashed[0]);</a>
<a name="ln1056">  dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln1057"> </a>
<a name="ln1058">  float dx = 0.0f, dy = 0.0f, xref = 0.0f, yref = 0.0f;</a>
<a name="ln1059">  float dxs = 0.0f, dys = 0.0f, xrefs = 0.0f, yrefs = 0.0f;</a>
<a name="ln1060">  float sinv = 0.0f, cosv = 1.0f;</a>
<a name="ln1061">  float scalea = 1.0f, scaleb = 1.0f, scaleab = 1.0f, scalebb = 1.0f;</a>
<a name="ln1062"> </a>
<a name="ln1063">  // add a preview when creating an ellipse</a>
<a name="ln1064">  // in creation mode</a>
<a name="ln1065">  if(gui-&gt;creation)</a>
<a name="ln1066">  {</a>
<a name="ln1067">    if(gui-&gt;guipoints_count == 0)</a>
<a name="ln1068">    {</a>
<a name="ln1069">      dt_masks_form_t *form = darktable.develop-&gt;form_visible;</a>
<a name="ln1070">      if(!form) return;</a>
<a name="ln1071"> </a>
<a name="ln1072">      float x, y;</a>
<a name="ln1073">      float masks_border;</a>
<a name="ln1074">      int flags;</a>
<a name="ln1075">      float radius_a;</a>
<a name="ln1076">      float radius_b;</a>
<a name="ln1077">      float rotation;</a>
<a name="ln1078"> </a>
<a name="ln1079">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln1080">      {</a>
<a name="ln1081">        masks_border = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_border&quot;);</a>
<a name="ln1082">        flags = dt_conf_get_int(&quot;plugins/darkroom/spots/ellipse_flags&quot;);</a>
<a name="ln1083">        radius_a = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;);</a>
<a name="ln1084">        radius_b = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;);</a>
<a name="ln1085">        rotation = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_rotation&quot;);</a>
<a name="ln1086">      }</a>
<a name="ln1087">      else</a>
<a name="ln1088">      {</a>
<a name="ln1089">        masks_border = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/border&quot;);</a>
<a name="ln1090">        flags = dt_conf_get_int(&quot;plugins/darkroom/masks/ellipse/flags&quot;);</a>
<a name="ln1091">        radius_a = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;);</a>
<a name="ln1092">        radius_b = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;);</a>
<a name="ln1093">        rotation = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/rotation&quot;);</a>
<a name="ln1094">      }</a>
<a name="ln1095"> </a>
<a name="ln1096">      float pzx = gui-&gt;posx;</a>
<a name="ln1097">      float pzy = gui-&gt;posy;</a>
<a name="ln1098"> </a>
<a name="ln1099">      if((pzx == -1.f &amp;&amp; pzy == -1.f) || gui-&gt;mouse_leaved_center)</a>
<a name="ln1100">      {</a>
<a name="ln1101">        const float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln1102">        const float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln1103">        pzx = (.5f + zoom_x) * darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1104">        pzy = (.5f + zoom_y) * darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1105">      }</a>
<a name="ln1106"> </a>
<a name="ln1107">      float pts[2] = { pzx, pzy };</a>
<a name="ln1108">      dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln1109">      x = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln1110">      y = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln1111"> </a>
<a name="ln1112">      float *points = NULL;</a>
<a name="ln1113">      int points_count = 0;</a>
<a name="ln1114">      float *border = NULL;</a>
<a name="ln1115">      int border_count = 0;</a>
<a name="ln1116"> </a>
<a name="ln1117">      int draw = 0;</a>
<a name="ln1118"> </a>
<a name="ln1119">      draw = dt_ellipse_get_points(darktable.develop, x, y, radius_a, radius_b, rotation, &amp;points, &amp;points_count);</a>
<a name="ln1120">      if(draw &amp;&amp; masks_border &gt; 0.f)</a>
<a name="ln1121">      {</a>
<a name="ln1122">        draw = dt_ellipse_get_points(</a>
<a name="ln1123">            darktable.develop, x, y,</a>
<a name="ln1124">            (flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? radius_a * (1.0f + masks_border) : radius_a + masks_border),</a>
<a name="ln1125">            (flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? radius_b * (1.0f + masks_border) : radius_b + masks_border),</a>
<a name="ln1126">            rotation, &amp;border, &amp;border_count);</a>
<a name="ln1127">      }</a>
<a name="ln1128"> </a>
<a name="ln1129">      if(draw &amp;&amp; points_count &gt;= 2)</a>
<a name="ln1130">      {</a>
<a name="ln1131">        xref = points[0];</a>
<a name="ln1132">        yref = points[1];</a>
<a name="ln1133"> </a>
<a name="ln1134">        dt_ellipse_draw_shape(cr, dashed, 0, zoom_scale, dx, dy, xref, yref, sinv, cosv, scalea, scaleb, points,</a>
<a name="ln1135">                              points_count);</a>
<a name="ln1136">      }</a>
<a name="ln1137">      if(draw &amp;&amp; border_count &gt;= 2)</a>
<a name="ln1138">      {</a>
<a name="ln1139">        xref = border[0];</a>
<a name="ln1140">        yref = border[1];</a>
<a name="ln1141"> </a>
<a name="ln1142">        dt_ellipse_draw_border(cr, dashed, len, 0, zoom_scale, dx, dy, xref, yref, sinv, cosv, scaleab, scalebb,</a>
<a name="ln1143">                               border, border_count);</a>
<a name="ln1144">      }</a>
<a name="ln1145"> </a>
<a name="ln1146">      // draw a cross where the source will be created</a>
<a name="ln1147">      if(form-&gt;type &amp; DT_MASKS_CLONE)</a>
<a name="ln1148">      {</a>
<a name="ln1149">        float x = 0.f, y = 0.f;</a>
<a name="ln1150">        dt_masks_calculate_source_pos_value(gui, DT_MASKS_ELLIPSE, pzx, pzy, pzx, pzy, &amp;x, &amp;y, FALSE);</a>
<a name="ln1151">        dt_masks_draw_clone_source_pos(cr, zoom_scale, x, y);</a>
<a name="ln1152">      }</a>
<a name="ln1153"> </a>
<a name="ln1154">      if(points) free(points);</a>
<a name="ln1155">      if(border) free(border);</a>
<a name="ln1156">    }</a>
<a name="ln1157">    return;</a>
<a name="ln1158">  }</a>
<a name="ln1159"> </a>
<a name="ln1160">  if(!gpt) return;</a>
<a name="ln1161"> </a>
<a name="ln1162">  const float r = atan2(gpt-&gt;points[3] - gpt-&gt;points[1], gpt-&gt;points[2] - gpt-&gt;points[0]);</a>
<a name="ln1163">  const float sinr = sin(r);</a>
<a name="ln1164">  const float cosr = cos(r);</a>
<a name="ln1165"> </a>
<a name="ln1166">  xref = gpt-&gt;points[0];</a>
<a name="ln1167">  yref = gpt-&gt;points[1];</a>
<a name="ln1168"> </a>
<a name="ln1169">  if(gpt-&gt;source_count &gt; 10)</a>
<a name="ln1170">  {</a>
<a name="ln1171">    xrefs = gpt-&gt;source[0];</a>
<a name="ln1172">    yrefs = gpt-&gt;source[1];</a>
<a name="ln1173">  }</a>
<a name="ln1174">  if((gui-&gt;group_selected == index) &amp;&amp; gui-&gt;form_dragging)</a>
<a name="ln1175">  {</a>
<a name="ln1176">    dx = gui-&gt;posx + gui-&gt;dx - xref;</a>
<a name="ln1177">    dy = gui-&gt;posy + gui-&gt;dy - yref;</a>
<a name="ln1178">  }</a>
<a name="ln1179">  else if((gui-&gt;group_selected == index) &amp;&amp; gui-&gt;source_dragging)</a>
<a name="ln1180">  {</a>
<a name="ln1181">    xrefs = gpt-&gt;source[0], yrefs = gpt-&gt;source[1];</a>
<a name="ln1182">    dxs = gui-&gt;posx + gui-&gt;dx - xrefs;</a>
<a name="ln1183">    dys = gui-&gt;posy + gui-&gt;dy - yrefs;</a>
<a name="ln1184">  }</a>
<a name="ln1185">  else if((gui-&gt;group_selected == index) &amp;&amp; gui-&gt;form_rotating)</a>
<a name="ln1186">  {</a>
<a name="ln1187">    const float v = atan2(gui-&gt;posy - yref, gui-&gt;posx - xref) - atan2(-gui-&gt;dy, -gui-&gt;dx);</a>
<a name="ln1188">    sinv = sin(v);</a>
<a name="ln1189">    cosv = cos(v);</a>
<a name="ln1190">  }</a>
<a name="ln1191">  else if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;point_dragging &gt;= 1))</a>
<a name="ln1192">  {</a>
<a name="ln1193">    const int k = gui-&gt;point_dragging;</a>
<a name="ln1194">    const float rx = gpt-&gt;points[k * 2] - xref;</a>
<a name="ln1195">    const float ry = gpt-&gt;points[k * 2 + 1] - yref;</a>
<a name="ln1196">    const float bx = gpt-&gt;border[k * 2] - xref;</a>
<a name="ln1197">    const float by = gpt-&gt;border[k * 2 + 1] - yref;</a>
<a name="ln1198">    const float deltax = gui-&gt;posx + gui-&gt;dx - xref;</a>
<a name="ln1199">    const float deltay = gui-&gt;posy + gui-&gt;dy - yref;</a>
<a name="ln1200"> </a>
<a name="ln1201">    const float r = sqrtf(rx * rx + ry * ry);</a>
<a name="ln1202">    const float b = sqrtf(bx * bx + by * by);</a>
<a name="ln1203">    float d = (rx * deltax + ry * deltay) / r;</a>
<a name="ln1204">    if(r + d &lt; 0) d = -r;</a>
<a name="ln1205"> </a>
<a name="ln1206">    if(k == 1 || k == 2)</a>
<a name="ln1207">    {</a>
<a name="ln1208">      scalea = r &gt; 0 ? (r + d) / r : 0;</a>
<a name="ln1209">      scaleab = b &gt; 0 ? (b + d) / b : 0;</a>
<a name="ln1210">    }</a>
<a name="ln1211">    else</a>
<a name="ln1212">    {</a>
<a name="ln1213">      scaleb = r &gt; 0 ? (r + d) / r : 0;</a>
<a name="ln1214">      scalebb = b &gt; 0 ? (b + d) / b : 0;</a>
<a name="ln1215">    }</a>
<a name="ln1216">  }</a>
<a name="ln1217"> </a>
<a name="ln1218">  float x, y;</a>
<a name="ln1219"> </a>
<a name="ln1220">  // draw shape</a>
<a name="ln1221">  dt_ellipse_draw_shape(cr, dashed, 0, zoom_scale, dx, dy, xref, yref, sinv, cosv, scalea, scaleb, gpt-&gt;points,</a>
<a name="ln1222">                        gpt-&gt;points_count);</a>
<a name="ln1223"> </a>
<a name="ln1224">  // draw anchor points</a>
<a name="ln1225">  if(TRUE)</a>
<a name="ln1226">  {</a>
<a name="ln1227">    cairo_set_dash(cr, dashed, 0, 0);</a>
<a name="ln1228">    float anchor_size; // = (gui-&gt;form_dragging || gui-&gt;form_selected) ? 7.0f / zoom_scale : 5.0f /</a>
<a name="ln1229">                       // zoom_scale;</a>
<a name="ln1230"> </a>
<a name="ln1231">    for(int i = 1; i &lt; 5; i++)</a>
<a name="ln1232">    {</a>
<a name="ln1233">      cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln1234"> </a>
<a name="ln1235">      if(i == gui-&gt;point_dragging || i == gui-&gt;point_selected)</a>
<a name="ln1236">        anchor_size = 7.0f / zoom_scale;</a>
<a name="ln1237">      else</a>
<a name="ln1238">        anchor_size = 5.0f / zoom_scale;</a>
<a name="ln1239"> </a>
<a name="ln1240">      _ellipse_point_transform(xref, yref, gpt-&gt;points[i * 2] + dx, gpt-&gt;points[i * 2 + 1] + dy, sinr, cosr,</a>
<a name="ln1241">                               scalea, scaleb, sinv, cosv, &amp;x, &amp;y);</a>
<a name="ln1242">      cairo_rectangle(cr, x - (anchor_size * 0.5), y - (anchor_size * 0.5), anchor_size, anchor_size);</a>
<a name="ln1243">      cairo_fill_preserve(cr);</a>
<a name="ln1244">      if((gui-&gt;group_selected == index) &amp;&amp; (i == gui-&gt;point_dragging || i == gui-&gt;point_selected))</a>
<a name="ln1245">        cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln1246">      if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_dragging || gui-&gt;form_selected))</a>
<a name="ln1247">        cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln1248">      else</a>
<a name="ln1249">        cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln1250">      cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln1251">      cairo_stroke(cr);</a>
<a name="ln1252">    }</a>
<a name="ln1253">  }</a>
<a name="ln1254"> </a>
<a name="ln1255">  // draw border</a>
<a name="ln1256">  if(gui-&gt;group_selected == index)</a>
<a name="ln1257">  {</a>
<a name="ln1258">    dt_ellipse_draw_border(cr, dashed, len, 0, zoom_scale, dx, dy, xref, yref, sinv, cosv, scaleab, scalebb,</a>
<a name="ln1259">                           gpt-&gt;border, gpt-&gt;border_count);</a>
<a name="ln1260">  }</a>
<a name="ln1261"> </a>
<a name="ln1262">  // draw the source if any</a>
<a name="ln1263">  if(gpt-&gt;source_count &gt; 10)</a>
<a name="ln1264">  {</a>
<a name="ln1265">    // compute the dest inner ellipse intersection with the line from source center to dest center.</a>
<a name="ln1266">    float cdx = gpt-&gt;source[0] + dxs - gpt-&gt;points[0] - dx;</a>
<a name="ln1267">    float cdy = gpt-&gt;source[1] + dys - gpt-&gt;points[1] - dy;</a>
<a name="ln1268"> </a>
<a name="ln1269">    // we don't draw the line if source==point</a>
<a name="ln1270">    if(cdx != 0.0 &amp;&amp; cdy != 0.0)</a>
<a name="ln1271">    {</a>
<a name="ln1272">      cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln1273">      float cangle = atan(cdx / cdy);</a>
<a name="ln1274"> </a>
<a name="ln1275">      if(cdy &gt; 0)</a>
<a name="ln1276">        cangle = (M_PI / 2) - cangle;</a>
<a name="ln1277">      else</a>
<a name="ln1278">        cangle = -(M_PI / 2) - cangle;</a>
<a name="ln1279"> </a>
<a name="ln1280">      float arrowx = gpt-&gt;points[0] + dx;</a>
<a name="ln1281">      float arrowy = gpt-&gt;points[1] + dy;</a>
<a name="ln1282"> </a>
<a name="ln1283">      cairo_move_to(cr, gpt-&gt;source[0] + dxs, gpt-&gt;source[1] + dys); // source center</a>
<a name="ln1284">      cairo_line_to(cr, arrowx, arrowy);                             // dest border</a>
<a name="ln1285">      // then draw to line for the arrow itself</a>
<a name="ln1286">      const float arrow_scale = 8.0;</a>
<a name="ln1287">      cairo_move_to(cr, arrowx + arrow_scale * cos(cangle + (0.4)),</a>
<a name="ln1288">                    arrowy + arrow_scale * sin(cangle + (0.4)));</a>
<a name="ln1289">      cairo_line_to(cr, arrowx, arrowy);</a>
<a name="ln1290">      cairo_line_to(cr, arrowx + arrow_scale * cos(cangle - (0.4)),</a>
<a name="ln1291">                    arrowy + arrow_scale * sin(cangle - (0.4)));</a>
<a name="ln1292"> </a>
<a name="ln1293">      cairo_set_dash(cr, dashed, 0, 0);</a>
<a name="ln1294">      if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging))</a>
<a name="ln1295">        cairo_set_line_width(cr, 2.5 / zoom_scale);</a>
<a name="ln1296">      else</a>
<a name="ln1297">        cairo_set_line_width(cr, 1.5 / zoom_scale);</a>
<a name="ln1298">      cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln1299">      cairo_stroke_preserve(cr);</a>
<a name="ln1300">      if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging))</a>
<a name="ln1301">        cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln1302">      else</a>
<a name="ln1303">        cairo_set_line_width(cr, 0.5 / zoom_scale);</a>
<a name="ln1304">      cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln1305">      cairo_stroke(cr);</a>
<a name="ln1306">    }</a>
<a name="ln1307"> </a>
<a name="ln1308">    // we draw the source</a>
<a name="ln1309">    cairo_set_dash(cr, dashed, 0, 0);</a>
<a name="ln1310">    if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging))</a>
<a name="ln1311">      cairo_set_line_width(cr, 2.5 / zoom_scale);</a>
<a name="ln1312">    else</a>
<a name="ln1313">      cairo_set_line_width(cr, 1.5 / zoom_scale);</a>
<a name="ln1314">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln1315">    _ellipse_point_transform(xrefs, yrefs, gpt-&gt;source[10] + dxs, gpt-&gt;source[11] + dys, sinr, cosr, scalea,</a>
<a name="ln1316">                             scaleb, sinv, cosv, &amp;x, &amp;y);</a>
<a name="ln1317">    cairo_move_to(cr, x, y);</a>
<a name="ln1318">    for(int i = 6; i &lt; gpt-&gt;source_count; i++)</a>
<a name="ln1319">    {</a>
<a name="ln1320">      _ellipse_point_transform(xrefs, yrefs, gpt-&gt;source[i * 2] + dxs, gpt-&gt;source[i * 2 + 1] + dys, sinr,</a>
<a name="ln1321">                               cosr, scalea, scaleb, sinv, cosv, &amp;x, &amp;y);</a>
<a name="ln1322">      cairo_line_to(cr, x, y);</a>
<a name="ln1323">    }</a>
<a name="ln1324">    _ellipse_point_transform(xrefs, yrefs, gpt-&gt;source[10] + dxs, gpt-&gt;source[11] + dys, sinr, cosr, scalea,</a>
<a name="ln1325">                             scaleb, sinv, cosv, &amp;x, &amp;y);</a>
<a name="ln1326">    cairo_line_to(cr, x, y);</a>
<a name="ln1327">    cairo_stroke_preserve(cr);</a>
<a name="ln1328">    if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging))</a>
<a name="ln1329">      cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln1330">    else</a>
<a name="ln1331">      cairo_set_line_width(cr, 0.5 / zoom_scale);</a>
<a name="ln1332">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln1333">    cairo_stroke(cr);</a>
<a name="ln1334">  }</a>
<a name="ln1335">}</a>
<a name="ln1336"> </a>
<a name="ln1337">static int dt_ellipse_get_source_area(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1338">                                      dt_masks_form_t *form, int *width, int *height, int *posx, int *posy)</a>
<a name="ln1339">{</a>
<a name="ln1340">  // we get the ellipse values</a>
<a name="ln1341">  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln1342">  const float wd = piece-&gt;pipe-&gt;iwidth, ht = piece-&gt;pipe-&gt;iheight;</a>
<a name="ln1343"> </a>
<a name="ln1344">  const float total[2] = { (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[0] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[0] + ellipse-&gt;border) * MIN(wd, ht),</a>
<a name="ln1345">                           (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[1] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[1] + ellipse-&gt;border) * MIN(wd, ht) };</a>
<a name="ln1346">  const float v1 = ((ellipse-&gt;rotation) / 180.0f) * M_PI;</a>
<a name="ln1347">  const float v2 = ((ellipse-&gt;rotation - 90.0f) / 180.0f) * M_PI;</a>
<a name="ln1348">  float a, b, v;</a>
<a name="ln1349"> </a>
<a name="ln1350">  if(total[0] &gt;= total[1])</a>
<a name="ln1351">  {</a>
<a name="ln1352">    a = total[0];</a>
<a name="ln1353">    b = total[1];</a>
<a name="ln1354">    v = v1;</a>
<a name="ln1355">  }</a>
<a name="ln1356">  else</a>
<a name="ln1357">  {</a>
<a name="ln1358">    a = total[1];</a>
<a name="ln1359">    b = total[0];</a>
<a name="ln1360">    v = v2;</a>
<a name="ln1361">  }</a>
<a name="ln1362"> </a>
<a name="ln1363">  const float sinv = sinf(v);</a>
<a name="ln1364">  const float cosv = cosf(v);</a>
<a name="ln1365"> </a>
<a name="ln1366">  // how many points do we need ?</a>
<a name="ln1367">  const float lambda = (a - b) / (a + b);</a>
<a name="ln1368">  const int l = (int)(M_PI * (a + b)</a>
<a name="ln1369">                      * (1.0f + (3.0f * lambda * lambda) / (10.0f + sqrtf(4.0f - 3.0f * lambda * lambda))));</a>
<a name="ln1370"> </a>
<a name="ln1371">  // buffer allocations</a>
<a name="ln1372">  float *points = calloc(2 * (l + 5), sizeof(float));</a>
<a name="ln1373"> </a>
<a name="ln1374">  // now we set the points</a>
<a name="ln1375">  const float x = points[0] = ellipse-&gt;center[0] * wd;</a>
<a name="ln1376">  const float y = points[1] = ellipse-&gt;center[1] * ht;</a>
<a name="ln1377"> </a>
<a name="ln1378">  points[2] = x + a * cos(v);</a>
<a name="ln1379">  points[3] = y + a * sin(v);</a>
<a name="ln1380">  points[4] = x - a * cos(v);</a>
<a name="ln1381">  points[5] = y - a * sin(v);</a>
<a name="ln1382"> </a>
<a name="ln1383">  points[6] = x + b * cos(v - M_PI / 2.0f);</a>
<a name="ln1384">  points[7] = y + b * sin(v - M_PI / 2.0f);</a>
<a name="ln1385">  points[8] = x - b * cos(v - M_PI / 2.0f);</a>
<a name="ln1386">  points[9] = y - b * sin(v - M_PI / 2.0f);</a>
<a name="ln1387"> </a>
<a name="ln1388">  for(int i = 1; i &lt; l + 5; i++)</a>
<a name="ln1389">  {</a>
<a name="ln1390">    float alpha = (i - 5) * 2.0 * M_PI / (float)l;</a>
<a name="ln1391">    points[i * 2] = points[0] + a * cosf(alpha) * cosv - b * sinf(alpha) * sinv;</a>
<a name="ln1392">    points[i * 2 + 1] = points[1] + a * cosf(alpha) * sinv + b * sinf(alpha) * cosv;</a>
<a name="ln1393">  }</a>
<a name="ln1394"> </a>
<a name="ln1395">  // and we transform them with all distorted modules</a>
<a name="ln1396">  if(!dt_dev_distort_transform_plus(darktable.develop, piece-&gt;pipe, 0, module-&gt;priority, points, l + 5))</a>
<a name="ln1397">  {</a>
<a name="ln1398">    free(points);</a>
<a name="ln1399">    return 0;</a>
<a name="ln1400">  }</a>
<a name="ln1401"> </a>
<a name="ln1402">  // now we search min and max</a>
<a name="ln1403">  float xmin, xmax, ymin, ymax;</a>
<a name="ln1404">  xmin = ymin = FLT_MAX;</a>
<a name="ln1405">  xmax = ymax = FLT_MIN;</a>
<a name="ln1406">  for(int i = 1; i &lt; l + 5; i++)</a>
<a name="ln1407">  {</a>
<a name="ln1408">    xmin = fminf(points[i * 2], xmin);</a>
<a name="ln1409">    xmax = fmaxf(points[i * 2], xmax);</a>
<a name="ln1410">    ymin = fminf(points[i * 2 + 1], ymin);</a>
<a name="ln1411">    ymax = fmaxf(points[i * 2 + 1], ymax);</a>
<a name="ln1412">  }</a>
<a name="ln1413">  free(points);</a>
<a name="ln1414">  // and we set values</a>
<a name="ln1415">  *posx = xmin;</a>
<a name="ln1416">  *posy = ymin;</a>
<a name="ln1417">  *width = (xmax - xmin);</a>
<a name="ln1418">  *height = (ymax - ymin);</a>
<a name="ln1419">  return 1;</a>
<a name="ln1420">}</a>
<a name="ln1421"> </a>
<a name="ln1422">static int dt_ellipse_get_area(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, dt_masks_form_t *form,</a>
<a name="ln1423">                               int *width, int *height, int *posx, int *posy)</a>
<a name="ln1424">{</a>
<a name="ln1425">  // we get the ellipse values</a>
<a name="ln1426">  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln1427"> </a>
<a name="ln1428">  const float wd = piece-&gt;pipe-&gt;iwidth, ht = piece-&gt;pipe-&gt;iheight;</a>
<a name="ln1429"> </a>
<a name="ln1430">  const float total[2] = { (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[0] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[0] + ellipse-&gt;border) * MIN(wd, ht),</a>
<a name="ln1431">                           (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[1] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[1] + ellipse-&gt;border) * MIN(wd, ht) };</a>
<a name="ln1432">  const float v1 = ((ellipse-&gt;rotation) / 180.0f) * M_PI;</a>
<a name="ln1433">  const float v2 = ((ellipse-&gt;rotation - 90.0f) / 180.0f) * M_PI;</a>
<a name="ln1434">  float a, b, v;</a>
<a name="ln1435"> </a>
<a name="ln1436">  if(total[0] &gt;= total[1])</a>
<a name="ln1437">  {</a>
<a name="ln1438">    a = total[0];</a>
<a name="ln1439">    b = total[1];</a>
<a name="ln1440">    v = v1;</a>
<a name="ln1441">  }</a>
<a name="ln1442">  else</a>
<a name="ln1443">  {</a>
<a name="ln1444">    a = total[1];</a>
<a name="ln1445">    b = total[0];</a>
<a name="ln1446">    v = v2;</a>
<a name="ln1447">  }</a>
<a name="ln1448"> </a>
<a name="ln1449">  const float sinv = sinf(v);</a>
<a name="ln1450">  const float cosv = cosf(v);</a>
<a name="ln1451"> </a>
<a name="ln1452">  // how many points do we need ?</a>
<a name="ln1453">  const float lambda = (a - b) / (a + b);</a>
<a name="ln1454">  const int l = (int)(M_PI * (a + b)</a>
<a name="ln1455">                      * (1.0f + (3.0f * lambda * lambda) / (10.0f + sqrtf(4.0f - 3.0f * lambda * lambda))));</a>
<a name="ln1456"> </a>
<a name="ln1457">  // buffer allocations</a>
<a name="ln1458">  float *points = calloc(2 * (l + 5), sizeof(float));</a>
<a name="ln1459"> </a>
<a name="ln1460">  // now we set the points</a>
<a name="ln1461">  const float x = points[0] = ellipse-&gt;center[0] * wd;</a>
<a name="ln1462">  const float y = points[1] = ellipse-&gt;center[1] * ht;</a>
<a name="ln1463"> </a>
<a name="ln1464">  points[2] = x + a * cos(v);</a>
<a name="ln1465">  points[3] = y + a * sin(v);</a>
<a name="ln1466">  points[4] = x - a * cos(v);</a>
<a name="ln1467">  points[5] = y - a * sin(v);</a>
<a name="ln1468"> </a>
<a name="ln1469">  points[6] = x + b * cos(v - M_PI / 2.0f);</a>
<a name="ln1470">  points[7] = y + b * sin(v - M_PI / 2.0f);</a>
<a name="ln1471">  points[8] = x - b * cos(v - M_PI / 2.0f);</a>
<a name="ln1472">  points[9] = y - b * sin(v - M_PI / 2.0f);</a>
<a name="ln1473"> </a>
<a name="ln1474">  for(int i = 5; i &lt; l + 5; i++)</a>
<a name="ln1475">  {</a>
<a name="ln1476">    float alpha = (i - 5) * 2.0 * M_PI / (float)l;</a>
<a name="ln1477">    points[i * 2] = x + a * cosf(alpha) * cosv - b * sinf(alpha) * sinv;</a>
<a name="ln1478">    points[i * 2 + 1] = y + a * cosf(alpha) * sinv + b * sinf(alpha) * cosv;</a>
<a name="ln1479">  }</a>
<a name="ln1480"> </a>
<a name="ln1481">  // and we transform them with all distorted modules</a>
<a name="ln1482">  if(!dt_dev_distort_transform_plus(module-&gt;dev, piece-&gt;pipe, 0, module-&gt;priority, points, l + 5))</a>
<a name="ln1483">  {</a>
<a name="ln1484">    free(points);</a>
<a name="ln1485">    return 0;</a>
<a name="ln1486">  }</a>
<a name="ln1487"> </a>
<a name="ln1488">  // now we search min and max</a>
<a name="ln1489">  float xmin, xmax, ymin, ymax;</a>
<a name="ln1490">  xmin = ymin = FLT_MAX;</a>
<a name="ln1491">  xmax = ymax = FLT_MIN;</a>
<a name="ln1492">  for(int i = 5; i &lt; l + 5; i++)</a>
<a name="ln1493">  {</a>
<a name="ln1494">    xmin = fminf(points[i * 2], xmin);</a>
<a name="ln1495">    xmax = fmaxf(points[i * 2], xmax);</a>
<a name="ln1496">    ymin = fminf(points[i * 2 + 1], ymin);</a>
<a name="ln1497">    ymax = fmaxf(points[i * 2 + 1], ymax);</a>
<a name="ln1498">  }</a>
<a name="ln1499">  free(points);</a>
<a name="ln1500"> </a>
<a name="ln1501">  // and we set values</a>
<a name="ln1502">  *posx = xmin;</a>
<a name="ln1503">  *posy = ymin;</a>
<a name="ln1504">  *width = (xmax - xmin);</a>
<a name="ln1505">  *height = (ymax - ymin);</a>
<a name="ln1506">  return 1;</a>
<a name="ln1507">}</a>
<a name="ln1508"> </a>
<a name="ln1509">static int dt_ellipse_get_mask(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, dt_masks_form_t *form,</a>
<a name="ln1510">                               float **buffer, int *width, int *height, int *posx, int *posy)</a>
<a name="ln1511">{</a>
<a name="ln1512">  double start2 = dt_get_wtime();</a>
<a name="ln1513"> </a>
<a name="ln1514">  // we get the area</a>
<a name="ln1515">  if(!dt_ellipse_get_area(module, piece, form, width, height, posx, posy)) return 0;</a>
<a name="ln1516"> </a>
<a name="ln1517">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1518">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse area took %0.04f sec\n&quot;, form-&gt;name, dt_get_wtime() - start2);</a>
<a name="ln1519">  start2 = dt_get_wtime();</a>
<a name="ln1520"> </a>
<a name="ln1521">  // we get the ellipse values</a>
<a name="ln1522">  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln1523"> </a>
<a name="ln1524">  // we create a buffer of points with all points in the area</a>
<a name="ln1525">  int w = *width, h = *height;</a>
<a name="ln1526">  float *points = malloc(w * h * 2 * sizeof(float));</a>
<a name="ln1527">  for(int i = 0; i &lt; h; i++)</a>
<a name="ln1528">    for(int j = 0; j &lt; w; j++)</a>
<a name="ln1529">    {</a>
<a name="ln1530">      points[(i * w + j) * 2] = (j + (*posx));</a>
<a name="ln1531">      points[(i * w + j) * 2 + 1] = (i + (*posy));</a>
<a name="ln1532">    }</a>
<a name="ln1533"> </a>
<a name="ln1534">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1535">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse draw took %0.04f sec\n&quot;, form-&gt;name, dt_get_wtime() - start2);</a>
<a name="ln1536">  start2 = dt_get_wtime();</a>
<a name="ln1537"> </a>
<a name="ln1538">  // we back transform all this points</a>
<a name="ln1539">  if(!dt_dev_distort_backtransform_plus(module-&gt;dev, piece-&gt;pipe, 0, module-&gt;priority, points, w * h))</a>
<a name="ln1540">  {</a>
<a name="ln1541">    free(points);</a>
<a name="ln1542">    return 0;</a>
<a name="ln1543">  }</a>
<a name="ln1544"> </a>
<a name="ln1545">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1546">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse transform took %0.04f sec\n&quot;, form-&gt;name,</a>
<a name="ln1547">             dt_get_wtime() - start2);</a>
<a name="ln1548">  start2 = dt_get_wtime();</a>
<a name="ln1549"> </a>
<a name="ln1550">  // we allocate the buffer</a>
<a name="ln1551">  *buffer = calloc(w * h, sizeof(float));</a>
<a name="ln1552"> </a>
<a name="ln1553">  // we populate the buffer</a>
<a name="ln1554">  const int wi = piece-&gt;pipe-&gt;iwidth, hi = piece-&gt;pipe-&gt;iheight;</a>
<a name="ln1555">  const float center[2] = { ellipse-&gt;center[0] * wi, ellipse-&gt;center[1] * hi };</a>
<a name="ln1556">  const float radius[2] = { ellipse-&gt;radius[0] * MIN(wi, hi), ellipse-&gt;radius[1] * MIN(wi, hi) };</a>
<a name="ln1557">  const float total[2] =  { (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[0] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[0] + ellipse-&gt;border) * MIN(wi, hi),</a>
<a name="ln1558">                            (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[1] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[1] + ellipse-&gt;border) * MIN(wi, hi) };</a>
<a name="ln1559"> </a>
<a name="ln1560">  float a, b, ta, tb, alpha;</a>
<a name="ln1561"> </a>
<a name="ln1562">  if(radius[0] &gt;= radius[1])</a>
<a name="ln1563">  {</a>
<a name="ln1564">    a = radius[0];</a>
<a name="ln1565">    b = radius[1];</a>
<a name="ln1566">    ta = total[0];</a>
<a name="ln1567">    tb = total[1];</a>
<a name="ln1568">    alpha = (ellipse-&gt;rotation / 180.0f) * M_PI;</a>
<a name="ln1569">  }</a>
<a name="ln1570">  else</a>
<a name="ln1571">  {</a>
<a name="ln1572">    a = radius[1];</a>
<a name="ln1573">    b = radius[0];</a>
<a name="ln1574">    ta = total[1];</a>
<a name="ln1575">    tb = total[0];</a>
<a name="ln1576">    alpha = ((ellipse-&gt;rotation - 90.0f) / 180.0f) * M_PI;</a>
<a name="ln1577">  }</a>
<a name="ln1578"> </a>
<a name="ln1579">  for(int i = 0; i &lt; h; i++)</a>
<a name="ln1580">    for(int j = 0; j &lt; w; j++)</a>
<a name="ln1581">    {</a>
<a name="ln1582">      float x = points[(i * w + j) * 2] - center[0];</a>
<a name="ln1583">      float y = points[(i * w + j) * 2 + 1] - center[1];</a>
<a name="ln1584">      float v = atan2(y, x) - alpha;</a>
<a name="ln1585">      float cosv = cos(v);</a>
<a name="ln1586">      float sinv = sin(v);</a>
<a name="ln1587">      float radius2 = a * a * b * b / (a * a * sinv * sinv + b * b * cosv * cosv);</a>
<a name="ln1588">      float total2 = ta * ta * tb * tb / (ta * ta * sinv * sinv + tb * tb * cosv * cosv);</a>
<a name="ln1589">      float l2 = x * x + y * y;</a>
<a name="ln1590"> </a>
<a name="ln1591">      if(l2 &lt; radius2)</a>
<a name="ln1592">        (*buffer)[i * w + j] = 1.0f;</a>
<a name="ln1593">      else if(l2 &lt; total2)</a>
<a name="ln1594">      {</a>
<a name="ln1595">        float f = (total2 - l2) / (total2 - radius2);</a>
<a name="ln1596">        (*buffer)[i * w + j] = f * f;</a>
<a name="ln1597">      }</a>
<a name="ln1598">      else</a>
<a name="ln1599">        (*buffer)[i * w + j] = 0.0f;</a>
<a name="ln1600">    }</a>
<a name="ln1601">  free(points);</a>
<a name="ln1602"> </a>
<a name="ln1603">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1604">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse fill took %0.04f sec\n&quot;, form-&gt;name, dt_get_wtime() - start2);</a>
<a name="ln1605">//   start2 = dt_get_wtime();</a>
<a name="ln1606"> </a>
<a name="ln1607">  return 1;</a>
<a name="ln1608">}</a>
<a name="ln1609"> </a>
<a name="ln1610"> </a>
<a name="ln1611">static int dt_ellipse_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1612">                                   dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer)</a>
<a name="ln1613">{</a>
<a name="ln1614">  double start2 = dt_get_wtime();</a>
<a name="ln1615"> </a>
<a name="ln1616">  // we get the ellipse values</a>
<a name="ln1617">  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln1618"> </a>
<a name="ln1619">  // we create a buffer of mesh points for later interpolation. mainly in order to reduce memory footprint</a>
<a name="ln1620">  const int w = roi-&gt;width;</a>
<a name="ln1621">  const int h = roi-&gt;height;</a>
<a name="ln1622">  const int px = roi-&gt;x;</a>
<a name="ln1623">  const int py = roi-&gt;y;</a>
<a name="ln1624">  const float iscale = 1.0f / roi-&gt;scale;</a>
<a name="ln1625">  const int mesh = 4;</a>
<a name="ln1626">  const int mw = (w + mesh - 1) / mesh + 1;</a>
<a name="ln1627">  const int mh = (h + mesh - 1) / mesh + 1;</a>
<a name="ln1628"> </a>
<a name="ln1629">  float *points = malloc((size_t)mw * mh * 2 * sizeof(float));</a>
<a name="ln1630">  if(points == NULL) return 0;</a>
<a name="ln1631"> </a>
<a name="ln1632">#ifdef _OPENMP</a>
<a name="ln1633">#if !defined(__SUNOS__) &amp;&amp; !defined(__NetBSD__)</a>
<a name="ln1634">#pragma omp parallel for default(none) shared(points)</a>
<a name="ln1635">#else</a>
<a name="ln1636">#pragma omp parallel for shared(points)</a>
<a name="ln1637">#endif</a>
<a name="ln1638">#endif</a>
<a name="ln1639">  for(int j = 0; j &lt; mh; j++)</a>
<a name="ln1640">    for(int i = 0; i &lt; mw; i++)</a>
<a name="ln1641">    {</a>
<a name="ln1642">      size_t index = (size_t)j * mw + i;</a>
<a name="ln1643">      points[index * 2] = (mesh * i + px) * iscale;</a>
<a name="ln1644">      points[index * 2 + 1] = (mesh * j + py) * iscale;</a>
<a name="ln1645">    }</a>
<a name="ln1646"> </a>
<a name="ln1647">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1648">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse draw took %0.04f sec\n&quot;, form-&gt;name, dt_get_wtime() - start2);</a>
<a name="ln1649">  start2 = dt_get_wtime();</a>
<a name="ln1650"> </a>
<a name="ln1651">  // we back transform all these points</a>
<a name="ln1652">  if(!dt_dev_distort_backtransform_plus(module-&gt;dev, piece-&gt;pipe, 0, module-&gt;priority, points,</a>
<a name="ln1653">                                        (size_t)mw * mh))</a>
<a name="ln1654">  {</a>
<a name="ln1655">    free(points);</a>
<a name="ln1656">    return 0;</a>
<a name="ln1657">  }</a>
<a name="ln1658"> </a>
<a name="ln1659">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1660">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse transform took %0.04f sec\n&quot;, form-&gt;name,</a>
<a name="ln1661">             dt_get_wtime() - start2);</a>
<a name="ln1662">  start2 = dt_get_wtime();</a>
<a name="ln1663"> </a>
<a name="ln1664">  // we populate the buffer</a>
<a name="ln1665">  const int wi = piece-&gt;pipe-&gt;iwidth, hi = piece-&gt;pipe-&gt;iheight;</a>
<a name="ln1666">  const float center[2] = { ellipse-&gt;center[0] * wi, ellipse-&gt;center[1] * hi };</a>
<a name="ln1667">  const float radius[2] = { ellipse-&gt;radius[0] * MIN(wi, hi), ellipse-&gt;radius[1] * MIN(wi, hi) };</a>
<a name="ln1668">  const float total[2] = { (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[0] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[0] + ellipse-&gt;border) * MIN(wi, hi),</a>
<a name="ln1669">                           (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[1] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[1] + ellipse-&gt;border) * MIN(wi, hi) };</a>
<a name="ln1670"> </a>
<a name="ln1671">  float a, b, ta, tb, alpha;</a>
<a name="ln1672"> </a>
<a name="ln1673">  if(radius[0] &gt;= radius[1])</a>
<a name="ln1674">  {</a>
<a name="ln1675">    a = radius[0];</a>
<a name="ln1676">    b = radius[1];</a>
<a name="ln1677">    ta = total[0];</a>
<a name="ln1678">    tb = total[1];</a>
<a name="ln1679">    alpha = (ellipse-&gt;rotation / 180.0f) * M_PI;</a>
<a name="ln1680">  }</a>
<a name="ln1681">  else</a>
<a name="ln1682">  {</a>
<a name="ln1683">    a = radius[1];</a>
<a name="ln1684">    b = radius[0];</a>
<a name="ln1685">    ta = total[1];</a>
<a name="ln1686">    tb = total[0];</a>
<a name="ln1687">    alpha = ((ellipse-&gt;rotation - 90.0f) / 180.0f) * M_PI;</a>
<a name="ln1688">  }</a>
<a name="ln1689"> </a>
<a name="ln1690">#ifdef _OPENMP</a>
<a name="ln1691">#if !defined(__SUNOS__) &amp;&amp; !defined(__NetBSD__)</a>
<a name="ln1692">#pragma omp parallel for default(none) shared(points, a, b, ta, tb, alpha)</a>
<a name="ln1693">#else</a>
<a name="ln1694">#pragma omp parallel for shared(points, a, b, ta, tb, alpha)</a>
<a name="ln1695">#endif</a>
<a name="ln1696">#endif</a>
<a name="ln1697">  for(int i = 0; i &lt; mh; i++)</a>
<a name="ln1698">    for(int j = 0; j &lt; mw; j++)</a>
<a name="ln1699">    {</a>
<a name="ln1700">      size_t index = (size_t)i * mw + j;</a>
<a name="ln1701">      float x = points[index * 2] - center[0];</a>
<a name="ln1702">      float y = points[index * 2 + 1] - center[1];</a>
<a name="ln1703">      float v = atan2(y, x) - alpha;</a>
<a name="ln1704">      float cosv = cos(v);</a>
<a name="ln1705">      float sinv = sin(v);</a>
<a name="ln1706">      float radius2 = a * a * b * b / (a * a * sinv * sinv + b * b * cosv * cosv);</a>
<a name="ln1707">      float total2 = ta * ta * tb * tb / (ta * ta * sinv * sinv + tb * tb * cosv * cosv);</a>
<a name="ln1708">      float l2 = x * x + y * y;</a>
<a name="ln1709"> </a>
<a name="ln1710">      if(l2 &lt; radius2)</a>
<a name="ln1711">        points[index * 2] = 1.0f;</a>
<a name="ln1712">      else if(l2 &lt; total2)</a>
<a name="ln1713">      {</a>
<a name="ln1714">        float f = (total2 - l2) / (total2 - radius2);</a>
<a name="ln1715">        points[index * 2] = f * f;</a>
<a name="ln1716">      }</a>
<a name="ln1717">      else</a>
<a name="ln1718">        points[index * 2] = 0.0f;</a>
<a name="ln1719">    }</a>
<a name="ln1720"> </a>
<a name="ln1721">// we fill the output buffer by interpolation</a>
<a name="ln1722">#ifdef _OPENMP</a>
<a name="ln1723">#if !defined(__SUNOS__) &amp;&amp; !defined(__NetBSD__)</a>
<a name="ln1724">#pragma omp parallel for default(none) shared(points, buffer)</a>
<a name="ln1725">#else</a>
<a name="ln1726">#pragma omp parallel for shared(points, buffer)</a>
<a name="ln1727">#endif</a>
<a name="ln1728">#endif</a>
<a name="ln1729">  for(int j = 0; j &lt; h; j++)</a>
<a name="ln1730">  {</a>
<a name="ln1731">    int jj = j % mesh;</a>
<a name="ln1732">    int mj = j / mesh;</a>
<a name="ln1733">    for(int i = 0; i &lt; w; i++)</a>
<a name="ln1734">    {</a>
<a name="ln1735">      int ii = i % mesh;</a>
<a name="ln1736">      int mi = i / mesh;</a>
<a name="ln1737">      size_t mindex = (size_t)mj * mw + mi;</a>
<a name="ln1738">      buffer[(size_t)j * w + i]</a>
<a name="ln1739">          = (points[mindex * 2] * (mesh - ii) * (mesh - jj) + points[(mindex + 1) * 2] * ii * (mesh - jj)</a>
<a name="ln1740">             + points[(mindex + mw) * 2] * (mesh - ii) * jj + points[(mindex + mw + 1) * 2] * ii * jj)</a>
<a name="ln1741">            / (mesh * mesh);</a>
<a name="ln1742">    }</a>
<a name="ln1743">  }</a>
<a name="ln1744"> </a>
<a name="ln1745">  free(points);</a>
<a name="ln1746"> </a>
<a name="ln1747"> </a>
<a name="ln1748">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1749">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse fill took %0.04f sec\n&quot;, form-&gt;name, dt_get_wtime() - start2);</a>
<a name="ln1750">//   start2 = dt_get_wtime();</a>
<a name="ln1751"> </a>
<a name="ln1752">  return 1;</a>
<a name="ln1753">}</a>
<a name="ln1754"> </a>
<a name="ln1755"> </a>
<a name="ln1756"> </a>
<a name="ln1757">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1758">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1759">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="614"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'ellipse'. Check lines: 614, 607.</p></div>
<div class="balloon" rel="1132"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'points' pointer was utilized before it was verified against nullptr. Check lines: 1132, 1154.</p></div>
<div class="balloon" rel="1140"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'border' pointer was utilized before it was verified against nullptr. Check lines: 1140, 1155.</p></div>
<div class="balloon" rel="1375"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'points'. Check lines: 1375, 1372.</p></div>
<div class="balloon" rel="1461"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'points'. Check lines: 1461, 1458.</p></div>
<div class="balloon" rel="1530"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'points'. Check lines: 1530, 1526.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
