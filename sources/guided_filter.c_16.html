
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2018-2019 Heiko Bauke.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">    Implementation of the guided image filter as described in</a>
<a name="ln20"> </a>
<a name="ln21">    &quot;Guided Image Filtering&quot; by Kaiming He, Jian Sun, and Xiaoou Tang in</a>
<a name="ln22">    K. Daniilidis, P. Maragos, N. Paragios (Eds.): ECCV 2010, Part I,</a>
<a name="ln23">    LNCS 6311, pp. 1-14, 2010. Springer-Verlag Berlin Heidelberg 2010</a>
<a name="ln24"> </a>
<a name="ln25">    &quot;Guided Image Filtering&quot; by Kaiming He, Jian Sun, and Xiaoou Tang in</a>
<a name="ln26">    IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 35,</a>
<a name="ln27">    no. 6, June 2013, 1397-1409</a>
<a name="ln28"> </a>
<a name="ln29">*/</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;common/guided_filter.h&quot;</a>
<a name="ln32">#include &quot;common/darktable.h&quot;</a>
<a name="ln33">#include &quot;common/opencl.h&quot;</a>
<a name="ln34">#include &lt;assert.h&gt;</a>
<a name="ln35">#include &lt;float.h&gt;</a>
<a name="ln36">#include &lt;stdlib.h&gt;</a>
<a name="ln37">#include &lt;string.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">typedef struct tile</a>
<a name="ln40">{</a>
<a name="ln41">  int left, right, lower, upper;</a>
<a name="ln42">} tile;</a>
<a name="ln43"> </a>
<a name="ln44">typedef struct color_image</a>
<a name="ln45">{</a>
<a name="ln46">  float *data;</a>
<a name="ln47">  int width, height, stride;</a>
<a name="ln48">} color_image;</a>
<a name="ln49"> </a>
<a name="ln50">static inline float *get_color_pixel(color_image img, size_t i)</a>
<a name="ln51">{</a>
<a name="ln52">  return img.data + i * img.stride;</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55">typedef struct gray_image</a>
<a name="ln56">{</a>
<a name="ln57">  float *data;</a>
<a name="ln58">  int width, height;</a>
<a name="ln59">} gray_image;</a>
<a name="ln60"> </a>
<a name="ln61">// allocate space for 1-component image of size width x height</a>
<a name="ln62">static inline gray_image new_gray_image(int width, int height)</a>
<a name="ln63">{</a>
<a name="ln64">  return (gray_image){ dt_alloc_align(64, sizeof(float) * width * height), width, height };</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67">// free space for 1-component image</a>
<a name="ln68">static inline void free_gray_image(gray_image *img_p)</a>
<a name="ln69">{</a>
<a name="ln70">  dt_free_align(img_p-&gt;data);</a>
<a name="ln71">  img_p-&gt;data = NULL;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">// minimum of two integers</a>
<a name="ln75">static inline int min_i(int a, int b)</a>
<a name="ln76">{</a>
<a name="ln77">  return a &lt; b ? a : b;</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">// maximum of two integers</a>
<a name="ln81">static inline int max_i(int a, int b)</a>
<a name="ln82">{</a>
<a name="ln83">  return a &gt; b ? a : b;</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">// calculate the one-dimensional moving average over a window of size 2*w+1</a>
<a name="ln87">// input array x has stride 1, output array y has stride stride_y</a>
<a name="ln88">static inline void box_mean_1d(int N, const float *x, float *y, size_t stride_y, int w)</a>
<a name="ln89">{</a>
<a name="ln90">  float m = 0.f, n_box = 0.f;</a>
<a name="ln91">  if(N &gt; 2 * w)</a>
<a name="ln92">  {</a>
<a name="ln93">    for(int i = 0, i_end = w + 1; i &lt; i_end; i++)</a>
<a name="ln94">    {</a>
<a name="ln95">      m += x[i];</a>
<a name="ln96">      n_box++;</a>
<a name="ln97">    }</a>
<a name="ln98">    for(int i = 0, i_end = w; i &lt; i_end; i++)</a>
<a name="ln99">    {</a>
<a name="ln100">      y[i * stride_y] = m / n_box;</a>
<a name="ln101">      m += x[i + w + 1];</a>
<a name="ln102">      n_box++;</a>
<a name="ln103">    }</a>
<a name="ln104">    for(int i = w, i_end = N - w - 1; i &lt; i_end; i++)</a>
<a name="ln105">    {</a>
<a name="ln106">      y[i * stride_y] = m / n_box;</a>
<a name="ln107">      m += x[i + w + 1] - x[i - w];</a>
<a name="ln108">    }</a>
<a name="ln109">    for(int i = N - w - 1, i_end = N; i &lt; i_end; i++)</a>
<a name="ln110">    {</a>
<a name="ln111">      y[i * stride_y] = m / n_box;</a>
<a name="ln112">      m -= x[i - w];</a>
<a name="ln113">      n_box--;</a>
<a name="ln114">    }</a>
<a name="ln115">  }</a>
<a name="ln116">  else</a>
<a name="ln117">  {</a>
<a name="ln118">    for(int i = 0, i_end = min_i(w + 1, N); i &lt; i_end; i++)</a>
<a name="ln119">    {</a>
<a name="ln120">      m += x[i];</a>
<a name="ln121">      n_box++;</a>
<a name="ln122">    }</a>
<a name="ln123">    for(int i = 0; i &lt; N; i++)</a>
<a name="ln124">    {</a>
<a name="ln125">      y[i * stride_y] = m / n_box;</a>
<a name="ln126">      if(i - w &gt;= 0)</a>
<a name="ln127">      {</a>
<a name="ln128">        m -= x[i - w];</a>
<a name="ln129">        n_box--;</a>
<a name="ln130">      }</a>
<a name="ln131">      if(i + w + 1 &lt; N)</a>
<a name="ln132">      {</a>
<a name="ln133">        m += x[i + w + 1];</a>
<a name="ln134">        n_box++;</a>
<a name="ln135">      }</a>
<a name="ln136">    }</a>
<a name="ln137">  }</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">// calculate the two-dimensional moving average over a box of size (2*w+1) x (2*w+1)</a>
<a name="ln141">// does the calculation in-place if input and ouput images are identical</a>
<a name="ln142">// this function is always called from a OpenMP thread, thus no parallelization</a>
<a name="ln143">static void box_mean(gray_image img1, gray_image img2, int w)</a>
<a name="ln144">{</a>
<a name="ln145">  gray_image img2_bak;</a>
<a name="ln146">  if(img1.data == img2.data)</a>
<a name="ln147">  {</a>
<a name="ln148">    img2_bak = new_gray_image(max_i(img2.width, img2.height), 1);</a>
<a name="ln149">    for(int i1 = 0; i1 &lt; img2.height; i1++)</a>
<a name="ln150">    {</a>
<a name="ln151">      memcpy(img2_bak.data, img2.data + (size_t)i1 * img2.width, sizeof(float) * img2.width);</a>
<a name="ln152">      box_mean_1d(img2.width, img2_bak.data, img2.data + (size_t)i1 * img2.width, 1, w);</a>
<a name="ln153">    }</a>
<a name="ln154">  }</a>
<a name="ln155">  else</a>
<a name="ln156">  {</a>
<a name="ln157">    for(int i1 = 0; i1 &lt; img1.height; i1++)</a>
<a name="ln158">      box_mean_1d(img1.width, img1.data + (size_t)i1 * img1.width, img2.data + (size_t)i1 * img2.width, 1, w);</a>
<a name="ln159">    img2_bak = new_gray_image(1, img2.height);</a>
<a name="ln160">  }</a>
<a name="ln161">  for(int i0 = 0; i0 &lt; img1.width; i0++)</a>
<a name="ln162">  {</a>
<a name="ln163">    for(int i1 = 0; i1 &lt; img1.height; i1++) img2_bak.data[i1] = img2.data[i0 + (size_t)i1 * img2.width];</a>
<a name="ln164">    box_mean_1d(img1.height, img2_bak.data, img2.data + i0, img1.width, w);</a>
<a name="ln165">  }</a>
<a name="ln166">  free_gray_image(&amp;img2_bak);</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">// apply guided filter to single-component image img using the 3-components</a>
<a name="ln170">// image imgg as a guide</a>
<a name="ln171">static void guided_filter_tiling(color_image imgg, gray_image img, gray_image img_out, tile target, const int w,</a>
<a name="ln172">                                 const float eps, const float guide_weight, const float min, const float max)</a>
<a name="ln173">{</a>
<a name="ln174">  const tile source = { max_i(target.left - 2 * w, 0), min_i(target.right + 2 * w, imgg.width),</a>
<a name="ln175">                        max_i(target.lower - 2 * w, 0), min_i(target.upper + 2 * w, imgg.height) };</a>
<a name="ln176">  const int width = source.right - source.left;</a>
<a name="ln177">  const int height = source.upper - source.lower;</a>
<a name="ln178">  size_t size = (size_t)width * (size_t)height;</a>
<a name="ln179">  gray_image imgg_mean_r = new_gray_image(width, height);</a>
<a name="ln180">  gray_image imgg_mean_g = new_gray_image(width, height);</a>
<a name="ln181">  gray_image imgg_mean_b = new_gray_image(width, height);</a>
<a name="ln182">  gray_image img_mean = new_gray_image(width, height);</a>
<a name="ln183">  for(int j_imgg = source.lower; j_imgg &lt; source.upper; j_imgg++)</a>
<a name="ln184">  {</a>
<a name="ln185">    int j = j_imgg - source.lower;</a>
<a name="ln186">    for(int i_imgg = source.left; i_imgg &lt; source.right; i_imgg++)</a>
<a name="ln187">    {</a>
<a name="ln188">      int i = i_imgg - source.left;</a>
<a name="ln189">      float *pixel = get_color_pixel(imgg, i_imgg + (size_t)j_imgg * imgg.width);</a>
<a name="ln190">      size_t k = i + (size_t)j * width;</a>
<a name="ln191">      imgg_mean_r.data[k] = pixel[0] * guide_weight;</a>
<a name="ln192">      imgg_mean_g.data[k] = pixel[1] * guide_weight;</a>
<a name="ln193">      imgg_mean_b.data[k] = pixel[2] * guide_weight;</a>
<a name="ln194">      img_mean.data[k] = img.data[i_imgg + (size_t)j_imgg * img.width];</a>
<a name="ln195">    }</a>
<a name="ln196">  }</a>
<a name="ln197">  box_mean(imgg_mean_r, imgg_mean_r, w);</a>
<a name="ln198">  box_mean(imgg_mean_g, imgg_mean_g, w);</a>
<a name="ln199">  box_mean(imgg_mean_b, imgg_mean_b, w);</a>
<a name="ln200">  box_mean(img_mean, img_mean, w);</a>
<a name="ln201">  gray_image cov_imgg_img_r = new_gray_image(width, height);</a>
<a name="ln202">  gray_image cov_imgg_img_g = new_gray_image(width, height);</a>
<a name="ln203">  gray_image cov_imgg_img_b = new_gray_image(width, height);</a>
<a name="ln204">  gray_image var_imgg_rr = new_gray_image(width, height);</a>
<a name="ln205">  gray_image var_imgg_gg = new_gray_image(width, height);</a>
<a name="ln206">  gray_image var_imgg_bb = new_gray_image(width, height);</a>
<a name="ln207">  gray_image var_imgg_rg = new_gray_image(width, height);</a>
<a name="ln208">  gray_image var_imgg_rb = new_gray_image(width, height);</a>
<a name="ln209">  gray_image var_imgg_gb = new_gray_image(width, height);</a>
<a name="ln210">  for(int j_imgg = source.lower; j_imgg &lt; source.upper; j_imgg++)</a>
<a name="ln211">  {</a>
<a name="ln212">    int j = j_imgg - source.lower;</a>
<a name="ln213">    for(int i_imgg = source.left; i_imgg &lt; source.right; i_imgg++)</a>
<a name="ln214">    {</a>
<a name="ln215">      int i = i_imgg - source.left;</a>
<a name="ln216">      float *pixel_ = get_color_pixel(imgg, i_imgg + (size_t)j_imgg * imgg.width);</a>
<a name="ln217">      float pixel[3] = { pixel_[0] * guide_weight, pixel_[1] * guide_weight, pixel_[2] * guide_weight };</a>
<a name="ln218">      size_t k = i + (size_t)j * width;</a>
<a name="ln219">      cov_imgg_img_r.data[k] = pixel[0] * img.data[i_imgg + (size_t)j_imgg * imgg.width];</a>
<a name="ln220">      cov_imgg_img_g.data[k] = pixel[1] * img.data[i_imgg + (size_t)j_imgg * imgg.width];</a>
<a name="ln221">      cov_imgg_img_b.data[k] = pixel[2] * img.data[i_imgg + (size_t)j_imgg * imgg.width];</a>
<a name="ln222">      var_imgg_rr.data[k] = pixel[0] * pixel[0];</a>
<a name="ln223">      var_imgg_rg.data[k] = pixel[0] * pixel[1];</a>
<a name="ln224">      var_imgg_rb.data[k] = pixel[0] * pixel[2];</a>
<a name="ln225">      var_imgg_gg.data[k] = pixel[1] * pixel[1];</a>
<a name="ln226">      var_imgg_gb.data[k] = pixel[1] * pixel[2];</a>
<a name="ln227">      var_imgg_bb.data[k] = pixel[2] * pixel[2];</a>
<a name="ln228">    }</a>
<a name="ln229">  }</a>
<a name="ln230">  box_mean(cov_imgg_img_r, cov_imgg_img_r, w);</a>
<a name="ln231">  box_mean(cov_imgg_img_g, cov_imgg_img_g, w);</a>
<a name="ln232">  box_mean(cov_imgg_img_b, cov_imgg_img_b, w);</a>
<a name="ln233">  box_mean(var_imgg_rr, var_imgg_rr, w);</a>
<a name="ln234">  box_mean(var_imgg_rg, var_imgg_rg, w);</a>
<a name="ln235">  box_mean(var_imgg_rb, var_imgg_rb, w);</a>
<a name="ln236">  box_mean(var_imgg_gg, var_imgg_gg, w);</a>
<a name="ln237">  box_mean(var_imgg_gb, var_imgg_gb, w);</a>
<a name="ln238">  box_mean(var_imgg_bb, var_imgg_bb, w);</a>
<a name="ln239">  for(size_t i = 0; i &lt; size; i++)</a>
<a name="ln240">  {</a>
<a name="ln241">    cov_imgg_img_r.data[i] -= imgg_mean_r.data[i] * img_mean.data[i];</a>
<a name="ln242">    cov_imgg_img_g.data[i] -= imgg_mean_g.data[i] * img_mean.data[i];</a>
<a name="ln243">    cov_imgg_img_b.data[i] -= imgg_mean_b.data[i] * img_mean.data[i];</a>
<a name="ln244">    var_imgg_rr.data[i] -= imgg_mean_r.data[i] * imgg_mean_r.data[i];</a>
<a name="ln245">    var_imgg_rr.data[i] += eps;</a>
<a name="ln246">    var_imgg_rg.data[i] -= imgg_mean_r.data[i] * imgg_mean_g.data[i];</a>
<a name="ln247">    var_imgg_rb.data[i] -= imgg_mean_r.data[i] * imgg_mean_b.data[i];</a>
<a name="ln248">    var_imgg_gg.data[i] -= imgg_mean_g.data[i] * imgg_mean_g.data[i];</a>
<a name="ln249">    var_imgg_gg.data[i] += eps;</a>
<a name="ln250">    var_imgg_gb.data[i] -= imgg_mean_g.data[i] * imgg_mean_b.data[i];</a>
<a name="ln251">    var_imgg_bb.data[i] -= imgg_mean_b.data[i] * imgg_mean_b.data[i];</a>
<a name="ln252">    var_imgg_bb.data[i] += eps;</a>
<a name="ln253">  }</a>
<a name="ln254">  // we will recycle memory of the arrays imgg_mean_? and img_mean for the new coefficient arrays a_? and b to</a>
<a name="ln255">  // reduce memory foot print</a>
<a name="ln256">  gray_image a_r = imgg_mean_r;</a>
<a name="ln257">  gray_image a_g = imgg_mean_g;</a>
<a name="ln258">  gray_image a_b = imgg_mean_b;</a>
<a name="ln259">  gray_image b = img_mean;</a>
<a name="ln260">  for(int i1 = 0; i1 &lt; height; i1++)</a>
<a name="ln261">  {</a>
<a name="ln262">    size_t i = (size_t)i1 * width;</a>
<a name="ln263">    for(int i0 = 0; i0 &lt; width; i0++)</a>
<a name="ln264">    {</a>
<a name="ln265">      // solve linear system of equations of size 3x3 via Cramer's rule</a>
<a name="ln266">      // symmetric coefficient matrix</a>
<a name="ln267">      const float Sigma_0_0 = var_imgg_rr.data[i];</a>
<a name="ln268">      const float Sigma_0_1 = var_imgg_rg.data[i];</a>
<a name="ln269">      const float Sigma_0_2 = var_imgg_rb.data[i];</a>
<a name="ln270">      const float Sigma_1_1 = var_imgg_gg.data[i];</a>
<a name="ln271">      const float Sigma_1_2 = var_imgg_gb.data[i];</a>
<a name="ln272">      const float Sigma_2_2 = var_imgg_bb.data[i];</a>
<a name="ln273">      const float cov_imgg_img[3] = { cov_imgg_img_r.data[i], cov_imgg_img_g.data[i], cov_imgg_img_b.data[i] };</a>
<a name="ln274">      const float det0 = Sigma_0_0 * (Sigma_1_1 * Sigma_2_2 - Sigma_1_2 * Sigma_1_2)</a>
<a name="ln275">                         - Sigma_0_1 * (Sigma_0_1 * Sigma_2_2 - Sigma_0_2 * Sigma_1_2)</a>
<a name="ln276">                         + Sigma_0_2 * (Sigma_0_1 * Sigma_1_2 - Sigma_0_2 * Sigma_1_1);</a>
<a name="ln277">      float a_r_, a_g_, a_b_;</a>
<a name="ln278">      if(fabsf(det0) &gt; 4.f * FLT_EPSILON)</a>
<a name="ln279">      {</a>
<a name="ln280">        const float det1 = cov_imgg_img[0] * (Sigma_1_1 * Sigma_2_2 - Sigma_1_2 * Sigma_1_2)</a>
<a name="ln281">                           - Sigma_0_1 * (cov_imgg_img[1] * Sigma_2_2 - cov_imgg_img[2] * Sigma_1_2)</a>
<a name="ln282">                           + Sigma_0_2 * (cov_imgg_img[1] * Sigma_1_2 - cov_imgg_img[2] * Sigma_1_1);</a>
<a name="ln283">        const float det2 = Sigma_0_0 * (cov_imgg_img[1] * Sigma_2_2 - cov_imgg_img[2] * Sigma_1_2)</a>
<a name="ln284">                           - cov_imgg_img[0] * (Sigma_0_1 * Sigma_2_2 - Sigma_0_2 * Sigma_1_2)</a>
<a name="ln285">                           + Sigma_0_2 * (Sigma_0_1 * cov_imgg_img[2] - Sigma_0_2 * cov_imgg_img[1]);</a>
<a name="ln286">        const float det3 = Sigma_0_0 * (Sigma_1_1 * cov_imgg_img[2] - Sigma_1_2 * cov_imgg_img[1])</a>
<a name="ln287">                           - Sigma_0_1 * (Sigma_0_1 * cov_imgg_img[2] - Sigma_0_2 * cov_imgg_img[1])</a>
<a name="ln288">                           + cov_imgg_img[0] * (Sigma_0_1 * Sigma_1_2 - Sigma_0_2 * Sigma_1_1);</a>
<a name="ln289">        a_r_ = det1 / det0;</a>
<a name="ln290">        a_g_ = det2 / det0;</a>
<a name="ln291">        a_b_ = det3 / det0;</a>
<a name="ln292">      }</a>
<a name="ln293">      else</a>
<a name="ln294">      {</a>
<a name="ln295">        // linear system is singular</a>
<a name="ln296">        a_r_ = 0.f;</a>
<a name="ln297">        a_g_ = 0.f;</a>
<a name="ln298">        a_b_ = 0.f;</a>
<a name="ln299">      }</a>
<a name="ln300">      b.data[i] -= a_r_ * imgg_mean_r.data[i];</a>
<a name="ln301">      b.data[i] -= a_g_ * imgg_mean_g.data[i];</a>
<a name="ln302">      b.data[i] -= a_b_ * imgg_mean_b.data[i];</a>
<a name="ln303">      // now data of imgg_mean_? is no longer needed, we can safely overwrite aliasing arrays</a>
<a name="ln304">      a_r.data[i] = a_r_;</a>
<a name="ln305">      a_g.data[i] = a_g_;</a>
<a name="ln306">      a_b.data[i] = a_b_;</a>
<a name="ln307">      ++i;</a>
<a name="ln308">    }</a>
<a name="ln309">  }</a>
<a name="ln310">  box_mean(a_r, a_r, w);</a>
<a name="ln311">  box_mean(a_g, a_g, w);</a>
<a name="ln312">  box_mean(a_b, a_b, w);</a>
<a name="ln313">  box_mean(b, b, w);</a>
<a name="ln314">  for(int j_imgg = target.lower; j_imgg &lt; target.upper; j_imgg++)</a>
<a name="ln315">  {</a>
<a name="ln316">    // index of the left most target pixel in the current row</a>
<a name="ln317">    size_t l = target.left + (size_t)j_imgg * imgg.width;</a>
<a name="ln318">    // index of the left most source pixel in the current row of the</a>
<a name="ln319">    // smaller auxiliary gray-scale images a_r, a_g, a_b, and b</a>
<a name="ln320">    // excluding boundary data from neighboring tiles</a>
<a name="ln321">    size_t k = (target.left - source.left) + (size_t)(j_imgg - source.lower) * width;</a>
<a name="ln322">    for(int i_imgg = target.left; i_imgg &lt; target.right; i_imgg++, k++, l++)</a>
<a name="ln323">    {</a>
<a name="ln324">      float *pixel = get_color_pixel(imgg, l);</a>
<a name="ln325">      float res = a_r.data[k] * pixel[0] + a_g.data[k] * pixel[1] + a_b.data[k] * pixel[2];</a>
<a name="ln326">      res *= guide_weight;</a>
<a name="ln327">      res += b.data[k];</a>
<a name="ln328">      if(res &lt; min) res = min;</a>
<a name="ln329">      if(res &gt; max) res = max;</a>
<a name="ln330">      img_out.data[i_imgg + (size_t)j_imgg * imgg.width] = res;</a>
<a name="ln331">    }</a>
<a name="ln332">  }</a>
<a name="ln333">  free_gray_image(&amp;var_imgg_rr);</a>
<a name="ln334">  free_gray_image(&amp;var_imgg_rg);</a>
<a name="ln335">  free_gray_image(&amp;var_imgg_rb);</a>
<a name="ln336">  free_gray_image(&amp;var_imgg_gg);</a>
<a name="ln337">  free_gray_image(&amp;var_imgg_gb);</a>
<a name="ln338">  free_gray_image(&amp;var_imgg_bb);</a>
<a name="ln339">  free_gray_image(&amp;cov_imgg_img_r);</a>
<a name="ln340">  free_gray_image(&amp;cov_imgg_img_g);</a>
<a name="ln341">  free_gray_image(&amp;cov_imgg_img_b);</a>
<a name="ln342">  free_gray_image(&amp;img_mean);</a>
<a name="ln343">  free_gray_image(&amp;imgg_mean_r);</a>
<a name="ln344">  free_gray_image(&amp;imgg_mean_g);</a>
<a name="ln345">  free_gray_image(&amp;imgg_mean_b);</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348"> </a>
<a name="ln349">void guided_filter(const float *const guide, const float *const in, float *const out, const int width,</a>
<a name="ln350">                   const int height, const int ch,</a>
<a name="ln351">                   const int w,              // window size</a>
<a name="ln352">                   const float sqrt_eps,     // regularization parameter</a>
<a name="ln353">                   const float guide_weight, // to balance the amplitudes in the guiding image and the input image</a>
<a name="ln354">                   const float min, const float max)</a>
<a name="ln355">{</a>
<a name="ln356">  assert(ch &gt;= 3);</a>
<a name="ln357">  assert(w &gt;= 1);</a>
<a name="ln358"> </a>
<a name="ln359">  color_image img_guide = (color_image){ (float *)guide, width, height, ch };</a>
<a name="ln360">  gray_image img_in = (gray_image){ (float *)in, width, height };</a>
<a name="ln361">  gray_image img_out = (gray_image){ out, width, height };</a>
<a name="ln362">  const int tile_width = max_i(3 * w, 512);</a>
<a name="ln363">  const float eps = sqrt_eps * sqrt_eps; // this is the regularization parameter of the original papers</a>
<a name="ln364"> </a>
<a name="ln365">#ifdef _OPENMP</a>
<a name="ln366">#pragma omp parallel for collapse(2)</a>
<a name="ln367">#endif</a>
<a name="ln368">  for(int j = 0; j &lt; height; j += tile_width)</a>
<a name="ln369">  {</a>
<a name="ln370">    for(int i = 0; i &lt; width; i += tile_width)</a>
<a name="ln371">    {</a>
<a name="ln372">      tile target = { i, min_i(i + tile_width, width), j, min_i(j + tile_width, height) };</a>
<a name="ln373">      guided_filter_tiling(img_guide, img_in, img_out, target, w, eps, guide_weight, min, max);</a>
<a name="ln374">    }</a>
<a name="ln375">  }</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">#ifdef HAVE_OPENCL</a>
<a name="ln379"> </a>
<a name="ln380">dt_guided_filter_cl_global_t *dt_guided_filter_init_cl_global()</a>
<a name="ln381">{</a>
<a name="ln382">  dt_guided_filter_cl_global_t *g = malloc(sizeof(*g));</a>
<a name="ln383">  const int program = 26; // guided_filter.cl, from programs.conf</a>
<a name="ln384">  g-&gt;kernel_guided_filter_split_rgb = dt_opencl_create_kernel(program, &quot;guided_filter_split_rgb_image&quot;);</a>
<a name="ln385">  g-&gt;kernel_guided_filter_box_mean_x = dt_opencl_create_kernel(program, &quot;guided_filter_box_mean_x&quot;);</a>
<a name="ln386">  g-&gt;kernel_guided_filter_box_mean_y = dt_opencl_create_kernel(program, &quot;guided_filter_box_mean_y&quot;);</a>
<a name="ln387">  g-&gt;kernel_guided_filter_guided_filter_covariances</a>
<a name="ln388">      = dt_opencl_create_kernel(program, &quot;guided_filter_covariances&quot;);</a>
<a name="ln389">  g-&gt;kernel_guided_filter_guided_filter_variances = dt_opencl_create_kernel(program, &quot;guided_filter_variances&quot;);</a>
<a name="ln390">  g-&gt;kernel_guided_filter_update_covariance = dt_opencl_create_kernel(program, &quot;guided_filter_update_covariance&quot;);</a>
<a name="ln391">  g-&gt;kernel_guided_filter_solve = dt_opencl_create_kernel(program, &quot;guided_filter_solve&quot;);</a>
<a name="ln392">  g-&gt;kernel_guided_filter_generate_result = dt_opencl_create_kernel(program, &quot;guided_filter_generate_result&quot;);</a>
<a name="ln393">  return g;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396"> </a>
<a name="ln397">void dt_guided_filter_free_cl_global(dt_guided_filter_cl_global_t *g)</a>
<a name="ln398">{</a>
<a name="ln399">  if(!g) return;</a>
<a name="ln400">  // destroy kernels</a>
<a name="ln401">  dt_opencl_free_kernel(g-&gt;kernel_guided_filter_split_rgb);</a>
<a name="ln402">  dt_opencl_free_kernel(g-&gt;kernel_guided_filter_box_mean_x);</a>
<a name="ln403">  dt_opencl_free_kernel(g-&gt;kernel_guided_filter_box_mean_y);</a>
<a name="ln404">  dt_opencl_free_kernel(g-&gt;kernel_guided_filter_guided_filter_covariances);</a>
<a name="ln405">  dt_opencl_free_kernel(g-&gt;kernel_guided_filter_guided_filter_variances);</a>
<a name="ln406">  dt_opencl_free_kernel(g-&gt;kernel_guided_filter_update_covariance);</a>
<a name="ln407">  dt_opencl_free_kernel(g-&gt;kernel_guided_filter_solve);</a>
<a name="ln408">  dt_opencl_free_kernel(g-&gt;kernel_guided_filter_generate_result);</a>
<a name="ln409">  free(g);</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412"> </a>
<a name="ln413">static int cl_split_rgb(const int devid, const int width, const int height, cl_mem guide, cl_mem imgg_r,</a>
<a name="ln414">                        cl_mem imgg_g, cl_mem imgg_b, const float guide_weight)</a>
<a name="ln415">{</a>
<a name="ln416">  const int kernel = darktable.opencl-&gt;guided_filter-&gt;kernel_guided_filter_split_rgb;</a>
<a name="ln417">  dt_opencl_set_kernel_arg(devid, kernel, 0, sizeof(width), &amp;width);</a>
<a name="ln418">  dt_opencl_set_kernel_arg(devid, kernel, 1, sizeof(height), &amp;height);</a>
<a name="ln419">  dt_opencl_set_kernel_arg(devid, kernel, 2, sizeof(guide), &amp;guide);</a>
<a name="ln420">  dt_opencl_set_kernel_arg(devid, kernel, 3, sizeof(imgg_r), &amp;imgg_r);</a>
<a name="ln421">  dt_opencl_set_kernel_arg(devid, kernel, 4, sizeof(imgg_g), &amp;imgg_g);</a>
<a name="ln422">  dt_opencl_set_kernel_arg(devid, kernel, 5, sizeof(imgg_b), &amp;imgg_b);</a>
<a name="ln423">  dt_opencl_set_kernel_arg(devid, kernel, 6, sizeof(guide_weight), &amp;guide_weight);</a>
<a name="ln424">  const size_t sizes[] = { ROUNDUPWD(width), ROUNDUPWD(height) };</a>
<a name="ln425">  return dt_opencl_enqueue_kernel_2d(devid, kernel, sizes);</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428"> </a>
<a name="ln429">static int cl_box_mean(const int devid, const int width, const int height, const int w, cl_mem in, cl_mem out,</a>
<a name="ln430">                       cl_mem temp)</a>
<a name="ln431">{</a>
<a name="ln432">  const int kernel_x = darktable.opencl-&gt;guided_filter-&gt;kernel_guided_filter_box_mean_x;</a>
<a name="ln433">  dt_opencl_set_kernel_arg(devid, kernel_x, 0, sizeof(width), &amp;width);</a>
<a name="ln434">  dt_opencl_set_kernel_arg(devid, kernel_x, 1, sizeof(height), &amp;height);</a>
<a name="ln435">  dt_opencl_set_kernel_arg(devid, kernel_x, 2, sizeof(in), &amp;in);</a>
<a name="ln436">  dt_opencl_set_kernel_arg(devid, kernel_x, 3, sizeof(temp), &amp;temp);</a>
<a name="ln437">  dt_opencl_set_kernel_arg(devid, kernel_x, 4, sizeof(w), &amp;w);</a>
<a name="ln438">  const size_t sizes_x[] = { 1, ROUNDUPWD(height) };</a>
<a name="ln439">  const int err = dt_opencl_enqueue_kernel_2d(devid, kernel_x, sizes_x);</a>
<a name="ln440">  if(err != CL_SUCCESS) return err;</a>
<a name="ln441"> </a>
<a name="ln442">  const int kernel_y = darktable.opencl-&gt;guided_filter-&gt;kernel_guided_filter_box_mean_y;</a>
<a name="ln443">  dt_opencl_set_kernel_arg(devid, kernel_y, 0, sizeof(width), &amp;width);</a>
<a name="ln444">  dt_opencl_set_kernel_arg(devid, kernel_y, 1, sizeof(height), &amp;height);</a>
<a name="ln445">  dt_opencl_set_kernel_arg(devid, kernel_y, 2, sizeof(temp), &amp;temp);</a>
<a name="ln446">  dt_opencl_set_kernel_arg(devid, kernel_y, 3, sizeof(out), &amp;out);</a>
<a name="ln447">  dt_opencl_set_kernel_arg(devid, kernel_y, 4, sizeof(w), &amp;w);</a>
<a name="ln448">  const size_t sizes_y[] = { ROUNDUPWD(width), 1 };</a>
<a name="ln449">  return dt_opencl_enqueue_kernel_2d(devid, kernel_y, sizes_y);</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452"> </a>
<a name="ln453">static int cl_covariances(const int devid, const int width, const int height, cl_mem guide, cl_mem in,</a>
<a name="ln454">                          cl_mem cov_imgg_img_r, cl_mem cov_imgg_img_g, cl_mem cov_imgg_img_b,</a>
<a name="ln455">                          const float guide_weight)</a>
<a name="ln456">{</a>
<a name="ln457">  const int kernel = darktable.opencl-&gt;guided_filter-&gt;kernel_guided_filter_guided_filter_covariances;</a>
<a name="ln458">  dt_opencl_set_kernel_arg(devid, kernel, 0, sizeof(width), &amp;width);</a>
<a name="ln459">  dt_opencl_set_kernel_arg(devid, kernel, 1, sizeof(height), &amp;height);</a>
<a name="ln460">  dt_opencl_set_kernel_arg(devid, kernel, 2, sizeof(guide), &amp;guide);</a>
<a name="ln461">  dt_opencl_set_kernel_arg(devid, kernel, 3, sizeof(in), &amp;in);</a>
<a name="ln462">  dt_opencl_set_kernel_arg(devid, kernel, 4, sizeof(cov_imgg_img_r), &amp;cov_imgg_img_r);</a>
<a name="ln463">  dt_opencl_set_kernel_arg(devid, kernel, 5, sizeof(cov_imgg_img_g), &amp;cov_imgg_img_g);</a>
<a name="ln464">  dt_opencl_set_kernel_arg(devid, kernel, 6, sizeof(cov_imgg_img_b), &amp;cov_imgg_img_b);</a>
<a name="ln465">  dt_opencl_set_kernel_arg(devid, kernel, 7, sizeof(guide_weight), &amp;guide_weight);</a>
<a name="ln466">  const size_t sizes[] = { ROUNDUPWD(width), ROUNDUPWD(height) };</a>
<a name="ln467">  return dt_opencl_enqueue_kernel_2d(devid, kernel, sizes);</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470"> </a>
<a name="ln471">static int cl_variances(const int devid, const int width, const int height, cl_mem guide, cl_mem var_imgg_rr,</a>
<a name="ln472">                        cl_mem var_imgg_rg, cl_mem var_imgg_rb, cl_mem var_imgg_gg, cl_mem var_imgg_gb,</a>
<a name="ln473">                        cl_mem var_imgg_bb, const float guide_weight)</a>
<a name="ln474">{</a>
<a name="ln475">  const int kernel = darktable.opencl-&gt;guided_filter-&gt;kernel_guided_filter_guided_filter_variances;</a>
<a name="ln476">  dt_opencl_set_kernel_arg(devid, kernel, 0, sizeof(width), &amp;width);</a>
<a name="ln477">  dt_opencl_set_kernel_arg(devid, kernel, 1, sizeof(height), &amp;height);</a>
<a name="ln478">  dt_opencl_set_kernel_arg(devid, kernel, 2, sizeof(guide), &amp;guide);</a>
<a name="ln479">  dt_opencl_set_kernel_arg(devid, kernel, 3, sizeof(var_imgg_rr), &amp;var_imgg_rr);</a>
<a name="ln480">  dt_opencl_set_kernel_arg(devid, kernel, 4, sizeof(var_imgg_rg), &amp;var_imgg_rg);</a>
<a name="ln481">  dt_opencl_set_kernel_arg(devid, kernel, 5, sizeof(var_imgg_rb), &amp;var_imgg_rb);</a>
<a name="ln482">  dt_opencl_set_kernel_arg(devid, kernel, 6, sizeof(var_imgg_gg), &amp;var_imgg_gg);</a>
<a name="ln483">  dt_opencl_set_kernel_arg(devid, kernel, 7, sizeof(var_imgg_gb), &amp;var_imgg_gb);</a>
<a name="ln484">  dt_opencl_set_kernel_arg(devid, kernel, 8, sizeof(var_imgg_bb), &amp;var_imgg_bb);</a>
<a name="ln485">  dt_opencl_set_kernel_arg(devid, kernel, 9, sizeof(guide_weight), &amp;guide_weight);</a>
<a name="ln486">  size_t sizes[] = { ROUNDUPWD(width), ROUNDUPWD(height) };</a>
<a name="ln487">  return dt_opencl_enqueue_kernel_2d(devid, kernel, sizes);</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490"> </a>
<a name="ln491">static int cl_update_covariance(const int devid, const int width, const int height, cl_mem in, cl_mem out,</a>
<a name="ln492">                                cl_mem a, cl_mem b, float eps)</a>
<a name="ln493">{</a>
<a name="ln494">  const int kernel = darktable.opencl-&gt;guided_filter-&gt;kernel_guided_filter_update_covariance;</a>
<a name="ln495">  dt_opencl_set_kernel_arg(devid, kernel, 0, sizeof(width), &amp;width);</a>
<a name="ln496">  dt_opencl_set_kernel_arg(devid, kernel, 1, sizeof(height), &amp;height);</a>
<a name="ln497">  dt_opencl_set_kernel_arg(devid, kernel, 2, sizeof(in), &amp;in);</a>
<a name="ln498">  dt_opencl_set_kernel_arg(devid, kernel, 3, sizeof(out), &amp;out);</a>
<a name="ln499">  dt_opencl_set_kernel_arg(devid, kernel, 4, sizeof(a), &amp;a);</a>
<a name="ln500">  dt_opencl_set_kernel_arg(devid, kernel, 5, sizeof(b), &amp;b);</a>
<a name="ln501">  dt_opencl_set_kernel_arg(devid, kernel, 6, sizeof(eps), &amp;eps);</a>
<a name="ln502">  const size_t sizes[] = { ROUNDUPWD(width), ROUNDUPWD(height) };</a>
<a name="ln503">  return dt_opencl_enqueue_kernel_2d(devid, kernel, sizes);</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506"> </a>
<a name="ln507">static int cl_solve(const int devid, const int width, const int height, cl_mem img_mean, cl_mem imgg_mean_r,</a>
<a name="ln508">                    cl_mem imgg_mean_g, cl_mem imgg_mean_b, cl_mem cov_imgg_img_r, cl_mem cov_imgg_img_g,</a>
<a name="ln509">                    cl_mem cov_imgg_img_b, cl_mem var_imgg_rr, cl_mem var_imgg_rg, cl_mem var_imgg_rb,</a>
<a name="ln510">                    cl_mem var_imgg_gg, cl_mem var_imgg_gb, cl_mem var_imgg_bb, cl_mem a_r, cl_mem a_g, cl_mem a_b,</a>
<a name="ln511">                    cl_mem b)</a>
<a name="ln512">{</a>
<a name="ln513">  const int kernel = darktable.opencl-&gt;guided_filter-&gt;kernel_guided_filter_solve;</a>
<a name="ln514">  dt_opencl_set_kernel_arg(devid, kernel, 0, sizeof(width), &amp;width);</a>
<a name="ln515">  dt_opencl_set_kernel_arg(devid, kernel, 1, sizeof(height), &amp;height);</a>
<a name="ln516">  dt_opencl_set_kernel_arg(devid, kernel, 2, sizeof(img_mean), &amp;img_mean);</a>
<a name="ln517">  dt_opencl_set_kernel_arg(devid, kernel, 3, sizeof(imgg_mean_r), &amp;imgg_mean_r);</a>
<a name="ln518">  dt_opencl_set_kernel_arg(devid, kernel, 4, sizeof(imgg_mean_g), &amp;imgg_mean_g);</a>
<a name="ln519">  dt_opencl_set_kernel_arg(devid, kernel, 5, sizeof(imgg_mean_b), &amp;imgg_mean_b);</a>
<a name="ln520">  dt_opencl_set_kernel_arg(devid, kernel, 6, sizeof(cov_imgg_img_r), &amp;cov_imgg_img_r);</a>
<a name="ln521">  dt_opencl_set_kernel_arg(devid, kernel, 7, sizeof(cov_imgg_img_g), &amp;cov_imgg_img_g);</a>
<a name="ln522">  dt_opencl_set_kernel_arg(devid, kernel, 8, sizeof(cov_imgg_img_b), &amp;cov_imgg_img_b);</a>
<a name="ln523">  dt_opencl_set_kernel_arg(devid, kernel, 9, sizeof(var_imgg_rr), &amp;var_imgg_rr);</a>
<a name="ln524">  dt_opencl_set_kernel_arg(devid, kernel, 10, sizeof(var_imgg_rg), &amp;var_imgg_rg);</a>
<a name="ln525">  dt_opencl_set_kernel_arg(devid, kernel, 11, sizeof(var_imgg_rb), &amp;var_imgg_rb);</a>
<a name="ln526">  dt_opencl_set_kernel_arg(devid, kernel, 12, sizeof(var_imgg_gg), &amp;var_imgg_gg);</a>
<a name="ln527">  dt_opencl_set_kernel_arg(devid, kernel, 13, sizeof(var_imgg_gb), &amp;var_imgg_gb);</a>
<a name="ln528">  dt_opencl_set_kernel_arg(devid, kernel, 14, sizeof(var_imgg_bb), &amp;var_imgg_bb);</a>
<a name="ln529">  dt_opencl_set_kernel_arg(devid, kernel, 15, sizeof(a_r), &amp;a_r);</a>
<a name="ln530">  dt_opencl_set_kernel_arg(devid, kernel, 16, sizeof(a_g), &amp;a_g);</a>
<a name="ln531">  dt_opencl_set_kernel_arg(devid, kernel, 17, sizeof(a_b), &amp;a_b);</a>
<a name="ln532">  dt_opencl_set_kernel_arg(devid, kernel, 18, sizeof(b), &amp;b);</a>
<a name="ln533">  const size_t sizes[] = { ROUNDUPWD(width), ROUNDUPWD(height) };</a>
<a name="ln534">  return dt_opencl_enqueue_kernel_2d(devid, kernel, sizes);</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537"> </a>
<a name="ln538">static int cl_generate_result(const int devid, const int width, const int height, cl_mem guide, cl_mem a_r,</a>
<a name="ln539">                              cl_mem a_g, cl_mem a_b, cl_mem b, cl_mem out, const float guide_weight,</a>
<a name="ln540">                              const float min, const float max)</a>
<a name="ln541">{</a>
<a name="ln542">  const int kernel = darktable.opencl-&gt;guided_filter-&gt;kernel_guided_filter_generate_result;</a>
<a name="ln543">  dt_opencl_set_kernel_arg(devid, kernel, 0, sizeof(width), &amp;width);</a>
<a name="ln544">  dt_opencl_set_kernel_arg(devid, kernel, 1, sizeof(height), &amp;height);</a>
<a name="ln545">  dt_opencl_set_kernel_arg(devid, kernel, 2, sizeof(guide), &amp;guide);</a>
<a name="ln546">  dt_opencl_set_kernel_arg(devid, kernel, 3, sizeof(a_r), &amp;a_r);</a>
<a name="ln547">  dt_opencl_set_kernel_arg(devid, kernel, 4, sizeof(a_g), &amp;a_g);</a>
<a name="ln548">  dt_opencl_set_kernel_arg(devid, kernel, 5, sizeof(a_b), &amp;a_b);</a>
<a name="ln549">  dt_opencl_set_kernel_arg(devid, kernel, 6, sizeof(b), &amp;b);</a>
<a name="ln550">  dt_opencl_set_kernel_arg(devid, kernel, 7, sizeof(out), &amp;out);</a>
<a name="ln551">  dt_opencl_set_kernel_arg(devid, kernel, 8, sizeof(guide_weight), &amp;guide_weight);</a>
<a name="ln552">  dt_opencl_set_kernel_arg(devid, kernel, 9, sizeof(min), &amp;min);</a>
<a name="ln553">  dt_opencl_set_kernel_arg(devid, kernel, 10, sizeof(max), &amp;max);</a>
<a name="ln554">  const size_t sizes[] = { ROUNDUPWD(width), ROUNDUPWD(height) };</a>
<a name="ln555">  return dt_opencl_enqueue_kernel_2d(devid, kernel, sizes);</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558"> </a>
<a name="ln559">static void guided_filter_cl_impl(int devid, cl_mem guide, cl_mem in, cl_mem out, const int width,</a>
<a name="ln560">                                  const int height, const int ch,</a>
<a name="ln561">                                  const int w,              // window size</a>
<a name="ln562">                                  const float sqrt_eps,     // regularization parameter</a>
<a name="ln563">                                  const float guide_weight, // to balance the amplitudes in the guiding image and</a>
<a name="ln564">                                                            // the input// image</a>
<a name="ln565">                                  const float min, const float max)</a>
<a name="ln566">{</a>
<a name="ln567">  const float eps = sqrt_eps * sqrt_eps; // this is the regularization parameter of the original papers</a>
<a name="ln568">  int err = CL_SUCCESS;</a>
<a name="ln569"> </a>
<a name="ln570">  void *temp1 = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln571">  void *temp2 = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln572">  void *imgg_mean_r = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln573">  void *imgg_mean_g = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln574">  void *imgg_mean_b = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln575">  void *img_mean = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln576">  void *cov_imgg_img_r = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln577">  void *cov_imgg_img_g = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln578">  void *cov_imgg_img_b = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln579">  void *var_imgg_rr = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln580">  void *var_imgg_gg = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln581">  void *var_imgg_bb = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln582">  void *var_imgg_rg = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln583">  void *var_imgg_rb = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln584">  void *var_imgg_gb = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln585">  void *a_r = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln586">  void *a_g = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln587">  void *a_b = dt_opencl_alloc_device(devid, width, height, (int)sizeof(float));</a>
<a name="ln588">  void *b = temp2;</a>
<a name="ln589"> </a>
<a name="ln590">  err = cl_split_rgb(devid, width, height, guide, imgg_mean_r, imgg_mean_g, imgg_mean_b, guide_weight);</a>
<a name="ln591">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln592"> </a>
<a name="ln593">  err = cl_box_mean(devid, width, height, w, in, img_mean, temp1);</a>
<a name="ln594">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln595">  err = cl_box_mean(devid, width, height, w, imgg_mean_r, imgg_mean_r, temp1);</a>
<a name="ln596">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln597">  err = cl_box_mean(devid, width, height, w, imgg_mean_g, imgg_mean_g, temp1);</a>
<a name="ln598">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln599">  err = cl_box_mean(devid, width, height, w, imgg_mean_b, imgg_mean_b, temp1);</a>
<a name="ln600">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln601"> </a>
<a name="ln602">  err = cl_covariances(devid, width, height, guide, in, cov_imgg_img_r, cov_imgg_img_g, cov_imgg_img_b,</a>
<a name="ln603">                       guide_weight);</a>
<a name="ln604">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln605"> </a>
<a name="ln606">  err = cl_variances(devid, width, height, guide, var_imgg_rr, var_imgg_rg, var_imgg_rb, var_imgg_gg, var_imgg_gb,</a>
<a name="ln607">                     var_imgg_bb, guide_weight);</a>
<a name="ln608">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln609"> </a>
<a name="ln610">  err = cl_box_mean(devid, width, height, w, cov_imgg_img_r, temp2, temp1);</a>
<a name="ln611">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln612">  err = cl_update_covariance(devid, width, height, temp2, cov_imgg_img_r, imgg_mean_r, img_mean, 0.f);</a>
<a name="ln613">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln614">  err = cl_box_mean(devid, width, height, w, cov_imgg_img_g, temp2, temp1);</a>
<a name="ln615">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln616">  err = cl_update_covariance(devid, width, height, temp2, cov_imgg_img_g, imgg_mean_g, img_mean, 0.f);</a>
<a name="ln617">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln618">  err = cl_box_mean(devid, width, height, w, cov_imgg_img_b, temp2, temp1);</a>
<a name="ln619">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln620">  err = cl_update_covariance(devid, width, height, temp2, cov_imgg_img_b, imgg_mean_b, img_mean, 0.f);</a>
<a name="ln621">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln622">  err = cl_box_mean(devid, width, height, w, var_imgg_rr, temp2, temp1);</a>
<a name="ln623">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln624">  err = cl_update_covariance(devid, width, height, temp2, var_imgg_rr, imgg_mean_r, imgg_mean_r, eps);</a>
<a name="ln625">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln626">  err = cl_box_mean(devid, width, height, w, var_imgg_rg, temp2, temp1);</a>
<a name="ln627">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln628">  err = cl_update_covariance(devid, width, height, temp2, var_imgg_rg, imgg_mean_r, imgg_mean_g, 0.f);</a>
<a name="ln629">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln630">  err = cl_box_mean(devid, width, height, w, var_imgg_rb, temp2, temp1);</a>
<a name="ln631">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln632">  err = cl_update_covariance(devid, width, height, temp2, var_imgg_rb, imgg_mean_r, imgg_mean_b, 0.f);</a>
<a name="ln633">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln634">  err = cl_box_mean(devid, width, height, w, var_imgg_gg, temp2, temp1);</a>
<a name="ln635">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln636">  err = cl_update_covariance(devid, width, height, temp2, var_imgg_gg, imgg_mean_g, imgg_mean_g, eps);</a>
<a name="ln637">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln638">  err = cl_box_mean(devid, width, height, w, var_imgg_gb, temp2, temp1);</a>
<a name="ln639">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln640">  err = cl_update_covariance(devid, width, height, temp2, var_imgg_gb, imgg_mean_g, imgg_mean_b, 0.f);</a>
<a name="ln641">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln642">  err = cl_box_mean(devid, width, height, w, var_imgg_bb, temp2, temp1);</a>
<a name="ln643">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln644">  err = cl_update_covariance(devid, width, height, temp2, var_imgg_bb, imgg_mean_b, imgg_mean_b, eps);</a>
<a name="ln645">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln646"> </a>
<a name="ln647">  err = cl_solve(devid, width, height, img_mean, imgg_mean_r, imgg_mean_g, imgg_mean_b, cov_imgg_img_r,</a>
<a name="ln648">                 cov_imgg_img_g, cov_imgg_img_b, var_imgg_rr, var_imgg_rg, var_imgg_rb, var_imgg_gg, var_imgg_gb,</a>
<a name="ln649">                 var_imgg_bb, a_r, a_g, a_b, b);</a>
<a name="ln650">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln651"> </a>
<a name="ln652">  err = cl_box_mean(devid, width, height, w, a_r, a_r, temp1);</a>
<a name="ln653">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln654">  err = cl_box_mean(devid, width, height, w, a_g, a_g, temp1);</a>
<a name="ln655">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln656">  err = cl_box_mean(devid, width, height, w, a_b, a_b, temp1);</a>
<a name="ln657">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln658">  err = cl_box_mean(devid, width, height, w, b, b, temp1);</a>
<a name="ln659">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln660"> </a>
<a name="ln661">  err = cl_generate_result(devid, width, height, guide, a_r, a_g, a_b, b, out, guide_weight, min, max);</a>
<a name="ln662"> </a>
<a name="ln663">error:</a>
<a name="ln664">  if (err != CL_SUCCESS)</a>
<a name="ln665">    dt_print(DT_DEBUG_OPENCL, &quot;[guided filter] unknown error: %d\n&quot;, err);</a>
<a name="ln666"> </a>
<a name="ln667">  dt_opencl_release_mem_object(a_r);</a>
<a name="ln668">  dt_opencl_release_mem_object(a_g);</a>
<a name="ln669">  dt_opencl_release_mem_object(a_b);</a>
<a name="ln670">  dt_opencl_release_mem_object(var_imgg_rr);</a>
<a name="ln671">  dt_opencl_release_mem_object(var_imgg_rg);</a>
<a name="ln672">  dt_opencl_release_mem_object(var_imgg_rb);</a>
<a name="ln673">  dt_opencl_release_mem_object(var_imgg_gg);</a>
<a name="ln674">  dt_opencl_release_mem_object(var_imgg_gb);</a>
<a name="ln675">  dt_opencl_release_mem_object(var_imgg_bb);</a>
<a name="ln676">  dt_opencl_release_mem_object(cov_imgg_img_r);</a>
<a name="ln677">  dt_opencl_release_mem_object(cov_imgg_img_g);</a>
<a name="ln678">  dt_opencl_release_mem_object(cov_imgg_img_b);</a>
<a name="ln679">  dt_opencl_release_mem_object(img_mean);</a>
<a name="ln680">  dt_opencl_release_mem_object(imgg_mean_r);</a>
<a name="ln681">  dt_opencl_release_mem_object(imgg_mean_g);</a>
<a name="ln682">  dt_opencl_release_mem_object(imgg_mean_b);</a>
<a name="ln683">  dt_opencl_release_mem_object(temp1);</a>
<a name="ln684">  dt_opencl_release_mem_object(temp2);</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687"> </a>
<a name="ln688">static void guided_filter_cl_fallback(int devid, cl_mem guide, cl_mem in, cl_mem out, const int width,</a>
<a name="ln689">                                      const int height, const int ch,</a>
<a name="ln690">                                      const int w,              // window size</a>
<a name="ln691">                                      const float sqrt_eps,     // regularization parameter</a>
<a name="ln692">                                      const float guide_weight, // to balance the amplitudes in the guiding image</a>
<a name="ln693">                                                                // and the input// image</a>
<a name="ln694">                                      const float min, const float max)</a>
<a name="ln695">{</a>
<a name="ln696">  // fall-back implementation: copy data from device memory to host memory and perform filter</a>
<a name="ln697">  // by CPU until there is a proper OpenCL implementation</a>
<a name="ln698">  float *guide_host = dt_alloc_align(64, sizeof(*guide_host) * width * height * ch);</a>
<a name="ln699">  float *in_host = dt_alloc_align(64, sizeof(*in_host) * width * height);</a>
<a name="ln700">  float *out_host = dt_alloc_align(64, sizeof(*out_host) * width * height);</a>
<a name="ln701">  int err;</a>
<a name="ln702">  err = dt_opencl_read_host_from_device(devid, guide_host, guide, width, height, ch * sizeof(float));</a>
<a name="ln703">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln704">  err = dt_opencl_read_host_from_device(devid, in_host, in, width, height, sizeof(float));</a>
<a name="ln705">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln706">  guided_filter(guide_host, in_host, out_host, width, height, ch, w, sqrt_eps, guide_weight, min, max);</a>
<a name="ln707">  err = dt_opencl_write_host_to_device(devid, out_host, out, width, height, sizeof(float));</a>
<a name="ln708">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln709">error:</a>
<a name="ln710">  dt_free_align(guide_host);</a>
<a name="ln711">  dt_free_align(in_host);</a>
<a name="ln712">  dt_free_align(out_host);</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715"> </a>
<a name="ln716">void guided_filter_cl(int devid, cl_mem guide, cl_mem in, cl_mem out, const int width, const int height,</a>
<a name="ln717">                      const int ch,</a>
<a name="ln718">                      const int w,              // window size</a>
<a name="ln719">                      const float sqrt_eps,     // regularization parameter</a>
<a name="ln720">                      const float guide_weight, // to balance the amplitudes in the guiding image and the input</a>
<a name="ln721">                                                // image</a>
<a name="ln722">                      const float min, const float max)</a>
<a name="ln723">{</a>
<a name="ln724">  assert(ch &gt;= 3);</a>
<a name="ln725">  assert(w &gt;= 1);</a>
<a name="ln726"> </a>
<a name="ln727">  const cl_ulong max_global_mem = dt_opencl_get_max_global_mem(devid);</a>
<a name="ln728">  const size_t reserved_memory = (size_t)(dt_conf_get_float(&quot;opencl_memory_headroom&quot;) * 1024 * 1024);</a>
<a name="ln729">  // estimate required memory for OpenCL code path with an safety factor of 9/8</a>
<a name="ln730">  const size_t required_memory</a>
<a name="ln731">      = darktable.opencl-&gt;dev[devid].memory_in_use + (size_t)width * height * sizeof(float) * 18 * 9 / 8;</a>
<a name="ln732">  if(max_global_mem - reserved_memory &gt; required_memory)</a>
<a name="ln733">    guided_filter_cl_impl(devid, guide, in, out, width, height, ch, w, sqrt_eps, guide_weight, min, max);</a>
<a name="ln734">  else</a>
<a name="ln735">  {</a>
<a name="ln736">    dt_print(DT_DEBUG_OPENCL, &quot;[guided filter] fall back to cpu implementation due to insufficient gpu memory\n&quot;);</a>
<a name="ln737">    guided_filter_cl_fallback(devid, guide, in, out, width, height, ch, w, sqrt_eps, guide_weight, min, max);</a>
<a name="ln738">  }</a>
<a name="ln739">}</a>
<a name="ln740"> </a>
<a name="ln741">#endif</a>

</code></pre>
<div class="balloon" rel="384"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 384, 382.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
