
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010 henrik andersson,</a>
<a name="ln4">    copyright (c) 2011-2012 johannes hanika</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;common/history.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/exif.h&quot;</a>
<a name="ln24">#include &quot;common/image_cache.h&quot;</a>
<a name="ln25">#include &quot;common/imageio.h&quot;</a>
<a name="ln26">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln27">#include &quot;common/tags.h&quot;</a>
<a name="ln28">#include &quot;common/utility.h&quot;</a>
<a name="ln29">#include &quot;common/collection.h&quot;</a>
<a name="ln30">#include &quot;common/history_snapshot.h&quot;</a>
<a name="ln31">#include &quot;common/undo.h&quot;</a>
<a name="ln32">#include &quot;control/control.h&quot;</a>
<a name="ln33">#include &quot;develop/develop.h&quot;</a>
<a name="ln34">#include &quot;develop/blend.h&quot;</a>
<a name="ln35">#include &quot;develop/masks.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">void dt_history_item_free(gpointer data)</a>
<a name="ln38">{</a>
<a name="ln39">  dt_history_item_t *item = (dt_history_item_t *)data;</a>
<a name="ln40">  g_free(item-&gt;op);</a>
<a name="ln41">  g_free(item-&gt;name);</a>
<a name="ln42">  item-&gt;op = NULL;</a>
<a name="ln43">  item-&gt;name = NULL;</a>
<a name="ln44">  g_free(item);</a>
<a name="ln45">}</a>
<a name="ln46"> </a>
<a name="ln47">static void remove_preset_flag(const int imgid)</a>
<a name="ln48">{</a>
<a name="ln49">  dt_image_t *image = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln50"> </a>
<a name="ln51">  // clear flag</a>
<a name="ln52">  image-&gt;flags &amp;= ~DT_IMAGE_AUTO_PRESETS_APPLIED;</a>
<a name="ln53"> </a>
<a name="ln54">  // write through to sql+xmp</a>
<a name="ln55">  dt_image_cache_write_release(darktable.image_cache, image, DT_IMAGE_CACHE_SAFE);</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">void dt_history_delete_on_image_ext(int32_t imgid, gboolean undo)</a>
<a name="ln59">{</a>
<a name="ln60">  dt_undo_lt_history_t *hist = undo?dt_history_snapshot_item_init():NULL;</a>
<a name="ln61"> </a>
<a name="ln62">  if(undo)</a>
<a name="ln63">  {</a>
<a name="ln64">    hist-&gt;imgid = imgid;</a>
<a name="ln65">    dt_history_snapshot_undo_create(hist-&gt;imgid, &amp;hist-&gt;before, &amp;hist-&gt;before_history_end);</a>
<a name="ln66">  }</a>
<a name="ln67"> </a>
<a name="ln68">  sqlite3_stmt *stmt;</a>
<a name="ln69"> </a>
<a name="ln70">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln71">                              &amp;stmt, NULL);</a>
<a name="ln72">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln73">  sqlite3_step(stmt);</a>
<a name="ln74">  sqlite3_finalize(stmt);</a>
<a name="ln75"> </a>
<a name="ln76">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln77">      dt_database_get(darktable.db),</a>
<a name="ln78">      &quot;UPDATE main.images SET history_end = 0, iop_order_version = 0, aspect_ratio = 0.0 WHERE id = ?1&quot;, -1, &amp;stmt,</a>
<a name="ln79">      NULL);</a>
<a name="ln80">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln81">  sqlite3_step(stmt);</a>
<a name="ln82">  sqlite3_finalize(stmt);</a>
<a name="ln83"> </a>
<a name="ln84">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.masks_history WHERE imgid = ?1&quot;, -1, &amp;stmt,</a>
<a name="ln85">                              NULL);</a>
<a name="ln86">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln87">  sqlite3_step(stmt);</a>
<a name="ln88">  sqlite3_finalize(stmt);</a>
<a name="ln89"> </a>
<a name="ln90">  remove_preset_flag(imgid);</a>
<a name="ln91"> </a>
<a name="ln92">  /* if current image in develop reload history */</a>
<a name="ln93">  if(dt_dev_is_current_image(darktable.develop, imgid)) dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln94"> </a>
<a name="ln95">  /* make sure mipmaps are recomputed */</a>
<a name="ln96">  dt_mipmap_cache_remove(darktable.mipmap_cache, imgid);</a>
<a name="ln97">  dt_image_reset_final_size(imgid);</a>
<a name="ln98"> </a>
<a name="ln99">  /* remove darktable|style|* tags */</a>
<a name="ln100">  dt_tag_detach_by_string(&quot;darktable|style%&quot;, imgid);</a>
<a name="ln101">  dt_tag_detach_by_string(&quot;darktable|changed&quot;, imgid);</a>
<a name="ln102"> </a>
<a name="ln103">  if(undo)</a>
<a name="ln104">  {</a>
<a name="ln105">    dt_history_snapshot_undo_create(hist-&gt;imgid, &amp;hist-&gt;after, &amp;hist-&gt;after_history_end);</a>
<a name="ln106"> </a>
<a name="ln107">    dt_undo_start_group(darktable.undo, DT_UNDO_LT_HISTORY);</a>
<a name="ln108">    dt_undo_record(darktable.undo, NULL, DT_UNDO_LT_HISTORY, (dt_undo_data_t)hist,</a>
<a name="ln109">                   dt_history_snapshot_undo_pop, dt_history_snapshot_undo_lt_history_data_free);</a>
<a name="ln110">    dt_undo_end_group(darktable.undo);</a>
<a name="ln111">  }</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">void dt_history_delete_on_image(int32_t imgid)</a>
<a name="ln115">{</a>
<a name="ln116">  dt_history_delete_on_image_ext(imgid, TRUE);</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">void dt_history_delete_on_selection()</a>
<a name="ln120">{</a>
<a name="ln121">  sqlite3_stmt *stmt;</a>
<a name="ln122"> </a>
<a name="ln123">  dt_undo_start_group(darktable.undo, DT_UNDO_LT_HISTORY);</a>
<a name="ln124"> </a>
<a name="ln125">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;,</a>
<a name="ln126">                              -1, &amp;stmt, NULL);</a>
<a name="ln127">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln128">  {</a>
<a name="ln129">    const int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln130">    dt_undo_lt_history_t *hist = dt_history_snapshot_item_init();</a>
<a name="ln131"> </a>
<a name="ln132">    hist-&gt;imgid = imgid;</a>
<a name="ln133">    dt_history_snapshot_undo_create(hist-&gt;imgid, &amp;hist-&gt;before, &amp;hist-&gt;before_history_end);</a>
<a name="ln134"> </a>
<a name="ln135">    dt_history_delete_on_image_ext(imgid, FALSE);</a>
<a name="ln136"> </a>
<a name="ln137">    dt_history_snapshot_undo_create(hist-&gt;imgid, &amp;hist-&gt;after, &amp;hist-&gt;after_history_end);</a>
<a name="ln138">    dt_undo_record(darktable.undo, NULL, DT_UNDO_LT_HISTORY, (dt_undo_data_t)hist,</a>
<a name="ln139">                   dt_history_snapshot_undo_pop, dt_history_snapshot_undo_lt_history_data_free);</a>
<a name="ln140"> </a>
<a name="ln141">    /* update the aspect ratio if the current sorting is based on aspect ratio, otherwise the aspect ratio will be</a>
<a name="ln142">       recalculated when the mimpap will be recreated */</a>
<a name="ln143">    if (darktable.collection-&gt;params.sort == DT_COLLECTION_SORT_ASPECT_RATIO)</a>
<a name="ln144">      dt_image_set_aspect_ratio(imgid);</a>
<a name="ln145">  }</a>
<a name="ln146">  sqlite3_finalize(stmt);</a>
<a name="ln147"> </a>
<a name="ln148">  dt_undo_end_group(darktable.undo);</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">int dt_history_load_and_apply(const int imgid, gchar *filename, int history_only)</a>
<a name="ln152">{</a>
<a name="ln153">  dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln154">  if(img)</a>
<a name="ln155">  {</a>
<a name="ln156">    dt_undo_lt_history_t *hist = dt_history_snapshot_item_init();</a>
<a name="ln157">    hist-&gt;imgid = imgid;</a>
<a name="ln158">    dt_history_snapshot_undo_create(hist-&gt;imgid, &amp;hist-&gt;before, &amp;hist-&gt;before_history_end);</a>
<a name="ln159"> </a>
<a name="ln160">    if(dt_exif_xmp_read(img, filename, history_only)) return 1;</a>
<a name="ln161"> </a>
<a name="ln162">    dt_history_snapshot_undo_create(hist-&gt;imgid, &amp;hist-&gt;after, &amp;hist-&gt;after_history_end);</a>
<a name="ln163">    dt_undo_start_group(darktable.undo, DT_UNDO_LT_HISTORY);</a>
<a name="ln164">    dt_undo_record(darktable.undo, NULL, DT_UNDO_LT_HISTORY, (dt_undo_data_t)hist,</a>
<a name="ln165">                   dt_history_snapshot_undo_pop, dt_history_snapshot_undo_lt_history_data_free);</a>
<a name="ln166">    dt_undo_end_group(darktable.undo);</a>
<a name="ln167"> </a>
<a name="ln168">    /* if current image in develop reload history */</a>
<a name="ln169">    if(dt_dev_is_current_image(darktable.develop, imgid)) dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln170"> </a>
<a name="ln171">    dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_SAFE);</a>
<a name="ln172">    dt_mipmap_cache_remove(darktable.mipmap_cache, imgid);</a>
<a name="ln173">    dt_image_reset_final_size(imgid);</a>
<a name="ln174">  }</a>
<a name="ln175">  return 0;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">int dt_history_load_and_apply_on_selection(gchar *filename)</a>
<a name="ln179">{</a>
<a name="ln180">  int res = 0;</a>
<a name="ln181">  sqlite3_stmt *stmt;</a>
<a name="ln182">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;,</a>
<a name="ln183">                              -1, &amp;stmt, NULL);</a>
<a name="ln184">  dt_undo_start_group(darktable.undo, DT_UNDO_LT_HISTORY);</a>
<a name="ln185">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln186">  {</a>
<a name="ln187">    const int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln188">    if(dt_history_load_and_apply(imgid, filename, 1)) res = 1;</a>
<a name="ln189">  }</a>
<a name="ln190">  dt_undo_end_group(darktable.undo);</a>
<a name="ln191">  sqlite3_finalize(stmt);</a>
<a name="ln192">  return res;</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">// returns the first history item with hist-&gt;module == module</a>
<a name="ln196">static dt_dev_history_item_t *_search_history_by_module(dt_develop_t *dev, dt_iop_module_t *module)</a>
<a name="ln197">{</a>
<a name="ln198">  dt_dev_history_item_t *hist_mod = NULL;</a>
<a name="ln199">  GList *history = g_list_first(dev-&gt;history);</a>
<a name="ln200">  while(history)</a>
<a name="ln201">  {</a>
<a name="ln202">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln203"> </a>
<a name="ln204">    if(hist-&gt;module == module)</a>
<a name="ln205">    {</a>
<a name="ln206">      hist_mod = hist;</a>
<a name="ln207">      break;</a>
<a name="ln208">    }</a>
<a name="ln209">    history = g_list_next(history);</a>
<a name="ln210">  }</a>
<a name="ln211">  return hist_mod;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">// returns the first history item with corresponding module-&gt;op</a>
<a name="ln215">static dt_dev_history_item_t *_search_history_by_op(dt_develop_t *dev, dt_iop_module_t *module)</a>
<a name="ln216">{</a>
<a name="ln217">  dt_dev_history_item_t *hist_mod = NULL;</a>
<a name="ln218">  GList *history = g_list_first(dev-&gt;history);</a>
<a name="ln219">  while(history)</a>
<a name="ln220">  {</a>
<a name="ln221">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln222"> </a>
<a name="ln223">    if(strcmp(hist-&gt;module-&gt;op, module-&gt;op) == 0)</a>
<a name="ln224">    {</a>
<a name="ln225">      hist_mod = hist;</a>
<a name="ln226">      break;</a>
<a name="ln227">    }</a>
<a name="ln228">    history = g_list_next(history);</a>
<a name="ln229">  }</a>
<a name="ln230">  return hist_mod;</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233">// returns the module on modules_list that is equal to module</a>
<a name="ln234">// used to check if module exists on the list</a>
<a name="ln235">static dt_iop_module_t *_search_list_iop_by_module(GList *modules_list, dt_iop_module_t *module)</a>
<a name="ln236">{</a>
<a name="ln237">  dt_iop_module_t *mod_ret = NULL;</a>
<a name="ln238">  GList *modules = g_list_first(modules_list);</a>
<a name="ln239">  while(modules)</a>
<a name="ln240">  {</a>
<a name="ln241">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln242"> </a>
<a name="ln243">    if(mod == module)</a>
<a name="ln244">    {</a>
<a name="ln245">      mod_ret = mod;</a>
<a name="ln246">      break;</a>
<a name="ln247">    }</a>
<a name="ln248">    modules = g_list_next(modules);</a>
<a name="ln249">  }</a>
<a name="ln250">  return mod_ret;</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">// returns the first module on modules_list with operation = op_name</a>
<a name="ln254">static dt_iop_module_t *_search_list_iop_by_op(GList *modules_list, const char *op_name)</a>
<a name="ln255">{</a>
<a name="ln256">  dt_iop_module_t *mod_ret = NULL;</a>
<a name="ln257">  GList *modules = g_list_first(modules_list);</a>
<a name="ln258">  while(modules)</a>
<a name="ln259">  {</a>
<a name="ln260">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln261"> </a>
<a name="ln262">    if(strcmp(mod-&gt;op, op_name) == 0)</a>
<a name="ln263">    {</a>
<a name="ln264">      mod_ret = mod;</a>
<a name="ln265">      break;</a>
<a name="ln266">    }</a>
<a name="ln267">    modules = g_list_next(modules);</a>
<a name="ln268">  }</a>
<a name="ln269">  return mod_ret;</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">// returns a new multi_priority number for op_name</a>
<a name="ln273">static int _get_new_iop_multi_priority(dt_develop_t *dev, const char *op_name)</a>
<a name="ln274">{</a>
<a name="ln275">  int multi_priority_new = -1;</a>
<a name="ln276">  GList *modules = g_list_first(dev-&gt;iop);</a>
<a name="ln277">  while(modules)</a>
<a name="ln278">  {</a>
<a name="ln279">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln280"> </a>
<a name="ln281">    if(strcmp(mod-&gt;op, op_name) == 0)</a>
<a name="ln282">    {</a>
<a name="ln283">      multi_priority_new = MAX(multi_priority_new, mod-&gt;multi_priority);</a>
<a name="ln284">    }</a>
<a name="ln285">    modules = g_list_next(modules);</a>
<a name="ln286">  }</a>
<a name="ln287">  return (multi_priority_new + 1);</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">// fills used with formid, if it is a group it recurs and fill all sub-forms</a>
<a name="ln291">static void _fill_used_forms(GList *forms_list, int formid, int *used, int nb)</a>
<a name="ln292">{</a>
<a name="ln293">  // first, we search for the formid in used table</a>
<a name="ln294">  for(int i = 0; i &lt; nb; i++)</a>
<a name="ln295">  {</a>
<a name="ln296">    if(used[i] == 0)</a>
<a name="ln297">    {</a>
<a name="ln298">      // we store the formid</a>
<a name="ln299">      used[i] = formid;</a>
<a name="ln300">      break;</a>
<a name="ln301">    }</a>
<a name="ln302">    if(used[i] == formid) break;</a>
<a name="ln303">  }</a>
<a name="ln304"> </a>
<a name="ln305">  // if the form is a group, we iterate through the sub-forms</a>
<a name="ln306">  dt_masks_form_t *form = dt_masks_get_from_id_ext(forms_list, formid);</a>
<a name="ln307">  if(form &amp;&amp; (form-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln308">  {</a>
<a name="ln309">    GList *grpts = g_list_first(form-&gt;points);</a>
<a name="ln310">    while(grpts)</a>
<a name="ln311">    {</a>
<a name="ln312">      dt_masks_point_group_t *grpt = (dt_masks_point_group_t *)grpts-&gt;data;</a>
<a name="ln313">      _fill_used_forms(forms_list, grpt-&gt;formid, used, nb);</a>
<a name="ln314">      grpts = g_list_next(grpts);</a>
<a name="ln315">    }</a>
<a name="ln316">  }</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">// dev_src is used only to copy masks, if no mask will be copied it can be null</a>
<a name="ln320">int dt_history_merge_module_into_history(dt_develop_t *dev_dest, dt_develop_t *dev_src, dt_iop_module_t *mod_src, GList **_modules_used, const int append)</a>
<a name="ln321">{</a>
<a name="ln322">  int module_added = 1;</a>
<a name="ln323">  GList *modules_used = *_modules_used;</a>
<a name="ln324">  dt_iop_module_t *module = NULL;</a>
<a name="ln325">  dt_iop_module_t *mod_replace = NULL;</a>
<a name="ln326"> </a>
<a name="ln327">  // one-instance modules always replace the existing one</a>
<a name="ln328">  if(mod_src-&gt;flags() &amp; IOP_FLAGS_ONE_INSTANCE)</a>
<a name="ln329">  {</a>
<a name="ln330">    mod_replace = _search_list_iop_by_op(dev_dest-&gt;iop, mod_src-&gt;op);</a>
<a name="ln331">    if(mod_replace == NULL)</a>
<a name="ln332">    {</a>
<a name="ln333">      fprintf(stderr, &quot;[dt_history_merge_module_into_history] can't find single instance module %s\n&quot;,</a>
<a name="ln334">              mod_src-&gt;op);</a>
<a name="ln335">      module_added = 0;</a>
<a name="ln336">    }</a>
<a name="ln337">  }</a>
<a name="ln338"> </a>
<a name="ln339">  if(module_added &amp;&amp; !append)</a>
<a name="ln340">  {</a>
<a name="ln341">    // we haven't found a module to replace</a>
<a name="ln342">    if(mod_replace == NULL)</a>
<a name="ln343">    {</a>
<a name="ln344">      // check if there's a module with the same (operation, multi_name) on dev-&gt;iop</a>
<a name="ln345">      GList *modules_dest = g_list_first(dev_dest-&gt;iop);</a>
<a name="ln346">      while(modules_dest)</a>
<a name="ln347">      {</a>
<a name="ln348">        dt_iop_module_t *mod_dest = (dt_iop_module_t *)(modules_dest-&gt;data);</a>
<a name="ln349"> </a>
<a name="ln350">        if(strcmp(mod_src-&gt;op, mod_dest-&gt;op) == 0 &amp;&amp; strcmp(mod_src-&gt;multi_name, mod_dest-&gt;multi_name) == 0)</a>
<a name="ln351">        {</a>
<a name="ln352">          // but only if it hasn't been used already</a>
<a name="ln353">          if(_search_list_iop_by_module(modules_used, mod_dest) == NULL)</a>
<a name="ln354">          {</a>
<a name="ln355">            // we will replace this module</a>
<a name="ln356">            modules_used = g_list_append(modules_used, mod_dest);</a>
<a name="ln357">            mod_replace = mod_dest;</a>
<a name="ln358">            break;</a>
<a name="ln359">          }</a>
<a name="ln360">        }</a>
<a name="ln361">        modules_dest = g_list_next(modules_dest);</a>
<a name="ln362">      }</a>
<a name="ln363">    }</a>
<a name="ln364">  }</a>
<a name="ln365"> </a>
<a name="ln366">  if(module_added)</a>
<a name="ln367">  {</a>
<a name="ln368">    // we haven't found a module to replace, so we will create a new instance</a>
<a name="ln369">    if(mod_replace == NULL)</a>
<a name="ln370">    {</a>
<a name="ln371">      // but if there's an un-used instance on dev-&gt;iop we will use that</a>
<a name="ln372">      if(_search_history_by_op(dev_dest, mod_src) == NULL)</a>
<a name="ln373">      {</a>
<a name="ln374">        // there should be only one instance of this iop (since is un-used)</a>
<a name="ln375">        mod_replace = _search_list_iop_by_op(dev_dest-&gt;iop, mod_src-&gt;op);</a>
<a name="ln376">        if(mod_replace == NULL)</a>
<a name="ln377">        {</a>
<a name="ln378">          fprintf(stderr, &quot;[dt_history_merge_module_into_history] can't find base instance module %s\n&quot;, mod_src-&gt;op);</a>
<a name="ln379">          module_added = 0;</a>
<a name="ln380">        }</a>
<a name="ln381">      }</a>
<a name="ln382">    }</a>
<a name="ln383">  }</a>
<a name="ln384"> </a>
<a name="ln385">  if(module_added)</a>
<a name="ln386">  {</a>
<a name="ln387">    // if we are creating a new instance, create a new module</a>
<a name="ln388">    if(!mod_replace)</a>
<a name="ln389">    {</a>
<a name="ln390">      dt_iop_module_t *base = _search_list_iop_by_op(dev_dest-&gt;iop, mod_src-&gt;op);</a>
<a name="ln391">      module = (dt_iop_module_t *)calloc(1, sizeof(dt_iop_module_t));</a>
<a name="ln392">      if(dt_iop_load_module(module, base-&gt;so, dev_dest))</a>
<a name="ln393">      {</a>
<a name="ln394">        fprintf(stderr, &quot;[dt_history_merge_module_into_history] can't load module %s\n&quot;, mod_src-&gt;op);</a>
<a name="ln395">        module_added = 0;</a>
<a name="ln396">      }</a>
<a name="ln397">      else</a>
<a name="ln398">      {</a>
<a name="ln399">        module-&gt;instance = mod_src-&gt;instance;</a>
<a name="ln400">        dt_iop_update_multi_priority(module, _get_new_iop_multi_priority(dev_dest, base-&gt;op));</a>
<a name="ln401">        module-&gt;iop_order = DBL_MAX;</a>
<a name="ln402">      }</a>
<a name="ln403">    }</a>
<a name="ln404">    else</a>
<a name="ln405">    {</a>
<a name="ln406">      module = mod_replace;</a>
<a name="ln407">    }</a>
<a name="ln408"> </a>
<a name="ln409">    module-&gt;enabled = mod_src-&gt;enabled;</a>
<a name="ln410">    snprintf(module-&gt;multi_name, sizeof(module-&gt;multi_name), &quot;%s&quot;, mod_src-&gt;multi_name);</a>
<a name="ln411"> </a>
<a name="ln412">    memcpy(module-&gt;params, mod_src-&gt;params, module-&gt;params_size);</a>
<a name="ln413">    if(module-&gt;flags() &amp; IOP_FLAGS_SUPPORTS_BLENDING)</a>
<a name="ln414">    {</a>
<a name="ln415">      memcpy(module-&gt;blend_params, mod_src-&gt;blend_params, sizeof(dt_develop_blend_params_t));</a>
<a name="ln416">      module-&gt;blend_params-&gt;mask_id = mod_src-&gt;blend_params-&gt;mask_id;</a>
<a name="ln417">    }</a>
<a name="ln418">  }</a>
<a name="ln419"> </a>
<a name="ln420">  // we have the module, we will use the source module iop_order unless there's already</a>
<a name="ln421">  // a module with that order</a>
<a name="ln422">  if(module_added)</a>
<a name="ln423">  {</a>
<a name="ln424">    dt_iop_module_t *module_duplicate = NULL;</a>
<a name="ln425">    // check if there's a module with the same iop_order</a>
<a name="ln426">    GList *modules_dest = g_list_first(dev_dest-&gt;iop);</a>
<a name="ln427">    while(modules_dest)</a>
<a name="ln428">    {</a>
<a name="ln429">      dt_iop_module_t *mod = (dt_iop_module_t *)(modules_dest-&gt;data);</a>
<a name="ln430"> </a>
<a name="ln431">      if(module_duplicate != NULL)</a>
<a name="ln432">      {</a>
<a name="ln433">        module_duplicate = mod;</a>
<a name="ln434">        break;</a>
<a name="ln435">      }</a>
<a name="ln436">      if(mod-&gt;iop_order == mod_src-&gt;iop_order &amp;&amp; mod != module)</a>
<a name="ln437">      {</a>
<a name="ln438">        module_duplicate = mod;</a>
<a name="ln439">      }</a>
<a name="ln440"> </a>
<a name="ln441">      modules_dest = g_list_next(modules_dest);</a>
<a name="ln442">    }</a>
<a name="ln443"> </a>
<a name="ln444">    // we are good, just use the source iop_order</a>
<a name="ln445">    if(module_duplicate == NULL)</a>
<a name="ln446">    {</a>
<a name="ln447">      module-&gt;iop_order = mod_src-&gt;iop_order;</a>
<a name="ln448">    }</a>
<a name="ln449">    // if there's a conflict, add it after the offended module</a>
<a name="ln450">    else</a>
<a name="ln451">    {</a>
<a name="ln452">      module-&gt;iop_order = mod_src-&gt;iop_order + (module_duplicate-&gt;iop_order - mod_src-&gt;iop_order) / 2.0;</a>
<a name="ln453">    }</a>
<a name="ln454"> </a>
<a name="ln455">    // do some checking...</a>
<a name="ln456">    if(mod_src-&gt;iop_order &lt;= 0.0 || mod_src-&gt;iop_order == DBL_MAX)</a>
<a name="ln457">      fprintf(stderr, &quot;[dt_history_merge_module_into_history] invalid source module %s %s(%f)(%i)\n&quot;,</a>
<a name="ln458">          mod_src-&gt;op, mod_src-&gt;multi_name, mod_src-&gt;iop_order, mod_src-&gt;multi_priority);</a>
<a name="ln459">    if(module_duplicate &amp;&amp; (module_duplicate-&gt;iop_order &lt;= 0.0 || module_duplicate-&gt;iop_order == DBL_MAX))</a>
<a name="ln460">      fprintf(stderr, &quot;[dt_history_merge_module_into_history] invalid duplicate module module %s %s(%f)(%i)\n&quot;,</a>
<a name="ln461">          module_duplicate-&gt;op, module_duplicate-&gt;multi_name, module_duplicate-&gt;iop_order, module_duplicate-&gt;multi_priority);</a>
<a name="ln462">    if(module-&gt;iop_order &lt;= 0.0 || module-&gt;iop_order == DBL_MAX)</a>
<a name="ln463">      fprintf(stderr, &quot;[dt_history_merge_module_into_history] invalid iop_order for module %s %s(%f)(%i)\n&quot;,</a>
<a name="ln464">          module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, module-&gt;multi_priority);</a>
<a name="ln465"> </a>
<a name="ln466">    // if this is a new module just add it to the list</a>
<a name="ln467">    if(mod_replace == NULL)</a>
<a name="ln468">      dev_dest-&gt;iop = g_list_insert_sorted(dev_dest-&gt;iop, module, dt_sort_iop_by_order);</a>
<a name="ln469">    else</a>
<a name="ln470">      dev_dest-&gt;iop = g_list_sort(dev_dest-&gt;iop, dt_sort_iop_by_order);</a>
<a name="ln471">  }</a>
<a name="ln472"> </a>
<a name="ln473">  // and we add it to history</a>
<a name="ln474">  if(module_added)</a>
<a name="ln475">  {</a>
<a name="ln476">    // copy masks</a>
<a name="ln477">    guint nbf = 0;</a>
<a name="ln478">    int *forms_used_replace = NULL;</a>
<a name="ln479"> </a>
<a name="ln480">    if(dev_src)</a>
<a name="ln481">    {</a>
<a name="ln482">      // we will copy only used forms</a>
<a name="ln483">      // record the masks used by this module</a>
<a name="ln484">      if(mod_src-&gt;flags() &amp; IOP_FLAGS_SUPPORTS_BLENDING &amp;&amp; mod_src-&gt;blend_params-&gt;mask_id &gt; 0)</a>
<a name="ln485">      {</a>
<a name="ln486">        nbf = g_list_length(dev_src-&gt;forms);</a>
<a name="ln487">        forms_used_replace = calloc(nbf, sizeof(int));</a>
<a name="ln488"> </a>
<a name="ln489">        _fill_used_forms(dev_src-&gt;forms, mod_src-&gt;blend_params-&gt;mask_id, forms_used_replace, nbf);</a>
<a name="ln490"> </a>
<a name="ln491">        // now copy masks</a>
<a name="ln492">        for(int i = 0; i &lt; nbf &amp;&amp; forms_used_replace[i] &gt; 0; i++)</a>
<a name="ln493">        {</a>
<a name="ln494">          dt_masks_form_t *form = dt_masks_get_from_id_ext(dev_src-&gt;forms, forms_used_replace[i]);</a>
<a name="ln495">          if(form)</a>
<a name="ln496">          {</a>
<a name="ln497">            // check if the form already exists in dest image</a>
<a name="ln498">            // if so we'll remove it, so it is replaced</a>
<a name="ln499">            dt_masks_form_t *form_dest = dt_masks_get_from_id_ext(dev_dest-&gt;forms, forms_used_replace[i]);</a>
<a name="ln500">            if(form_dest)</a>
<a name="ln501">            {</a>
<a name="ln502">              dev_dest-&gt;forms = g_list_remove(dev_dest-&gt;forms, form_dest);</a>
<a name="ln503">              // and add it to allforms to cleanup</a>
<a name="ln504">              dev_dest-&gt;allforms = g_list_append(dev_dest-&gt;allforms, form_dest);</a>
<a name="ln505">            }</a>
<a name="ln506"> </a>
<a name="ln507">            // and add it to dest image</a>
<a name="ln508">            dt_masks_form_t *form_new = dt_masks_dup_masks_form(form);</a>
<a name="ln509">            dev_dest-&gt;forms = g_list_append(dev_dest-&gt;forms, form_new);</a>
<a name="ln510">          }</a>
<a name="ln511">          else</a>
<a name="ln512">            fprintf(stderr, &quot;[dt_history_merge_module_into_history] form %i not found in source image\n&quot;, forms_used_replace[i]);</a>
<a name="ln513">        }</a>
<a name="ln514">      }</a>
<a name="ln515">    }</a>
<a name="ln516"> </a>
<a name="ln517">    if(nbf &gt; 0 &amp;&amp; forms_used_replace[0] &gt; 0)</a>
<a name="ln518">      dt_dev_add_masks_history_item_ext(dev_dest, module, FALSE, TRUE);</a>
<a name="ln519">    else</a>
<a name="ln520">      dt_dev_add_history_item_ext(dev_dest, module, FALSE, TRUE);</a>
<a name="ln521">    dt_dev_pop_history_items_ext(dev_dest, dev_dest-&gt;history_end);</a>
<a name="ln522"> </a>
<a name="ln523">    if(forms_used_replace) free(forms_used_replace);</a>
<a name="ln524">  }</a>
<a name="ln525"> </a>
<a name="ln526">  *_modules_used = modules_used;</a>
<a name="ln527"> </a>
<a name="ln528">  return module_added;</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">static int _history_copy_and_paste_on_image_merge(int32_t imgid, int32_t dest_imgid, GList *ops)</a>
<a name="ln532">{</a>
<a name="ln533">  GList *modules_used = NULL;</a>
<a name="ln534"> </a>
<a name="ln535">  dt_develop_t _dev_src = { 0 };</a>
<a name="ln536">  dt_develop_t _dev_dest = { 0 };</a>
<a name="ln537"> </a>
<a name="ln538">  dt_develop_t *dev_src = &amp;_dev_src;</a>
<a name="ln539">  dt_develop_t *dev_dest = &amp;_dev_dest;</a>
<a name="ln540"> </a>
<a name="ln541">  // we will do the copy/paste on memory so we can deal with masks</a>
<a name="ln542">  dt_dev_init(dev_src, FALSE);</a>
<a name="ln543">  dt_dev_init(dev_dest, FALSE);</a>
<a name="ln544"> </a>
<a name="ln545">  dev_src-&gt;iop = dt_iop_load_modules_ext(dev_src, TRUE);</a>
<a name="ln546">  dev_dest-&gt;iop = dt_iop_load_modules_ext(dev_dest, TRUE);</a>
<a name="ln547"> </a>
<a name="ln548">  dt_dev_read_history_ext(dev_src, imgid, TRUE);</a>
<a name="ln549">  dt_dev_read_history_ext(dev_dest, dest_imgid, TRUE);</a>
<a name="ln550"> </a>
<a name="ln551">  dt_ioppr_check_iop_order(dev_src, imgid, &quot;_history_copy_and_paste_on_image_merge &quot;);</a>
<a name="ln552">  dt_ioppr_check_iop_order(dev_dest, imgid, &quot;_history_copy_and_paste_on_image_merge &quot;);</a>
<a name="ln553"> </a>
<a name="ln554">  dt_dev_pop_history_items_ext(dev_src, dev_src-&gt;history_end);</a>
<a name="ln555">  dt_dev_pop_history_items_ext(dev_dest, dev_dest-&gt;history_end);</a>
<a name="ln556"> </a>
<a name="ln557">  dt_ioppr_check_iop_order(dev_src, imgid, &quot;_history_copy_and_paste_on_image_merge 1&quot;);</a>
<a name="ln558">  dt_ioppr_check_iop_order(dev_dest, imgid, &quot;_history_copy_and_paste_on_image_merge 1&quot;);</a>
<a name="ln559"> </a>
<a name="ln560">  // the user have selected some history entries</a>
<a name="ln561">  if(ops)</a>
<a name="ln562">  {</a>
<a name="ln563">    // copy only selected history entries</a>
<a name="ln564">    GList *l = g_list_last(ops);</a>
<a name="ln565">    while(l)</a>
<a name="ln566">    {</a>
<a name="ln567">      unsigned int num = GPOINTER_TO_UINT(l-&gt;data);</a>
<a name="ln568"> </a>
<a name="ln569">      dt_dev_history_item_t *hist = g_list_nth_data(dev_src-&gt;history, num);</a>
<a name="ln570"> </a>
<a name="ln571">      if(hist)</a>
<a name="ln572">      {</a>
<a name="ln573">        // merge the entry</a>
<a name="ln574">        dt_history_merge_module_into_history(dev_dest, dev_src, hist-&gt;module, &amp;modules_used, FALSE);</a>
<a name="ln575">      }</a>
<a name="ln576"> </a>
<a name="ln577">      l = g_list_previous(l);</a>
<a name="ln578">    }</a>
<a name="ln579">  }</a>
<a name="ln580">  else</a>
<a name="ln581">  {</a>
<a name="ln582">    // we will copy all modules</a>
<a name="ln583">    GList *modules_src = g_list_first(dev_src-&gt;iop);</a>
<a name="ln584">    while(modules_src)</a>
<a name="ln585">    {</a>
<a name="ln586">      dt_iop_module_t *mod_src = (dt_iop_module_t *)(modules_src-&gt;data);</a>
<a name="ln587"> </a>
<a name="ln588">      // but only if module is in history in source image</a>
<a name="ln589">      if(_search_history_by_module(dev_src, mod_src) != NULL)</a>
<a name="ln590">      {</a>
<a name="ln591">        // merge the module into dest image</a>
<a name="ln592">        dt_history_merge_module_into_history(dev_dest, dev_src, mod_src, &amp;modules_used, FALSE);</a>
<a name="ln593">      }</a>
<a name="ln594"> </a>
<a name="ln595">      modules_src = g_list_next(modules_src);</a>
<a name="ln596">    }</a>
<a name="ln597">  }</a>
<a name="ln598"> </a>
<a name="ln599">  dt_ioppr_check_iop_order(dev_src, imgid, &quot;_history_copy_and_paste_on_image_merge 2&quot;);</a>
<a name="ln600">  dt_ioppr_check_iop_order(dev_dest, imgid, &quot;_history_copy_and_paste_on_image_merge 2&quot;);</a>
<a name="ln601"> </a>
<a name="ln602">  // write history and forms to db</a>
<a name="ln603">  dt_dev_write_history_ext(dev_dest, dest_imgid);</a>
<a name="ln604"> </a>
<a name="ln605">  dt_dev_cleanup(dev_src);</a>
<a name="ln606">  dt_dev_cleanup(dev_dest);</a>
<a name="ln607"> </a>
<a name="ln608">  g_list_free(modules_used);</a>
<a name="ln609"> </a>
<a name="ln610">  return 0;</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">static int _history_copy_and_paste_on_image_overwrite(int32_t imgid, int32_t dest_imgid, GList *ops)</a>
<a name="ln614">{</a>
<a name="ln615">  int ret_val = 0;</a>
<a name="ln616">  sqlite3_stmt *stmt;</a>
<a name="ln617"> </a>
<a name="ln618">  // replace history stack</a>
<a name="ln619">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln620">                              &amp;stmt, NULL);</a>
<a name="ln621">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln622">  sqlite3_step(stmt);</a>
<a name="ln623">  sqlite3_finalize(stmt);</a>
<a name="ln624"> </a>
<a name="ln625">  // and shapes</a>
<a name="ln626">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.masks_history WHERE imgid = ?1&quot;, -1, &amp;stmt,</a>
<a name="ln627">                              NULL);</a>
<a name="ln628">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln629">  sqlite3_step(stmt);</a>
<a name="ln630">  sqlite3_finalize(stmt);</a>
<a name="ln631"> </a>
<a name="ln632">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln633">      dt_database_get(darktable.db),</a>
<a name="ln634">      &quot;UPDATE main.images SET history_end = 0, iop_order_version = 0, aspect_ratio = 0.0 WHERE id = ?1&quot;, -1, &amp;stmt,</a>
<a name="ln635">      NULL);</a>
<a name="ln636">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln637">  sqlite3_step(stmt);</a>
<a name="ln638">  sqlite3_finalize(stmt);</a>
<a name="ln639"> </a>
<a name="ln640">  // the user wants an exact duplicate of the history, so just copy the db</a>
<a name="ln641">  if(!ops)</a>
<a name="ln642">  {</a>
<a name="ln643">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln644">                                &quot;INSERT INTO main.history &quot;</a>
<a name="ln645">                                &quot;(imgid,num,module,operation,op_params,enabled,blendop_params, &quot;</a>
<a name="ln646">                                &quot;blendop_version,multi_priority,multi_name,iop_order) SELECT &quot;</a>
<a name="ln647">                                &quot;?1,num,module,operation,op_params,enabled,blendop_params, &quot;</a>
<a name="ln648">                                &quot;blendop_version,multi_priority,multi_name,iop_order &quot;</a>
<a name="ln649">                                &quot;FROM main.history WHERE imgid=?2 ORDER BY num&quot;,</a>
<a name="ln650">                                -1, &amp;stmt, NULL);</a>
<a name="ln651">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln652">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln653">    sqlite3_step(stmt);</a>
<a name="ln654">    sqlite3_finalize(stmt);</a>
<a name="ln655"> </a>
<a name="ln656">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln657">                                &quot;INSERT INTO main.masks_history &quot;</a>
<a name="ln658">                                &quot;(imgid, num, formid, form, name, version, points, points_count, source) SELECT &quot;</a>
<a name="ln659">                                &quot;?1, num, formid, form, name, version, points, points_count, source &quot;</a>
<a name="ln660">                                &quot;FROM main.masks_history WHERE imgid = ?2&quot;,</a>
<a name="ln661">                                -1, &amp;stmt, NULL);</a>
<a name="ln662">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln663">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln664">    sqlite3_step(stmt);</a>
<a name="ln665">    sqlite3_finalize(stmt);</a>
<a name="ln666"> </a>
<a name="ln667">    int history_end = 0;</a>
<a name="ln668">    int iop_order_version = 0;</a>
<a name="ln669">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln670">                                &quot;SELECT history_end, iop_order_version FROM main.images WHERE id = ?1&quot;,</a>
<a name="ln671">                                -1, &amp;stmt, NULL);</a>
<a name="ln672">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln673">    if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln674">    {</a>
<a name="ln675">      if(sqlite3_column_type(stmt, 0) != SQLITE_NULL)</a>
<a name="ln676">        history_end = sqlite3_column_int(stmt, 0);</a>
<a name="ln677">      if(sqlite3_column_type(stmt, 1) != SQLITE_NULL)</a>
<a name="ln678">        iop_order_version = sqlite3_column_int(stmt, 1);</a>
<a name="ln679">    }</a>
<a name="ln680">    sqlite3_finalize(stmt);</a>
<a name="ln681"> </a>
<a name="ln682">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln683">                                &quot;UPDATE main.images SET history_end = ?2, iop_order_version = ?3 &quot;</a>
<a name="ln684">                                &quot; WHERE id = ?1&quot;,</a>
<a name="ln685">                                -1, &amp;stmt, NULL);</a>
<a name="ln686">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln687">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, history_end);</a>
<a name="ln688">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, iop_order_version);</a>
<a name="ln689">    sqlite3_step(stmt);</a>
<a name="ln690">    sqlite3_finalize(stmt);</a>
<a name="ln691">  }</a>
<a name="ln692">  else</a>
<a name="ln693">  {</a>
<a name="ln694">    // since the history and masks where deleted we can do a merge</a>
<a name="ln695">    ret_val = _history_copy_and_paste_on_image_merge(imgid, dest_imgid, ops);</a>
<a name="ln696">  }</a>
<a name="ln697"> </a>
<a name="ln698">  return ret_val;</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">int dt_history_copy_and_paste_on_image(int32_t imgid, int32_t dest_imgid, gboolean merge, GList *ops)</a>
<a name="ln702">{</a>
<a name="ln703">  if(imgid == dest_imgid) return 1;</a>
<a name="ln704"> </a>
<a name="ln705">  if(imgid == -1)</a>
<a name="ln706">  {</a>
<a name="ln707">    dt_control_log(_(&quot;you need to copy history from an image before you paste it onto another&quot;));</a>
<a name="ln708">    return 1;</a>
<a name="ln709">  }</a>
<a name="ln710"> </a>
<a name="ln711">  // be sure the current history is written before pasting some other history data</a>
<a name="ln712">  const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln713">  if(cv-&gt;view((dt_view_t *)cv) == DT_VIEW_DARKROOM) dt_dev_write_history(darktable.develop);</a>
<a name="ln714"> </a>
<a name="ln715">  dt_undo_lt_history_t *hist = dt_history_snapshot_item_init();</a>
<a name="ln716">  hist-&gt;imgid = dest_imgid;</a>
<a name="ln717">  dt_history_snapshot_undo_create(hist-&gt;imgid, &amp;hist-&gt;before, &amp;hist-&gt;before_history_end);</a>
<a name="ln718"> </a>
<a name="ln719">  int ret_val = 0;</a>
<a name="ln720">  if(merge)</a>
<a name="ln721">    ret_val = _history_copy_and_paste_on_image_merge(imgid, dest_imgid, ops);</a>
<a name="ln722">  else</a>
<a name="ln723">    ret_val = _history_copy_and_paste_on_image_overwrite(imgid, dest_imgid, ops);</a>
<a name="ln724"> </a>
<a name="ln725">  dt_history_snapshot_undo_create(hist-&gt;imgid, &amp;hist-&gt;after, &amp;hist-&gt;after_history_end);</a>
<a name="ln726">  dt_undo_start_group(darktable.undo, DT_UNDO_LT_HISTORY);</a>
<a name="ln727">  dt_undo_record(darktable.undo, NULL, DT_UNDO_LT_HISTORY, (dt_undo_data_t)hist,</a>
<a name="ln728">                 dt_history_snapshot_undo_pop, dt_history_snapshot_undo_lt_history_data_free);</a>
<a name="ln729">  dt_undo_end_group(darktable.undo);</a>
<a name="ln730"> </a>
<a name="ln731">  /* attach changed tag reflecting actual change */</a>
<a name="ln732">  guint tagid = 0;</a>
<a name="ln733">  dt_tag_new(&quot;darktable|changed&quot;, &amp;tagid);</a>
<a name="ln734">  dt_tag_attach(tagid, dest_imgid);</a>
<a name="ln735"> </a>
<a name="ln736">  /* if current image in develop reload history */</a>
<a name="ln737">  if(dt_dev_is_current_image(darktable.develop, dest_imgid))</a>
<a name="ln738">  {</a>
<a name="ln739">    dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln740">    dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln741">  }</a>
<a name="ln742"> </a>
<a name="ln743">  /* update xmp file */</a>
<a name="ln744">  dt_image_synch_xmp(dest_imgid);</a>
<a name="ln745"> </a>
<a name="ln746">  dt_mipmap_cache_remove(darktable.mipmap_cache, dest_imgid);</a>
<a name="ln747">  dt_image_reset_final_size(imgid);</a>
<a name="ln748"> </a>
<a name="ln749">  /* update the aspect ratio. recompute only if really needed for performance reasons */</a>
<a name="ln750">  if(darktable.collection-&gt;params.sort == DT_COLLECTION_SORT_ASPECT_RATIO)</a>
<a name="ln751">    dt_image_set_aspect_ratio(dest_imgid);</a>
<a name="ln752">  else</a>
<a name="ln753">    dt_image_reset_aspect_ratio(dest_imgid);</a>
<a name="ln754"> </a>
<a name="ln755">  return ret_val;</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758">GList *dt_history_get_items(int32_t imgid, gboolean enabled)</a>
<a name="ln759">{</a>
<a name="ln760">  GList *result = NULL;</a>
<a name="ln761">  sqlite3_stmt *stmt;</a>
<a name="ln762"> </a>
<a name="ln763">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln764">                              &quot;SELECT num, operation, enabled, multi_name FROM main.history WHERE imgid=?1 AND &quot;</a>
<a name="ln765">                              &quot;num IN (SELECT MAX(num) FROM main.history hst2 WHERE hst2.imgid=?1 AND &quot;</a>
<a name="ln766">                              &quot;hst2.operation=main.history.operation GROUP BY multi_priority) &quot;</a>
<a name="ln767">                              &quot;ORDER BY num DESC&quot;,</a>
<a name="ln768">                              -1, &amp;stmt, NULL);</a>
<a name="ln769">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln770">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln771">  {</a>
<a name="ln772">    if(strcmp((const char*)sqlite3_column_text(stmt, 1), &quot;mask_manager&quot;) == 0) continue;</a>
<a name="ln773"> </a>
<a name="ln774">    char name[512] = { 0 };</a>
<a name="ln775">    const int is_active = sqlite3_column_int(stmt, 2);</a>
<a name="ln776"> </a>
<a name="ln777">    if(enabled == FALSE || is_active)</a>
<a name="ln778">    {</a>
<a name="ln779">      dt_history_item_t *item = g_malloc(sizeof(dt_history_item_t));</a>
<a name="ln780">      item-&gt;num = sqlite3_column_int(stmt, 0);</a>
<a name="ln781">      char *mname = NULL;</a>
<a name="ln782">      mname = g_strdup((gchar *)sqlite3_column_text(stmt, 3));</a>
<a name="ln783">      if(enabled)</a>
<a name="ln784">      {</a>
<a name="ln785">        if(strcmp(mname, &quot;0&quot;) == 0)</a>
<a name="ln786">          g_snprintf(name, sizeof(name), &quot;%s&quot;,</a>
<a name="ln787">                     dt_iop_get_localized_name((char *)sqlite3_column_text(stmt, 1)));</a>
<a name="ln788">        else</a>
<a name="ln789">          g_snprintf(name, sizeof(name), &quot;%s %s&quot;,</a>
<a name="ln790">                     dt_iop_get_localized_name((char *)sqlite3_column_text(stmt, 1)),</a>
<a name="ln791">                     (char *)sqlite3_column_text(stmt, 3));</a>
<a name="ln792">      }</a>
<a name="ln793">      else</a>
<a name="ln794">      {</a>
<a name="ln795">        if(strcmp(mname, &quot;0&quot;) == 0)</a>
<a name="ln796">          g_snprintf(name, sizeof(name), &quot;%s (%s)&quot;,</a>
<a name="ln797">                     dt_iop_get_localized_name((char *)sqlite3_column_text(stmt, 1)),</a>
<a name="ln798">                     (is_active != 0) ? _(&quot;on&quot;) : _(&quot;off&quot;));</a>
<a name="ln799">        g_snprintf(name, sizeof(name), &quot;%s %s (%s)&quot;,</a>
<a name="ln800">                   dt_iop_get_localized_name((char *)sqlite3_column_text(stmt, 1)),</a>
<a name="ln801">                   (char *)sqlite3_column_text(stmt, 3), (is_active != 0) ? _(&quot;on&quot;) : _(&quot;off&quot;));</a>
<a name="ln802">      }</a>
<a name="ln803">      item-&gt;name = g_strdup(name);</a>
<a name="ln804">      item-&gt;op = g_strdup((gchar *)sqlite3_column_text(stmt, 1));</a>
<a name="ln805">      result = g_list_append(result, item);</a>
<a name="ln806"> </a>
<a name="ln807">      g_free(mname);</a>
<a name="ln808">    }</a>
<a name="ln809">  }</a>
<a name="ln810">  sqlite3_finalize(stmt);</a>
<a name="ln811">  return result;</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814">char *dt_history_get_items_as_string(int32_t imgid)</a>
<a name="ln815">{</a>
<a name="ln816">  GList *items = NULL;</a>
<a name="ln817">  const char *onoff[2] = { _(&quot;off&quot;), _(&quot;on&quot;) };</a>
<a name="ln818">  sqlite3_stmt *stmt;</a>
<a name="ln819">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln820">      dt_database_get(darktable.db),</a>
<a name="ln821">      &quot;SELECT operation, enabled, multi_name FROM main.history WHERE imgid=?1 ORDER BY num DESC&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln822">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln823"> </a>
<a name="ln824">  // collect all the entries in the history from the db</a>
<a name="ln825">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln826">  {</a>
<a name="ln827">    char *name = NULL, *multi_name = NULL;</a>
<a name="ln828">    const char *mn = (char *)sqlite3_column_text(stmt, 2);</a>
<a name="ln829">    if(mn &amp;&amp; *mn &amp;&amp; g_strcmp0(mn, &quot; &quot;) != 0 &amp;&amp; g_strcmp0(mn, &quot;0&quot;) != 0)</a>
<a name="ln830">      multi_name = g_strconcat(&quot; &quot;, sqlite3_column_text(stmt, 2), NULL);</a>
<a name="ln831">    name = g_strconcat(dt_iop_get_localized_name((char *)sqlite3_column_text(stmt, 0)),</a>
<a name="ln832">                       multi_name ? multi_name : &quot;&quot;, &quot; (&quot;,</a>
<a name="ln833">                       (sqlite3_column_int(stmt, 1) == 0) ? onoff[0] : onoff[1], &quot;)&quot;, NULL);</a>
<a name="ln834">    items = g_list_append(items, name);</a>
<a name="ln835">    g_free(multi_name);</a>
<a name="ln836">  }</a>
<a name="ln837">  sqlite3_finalize(stmt);</a>
<a name="ln838">  char *result = dt_util_glist_to_str(&quot;\n&quot;, items);</a>
<a name="ln839">  g_list_free_full(items, g_free);</a>
<a name="ln840">  return result;</a>
<a name="ln841">}</a>
<a name="ln842"> </a>
<a name="ln843">int dt_history_copy_and_paste_on_selection(int32_t imgid, gboolean merge, GList *ops)</a>
<a name="ln844">{</a>
<a name="ln845">  if(imgid &lt; 0) return 1;</a>
<a name="ln846"> </a>
<a name="ln847">  int res = 0;</a>
<a name="ln848">  sqlite3_stmt *stmt;</a>
<a name="ln849">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln850">                              &quot;SELECT imgid FROM main.selected_images WHERE imgid != ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln851">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln852">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln853">  {</a>
<a name="ln854">    dt_undo_start_group(darktable.undo, DT_UNDO_LT_HISTORY);</a>
<a name="ln855">    do</a>
<a name="ln856">    {</a>
<a name="ln857">      /* get imgid of selected image */</a>
<a name="ln858">      int32_t dest_imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln859"> </a>
<a name="ln860">      /* paste history stack onto image id */</a>
<a name="ln861">      dt_history_copy_and_paste_on_image(imgid, dest_imgid, merge, ops);</a>
<a name="ln862"> </a>
<a name="ln863">    } while(sqlite3_step(stmt) == SQLITE_ROW);</a>
<a name="ln864">    dt_undo_end_group(darktable.undo);</a>
<a name="ln865">  }</a>
<a name="ln866">  else</a>
<a name="ln867">    res = 1;</a>
<a name="ln868"> </a>
<a name="ln869">  sqlite3_finalize(stmt);</a>
<a name="ln870">  return res;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">void dt_history_set_compress_problem(int32_t imgid, gboolean set)</a>
<a name="ln874">{</a>
<a name="ln875">  guint tagid = 0;</a>
<a name="ln876">  char tagname[64];</a>
<a name="ln877">  snprintf(tagname, sizeof(tagname), &quot;darktable|problem|history-compress&quot;);</a>
<a name="ln878">  dt_tag_new(tagname, &amp;tagid);</a>
<a name="ln879">  if (set)</a>
<a name="ln880">    dt_tag_attach(tagid, imgid);</a>
<a name="ln881">  else</a>
<a name="ln882">    dt_tag_detach(tagid, imgid);</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885">static int dt_history_end_attop(int32_t imgid)</a>
<a name="ln886">{</a>
<a name="ln887">  int size=0;</a>
<a name="ln888">  int end=0;</a>
<a name="ln889">  sqlite3_stmt *stmt;</a>
<a name="ln890"> </a>
<a name="ln891">  // get highest num in history</a>
<a name="ln892">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln893">    &quot;SELECT MAX(num) FROM main.history WHERE imgid=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln894">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln895"> </a>
<a name="ln896">  if (sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln897">    size = sqlite3_column_int(stmt, 0);</a>
<a name="ln898">  sqlite3_finalize(stmt);</a>
<a name="ln899"> </a>
<a name="ln900">  // get history_end</a>
<a name="ln901">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln902">    &quot;SELECT history_end FROM main.images WHERE id=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln903">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln904"> </a>
<a name="ln905">  if (sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln906">    end = sqlite3_column_int(stmt, 0);</a>
<a name="ln907">  sqlite3_finalize(stmt);</a>
<a name="ln908"> </a>
<a name="ln909">  // fprintf(stderr,&quot;\ndt_history_end_attop for image %i: size %i, end %i&quot;,imgid,size,end);</a>
<a name="ln910"> </a>
<a name="ln911">  // a special case right after removing all history</a>
<a name="ln912">  // It must be absolutely fresh and untouched so history_end is always on top</a>
<a name="ln913">  if ((size==0) &amp;&amp; (end==0)) return -1;</a>
<a name="ln914"> </a>
<a name="ln915">  // return 1 if end is larger than size</a>
<a name="ln916">  if (end &gt; size) return 1;</a>
<a name="ln917"> </a>
<a name="ln918">  // no compression as history_end is right in the middle of stack</a>
<a name="ln919">  return 0;</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922"> </a>
<a name="ln923">/* Please note: dt_history_compress_on_image</a>
<a name="ln924">  - is used in lighttable and darkroom mode</a>
<a name="ln925">  - It compresses history *exclusively* in the database and does *not* touch anything on the history stack</a>
<a name="ln926">*/</a>
<a name="ln927">void dt_history_compress_on_image(int32_t imgid)</a>
<a name="ln928">{</a>
<a name="ln929">  sqlite3_stmt *stmt;</a>
<a name="ln930"> </a>
<a name="ln931">  // get history_end for image</a>
<a name="ln932">  int my_history_end = 0;</a>
<a name="ln933">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln934">    &quot;SELECT history_end FROM main.images WHERE id=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln935">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln936"> </a>
<a name="ln937">  if (sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln938">    my_history_end = sqlite3_column_int(stmt, 0);</a>
<a name="ln939">  sqlite3_finalize(stmt);</a>
<a name="ln940"> </a>
<a name="ln941">  if (my_history_end == 0) return;</a>
<a name="ln942"> </a>
<a name="ln943">  // compress history, keep disabled modules as documented</a>
<a name="ln944">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln945">                              &quot;DELETE FROM main.history WHERE imgid = ?1 AND num &quot;</a>
<a name="ln946">                              &quot;NOT IN (SELECT MAX(num) FROM main.history WHERE &quot;</a>
<a name="ln947">                              &quot;imgid = ?1 AND num &lt; ?2 GROUP BY operation, &quot;</a>
<a name="ln948">                              &quot;multi_priority)&quot;,</a>
<a name="ln949">                              -1, &amp;stmt, NULL);</a>
<a name="ln950">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln951">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, my_history_end);</a>
<a name="ln952">  sqlite3_step(stmt);</a>
<a name="ln953">  sqlite3_finalize(stmt);</a>
<a name="ln954"> </a>
<a name="ln955">  int masks_count = 0;</a>
<a name="ln956">  char op_mask_manager[20] = { 0 };</a>
<a name="ln957"> </a>
<a name="ln958">  gboolean manager_position = FALSE;</a>
<a name="ln959">  // do we already have a mask manager at the correct position? We don't want to increase history nums later</a>
<a name="ln960">  g_strlcpy(op_mask_manager, &quot;mask_manager&quot;, sizeof(op_mask_manager));</a>
<a name="ln961"> </a>
<a name="ln962">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln963">                              &quot;SELECT num FROM main.history WHERE imgid = ?1 AND operation = ?2&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln964">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln965">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, op_mask_manager, -1, SQLITE_TRANSIENT);</a>
<a name="ln966">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln967">    {</a>
<a name="ln968">      if (sqlite3_column_int(stmt, 0) == 0) manager_position = TRUE;</a>
<a name="ln969">    }</a>
<a name="ln970">  sqlite3_finalize(stmt);</a>
<a name="ln971"> </a>
<a name="ln972">  // delete all mask_manager entries</a>
<a name="ln973">  g_strlcpy(op_mask_manager, &quot;mask_manager&quot;, sizeof(op_mask_manager));</a>
<a name="ln974"> </a>
<a name="ln975">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln976">                              &quot;DELETE FROM main.history WHERE imgid = ?1 AND operation = ?2&quot;, -1, &amp;stmt,</a>
<a name="ln977">                              NULL);</a>
<a name="ln978">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln979">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, op_mask_manager, -1, SQLITE_TRANSIENT);</a>
<a name="ln980">  sqlite3_step(stmt);</a>
<a name="ln981">  sqlite3_finalize(stmt);</a>
<a name="ln982"> </a>
<a name="ln983">  // compress masks history, this keeps masks owned by the mask manager.</a>
<a name="ln984">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.masks_history WHERE imgid = ?1 AND num &quot;</a>
<a name="ln985">                                                             &quot;NOT IN (SELECT MAX(num) FROM main.masks_history WHERE &quot;</a>
<a name="ln986">                                                             &quot;imgid = ?1 AND num &lt; ?2)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln987">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln988">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, my_history_end);</a>
<a name="ln989">  sqlite3_step(stmt);</a>
<a name="ln990">  sqlite3_finalize(stmt);</a>
<a name="ln991"> </a>
<a name="ln992">  // if there's masks create a mask manage entry</a>
<a name="ln993">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln994">                              &quot;SELECT COUNT(*) FROM main.masks_history WHERE imgid = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln995">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln996">  if(sqlite3_step(stmt) == SQLITE_ROW) masks_count = sqlite3_column_int(stmt, 0);</a>
<a name="ln997">  sqlite3_finalize(stmt);</a>
<a name="ln998"> </a>
<a name="ln999">  if(masks_count &gt; 0)</a>
<a name="ln1000">  {</a>
<a name="ln1001">    // set the masks history as first entry. This means the mask is owned by the manager, is this really correct and desired?</a>
<a name="ln1002">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1003">                                &quot;UPDATE main.masks_history SET num = 0 WHERE imgid = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1004">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1005">    sqlite3_step(stmt);</a>
<a name="ln1006">    sqlite3_finalize(stmt);</a>
<a name="ln1007"> </a>
<a name="ln1008">    if (!manager_position)</a>
<a name="ln1009">    {</a>
<a name="ln1010">      // make room for mask manager history entry</a>
<a name="ln1011">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1012">        &quot;UPDATE main.history SET num=num+1 WHERE imgid = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1013">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1014">      sqlite3_step(stmt);</a>
<a name="ln1015">      sqlite3_finalize(stmt);</a>
<a name="ln1016"> </a>
<a name="ln1017">      // update history end</a>
<a name="ln1018">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1019">        &quot;UPDATE main.images SET history_end = history_end+1 WHERE id = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1020">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1021">      sqlite3_step(stmt);</a>
<a name="ln1022">      sqlite3_finalize(stmt);</a>
<a name="ln1023">    }</a>
<a name="ln1024">    const double iop_order = dt_ioppr_get_iop_order(darktable.develop-&gt;iop_order_list, op_mask_manager);</a>
<a name="ln1025"> </a>
<a name="ln1026">    // create a mask manager entry in history as first entry</a>
<a name="ln1027">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1028">                                &quot;INSERT INTO main.history (imgid, num, operation, op_params, module, enabled, &quot;</a>
<a name="ln1029">                                &quot;blendop_params, blendop_version, multi_priority, multi_name, iop_order) &quot;</a>
<a name="ln1030">                                &quot;VALUES(?1, 0, ?2, NULL, 1, 0, NULL, 0, 0, '', ?3)&quot;,</a>
<a name="ln1031">                                -1, &amp;stmt, NULL);</a>
<a name="ln1032">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1033">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, op_mask_manager, -1, SQLITE_TRANSIENT);</a>
<a name="ln1034">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 3, iop_order);</a>
<a name="ln1035">    sqlite3_step(stmt);</a>
<a name="ln1036">    sqlite3_finalize(stmt);</a>
<a name="ln1037">  }</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040">#define no_forced_reordering FALSE</a>
<a name="ln1041">#define give_reorder_information FALSE</a>
<a name="ln1042">static void _history_reorder(int32_t imgid)</a>
<a name="ln1043">{</a>
<a name="ln1044">  int32_t dummy = 0x7fffffff;</a>
<a name="ln1045">  sqlite3_stmt *stmt;</a>
<a name="ln1046">  if(give_reorder_information) fprintf(stderr,&quot;\n\n_history reorder for image: %i&quot;,imgid);</a>
<a name="ln1047"> </a>
<a name="ln1048">  if(no_forced_reordering)</a>
<a name="ln1049">  {</a>
<a name="ln1050">    if (give_reorder_information) fprintf(stderr,&quot;, no action\n&quot;);</a>
<a name="ln1051">  }</a>
<a name="ln1052">  else</a>
<a name="ln1053">  {</a>
<a name="ln1054">    if (give_reorder_information) fprintf(stderr,&quot;, reorder\n&quot;);</a>
<a name="ln1055"> </a>
<a name="ln1056">    _history_copy_and_paste_on_image_overwrite(imgid, dummy, 0);</a>
<a name="ln1057">    _history_copy_and_paste_on_image_overwrite(dummy, imgid, 0);</a>
<a name="ln1058"> </a>
<a name="ln1059">    // make sure a cleanup</a>
<a name="ln1060">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1061">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dummy);</a>
<a name="ln1062">    sqlite3_step(stmt);</a>
<a name="ln1063">    sqlite3_finalize(stmt);</a>
<a name="ln1064"> </a>
<a name="ln1065">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.masks_history WHERE imgid = ?1&quot;, -1, &amp;stmt,NULL);</a>
<a name="ln1066">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dummy);</a>
<a name="ln1067">    sqlite3_step(stmt);</a>
<a name="ln1068">    sqlite3_finalize(stmt);</a>
<a name="ln1069">  }</a>
<a name="ln1070">}</a>
<a name="ln1071">#undef give_reorder_information</a>
<a name="ln1072">#undef no_forced_reordering</a>
<a name="ln1073"> </a>
<a name="ln1074">int dt_history_compress_on_selection()</a>
<a name="ln1075">{</a>
<a name="ln1076">  int uncompressed=0;</a>
<a name="ln1077"> </a>
<a name="ln1078">  // Get the list of selected images</a>
<a name="ln1079">  sqlite3_stmt *stmt;</a>
<a name="ln1080">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1081"> </a>
<a name="ln1082">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1083">  {</a>
<a name="ln1084">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1085">    const int test = dt_history_end_attop(imgid);</a>
<a name="ln1086">    if (test == 1) // we do a compression and we know for sure history_end is at the top!</a>
<a name="ln1087">    {</a>
<a name="ln1088">      dt_history_set_compress_problem(imgid, FALSE);</a>
<a name="ln1089">      dt_history_compress_on_image(imgid);</a>
<a name="ln1090">      _history_reorder(imgid);</a>
<a name="ln1091"> </a>
<a name="ln1092">      // now the modules are in right order but need renumbering to remove leaks</a>
<a name="ln1093">      int max=0;    // the maximum num in main_history for an image</a>
<a name="ln1094">      int size=0;   // the number of items in main_history for an image</a>
<a name="ln1095">      int done=0;   // used for renumbering index</a>
<a name="ln1096"> </a>
<a name="ln1097">      sqlite3_stmt *stmt2;</a>
<a name="ln1098"> </a>
<a name="ln1099">      // get highest num in history</a>
<a name="ln1100">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1101">        &quot;SELECT MAX(num) FROM main.history WHERE imgid=?1&quot;, -1, &amp;stmt2, NULL);</a>
<a name="ln1102">      DT_DEBUG_SQLITE3_BIND_INT(stmt2, 1, imgid);</a>
<a name="ln1103">      if (sqlite3_step(stmt2) == SQLITE_ROW)</a>
<a name="ln1104">        max = sqlite3_column_int(stmt2, 0);</a>
<a name="ln1105">      sqlite3_finalize(stmt2);</a>
<a name="ln1106"> </a>
<a name="ln1107">      // get number of items in main.history</a>
<a name="ln1108">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1109">        &quot;SELECT COUNT(*) FROM main.history WHERE imgid = ?1&quot;, -1, &amp;stmt2, NULL);</a>
<a name="ln1110">      DT_DEBUG_SQLITE3_BIND_INT(stmt2, 1, imgid);</a>
<a name="ln1111">      if(sqlite3_step(stmt2) == SQLITE_ROW)</a>
<a name="ln1112">        size = sqlite3_column_int(stmt2, 0);</a>
<a name="ln1113">      sqlite3_finalize(stmt2);</a>
<a name="ln1114"> </a>
<a name="ln1115">      if ((size&gt;0) &amp;&amp; (max&gt;0))</a>
<a name="ln1116">      {</a>
<a name="ln1117">        for (int index=0;index&lt;(max+1);index++)</a>
<a name="ln1118">        {</a>
<a name="ln1119">          sqlite3_stmt *stmt3;</a>
<a name="ln1120">          DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1121">            &quot;SELECT num FROM main.history WHERE imgid=?1 AND num=?2&quot;, -1, &amp;stmt3, NULL);</a>
<a name="ln1122">          DT_DEBUG_SQLITE3_BIND_INT(stmt3, 1, imgid);</a>
<a name="ln1123">          DT_DEBUG_SQLITE3_BIND_INT(stmt3, 2, index);</a>
<a name="ln1124">          if (sqlite3_step(stmt3) == SQLITE_ROW)</a>
<a name="ln1125">          {</a>
<a name="ln1126">            sqlite3_stmt *stmt4;</a>
<a name="ln1127">            // step by step set the correct num</a>
<a name="ln1128">            DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1129">              &quot;UPDATE main.history SET num = ?3 WHERE imgid = ?1 AND num = ?2&quot;, -1, &amp;stmt4, NULL);</a>
<a name="ln1130">            DT_DEBUG_SQLITE3_BIND_INT(stmt4, 1, imgid);</a>
<a name="ln1131">            DT_DEBUG_SQLITE3_BIND_INT(stmt4, 2, index);</a>
<a name="ln1132">            DT_DEBUG_SQLITE3_BIND_INT(stmt4, 3, done);</a>
<a name="ln1133">            sqlite3_step(stmt4);</a>
<a name="ln1134">            sqlite3_finalize(stmt4);</a>
<a name="ln1135"> </a>
<a name="ln1136">            done++;</a>
<a name="ln1137">          }</a>
<a name="ln1138">          sqlite3_finalize(stmt3);</a>
<a name="ln1139">        }</a>
<a name="ln1140">      }</a>
<a name="ln1141">      // update history end</a>
<a name="ln1142">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1143">        &quot;UPDATE main.images SET history_end = ?2 WHERE id = ?1&quot;, -1, &amp;stmt2, NULL);</a>
<a name="ln1144">      DT_DEBUG_SQLITE3_BIND_INT(stmt2, 1, imgid);</a>
<a name="ln1145">      DT_DEBUG_SQLITE3_BIND_INT(stmt2, 2, done);</a>
<a name="ln1146">      sqlite3_step(stmt2);</a>
<a name="ln1147">      sqlite3_finalize(stmt2);</a>
<a name="ln1148"> </a>
<a name="ln1149">      dt_image_write_sidecar_file(imgid);</a>
<a name="ln1150">    }</a>
<a name="ln1151">    if (test == 0) // no compression as history_end is right in the middle of history</a>
<a name="ln1152">    {</a>
<a name="ln1153">      uncompressed++;</a>
<a name="ln1154">      dt_history_set_compress_problem(imgid, TRUE);</a>
<a name="ln1155">    }</a>
<a name="ln1156">    if (test == -1)</a>
<a name="ln1157">      dt_history_set_compress_problem(imgid, FALSE);</a>
<a name="ln1158">  }</a>
<a name="ln1159"> </a>
<a name="ln1160">  sqlite3_finalize(stmt);</a>
<a name="ln1161">  return uncompressed;</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164">gboolean dt_history_check_module_exists(int32_t imgid, const char *operation)</a>
<a name="ln1165">{</a>
<a name="ln1166">  gboolean result = FALSE;</a>
<a name="ln1167">  sqlite3_stmt *stmt;</a>
<a name="ln1168"> </a>
<a name="ln1169">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln1170">    dt_database_get(darktable.db),</a>
<a name="ln1171">    &quot;SELECT imgid FROM main.history WHERE imgid= ?1 AND operation = ?2&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1172">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1173">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, operation, -1, SQLITE_TRANSIENT);</a>
<a name="ln1174">  if (sqlite3_step(stmt) == SQLITE_ROW) result = TRUE;</a>
<a name="ln1175">  sqlite3_finalize(stmt);</a>
<a name="ln1176"> </a>
<a name="ln1177">  return result;</a>
<a name="ln1178">}</a>
<a name="ln1179"> </a>
<a name="ln1180">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1181">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1182">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="399"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'module'. Check lines: 399, 391.</p></div>
<div class="balloon" rel="492"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'forms_used_replace'. Check lines: 492, 487.</p></div>
<div class="balloon" rel="517"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'forms_used_replace' pointer was utilized before it was verified against nullptr. Check lines: 517, 523.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
