
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 henrik andersson.</a>
<a name="ln4">    copyright (c) 2012 aldric renaudin.</a>
<a name="ln5">    copyright (c) 2013 Ulrich Pegelow.</a>
<a name="ln6"> </a>
<a name="ln7">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln8">    it under the terms of the GNU General Public License as published by</a>
<a name="ln9">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln10">    (at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln13">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">    GNU General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">    You should have received a copy of the GNU General Public License</a>
<a name="ln18">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln19">*/</a>
<a name="ln20">#include &quot;common/debug.h&quot;</a>
<a name="ln21">#include &quot;control/conf.h&quot;</a>
<a name="ln22">#include &quot;control/control.h&quot;</a>
<a name="ln23">#include &quot;develop/blend.h&quot;</a>
<a name="ln24">#include &quot;develop/imageop.h&quot;</a>
<a name="ln25">#include &quot;develop/masks.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">/** get squared distance of indexed point to line segment, taking weighted payload data into account */</a>
<a name="ln28">static float _brush_point_line_distance2(int index, int pointscount, const float *points, const float *payload)</a>
<a name="ln29">{</a>
<a name="ln30">  const float x = points[2 * index];</a>
<a name="ln31">  const float y = points[2 * index + 1];</a>
<a name="ln32">  const float b = payload[4 * index];</a>
<a name="ln33">  const float h = payload[4 * index + 1];</a>
<a name="ln34">  const float d = payload[4 * index + 2];</a>
<a name="ln35">  const float xstart = points[0];</a>
<a name="ln36">  const float ystart = points[1];</a>
<a name="ln37">  const float bstart = payload[0];</a>
<a name="ln38">  const float hstart = payload[1];</a>
<a name="ln39">  const float dstart = payload[2];</a>
<a name="ln40">  const float xend = points[2 * (pointscount - 1)];</a>
<a name="ln41">  const float yend = points[2 * (pointscount - 1) + 1];</a>
<a name="ln42">  const float bend = payload[4 * (pointscount - 1)];</a>
<a name="ln43">  const float hend = payload[4 * (pointscount - 1) + 1];</a>
<a name="ln44">  const float dend = payload[4 * (pointscount - 1) + 2];</a>
<a name="ln45">  const float bweight = 1.0f;</a>
<a name="ln46">  const float hweight = 0.01f;</a>
<a name="ln47">  const float dweight = 0.01f;</a>
<a name="ln48"> </a>
<a name="ln49">  const float r1 = x - xstart;</a>
<a name="ln50">  const float r2 = y - ystart;</a>
<a name="ln51">  const float r3 = xend - xstart;</a>
<a name="ln52">  const float r4 = yend - ystart;</a>
<a name="ln53">  const float r5 = bend - bstart;</a>
<a name="ln54">  const float r6 = hend - hstart;</a>
<a name="ln55">  const float r7 = dend - dstart;</a>
<a name="ln56"> </a>
<a name="ln57">  const float r = r1 * r3 + r2 * r4;</a>
<a name="ln58">  const float l = r3 * r3 + r4 * r4;</a>
<a name="ln59">  const float p = r / l;</a>
<a name="ln60"> </a>
<a name="ln61">  float dx, dy, db, dh, dd;</a>
<a name="ln62"> </a>
<a name="ln63">  if(l == 0.0f)</a>
<a name="ln64">  {</a>
<a name="ln65">    dx = x - xstart;</a>
<a name="ln66">    dy = y - ystart;</a>
<a name="ln67">    db = b - bstart;</a>
<a name="ln68">    dh = h - hstart;</a>
<a name="ln69">    dd = d - dstart;</a>
<a name="ln70">  }</a>
<a name="ln71">  else if(p &lt; 0.0f)</a>
<a name="ln72">  {</a>
<a name="ln73">    dx = x - xstart;</a>
<a name="ln74">    dy = y - ystart;</a>
<a name="ln75">    db = b - bstart;</a>
<a name="ln76">    dh = h - hstart;</a>
<a name="ln77">    dd = d - dstart;</a>
<a name="ln78">  }</a>
<a name="ln79">  else if(p &gt; 1.0f)</a>
<a name="ln80">  {</a>
<a name="ln81">    dx = x - xend;</a>
<a name="ln82">    dy = y - yend;</a>
<a name="ln83">    db = b - bend;</a>
<a name="ln84">    dh = h - hend;</a>
<a name="ln85">    dd = d - dend;</a>
<a name="ln86">  }</a>
<a name="ln87">  else</a>
<a name="ln88">  {</a>
<a name="ln89">    dx = x - (xstart + p * r3);</a>
<a name="ln90">    dy = y - (ystart + p * r4);</a>
<a name="ln91">    db = b - (bstart + p * r5);</a>
<a name="ln92">    dh = h - (hstart + p * r6);</a>
<a name="ln93">    dd = d - (dstart + p * r7);</a>
<a name="ln94">  }</a>
<a name="ln95"> </a>
<a name="ln96">  return dx * dx + dy * dy + bweight * db * db + hweight * dh * dh + dweight * dd * dd;</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">/** remove unneeded points (Ramer-Douglas-Peucker algorithm) and return resulting path as linked list */</a>
<a name="ln100">static GList *_brush_ramer_douglas_peucker(const float *points, int points_count, const float *payload,</a>
<a name="ln101">                                           float epsilon2)</a>
<a name="ln102">{</a>
<a name="ln103">  GList *ResultList = NULL;</a>
<a name="ln104"> </a>
<a name="ln105">  float dmax2 = 0.0f;</a>
<a name="ln106">  int index = 0;</a>
<a name="ln107"> </a>
<a name="ln108">  for(int i = 1; i &lt; points_count - 1; i++)</a>
<a name="ln109">  {</a>
<a name="ln110">    float d2 = _brush_point_line_distance2(i, points_count, points, payload);</a>
<a name="ln111">    if(d2 &gt; dmax2)</a>
<a name="ln112">    {</a>
<a name="ln113">      index = i;</a>
<a name="ln114">      dmax2 = d2;</a>
<a name="ln115">    }</a>
<a name="ln116">  }</a>
<a name="ln117"> </a>
<a name="ln118">  if(dmax2 &gt;= epsilon2)</a>
<a name="ln119">  {</a>
<a name="ln120">    GList *ResultList1 = _brush_ramer_douglas_peucker(points, index + 1, payload, epsilon2);</a>
<a name="ln121">    GList *ResultList2 = _brush_ramer_douglas_peucker(points + index * 2, points_count - index,</a>
<a name="ln122">                                                      payload + index * 4, epsilon2);</a>
<a name="ln123"> </a>
<a name="ln124">    // remove last element from ResultList1</a>
<a name="ln125">    GList *end1 = g_list_last(ResultList1);</a>
<a name="ln126">    free(end1-&gt;data);</a>
<a name="ln127">    ResultList1 = g_list_delete_link(ResultList1, end1);</a>
<a name="ln128"> </a>
<a name="ln129">    ResultList = g_list_concat(ResultList1, ResultList2);</a>
<a name="ln130">  }</a>
<a name="ln131">  else</a>
<a name="ln132">  {</a>
<a name="ln133">    dt_masks_point_brush_t *point1 = malloc(sizeof(dt_masks_point_brush_t));</a>
<a name="ln134">    point1-&gt;corner[0] = points[0];</a>
<a name="ln135">    point1-&gt;corner[1] = points[1];</a>
<a name="ln136">    point1-&gt;ctrl1[0] = point1-&gt;ctrl1[1] = point1-&gt;ctrl2[0] = point1-&gt;ctrl2[1] = -1.0f;</a>
<a name="ln137">    point1-&gt;border[0] = point1-&gt;border[1] = payload[0];</a>
<a name="ln138">    point1-&gt;hardness = payload[1];</a>
<a name="ln139">    point1-&gt;density = payload[2];</a>
<a name="ln140">    point1-&gt;state = DT_MASKS_POINT_STATE_NORMAL;</a>
<a name="ln141">    ResultList = g_list_append(ResultList, (gpointer)point1);</a>
<a name="ln142"> </a>
<a name="ln143">    dt_masks_point_brush_t *pointn = malloc(sizeof(dt_masks_point_brush_t));</a>
<a name="ln144">    pointn-&gt;corner[0] = points[(points_count - 1) * 2];</a>
<a name="ln145">    pointn-&gt;corner[1] = points[(points_count - 1) * 2 + 1];</a>
<a name="ln146">    pointn-&gt;ctrl1[0] = pointn-&gt;ctrl1[1] = pointn-&gt;ctrl2[0] = pointn-&gt;ctrl2[1] = -1.0f;</a>
<a name="ln147">    pointn-&gt;border[0] = pointn-&gt;border[1] = payload[(points_count - 1) * 4];</a>
<a name="ln148">    pointn-&gt;hardness = payload[(points_count - 1) * 4 + 1];</a>
<a name="ln149">    pointn-&gt;density = payload[(points_count - 1) * 4 + 2];</a>
<a name="ln150">    pointn-&gt;state = DT_MASKS_POINT_STATE_NORMAL;</a>
<a name="ln151">    ResultList = g_list_append(ResultList, (gpointer)pointn);</a>
<a name="ln152">  }</a>
<a name="ln153"> </a>
<a name="ln154">  return ResultList;</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">/** get the point of the brush at pos t [0,1]  */</a>
<a name="ln158">static void _brush_get_XY(float p0x, float p0y, float p1x, float p1y, float p2x, float p2y, float p3x,</a>
<a name="ln159">                          float p3y, float t, float *x, float *y)</a>
<a name="ln160">{</a>
<a name="ln161">  float a = (1 - t) * (1 - t) * (1 - t);</a>
<a name="ln162">  float b = 3 * t * (1 - t) * (1 - t);</a>
<a name="ln163">  float c = 3 * t * t * (1 - t);</a>
<a name="ln164">  float d = t * t * t;</a>
<a name="ln165">  *x = p0x * a + p1x * b + p2x * c + p3x * d;</a>
<a name="ln166">  *y = p0y * a + p1y * b + p2y * c + p3y * d;</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">/** get the point of the brush at pos t [0,1]  AND the corresponding border point */</a>
<a name="ln170">static void _brush_border_get_XY(float p0x, float p0y, float p1x, float p1y, float p2x, float p2y, float p3x,</a>
<a name="ln171">                                 float p3y, float t, float rad, float *xc, float *yc, float *xb, float *yb)</a>
<a name="ln172">{</a>
<a name="ln173">  // we get the point</a>
<a name="ln174">  _brush_get_XY(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t, xc, yc);</a>
<a name="ln175"> </a>
<a name="ln176">  // now we get derivative points</a>
<a name="ln177">  float a = 3 * (1 - t) * (1 - t);</a>
<a name="ln178">  float b = 3 * ((1 - t) * (1 - t) - 2 * t * (1 - t));</a>
<a name="ln179">  float c = 3 * (2 * t * (1 - t) - t * t);</a>
<a name="ln180">  float d = 3 * t * t;</a>
<a name="ln181"> </a>
<a name="ln182">  float dx = -p0x * a + p1x * b + p2x * c + p3x * d;</a>
<a name="ln183">  float dy = -p0y * a + p1y * b + p2y * c + p3y * d;</a>
<a name="ln184"> </a>
<a name="ln185">  // so we can have the resulting point</a>
<a name="ln186">  if(dx == 0 &amp;&amp; dy == 0)</a>
<a name="ln187">  {</a>
<a name="ln188">    *xb = NAN;</a>
<a name="ln189">    *yb = NAN;</a>
<a name="ln190">    return;</a>
<a name="ln191">  }</a>
<a name="ln192">  float l = 1.0 / sqrtf(dx * dx + dy * dy);</a>
<a name="ln193">  *xb = (*xc) + rad * dy * l;</a>
<a name="ln194">  *yb = (*yc) - rad * dx * l;</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">/** get feather extremity from the control point n°2 */</a>
<a name="ln198">/** the values should be in orthonormal space */</a>
<a name="ln199">static void _brush_ctrl2_to_feather(int ptx, int pty, int ctrlx, int ctrly, int *fx, int *fy,</a>
<a name="ln200">                                    gboolean clockwise)</a>
<a name="ln201">{</a>
<a name="ln202">  if(clockwise)</a>
<a name="ln203">  {</a>
<a name="ln204">    *fx = ptx + ctrly - pty;</a>
<a name="ln205">    *fy = pty + ptx - ctrlx;</a>
<a name="ln206">  }</a>
<a name="ln207">  else</a>
<a name="ln208">  {</a>
<a name="ln209">    *fx = ptx - ctrly + pty;</a>
<a name="ln210">    *fy = pty - ptx + ctrlx;</a>
<a name="ln211">  }</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">/** get bezier control points from feather extremity */</a>
<a name="ln215">/** the values should be in orthonormal space */</a>
<a name="ln216">static void _brush_feather_to_ctrl(int ptx, int pty, int fx, int fy, int *ctrl1x, int *ctrl1y, int *ctrl2x,</a>
<a name="ln217">                                   int *ctrl2y, gboolean clockwise)</a>
<a name="ln218">{</a>
<a name="ln219">  if(clockwise)</a>
<a name="ln220">  {</a>
<a name="ln221">    *ctrl2x = ptx + pty - fy;</a>
<a name="ln222">    *ctrl2y = pty + fx - ptx;</a>
<a name="ln223">    *ctrl1x = ptx - pty + fy;</a>
<a name="ln224">    *ctrl1y = pty - fx + ptx;</a>
<a name="ln225">  }</a>
<a name="ln226">  else</a>
<a name="ln227">  {</a>
<a name="ln228">    *ctrl1x = ptx + pty - fy;</a>
<a name="ln229">    *ctrl1y = pty + fx - ptx;</a>
<a name="ln230">    *ctrl2x = ptx - pty + fy;</a>
<a name="ln231">    *ctrl2y = pty - fx + ptx;</a>
<a name="ln232">  }</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">/** Get the control points of a segment to match exactly a catmull-rom spline */</a>
<a name="ln236">static void _brush_catmull_to_bezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4,</a>
<a name="ln237">                                     float y4, float *bx1, float *by1, float *bx2, float *by2)</a>
<a name="ln238">{</a>
<a name="ln239">  *bx1 = (-x1 + 6 * x2 + x3) / 6;</a>
<a name="ln240">  *by1 = (-y1 + 6 * y2 + y3) / 6;</a>
<a name="ln241">  *bx2 = (x2 + 6 * x3 - x4) / 6;</a>
<a name="ln242">  *by2 = (y2 + 6 * y3 - y4) / 6;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">/** initialise all control points to eventually match a catmull-rom like spline */</a>
<a name="ln246">static void _brush_init_ctrl_points(dt_masks_form_t *form)</a>
<a name="ln247">{</a>
<a name="ln248">  // if we have less that 2 points, what to do ??</a>
<a name="ln249">  if(g_list_length(form-&gt;points) &lt; 2) return;</a>
<a name="ln250"> </a>
<a name="ln251">  // we need extra points to deal with curve ends</a>
<a name="ln252">  dt_masks_point_brush_t start_point[2], end_point[2];</a>
<a name="ln253"> </a>
<a name="ln254">  guint nb = g_list_length(form-&gt;points);</a>
<a name="ln255">  for(int k = 0; k &lt; nb; k++)</a>
<a name="ln256">  {</a>
<a name="ln257">    dt_masks_point_brush_t *point3 = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k);</a>
<a name="ln258">    // if the point as not be set manually, we redfine it</a>
<a name="ln259">    if(point3-&gt;state &amp; DT_MASKS_POINT_STATE_NORMAL)</a>
<a name="ln260">    {</a>
<a name="ln261">      // we want to get point-2, point-1, point+1, point+2</a>
<a name="ln262">      dt_masks_point_brush_t *point1</a>
<a name="ln263">          = k - 2 &gt;= 0 ? (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k - 2) : NULL;</a>
<a name="ln264">      dt_masks_point_brush_t *point2</a>
<a name="ln265">          = k - 1 &gt;= 0 ? (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k - 1) : NULL;</a>
<a name="ln266">      dt_masks_point_brush_t *point4</a>
<a name="ln267">          = k + 1 &lt; nb ? (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k + 1) : NULL;</a>
<a name="ln268">      dt_masks_point_brush_t *point5</a>
<a name="ln269">          = k + 2 &lt; nb ? (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k + 2) : NULL;</a>
<a name="ln270"> </a>
<a name="ln271">      // deal with end points: make both extending points mirror their neighborhood</a>
<a name="ln272">      if(point1 == NULL &amp;&amp; point2 == NULL)</a>
<a name="ln273">      {</a>
<a name="ln274">        start_point[0].corner[0] = start_point[1].corner[0] = 2 * point3-&gt;corner[0] - point4-&gt;corner[0];</a>
<a name="ln275">        start_point[0].corner[1] = start_point[1].corner[1] = 2 * point3-&gt;corner[1] - point4-&gt;corner[1];</a>
<a name="ln276">        point1 = &amp;(start_point[0]);</a>
<a name="ln277">        point2 = &amp;(start_point[1]);</a>
<a name="ln278">      }</a>
<a name="ln279">      else if(point1 == NULL)</a>
<a name="ln280">      {</a>
<a name="ln281">        start_point[0].corner[0] = 2 * point2-&gt;corner[0] - point3-&gt;corner[0];</a>
<a name="ln282">        start_point[0].corner[1] = 2 * point2-&gt;corner[1] - point3-&gt;corner[1];</a>
<a name="ln283">        point1 = &amp;(start_point[0]);</a>
<a name="ln284">      }</a>
<a name="ln285"> </a>
<a name="ln286">      if(point4 == NULL &amp;&amp; point5 == NULL)</a>
<a name="ln287">      {</a>
<a name="ln288">        end_point[0].corner[0] = end_point[1].corner[0] = 2 * point3-&gt;corner[0] - point2-&gt;corner[0];</a>
<a name="ln289">        end_point[0].corner[1] = end_point[1].corner[1] = 2 * point3-&gt;corner[1] - point2-&gt;corner[1];</a>
<a name="ln290">        point4 = &amp;(end_point[0]);</a>
<a name="ln291">        point5 = &amp;(end_point[1]);</a>
<a name="ln292">      }</a>
<a name="ln293">      else if(point5 == NULL)</a>
<a name="ln294">      {</a>
<a name="ln295">        end_point[0].corner[0] = 2 * point4-&gt;corner[0] - point3-&gt;corner[0];</a>
<a name="ln296">        end_point[0].corner[1] = 2 * point4-&gt;corner[1] - point3-&gt;corner[1];</a>
<a name="ln297">        point5 = &amp;(end_point[0]);</a>
<a name="ln298">      }</a>
<a name="ln299"> </a>
<a name="ln300"> </a>
<a name="ln301">      float bx1, by1, bx2, by2;</a>
<a name="ln302">      _brush_catmull_to_bezier(point1-&gt;corner[0], point1-&gt;corner[1], point2-&gt;corner[0], point2-&gt;corner[1],</a>
<a name="ln303">                               point3-&gt;corner[0], point3-&gt;corner[1], point4-&gt;corner[0], point4-&gt;corner[1],</a>
<a name="ln304">                               &amp;bx1, &amp;by1, &amp;bx2, &amp;by2);</a>
<a name="ln305">      if(point2-&gt;ctrl2[0] == -1.0) point2-&gt;ctrl2[0] = bx1;</a>
<a name="ln306">      if(point2-&gt;ctrl2[1] == -1.0) point2-&gt;ctrl2[1] = by1;</a>
<a name="ln307">      point3-&gt;ctrl1[0] = bx2;</a>
<a name="ln308">      point3-&gt;ctrl1[1] = by2;</a>
<a name="ln309">      _brush_catmull_to_bezier(point2-&gt;corner[0], point2-&gt;corner[1], point3-&gt;corner[0], point3-&gt;corner[1],</a>
<a name="ln310">                               point4-&gt;corner[0], point4-&gt;corner[1], point5-&gt;corner[0], point5-&gt;corner[1],</a>
<a name="ln311">                               &amp;bx1, &amp;by1, &amp;bx2, &amp;by2);</a>
<a name="ln312">      if(point4-&gt;ctrl1[0] == -1.0) point4-&gt;ctrl1[0] = bx2;</a>
<a name="ln313">      if(point4-&gt;ctrl1[1] == -1.0) point4-&gt;ctrl1[1] = by2;</a>
<a name="ln314">      point3-&gt;ctrl2[0] = bx1;</a>
<a name="ln315">      point3-&gt;ctrl2[1] = by1;</a>
<a name="ln316">    }</a>
<a name="ln317">  }</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320"> </a>
<a name="ln321">/** fill the gap between 2 points with an arc of circle */</a>
<a name="ln322">/** this function is here because we can have gap in border, esp. if the corner is very sharp */</a>
<a name="ln323">static void _brush_points_recurs_border_gaps(float *cmax, float *bmin, float *bmin2, float *bmax,</a>
<a name="ln324">                                             dt_masks_dynbuf_t *dpoints, dt_masks_dynbuf_t *dborder,</a>
<a name="ln325">                                             gboolean clockwise)</a>
<a name="ln326">{</a>
<a name="ln327">  // we want to find the start and end angles</a>
<a name="ln328">  float a1 = atan2(bmin[1] - cmax[1], bmin[0] - cmax[0]);</a>
<a name="ln329">  float a2 = atan2(bmax[1] - cmax[1], bmax[0] - cmax[0]);</a>
<a name="ln330"> </a>
<a name="ln331">  if(a1 == a2) return;</a>
<a name="ln332"> </a>
<a name="ln333">  // we have to be sure that we turn in the correct direction</a>
<a name="ln334">  if(a2 &lt; a1 &amp;&amp; clockwise)</a>
<a name="ln335">  {</a>
<a name="ln336">    a2 += 2.0f * M_PI;</a>
<a name="ln337">  }</a>
<a name="ln338">  if(a2 &gt; a1 &amp;&amp; !clockwise)</a>
<a name="ln339">  {</a>
<a name="ln340">    a1 += 2.0f * M_PI;</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  // we determine start and end radius too</a>
<a name="ln344">  float r1 = sqrtf((bmin[1] - cmax[1]) * (bmin[1] - cmax[1]) + (bmin[0] - cmax[0]) * (bmin[0] - cmax[0]));</a>
<a name="ln345">  float r2 = sqrtf((bmax[1] - cmax[1]) * (bmax[1] - cmax[1]) + (bmax[0] - cmax[0]) * (bmax[0] - cmax[0]));</a>
<a name="ln346"> </a>
<a name="ln347">  // and the max length of the circle arc</a>
<a name="ln348">  int l;</a>
<a name="ln349">  if(a2 &gt; a1)</a>
<a name="ln350">    l = (a2 - a1) * fmaxf(r1, r2);</a>
<a name="ln351">  else</a>
<a name="ln352">    l = (a1 - a2) * fmaxf(r1, r2);</a>
<a name="ln353">  if(l &lt; 2) return;</a>
<a name="ln354"> </a>
<a name="ln355">  // and now we add the points</a>
<a name="ln356">  float incra = (a2 - a1) / l;</a>
<a name="ln357">  float incrr = (r2 - r1) / l;</a>
<a name="ln358">  float rr = r1 + incrr;</a>
<a name="ln359">  float aa = a1 + incra;</a>
<a name="ln360">  for(int i = 1; i &lt; l; i++)</a>
<a name="ln361">  {</a>
<a name="ln362">    dt_masks_dynbuf_add(dpoints, cmax[0]);</a>
<a name="ln363">    dt_masks_dynbuf_add(dpoints, cmax[1]);</a>
<a name="ln364">    dt_masks_dynbuf_add(dborder, cmax[0] + rr * cosf(aa));</a>
<a name="ln365">    dt_masks_dynbuf_add(dborder, cmax[1] + rr * sinf(aa));</a>
<a name="ln366">    rr += incrr;</a>
<a name="ln367">    aa += incra;</a>
<a name="ln368">  }</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">/** fill small gap between 2 points with an arc of circle */</a>
<a name="ln372">/** in contrast to the previous function it will always run the shortest path (max. PI) and does not consider</a>
<a name="ln373"> * clock or anti-clockwise action */</a>
<a name="ln374">static void _brush_points_recurs_border_small_gaps(float *cmax, float *bmin, float *bmin2, float *bmax,</a>
<a name="ln375">                                                   dt_masks_dynbuf_t *dpoints, dt_masks_dynbuf_t *dborder)</a>
<a name="ln376">{</a>
<a name="ln377">  // we want to find the start and end angles</a>
<a name="ln378">  float a1 = fmodf(atan2(bmin[1] - cmax[1], bmin[0] - cmax[0]) + 2.0f * M_PI, 2.0f * M_PI);</a>
<a name="ln379">  float a2 = fmodf(atan2(bmax[1] - cmax[1], bmax[0] - cmax[0]) + 2.0f * M_PI, 2.0f * M_PI);</a>
<a name="ln380"> </a>
<a name="ln381">  if(a1 == a2) return;</a>
<a name="ln382"> </a>
<a name="ln383">  // we determine start and end radius too</a>
<a name="ln384">  float r1 = sqrtf((bmin[1] - cmax[1]) * (bmin[1] - cmax[1]) + (bmin[0] - cmax[0]) * (bmin[0] - cmax[0]));</a>
<a name="ln385">  float r2 = sqrtf((bmax[1] - cmax[1]) * (bmax[1] - cmax[1]) + (bmax[0] - cmax[0]) * (bmax[0] - cmax[0]));</a>
<a name="ln386"> </a>
<a name="ln387">  // we close the gap in the shortest direction</a>
<a name="ln388">  float delta = a2 - a1;</a>
<a name="ln389">  if(fabsf(delta) &gt; M_PI) delta = delta - copysignf(2.0f * M_PI, delta);</a>
<a name="ln390"> </a>
<a name="ln391">  // get the max length of the circle arc</a>
<a name="ln392">  int l = fabsf(delta) * fmaxf(r1, r2);</a>
<a name="ln393">  if(l &lt; 2) return;</a>
<a name="ln394"> </a>
<a name="ln395">  // and now we add the points</a>
<a name="ln396">  float incra = delta / l;</a>
<a name="ln397">  float incrr = (r2 - r1) / l;</a>
<a name="ln398">  float rr = r1 + incrr;</a>
<a name="ln399">  float aa = a1 + incra;</a>
<a name="ln400">  for(int i = 1; i &lt; l; i++)</a>
<a name="ln401">  {</a>
<a name="ln402">    dt_masks_dynbuf_add(dpoints, cmax[0]);</a>
<a name="ln403">    dt_masks_dynbuf_add(dpoints, cmax[1]);</a>
<a name="ln404">    dt_masks_dynbuf_add(dborder, cmax[0] + rr * cosf(aa));</a>
<a name="ln405">    dt_masks_dynbuf_add(dborder, cmax[1] + rr * sinf(aa));</a>
<a name="ln406">    rr += incrr;</a>
<a name="ln407">    aa += incra;</a>
<a name="ln408">  }</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411"> </a>
<a name="ln412">/** draw a circle with given radius. can be used to terminate a stroke and to draw junctions where attributes</a>
<a name="ln413"> * (opacity) change */</a>
<a name="ln414">static void _brush_points_stamp(float *cmax, float *bmin, dt_masks_dynbuf_t *dpoints,  dt_masks_dynbuf_t *dborder,</a>
<a name="ln415">                                gboolean clockwise)</a>
<a name="ln416">{</a>
<a name="ln417">  // we want to find the start angle</a>
<a name="ln418">  float a1 = atan2(bmin[1] - cmax[1], bmin[0] - cmax[0]);</a>
<a name="ln419"> </a>
<a name="ln420">  // we determine the radius too</a>
<a name="ln421">  float rad = sqrtf((bmin[1] - cmax[1]) * (bmin[1] - cmax[1]) + (bmin[0] - cmax[0]) * (bmin[0] - cmax[0]));</a>
<a name="ln422"> </a>
<a name="ln423">  // determine the max length of the circle arc</a>
<a name="ln424">  int l = 2.0f * M_PI * rad;</a>
<a name="ln425">  if(l &lt; 2) return;</a>
<a name="ln426"> </a>
<a name="ln427">  // and now we add the points</a>
<a name="ln428">  float incra = 2.0f * M_PI / l;</a>
<a name="ln429">  float aa = a1 + incra;</a>
<a name="ln430">  for(int i = 0; i &lt; l; i++)</a>
<a name="ln431">  {</a>
<a name="ln432">    dt_masks_dynbuf_add(dpoints, cmax[0]);</a>
<a name="ln433">    dt_masks_dynbuf_add(dpoints, cmax[1]);</a>
<a name="ln434">    dt_masks_dynbuf_add(dborder, cmax[0] + rad * cosf(aa));</a>
<a name="ln435">    dt_masks_dynbuf_add(dborder, cmax[1] + rad * sinf(aa));</a>
<a name="ln436">    aa += incra;</a>
<a name="ln437">  }</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">/** recursive function to get all points of the brush AND all point of the border */</a>
<a name="ln441">/** the function takes care to avoid big gaps between points */</a>
<a name="ln442">static void _brush_points_recurs(float *p1, float *p2, double tmin, double tmax, float *points_min,</a>
<a name="ln443">                                 float *points_max, float *border_min, float *border_max, float *rpoints,</a>
<a name="ln444">                                 float *rborder, float *rpayload, dt_masks_dynbuf_t *dpoints, dt_masks_dynbuf_t *dborder,</a>
<a name="ln445">                                 dt_masks_dynbuf_t *dpayload)</a>
<a name="ln446">{</a>
<a name="ln447">  const gboolean withborder = (dborder != NULL);</a>
<a name="ln448">  const gboolean withpayload = (dpayload != NULL);</a>
<a name="ln449"> </a>
<a name="ln450">  // we calculate points if needed</a>
<a name="ln451">  if(isnan(points_min[0]))</a>
<a name="ln452">  {</a>
<a name="ln453">    _brush_border_get_XY(p1[0], p1[1], p1[2], p1[3], p2[2], p2[3], p2[0], p2[1], tmin,</a>
<a name="ln454">                         p1[4] + (p2[4] - p1[4]) * tmin * tmin * (3.0 - 2.0 * tmin), points_min,</a>
<a name="ln455">                         points_min + 1, border_min, border_min + 1);</a>
<a name="ln456">  }</a>
<a name="ln457">  if(isnan(points_max[0]))</a>
<a name="ln458">  {</a>
<a name="ln459">    _brush_border_get_XY(p1[0], p1[1], p1[2], p1[3], p2[2], p2[3], p2[0], p2[1], tmax,</a>
<a name="ln460">                         p1[4] + (p2[4] - p1[4]) * tmax * tmax * (3.0 - 2.0 * tmax), points_max,</a>
<a name="ln461">                         points_max + 1, border_max, border_max + 1);</a>
<a name="ln462">  }</a>
<a name="ln463">  // are the points near ?</a>
<a name="ln464">  if((tmax - tmin &lt; 0.0001f)</a>
<a name="ln465">     || ((int)points_min[0] - (int)points_max[0] &lt; 1 &amp;&amp; (int)points_min[0] - (int)points_max[0] &gt; -1</a>
<a name="ln466">         &amp;&amp; (int)points_min[1] - (int)points_max[1] &lt; 1 &amp;&amp; (int)points_min[1] - (int)points_max[1] &gt; -1</a>
<a name="ln467">         &amp;&amp; (!withborder</a>
<a name="ln468">             || ((int)border_min[0] - (int)border_max[0] &lt; 1 &amp;&amp; (int)border_min[0] - (int)border_max[0] &gt; -1</a>
<a name="ln469">                 &amp;&amp; (int)border_min[1] - (int)border_max[1] &lt; 1</a>
<a name="ln470">                 &amp;&amp; (int)border_min[1] - (int)border_max[1] &gt; -1))))</a>
<a name="ln471">  {</a>
<a name="ln472">    rpoints[0] = points_max[0];</a>
<a name="ln473">    rpoints[1] = points_max[1];</a>
<a name="ln474">    dt_masks_dynbuf_add(dpoints, rpoints[0]);</a>
<a name="ln475">    dt_masks_dynbuf_add(dpoints, rpoints[1]);</a>
<a name="ln476"> </a>
<a name="ln477">    if(withborder)</a>
<a name="ln478">    {</a>
<a name="ln479">      if(isnan(border_max[0]))</a>
<a name="ln480">      {</a>
<a name="ln481">        border_max[0] = border_min[0];</a>
<a name="ln482">        border_max[1] = border_min[1];</a>
<a name="ln483">      }</a>
<a name="ln484">      else if(isnan(border_min[0]))</a>
<a name="ln485">      {</a>
<a name="ln486">        border_min[0] = border_max[0];</a>
<a name="ln487">        border_min[1] = border_max[1];</a>
<a name="ln488">      }</a>
<a name="ln489"> </a>
<a name="ln490">      // we check gaps in the border (sharp edges)</a>
<a name="ln491">      if(abs((int)border_max[0] - (int)border_min[0]) &gt; 2 || abs((int)border_max[1] - (int)border_min[1]) &gt; 2)</a>
<a name="ln492">      {</a>
<a name="ln493">        _brush_points_recurs_border_small_gaps(points_max, border_min, NULL, border_max, dpoints, dborder);</a>
<a name="ln494">      }</a>
<a name="ln495"> </a>
<a name="ln496">      rborder[0] = border_max[0];</a>
<a name="ln497">      rborder[1] = border_max[1];</a>
<a name="ln498">      dt_masks_dynbuf_add(dborder, rborder[0]);</a>
<a name="ln499">      dt_masks_dynbuf_add(dborder, rborder[1]);</a>
<a name="ln500">    }</a>
<a name="ln501"> </a>
<a name="ln502">    if(withpayload)</a>
<a name="ln503">    {</a>
<a name="ln504">      while(dt_masks_dynbuf_position(dpayload) &lt; dt_masks_dynbuf_position(dpoints))</a>
<a name="ln505">      {</a>
<a name="ln506">        rpayload[0] = p1[5] + tmax * (p2[5] - p1[5]);</a>
<a name="ln507">        rpayload[1] = p1[6] + tmax * (p2[6] - p1[6]);</a>
<a name="ln508">        dt_masks_dynbuf_add(dpayload, rpayload[0]);</a>
<a name="ln509">        dt_masks_dynbuf_add(dpayload, rpayload[1]);</a>
<a name="ln510">      }</a>
<a name="ln511">    }</a>
<a name="ln512"> </a>
<a name="ln513">    return;</a>
<a name="ln514">  }</a>
<a name="ln515"> </a>
<a name="ln516">  // we split in two part</a>
<a name="ln517">  double tx = (tmin + tmax) / 2.0;</a>
<a name="ln518">  float c[2] = { NAN, NAN }, b[2] = { NAN, NAN };</a>
<a name="ln519">  float rc[2], rb[2], rp[2];</a>
<a name="ln520">  _brush_points_recurs(p1, p2, tmin, tx, points_min, c, border_min, b, rc, rb, rp, dpoints, dborder, dpayload);</a>
<a name="ln521">  _brush_points_recurs(p1, p2, tx, tmax, rc, points_max, rb, border_max, rpoints, rborder, rpayload, dpoints,</a>
<a name="ln522">                       dborder, dpayload);</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525"> </a>
<a name="ln526">/** converts n into a cyclical sequence counting upwards from 0 to nb-1 and back down again, counting</a>
<a name="ln527"> * endpoints twice */</a>
<a name="ln528">static inline int _brush_cyclic_cursor(int n, int nb)</a>
<a name="ln529">{</a>
<a name="ln530">  const int o = n % (2 * nb);</a>
<a name="ln531">  const int p = o % nb;</a>
<a name="ln532"> </a>
<a name="ln533">  return (o &lt;= p) ? o : o - 2 * p - 1;</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536"> </a>
<a name="ln537">/** get all points of the brush and the border */</a>
<a name="ln538">/** this takes care of gaps and iop distortions */</a>
<a name="ln539">static int _brush_get_points_border(dt_develop_t *dev, dt_masks_form_t *form, const double iop_order, const int transf_direction, </a>
<a name="ln540">                                    dt_dev_pixelpipe_t *pipe, float **points, int *points_count,</a>
<a name="ln541">                                    float **border, int *border_count, float **payload, int *payload_count,</a>
<a name="ln542">                                    int source)</a>
<a name="ln543">{</a>
<a name="ln544">  double start2 = dt_get_wtime();</a>
<a name="ln545"> </a>
<a name="ln546">  float wd = pipe-&gt;iwidth, ht = pipe-&gt;iheight;</a>
<a name="ln547"> </a>
<a name="ln548">  *points = NULL;</a>
<a name="ln549">  *points_count = 0;</a>
<a name="ln550">  if(border) *border = NULL;</a>
<a name="ln551">  if(border) *border_count = 0;</a>
<a name="ln552">  if(payload) *payload = NULL;</a>
<a name="ln553">  if(payload) *payload_count = 0;</a>
<a name="ln554"> </a>
<a name="ln555">  dt_masks_dynbuf_t *dpoints = NULL, *dborder = NULL, *dpayload = NULL;</a>
<a name="ln556"> </a>
<a name="ln557">  dpoints = dt_masks_dynbuf_init(1000000, &quot;brush dpoints&quot;);</a>
<a name="ln558">  if(dpoints == NULL) return 0;</a>
<a name="ln559"> </a>
<a name="ln560">  if(border)</a>
<a name="ln561">  {</a>
<a name="ln562">    dborder = dt_masks_dynbuf_init(1000000, &quot;brush dborder&quot;);</a>
<a name="ln563">    if(dborder == NULL)</a>
<a name="ln564">    {</a>
<a name="ln565">      dt_masks_dynbuf_free(dpoints);</a>
<a name="ln566">      return 0;</a>
<a name="ln567">    }</a>
<a name="ln568">  }</a>
<a name="ln569"> </a>
<a name="ln570">  if(payload)</a>
<a name="ln571">  {</a>
<a name="ln572">    dpayload = dt_masks_dynbuf_init(1000000, &quot;brush dpayload&quot;);</a>
<a name="ln573">    if(dpayload == NULL)</a>
<a name="ln574">    {</a>
<a name="ln575">      dt_masks_dynbuf_free(dpoints);</a>
<a name="ln576">      dt_masks_dynbuf_free(dborder);</a>
<a name="ln577">      return 0;</a>
<a name="ln578">    }</a>
<a name="ln579">  }</a>
<a name="ln580"> </a>
<a name="ln581">  // we store all points</a>
<a name="ln582">  float dx = 0.0f, dy = 0.0f;</a>
<a name="ln583"> </a>
<a name="ln584">  guint nb = g_list_length(form-&gt;points);</a>
<a name="ln585"> </a>
<a name="ln586">  if(source &amp;&amp; nb &gt; 0)</a>
<a name="ln587">  {</a>
<a name="ln588">    dt_masks_point_brush_t *pt = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, 0);</a>
<a name="ln589">    dx = (pt-&gt;corner[0] - form-&gt;source[0]) * wd;</a>
<a name="ln590">    dy = (pt-&gt;corner[1] - form-&gt;source[1]) * ht;</a>
<a name="ln591">  }</a>
<a name="ln592"> </a>
<a name="ln593">  for(int k = 0; k &lt; nb; k++)</a>
<a name="ln594">  {</a>
<a name="ln595">    dt_masks_point_brush_t *pt = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k);</a>
<a name="ln596">    dt_masks_dynbuf_add(dpoints, pt-&gt;ctrl1[0] * wd - dx);</a>
<a name="ln597">    dt_masks_dynbuf_add(dpoints, pt-&gt;ctrl1[1] * ht - dy);</a>
<a name="ln598">    dt_masks_dynbuf_add(dpoints, pt-&gt;corner[0] * wd - dx);</a>
<a name="ln599">    dt_masks_dynbuf_add(dpoints, pt-&gt;corner[1] * ht - dy);</a>
<a name="ln600">    dt_masks_dynbuf_add(dpoints, pt-&gt;ctrl2[0] * wd - dx);</a>
<a name="ln601">    dt_masks_dynbuf_add(dpoints, pt-&gt;ctrl2[1] * ht - dy);</a>
<a name="ln602">  }</a>
<a name="ln603"> </a>
<a name="ln604">  // for the border, we store value too</a>
<a name="ln605">  if(dborder)</a>
<a name="ln606">  {</a>
<a name="ln607">    for(int k = 0; k &lt; nb; k++)</a>
<a name="ln608">    {</a>
<a name="ln609">      dt_masks_dynbuf_add(dborder, 0.0f);</a>
<a name="ln610">      dt_masks_dynbuf_add(dborder, 0.0f);</a>
<a name="ln611">      dt_masks_dynbuf_add(dborder, 0.0f);</a>
<a name="ln612">      dt_masks_dynbuf_add(dborder, 0.0f);</a>
<a name="ln613">      dt_masks_dynbuf_add(dborder, 0.0f);</a>
<a name="ln614">      dt_masks_dynbuf_add(dborder, 0.0f);</a>
<a name="ln615">    }</a>
<a name="ln616">  }</a>
<a name="ln617"> </a>
<a name="ln618">  // for the payload, we reserve an equivalent number of cells to keep it in sync</a>
<a name="ln619">  if(dpayload)</a>
<a name="ln620">  {</a>
<a name="ln621">    for(int k = 0; k &lt; nb; k++)</a>
<a name="ln622">    {</a>
<a name="ln623">      dt_masks_dynbuf_add(dpayload, 0.0f);</a>
<a name="ln624">      dt_masks_dynbuf_add(dpayload, 0.0f);</a>
<a name="ln625">      dt_masks_dynbuf_add(dpayload, 0.0f);</a>
<a name="ln626">      dt_masks_dynbuf_add(dpayload, 0.0f);</a>
<a name="ln627">      dt_masks_dynbuf_add(dpayload, 0.0f);</a>
<a name="ln628">      dt_masks_dynbuf_add(dpayload, 0.0f);</a>
<a name="ln629">    }</a>
<a name="ln630">  }</a>
<a name="ln631"> </a>
<a name="ln632">  int cw = 1;</a>
<a name="ln633">  int start_stamp = 0;</a>
<a name="ln634"> </a>
<a name="ln635">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln636">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] brush_points init took %0.04f sec\n&quot;, form-&gt;name,</a>
<a name="ln637">             dt_get_wtime() - start2);</a>
<a name="ln638">  start2 = dt_get_wtime();</a>
<a name="ln639"> </a>
<a name="ln640">  // we render all segments first upwards, then downwards</a>
<a name="ln641">  for(int n = 0; n &lt; 2 * nb; n++)</a>
<a name="ln642">  {</a>
<a name="ln643">    float p1[7], p2[7], p3[7], p4[7];</a>
<a name="ln644">    int k = _brush_cyclic_cursor(n, nb);</a>
<a name="ln645">    int k1 = _brush_cyclic_cursor(n + 1, nb);</a>
<a name="ln646">    int k2 = _brush_cyclic_cursor(n + 2, nb);</a>
<a name="ln647"> </a>
<a name="ln648">    dt_masks_point_brush_t *point1 = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k);</a>
<a name="ln649">    dt_masks_point_brush_t *point2 = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k1);</a>
<a name="ln650">    dt_masks_point_brush_t *point3 = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k2);</a>
<a name="ln651">    if(cw &gt; 0)</a>
<a name="ln652">    {</a>
<a name="ln653">      float pa[7] = { point1-&gt;corner[0] * wd - dx, point1-&gt;corner[1] * ht - dy, point1-&gt;ctrl2[0] * wd - dx,</a>
<a name="ln654">                      point1-&gt;ctrl2[1] * ht - dy, point1-&gt;border[1] * MIN(wd, ht), point1-&gt;hardness,</a>
<a name="ln655">                      point1-&gt;density };</a>
<a name="ln656">      float pb[7] = { point2-&gt;corner[0] * wd - dx, point2-&gt;corner[1] * ht - dy, point2-&gt;ctrl1[0] * wd - dx,</a>
<a name="ln657">                      point2-&gt;ctrl1[1] * ht - dy, point2-&gt;border[0] * MIN(wd, ht), point2-&gt;hardness,</a>
<a name="ln658">                      point2-&gt;density };</a>
<a name="ln659">      float pc[7] = { point2-&gt;corner[0] * wd - dx, point2-&gt;corner[1] * ht - dy, point2-&gt;ctrl2[0] * wd - dx,</a>
<a name="ln660">                      point2-&gt;ctrl2[1] * ht - dy, point2-&gt;border[1] * MIN(wd, ht), point2-&gt;hardness,</a>
<a name="ln661">                      point2-&gt;density };</a>
<a name="ln662">      float pd[7] = { point3-&gt;corner[0] * wd - dx, point3-&gt;corner[1] * ht - dy, point3-&gt;ctrl1[0] * wd - dx,</a>
<a name="ln663">                      point3-&gt;ctrl1[1] * ht - dy, point3-&gt;border[0] * MIN(wd, ht), point3-&gt;hardness,</a>
<a name="ln664">                      point3-&gt;density };</a>
<a name="ln665">      memcpy(p1, pa, 7 * sizeof(float));</a>
<a name="ln666">      memcpy(p2, pb, 7 * sizeof(float));</a>
<a name="ln667">      memcpy(p3, pc, 7 * sizeof(float));</a>
<a name="ln668">      memcpy(p4, pd, 7 * sizeof(float));</a>
<a name="ln669">    }</a>
<a name="ln670">    else</a>
<a name="ln671">    {</a>
<a name="ln672">      float pa[7] = { point1-&gt;corner[0] * wd - dx, point1-&gt;corner[1] * ht - dy, point1-&gt;ctrl1[0] * wd - dx,</a>
<a name="ln673">                      point1-&gt;ctrl1[1] * ht - dy, point1-&gt;border[1] * MIN(wd, ht), point1-&gt;hardness,</a>
<a name="ln674">                      point1-&gt;density };</a>
<a name="ln675">      float pb[7] = { point2-&gt;corner[0] * wd - dx, point2-&gt;corner[1] * ht - dy, point2-&gt;ctrl2[0] * wd - dx,</a>
<a name="ln676">                      point2-&gt;ctrl2[1] * ht - dy, point2-&gt;border[0] * MIN(wd, ht), point2-&gt;hardness,</a>
<a name="ln677">                      point2-&gt;density };</a>
<a name="ln678">      float pc[7] = { point2-&gt;corner[0] * wd - dx, point2-&gt;corner[1] * ht - dy, point2-&gt;ctrl1[0] * wd - dx,</a>
<a name="ln679">                      point2-&gt;ctrl1[1] * ht - dy, point2-&gt;border[1] * MIN(wd, ht), point2-&gt;hardness,</a>
<a name="ln680">                      point2-&gt;density };</a>
<a name="ln681">      float pd[7] = { point3-&gt;corner[0] * wd - dx, point3-&gt;corner[1] * ht - dy, point3-&gt;ctrl2[0] * wd - dx,</a>
<a name="ln682">                      point3-&gt;ctrl2[1] * ht - dy, point3-&gt;border[0] * MIN(wd, ht), point3-&gt;hardness,</a>
<a name="ln683">                      point3-&gt;density };</a>
<a name="ln684">      memcpy(p1, pa, 7 * sizeof(float));</a>
<a name="ln685">      memcpy(p2, pb, 7 * sizeof(float));</a>
<a name="ln686">      memcpy(p3, pc, 7 * sizeof(float));</a>
<a name="ln687">      memcpy(p4, pd, 7 * sizeof(float));</a>
<a name="ln688">    }</a>
<a name="ln689"> </a>
<a name="ln690">    // 1st. special case: render abrupt transitions between different opacity and/or hardness values</a>
<a name="ln691">    if((fabs(p1[5] - p2[5]) &gt; 0.05f || fabs(p1[6] - p2[6]) &gt; 0.05f) || (start_stamp &amp;&amp; n == 2 * nb - 1))</a>
<a name="ln692">    {</a>
<a name="ln693">      if(n == 0)</a>
<a name="ln694">      {</a>
<a name="ln695">        start_stamp = 1; // remember to deal with the first node as a final step</a>
<a name="ln696">      }</a>
<a name="ln697">      else</a>
<a name="ln698">      {</a>
<a name="ln699">        if(dborder)</a>
<a name="ln700">        {</a>
<a name="ln701">          float bmin[2] = { dt_masks_dynbuf_get(dborder, -2), dt_masks_dynbuf_get(dborder, -1) };</a>
<a name="ln702">          float cmax[2] = { dt_masks_dynbuf_get(dpoints, -2), dt_masks_dynbuf_get(dpoints, -1) };</a>
<a name="ln703">          _brush_points_stamp(cmax, bmin, dpoints, dborder, TRUE);</a>
<a name="ln704">        }</a>
<a name="ln705"> </a>
<a name="ln706">        if(dpayload)</a>
<a name="ln707">        {</a>
<a name="ln708">          while(dt_masks_dynbuf_position(dpayload) &lt; dt_masks_dynbuf_position(dpoints))</a>
<a name="ln709">          {</a>
<a name="ln710">            dt_masks_dynbuf_add(dpayload, p1[5]);</a>
<a name="ln711">            dt_masks_dynbuf_add(dpayload, p1[6]);</a>
<a name="ln712">          }</a>
<a name="ln713">        }</a>
<a name="ln714">      }</a>
<a name="ln715">    }</a>
<a name="ln716"> </a>
<a name="ln717">    // 2nd. special case: render transition point between different brush sizes</a>
<a name="ln718">    if(fabs(p1[4] - p2[4]) &gt; 0.0001f &amp;&amp; n &gt; 0)</a>
<a name="ln719">    {</a>
<a name="ln720">      if(dborder)</a>
<a name="ln721">      {</a>
<a name="ln722">        float bmin[2] = { dt_masks_dynbuf_get(dborder, -2), dt_masks_dynbuf_get(dborder, -1) };</a>
<a name="ln723">        float cmax[2] = { dt_masks_dynbuf_get(dpoints, -2), dt_masks_dynbuf_get(dpoints, -1) };</a>
<a name="ln724">        float bmax[2] = { 2 * cmax[0] - bmin[0], 2 * cmax[1] - bmin[1] };</a>
<a name="ln725">        _brush_points_recurs_border_gaps(cmax, bmin, NULL, bmax, dpoints, dborder, TRUE);</a>
<a name="ln726">      }</a>
<a name="ln727"> </a>
<a name="ln728">      if(dpayload)</a>
<a name="ln729">      {</a>
<a name="ln730">        while(dt_masks_dynbuf_position(dpayload) &lt; dt_masks_dynbuf_position(dpoints))</a>
<a name="ln731">        {</a>
<a name="ln732">          dt_masks_dynbuf_add(dpayload, p1[5]);</a>
<a name="ln733">          dt_masks_dynbuf_add(dpayload, p1[6]);</a>
<a name="ln734">        }</a>
<a name="ln735">      }</a>
<a name="ln736">    }</a>
<a name="ln737"> </a>
<a name="ln738">    // 3rd. special case: render endpoints</a>
<a name="ln739">    if(k == k1)</a>
<a name="ln740">    {</a>
<a name="ln741">      if(dborder)</a>
<a name="ln742">      {</a>
<a name="ln743">        float bmin[2] = { dt_masks_dynbuf_get(dborder, -2), dt_masks_dynbuf_get(dborder, -1) };</a>
<a name="ln744">        float cmax[2] = { dt_masks_dynbuf_get(dpoints, -2), dt_masks_dynbuf_get(dpoints, -1) };</a>
<a name="ln745">        float bmax[2] = { 2 * cmax[0] - bmin[0], 2 * cmax[1] - bmin[1] };</a>
<a name="ln746">        _brush_points_recurs_border_gaps(cmax, bmin, NULL, bmax, dpoints, dborder, TRUE);</a>
<a name="ln747">      }</a>
<a name="ln748"> </a>
<a name="ln749">      if(dpayload)</a>
<a name="ln750">      {</a>
<a name="ln751">        while(dt_masks_dynbuf_position(dpayload) &lt; dt_masks_dynbuf_position(dpoints))</a>
<a name="ln752">        {</a>
<a name="ln753">          dt_masks_dynbuf_add(dpayload, p1[5]);</a>
<a name="ln754">          dt_masks_dynbuf_add(dpayload, p1[6]);</a>
<a name="ln755">        }</a>
<a name="ln756">      }</a>
<a name="ln757"> </a>
<a name="ln758">      cw *= -1;</a>
<a name="ln759">      continue;</a>
<a name="ln760">    }</a>
<a name="ln761"> </a>
<a name="ln762">    // and we determine all points by recursion (to be sure the distance between 2 points is &lt;=1)</a>
<a name="ln763">    float rc[2], rb[2], rp[2];</a>
<a name="ln764">    float bmin[2] = { NAN, NAN };</a>
<a name="ln765">    float bmax[2] = { NAN, NAN };</a>
<a name="ln766">    float cmin[2] = { NAN, NAN };</a>
<a name="ln767">    float cmax[2] = { NAN, NAN };</a>
<a name="ln768"> </a>
<a name="ln769">    _brush_points_recurs(p1, p2, 0.0, 1.0, cmin, cmax, bmin, bmax, rc, rb, rp, dpoints, dborder, dpayload);</a>
<a name="ln770"> </a>
<a name="ln771">    dt_masks_dynbuf_add(dpoints, rc[0]);</a>
<a name="ln772">    dt_masks_dynbuf_add(dpoints, rc[1]);</a>
<a name="ln773"> </a>
<a name="ln774">    if(dpayload)</a>
<a name="ln775">    {</a>
<a name="ln776">      dt_masks_dynbuf_add(dpayload, rp[0]);</a>
<a name="ln777">      dt_masks_dynbuf_add(dpayload, rp[1]);</a>
<a name="ln778">    }</a>
<a name="ln779"> </a>
<a name="ln780">    if(dborder)</a>
<a name="ln781">    {</a>
<a name="ln782">      if(isnan(rb[0]))</a>
<a name="ln783">      {</a>
<a name="ln784">        if(isnan(dt_masks_dynbuf_get(dborder, -2)))</a>
<a name="ln785">        {</a>
<a name="ln786">          dt_masks_dynbuf_set(dborder, -2, dt_masks_dynbuf_get(dborder, -4));</a>
<a name="ln787">          dt_masks_dynbuf_set(dborder, -1, dt_masks_dynbuf_get(dborder, -3));</a>
<a name="ln788">        }</a>
<a name="ln789">        rb[0] = dt_masks_dynbuf_get(dborder, -2);</a>
<a name="ln790">        rb[1] = dt_masks_dynbuf_get(dborder, -1);</a>
<a name="ln791">      }</a>
<a name="ln792">      dt_masks_dynbuf_add(dborder, rb[0]);</a>
<a name="ln793">      dt_masks_dynbuf_add(dborder, rb[1]);</a>
<a name="ln794">    }</a>
<a name="ln795"> </a>
<a name="ln796">    // we first want to be sure that there are no gaps in border</a>
<a name="ln797">    if(dborder &amp;&amp; nb &gt;= 3)</a>
<a name="ln798">    {</a>
<a name="ln799">      // we get the next point (start of the next segment)</a>
<a name="ln800">      _brush_border_get_XY(p3[0], p3[1], p3[2], p3[3], p4[2], p4[3], p4[0], p4[1], 0, p3[4], cmin, cmin + 1,</a>
<a name="ln801">                           bmax, bmax + 1);</a>
<a name="ln802">      if(isnan(bmax[0]))</a>
<a name="ln803">      {</a>
<a name="ln804">        _brush_border_get_XY(p3[0], p3[1], p3[2], p3[3], p4[2], p4[3], p4[0], p4[1], 0.0001, p3[4], cmin,</a>
<a name="ln805">                             cmin + 1, bmax, bmax + 1);</a>
<a name="ln806">      }</a>
<a name="ln807">      if(bmax[0] - rb[0] &gt; 1 || bmax[0] - rb[0] &lt; -1 || bmax[1] - rb[1] &gt; 1 || bmax[1] - rb[1] &lt; -1)</a>
<a name="ln808">      {</a>
<a name="ln809">        // float bmin2[2] = {(*border)[posb-22],(*border)[posb-21]};</a>
<a name="ln810">        _brush_points_recurs_border_gaps(rc, rb, NULL, bmax, dpoints, dborder, cw);</a>
<a name="ln811">      }</a>
<a name="ln812">    }</a>
<a name="ln813"> </a>
<a name="ln814">    if(dpayload)</a>
<a name="ln815">    {</a>
<a name="ln816">      while(dt_masks_dynbuf_position(dpayload) &lt; dt_masks_dynbuf_position(dpoints))</a>
<a name="ln817">      {</a>
<a name="ln818">        dt_masks_dynbuf_add(dpayload, rp[0]);</a>
<a name="ln819">        dt_masks_dynbuf_add(dpayload, rp[1]);</a>
<a name="ln820">      }</a>
<a name="ln821">    }</a>
<a name="ln822">  }</a>
<a name="ln823"> </a>
<a name="ln824">  *points_count = dt_masks_dynbuf_position(dpoints) / 2;</a>
<a name="ln825">  *points = dt_masks_dynbuf_harvest(dpoints);</a>
<a name="ln826">  dt_masks_dynbuf_free(dpoints);</a>
<a name="ln827"> </a>
<a name="ln828">  if(dborder)</a>
<a name="ln829">  {</a>
<a name="ln830">    *border_count = dt_masks_dynbuf_position(dborder) / 2;</a>
<a name="ln831">    *border = dt_masks_dynbuf_harvest(dborder);</a>
<a name="ln832">    dt_masks_dynbuf_free(dborder);</a>
<a name="ln833">  }</a>
<a name="ln834"> </a>
<a name="ln835">  if(dpayload)</a>
<a name="ln836">  {</a>
<a name="ln837">    *payload_count = dt_masks_dynbuf_position(dpayload) / 2;</a>
<a name="ln838">    *payload = dt_masks_dynbuf_harvest(dpayload);</a>
<a name="ln839">    dt_masks_dynbuf_free(dpayload);</a>
<a name="ln840">  }</a>
<a name="ln841">  // printf(&quot;points %d, border %d, playload %d\n&quot;, *points_count, border ? *border_count : -1, payload ?</a>
<a name="ln842">  // *payload_count : -1);</a>
<a name="ln843"> </a>
<a name="ln844">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln845">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] brush_points point recurs %0.04f sec\n&quot;, form-&gt;name,</a>
<a name="ln846">             dt_get_wtime() - start2);</a>
<a name="ln847">  start2 = dt_get_wtime();</a>
<a name="ln848"> </a>
<a name="ln849">  // and we transform them with all distorted modules</a>
<a name="ln850">  if(dt_dev_distort_transform_plus(dev, pipe, iop_order, transf_direction, *points, *points_count))</a>
<a name="ln851">  {</a>
<a name="ln852">    if(!border || dt_dev_distort_transform_plus(dev, pipe, iop_order, transf_direction, *border, *border_count))</a>
<a name="ln853">    {</a>
<a name="ln854">      if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln855">        dt_print(DT_DEBUG_MASKS, &quot;[masks %s] brush_points transform took %0.04f sec\n&quot;, form-&gt;name,</a>
<a name="ln856">                 dt_get_wtime() - start2);</a>
<a name="ln857">//       start2 = dt_get_wtime();</a>
<a name="ln858">      return 1;</a>
<a name="ln859">    }</a>
<a name="ln860">  }</a>
<a name="ln861"> </a>
<a name="ln862">  // if we failed, then free all and return</a>
<a name="ln863">  free(*points);</a>
<a name="ln864">  *points = NULL;</a>
<a name="ln865">  *points_count = 0;</a>
<a name="ln866">  if(border) free(*border);</a>
<a name="ln867">  if(border) *border = NULL;</a>
<a name="ln868">  if(border) *border_count = 0;</a>
<a name="ln869">  if(payload) free(*payload);</a>
<a name="ln870">  if(payload) *payload = NULL;</a>
<a name="ln871">  if(payload) *payload_count = 0;</a>
<a name="ln872">  return 0;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">/** get the distance between point (x,y) and the brush */</a>
<a name="ln876">static void dt_brush_get_distance(float x, int y, float as, dt_masks_form_gui_t *gui, int index,</a>
<a name="ln877">                                  int corner_count, int *inside, int *inside_border, int *near,</a>
<a name="ln878">                                  int *inside_source)</a>
<a name="ln879">{</a>
<a name="ln880">  // initialise returned values</a>
<a name="ln881">  *inside_source = 0;</a>
<a name="ln882">  *inside = 0;</a>
<a name="ln883">  *inside_border = 0;</a>
<a name="ln884">  *near = -1;</a>
<a name="ln885"> </a>
<a name="ln886">  if(!gui) return;</a>
<a name="ln887"> </a>
<a name="ln888">  float yf = (float)y;</a>
<a name="ln889">  dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln890">  if(!gpt) return;</a>
<a name="ln891"> </a>
<a name="ln892">  // we first check if we are inside the source form</a>
<a name="ln893"> </a>
<a name="ln894">  // add support for clone masks</a>
<a name="ln895">  if(gpt-&gt;points_count &gt; 2 + corner_count * 3 &amp;&amp; gpt-&gt;source_count &gt; 2 + corner_count * 3)</a>
<a name="ln896">  {</a>
<a name="ln897">    float dx = -gpt-&gt;points[2] + gpt-&gt;source[2];</a>
<a name="ln898">    float dy = -gpt-&gt;points[3] + gpt-&gt;source[3];</a>
<a name="ln899"> </a>
<a name="ln900">    int current_seg = 1;</a>
<a name="ln901">    for(int i = corner_count * 3; i &lt; gpt-&gt;points_count; i++)</a>
<a name="ln902">    {</a>
<a name="ln903">      // do we change of path segment ?</a>
<a name="ln904">      if(gpt-&gt;points[i * 2 + 1] == gpt-&gt;points[current_seg * 6 + 3]</a>
<a name="ln905">         &amp;&amp; gpt-&gt;points[i * 2] == gpt-&gt;points[current_seg * 6 + 2])</a>
<a name="ln906">      {</a>
<a name="ln907">        current_seg = (current_seg + 1) % corner_count;</a>
<a name="ln908">      }</a>
<a name="ln909">      // distance from tested point to current form point</a>
<a name="ln910">      const float yy = gpt-&gt;points[i * 2 + 1] + dy;</a>
<a name="ln911">      const float xx = gpt-&gt;points[i * 2] + dx;</a>
<a name="ln912">      if((yy - yf) &lt; as &amp;&amp; (yy - yf) &gt; -as &amp;&amp; (xx - x) &lt; as &amp;&amp; (xx - x) &gt; -as)</a>
<a name="ln913">      {</a>
<a name="ln914">        if(current_seg == 0)</a>
<a name="ln915">          *inside_source = corner_count - 1;</a>
<a name="ln916">        else</a>
<a name="ln917">          *inside_source = current_seg - 1;</a>
<a name="ln918"> </a>
<a name="ln919">        if(*inside_source)</a>
<a name="ln920">        {</a>
<a name="ln921">          *inside = 1;</a>
<a name="ln922">          return;</a>
<a name="ln923">        }</a>
<a name="ln924">      }</a>
<a name="ln925">    }</a>
<a name="ln926">  }</a>
<a name="ln927"> </a>
<a name="ln928">  // we check if it's inside borders</a>
<a name="ln929">  if(gpt-&gt;border_count &gt; 2 + corner_count * 3)</a>
<a name="ln930">  {</a>
<a name="ln931">    float last = gpt-&gt;border[gpt-&gt;border_count * 2 - 1];</a>
<a name="ln932">    int nb = 0;</a>
<a name="ln933">    for(int i = corner_count * 3; i &lt; gpt-&gt;border_count; i++)</a>
<a name="ln934">    {</a>
<a name="ln935">      float yy = gpt-&gt;border[i * 2 + 1];</a>
<a name="ln936">      if (((yf&lt;=yy &amp;&amp; yf&gt;last) || (yf&gt;=yy &amp;&amp; yf&lt;last)) &amp;&amp; (gpt-&gt;border[i * 2] &gt; x)) nb++;</a>
<a name="ln937">      last = yy;</a>
<a name="ln938">    }</a>
<a name="ln939">    *inside = *inside_border = (nb &amp; 1);</a>
<a name="ln940">  }</a>
<a name="ln941"> </a>
<a name="ln942">  // and we check if we are near a segment</a>
<a name="ln943">  if(gpt-&gt;points_count &gt; 2 + corner_count * 3)</a>
<a name="ln944">  {</a>
<a name="ln945">    int current_seg = 1;</a>
<a name="ln946">    for(int i = corner_count * 3; i &lt; gpt-&gt;points_count; i++)</a>
<a name="ln947">    {</a>
<a name="ln948">      // do we change of path segment ?</a>
<a name="ln949">      if(gpt-&gt;points[i * 2 + 1] == gpt-&gt;points[current_seg * 6 + 3] &amp;&amp; gpt-&gt;points[i * 2] == gpt-&gt;points[current_seg * 6 + 2])</a>
<a name="ln950">      {</a>
<a name="ln951">        current_seg = (current_seg + 1) % corner_count;</a>
<a name="ln952">      }</a>
<a name="ln953">      //distance from tested point to current form point</a>
<a name="ln954">      float yy = gpt-&gt;points[i * 2 + 1];</a>
<a name="ln955">      float xx = gpt-&gt;points[i * 2];</a>
<a name="ln956">      if ((yy-yf)&lt;as &amp;&amp; (yy-yf)&gt;-as &amp;&amp; (xx-x)&lt;as &amp;&amp; (xx-x)&gt;-as)</a>
<a name="ln957">      {</a>
<a name="ln958">        if(current_seg == 0)</a>
<a name="ln959">          *near = corner_count - 1;</a>
<a name="ln960">        else</a>
<a name="ln961">          *near = current_seg - 1;</a>
<a name="ln962"> </a>
<a name="ln963">        return;</a>
<a name="ln964">      }</a>
<a name="ln965">    }</a>
<a name="ln966">  }</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969">static int dt_brush_get_points_border(dt_develop_t *dev, dt_masks_form_t *form, float **points,</a>
<a name="ln970">                                      int *points_count, float **border, int *border_count, int source)</a>
<a name="ln971">{</a>
<a name="ln972">  return _brush_get_points_border(dev, form, 0.f, DT_DEV_TRANSFORM_DIR_ALL, dev-&gt;preview_pipe, points, points_count, border,</a>
<a name="ln973">                                  border_count, NULL, NULL, source);</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976">/** find relative position within a brush segment that is closest to the point given by coordinates x and y;</a>
<a name="ln977">    we only need to find the minimum with a resolution of 1%, so we just do an exhaustive search without any</a>
<a name="ln978">   frills */</a>
<a name="ln979">static float _brush_get_position_in_segment(float x, float y, dt_masks_form_t *form, int segment)</a>
<a name="ln980">{</a>
<a name="ln981">  guint nb = g_list_length(form-&gt;points);</a>
<a name="ln982">  int pos0 = segment;</a>
<a name="ln983">  int pos1 = segment + 1;</a>
<a name="ln984">  int pos2 = segment + 2;</a>
<a name="ln985">  int pos3 = segment + 3;</a>
<a name="ln986"> </a>
<a name="ln987">  dt_masks_point_brush_t *point0 = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, pos0);</a>
<a name="ln988">  dt_masks_point_brush_t *point1 = pos1 &lt; nb ? (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, pos1)</a>
<a name="ln989">                                             : point0;</a>
<a name="ln990">  dt_masks_point_brush_t *point2 = pos2 &lt; nb ? (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, pos2)</a>
<a name="ln991">                                             : point1;</a>
<a name="ln992">  dt_masks_point_brush_t *point3 = pos3 &lt; nb ? (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, pos3)</a>
<a name="ln993">                                             : point2;</a>
<a name="ln994"> </a>
<a name="ln995">  float tmin = 0;</a>
<a name="ln996">  float dmin = FLT_MAX;</a>
<a name="ln997"> </a>
<a name="ln998">  for(int i = 0; i &lt;= 100; i++)</a>
<a name="ln999">  {</a>
<a name="ln1000">    float t = i / 100.0f;</a>
<a name="ln1001">    float sx, sy;</a>
<a name="ln1002">    _brush_get_XY(point0-&gt;corner[0], point0-&gt;corner[1], point1-&gt;corner[0], point1-&gt;corner[1],</a>
<a name="ln1003">                  point2-&gt;corner[0], point2-&gt;corner[1], point3-&gt;corner[0], point3-&gt;corner[1], t, &amp;sx, &amp;sy);</a>
<a name="ln1004"> </a>
<a name="ln1005">    float d = (x - sx) * (x - sx) + (y - sy) * (y - sy);</a>
<a name="ln1006">    if(d &lt; dmin)</a>
<a name="ln1007">    {</a>
<a name="ln1008">      dmin = d;</a>
<a name="ln1009">      tmin = t;</a>
<a name="ln1010">    }</a>
<a name="ln1011">  }</a>
<a name="ln1012"> </a>
<a name="ln1013">  return tmin;</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016">static int dt_brush_events_mouse_scrolled(struct dt_iop_module_t *module, float pzx, float pzy, int up,</a>
<a name="ln1017">                                          uint32_t state, dt_masks_form_t *form, int parentid,</a>
<a name="ln1018">                                          dt_masks_form_gui_t *gui, int index)</a>
<a name="ln1019">{</a>
<a name="ln1020">  if(gui-&gt;creation)</a>
<a name="ln1021">  {</a>
<a name="ln1022">    if((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln1023">    {</a>
<a name="ln1024">      float masks_hardness;</a>
<a name="ln1025">      float amount = 1.03f;</a>
<a name="ln1026">      if(up) amount = 0.97f;</a>
<a name="ln1027"> </a>
<a name="ln1028">      if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln1029">      {</a>
<a name="ln1030">        masks_hardness = dt_conf_get_float(&quot;plugins/darkroom/spots/brush_hardness&quot;);</a>
<a name="ln1031">        masks_hardness = MAX(0.05f, MIN(masks_hardness * amount, 1.0f));</a>
<a name="ln1032">        dt_conf_set_float(&quot;plugins/darkroom/spots/brush_hardness&quot;, masks_hardness);</a>
<a name="ln1033">      }</a>
<a name="ln1034">      else</a>
<a name="ln1035">      {</a>
<a name="ln1036">        masks_hardness = dt_conf_get_float(&quot;plugins/darkroom/masks/brush/hardness&quot;);</a>
<a name="ln1037">        masks_hardness = MAX(0.05f, MIN(masks_hardness * amount, 1.0f));</a>
<a name="ln1038">        dt_conf_set_float(&quot;plugins/darkroom/masks/brush/hardness&quot;, masks_hardness);</a>
<a name="ln1039">      }</a>
<a name="ln1040"> </a>
<a name="ln1041">      if(gui-&gt;guipoints_count &gt; 0)</a>
<a name="ln1042">      {</a>
<a name="ln1043">        dt_masks_dynbuf_set(gui-&gt;guipoints_payload, -3, masks_hardness);</a>
<a name="ln1044">      }</a>
<a name="ln1045">    }</a>
<a name="ln1046">    else if((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK)</a>
<a name="ln1047">    {</a>
<a name="ln1048">      float masks_density;</a>
<a name="ln1049">      float amount = 1.03f;</a>
<a name="ln1050">      if(up) amount = 0.97f;</a>
<a name="ln1051"> </a>
<a name="ln1052">      if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln1053">      {</a>
<a name="ln1054">        masks_density = dt_conf_get_float(&quot;plugins/darkroom/spots/brush_density&quot;);</a>
<a name="ln1055">        masks_density = MAX(0.05f, MIN(masks_density * amount, 1.0f));</a>
<a name="ln1056">        dt_conf_set_float(&quot;plugins/darkroom/spots/brush_density&quot;, masks_density);</a>
<a name="ln1057">      }</a>
<a name="ln1058">      else</a>
<a name="ln1059">      {</a>
<a name="ln1060">        masks_density = dt_conf_get_float(&quot;plugins/darkroom/masks/brush/density&quot;);</a>
<a name="ln1061">        masks_density = MAX(0.05f, MIN(masks_density * amount, 1.0f));</a>
<a name="ln1062">        dt_conf_set_float(&quot;plugins/darkroom/masks/brush/density&quot;, masks_density);</a>
<a name="ln1063">      }</a>
<a name="ln1064"> </a>
<a name="ln1065">      if(gui-&gt;guipoints_count &gt; 0)</a>
<a name="ln1066">      {</a>
<a name="ln1067">        dt_masks_dynbuf_set(gui-&gt;guipoints_payload, -2, masks_density);</a>
<a name="ln1068">      }</a>
<a name="ln1069">    }</a>
<a name="ln1070"> </a>
<a name="ln1071">    else</a>
<a name="ln1072">    {</a>
<a name="ln1073">      float masks_border;</a>
<a name="ln1074">      float amount = 1.03f;</a>
<a name="ln1075">      if(up) amount = 0.97f;</a>
<a name="ln1076"> </a>
<a name="ln1077">      if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln1078">      {</a>
<a name="ln1079">        masks_border = dt_conf_get_float(&quot;plugins/darkroom/spots/brush_border&quot;);</a>
<a name="ln1080">        masks_border = MAX(0.0005f, MIN(masks_border * amount, 0.5f));</a>
<a name="ln1081">        dt_conf_set_float(&quot;plugins/darkroom/spots/brush_border&quot;, masks_border);</a>
<a name="ln1082">      }</a>
<a name="ln1083">      else</a>
<a name="ln1084">      {</a>
<a name="ln1085">        masks_border = dt_conf_get_float(&quot;plugins/darkroom/masks/brush/border&quot;);</a>
<a name="ln1086">        masks_border = MAX(0.0005f, MIN(masks_border * amount, 0.5f));</a>
<a name="ln1087">        dt_conf_set_float(&quot;plugins/darkroom/masks/brush/border&quot;, masks_border);</a>
<a name="ln1088">      }</a>
<a name="ln1089"> </a>
<a name="ln1090">      if(gui-&gt;guipoints_count &gt; 0)</a>
<a name="ln1091">      {</a>
<a name="ln1092">        dt_masks_dynbuf_set(gui-&gt;guipoints_payload, -4, masks_border);</a>
<a name="ln1093">      }</a>
<a name="ln1094">    }</a>
<a name="ln1095">    dt_control_queue_redraw_center();</a>
<a name="ln1096">    return 1;</a>
<a name="ln1097">  }</a>
<a name="ln1098">  else if(gui-&gt;form_selected || gui-&gt;point_selected &gt;= 0 || gui-&gt;feather_selected &gt;= 0</a>
<a name="ln1099">          || gui-&gt;seg_selected &gt;= 0)</a>
<a name="ln1100">  {</a>
<a name="ln1101">    // we register the current position</a>
<a name="ln1102">    if(gui-&gt;scrollx == 0.0f &amp;&amp; gui-&gt;scrolly == 0.0f)</a>
<a name="ln1103">    {</a>
<a name="ln1104">      gui-&gt;scrollx = pzx;</a>
<a name="ln1105">      gui-&gt;scrolly = pzy;</a>
<a name="ln1106">    }</a>
<a name="ln1107">    if((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK)</a>
<a name="ln1108">    {</a>
<a name="ln1109">      // we try to change the opacity</a>
<a name="ln1110">      dt_masks_form_change_opacity(form, parentid, up);</a>
<a name="ln1111">    }</a>
<a name="ln1112">    else</a>
<a name="ln1113">    {</a>
<a name="ln1114">      guint nb = g_list_length(form-&gt;points);</a>
<a name="ln1115">      // resize don't care where the mouse is inside a shape</a>
<a name="ln1116">      if((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln1117">      {</a>
<a name="ln1118">        float amount = 1.03f;</a>
<a name="ln1119">        if(up) amount = 0.97f;</a>
<a name="ln1120">        // do not exceed upper limit of 1.0 and lower limit of 0.004</a>
<a name="ln1121">        for(int k = 0; k &lt; nb; k++)</a>
<a name="ln1122">        {</a>
<a name="ln1123">          dt_masks_point_brush_t *point = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k);</a>
<a name="ln1124">          if(amount &gt; 1.0f &amp;&amp; (point-&gt;border[0] &gt; 1.0f || point-&gt;border[1] &gt; 1.0f)) return 1;</a>
<a name="ln1125">        }</a>
<a name="ln1126">        for(int k = 0; k &lt; nb; k++)</a>
<a name="ln1127">        {</a>
<a name="ln1128">          dt_masks_point_brush_t *point = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k);</a>
<a name="ln1129">          point-&gt;border[0] *= amount;</a>
<a name="ln1130">          point-&gt;border[1] *= amount;</a>
<a name="ln1131">        }</a>
<a name="ln1132">        if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln1133">        {</a>
<a name="ln1134">          float masks_border = dt_conf_get_float(&quot;plugins/darkroom/spots/brush_border&quot;);</a>
<a name="ln1135">          masks_border = MAX(0.0005f, MIN(masks_border * amount, 0.5f));</a>
<a name="ln1136">          dt_conf_set_float(&quot;plugins/darkroom/spots/brush_border&quot;, masks_border);</a>
<a name="ln1137">        }</a>
<a name="ln1138">        else</a>
<a name="ln1139">        {</a>
<a name="ln1140">          float masks_border = dt_conf_get_float(&quot;plugins/darkroom/masks/brush/border&quot;);</a>
<a name="ln1141">          masks_border = MAX(0.0005f, MIN(masks_border * amount, 0.5f));</a>
<a name="ln1142">          dt_conf_set_float(&quot;plugins/darkroom/masks/brush/border&quot;, masks_border);</a>
<a name="ln1143">        }</a>
<a name="ln1144">      }</a>
<a name="ln1145">      else</a>
<a name="ln1146">      {</a>
<a name="ln1147">        float amount = 1.03f;</a>
<a name="ln1148">        if(up) amount = 0.97f;</a>
<a name="ln1149">        for(int k = 0; k &lt; nb; k++)</a>
<a name="ln1150">        {</a>
<a name="ln1151">          dt_masks_point_brush_t *point = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k);</a>
<a name="ln1152">          float masks_hardness = point-&gt;hardness;</a>
<a name="ln1153">          point-&gt;hardness = MAX(0.05f, MIN(masks_hardness * amount, 1.0f));</a>
<a name="ln1154">        }</a>
<a name="ln1155">        if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln1156">        {</a>
<a name="ln1157">          float masks_hardness = dt_conf_get_float(&quot;plugins/darkroom/spots/brush_hardness&quot;);</a>
<a name="ln1158">          masks_hardness = MAX(0.05f, MIN(masks_hardness * amount, 1.0f));</a>
<a name="ln1159">          dt_conf_set_float(&quot;plugins/darkroom/spots/brush_hardness&quot;, masks_hardness);</a>
<a name="ln1160">        }</a>
<a name="ln1161">        else</a>
<a name="ln1162">        {</a>
<a name="ln1163">          float masks_hardness = dt_conf_get_float(&quot;plugins/darkroom/masks/brush/hardness&quot;);</a>
<a name="ln1164">          masks_hardness = MAX(0.05f, MIN(masks_hardness * amount, 1.0f));</a>
<a name="ln1165">          dt_conf_set_float(&quot;plugins/darkroom/masks/brush/hardness&quot;, masks_hardness);</a>
<a name="ln1166">        }</a>
<a name="ln1167">      }</a>
<a name="ln1168"> </a>
<a name="ln1169">      dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln1170"> </a>
<a name="ln1171">      // we recreate the form points</a>
<a name="ln1172">      dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln1173">      dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln1174"> </a>
<a name="ln1175">      // we save the move</a>
<a name="ln1176">      dt_masks_update_image(darktable.develop);</a>
<a name="ln1177">    }</a>
<a name="ln1178">    return 1;</a>
<a name="ln1179">  }</a>
<a name="ln1180">  return 0;</a>
<a name="ln1181">}</a>
<a name="ln1182"> </a>
<a name="ln1183">static int dt_brush_events_button_pressed(struct dt_iop_module_t *module, float pzx, float pzy,</a>
<a name="ln1184">                                          double pressure, int which, int type, uint32_t state,</a>
<a name="ln1185">                                          dt_masks_form_t *form, int parentid, dt_masks_form_gui_t *gui,</a>
<a name="ln1186">                                          int index)</a>
<a name="ln1187">{</a>
<a name="ln1188">  if(type == GDK_2BUTTON_PRESS || type == GDK_3BUTTON_PRESS) return 1;</a>
<a name="ln1189">  if(!gui) return 0;</a>
<a name="ln1190">  dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln1191">  if(!gpt) return 0;</a>
<a name="ln1192"> </a>
<a name="ln1193">  float masks_border;</a>
<a name="ln1194">  if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln1195">    masks_border = MIN(dt_conf_get_float(&quot;plugins/darkroom/spots/brush_border&quot;), 0.5f);</a>
<a name="ln1196">  else</a>
<a name="ln1197">    masks_border = MIN(dt_conf_get_float(&quot;plugins/darkroom/masks/brush/border&quot;), 0.5f);</a>
<a name="ln1198"> </a>
<a name="ln1199">  float masks_hardness;</a>
<a name="ln1200">  if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln1201">    masks_hardness = MIN(dt_conf_get_float(&quot;plugins/darkroom/spots/brush_hardness&quot;), 1.0f);</a>
<a name="ln1202">  else</a>
<a name="ln1203">    masks_hardness = MIN(dt_conf_get_float(&quot;plugins/darkroom/masks/brush/hardness&quot;), 1.0f);</a>
<a name="ln1204"> </a>
<a name="ln1205">  float masks_density;</a>
<a name="ln1206">  if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln1207">    masks_density = MIN(dt_conf_get_float(&quot;plugins/darkroom/spots/brush_density&quot;), 1.0f);</a>
<a name="ln1208">  else</a>
<a name="ln1209">    masks_density = MIN(dt_conf_get_float(&quot;plugins/darkroom/masks/brush/density&quot;), 1.0f);</a>
<a name="ln1210"> </a>
<a name="ln1211">  if(gui-&gt;creation &amp;&amp; which == 1</a>
<a name="ln1212">     &amp;&amp; (((state &amp; (GDK_CONTROL_MASK | GDK_SHIFT_MASK)) == (GDK_CONTROL_MASK | GDK_SHIFT_MASK))</a>
<a name="ln1213">         || ((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)))</a>
<a name="ln1214">  {</a>
<a name="ln1215">    // set some absolute or relative position for the source of the clone mask</a>
<a name="ln1216">    if(form-&gt;type &amp; DT_MASKS_CLONE) dt_masks_set_source_pos_initial_state(gui, state, pzx, pzy);</a>
<a name="ln1217"> </a>
<a name="ln1218">    return 1;</a>
<a name="ln1219">  }</a>
<a name="ln1220">  else if(which == 1)</a>
<a name="ln1221">  {</a>
<a name="ln1222">    if(gui-&gt;creation)</a>
<a name="ln1223">    {</a>
<a name="ln1224">      float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1225">      float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1226"> </a>
<a name="ln1227">      if(!gui-&gt;guipoints) gui-&gt;guipoints = dt_masks_dynbuf_init(200000, &quot;brush guipoints&quot;);</a>
<a name="ln1228">      if(!gui-&gt;guipoints) return 1;</a>
<a name="ln1229">      if(!gui-&gt;guipoints_payload) gui-&gt;guipoints_payload = dt_masks_dynbuf_init(400000, &quot;brush guipoints_payload&quot;);</a>
<a name="ln1230">      if(!gui-&gt;guipoints_payload) return 1;</a>
<a name="ln1231">      dt_masks_dynbuf_add(gui-&gt;guipoints, pzx * wd);</a>
<a name="ln1232">      dt_masks_dynbuf_add(gui-&gt;guipoints, pzy * ht);</a>
<a name="ln1233">      dt_masks_dynbuf_add(gui-&gt;guipoints_payload, masks_border);</a>
<a name="ln1234">      dt_masks_dynbuf_add(gui-&gt;guipoints_payload, masks_hardness);</a>
<a name="ln1235">      dt_masks_dynbuf_add(gui-&gt;guipoints_payload, masks_density);</a>
<a name="ln1236">      dt_masks_dynbuf_add(gui-&gt;guipoints_payload, pressure);</a>
<a name="ln1237"> </a>
<a name="ln1238">      gui-&gt;guipoints_count = 1;</a>
<a name="ln1239"> </a>
<a name="ln1240">      // add support for clone masks</a>
<a name="ln1241">      if(form-&gt;type &amp; DT_MASKS_CLONE)</a>
<a name="ln1242">      {</a>
<a name="ln1243">        dt_masks_set_source_pos_initial_value(gui, DT_MASKS_BRUSH, form, pzx, pzy);</a>
<a name="ln1244">      }</a>
<a name="ln1245">      else</a>
<a name="ln1246">      {</a>
<a name="ln1247">        // not used by regular masks</a>
<a name="ln1248">        form-&gt;source[0] = form-&gt;source[1] = 0.0f;</a>
<a name="ln1249">      }</a>
<a name="ln1250"> </a>
<a name="ln1251">      gui-&gt;pressure_sensitivity = DT_MASKS_PRESSURE_OFF;</a>
<a name="ln1252">      char *psens = dt_conf_get_string(&quot;pressure_sensitivity&quot;);</a>
<a name="ln1253">      if(psens)</a>
<a name="ln1254">      {</a>
<a name="ln1255">        if(!strcmp(psens, &quot;hardness (absolute)&quot;))</a>
<a name="ln1256">          gui-&gt;pressure_sensitivity = DT_MASKS_PRESSURE_HARDNESS_ABS;</a>
<a name="ln1257">        else if(!strcmp(psens, &quot;hardness (relative)&quot;))</a>
<a name="ln1258">          gui-&gt;pressure_sensitivity = DT_MASKS_PRESSURE_HARDNESS_REL;</a>
<a name="ln1259">        else if(!strcmp(psens, &quot;opacity (absolute)&quot;))</a>
<a name="ln1260">          gui-&gt;pressure_sensitivity = DT_MASKS_PRESSURE_OPACITY_ABS;</a>
<a name="ln1261">        else if(!strcmp(psens, &quot;opacity (relative)&quot;))</a>
<a name="ln1262">          gui-&gt;pressure_sensitivity = DT_MASKS_PRESSURE_OPACITY_REL;</a>
<a name="ln1263">        else if(!strcmp(psens, &quot;brush size (relative)&quot;))</a>
<a name="ln1264">          gui-&gt;pressure_sensitivity = DT_MASKS_PRESSURE_BRUSHSIZE_REL;</a>
<a name="ln1265">        g_free(psens);</a>
<a name="ln1266">      }</a>
<a name="ln1267"> </a>
<a name="ln1268">      dt_control_queue_redraw_center();</a>
<a name="ln1269">      return 1;</a>
<a name="ln1270">    }</a>
<a name="ln1271">    else if(gui-&gt;source_selected &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln1272">    {</a>
<a name="ln1273">      dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln1274">      if(!gpt) return 0;</a>
<a name="ln1275">      // we start the form dragging</a>
<a name="ln1276">      gui-&gt;source_dragging = TRUE;</a>
<a name="ln1277">      gui-&gt;dx = gpt-&gt;source[2] - gui-&gt;posx;</a>
<a name="ln1278">      gui-&gt;dy = gpt-&gt;source[3] - gui-&gt;posy;</a>
<a name="ln1279">      return 1;</a>
<a name="ln1280">    }</a>
<a name="ln1281">    else if(gui-&gt;form_selected &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln1282">    {</a>
<a name="ln1283">      gui-&gt;form_dragging = TRUE;</a>
<a name="ln1284">      gui-&gt;point_edited = -1;</a>
<a name="ln1285">      gui-&gt;dx = gpt-&gt;points[2] - gui-&gt;posx;</a>
<a name="ln1286">      gui-&gt;dy = gpt-&gt;points[3] - gui-&gt;posy;</a>
<a name="ln1287">      return 1;</a>
<a name="ln1288">    }</a>
<a name="ln1289">    else if(gui-&gt;point_selected &gt;= 0)</a>
<a name="ln1290">    {</a>
<a name="ln1291">      // if ctrl is pressed, we change the type of point</a>
<a name="ln1292">      if(gui-&gt;point_edited == gui-&gt;point_selected &amp;&amp; ((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK))</a>
<a name="ln1293">      {</a>
<a name="ln1294">        dt_masks_point_brush_t *point</a>
<a name="ln1295">            = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, gui-&gt;point_edited);</a>
<a name="ln1296">        if(point-&gt;state != DT_MASKS_POINT_STATE_NORMAL)</a>
<a name="ln1297">        {</a>
<a name="ln1298">          point-&gt;state = DT_MASKS_POINT_STATE_NORMAL;</a>
<a name="ln1299">          _brush_init_ctrl_points(form);</a>
<a name="ln1300">        }</a>
<a name="ln1301">        else</a>
<a name="ln1302">        {</a>
<a name="ln1303">          point-&gt;ctrl1[0] = point-&gt;ctrl2[0] = point-&gt;corner[0];</a>
<a name="ln1304">          point-&gt;ctrl1[1] = point-&gt;ctrl2[1] = point-&gt;corner[1];</a>
<a name="ln1305">          point-&gt;state = DT_MASKS_POINT_STATE_USER;</a>
<a name="ln1306">        }</a>
<a name="ln1307">        dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln1308"> </a>
<a name="ln1309">        // we recreate the form points</a>
<a name="ln1310">        dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln1311">        dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln1312">        // we save the move</a>
<a name="ln1313">        dt_masks_update_image(darktable.develop);</a>
<a name="ln1314">        return 1;</a>
<a name="ln1315">      }</a>
<a name="ln1316">      // we register the current position to avoid accidental move</a>
<a name="ln1317">      if(gui-&gt;point_edited &lt; 0 &amp;&amp; gui-&gt;scrollx == 0.0f &amp;&amp; gui-&gt;scrolly == 0.0f)</a>
<a name="ln1318">      {</a>
<a name="ln1319">        gui-&gt;scrollx = pzx;</a>
<a name="ln1320">        gui-&gt;scrolly = pzy;</a>
<a name="ln1321">      }</a>
<a name="ln1322">      gui-&gt;point_edited = gui-&gt;point_dragging = gui-&gt;point_selected;</a>
<a name="ln1323">      dt_control_queue_redraw_center();</a>
<a name="ln1324">      return 1;</a>
<a name="ln1325">    }</a>
<a name="ln1326">    else if(gui-&gt;feather_selected &gt;= 0)</a>
<a name="ln1327">    {</a>
<a name="ln1328">      gui-&gt;feather_dragging = gui-&gt;feather_selected;</a>
<a name="ln1329">      dt_control_queue_redraw_center();</a>
<a name="ln1330">      return 1;</a>
<a name="ln1331">    }</a>
<a name="ln1332">    else if(gui-&gt;point_border_selected &gt;= 0)</a>
<a name="ln1333">    {</a>
<a name="ln1334">      gui-&gt;point_edited = -1;</a>
<a name="ln1335">      gui-&gt;point_border_dragging = gui-&gt;point_border_selected;</a>
<a name="ln1336">      dt_control_queue_redraw_center();</a>
<a name="ln1337">      return 1;</a>
<a name="ln1338">    }</a>
<a name="ln1339">    else if(gui-&gt;seg_selected &gt;= 0)</a>
<a name="ln1340">    {</a>
<a name="ln1341">      guint nb = g_list_length(form-&gt;points);</a>
<a name="ln1342">      gui-&gt;point_edited = -1;</a>
<a name="ln1343">      if((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK)</a>
<a name="ln1344">      {</a>
<a name="ln1345">        // we add a new point to the brush</a>
<a name="ln1346">        dt_masks_point_brush_t *bzpt = (dt_masks_point_brush_t *)(malloc(sizeof(dt_masks_point_brush_t)));</a>
<a name="ln1347"> </a>
<a name="ln1348">        float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1349">        float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1350">        float pts[2] = { pzx * wd, pzy * ht };</a>
<a name="ln1351">        dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln1352"> </a>
<a name="ln1353">        // set coordinates</a>
<a name="ln1354">        bzpt-&gt;corner[0] = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln1355">        bzpt-&gt;corner[1] = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln1356">        bzpt-&gt;ctrl1[0] = bzpt-&gt;ctrl1[1] = bzpt-&gt;ctrl2[0] = bzpt-&gt;ctrl2[1] = -1.0;</a>
<a name="ln1357">        bzpt-&gt;state = DT_MASKS_POINT_STATE_NORMAL;</a>
<a name="ln1358"> </a>
<a name="ln1359">        // set other attributes of the new point. we interpolate the starting and the end point of that</a>
<a name="ln1360">        // segment</a>
<a name="ln1361">        float t = _brush_get_position_in_segment(bzpt-&gt;corner[0], bzpt-&gt;corner[1], form, gui-&gt;seg_selected);</a>
<a name="ln1362">        // start and end point of the segment</a>
<a name="ln1363">        dt_masks_point_brush_t *point0</a>
<a name="ln1364">            = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, gui-&gt;seg_selected);</a>
<a name="ln1365">        dt_masks_point_brush_t *point1</a>
<a name="ln1366">            = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, gui-&gt;seg_selected + 1);</a>
<a name="ln1367">        bzpt-&gt;border[0] = point0-&gt;border[0] * (1.0f - t) + point1-&gt;border[0] * t;</a>
<a name="ln1368">        bzpt-&gt;border[1] = point0-&gt;border[1] * (1.0f - t) + point1-&gt;border[1] * t;</a>
<a name="ln1369">        bzpt-&gt;hardness = point0-&gt;hardness * (1.0f - t) + point1-&gt;hardness * t;</a>
<a name="ln1370">        bzpt-&gt;density = point0-&gt;density * (1.0f - t) + point1-&gt;density * t;</a>
<a name="ln1371"> </a>
<a name="ln1372">        form-&gt;points = g_list_insert(form-&gt;points, bzpt, gui-&gt;seg_selected + 1);</a>
<a name="ln1373">        _brush_init_ctrl_points(form);</a>
<a name="ln1374">        dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln1375">        dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln1376">        gui-&gt;point_edited = gui-&gt;point_dragging = gui-&gt;point_selected = gui-&gt;seg_selected + 1;</a>
<a name="ln1377">        gui-&gt;seg_selected = -1;</a>
<a name="ln1378">        dt_control_queue_redraw_center();</a>
<a name="ln1379">      }</a>
<a name="ln1380">      else if(gui-&gt;seg_selected &gt;= 0 &amp;&amp; gui-&gt;seg_selected &lt; nb - 1)</a>
<a name="ln1381">      {</a>
<a name="ln1382">        // we move the entire segment</a>
<a name="ln1383">        gui-&gt;seg_dragging = gui-&gt;seg_selected;</a>
<a name="ln1384">        gui-&gt;dx = gpt-&gt;points[gui-&gt;seg_selected * 6 + 2] - gui-&gt;posx;</a>
<a name="ln1385">        gui-&gt;dy = gpt-&gt;points[gui-&gt;seg_selected * 6 + 3] - gui-&gt;posy;</a>
<a name="ln1386">      }</a>
<a name="ln1387">      return 1;</a>
<a name="ln1388">    }</a>
<a name="ln1389">    gui-&gt;point_edited = -1;</a>
<a name="ln1390">  }</a>
<a name="ln1391">  else if(gui-&gt;creation &amp;&amp; which == 3)</a>
<a name="ln1392">  {</a>
<a name="ln1393">    dt_masks_dynbuf_free(gui-&gt;guipoints);</a>
<a name="ln1394">    dt_masks_dynbuf_free(gui-&gt;guipoints_payload);</a>
<a name="ln1395">    gui-&gt;guipoints = NULL;</a>
<a name="ln1396">    gui-&gt;guipoints_payload = NULL;</a>
<a name="ln1397">    gui-&gt;guipoints_count = 0;</a>
<a name="ln1398"> </a>
<a name="ln1399">    gui-&gt;creation_continuous = FALSE;</a>
<a name="ln1400">    gui-&gt;creation_continuous_module = NULL;</a>
<a name="ln1401"> </a>
<a name="ln1402">    dt_masks_set_edit_mode(module, DT_MASKS_EDIT_FULL);</a>
<a name="ln1403">    dt_masks_iop_update(module);</a>
<a name="ln1404">    dt_control_queue_redraw_center();</a>
<a name="ln1405">    return 1;</a>
<a name="ln1406">  }</a>
<a name="ln1407">  else if(gui-&gt;point_selected &gt;= 0 &amp;&amp; which == 3)</a>
<a name="ln1408">  {</a>
<a name="ln1409">    // we remove the point (and the entire form if there is too few points)</a>
<a name="ln1410">    if(g_list_length(form-&gt;points) &lt;= 2)</a>
<a name="ln1411">    {</a>
<a name="ln1412">      // if the form doesn't below to a group, we don't delete it</a>
<a name="ln1413">      if(parentid &lt;= 0) return 1;</a>
<a name="ln1414"> </a>
<a name="ln1415">      // we hide the form</a>
<a name="ln1416">      if(!(darktable.develop-&gt;form_visible-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln1417">        dt_masks_change_form_gui(NULL);</a>
<a name="ln1418">      else if(g_list_length(darktable.develop-&gt;form_visible-&gt;points) &lt; 2)</a>
<a name="ln1419">        dt_masks_change_form_gui(NULL);</a>
<a name="ln1420">      else</a>
<a name="ln1421">      {</a>
<a name="ln1422">        int emode = gui-&gt;edit_mode;</a>
<a name="ln1423">        dt_masks_clear_form_gui(darktable.develop);</a>
<a name="ln1424">        GList *forms = g_list_first(darktable.develop-&gt;form_visible-&gt;points);</a>
<a name="ln1425">        while(forms)</a>
<a name="ln1426">        {</a>
<a name="ln1427">          dt_masks_point_group_t *gpt = (dt_masks_point_group_t *)forms-&gt;data;</a>
<a name="ln1428">          if(gpt-&gt;formid == form-&gt;formid)</a>
<a name="ln1429">          {</a>
<a name="ln1430">            darktable.develop-&gt;form_visible-&gt;points</a>
<a name="ln1431">                = g_list_remove(darktable.develop-&gt;form_visible-&gt;points, gpt);</a>
<a name="ln1432">            free(gpt);</a>
<a name="ln1433">            break;</a>
<a name="ln1434">          }</a>
<a name="ln1435">          forms = g_list_next(forms);</a>
<a name="ln1436">        }</a>
<a name="ln1437">        gui-&gt;edit_mode = emode;</a>
<a name="ln1438">      }</a>
<a name="ln1439"> </a>
<a name="ln1440">      // we delete or remove the shape</a>
<a name="ln1441">      dt_masks_form_remove(module, NULL, form);</a>
<a name="ln1442">      dt_control_queue_redraw_center();</a>
<a name="ln1443">      return 1;</a>
<a name="ln1444">    }</a>
<a name="ln1445">    dt_masks_point_brush_t *point</a>
<a name="ln1446">        = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, gui-&gt;point_selected);</a>
<a name="ln1447">    form-&gt;points = g_list_remove(form-&gt;points, point);</a>
<a name="ln1448">    free(point);</a>
<a name="ln1449">    gui-&gt;point_selected = -1;</a>
<a name="ln1450">    _brush_init_ctrl_points(form);</a>
<a name="ln1451"> </a>
<a name="ln1452">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln1453"> </a>
<a name="ln1454">    // we recreate the form points</a>
<a name="ln1455">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln1456">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln1457">    // we save the move</a>
<a name="ln1458">    dt_masks_update_image(darktable.develop);</a>
<a name="ln1459"> </a>
<a name="ln1460">    return 1;</a>
<a name="ln1461">  }</a>
<a name="ln1462">  else if(gui-&gt;feather_selected &gt;= 0 &amp;&amp; which == 3)</a>
<a name="ln1463">  {</a>
<a name="ln1464">    dt_masks_point_brush_t *point</a>
<a name="ln1465">        = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, gui-&gt;feather_selected);</a>
<a name="ln1466">    if(point-&gt;state != DT_MASKS_POINT_STATE_NORMAL)</a>
<a name="ln1467">    {</a>
<a name="ln1468">      point-&gt;state = DT_MASKS_POINT_STATE_NORMAL;</a>
<a name="ln1469">      _brush_init_ctrl_points(form);</a>
<a name="ln1470"> </a>
<a name="ln1471">      dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln1472"> </a>
<a name="ln1473">      // we recreate the form points</a>
<a name="ln1474">      dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln1475">      dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln1476">      // we save the move</a>
<a name="ln1477">      dt_masks_update_image(darktable.develop);</a>
<a name="ln1478">    }</a>
<a name="ln1479">    return 1;</a>
<a name="ln1480">  }</a>
<a name="ln1481">  else if(which == 3 &amp;&amp; parentid &gt; 0 &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln1482">  {</a>
<a name="ln1483">    // we hide the form</a>
<a name="ln1484">    if(!(darktable.develop-&gt;form_visible-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln1485">      dt_masks_change_form_gui(NULL);</a>
<a name="ln1486">    else if(g_list_length(darktable.develop-&gt;form_visible-&gt;points) &lt; 2)</a>
<a name="ln1487">      dt_masks_change_form_gui(NULL);</a>
<a name="ln1488">    else</a>
<a name="ln1489">    {</a>
<a name="ln1490">      dt_masks_clear_form_gui(darktable.develop);</a>
<a name="ln1491">      GList *forms = g_list_first(darktable.develop-&gt;form_visible-&gt;points);</a>
<a name="ln1492">      while(forms)</a>
<a name="ln1493">      {</a>
<a name="ln1494">        dt_masks_point_group_t *gpt = (dt_masks_point_group_t *)forms-&gt;data;</a>
<a name="ln1495">        if(gpt-&gt;formid == form-&gt;formid)</a>
<a name="ln1496">        {</a>
<a name="ln1497">          darktable.develop-&gt;form_visible-&gt;points</a>
<a name="ln1498">              = g_list_remove(darktable.develop-&gt;form_visible-&gt;points, gpt);</a>
<a name="ln1499">          free(gpt);</a>
<a name="ln1500">          break;</a>
<a name="ln1501">        }</a>
<a name="ln1502">        forms = g_list_next(forms);</a>
<a name="ln1503">      }</a>
<a name="ln1504">      gui-&gt;edit_mode = DT_MASKS_EDIT_FULL;</a>
<a name="ln1505">    }</a>
<a name="ln1506"> </a>
<a name="ln1507">    // we remove the shape</a>
<a name="ln1508">    dt_masks_form_remove(module, dt_masks_get_from_id(darktable.develop, parentid), form);</a>
<a name="ln1509">    return 1;</a>
<a name="ln1510">  }</a>
<a name="ln1511"> </a>
<a name="ln1512">  return 0;</a>
<a name="ln1513">}</a>
<a name="ln1514"> </a>
<a name="ln1515">static int dt_brush_events_button_released(struct dt_iop_module_t *module, float pzx, float pzy, int which,</a>
<a name="ln1516">                                           uint32_t state, dt_masks_form_t *form, int parentid,</a>
<a name="ln1517">                                           dt_masks_form_gui_t *gui, int index)</a>
<a name="ln1518">{</a>
<a name="ln1519">  if(!gui) return 0;</a>
<a name="ln1520"> </a>
<a name="ln1521">  dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln1522">  if(!gpt) return 0;</a>
<a name="ln1523"> </a>
<a name="ln1524">  float masks_border;</a>
<a name="ln1525">  if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln1526">    masks_border = MIN(dt_conf_get_float(&quot;plugins/darkroom/spots/brush_border&quot;), 0.5f);</a>
<a name="ln1527">  else</a>
<a name="ln1528">    masks_border = MIN(dt_conf_get_float(&quot;plugins/darkroom/masks/brush/border&quot;), 0.5f);</a>
<a name="ln1529"> </a>
<a name="ln1530">  if(gui-&gt;creation &amp;&amp; which == 1 &amp;&amp; (state &amp; (GDK_CONTROL_MASK | GDK_SHIFT_MASK)))</a>
<a name="ln1531">  {</a>
<a name="ln1532">    // user just set the source position, so just return</a>
<a name="ln1533">    return 1;</a>
<a name="ln1534">  }</a>
<a name="ln1535">  else if(gui-&gt;creation &amp;&amp; which == 1)</a>
<a name="ln1536">  {</a>
<a name="ln1537">    dt_iop_module_t *crea_module = gui-&gt;creation_module;</a>
<a name="ln1538"> </a>
<a name="ln1539">    if(gui-&gt;guipoints &amp;&amp; gui-&gt;guipoints_count &gt; 0)</a>
<a name="ln1540">    {</a>
<a name="ln1541">      // if the path consists only of one x/y pair we add a second one close so we don't need to deal with</a>
<a name="ln1542">      // this special case later</a>
<a name="ln1543">      if(gui-&gt;guipoints_count == 1)</a>
<a name="ln1544">      {</a>
<a name="ln1545">        // add a helper node very close to the single spot</a>
<a name="ln1546">        const float x = dt_masks_dynbuf_get(gui-&gt;guipoints, -2) + 0.01f;</a>
<a name="ln1547">        const float y = dt_masks_dynbuf_get(gui-&gt;guipoints, -1) - 0.01f;</a>
<a name="ln1548">        dt_masks_dynbuf_add(gui-&gt;guipoints, x);</a>
<a name="ln1549">        dt_masks_dynbuf_add(gui-&gt;guipoints, y);</a>
<a name="ln1550">        const float border = dt_masks_dynbuf_get(gui-&gt;guipoints_payload, -4);</a>
<a name="ln1551">        const float hardness = dt_masks_dynbuf_get(gui-&gt;guipoints_payload, -3);</a>
<a name="ln1552">        const float density = dt_masks_dynbuf_get(gui-&gt;guipoints_payload, -2);</a>
<a name="ln1553">        const float pressure = dt_masks_dynbuf_get(gui-&gt;guipoints_payload, -1);</a>
<a name="ln1554">        dt_masks_dynbuf_add(gui-&gt;guipoints_payload, border);</a>
<a name="ln1555">        dt_masks_dynbuf_add(gui-&gt;guipoints_payload, hardness);</a>
<a name="ln1556">        dt_masks_dynbuf_add(gui-&gt;guipoints_payload, density);</a>
<a name="ln1557">        dt_masks_dynbuf_add(gui-&gt;guipoints_payload, pressure);</a>
<a name="ln1558">        gui-&gt;guipoints_count++;</a>
<a name="ln1559">      }</a>
<a name="ln1560"> </a>
<a name="ln1561">      float *guipoints = dt_masks_dynbuf_buffer(gui-&gt;guipoints);</a>
<a name="ln1562">      float *guipoints_payload = dt_masks_dynbuf_buffer(gui-&gt;guipoints_payload);</a>
<a name="ln1563"> </a>
<a name="ln1564">      // we transform the points</a>
<a name="ln1565">      dt_dev_distort_backtransform(darktable.develop, guipoints, gui-&gt;guipoints_count);</a>
<a name="ln1566"> </a>
<a name="ln1567">      for(int i = 0; i &lt; gui-&gt;guipoints_count; i++)</a>
<a name="ln1568">      {</a>
<a name="ln1569">        guipoints[i * 2] /= darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln1570">        guipoints[i * 2 + 1] /= darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln1571">      }</a>
<a name="ln1572"> </a>
<a name="ln1573">      // we consolidate pen pressure readings into payload</a>
<a name="ln1574">      for(int i = 0; i &lt; gui-&gt;guipoints_count; i++)</a>
<a name="ln1575">      {</a>
<a name="ln1576">        float *payload = guipoints_payload + 4 * i;</a>
<a name="ln1577">        float pressure = payload[3];</a>
<a name="ln1578">        payload[3] = 1.0f;</a>
<a name="ln1579"> </a>
<a name="ln1580">        switch(gui-&gt;pressure_sensitivity)</a>
<a name="ln1581">        {</a>
<a name="ln1582">          case DT_MASKS_PRESSURE_BRUSHSIZE_REL:</a>
<a name="ln1583">            payload[0] = MAX(0.005f, payload[0] * pressure);</a>
<a name="ln1584">            break;</a>
<a name="ln1585">          case DT_MASKS_PRESSURE_HARDNESS_ABS:</a>
<a name="ln1586">            payload[1] = MAX(0.05f, pressure);</a>
<a name="ln1587">            break;</a>
<a name="ln1588">          case DT_MASKS_PRESSURE_HARDNESS_REL:</a>
<a name="ln1589">            payload[1] = MAX(0.05f, payload[1] * pressure);</a>
<a name="ln1590">            break;</a>
<a name="ln1591">          case DT_MASKS_PRESSURE_OPACITY_ABS:</a>
<a name="ln1592">            payload[2] = MAX(0.05f, pressure);</a>
<a name="ln1593">            break;</a>
<a name="ln1594">          case DT_MASKS_PRESSURE_OPACITY_REL:</a>
<a name="ln1595">            payload[2] = MAX(0.05f, payload[2] * pressure);</a>
<a name="ln1596">            break;</a>
<a name="ln1597">          default:</a>
<a name="ln1598">          case DT_MASKS_PRESSURE_OFF:</a>
<a name="ln1599">            // ignore pressure value</a>
<a name="ln1600">            break;</a>
<a name="ln1601">        }</a>
<a name="ln1602">      }</a>
<a name="ln1603"> </a>
<a name="ln1604">      float factor = 0.01f;</a>
<a name="ln1605">      char *smoothing = dt_conf_get_string(&quot;brush_smoothing&quot;);</a>
<a name="ln1606">      if(smoothing)</a>
<a name="ln1607">      {</a>
<a name="ln1608">        if(!strcmp(smoothing, &quot;low&quot;))</a>
<a name="ln1609">          factor = 0.0025f;</a>
<a name="ln1610">        else if(!strcmp(smoothing, &quot;medium&quot;))</a>
<a name="ln1611">          factor = 0.01f;</a>
<a name="ln1612">        else if(!strcmp(smoothing, &quot;high&quot;))</a>
<a name="ln1613">          factor = 0.04f;</a>
<a name="ln1614">        g_free(smoothing);</a>
<a name="ln1615">      }</a>
<a name="ln1616"> </a>
<a name="ln1617">      // accuracy level for node elimination, dependent on brush size</a>
<a name="ln1618">      const float epsilon2 = factor * MAX(0.005f, masks_border) * MAX(0.005f, masks_border);</a>
<a name="ln1619"> </a>
<a name="ln1620">      // we simplify the path and generate the nodes</a>
<a name="ln1621">      form-&gt;points = _brush_ramer_douglas_peucker(guipoints, gui-&gt;guipoints_count, guipoints_payload, epsilon2);</a>
<a name="ln1622"> </a>
<a name="ln1623">      // printf(&quot;guipoints_count %d, points %d\n&quot;, gui-&gt;guipoints_count, g_list_length(form-&gt;points));</a>
<a name="ln1624"> </a>
<a name="ln1625">      _brush_init_ctrl_points(form);</a>
<a name="ln1626"> </a>
<a name="ln1627">      dt_masks_dynbuf_free(gui-&gt;guipoints);</a>
<a name="ln1628">      dt_masks_dynbuf_free(gui-&gt;guipoints_payload);</a>
<a name="ln1629">      gui-&gt;guipoints = NULL;</a>
<a name="ln1630">      gui-&gt;guipoints_payload = NULL;</a>
<a name="ln1631">      gui-&gt;guipoints_count = 0;</a>
<a name="ln1632"> </a>
<a name="ln1633">      // we save the form and quit creation mode</a>
<a name="ln1634">      dt_masks_gui_form_save_creation(darktable.develop, crea_module, form, gui);</a>
<a name="ln1635"> </a>
<a name="ln1636">      if(crea_module)</a>
<a name="ln1637">      {</a>
<a name="ln1638">        dt_dev_add_history_item(darktable.develop, crea_module, TRUE);</a>
<a name="ln1639">        // and we switch in edit mode to show all the forms</a>
<a name="ln1640">        if(gui-&gt;creation_continuous)</a>
<a name="ln1641">          dt_masks_set_edit_mode_single_form(crea_module, form-&gt;formid, DT_MASKS_EDIT_FULL);</a>
<a name="ln1642">        else</a>
<a name="ln1643">          dt_masks_set_edit_mode(crea_module, DT_MASKS_EDIT_FULL);</a>
<a name="ln1644">        dt_masks_iop_update(crea_module);</a>
<a name="ln1645">        gui-&gt;creation_module = NULL;</a>
<a name="ln1646">      }</a>
<a name="ln1647">      else</a>
<a name="ln1648">      {</a>
<a name="ln1649">        dt_dev_masks_selection_change(darktable.develop, form-&gt;formid, TRUE);</a>
<a name="ln1650">      }</a>
<a name="ln1651"> </a>
<a name="ln1652">      if(gui-&gt;creation_continuous)</a>
<a name="ln1653">      {</a>
<a name="ln1654">        dt_masks_form_t *form_new = dt_masks_create(form-&gt;type);</a>
<a name="ln1655">        dt_masks_change_form_gui(form_new);</a>
<a name="ln1656"> </a>
<a name="ln1657">        darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln1658">        darktable.develop-&gt;form_gui-&gt;creation_module = gui-&gt;creation_continuous_module;</a>
<a name="ln1659">      }</a>
<a name="ln1660">      else if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln1661">      {</a>
<a name="ln1662">        dt_masks_form_t *grp = darktable.develop-&gt;form_visible;</a>
<a name="ln1663">        if(!grp || !(grp-&gt;type &amp; DT_MASKS_GROUP)) return 1;</a>
<a name="ln1664">        int pos3 = 0, pos2 = -1;</a>
<a name="ln1665">        GList *fs = g_list_first(grp-&gt;points);</a>
<a name="ln1666">        while(fs)</a>
<a name="ln1667">        {</a>
<a name="ln1668">          dt_masks_point_group_t *pt = (dt_masks_point_group_t *)fs-&gt;data;</a>
<a name="ln1669">          if(pt-&gt;formid == form-&gt;formid)</a>
<a name="ln1670">          {</a>
<a name="ln1671">            pos2 = pos3;</a>
<a name="ln1672">            break;</a>
<a name="ln1673">          }</a>
<a name="ln1674">          pos3++;</a>
<a name="ln1675">          fs = g_list_next(fs);</a>
<a name="ln1676">        }</a>
<a name="ln1677">        if(pos2 &lt; 0) return 1;</a>
<a name="ln1678">        dt_masks_form_gui_t *gui2 = darktable.develop-&gt;form_gui;</a>
<a name="ln1679">        if(!gui2) return 1;</a>
<a name="ln1680">        gui2-&gt;group_selected = pos2;</a>
<a name="ln1681"> </a>
<a name="ln1682">        dt_masks_select_form(crea_module, dt_masks_get_from_id(darktable.develop, form-&gt;formid));</a>
<a name="ln1683">      }</a>
<a name="ln1684">    }</a>
<a name="ln1685">    else</a>
<a name="ln1686">    {</a>
<a name="ln1687">      // unlikely case of button released but no points gathered -&gt; no form</a>
<a name="ln1688">      dt_masks_dynbuf_free(gui-&gt;guipoints);</a>
<a name="ln1689">      dt_masks_dynbuf_free(gui-&gt;guipoints_payload);</a>
<a name="ln1690">      gui-&gt;guipoints = NULL;</a>
<a name="ln1691">      gui-&gt;guipoints_payload = NULL;</a>
<a name="ln1692">      gui-&gt;guipoints_count = 0;</a>
<a name="ln1693"> </a>
<a name="ln1694">      gui-&gt;creation_continuous = FALSE;</a>
<a name="ln1695">      gui-&gt;creation_continuous_module = NULL;</a>
<a name="ln1696"> </a>
<a name="ln1697">      dt_masks_set_edit_mode(module, DT_MASKS_EDIT_FULL);</a>
<a name="ln1698">      dt_masks_iop_update(module);</a>
<a name="ln1699"> </a>
<a name="ln1700">      dt_masks_change_form_gui(NULL);</a>
<a name="ln1701">    }</a>
<a name="ln1702"> </a>
<a name="ln1703">    dt_control_queue_redraw_center();</a>
<a name="ln1704">    return 1;</a>
<a name="ln1705">  }</a>
<a name="ln1706">  else if(gui-&gt;form_dragging)</a>
<a name="ln1707">  {</a>
<a name="ln1708">    // we end the form dragging</a>
<a name="ln1709">    gui-&gt;form_dragging = FALSE;</a>
<a name="ln1710"> </a>
<a name="ln1711">    // we get point0 new values</a>
<a name="ln1712">    dt_masks_point_brush_t *point = (dt_masks_point_brush_t *)g_list_first(form-&gt;points)-&gt;data;</a>
<a name="ln1713">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1714">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1715">    float pts[2] = { pzx * wd + gui-&gt;dx, pzy * ht + gui-&gt;dy };</a>
<a name="ln1716">    dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln1717">    float dx = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth - point-&gt;corner[0];</a>
<a name="ln1718">    float dy = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight - point-&gt;corner[1];</a>
<a name="ln1719"> </a>
<a name="ln1720">    // we move all points</a>
<a name="ln1721">    GList *points = g_list_first(form-&gt;points);</a>
<a name="ln1722">    while(points)</a>
<a name="ln1723">    {</a>
<a name="ln1724">      point = (dt_masks_point_brush_t *)points-&gt;data;</a>
<a name="ln1725">      point-&gt;corner[0] += dx;</a>
<a name="ln1726">      point-&gt;corner[1] += dy;</a>
<a name="ln1727">      point-&gt;ctrl1[0] += dx;</a>
<a name="ln1728">      point-&gt;ctrl1[1] += dy;</a>
<a name="ln1729">      point-&gt;ctrl2[0] += dx;</a>
<a name="ln1730">      point-&gt;ctrl2[1] += dy;</a>
<a name="ln1731">      points = g_list_next(points);</a>
<a name="ln1732">    }</a>
<a name="ln1733"> </a>
<a name="ln1734">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln1735"> </a>
<a name="ln1736">    // we recreate the form points</a>
<a name="ln1737">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln1738">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln1739"> </a>
<a name="ln1740">    // we save the move</a>
<a name="ln1741">    dt_masks_update_image(darktable.develop);</a>
<a name="ln1742"> </a>
<a name="ln1743">    return 1;</a>
<a name="ln1744">  }</a>
<a name="ln1745">  else if(gui-&gt;source_dragging)</a>
<a name="ln1746">  {</a>
<a name="ln1747">    // we end the form dragging</a>
<a name="ln1748">    gui-&gt;source_dragging = FALSE;</a>
<a name="ln1749"> </a>
<a name="ln1750">    // we change the source value</a>
<a name="ln1751">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1752">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1753">    float pts[2] = { pzx * wd + gui-&gt;dx, pzy * ht + gui-&gt;dy };</a>
<a name="ln1754">    dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln1755">    form-&gt;source[0] = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln1756">    form-&gt;source[1] = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln1757">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln1758"> </a>
<a name="ln1759">    // we recreate the form points</a>
<a name="ln1760">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln1761">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln1762"> </a>
<a name="ln1763">    // we save the move</a>
<a name="ln1764">    dt_masks_update_image(darktable.develop);</a>
<a name="ln1765"> </a>
<a name="ln1766">    return 1;</a>
<a name="ln1767">  }</a>
<a name="ln1768">  else if(gui-&gt;seg_dragging &gt;= 0)</a>
<a name="ln1769">  {</a>
<a name="ln1770">    gui-&gt;seg_dragging = -1;</a>
<a name="ln1771">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln1772">    dt_masks_update_image(darktable.develop);</a>
<a name="ln1773">    return 1;</a>
<a name="ln1774">  }</a>
<a name="ln1775">  else if(gui-&gt;point_dragging &gt;= 0)</a>
<a name="ln1776">  {</a>
<a name="ln1777">    dt_masks_point_brush_t *point</a>
<a name="ln1778">        = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, gui-&gt;point_dragging);</a>
<a name="ln1779">    gui-&gt;point_dragging = -1;</a>
<a name="ln1780">    if(gui-&gt;scrollx != 0.0f || gui-&gt;scrolly != 0.0f)</a>
<a name="ln1781">    {</a>
<a name="ln1782">      gui-&gt;scrollx = gui-&gt;scrolly = 0;</a>
<a name="ln1783">      return 1;</a>
<a name="ln1784">    }</a>
<a name="ln1785">    gui-&gt;scrollx = gui-&gt;scrolly = 0;</a>
<a name="ln1786">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1787">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1788">    float pts[2] = { pzx * wd, pzy * ht };</a>
<a name="ln1789">    dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln1790">    float dx = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth - point-&gt;corner[0];</a>
<a name="ln1791">    float dy = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight - point-&gt;corner[1];</a>
<a name="ln1792"> </a>
<a name="ln1793">    point-&gt;corner[0] += dx;</a>
<a name="ln1794">    point-&gt;corner[1] += dy;</a>
<a name="ln1795">    point-&gt;ctrl1[0] += dx;</a>
<a name="ln1796">    point-&gt;ctrl1[1] += dy;</a>
<a name="ln1797">    point-&gt;ctrl2[0] += dx;</a>
<a name="ln1798">    point-&gt;ctrl2[1] += dy;</a>
<a name="ln1799"> </a>
<a name="ln1800">    _brush_init_ctrl_points(form);</a>
<a name="ln1801"> </a>
<a name="ln1802">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln1803"> </a>
<a name="ln1804">    // we recreate the form points</a>
<a name="ln1805">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln1806">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln1807">    // we save the move</a>
<a name="ln1808">    dt_masks_update_image(darktable.develop);</a>
<a name="ln1809"> </a>
<a name="ln1810">    return 1;</a>
<a name="ln1811">  }</a>
<a name="ln1812">  else if(gui-&gt;feather_dragging &gt;= 0)</a>
<a name="ln1813">  {</a>
<a name="ln1814">    dt_masks_point_brush_t *point</a>
<a name="ln1815">        = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, gui-&gt;feather_dragging);</a>
<a name="ln1816">    gui-&gt;feather_dragging = -1;</a>
<a name="ln1817">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1818">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1819">    float pts[2] = { pzx * wd, pzy * ht };</a>
<a name="ln1820">    dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln1821"> </a>
<a name="ln1822">    int p1x, p1y, p2x, p2y;</a>
<a name="ln1823">    _brush_feather_to_ctrl(point-&gt;corner[0] * darktable.develop-&gt;preview_pipe-&gt;iwidth,</a>
<a name="ln1824">                           point-&gt;corner[1] * darktable.develop-&gt;preview_pipe-&gt;iheight, pts[0], pts[1], &amp;p1x,</a>
<a name="ln1825">                           &amp;p1y, &amp;p2x, &amp;p2y, TRUE);</a>
<a name="ln1826">    point-&gt;ctrl1[0] = (float)p1x / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln1827">    point-&gt;ctrl1[1] = (float)p1y / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln1828">    point-&gt;ctrl2[0] = (float)p2x / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln1829">    point-&gt;ctrl2[1] = (float)p2y / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln1830"> </a>
<a name="ln1831">    point-&gt;state = DT_MASKS_POINT_STATE_USER;</a>
<a name="ln1832"> </a>
<a name="ln1833">    _brush_init_ctrl_points(form);</a>
<a name="ln1834"> </a>
<a name="ln1835">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln1836"> </a>
<a name="ln1837">    // we recreate the form points</a>
<a name="ln1838">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln1839">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln1840">    // we save the move</a>
<a name="ln1841">    dt_masks_update_image(darktable.develop);</a>
<a name="ln1842"> </a>
<a name="ln1843">    return 1;</a>
<a name="ln1844">  }</a>
<a name="ln1845">  else if(gui-&gt;point_border_dragging &gt;= 0)</a>
<a name="ln1846">  {</a>
<a name="ln1847">    gui-&gt;point_border_dragging = -1;</a>
<a name="ln1848"> </a>
<a name="ln1849">    // we save the move</a>
<a name="ln1850">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln1851">    dt_masks_update_image(darktable.develop);</a>
<a name="ln1852">    dt_control_queue_redraw_center();</a>
<a name="ln1853">    return 1;</a>
<a name="ln1854">  }</a>
<a name="ln1855"> </a>
<a name="ln1856">  return 0;</a>
<a name="ln1857">}</a>
<a name="ln1858"> </a>
<a name="ln1859">static int dt_brush_events_mouse_moved(struct dt_iop_module_t *module, float pzx, float pzy, double pressure,</a>
<a name="ln1860">                                       int which, dt_masks_form_t *form, int parentid,</a>
<a name="ln1861">                                       dt_masks_form_gui_t *gui, int index)</a>
<a name="ln1862">{</a>
<a name="ln1863">  dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln1864">  int closeup = dt_control_get_dev_closeup();</a>
<a name="ln1865">  float zoom_scale = dt_dev_get_zoom_scale(darktable.develop, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln1866">  float as = 0.005f / zoom_scale * darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1867">  if(!gui) return 0;</a>
<a name="ln1868">  dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln1869">  if(!gpt) return 0;</a>
<a name="ln1870"> </a>
<a name="ln1871">  if(gui-&gt;creation)</a>
<a name="ln1872">  {</a>
<a name="ln1873">    if(gui-&gt;guipoints)</a>
<a name="ln1874">    {</a>
<a name="ln1875">      dt_masks_dynbuf_add(gui-&gt;guipoints, pzx * darktable.develop-&gt;preview_pipe-&gt;backbuf_width);</a>
<a name="ln1876">      dt_masks_dynbuf_add(gui-&gt;guipoints, pzy * darktable.develop-&gt;preview_pipe-&gt;backbuf_height);</a>
<a name="ln1877">      const float border = dt_masks_dynbuf_get(gui-&gt;guipoints_payload, -4);</a>
<a name="ln1878">      const float hardness = dt_masks_dynbuf_get(gui-&gt;guipoints_payload, -3);</a>
<a name="ln1879">      const float density = dt_masks_dynbuf_get(gui-&gt;guipoints_payload, -2);</a>
<a name="ln1880">      dt_masks_dynbuf_add(gui-&gt;guipoints_payload, border);</a>
<a name="ln1881">      dt_masks_dynbuf_add(gui-&gt;guipoints_payload, hardness);</a>
<a name="ln1882">      dt_masks_dynbuf_add(gui-&gt;guipoints_payload, density);</a>
<a name="ln1883">      dt_masks_dynbuf_add(gui-&gt;guipoints_payload, pressure);</a>
<a name="ln1884">      gui-&gt;guipoints_count++;</a>
<a name="ln1885">    }</a>
<a name="ln1886">    dt_control_queue_redraw_center();</a>
<a name="ln1887">    return 1;</a>
<a name="ln1888">  }</a>
<a name="ln1889">  else if(gui-&gt;point_dragging &gt;= 0)</a>
<a name="ln1890">  {</a>
<a name="ln1891">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1892">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1893">    float pts[2] = { pzx * wd, pzy * ht };</a>
<a name="ln1894">    dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln1895">    dt_masks_point_brush_t *bzpt</a>
<a name="ln1896">        = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, gui-&gt;point_dragging);</a>
<a name="ln1897">    pzx = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln1898">    pzy = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln1899">    bzpt-&gt;ctrl1[0] += pzx - bzpt-&gt;corner[0];</a>
<a name="ln1900">    bzpt-&gt;ctrl2[0] += pzx - bzpt-&gt;corner[0];</a>
<a name="ln1901">    bzpt-&gt;ctrl1[1] += pzy - bzpt-&gt;corner[1];</a>
<a name="ln1902">    bzpt-&gt;ctrl2[1] += pzy - bzpt-&gt;corner[1];</a>
<a name="ln1903">    bzpt-&gt;corner[0] = pzx;</a>
<a name="ln1904">    bzpt-&gt;corner[1] = pzy;</a>
<a name="ln1905">    _brush_init_ctrl_points(form);</a>
<a name="ln1906">    // we recreate the form points</a>
<a name="ln1907">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln1908">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln1909">    dt_control_queue_redraw_center();</a>
<a name="ln1910">    return 1;</a>
<a name="ln1911">  }</a>
<a name="ln1912">  else if(gui-&gt;seg_dragging &gt;= 0)</a>
<a name="ln1913">  {</a>
<a name="ln1914">    // we get point0 new values</a>
<a name="ln1915">    int pos2 = (gui-&gt;seg_dragging + 1) % g_list_length(form-&gt;points);</a>
<a name="ln1916">    dt_masks_point_brush_t *point</a>
<a name="ln1917">        = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, gui-&gt;seg_dragging);</a>
<a name="ln1918">    dt_masks_point_brush_t *point2 = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, pos2);</a>
<a name="ln1919">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1920">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1921">    float pts[2] = { pzx * wd + gui-&gt;dx, pzy * ht + gui-&gt;dy };</a>
<a name="ln1922">    dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln1923">    float dx = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth - point-&gt;corner[0];</a>
<a name="ln1924">    float dy = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight - point-&gt;corner[1];</a>
<a name="ln1925"> </a>
<a name="ln1926">    // we move all points</a>
<a name="ln1927">    point-&gt;corner[0] += dx;</a>
<a name="ln1928">    point-&gt;corner[1] += dy;</a>
<a name="ln1929">    point-&gt;ctrl1[0] += dx;</a>
<a name="ln1930">    point-&gt;ctrl1[1] += dy;</a>
<a name="ln1931">    point-&gt;ctrl2[0] += dx;</a>
<a name="ln1932">    point-&gt;ctrl2[1] += dy;</a>
<a name="ln1933">    point2-&gt;corner[0] += dx;</a>
<a name="ln1934">    point2-&gt;corner[1] += dy;</a>
<a name="ln1935">    point2-&gt;ctrl1[0] += dx;</a>
<a name="ln1936">    point2-&gt;ctrl1[1] += dy;</a>
<a name="ln1937">    point2-&gt;ctrl2[0] += dx;</a>
<a name="ln1938">    point2-&gt;ctrl2[1] += dy;</a>
<a name="ln1939"> </a>
<a name="ln1940">    _brush_init_ctrl_points(form);</a>
<a name="ln1941"> </a>
<a name="ln1942">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln1943"> </a>
<a name="ln1944">    // we recreate the form points</a>
<a name="ln1945">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln1946">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln1947"> </a>
<a name="ln1948">    dt_control_queue_redraw_center();</a>
<a name="ln1949">    return 1;</a>
<a name="ln1950">  }</a>
<a name="ln1951">  else if(gui-&gt;feather_dragging &gt;= 0)</a>
<a name="ln1952">  {</a>
<a name="ln1953">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1954">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1955">    float pts[2] = { pzx * wd, pzy * ht };</a>
<a name="ln1956">    dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln1957">    dt_masks_point_brush_t *point</a>
<a name="ln1958">        = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, gui-&gt;feather_dragging);</a>
<a name="ln1959"> </a>
<a name="ln1960">    int p1x, p1y, p2x, p2y;</a>
<a name="ln1961">    _brush_feather_to_ctrl(point-&gt;corner[0] * darktable.develop-&gt;preview_pipe-&gt;iwidth,</a>
<a name="ln1962">                           point-&gt;corner[1] * darktable.develop-&gt;preview_pipe-&gt;iheight, pts[0], pts[1], &amp;p1x,</a>
<a name="ln1963">                           &amp;p1y, &amp;p2x, &amp;p2y, TRUE);</a>
<a name="ln1964">    point-&gt;ctrl1[0] = (float)p1x / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln1965">    point-&gt;ctrl1[1] = (float)p1y / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln1966">    point-&gt;ctrl2[0] = (float)p2x / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln1967">    point-&gt;ctrl2[1] = (float)p2y / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln1968">    point-&gt;state = DT_MASKS_POINT_STATE_USER;</a>
<a name="ln1969"> </a>
<a name="ln1970">    _brush_init_ctrl_points(form);</a>
<a name="ln1971">    // we recreate the form points</a>
<a name="ln1972">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln1973">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln1974">    dt_control_queue_redraw_center();</a>
<a name="ln1975">    return 1;</a>
<a name="ln1976">  }</a>
<a name="ln1977">  else if(gui-&gt;point_border_dragging &gt;= 0)</a>
<a name="ln1978">  {</a>
<a name="ln1979">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1980">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1981"> </a>
<a name="ln1982">    int k = gui-&gt;point_border_dragging;</a>
<a name="ln1983"> </a>
<a name="ln1984">    // now we want to know the position reflected on actual corner/border segment</a>
<a name="ln1985">    float a = (gpt-&gt;border[k * 6 + 1] - gpt-&gt;points[k * 6 + 3])</a>
<a name="ln1986">              / (float)(gpt-&gt;border[k * 6] - gpt-&gt;points[k * 6 + 2]);</a>
<a name="ln1987">    float b = gpt-&gt;points[k * 6 + 3] - a * gpt-&gt;points[k * 6 + 2];</a>
<a name="ln1988"> </a>
<a name="ln1989">    float pts[2];</a>
<a name="ln1990">    pts[0] = (a * pzy * ht + pzx * wd - b * a) / (a * a + 1.0);</a>
<a name="ln1991">    pts[1] = a * pts[0] + b;</a>
<a name="ln1992"> </a>
<a name="ln1993">    dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln1994"> </a>
<a name="ln1995">    dt_masks_point_brush_t *point = (dt_masks_point_brush_t *)g_list_nth_data(form-&gt;points, k);</a>
<a name="ln1996">    float nx = point-&gt;corner[0] * darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln1997">    float ny = point-&gt;corner[1] * darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln1998">    float nr = sqrtf((pts[0] - nx) * (pts[0] - nx) + (pts[1] - ny) * (pts[1] - ny));</a>
<a name="ln1999">    float bdr = nr / fminf(darktable.develop-&gt;preview_pipe-&gt;iwidth, darktable.develop-&gt;preview_pipe-&gt;iheight);</a>
<a name="ln2000"> </a>
<a name="ln2001">    point-&gt;border[0] = point-&gt;border[1] = bdr;</a>
<a name="ln2002"> </a>
<a name="ln2003">    // we recreate the form points</a>
<a name="ln2004">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln2005">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln2006">    dt_control_queue_redraw_center();</a>
<a name="ln2007">    return 1;</a>
<a name="ln2008">  }</a>
<a name="ln2009">  else if(gui-&gt;form_dragging || gui-&gt;source_dragging)</a>
<a name="ln2010">  {</a>
<a name="ln2011">    dt_control_queue_redraw_center();</a>
<a name="ln2012">    return 1;</a>
<a name="ln2013">  }</a>
<a name="ln2014"> </a>
<a name="ln2015">  gui-&gt;form_selected = FALSE;</a>
<a name="ln2016">  gui-&gt;border_selected = FALSE;</a>
<a name="ln2017">  gui-&gt;source_selected = FALSE;</a>
<a name="ln2018">  gui-&gt;feather_selected = -1;</a>
<a name="ln2019">  gui-&gt;point_selected = -1;</a>
<a name="ln2020">  gui-&gt;seg_selected = -1;</a>
<a name="ln2021">  gui-&gt;point_border_selected = -1;</a>
<a name="ln2022">  // are we near a point or feather ?</a>
<a name="ln2023">  guint nb = g_list_length(form-&gt;points);</a>
<a name="ln2024"> </a>
<a name="ln2025">  pzx *= darktable.develop-&gt;preview_pipe-&gt;backbuf_width,</a>
<a name="ln2026">      pzy *= darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln2027"> </a>
<a name="ln2028">  if((gui-&gt;group_selected == index) &amp;&amp; gui-&gt;point_edited &gt;= 0)</a>
<a name="ln2029">  {</a>
<a name="ln2030">    int k = gui-&gt;point_edited;</a>
<a name="ln2031">    // we only select feather if the point is not &quot;sharp&quot;</a>
<a name="ln2032">    if(gpt-&gt;points[k * 6 + 2] != gpt-&gt;points[k * 6 + 4] &amp;&amp; gpt-&gt;points[k * 6 + 3] != gpt-&gt;points[k * 6 + 5])</a>
<a name="ln2033">    {</a>
<a name="ln2034">      int ffx, ffy;</a>
<a name="ln2035">      _brush_ctrl2_to_feather(gpt-&gt;points[k * 6 + 2], gpt-&gt;points[k * 6 + 3], gpt-&gt;points[k * 6 + 4],</a>
<a name="ln2036">                              gpt-&gt;points[k * 6 + 5], &amp;ffx, &amp;ffy, TRUE);</a>
<a name="ln2037">      if(pzx - ffx &gt; -as &amp;&amp; pzx - ffx &lt; as &amp;&amp; pzy - ffy &gt; -as &amp;&amp; pzy - ffy &lt; as)</a>
<a name="ln2038">      {</a>
<a name="ln2039">        gui-&gt;feather_selected = k;</a>
<a name="ln2040">        dt_control_queue_redraw_center();</a>
<a name="ln2041">        return 1;</a>
<a name="ln2042">      }</a>
<a name="ln2043">    }</a>
<a name="ln2044">    // corner ??</a>
<a name="ln2045">    if(pzx - gpt-&gt;points[k * 6 + 2] &gt; -as &amp;&amp; pzx - gpt-&gt;points[k * 6 + 2] &lt; as</a>
<a name="ln2046">       &amp;&amp; pzy - gpt-&gt;points[k * 6 + 3] &gt; -as &amp;&amp; pzy - gpt-&gt;points[k * 6 + 3] &lt; as)</a>
<a name="ln2047">    {</a>
<a name="ln2048">      gui-&gt;point_selected = k;</a>
<a name="ln2049">      dt_control_queue_redraw_center();</a>
<a name="ln2050">      return 1;</a>
<a name="ln2051">    }</a>
<a name="ln2052">  }</a>
<a name="ln2053"> </a>
<a name="ln2054">  for(int k = 0; k &lt; nb; k++)</a>
<a name="ln2055">  {</a>
<a name="ln2056">    // corner ??</a>
<a name="ln2057">    if(pzx - gpt-&gt;points[k * 6 + 2] &gt; -as &amp;&amp; pzx - gpt-&gt;points[k * 6 + 2] &lt; as</a>
<a name="ln2058">       &amp;&amp; pzy - gpt-&gt;points[k * 6 + 3] &gt; -as &amp;&amp; pzy - gpt-&gt;points[k * 6 + 3] &lt; as)</a>
<a name="ln2059">    {</a>
<a name="ln2060">      gui-&gt;point_selected = k;</a>
<a name="ln2061">      dt_control_queue_redraw_center();</a>
<a name="ln2062">      return 1;</a>
<a name="ln2063">    }</a>
<a name="ln2064"> </a>
<a name="ln2065">    // border corner ??</a>
<a name="ln2066">    if(pzx - gpt-&gt;border[k * 6] &gt; -as &amp;&amp; pzx - gpt-&gt;border[k * 6] &lt; as &amp;&amp; pzy - gpt-&gt;border[k * 6 + 1] &gt; -as</a>
<a name="ln2067">       &amp;&amp; pzy - gpt-&gt;border[k * 6 + 1] &lt; as)</a>
<a name="ln2068">    {</a>
<a name="ln2069">      gui-&gt;point_border_selected = k;</a>
<a name="ln2070">      dt_control_queue_redraw_center();</a>
<a name="ln2071">      return 1;</a>
<a name="ln2072">    }</a>
<a name="ln2073">  }</a>
<a name="ln2074"> </a>
<a name="ln2075">  // are we inside the form or the borders or near a segment ???</a>
<a name="ln2076">  int in, inb, near, ins;</a>
<a name="ln2077">  dt_brush_get_distance(pzx, (int)pzy, as, gui, index, nb, &amp;in, &amp;inb, &amp;near, &amp;ins);</a>
<a name="ln2078">  gui-&gt;seg_selected = near;</a>
<a name="ln2079">  if(near &lt; 0)</a>
<a name="ln2080">  {</a>
<a name="ln2081">    if(ins)</a>
<a name="ln2082">    {</a>
<a name="ln2083">      gui-&gt;form_selected = TRUE;</a>
<a name="ln2084">      gui-&gt;source_selected = TRUE;</a>
<a name="ln2085">    }</a>
<a name="ln2086">    else if(inb)</a>
<a name="ln2087">    {</a>
<a name="ln2088">      gui-&gt;form_selected = TRUE;</a>
<a name="ln2089">      gui-&gt;border_selected = TRUE;</a>
<a name="ln2090">    }</a>
<a name="ln2091">    else if(in)</a>
<a name="ln2092">    {</a>
<a name="ln2093">      gui-&gt;form_selected = TRUE;</a>
<a name="ln2094">    }</a>
<a name="ln2095">  }</a>
<a name="ln2096">  dt_control_queue_redraw_center();</a>
<a name="ln2097">  if(!gui-&gt;form_selected &amp;&amp; !gui-&gt;border_selected &amp;&amp; gui-&gt;seg_selected &lt; 0) return 0;</a>
<a name="ln2098">  if(gui-&gt;edit_mode != DT_MASKS_EDIT_FULL) return 0;</a>
<a name="ln2099">  return 1;</a>
<a name="ln2100">}</a>
<a name="ln2101"> </a>
<a name="ln2102">static void dt_brush_events_post_expose(cairo_t *cr, float zoom_scale, dt_masks_form_gui_t *gui, int index,</a>
<a name="ln2103">                                        int nb)</a>
<a name="ln2104">{</a>
<a name="ln2105">  double dashed[] = { 4.0, 4.0 };</a>
<a name="ln2106">  dashed[0] /= zoom_scale;</a>
<a name="ln2107">  dashed[1] /= zoom_scale;</a>
<a name="ln2108">  int len = sizeof(dashed) / sizeof(dashed[0]);</a>
<a name="ln2109"> </a>
<a name="ln2110">  if(!gui) return;</a>
<a name="ln2111">  dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln2112">  if(!gpt) return;</a>
<a name="ln2113">  float dx = 0, dy = 0, dxs = 0, dys = 0;</a>
<a name="ln2114">  if((gui-&gt;group_selected == index) &amp;&amp; gui-&gt;form_dragging)</a>
<a name="ln2115">  {</a>
<a name="ln2116">    dx = gui-&gt;posx + gui-&gt;dx - gpt-&gt;points[2];</a>
<a name="ln2117">    dy = gui-&gt;posy + gui-&gt;dy - gpt-&gt;points[3];</a>
<a name="ln2118">  }</a>
<a name="ln2119">  if((gui-&gt;group_selected == index) &amp;&amp; gui-&gt;source_dragging)</a>
<a name="ln2120">  {</a>
<a name="ln2121">    dxs = gui-&gt;posx + gui-&gt;dx - gpt-&gt;source[2];</a>
<a name="ln2122">    dys = gui-&gt;posy + gui-&gt;dy - gpt-&gt;source[3];</a>
<a name="ln2123">  }</a>
<a name="ln2124"> </a>
<a name="ln2125">  // in creation mode</a>
<a name="ln2126">  if(gui-&gt;creation)</a>
<a name="ln2127">  {</a>
<a name="ln2128">    float wd = darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln2129">    float ht = darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln2130"> </a>
<a name="ln2131">    if(gui-&gt;guipoints_count == 0)</a>
<a name="ln2132">    {</a>
<a name="ln2133">      dt_masks_form_t *form = darktable.develop-&gt;form_visible;</a>
<a name="ln2134">      if(!form) return;</a>
<a name="ln2135"> </a>
<a name="ln2136">      float masks_border;</a>
<a name="ln2137">      if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln2138">        masks_border = MIN(dt_conf_get_float(&quot;plugins/darkroom/spots/brush_border&quot;), 0.5f);</a>
<a name="ln2139">      else</a>
<a name="ln2140">        masks_border = MIN(dt_conf_get_float(&quot;plugins/darkroom/masks/brush/border&quot;), 0.5f);</a>
<a name="ln2141"> </a>
<a name="ln2142">      float masks_hardness;</a>
<a name="ln2143">      if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln2144">        masks_hardness = MIN(dt_conf_get_float(&quot;plugins/darkroom/spots/brush_hardness&quot;), 1.0f);</a>
<a name="ln2145">      else</a>
<a name="ln2146">        masks_hardness = MIN(dt_conf_get_float(&quot;plugins/darkroom/masks/brush/hardness&quot;), 1.0f);</a>
<a name="ln2147"> </a>
<a name="ln2148">      float masks_density;</a>
<a name="ln2149">      if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln2150">        masks_density = MIN(dt_conf_get_float(&quot;plugins/darkroom/spots/brush_density&quot;), 1.0f);</a>
<a name="ln2151">      else</a>
<a name="ln2152">        masks_density = MIN(dt_conf_get_float(&quot;plugins/darkroom/masks/brush/density&quot;), 1.0f);</a>
<a name="ln2153"> </a>
<a name="ln2154">      float radius1 = masks_border * masks_hardness * MIN(wd, ht);</a>
<a name="ln2155">      float radius2 = masks_border * MIN(wd, ht);</a>
<a name="ln2156"> </a>
<a name="ln2157">      float xpos, ypos;</a>
<a name="ln2158">      if((gui-&gt;posx == -1.f &amp;&amp; gui-&gt;posy == -1.f) || gui-&gt;mouse_leaved_center)</a>
<a name="ln2159">      {</a>
<a name="ln2160">        xpos = (.5f + dt_control_get_dev_zoom_x()) * darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln2161">        ypos = (.5f + dt_control_get_dev_zoom_y()) * darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln2162">      }</a>
<a name="ln2163">      else</a>
<a name="ln2164">      {</a>
<a name="ln2165">        xpos = gui-&gt;posx;</a>
<a name="ln2166">        ypos = gui-&gt;posy;</a>
<a name="ln2167">      }</a>
<a name="ln2168"> </a>
<a name="ln2169">      cairo_save(cr);</a>
<a name="ln2170">      dt_gui_gtk_set_source_rgba(cr, DT_GUI_COLOR_BRUSH_CURSOR, masks_density);</a>
<a name="ln2171">      if(masks_density &lt; 1.0) cairo_set_line_width(cr, cairo_get_line_width(cr) * .8);</a>
<a name="ln2172">      cairo_arc(cr, xpos, ypos, radius1, 0, 2.0 * M_PI);</a>
<a name="ln2173">      cairo_fill_preserve(cr);</a>
<a name="ln2174">      cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln2175">      cairo_stroke(cr);</a>
<a name="ln2176">      cairo_set_dash(cr, dashed, len, 0);</a>
<a name="ln2177">      cairo_arc(cr, xpos, ypos, radius2, 0, 2.0 * M_PI);</a>
<a name="ln2178">      cairo_stroke(cr);</a>
<a name="ln2179"> </a>
<a name="ln2180">      if(form-&gt;type &amp; DT_MASKS_CLONE)</a>
<a name="ln2181">      {</a>
<a name="ln2182">        float x = 0.f, y = 0.f;</a>
<a name="ln2183">        dt_masks_calculate_source_pos_value(gui, DT_MASKS_BRUSH, xpos, ypos, xpos, ypos, &amp;x, &amp;y, FALSE);</a>
<a name="ln2184">        dt_masks_draw_clone_source_pos(cr, zoom_scale, x, y);</a>
<a name="ln2185">      }</a>
<a name="ln2186"> </a>
<a name="ln2187">      cairo_restore(cr);</a>
<a name="ln2188">    }</a>
<a name="ln2189">    else</a>
<a name="ln2190">    {</a>
<a name="ln2191">      float masks_border, masks_hardness, masks_density;</a>
<a name="ln2192">      float radius, oldradius, opacity, oldopacity, pressure;</a>
<a name="ln2193">      int stroked = 1;</a>
<a name="ln2194"> </a>
<a name="ln2195">      const float *guipoints = dt_masks_dynbuf_buffer(gui-&gt;guipoints);</a>
<a name="ln2196">      const float *guipoints_payload = dt_masks_dynbuf_buffer(gui-&gt;guipoints_payload);</a>
<a name="ln2197"> </a>
<a name="ln2198">      cairo_save(cr);</a>
<a name="ln2199">      cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);</a>
<a name="ln2200">      cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln2201">      float linewidth = cairo_get_line_width(cr);</a>
<a name="ln2202">      masks_border = guipoints_payload[0];</a>
<a name="ln2203">      masks_hardness = guipoints_payload[1];</a>
<a name="ln2204">      masks_density = guipoints_payload[2];</a>
<a name="ln2205">      pressure = guipoints_payload[3];</a>
<a name="ln2206"> </a>
<a name="ln2207">      switch(gui-&gt;pressure_sensitivity)</a>
<a name="ln2208">      {</a>
<a name="ln2209">        case DT_MASKS_PRESSURE_HARDNESS_ABS:</a>
<a name="ln2210">          masks_hardness = MAX(0.05f, pressure);</a>
<a name="ln2211">          break;</a>
<a name="ln2212">        case DT_MASKS_PRESSURE_HARDNESS_REL:</a>
<a name="ln2213">          masks_hardness = MAX(0.05f, masks_hardness * pressure);</a>
<a name="ln2214">          break;</a>
<a name="ln2215">        case DT_MASKS_PRESSURE_OPACITY_ABS:</a>
<a name="ln2216">          masks_density = MAX(0.05f, pressure);</a>
<a name="ln2217">          break;</a>
<a name="ln2218">        case DT_MASKS_PRESSURE_OPACITY_REL:</a>
<a name="ln2219">          masks_density = MAX(0.05f, masks_density * pressure);</a>
<a name="ln2220">          break;</a>
<a name="ln2221">        case DT_MASKS_PRESSURE_BRUSHSIZE_REL:</a>
<a name="ln2222">          masks_border = MAX(0.005f, masks_border * pressure);</a>
<a name="ln2223">          break;</a>
<a name="ln2224">        default:</a>
<a name="ln2225">        case DT_MASKS_PRESSURE_OFF:</a>
<a name="ln2226">          // ignore pressure value</a>
<a name="ln2227">          break;</a>
<a name="ln2228">      }</a>
<a name="ln2229"> </a>
<a name="ln2230">      radius = oldradius = masks_border * masks_hardness * MIN(wd, ht);</a>
<a name="ln2231">      opacity = oldopacity = masks_density;</a>
<a name="ln2232"> </a>
<a name="ln2233">      cairo_set_line_width(cr, 2 * radius);</a>
<a name="ln2234">      dt_gui_gtk_set_source_rgba(cr, DT_GUI_COLOR_BRUSH_TRACE, opacity);</a>
<a name="ln2235"> </a>
<a name="ln2236">      cairo_move_to(cr, guipoints[0], guipoints[1]);</a>
<a name="ln2237">      for(int i = 1; i &lt; gui-&gt;guipoints_count; i++)</a>
<a name="ln2238">      {</a>
<a name="ln2239">        cairo_line_to(cr, guipoints[i * 2], guipoints[i * 2 + 1]);</a>
<a name="ln2240">        stroked = 0;</a>
<a name="ln2241">        masks_border = guipoints_payload[i * 4];</a>
<a name="ln2242">        masks_hardness = guipoints_payload[i * 4 + 1];</a>
<a name="ln2243">        masks_density = guipoints_payload[i * 4 + 2];</a>
<a name="ln2244">        pressure = guipoints_payload[i * 4 + 3];</a>
<a name="ln2245"> </a>
<a name="ln2246">        switch(gui-&gt;pressure_sensitivity)</a>
<a name="ln2247">        {</a>
<a name="ln2248">          case DT_MASKS_PRESSURE_HARDNESS_ABS:</a>
<a name="ln2249">            masks_hardness = MAX(0.05f, pressure);</a>
<a name="ln2250">            break;</a>
<a name="ln2251">          case DT_MASKS_PRESSURE_HARDNESS_REL:</a>
<a name="ln2252">            masks_hardness = MAX(0.05f, masks_hardness * pressure);</a>
<a name="ln2253">            break;</a>
<a name="ln2254">          case DT_MASKS_PRESSURE_OPACITY_ABS:</a>
<a name="ln2255">            masks_density = MAX(0.05f, pressure);</a>
<a name="ln2256">            break;</a>
<a name="ln2257">          case DT_MASKS_PRESSURE_OPACITY_REL:</a>
<a name="ln2258">            masks_density = MAX(0.05f, masks_density * pressure);</a>
<a name="ln2259">            break;</a>
<a name="ln2260">          case DT_MASKS_PRESSURE_BRUSHSIZE_REL:</a>
<a name="ln2261">            masks_border = MAX(0.005f, masks_border * pressure);</a>
<a name="ln2262">            break;</a>
<a name="ln2263">          default:</a>
<a name="ln2264">          case DT_MASKS_PRESSURE_OFF:</a>
<a name="ln2265">            // ignore pressure value</a>
<a name="ln2266">            break;</a>
<a name="ln2267">        }</a>
<a name="ln2268"> </a>
<a name="ln2269">        radius = masks_border * masks_hardness * MIN(wd, ht);</a>
<a name="ln2270">        opacity = masks_density;</a>
<a name="ln2271"> </a>
<a name="ln2272">        if(radius != oldradius || opacity != oldopacity)</a>
<a name="ln2273">        {</a>
<a name="ln2274">          cairo_stroke(cr);</a>
<a name="ln2275">          stroked = 1;</a>
<a name="ln2276">          cairo_set_line_width(cr, 2 * radius);</a>
<a name="ln2277">          dt_gui_gtk_set_source_rgba(cr, DT_GUI_COLOR_BRUSH_TRACE, opacity);</a>
<a name="ln2278">          oldradius = radius;</a>
<a name="ln2279">          oldopacity = opacity;</a>
<a name="ln2280">          cairo_move_to(cr, guipoints[i * 2], guipoints[i * 2 + 1]);</a>
<a name="ln2281">        }</a>
<a name="ln2282">      }</a>
<a name="ln2283">      if(!stroked) cairo_stroke(cr);</a>
<a name="ln2284"> </a>
<a name="ln2285">      cairo_set_line_width(cr, linewidth);</a>
<a name="ln2286">      dt_gui_gtk_set_source_rgba(cr, DT_GUI_COLOR_BRUSH_CURSOR, opacity);</a>
<a name="ln2287">      if(opacity &lt; 1.0) cairo_set_line_width(cr, cairo_get_line_width(cr) * .8);</a>
<a name="ln2288">      cairo_arc(cr, guipoints[2 * (gui-&gt;guipoints_count - 1)],</a>
<a name="ln2289">                guipoints[2 * (gui-&gt;guipoints_count - 1) + 1], radius, 0, 2.0 * M_PI);</a>
<a name="ln2290">      cairo_fill_preserve(cr);</a>
<a name="ln2291">      cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln2292">      cairo_stroke(cr);</a>
<a name="ln2293">      cairo_set_dash(cr, dashed, len, 0);</a>
<a name="ln2294">      cairo_arc(cr, guipoints[2 * (gui-&gt;guipoints_count - 1)],</a>
<a name="ln2295">                guipoints[2 * (gui-&gt;guipoints_count - 1) + 1], masks_border * MIN(wd, ht), 0,</a>
<a name="ln2296">                2.0 * M_PI);</a>
<a name="ln2297">      cairo_stroke(cr);</a>
<a name="ln2298"> </a>
<a name="ln2299">      if(darktable.develop-&gt;form_visible &amp;&amp; (darktable.develop-&gt;form_visible-&gt;type &amp; DT_MASKS_CLONE))</a>
<a name="ln2300">      {</a>
<a name="ln2301">        const int i = gui-&gt;guipoints_count - 1;</a>
<a name="ln2302">        float x = 0.f, y = 0.f;</a>
<a name="ln2303">        dt_masks_calculate_source_pos_value(gui, DT_MASKS_BRUSH, guipoints[0], guipoints[1], guipoints[i * 2],</a>
<a name="ln2304">                                            guipoints[i * 2 + 1], &amp;x, &amp;y, TRUE);</a>
<a name="ln2305">        dt_masks_draw_clone_source_pos(cr, zoom_scale, x, y);</a>
<a name="ln2306">      }</a>
<a name="ln2307"> </a>
<a name="ln2308">      cairo_restore(cr);</a>
<a name="ln2309">    }</a>
<a name="ln2310">    return;</a>
<a name="ln2311">  }</a>
<a name="ln2312"> </a>
<a name="ln2313">  // draw path</a>
<a name="ln2314">  if(gpt-&gt;points_count &gt; nb * 3 + 2)</a>
<a name="ln2315">  {</a>
<a name="ln2316">    cairo_set_dash(cr, dashed, 0, 0);</a>
<a name="ln2317"> </a>
<a name="ln2318">    cairo_move_to(cr, gpt-&gt;points[nb * 6] + dx, gpt-&gt;points[nb * 6 + 1] + dy);</a>
<a name="ln2319">    int seg = 1, seg2 = 0;</a>
<a name="ln2320">    for(int i = nb * 3; i &lt; gpt-&gt;points_count; i++)</a>
<a name="ln2321">    {</a>
<a name="ln2322">      cairo_line_to(cr, gpt-&gt;points[i * 2] + dx, gpt-&gt;points[i * 2 + 1] + dy);</a>
<a name="ln2323">      // we decide to highlight the form segment by segment</a>
<a name="ln2324">      if(gpt-&gt;points[i * 2 + 1] == gpt-&gt;points[seg * 6 + 3] &amp;&amp; gpt-&gt;points[i * 2] == gpt-&gt;points[seg * 6 + 2])</a>
<a name="ln2325">      {</a>
<a name="ln2326">        // this is the end of the last segment, so we have to draw it</a>
<a name="ln2327">        if((gui-&gt;group_selected == index)</a>
<a name="ln2328">           &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging || gui-&gt;seg_selected == seg2))</a>
<a name="ln2329">          cairo_set_line_width(cr, 5.0 / zoom_scale);</a>
<a name="ln2330">        else</a>
<a name="ln2331">          cairo_set_line_width(cr, 3.0 / zoom_scale);</a>
<a name="ln2332">        cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln2333">        cairo_stroke_preserve(cr);</a>
<a name="ln2334">        if((gui-&gt;group_selected == index)</a>
<a name="ln2335">           &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging || gui-&gt;seg_selected == seg2))</a>
<a name="ln2336">          cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln2337">        else</a>
<a name="ln2338">          cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln2339">        cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln2340">        cairo_stroke(cr);</a>
<a name="ln2341">        // and we update the segment number</a>
<a name="ln2342">        seg = (seg + 1) % nb;</a>
<a name="ln2343">        seg2++;</a>
<a name="ln2344">        cairo_move_to(cr, gpt-&gt;points[i * 2] + dx, gpt-&gt;points[i * 2 + 1] + dy);</a>
<a name="ln2345">      }</a>
<a name="ln2346">    }</a>
<a name="ln2347">  }</a>
<a name="ln2348"> </a>
<a name="ln2349">  // draw corners</a>
<a name="ln2350">  float anchor_size;</a>
<a name="ln2351">  if(gui-&gt;group_selected == index &amp;&amp; gpt-&gt;points_count &gt; nb * 3 + 2)</a>
<a name="ln2352">  {</a>
<a name="ln2353">    for(int k = 0; k &lt; nb; k++)</a>
<a name="ln2354">    {</a>
<a name="ln2355">      if(k == gui-&gt;point_dragging || k == gui-&gt;point_selected)</a>
<a name="ln2356">      {</a>
<a name="ln2357">        anchor_size = 7.0f / zoom_scale;</a>
<a name="ln2358">      }</a>
<a name="ln2359">      else</a>
<a name="ln2360">      {</a>
<a name="ln2361">        anchor_size = 5.0f / zoom_scale;</a>
<a name="ln2362">      }</a>
<a name="ln2363">      cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln2364">      cairo_rectangle(cr, gpt-&gt;points[k * 6 + 2] - (anchor_size * 0.5) + dx,</a>
<a name="ln2365">                      gpt-&gt;points[k * 6 + 3] - (anchor_size * 0.5) + dy, anchor_size, anchor_size);</a>
<a name="ln2366">      cairo_fill_preserve(cr);</a>
<a name="ln2367"> </a>
<a name="ln2368">      if((gui-&gt;group_selected == index) &amp;&amp; (k == gui-&gt;point_dragging || k == gui-&gt;point_selected))</a>
<a name="ln2369">        cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln2370">      else if((gui-&gt;group_selected == index)</a>
<a name="ln2371">              &amp;&amp; ((k == 0 || k == nb) &amp;&amp; gui-&gt;creation &amp;&amp; gui-&gt;creation_closing_form))</a>
<a name="ln2372">        cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln2373">      else</a>
<a name="ln2374">        cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln2375">      cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln2376">      cairo_stroke(cr);</a>
<a name="ln2377">    }</a>
<a name="ln2378">  }</a>
<a name="ln2379"> </a>
<a name="ln2380">  // draw feathers</a>
<a name="ln2381">  if((gui-&gt;group_selected == index) &amp;&amp; gui-&gt;point_edited &gt;= 0)</a>
<a name="ln2382">  {</a>
<a name="ln2383">    int k = gui-&gt;point_edited;</a>
<a name="ln2384">    // uncomment this part if you want to see &quot;real&quot; control points</a>
<a name="ln2385">    /*cairo_move_to(cr, gui-&gt;points[k*6+2]+dx,gui-&gt;points[k*6+3]+dy);</a>
<a name="ln2386">    cairo_line_to(cr, gui-&gt;points[k*6]+dx,gui-&gt;points[k*6+1]+dy);</a>
<a name="ln2387">    cairo_stroke(cr);</a>
<a name="ln2388">    cairo_move_to(cr, gui-&gt;points[k*6+2]+dx,gui-&gt;points[k*6+3]+dy);</a>
<a name="ln2389">    cairo_line_to(cr, gui-&gt;points[k*6+4]+dx,gui-&gt;points[k*6+5]+dy);</a>
<a name="ln2390">    cairo_stroke(cr);*/</a>
<a name="ln2391">    int ffx, ffy;</a>
<a name="ln2392">    _brush_ctrl2_to_feather(gpt-&gt;points[k * 6 + 2] + dx, gpt-&gt;points[k * 6 + 3] + dy,</a>
<a name="ln2393">                            gpt-&gt;points[k * 6 + 4] + dx, gpt-&gt;points[k * 6 + 5] + dy, &amp;ffx, &amp;ffy, TRUE);</a>
<a name="ln2394">    cairo_move_to(cr, gpt-&gt;points[k * 6 + 2] + dx, gpt-&gt;points[k * 6 + 3] + dy);</a>
<a name="ln2395">    cairo_line_to(cr, ffx, ffy);</a>
<a name="ln2396">    cairo_set_line_width(cr, 1.5 / zoom_scale);</a>
<a name="ln2397">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln2398">    cairo_stroke_preserve(cr);</a>
<a name="ln2399">    cairo_set_line_width(cr, 0.75 / zoom_scale);</a>
<a name="ln2400">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln2401">    cairo_stroke(cr);</a>
<a name="ln2402"> </a>
<a name="ln2403">    if((gui-&gt;group_selected == index) &amp;&amp; (k == gui-&gt;feather_dragging || k == gui-&gt;feather_selected))</a>
<a name="ln2404">      cairo_arc(cr, ffx, ffy, 3.0f / zoom_scale, 0, 2.0 * M_PI);</a>
<a name="ln2405">    else</a>
<a name="ln2406">      cairo_arc(cr, ffx, ffy, 1.5f / zoom_scale, 0, 2.0 * M_PI);</a>
<a name="ln2407">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln2408">    cairo_fill_preserve(cr);</a>
<a name="ln2409"> </a>
<a name="ln2410">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln2411">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln2412">    cairo_stroke(cr);</a>
<a name="ln2413">  }</a>
<a name="ln2414"> </a>
<a name="ln2415">  // draw border and corners</a>
<a name="ln2416">  if((gui-&gt;group_selected == index) &amp;&amp; gpt-&gt;border_count &gt; nb * 3 + 2)</a>
<a name="ln2417">  {</a>
<a name="ln2418"> </a>
<a name="ln2419"> </a>
<a name="ln2420">    cairo_move_to(cr, gpt-&gt;border[nb * 6] + dx, gpt-&gt;border[nb * 6 + 1] + dy);</a>
<a name="ln2421"> </a>
<a name="ln2422">    for(int i = nb * 3 + 1; i &lt; gpt-&gt;border_count; i++)</a>
<a name="ln2423">    {</a>
<a name="ln2424">      cairo_line_to(cr, gpt-&gt;border[i * 2] + dx, gpt-&gt;border[i * 2 + 1] + dy);</a>
<a name="ln2425">    }</a>
<a name="ln2426">    // we execute the drawing</a>
<a name="ln2427">    if(gui-&gt;border_selected)</a>
<a name="ln2428">      cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln2429">    else</a>
<a name="ln2430">      cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln2431">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln2432">    cairo_set_dash(cr, dashed, len, 0);</a>
<a name="ln2433">    cairo_stroke_preserve(cr);</a>
<a name="ln2434">    if(gui-&gt;border_selected)</a>
<a name="ln2435">      cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln2436">    else</a>
<a name="ln2437">      cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln2438">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln2439">    cairo_set_dash(cr, dashed, len, 4);</a>
<a name="ln2440">    cairo_stroke(cr);</a>
<a name="ln2441"> </a>
<a name="ln2442">#if 0</a>
<a name="ln2443">    //we draw the brush segment by segment</a>
<a name="ln2444">    for (int k=0; k&lt;nb; k++)</a>
<a name="ln2445">    {</a>
<a name="ln2446">      //draw the point</a>
<a name="ln2447">      if (gui-&gt;point_border_selected == k)</a>
<a name="ln2448">      {</a>
<a name="ln2449">        anchor_size = 7.0f / zoom_scale;</a>
<a name="ln2450">      }</a>
<a name="ln2451">      else</a>
<a name="ln2452">      {</a>
<a name="ln2453">        anchor_size = 5.0f / zoom_scale;</a>
<a name="ln2454">      }</a>
<a name="ln2455">      cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln2456">      cairo_rectangle(cr,</a>
<a name="ln2457">                      gpt-&gt;border[k*6] - (anchor_size*0.5)+dx,</a>
<a name="ln2458">                      gpt-&gt;border[k*6+1] - (anchor_size*0.5)+dy,</a>
<a name="ln2459">                      anchor_size, anchor_size);</a>
<a name="ln2460">      cairo_fill_preserve(cr);</a>
<a name="ln2461"> </a>
<a name="ln2462">      if (gui-&gt;point_border_selected == k) cairo_set_line_width(cr, 2.0/zoom_scale);</a>
<a name="ln2463">      else cairo_set_line_width(cr, 1.0/zoom_scale);</a>
<a name="ln2464">      cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln2465">      cairo_set_dash(cr, dashed, 0, 0);</a>
<a name="ln2466">      cairo_stroke(cr);</a>
<a name="ln2467">    }</a>
<a name="ln2468">#endif</a>
<a name="ln2469">  }</a>
<a name="ln2470"> </a>
<a name="ln2471">  // draw the source if needed</a>
<a name="ln2472">  if(!gui-&gt;creation &amp;&amp; gpt-&gt;source_count &gt; nb * 3 + 2)</a>
<a name="ln2473">  {</a>
<a name="ln2474">    // we draw the line between source and dest</a>
<a name="ln2475">    cairo_move_to(cr, gpt-&gt;source[2] + dxs, gpt-&gt;source[3] + dys);</a>
<a name="ln2476">    cairo_line_to(cr, gpt-&gt;points[2] + dx, gpt-&gt;points[3] + dy);</a>
<a name="ln2477">    cairo_set_dash(cr, dashed, 0, 0);</a>
<a name="ln2478">    if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging))</a>
<a name="ln2479">      cairo_set_line_width(cr, 2.5 / zoom_scale);</a>
<a name="ln2480">    else</a>
<a name="ln2481">      cairo_set_line_width(cr, 1.5 / zoom_scale);</a>
<a name="ln2482">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln2483">    cairo_stroke_preserve(cr);</a>
<a name="ln2484">    if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging))</a>
<a name="ln2485">      cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln2486">    else</a>
<a name="ln2487">      cairo_set_line_width(cr, 0.5 / zoom_scale);</a>
<a name="ln2488">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln2489">    cairo_stroke(cr);</a>
<a name="ln2490"> </a>
<a name="ln2491">    // we draw the source</a>
<a name="ln2492">    cairo_set_dash(cr, dashed, 0, 0);</a>
<a name="ln2493">    if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging))</a>
<a name="ln2494">      cairo_set_line_width(cr, 2.5 / zoom_scale);</a>
<a name="ln2495">    else</a>
<a name="ln2496">      cairo_set_line_width(cr, 1.5 / zoom_scale);</a>
<a name="ln2497">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln2498">    cairo_move_to(cr, gpt-&gt;source[nb * 6] + dxs, gpt-&gt;source[nb * 6 + 1] + dys);</a>
<a name="ln2499">    for(int i = nb * 3; i &lt; gpt-&gt;source_count; i++)</a>
<a name="ln2500">      cairo_line_to(cr, gpt-&gt;source[i * 2] + dxs, gpt-&gt;source[i * 2 + 1] + dys);</a>
<a name="ln2501">    cairo_line_to(cr, gpt-&gt;source[nb * 6] + dxs, gpt-&gt;source[nb * 6 + 1] + dys);</a>
<a name="ln2502">    cairo_stroke_preserve(cr);</a>
<a name="ln2503">    if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging))</a>
<a name="ln2504">      cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln2505">    else</a>
<a name="ln2506">      cairo_set_line_width(cr, 0.5 / zoom_scale);</a>
<a name="ln2507">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln2508">    cairo_stroke(cr);</a>
<a name="ln2509">  }</a>
<a name="ln2510">}</a>
<a name="ln2511"> </a>
<a name="ln2512">static int dt_brush_get_source_area(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln2513">                                    dt_masks_form_t *form, int *width, int *height, int *posx, int *posy)</a>
<a name="ln2514">{</a>
<a name="ln2515">  if(!module) return 0;</a>
<a name="ln2516">  // we get buffers for all points</a>
<a name="ln2517">  float *points = NULL, *border = NULL;</a>
<a name="ln2518">  int points_count, border_count;</a>
<a name="ln2519">  if(!_brush_get_points_border(module-&gt;dev, form, module-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, piece-&gt;pipe, &amp;points, &amp;points_count,</a>
<a name="ln2520">                               &amp;border, &amp;border_count, NULL, NULL, 1))</a>
<a name="ln2521">  {</a>
<a name="ln2522">    free(points);</a>
<a name="ln2523">    free(border);</a>
<a name="ln2524">    return 0;</a>
<a name="ln2525">  }</a>
<a name="ln2526"> </a>
<a name="ln2527">  // now we want to find the area, so we search min/max points</a>
<a name="ln2528">  float xmin, xmax, ymin, ymax;</a>
<a name="ln2529">  xmin = ymin = FLT_MAX;</a>
<a name="ln2530">  xmax = ymax = FLT_MIN;</a>
<a name="ln2531">  guint nb_corner = g_list_length(form-&gt;points);</a>
<a name="ln2532">  for(int i = nb_corner * 3; i &lt; border_count; i++)</a>
<a name="ln2533">  {</a>
<a name="ln2534">    // we look at the borders</a>
<a name="ln2535">    float xx = border[i * 2];</a>
<a name="ln2536">    float yy = border[i * 2 + 1];</a>
<a name="ln2537">    xmin = fminf(xx, xmin);</a>
<a name="ln2538">    xmax = fmaxf(xx, xmax);</a>
<a name="ln2539">    ymin = fminf(yy, ymin);</a>
<a name="ln2540">    ymax = fmaxf(yy, ymax);</a>
<a name="ln2541">  }</a>
<a name="ln2542">  for(int i = nb_corner * 3; i &lt; points_count; i++)</a>
<a name="ln2543">  {</a>
<a name="ln2544">    // we look at the brush too</a>
<a name="ln2545">    float xx = points[i * 2];</a>
<a name="ln2546">    float yy = points[i * 2 + 1];</a>
<a name="ln2547">    xmin = fminf(xx, xmin);</a>
<a name="ln2548">    xmax = fmaxf(xx, xmax);</a>
<a name="ln2549">    ymin = fminf(yy, ymin);</a>
<a name="ln2550">    ymax = fmaxf(yy, ymax);</a>
<a name="ln2551">  }</a>
<a name="ln2552"> </a>
<a name="ln2553">  free(points);</a>
<a name="ln2554">  free(border);</a>
<a name="ln2555">  *height = ymax - ymin + 4;</a>
<a name="ln2556">  *width = xmax - xmin + 4;</a>
<a name="ln2557">  *posx = xmin - 2;</a>
<a name="ln2558">  *posy = ymin - 2;</a>
<a name="ln2559">  return 1;</a>
<a name="ln2560">}</a>
<a name="ln2561"> </a>
<a name="ln2562">static int dt_brush_get_area(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, dt_masks_form_t *form,</a>
<a name="ln2563">                             int *width, int *height, int *posx, int *posy)</a>
<a name="ln2564">{</a>
<a name="ln2565">  if(!module) return 0;</a>
<a name="ln2566">  // we get buffers for all points</a>
<a name="ln2567">  float *points = NULL, *border = NULL;</a>
<a name="ln2568">  int points_count, border_count;</a>
<a name="ln2569">  if(!_brush_get_points_border(module-&gt;dev, form, module-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, piece-&gt;pipe, &amp;points, &amp;points_count,</a>
<a name="ln2570">                               &amp;border, &amp;border_count, NULL, NULL, 0))</a>
<a name="ln2571">  {</a>
<a name="ln2572">    free(points);</a>
<a name="ln2573">    free(border);</a>
<a name="ln2574">    return 0;</a>
<a name="ln2575">  }</a>
<a name="ln2576"> </a>
<a name="ln2577">  // now we want to find the area, so we search min/max points</a>
<a name="ln2578">  float xmin, xmax, ymin, ymax;</a>
<a name="ln2579">  xmin = ymin = FLT_MAX;</a>
<a name="ln2580">  xmax = ymax = FLT_MIN;</a>
<a name="ln2581">  guint nb_corner = g_list_length(form-&gt;points);</a>
<a name="ln2582">  for(int i = nb_corner * 3; i &lt; border_count; i++)</a>
<a name="ln2583">  {</a>
<a name="ln2584">    // we look at the borders</a>
<a name="ln2585">    float xx = border[i * 2];</a>
<a name="ln2586">    float yy = border[i * 2 + 1];</a>
<a name="ln2587">    xmin = fminf(xx, xmin);</a>
<a name="ln2588">    xmax = fmaxf(xx, xmax);</a>
<a name="ln2589">    ymin = fminf(yy, ymin);</a>
<a name="ln2590">    ymax = fmaxf(yy, ymax);</a>
<a name="ln2591">  }</a>
<a name="ln2592">  for(int i = nb_corner * 3; i &lt; points_count; i++)</a>
<a name="ln2593">  {</a>
<a name="ln2594">    // we look at the brush too</a>
<a name="ln2595">    float xx = points[i * 2];</a>
<a name="ln2596">    float yy = points[i * 2 + 1];</a>
<a name="ln2597">    xmin = fminf(xx, xmin);</a>
<a name="ln2598">    xmax = fmaxf(xx, xmax);</a>
<a name="ln2599">    ymin = fminf(yy, ymin);</a>
<a name="ln2600">    ymax = fmaxf(yy, ymax);</a>
<a name="ln2601">  }</a>
<a name="ln2602"> </a>
<a name="ln2603">  free(points);</a>
<a name="ln2604">  free(border);</a>
<a name="ln2605"> </a>
<a name="ln2606">  *height = ymax - ymin + 4;</a>
<a name="ln2607">  *width = xmax - xmin + 4;</a>
<a name="ln2608">  *posx = xmin - 2;</a>
<a name="ln2609">  *posy = ymin - 2;</a>
<a name="ln2610">  return 1;</a>
<a name="ln2611">}</a>
<a name="ln2612"> </a>
<a name="ln2613">/** we write a falloff segment */</a>
<a name="ln2614">static void _brush_falloff(float **buffer, int *p0, int *p1, int posx, int posy, int bw, float hardness,</a>
<a name="ln2615">                           float density)</a>
<a name="ln2616">{</a>
<a name="ln2617">  // segment length</a>
<a name="ln2618">  const int l = sqrt((p1[0] - p0[0]) * (p1[0] - p0[0]) + (p1[1] - p0[1]) * (p1[1] - p0[1])) + 1;</a>
<a name="ln2619">  const int solid = (int)l * hardness;</a>
<a name="ln2620">  const int soft = l - solid;</a>
<a name="ln2621"> </a>
<a name="ln2622">  const float lx = p1[0] - p0[0];</a>
<a name="ln2623">  const float ly = p1[1] - p0[1];</a>
<a name="ln2624"> </a>
<a name="ln2625">  for(int i = 0; i &lt; l; i++)</a>
<a name="ln2626">  {</a>
<a name="ln2627">    // position</a>
<a name="ln2628">    const int x = (int)((float)i * lx / (float)l) + p0[0] - posx;</a>
<a name="ln2629">    const int y = (int)((float)i * ly / (float)l) + p0[1] - posy;</a>
<a name="ln2630">    const float op = density * ((i &lt;= solid) ? 1.0f : 1.0 - (float)(i - solid) / (float)soft);</a>
<a name="ln2631">    (*buffer)[y * bw + x] = fmaxf((*buffer)[y * bw + x], op);</a>
<a name="ln2632">    if(x &gt; 0)</a>
<a name="ln2633">      (*buffer)[y * bw + x - 1]</a>
<a name="ln2634">          = fmaxf((*buffer)[y * bw + x - 1], op); // this one is to avoid gap due to int rounding</a>
<a name="ln2635">    if(y &gt; 0)</a>
<a name="ln2636">      (*buffer)[(y - 1) * bw + x]</a>
<a name="ln2637">          = fmaxf((*buffer)[(y - 1) * bw + x], op); // this one is to avoid gap due to int rounding</a>
<a name="ln2638">  }</a>
<a name="ln2639">}</a>
<a name="ln2640"> </a>
<a name="ln2641">static int dt_brush_get_mask(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, dt_masks_form_t *form,</a>
<a name="ln2642">                             float **buffer, int *width, int *height, int *posx, int *posy)</a>
<a name="ln2643">{</a>
<a name="ln2644">  if(!module) return 0;</a>
<a name="ln2645">  double start = dt_get_wtime();</a>
<a name="ln2646">  double start2;</a>
<a name="ln2647"> </a>
<a name="ln2648">  // we get buffers for all points</a>
<a name="ln2649">  float *points = NULL, *border = NULL, *payload = NULL;</a>
<a name="ln2650">  int points_count, border_count, payload_count;</a>
<a name="ln2651">  if(!_brush_get_points_border(module-&gt;dev, form, module-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, piece-&gt;pipe,&amp;points, &amp;points_count,</a>
<a name="ln2652">                               &amp;border, &amp;border_count, &amp;payload, &amp;payload_count, 0))</a>
<a name="ln2653">  {</a>
<a name="ln2654">    free(points);</a>
<a name="ln2655">    free(border);</a>
<a name="ln2656">    free(payload);</a>
<a name="ln2657">    return 0;</a>
<a name="ln2658">  }</a>
<a name="ln2659"> </a>
<a name="ln2660">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2661">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] brush points took %0.04f sec\n&quot;, form-&gt;name, dt_get_wtime() - start);</a>
<a name="ln2662">  start = start2 = dt_get_wtime();</a>
<a name="ln2663"> </a>
<a name="ln2664">  // now we want to find the area, so we search min/max points</a>
<a name="ln2665">  float xmin, xmax, ymin, ymax;</a>
<a name="ln2666">  xmin = ymin = FLT_MAX;</a>
<a name="ln2667">  xmax = ymax = FLT_MIN;</a>
<a name="ln2668">  guint nb_corner = g_list_length(form-&gt;points);</a>
<a name="ln2669">  for(int i = nb_corner * 3; i &lt; border_count; i++)</a>
<a name="ln2670">  {</a>
<a name="ln2671">    // we look at the borders</a>
<a name="ln2672">    float xx = border[i * 2];</a>
<a name="ln2673">    float yy = border[i * 2 + 1];</a>
<a name="ln2674">    xmin = fminf(xx, xmin);</a>
<a name="ln2675">    xmax = fmaxf(xx, xmax);</a>
<a name="ln2676">    ymin = fminf(yy, ymin);</a>
<a name="ln2677">    ymax = fmaxf(yy, ymax);</a>
<a name="ln2678">  }</a>
<a name="ln2679">  for(int i = nb_corner * 3; i &lt; points_count; i++)</a>
<a name="ln2680">  {</a>
<a name="ln2681">    // we look at the brush too</a>
<a name="ln2682">    float xx = points[i * 2];</a>
<a name="ln2683">    float yy = points[i * 2 + 1];</a>
<a name="ln2684">    xmin = fminf(xx, xmin);</a>
<a name="ln2685">    xmax = fmaxf(xx, xmax);</a>
<a name="ln2686">    ymin = fminf(yy, ymin);</a>
<a name="ln2687">    ymax = fmaxf(yy, ymax);</a>
<a name="ln2688">  }</a>
<a name="ln2689"> </a>
<a name="ln2690">  *height = ymax - ymin + 4;</a>
<a name="ln2691">  *width = xmax - xmin + 4;</a>
<a name="ln2692">  *posx = xmin - 2;</a>
<a name="ln2693">  *posy = ymin - 2;</a>
<a name="ln2694"> </a>
<a name="ln2695">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2696">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] brush_fill min max took %0.04f sec\n&quot;, form-&gt;name,</a>
<a name="ln2697">             dt_get_wtime() - start2);</a>
<a name="ln2698">//   start2 = dt_get_wtime();</a>
<a name="ln2699"> </a>
<a name="ln2700">  // we allocate the buffer</a>
<a name="ln2701">  *buffer = calloc((size_t)(*width) * (*height), sizeof(float));</a>
<a name="ln2702"> </a>
<a name="ln2703">  // now we fill the falloff</a>
<a name="ln2704">  int p0[2], p1[2];</a>
<a name="ln2705"> </a>
<a name="ln2706">  for(int i = nb_corner * 3; i &lt; border_count; i++)</a>
<a name="ln2707">  {</a>
<a name="ln2708">    p0[0] = points[i * 2];</a>
<a name="ln2709">    p0[1] = points[i * 2 + 1];</a>
<a name="ln2710">    p1[0] = border[i * 2];</a>
<a name="ln2711">    p1[1] = border[i * 2 + 1];</a>
<a name="ln2712"> </a>
<a name="ln2713">    _brush_falloff(buffer, p0, p1, *posx, *posy, *width, payload[i * 2], payload[i * 2 + 1]);</a>
<a name="ln2714">  }</a>
<a name="ln2715"> </a>
<a name="ln2716">  free(points);</a>
<a name="ln2717">  free(border);</a>
<a name="ln2718">  free(payload);</a>
<a name="ln2719"> </a>
<a name="ln2720">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2721">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] brush fill buffer took %0.04f sec\n&quot;, form-&gt;name,</a>
<a name="ln2722">             dt_get_wtime() - start);</a>
<a name="ln2723"> </a>
<a name="ln2724">  return 1;</a>
<a name="ln2725">}</a>
<a name="ln2726"> </a>
<a name="ln2727">/** we write a falloff segment respecting limits of buffer */</a>
<a name="ln2728">static inline void _brush_falloff_roi(float *buffer, int *p0, int *p1, int bw, int bh, float hardness,</a>
<a name="ln2729">                                      float density)</a>
<a name="ln2730">{</a>
<a name="ln2731">  // segment length (increase by 1 to avoid division-by-zero special case handling)</a>
<a name="ln2732">  const int l = sqrt((p1[0] - p0[0]) * (p1[0] - p0[0]) + (p1[1] - p0[1]) * (p1[1] - p0[1])) + 1;</a>
<a name="ln2733">  const int solid = hardness * l;</a>
<a name="ln2734"> </a>
<a name="ln2735">  const float lx = (float)(p1[0] - p0[0]) / (float)l;</a>
<a name="ln2736">  const float ly = (float)(p1[1] - p0[1]) / (float)l;</a>
<a name="ln2737"> </a>
<a name="ln2738">  const int dx = lx &lt;= 0 ? -1 : 1;</a>
<a name="ln2739">  const int dy = ly &lt;= 0 ? -1 : 1;</a>
<a name="ln2740">  const int dpx = dx;</a>
<a name="ln2741">  const int dpy = dy * bw;</a>
<a name="ln2742"> </a>
<a name="ln2743">  float fx = p0[0];</a>
<a name="ln2744">  float fy = p0[1];</a>
<a name="ln2745"> </a>
<a name="ln2746">  float op = density;</a>
<a name="ln2747">  float dop = density / (float)(l - solid);</a>
<a name="ln2748"> </a>
<a name="ln2749">  for(int i = 0; i &lt; l; i++)</a>
<a name="ln2750">  {</a>
<a name="ln2751">    const int x = fx;</a>
<a name="ln2752">    const int y = fy;</a>
<a name="ln2753"> </a>
<a name="ln2754">    fx += lx;</a>
<a name="ln2755">    fy += ly;</a>
<a name="ln2756">    if(i &gt; solid) op -= dop;</a>
<a name="ln2757"> </a>
<a name="ln2758">    if(x &lt; 0 || x &gt;= bw || y &lt; 0 || y &gt;= bh) continue;</a>
<a name="ln2759"> </a>
<a name="ln2760">    float *buf = buffer + (size_t)y * bw + x;</a>
<a name="ln2761"> </a>
<a name="ln2762">    *buf = fmaxf(*buf, op);</a>
<a name="ln2763">    if(x + dx &gt;= 0 &amp;&amp; x + dx &lt; bw)</a>
<a name="ln2764">      buf[dpx] = fmaxf(buf[dpx], op); // this one is to avoid gaps due to int rounding</a>
<a name="ln2765">    if(y + dy &gt;= 0 &amp;&amp; y + dy &lt; bh)</a>
<a name="ln2766">      buf[dpy] = fmaxf(buf[dpy], op); // this one is to avoid gaps due to int rounding</a>
<a name="ln2767">  }</a>
<a name="ln2768">}</a>
<a name="ln2769"> </a>
<a name="ln2770">static int dt_brush_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln2771">                                 dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer)</a>
<a name="ln2772">{</a>
<a name="ln2773">  if(!module) return 0;</a>
<a name="ln2774">  double start = dt_get_wtime();</a>
<a name="ln2775">  double start2;</a>
<a name="ln2776"> </a>
<a name="ln2777">  const int px = roi-&gt;x;</a>
<a name="ln2778">  const int py = roi-&gt;y;</a>
<a name="ln2779">  const int width = roi-&gt;width;</a>
<a name="ln2780">  const int height = roi-&gt;height;</a>
<a name="ln2781">  const float scale = roi-&gt;scale;</a>
<a name="ln2782"> </a>
<a name="ln2783">  // we get buffers for all points</a>
<a name="ln2784">  float *points = NULL, *border = NULL, *payload = NULL;</a>
<a name="ln2785"> </a>
<a name="ln2786">  int points_count, border_count, payload_count;</a>
<a name="ln2787">  if(!_brush_get_points_border(module-&gt;dev, form, module-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, piece-&gt;pipe,&amp;points, &amp;points_count,</a>
<a name="ln2788">                               &amp;border, &amp;border_count, &amp;payload, &amp;payload_count, 0))</a>
<a name="ln2789">  {</a>
<a name="ln2790">    free(points);</a>
<a name="ln2791">    free(border);</a>
<a name="ln2792">    free(payload);</a>
<a name="ln2793">    return 0;</a>
<a name="ln2794">  }</a>
<a name="ln2795"> </a>
<a name="ln2796">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2797">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] brush points took %0.04f sec\n&quot;, form-&gt;name, dt_get_wtime() - start);</a>
<a name="ln2798">  start = start2 = dt_get_wtime();</a>
<a name="ln2799"> </a>
<a name="ln2800">  // empty the output buffer</a>
<a name="ln2801">  memset(buffer, 0, (size_t)width * height * sizeof(float));</a>
<a name="ln2802"> </a>
<a name="ln2803">  guint nb_corner = g_list_length(form-&gt;points);</a>
<a name="ln2804"> </a>
<a name="ln2805">  // we shift and scale down brush and border</a>
<a name="ln2806">  for(int i = nb_corner * 3; i &lt; border_count; i++)</a>
<a name="ln2807">  {</a>
<a name="ln2808">    float xx = border[2 * i];</a>
<a name="ln2809">    float yy = border[2 * i + 1];</a>
<a name="ln2810">    border[2 * i] = xx * scale - px;</a>
<a name="ln2811">    border[2 * i + 1] = yy * scale - py;</a>
<a name="ln2812">  }</a>
<a name="ln2813"> </a>
<a name="ln2814">  for(int i = nb_corner * 3; i &lt; points_count; i++)</a>
<a name="ln2815">  {</a>
<a name="ln2816">    float xx = points[2 * i];</a>
<a name="ln2817">    float yy = points[2 * i + 1];</a>
<a name="ln2818">    points[2 * i] = xx * scale - px;</a>
<a name="ln2819">    points[2 * i + 1] = yy * scale - py;</a>
<a name="ln2820">  }</a>
<a name="ln2821"> </a>
<a name="ln2822">  // now we want to find the area, so we search min/max points</a>
<a name="ln2823">  float xmin, xmax, ymin, ymax;</a>
<a name="ln2824">  xmin = ymin = FLT_MAX;</a>
<a name="ln2825">  xmax = ymax = FLT_MIN;</a>
<a name="ln2826"> </a>
<a name="ln2827">  for(int i = nb_corner * 3; i &lt; border_count; i++)</a>
<a name="ln2828">  {</a>
<a name="ln2829">    // we look at the borders</a>
<a name="ln2830">    float xx = border[i * 2];</a>
<a name="ln2831">    float yy = border[i * 2 + 1];</a>
<a name="ln2832">    xmin = fminf(xx, xmin);</a>
<a name="ln2833">    xmax = fmaxf(xx, xmax);</a>
<a name="ln2834">    ymin = fminf(yy, ymin);</a>
<a name="ln2835">    ymax = fmaxf(yy, ymax);</a>
<a name="ln2836">  }</a>
<a name="ln2837">  for(int i = nb_corner * 3; i &lt; points_count; i++)</a>
<a name="ln2838">  {</a>
<a name="ln2839">    // we look at the brush too</a>
<a name="ln2840">    float xx = points[i * 2];</a>
<a name="ln2841">    float yy = points[i * 2 + 1];</a>
<a name="ln2842">    xmin = fminf(xx, xmin);</a>
<a name="ln2843">    xmax = fmaxf(xx, xmax);</a>
<a name="ln2844">    ymin = fminf(yy, ymin);</a>
<a name="ln2845">    ymax = fmaxf(yy, ymax);</a>
<a name="ln2846">  }</a>
<a name="ln2847"> </a>
<a name="ln2848">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2849">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] brush_fill min max took %0.04f sec\n&quot;, form-&gt;name,</a>
<a name="ln2850">             dt_get_wtime() - start2);</a>
<a name="ln2851">//   start2 = dt_get_wtime();</a>
<a name="ln2852"> </a>
<a name="ln2853">  // check if the path completely lies outside of roi -&gt; we're done/mask remains empty</a>
<a name="ln2854">  if(xmax &lt; 0 || ymax &lt; 0 || xmin &gt;= width || ymin &gt;= height)</a>
<a name="ln2855">  {</a>
<a name="ln2856">    free(points);</a>
<a name="ln2857">    free(border);</a>
<a name="ln2858">    free(payload);</a>
<a name="ln2859">    return 1;</a>
<a name="ln2860">  }</a>
<a name="ln2861"> </a>
<a name="ln2862">  // now we fill the falloff</a>
<a name="ln2863">  int p0[2], p1[2];</a>
<a name="ln2864">  for(int i = nb_corner * 3; i &lt; border_count; i++)</a>
<a name="ln2865">  {</a>
<a name="ln2866">    p0[0] = points[i * 2];</a>
<a name="ln2867">    p0[1] = points[i * 2 + 1];</a>
<a name="ln2868">    p1[0] = border[i * 2];</a>
<a name="ln2869">    p1[1] = border[i * 2 + 1];</a>
<a name="ln2870"> </a>
<a name="ln2871">    if(MAX(p0[0], p1[0]) &lt; 0 || MIN(p0[0], p1[0]) &gt;= width || MAX(p0[1], p1[1]) &lt; 0</a>
<a name="ln2872">       || MIN(p0[1], p1[1]) &gt;= height)</a>
<a name="ln2873">      continue;</a>
<a name="ln2874"> </a>
<a name="ln2875">    _brush_falloff_roi(buffer, p0, p1, width, height, payload[i * 2], payload[i * 2 + 1]);</a>
<a name="ln2876">  }</a>
<a name="ln2877"> </a>
<a name="ln2878">  free(points);</a>
<a name="ln2879">  free(border);</a>
<a name="ln2880">  free(payload);</a>
<a name="ln2881"> </a>
<a name="ln2882">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2883">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] brush fill buffer took %0.04f sec\n&quot;, form-&gt;name,</a>
<a name="ln2884">             dt_get_wtime() - start);</a>
<a name="ln2885"> </a>
<a name="ln2886">  return 1;</a>
<a name="ln2887">}</a>
<a name="ln2888"> </a>
<a name="ln2889">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2890">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2891">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="134"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'point1'. Check lines: 134, 133.</p></div>
<div class="balloon" rel="144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'pointn'. Check lines: 144, 143.</p></div>
<div class="balloon" rel="275"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'point4' pointer was utilized before it was verified against nullptr. Check lines: 275, 286.</p></div>
<div class="balloon" rel="551"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 550, 551.</p></div>
<div class="balloon" rel="553"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 552, 553.</p></div>
<div class="balloon" rel="867"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 866, 867.</p></div>
<div class="balloon" rel="868"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 867, 868.</p></div>
<div class="balloon" rel="870"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 869, 870.</p></div>
<div class="balloon" rel="871"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 870, 871.</p></div>
<div class="balloon" rel="831"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'border' pointer was utilized before it was verified against nullptr. Check lines: 831, 852.</p></div>
<div class="balloon" rel="1354"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'bzpt'. Check lines: 1354, 1346.</p></div>
<div class="balloon" rel="1380"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: gui->seg_selected >= 0.</p></div>
<div class="balloon" rel="2371"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: k == nb.</p></div>
<div class="balloon" rel="2371"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: gui->creation.</p></div>
<div class="balloon" rel="2403"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: (gui->group_selected == index).</p></div>
<div class="balloon" rel="2472"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !gui->creation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
