
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012--2013 Ulrich Pegelow</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln22">#include &quot;common/imageio.h&quot;</a>
<a name="ln23">#include &quot;common/opencl.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;develop/develop.h&quot;</a>
<a name="ln26">#include &quot;develop/imageop.h&quot;</a>
<a name="ln27">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln28">#include &quot;develop/tiling.h&quot;</a>
<a name="ln29">#include &quot;dtgtk/gradientslider.h&quot;</a>
<a name="ln30">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln31">#include &quot;gui/gtk.h&quot;</a>
<a name="ln32">#include &quot;gui/presets.h&quot;</a>
<a name="ln33">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln34">#include &lt;assert.h&gt;</a>
<a name="ln35">#include &lt;math.h&gt;</a>
<a name="ln36">#include &lt;stdlib.h&gt;</a>
<a name="ln37">#include &lt;string.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln40">#include &lt;inttypes.h&gt;</a>
<a name="ln41">#if defined(__SSE__)</a>
<a name="ln42">#include &lt;xmmintrin.h&gt;</a>
<a name="ln43">#endif</a>
<a name="ln44"> </a>
<a name="ln45">#define CLIP(x) ((x &lt; 0) ? 0.0 : (x &gt; 1.0) ? 1.0 : x)</a>
<a name="ln46">#define TEA_ROUNDS 8</a>
<a name="ln47"> </a>
<a name="ln48">DT_MODULE_INTROSPECTION(1, dt_iop_dither_params_t)</a>
<a name="ln49"> </a>
<a name="ln50">typedef void(_find_nearest_color)(float *val, float *err, const float f, const float rf);</a>
<a name="ln51"> </a>
<a name="ln52">#if defined(__SSE__)</a>
<a name="ln53">typedef __m128(_find_nearest_color_sse)(float *val, const float f, const float rf);</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">typedef enum dt_iop_dither_type_t</a>
<a name="ln57">{</a>
<a name="ln58">  DITHER_RANDOM,</a>
<a name="ln59">  DITHER_FS1BIT,</a>
<a name="ln60">  DITHER_FS4BIT_GRAY,</a>
<a name="ln61">  DITHER_FS8BIT,</a>
<a name="ln62">  DITHER_FS16BIT,</a>
<a name="ln63">  DITHER_FSAUTO</a>
<a name="ln64">} dt_iop_dither_type_t;</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">typedef struct dt_iop_dither_params_t</a>
<a name="ln68">{</a>
<a name="ln69">  dt_iop_dither_type_t dither_type;</a>
<a name="ln70">  int palette; // reserved for future extensions</a>
<a name="ln71">  struct</a>
<a name="ln72">  {</a>
<a name="ln73">    float radius;   // reserved for future extensions</a>
<a name="ln74">    float range[4]; // reserved for future extensions</a>
<a name="ln75">    float damping;</a>
<a name="ln76">  } random;</a>
<a name="ln77">} dt_iop_dither_params_t;</a>
<a name="ln78"> </a>
<a name="ln79">typedef struct dt_iop_dither_gui_data_t</a>
<a name="ln80">{</a>
<a name="ln81">  GtkWidget *dither_type;</a>
<a name="ln82">  GtkWidget *random;</a>
<a name="ln83">  GtkWidget *radius;</a>
<a name="ln84">  GtkWidget *range;</a>
<a name="ln85">  GtkWidget *range_label;</a>
<a name="ln86">  GtkWidget *damping;</a>
<a name="ln87">} dt_iop_dither_gui_data_t;</a>
<a name="ln88"> </a>
<a name="ln89">typedef struct dt_iop_dither_data_t</a>
<a name="ln90">{</a>
<a name="ln91">  dt_iop_dither_type_t dither_type;</a>
<a name="ln92">  struct</a>
<a name="ln93">  {</a>
<a name="ln94">    float radius;</a>
<a name="ln95">    float range[4];</a>
<a name="ln96">    float damping;</a>
<a name="ln97">  } random;</a>
<a name="ln98">} dt_iop_dither_data_t;</a>
<a name="ln99"> </a>
<a name="ln100"> </a>
<a name="ln101">const char *name()</a>
<a name="ln102">{</a>
<a name="ln103">  return _(&quot;dithering&quot;);</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">int default_group()</a>
<a name="ln107">{</a>
<a name="ln108">  return IOP_GROUP_CORRECT;</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">int flags()</a>
<a name="ln112">{</a>
<a name="ln113">  return IOP_FLAGS_ONE_INSTANCE;</a>
<a name="ln114">}</a>
<a name="ln115"> </a>
<a name="ln116">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln117">{</a>
<a name="ln118">  return iop_cs_rgb;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121"> </a>
<a name="ln122">void init_presets(dt_iop_module_so_t *self)</a>
<a name="ln123">{</a>
<a name="ln124">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;BEGIN&quot;, NULL, NULL, NULL);</a>
<a name="ln125"> </a>
<a name="ln126">  dt_iop_dither_params_t tmp</a>
<a name="ln127">      = (dt_iop_dither_params_t){ DITHER_FSAUTO, 0, { 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }, -200.0f } };</a>
<a name="ln128">  // add the preset.</a>
<a name="ln129">  dt_gui_presets_add_generic(_(&quot;dither&quot;), self-&gt;op, self-&gt;version(), &amp;tmp, sizeof(dt_iop_dither_params_t), 1);</a>
<a name="ln130">  // make it auto-apply for all images:</a>
<a name="ln131">  // dt_gui_presets_update_autoapply(_(&quot;dither&quot;), self-&gt;op, self-&gt;version(), 1);</a>
<a name="ln132"> </a>
<a name="ln133">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136"> </a>
<a name="ln137">// dither pixel into gray, with f=levels-1 and rf=1/f, return err=old-new</a>
<a name="ln138">static void _find_nearest_color_n_levels_gray(float *val, float *err, const float f, const float rf)</a>
<a name="ln139">{</a>
<a name="ln140">  const float in = 0.30f * val[0] + 0.59f * val[1] + 0.11f * val[2]; // RGB -&gt; GRAY</a>
<a name="ln141"> </a>
<a name="ln142">  float tmp = in * f;</a>
<a name="ln143">  int itmp = floorf(tmp);</a>
<a name="ln144"> </a>
<a name="ln145">  float new = (tmp - itmp &gt; 0.5f ? (float)(itmp + 1) : (float)itmp) * rf;</a>
<a name="ln146"> </a>
<a name="ln147">  for(int c = 0; c &lt; 4; c++)</a>
<a name="ln148">  {</a>
<a name="ln149">    err[c] = val[c] - new;</a>
<a name="ln150">    val[c] = new;</a>
<a name="ln151">  }</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">#if defined(__SSE2__)</a>
<a name="ln155">// dither pixel into gray, with f=levels-1 and rf=1/f, return err=old-new</a>
<a name="ln156">static __m128 _find_nearest_color_n_levels_gray_sse(float *val, const float f, const float rf)</a>
<a name="ln157">{</a>
<a name="ln158">  __m128 err;</a>
<a name="ln159">  __m128 new;</a>
<a name="ln160"> </a>
<a name="ln161">  const float in = 0.30f * val[0] + 0.59f * val[1] + 0.11f * val[2]; // RGB -&gt; GRAY</a>
<a name="ln162"> </a>
<a name="ln163">  float tmp = in * f;</a>
<a name="ln164">  int itmp = floorf(tmp);</a>
<a name="ln165"> </a>
<a name="ln166">  new = _mm_set1_ps(tmp - itmp &gt; 0.5f ? (float)(itmp + 1) * rf : (float)itmp * rf);</a>
<a name="ln167">  err = _mm_sub_ps(_mm_load_ps(val), new);</a>
<a name="ln168">  _mm_store_ps(val, new);</a>
<a name="ln169"> </a>
<a name="ln170">  return err;</a>
<a name="ln171">}</a>
<a name="ln172">#endif</a>
<a name="ln173"> </a>
<a name="ln174">// dither pixel into RGB, with f=levels-1 and rf=1/f, return err=old-new</a>
<a name="ln175">static void _find_nearest_color_n_levels_rgb(float *val, float *err, const float f, const float rf)</a>
<a name="ln176">{</a>
<a name="ln177">  for(int c = 0; c &lt; 4; c++)</a>
<a name="ln178">  {</a>
<a name="ln179">    float old = val[c];</a>
<a name="ln180">    float tmp = old * f;</a>
<a name="ln181">    float itmp = floorf(tmp);</a>
<a name="ln182">    float new = (tmp - itmp &gt; 0.5f ? itmp + 1 : itmp) * rf;</a>
<a name="ln183"> </a>
<a name="ln184">    val[c] = new;</a>
<a name="ln185">    err[c] = old - new;</a>
<a name="ln186">  }</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">#if defined(__SSE2__)</a>
<a name="ln190">// dither pixel into RGB, with f=levels-1 and rf=1/f, return err=old-new</a>
<a name="ln191">static __m128 _find_nearest_color_n_levels_rgb_sse2(float *val, const float f, const float rf)</a>
<a name="ln192">{</a>
<a name="ln193">  __m128 old = _mm_load_ps(val);</a>
<a name="ln194">  __m128 tmp = _mm_mul_ps(old, _mm_set1_ps(f));        // old * f</a>
<a name="ln195">  __m128 itmp = _mm_cvtepi32_ps(_mm_cvtps_epi32(tmp)); // floor(tmp)</a>
<a name="ln196">  __m128 new = _mm_mul_ps(</a>
<a name="ln197">      _mm_add_ps(itmp,</a>
<a name="ln198">                 _mm_and_ps(_mm_cmpgt_ps(_mm_sub_ps(tmp, itmp), // (tmp - itmp &gt; 0.5f ? itmp + 1 : itmp) * rf</a>
<a name="ln199">                                         _mm_set1_ps(0.5f)),</a>
<a name="ln200">                            _mm_set1_ps(1.0f))),</a>
<a name="ln201">      _mm_set1_ps(rf));</a>
<a name="ln202"> </a>
<a name="ln203">  _mm_store_ps(val, new);</a>
<a name="ln204"> </a>
<a name="ln205">  return _mm_sub_ps(old, new);</a>
<a name="ln206">}</a>
<a name="ln207">#endif</a>
<a name="ln208"> </a>
<a name="ln209">static inline void _diffuse_error(float *val, const float *err, const float factor)</a>
<a name="ln210">{</a>
<a name="ln211">  for(int c = 0; c &lt; 4; c++)</a>
<a name="ln212">  {</a>
<a name="ln213">    val[c] += err[c] * factor;</a>
<a name="ln214">  }</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">#if defined(__SSE__)</a>
<a name="ln218">static inline void _diffuse_error_sse(float *val, const __m128 err, const float factor)</a>
<a name="ln219">{</a>
<a name="ln220">  _mm_store_ps(val,</a>
<a name="ln221">               _mm_add_ps(_mm_load_ps(val), _mm_mul_ps(err, _mm_set1_ps(factor)))); // *val += err * factor</a>
<a name="ln222">}</a>
<a name="ln223">#endif</a>
<a name="ln224"> </a>
<a name="ln225">static inline float clipnan(const float x)</a>
<a name="ln226">{</a>
<a name="ln227">  float r;</a>
<a name="ln228"> </a>
<a name="ln229">  if(isnan(x))</a>
<a name="ln230">    r = 0.5f;</a>
<a name="ln231">  else // normal number</a>
<a name="ln232">    r = (isless(x, 0.0f) ? 0.0f : (isgreater(x, 1.0f) ? 1.0f : x));</a>
<a name="ln233"> </a>
<a name="ln234">  return r;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">static void process_floyd_steinberg(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln238">                                    const void *const ivoid, void *const ovoid,</a>
<a name="ln239">                                    const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln240">{</a>
<a name="ln241">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln242"> </a>
<a name="ln243">  const int width = roi_in-&gt;width;</a>
<a name="ln244">  const int height = roi_in-&gt;height;</a>
<a name="ln245">  const int ch = piece-&gt;colors;</a>
<a name="ln246">  const float scale = roi_in-&gt;scale / piece-&gt;iscale;</a>
<a name="ln247">  const int l1 = floorf(1.0f + dt_log2f(1.0f / scale));</a>
<a name="ln248"> </a>
<a name="ln249">  _find_nearest_color *nearest_color = NULL;</a>
<a name="ln250">  unsigned int levels = 1;</a>
<a name="ln251">  int bds = (piece-&gt;pipe-&gt;type != DT_DEV_PIXELPIPE_EXPORT) ? l1 * l1 : 1;</a>
<a name="ln252"> </a>
<a name="ln253">  switch(data-&gt;dither_type)</a>
<a name="ln254">  {</a>
<a name="ln255">    case DITHER_FS1BIT:</a>
<a name="ln256">      nearest_color = _find_nearest_color_n_levels_gray;</a>
<a name="ln257">      levels = MAX(2, MIN(bds + 1, 256));</a>
<a name="ln258">      break;</a>
<a name="ln259">    case DITHER_FS4BIT_GRAY:</a>
<a name="ln260">      nearest_color = _find_nearest_color_n_levels_gray;</a>
<a name="ln261">      levels = MAX(16, MIN(15 * bds + 1, 256));</a>
<a name="ln262">      break;</a>
<a name="ln263">    case DITHER_FS8BIT:</a>
<a name="ln264">      nearest_color = _find_nearest_color_n_levels_rgb;</a>
<a name="ln265">      levels = 256;</a>
<a name="ln266">      break;</a>
<a name="ln267">    case DITHER_FS16BIT:</a>
<a name="ln268">      nearest_color = _find_nearest_color_n_levels_rgb;</a>
<a name="ln269">      levels = 65536;</a>
<a name="ln270">      break;</a>
<a name="ln271">    case DITHER_FSAUTO:</a>
<a name="ln272">      switch(piece-&gt;pipe-&gt;levels &amp; IMAGEIO_CHANNEL_MASK)</a>
<a name="ln273">      {</a>
<a name="ln274">        case IMAGEIO_RGB:</a>
<a name="ln275">          nearest_color = _find_nearest_color_n_levels_rgb;</a>
<a name="ln276">          break;</a>
<a name="ln277">        case IMAGEIO_GRAY:</a>
<a name="ln278">          nearest_color = _find_nearest_color_n_levels_gray;</a>
<a name="ln279">          break;</a>
<a name="ln280">      }</a>
<a name="ln281"> </a>
<a name="ln282">      switch(piece-&gt;pipe-&gt;levels &amp; IMAGEIO_PREC_MASK)</a>
<a name="ln283">      {</a>
<a name="ln284">        case IMAGEIO_INT8:</a>
<a name="ln285">          levels = 256;</a>
<a name="ln286">          break;</a>
<a name="ln287">        case IMAGEIO_INT12:</a>
<a name="ln288">          levels = 4096;</a>
<a name="ln289">          break;</a>
<a name="ln290">        case IMAGEIO_INT16:</a>
<a name="ln291">          levels = 65536;</a>
<a name="ln292">          break;</a>
<a name="ln293">        case IMAGEIO_BW:</a>
<a name="ln294">          levels = 2;</a>
<a name="ln295">          break;</a>
<a name="ln296">        case IMAGEIO_INT32:</a>
<a name="ln297">        case IMAGEIO_FLOAT:</a>
<a name="ln298">        default:</a>
<a name="ln299">          nearest_color = NULL;</a>
<a name="ln300">          break;</a>
<a name="ln301">      }</a>
<a name="ln302">      // no automatic dithering for preview and thumbnail</a>
<a name="ln303">      if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_THUMBNAIL)</a>
<a name="ln304">        nearest_color = NULL;</a>
<a name="ln305">      break;</a>
<a name="ln306">    case DITHER_RANDOM:</a>
<a name="ln307">      // this function won't ever be called for that type</a>
<a name="ln308">      // instead, process_random() will be called</a>
<a name="ln309">      __builtin_unreachable();</a>
<a name="ln310">      break;</a>
<a name="ln311">  }</a>
<a name="ln312"> </a>
<a name="ln313">#ifdef _OPENMP</a>
<a name="ln314">#pragma omp parallel for default(none) \</a>
<a name="ln315">  dt_omp_firstprivate(ch, height, ivoid, ovoid, width) \</a>
<a name="ln316">  schedule(static)</a>
<a name="ln317">#endif</a>
<a name="ln318">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln319">  {</a>
<a name="ln320">    const float *in = (const float *)ivoid + (size_t)ch * width * j;</a>
<a name="ln321">    float *out = (float *)ovoid + (size_t)ch * width * j;</a>
<a name="ln322">    for(int i = 0; i &lt; width; i++, in += ch, out += ch)</a>
<a name="ln323">    {</a>
<a name="ln324">      out[0] = clipnan(in[0]);</a>
<a name="ln325">      out[1] = clipnan(in[1]);</a>
<a name="ln326">      out[2] = clipnan(in[2]);</a>
<a name="ln327">    }</a>
<a name="ln328">  }</a>
<a name="ln329"> </a>
<a name="ln330">  if(nearest_color == NULL) return;</a>
<a name="ln331"> </a>
<a name="ln332">  const float f = levels - 1;</a>
<a name="ln333">  const float rf = 1.0 / f;</a>
<a name="ln334">  float err[4];</a>
<a name="ln335"> </a>
<a name="ln336">  // dither without error diffusion on very tiny images</a>
<a name="ln337">  if(width &lt; 3 || height &lt; 3)</a>
<a name="ln338">  {</a>
<a name="ln339">    for(int j = 0; j &lt; height; j++)</a>
<a name="ln340">    {</a>
<a name="ln341">      float *out = ((float *)ovoid) + (size_t)ch * j * width;</a>
<a name="ln342">      for(int i = 0; i &lt; width; i++) nearest_color(out + ch * i, err, f, rf);</a>
<a name="ln343">    }</a>
<a name="ln344"> </a>
<a name="ln345">    if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln346">    return;</a>
<a name="ln347">  }</a>
<a name="ln348"> </a>
<a name="ln349">  // floyd-steinberg dithering follows here</a>
<a name="ln350"> </a>
<a name="ln351">  // first height-1 rows</a>
<a name="ln352">  for(int j = 0; j &lt; height - 1; j++)</a>
<a name="ln353">  {</a>
<a name="ln354">    float *out = ((float *)ovoid) + (size_t)ch * j * width;</a>
<a name="ln355"> </a>
<a name="ln356">    // first column</a>
<a name="ln357">    nearest_color(out, err, f, rf);</a>
<a name="ln358">    _diffuse_error(out + ch, err, 7.0f / 16.0f);</a>
<a name="ln359">    _diffuse_error(out + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln360">    _diffuse_error(out + ch * (width + 1), err, 1.0f / 16.0f);</a>
<a name="ln361"> </a>
<a name="ln362"> </a>
<a name="ln363">    // main part of image</a>
<a name="ln364">    for(int i = 1; i &lt; width - 1; i++)</a>
<a name="ln365">    {</a>
<a name="ln366">      nearest_color(out + ch * i, err, f, rf);</a>
<a name="ln367">      _diffuse_error(out + ch * (i + 1), err, 7.0f / 16.0f);</a>
<a name="ln368">      _diffuse_error(out + ch * (i - 1) + ch * width, err, 3.0f / 16.0f);</a>
<a name="ln369">      _diffuse_error(out + ch * i + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln370">      _diffuse_error(out + ch * (i + 1) + ch * width, err, 1.0f / 16.0f);</a>
<a name="ln371">    }</a>
<a name="ln372"> </a>
<a name="ln373">    // last column</a>
<a name="ln374">    nearest_color(out + ch * (width - 1), err, f, rf);</a>
<a name="ln375">    _diffuse_error(out + ch * (width - 2) + ch * width, err, 3.0f / 16.0f);</a>
<a name="ln376">    _diffuse_error(out + ch * (width - 1) + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln377">  }</a>
<a name="ln378"> </a>
<a name="ln379">  // last row</a>
<a name="ln380">  {</a>
<a name="ln381">    float *out = ((float *)ovoid) + (size_t)ch * (height - 1) * width;</a>
<a name="ln382"> </a>
<a name="ln383">    // lower left pixel</a>
<a name="ln384">    nearest_color(out, err, f, rf);</a>
<a name="ln385">    _diffuse_error(out + ch, err, 7.0f / 16.0f);</a>
<a name="ln386"> </a>
<a name="ln387">    // main part of last row</a>
<a name="ln388">    for(int i = 1; i &lt; width - 1; i++)</a>
<a name="ln389">    {</a>
<a name="ln390">      nearest_color(out + ch * i, err, f, rf);</a>
<a name="ln391">      _diffuse_error(out + ch * (i + 1), err, 7.0f / 16.0f);</a>
<a name="ln392">    }</a>
<a name="ln393"> </a>
<a name="ln394">    // lower right pixel</a>
<a name="ln395">    nearest_color(out + ch * (width - 1), err, f, rf);</a>
<a name="ln396"> </a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  // copy alpha channel if needed</a>
<a name="ln400">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln401">}</a>
<a name="ln402"> </a>
<a name="ln403">#if defined(__SSE2__)</a>
<a name="ln404">static void process_floyd_steinberg_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln405">                                         const void *const ivoid, void *const ovoid,</a>
<a name="ln406">                                         const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln407">{</a>
<a name="ln408">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln409"> </a>
<a name="ln410">  const int width = roi_in-&gt;width;</a>
<a name="ln411">  const int height = roi_in-&gt;height;</a>
<a name="ln412">  const int ch = piece-&gt;colors;</a>
<a name="ln413">  const float scale = roi_in-&gt;scale / piece-&gt;iscale;</a>
<a name="ln414">  const int l1 = floorf(1.0f + dt_log2f(1.0f / scale));</a>
<a name="ln415"> </a>
<a name="ln416">  _find_nearest_color_sse *nearest_color = NULL;</a>
<a name="ln417">  unsigned int levels = 1;</a>
<a name="ln418">  int bds = (piece-&gt;pipe-&gt;type != DT_DEV_PIXELPIPE_EXPORT) ? l1 * l1 : 1;</a>
<a name="ln419"> </a>
<a name="ln420">  switch(data-&gt;dither_type)</a>
<a name="ln421">  {</a>
<a name="ln422">    case DITHER_FS1BIT:</a>
<a name="ln423">      nearest_color = _find_nearest_color_n_levels_gray_sse;</a>
<a name="ln424">      levels = MAX(2, MIN(bds + 1, 256));</a>
<a name="ln425">      break;</a>
<a name="ln426">    case DITHER_FS4BIT_GRAY:</a>
<a name="ln427">      nearest_color = _find_nearest_color_n_levels_gray_sse;</a>
<a name="ln428">      levels = MAX(16, MIN(15 * bds + 1, 256));</a>
<a name="ln429">      break;</a>
<a name="ln430">    case DITHER_FS8BIT:</a>
<a name="ln431">      nearest_color = _find_nearest_color_n_levels_rgb_sse2;</a>
<a name="ln432">      levels = 256;</a>
<a name="ln433">      break;</a>
<a name="ln434">    case DITHER_FS16BIT:</a>
<a name="ln435">      nearest_color = _find_nearest_color_n_levels_rgb_sse2;</a>
<a name="ln436">      levels = 65536;</a>
<a name="ln437">      break;</a>
<a name="ln438">    case DITHER_FSAUTO:</a>
<a name="ln439">      switch(piece-&gt;pipe-&gt;levels &amp; IMAGEIO_CHANNEL_MASK)</a>
<a name="ln440">      {</a>
<a name="ln441">        case IMAGEIO_RGB:</a>
<a name="ln442">          nearest_color = _find_nearest_color_n_levels_rgb_sse2;</a>
<a name="ln443">          break;</a>
<a name="ln444">        case IMAGEIO_GRAY:</a>
<a name="ln445">          nearest_color = _find_nearest_color_n_levels_gray_sse;</a>
<a name="ln446">          break;</a>
<a name="ln447">      }</a>
<a name="ln448"> </a>
<a name="ln449">      switch(piece-&gt;pipe-&gt;levels &amp; IMAGEIO_PREC_MASK)</a>
<a name="ln450">      {</a>
<a name="ln451">        case IMAGEIO_INT8:</a>
<a name="ln452">          levels = 256;</a>
<a name="ln453">          break;</a>
<a name="ln454">        case IMAGEIO_INT12:</a>
<a name="ln455">          levels = 4096;</a>
<a name="ln456">          break;</a>
<a name="ln457">        case IMAGEIO_INT16:</a>
<a name="ln458">          levels = 65536;</a>
<a name="ln459">          break;</a>
<a name="ln460">        case IMAGEIO_BW:</a>
<a name="ln461">          levels = 2;</a>
<a name="ln462">          break;</a>
<a name="ln463">        case IMAGEIO_INT32:</a>
<a name="ln464">        case IMAGEIO_FLOAT:</a>
<a name="ln465">        default:</a>
<a name="ln466">          nearest_color = NULL;</a>
<a name="ln467">          break;</a>
<a name="ln468">      }</a>
<a name="ln469">      // no automatic dithering for preview and thumbnail</a>
<a name="ln470">      if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_THUMBNAIL)</a>
<a name="ln471">        nearest_color = NULL;</a>
<a name="ln472">      break;</a>
<a name="ln473">    case DITHER_RANDOM:</a>
<a name="ln474">      // this function won't ever be called for that type</a>
<a name="ln475">      // instead, process_random() will be called</a>
<a name="ln476">      __builtin_unreachable();</a>
<a name="ln477">      break;</a>
<a name="ln478">  }</a>
<a name="ln479"> </a>
<a name="ln480">#ifdef _OPENMP</a>
<a name="ln481">#pragma omp parallel for default(none) \</a>
<a name="ln482">  dt_omp_firstprivate(ch, height, ivoid, ovoid, width) \</a>
<a name="ln483">  schedule(static)</a>
<a name="ln484">#endif</a>
<a name="ln485">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln486">  {</a>
<a name="ln487">    const float *in = (const float *)ivoid + (size_t)ch * width * j;</a>
<a name="ln488">    float *out = (float *)ovoid + (size_t)ch * width * j;</a>
<a name="ln489">    for(int i = 0; i &lt; width; i++, in += ch, out += ch)</a>
<a name="ln490">    {</a>
<a name="ln491">      out[0] = clipnan(in[0]);</a>
<a name="ln492">      out[1] = clipnan(in[1]);</a>
<a name="ln493">      out[2] = clipnan(in[2]);</a>
<a name="ln494">    }</a>
<a name="ln495">  }</a>
<a name="ln496"> </a>
<a name="ln497">  if(nearest_color == NULL) return;</a>
<a name="ln498"> </a>
<a name="ln499">  const float f = levels - 1;</a>
<a name="ln500">  const float rf = 1.0 / f;</a>
<a name="ln501">  __m128 err;</a>
<a name="ln502"> </a>
<a name="ln503">  // dither without error diffusion on very tiny images</a>
<a name="ln504">  if(width &lt; 3 || height &lt; 3)</a>
<a name="ln505">  {</a>
<a name="ln506">    for(int j = 0; j &lt; height; j++)</a>
<a name="ln507">    {</a>
<a name="ln508">      float *out = ((float *)ovoid) + (size_t)ch * j * width;</a>
<a name="ln509">      for(int i = 0; i &lt; width; i++) (void)nearest_color(out + ch * i, f, rf);</a>
<a name="ln510">    }</a>
<a name="ln511"> </a>
<a name="ln512">    if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln513">    return;</a>
<a name="ln514">  }</a>
<a name="ln515"> </a>
<a name="ln516">  // floyd-steinberg dithering follows here</a>
<a name="ln517"> </a>
<a name="ln518">  // first height-1 rows</a>
<a name="ln519">  for(int j = 0; j &lt; height - 1; j++)</a>
<a name="ln520">  {</a>
<a name="ln521">    float *out = ((float *)ovoid) + (size_t)ch * j * width;</a>
<a name="ln522"> </a>
<a name="ln523">    // first column</a>
<a name="ln524">    err = nearest_color(out, f, rf);</a>
<a name="ln525">    _diffuse_error_sse(out + ch, err, 7.0f / 16.0f);</a>
<a name="ln526">    _diffuse_error_sse(out + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln527">    _diffuse_error_sse(out + ch * (width + 1), err, 1.0f / 16.0f);</a>
<a name="ln528"> </a>
<a name="ln529"> </a>
<a name="ln530">    // main part of image</a>
<a name="ln531">    for(int i = 1; i &lt; width - 1; i++)</a>
<a name="ln532">    {</a>
<a name="ln533">      err = nearest_color(out + ch * i, f, rf);</a>
<a name="ln534">      _diffuse_error_sse(out + ch * (i + 1), err, 7.0f / 16.0f);</a>
<a name="ln535">      _diffuse_error_sse(out + ch * (i - 1) + ch * width, err, 3.0f / 16.0f);</a>
<a name="ln536">      _diffuse_error_sse(out + ch * i + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln537">      _diffuse_error_sse(out + ch * (i + 1) + ch * width, err, 1.0f / 16.0f);</a>
<a name="ln538">    }</a>
<a name="ln539"> </a>
<a name="ln540">    // last column</a>
<a name="ln541">    err = nearest_color(out + ch * (width - 1), f, rf);</a>
<a name="ln542">    _diffuse_error_sse(out + ch * (width - 2) + ch * width, err, 3.0f / 16.0f);</a>
<a name="ln543">    _diffuse_error_sse(out + ch * (width - 1) + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln544">  }</a>
<a name="ln545"> </a>
<a name="ln546">  // last row</a>
<a name="ln547">  {</a>
<a name="ln548">    float *out = ((float *)ovoid) + (size_t)ch * (height - 1) * width;</a>
<a name="ln549"> </a>
<a name="ln550">    // lower left pixel</a>
<a name="ln551">    err = nearest_color(out, f, rf);</a>
<a name="ln552">    _diffuse_error_sse(out + ch, err, 7.0f / 16.0f);</a>
<a name="ln553"> </a>
<a name="ln554">    // main part of last row</a>
<a name="ln555">    for(int i = 1; i &lt; width - 1; i++)</a>
<a name="ln556">    {</a>
<a name="ln557">      err = nearest_color(out + ch * i, f, rf);</a>
<a name="ln558">      _diffuse_error_sse(out + ch * (i + 1), err, 7.0f / 16.0f);</a>
<a name="ln559">    }</a>
<a name="ln560"> </a>
<a name="ln561">    // lower right pixel</a>
<a name="ln562">    (void)nearest_color(out + ch * (width - 1), f, rf);</a>
<a name="ln563"> </a>
<a name="ln564">  }</a>
<a name="ln565"> </a>
<a name="ln566">  // copy alpha channel if needed</a>
<a name="ln567">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln568">}</a>
<a name="ln569">#endif</a>
<a name="ln570"> </a>
<a name="ln571"> </a>
<a name="ln572">static void encrypt_tea(unsigned int *arg)</a>
<a name="ln573">{</a>
<a name="ln574">  const unsigned int key[] = { 0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e };</a>
<a name="ln575">  unsigned int v0 = arg[0], v1 = arg[1];</a>
<a name="ln576">  unsigned int sum = 0;</a>
<a name="ln577">  unsigned int delta = 0x9e3779b9;</a>
<a name="ln578">  for(int i = 0; i &lt; TEA_ROUNDS; i++)</a>
<a name="ln579">  {</a>
<a name="ln580">    sum += delta;</a>
<a name="ln581">    v0 += ((v1 &lt;&lt; 4) + key[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + key[1]);</a>
<a name="ln582">    v1 += ((v0 &lt;&lt; 4) + key[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + key[3]);</a>
<a name="ln583">  }</a>
<a name="ln584">  arg[0] = v0;</a>
<a name="ln585">  arg[1] = v1;</a>
<a name="ln586">}</a>
<a name="ln587"> </a>
<a name="ln588"> </a>
<a name="ln589">static float tpdf(unsigned int urandom)</a>
<a name="ln590">{</a>
<a name="ln591">  float frandom = (float)urandom / 0xFFFFFFFFu;</a>
<a name="ln592"> </a>
<a name="ln593">  return (frandom &lt; 0.5f ? (sqrtf(2.0f * frandom) - 1.0f) : (1.0f - sqrtf(2.0f * (1.0f - frandom))));</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596"> </a>
<a name="ln597">static void process_random(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln598">                           const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln599">                           const dt_iop_roi_t *const roi_out)</a>
<a name="ln600">{</a>
<a name="ln601">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln602"> </a>
<a name="ln603">  const int width = roi_in-&gt;width;</a>
<a name="ln604">  const int height = roi_in-&gt;height;</a>
<a name="ln605">  const int ch = piece-&gt;colors;</a>
<a name="ln606"> </a>
<a name="ln607">  const float dither = powf(2.0f, data-&gt;random.damping / 10.0f);</a>
<a name="ln608"> </a>
<a name="ln609">  unsigned int *const tea_states = calloc(2 * dt_get_num_threads(), sizeof(unsigned int));</a>
<a name="ln610"> </a>
<a name="ln611">#ifdef _OPENMP</a>
<a name="ln612">#pragma omp parallel for default(none) \</a>
<a name="ln613">  dt_omp_firstprivate(ch, dither, height, ivoid, ovoid, tea_states, width) \</a>
<a name="ln614">  schedule(static)</a>
<a name="ln615">#endif</a>
<a name="ln616">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln617">  {</a>
<a name="ln618">    const size_t k = (size_t)ch * width * j;</a>
<a name="ln619">    const float *in = (const float *)ivoid + k;</a>
<a name="ln620">    float *out = (float *)ovoid + k;</a>
<a name="ln621">    unsigned int *tea_state = tea_states + 2 * dt_get_thread_num();</a>
<a name="ln622">    tea_state[0] = j * height + dt_get_thread_num();</a>
<a name="ln623">    for(int i = 0; i &lt; width; i++, in += ch, out += ch)</a>
<a name="ln624">    {</a>
<a name="ln625">      encrypt_tea(tea_state);</a>
<a name="ln626">      float dith = dither * tpdf(tea_state[0]);</a>
<a name="ln627"> </a>
<a name="ln628">      out[0] = CLIP(in[0] + dith);</a>
<a name="ln629">      out[1] = CLIP(in[1] + dith);</a>
<a name="ln630">      out[2] = CLIP(in[2] + dith);</a>
<a name="ln631">    }</a>
<a name="ln632">  }</a>
<a name="ln633"> </a>
<a name="ln634">  free(tea_states);</a>
<a name="ln635"> </a>
<a name="ln636">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, width, height);</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639"> </a>
<a name="ln640">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln641">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln642">{</a>
<a name="ln643">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln644"> </a>
<a name="ln645">  if(data-&gt;dither_type == DITHER_RANDOM)</a>
<a name="ln646">    process_random(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln647">  else</a>
<a name="ln648">    process_floyd_steinberg(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651">#if defined(__SSE2__)</a>
<a name="ln652">void process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln653">                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln654">{</a>
<a name="ln655">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln656"> </a>
<a name="ln657">  if(data-&gt;dither_type == DITHER_RANDOM)</a>
<a name="ln658">    process_random(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln659">  else</a>
<a name="ln660">    process_floyd_steinberg_sse2(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln661">}</a>
<a name="ln662">#endif</a>
<a name="ln663"> </a>
<a name="ln664">static void method_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln665">{</a>
<a name="ln666">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln667">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln668">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln669">  dt_iop_dither_gui_data_t *g = (dt_iop_dither_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln670">  p-&gt;dither_type = dt_bauhaus_combobox_get(widget);</a>
<a name="ln671"> </a>
<a name="ln672">  if(p-&gt;dither_type == DITHER_RANDOM)</a>
<a name="ln673">    gtk_widget_show(GTK_WIDGET(g-&gt;random));</a>
<a name="ln674">  else</a>
<a name="ln675">    gtk_widget_hide(GTK_WIDGET(g-&gt;random));</a>
<a name="ln676"> </a>
<a name="ln677">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">#if 0</a>
<a name="ln681">static void</a>
<a name="ln682">radius_callback (GtkWidget *slider, gpointer user_data)</a>
<a name="ln683">{</a>
<a name="ln684">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln685">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln686">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln687">  p-&gt;random.radius = dt_bauhaus_slider_get(slider);</a>
<a name="ln688">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln689">}</a>
<a name="ln690">#endif</a>
<a name="ln691"> </a>
<a name="ln692">static void damping_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln693">{</a>
<a name="ln694">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln695">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln696">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln697">  p-&gt;random.damping = dt_bauhaus_slider_get(slider);</a>
<a name="ln698">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">#if 0</a>
<a name="ln702">static void</a>
<a name="ln703">range_callback (GtkWidget *slider, gpointer user_data)</a>
<a name="ln704">{</a>
<a name="ln705">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln706">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln707">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln708">  p-&gt;random.range[0] = dtgtk_gradient_slider_multivalue_get_value(DTGTK_GRADIENT_SLIDER(slider), 0);</a>
<a name="ln709">  p-&gt;random.range[1] = dtgtk_gradient_slider_multivalue_get_value(DTGTK_GRADIENT_SLIDER(slider), 1);</a>
<a name="ln710">  p-&gt;random.range[2] = dtgtk_gradient_slider_multivalue_get_value(DTGTK_GRADIENT_SLIDER(slider), 2);</a>
<a name="ln711">  p-&gt;random.range[3] = dtgtk_gradient_slider_multivalue_get_value(DTGTK_GRADIENT_SLIDER(slider), 3);</a>
<a name="ln712">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln713">}</a>
<a name="ln714">#endif</a>
<a name="ln715"> </a>
<a name="ln716">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln717">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln718">{</a>
<a name="ln719">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)p1;</a>
<a name="ln720">  dt_iop_dither_data_t *d = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln721"> </a>
<a name="ln722">  d-&gt;dither_type = p-&gt;dither_type;</a>
<a name="ln723">  memcpy(&amp;(d-&gt;random.range), &amp;(p-&gt;random.range), sizeof(p-&gt;random.range));</a>
<a name="ln724">  d-&gt;random.radius = p-&gt;random.radius;</a>
<a name="ln725">  d-&gt;random.damping = p-&gt;random.damping;</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln729">{</a>
<a name="ln730">  piece-&gt;data = malloc(sizeof(dt_iop_dither_data_t));</a>
<a name="ln731">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln732">}</a>
<a name="ln733"> </a>
<a name="ln734">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln735">{</a>
<a name="ln736">  free(piece-&gt;data);</a>
<a name="ln737">  piece-&gt;data = NULL;</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740"> </a>
<a name="ln741">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln742">{</a>
<a name="ln743">  dt_iop_module_t *module = (dt_iop_module_t *)self;</a>
<a name="ln744">  dt_iop_dither_gui_data_t *g = (dt_iop_dither_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln745">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)module-&gt;params;</a>
<a name="ln746">  dt_bauhaus_combobox_set(g-&gt;dither_type, p-&gt;dither_type);</a>
<a name="ln747">#if 0</a>
<a name="ln748">  dt_bauhaus_slider_set(g-&gt;radius, p-&gt;random.radius);</a>
<a name="ln749"> </a>
<a name="ln750">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[0], 0);</a>
<a name="ln751">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[1], 1);</a>
<a name="ln752">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[2], 2);</a>
<a name="ln753">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[3], 3);</a>
<a name="ln754">#endif</a>
<a name="ln755"> </a>
<a name="ln756">  dt_bauhaus_slider_set(g-&gt;damping, p-&gt;random.damping);</a>
<a name="ln757"> </a>
<a name="ln758">  if(p-&gt;dither_type == DITHER_RANDOM)</a>
<a name="ln759">    gtk_widget_show(GTK_WIDGET(g-&gt;random));</a>
<a name="ln760">  else</a>
<a name="ln761">    gtk_widget_hide(GTK_WIDGET(g-&gt;random));</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764">void init(dt_iop_module_t *module)</a>
<a name="ln765">{</a>
<a name="ln766">  module-&gt;params = calloc(1, sizeof(dt_iop_dither_params_t));</a>
<a name="ln767">  module-&gt;default_params = calloc(1, sizeof(dt_iop_dither_params_t));</a>
<a name="ln768">  module-&gt;default_enabled = 0;</a>
<a name="ln769">  module-&gt;params_size = sizeof(dt_iop_dither_params_t);</a>
<a name="ln770">  module-&gt;gui_data = NULL;</a>
<a name="ln771">  dt_iop_dither_params_t tmp</a>
<a name="ln772">      = (dt_iop_dither_params_t){ DITHER_FSAUTO, 0, { 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }, -200.0f } };</a>
<a name="ln773">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_dither_params_t));</a>
<a name="ln774">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_dither_params_t));</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777"> </a>
<a name="ln778">void cleanup(dt_iop_module_t *module)</a>
<a name="ln779">{</a>
<a name="ln780">  free(module-&gt;params);</a>
<a name="ln781">  module-&gt;params = NULL;</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln785">{</a>
<a name="ln786">  self-&gt;gui_data = malloc(sizeof(dt_iop_dither_gui_data_t));</a>
<a name="ln787">  dt_iop_dither_gui_data_t *g = (dt_iop_dither_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln788">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln789"> </a>
<a name="ln790">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln791">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln792">  g-&gt;random = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln793"> </a>
<a name="ln794">  g-&gt;dither_type = dt_bauhaus_combobox_new(self);</a>
<a name="ln795">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;random&quot;));</a>
<a name="ln796">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg 1-bit B&amp;W&quot;));</a>
<a name="ln797">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg 4-bit gray&quot;));</a>
<a name="ln798">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg 8-bit RGB&quot;));</a>
<a name="ln799">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg 16-bit RGB&quot;));</a>
<a name="ln800">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg auto&quot;));</a>
<a name="ln801">  dt_bauhaus_widget_set_label(g-&gt;dither_type, NULL, _(&quot;method&quot;));</a>
<a name="ln802"> </a>
<a name="ln803">#if 0</a>
<a name="ln804">  g-&gt;radius = dt_bauhaus_slider_new_with_range(self, 0.0, 200.0, 0.1, p-&gt;random.radius, 2);</a>
<a name="ln805">  gtk_widget_set_tooltip_text(g-&gt;radius, _(&quot;radius for blurring step&quot;));</a>
<a name="ln806">  dt_bauhaus_widget_set_label(g-&gt;radius, NULL, _(&quot;radius&quot;));</a>
<a name="ln807"> </a>
<a name="ln808">  g-&gt;range = dtgtk_gradient_slider_multivalue_new(4);</a>
<a name="ln809">  dtgtk_gradient_slider_multivalue_set_marker(DTGTK_GRADIENT_SLIDER(g-&gt;range), GRADIENT_SLIDER_MARKER_LOWER_OPEN_BIG, 0);</a>
<a name="ln810">  dtgtk_gradient_slider_multivalue_set_marker(DTGTK_GRADIENT_SLIDER(g-&gt;range), GRADIENT_SLIDER_MARKER_UPPER_FILLED_BIG, 1);</a>
<a name="ln811">  dtgtk_gradient_slider_multivalue_set_marker(DTGTK_GRADIENT_SLIDER(g-&gt;range), GRADIENT_SLIDER_MARKER_UPPER_FILLED_BIG, 2);</a>
<a name="ln812">  dtgtk_gradient_slider_multivalue_set_marker(DTGTK_GRADIENT_SLIDER(g-&gt;range), GRADIENT_SLIDER_MARKER_LOWER_OPEN_BIG, 3);</a>
<a name="ln813">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[0], 0);</a>
<a name="ln814">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[1], 1);</a>
<a name="ln815">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[2], 2);</a>
<a name="ln816">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[3], 3);</a>
<a name="ln817">  gtk_widget_set_tooltip_text(g-&gt;range, _(&quot;the gradient range where to apply random dither&quot;));</a>
<a name="ln818">  g-&gt;range_label = gtk_label_new(_(&quot;gradient range&quot;));</a>
<a name="ln819"> </a>
<a name="ln820">  GtkWidget *rlabel = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);</a>
<a name="ln821">  gtk_box_pack_start(GTK_BOX(rlabel), GTK_WIDGET(g-&gt;range_label), FALSE, FALSE, 0);</a>
<a name="ln822">#endif</a>
<a name="ln823"> </a>
<a name="ln824">  g-&gt;damping = dt_bauhaus_slider_new_with_range(self, -200.0, 0.0, 1.0, p-&gt;random.damping, 3);</a>
<a name="ln825">  gtk_widget_set_tooltip_text(g-&gt;damping, _(&quot;damping level of random dither&quot;));</a>
<a name="ln826">  dt_bauhaus_widget_set_label(g-&gt;damping, NULL, _(&quot;damping&quot;));</a>
<a name="ln827">  dt_bauhaus_slider_set_format(g-&gt;damping, &quot;%.0fdB&quot;);</a>
<a name="ln828"> </a>
<a name="ln829">#if 0</a>
<a name="ln830">  gtk_box_pack_start(GTK_BOX(g-&gt;random), g-&gt;radius, TRUE, TRUE, 0);</a>
<a name="ln831">  gtk_box_pack_start(GTK_BOX(g-&gt;random), rlabel, TRUE, TRUE, 0);</a>
<a name="ln832">  gtk_box_pack_start(GTK_BOX(g-&gt;random), g-&gt;range, TRUE, TRUE, 0);</a>
<a name="ln833">#endif</a>
<a name="ln834">  gtk_box_pack_start(GTK_BOX(g-&gt;random), g-&gt;damping, TRUE, TRUE, 0);</a>
<a name="ln835"> </a>
<a name="ln836">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;dither_type, TRUE, TRUE, 0);</a>
<a name="ln837">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;random, TRUE, TRUE, 0);</a>
<a name="ln838"> </a>
<a name="ln839">  g_signal_connect(G_OBJECT(g-&gt;dither_type), &quot;value-changed&quot;, G_CALLBACK(method_callback), self);</a>
<a name="ln840">#if 0</a>
<a name="ln841">  g_signal_connect (G_OBJECT (g-&gt;radius), &quot;value-changed&quot;,</a>
<a name="ln842">                    G_CALLBACK (radius_callback), self);</a>
<a name="ln843">  g_signal_connect (G_OBJECT (g-&gt;range), &quot;value-changed&quot;,</a>
<a name="ln844">                    G_CALLBACK (range_callback), self);</a>
<a name="ln845">#endif</a>
<a name="ln846">  g_signal_connect(G_OBJECT(g-&gt;damping), &quot;value-changed&quot;, G_CALLBACK(damping_callback), self);</a>
<a name="ln847">}</a>
<a name="ln848"> </a>
<a name="ln849">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln850">{</a>
<a name="ln851">  free(self-&gt;gui_data);</a>
<a name="ln852">  self-&gt;gui_data = NULL;</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln856">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln857">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="621"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'tea_states' pointer in the 'tea_states + 2 * dt_get_thread_num()' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 621, 609.</p></div>
<div class="balloon" rel="773"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 773, 766.</p></div>
<div class="balloon" rel="774"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 774, 767.</p></div>
<div class="balloon" rel="792"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 792, 786.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
