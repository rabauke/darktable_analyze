
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    RawSpeed - RAW file decoder.</a>
<a name="ln3"> </a>
<a name="ln4">    Copyright (C) 2016 Alexey Danilchenko</a>
<a name="ln5">    Copyright (C) 2016 Alex Tutubalin</a>
<a name="ln6">    Copyright (C) 2017 Uwe MÃ¼ssel</a>
<a name="ln7">    Copyright (C) 2017 Roman Lebedev</a>
<a name="ln8"> </a>
<a name="ln9">    This library is free software; you can redistribute it and/or</a>
<a name="ln10">    modify it under the terms of the GNU Lesser General Public</a>
<a name="ln11">    License as published by the Free Software Foundation; either</a>
<a name="ln12">    version 2.1 of the License, or (at your option) any later version.</a>
<a name="ln13"> </a>
<a name="ln14">    This library is distributed in the hope that it will be useful,</a>
<a name="ln15">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln16">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln17">    Lesser General Public License for more details.</a>
<a name="ln18"> </a>
<a name="ln19">    You should have received a copy of the GNU Lesser General Public</a>
<a name="ln20">    License along with this library; if not, write to the Free Software</a>
<a name="ln21">    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</a>
<a name="ln22">*/</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;rawspeedconfig.h&quot;</a>
<a name="ln25">#include &quot;decompressors/FujiDecompressor.h&quot;</a>
<a name="ln26">#include &quot;common/Common.h&quot;                // for uint16_t</a>
<a name="ln27">#include &quot;common/Point.h&quot;                 // for iPoint2D</a>
<a name="ln28">#include &quot;common/RawImage.h&quot;              // for RawImage</a>
<a name="ln29">#include &quot;decoders/RawDecoderException.h&quot; // for ThrowRDE</a>
<a name="ln30">#include &quot;io/Endianness.h&quot;                // for Endianness</a>
<a name="ln31">#include &quot;metadata/ColorFilterArray.h&quot;    // for CFA_BLUE</a>
<a name="ln32">#include &lt;algorithm&gt;                      // for fill, min</a>
<a name="ln33">#include &lt;cmath&gt;                          // for abs</a>
<a name="ln34">#include &lt;cstdlib&gt;                        // for abs, size_t</a>
<a name="ln35">#include &lt;cstring&gt;                        // for memcpy</a>
<a name="ln36"> </a>
<a name="ln37">namespace rawspeed {</a>
<a name="ln38"> </a>
<a name="ln39">FujiDecompressor::FujiDecompressor(const RawImage&amp; img, ByteStream input_)</a>
<a name="ln40">    : mRaw(img), input(std::move(input_)) {</a>
<a name="ln41">  if (mRaw-&gt;getCpp() != 1 || mRaw-&gt;getDataType() != TYPE_USHORT16 ||</a>
<a name="ln42">      mRaw-&gt;getBpp() != 2)</a>
<a name="ln43">    ThrowRDE(&quot;Unexpected component count / data type&quot;);</a>
<a name="ln44"> </a>
<a name="ln45">  input.setByteOrder(Endianness::big);</a>
<a name="ln46"> </a>
<a name="ln47">  header = FujiHeader(&amp;input);</a>
<a name="ln48">  if (!header)</a>
<a name="ln49">    ThrowRDE(&quot;compressed RAF header check&quot;);</a>
<a name="ln50"> </a>
<a name="ln51">  if (mRaw-&gt;dim != iPoint2D(header.raw_width, header.raw_height))</a>
<a name="ln52">    ThrowRDE(&quot;RAF header specifies different dimensions!&quot;);</a>
<a name="ln53"> </a>
<a name="ln54">  if (12 == header.raw_bits) {</a>
<a name="ln55">    ThrowRDE(&quot;Aha, finally, a 12-bit compressed RAF! Please consider providing &quot;</a>
<a name="ln56">             &quot;samples on &lt;https://raw.pixls.us/&gt;, thanks!&quot;);</a>
<a name="ln57">  }</a>
<a name="ln58"> </a>
<a name="ln59">  for (int i = 0; i &lt; 6; i++) {</a>
<a name="ln60">    for (int j = 0; j &lt; 6; j++) {</a>
<a name="ln61">      const CFAColor c = mRaw-&gt;cfa.getColorAt(j, i);</a>
<a name="ln62">      switch (c) {</a>
<a name="ln63">      case CFA_RED:</a>
<a name="ln64">      case CFA_GREEN:</a>
<a name="ln65">      case CFA_BLUE:</a>
<a name="ln66">        CFA[i][j] = c;</a>
<a name="ln67">        break;</a>
<a name="ln68">      default:</a>
<a name="ln69">        ThrowRDE(&quot;Got unexpected color %u&quot;, c);</a>
<a name="ln70">      }</a>
<a name="ln71">    }</a>
<a name="ln72">  }</a>
<a name="ln73"> </a>
<a name="ln74">  fuji_compressed_load_raw();</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">FujiDecompressor::fuji_compressed_params::fuji_compressed_params(</a>
<a name="ln78">    const FujiDecompressor&amp; d) {</a>
<a name="ln79">  int cur_val;</a>
<a name="ln80">  char* qt;</a>
<a name="ln81"> </a>
<a name="ln82">  if ((d.header.block_size % 3 &amp;&amp; d.header.raw_type == 16) ||</a>
<a name="ln83">      (d.header.block_size &amp; 1 &amp;&amp; d.header.raw_type == 0)) {</a>
<a name="ln84">    ThrowRDE(&quot;fuji_block_checks&quot;);</a>
<a name="ln85">  }</a>
<a name="ln86"> </a>
<a name="ln87">  q_table.resize(32768);</a>
<a name="ln88"> </a>
<a name="ln89">  if (d.header.raw_type == 16) {</a>
<a name="ln90">    line_width = (d.header.block_size * 2) / 3;</a>
<a name="ln91">  } else {</a>
<a name="ln92">    line_width = d.header.block_size &gt;&gt; 1;</a>
<a name="ln93">  }</a>
<a name="ln94"> </a>
<a name="ln95">  q_point[0] = 0;</a>
<a name="ln96">  q_point[1] = 0x12;</a>
<a name="ln97">  q_point[2] = 0x43;</a>
<a name="ln98">  q_point[3] = 0x114;</a>
<a name="ln99">  q_point[4] = (1 &lt;&lt; d.header.raw_bits) - 1;</a>
<a name="ln100">  min_value = 0x40;</a>
<a name="ln101"> </a>
<a name="ln102">  cur_val = -q_point[4];</a>
<a name="ln103"> </a>
<a name="ln104">  for (qt = &amp;q_table[0]; cur_val &lt;= q_point[4]; ++qt, ++cur_val) {</a>
<a name="ln105">    if (cur_val &lt;= -q_point[3]) {</a>
<a name="ln106">      *qt = -4;</a>
<a name="ln107">    } else if (cur_val &lt;= -q_point[2]) {</a>
<a name="ln108">      *qt = -3;</a>
<a name="ln109">    } else if (cur_val &lt;= -q_point[1]) {</a>
<a name="ln110">      *qt = -2;</a>
<a name="ln111">    } else if (cur_val &lt; 0) {</a>
<a name="ln112">      *qt = -1;</a>
<a name="ln113">    } else if (cur_val == 0) {</a>
<a name="ln114">      *qt = 0;</a>
<a name="ln115">    } else if (cur_val &lt; q_point[1]) {</a>
<a name="ln116">      *qt = 1;</a>
<a name="ln117">    } else if (cur_val &lt; q_point[2]) {</a>
<a name="ln118">      *qt = 2;</a>
<a name="ln119">    } else if (cur_val &lt; q_point[3]) {</a>
<a name="ln120">      *qt = 3;</a>
<a name="ln121">    } else {</a>
<a name="ln122">      *qt = 4;</a>
<a name="ln123">    }</a>
<a name="ln124">  }</a>
<a name="ln125"> </a>
<a name="ln126">  // populting gradients</a>
<a name="ln127">  if (q_point[4] == 0x3FFF) {</a>
<a name="ln128">    total_values = 0x4000;</a>
<a name="ln129">    raw_bits = 14;</a>
<a name="ln130">    max_bits = 56;</a>
<a name="ln131">    maxDiff = 256;</a>
<a name="ln132">  } else if (q_point[4] == 0xFFF) {</a>
<a name="ln133">    ThrowRDE(&quot;Aha, finally, a 12-bit compressed RAF! Please consider providing &quot;</a>
<a name="ln134">             &quot;samples on &lt;https://raw.pixls.us/&gt;, thanks!&quot;);</a>
<a name="ln135"> </a>
<a name="ln136">    /* kept for future, once there is a sample.</a>
<a name="ln137">     total_values = 4096;</a>
<a name="ln138">     raw_bits = 12;</a>
<a name="ln139">     max_bits = 48;</a>
<a name="ln140">     maxDiff = 64;</a>
<a name="ln141">    */</a>
<a name="ln142">  } else {</a>
<a name="ln143">    ThrowRDE(&quot;FUJI q_point&quot;);</a>
<a name="ln144">  }</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">void FujiDecompressor::fuji_compressed_block::reset(</a>
<a name="ln148">    const fuji_compressed_params* params) {</a>
<a name="ln149">  const bool reInit = !linealloc.empty();</a>
<a name="ln150"> </a>
<a name="ln151">  linealloc.resize(_ltotal * (params-&gt;line_width + 2), 0);</a>
<a name="ln152"> </a>
<a name="ln153">  if (reInit)</a>
<a name="ln154">    std::fill(linealloc.begin(), linealloc.end(), 0);</a>
<a name="ln155"> </a>
<a name="ln156">  linebuf[_R0] = &amp;linealloc[0];</a>
<a name="ln157"> </a>
<a name="ln158">  for (int i = _R1; i &lt;= _B4; i++) {</a>
<a name="ln159">    linebuf[i] = linebuf[i - 1] + params-&gt;line_width + 2;</a>
<a name="ln160">  }</a>
<a name="ln161"> </a>
<a name="ln162">  for (int j = 0; j &lt; 3; j++) {</a>
<a name="ln163">    for (int i = 0; i &lt; 41; i++) {</a>
<a name="ln164">      grad_even[j][i].value1 = params-&gt;maxDiff;</a>
<a name="ln165">      grad_even[j][i].value2 = 1;</a>
<a name="ln166">      grad_odd[j][i].value1 = params-&gt;maxDiff;</a>
<a name="ln167">      grad_odd[j][i].value2 = 1;</a>
<a name="ln168">    }</a>
<a name="ln169">  }</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">template &lt;typename T&gt;</a>
<a name="ln173">void FujiDecompressor::copy_line(fuji_compressed_block* info,</a>
<a name="ln174">                                 const FujiStrip&amp; strip, int cur_line,</a>
<a name="ln175">                                 T&amp;&amp; idx) const {</a>
<a name="ln176">  std::array&lt;uint16_t*, 3&gt; lineBufB;</a>
<a name="ln177">  std::array&lt;uint16_t*, 6&gt; lineBufG;</a>
<a name="ln178">  std::array&lt;uint16_t*, 3&gt; lineBufR;</a>
<a name="ln179"> </a>
<a name="ln180">  for (int i = 0; i &lt; 3; i++) {</a>
<a name="ln181">    lineBufR[i] = info-&gt;linebuf[_R2 + i] + 1;</a>
<a name="ln182">    lineBufB[i] = info-&gt;linebuf[_B2 + i] + 1;</a>
<a name="ln183">  }</a>
<a name="ln184"> </a>
<a name="ln185">  for (int i = 0; i &lt; 6; i++) {</a>
<a name="ln186">    lineBufG[i] = info-&gt;linebuf[_G2 + i] + 1;</a>
<a name="ln187">  }</a>
<a name="ln188"> </a>
<a name="ln189">  for (int row_count = 0; row_count &lt; FujiStrip::lineHeight(); row_count++) {</a>
<a name="ln190">    auto* const raw_block_data = reinterpret_cast&lt;uint16_t*&gt;(</a>
<a name="ln191">        mRaw-&gt;getData(strip.offsetX(), strip.offsetY(cur_line) + row_count));</a>
<a name="ln192"> </a>
<a name="ln193">    for (int pixel_count = 0; pixel_count &lt; strip.width(); pixel_count++) {</a>
<a name="ln194">      uint16_t* line_buf = nullptr;</a>
<a name="ln195"> </a>
<a name="ln196">      switch (CFA[row_count][pixel_count % 6]) {</a>
<a name="ln197">      case CFA_RED: // red</a>
<a name="ln198">        line_buf = lineBufR[row_count &gt;&gt; 1];</a>
<a name="ln199">        break;</a>
<a name="ln200"> </a>
<a name="ln201">      case CFA_GREEN: // green</a>
<a name="ln202">        line_buf = lineBufG[row_count];</a>
<a name="ln203">        break;</a>
<a name="ln204"> </a>
<a name="ln205">      case CFA_BLUE: // blue</a>
<a name="ln206">        line_buf = lineBufB[row_count &gt;&gt; 1];</a>
<a name="ln207">        break;</a>
<a name="ln208"> </a>
<a name="ln209">      default:</a>
<a name="ln210">        __builtin_unreachable();</a>
<a name="ln211">      }</a>
<a name="ln212"> </a>
<a name="ln213">      raw_block_data[pixel_count] = line_buf[idx(pixel_count)];</a>
<a name="ln214">    }</a>
<a name="ln215">  }</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">void FujiDecompressor::copy_line_to_xtrans(fuji_compressed_block* info,</a>
<a name="ln219">                                           const FujiStrip&amp; strip,</a>
<a name="ln220">                                           int cur_line) const {</a>
<a name="ln221">  auto index = [](int pixel_count) {</a>
<a name="ln222">    return (((pixel_count * 2 / 3) &amp; 0x7FFFFFFE) | ((pixel_count % 3) &amp; 1)) +</a>
<a name="ln223">           ((pixel_count % 3) &gt;&gt; 1);</a>
<a name="ln224">  };</a>
<a name="ln225"> </a>
<a name="ln226">  copy_line(info, strip, cur_line, index);</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">void FujiDecompressor::copy_line_to_bayer(fuji_compressed_block* info,</a>
<a name="ln230">                                          const FujiStrip&amp; strip,</a>
<a name="ln231">                                          int cur_line) const {</a>
<a name="ln232">  auto index = [](int pixel_count) { return pixel_count &gt;&gt; 1; };</a>
<a name="ln233"> </a>
<a name="ln234">  copy_line(info, strip, cur_line, index);</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">inline void FujiDecompressor::fuji_zerobits(BitPumpMSB* pump, int* count) {</a>
<a name="ln238">  uint8_t zero = 0;</a>
<a name="ln239">  *count = 0;</a>
<a name="ln240"> </a>
<a name="ln241">  while (zero == 0) {</a>
<a name="ln242">    zero = pump-&gt;getBits(1);</a>
<a name="ln243"> </a>
<a name="ln244">    if (zero)</a>
<a name="ln245">      break;</a>
<a name="ln246"> </a>
<a name="ln247">    ++*count;</a>
<a name="ln248">  }</a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251">int __attribute__((const)) FujiDecompressor::bitDiff(int value1, int value2) {</a>
<a name="ln252">  int decBits = 0;</a>
<a name="ln253"> </a>
<a name="ln254">  if (value2 &gt;= value1)</a>
<a name="ln255">    return decBits;</a>
<a name="ln256"> </a>
<a name="ln257">  while (decBits &lt;= 12) {</a>
<a name="ln258">    ++decBits;</a>
<a name="ln259"> </a>
<a name="ln260">    if ((value2 &lt;&lt; decBits) &gt;= value1)</a>
<a name="ln261">      return decBits;</a>
<a name="ln262">  }</a>
<a name="ln263"> </a>
<a name="ln264">  return decBits;</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">template &lt;typename T1, typename T2&gt;</a>
<a name="ln268">void FujiDecompressor::fuji_decode_sample(</a>
<a name="ln269">    T1&amp;&amp; func_0, T2&amp;&amp; func_1, fuji_compressed_block* info, uint16_t* line_buf,</a>
<a name="ln270">    int* pos, std::array&lt;int_pair, 41&gt;* grads) const {</a>
<a name="ln271">  int interp_val = 0;</a>
<a name="ln272"> </a>
<a name="ln273">  int sample = 0;</a>
<a name="ln274">  int code = 0;</a>
<a name="ln275">  uint16_t* line_buf_cur = line_buf + *pos;</a>
<a name="ln276"> </a>
<a name="ln277">  int grad;</a>
<a name="ln278">  int gradient;</a>
<a name="ln279"> </a>
<a name="ln280">  func_0(line_buf_cur, &amp;interp_val, &amp;grad, &amp;gradient);</a>
<a name="ln281"> </a>
<a name="ln282">  fuji_zerobits(&amp;(info-&gt;pump), &amp;sample);</a>
<a name="ln283"> </a>
<a name="ln284">  if (sample &lt; common_info.max_bits - common_info.raw_bits - 1) {</a>
<a name="ln285">    int decBits = bitDiff((*grads)[gradient].value1, (*grads)[gradient].value2);</a>
<a name="ln286">    code = 0;</a>
<a name="ln287">    if (decBits)</a>
<a name="ln288">      code = info-&gt;pump.getBits(decBits);</a>
<a name="ln289">    code += sample &lt;&lt; decBits;</a>
<a name="ln290">  } else {</a>
<a name="ln291">    code = info-&gt;pump.getBits(common_info.raw_bits);</a>
<a name="ln292">    code++;</a>
<a name="ln293">  }</a>
<a name="ln294"> </a>
<a name="ln295">  if (code &lt; 0 || code &gt;= common_info.total_values) {</a>
<a name="ln296">    ThrowRDE(&quot;fuji_decode_sample&quot;);</a>
<a name="ln297">  }</a>
<a name="ln298"> </a>
<a name="ln299">  if (code &amp; 1) {</a>
<a name="ln300">    code = -1 - code / 2;</a>
<a name="ln301">  } else {</a>
<a name="ln302">    code /= 2;</a>
<a name="ln303">  }</a>
<a name="ln304"> </a>
<a name="ln305">  (*grads)[gradient].value1 += std::abs(code);</a>
<a name="ln306"> </a>
<a name="ln307">  if ((*grads)[gradient].value2 == common_info.min_value) {</a>
<a name="ln308">    (*grads)[gradient].value1 &gt;&gt;= 1;</a>
<a name="ln309">    (*grads)[gradient].value2 &gt;&gt;= 1;</a>
<a name="ln310">  }</a>
<a name="ln311"> </a>
<a name="ln312">  (*grads)[gradient].value2++;</a>
<a name="ln313"> </a>
<a name="ln314">  interp_val = func_1(grad, interp_val, code);</a>
<a name="ln315"> </a>
<a name="ln316">  if (interp_val &lt; 0) {</a>
<a name="ln317">    interp_val += common_info.total_values;</a>
<a name="ln318">  } else if (interp_val &gt; common_info.q_point[4]) {</a>
<a name="ln319">    interp_val -= common_info.total_values;</a>
<a name="ln320">  }</a>
<a name="ln321"> </a>
<a name="ln322">  if (interp_val &gt;= 0) {</a>
<a name="ln323">    line_buf_cur[0] = std::min(interp_val, common_info.q_point[4]);</a>
<a name="ln324">  } else {</a>
<a name="ln325">    line_buf_cur[0] = 0;</a>
<a name="ln326">  }</a>
<a name="ln327"> </a>
<a name="ln328">  *pos += 2;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">#define fuji_quant_gradient(v1, v2)                                            \</a>
<a name="ln332">  (9 * ci.q_table[ci.q_point[4] + (v1)] + ci.q_table[ci.q_point[4] + (v2)])</a>
<a name="ln333"> </a>
<a name="ln334">void FujiDecompressor::fuji_decode_sample_even(</a>
<a name="ln335">    fuji_compressed_block* info, uint16_t* line_buf, int* pos,</a>
<a name="ln336">    std::array&lt;int_pair, 41&gt;* grads) const {</a>
<a name="ln337">  const auto&amp; ci = common_info;</a>
<a name="ln338">  fuji_decode_sample(</a>
<a name="ln339">      [&amp;ci](const uint16_t* line_buf_cur, int* interp_val, int* grad,</a>
<a name="ln340">            int* gradient) {</a>
<a name="ln341">        int Rb = line_buf_cur[-2 - ci.line_width];</a>
<a name="ln342">        int Rc = line_buf_cur[-3 - ci.line_width];</a>
<a name="ln343">        int Rd = line_buf_cur[-1 - ci.line_width];</a>
<a name="ln344">        int Rf = line_buf_cur[-4 - 2 * ci.line_width];</a>
<a name="ln345"> </a>
<a name="ln346">        int diffRcRb;</a>
<a name="ln347">        int diffRfRb;</a>
<a name="ln348">        int diffRdRb;</a>
<a name="ln349"> </a>
<a name="ln350">        *grad = fuji_quant_gradient(Rb - Rf, Rc - Rb);</a>
<a name="ln351">        *gradient = std::abs(*grad);</a>
<a name="ln352">        diffRcRb = std::abs(Rc - Rb);</a>
<a name="ln353">        diffRfRb = std::abs(Rf - Rb);</a>
<a name="ln354">        diffRdRb = std::abs(Rd - Rb);</a>
<a name="ln355"> </a>
<a name="ln356">        if (diffRcRb &gt; diffRfRb &amp;&amp; diffRcRb &gt; diffRdRb) {</a>
<a name="ln357">          *interp_val = Rf + Rd + 2 * Rb;</a>
<a name="ln358">        } else if (diffRdRb &gt; diffRcRb &amp;&amp; diffRdRb &gt; diffRfRb) {</a>
<a name="ln359">          *interp_val = Rf + Rc + 2 * Rb;</a>
<a name="ln360">        } else {</a>
<a name="ln361">          *interp_val = Rd + Rc + 2 * Rb;</a>
<a name="ln362">        }</a>
<a name="ln363">      },</a>
<a name="ln364">      [](int grad, int interp_val, int code) {</a>
<a name="ln365">        if (grad &lt; 0) {</a>
<a name="ln366">          interp_val = (interp_val &gt;&gt; 2) - code;</a>
<a name="ln367">        } else {</a>
<a name="ln368">          interp_val = (interp_val &gt;&gt; 2) + code;</a>
<a name="ln369">        }</a>
<a name="ln370"> </a>
<a name="ln371">        return interp_val;</a>
<a name="ln372">      },</a>
<a name="ln373">      info, line_buf, pos, grads);</a>
<a name="ln374">}</a>
<a name="ln375"> </a>
<a name="ln376">void FujiDecompressor::fuji_decode_sample_odd(</a>
<a name="ln377">    fuji_compressed_block* info, uint16_t* line_buf, int* pos,</a>
<a name="ln378">    std::array&lt;int_pair, 41&gt;* grads) const {</a>
<a name="ln379">  const auto&amp; ci = common_info;</a>
<a name="ln380">  fuji_decode_sample(</a>
<a name="ln381">      [&amp;ci](const uint16_t* line_buf_cur, int* interp_val, int* grad,</a>
<a name="ln382">            int* gradient) {</a>
<a name="ln383">        int Ra = line_buf_cur[-1];</a>
<a name="ln384">        int Rb = line_buf_cur[-2 - ci.line_width];</a>
<a name="ln385">        int Rc = line_buf_cur[-3 - ci.line_width];</a>
<a name="ln386">        int Rd = line_buf_cur[-1 - ci.line_width];</a>
<a name="ln387">        int Rg = line_buf_cur[1];</a>
<a name="ln388"> </a>
<a name="ln389">        *grad = fuji_quant_gradient(Rb - Rc, Rc - Ra);</a>
<a name="ln390">        *gradient = std::abs(*grad);</a>
<a name="ln391"> </a>
<a name="ln392">        if ((Rb &gt; Rc &amp;&amp; Rb &gt; Rd) || (Rb &lt; Rc &amp;&amp; Rb &lt; Rd)) {</a>
<a name="ln393">          *interp_val = (Rg + Ra + 2 * Rb) &gt;&gt; 2;</a>
<a name="ln394">        } else {</a>
<a name="ln395">          *interp_val = (Ra + Rg) &gt;&gt; 1;</a>
<a name="ln396">        }</a>
<a name="ln397">      },</a>
<a name="ln398">      [](int grad, int interp_val, int code) {</a>
<a name="ln399">        if (grad &lt; 0) {</a>
<a name="ln400">          interp_val -= code;</a>
<a name="ln401">        } else {</a>
<a name="ln402">          interp_val += code;</a>
<a name="ln403">        }</a>
<a name="ln404"> </a>
<a name="ln405">        return interp_val;</a>
<a name="ln406">      },</a>
<a name="ln407">      info, line_buf, pos, grads);</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">#undef fuji_quant_gradient</a>
<a name="ln411"> </a>
<a name="ln412">void FujiDecompressor::fuji_decode_interpolation_even(int line_width,</a>
<a name="ln413">                                                      uint16_t* line_buf,</a>
<a name="ln414">                                                      int* pos) {</a>
<a name="ln415">  uint16_t* line_buf_cur = line_buf + *pos;</a>
<a name="ln416">  int Rb = line_buf_cur[-2 - line_width];</a>
<a name="ln417">  int Rc = line_buf_cur[-3 - line_width];</a>
<a name="ln418">  int Rd = line_buf_cur[-1 - line_width];</a>
<a name="ln419">  int Rf = line_buf_cur[-4 - 2 * line_width];</a>
<a name="ln420">  int diffRcRb = std::abs(Rc - Rb);</a>
<a name="ln421">  int diffRfRb = std::abs(Rf - Rb);</a>
<a name="ln422">  int diffRdRb = std::abs(Rd - Rb);</a>
<a name="ln423"> </a>
<a name="ln424">  if (diffRcRb &gt; diffRfRb &amp;&amp; diffRcRb &gt; diffRdRb) {</a>
<a name="ln425">    *line_buf_cur = (Rf + Rd + 2 * Rb) &gt;&gt; 2;</a>
<a name="ln426">  } else if (diffRdRb &gt; diffRcRb &amp;&amp; diffRdRb &gt; diffRfRb) {</a>
<a name="ln427">    *line_buf_cur = (Rf + Rc + 2 * Rb) &gt;&gt; 2;</a>
<a name="ln428">  } else {</a>
<a name="ln429">    *line_buf_cur = (Rd + Rc + 2 * Rb) &gt;&gt; 2;</a>
<a name="ln430">  }</a>
<a name="ln431"> </a>
<a name="ln432">  *pos += 2;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">void FujiDecompressor::fuji_extend_generic(</a>
<a name="ln436">    std::array&lt;uint16_t*, _ltotal&gt; linebuf, int line_width, int start,</a>
<a name="ln437">    int end) {</a>
<a name="ln438">  for (int i = start; i &lt;= end; i++) {</a>
<a name="ln439">    linebuf[i][0] = linebuf[i - 1][1];</a>
<a name="ln440">    linebuf[i][line_width + 1] = linebuf[i - 1][line_width];</a>
<a name="ln441">  }</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">void FujiDecompressor::fuji_extend_red(std::array&lt;uint16_t*, _ltotal&gt; linebuf,</a>
<a name="ln445">                                       int line_width) {</a>
<a name="ln446">  fuji_extend_generic(linebuf, line_width, _R2, _R4);</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">void FujiDecompressor::fuji_extend_green(std::array&lt;uint16_t*, _ltotal&gt; linebuf,</a>
<a name="ln450">                                         int line_width) {</a>
<a name="ln451">  fuji_extend_generic(linebuf, line_width, _G2, _G7);</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">void FujiDecompressor::fuji_extend_blue(std::array&lt;uint16_t*, _ltotal&gt; linebuf,</a>
<a name="ln455">                                        int line_width) {</a>
<a name="ln456">  fuji_extend_generic(linebuf, line_width, _B2, _B4);</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">void FujiDecompressor::xtrans_decode_block(fuji_compressed_block* info,</a>
<a name="ln460">                                           int cur_line) const {</a>
<a name="ln461">  struct ColorPos {</a>
<a name="ln462">    int even = 0;</a>
<a name="ln463">    int odd = 1;</a>
<a name="ln464"> </a>
<a name="ln465">    void reset() {</a>
<a name="ln466">      even = 0;</a>
<a name="ln467">      odd = 1;</a>
<a name="ln468">    }</a>
<a name="ln469">  };</a>
<a name="ln470"> </a>
<a name="ln471">  ColorPos r;</a>
<a name="ln472">  ColorPos g;</a>
<a name="ln473">  ColorPos b;</a>
<a name="ln474"> </a>
<a name="ln475">  const int line_width = common_info.line_width;</a>
<a name="ln476"> </a>
<a name="ln477">  // FIXME: GCC5 sucks.</a>
<a name="ln478">  // https://github.com/darktable-org/rawspeed/issues/112</a>
<a name="ln479">  // https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=871250</a>
<a name="ln480">  // https://bugs.launchpad.net/linuxmint/+bug/1709234</a>
<a name="ln481">  auto pass = [&amp;, line_width](auto&amp;&amp; even_func, _xt_lines c0, _xt_lines c1,</a>
<a name="ln482">                              int grad, ColorPos&amp; c0_pos, ColorPos&amp; c1_pos) {</a>
<a name="ln483">    while (g.even &lt; line_width || g.odd &lt; line_width) {</a>
<a name="ln484">      if (g.even &lt; line_width)</a>
<a name="ln485">        even_func(c0, c1, grad, c0_pos, c1_pos);</a>
<a name="ln486"> </a>
<a name="ln487">      if (g.even &gt; 8) {</a>
<a name="ln488">        fuji_decode_sample_odd(info, info-&gt;linebuf[c0] + 1, &amp;c0_pos.odd,</a>
<a name="ln489">                               &amp;(info-&gt;grad_odd[grad]));</a>
<a name="ln490">        fuji_decode_sample_odd(info, info-&gt;linebuf[c1] + 1, &amp;c1_pos.odd,</a>
<a name="ln491">                               &amp;(info-&gt;grad_odd[grad]));</a>
<a name="ln492">      }</a>
<a name="ln493">    }</a>
<a name="ln494">  };</a>
<a name="ln495"> </a>
<a name="ln496">  pass(</a>
<a name="ln497">      [&amp;](_xt_lines c0, _xt_lines c1, int grad, ColorPos&amp; c0_pos,</a>
<a name="ln498">          ColorPos&amp; c1_pos) {</a>
<a name="ln499">        fuji_decode_interpolation_even(line_width, info-&gt;linebuf[c0] + 1,</a>
<a name="ln500">                                       &amp;c0_pos.even);</a>
<a name="ln501">        fuji_decode_sample_even(info, info-&gt;linebuf[c1] + 1, &amp;c1_pos.even,</a>
<a name="ln502">                                &amp;(info-&gt;grad_even[grad]));</a>
<a name="ln503">      },</a>
<a name="ln504">      _R2, _G2, 0, r, g);</a>
<a name="ln505"> </a>
<a name="ln506">  fuji_extend_red(info-&gt;linebuf, line_width);</a>
<a name="ln507">  fuji_extend_green(info-&gt;linebuf, line_width);</a>
<a name="ln508"> </a>
<a name="ln509">  g.reset();</a>
<a name="ln510"> </a>
<a name="ln511">  pass(</a>
<a name="ln512">      [&amp;](_xt_lines c0, _xt_lines c1, int grad, ColorPos&amp; c0_pos,</a>
<a name="ln513">          ColorPos&amp; c1_pos) {</a>
<a name="ln514">        fuji_decode_sample_even(info, info-&gt;linebuf[c0] + 1, &amp;c0_pos.even,</a>
<a name="ln515">                                &amp;(info-&gt;grad_even[grad]));</a>
<a name="ln516">        fuji_decode_interpolation_even(line_width, info-&gt;linebuf[c1] + 1,</a>
<a name="ln517">                                       &amp;c1_pos.even);</a>
<a name="ln518">      },</a>
<a name="ln519">      _G3, _B2, 1, g, b);</a>
<a name="ln520"> </a>
<a name="ln521">  fuji_extend_green(info-&gt;linebuf, line_width);</a>
<a name="ln522">  fuji_extend_blue(info-&gt;linebuf, line_width);</a>
<a name="ln523"> </a>
<a name="ln524">  r.reset();</a>
<a name="ln525">  g.reset();</a>
<a name="ln526"> </a>
<a name="ln527">  pass(</a>
<a name="ln528">      [&amp;](_xt_lines c0, _xt_lines c1, int grad, ColorPos&amp; c0_pos,</a>
<a name="ln529">          ColorPos&amp; c1_pos) {</a>
<a name="ln530">        if (c0_pos.even &amp; 3) {</a>
<a name="ln531">          fuji_decode_sample_even(info, info-&gt;linebuf[c0] + 1, &amp;c0_pos.even,</a>
<a name="ln532">                                  &amp;(info-&gt;grad_even[grad]));</a>
<a name="ln533">        } else {</a>
<a name="ln534">          fuji_decode_interpolation_even(line_width, info-&gt;linebuf[c0] + 1,</a>
<a name="ln535">                                         &amp;c0_pos.even);</a>
<a name="ln536">        }</a>
<a name="ln537"> </a>
<a name="ln538">        fuji_decode_interpolation_even(line_width, info-&gt;linebuf[c1] + 1,</a>
<a name="ln539">                                       &amp;c1_pos.even);</a>
<a name="ln540">      },</a>
<a name="ln541">      _R3, _G4, 2, r, g);</a>
<a name="ln542"> </a>
<a name="ln543">  fuji_extend_red(info-&gt;linebuf, line_width);</a>
<a name="ln544">  fuji_extend_green(info-&gt;linebuf, line_width);</a>
<a name="ln545"> </a>
<a name="ln546">  g.reset();</a>
<a name="ln547">  b.reset();</a>
<a name="ln548"> </a>
<a name="ln549">  pass(</a>
<a name="ln550">      [&amp;](_xt_lines c0, _xt_lines c1, int grad, ColorPos&amp; c0_pos,</a>
<a name="ln551">          ColorPos&amp; c1_pos) {</a>
<a name="ln552">        fuji_decode_sample_even(info, info-&gt;linebuf[c0] + 1, &amp;c0_pos.even,</a>
<a name="ln553">                                &amp;(info-&gt;grad_even[grad]));</a>
<a name="ln554"> </a>
<a name="ln555">        if ((c1_pos.even &amp; 3) == 2) {</a>
<a name="ln556">          fuji_decode_interpolation_even(line_width, info-&gt;linebuf[c1] + 1,</a>
<a name="ln557">                                         &amp;c1_pos.even);</a>
<a name="ln558">        } else {</a>
<a name="ln559">          fuji_decode_sample_even(info, info-&gt;linebuf[c1] + 1, &amp;c1_pos.even,</a>
<a name="ln560">                                  &amp;(info-&gt;grad_even[grad]));</a>
<a name="ln561">        }</a>
<a name="ln562">      },</a>
<a name="ln563">      _G5, _B3, 0, g, b);</a>
<a name="ln564"> </a>
<a name="ln565">  fuji_extend_green(info-&gt;linebuf, line_width);</a>
<a name="ln566">  fuji_extend_blue(info-&gt;linebuf, line_width);</a>
<a name="ln567"> </a>
<a name="ln568">  r.reset();</a>
<a name="ln569">  g.reset();</a>
<a name="ln570"> </a>
<a name="ln571">  pass(</a>
<a name="ln572">      [&amp;](_xt_lines c0, _xt_lines c1, int grad, ColorPos&amp; c0_pos,</a>
<a name="ln573">          ColorPos&amp; c1_pos) {</a>
<a name="ln574">        if ((c0_pos.even &amp; 3) == 2) {</a>
<a name="ln575">          fuji_decode_interpolation_even(line_width, info-&gt;linebuf[c0] + 1,</a>
<a name="ln576">                                         &amp;c0_pos.even);</a>
<a name="ln577">        } else {</a>
<a name="ln578">          fuji_decode_sample_even(info, info-&gt;linebuf[c0] + 1, &amp;c0_pos.even,</a>
<a name="ln579">                                  &amp;(info-&gt;grad_even[grad]));</a>
<a name="ln580">        }</a>
<a name="ln581"> </a>
<a name="ln582">        fuji_decode_sample_even(info, info-&gt;linebuf[c1] + 1, &amp;c1_pos.even,</a>
<a name="ln583">                                &amp;(info-&gt;grad_even[grad]));</a>
<a name="ln584">      },</a>
<a name="ln585">      _R4, _G6, 1, r, g);</a>
<a name="ln586"> </a>
<a name="ln587">  fuji_extend_red(info-&gt;linebuf, line_width);</a>
<a name="ln588">  fuji_extend_green(info-&gt;linebuf, line_width);</a>
<a name="ln589"> </a>
<a name="ln590">  g.reset();</a>
<a name="ln591">  b.reset();</a>
<a name="ln592"> </a>
<a name="ln593">  pass(</a>
<a name="ln594">      [&amp;](_xt_lines c0, _xt_lines c1, int grad, ColorPos&amp; c0_pos,</a>
<a name="ln595">          ColorPos&amp; c1_pos) {</a>
<a name="ln596">        fuji_decode_interpolation_even(line_width, info-&gt;linebuf[c0] + 1,</a>
<a name="ln597">                                       &amp;c0_pos.even);</a>
<a name="ln598"> </a>
<a name="ln599">        if (c1_pos.even &amp; 3) {</a>
<a name="ln600">          fuji_decode_sample_even(info, info-&gt;linebuf[c1] + 1, &amp;c1_pos.even,</a>
<a name="ln601">                                  &amp;(info-&gt;grad_even[grad]));</a>
<a name="ln602">        } else {</a>
<a name="ln603">          fuji_decode_interpolation_even(line_width, info-&gt;linebuf[c1] + 1,</a>
<a name="ln604">                                         &amp;c1_pos.even);</a>
<a name="ln605">        }</a>
<a name="ln606">      },</a>
<a name="ln607">      _G7, _B4, 2, g, b);</a>
<a name="ln608"> </a>
<a name="ln609">  fuji_extend_green(info-&gt;linebuf, line_width);</a>
<a name="ln610">  fuji_extend_blue(info-&gt;linebuf, line_width);</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">void FujiDecompressor::fuji_bayer_decode_block(fuji_compressed_block* info,</a>
<a name="ln614">                                               int cur_line) const {</a>
<a name="ln615">  struct ColorPos {</a>
<a name="ln616">    int even = 0;</a>
<a name="ln617">    int odd = 1;</a>
<a name="ln618"> </a>
<a name="ln619">    void reset() {</a>
<a name="ln620">      even = 0;</a>
<a name="ln621">      odd = 1;</a>
<a name="ln622">    }</a>
<a name="ln623">  };</a>
<a name="ln624"> </a>
<a name="ln625">  ColorPos r;</a>
<a name="ln626">  ColorPos g;</a>
<a name="ln627">  ColorPos b;</a>
<a name="ln628"> </a>
<a name="ln629">  const int line_width = common_info.line_width;</a>
<a name="ln630"> </a>
<a name="ln631">  auto pass = [&amp;](_xt_lines c0, _xt_lines c1, int grad, ColorPos&amp; c0_pos,</a>
<a name="ln632">                  ColorPos&amp; c1_pos) {</a>
<a name="ln633">    while (g.even &lt; line_width || g.odd &lt; line_width) {</a>
<a name="ln634">      if (g.even &lt; line_width) {</a>
<a name="ln635">        fuji_decode_sample_even(info, info-&gt;linebuf[c0] + 1, &amp;c0_pos.even,</a>
<a name="ln636">                                &amp;(info-&gt;grad_even[grad]));</a>
<a name="ln637">        fuji_decode_sample_even(info, info-&gt;linebuf[c1] + 1, &amp;c1_pos.even,</a>
<a name="ln638">                                &amp;(info-&gt;grad_even[grad]));</a>
<a name="ln639">      }</a>
<a name="ln640"> </a>
<a name="ln641">      if (g.even &gt; 8) {</a>
<a name="ln642">        fuji_decode_sample_odd(info, info-&gt;linebuf[c0] + 1, &amp;c0_pos.odd,</a>
<a name="ln643">                               &amp;(info-&gt;grad_odd[grad]));</a>
<a name="ln644">        fuji_decode_sample_odd(info, info-&gt;linebuf[c1] + 1, &amp;c1_pos.odd,</a>
<a name="ln645">                               &amp;(info-&gt;grad_odd[grad]));</a>
<a name="ln646">      }</a>
<a name="ln647">    }</a>
<a name="ln648">  };</a>
<a name="ln649"> </a>
<a name="ln650">  auto pass_RG = [&amp;](_xt_lines c0, _xt_lines c1, int grad) {</a>
<a name="ln651">    pass(c0, c1, grad, r, g);</a>
<a name="ln652"> </a>
<a name="ln653">    fuji_extend_red(info-&gt;linebuf, line_width);</a>
<a name="ln654">    fuji_extend_green(info-&gt;linebuf, line_width);</a>
<a name="ln655">  };</a>
<a name="ln656"> </a>
<a name="ln657">  auto pass_GB = [&amp;](_xt_lines c0, _xt_lines c1, int grad) {</a>
<a name="ln658">    pass(c0, c1, grad, g, b);</a>
<a name="ln659"> </a>
<a name="ln660">    fuji_extend_green(info-&gt;linebuf, line_width);</a>
<a name="ln661">    fuji_extend_blue(info-&gt;linebuf, line_width);</a>
<a name="ln662">  };</a>
<a name="ln663"> </a>
<a name="ln664">  pass_RG(_R2, _G2, 0);</a>
<a name="ln665"> </a>
<a name="ln666">  g.reset();</a>
<a name="ln667"> </a>
<a name="ln668">  pass_GB(_G3, _B2, 1);</a>
<a name="ln669"> </a>
<a name="ln670">  r.reset();</a>
<a name="ln671">  g.reset();</a>
<a name="ln672"> </a>
<a name="ln673">  pass_RG(_R3, _G4, 2);</a>
<a name="ln674"> </a>
<a name="ln675">  g.reset();</a>
<a name="ln676">  b.reset();</a>
<a name="ln677"> </a>
<a name="ln678">  pass_GB(_G5, _B3, 0);</a>
<a name="ln679"> </a>
<a name="ln680">  r.reset();</a>
<a name="ln681">  g.reset();</a>
<a name="ln682"> </a>
<a name="ln683">  pass_RG(_R4, _G6, 1);</a>
<a name="ln684"> </a>
<a name="ln685">  g.reset();</a>
<a name="ln686">  b.reset();</a>
<a name="ln687"> </a>
<a name="ln688">  pass_GB(_G7, _B4, 2);</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">void FujiDecompressor::fuji_decode_strip(</a>
<a name="ln692">    fuji_compressed_block* info_block, const FujiStrip&amp; strip) const {</a>
<a name="ln693">  BitPumpMSB pump(strip.bs);</a>
<a name="ln694"> </a>
<a name="ln695">  const unsigned line_size = sizeof(uint16_t) * (common_info.line_width + 2);</a>
<a name="ln696"> </a>
<a name="ln697">  struct i_pair {</a>
<a name="ln698">    int a;</a>
<a name="ln699">    int b;</a>
<a name="ln700">  };</a>
<a name="ln701"> </a>
<a name="ln702">  const std::array&lt;i_pair, 6&gt; mtable = {</a>
<a name="ln703">      {{_R0, _R3}, {_R1, _R4}, {_G0, _G6}, {_G1, _G7}, {_B0, _B3}, {_B1, _B4}}};</a>
<a name="ln704">  const std::array&lt;i_pair, 3&gt; ztable = {{{_R2, 3}, {_G2, 6}, {_B2, 3}}};</a>
<a name="ln705"> </a>
<a name="ln706">  for (int cur_line = 0; cur_line &lt; strip.height(); cur_line++) {</a>
<a name="ln707">    if (header.raw_type == 16) {</a>
<a name="ln708">      xtrans_decode_block(info_block, cur_line);</a>
<a name="ln709">    } else {</a>
<a name="ln710">      fuji_bayer_decode_block(info_block, cur_line);</a>
<a name="ln711">    }</a>
<a name="ln712"> </a>
<a name="ln713">    // copy data from line buffers and advance</a>
<a name="ln714">    for (auto i : mtable) {</a>
<a name="ln715">      memcpy(info_block-&gt;linebuf[i.a], info_block-&gt;linebuf[i.b], line_size);</a>
<a name="ln716">    }</a>
<a name="ln717"> </a>
<a name="ln718">    if (header.raw_type == 16) {</a>
<a name="ln719">      copy_line_to_xtrans(info_block, strip, cur_line);</a>
<a name="ln720">    } else {</a>
<a name="ln721">      copy_line_to_bayer(info_block, strip, cur_line);</a>
<a name="ln722">    }</a>
<a name="ln723"> </a>
<a name="ln724">    for (auto i : ztable) {</a>
<a name="ln725">      memset(info_block-&gt;linebuf[i.a], 0, i.b * line_size);</a>
<a name="ln726">      info_block-&gt;linebuf[i.a][0] = info_block-&gt;linebuf[i.a - 1][1];</a>
<a name="ln727">      info_block-&gt;linebuf[i.a][common_info.line_width + 1] =</a>
<a name="ln728">          info_block-&gt;linebuf[i.a - 1][common_info.line_width];</a>
<a name="ln729">    }</a>
<a name="ln730">  }</a>
<a name="ln731">}</a>
<a name="ln732"> </a>
<a name="ln733">void FujiDecompressor::fuji_compressed_load_raw() {</a>
<a name="ln734">  common_info = fuji_compressed_params(*this);</a>
<a name="ln735"> </a>
<a name="ln736">  // read block sizes</a>
<a name="ln737">  std::vector&lt;uint32_t&gt; block_sizes;</a>
<a name="ln738">  block_sizes.resize(header.blocks_in_row);</a>
<a name="ln739">  for (auto&amp; block_size : block_sizes)</a>
<a name="ln740">    block_size = input.getU32();</a>
<a name="ln741"> </a>
<a name="ln742">  // some padding?</a>
<a name="ln743">  const uint64_t raw_offset = sizeof(uint32_t) * header.blocks_in_row;</a>
<a name="ln744">  if (raw_offset &amp; 0xC) {</a>
<a name="ln745">    const int padding = 0x10 - (raw_offset &amp; 0xC);</a>
<a name="ln746">    input.skipBytes(padding);</a>
<a name="ln747">  }</a>
<a name="ln748"> </a>
<a name="ln749">  // calculating raw block offsets</a>
<a name="ln750">  strips.reserve(header.blocks_in_row);</a>
<a name="ln751"> </a>
<a name="ln752">  int block = 0;</a>
<a name="ln753">  for (const auto&amp; block_size : block_sizes) {</a>
<a name="ln754">    strips.emplace_back(header, block, input.getStream(block_size));</a>
<a name="ln755">    block++;</a>
<a name="ln756">  }</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759">void FujiDecompressor::decompressThread() const noexcept {</a>
<a name="ln760">  fuji_compressed_block block_info;</a>
<a name="ln761"> </a>
<a name="ln762">#ifdef HAVE_OPENMP</a>
<a name="ln763">#pragma omp for schedule(static)</a>
<a name="ln764">#endif</a>
<a name="ln765">  for (auto strip = strips.cbegin(); strip &lt; strips.cend(); ++strip) {</a>
<a name="ln766">    block_info.reset(&amp;common_info);</a>
<a name="ln767">    block_info.pump = BitPumpMSB(strip-&gt;bs);</a>
<a name="ln768">    try {</a>
<a name="ln769">      fuji_decode_strip(&amp;block_info, *strip);</a>
<a name="ln770">    } catch (RawspeedException&amp; err) {</a>
<a name="ln771">      // Propagate the exception out of OpenMP magic.</a>
<a name="ln772">      mRaw-&gt;setError(err.what());</a>
<a name="ln773">    }</a>
<a name="ln774">  }</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">void FujiDecompressor::decompress() const {</a>
<a name="ln778">#ifdef HAVE_OPENMP</a>
<a name="ln779">#pragma omp parallel default(none)                                             \</a>
<a name="ln780">    num_threads(rawspeed_get_number_of_processor_cores())</a>
<a name="ln781">#endif</a>
<a name="ln782">  decompressThread();</a>
<a name="ln783"> </a>
<a name="ln784">  std::string firstErr;</a>
<a name="ln785">  if (mRaw-&gt;isTooManyErrors(1, &amp;firstErr)) {</a>
<a name="ln786">    ThrowRDE(&quot;Too many errors encountered. Giving up. First Error:\n%s&quot;,</a>
<a name="ln787">             firstErr.c_str());</a>
<a name="ln788">  }</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">FujiDecompressor::FujiHeader::FujiHeader(ByteStream* bs) {</a>
<a name="ln792">  signature = bs-&gt;getU16();</a>
<a name="ln793">  version = bs-&gt;getByte();</a>
<a name="ln794">  raw_type = bs-&gt;getByte();</a>
<a name="ln795">  raw_bits = bs-&gt;getByte();</a>
<a name="ln796">  raw_height = bs-&gt;getU16();</a>
<a name="ln797">  raw_rounded_width = bs-&gt;getU16();</a>
<a name="ln798">  raw_width = bs-&gt;getU16();</a>
<a name="ln799">  block_size = bs-&gt;getU16();</a>
<a name="ln800">  blocks_in_row = bs-&gt;getByte();</a>
<a name="ln801">  total_lines = bs-&gt;getU16();</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">FujiDecompressor::FujiHeader::operator bool() const {</a>
<a name="ln805">  // general validation</a>
<a name="ln806">  const bool invalid =</a>
<a name="ln807">      (signature != 0x4953 || version != 1 || raw_height &gt; 0x3000 ||</a>
<a name="ln808">       raw_height &lt; FujiStrip::lineHeight() ||</a>
<a name="ln809">       raw_height % FujiStrip::lineHeight() || raw_width &gt; 0x3000 ||</a>
<a name="ln810">       raw_width &lt; 0x300 || raw_width % 24 || raw_rounded_width &gt; 0x3000 ||</a>
<a name="ln811">       block_size != 0x300 || raw_rounded_width &lt; block_size ||</a>
<a name="ln812">       raw_rounded_width % block_size ||</a>
<a name="ln813">       raw_rounded_width - raw_width &gt;= block_size || blocks_in_row &gt; 0x10 ||</a>
<a name="ln814">       blocks_in_row == 0 || blocks_in_row != raw_rounded_width / block_size ||</a>
<a name="ln815">       blocks_in_row != roundUpDivision(raw_width, block_size) ||</a>
<a name="ln816">       total_lines &gt; 0x800 || total_lines == 0 ||</a>
<a name="ln817">       total_lines != raw_height / FujiStrip::lineHeight() ||</a>
<a name="ln818">       (raw_bits != 12 &amp;&amp; raw_bits != 14) || (raw_type != 16 &amp;&amp; raw_type != 0));</a>
<a name="ln819"> </a>
<a name="ln820">  return !invalid;</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">} // namespace rawspeed</a>

</code></pre>
<div class="balloon" rel="633"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v590/" target="_blank">V590</a> Consider inspecting this expression. The expression is excessive or contains a misprint.</p></div>
<div class="balloon" rel="634"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'g.even < line_width' is always true.</p></div>
<div class="balloon" rel="641"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'g.even > 8' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
