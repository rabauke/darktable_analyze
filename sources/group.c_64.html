
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012 aldric renaudin.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#include &quot;common/debug.h&quot;</a>
<a name="ln19">#include &quot;control/conf.h&quot;</a>
<a name="ln20">#include &quot;control/control.h&quot;</a>
<a name="ln21">#include &quot;develop/blend.h&quot;</a>
<a name="ln22">#include &quot;develop/imageop.h&quot;</a>
<a name="ln23">#include &quot;develop/masks.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25">static int dt_group_events_mouse_scrolled(struct dt_iop_module_t *module, float pzx, float pzy, int up,</a>
<a name="ln26">                                          uint32_t state, dt_masks_form_t *form, dt_masks_form_gui_t *gui)</a>
<a name="ln27">{</a>
<a name="ln28">  if(gui-&gt;group_edited &gt;= 0)</a>
<a name="ln29">  {</a>
<a name="ln30">    // we get the form</a>
<a name="ln31">    dt_masks_point_group_t *fpt = (dt_masks_point_group_t *)g_list_nth_data(form-&gt;points, gui-&gt;group_edited);</a>
<a name="ln32">    dt_masks_form_t *sel = dt_masks_get_from_id(darktable.develop, fpt-&gt;formid);</a>
<a name="ln33">    if(!sel) return 0;</a>
<a name="ln34">    if(sel-&gt;type &amp; DT_MASKS_CIRCLE)</a>
<a name="ln35">      return dt_circle_events_mouse_scrolled(module, pzx, pzy, up, state, sel, fpt-&gt;parentid, gui,</a>
<a name="ln36">                                             gui-&gt;group_edited);</a>
<a name="ln37">    else if(sel-&gt;type &amp; DT_MASKS_PATH)</a>
<a name="ln38">      return dt_path_events_mouse_scrolled(module, pzx, pzy, up, state, sel, fpt-&gt;parentid, gui,</a>
<a name="ln39">                                           gui-&gt;group_edited);</a>
<a name="ln40">    else if(sel-&gt;type &amp; DT_MASKS_GRADIENT)</a>
<a name="ln41">      return dt_gradient_events_mouse_scrolled(module, pzx, pzy, up, state, sel, fpt-&gt;parentid, gui,</a>
<a name="ln42">                                               gui-&gt;group_edited);</a>
<a name="ln43">    else if(sel-&gt;type &amp; DT_MASKS_ELLIPSE)</a>
<a name="ln44">      return dt_ellipse_events_mouse_scrolled(module, pzx, pzy, up, state, sel, fpt-&gt;parentid, gui,</a>
<a name="ln45">                                              gui-&gt;group_edited);</a>
<a name="ln46">    else if(sel-&gt;type &amp; DT_MASKS_BRUSH)</a>
<a name="ln47">      return dt_brush_events_mouse_scrolled(module, pzx, pzy, up, state, sel, fpt-&gt;parentid, gui,</a>
<a name="ln48">                                            gui-&gt;group_edited);</a>
<a name="ln49">  }</a>
<a name="ln50">  return 0;</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53">static int dt_group_events_button_pressed(struct dt_iop_module_t *module, float pzx, float pzy,</a>
<a name="ln54">                                          double pressure, int which, int type, uint32_t state,</a>
<a name="ln55">                                          dt_masks_form_t *form, dt_masks_form_gui_t *gui)</a>
<a name="ln56">{</a>
<a name="ln57">  if(gui-&gt;group_edited != gui-&gt;group_selected)</a>
<a name="ln58">  {</a>
<a name="ln59">    // we set the selected form in edit mode</a>
<a name="ln60">    gui-&gt;group_edited = gui-&gt;group_selected;</a>
<a name="ln61">    // we initialise some variable</a>
<a name="ln62">    gui-&gt;dx = gui-&gt;dy = 0.0f;</a>
<a name="ln63">    gui-&gt;form_selected = gui-&gt;border_selected = gui-&gt;form_dragging = gui-&gt;form_rotating = FALSE;</a>
<a name="ln64">    gui-&gt;pivot_selected = FALSE;</a>
<a name="ln65">    gui-&gt;point_border_selected = gui-&gt;seg_selected = gui-&gt;point_selected = gui-&gt;feather_selected = -1;</a>
<a name="ln66">    gui-&gt;point_border_dragging = gui-&gt;seg_dragging = gui-&gt;feather_dragging = gui-&gt;point_dragging = -1;</a>
<a name="ln67"> </a>
<a name="ln68">    dt_control_queue_redraw_center();</a>
<a name="ln69">    return 1;</a>
<a name="ln70">  }</a>
<a name="ln71">  if(gui-&gt;group_edited &gt;= 0)</a>
<a name="ln72">  {</a>
<a name="ln73">    // we get the form</a>
<a name="ln74">    dt_masks_point_group_t *fpt = (dt_masks_point_group_t *)g_list_nth_data(form-&gt;points, gui-&gt;group_edited);</a>
<a name="ln75">    dt_masks_form_t *sel = dt_masks_get_from_id(darktable.develop, fpt-&gt;formid);</a>
<a name="ln76">    if(!sel) return 0;</a>
<a name="ln77">    if(sel-&gt;type &amp; DT_MASKS_CIRCLE)</a>
<a name="ln78">      return dt_circle_events_button_pressed(module, pzx, pzy, pressure, which, type, state, sel,</a>
<a name="ln79">                                             fpt-&gt;parentid, gui, gui-&gt;group_edited);</a>
<a name="ln80">    else if(sel-&gt;type &amp; DT_MASKS_PATH)</a>
<a name="ln81">      return dt_path_events_button_pressed(module, pzx, pzy, pressure, which, type, state, sel, fpt-&gt;parentid,</a>
<a name="ln82">                                           gui, gui-&gt;group_edited);</a>
<a name="ln83">    else if(sel-&gt;type &amp; DT_MASKS_GRADIENT)</a>
<a name="ln84">      return dt_gradient_events_button_pressed(module, pzx, pzy, pressure, which, type, state, sel,</a>
<a name="ln85">                                               fpt-&gt;parentid, gui, gui-&gt;group_edited);</a>
<a name="ln86">    else if(sel-&gt;type &amp; DT_MASKS_ELLIPSE)</a>
<a name="ln87">      return dt_ellipse_events_button_pressed(module, pzx, pzy, pressure, which, type, state, sel,</a>
<a name="ln88">                                              fpt-&gt;parentid, gui, gui-&gt;group_edited);</a>
<a name="ln89">    else if(sel-&gt;type &amp; DT_MASKS_BRUSH)</a>
<a name="ln90">      return dt_brush_events_button_pressed(module, pzx, pzy, pressure, which, type, state, sel,</a>
<a name="ln91">                                            fpt-&gt;parentid, gui, gui-&gt;group_edited);</a>
<a name="ln92">  }</a>
<a name="ln93">  return 0;</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">static int dt_group_events_button_released(struct dt_iop_module_t *module, float pzx, float pzy, int which,</a>
<a name="ln97">                                           uint32_t state, dt_masks_form_t *form, dt_masks_form_gui_t *gui)</a>
<a name="ln98">{</a>
<a name="ln99">  if(gui-&gt;group_edited &gt;= 0)</a>
<a name="ln100">  {</a>
<a name="ln101">    // we get the form</a>
<a name="ln102">    dt_masks_point_group_t *fpt = (dt_masks_point_group_t *)g_list_nth_data(form-&gt;points, gui-&gt;group_edited);</a>
<a name="ln103">    dt_masks_form_t *sel = dt_masks_get_from_id(darktable.develop, fpt-&gt;formid);</a>
<a name="ln104">    if(!sel) return 0;</a>
<a name="ln105">    if(sel-&gt;type &amp; DT_MASKS_CIRCLE)</a>
<a name="ln106">      return dt_circle_events_button_released(module, pzx, pzy, which, state, sel, fpt-&gt;parentid, gui,</a>
<a name="ln107">                                              gui-&gt;group_edited);</a>
<a name="ln108">    else if(sel-&gt;type &amp; DT_MASKS_PATH)</a>
<a name="ln109">      return dt_path_events_button_released(module, pzx, pzy, which, state, sel, fpt-&gt;parentid, gui,</a>
<a name="ln110">                                            gui-&gt;group_edited);</a>
<a name="ln111">    else if(sel-&gt;type &amp; DT_MASKS_GRADIENT)</a>
<a name="ln112">      return dt_gradient_events_button_released(module, pzx, pzy, which, state, sel, fpt-&gt;parentid, gui,</a>
<a name="ln113">                                                gui-&gt;group_edited);</a>
<a name="ln114">    else if(sel-&gt;type &amp; DT_MASKS_ELLIPSE)</a>
<a name="ln115">      return dt_ellipse_events_button_released(module, pzx, pzy, which, state, sel, fpt-&gt;parentid, gui,</a>
<a name="ln116">                                               gui-&gt;group_edited);</a>
<a name="ln117">    else if(sel-&gt;type &amp; DT_MASKS_BRUSH)</a>
<a name="ln118">      return dt_brush_events_button_released(module, pzx, pzy, which, state, sel, fpt-&gt;parentid, gui,</a>
<a name="ln119">                                             gui-&gt;group_edited);</a>
<a name="ln120">  }</a>
<a name="ln121">  return 0;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">static int dt_group_events_mouse_moved(struct dt_iop_module_t *module, float pzx, float pzy, double pressure,</a>
<a name="ln125">                                       int which, dt_masks_form_t *form, dt_masks_form_gui_t *gui)</a>
<a name="ln126">{</a>
<a name="ln127">  const dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln128">  const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln129">  const float zoom_scale = dt_dev_get_zoom_scale(darktable.develop, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln130">  const float as = 0.005f / zoom_scale * darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln131"> </a>
<a name="ln132">  // we first don't do anything if we are inside a scrolling session</a>
<a name="ln133"> </a>
<a name="ln134">  if(gui-&gt;scrollx != 0.0f &amp;&amp; gui-&gt;scrolly != 0.0f)</a>
<a name="ln135">  {</a>
<a name="ln136">    const float as2 = 0.015f / zoom_scale;</a>
<a name="ln137">    if((gui-&gt;scrollx - pzx &lt; as2 &amp;&amp; gui-&gt;scrollx - pzx &gt; -as2)</a>
<a name="ln138">       &amp;&amp; (gui-&gt;scrolly - pzy &lt; as2 &amp;&amp; gui-&gt;scrolly - pzy &gt; -as2))</a>
<a name="ln139">      return 1;</a>
<a name="ln140">    gui-&gt;scrollx = gui-&gt;scrolly = 0.0f;</a>
<a name="ln141">  }</a>
<a name="ln142"> </a>
<a name="ln143">  // if a form is in edit mode, we first execute the corresponding event</a>
<a name="ln144">  if(gui-&gt;group_edited &gt;= 0)</a>
<a name="ln145">  {</a>
<a name="ln146">    // we get the form</a>
<a name="ln147">    dt_masks_point_group_t *fpt = (dt_masks_point_group_t *)g_list_nth_data(form-&gt;points, gui-&gt;group_edited);</a>
<a name="ln148">    dt_masks_form_t *sel = dt_masks_get_from_id(darktable.develop, fpt-&gt;formid);</a>
<a name="ln149">    if(!sel) return 0;</a>
<a name="ln150">    int rep = 0;</a>
<a name="ln151">    if(sel-&gt;type &amp; DT_MASKS_CIRCLE)</a>
<a name="ln152">      rep = dt_circle_events_mouse_moved(module, pzx, pzy, pressure, which, sel, fpt-&gt;parentid, gui,</a>
<a name="ln153">                                         gui-&gt;group_edited);</a>
<a name="ln154">    else if(sel-&gt;type &amp; DT_MASKS_PATH)</a>
<a name="ln155">      rep = dt_path_events_mouse_moved(module, pzx, pzy, pressure, which, sel, fpt-&gt;parentid, gui,</a>
<a name="ln156">                                       gui-&gt;group_edited);</a>
<a name="ln157">    else if(sel-&gt;type &amp; DT_MASKS_GRADIENT)</a>
<a name="ln158">      rep = dt_gradient_events_mouse_moved(module, pzx, pzy, pressure, which, sel, fpt-&gt;parentid, gui,</a>
<a name="ln159">                                           gui-&gt;group_edited);</a>
<a name="ln160">    else if(sel-&gt;type &amp; DT_MASKS_ELLIPSE)</a>
<a name="ln161">      rep = dt_ellipse_events_mouse_moved(module, pzx, pzy, pressure, which, sel, fpt-&gt;parentid, gui,</a>
<a name="ln162">                                          gui-&gt;group_edited);</a>
<a name="ln163">    else if(sel-&gt;type &amp; DT_MASKS_BRUSH)</a>
<a name="ln164">      rep = dt_brush_events_mouse_moved(module, pzx, pzy, pressure, which, sel, fpt-&gt;parentid, gui,</a>
<a name="ln165">                                        gui-&gt;group_edited);</a>
<a name="ln166">    if(rep) return 1;</a>
<a name="ln167">    // if a point is in state editing, then we don't want that another form can be selected</a>
<a name="ln168">    if(gui-&gt;point_edited &gt;= 0) return 0;</a>
<a name="ln169">  }</a>
<a name="ln170"> </a>
<a name="ln171">  // now we check if we are near a form</a>
<a name="ln172">  GList *fpts = g_list_first(form-&gt;points);</a>
<a name="ln173">  int pos = 0;</a>
<a name="ln174">  gui-&gt;form_selected = gui-&gt;border_selected = FALSE;</a>
<a name="ln175">  gui-&gt;source_selected = gui-&gt;source_dragging = FALSE;</a>
<a name="ln176">  gui-&gt;pivot_selected = FALSE;</a>
<a name="ln177">  gui-&gt;feather_selected = -1;</a>
<a name="ln178">  gui-&gt;point_edited = gui-&gt;point_selected = -1;</a>
<a name="ln179">  gui-&gt;seg_selected = -1;</a>
<a name="ln180">  gui-&gt;point_border_selected = -1;</a>
<a name="ln181">  gui-&gt;group_edited = gui-&gt;group_selected = -1;</a>
<a name="ln182">  while(fpts)</a>
<a name="ln183">  {</a>
<a name="ln184">    dt_masks_point_group_t *fpt = (dt_masks_point_group_t *)fpts-&gt;data;</a>
<a name="ln185">    dt_masks_form_t *sel = dt_masks_get_from_id(darktable.develop, fpt-&gt;formid);</a>
<a name="ln186">    int inside, inside_border, near, inside_source;</a>
<a name="ln187">    inside = inside_border = inside_source = 0;</a>
<a name="ln188">    near = -1;</a>
<a name="ln189">    const float xx = pzx * darktable.develop-&gt;preview_pipe-&gt;backbuf_width,</a>
<a name="ln190">                yy = pzy * darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln191">    if(sel-&gt;type &amp; DT_MASKS_CIRCLE)</a>
<a name="ln192">      dt_circle_get_distance(xx, yy, as, gui, pos, &amp;inside, &amp;inside_border, &amp;near, &amp;inside_source);</a>
<a name="ln193">    else if(sel-&gt;type &amp; DT_MASKS_PATH)</a>
<a name="ln194">      dt_path_get_distance(xx, yy, as, gui, pos, g_list_length(sel-&gt;points), &amp;inside, &amp;inside_border, &amp;near,</a>
<a name="ln195">                           &amp;inside_source);</a>
<a name="ln196">    else if(sel-&gt;type &amp; DT_MASKS_GRADIENT)</a>
<a name="ln197">      dt_gradient_get_distance(xx, yy, as, gui, pos, &amp;inside, &amp;inside_border, &amp;near, &amp;inside_source);</a>
<a name="ln198">    else if(sel-&gt;type &amp; DT_MASKS_ELLIPSE)</a>
<a name="ln199">      dt_ellipse_get_distance(xx, yy, as, gui, pos, &amp;inside, &amp;inside_border, &amp;near, &amp;inside_source);</a>
<a name="ln200">    else if(sel-&gt;type &amp; DT_MASKS_BRUSH)</a>
<a name="ln201">      dt_brush_get_distance(xx, yy, as, gui, pos, g_list_length(sel-&gt;points), &amp;inside, &amp;inside_border, &amp;near,</a>
<a name="ln202">                            &amp;inside_source);</a>
<a name="ln203">    if(inside || inside_border || near &gt;= 0 || inside_source)</a>
<a name="ln204">    {</a>
<a name="ln205">      gui-&gt;group_edited = gui-&gt;group_selected = pos;</a>
<a name="ln206">      if(sel-&gt;type &amp; DT_MASKS_CIRCLE)</a>
<a name="ln207">        return dt_circle_events_mouse_moved(module, pzx, pzy, pressure, which, sel, fpt-&gt;parentid, gui, pos);</a>
<a name="ln208">      else if(sel-&gt;type &amp; DT_MASKS_PATH)</a>
<a name="ln209">        return dt_path_events_mouse_moved(module, pzx, pzy, pressure, which, sel, fpt-&gt;parentid, gui, pos);</a>
<a name="ln210">      else if(sel-&gt;type &amp; DT_MASKS_GRADIENT)</a>
<a name="ln211">        return dt_gradient_events_mouse_moved(module, pzx, pzy, pressure, which, sel, fpt-&gt;parentid, gui, pos);</a>
<a name="ln212">      else if(sel-&gt;type &amp; DT_MASKS_ELLIPSE)</a>
<a name="ln213">        return dt_ellipse_events_mouse_moved(module, pzx, pzy, pressure, which, sel, fpt-&gt;parentid, gui, pos);</a>
<a name="ln214">      else if(sel-&gt;type &amp; DT_MASKS_BRUSH)</a>
<a name="ln215">        return dt_brush_events_mouse_moved(module, pzx, pzy, pressure, which, sel, fpt-&gt;parentid, gui, pos);</a>
<a name="ln216">    }</a>
<a name="ln217">    fpts = g_list_next(fpts);</a>
<a name="ln218">    pos++;</a>
<a name="ln219">  }</a>
<a name="ln220">  dt_control_queue_redraw_center();</a>
<a name="ln221">  return 0;</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">static void dt_group_events_post_expose(cairo_t *cr, float zoom_scale, dt_masks_form_t *form,</a>
<a name="ln225">                                        dt_masks_form_gui_t *gui)</a>
<a name="ln226">{</a>
<a name="ln227">  GList *fpts = g_list_first(form-&gt;points);</a>
<a name="ln228">  int pos = 0;</a>
<a name="ln229">  while(fpts)</a>
<a name="ln230">  {</a>
<a name="ln231">    dt_masks_point_group_t *fpt = (dt_masks_point_group_t *)fpts-&gt;data;</a>
<a name="ln232">    dt_masks_form_t *sel = dt_masks_get_from_id(darktable.develop, fpt-&gt;formid);</a>
<a name="ln233">    if (!sel) return;</a>
<a name="ln234">    if(sel-&gt;type &amp; DT_MASKS_CIRCLE)</a>
<a name="ln235">      dt_circle_events_post_expose(cr, zoom_scale, gui, pos);</a>
<a name="ln236">    else if(sel-&gt;type &amp; DT_MASKS_PATH)</a>
<a name="ln237">      dt_path_events_post_expose(cr, zoom_scale, gui, pos, g_list_length(sel-&gt;points));</a>
<a name="ln238">    else if(sel-&gt;type &amp; DT_MASKS_GRADIENT)</a>
<a name="ln239">      dt_gradient_events_post_expose(cr, zoom_scale, gui, pos);</a>
<a name="ln240">    else if(sel-&gt;type &amp; DT_MASKS_ELLIPSE)</a>
<a name="ln241">      dt_ellipse_events_post_expose(cr, zoom_scale, gui, pos);</a>
<a name="ln242">    else if(sel-&gt;type &amp; DT_MASKS_BRUSH)</a>
<a name="ln243">      dt_brush_events_post_expose(cr, zoom_scale, gui, pos, g_list_length(sel-&gt;points));</a>
<a name="ln244">    fpts = g_list_next(fpts);</a>
<a name="ln245">    pos++;</a>
<a name="ln246">  }</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">static void _inverse_mask(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, dt_masks_form_t *form,</a>
<a name="ln250">                          float **buffer, int *width, int *height, int *posx, int *posy)</a>
<a name="ln251">{</a>
<a name="ln252">  // we create a new buffer</a>
<a name="ln253">  const int wt = piece-&gt;iwidth;</a>
<a name="ln254">  const int ht = piece-&gt;iheight;</a>
<a name="ln255">  float *buf = malloc((size_t)ht * wt * sizeof(float));</a>
<a name="ln256"> </a>
<a name="ln257">  // we fill this buffer</a>
<a name="ln258">  for(int yy = 0; yy &lt; MIN(*posy, ht); yy++)</a>
<a name="ln259">  {</a>
<a name="ln260">    for(int xx = 0; xx &lt; wt; xx++) buf[(size_t)yy * wt + xx] = 1.0f;</a>
<a name="ln261">  }</a>
<a name="ln262"> </a>
<a name="ln263">  for(int yy = MAX(*posy, 0); yy &lt; MIN(ht, (*posy) + (*height)); yy++)</a>
<a name="ln264">  {</a>
<a name="ln265">    for(int xx = 0; xx &lt; MIN((*posx), wt); xx++) buf[(size_t)yy * wt + xx] = 1.0f;</a>
<a name="ln266">    for(int xx = MAX((*posx), 0); xx &lt; MIN(wt, (*posx) + (*width)); xx++)</a>
<a name="ln267">      buf[(size_t)yy * wt + xx] = 1.0f - (*buffer)[((size_t)yy - (*posy)) * (*width) + xx - (*posx)];</a>
<a name="ln268">    for(int xx = MAX((*posx) + (*width), 0); xx &lt; wt; xx++) buf[(size_t)yy * wt + xx] = 1.0f;</a>
<a name="ln269">  }</a>
<a name="ln270"> </a>
<a name="ln271">  for(int yy = MAX((*posy) + (*height), 0); yy &lt; ht; yy++)</a>
<a name="ln272">  {</a>
<a name="ln273">    for(int xx = 0; xx &lt; wt; xx++) buf[(size_t)yy * wt + xx] = 1.0f;</a>
<a name="ln274">  }</a>
<a name="ln275"> </a>
<a name="ln276">  // we free the old buffer</a>
<a name="ln277">  free(*buffer);</a>
<a name="ln278">  (*buffer) = buf;</a>
<a name="ln279"> </a>
<a name="ln280">  // we return correct values for positions;</a>
<a name="ln281">  *posx = *posy = 0;</a>
<a name="ln282">  *width = wt;</a>
<a name="ln283">  *height = ht;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">static int dt_group_get_mask(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, dt_masks_form_t *form,</a>
<a name="ln287">                             float **buffer, int *width, int *height, int *posx, int *posy)</a>
<a name="ln288">{</a>
<a name="ln289">  // we allocate buffers and values</a>
<a name="ln290">  const guint nb = g_list_length(form-&gt;points);</a>
<a name="ln291">  if(nb == 0) return 0;</a>
<a name="ln292">  float **bufs = calloc(nb, sizeof(float *));</a>
<a name="ln293">  int *w = malloc(nb * sizeof(int));</a>
<a name="ln294">  int *h = malloc(nb * sizeof(int));</a>
<a name="ln295">  int *px = malloc(nb * sizeof(int));</a>
<a name="ln296">  int *py = malloc(nb * sizeof(int));</a>
<a name="ln297">  int *ok = malloc(nb * sizeof(int));</a>
<a name="ln298">  int *states = malloc(nb * sizeof(int));</a>
<a name="ln299">  float *op = malloc(nb * sizeof(float));</a>
<a name="ln300"> </a>
<a name="ln301">  // and we get all masks</a>
<a name="ln302">  GList *fpts = g_list_first(form-&gt;points);</a>
<a name="ln303">  int pos = 0;</a>
<a name="ln304">  int nb_ok = 0;</a>
<a name="ln305">  while(fpts)</a>
<a name="ln306">  {</a>
<a name="ln307">    dt_masks_point_group_t *fpt = (dt_masks_point_group_t *)fpts-&gt;data;</a>
<a name="ln308">    dt_masks_form_t *sel = dt_masks_get_from_id(module-&gt;dev, fpt-&gt;formid);</a>
<a name="ln309">    if(sel)</a>
<a name="ln310">    {</a>
<a name="ln311">      ok[pos] = dt_masks_get_mask(module, piece, sel, &amp;bufs[pos], &amp;w[pos], &amp;h[pos], &amp;px[pos], &amp;py[pos]);</a>
<a name="ln312">      if(fpt-&gt;state &amp; DT_MASKS_STATE_INVERSE)</a>
<a name="ln313">      {</a>
<a name="ln314">        const double start = dt_get_wtime();</a>
<a name="ln315">        _inverse_mask(module, piece, sel, &amp;bufs[pos], &amp;w[pos], &amp;h[pos], &amp;px[pos], &amp;py[pos]);</a>
<a name="ln316">        if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln317">          dt_print(DT_DEBUG_MASKS, &quot;[masks %s] inverse took %0.04f sec\n&quot;, sel-&gt;name, dt_get_wtime() - start);</a>
<a name="ln318">      }</a>
<a name="ln319">      op[pos] = fpt-&gt;opacity;</a>
<a name="ln320">      states[pos] = fpt-&gt;state;</a>
<a name="ln321">      if(ok[pos]) nb_ok++;</a>
<a name="ln322">    }</a>
<a name="ln323">    fpts = g_list_next(fpts);</a>
<a name="ln324">    pos++;</a>
<a name="ln325">  }</a>
<a name="ln326">  if(nb_ok == 0) goto error;</a>
<a name="ln327"> </a>
<a name="ln328">  // now we get the min, max, width, height of the final mask</a>
<a name="ln329">  int l, r, t, b;</a>
<a name="ln330">  l = t = INT_MAX;</a>
<a name="ln331">  r = b = INT_MIN;</a>
<a name="ln332">  for(int i = 0; i &lt; nb; i++)</a>
<a name="ln333">  {</a>
<a name="ln334">    l = MIN(l, px[i]);</a>
<a name="ln335">    t = MIN(t, py[i]);</a>
<a name="ln336">    r = MAX(r, px[i] + w[i]);</a>
<a name="ln337">    b = MAX(b, py[i] + h[i]);</a>
<a name="ln338">  }</a>
<a name="ln339">  *posx = l;</a>
<a name="ln340">  *posy = t;</a>
<a name="ln341">  *width = r - l;</a>
<a name="ln342">  *height = b - t;</a>
<a name="ln343"> </a>
<a name="ln344">  // we allocate the buffer</a>
<a name="ln345">  *buffer = malloc(sizeof(float) * (r - l) * (b - t));</a>
<a name="ln346"> </a>
<a name="ln347">  // and we copy each buffer inside, row by row</a>
<a name="ln348">  for(int i = 0; i &lt; nb; i++)</a>
<a name="ln349">  {</a>
<a name="ln350">    const double start = dt_get_wtime();</a>
<a name="ln351">    if(states[i] &amp; DT_MASKS_STATE_UNION)</a>
<a name="ln352">    {</a>
<a name="ln353">      for(int y = 0; y &lt; h[i]; y++)</a>
<a name="ln354">      {</a>
<a name="ln355">        for(int x = 0; x &lt; w[i]; x++)</a>
<a name="ln356">        {</a>
<a name="ln357">          (*buffer)[(py[i] + y - t) * (r - l) + px[i] + x - l]</a>
<a name="ln358">              = fmaxf((*buffer)[(py[i] + y - t) * (r - l) + px[i] + x - l], bufs[i][y * w[i] + x] * op[i]);</a>
<a name="ln359">        }</a>
<a name="ln360">      }</a>
<a name="ln361">    }</a>
<a name="ln362">    else if(states[i] &amp; DT_MASKS_STATE_INTERSECTION)</a>
<a name="ln363">    {</a>
<a name="ln364">      for(int y = 0; y &lt; b - t; y++)</a>
<a name="ln365">      {</a>
<a name="ln366">        for(int x = 0; x &lt; r - l; x++)</a>
<a name="ln367">        {</a>
<a name="ln368">          const float b1 = (*buffer)[y * (r - l) + x];</a>
<a name="ln369">          float b2 = 0.0f;</a>
<a name="ln370">          if(y + t - py[i] &gt;= 0 &amp;&amp; y + t - py[i] &lt; h[i] &amp;&amp; x + l - px[i] &gt;= 0 &amp;&amp; x + l - px[i] &lt; w[i])</a>
<a name="ln371">            b2 = bufs[i][(y + t - py[i]) * w[i] + x + l - px[i]];</a>
<a name="ln372">          if(b1 &gt; 0.0f &amp;&amp; b2 &gt; 0.0f)</a>
<a name="ln373">            (*buffer)[y * (r - l) + x] = fminf(b1, b2 * op[i]);</a>
<a name="ln374">          else</a>
<a name="ln375">            (*buffer)[y * (r - l) + x] = 0.0f;</a>
<a name="ln376">        }</a>
<a name="ln377">      }</a>
<a name="ln378">    }</a>
<a name="ln379">    else if(states[i] &amp; DT_MASKS_STATE_DIFFERENCE)</a>
<a name="ln380">    {</a>
<a name="ln381">      for(int y = 0; y &lt; h[i]; y++)</a>
<a name="ln382">      {</a>
<a name="ln383">        for(int x = 0; x &lt; w[i]; x++)</a>
<a name="ln384">        {</a>
<a name="ln385">          const float b1 = (*buffer)[(py[i] + y - t) * (r - l) + px[i] + x - l];</a>
<a name="ln386">          const float b2 = bufs[i][y * w[i] + x] * op[i];</a>
<a name="ln387">          if(b1 &gt; 0.0f &amp;&amp; b2 &gt; 0.0f) (*buffer)[(py[i] + y - t) * (r - l) + px[i] + x - l] = b1 * (1.0f - b2);</a>
<a name="ln388">        }</a>
<a name="ln389">      }</a>
<a name="ln390">    }</a>
<a name="ln391">    else if(states[i] &amp; DT_MASKS_STATE_EXCLUSION)</a>
<a name="ln392">    {</a>
<a name="ln393">      for(int y = 0; y &lt; h[i]; y++)</a>
<a name="ln394">      {</a>
<a name="ln395">        for(int x = 0; x &lt; w[i]; x++)</a>
<a name="ln396">        {</a>
<a name="ln397">          const float b1 = (*buffer)[(py[i] + y - t) * (r - l) + px[i] + x - l];</a>
<a name="ln398">          const float b2 = bufs[i][y * w[i] + x] * op[i];</a>
<a name="ln399">          if(b1 &gt; 0.0f &amp;&amp; b2 &gt; 0.0f)</a>
<a name="ln400">            (*buffer)[(py[i] + y - t) * (r - l) + px[i] + x - l] = fmaxf((1.0f - b1) * b2, b1 * (1.0f - b2));</a>
<a name="ln401">          else</a>
<a name="ln402">            (*buffer)[(py[i] + y - t) * (r - l) + px[i] + x - l]</a>
<a name="ln403">                = fmaxf((*buffer)[(py[i] + y - t) * (r - l) + px[i] + x - l], bufs[i][y * w[i] + x] * op[i]);</a>
<a name="ln404">        }</a>
<a name="ln405">      }</a>
<a name="ln406">    }</a>
<a name="ln407">    else // if we are here, this mean that we just have to copy the shape and null other parts</a>
<a name="ln408">    {</a>
<a name="ln409">      for(int y = 0; y &lt; b - t; y++)</a>
<a name="ln410">      {</a>
<a name="ln411">        for(int x = 0; x &lt; r - l; x++)</a>
<a name="ln412">        {</a>
<a name="ln413">          float b2 = 0.0f;</a>
<a name="ln414">          if(y + t - py[i] &gt;= 0 &amp;&amp; y + t - py[i] &lt; h[i] &amp;&amp; x + l - px[i] &gt;= 0 &amp;&amp; x + l - px[i] &lt; w[i])</a>
<a name="ln415">            b2 = bufs[i][(y + t - py[i]) * w[i] + x + l - px[i]];</a>
<a name="ln416">          (*buffer)[y * (r - l) + x] = b2 * op[i];</a>
<a name="ln417">        }</a>
<a name="ln418">      }</a>
<a name="ln419">    }</a>
<a name="ln420"> </a>
<a name="ln421">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln422">      dt_print(DT_DEBUG_MASKS, &quot;[masks %d] combine took %0.04f sec\n&quot;, i, dt_get_wtime() - start);</a>
<a name="ln423">  }</a>
<a name="ln424"> </a>
<a name="ln425">  free(op);</a>
<a name="ln426">  free(states);</a>
<a name="ln427">  free(ok);</a>
<a name="ln428">  free(py);</a>
<a name="ln429">  free(px);</a>
<a name="ln430">  free(h);</a>
<a name="ln431">  free(w);</a>
<a name="ln432">  for(int i = 0; i &lt; nb; i++) free(bufs[i]);</a>
<a name="ln433">  free(bufs);</a>
<a name="ln434">  return 1;</a>
<a name="ln435"> </a>
<a name="ln436">error:</a>
<a name="ln437">  free(op);</a>
<a name="ln438">  free(states);</a>
<a name="ln439">  free(ok);</a>
<a name="ln440">  free(py);</a>
<a name="ln441">  free(px);</a>
<a name="ln442">  free(h);</a>
<a name="ln443">  free(w);</a>
<a name="ln444">  for(int i = 0; i &lt; nb; i++) free(bufs[i]);</a>
<a name="ln445">  free(bufs);</a>
<a name="ln446">  return 0;</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">static int dt_group_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln450">                                 dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer)</a>
<a name="ln451">{</a>
<a name="ln452">  double start = dt_get_wtime();</a>
<a name="ln453">  const guint nb = g_list_length(form-&gt;points);</a>
<a name="ln454">  if(nb == 0) return 0;</a>
<a name="ln455">  int nb_ok = 0;</a>
<a name="ln456"> </a>
<a name="ln457">  const int width = roi-&gt;width;</a>
<a name="ln458">  const int height = roi-&gt;height;</a>
<a name="ln459"> </a>
<a name="ln460">  // we need to allocate a temporary buffer for intermediate creation of individual shapes</a>
<a name="ln461">  float *bufs = dt_alloc_align(64, (size_t)width * height * sizeof(float));</a>
<a name="ln462">  if(bufs == NULL) return 0;</a>
<a name="ln463"> </a>
<a name="ln464">  // empty the output buffer</a>
<a name="ln465">  memset(buffer, 0, (size_t)width * height * sizeof(float));</a>
<a name="ln466"> </a>
<a name="ln467">  // and we get all masks</a>
<a name="ln468">  GList *fpts = g_list_first(form-&gt;points);</a>
<a name="ln469"> </a>
<a name="ln470">  while(fpts)</a>
<a name="ln471">  {</a>
<a name="ln472">    dt_masks_point_group_t *fpt = (dt_masks_point_group_t *)fpts-&gt;data;</a>
<a name="ln473">    dt_masks_form_t *sel = dt_masks_get_from_id(module-&gt;dev, fpt-&gt;formid);</a>
<a name="ln474"> </a>
<a name="ln475">    if(sel)</a>
<a name="ln476">    {</a>
<a name="ln477">      const int ok = dt_masks_get_mask_roi(module, piece, sel, roi, bufs);</a>
<a name="ln478">      const float op = fpt-&gt;opacity;</a>
<a name="ln479">      const int state = fpt-&gt;state;</a>
<a name="ln480"> </a>
<a name="ln481">      if(ok)</a>
<a name="ln482">      {</a>
<a name="ln483">        // first see if we need to invert this shape</a>
<a name="ln484">        if(state &amp; DT_MASKS_STATE_INVERSE)</a>
<a name="ln485">        {</a>
<a name="ln486">#ifdef _OPENMP</a>
<a name="ln487">#if !defined(__SUNOS__) &amp;&amp; !defined(__NetBSD__)</a>
<a name="ln488">#pragma omp parallel for default(none) shared(bufs)</a>
<a name="ln489">#else</a>
<a name="ln490">#pragma omp parallel for shared(bufs)</a>
<a name="ln491">#endif</a>
<a name="ln492">#endif</a>
<a name="ln493">          for(int y = 0; y &lt; height; y++)</a>
<a name="ln494">            for(int x = 0; x &lt; width; x++)</a>
<a name="ln495">            {</a>
<a name="ln496">              const size_t index = (size_t)y * width + x;</a>
<a name="ln497">              bufs[index] = 1.0f - bufs[index];</a>
<a name="ln498">            }</a>
<a name="ln499">        }</a>
<a name="ln500"> </a>
<a name="ln501">        if(state &amp; DT_MASKS_STATE_UNION)</a>
<a name="ln502">        {</a>
<a name="ln503">#ifdef _OPENMP</a>
<a name="ln504">#if !defined(__SUNOS__) &amp;&amp; !defined(__NetBSD__)</a>
<a name="ln505">#pragma omp parallel for default(none) shared(bufs, buffer)</a>
<a name="ln506">#else</a>
<a name="ln507">#pragma omp parallel for shared(bufs, buffer)</a>
<a name="ln508">#endif</a>
<a name="ln509">#endif</a>
<a name="ln510">          for(int y = 0; y &lt; height; y++)</a>
<a name="ln511">            for(int x = 0; x &lt; width; x++)</a>
<a name="ln512">            {</a>
<a name="ln513">              const size_t index = (size_t)y * width + x;</a>
<a name="ln514">              buffer[index] = fmaxf(buffer[index], bufs[index] * op);</a>
<a name="ln515">            }</a>
<a name="ln516">        }</a>
<a name="ln517">        else if(state &amp; DT_MASKS_STATE_INTERSECTION)</a>
<a name="ln518">        {</a>
<a name="ln519">#ifdef _OPENMP</a>
<a name="ln520">#if !defined(__SUNOS__) &amp;&amp; !defined(__NetBSD__)</a>
<a name="ln521">#pragma omp parallel for default(none) shared(bufs, buffer)</a>
<a name="ln522">#else</a>
<a name="ln523">#pragma omp parallel for shared(bufs, buffer)</a>
<a name="ln524">#endif</a>
<a name="ln525">#endif</a>
<a name="ln526">          for(int y = 0; y &lt; height; y++)</a>
<a name="ln527">            for(int x = 0; x &lt; width; x++)</a>
<a name="ln528">            {</a>
<a name="ln529">              const size_t index = (size_t)y * width + x;</a>
<a name="ln530">              const float b1 = buffer[index];</a>
<a name="ln531">              const float b2 = bufs[index];</a>
<a name="ln532">              if(b1 &gt; 0.0f &amp;&amp; b2 &gt; 0.0f)</a>
<a name="ln533">                buffer[index] = fminf(b1, b2 * op);</a>
<a name="ln534">              else</a>
<a name="ln535">                buffer[index] = 0.0f;</a>
<a name="ln536">            }</a>
<a name="ln537">        }</a>
<a name="ln538">        else if(state &amp; DT_MASKS_STATE_DIFFERENCE)</a>
<a name="ln539">        {</a>
<a name="ln540">#ifdef _OPENMP</a>
<a name="ln541">#if !defined(__SUNOS__) &amp;&amp; !defined(__NetBSD__)</a>
<a name="ln542">#pragma omp parallel for default(none) shared(bufs, buffer)</a>
<a name="ln543">#else</a>
<a name="ln544">#pragma omp parallel for shared(bufs, buffer)</a>
<a name="ln545">#endif</a>
<a name="ln546">#endif</a>
<a name="ln547">          for(int y = 0; y &lt; height; y++)</a>
<a name="ln548">            for(int x = 0; x &lt; width; x++)</a>
<a name="ln549">            {</a>
<a name="ln550">              const size_t index = (size_t)y * width + x;</a>
<a name="ln551">              const float b1 = buffer[index];</a>
<a name="ln552">              const float b2 = bufs[index] * op;</a>
<a name="ln553">              if(b1 &gt; 0.0f &amp;&amp; b2 &gt; 0.0f) buffer[index] = b1 * (1.0f - b2);</a>
<a name="ln554">            }</a>
<a name="ln555">        }</a>
<a name="ln556">        else if(state &amp; DT_MASKS_STATE_EXCLUSION)</a>
<a name="ln557">        {</a>
<a name="ln558">#ifdef _OPENMP</a>
<a name="ln559">#if !defined(__SUNOS__) &amp;&amp; !defined(__NetBSD__)</a>
<a name="ln560">#pragma omp parallel for default(none) shared(bufs, buffer)</a>
<a name="ln561">#else</a>
<a name="ln562">#pragma omp parallel for shared(bufs, buffer)</a>
<a name="ln563">#endif</a>
<a name="ln564">#endif</a>
<a name="ln565">          for(int y = 0; y &lt; height; y++)</a>
<a name="ln566">            for(int x = 0; x &lt; width; x++)</a>
<a name="ln567">            {</a>
<a name="ln568">              const size_t index = (size_t)y * width + x;</a>
<a name="ln569">              const float b1 = buffer[index];</a>
<a name="ln570">              const float b2 = bufs[index] * op;</a>
<a name="ln571">              if(b1 &gt; 0.0f &amp;&amp; b2 &gt; 0.0f)</a>
<a name="ln572">                buffer[index] = fmaxf((1.0f - b1) * b2, b1 * (1.0f - b2));</a>
<a name="ln573">              else</a>
<a name="ln574">                buffer[index] = fmaxf(b1, b2);</a>
<a name="ln575">            }</a>
<a name="ln576">        }</a>
<a name="ln577">        else // if we are here, this mean that we just have to copy the shape and null other parts</a>
<a name="ln578">        {</a>
<a name="ln579">#ifdef _OPENMP</a>
<a name="ln580">#if !defined(__SUNOS__) &amp;&amp; !defined(__NetBSD__)</a>
<a name="ln581">#pragma omp parallel for default(none) shared(bufs, buffer)</a>
<a name="ln582">#else</a>
<a name="ln583">#pragma omp parallel for shared(bufs, buffer)</a>
<a name="ln584">#endif</a>
<a name="ln585">#endif</a>
<a name="ln586">          for(int y = 0; y &lt; height; y++)</a>
<a name="ln587">            for(int x = 0; x &lt; width; x++)</a>
<a name="ln588">            {</a>
<a name="ln589">              const size_t index = (size_t)y * width + x;</a>
<a name="ln590">              buffer[index] = bufs[index] * op;</a>
<a name="ln591">            }</a>
<a name="ln592">        }</a>
<a name="ln593"> </a>
<a name="ln594">        if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln595">          dt_print(DT_DEBUG_MASKS, &quot;[masks %d] combine took %0.04f sec\n&quot;, nb_ok, dt_get_wtime() - start);</a>
<a name="ln596">        start = dt_get_wtime();</a>
<a name="ln597"> </a>
<a name="ln598">        nb_ok++;</a>
<a name="ln599">      }</a>
<a name="ln600">    }</a>
<a name="ln601">    fpts = g_list_next(fpts);</a>
<a name="ln602">  }</a>
<a name="ln603"> </a>
<a name="ln604">  // and we free the intermediate buffer</a>
<a name="ln605">  dt_free_align(bufs);</a>
<a name="ln606"> </a>
<a name="ln607">  return nb_ok != 0;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">int dt_masks_group_render_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, dt_masks_form_t *form,</a>
<a name="ln611">                              const dt_iop_roi_t *roi, float *buffer)</a>
<a name="ln612">{</a>
<a name="ln613">  const double start = dt_get_wtime();</a>
<a name="ln614">  if(!form) return 0;</a>
<a name="ln615"> </a>
<a name="ln616">  const int ok = dt_masks_get_mask_roi(module, piece, form, roi, buffer);</a>
<a name="ln617"> </a>
<a name="ln618">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln619">    dt_print(DT_DEBUG_MASKS, &quot;[masks] render all masks took %0.04f sec\n&quot;, dt_get_wtime() - start);</a>
<a name="ln620">  return ok;</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln624">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln625">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="260"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'buf'. Check lines: 260, 255.</p></div>
<div class="balloon" rel="311"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'ok'. Check lines: 311, 297.</p></div>
<div class="balloon" rel="311"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'bufs'. Check lines: 311, 292.</p></div>
<div class="balloon" rel="311"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'w'. Check lines: 311, 293.</p></div>
<div class="balloon" rel="311"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'h'. Check lines: 311, 294.</p></div>
<div class="balloon" rel="311"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'px'. Check lines: 311, 295.</p></div>
<div class="balloon" rel="311"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'py'. Check lines: 311, 296.</p></div>
<div class="balloon" rel="319"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'op'. Check lines: 319, 299.</p></div>
<div class="balloon" rel="320"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'states'. Check lines: 320, 298.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
