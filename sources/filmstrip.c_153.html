
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011-2012 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/collection.h&quot;</a>
<a name="ln20">#include &quot;common/colorlabels.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/history.h&quot;</a>
<a name="ln24">#include &quot;common/image_cache.h&quot;</a>
<a name="ln25">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln26">#include &quot;common/ratings.h&quot;</a>
<a name="ln27">#include &quot;common/selection.h&quot;</a>
<a name="ln28">#include &quot;control/conf.h&quot;</a>
<a name="ln29">#include &quot;control/control.h&quot;</a>
<a name="ln30">#include &quot;develop/develop.h&quot;</a>
<a name="ln31">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln32">#include &quot;gui/drag_and_drop.h&quot;</a>
<a name="ln33">#include &quot;gui/gtk.h&quot;</a>
<a name="ln34">#include &quot;gui/hist_dialog.h&quot;</a>
<a name="ln35">#include &quot;libs/lib.h&quot;</a>
<a name="ln36">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln37">#include &quot;views/view.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">DT_MODULE(1)</a>
<a name="ln42"> </a>
<a name="ln43">typedef enum dt_lib_filmstrip_select_t</a>
<a name="ln44">{</a>
<a name="ln45">  DT_LIB_FILMSTRIP_SELECT_NONE,</a>
<a name="ln46">  DT_LIB_FILMSTRIP_SELECT_SINGLE,</a>
<a name="ln47">  DT_LIB_FILMSTRIP_SELECT_TOGGLE,</a>
<a name="ln48">  DT_LIB_FILMSTRIP_SELECT_RANGE</a>
<a name="ln49">} dt_lib_filmstrip_select_t;</a>
<a name="ln50"> </a>
<a name="ln51">typedef struct dt_lib_filmstrip_t</a>
<a name="ln52">{</a>
<a name="ln53">  GtkWidget *filmstrip;</a>
<a name="ln54"> </a>
<a name="ln55">  /* state vars */</a>
<a name="ln56">  int32_t last_selected_id;</a>
<a name="ln57">  int32_t mouse_over_id;</a>
<a name="ln58">  int32_t offset;</a>
<a name="ln59">  int32_t collection_count;</a>
<a name="ln60">  int32_t history_copy_imgid;</a>
<a name="ln61">  gdouble pointerx, pointery;</a>
<a name="ln62">  dt_view_image_over_t image_over;</a>
<a name="ln63"> </a>
<a name="ln64">  gboolean size_handle_is_dragging;</a>
<a name="ln65">  gint size_handle_x, size_handle_y;</a>
<a name="ln66">  int32_t size_handle_height;</a>
<a name="ln67"> </a>
<a name="ln68">  int32_t activated_image;</a>
<a name="ln69">  dt_lib_filmstrip_select_t select;</a>
<a name="ln70">  int32_t select_id;</a>
<a name="ln71"> </a>
<a name="ln72">  float thumb_size;</a>
<a name="ln73">  float offset_x;</a>
<a name="ln74">  int last_mouse_over_thumb;</a>
<a name="ln75">  int32_t last_exposed_id;</a>
<a name="ln76">  gboolean force_expose_all;</a>
<a name="ln77">  cairo_surface_t *surface;</a>
<a name="ln78">  GHashTable *thumbs_table;</a>
<a name="ln79">  int32_t panel_width;</a>
<a name="ln80"> </a>
<a name="ln81">  dt_gui_hist_dialog_t dg;</a>
<a name="ln82">} dt_lib_filmstrip_t;</a>
<a name="ln83"> </a>
<a name="ln84">/* proxy function to center filmstrip on imgid */</a>
<a name="ln85">static void _lib_filmstrip_scroll_to_image(dt_lib_module_t *self, gint imgid, gboolean activate);</a>
<a name="ln86">/* proxy function for retrieving last activate request image id */</a>
<a name="ln87">static int32_t _lib_filmstrip_get_activated_imgid(dt_lib_module_t *self);</a>
<a name="ln88">static GtkWidget *_lib_filmstrip_get_widget(dt_lib_module_t *self);</a>
<a name="ln89"> </a>
<a name="ln90">static gboolean _lib_filmstrip_size_handle_button_callback(GtkWidget *w, GdkEventButton *e,</a>
<a name="ln91">                                                           gpointer user_data);</a>
<a name="ln92">static gboolean _lib_filmstrip_size_handle_motion_notify_callback(GtkWidget *w, GdkEventButton *e,</a>
<a name="ln93">                                                                  gpointer user_data);</a>
<a name="ln94">static gboolean _lib_filmstrip_size_handle_cursor_callback(GtkWidget *w, GdkEventCrossing *e,</a>
<a name="ln95">                                                           gpointer user_data);</a>
<a name="ln96"> </a>
<a name="ln97">/* motion notify event handler */</a>
<a name="ln98">static gboolean _lib_filmstrip_motion_notify_callback(GtkWidget *w, GdkEventMotion *e, gpointer user_data);</a>
<a name="ln99">/* motion leave event handler */</a>
<a name="ln100">static gboolean _lib_filmstrip_mouse_leave_callback(GtkWidget *w, GdkEventCrossing *e, gpointer user_data);</a>
<a name="ln101">/* scroll event */</a>
<a name="ln102">static gboolean _lib_filmstrip_scroll_callback(GtkWidget *w, GdkEventScroll *e, gpointer user_data);</a>
<a name="ln103">/* expose function for filmstrip module */</a>
<a name="ln104">static gboolean _lib_filmstrip_draw_callback(GtkWidget *widget, cairo_t *cr, gpointer user_data);</a>
<a name="ln105">/* button press callback */</a>
<a name="ln106">static gboolean _lib_filmstrip_button_press_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln107">                                                     gpointer user_data);</a>
<a name="ln108">/* button release callback */</a>
<a name="ln109">static gboolean _lib_filmstrip_button_release_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln110">                                                       gpointer user_data);</a>
<a name="ln111">/* signal callback for collection change */</a>
<a name="ln112">static void _lib_filmstrip_collection_changed_callback(gpointer instance, gpointer user_data);</a>
<a name="ln113"> </a>
<a name="ln114">/* key accelerators callback */</a>
<a name="ln115">static gboolean _lib_filmstrip_copy_history_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln116">                                                               GObject *aceeleratable, guint keyval,</a>
<a name="ln117">                                                               GdkModifierType modifier, gpointer data);</a>
<a name="ln118">static gboolean _lib_filmstrip_copy_history_parts_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln119">                                                                     GObject *aceeleratable, guint keyval,</a>
<a name="ln120">                                                                     GdkModifierType modifier, gpointer data);</a>
<a name="ln121">static gboolean _lib_filmstrip_paste_history_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln122">                                                                GObject *aceeleratable, guint keyval,</a>
<a name="ln123">                                                                GdkModifierType modifier, gpointer data);</a>
<a name="ln124">static gboolean _lib_filmstrip_paste_history_parts_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln125">                                                                      GObject *aceeleratable, guint keyval,</a>
<a name="ln126">                                                                      GdkModifierType modifier,</a>
<a name="ln127">                                                                      gpointer data);</a>
<a name="ln128">static gboolean _lib_filmstrip_discard_history_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln129">                                                                  GObject *aceeleratable, guint keyval,</a>
<a name="ln130">                                                                  GdkModifierType modifier, gpointer data);</a>
<a name="ln131">static gboolean _lib_filmstrip_duplicate_image_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln132">                                                                  GObject *aceeleratable, guint keyval,</a>
<a name="ln133">                                                                  GdkModifierType modifier, gpointer data);</a>
<a name="ln134">static gboolean _lib_filmstrip_ratings_key_accel_callback(GtkAccelGroup *accel_group, GObject *aceeleratable,</a>
<a name="ln135">                                                          guint keyval, GdkModifierType modifier,</a>
<a name="ln136">                                                          gpointer data);</a>
<a name="ln137">static gboolean _lib_filmstrip_colorlabels_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln138">                                                              GObject *aceeleratable, guint keyval,</a>
<a name="ln139">                                                              GdkModifierType modifier, gpointer data);</a>
<a name="ln140">static gboolean _lib_filmstrip_select_key_accel_callback(GtkAccelGroup *accel_group, GObject *aceeleratable,</a>
<a name="ln141">                                                         guint keyval, GdkModifierType modifier,</a>
<a name="ln142">                                                         gpointer data);</a>
<a name="ln143"> </a>
<a name="ln144">/* drag'n'drop callbacks */</a>
<a name="ln145">static void _lib_filmstrip_dnd_get_callback(GtkWidget *widget, GdkDragContext *context,</a>
<a name="ln146">                                            GtkSelectionData *selection_data, guint target_type, guint time,</a>
<a name="ln147">                                            gpointer user_data);</a>
<a name="ln148">static void _lib_filmstrip_dnd_begin_callback(GtkWidget *widget, GdkDragContext *context, gpointer user_data);</a>
<a name="ln149"> </a>
<a name="ln150">const char *name(dt_lib_module_t *self)</a>
<a name="ln151">{</a>
<a name="ln152">  return _(&quot;filmstrip&quot;);</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">const char **views(dt_lib_module_t *self)</a>
<a name="ln156">{</a>
<a name="ln157">  static const char *v[] = {&quot;lighttable&quot;, &quot;darkroom&quot;, &quot;tethering&quot;, &quot;map&quot;, &quot;print&quot;, NULL};</a>
<a name="ln158">  return v;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln162">{</a>
<a name="ln163">  return DT_UI_CONTAINER_PANEL_BOTTOM;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">int expandable(dt_lib_module_t *self)</a>
<a name="ln167">{</a>
<a name="ln168">  return 0;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">int position()</a>
<a name="ln172">{</a>
<a name="ln173">  return 1001;</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln177">{</a>
<a name="ln178">  /* setup rating key accelerators */</a>
<a name="ln179">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;rate 0&quot;), GDK_KEY_0, 0);</a>
<a name="ln180">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;rate 1&quot;), GDK_KEY_1, 0);</a>
<a name="ln181">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;rate 2&quot;), GDK_KEY_2, 0);</a>
<a name="ln182">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;rate 3&quot;), GDK_KEY_3, 0);</a>
<a name="ln183">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;rate 4&quot;), GDK_KEY_4, 0);</a>
<a name="ln184">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;rate 5&quot;), GDK_KEY_5, 0);</a>
<a name="ln185">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;rate reject&quot;), GDK_KEY_r, 0);</a>
<a name="ln186"> </a>
<a name="ln187">  /* setup history key accelerators */</a>
<a name="ln188">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;copy history&quot;), GDK_KEY_c, GDK_CONTROL_MASK);</a>
<a name="ln189">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;copy history parts&quot;), GDK_KEY_c,</a>
<a name="ln190">                        GDK_CONTROL_MASK | GDK_SHIFT_MASK);</a>
<a name="ln191">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;paste history&quot;), GDK_KEY_v, GDK_CONTROL_MASK);</a>
<a name="ln192">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;paste history parts&quot;), GDK_KEY_v,</a>
<a name="ln193">                        GDK_CONTROL_MASK | GDK_SHIFT_MASK);</a>
<a name="ln194">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;discard history&quot;), 0, 0);</a>
<a name="ln195"> </a>
<a name="ln196">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;duplicate image&quot;), GDK_KEY_d, GDK_CONTROL_MASK);</a>
<a name="ln197"> </a>
<a name="ln198">  /* setup color label accelerators */</a>
<a name="ln199">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;color red&quot;), GDK_KEY_F1, 0);</a>
<a name="ln200">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;color yellow&quot;), GDK_KEY_F2, 0);</a>
<a name="ln201">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;color green&quot;), GDK_KEY_F3, 0);</a>
<a name="ln202">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;color blue&quot;), GDK_KEY_F4, 0);</a>
<a name="ln203">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;color purple&quot;), GDK_KEY_F5, 0);</a>
<a name="ln204"> </a>
<a name="ln205">  /* setup selection accelerators */</a>
<a name="ln206">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;select all&quot;), GDK_KEY_a, GDK_CONTROL_MASK);</a>
<a name="ln207">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;select none&quot;), GDK_KEY_a, GDK_CONTROL_MASK | GDK_SHIFT_MASK);</a>
<a name="ln208">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;invert selection&quot;), GDK_KEY_i, GDK_CONTROL_MASK);</a>
<a name="ln209">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;select film roll&quot;), 0, 0);</a>
<a name="ln210">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;select untouched&quot;), 0, 0);</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln214">{</a>
<a name="ln215"> </a>
<a name="ln216">  // Rating accels</a>
<a name="ln217">  dt_accel_connect_lib(self, &quot;rate 0&quot;, g_cclosure_new(G_CALLBACK(_lib_filmstrip_ratings_key_accel_callback),</a>
<a name="ln218">                                                      GINT_TO_POINTER(DT_VIEW_DESERT), NULL));</a>
<a name="ln219">  dt_accel_connect_lib(self, &quot;rate 1&quot;, g_cclosure_new(G_CALLBACK(_lib_filmstrip_ratings_key_accel_callback),</a>
<a name="ln220">                                                      GINT_TO_POINTER(DT_VIEW_STAR_1), NULL));</a>
<a name="ln221">  dt_accel_connect_lib(self, &quot;rate 2&quot;, g_cclosure_new(G_CALLBACK(_lib_filmstrip_ratings_key_accel_callback),</a>
<a name="ln222">                                                      GINT_TO_POINTER(DT_VIEW_STAR_2), NULL));</a>
<a name="ln223">  dt_accel_connect_lib(self, &quot;rate 3&quot;, g_cclosure_new(G_CALLBACK(_lib_filmstrip_ratings_key_accel_callback),</a>
<a name="ln224">                                                      GINT_TO_POINTER(DT_VIEW_STAR_3), NULL));</a>
<a name="ln225">  dt_accel_connect_lib(self, &quot;rate 4&quot;, g_cclosure_new(G_CALLBACK(_lib_filmstrip_ratings_key_accel_callback),</a>
<a name="ln226">                                                      GINT_TO_POINTER(DT_VIEW_STAR_4), NULL));</a>
<a name="ln227">  dt_accel_connect_lib(self, &quot;rate 5&quot;, g_cclosure_new(G_CALLBACK(_lib_filmstrip_ratings_key_accel_callback),</a>
<a name="ln228">                                                      GINT_TO_POINTER(DT_VIEW_STAR_5), NULL));</a>
<a name="ln229">  dt_accel_connect_lib(self, &quot;rate reject&quot;,</a>
<a name="ln230">                       g_cclosure_new(G_CALLBACK(_lib_filmstrip_ratings_key_accel_callback),</a>
<a name="ln231">                                      GINT_TO_POINTER(DT_VIEW_REJECT), NULL));</a>
<a name="ln232"> </a>
<a name="ln233">  // History key accels</a>
<a name="ln234">  dt_accel_connect_lib(</a>
<a name="ln235">      self, &quot;copy history&quot;,</a>
<a name="ln236">      g_cclosure_new(G_CALLBACK(_lib_filmstrip_copy_history_key_accel_callback), (gpointer)self-&gt;data, NULL));</a>
<a name="ln237">  dt_accel_connect_lib(self, &quot;copy history parts&quot;,</a>
<a name="ln238">                       g_cclosure_new(G_CALLBACK(_lib_filmstrip_copy_history_parts_key_accel_callback),</a>
<a name="ln239">                                      (gpointer)self-&gt;data, NULL));</a>
<a name="ln240">  dt_accel_connect_lib(self, &quot;paste history&quot;,</a>
<a name="ln241">                       g_cclosure_new(G_CALLBACK(_lib_filmstrip_paste_history_key_accel_callback),</a>
<a name="ln242">                                      (gpointer)self-&gt;data, NULL));</a>
<a name="ln243">  dt_accel_connect_lib(self, &quot;paste history parts&quot;,</a>
<a name="ln244">                       g_cclosure_new(G_CALLBACK(_lib_filmstrip_paste_history_parts_key_accel_callback),</a>
<a name="ln245">                                      (gpointer)self-&gt;data, NULL));</a>
<a name="ln246">  dt_accel_connect_lib(self, &quot;discard history&quot;,</a>
<a name="ln247">                       g_cclosure_new(G_CALLBACK(_lib_filmstrip_discard_history_key_accel_callback),</a>
<a name="ln248">                                      (gpointer)self-&gt;data, NULL));</a>
<a name="ln249"> </a>
<a name="ln250">  dt_accel_connect_lib(self, &quot;duplicate image&quot;,</a>
<a name="ln251">                       g_cclosure_new(G_CALLBACK(_lib_filmstrip_duplicate_image_key_accel_callback),</a>
<a name="ln252">                                      (gpointer)self-&gt;data, NULL));</a>
<a name="ln253"> </a>
<a name="ln254">  // Color label accels</a>
<a name="ln255">  dt_accel_connect_lib(</a>
<a name="ln256">      self, &quot;color red&quot;,</a>
<a name="ln257">      g_cclosure_new(G_CALLBACK(_lib_filmstrip_colorlabels_key_accel_callback), GINT_TO_POINTER(0), NULL));</a>
<a name="ln258">  dt_accel_connect_lib(</a>
<a name="ln259">      self, &quot;color yellow&quot;,</a>
<a name="ln260">      g_cclosure_new(G_CALLBACK(_lib_filmstrip_colorlabels_key_accel_callback), GINT_TO_POINTER(1), NULL));</a>
<a name="ln261">  dt_accel_connect_lib(</a>
<a name="ln262">      self, &quot;color green&quot;,</a>
<a name="ln263">      g_cclosure_new(G_CALLBACK(_lib_filmstrip_colorlabels_key_accel_callback), GINT_TO_POINTER(2), NULL));</a>
<a name="ln264">  dt_accel_connect_lib(</a>
<a name="ln265">      self, &quot;color blue&quot;,</a>
<a name="ln266">      g_cclosure_new(G_CALLBACK(_lib_filmstrip_colorlabels_key_accel_callback), GINT_TO_POINTER(3), NULL));</a>
<a name="ln267">  dt_accel_connect_lib(</a>
<a name="ln268">      self, &quot;color purple&quot;,</a>
<a name="ln269">      g_cclosure_new(G_CALLBACK(_lib_filmstrip_colorlabels_key_accel_callback), GINT_TO_POINTER(4), NULL));</a>
<a name="ln270"> </a>
<a name="ln271">  // Selection accels</a>
<a name="ln272">  dt_accel_connect_lib(self, &quot;select all&quot;, g_cclosure_new(G_CALLBACK(_lib_filmstrip_select_key_accel_callback),</a>
<a name="ln273">                                                          GINT_TO_POINTER(0), NULL));</a>
<a name="ln274">  dt_accel_connect_lib(</a>
<a name="ln275">      self, &quot;select none&quot;,</a>
<a name="ln276">      g_cclosure_new(G_CALLBACK(_lib_filmstrip_select_key_accel_callback), GINT_TO_POINTER(1), NULL));</a>
<a name="ln277">  dt_accel_connect_lib(</a>
<a name="ln278">      self, &quot;invert selection&quot;,</a>
<a name="ln279">      g_cclosure_new(G_CALLBACK(_lib_filmstrip_select_key_accel_callback), GINT_TO_POINTER(2), NULL));</a>
<a name="ln280">  dt_accel_connect_lib(</a>
<a name="ln281">      self, &quot;select film roll&quot;,</a>
<a name="ln282">      g_cclosure_new(G_CALLBACK(_lib_filmstrip_select_key_accel_callback), GINT_TO_POINTER(3), NULL));</a>
<a name="ln283">  dt_accel_connect_lib(</a>
<a name="ln284">      self, &quot;select untouched&quot;,</a>
<a name="ln285">      g_cclosure_new(G_CALLBACK(_lib_filmstrip_select_key_accel_callback), GINT_TO_POINTER(4), NULL));</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">void gui_init(dt_lib_module_t *self)</a>
<a name="ln289">{</a>
<a name="ln290">  /* initialize ui widgets */</a>
<a name="ln291">  dt_lib_filmstrip_t *d = (dt_lib_filmstrip_t *)calloc(1, sizeof(dt_lib_filmstrip_t));</a>
<a name="ln292">  self-&gt;data = (void *)d;</a>
<a name="ln293"> </a>
<a name="ln294">  d-&gt;last_selected_id = -1;</a>
<a name="ln295">  d-&gt;history_copy_imgid = -1;</a>
<a name="ln296">  d-&gt;activated_image = -1;</a>
<a name="ln297">  d-&gt;mouse_over_id = -1;</a>
<a name="ln298">  d-&gt;pointerx = -1;</a>
<a name="ln299">  d-&gt;pointery = -1;</a>
<a name="ln300">  d-&gt;thumb_size = -1;</a>
<a name="ln301">  d-&gt;last_mouse_over_thumb = -1;</a>
<a name="ln302">  d-&gt;last_exposed_id = -1;</a>
<a name="ln303">  d-&gt;force_expose_all = FALSE;</a>
<a name="ln304">  d-&gt;offset_x = 0;</a>
<a name="ln305">  d-&gt;surface = NULL;</a>
<a name="ln306">  d-&gt;panel_width = -1;</a>
<a name="ln307">  d-&gt;thumbs_table = g_hash_table_new(g_int_hash, g_int_equal);</a>
<a name="ln308">  dt_gui_hist_dialog_init(&amp;d-&gt;dg);</a>
<a name="ln309"> </a>
<a name="ln310">  /* creating drawing area */</a>
<a name="ln311">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln312"> </a>
<a name="ln313">  /* creating filmstrip box*/</a>
<a name="ln314">  d-&gt;filmstrip = gtk_event_box_new();</a>
<a name="ln315"> </a>
<a name="ln316">  /* allow drag&amp;drop of images from the filmstrip. this has to come before the other callbacks are registered!</a>
<a name="ln317">   */</a>
<a name="ln318">  gtk_drag_source_set(d-&gt;filmstrip, GDK_BUTTON1_MASK, target_list_all, n_targets_all, GDK_ACTION_COPY);</a>
<a name="ln319">#ifdef HAVE_MAP</a>
<a name="ln320">  gtk_drag_dest_set(d-&gt;filmstrip, GTK_DEST_DEFAULT_ALL, target_list_internal, n_targets_internal,</a>
<a name="ln321">                    GDK_ACTION_COPY);</a>
<a name="ln322">#endif</a>
<a name="ln323"> </a>
<a name="ln324">  g_signal_connect_after(d-&gt;filmstrip, &quot;drag-begin&quot;, G_CALLBACK(_lib_filmstrip_dnd_begin_callback), self);</a>
<a name="ln325">  g_signal_connect(d-&gt;filmstrip, &quot;drag-data-get&quot;, G_CALLBACK(_lib_filmstrip_dnd_get_callback), self);</a>
<a name="ln326"> </a>
<a name="ln327">  gtk_widget_add_events(d-&gt;filmstrip, GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln328">                                      | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln329">                                      | darktable.gui-&gt;scroll_mask</a>
<a name="ln330">                                      | GDK_LEAVE_NOTIFY_MASK);</a>
<a name="ln331"> </a>
<a name="ln332">  /* connect callbacks */</a>
<a name="ln333">  g_signal_connect(G_OBJECT(d-&gt;filmstrip), &quot;draw&quot;, G_CALLBACK(_lib_filmstrip_draw_callback), self);</a>
<a name="ln334">  g_signal_connect(G_OBJECT(d-&gt;filmstrip), &quot;button-press-event&quot;,</a>
<a name="ln335">                   G_CALLBACK(_lib_filmstrip_button_press_callback), self);</a>
<a name="ln336">  g_signal_connect(G_OBJECT(d-&gt;filmstrip), &quot;button-release-event&quot;,</a>
<a name="ln337">                   G_CALLBACK(_lib_filmstrip_button_release_callback), self);</a>
<a name="ln338">  g_signal_connect(G_OBJECT(d-&gt;filmstrip), &quot;scroll-event&quot;, G_CALLBACK(_lib_filmstrip_scroll_callback), self);</a>
<a name="ln339">  g_signal_connect(G_OBJECT(d-&gt;filmstrip), &quot;motion-notify-event&quot;,</a>
<a name="ln340">                   G_CALLBACK(_lib_filmstrip_motion_notify_callback), self);</a>
<a name="ln341">  g_signal_connect(G_OBJECT(d-&gt;filmstrip), &quot;leave-notify-event&quot;,</a>
<a name="ln342">                   G_CALLBACK(_lib_filmstrip_mouse_leave_callback), self);</a>
<a name="ln343"> </a>
<a name="ln344">  /* set size of filmstrip */</a>
<a name="ln345">  int32_t height = dt_conf_get_int(&quot;plugins/lighttable/filmstrip/height&quot;);</a>
<a name="ln346">  gtk_widget_set_size_request(d-&gt;filmstrip, -1,</a>
<a name="ln347">                              CLAMP(height, DT_PIXEL_APPLY_DPI(64), DT_PIXEL_APPLY_DPI(400)));</a>
<a name="ln348"> </a>
<a name="ln349">  /* create the resize handle */</a>
<a name="ln350">  GtkWidget *size_handle = gtk_event_box_new();</a>
<a name="ln351">  gtk_widget_set_size_request(size_handle, -1, DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln352">  gtk_widget_add_events(size_handle, GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln353">                                     | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_ENTER_NOTIFY_MASK</a>
<a name="ln354">                                     | GDK_LEAVE_NOTIFY_MASK);</a>
<a name="ln355">  g_signal_connect(G_OBJECT(size_handle), &quot;button-press-event&quot;,</a>
<a name="ln356">                   G_CALLBACK(_lib_filmstrip_size_handle_button_callback), self);</a>
<a name="ln357">  g_signal_connect(G_OBJECT(size_handle), &quot;button-release-event&quot;,</a>
<a name="ln358">                   G_CALLBACK(_lib_filmstrip_size_handle_button_callback), self);</a>
<a name="ln359">  g_signal_connect(G_OBJECT(size_handle), &quot;motion-notify-event&quot;,</a>
<a name="ln360">                   G_CALLBACK(_lib_filmstrip_size_handle_motion_notify_callback), self);</a>
<a name="ln361">  g_signal_connect(G_OBJECT(size_handle), &quot;leave-notify-event&quot;,</a>
<a name="ln362">                   G_CALLBACK(_lib_filmstrip_size_handle_cursor_callback), self);</a>
<a name="ln363">  g_signal_connect(G_OBJECT(size_handle), &quot;enter-notify-event&quot;,</a>
<a name="ln364">                   G_CALLBACK(_lib_filmstrip_size_handle_cursor_callback), self);</a>
<a name="ln365"> </a>
<a name="ln366">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), size_handle, FALSE, FALSE, 0);</a>
<a name="ln367">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), d-&gt;filmstrip, FALSE, FALSE, 0);</a>
<a name="ln368"> </a>
<a name="ln369">  /* initialize view manager proxy */</a>
<a name="ln370">  darktable.view_manager-&gt;proxy.filmstrip.module = self;</a>
<a name="ln371">  darktable.view_manager-&gt;proxy.filmstrip.scroll_to_image = _lib_filmstrip_scroll_to_image;</a>
<a name="ln372">  darktable.view_manager-&gt;proxy.filmstrip.activated_image = _lib_filmstrip_get_activated_imgid;</a>
<a name="ln373">  darktable.view_manager-&gt;proxy.filmstrip.widget = _lib_filmstrip_get_widget;</a>
<a name="ln374"> </a>
<a name="ln375">  /* connect signal handler */</a>
<a name="ln376">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED,</a>
<a name="ln377">                            G_CALLBACK(_lib_filmstrip_collection_changed_callback), (gpointer)self);</a>
<a name="ln378">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_MIPMAP_UPDATED,</a>
<a name="ln379">                            G_CALLBACK(_lib_filmstrip_collection_changed_callback), (gpointer)self);</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln383">{</a>
<a name="ln384">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln385"> </a>
<a name="ln386">  /* disconnect from signals */</a>
<a name="ln387">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_filmstrip_collection_changed_callback),</a>
<a name="ln388">                               (gpointer)self);</a>
<a name="ln389"> </a>
<a name="ln390">  /* unset viewmanager proxy */</a>
<a name="ln391">  darktable.view_manager-&gt;proxy.filmstrip.module = NULL;</a>
<a name="ln392"> </a>
<a name="ln393">  g_hash_table_destroy(strip-&gt;thumbs_table);</a>
<a name="ln394"> </a>
<a name="ln395">  /* cleanup */</a>
<a name="ln396">  free(self-&gt;data);</a>
<a name="ln397">  self-&gt;data = NULL;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400"> </a>
<a name="ln401">static gboolean _lib_filmstrip_mouse_leave_callback(GtkWidget *w, GdkEventCrossing *e, gpointer user_data)</a>
<a name="ln402">{</a>
<a name="ln403">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln404">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln405"> </a>
<a name="ln406">  dt_control_set_mouse_over_id(strip-&gt;activated_image);</a>
<a name="ln407"> </a>
<a name="ln408">  /* suppress mouse over highlight upon leave */</a>
<a name="ln409">  strip-&gt;pointery = -1;</a>
<a name="ln410">  gtk_widget_queue_draw(strip-&gt;filmstrip);</a>
<a name="ln411"> </a>
<a name="ln412">  return TRUE;</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">static inline gboolean _is_on_lighttable()</a>
<a name="ln416">{</a>
<a name="ln417">  // on lighttable, does nothing and report that it has not been handled</a>
<a name="ln418">  const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln419">  return cv-&gt;view((dt_view_t *)cv) == DT_VIEW_LIGHTTABLE;</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">static gboolean _lib_filmstrip_size_handle_cursor_callback(GtkWidget *w, GdkEventCrossing *e,</a>
<a name="ln423">                                                           gpointer user_data)</a>
<a name="ln424">{</a>
<a name="ln425">  dt_control_change_cursor((e-&gt;type == GDK_ENTER_NOTIFY) ? GDK_SB_V_DOUBLE_ARROW : GDK_LEFT_PTR);</a>
<a name="ln426">  return TRUE;</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">static gboolean _lib_filmstrip_size_handle_button_callback(GtkWidget *w, GdkEventButton *e, gpointer user_data)</a>
<a name="ln430">{</a>
<a name="ln431">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln432">  dt_lib_filmstrip_t *d = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln433"> </a>
<a name="ln434">  if(e-&gt;button == 1)</a>
<a name="ln435">  {</a>
<a name="ln436">    if(e-&gt;type == GDK_BUTTON_PRESS)</a>
<a name="ln437">    {</a>
<a name="ln438">      /* store current  mousepointer position */</a>
<a name="ln439">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln440">      gdk_window_get_device_position(e-&gt;window,</a>
<a name="ln441">                                     gdk_seat_get_pointer(gdk_display_get_default_seat(gdk_window_get_display(</a>
<a name="ln442">                                         gtk_widget_get_window(dt_ui_main_window(darktable.gui-&gt;ui))))),</a>
<a name="ln443">                                     &amp;d-&gt;size_handle_x, &amp;d-&gt;size_handle_y, 0);</a>
<a name="ln444">#else</a>
<a name="ln445">      gdk_window_get_device_position(</a>
<a name="ln446">          gtk_widget_get_window(dt_ui_main_window(darktable.gui-&gt;ui)),</a>
<a name="ln447">          gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(</a>
<a name="ln448">              gdk_window_get_display(gtk_widget_get_window(dt_ui_main_window(darktable.gui-&gt;ui))))),</a>
<a name="ln449">          &amp;d-&gt;size_handle_x, &amp;d-&gt;size_handle_y, NULL);</a>
<a name="ln450">#endif</a>
<a name="ln451"> </a>
<a name="ln452">      gtk_widget_get_size_request(d-&gt;filmstrip, NULL, &amp;d-&gt;size_handle_height);</a>
<a name="ln453">      d-&gt;size_handle_is_dragging = TRUE;</a>
<a name="ln454">      cairo_surface_destroy(d-&gt;surface);</a>
<a name="ln455">      d-&gt;surface = NULL;</a>
<a name="ln456">    }</a>
<a name="ln457">    else if(e-&gt;type == GDK_BUTTON_RELEASE)</a>
<a name="ln458">      d-&gt;size_handle_is_dragging = FALSE;</a>
<a name="ln459">  }</a>
<a name="ln460">  return TRUE;</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463">static gboolean _lib_filmstrip_size_handle_motion_notify_callback(GtkWidget *w, GdkEventButton *e,</a>
<a name="ln464">                                                                  gpointer user_data)</a>
<a name="ln465">{</a>
<a name="ln466">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln467">  dt_lib_filmstrip_t *d = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln468">  if(d-&gt;size_handle_is_dragging)</a>
<a name="ln469">  {</a>
<a name="ln470">    gint x, y, sx, sy;</a>
<a name="ln471">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln472">    gdk_window_get_device_position(e-&gt;window,</a>
<a name="ln473">        gdk_seat_get_pointer(gdk_display_get_default_seat(</a>
<a name="ln474">            gdk_window_get_display(gtk_widget_get_window(dt_ui_main_window(darktable.gui-&gt;ui))))),</a>
<a name="ln475">        &amp;x, &amp;y, 0);</a>
<a name="ln476">#else</a>
<a name="ln477">    gdk_window_get_device_position(</a>
<a name="ln478">        gtk_widget_get_window(dt_ui_main_window(darktable.gui-&gt;ui)),</a>
<a name="ln479">        gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(</a>
<a name="ln480">            gdk_window_get_display(gtk_widget_get_window(dt_ui_main_window(darktable.gui-&gt;ui))))),</a>
<a name="ln481">        &amp;x, &amp;y, NULL);</a>
<a name="ln482">#endif</a>
<a name="ln483"> </a>
<a name="ln484">    gtk_widget_get_size_request(d-&gt;filmstrip, &amp;sx, &amp;sy);</a>
<a name="ln485">    sy = CLAMP(d-&gt;size_handle_height + (d-&gt;size_handle_y - y), DT_PIXEL_APPLY_DPI(64),</a>
<a name="ln486">               DT_PIXEL_APPLY_DPI(400));</a>
<a name="ln487"> </a>
<a name="ln488">    dt_conf_set_int(&quot;plugins/lighttable/filmstrip/height&quot;, sy);</a>
<a name="ln489"> </a>
<a name="ln490">    cairo_surface_destroy(d-&gt;surface);</a>
<a name="ln491">    d-&gt;surface = NULL;</a>
<a name="ln492">    gtk_widget_set_size_request(d-&gt;filmstrip, -1, sy);</a>
<a name="ln493"> </a>
<a name="ln494">    return TRUE;</a>
<a name="ln495">  }</a>
<a name="ln496"> </a>
<a name="ln497">  return FALSE;</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500">static gboolean _lib_filmstrip_motion_notify_callback(GtkWidget *w, GdkEventMotion *e, gpointer user_data)</a>
<a name="ln501">{</a>
<a name="ln502">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln503">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln504"> </a>
<a name="ln505">  // no redraw by default</a>
<a name="ln506">  gboolean do_redraw = FALSE;</a>
<a name="ln507"> </a>
<a name="ln508">  strip-&gt;pointerx = e-&gt;x;</a>
<a name="ln509">  strip-&gt;pointery = e-&gt;y;</a>
<a name="ln510"> </a>
<a name="ln511">  if(strip-&gt;thumb_size == -1)</a>
<a name="ln512">  {</a>
<a name="ln513">    do_redraw = TRUE;</a>
<a name="ln514">  }</a>
<a name="ln515">  else</a>
<a name="ln516">  {</a>
<a name="ln517">    // compute the actual thumb number, this is not at all the thumb id, but a count of the thumb starting from the</a>
<a name="ln518">    // left and continuing to the right. this goal is to filter out as much as possible the redraw event. when we</a>
<a name="ln519">    // stay on the same thumb we do not redraw, there is nothing to do. the exception is a small border around the</a>
<a name="ln520">    // thumb to ensure the stars, reject tag and the dev history sensitive area are reacting.</a>
<a name="ln521">    const double px = e-&gt;x - strip-&gt;offset_x;</a>
<a name="ln522">    const double py = e-&gt;y;</a>
<a name="ln523">    const int mouse_over_thumb = (int)(1.0 + px / strip-&gt;thumb_size);</a>
<a name="ln524">    const float x_offset = fmodf(px, strip-&gt;thumb_size);</a>
<a name="ln525">    const float y_offset = fmodf(py, strip-&gt;thumb_size);</a>
<a name="ln526">    const float end_pos = (strip-&gt;thumb_size * 85) / 100;</a>
<a name="ln527">    const float start_pos = (strip-&gt;thumb_size * 10) / 100;</a>
<a name="ln528"> </a>
<a name="ln529">    if (strip-&gt;last_mouse_over_thumb == -1 || strip-&gt;last_mouse_over_thumb != mouse_over_thumb</a>
<a name="ln530">        || (y_offset &gt; end_pos || y_offset &lt; start_pos)</a>
<a name="ln531">        || (x_offset &gt; end_pos || x_offset &lt; start_pos))</a>
<a name="ln532">    {</a>
<a name="ln533">      strip-&gt;last_mouse_over_thumb = mouse_over_thumb;</a>
<a name="ln534">      do_redraw = TRUE;</a>
<a name="ln535">    }</a>
<a name="ln536">  }</a>
<a name="ln537"> </a>
<a name="ln538">  /* redraw */</a>
<a name="ln539">  if(do_redraw) gtk_widget_queue_draw(strip-&gt;filmstrip);</a>
<a name="ln540">  return TRUE;</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543">static gboolean _lib_filmstrip_scroll_callback(GtkWidget *w, GdkEventScroll *e, gpointer user_data)</a>
<a name="ln544">{</a>
<a name="ln545">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln546">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln547"> </a>
<a name="ln548">  /* change the offset */</a>
<a name="ln549">  int delta_x, delta_y;</a>
<a name="ln550">  if(dt_gui_get_scroll_unit_deltas(e, &amp;delta_x, &amp;delta_y))</a>
<a name="ln551">  {</a>
<a name="ln552">    strip-&gt;offset = CLAMP(strip-&gt;offset + delta_x + delta_y, 0, strip-&gt;collection_count-1);</a>
<a name="ln553">    strip-&gt;force_expose_all = TRUE;</a>
<a name="ln554">    gtk_widget_queue_draw(strip-&gt;filmstrip);</a>
<a name="ln555">  }</a>
<a name="ln556"> </a>
<a name="ln557">  return TRUE;</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">static gboolean _lib_filmstrip_imgid_in_collection(const dt_collection_t *collection, const int imgid)</a>
<a name="ln561">{</a>
<a name="ln562">  sqlite3_stmt *stmt;</a>
<a name="ln563">  gboolean image_in_collection = TRUE;</a>
<a name="ln564">  const char *query = dt_collection_get_query(collection);</a>
<a name="ln565"> </a>
<a name="ln566">  char *count_query = g_strdup_printf(&quot;SELECT count(id) FROM (%s) WHERE id = ?3&quot;, query);</a>
<a name="ln567"> </a>
<a name="ln568">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), count_query, -1, &amp;stmt, NULL);</a>
<a name="ln569">  if((collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_LIMIT)</a>
<a name="ln570">     &amp;&amp; !(collection-&gt;params.query_flags &amp; COLLECTION_QUERY_USE_ONLY_WHERE_EXT))</a>
<a name="ln571">  {</a>
<a name="ln572">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, 0);</a>
<a name="ln573">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, -1);</a>
<a name="ln574">  }</a>
<a name="ln575">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, imgid);</a>
<a name="ln576"> </a>
<a name="ln577">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln578">    image_in_collection = (sqlite3_column_int(stmt, 0) &gt; 0);</a>
<a name="ln579">  sqlite3_finalize(stmt);</a>
<a name="ln580">  g_free(count_query);</a>
<a name="ln581">  return image_in_collection;</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">static gboolean _lib_filmstrip_button_press_callback(GtkWidget *w, GdkEventButton *e, gpointer user_data)</a>
<a name="ln585">{</a>
<a name="ln586">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln587">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln588"> </a>
<a name="ln589">  const int32_t mouse_over_id = strip-&gt;mouse_over_id;</a>
<a name="ln590">  strip-&gt;select = DT_LIB_FILMSTRIP_SELECT_NONE;</a>
<a name="ln591"> </a>
<a name="ln592">  if(e-&gt;button == 1)</a>
<a name="ln593">  {</a>
<a name="ln594">    if(e-&gt;type == GDK_BUTTON_PRESS)</a>
<a name="ln595">    {</a>
<a name="ln596">      /* let check if any thumb controls was clicked */</a>
<a name="ln597">      switch(strip-&gt;image_over)</a>
<a name="ln598">      {</a>
<a name="ln599">        case DT_VIEW_DESERT:</a>
<a name="ln600">          /* is this an activation of image */</a>
<a name="ln601">          if((e-&gt;state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK)) == 0)</a>
<a name="ln602">            strip-&gt;select = DT_LIB_FILMSTRIP_SELECT_SINGLE;</a>
<a name="ln603">          else if((e-&gt;state &amp; (GDK_CONTROL_MASK)) == GDK_CONTROL_MASK)</a>
<a name="ln604">            strip-&gt;select = DT_LIB_FILMSTRIP_SELECT_TOGGLE;</a>
<a name="ln605">          else if((e-&gt;state &amp; (GDK_SHIFT_MASK)) == GDK_SHIFT_MASK)</a>
<a name="ln606">            strip-&gt;select = DT_LIB_FILMSTRIP_SELECT_RANGE;</a>
<a name="ln607">          if(strip-&gt;select != DT_LIB_FILMSTRIP_SELECT_NONE)</a>
<a name="ln608">          {</a>
<a name="ln609">            strip-&gt;select_id = mouse_over_id;</a>
<a name="ln610">            return TRUE;</a>
<a name="ln611">          }</a>
<a name="ln612">          break;</a>
<a name="ln613">        case DT_VIEW_REJECT:</a>
<a name="ln614">        case DT_VIEW_STAR_1:</a>
<a name="ln615">        case DT_VIEW_STAR_2:</a>
<a name="ln616">        case DT_VIEW_STAR_3:</a>
<a name="ln617">        case DT_VIEW_STAR_4:</a>
<a name="ln618">        case DT_VIEW_STAR_5:</a>
<a name="ln619">        {</a>
<a name="ln620">          int offset = 0;</a>
<a name="ln621">          if(mouse_over_id == strip-&gt;activated_image) offset = dt_collection_image_offset(mouse_over_id);</a>
<a name="ln622"> </a>
<a name="ln623">          dt_ratings_apply_to_image_or_group(mouse_over_id, strip-&gt;image_over);</a>
<a name="ln624"> </a>
<a name="ln625">          if(mouse_over_id == strip-&gt;activated_image)</a>
<a name="ln626">            if(_lib_filmstrip_imgid_in_collection(darktable.collection, mouse_over_id) == 0)</a>
<a name="ln627">              dt_view_filmstrip_scroll_relative(0, offset);</a>
<a name="ln628"> </a>
<a name="ln629">          //  gtk_widget_queue_draw(darktable.view_manager-&gt;proxy.filmstrip.module-&gt;widget);</a>
<a name="ln630">          gtk_widget_queue_draw(strip-&gt;filmstrip);</a>
<a name="ln631">          return TRUE;</a>
<a name="ln632">        }</a>
<a name="ln633"> </a>
<a name="ln634">        default:</a>
<a name="ln635">          return FALSE;</a>
<a name="ln636">      }</a>
<a name="ln637">    }</a>
<a name="ln638">    else if(e-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln639">    {</a>
<a name="ln640">      if(mouse_over_id &gt; 0)</a>
<a name="ln641">      {</a>
<a name="ln642">        strip-&gt;activated_image = mouse_over_id;</a>
<a name="ln643">        dt_control_signal_raise(darktable.signals, DT_SIGNAL_VIEWMANAGER_FILMSTRIP_ACTIVATE);</a>
<a name="ln644">        return TRUE;</a>
<a name="ln645">      }</a>
<a name="ln646">    }</a>
<a name="ln647">  }</a>
<a name="ln648"> </a>
<a name="ln649">  return FALSE;</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">static gboolean _lib_filmstrip_button_release_callback(GtkWidget *w, GdkEventButton *e, gpointer user_data)</a>
<a name="ln653">{</a>
<a name="ln654">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln655">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln656"> </a>
<a name="ln657">  const int32_t mouse_over_id = strip-&gt;mouse_over_id;</a>
<a name="ln658">  const int32_t select_id = strip-&gt;select_id;</a>
<a name="ln659">  gboolean result = FALSE;</a>
<a name="ln660">  strip-&gt;force_expose_all = TRUE;</a>
<a name="ln661"> </a>
<a name="ln662">  if(mouse_over_id == select_id &amp;&amp; mouse_over_id &gt; 0)</a>
<a name="ln663">  {</a>
<a name="ln664">    result = TRUE;</a>
<a name="ln665">    if(strip-&gt;select == DT_LIB_FILMSTRIP_SELECT_SINGLE)</a>
<a name="ln666">      dt_selection_select_single(darktable.selection, mouse_over_id);</a>
<a name="ln667">    else if(strip-&gt;select == DT_LIB_FILMSTRIP_SELECT_TOGGLE)</a>
<a name="ln668">      dt_selection_toggle(darktable.selection, mouse_over_id);</a>
<a name="ln669">    else if(strip-&gt;select == DT_LIB_FILMSTRIP_SELECT_RANGE)</a>
<a name="ln670">      dt_selection_select_range(darktable.selection, mouse_over_id);</a>
<a name="ln671">    else</a>
<a name="ln672">      result = FALSE;</a>
<a name="ln673">  }</a>
<a name="ln674"> </a>
<a name="ln675">  strip-&gt;select = DT_LIB_FILMSTRIP_SELECT_NONE;</a>
<a name="ln676">  strip-&gt;select_id = -1;</a>
<a name="ln677"> </a>
<a name="ln678">  /* redraw filmstrip */</a>
<a name="ln679">  gtk_widget_queue_draw(strip-&gt;filmstrip);</a>
<a name="ln680">  return result;</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">static gboolean _expose_again(gpointer user_data)</a>
<a name="ln684">{</a>
<a name="ln685">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln686">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln687">  // unfortunately there might have been images without thumbnails during expose.</a>
<a name="ln688">  // this can have multiple reasons: not loaded yet (we'll receive a signal when done)</a>
<a name="ln689">  // or still locked for writing.. we won't be notified when this changes.</a>
<a name="ln690">  // so we just track whether there were missing images and expose again.</a>
<a name="ln691">  if(darktable.view_manager-&gt;proxy.filmstrip.module)</a>
<a name="ln692">  {</a>
<a name="ln693">    gtk_widget_queue_draw(strip-&gt;filmstrip);</a>
<a name="ln694">  }</a>
<a name="ln695">  return FALSE; // don't call again</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">static gboolean _lib_filmstrip_draw_callback(GtkWidget *widget, cairo_t *wcr, gpointer user_data)</a>
<a name="ln699">{</a>
<a name="ln700">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln701">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln702"> </a>
<a name="ln703">  GtkAllocation allocation;</a>
<a name="ln704">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln705">  const int32_t width = allocation.width;</a>
<a name="ln706">  const int32_t height = allocation.height;</a>
<a name="ln707"> </a>
<a name="ln708">  // windows could have been expanded for example, we need to create a new surface of the good size and redraw</a>
<a name="ln709">  if(strip-&gt;surface &amp;&amp; width != strip-&gt;panel_width)</a>
<a name="ln710">  {</a>
<a name="ln711">    cairo_surface_destroy(strip-&gt;surface);</a>
<a name="ln712">    strip-&gt;surface = NULL;</a>
<a name="ln713">  }</a>
<a name="ln714"> </a>
<a name="ln715">  // create the persistent surface if it does not exists, this surface will be invalidated each time</a>
<a name="ln716">  // a resize of the filmstrip is done.</a>
<a name="ln717">  if(!strip-&gt;surface)</a>
<a name="ln718">  {</a>
<a name="ln719">    strip-&gt;surface</a>
<a name="ln720">      = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, allocation.width, allocation.height);</a>
<a name="ln721">    strip-&gt;force_expose_all = TRUE;</a>
<a name="ln722">    strip-&gt;panel_width = width;</a>
<a name="ln723">  }</a>
<a name="ln724"> </a>
<a name="ln725">  // get cairo drawing handle</a>
<a name="ln726">  cairo_t *cr = cairo_create(strip-&gt;surface);</a>
<a name="ln727"> </a>
<a name="ln728">  if(darktable.gui-&gt;center_tooltip == 1) darktable.gui-&gt;center_tooltip++;</a>
<a name="ln729"> </a>
<a name="ln730">  int mouse_over_id = -1;</a>
<a name="ln731">  strip-&gt;image_over = DT_VIEW_DESERT;</a>
<a name="ln732"> </a>
<a name="ln733">  /* fill background */</a>
<a name="ln734">  if (strip-&gt;mouse_over_id == -1 || strip-&gt;force_expose_all)</a>
<a name="ln735">  {</a>
<a name="ln736">    strip-&gt;force_expose_all = TRUE;</a>
<a name="ln737">    strip-&gt;last_exposed_id = -1;</a>
<a name="ln738">    dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_FILMSTRIP_BG);</a>
<a name="ln739">    cairo_paint(cr);</a>
<a name="ln740">  }</a>
<a name="ln741"> </a>
<a name="ln742">  int offset = strip-&gt;offset;</a>
<a name="ln743"> </a>
<a name="ln744">  const float wd = height;</a>
<a name="ln745">  const float ht = height;</a>
<a name="ln746">  strip-&gt;thumb_size = wd;</a>
<a name="ln747"> </a>
<a name="ln748">  int max_cols = (int)(width / (float)wd) + 2;</a>
<a name="ln749">  if(max_cols % 2 == 0) max_cols += 1;</a>
<a name="ln750"> </a>
<a name="ln751">  const int col_start = max_cols / 2 - offset;</a>
<a name="ln752">  const float empty_edge = (width - (max_cols * wd)) / 2.0;</a>
<a name="ln753">  strip-&gt;offset_x = empty_edge;</a>
<a name="ln754">  int step_res = SQLITE_ROW;</a>
<a name="ln755"> </a>
<a name="ln756">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln757"> </a>
<a name="ln758">  /* mouse over image position in filmstrip */</a>
<a name="ln759">  const gdouble pointerx = strip-&gt;pointerx - empty_edge;</a>
<a name="ln760">  const gdouble pointery = strip-&gt;pointery;</a>
<a name="ln761">  const int seli = (pointery &gt; 0 &amp;&amp; pointery &lt;= ht) ? pointerx / (float)wd : -1;</a>
<a name="ln762">  const int img_pointerx = (int)fmodf(pointerx, wd);</a>
<a name="ln763">  const int img_pointery = (int)pointery;</a>
<a name="ln764"> </a>
<a name="ln765">  const dt_collection_sort_t current_sort = dt_collection_get_sort_field(darktable.collection);</a>
<a name="ln766">  const gboolean reverse = dt_collection_get_sort_descending(darktable.collection);</a>
<a name="ln767"> </a>
<a name="ln768">  // we disable the shuffle sort on the filmstrip as this cannot be work with the current implementation. On each redraw</a>
<a name="ln769">  // we get a new order for the collection.</a>
<a name="ln770">  if(current_sort == DT_COLLECTION_SORT_SHUFFLE)</a>
<a name="ln771">  {</a>
<a name="ln772">    dt_collection_set_sort(darktable.collection, DT_COLLECTION_SORT_ID, reverse);</a>
<a name="ln773">    dt_collection_update(darktable.collection);</a>
<a name="ln774">  }</a>
<a name="ln775"> </a>
<a name="ln776">  /* get the count of current collection */</a>
<a name="ln777">  strip-&gt;collection_count = dt_collection_get_count(darktable.collection);</a>
<a name="ln778"> </a>
<a name="ln779">  /* get the collection query */</a>
<a name="ln780">  const gchar *query = dt_collection_get_query(darktable.collection);</a>
<a name="ln781">  if(!query) return FALSE;</a>
<a name="ln782"> </a>
<a name="ln783">  if(offset &lt; 0) strip-&gt;offset = offset = 0;</a>
<a name="ln784">  if(offset &gt; strip-&gt;collection_count - 1) strip-&gt;offset = offset = strip-&gt;collection_count - 1;</a>
<a name="ln785"> </a>
<a name="ln786">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln787">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, offset - max_cols / 2);</a>
<a name="ln788">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, max_cols);</a>
<a name="ln789"> </a>
<a name="ln790">  // reset previous sort</a>
<a name="ln791">  if(current_sort == DT_COLLECTION_SORT_SHUFFLE)</a>
<a name="ln792">  {</a>
<a name="ln793">    dt_collection_set_sort(darktable.collection, current_sort, reverse);</a>
<a name="ln794">    dt_collection_update(darktable.collection);</a>
<a name="ln795">  }</a>
<a name="ln796"> </a>
<a name="ln797">  cairo_save(cr);</a>
<a name="ln798">  cairo_translate(cr, empty_edge, 0.0f);</a>
<a name="ln799">  const int before_last_exposed_id = strip-&gt;last_exposed_id;</a>
<a name="ln800">  const int initial_mouse_over_id = strip-&gt;mouse_over_id;</a>
<a name="ln801">  int missing = 0;</a>
<a name="ln802"> </a>
<a name="ln803">  // invalidate mouse_over_id to ensure the exposed image won't get the over background until set below</a>
<a name="ln804">  // when we reach seli.</a>
<a name="ln805"> </a>
<a name="ln806">  dt_control_set_mouse_over_id(-1);</a>
<a name="ln807"> </a>
<a name="ln808">  for(int col = 0; col &lt; max_cols; col++)</a>
<a name="ln809">  {</a>
<a name="ln810">    if(col &lt; col_start)</a>
<a name="ln811">    {</a>
<a name="ln812">      cairo_translate(cr, wd, 0.0f);</a>
<a name="ln813">      continue;</a>
<a name="ln814">    }</a>
<a name="ln815"> </a>
<a name="ln816">    if(step_res != SQLITE_DONE)</a>
<a name="ln817">    {</a>
<a name="ln818">      step_res = sqlite3_step(stmt);</a>
<a name="ln819">    }</a>
<a name="ln820"> </a>
<a name="ln821">    if(step_res == SQLITE_ROW)</a>
<a name="ln822">    {</a>
<a name="ln823">      const int id = sqlite3_column_int(stmt, 0);</a>
<a name="ln824">      // set mouse over id</a>
<a name="ln825">      if(seli == col)</a>
<a name="ln826">      {</a>
<a name="ln827">        strip-&gt;mouse_over_id = id;</a>
<a name="ln828">        mouse_over_id = id;</a>
<a name="ln829">        dt_control_set_mouse_over_id(mouse_over_id);</a>
<a name="ln830">      }</a>
<a name="ln831">      cairo_save(cr);</a>
<a name="ln832">      // FIXME find out where the y translation is done, how big the value is and use it directly instead of</a>
<a name="ln833">      // getting it from the matrix ...</a>
<a name="ln834">      cairo_matrix_t m;</a>
<a name="ln835">      cairo_get_matrix(cr, &amp;m);</a>
<a name="ln836"> </a>
<a name="ln837">      if (id == strip-&gt;mouse_over_id</a>
<a name="ln838">          || strip-&gt;force_expose_all</a>
<a name="ln839">          || id == before_last_exposed_id</a>
<a name="ln840">          || id == initial_mouse_over_id</a>
<a name="ln841">          || g_hash_table_contains(strip-&gt;thumbs_table, (gpointer)&amp;id))</a>
<a name="ln842">      {</a>
<a name="ln843">        if(!strip-&gt;force_expose_all &amp;&amp; id == mouse_over_id) strip-&gt;last_exposed_id = id;</a>
<a name="ln844"> </a>
<a name="ln845">        dt_view_image_expose_t params = { 0 };</a>
<a name="ln846">        params.image_over = &amp;(strip-&gt;image_over);</a>
<a name="ln847">        params.imgid = id;</a>
<a name="ln848">        params.cr = cr;</a>
<a name="ln849">        params.width = wd;</a>
<a name="ln850">        params.height = ht;</a>
<a name="ln851">        params.px = img_pointerx;</a>
<a name="ln852">        params.py = img_pointery;</a>
<a name="ln853">        params.zoom = max_cols;</a>
<a name="ln854">        const int thumb_missed = dt_view_image_expose(&amp;params);</a>
<a name="ln855"> </a>
<a name="ln856">        // if thumb is missing, record it for expose int next round</a>
<a name="ln857">        if(thumb_missed)</a>
<a name="ln858">          g_hash_table_add(strip-&gt;thumbs_table, (gpointer)&amp;id);</a>
<a name="ln859">        else</a>
<a name="ln860">          g_hash_table_remove(strip-&gt;thumbs_table, (gpointer)&amp;id);</a>
<a name="ln861"> </a>
<a name="ln862">        missing += thumb_missed;</a>
<a name="ln863">      }</a>
<a name="ln864">      cairo_restore(cr);</a>
<a name="ln865">    }</a>
<a name="ln866">    else if(step_res == SQLITE_DONE)</a>
<a name="ln867">    {</a>
<a name="ln868">      /* do nothing, just add some empty thumb frames */</a>
<a name="ln869">    }</a>
<a name="ln870">    else</a>
<a name="ln871">      goto failure;</a>
<a name="ln872">    cairo_translate(cr, wd, 0.0f);</a>
<a name="ln873">  }</a>
<a name="ln874">failure:</a>
<a name="ln875">  cairo_restore(cr);</a>
<a name="ln876">  sqlite3_finalize(stmt);</a>
<a name="ln877"> </a>
<a name="ln878">  // don't reset the global mouse_over_id when the cursor isn't even over the filmstrip</a>
<a name="ln879">  if(pointerx &gt;= 0 &amp;&amp; pointery &gt;= 0)</a>
<a name="ln880">    dt_control_set_mouse_over_id(mouse_over_id);</a>
<a name="ln881"> </a>
<a name="ln882">  if(darktable.gui-&gt;center_tooltip == 1) // set in this round</a>
<a name="ln883">  {</a>
<a name="ln884">    char *tooltip = dt_history_get_items_as_string(strip-&gt;mouse_over_id);</a>
<a name="ln885">    if(tooltip != NULL)</a>
<a name="ln886">    {</a>
<a name="ln887">      gtk_widget_set_tooltip_text(strip-&gt;filmstrip, tooltip);</a>
<a name="ln888">      g_free(tooltip);</a>
<a name="ln889">    }</a>
<a name="ln890">  }</a>
<a name="ln891">  else if(darktable.gui-&gt;center_tooltip == 2) // not set in this round</a>
<a name="ln892">  {</a>
<a name="ln893">    darktable.gui-&gt;center_tooltip = 0;</a>
<a name="ln894">    gtk_widget_set_tooltip_text(strip-&gt;filmstrip, &quot;&quot;);</a>
<a name="ln895">  }</a>
<a name="ln896"> </a>
<a name="ln897">#ifdef _DEBUG</a>
<a name="ln898">  if(darktable.unmuted &amp; DT_DEBUG_CACHE) dt_mipmap_cache_print(darktable.mipmap_cache);</a>
<a name="ln899">#endif</a>
<a name="ln900"> </a>
<a name="ln901">  // copy back the new content into the cairo handle of the draw callback</a>
<a name="ln902">  cairo_destroy(cr);</a>
<a name="ln903">  cairo_set_source_surface(wcr, strip-&gt;surface, 0, 0);</a>
<a name="ln904">  cairo_paint(wcr);</a>
<a name="ln905"> </a>
<a name="ln906">  if(missing)</a>
<a name="ln907">    g_timeout_add(250, _expose_again, user_data);</a>
<a name="ln908">  else</a>
<a name="ln909">  {</a>
<a name="ln910">    // clear hash map of thumb to redisplay, we are done</a>
<a name="ln911">    g_hash_table_remove_all(strip-&gt;thumbs_table);</a>
<a name="ln912">    strip-&gt;force_expose_all = FALSE;</a>
<a name="ln913">  }</a>
<a name="ln914"> </a>
<a name="ln915">  return TRUE;</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">static void _lib_filmstrip_collection_changed_callback(gpointer instance, gpointer user_data)</a>
<a name="ln919">{</a>
<a name="ln920">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln921">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln922">  strip-&gt;force_expose_all = TRUE;</a>
<a name="ln923">  dt_control_queue_redraw_widget(strip-&gt;filmstrip);</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926">static void _lib_filmstrip_scroll_to_image(dt_lib_module_t *self, gint imgid, gboolean activate)</a>
<a name="ln927">{</a>
<a name="ln928">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln929"> </a>
<a name="ln930">  /* if no imgid just bail out */</a>
<a name="ln931">  if(imgid &lt;= 0) return;</a>
<a name="ln932"> </a>
<a name="ln933">  strip-&gt;activated_image = imgid;</a>
<a name="ln934"> </a>
<a name="ln935">  strip-&gt;offset = dt_collection_image_offset(imgid);</a>
<a name="ln936"> </a>
<a name="ln937">  dt_control_set_mouse_over_id(strip-&gt;activated_image);</a>
<a name="ln938"> </a>
<a name="ln939">  /* activate the image if requested */</a>
<a name="ln940">  if(activate)</a>
<a name="ln941">  {</a>
<a name="ln942">    strip-&gt;activated_image = imgid;</a>
<a name="ln943">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_VIEWMANAGER_FILMSTRIP_ACTIVATE);</a>
<a name="ln944">  }</a>
<a name="ln945"> </a>
<a name="ln946">  /* redraw filmstrip. since this is a proxy function it could be used from another thread */</a>
<a name="ln947">  strip-&gt;force_expose_all = TRUE;</a>
<a name="ln948">  dt_control_queue_redraw_widget(self-&gt;widget);</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951">static int32_t _lib_filmstrip_get_activated_imgid(dt_lib_module_t *self)</a>
<a name="ln952">{</a>
<a name="ln953">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln954">  return strip-&gt;activated_image;</a>
<a name="ln955">}</a>
<a name="ln956"> </a>
<a name="ln957">static GtkWidget *_lib_filmstrip_get_widget(dt_lib_module_t *self)</a>
<a name="ln958">{</a>
<a name="ln959">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln960">  return strip-&gt;filmstrip;</a>
<a name="ln961">}</a>
<a name="ln962"> </a>
<a name="ln963">static gboolean _lib_filmstrip_copy_history_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln964">                                                               GObject *aceeleratable, guint keyval,</a>
<a name="ln965">                                                               GdkModifierType modifier, gpointer data)</a>
<a name="ln966">{</a>
<a name="ln967">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)data;</a>
<a name="ln968">  const int32_t mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln969">  if(mouse_over_id &lt;= 0) return FALSE;</a>
<a name="ln970">  strip-&gt;history_copy_imgid = mouse_over_id;</a>
<a name="ln971">  strip-&gt;dg.selops = NULL;</a>
<a name="ln972"> </a>
<a name="ln973">  /* check if images is currently loaded in darkroom */</a>
<a name="ln974">  if(!_is_on_lighttable() &amp;&amp; dt_dev_is_current_image(darktable.develop, mouse_over_id)) dt_dev_write_history(darktable.develop);</a>
<a name="ln975">  return TRUE;</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978">static gboolean _lib_filmstrip_copy_history_parts_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln979">                                                                     GObject *aceeleratable, guint keyval,</a>
<a name="ln980">                                                                     GdkModifierType modifier, gpointer data)</a>
<a name="ln981">{</a>
<a name="ln982">  if(_lib_filmstrip_copy_history_key_accel_callback(accel_group, aceeleratable, keyval, modifier, data))</a>
<a name="ln983">  {</a>
<a name="ln984">    dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)data;</a>
<a name="ln985">    if(dt_gui_hist_dialog_new(&amp;(strip-&gt;dg), strip-&gt;history_copy_imgid, TRUE) == GTK_RESPONSE_CANCEL)</a>
<a name="ln986">      return FALSE;</a>
<a name="ln987">    return TRUE;</a>
<a name="ln988">  }</a>
<a name="ln989">  else</a>
<a name="ln990">    return FALSE;</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">static gboolean _lib_filmstrip_paste_history_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln994">                                                                GObject *aceeleratable, guint keyval,</a>
<a name="ln995">                                                                GdkModifierType modifier, gpointer data)</a>
<a name="ln996">{</a>
<a name="ln997">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)data;</a>
<a name="ln998">  const int mode = dt_conf_get_int(&quot;plugins/lighttable/copy_history/pastemode&quot;);</a>
<a name="ln999"> </a>
<a name="ln1000">  if(dt_history_copy_and_paste_on_selection(strip-&gt;history_copy_imgid, (mode == 0) ? TRUE : FALSE,</a>
<a name="ln1001">                                            strip-&gt;dg.selops) != 0)</a>
<a name="ln1002">  {</a>
<a name="ln1003">    const int32_t mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln1004">    if(mouse_over_id &lt;= 0) return FALSE;</a>
<a name="ln1005"> </a>
<a name="ln1006">    dt_history_copy_and_paste_on_image(strip-&gt;history_copy_imgid, mouse_over_id, (mode == 0) ? TRUE : FALSE,</a>
<a name="ln1007">                                       strip-&gt;dg.selops);</a>
<a name="ln1008">  }</a>
<a name="ln1009"> </a>
<a name="ln1010">  dt_control_queue_redraw_center();</a>
<a name="ln1011">  return TRUE;</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014">static gboolean _lib_filmstrip_paste_history_parts_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln1015">                                                                      GObject *aceeleratable, guint keyval,</a>
<a name="ln1016">                                                                      GdkModifierType modifier, gpointer data)</a>
<a name="ln1017">{</a>
<a name="ln1018">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)data;</a>
<a name="ln1019">  const int mode = dt_conf_get_int(&quot;plugins/lighttable/copy_history/pastemode&quot;);</a>
<a name="ln1020"> </a>
<a name="ln1021">  // get mouse over before launching the dialog</a>
<a name="ln1022">  const int32_t mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln1023"> </a>
<a name="ln1024">  const int res = dt_gui_hist_dialog_new(&amp;(strip-&gt;dg), strip-&gt;history_copy_imgid, FALSE);</a>
<a name="ln1025">  if(res == GTK_RESPONSE_CANCEL) return FALSE;</a>
<a name="ln1026"> </a>
<a name="ln1027">  if(dt_history_copy_and_paste_on_selection(strip-&gt;history_copy_imgid, (mode == 0) ? TRUE : FALSE,</a>
<a name="ln1028">                                            strip-&gt;dg.selops) != 0)</a>
<a name="ln1029">  {</a>
<a name="ln1030">    if(mouse_over_id &lt;= 0) return FALSE;</a>
<a name="ln1031"> </a>
<a name="ln1032">    dt_history_copy_and_paste_on_image(strip-&gt;history_copy_imgid, mouse_over_id, (mode == 0) ? TRUE : FALSE,</a>
<a name="ln1033">                                       strip-&gt;dg.selops);</a>
<a name="ln1034">  }</a>
<a name="ln1035"> </a>
<a name="ln1036">  dt_control_queue_redraw_center();</a>
<a name="ln1037">  return TRUE;</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040">static gboolean _lib_filmstrip_discard_history_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln1041">                                                                  GObject *aceeleratable, guint keyval,</a>
<a name="ln1042">                                                                  GdkModifierType modifier, gpointer data)</a>
<a name="ln1043">{</a>
<a name="ln1044">  const int32_t mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln1045">  if(mouse_over_id &lt;= 0) return FALSE;</a>
<a name="ln1046"> </a>
<a name="ln1047">  dt_history_delete_on_image(mouse_over_id);</a>
<a name="ln1048">  dt_control_queue_redraw_center();</a>
<a name="ln1049">  return TRUE;</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052">static gboolean _lib_filmstrip_duplicate_image_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln1053">                                                                  GObject *aceeleratable, guint keyval,</a>
<a name="ln1054">                                                                  GdkModifierType modifier, gpointer data)</a>
<a name="ln1055">{</a>
<a name="ln1056">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)data;</a>
<a name="ln1057"> </a>
<a name="ln1058">  if(_is_on_lighttable()) return FALSE;</a>
<a name="ln1059"> </a>
<a name="ln1060">  strip-&gt;force_expose_all = TRUE;</a>
<a name="ln1061"> </a>
<a name="ln1062">  const int32_t mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln1063">  if(mouse_over_id &lt;= 0) return FALSE;</a>
<a name="ln1064"> </a>
<a name="ln1065">  /* check if images is currently loaded in darkroom */</a>
<a name="ln1066">  if(!_is_on_lighttable() &amp;&amp; dt_dev_is_current_image(darktable.develop, mouse_over_id)) dt_dev_write_history(darktable.develop);</a>
<a name="ln1067"> </a>
<a name="ln1068">  const int32_t newimgid = dt_image_duplicate(mouse_over_id);</a>
<a name="ln1069">  if(newimgid != -1) dt_history_copy_and_paste_on_image(mouse_over_id, newimgid, FALSE, NULL);</a>
<a name="ln1070"> </a>
<a name="ln1071">  dt_control_queue_redraw_center();</a>
<a name="ln1072">  return TRUE;</a>
<a name="ln1073">}</a>
<a name="ln1074"> </a>
<a name="ln1075">static gboolean _lib_filmstrip_ratings_key_accel_callback(GtkAccelGroup *accel_group, GObject *aceeleratable,</a>
<a name="ln1076">                                                          guint keyval, GdkModifierType modifier,</a>
<a name="ln1077">                                                          gpointer data)</a>
<a name="ln1078">{</a>
<a name="ln1079">  dt_lib_module_t *self = (dt_lib_module_t *)darktable.view_manager-&gt;proxy.filmstrip.module;</a>
<a name="ln1080">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln1081"> </a>
<a name="ln1082">  if(_is_on_lighttable()) return FALSE;</a>
<a name="ln1083"> </a>
<a name="ln1084">  const int num = GPOINTER_TO_INT(data);</a>
<a name="ln1085">  strip-&gt;force_expose_all = TRUE;</a>
<a name="ln1086"> </a>
<a name="ln1087">  switch(num)</a>
<a name="ln1088">  {</a>
<a name="ln1089">    case DT_VIEW_DESERT:</a>
<a name="ln1090">    case DT_VIEW_REJECT:</a>
<a name="ln1091">    case DT_VIEW_STAR_1:</a>
<a name="ln1092">    case DT_VIEW_STAR_2:</a>
<a name="ln1093">    case DT_VIEW_STAR_3:</a>
<a name="ln1094">    case DT_VIEW_STAR_4:</a>
<a name="ln1095">    case DT_VIEW_STAR_5:</a>
<a name="ln1096">    {</a>
<a name="ln1097">      const int32_t mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln1098"> </a>
<a name="ln1099">      /* get image from cache */</a>
<a name="ln1100"> </a>
<a name="ln1101">      const int32_t activated_image = darktable.view_manager-&gt;proxy.filmstrip.activated_image(</a>
<a name="ln1102">        darktable.view_manager-&gt;proxy.filmstrip.module);</a>
<a name="ln1103"> </a>
<a name="ln1104">      const int32_t image_id = mouse_over_id == -1 ? activated_image : mouse_over_id;</a>
<a name="ln1105"> </a>
<a name="ln1106">      int offset = 0;</a>
<a name="ln1107">      if(mouse_over_id == activated_image) offset = dt_collection_image_offset(mouse_over_id);</a>
<a name="ln1108"> </a>
<a name="ln1109">      dt_ratings_apply_to_image_or_group(image_id, num);</a>
<a name="ln1110"> </a>
<a name="ln1111">      dt_collection_update_query(darktable.collection); // update the counter and selection</a>
<a name="ln1112">      dt_collection_hint_message(darktable.collection); // More than this, we need to redraw all</a>
<a name="ln1113"> </a>
<a name="ln1114">      if(mouse_over_id == activated_image)</a>
<a name="ln1115">        if(_lib_filmstrip_imgid_in_collection(darktable.collection, mouse_over_id) == 0)</a>
<a name="ln1116">          dt_view_filmstrip_scroll_relative(0, offset);</a>
<a name="ln1117"> </a>
<a name="ln1118">      /* redraw all */</a>
<a name="ln1119">      dt_control_queue_redraw();</a>
<a name="ln1120">      break;</a>
<a name="ln1121">    }</a>
<a name="ln1122">    default:</a>
<a name="ln1123">      break;</a>
<a name="ln1124">  }</a>
<a name="ln1125">  return TRUE;</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128">static gboolean _lib_filmstrip_colorlabels_key_accel_callback(GtkAccelGroup *accel_group,</a>
<a name="ln1129">                                                              GObject *acceleratable, guint keyval,</a>
<a name="ln1130">                                                              GdkModifierType modifier, gpointer data)</a>
<a name="ln1131">{</a>
<a name="ln1132">  dt_lib_module_t *self = (dt_lib_module_t *)darktable.view_manager-&gt;proxy.filmstrip.module;</a>
<a name="ln1133">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln1134"> </a>
<a name="ln1135">  if(_is_on_lighttable()) return FALSE;</a>
<a name="ln1136"> </a>
<a name="ln1137">  strip-&gt;force_expose_all = TRUE;</a>
<a name="ln1138"> </a>
<a name="ln1139">  dt_colorlabels_key_accel_callback(NULL, NULL, 0, 0, data);</a>
<a name="ln1140">  /* redraw filmstrip */</a>
<a name="ln1141">  gtk_widget_queue_draw(strip-&gt;filmstrip);</a>
<a name="ln1142">  return TRUE;</a>
<a name="ln1143">}</a>
<a name="ln1144"> </a>
<a name="ln1145">static gboolean _lib_filmstrip_select_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable,</a>
<a name="ln1146">                                                         guint keyval, GdkModifierType modifier,</a>
<a name="ln1147">                                                         gpointer data)</a>
<a name="ln1148">{</a>
<a name="ln1149">  dt_lib_module_t *self = (dt_lib_module_t *)darktable.view_manager-&gt;proxy.filmstrip.module;</a>
<a name="ln1150">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln1151"> </a>
<a name="ln1152">  if(_is_on_lighttable()) return FALSE;</a>
<a name="ln1153"> </a>
<a name="ln1154">  strip-&gt;force_expose_all = TRUE;</a>
<a name="ln1155"> </a>
<a name="ln1156">  switch(GPOINTER_TO_INT(data))</a>
<a name="ln1157">  {</a>
<a name="ln1158">    case 0: // all</a>
<a name="ln1159">      dt_selection_select_all(darktable.selection);</a>
<a name="ln1160">      break;</a>
<a name="ln1161">    case 1: // none</a>
<a name="ln1162">      dt_selection_clear(darktable.selection);</a>
<a name="ln1163">      break;</a>
<a name="ln1164">    case 2: // invert</a>
<a name="ln1165">      dt_selection_invert(darktable.selection);</a>
<a name="ln1166">      break;</a>
<a name="ln1167">    case 4: // untouched</a>
<a name="ln1168">      dt_selection_select_unaltered(darktable.selection);</a>
<a name="ln1169">      break;</a>
<a name="ln1170">    default: // case 3: same film roll</a>
<a name="ln1171">      dt_selection_select_filmroll(darktable.selection);</a>
<a name="ln1172">  }</a>
<a name="ln1173"> </a>
<a name="ln1174">  gtk_widget_queue_draw(strip-&gt;filmstrip);</a>
<a name="ln1175">  return TRUE;</a>
<a name="ln1176">}</a>
<a name="ln1177"> </a>
<a name="ln1178">static void _lib_filmstrip_dnd_get_callback(GtkWidget *widget, GdkDragContext *context,</a>
<a name="ln1179">                                            GtkSelectionData *selection_data, guint target_type, guint time,</a>
<a name="ln1180">                                            gpointer user_data)</a>
<a name="ln1181">{</a>
<a name="ln1182">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1183">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln1184"> </a>
<a name="ln1185">  if(_is_on_lighttable()) return;</a>
<a name="ln1186"> </a>
<a name="ln1187">  g_assert(selection_data != NULL);</a>
<a name="ln1188"> </a>
<a name="ln1189">  int mouse_over_id = strip-&gt;mouse_over_id;</a>
<a name="ln1190">  int count = dt_collection_get_selected_count(NULL);</a>
<a name="ln1191">  switch(target_type)</a>
<a name="ln1192">  {</a>
<a name="ln1193">    case DND_TARGET_IMGID:</a>
<a name="ln1194">    {</a>
<a name="ln1195">      int id = ((count == 1) ? mouse_over_id : -1);</a>
<a name="ln1196">      gtk_selection_data_set(selection_data, gtk_selection_data_get_target(selection_data), _DWORD,</a>
<a name="ln1197">                             (guchar *)&amp;id, sizeof(id));</a>
<a name="ln1198">      break;</a>
<a name="ln1199">    }</a>
<a name="ln1200">    default:             // return the location of the file as a last resort</a>
<a name="ln1201">    case DND_TARGET_URI: // TODO: add all images from the selection</a>
<a name="ln1202">    {</a>
<a name="ln1203">      if(count == 1)</a>
<a name="ln1204">      {</a>
<a name="ln1205">        gchar pathname[PATH_MAX] = { 0 };</a>
<a name="ln1206">        gboolean from_cache = TRUE;</a>
<a name="ln1207">        dt_image_full_path(mouse_over_id, pathname, sizeof(pathname), &amp;from_cache);</a>
<a name="ln1208">        gchar *uri = g_strdup_printf(&quot;file://%s&quot;, pathname); // TODO: should we add the host?</a>
<a name="ln1209">        gtk_selection_data_set(selection_data, gtk_selection_data_get_target(selection_data), _BYTE,</a>
<a name="ln1210">                               (guchar *)uri, strlen(uri));</a>
<a name="ln1211">        g_free(uri);</a>
<a name="ln1212">      }</a>
<a name="ln1213">      else</a>
<a name="ln1214">      {</a>
<a name="ln1215">        sqlite3_stmt *stmt;</a>
<a name="ln1216">        GList *images = NULL;</a>
<a name="ln1217">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1218">                                    &quot;SELECT imgid FROM main.selected_images&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1219">        while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1220">        {</a>
<a name="ln1221">          int id = sqlite3_column_int(stmt, 0);</a>
<a name="ln1222">          gchar pathname[PATH_MAX] = { 0 };</a>
<a name="ln1223">          gboolean from_cache = TRUE;</a>
<a name="ln1224">          dt_image_full_path(id, pathname, sizeof(pathname), &amp;from_cache);</a>
<a name="ln1225">          gchar *uri = g_strdup_printf(&quot;file://%s&quot;, pathname); // TODO: should we add the host?</a>
<a name="ln1226">          images = g_list_append(images, uri);</a>
<a name="ln1227">        }</a>
<a name="ln1228">        sqlite3_finalize(stmt);</a>
<a name="ln1229">        gchar *uri_list = dt_util_glist_to_str(&quot;\r\n&quot;, images);</a>
<a name="ln1230">        g_list_free_full(images, g_free);</a>
<a name="ln1231">        gtk_selection_data_set(selection_data, gtk_selection_data_get_target(selection_data), _BYTE,</a>
<a name="ln1232">                               (guchar *)uri_list, strlen(uri_list));</a>
<a name="ln1233">        g_free(uri_list);</a>
<a name="ln1234">      }</a>
<a name="ln1235">      break;</a>
<a name="ln1236">    }</a>
<a name="ln1237">  }</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240">static void _lib_filmstrip_dnd_begin_callback(GtkWidget *widget, GdkDragContext *context, gpointer user_data)</a>
<a name="ln1241">{</a>
<a name="ln1242">  const int ts = DT_PIXEL_APPLY_DPI(64);</a>
<a name="ln1243"> </a>
<a name="ln1244">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1245">  dt_lib_filmstrip_t *strip = (dt_lib_filmstrip_t *)self-&gt;data;</a>
<a name="ln1246"> </a>
<a name="ln1247">  if(_is_on_lighttable()) return;</a>
<a name="ln1248"> </a>
<a name="ln1249">  int imgid = strip-&gt;mouse_over_id;</a>
<a name="ln1250"> </a>
<a name="ln1251">  // imgid part of selection -&gt; do nothing</a>
<a name="ln1252">  // otherwise               -&gt; select the current image</a>
<a name="ln1253">  strip-&gt;select = DT_LIB_FILMSTRIP_SELECT_NONE;</a>
<a name="ln1254">  sqlite3_stmt *stmt;</a>
<a name="ln1255">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1256">                              &quot;SELECT imgid FROM main.selected_images WHERE imgid=?1 LIMIT 1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1257">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1258">  if(sqlite3_step(stmt) != SQLITE_ROW)</a>
<a name="ln1259">  {</a>
<a name="ln1260">    dt_selection_select_single(darktable.selection, imgid);</a>
<a name="ln1261">    /* redraw filmstrip */</a>
<a name="ln1262">    if(darktable.view_manager-&gt;proxy.filmstrip.module)</a>
<a name="ln1263">      gtk_widget_queue_draw(darktable.view_manager-&gt;proxy.filmstrip.module-&gt;widget);</a>
<a name="ln1264">  }</a>
<a name="ln1265">  sqlite3_finalize(stmt);</a>
<a name="ln1266"> </a>
<a name="ln1267">  // if we are dragging a single image -&gt; use the thumbnail of that image</a>
<a name="ln1268">  // otherwise use the generic d&amp;d icon</a>
<a name="ln1269">  // TODO: have something pretty in the 2nd case, too.</a>
<a name="ln1270">  if(dt_collection_get_selected_count(NULL) == 1)</a>
<a name="ln1271">  {</a>
<a name="ln1272">    dt_mipmap_buffer_t buf;</a>
<a name="ln1273">    dt_mipmap_size_t mip = dt_mipmap_cache_get_matching_size(darktable.mipmap_cache, ts, ts);</a>
<a name="ln1274">    dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, mip, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln1275"> </a>
<a name="ln1276">    if(buf.buf)</a>
<a name="ln1277">    {</a>
<a name="ln1278">      for(size_t i = 3; i &lt; (size_t)4 * buf.width * buf.height; i += 4) buf.buf[i] = UINT8_MAX;</a>
<a name="ln1279"> </a>
<a name="ln1280">      int w = ts, h = ts;</a>
<a name="ln1281">      if(buf.width &lt; buf.height)</a>
<a name="ln1282">        w = (buf.width * ts) / buf.height; // portrait</a>
<a name="ln1283">      else</a>
<a name="ln1284">        h = (buf.height * ts) / buf.width; // landscape</a>
<a name="ln1285"> </a>
<a name="ln1286">      GdkPixbuf *source = gdk_pixbuf_new_from_data(buf.buf, GDK_COLORSPACE_RGB, TRUE, 8, buf.width,</a>
<a name="ln1287">                                                   buf.height, buf.width * 4, NULL, NULL);</a>
<a name="ln1288">      GdkPixbuf *scaled = gdk_pixbuf_scale_simple(source, w, h, GDK_INTERP_HYPER);</a>
<a name="ln1289">      gtk_drag_set_icon_pixbuf(context, scaled, 0, h);</a>
<a name="ln1290"> </a>
<a name="ln1291">      if(source) g_object_unref(source);</a>
<a name="ln1292">      if(scaled) g_object_unref(scaled);</a>
<a name="ln1293">    }</a>
<a name="ln1294"> </a>
<a name="ln1295">    dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln1296">  }</a>
<a name="ln1297">}</a>
<a name="ln1298"> </a>
<a name="ln1299">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1300">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1301">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="294"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 294, 291.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
