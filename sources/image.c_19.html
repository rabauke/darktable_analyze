
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/image.h&quot;</a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/exif.h&quot;</a>
<a name="ln24">#include &quot;common/grouping.h&quot;</a>
<a name="ln25">#include &quot;common/history.h&quot;</a>
<a name="ln26">#include &quot;common/image_cache.h&quot;</a>
<a name="ln27">#include &quot;common/imageio.h&quot;</a>
<a name="ln28">#include &quot;common/imageio_rawspeed.h&quot;</a>
<a name="ln29">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln30">#include &quot;common/tags.h&quot;</a>
<a name="ln31">#include &quot;control/conf.h&quot;</a>
<a name="ln32">#include &quot;control/control.h&quot;</a>
<a name="ln33">#include &quot;control/jobs.h&quot;</a>
<a name="ln34">#include &quot;develop/lightroom.h&quot;</a>
<a name="ln35">#ifdef USE_LUA</a>
<a name="ln36">#include &quot;lua/image.h&quot;</a>
<a name="ln37">#endif</a>
<a name="ln38">#include &lt;assert.h&gt;</a>
<a name="ln39">#include &lt;math.h&gt;</a>
<a name="ln40">#include &lt;sqlite3.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;string.h&gt;</a>
<a name="ln43">#include &lt;strings.h&gt;</a>
<a name="ln44">#ifndef _WIN32</a>
<a name="ln45">#include &lt;glob.h&gt;</a>
<a name="ln46">#endif</a>
<a name="ln47">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49">static int64_t max_image_position()</a>
<a name="ln50">{</a>
<a name="ln51">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln52"> </a>
<a name="ln53">  // get last position</a>
<a name="ln54">  int64_t max_position = 0;</a>
<a name="ln55"> </a>
<a name="ln56">  gchar *max_position_query = &quot;SELECT MAX(position) FROM main.images&quot;;</a>
<a name="ln57">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), max_position_query, -1, &amp;stmt, NULL);</a>
<a name="ln58"> </a>
<a name="ln59">  if (sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln60">  {</a>
<a name="ln61">    max_position = sqlite3_column_int64(stmt, 0);</a>
<a name="ln62">  }</a>
<a name="ln63"> </a>
<a name="ln64">  sqlite3_finalize(stmt);</a>
<a name="ln65">  return max_position;</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">static int64_t create_next_image_position()</a>
<a name="ln69">{</a>
<a name="ln70">  /* The sequence pictures come in (import) define the initial sequence.</a>
<a name="ln71">   *</a>
<a name="ln72">   * The upper int32_t of the last image position is increased by one</a>
<a name="ln73">   * while the lower 32 bits are masked out.</a>
<a name="ln74">   *</a>
<a name="ln75">   * Example:</a>
<a name="ln76">   * last image position: (Hex)</a>
<a name="ln77">   * 0000 0002 0000 0001</a>
<a name="ln78">   *</a>
<a name="ln79">   * next image position</a>
<a name="ln80">   * 0000 0003 0000 0000</a>
<a name="ln81">   */</a>
<a name="ln82">  return (max_image_position() &amp; 0xFFFFFFFF00000000) + (1ll &lt;&lt; 32);</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85">static void _image_local_copy_full_path(const int imgid, char *pathname, size_t pathname_len);</a>
<a name="ln86"> </a>
<a name="ln87">int dt_image_is_ldr(const dt_image_t *img)</a>
<a name="ln88">{</a>
<a name="ln89">  const char *c = img-&gt;filename + strlen(img-&gt;filename);</a>
<a name="ln90">  while(*c != '.' &amp;&amp; c &gt; img-&gt;filename) c--;</a>
<a name="ln91">  if((img-&gt;flags &amp; DT_IMAGE_LDR) || !strcasecmp(c, &quot;.jpg&quot;) || !strcasecmp(c, &quot;.png&quot;)</a>
<a name="ln92">     || !strcasecmp(c, &quot;.ppm&quot;))</a>
<a name="ln93">    return 1;</a>
<a name="ln94">  else</a>
<a name="ln95">    return 0;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">int dt_image_is_hdr(const dt_image_t *img)</a>
<a name="ln99">{</a>
<a name="ln100">  const char *c = img-&gt;filename + strlen(img-&gt;filename);</a>
<a name="ln101">  while(*c != '.' &amp;&amp; c &gt; img-&gt;filename) c--;</a>
<a name="ln102">  if((img-&gt;flags &amp; DT_IMAGE_HDR) || !strcasecmp(c, &quot;.exr&quot;) || !strcasecmp(c, &quot;.hdr&quot;)</a>
<a name="ln103">     || !strcasecmp(c, &quot;.pfm&quot;))</a>
<a name="ln104">    return 1;</a>
<a name="ln105">  else</a>
<a name="ln106">    return 0;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">int dt_image_is_raw(const dt_image_t *img)</a>
<a name="ln110">{</a>
<a name="ln111">  // NULL terminated list of supported non-RAW extensions</a>
<a name="ln112">  const char *dt_non_raw_extensions[]</a>
<a name="ln113">      = { &quot;.jpeg&quot;, &quot;.jpg&quot;,  &quot;.pfm&quot;, &quot;.hdr&quot;, &quot;.exr&quot;, &quot;.pxn&quot;, &quot;.tif&quot;, &quot;.tiff&quot;, &quot;.png&quot;,</a>
<a name="ln114">          &quot;.j2c&quot;,  &quot;.j2k&quot;,  &quot;.jp2&quot;, &quot;.jpc&quot;, &quot;.gif&quot;, &quot;.jpc&quot;, &quot;.jp2&quot;, &quot;.bmp&quot;,  &quot;.dcm&quot;,</a>
<a name="ln115">          &quot;.jng&quot;,  &quot;.miff&quot;, &quot;.mng&quot;, &quot;.pbm&quot;, &quot;.pnm&quot;, &quot;.ppm&quot;, &quot;.pgm&quot;, NULL };</a>
<a name="ln116"> </a>
<a name="ln117">  if(img-&gt;flags &amp; DT_IMAGE_RAW) return TRUE;</a>
<a name="ln118"> </a>
<a name="ln119">  const char *c = img-&gt;filename + strlen(img-&gt;filename);</a>
<a name="ln120">  while(*c != '.' &amp;&amp; c &gt; img-&gt;filename) c--;</a>
<a name="ln121"> </a>
<a name="ln122">  gboolean isnonraw = FALSE;</a>
<a name="ln123">  for(const char **i = dt_non_raw_extensions; *i != NULL; i++)</a>
<a name="ln124">  {</a>
<a name="ln125">    if(!g_ascii_strncasecmp(c, *i, strlen(*i)))</a>
<a name="ln126">    {</a>
<a name="ln127">      isnonraw = TRUE;</a>
<a name="ln128">      break;</a>
<a name="ln129">    }</a>
<a name="ln130">  }</a>
<a name="ln131"> </a>
<a name="ln132">  return !isnonraw;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">int dt_image_is_monochrome(const dt_image_t *img)</a>
<a name="ln136">{</a>
<a name="ln137">  if(strncmp(img-&gt;exif_maker, &quot;Leica Camera AG&quot;, 15) != 0) return 0;</a>
<a name="ln138"> </a>
<a name="ln139">  gchar *tmp_model = g_ascii_strdown(img-&gt;exif_model, -1);</a>
<a name="ln140"> </a>
<a name="ln141">  const int res = strstr(tmp_model, &quot;monochrom&quot;) != NULL;</a>
<a name="ln142">  g_free(tmp_model);</a>
<a name="ln143"> </a>
<a name="ln144">  return res;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">const char *dt_image_film_roll_name(const char *path)</a>
<a name="ln148">{</a>
<a name="ln149">  const char *folder = path + strlen(path);</a>
<a name="ln150">  int numparts = dt_conf_get_int(&quot;show_folder_levels&quot;);</a>
<a name="ln151">  numparts = CLAMPS(numparts, 1, 5);</a>
<a name="ln152">  int count = 0;</a>
<a name="ln153">  if(numparts &lt; 1) numparts = 1;</a>
<a name="ln154">  while(folder &gt; path)</a>
<a name="ln155">  {</a>
<a name="ln156">    if(*folder == G_DIR_SEPARATOR)</a>
<a name="ln157">      if(++count &gt;= numparts)</a>
<a name="ln158">      {</a>
<a name="ln159">        ++folder;</a>
<a name="ln160">        break;</a>
<a name="ln161">      }</a>
<a name="ln162">    --folder;</a>
<a name="ln163">  }</a>
<a name="ln164">  return folder;</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">void dt_image_film_roll_directory(const dt_image_t *img, char *pathname, size_t pathname_len)</a>
<a name="ln168">{</a>
<a name="ln169">  sqlite3_stmt *stmt;</a>
<a name="ln170">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT folder FROM main.film_rolls WHERE id = ?1&quot;,</a>
<a name="ln171">                              -1, &amp;stmt, NULL);</a>
<a name="ln172">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;film_id);</a>
<a name="ln173">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln174">  {</a>
<a name="ln175">    char *f = (char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln176">    snprintf(pathname, pathname_len, &quot;%s&quot;, f);</a>
<a name="ln177">  }</a>
<a name="ln178">  sqlite3_finalize(stmt);</a>
<a name="ln179">  pathname[pathname_len - 1] = '\0';</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182"> </a>
<a name="ln183">void dt_image_film_roll(const dt_image_t *img, char *pathname, size_t pathname_len)</a>
<a name="ln184">{</a>
<a name="ln185">  sqlite3_stmt *stmt;</a>
<a name="ln186">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT folder FROM main.film_rolls WHERE id = ?1&quot;,</a>
<a name="ln187">                              -1, &amp;stmt, NULL);</a>
<a name="ln188">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;film_id);</a>
<a name="ln189">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln190">  {</a>
<a name="ln191">    char *f = (char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln192">    const char *c = dt_image_film_roll_name(f);</a>
<a name="ln193">    snprintf(pathname, pathname_len, &quot;%s&quot;, c);</a>
<a name="ln194">  }</a>
<a name="ln195">  else</a>
<a name="ln196">  {</a>
<a name="ln197">    snprintf(pathname, pathname_len, &quot;%s&quot;, _(&quot;orphaned image&quot;));</a>
<a name="ln198">  }</a>
<a name="ln199">  sqlite3_finalize(stmt);</a>
<a name="ln200">  pathname[pathname_len - 1] = '\0';</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">gboolean dt_image_safe_remove(const int32_t imgid)</a>
<a name="ln204">{</a>
<a name="ln205">  // always safe to remove if we do not have .xmp</a>
<a name="ln206">  if(!dt_conf_get_bool(&quot;write_sidecar_files&quot;)) return TRUE;</a>
<a name="ln207"> </a>
<a name="ln208">  // check whether the original file is accessible</a>
<a name="ln209">  char pathname[PATH_MAX] = { 0 };</a>
<a name="ln210">  gboolean from_cache = TRUE;</a>
<a name="ln211"> </a>
<a name="ln212">  dt_image_full_path(imgid, pathname, sizeof(pathname), &amp;from_cache);</a>
<a name="ln213"> </a>
<a name="ln214">  if(!from_cache)</a>
<a name="ln215">    return TRUE;</a>
<a name="ln216"> </a>
<a name="ln217">  else</a>
<a name="ln218">  {</a>
<a name="ln219">    // finally check if we have a .xmp for the local copy. If no modification done on the local copy it is safe</a>
<a name="ln220">    // to remove.</a>
<a name="ln221">    g_strlcat(pathname, &quot;.xmp&quot;, sizeof(pathname));</a>
<a name="ln222">    return !g_file_test(pathname, G_FILE_TEST_EXISTS);</a>
<a name="ln223">  }</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">void dt_image_full_path(const int imgid, char *pathname, size_t pathname_len, gboolean *from_cache)</a>
<a name="ln227">{</a>
<a name="ln228">  sqlite3_stmt *stmt;</a>
<a name="ln229">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln230">                              &quot;SELECT folder || '&quot; G_DIR_SEPARATOR_S &quot;' || filename FROM main.images i, main.film_rolls f WHERE &quot;</a>
<a name="ln231">                              &quot;i.film_id = f.id and i.id = ?1&quot;,</a>
<a name="ln232">                              -1, &amp;stmt, NULL);</a>
<a name="ln233">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln234">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln235">  {</a>
<a name="ln236">    g_strlcpy(pathname, (char *)sqlite3_column_text(stmt, 0), pathname_len);</a>
<a name="ln237">  }</a>
<a name="ln238">  sqlite3_finalize(stmt);</a>
<a name="ln239"> </a>
<a name="ln240">  if(*from_cache)</a>
<a name="ln241">  {</a>
<a name="ln242">    char lc_pathname[PATH_MAX] = { 0 };</a>
<a name="ln243">    _image_local_copy_full_path(imgid, lc_pathname, sizeof(lc_pathname));</a>
<a name="ln244"> </a>
<a name="ln245">    if (g_file_test(lc_pathname, G_FILE_TEST_EXISTS))</a>
<a name="ln246">      g_strlcpy(pathname, (char *)lc_pathname, pathname_len);</a>
<a name="ln247">    else</a>
<a name="ln248">      *from_cache = FALSE;</a>
<a name="ln249">  }</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">static void _image_local_copy_full_path(const int imgid, char *pathname, size_t pathname_len)</a>
<a name="ln253">{</a>
<a name="ln254">  sqlite3_stmt *stmt;</a>
<a name="ln255"> </a>
<a name="ln256">  *pathname = '\0';</a>
<a name="ln257">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln258">                              &quot;SELECT folder || '&quot; G_DIR_SEPARATOR_S &quot;' || filename FROM main.images i, main.film_rolls f &quot;</a>
<a name="ln259">                              &quot;WHERE i.film_id = f.id AND i.id = ?1&quot;,</a>
<a name="ln260">                              -1, &amp;stmt, NULL);</a>
<a name="ln261">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln262">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln263">  {</a>
<a name="ln264">    char filename[PATH_MAX] = { 0 };</a>
<a name="ln265">    char cachedir[PATH_MAX] = { 0 };</a>
<a name="ln266">    g_strlcpy(filename, (char *)sqlite3_column_text(stmt, 0), pathname_len);</a>
<a name="ln267">    char *md5_filename = g_compute_checksum_for_string(G_CHECKSUM_MD5, filename, strlen(filename));</a>
<a name="ln268">    dt_loc_get_user_cache_dir(cachedir, sizeof(cachedir));</a>
<a name="ln269"> </a>
<a name="ln270">    // and finally, add extension, needed as some part of the code is looking for the extension</a>
<a name="ln271">    char *c = filename + strlen(filename);</a>
<a name="ln272">    while(*c != '.' &amp;&amp; c &gt; filename) c--;</a>
<a name="ln273"> </a>
<a name="ln274">    // cache filename old format: &lt;cachedir&gt;/img-&lt;id&gt;-&lt;MD5&gt;.&lt;ext&gt;</a>
<a name="ln275">    // for upward compatibility we check for the old name, if found we return it</a>
<a name="ln276">    snprintf(pathname, pathname_len, &quot;%s/img-%d-%s%s&quot;, cachedir, imgid, md5_filename, c);</a>
<a name="ln277"> </a>
<a name="ln278">    // if it does not exist, we return the new naming</a>
<a name="ln279">    if(!g_file_test(pathname, G_FILE_TEST_EXISTS))</a>
<a name="ln280">    {</a>
<a name="ln281">      // cache filename format: &lt;cachedir&gt;/img-&lt;MD5&gt;.&lt;ext&gt;</a>
<a name="ln282">      snprintf(pathname, pathname_len, &quot;%s/img-%s%s&quot;, cachedir, md5_filename, c);</a>
<a name="ln283">    }</a>
<a name="ln284"> </a>
<a name="ln285">    g_free(md5_filename);</a>
<a name="ln286">  }</a>
<a name="ln287">  sqlite3_finalize(stmt);</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">void dt_image_path_append_version_no_db(int version, char *pathname, size_t pathname_len)</a>
<a name="ln291">{</a>
<a name="ln292">  // the &quot;first&quot; instance (version zero) does not get a version suffix</a>
<a name="ln293">  if(version &gt; 0)</a>
<a name="ln294">  {</a>
<a name="ln295">    // add version information:</a>
<a name="ln296">    char *filename = g_strdup(pathname);</a>
<a name="ln297"> </a>
<a name="ln298">    char *c = pathname + strlen(pathname);</a>
<a name="ln299">    while(*c != '.' &amp;&amp; c &gt; pathname) c--;</a>
<a name="ln300">    snprintf(c, pathname + pathname_len - c, &quot;_%02d&quot;, version);</a>
<a name="ln301">    c = pathname + strlen(pathname);</a>
<a name="ln302">    char *c2 = filename + strlen(filename);</a>
<a name="ln303">    while(*c2 != '.' &amp;&amp; c2 &gt; filename) c2--;</a>
<a name="ln304">    snprintf(c, pathname + pathname_len - c, &quot;%s&quot;, c2);</a>
<a name="ln305">    g_free(filename);</a>
<a name="ln306">  }</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">void dt_image_path_append_version(int imgid, char *pathname, size_t pathname_len)</a>
<a name="ln310">{</a>
<a name="ln311">  // get duplicate suffix</a>
<a name="ln312">  int version = 0;</a>
<a name="ln313">  sqlite3_stmt *stmt;</a>
<a name="ln314">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT version FROM main.images WHERE id = ?1&quot;, -1,</a>
<a name="ln315">                              &amp;stmt, NULL);</a>
<a name="ln316">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln317"> </a>
<a name="ln318">  if(sqlite3_step(stmt) == SQLITE_ROW) version = sqlite3_column_int(stmt, 0);</a>
<a name="ln319">  sqlite3_finalize(stmt);</a>
<a name="ln320"> </a>
<a name="ln321">  dt_image_path_append_version_no_db(version, pathname, pathname_len);</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">void dt_image_print_exif(const dt_image_t *img, char *line, size_t line_len)</a>
<a name="ln325">{</a>
<a name="ln326">  if(img-&gt;exif_exposure &gt;= 1.0f)</a>
<a name="ln327">    if(nearbyintf(img-&gt;exif_exposure) == img-&gt;exif_exposure)</a>
<a name="ln328">      snprintf(line, line_len, &quot;%.0f″ f/%.1f %dmm iso %d&quot;, img-&gt;exif_exposure, img-&gt;exif_aperture,</a>
<a name="ln329">               (int)img-&gt;exif_focal_length, (int)img-&gt;exif_iso);</a>
<a name="ln330">    else</a>
<a name="ln331">      snprintf(line, line_len, &quot;%.1f″ f/%.1f %dmm iso %d&quot;, img-&gt;exif_exposure, img-&gt;exif_aperture,</a>
<a name="ln332">               (int)img-&gt;exif_focal_length, (int)img-&gt;exif_iso);</a>
<a name="ln333">  /* want to catch everything below 0.3 seconds */</a>
<a name="ln334">  else if(img-&gt;exif_exposure &lt; 0.29f)</a>
<a name="ln335">    snprintf(line, line_len, &quot;1/%.0f f/%.1f %dmm iso %d&quot;, 1.0 / img-&gt;exif_exposure, img-&gt;exif_aperture,</a>
<a name="ln336">             (int)img-&gt;exif_focal_length, (int)img-&gt;exif_iso);</a>
<a name="ln337">  /* catch 1/2, 1/3 */</a>
<a name="ln338">  else if(nearbyintf(1.0f / img-&gt;exif_exposure) == 1.0f / img-&gt;exif_exposure)</a>
<a name="ln339">    snprintf(line, line_len, &quot;1/%.0f f/%.1f %dmm iso %d&quot;, 1.0 / img-&gt;exif_exposure, img-&gt;exif_aperture,</a>
<a name="ln340">             (int)img-&gt;exif_focal_length, (int)img-&gt;exif_iso);</a>
<a name="ln341">  /* catch 1/1.3, 1/1.6, etc. */</a>
<a name="ln342">  else if(10 * nearbyintf(10.0f / img-&gt;exif_exposure) == nearbyintf(100.0f / img-&gt;exif_exposure))</a>
<a name="ln343">    snprintf(line, line_len, &quot;1/%.1f f/%.1f %dmm iso %d&quot;, 1.0 / img-&gt;exif_exposure, img-&gt;exif_aperture,</a>
<a name="ln344">             (int)img-&gt;exif_focal_length, (int)img-&gt;exif_iso);</a>
<a name="ln345">  else</a>
<a name="ln346">    snprintf(line, line_len, &quot;%.1f″ f/%.1f %dmm iso %d&quot;, img-&gt;exif_exposure, img-&gt;exif_aperture,</a>
<a name="ln347">             (int)img-&gt;exif_focal_length, (int)img-&gt;exif_iso);</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">void dt_image_set_location(const int32_t imgid, double lon, double lat)</a>
<a name="ln351">{</a>
<a name="ln352">  /* fetch image from cache */</a>
<a name="ln353">  dt_image_t *image = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln354"> </a>
<a name="ln355">  /* set image location */</a>
<a name="ln356">  image-&gt;longitude = lon;</a>
<a name="ln357">  image-&gt;latitude = lat;</a>
<a name="ln358"> </a>
<a name="ln359">  /* store */</a>
<a name="ln360">  dt_image_cache_write_release(darktable.image_cache, image, DT_IMAGE_CACHE_SAFE);</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">void dt_image_set_location_and_elevation(const int32_t imgid, double lon, double lat, double ele)</a>
<a name="ln364">{</a>
<a name="ln365">  /* fetch image from cache */</a>
<a name="ln366">  dt_image_t *image = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln367"> </a>
<a name="ln368">  /* set image location and elevation */</a>
<a name="ln369">  image-&gt;longitude = lon;</a>
<a name="ln370">  image-&gt;latitude = lat;</a>
<a name="ln371">  image-&gt;elevation = ele;</a>
<a name="ln372"> </a>
<a name="ln373">  /* store */</a>
<a name="ln374">  dt_image_cache_write_release(darktable.image_cache, image, DT_IMAGE_CACHE_SAFE);</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377">gboolean dt_image_get_final_size(const int32_t imgid, int *width, int *height)</a>
<a name="ln378">{</a>
<a name="ln379">  dt_develop_t dev;</a>
<a name="ln380"> </a>
<a name="ln381">  dt_dev_init(&amp;dev, 0);</a>
<a name="ln382">  dt_dev_load_image(&amp;dev, imgid);</a>
<a name="ln383">  const dt_image_t *img = &amp;dev.image_storage;</a>
<a name="ln384"> </a>
<a name="ln385">  dt_dev_pixelpipe_t pipe;</a>
<a name="ln386">  int wd = img-&gt;width, ht = img-&gt;height;</a>
<a name="ln387">  int res = dt_dev_pixelpipe_init_dummy(&amp;pipe, wd, ht);</a>
<a name="ln388">  if(res)</a>
<a name="ln389">  {</a>
<a name="ln390">    // set mem pointer to 0, won't be used.</a>
<a name="ln391">    dt_dev_pixelpipe_set_input(&amp;pipe, &amp;dev, NULL, wd, ht, 1.0f);</a>
<a name="ln392">    dt_dev_pixelpipe_create_nodes(&amp;pipe, &amp;dev);</a>
<a name="ln393">    dt_dev_pixelpipe_synch_all(&amp;pipe, &amp;dev);</a>
<a name="ln394">    dt_dev_pixelpipe_get_dimensions(&amp;pipe, &amp;dev, pipe.iwidth, pipe.iheight, &amp;pipe.processed_width,</a>
<a name="ln395">                                    &amp;pipe.processed_height);</a>
<a name="ln396">    wd = pipe.processed_width;</a>
<a name="ln397">    ht = pipe.processed_height;</a>
<a name="ln398">    res = TRUE;</a>
<a name="ln399">    dt_dev_pixelpipe_cleanup(&amp;pipe);</a>
<a name="ln400">  }</a>
<a name="ln401">  dt_dev_cleanup(&amp;dev);</a>
<a name="ln402"> </a>
<a name="ln403">  *width = wd;</a>
<a name="ln404">  *height = ht;</a>
<a name="ln405">  return res;</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">void dt_image_set_flip(const int32_t imgid, const dt_image_orientation_t orientation)</a>
<a name="ln409">{</a>
<a name="ln410">  sqlite3_stmt *stmt;</a>
<a name="ln411">  // push new orientation to sql via additional history entry:</a>
<a name="ln412">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT IFNULL(MAX(num)+1, 0) FROM main.history &quot;</a>
<a name="ln413">                                                             &quot;WHERE imgid = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln414">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln415">  const int iop_flip_MODVER = 2;</a>
<a name="ln416">  int num = 0;</a>
<a name="ln417">  if(sqlite3_step(stmt) == SQLITE_ROW) num = sqlite3_column_int(stmt, 0);</a>
<a name="ln418"> </a>
<a name="ln419">  sqlite3_finalize(stmt);</a>
<a name="ln420">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln421">                              &quot;INSERT INTO main.history (imgid, num, module, operation, op_params, enabled, &quot;</a>
<a name="ln422">                              &quot;blendop_params, blendop_version, multi_priority, multi_name) VALUES &quot;</a>
<a name="ln423">                              &quot;(?1, ?2, ?3, 'flip', ?4, 1, NULL, 0, 0, '') &quot;,</a>
<a name="ln424">                              -1, &amp;stmt, NULL);</a>
<a name="ln425">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln426">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, num);</a>
<a name="ln427">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, iop_flip_MODVER);</a>
<a name="ln428">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 4, &amp;orientation, sizeof(int32_t), SQLITE_TRANSIENT);</a>
<a name="ln429">  sqlite3_step(stmt);</a>
<a name="ln430">  sqlite3_finalize(stmt);</a>
<a name="ln431"> </a>
<a name="ln432">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln433">                              &quot;UPDATE main.images SET history_end = (SELECT MAX(num) + 1 FROM main.history &quot;</a>
<a name="ln434">                              &quot;WHERE imgid = ?1) WHERE id = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln435">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln436">  sqlite3_step(stmt);</a>
<a name="ln437">  sqlite3_finalize(stmt);</a>
<a name="ln438"> </a>
<a name="ln439">  dt_mipmap_cache_remove(darktable.mipmap_cache, imgid);</a>
<a name="ln440">  // write that through to xmp:</a>
<a name="ln441">  dt_image_write_sidecar_file(imgid);</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">dt_image_orientation_t dt_image_get_orientation(const int imgid)</a>
<a name="ln445">{</a>
<a name="ln446">  // find the flip module -- the pointer stays valid until darktable shuts down</a>
<a name="ln447">  static dt_iop_module_so_t *flip = NULL;</a>
<a name="ln448">  if(flip == NULL)</a>
<a name="ln449">  {</a>
<a name="ln450">    GList *modules = g_list_first(darktable.iop);</a>
<a name="ln451">    while(modules)</a>
<a name="ln452">    {</a>
<a name="ln453">      dt_iop_module_so_t *module = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln454">      if(!strcmp(module-&gt;op, &quot;flip&quot;))</a>
<a name="ln455">      {</a>
<a name="ln456">        flip = module;</a>
<a name="ln457">        break;</a>
<a name="ln458">      }</a>
<a name="ln459">      modules = g_list_next(modules);</a>
<a name="ln460">    }</a>
<a name="ln461">  }</a>
<a name="ln462"> </a>
<a name="ln463">  dt_image_orientation_t orientation = ORIENTATION_NULL;</a>
<a name="ln464"> </a>
<a name="ln465">  // db lookup flip params</a>
<a name="ln466">  if(flip &amp;&amp; flip-&gt;get_p)</a>
<a name="ln467">  {</a>
<a name="ln468">    sqlite3_stmt *stmt;</a>
<a name="ln469">    DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln470">        dt_database_get(darktable.db),</a>
<a name="ln471">        &quot;SELECT op_params FROM main.history WHERE imgid=?1 AND operation='flip' ORDER BY num DESC LIMIT 1&quot;, -1,</a>
<a name="ln472">        &amp;stmt, NULL);</a>
<a name="ln473">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln474">    if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln475">    {</a>
<a name="ln476">      // use introspection to get the orientation from the binary params blob</a>
<a name="ln477">      const void *params = sqlite3_column_blob(stmt, 0);</a>
<a name="ln478">      orientation = *((dt_image_orientation_t *)flip-&gt;get_p(params, &quot;orientation&quot;));</a>
<a name="ln479">    }</a>
<a name="ln480">    sqlite3_finalize(stmt);</a>
<a name="ln481">  }</a>
<a name="ln482"> </a>
<a name="ln483">  if(orientation == ORIENTATION_NULL)</a>
<a name="ln484">  {</a>
<a name="ln485">    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln486">    orientation = dt_image_orientation(img);</a>
<a name="ln487">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln488">  }</a>
<a name="ln489"> </a>
<a name="ln490">  return orientation;</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">void dt_image_flip(const int32_t imgid, const int32_t cw)</a>
<a name="ln494">{</a>
<a name="ln495">  // this is light table only:</a>
<a name="ln496">  const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln497">  if(darktable.develop-&gt;image_storage.id == imgid &amp;&amp; cv-&gt;view((dt_view_t *)cv) == DT_VIEW_DARKROOM) return;</a>
<a name="ln498"> </a>
<a name="ln499">  dt_image_orientation_t orientation = dt_image_get_orientation(imgid);</a>
<a name="ln500"> </a>
<a name="ln501">  if(cw == 1)</a>
<a name="ln502">  {</a>
<a name="ln503">    if(orientation &amp; ORIENTATION_SWAP_XY)</a>
<a name="ln504">      orientation ^= ORIENTATION_FLIP_Y;</a>
<a name="ln505">    else</a>
<a name="ln506">      orientation ^= ORIENTATION_FLIP_X;</a>
<a name="ln507">  }</a>
<a name="ln508">  else</a>
<a name="ln509">  {</a>
<a name="ln510">    if(orientation &amp; ORIENTATION_SWAP_XY)</a>
<a name="ln511">      orientation ^= ORIENTATION_FLIP_X;</a>
<a name="ln512">    else</a>
<a name="ln513">      orientation ^= ORIENTATION_FLIP_Y;</a>
<a name="ln514">  }</a>
<a name="ln515">  orientation ^= ORIENTATION_SWAP_XY;</a>
<a name="ln516"> </a>
<a name="ln517">  if(cw == 2) orientation = ORIENTATION_NULL;</a>
<a name="ln518">  dt_image_set_flip(imgid, orientation);</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521">void dt_image_set_aspect_ratio_to(const int32_t imgid, double aspect_ratio)</a>
<a name="ln522">{</a>
<a name="ln523">  if (aspect_ratio &gt; .0f)</a>
<a name="ln524">  {</a>
<a name="ln525">    sqlite3_stmt *stmt;</a>
<a name="ln526"> </a>
<a name="ln527">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln528">                                &quot;UPDATE images SET aspect_ratio=ROUND(?1,1) WHERE id=?2&quot;,</a>
<a name="ln529">                                -1, &amp;stmt, NULL);</a>
<a name="ln530"> </a>
<a name="ln531">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 1, aspect_ratio);</a>
<a name="ln532">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln533">    sqlite3_step(stmt);</a>
<a name="ln534">    sqlite3_finalize(stmt);</a>
<a name="ln535"> </a>
<a name="ln536">    if (darktable.collection-&gt;params.sort == DT_COLLECTION_SORT_ASPECT_RATIO)</a>
<a name="ln537">      dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln538">  }</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">void dt_image_set_aspect_ratio(const int32_t imgid)</a>
<a name="ln542">{</a>
<a name="ln543">  dt_mipmap_buffer_t buf;</a>
<a name="ln544"> </a>
<a name="ln545">  // mipmap cache must be initialized, otherwise we'll update next call</a>
<a name="ln546">  if(darktable.mipmap_cache)</a>
<a name="ln547">  {</a>
<a name="ln548">    dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, DT_MIPMAP_0, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln549"> </a>
<a name="ln550">    if (buf.buf &amp;&amp; buf.height &amp;&amp; buf.width)</a>
<a name="ln551">    {</a>
<a name="ln552">      const double aspect_ratio = (double)buf.width / (double)buf.height;</a>
<a name="ln553">      dt_image_set_aspect_ratio_to(imgid, aspect_ratio);</a>
<a name="ln554">    }</a>
<a name="ln555"> </a>
<a name="ln556">    dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln557">  }</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">int32_t dt_image_duplicate(const int32_t imgid)</a>
<a name="ln561">{</a>
<a name="ln562">  return dt_image_duplicate_with_version(imgid, -1);</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565"> </a>
<a name="ln566">int32_t dt_image_duplicate_with_version(const int32_t imgid, const int32_t newversion)</a>
<a name="ln567">{</a>
<a name="ln568">  sqlite3_stmt *stmt;</a>
<a name="ln569">  int32_t newid = -1;</a>
<a name="ln570">  const int64_t image_position = dt_collection_get_image_position(imgid);</a>
<a name="ln571">  const int64_t new_image_position = (image_position &lt; 0) ? max_image_position() : image_position + 1;</a>
<a name="ln572"> </a>
<a name="ln573">  dt_collection_shift_image_positions(1, new_image_position);</a>
<a name="ln574"> </a>
<a name="ln575">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln576">                              &quot;SELECT a.id FROM main.images AS a JOIN main.images AS b WHERE &quot;</a>
<a name="ln577">                              &quot;a.film_id = b.film_id AND a.filename = b.filename AND &quot;</a>
<a name="ln578">                              &quot;b.id = ?1 AND a.version = ?2 ORDER BY a.id DESC&quot;,</a>
<a name="ln579">                              -1, &amp;stmt, NULL);</a>
<a name="ln580">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln581">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, newversion);</a>
<a name="ln582">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln583">  {</a>
<a name="ln584">    newid = sqlite3_column_int(stmt, 0);</a>
<a name="ln585">  }</a>
<a name="ln586">  sqlite3_finalize(stmt);</a>
<a name="ln587"> </a>
<a name="ln588">  // requested version is already present in DB, so we just return it</a>
<a name="ln589">  if(newid != -1) return newid;</a>
<a name="ln590"> </a>
<a name="ln591">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln592">      dt_database_get(darktable.db),</a>
<a name="ln593">      &quot;INSERT INTO main.images &quot;</a>
<a name="ln594">      &quot;(id, group_id, film_id, width, height, filename, maker, model, lens, exposure, &quot;</a>
<a name="ln595">      &quot;aperture, iso, focal_length, focus_distance, datetime_taken, flags, &quot;</a>
<a name="ln596">      &quot;output_width, output_height, crop, raw_parameters, raw_denoise_threshold, &quot;</a>
<a name="ln597">      &quot;raw_auto_bright_threshold, raw_black, raw_maximum, &quot;</a>
<a name="ln598">      &quot;caption, description, license, sha1sum, orientation, histogram, lightmap, &quot;</a>
<a name="ln599">      &quot;longitude, latitude, altitude, color_matrix, colorspace, version, max_version, history_end, &quot;</a>
<a name="ln600">      &quot;position, aspect_ratio) &quot;</a>
<a name="ln601">      &quot;SELECT NULL, group_id, film_id, width, height, filename, maker, model, lens, &quot;</a>
<a name="ln602">      &quot;exposure, aperture, iso, focal_length, focus_distance, datetime_taken, &quot;</a>
<a name="ln603">      &quot;flags, width, height, crop, raw_parameters, raw_denoise_threshold, &quot;</a>
<a name="ln604">      &quot;raw_auto_bright_threshold, raw_black, raw_maximum, &quot;</a>
<a name="ln605">      &quot;caption, description, license, sha1sum, orientation, histogram, lightmap, &quot;</a>
<a name="ln606">      &quot;longitude, latitude, altitude, color_matrix, colorspace, NULL, NULL, 0, ?1, aspect_ratio &quot;</a>
<a name="ln607">      &quot;FROM main.images WHERE id = ?2&quot;,</a>
<a name="ln608">      -1, &amp;stmt, NULL);</a>
<a name="ln609">  DT_DEBUG_SQLITE3_BIND_INT64(stmt, 1, new_image_position);</a>
<a name="ln610">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln611">  sqlite3_step(stmt);</a>
<a name="ln612">  sqlite3_finalize(stmt);</a>
<a name="ln613">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln614">      dt_database_get(darktable.db),</a>
<a name="ln615">      &quot;SELECT a.id, a.film_id, a.filename, b.max_version FROM main.images AS a JOIN main.images AS b WHERE &quot;</a>
<a name="ln616">      &quot;a.film_id = b.film_id AND a.filename = b.filename AND &quot;</a>
<a name="ln617">      &quot;b.id = ?1 ORDER BY a.id DESC&quot;,</a>
<a name="ln618">      -1, &amp;stmt, NULL);</a>
<a name="ln619">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln620"> </a>
<a name="ln621">  int32_t film_id = 1;</a>
<a name="ln622">  int32_t max_version = -1;</a>
<a name="ln623">  gchar *filename = NULL;</a>
<a name="ln624">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln625">  {</a>
<a name="ln626">    newid = sqlite3_column_int(stmt, 0);</a>
<a name="ln627">    film_id = sqlite3_column_int(stmt, 1);</a>
<a name="ln628">    filename = g_strdup((gchar *)sqlite3_column_text(stmt, 2));</a>
<a name="ln629">    max_version = sqlite3_column_int(stmt, 3);</a>
<a name="ln630">  }</a>
<a name="ln631">  sqlite3_finalize(stmt);</a>
<a name="ln632"> </a>
<a name="ln633">  if(newid != -1)</a>
<a name="ln634">  {</a>
<a name="ln635">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln636">                                &quot;INSERT INTO main.color_labels (imgid, color) SELECT ?1, color FROM &quot;</a>
<a name="ln637">                                &quot;main.color_labels WHERE imgid = ?2&quot;,</a>
<a name="ln638">                                -1, &amp;stmt, NULL);</a>
<a name="ln639">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, newid);</a>
<a name="ln640">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln641">    sqlite3_step(stmt);</a>
<a name="ln642">    sqlite3_finalize(stmt);</a>
<a name="ln643">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln644">                                &quot;INSERT INTO main.meta_data (id, key, value) SELECT ?1, key, value &quot;</a>
<a name="ln645">                                &quot;FROM main.meta_data WHERE id = ?2&quot;,</a>
<a name="ln646">                                -1, &amp;stmt, NULL);</a>
<a name="ln647">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, newid);</a>
<a name="ln648">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln649">    sqlite3_step(stmt);</a>
<a name="ln650">    sqlite3_finalize(stmt);</a>
<a name="ln651">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln652">                                &quot;INSERT INTO main.tagged_images (imgid, tagid) SELECT ?1, tagid FROM &quot;</a>
<a name="ln653">                                &quot;main.tagged_images WHERE imgid = ?2&quot;,</a>
<a name="ln654">                                -1, &amp;stmt, NULL);</a>
<a name="ln655">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, newid);</a>
<a name="ln656">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln657">    sqlite3_step(stmt);</a>
<a name="ln658">    sqlite3_finalize(stmt);</a>
<a name="ln659"> </a>
<a name="ln660">    // make sure that the duplicate doesn't have some magic darktable| tags</a>
<a name="ln661">    dt_tag_detach_by_string(&quot;darktable|changed&quot;, newid);</a>
<a name="ln662">    dt_tag_detach_by_string(&quot;darktable|exported&quot;, newid);</a>
<a name="ln663"> </a>
<a name="ln664">    // set version of new entry and max_version of all involved duplicates (with same film_id and filename)</a>
<a name="ln665">    int32_t version = (newversion != -1) ? newversion : max_version + 1;</a>
<a name="ln666">    max_version = (newversion != -1) ? MAX(max_version, newversion) : max_version + 1;</a>
<a name="ln667"> </a>
<a name="ln668">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;UPDATE main.images SET version=?1 WHERE id = ?2&quot;,</a>
<a name="ln669">                                -1, &amp;stmt, NULL);</a>
<a name="ln670">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, version);</a>
<a name="ln671">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, newid);</a>
<a name="ln672">    sqlite3_step(stmt);</a>
<a name="ln673">    sqlite3_finalize(stmt);</a>
<a name="ln674"> </a>
<a name="ln675">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln676">                                &quot;UPDATE main.images SET max_version=?1 WHERE film_id = ?2 AND filename = ?3&quot;, -1,</a>
<a name="ln677">                                &amp;stmt, NULL);</a>
<a name="ln678">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, max_version);</a>
<a name="ln679">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, film_id);</a>
<a name="ln680">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 3, filename, -1, SQLITE_TRANSIENT);</a>
<a name="ln681">    sqlite3_step(stmt);</a>
<a name="ln682">    sqlite3_finalize(stmt);</a>
<a name="ln683"> </a>
<a name="ln684">    g_free(filename);</a>
<a name="ln685"> </a>
<a name="ln686">    if(darktable.gui &amp;&amp; darktable.gui-&gt;grouping)</a>
<a name="ln687">    {</a>
<a name="ln688">      const dt_image_t *img = dt_image_cache_get(darktable.image_cache, newid, 'r');</a>
<a name="ln689">      darktable.gui-&gt;expanded_group_id = img-&gt;group_id;</a>
<a name="ln690">      dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln691">    }</a>
<a name="ln692">    dt_collection_update_query(darktable.collection);</a>
<a name="ln693">  }</a>
<a name="ln694">  return newid;</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">void dt_image_remove(const int32_t imgid)</a>
<a name="ln698">{</a>
<a name="ln699">  // if a local copy exists, remove it</a>
<a name="ln700"> </a>
<a name="ln701">  if(dt_image_local_copy_reset(imgid)) return;</a>
<a name="ln702"> </a>
<a name="ln703">  sqlite3_stmt *stmt;</a>
<a name="ln704">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln705">  int old_group_id = img-&gt;group_id;</a>
<a name="ln706">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln707"> </a>
<a name="ln708">  // make sure we remove from the cache first, or else the cache will look for imgid in sql</a>
<a name="ln709">  dt_image_cache_remove(darktable.image_cache, imgid);</a>
<a name="ln710"> </a>
<a name="ln711">  int new_group_id = dt_grouping_remove_from_group(imgid);</a>
<a name="ln712">  if(darktable.gui &amp;&amp; darktable.gui-&gt;expanded_group_id == old_group_id)</a>
<a name="ln713">    darktable.gui-&gt;expanded_group_id = new_group_id;</a>
<a name="ln714"> </a>
<a name="ln715">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.images WHERE id = ?1&quot;, -1, &amp;stmt,</a>
<a name="ln716">                              NULL);</a>
<a name="ln717">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln718">  sqlite3_step(stmt);</a>
<a name="ln719">  sqlite3_finalize(stmt);</a>
<a name="ln720">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.tagged_images WHERE imgid = ?1&quot;, -1,</a>
<a name="ln721">                              &amp;stmt, NULL);</a>
<a name="ln722">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln723">  sqlite3_step(stmt);</a>
<a name="ln724">  sqlite3_finalize(stmt);</a>
<a name="ln725">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln726">                              &amp;stmt, NULL);</a>
<a name="ln727">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln728">  sqlite3_step(stmt);</a>
<a name="ln729">  sqlite3_finalize(stmt);</a>
<a name="ln730">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.color_labels WHERE imgid = ?1&quot;, -1,</a>
<a name="ln731">                              &amp;stmt, NULL);</a>
<a name="ln732">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln733">  sqlite3_step(stmt);</a>
<a name="ln734">  sqlite3_finalize(stmt);</a>
<a name="ln735">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.meta_data WHERE id = ?1&quot;, -1, &amp;stmt,</a>
<a name="ln736">                              NULL);</a>
<a name="ln737">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln738">  sqlite3_step(stmt);</a>
<a name="ln739">  sqlite3_finalize(stmt);</a>
<a name="ln740">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images WHERE imgid = ?1&quot;,</a>
<a name="ln741">                              -1, &amp;stmt, NULL);</a>
<a name="ln742">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln743">  sqlite3_step(stmt);</a>
<a name="ln744">  sqlite3_finalize(stmt);</a>
<a name="ln745">  // also clear all thumbnails in mipmap_cache.</a>
<a name="ln746">  dt_mipmap_cache_remove(darktable.mipmap_cache, imgid);</a>
<a name="ln747"> </a>
<a name="ln748">  dt_tag_update_used_tags();</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">int dt_image_altered(const uint32_t imgid)</a>
<a name="ln752">{</a>
<a name="ln753">  int altered = 0;</a>
<a name="ln754">  sqlite3_stmt *stmt;</a>
<a name="ln755"> </a>
<a name="ln756">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT operation FROM main.history WHERE imgid = ?1&quot;,</a>
<a name="ln757">                              -1, &amp;stmt, NULL);</a>
<a name="ln758">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln759">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln760">  {</a>
<a name="ln761">    const char *op = (const char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln762">    // FIXME: this is clearly a terrible way to determine which modules</a>
<a name="ln763">    // are okay to still load the thumbnail and which aren't.</a>
<a name="ln764">    // (that's currently the only use of this function)</a>
<a name="ln765">    if(!op) continue; // can happen while importing or something like that</a>
<a name="ln766">    if(!strcmp(op, &quot;basecurve&quot;)) continue;</a>
<a name="ln767">    if(!strcmp(op, &quot;flip&quot;)) continue;</a>
<a name="ln768">    if(!strcmp(op, &quot;sharpen&quot;)) continue;</a>
<a name="ln769">    if(!strcmp(op, &quot;dither&quot;)) continue;</a>
<a name="ln770">    if(!strcmp(op, &quot;highlights&quot;)) continue;</a>
<a name="ln771">    altered = 1;</a>
<a name="ln772">    break;</a>
<a name="ln773">  }</a>
<a name="ln774">  sqlite3_finalize(stmt);</a>
<a name="ln775"> </a>
<a name="ln776">  return altered;</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779"> </a>
<a name="ln780">void dt_image_read_duplicates(const uint32_t id, const char *filename)</a>
<a name="ln781">{</a>
<a name="ln782">  // Search for duplicate's sidecar files and import them if found and not in DB yet</a>
<a name="ln783">  gchar *imgfname = g_path_get_basename(filename);</a>
<a name="ln784">  gchar *imgpath = g_path_get_dirname(filename);</a>
<a name="ln785">  gchar pattern[PATH_MAX] = { 0 };</a>
<a name="ln786"> </a>
<a name="ln787">  // NULL terminated list of glob patterns; should include &quot;&quot; and can be extended if needed</a>
<a name="ln788">  static const gchar *glob_patterns[]</a>
<a name="ln789">      = { &quot;&quot;, &quot;_[0-9][0-9]&quot;, &quot;_[0-9][0-9][0-9]&quot;, &quot;_[0-9][0-9][0-9][0-9]&quot;, NULL };</a>
<a name="ln790"> </a>
<a name="ln791">  const gchar **glob_pattern = glob_patterns;</a>
<a name="ln792">  GList *files = NULL;</a>
<a name="ln793">  while(*glob_pattern)</a>
<a name="ln794">  {</a>
<a name="ln795">    snprintf(pattern, sizeof(pattern), &quot;%s&quot;, filename);</a>
<a name="ln796">    gchar *c1 = pattern + strlen(pattern);</a>
<a name="ln797">    while(*c1 != '.' &amp;&amp; c1 &gt; pattern) c1--;</a>
<a name="ln798">    snprintf(c1, pattern + sizeof(pattern) - c1, &quot;%s&quot;, *glob_pattern);</a>
<a name="ln799">    const gchar *c2 = filename + strlen(filename);</a>
<a name="ln800">    while(*c2 != '.' &amp;&amp; c2 &gt; filename) c2--;</a>
<a name="ln801">    snprintf(c1 + strlen(*glob_pattern), pattern + sizeof(pattern) - c1 - strlen(*glob_pattern), &quot;%s.xmp&quot;, c2);</a>
<a name="ln802"> </a>
<a name="ln803">#ifdef _WIN32</a>
<a name="ln804">    wchar_t *wpattern = g_utf8_to_utf16(pattern, -1, NULL, NULL, NULL);</a>
<a name="ln805">    WIN32_FIND_DATAW data;</a>
<a name="ln806">    HANDLE handle = FindFirstFileW(wpattern, &amp;data);</a>
<a name="ln807">    g_free(wpattern);</a>
<a name="ln808">    if(handle != INVALID_HANDLE_VALUE)</a>
<a name="ln809">    {</a>
<a name="ln810">      do</a>
<a name="ln811">      {</a>
<a name="ln812">        char *file = g_utf16_to_utf8(data.cFileName, -1, NULL, NULL, NULL);</a>
<a name="ln813">        files = g_list_append(files, g_build_filename(imgpath, file, NULL));</a>
<a name="ln814">        g_free(file);</a>
<a name="ln815">      }</a>
<a name="ln816">      while(FindNextFileW(handle, &amp;data));</a>
<a name="ln817">    }</a>
<a name="ln818">    FindClose(handle);</a>
<a name="ln819">#else</a>
<a name="ln820">    glob_t globbuf;</a>
<a name="ln821">    if(!glob(pattern, 0, NULL, &amp;globbuf))</a>
<a name="ln822">    {</a>
<a name="ln823">      for(size_t i = 0; i &lt; globbuf.gl_pathc; i++)</a>
<a name="ln824">        files = g_list_append(files, g_strdup(globbuf.gl_pathv[i]));</a>
<a name="ln825">      globfree(&amp;globbuf);</a>
<a name="ln826">    }</a>
<a name="ln827">#endif</a>
<a name="ln828"> </a>
<a name="ln829">    glob_pattern++;</a>
<a name="ln830">  }</a>
<a name="ln831"> </a>
<a name="ln832">  // we store the xmp filename without version part in pattern to speed up string comparison later</a>
<a name="ln833">  g_snprintf(pattern, sizeof(pattern), &quot;%s.xmp&quot;, filename);</a>
<a name="ln834"> </a>
<a name="ln835">  GList *file_iter = g_list_first(files);</a>
<a name="ln836">  while(file_iter != NULL)</a>
<a name="ln837">  {</a>
<a name="ln838">    gchar *xmpfilename = file_iter-&gt;data;</a>
<a name="ln839">    int version = -1;</a>
<a name="ln840"> </a>
<a name="ln841">    // we need to get the version number of the sidecar filename</a>
<a name="ln842">    if(!strncmp(xmpfilename, pattern, sizeof(pattern)))</a>
<a name="ln843">    {</a>
<a name="ln844">      // this is an xmp file without version number which corresponds to version 0</a>
<a name="ln845">      version = 0;</a>
<a name="ln846">    }</a>
<a name="ln847">    else</a>
<a name="ln848">    {</a>
<a name="ln849">      // we need to derive the version number from the filename</a>
<a name="ln850"> </a>
<a name="ln851">      gchar *c3 = xmpfilename + strlen(xmpfilename)</a>
<a name="ln852">                  - 5; // skip over .xmp extension; position c3 at character before the '.'</a>
<a name="ln853">      while(*c3 != '.' &amp;&amp; c3 &gt; xmpfilename)</a>
<a name="ln854">        c3--; // skip over filename extension; position c3 is at character '.'</a>
<a name="ln855">      gchar *c4 = c3;</a>
<a name="ln856">      while(*c4 != '_' &amp;&amp; c4 &gt; xmpfilename) c4--; // move to beginning of version number</a>
<a name="ln857">      c4++;</a>
<a name="ln858"> </a>
<a name="ln859">      gchar *idfield = g_strndup(c4, c3 - c4);</a>
<a name="ln860"> </a>
<a name="ln861">      version = atoi(idfield);</a>
<a name="ln862">      g_free(idfield);</a>
<a name="ln863">    }</a>
<a name="ln864"> </a>
<a name="ln865">    int newid = dt_image_duplicate_with_version(id, version);</a>
<a name="ln866">    dt_image_t *img = dt_image_cache_get(darktable.image_cache, newid, 'w');</a>
<a name="ln867">    (void)dt_exif_xmp_read(img, xmpfilename, 0);</a>
<a name="ln868">    dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln869"> </a>
<a name="ln870">    file_iter = g_list_next(file_iter);</a>
<a name="ln871">  }</a>
<a name="ln872"> </a>
<a name="ln873">  g_list_free_full(files, g_free);</a>
<a name="ln874">  g_free(imgfname);</a>
<a name="ln875">  g_free(imgpath);</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878"> </a>
<a name="ln879">static uint32_t dt_image_import_internal(const int32_t film_id, const char *filename, gboolean override_ignore_jpegs, gboolean lua_locking)</a>
<a name="ln880">{</a>
<a name="ln881">  char *normalized_filename = dt_util_normalize_path(filename);</a>
<a name="ln882">  if(!normalized_filename || !g_file_test(normalized_filename, G_FILE_TEST_IS_REGULAR) || dt_util_get_file_size(normalized_filename) == 0)</a>
<a name="ln883">  {</a>
<a name="ln884">    g_free(normalized_filename);</a>
<a name="ln885">    return 0;</a>
<a name="ln886">  }</a>
<a name="ln887">  const char *cc = normalized_filename + strlen(normalized_filename);</a>
<a name="ln888">  for(; *cc != '.' &amp;&amp; cc &gt; normalized_filename; cc--)</a>
<a name="ln889">    ;</a>
<a name="ln890">  if(!strcasecmp(cc, &quot;.dt&quot;) || !strcasecmp(cc, &quot;.dttags&quot;) || !strcasecmp(cc, &quot;.xmp&quot;))</a>
<a name="ln891">  {</a>
<a name="ln892">    g_free(normalized_filename);</a>
<a name="ln893">    return 0;</a>
<a name="ln894">  }</a>
<a name="ln895">  char *ext = g_ascii_strdown(cc + 1, -1);</a>
<a name="ln896">  if(override_ignore_jpegs == FALSE &amp;&amp; (!strcmp(ext, &quot;jpg&quot;) || !strcmp(ext, &quot;jpeg&quot;))</a>
<a name="ln897">     &amp;&amp; dt_conf_get_bool(&quot;ui_last/import_ignore_jpegs&quot;))</a>
<a name="ln898">  {</a>
<a name="ln899">    g_free(normalized_filename);</a>
<a name="ln900">    g_free(ext);</a>
<a name="ln901">    return 0;</a>
<a name="ln902">  }</a>
<a name="ln903">  int supported = 0;</a>
<a name="ln904">  for(const char **i = dt_supported_extensions; *i != NULL; i++)</a>
<a name="ln905">    if(!strcmp(ext, *i))</a>
<a name="ln906">    {</a>
<a name="ln907">      supported = 1;</a>
<a name="ln908">      break;</a>
<a name="ln909">    }</a>
<a name="ln910">  if(!supported)</a>
<a name="ln911">  {</a>
<a name="ln912">    g_free(normalized_filename);</a>
<a name="ln913">    g_free(ext);</a>
<a name="ln914">    return 0;</a>
<a name="ln915">  }</a>
<a name="ln916">  int rc;</a>
<a name="ln917">  uint32_t id = 0;</a>
<a name="ln918">  // select from images; if found =&gt; return</a>
<a name="ln919">  gchar *imgfname;</a>
<a name="ln920">  imgfname = g_path_get_basename(normalized_filename);</a>
<a name="ln921">  sqlite3_stmt *stmt;</a>
<a name="ln922">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln923">                              &quot;SELECT id FROM main.images WHERE film_id = ?1 AND filename = ?2&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln924">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, film_id);</a>
<a name="ln925">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgfname, -1, SQLITE_STATIC);</a>
<a name="ln926">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln927">  {</a>
<a name="ln928">    id = sqlite3_column_int(stmt, 0);</a>
<a name="ln929">    g_free(imgfname);</a>
<a name="ln930">    sqlite3_finalize(stmt);</a>
<a name="ln931">    dt_image_t *img = dt_image_cache_get(darktable.image_cache, id, 'w');</a>
<a name="ln932">    img-&gt;flags &amp;= ~DT_IMAGE_REMOVE;</a>
<a name="ln933">    dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln934">    dt_image_read_duplicates(id, normalized_filename);</a>
<a name="ln935">    dt_image_synch_all_xmp(normalized_filename);</a>
<a name="ln936">    g_free(ext);</a>
<a name="ln937">    g_free(normalized_filename);</a>
<a name="ln938">    return id;</a>
<a name="ln939">  }</a>
<a name="ln940">  sqlite3_finalize(stmt);</a>
<a name="ln941"> </a>
<a name="ln942">  // also need to set the no-legacy bit, to make sure we get the right presets (new ones)</a>
<a name="ln943">  uint32_t flags = dt_conf_get_int(&quot;ui_last/import_initial_rating&quot;);</a>
<a name="ln944">  if(flags &gt; 5)</a>
<a name="ln945">  {</a>
<a name="ln946">    flags = 1;</a>
<a name="ln947">    dt_conf_set_int(&quot;ui_last/import_initial_rating&quot;, 1);</a>
<a name="ln948">  }</a>
<a name="ln949">  flags |= DT_IMAGE_NO_LEGACY_PRESETS;</a>
<a name="ln950">  // set the bits in flags that indicate if any of the extra files (.txt, .wav) are present</a>
<a name="ln951">  char *extra_file = dt_image_get_audio_path_from_path(normalized_filename);</a>
<a name="ln952">  if(extra_file)</a>
<a name="ln953">  {</a>
<a name="ln954">    flags |= DT_IMAGE_HAS_WAV;</a>
<a name="ln955">    g_free(extra_file);</a>
<a name="ln956">  }</a>
<a name="ln957">  extra_file = dt_image_get_text_path_from_path(normalized_filename);</a>
<a name="ln958">  if(extra_file)</a>
<a name="ln959">  {</a>
<a name="ln960">    flags |= DT_IMAGE_HAS_TXT;</a>
<a name="ln961">    g_free(extra_file);</a>
<a name="ln962">  }</a>
<a name="ln963"> </a>
<a name="ln964">  // insert dummy image entry in database</a>
<a name="ln965"> </a>
<a name="ln966">  /* Image Position Calulation</a>
<a name="ln967">   *</a>
<a name="ln968">   * The upper int32_t of the last image position is increased by one</a>
<a name="ln969">   * while the lower 32 bits are masked out.</a>
<a name="ln970">   *</a>
<a name="ln971">   * Example:</a>
<a name="ln972">   * last image position: (Hex)</a>
<a name="ln973">   * 0000 0002 0000 0001</a>
<a name="ln974">   *</a>
<a name="ln975">   * next image position</a>
<a name="ln976">   * 0000 0003 0000 0000</a>
<a name="ln977">   */</a>
<a name="ln978">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln979">      dt_database_get(darktable.db),</a>
<a name="ln980">      &quot;INSERT INTO main.images (id, film_id, filename, caption, description, license, sha1sum, flags, version, &quot;</a>
<a name="ln981">      &quot;max_version, history_end, position) &quot;</a>
<a name="ln982">      &quot;SELECT NULL, ?1, ?2, '', '', '', '', ?3, 0, 0, 0, (IFNULL(MAX(position),0) &amp; (4294967295 &lt;&lt; 32))  + (1 &lt;&lt; 32) &quot;</a>
<a name="ln983">      &quot;FROM images&quot;,</a>
<a name="ln984">      -1, &amp;stmt, NULL);</a>
<a name="ln985"> </a>
<a name="ln986">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, film_id);</a>
<a name="ln987">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgfname, -1, SQLITE_TRANSIENT);</a>
<a name="ln988">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, flags);</a>
<a name="ln989"> </a>
<a name="ln990">  rc = sqlite3_step(stmt);</a>
<a name="ln991">  if(rc != SQLITE_DONE) fprintf(stderr, &quot;sqlite3 error %d\n&quot;, rc);</a>
<a name="ln992">  sqlite3_finalize(stmt);</a>
<a name="ln993"> </a>
<a name="ln994">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln995">                              &quot;SELECT id FROM main.images WHERE film_id = ?1 AND filename = ?2&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln996">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, film_id);</a>
<a name="ln997">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgfname, -1, SQLITE_STATIC);</a>
<a name="ln998">  if(sqlite3_step(stmt) == SQLITE_ROW) id = sqlite3_column_int(stmt, 0);</a>
<a name="ln999">  sqlite3_finalize(stmt);</a>
<a name="ln1000"> </a>
<a name="ln1001">  // Try to find out if this should be grouped already.</a>
<a name="ln1002">  gchar *basename = g_strdup(imgfname);</a>
<a name="ln1003">  gchar *cc2 = basename + strlen(basename);</a>
<a name="ln1004">  for(; *cc2 != '.' &amp;&amp; cc2 &gt; basename; cc2--)</a>
<a name="ln1005">    ;</a>
<a name="ln1006">  *cc2 = '\0';</a>
<a name="ln1007">  gchar *sql_pattern = g_strconcat(basename, &quot;.%&quot;, NULL);</a>
<a name="ln1008">  int group_id;</a>
<a name="ln1009">  // in case we are not a jpg check if we need to change group representative</a>
<a name="ln1010">  if(strcmp(ext, &quot;jpg&quot;) != 0 &amp;&amp; strcmp(ext, &quot;jpeg&quot;) != 0)</a>
<a name="ln1011">  {</a>
<a name="ln1012">    sqlite3_stmt *stmt2;</a>
<a name="ln1013">    DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln1014">        dt_database_get(darktable.db),</a>
<a name="ln1015">        &quot;SELECT group_id FROM main.images WHERE film_id = ?1 AND filename LIKE ?2 AND id = group_id&quot;, -1, &amp;stmt2,</a>
<a name="ln1016">        NULL);</a>
<a name="ln1017">    DT_DEBUG_SQLITE3_BIND_INT(stmt2, 1, film_id);</a>
<a name="ln1018">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt2, 2, sql_pattern, -1, SQLITE_TRANSIENT);</a>
<a name="ln1019">    // if we have a group already</a>
<a name="ln1020">    if(sqlite3_step(stmt2) == SQLITE_ROW)</a>
<a name="ln1021">    {</a>
<a name="ln1022">      int other_id = sqlite3_column_int(stmt2, 0);</a>
<a name="ln1023">      dt_image_t *other_img = dt_image_cache_get(darktable.image_cache, other_id, 'w');</a>
<a name="ln1024">      gchar *other_basename = g_strdup(other_img-&gt;filename);</a>
<a name="ln1025">      gchar *cc3 = other_basename + strlen(other_img-&gt;filename);</a>
<a name="ln1026">      for(; *cc3 != '.' &amp;&amp; cc3 &gt; other_basename; cc3--)</a>
<a name="ln1027">        ;</a>
<a name="ln1028">      ++cc3;</a>
<a name="ln1029">      gchar *ext_lowercase = g_ascii_strdown(cc3, -1);</a>
<a name="ln1030">      // if the group representative is a jpg, change group representative to this new imported image</a>
<a name="ln1031">      if(!strcmp(ext_lowercase, &quot;jpg&quot;) || !strcmp(ext_lowercase, &quot;jpeg&quot;))</a>
<a name="ln1032">      {</a>
<a name="ln1033">        other_img-&gt;group_id = id;</a>
<a name="ln1034">        dt_image_cache_write_release(darktable.image_cache, other_img, DT_IMAGE_CACHE_SAFE);</a>
<a name="ln1035">        sqlite3_stmt *stmt3;</a>
<a name="ln1036">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1037">                                    &quot;SELECT id FROM main.images WHERE group_id = ?1 AND id != ?1&quot;, -1, &amp;stmt3,</a>
<a name="ln1038">                                    NULL);</a>
<a name="ln1039">        DT_DEBUG_SQLITE3_BIND_INT(stmt3, 1, other_id);</a>
<a name="ln1040">        while(sqlite3_step(stmt3) == SQLITE_ROW)</a>
<a name="ln1041">        {</a>
<a name="ln1042">          other_id = sqlite3_column_int(stmt3, 0);</a>
<a name="ln1043">          dt_image_t *group_img = dt_image_cache_get(darktable.image_cache, other_id, 'w');</a>
<a name="ln1044">          group_img-&gt;group_id = id;</a>
<a name="ln1045">          dt_image_cache_write_release(darktable.image_cache, group_img, DT_IMAGE_CACHE_SAFE);</a>
<a name="ln1046">        }</a>
<a name="ln1047">        group_id = id;</a>
<a name="ln1048">        sqlite3_finalize(stmt3);</a>
<a name="ln1049">      }</a>
<a name="ln1050">      else</a>
<a name="ln1051">      {</a>
<a name="ln1052">        dt_image_cache_write_release(darktable.image_cache, other_img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln1053">        group_id = other_id;</a>
<a name="ln1054">      }</a>
<a name="ln1055">      g_free(ext_lowercase);</a>
<a name="ln1056">      g_free(other_basename);</a>
<a name="ln1057">    }</a>
<a name="ln1058">    else</a>
<a name="ln1059">    {</a>
<a name="ln1060">      group_id = id;</a>
<a name="ln1061">    }</a>
<a name="ln1062">    sqlite3_finalize(stmt2);</a>
<a name="ln1063">  }</a>
<a name="ln1064">  else</a>
<a name="ln1065">  {</a>
<a name="ln1066">    sqlite3_stmt *stmt2;</a>
<a name="ln1067">    DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln1068">        dt_database_get(darktable.db),</a>
<a name="ln1069">        &quot;SELECT group_id FROM main.images WHERE film_id = ?1 AND filename LIKE ?2 AND id != ?3&quot;, -1, &amp;stmt2, NULL);</a>
<a name="ln1070">    DT_DEBUG_SQLITE3_BIND_INT(stmt2, 1, film_id);</a>
<a name="ln1071">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt2, 2, sql_pattern, -1, SQLITE_TRANSIENT);</a>
<a name="ln1072">    DT_DEBUG_SQLITE3_BIND_INT(stmt2, 3, id);</a>
<a name="ln1073">    if(sqlite3_step(stmt2) == SQLITE_ROW)</a>
<a name="ln1074">      group_id = sqlite3_column_int(stmt2, 0);</a>
<a name="ln1075">    else</a>
<a name="ln1076">      group_id = id;</a>
<a name="ln1077">    sqlite3_finalize(stmt2);</a>
<a name="ln1078">  }</a>
<a name="ln1079">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;UPDATE main.images SET group_id = ?1 WHERE id = ?2&quot;,</a>
<a name="ln1080">                              -1, &amp;stmt, NULL);</a>
<a name="ln1081">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, group_id);</a>
<a name="ln1082">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, id);</a>
<a name="ln1083">  sqlite3_step(stmt);</a>
<a name="ln1084">  sqlite3_finalize(stmt);</a>
<a name="ln1085"> </a>
<a name="ln1086">  // printf(&quot;[image_import] importing `%s' to img id %d\n&quot;, imgfname, id);</a>
<a name="ln1087"> </a>
<a name="ln1088">  // lock as shortly as possible:</a>
<a name="ln1089">  dt_image_t *img = dt_image_cache_get(darktable.image_cache, id, 'w');</a>
<a name="ln1090">  img-&gt;group_id = group_id;</a>
<a name="ln1091"> </a>
<a name="ln1092">  // read dttags and exif for database queries!</a>
<a name="ln1093">  (void)dt_exif_read(img, normalized_filename);</a>
<a name="ln1094">  char dtfilename[PATH_MAX] = { 0 };</a>
<a name="ln1095">  g_strlcpy(dtfilename, normalized_filename, sizeof(dtfilename));</a>
<a name="ln1096">  // dt_image_path_append_version(id, dtfilename, sizeof(dtfilename));</a>
<a name="ln1097">  g_strlcat(dtfilename, &quot;.xmp&quot;, sizeof(dtfilename));</a>
<a name="ln1098"> </a>
<a name="ln1099">  int res = dt_exif_xmp_read(img, dtfilename, 0);</a>
<a name="ln1100"> </a>
<a name="ln1101">  // write through to db, but not to xmp.</a>
<a name="ln1102">  dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln1103"> </a>
<a name="ln1104">  if(res != 0)</a>
<a name="ln1105">  {</a>
<a name="ln1106">    // Search for Lightroom sidecar file, import tags if found</a>
<a name="ln1107">    dt_lightroom_import(id, NULL, TRUE);</a>
<a name="ln1108">  }</a>
<a name="ln1109"> </a>
<a name="ln1110">  // add a tag with the file extension</a>
<a name="ln1111">  guint tagid = 0;</a>
<a name="ln1112">  char tagname[512];</a>
<a name="ln1113">  snprintf(tagname, sizeof(tagname), &quot;darktable|format|%s&quot;, ext);</a>
<a name="ln1114">  g_free(ext);</a>
<a name="ln1115">  dt_tag_new(tagname, &amp;tagid);</a>
<a name="ln1116">  dt_tag_attach(tagid, id);</a>
<a name="ln1117"> </a>
<a name="ln1118">  // make sure that there are no stale thumbnails left</a>
<a name="ln1119">  dt_mipmap_cache_remove(darktable.mipmap_cache, id);</a>
<a name="ln1120"> </a>
<a name="ln1121">  // read all sidecar files</a>
<a name="ln1122">  dt_image_read_duplicates(id, normalized_filename);</a>
<a name="ln1123">  dt_image_synch_all_xmp(normalized_filename);</a>
<a name="ln1124"> </a>
<a name="ln1125">  g_free(imgfname);</a>
<a name="ln1126">  g_free(basename);</a>
<a name="ln1127">  g_free(sql_pattern);</a>
<a name="ln1128">  g_free(normalized_filename);</a>
<a name="ln1129"> </a>
<a name="ln1130">#ifdef USE_LUA</a>
<a name="ln1131">  //Synchronous calling of lua post-import-image events</a>
<a name="ln1132">  if(lua_locking)</a>
<a name="ln1133">    dt_lua_lock();</a>
<a name="ln1134"> </a>
<a name="ln1135">  lua_State *L = darktable.lua_state.state;</a>
<a name="ln1136"> </a>
<a name="ln1137">  luaA_push(L, dt_lua_image_t, &amp;id);</a>
<a name="ln1138">  dt_lua_event_trigger(L, &quot;post-import-image&quot;, 1);</a>
<a name="ln1139"> </a>
<a name="ln1140">  if(lua_locking)</a>
<a name="ln1141">    dt_lua_unlock();</a>
<a name="ln1142">#endif</a>
<a name="ln1143"> </a>
<a name="ln1144">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_IMAGE_IMPORT, id);</a>
<a name="ln1145">  // the following line would look logical with new_tags_set being the return value</a>
<a name="ln1146">  // from dt_tag_new above, but this could lead to too rapid signals, being able to lock up the</a>
<a name="ln1147">  // keywords side pane when trying to use it, which can lock up the whole dt GUI ..</a>
<a name="ln1148">  // if (new_tags_set) dt_control_signal_raise(darktable.signals,DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln1149">  return id;</a>
<a name="ln1150">}</a>
<a name="ln1151"> </a>
<a name="ln1152">uint32_t dt_image_import(const int32_t film_id, const char *filename, gboolean override_ignore_jpegs)</a>
<a name="ln1153">{</a>
<a name="ln1154">  return dt_image_import_internal(film_id, filename, override_ignore_jpegs, TRUE);</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">uint32_t dt_image_import_lua(const int32_t film_id, const char *filename, gboolean override_ignore_jpegs)</a>
<a name="ln1158">{</a>
<a name="ln1159">  return dt_image_import_internal(film_id, filename, override_ignore_jpegs, FALSE);</a>
<a name="ln1160">}</a>
<a name="ln1161"> </a>
<a name="ln1162">void dt_image_init(dt_image_t *img)</a>
<a name="ln1163">{</a>
<a name="ln1164">  img-&gt;width = img-&gt;height = 0;</a>
<a name="ln1165">  img-&gt;crop_x = img-&gt;crop_y = img-&gt;crop_width = img-&gt;crop_height = 0;</a>
<a name="ln1166">  img-&gt;orientation = ORIENTATION_NULL;</a>
<a name="ln1167">  img-&gt;legacy_flip.legacy = 0;</a>
<a name="ln1168">  img-&gt;legacy_flip.user_flip = 0;</a>
<a name="ln1169"> </a>
<a name="ln1170">  img-&gt;buf_dsc.filters = 0u;</a>
<a name="ln1171">  img-&gt;buf_dsc = (dt_iop_buffer_dsc_t){.channels = 0, .datatype = TYPE_UNKNOWN };</a>
<a name="ln1172">  img-&gt;film_id = -1;</a>
<a name="ln1173">  img-&gt;group_id = -1;</a>
<a name="ln1174">  img-&gt;flags = 0;</a>
<a name="ln1175">  img-&gt;id = -1;</a>
<a name="ln1176">  img-&gt;version = -1;</a>
<a name="ln1177">  img-&gt;loader = LOADER_UNKNOWN;</a>
<a name="ln1178">  img-&gt;exif_inited = 0;</a>
<a name="ln1179">  memset(img-&gt;exif_maker, 0, sizeof(img-&gt;exif_maker));</a>
<a name="ln1180">  memset(img-&gt;exif_model, 0, sizeof(img-&gt;exif_model));</a>
<a name="ln1181">  memset(img-&gt;exif_lens, 0, sizeof(img-&gt;exif_lens));</a>
<a name="ln1182">  memset(img-&gt;camera_maker, 0, sizeof(img-&gt;camera_maker));</a>
<a name="ln1183">  memset(img-&gt;camera_model, 0, sizeof(img-&gt;camera_model));</a>
<a name="ln1184">  memset(img-&gt;camera_alias, 0, sizeof(img-&gt;camera_alias));</a>
<a name="ln1185">  memset(img-&gt;camera_makermodel, 0, sizeof(img-&gt;camera_makermodel));</a>
<a name="ln1186">  memset(img-&gt;camera_legacy_makermodel, 0, sizeof(img-&gt;camera_legacy_makermodel));</a>
<a name="ln1187">  memset(img-&gt;filename, 0, sizeof(img-&gt;filename));</a>
<a name="ln1188">  g_strlcpy(img-&gt;filename, &quot;(unknown)&quot;, sizeof(img-&gt;filename));</a>
<a name="ln1189">  img-&gt;exif_model[0] = img-&gt;exif_maker[0] = img-&gt;exif_lens[0] = '\0';</a>
<a name="ln1190">  g_strlcpy(img-&gt;exif_datetime_taken, &quot;0000:00:00 00:00:00&quot;, sizeof(img-&gt;exif_datetime_taken));</a>
<a name="ln1191">  img-&gt;exif_crop = 1.0;</a>
<a name="ln1192">  img-&gt;exif_exposure = 0;</a>
<a name="ln1193">  img-&gt;exif_aperture = 0;</a>
<a name="ln1194">  img-&gt;exif_iso = 0;</a>
<a name="ln1195">  img-&gt;exif_focal_length = 0;</a>
<a name="ln1196">  img-&gt;exif_focus_distance = 0;</a>
<a name="ln1197">  img-&gt;latitude = NAN;</a>
<a name="ln1198">  img-&gt;longitude = NAN;</a>
<a name="ln1199">  img-&gt;elevation = NAN;</a>
<a name="ln1200">  img-&gt;raw_black_level = 0;</a>
<a name="ln1201">  for(uint8_t i = 0; i &lt; 4; i++) img-&gt;raw_black_level_separate[i] = 0;</a>
<a name="ln1202">  img-&gt;raw_white_point = 16384; // 2^14</a>
<a name="ln1203">  img-&gt;d65_color_matrix[0] = NAN;</a>
<a name="ln1204">  img-&gt;profile = NULL;</a>
<a name="ln1205">  img-&gt;profile_size = 0;</a>
<a name="ln1206">  img-&gt;colorspace = DT_IMAGE_COLORSPACE_NONE;</a>
<a name="ln1207">  img-&gt;fuji_rotation_pos = 0;</a>
<a name="ln1208">  img-&gt;pixel_aspect_ratio = 1.0f;</a>
<a name="ln1209">  img-&gt;wb_coeffs[0] = NAN;</a>
<a name="ln1210">  img-&gt;wb_coeffs[1] = NAN;</a>
<a name="ln1211">  img-&gt;wb_coeffs[2] = NAN;</a>
<a name="ln1212">  img-&gt;wb_coeffs[3] = NAN;</a>
<a name="ln1213">  img-&gt;cache_entry = 0;</a>
<a name="ln1214">}</a>
<a name="ln1215"> </a>
<a name="ln1216">void dt_image_refresh_makermodel(dt_image_t *img)</a>
<a name="ln1217">{</a>
<a name="ln1218">  if (!img-&gt;camera_maker[0] || !img-&gt;camera_model[0] || !img-&gt;camera_alias[0])</a>
<a name="ln1219">  {</a>
<a name="ln1220">    // We need to use the exif values, so let's get rawspeed to munge them</a>
<a name="ln1221">    dt_rawspeed_lookup_makermodel(img-&gt;exif_maker, img-&gt;exif_model,</a>
<a name="ln1222">                                  img-&gt;camera_maker, sizeof(img-&gt;camera_maker),</a>
<a name="ln1223">                                  img-&gt;camera_model, sizeof(img-&gt;camera_model),</a>
<a name="ln1224">                                  img-&gt;camera_alias, sizeof(img-&gt;camera_alias));</a>
<a name="ln1225">  }</a>
<a name="ln1226"> </a>
<a name="ln1227">  // Now we just create a makermodel by concatenation</a>
<a name="ln1228">  g_strlcpy(img-&gt;camera_makermodel, img-&gt;camera_maker, sizeof(img-&gt;camera_makermodel));</a>
<a name="ln1229">  int len = strlen(img-&gt;camera_maker);</a>
<a name="ln1230">  img-&gt;camera_makermodel[len] = ' ';</a>
<a name="ln1231">  g_strlcpy(img-&gt;camera_makermodel+len+1, img-&gt;camera_model, sizeof(img-&gt;camera_makermodel)-len-1);</a>
<a name="ln1232">}</a>
<a name="ln1233"> </a>
<a name="ln1234">int32_t dt_image_move(const int32_t imgid, const int32_t filmid)</a>
<a name="ln1235">{</a>
<a name="ln1236">  // TODO: several places where string truncation could occur unnoticed</a>
<a name="ln1237">  int32_t result = -1;</a>
<a name="ln1238">  gchar oldimg[PATH_MAX] = { 0 };</a>
<a name="ln1239">  gchar newimg[PATH_MAX] = { 0 };</a>
<a name="ln1240">  gboolean from_cache = FALSE;</a>
<a name="ln1241">  dt_image_full_path(imgid, oldimg, sizeof(oldimg), &amp;from_cache);</a>
<a name="ln1242">  gchar *newdir = NULL;</a>
<a name="ln1243"> </a>
<a name="ln1244">  sqlite3_stmt *film_stmt;</a>
<a name="ln1245">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT folder FROM main.film_rolls WHERE id = ?1&quot;,</a>
<a name="ln1246">                              -1, &amp;film_stmt, NULL);</a>
<a name="ln1247">  DT_DEBUG_SQLITE3_BIND_INT(film_stmt, 1, filmid);</a>
<a name="ln1248">  if(sqlite3_step(film_stmt) == SQLITE_ROW) newdir = g_strdup((gchar *)sqlite3_column_text(film_stmt, 0));</a>
<a name="ln1249">  sqlite3_finalize(film_stmt);</a>
<a name="ln1250"> </a>
<a name="ln1251">  if(newdir)</a>
<a name="ln1252">  {</a>
<a name="ln1253">    gchar copysrcpath[PATH_MAX] = { 0 };</a>
<a name="ln1254">    gchar copydestpath[PATH_MAX] = { 0 };</a>
<a name="ln1255">    gchar *imgbname = g_path_get_basename(oldimg);</a>
<a name="ln1256">    g_snprintf(newimg, sizeof(newimg), &quot;%s%c%s&quot;, newdir, G_DIR_SEPARATOR, imgbname);</a>
<a name="ln1257">    g_free(imgbname);</a>
<a name="ln1258">    g_free(newdir);</a>
<a name="ln1259"> </a>
<a name="ln1260">    // get current local copy if any</a>
<a name="ln1261">    _image_local_copy_full_path(imgid, copysrcpath, sizeof(copysrcpath));</a>
<a name="ln1262"> </a>
<a name="ln1263">    // move image</a>
<a name="ln1264">    GFile *old, *new;</a>
<a name="ln1265">    old = g_file_new_for_path(oldimg);</a>
<a name="ln1266">    new = g_file_new_for_path(newimg);</a>
<a name="ln1267">    if(!g_file_test(newimg, G_FILE_TEST_EXISTS) &amp;&amp; (g_file_move(old, new, 0, NULL, NULL, NULL, NULL) == TRUE))</a>
<a name="ln1268">    {</a>
<a name="ln1269">      // statement for getting ids of the image to be moved and it's duplicates</a>
<a name="ln1270">      sqlite3_stmt *duplicates_stmt;</a>
<a name="ln1271">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1272">                                  &quot;SELECT id FROM main.images WHERE filename IN (SELECT filename FROM main.images &quot;</a>
<a name="ln1273">                                  &quot;WHERE id = ?1) AND film_id IN (SELECT film_id FROM main.images WHERE id = ?1)&quot;,</a>
<a name="ln1274">                                  -1, &amp;duplicates_stmt, NULL);</a>
<a name="ln1275"> </a>
<a name="ln1276">      // first move xmp files of image and duplicates</a>
<a name="ln1277">      GList *dup_list = NULL;</a>
<a name="ln1278">      DT_DEBUG_SQLITE3_BIND_INT(duplicates_stmt, 1, imgid);</a>
<a name="ln1279">      while(sqlite3_step(duplicates_stmt) == SQLITE_ROW)</a>
<a name="ln1280">      {</a>
<a name="ln1281">        int32_t id = sqlite3_column_int(duplicates_stmt, 0);</a>
<a name="ln1282">        dup_list = g_list_append(dup_list, GINT_TO_POINTER(id));</a>
<a name="ln1283">        gchar oldxmp[PATH_MAX] = { 0 }, newxmp[PATH_MAX] = { 0 };</a>
<a name="ln1284">        g_strlcpy(oldxmp, oldimg, sizeof(oldxmp));</a>
<a name="ln1285">        g_strlcpy(newxmp, newimg, sizeof(newxmp));</a>
<a name="ln1286">        dt_image_path_append_version(id, oldxmp, sizeof(oldxmp));</a>
<a name="ln1287">        dt_image_path_append_version(id, newxmp, sizeof(newxmp));</a>
<a name="ln1288">        g_strlcat(oldxmp, &quot;.xmp&quot;, sizeof(oldxmp));</a>
<a name="ln1289">        g_strlcat(newxmp, &quot;.xmp&quot;, sizeof(newxmp));</a>
<a name="ln1290"> </a>
<a name="ln1291">        GFile *goldxmp = g_file_new_for_path(oldxmp);</a>
<a name="ln1292">        GFile *gnewxmp = g_file_new_for_path(newxmp);</a>
<a name="ln1293"> </a>
<a name="ln1294">        if(g_file_test(oldxmp, G_FILE_TEST_EXISTS))</a>
<a name="ln1295">          (void)g_file_move(goldxmp, gnewxmp, 0, NULL, NULL, NULL, NULL);</a>
<a name="ln1296"> </a>
<a name="ln1297">        g_object_unref(goldxmp);</a>
<a name="ln1298">        g_object_unref(gnewxmp);</a>
<a name="ln1299">      }</a>
<a name="ln1300">      sqlite3_finalize(duplicates_stmt);</a>
<a name="ln1301"> </a>
<a name="ln1302">      // then update database and cache</a>
<a name="ln1303">      // if update was performed in above loop, dt_image_path_append_version()</a>
<a name="ln1304">      // would return wrong version!</a>
<a name="ln1305">      while(dup_list)</a>
<a name="ln1306">      {</a>
<a name="ln1307">        int id = GPOINTER_TO_INT(dup_list-&gt;data);</a>
<a name="ln1308">        dt_image_t *img = dt_image_cache_get(darktable.image_cache, id, 'w');</a>
<a name="ln1309">        img-&gt;film_id = filmid;</a>
<a name="ln1310">        // write through to db, but not to xmp</a>
<a name="ln1311">        dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln1312">        dup_list = g_list_delete_link(dup_list, dup_list);</a>
<a name="ln1313">      }</a>
<a name="ln1314">      g_list_free(dup_list);</a>
<a name="ln1315"> </a>
<a name="ln1316">      // finally, rename local copy if any</a>
<a name="ln1317">      if(g_file_test(copysrcpath, G_FILE_TEST_EXISTS))</a>
<a name="ln1318">      {</a>
<a name="ln1319">        // get new name</a>
<a name="ln1320">        _image_local_copy_full_path(imgid, copydestpath, sizeof(copydestpath));</a>
<a name="ln1321"> </a>
<a name="ln1322">        GFile *cold = g_file_new_for_path(copysrcpath);</a>
<a name="ln1323">        GFile *cnew = g_file_new_for_path(copydestpath);</a>
<a name="ln1324"> </a>
<a name="ln1325">        if(g_file_move(cold, cnew, 0, NULL, NULL, NULL, NULL) != TRUE)</a>
<a name="ln1326">          fprintf(stderr, &quot;[dt_image_move] error moving local copy `%s' -&gt; `%s'\n&quot;, copysrcpath, copydestpath);</a>
<a name="ln1327"> </a>
<a name="ln1328">        g_object_unref(cold);</a>
<a name="ln1329">        g_object_unref(cnew);</a>
<a name="ln1330">      }</a>
<a name="ln1331"> </a>
<a name="ln1332">      result = 0;</a>
<a name="ln1333">    }</a>
<a name="ln1334">    else</a>
<a name="ln1335">    {</a>
<a name="ln1336">      fprintf(stderr, &quot;[dt_image_move] error moving `%s' -&gt; `%s'\n&quot;, oldimg, newimg);</a>
<a name="ln1337">    }</a>
<a name="ln1338"> </a>
<a name="ln1339">    g_object_unref(old);</a>
<a name="ln1340">    g_object_unref(new);</a>
<a name="ln1341">  }</a>
<a name="ln1342"> </a>
<a name="ln1343">  return result;</a>
<a name="ln1344">}</a>
<a name="ln1345"> </a>
<a name="ln1346">int32_t dt_image_copy(const int32_t imgid, const int32_t filmid)</a>
<a name="ln1347">{</a>
<a name="ln1348">  int32_t newid = -1;</a>
<a name="ln1349">  sqlite3_stmt *stmt;</a>
<a name="ln1350">  gchar srcpath[PATH_MAX] = { 0 };</a>
<a name="ln1351">  gchar *newdir = NULL;</a>
<a name="ln1352">  gchar *filename = NULL;</a>
<a name="ln1353">  gboolean from_cache = FALSE;</a>
<a name="ln1354"> </a>
<a name="ln1355">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT folder FROM main.film_rolls WHERE id = ?1&quot;,</a>
<a name="ln1356">                              -1, &amp;stmt, NULL);</a>
<a name="ln1357">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, filmid);</a>
<a name="ln1358">  if(sqlite3_step(stmt) == SQLITE_ROW) newdir = g_strdup((gchar *)sqlite3_column_text(stmt, 0));</a>
<a name="ln1359">  sqlite3_finalize(stmt);</a>
<a name="ln1360"> </a>
<a name="ln1361">  if(newdir)</a>
<a name="ln1362">  {</a>
<a name="ln1363">    dt_image_full_path(imgid, srcpath, sizeof(srcpath), &amp;from_cache);</a>
<a name="ln1364">    gchar *imgbname = g_path_get_basename(srcpath);</a>
<a name="ln1365">    gchar *destpath = g_build_filename(newdir, imgbname, NULL);</a>
<a name="ln1366">    GFile *src = g_file_new_for_path(srcpath);</a>
<a name="ln1367">    GFile *dest = g_file_new_for_path(destpath);</a>
<a name="ln1368">    g_free(imgbname);</a>
<a name="ln1369">    imgbname = NULL;</a>
<a name="ln1370">    g_free(newdir);</a>
<a name="ln1371">    newdir = NULL;</a>
<a name="ln1372">    g_free(destpath);</a>
<a name="ln1373">    destpath = NULL;</a>
<a name="ln1374"> </a>
<a name="ln1375">    // copy image to new folder</a>
<a name="ln1376">    // if image file already exists, continue</a>
<a name="ln1377">    GError *gerror = NULL;</a>
<a name="ln1378">    g_file_copy(src, dest, G_FILE_COPY_NONE, NULL, NULL, NULL, &amp;gerror);</a>
<a name="ln1379"> </a>
<a name="ln1380">    if((gerror == NULL) || (gerror != NULL &amp;&amp; gerror-&gt;code == G_IO_ERROR_EXISTS))</a>
<a name="ln1381">    {</a>
<a name="ln1382">      const int64_t new_image_position = create_next_image_position();</a>
<a name="ln1383"> </a>
<a name="ln1384">      // update database</a>
<a name="ln1385">      DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln1386">          dt_database_get(darktable.db),</a>
<a name="ln1387">          &quot;INSERT INTO main.images &quot;</a>
<a name="ln1388">          &quot;(id, group_id, film_id, width, height, filename, maker, model, lens, exposure, &quot;</a>
<a name="ln1389">          &quot;aperture, iso, focal_length, focus_distance, datetime_taken, flags, &quot;</a>
<a name="ln1390">          &quot;output_width, output_height, crop, raw_parameters, raw_denoise_threshold, &quot;</a>
<a name="ln1391">          &quot;raw_auto_bright_threshold, raw_black, raw_maximum, &quot;</a>
<a name="ln1392">          &quot;caption, description, license, sha1sum, orientation, histogram, lightmap, &quot;</a>
<a name="ln1393">          &quot;longitude, latitude, altitude, color_matrix, colorspace, version, max_version, &quot;</a>
<a name="ln1394">          &quot;position, aspect_ratio) &quot;</a>
<a name="ln1395">          &quot;SELECT NULL, group_id, ?1 as film_id, width, height, filename, maker, model, lens, &quot;</a>
<a name="ln1396">          &quot;exposure, aperture, iso, focal_length, focus_distance, datetime_taken, &quot;</a>
<a name="ln1397">          &quot;flags, width, height, crop, raw_parameters, raw_denoise_threshold, &quot;</a>
<a name="ln1398">          &quot;raw_auto_bright_threshold, raw_black, raw_maximum, &quot;</a>
<a name="ln1399">          &quot;caption, description, license, sha1sum, orientation, histogram, lightmap, &quot;</a>
<a name="ln1400">          &quot;longitude, latitude, altitude, color_matrix, colorspace, -1, -1, &quot;</a>
<a name="ln1401">          &quot;?2, aspect_ratio &quot;</a>
<a name="ln1402">          &quot;FROM main.images WHERE id = ?3&quot;,</a>
<a name="ln1403">          -1, &amp;stmt, NULL);</a>
<a name="ln1404">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, filmid);</a>
<a name="ln1405">      DT_DEBUG_SQLITE3_BIND_INT64(stmt, 2, new_image_position);</a>
<a name="ln1406">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, imgid);</a>
<a name="ln1407">      sqlite3_step(stmt);</a>
<a name="ln1408">      sqlite3_finalize(stmt);</a>
<a name="ln1409">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1410">                                  &quot;SELECT a.id, a.filename FROM main.images AS a JOIN main.images AS b WHERE &quot;</a>
<a name="ln1411">                                  &quot;a.film_id = ?1 AND a.filename = b.filename AND b.id = ?2 ORDER BY a.id DESC&quot;,</a>
<a name="ln1412">                                  -1, &amp;stmt, NULL);</a>
<a name="ln1413">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, filmid);</a>
<a name="ln1414">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln1415"> </a>
<a name="ln1416">      if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1417">      {</a>
<a name="ln1418">        newid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1419">        filename = g_strdup((gchar *)sqlite3_column_text(stmt, 1));</a>
<a name="ln1420">      }</a>
<a name="ln1421">      sqlite3_finalize(stmt);</a>
<a name="ln1422"> </a>
<a name="ln1423">      if(newid != -1)</a>
<a name="ln1424">      {</a>
<a name="ln1425">        // also copy over on-disk thumbnails, if any</a>
<a name="ln1426">        dt_mipmap_cache_copy_thumbnails(darktable.mipmap_cache, newid, imgid);</a>
<a name="ln1427">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1428">                                    &quot;INSERT INTO main.color_labels (imgid, color) SELECT ?1, color FROM &quot;</a>
<a name="ln1429">                                    &quot;main.color_labels WHERE imgid = ?2&quot;,</a>
<a name="ln1430">                                    -1, &amp;stmt, NULL);</a>
<a name="ln1431">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, newid);</a>
<a name="ln1432">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln1433">        sqlite3_step(stmt);</a>
<a name="ln1434">        sqlite3_finalize(stmt);</a>
<a name="ln1435">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1436">                                    &quot;INSERT INTO main.meta_data (id, key, value) SELECT ?1, key, value &quot;</a>
<a name="ln1437">                                    &quot;FROM main.meta_data WHERE id = ?2&quot;,</a>
<a name="ln1438">                                    -1, &amp;stmt, NULL);</a>
<a name="ln1439">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, newid);</a>
<a name="ln1440">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln1441">        sqlite3_step(stmt);</a>
<a name="ln1442">        sqlite3_finalize(stmt);</a>
<a name="ln1443">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1444">                                    &quot;INSERT INTO main.tagged_images (imgid, tagid) SELECT ?1, tagid FROM &quot;</a>
<a name="ln1445">                                    &quot;main.tagged_images WHERE imgid = ?2&quot;,</a>
<a name="ln1446">                                    -1, &amp;stmt, NULL);</a>
<a name="ln1447">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, newid);</a>
<a name="ln1448">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln1449">        sqlite3_step(stmt);</a>
<a name="ln1450">        sqlite3_finalize(stmt);</a>
<a name="ln1451"> </a>
<a name="ln1452">        // get max_version of image duplicates in destination filmroll</a>
<a name="ln1453">        int32_t max_version = -1;</a>
<a name="ln1454">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1455">                                    &quot;SELECT MAX(a.max_version) FROM main.images AS a JOIN main.images AS b WHERE &quot;</a>
<a name="ln1456">                                    &quot;a.film_id = b.film_id AND a.filename = b.filename AND b.id = ?1&quot;,</a>
<a name="ln1457">                                    -1, &amp;stmt, NULL);</a>
<a name="ln1458">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, newid);</a>
<a name="ln1459"> </a>
<a name="ln1460">        if(sqlite3_step(stmt) == SQLITE_ROW) max_version = sqlite3_column_int(stmt, 0);</a>
<a name="ln1461">        sqlite3_finalize(stmt);</a>
<a name="ln1462"> </a>
<a name="ln1463">        // set version of new entry and max_version of all involved duplicates (with same film_id and</a>
<a name="ln1464">        // filename)</a>
<a name="ln1465">        max_version = (max_version &gt;= 0) ? max_version + 1 : 0;</a>
<a name="ln1466">        int32_t version = max_version;</a>
<a name="ln1467"> </a>
<a name="ln1468">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1469">                                    &quot;UPDATE main.images SET version=?1 WHERE id = ?2&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1470">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, version);</a>
<a name="ln1471">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, newid);</a>
<a name="ln1472">        sqlite3_step(stmt);</a>
<a name="ln1473">        sqlite3_finalize(stmt);</a>
<a name="ln1474"> </a>
<a name="ln1475">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1476">                                    &quot;UPDATE main.images SET max_version=?1 WHERE film_id = ?2 AND filename = ?3&quot;,</a>
<a name="ln1477">                                    -1, &amp;stmt, NULL);</a>
<a name="ln1478">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, max_version);</a>
<a name="ln1479">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, filmid);</a>
<a name="ln1480">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 3, filename, -1, SQLITE_TRANSIENT);</a>
<a name="ln1481">        sqlite3_step(stmt);</a>
<a name="ln1482">        sqlite3_finalize(stmt);</a>
<a name="ln1483"> </a>
<a name="ln1484">        // image group handling follows</a>
<a name="ln1485">        // get group_id of potential image duplicates in destination filmroll</a>
<a name="ln1486">        int32_t new_group_id = -1;</a>
<a name="ln1487">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1488">                                    &quot;SELECT DISTINCT a.group_id FROM main.images AS a JOIN main.images AS b WHERE &quot;</a>
<a name="ln1489">                                    &quot;a.film_id = b.film_id AND a.filename = b.filename AND &quot;</a>
<a name="ln1490">                                    &quot;b.id = ?1 AND a.id != ?1&quot;,</a>
<a name="ln1491">                                    -1, &amp;stmt, NULL);</a>
<a name="ln1492">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, newid);</a>
<a name="ln1493"> </a>
<a name="ln1494">        if(sqlite3_step(stmt) == SQLITE_ROW) new_group_id = sqlite3_column_int(stmt, 0);</a>
<a name="ln1495"> </a>
<a name="ln1496">        // then check if there are further duplicates belonging to different group(s)</a>
<a name="ln1497">        if(sqlite3_step(stmt) == SQLITE_ROW) new_group_id = -1;</a>
<a name="ln1498">        sqlite3_finalize(stmt);</a>
<a name="ln1499"> </a>
<a name="ln1500">        // rationale:</a>
<a name="ln1501">        // if no group exists or if the image duplicates belong to multiple groups, then the</a>
<a name="ln1502">        // new image builds a group of its own, else it is added to the (one) existing group</a>
<a name="ln1503">        if(new_group_id == -1) new_group_id = newid;</a>
<a name="ln1504"> </a>
<a name="ln1505">        // make copied image belong to a group</a>
<a name="ln1506">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1507">                                    &quot;UPDATE main.images SET group_id=?1 WHERE id = ?2&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1508"> </a>
<a name="ln1509">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, new_group_id);</a>
<a name="ln1510">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, newid);</a>
<a name="ln1511">        sqlite3_step(stmt);</a>
<a name="ln1512">        sqlite3_finalize(stmt);</a>
<a name="ln1513"> </a>
<a name="ln1514">        dt_history_copy_and_paste_on_image(imgid, newid, FALSE, NULL);</a>
<a name="ln1515"> </a>
<a name="ln1516">        // write xmp file</a>
<a name="ln1517">        dt_image_write_sidecar_file(newid);</a>
<a name="ln1518">      }</a>
<a name="ln1519"> </a>
<a name="ln1520">      g_free(filename);</a>
<a name="ln1521">    }</a>
<a name="ln1522">    else</a>
<a name="ln1523">    {</a>
<a name="ln1524">      fprintf(stderr, &quot;Failed to copy image %s: %s\n&quot;, srcpath, gerror-&gt;message);</a>
<a name="ln1525">    }</a>
<a name="ln1526">    g_object_unref(dest);</a>
<a name="ln1527">    g_object_unref(src);</a>
<a name="ln1528">    g_clear_error(&amp;gerror);</a>
<a name="ln1529">  }</a>
<a name="ln1530"> </a>
<a name="ln1531">  return newid;</a>
<a name="ln1532">}</a>
<a name="ln1533"> </a>
<a name="ln1534">int dt_image_local_copy_set(const int32_t imgid)</a>
<a name="ln1535">{</a>
<a name="ln1536">  gchar srcpath[PATH_MAX] = { 0 };</a>
<a name="ln1537">  gchar destpath[PATH_MAX] = { 0 };</a>
<a name="ln1538"> </a>
<a name="ln1539">  gboolean from_cache = FALSE;</a>
<a name="ln1540">  dt_image_full_path(imgid, srcpath, sizeof(srcpath), &amp;from_cache);</a>
<a name="ln1541"> </a>
<a name="ln1542">  _image_local_copy_full_path(imgid, destpath, sizeof(destpath));</a>
<a name="ln1543"> </a>
<a name="ln1544">  // check that the src file is readable</a>
<a name="ln1545">  if(!g_file_test(srcpath, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln1546">  {</a>
<a name="ln1547">    dt_control_log(_(&quot;cannot create local copy when the original file is not accessible.&quot;));</a>
<a name="ln1548">    return 1;</a>
<a name="ln1549">  }</a>
<a name="ln1550"> </a>
<a name="ln1551">  if(!g_file_test(destpath, G_FILE_TEST_EXISTS))</a>
<a name="ln1552">  {</a>
<a name="ln1553">    GFile *src = g_file_new_for_path(srcpath);</a>
<a name="ln1554">    GFile *dest = g_file_new_for_path(destpath);</a>
<a name="ln1555"> </a>
<a name="ln1556">    // copy image to cache directory</a>
<a name="ln1557">    GError *gerror = NULL;</a>
<a name="ln1558"> </a>
<a name="ln1559">    if(!g_file_copy(src, dest, G_FILE_COPY_NONE, NULL, NULL, NULL, &amp;gerror))</a>
<a name="ln1560">    {</a>
<a name="ln1561">      dt_control_log(_(&quot;cannot create local copy.&quot;));</a>
<a name="ln1562">      g_object_unref(dest);</a>
<a name="ln1563">      g_object_unref(src);</a>
<a name="ln1564">      return 1;</a>
<a name="ln1565">    }</a>
<a name="ln1566"> </a>
<a name="ln1567">    g_object_unref(dest);</a>
<a name="ln1568">    g_object_unref(src);</a>
<a name="ln1569">  }</a>
<a name="ln1570"> </a>
<a name="ln1571">  // update cache local copy flags, do this even if the local copy already exists as we need to set the flags</a>
<a name="ln1572">  // for duplicate</a>
<a name="ln1573">  dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln1574">  img-&gt;flags |= DT_IMAGE_LOCAL_COPY;</a>
<a name="ln1575">  dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln1576"> </a>
<a name="ln1577">  dt_control_queue_redraw_center();</a>
<a name="ln1578">  return 0;</a>
<a name="ln1579">}</a>
<a name="ln1580"> </a>
<a name="ln1581">static int _nb_other_local_copy_for(const int32_t imgid)</a>
<a name="ln1582">{</a>
<a name="ln1583">  sqlite3_stmt *stmt;</a>
<a name="ln1584">  int result = 1;</a>
<a name="ln1585"> </a>
<a name="ln1586">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT COUNT(*) FROM main.images WHERE id!=?1 AND &quot;</a>
<a name="ln1587">                                                             &quot;flags&amp;?2=?2 AND film_id=(SELECT film_id FROM &quot;</a>
<a name="ln1588">                                                             &quot;main.images WHERE id=?1) AND filename=(SELECT &quot;</a>
<a name="ln1589">                                                             &quot;filename FROM main.images WHERE id=?1);&quot;,</a>
<a name="ln1590">                              -1, &amp;stmt, NULL);</a>
<a name="ln1591">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1592">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, DT_IMAGE_LOCAL_COPY);</a>
<a name="ln1593">  if(sqlite3_step(stmt) == SQLITE_ROW) result = sqlite3_column_int(stmt, 0);</a>
<a name="ln1594">  sqlite3_finalize(stmt);</a>
<a name="ln1595"> </a>
<a name="ln1596">  return result;</a>
<a name="ln1597">}</a>
<a name="ln1598"> </a>
<a name="ln1599">int dt_image_local_copy_reset(const int32_t imgid)</a>
<a name="ln1600">{</a>
<a name="ln1601">  gchar destpath[PATH_MAX] = { 0 };</a>
<a name="ln1602">  gchar locppath[PATH_MAX] = { 0 };</a>
<a name="ln1603">  gchar cachedir[PATH_MAX] = { 0 };</a>
<a name="ln1604"> </a>
<a name="ln1605">  // check that a local copy exists, otherwise there is nothing to do</a>
<a name="ln1606">  dt_image_t *imgr = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1607">  const gboolean local_copy_exists = (imgr-&gt;flags &amp; DT_IMAGE_LOCAL_COPY) == DT_IMAGE_LOCAL_COPY ? TRUE : FALSE;</a>
<a name="ln1608">  dt_image_cache_read_release(darktable.image_cache, imgr);</a>
<a name="ln1609"> </a>
<a name="ln1610">  if (!local_copy_exists)</a>
<a name="ln1611">    return 0;</a>
<a name="ln1612"> </a>
<a name="ln1613">  // check that the original file is accessible</a>
<a name="ln1614"> </a>
<a name="ln1615">  gboolean from_cache = FALSE;</a>
<a name="ln1616">  dt_image_full_path(imgid, destpath, sizeof(destpath), &amp;from_cache);</a>
<a name="ln1617"> </a>
<a name="ln1618">  from_cache = TRUE;</a>
<a name="ln1619">  dt_image_full_path(imgid, locppath, sizeof(locppath), &amp;from_cache);</a>
<a name="ln1620">  dt_image_path_append_version(imgid, locppath, sizeof(locppath));</a>
<a name="ln1621">  g_strlcat(locppath, &quot;.xmp&quot;, sizeof(locppath));</a>
<a name="ln1622"> </a>
<a name="ln1623">  // a local copy exists, but the original is not accessible</a>
<a name="ln1624"> </a>
<a name="ln1625">  if(g_file_test(locppath, G_FILE_TEST_EXISTS) &amp;&amp; !g_file_test(destpath, G_FILE_TEST_EXISTS))</a>
<a name="ln1626">  {</a>
<a name="ln1627">    dt_control_log(_(&quot;cannot remove local copy when the original file is not accessible.&quot;));</a>
<a name="ln1628">    return 1;</a>
<a name="ln1629">  }</a>
<a name="ln1630"> </a>
<a name="ln1631">  // get name of local copy</a>
<a name="ln1632"> </a>
<a name="ln1633">  _image_local_copy_full_path(imgid, locppath, sizeof(locppath));</a>
<a name="ln1634"> </a>
<a name="ln1635">  // remove cached file, but double check that this is really into the cache. We really want to avoid deleting</a>
<a name="ln1636">  // a user's original file.</a>
<a name="ln1637"> </a>
<a name="ln1638">  dt_loc_get_user_cache_dir(cachedir, sizeof(cachedir));</a>
<a name="ln1639"> </a>
<a name="ln1640">  if(g_file_test(locppath, G_FILE_TEST_EXISTS) &amp;&amp; strstr(locppath, cachedir))</a>
<a name="ln1641">  {</a>
<a name="ln1642">    GFile *dest = g_file_new_for_path(locppath);</a>
<a name="ln1643"> </a>
<a name="ln1644">    // first sync the xmp with the original picture</a>
<a name="ln1645"> </a>
<a name="ln1646">    dt_image_write_sidecar_file(imgid);</a>
<a name="ln1647"> </a>
<a name="ln1648">    // delete image from cache directory only if there is no other local cache image referencing it</a>
<a name="ln1649">    // for example duplicates are all referencing the same base picture.</a>
<a name="ln1650"> </a>
<a name="ln1651">    if(_nb_other_local_copy_for(imgid) == 0) g_file_delete(dest, NULL, NULL);</a>
<a name="ln1652"> </a>
<a name="ln1653">    g_object_unref(dest);</a>
<a name="ln1654"> </a>
<a name="ln1655">    // delete xmp if any</a>
<a name="ln1656">    dt_image_path_append_version(imgid, locppath, sizeof(locppath));</a>
<a name="ln1657">    g_strlcat(locppath, &quot;.xmp&quot;, sizeof(locppath));</a>
<a name="ln1658">    dest = g_file_new_for_path(locppath);</a>
<a name="ln1659"> </a>
<a name="ln1660">    if(g_file_test(locppath, G_FILE_TEST_EXISTS)) g_file_delete(dest, NULL, NULL);</a>
<a name="ln1661">    g_object_unref(dest);</a>
<a name="ln1662"> </a>
<a name="ln1663">    // update cache, remove local copy flags</a>
<a name="ln1664">    dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln1665">    img-&gt;flags &amp;= ~DT_IMAGE_LOCAL_COPY;</a>
<a name="ln1666">    dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln1667"> </a>
<a name="ln1668">    dt_control_queue_redraw_center();</a>
<a name="ln1669">  }</a>
<a name="ln1670"> </a>
<a name="ln1671">  return 0;</a>
<a name="ln1672">}</a>
<a name="ln1673"> </a>
<a name="ln1674">// *******************************************************</a>
<a name="ln1675">// xmp stuff</a>
<a name="ln1676">// *******************************************************</a>
<a name="ln1677"> </a>
<a name="ln1678">void dt_image_write_sidecar_file(int imgid)</a>
<a name="ln1679">{</a>
<a name="ln1680">  // TODO: compute hash and don't write if not needed!</a>
<a name="ln1681">  // write .xmp file</a>
<a name="ln1682">  if(imgid &gt; 0 &amp;&amp; dt_conf_get_bool(&quot;write_sidecar_files&quot;))</a>
<a name="ln1683">  {</a>
<a name="ln1684">    char filename[PATH_MAX] = { 0 };</a>
<a name="ln1685"> </a>
<a name="ln1686">    // FIRST: check if the original file is present</a>
<a name="ln1687">    gboolean from_cache = FALSE;</a>
<a name="ln1688">    dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln1689"> </a>
<a name="ln1690">    if (!g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln1691">    {</a>
<a name="ln1692">      // OTHERWISE: check if the local copy exists</a>
<a name="ln1693">      from_cache = TRUE;</a>
<a name="ln1694">      dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln1695"> </a>
<a name="ln1696">      //  nothing to do, the original is not accessible and there is no local copy</a>
<a name="ln1697">      if (!from_cache) return;</a>
<a name="ln1698">    }</a>
<a name="ln1699"> </a>
<a name="ln1700">    dt_image_path_append_version(imgid, filename, sizeof(filename));</a>
<a name="ln1701">    g_strlcat(filename, &quot;.xmp&quot;, sizeof(filename));</a>
<a name="ln1702"> </a>
<a name="ln1703">    if(!dt_exif_xmp_write(imgid, filename))</a>
<a name="ln1704">    {</a>
<a name="ln1705">      // put the timestamp into db. this can't be done in exif.cc since that code gets called</a>
<a name="ln1706">      // for the copy exporter, too</a>
<a name="ln1707">      sqlite3_stmt *stmt;</a>
<a name="ln1708">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1709">                                  &quot;UPDATE main.images SET write_timestamp = STRFTIME('%s', 'now') WHERE id = ?1&quot;,</a>
<a name="ln1710">                                  -1, &amp;stmt, NULL);</a>
<a name="ln1711">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1712">      sqlite3_step(stmt);</a>
<a name="ln1713">      sqlite3_finalize(stmt);</a>
<a name="ln1714">    }</a>
<a name="ln1715">  }</a>
<a name="ln1716">}</a>
<a name="ln1717"> </a>
<a name="ln1718"> </a>
<a name="ln1719">void dt_image_synch_xmp(const int selected)</a>
<a name="ln1720">{</a>
<a name="ln1721">  if(selected &gt; 0)</a>
<a name="ln1722">  {</a>
<a name="ln1723">    dt_image_write_sidecar_file(selected);</a>
<a name="ln1724">  }</a>
<a name="ln1725">  else if(dt_conf_get_bool(&quot;write_sidecar_files&quot;))</a>
<a name="ln1726">  {</a>
<a name="ln1727">    sqlite3_stmt *stmt;</a>
<a name="ln1728">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;, -1, &amp;stmt,</a>
<a name="ln1729">                                NULL);</a>
<a name="ln1730">    while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1731">    {</a>
<a name="ln1732">      const int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1733">      dt_image_write_sidecar_file(imgid);</a>
<a name="ln1734">    }</a>
<a name="ln1735">    sqlite3_finalize(stmt);</a>
<a name="ln1736">  }</a>
<a name="ln1737">}</a>
<a name="ln1738"> </a>
<a name="ln1739">void dt_image_synch_all_xmp(const gchar *pathname)</a>
<a name="ln1740">{</a>
<a name="ln1741">  if(dt_conf_get_bool(&quot;write_sidecar_files&quot;))</a>
<a name="ln1742">  {</a>
<a name="ln1743">    sqlite3_stmt *stmt;</a>
<a name="ln1744">    gchar *imgfname = g_path_get_basename(pathname);</a>
<a name="ln1745">    gchar *imgpath = g_path_get_dirname(pathname);</a>
<a name="ln1746">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1747">                                &quot;SELECT id FROM main.images WHERE film_id IN (SELECT id FROM main.film_rolls &quot;</a>
<a name="ln1748">                                &quot;WHERE folder = ?1) AND filename = ?2&quot;,</a>
<a name="ln1749">                                -1, &amp;stmt, NULL);</a>
<a name="ln1750">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, imgpath, -1, SQLITE_TRANSIENT);</a>
<a name="ln1751">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgfname, -1, SQLITE_TRANSIENT);</a>
<a name="ln1752">    while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1753">    {</a>
<a name="ln1754">      const int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1755">      dt_image_write_sidecar_file(imgid);</a>
<a name="ln1756">    }</a>
<a name="ln1757">    sqlite3_finalize(stmt);</a>
<a name="ln1758">    g_free(imgfname);</a>
<a name="ln1759">    g_free(imgpath);</a>
<a name="ln1760">  }</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763">void dt_image_local_copy_synch(void)</a>
<a name="ln1764">{</a>
<a name="ln1765">  // nothing to do if not creating .xmp</a>
<a name="ln1766">  if(!dt_conf_get_bool(&quot;write_sidecar_files&quot;)) return;</a>
<a name="ln1767"> </a>
<a name="ln1768">  sqlite3_stmt *stmt;</a>
<a name="ln1769"> </a>
<a name="ln1770">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT id FROM main.images WHERE flags&amp;?1=?1&quot;, -1,</a>
<a name="ln1771">                              &amp;stmt, NULL);</a>
<a name="ln1772">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, DT_IMAGE_LOCAL_COPY);</a>
<a name="ln1773"> </a>
<a name="ln1774">  int count = 0;</a>
<a name="ln1775"> </a>
<a name="ln1776">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1777">  {</a>
<a name="ln1778">    const int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1779">    gboolean from_cache = FALSE;</a>
<a name="ln1780">    char filename[PATH_MAX] = { 0 };</a>
<a name="ln1781">    dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln1782"> </a>
<a name="ln1783">    if(g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln1784">    {</a>
<a name="ln1785">      dt_image_write_sidecar_file(imgid);</a>
<a name="ln1786">      count++;</a>
<a name="ln1787">    }</a>
<a name="ln1788">  }</a>
<a name="ln1789">  sqlite3_finalize(stmt);</a>
<a name="ln1790"> </a>
<a name="ln1791">  if(count &gt; 0)</a>
<a name="ln1792">  {</a>
<a name="ln1793">    dt_control_log(ngettext(&quot;%d local copy has been synchronized&quot;,</a>
<a name="ln1794">                            &quot;%d local copies have been synchronized&quot;, count),</a>
<a name="ln1795">                   count);</a>
<a name="ln1796">  }</a>
<a name="ln1797">}</a>
<a name="ln1798"> </a>
<a name="ln1799">void dt_image_add_time_offset(const int imgid, const long int offset)</a>
<a name="ln1800">{</a>
<a name="ln1801">  const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1802">  if(!cimg) return;</a>
<a name="ln1803"> </a>
<a name="ln1804">  // get the datetime_taken and calculate the new time</a>
<a name="ln1805">  gint year;</a>
<a name="ln1806">  gint month;</a>
<a name="ln1807">  gint day;</a>
<a name="ln1808">  gint hour;</a>
<a name="ln1809">  gint minute;</a>
<a name="ln1810">  gint seconds;</a>
<a name="ln1811"> </a>
<a name="ln1812">  if(sscanf(cimg-&gt;exif_datetime_taken, &quot;%d:%d:%d %d:%d:%d&quot;, (int *)&amp;year, (int *)&amp;month, (int *)&amp;day,</a>
<a name="ln1813">            (int *)&amp;hour, (int *)&amp;minute, (int *)&amp;seconds) != 6)</a>
<a name="ln1814">  {</a>
<a name="ln1815">    fprintf(stderr, &quot;broken exif time in db, '%s', imgid %d\n&quot;, cimg-&gt;exif_datetime_taken, imgid);</a>
<a name="ln1816">    dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1817">    return;</a>
<a name="ln1818">  }</a>
<a name="ln1819"> </a>
<a name="ln1820">  GTimeZone *tz = g_time_zone_new_utc();</a>
<a name="ln1821">  GDateTime *datetime_original = g_date_time_new(tz, year, month, day, hour, minute, seconds);</a>
<a name="ln1822">  g_time_zone_unref(tz);</a>
<a name="ln1823">  if(!datetime_original)</a>
<a name="ln1824">  {</a>
<a name="ln1825">    dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1826">    return;</a>
<a name="ln1827">  }</a>
<a name="ln1828"> </a>
<a name="ln1829">  // let's add our offset</a>
<a name="ln1830">  GDateTime *datetime_new = g_date_time_add_seconds(datetime_original, offset);</a>
<a name="ln1831">  g_date_time_unref(datetime_original);</a>
<a name="ln1832"> </a>
<a name="ln1833">  if(!datetime_new)</a>
<a name="ln1834">  {</a>
<a name="ln1835">    dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1836">    return;</a>
<a name="ln1837">  }</a>
<a name="ln1838"> </a>
<a name="ln1839">  gchar *datetime = g_date_time_format(datetime_new, &quot;%Y:%m:%d %H:%M:%S&quot;);</a>
<a name="ln1840">  g_date_time_unref(datetime_new);</a>
<a name="ln1841"> </a>
<a name="ln1842">  // update exif_datetime_taken in img</a>
<a name="ln1843">  if(datetime)</a>
<a name="ln1844">  {</a>
<a name="ln1845">    dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1846">    dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln1847">    g_strlcpy(img-&gt;exif_datetime_taken, datetime, sizeof(img-&gt;exif_datetime_taken));</a>
<a name="ln1848">    dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_SAFE);</a>
<a name="ln1849">  }</a>
<a name="ln1850">  else dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1851"> </a>
<a name="ln1852">  g_free(datetime);</a>
<a name="ln1853">}</a>
<a name="ln1854"> </a>
<a name="ln1855">char *dt_image_get_audio_path_from_path(const char *image_path)</a>
<a name="ln1856">{</a>
<a name="ln1857">  size_t len = strlen(image_path);</a>
<a name="ln1858">  const char *c = image_path + len;</a>
<a name="ln1859">  while((c &gt; image_path) &amp;&amp; (*c != '.')) c--;</a>
<a name="ln1860">  len = c - image_path + 1;</a>
<a name="ln1861"> </a>
<a name="ln1862">  char *result = g_strndup(image_path, len + 3);</a>
<a name="ln1863"> </a>
<a name="ln1864">  result[len] = 'w';</a>
<a name="ln1865">  result[len + 1] = 'a';</a>
<a name="ln1866">  result[len + 2] = 'v';</a>
<a name="ln1867">  if(g_file_test(result, G_FILE_TEST_EXISTS)) return result;</a>
<a name="ln1868"> </a>
<a name="ln1869">  result[len] = 'W';</a>
<a name="ln1870">  result[len + 1] = 'A';</a>
<a name="ln1871">  result[len + 2] = 'V';</a>
<a name="ln1872">  if(g_file_test(result, G_FILE_TEST_EXISTS)) return result;</a>
<a name="ln1873"> </a>
<a name="ln1874">  g_free(result);</a>
<a name="ln1875">  return NULL;</a>
<a name="ln1876">}</a>
<a name="ln1877"> </a>
<a name="ln1878">char *dt_image_get_audio_path(const int32_t imgid)</a>
<a name="ln1879">{</a>
<a name="ln1880">  gboolean from_cache = FALSE;</a>
<a name="ln1881">  char image_path[PATH_MAX] = { 0 };</a>
<a name="ln1882">  dt_image_full_path(imgid, image_path, sizeof(image_path), &amp;from_cache);</a>
<a name="ln1883"> </a>
<a name="ln1884">  return dt_image_get_audio_path_from_path(image_path);</a>
<a name="ln1885">}</a>
<a name="ln1886"> </a>
<a name="ln1887">char *dt_image_get_text_path_from_path(const char *image_path)</a>
<a name="ln1888">{</a>
<a name="ln1889">  size_t len = strlen(image_path);</a>
<a name="ln1890">  const char *c = image_path + len;</a>
<a name="ln1891">  while((c &gt; image_path) &amp;&amp; (*c != '.')) c--;</a>
<a name="ln1892">  len = c - image_path + 1;</a>
<a name="ln1893"> </a>
<a name="ln1894">  char *result = g_strndup(image_path, len + 3);</a>
<a name="ln1895"> </a>
<a name="ln1896">  result[len] = 't';</a>
<a name="ln1897">  result[len + 1] = 'x';</a>
<a name="ln1898">  result[len + 2] = 't';</a>
<a name="ln1899">  if(g_file_test(result, G_FILE_TEST_EXISTS)) return result;</a>
<a name="ln1900"> </a>
<a name="ln1901">  result[len] = 'T';</a>
<a name="ln1902">  result[len + 1] = 'X';</a>
<a name="ln1903">  result[len + 2] = 'T';</a>
<a name="ln1904">  if(g_file_test(result, G_FILE_TEST_EXISTS)) return result;</a>
<a name="ln1905"> </a>
<a name="ln1906">  g_free(result);</a>
<a name="ln1907">  return NULL;</a>
<a name="ln1908">}</a>
<a name="ln1909"> </a>
<a name="ln1910">char *dt_image_get_text_path(const int32_t imgid)</a>
<a name="ln1911">{</a>
<a name="ln1912">  gboolean from_cache = FALSE;</a>
<a name="ln1913">  char image_path[PATH_MAX] = { 0 };</a>
<a name="ln1914">  dt_image_full_path(imgid, image_path, sizeof(image_path), &amp;from_cache);</a>
<a name="ln1915"> </a>
<a name="ln1916">  return dt_image_get_text_path_from_path(image_path);</a>
<a name="ln1917">}</a>
<a name="ln1918"> </a>
<a name="ln1919">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1920">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1921">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="153"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'numparts < 1' is always false.</p></div>
<div class="balloon" rel="1314"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="1380"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: gerror != NULL.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
