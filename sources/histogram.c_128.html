
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#include &lt;stdint.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/image_cache.h&quot;</a>
<a name="ln24">#include &quot;control/conf.h&quot;</a>
<a name="ln25">#include &quot;control/control.h&quot;</a>
<a name="ln26">#include &quot;develop/develop.h&quot;</a>
<a name="ln27">#include &quot;gui/draw.h&quot;</a>
<a name="ln28">#include &quot;gui/gtk.h&quot;</a>
<a name="ln29">#include &quot;libs/lib.h&quot;</a>
<a name="ln30">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">DT_MODULE(1)</a>
<a name="ln33"> </a>
<a name="ln34">#define DT_HIST_INSET 5</a>
<a name="ln35"> </a>
<a name="ln36">typedef struct dt_lib_histogram_t</a>
<a name="ln37">{</a>
<a name="ln38">  float exposure, black;</a>
<a name="ln39">  int32_t dragging;</a>
<a name="ln40">  int32_t button_down_x, button_down_y;</a>
<a name="ln41">  int32_t highlight;</a>
<a name="ln42">  gboolean red, green, blue;</a>
<a name="ln43">  float mode_x, mode_w, red_x, green_x, blue_x;</a>
<a name="ln44">  float color_w, button_h, button_y, button_spacing;</a>
<a name="ln45">} dt_lib_histogram_t;</a>
<a name="ln46"> </a>
<a name="ln47">static gboolean _lib_histogram_draw_callback(GtkWidget *widget, cairo_t *cr, gpointer user_data);</a>
<a name="ln48">static gboolean _lib_histogram_motion_notify_callback(GtkWidget *widget, GdkEventMotion *event,</a>
<a name="ln49">                                                      gpointer user_data);</a>
<a name="ln50">static gboolean _lib_histogram_button_press_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln51">                                                     gpointer user_data);</a>
<a name="ln52">static gboolean _lib_histogram_button_release_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln53">                                                       gpointer user_data);</a>
<a name="ln54">static gboolean _lib_histogram_scroll_callback(GtkWidget *widget, GdkEventScroll *event, gpointer user_data);</a>
<a name="ln55">static gboolean _lib_histogram_enter_notify_callback(GtkWidget *widget, GdkEventCrossing *event,</a>
<a name="ln56">                                                     gpointer user_data);</a>
<a name="ln57">static gboolean _lib_histogram_leave_notify_callback(GtkWidget *widget, GdkEventCrossing *event,</a>
<a name="ln58">                                                     gpointer user_data);</a>
<a name="ln59"> </a>
<a name="ln60">const char *name(dt_lib_module_t *self)</a>
<a name="ln61">{</a>
<a name="ln62">  return _(&quot;histogram&quot;);</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65">const char **views(dt_lib_module_t *self)</a>
<a name="ln66">{</a>
<a name="ln67">  static const char *v[] = {&quot;darkroom&quot;, &quot;tethering&quot;, NULL};</a>
<a name="ln68">  return v;</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln72">{</a>
<a name="ln73">  return DT_UI_CONTAINER_PANEL_RIGHT_TOP;</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">int expandable(dt_lib_module_t *self)</a>
<a name="ln77">{</a>
<a name="ln78">  return 0;</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">int position()</a>
<a name="ln82">{</a>
<a name="ln83">  return 1001;</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">static void _lib_histogram_change_callback(gpointer instance, gpointer user_data)</a>
<a name="ln88">{</a>
<a name="ln89">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln90">  dt_control_queue_redraw_widget(self-&gt;widget);</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">// WARNING: don't use this code as-is, it causes segfaults elsewhere!</a>
<a name="ln94">// static gboolean _lib_histogram_configure_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln95">// {</a>
<a name="ln96">//   dt_develop_t *dev = darktable.develop;</a>
<a name="ln97">//   dt_pthread_mutex_lock(&amp;dev-&gt;histogram_waveform_mutex);</a>
<a name="ln98">//</a>
<a name="ln99">//   int width = allocation.width;</a>
<a name="ln100">//   int height = allocation.height;</a>
<a name="ln101">//   width -= 2 * 4 * DT_HIST_INSET;</a>
<a name="ln102">//   height -= 2 * DT_HIST_INSET;</a>
<a name="ln103">//</a>
<a name="ln104">//   const gint stride = cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, width);</a>
<a name="ln105">//</a>
<a name="ln106">//   free(dev-&gt;histogram_waveform);</a>
<a name="ln107">//   dev-&gt;histogram_waveform = (uint32_t*)calloc(height * stride / 4, sizeof(uint32_t));</a>
<a name="ln108">//   dev-&gt;histogram_waveform_width = width;</a>
<a name="ln109">//   dev-&gt;histogram_waveform_height = height;</a>
<a name="ln110">//   dev-&gt;histogram_waveform_stride = stride;</a>
<a name="ln111">//</a>
<a name="ln112">//   dt_pthread_mutex_unlock(&amp;dev-&gt;histogram_waveform_mutex);</a>
<a name="ln113">//   return FALSE;</a>
<a name="ln114">// }</a>
<a name="ln115"> </a>
<a name="ln116">void gui_init(dt_lib_module_t *self)</a>
<a name="ln117">{</a>
<a name="ln118">  /* initialize ui widgets */</a>
<a name="ln119">  dt_lib_histogram_t *d = (dt_lib_histogram_t *)g_malloc0(sizeof(dt_lib_histogram_t));</a>
<a name="ln120">  self-&gt;data = (void *)d;</a>
<a name="ln121"> </a>
<a name="ln122">  d-&gt;red = dt_conf_get_bool(&quot;plugins/darkroom/histogram/show_red&quot;);</a>
<a name="ln123">  d-&gt;green = dt_conf_get_bool(&quot;plugins/darkroom/histogram/show_green&quot;);</a>
<a name="ln124">  d-&gt;blue = dt_conf_get_bool(&quot;plugins/darkroom/histogram/show_blue&quot;);</a>
<a name="ln125"> </a>
<a name="ln126">  /* create drawingarea */</a>
<a name="ln127">  self-&gt;widget = gtk_drawing_area_new();</a>
<a name="ln128">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln129"> </a>
<a name="ln130">  gtk_widget_add_events(self-&gt;widget, GDK_LEAVE_NOTIFY_MASK | GDK_ENTER_NOTIFY_MASK | GDK_POINTER_MOTION_MASK</a>
<a name="ln131">                                      | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |</a>
<a name="ln132">                                      //                         GDK_STRUCTURE_MASK |</a>
<a name="ln133">                                      darktable.gui-&gt;scroll_mask);</a>
<a name="ln134"> </a>
<a name="ln135">  /* connect callbacks */</a>
<a name="ln136">  gtk_widget_set_tooltip_text(self-&gt;widget, _(&quot;drag to change exposure,\ndoubleclick resets&quot;));</a>
<a name="ln137">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;draw&quot;, G_CALLBACK(_lib_histogram_draw_callback), self);</a>
<a name="ln138">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;button-press-event&quot;,</a>
<a name="ln139">                   G_CALLBACK(_lib_histogram_button_press_callback), self);</a>
<a name="ln140">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;button-release-event&quot;,</a>
<a name="ln141">                   G_CALLBACK(_lib_histogram_button_release_callback), self);</a>
<a name="ln142">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;motion-notify-event&quot;,</a>
<a name="ln143">                   G_CALLBACK(_lib_histogram_motion_notify_callback), self);</a>
<a name="ln144">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;leave-notify-event&quot;,</a>
<a name="ln145">                   G_CALLBACK(_lib_histogram_leave_notify_callback), self);</a>
<a name="ln146">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;enter-notify-event&quot;,</a>
<a name="ln147">                   G_CALLBACK(_lib_histogram_enter_notify_callback), self);</a>
<a name="ln148">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;scroll-event&quot;, G_CALLBACK(_lib_histogram_scroll_callback), self);</a>
<a name="ln149">  //   g_signal_connect (G_OBJECT (self-&gt;widget), &quot;configure-event&quot;,</a>
<a name="ln150">  //                     G_CALLBACK (_lib_histogram_configure_callback), self);</a>
<a name="ln151"> </a>
<a name="ln152">  /* set size of navigation draw area */</a>
<a name="ln153">  int panel_width = dt_conf_get_int(&quot;panel_width&quot;);</a>
<a name="ln154">  gtk_widget_set_size_request(self-&gt;widget, -1, panel_width * .5);</a>
<a name="ln155"> </a>
<a name="ln156">  /* connect to preview pipe finished  signal */</a>
<a name="ln157">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_PREVIEW_PIPE_FINISHED,</a>
<a name="ln158">                            G_CALLBACK(_lib_histogram_change_callback), self);</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln162">{</a>
<a name="ln163">  /* disconnect callback from  signal */</a>
<a name="ln164">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_histogram_change_callback), self);</a>
<a name="ln165"> </a>
<a name="ln166">  dt_develop_t *dev = darktable.develop;</a>
<a name="ln167"> </a>
<a name="ln168">  free(dev-&gt;histogram_waveform);</a>
<a name="ln169">  dev-&gt;histogram_waveform = NULL;</a>
<a name="ln170"> </a>
<a name="ln171">  dev-&gt;histogram_waveform_stride = 0;</a>
<a name="ln172">  dev-&gt;histogram_waveform_height = 0;</a>
<a name="ln173">  dev-&gt;histogram_waveform_width = 0;</a>
<a name="ln174"> </a>
<a name="ln175">  g_free(self-&gt;data);</a>
<a name="ln176">  self-&gt;data = NULL;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">static void _draw_color_toggle(cairo_t *cr, float x, float y, float width, float height, gboolean state)</a>
<a name="ln180">{</a>
<a name="ln181">  float border = MIN(width * .1, height * .1);</a>
<a name="ln182">  cairo_rectangle(cr, x + border, y + border, width - 2.0 * border, height - 2.0 * border);</a>
<a name="ln183">  cairo_fill_preserve(cr);</a>
<a name="ln184">  if(state)</a>
<a name="ln185">    cairo_set_source_rgba(cr, 1.0, 1.0, 1.0, 0.5);</a>
<a name="ln186">  else</a>
<a name="ln187">    cairo_set_source_rgba(cr, 0.0, 0.0, 0.0, 0.5);</a>
<a name="ln188">  cairo_set_line_width(cr, border);</a>
<a name="ln189">  cairo_stroke(cr);</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">static void _draw_mode_toggle(cairo_t *cr, float x, float y, float width, float height, int type)</a>
<a name="ln193">{</a>
<a name="ln194">  cairo_save(cr);</a>
<a name="ln195">  cairo_translate(cr, x, y);</a>
<a name="ln196"> </a>
<a name="ln197">  // border</a>
<a name="ln198">  float border = MIN(width * .1, height * .1);</a>
<a name="ln199">  cairo_set_source_rgba(cr, 0.0, 0.0, 0.0, 0.4);</a>
<a name="ln200">  cairo_rectangle(cr, border, border, width - 2.0 * border, height - 2.0 * border);</a>
<a name="ln201">  cairo_fill_preserve(cr);</a>
<a name="ln202">  cairo_set_source_rgba(cr, 0.0, 0.0, 0.0, 0.5);</a>
<a name="ln203">  cairo_set_line_width(cr, border);</a>
<a name="ln204">  cairo_stroke(cr);</a>
<a name="ln205"> </a>
<a name="ln206">  // icon</a>
<a name="ln207">  cairo_set_source_rgba(cr, 1.0, 1.0, 1.0, 0.5);</a>
<a name="ln208">  cairo_move_to(cr, 2.0 * border, height - 2.0 * border);</a>
<a name="ln209">  switch(type)</a>
<a name="ln210">  {</a>
<a name="ln211">    case DT_DEV_HISTOGRAM_LINEAR:</a>
<a name="ln212">      cairo_line_to(cr, width - 2.0 * border, 2.0 * border);</a>
<a name="ln213">      cairo_stroke(cr);</a>
<a name="ln214">      break;</a>
<a name="ln215">    case DT_DEV_HISTOGRAM_LOGARITHMIC:</a>
<a name="ln216">      cairo_curve_to(cr, 2.0 * border, 0.33 * height, 0.66 * width, 2.0 * border, width - 2.0 * border,</a>
<a name="ln217">                     2.0 * border);</a>
<a name="ln218">      cairo_stroke(cr);</a>
<a name="ln219">      break;</a>
<a name="ln220">    case DT_DEV_HISTOGRAM_WAVEFORM:</a>
<a name="ln221">    {</a>
<a name="ln222">      cairo_pattern_t *pattern;</a>
<a name="ln223">      pattern = cairo_pattern_create_linear(0.0, 1.5 * border, 0.0, height - 3.0 * border);</a>
<a name="ln224"> </a>
<a name="ln225">      cairo_pattern_add_color_stop_rgba(pattern, 0.0, 0.0, 0.0, 0.0, 0.5);</a>
<a name="ln226">      cairo_pattern_add_color_stop_rgba(pattern, 0.2, 0.2, 0.2, 0.2, 0.5);</a>
<a name="ln227">      cairo_pattern_add_color_stop_rgba(pattern, 0.5, 1.0, 1.0, 1.0, 0.5);</a>
<a name="ln228">      cairo_pattern_add_color_stop_rgba(pattern, 0.6, 1.0, 1.0, 1.0, 0.5);</a>
<a name="ln229">      cairo_pattern_add_color_stop_rgba(pattern, 1.0, 0.2, 0.2, 0.2, 0.5);</a>
<a name="ln230"> </a>
<a name="ln231">      cairo_rectangle(cr, 1.5 * border, 1.5 * border, (width - 3.0 * border) * 0.3, height - 3.0 * border);</a>
<a name="ln232">      cairo_set_source(cr, pattern);</a>
<a name="ln233">      cairo_fill(cr);</a>
<a name="ln234"> </a>
<a name="ln235">      cairo_save(cr);</a>
<a name="ln236">      cairo_scale(cr, 1, -1);</a>
<a name="ln237">      cairo_translate(cr, 0, -height);</a>
<a name="ln238">      cairo_rectangle(cr, 1.5 * border + (width - 3.0 * border) * 0.2, 1.5 * border,</a>
<a name="ln239">                      (width - 3.0 * border) * 0.6, height - 3.0 * border);</a>
<a name="ln240">      cairo_set_source(cr, pattern);</a>
<a name="ln241">      cairo_fill(cr);</a>
<a name="ln242">      cairo_restore(cr);</a>
<a name="ln243"> </a>
<a name="ln244">      cairo_rectangle(cr, 1.5 * border + (width - 3.0 * border) * 0.7, 1.5 * border,</a>
<a name="ln245">                      (width - 3.0 * border) * 0.3, height - 3.0 * border);</a>
<a name="ln246">      cairo_set_source(cr, pattern);</a>
<a name="ln247">      cairo_fill(cr);</a>
<a name="ln248"> </a>
<a name="ln249">      cairo_pattern_destroy(pattern);</a>
<a name="ln250">      break;</a>
<a name="ln251">    }</a>
<a name="ln252">  }</a>
<a name="ln253">  cairo_restore(cr);</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">static gboolean _lib_histogram_draw_callback(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln257">{</a>
<a name="ln258">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln259">  dt_lib_histogram_t *d = (dt_lib_histogram_t *)self-&gt;data;</a>
<a name="ln260"> </a>
<a name="ln261">  dt_develop_t *dev = darktable.develop;</a>
<a name="ln262">  uint32_t *hist = dev-&gt;histogram;</a>
<a name="ln263">  float hist_max = dev-&gt;histogram_type == DT_DEV_HISTOGRAM_LINEAR ? dev-&gt;histogram_max</a>
<a name="ln264">                                                                  : logf(1.0 + dev-&gt;histogram_max);</a>
<a name="ln265">  const int inset = DT_HIST_INSET;</a>
<a name="ln266">  GtkAllocation allocation;</a>
<a name="ln267">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln268">  int width = allocation.width, height = allocation.height;</a>
<a name="ln269">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln270">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln271"> </a>
<a name="ln272">  gtk_render_background(gtk_widget_get_style_context(widget), cr, 0, 0, allocation.width, allocation.height);</a>
<a name="ln273"> </a>
<a name="ln274">  cairo_translate(cr, 4 * inset, inset);</a>
<a name="ln275">  width -= 2 * 4 * inset;</a>
<a name="ln276">  height -= 2 * inset;</a>
<a name="ln277"> </a>
<a name="ln278">  if(d-&gt;mode_x == 0)</a>
<a name="ln279">  {</a>
<a name="ln280">    d-&gt;color_w = 0.06 * width;</a>
<a name="ln281">    d-&gt;button_spacing = 0.01 * width;</a>
<a name="ln282">    d-&gt;button_h = 0.06 * width;</a>
<a name="ln283">    d-&gt;button_y = d-&gt;button_spacing;</a>
<a name="ln284">    d-&gt;mode_w = d-&gt;color_w;</a>
<a name="ln285">    d-&gt;mode_x = width - 3 * (d-&gt;color_w + d-&gt;button_spacing) - (d-&gt;mode_w + d-&gt;button_spacing);</a>
<a name="ln286">    d-&gt;red_x = width - 3 * (d-&gt;color_w + d-&gt;button_spacing);</a>
<a name="ln287">    d-&gt;green_x = width - 2 * (d-&gt;color_w + d-&gt;button_spacing);</a>
<a name="ln288">    d-&gt;blue_x = width - (d-&gt;color_w + d-&gt;button_spacing);</a>
<a name="ln289">  }</a>
<a name="ln290"> </a>
<a name="ln291">  // TODO: probably this should move to the configure-event callback! That would be future proof if we ever</a>
<a name="ln292">  // (again) allow to resize the side panels.</a>
<a name="ln293">  const gint stride = cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, width);</a>
<a name="ln294"> </a>
<a name="ln295">  // this code assumes that the first expose comes before the first (preview) pipe is processed and that the</a>
<a name="ln296">  // size of the widget doesn't change!</a>
<a name="ln297">  if(dev-&gt;histogram_waveform_width == 0)</a>
<a name="ln298">  {</a>
<a name="ln299">    dev-&gt;histogram_waveform = (uint32_t *)calloc(height * stride / 4, sizeof(uint32_t));</a>
<a name="ln300">    dev-&gt;histogram_waveform_stride = stride;</a>
<a name="ln301">    dev-&gt;histogram_waveform_height = height;</a>
<a name="ln302">    dev-&gt;histogram_waveform_width = width;</a>
<a name="ln303">    //     return TRUE; // there are enough expose events following ...</a>
<a name="ln304">  }</a>
<a name="ln305"> </a>
<a name="ln306">#if 1</a>
<a name="ln307">  // draw shadow around</a>
<a name="ln308">  float alpha = 1.0f;</a>
<a name="ln309">  cairo_set_line_width(cr, 0.2);</a>
<a name="ln310">  for(int k = 0; k &lt; inset; k++)</a>
<a name="ln311">  {</a>
<a name="ln312">    cairo_rectangle(cr, -k, -k, width + 2 * k, height + 2 * k);</a>
<a name="ln313">    cairo_set_source_rgba(cr, 0, 0, 0, alpha);</a>
<a name="ln314">    alpha *= 0.5f;</a>
<a name="ln315">    cairo_fill(cr);</a>
<a name="ln316">  }</a>
<a name="ln317">  cairo_set_line_width(cr, 1.0);</a>
<a name="ln318">#else</a>
<a name="ln319">  cairo_set_line_width(cr, 1.0);</a>
<a name="ln320">  cairo_set_source_rgb(cr, .1, .1, .1);</a>
<a name="ln321">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln322">  cairo_stroke(cr);</a>
<a name="ln323">#endif</a>
<a name="ln324"> </a>
<a name="ln325">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln326">  cairo_clip(cr);</a>
<a name="ln327"> </a>
<a name="ln328">  cairo_set_source_rgb(cr, .3, .3, .3);</a>
<a name="ln329">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln330">  cairo_fill(cr);</a>
<a name="ln331">  if(d-&gt;highlight == 1)</a>
<a name="ln332">  {</a>
<a name="ln333">    cairo_set_source_rgb(cr, .5, .5, .5);</a>
<a name="ln334">    cairo_rectangle(cr, 0, 0, .2 * width, height);</a>
<a name="ln335">    cairo_fill(cr);</a>
<a name="ln336">  }</a>
<a name="ln337">  else if(d-&gt;highlight == 2)</a>
<a name="ln338">  {</a>
<a name="ln339">    cairo_set_source_rgb(cr, .5, .5, .5);</a>
<a name="ln340">    cairo_rectangle(cr, 0.2 * width, 0, width, height);</a>
<a name="ln341">    cairo_fill(cr);</a>
<a name="ln342">  }</a>
<a name="ln343"> </a>
<a name="ln344">  // draw grid</a>
<a name="ln345">  cairo_set_line_width(cr, .4);</a>
<a name="ln346">  cairo_set_source_rgb(cr, .1, .1, .1);</a>
<a name="ln347">  if(dev-&gt;histogram_type == DT_DEV_HISTOGRAM_WAVEFORM)</a>
<a name="ln348">    dt_draw_waveform_lines(cr, 0, 0, width, height);</a>
<a name="ln349">  else</a>
<a name="ln350">    dt_draw_grid(cr, 4, 0, 0, width, height);</a>
<a name="ln351"> </a>
<a name="ln352">  if(hist_max &gt; 0.0f)</a>
<a name="ln353">  {</a>
<a name="ln354">    cairo_save(cr);</a>
<a name="ln355">    if(dev-&gt;histogram_type == DT_DEV_HISTOGRAM_WAVEFORM)</a>
<a name="ln356">    {</a>
<a name="ln357">      // make the color channel selector work:</a>
<a name="ln358">      uint8_t *buf = (uint8_t *)malloc(sizeof(uint8_t) * height * stride);</a>
<a name="ln359">      uint8_t mask[3] = { d-&gt;blue, d-&gt;green, d-&gt;red };</a>
<a name="ln360">      memcpy(buf, dev-&gt;histogram_waveform, sizeof(uint8_t) * height * stride);</a>
<a name="ln361">      for(int y = 0; y &lt; height; y++)</a>
<a name="ln362">        for(int x = 0; x &lt; width; x++)</a>
<a name="ln363">          for(int k = 0; k &lt; 3; k++)</a>
<a name="ln364">          {</a>
<a name="ln365">            buf[y * stride + x * 4 + k] *= mask[k];</a>
<a name="ln366">          }</a>
<a name="ln367"> </a>
<a name="ln368">      cairo_surface_t *source</a>
<a name="ln369">          = cairo_image_surface_create_for_data(buf, CAIRO_FORMAT_ARGB32, width, height, stride);</a>
<a name="ln370"> </a>
<a name="ln371">      cairo_set_source_surface(cr, source, 0.0, 0.0);</a>
<a name="ln372">      cairo_set_operator(cr, CAIRO_OPERATOR_ADD);</a>
<a name="ln373">      cairo_paint(cr);</a>
<a name="ln374">      cairo_surface_destroy(source);</a>
<a name="ln375">      free(buf);</a>
<a name="ln376">    }</a>
<a name="ln377">    else</a>
<a name="ln378">    {</a>
<a name="ln379">      // cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE);</a>
<a name="ln380">      cairo_translate(cr, 0, height);</a>
<a name="ln381">      cairo_scale(cr, width / 255.0, -(height - 10) / hist_max);</a>
<a name="ln382">      cairo_set_operator(cr, CAIRO_OPERATOR_ADD);</a>
<a name="ln383">      // cairo_set_operator(cr, CAIRO_OPERATOR_OVER);</a>
<a name="ln384">      cairo_set_line_width(cr, 1.);</a>
<a name="ln385">      if(d-&gt;red)</a>
<a name="ln386">      {</a>
<a name="ln387">        cairo_set_source_rgba(cr, 1., 0., 0., 0.2);</a>
<a name="ln388">        dt_draw_histogram_8(cr, hist, 4, 0, dev-&gt;histogram_type == DT_DEV_HISTOGRAM_LINEAR);</a>
<a name="ln389">      }</a>
<a name="ln390">      if(d-&gt;green)</a>
<a name="ln391">      {</a>
<a name="ln392">        cairo_set_source_rgba(cr, 0., 1., 0., 0.2);</a>
<a name="ln393">        dt_draw_histogram_8(cr, hist, 4, 1, dev-&gt;histogram_type == DT_DEV_HISTOGRAM_LINEAR);</a>
<a name="ln394">      }</a>
<a name="ln395">      if(d-&gt;blue)</a>
<a name="ln396">      {</a>
<a name="ln397">        cairo_set_source_rgba(cr, 0., 0., 1., 0.2);</a>
<a name="ln398">        dt_draw_histogram_8(cr, hist, 4, 2, dev-&gt;histogram_type == DT_DEV_HISTOGRAM_LINEAR);</a>
<a name="ln399">      }</a>
<a name="ln400">      cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);</a>
<a name="ln401">      // cairo_set_antialias(cr, CAIRO_ANTIALIAS_DEFAULT);</a>
<a name="ln402">    }</a>
<a name="ln403">    cairo_restore(cr);</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  cairo_set_source_rgb(cr, .25, .25, .25);</a>
<a name="ln407">  cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);</a>
<a name="ln408">  PangoLayout *layout;</a>
<a name="ln409">  PangoRectangle ink;</a>
<a name="ln410">  PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln411">  pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln412">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln413">  pango_font_description_set_absolute_size(desc, .1 * height * PANGO_SCALE);</a>
<a name="ln414">  pango_layout_set_font_description(layout, desc);</a>
<a name="ln415"> </a>
<a name="ln416">  char exifline[50];</a>
<a name="ln417">  dt_image_print_exif(&amp;dev-&gt;image_storage, exifline, sizeof(exifline));</a>
<a name="ln418"> </a>
<a name="ln419">  pango_layout_set_text(layout, exifline, -1);</a>
<a name="ln420">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln421">  cairo_move_to(cr, .02 * width, .98 * height - ink.height - ink.y);</a>
<a name="ln422">  cairo_save(cr);</a>
<a name="ln423">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0));</a>
<a name="ln424">  cairo_set_source_rgba(cr, 1, 1, 1, 0.3);</a>
<a name="ln425">  pango_cairo_layout_path(cr, layout);</a>
<a name="ln426">  cairo_stroke_preserve(cr);</a>
<a name="ln427">  cairo_set_source_rgb(cr, .25, .25, .25);</a>
<a name="ln428">  cairo_fill(cr);</a>
<a name="ln429">  cairo_restore(cr);</a>
<a name="ln430"> </a>
<a name="ln431">  // buttons to control the display of the histogram: linear/log, r, g, b</a>
<a name="ln432">  if(d-&gt;highlight != 0)</a>
<a name="ln433">  {</a>
<a name="ln434">    _draw_mode_toggle(cr, d-&gt;mode_x, d-&gt;button_y, d-&gt;mode_w, d-&gt;button_h, dev-&gt;histogram_type);</a>
<a name="ln435">    cairo_set_source_rgba(cr, 1.0, 0.0, 0.0, 0.4);</a>
<a name="ln436">    _draw_color_toggle(cr, d-&gt;red_x, d-&gt;button_y, d-&gt;color_w, d-&gt;button_h, d-&gt;red);</a>
<a name="ln437">    cairo_set_source_rgba(cr, 0.0, 1.0, 0.0, 0.4);</a>
<a name="ln438">    _draw_color_toggle(cr, d-&gt;green_x, d-&gt;button_y, d-&gt;color_w, d-&gt;button_h, d-&gt;green);</a>
<a name="ln439">    cairo_set_source_rgba(cr, 0.0, 0.0, 1.0, 0.4);</a>
<a name="ln440">    _draw_color_toggle(cr, d-&gt;blue_x, d-&gt;button_y, d-&gt;color_w, d-&gt;button_h, d-&gt;blue);</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443">  cairo_destroy(cr);</a>
<a name="ln444">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln445">  cairo_paint(crf);</a>
<a name="ln446">  cairo_surface_destroy(cst);</a>
<a name="ln447">  pango_font_description_free(desc);</a>
<a name="ln448">  g_object_unref(layout);</a>
<a name="ln449">  return TRUE;</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">static gboolean _lib_histogram_motion_notify_callback(GtkWidget *widget, GdkEventMotion *event,</a>
<a name="ln453">                                                      gpointer user_data)</a>
<a name="ln454">{</a>
<a name="ln455">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln456">  dt_lib_histogram_t *d = (dt_lib_histogram_t *)self-&gt;data;</a>
<a name="ln457"> </a>
<a name="ln458">  /* check if exposure hooks are available */</a>
<a name="ln459">  gboolean hooks_available = dt_dev_exposure_hooks_available(darktable.develop);</a>
<a name="ln460"> </a>
<a name="ln461">  if(!hooks_available) return TRUE;</a>
<a name="ln462"> </a>
<a name="ln463">  GtkAllocation allocation;</a>
<a name="ln464">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln465">  if(d-&gt;dragging &amp;&amp; d-&gt;highlight == 2)</a>
<a name="ln466">  {</a>
<a name="ln467">    float exposure = d-&gt;exposure + (event-&gt;x - d-&gt;button_down_x) * 4.0f / (float)allocation.width;</a>
<a name="ln468">    dt_dev_exposure_set_exposure(darktable.develop, exposure);</a>
<a name="ln469">  }</a>
<a name="ln470">  else if(d-&gt;dragging &amp;&amp; d-&gt;highlight == 1)</a>
<a name="ln471">  {</a>
<a name="ln472">    float black = d-&gt;black - (event-&gt;x - d-&gt;button_down_x) * .1f / (float)allocation.width;</a>
<a name="ln473">    dt_dev_exposure_set_black(darktable.develop, black);</a>
<a name="ln474">  }</a>
<a name="ln475">  else</a>
<a name="ln476">  {</a>
<a name="ln477">    const float offs = 4 * DT_HIST_INSET;</a>
<a name="ln478">    const float x = event-&gt;x - offs;</a>
<a name="ln479">    const float y = event-&gt;y - DT_HIST_INSET;</a>
<a name="ln480">    const float pos = x / (float)(allocation.width - 2 * offs);</a>
<a name="ln481"> </a>
<a name="ln482"> </a>
<a name="ln483">    if(pos &lt; 0 || pos &gt; 1.0)</a>
<a name="ln484">      ;</a>
<a name="ln485">    else if(x &gt; d-&gt;mode_x &amp;&amp; x &lt; d-&gt;mode_x + d-&gt;mode_w &amp;&amp; y &gt; d-&gt;button_y &amp;&amp; y &lt; d-&gt;button_y + d-&gt;button_h)</a>
<a name="ln486">    {</a>
<a name="ln487">      d-&gt;highlight = 3;</a>
<a name="ln488">      switch(darktable.develop-&gt;histogram_type)</a>
<a name="ln489">      {</a>
<a name="ln490">        case DT_DEV_HISTOGRAM_LOGARITHMIC:</a>
<a name="ln491">          gtk_widget_set_tooltip_text(widget, _(&quot;set histogram mode to linear&quot;));</a>
<a name="ln492">          break;</a>
<a name="ln493">        case DT_DEV_HISTOGRAM_LINEAR:</a>
<a name="ln494">          gtk_widget_set_tooltip_text(widget, _(&quot;set histogram mode to waveform&quot;));</a>
<a name="ln495">          break;</a>
<a name="ln496">        case DT_DEV_HISTOGRAM_WAVEFORM:</a>
<a name="ln497">          gtk_widget_set_tooltip_text(widget, _(&quot;set histogram mode to logarithmic&quot;));</a>
<a name="ln498">          break;</a>
<a name="ln499">        case DT_DEV_HISTOGRAM_N:</a>
<a name="ln500">          g_assert_not_reached();</a>
<a name="ln501">      }</a>
<a name="ln502">    }</a>
<a name="ln503">    else if(x &gt; d-&gt;red_x &amp;&amp; x &lt; d-&gt;red_x + d-&gt;color_w &amp;&amp; y &gt; d-&gt;button_y &amp;&amp; y &lt; d-&gt;button_y + d-&gt;button_h)</a>
<a name="ln504">    {</a>
<a name="ln505">      d-&gt;highlight = 4;</a>
<a name="ln506">      gtk_widget_set_tooltip_text(widget, d-&gt;red ? _(&quot;click to hide red channel&quot;) : _(&quot;click to show red channel&quot;));</a>
<a name="ln507">    }</a>
<a name="ln508">    else if(x &gt; d-&gt;green_x &amp;&amp; x &lt; d-&gt;green_x + d-&gt;color_w &amp;&amp; y &gt; d-&gt;button_y &amp;&amp; y &lt; d-&gt;button_y + d-&gt;button_h)</a>
<a name="ln509">    {</a>
<a name="ln510">      d-&gt;highlight = 5;</a>
<a name="ln511">      gtk_widget_set_tooltip_text(widget, d-&gt;red ? _(&quot;click to hide green channel&quot;)</a>
<a name="ln512">                                                 : _(&quot;click to show green channel&quot;));</a>
<a name="ln513">    }</a>
<a name="ln514">    else if(x &gt; d-&gt;blue_x &amp;&amp; x &lt; d-&gt;blue_x + d-&gt;color_w &amp;&amp; y &gt; d-&gt;button_y &amp;&amp; y &lt; d-&gt;button_y + d-&gt;button_h)</a>
<a name="ln515">    {</a>
<a name="ln516">      d-&gt;highlight = 6;</a>
<a name="ln517">      gtk_widget_set_tooltip_text(widget, d-&gt;red ? _(&quot;click to hide blue channel&quot;) : _(&quot;click to show blue channel&quot;));</a>
<a name="ln518">    }</a>
<a name="ln519">    else if(pos &lt; 0.2)</a>
<a name="ln520">    {</a>
<a name="ln521">      d-&gt;highlight = 1;</a>
<a name="ln522">      gtk_widget_set_tooltip_text(widget, _(&quot;drag to change black point,\ndoubleclick resets&quot;));</a>
<a name="ln523">    }</a>
<a name="ln524">    else</a>
<a name="ln525">    {</a>
<a name="ln526">      d-&gt;highlight = 2;</a>
<a name="ln527">      gtk_widget_set_tooltip_text(widget, _(&quot;drag to change exposure,\ndoubleclick resets&quot;));</a>
<a name="ln528">    }</a>
<a name="ln529">    gtk_widget_queue_draw(widget);</a>
<a name="ln530">  }</a>
<a name="ln531">  gint x, y; // notify gtk for motion_hint.</a>
<a name="ln532">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln533">  gdk_window_get_device_position(gtk_widget_get_window(widget),</a>
<a name="ln534">      gdk_seat_get_pointer(gdk_display_get_default_seat(</a>
<a name="ln535">          gdk_window_get_display(event-&gt;window))),</a>
<a name="ln536">      &amp;x, &amp;y, 0);</a>
<a name="ln537">#else</a>
<a name="ln538">  gdk_window_get_device_position(event-&gt;window,</a>
<a name="ln539">                                 gdk_device_manager_get_client_pointer(</a>
<a name="ln540">                                     gdk_display_get_device_manager(gdk_window_get_display(event-&gt;window))),</a>
<a name="ln541">                                 &amp;x, &amp;y, NULL);</a>
<a name="ln542">#endif</a>
<a name="ln543"> </a>
<a name="ln544">  return TRUE;</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">static gboolean _lib_histogram_button_press_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln548">                                                     gpointer user_data)</a>
<a name="ln549">{</a>
<a name="ln550">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln551">  dt_lib_histogram_t *d = (dt_lib_histogram_t *)self-&gt;data;</a>
<a name="ln552"> </a>
<a name="ln553">  /* check if exposure hooks are available */</a>
<a name="ln554">  gboolean hooks_available = dt_dev_exposure_hooks_available(darktable.develop);</a>
<a name="ln555"> </a>
<a name="ln556">  if(!hooks_available) return TRUE;</a>
<a name="ln557"> </a>
<a name="ln558">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln559">  {</a>
<a name="ln560">    dt_dev_exposure_reset_defaults(darktable.develop);</a>
<a name="ln561">  }</a>
<a name="ln562">  else</a>
<a name="ln563">  {</a>
<a name="ln564">    if(d-&gt;highlight == 3) // mode button</a>
<a name="ln565">    {</a>
<a name="ln566">      darktable.develop-&gt;histogram_type = (darktable.develop-&gt;histogram_type + 1) % DT_DEV_HISTOGRAM_N;</a>
<a name="ln567">      dt_conf_set_string(&quot;plugins/darkroom/histogram/mode&quot;,</a>
<a name="ln568">                         dt_dev_histogram_type_names[darktable.develop-&gt;histogram_type]);</a>
<a name="ln569">    }</a>
<a name="ln570">    else if(d-&gt;highlight == 4) // red button</a>
<a name="ln571">    {</a>
<a name="ln572">      d-&gt;red = !d-&gt;red;</a>
<a name="ln573">      dt_conf_set_bool(&quot;plugins/darkroom/histogram/show_red&quot;, d-&gt;red);</a>
<a name="ln574">    }</a>
<a name="ln575">    else if(d-&gt;highlight == 5) // green button</a>
<a name="ln576">    {</a>
<a name="ln577">      d-&gt;green = !d-&gt;green;</a>
<a name="ln578">      dt_conf_set_bool(&quot;plugins/darkroom/histogram/show_green&quot;, d-&gt;green);</a>
<a name="ln579">    }</a>
<a name="ln580">    else if(d-&gt;highlight == 6) // blue button</a>
<a name="ln581">    {</a>
<a name="ln582">      d-&gt;blue = !d-&gt;blue;</a>
<a name="ln583">      dt_conf_set_bool(&quot;plugins/darkroom/histogram/show_blue&quot;, d-&gt;blue);</a>
<a name="ln584">    }</a>
<a name="ln585">    else</a>
<a name="ln586">    {</a>
<a name="ln587">      d-&gt;dragging = 1;</a>
<a name="ln588"> </a>
<a name="ln589">      if(d-&gt;highlight == 2) d-&gt;exposure = dt_dev_exposure_get_exposure(darktable.develop);</a>
<a name="ln590"> </a>
<a name="ln591">      if(d-&gt;highlight == 1) d-&gt;black = dt_dev_exposure_get_black(darktable.develop);</a>
<a name="ln592"> </a>
<a name="ln593">      d-&gt;button_down_x = event-&gt;x;</a>
<a name="ln594">      d-&gt;button_down_y = event-&gt;y;</a>
<a name="ln595">    }</a>
<a name="ln596">  }</a>
<a name="ln597">  // update for good measure</a>
<a name="ln598">  dt_control_queue_redraw_widget(self-&gt;widget);</a>
<a name="ln599"> </a>
<a name="ln600">  return TRUE;</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">static gboolean _lib_histogram_scroll_callback(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln604">{</a>
<a name="ln605">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln606">  dt_lib_histogram_t *d = (dt_lib_histogram_t *)self-&gt;data;</a>
<a name="ln607"> </a>
<a name="ln608">  float ce = dt_dev_exposure_get_exposure(darktable.develop);</a>
<a name="ln609">  float cb = dt_dev_exposure_get_black(darktable.develop);</a>
<a name="ln610"> </a>
<a name="ln611">  int delta_y;</a>
<a name="ln612">  // note are using unit rather than smooth scroll events, as</a>
<a name="ln613">  // exposure changes can get laggy if handling a multitude of smooth</a>
<a name="ln614">  // scroll events</a>
<a name="ln615">  if(dt_gui_get_scroll_unit_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln616">  {</a>
<a name="ln617">    if(d-&gt;highlight == 2)</a>
<a name="ln618">      dt_dev_exposure_set_exposure(darktable.develop, ce - 0.15f * delta_y);</a>
<a name="ln619">    else if(d-&gt;highlight == 1)</a>
<a name="ln620">      dt_dev_exposure_set_black(darktable.develop, cb + 0.001f * delta_y);</a>
<a name="ln621">  }</a>
<a name="ln622"> </a>
<a name="ln623">  return TRUE;</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">static gboolean _lib_histogram_button_release_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln627">                                                       gpointer user_data)</a>
<a name="ln628">{</a>
<a name="ln629">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln630">  dt_lib_histogram_t *d = (dt_lib_histogram_t *)self-&gt;data;</a>
<a name="ln631">  d-&gt;dragging = 0;</a>
<a name="ln632">  return TRUE;</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">static gboolean _lib_histogram_enter_notify_callback(GtkWidget *widget, GdkEventCrossing *event,</a>
<a name="ln636">                                                     gpointer user_data)</a>
<a name="ln637">{</a>
<a name="ln638">  dt_control_change_cursor(GDK_HAND1);</a>
<a name="ln639">  return TRUE;</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">static gboolean _lib_histogram_leave_notify_callback(GtkWidget *widget, GdkEventCrossing *event,</a>
<a name="ln643">                                                     gpointer user_data)</a>
<a name="ln644">{</a>
<a name="ln645">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln646">  dt_lib_histogram_t *d = (dt_lib_histogram_t *)self-&gt;data;</a>
<a name="ln647">  d-&gt;dragging = 0;</a>
<a name="ln648">  d-&gt;highlight = 0;</a>
<a name="ln649">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln650">  gtk_widget_queue_draw(widget);</a>
<a name="ln651">  return TRUE;</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln655">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln656">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="360"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 360, 358.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
