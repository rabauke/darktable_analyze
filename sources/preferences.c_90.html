
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">   This file is part of darktable,</a>
<a name="ln3">   copyright (c) 2012 Jeremy Rosen</a>
<a name="ln4"> </a>
<a name="ln5">   darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">   it under the terms of the GNU General Public License as published by</a>
<a name="ln7">   the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">   (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">   darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">   but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">   GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">   You should have received a copy of the GNU General Public License</a>
<a name="ln16">   along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17"> */</a>
<a name="ln18">#include &quot;lua/preferences.h&quot;</a>
<a name="ln19">#include &quot;control/conf.h&quot;</a>
<a name="ln20">#include &quot;gui/gtk.h&quot;</a>
<a name="ln21">#include &quot;lua/call.h&quot;</a>
<a name="ln22">#include &quot;lua/widget/widget.h&quot;</a>
<a name="ln23">#include &lt;glib.h&gt;</a>
<a name="ln24">#include &lt;stdlib.h&gt;</a>
<a name="ln25">#include &lt;string.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">typedef enum</a>
<a name="ln28">{</a>
<a name="ln29">  pref_enum,</a>
<a name="ln30">  pref_dir,</a>
<a name="ln31">  pref_file,</a>
<a name="ln32">  pref_string,</a>
<a name="ln33">  pref_bool,</a>
<a name="ln34">  pref_int,</a>
<a name="ln35">  pref_float,</a>
<a name="ln36">  pref_lua,</a>
<a name="ln37">} lua_pref_type;</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">typedef struct enum_data_t</a>
<a name="ln41">{</a>
<a name="ln42">  char *default_value;</a>
<a name="ln43">  luaA_Type enum_type;</a>
<a name="ln44">} enum_data_t;</a>
<a name="ln45">typedef struct dir_data_t</a>
<a name="ln46">{</a>
<a name="ln47">  char *default_value;</a>
<a name="ln48">} dir_data_t;</a>
<a name="ln49">typedef struct file_data_t</a>
<a name="ln50">{</a>
<a name="ln51">  char *default_value;</a>
<a name="ln52">} file_data_t;</a>
<a name="ln53">typedef struct string_data_t</a>
<a name="ln54">{</a>
<a name="ln55">  char *default_value;</a>
<a name="ln56">} string_data_t;</a>
<a name="ln57">typedef struct bool_data_t</a>
<a name="ln58">{</a>
<a name="ln59">  gboolean default_value;</a>
<a name="ln60">} bool_data_t;</a>
<a name="ln61">typedef struct int_data_t</a>
<a name="ln62">{</a>
<a name="ln63">  int default_value;</a>
<a name="ln64">} int_data_t;</a>
<a name="ln65"> </a>
<a name="ln66">typedef struct float_data_t</a>
<a name="ln67">{</a>
<a name="ln68">  float default_value;</a>
<a name="ln69">} float_data_t;</a>
<a name="ln70">typedef struct lua_data_t</a>
<a name="ln71">{</a>
<a name="ln72">  char *default_value;</a>
<a name="ln73">} lua_data_t;</a>
<a name="ln74"> </a>
<a name="ln75">typedef union all_data_t</a>
<a name="ln76">{</a>
<a name="ln77">  enum_data_t enum_data;</a>
<a name="ln78">  dir_data_t dir_data;</a>
<a name="ln79">  file_data_t file_data;</a>
<a name="ln80">  string_data_t string_data;</a>
<a name="ln81">  bool_data_t bool_data;</a>
<a name="ln82">  int_data_t int_data;</a>
<a name="ln83">  float_data_t float_data;</a>
<a name="ln84">  lua_data_t lua_data;</a>
<a name="ln85">} all_data_t;</a>
<a name="ln86"> </a>
<a name="ln87">struct pref_element;</a>
<a name="ln88">typedef void (update_widget_function)(struct pref_element* ,GtkWidget* ,GtkWidget* );</a>
<a name="ln89">static void update_widget_enum(struct pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev);</a>
<a name="ln90">static void update_widget_dir(struct pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev);</a>
<a name="ln91">static void update_widget_file(struct pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev);</a>
<a name="ln92">static void update_widget_string(struct pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev);</a>
<a name="ln93">static void update_widget_bool(struct pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev);</a>
<a name="ln94">static void update_widget_int(struct pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev);</a>
<a name="ln95">static void update_widget_float(struct pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev);</a>
<a name="ln96">static void update_widget_lua(struct pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev);</a>
<a name="ln97"> </a>
<a name="ln98">typedef struct pref_element</a>
<a name="ln99">{</a>
<a name="ln100">  char *script;</a>
<a name="ln101">  char *name;</a>
<a name="ln102">  char *label;</a>
<a name="ln103">  char *tooltip;</a>
<a name="ln104">  char *tooltip_reset;</a>
<a name="ln105">  lua_pref_type type;</a>
<a name="ln106">  struct pref_element *next;</a>
<a name="ln107">  all_data_t type_data;</a>
<a name="ln108">  // The widget used for this preference</a>
<a name="ln109">  GtkWidget *widget;</a>
<a name="ln110">  update_widget_function* update_widget;</a>
<a name="ln111"> </a>
<a name="ln112"> </a>
<a name="ln113">} pref_element;</a>
<a name="ln114"> </a>
<a name="ln115">static void destroy_pref_element(pref_element *elt)</a>
<a name="ln116">{</a>
<a name="ln117">  free(elt-&gt;script);</a>
<a name="ln118">  free(elt-&gt;name);</a>
<a name="ln119">  free(elt-&gt;label);</a>
<a name="ln120">  free(elt-&gt;tooltip);</a>
<a name="ln121">  free(elt-&gt;tooltip_reset);</a>
<a name="ln122">  if(elt-&gt;widget) g_object_unref(elt-&gt;widget);</a>
<a name="ln123">  switch(elt-&gt;type)</a>
<a name="ln124">  {</a>
<a name="ln125">    case pref_enum:</a>
<a name="ln126">      free(elt-&gt;type_data.enum_data.default_value);</a>
<a name="ln127">      break;</a>
<a name="ln128">    case pref_dir:</a>
<a name="ln129">      free(elt-&gt;type_data.dir_data.default_value);</a>
<a name="ln130">      break;</a>
<a name="ln131">    case pref_file:</a>
<a name="ln132">      free(elt-&gt;type_data.file_data.default_value);</a>
<a name="ln133">      break;</a>
<a name="ln134">    case pref_string:</a>
<a name="ln135">      free(elt-&gt;type_data.string_data.default_value);</a>
<a name="ln136">      break;</a>
<a name="ln137">    case pref_lua:</a>
<a name="ln138">      free(elt-&gt;type_data.lua_data.default_value);</a>
<a name="ln139">      break;</a>
<a name="ln140">    case pref_bool:</a>
<a name="ln141">    case pref_int:</a>
<a name="ln142">    case pref_float:</a>
<a name="ln143">    default:</a>
<a name="ln144">      break;</a>
<a name="ln145">  }</a>
<a name="ln146">  free(elt);</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">static pref_element *pref_list = NULL;</a>
<a name="ln150"> </a>
<a name="ln151">static void get_pref_name(char *tgt, size_t size, const char *script, const char *name)</a>
<a name="ln152">{</a>
<a name="ln153">  snprintf(tgt, size, &quot;lua/%s/%s&quot;, script, name);</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">static int read_pref(lua_State *L)</a>
<a name="ln157">{</a>
<a name="ln158">  const char *script = luaL_checkstring(L, 1);</a>
<a name="ln159">  const char *name = luaL_checkstring(L, 2);</a>
<a name="ln160">  lua_pref_type i;</a>
<a name="ln161">  luaA_to(L, lua_pref_type, &amp;i, 3);</a>
<a name="ln162"> </a>
<a name="ln163">  char pref_name[1024];</a>
<a name="ln164">  get_pref_name(pref_name, sizeof(pref_name), script, name);</a>
<a name="ln165">  switch(i)</a>
<a name="ln166">  {</a>
<a name="ln167">    case pref_enum:</a>
<a name="ln168">    {</a>
<a name="ln169">      char *str = dt_conf_get_string(pref_name);</a>
<a name="ln170">      lua_pushstring(L, str);</a>
<a name="ln171">      g_free(str);</a>
<a name="ln172">      break;</a>
<a name="ln173">    }</a>
<a name="ln174">    case pref_dir:</a>
<a name="ln175">    {</a>
<a name="ln176">      char *str = dt_conf_get_string(pref_name);</a>
<a name="ln177">      lua_pushstring(L, str);</a>
<a name="ln178">      g_free(str);</a>
<a name="ln179">      break;</a>
<a name="ln180">    }</a>
<a name="ln181">    case pref_file:</a>
<a name="ln182">    {</a>
<a name="ln183">      char *str = dt_conf_get_string(pref_name);</a>
<a name="ln184">      lua_pushstring(L, str);</a>
<a name="ln185">      g_free(str);</a>
<a name="ln186">      break;</a>
<a name="ln187">    }</a>
<a name="ln188">    case pref_string:</a>
<a name="ln189">    {</a>
<a name="ln190">      char *str = dt_conf_get_string(pref_name);</a>
<a name="ln191">      lua_pushstring(L, str);</a>
<a name="ln192">      g_free(str);</a>
<a name="ln193">      break;</a>
<a name="ln194">    }</a>
<a name="ln195">    case pref_bool:</a>
<a name="ln196">      lua_pushboolean(L, dt_conf_get_bool(pref_name));</a>
<a name="ln197">      break;</a>
<a name="ln198">    case pref_int:</a>
<a name="ln199">      lua_pushinteger(L, dt_conf_get_int(pref_name));</a>
<a name="ln200">      break;</a>
<a name="ln201">    case pref_float:</a>
<a name="ln202">      lua_pushnumber(L, dt_conf_get_float(pref_name));</a>
<a name="ln203">      break;</a>
<a name="ln204">    case pref_lua:</a>
<a name="ln205">    {</a>
<a name="ln206">      char *str = dt_conf_get_string(pref_name);</a>
<a name="ln207">      lua_pushstring(L, str);</a>
<a name="ln208">      g_free(str);</a>
<a name="ln209">      break;</a>
<a name="ln210">    }</a>
<a name="ln211">  }</a>
<a name="ln212">  return 1;</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">static int write_pref(lua_State *L)</a>
<a name="ln216">{</a>
<a name="ln217">  const char *script = luaL_checkstring(L, 1);</a>
<a name="ln218">  const char *name = luaL_checkstring(L, 2);</a>
<a name="ln219">  int i, tmp;</a>
<a name="ln220">  luaA_to(L, lua_pref_type, &amp;i, 3);</a>
<a name="ln221"> </a>
<a name="ln222">  char pref_name[1024];</a>
<a name="ln223">  get_pref_name(pref_name, sizeof(pref_name), script, name);</a>
<a name="ln224">  switch(i)</a>
<a name="ln225">  {</a>
<a name="ln226">    case pref_enum:</a>
<a name="ln227">      luaA_to_type(L, luaA_type_find(L,pref_name), &amp;tmp, 4);</a>
<a name="ln228">      dt_conf_set_string(pref_name, lua_tostring(L, 4));</a>
<a name="ln229">      break;</a>
<a name="ln230">    case pref_dir:</a>
<a name="ln231">      dt_conf_set_string(pref_name, luaL_checkstring(L, 4));</a>
<a name="ln232">      break;</a>
<a name="ln233">    case pref_file:</a>
<a name="ln234">      dt_conf_set_string(pref_name, luaL_checkstring(L, 4));</a>
<a name="ln235">      break;</a>
<a name="ln236">    case pref_string:</a>
<a name="ln237">      dt_conf_set_string(pref_name, luaL_checkstring(L, 4));</a>
<a name="ln238">      break;</a>
<a name="ln239">    case pref_bool:</a>
<a name="ln240">      luaL_checktype(L, 4, LUA_TBOOLEAN);</a>
<a name="ln241">      dt_conf_set_bool(pref_name, lua_toboolean(L, 4));</a>
<a name="ln242">      break;</a>
<a name="ln243">    case pref_int:</a>
<a name="ln244">      dt_conf_set_int(pref_name, luaL_checkinteger(L, 4));</a>
<a name="ln245">      break;</a>
<a name="ln246">    case pref_float:</a>
<a name="ln247">      dt_conf_set_float(pref_name, luaL_checknumber(L, 4));</a>
<a name="ln248">      break;</a>
<a name="ln249">    case pref_lua:</a>
<a name="ln250">      dt_conf_set_string(pref_name, luaL_checkstring(L, 4));</a>
<a name="ln251">      break;</a>
<a name="ln252">  }</a>
<a name="ln253">  return 0;</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256"> </a>
<a name="ln257"> </a>
<a name="ln258">static void response_callback_enum(GtkDialog *dialog, gint response_id, pref_element *cur_elt)</a>
<a name="ln259">{</a>
<a name="ln260">  if(response_id == GTK_RESPONSE_ACCEPT)</a>
<a name="ln261">  {</a>
<a name="ln262">    char pref_name[1024];</a>
<a name="ln263">    get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln264">    char *text = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(cur_elt-&gt;widget));</a>
<a name="ln265">    dt_conf_set_string(pref_name, text);</a>
<a name="ln266">    g_free(text);</a>
<a name="ln267">  }</a>
<a name="ln268">}</a>
<a name="ln269">static void response_callback_dir(GtkDialog *dialog, gint response_id, pref_element *cur_elt)</a>
<a name="ln270">{</a>
<a name="ln271">  if(response_id == GTK_RESPONSE_ACCEPT)</a>
<a name="ln272">  {</a>
<a name="ln273">    char pref_name[1024];</a>
<a name="ln274">    get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln275">    gchar *folder = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(cur_elt-&gt;widget));</a>
<a name="ln276">    dt_conf_set_string(pref_name, folder);</a>
<a name="ln277">    g_free(folder);</a>
<a name="ln278">  }</a>
<a name="ln279">}</a>
<a name="ln280">static void response_callback_file(GtkDialog *dialog, gint response_id, pref_element *cur_elt)</a>
<a name="ln281">{</a>
<a name="ln282">  if(response_id == GTK_RESPONSE_ACCEPT)</a>
<a name="ln283">  {</a>
<a name="ln284">    char pref_name[1024];</a>
<a name="ln285">    get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln286">    dt_conf_set_string(pref_name, gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(cur_elt-&gt;widget)));</a>
<a name="ln287">  }</a>
<a name="ln288">}</a>
<a name="ln289">static void response_callback_string(GtkDialog *dialog, gint response_id, pref_element *cur_elt)</a>
<a name="ln290">{</a>
<a name="ln291">  if(response_id == GTK_RESPONSE_ACCEPT)</a>
<a name="ln292">  {</a>
<a name="ln293">    char pref_name[1024];</a>
<a name="ln294">    get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln295">    dt_conf_set_string(pref_name, gtk_entry_get_text(GTK_ENTRY(cur_elt-&gt;widget)));</a>
<a name="ln296">  }</a>
<a name="ln297">}</a>
<a name="ln298">static void response_callback_bool(GtkDialog *dialog, gint response_id, pref_element *cur_elt)</a>
<a name="ln299">{</a>
<a name="ln300">  if(response_id == GTK_RESPONSE_ACCEPT)</a>
<a name="ln301">  {</a>
<a name="ln302">    char pref_name[1024];</a>
<a name="ln303">    get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln304">    dt_conf_set_bool(pref_name, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(cur_elt-&gt;widget)));</a>
<a name="ln305">  }</a>
<a name="ln306">}</a>
<a name="ln307">static void response_callback_int(GtkDialog *dialog, gint response_id, pref_element *cur_elt)</a>
<a name="ln308">{</a>
<a name="ln309">  if(response_id == GTK_RESPONSE_ACCEPT)</a>
<a name="ln310">  {</a>
<a name="ln311">    char pref_name[1024];</a>
<a name="ln312">    get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln313">    dt_conf_set_int(pref_name, gtk_spin_button_get_value(GTK_SPIN_BUTTON(cur_elt-&gt;widget)));</a>
<a name="ln314">  }</a>
<a name="ln315">}</a>
<a name="ln316">static void response_callback_float(GtkDialog *dialog, gint response_id, pref_element *cur_elt)</a>
<a name="ln317">{</a>
<a name="ln318">  if(response_id == GTK_RESPONSE_ACCEPT)</a>
<a name="ln319">  {</a>
<a name="ln320">    char pref_name[1024];</a>
<a name="ln321">    get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln322">    dt_conf_set_float(pref_name, gtk_spin_button_get_value(GTK_SPIN_BUTTON(cur_elt-&gt;widget)));</a>
<a name="ln323">  }</a>
<a name="ln324">}</a>
<a name="ln325">static void response_callback_lua(GtkDialog *dialog, gint response_id, pref_element *cur_elt)</a>
<a name="ln326">{</a>
<a name="ln327">  if(response_id == GTK_RESPONSE_ACCEPT)</a>
<a name="ln328">  {</a>
<a name="ln329">    dt_lua_lock_silent();</a>
<a name="ln330">    lua_State * L = darktable.lua_state.state;</a>
<a name="ln331">    lua_pushcfunction(L,dt_lua_widget_trigger_callback);</a>
<a name="ln332">    luaA_push(L,lua_widget,&amp;cur_elt-&gt;widget);</a>
<a name="ln333">    lua_pushstring(L,&quot;set_pref&quot;);</a>
<a name="ln334">    lua_call(L,2,0);</a>
<a name="ln335">    dt_lua_unlock();</a>
<a name="ln336">  }</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339"> </a>
<a name="ln340">static gboolean reset_widget_enum(GtkWidget *label, GdkEventButton *event, pref_element *cur_elt)</a>
<a name="ln341">{</a>
<a name="ln342">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln343">  {</a>
<a name="ln344">    gtk_combo_box_set_active(GTK_COMBO_BOX(cur_elt-&gt;widget), 0);</a>
<a name="ln345">    return TRUE;</a>
<a name="ln346">  }</a>
<a name="ln347">  return FALSE;</a>
<a name="ln348">}</a>
<a name="ln349">static gboolean reset_widget_dir(GtkWidget *label, GdkEventButton *event, pref_element *cur_elt)</a>
<a name="ln350">{</a>
<a name="ln351">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln352">  {</a>
<a name="ln353">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(cur_elt-&gt;widget),</a>
<a name="ln354">                                        cur_elt-&gt;type_data.dir_data.default_value);</a>
<a name="ln355">    return TRUE;</a>
<a name="ln356">  }</a>
<a name="ln357">  return FALSE;</a>
<a name="ln358">}</a>
<a name="ln359">static gboolean reset_widget_file(GtkWidget *label, GdkEventButton *event, pref_element *cur_elt)</a>
<a name="ln360">{</a>
<a name="ln361">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln362">  {</a>
<a name="ln363">    gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(cur_elt-&gt;widget),</a>
<a name="ln364">                                  cur_elt-&gt;type_data.file_data.default_value);</a>
<a name="ln365">    return TRUE;</a>
<a name="ln366">  }</a>
<a name="ln367">  return FALSE;</a>
<a name="ln368">}</a>
<a name="ln369">static gboolean reset_widget_string(GtkWidget *label, GdkEventButton *event, pref_element *cur_elt)</a>
<a name="ln370">{</a>
<a name="ln371">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln372">  {</a>
<a name="ln373">    gtk_entry_set_text(GTK_ENTRY(cur_elt-&gt;widget), cur_elt-&gt;type_data.string_data.default_value);</a>
<a name="ln374">    return TRUE;</a>
<a name="ln375">  }</a>
<a name="ln376">  return FALSE;</a>
<a name="ln377">}</a>
<a name="ln378">static gboolean reset_widget_bool(GtkWidget *label, GdkEventButton *event, pref_element *cur_elt)</a>
<a name="ln379">{</a>
<a name="ln380">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln381">  {</a>
<a name="ln382">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(cur_elt-&gt;widget),</a>
<a name="ln383">                                 cur_elt-&gt;type_data.bool_data.default_value);</a>
<a name="ln384">    return TRUE;</a>
<a name="ln385">  }</a>
<a name="ln386">  return FALSE;</a>
<a name="ln387">}</a>
<a name="ln388">static gboolean reset_widget_int(GtkWidget *label, GdkEventButton *event, pref_element *cur_elt)</a>
<a name="ln389">{</a>
<a name="ln390">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln391">  {</a>
<a name="ln392">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(cur_elt-&gt;widget), cur_elt-&gt;type_data.int_data.default_value);</a>
<a name="ln393">    return TRUE;</a>
<a name="ln394">  }</a>
<a name="ln395">  return FALSE;</a>
<a name="ln396">}</a>
<a name="ln397">static gboolean reset_widget_float(GtkWidget *label, GdkEventButton *event, pref_element *cur_elt)</a>
<a name="ln398">{</a>
<a name="ln399">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln400">  {</a>
<a name="ln401">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(cur_elt-&gt;widget), cur_elt-&gt;type_data.float_data.default_value);</a>
<a name="ln402">    return TRUE;</a>
<a name="ln403">  }</a>
<a name="ln404">  return FALSE;</a>
<a name="ln405">}</a>
<a name="ln406">static gboolean reset_widget_lua(GtkWidget *label, GdkEventButton *event, pref_element *cur_elt)</a>
<a name="ln407">{</a>
<a name="ln408">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln409">  {</a>
<a name="ln410">    char pref_name[1024];</a>
<a name="ln411">    get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln412">    char *old_str = dt_conf_get_string(pref_name);</a>
<a name="ln413">    dt_conf_set_string(pref_name, cur_elt-&gt;type_data.lua_data.default_value);</a>
<a name="ln414">    dt_lua_lock_silent();</a>
<a name="ln415">    lua_State * L = darktable.lua_state.state;</a>
<a name="ln416">    lua_pushcfunction(L,dt_lua_widget_trigger_callback);</a>
<a name="ln417">    luaA_push(L,lua_widget,&amp;cur_elt-&gt;widget);</a>
<a name="ln418">    luaA_push(L,lua_widget,&amp;cur_elt-&gt;widget);</a>
<a name="ln419">    lua_pushstring(L,&quot;set_pref&quot;);</a>
<a name="ln420">    lua_call(L,3,0);</a>
<a name="ln421">    dt_lua_unlock();</a>
<a name="ln422">    dt_conf_set_string(pref_name, old_str);</a>
<a name="ln423">    return TRUE;</a>
<a name="ln424">  }</a>
<a name="ln425">  return FALSE;</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428"> </a>
<a name="ln429"> </a>
<a name="ln430">static void update_widget_enum(pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev)</a>
<a name="ln431">{</a>
<a name="ln432">  char pref_name[1024];</a>
<a name="ln433">  get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln434">  g_signal_connect(G_OBJECT(labelev), &quot;button-press-event&quot;, G_CALLBACK(reset_widget_enum), cur_elt);</a>
<a name="ln435">  g_signal_connect(G_OBJECT(dialog), &quot;response&quot;, G_CALLBACK(response_callback_enum), cur_elt);</a>
<a name="ln436">  gtk_combo_box_set_active(GTK_COMBO_BOX(cur_elt-&gt;widget), 0);</a>
<a name="ln437">  char*value= dt_conf_get_string(pref_name);</a>
<a name="ln438">  do {</a>
<a name="ln439">    char * active_entry = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(cur_elt-&gt;widget));</a>
<a name="ln440">    if(!active_entry) {</a>
<a name="ln441">      gtk_combo_box_set_active(GTK_COMBO_BOX(cur_elt-&gt;widget), -1);</a>
<a name="ln442">      g_free(active_entry);</a>
<a name="ln443">      break;</a>
<a name="ln444">    }else if(!strcmp(active_entry,value )) {</a>
<a name="ln445">      g_free(active_entry);</a>
<a name="ln446">      break;</a>
<a name="ln447">    } else {</a>
<a name="ln448">      gtk_combo_box_set_active(GTK_COMBO_BOX(cur_elt-&gt;widget), gtk_combo_box_get_active(GTK_COMBO_BOX(cur_elt-&gt;widget))+1);</a>
<a name="ln449">      g_free(active_entry);</a>
<a name="ln450">    }</a>
<a name="ln451">  } while (true);</a>
<a name="ln452">  free(value);</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">static void update_widget_dir(pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev)</a>
<a name="ln456">{</a>
<a name="ln457">  char pref_name[1024];</a>
<a name="ln458">  get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln459">  gchar *str = dt_conf_get_string(pref_name);</a>
<a name="ln460">  gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(cur_elt-&gt;widget), str);</a>
<a name="ln461">  g_free(str);</a>
<a name="ln462">  g_signal_connect(G_OBJECT(labelev), &quot;button-press-event&quot;, G_CALLBACK(reset_widget_dir), cur_elt);</a>
<a name="ln463">  g_signal_connect(G_OBJECT(dialog), &quot;response&quot;, G_CALLBACK(response_callback_dir), cur_elt);</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">static void update_widget_file(pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev)</a>
<a name="ln467">{</a>
<a name="ln468">  char pref_name[1024];</a>
<a name="ln469">  get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln470">  gchar *str = dt_conf_get_string(pref_name);</a>
<a name="ln471">  gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(cur_elt-&gt;widget), str);</a>
<a name="ln472">  g_free(str);</a>
<a name="ln473">  g_signal_connect(G_OBJECT(labelev), &quot;button-press-event&quot;, G_CALLBACK(reset_widget_file), cur_elt);</a>
<a name="ln474">  g_signal_connect(G_OBJECT(dialog), &quot;response&quot;, G_CALLBACK(response_callback_file), cur_elt);</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">static void update_widget_string(pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev)</a>
<a name="ln478">{</a>
<a name="ln479">  char pref_name[1024];</a>
<a name="ln480">  get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln481">  g_signal_connect(G_OBJECT(labelev), &quot;button-press-event&quot;, G_CALLBACK(reset_widget_string), cur_elt);</a>
<a name="ln482">  g_signal_connect(G_OBJECT(dialog), &quot;response&quot;, G_CALLBACK(response_callback_string), cur_elt);</a>
<a name="ln483">  char* str = dt_conf_get_string(pref_name);</a>
<a name="ln484">  gtk_entry_set_text(GTK_ENTRY(cur_elt-&gt;widget), str);</a>
<a name="ln485">  g_free(str);</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488">static void update_widget_bool(pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev)</a>
<a name="ln489">{</a>
<a name="ln490">  char pref_name[1024];</a>
<a name="ln491">  get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln492">  g_signal_connect(G_OBJECT(labelev), &quot;button-press-event&quot;, G_CALLBACK(reset_widget_bool), cur_elt);</a>
<a name="ln493">  g_signal_connect(G_OBJECT(dialog), &quot;response&quot;, G_CALLBACK(response_callback_bool), cur_elt);</a>
<a name="ln494">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(cur_elt-&gt;widget), dt_conf_get_bool(pref_name));</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497">static void update_widget_int(pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev)</a>
<a name="ln498">{</a>
<a name="ln499">  char pref_name[1024];</a>
<a name="ln500">  get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln501">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(cur_elt-&gt;widget), dt_conf_get_int(pref_name));</a>
<a name="ln502">  g_signal_connect(G_OBJECT(labelev), &quot;button-press-event&quot;, G_CALLBACK(reset_widget_int), cur_elt);</a>
<a name="ln503">  g_signal_connect(G_OBJECT(dialog), &quot;response&quot;, G_CALLBACK(response_callback_int), cur_elt);</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">static void update_widget_float(pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev)</a>
<a name="ln507">{</a>
<a name="ln508">  char pref_name[1024];</a>
<a name="ln509">  get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln510">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(cur_elt-&gt;widget), dt_conf_get_float(pref_name));</a>
<a name="ln511">  g_signal_connect(G_OBJECT(labelev), &quot;button-press-event&quot;, G_CALLBACK(reset_widget_float), cur_elt);</a>
<a name="ln512">  g_signal_connect(G_OBJECT(dialog), &quot;response&quot;, G_CALLBACK(response_callback_float), cur_elt);</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">static void update_widget_lua(pref_element* cur_elt,GtkWidget* dialog,GtkWidget* labelev)</a>
<a name="ln516">{</a>
<a name="ln517">  dt_lua_lock_silent();</a>
<a name="ln518">  lua_State * L = darktable.lua_state.state;</a>
<a name="ln519">  lua_pushcfunction(L,dt_lua_widget_trigger_callback);</a>
<a name="ln520">  luaA_push(L,lua_widget,&amp;cur_elt-&gt;widget);</a>
<a name="ln521">  lua_pushstring(L,&quot;reset&quot;);</a>
<a name="ln522">  lua_call(L,2,0);</a>
<a name="ln523">  dt_lua_unlock();</a>
<a name="ln524">  g_signal_connect(G_OBJECT(labelev), &quot;button-press-event&quot;, G_CALLBACK(reset_widget_lua), cur_elt);</a>
<a name="ln525">  g_signal_connect(G_OBJECT(dialog), &quot;response&quot;, G_CALLBACK(response_callback_lua), cur_elt);</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">static int register_pref_sub(lua_State *L)</a>
<a name="ln529">{</a>
<a name="ln530">  // to avoid leaks, we need to first get all params (which could raise errors) then alloc and fill the struct</a>
<a name="ln531">  // this is complicated, but needed</a>
<a name="ln532">  pref_element **tmp = lua_touserdata(L, -1);</a>
<a name="ln533">  lua_pop(L, 1);</a>
<a name="ln534">  *tmp = calloc(1, sizeof(pref_element));</a>
<a name="ln535">  pref_element *built_elt = *tmp;</a>
<a name="ln536">  int cur_param = 1;</a>
<a name="ln537"> </a>
<a name="ln538">  built_elt-&gt;script = strdup(luaL_checkstring(L, cur_param));</a>
<a name="ln539">  cur_param++;</a>
<a name="ln540"> </a>
<a name="ln541">  built_elt-&gt;name = strdup(luaL_checkstring(L, cur_param));</a>
<a name="ln542">  cur_param++;</a>
<a name="ln543"> </a>
<a name="ln544">  luaA_to(L, lua_pref_type, &amp;built_elt-&gt;type, cur_param);</a>
<a name="ln545">  cur_param++;</a>
<a name="ln546"> </a>
<a name="ln547">  built_elt-&gt;label = strdup(luaL_checkstring(L, cur_param));</a>
<a name="ln548">  cur_param++;</a>
<a name="ln549"> </a>
<a name="ln550">  built_elt-&gt;tooltip = strdup(luaL_checkstring(L, cur_param));</a>
<a name="ln551">  cur_param++;</a>
<a name="ln552"> </a>
<a name="ln553">  char pref_name[1024];</a>
<a name="ln554">  get_pref_name(pref_name, sizeof(pref_name), built_elt-&gt;script, built_elt-&gt;name);</a>
<a name="ln555">  switch(built_elt-&gt;type)</a>
<a name="ln556">  {</a>
<a name="ln557">    case pref_enum:</a>
<a name="ln558">    {</a>
<a name="ln559">      luaA_Type enum_type = luaA_type_add(L, pref_name, sizeof(int));</a>
<a name="ln560">      luaA_enum_type(L, enum_type, sizeof(int));</a>
<a name="ln561">      built_elt-&gt;type_data.enum_data.enum_type = enum_type;</a>
<a name="ln562">      built_elt-&gt;widget = gtk_combo_box_text_new();</a>
<a name="ln563"> </a>
<a name="ln564">      int value = 0;</a>
<a name="ln565">      built_elt-&gt;type_data.enum_data.default_value = strdup(luaL_checkstring(L, cur_param));</a>
<a name="ln566">      while(!lua_isnoneornil(L, cur_param))</a>
<a name="ln567">      {</a>
<a name="ln568">        luaA_enum_value_type(L, enum_type, &amp;value, luaL_checkstring(L, cur_param));</a>
<a name="ln569">        gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(built_elt-&gt;widget), luaL_checkstring(L, cur_param));</a>
<a name="ln570">        cur_param++;</a>
<a name="ln571">        value++;</a>
<a name="ln572">      }</a>
<a name="ln573"> </a>
<a name="ln574">      if(!dt_conf_key_exists(pref_name)) {</a>
<a name="ln575">        dt_conf_set_string(pref_name, built_elt-&gt;type_data.enum_data.default_value);</a>
<a name="ln576">      }</a>
<a name="ln577"> </a>
<a name="ln578"> </a>
<a name="ln579">      g_object_ref_sink(G_OBJECT(built_elt-&gt;widget));</a>
<a name="ln580">      built_elt-&gt;tooltip_reset = g_strdup_printf(  _(&quot;double click to reset to `%s'&quot;),</a>
<a name="ln581">          built_elt-&gt;type_data.enum_data.default_value);</a>
<a name="ln582">      built_elt-&gt;update_widget = update_widget_enum;</a>
<a name="ln583">      break;</a>
<a name="ln584">    }</a>
<a name="ln585">    case pref_dir:</a>
<a name="ln586">      built_elt-&gt;type_data.dir_data.default_value = strdup(luaL_checkstring(L, cur_param));</a>
<a name="ln587">      cur_param++;</a>
<a name="ln588"> </a>
<a name="ln589">      if(!dt_conf_key_exists(pref_name)) {</a>
<a name="ln590">        dt_conf_set_string(pref_name, built_elt-&gt;type_data.dir_data.default_value);</a>
<a name="ln591">      }</a>
<a name="ln592">      built_elt-&gt;widget = gtk_file_chooser_button_new(_(&quot;select directory&quot;), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER);</a>
<a name="ln593">      gtk_file_chooser_button_set_width_chars(GTK_FILE_CHOOSER_BUTTON(built_elt-&gt;widget), 20);</a>
<a name="ln594">      g_object_ref_sink(G_OBJECT(built_elt-&gt;widget));</a>
<a name="ln595">      built_elt-&gt;tooltip_reset = g_strdup_printf( _(&quot;double click to reset to `%s'&quot;), built_elt-&gt;type_data.dir_data.default_value);</a>
<a name="ln596">      built_elt-&gt;update_widget = update_widget_dir;</a>
<a name="ln597">      break;</a>
<a name="ln598">    case pref_file:</a>
<a name="ln599">      built_elt-&gt;type_data.file_data.default_value = strdup(luaL_checkstring(L, cur_param));</a>
<a name="ln600">      cur_param++;</a>
<a name="ln601"> </a>
<a name="ln602">      if(!dt_conf_key_exists(pref_name))</a>
<a name="ln603">        dt_conf_set_string(pref_name, built_elt-&gt;type_data.file_data.default_value);</a>
<a name="ln604"> </a>
<a name="ln605">      built_elt-&gt;widget = gtk_file_chooser_button_new(_(&quot;select file&quot;), GTK_FILE_CHOOSER_ACTION_OPEN);</a>
<a name="ln606">      gtk_file_chooser_button_set_width_chars(GTK_FILE_CHOOSER_BUTTON(built_elt-&gt;widget), 20);</a>
<a name="ln607">      built_elt-&gt;tooltip_reset= g_strdup_printf( _(&quot;double click to reset to `%s'&quot;), built_elt-&gt;type_data.file_data.default_value);</a>
<a name="ln608">      g_object_ref_sink(G_OBJECT(built_elt-&gt;widget));</a>
<a name="ln609">      built_elt-&gt;update_widget = update_widget_file;</a>
<a name="ln610">      break;</a>
<a name="ln611">    case pref_string:</a>
<a name="ln612">      built_elt-&gt;type_data.string_data.default_value = strdup(luaL_checkstring(L, cur_param));</a>
<a name="ln613">      cur_param++;</a>
<a name="ln614"> </a>
<a name="ln615">      if(!dt_conf_key_exists(pref_name))</a>
<a name="ln616">        dt_conf_set_string(pref_name, built_elt-&gt;type_data.string_data.default_value);</a>
<a name="ln617"> </a>
<a name="ln618">      built_elt-&gt;widget = gtk_entry_new();</a>
<a name="ln619">      built_elt-&gt;tooltip_reset= g_strdup_printf( _(&quot;double click to reset to `%s'&quot;),</a>
<a name="ln620">          built_elt-&gt;type_data.string_data.default_value);</a>
<a name="ln621">      g_object_ref_sink(G_OBJECT(built_elt-&gt;widget));</a>
<a name="ln622">      built_elt-&gt;update_widget = update_widget_string;</a>
<a name="ln623">      break;</a>
<a name="ln624">    case pref_bool:</a>
<a name="ln625">      luaL_checktype(L, cur_param, LUA_TBOOLEAN);</a>
<a name="ln626">      built_elt-&gt;type_data.bool_data.default_value = lua_toboolean(L, cur_param);</a>
<a name="ln627">      cur_param++;</a>
<a name="ln628"> </a>
<a name="ln629">      if(!dt_conf_key_exists(pref_name))</a>
<a name="ln630">        dt_conf_set_bool(pref_name, built_elt-&gt;type_data.bool_data.default_value);</a>
<a name="ln631"> </a>
<a name="ln632">      built_elt-&gt;widget = gtk_check_button_new();</a>
<a name="ln633">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(built_elt-&gt;widget), dt_conf_get_bool(pref_name));</a>
<a name="ln634">      g_object_ref_sink(G_OBJECT(built_elt-&gt;widget));</a>
<a name="ln635">      built_elt-&gt;tooltip_reset = g_strdup_printf(  _(&quot;double click to reset to `%s'&quot;),</a>
<a name="ln636">          built_elt-&gt;type_data.bool_data.default_value ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln637">      built_elt-&gt;update_widget = update_widget_bool;</a>
<a name="ln638">      break;</a>
<a name="ln639">    case pref_int:</a>
<a name="ln640">      {</a>
<a name="ln641">        luaL_checktype(L, cur_param, LUA_TNUMBER);</a>
<a name="ln642">        built_elt-&gt;type_data.int_data.default_value = lua_tointeger(L, cur_param);</a>
<a name="ln643">        cur_param++;</a>
<a name="ln644"> </a>
<a name="ln645">        luaL_checktype(L, cur_param, LUA_TNUMBER);</a>
<a name="ln646">        int min = lua_tointeger(L, cur_param);</a>
<a name="ln647">        cur_param++;</a>
<a name="ln648"> </a>
<a name="ln649">        luaL_checktype(L, cur_param, LUA_TNUMBER);</a>
<a name="ln650">        int max = lua_tointeger(L, cur_param);</a>
<a name="ln651">        cur_param++;</a>
<a name="ln652"> </a>
<a name="ln653">        if(!dt_conf_key_exists(pref_name))</a>
<a name="ln654">          dt_conf_set_int(pref_name, built_elt-&gt;type_data.int_data.default_value);</a>
<a name="ln655">        built_elt-&gt;widget = gtk_spin_button_new_with_range(min, max, 1);</a>
<a name="ln656">        gtk_spin_button_set_digits(GTK_SPIN_BUTTON(built_elt-&gt;widget), 0);</a>
<a name="ln657">        g_object_ref_sink(G_OBJECT(built_elt-&gt;widget));</a>
<a name="ln658">        built_elt-&gt;tooltip_reset = g_strdup_printf( _(&quot;double click to reset to `%d'&quot;),</a>
<a name="ln659">            built_elt-&gt;type_data.int_data.default_value);</a>
<a name="ln660">        built_elt-&gt;update_widget = update_widget_int;</a>
<a name="ln661">        break;</a>
<a name="ln662">      }</a>
<a name="ln663">    case pref_float:</a>
<a name="ln664">      {</a>
<a name="ln665">        luaL_checktype(L, cur_param, LUA_TNUMBER);</a>
<a name="ln666">        built_elt-&gt;type_data.float_data.default_value = lua_tonumber(L, cur_param);</a>
<a name="ln667">        cur_param++;</a>
<a name="ln668"> </a>
<a name="ln669">        luaL_checktype(L, cur_param, LUA_TNUMBER);</a>
<a name="ln670">        float min = lua_tonumber(L, cur_param);</a>
<a name="ln671">        cur_param++;</a>
<a name="ln672"> </a>
<a name="ln673">        luaL_checktype(L, cur_param, LUA_TNUMBER);</a>
<a name="ln674">        float max = lua_tonumber(L, cur_param);</a>
<a name="ln675">        cur_param++;</a>
<a name="ln676"> </a>
<a name="ln677">        luaL_checktype(L, cur_param, LUA_TNUMBER);</a>
<a name="ln678">        float step = lua_tonumber(L, cur_param);</a>
<a name="ln679">        cur_param++;</a>
<a name="ln680"> </a>
<a name="ln681">        if(!dt_conf_key_exists(pref_name))</a>
<a name="ln682">          dt_conf_set_float(pref_name, built_elt-&gt;type_data.float_data.default_value);</a>
<a name="ln683"> </a>
<a name="ln684">        built_elt-&gt;widget = gtk_spin_button_new_with_range(min, max, step);</a>
<a name="ln685">        built_elt-&gt;tooltip_reset = g_strdup_printf( _(&quot;double click to reset to `%f'&quot;),</a>
<a name="ln686">            built_elt-&gt;type_data.float_data.default_value);</a>
<a name="ln687">        g_object_ref_sink(G_OBJECT(built_elt-&gt;widget));</a>
<a name="ln688">        built_elt-&gt;update_widget = update_widget_float;</a>
<a name="ln689">        break;</a>
<a name="ln690">      }</a>
<a name="ln691">    case pref_lua:</a>
<a name="ln692">      {</a>
<a name="ln693">        built_elt-&gt;type_data.lua_data.default_value = strdup(luaL_checkstring(L, cur_param));</a>
<a name="ln694">        cur_param++;</a>
<a name="ln695"> </a>
<a name="ln696">        if(!dt_conf_key_exists(pref_name))</a>
<a name="ln697">          dt_conf_set_string(pref_name, built_elt-&gt;type_data.lua_data.default_value);</a>
<a name="ln698"> </a>
<a name="ln699">        built_elt-&gt;tooltip_reset= g_strdup_printf( _(&quot;double click to reset to `%s'&quot;),</a>
<a name="ln700">            built_elt-&gt;type_data.lua_data.default_value);</a>
<a name="ln701"> </a>
<a name="ln702">        lua_widget widget;</a>
<a name="ln703">        luaA_to(L,lua_widget,&amp;widget,cur_param);</a>
<a name="ln704">        cur_param++;</a>
<a name="ln705">        dt_lua_widget_bind(L,widget);</a>
<a name="ln706">        built_elt-&gt;widget = widget-&gt;widget;</a>
<a name="ln707">        built_elt-&gt;update_widget = update_widget_lua;</a>
<a name="ln708"> </a>
<a name="ln709">        luaL_checktype(L,cur_param,LUA_TFUNCTION);</a>
<a name="ln710">        luaA_push(L,lua_widget,widget);</a>
<a name="ln711">        lua_pushvalue(L,cur_param);</a>
<a name="ln712">        dt_lua_widget_set_callback(L,-2,&quot;set_pref&quot;);</a>
<a name="ln713">        lua_pop(L,1);</a>
<a name="ln714"> </a>
<a name="ln715">        break;</a>
<a name="ln716">      }</a>
<a name="ln717">  }</a>
<a name="ln718">  return 0;</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721"> </a>
<a name="ln722">static int register_pref(lua_State *L)</a>
<a name="ln723">{</a>
<a name="ln724">  // wrapper to catch lua errors in a clean way</a>
<a name="ln725">  pref_element *built_elt = NULL;</a>
<a name="ln726">  lua_pushcfunction(L, register_pref_sub);</a>
<a name="ln727">  dt_lua_gtk_wrap(L);</a>
<a name="ln728">  lua_insert(L, 1);</a>
<a name="ln729">  lua_pushlightuserdata(L, &amp;built_elt);</a>
<a name="ln730">  int result = dt_lua_treated_pcall(L,lua_gettop(L)-1,0);</a>
<a name="ln731">  if(result == LUA_OK)</a>
<a name="ln732">  {</a>
<a name="ln733">    built_elt-&gt;next = pref_list;</a>
<a name="ln734">    pref_list = built_elt;</a>
<a name="ln735">    return 0;</a>
<a name="ln736">  }</a>
<a name="ln737">  else</a>
<a name="ln738">  {</a>
<a name="ln739">    destroy_pref_element(built_elt);</a>
<a name="ln740">    return lua_error(L);</a>
<a name="ln741">  }</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744"> </a>
<a name="ln745">GtkGrid* init_tab_lua(GtkWidget *dialog, GtkWidget *tab)</a>
<a name="ln746">{</a>
<a name="ln747">  if(!pref_list) return NULL; // no option registered =&gt; don't create the tab</a>
<a name="ln748">  GtkWidget *label, *labelev, *viewport;</a>
<a name="ln749">  GtkWidget *grid = gtk_grid_new();</a>
<a name="ln750">  int line = 0;</a>
<a name="ln751">  gtk_grid_set_row_spacing(GTK_GRID(grid), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln752">  gtk_grid_set_column_spacing(GTK_GRID(grid), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln753">  gtk_grid_set_row_homogeneous(GTK_GRID(grid), TRUE);</a>
<a name="ln754">  gtk_widget_set_valign(grid, GTK_ALIGN_START);</a>
<a name="ln755">  GtkWidget *scroll = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln756">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);</a>
<a name="ln757">  gtk_widget_set_margin_top(scroll, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln758">  gtk_widget_set_margin_bottom(scroll, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln759">  gtk_widget_set_margin_start(scroll, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln760">  gtk_widget_set_margin_end(scroll, DT_PIXEL_APPLY_DPI(20));</a>
<a name="ln761">  viewport = gtk_viewport_new(NULL, NULL);</a>
<a name="ln762">  gtk_viewport_set_shadow_type(GTK_VIEWPORT(viewport), GTK_SHADOW_NONE); // doesn't seem to work from gtkrc</a>
<a name="ln763">  gtk_container_add(GTK_CONTAINER(scroll), viewport);</a>
<a name="ln764">  gtk_container_add(GTK_CONTAINER(viewport), grid);</a>
<a name="ln765">  gtk_notebook_append_page(GTK_NOTEBOOK(tab), scroll, gtk_label_new(_(&quot;lua options&quot;)));</a>
<a name="ln766"> </a>
<a name="ln767">  pref_element *cur_elt = pref_list;</a>
<a name="ln768">  while(cur_elt)</a>
<a name="ln769">  {</a>
<a name="ln770">    char pref_name[1024];</a>
<a name="ln771">    get_pref_name(pref_name, sizeof(pref_name), cur_elt-&gt;script, cur_elt-&gt;name);</a>
<a name="ln772">    label = gtk_label_new(cur_elt-&gt;label);</a>
<a name="ln773">    gtk_widget_set_halign(GTK_WIDGET(label), GTK_ALIGN_START);</a>
<a name="ln774">    labelev = gtk_event_box_new();</a>
<a name="ln775">    gtk_widget_add_events(labelev, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln776">    gtk_container_add(GTK_CONTAINER(labelev), label);</a>
<a name="ln777">    cur_elt-&gt;update_widget(cur_elt,dialog,labelev);</a>
<a name="ln778">    gtk_widget_set_tooltip_text(labelev, cur_elt-&gt;tooltip_reset);</a>
<a name="ln779">    gtk_event_box_set_visible_window(GTK_EVENT_BOX(labelev), FALSE);</a>
<a name="ln780">    gtk_widget_set_tooltip_text(cur_elt-&gt;widget, cur_elt-&gt;tooltip);</a>
<a name="ln781">    gtk_grid_attach(GTK_GRID(grid), labelev, 0, line, 1, 1);</a>
<a name="ln782">    gtk_grid_attach(GTK_GRID(grid), cur_elt-&gt;widget, 1, line, 1, 1);</a>
<a name="ln783">    cur_elt = cur_elt-&gt;next;</a>
<a name="ln784">    line++;</a>
<a name="ln785">  }</a>
<a name="ln786">  return GTK_GRID(grid);</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">void destroy_tab_lua(GtkGrid *grid)</a>
<a name="ln790">{</a>
<a name="ln791">  if(!grid) return;</a>
<a name="ln792">  gtk_grid_remove_column(grid,1); // detach all special widgets to avoid having them destroyed</a>
<a name="ln793">}</a>
<a name="ln794">int dt_lua_init_preferences(lua_State *L)</a>
<a name="ln795">{</a>
<a name="ln796">  luaA_enum(L, lua_pref_type);</a>
<a name="ln797">  luaA_enum_value_name(L, lua_pref_type, pref_string, &quot;string&quot;);</a>
<a name="ln798">  luaA_enum_value_name(L, lua_pref_type, pref_bool, &quot;bool&quot;);</a>
<a name="ln799">  luaA_enum_value_name(L, lua_pref_type, pref_int, &quot;integer&quot;);</a>
<a name="ln800">  luaA_enum_value_name(L, lua_pref_type, pref_float, &quot;float&quot;);</a>
<a name="ln801">  luaA_enum_value_name(L, lua_pref_type, pref_file, &quot;file&quot;);</a>
<a name="ln802">  luaA_enum_value_name(L, lua_pref_type, pref_dir, &quot;directory&quot;);</a>
<a name="ln803">  luaA_enum_value_name(L, lua_pref_type, pref_enum, &quot;enum&quot;);</a>
<a name="ln804">  luaA_enum_value_name(L, lua_pref_type, pref_lua, &quot;lua&quot;);</a>
<a name="ln805"> </a>
<a name="ln806">  dt_lua_push_darktable_lib(L);</a>
<a name="ln807">  dt_lua_goto_subtable(L, &quot;preferences&quot;);</a>
<a name="ln808"> </a>
<a name="ln809">  lua_pushcfunction(L, register_pref);</a>
<a name="ln810">  lua_setfield(L, -2, &quot;register&quot;);</a>
<a name="ln811"> </a>
<a name="ln812">  lua_pushcfunction(L, read_pref);</a>
<a name="ln813">  lua_setfield(L, -2, &quot;read&quot;);</a>
<a name="ln814"> </a>
<a name="ln815">  lua_pushcfunction(L, write_pref);</a>
<a name="ln816">  lua_setfield(L, -2, &quot;write&quot;);</a>
<a name="ln817"> </a>
<a name="ln818">  lua_pop(L, 1);</a>
<a name="ln819">  return 0;</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln823">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln824">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="452"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v611/" target="_blank">V611</a> The memory was allocated using 'g_malloc' function but was released using the 'free' function. Consider inspecting operation logics behind the 'value' variable.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
