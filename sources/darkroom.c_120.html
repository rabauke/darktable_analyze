
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika.</a>
<a name="ln4">    copyright (c) 2011--2012 henrik andersson.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">/** this is the view for the darkroom module.  */</a>
<a name="ln20">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln21">#include &quot;common/collection.h&quot;</a>
<a name="ln22">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln23">#include &quot;common/darktable.h&quot;</a>
<a name="ln24">#include &quot;common/debug.h&quot;</a>
<a name="ln25">#include &quot;common/file_location.h&quot;</a>
<a name="ln26">#include &quot;common/image_cache.h&quot;</a>
<a name="ln27">#include &quot;common/imageio.h&quot;</a>
<a name="ln28">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln29">#include &quot;common/styles.h&quot;</a>
<a name="ln30">#include &quot;common/tags.h&quot;</a>
<a name="ln31">#include &quot;common/undo.h&quot;</a>
<a name="ln32">#include &quot;control/conf.h&quot;</a>
<a name="ln33">#include &quot;control/control.h&quot;</a>
<a name="ln34">#include &quot;control/jobs.h&quot;</a>
<a name="ln35">#include &quot;develop/blend.h&quot;</a>
<a name="ln36">#include &quot;develop/develop.h&quot;</a>
<a name="ln37">#include &quot;develop/imageop.h&quot;</a>
<a name="ln38">#include &quot;develop/masks.h&quot;</a>
<a name="ln39">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln40">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln41">#include &quot;gui/gtk.h&quot;</a>
<a name="ln42">#include &quot;gui/presets.h&quot;</a>
<a name="ln43">#include &quot;libs/colorpicker.h&quot;</a>
<a name="ln44">#include &quot;views/view.h&quot;</a>
<a name="ln45">#include &quot;views/view_api.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#ifdef USE_LUA</a>
<a name="ln48">#include &quot;lua/image.h&quot;</a>
<a name="ln49">#endif</a>
<a name="ln50"> </a>
<a name="ln51">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln52">#include &lt;glib.h&gt;</a>
<a name="ln53">#include &lt;math.h&gt;</a>
<a name="ln54">#include &lt;stdlib.h&gt;</a>
<a name="ln55">#include &lt;string.h&gt;</a>
<a name="ln56">#include &lt;unistd.h&gt;</a>
<a name="ln57">#include &lt;sys/types.h&gt;</a>
<a name="ln58">#include &lt;sys/stat.h&gt;</a>
<a name="ln59">#include &lt;fcntl.h&gt;</a>
<a name="ln60"> </a>
<a name="ln61">#ifndef G_SOURCE_FUNC // Defined for glib &gt;= 2.58</a>
<a name="ln62">#define G_SOURCE_FUNC(f) ((GSourceFunc) (void (*)(void)) (f))</a>
<a name="ln63">#endif</a>
<a name="ln64"> </a>
<a name="ln65">DT_MODULE(1)</a>
<a name="ln66"> </a>
<a name="ln67">static gboolean film_strip_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln68">                                     GdkModifierType modifier, gpointer data);</a>
<a name="ln69"> </a>
<a name="ln70">static gboolean zoom_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln71">                               GdkModifierType modifier, gpointer data);</a>
<a name="ln72"> </a>
<a name="ln73">static gboolean export_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln74">                                          GdkModifierType modifier, gpointer data);</a>
<a name="ln75"> </a>
<a name="ln76">static gboolean skip_f_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln77">                                          GdkModifierType modifier, gpointer data);</a>
<a name="ln78">static gboolean skip_b_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln79">                                          GdkModifierType modifier, gpointer data);</a>
<a name="ln80">static gboolean _toolbox_toggle_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln81">                                         GdkModifierType modifier, gpointer data);</a>
<a name="ln82">static gboolean _brush_size_up_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln83">                                        GdkModifierType modifier, gpointer data);</a>
<a name="ln84">static gboolean _brush_size_down_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln85">                                          GdkModifierType modifier, gpointer data);</a>
<a name="ln86">static gboolean _brush_hardness_up_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln87">                                            GdkModifierType modifier, gpointer data);</a>
<a name="ln88">static gboolean _brush_hardness_down_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln89">                                              GdkModifierType modifier, gpointer data);</a>
<a name="ln90">static gboolean _brush_opacity_up_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln91">                                           GdkModifierType modifier, gpointer data);</a>
<a name="ln92">static gboolean _brush_opacity_down_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln93">                                             GdkModifierType modifier, gpointer data);</a>
<a name="ln94"> </a>
<a name="ln95">static void _update_softproof_gamut_checking(dt_develop_t *d);</a>
<a name="ln96"> </a>
<a name="ln97">/* signal handler for filmstrip image switching */</a>
<a name="ln98">static void _view_darkroom_filmstrip_activate_callback(gpointer instance, gpointer user_data);</a>
<a name="ln99"> </a>
<a name="ln100">static void dt_dev_change_image(dt_develop_t *dev, const uint32_t imgid);</a>
<a name="ln101"> </a>
<a name="ln102">static void _darkroom_display_second_window(dt_develop_t *dev);</a>
<a name="ln103">static void _darkroom_ui_second_window_write_config(GtkWidget *widget);</a>
<a name="ln104"> </a>
<a name="ln105">const char *name(const dt_view_t *self)</a>
<a name="ln106">{</a>
<a name="ln107">  return _(&quot;darkroom&quot;);</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">#ifdef USE_LUA</a>
<a name="ln111"> </a>
<a name="ln112">static int display_image_cb(lua_State *L)</a>
<a name="ln113">{</a>
<a name="ln114">  dt_develop_t *dev = darktable.develop;</a>
<a name="ln115">  dt_lua_image_t imgid = -1;</a>
<a name="ln116">  if(luaL_testudata(L, 1, &quot;dt_lua_image_t&quot;))</a>
<a name="ln117">  {</a>
<a name="ln118">    luaA_to(L, dt_lua_image_t, &amp;imgid, 1);</a>
<a name="ln119">    dt_dev_change_image(dev, imgid);</a>
<a name="ln120">  }</a>
<a name="ln121">  else</a>
<a name="ln122">  {</a>
<a name="ln123">    // ensure the image infos in db is up to date</a>
<a name="ln124">    dt_dev_write_history(dev);</a>
<a name="ln125">  }</a>
<a name="ln126">  luaA_push(L, dt_lua_image_t, &amp;dev-&gt;image_storage.id);</a>
<a name="ln127">  return 1;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">#endif</a>
<a name="ln131"> </a>
<a name="ln132"> </a>
<a name="ln133">void init(dt_view_t *self)</a>
<a name="ln134">{</a>
<a name="ln135">  self-&gt;data = malloc(sizeof(dt_develop_t));</a>
<a name="ln136">  dt_dev_init((dt_develop_t *)self-&gt;data, 1);</a>
<a name="ln137"> </a>
<a name="ln138">#ifdef USE_LUA</a>
<a name="ln139">  lua_State *L = darktable.lua_state.state;</a>
<a name="ln140">  int my_type = dt_lua_module_entry_get_type(L, &quot;view&quot;, self-&gt;module_name);</a>
<a name="ln141">  lua_pushlightuserdata(L, self);</a>
<a name="ln142">  lua_pushcclosure(L, display_image_cb, 1);</a>
<a name="ln143">  dt_lua_gtk_wrap(L);</a>
<a name="ln144">  lua_pushcclosure(L, dt_lua_type_member_common, 1);</a>
<a name="ln145">  dt_lua_type_register_const_type(L, my_type, &quot;display_image&quot;);</a>
<a name="ln146">#endif</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">uint32_t view(const dt_view_t *self)</a>
<a name="ln150">{</a>
<a name="ln151">  return DT_VIEW_DARKROOM;</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">void cleanup(dt_view_t *self)</a>
<a name="ln155">{</a>
<a name="ln156">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln157"> </a>
<a name="ln158">  if(dev-&gt;second_window.second_wnd)</a>
<a name="ln159">  {</a>
<a name="ln160">    if(gtk_widget_is_visible(dev-&gt;second_window.second_wnd))</a>
<a name="ln161">    {</a>
<a name="ln162">      dt_conf_set_bool(&quot;second_window/last_visible&quot;, TRUE);</a>
<a name="ln163">      _darkroom_ui_second_window_write_config(dev-&gt;second_window.second_wnd);</a>
<a name="ln164">    }</a>
<a name="ln165">    else</a>
<a name="ln166">      dt_conf_set_bool(&quot;second_window/last_visible&quot;, FALSE);</a>
<a name="ln167"> </a>
<a name="ln168">    gtk_widget_destroy(dev-&gt;second_window.second_wnd);</a>
<a name="ln169">    dev-&gt;second_window.second_wnd = NULL;</a>
<a name="ln170">    dev-&gt;second_window.widget = NULL;</a>
<a name="ln171">  }</a>
<a name="ln172">  else</a>
<a name="ln173">  {</a>
<a name="ln174">    dt_conf_set_bool(&quot;second_window/last_visible&quot;, FALSE);</a>
<a name="ln175">  }</a>
<a name="ln176"> </a>
<a name="ln177">  dt_dev_cleanup(dev);</a>
<a name="ln178">  free(dev);</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">static cairo_status_t write_snapshot_data(void *closure, const unsigned char *data, unsigned int length)</a>
<a name="ln182">{</a>
<a name="ln183">  int fd = GPOINTER_TO_INT(closure);</a>
<a name="ln184">  ssize_t res = write(fd, data, length);</a>
<a name="ln185">  if(res != length)</a>
<a name="ln186">    return CAIRO_STATUS_WRITE_ERROR;</a>
<a name="ln187">  return CAIRO_STATUS_SUCCESS;</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">void expose(</a>
<a name="ln191">    dt_view_t *self,</a>
<a name="ln192">    cairo_t *cri,</a>
<a name="ln193">    int32_t width,</a>
<a name="ln194">    int32_t height,</a>
<a name="ln195">    int32_t pointerx,</a>
<a name="ln196">    int32_t pointery)</a>
<a name="ln197">{</a>
<a name="ln198">  cairo_set_source_rgb(cri, .2, .2, .2);</a>
<a name="ln199">  cairo_save(cri);</a>
<a name="ln200"> </a>
<a name="ln201">  const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln202">  // account for border, make it transparent for other modules called below:</a>
<a name="ln203">  pointerx -= tb;</a>
<a name="ln204">  pointery -= tb;</a>
<a name="ln205"> </a>
<a name="ln206">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln207"> </a>
<a name="ln208">  if(dev-&gt;gui_synch &amp;&amp; !dev-&gt;image_loading)</a>
<a name="ln209">  {</a>
<a name="ln210">    // synch module guis from gtk thread:</a>
<a name="ln211">    const int reset = darktable.gui-&gt;reset;</a>
<a name="ln212">    darktable.gui-&gt;reset = 1;</a>
<a name="ln213">    GList *modules = dev-&gt;iop;</a>
<a name="ln214">    while(modules)</a>
<a name="ln215">    {</a>
<a name="ln216">      dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln217">      dt_iop_gui_update(module);</a>
<a name="ln218">      modules = g_list_next(modules);</a>
<a name="ln219">    }</a>
<a name="ln220">    darktable.gui-&gt;reset = reset;</a>
<a name="ln221">    dev-&gt;gui_synch = 0;</a>
<a name="ln222">  }</a>
<a name="ln223"> </a>
<a name="ln224">  if(dev-&gt;image_status == DT_DEV_PIXELPIPE_DIRTY || dev-&gt;image_status == DT_DEV_PIXELPIPE_INVALID</a>
<a name="ln225">     || dev-&gt;pipe-&gt;input_timestamp &lt; dev-&gt;preview_pipe-&gt;input_timestamp)</a>
<a name="ln226">  {</a>
<a name="ln227">    dt_dev_process_image(dev);</a>
<a name="ln228">  }</a>
<a name="ln229"> </a>
<a name="ln230">  if(dev-&gt;preview_status == DT_DEV_PIXELPIPE_DIRTY || dev-&gt;preview_status == DT_DEV_PIXELPIPE_INVALID</a>
<a name="ln231">     || dev-&gt;pipe-&gt;input_timestamp &gt; dev-&gt;preview_pipe-&gt;input_timestamp)</a>
<a name="ln232">  {</a>
<a name="ln233">    dt_dev_process_preview(dev);</a>
<a name="ln234">  }</a>
<a name="ln235"> </a>
<a name="ln236">  if(dev-&gt;preview2_status == DT_DEV_PIXELPIPE_DIRTY || dev-&gt;preview2_status == DT_DEV_PIXELPIPE_INVALID</a>
<a name="ln237">     || dev-&gt;pipe-&gt;input_timestamp &gt; dev-&gt;preview2_pipe-&gt;input_timestamp)</a>
<a name="ln238">  {</a>
<a name="ln239">    dt_dev_process_preview2(dev);</a>
<a name="ln240">  }</a>
<a name="ln241"> </a>
<a name="ln242">  dt_pthread_mutex_t *mutex = NULL;</a>
<a name="ln243">  int stride;</a>
<a name="ln244">  const float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln245">  const float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln246">  const dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln247">  const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln248">  const float backbuf_scale = dt_dev_get_zoom_scale(dev, zoom, 1.0f, 0) * darktable.gui-&gt;ppd;</a>
<a name="ln249"> </a>
<a name="ln250">  static cairo_surface_t *image_surface = NULL;</a>
<a name="ln251">  static int image_surface_width = 0, image_surface_height = 0, image_surface_imgid = -1;</a>
<a name="ln252"> </a>
<a name="ln253">  if(image_surface_width != width || image_surface_height != height || image_surface == NULL)</a>
<a name="ln254">  {</a>
<a name="ln255">    // create double-buffered image to draw on, to make modules draw more fluently.</a>
<a name="ln256">    image_surface_width = width;</a>
<a name="ln257">    image_surface_height = height;</a>
<a name="ln258">    if(image_surface) cairo_surface_destroy(image_surface);</a>
<a name="ln259">    image_surface = dt_cairo_image_surface_create(CAIRO_FORMAT_RGB24, width, height);</a>
<a name="ln260">    image_surface_imgid = -1; // invalidate old stuff</a>
<a name="ln261">  }</a>
<a name="ln262">  cairo_surface_t *surface;</a>
<a name="ln263">  cairo_t *cr = cairo_create(image_surface);</a>
<a name="ln264"> </a>
<a name="ln265">  // adjust scroll bars</a>
<a name="ln266">  {</a>
<a name="ln267">    float zx = zoom_x, zy = zoom_y, boxw = 1., boxh = 1.;</a>
<a name="ln268">    dt_dev_check_zoom_bounds(dev, &amp;zx, &amp;zy, zoom, closeup, &amp;boxw, &amp;boxh);</a>
<a name="ln269">    dt_view_set_scrollbar(self, zx, -0.5 + boxw/2, 0.5, boxw/2, zy, -0.5+ boxh/2, 0.5, boxh/2);</a>
<a name="ln270">  }</a>
<a name="ln271"> </a>
<a name="ln272">  if(dev-&gt;pipe-&gt;output_backbuf &amp;&amp; // do we have an image?</a>
<a name="ln273">    dev-&gt;pipe-&gt;output_imgid == dev-&gt;image_storage.id &amp;&amp; // is the right image?</a>
<a name="ln274">    dev-&gt;pipe-&gt;backbuf_scale == backbuf_scale &amp;&amp; // is this the zoom scale we want to display?</a>
<a name="ln275">    dev-&gt;pipe-&gt;backbuf_zoom_x == zoom_x &amp;&amp; dev-&gt;pipe-&gt;backbuf_zoom_y == zoom_y)</a>
<a name="ln276">  {</a>
<a name="ln277">    // draw image</a>
<a name="ln278">    mutex = &amp;dev-&gt;pipe-&gt;backbuf_mutex;</a>
<a name="ln279">    dt_pthread_mutex_lock(mutex);</a>
<a name="ln280">    float wd = dev-&gt;pipe-&gt;output_backbuf_width;</a>
<a name="ln281">    float ht = dev-&gt;pipe-&gt;output_backbuf_height;</a>
<a name="ln282">    stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, wd);</a>
<a name="ln283">    surface = dt_cairo_image_surface_create_for_data(dev-&gt;pipe-&gt;output_backbuf, CAIRO_FORMAT_RGB24, wd, ht, stride);</a>
<a name="ln284">    wd /= darktable.gui-&gt;ppd;</a>
<a name="ln285">    ht /= darktable.gui-&gt;ppd;</a>
<a name="ln286">    if(dev-&gt;full_preview)</a>
<a name="ln287">      dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_DARKROOM_PREVIEW_BG);</a>
<a name="ln288">    else</a>
<a name="ln289">      dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_DARKROOM_BG);</a>
<a name="ln290">    cairo_paint(cr);</a>
<a name="ln291">    cairo_translate(cr, .5f * (width - wd), .5f * (height - ht));</a>
<a name="ln292">    if(closeup)</a>
<a name="ln293">    {</a>
<a name="ln294">      const double scale = 1&lt;&lt;closeup;</a>
<a name="ln295">      cairo_scale(cr, scale, scale);</a>
<a name="ln296">      cairo_translate(cr, -(.5 - 0.5/scale) * wd, -(.5 - 0.5/scale) * ht);</a>
<a name="ln297">    }</a>
<a name="ln298">    cairo_rectangle(cr, 0, 0, wd, ht);</a>
<a name="ln299">    cairo_set_source_surface(cr, surface, 0, 0);</a>
<a name="ln300">    cairo_pattern_set_filter(cairo_get_source(cr), CAIRO_FILTER_FAST);</a>
<a name="ln301">    cairo_fill(cr);</a>
<a name="ln302">    cairo_surface_destroy(surface);</a>
<a name="ln303">    dt_pthread_mutex_unlock(mutex);</a>
<a name="ln304">    image_surface_imgid = dev-&gt;image_storage.id;</a>
<a name="ln305">  }</a>
<a name="ln306">  else if(dev-&gt;preview_pipe-&gt;output_backbuf &amp;&amp; dev-&gt;preview_pipe-&gt;output_imgid == dev-&gt;image_storage.id)</a>
<a name="ln307">  {</a>
<a name="ln308">    // draw preview</a>
<a name="ln309">    mutex = &amp;dev-&gt;preview_pipe-&gt;backbuf_mutex;</a>
<a name="ln310">    dt_pthread_mutex_lock(mutex);</a>
<a name="ln311"> </a>
<a name="ln312">    const float wd = dev-&gt;preview_pipe-&gt;output_backbuf_width;</a>
<a name="ln313">    const float ht = dev-&gt;preview_pipe-&gt;output_backbuf_height;</a>
<a name="ln314">    const float zoom_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln315">    dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_DARKROOM_BG);</a>
<a name="ln316">    cairo_paint(cr);</a>
<a name="ln317">    cairo_rectangle(cr, tb, tb, width-2*tb, height-2*tb);</a>
<a name="ln318">    cairo_clip(cr);</a>
<a name="ln319">    stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, wd);</a>
<a name="ln320">    surface</a>
<a name="ln321">        = cairo_image_surface_create_for_data(dev-&gt;preview_pipe-&gt;output_backbuf, CAIRO_FORMAT_RGB24, wd, ht, stride);</a>
<a name="ln322">    cairo_translate(cr, width / 2.0, height / 2.0f);</a>
<a name="ln323">    cairo_scale(cr, zoom_scale, zoom_scale);</a>
<a name="ln324">    cairo_translate(cr, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln325">    // avoid to draw the 1px garbage that sometimes shows up in the preview :(</a>
<a name="ln326">    cairo_rectangle(cr, 0, 0, wd - 1, ht - 1);</a>
<a name="ln327">    cairo_set_source_surface(cr, surface, 0, 0);</a>
<a name="ln328">    cairo_pattern_set_filter(cairo_get_source(cr), CAIRO_FILTER_FAST);</a>
<a name="ln329">    cairo_fill(cr);</a>
<a name="ln330">    cairo_surface_destroy(surface);</a>
<a name="ln331">    dt_pthread_mutex_unlock(mutex);</a>
<a name="ln332">    image_surface_imgid = dev-&gt;image_storage.id;</a>
<a name="ln333">  }</a>
<a name="ln334">  cairo_restore(cri);</a>
<a name="ln335"> </a>
<a name="ln336">  if(image_surface_imgid == dev-&gt;image_storage.id)</a>
<a name="ln337">  {</a>
<a name="ln338">    cairo_destroy(cr);</a>
<a name="ln339">    cairo_set_source_surface(cri, image_surface, 0, 0);</a>
<a name="ln340">    cairo_paint(cri);</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  /* if we are in full preview mode, we don&quot;t want anything else than the image */</a>
<a name="ln344">  if(dev-&gt;full_preview) return;</a>
<a name="ln345"> </a>
<a name="ln346">  /* check if we should create a snapshot of view */</a>
<a name="ln347">  if(darktable.develop-&gt;proxy.snapshot.request &amp;&amp; !darktable.develop-&gt;image_loading)</a>
<a name="ln348">  {</a>
<a name="ln349">    /* reset the request */</a>
<a name="ln350">    darktable.develop-&gt;proxy.snapshot.request = FALSE;</a>
<a name="ln351"> </a>
<a name="ln352">    /* validation of snapshot filename */</a>
<a name="ln353">    g_assert(darktable.develop-&gt;proxy.snapshot.filename != NULL);</a>
<a name="ln354"> </a>
<a name="ln355">    /* Store current image surface to snapshot file.</a>
<a name="ln356">       FIXME: add checks so that we don't make snapshots of preview pipe image surface.</a>
<a name="ln357">    */</a>
<a name="ln358">    int fd = g_open(darktable.develop-&gt;proxy.snapshot.filename, O_CREAT | O_WRONLY | O_BINARY, 0600);</a>
<a name="ln359">    cairo_surface_write_to_png_stream(image_surface, write_snapshot_data, GINT_TO_POINTER(fd));</a>
<a name="ln360">    close(fd);</a>
<a name="ln361">  }</a>
<a name="ln362"> </a>
<a name="ln363">  // Displaying sample areas if enabled</a>
<a name="ln364">  if(darktable.lib-&gt;proxy.colorpicker.live_samples &amp;&amp; darktable.lib-&gt;proxy.colorpicker.display_samples)</a>
<a name="ln365">  {</a>
<a name="ln366">    GSList *samples = darktable.lib-&gt;proxy.colorpicker.live_samples;</a>
<a name="ln367">    dt_colorpicker_sample_t *sample = NULL;</a>
<a name="ln368"> </a>
<a name="ln369">    cairo_save(cri);</a>
<a name="ln370"> </a>
<a name="ln371">    const float wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln372">    const float ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln373">    const float zoom_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln374"> </a>
<a name="ln375">    cairo_translate(cri, width / 2.0, height / 2.0f);</a>
<a name="ln376">    cairo_scale(cri, zoom_scale, zoom_scale);</a>
<a name="ln377">    cairo_translate(cri, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln378"> </a>
<a name="ln379">    while(samples)</a>
<a name="ln380">    {</a>
<a name="ln381">      sample = samples-&gt;data;</a>
<a name="ln382"> </a>
<a name="ln383">      cairo_set_line_width(cri, 1.0 / zoom_scale);</a>
<a name="ln384">      if(sample == darktable.lib-&gt;proxy.colorpicker.selected_sample)</a>
<a name="ln385">        cairo_set_source_rgb(cri, .2, 0, 0);</a>
<a name="ln386">      else</a>
<a name="ln387">        cairo_set_source_rgb(cri, 0, 0, .2);</a>
<a name="ln388"> </a>
<a name="ln389">      const float *box = sample-&gt;box;</a>
<a name="ln390">      const float *point = sample-&gt;point;</a>
<a name="ln391">      if(sample-&gt;size == DT_COLORPICKER_SIZE_BOX)</a>
<a name="ln392">      {</a>
<a name="ln393">        cairo_rectangle(cri, box[0] * wd, box[1] * ht, (box[2] - box[0]) * wd, (box[3] - box[1]) * ht);</a>
<a name="ln394">        cairo_stroke(cri);</a>
<a name="ln395">        cairo_translate(cri, 1.0 / zoom_scale, 1.0 / zoom_scale);</a>
<a name="ln396">        if(sample == darktable.lib-&gt;proxy.colorpicker.selected_sample)</a>
<a name="ln397">          cairo_set_source_rgb(cri, .8, 0, 0);</a>
<a name="ln398">        else</a>
<a name="ln399">          cairo_set_source_rgb(cri, 0, 0, .8);</a>
<a name="ln400">        cairo_rectangle(cri, box[0] * wd + 1.0 / zoom_scale, box[1] * ht,</a>
<a name="ln401">                        (box[2] - box[0]) * wd - 3. / zoom_scale, (box[3] - box[1]) * ht - 2. / zoom_scale);</a>
<a name="ln402">        cairo_stroke(cri);</a>
<a name="ln403">      }</a>
<a name="ln404">      else</a>
<a name="ln405">      {</a>
<a name="ln406">        cairo_rectangle(cri, point[0] * wd - .01 * wd, point[1] * ht - .01 * wd, .02 * wd, .02 * wd);</a>
<a name="ln407">        cairo_stroke(cri);</a>
<a name="ln408"> </a>
<a name="ln409">        if(sample == darktable.lib-&gt;proxy.colorpicker.selected_sample)</a>
<a name="ln410">          cairo_set_source_rgb(cri, .8, 0, 0);</a>
<a name="ln411">        else</a>
<a name="ln412">          cairo_set_source_rgb(cri, 0, 0, .8);</a>
<a name="ln413">        cairo_rectangle(cri, (point[0] - 0.01) * wd + 1.0 / zoom_scale,</a>
<a name="ln414">                        point[1] * ht - 0.01 * wd + 1.0 / zoom_scale, .02 * wd - 2. / zoom_scale,</a>
<a name="ln415">                        .02 * wd - 2. / zoom_scale);</a>
<a name="ln416">        cairo_move_to(cri, point[0] * wd, point[1] * ht - .01 * wd + 1. / zoom_scale);</a>
<a name="ln417">        cairo_line_to(cri, point[0] * wd, point[1] * ht + .01 * wd - 1. / zoom_scale);</a>
<a name="ln418">        cairo_move_to(cri, point[0] * wd - .01 * wd + 1. / zoom_scale, point[1] * ht);</a>
<a name="ln419">        cairo_line_to(cri, point[0] * wd + .01 * wd - 1. / zoom_scale, point[1] * ht);</a>
<a name="ln420">        cairo_stroke(cri);</a>
<a name="ln421">      }</a>
<a name="ln422"> </a>
<a name="ln423">      samples = g_slist_next(samples);</a>
<a name="ln424">    }</a>
<a name="ln425"> </a>
<a name="ln426">    cairo_restore(cri);</a>
<a name="ln427">  }</a>
<a name="ln428"> </a>
<a name="ln429">  // execute module callback hook.</a>
<a name="ln430">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF)</a>
<a name="ln431">  {</a>
<a name="ln432">    const float wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln433">    const float ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln434">    const float zoom_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln435"> </a>
<a name="ln436">    cairo_translate(cri, width / 2.0, height / 2.0f);</a>
<a name="ln437">    cairo_scale(cri, zoom_scale, zoom_scale);</a>
<a name="ln438">    cairo_translate(cri, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln439"> </a>
<a name="ln440">    cairo_set_line_width(cri, 1.0 / zoom_scale);</a>
<a name="ln441">    cairo_set_source_rgb(cri, .2, .2, .2);</a>
<a name="ln442"> </a>
<a name="ln443">    const float *box = dev-&gt;gui_module-&gt;color_picker_box;</a>
<a name="ln444">    const float *point = dev-&gt;gui_module-&gt;color_picker_point;</a>
<a name="ln445">    if(darktable.lib-&gt;proxy.colorpicker.size)</a>
<a name="ln446">    {</a>
<a name="ln447">      cairo_rectangle(cri, box[0] * wd, box[1] * ht, (box[2] - box[0]) * wd, (box[3] - box[1]) * ht);</a>
<a name="ln448">      cairo_stroke(cri);</a>
<a name="ln449">      cairo_translate(cri, 1.0 / zoom_scale, 1.0 / zoom_scale);</a>
<a name="ln450">      cairo_set_source_rgb(cri, .8, .8, .8);</a>
<a name="ln451">      cairo_rectangle(cri, box[0] * wd + 1.0 / zoom_scale, box[1] * ht,</a>
<a name="ln452">                      (box[2] - box[0]) * wd - 3. / zoom_scale, (box[3] - box[1]) * ht - 2. / zoom_scale);</a>
<a name="ln453">      cairo_stroke(cri);</a>
<a name="ln454">    }</a>
<a name="ln455">    else if(point[0] &gt;= 0.0f &amp;&amp; point[0] &lt;= 1.0f &amp;&amp; point[1] &gt;= 0.0f &amp;&amp; point[1] &lt;= 1.0f)</a>
<a name="ln456">    {</a>
<a name="ln457">      cairo_rectangle(cri, point[0] * wd - .01 * wd, point[1] * ht - .01 * wd, .02 * wd, .02 * wd);</a>
<a name="ln458">      cairo_stroke(cri);</a>
<a name="ln459"> </a>
<a name="ln460">      cairo_set_source_rgb(cri, .8, .8, .8);</a>
<a name="ln461">      cairo_rectangle(cri, (point[0] - 0.01) * wd + 1.0 / zoom_scale,</a>
<a name="ln462">                      point[1] * ht - 0.01 * wd + 1.0 / zoom_scale, .02 * wd - 2. / zoom_scale,</a>
<a name="ln463">                      .02 * wd - 2. / zoom_scale);</a>
<a name="ln464">      cairo_move_to(cri, point[0] * wd, point[1] * ht - .01 * wd + 1. / zoom_scale);</a>
<a name="ln465">      cairo_line_to(cri, point[0] * wd, point[1] * ht + .01 * wd - 1. / zoom_scale);</a>
<a name="ln466">      cairo_move_to(cri, point[0] * wd - .01 * wd + 1. / zoom_scale, point[1] * ht);</a>
<a name="ln467">      cairo_line_to(cri, point[0] * wd + .01 * wd - 1. / zoom_scale, point[1] * ht);</a>
<a name="ln468">      cairo_stroke(cri);</a>
<a name="ln469">    }</a>
<a name="ln470">  }</a>
<a name="ln471">  else</a>
<a name="ln472">  {</a>
<a name="ln473">    // masks</a>
<a name="ln474">    if(dev-&gt;form_visible)</a>
<a name="ln475">      dt_masks_events_post_expose(dev-&gt;gui_module, cri, width, height, pointerx, pointery);</a>
<a name="ln476">    // module</a>
<a name="ln477">    if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;gui_post_expose)</a>
<a name="ln478">      dev-&gt;gui_module-&gt;gui_post_expose(dev-&gt;gui_module, cri, width, height, pointerx, pointery);</a>
<a name="ln479">  }</a>
<a name="ln480"> </a>
<a name="ln481">  // indicate if we are in gamut check or softproof mode</a>
<a name="ln482">  if(darktable.color_profiles-&gt;mode != DT_PROFILE_NORMAL)</a>
<a name="ln483">  {</a>
<a name="ln484">    gchar *label = darktable.color_profiles-&gt;mode == DT_PROFILE_GAMUTCHECK ? _(&quot;gamut check&quot;) : _(&quot;soft proof&quot;);</a>
<a name="ln485">    cairo_set_source_rgba(cri, 0.5, 0.5, 0.5, 0.5);</a>
<a name="ln486">    PangoLayout *layout;</a>
<a name="ln487">    PangoRectangle ink;</a>
<a name="ln488">    PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln489">    pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln490">    layout = pango_cairo_create_layout(cri);</a>
<a name="ln491">    pango_font_description_set_absolute_size(desc, DT_PIXEL_APPLY_DPI(20) * PANGO_SCALE);</a>
<a name="ln492">    pango_layout_set_font_description(layout, desc);</a>
<a name="ln493">    pango_layout_set_text(layout, label, -1);</a>
<a name="ln494">    pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln495">    cairo_move_to(cri, ink.height * 2, height - (ink.height * 3));</a>
<a name="ln496">    pango_cairo_layout_path(cri, layout);</a>
<a name="ln497">    cairo_set_source_rgb(cri, 0.7, 0.7, 0.7);</a>
<a name="ln498">    cairo_fill_preserve(cri);</a>
<a name="ln499">    cairo_set_line_width(cri, 0.7);</a>
<a name="ln500">    cairo_set_source_rgb(cri, 0.3, 0.3, 0.3);</a>
<a name="ln501">    cairo_stroke(cri);</a>
<a name="ln502">    pango_font_description_free(desc);</a>
<a name="ln503">    g_object_unref(layout);</a>
<a name="ln504">  }</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">void reset(dt_view_t *self)</a>
<a name="ln508">{</a>
<a name="ln509">  dt_control_set_dev_zoom(DT_ZOOM_FIT);</a>
<a name="ln510">  dt_control_set_dev_zoom_x(0);</a>
<a name="ln511">  dt_control_set_dev_zoom_y(0);</a>
<a name="ln512">  dt_control_set_dev_closeup(0);</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">int try_enter(dt_view_t *self)</a>
<a name="ln516">{</a>
<a name="ln517">  int selected = dt_control_get_mouse_over_id();</a>
<a name="ln518">  if(selected &lt; 0)</a>
<a name="ln519">  {</a>
<a name="ln520">    // try last selected</a>
<a name="ln521">    sqlite3_stmt *stmt;</a>
<a name="ln522">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;, -1, &amp;stmt,</a>
<a name="ln523">                                NULL);</a>
<a name="ln524">    if(sqlite3_step(stmt) == SQLITE_ROW) selected = sqlite3_column_int(stmt, 0);</a>
<a name="ln525">    sqlite3_finalize(stmt);</a>
<a name="ln526"> </a>
<a name="ln527">    // Leave as selected only the image being edited</a>
<a name="ln528">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images&quot;, NULL, NULL, NULL);</a>
<a name="ln529">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln530">                                &quot;INSERT OR IGNORE INTO main.selected_images VALUES (?1)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln531">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, selected);</a>
<a name="ln532">    sqlite3_step(stmt);</a>
<a name="ln533">    sqlite3_finalize(stmt);</a>
<a name="ln534">  }</a>
<a name="ln535"> </a>
<a name="ln536">  if(selected &lt; 0)</a>
<a name="ln537">  {</a>
<a name="ln538">    // fail :(</a>
<a name="ln539">    dt_control_log(_(&quot;no image selected!&quot;));</a>
<a name="ln540">    return 1;</a>
<a name="ln541">  }</a>
<a name="ln542"> </a>
<a name="ln543">  // this loads the image from db if needed:</a>
<a name="ln544">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, selected, 'r');</a>
<a name="ln545">  // get image and check if it has been deleted from disk first!</a>
<a name="ln546"> </a>
<a name="ln547">  char imgfilename[PATH_MAX] = { 0 };</a>
<a name="ln548">  gboolean from_cache = TRUE;</a>
<a name="ln549">  dt_image_full_path(img-&gt;id, imgfilename, sizeof(imgfilename), &amp;from_cache);</a>
<a name="ln550">  if(!g_file_test(imgfilename, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln551">  {</a>
<a name="ln552">    dt_control_log(_(&quot;image `%s' is currently unavailable&quot;), img-&gt;filename);</a>
<a name="ln553">    // dt_image_remove(selected);</a>
<a name="ln554">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln555">    return 1;</a>
<a name="ln556">  }</a>
<a name="ln557">  // and drop the lock again.</a>
<a name="ln558">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln559">  darktable.develop-&gt;image_storage.id = selected;</a>
<a name="ln560">  return 0;</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563"> </a>
<a name="ln564"> </a>
<a name="ln565">static void select_this_image(const int imgid)</a>
<a name="ln566">{</a>
<a name="ln567">  sqlite3_stmt *stmt;</a>
<a name="ln568">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images&quot;, NULL, NULL, NULL);</a>
<a name="ln569">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln570">                              &quot;INSERT OR IGNORE INTO main.selected_images VALUES (?1)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln571">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln572">  sqlite3_step(stmt);</a>
<a name="ln573">  sqlite3_finalize(stmt);</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">static void dt_dev_cleanup_module_accels(dt_iop_module_t *module)</a>
<a name="ln577">{</a>
<a name="ln578">  dt_accel_disconnect_list(module-&gt;accel_closures);</a>
<a name="ln579">  dt_accel_cleanup_locals_iop(module);</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">static void dt_dev_change_image(dt_develop_t *dev, const uint32_t imgid)</a>
<a name="ln583">{</a>
<a name="ln584">  // stop crazy users from sleeping on key-repeat spacebar:</a>
<a name="ln585">  if(dev-&gt;image_loading) return;</a>
<a name="ln586"> </a>
<a name="ln587">  // disable color picker when changing image</a>
<a name="ln588">  if(dev-&gt;gui_module)</a>
<a name="ln589">  {</a>
<a name="ln590">    dev-&gt;gui_module-&gt;request_color_pick = DT_REQUEST_COLORPICK_OFF;</a>
<a name="ln591">  }</a>
<a name="ln592"> </a>
<a name="ln593">  // update aspect ratio</a>
<a name="ln594">  if(dev-&gt;preview_pipe-&gt;backbuf &amp;&amp; dev-&gt;preview_status == DT_DEV_PIXELPIPE_VALID)</a>
<a name="ln595">  {</a>
<a name="ln596">    double aspect_ratio = (double)dev-&gt;preview_pipe-&gt;backbuf_width / (double)dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln597">    dt_image_set_aspect_ratio_to(dev-&gt;preview_pipe-&gt;image.id, aspect_ratio);</a>
<a name="ln598">  }</a>
<a name="ln599">  else</a>
<a name="ln600">  {</a>
<a name="ln601">    dt_image_set_aspect_ratio(dev-&gt;image_storage.id);</a>
<a name="ln602">  }</a>
<a name="ln603"> </a>
<a name="ln604">  // clean the undo list</a>
<a name="ln605">  dt_undo_clear(darktable.undo, DT_UNDO_DEVELOP);</a>
<a name="ln606"> </a>
<a name="ln607">  // prevent accels_window to refresh</a>
<a name="ln608">  darktable.view_manager-&gt;accels_window.prevent_refresh = TRUE;</a>
<a name="ln609"> </a>
<a name="ln610">  // make sure we can destroy and re-setup the pixel pipes.</a>
<a name="ln611">  // we acquire the pipe locks, which will block the processing threads</a>
<a name="ln612">  // in darkroom mode before they touch the pipes (init buffers etc).</a>
<a name="ln613">  // we don't block here, since we hold the gdk lock, which will</a>
<a name="ln614">  // result in circular locking when background threads emit signals</a>
<a name="ln615">  // which in turn try to acquire the gdk lock.</a>
<a name="ln616">  //</a>
<a name="ln617">  // worst case, it'll drop some change image events. sorry.</a>
<a name="ln618">  if(dt_pthread_mutex_BAD_trylock(&amp;dev-&gt;preview_pipe_mutex)) return;</a>
<a name="ln619">  if(dt_pthread_mutex_BAD_trylock(&amp;dev-&gt;pipe_mutex))</a>
<a name="ln620">  {</a>
<a name="ln621">    dt_pthread_mutex_BAD_unlock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln622">    return;</a>
<a name="ln623">  }</a>
<a name="ln624">  if(dt_pthread_mutex_BAD_trylock(&amp;dev-&gt;preview2_pipe_mutex))</a>
<a name="ln625">  {</a>
<a name="ln626">    dt_pthread_mutex_BAD_unlock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln627">    dt_pthread_mutex_BAD_unlock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln628">    return;</a>
<a name="ln629">  }</a>
<a name="ln630"> </a>
<a name="ln631">  // get last active plugin, make sure focus out is called:</a>
<a name="ln632">  gchar *active_plugin = dt_conf_get_string(&quot;plugins/darkroom/active&quot;);</a>
<a name="ln633">  dt_iop_request_focus(NULL);</a>
<a name="ln634">  // store last active group</a>
<a name="ln635">  dt_conf_set_int(&quot;plugins/darkroom/groups&quot;, dt_dev_modulegroups_get(dev));</a>
<a name="ln636"> </a>
<a name="ln637">  // store last active plugin:</a>
<a name="ln638">  if(darktable.develop-&gt;gui_module)</a>
<a name="ln639">    dt_conf_set_string(&quot;plugins/darkroom/active&quot;, darktable.develop-&gt;gui_module-&gt;op);</a>
<a name="ln640">  else</a>
<a name="ln641">    dt_conf_set_string(&quot;plugins/darkroom/active&quot;, &quot;&quot;);</a>
<a name="ln642">  g_assert(dev-&gt;gui_attached);</a>
<a name="ln643"> </a>
<a name="ln644">  // commit image ops to db</a>
<a name="ln645">  dt_dev_write_history(dev);</a>
<a name="ln646"> </a>
<a name="ln647">  // be sure light table will update the thumbnail</a>
<a name="ln648">  // TODO: only if image changed!</a>
<a name="ln649">  // if()</a>
<a name="ln650">  {</a>
<a name="ln651">    dt_mipmap_cache_remove(darktable.mipmap_cache, dev-&gt;image_storage.id);</a>
<a name="ln652">    dt_image_reset_final_size(dev-&gt;image_storage.id);</a>
<a name="ln653">    dt_image_synch_xmp(dev-&gt;image_storage.id);</a>
<a name="ln654">  }</a>
<a name="ln655"> </a>
<a name="ln656">  // cleanup visible masks</a>
<a name="ln657">  if(!dev-&gt;form_gui)</a>
<a name="ln658">  {</a>
<a name="ln659">    dev-&gt;form_gui = (dt_masks_form_gui_t *)calloc(1, sizeof(dt_masks_form_gui_t));</a>
<a name="ln660">    dt_masks_init_form_gui(dev-&gt;form_gui);</a>
<a name="ln661">  }</a>
<a name="ln662">  dt_masks_change_form_gui(NULL);</a>
<a name="ln663"> </a>
<a name="ln664">  select_this_image(imgid);</a>
<a name="ln665"> </a>
<a name="ln666">  while(dev-&gt;history)</a>
<a name="ln667">  {</a>
<a name="ln668">    // clear history of old image</a>
<a name="ln669">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(dev-&gt;history-&gt;data);</a>
<a name="ln670">    dt_dev_free_history_item(hist);</a>
<a name="ln671">    dev-&gt;history = g_list_delete_link(dev-&gt;history, dev-&gt;history);</a>
<a name="ln672">  }</a>
<a name="ln673"> </a>
<a name="ln674">  // get new image:</a>
<a name="ln675">  dt_dev_reload_image(dev, imgid);</a>
<a name="ln676"> </a>
<a name="ln677">  // make sure no signals propagate here:</a>
<a name="ln678">  const int reset = darktable.gui-&gt;reset;</a>
<a name="ln679">  darktable.gui-&gt;reset = 1;</a>
<a name="ln680"> </a>
<a name="ln681">  const guint nb_iop = g_list_length(dev-&gt;iop);</a>
<a name="ln682">  dt_dev_pixelpipe_cleanup_nodes(dev-&gt;pipe);</a>
<a name="ln683">  dt_dev_pixelpipe_cleanup_nodes(dev-&gt;preview_pipe);</a>
<a name="ln684">  dt_dev_pixelpipe_cleanup_nodes(dev-&gt;preview2_pipe);</a>
<a name="ln685">  for(int i = nb_iop - 1; i &gt;= 0; i--)</a>
<a name="ln686">  {</a>
<a name="ln687">    dt_iop_module_t *module = (dt_iop_module_t *)(g_list_nth_data(dev-&gt;iop, i));</a>
<a name="ln688"> </a>
<a name="ln689">    // the base module is the one with the lowest multi_priority</a>
<a name="ln690">    const guint clen = g_list_length(dev-&gt;iop);</a>
<a name="ln691">    int base_multi_priority = 0;</a>
<a name="ln692">    for(int k = 0; k &lt; clen; k++)</a>
<a name="ln693">    {</a>
<a name="ln694">      dt_iop_module_t *mod = (dt_iop_module_t *)(g_list_nth_data(dev-&gt;iop, k));</a>
<a name="ln695">      if(strcmp(module-&gt;op, mod-&gt;op) == 0) base_multi_priority = MIN(base_multi_priority, mod-&gt;multi_priority);</a>
<a name="ln696">    }</a>
<a name="ln697"> </a>
<a name="ln698">    if(module-&gt;multi_priority == base_multi_priority) // if the module is the &quot;base&quot; instance, we keep it</a>
<a name="ln699">    {</a>
<a name="ln700">      if(dev-&gt;iop_order_list)</a>
<a name="ln701">        module-&gt;iop_order = dt_ioppr_get_iop_order(dev-&gt;iop_order_list, module-&gt;op);</a>
<a name="ln702">      else</a>
<a name="ln703">        module-&gt;iop_order = dt_ioppr_get_iop_order(darktable.iop_order_list, module-&gt;op);</a>
<a name="ln704">      module-&gt;multi_priority = 0;</a>
<a name="ln705">      module-&gt;multi_name[0] = '\0';</a>
<a name="ln706">      dt_iop_reload_defaults(module);</a>
<a name="ln707">      dt_iop_gui_update(module);</a>
<a name="ln708">    }</a>
<a name="ln709">    else // else we delete it and remove it from the panel</a>
<a name="ln710">    {</a>
<a name="ln711">      if(!dt_iop_is_hidden(module))</a>
<a name="ln712">      {</a>
<a name="ln713">        gtk_widget_destroy(module-&gt;expander);</a>
<a name="ln714">        dt_iop_gui_cleanup_module(module);</a>
<a name="ln715">      }</a>
<a name="ln716"> </a>
<a name="ln717">      // we remove the module from the list</a>
<a name="ln718">      dev-&gt;iop = g_list_remove_link(dev-&gt;iop, g_list_nth(dev-&gt;iop, i));</a>
<a name="ln719"> </a>
<a name="ln720">      // we cleanup the module</a>
<a name="ln721">      dt_accel_disconnect_list(module-&gt;accel_closures);</a>
<a name="ln722">      dt_accel_cleanup_locals_iop(module);</a>
<a name="ln723">      module-&gt;accel_closures = NULL;</a>
<a name="ln724">      dt_iop_cleanup_module(module);</a>
<a name="ln725">      free(module);</a>
<a name="ln726">    }</a>
<a name="ln727">  }</a>
<a name="ln728">  dev-&gt;iop = g_list_sort(dev-&gt;iop, dt_sort_iop_by_order);</a>
<a name="ln729"> </a>
<a name="ln730">  // we also clear the saved modules</a>
<a name="ln731">  while(dev-&gt;alliop)</a>
<a name="ln732">  {</a>
<a name="ln733">    dt_iop_cleanup_module((dt_iop_module_t *)dev-&gt;alliop-&gt;data);</a>
<a name="ln734">    free(dev-&gt;alliop-&gt;data);</a>
<a name="ln735">    dev-&gt;alliop = g_list_delete_link(dev-&gt;alliop, dev-&gt;alliop);</a>
<a name="ln736">  }</a>
<a name="ln737">  // and masks</a>
<a name="ln738">  g_list_free_full(dev-&gt;forms, (void (*)(void *))dt_masks_free_form);</a>
<a name="ln739">  dev-&gt;forms = NULL;</a>
<a name="ln740">  g_list_free_full(dev-&gt;allforms, (void (*)(void *))dt_masks_free_form);</a>
<a name="ln741">  dev-&gt;allforms = NULL;</a>
<a name="ln742"> </a>
<a name="ln743">  dt_dev_pixelpipe_create_nodes(dev-&gt;pipe, dev);</a>
<a name="ln744">  dt_dev_pixelpipe_create_nodes(dev-&gt;preview_pipe, dev);</a>
<a name="ln745">  if(dev-&gt;second_window.widget &amp;&amp; GTK_IS_WIDGET(dev-&gt;second_window.widget))</a>
<a name="ln746">    dt_dev_pixelpipe_create_nodes(dev-&gt;preview2_pipe, dev);</a>
<a name="ln747">  dt_dev_read_history(dev);</a>
<a name="ln748"> </a>
<a name="ln749">  // we have to init all module instances other than &quot;base&quot; instance</a>
<a name="ln750">  GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln751">  while(modules)</a>
<a name="ln752">  {</a>
<a name="ln753">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln754">    if(module-&gt;multi_priority &gt; 0)</a>
<a name="ln755">    {</a>
<a name="ln756">      if(!dt_iop_is_hidden(module))</a>
<a name="ln757">      {</a>
<a name="ln758">        module-&gt;gui_init(module);</a>
<a name="ln759">        dt_iop_reload_defaults(module);</a>
<a name="ln760"> </a>
<a name="ln761">        /* add module to right panel */</a>
<a name="ln762">        GtkWidget *expander = dt_iop_gui_get_expander(module);</a>
<a name="ln763">        dt_ui_container_add_widget(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER, expander);</a>
<a name="ln764">        dt_iop_gui_set_expanded(module, FALSE, FALSE);</a>
<a name="ln765">        dt_iop_gui_update_blending(module);</a>
<a name="ln766">      }</a>
<a name="ln767"> </a>
<a name="ln768">      /* setup key accelerators */</a>
<a name="ln769">      module-&gt;accel_closures = NULL;</a>
<a name="ln770">      if(module-&gt;connect_key_accels) module-&gt;connect_key_accels(module);</a>
<a name="ln771">      dt_iop_connect_common_accels(module);</a>
<a name="ln772">    }</a>
<a name="ln773">    else</a>
<a name="ln774">    {</a>
<a name="ln775">      //  update the module header to ensure proper multi-name display</a>
<a name="ln776">      if(!dt_iop_is_hidden(module))</a>
<a name="ln777">      {</a>
<a name="ln778">        if(module-&gt;change_image) module-&gt;change_image(module);</a>
<a name="ln779">        dt_iop_gui_update_header(module);</a>
<a name="ln780">      }</a>
<a name="ln781">    }</a>
<a name="ln782"> </a>
<a name="ln783">    modules = g_list_previous(modules);</a>
<a name="ln784">  }</a>
<a name="ln785"> </a>
<a name="ln786">  dt_dev_pop_history_items(dev, dev-&gt;history_end);</a>
<a name="ln787"> </a>
<a name="ln788">  // set the module list order</a>
<a name="ln789">  dt_dev_reorder_gui_module_list(dev);</a>
<a name="ln790"> </a>
<a name="ln791">  if(active_plugin)</a>
<a name="ln792">  {</a>
<a name="ln793">    modules = dev-&gt;iop;</a>
<a name="ln794">    while(modules)</a>
<a name="ln795">    {</a>
<a name="ln796">      dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln797">      if(!strcmp(module-&gt;op, active_plugin)) dt_iop_request_focus(module);</a>
<a name="ln798">      modules = g_list_next(modules);</a>
<a name="ln799">    }</a>
<a name="ln800">    g_free(active_plugin);</a>
<a name="ln801">  }</a>
<a name="ln802"> </a>
<a name="ln803">  dt_dev_masks_list_change(dev);</a>
<a name="ln804"> </a>
<a name="ln805">  /* last set the group to update visibility of iop modules for new pipe */</a>
<a name="ln806">  dt_dev_modulegroups_set(dev, dt_conf_get_int(&quot;plugins/darkroom/groups&quot;));</a>
<a name="ln807"> </a>
<a name="ln808">  /* cleanup histograms */</a>
<a name="ln809">  g_list_foreach(dev-&gt;iop, (GFunc)dt_iop_cleanup_histogram, (gpointer)NULL);</a>
<a name="ln810"> </a>
<a name="ln811">  // make signals work again, but only after focus event,</a>
<a name="ln812">  // to avoid crop/rotate for example to add another history item.</a>
<a name="ln813">  darktable.gui-&gt;reset = reset;</a>
<a name="ln814"> </a>
<a name="ln815">  // Signal develop initialize</a>
<a name="ln816">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_IMAGE_CHANGED);</a>
<a name="ln817"> </a>
<a name="ln818">  // prefetch next few from first selected image on.</a>
<a name="ln819">  dt_view_filmstrip_prefetch();</a>
<a name="ln820"> </a>
<a name="ln821">  // release pixel pipe mutices</a>
<a name="ln822">  dt_pthread_mutex_BAD_unlock(&amp;dev-&gt;preview2_pipe_mutex);</a>
<a name="ln823">  dt_pthread_mutex_BAD_unlock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln824">  dt_pthread_mutex_BAD_unlock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln825"> </a>
<a name="ln826">  // update hint message</a>
<a name="ln827">  dt_collection_hint_message(darktable.collection);</a>
<a name="ln828"> </a>
<a name="ln829">  // update accels_window</a>
<a name="ln830">  darktable.view_manager-&gt;accels_window.prevent_refresh = FALSE;</a>
<a name="ln831">  if(darktable.view_manager-&gt;accels_window.window &amp;&amp; darktable.view_manager-&gt;accels_window.sticky)</a>
<a name="ln832">    dt_view_accels_refresh(darktable.view_manager);</a>
<a name="ln833">}</a>
<a name="ln834"> </a>
<a name="ln835">static void film_strip_activated(const int imgid, void *data)</a>
<a name="ln836">{</a>
<a name="ln837">  // switch images in darkroom mode:</a>
<a name="ln838">  const dt_view_t *self = (dt_view_t *)data;</a>
<a name="ln839">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln840"> </a>
<a name="ln841">  dt_dev_change_image(dev, imgid);</a>
<a name="ln842">  dt_view_filmstrip_scroll_to_image(darktable.view_manager, imgid, FALSE);</a>
<a name="ln843">  // record the imgid to display when going back to lighttable</a>
<a name="ln844">  dt_view_lighttable_set_position(darktable.view_manager, dt_collection_image_offset(imgid));</a>
<a name="ln845">  // force redraw</a>
<a name="ln846">  dt_control_queue_redraw();</a>
<a name="ln847">}</a>
<a name="ln848"> </a>
<a name="ln849">static void _view_darkroom_filmstrip_activate_callback(gpointer instance, gpointer user_data)</a>
<a name="ln850">{</a>
<a name="ln851">  int32_t imgid = 0;</a>
<a name="ln852">  if((imgid = dt_view_filmstrip_get_activated_imgid(darktable.view_manager)) &gt; 0)</a>
<a name="ln853">    film_strip_activated(imgid, user_data);</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">static void dt_dev_jump_image(dt_develop_t *dev, int diff)</a>
<a name="ln857">{</a>
<a name="ln858">  const gchar *qin = dt_collection_get_query(darktable.collection);</a>
<a name="ln859">  int offset = 0;</a>
<a name="ln860">  if(qin)</a>
<a name="ln861">  {</a>
<a name="ln862">    int orig_imgid = -1, imgid = -1;</a>
<a name="ln863">    sqlite3_stmt *stmt;</a>
<a name="ln864"> </a>
<a name="ln865">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;, -1, &amp;stmt,</a>
<a name="ln866">                                NULL);</a>
<a name="ln867">    if(sqlite3_step(stmt) == SQLITE_ROW) orig_imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln868">    sqlite3_finalize(stmt);</a>
<a name="ln869"> </a>
<a name="ln870">    offset = dt_collection_image_offset(orig_imgid);</a>
<a name="ln871"> </a>
<a name="ln872">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), qin, -1, &amp;stmt, NULL);</a>
<a name="ln873">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, offset + diff);</a>
<a name="ln874">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, 1);</a>
<a name="ln875">    if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln876">    {</a>
<a name="ln877">      imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln878"> </a>
<a name="ln879">      if(orig_imgid == imgid)</a>
<a name="ln880">      {</a>
<a name="ln881">        // nothing to do</a>
<a name="ln882">        sqlite3_finalize(stmt);</a>
<a name="ln883">        return;</a>
<a name="ln884">      }</a>
<a name="ln885"> </a>
<a name="ln886">      if(!dev-&gt;image_loading)</a>
<a name="ln887">      {</a>
<a name="ln888">        dt_dev_change_image(dev, imgid);</a>
<a name="ln889">        dt_view_filmstrip_scroll_to_image(darktable.view_manager, imgid, FALSE);</a>
<a name="ln890">        // record the imgid to display when going back to lighttable</a>
<a name="ln891">        dt_view_lighttable_set_position(darktable.view_manager, dt_collection_image_offset(imgid));</a>
<a name="ln892">      }</a>
<a name="ln893">    }</a>
<a name="ln894">    sqlite3_finalize(stmt);</a>
<a name="ln895">  }</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898">static gboolean zoom_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln899">                               GdkModifierType modifier, gpointer data)</a>
<a name="ln900">{</a>
<a name="ln901">  dt_develop_t *dev = darktable.develop;</a>
<a name="ln902">  int zoom, closeup;</a>
<a name="ln903">  float zoom_x, zoom_y;</a>
<a name="ln904">  switch(GPOINTER_TO_INT(data))</a>
<a name="ln905">  {</a>
<a name="ln906">    case 1:</a>
<a name="ln907">      zoom = dt_control_get_dev_zoom();</a>
<a name="ln908">      zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln909">      zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln910">      closeup = dt_control_get_dev_closeup();</a>
<a name="ln911">      if(zoom == DT_ZOOM_1) closeup = (closeup &gt; 0) ^ 1; // flip closeup/no closeup, no difference whether it was 1 or larger</a>
<a name="ln912">      dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, DT_ZOOM_1, closeup, NULL, NULL);</a>
<a name="ln913">      dt_control_set_dev_zoom(DT_ZOOM_1);</a>
<a name="ln914">      dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln915">      dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln916">      dt_control_set_dev_closeup(closeup);</a>
<a name="ln917">      break;</a>
<a name="ln918">    case 2:</a>
<a name="ln919">      zoom_x = zoom_y = 0.0f;</a>
<a name="ln920">      dt_control_set_dev_zoom(DT_ZOOM_FILL);</a>
<a name="ln921">      dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, DT_ZOOM_FILL, 0, NULL, NULL);</a>
<a name="ln922">      dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln923">      dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln924">      dt_control_set_dev_closeup(0);</a>
<a name="ln925">      break;</a>
<a name="ln926">    case 3:</a>
<a name="ln927">      dt_control_set_dev_zoom(DT_ZOOM_FIT);</a>
<a name="ln928">      dt_control_set_dev_zoom_x(0);</a>
<a name="ln929">      dt_control_set_dev_zoom_y(0);</a>
<a name="ln930">      dt_control_set_dev_closeup(0);</a>
<a name="ln931">      break;</a>
<a name="ln932">    default:</a>
<a name="ln933">      break;</a>
<a name="ln934">  }</a>
<a name="ln935">  dt_dev_invalidate(dev);</a>
<a name="ln936">  dt_control_queue_redraw_center();</a>
<a name="ln937">  dt_control_navigation_redraw();</a>
<a name="ln938">  return TRUE;</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941">static gboolean film_strip_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln942">                                     GdkModifierType modifier, gpointer data)</a>
<a name="ln943">{</a>
<a name="ln944">  dt_lib_module_t *m = darktable.view_manager-&gt;proxy.filmstrip.module;</a>
<a name="ln945">  gboolean vs = dt_lib_is_visible(m);</a>
<a name="ln946">  dt_lib_set_visible(m, !vs);</a>
<a name="ln947">  return TRUE;</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950"> </a>
<a name="ln951">static gboolean export_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln952">                                          GdkModifierType modifier, gpointer data)</a>
<a name="ln953">{</a>
<a name="ln954">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln955"> </a>
<a name="ln956">  /* write history before exporting */</a>
<a name="ln957">  dt_dev_write_history(dev);</a>
<a name="ln958"> </a>
<a name="ln959">  /* export current image */</a>
<a name="ln960">  const int max_width = dt_conf_get_int(&quot;plugins/lighttable/export/width&quot;);</a>
<a name="ln961">  const int max_height = dt_conf_get_int(&quot;plugins/lighttable/export/height&quot;);</a>
<a name="ln962">  char *format_name = dt_conf_get_string(&quot;plugins/lighttable/export/format_name&quot;);</a>
<a name="ln963">  char *storage_name = dt_conf_get_string(&quot;plugins/lighttable/export/storage_name&quot;);</a>
<a name="ln964">  const int format_index = dt_imageio_get_index_of_format(dt_imageio_get_format_by_name(format_name));</a>
<a name="ln965">  const int storage_index = dt_imageio_get_index_of_storage(dt_imageio_get_storage_by_name(storage_name));</a>
<a name="ln966">  const gboolean high_quality = dt_conf_get_bool(&quot;plugins/lighttable/export/high_quality_processing&quot;);</a>
<a name="ln967">  const gboolean upscale = dt_conf_get_bool(&quot;plugins/lighttable/export/upscale&quot;);</a>
<a name="ln968">  char *style = dt_conf_get_string(&quot;plugins/lighttable/export/style&quot;);</a>
<a name="ln969">  const gboolean style_append = dt_conf_get_bool(&quot;plugins/lighttable/export/style_append&quot;);</a>
<a name="ln970">  dt_colorspaces_color_profile_type_t icc_type = dt_conf_get_int(&quot;plugins/lighttable/export/icctype&quot;);</a>
<a name="ln971">  gchar *icc_filename = dt_conf_get_string(&quot;plugins/lighttable/export/iccprofile&quot;);</a>
<a name="ln972">  dt_iop_color_intent_t icc_intent = dt_conf_get_int(&quot;plugins/lighttable/export/iccintent&quot;);</a>
<a name="ln973">  gchar *metadata_export = dt_conf_get_string(&quot;plugins/lighttable/export/metadata&quot;);</a>
<a name="ln974">  // darkroom is for single images, so only export the one the user is working on</a>
<a name="ln975">  GList *l = g_list_append(NULL, GINT_TO_POINTER(dev-&gt;image_storage.id));</a>
<a name="ln976">  dt_control_export(l, max_width, max_height, format_index, storage_index, high_quality, upscale, style, style_append,</a>
<a name="ln977">                    icc_type, icc_filename, icc_intent, metadata_export);</a>
<a name="ln978">  g_free(format_name);</a>
<a name="ln979">  g_free(storage_name);</a>
<a name="ln980">  g_free(style);</a>
<a name="ln981">  g_free(icc_filename);</a>
<a name="ln982">  g_free(metadata_export);</a>
<a name="ln983">  return TRUE;</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986">static gboolean skip_f_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln987">                                          GdkModifierType modifier, gpointer data)</a>
<a name="ln988">{</a>
<a name="ln989">  dt_dev_jump_image((dt_develop_t *)data, 1);</a>
<a name="ln990">  return TRUE;</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">static gboolean skip_b_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln994">                                          GdkModifierType modifier, gpointer data)</a>
<a name="ln995">{</a>
<a name="ln996">  dt_dev_jump_image((dt_develop_t *)data, -1);</a>
<a name="ln997">  return TRUE;</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000">static void _darkroom_ui_pipe_finish_signal_callback(gpointer instance, gpointer data)</a>
<a name="ln1001">{</a>
<a name="ln1002">  dt_control_queue_redraw_center();</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005">static void _darkroom_ui_preview2_pipe_finish_signal_callback(gpointer instance, gpointer user_data)</a>
<a name="ln1006">{</a>
<a name="ln1007">  dt_view_t *self = (dt_view_t *)user_data;</a>
<a name="ln1008">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln1009">  if(dev-&gt;second_window.widget)</a>
<a name="ln1010">    gtk_widget_queue_draw(dev-&gt;second_window.widget);</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">static void _darkroom_ui_favorite_presets_popupmenu(GtkWidget *w, gpointer user_data)</a>
<a name="ln1014">{</a>
<a name="ln1015">  /* create favorites menu and popup */</a>
<a name="ln1016">  dt_gui_favorite_presets_menu_show();</a>
<a name="ln1017"> </a>
<a name="ln1018">  /* if we got any styles, lets popup menu for selection */</a>
<a name="ln1019">  if(darktable.gui-&gt;presets_popup_menu)</a>
<a name="ln1020">  {</a>
<a name="ln1021">    gtk_widget_show_all(GTK_WIDGET(darktable.gui-&gt;presets_popup_menu));</a>
<a name="ln1022"> </a>
<a name="ln1023">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln1024">    gtk_menu_popup_at_pointer(darktable.gui-&gt;presets_popup_menu, NULL);</a>
<a name="ln1025">#else</a>
<a name="ln1026">    gtk_menu_popup(darktable.gui-&gt;presets_popup_menu, NULL, NULL, NULL, NULL, 0, 0);</a>
<a name="ln1027">#endif</a>
<a name="ln1028">  }</a>
<a name="ln1029">  else</a>
<a name="ln1030">    dt_control_log(_(&quot;no userdefined presets for favorite modules were found&quot;));</a>
<a name="ln1031">}</a>
<a name="ln1032"> </a>
<a name="ln1033">static void _darkroom_ui_apply_style_activate_callback(gchar *name)</a>
<a name="ln1034">{</a>
<a name="ln1035">  dt_control_log(_(&quot;applied style `%s' on current image&quot;), name);</a>
<a name="ln1036"> </a>
<a name="ln1037">  /* write current history changes so nothing gets lost */</a>
<a name="ln1038">  dt_dev_write_history(darktable.develop);</a>
<a name="ln1039"> </a>
<a name="ln1040">  /* apply style on image and reload*/</a>
<a name="ln1041">  dt_styles_apply_to_image(name, FALSE, darktable.develop-&gt;image_storage.id);</a>
<a name="ln1042">  dt_dev_reload_image(darktable.develop, darktable.develop-&gt;image_storage.id);</a>
<a name="ln1043">}</a>
<a name="ln1044"> </a>
<a name="ln1045">static void _darkroom_ui_apply_style_popupmenu(GtkWidget *w, gpointer user_data)</a>
<a name="ln1046">{</a>
<a name="ln1047">  /* show styles popup menu */</a>
<a name="ln1048">  GList *styles = dt_styles_get_list(&quot;&quot;);</a>
<a name="ln1049">  GtkMenuShell *menu = NULL;</a>
<a name="ln1050">  if(styles)</a>
<a name="ln1051">  {</a>
<a name="ln1052">    menu = GTK_MENU_SHELL(gtk_menu_new());</a>
<a name="ln1053">    do</a>
<a name="ln1054">    {</a>
<a name="ln1055">      dt_style_t *style = (dt_style_t *)styles-&gt;data;</a>
<a name="ln1056"> </a>
<a name="ln1057">      char *items_string = dt_styles_get_item_list_as_string(style-&gt;name);</a>
<a name="ln1058">      gchar *tooltip = NULL;</a>
<a name="ln1059"> </a>
<a name="ln1060">      if(style-&gt;description &amp;&amp; *style-&gt;description)</a>
<a name="ln1061">      {</a>
<a name="ln1062">        tooltip = g_strconcat(&quot;&lt;b&gt;&quot;, style-&gt;description, &quot;&lt;/b&gt;\n&quot;, items_string, NULL);</a>
<a name="ln1063">      }</a>
<a name="ln1064">      else</a>
<a name="ln1065">      {</a>
<a name="ln1066">        tooltip = g_strdup(items_string);</a>
<a name="ln1067">      }</a>
<a name="ln1068"> </a>
<a name="ln1069">      gchar **split = g_strsplit(style-&gt;name, &quot;|&quot;, 0);</a>
<a name="ln1070"> </a>
<a name="ln1071">      // if sub-menu, do not put leading group in final name</a>
<a name="ln1072"> </a>
<a name="ln1073">      gchar *mi_name = NULL;</a>
<a name="ln1074"> </a>
<a name="ln1075">      if(split[1])</a>
<a name="ln1076">      {</a>
<a name="ln1077">        mi_name = g_strdup(split[1]);</a>
<a name="ln1078">        for(int i=2; split[i]; i++)</a>
<a name="ln1079">          mi_name = g_strconcat(mi_name, &quot; | &quot;, split[i], NULL);</a>
<a name="ln1080">      }</a>
<a name="ln1081">      else</a>
<a name="ln1082">        mi_name = g_strdup(split[0]);</a>
<a name="ln1083"> </a>
<a name="ln1084">      GtkWidget *mi = gtk_menu_item_new_with_label(mi_name);</a>
<a name="ln1085">      gtk_widget_set_tooltip_markup(mi, tooltip);</a>
<a name="ln1086">      g_free(mi_name);</a>
<a name="ln1087"> </a>
<a name="ln1088">      // check if we already have a sub-menu with this name</a>
<a name="ln1089">      GtkMenu *sm = NULL;</a>
<a name="ln1090"> </a>
<a name="ln1091">      GList *childs = gtk_container_get_children(GTK_CONTAINER(menu));</a>
<a name="ln1092">      while(childs)</a>
<a name="ln1093">      {</a>
<a name="ln1094">        GtkMenuItem *smi = (GtkMenuItem *)childs-&gt;data;</a>
<a name="ln1095">        if(!g_strcmp0(split[0],gtk_menu_item_get_label(smi)))</a>
<a name="ln1096">        {</a>
<a name="ln1097">          sm = (GtkMenu *)gtk_menu_item_get_submenu(smi);</a>
<a name="ln1098">          g_list_free(childs);</a>
<a name="ln1099">          break;</a>
<a name="ln1100">        }</a>
<a name="ln1101">        childs = g_list_next(childs);</a>
<a name="ln1102">      }</a>
<a name="ln1103"> </a>
<a name="ln1104">      GtkMenuItem *smi = NULL;</a>
<a name="ln1105"> </a>
<a name="ln1106">      // no sub-menu, but we need one</a>
<a name="ln1107">      if(!sm &amp;&amp; split[1])</a>
<a name="ln1108">      {</a>
<a name="ln1109">        smi = (GtkMenuItem *)gtk_menu_item_new_with_label(split[0]);</a>
<a name="ln1110">        sm = (GtkMenu *)gtk_menu_new();</a>
<a name="ln1111">        gtk_menu_item_set_submenu(smi, GTK_WIDGET(sm));</a>
<a name="ln1112">      }</a>
<a name="ln1113"> </a>
<a name="ln1114">      if(sm)</a>
<a name="ln1115">        gtk_menu_shell_append(GTK_MENU_SHELL(sm), mi);</a>
<a name="ln1116">      else</a>
<a name="ln1117">        gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1118"> </a>
<a name="ln1119">      if(smi)</a>
<a name="ln1120">      {</a>
<a name="ln1121">        gtk_menu_shell_append(GTK_MENU_SHELL(menu), GTK_WIDGET(smi));</a>
<a name="ln1122">        gtk_widget_show(GTK_WIDGET(smi));</a>
<a name="ln1123">      }</a>
<a name="ln1124"> </a>
<a name="ln1125">      g_signal_connect_swapped(G_OBJECT(mi), &quot;activate&quot;,</a>
<a name="ln1126">                               G_CALLBACK(_darkroom_ui_apply_style_activate_callback),</a>
<a name="ln1127">                               (gpointer)g_strdup(style-&gt;name));</a>
<a name="ln1128">      gtk_widget_show(mi);</a>
<a name="ln1129"> </a>
<a name="ln1130">      g_free(items_string);</a>
<a name="ln1131">      g_free(tooltip);</a>
<a name="ln1132">      g_strfreev(split);</a>
<a name="ln1133">    } while((styles = g_list_next(styles)) != NULL);</a>
<a name="ln1134">    g_list_free_full(styles, dt_style_free);</a>
<a name="ln1135">  }</a>
<a name="ln1136"> </a>
<a name="ln1137">  /* if we got any styles, lets popup menu for selection */</a>
<a name="ln1138">  if(menu)</a>
<a name="ln1139">  {</a>
<a name="ln1140">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln1141">    gtk_menu_popup_at_pointer(GTK_MENU(menu), NULL);</a>
<a name="ln1142">#else</a>
<a name="ln1143">    gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, 0, 0);</a>
<a name="ln1144">#endif</a>
<a name="ln1145">  }</a>
<a name="ln1146">  else</a>
<a name="ln1147">    dt_control_log(_(&quot;no styles have been created yet&quot;));</a>
<a name="ln1148">}</a>
<a name="ln1149"> </a>
<a name="ln1150">static void _second_window_quickbutton_clicked(GtkWidget *w, dt_develop_t *dev)</a>
<a name="ln1151">{</a>
<a name="ln1152">  if(dev-&gt;second_window.second_wnd &amp;&amp; !gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w)))</a>
<a name="ln1153">  {</a>
<a name="ln1154">    _darkroom_ui_second_window_write_config(dev-&gt;second_window.second_wnd);</a>
<a name="ln1155"> </a>
<a name="ln1156">    gtk_widget_destroy(dev-&gt;second_window.second_wnd);</a>
<a name="ln1157">    dev-&gt;second_window.second_wnd = NULL;</a>
<a name="ln1158">    dev-&gt;second_window.widget = NULL;</a>
<a name="ln1159">  }</a>
<a name="ln1160">  else if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w)))</a>
<a name="ln1161">    _darkroom_display_second_window(dev);</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164">/** toolbar buttons */</a>
<a name="ln1165"> </a>
<a name="ln1166">static gboolean _toolbar_show_popup(gpointer user_data)</a>
<a name="ln1167">{</a>
<a name="ln1168">  gtk_widget_show_all(GTK_WIDGET(user_data));</a>
<a name="ln1169"> </a>
<a name="ln1170">  // cancel glib timeout if invoked by long button press</a>
<a name="ln1171">  return FALSE;</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174">/* overexposed */</a>
<a name="ln1175">static void _overexposed_quickbutton_clicked(GtkWidget *w, gpointer user_data)</a>
<a name="ln1176">{</a>
<a name="ln1177">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1178">  d-&gt;overexposed.enabled = !d-&gt;overexposed.enabled;</a>
<a name="ln1179">  dt_dev_reprocess_center(d);</a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182">static gboolean _overexposed_quickbutton_pressed(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1183">{</a>
<a name="ln1184">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1185">  const GdkEventButton *e = (GdkEventButton *)event;</a>
<a name="ln1186">  if(e-&gt;button == 3)</a>
<a name="ln1187">  {</a>
<a name="ln1188">    _toolbar_show_popup(d-&gt;overexposed.floating_window);</a>
<a name="ln1189">    return TRUE;</a>
<a name="ln1190">  }</a>
<a name="ln1191">  else</a>
<a name="ln1192">  {</a>
<a name="ln1193">    d-&gt;overexposed.timeout = g_timeout_add_seconds(1, _toolbar_show_popup, d-&gt;overexposed.floating_window);</a>
<a name="ln1194">    return FALSE;</a>
<a name="ln1195">  }</a>
<a name="ln1196">}</a>
<a name="ln1197"> </a>
<a name="ln1198">static gboolean _overexposed_quickbutton_released(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1199">{</a>
<a name="ln1200">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1201">  if(d-&gt;overexposed.timeout &gt; 0) g_source_remove(d-&gt;overexposed.timeout);</a>
<a name="ln1202">  d-&gt;overexposed.timeout = 0;</a>
<a name="ln1203">  return FALSE;</a>
<a name="ln1204">}</a>
<a name="ln1205"> </a>
<a name="ln1206">static void colorscheme_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1207">{</a>
<a name="ln1208">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1209">  d-&gt;overexposed.colorscheme = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1210">  if(d-&gt;overexposed.enabled == FALSE)</a>
<a name="ln1211">    gtk_button_clicked(GTK_BUTTON(d-&gt;overexposed.button));</a>
<a name="ln1212">  else</a>
<a name="ln1213">    dt_dev_reprocess_center(d);</a>
<a name="ln1214">}</a>
<a name="ln1215"> </a>
<a name="ln1216">static void lower_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1217">{</a>
<a name="ln1218">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1219">  d-&gt;overexposed.lower = dt_bauhaus_slider_get(slider);</a>
<a name="ln1220">  if(d-&gt;overexposed.enabled == FALSE)</a>
<a name="ln1221">    gtk_button_clicked(GTK_BUTTON(d-&gt;overexposed.button));</a>
<a name="ln1222">  else</a>
<a name="ln1223">    dt_dev_reprocess_center(d);</a>
<a name="ln1224">}</a>
<a name="ln1225"> </a>
<a name="ln1226">static void upper_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1227">{</a>
<a name="ln1228">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1229">  d-&gt;overexposed.upper = dt_bauhaus_slider_get(slider);</a>
<a name="ln1230">  if(d-&gt;overexposed.enabled == FALSE)</a>
<a name="ln1231">    gtk_button_clicked(GTK_BUTTON(d-&gt;overexposed.button));</a>
<a name="ln1232">  else</a>
<a name="ln1233">    dt_dev_reprocess_center(d);</a>
<a name="ln1234">}</a>
<a name="ln1235"> </a>
<a name="ln1236">/* rawoverexposed */</a>
<a name="ln1237">static void _rawoverexposed_quickbutton_clicked(GtkWidget *w, gpointer user_data)</a>
<a name="ln1238">{</a>
<a name="ln1239">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1240">  d-&gt;rawoverexposed.enabled = !d-&gt;rawoverexposed.enabled;</a>
<a name="ln1241">  dt_dev_reprocess_center(d);</a>
<a name="ln1242">}</a>
<a name="ln1243"> </a>
<a name="ln1244">static gboolean _rawoverexposed_quickbutton_pressed(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1245">{</a>
<a name="ln1246">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1247">  const GdkEventButton *e = (GdkEventButton *)event;</a>
<a name="ln1248">  if(e-&gt;button == 3)</a>
<a name="ln1249">  {</a>
<a name="ln1250">    _toolbar_show_popup(d-&gt;rawoverexposed.floating_window);</a>
<a name="ln1251">    return TRUE;</a>
<a name="ln1252">  }</a>
<a name="ln1253">  else</a>
<a name="ln1254">  {</a>
<a name="ln1255">    d-&gt;rawoverexposed.timeout = g_timeout_add_seconds(1, _toolbar_show_popup, d-&gt;rawoverexposed.floating_window);</a>
<a name="ln1256">    return FALSE;</a>
<a name="ln1257">  }</a>
<a name="ln1258">}</a>
<a name="ln1259"> </a>
<a name="ln1260">static gboolean _rawoverexposed_quickbutton_released(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1261">{</a>
<a name="ln1262">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1263">  if(d-&gt;rawoverexposed.timeout &gt; 0) g_source_remove(d-&gt;rawoverexposed.timeout);</a>
<a name="ln1264">  d-&gt;rawoverexposed.timeout = 0;</a>
<a name="ln1265">  return FALSE;</a>
<a name="ln1266">}</a>
<a name="ln1267"> </a>
<a name="ln1268">static void rawoverexposed_mode_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1269">{</a>
<a name="ln1270">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1271">  d-&gt;rawoverexposed.mode = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1272">  if(d-&gt;rawoverexposed.enabled == FALSE)</a>
<a name="ln1273">    gtk_button_clicked(GTK_BUTTON(d-&gt;rawoverexposed.button));</a>
<a name="ln1274">  else</a>
<a name="ln1275">    dt_dev_reprocess_center(d);</a>
<a name="ln1276">}</a>
<a name="ln1277"> </a>
<a name="ln1278">static void rawoverexposed_colorscheme_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1279">{</a>
<a name="ln1280">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1281">  d-&gt;rawoverexposed.colorscheme = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1282">  if(d-&gt;rawoverexposed.enabled == FALSE)</a>
<a name="ln1283">    gtk_button_clicked(GTK_BUTTON(d-&gt;rawoverexposed.button));</a>
<a name="ln1284">  else</a>
<a name="ln1285">    dt_dev_reprocess_center(d);</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288">static void rawoverexposed_threshold_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1289">{</a>
<a name="ln1290">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1291">  d-&gt;rawoverexposed.threshold = dt_bauhaus_slider_get(slider);</a>
<a name="ln1292">  if(d-&gt;rawoverexposed.enabled == FALSE)</a>
<a name="ln1293">    gtk_button_clicked(GTK_BUTTON(d-&gt;rawoverexposed.button));</a>
<a name="ln1294">  else</a>
<a name="ln1295">    dt_dev_reprocess_center(d);</a>
<a name="ln1296">}</a>
<a name="ln1297"> </a>
<a name="ln1298">static gboolean _toolbox_toggle_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1299">                                             GdkModifierType modifier, gpointer data)</a>
<a name="ln1300">{</a>
<a name="ln1301">  gtk_button_clicked(GTK_BUTTON(data));</a>
<a name="ln1302">  return TRUE;</a>
<a name="ln1303">}</a>
<a name="ln1304"> </a>
<a name="ln1305">/* softproof */</a>
<a name="ln1306">static void _softproof_quickbutton_clicked(GtkWidget *w, gpointer user_data)</a>
<a name="ln1307">{</a>
<a name="ln1308">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1309">  if(darktable.color_profiles-&gt;mode == DT_PROFILE_SOFTPROOF)</a>
<a name="ln1310">    darktable.color_profiles-&gt;mode = DT_PROFILE_NORMAL;</a>
<a name="ln1311">  else</a>
<a name="ln1312">    darktable.color_profiles-&gt;mode = DT_PROFILE_SOFTPROOF;</a>
<a name="ln1313"> </a>
<a name="ln1314">  _update_softproof_gamut_checking(d);</a>
<a name="ln1315"> </a>
<a name="ln1316">  dt_dev_reprocess_center(d);</a>
<a name="ln1317">}</a>
<a name="ln1318"> </a>
<a name="ln1319">static gboolean _softproof_quickbutton_pressed(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1320">{</a>
<a name="ln1321">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1322">  GdkEventButton *e = (GdkEventButton *)event;</a>
<a name="ln1323"> </a>
<a name="ln1324">  gtk_popover_set_relative_to(GTK_POPOVER(d-&gt;profile.floating_window), d-&gt;profile.softproof_button);</a>
<a name="ln1325"> </a>
<a name="ln1326">  if(e-&gt;button == 3)</a>
<a name="ln1327">  {</a>
<a name="ln1328">    _toolbar_show_popup(d-&gt;profile.floating_window);</a>
<a name="ln1329">    return TRUE;</a>
<a name="ln1330">  }</a>
<a name="ln1331">  else</a>
<a name="ln1332">  {</a>
<a name="ln1333">    d-&gt;profile.timeout = g_timeout_add_seconds(1, _toolbar_show_popup, d-&gt;profile.floating_window);</a>
<a name="ln1334">    return FALSE;</a>
<a name="ln1335">  }</a>
<a name="ln1336">}</a>
<a name="ln1337"> </a>
<a name="ln1338">static gboolean _second_window_quickbutton_pressed(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1339">{</a>
<a name="ln1340">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1341">  GdkEventButton *e = (GdkEventButton *)event;</a>
<a name="ln1342"> </a>
<a name="ln1343">  gtk_popover_set_relative_to(GTK_POPOVER(d-&gt;profile.floating_window), d-&gt;second_window.button);</a>
<a name="ln1344"> </a>
<a name="ln1345">  if(e-&gt;button == 3)</a>
<a name="ln1346">  {</a>
<a name="ln1347">    _toolbar_show_popup(d-&gt;profile.floating_window);</a>
<a name="ln1348">    return TRUE;</a>
<a name="ln1349">  }</a>
<a name="ln1350">  else</a>
<a name="ln1351">  {</a>
<a name="ln1352">    d-&gt;profile.timeout = g_timeout_add_seconds(1, _toolbar_show_popup, d-&gt;profile.floating_window);</a>
<a name="ln1353">    return FALSE;</a>
<a name="ln1354">  }</a>
<a name="ln1355">}</a>
<a name="ln1356"> </a>
<a name="ln1357">static gboolean _profile_quickbutton_released(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1358">{</a>
<a name="ln1359">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1360">  if(d-&gt;profile.timeout &gt; 0) g_source_remove(d-&gt;profile.timeout);</a>
<a name="ln1361">  d-&gt;profile.timeout = 0;</a>
<a name="ln1362">  return FALSE;</a>
<a name="ln1363">}</a>
<a name="ln1364"> </a>
<a name="ln1365">/* gamut */</a>
<a name="ln1366">static void _gamut_quickbutton_clicked(GtkWidget *w, gpointer user_data)</a>
<a name="ln1367">{</a>
<a name="ln1368">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1369">  if(darktable.color_profiles-&gt;mode == DT_PROFILE_GAMUTCHECK)</a>
<a name="ln1370">    darktable.color_profiles-&gt;mode = DT_PROFILE_NORMAL;</a>
<a name="ln1371">  else</a>
<a name="ln1372">    darktable.color_profiles-&gt;mode = DT_PROFILE_GAMUTCHECK;</a>
<a name="ln1373"> </a>
<a name="ln1374">  _update_softproof_gamut_checking(d);</a>
<a name="ln1375"> </a>
<a name="ln1376">  dt_dev_reprocess_center(d);</a>
<a name="ln1377">}</a>
<a name="ln1378"> </a>
<a name="ln1379">static gboolean _gamut_quickbutton_pressed(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1380">{</a>
<a name="ln1381">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1382">  GdkEventButton *e = (GdkEventButton *)event;</a>
<a name="ln1383"> </a>
<a name="ln1384">  gtk_popover_set_relative_to(GTK_POPOVER(d-&gt;profile.floating_window), d-&gt;profile.gamut_button);</a>
<a name="ln1385"> </a>
<a name="ln1386">  if(e-&gt;button == 3)</a>
<a name="ln1387">  {</a>
<a name="ln1388">    _toolbar_show_popup(d-&gt;profile.floating_window);</a>
<a name="ln1389">    return TRUE;</a>
<a name="ln1390">  }</a>
<a name="ln1391">  else</a>
<a name="ln1392">  {</a>
<a name="ln1393">    d-&gt;profile.timeout = g_timeout_add_seconds(1, _toolbar_show_popup, d-&gt;profile.floating_window);</a>
<a name="ln1394">    return FALSE;</a>
<a name="ln1395">  }</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398">/* set the gui state for both softproof and gamut checking */</a>
<a name="ln1399">static void _update_softproof_gamut_checking(dt_develop_t *d)</a>
<a name="ln1400">{</a>
<a name="ln1401">  g_signal_handlers_block_by_func(d-&gt;profile.softproof_button, _softproof_quickbutton_clicked, d);</a>
<a name="ln1402">  g_signal_handlers_block_by_func(d-&gt;profile.gamut_button, _gamut_quickbutton_clicked, d);</a>
<a name="ln1403"> </a>
<a name="ln1404">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;profile.softproof_button), darktable.color_profiles-&gt;mode == DT_PROFILE_SOFTPROOF);</a>
<a name="ln1405">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;profile.gamut_button), darktable.color_profiles-&gt;mode == DT_PROFILE_GAMUTCHECK);</a>
<a name="ln1406"> </a>
<a name="ln1407">  g_signal_handlers_unblock_by_func(d-&gt;profile.softproof_button, _softproof_quickbutton_clicked, d);</a>
<a name="ln1408">  g_signal_handlers_unblock_by_func(d-&gt;profile.gamut_button, _gamut_quickbutton_clicked, d);</a>
<a name="ln1409">}</a>
<a name="ln1410"> </a>
<a name="ln1411">static void display_intent_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1412">{</a>
<a name="ln1413">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1414">  const int pos = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1415"> </a>
<a name="ln1416">  dt_iop_color_intent_t new_intent = darktable.color_profiles-&gt;display_intent;</a>
<a name="ln1417"> </a>
<a name="ln1418">  // we are not using the int value directly so it's robust against changes on lcms' side</a>
<a name="ln1419">  switch(pos)</a>
<a name="ln1420">  {</a>
<a name="ln1421">    case 0:</a>
<a name="ln1422">      new_intent = DT_INTENT_PERCEPTUAL;</a>
<a name="ln1423">      break;</a>
<a name="ln1424">    case 1:</a>
<a name="ln1425">      new_intent = DT_INTENT_RELATIVE_COLORIMETRIC;</a>
<a name="ln1426">      break;</a>
<a name="ln1427">    case 2:</a>
<a name="ln1428">      new_intent = DT_INTENT_SATURATION;</a>
<a name="ln1429">      break;</a>
<a name="ln1430">    case 3:</a>
<a name="ln1431">      new_intent = DT_INTENT_ABSOLUTE_COLORIMETRIC;</a>
<a name="ln1432">      break;</a>
<a name="ln1433">  }</a>
<a name="ln1434"> </a>
<a name="ln1435">  if(new_intent != darktable.color_profiles-&gt;display_intent)</a>
<a name="ln1436">  {</a>
<a name="ln1437">    darktable.color_profiles-&gt;display_intent = new_intent;</a>
<a name="ln1438">    dt_dev_reprocess_all(d);</a>
<a name="ln1439">  }</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442">static void display2_intent_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1443">{</a>
<a name="ln1444">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1445">  const int pos = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1446"> </a>
<a name="ln1447">  dt_iop_color_intent_t new_intent = darktable.color_profiles-&gt;display2_intent;</a>
<a name="ln1448"> </a>
<a name="ln1449">  // we are not using the int value directly so it's robust against changes on lcms' side</a>
<a name="ln1450">  switch(pos)</a>
<a name="ln1451">  {</a>
<a name="ln1452">    case 0:</a>
<a name="ln1453">      new_intent = DT_INTENT_PERCEPTUAL;</a>
<a name="ln1454">      break;</a>
<a name="ln1455">    case 1:</a>
<a name="ln1456">      new_intent = DT_INTENT_RELATIVE_COLORIMETRIC;</a>
<a name="ln1457">      break;</a>
<a name="ln1458">    case 2:</a>
<a name="ln1459">      new_intent = DT_INTENT_SATURATION;</a>
<a name="ln1460">      break;</a>
<a name="ln1461">    case 3:</a>
<a name="ln1462">      new_intent = DT_INTENT_ABSOLUTE_COLORIMETRIC;</a>
<a name="ln1463">      break;</a>
<a name="ln1464">  }</a>
<a name="ln1465"> </a>
<a name="ln1466">  if(new_intent != darktable.color_profiles-&gt;display2_intent)</a>
<a name="ln1467">  {</a>
<a name="ln1468">    darktable.color_profiles-&gt;display2_intent = new_intent;</a>
<a name="ln1469">    dt_dev_reprocess_all(d);</a>
<a name="ln1470">  }</a>
<a name="ln1471">}</a>
<a name="ln1472"> </a>
<a name="ln1473">static void softproof_profile_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1474">{</a>
<a name="ln1475">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1476">  gboolean profile_changed = FALSE;</a>
<a name="ln1477">  const int pos = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1478">  for(GList *profiles = darktable.color_profiles-&gt;profiles; profiles; profiles = g_list_next(profiles))</a>
<a name="ln1479">  {</a>
<a name="ln1480">    dt_colorspaces_color_profile_t *pp = (dt_colorspaces_color_profile_t *)profiles-&gt;data;</a>
<a name="ln1481">    if(pp-&gt;out_pos == pos)</a>
<a name="ln1482">    {</a>
<a name="ln1483">      if(darktable.color_profiles-&gt;softproof_type != pp-&gt;type</a>
<a name="ln1484">        || (darktable.color_profiles-&gt;softproof_type == DT_COLORSPACE_FILE</a>
<a name="ln1485">            &amp;&amp; strcmp(darktable.color_profiles-&gt;softproof_filename, pp-&gt;filename)))</a>
<a name="ln1486"> </a>
<a name="ln1487">      {</a>
<a name="ln1488">        darktable.color_profiles-&gt;softproof_type = pp-&gt;type;</a>
<a name="ln1489">        g_strlcpy(darktable.color_profiles-&gt;softproof_filename, pp-&gt;filename,</a>
<a name="ln1490">                  sizeof(darktable.color_profiles-&gt;softproof_filename));</a>
<a name="ln1491">        profile_changed = TRUE;</a>
<a name="ln1492">      }</a>
<a name="ln1493">      goto end;</a>
<a name="ln1494">    }</a>
<a name="ln1495">  }</a>
<a name="ln1496"> </a>
<a name="ln1497">  // profile not found, fall back to sRGB. shouldn't happen</a>
<a name="ln1498">  fprintf(stderr, &quot;can't find softproof profile `%s', using sRGB instead\n&quot;, dt_bauhaus_combobox_get_text(combo));</a>
<a name="ln1499">  profile_changed = darktable.color_profiles-&gt;softproof_type != DT_COLORSPACE_SRGB;</a>
<a name="ln1500">  darktable.color_profiles-&gt;softproof_type = DT_COLORSPACE_SRGB;</a>
<a name="ln1501">  darktable.color_profiles-&gt;softproof_filename[0] = '\0';</a>
<a name="ln1502"> </a>
<a name="ln1503">end:</a>
<a name="ln1504">  if(profile_changed)</a>
<a name="ln1505">  {</a>
<a name="ln1506">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_CONTROL_PROFILE_USER_CHANGED, DT_COLORSPACES_PROFILE_TYPE_SOFTPROOF);</a>
<a name="ln1507">    dt_dev_reprocess_all(d);</a>
<a name="ln1508">  }</a>
<a name="ln1509">}</a>
<a name="ln1510"> </a>
<a name="ln1511">static void display_profile_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1512">{</a>
<a name="ln1513">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1514">  gboolean profile_changed = FALSE;</a>
<a name="ln1515">  const int pos = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1516">  for(GList *profiles = darktable.color_profiles-&gt;profiles; profiles; profiles = g_list_next(profiles))</a>
<a name="ln1517">  {</a>
<a name="ln1518">    dt_colorspaces_color_profile_t *pp = (dt_colorspaces_color_profile_t *)profiles-&gt;data;</a>
<a name="ln1519">    if(pp-&gt;display_pos == pos)</a>
<a name="ln1520">    {</a>
<a name="ln1521">      if(darktable.color_profiles-&gt;display_type != pp-&gt;type</a>
<a name="ln1522">        || (darktable.color_profiles-&gt;display_type == DT_COLORSPACE_FILE</a>
<a name="ln1523">            &amp;&amp; strcmp(darktable.color_profiles-&gt;display_filename, pp-&gt;filename)))</a>
<a name="ln1524">      {</a>
<a name="ln1525">        darktable.color_profiles-&gt;display_type = pp-&gt;type;</a>
<a name="ln1526">        g_strlcpy(darktable.color_profiles-&gt;display_filename, pp-&gt;filename,</a>
<a name="ln1527">                  sizeof(darktable.color_profiles-&gt;display_filename));</a>
<a name="ln1528">        profile_changed = TRUE;</a>
<a name="ln1529">      }</a>
<a name="ln1530">      goto end;</a>
<a name="ln1531">    }</a>
<a name="ln1532">  }</a>
<a name="ln1533"> </a>
<a name="ln1534">  // profile not found, fall back to system display profile. shouldn't happen</a>
<a name="ln1535">  fprintf(stderr, &quot;can't find display profile `%s', using system display profile instead\n&quot;, dt_bauhaus_combobox_get_text(combo));</a>
<a name="ln1536">  profile_changed = darktable.color_profiles-&gt;display_type != DT_COLORSPACE_DISPLAY;</a>
<a name="ln1537">  darktable.color_profiles-&gt;display_type = DT_COLORSPACE_DISPLAY;</a>
<a name="ln1538">  darktable.color_profiles-&gt;display_filename[0] = '\0';</a>
<a name="ln1539"> </a>
<a name="ln1540">end:</a>
<a name="ln1541">  if(profile_changed)</a>
<a name="ln1542">  {</a>
<a name="ln1543">    pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1544">    dt_colorspaces_update_display_transforms();</a>
<a name="ln1545">    pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1546">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_CONTROL_PROFILE_USER_CHANGED, DT_COLORSPACES_PROFILE_TYPE_DISPLAY);</a>
<a name="ln1547">    dt_dev_reprocess_all(d);</a>
<a name="ln1548">  }</a>
<a name="ln1549">}</a>
<a name="ln1550"> </a>
<a name="ln1551">static void display2_profile_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1552">{</a>
<a name="ln1553">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1554">  gboolean profile_changed = FALSE;</a>
<a name="ln1555">  const int pos = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1556">  for(GList *profiles = darktable.color_profiles-&gt;profiles; profiles; profiles = g_list_next(profiles))</a>
<a name="ln1557">  {</a>
<a name="ln1558">    dt_colorspaces_color_profile_t *pp = (dt_colorspaces_color_profile_t *)profiles-&gt;data;</a>
<a name="ln1559">    if(pp-&gt;display2_pos == pos)</a>
<a name="ln1560">    {</a>
<a name="ln1561">      if(darktable.color_profiles-&gt;display2_type != pp-&gt;type</a>
<a name="ln1562">         || (darktable.color_profiles-&gt;display2_type == DT_COLORSPACE_FILE</a>
<a name="ln1563">             &amp;&amp; strcmp(darktable.color_profiles-&gt;display2_filename, pp-&gt;filename)))</a>
<a name="ln1564">      {</a>
<a name="ln1565">        darktable.color_profiles-&gt;display2_type = pp-&gt;type;</a>
<a name="ln1566">        g_strlcpy(darktable.color_profiles-&gt;display2_filename, pp-&gt;filename,</a>
<a name="ln1567">                  sizeof(darktable.color_profiles-&gt;display2_filename));</a>
<a name="ln1568">        profile_changed = TRUE;</a>
<a name="ln1569">      }</a>
<a name="ln1570">      goto end;</a>
<a name="ln1571">    }</a>
<a name="ln1572">  }</a>
<a name="ln1573"> </a>
<a name="ln1574">  // profile not found, fall back to system display2 profile. shouldn't happen</a>
<a name="ln1575">  fprintf(stderr, &quot;can't find preview display profile `%s', using system display profile instead\n&quot;,</a>
<a name="ln1576">          dt_bauhaus_combobox_get_text(combo));</a>
<a name="ln1577">  profile_changed = darktable.color_profiles-&gt;display2_type != DT_COLORSPACE_DISPLAY2;</a>
<a name="ln1578">  darktable.color_profiles-&gt;display2_type = DT_COLORSPACE_DISPLAY2;</a>
<a name="ln1579">  darktable.color_profiles-&gt;display2_filename[0] = '\0';</a>
<a name="ln1580"> </a>
<a name="ln1581">end:</a>
<a name="ln1582">  if(profile_changed)</a>
<a name="ln1583">  {</a>
<a name="ln1584">    pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1585">    dt_colorspaces_update_display2_transforms();</a>
<a name="ln1586">    pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1587">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_CONTROL_PROFILE_USER_CHANGED,</a>
<a name="ln1588">                            DT_COLORSPACES_PROFILE_TYPE_DISPLAY2);</a>
<a name="ln1589">    dt_dev_reprocess_all(d);</a>
<a name="ln1590">  }</a>
<a name="ln1591">}</a>
<a name="ln1592"> </a>
<a name="ln1593">static void histogram_profile_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1594">{</a>
<a name="ln1595">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1596">  gboolean profile_changed = FALSE;</a>
<a name="ln1597">  const int pos = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1598">  for(GList *profiles = darktable.color_profiles-&gt;profiles; profiles; profiles = g_list_next(profiles))</a>
<a name="ln1599">  {</a>
<a name="ln1600">    dt_colorspaces_color_profile_t *pp = (dt_colorspaces_color_profile_t *)profiles-&gt;data;</a>
<a name="ln1601">    if(pp-&gt;category_pos == pos)</a>
<a name="ln1602">    {</a>
<a name="ln1603">      if(darktable.color_profiles-&gt;histogram_type != pp-&gt;type</a>
<a name="ln1604">        || (darktable.color_profiles-&gt;histogram_type == DT_COLORSPACE_FILE</a>
<a name="ln1605">            &amp;&amp; strcmp(darktable.color_profiles-&gt;histogram_filename, pp-&gt;filename)))</a>
<a name="ln1606">      {</a>
<a name="ln1607">        darktable.color_profiles-&gt;histogram_type = pp-&gt;type;</a>
<a name="ln1608">        g_strlcpy(darktable.color_profiles-&gt;histogram_filename, pp-&gt;filename,</a>
<a name="ln1609">                  sizeof(darktable.color_profiles-&gt;histogram_filename));</a>
<a name="ln1610">        profile_changed = TRUE;</a>
<a name="ln1611">      }</a>
<a name="ln1612">      goto end;</a>
<a name="ln1613">    }</a>
<a name="ln1614">  }</a>
<a name="ln1615"> </a>
<a name="ln1616">  // profile not found, fall back to export profile. shouldn't happen</a>
<a name="ln1617">  fprintf(stderr, &quot;can't find histogram profile `%s', using export profile instead\n&quot;, dt_bauhaus_combobox_get_text(combo));</a>
<a name="ln1618">  profile_changed = darktable.color_profiles-&gt;histogram_type != DT_COLORSPACE_WORK;</a>
<a name="ln1619">  darktable.color_profiles-&gt;histogram_type = DT_COLORSPACE_WORK;</a>
<a name="ln1620">  darktable.color_profiles-&gt;histogram_filename[0] = '\0';</a>
<a name="ln1621"> </a>
<a name="ln1622">end:</a>
<a name="ln1623">  if(profile_changed)</a>
<a name="ln1624">  {</a>
<a name="ln1625">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_CONTROL_PROFILE_USER_CHANGED, DT_COLORSPACES_PROFILE_TYPE_HISTOGRAM);</a>
<a name="ln1626">    dt_dev_reprocess_all(d);</a>
<a name="ln1627">  }</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">// FIXME: turning off lcms2 in prefs hides the widget but leaves the window sized like before -&gt; ugly-ish</a>
<a name="ln1631">static void _preference_changed(gpointer instance, gpointer user_data)</a>
<a name="ln1632">{</a>
<a name="ln1633">  GtkWidget *display_intent = GTK_WIDGET(user_data);</a>
<a name="ln1634"> </a>
<a name="ln1635">  const int force_lcms2 = dt_conf_get_bool(&quot;plugins/lighttable/export/force_lcms2&quot;);</a>
<a name="ln1636">  if(force_lcms2)</a>
<a name="ln1637">  {</a>
<a name="ln1638">    gtk_widget_set_no_show_all(display_intent, FALSE);</a>
<a name="ln1639">    gtk_widget_set_visible(display_intent, TRUE);</a>
<a name="ln1640">  }</a>
<a name="ln1641">  else</a>
<a name="ln1642">  {</a>
<a name="ln1643">    gtk_widget_set_no_show_all(display_intent, TRUE);</a>
<a name="ln1644">    gtk_widget_set_visible(display_intent, FALSE);</a>
<a name="ln1645">  }</a>
<a name="ln1646"> </a>
<a name="ln1647">  // reconstruct dynamic accels list</a>
<a name="ln1648">  dt_dynamic_accel_get_valid_list();</a>
<a name="ln1649">}</a>
<a name="ln1650"> </a>
<a name="ln1651">static void _update_display_profile_cmb(GtkWidget *cmb_display_profile)</a>
<a name="ln1652">{</a>
<a name="ln1653">  GList *l = darktable.color_profiles-&gt;profiles;</a>
<a name="ln1654">  while(l)</a>
<a name="ln1655">  {</a>
<a name="ln1656">    dt_colorspaces_color_profile_t *prof = (dt_colorspaces_color_profile_t *)l-&gt;data;</a>
<a name="ln1657">    if(prof-&gt;display_pos &gt; -1)</a>
<a name="ln1658">    {</a>
<a name="ln1659">      if(prof-&gt;type == darktable.color_profiles-&gt;display_type</a>
<a name="ln1660">         &amp;&amp; (prof-&gt;type != DT_COLORSPACE_FILE</a>
<a name="ln1661">             || !strcmp(prof-&gt;filename, darktable.color_profiles-&gt;display_filename)))</a>
<a name="ln1662">      {</a>
<a name="ln1663">        if(dt_bauhaus_combobox_get(cmb_display_profile) != prof-&gt;display_pos)</a>
<a name="ln1664">        {</a>
<a name="ln1665">          dt_bauhaus_combobox_set(cmb_display_profile, prof-&gt;display_pos);</a>
<a name="ln1666">          break;</a>
<a name="ln1667">        }</a>
<a name="ln1668">      }</a>
<a name="ln1669">    }</a>
<a name="ln1670">    l = g_list_next(l);</a>
<a name="ln1671">  }</a>
<a name="ln1672">}</a>
<a name="ln1673"> </a>
<a name="ln1674">static void _update_display2_profile_cmb(GtkWidget *cmb_display_profile)</a>
<a name="ln1675">{</a>
<a name="ln1676">  GList *l = darktable.color_profiles-&gt;profiles;</a>
<a name="ln1677">  while(l)</a>
<a name="ln1678">  {</a>
<a name="ln1679">    dt_colorspaces_color_profile_t *prof = (dt_colorspaces_color_profile_t *)l-&gt;data;</a>
<a name="ln1680">    if(prof-&gt;display2_pos &gt; -1)</a>
<a name="ln1681">    {</a>
<a name="ln1682">      if(prof-&gt;type == darktable.color_profiles-&gt;display2_type</a>
<a name="ln1683">         &amp;&amp; (prof-&gt;type != DT_COLORSPACE_FILE</a>
<a name="ln1684">             || !strcmp(prof-&gt;filename, darktable.color_profiles-&gt;display2_filename)))</a>
<a name="ln1685">      {</a>
<a name="ln1686">        if(dt_bauhaus_combobox_get(cmb_display_profile) != prof-&gt;display2_pos)</a>
<a name="ln1687">        {</a>
<a name="ln1688">          dt_bauhaus_combobox_set(cmb_display_profile, prof-&gt;display2_pos);</a>
<a name="ln1689">          break;</a>
<a name="ln1690">        }</a>
<a name="ln1691">      }</a>
<a name="ln1692">    }</a>
<a name="ln1693">    l = g_list_next(l);</a>
<a name="ln1694">  }</a>
<a name="ln1695">}</a>
<a name="ln1696"> </a>
<a name="ln1697">static void _display_profile_changed(gpointer instance, uint8_t profile_type, gpointer user_data)</a>
<a name="ln1698">{</a>
<a name="ln1699">  GtkWidget *cmb_display_profile = GTK_WIDGET(user_data);</a>
<a name="ln1700"> </a>
<a name="ln1701">  _update_display_profile_cmb(cmb_display_profile);</a>
<a name="ln1702">}</a>
<a name="ln1703"> </a>
<a name="ln1704">static void _display2_profile_changed(gpointer instance, uint8_t profile_type, gpointer user_data)</a>
<a name="ln1705">{</a>
<a name="ln1706">  GtkWidget *cmb_display_profile = GTK_WIDGET(user_data);</a>
<a name="ln1707"> </a>
<a name="ln1708">  _update_display2_profile_cmb(cmb_display_profile);</a>
<a name="ln1709">}</a>
<a name="ln1710"> </a>
<a name="ln1711">/** end of toolbox */</a>
<a name="ln1712"> </a>
<a name="ln1713">static gboolean _brush_size_up_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1714">                                        GdkModifierType modifier, gpointer data)</a>
<a name="ln1715">{</a>
<a name="ln1716">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln1717"> </a>
<a name="ln1718">  if(dev-&gt;form_visible) dt_masks_events_mouse_scrolled(dev-&gt;gui_module, 0, 0, 0, 0);</a>
<a name="ln1719">  return TRUE;</a>
<a name="ln1720">}</a>
<a name="ln1721">static gboolean _brush_size_down_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1722">                                          GdkModifierType modifier, gpointer data)</a>
<a name="ln1723">{</a>
<a name="ln1724">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln1725"> </a>
<a name="ln1726">  if(dev-&gt;form_visible) dt_masks_events_mouse_scrolled(dev-&gt;gui_module, 0, 0, 1, 0);</a>
<a name="ln1727">  return TRUE;</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730">static gboolean _brush_hardness_up_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1731">                                            GdkModifierType modifier, gpointer data)</a>
<a name="ln1732">{</a>
<a name="ln1733">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln1734"> </a>
<a name="ln1735">  if(dev-&gt;form_visible) dt_masks_events_mouse_scrolled(dev-&gt;gui_module, 0, 0, 0, GDK_SHIFT_MASK);</a>
<a name="ln1736">  return TRUE;</a>
<a name="ln1737">}</a>
<a name="ln1738">static gboolean _brush_hardness_down_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1739">                                              GdkModifierType modifier, gpointer data)</a>
<a name="ln1740">{</a>
<a name="ln1741">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln1742"> </a>
<a name="ln1743">  if(dev-&gt;form_visible) dt_masks_events_mouse_scrolled(dev-&gt;gui_module, 0, 0, 1, GDK_SHIFT_MASK);</a>
<a name="ln1744">  return TRUE;</a>
<a name="ln1745">}</a>
<a name="ln1746"> </a>
<a name="ln1747">static gboolean _brush_opacity_up_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1748">                                           GdkModifierType modifier, gpointer data)</a>
<a name="ln1749">{</a>
<a name="ln1750">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln1751"> </a>
<a name="ln1752">  if(dev-&gt;form_visible) dt_masks_events_mouse_scrolled(dev-&gt;gui_module, 0, 0, 0, GDK_CONTROL_MASK);</a>
<a name="ln1753">  return TRUE;</a>
<a name="ln1754">}</a>
<a name="ln1755">static gboolean _brush_opacity_down_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1756">                                             GdkModifierType modifier, gpointer data)</a>
<a name="ln1757">{</a>
<a name="ln1758">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln1759"> </a>
<a name="ln1760">  if(dev-&gt;form_visible) dt_masks_events_mouse_scrolled(dev-&gt;gui_module, 0, 0, 1, GDK_CONTROL_MASK);</a>
<a name="ln1761">  return TRUE;</a>
<a name="ln1762">}</a>
<a name="ln1763"> </a>
<a name="ln1764">void gui_init(dt_view_t *self)</a>
<a name="ln1765">{</a>
<a name="ln1766">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln1767">  /*</a>
<a name="ln1768">   * Add view specific tool buttons</a>
<a name="ln1769">   */</a>
<a name="ln1770"> </a>
<a name="ln1771">  /* create favorite plugin preset popup tool */</a>
<a name="ln1772">  GtkWidget *favorite_presets</a>
<a name="ln1773">      = dtgtk_button_new(dtgtk_cairo_paint_presets, CPF_STYLE_FLAT, NULL);</a>
<a name="ln1774">  gtk_widget_set_tooltip_text(favorite_presets, _(&quot;quick access to presets of your favorites&quot;));</a>
<a name="ln1775">  g_signal_connect(G_OBJECT(favorite_presets), &quot;clicked&quot;, G_CALLBACK(_darkroom_ui_favorite_presets_popupmenu),</a>
<a name="ln1776">                   NULL);</a>
<a name="ln1777">  dt_gui_add_help_link(favorite_presets, dt_get_help_url(&quot;favorite_presets&quot;));</a>
<a name="ln1778">  dt_view_manager_view_toolbox_add(darktable.view_manager, favorite_presets, DT_VIEW_DARKROOM);</a>
<a name="ln1779"> </a>
<a name="ln1780">  /* create quick styles popup menu tool */</a>
<a name="ln1781">  GtkWidget *styles = dtgtk_button_new(dtgtk_cairo_paint_styles, CPF_STYLE_FLAT, NULL);</a>
<a name="ln1782">  g_signal_connect(G_OBJECT(styles), &quot;clicked&quot;, G_CALLBACK(_darkroom_ui_apply_style_popupmenu), NULL);</a>
<a name="ln1783">  gtk_widget_set_tooltip_text(styles, _(&quot;quick access for applying any of your styles&quot;));</a>
<a name="ln1784">  dt_gui_add_help_link(styles, dt_get_help_url(&quot;bottom_panel_styles&quot;));</a>
<a name="ln1785">  dt_view_manager_view_toolbox_add(darktable.view_manager, styles, DT_VIEW_DARKROOM);</a>
<a name="ln1786"> </a>
<a name="ln1787">  /* create second window display button */</a>
<a name="ln1788">  dev-&gt;second_window.button</a>
<a name="ln1789">      = dtgtk_togglebutton_new(dtgtk_cairo_paint_display2, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1790">  g_signal_connect(G_OBJECT(dev-&gt;second_window.button), &quot;clicked&quot;, G_CALLBACK(_second_window_quickbutton_clicked),</a>
<a name="ln1791">                   dev);</a>
<a name="ln1792">  g_signal_connect(G_OBJECT(dev-&gt;second_window.button), &quot;button-press-event&quot;,</a>
<a name="ln1793">                   G_CALLBACK(_second_window_quickbutton_pressed), dev);</a>
<a name="ln1794">  g_signal_connect(G_OBJECT(dev-&gt;second_window.button), &quot;button-release-event&quot;,</a>
<a name="ln1795">                   G_CALLBACK(_profile_quickbutton_released), dev);</a>
<a name="ln1796">  gtk_widget_set_tooltip_text(dev-&gt;second_window.button, _(&quot;display a second darkroom image window&quot;));</a>
<a name="ln1797">  dt_view_manager_view_toolbox_add(darktable.view_manager, dev-&gt;second_window.button, DT_VIEW_DARKROOM);</a>
<a name="ln1798"> </a>
<a name="ln1799">  const int panel_width = dt_conf_get_int(&quot;panel_width&quot;);</a>
<a name="ln1800"> </a>
<a name="ln1801">  /* create rawoverexposed popup tool */</a>
<a name="ln1802">  {</a>
<a name="ln1803">    // the button</a>
<a name="ln1804">    dev-&gt;rawoverexposed.button</a>
<a name="ln1805">        = dtgtk_togglebutton_new(dtgtk_cairo_paint_rawoverexposed, CPF_STYLE_FLAT, NULL);</a>
<a name="ln1806">    gtk_widget_set_tooltip_text(dev-&gt;rawoverexposed.button,</a>
<a name="ln1807">                                _(&quot;toggle raw over exposed indication\nright click for options&quot;));</a>
<a name="ln1808">    g_signal_connect(G_OBJECT(dev-&gt;rawoverexposed.button), &quot;clicked&quot;,</a>
<a name="ln1809">                     G_CALLBACK(_rawoverexposed_quickbutton_clicked), dev);</a>
<a name="ln1810">    g_signal_connect(G_OBJECT(dev-&gt;rawoverexposed.button), &quot;button-press-event&quot;,</a>
<a name="ln1811">                     G_CALLBACK(_rawoverexposed_quickbutton_pressed), dev);</a>
<a name="ln1812">    g_signal_connect(G_OBJECT(dev-&gt;rawoverexposed.button), &quot;button-release-event&quot;,</a>
<a name="ln1813">                     G_CALLBACK(_rawoverexposed_quickbutton_released), dev);</a>
<a name="ln1814">    dt_view_manager_module_toolbox_add(darktable.view_manager, dev-&gt;rawoverexposed.button, DT_VIEW_DARKROOM);</a>
<a name="ln1815">    dt_gui_add_help_link(dev-&gt;rawoverexposed.button, dt_get_help_url(&quot;rawoverexposed&quot;));</a>
<a name="ln1816"> </a>
<a name="ln1817">    // and the popup window</a>
<a name="ln1818">    dev-&gt;rawoverexposed.floating_window = gtk_popover_new(dev-&gt;rawoverexposed.button);</a>
<a name="ln1819">    gtk_widget_set_size_request(GTK_WIDGET(dev-&gt;rawoverexposed.floating_window), panel_width, -1);</a>
<a name="ln1820">#if GTK_CHECK_VERSION(3, 16, 0)</a>
<a name="ln1821">    g_object_set(G_OBJECT(dev-&gt;rawoverexposed.floating_window), &quot;transitions-enabled&quot;, FALSE, NULL);</a>
<a name="ln1822">#endif</a>
<a name="ln1823"> </a>
<a name="ln1824">    GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln1825">    gtk_container_add(GTK_CONTAINER(dev-&gt;rawoverexposed.floating_window), vbox);</a>
<a name="ln1826"> </a>
<a name="ln1827">    /** let's fill the encapsulating widgets */</a>
<a name="ln1828">    /* mode of operation */</a>
<a name="ln1829">    GtkWidget *mode = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1830">    dt_bauhaus_widget_set_label(mode, NULL, _(&quot;mode&quot;));</a>
<a name="ln1831">    dt_bauhaus_combobox_add(mode, _(&quot;mark with CFA color&quot;));</a>
<a name="ln1832">    dt_bauhaus_combobox_add(mode, _(&quot;mark with solid color&quot;));</a>
<a name="ln1833">    dt_bauhaus_combobox_add(mode, _(&quot;false color&quot;));</a>
<a name="ln1834">    dt_bauhaus_combobox_set(mode, dev-&gt;rawoverexposed.mode);</a>
<a name="ln1835">    gtk_widget_set_tooltip_text(mode, _(&quot;select how to mark the clipped pixels&quot;));</a>
<a name="ln1836">    g_signal_connect(G_OBJECT(mode), &quot;value-changed&quot;, G_CALLBACK(rawoverexposed_mode_callback), dev);</a>
<a name="ln1837">    gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(mode), TRUE, TRUE, 0);</a>
<a name="ln1838">    gtk_widget_set_state_flags(mode, GTK_STATE_FLAG_SELECTED, TRUE);</a>
<a name="ln1839"> </a>
<a name="ln1840">    /* color scheme */</a>
<a name="ln1841">    GtkWidget *colorscheme = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1842">    dt_bauhaus_widget_set_label(colorscheme, NULL, _(&quot;color scheme&quot;));</a>
<a name="ln1843">    dt_bauhaus_combobox_add(colorscheme, C_(&quot;solidcolor&quot;, &quot;red&quot;));</a>
<a name="ln1844">    dt_bauhaus_combobox_add(colorscheme, C_(&quot;solidcolor&quot;, &quot;green&quot;));</a>
<a name="ln1845">    dt_bauhaus_combobox_add(colorscheme, C_(&quot;solidcolor&quot;, &quot;blue&quot;));</a>
<a name="ln1846">    dt_bauhaus_combobox_add(colorscheme, C_(&quot;solidcolor&quot;, &quot;black&quot;));</a>
<a name="ln1847">    dt_bauhaus_combobox_set(colorscheme, dev-&gt;rawoverexposed.colorscheme);</a>
<a name="ln1848">    gtk_widget_set_tooltip_text(</a>
<a name="ln1849">        colorscheme,</a>
<a name="ln1850">        _(&quot;select the solid color to indicate over exposure.\nwill only be used if mode = mark with solid color&quot;));</a>
<a name="ln1851">    g_signal_connect(G_OBJECT(colorscheme), &quot;value-changed&quot;, G_CALLBACK(rawoverexposed_colorscheme_callback), dev);</a>
<a name="ln1852">    gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(colorscheme), TRUE, TRUE, 0);</a>
<a name="ln1853">    gtk_widget_set_state_flags(colorscheme, GTK_STATE_FLAG_SELECTED, TRUE);</a>
<a name="ln1854"> </a>
<a name="ln1855">    /* threshold */</a>
<a name="ln1856">    GtkWidget *threshold = dt_bauhaus_slider_new_with_range(NULL, 0.0, 2.0, 0.01, 1.0, 3);</a>
<a name="ln1857">    dt_bauhaus_slider_set(threshold, dev-&gt;rawoverexposed.threshold);</a>
<a name="ln1858">    dt_bauhaus_widget_set_label(threshold, NULL, _(&quot;clipping threshold&quot;));</a>
<a name="ln1859">    gtk_widget_set_tooltip_text(</a>
<a name="ln1860">        threshold, _(&quot;threshold of what shall be considered overexposed\n1.0 - white level\n0.0 - black level&quot;));</a>
<a name="ln1861">    g_signal_connect(G_OBJECT(threshold), &quot;value-changed&quot;, G_CALLBACK(rawoverexposed_threshold_callback), dev);</a>
<a name="ln1862">    gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(threshold), TRUE, TRUE, 0);</a>
<a name="ln1863">  }</a>
<a name="ln1864"> </a>
<a name="ln1865">  /* create overexposed popup tool */</a>
<a name="ln1866">  {</a>
<a name="ln1867">    // the button</a>
<a name="ln1868">    dev-&gt;overexposed.button</a>
<a name="ln1869">        = dtgtk_togglebutton_new(dtgtk_cairo_paint_overexposed, CPF_STYLE_FLAT, NULL);</a>
<a name="ln1870">    gtk_widget_set_tooltip_text(dev-&gt;overexposed.button,</a>
<a name="ln1871">                                _(&quot;toggle over/under exposed indication\nright click for options&quot;));</a>
<a name="ln1872">    g_signal_connect(G_OBJECT(dev-&gt;overexposed.button), &quot;clicked&quot;,</a>
<a name="ln1873">                     G_CALLBACK(_overexposed_quickbutton_clicked), dev);</a>
<a name="ln1874">    g_signal_connect(G_OBJECT(dev-&gt;overexposed.button), &quot;button-press-event&quot;,</a>
<a name="ln1875">                     G_CALLBACK(_overexposed_quickbutton_pressed), dev);</a>
<a name="ln1876">    g_signal_connect(G_OBJECT(dev-&gt;overexposed.button), &quot;button-release-event&quot;,</a>
<a name="ln1877">                     G_CALLBACK(_overexposed_quickbutton_released), dev);</a>
<a name="ln1878">    dt_view_manager_module_toolbox_add(darktable.view_manager, dev-&gt;overexposed.button, DT_VIEW_DARKROOM);</a>
<a name="ln1879">    dt_gui_add_help_link(dev-&gt;overexposed.button, dt_get_help_url(&quot;overexposed&quot;));</a>
<a name="ln1880"> </a>
<a name="ln1881">    // and the popup window</a>
<a name="ln1882">    dev-&gt;overexposed.floating_window = gtk_popover_new(dev-&gt;overexposed.button);</a>
<a name="ln1883">    gtk_widget_set_size_request(GTK_WIDGET(dev-&gt;overexposed.floating_window), panel_width, -1);</a>
<a name="ln1884">#if GTK_CHECK_VERSION(3, 16, 0)</a>
<a name="ln1885">    g_object_set(G_OBJECT(dev-&gt;overexposed.floating_window), &quot;transitions-enabled&quot;, FALSE, NULL);</a>
<a name="ln1886">#endif</a>
<a name="ln1887"> </a>
<a name="ln1888">    GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1889">    gtk_container_add(GTK_CONTAINER(dev-&gt;overexposed.floating_window), vbox);</a>
<a name="ln1890"> </a>
<a name="ln1891">    /** let's fill the encapsulating widgets */</a>
<a name="ln1892">    /* color scheme */</a>
<a name="ln1893">    GtkWidget *colorscheme = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1894">    dt_bauhaus_widget_set_label(colorscheme, NULL, _(&quot;color scheme&quot;));</a>
<a name="ln1895">    dt_bauhaus_combobox_add(colorscheme, _(&quot;black &amp; white&quot;));</a>
<a name="ln1896">    dt_bauhaus_combobox_add(colorscheme, _(&quot;red &amp; blue&quot;));</a>
<a name="ln1897">    dt_bauhaus_combobox_add(colorscheme, _(&quot;purple &amp; green&quot;));</a>
<a name="ln1898">    dt_bauhaus_combobox_set(colorscheme, dev-&gt;overexposed.colorscheme);</a>
<a name="ln1899">    gtk_widget_set_tooltip_text(colorscheme, _(&quot;select colors to indicate over/under exposure&quot;));</a>
<a name="ln1900">    g_signal_connect(G_OBJECT(colorscheme), &quot;value-changed&quot;, G_CALLBACK(colorscheme_callback), dev);</a>
<a name="ln1901">    gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(colorscheme), TRUE, TRUE, 0);</a>
<a name="ln1902">    gtk_widget_set_state_flags(colorscheme, GTK_STATE_FLAG_SELECTED, TRUE);</a>
<a name="ln1903"> </a>
<a name="ln1904">    /* lower */</a>
<a name="ln1905">    GtkWidget *lower = dt_bauhaus_slider_new_with_range(NULL, 0.0, 100.0, 0.1, 2.0, 2);</a>
<a name="ln1906">    dt_bauhaus_slider_set(lower, dev-&gt;overexposed.lower);</a>
<a name="ln1907">    dt_bauhaus_slider_set_format(lower, &quot;%.0f%%&quot;);</a>
<a name="ln1908">    dt_bauhaus_widget_set_label(lower, NULL, _(&quot;lower threshold&quot;));</a>
<a name="ln1909">    gtk_widget_set_tooltip_text(lower, _(&quot;threshold of what shall be considered underexposed&quot;));</a>
<a name="ln1910">    g_signal_connect(G_OBJECT(lower), &quot;value-changed&quot;, G_CALLBACK(lower_callback), dev);</a>
<a name="ln1911">    gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(lower), TRUE, TRUE, 0);</a>
<a name="ln1912"> </a>
<a name="ln1913">    /* upper */</a>
<a name="ln1914">    GtkWidget *upper = dt_bauhaus_slider_new_with_range(NULL, 0.0, 100.0, 0.1, 98.0, 2);</a>
<a name="ln1915">    dt_bauhaus_slider_set(upper, dev-&gt;overexposed.upper);</a>
<a name="ln1916">    dt_bauhaus_slider_set_format(upper, &quot;%.0f%%&quot;);</a>
<a name="ln1917">    dt_bauhaus_widget_set_label(upper, NULL, _(&quot;upper threshold&quot;));</a>
<a name="ln1918">    gtk_widget_set_tooltip_text(upper, _(&quot;threshold of what shall be considered overexposed&quot;));</a>
<a name="ln1919">    g_signal_connect(G_OBJECT(upper), &quot;value-changed&quot;, G_CALLBACK(upper_callback), dev);</a>
<a name="ln1920">    gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(upper), TRUE, TRUE, 0);</a>
<a name="ln1921">  }</a>
<a name="ln1922"> </a>
<a name="ln1923">  /* create profile popup tool &amp; buttons (softproof + gamut) */</a>
<a name="ln1924">  {</a>
<a name="ln1925">    // the softproof button</a>
<a name="ln1926">    dev-&gt;profile.softproof_button =</a>
<a name="ln1927">      dtgtk_togglebutton_new(dtgtk_cairo_paint_softproof, CPF_STYLE_FLAT, NULL);</a>
<a name="ln1928">    gtk_widget_set_tooltip_text(dev-&gt;profile.softproof_button,</a>
<a name="ln1929">                                _(&quot;toggle softproofing\nright click for profile options&quot;));</a>
<a name="ln1930">    g_signal_connect(G_OBJECT(dev-&gt;profile.softproof_button), &quot;clicked&quot;,</a>
<a name="ln1931">                     G_CALLBACK(_softproof_quickbutton_clicked), dev);</a>
<a name="ln1932">    g_signal_connect(G_OBJECT(dev-&gt;profile.softproof_button), &quot;button-press-event&quot;,</a>
<a name="ln1933">                     G_CALLBACK(_softproof_quickbutton_pressed), dev);</a>
<a name="ln1934">    g_signal_connect(G_OBJECT(dev-&gt;profile.softproof_button), &quot;button-release-event&quot;,</a>
<a name="ln1935">                     G_CALLBACK(_profile_quickbutton_released), dev);</a>
<a name="ln1936">    dt_view_manager_module_toolbox_add(darktable.view_manager, dev-&gt;profile.softproof_button, DT_VIEW_DARKROOM);</a>
<a name="ln1937">    dt_gui_add_help_link(dev-&gt;profile.softproof_button, dt_get_help_url(&quot;softproof&quot;));</a>
<a name="ln1938"> </a>
<a name="ln1939">    // the gamut check button</a>
<a name="ln1940">    dev-&gt;profile.gamut_button =</a>
<a name="ln1941">      dtgtk_togglebutton_new(dtgtk_cairo_paint_gamut_check, CPF_STYLE_FLAT, NULL);</a>
<a name="ln1942">    gtk_widget_set_tooltip_text(dev-&gt;profile.gamut_button,</a>
<a name="ln1943">                 _(&quot;toggle gamut checking\nright click for profile options&quot;));</a>
<a name="ln1944">    g_signal_connect(G_OBJECT(dev-&gt;profile.gamut_button), &quot;clicked&quot;,</a>
<a name="ln1945">                     G_CALLBACK(_gamut_quickbutton_clicked), dev);</a>
<a name="ln1946">    g_signal_connect(G_OBJECT(dev-&gt;profile.gamut_button), &quot;button-press-event&quot;,</a>
<a name="ln1947">                     G_CALLBACK(_gamut_quickbutton_pressed), dev);</a>
<a name="ln1948">    g_signal_connect(G_OBJECT(dev-&gt;profile.gamut_button), &quot;button-release-event&quot;,</a>
<a name="ln1949">                     G_CALLBACK(_profile_quickbutton_released), dev);</a>
<a name="ln1950">    dt_view_manager_module_toolbox_add(darktable.view_manager, dev-&gt;profile.gamut_button, DT_VIEW_DARKROOM);</a>
<a name="ln1951">    dt_gui_add_help_link(dev-&gt;profile.gamut_button, dt_get_help_url(&quot;gamut&quot;));</a>
<a name="ln1952"> </a>
<a name="ln1953">    // and the popup window, which is shared between the two profile buttons</a>
<a name="ln1954">    dev-&gt;profile.floating_window = gtk_popover_new(NULL);</a>
<a name="ln1955">    gtk_widget_set_size_request(GTK_WIDGET(dev-&gt;profile.floating_window), panel_width, -1);</a>
<a name="ln1956">#if GTK_CHECK_VERSION(3, 16, 0)</a>
<a name="ln1957">    g_object_set(G_OBJECT(dev-&gt;profile.floating_window), &quot;transitions-enabled&quot;, FALSE, NULL);</a>
<a name="ln1958">#endif</a>
<a name="ln1959"> </a>
<a name="ln1960">    GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1961">    gtk_container_add(GTK_CONTAINER(dev-&gt;profile.floating_window), vbox);</a>
<a name="ln1962"> </a>
<a name="ln1963">    /** let's fill the encapsulating widgets */</a>
<a name="ln1964">    char datadir[PATH_MAX] = { 0 };</a>
<a name="ln1965">    char confdir[PATH_MAX] = { 0 };</a>
<a name="ln1966">    dt_loc_get_user_config_dir(confdir, sizeof(confdir));</a>
<a name="ln1967">    dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln1968">    const int force_lcms2 = dt_conf_get_bool(&quot;plugins/lighttable/export/force_lcms2&quot;);</a>
<a name="ln1969"> </a>
<a name="ln1970">    GtkWidget *display_intent = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1971">    dt_bauhaus_widget_set_label(display_intent, NULL, _(&quot;display intent&quot;));</a>
<a name="ln1972">    gtk_box_pack_start(GTK_BOX(vbox), display_intent, TRUE, TRUE, 0);</a>
<a name="ln1973">    dt_bauhaus_combobox_add(display_intent, _(&quot;perceptual&quot;));</a>
<a name="ln1974">    dt_bauhaus_combobox_add(display_intent, _(&quot;relative colorimetric&quot;));</a>
<a name="ln1975">    dt_bauhaus_combobox_add(display_intent, C_(&quot;rendering intent&quot;, &quot;saturation&quot;));</a>
<a name="ln1976">    dt_bauhaus_combobox_add(display_intent, _(&quot;absolute colorimetric&quot;));</a>
<a name="ln1977"> </a>
<a name="ln1978">    GtkWidget *display2_intent = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1979">    dt_bauhaus_widget_set_label(display2_intent, NULL, _(&quot;preview display intent&quot;));</a>
<a name="ln1980">    gtk_box_pack_start(GTK_BOX(vbox), display2_intent, TRUE, TRUE, 0);</a>
<a name="ln1981">    dt_bauhaus_combobox_add(display2_intent, _(&quot;perceptual&quot;));</a>
<a name="ln1982">    dt_bauhaus_combobox_add(display2_intent, _(&quot;relative colorimetric&quot;));</a>
<a name="ln1983">    dt_bauhaus_combobox_add(display2_intent, C_(&quot;rendering intent&quot;, &quot;saturation&quot;));</a>
<a name="ln1984">    dt_bauhaus_combobox_add(display2_intent, _(&quot;absolute colorimetric&quot;));</a>
<a name="ln1985"> </a>
<a name="ln1986">    if(!force_lcms2)</a>
<a name="ln1987">    {</a>
<a name="ln1988">      gtk_widget_set_no_show_all(display_intent, TRUE);</a>
<a name="ln1989">      gtk_widget_set_visible(display_intent, FALSE);</a>
<a name="ln1990">      gtk_widget_set_no_show_all(display2_intent, TRUE);</a>
<a name="ln1991">      gtk_widget_set_visible(display2_intent, FALSE);</a>
<a name="ln1992">    }</a>
<a name="ln1993"> </a>
<a name="ln1994">    GtkWidget *display_profile = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1995">    GtkWidget *display2_profile = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1996">    GtkWidget *softproof_profile = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1997">    GtkWidget *histogram_profile = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1998">    dt_bauhaus_widget_set_label(softproof_profile, NULL, _(&quot;softproof profile&quot;));</a>
<a name="ln1999">    dt_bauhaus_widget_set_label(display_profile, NULL, _(&quot;display profile&quot;));</a>
<a name="ln2000">    dt_bauhaus_widget_set_label(display2_profile, NULL, _(&quot;preview display profile&quot;));</a>
<a name="ln2001">    dt_bauhaus_widget_set_label(histogram_profile, NULL, _(&quot;histogram profile&quot;));</a>
<a name="ln2002">    gtk_box_pack_start(GTK_BOX(vbox), softproof_profile, TRUE, TRUE, 0);</a>
<a name="ln2003">    gtk_box_pack_start(GTK_BOX(vbox), display_profile, TRUE, TRUE, 0);</a>
<a name="ln2004">    gtk_box_pack_start(GTK_BOX(vbox), display2_profile, TRUE, TRUE, 0);</a>
<a name="ln2005">    gtk_box_pack_start(GTK_BOX(vbox), histogram_profile, TRUE, TRUE, 0);</a>
<a name="ln2006"> </a>
<a name="ln2007">    GList *l = darktable.color_profiles-&gt;profiles;</a>
<a name="ln2008">    while(l)</a>
<a name="ln2009">    {</a>
<a name="ln2010">      dt_colorspaces_color_profile_t *prof = (dt_colorspaces_color_profile_t *)l-&gt;data;</a>
<a name="ln2011">      if(prof-&gt;display_pos &gt; -1)</a>
<a name="ln2012">      {</a>
<a name="ln2013">        dt_bauhaus_combobox_add(display_profile, prof-&gt;name);</a>
<a name="ln2014">        if(prof-&gt;type == darktable.color_profiles-&gt;display_type</a>
<a name="ln2015">          &amp;&amp; (prof-&gt;type != DT_COLORSPACE_FILE</a>
<a name="ln2016">              || !strcmp(prof-&gt;filename, darktable.color_profiles-&gt;display_filename)))</a>
<a name="ln2017">        {</a>
<a name="ln2018">          dt_bauhaus_combobox_set(display_profile, prof-&gt;display_pos);</a>
<a name="ln2019">        }</a>
<a name="ln2020">      }</a>
<a name="ln2021">      if(prof-&gt;display2_pos &gt; -1)</a>
<a name="ln2022">      {</a>
<a name="ln2023">        dt_bauhaus_combobox_add(display2_profile, prof-&gt;name);</a>
<a name="ln2024">        if(prof-&gt;type == darktable.color_profiles-&gt;display2_type</a>
<a name="ln2025">           &amp;&amp; (prof-&gt;type != DT_COLORSPACE_FILE</a>
<a name="ln2026">               || !strcmp(prof-&gt;filename, darktable.color_profiles-&gt;display2_filename)))</a>
<a name="ln2027">        {</a>
<a name="ln2028">          dt_bauhaus_combobox_set(display2_profile, prof-&gt;display2_pos);</a>
<a name="ln2029">        }</a>
<a name="ln2030">      }</a>
<a name="ln2031">      // the system display profile is only suitable for display purposes</a>
<a name="ln2032">      if(prof-&gt;out_pos &gt; -1)</a>
<a name="ln2033">      {</a>
<a name="ln2034">        dt_bauhaus_combobox_add(softproof_profile, prof-&gt;name);</a>
<a name="ln2035">        if(prof-&gt;type == darktable.color_profiles-&gt;softproof_type</a>
<a name="ln2036">          &amp;&amp; (prof-&gt;type != DT_COLORSPACE_FILE</a>
<a name="ln2037">              || !strcmp(prof-&gt;filename, darktable.color_profiles-&gt;softproof_filename)))</a>
<a name="ln2038">          dt_bauhaus_combobox_set(softproof_profile, prof-&gt;out_pos);</a>
<a name="ln2039">      }</a>
<a name="ln2040">      if(prof-&gt;category_pos &gt; -1)</a>
<a name="ln2041">      {</a>
<a name="ln2042">        dt_bauhaus_combobox_add(histogram_profile, prof-&gt;name);</a>
<a name="ln2043">        if(prof-&gt;type == darktable.color_profiles-&gt;histogram_type</a>
<a name="ln2044">          &amp;&amp; (prof-&gt;type != DT_COLORSPACE_FILE</a>
<a name="ln2045">              || !strcmp(prof-&gt;filename, darktable.color_profiles-&gt;histogram_filename)))</a>
<a name="ln2046">        {</a>
<a name="ln2047">          dt_bauhaus_combobox_set(histogram_profile, prof-&gt;category_pos);</a>
<a name="ln2048">        }</a>
<a name="ln2049">      }</a>
<a name="ln2050">      l = g_list_next(l);</a>
<a name="ln2051">    }</a>
<a name="ln2052"> </a>
<a name="ln2053">    char *system_profile_dir = g_build_filename(datadir, &quot;color&quot;, &quot;out&quot;, NULL);</a>
<a name="ln2054">    char *user_profile_dir = g_build_filename(confdir, &quot;color&quot;, &quot;out&quot;, NULL);</a>
<a name="ln2055">    char *tooltip = g_strdup_printf(_(&quot;display ICC profiles in %s or %s&quot;), user_profile_dir, system_profile_dir);</a>
<a name="ln2056">    gtk_widget_set_tooltip_text(display_profile, tooltip);</a>
<a name="ln2057">    g_free(tooltip);</a>
<a name="ln2058">    tooltip = g_strdup_printf(_(&quot;preview display ICC profiles in %s or %s&quot;), user_profile_dir, system_profile_dir);</a>
<a name="ln2059">    gtk_widget_set_tooltip_text(display2_profile, tooltip);</a>
<a name="ln2060">    g_free(tooltip);</a>
<a name="ln2061">    tooltip = g_strdup_printf(_(&quot;softproof ICC profiles in %s or %s&quot;), user_profile_dir, system_profile_dir);</a>
<a name="ln2062">    gtk_widget_set_tooltip_text(softproof_profile, tooltip);</a>
<a name="ln2063">    g_free(tooltip);</a>
<a name="ln2064">    tooltip = g_strdup_printf(_(&quot;histogram and color picker ICC profiles in %s or %s&quot;), user_profile_dir, system_profile_dir);</a>
<a name="ln2065">    gtk_widget_set_tooltip_text(histogram_profile, tooltip);</a>
<a name="ln2066">    g_free(tooltip);</a>
<a name="ln2067">    g_free(system_profile_dir);</a>
<a name="ln2068">    g_free(user_profile_dir);</a>
<a name="ln2069"> </a>
<a name="ln2070">    g_signal_connect(G_OBJECT(display_intent), &quot;value-changed&quot;, G_CALLBACK(display_intent_callback), dev);</a>
<a name="ln2071">    g_signal_connect(G_OBJECT(display_profile), &quot;value-changed&quot;, G_CALLBACK(display_profile_callback), dev);</a>
<a name="ln2072">    g_signal_connect(G_OBJECT(display2_intent), &quot;value-changed&quot;, G_CALLBACK(display2_intent_callback), dev);</a>
<a name="ln2073">    g_signal_connect(G_OBJECT(display2_profile), &quot;value-changed&quot;, G_CALLBACK(display2_profile_callback), dev);</a>
<a name="ln2074">    g_signal_connect(G_OBJECT(softproof_profile), &quot;value-changed&quot;, G_CALLBACK(softproof_profile_callback), dev);</a>
<a name="ln2075">    g_signal_connect(G_OBJECT(histogram_profile), &quot;value-changed&quot;, G_CALLBACK(histogram_profile_callback), dev);</a>
<a name="ln2076"> </a>
<a name="ln2077">    _update_softproof_gamut_checking(dev);</a>
<a name="ln2078"> </a>
<a name="ln2079">    // update the gui when the preferences changed (i.e. show intent when using lcms2)</a>
<a name="ln2080">    dt_control_signal_connect(darktable.signals, DT_SIGNAL_PREFERENCES_CHANGE,</a>
<a name="ln2081">                              G_CALLBACK(_preference_changed), (gpointer)display_intent);</a>
<a name="ln2082">    dt_control_signal_connect(darktable.signals, DT_SIGNAL_PREFERENCES_CHANGE, G_CALLBACK(_preference_changed),</a>
<a name="ln2083">                              (gpointer)display2_intent);</a>
<a name="ln2084">    // and when profiles change</a>
<a name="ln2085">    dt_control_signal_connect(darktable.signals, DT_SIGNAL_CONTROL_PROFILE_USER_CHANGED,</a>
<a name="ln2086">                              G_CALLBACK(_display_profile_changed), (gpointer)display_profile);</a>
<a name="ln2087">    dt_control_signal_connect(darktable.signals, DT_SIGNAL_CONTROL_PROFILE_USER_CHANGED,</a>
<a name="ln2088">                              G_CALLBACK(_display2_profile_changed), (gpointer)display2_profile);</a>
<a name="ln2089">  }</a>
<a name="ln2090">}</a>
<a name="ln2091"> </a>
<a name="ln2092">enum</a>
<a name="ln2093">{</a>
<a name="ln2094">  DND_TARGET_IOP,</a>
<a name="ln2095">};</a>
<a name="ln2096"> </a>
<a name="ln2097">/** drag and drop module list */</a>
<a name="ln2098">static const GtkTargetEntry _iop_target_list_internal[] = { { &quot;iop&quot;, GTK_TARGET_SAME_WIDGET, DND_TARGET_IOP } };</a>
<a name="ln2099">static const guint _iop_n_targets_internal = G_N_ELEMENTS(_iop_target_list_internal);</a>
<a name="ln2100"> </a>
<a name="ln2101">static dt_iop_module_t *_get_dnd_dest_module(GtkBox *container, gint x, gint y)</a>
<a name="ln2102">{</a>
<a name="ln2103">  dt_iop_module_t *module_dest = NULL;</a>
<a name="ln2104"> </a>
<a name="ln2105">  GtkWidget *widget_dest = NULL;</a>
<a name="ln2106">  GList *children = gtk_container_get_children(GTK_CONTAINER(container));</a>
<a name="ln2107">  for(GList *l = children; l != NULL; l = g_list_next(l))</a>
<a name="ln2108">  {</a>
<a name="ln2109">    GtkWidget *w = GTK_WIDGET(l-&gt;data);</a>
<a name="ln2110"> </a>
<a name="ln2111">    if(w &amp;&amp; gtk_widget_is_visible(w))</a>
<a name="ln2112">    {</a>
<a name="ln2113">      GtkAllocation allocation_w = {0};</a>
<a name="ln2114">      gtk_widget_get_allocation(w, &amp;allocation_w);</a>
<a name="ln2115">      if(y &lt;= allocation_w.y + allocation_w.height + DT_PIXEL_APPLY_DPI(8) &amp;&amp; y &gt;= allocation_w.y - DT_PIXEL_APPLY_DPI(8))</a>
<a name="ln2116">      {</a>
<a name="ln2117">        widget_dest = w;</a>
<a name="ln2118">        break;</a>
<a name="ln2119">      }</a>
<a name="ln2120">    }</a>
<a name="ln2121">  }</a>
<a name="ln2122">  g_list_free(children);</a>
<a name="ln2123"> </a>
<a name="ln2124">  if(widget_dest)</a>
<a name="ln2125">  {</a>
<a name="ln2126">    GList *modules = g_list_first(darktable.develop-&gt;iop);</a>
<a name="ln2127">    while(modules)</a>
<a name="ln2128">    {</a>
<a name="ln2129">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln2130">      if(mod-&gt;expander == widget_dest)</a>
<a name="ln2131">      {</a>
<a name="ln2132">        module_dest = mod;</a>
<a name="ln2133">        break;</a>
<a name="ln2134">      }</a>
<a name="ln2135">      modules = g_list_next(modules);</a>
<a name="ln2136">    }</a>
<a name="ln2137">  }</a>
<a name="ln2138"> </a>
<a name="ln2139">  return module_dest;</a>
<a name="ln2140">}</a>
<a name="ln2141"> </a>
<a name="ln2142">static dt_iop_module_t *_get_dnd_source_module(GtkBox *container)</a>
<a name="ln2143">{</a>
<a name="ln2144">  dt_iop_module_t *module_source = NULL;</a>
<a name="ln2145">  gpointer *source_data = g_object_get_data(G_OBJECT(container), &quot;source_data&quot;);</a>
<a name="ln2146">  if(source_data) module_source = (dt_iop_module_t *)source_data;</a>
<a name="ln2147"> </a>
<a name="ln2148">  return module_source;</a>
<a name="ln2149">}</a>
<a name="ln2150"> </a>
<a name="ln2151">// this will be used for a custom highlight, if ever implemented</a>
<a name="ln2152">static void _on_drag_end(GtkWidget *widget, GdkDragContext *context, gpointer user_data)</a>
<a name="ln2153">{</a>
<a name="ln2154">}</a>
<a name="ln2155"> </a>
<a name="ln2156">// FIXME: default highlight for the dnd is barely visible</a>
<a name="ln2157">// it should be possible to configure it</a>
<a name="ln2158">static void _on_drag_begin(GtkWidget *widget, GdkDragContext *context, gpointer user_data)</a>
<a name="ln2159">{</a>
<a name="ln2160">  GtkBox *container = dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER);</a>
<a name="ln2161">  dt_iop_module_t *module_src = _get_dnd_source_module(container);</a>
<a name="ln2162">  if(module_src &amp;&amp; module_src-&gt;expander)</a>
<a name="ln2163">  {</a>
<a name="ln2164">    GdkWindow *window = gtk_widget_get_parent_window(module_src-&gt;expander);</a>
<a name="ln2165">    if(window)</a>
<a name="ln2166">    {</a>
<a name="ln2167">      GtkAllocation allocation_w = {0};</a>
<a name="ln2168">      gtk_widget_get_allocation(module_src-&gt;expander, &amp;allocation_w);</a>
<a name="ln2169"> </a>
<a name="ln2170">      GdkPixbuf *pixbuf = gdk_pixbuf_get_from_window(window, allocation_w.x, allocation_w.y,</a>
<a name="ln2171">                                                     allocation_w.width, allocation_w.height);</a>
<a name="ln2172">      gtk_drag_set_icon_pixbuf(context, pixbuf, allocation_w.width / 2, 0);</a>
<a name="ln2173">    }</a>
<a name="ln2174">  }</a>
<a name="ln2175">}</a>
<a name="ln2176"> </a>
<a name="ln2177">static void _on_drag_data_get(GtkWidget *widget, GdkDragContext *context,</a>
<a name="ln2178">                              GtkSelectionData *selection_data, guint info, guint time,</a>
<a name="ln2179">                              gpointer user_data)</a>
<a name="ln2180">{</a>
<a name="ln2181">  gpointer *target_data = g_object_get_data(G_OBJECT(widget), &quot;target_data&quot;);</a>
<a name="ln2182">  guint number_data = 0;</a>
<a name="ln2183">  if(target_data) number_data = GPOINTER_TO_UINT(target_data[DND_TARGET_IOP]);</a>
<a name="ln2184">  gtk_selection_data_set(selection_data, gdk_atom_intern(&quot;iop&quot;, TRUE), // type</a>
<a name="ln2185">                                        32,                            // format</a>
<a name="ln2186">                                        (guchar*)&amp;number_data,         // data</a>
<a name="ln2187">                                        1);                            // length</a>
<a name="ln2188">}</a>
<a name="ln2189"> </a>
<a name="ln2190">static gboolean _on_drag_drop(GtkWidget *widget, GdkDragContext *dc, gint x, gint y, guint time, gpointer user_data)</a>
<a name="ln2191">{</a>
<a name="ln2192">  GdkAtom target_atom = GDK_NONE;</a>
<a name="ln2193"> </a>
<a name="ln2194">  target_atom = gdk_atom_intern(&quot;iop&quot;, TRUE);</a>
<a name="ln2195"> </a>
<a name="ln2196">  gtk_drag_get_data(widget, dc, target_atom, time);</a>
<a name="ln2197"> </a>
<a name="ln2198">  return TRUE;</a>
<a name="ln2199">}</a>
<a name="ln2200"> </a>
<a name="ln2201">static gboolean _on_drag_motion(GtkWidget *widget, GdkDragContext *dc, gint x, gint y, guint time, gpointer user_data)</a>
<a name="ln2202">{</a>
<a name="ln2203">  gboolean can_moved = FALSE;</a>
<a name="ln2204">  GtkBox *container = dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER);</a>
<a name="ln2205">  dt_iop_module_t *module_src = _get_dnd_source_module(container);</a>
<a name="ln2206">  dt_iop_module_t *module_dest = _get_dnd_dest_module(container, x, y);</a>
<a name="ln2207"> </a>
<a name="ln2208">  if(module_src &amp;&amp; module_dest &amp;&amp; module_src != module_dest)</a>
<a name="ln2209">  {</a>
<a name="ln2210">    double iop_order = -1.0;</a>
<a name="ln2211">    if(module_src-&gt;iop_order &lt; module_dest-&gt;iop_order)</a>
<a name="ln2212">      iop_order = dt_ioppr_get_iop_order_after_iop(darktable.develop-&gt;iop, module_src, module_dest, 1, 0);</a>
<a name="ln2213">    else</a>
<a name="ln2214">      iop_order = dt_ioppr_get_iop_order_before_iop(darktable.develop-&gt;iop, module_src, module_dest, 1, 0);</a>
<a name="ln2215"> </a>
<a name="ln2216">    if(iop_order &gt; 0.0 &amp;&amp; iop_order != module_src-&gt;iop_order)</a>
<a name="ln2217">      can_moved = TRUE;</a>
<a name="ln2218">  }</a>
<a name="ln2219"> </a>
<a name="ln2220">  if(can_moved)</a>
<a name="ln2221">  {</a>
<a name="ln2222">    gdk_drag_status(dc, GDK_ACTION_COPY, time);</a>
<a name="ln2223">    GtkWidget *w = g_object_get_data(G_OBJECT(widget), &quot;highlighted&quot;);</a>
<a name="ln2224">    if(w) gtk_drag_unhighlight(w);</a>
<a name="ln2225">    g_object_set_data(G_OBJECT(widget), &quot;highlighted&quot;, (gpointer)module_dest-&gt;expander);</a>
<a name="ln2226">    gtk_drag_highlight(module_dest-&gt;expander);</a>
<a name="ln2227">  }</a>
<a name="ln2228">  else</a>
<a name="ln2229">  {</a>
<a name="ln2230">    gdk_drag_status(dc, 0, time);</a>
<a name="ln2231">    GtkWidget *w = g_object_get_data(G_OBJECT(widget), &quot;highlighted&quot;);</a>
<a name="ln2232">    if(w)</a>
<a name="ln2233">    {</a>
<a name="ln2234">      gtk_drag_unhighlight(w);</a>
<a name="ln2235">      g_object_set_data(G_OBJECT(widget), &quot;highlighted&quot;, (gpointer)FALSE);</a>
<a name="ln2236">    }</a>
<a name="ln2237">  }</a>
<a name="ln2238"> </a>
<a name="ln2239">  return can_moved;</a>
<a name="ln2240">}</a>
<a name="ln2241"> </a>
<a name="ln2242">static void _on_drag_data_received(GtkWidget *widget, GdkDragContext *dc, gint x, gint y,</a>
<a name="ln2243">                                   GtkSelectionData *selection_data,</a>
<a name="ln2244">                                   guint info, guint time, gpointer user_data)</a>
<a name="ln2245">{</a>
<a name="ln2246">  int moved = 0;</a>
<a name="ln2247">  GtkBox *container = dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER);</a>
<a name="ln2248">  dt_iop_module_t *module_src = _get_dnd_source_module(container);</a>
<a name="ln2249">  dt_iop_module_t *module_dest = _get_dnd_dest_module(container, x, y);</a>
<a name="ln2250"> </a>
<a name="ln2251">  if(module_src &amp;&amp; module_dest &amp;&amp; module_src != module_dest)</a>
<a name="ln2252">  {</a>
<a name="ln2253">    if(module_src-&gt;iop_order &lt; module_dest-&gt;iop_order)</a>
<a name="ln2254">    {</a>
<a name="ln2255">      /* printf(&quot;[_on_drag_data_received] moving %s %s(%f) after %s %s(%f)\n&quot;,</a>
<a name="ln2256">          module_src-&gt;op, module_src-&gt;multi_name, module_src-&gt;iop_order,</a>
<a name="ln2257">          module_dest-&gt;op, module_dest-&gt;multi_name, module_dest-&gt;iop_order); */</a>
<a name="ln2258">      moved = dt_ioppr_move_iop_after(&amp;darktable.develop-&gt;iop, module_src, module_dest, 1, 1);</a>
<a name="ln2259">    }</a>
<a name="ln2260">    else</a>
<a name="ln2261">    {</a>
<a name="ln2262">      /* printf(&quot;[_on_drag_data_received] moving %s %s(%f) before %s %s(%f)\n&quot;,</a>
<a name="ln2263">          module_src-&gt;op, module_src-&gt;multi_name, module_src-&gt;iop_order,</a>
<a name="ln2264">          module_dest-&gt;op, module_dest-&gt;multi_name, module_dest-&gt;iop_order); */</a>
<a name="ln2265">      moved = dt_ioppr_move_iop_before(&amp;darktable.develop-&gt;iop, module_src, module_dest, 1, 1);</a>
<a name="ln2266">    }</a>
<a name="ln2267">  }</a>
<a name="ln2268">  else</a>
<a name="ln2269">  {</a>
<a name="ln2270">    if(module_src == NULL)</a>
<a name="ln2271">      fprintf(stderr, &quot;[_on_drag_data_received] can't find source module\n&quot;);</a>
<a name="ln2272">    if(module_dest == NULL)</a>
<a name="ln2273">      fprintf(stderr, &quot;[_on_drag_data_received] can't find destination module\n&quot;);</a>
<a name="ln2274">  }</a>
<a name="ln2275"> </a>
<a name="ln2276">  gtk_drag_finish(dc, TRUE, FALSE, time);</a>
<a name="ln2277"> </a>
<a name="ln2278">  if(moved)</a>
<a name="ln2279">  {</a>
<a name="ln2280">    // we move the headers</a>
<a name="ln2281">    GValue gv = { 0, { { 0 } } };</a>
<a name="ln2282">    g_value_init(&amp;gv, G_TYPE_INT);</a>
<a name="ln2283">    gtk_container_child_get_property(</a>
<a name="ln2284">        GTK_CONTAINER(dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER)), module_dest-&gt;expander,</a>
<a name="ln2285">        &quot;position&quot;, &amp;gv);</a>
<a name="ln2286">    gtk_box_reorder_child(dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER),</a>
<a name="ln2287">        module_src-&gt;expander, g_value_get_int(&amp;gv));</a>
<a name="ln2288"> </a>
<a name="ln2289">    // we update the headers</a>
<a name="ln2290">    dt_dev_modules_update_multishow(module_src-&gt;dev);</a>
<a name="ln2291"> </a>
<a name="ln2292">    dt_dev_add_history_item(module_src-&gt;dev, module_src, TRUE);</a>
<a name="ln2293"> </a>
<a name="ln2294">    dt_ioppr_check_iop_order(module_src-&gt;dev, 0, &quot;_on_drag_data_received end&quot;);</a>
<a name="ln2295"> </a>
<a name="ln2296">    // we rebuild the pipe</a>
<a name="ln2297">    module_src-&gt;dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln2298">    module_src-&gt;dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln2299">    module_src-&gt;dev-&gt;preview2_pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln2300">    module_src-&gt;dev-&gt;pipe-&gt;cache_obsolete = 1;</a>
<a name="ln2301">    module_src-&gt;dev-&gt;preview_pipe-&gt;cache_obsolete = 1;</a>
<a name="ln2302">    module_src-&gt;dev-&gt;preview2_pipe-&gt;cache_obsolete = 1;</a>
<a name="ln2303"> </a>
<a name="ln2304">    // invalidate buffers and force redraw of darkroom</a>
<a name="ln2305">    dt_dev_invalidate_all(module_src-&gt;dev);</a>
<a name="ln2306">  }</a>
<a name="ln2307">}</a>
<a name="ln2308"> </a>
<a name="ln2309">static void _on_drag_leave(GtkWidget *widget, GdkDragContext *dc, guint time, gpointer user_data)</a>
<a name="ln2310">{</a>
<a name="ln2311">  GtkWidget *w = g_object_get_data(G_OBJECT(widget), &quot;highlighted&quot;);</a>
<a name="ln2312">  if(w)</a>
<a name="ln2313">  {</a>
<a name="ln2314">    gtk_drag_unhighlight(w);</a>
<a name="ln2315">    g_object_set_data(G_OBJECT(widget), &quot;highlighted&quot;, (gpointer)FALSE);</a>
<a name="ln2316">  }</a>
<a name="ln2317">}</a>
<a name="ln2318"> </a>
<a name="ln2319">static void _register_modules_drag_n_drop(dt_view_t *self)</a>
<a name="ln2320">{</a>
<a name="ln2321">  if(darktable.gui)</a>
<a name="ln2322">  {</a>
<a name="ln2323">    GtkWidget *container = GTK_WIDGET(dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER));</a>
<a name="ln2324"> </a>
<a name="ln2325">    gtk_drag_source_set(container, GDK_BUTTON1_MASK | GDK_SHIFT_MASK, _iop_target_list_internal, _iop_n_targets_internal, GDK_ACTION_COPY);</a>
<a name="ln2326"> </a>
<a name="ln2327">    g_object_set_data(G_OBJECT(container), &quot;targetlist&quot;, (gpointer)_iop_target_list_internal);</a>
<a name="ln2328">    g_object_set_data(G_OBJECT(container), &quot;ntarget&quot;, GUINT_TO_POINTER(_iop_n_targets_internal));</a>
<a name="ln2329"> </a>
<a name="ln2330">    g_signal_connect(container, &quot;drag-begin&quot;, G_CALLBACK(_on_drag_begin), NULL);</a>
<a name="ln2331">    g_signal_connect(container, &quot;drag-data-get&quot;, G_CALLBACK(_on_drag_data_get), NULL);</a>
<a name="ln2332">    g_signal_connect(container, &quot;drag-end&quot;, G_CALLBACK(_on_drag_end), NULL);</a>
<a name="ln2333"> </a>
<a name="ln2334">    gtk_drag_dest_set(container, 0, _iop_target_list_internal, _iop_n_targets_internal, GDK_ACTION_COPY);</a>
<a name="ln2335"> </a>
<a name="ln2336">    g_signal_connect(container, &quot;drag-data-received&quot;, G_CALLBACK(_on_drag_data_received), NULL);</a>
<a name="ln2337">    g_signal_connect(container, &quot;drag-drop&quot;, G_CALLBACK(_on_drag_drop), NULL);</a>
<a name="ln2338">    g_signal_connect(container, &quot;drag-motion&quot;, G_CALLBACK(_on_drag_motion), NULL);</a>
<a name="ln2339">    g_signal_connect(container, &quot;drag-leave&quot;, G_CALLBACK(_on_drag_leave), NULL);</a>
<a name="ln2340">  }</a>
<a name="ln2341">}</a>
<a name="ln2342"> </a>
<a name="ln2343">static void _unregister_modules_drag_n_drop(dt_view_t *self)</a>
<a name="ln2344">{</a>
<a name="ln2345">  if(darktable.gui)</a>
<a name="ln2346">  {</a>
<a name="ln2347">    gtk_drag_source_unset(dt_ui_center(darktable.gui-&gt;ui));</a>
<a name="ln2348"> </a>
<a name="ln2349">    GtkBox *container = dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER);</a>
<a name="ln2350"> </a>
<a name="ln2351">    g_signal_handlers_disconnect_matched(container, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, 0, 0, NULL, G_CALLBACK(_on_drag_begin), NULL);</a>
<a name="ln2352">    g_signal_handlers_disconnect_matched(container, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, 0, 0, NULL, G_CALLBACK(_on_drag_data_get), NULL);</a>
<a name="ln2353">    g_signal_handlers_disconnect_matched(container, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, 0, 0, NULL, G_CALLBACK(_on_drag_end), NULL);</a>
<a name="ln2354">    g_signal_handlers_disconnect_matched(container, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, 0, 0, NULL, G_CALLBACK(_on_drag_data_received), NULL);</a>
<a name="ln2355">    g_signal_handlers_disconnect_matched(container, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, 0, 0, NULL, G_CALLBACK(_on_drag_drop), NULL);</a>
<a name="ln2356">    g_signal_handlers_disconnect_matched(container, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, 0, 0, NULL, G_CALLBACK(_on_drag_motion), NULL);</a>
<a name="ln2357">    g_signal_handlers_disconnect_matched(container, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, 0, 0, NULL, G_CALLBACK(_on_drag_leave), NULL);</a>
<a name="ln2358">  }</a>
<a name="ln2359">}</a>
<a name="ln2360"> </a>
<a name="ln2361">void enter(dt_view_t *self)</a>
<a name="ln2362">{</a>
<a name="ln2363">  // prevent accels_window to refresh</a>
<a name="ln2364">  darktable.view_manager-&gt;accels_window.prevent_refresh = TRUE;</a>
<a name="ln2365"> </a>
<a name="ln2366">  // clean the undo list</a>
<a name="ln2367">  dt_undo_clear(darktable.undo, DT_UNDO_DEVELOP);</a>
<a name="ln2368"> </a>
<a name="ln2369">  /* connect to ui pipe finished signal for redraw */</a>
<a name="ln2370">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_UI_PIPE_FINISHED,</a>
<a name="ln2371">                            G_CALLBACK(_darkroom_ui_pipe_finish_signal_callback), (gpointer)self);</a>
<a name="ln2372"> </a>
<a name="ln2373">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_PREVIEW2_PIPE_FINISHED,</a>
<a name="ln2374">                            G_CALLBACK(_darkroom_ui_preview2_pipe_finish_signal_callback), (gpointer)self);</a>
<a name="ln2375"> </a>
<a name="ln2376">  dt_print(DT_DEBUG_CONTROL, &quot;[run_job+] 11 %f in darkroom mode\n&quot;, dt_get_wtime());</a>
<a name="ln2377">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2378">  if(!dev-&gt;form_gui)</a>
<a name="ln2379">  {</a>
<a name="ln2380">    dev-&gt;form_gui = (dt_masks_form_gui_t *)calloc(1, sizeof(dt_masks_form_gui_t));</a>
<a name="ln2381">    dt_masks_init_form_gui(dev-&gt;form_gui);</a>
<a name="ln2382">  }</a>
<a name="ln2383">  dt_masks_change_form_gui(NULL);</a>
<a name="ln2384">  dev-&gt;form_gui-&gt;pipe_hash = 0;</a>
<a name="ln2385">  dev-&gt;form_gui-&gt;formid = 0;</a>
<a name="ln2386">  dev-&gt;gui_leaving = 0;</a>
<a name="ln2387">  dev-&gt;gui_module = NULL;</a>
<a name="ln2388"> </a>
<a name="ln2389">  select_this_image(dev-&gt;image_storage.id);</a>
<a name="ln2390"> </a>
<a name="ln2391">  dt_control_set_dev_zoom(DT_ZOOM_FIT);</a>
<a name="ln2392">  dt_control_set_dev_zoom_x(0);</a>
<a name="ln2393">  dt_control_set_dev_zoom_y(0);</a>
<a name="ln2394">  dt_control_set_dev_closeup(0);</a>
<a name="ln2395"> </a>
<a name="ln2396">  // take a copy of the image struct for convenience.</a>
<a name="ln2397"> </a>
<a name="ln2398">  dt_dev_load_image(darktable.develop, dev-&gt;image_storage.id);</a>
<a name="ln2399"> </a>
<a name="ln2400"> </a>
<a name="ln2401">  /*</a>
<a name="ln2402">   * add IOP modules to plugin list</a>
<a name="ln2403">   */</a>
<a name="ln2404">  // avoid triggering of events before plugin is ready:</a>
<a name="ln2405">  const int reset = darktable.gui-&gt;reset;</a>
<a name="ln2406">  darktable.gui-&gt;reset = 1;</a>
<a name="ln2407">  char option[1024];</a>
<a name="ln2408">  GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln2409">  while(modules)</a>
<a name="ln2410">  {</a>
<a name="ln2411">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln2412"> </a>
<a name="ln2413">    /* initialize gui if iop have one defined */</a>
<a name="ln2414">    if(!dt_iop_is_hidden(module))</a>
<a name="ln2415">    {</a>
<a name="ln2416">      module-&gt;gui_init(module);</a>
<a name="ln2417">      dt_iop_reload_defaults(module);</a>
<a name="ln2418"> </a>
<a name="ln2419">      /* add module to right panel */</a>
<a name="ln2420">      GtkWidget *expander = dt_iop_gui_get_expander(module);</a>
<a name="ln2421">      dt_ui_container_add_widget(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER, expander);</a>
<a name="ln2422"> </a>
<a name="ln2423">      snprintf(option, sizeof(option), &quot;plugins/darkroom/%s/expanded&quot;, module-&gt;op);</a>
<a name="ln2424">      dt_iop_gui_set_expanded(module, dt_conf_get_bool(option), FALSE);</a>
<a name="ln2425">    }</a>
<a name="ln2426"> </a>
<a name="ln2427">    /* setup key accelerators (only if not hidden) */</a>
<a name="ln2428">    module-&gt;accel_closures = NULL;</a>
<a name="ln2429">    if(module-&gt;so-&gt;state != dt_iop_state_HIDDEN)</a>
<a name="ln2430">    {</a>
<a name="ln2431">      if(module-&gt;connect_key_accels) module-&gt;connect_key_accels(module);</a>
<a name="ln2432">      dt_iop_connect_common_accels(module);</a>
<a name="ln2433">    }</a>
<a name="ln2434"> </a>
<a name="ln2435">    modules = g_list_previous(modules);</a>
<a name="ln2436">  }</a>
<a name="ln2437">  // make signals work again:</a>
<a name="ln2438">  darktable.gui-&gt;reset = reset;</a>
<a name="ln2439"> </a>
<a name="ln2440">  /* signal that darktable.develop is initialized and ready to be used */</a>
<a name="ln2441">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_INITIALIZE);</a>
<a name="ln2442"> </a>
<a name="ln2443">  // synch gui and flag pipe as dirty</a>
<a name="ln2444">  // this is done here and not in dt_read_history, as it would else be triggered before module-&gt;gui_init.</a>
<a name="ln2445">  dt_dev_pop_history_items(dev, dev-&gt;history_end);</a>
<a name="ln2446"> </a>
<a name="ln2447">  /* ensure that filmstrip shows current image */</a>
<a name="ln2448">  dt_view_filmstrip_scroll_to_image(darktable.view_manager, dev-&gt;image_storage.id, FALSE);</a>
<a name="ln2449"> </a>
<a name="ln2450">  // switch on groups as they were last time:</a>
<a name="ln2451">  dt_dev_modulegroups_set(dev, dt_conf_get_int(&quot;plugins/darkroom/groups&quot;));</a>
<a name="ln2452"> </a>
<a name="ln2453">  // get last active plugin:</a>
<a name="ln2454">  gchar *active_plugin = dt_conf_get_string(&quot;plugins/darkroom/active&quot;);</a>
<a name="ln2455">  if(active_plugin)</a>
<a name="ln2456">  {</a>
<a name="ln2457">    modules = dev-&gt;iop;</a>
<a name="ln2458">    while(modules)</a>
<a name="ln2459">    {</a>
<a name="ln2460">      dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln2461">      if(!strcmp(module-&gt;op, active_plugin)) dt_iop_request_focus(module);</a>
<a name="ln2462">      modules = g_list_next(modules);</a>
<a name="ln2463">    }</a>
<a name="ln2464">    g_free(active_plugin);</a>
<a name="ln2465">  }</a>
<a name="ln2466"> </a>
<a name="ln2467">  // update module multishow state now modules are loaded</a>
<a name="ln2468">  dt_dev_modules_update_multishow(dev);</a>
<a name="ln2469"> </a>
<a name="ln2470">  // image should be there now.</a>
<a name="ln2471">  float zoom_x, zoom_y;</a>
<a name="ln2472">  dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, DT_ZOOM_FIT, 0, NULL, NULL);</a>
<a name="ln2473">  dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln2474">  dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln2475"> </a>
<a name="ln2476">  /* connect signal for filmstrip image activate */</a>
<a name="ln2477">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_VIEWMANAGER_FILMSTRIP_ACTIVATE,</a>
<a name="ln2478">                            G_CALLBACK(_view_darkroom_filmstrip_activate_callback), self);</a>
<a name="ln2479"> </a>
<a name="ln2480">  // prefetch next few from first selected image on.</a>
<a name="ln2481">  dt_view_filmstrip_prefetch();</a>
<a name="ln2482"> </a>
<a name="ln2483">  dt_collection_hint_message(darktable.collection);</a>
<a name="ln2484"> </a>
<a name="ln2485">  char *scrollbars_conf = dt_conf_get_string(&quot;scrollbars&quot;);</a>
<a name="ln2486"> </a>
<a name="ln2487">  gboolean scrollbars_visible = FALSE;</a>
<a name="ln2488">  if(scrollbars_conf)</a>
<a name="ln2489">  {</a>
<a name="ln2490">    if(!strcmp(scrollbars_conf, &quot;lighttable + darkroom&quot;))</a>
<a name="ln2491">      scrollbars_visible = TRUE;</a>
<a name="ln2492">    g_free(scrollbars_conf);</a>
<a name="ln2493">  }</a>
<a name="ln2494"> </a>
<a name="ln2495">  dt_ui_scrollbars_show(darktable.gui-&gt;ui, scrollbars_visible);</a>
<a name="ln2496"> </a>
<a name="ln2497">  _register_modules_drag_n_drop(self);</a>
<a name="ln2498"> </a>
<a name="ln2499">  if(dt_conf_get_bool(&quot;second_window/last_visible&quot;))</a>
<a name="ln2500">  {</a>
<a name="ln2501">    _darkroom_display_second_window(dev);</a>
<a name="ln2502">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(dev-&gt;second_window.button), TRUE);</a>
<a name="ln2503">  }</a>
<a name="ln2504"> </a>
<a name="ln2505">  // update accels_window</a>
<a name="ln2506">  darktable.view_manager-&gt;accels_window.prevent_refresh = FALSE;</a>
<a name="ln2507">}</a>
<a name="ln2508"> </a>
<a name="ln2509">void leave(dt_view_t *self)</a>
<a name="ln2510">{</a>
<a name="ln2511">  _unregister_modules_drag_n_drop(self);</a>
<a name="ln2512"> </a>
<a name="ln2513">  /* disconnect from filmstrip image activate */</a>
<a name="ln2514">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_view_darkroom_filmstrip_activate_callback),</a>
<a name="ln2515">                               (gpointer)self);</a>
<a name="ln2516"> </a>
<a name="ln2517">  /* disconnect from pipe finish signal */</a>
<a name="ln2518">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_darkroom_ui_pipe_finish_signal_callback),</a>
<a name="ln2519">                               (gpointer)self);</a>
<a name="ln2520"> </a>
<a name="ln2521">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_darkroom_ui_preview2_pipe_finish_signal_callback),</a>
<a name="ln2522">                               (gpointer)self);</a>
<a name="ln2523"> </a>
<a name="ln2524">  // store groups for next time:</a>
<a name="ln2525">  dt_conf_set_int(&quot;plugins/darkroom/groups&quot;, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln2526"> </a>
<a name="ln2527">  // store last active plugin:</a>
<a name="ln2528">  if(darktable.develop-&gt;gui_module)</a>
<a name="ln2529">    dt_conf_set_string(&quot;plugins/darkroom/active&quot;, darktable.develop-&gt;gui_module-&gt;op);</a>
<a name="ln2530">  else</a>
<a name="ln2531">    dt_conf_set_string(&quot;plugins/darkroom/active&quot;, &quot;&quot;);</a>
<a name="ln2532"> </a>
<a name="ln2533">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2534"> </a>
<a name="ln2535">  // commit image ops to db</a>
<a name="ln2536">  dt_dev_write_history(dev);</a>
<a name="ln2537"> </a>
<a name="ln2538">  // update aspect ratio</a>
<a name="ln2539">  if(dev-&gt;preview_pipe-&gt;backbuf &amp;&amp; dev-&gt;preview_status == DT_DEV_PIXELPIPE_VALID)</a>
<a name="ln2540">  {</a>
<a name="ln2541">    double aspect_ratio = (double)dev-&gt;preview_pipe-&gt;backbuf_width / (double)dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln2542">    dt_image_set_aspect_ratio_to(dev-&gt;preview_pipe-&gt;image.id, aspect_ratio);</a>
<a name="ln2543">  }</a>
<a name="ln2544">  else</a>
<a name="ln2545">  {</a>
<a name="ln2546">    dt_image_set_aspect_ratio(dev-&gt;image_storage.id);</a>
<a name="ln2547">  }</a>
<a name="ln2548"> </a>
<a name="ln2549">  // be sure light table will regenerate the thumbnail:</a>
<a name="ln2550">  // TODO: only if changed!</a>
<a name="ln2551">  // if()</a>
<a name="ln2552">  {</a>
<a name="ln2553">    dt_mipmap_cache_remove(darktable.mipmap_cache, dev-&gt;image_storage.id);</a>
<a name="ln2554">    dt_image_reset_final_size(dev-&gt;image_storage.id);</a>
<a name="ln2555">    // dump new xmp data</a>
<a name="ln2556">    dt_image_synch_xmp(dev-&gt;image_storage.id);</a>
<a name="ln2557">  }</a>
<a name="ln2558"> </a>
<a name="ln2559">  // clear gui.</a>
<a name="ln2560"> </a>
<a name="ln2561">  dt_pthread_mutex_lock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln2562">  dt_pthread_mutex_lock(&amp;dev-&gt;preview2_pipe_mutex);</a>
<a name="ln2563">  dt_pthread_mutex_lock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln2564"> </a>
<a name="ln2565">  dev-&gt;gui_leaving = 1;</a>
<a name="ln2566"> </a>
<a name="ln2567">  dt_dev_pixelpipe_cleanup_nodes(dev-&gt;pipe);</a>
<a name="ln2568">  dt_dev_pixelpipe_cleanup_nodes(dev-&gt;preview2_pipe);</a>
<a name="ln2569">  dt_dev_pixelpipe_cleanup_nodes(dev-&gt;preview_pipe);</a>
<a name="ln2570"> </a>
<a name="ln2571">  dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln2572">  while(dev-&gt;history)</a>
<a name="ln2573">  {</a>
<a name="ln2574">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(dev-&gt;history-&gt;data);</a>
<a name="ln2575">    // printf(&quot;removing history item %d - %s, data %f %f\n&quot;, hist-&gt;module-&gt;instance, hist-&gt;module-&gt;op, *(float</a>
<a name="ln2576">    // *)hist-&gt;params, *((float *)hist-&gt;params+1));</a>
<a name="ln2577">    dt_dev_free_history_item(hist);</a>
<a name="ln2578">    dev-&gt;history = g_list_delete_link(dev-&gt;history, dev-&gt;history);</a>
<a name="ln2579">  }</a>
<a name="ln2580"> </a>
<a name="ln2581">  while(dev-&gt;iop)</a>
<a name="ln2582">  {</a>
<a name="ln2583">    dt_iop_module_t *module = (dt_iop_module_t *)(dev-&gt;iop-&gt;data);</a>
<a name="ln2584">    if(!dt_iop_is_hidden(module)) dt_iop_gui_cleanup_module(module);</a>
<a name="ln2585"> </a>
<a name="ln2586">    dt_dev_cleanup_module_accels(module);</a>
<a name="ln2587">    module-&gt;accel_closures = NULL;</a>
<a name="ln2588">    dt_iop_cleanup_module(module);</a>
<a name="ln2589">    free(module);</a>
<a name="ln2590">    dev-&gt;iop = g_list_delete_link(dev-&gt;iop, dev-&gt;iop);</a>
<a name="ln2591">  }</a>
<a name="ln2592">  while(dev-&gt;alliop)</a>
<a name="ln2593">  {</a>
<a name="ln2594">    dt_iop_cleanup_module((dt_iop_module_t *)dev-&gt;alliop-&gt;data);</a>
<a name="ln2595">    free(dev-&gt;alliop-&gt;data);</a>
<a name="ln2596">    dev-&gt;alliop = g_list_delete_link(dev-&gt;alliop, dev-&gt;alliop);</a>
<a name="ln2597">  }</a>
<a name="ln2598"> </a>
<a name="ln2599">  dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln2600"> </a>
<a name="ln2601">  dt_pthread_mutex_unlock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln2602">  dt_pthread_mutex_unlock(&amp;dev-&gt;preview2_pipe_mutex);</a>
<a name="ln2603">  dt_pthread_mutex_unlock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln2604"> </a>
<a name="ln2605">  // cleanup visible masks</a>
<a name="ln2606">  if(dev-&gt;form_gui)</a>
<a name="ln2607">  {</a>
<a name="ln2608">    dev-&gt;gui_module = NULL; // modules have already been free()</a>
<a name="ln2609">    dt_masks_clear_form_gui(dev);</a>
<a name="ln2610">    free(dev-&gt;form_gui);</a>
<a name="ln2611">    dev-&gt;form_gui = NULL;</a>
<a name="ln2612">    dt_masks_change_form_gui(NULL);</a>
<a name="ln2613">  }</a>
<a name="ln2614">  // clear masks</a>
<a name="ln2615">  g_list_free_full(dev-&gt;forms, (void (*)(void *))dt_masks_free_form);</a>
<a name="ln2616">  dev-&gt;forms = NULL;</a>
<a name="ln2617">  g_list_free_full(dev-&gt;allforms, (void (*)(void *))dt_masks_free_form);</a>
<a name="ln2618">  dev-&gt;allforms = NULL;</a>
<a name="ln2619"> </a>
<a name="ln2620">  // take care of the overexposed window</a>
<a name="ln2621">  if(dev-&gt;overexposed.timeout &gt; 0) g_source_remove(dev-&gt;overexposed.timeout);</a>
<a name="ln2622">  gtk_widget_hide(dev-&gt;overexposed.floating_window);</a>
<a name="ln2623">  gtk_widget_hide(dev-&gt;profile.floating_window);</a>
<a name="ln2624"> </a>
<a name="ln2625">  dt_ui_scrollbars_show(darktable.gui-&gt;ui, FALSE);</a>
<a name="ln2626"> </a>
<a name="ln2627">  darktable.develop-&gt;image_storage.id = -1;</a>
<a name="ln2628">  // darkroom development could have changed a collection, so update that before being back in lightroom </a>
<a name="ln2629">  dt_collection_update_query(darktable.collection);</a>
<a name="ln2630">  dt_print(DT_DEBUG_CONTROL, &quot;[run_job-] 11 %f in darkroom mode\n&quot;, dt_get_wtime());</a>
<a name="ln2631">}</a>
<a name="ln2632"> </a>
<a name="ln2633">void mouse_leave(dt_view_t *self)</a>
<a name="ln2634">{</a>
<a name="ln2635">  // if we are not hovering over a thumbnail in the filmstrip -&gt; show metadata of opened image.</a>
<a name="ln2636">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2637">  dt_control_set_mouse_over_id(dev-&gt;image_storage.id);</a>
<a name="ln2638"> </a>
<a name="ln2639">  // masks</a>
<a name="ln2640">  int handled = dt_masks_events_mouse_leave(dev-&gt;gui_module);</a>
<a name="ln2641">  if(handled) return;</a>
<a name="ln2642">  // module</a>
<a name="ln2643">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;mouse_leave)</a>
<a name="ln2644">    handled = dev-&gt;gui_module-&gt;mouse_leave(dev-&gt;gui_module);</a>
<a name="ln2645"> </a>
<a name="ln2646">  // reset any changes the selected plugin might have made.</a>
<a name="ln2647">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln2648">}</a>
<a name="ln2649"> </a>
<a name="ln2650">void mouse_enter(dt_view_t *self)</a>
<a name="ln2651">{</a>
<a name="ln2652">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2653">  // masks</a>
<a name="ln2654">  dt_masks_events_mouse_enter(dev-&gt;gui_module);</a>
<a name="ln2655">}</a>
<a name="ln2656"> </a>
<a name="ln2657">void mouse_moved(dt_view_t *self, double x, double y, double pressure, int which)</a>
<a name="ln2658">{</a>
<a name="ln2659">  const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln2660">  const int32_t capwd = self-&gt;width  - 2*tb;</a>
<a name="ln2661">  const int32_t capht = self-&gt;height - 2*tb;</a>
<a name="ln2662">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2663"> </a>
<a name="ln2664">  // if we are not hovering over a thumbnail in the filmstrip -&gt; show metadata of opened image.</a>
<a name="ln2665">  int32_t mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln2666">  if(mouse_over_id == -1)</a>
<a name="ln2667">  {</a>
<a name="ln2668">    mouse_over_id = dev-&gt;image_storage.id;</a>
<a name="ln2669">    dt_control_set_mouse_over_id(mouse_over_id);</a>
<a name="ln2670">  }</a>
<a name="ln2671"> </a>
<a name="ln2672">  dt_control_t *ctl = darktable.control;</a>
<a name="ln2673">  const int32_t width_i = self-&gt;width;</a>
<a name="ln2674">  const int32_t height_i = self-&gt;height;</a>
<a name="ln2675">  int32_t offx = 0.0f, offy = 0.0f;</a>
<a name="ln2676">  if(width_i &gt; capwd) offx = (capwd - width_i) * .5f;</a>
<a name="ln2677">  if(height_i &gt; capht) offy = (capht - height_i) * .5f;</a>
<a name="ln2678">  int handled = 0;</a>
<a name="ln2679">  x += offx;</a>
<a name="ln2680">  y += offy;</a>
<a name="ln2681"> </a>
<a name="ln2682">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF &amp;&amp; ctl-&gt;button_down</a>
<a name="ln2683">     &amp;&amp; ctl-&gt;button_down_which == 1)</a>
<a name="ln2684">  {</a>
<a name="ln2685">    // module requested a color box</a>
<a name="ln2686">    float zoom_x, zoom_y, bzoom_x, bzoom_y;</a>
<a name="ln2687">    dt_dev_get_pointer_zoom_pos(dev, x, y, &amp;zoom_x, &amp;zoom_y);</a>
<a name="ln2688">    dt_dev_get_pointer_zoom_pos(dev, ctl-&gt;button_x + offx, ctl-&gt;button_y + offy, &amp;bzoom_x, &amp;bzoom_y);</a>
<a name="ln2689">    if(darktable.lib-&gt;proxy.colorpicker.size)</a>
<a name="ln2690">    {</a>
<a name="ln2691">      dev-&gt;gui_module-&gt;color_picker_box[0] = fmaxf(0.0, fminf(.5f + bzoom_x, .5f + zoom_x));</a>
<a name="ln2692">      dev-&gt;gui_module-&gt;color_picker_box[1] = fmaxf(0.0, fminf(.5f + bzoom_y, .5f + zoom_y));</a>
<a name="ln2693">      dev-&gt;gui_module-&gt;color_picker_box[2] = fminf(1.0, fmaxf(.5f + bzoom_x, .5f + zoom_x));</a>
<a name="ln2694">      dev-&gt;gui_module-&gt;color_picker_box[3] = fminf(1.0, fmaxf(.5f + bzoom_y, .5f + zoom_y));</a>
<a name="ln2695">    }</a>
<a name="ln2696">    else</a>
<a name="ln2697">    {</a>
<a name="ln2698">      dev-&gt;gui_module-&gt;color_picker_point[0] = .5f + zoom_x;</a>
<a name="ln2699">      dev-&gt;gui_module-&gt;color_picker_point[1] = .5f + zoom_y;</a>
<a name="ln2700"> </a>
<a name="ln2701">      dev-&gt;preview_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln2702">    }</a>
<a name="ln2703"> </a>
<a name="ln2704">    dt_control_queue_redraw();</a>
<a name="ln2705">    return;</a>
<a name="ln2706">  }</a>
<a name="ln2707">  // masks</a>
<a name="ln2708">  handled = dt_masks_events_mouse_moved(dev-&gt;gui_module, x, y, pressure, which);</a>
<a name="ln2709">  if(handled) return;</a>
<a name="ln2710">  // module</a>
<a name="ln2711">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;mouse_moved)</a>
<a name="ln2712">    handled = dev-&gt;gui_module-&gt;mouse_moved(dev-&gt;gui_module, x, y, pressure, which);</a>
<a name="ln2713">  if(handled) return;</a>
<a name="ln2714"> </a>
<a name="ln2715">  if(darktable.control-&gt;button_down &amp;&amp; darktable.control-&gt;button_down_which == 1)</a>
<a name="ln2716">  {</a>
<a name="ln2717">    // depending on dev_zoom, adjust dev_zoom_x/y.</a>
<a name="ln2718">    const dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln2719">    const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln2720">    int procw, proch;</a>
<a name="ln2721">    dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln2722">    const float scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln2723">    float old_zoom_x, old_zoom_y;</a>
<a name="ln2724">    old_zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln2725">    old_zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln2726">    float zx = old_zoom_x - (1.0 / scale) * (x - ctl-&gt;button_x - offx) / procw;</a>
<a name="ln2727">    float zy = old_zoom_y - (1.0 / scale) * (y - ctl-&gt;button_y - offy) / proch;</a>
<a name="ln2728">    dt_dev_check_zoom_bounds(dev, &amp;zx, &amp;zy, zoom, closeup, NULL, NULL);</a>
<a name="ln2729">    dt_control_set_dev_zoom_x(zx);</a>
<a name="ln2730">    dt_control_set_dev_zoom_y(zy);</a>
<a name="ln2731">    ctl-&gt;button_x = x - offx;</a>
<a name="ln2732">    ctl-&gt;button_y = y - offy;</a>
<a name="ln2733">    dt_dev_invalidate(dev);</a>
<a name="ln2734">    dt_control_queue_redraw_center();</a>
<a name="ln2735">    dt_control_navigation_redraw();</a>
<a name="ln2736">  }</a>
<a name="ln2737">}</a>
<a name="ln2738"> </a>
<a name="ln2739"> </a>
<a name="ln2740">int button_released(dt_view_t *self, double x, double y, int which, uint32_t state)</a>
<a name="ln2741">{</a>
<a name="ln2742">  const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln2743">  const int32_t capwd = self-&gt;width  - 2*tb;</a>
<a name="ln2744">  const int32_t capht = self-&gt;height - 2*tb;</a>
<a name="ln2745">  dt_develop_t *dev = darktable.develop;</a>
<a name="ln2746">  const int32_t width_i = self-&gt;width;</a>
<a name="ln2747">  const int32_t height_i = self-&gt;height;</a>
<a name="ln2748">  if(width_i &gt; capwd) x += (capwd - width_i) * .5f;</a>
<a name="ln2749">  if(height_i &gt; capht) y += (capht - height_i) * .5f;</a>
<a name="ln2750"> </a>
<a name="ln2751">  int handled = 0;</a>
<a name="ln2752">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF &amp;&amp; which == 1)</a>
<a name="ln2753">  {</a>
<a name="ln2754">    dev-&gt;preview_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln2755">    dt_control_queue_redraw();</a>
<a name="ln2756">    return 1;</a>
<a name="ln2757">  }</a>
<a name="ln2758">  // masks</a>
<a name="ln2759">  if(dev-&gt;form_visible) handled = dt_masks_events_button_released(dev-&gt;gui_module, x, y, which, state);</a>
<a name="ln2760">  if(handled) return handled;</a>
<a name="ln2761">  // module</a>
<a name="ln2762">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;button_released)</a>
<a name="ln2763">    handled = dev-&gt;gui_module-&gt;button_released(dev-&gt;gui_module, x, y, which, state);</a>
<a name="ln2764">  if(handled) return handled;</a>
<a name="ln2765">  if(which == 1) dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln2766">  return 1;</a>
<a name="ln2767">}</a>
<a name="ln2768"> </a>
<a name="ln2769"> </a>
<a name="ln2770">int button_pressed(dt_view_t *self, double x, double y, double pressure, int which, int type, uint32_t state)</a>
<a name="ln2771">{</a>
<a name="ln2772">  const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln2773">  const int32_t capwd = self-&gt;width  - 2*tb;</a>
<a name="ln2774">  const int32_t capht = self-&gt;height - 2*tb;</a>
<a name="ln2775">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2776">  const int32_t width_i = self-&gt;width;</a>
<a name="ln2777">  const int32_t height_i = self-&gt;height;</a>
<a name="ln2778">  if(width_i &gt; capwd) x += (capwd - width_i) * .5f;</a>
<a name="ln2779">  if(height_i &gt; capht) y += (capht - height_i) * .5f;</a>
<a name="ln2780"> </a>
<a name="ln2781">  int handled = 0;</a>
<a name="ln2782">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF &amp;&amp; which == 1)</a>
<a name="ln2783">  {</a>
<a name="ln2784">    float zoom_x, zoom_y;</a>
<a name="ln2785">    dt_dev_get_pointer_zoom_pos(dev, x, y, &amp;zoom_x, &amp;zoom_y);</a>
<a name="ln2786">    if(darktable.lib-&gt;proxy.colorpicker.size)</a>
<a name="ln2787">    {</a>
<a name="ln2788">      dev-&gt;gui_module-&gt;color_picker_box[0] = .5f + zoom_x;</a>
<a name="ln2789">      dev-&gt;gui_module-&gt;color_picker_box[1] = .5f + zoom_y;</a>
<a name="ln2790">      dev-&gt;gui_module-&gt;color_picker_box[2] = .5f + zoom_x;</a>
<a name="ln2791">      dev-&gt;gui_module-&gt;color_picker_box[3] = .5f + zoom_y;</a>
<a name="ln2792">    }</a>
<a name="ln2793">    else</a>
<a name="ln2794">    {</a>
<a name="ln2795">      dev-&gt;gui_module-&gt;color_picker_point[0] = .5f + zoom_x;</a>
<a name="ln2796">      dev-&gt;gui_module-&gt;color_picker_point[1] = .5f + zoom_y;</a>
<a name="ln2797"> </a>
<a name="ln2798">      dev-&gt;preview_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln2799">    }</a>
<a name="ln2800"> </a>
<a name="ln2801">    dt_control_queue_redraw();</a>
<a name="ln2802"> </a>
<a name="ln2803">    return 1;</a>
<a name="ln2804">  }</a>
<a name="ln2805">  // masks</a>
<a name="ln2806">  if(dev-&gt;form_visible)</a>
<a name="ln2807">    handled = dt_masks_events_button_pressed(dev-&gt;gui_module, x, y, pressure, which, type, state);</a>
<a name="ln2808">  if(handled) return handled;</a>
<a name="ln2809">  // module</a>
<a name="ln2810">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;button_pressed)</a>
<a name="ln2811">    handled = dev-&gt;gui_module-&gt;button_pressed(dev-&gt;gui_module, x, y, pressure, which, type, state);</a>
<a name="ln2812">  if(handled) return handled;</a>
<a name="ln2813"> </a>
<a name="ln2814">  if(which == 1 &amp;&amp; type == GDK_2BUTTON_PRESS) return 0;</a>
<a name="ln2815">  if(which == 1)</a>
<a name="ln2816">  {</a>
<a name="ln2817">    dt_control_change_cursor(GDK_HAND1);</a>
<a name="ln2818">    return 1;</a>
<a name="ln2819">  }</a>
<a name="ln2820">  if(which == 2)</a>
<a name="ln2821">  {</a>
<a name="ln2822">    // zoom to 1:1 2:1 and back</a>
<a name="ln2823">    dt_dev_zoom_t zoom;</a>
<a name="ln2824">    int closeup, procw, proch;</a>
<a name="ln2825">    float zoom_x, zoom_y;</a>
<a name="ln2826">    zoom = dt_control_get_dev_zoom();</a>
<a name="ln2827">    closeup = dt_control_get_dev_closeup();</a>
<a name="ln2828">    zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln2829">    zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln2830">    dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln2831">    const float scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln2832">    zoom_x += (1.0 / scale) * (x - .5f * dev-&gt;width) / procw;</a>
<a name="ln2833">    zoom_y += (1.0 / scale) * (y - .5f * dev-&gt;height) / proch;</a>
<a name="ln2834">    if(zoom == DT_ZOOM_1)</a>
<a name="ln2835">    {</a>
<a name="ln2836">      if(!closeup)</a>
<a name="ln2837">        closeup = 1;</a>
<a name="ln2838">      else</a>
<a name="ln2839">      {</a>
<a name="ln2840">        zoom = DT_ZOOM_FIT;</a>
<a name="ln2841">        zoom_x = zoom_y = 0.0f;</a>
<a name="ln2842">        closeup = 0;</a>
<a name="ln2843">      }</a>
<a name="ln2844">    }</a>
<a name="ln2845">    else</a>
<a name="ln2846">      zoom = DT_ZOOM_1;</a>
<a name="ln2847">    dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, zoom, closeup, NULL, NULL);</a>
<a name="ln2848">    dt_control_set_dev_zoom(zoom);</a>
<a name="ln2849">    dt_control_set_dev_closeup(closeup);</a>
<a name="ln2850">    dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln2851">    dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln2852">    dt_dev_invalidate(dev);</a>
<a name="ln2853">    dt_control_queue_redraw_center();</a>
<a name="ln2854">    dt_control_navigation_redraw();</a>
<a name="ln2855">    return 1;</a>
<a name="ln2856">  }</a>
<a name="ln2857">  return 0;</a>
<a name="ln2858">}</a>
<a name="ln2859"> </a>
<a name="ln2860">void scrollbar_changed(dt_view_t *self, double x, double y)</a>
<a name="ln2861">{</a>
<a name="ln2862">  dt_control_set_dev_zoom_x(x);</a>
<a name="ln2863">  dt_control_set_dev_zoom_y(y);</a>
<a name="ln2864"> </a>
<a name="ln2865">  /* redraw pipe */</a>
<a name="ln2866">  dt_dev_invalidate(darktable.develop);</a>
<a name="ln2867">  dt_control_queue_redraw_center();</a>
<a name="ln2868">  dt_control_navigation_redraw();</a>
<a name="ln2869">}</a>
<a name="ln2870"> </a>
<a name="ln2871">void scrolled(dt_view_t *self, double x, double y, int up, int state)</a>
<a name="ln2872">{</a>
<a name="ln2873">  const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln2874">  const int32_t capwd = self-&gt;width  - 2*tb;</a>
<a name="ln2875">  const int32_t capht = self-&gt;height - 2*tb;</a>
<a name="ln2876">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2877">  const int32_t width_i = self-&gt;width;</a>
<a name="ln2878">  const int32_t height_i = self-&gt;height;</a>
<a name="ln2879">  if(width_i &gt; capwd) x += (capwd - width_i) * .5f;</a>
<a name="ln2880">  if(height_i &gt; capht) y += (capht - height_i) * .5f;</a>
<a name="ln2881"> </a>
<a name="ln2882">  int handled = 0;</a>
<a name="ln2883">  // dynamic accels</a>
<a name="ln2884">  if(self-&gt;dynamic_accel_current &amp;&amp; self-&gt;dynamic_accel_current-&gt;widget)</a>
<a name="ln2885">  {</a>
<a name="ln2886">    gtk_widget_grab_focus(self-&gt;dynamic_accel_current-&gt;widget);</a>
<a name="ln2887">    float value = dt_bauhaus_slider_get(self-&gt;dynamic_accel_current-&gt;widget);</a>
<a name="ln2888">    float step = dt_bauhaus_slider_get_step(self-&gt;dynamic_accel_current-&gt;widget);</a>
<a name="ln2889"> </a>
<a name="ln2890">    if(up)</a>
<a name="ln2891">      dt_bauhaus_slider_set(self-&gt;dynamic_accel_current-&gt;widget, value + step);</a>
<a name="ln2892">    else</a>
<a name="ln2893">      dt_bauhaus_slider_set(self-&gt;dynamic_accel_current-&gt;widget, value - step);</a>
<a name="ln2894">    g_signal_emit_by_name(G_OBJECT(self-&gt;dynamic_accel_current-&gt;widget), &quot;value-changed&quot;);</a>
<a name="ln2895">    return;</a>
<a name="ln2896">  }</a>
<a name="ln2897">  // masks</a>
<a name="ln2898">  if(dev-&gt;form_visible) handled = dt_masks_events_mouse_scrolled(dev-&gt;gui_module, x, y, up, state);</a>
<a name="ln2899">  if(handled) return;</a>
<a name="ln2900">  // module</a>
<a name="ln2901">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;scrolled)</a>
<a name="ln2902">    handled = dev-&gt;gui_module-&gt;scrolled(dev-&gt;gui_module, x, y, up, state);</a>
<a name="ln2903">  if(handled) return;</a>
<a name="ln2904">  // free zoom</a>
<a name="ln2905">  dt_dev_zoom_t zoom;</a>
<a name="ln2906">  int closeup, procw, proch;</a>
<a name="ln2907">  float zoom_x, zoom_y;</a>
<a name="ln2908">  zoom = dt_control_get_dev_zoom();</a>
<a name="ln2909">  closeup = dt_control_get_dev_closeup();</a>
<a name="ln2910">  zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln2911">  zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln2912">  dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln2913">  float scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln2914">  const float fitscale = dt_dev_get_zoom_scale(dev, DT_ZOOM_FIT, 1.0, 0);</a>
<a name="ln2915">  float oldscale = scale;</a>
<a name="ln2916"> </a>
<a name="ln2917">  // offset from center now (current zoom_{x,y} points there)</a>
<a name="ln2918">  float mouse_off_x = x - .5 * dev-&gt;width, mouse_off_y = y - .5 * dev-&gt;height;</a>
<a name="ln2919">  zoom_x += mouse_off_x / (procw * scale);</a>
<a name="ln2920">  zoom_y += mouse_off_y / (proch * scale);</a>
<a name="ln2921">  zoom = DT_ZOOM_FREE;</a>
<a name="ln2922">  closeup = 0;</a>
<a name="ln2923">  if(up)</a>
<a name="ln2924">  {</a>
<a name="ln2925">    if((scale == 1.0f || scale == 2.0f) &amp;&amp; !((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK)) return;</a>
<a name="ln2926">    if(scale &gt;= 16.0f)</a>
<a name="ln2927">      return;</a>
<a name="ln2928">    else if(scale &gt;= 8.0f)</a>
<a name="ln2929">      scale = 16.0;</a>
<a name="ln2930">    else if(scale &gt;= 4.0f)</a>
<a name="ln2931">      scale = 8.0;</a>
<a name="ln2932">    else if(scale &gt;= 2.0f)</a>
<a name="ln2933">      scale = 4.0;</a>
<a name="ln2934">    else if(scale &lt; fitscale)</a>
<a name="ln2935">      scale += .05f * (1.0f - fitscale);</a>
<a name="ln2936">    else</a>
<a name="ln2937">      scale += .1f * (1.0f - fitscale);</a>
<a name="ln2938">  }</a>
<a name="ln2939">  else</a>
<a name="ln2940">  {</a>
<a name="ln2941">    if(scale == fitscale &amp;&amp; !((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK))</a>
<a name="ln2942">      return;</a>
<a name="ln2943">    else if(scale &lt; 0.5 * fitscale)</a>
<a name="ln2944">      return;</a>
<a name="ln2945">    else if(scale &lt;= fitscale)</a>
<a name="ln2946">      scale -= .05f * (1.0f - fitscale);</a>
<a name="ln2947">    else if(scale &lt;= 2.0f)</a>
<a name="ln2948">      scale -= .1f * (1.0f - fitscale);</a>
<a name="ln2949">    else if(scale &lt;= 4.0f)</a>
<a name="ln2950">      scale = 2.0f;</a>
<a name="ln2951">    else if(scale &lt;= 8.0f)</a>
<a name="ln2952">      scale = 4.0f;</a>
<a name="ln2953">    else</a>
<a name="ln2954">      scale = 8.0f;</a>
<a name="ln2955">  }</a>
<a name="ln2956">  // we want to be sure to stop at 1:1 and FIT levels</a>
<a name="ln2957">  if((scale - 1.0) * (oldscale - 1.0) &lt; 0) scale = 1.0f;</a>
<a name="ln2958">  if((scale - fitscale) * (oldscale - fitscale) &lt; 0) scale = fitscale;</a>
<a name="ln2959">  scale = fmaxf(fminf(scale, 16.0f), 0.5 * fitscale);</a>
<a name="ln2960"> </a>
<a name="ln2961">  // for 200% zoom we want pixel doubling instead of interpolation</a>
<a name="ln2962">  if(scale &gt; 15.9999f)</a>
<a name="ln2963">  {</a>
<a name="ln2964">    scale = 1.0f; // don't interpolate</a>
<a name="ln2965">    closeup = 4;  // enable closeup mode (pixel doubling)</a>
<a name="ln2966">  }</a>
<a name="ln2967">  else if(scale &gt; 7.9999f)</a>
<a name="ln2968">  {</a>
<a name="ln2969">    scale = 1.0f; // don't interpolate</a>
<a name="ln2970">    closeup = 3;  // enable closeup mode (pixel doubling)</a>
<a name="ln2971">  }</a>
<a name="ln2972">  else if(scale &gt; 3.9999f)</a>
<a name="ln2973">  {</a>
<a name="ln2974">    scale = 1.0f; // don't interpolate</a>
<a name="ln2975">    closeup = 2;  // enable closeup mode (pixel doubling)</a>
<a name="ln2976">  }</a>
<a name="ln2977">  else if(scale &gt; 1.9999f)</a>
<a name="ln2978">  {</a>
<a name="ln2979">    scale = 1.0f; // don't interpolate</a>
<a name="ln2980">    closeup = 1;  // enable closeup mode (pixel doubling)</a>
<a name="ln2981">  }</a>
<a name="ln2982"> </a>
<a name="ln2983">  if(fabsf(scale - 1.0f) &lt; 0.001f) zoom = DT_ZOOM_1;</a>
<a name="ln2984">  if(fabsf(scale - fitscale) &lt; 0.001f) zoom = DT_ZOOM_FIT;</a>
<a name="ln2985">  dt_control_set_dev_zoom_scale(scale);</a>
<a name="ln2986">  dt_control_set_dev_closeup(closeup);</a>
<a name="ln2987">  scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln2988"> </a>
<a name="ln2989">  zoom_x -= mouse_off_x / (procw * scale);</a>
<a name="ln2990">  zoom_y -= mouse_off_y / (proch * scale);</a>
<a name="ln2991">  dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, zoom, closeup, NULL, NULL);</a>
<a name="ln2992">  dt_control_set_dev_zoom(zoom);</a>
<a name="ln2993">  dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln2994">  dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln2995">  dt_dev_invalidate(dev);</a>
<a name="ln2996">  dt_control_queue_redraw_center();</a>
<a name="ln2997">  dt_control_navigation_redraw();</a>
<a name="ln2998">}</a>
<a name="ln2999"> </a>
<a name="ln3000">int key_released(dt_view_t *self, guint key, guint state)</a>
<a name="ln3001">{</a>
<a name="ln3002">  const dt_control_accels_t *accels = &amp;darktable.control-&gt;accels;</a>
<a name="ln3003">  dt_develop_t *lib = (dt_develop_t *)self-&gt;data;</a>
<a name="ln3004"> </a>
<a name="ln3005">  if(!darktable.control-&gt;key_accelerators_on)</a>
<a name="ln3006">    return 0;</a>
<a name="ln3007"> </a>
<a name="ln3008">  if(key == accels-&gt;darkroom_preview.accel_key &amp;&amp; state == accels-&gt;darkroom_preview.accel_mods &amp;&amp; lib-&gt;full_preview)</a>
<a name="ln3009">  {</a>
<a name="ln3010">    dt_ui_restore_panels(darktable.gui-&gt;ui);</a>
<a name="ln3011">    dt_control_set_dev_zoom(lib-&gt;full_preview_last_zoom);</a>
<a name="ln3012">    dt_control_set_dev_zoom_x(lib-&gt;full_preview_last_zoom_x);</a>
<a name="ln3013">    dt_control_set_dev_zoom_y(lib-&gt;full_preview_last_zoom_y);</a>
<a name="ln3014">    dt_control_set_dev_closeup(lib-&gt;full_preview_last_closeup);</a>
<a name="ln3015">    lib-&gt;full_preview = FALSE;</a>
<a name="ln3016">    dt_iop_request_focus(lib-&gt;full_preview_last_module);</a>
<a name="ln3017">    dt_masks_set_edit_mode(darktable.develop-&gt;gui_module, lib-&gt;full_preview_masks_state);</a>
<a name="ln3018">    dt_dev_invalidate(darktable.develop);</a>
<a name="ln3019">    dt_control_queue_redraw_center();</a>
<a name="ln3020">    dt_control_navigation_redraw();</a>
<a name="ln3021">  }</a>
<a name="ln3022">  // add an option to allow skip mouse events while editing masks</a>
<a name="ln3023">  if(key == accels-&gt;darkroom_skip_mouse_events.accel_key &amp;&amp; state == accels-&gt;darkroom_skip_mouse_events.accel_mods)</a>
<a name="ln3024">  {</a>
<a name="ln3025">    darktable.develop-&gt;darkroom_skip_mouse_events = FALSE;</a>
<a name="ln3026">  }</a>
<a name="ln3027"> </a>
<a name="ln3028">  return 1;</a>
<a name="ln3029">}</a>
<a name="ln3030"> </a>
<a name="ln3031">int key_pressed(dt_view_t *self, guint key, guint state)</a>
<a name="ln3032">{</a>
<a name="ln3033">  const dt_control_accels_t *accels = &amp;darktable.control-&gt;accels;</a>
<a name="ln3034">  dt_develop_t *lib = (dt_develop_t *)self-&gt;data;</a>
<a name="ln3035"> </a>
<a name="ln3036">  if(!darktable.control-&gt;key_accelerators_on)</a>
<a name="ln3037">    return 0;</a>
<a name="ln3038"> </a>
<a name="ln3039">  if(key == accels-&gt;darkroom_preview.accel_key &amp;&amp; state == accels-&gt;darkroom_preview.accel_mods)</a>
<a name="ln3040">  {</a>
<a name="ln3041">    if(!lib-&gt;full_preview)</a>
<a name="ln3042">    {</a>
<a name="ln3043">      lib-&gt;full_preview = TRUE;</a>
<a name="ln3044">      // we hide all panels</a>
<a name="ln3045">      for(int k = 0; k &lt; DT_UI_PANEL_SIZE; k++)</a>
<a name="ln3046">        dt_ui_panel_show(darktable.gui-&gt;ui, k, FALSE, FALSE);</a>
<a name="ln3047">      // we remember the masks edit state</a>
<a name="ln3048">      if(darktable.develop-&gt;gui_module)</a>
<a name="ln3049">      {</a>
<a name="ln3050">        dt_iop_gui_blend_data_t *bd = (dt_iop_gui_blend_data_t *)darktable.develop-&gt;gui_module-&gt;blend_data;</a>
<a name="ln3051">        if (bd) lib-&gt;full_preview_masks_state = bd-&gt;masks_shown;</a>
<a name="ln3052">      }</a>
<a name="ln3053">      // we set the zoom values to &quot;fit&quot;</a>
<a name="ln3054">      lib-&gt;full_preview_last_zoom = dt_control_get_dev_zoom();</a>
<a name="ln3055">      lib-&gt;full_preview_last_zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln3056">      lib-&gt;full_preview_last_zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln3057">      lib-&gt;full_preview_last_closeup = dt_control_get_dev_closeup();</a>
<a name="ln3058">      dt_control_set_dev_zoom(DT_ZOOM_FIT);</a>
<a name="ln3059">      dt_control_set_dev_zoom_x(0);</a>
<a name="ln3060">      dt_control_set_dev_zoom_y(0);</a>
<a name="ln3061">      dt_control_set_dev_closeup(0);</a>
<a name="ln3062">      // we quit the active iop if any</a>
<a name="ln3063">      lib-&gt;full_preview_last_module = darktable.develop-&gt;gui_module;</a>
<a name="ln3064">      dt_iop_request_focus(NULL);</a>
<a name="ln3065">      dt_dev_invalidate(darktable.develop);</a>
<a name="ln3066">      dt_control_queue_redraw_center();</a>
<a name="ln3067">    }</a>
<a name="ln3068">    else</a>
<a name="ln3069">      return 0;</a>
<a name="ln3070">  }</a>
<a name="ln3071"> </a>
<a name="ln3072">  if(key == accels-&gt;global_zoom_in.accel_key &amp;&amp; state == accels-&gt;global_zoom_in.accel_mods)</a>
<a name="ln3073">  {</a>
<a name="ln3074">    dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln3075"> </a>
<a name="ln3076">    scrolled(self, dev-&gt;width / 2, dev-&gt;height / 2, 1, state);</a>
<a name="ln3077">    return 1;</a>
<a name="ln3078">  }</a>
<a name="ln3079"> </a>
<a name="ln3080">  if(key == accels-&gt;global_zoom_out.accel_key &amp;&amp; state == accels-&gt;global_zoom_out.accel_mods)</a>
<a name="ln3081">  {</a>
<a name="ln3082">    dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln3083"> </a>
<a name="ln3084">    scrolled(self, dev-&gt;width / 2, dev-&gt;height / 2, 0, state);</a>
<a name="ln3085">    return 1;</a>
<a name="ln3086">  }</a>
<a name="ln3087"> </a>
<a name="ln3088">  if(key == GDK_KEY_Left || key == GDK_KEY_Right || key == GDK_KEY_Up || key == GDK_KEY_Down)</a>
<a name="ln3089">  {</a>
<a name="ln3090">    dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln3091">    dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln3092">    const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln3093">    float scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln3094">    int procw, proch;</a>
<a name="ln3095">    dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln3096"> </a>
<a name="ln3097">    GdkModifierType modifiers;</a>
<a name="ln3098">    modifiers = gtk_accelerator_get_default_mod_mask();</a>
<a name="ln3099"> </a>
<a name="ln3100">    // For each cursor press, move one screen by default</a>
<a name="ln3101">    float step_changex = dev-&gt;width / (procw * scale);</a>
<a name="ln3102">    float step_changey = dev-&gt;height / (proch * scale);</a>
<a name="ln3103">    float factor = 0.2f;</a>
<a name="ln3104"> </a>
<a name="ln3105">    if((state &amp; modifiers) == GDK_MOD1_MASK) factor = 0.02f;</a>
<a name="ln3106">    if((state &amp; modifiers) == GDK_CONTROL_MASK) factor = 1.0f;</a>
<a name="ln3107"> </a>
<a name="ln3108">    float old_zoom_x, old_zoom_y;</a>
<a name="ln3109"> </a>
<a name="ln3110">    old_zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln3111">    old_zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln3112"> </a>
<a name="ln3113">    float zx = old_zoom_x;</a>
<a name="ln3114">    float zy = old_zoom_y;</a>
<a name="ln3115"> </a>
<a name="ln3116">    if(key == GDK_KEY_Left) zx = zx - step_changex * factor;</a>
<a name="ln3117">    if(key == GDK_KEY_Right) zx = zx + step_changex * factor;</a>
<a name="ln3118">    if(key == GDK_KEY_Up) zy = zy - step_changey * factor;</a>
<a name="ln3119">    if(key == GDK_KEY_Down) zy = zy + step_changey * factor;</a>
<a name="ln3120"> </a>
<a name="ln3121">    dt_dev_check_zoom_bounds(dev, &amp;zx, &amp;zy, zoom, closeup, NULL, NULL);</a>
<a name="ln3122">    dt_control_set_dev_zoom_x(zx);</a>
<a name="ln3123">    dt_control_set_dev_zoom_y(zy);</a>
<a name="ln3124"> </a>
<a name="ln3125">    dt_dev_invalidate(dev);</a>
<a name="ln3126">    dt_control_queue_redraw_center();</a>
<a name="ln3127">    dt_control_navigation_redraw();</a>
<a name="ln3128"> </a>
<a name="ln3129">    return 1;</a>
<a name="ln3130">  }</a>
<a name="ln3131"> </a>
<a name="ln3132">  // add an option to allow skip mouse events while editing masks</a>
<a name="ln3133">  if(key == accels-&gt;darkroom_skip_mouse_events.accel_key &amp;&amp; state == accels-&gt;darkroom_skip_mouse_events.accel_mods)</a>
<a name="ln3134">  {</a>
<a name="ln3135">    darktable.develop-&gt;darkroom_skip_mouse_events = TRUE;</a>
<a name="ln3136">    return 1;</a>
<a name="ln3137">  }</a>
<a name="ln3138"> </a>
<a name="ln3139">  // set focus to the search module text box</a>
<a name="ln3140">  if(key == accels-&gt;darkroom_search_modules_focus.accel_key</a>
<a name="ln3141">     &amp;&amp; state == accels-&gt;darkroom_search_modules_focus.accel_mods)</a>
<a name="ln3142">  {</a>
<a name="ln3143">    dt_dev_modulegroups_search_text_focus(darktable.develop);</a>
<a name="ln3144">    return 1;</a>
<a name="ln3145">  }</a>
<a name="ln3146"> </a>
<a name="ln3147">  return 1;</a>
<a name="ln3148">}</a>
<a name="ln3149"> </a>
<a name="ln3150"> </a>
<a name="ln3151">void configure(dt_view_t *self, int wd, int ht)</a>
<a name="ln3152">{</a>
<a name="ln3153">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln3154">  dt_dev_configure(dev, wd, ht);</a>
<a name="ln3155">}</a>
<a name="ln3156"> </a>
<a name="ln3157">void init_key_accels(dt_view_t *self)</a>
<a name="ln3158">{</a>
<a name="ln3159">  // Film strip shortcuts</a>
<a name="ln3160">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;toggle film strip&quot;), GDK_KEY_f, GDK_CONTROL_MASK);</a>
<a name="ln3161"> </a>
<a name="ln3162">  // Zoom shortcuts</a>
<a name="ln3163">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;zoom close-up&quot;), GDK_KEY_1, GDK_MOD1_MASK);</a>
<a name="ln3164">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;zoom fill&quot;), GDK_KEY_2, GDK_MOD1_MASK);</a>
<a name="ln3165">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;zoom fit&quot;), GDK_KEY_3, GDK_MOD1_MASK);</a>
<a name="ln3166"> </a>
<a name="ln3167">  // enable shortcut to export with current export settings:</a>
<a name="ln3168">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;export&quot;), GDK_KEY_e, GDK_CONTROL_MASK);</a>
<a name="ln3169"> </a>
<a name="ln3170">  // Shortcut to skip images</a>
<a name="ln3171">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;image forward&quot;), GDK_KEY_space, 0);</a>
<a name="ln3172">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;image back&quot;), GDK_KEY_BackSpace, 0);</a>
<a name="ln3173"> </a>
<a name="ln3174">  // toggle raw overexposure indication</a>
<a name="ln3175">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;raw overexposed&quot;), GDK_KEY_o, GDK_SHIFT_MASK);</a>
<a name="ln3176"> </a>
<a name="ln3177">  // toggle overexposure indication</a>
<a name="ln3178">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;overexposed&quot;), GDK_KEY_o, 0);</a>
<a name="ln3179"> </a>
<a name="ln3180">  // toggle softproofing</a>
<a name="ln3181">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;softproof&quot;), GDK_KEY_s, GDK_CONTROL_MASK);</a>
<a name="ln3182"> </a>
<a name="ln3183">  // toggle gamut check</a>
<a name="ln3184">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;gamut check&quot;), GDK_KEY_g, GDK_CONTROL_MASK);</a>
<a name="ln3185"> </a>
<a name="ln3186">  // brush size +/-</a>
<a name="ln3187">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;increase brush size&quot;), GDK_KEY_bracketright, 0);</a>
<a name="ln3188">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;decrease brush size&quot;), GDK_KEY_bracketleft, 0);</a>
<a name="ln3189"> </a>
<a name="ln3190">  // brush hardness +/-</a>
<a name="ln3191">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;increase brush hardness&quot;), GDK_KEY_braceright, 0);</a>
<a name="ln3192">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;decrease brush hardness&quot;), GDK_KEY_braceleft, 0);</a>
<a name="ln3193"> </a>
<a name="ln3194">  // brush opacity +/-</a>
<a name="ln3195">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;increase brush opacity&quot;), GDK_KEY_greater, 0);</a>
<a name="ln3196">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;decrease brush opacity&quot;), GDK_KEY_less, 0);</a>
<a name="ln3197"> </a>
<a name="ln3198">  // fullscreen view</a>
<a name="ln3199">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;full preview&quot;), GDK_KEY_z, 0);</a>
<a name="ln3200"> </a>
<a name="ln3201">  // undo/redo</a>
<a name="ln3202">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;undo&quot;), GDK_KEY_z, GDK_CONTROL_MASK);</a>
<a name="ln3203">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;redo&quot;), GDK_KEY_y, GDK_CONTROL_MASK);</a>
<a name="ln3204"> </a>
<a name="ln3205">  // add an option to allow skip mouse events while editing masks</a>
<a name="ln3206">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;allow to pan &amp; zoom while editing masks&quot;), GDK_KEY_a, 0);</a>
<a name="ln3207"> </a>
<a name="ln3208">  // set focus to the search modules text box</a>
<a name="ln3209">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;search modules&quot;), 0, 0);</a>
<a name="ln3210">}</a>
<a name="ln3211"> </a>
<a name="ln3212">static gboolean _darkroom_undo_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln3213">                                        GdkModifierType modifier, gpointer data)</a>
<a name="ln3214">{</a>
<a name="ln3215">  dt_undo_do_undo(darktable.undo, DT_UNDO_DEVELOP);</a>
<a name="ln3216">  return TRUE;</a>
<a name="ln3217">}</a>
<a name="ln3218"> </a>
<a name="ln3219">static gboolean _darkroom_redo_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln3220">                                        GdkModifierType modifier, gpointer data)</a>
<a name="ln3221">{</a>
<a name="ln3222">  dt_undo_do_redo(darktable.undo, DT_UNDO_DEVELOP);</a>
<a name="ln3223">  return TRUE;</a>
<a name="ln3224">}</a>
<a name="ln3225"> </a>
<a name="ln3226">void connect_key_accels(dt_view_t *self)</a>
<a name="ln3227">{</a>
<a name="ln3228">  GClosure *closure;</a>
<a name="ln3229">  dt_develop_t *data = (dt_develop_t *)self-&gt;data;</a>
<a name="ln3230"> </a>
<a name="ln3231">  // Film strip shortcuts</a>
<a name="ln3232">  closure = g_cclosure_new(G_CALLBACK(film_strip_key_accel), (gpointer)self, NULL);</a>
<a name="ln3233">  dt_accel_connect_view(self, &quot;toggle film strip&quot;, closure);</a>
<a name="ln3234"> </a>
<a name="ln3235">  // Zoom shortcuts</a>
<a name="ln3236">  closure = g_cclosure_new(G_CALLBACK(zoom_key_accel), GINT_TO_POINTER(1), NULL);</a>
<a name="ln3237">  dt_accel_connect_view(self, &quot;zoom close-up&quot;, closure);</a>
<a name="ln3238"> </a>
<a name="ln3239">  closure = g_cclosure_new(G_CALLBACK(zoom_key_accel), GINT_TO_POINTER(2), NULL);</a>
<a name="ln3240">  dt_accel_connect_view(self, &quot;zoom fill&quot;, closure);</a>
<a name="ln3241"> </a>
<a name="ln3242">  closure = g_cclosure_new(G_CALLBACK(zoom_key_accel), GINT_TO_POINTER(3), NULL);</a>
<a name="ln3243">  dt_accel_connect_view(self, &quot;zoom fit&quot;, closure);</a>
<a name="ln3244"> </a>
<a name="ln3245">  // enable shortcut to export with current export settings:</a>
<a name="ln3246">  closure = g_cclosure_new(G_CALLBACK(export_key_accel_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln3247">  dt_accel_connect_view(self, &quot;export&quot;, closure);</a>
<a name="ln3248"> </a>
<a name="ln3249">  // Shortcut to skip images</a>
<a name="ln3250">  closure = g_cclosure_new(G_CALLBACK(skip_f_key_accel_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln3251">  dt_accel_connect_view(self, &quot;image forward&quot;, closure);</a>
<a name="ln3252"> </a>
<a name="ln3253">  closure = g_cclosure_new(G_CALLBACK(skip_b_key_accel_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln3254">  dt_accel_connect_view(self, &quot;image back&quot;, closure);</a>
<a name="ln3255"> </a>
<a name="ln3256">  // toggle raw overexposure indication</a>
<a name="ln3257">  closure = g_cclosure_new(G_CALLBACK(_toolbox_toggle_callback), data-&gt;rawoverexposed.button, NULL);</a>
<a name="ln3258">  dt_accel_connect_view(self, &quot;raw overexposed&quot;, closure);</a>
<a name="ln3259"> </a>
<a name="ln3260">  // toggle overexposure indication</a>
<a name="ln3261">  closure = g_cclosure_new(G_CALLBACK(_toolbox_toggle_callback), data-&gt;overexposed.button, NULL);</a>
<a name="ln3262">  dt_accel_connect_view(self, &quot;overexposed&quot;, closure);</a>
<a name="ln3263"> </a>
<a name="ln3264">  // toggle softproof indication</a>
<a name="ln3265">  closure = g_cclosure_new(G_CALLBACK(_toolbox_toggle_callback), data-&gt;profile.softproof_button, NULL);</a>
<a name="ln3266">  dt_accel_connect_view(self, &quot;softproof&quot;, closure);</a>
<a name="ln3267"> </a>
<a name="ln3268">  // toggle gamut indication</a>
<a name="ln3269">  closure = g_cclosure_new(G_CALLBACK(_toolbox_toggle_callback), data-&gt;profile.gamut_button, NULL);</a>
<a name="ln3270">  dt_accel_connect_view(self, &quot;gamut check&quot;, closure);</a>
<a name="ln3271"> </a>
<a name="ln3272">  // brush size +/-</a>
<a name="ln3273">  closure = g_cclosure_new(G_CALLBACK(_brush_size_up_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln3274">  dt_accel_connect_view(self, &quot;increase brush size&quot;, closure);</a>
<a name="ln3275">  closure = g_cclosure_new(G_CALLBACK(_brush_size_down_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln3276">  dt_accel_connect_view(self, &quot;decrease brush size&quot;, closure);</a>
<a name="ln3277"> </a>
<a name="ln3278">  // brush hardness +/-</a>
<a name="ln3279">  closure = g_cclosure_new(G_CALLBACK(_brush_hardness_up_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln3280">  dt_accel_connect_view(self, &quot;increase brush hardness&quot;, closure);</a>
<a name="ln3281">  closure = g_cclosure_new(G_CALLBACK(_brush_hardness_down_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln3282">  dt_accel_connect_view(self, &quot;decrease brush hardness&quot;, closure);</a>
<a name="ln3283"> </a>
<a name="ln3284">  // brush opacity +/-</a>
<a name="ln3285">  closure = g_cclosure_new(G_CALLBACK(_brush_opacity_up_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln3286">  dt_accel_connect_view(self, &quot;increase brush opacity&quot;, closure);</a>
<a name="ln3287">  closure = g_cclosure_new(G_CALLBACK(_brush_opacity_down_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln3288">  dt_accel_connect_view(self, &quot;decrease brush opacity&quot;, closure);</a>
<a name="ln3289"> </a>
<a name="ln3290">  // undo/redo</a>
<a name="ln3291">  closure = g_cclosure_new(G_CALLBACK(_darkroom_undo_callback), (gpointer)self, NULL);</a>
<a name="ln3292">  dt_accel_connect_view(self, &quot;undo&quot;, closure);</a>
<a name="ln3293">  closure = g_cclosure_new(G_CALLBACK(_darkroom_redo_callback), (gpointer)self, NULL);</a>
<a name="ln3294">  dt_accel_connect_view(self, &quot;redo&quot;, closure);</a>
<a name="ln3295"> </a>
<a name="ln3296">  // dynamics accels</a>
<a name="ln3297">  dt_dynamic_accel_get_valid_list();</a>
<a name="ln3298">}</a>
<a name="ln3299"> </a>
<a name="ln3300">GSList *mouse_actions(const dt_view_t *self)</a>
<a name="ln3301">{</a>
<a name="ln3302">  GSList *lm = NULL;</a>
<a name="ln3303">  GSList *lm2 = NULL;</a>
<a name="ln3304">  dt_mouse_action_t *a = NULL;</a>
<a name="ln3305"> </a>
<a name="ln3306">  a = (dt_mouse_action_t *)calloc(1, sizeof(dt_mouse_action_t));</a>
<a name="ln3307">  a-&gt;action = DT_MOUSE_ACTION_DOUBLE_LEFT;</a>
<a name="ln3308">  g_strlcpy(a-&gt;name, _(&quot;switch to lighttable&quot;), sizeof(a-&gt;name));</a>
<a name="ln3309">  lm = g_slist_append(lm, a);</a>
<a name="ln3310"> </a>
<a name="ln3311">  a = (dt_mouse_action_t *)calloc(1, sizeof(dt_mouse_action_t));</a>
<a name="ln3312">  a-&gt;action = DT_MOUSE_ACTION_SCROLL;</a>
<a name="ln3313">  g_strlcpy(a-&gt;name, _(&quot;zoom in the image&quot;), sizeof(a-&gt;name));</a>
<a name="ln3314">  lm = g_slist_append(lm, a);</a>
<a name="ln3315"> </a>
<a name="ln3316">  a = (dt_mouse_action_t *)calloc(1, sizeof(dt_mouse_action_t));</a>
<a name="ln3317">  a-&gt;key.accel_mods = GDK_CONTROL_MASK;</a>
<a name="ln3318">  a-&gt;action = DT_MOUSE_ACTION_SCROLL;</a>
<a name="ln3319">  g_strlcpy(a-&gt;name, _(&quot;unbounded zoom in the image&quot;), sizeof(a-&gt;name));</a>
<a name="ln3320">  lm = g_slist_append(lm, a);</a>
<a name="ln3321"> </a>
<a name="ln3322">  a = (dt_mouse_action_t *)calloc(1, sizeof(dt_mouse_action_t));</a>
<a name="ln3323">  a-&gt;action = DT_MOUSE_ACTION_MIDDLE;</a>
<a name="ln3324">  g_strlcpy(a-&gt;name, _(&quot;zoom to 100% 200% and back&quot;), sizeof(a-&gt;name));</a>
<a name="ln3325">  lm = g_slist_append(lm, a);</a>
<a name="ln3326"> </a>
<a name="ln3327">  a = (dt_mouse_action_t *)calloc(1, sizeof(dt_mouse_action_t));</a>
<a name="ln3328">  a-&gt;key.accel_mods = GDK_SHIFT_MASK;</a>
<a name="ln3329">  a-&gt;action = DT_MOUSE_ACTION_SCROLL;</a>
<a name="ln3330">  g_strlcpy(a-&gt;name, _(&quot;[modules] expand module without closing others&quot;), sizeof(a-&gt;name));</a>
<a name="ln3331">  lm = g_slist_append(lm, a);</a>
<a name="ln3332"> </a>
<a name="ln3333">  a = (dt_mouse_action_t *)calloc(1, sizeof(dt_mouse_action_t));</a>
<a name="ln3334">  a-&gt;key.accel_mods = GDK_SHIFT_MASK | GDK_CONTROL_MASK;</a>
<a name="ln3335">  a-&gt;action = DT_MOUSE_ACTION_DRAG_DROP;</a>
<a name="ln3336">  g_strlcpy(a-&gt;name, _(&quot;[modules] change module position in pipe&quot;), sizeof(a-&gt;name));</a>
<a name="ln3337">  lm = g_slist_append(lm, a);</a>
<a name="ln3338"> </a>
<a name="ln3339">  const dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln3340">  if(dev-&gt;form_visible)</a>
<a name="ln3341">  {</a>
<a name="ln3342">    // masks</a>
<a name="ln3343">    lm2 = dt_masks_mouse_actions(dev-&gt;form_visible);</a>
<a name="ln3344">  }</a>
<a name="ln3345">  else if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;mouse_actions)</a>
<a name="ln3346">  {</a>
<a name="ln3347">    // modules with on canvas actions</a>
<a name="ln3348">    lm2 = dev-&gt;gui_module-&gt;mouse_actions(dev-&gt;gui_module);</a>
<a name="ln3349">  }</a>
<a name="ln3350"> </a>
<a name="ln3351">  // we concatenate the 2 lists</a>
<a name="ln3352">  GSList *l = lm2;</a>
<a name="ln3353">  while(l)</a>
<a name="ln3354">  {</a>
<a name="ln3355">    a = (dt_mouse_action_t *)l-&gt;data;</a>
<a name="ln3356">    if(a) lm = g_slist_append(lm, a);</a>
<a name="ln3357">    l = g_slist_next(l);</a>
<a name="ln3358">  }</a>
<a name="ln3359">  g_slist_free(lm2);</a>
<a name="ln3360"> </a>
<a name="ln3361">  return lm;</a>
<a name="ln3362">}</a>
<a name="ln3363"> </a>
<a name="ln3364">//-----------------------------------------------------------</a>
<a name="ln3365">// second darkroom window</a>
<a name="ln3366">//-----------------------------------------------------------</a>
<a name="ln3367"> </a>
<a name="ln3368">/* helper macro that applies the DPI transformation to fixed pixel values. input should be defaulting to 96</a>
<a name="ln3369"> * DPI */</a>
<a name="ln3370">#define DT_PIXEL_APPLY_DPI_2ND_WND(dev, value) ((value) * dev-&gt;second_window.dpi_factor)</a>
<a name="ln3371"> </a>
<a name="ln3372">static void dt_second_window_change_cursor(dt_develop_t *dev, dt_cursor_t curs)</a>
<a name="ln3373">{</a>
<a name="ln3374">  GtkWidget *widget = dev-&gt;second_window.second_wnd;</a>
<a name="ln3375">  GdkCursor *cursor = gdk_cursor_new_for_display(gdk_display_get_default(), curs);</a>
<a name="ln3376">  gdk_window_set_cursor(gtk_widget_get_window(widget), cursor);</a>
<a name="ln3377">  g_object_unref(cursor);</a>
<a name="ln3378">}</a>
<a name="ln3379"> </a>
<a name="ln3380">static void second_window_expose(GtkWidget *widget, dt_develop_t *dev, cairo_t *cri, int32_t width, int32_t height,</a>
<a name="ln3381">                                 int32_t pointerx, int32_t pointery)</a>
<a name="ln3382">{</a>
<a name="ln3383">  cairo_set_source_rgb(cri, .2, .2, .2);</a>
<a name="ln3384">  cairo_save(cri);</a>
<a name="ln3385"> </a>
<a name="ln3386">  const int32_t tb = 0; // DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln3387">  // account for border, make it transparent for other modules called below:</a>
<a name="ln3388">  pointerx -= tb;</a>
<a name="ln3389">  pointery -= tb;</a>
<a name="ln3390"> </a>
<a name="ln3391">  if(dev-&gt;preview2_status == DT_DEV_PIXELPIPE_DIRTY || dev-&gt;preview2_status == DT_DEV_PIXELPIPE_INVALID</a>
<a name="ln3392">     || dev-&gt;pipe-&gt;input_timestamp &gt; dev-&gt;preview2_pipe-&gt;input_timestamp)</a>
<a name="ln3393">    dt_dev_process_preview2(dev);</a>
<a name="ln3394"> </a>
<a name="ln3395">  dt_pthread_mutex_t *mutex = NULL;</a>
<a name="ln3396">  const float zoom_y = dt_second_window_get_dev_zoom_y(dev);</a>
<a name="ln3397">  const float zoom_x = dt_second_window_get_dev_zoom_x(dev);</a>
<a name="ln3398">  const dt_dev_zoom_t zoom = dt_second_window_get_dev_zoom(dev);</a>
<a name="ln3399">  const int closeup = dt_second_window_get_dev_closeup(dev);</a>
<a name="ln3400">  const float backbuf_scale = dt_second_window_get_zoom_scale(dev, zoom, 1.0f, 0) * dev-&gt;second_window.ppd;</a>
<a name="ln3401"> </a>
<a name="ln3402">  static cairo_surface_t *image_surface = NULL;</a>
<a name="ln3403">  static int image_surface_width = 0, image_surface_height = 0, image_surface_imgid = -1;</a>
<a name="ln3404"> </a>
<a name="ln3405">  if(image_surface_width != width || image_surface_height != height || image_surface == NULL)</a>
<a name="ln3406">  {</a>
<a name="ln3407">    // create double-buffered image to draw on, to make modules draw more fluently.</a>
<a name="ln3408">    image_surface_width = width;</a>
<a name="ln3409">    image_surface_height = height;</a>
<a name="ln3410">    if(image_surface) cairo_surface_destroy(image_surface);</a>
<a name="ln3411">    image_surface = dt_cairo_image_surface_create(CAIRO_FORMAT_RGB24, width, height);</a>
<a name="ln3412">    image_surface_imgid = -1; // invalidate old stuff</a>
<a name="ln3413">  }</a>
<a name="ln3414">  cairo_surface_t *surface;</a>
<a name="ln3415">  cairo_t *cr = cairo_create(image_surface);</a>
<a name="ln3416"> </a>
<a name="ln3417">  if(dev-&gt;preview2_pipe-&gt;output_backbuf &amp;&amp; // do we have an image?</a>
<a name="ln3418">    dev-&gt;preview2_pipe-&gt;backbuf_scale == backbuf_scale &amp;&amp; // is this the zoom scale we want to display?</a>
<a name="ln3419">    dev-&gt;preview2_pipe-&gt;backbuf_zoom_x == zoom_x &amp;&amp; dev-&gt;preview2_pipe-&gt;backbuf_zoom_y == zoom_y)</a>
<a name="ln3420">  {</a>
<a name="ln3421">    // draw image</a>
<a name="ln3422">    mutex = &amp;dev-&gt;preview2_pipe-&gt;backbuf_mutex;</a>
<a name="ln3423">    dt_pthread_mutex_lock(mutex);</a>
<a name="ln3424">    float wd = dev-&gt;preview2_pipe-&gt;output_backbuf_width;</a>
<a name="ln3425">    float ht = dev-&gt;preview2_pipe-&gt;output_backbuf_height;</a>
<a name="ln3426">    const int stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, wd);</a>
<a name="ln3427">    surface</a>
<a name="ln3428">        = dt_cairo_image_surface_create_for_data(dev-&gt;preview2_pipe-&gt;output_backbuf, CAIRO_FORMAT_RGB24, wd, ht, stride);</a>
<a name="ln3429">    wd /= dev-&gt;second_window.ppd;</a>
<a name="ln3430">    ht /= dev-&gt;second_window.ppd;</a>
<a name="ln3431">    dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_DARKROOM_BG);</a>
<a name="ln3432">    cairo_paint(cr);</a>
<a name="ln3433">    cairo_translate(cr, .5f * (width - wd), .5f * (height - ht));</a>
<a name="ln3434"> </a>
<a name="ln3435">    if(closeup)</a>
<a name="ln3436">    {</a>
<a name="ln3437">      const double scale = 1&lt;&lt;closeup;</a>
<a name="ln3438">      cairo_scale(cr, scale, scale);</a>
<a name="ln3439">      cairo_translate(cr, -(.5 - 0.5/scale) * wd, -(.5 - 0.5/scale) * ht);</a>
<a name="ln3440">    }</a>
<a name="ln3441"> </a>
<a name="ln3442">    cairo_rectangle(cr, 0, 0, wd, ht);</a>
<a name="ln3443">    cairo_set_source_surface(cr, surface, 0, 0);</a>
<a name="ln3444">    cairo_pattern_set_filter(cairo_get_source(cr), CAIRO_FILTER_FAST);</a>
<a name="ln3445">    cairo_fill(cr);</a>
<a name="ln3446">    cairo_surface_destroy(surface);</a>
<a name="ln3447">    dt_pthread_mutex_unlock(mutex);</a>
<a name="ln3448">    image_surface_imgid = dev-&gt;image_storage.id;</a>
<a name="ln3449">  }</a>
<a name="ln3450">  else if(dev-&gt;preview_pipe-&gt;output_backbuf)</a>
<a name="ln3451">  {</a>
<a name="ln3452">    // draw preview</a>
<a name="ln3453">    mutex = &amp;dev-&gt;preview_pipe-&gt;backbuf_mutex;</a>
<a name="ln3454">    dt_pthread_mutex_lock(mutex);</a>
<a name="ln3455"> </a>
<a name="ln3456">    const float wd = dev-&gt;preview_pipe-&gt;output_backbuf_width;</a>
<a name="ln3457">    const float ht = dev-&gt;preview_pipe-&gt;output_backbuf_height;</a>
<a name="ln3458">    const float zoom_scale = dt_second_window_get_zoom_scale(dev, zoom, 1 &lt;&lt; closeup, 1);</a>
<a name="ln3459">    dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_DARKROOM_BG);</a>
<a name="ln3460">    cairo_paint(cr);</a>
<a name="ln3461">    cairo_rectangle(cr, tb, tb, width - 2 * tb, height - 2 * tb);</a>
<a name="ln3462">    cairo_clip(cr);</a>
<a name="ln3463">    const int stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, wd);</a>
<a name="ln3464">    surface = cairo_image_surface_create_for_data(dev-&gt;preview_pipe-&gt;output_backbuf, CAIRO_FORMAT_RGB24, wd, ht, stride);</a>
<a name="ln3465">    cairo_translate(cr, width / 2.0, height / 2.0f);</a>
<a name="ln3466">    cairo_scale(cr, zoom_scale, zoom_scale);</a>
<a name="ln3467">    cairo_translate(cr, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln3468">    // avoid to draw the 1px garbage that sometimes shows up in the preview :(</a>
<a name="ln3469">    cairo_rectangle(cr, 0, 0, wd - 1, ht - 1);</a>
<a name="ln3470">    cairo_set_source_surface(cr, surface, 0, 0);</a>
<a name="ln3471">    cairo_pattern_set_filter(cairo_get_source(cr), CAIRO_FILTER_FAST);</a>
<a name="ln3472">    cairo_fill(cr);</a>
<a name="ln3473">    cairo_surface_destroy(surface);</a>
<a name="ln3474">    dt_pthread_mutex_unlock(mutex);</a>
<a name="ln3475">    image_surface_imgid = dev-&gt;image_storage.id;</a>
<a name="ln3476">  }</a>
<a name="ln3477"> </a>
<a name="ln3478">  cairo_restore(cri);</a>
<a name="ln3479"> </a>
<a name="ln3480">  if(image_surface_imgid == dev-&gt;image_storage.id)</a>
<a name="ln3481">  {</a>
<a name="ln3482">    cairo_destroy(cr);</a>
<a name="ln3483">    cairo_set_source_surface(cri, image_surface, 0, 0);</a>
<a name="ln3484">    cairo_paint(cri);</a>
<a name="ln3485">  }</a>
<a name="ln3486">}</a>
<a name="ln3487"> </a>
<a name="ln3488">static void second_window_scrolled(GtkWidget *widget, dt_develop_t *dev, double x, double y, const int up,</a>
<a name="ln3489">                                   const int state)</a>
<a name="ln3490">{</a>
<a name="ln3491">  const int32_t tb = 0; // DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln3492">  const int32_t capwd = dev-&gt;second_window.width - 2 * tb;</a>
<a name="ln3493">  const int32_t capht = dev-&gt;second_window.height - 2 * tb;</a>
<a name="ln3494">  const int32_t width_i = dev-&gt;second_window.width;</a>
<a name="ln3495">  const int32_t height_i = dev-&gt;second_window.height;</a>
<a name="ln3496">  if(width_i &gt; capwd) x += (capwd - width_i) * .5f;</a>
<a name="ln3497">  if(height_i &gt; capht) y += (capht - height_i) * .5f;</a>
<a name="ln3498"> </a>
<a name="ln3499">  // free zoom</a>
<a name="ln3500">  int procw, proch;</a>
<a name="ln3501"> </a>
<a name="ln3502">  dt_dev_zoom_t zoom = dt_second_window_get_dev_zoom(dev);</a>
<a name="ln3503">  int closeup = dt_second_window_get_dev_closeup(dev);</a>
<a name="ln3504">  float zoom_x = dt_second_window_get_dev_zoom_x(dev);</a>
<a name="ln3505">  float zoom_y = dt_second_window_get_dev_zoom_y(dev);</a>
<a name="ln3506">  dt_second_window_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln3507">  float scale = dt_second_window_get_zoom_scale(dev, zoom, 1 &lt;&lt; closeup, 0);</a>
<a name="ln3508">  const float fitscale = dt_second_window_get_zoom_scale(dev, DT_ZOOM_FIT, 1.0, 0);</a>
<a name="ln3509">  float oldscale = scale;</a>
<a name="ln3510"> </a>
<a name="ln3511">  // offset from center now (current zoom_{x,y} points there)</a>
<a name="ln3512">  float mouse_off_x = x - .5 * dev-&gt;second_window.width, mouse_off_y = y - .5 * dev-&gt;second_window.height;</a>
<a name="ln3513">  zoom_x += mouse_off_x / (procw * scale);</a>
<a name="ln3514">  zoom_y += mouse_off_y / (proch * scale);</a>
<a name="ln3515">  zoom = DT_ZOOM_FREE;</a>
<a name="ln3516">  closeup = 0;</a>
<a name="ln3517">  if(up)</a>
<a name="ln3518">  {</a>
<a name="ln3519">    if((scale == 1.0f || scale == 2.0f) &amp;&amp; !((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK)) return;</a>
<a name="ln3520">    if(scale &gt;= 16.0f)</a>
<a name="ln3521">      return;</a>
<a name="ln3522">    else if(scale &gt;= 8.0f)</a>
<a name="ln3523">      scale = 16.0;</a>
<a name="ln3524">    else if(scale &gt;= 4.0f)</a>
<a name="ln3525">      scale = 8.0;</a>
<a name="ln3526">    else if(scale &gt;= 2.0f)</a>
<a name="ln3527">      scale = 4.0;</a>
<a name="ln3528">    else if(scale &lt; fitscale)</a>
<a name="ln3529">      scale += .05f * (1.0f - fitscale);</a>
<a name="ln3530">    else</a>
<a name="ln3531">      scale += .1f * (1.0f - fitscale);</a>
<a name="ln3532">  }</a>
<a name="ln3533">  else</a>
<a name="ln3534">  {</a>
<a name="ln3535">    if(scale == fitscale &amp;&amp; !((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK))</a>
<a name="ln3536">      return;</a>
<a name="ln3537">    else if(scale &lt; 0.5 * fitscale)</a>
<a name="ln3538">      return;</a>
<a name="ln3539">    else if(scale &lt;= fitscale)</a>
<a name="ln3540">      scale -= .05f * (1.0f - fitscale);</a>
<a name="ln3541">    else if(scale &lt;= 2.0f)</a>
<a name="ln3542">      scale -= .1f * (1.0f - fitscale);</a>
<a name="ln3543">    else if(scale &lt;= 4.0f)</a>
<a name="ln3544">      scale = 2.0f;</a>
<a name="ln3545">    else if(scale &lt;= 8.0f)</a>
<a name="ln3546">      scale = 4.0f;</a>
<a name="ln3547">    else</a>
<a name="ln3548">      scale = 8.0f;</a>
<a name="ln3549">  }</a>
<a name="ln3550">  // we want to be sure to stop at 1:1 and FIT levels</a>
<a name="ln3551">  if((scale - 1.0) * (oldscale - 1.0) &lt; 0) scale = 1.0f;</a>
<a name="ln3552">  if((scale - fitscale) * (oldscale - fitscale) &lt; 0) scale = fitscale;</a>
<a name="ln3553">  scale = fmaxf(fminf(scale, 16.0f), 0.5 * fitscale);</a>
<a name="ln3554"> </a>
<a name="ln3555">  // for 200% zoom we want pixel doubling instead of interpolation</a>
<a name="ln3556">  if(scale &gt; 15.9999f)</a>
<a name="ln3557">  {</a>
<a name="ln3558">    scale = 1.0f; // don't interpolate</a>
<a name="ln3559">    closeup = 4;  // enable closeup mode (pixel doubling)</a>
<a name="ln3560">  }</a>
<a name="ln3561">  else if(scale &gt; 7.9999f)</a>
<a name="ln3562">  {</a>
<a name="ln3563">    scale = 1.0f; // don't interpolate</a>
<a name="ln3564">    closeup = 3;  // enable closeup mode (pixel doubling)</a>
<a name="ln3565">  }</a>
<a name="ln3566">  else if(scale &gt; 3.9999f)</a>
<a name="ln3567">  {</a>
<a name="ln3568">    scale = 1.0f; // don't interpolate</a>
<a name="ln3569">    closeup = 2;  // enable closeup mode (pixel doubling)</a>
<a name="ln3570">  }</a>
<a name="ln3571">  else if(scale &gt; 1.9999f)</a>
<a name="ln3572">  {</a>
<a name="ln3573">    scale = 1.0f; // don't interpolate</a>
<a name="ln3574">    closeup = 1;  // enable closeup mode (pixel doubling)</a>
<a name="ln3575">  }</a>
<a name="ln3576"> </a>
<a name="ln3577">  if(fabsf(scale - 1.0f) &lt; 0.001f) zoom = DT_ZOOM_1;</a>
<a name="ln3578">  if(fabsf(scale - fitscale) &lt; 0.001f) zoom = DT_ZOOM_FIT;</a>
<a name="ln3579">  dt_second_window_set_zoom_scale(dev, scale);</a>
<a name="ln3580">  dt_second_window_set_dev_closeup(dev, closeup);</a>
<a name="ln3581">  scale = dt_second_window_get_zoom_scale(dev, zoom, 1 &lt;&lt; closeup, 0);</a>
<a name="ln3582"> </a>
<a name="ln3583">  zoom_x -= mouse_off_x / (procw * scale);</a>
<a name="ln3584">  zoom_y -= mouse_off_y / (proch * scale);</a>
<a name="ln3585">  dt_second_window_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, zoom, closeup, NULL, NULL);</a>
<a name="ln3586">  dt_second_window_set_dev_zoom(dev, zoom);</a>
<a name="ln3587">  dt_second_window_set_dev_zoom_x(dev, zoom_x);</a>
<a name="ln3588">  dt_second_window_set_dev_zoom_y(dev, zoom_y);</a>
<a name="ln3589"> </a>
<a name="ln3590">  // pipe needs to be reconstructed</a>
<a name="ln3591">  dev-&gt;preview2_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln3592"> </a>
<a name="ln3593">  gtk_widget_queue_draw(widget);</a>
<a name="ln3594">}</a>
<a name="ln3595"> </a>
<a name="ln3596">static void second_window_leave(dt_develop_t *dev)</a>
<a name="ln3597">{</a>
<a name="ln3598">  // reset any changes the selected plugin might have made.</a>
<a name="ln3599">  dt_second_window_change_cursor(dev, GDK_LEFT_PTR);</a>
<a name="ln3600">}</a>
<a name="ln3601"> </a>
<a name="ln3602">static int second_window_button_pressed(GtkWidget *widget, dt_develop_t *dev, double x, double y, const double pressure,</a>
<a name="ln3603">                                        const int which, const int type, const uint32_t state)</a>
<a name="ln3604">{</a>
<a name="ln3605">  const int32_t tb = 0; // DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln3606">  const int32_t capwd = dev-&gt;second_window.width - 2 * tb;</a>
<a name="ln3607">  const int32_t capht = dev-&gt;second_window.height - 2 * tb;</a>
<a name="ln3608">  const int32_t width_i = dev-&gt;second_window.width;</a>
<a name="ln3609">  const int32_t height_i = dev-&gt;second_window.height;</a>
<a name="ln3610">  if(width_i &gt; capwd) x += (capwd - width_i) * .5f;</a>
<a name="ln3611">  if(height_i &gt; capht) y += (capht - height_i) * .5f;</a>
<a name="ln3612"> </a>
<a name="ln3613">  dev-&gt;second_window.button_x = x - tb;</a>
<a name="ln3614">  dev-&gt;second_window.button_y = y - tb;</a>
<a name="ln3615"> </a>
<a name="ln3616">  if(which == 1 &amp;&amp; type == GDK_2BUTTON_PRESS) return 0;</a>
<a name="ln3617">  if(which == 1)</a>
<a name="ln3618">  {</a>
<a name="ln3619">    dt_second_window_change_cursor(dev, GDK_HAND1);</a>
<a name="ln3620">    return 1;</a>
<a name="ln3621">  }</a>
<a name="ln3622">  if(which == 2)</a>
<a name="ln3623">  {</a>
<a name="ln3624">    // zoom to 1:1 2:1 and back</a>
<a name="ln3625">    int procw, proch;</a>
<a name="ln3626"> </a>
<a name="ln3627">    dt_dev_zoom_t zoom = dt_second_window_get_dev_zoom(dev);</a>
<a name="ln3628">    int closeup = dt_second_window_get_dev_closeup(dev);</a>
<a name="ln3629">    float zoom_x = dt_second_window_get_dev_zoom_x(dev);</a>
<a name="ln3630">    float zoom_y = dt_second_window_get_dev_zoom_y(dev);</a>
<a name="ln3631">    dt_second_window_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln3632">    const float scale = dt_second_window_get_zoom_scale(dev, zoom, 1 &lt;&lt; closeup, 0);</a>
<a name="ln3633"> </a>
<a name="ln3634">    zoom_x += (1.0 / scale) * (x - .5f * dev-&gt;second_window.width) / procw;</a>
<a name="ln3635">    zoom_y += (1.0 / scale) * (y - .5f * dev-&gt;second_window.height) / proch;</a>
<a name="ln3636"> </a>
<a name="ln3637">    if(zoom == DT_ZOOM_1)</a>
<a name="ln3638">    {</a>
<a name="ln3639">      if(!closeup)</a>
<a name="ln3640">        closeup = 1;</a>
<a name="ln3641">      else</a>
<a name="ln3642">      {</a>
<a name="ln3643">        zoom = DT_ZOOM_FIT;</a>
<a name="ln3644">        zoom_x = zoom_y = 0.0f;</a>
<a name="ln3645">        closeup = 0;</a>
<a name="ln3646">      }</a>
<a name="ln3647">    }</a>
<a name="ln3648">    else</a>
<a name="ln3649">      zoom = DT_ZOOM_1;</a>
<a name="ln3650"> </a>
<a name="ln3651">    dt_second_window_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, zoom, closeup, NULL, NULL);</a>
<a name="ln3652">    dt_second_window_set_dev_zoom(dev, zoom);</a>
<a name="ln3653">    dt_second_window_set_dev_closeup(dev, closeup);</a>
<a name="ln3654">    dt_second_window_set_dev_zoom_x(dev, zoom_x);</a>
<a name="ln3655">    dt_second_window_set_dev_zoom_y(dev, zoom_y);</a>
<a name="ln3656"> </a>
<a name="ln3657">    // pipe needs to be reconstructed</a>
<a name="ln3658">    dev-&gt;preview2_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln3659"> </a>
<a name="ln3660">    gtk_widget_queue_draw(widget);</a>
<a name="ln3661"> </a>
<a name="ln3662">    return 1;</a>
<a name="ln3663">  }</a>
<a name="ln3664">  return 0;</a>
<a name="ln3665">}</a>
<a name="ln3666"> </a>
<a name="ln3667">static int second_window_button_released(dt_develop_t *dev, const double x, const double y, const int which,</a>
<a name="ln3668">                                         const uint32_t state)</a>
<a name="ln3669">{</a>
<a name="ln3670">  if(which == 1) dt_second_window_change_cursor(dev, GDK_LEFT_PTR);</a>
<a name="ln3671">  return 1;</a>
<a name="ln3672">}</a>
<a name="ln3673"> </a>
<a name="ln3674">static void second_window_mouse_moved(GtkWidget *widget, dt_develop_t *dev, double x, double y,</a>
<a name="ln3675">                                      const double pressure, const int which)</a>
<a name="ln3676">{</a>
<a name="ln3677">  const int32_t tb = 0; // DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln3678">  const int32_t capwd = dev-&gt;second_window.width - 2 * tb;</a>
<a name="ln3679">  const int32_t capht = dev-&gt;second_window.height - 2 * tb;</a>
<a name="ln3680"> </a>
<a name="ln3681">  const int32_t width_i = dev-&gt;second_window.width;</a>
<a name="ln3682">  const int32_t height_i = dev-&gt;second_window.height;</a>
<a name="ln3683">  int32_t offx = 0.0f, offy = 0.0f;</a>
<a name="ln3684">  if(width_i &gt; capwd) offx = (capwd - width_i) * .5f;</a>
<a name="ln3685">  if(height_i &gt; capht) offy = (capht - height_i) * .5f;</a>
<a name="ln3686"> </a>
<a name="ln3687">  x += offx;</a>
<a name="ln3688">  y += offy;</a>
<a name="ln3689"> </a>
<a name="ln3690">  if(which &amp; GDK_BUTTON1_MASK)</a>
<a name="ln3691">  {</a>
<a name="ln3692">    // depending on dev_zoom, adjust dev_zoom_x/y.</a>
<a name="ln3693">    const dt_dev_zoom_t zoom = dt_second_window_get_dev_zoom(dev);</a>
<a name="ln3694">    const int closeup = dt_second_window_get_dev_closeup(dev);</a>
<a name="ln3695">    int procw, proch;</a>
<a name="ln3696">    dt_second_window_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln3697">    const float scale = dt_second_window_get_zoom_scale(dev, zoom, 1 &lt;&lt; closeup, 0);</a>
<a name="ln3698">    float old_zoom_x, old_zoom_y;</a>
<a name="ln3699">    old_zoom_x = dt_second_window_get_dev_zoom_x(dev);</a>
<a name="ln3700">    old_zoom_y = dt_second_window_get_dev_zoom_y(dev);</a>
<a name="ln3701">    float zx = old_zoom_x - (1.0 / scale) * (x - dev-&gt;second_window.button_x - offx) / procw;</a>
<a name="ln3702">    float zy = old_zoom_y - (1.0 / scale) * (y - dev-&gt;second_window.button_y - offy) / proch;</a>
<a name="ln3703">    dt_second_window_check_zoom_bounds(dev, &amp;zx, &amp;zy, zoom, closeup, NULL, NULL);</a>
<a name="ln3704">    dt_second_window_set_dev_zoom_x(dev, zx);</a>
<a name="ln3705">    dt_second_window_set_dev_zoom_y(dev, zy);</a>
<a name="ln3706">    dev-&gt;second_window.button_x = x - offx;</a>
<a name="ln3707">    dev-&gt;second_window.button_y = y - offy;</a>
<a name="ln3708"> </a>
<a name="ln3709">    // pipe needs to be reconstructed</a>
<a name="ln3710">    dev-&gt;preview2_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln3711"> </a>
<a name="ln3712">    gtk_widget_queue_draw(widget);</a>
<a name="ln3713">  }</a>
<a name="ln3714">}</a>
<a name="ln3715"> </a>
<a name="ln3716">static void _second_window_configure_ppd_dpi(dt_develop_t *dev)</a>
<a name="ln3717">{</a>
<a name="ln3718">  GtkWidget *widget = dev-&gt;second_window.second_wnd;</a>
<a name="ln3719"> </a>
<a name="ln3720">// check if in HiDPI mode</a>
<a name="ln3721">#if(CAIRO_VERSION &gt;= CAIRO_VERSION_ENCODE(1, 13, 1))</a>
<a name="ln3722">  float screen_ppd_overwrite = dt_conf_get_float(&quot;screen_ppd_overwrite&quot;);</a>
<a name="ln3723">  if(screen_ppd_overwrite &gt; 0.0)</a>
<a name="ln3724">  {</a>
<a name="ln3725">    dev-&gt;second_window.ppd = screen_ppd_overwrite;</a>
<a name="ln3726">    dt_print(DT_DEBUG_CONTROL, &quot;[HiDPI] setting ppd to %f as specified in the configuration file\n&quot;,</a>
<a name="ln3727">             screen_ppd_overwrite);</a>
<a name="ln3728">  }</a>
<a name="ln3729">  else</a>
<a name="ln3730">  {</a>
<a name="ln3731">#ifndef GDK_WINDOWING_QUARTZ</a>
<a name="ln3732">    dev-&gt;second_window.ppd = gtk_widget_get_scale_factor(widget);</a>
<a name="ln3733">#else</a>
<a name="ln3734">    // this do not depends on the window, so we can use the main window value</a>
<a name="ln3735">    dev-&gt;second_window.ppd = darktable.gui-&gt;ppd;</a>
<a name="ln3736">#endif</a>
<a name="ln3737">    if(dev-&gt;second_window.ppd &lt; 0.0)</a>
<a name="ln3738">    {</a>
<a name="ln3739">      dev-&gt;second_window.ppd = 1.0;</a>
<a name="ln3740">      dt_print(DT_DEBUG_CONTROL, &quot;[HiDPI] can't detect screen settings, switching off\n&quot;);</a>
<a name="ln3741">    }</a>
<a name="ln3742">    else</a>
<a name="ln3743">      dt_print(DT_DEBUG_CONTROL, &quot;[HiDPI] setting ppd to %f\n&quot;, dev-&gt;second_window.ppd);</a>
<a name="ln3744">  }</a>
<a name="ln3745">#else</a>
<a name="ln3746">  dev-&gt;second_window.ppd = 1.0;</a>
<a name="ln3747">#endif</a>
<a name="ln3748">  // get the screen resolution</a>
<a name="ln3749">  float screen_dpi_overwrite = dt_conf_get_float(&quot;screen_dpi_overwrite&quot;);</a>
<a name="ln3750">  if(screen_dpi_overwrite &gt; 0.0)</a>
<a name="ln3751">  {</a>
<a name="ln3752">    dev-&gt;second_window.dpi = screen_dpi_overwrite;</a>
<a name="ln3753">    gdk_screen_set_resolution(gtk_widget_get_screen(widget), screen_dpi_overwrite);</a>
<a name="ln3754">    dt_print(DT_DEBUG_CONTROL, &quot;[screen resolution] setting the screen resolution to %f dpi as specified in &quot;</a>
<a name="ln3755">                               &quot;the configuration file\n&quot;, screen_dpi_overwrite);</a>
<a name="ln3756">  }</a>
<a name="ln3757">  else</a>
<a name="ln3758">  {</a>
<a name="ln3759">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln3760">    dt_osx_autoset_dpi(widget);</a>
<a name="ln3761">#endif</a>
<a name="ln3762">    dev-&gt;second_window.dpi = gdk_screen_get_resolution(gtk_widget_get_screen(widget));</a>
<a name="ln3763">    if(dev-&gt;second_window.dpi &lt; 0.0)</a>
<a name="ln3764">    {</a>
<a name="ln3765">      dev-&gt;second_window.dpi = 96.0;</a>
<a name="ln3766">      gdk_screen_set_resolution(gtk_widget_get_screen(widget), 96.0);</a>
<a name="ln3767">      dt_print(DT_DEBUG_CONTROL, &quot;[screen resolution] setting the screen resolution to the default 96 dpi\n&quot;);</a>
<a name="ln3768">    }</a>
<a name="ln3769">    else</a>
<a name="ln3770">      dt_print(DT_DEBUG_CONTROL, &quot;[screen resolution] setting the screen resolution to %f dpi\n&quot;, dev-&gt;second_window.dpi);</a>
<a name="ln3771">  }</a>
<a name="ln3772">  dev-&gt;second_window.dpi_factor</a>
<a name="ln3773">      = dev-&gt;second_window.dpi / 96; // according to man xrandr and the docs of gdk_screen_set_resolution 96 is the default</a>
<a name="ln3774">}</a>
<a name="ln3775"> </a>
<a name="ln3776">static gboolean _second_window_draw_callback(GtkWidget *widget, cairo_t *crf, dt_develop_t *dev)</a>
<a name="ln3777">{</a>
<a name="ln3778">  int pointerx, pointery;</a>
<a name="ln3779">  GtkAllocation allocation;</a>
<a name="ln3780">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln3781">  int32_t width = allocation.width;</a>
<a name="ln3782">  int32_t height = allocation.height;</a>
<a name="ln3783"> </a>
<a name="ln3784">  dev-&gt;second_window.width = width;</a>
<a name="ln3785">  dev-&gt;second_window.height = height;</a>
<a name="ln3786"> </a>
<a name="ln3787">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln3788">  gdk_window_get_device_position(gtk_widget_get_window(widget),</a>
<a name="ln3789">                                 gdk_seat_get_pointer(gdk_display_get_default_seat(gtk_widget_get_display(widget))),</a>
<a name="ln3790">                                 &amp;pointerx, &amp;pointery, NULL);</a>
<a name="ln3791">#else</a>
<a name="ln3792">  GdkDevice *device</a>
<a name="ln3793">      = gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gtk_widget_get_display(widget)));</a>
<a name="ln3794">  gdk_window_get_device_position(gtk_widget_get_window(widget), device, &amp;pointerx, &amp;pointery, NULL);</a>
<a name="ln3795">#endif</a>
<a name="ln3796"> </a>
<a name="ln3797">  second_window_expose(widget, dev, crf, width, height, pointerx, pointery);</a>
<a name="ln3798"> </a>
<a name="ln3799">  return TRUE;</a>
<a name="ln3800">}</a>
<a name="ln3801"> </a>
<a name="ln3802">static gboolean dt_gui_get_second_window_scroll_unit_deltas(const GdkEventScroll *event, int *delta_x, int *delta_y)</a>
<a name="ln3803">{</a>
<a name="ln3804">  // accumulates scrolling regardless of source or the widget being scrolled</a>
<a name="ln3805">  static gdouble acc_x = 0.0, acc_y = 0.0;</a>
<a name="ln3806">  gboolean handled = FALSE;</a>
<a name="ln3807"> </a>
<a name="ln3808">  switch(event-&gt;direction)</a>
<a name="ln3809">  {</a>
<a name="ln3810">    // is one-unit cardinal, e.g. from a mouse scroll wheel</a>
<a name="ln3811">    case GDK_SCROLL_LEFT:</a>
<a name="ln3812">      if(delta_x) *delta_x = -1;</a>
<a name="ln3813">      if(delta_y) *delta_y = 0;</a>
<a name="ln3814">      handled = TRUE;</a>
<a name="ln3815">      break;</a>
<a name="ln3816">    case GDK_SCROLL_RIGHT:</a>
<a name="ln3817">      if(delta_x) *delta_x = 1;</a>
<a name="ln3818">      if(delta_y) *delta_y = 0;</a>
<a name="ln3819">      handled = TRUE;</a>
<a name="ln3820">      break;</a>
<a name="ln3821">    case GDK_SCROLL_UP:</a>
<a name="ln3822">      if(delta_x) *delta_x = 0;</a>
<a name="ln3823">      if(delta_y) *delta_y = -1;</a>
<a name="ln3824">      handled = TRUE;</a>
<a name="ln3825">      break;</a>
<a name="ln3826">    case GDK_SCROLL_DOWN:</a>
<a name="ln3827">      if(delta_x) *delta_x = 0;</a>
<a name="ln3828">      if(delta_y) *delta_y = 1;</a>
<a name="ln3829">      handled = TRUE;</a>
<a name="ln3830">      break;</a>
<a name="ln3831">    // is trackpad (or touch) scroll</a>
<a name="ln3832">    case GDK_SCROLL_SMOOTH:</a>
<a name="ln3833">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln3834">      // stop events reset accumulated delta</a>
<a name="ln3835">      if(event-&gt;is_stop)</a>
<a name="ln3836">      {</a>
<a name="ln3837">        acc_x = acc_y = 0.0;</a>
<a name="ln3838">        break;</a>
<a name="ln3839">      }</a>
<a name="ln3840">#endif</a>
<a name="ln3841">      // accumulate trackpad/touch scrolls until they make a unit</a>
<a name="ln3842">      // scroll, and only then tell caller that there is a scroll to</a>
<a name="ln3843">      // handle</a>
<a name="ln3844">      acc_x += event-&gt;delta_x;</a>
<a name="ln3845">      acc_y += event-&gt;delta_y;</a>
<a name="ln3846">      if(fabs(acc_x) &gt;= 1.0)</a>
<a name="ln3847">      {</a>
<a name="ln3848">        gdouble amt = trunc(acc_x);</a>
<a name="ln3849">        acc_x -= amt;</a>
<a name="ln3850">        if(delta_x) *delta_x = (int)amt;</a>
<a name="ln3851">        if(delta_y) *delta_y = 0;</a>
<a name="ln3852">        handled = TRUE;</a>
<a name="ln3853">      }</a>
<a name="ln3854">      if(fabs(acc_y) &gt;= 1.0)</a>
<a name="ln3855">      {</a>
<a name="ln3856">        gdouble amt = trunc(acc_y);</a>
<a name="ln3857">        acc_y -= amt;</a>
<a name="ln3858">        if(delta_x &amp;&amp; !handled) *delta_x = 0;</a>
<a name="ln3859">        if(delta_y) *delta_y = (int)amt;</a>
<a name="ln3860">        handled = TRUE;</a>
<a name="ln3861">      }</a>
<a name="ln3862">      break;</a>
<a name="ln3863">    default:</a>
<a name="ln3864">      break;</a>
<a name="ln3865">  }</a>
<a name="ln3866">  return handled;</a>
<a name="ln3867">}</a>
<a name="ln3868"> </a>
<a name="ln3869">static gboolean _second_window_scrolled_callback(GtkWidget *widget, GdkEventScroll *event, dt_develop_t *dev)</a>
<a name="ln3870">{</a>
<a name="ln3871">  int delta_y;</a>
<a name="ln3872">  if(dt_gui_get_second_window_scroll_unit_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln3873">  {</a>
<a name="ln3874">    second_window_scrolled(widget, dev, event-&gt;x, event-&gt;y, delta_y &lt; 0, event-&gt;state &amp; 0xf);</a>
<a name="ln3875">    gtk_widget_queue_draw(widget);</a>
<a name="ln3876">  }</a>
<a name="ln3877"> </a>
<a name="ln3878">  return TRUE;</a>
<a name="ln3879">}</a>
<a name="ln3880"> </a>
<a name="ln3881">static gboolean _second_window_button_pressed_callback(GtkWidget *w, GdkEventButton *event, dt_develop_t *dev)</a>
<a name="ln3882">{</a>
<a name="ln3883">  double pressure = 1.0;</a>
<a name="ln3884">  GdkDevice *device = gdk_event_get_source_device((GdkEvent *)event);</a>
<a name="ln3885"> </a>
<a name="ln3886">  if(device &amp;&amp; gdk_device_get_source(device) == GDK_SOURCE_PEN)</a>
<a name="ln3887">  {</a>
<a name="ln3888">    gdk_event_get_axis((GdkEvent *)event, GDK_AXIS_PRESSURE, &amp;pressure);</a>
<a name="ln3889">  }</a>
<a name="ln3890">  second_window_button_pressed(w, dev, event-&gt;x, event-&gt;y, pressure, event-&gt;button, event-&gt;type, event-&gt;state &amp; 0xf);</a>
<a name="ln3891">  gtk_widget_grab_focus(w);</a>
<a name="ln3892">  gtk_widget_queue_draw(w);</a>
<a name="ln3893">  return FALSE;</a>
<a name="ln3894">}</a>
<a name="ln3895"> </a>
<a name="ln3896">static gboolean _second_window_button_released_callback(GtkWidget *w, GdkEventButton *event, dt_develop_t *dev)</a>
<a name="ln3897">{</a>
<a name="ln3898">  second_window_button_released(dev, event-&gt;x, event-&gt;y, event-&gt;button, event-&gt;state &amp; 0xf);</a>
<a name="ln3899">  gtk_widget_queue_draw(w);</a>
<a name="ln3900">  return TRUE;</a>
<a name="ln3901">}</a>
<a name="ln3902"> </a>
<a name="ln3903">static gboolean _second_window_mouse_moved_callback(GtkWidget *w, GdkEventMotion *event, dt_develop_t *dev)</a>
<a name="ln3904">{</a>
<a name="ln3905">  double pressure = 1.0;</a>
<a name="ln3906">  GdkDevice *device = gdk_event_get_source_device((GdkEvent *)event);</a>
<a name="ln3907"> </a>
<a name="ln3908">  if(device &amp;&amp; gdk_device_get_source(device) == GDK_SOURCE_PEN)</a>
<a name="ln3909">  {</a>
<a name="ln3910">    gdk_event_get_axis((GdkEvent *)event, GDK_AXIS_PRESSURE, &amp;pressure);</a>
<a name="ln3911">  }</a>
<a name="ln3912">  second_window_mouse_moved(w, dev, event-&gt;x, event-&gt;y, pressure, event-&gt;state);</a>
<a name="ln3913">  return FALSE;</a>
<a name="ln3914">}</a>
<a name="ln3915"> </a>
<a name="ln3916">static gboolean _second_window_leave_callback(GtkWidget *widget, GdkEventCrossing *event, dt_develop_t *dev)</a>
<a name="ln3917">{</a>
<a name="ln3918">  second_window_leave(dev);</a>
<a name="ln3919">  return TRUE;</a>
<a name="ln3920">}</a>
<a name="ln3921"> </a>
<a name="ln3922">static gboolean _second_window_configure_callback(GtkWidget *da, GdkEventConfigure *event, dt_develop_t *dev)</a>
<a name="ln3923">{</a>
<a name="ln3924">  static int oldw = 0;</a>
<a name="ln3925">  static int oldh = 0;</a>
<a name="ln3926"> </a>
<a name="ln3927">  if(oldw != event-&gt;width || oldh != event-&gt;height)</a>
<a name="ln3928">  {</a>
<a name="ln3929">    dev-&gt;second_window.width = event-&gt;width;</a>
<a name="ln3930">    dev-&gt;second_window.height = event-&gt;height;</a>
<a name="ln3931"> </a>
<a name="ln3932">    // pipe needs to be reconstructed</a>
<a name="ln3933">    dev-&gt;preview2_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln3934">    dev-&gt;preview2_pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln3935">    dev-&gt;preview2_pipe-&gt;cache_obsolete = 1;</a>
<a name="ln3936">  }</a>
<a name="ln3937">  oldw = event-&gt;width;</a>
<a name="ln3938">  oldh = event-&gt;height;</a>
<a name="ln3939"> </a>
<a name="ln3940">  dt_colorspaces_set_display_profile(DT_COLORSPACE_DISPLAY2);</a>
<a name="ln3941"> </a>
<a name="ln3942">#ifndef GDK_WINDOWING_QUARTZ</a>
<a name="ln3943">  _second_window_configure_ppd_dpi(dev);</a>
<a name="ln3944">#endif</a>
<a name="ln3945"> </a>
<a name="ln3946">  return TRUE;</a>
<a name="ln3947">}</a>
<a name="ln3948"> </a>
<a name="ln3949">static void _darkroom_ui_second_window_init(GtkWidget *widget, dt_develop_t *dev)</a>
<a name="ln3950">{</a>
<a name="ln3951">  const int width = MAX(10, dt_conf_get_int(&quot;second_window/window_w&quot;));</a>
<a name="ln3952">  const int height = MAX(10, dt_conf_get_int(&quot;second_window/window_h&quot;));</a>
<a name="ln3953"> </a>
<a name="ln3954">  dev-&gt;second_window.width = width;</a>
<a name="ln3955">  dev-&gt;second_window.height = height;</a>
<a name="ln3956"> </a>
<a name="ln3957">  const gint x = MAX(0, dt_conf_get_int(&quot;second_window/window_x&quot;));</a>
<a name="ln3958">  const gint y = MAX(0, dt_conf_get_int(&quot;second_window/window_y&quot;));</a>
<a name="ln3959">  gtk_window_set_default_size(GTK_WINDOW(widget), width, height);</a>
<a name="ln3960">  gtk_widget_show_all(widget);</a>
<a name="ln3961">  gtk_window_move(GTK_WINDOW(widget), x, y);</a>
<a name="ln3962">  gtk_window_resize(GTK_WINDOW(widget), width, height);</a>
<a name="ln3963">  const int fullscreen = dt_conf_get_bool(&quot;second_window/fullscreen&quot;);</a>
<a name="ln3964">  if(fullscreen)</a>
<a name="ln3965">    gtk_window_fullscreen(GTK_WINDOW(widget));</a>
<a name="ln3966">  else</a>
<a name="ln3967">  {</a>
<a name="ln3968">    gtk_window_unfullscreen(GTK_WINDOW(widget));</a>
<a name="ln3969">    const int maximized = dt_conf_get_bool(&quot;second_window/maximized&quot;);</a>
<a name="ln3970">    if(maximized)</a>
<a name="ln3971">      gtk_window_maximize(GTK_WINDOW(widget));</a>
<a name="ln3972">    else</a>
<a name="ln3973">      gtk_window_unmaximize(GTK_WINDOW(widget));</a>
<a name="ln3974">  }</a>
<a name="ln3975">}</a>
<a name="ln3976"> </a>
<a name="ln3977">static void _darkroom_ui_second_window_write_config(GtkWidget *widget)</a>
<a name="ln3978">{</a>
<a name="ln3979">  GtkAllocation allocation;</a>
<a name="ln3980">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln3981">  gint x, y;</a>
<a name="ln3982">  gtk_window_get_position(GTK_WINDOW(widget), &amp;x, &amp;y);</a>
<a name="ln3983">  dt_conf_set_int(&quot;second_window/window_x&quot;, x);</a>
<a name="ln3984">  dt_conf_set_int(&quot;second_window/window_y&quot;, y);</a>
<a name="ln3985">  dt_conf_set_int(&quot;second_window/window_w&quot;, allocation.width);</a>
<a name="ln3986">  dt_conf_set_int(&quot;second_window/window_h&quot;, allocation.height);</a>
<a name="ln3987">  dt_conf_set_bool(&quot;second_window/maximized&quot;,</a>
<a name="ln3988">                   (gdk_window_get_state(gtk_widget_get_window(widget)) &amp; GDK_WINDOW_STATE_MAXIMIZED));</a>
<a name="ln3989">  dt_conf_set_bool(&quot;second_window/fullscreen&quot;,</a>
<a name="ln3990">                   (gdk_window_get_state(gtk_widget_get_window(widget)) &amp; GDK_WINDOW_STATE_FULLSCREEN));</a>
<a name="ln3991">}</a>
<a name="ln3992"> </a>
<a name="ln3993">static gboolean _second_window_delete_callback(GtkWidget *widget, GdkEvent *event, dt_develop_t *dev)</a>
<a name="ln3994">{</a>
<a name="ln3995">  _darkroom_ui_second_window_write_config(dev-&gt;second_window.second_wnd);</a>
<a name="ln3996"> </a>
<a name="ln3997">  dev-&gt;second_window.second_wnd = NULL;</a>
<a name="ln3998">  dev-&gt;second_window.widget = NULL;</a>
<a name="ln3999"> </a>
<a name="ln4000">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(dev-&gt;second_window.button), FALSE);</a>
<a name="ln4001"> </a>
<a name="ln4002">  return FALSE;</a>
<a name="ln4003">}</a>
<a name="ln4004"> </a>
<a name="ln4005">static gboolean _second_window_key_pressed_callback(GtkWidget *widget, GdkEventKey *event, dt_develop_t *dev)</a>
<a name="ln4006">{</a>
<a name="ln4007">  int fullscreen;</a>
<a name="ln4008"> </a>
<a name="ln4009">  GtkAccelKey key_on, key_off;</a>
<a name="ln4010">  char path_on[256];</a>
<a name="ln4011">  char path_off[256];</a>
<a name="ln4012">  dt_accel_path_global(path_on, sizeof(path_on), &quot;toggle fullscreen&quot;);</a>
<a name="ln4013">  dt_accel_path_global(path_off, sizeof(path_off), &quot;leave fullscreen&quot;);</a>
<a name="ln4014">  gtk_accel_map_lookup_entry(path_on, &amp;key_on);</a>
<a name="ln4015">  gtk_accel_map_lookup_entry(path_off, &amp;key_off);</a>
<a name="ln4016"> </a>
<a name="ln4017">  if(event-&gt;keyval == key_on.accel_key &amp;&amp; (event-&gt;state &amp; KEY_STATE_MASK) == key_on.accel_mods)</a>
<a name="ln4018">  {</a>
<a name="ln4019">    fullscreen = gdk_window_get_state(gtk_widget_get_window(widget)) &amp; GDK_WINDOW_STATE_FULLSCREEN;</a>
<a name="ln4020">    if(fullscreen)</a>
<a name="ln4021">      gtk_window_unfullscreen(GTK_WINDOW(widget));</a>
<a name="ln4022">    else</a>
<a name="ln4023">      gtk_window_fullscreen(GTK_WINDOW(widget));</a>
<a name="ln4024">  }</a>
<a name="ln4025">  else if(event-&gt;keyval == key_off.accel_key &amp;&amp; (event-&gt;state &amp; KEY_STATE_MASK) == key_off.accel_mods)</a>
<a name="ln4026">  {</a>
<a name="ln4027">    gtk_window_unfullscreen(GTK_WINDOW(widget));</a>
<a name="ln4028">  }</a>
<a name="ln4029">  else</a>
<a name="ln4030">  {</a>
<a name="ln4031">    return FALSE;</a>
<a name="ln4032">  }</a>
<a name="ln4033"> </a>
<a name="ln4034">  /* redraw center view */</a>
<a name="ln4035">  gtk_widget_queue_draw(dev-&gt;second_window.widget);</a>
<a name="ln4036">#ifdef __APPLE__</a>
<a name="ln4037">  // workaround for GTK Quartz backend bug</a>
<a name="ln4038">  gtk_window_set_title(GTK_WINDOW(widget), _(&quot;darktable - darkroom preview&quot;));</a>
<a name="ln4039">#endif</a>
<a name="ln4040">  return TRUE;</a>
<a name="ln4041">}</a>
<a name="ln4042"> </a>
<a name="ln4043">static void _darkroom_display_second_window(dt_develop_t *dev)</a>
<a name="ln4044">{</a>
<a name="ln4045">  if(dev-&gt;second_window.second_wnd == NULL)</a>
<a name="ln4046">  {</a>
<a name="ln4047">    dev-&gt;second_window.width = -1;</a>
<a name="ln4048">    dev-&gt;second_window.height = -1;</a>
<a name="ln4049"> </a>
<a name="ln4050">    dev-&gt;second_window.second_wnd = gtk_window_new(GTK_WINDOW_TOPLEVEL);</a>
<a name="ln4051">    gtk_widget_set_name(dev-&gt;second_window.second_wnd, &quot;second_window&quot;);</a>
<a name="ln4052"> </a>
<a name="ln4053">    _second_window_configure_ppd_dpi(dev);</a>
<a name="ln4054"> </a>
<a name="ln4055">    gtk_window_set_icon_name(GTK_WINDOW(dev-&gt;second_window.second_wnd), &quot;darktable&quot;);</a>
<a name="ln4056">    gtk_window_set_title(GTK_WINDOW(dev-&gt;second_window.second_wnd), _(&quot;darktable - darkroom preview&quot;));</a>
<a name="ln4057"> </a>
<a name="ln4058">    GtkWidget *container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln4059">    gtk_container_add(GTK_CONTAINER(dev-&gt;second_window.second_wnd), container);</a>
<a name="ln4060"> </a>
<a name="ln4061">    GtkWidget *widget = gtk_grid_new();</a>
<a name="ln4062">    gtk_box_pack_start(GTK_BOX(container), widget, TRUE, TRUE, 0);</a>
<a name="ln4063"> </a>
<a name="ln4064">    dev-&gt;second_window.widget = gtk_drawing_area_new();</a>
<a name="ln4065">    gtk_widget_set_size_request(dev-&gt;second_window.widget, DT_PIXEL_APPLY_DPI_2ND_WND(dev, 50), DT_PIXEL_APPLY_DPI_2ND_WND(dev, 200));</a>
<a name="ln4066">    gtk_widget_set_hexpand(dev-&gt;second_window.widget, TRUE);</a>
<a name="ln4067">    gtk_widget_set_vexpand(dev-&gt;second_window.widget, TRUE);</a>
<a name="ln4068">    gtk_widget_set_app_paintable(dev-&gt;second_window.widget, TRUE);</a>
<a name="ln4069"> </a>
<a name="ln4070">    gtk_grid_attach(GTK_GRID(widget), dev-&gt;second_window.widget, 0, 0, 1, 1);</a>
<a name="ln4071"> </a>
<a name="ln4072">    gtk_widget_set_events(dev-&gt;second_window.widget, GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln4073">                                                         | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln4074">                                                         | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK</a>
<a name="ln4075">                                                         | darktable.gui-&gt;scroll_mask);</a>
<a name="ln4076"> </a>
<a name="ln4077">    /* connect callbacks */</a>
<a name="ln4078">    g_signal_connect(G_OBJECT(dev-&gt;second_window.widget), &quot;draw&quot;, G_CALLBACK(_second_window_draw_callback), dev);</a>
<a name="ln4079">    g_signal_connect(G_OBJECT(dev-&gt;second_window.widget), &quot;scroll-event&quot;,</a>
<a name="ln4080">                     G_CALLBACK(_second_window_scrolled_callback), dev);</a>
<a name="ln4081">    g_signal_connect(G_OBJECT(dev-&gt;second_window.widget), &quot;button-press-event&quot;,</a>
<a name="ln4082">                     G_CALLBACK(_second_window_button_pressed_callback), dev);</a>
<a name="ln4083">    g_signal_connect(G_OBJECT(dev-&gt;second_window.widget), &quot;button-release-event&quot;,</a>
<a name="ln4084">                     G_CALLBACK(_second_window_button_released_callback), dev);</a>
<a name="ln4085">    g_signal_connect(G_OBJECT(dev-&gt;second_window.widget), &quot;motion-notify-event&quot;,</a>
<a name="ln4086">                     G_CALLBACK(_second_window_mouse_moved_callback), dev);</a>
<a name="ln4087">    g_signal_connect(G_OBJECT(dev-&gt;second_window.widget), &quot;leave-notify-event&quot;,</a>
<a name="ln4088">                     G_CALLBACK(_second_window_leave_callback), dev);</a>
<a name="ln4089">    g_signal_connect(G_OBJECT(dev-&gt;second_window.widget), &quot;configure-event&quot;,</a>
<a name="ln4090">                     G_CALLBACK(_second_window_configure_callback), dev);</a>
<a name="ln4091"> </a>
<a name="ln4092">    g_signal_connect(G_OBJECT(dev-&gt;second_window.second_wnd), &quot;delete-event&quot;,</a>
<a name="ln4093">                     G_CALLBACK(_second_window_delete_callback), dev);</a>
<a name="ln4094">    g_signal_connect(G_OBJECT(dev-&gt;second_window.second_wnd), &quot;key-press-event&quot;,</a>
<a name="ln4095">                     G_CALLBACK(_second_window_key_pressed_callback), dev);</a>
<a name="ln4096"> </a>
<a name="ln4097">    _darkroom_ui_second_window_init(dev-&gt;second_window.second_wnd, dev);</a>
<a name="ln4098">  }</a>
<a name="ln4099"> </a>
<a name="ln4100">  gtk_widget_show_all(dev-&gt;second_window.second_wnd);</a>
<a name="ln4101">}</a>
<a name="ln4102"> </a>
<a name="ln4103">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln4104">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln4105">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1134"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="2101"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v751/" target="_blank">V751</a> Parameter 'x' is not used inside function body.</p></div>
<div class="balloon" rel="3307"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'a'. Check lines: 3307, 3306.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
