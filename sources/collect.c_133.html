
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika, henrik andersson.</a>
<a name="ln4">    copyright (c) 2012 Jose Carlos Garcia Sogo</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;libs/collect.h&quot;</a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/film.h&quot;</a>
<a name="ln24">#include &quot;common/metadata.h&quot;</a>
<a name="ln25">#include &quot;common/utility.h&quot;</a>
<a name="ln26">#include &quot;control/conf.h&quot;</a>
<a name="ln27">#include &quot;control/control.h&quot;</a>
<a name="ln28">#include &quot;control/jobs.h&quot;</a>
<a name="ln29">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln30">#include &quot;gui/gtk.h&quot;</a>
<a name="ln31">#include &quot;libs/lib.h&quot;</a>
<a name="ln32">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln33">#include &quot;views/view.h&quot;</a>
<a name="ln34">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln35">#include &quot;osx/osx.h&quot;</a>
<a name="ln36">#endif</a>
<a name="ln37"> </a>
<a name="ln38">DT_MODULE(1)</a>
<a name="ln39"> </a>
<a name="ln40">#define MAX_RULES 10</a>
<a name="ln41"> </a>
<a name="ln42">#define PARAM_STRING_SIZE 256 // FIXME: is this enough !?</a>
<a name="ln43"> </a>
<a name="ln44">typedef struct dt_lib_collect_rule_t</a>
<a name="ln45">{</a>
<a name="ln46">  int num;</a>
<a name="ln47">  GtkWidget *hbox;</a>
<a name="ln48">  GtkComboBox *combo;</a>
<a name="ln49">  GtkWidget *text;</a>
<a name="ln50">  GtkWidget *button;</a>
<a name="ln51">  gboolean typing;</a>
<a name="ln52">} dt_lib_collect_rule_t;</a>
<a name="ln53"> </a>
<a name="ln54">typedef struct dt_lib_collect_t</a>
<a name="ln55">{</a>
<a name="ln56">  dt_lib_collect_rule_t rule[MAX_RULES];</a>
<a name="ln57">  int active_rule;</a>
<a name="ln58">  int nb_rules;</a>
<a name="ln59"> </a>
<a name="ln60">  GtkTreeView *view;</a>
<a name="ln61">  int view_rule;</a>
<a name="ln62"> </a>
<a name="ln63">  GtkTreeModel *treefilter;</a>
<a name="ln64">  GtkTreeModel *listfilter;</a>
<a name="ln65">  GtkScrolledWindow *scrolledwindow;</a>
<a name="ln66"> </a>
<a name="ln67">  GtkScrolledWindow *sw2;</a>
<a name="ln68"> </a>
<a name="ln69">  gboolean singleclick;</a>
<a name="ln70">  struct dt_lib_collect_params_t *params;</a>
<a name="ln71">} dt_lib_collect_t;</a>
<a name="ln72"> </a>
<a name="ln73">typedef struct dt_lib_collect_params_rule_t</a>
<a name="ln74">{</a>
<a name="ln75">  uint32_t item : 16;</a>
<a name="ln76">  uint32_t mode : 16;</a>
<a name="ln77">  char string[PARAM_STRING_SIZE];</a>
<a name="ln78">} dt_lib_collect_params_rule_t;</a>
<a name="ln79"> </a>
<a name="ln80">typedef struct dt_lib_collect_params_t</a>
<a name="ln81">{</a>
<a name="ln82">  uint32_t rules;</a>
<a name="ln83">  dt_lib_collect_params_rule_t rule[MAX_RULES];</a>
<a name="ln84">} dt_lib_collect_params_t;</a>
<a name="ln85"> </a>
<a name="ln86">typedef enum dt_lib_collect_cols_t</a>
<a name="ln87">{</a>
<a name="ln88">  DT_LIB_COLLECT_COL_TEXT = 0,</a>
<a name="ln89">  DT_LIB_COLLECT_COL_ID,</a>
<a name="ln90">  DT_LIB_COLLECT_COL_TOOLTIP,</a>
<a name="ln91">  DT_LIB_COLLECT_COL_PATH,</a>
<a name="ln92">  DT_LIB_COLLECT_COL_VISIBLE,</a>
<a name="ln93">  DT_LIB_COLLECT_COL_UNREACHABLE,</a>
<a name="ln94">  DT_LIB_COLLECT_COL_COUNT,</a>
<a name="ln95">  DT_LIB_COLLECT_NUM_COLS</a>
<a name="ln96">} dt_lib_collect_cols_t;</a>
<a name="ln97"> </a>
<a name="ln98">typedef struct _range_t</a>
<a name="ln99">{</a>
<a name="ln100">  gchar *start;</a>
<a name="ln101">  gchar *stop;</a>
<a name="ln102">  GtkTreePath *path1;</a>
<a name="ln103">  GtkTreePath *path2;</a>
<a name="ln104">} _range_t;</a>
<a name="ln105"> </a>
<a name="ln106">static void _lib_collect_gui_update(dt_lib_module_t *self);</a>
<a name="ln107">static void _lib_folders_update_collection(const gchar *filmroll);</a>
<a name="ln108">static void entry_insert_text(GtkWidget *entry, gchar *new_text, gint new_length, gpointer *position,</a>
<a name="ln109">                          dt_lib_collect_rule_t *d);</a>
<a name="ln110">static void entry_changed(GtkEntry *entry, dt_lib_collect_rule_t *dr);</a>
<a name="ln111">static void collection_updated(gpointer instance, gpointer self);</a>
<a name="ln112">static void row_activated_with_event(GtkTreeView *view, GtkTreePath *path, GtkTreeViewColumn *col, GdkEventButton *event, dt_lib_collect_t *d);</a>
<a name="ln113"> </a>
<a name="ln114">const char *name(dt_lib_module_t *self)</a>
<a name="ln115">{</a>
<a name="ln116">  return _(&quot;collect images&quot;);</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">void init_presets(dt_lib_module_t *self)</a>
<a name="ln120">{</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">/* Update the params struct with active ruleset */</a>
<a name="ln124">static void _lib_collect_update_params(dt_lib_collect_t *d)</a>
<a name="ln125">{</a>
<a name="ln126">  /* reset params */</a>
<a name="ln127">  dt_lib_collect_params_t *p = d-&gt;params;</a>
<a name="ln128">  memset(p, 0, sizeof(dt_lib_collect_params_t));</a>
<a name="ln129"> </a>
<a name="ln130">  /* for each active rule set update params */</a>
<a name="ln131">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;) - 1;</a>
<a name="ln132">  const int active = CLAMP(_a, 0, (MAX_RULES - 1));</a>
<a name="ln133">  char confname[200] = { 0 };</a>
<a name="ln134">  for(int i = 0; i &lt;= active; i++)</a>
<a name="ln135">  {</a>
<a name="ln136">    /* get item */</a>
<a name="ln137">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln138">    p-&gt;rule[i].item = dt_conf_get_int(confname);</a>
<a name="ln139"> </a>
<a name="ln140">    /* get mode */</a>
<a name="ln141">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln142">    p-&gt;rule[i].mode = dt_conf_get_int(confname);</a>
<a name="ln143"> </a>
<a name="ln144">    /* get string */</a>
<a name="ln145">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln146">    gchar *string = dt_conf_get_string(confname);</a>
<a name="ln147">    if(string != NULL)</a>
<a name="ln148">    {</a>
<a name="ln149">      snprintf(p-&gt;rule[i].string, PARAM_STRING_SIZE, &quot;%s&quot;, string);</a>
<a name="ln150">      g_free(string);</a>
<a name="ln151">    }</a>
<a name="ln152"> </a>
<a name="ln153">    // fprintf(stderr,&quot;[%i] %d,%d,%s\n&quot;,i, p-&gt;rule[i].item, p-&gt;rule[i].mode,  p-&gt;rule[i].string);</a>
<a name="ln154">  }</a>
<a name="ln155"> </a>
<a name="ln156">  p-&gt;rules = active + 1;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">void *get_params(dt_lib_module_t *self, int *size)</a>
<a name="ln160">{</a>
<a name="ln161">  _lib_collect_update_params(self-&gt;data);</a>
<a name="ln162"> </a>
<a name="ln163">  /* allocate a copy of params to return, freed by caller */</a>
<a name="ln164">  *size = sizeof(dt_lib_collect_params_t);</a>
<a name="ln165">  void *p = malloc(*size);</a>
<a name="ln166">  memcpy(p, ((dt_lib_collect_t *)self-&gt;data)-&gt;params, *size);</a>
<a name="ln167">  return p;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">int set_params(dt_lib_module_t *self, const void *params, int size)</a>
<a name="ln171">{</a>
<a name="ln172">  /* update conf settings from params */</a>
<a name="ln173">  dt_lib_collect_params_t *p = (dt_lib_collect_params_t *)params;</a>
<a name="ln174">  char confname[200] = { 0 };</a>
<a name="ln175"> </a>
<a name="ln176">  for(uint32_t i = 0; i &lt; p-&gt;rules; i++)</a>
<a name="ln177">  {</a>
<a name="ln178">    /* set item */</a>
<a name="ln179">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln180">    dt_conf_set_int(confname, p-&gt;rule[i].item);</a>
<a name="ln181"> </a>
<a name="ln182">    /* set mode */</a>
<a name="ln183">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln184">    dt_conf_set_int(confname, p-&gt;rule[i].mode);</a>
<a name="ln185"> </a>
<a name="ln186">    /* set string */</a>
<a name="ln187">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln188">    dt_conf_set_string(confname, p-&gt;rule[i].string);</a>
<a name="ln189">  }</a>
<a name="ln190"> </a>
<a name="ln191">  /* set number of rules */</a>
<a name="ln192">  g_strlcpy(confname, &quot;plugins/lighttable/collect/num_rules&quot;, sizeof(confname));</a>
<a name="ln193">  dt_conf_set_int(confname, p-&gt;rules);</a>
<a name="ln194"> </a>
<a name="ln195">  /* update internal params */</a>
<a name="ln196">  _lib_collect_update_params(self-&gt;data);</a>
<a name="ln197"> </a>
<a name="ln198">  /* update ui */</a>
<a name="ln199">  _lib_collect_gui_update(self);</a>
<a name="ln200"> </a>
<a name="ln201">  /* update view */</a>
<a name="ln202">  dt_collection_update_query(darktable.collection);</a>
<a name="ln203">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_QUERY_CHANGED);</a>
<a name="ln204">  return 0;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207"> </a>
<a name="ln208">const char **views(dt_lib_module_t *self)</a>
<a name="ln209">{</a>
<a name="ln210">  static const char *v[] = {&quot;lighttable&quot;, &quot;map&quot;, &quot;print&quot;, NULL};</a>
<a name="ln211">  return v;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln215">{</a>
<a name="ln216">  return DT_UI_CONTAINER_PANEL_LEFT_CENTER;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">static void view_popup_menu_onSearchFilmroll(GtkWidget *menuitem, gpointer userdata)</a>
<a name="ln220">{</a>
<a name="ln221">  GtkTreeView *treeview = GTK_TREE_VIEW(userdata);</a>
<a name="ln222">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln223">  GtkWidget *filechooser;</a>
<a name="ln224"> </a>
<a name="ln225">  GtkTreeSelection *selection;</a>
<a name="ln226">  GtkTreeIter iter, child;</a>
<a name="ln227">  GtkTreeModel *model;</a>
<a name="ln228"> </a>
<a name="ln229">  gchar *tree_path = NULL;</a>
<a name="ln230">  gchar *new_path = NULL;</a>
<a name="ln231"> </a>
<a name="ln232">  model = gtk_tree_view_get_model(treeview);</a>
<a name="ln233">  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln234">  if (!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln235">    return;</a>
<a name="ln236"> </a>
<a name="ln237">  child = iter;</a>
<a name="ln238">  gtk_tree_model_iter_parent(model, &amp;iter, &amp;child);</a>
<a name="ln239">  gtk_tree_model_get(model, &amp;child, DT_LIB_COLLECT_COL_PATH, &amp;tree_path, -1);</a>
<a name="ln240"> </a>
<a name="ln241">  filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln242">    _(&quot;search filmroll&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln243">    GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln244">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln245">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln246">#endif</a>
<a name="ln247"> </a>
<a name="ln248">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln249">  if(tree_path != NULL)</a>
<a name="ln250">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(filechooser), tree_path);</a>
<a name="ln251">  else</a>
<a name="ln252">    goto error;</a>
<a name="ln253"> </a>
<a name="ln254">  // run the dialog</a>
<a name="ln255">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln256">  {</a>
<a name="ln257">    gint id = -1;</a>
<a name="ln258">    sqlite3_stmt *stmt;</a>
<a name="ln259">    gchar *query = NULL;</a>
<a name="ln260"> </a>
<a name="ln261">    gchar *uri = NULL;</a>
<a name="ln262">    uri = gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln263">    new_path = g_filename_from_uri(uri, NULL, NULL);</a>
<a name="ln264">    g_free(uri);</a>
<a name="ln265">    if(new_path)</a>
<a name="ln266">    {</a>
<a name="ln267">      gchar *old = NULL;</a>
<a name="ln268">      query = dt_util_dstrcat(query, &quot;SELECT id, folder FROM main.film_rolls WHERE folder LIKE '%s%%'&quot;, tree_path);</a>
<a name="ln269">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln270">      g_free(query);</a>
<a name="ln271">      query = NULL;</a>
<a name="ln272"> </a>
<a name="ln273">      while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln274">      {</a>
<a name="ln275">        id = sqlite3_column_int(stmt, 0);</a>
<a name="ln276">        old = (gchar *)sqlite3_column_text(stmt, 1);</a>
<a name="ln277"> </a>
<a name="ln278">        query = NULL;</a>
<a name="ln279">        query = dt_util_dstrcat(query, &quot;UPDATE main.film_rolls SET folder=?1 WHERE id=?2&quot;);</a>
<a name="ln280"> </a>
<a name="ln281">        gchar trailing[1024] = { 0 };</a>
<a name="ln282">        gchar final[1024] = { 0 };</a>
<a name="ln283"> </a>
<a name="ln284">        if(g_strcmp0(old, tree_path))</a>
<a name="ln285">        {</a>
<a name="ln286">          g_snprintf(trailing, sizeof(trailing), &quot;%s&quot;, old + strlen(tree_path) + 1);</a>
<a name="ln287">          g_snprintf(final, sizeof(final), &quot;%s/%s&quot;, new_path, trailing);</a>
<a name="ln288">        }</a>
<a name="ln289">        else</a>
<a name="ln290">        {</a>
<a name="ln291">          g_snprintf(final, sizeof(final), &quot;%s&quot;, new_path);</a>
<a name="ln292">        }</a>
<a name="ln293"> </a>
<a name="ln294">        sqlite3_stmt *stmt2;</a>
<a name="ln295">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt2, NULL);</a>
<a name="ln296">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt2, 1, final, -1, SQLITE_STATIC);</a>
<a name="ln297">        DT_DEBUG_SQLITE3_BIND_INT(stmt2, 2, id);</a>
<a name="ln298">        sqlite3_step(stmt2);</a>
<a name="ln299">        sqlite3_finalize(stmt2);</a>
<a name="ln300">      }</a>
<a name="ln301">      sqlite3_finalize(stmt);</a>
<a name="ln302">      g_free(query);</a>
<a name="ln303"> </a>
<a name="ln304">      /* reset filter so that view isn't empty */</a>
<a name="ln305">      dt_view_filter_reset(darktable.view_manager, FALSE);</a>
<a name="ln306"> </a>
<a name="ln307">      /* update collection to view missing filmroll */</a>
<a name="ln308">      _lib_folders_update_collection(new_path);</a>
<a name="ln309"> </a>
<a name="ln310">      dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln311">    }</a>
<a name="ln312">    else</a>
<a name="ln313">      goto error;</a>
<a name="ln314">  }</a>
<a name="ln315">  g_free(tree_path);</a>
<a name="ln316">  g_free(new_path);</a>
<a name="ln317">  gtk_widget_destroy(filechooser);</a>
<a name="ln318">  return;</a>
<a name="ln319"> </a>
<a name="ln320">error:</a>
<a name="ln321">  /* Something wrong happened */</a>
<a name="ln322">  gtk_widget_destroy(filechooser);</a>
<a name="ln323">  dt_control_log(_(&quot;problem selecting new path for the filmroll in %s&quot;), tree_path);</a>
<a name="ln324"> </a>
<a name="ln325">  g_free(tree_path);</a>
<a name="ln326">  g_free(new_path);</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">static void view_popup_menu_onRemove(GtkWidget *menuitem, gpointer userdata)</a>
<a name="ln330">{</a>
<a name="ln331">  GtkTreeView *treeview = GTK_TREE_VIEW(userdata);</a>
<a name="ln332"> </a>
<a name="ln333">  GtkTreeSelection *selection;</a>
<a name="ln334">  GtkTreeIter iter, model_iter;</a>
<a name="ln335">  GtkTreeModel *model;</a>
<a name="ln336"> </a>
<a name="ln337">  gchar *filmroll_path = NULL;</a>
<a name="ln338">  gchar *fullq = NULL;</a>
<a name="ln339"> </a>
<a name="ln340">  /* Get info about the filmroll (or parent) selected */</a>
<a name="ln341">  model = gtk_tree_view_get_model(treeview);</a>
<a name="ln342">  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln343">  if (gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln344">  {</a>
<a name="ln345">    gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;filmroll_path, -1);</a>
<a name="ln346"> </a>
<a name="ln347">    /* Clean selected images, and add to the table those which are going to be deleted */</a>
<a name="ln348">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images&quot;, NULL, NULL, NULL);</a>
<a name="ln349"> </a>
<a name="ln350">    fullq = dt_util_dstrcat(fullq, &quot;INSERT INTO main.selected_images SELECT id FROM main.images WHERE film_id IN &quot;</a>
<a name="ln351">                                   &quot;(SELECT id FROM main.film_rolls WHERE folder LIKE '%s%%')&quot;,</a>
<a name="ln352">                            filmroll_path);</a>
<a name="ln353">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), fullq, NULL, NULL, NULL);</a>
<a name="ln354"> </a>
<a name="ln355">    if (dt_control_remove_images())</a>
<a name="ln356">    {</a>
<a name="ln357">      gtk_tree_model_filter_convert_iter_to_child_iter(GTK_TREE_MODEL_FILTER(model), &amp;model_iter, &amp;iter);</a>
<a name="ln358">      gtk_tree_store_remove(GTK_TREE_STORE(gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model))),</a>
<a name="ln359">                            &amp;model_iter);</a>
<a name="ln360">    }</a>
<a name="ln361"> </a>
<a name="ln362">    g_free(fullq);</a>
<a name="ln363">  }</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">static void view_popup_menu(GtkWidget *treeview, GdkEventButton *event, dt_lib_collect_t *d)</a>
<a name="ln367">{</a>
<a name="ln368">  GtkWidget *menu, *menuitem;</a>
<a name="ln369"> </a>
<a name="ln370">  menu = gtk_menu_new();</a>
<a name="ln371"> </a>
<a name="ln372">  menuitem = gtk_menu_item_new_with_label(_(&quot;search filmroll...&quot;));</a>
<a name="ln373">  g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)view_popup_menu_onSearchFilmroll, treeview);</a>
<a name="ln374">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln375"> </a>
<a name="ln376">  menuitem = gtk_menu_item_new_with_label(_(&quot;remove...&quot;));</a>
<a name="ln377">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln378">  g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)view_popup_menu_onRemove, treeview);</a>
<a name="ln379"> </a>
<a name="ln380">  gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln381"> </a>
<a name="ln382">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln383">  gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln384">#else</a>
<a name="ln385">  /* Note: event can be NULL here when called from view_onPopupMenu;</a>
<a name="ln386">   *  gdk_event_get_time() accepts a NULL argument */</a>
<a name="ln387">  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, (event != NULL) ? event-&gt;button : 0,</a>
<a name="ln388">                 gdk_event_get_time((GdkEvent *)event));</a>
<a name="ln389">#endif</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">static gboolean view_onButtonPressed(GtkWidget *treeview, GdkEventButton *event, dt_lib_collect_t *d)</a>
<a name="ln393">{</a>
<a name="ln394">  if((d-&gt;view_rule == DT_COLLECTION_PROP_FOLDERS &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3)</a>
<a name="ln395">     || (!d-&gt;singleclick &amp;&amp; event-&gt;type == GDK_2BUTTON_PRESS &amp;&amp; event-&gt;button == 1)</a>
<a name="ln396">     || (d-&gt;singleclick &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 1))</a>
<a name="ln397">  {</a>
<a name="ln398">    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln399">    GtkTreePath *path = NULL;</a>
<a name="ln400"> </a>
<a name="ln401">    /* Get tree path for row that was clicked */</a>
<a name="ln402">    if(gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(treeview), (gint)event-&gt;x, (gint)event-&gt;y, &amp;path, NULL, NULL,</a>
<a name="ln403">                                     NULL))</a>
<a name="ln404">    {</a>
<a name="ln405">      if(d-&gt;singleclick &amp;&amp; (event-&gt;state &amp; GDK_SHIFT_MASK) &amp;&amp; gtk_tree_selection_count_selected_rows(selection) &gt; 0</a>
<a name="ln406">         &amp;&amp; (d-&gt;view_rule == DT_COLLECTION_PROP_DAY || d-&gt;view_rule == DT_COLLECTION_PROP_TIME</a>
<a name="ln407">             || d-&gt;view_rule == DT_COLLECTION_PROP_APERTURE || d-&gt;view_rule == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln408">             || d-&gt;view_rule == DT_COLLECTION_PROP_ISO || d-&gt;view_rule == DT_COLLECTION_PROP_EXPOSURE</a>
<a name="ln409">             || d-&gt;view_rule == DT_COLLECTION_PROP_ASPECT_RATIO))</a>
<a name="ln410">      {</a>
<a name="ln411">        // range selection</a>
<a name="ln412">        GList *sels = gtk_tree_selection_get_selected_rows(selection, NULL);</a>
<a name="ln413">        GtkTreePath *path2 = (GtkTreePath *)g_list_nth_data(sels, 0);</a>
<a name="ln414">        gtk_tree_selection_unselect_all(selection);</a>
<a name="ln415">        if(gtk_tree_path_compare(path, path2) &gt; 0)</a>
<a name="ln416">          gtk_tree_selection_select_range(selection, path, path2);</a>
<a name="ln417">        else</a>
<a name="ln418">          gtk_tree_selection_select_range(selection, path2, path);</a>
<a name="ln419">      }</a>
<a name="ln420">      else</a>
<a name="ln421">      {</a>
<a name="ln422">        gtk_tree_selection_unselect_all(selection);</a>
<a name="ln423">        gtk_tree_selection_select_path(selection, path);</a>
<a name="ln424">      }</a>
<a name="ln425">    }</a>
<a name="ln426"> </a>
<a name="ln427">    /* single click on folder with the right mouse button? */</a>
<a name="ln428">    if(d-&gt;view_rule == DT_COLLECTION_PROP_FOLDERS &amp;&amp; (event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3))</a>
<a name="ln429">      view_popup_menu(treeview, event, d);</a>
<a name="ln430">    else</a>
<a name="ln431">      row_activated_with_event(GTK_TREE_VIEW(treeview), path, NULL, event, d);</a>
<a name="ln432"> </a>
<a name="ln433">    gtk_tree_path_free(path);</a>
<a name="ln434"> </a>
<a name="ln435">    if((d-&gt;view_rule == DT_COLLECTION_PROP_DAY || d-&gt;view_rule == DT_COLLECTION_PROP_TIME</a>
<a name="ln436">        || d-&gt;view_rule == DT_COLLECTION_PROP_FOLDERS || d-&gt;view_rule == DT_COLLECTION_PROP_TAG)</a>
<a name="ln437">       &amp;&amp; !(event-&gt;state &amp; GDK_SHIFT_MASK))</a>
<a name="ln438">      return FALSE; /* we allow propagation (expand/collapse row) */</a>
<a name="ln439">    else</a>
<a name="ln440">      return TRUE; /* we stop propagation */</a>
<a name="ln441">  }</a>
<a name="ln442">  return FALSE; /* we did not handle this */</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">static gboolean view_onPopupMenu(GtkWidget *treeview, dt_lib_collect_t *d)</a>
<a name="ln446">{</a>
<a name="ln447">  if(d-&gt;view_rule != DT_COLLECTION_PROP_FOLDERS) return FALSE;</a>
<a name="ln448"> </a>
<a name="ln449">  view_popup_menu(treeview, NULL, d);</a>
<a name="ln450"> </a>
<a name="ln451">  return TRUE; /* we handled this */</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">static dt_lib_collect_t *get_collect(dt_lib_collect_rule_t *r)</a>
<a name="ln455">{</a>
<a name="ln456">  dt_lib_collect_t *d = (dt_lib_collect_t *)(((char *)r) - r-&gt;num * sizeof(dt_lib_collect_rule_t));</a>
<a name="ln457">  return d;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">static gboolean list_select(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln461">{</a>
<a name="ln462">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln463">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln464">  gchar *str = NULL;</a>
<a name="ln465"> </a>
<a name="ln466">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, -1);</a>
<a name="ln467"> </a>
<a name="ln468">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln469">  gchar *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln470"> </a>
<a name="ln471">  if(strcmp(haystack, needle) == 0)</a>
<a name="ln472">  {</a>
<a name="ln473">    gtk_tree_selection_select_path(gtk_tree_view_get_selection(d-&gt;view), path);</a>
<a name="ln474">    gtk_tree_view_scroll_to_cell(d-&gt;view, path, NULL, FALSE, 0.2, 0);</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  g_free(haystack);</a>
<a name="ln478">  g_free(needle);</a>
<a name="ln479">  g_free(str);</a>
<a name="ln480"> </a>
<a name="ln481">  return FALSE;</a>
<a name="ln482">}</a>
<a name="ln483">static gboolean range_select(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln484">{</a>
<a name="ln485">  _range_t *range = (_range_t *)data;</a>
<a name="ln486">  gchar *str = NULL;</a>
<a name="ln487"> </a>
<a name="ln488">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, -1);</a>
<a name="ln489"> </a>
<a name="ln490">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln491">  gchar *needle;</a>
<a name="ln492">  if(range-&gt;path1)</a>
<a name="ln493">    needle = g_utf8_strdown(range-&gt;stop, -1);</a>
<a name="ln494">  else</a>
<a name="ln495">    needle = g_utf8_strdown(range-&gt;start, -1);</a>
<a name="ln496"> </a>
<a name="ln497">  if(strcmp(haystack, needle) == 0)</a>
<a name="ln498">  {</a>
<a name="ln499">    if(range-&gt;path1)</a>
<a name="ln500">    {</a>
<a name="ln501">      range-&gt;path2 = gtk_tree_path_copy(path);</a>
<a name="ln502">      return TRUE;</a>
<a name="ln503">    }</a>
<a name="ln504">    else</a>
<a name="ln505">      range-&gt;path1 = gtk_tree_path_copy(path);</a>
<a name="ln506">  }</a>
<a name="ln507"> </a>
<a name="ln508">  g_free(haystack);</a>
<a name="ln509">  g_free(needle);</a>
<a name="ln510">  g_free(str);</a>
<a name="ln511"> </a>
<a name="ln512">  return FALSE;</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">static gboolean tree_expand(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln516">{</a>
<a name="ln517">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln518">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln519">  gchar *str = NULL;</a>
<a name="ln520">  gchar *txt = NULL;</a>
<a name="ln521">  gboolean startwildcard = FALSE;</a>
<a name="ln522"> </a>
<a name="ln523">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, DT_LIB_COLLECT_COL_TEXT, &amp;txt, -1);</a>
<a name="ln524"> </a>
<a name="ln525">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln526">  gchar *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln527">  gchar *txt2 = g_utf8_strdown(txt, -1);</a>
<a name="ln528"> </a>
<a name="ln529">  if(g_str_has_prefix(needle, &quot;%&quot;)) startwildcard = TRUE;</a>
<a name="ln530">  if(g_str_has_suffix(needle, &quot;%&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln531">  if(g_str_has_suffix(haystack, &quot;%&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln532">  if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_TAG)</a>
<a name="ln533">  {</a>
<a name="ln534">    if(g_str_has_suffix(needle, &quot;|&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln535">    if(g_str_has_suffix(haystack, &quot;|&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln536">  }</a>
<a name="ln537">  else if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_FOLDERS)</a>
<a name="ln538">  {</a>
<a name="ln539">    if(g_str_has_suffix(needle, &quot;/&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln540">    if(g_str_has_suffix(haystack, &quot;/&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln541">  }</a>
<a name="ln542">  else if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_DAY</a>
<a name="ln543">          || gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_TIME)</a>
<a name="ln544">  {</a>
<a name="ln545">    if(g_str_has_suffix(needle, &quot;:&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln546">    if(g_str_has_suffix(haystack, &quot;:&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln547">  }</a>
<a name="ln548"> </a>
<a name="ln549">  if(dr-&gt;typing &amp;&amp; g_strrstr(txt2, needle) != NULL)</a>
<a name="ln550">  {</a>
<a name="ln551">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln552">  }</a>
<a name="ln553"> </a>
<a name="ln554">  if(strlen(needle)==0)</a>
<a name="ln555">  {</a>
<a name="ln556">    //nothing to do, we keep the tree collapsed</a>
<a name="ln557">  }</a>
<a name="ln558">  else if(strcmp(haystack, needle) == 0)</a>
<a name="ln559">  {</a>
<a name="ln560">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln561">    gtk_tree_selection_select_path(gtk_tree_view_get_selection(d-&gt;view), path);</a>
<a name="ln562">    gtk_tree_view_scroll_to_cell(d-&gt;view, path, NULL, FALSE, 0.2, 0);</a>
<a name="ln563">  }</a>
<a name="ln564">  else if(startwildcard &amp;&amp; g_strrstr(haystack, needle+1) != NULL)</a>
<a name="ln565">  {</a>
<a name="ln566">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln567">  }</a>
<a name="ln568">  else if(g_str_has_prefix(haystack, needle))</a>
<a name="ln569">  {</a>
<a name="ln570">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  g_free(haystack);</a>
<a name="ln574">  g_free(needle);</a>
<a name="ln575">  g_free(txt2);</a>
<a name="ln576">  g_free(str);</a>
<a name="ln577">  g_free(txt);</a>
<a name="ln578"> </a>
<a name="ln579">  return FALSE;</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">static gboolean list_match_string(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln583">{</a>
<a name="ln584">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln585">  gchar *str = NULL;</a>
<a name="ln586">  gboolean visible;</a>
<a name="ln587"> </a>
<a name="ln588">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, -1);</a>
<a name="ln589"> </a>
<a name="ln590">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln591">  gchar *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln592">  if(g_str_has_suffix(needle, &quot;%&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln593"> </a>
<a name="ln594">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln595">  if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln596">     || property == DT_COLLECTION_PROP_ISO)</a>
<a name="ln597">  {</a>
<a name="ln598">    // handle of numeric value, which can have some operator before the text</a>
<a name="ln599">    visible = TRUE;</a>
<a name="ln600">    gchar *operator, *number, *number2;</a>
<a name="ln601">    dt_collection_split_operator_number(needle, &amp;number, &amp;number2, &amp;operator);</a>
<a name="ln602">    if(number)</a>
<a name="ln603">    {</a>
<a name="ln604">      float nb1 = g_strtod(number, NULL);</a>
<a name="ln605">      float nb2 = g_strtod(haystack, NULL);</a>
<a name="ln606">      if(operator&amp;&amp; strcmp(operator, &quot;&gt;&quot;) == 0)</a>
<a name="ln607">      {</a>
<a name="ln608">        visible = (nb2 &gt; nb1);</a>
<a name="ln609">      }</a>
<a name="ln610">      else if(operator&amp;&amp; strcmp(operator, &quot;&gt;=&quot;) == 0)</a>
<a name="ln611">      {</a>
<a name="ln612">        visible = (nb2 &gt;= nb1);</a>
<a name="ln613">      }</a>
<a name="ln614">      else if(operator&amp;&amp; strcmp(operator, &quot;&lt;&quot;) == 0)</a>
<a name="ln615">      {</a>
<a name="ln616">        visible = (nb2 &lt; nb1);</a>
<a name="ln617">      }</a>
<a name="ln618">      else if(operator&amp;&amp; strcmp(operator, &quot;&lt;=&quot;) == 0)</a>
<a name="ln619">      {</a>
<a name="ln620">        visible = (nb2 &lt;= nb1);</a>
<a name="ln621">      }</a>
<a name="ln622">      else if(operator&amp;&amp; strcmp(operator, &quot;&lt;&gt;&quot;) == 0)</a>
<a name="ln623">      {</a>
<a name="ln624">        visible = (nb1 != nb2);</a>
<a name="ln625">      }</a>
<a name="ln626">      else if(operator&amp;&amp; number2 &amp;&amp; strcmp(operator, &quot;[]&quot;) == 0)</a>
<a name="ln627">      {</a>
<a name="ln628">        float nb3 = g_strtod(number2, NULL);</a>
<a name="ln629">        visible = (nb2 &gt;= nb1 &amp;&amp; nb2 &lt;= nb3);</a>
<a name="ln630">      }</a>
<a name="ln631">      else</a>
<a name="ln632">      {</a>
<a name="ln633">        visible = (nb1 == nb2);</a>
<a name="ln634">      }</a>
<a name="ln635">    }</a>
<a name="ln636">    g_free(operator);</a>
<a name="ln637">    g_free(number);</a>
<a name="ln638">    g_free(number2);</a>
<a name="ln639">  }</a>
<a name="ln640">  else</a>
<a name="ln641">  {</a>
<a name="ln642">    if(g_str_has_prefix(needle, &quot;%&quot;))</a>
<a name="ln643">      visible = (g_strrstr(haystack, needle + 1) != NULL);</a>
<a name="ln644">    else</a>
<a name="ln645">      visible = (g_strrstr(haystack, needle) != NULL);</a>
<a name="ln646">  }</a>
<a name="ln647"> </a>
<a name="ln648">  g_free(haystack);</a>
<a name="ln649">  g_free(needle);</a>
<a name="ln650"> </a>
<a name="ln651">  g_free(str);</a>
<a name="ln652"> </a>
<a name="ln653">  gtk_list_store_set(GTK_LIST_STORE(model), iter, DT_LIB_COLLECT_COL_VISIBLE, visible, -1);</a>
<a name="ln654">  return FALSE;</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">static gboolean tree_match_string(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln658">{</a>
<a name="ln659">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln660">  gchar *str = NULL;</a>
<a name="ln661">  gboolean cur_state, visible;</a>
<a name="ln662"> </a>
<a name="ln663">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, DT_LIB_COLLECT_COL_VISIBLE, &amp;cur_state, -1);</a>
<a name="ln664"> </a>
<a name="ln665">  if(dr-&gt;typing == FALSE &amp;&amp; !cur_state)</a>
<a name="ln666">  {</a>
<a name="ln667">    visible = TRUE;</a>
<a name="ln668">  }</a>
<a name="ln669">  else</a>
<a name="ln670">  {</a>
<a name="ln671">    gchar *haystack = g_utf8_strdown(str, -1),</a>
<a name="ln672">          *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln673">    visible = (g_strrstr(haystack, needle) != NULL);</a>
<a name="ln674">    g_free(haystack);</a>
<a name="ln675">    g_free(needle);</a>
<a name="ln676">  }</a>
<a name="ln677"> </a>
<a name="ln678">  g_free(str);</a>
<a name="ln679"> </a>
<a name="ln680">  gtk_tree_store_set(GTK_TREE_STORE(model), iter, DT_LIB_COLLECT_COL_VISIBLE, visible, -1);</a>
<a name="ln681">  return FALSE;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">static gboolean tree_reveal_func(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln685">{</a>
<a name="ln686">  gboolean state;</a>
<a name="ln687">  GtkTreeIter parent, child = *iter;</a>
<a name="ln688"> </a>
<a name="ln689">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_VISIBLE, &amp;state, -1);</a>
<a name="ln690">  if(!state) return FALSE;</a>
<a name="ln691"> </a>
<a name="ln692">  while(gtk_tree_model_iter_parent(model, &amp;parent, &amp;child))</a>
<a name="ln693">  {</a>
<a name="ln694">    gtk_tree_model_get(model, &amp;parent, DT_LIB_COLLECT_COL_VISIBLE, &amp;state, -1);</a>
<a name="ln695">    gtk_tree_store_set(GTK_TREE_STORE(model), &amp;parent, DT_LIB_COLLECT_COL_VISIBLE, TRUE, -1);</a>
<a name="ln696">    child = parent;</a>
<a name="ln697">  }</a>
<a name="ln698"> </a>
<a name="ln699">  return FALSE;</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">static void tree_set_visibility(GtkTreeModel *model, gpointer data)</a>
<a name="ln703">{</a>
<a name="ln704">  gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)tree_match_string, data);</a>
<a name="ln705"> </a>
<a name="ln706">  gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)tree_reveal_func, NULL);</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">static void _lib_folders_update_collection(const gchar *filmroll)</a>
<a name="ln710">{</a>
<a name="ln711"> </a>
<a name="ln712">  gchar *complete_query = NULL;</a>
<a name="ln713"> </a>
<a name="ln714">  // remove from selected images where not in this query.</a>
<a name="ln715">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln716">  const gchar *cquery = dt_collection_get_query(darktable.collection);</a>
<a name="ln717">  // complete_query = NULL;</a>
<a name="ln718">  if(cquery &amp;&amp; cquery[0] != '\0')</a>
<a name="ln719">  {</a>
<a name="ln720">    complete_query</a>
<a name="ln721">        = dt_util_dstrcat(complete_query, &quot;DELETE FROM main.selected_images WHERE imgid NOT IN (%s)&quot;, cquery);</a>
<a name="ln722">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), complete_query, -1, &amp;stmt, NULL);</a>
<a name="ln723">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, 0);</a>
<a name="ln724">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, -1);</a>
<a name="ln725">    sqlite3_step(stmt);</a>
<a name="ln726">    sqlite3_finalize(stmt);</a>
<a name="ln727"> </a>
<a name="ln728">    /* free allocated strings */</a>
<a name="ln729">    g_free(complete_query);</a>
<a name="ln730">  }</a>
<a name="ln731"> </a>
<a name="ln732">  /* raise signal of collection change, only if this is an original */</a>
<a name="ln733">  if(!darktable.collection-&gt;clone) dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">static void set_properties(dt_lib_collect_rule_t *dr)</a>
<a name="ln737">{</a>
<a name="ln738">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln739">  const gchar *text = gtk_entry_get_text(GTK_ENTRY(dr-&gt;text));</a>
<a name="ln740"> </a>
<a name="ln741">  char confname[200] = { 0 };</a>
<a name="ln742">  snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, dr-&gt;num);</a>
<a name="ln743">  dt_conf_set_string(confname, text);</a>
<a name="ln744">  snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, dr-&gt;num);</a>
<a name="ln745">  dt_conf_set_int(confname, property);</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">static GtkTreeModel *_create_filtered_model(GtkTreeModel *model, dt_lib_collect_rule_t *dr)</a>
<a name="ln749">{</a>
<a name="ln750">  GtkTreeModel *filter = NULL;</a>
<a name="ln751">  GtkTreePath *path = NULL;</a>
<a name="ln752"> </a>
<a name="ln753">  if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_FOLDERS)</a>
<a name="ln754">  {</a>
<a name="ln755">    // we search a common path to all the folders</a>
<a name="ln756">    // we'll use it as root</a>
<a name="ln757">    GtkTreeIter child, iter;</a>
<a name="ln758">    int level = 0;</a>
<a name="ln759"> </a>
<a name="ln760">    while(gtk_tree_model_iter_n_children(model, level &gt; 0 ? &amp;iter : NULL) &gt; 0)</a>
<a name="ln761">    {</a>
<a name="ln762">      if(level &gt; 0)</a>
<a name="ln763">      {</a>
<a name="ln764">        sqlite3_stmt *stmt = NULL;</a>
<a name="ln765">        gchar *pth = NULL;</a>
<a name="ln766">        int id = -1;</a>
<a name="ln767">        // Check if this path also matches a filmroll</a>
<a name="ln768">        gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;pth, -1);</a>
<a name="ln769">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln770">                                    &quot;SELECT id FROM main.film_rolls WHERE folder LIKE ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln771">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, pth, -1, SQLITE_TRANSIENT);</a>
<a name="ln772">        if(sqlite3_step(stmt) == SQLITE_ROW) id = sqlite3_column_int(stmt, 0);</a>
<a name="ln773">        sqlite3_finalize(stmt);</a>
<a name="ln774"> </a>
<a name="ln775">        g_free(pth);</a>
<a name="ln776"> </a>
<a name="ln777">        if(id != -1)</a>
<a name="ln778">        {</a>
<a name="ln779">          // we go back to the parent, in order to show this folder</a>
<a name="ln780">          if(!gtk_tree_model_iter_parent(model, &amp;child, &amp;iter)) level = 0;</a>
<a name="ln781">          iter = child;</a>
<a name="ln782">          break;</a>
<a name="ln783">        }</a>
<a name="ln784">      }</a>
<a name="ln785">      if(gtk_tree_model_iter_n_children(model, level &gt; 0 ? &amp;iter : NULL) != 1) break;</a>
<a name="ln786"> </a>
<a name="ln787">      gtk_tree_model_iter_children(model, &amp;child, level &gt; 0 ? &amp;iter : NULL);</a>
<a name="ln788">      iter = child;</a>
<a name="ln789">      level++;</a>
<a name="ln790">    }</a>
<a name="ln791"> </a>
<a name="ln792">    if(level &gt; 0)</a>
<a name="ln793">    {</a>
<a name="ln794">      if(level &gt; 0 &amp;&amp;</a>
<a name="ln795">         gtk_tree_model_iter_n_children(model, &amp;iter) == 0 &amp;&amp;</a>
<a name="ln796">         gtk_tree_model_iter_parent(model, &amp;child, &amp;iter))</a>
<a name="ln797">      {</a>
<a name="ln798">        path = gtk_tree_model_get_path(model, &amp;child);</a>
<a name="ln799">      }</a>
<a name="ln800">      else</a>
<a name="ln801">      {</a>
<a name="ln802">        path = gtk_tree_model_get_path(model, &amp;iter);</a>
<a name="ln803">      }</a>
<a name="ln804">    }</a>
<a name="ln805">  }</a>
<a name="ln806"> </a>
<a name="ln807">  // Create filter and set virtual root</a>
<a name="ln808">  filter = gtk_tree_model_filter_new(model, path);</a>
<a name="ln809">  gtk_tree_path_free(path);</a>
<a name="ln810"> </a>
<a name="ln811">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(filter), DT_LIB_COLLECT_COL_VISIBLE);</a>
<a name="ln812"> </a>
<a name="ln813">  return filter;</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">static int string_array_length(char **list)</a>
<a name="ln817">{</a>
<a name="ln818">  int length = 0;</a>
<a name="ln819">  for(; *list; list++) length++;</a>
<a name="ln820">  return length;</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">// returns a NULL terminated array of path components</a>
<a name="ln824">static char **split_path(const char *path)</a>
<a name="ln825">{</a>
<a name="ln826">  if(!path || !*path) return NULL;</a>
<a name="ln827"> </a>
<a name="ln828">  char **result;</a>
<a name="ln829">  char **tokens = g_strsplit(path, G_DIR_SEPARATOR_S, -1);</a>
<a name="ln830"> </a>
<a name="ln831">#ifdef _WIN32</a>
<a name="ln832"> </a>
<a name="ln833">  if(! (g_ascii_isalpha(tokens[0][0]) &amp;&amp; tokens[0][strlen(tokens[0]) - 1] == ':') )</a>
<a name="ln834">  {</a>
<a name="ln835">    g_strfreev(tokens);</a>
<a name="ln836">    tokens = NULL;</a>
<a name="ln837">  }</a>
<a name="ln838"> </a>
<a name="ln839">  result = tokens;</a>
<a name="ln840"> </a>
<a name="ln841">#else</a>
<a name="ln842"> </a>
<a name="ln843">  // there are size + 1 elements in tokens -- the final NULL! we want to ignore it.</a>
<a name="ln844">  unsigned int size = g_strv_length(tokens);</a>
<a name="ln845"> </a>
<a name="ln846">  result = malloc(size * sizeof(char *));</a>
<a name="ln847">  for(unsigned int i = 0; i &lt; size; i++)</a>
<a name="ln848">    result[i] = tokens[i + 1];</a>
<a name="ln849"> </a>
<a name="ln850">  g_free(tokens[0]);</a>
<a name="ln851">  g_free(tokens);</a>
<a name="ln852"> </a>
<a name="ln853">#endif</a>
<a name="ln854"> </a>
<a name="ln855">  return result;</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">typedef struct name_key_tuple_t</a>
<a name="ln859">{</a>
<a name="ln860">  char *name, *collate_key;</a>
<a name="ln861">  int count;</a>
<a name="ln862">} name_key_tuple_t;</a>
<a name="ln863"> </a>
<a name="ln864">static void free_tuple(gpointer data)</a>
<a name="ln865">{</a>
<a name="ln866">  name_key_tuple_t *tuple = (name_key_tuple_t *)data;</a>
<a name="ln867">  g_free(tuple-&gt;name);</a>
<a name="ln868">  g_free(tuple-&gt;collate_key);</a>
<a name="ln869">  free(tuple);</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872">static gint sort_folder_tag(gconstpointer a, gconstpointer b)</a>
<a name="ln873">{</a>
<a name="ln874">  const name_key_tuple_t *tuple_a = (const name_key_tuple_t *)a;</a>
<a name="ln875">  const name_key_tuple_t *tuple_b = (const name_key_tuple_t *)b;</a>
<a name="ln876"> </a>
<a name="ln877">  return g_strcmp0(tuple_a-&gt;collate_key, tuple_b-&gt;collate_key);</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880">// create a key such that &quot;darktable|&quot; is coming first, and the rest is ordered such that sub tags are coming directly</a>
<a name="ln881">// behind their parent</a>
<a name="ln882">static char *tag_collate_key(char *tag)</a>
<a name="ln883">{</a>
<a name="ln884">  size_t len = strlen(tag);</a>
<a name="ln885">  char *result = g_malloc(len + 2);</a>
<a name="ln886">  if(g_str_has_prefix(tag, &quot;darktable|&quot;))</a>
<a name="ln887">    *result = '\1';</a>
<a name="ln888">  else</a>
<a name="ln889">    *result = '\2';</a>
<a name="ln890">  memcpy(result + 1, tag, len + 1);</a>
<a name="ln891">  for(char *iter = result + 1; *iter; iter++)</a>
<a name="ln892">    if(*iter == '|') *iter = '\1';</a>
<a name="ln893">  return result;</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896"> </a>
<a name="ln897">void tree_count_show(GtkTreeViewColumn *col, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter,</a>
<a name="ln898">                     gpointer data)</a>
<a name="ln899">{</a>
<a name="ln900">  gchar *name;</a>
<a name="ln901">  guint count;</a>
<a name="ln902"> </a>
<a name="ln903">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_TEXT, &amp;name, DT_LIB_COLLECT_COL_COUNT, &amp;count, -1);</a>
<a name="ln904">  if (!count)</a>
<a name="ln905">  {</a>
<a name="ln906">    g_object_set(renderer, &quot;text&quot;, name, NULL);</a>
<a name="ln907">  }</a>
<a name="ln908">  else</a>
<a name="ln909">  {</a>
<a name="ln910">    gchar *coltext = g_strdup_printf(&quot;%s (%d)&quot;, name, count);</a>
<a name="ln911">    g_object_set(renderer, &quot;text&quot;, coltext, NULL);</a>
<a name="ln912">    g_free(coltext);</a>
<a name="ln913">  }</a>
<a name="ln914"> </a>
<a name="ln915">  g_free(name);</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">static const char *UNCATEGORIZED_TAG = N_(&quot;uncategorized&quot;);</a>
<a name="ln919">static void tree_view(dt_lib_collect_rule_t *dr)</a>
<a name="ln920">{</a>
<a name="ln921">  // update related list</a>
<a name="ln922">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln923">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln924">  const gboolean folders = (property == DT_COLLECTION_PROP_FOLDERS);</a>
<a name="ln925">  const gboolean tags = (property == DT_COLLECTION_PROP_TAG);</a>
<a name="ln926">  const gboolean days = (property == DT_COLLECTION_PROP_DAY);</a>
<a name="ln927">  const gboolean times = (property == DT_COLLECTION_PROP_TIME);</a>
<a name="ln928">  const char *format_separator = folders ? &quot;%s&quot; G_DIR_SEPARATOR_S :</a>
<a name="ln929">  days || times ? &quot;%s:&quot; : &quot;%s|&quot;;</a>
<a name="ln930"> </a>
<a name="ln931">  set_properties(dr);</a>
<a name="ln932"> </a>
<a name="ln933">  GtkTreeModel *model = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(d-&gt;treefilter));</a>
<a name="ln934"> </a>
<a name="ln935">  if(d-&gt;view_rule != property)</a>
<a name="ln936">  {</a>
<a name="ln937">    // tree creation/recreation</a>
<a name="ln938">    sqlite3_stmt *stmt;</a>
<a name="ln939">    GtkTreeIter uncategorized = { 0 };</a>
<a name="ln940">    GtkTreeIter temp;</a>
<a name="ln941"> </a>
<a name="ln942">    g_object_ref(model);</a>
<a name="ln943">    g_object_unref(d-&gt;treefilter);</a>
<a name="ln944">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), NULL);</a>
<a name="ln945">    gtk_tree_store_clear(GTK_TREE_STORE(model));</a>
<a name="ln946">    gtk_widget_hide(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln947">    gtk_widget_hide(GTK_WIDGET(d-&gt;sw2));</a>
<a name="ln948"> </a>
<a name="ln949">    /* query construction */</a>
<a name="ln950">    gchar *where_ext = dt_collection_get_extended_where(darktable.collection, dr-&gt;num);</a>
<a name="ln951">    const char *query = g_strdup_printf(</a>
<a name="ln952">            folders ? &quot;SELECT folder, film_rolls_id, COUNT(*) AS count FROM main.images AS mi &quot;</a>
<a name="ln953">                    &quot;JOIN (SELECT id AS film_rolls_id, folder FROM main.film_rolls) ON film_id = film_rolls_id &quot;</a>
<a name="ln954">                    &quot;WHERE %s GROUP BY folder, film_rolls_id&quot;:</a>
<a name="ln955">            tags ? &quot;SELECT name, tag_id, COUNT(*) AS count FROM main.images AS mi JOIN main.tagged_images ON id = imgid &quot;</a>
<a name="ln956">                    &quot;JOIN (SELECT name, id AS tag_id FROM data.tags) ON tagid = tag_id &quot;</a>
<a name="ln957">                    &quot;WHERE %s GROUP BY name,tag_id&quot; :</a>
<a name="ln958">            days ? &quot;SELECT SUBSTR(datetime_taken, 1, 10) AS date, 1, COUNT(*) AS count FROM main.images AS mi &quot;</a>
<a name="ln959">                    &quot;WHERE %s GROUP BY date ORDER BY datetime_taken ASC&quot; :</a>
<a name="ln960">            times ? &quot;SELECT datetime_taken AS date, 1, COUNT(*) AS count FROM main.images AS mi &quot;</a>
<a name="ln961">                    &quot;WHERE %s GROUP BY date ORDER BY datetime_taken ASC&quot; :</a>
<a name="ln962">            NULL,</a>
<a name="ln963">            where_ext);</a>
<a name="ln964"> </a>
<a name="ln965">    g_free(where_ext);</a>
<a name="ln966">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln967"> </a>
<a name="ln968">    char **last_tokens = NULL;</a>
<a name="ln969">    int last_tokens_length = 0;</a>
<a name="ln970">    GtkTreeIter last_parent = { 0 };</a>
<a name="ln971"> </a>
<a name="ln972">    // we need to sort the names ourselves and not let sqlite handle this</a>
<a name="ln973">    // because it knows nothing about path separators.</a>
<a name="ln974">    GList *sorted_names = NULL;</a>
<a name="ln975">    while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln976">    {</a>
<a name="ln977">      char *name = g_strdup((const char *)sqlite3_column_text(stmt, 0));</a>
<a name="ln978">      gchar *collate_key = NULL;</a>
<a name="ln979"> </a>
<a name="ln980">      const int count = sqlite3_column_int(stmt, 2);</a>
<a name="ln981"> </a>
<a name="ln982">      if(folders)</a>
<a name="ln983">      {</a>
<a name="ln984">        char *name_folded = g_utf8_casefold(name, -1);</a>
<a name="ln985">        char *name_folded_slash = g_strconcat(name_folded, G_DIR_SEPARATOR_S, NULL);</a>
<a name="ln986">        collate_key = g_utf8_collate_key_for_filename(name_folded_slash, -1);</a>
<a name="ln987">        g_free(name_folded_slash);</a>
<a name="ln988">        g_free(name_folded);</a>
<a name="ln989">      }</a>
<a name="ln990">      else if(tags)</a>
<a name="ln991">        collate_key = tag_collate_key(name);</a>
<a name="ln992"> </a>
<a name="ln993">      name_key_tuple_t *tuple = (name_key_tuple_t *)malloc(sizeof(name_key_tuple_t));</a>
<a name="ln994">      tuple-&gt;name = name;</a>
<a name="ln995">      tuple-&gt;collate_key = collate_key;</a>
<a name="ln996">      tuple-&gt;count = count;</a>
<a name="ln997">      sorted_names = g_list_prepend(sorted_names, tuple);</a>
<a name="ln998">    }</a>
<a name="ln999">    sqlite3_finalize(stmt);</a>
<a name="ln1000"> </a>
<a name="ln1001">    if(folders || tags)</a>
<a name="ln1002">      sorted_names = g_list_sort(sorted_names, sort_folder_tag);</a>
<a name="ln1003"> </a>
<a name="ln1004">    for(GList *names = sorted_names; names; names = g_list_next(names))</a>
<a name="ln1005">    {</a>
<a name="ln1006">      name_key_tuple_t *tuple = (name_key_tuple_t *)names-&gt;data;</a>
<a name="ln1007">      char *name = tuple-&gt;name;</a>
<a name="ln1008">      const int count = tuple-&gt;count;</a>
<a name="ln1009">      if(name == NULL) continue; // safeguard against degenerated db entries</a>
<a name="ln1010"> </a>
<a name="ln1011">      if(tags &amp;&amp; strchr(name, '|') == 0 &amp;&amp; (last_tokens_length == 0 || strcmp(name, *last_tokens)))</a>
<a name="ln1012">      {</a>
<a name="ln1013">        /* add uncategorized root iter if not exists */</a>
<a name="ln1014">        if(!uncategorized.stamp)</a>
<a name="ln1015">        {</a>
<a name="ln1016">          gtk_tree_store_insert(GTK_TREE_STORE(model), &amp;uncategorized, NULL, 0);</a>
<a name="ln1017">          gtk_tree_store_set(GTK_TREE_STORE(model), &amp;uncategorized, DT_LIB_COLLECT_COL_TEXT,</a>
<a name="ln1018">                             _(UNCATEGORIZED_TAG), DT_LIB_COLLECT_COL_PATH, &quot;&quot;, DT_LIB_COLLECT_COL_VISIBLE,</a>
<a name="ln1019">                             TRUE, -1);</a>
<a name="ln1020">        }</a>
<a name="ln1021"> </a>
<a name="ln1022">        /* adding an uncategorized tag */</a>
<a name="ln1023">        gtk_tree_store_insert(GTK_TREE_STORE(model), &amp;temp, &amp;uncategorized, -1);</a>
<a name="ln1024">        gtk_tree_store_set(GTK_TREE_STORE(model), &amp;temp, DT_LIB_COLLECT_COL_TEXT, name,</a>
<a name="ln1025">                           DT_LIB_COLLECT_COL_PATH, name, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1026">                           DT_LIB_COLLECT_COL_COUNT, count, -1);</a>
<a name="ln1027">      }</a>
<a name="ln1028">      else</a>
<a name="ln1029">      {</a>
<a name="ln1030">        char **tokens;</a>
<a name="ln1031">        if(folders)</a>
<a name="ln1032">          tokens = split_path(name);</a>
<a name="ln1033">        else if(days)</a>
<a name="ln1034">          tokens = g_strsplit(name, &quot;:&quot;, -1);</a>
<a name="ln1035">        else if(times)</a>
<a name="ln1036">          tokens = g_strsplit_set(name, &quot;: &quot;, 4);</a>
<a name="ln1037">        else</a>
<a name="ln1038">          tokens = g_strsplit(name, &quot;|&quot;, -1);</a>
<a name="ln1039"> </a>
<a name="ln1040">        if(tokens != NULL)</a>
<a name="ln1041">        {</a>
<a name="ln1042">          // find the number of common parts at the beginning of tokens and last_tokens</a>
<a name="ln1043">          GtkTreeIter parent = last_parent;</a>
<a name="ln1044">          int tokens_length = string_array_length(tokens);</a>
<a name="ln1045">          int common_length = 0;</a>
<a name="ln1046">          if(last_tokens)</a>
<a name="ln1047">          {</a>
<a name="ln1048">            while(tokens[common_length] &amp;&amp; last_tokens[common_length] &amp;&amp;</a>
<a name="ln1049">                  !g_strcmp0(tokens[common_length], last_tokens[common_length]))</a>
<a name="ln1050">            {</a>
<a name="ln1051">              common_length++;</a>
<a name="ln1052">            }</a>
<a name="ln1053"> </a>
<a name="ln1054">            // point parent iter to where the entries should be added</a>
<a name="ln1055">            for(int i = common_length; i &lt; last_tokens_length; i++)</a>
<a name="ln1056">            {</a>
<a name="ln1057">              gtk_tree_model_iter_parent(model, &amp;parent, &amp;last_parent);</a>
<a name="ln1058">              last_parent = parent;</a>
<a name="ln1059">            }</a>
<a name="ln1060">          }</a>
<a name="ln1061"> </a>
<a name="ln1062">          // insert everything from tokens past the common part</a>
<a name="ln1063"> </a>
<a name="ln1064">          char *pth = NULL;</a>
<a name="ln1065">#ifndef _WIN32</a>
<a name="ln1066">          if(folders) pth = g_strdup(&quot;/&quot;);</a>
<a name="ln1067">#endif</a>
<a name="ln1068">          for(int i = 0; i &lt; common_length; i++)</a>
<a name="ln1069">            pth = dt_util_dstrcat(pth, format_separator, tokens[i]);</a>
<a name="ln1070"> </a>
<a name="ln1071">          for(char **token = &amp;tokens[common_length]; *token; token++)</a>
<a name="ln1072">          {</a>
<a name="ln1073">            GtkTreeIter iter;</a>
<a name="ln1074"> </a>
<a name="ln1075">            pth = dt_util_dstrcat(pth, format_separator, *token);</a>
<a name="ln1076">            if(times &amp;&amp; !*(token + 1)) pth[10] = ' ';</a>
<a name="ln1077"> </a>
<a name="ln1078">            gchar *pth2 = g_strdup(pth);</a>
<a name="ln1079">            pth2[strlen(pth2) - 1] = '\0';</a>
<a name="ln1080">            gtk_tree_store_insert(GTK_TREE_STORE(model), &amp;iter, common_length &gt; 0 ? &amp;parent : NULL, -1);</a>
<a name="ln1081">            gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_TEXT, *token,</a>
<a name="ln1082">                               DT_LIB_COLLECT_COL_PATH, pth2, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1083">                               DT_LIB_COLLECT_COL_COUNT, (*(token + 1)?0:count), -1);</a>
<a name="ln1084"> </a>
<a name="ln1085">            // also add the item count to parents</a>
<a name="ln1086">            if((folders || days || times) &amp;&amp; !*(token + 1))</a>
<a name="ln1087">            {</a>
<a name="ln1088">              guint parentcount;</a>
<a name="ln1089">              GtkTreeIter parent2, child = iter;</a>
<a name="ln1090"> </a>
<a name="ln1091">              while(gtk_tree_model_iter_parent(model, &amp;parent2, &amp;child))</a>
<a name="ln1092">              {</a>
<a name="ln1093">                gtk_tree_model_get(model, &amp;parent2, DT_LIB_COLLECT_COL_COUNT, &amp;parentcount, -1);</a>
<a name="ln1094">                gtk_tree_store_set(GTK_TREE_STORE(model), &amp;parent2, DT_LIB_COLLECT_COL_COUNT, count + parentcount, -1);</a>
<a name="ln1095">                child = parent2;</a>
<a name="ln1096">              }</a>
<a name="ln1097">            }</a>
<a name="ln1098"> </a>
<a name="ln1099">            if(folders)</a>
<a name="ln1100">              gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_UNREACHABLE,</a>
<a name="ln1101">                                 !(g_file_test(pth, G_FILE_TEST_IS_DIR)), -1);</a>
<a name="ln1102">            common_length++;</a>
<a name="ln1103">            parent = iter;</a>
<a name="ln1104">            g_free(pth2);</a>
<a name="ln1105">          }</a>
<a name="ln1106"> </a>
<a name="ln1107">          g_free(pth);</a>
<a name="ln1108"> </a>
<a name="ln1109">          // remember things for the next round</a>
<a name="ln1110">          if(last_tokens) g_strfreev(last_tokens);</a>
<a name="ln1111">          last_tokens = tokens;</a>
<a name="ln1112">          last_parent = parent;</a>
<a name="ln1113">          last_tokens_length = tokens_length;</a>
<a name="ln1114">        }</a>
<a name="ln1115">      }</a>
<a name="ln1116">    }</a>
<a name="ln1117">    g_list_free_full(sorted_names, free_tuple);</a>
<a name="ln1118"> </a>
<a name="ln1119"> </a>
<a name="ln1120">    gtk_tree_view_set_tooltip_column(GTK_TREE_VIEW(d-&gt;view), DT_LIB_COLLECT_COL_TOOLTIP);</a>
<a name="ln1121"> </a>
<a name="ln1122">    d-&gt;treefilter = _create_filtered_model(model, dr);</a>
<a name="ln1123"> </a>
<a name="ln1124">    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(d-&gt;view));</a>
<a name="ln1125">    if(property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1126">    {</a>
<a name="ln1127">      gtk_tree_selection_set_mode(selection, GTK_SELECTION_MULTIPLE);</a>
<a name="ln1128">    }</a>
<a name="ln1129">    else</a>
<a name="ln1130">    {</a>
<a name="ln1131">      gtk_tree_selection_set_mode(selection, GTK_SELECTION_SINGLE);</a>
<a name="ln1132">    }</a>
<a name="ln1133"> </a>
<a name="ln1134">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), d-&gt;treefilter);</a>
<a name="ln1135">    gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;scrolledwindow), FALSE);</a>
<a name="ln1136">    gtk_widget_show_all(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln1137"> </a>
<a name="ln1138">    g_object_unref(model);</a>
<a name="ln1139">    g_strfreev(last_tokens);</a>
<a name="ln1140"> </a>
<a name="ln1141">    d-&gt;view_rule = property;</a>
<a name="ln1142">  }</a>
<a name="ln1143"> </a>
<a name="ln1144">  // if needed, we restrict the tree to matching entries</a>
<a name="ln1145">  if(dr-&gt;typing) tree_set_visibility(model, dr);</a>
<a name="ln1146">  // we update tree expansion and selection</a>
<a name="ln1147">  gtk_tree_selection_unselect_all(gtk_tree_view_get_selection(d-&gt;view));</a>
<a name="ln1148">  gtk_tree_view_collapse_all(d-&gt;view);</a>
<a name="ln1149"> </a>
<a name="ln1150">  if(property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1151">  {</a>
<a name="ln1152">    // test selection range [xxx;xxx]</a>
<a name="ln1153">    GRegex *regex;</a>
<a name="ln1154">    GMatchInfo *match_info;</a>
<a name="ln1155">    int match_count;</a>
<a name="ln1156"> </a>
<a name="ln1157">    regex = g_regex_new(&quot;^\\s*\\[\\s*(.*)\\s*;\\s*(.*)\\s*\\]\\s*$&quot;, 0, 0, NULL);</a>
<a name="ln1158">    g_regex_match_full(regex, gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1, 0, 0, &amp;match_info, NULL);</a>
<a name="ln1159">    match_count = g_match_info_get_match_count(match_info);</a>
<a name="ln1160"> </a>
<a name="ln1161">    if(match_count == 3)</a>
<a name="ln1162">    {</a>
<a name="ln1163">      _range_t *range = (_range_t *)calloc(1, sizeof(_range_t));</a>
<a name="ln1164">      /* inversed as dates are in reverse order */</a>
<a name="ln1165">      range-&gt;start = g_match_info_fetch(match_info, 2);</a>
<a name="ln1166">      range-&gt;stop = g_match_info_fetch(match_info, 1);</a>
<a name="ln1167"> </a>
<a name="ln1168">      gtk_tree_model_foreach(d-&gt;treefilter, (GtkTreeModelForeachFunc)range_select, range);</a>
<a name="ln1169">      if(range-&gt;path1 &amp;&amp; range-&gt;path2)</a>
<a name="ln1170">      {</a>
<a name="ln1171">        gtk_tree_selection_select_range(gtk_tree_view_get_selection(d-&gt;view), range-&gt;path1, range-&gt;path2);</a>
<a name="ln1172">      }</a>
<a name="ln1173">      g_free(range-&gt;start);</a>
<a name="ln1174">      g_free(range-&gt;stop);</a>
<a name="ln1175">      gtk_tree_path_free(range-&gt;path1);</a>
<a name="ln1176">      gtk_tree_path_free(range-&gt;path2);</a>
<a name="ln1177">      free(range);</a>
<a name="ln1178">    }</a>
<a name="ln1179">    else</a>
<a name="ln1180">      gtk_tree_model_foreach(d-&gt;treefilter, (GtkTreeModelForeachFunc)tree_expand, dr);</a>
<a name="ln1181"> </a>
<a name="ln1182">    g_match_info_free(match_info);</a>
<a name="ln1183">    g_regex_unref(regex);</a>
<a name="ln1184">  }</a>
<a name="ln1185">  else</a>
<a name="ln1186">    gtk_tree_model_foreach(d-&gt;treefilter, (GtkTreeModelForeachFunc)tree_expand, dr);</a>
<a name="ln1187">}</a>
<a name="ln1188"> </a>
<a name="ln1189">static void list_view(dt_lib_collect_rule_t *dr)</a>
<a name="ln1190">{</a>
<a name="ln1191">  // update related list</a>
<a name="ln1192">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln1193">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln1194"> </a>
<a name="ln1195">  set_properties(dr);</a>
<a name="ln1196"> </a>
<a name="ln1197">  GtkTreeModel *model = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(d-&gt;listfilter));</a>
<a name="ln1198">  if(d-&gt;view_rule != property)</a>
<a name="ln1199">  {</a>
<a name="ln1200">    sqlite3_stmt *stmt;</a>
<a name="ln1201">    GtkTreeIter iter;</a>
<a name="ln1202">    g_object_unref(d-&gt;listfilter);</a>
<a name="ln1203">    g_object_ref(model);</a>
<a name="ln1204">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), NULL);</a>
<a name="ln1205">    gtk_list_store_clear(GTK_LIST_STORE(model));</a>
<a name="ln1206">    gtk_widget_hide(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln1207">    gtk_widget_hide(GTK_WIDGET(d-&gt;sw2));</a>
<a name="ln1208">    gchar *where_ext = dt_collection_get_extended_where(darktable.collection, dr-&gt;num);</a>
<a name="ln1209"> </a>
<a name="ln1210">    char query[1024] = { 0 };</a>
<a name="ln1211"> </a>
<a name="ln1212">    switch(property)</a>
<a name="ln1213">    {</a>
<a name="ln1214">      case DT_COLLECTION_PROP_CAMERA:; // camera</a>
<a name="ln1215">        int index = 0;</a>
<a name="ln1216">        gchar *makermodel_query = NULL;</a>
<a name="ln1217">        makermodel_query = dt_util_dstrcat(makermodel_query, &quot;SELECT maker, model, COUNT(*) AS count &quot;</a>
<a name="ln1218">                &quot;FROM main.images AS mi WHERE %s GROUP BY maker, model&quot;, where_ext);</a>
<a name="ln1219"> </a>
<a name="ln1220">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1221">                                makermodel_query,</a>
<a name="ln1222">                                -1, &amp;stmt, NULL);</a>
<a name="ln1223"> </a>
<a name="ln1224">        while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1225">        {</a>
<a name="ln1226">          char *exif_maker = (char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln1227">          char *exif_model = (char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln1228">          const int count = sqlite3_column_int(stmt, 2);</a>
<a name="ln1229"> </a>
<a name="ln1230">          gchar *value =  dt_collection_get_makermodel(exif_maker, exif_model);</a>
<a name="ln1231"> </a>
<a name="ln1232">          gtk_list_store_append(GTK_LIST_STORE(model), &amp;iter);</a>
<a name="ln1233">          gtk_list_store_set(GTK_LIST_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_TEXT, value,</a>
<a name="ln1234">                             DT_LIB_COLLECT_COL_ID, index, DT_LIB_COLLECT_COL_TOOLTIP, value,</a>
<a name="ln1235">                             DT_LIB_COLLECT_COL_PATH, value, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1236">                             DT_LIB_COLLECT_COL_COUNT, count,</a>
<a name="ln1237">                             -1);</a>
<a name="ln1238"> </a>
<a name="ln1239">          g_free(value);</a>
<a name="ln1240">          index++;</a>
<a name="ln1241">        }</a>
<a name="ln1242">        g_free(makermodel_query);</a>
<a name="ln1243">        break;</a>
<a name="ln1244"> </a>
<a name="ln1245">      case DT_COLLECTION_PROP_HISTORY: // History, 2 hardcoded alternatives</a>
<a name="ln1246">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1247">                           &quot;altered WHEN 1 THEN '%s' ELSE '%s' END as altered, 1, COUNT(*) AS count &quot;</a>
<a name="ln1248">                           &quot;FROM main.images AS mi LEFT JOIN &quot;</a>
<a name="ln1249">                           &quot;(SELECT DISTINCT imgid AS history_id, 1 AS altered FROM main.history) ON id = history_id &quot;</a>
<a name="ln1250">                           &quot;WHERE %s GROUP BY altered ORDER BY altered ASC&quot;,</a>
<a name="ln1251">                   _(&quot;altered&quot;),  _(&quot;not altered&quot;), where_ext);</a>
<a name="ln1252">        break;</a>
<a name="ln1253"> </a>
<a name="ln1254">      case DT_COLLECTION_PROP_GEOTAGGING: // Geotagging, 2 hardcoded alternatives</a>
<a name="ln1255">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1256">                           &quot;WHEN latitude IS NOT NULL AND longitude IS NOT NULL THEN '%s' ELSE '%s' END as tagged, 1, &quot;</a>
<a name="ln1257">                           &quot;COUNT(*) AS count &quot;</a>
<a name="ln1258">                           &quot;FROM main.images AS mi &quot;</a>
<a name="ln1259">                           &quot;WHERE %s GROUP BY tagged ORDER BY tagged ASC&quot;,</a>
<a name="ln1260">                       _(&quot;tagged&quot;),  _(&quot;not tagged&quot;), where_ext);</a>
<a name="ln1261">        break;</a>
<a name="ln1262"> </a>
<a name="ln1263">      case DT_COLLECTION_PROP_LOCAL_COPY: // local copy, 2 hardcoded alternatives</a>
<a name="ln1264">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1265">                           &quot;WHEN (flags &amp; %d) THEN '%s' ELSE '%s' END as lcp, 1, &quot;</a>
<a name="ln1266">                           &quot;COUNT(*) AS count &quot;</a>
<a name="ln1267">                           &quot;FROM main.images AS mi &quot;</a>
<a name="ln1268">                           &quot;WHERE %s GROUP BY lcp ORDER BY lcp ASC&quot;,</a>
<a name="ln1269">                   DT_IMAGE_LOCAL_COPY, _(&quot;copied locally&quot;),  _(&quot;not copied locally&quot;), where_ext);</a>
<a name="ln1270">        break;</a>
<a name="ln1271"> </a>
<a name="ln1272">      case DT_COLLECTION_PROP_ASPECT_RATIO: // aspect ratio, 3 hardcoded alternatives</a>
<a name="ln1273">        g_snprintf(query, sizeof(query), &quot;SELECT ROUND(aspect_ratio,1), 1, COUNT(*) AS count FROM main.images AS mi &quot;</a>
<a name="ln1274">                   &quot;WHERE %s GROUP BY ROUND(aspect_ratio,1)&quot;, where_ext);</a>
<a name="ln1275">        break;</a>
<a name="ln1276"> </a>
<a name="ln1277">      case DT_COLLECTION_PROP_COLORLABEL: // colorlabels</a>
<a name="ln1278">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1279">                           &quot;color WHEN 0 THEN '%s' WHEN 1 THEN '%s' WHEN 2 THEN '%s' WHEN 3 THEN '%s' WHEN 4 THEN '%s' &quot;</a>
<a name="ln1280">                           &quot;ELSE '' END, color, COUNT(*) AS count &quot;</a>
<a name="ln1281">                           &quot;FROM main.images AS mi JOIN &quot;</a>
<a name="ln1282">                           &quot;(SELECT imgid AS color_labels_id, color FROM main.color_labels) ON id = color_labels_id &quot;</a>
<a name="ln1283">                           &quot;WHERE %s GROUP BY color ORDER BY color DESC&quot;,</a>
<a name="ln1284">                   _(&quot;red&quot;), _(&quot;yellow&quot;), _(&quot;green&quot;), _(&quot;blue&quot;), _(&quot;purple&quot;), where_ext);</a>
<a name="ln1285">        break;</a>
<a name="ln1286"> </a>
<a name="ln1287">      // TODO: Add empty string for metadata?</a>
<a name="ln1288">      // TODO: Autogenerate this code?</a>
<a name="ln1289">      case DT_COLLECTION_PROP_TITLE: // title</a>
<a name="ln1290">        snprintf(query, sizeof(query),</a>
<a name="ln1291">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images AS mi JOIN &quot;</a>
<a name="ln1292">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1293">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1294">                 DT_METADATA_XMP_DC_TITLE, where_ext);</a>
<a name="ln1295">        break;</a>
<a name="ln1296">      case DT_COLLECTION_PROP_DESCRIPTION: // description</a>
<a name="ln1297">        snprintf(query, sizeof(query),</a>
<a name="ln1298">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images AS mi JOIN &quot;</a>
<a name="ln1299">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1300">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1301">                 DT_METADATA_XMP_DC_DESCRIPTION, where_ext);</a>
<a name="ln1302">        break;</a>
<a name="ln1303">      case DT_COLLECTION_PROP_CREATOR: // creator</a>
<a name="ln1304">        snprintf(query, sizeof(query),</a>
<a name="ln1305">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images AS mi JOIN &quot;</a>
<a name="ln1306">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1307">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1308">                 DT_METADATA_XMP_DC_CREATOR, where_ext);</a>
<a name="ln1309">        break;</a>
<a name="ln1310">      case DT_COLLECTION_PROP_PUBLISHER: // publisher</a>
<a name="ln1311">        snprintf(query, sizeof(query),</a>
<a name="ln1312">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images AS mi JOIN &quot;</a>
<a name="ln1313">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1314">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1315">                 DT_METADATA_XMP_DC_PUBLISHER, where_ext);</a>
<a name="ln1316">        break;</a>
<a name="ln1317">      case DT_COLLECTION_PROP_RIGHTS: // rights</a>
<a name="ln1318">        snprintf(query, sizeof(query),</a>
<a name="ln1319">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images AS mi JOIN &quot;</a>
<a name="ln1320">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1321">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1322">                 DT_METADATA_XMP_DC_RIGHTS, where_ext);</a>
<a name="ln1323">        break;</a>
<a name="ln1324">      case DT_COLLECTION_PROP_LENS: // lens</a>
<a name="ln1325">        g_snprintf(query, sizeof(query), &quot;SELECT lens, 1, COUNT(*) AS count &quot;</a>
<a name="ln1326">                &quot;FROM main.images AS mi WHERE %s GROUP BY lens ORDER BY lens&quot;, where_ext);</a>
<a name="ln1327">        break;</a>
<a name="ln1328"> </a>
<a name="ln1329">      case DT_COLLECTION_PROP_FOCAL_LENGTH: // focal length</a>
<a name="ln1330">        g_snprintf(query, sizeof(query), &quot;SELECT CAST(focal_length AS INTEGER) AS focal_length, 1, COUNT(*) AS count &quot;</a>
<a name="ln1331">                         &quot;FROM main.images AS mi WHERE %s GROUP BY focal_length ORDER BY focal_length&quot;,</a>
<a name="ln1332">                   where_ext);</a>
<a name="ln1333">        break;</a>
<a name="ln1334"> </a>
<a name="ln1335">      case DT_COLLECTION_PROP_ISO: // iso</a>
<a name="ln1336">        g_snprintf(query, sizeof(query), &quot;SELECT CAST(iso AS INTEGER) AS iso, 1, COUNT(*) AS count &quot;</a>
<a name="ln1337">                           &quot;FROM main.images AS mi WHERE %s GROUP BY iso ORDER BY iso&quot;,</a>
<a name="ln1338">                   where_ext);</a>
<a name="ln1339">        break;</a>
<a name="ln1340"> </a>
<a name="ln1341">      case DT_COLLECTION_PROP_APERTURE: // aperture</a>
<a name="ln1342">        g_snprintf(query, sizeof(query), &quot;SELECT ROUND(aperture,1) AS aperture, 1, COUNT(*) AS count &quot;</a>
<a name="ln1343">                           &quot;FROM main.images AS mi WHERE %s GROUP BY aperture ORDER BY aperture&quot;,</a>
<a name="ln1344">                   where_ext);</a>
<a name="ln1345">        break;</a>
<a name="ln1346"> </a>
<a name="ln1347">      case DT_COLLECTION_PROP_EXPOSURE: // exposure</a>
<a name="ln1348">        g_snprintf(query, sizeof(query), &quot;SELECT CASE WHEN (exposure &lt; 0.4) &quot;</a>
<a name="ln1349">                              &quot;THEN '1/' || CAST(1/exposure + 0.9 AS INTEGER) &quot;</a>
<a name="ln1350">                           &quot;ELSE ROUND(exposure,2) || '\&quot;' END as _exposure, 1, COUNT(*) AS count &quot;</a>
<a name="ln1351">                &quot;FROM main.images AS mi WHERE %s GROUP BY _exposure ORDER BY exposure&quot;,</a>
<a name="ln1352">                  where_ext);</a>
<a name="ln1353">        break;</a>
<a name="ln1354"> </a>
<a name="ln1355">      case DT_COLLECTION_PROP_FILENAME: // filename</a>
<a name="ln1356">        g_snprintf(query, sizeof(query), &quot;SELECT filename, 1, COUNT(*) AS count &quot;</a>
<a name="ln1357">                &quot;FROM main.images AS mi WHERE %s GROUP BY filename ORDER BY filename&quot;, where_ext);</a>
<a name="ln1358">        break;</a>
<a name="ln1359"> </a>
<a name="ln1360">      default: // filmroll</a>
<a name="ln1361">        g_snprintf(query, sizeof(query), &quot;SELECT folder, film_rolls_id, COUNT(*) AS count &quot;</a>
<a name="ln1362">                &quot;FROM main.images AS mi JOIN &quot;</a>
<a name="ln1363">                &quot;(SELECT id AS film_rolls_id, folder FROM main.film_rolls) ON film_id = film_rolls_id &quot;</a>
<a name="ln1364">                &quot;WHERE %s GROUP BY folder ORDER BY folder DESC&quot;, where_ext);</a>
<a name="ln1365">        break;</a>
<a name="ln1366"> </a>
<a name="ln1367">      case DT_COLLECTION_PROP_GROUPING: // Grouping, 2 hardcoded alternatives</a>
<a name="ln1368">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1369">                           &quot;WHEN id = group_id THEN '%s' ELSE '%s' END as group_leader, 1, &quot;</a>
<a name="ln1370">                           &quot;COUNT(*) AS count &quot;</a>
<a name="ln1371">                           &quot;FROM main.images AS mi &quot;</a>
<a name="ln1372">                           &quot;WHERE %s GROUP BY group_leader ORDER BY group_leader ASC&quot;,</a>
<a name="ln1373">                   _(&quot;group leaders&quot;),  _(&quot;group followers&quot;), where_ext);</a>
<a name="ln1374">        break;</a>
<a name="ln1375">    }</a>
<a name="ln1376"> </a>
<a name="ln1377">    g_free(where_ext);</a>
<a name="ln1378"> </a>
<a name="ln1379">    if(strlen(query) &gt; 0)</a>
<a name="ln1380">    {</a>
<a name="ln1381">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln1382">      while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1383">      {</a>
<a name="ln1384">        const char *folder = (const char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln1385">        if(folder == NULL) continue; // safeguard against degenerated db entries</a>
<a name="ln1386"> </a>
<a name="ln1387">        gtk_list_store_append(GTK_LIST_STORE(model), &amp;iter);</a>
<a name="ln1388">        if(property == DT_COLLECTION_PROP_FILMROLL)</a>
<a name="ln1389">        {</a>
<a name="ln1390">          folder = dt_image_film_roll_name(folder);</a>
<a name="ln1391">        }</a>
<a name="ln1392">        gchar *value = (gchar *)sqlite3_column_text(stmt, 0);</a>
<a name="ln1393">        const int count = sqlite3_column_int(stmt, 2);</a>
<a name="ln1394"> </a>
<a name="ln1395">        // replace invalid utf8 characters if any</a>
<a name="ln1396">        gchar *text = g_strdup(value);</a>
<a name="ln1397">        gchar *ptr = text;</a>
<a name="ln1398">        while(!g_utf8_validate(ptr, -1, (const gchar **)&amp;ptr)) ptr[0] = '?';</a>
<a name="ln1399"> </a>
<a name="ln1400">        gchar *escaped_text = g_markup_escape_text(text, -1);</a>
<a name="ln1401"> </a>
<a name="ln1402">        gtk_list_store_set(GTK_LIST_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_TEXT, folder,</a>
<a name="ln1403">                           DT_LIB_COLLECT_COL_ID, sqlite3_column_int(stmt, 1), DT_LIB_COLLECT_COL_TOOLTIP,</a>
<a name="ln1404">                           escaped_text, DT_LIB_COLLECT_COL_PATH, value, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1405">                           DT_LIB_COLLECT_COL_COUNT, count,</a>
<a name="ln1406">                           -1);</a>
<a name="ln1407">        g_free(text);</a>
<a name="ln1408">        g_free(escaped_text);</a>
<a name="ln1409">      }</a>
<a name="ln1410">      sqlite3_finalize(stmt);</a>
<a name="ln1411">    }</a>
<a name="ln1412"> </a>
<a name="ln1413">    gtk_tree_view_set_tooltip_column(GTK_TREE_VIEW(d-&gt;view), DT_LIB_COLLECT_COL_TOOLTIP);</a>
<a name="ln1414"> </a>
<a name="ln1415">    d-&gt;listfilter = _create_filtered_model(model, dr);</a>
<a name="ln1416"> </a>
<a name="ln1417">    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(d-&gt;view));</a>
<a name="ln1418">    if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln1419">       || property == DT_COLLECTION_PROP_ISO || property == DT_COLLECTION_PROP_EXPOSURE</a>
<a name="ln1420">       || property == DT_COLLECTION_PROP_ASPECT_RATIO)</a>
<a name="ln1421">    {</a>
<a name="ln1422">      gtk_tree_selection_set_mode(selection, GTK_SELECTION_MULTIPLE);</a>
<a name="ln1423">    }</a>
<a name="ln1424">    else</a>
<a name="ln1425">    {</a>
<a name="ln1426">      gtk_tree_selection_set_mode(selection, GTK_SELECTION_SINGLE);</a>
<a name="ln1427">    }</a>
<a name="ln1428"> </a>
<a name="ln1429">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), d-&gt;listfilter);</a>
<a name="ln1430">    gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;scrolledwindow), FALSE);</a>
<a name="ln1431">    gtk_widget_show_all(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln1432"> </a>
<a name="ln1433">    g_object_unref(model);</a>
<a name="ln1434"> </a>
<a name="ln1435">    d-&gt;view_rule = property;</a>
<a name="ln1436">  }</a>
<a name="ln1437"> </a>
<a name="ln1438">  // if needed, we restrict the tree to matching entries</a>
<a name="ln1439">  if(dr-&gt;typing &amp;&amp; (property == DT_COLLECTION_PROP_CAMERA || property == DT_COLLECTION_PROP_CREATOR</a>
<a name="ln1440">                    || property == DT_COLLECTION_PROP_DESCRIPTION || property == DT_COLLECTION_PROP_FILENAME</a>
<a name="ln1441">                    || property == DT_COLLECTION_PROP_FILMROLL || property == DT_COLLECTION_PROP_LENS</a>
<a name="ln1442">                    || property == DT_COLLECTION_PROP_PUBLISHER || property == DT_COLLECTION_PROP_RIGHTS</a>
<a name="ln1443">                    || property == DT_COLLECTION_PROP_TITLE || property == DT_COLLECTION_PROP_APERTURE</a>
<a name="ln1444">                    || property == DT_COLLECTION_PROP_FOCAL_LENGTH || property == DT_COLLECTION_PROP_ISO))</a>
<a name="ln1445">    gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)list_match_string, dr);</a>
<a name="ln1446">  // we update list selection</a>
<a name="ln1447">  gtk_tree_selection_unselect_all(gtk_tree_view_get_selection(d-&gt;view));</a>
<a name="ln1448"> </a>
<a name="ln1449">  if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln1450">     || property == DT_COLLECTION_PROP_ISO || property == DT_COLLECTION_PROP_EXPOSURE</a>
<a name="ln1451">     || property == DT_COLLECTION_PROP_ASPECT_RATIO)</a>
<a name="ln1452">  {</a>
<a name="ln1453">    // test selection range [xxx;xxx]</a>
<a name="ln1454">    GRegex *regex;</a>
<a name="ln1455">    GMatchInfo *match_info;</a>
<a name="ln1456">    int match_count;</a>
<a name="ln1457"> </a>
<a name="ln1458">    regex = g_regex_new(&quot;^\\s*\\[\\s*(.*)\\s*;\\s*(.*)\\s*\\]\\s*$&quot;, 0, 0, NULL);</a>
<a name="ln1459">    g_regex_match_full(regex, gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1, 0, 0, &amp;match_info, NULL);</a>
<a name="ln1460">    match_count = g_match_info_get_match_count(match_info);</a>
<a name="ln1461"> </a>
<a name="ln1462">    if(match_count == 3)</a>
<a name="ln1463">    {</a>
<a name="ln1464">      _range_t *range = (_range_t *)calloc(1, sizeof(_range_t));</a>
<a name="ln1465">      range-&gt;start = g_match_info_fetch(match_info, 1);</a>
<a name="ln1466">      range-&gt;stop = g_match_info_fetch(match_info, 2);</a>
<a name="ln1467"> </a>
<a name="ln1468">      gtk_tree_model_foreach(d-&gt;listfilter, (GtkTreeModelForeachFunc)range_select, range);</a>
<a name="ln1469">      if(range-&gt;path1 &amp;&amp; range-&gt;path2)</a>
<a name="ln1470">      {</a>
<a name="ln1471">        gtk_tree_selection_select_range(gtk_tree_view_get_selection(d-&gt;view), range-&gt;path1, range-&gt;path2);</a>
<a name="ln1472">      }</a>
<a name="ln1473">      g_free(range-&gt;start);</a>
<a name="ln1474">      g_free(range-&gt;stop);</a>
<a name="ln1475">      gtk_tree_path_free(range-&gt;path1);</a>
<a name="ln1476">      gtk_tree_path_free(range-&gt;path2);</a>
<a name="ln1477">      free(range);</a>
<a name="ln1478">    }</a>
<a name="ln1479">    else</a>
<a name="ln1480">      gtk_tree_model_foreach(d-&gt;listfilter, (GtkTreeModelForeachFunc)list_select, dr);</a>
<a name="ln1481"> </a>
<a name="ln1482">    g_match_info_free(match_info);</a>
<a name="ln1483">    g_regex_unref(regex);</a>
<a name="ln1484">  }</a>
<a name="ln1485">  else</a>
<a name="ln1486">    gtk_tree_model_foreach(d-&gt;listfilter, (GtkTreeModelForeachFunc)list_select, dr);</a>
<a name="ln1487">}</a>
<a name="ln1488"> </a>
<a name="ln1489">static void update_view(dt_lib_collect_rule_t *dr)</a>
<a name="ln1490">{</a>
<a name="ln1491">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln1492"> </a>
<a name="ln1493">  if(property == DT_COLLECTION_PROP_FOLDERS || property == DT_COLLECTION_PROP_TAG</a>
<a name="ln1494">     || property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1495">    tree_view(dr);</a>
<a name="ln1496">  else</a>
<a name="ln1497">    list_view(dr);</a>
<a name="ln1498">}</a>
<a name="ln1499"> </a>
<a name="ln1500"> </a>
<a name="ln1501">static void _lib_collect_gui_update(dt_lib_module_t *self)</a>
<a name="ln1502">{</a>
<a name="ln1503">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln1504"> </a>
<a name="ln1505">  // we check if something as change since last call</a>
<a name="ln1506">  if(d-&gt;view_rule != -1) return;</a>
<a name="ln1507"> </a>
<a name="ln1508">  const int reset = darktable.gui-&gt;reset;</a>
<a name="ln1509">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1510">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;) - 1;</a>
<a name="ln1511">  const int active = CLAMP(_a, 0, (MAX_RULES - 1));</a>
<a name="ln1512">  d-&gt;nb_rules = active + 1;</a>
<a name="ln1513">  char confname[200] = { 0 };</a>
<a name="ln1514"> </a>
<a name="ln1515">  gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;scrolledwindow), TRUE);</a>
<a name="ln1516">  gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;sw2), TRUE);</a>
<a name="ln1517"> </a>
<a name="ln1518">  for(int i = 0; i &lt; MAX_RULES; i++)</a>
<a name="ln1519">  {</a>
<a name="ln1520">    gtk_widget_set_no_show_all(d-&gt;rule[i].hbox, TRUE);</a>
<a name="ln1521">    gtk_widget_set_visible(d-&gt;rule[i].hbox, FALSE);</a>
<a name="ln1522">  }</a>
<a name="ln1523">  for(int i = 0; i &lt;= active; i++)</a>
<a name="ln1524">  {</a>
<a name="ln1525">    gtk_widget_set_no_show_all(d-&gt;rule[i].hbox, FALSE);</a>
<a name="ln1526">    gtk_widget_set_visible(d-&gt;rule[i].hbox, TRUE);</a>
<a name="ln1527">    gtk_widget_show_all(d-&gt;rule[i].hbox);</a>
<a name="ln1528">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln1529">    gtk_combo_box_set_active(GTK_COMBO_BOX(d-&gt;rule[i].combo), dt_conf_get_int(confname));</a>
<a name="ln1530">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln1531">    gchar *text = dt_conf_get_string(confname);</a>
<a name="ln1532">    if(text)</a>
<a name="ln1533">    {</a>
<a name="ln1534">      g_signal_handlers_block_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1535">      g_signal_handlers_block_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1536">      gtk_entry_set_text(GTK_ENTRY(d-&gt;rule[i].text), text);</a>
<a name="ln1537">      gtk_editable_set_position(GTK_EDITABLE(d-&gt;rule[i].text), -1);</a>
<a name="ln1538">      g_signal_handlers_unblock_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1539">      g_signal_handlers_unblock_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1540">      g_free(text);</a>
<a name="ln1541">      d-&gt;rule[i].typing = FALSE;</a>
<a name="ln1542">    }</a>
<a name="ln1543"> </a>
<a name="ln1544">    GtkDarktableButton *button = DTGTK_BUTTON(d-&gt;rule[i].button);</a>
<a name="ln1545">    if(i == MAX_RULES - 1)</a>
<a name="ln1546">    {</a>
<a name="ln1547">      // only clear</a>
<a name="ln1548">      button-&gt;icon = dtgtk_cairo_paint_cancel;</a>
<a name="ln1549">      gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;clear this rule&quot;));</a>
<a name="ln1550">    }</a>
<a name="ln1551">    else if(i == active)</a>
<a name="ln1552">    {</a>
<a name="ln1553">      gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;clear this rule or add new rules&quot;));</a>
<a name="ln1554">      gint flags = CPF_DIRECTION_DOWN | CPF_BG_TRANSPARENT | CPF_STYLE_FLAT;</a>
<a name="ln1555">      dtgtk_button_set_paint(button, dtgtk_cairo_paint_solid_arrow, flags, NULL);</a>
<a name="ln1556">    }</a>
<a name="ln1557">    else</a>
<a name="ln1558">    {</a>
<a name="ln1559">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i + 1);</a>
<a name="ln1560">      const int mode = dt_conf_get_int(confname);</a>
<a name="ln1561">      if(mode == DT_LIB_COLLECT_MODE_AND) button-&gt;icon = dtgtk_cairo_paint_and;</a>
<a name="ln1562">      if(mode == DT_LIB_COLLECT_MODE_OR) button-&gt;icon = dtgtk_cairo_paint_or;</a>
<a name="ln1563">      if(mode == DT_LIB_COLLECT_MODE_AND_NOT) button-&gt;icon = dtgtk_cairo_paint_andnot;</a>
<a name="ln1564">      gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;clear this rule&quot;));</a>
<a name="ln1565">    }</a>
<a name="ln1566">  }</a>
<a name="ln1567"> </a>
<a name="ln1568">  // update list of proposals</a>
<a name="ln1569">  update_view(d-&gt;rule + d-&gt;active_rule);</a>
<a name="ln1570">  darktable.gui-&gt;reset = reset;</a>
<a name="ln1571">}</a>
<a name="ln1572"> </a>
<a name="ln1573">void gui_reset(dt_lib_module_t *self)</a>
<a name="ln1574">{</a>
<a name="ln1575">  dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, 1);</a>
<a name="ln1576">  dt_conf_set_int(&quot;plugins/lighttable/collect/item0&quot;, DT_COLLECTION_PROP_FILMROLL);</a>
<a name="ln1577">  dt_conf_set_int(&quot;plugins/lighttable/collect/mode0&quot;, 0);</a>
<a name="ln1578">  dt_conf_set_string(&quot;plugins/lighttable/collect/string0&quot;, &quot;&quot;);</a>
<a name="ln1579">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln1580">  d-&gt;active_rule = 0;</a>
<a name="ln1581">  d-&gt;view_rule = -1;</a>
<a name="ln1582">  dt_collection_set_query_flags(darktable.collection, COLLECTION_QUERY_FULL);</a>
<a name="ln1583">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1584">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_QUERY_CHANGED);</a>
<a name="ln1585">}</a>
<a name="ln1586"> </a>
<a name="ln1587">static void combo_changed(GtkComboBox *combo, dt_lib_collect_rule_t *d)</a>
<a name="ln1588">{</a>
<a name="ln1589">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln1590">  g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1591">  g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1592">  gtk_entry_set_text(GTK_ENTRY(d-&gt;text), &quot;&quot;);</a>
<a name="ln1593">  g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1594">  g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1595">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1596">  c-&gt;active_rule = d-&gt;num;</a>
<a name="ln1597"> </a>
<a name="ln1598">  int property = gtk_combo_box_get_active(d-&gt;combo);</a>
<a name="ln1599"> </a>
<a name="ln1600">  if(property == DT_COLLECTION_PROP_FOLDERS || property == DT_COLLECTION_PROP_TAG</a>
<a name="ln1601">     || property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1602">  {</a>
<a name="ln1603">    d-&gt;typing = FALSE;</a>
<a name="ln1604">  }</a>
<a name="ln1605"> </a>
<a name="ln1606">  if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln1607">     || property == DT_COLLECTION_PROP_ISO || property == DT_COLLECTION_PROP_ASPECT_RATIO</a>
<a name="ln1608">     || property == DT_COLLECTION_PROP_EXPOSURE)</a>
<a name="ln1609">  {</a>
<a name="ln1610">    gtk_widget_set_tooltip_text(d-&gt;text, _(&quot;type your query, use &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, =, [;] as operators&quot;));</a>
<a name="ln1611">  }</a>
<a name="ln1612">  else if(property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1613">  {</a>
<a name="ln1614">    gtk_widget_set_tooltip_text(d-&gt;text,</a>
<a name="ln1615">                                _(&quot;type your query, use &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, =, [;] as operators, type dates in &quot;</a>
<a name="ln1616">                                  &quot;the form : YYYY:MM:DD HH:MM:SS (only the year is mandatory)&quot;));</a>
<a name="ln1617">  }</a>
<a name="ln1618">  else</a>
<a name="ln1619">  {</a>
<a name="ln1620">    /* xgettext:no-c-format */</a>
<a name="ln1621">    gtk_widget_set_tooltip_text(d-&gt;text, _(&quot;type your query, use `%' as wildcard&quot;));</a>
<a name="ln1622">  }</a>
<a name="ln1623"> </a>
<a name="ln1624">  set_properties(d);</a>
<a name="ln1625">  c-&gt;view_rule = -1;</a>
<a name="ln1626">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1627">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_QUERY_CHANGED);</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">static void row_activated_with_event(GtkTreeView *view, GtkTreePath *path, GtkTreeViewColumn *col, GdkEventButton *event, dt_lib_collect_t *d)</a>
<a name="ln1631">{</a>
<a name="ln1632">  GtkTreeIter iter;</a>
<a name="ln1633">  GtkTreeModel *model = NULL;</a>
<a name="ln1634"> </a>
<a name="ln1635">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln1636">  if(gtk_tree_selection_count_selected_rows(selection) &lt; 1) return;</a>
<a name="ln1637">  GList *sels = gtk_tree_selection_get_selected_rows(selection, &amp;model);</a>
<a name="ln1638">  GtkTreePath *path1 = (GtkTreePath *)g_list_nth_data(sels, 0);</a>
<a name="ln1639">  if(!gtk_tree_model_get_iter(model, &amp;iter, path1)) return;</a>
<a name="ln1640"> </a>
<a name="ln1641">  gchar *text;</a>
<a name="ln1642"> </a>
<a name="ln1643">  const int active = d-&gt;active_rule;</a>
<a name="ln1644">  d-&gt;rule[active].typing = FALSE;</a>
<a name="ln1645"> </a>
<a name="ln1646">  const int item = gtk_combo_box_get_active(GTK_COMBO_BOX(d-&gt;rule[active].combo));</a>
<a name="ln1647">  gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;text, -1);</a>
<a name="ln1648"> </a>
<a name="ln1649">  if(text &amp;&amp; strlen(text) &gt; 0)</a>
<a name="ln1650">  {</a>
<a name="ln1651">    if(gtk_tree_selection_count_selected_rows(selection) &gt; 1</a>
<a name="ln1652">       &amp;&amp; (item == DT_COLLECTION_PROP_DAY || item == DT_COLLECTION_PROP_TIME || item == DT_COLLECTION_PROP_APERTURE</a>
<a name="ln1653">           || item == DT_COLLECTION_PROP_FOCAL_LENGTH || item == DT_COLLECTION_PROP_ISO</a>
<a name="ln1654">           || item == DT_COLLECTION_PROP_EXPOSURE || item == DT_COLLECTION_PROP_ASPECT_RATIO))</a>
<a name="ln1655">    {</a>
<a name="ln1656">      /* this is a range selection */</a>
<a name="ln1657">      GtkTreeIter iter2;</a>
<a name="ln1658">      GtkTreePath *path2 = (GtkTreePath *)g_list_last(sels)-&gt;data;</a>
<a name="ln1659">      if(!gtk_tree_model_get_iter(model, &amp;iter2, path2)) return;</a>
<a name="ln1660"> </a>
<a name="ln1661">      gchar *text2;</a>
<a name="ln1662">      gtk_tree_model_get(model, &amp;iter2, DT_LIB_COLLECT_COL_PATH, &amp;text2, -1);</a>
<a name="ln1663"> </a>
<a name="ln1664">      gchar *n_text;</a>
<a name="ln1665">      if(item == DT_COLLECTION_PROP_DAY || item == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1666">        n_text = g_strdup_printf(&quot;[%s;%s]&quot;, text2, text); /* dates are in reverse order */</a>
<a name="ln1667">      else</a>
<a name="ln1668">        n_text = g_strdup_printf(&quot;[%s;%s]&quot;, text, text2);</a>
<a name="ln1669"> </a>
<a name="ln1670">      g_free(text);</a>
<a name="ln1671">      g_free(text2);</a>
<a name="ln1672">      text = n_text;</a>
<a name="ln1673">    }</a>
<a name="ln1674">    else if(item == DT_COLLECTION_PROP_TAG &amp;&amp; gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln1675">    {</a>
<a name="ln1676">      /* if a tag has children, ctrl-clicking on a parent node should display all images under this hierarchy. */</a>
<a name="ln1677">      if(event-&gt;state &amp; GDK_CONTROL_MASK)</a>
<a name="ln1678">      {</a>
<a name="ln1679">        gchar *n_text = g_strconcat(text, &quot;|%&quot;, NULL);</a>
<a name="ln1680">        g_free(text);</a>
<a name="ln1681">        text = n_text;</a>
<a name="ln1682">      }</a>
<a name="ln1683">      /* if a tag has children, shift-clicking on a parent node should display all images in and under this</a>
<a name="ln1684">       * hierarchy. */</a>
<a name="ln1685">      else if(event-&gt;state &amp; GDK_SHIFT_MASK)</a>
<a name="ln1686">      {</a>
<a name="ln1687">        gchar *n_text = g_strconcat(text, &quot;%&quot;, NULL);</a>
<a name="ln1688">        g_free(text);</a>
<a name="ln1689">        text = n_text;</a>
<a name="ln1690">      }</a>
<a name="ln1691">    }</a>
<a name="ln1692">  }</a>
<a name="ln1693"> </a>
<a name="ln1694">  g_signal_handlers_block_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1695">  g_signal_handlers_block_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1696">  gtk_entry_set_text(GTK_ENTRY(d-&gt;rule[active].text), text);</a>
<a name="ln1697">  gtk_editable_set_position(GTK_EDITABLE(d-&gt;rule[active].text), -1);</a>
<a name="ln1698">  g_signal_handlers_unblock_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text,</a>
<a name="ln1699">                                    NULL);</a>
<a name="ln1700">  g_signal_handlers_unblock_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed,</a>
<a name="ln1701">                                    NULL);</a>
<a name="ln1702">  g_free(text);</a>
<a name="ln1703"> </a>
<a name="ln1704">  if(item == DT_COLLECTION_PROP_TAG || item == DT_COLLECTION_PROP_FOLDERS</a>
<a name="ln1705">     || item == DT_COLLECTION_PROP_DAY || item == DT_COLLECTION_PROP_TIME</a>
<a name="ln1706">     || item == DT_COLLECTION_PROP_COLORLABEL || item == DT_COLLECTION_PROP_GEOTAGGING</a>
<a name="ln1707">     || item == DT_COLLECTION_PROP_HISTORY ||  item == DT_COLLECTION_PROP_LOCAL_COPY</a>
<a name="ln1708">     || item == DT_COLLECTION_PROP_GROUPING)</a>
<a name="ln1709">    set_properties(d-&gt;rule + active); // we just have to set the selection</a>
<a name="ln1710">  else</a>
<a name="ln1711">    update_view(d-&gt;rule + active); // we have to update visible items too</a>
<a name="ln1712"> </a>
<a name="ln1713">  dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1714">                                  darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1715">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1716">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_QUERY_CHANGED);</a>
<a name="ln1717">  dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1718">                                    darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1719">  dt_control_queue_redraw_center();</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">static void entry_activated(GtkWidget *entry, dt_lib_collect_rule_t *d)</a>
<a name="ln1723">{</a>
<a name="ln1724">  GtkTreeView *view;</a>
<a name="ln1725">  GtkTreeModel *model;</a>
<a name="ln1726">  int property, rows;</a>
<a name="ln1727"> </a>
<a name="ln1728">  update_view(d);</a>
<a name="ln1729">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1730"> </a>
<a name="ln1731">  property = gtk_combo_box_get_active(d-&gt;combo);</a>
<a name="ln1732"> </a>
<a name="ln1733">  if(property != DT_COLLECTION_PROP_FOLDERS &amp;&amp; property != DT_COLLECTION_PROP_TAG</a>
<a name="ln1734">     &amp;&amp; property != DT_COLLECTION_PROP_DAY &amp;&amp; property != DT_COLLECTION_PROP_TIME)</a>
<a name="ln1735">  {</a>
<a name="ln1736">    view = c-&gt;view;</a>
<a name="ln1737">    model = gtk_tree_view_get_model(GTK_TREE_VIEW(view));</a>
<a name="ln1738"> </a>
<a name="ln1739">    rows = gtk_tree_model_iter_n_children(model, NULL);</a>
<a name="ln1740"> </a>
<a name="ln1741">    if(rows == 1)</a>
<a name="ln1742">    {</a>
<a name="ln1743">      GtkTreeIter iter;</a>
<a name="ln1744">      if(gtk_tree_model_get_iter_first(model, &amp;iter))</a>
<a name="ln1745">      {</a>
<a name="ln1746">        gchar *text;</a>
<a name="ln1747">        gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;text, -1);</a>
<a name="ln1748"> </a>
<a name="ln1749">        g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1750">        g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1751">        gtk_entry_set_text(GTK_ENTRY(d-&gt;text), text);</a>
<a name="ln1752">        gtk_editable_set_position(GTK_EDITABLE(d-&gt;text), -1);</a>
<a name="ln1753">        g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1754">        g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1755">        g_free(text);</a>
<a name="ln1756">        d-&gt;typing = FALSE;</a>
<a name="ln1757">        update_view(d);</a>
<a name="ln1758">      }</a>
<a name="ln1759">    }</a>
<a name="ln1760">  }</a>
<a name="ln1761">  dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1762">                                  darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1763">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1764">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_QUERY_CHANGED);</a>
<a name="ln1765">  dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1766">                                    darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1767">}</a>
<a name="ln1768"> </a>
<a name="ln1769">static void entry_insert_text(GtkWidget *entry, gchar *new_text, gint new_length, gpointer *position,</a>
<a name="ln1770">                          dt_lib_collect_rule_t *d)</a>
<a name="ln1771">{</a>
<a name="ln1772">  d-&gt;typing = TRUE;</a>
<a name="ln1773">}</a>
<a name="ln1774"> </a>
<a name="ln1775">static void entry_changed(GtkEntry *entry, dt_lib_collect_rule_t *dr)</a>
<a name="ln1776">{</a>
<a name="ln1777">  update_view(dr);</a>
<a name="ln1778">}</a>
<a name="ln1779"> </a>
<a name="ln1780">int position()</a>
<a name="ln1781">{</a>
<a name="ln1782">  return 400;</a>
<a name="ln1783">}</a>
<a name="ln1784"> </a>
<a name="ln1785">static gboolean entry_focus_in_callback(GtkWidget *w, GdkEventFocus *event, dt_lib_collect_rule_t *d)</a>
<a name="ln1786">{</a>
<a name="ln1787">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1788">  if(c-&gt;active_rule != d-&gt;num)</a>
<a name="ln1789">  {</a>
<a name="ln1790">    c-&gt;active_rule = d-&gt;num;</a>
<a name="ln1791">    update_view(c-&gt;rule + c-&gt;active_rule);</a>
<a name="ln1792">  }</a>
<a name="ln1793"> </a>
<a name="ln1794">  return FALSE;</a>
<a name="ln1795">}</a>
<a name="ln1796"> </a>
<a name="ln1797">static void menuitem_mode(GtkMenuItem *menuitem, dt_lib_collect_rule_t *d)</a>
<a name="ln1798">{</a>
<a name="ln1799">  // add next row with and operator</a>
<a name="ln1800">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1801">  const int active = CLAMP(_a, 1, MAX_RULES);</a>
<a name="ln1802">  if(active &lt; MAX_RULES)</a>
<a name="ln1803">  {</a>
<a name="ln1804">    char confname[200] = { 0 };</a>
<a name="ln1805">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, active);</a>
<a name="ln1806">    const dt_lib_collect_mode_t mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(menuitem), &quot;menuitem_mode&quot;));</a>
<a name="ln1807">    dt_conf_set_int(confname, mode);</a>
<a name="ln1808">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, active);</a>
<a name="ln1809">    dt_conf_set_string(confname, &quot;&quot;);</a>
<a name="ln1810">    dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, active + 1);</a>
<a name="ln1811">    dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1812">    c-&gt;active_rule = active;</a>
<a name="ln1813">    c-&gt;view_rule = -1;</a>
<a name="ln1814">  }</a>
<a name="ln1815">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1816">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_QUERY_CHANGED);</a>
<a name="ln1817">}</a>
<a name="ln1818"> </a>
<a name="ln1819">static void menuitem_mode_change(GtkMenuItem *menuitem, dt_lib_collect_rule_t *d)</a>
<a name="ln1820">{</a>
<a name="ln1821">  // add next row with and operator</a>
<a name="ln1822">  const int num = d-&gt;num + 1;</a>
<a name="ln1823">  if(num &lt; MAX_RULES &amp;&amp; num &gt; 0)</a>
<a name="ln1824">  {</a>
<a name="ln1825">    char confname[200] = { 0 };</a>
<a name="ln1826">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, num);</a>
<a name="ln1827">    const dt_lib_collect_mode_t mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(menuitem), &quot;menuitem_mode&quot;));</a>
<a name="ln1828">    dt_conf_set_int(confname, mode);</a>
<a name="ln1829">  }</a>
<a name="ln1830">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1831">  c-&gt;view_rule = -1;</a>
<a name="ln1832">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1833">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_QUERY_CHANGED);</a>
<a name="ln1834">}</a>
<a name="ln1835"> </a>
<a name="ln1836">static void collection_updated(gpointer instance, gpointer self)</a>
<a name="ln1837">{</a>
<a name="ln1838">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1839">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1840"> </a>
<a name="ln1841">  // update tree</a>
<a name="ln1842">  d-&gt;view_rule = -1;</a>
<a name="ln1843">  d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1844">  _lib_collect_gui_update(self);</a>
<a name="ln1845">}</a>
<a name="ln1846"> </a>
<a name="ln1847"> </a>
<a name="ln1848">static void filmrolls_updated(gpointer instance, gpointer self)</a>
<a name="ln1849">{</a>
<a name="ln1850">  // TODO: We should update the count of images here</a>
<a name="ln1851">  _lib_collect_gui_update(self);</a>
<a name="ln1852">}</a>
<a name="ln1853"> </a>
<a name="ln1854">static void filmrolls_imported(gpointer instance, int film_id, gpointer self)</a>
<a name="ln1855">{</a>
<a name="ln1856">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1857">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1858"> </a>
<a name="ln1859">  // update tree</a>
<a name="ln1860">  d-&gt;view_rule = -1;</a>
<a name="ln1861">  d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1862">  _lib_collect_gui_update(self);</a>
<a name="ln1863">}</a>
<a name="ln1864"> </a>
<a name="ln1865">static void filmrolls_removed(gpointer instance, gpointer self)</a>
<a name="ln1866">{</a>
<a name="ln1867">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1868">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1869"> </a>
<a name="ln1870">  // update tree</a>
<a name="ln1871">  if (d-&gt;view_rule != DT_COLLECTION_PROP_FOLDERS)</a>
<a name="ln1872">  {</a>
<a name="ln1873">    d-&gt;view_rule = -1;</a>
<a name="ln1874">  }</a>
<a name="ln1875">  d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1876">  _lib_collect_gui_update(self);</a>
<a name="ln1877">}</a>
<a name="ln1878"> </a>
<a name="ln1879">static void tag_changed(gpointer instance, gpointer self)</a>
<a name="ln1880">{</a>
<a name="ln1881">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1882">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1883"> </a>
<a name="ln1884">  // update tree</a>
<a name="ln1885">  if(gtk_combo_box_get_active(GTK_COMBO_BOX(d-&gt;rule[d-&gt;active_rule].combo)) == DT_COLLECTION_PROP_TAG)</a>
<a name="ln1886">  {</a>
<a name="ln1887">    d-&gt;view_rule = -1;</a>
<a name="ln1888">    d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1889">    _lib_collect_gui_update(self);</a>
<a name="ln1890">  }</a>
<a name="ln1891">}</a>
<a name="ln1892"> </a>
<a name="ln1893">static void menuitem_clear(GtkMenuItem *menuitem, dt_lib_collect_rule_t *d)</a>
<a name="ln1894">{</a>
<a name="ln1895">  // remove this row, or if 1st, clear text entry box</a>
<a name="ln1896">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1897">  const int active = CLAMP(_a, 1, MAX_RULES);</a>
<a name="ln1898">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1899">  if(active &gt; 1)</a>
<a name="ln1900">  {</a>
<a name="ln1901">    dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, active - 1);</a>
<a name="ln1902">    if(c-&gt;active_rule &gt;= active - 1) c-&gt;active_rule = active - 2;</a>
<a name="ln1903">  }</a>
<a name="ln1904">  else</a>
<a name="ln1905">  {</a>
<a name="ln1906">    dt_conf_set_int(&quot;plugins/lighttable/collect/mode0&quot;, DT_LIB_COLLECT_MODE_AND);</a>
<a name="ln1907">    dt_conf_set_int(&quot;plugins/lighttable/collect/item0&quot;, 0);</a>
<a name="ln1908">    dt_conf_set_string(&quot;plugins/lighttable/collect/string0&quot;, &quot;&quot;);</a>
<a name="ln1909">    d-&gt;typing = FALSE;</a>
<a name="ln1910">  }</a>
<a name="ln1911">  // move up all still active rules by one.</a>
<a name="ln1912">  for(int i = d-&gt;num; i &lt; MAX_RULES - 1; i++)</a>
<a name="ln1913">  {</a>
<a name="ln1914">    char confname[200] = { 0 };</a>
<a name="ln1915">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i + 1);</a>
<a name="ln1916">    const int mode = dt_conf_get_int(confname);</a>
<a name="ln1917">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i + 1);</a>
<a name="ln1918">    const int item = dt_conf_get_int(confname);</a>
<a name="ln1919">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i + 1);</a>
<a name="ln1920">    gchar *string = dt_conf_get_string(confname);</a>
<a name="ln1921">    if(string)</a>
<a name="ln1922">    {</a>
<a name="ln1923">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln1924">      dt_conf_set_int(confname, mode);</a>
<a name="ln1925">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln1926">      dt_conf_set_int(confname, item);</a>
<a name="ln1927">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln1928">      dt_conf_set_string(confname, string);</a>
<a name="ln1929">      g_free(string);</a>
<a name="ln1930">    }</a>
<a name="ln1931">  }</a>
<a name="ln1932"> </a>
<a name="ln1933">  c-&gt;view_rule = -1;</a>
<a name="ln1934">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1935">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_QUERY_CHANGED);</a>
<a name="ln1936">}</a>
<a name="ln1937"> </a>
<a name="ln1938">static gboolean popup_button_callback(GtkWidget *widget, GdkEventButton *event, dt_lib_collect_rule_t *d)</a>
<a name="ln1939">{</a>
<a name="ln1940">  if(event-&gt;button != 1) return FALSE;</a>
<a name="ln1941"> </a>
<a name="ln1942">  GtkWidget *menu = gtk_menu_new();</a>
<a name="ln1943">  GtkWidget *mi;</a>
<a name="ln1944">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1945">  const int active = CLAMP(_a, 1, MAX_RULES);</a>
<a name="ln1946"> </a>
<a name="ln1947">  mi = gtk_menu_item_new_with_label(_(&quot;clear this rule&quot;));</a>
<a name="ln1948">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1949">  g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_clear), d);</a>
<a name="ln1950"> </a>
<a name="ln1951">  if(d-&gt;num == active - 1)</a>
<a name="ln1952">  {</a>
<a name="ln1953">    mi = gtk_menu_item_new_with_label(_(&quot;narrow down search&quot;));</a>
<a name="ln1954">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND));</a>
<a name="ln1955">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1956">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode), d);</a>
<a name="ln1957"> </a>
<a name="ln1958">    mi = gtk_menu_item_new_with_label(_(&quot;add more images&quot;));</a>
<a name="ln1959">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_OR));</a>
<a name="ln1960">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1961">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode), d);</a>
<a name="ln1962"> </a>
<a name="ln1963">    mi = gtk_menu_item_new_with_label(_(&quot;exclude images&quot;));</a>
<a name="ln1964">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND_NOT));</a>
<a name="ln1965">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1966">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode), d);</a>
<a name="ln1967">  }</a>
<a name="ln1968">  else if(d-&gt;num &lt; active - 1)</a>
<a name="ln1969">  {</a>
<a name="ln1970">    mi = gtk_menu_item_new_with_label(_(&quot;change to: and&quot;));</a>
<a name="ln1971">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND));</a>
<a name="ln1972">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1973">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode_change), d);</a>
<a name="ln1974"> </a>
<a name="ln1975">    mi = gtk_menu_item_new_with_label(_(&quot;change to: or&quot;));</a>
<a name="ln1976">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_OR));</a>
<a name="ln1977">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1978">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode_change), d);</a>
<a name="ln1979"> </a>
<a name="ln1980">    mi = gtk_menu_item_new_with_label(_(&quot;change to: except&quot;));</a>
<a name="ln1981">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND_NOT));</a>
<a name="ln1982">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1983">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode_change), d);</a>
<a name="ln1984">  }</a>
<a name="ln1985"> </a>
<a name="ln1986">  gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln1987"> </a>
<a name="ln1988">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln1989">  gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln1990">#else</a>
<a name="ln1991">  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, event-&gt;button, event-&gt;time);</a>
<a name="ln1992">#endif</a>
<a name="ln1993"> </a>
<a name="ln1994">  return TRUE;</a>
<a name="ln1995">}</a>
<a name="ln1996"> </a>
<a name="ln1997">static void view_set_click(gpointer instance, gpointer user_data)</a>
<a name="ln1998">{</a>
<a name="ln1999">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln2000">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln2001">  d-&gt;singleclick = dt_conf_get_bool(&quot;plugins/lighttable/collect/single-click&quot;);</a>
<a name="ln2002">}</a>
<a name="ln2003"> </a>
<a name="ln2004">void gui_init(dt_lib_module_t *self)</a>
<a name="ln2005">{</a>
<a name="ln2006">  dt_lib_collect_t *d = (dt_lib_collect_t *)calloc(1, sizeof(dt_lib_collect_t));</a>
<a name="ln2007"> </a>
<a name="ln2008">  self-&gt;data = (void *)d;</a>
<a name="ln2009">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln2010">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln2011"> </a>
<a name="ln2012">  d-&gt;active_rule = 0;</a>
<a name="ln2013">  d-&gt;nb_rules = 0;</a>
<a name="ln2014">  d-&gt;params = (dt_lib_collect_params_t *)malloc(sizeof(dt_lib_collect_params_t));</a>
<a name="ln2015">  view_set_click(NULL, self);</a>
<a name="ln2016"> </a>
<a name="ln2017">  GtkBox *box;</a>
<a name="ln2018">  GtkWidget *w;</a>
<a name="ln2019"> </a>
<a name="ln2020">  for(int i = 0; i &lt; MAX_RULES; i++)</a>
<a name="ln2021">  {</a>
<a name="ln2022">    d-&gt;rule[i].num = i;</a>
<a name="ln2023">    d-&gt;rule[i].typing = FALSE;</a>
<a name="ln2024">    box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln2025">    d-&gt;rule[i].hbox = GTK_WIDGET(box);</a>
<a name="ln2026">    gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(box), TRUE, TRUE, 0);</a>
<a name="ln2027">    w = gtk_combo_box_text_new();</a>
<a name="ln2028">    d-&gt;rule[i].combo = GTK_COMBO_BOX(w);</a>
<a name="ln2029">    for(int k = 0; k &lt; dt_lib_collect_string_cnt; k++)</a>
<a name="ln2030">      gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(w), _(dt_lib_collect_string[k]));</a>
<a name="ln2031">    g_signal_connect(G_OBJECT(w), &quot;changed&quot;, G_CALLBACK(combo_changed), d-&gt;rule + i);</a>
<a name="ln2032">    gtk_box_pack_start(box, w, FALSE, FALSE, 0);</a>
<a name="ln2033"> </a>
<a name="ln2034">    w = gtk_entry_new();</a>
<a name="ln2035">    d-&gt;rule[i].text = w;</a>
<a name="ln2036">    dt_gui_key_accel_block_on_focus_connect(d-&gt;rule[i].text);</a>
<a name="ln2037">    gtk_widget_add_events(w, GDK_FOCUS_CHANGE_MASK);</a>
<a name="ln2038">    g_signal_connect(G_OBJECT(w), &quot;focus-in-event&quot;, G_CALLBACK(entry_focus_in_callback), d-&gt;rule + i);</a>
<a name="ln2039"> </a>
<a name="ln2040">    /* xgettext:no-c-format */</a>
<a name="ln2041">    gtk_widget_set_tooltip_text(w, _(&quot;type your query, use `%' as wildcard&quot;));</a>
<a name="ln2042">    gtk_widget_add_events(w, GDK_KEY_PRESS_MASK);</a>
<a name="ln2043">    g_signal_connect(G_OBJECT(w), &quot;insert-text&quot;, G_CALLBACK(entry_insert_text), d-&gt;rule + i);</a>
<a name="ln2044">    g_signal_connect(G_OBJECT(w), &quot;changed&quot;, G_CALLBACK(entry_changed), d-&gt;rule + i);</a>
<a name="ln2045">    g_signal_connect(G_OBJECT(w), &quot;activate&quot;, G_CALLBACK(entry_activated), d-&gt;rule + i);</a>
<a name="ln2046">    gtk_box_pack_start(box, w, TRUE, TRUE, 0);</a>
<a name="ln2047">    gtk_entry_set_width_chars(GTK_ENTRY(w), 0);</a>
<a name="ln2048"> </a>
<a name="ln2049">    w = dtgtk_button_new(dtgtk_cairo_paint_presets, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2050">    d-&gt;rule[i].button = w;</a>
<a name="ln2051">    gtk_widget_set_events(w, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln2052">    g_signal_connect(G_OBJECT(w), &quot;button-press-event&quot;, G_CALLBACK(popup_button_callback), d-&gt;rule + i);</a>
<a name="ln2053">    gtk_box_pack_start(box, w, FALSE, FALSE, 0);</a>
<a name="ln2054">  }</a>
<a name="ln2055"> </a>
<a name="ln2056">  GtkWidget *sw = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln2057">  d-&gt;scrolledwindow = GTK_SCROLLED_WINDOW(sw);</a>
<a name="ln2058">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln2059">  gtk_scrolled_window_set_min_content_height(GTK_SCROLLED_WINDOW(d-&gt;scrolledwindow), DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln2060">  GtkTreeView *view = GTK_TREE_VIEW(gtk_tree_view_new());</a>
<a name="ln2061">  d-&gt;view_rule = -1;</a>
<a name="ln2062">  d-&gt;view = view;</a>
<a name="ln2063">  gtk_tree_view_set_headers_visible(view, FALSE);</a>
<a name="ln2064">  gtk_container_add(GTK_CONTAINER(sw), GTK_WIDGET(view));</a>
<a name="ln2065">  g_signal_connect(G_OBJECT(view), &quot;button-press-event&quot;, G_CALLBACK(view_onButtonPressed), d);</a>
<a name="ln2066">  g_signal_connect(G_OBJECT(view), &quot;popup-menu&quot;, G_CALLBACK(view_onPopupMenu), d);</a>
<a name="ln2067"> </a>
<a name="ln2068">  GtkTreeViewColumn *col = gtk_tree_view_column_new();</a>
<a name="ln2069">  gtk_tree_view_append_column(view, col);</a>
<a name="ln2070">  GtkCellRenderer *renderer = gtk_cell_renderer_text_new();</a>
<a name="ln2071">  gtk_tree_view_column_pack_start(col, renderer, TRUE);</a>
<a name="ln2072">  gtk_tree_view_column_set_cell_data_func(col, renderer, tree_count_show, NULL, NULL);</a>
<a name="ln2073">  g_object_set(renderer, &quot;strikethrough&quot;, TRUE, (gchar *)0);</a>
<a name="ln2074">  gtk_tree_view_column_add_attribute(col, renderer, &quot;strikethrough-set&quot;, DT_LIB_COLLECT_COL_UNREACHABLE);</a>
<a name="ln2075"> </a>
<a name="ln2076">  GtkTreeModel *listmodel</a>
<a name="ln2077">      = GTK_TREE_MODEL(gtk_list_store_new(DT_LIB_COLLECT_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING,</a>
<a name="ln2078">                                          G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_UINT));</a>
<a name="ln2079">  d-&gt;listfilter = gtk_tree_model_filter_new(listmodel, NULL);</a>
<a name="ln2080">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(d-&gt;listfilter), DT_LIB_COLLECT_COL_VISIBLE);</a>
<a name="ln2081"> </a>
<a name="ln2082">  GtkTreeModel *treemodel</a>
<a name="ln2083">      = GTK_TREE_MODEL(gtk_tree_store_new(DT_LIB_COLLECT_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING,</a>
<a name="ln2084">                                          G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_UINT));</a>
<a name="ln2085">  d-&gt;treefilter = gtk_tree_model_filter_new(treemodel, NULL);</a>
<a name="ln2086">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(d-&gt;treefilter), DT_LIB_COLLECT_COL_VISIBLE);</a>
<a name="ln2087">  g_object_unref(treemodel);</a>
<a name="ln2088"> </a>
<a name="ln2089">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(sw), TRUE, TRUE, 0);</a>
<a name="ln2090"> </a>
<a name="ln2091">  GtkWidget *sw2 = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln2092">  d-&gt;sw2 = GTK_SCROLLED_WINDOW(sw2);</a>
<a name="ln2093">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw2), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln2094">  gtk_scrolled_window_set_min_content_height(GTK_SCROLLED_WINDOW(sw2), DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln2095"> </a>
<a name="ln2096">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(sw2), TRUE, TRUE, 0);</a>
<a name="ln2097"> </a>
<a name="ln2098">  /* setup proxy */</a>
<a name="ln2099">  darktable.view_manager-&gt;proxy.module_collect.module = self;</a>
<a name="ln2100">  darktable.view_manager-&gt;proxy.module_collect.update = _lib_collect_gui_update;</a>
<a name="ln2101"> </a>
<a name="ln2102">  _lib_collect_gui_update(self);</a>
<a name="ln2103"> </a>
<a name="ln2104">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED, G_CALLBACK(collection_updated),</a>
<a name="ln2105">                            self);</a>
<a name="ln2106"> </a>
<a name="ln2107">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED, G_CALLBACK(filmrolls_updated),</a>
<a name="ln2108">                            self);</a>
<a name="ln2109"> </a>
<a name="ln2110">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_IMPORTED, G_CALLBACK(filmrolls_imported),</a>
<a name="ln2111">                            self);</a>
<a name="ln2112"> </a>
<a name="ln2113">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_REMOVED, G_CALLBACK(filmrolls_removed),</a>
<a name="ln2114">                            self);</a>
<a name="ln2115"> </a>
<a name="ln2116">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_TAG_CHANGED, G_CALLBACK(tag_changed),</a>
<a name="ln2117">                            self);</a>
<a name="ln2118"> </a>
<a name="ln2119">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_PREFERENCES_CHANGE, G_CALLBACK(view_set_click), self);</a>
<a name="ln2120">}</a>
<a name="ln2121"> </a>
<a name="ln2122">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln2123">{</a>
<a name="ln2124">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln2125"> </a>
<a name="ln2126">  for(int i = 0; i &lt; MAX_RULES; i++) dt_gui_key_accel_block_on_focus_disconnect(d-&gt;rule[i].text);</a>
<a name="ln2127"> </a>
<a name="ln2128">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(collection_updated), self);</a>
<a name="ln2129">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(filmrolls_updated), self);</a>
<a name="ln2130">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(filmrolls_imported), self);</a>
<a name="ln2131">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(filmrolls_removed), self);</a>
<a name="ln2132">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(tag_changed), self);</a>
<a name="ln2133">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(view_set_click), self);</a>
<a name="ln2134">  darktable.view_manager-&gt;proxy.module_collect.module = NULL;</a>
<a name="ln2135">  free(d-&gt;params);</a>
<a name="ln2136"> </a>
<a name="ln2137">  /* cleanup mem */</a>
<a name="ln2138"> </a>
<a name="ln2139">  g_object_unref(d-&gt;treefilter);</a>
<a name="ln2140">  g_object_unref(d-&gt;listfilter);</a>
<a name="ln2141"> </a>
<a name="ln2142">  /* TODO: Make sure we are cleaning up all allocations */</a>
<a name="ln2143"> </a>
<a name="ln2144">  free(self-&gt;data);</a>
<a name="ln2145">  self-&gt;data = NULL;</a>
<a name="ln2146">}</a>
<a name="ln2147"> </a>
<a name="ln2148"> </a>
<a name="ln2149">#ifdef USE_LUA</a>
<a name="ln2150">static int new_rule_cb(lua_State*L)</a>
<a name="ln2151">{</a>
<a name="ln2152">  dt_lib_collect_params_rule_t rule;</a>
<a name="ln2153">  memset(&amp;rule,0, sizeof(dt_lib_collect_params_rule_t));</a>
<a name="ln2154">  luaA_push(L,dt_lib_collect_params_rule_t,&amp;rule);</a>
<a name="ln2155">  return 1;</a>
<a name="ln2156">}</a>
<a name="ln2157">static int filter_cb(lua_State *L)</a>
<a name="ln2158">{</a>
<a name="ln2159">  dt_lib_module_t *self = lua_touserdata(L, lua_upvalueindex(1));</a>
<a name="ln2160"> </a>
<a name="ln2161">  int size;</a>
<a name="ln2162">  dt_lib_collect_params_t *p = get_params(self,&amp;size);</a>
<a name="ln2163">  // put it in stack so memory is not lost if a lua exception is raised</a>
<a name="ln2164"> </a>
<a name="ln2165"> </a>
<a name="ln2166"> </a>
<a name="ln2167">  if(lua_gettop(L) &gt; 0) {</a>
<a name="ln2168">    luaL_checktype(L,1,LUA_TTABLE);</a>
<a name="ln2169">    dt_lib_collect_params_t *new_p = get_params(self,&amp;size);</a>
<a name="ln2170">    new_p-&gt;rules = 0;</a>
<a name="ln2171">    do {</a>
<a name="ln2172">      lua_pushinteger(L,new_p-&gt;rules + 1);</a>
<a name="ln2173">      lua_gettable(L,1);</a>
<a name="ln2174">      if(lua_isnil(L,-1)) break;</a>
<a name="ln2175">      luaA_to(L,dt_lib_collect_params_rule_t,&amp;new_p-&gt;rule[new_p-&gt;rules],-1);</a>
<a name="ln2176">      new_p-&gt;rules++;</a>
<a name="ln2177">    }while(new_p-&gt;rules &lt; MAX_RULES);</a>
<a name="ln2178">    if(new_p-&gt;rules == MAX_RULES) {</a>
<a name="ln2179">      lua_pushinteger(L,new_p-&gt;rules + 1);</a>
<a name="ln2180">      lua_gettable(L,1);</a>
<a name="ln2181">      if(!lua_isnil(L,-1)) {</a>
<a name="ln2182">        luaL_error(L,&quot;Number of rules given excedes max allowed (%d)&quot;,MAX_RULES);</a>
<a name="ln2183">      }</a>
<a name="ln2184">    }</a>
<a name="ln2185">    set_params(self,new_p,size);</a>
<a name="ln2186">    free(new_p);</a>
<a name="ln2187"> </a>
<a name="ln2188">  }</a>
<a name="ln2189">  lua_newtable(L);</a>
<a name="ln2190">  for(int i = 0; i &lt; p-&gt;rules; i++) {</a>
<a name="ln2191">    luaA_push(L,dt_lib_collect_params_rule_t,&amp;p-&gt;rule[i]);</a>
<a name="ln2192">    luaL_ref(L,-2);</a>
<a name="ln2193">  }</a>
<a name="ln2194">  free(p);</a>
<a name="ln2195">  return 1;</a>
<a name="ln2196">}</a>
<a name="ln2197"> </a>
<a name="ln2198">static int mode_member(lua_State *L)</a>
<a name="ln2199">{</a>
<a name="ln2200">  dt_lib_collect_params_rule_t *rule = luaL_checkudata(L,1,&quot;dt_lib_collect_params_rule_t&quot;);</a>
<a name="ln2201">  if(lua_gettop(L) &gt; 2) {</a>
<a name="ln2202">    dt_lib_collect_mode_t value;</a>
<a name="ln2203">    luaA_to(L,dt_lib_collect_mode_t,&amp;value,3);</a>
<a name="ln2204">    rule-&gt;mode = value;</a>
<a name="ln2205">    return 0;</a>
<a name="ln2206">  }</a>
<a name="ln2207">  const dt_lib_collect_mode_t tmp = rule-&gt;mode; // temp buffer because of bitfield in the original struct</a>
<a name="ln2208">  luaA_push(L,dt_lib_collect_mode_t,&amp;tmp);</a>
<a name="ln2209">  return 1;</a>
<a name="ln2210">}</a>
<a name="ln2211"> </a>
<a name="ln2212">static int item_member(lua_State *L)</a>
<a name="ln2213">{</a>
<a name="ln2214">  dt_lib_collect_params_rule_t *rule = luaL_checkudata(L,1,&quot;dt_lib_collect_params_rule_t&quot;);</a>
<a name="ln2215"> </a>
<a name="ln2216">  if(lua_gettop(L) &gt; 2) {</a>
<a name="ln2217">    dt_collection_properties_t value;</a>
<a name="ln2218">    luaA_to(L,dt_collection_properties_t,&amp;value,3);</a>
<a name="ln2219">    rule-&gt;item = value;</a>
<a name="ln2220">    return 0;</a>
<a name="ln2221">  }</a>
<a name="ln2222">  const dt_collection_properties_t tmp = rule-&gt;item; // temp buffer because of bitfield in the original struct</a>
<a name="ln2223">  luaA_push(L,dt_collection_properties_t,&amp;tmp);</a>
<a name="ln2224">  return 1;</a>
<a name="ln2225">}</a>
<a name="ln2226"> </a>
<a name="ln2227">static int data_member(lua_State *L)</a>
<a name="ln2228">{</a>
<a name="ln2229">  dt_lib_collect_params_rule_t *rule = luaL_checkudata(L,1,&quot;dt_lib_collect_params_rule_t&quot;);</a>
<a name="ln2230"> </a>
<a name="ln2231">  if(lua_gettop(L) &gt; 2) {</a>
<a name="ln2232">    size_t tgt_size;</a>
<a name="ln2233">    const char*data = luaL_checklstring(L,3,&amp;tgt_size);</a>
<a name="ln2234">    if(tgt_size &gt; PARAM_STRING_SIZE)</a>
<a name="ln2235">    {</a>
<a name="ln2236">      return luaL_error(L, &quot;string '%s' too long (max is %d)&quot;, data, PARAM_STRING_SIZE);</a>
<a name="ln2237">    }</a>
<a name="ln2238">    g_strlcpy(rule-&gt;string, data, sizeof(rule-&gt;string));</a>
<a name="ln2239">    return 0;</a>
<a name="ln2240">  }</a>
<a name="ln2241">  lua_pushstring(L,rule-&gt;string);</a>
<a name="ln2242">  return 1;</a>
<a name="ln2243">}</a>
<a name="ln2244"> </a>
<a name="ln2245"> </a>
<a name="ln2246"> </a>
<a name="ln2247">void init(struct dt_lib_module_t *self)</a>
<a name="ln2248">{</a>
<a name="ln2249"> </a>
<a name="ln2250">  lua_State *L = darktable.lua_state.state;</a>
<a name="ln2251">  int my_type = dt_lua_module_entry_get_type(L, &quot;lib&quot;, self-&gt;plugin_name);</a>
<a name="ln2252">  lua_pushlightuserdata(L, self);</a>
<a name="ln2253">  lua_pushcclosure(L, filter_cb,1);</a>
<a name="ln2254">  dt_lua_gtk_wrap(L);</a>
<a name="ln2255">  lua_pushcclosure(L, dt_lua_type_member_common, 1);</a>
<a name="ln2256">  dt_lua_type_register_const_type(L, my_type, &quot;filter&quot;);</a>
<a name="ln2257">  lua_pushcfunction(L, new_rule_cb);</a>
<a name="ln2258">  lua_pushcclosure(L, dt_lua_type_member_common, 1);</a>
<a name="ln2259">  dt_lua_type_register_const_type(L, my_type, &quot;new_rule&quot;);</a>
<a name="ln2260"> </a>
<a name="ln2261">  dt_lua_init_type(L,dt_lib_collect_params_rule_t);</a>
<a name="ln2262">  lua_pushcfunction(L,mode_member);</a>
<a name="ln2263">  dt_lua_type_register(L, dt_lib_collect_params_rule_t, &quot;mode&quot;);</a>
<a name="ln2264">  lua_pushcfunction(L,item_member);</a>
<a name="ln2265">  dt_lua_type_register(L, dt_lib_collect_params_rule_t, &quot;item&quot;);</a>
<a name="ln2266">  lua_pushcfunction(L,data_member);</a>
<a name="ln2267">  dt_lua_type_register(L, dt_lib_collect_params_rule_t, &quot;data&quot;);</a>
<a name="ln2268"> </a>
<a name="ln2269"> </a>
<a name="ln2270">  luaA_enum(L,dt_lib_collect_mode_t);</a>
<a name="ln2271">  luaA_enum_value(L,dt_lib_collect_mode_t,DT_LIB_COLLECT_MODE_AND);</a>
<a name="ln2272">  luaA_enum_value(L,dt_lib_collect_mode_t,DT_LIB_COLLECT_MODE_OR);</a>
<a name="ln2273">  luaA_enum_value(L,dt_lib_collect_mode_t,DT_LIB_COLLECT_MODE_AND_NOT);</a>
<a name="ln2274"> </a>
<a name="ln2275">  luaA_enum(L,dt_collection_properties_t);</a>
<a name="ln2276">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FILMROLL);</a>
<a name="ln2277">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FOLDERS);</a>
<a name="ln2278">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_CAMERA);</a>
<a name="ln2279">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_TAG);</a>
<a name="ln2280">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_DAY);</a>
<a name="ln2281">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_TIME);</a>
<a name="ln2282">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_HISTORY);</a>
<a name="ln2283">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_COLORLABEL);</a>
<a name="ln2284">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_TITLE);</a>
<a name="ln2285">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_DESCRIPTION);</a>
<a name="ln2286">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_CREATOR);</a>
<a name="ln2287">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_PUBLISHER);</a>
<a name="ln2288">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_RIGHTS);</a>
<a name="ln2289">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_LENS);</a>
<a name="ln2290">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FOCAL_LENGTH);</a>
<a name="ln2291">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_ISO);</a>
<a name="ln2292">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_APERTURE);</a>
<a name="ln2293">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_ASPECT_RATIO);</a>
<a name="ln2294">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_EXPOSURE);</a>
<a name="ln2295">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FILENAME);</a>
<a name="ln2296">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_GEOTAGGING);</a>
<a name="ln2297">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_LOCAL_COPY);</a>
<a name="ln2298">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_GROUPING);</a>
<a name="ln2299"> </a>
<a name="ln2300">}</a>
<a name="ln2301">#endif</a>
<a name="ln2302">#undef MAX_RULES</a>
<a name="ln2303">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2304">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2305">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="166"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 166, 165.</p></div>
<div class="balloon" rel="326"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="780"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'gtk_tree_model_iter_parent' function: 'child' and 'iter'.</p></div>
<div class="balloon" rel="794"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: level > 0.</p></div>
<div class="balloon" rel="796"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'gtk_tree_model_iter_parent' function: 'child' and 'iter'.</p></div>
<div class="balloon" rel="794"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v571/" target="_blank">V571</a> Recurring check. The 'level > 0' condition was already verified in line 792.</p></div>
<div class="balloon" rel="848"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'result'. Check lines: 848, 846.</p></div>
<div class="balloon" rel="994"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'tuple'. Check lines: 994, 993.</p></div>
<div class="balloon" rel="1165"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'range'. Check lines: 1165, 1163.</p></div>
<div class="balloon" rel="1465"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'range'. Check lines: 1465, 1464.</p></div>
<div class="balloon" rel="2012"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 2012, 2006.</p></div>
<div class="balloon" rel="2170"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'new_p'.</p></div>
<div class="balloon" rel="2190"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'p'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
