
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 henrik andersson.</a>
<a name="ln4">    copyright (c) 2012-2016 tobias ellinghaus.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;common/database.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/iop_order.h&quot;</a>
<a name="ln24">#include &quot;control/conf.h&quot;</a>
<a name="ln25">#include &quot;control/control.h&quot;</a>
<a name="ln26">#include &quot;gui/legacy_presets.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;gio/gio.h&gt;</a>
<a name="ln29">#include &lt;glib.h&gt;</a>
<a name="ln30">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln31">#include &lt;sqlite3.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;errno.h&gt;</a>
<a name="ln34">#include &lt;fcntl.h&gt;</a>
<a name="ln35">#include &lt;signal.h&gt;</a>
<a name="ln36">#include &lt;sys/stat.h&gt;</a>
<a name="ln37">#include &lt;sys/types.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">// whenever _create_*_schema() gets changed you HAVE to bump this version and add an update path to</a>
<a name="ln40">// _upgrade_*_schema_step()!</a>
<a name="ln41">#define CURRENT_DATABASE_VERSION_LIBRARY 18</a>
<a name="ln42">#define CURRENT_DATABASE_VERSION_DATA 1</a>
<a name="ln43"> </a>
<a name="ln44">typedef struct dt_database_t</a>
<a name="ln45">{</a>
<a name="ln46">  gboolean lock_acquired;</a>
<a name="ln47"> </a>
<a name="ln48">  /* data database filename */</a>
<a name="ln49">  gchar *dbfilename_data, *lockfile_data;</a>
<a name="ln50"> </a>
<a name="ln51">  /* library database filename */</a>
<a name="ln52">  gchar *dbfilename_library, *lockfile_library;</a>
<a name="ln53"> </a>
<a name="ln54">  /* ondisk DB */</a>
<a name="ln55">  sqlite3 *handle;</a>
<a name="ln56"> </a>
<a name="ln57">  gchar *error_message, *error_dbfilename;</a>
<a name="ln58">} dt_database_t;</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">/* migrates database from old place to new */</a>
<a name="ln62">static void _database_migrate_to_xdg_structure();</a>
<a name="ln63"> </a>
<a name="ln64">/* delete old mipmaps files */</a>
<a name="ln65">static void _database_delete_mipmaps_files();</a>
<a name="ln66"> </a>
<a name="ln67">#define _SQLITE3_EXEC(a, b, c, d, e)                                                                         \</a>
<a name="ln68">  if(sqlite3_exec(a, b, c, d, e) != SQLITE_OK)                                                               \</a>
<a name="ln69">  {                                                                                                          \</a>
<a name="ln70">    all_ok = FALSE;                                                                                          \</a>
<a name="ln71">    failing_query = b;                                                                                       \</a>
<a name="ln72">    goto end;                                                                                                \</a>
<a name="ln73">  }</a>
<a name="ln74"> </a>
<a name="ln75">/* migrate from the legacy db format (with the 'settings' blob) to the first version this system knows */</a>
<a name="ln76">static gboolean _migrate_schema(dt_database_t *db, int version)</a>
<a name="ln77">{</a>
<a name="ln78">  gboolean all_ok = TRUE;</a>
<a name="ln79">  const char *failing_query = NULL;</a>
<a name="ln80">  sqlite3_stmt *stmt;</a>
<a name="ln81">  sqlite3_stmt *innerstmt;</a>
<a name="ln82"> </a>
<a name="ln83">  if(version != 36) // if anyone shows up with an older db we can probably add extra code</a>
<a name="ln84">    return FALSE;</a>
<a name="ln85"> </a>
<a name="ln86">  sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln87"> </a>
<a name="ln88">  // remove stuff that is either no longer needed or that got renamed</a>
<a name="ln89">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP TABLE IF EXISTS main.lock&quot;, NULL, NULL, NULL);</a>
<a name="ln90">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP TABLE IF EXISTS main.settings&quot;, NULL, NULL, NULL); // yes, we do this in many</a>
<a name="ln91">                                                                                     // places. because it's really</a>
<a name="ln92">                                                                                     // important to not miss it in</a>
<a name="ln93">                                                                                     // any code path.</a>
<a name="ln94">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP INDEX IF EXISTS main.group_id_index&quot;, NULL, NULL, NULL);</a>
<a name="ln95">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP INDEX IF EXISTS main.imgid_index&quot;, NULL, NULL, NULL);</a>
<a name="ln96">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP TABLE IF EXISTS main.mipmaps&quot;, NULL, NULL, NULL);</a>
<a name="ln97">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP TABLE IF EXISTS main.mipmap_timestamps&quot;, NULL, NULL, NULL);</a>
<a name="ln98">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP TABLE IF EXISTS main.dt_migration_table&quot;, NULL, NULL, NULL);</a>
<a name="ln99"> </a>
<a name="ln100">  // using _create_library_schema() and filling that with the old data doesn't work since we always want to generate</a>
<a name="ln101">  // version 1 tables</a>
<a name="ln102">  ////////////////////////////// db_info</a>
<a name="ln103">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE TABLE main.db_info (key VARCHAR PRIMARY KEY, value VARCHAR)&quot;,</a>
<a name="ln104">                NULL, NULL, NULL);</a>
<a name="ln105">  _SQLITE3_EXEC(db-&gt;handle, &quot;INSERT OR REPLACE INTO main.db_info (key, value) VALUES ('version', 1)&quot;,</a>
<a name="ln106">                NULL, NULL, NULL);</a>
<a name="ln107">  ////////////////////////////// film_rolls</a>
<a name="ln108">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE INDEX IF NOT EXISTS main.film_rolls_folder_index ON film_rolls (folder)&quot;,</a>
<a name="ln109">                NULL, NULL, NULL);</a>
<a name="ln110">  ////////////////////////////// images</a>
<a name="ln111">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.images ADD COLUMN orientation INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln112">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.images ADD COLUMN focus_distance REAL&quot;, NULL, NULL, NULL);</a>
<a name="ln113">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.images ADD COLUMN group_id INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln114">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.images ADD COLUMN histogram BLOB&quot;, NULL, NULL, NULL);</a>
<a name="ln115">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.images ADD COLUMN lightmap BLOB&quot;, NULL, NULL, NULL);</a>
<a name="ln116">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.images ADD COLUMN longitude REAL&quot;, NULL, NULL, NULL);</a>
<a name="ln117">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.images ADD COLUMN latitude REAL&quot;, NULL, NULL, NULL);</a>
<a name="ln118">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.images ADD COLUMN color_matrix BLOB&quot;, NULL, NULL, NULL);</a>
<a name="ln119">  // the colorspace as specified in some image types</a>
<a name="ln120">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.images ADD COLUMN colorspace INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln121">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.images ADD COLUMN version INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln122">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.images ADD COLUMN max_version INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln123">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.images SET orientation = -1 WHERE orientation IS NULL&quot;, NULL, NULL, NULL);</a>
<a name="ln124">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.images SET focus_distance = -1 WHERE focus_distance IS NULL&quot;,</a>
<a name="ln125">                NULL, NULL, NULL);</a>
<a name="ln126">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.images SET group_id = id WHERE group_id IS NULL&quot;, NULL, NULL, NULL);</a>
<a name="ln127">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.images SET max_version = (SELECT COUNT(*)-1 FROM main.images i WHERE &quot;</a>
<a name="ln128">                            &quot;i.filename = main.images.filename AND &quot;</a>
<a name="ln129">                            &quot;i.film_id = main.images.film_id) WHERE max_version IS NULL&quot;,</a>
<a name="ln130">                NULL, NULL, NULL);</a>
<a name="ln131">  _SQLITE3_EXEC(</a>
<a name="ln132">      db-&gt;handle,</a>
<a name="ln133">      &quot;UPDATE main.images SET version = (SELECT COUNT(*) FROM main.images i &quot;</a>
<a name="ln134">      &quot;WHERE i.filename = main.images.filename AND &quot;</a>
<a name="ln135">      &quot;i.film_id = main.images.film_id AND i.id &lt; main.images.id) WHERE version IS NULL&quot;,</a>
<a name="ln136">      NULL, NULL, NULL);</a>
<a name="ln137">  // make sure we have AUTOINCREMENT on imgid --&gt; move the whole thing away and recreate the table :(</a>
<a name="ln138">  _SQLITE3_EXEC(db-&gt;handle, &quot;ALTER TABLE main.images RENAME TO dt_migration_table&quot;, NULL, NULL, NULL);</a>
<a name="ln139">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP INDEX IF EXISTS main.images_group_id_index&quot;, NULL, NULL, NULL);</a>
<a name="ln140">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP INDEX IF EXISTS main.images_film_id_index&quot;, NULL, NULL, NULL);</a>
<a name="ln141">  _SQLITE3_EXEC(</a>
<a name="ln142">      db-&gt;handle,</a>
<a name="ln143">      &quot;CREATE TABLE main.images (id INTEGER PRIMARY KEY AUTOINCREMENT, group_id INTEGER, film_id INTEGER, &quot;</a>
<a name="ln144">      &quot;width INTEGER, height INTEGER, filename VARCHAR, maker VARCHAR, model VARCHAR, &quot;</a>
<a name="ln145">      &quot;lens VARCHAR, exposure REAL, aperture REAL, iso REAL, focal_length REAL, &quot;</a>
<a name="ln146">      &quot;focus_distance REAL, datetime_taken CHAR(20), flags INTEGER, &quot;</a>
<a name="ln147">      &quot;output_width INTEGER, output_height INTEGER, crop REAL, &quot;</a>
<a name="ln148">      &quot;raw_parameters INTEGER, raw_denoise_threshold REAL, &quot;</a>
<a name="ln149">      &quot;raw_auto_bright_threshold REAL, raw_black INTEGER, raw_maximum INTEGER, &quot;</a>
<a name="ln150">      &quot;caption VARCHAR, description VARCHAR, license VARCHAR, sha1sum CHAR(40), &quot;</a>
<a name="ln151">      &quot;orientation INTEGER, histogram BLOB, lightmap BLOB, longitude REAL, &quot;</a>
<a name="ln152">      &quot;latitude REAL, color_matrix BLOB, colorspace INTEGER, version INTEGER, max_version INTEGER)&quot;,</a>
<a name="ln153">      NULL, NULL, NULL);</a>
<a name="ln154">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE INDEX main.images_group_id_index ON images (group_id)&quot;, NULL, NULL, NULL);</a>
<a name="ln155">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE INDEX main.images_film_id_index ON images (film_id)&quot;, NULL, NULL, NULL);</a>
<a name="ln156">  _SQLITE3_EXEC(</a>
<a name="ln157">      db-&gt;handle,</a>
<a name="ln158">      &quot;INSERT INTO main.images (id, group_id, film_id, width, height, filename, maker, model, &quot;</a>
<a name="ln159">      &quot;lens, exposure, aperture, iso, focal_length, focus_distance, datetime_taken, flags, &quot;</a>
<a name="ln160">      &quot;output_width, output_height, crop, raw_parameters, raw_denoise_threshold, &quot;</a>
<a name="ln161">      &quot;raw_auto_bright_threshold, raw_black, raw_maximum, caption, description, license, sha1sum, &quot;</a>
<a name="ln162">      &quot;orientation, histogram, lightmap, longitude, latitude, color_matrix, colorspace, version, &quot;</a>
<a name="ln163">      &quot;max_version) &quot;</a>
<a name="ln164">      &quot;SELECT id, group_id, film_id, width, height, filename, maker, model, lens, exposure, aperture, iso, &quot;</a>
<a name="ln165">      &quot;focal_length, focus_distance, datetime_taken, flags, output_width, output_height, crop, &quot;</a>
<a name="ln166">      &quot;raw_parameters, raw_denoise_threshold, raw_auto_bright_threshold, raw_black, raw_maximum, &quot;</a>
<a name="ln167">      &quot;caption, description, license, sha1sum, orientation, histogram, lightmap, longitude, &quot;</a>
<a name="ln168">      &quot;latitude, color_matrix, colorspace, version, max_version FROM dt_migration_table&quot;,</a>
<a name="ln169">      NULL, NULL, NULL);</a>
<a name="ln170">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP TABLE dt_migration_table&quot;, NULL, NULL, NULL);</a>
<a name="ln171">  ////////////////////////////// selected_images</a>
<a name="ln172">  // selected_images should have a primary key. add it if it's missing:</a>
<a name="ln173">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE TEMPORARY TABLE dt_migration_table (imgid INTEGER)&quot;, NULL, NULL, NULL);</a>
<a name="ln174">  _SQLITE3_EXEC(db-&gt;handle, &quot;INSERT INTO dt_migration_table SELECT imgid FROM main.selected_images&quot;, NULL, NULL,</a>
<a name="ln175">                NULL);</a>
<a name="ln176">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP TABLE main.selected_images&quot;, NULL, NULL, NULL);</a>
<a name="ln177">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE TABLE main.selected_images (imgid INTEGER PRIMARY KEY)&quot;, NULL, NULL, NULL);</a>
<a name="ln178">  _SQLITE3_EXEC(db-&gt;handle, &quot;INSERT OR IGNORE INTO main.selected_images SELECT imgid FROM dt_migration_table&quot;,</a>
<a name="ln179">                NULL, NULL, NULL);</a>
<a name="ln180">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP TABLE dt_migration_table&quot;, NULL, NULL, NULL);</a>
<a name="ln181">  ////////////////////////////// history</a>
<a name="ln182">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.history ADD COLUMN blendop_params BLOB&quot;, NULL, NULL, NULL);</a>
<a name="ln183">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.history ADD COLUMN blendop_version INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln184">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.history ADD COLUMN multi_priority INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln185">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.history ADD COLUMN multi_name VARCHAR(256)&quot;, NULL, NULL, NULL);</a>
<a name="ln186">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE INDEX IF NOT EXISTS main.history_imgid_index ON history (imgid)&quot;, NULL, NULL,</a>
<a name="ln187">                NULL);</a>
<a name="ln188">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.history SET blendop_version = 1 WHERE blendop_version IS NULL&quot;, NULL,</a>
<a name="ln189">                NULL, NULL);</a>
<a name="ln190">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.history SET multi_priority = 0 WHERE multi_priority IS NULL&quot;, NULL, NULL,</a>
<a name="ln191">                NULL);</a>
<a name="ln192">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.history SET multi_name = ' ' WHERE multi_name IS NULL&quot;, NULL, NULL, NULL);</a>
<a name="ln193">  ////////////////////////////// mask</a>
<a name="ln194">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE TABLE IF NOT EXISTS main.mask (imgid INTEGER, formid INTEGER, form INTEGER, &quot;</a>
<a name="ln195">                            &quot;name VARCHAR(256), version INTEGER, &quot;</a>
<a name="ln196">                            &quot;points BLOB, points_count INTEGER, source BLOB)&quot;,</a>
<a name="ln197">                NULL, NULL, NULL);</a>
<a name="ln198">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.mask ADD COLUMN source BLOB&quot;, NULL, NULL,</a>
<a name="ln199">               NULL); // in case the table was there already but missed that column</a>
<a name="ln200">  ////////////////////////////// tagged_images</a>
<a name="ln201">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE INDEX IF NOT EXISTS main.tagged_images_tagid_index ON tagged_images (tagid)&quot;,</a>
<a name="ln202">                NULL, NULL, NULL);</a>
<a name="ln203">  ////////////////////////////// styles</a>
<a name="ln204">  _SQLITE3_EXEC(db-&gt;handle,</a>
<a name="ln205">                &quot;CREATE TABLE IF NOT EXISTS main.styles (id INTEGER, name VARCHAR, description VARCHAR)&quot;, NULL,</a>
<a name="ln206">                NULL, NULL);</a>
<a name="ln207">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.styles ADD COLUMN id INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln208">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.styles SET id = rowid WHERE id IS NULL&quot;, NULL, NULL, NULL);</a>
<a name="ln209">  ////////////////////////////// style_items</a>
<a name="ln210">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE TABLE IF NOT EXISTS main.style_items (styleid INTEGER, num INTEGER, module &quot;</a>
<a name="ln211">                            &quot;INTEGER, operation VARCHAR(256), op_params BLOB, &quot;</a>
<a name="ln212">                            &quot;enabled INTEGER, blendop_params BLOB, blendop_version INTEGER, multi_priority &quot;</a>
<a name="ln213">                            &quot;INTEGER, multi_name VARCHAR(256))&quot;,</a>
<a name="ln214">                NULL, NULL, NULL);</a>
<a name="ln215">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.style_items ADD COLUMN blendop_params BLOB&quot;, NULL, NULL, NULL);</a>
<a name="ln216">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.style_items ADD COLUMN blendop_version INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln217">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.style_items ADD COLUMN multi_priority INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln218">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.style_items ADD COLUMN multi_name VARCHAR(256)&quot;, NULL, NULL, NULL);</a>
<a name="ln219">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.style_items SET blendop_version = 1 WHERE blendop_version IS NULL&quot;, NULL,</a>
<a name="ln220">                NULL, NULL);</a>
<a name="ln221">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.style_items SET multi_priority = 0 WHERE multi_priority IS NULL&quot;, NULL,</a>
<a name="ln222">                NULL, NULL);</a>
<a name="ln223">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.style_items SET multi_name = ' ' WHERE multi_name IS NULL&quot;, NULL, NULL,</a>
<a name="ln224">                NULL);</a>
<a name="ln225">  ////////////////////////////// color_labels</a>
<a name="ln226">  // color_labels could have a PRIMARY KEY that we don't want</a>
<a name="ln227">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE TEMPORARY TABLE dt_migration_table (imgid INTEGER, color INTEGER)&quot;, NULL,</a>
<a name="ln228">                NULL, NULL);</a>
<a name="ln229">  _SQLITE3_EXEC(db-&gt;handle, &quot;INSERT INTO dt_migration_table SELECT imgid, color FROM main.color_labels&quot;, NULL,</a>
<a name="ln230">                NULL, NULL);</a>
<a name="ln231">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP TABLE main.color_labels&quot;, NULL, NULL, NULL);</a>
<a name="ln232">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE TABLE main.color_labels (imgid INTEGER, color INTEGER)&quot;, NULL, NULL, NULL);</a>
<a name="ln233">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE UNIQUE INDEX main.color_labels_idx ON color_labels (imgid, color)&quot;, NULL, NULL,</a>
<a name="ln234">                NULL);</a>
<a name="ln235">  _SQLITE3_EXEC(db-&gt;handle, &quot;INSERT OR IGNORE INTO main.color_labels SELECT imgid, color FROM dt_migration_table&quot;,</a>
<a name="ln236">                NULL, NULL, NULL);</a>
<a name="ln237">  _SQLITE3_EXEC(db-&gt;handle, &quot;DROP TABLE dt_migration_table&quot;, NULL, NULL, NULL);</a>
<a name="ln238">  ////////////////////////////// meta_data</a>
<a name="ln239">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE TABLE IF NOT EXISTS main.meta_data (id INTEGER, key INTEGER, value VARCHAR)&quot;,</a>
<a name="ln240">                NULL, NULL, NULL);</a>
<a name="ln241">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE INDEX IF NOT EXISTS main.metadata_index ON meta_data (id, key)&quot;, NULL, NULL,</a>
<a name="ln242">                NULL);</a>
<a name="ln243">  ////////////////////////////// presets</a>
<a name="ln244">  _SQLITE3_EXEC(db-&gt;handle, &quot;CREATE TABLE IF NOT EXISTS main.presets (name VARCHAR, description VARCHAR, &quot;</a>
<a name="ln245">                            &quot;operation VARCHAR, op_version INTEGER, op_params BLOB, &quot;</a>
<a name="ln246">                            &quot;enabled INTEGER, blendop_params BLOB, blendop_version INTEGER, multi_priority &quot;</a>
<a name="ln247">                            &quot;INTEGER, multi_name VARCHAR(256), &quot;</a>
<a name="ln248">                            &quot;model VARCHAR, maker VARCHAR, lens VARCHAR, iso_min REAL, iso_max REAL, &quot;</a>
<a name="ln249">                            &quot;exposure_min REAL, exposure_max REAL, &quot;</a>
<a name="ln250">                            &quot;aperture_min REAL, aperture_max REAL, focal_length_min REAL, focal_length_max &quot;</a>
<a name="ln251">                            &quot;REAL, writeprotect INTEGER, &quot;</a>
<a name="ln252">                            &quot;autoapply INTEGER, filter INTEGER, def INTEGER, isldr INTEGER)&quot;,</a>
<a name="ln253">                NULL, NULL, NULL);</a>
<a name="ln254">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.presets ADD COLUMN op_version INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln255">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.presets ADD COLUMN blendop_params BLOB&quot;, NULL, NULL, NULL);</a>
<a name="ln256">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.presets ADD COLUMN blendop_version INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln257">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.presets ADD COLUMN multi_priority INTEGER&quot;, NULL, NULL, NULL);</a>
<a name="ln258">  sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE main.presets ADD COLUMN multi_name VARCHAR(256)&quot;, NULL, NULL, NULL);</a>
<a name="ln259">  // the unique index only works if the db doesn't have any (name, operation, op_version) more than once.</a>
<a name="ln260">  // apparently there are dbs out there which do have that. :(</a>
<a name="ln261">  sqlite3_prepare_v2(db-&gt;handle,</a>
<a name="ln262">                     &quot;SELECT p.rowid, p.name, p.operation, p.op_version FROM main.presets p INNER JOIN &quot;</a>
<a name="ln263">                     &quot;(SELECT * FROM (SELECT rowid, name, operation, op_version, COUNT(*) AS count &quot;</a>
<a name="ln264">                     &quot;FROM main.presets GROUP BY name, operation, op_version) WHERE count &gt; 1) s &quot;</a>
<a name="ln265">                     &quot;ON p.name = s.name AND p.operation = s.operation AND p.op_version = s.op_version&quot;,</a>
<a name="ln266">                     -1, &amp;stmt, NULL);</a>
<a name="ln267">  char *last_name = NULL, *last_operation = NULL;</a>
<a name="ln268">  int last_op_version = 0;</a>
<a name="ln269">  int i = 0;</a>
<a name="ln270">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln271">  {</a>
<a name="ln272">    int rowid = sqlite3_column_int(stmt, 0);</a>
<a name="ln273">    const char *name = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln274">    const char *operation = (const char *)sqlite3_column_text(stmt, 2);</a>
<a name="ln275">    int op_version = sqlite3_column_int(stmt, 3);</a>
<a name="ln276"> </a>
<a name="ln277">    // is it still the same (name, operation, op_version) triple?</a>
<a name="ln278">    if(!last_name || strcmp(last_name, name) || !last_operation || strcmp(last_operation, operation)</a>
<a name="ln279">       || last_op_version != op_version)</a>
<a name="ln280">    {</a>
<a name="ln281">      g_free(last_name);</a>
<a name="ln282">      g_free(last_operation);</a>
<a name="ln283">      last_name = g_strdup(name);</a>
<a name="ln284">      last_operation = g_strdup(operation);</a>
<a name="ln285">      last_op_version = op_version;</a>
<a name="ln286">      i = 0;</a>
<a name="ln287">    }</a>
<a name="ln288"> </a>
<a name="ln289">    // find the next free amended version of name</a>
<a name="ln290">    sqlite3_prepare_v2(db-&gt;handle, &quot;SELECT name FROM main.presets  WHERE name = ?1 || ' (' || ?2 || ')' AND &quot;</a>
<a name="ln291">                                   &quot;operation = ?3 AND op_version = ?4&quot;,</a>
<a name="ln292">                       -1, &amp;innerstmt, NULL);</a>
<a name="ln293">    while(1)</a>
<a name="ln294">    {</a>
<a name="ln295">      sqlite3_bind_text(innerstmt, 1, name, -1, SQLITE_TRANSIENT);</a>
<a name="ln296">      sqlite3_bind_int(innerstmt, 2, i);</a>
<a name="ln297">      sqlite3_bind_text(innerstmt, 3, operation, -1, SQLITE_TRANSIENT);</a>
<a name="ln298">      sqlite3_bind_int(innerstmt, 4, op_version);</a>
<a name="ln299">      if(sqlite3_step(innerstmt) != SQLITE_ROW) break;</a>
<a name="ln300">      sqlite3_reset(innerstmt);</a>
<a name="ln301">      sqlite3_clear_bindings(innerstmt);</a>
<a name="ln302">      i++;</a>
<a name="ln303">    }</a>
<a name="ln304">    sqlite3_finalize(innerstmt);</a>
<a name="ln305"> </a>
<a name="ln306">    // rename preset</a>
<a name="ln307">    const char *query = &quot;UPDATE main.presets SET name = name || ' (' || ?1 || ')' WHERE rowid = ?2&quot;;</a>
<a name="ln308">    sqlite3_prepare_v2(db-&gt;handle, query, -1, &amp;innerstmt, NULL);</a>
<a name="ln309">    sqlite3_bind_int(innerstmt, 1, i);</a>
<a name="ln310">    sqlite3_bind_int(innerstmt, 2, rowid);</a>
<a name="ln311">    if(sqlite3_step(innerstmt) != SQLITE_DONE)</a>
<a name="ln312">    {</a>
<a name="ln313">      all_ok = FALSE;</a>
<a name="ln314">      failing_query = query;</a>
<a name="ln315">      goto end;</a>
<a name="ln316">    }</a>
<a name="ln317">    sqlite3_finalize(innerstmt);</a>
<a name="ln318">  }</a>
<a name="ln319">  sqlite3_finalize(stmt);</a>
<a name="ln320">  g_free(last_name);</a>
<a name="ln321">  g_free(last_operation);</a>
<a name="ln322">  // now we should be able to create the index</a>
<a name="ln323">  _SQLITE3_EXEC(db-&gt;handle,</a>
<a name="ln324">                &quot;CREATE UNIQUE INDEX IF NOT EXISTS main.presets_idx ON presets (name, operation, op_version)&quot;,</a>
<a name="ln325">                NULL, NULL, NULL);</a>
<a name="ln326">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.presets SET blendop_version = 1 WHERE blendop_version IS NULL&quot;, NULL,</a>
<a name="ln327">                NULL, NULL);</a>
<a name="ln328">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.presets SET multi_priority = 0 WHERE multi_priority IS NULL&quot;, NULL, NULL,</a>
<a name="ln329">                NULL);</a>
<a name="ln330">  _SQLITE3_EXEC(db-&gt;handle, &quot;UPDATE main.presets SET multi_name = ' ' WHERE multi_name IS NULL&quot;, NULL, NULL, NULL);</a>
<a name="ln331"> </a>
<a name="ln332"> </a>
<a name="ln333">  // There are systems where absolute paths don't start with '/' (like Windows).</a>
<a name="ln334">  // Since the bug which introduced absolute paths to the db was fixed before a</a>
<a name="ln335">  // Windows build was available this shouldn't matter though.</a>
<a name="ln336">  sqlite3_prepare_v2(db-&gt;handle, &quot;SELECT id, filename FROM main.images WHERE filename LIKE '/%'&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln337">  sqlite3_prepare_v2(db-&gt;handle, &quot;UPDATE main.images SET filename = ?1 WHERE id = ?2&quot;, -1, &amp;innerstmt, NULL);</a>
<a name="ln338">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln339">  {</a>
<a name="ln340">    int id = sqlite3_column_int(stmt, 0);</a>
<a name="ln341">    const char *path = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln342">    gchar *filename = g_path_get_basename(path);</a>
<a name="ln343">    sqlite3_bind_text(innerstmt, 1, filename, -1, SQLITE_TRANSIENT);</a>
<a name="ln344">    sqlite3_bind_int(innerstmt, 2, id);</a>
<a name="ln345">    sqlite3_step(innerstmt);</a>
<a name="ln346">    sqlite3_reset(innerstmt);</a>
<a name="ln347">    sqlite3_clear_bindings(innerstmt);</a>
<a name="ln348">    g_free(filename);</a>
<a name="ln349">  }</a>
<a name="ln350">  sqlite3_finalize(stmt);</a>
<a name="ln351">  sqlite3_finalize(innerstmt);</a>
<a name="ln352"> </a>
<a name="ln353">  // We used to insert datetime_taken entries with '-' as date separators. Since that doesn't work well with</a>
<a name="ln354">  // the regular ':' when parsing</a>
<a name="ln355">  // or sorting we changed it to ':'. This takes care to change what we have as leftovers</a>
<a name="ln356">  _SQLITE3_EXEC(</a>
<a name="ln357">      db-&gt;handle,</a>
<a name="ln358">      &quot;UPDATE main.images SET datetime_taken = REPLACE(datetime_taken, '-', ':') WHERE datetime_taken LIKE '%-%'&quot;,</a>
<a name="ln359">      NULL, NULL, NULL);</a>
<a name="ln360"> </a>
<a name="ln361">end:</a>
<a name="ln362">  if(all_ok)</a>
<a name="ln363">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln364">  else</a>
<a name="ln365">  {</a>
<a name="ln366">    fprintf(stderr, &quot;[init] failing query: `%s'\n&quot;, failing_query);</a>
<a name="ln367">    fprintf(stderr, &quot;[init]   %s\n&quot;, sqlite3_errmsg(db-&gt;handle));</a>
<a name="ln368">    sqlite3_exec(db-&gt;handle, &quot;ROLLBACK TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln369">  }</a>
<a name="ln370"> </a>
<a name="ln371">  return all_ok;</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">#undef _SQLITE3_EXEC</a>
<a name="ln375"> </a>
<a name="ln376">#define TRY_EXEC(_query, _message)                                               \</a>
<a name="ln377">  do                                                                             \</a>
<a name="ln378">  {                                                                              \</a>
<a name="ln379">    if(sqlite3_exec(db-&gt;handle, _query, NULL, NULL, NULL) != SQLITE_OK)          \</a>
<a name="ln380">    {                                                                            \</a>
<a name="ln381">      fprintf(stderr, _message);                                                 \</a>
<a name="ln382">      fprintf(stderr, &quot;[init]   %s\n&quot;, sqlite3_errmsg(db-&gt;handle));              \</a>
<a name="ln383">      FINALIZE;                                                                  \</a>
<a name="ln384">      sqlite3_exec(db-&gt;handle, &quot;ROLLBACK TRANSACTION&quot;, NULL, NULL, NULL);        \</a>
<a name="ln385">      return version;                                                            \</a>
<a name="ln386">    }                                                                            \</a>
<a name="ln387">  } while(0)</a>
<a name="ln388"> </a>
<a name="ln389">#define TRY_STEP(_stmt, _expected, _message)                                     \</a>
<a name="ln390">  do                                                                             \</a>
<a name="ln391">  {                                                                              \</a>
<a name="ln392">    if(sqlite3_step(_stmt) != _expected)                                         \</a>
<a name="ln393">    {                                                                            \</a>
<a name="ln394">      fprintf(stderr, _message);                                                 \</a>
<a name="ln395">      fprintf(stderr, &quot;[init]   %s\n&quot;, sqlite3_errmsg(db-&gt;handle));              \</a>
<a name="ln396">      FINALIZE;                                                                  \</a>
<a name="ln397">      sqlite3_exec(db-&gt;handle, &quot;ROLLBACK TRANSACTION&quot;, NULL, NULL, NULL);        \</a>
<a name="ln398">      return version;                                                            \</a>
<a name="ln399">    }                                                                            \</a>
<a name="ln400">  } while(0)</a>
<a name="ln401"> </a>
<a name="ln402">#define TRY_PREPARE(_stmt, _query, _message)                                     \</a>
<a name="ln403">  do                                                                             \</a>
<a name="ln404">  {                                                                              \</a>
<a name="ln405">    if(sqlite3_prepare_v2(db-&gt;handle, _query, -1, &amp;_stmt, NULL) != SQLITE_OK)    \</a>
<a name="ln406">    {                                                                            \</a>
<a name="ln407">      fprintf(stderr, _message);                                                 \</a>
<a name="ln408">      fprintf(stderr, &quot;[init]   %s\n&quot;, sqlite3_errmsg(db-&gt;handle));              \</a>
<a name="ln409">      FINALIZE;                                                                  \</a>
<a name="ln410">      sqlite3_exec(db-&gt;handle, &quot;ROLLBACK TRANSACTION&quot;, NULL, NULL, NULL);        \</a>
<a name="ln411">      return version;                                                            \</a>
<a name="ln412">    }                                                                            \</a>
<a name="ln413">  } while(0)</a>
<a name="ln414"> </a>
<a name="ln415">// redefine this where needed</a>
<a name="ln416">#define FINALIZE</a>
<a name="ln417"> </a>
<a name="ln418">/* do the real migration steps, returns the version the db was converted to */</a>
<a name="ln419">static int _upgrade_library_schema_step(dt_database_t *db, int version)</a>
<a name="ln420">{</a>
<a name="ln421">  sqlite3_stmt *stmt;</a>
<a name="ln422">  int new_version = version;</a>
<a name="ln423">  if(version == CURRENT_DATABASE_VERSION_LIBRARY)</a>
<a name="ln424">    return version;</a>
<a name="ln425">  else if(version == 0)</a>
<a name="ln426">  {</a>
<a name="ln427">    // this can't happen, we started with 1, but it's a good example how this function works</a>
<a name="ln428">    // &lt;do some magic to the db&gt;</a>
<a name="ln429">    new_version = 1; // the version we transformed the db to. this way it might be possible to roll back or</a>
<a name="ln430">                     // add fast paths</a>
<a name="ln431">  }</a>
<a name="ln432">  else if(version == 1)</a>
<a name="ln433">  {</a>
<a name="ln434">    // 1 -&gt; 2 added write_timestamp</a>
<a name="ln435">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln436">    TRY_EXEC(&quot;ALTER TABLE main.images ADD COLUMN write_timestamp INTEGER&quot;,</a>
<a name="ln437">             &quot;[init] can't add `write_timestamp' column to database\n&quot;);</a>
<a name="ln438">    TRY_EXEC(&quot;UPDATE main.images SET write_timestamp = STRFTIME('%s', 'now') WHERE write_timestamp IS NULL&quot;,</a>
<a name="ln439">             &quot;[init] can't initialize `write_timestamp' with current point in time\n&quot;);</a>
<a name="ln440">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln441">    new_version = 2;</a>
<a name="ln442">  }</a>
<a name="ln443">  else if(version == 2)</a>
<a name="ln444">  {</a>
<a name="ln445">    // 2 -&gt; 3 reset raw_black and raw_maximum. in theory we should change the columns from REAL to INTEGER,</a>
<a name="ln446">    // but sqlite doesn't care about types so whatever</a>
<a name="ln447">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln448">    TRY_EXEC(&quot;UPDATE main.images SET raw_black = 0, raw_maximum = 16384&quot;,</a>
<a name="ln449">             &quot;[init] can't reset raw_black and raw_maximum\n&quot;);</a>
<a name="ln450">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln451">    new_version = 3;</a>
<a name="ln452">  }</a>
<a name="ln453">  else if(version == 3)</a>
<a name="ln454">  {</a>
<a name="ln455">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln456"> </a>
<a name="ln457">    TRY_EXEC(&quot;CREATE TRIGGER insert_tag AFTER INSERT ON main.tags&quot;</a>
<a name="ln458">             &quot; BEGIN&quot;</a>
<a name="ln459">             &quot;   INSERT INTO tagxtag SELECT id, new.id, 0 FROM TAGS;&quot;</a>
<a name="ln460">             &quot;   UPDATE tagxtag SET count = 1000000 WHERE id1=new.id AND id2=new.id;&quot;</a>
<a name="ln461">             &quot; END&quot;,</a>
<a name="ln462">             &quot;[init] can't create insert_tag trigger\n&quot;);</a>
<a name="ln463">    TRY_EXEC(&quot;CREATE TRIGGER delete_tag BEFORE DELETE ON main.tags&quot;</a>
<a name="ln464">             &quot; BEGIN&quot;</a>
<a name="ln465">             &quot;   DELETE FROM tagxtag WHERE id1=old.id OR id2=old.id;&quot;</a>
<a name="ln466">             &quot;   DELETE FROM tagged_images WHERE tagid=old.id;&quot;</a>
<a name="ln467">             &quot; END&quot;,</a>
<a name="ln468">             &quot;[init] can't create delete_tag trigger\n&quot;);</a>
<a name="ln469">    TRY_EXEC(&quot;CREATE TRIGGER attach_tag AFTER INSERT ON main.tagged_images&quot;</a>
<a name="ln470">             &quot; BEGIN&quot;</a>
<a name="ln471">             &quot;   UPDATE tagxtag&quot;</a>
<a name="ln472">             &quot;     SET count = count + 1&quot;</a>
<a name="ln473">             &quot;     WHERE (id1=new.tagid AND id2 IN (SELECT tagid FROM tagged_images WHERE imgid=new.imgid))&quot;</a>
<a name="ln474">             &quot;        OR (id2=new.tagid AND id1 IN (SELECT tagid FROM tagged_images WHERE imgid=new.imgid));&quot;</a>
<a name="ln475">             &quot; END&quot;,</a>
<a name="ln476">             &quot;[init] can't create attach_tag trigger\n&quot;);</a>
<a name="ln477">    TRY_EXEC(&quot;CREATE TRIGGER detach_tag BEFORE DELETE ON main.tagged_images&quot;</a>
<a name="ln478">             &quot; BEGIN&quot;</a>
<a name="ln479">             &quot;   UPDATE tagxtag&quot;</a>
<a name="ln480">             &quot;     SET count = count - 1&quot;</a>
<a name="ln481">             &quot;     WHERE (id1=old.tagid AND id2 IN (SELECT tagid FROM tagged_images WHERE imgid=old.imgid))&quot;</a>
<a name="ln482">             &quot;        OR (id2=old.tagid AND id1 IN (SELECT tagid FROM tagged_images WHERE imgid=old.imgid));&quot;</a>
<a name="ln483">             &quot; END&quot;,</a>
<a name="ln484">             &quot;[init] can't create detach_tag trigger\n&quot;);</a>
<a name="ln485"> </a>
<a name="ln486">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln487">    new_version = 4;</a>
<a name="ln488">  }</a>
<a name="ln489">  else if(version == 4)</a>
<a name="ln490">  {</a>
<a name="ln491">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln492"> </a>
<a name="ln493">    TRY_EXEC(&quot;ALTER TABLE main.presets RENAME TO tmp_presets&quot;,  &quot;[init] can't rename table presets\n&quot;);</a>
<a name="ln494"> </a>
<a name="ln495">    TRY_EXEC(&quot;CREATE TABLE main.presets (name VARCHAR, description VARCHAR, operation VARCHAR, op_params BLOB,&quot;</a>
<a name="ln496">             &quot;enabled INTEGER, blendop_params BLOB, model VARCHAR, maker VARCHAR, lens VARCHAR,&quot;</a>
<a name="ln497">             &quot;iso_min REAL, iso_max REAL, exposure_min REAL, exposure_max REAL, aperture_min REAL,&quot;</a>
<a name="ln498">             &quot;aperture_max REAL, focal_length_min REAL, focal_length_max REAL, writeprotect INTEGER,&quot;</a>
<a name="ln499">             &quot;autoapply INTEGER, filter INTEGER, def INTEGER, format INTEGER, op_version INTEGER,&quot;</a>
<a name="ln500">             &quot;blendop_version INTEGER, multi_priority INTEGER, multi_name VARCHAR(256))&quot;,</a>
<a name="ln501">             &quot;[init] can't create new presets table\n&quot;);</a>
<a name="ln502"> </a>
<a name="ln503">    TRY_EXEC(&quot;INSERT INTO main.presets (name, description, operation, op_params, enabled, blendop_params, model, &quot;</a>
<a name="ln504">             &quot;maker, lens, iso_min, iso_max, exposure_min, exposure_max, aperture_min, aperture_max,&quot;</a>
<a name="ln505">             &quot;focal_length_min, focal_length_max, writeprotect, autoapply, filter, def, format, op_version, &quot;</a>
<a name="ln506">             &quot;blendop_version, multi_priority, multi_name) SELECT name, description, operation, op_params, &quot;</a>
<a name="ln507">             &quot;enabled, blendop_params, model, maker, lens, iso_min, iso_max, exposure_min, exposure_max, &quot;</a>
<a name="ln508">             &quot;aperture_min, aperture_max, focal_length_min, focal_length_max, writeprotect, autoapply, filter, &quot;</a>
<a name="ln509">             &quot;def, isldr, op_version, blendop_version, multi_priority, multi_name FROM tmp_presets&quot;,</a>
<a name="ln510">             &quot;[init] can't populate presets table from tmp_presets\n&quot;);</a>
<a name="ln511"> </a>
<a name="ln512">    TRY_EXEC(&quot;DROP TABLE tmp_presets&quot;, &quot;[init] can't delete table tmp_presets\n&quot;);</a>
<a name="ln513"> </a>
<a name="ln514">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln515">    new_version = 5;</a>
<a name="ln516">  }</a>
<a name="ln517">  else if(version == 5)</a>
<a name="ln518">  {</a>
<a name="ln519">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln520"> </a>
<a name="ln521">    TRY_EXEC(&quot;CREATE INDEX main.images_filename_index ON images (filename)&quot;,</a>
<a name="ln522">             &quot;[init] can't create index on image filename\n&quot;);</a>
<a name="ln523"> </a>
<a name="ln524">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln525">    new_version = 6;</a>
<a name="ln526">  }</a>
<a name="ln527">  else if(version == 6)</a>
<a name="ln528">  {</a>
<a name="ln529">    // some ancient tables can have the styleid column of style_items be called style_id. fix that.</a>
<a name="ln530">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln531"> </a>
<a name="ln532">    if(sqlite3_exec(db-&gt;handle, &quot;SELECT style_id FROM main.style_items&quot;, NULL, NULL, NULL) == SQLITE_OK)</a>
<a name="ln533">    {</a>
<a name="ln534">      TRY_EXEC(&quot;ALTER TABLE main.style_items RENAME TO tmp_style_items&quot;,</a>
<a name="ln535">               &quot;[init] can't rename table style_items\n&quot;);</a>
<a name="ln536"> </a>
<a name="ln537">      TRY_EXEC(&quot;CREATE TABLE main.style_items (styleid INTEGER, num INTEGER, module INTEGER, &quot;</a>
<a name="ln538">               &quot;operation VARCHAR(256), op_params BLOB, enabled INTEGER, &quot;</a>
<a name="ln539">               &quot;blendop_params BLOB, blendop_version INTEGER, multi_priority INTEGER, multi_name VARCHAR(256))&quot;,</a>
<a name="ln540">               &quot;[init] can't create new style_items table\n&quot;);</a>
<a name="ln541"> </a>
<a name="ln542">      TRY_EXEC(&quot;INSERT INTO main.style_items (styleid, num, module, operation, op_params, enabled,&quot;</a>
<a name="ln543">               &quot;                         blendop_params, blendop_version, multi_priority, multi_name)&quot;</a>
<a name="ln544">               &quot;                  SELECT style_id, num, module, operation, op_params, enabled,&quot;</a>
<a name="ln545">               &quot;                         blendop_params, blendop_version, multi_priority, multi_name&quot;</a>
<a name="ln546">               &quot;                  FROM   tmp_style_items&quot;,</a>
<a name="ln547">               &quot;[init] can't populate style_items table from tmp_style_items\n&quot;);</a>
<a name="ln548"> </a>
<a name="ln549">      TRY_EXEC(&quot;DROP TABLE tmp_style_items&quot;, &quot;[init] can't delete table tmp_style_items\n&quot;);</a>
<a name="ln550">    }</a>
<a name="ln551"> </a>
<a name="ln552">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln553">    new_version = 7;</a>
<a name="ln554">  }</a>
<a name="ln555">  else if(version == 7)</a>
<a name="ln556">  {</a>
<a name="ln557">    // make sure that we have no film rolls with a NULL folder</a>
<a name="ln558">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln559"> </a>
<a name="ln560">    TRY_EXEC(&quot;ALTER TABLE main.film_rolls RENAME TO tmp_film_rolls&quot;, &quot;[init] can't rename table film_rolls\n&quot;);</a>
<a name="ln561"> </a>
<a name="ln562">    TRY_EXEC(&quot;CREATE TABLE main.film_rolls &quot;</a>
<a name="ln563">             &quot;(id INTEGER PRIMARY KEY, datetime_accessed CHAR(20), &quot;</a>
<a name="ln564">             &quot;folder VARCHAR(1024) NOT NULL)&quot;,</a>
<a name="ln565">             &quot;[init] can't create new film_rolls table\n&quot;);</a>
<a name="ln566"> </a>
<a name="ln567">    TRY_EXEC(&quot;INSERT INTO main.film_rolls (id, datetime_accessed, folder) &quot;</a>
<a name="ln568">             &quot;SELECT id, datetime_accessed, folder &quot;</a>
<a name="ln569">             &quot;FROM   tmp_film_rolls &quot;</a>
<a name="ln570">             &quot;WHERE  folder IS NOT NULL&quot;,</a>
<a name="ln571">             &quot;[init] can't populate film_rolls table from tmp_film_rolls\n&quot;);</a>
<a name="ln572"> </a>
<a name="ln573">    TRY_EXEC(&quot;DROP TABLE tmp_film_rolls&quot;, &quot;[init] can't delete table tmp_film_rolls\n&quot;);</a>
<a name="ln574"> </a>
<a name="ln575">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln576">    new_version = 8;</a>
<a name="ln577">  }</a>
<a name="ln578">  else if(version == 8)</a>
<a name="ln579">  {</a>
<a name="ln580">    // 8 -&gt; 9 added history_end column to images</a>
<a name="ln581">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln582"> </a>
<a name="ln583">    TRY_EXEC(&quot;ALTER TABLE main.images ADD COLUMN history_end INTEGER&quot;,</a>
<a name="ln584">             &quot;[init] can't add `history_end' column to database\n&quot;);</a>
<a name="ln585"> </a>
<a name="ln586">    TRY_EXEC(&quot;UPDATE main.images SET history_end = (SELECT IFNULL(MAX(num) + 1, 0) FROM main.history &quot;</a>
<a name="ln587">             &quot;WHERE imgid = id)&quot;, &quot;[init] can't initialize `history_end' with last history entry\n&quot;);</a>
<a name="ln588"> </a>
<a name="ln589">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln590">    new_version = 9;</a>
<a name="ln591">  }</a>
<a name="ln592">  else if(version == 9)</a>
<a name="ln593">  {</a>
<a name="ln594">    // 9 -&gt; 10 cleanup of last update :(</a>
<a name="ln595">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln596"> </a>
<a name="ln597">    TRY_EXEC(&quot;UPDATE main.images SET history_end = (SELECT IFNULL(MAX(num) + 1, 0) FROM main.history &quot;</a>
<a name="ln598">             &quot;WHERE imgid = id)&quot;, &quot;[init] can't set `history_end' to 0 where it was NULL\n&quot;);</a>
<a name="ln599"> </a>
<a name="ln600">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln601">    new_version = 10;</a>
<a name="ln602">  }</a>
<a name="ln603">  else if(version == 10)</a>
<a name="ln604">  {</a>
<a name="ln605">    // 10 -&gt; 11 added altitude column to images</a>
<a name="ln606">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln607"> </a>
<a name="ln608">    TRY_EXEC(&quot;ALTER TABLE main.images ADD COLUMN altitude REAL&quot;,</a>
<a name="ln609">             &quot;[init] can't add `altitude' column to database\n&quot;);</a>
<a name="ln610"> </a>
<a name="ln611">    TRY_EXEC(&quot;UPDATE main.images SET altitude = NULL&quot;, &quot;[init] can't initialize `altitude' with NULL\n&quot;);</a>
<a name="ln612"> </a>
<a name="ln613">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln614">    new_version = 11;</a>
<a name="ln615">  }</a>
<a name="ln616">  else if(version == 11)</a>
<a name="ln617">  {</a>
<a name="ln618">    // 11 -&gt; 12 tagxtag was removed in order to reduce database size</a>
<a name="ln619">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln620"> </a>
<a name="ln621">    TRY_EXEC(&quot;DROP TRIGGER main.detach_tag&quot;, &quot;[init] can't drop trigger `detach_tag' from database\n&quot;);</a>
<a name="ln622"> </a>
<a name="ln623">    TRY_EXEC(&quot;DROP TRIGGER main.attach_tag&quot;, &quot;[init] can't drop trigger `attach_tag' from database\n&quot;);</a>
<a name="ln624"> </a>
<a name="ln625">    TRY_EXEC(&quot;DROP TRIGGER main.delete_tag&quot;, &quot;[init] can't drop trigger `delete_tag' from database\n&quot;);</a>
<a name="ln626"> </a>
<a name="ln627">    TRY_EXEC(&quot;DROP TRIGGER main.insert_tag&quot;, &quot;[init] can't drop trigger `insert_tag' from database\n&quot;);</a>
<a name="ln628"> </a>
<a name="ln629">    TRY_EXEC(&quot;DROP TABLE main.tagxtag&quot;, &quot;[init] can't drop table `tagxtag' from database\n&quot;);</a>
<a name="ln630"> </a>
<a name="ln631">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln632">    new_version = 12;</a>
<a name="ln633">  }</a>
<a name="ln634">  else if(version == 12)</a>
<a name="ln635">  {</a>
<a name="ln636">    // 11 -&gt; 12 move presets, styles and tags over to the data database</a>
<a name="ln637">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln638"> </a>
<a name="ln639">    ////////////// presets</a>
<a name="ln640">#undef FINALIZE</a>
<a name="ln641">#define FINALIZE                                                                   \</a>
<a name="ln642">    do                                                                             \</a>
<a name="ln643">    {                                                                              \</a>
<a name="ln644">      sqlite3_finalize(stmt);                                                      \</a>
<a name="ln645">      sqlite3_finalize(select_stmt);                                               \</a>
<a name="ln646">      sqlite3_finalize(count_clashes_stmt);                                        \</a>
<a name="ln647">      sqlite3_finalize(update_name_stmt);                                          \</a>
<a name="ln648">      sqlite3_finalize(insert_stmt);                                               \</a>
<a name="ln649">      sqlite3_finalize(delete_stmt);                                               \</a>
<a name="ln650">    } while(0)</a>
<a name="ln651"> </a>
<a name="ln652">    stmt = NULL;</a>
<a name="ln653">    sqlite3_stmt *insert_stmt = NULL, *delete_stmt = NULL, *select_stmt = NULL, *count_clashes_stmt = NULL,</a>
<a name="ln654">    *update_name_stmt = NULL;</a>
<a name="ln655">    // remove presets that are already in data.</a>
<a name="ln656">    // we can't use a NATURAL JOIN here as that fails when columns have NULL values. :-(</a>
<a name="ln657">    TRY_EXEC(&quot;DELETE FROM main.presets WHERE rowid IN (SELECT p1.rowid FROM main.presets p1 &quot;</a>
<a name="ln658">             &quot;JOIN data.presets p2 ON &quot;</a>
<a name="ln659">                 &quot;p1.name IS p2.name AND &quot;</a>
<a name="ln660">                 &quot;p1.description IS p2.description AND &quot;</a>
<a name="ln661">                 &quot;p1.operation IS p2.operation AND &quot;</a>
<a name="ln662">                 &quot;p1.op_version IS p2.op_version AND &quot;</a>
<a name="ln663">                 &quot;p1.op_params IS p2.op_params AND &quot;</a>
<a name="ln664">                 &quot;p1.enabled IS p2.enabled AND &quot;</a>
<a name="ln665">                 &quot;p1.blendop_params IS p2.blendop_params AND &quot;</a>
<a name="ln666">                 &quot;p1.blendop_version IS p2.blendop_version AND &quot;</a>
<a name="ln667">                 &quot;p1.multi_priority IS p2.multi_priority AND &quot;</a>
<a name="ln668">                 &quot;p1.multi_name IS p2.multi_name AND &quot;</a>
<a name="ln669">                 &quot;p1.model IS p2.model AND &quot;</a>
<a name="ln670">                 &quot;p1.maker IS p2.maker AND &quot;</a>
<a name="ln671">                 &quot;p1.lens IS p2.lens AND &quot;</a>
<a name="ln672">                 &quot;p1.iso_min IS p2.iso_min AND &quot;</a>
<a name="ln673">                 &quot;p1.iso_max IS p2.iso_max AND &quot;</a>
<a name="ln674">                 &quot;p1.exposure_min IS p2.exposure_min AND &quot;</a>
<a name="ln675">                 &quot;p1.exposure_max IS p2.exposure_max AND &quot;</a>
<a name="ln676">                 &quot;p1.aperture_min IS p2.aperture_min AND &quot;</a>
<a name="ln677">                 &quot;p1.aperture_max IS p2.aperture_max AND &quot;</a>
<a name="ln678">                 &quot;p1.focal_length_min IS p2.focal_length_min AND &quot;</a>
<a name="ln679">                 &quot;p1.focal_length_max IS p2.focal_length_max AND &quot;</a>
<a name="ln680">                 &quot;p1.writeprotect IS p2.writeprotect AND &quot;</a>
<a name="ln681">                 &quot;p1.autoapply IS p2.autoapply AND &quot;</a>
<a name="ln682">                 &quot;p1.filter IS p2.filter AND &quot;</a>
<a name="ln683">                 &quot;p1.def IS p2.def AND &quot;</a>
<a name="ln684">                 &quot;p1.format IS p2.format &quot;</a>
<a name="ln685">             &quot;WHERE p1.writeprotect = 0)&quot;,</a>
<a name="ln686">             &quot;[init] can't delete already migrated presets from database\n&quot;);</a>
<a name="ln687"> </a>
<a name="ln688">    // find all presets that are clashing with something else in presets. that can happen as we introduced an</a>
<a name="ln689">    // index on presets in data which wasn't in place in library.</a>
<a name="ln690">    TRY_PREPARE(select_stmt, &quot;SELECT p.rowid, r FROM main.presets AS p, (SELECT rowid AS r, name, operation, &quot;</a>
<a name="ln691">                             &quot;op_version FROM main.presets GROUP BY name, operation, op_version HAVING &quot;</a>
<a name="ln692">                             &quot;COUNT(*) &gt; 1) USING (name, operation, op_version) WHERE p.rowid != r&quot;,</a>
<a name="ln693">                &quot;[init] can't prepare selecting presets with same name, operation, op_version from database\n&quot;);</a>
<a name="ln694"> </a>
<a name="ln695">    // see if an updated preset name still causes problems</a>
<a name="ln696">    TRY_PREPARE(count_clashes_stmt, &quot;SELECT COUNT(*) FROM main.presets AS p, (SELECT name, operation, op_version &quot;</a>
<a name="ln697">                                    &quot;FROM main.presets WHERE rowid = ?1) AS i ON p.name = i.name || \&quot; #\&quot; || ?2 &quot;</a>
<a name="ln698">                                    &quot;AND p.operation = i.operation AND p.op_version = i.op_version&quot;,</a>
<a name="ln699">                &quot;[init] can't prepare selection of preset count by name from database\n&quot;);</a>
<a name="ln700"> </a>
<a name="ln701">    // update the preset name for good</a>
<a name="ln702">    TRY_PREPARE(update_name_stmt, &quot;UPDATE main.presets SET name = name || \&quot; #\&quot; || ?1 WHERE rowid = ?2&quot;,</a>
<a name="ln703">                &quot;[init] can't prepare updating of preset name in database\n&quot;);</a>
<a name="ln704"> </a>
<a name="ln705">    // find all presets that would be clashing with something in data</a>
<a name="ln706">    TRY_PREPARE(stmt, &quot;SELECT p1.rowid FROM main.presets p1 INNER JOIN data.presets p2 &quot;</a>
<a name="ln707">                      &quot;USING (name, operation, op_version) WHERE p1.writeprotect = 0&quot;,</a>
<a name="ln708">                &quot;[init] can't access table `presets' in database\n&quot;);</a>
<a name="ln709"> </a>
<a name="ln710">    // ... and move them over with a new name</a>
<a name="ln711">    TRY_PREPARE(insert_stmt, &quot;INSERT OR FAIL INTO data.presets (name, description, operation, op_version, &quot;</a>
<a name="ln712">                             &quot;op_params, enabled, blendop_params, blendop_version, multi_priority, multi_name, &quot;</a>
<a name="ln713">                             &quot;model, maker, lens, iso_min, iso_max, exposure_min, exposure_max, aperture_min, &quot;</a>
<a name="ln714">                             &quot;aperture_max, focal_length_min, focal_length_max, writeprotect, autoapply, filter, &quot;</a>
<a name="ln715">                             &quot;def, format) &quot;</a>
<a name="ln716">                             &quot;SELECT name || \&quot; #\&quot; || ?1, description, operation, op_version, op_params, &quot;</a>
<a name="ln717">                             &quot;enabled, blendop_params, blendop_version, multi_priority, multi_name, model, maker, &quot;</a>
<a name="ln718">                             &quot;lens, iso_min, iso_max, exposure_min, exposure_max, aperture_min, aperture_max, &quot;</a>
<a name="ln719">                             &quot;focal_length_min, focal_length_max, writeprotect, autoapply, filter, def, format &quot;</a>
<a name="ln720">                             &quot;FROM main.presets p1 WHERE p1.rowid = ?2&quot;,</a>
<a name="ln721">                &quot;[init] can't prepare insertion statement\n&quot;);</a>
<a name="ln722"> </a>
<a name="ln723">    TRY_PREPARE(delete_stmt, &quot;DELETE FROM main.presets WHERE rowid = ?1&quot;, &quot;[init] can't prepare deletion statement\n&quot;);</a>
<a name="ln724"> </a>
<a name="ln725">    // first rename presets with (name, operation, op_version) not being unique</a>
<a name="ln726">    while(sqlite3_step(select_stmt) == SQLITE_ROW)</a>
<a name="ln727">    {</a>
<a name="ln728">      int own_rowid = sqlite3_column_int(select_stmt, 0);</a>
<a name="ln729">      int other_rowid = sqlite3_column_int(select_stmt, 1);</a>
<a name="ln730">      int preset_version = 0;</a>
<a name="ln731"> </a>
<a name="ln732">      do</a>
<a name="ln733">      {</a>
<a name="ln734">        preset_version++;</a>
<a name="ln735">        sqlite3_reset(count_clashes_stmt);</a>
<a name="ln736">        sqlite3_clear_bindings(count_clashes_stmt);</a>
<a name="ln737">        sqlite3_bind_int(count_clashes_stmt, 1, other_rowid);</a>
<a name="ln738">        sqlite3_bind_int(count_clashes_stmt, 2, preset_version);</a>
<a name="ln739">      }</a>
<a name="ln740">      while(sqlite3_step(count_clashes_stmt) == SQLITE_ROW &amp;&amp; sqlite3_column_int(count_clashes_stmt, 0) &gt; 0);</a>
<a name="ln741"> </a>
<a name="ln742">      sqlite3_bind_int(update_name_stmt, 1, preset_version);</a>
<a name="ln743">      sqlite3_bind_int(update_name_stmt, 2, own_rowid);</a>
<a name="ln744">      TRY_STEP(update_name_stmt, SQLITE_DONE, &quot;[init] can't rename preset in database\n&quot;);</a>
<a name="ln745">      sqlite3_reset(update_name_stmt);</a>
<a name="ln746">      sqlite3_reset(update_name_stmt);</a>
<a name="ln747">    }</a>
<a name="ln748"> </a>
<a name="ln749">    // now rename to avoid clashes with data.presets</a>
<a name="ln750">    while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln751">    {</a>
<a name="ln752">      int preset_version = 0;</a>
<a name="ln753">      int rowid = sqlite3_column_int(stmt, 0);</a>
<a name="ln754"> </a>
<a name="ln755">      do</a>
<a name="ln756">      {</a>
<a name="ln757">        preset_version++;</a>
<a name="ln758">        sqlite3_reset(insert_stmt);</a>
<a name="ln759">        sqlite3_clear_bindings(insert_stmt);</a>
<a name="ln760">        sqlite3_bind_int(insert_stmt, 1, preset_version);</a>
<a name="ln761">        sqlite3_bind_int(insert_stmt, 2, rowid);</a>
<a name="ln762">      } while(sqlite3_step(insert_stmt) != SQLITE_DONE);</a>
<a name="ln763"> </a>
<a name="ln764">      sqlite3_reset(delete_stmt);</a>
<a name="ln765">      sqlite3_clear_bindings(delete_stmt);</a>
<a name="ln766">      sqlite3_bind_int(delete_stmt, 1, rowid);</a>
<a name="ln767">      TRY_STEP(delete_stmt, SQLITE_DONE, &quot;[init] can't delete preset from database\n&quot;);</a>
<a name="ln768">    }</a>
<a name="ln769"> </a>
<a name="ln770">    // all that is left in presets should be those that can be moved over without any further concerns</a>
<a name="ln771">    TRY_EXEC(&quot;INSERT OR FAIL INTO data.presets SELECT name, description, operation, &quot;</a>
<a name="ln772">             &quot;op_version, op_params, enabled, blendop_params, blendop_version, &quot;</a>
<a name="ln773">             &quot;multi_priority, multi_name, model, maker, lens, iso_min, iso_max, &quot;</a>
<a name="ln774">             &quot;exposure_min, exposure_max, aperture_min, aperture_max, &quot;</a>
<a name="ln775">             &quot;focal_length_min, focal_length_max, writeprotect, autoapply, filter, &quot;</a>
<a name="ln776">             &quot;def, format FROM main.presets WHERE writeprotect = 0&quot;,</a>
<a name="ln777">             &quot;[init] can't copy presets to the data database\n&quot;);</a>
<a name="ln778">    // ... delete them on the old side</a>
<a name="ln779">    TRY_EXEC(&quot;DELETE FROM main.presets WHERE writeprotect = 0&quot;,</a>
<a name="ln780">             &quot;[init] can't copy presets to the data database\n&quot;);</a>
<a name="ln781"> </a>
<a name="ln782">    FINALIZE;</a>
<a name="ln783">#undef FINALIZE</a>
<a name="ln784"> </a>
<a name="ln785">    ////////////// styles</a>
<a name="ln786">#define FINALIZE                                                                   \</a>
<a name="ln787">    do                                                                             \</a>
<a name="ln788">    {                                                                              \</a>
<a name="ln789">      sqlite3_finalize(stmt);                                                      \</a>
<a name="ln790">      sqlite3_finalize(insert_stmt);                                               \</a>
<a name="ln791">      sqlite3_finalize(select_stmt);                                               \</a>
<a name="ln792">      sqlite3_finalize(delete_stmt);                                               \</a>
<a name="ln793">      sqlite3_finalize(update_name_stmt);                                          \</a>
<a name="ln794">      sqlite3_finalize(select_new_stmt);                                           \</a>
<a name="ln795">      sqlite3_finalize(copy_style_items_stmt);                                     \</a>
<a name="ln796">      sqlite3_finalize(delete_style_items_stmt);                                   \</a>
<a name="ln797">    } while(0)</a>
<a name="ln798"> </a>
<a name="ln799">    stmt = NULL;</a>
<a name="ln800">    select_stmt = NULL;</a>
<a name="ln801">    update_name_stmt = NULL;</a>
<a name="ln802">    insert_stmt = NULL;</a>
<a name="ln803">    delete_stmt = NULL;</a>
<a name="ln804">    sqlite3_stmt *select_new_stmt = NULL, *copy_style_items_stmt = NULL, *delete_style_items_stmt = NULL;</a>
<a name="ln805"> </a>
<a name="ln806">    TRY_PREPARE(stmt, &quot;SELECT id, name FROM main.styles&quot;, &quot;[init] can't prepare style selection from database\n&quot;);</a>
<a name="ln807">    TRY_PREPARE(select_stmt, &quot;SELECT rowid FROM data.styles WHERE name = ?1 LIMIT 1&quot;,</a>
<a name="ln808">                &quot;[init] can't prepare style item selection from database\n&quot;);</a>
<a name="ln809">    TRY_PREPARE(update_name_stmt, &quot;UPDATE main.styles SET name = ?1 WHERE id = ?2&quot;,</a>
<a name="ln810">                &quot;[init] can't prepare style name update\n&quot;);</a>
<a name="ln811">    TRY_PREPARE(insert_stmt, &quot;INSERT INTO data.styles (id, name, description) &quot;</a>
<a name="ln812">                             &quot;SELECT (SELECT COALESCE(MAX(id),0)+1 FROM data.styles), name, description &quot;</a>
<a name="ln813">                             &quot;FROM main.styles where id = ?1&quot;,</a>
<a name="ln814">                &quot;[init] can't prepare style insertion for database\n&quot;);</a>
<a name="ln815">    TRY_PREPARE(delete_stmt, &quot;DELETE FROM main.styles WHERE id = ?1&quot;,</a>
<a name="ln816">                &quot;[init] can't prepare style deletion for database\n&quot;);</a>
<a name="ln817">    TRY_PREPARE(select_new_stmt, &quot;SELECT id FROM data.styles WHERE rowid = ?1&quot;,</a>
<a name="ln818">                &quot;[init] can't prepare style selection from data database\n&quot;);</a>
<a name="ln819">    TRY_PREPARE(copy_style_items_stmt, &quot;INSERT INTO data.style_items &quot;</a>
<a name="ln820">                                       &quot;(styleid, num, module, operation, op_params, enabled, blendop_params, &quot;</a>
<a name="ln821">                                       &quot;blendop_version, multi_priority, multi_name) &quot;</a>
<a name="ln822">                                       &quot;SELECT ?1, num, module, operation, op_params, enabled, blendop_params, &quot;</a>
<a name="ln823">                                       &quot;blendop_version, multi_priority, multi_name FROM main.style_items &quot;</a>
<a name="ln824">                                       &quot;WHERE styleid = ?2&quot;,</a>
<a name="ln825">                &quot;[init] can't prepare style item copy into data database\n&quot;);</a>
<a name="ln826">    TRY_PREPARE(delete_style_items_stmt, &quot;DELETE FROM main.style_items WHERE styleid = ?1&quot;,</a>
<a name="ln827">                &quot;[init] can't prepare style item deletion for database\n&quot;);</a>
<a name="ln828"> </a>
<a name="ln829">    while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln830">    {</a>
<a name="ln831">      int id = sqlite3_column_int(stmt, 0);</a>
<a name="ln832">      const char *name = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln833"> </a>
<a name="ln834">      // find a unique name of the style for data.styles</a>
<a name="ln835">      sqlite3_bind_text(select_stmt, 1, name, -1, SQLITE_TRANSIENT);</a>
<a name="ln836">      if(sqlite3_step(select_stmt) == SQLITE_ROW)</a>
<a name="ln837">      {</a>
<a name="ln838">        // we need to append a version</a>
<a name="ln839">        int style_version = 0;</a>
<a name="ln840">        char *new_name = NULL;</a>
<a name="ln841">        do</a>
<a name="ln842">        {</a>
<a name="ln843">          style_version++;</a>
<a name="ln844">          g_free(new_name);</a>
<a name="ln845">          new_name = g_strdup_printf(&quot;%s #%d&quot;, name, style_version);</a>
<a name="ln846">          sqlite3_reset(select_stmt);</a>
<a name="ln847">          sqlite3_clear_bindings(select_stmt);</a>
<a name="ln848">          sqlite3_bind_text(select_stmt, 1, new_name, -1, SQLITE_TRANSIENT);</a>
<a name="ln849">        } while(sqlite3_step(select_stmt) == SQLITE_ROW);</a>
<a name="ln850"> </a>
<a name="ln851">        // update the name in the old place</a>
<a name="ln852">        sqlite3_bind_text(update_name_stmt, 1, new_name, -1, SQLITE_TRANSIENT);</a>
<a name="ln853">        sqlite3_bind_int(update_name_stmt, 2, id);</a>
<a name="ln854">        TRY_STEP(update_name_stmt, SQLITE_DONE, &quot;[init] can't update name of style in database\n&quot;);</a>
<a name="ln855">        sqlite3_reset(update_name_stmt);</a>
<a name="ln856">        sqlite3_clear_bindings(update_name_stmt);</a>
<a name="ln857">        g_free(new_name);</a>
<a name="ln858">      }</a>
<a name="ln859"> </a>
<a name="ln860">      // move the style to data.styles and get the rowid</a>
<a name="ln861">      sqlite3_bind_int(insert_stmt, 1, id);</a>
<a name="ln862">      TRY_STEP(insert_stmt, SQLITE_DONE, &quot;[init] can't insert style into data database\n&quot;);</a>
<a name="ln863">      sqlite3_int64 last_rowid = sqlite3_last_insert_rowid(db-&gt;handle);</a>
<a name="ln864"> </a>
<a name="ln865">      // delete style from styles</a>
<a name="ln866">      sqlite3_bind_int(delete_stmt, 1, id);</a>
<a name="ln867">      TRY_STEP(delete_stmt, SQLITE_DONE, &quot;[init] can't delete style from database\n&quot;);</a>
<a name="ln868"> </a>
<a name="ln869">      sqlite3_bind_int(select_new_stmt, 1, last_rowid);</a>
<a name="ln870">      TRY_STEP(select_new_stmt, SQLITE_ROW, &quot;[init] can't select new style from data database\n&quot;);</a>
<a name="ln871">      int new_id = sqlite3_column_int(select_new_stmt, 0);</a>
<a name="ln872"> </a>
<a name="ln873">      // now that we have the style over in data.styles and the new id we can just copy over all style items</a>
<a name="ln874">      sqlite3_bind_int(copy_style_items_stmt, 1, new_id);</a>
<a name="ln875">      sqlite3_bind_int(copy_style_items_stmt, 2, id);</a>
<a name="ln876">      TRY_STEP(copy_style_items_stmt, SQLITE_DONE, &quot;[init] can't copy style items into data database\n&quot;);</a>
<a name="ln877"> </a>
<a name="ln878">      // delete the style items from the old table</a>
<a name="ln879">      sqlite3_bind_int(delete_style_items_stmt, 1, id);</a>
<a name="ln880">      TRY_STEP(delete_style_items_stmt, SQLITE_DONE, &quot;[init] can't delete style items from database\n&quot;);</a>
<a name="ln881"> </a>
<a name="ln882">      // cleanup for the next round</a>
<a name="ln883">      sqlite3_reset(insert_stmt);</a>
<a name="ln884">      sqlite3_clear_bindings(insert_stmt);</a>
<a name="ln885">      sqlite3_reset(select_stmt);</a>
<a name="ln886">      sqlite3_clear_bindings(select_stmt);</a>
<a name="ln887">      sqlite3_reset(delete_stmt);</a>
<a name="ln888">      sqlite3_clear_bindings(delete_stmt);</a>
<a name="ln889">      sqlite3_reset(select_new_stmt);</a>
<a name="ln890">      sqlite3_clear_bindings(select_new_stmt);</a>
<a name="ln891">      sqlite3_reset(copy_style_items_stmt);</a>
<a name="ln892">      sqlite3_clear_bindings(copy_style_items_stmt);</a>
<a name="ln893">      sqlite3_reset(delete_style_items_stmt);</a>
<a name="ln894">      sqlite3_clear_bindings(delete_style_items_stmt);</a>
<a name="ln895">    }</a>
<a name="ln896">    FINALIZE;</a>
<a name="ln897">#undef FINALIZE</a>
<a name="ln898"> </a>
<a name="ln899">    ////////////// tags</a>
<a name="ln900">#define FINALIZE</a>
<a name="ln901"> </a>
<a name="ln902">    // tags</a>
<a name="ln903">    TRY_EXEC(&quot;INSERT OR IGNORE INTO data.tags (name, icon, description, flags) &quot;</a>
<a name="ln904">             &quot;SELECT name, icon, description, flags FROM main.tags&quot;,</a>
<a name="ln905">             &quot;[init] can't prepare insertion of used tags into data database\n&quot;);</a>
<a name="ln906"> </a>
<a name="ln907">    // tagged images</a>
<a name="ln908">    // we need a temp table to update tagged_images due to its primary key</a>
<a name="ln909">    TRY_EXEC(&quot;CREATE TEMPORARY TABLE tagged_images_tmp (imgid INTEGER, tagid INTEGER)&quot;,</a>
<a name="ln910">             &quot;[init] can't create temporary table for updating `tagged_images'\n&quot;);</a>
<a name="ln911"> </a>
<a name="ln912">    TRY_EXEC(&quot;INSERT INTO tagged_images_tmp (imgid, tagid) &quot;</a>
<a name="ln913">             &quot;SELECT imgid, (SELECT t2.id FROM main.tags t1, data.tags t2 USING (name) WHERE t1.id = tagid) &quot;</a>
<a name="ln914">             &quot;FROM main.tagged_images&quot;, &quot;[init] can't insert into `tagged_images_tmp'\n&quot;);</a>
<a name="ln915"> </a>
<a name="ln916">    TRY_EXEC(&quot;DELETE FROM main.tagged_images&quot;, &quot;[init] can't delete tagged images in database\n&quot;);</a>
<a name="ln917"> </a>
<a name="ln918">    TRY_EXEC(&quot;INSERT OR IGNORE INTO main.tagged_images (imgid, tagid) SELECT imgid, tagid FROM tagged_images_tmp&quot;,</a>
<a name="ln919">             &quot;[init] can't copy updated values back to `tagged_images'\n&quot;);</a>
<a name="ln920"> </a>
<a name="ln921">    TRY_EXEC(&quot;DROP TABLE tagged_images_tmp&quot;, &quot;[init] can't drop table `tagged_images_tmp' from database\n&quot;);</a>
<a name="ln922"> </a>
<a name="ln923">    ////////////// cleanup - drop the indexes and tags</a>
<a name="ln924">    TRY_EXEC(&quot;DROP INDEX IF EXISTS main.presets_idx&quot;, &quot;[init] can't drop index `presets_idx' from database\n&quot;);</a>
<a name="ln925">    TRY_EXEC(&quot;DROP TABLE main.presets&quot;, &quot;[init] can't drop table `presets' from database\n&quot;);</a>
<a name="ln926">    TRY_EXEC(&quot;DROP TABLE main.style_items&quot;, &quot;[init] can't drop table `style_items' from database\n&quot;);</a>
<a name="ln927">    TRY_EXEC(&quot;DROP TABLE main.styles&quot;, &quot;[init] can't drop table `styles' from database\n&quot;);</a>
<a name="ln928">    TRY_EXEC(&quot;DROP TABLE main.tags&quot;, &quot;[init] can't drop table `tags' from database\n&quot;);</a>
<a name="ln929"> </a>
<a name="ln930">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln931">    new_version = 13;</a>
<a name="ln932">  } else if(version == 13)</a>
<a name="ln933">  {</a>
<a name="ln934">    // 12 -&gt; 13 bring back the used tag names to library.db so people can use it independently of data.db</a>
<a name="ln935">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln936"> </a>
<a name="ln937">    TRY_EXEC(&quot;CREATE TABLE main.used_tags (id INTEGER, name VARCHAR NOT NULL)&quot;,</a>
<a name="ln938">             &quot;[init] can't create `used_tags` table\n&quot;);</a>
<a name="ln939"> </a>
<a name="ln940">    TRY_EXEC(&quot;CREATE INDEX main.used_tags_idx ON used_tags (id, name)&quot;,</a>
<a name="ln941">             &quot;[init] can't create index on table `used_tags' in database\n&quot;);</a>
<a name="ln942"> </a>
<a name="ln943">    TRY_EXEC(&quot;INSERT INTO main.used_tags (id, name) SELECT t.id, t.name FROM data.tags AS t, main.tagged_images &quot;</a>
<a name="ln944">             &quot;AS i ON t.id = i.tagid GROUP BY t.id&quot;,</a>
<a name="ln945">             &quot;[init] can't insert used tags into `used_tags` table in database\n&quot;);</a>
<a name="ln946"> </a>
<a name="ln947">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln948">    new_version = 14;</a>
<a name="ln949">  }</a>
<a name="ln950">  else if(version == 14)</a>
<a name="ln951">  {</a>
<a name="ln952">    // 13 -&gt; fix the index on used_tags to be a UNIQUE index :-/</a>
<a name="ln953">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln954"> </a>
<a name="ln955">    TRY_EXEC(&quot;DELETE FROM main.used_tags WHERE rowid NOT IN (SELECT rowid FROM used_tags GROUP BY id)&quot;,</a>
<a name="ln956">             &quot;[init] can't delete duplicated entries from `used_tags' in database\n&quot;);</a>
<a name="ln957"> </a>
<a name="ln958">    TRY_EXEC(&quot;DROP INDEX main.used_tags_idx&quot;, &quot;[init] can't drop index `used_tags_idx' from database\n&quot;);</a>
<a name="ln959"> </a>
<a name="ln960">    TRY_EXEC(&quot;CREATE UNIQUE INDEX main.used_tags_idx ON used_tags (id, name)&quot;,</a>
<a name="ln961">             &quot;[init] can't create index `used_tags_idx' in database\n&quot;);</a>
<a name="ln962"> </a>
<a name="ln963">    TRY_EXEC(&quot;DELETE FROM main.tagged_images WHERE tagid IS NULL&quot;,</a>
<a name="ln964">             &quot;[init] can't delete NULL entries from `tagged_images' in database&quot;);</a>
<a name="ln965"> </a>
<a name="ln966">    TRY_EXEC(&quot;DELETE FROM main.used_tags WHERE id NOT IN (SELECT DISTINCT tagid FROM main.tagged_images)&quot;,</a>
<a name="ln967">             &quot;[init] can't delete unused tags from `used_tags' in database\n&quot;);</a>
<a name="ln968"> </a>
<a name="ln969">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln970">    new_version = 15;</a>
<a name="ln971">  }</a>
<a name="ln972">  else if(version == 15)</a>
<a name="ln973">  {</a>
<a name="ln974">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln975">    ////////////////////////////// custom image order</a>
<a name="ln976">    TRY_EXEC(&quot;ALTER TABLE main.images ADD COLUMN position INTEGER&quot;,</a>
<a name="ln977">             &quot;[init] can't add `position' column to images table in database\n&quot;);</a>
<a name="ln978">    TRY_EXEC(&quot;CREATE INDEX main.image_position_index ON images (position)&quot;,</a>
<a name="ln979">             &quot;[init] can't create index for custom image order table\n&quot;);</a>
<a name="ln980"> </a>
<a name="ln981">    // Set the initial image sequence. The image id - the sequece images were imported -</a>
<a name="ln982">    // defines the initial order of images.</a>
<a name="ln983">    //</a>
<a name="ln984">    // An int64 is used for the position index. The upper 31 bits define the initial order.</a>
<a name="ln985">    // The lower 32bit provide space to reorder images.</a>
<a name="ln986">    //</a>
<a name="ln987">    // see: dt_collection_move_before()</a>
<a name="ln988">    //</a>
<a name="ln989">    TRY_EXEC(&quot;UPDATE main.images SET position = id &lt;&lt; 32&quot;,</a>
<a name="ln990">             &quot;[init] can't update positions custom image order table\n&quot;);</a>
<a name="ln991"> </a>
<a name="ln992">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln993">    new_version = 16;</a>
<a name="ln994">  }</a>
<a name="ln995">  else if(version == 16)</a>
<a name="ln996">  {</a>
<a name="ln997">    sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln998">    ////////////////////////////// final image aspect ratio</a>
<a name="ln999">    TRY_EXEC(&quot;ALTER TABLE main.images ADD COLUMN aspect_ratio REAL&quot;,</a>
<a name="ln1000">             &quot;[init] can't add `aspect_ratio' column to images table in database\n&quot;);</a>
<a name="ln1001">    TRY_EXEC(&quot;UPDATE main.images SET aspect_ratio = 0.0&quot;,</a>
<a name="ln1002">             &quot;[init] can't update aspect_ratio in database\n&quot;);</a>
<a name="ln1003"> </a>
<a name="ln1004">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln1005">    new_version = 17;</a>
<a name="ln1006">  }</a>
<a name="ln1007">  else if(version == 17)</a>
<a name="ln1008">  {</a>
<a name="ln1009">    ////////////////////////////// masks history</a>
<a name="ln1010">    TRY_EXEC(&quot;CREATE TABLE main.masks_history (imgid INTEGER, num INTEGER, formid INTEGER, form INTEGER, name VARCHAR(256), &quot;</a>
<a name="ln1011">             &quot;version INTEGER, points BLOB, points_count INTEGER, source BLOB)&quot;,</a>
<a name="ln1012">             &quot;[init] can't create `masks_history` table\n&quot;);</a>
<a name="ln1013"> </a>
<a name="ln1014">    TRY_EXEC(&quot;CREATE INDEX main.masks_history_imgid_index ON masks_history (imgid)&quot;,</a>
<a name="ln1015">             &quot;[init] can't create index `masks_history_imgid_index' in database\n&quot;);</a>
<a name="ln1016"> </a>
<a name="ln1017">    // to speed up the mask look-up, and makes the following UPDATE instantaneous whereas it could takes hours</a>
<a name="ln1018">    TRY_EXEC(&quot;CREATE INDEX main.mask_imgid_index ON mask (imgid);&quot;,</a>
<a name="ln1019">             &quot;[init] can't create index `mask_imgid_index' in database\n&quot;);</a>
<a name="ln1020"> </a>
<a name="ln1021">    // create a mask manager entry on history for all images containing all forms</a>
<a name="ln1022">    // make room for mask manager history entry</a>
<a name="ln1023">    TRY_EXEC(&quot;UPDATE main.history SET num=num+1 WHERE imgid IN (SELECT imgid FROM main.mask WHERE main.mask.imgid=main.history.imgid)&quot;,</a>
<a name="ln1024">             &quot;[init] can't update `num' with num+1\n&quot;);</a>
<a name="ln1025"> </a>
<a name="ln1026">    // update history end</a>
<a name="ln1027">    TRY_EXEC(&quot;UPDATE main.images SET history_end = history_end+1 WHERE id IN (SELECT imgid FROM main.mask WHERE main.mask.imgid=main.images.id)&quot;,</a>
<a name="ln1028">             &quot;[init] can't update `history_end' with history_end+1\n&quot;);</a>
<a name="ln1029"> </a>
<a name="ln1030">    // copy all masks into history</a>
<a name="ln1031">    TRY_EXEC(&quot;INSERT INTO main.masks_history (imgid, num, formid, form, name, version, points, points_count, source) SELECT &quot;</a>
<a name="ln1032">             &quot;imgid, 0, formid, form, name, version, points, points_count, source FROM main.mask&quot;,</a>
<a name="ln1033">             &quot;[init] can't insert into masks_history\n&quot;);</a>
<a name="ln1034"> </a>
<a name="ln1035">    // create a mask manager entry for each image that has maks</a>
<a name="ln1036">    TRY_EXEC(&quot;INSERT INTO main.history (imgid, num, operation, op_params, module, enabled, &quot;</a>
<a name="ln1037">             &quot;blendop_params, blendop_version, multi_priority, multi_name) &quot;</a>
<a name="ln1038">             &quot;SELECT DISTINCT imgid, 0, 'mask_manager', NULL, 1, 0, NULL, 0, 0, '' FROM main.mask &quot;</a>
<a name="ln1039">             &quot;GROUP BY imgid&quot;,</a>
<a name="ln1040">             &quot;[init] can't insert mask manager into history\n&quot;);</a>
<a name="ln1041"> </a>
<a name="ln1042">    TRY_EXEC(&quot;DROP TABLE main.mask&quot;, &quot;[init] can't drop table `mask' from database\n&quot;);</a>
<a name="ln1043"> </a>
<a name="ln1044">    ////////////////////////////// custom iop order</a>
<a name="ln1045">    int iop_order_version = 1;</a>
<a name="ln1046">    GList *prior_v1 = dt_ioppr_get_iop_order_list(&amp;iop_order_version);</a>
<a name="ln1047"> </a>
<a name="ln1048">    TRY_EXEC(&quot;ALTER TABLE main.images ADD COLUMN iop_order_version INTEGER&quot;,</a>
<a name="ln1049">             &quot;[init] can't add `iop_order_version' column to images table in database\n&quot;);</a>
<a name="ln1050"> </a>
<a name="ln1051">    TRY_EXEC(&quot;UPDATE main.images SET iop_order_version = 0&quot;,</a>
<a name="ln1052">             &quot;[init] can't update iop_order_version in database\n&quot;);</a>
<a name="ln1053"> </a>
<a name="ln1054">    TRY_EXEC(&quot;UPDATE main.images SET iop_order_version = 1 WHERE &quot;</a>
<a name="ln1055">             &quot;EXISTS(SELECT * FROM main.history WHERE main.history.imgid = main.images.id)&quot;,</a>
<a name="ln1056">             &quot;[init] can't update iop_order_version in database\n&quot;);</a>
<a name="ln1057"> </a>
<a name="ln1058">    TRY_EXEC(&quot;ALTER TABLE main.history ADD COLUMN iop_order REAL&quot;,</a>
<a name="ln1059">             &quot;[init] can't add `iop_order' column to history table in database\n&quot;);</a>
<a name="ln1060"> </a>
<a name="ln1061">    // create a temp table with the previous priorities</a>
<a name="ln1062">    TRY_EXEC(&quot;CREATE TEMPORARY TABLE iop_order_tmp (iop_order REAL, operation VARCHAR(256))&quot;,</a>
<a name="ln1063">             &quot;[init] can't create temporary table for updating `main.history'\n&quot;);</a>
<a name="ln1064"> </a>
<a name="ln1065">    // fill temp table with all operations up to this release</a>
<a name="ln1066">    // it will be used to create the pipe and update the iop_order on history</a>
<a name="ln1067">    GList *priorities = g_list_first(prior_v1);</a>
<a name="ln1068">    while(priorities)</a>
<a name="ln1069">    {</a>
<a name="ln1070">      dt_iop_order_entry_t *prior = (dt_iop_order_entry_t *)priorities-&gt;data;</a>
<a name="ln1071"> </a>
<a name="ln1072">      sqlite3_prepare_v2(</a>
<a name="ln1073">          db-&gt;handle,</a>
<a name="ln1074">          &quot;INSERT INTO iop_order_tmp (iop_order, operation) VALUES (?1, ?2)&quot;,</a>
<a name="ln1075">          -1, &amp;stmt, NULL);</a>
<a name="ln1076">      sqlite3_bind_double(stmt, 1, prior-&gt;iop_order);</a>
<a name="ln1077">      sqlite3_bind_text(stmt, 2, prior-&gt;operation, -1, SQLITE_TRANSIENT);</a>
<a name="ln1078">      TRY_STEP(stmt, SQLITE_DONE, &quot;[init] can't insert default value in iop_order_tmp\n&quot;);</a>
<a name="ln1079">      sqlite3_finalize(stmt);</a>
<a name="ln1080"> </a>
<a name="ln1081">      priorities = g_list_next(priorities);</a>
<a name="ln1082">    }</a>
<a name="ln1083">    g_list_free_full(prior_v1, free);</a>
<a name="ln1084"> </a>
<a name="ln1085">    // create the order of the pipe</a>
<a name="ln1086">    // iop_order is by default the module priority</a>
<a name="ln1087">    // if there's multi-instances we add the multi_priority</a>
<a name="ln1088">    // multi_priority is in reverse order in this version,</a>
<a name="ln1089">    // so we assume that is always less than 1000 and reverse it</a>
<a name="ln1090">    // it is possible that multi_priority = 0 don't appear in history</a>
<a name="ln1091">    // so just in case 1 / 1000 to every instance</a>
<a name="ln1092">    TRY_EXEC(&quot;UPDATE main.history SET iop_order = (((&quot;</a>
<a name="ln1093">        &quot;SELECT MAX(multi_priority) FROM main.history hist1 WHERE hist1.imgid = main.history.imgid AND hist1.operation = main.history.operation &quot;</a>
<a name="ln1094">             &quot;) + 1. - multi_priority) / 1000.) + &quot;</a>
<a name="ln1095">             &quot;IFNULL((SELECT iop_order FROM iop_order_tmp WHERE iop_order_tmp.operation = &quot;</a>
<a name="ln1096">             &quot;main.history.operation), -999999.) &quot;,</a>
<a name="ln1097">             &quot;[init] can't update iop_order in history table\n&quot;);</a>
<a name="ln1098"> </a>
<a name="ln1099">    // check if there's any entry in history that was not updated</a>
<a name="ln1100">    sqlite3_stmt *sel_stmt;</a>
<a name="ln1101">    TRY_PREPARE(sel_stmt, &quot;SELECT DISTINCT operation FROM main.history WHERE iop_order &lt;= 0&quot;,</a>
<a name="ln1102">                &quot;[init] can't prepare selecting history iop_order\n&quot;);</a>
<a name="ln1103">    while(sqlite3_step(sel_stmt) == SQLITE_ROW)</a>
<a name="ln1104">    {</a>
<a name="ln1105">      const char *op_name = (const char *)sqlite3_column_text(sel_stmt, 0);</a>
<a name="ln1106">      printf(&quot;operation %s with no iop_order while upgrading database\n&quot;, op_name);</a>
<a name="ln1107">    }</a>
<a name="ln1108">    sqlite3_finalize(sel_stmt);</a>
<a name="ln1109"> </a>
<a name="ln1110">    // style_items</a>
<a name="ln1111">    TRY_EXEC(&quot;ALTER TABLE data.style_items ADD COLUMN iop_order REAL&quot;,</a>
<a name="ln1112">             &quot;[init] can't add `iop_order' column to style_items table in database\n&quot;);</a>
<a name="ln1113"> </a>
<a name="ln1114">    // do the same as for history</a>
<a name="ln1115">    TRY_EXEC(&quot;UPDATE data.style_items SET iop_order = (((&quot;</a>
<a name="ln1116">        &quot;SELECT MAX(multi_priority) FROM data.style_items style1 WHERE style1.styleid = data.style_items.styleid AND style1.operation = data.style_items.operation &quot;</a>
<a name="ln1117">             &quot;) + 1. - multi_priority) / 1000.) + &quot;</a>
<a name="ln1118">             &quot;IFNULL((SELECT iop_order FROM iop_order_tmp WHERE iop_order_tmp.operation = &quot;</a>
<a name="ln1119">             &quot;data.style_items.operation), -999999.) &quot;,</a>
<a name="ln1120">             &quot;[init] can't update iop_order in style_items table\n&quot;);</a>
<a name="ln1121"> </a>
<a name="ln1122">    TRY_PREPARE(sel_stmt, &quot;SELECT DISTINCT operation FROM data.style_items WHERE iop_order &lt;= 0&quot;,</a>
<a name="ln1123">                &quot;[init] can't prepare selecting style_items iop_order\n&quot;);</a>
<a name="ln1124">    while(sqlite3_step(sel_stmt) == SQLITE_ROW)</a>
<a name="ln1125">    {</a>
<a name="ln1126">      const char *op_name = (const char *)sqlite3_column_text(sel_stmt, 0);</a>
<a name="ln1127">      printf(&quot;operation %s with no iop_order while upgrading style_items in database\n&quot;, op_name);</a>
<a name="ln1128">    }</a>
<a name="ln1129">    sqlite3_finalize(sel_stmt);</a>
<a name="ln1130"> </a>
<a name="ln1131">    TRY_EXEC(&quot;DROP TABLE iop_order_tmp&quot;, &quot;[init] can't drop table `iop_order_tmp' from database\n&quot;);</a>
<a name="ln1132"> </a>
<a name="ln1133">    sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln1134">    new_version = 18;</a>
<a name="ln1135">  }</a>
<a name="ln1136">  // maybe in the future, see commented out code elsewhere</a>
<a name="ln1137">  //   else if(version == XXX)</a>
<a name="ln1138">  //   {</a>
<a name="ln1139">  //     sqlite3_exec(db-&gt;handle, &quot;ALTER TABLE film_rolls ADD COLUMN external_drive VARCHAR(1024)&quot;, NULL,</a>
<a name="ln1140">  //     NULL, NULL);</a>
<a name="ln1141">  //   }</a>
<a name="ln1142">  else</a>
<a name="ln1143">    new_version = version; // should be the fallback so that calling code sees that we are in an infinite loop</a>
<a name="ln1144"> </a>
<a name="ln1145">  // write the new version to db</a>
<a name="ln1146">  sqlite3_prepare_v2(db-&gt;handle, &quot;INSERT OR REPLACE INTO main.db_info (key, value) VALUES ('version', ?1)&quot;, -1, &amp;stmt,</a>
<a name="ln1147">                     NULL);</a>
<a name="ln1148">  sqlite3_bind_int(stmt, 1, new_version);</a>
<a name="ln1149">  sqlite3_step(stmt);</a>
<a name="ln1150">  sqlite3_finalize(stmt);</a>
<a name="ln1151"> </a>
<a name="ln1152">  return new_version;</a>
<a name="ln1153">}</a>
<a name="ln1154"> </a>
<a name="ln1155">#undef FINALIZE</a>
<a name="ln1156"> </a>
<a name="ln1157">#undef TRY_EXEC</a>
<a name="ln1158">#undef TRY_STEP</a>
<a name="ln1159">#undef TRY_PREPARE</a>
<a name="ln1160"> </a>
<a name="ln1161">/* do the real migration steps, returns the version the db was converted to */</a>
<a name="ln1162">static int _upgrade_data_schema_step(dt_database_t *db, int version)</a>
<a name="ln1163">{</a>
<a name="ln1164">  sqlite3_stmt *stmt;</a>
<a name="ln1165">  int new_version = version;</a>
<a name="ln1166">  if(version == CURRENT_DATABASE_VERSION_DATA)</a>
<a name="ln1167">    return version;</a>
<a name="ln1168">  else if(version == 0)</a>
<a name="ln1169">  {</a>
<a name="ln1170">    // this can't happen, we started with 1, but it's a good example how this function works</a>
<a name="ln1171">    // &lt;do some magic to the db&gt;</a>
<a name="ln1172">    new_version = 1; // the version we transformed the db to. this way it might be possible to roll back or</a>
<a name="ln1173">    // add fast paths</a>
<a name="ln1174">  }</a>
<a name="ln1175">  else</a>
<a name="ln1176">    new_version = version; // should be the fallback so that calling code sees that we are in an infinite loop</a>
<a name="ln1177"> </a>
<a name="ln1178">  // write the new version to db</a>
<a name="ln1179">  sqlite3_prepare_v2(db-&gt;handle, &quot;INSERT OR REPLACE INTO data.db_info (key, value) VALUES ('version', ?1)&quot;, -1, &amp;stmt,</a>
<a name="ln1180">                     NULL);</a>
<a name="ln1181">  sqlite3_bind_int(stmt, 1, new_version);</a>
<a name="ln1182">  sqlite3_step(stmt);</a>
<a name="ln1183">  sqlite3_finalize(stmt);</a>
<a name="ln1184"> </a>
<a name="ln1185">  return new_version;</a>
<a name="ln1186">}</a>
<a name="ln1187"> </a>
<a name="ln1188">/* upgrade library db from 'version' to CURRENT_DATABASE_VERSION_LIBRARY. don't touch this function but</a>
<a name="ln1189"> * _upgrade_library_schema_step() instead. */</a>
<a name="ln1190">static gboolean _upgrade_library_schema(dt_database_t *db, int version)</a>
<a name="ln1191">{</a>
<a name="ln1192">  while(version &lt; CURRENT_DATABASE_VERSION_LIBRARY)</a>
<a name="ln1193">  {</a>
<a name="ln1194">    int new_version = _upgrade_library_schema_step(db, version);</a>
<a name="ln1195">    if(new_version == version)</a>
<a name="ln1196">      return FALSE; // we don't know how to upgrade this db. probably a bug in _upgrade_library_schema_step</a>
<a name="ln1197">    else</a>
<a name="ln1198">      version = new_version;</a>
<a name="ln1199">  }</a>
<a name="ln1200">  return TRUE;</a>
<a name="ln1201">}</a>
<a name="ln1202"> </a>
<a name="ln1203">/* upgrade data db from 'version' to CURRENT_DATABASE_VERSION_DATA. don't touch this function but</a>
<a name="ln1204"> * _upgrade_data_schema_step() instead. */</a>
<a name="ln1205">static gboolean _upgrade_data_schema(dt_database_t *db, int version)</a>
<a name="ln1206">{</a>
<a name="ln1207">  while(version &lt; CURRENT_DATABASE_VERSION_DATA)</a>
<a name="ln1208">  {</a>
<a name="ln1209">    int new_version = _upgrade_data_schema_step(db, version);</a>
<a name="ln1210">    if(new_version == version)</a>
<a name="ln1211">      return FALSE; // we don't know how to upgrade this db. probably a bug in _upgrade_data_schema_step</a>
<a name="ln1212">    else</a>
<a name="ln1213">      version = new_version;</a>
<a name="ln1214">  }</a>
<a name="ln1215">  return TRUE;</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">/* create the current database schema and set the version in db_info accordingly */</a>
<a name="ln1219">static void _create_library_schema(dt_database_t *db)</a>
<a name="ln1220">{</a>
<a name="ln1221">  sqlite3_stmt *stmt;</a>
<a name="ln1222">  ////////////////////////////// db_info</a>
<a name="ln1223">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE main.db_info (key VARCHAR PRIMARY KEY, value VARCHAR)&quot;, NULL,</a>
<a name="ln1224">               NULL, NULL);</a>
<a name="ln1225">  sqlite3_prepare_v2(</a>
<a name="ln1226">      db-&gt;handle, &quot;INSERT OR REPLACE INTO main.db_info (key, value) VALUES ('version', ?1)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1227">  sqlite3_bind_int(stmt, 1, CURRENT_DATABASE_VERSION_LIBRARY);</a>
<a name="ln1228">  sqlite3_step(stmt);</a>
<a name="ln1229">  sqlite3_finalize(stmt);</a>
<a name="ln1230">  ////////////////////////////// film_rolls</a>
<a name="ln1231">  sqlite3_exec(db-&gt;handle,</a>
<a name="ln1232">               &quot;CREATE TABLE main.film_rolls &quot;</a>
<a name="ln1233">               &quot;(id INTEGER PRIMARY KEY, datetime_accessed CHAR(20), &quot;</a>
<a name="ln1234">               //                        &quot;folder VARCHAR(1024), external_drive VARCHAR(1024))&quot;, //</a>
<a name="ln1235">               //                        FIXME: make sure to bump CURRENT_DATABASE_VERSION_LIBRARY and add a</a>
<a name="ln1236">               //                        case to _upgrade_library_schema_step when adding this!</a>
<a name="ln1237">               &quot;folder VARCHAR(1024) NOT NULL)&quot;,</a>
<a name="ln1238">               NULL, NULL, NULL);</a>
<a name="ln1239">  sqlite3_exec(db-&gt;handle, &quot;CREATE INDEX main.film_rolls_folder_index ON film_rolls (folder)&quot;, NULL, NULL, NULL);</a>
<a name="ln1240">  ////////////////////////////// images</a>
<a name="ln1241">  sqlite3_exec(</a>
<a name="ln1242">      db-&gt;handle,</a>
<a name="ln1243">      &quot;CREATE TABLE main.images (id INTEGER PRIMARY KEY AUTOINCREMENT, group_id INTEGER, film_id INTEGER, &quot;</a>
<a name="ln1244">      &quot;width INTEGER, height INTEGER, filename VARCHAR, maker VARCHAR, model VARCHAR, &quot;</a>
<a name="ln1245">      &quot;lens VARCHAR, exposure REAL, aperture REAL, iso REAL, focal_length REAL, &quot;</a>
<a name="ln1246">      &quot;focus_distance REAL, datetime_taken CHAR(20), flags INTEGER, &quot;</a>
<a name="ln1247">      &quot;output_width INTEGER, output_height INTEGER, crop REAL, &quot;</a>
<a name="ln1248">      &quot;raw_parameters INTEGER, raw_denoise_threshold REAL, &quot;</a>
<a name="ln1249">      &quot;raw_auto_bright_threshold REAL, raw_black INTEGER, raw_maximum INTEGER, &quot;</a>
<a name="ln1250">      &quot;caption VARCHAR, description VARCHAR, license VARCHAR, sha1sum CHAR(40), &quot;</a>
<a name="ln1251">      &quot;orientation INTEGER, histogram BLOB, lightmap BLOB, longitude REAL, &quot;</a>
<a name="ln1252">      &quot;latitude REAL, altitude REAL, color_matrix BLOB, colorspace INTEGER, version INTEGER, &quot;</a>
<a name="ln1253">      &quot;max_version INTEGER, write_timestamp INTEGER, history_end INTEGER, position INTEGER, aspect_ratio REAL, iop_order_version INTEGER)&quot;,</a>
<a name="ln1254">      NULL, NULL, NULL);</a>
<a name="ln1255">  sqlite3_exec(db-&gt;handle, &quot;CREATE INDEX main.images_group_id_index ON images (group_id)&quot;, NULL, NULL, NULL);</a>
<a name="ln1256">  sqlite3_exec(db-&gt;handle, &quot;CREATE INDEX main.images_film_id_index ON images (film_id)&quot;, NULL, NULL, NULL);</a>
<a name="ln1257">  sqlite3_exec(db-&gt;handle, &quot;CREATE INDEX main.images_filename_index ON images (filename)&quot;, NULL, NULL, NULL);</a>
<a name="ln1258">  sqlite3_exec(db-&gt;handle, &quot;CREATE INDEX main.image_position_index ON images (position)&quot;, NULL, NULL, NULL);</a>
<a name="ln1259"> </a>
<a name="ln1260">  ////////////////////////////// selected_images</a>
<a name="ln1261">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE main.selected_images (imgid INTEGER PRIMARY KEY)&quot;, NULL, NULL, NULL);</a>
<a name="ln1262">  ////////////////////////////// history</a>
<a name="ln1263">  sqlite3_exec(</a>
<a name="ln1264">      db-&gt;handle,</a>
<a name="ln1265">      &quot;CREATE TABLE main.history (imgid INTEGER, num INTEGER, module INTEGER, &quot;</a>
<a name="ln1266">      &quot;operation VARCHAR(256), op_params BLOB, enabled INTEGER, &quot;</a>
<a name="ln1267">      &quot;blendop_params BLOB, blendop_version INTEGER, multi_priority INTEGER, multi_name VARCHAR(256), iop_order REAL)&quot;,</a>
<a name="ln1268">      NULL, NULL, NULL);</a>
<a name="ln1269">  sqlite3_exec(db-&gt;handle, &quot;CREATE INDEX main.history_imgid_index ON history (imgid)&quot;, NULL, NULL, NULL);</a>
<a name="ln1270">  ////////////////////////////// masks history</a>
<a name="ln1271">  sqlite3_exec(db-&gt;handle,</a>
<a name="ln1272">               &quot;CREATE TABLE main.masks_history (imgid INTEGER, num INTEGER, formid INTEGER, form INTEGER, name VARCHAR(256), &quot;</a>
<a name="ln1273">               &quot;version INTEGER, points BLOB, points_count INTEGER, source BLOB)&quot;,</a>
<a name="ln1274">               NULL, NULL, NULL);</a>
<a name="ln1275"> </a>
<a name="ln1276">  sqlite3_exec(db-&gt;handle,</a>
<a name="ln1277">      &quot;CREATE INDEX main.masks_history_imgid_index ON masks_history (imgid)&quot;,</a>
<a name="ln1278">      NULL, NULL, NULL);</a>
<a name="ln1279"> </a>
<a name="ln1280"> </a>
<a name="ln1281">  ////////////////////////////// tagged_images</a>
<a name="ln1282">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE main.tagged_images (imgid INTEGER, tagid INTEGER, &quot;</a>
<a name="ln1283">                           &quot;PRIMARY KEY (imgid, tagid))&quot;, NULL, NULL, NULL);</a>
<a name="ln1284">  sqlite3_exec(db-&gt;handle, &quot;CREATE INDEX main.tagged_images_tagid_index ON tagged_images (tagid)&quot;, NULL, NULL, NULL);</a>
<a name="ln1285">  ////////////////////////////// used_tags</a>
<a name="ln1286">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE main.used_tags (id INTEGER, name VARCHAR NOT NULL)&quot;, NULL, NULL, NULL);</a>
<a name="ln1287">  sqlite3_exec(db-&gt;handle, &quot;CREATE UNIQUE INDEX main.used_tags_idx ON used_tags (id, name)&quot;, NULL, NULL, NULL);</a>
<a name="ln1288">  ////////////////////////////// color_labels</a>
<a name="ln1289">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE main.color_labels (imgid INTEGER, color INTEGER)&quot;, NULL, NULL, NULL);</a>
<a name="ln1290">  sqlite3_exec(db-&gt;handle, &quot;CREATE UNIQUE INDEX main.color_labels_idx ON color_labels (imgid, color)&quot;, NULL, NULL,</a>
<a name="ln1291">               NULL);</a>
<a name="ln1292">  ////////////////////////////// meta_data</a>
<a name="ln1293">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE main.meta_data (id INTEGER, key INTEGER, value VARCHAR)&quot;, NULL, NULL, NULL);</a>
<a name="ln1294">  sqlite3_exec(db-&gt;handle, &quot;CREATE INDEX main.metadata_index ON meta_data (id, key)&quot;, NULL, NULL, NULL);</a>
<a name="ln1295">}</a>
<a name="ln1296"> </a>
<a name="ln1297">/* create the current database schema and set the version in db_info accordingly */</a>
<a name="ln1298">static void _create_data_schema(dt_database_t *db)</a>
<a name="ln1299">{</a>
<a name="ln1300">  sqlite3_stmt *stmt;</a>
<a name="ln1301">  ////////////////////////////// db_info</a>
<a name="ln1302">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE data.db_info (key VARCHAR PRIMARY KEY, value VARCHAR)&quot;, NULL,</a>
<a name="ln1303">               NULL, NULL);</a>
<a name="ln1304">  sqlite3_prepare_v2(</a>
<a name="ln1305">        db-&gt;handle, &quot;INSERT OR REPLACE INTO data.db_info (key, value) VALUES ('version', ?1)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1306">  sqlite3_bind_int(stmt, 1, CURRENT_DATABASE_VERSION_DATA);</a>
<a name="ln1307">  sqlite3_step(stmt);</a>
<a name="ln1308">  sqlite3_finalize(stmt);</a>
<a name="ln1309">  ////////////////////////////// tags</a>
<a name="ln1310">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE data.tags (id INTEGER PRIMARY KEY, name VARCHAR, icon BLOB, &quot;</a>
<a name="ln1311">                           &quot;description VARCHAR, flags INTEGER)&quot;, NULL, NULL, NULL);</a>
<a name="ln1312">  sqlite3_exec(db-&gt;handle, &quot;CREATE UNIQUE INDEX data.tags_name_idx ON tags (name)&quot;, NULL, NULL, NULL);</a>
<a name="ln1313">  ////////////////////////////// styles</a>
<a name="ln1314">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE data.styles (id INTEGER, name VARCHAR, description VARCHAR)&quot;,</a>
<a name="ln1315">                        NULL, NULL, NULL);</a>
<a name="ln1316">  ////////////////////////////// style_items</a>
<a name="ln1317">  sqlite3_exec(</a>
<a name="ln1318">      db-&gt;handle,</a>
<a name="ln1319">      &quot;CREATE TABLE data.style_items (styleid INTEGER, num INTEGER, module INTEGER, &quot;</a>
<a name="ln1320">      &quot;operation VARCHAR(256), op_params BLOB, enabled INTEGER, &quot;</a>
<a name="ln1321">      &quot;blendop_params BLOB, blendop_version INTEGER, multi_priority INTEGER, multi_name VARCHAR(256), iop_order REAL)&quot;,</a>
<a name="ln1322">      NULL, NULL, NULL);</a>
<a name="ln1323">  ////////////////////////////// presets</a>
<a name="ln1324">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE data.presets (name VARCHAR, description VARCHAR, operation &quot;</a>
<a name="ln1325">                           &quot;VARCHAR, op_version INTEGER, op_params BLOB, &quot;</a>
<a name="ln1326">                           &quot;enabled INTEGER, blendop_params BLOB, blendop_version INTEGER, &quot;</a>
<a name="ln1327">                           &quot;multi_priority INTEGER, multi_name VARCHAR(256), &quot;</a>
<a name="ln1328">                           &quot;model VARCHAR, maker VARCHAR, lens VARCHAR, iso_min REAL, iso_max REAL, &quot;</a>
<a name="ln1329">                           &quot;exposure_min REAL, exposure_max REAL, &quot;</a>
<a name="ln1330">                           &quot;aperture_min REAL, aperture_max REAL, focal_length_min REAL, &quot;</a>
<a name="ln1331">                           &quot;focal_length_max REAL, writeprotect INTEGER, &quot;</a>
<a name="ln1332">                           &quot;autoapply INTEGER, filter INTEGER, def INTEGER, format INTEGER)&quot;,</a>
<a name="ln1333">               NULL, NULL, NULL);</a>
<a name="ln1334">  sqlite3_exec(db-&gt;handle, &quot;CREATE UNIQUE INDEX data.presets_idx ON presets (name, operation, op_version)&quot;,</a>
<a name="ln1335">               NULL, NULL, NULL);</a>
<a name="ln1336">}</a>
<a name="ln1337"> </a>
<a name="ln1338">// create the in-memory tables</a>
<a name="ln1339">// temporary stuff for some ops, need this for some reason with newer sqlite3:</a>
<a name="ln1340">static void _create_memory_schema(dt_database_t *db)</a>
<a name="ln1341">{</a>
<a name="ln1342">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE memory.color_labels_temp (imgid INTEGER PRIMARY KEY)&quot;, NULL, NULL, NULL);</a>
<a name="ln1343">  sqlite3_exec(</a>
<a name="ln1344">      db-&gt;handle,</a>
<a name="ln1345">      &quot;CREATE TABLE memory.collected_images (rowid INTEGER PRIMARY KEY AUTOINCREMENT, imgid INTEGER)&quot;, NULL,</a>
<a name="ln1346">      NULL, NULL);</a>
<a name="ln1347">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE memory.tmp_selection (imgid INTEGER)&quot;, NULL, NULL, NULL);</a>
<a name="ln1348">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE memory.tagq (tmpid INTEGER PRIMARY KEY, id INTEGER)&quot;, NULL, NULL, NULL);</a>
<a name="ln1349">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE memory.taglist &quot;</a>
<a name="ln1350">                           &quot;(tmpid INTEGER PRIMARY KEY, id INTEGER UNIQUE ON CONFLICT IGNORE, count INTEGER)&quot;,</a>
<a name="ln1351">               NULL, NULL, NULL);</a>
<a name="ln1352">  sqlite3_exec(db-&gt;handle, &quot;CREATE TABLE memory.similar_tags (tagid INTEGER)&quot;, NULL, NULL, NULL);</a>
<a name="ln1353">  sqlite3_exec(</a>
<a name="ln1354">      db-&gt;handle,</a>
<a name="ln1355">      &quot;CREATE TABLE memory.history (imgid INTEGER, num INTEGER, module INTEGER, &quot;</a>
<a name="ln1356">      &quot;operation VARCHAR(256) UNIQUE ON CONFLICT REPLACE, op_params BLOB, enabled INTEGER, &quot;</a>
<a name="ln1357">      &quot;blendop_params BLOB, blendop_version INTEGER, multi_priority INTEGER, multi_name VARCHAR(256), iop_order REAL)&quot;,</a>
<a name="ln1358">      NULL, NULL, NULL);</a>
<a name="ln1359">  sqlite3_exec(</a>
<a name="ln1360">      db-&gt;handle,</a>
<a name="ln1361">      &quot;CREATE TABLE memory.undo_history (id INTEGER, imgid INTEGER, num INTEGER, module INTEGER, &quot;</a>
<a name="ln1362">      &quot;operation VARCHAR(256), op_params BLOB, enabled INTEGER, &quot;</a>
<a name="ln1363">      &quot;blendop_params BLOB, blendop_version INTEGER, multi_priority INTEGER, multi_name VARCHAR(256), iop_order REAL)&quot;,</a>
<a name="ln1364">      NULL, NULL, NULL);</a>
<a name="ln1365">  sqlite3_exec(</a>
<a name="ln1366">      db-&gt;handle,</a>
<a name="ln1367">      &quot;CREATE TABLE memory.undo_masks_history (id INTEGER, imgid INTEGER, num INTEGER, formid INTEGER, form INTEGER, &quot;</a>
<a name="ln1368">      &quot;name VARCHAR(256), version INTEGER, points BLOB, points_count INTEGER, source BLOB)&quot;,</a>
<a name="ln1369">      NULL, NULL, NULL);</a>
<a name="ln1370">}</a>
<a name="ln1371"> </a>
<a name="ln1372">static void _sanitize_db(dt_database_t *db)</a>
<a name="ln1373">{</a>
<a name="ln1374">  sqlite3_stmt *stmt, *innerstmt;</a>
<a name="ln1375"> </a>
<a name="ln1376">  /* first let's get rid of non-utf8 tags. */</a>
<a name="ln1377">  sqlite3_prepare_v2(db-&gt;handle, &quot;SELECT id, name FROM data.tags&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1378">  sqlite3_prepare_v2(db-&gt;handle, &quot;UPDATE data.tags SET name = ?1 WHERE id = ?2&quot;, -1, &amp;innerstmt, NULL);</a>
<a name="ln1379">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1380">  {</a>
<a name="ln1381">    int id = sqlite3_column_int(stmt, 0);</a>
<a name="ln1382">    const char *tag = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln1383"> </a>
<a name="ln1384">    if(!g_utf8_validate(tag, -1, NULL))</a>
<a name="ln1385">    {</a>
<a name="ln1386">      gchar *new_tag = dt_util_foo_to_utf8(tag);</a>
<a name="ln1387">      fprintf(stderr, &quot;[init]: tag `%s' is not valid utf8, replacing it with `%s'\n&quot;, tag, new_tag);</a>
<a name="ln1388">      if(tag)</a>
<a name="ln1389">      {</a>
<a name="ln1390">        sqlite3_bind_text(innerstmt, 1, new_tag, -1, SQLITE_TRANSIENT);</a>
<a name="ln1391">        sqlite3_bind_int(innerstmt, 2, id);</a>
<a name="ln1392">        sqlite3_step(innerstmt);</a>
<a name="ln1393">        sqlite3_reset(innerstmt);</a>
<a name="ln1394">        sqlite3_clear_bindings(innerstmt);</a>
<a name="ln1395">        g_free(new_tag);</a>
<a name="ln1396">      }</a>
<a name="ln1397">    }</a>
<a name="ln1398">  }</a>
<a name="ln1399">  sqlite3_finalize(stmt);</a>
<a name="ln1400">  sqlite3_finalize(innerstmt);</a>
<a name="ln1401">}</a>
<a name="ln1402"> </a>
<a name="ln1403">// in library we keep the names of the tags used in tagged_images. however, using that table at runtime results</a>
<a name="ln1404">// in some overhead not necessary so instead we just use the used_tags table to update tagged_images on startup</a>
<a name="ln1405">#define TRY_EXEC(_query, _message)                                                 \</a>
<a name="ln1406">  do                                                                               \</a>
<a name="ln1407">  {                                                                                \</a>
<a name="ln1408">    if(sqlite3_exec(db-&gt;handle, _query, NULL, NULL, NULL) != SQLITE_OK)            \</a>
<a name="ln1409">    {                                                                              \</a>
<a name="ln1410">      fprintf(stderr, _message);                                                   \</a>
<a name="ln1411">      fprintf(stderr, &quot;[init]   %s\n&quot;, sqlite3_errmsg(db-&gt;handle));                \</a>
<a name="ln1412">      FINALIZE;                                                                    \</a>
<a name="ln1413">      sqlite3_exec(db-&gt;handle, &quot;ROLLBACK TRANSACTION&quot;, NULL, NULL, NULL);          \</a>
<a name="ln1414">      return FALSE;                                                                \</a>
<a name="ln1415">    }                                                                              \</a>
<a name="ln1416">  } while(0)</a>
<a name="ln1417"> </a>
<a name="ln1418">#define TRY_STEP(_stmt, _expected, _message)                                       \</a>
<a name="ln1419">  do                                                                               \</a>
<a name="ln1420">  {                                                                                \</a>
<a name="ln1421">    if(sqlite3_step(_stmt) != _expected)                                           \</a>
<a name="ln1422">    {                                                                              \</a>
<a name="ln1423">      fprintf(stderr, _message);                                                   \</a>
<a name="ln1424">      fprintf(stderr, &quot;[init]   %s\n&quot;, sqlite3_errmsg(db-&gt;handle));                \</a>
<a name="ln1425">      FINALIZE;                                                                    \</a>
<a name="ln1426">      sqlite3_exec(db-&gt;handle, &quot;ROLLBACK TRANSACTION&quot;, NULL, NULL, NULL);          \</a>
<a name="ln1427">      return FALSE;                                                                \</a>
<a name="ln1428">    }                                                                              \</a>
<a name="ln1429">  } while(0)</a>
<a name="ln1430"> </a>
<a name="ln1431">#define TRY_PREPARE(_stmt, _query, _message)                                       \</a>
<a name="ln1432">  do                                                                               \</a>
<a name="ln1433">  {                                                                                \</a>
<a name="ln1434">    if(sqlite3_prepare_v2(db-&gt;handle, _query, -1, &amp;_stmt, NULL) != SQLITE_OK)      \</a>
<a name="ln1435">    {                                                                              \</a>
<a name="ln1436">      fprintf(stderr, _message);                                                   \</a>
<a name="ln1437">      fprintf(stderr, &quot;[init]   %s\n&quot;, sqlite3_errmsg(db-&gt;handle));                \</a>
<a name="ln1438">      FINALIZE;                                                                    \</a>
<a name="ln1439">      sqlite3_exec(db-&gt;handle, &quot;ROLLBACK TRANSACTION&quot;, NULL, NULL, NULL);          \</a>
<a name="ln1440">      return FALSE;                                                                \</a>
<a name="ln1441">    }                                                                              \</a>
<a name="ln1442">  } while(0)</a>
<a name="ln1443"> </a>
<a name="ln1444">#define FINALIZE                                                                   \</a>
<a name="ln1445">  do                                                                               \</a>
<a name="ln1446">  {                                                                                \</a>
<a name="ln1447">    sqlite3_finalize(stmt); stmt = NULL; /* NULL so that finalize becomes a NOP */ \</a>
<a name="ln1448">  } while(0)</a>
<a name="ln1449"> </a>
<a name="ln1450">static gboolean _synchronize_tags(dt_database_t *db)</a>
<a name="ln1451">{</a>
<a name="ln1452">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln1453"> </a>
<a name="ln1454">  sqlite3_exec(db-&gt;handle, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln1455"> </a>
<a name="ln1456">  // create temporary tables -- that has to be done outside the if() as the db is locked inside</a>
<a name="ln1457">  TRY_EXEC(&quot;CREATE TEMPORARY TABLE temp_used_tags (id INTEGER, name VARCHAR)&quot;,</a>
<a name="ln1458">           &quot;[synchronize tags] can't create temporary table for used tags\n&quot;);</a>
<a name="ln1459">  TRY_EXEC(&quot;CREATE TEMPORARY TABLE temp_tagged_images (imgid INTEGER, tagid INTEGER)&quot;,</a>
<a name="ln1460">           &quot;[synchronize tags] can't create temporary table for tagged images\n&quot;);</a>
<a name="ln1461"> </a>
<a name="ln1462">  // are the two databases in sync already?</a>
<a name="ln1463">  TRY_PREPARE(stmt, &quot;SELECT COUNT(*) FROM main.used_tags AS u LEFT JOIN data.tags AS t USING (id, name) &quot;</a>
<a name="ln1464">                    &quot;WHERE u.id IS NULL OR t.id IS NULL&quot;,</a>
<a name="ln1465">              &quot;[synchronize tags] can't prepare querying the number of tags that need to be synced\n&quot;);</a>
<a name="ln1466"> </a>
<a name="ln1467">  TRY_STEP(stmt, SQLITE_ROW, &quot;[synchronize tags] can't query the number of tags that need to be synced\n&quot;);</a>
<a name="ln1468">  if(sqlite3_column_int(stmt, 0) &gt; 0)</a>
<a name="ln1469">  {</a>
<a name="ln1470">    // insert tags that are only present in main.used_tags into data.tags</a>
<a name="ln1471">    TRY_EXEC(&quot;INSERT OR IGNORE INTO data.tags (name) SELECT name FROM main.used_tags&quot;,</a>
<a name="ln1472">             &quot;[synchronize tags] can't import new tags from the library\n&quot;);</a>
<a name="ln1473"> </a>
<a name="ln1474">    // insert id, name for the tags in main.used_tags according to data.tags</a>
<a name="ln1475">    TRY_EXEC(&quot;INSERT INTO temp_used_tags (id, name) SELECT t.id, t.name FROM main.used_tags, data.tags &quot;</a>
<a name="ln1476">             &quot;AS t USING (name)&quot;, &quot;[synchronize tags] can't collect used tags into temporary table\n&quot;);</a>
<a name="ln1477"> </a>
<a name="ln1478">    // insert updated valued into temp_tagged_images</a>
<a name="ln1479">    // FIXME: slowish!</a>
<a name="ln1480">    TRY_EXEC(&quot;INSERT INTO temp_tagged_images (imgid, tagid) SELECT imgid, new_id FROM main.tagged_images, &quot;</a>
<a name="ln1481">             &quot;(SELECT u.id AS old_id, tu.id AS new_id, name FROM used_tags AS u, temp_used_tags AS tu &quot;</a>
<a name="ln1482">             &quot;USING (name)) ON old_id = tagid&quot;,</a>
<a name="ln1483">             &quot;[synchronize tags] can't insert updated image tagging into temporary table\n&quot;);</a>
<a name="ln1484"> </a>
<a name="ln1485">    // clear table to not get in conflict with indices</a>
<a name="ln1486">    TRY_EXEC(&quot;DELETE FROM main.tagged_images&quot;, &quot;[synchronize tags] can't clear table `tagged_images'\n&quot;);</a>
<a name="ln1487">    TRY_EXEC(&quot;DELETE FROM main.used_tags&quot;, &quot;[synchronize tags] can't clear table `used_tags'\n&quot;);</a>
<a name="ln1488"> </a>
<a name="ln1489">    // copy back to main.tagged_images</a>
<a name="ln1490">    // FIXME: slow with huge db! dropping the index first and adding it back in the end speeds it up a little</a>
<a name="ln1491">    TRY_EXEC(&quot;INSERT INTO main.tagged_images (imgid, tagid) SELECT imgid, tagid FROM temp_tagged_images&quot;,</a>
<a name="ln1492">             &quot;[synchronize tags] can't update table `tagged_images`\n&quot;);</a>
<a name="ln1493"> </a>
<a name="ln1494">    // copy back to main.used_tags</a>
<a name="ln1495">    TRY_EXEC(&quot;INSERT INTO main.used_tags (id, name) SELECT id, name FROM temp_used_tags&quot;,</a>
<a name="ln1496">             &quot;[synchronize tags] can't update table `used_tags'\n&quot;);</a>
<a name="ln1497">  }</a>
<a name="ln1498"> </a>
<a name="ln1499">  FINALIZE; // we need to finalize before dropping the tables due to locking issues!</a>
<a name="ln1500"> </a>
<a name="ln1501">  // drop temporary tables</a>
<a name="ln1502">  TRY_EXEC(&quot;DROP TABLE temp_tagged_images&quot;, &quot;[synchronize tags] can't drop temporary table for tagged_images\n&quot;);</a>
<a name="ln1503">  TRY_EXEC(&quot;DROP TABLE temp_used_tags&quot;, &quot;[synchronize tags] can't drop temporary table for used_tags\n&quot;);</a>
<a name="ln1504"> </a>
<a name="ln1505">  sqlite3_exec(db-&gt;handle, &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln1506"> </a>
<a name="ln1507">  return TRUE;</a>
<a name="ln1508">}</a>
<a name="ln1509"> </a>
<a name="ln1510">#undef TRY_EXEC</a>
<a name="ln1511">#undef TRY_STEP</a>
<a name="ln1512">#undef TRY_PREPARE</a>
<a name="ln1513">#undef FINALIZE</a>
<a name="ln1514"> </a>
<a name="ln1515">void dt_database_show_error(const dt_database_t *db)</a>
<a name="ln1516">{</a>
<a name="ln1517">  if(!db-&gt;lock_acquired)</a>
<a name="ln1518">  {</a>
<a name="ln1519">    char *label_text = g_markup_printf_escaped(_(&quot;an error has occurred while trying to open the database from\n&quot;</a>
<a name="ln1520">                                                  &quot;\n&quot;</a>
<a name="ln1521">                                                  &quot;&lt;span style=\&quot;italic\&quot;&gt;%s&lt;/span&gt;\n&quot;</a>
<a name="ln1522">                                                  &quot;\n&quot;</a>
<a name="ln1523">                                                  &quot;%s\n&quot;),</a>
<a name="ln1524">                                                db-&gt;error_dbfilename, db-&gt;error_message ? db-&gt;error_message : &quot;&quot;);</a>
<a name="ln1525"> </a>
<a name="ln1526">    dt_gui_show_standalone_yes_no_dialog(_(&quot;darktable - error locking database&quot;), label_text, _(&quot;close darktable&quot;),</a>
<a name="ln1527">                                         /*_(&quot;try again&quot;)*/NULL);</a>
<a name="ln1528"> </a>
<a name="ln1529">    g_free(label_text);</a>
<a name="ln1530">  }</a>
<a name="ln1531"> </a>
<a name="ln1532">  g_free(db-&gt;error_message);</a>
<a name="ln1533">  g_free(db-&gt;error_dbfilename);</a>
<a name="ln1534">  ((dt_database_t *)db)-&gt;error_message = NULL;</a>
<a name="ln1535">  ((dt_database_t *)db)-&gt;error_dbfilename = NULL;</a>
<a name="ln1536">}</a>
<a name="ln1537"> </a>
<a name="ln1538">static gboolean pid_is_alive(int pid)</a>
<a name="ln1539">{</a>
<a name="ln1540">  gboolean pid_is_alive;</a>
<a name="ln1541"> </a>
<a name="ln1542">#ifdef _WIN32</a>
<a name="ln1543">  pid_is_alive = FALSE;</a>
<a name="ln1544">  HANDLE h = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);</a>
<a name="ln1545">  if(h)</a>
<a name="ln1546">  {</a>
<a name="ln1547">    wchar_t wfilename[MAX_PATH];</a>
<a name="ln1548">    long unsigned int n_filename = sizeof(wfilename);</a>
<a name="ln1549">    int ret = QueryFullProcessImageNameW(h, 0, wfilename, &amp;n_filename);</a>
<a name="ln1550">    char *filename = g_utf16_to_utf8(wfilename, -1, NULL, NULL, NULL);</a>
<a name="ln1551">    if(ret &amp;&amp; n_filename &gt; 0 &amp;&amp; filename &amp;&amp; g_str_has_suffix(filename, &quot;darktable.exe&quot;))</a>
<a name="ln1552">      pid_is_alive = TRUE;</a>
<a name="ln1553">    g_free(filename);</a>
<a name="ln1554">    CloseHandle(h);</a>
<a name="ln1555">  }</a>
<a name="ln1556">#else</a>
<a name="ln1557">  pid_is_alive = !((kill(pid, 0) == -1) &amp;&amp; errno == ESRCH);</a>
<a name="ln1558"> </a>
<a name="ln1559">#ifdef __linux__</a>
<a name="ln1560">  // If this is Linux, we can query /proc to see if the pid is</a>
<a name="ln1561">  // actually a darktable instance.</a>
<a name="ln1562">  if(pid_is_alive)</a>
<a name="ln1563">  {</a>
<a name="ln1564">    gchar *contents;</a>
<a name="ln1565">    gsize length;</a>
<a name="ln1566">    gchar filename[64];</a>
<a name="ln1567">    snprintf(filename, sizeof(filename), &quot;/proc/%d/cmdline&quot;, pid);</a>
<a name="ln1568"> </a>
<a name="ln1569">    if(g_file_get_contents(&quot;&quot;, &amp;contents, &amp;length, NULL))</a>
<a name="ln1570">    {</a>
<a name="ln1571">      if(strstr(contents, &quot;darktable&quot;) == NULL)</a>
<a name="ln1572">      {</a>
<a name="ln1573">        pid_is_alive = FALSE;</a>
<a name="ln1574">      }</a>
<a name="ln1575">      g_free(contents);</a>
<a name="ln1576">    }</a>
<a name="ln1577">  }</a>
<a name="ln1578">#endif</a>
<a name="ln1579"> </a>
<a name="ln1580">#endif</a>
<a name="ln1581"> </a>
<a name="ln1582">  return pid_is_alive;</a>
<a name="ln1583">}</a>
<a name="ln1584"> </a>
<a name="ln1585">static gboolean _lock_single_database(dt_database_t *db, const char *dbfilename, char **lockfile)</a>
<a name="ln1586">{</a>
<a name="ln1587">  gboolean lock_acquired = FALSE;</a>
<a name="ln1588">  mode_t old_mode;</a>
<a name="ln1589">  int fd = 0, lock_tries = 0;</a>
<a name="ln1590">  gchar *pid = g_strdup_printf(&quot;%d&quot;, getpid());</a>
<a name="ln1591"> </a>
<a name="ln1592">  if(!strcmp(dbfilename, &quot;:memory:&quot;))</a>
<a name="ln1593">  {</a>
<a name="ln1594">    lock_acquired = TRUE;</a>
<a name="ln1595">  }</a>
<a name="ln1596">  else</a>
<a name="ln1597">  {</a>
<a name="ln1598">    *lockfile = g_strconcat(dbfilename, &quot;.lock&quot;, NULL);</a>
<a name="ln1599">lock_again:</a>
<a name="ln1600">    lock_tries++;</a>
<a name="ln1601">    old_mode = umask(0);</a>
<a name="ln1602">    fd = g_open(*lockfile, O_RDWR | O_CREAT | O_EXCL, 0666);</a>
<a name="ln1603">    umask(old_mode);</a>
<a name="ln1604"> </a>
<a name="ln1605">    if(fd != -1) // the lockfile was successfully created - write our PID into it</a>
<a name="ln1606">    {</a>
<a name="ln1607">      if(write(fd, pid, strlen(pid) + 1) &gt; -1) lock_acquired = TRUE;</a>
<a name="ln1608">      close(fd);</a>
<a name="ln1609">    }</a>
<a name="ln1610">    else // the lockfile already exists - see if it's a stale one left over from a crashed instance</a>
<a name="ln1611">    {</a>
<a name="ln1612">      char buf[64];</a>
<a name="ln1613">      memset(buf, 0, sizeof(buf));</a>
<a name="ln1614">      fd = g_open(*lockfile, O_RDWR | O_CREAT, 0666);</a>
<a name="ln1615">      if(fd != -1)</a>
<a name="ln1616">      {</a>
<a name="ln1617">        int foo;</a>
<a name="ln1618">        if((foo = read(fd, buf, sizeof(buf) - 1)) &gt; 0)</a>
<a name="ln1619">        {</a>
<a name="ln1620">          int other_pid = atoi(buf);</a>
<a name="ln1621">          if(!pid_is_alive(other_pid))</a>
<a name="ln1622">          {</a>
<a name="ln1623">            // the other process seems to no longer exist. unlink the .lock file and try again</a>
<a name="ln1624">            g_unlink(*lockfile);</a>
<a name="ln1625">            if(lock_tries &lt; 5)</a>
<a name="ln1626">            {</a>
<a name="ln1627">              close(fd);</a>
<a name="ln1628">              goto lock_again;</a>
<a name="ln1629">            }</a>
<a name="ln1630">          }</a>
<a name="ln1631">          else</a>
<a name="ln1632">          {</a>
<a name="ln1633">            fprintf(</a>
<a name="ln1634">              stderr,</a>
<a name="ln1635">              &quot;[init] the database lock file contains a pid that seems to be alive in your system: %d\n&quot;,</a>
<a name="ln1636">              other_pid);</a>
<a name="ln1637">            db-&gt;error_message = g_strdup_printf(_(&quot;the database lock file contains a pid that seems to be alive in your system: %d&quot;), other_pid);</a>
<a name="ln1638">          }</a>
<a name="ln1639">        }</a>
<a name="ln1640">        else</a>
<a name="ln1641">        {</a>
<a name="ln1642">          fprintf(stderr, &quot;[init] the database lock file seems to be empty\n&quot;);</a>
<a name="ln1643">          db-&gt;error_message = g_strdup_printf(_(&quot;the database lock file seems to be empty&quot;));</a>
<a name="ln1644">        }</a>
<a name="ln1645">        close(fd);</a>
<a name="ln1646">      }</a>
<a name="ln1647">      else</a>
<a name="ln1648">      {</a>
<a name="ln1649">        int err = errno;</a>
<a name="ln1650">        fprintf(stderr, &quot;[init] error opening the database lock file for reading: %s\n&quot;, strerror(err));</a>
<a name="ln1651">        db-&gt;error_message = g_strdup_printf(_(&quot;error opening the database lock file for reading: %s&quot;), strerror(err));</a>
<a name="ln1652">      }</a>
<a name="ln1653">    }</a>
<a name="ln1654">  }</a>
<a name="ln1655"> </a>
<a name="ln1656">  g_free(pid);</a>
<a name="ln1657"> </a>
<a name="ln1658">  if(db-&gt;error_message)</a>
<a name="ln1659">    db-&gt;error_dbfilename = g_strdup(dbfilename);</a>
<a name="ln1660"> </a>
<a name="ln1661">  return lock_acquired;</a>
<a name="ln1662">}</a>
<a name="ln1663"> </a>
<a name="ln1664">static gboolean _lock_databases(dt_database_t *db)</a>
<a name="ln1665">{</a>
<a name="ln1666">  if(!_lock_single_database(db, db-&gt;dbfilename_data, &amp;db-&gt;lockfile_data))</a>
<a name="ln1667">    return FALSE;</a>
<a name="ln1668">  if(!_lock_single_database(db, db-&gt;dbfilename_library, &amp;db-&gt;lockfile_library))</a>
<a name="ln1669">  {</a>
<a name="ln1670">    // unlock data.db to not leave a stale lock file around</a>
<a name="ln1671">    g_unlink(db-&gt;lockfile_data);</a>
<a name="ln1672">    return FALSE;</a>
<a name="ln1673">  }</a>
<a name="ln1674">  return TRUE;</a>
<a name="ln1675">}</a>
<a name="ln1676"> </a>
<a name="ln1677">void ask_for_upgrade(const gchar *dbname)</a>
<a name="ln1678">{</a>
<a name="ln1679">  // the database has to be upgraded, let's ask user</a>
<a name="ln1680"> </a>
<a name="ln1681">  char *label_text = g_markup_printf_escaped(_(&quot;the database schema has to be upgraded for\n&quot;</a>
<a name="ln1682">                                               &quot;\n&quot;</a>
<a name="ln1683">                                               &quot;&lt;span style=\&quot;italic\&quot;&gt;%s&lt;/span&gt;\n&quot;</a>
<a name="ln1684">                                               &quot;\n&quot;</a>
<a name="ln1685">                                               &quot;do you want to proceed or quit now to do a backup\n&quot;),</a>
<a name="ln1686">                                               dbname);</a>
<a name="ln1687"> </a>
<a name="ln1688">  gboolean shall_we_update_the_db =</a>
<a name="ln1689">    dt_gui_show_standalone_yes_no_dialog(_(&quot;darktable - schema migration&quot;), label_text,</a>
<a name="ln1690">                                         _(&quot;close darktable&quot;), _(&quot;upgrade database&quot;));</a>
<a name="ln1691"> </a>
<a name="ln1692">  g_free(label_text);</a>
<a name="ln1693"> </a>
<a name="ln1694">  // if no upgrade, we exit now, nothing we can do more</a>
<a name="ln1695">  if(!shall_we_update_the_db) exit(1);</a>
<a name="ln1696">}</a>
<a name="ln1697"> </a>
<a name="ln1698">dt_database_t *dt_database_init(const char *alternative, const gboolean load_data)</a>
<a name="ln1699">{</a>
<a name="ln1700">  /*  set the threading mode to Serialized */</a>
<a name="ln1701">  sqlite3_config(SQLITE_CONFIG_SERIALIZED);</a>
<a name="ln1702"> </a>
<a name="ln1703">  sqlite3_initialize();</a>
<a name="ln1704"> </a>
<a name="ln1705">start:</a>
<a name="ln1706">  /* migrate default database location to new default */</a>
<a name="ln1707">  _database_migrate_to_xdg_structure();</a>
<a name="ln1708"> </a>
<a name="ln1709">  /* delete old mipmaps files */</a>
<a name="ln1710">  _database_delete_mipmaps_files();</a>
<a name="ln1711"> </a>
<a name="ln1712">  /* lets construct the db filename  */</a>
<a name="ln1713">  gchar *dbname = NULL;</a>
<a name="ln1714">  gchar dbfilename_library[PATH_MAX] = { 0 };</a>
<a name="ln1715">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln1716"> </a>
<a name="ln1717">  dt_loc_get_user_config_dir(datadir, sizeof(datadir));</a>
<a name="ln1718"> </a>
<a name="ln1719">  if(alternative == NULL)</a>
<a name="ln1720">  {</a>
<a name="ln1721">    dbname = dt_conf_get_string(&quot;database&quot;);</a>
<a name="ln1722">    if(!dbname)</a>
<a name="ln1723">      snprintf(dbfilename_library, sizeof(dbfilename_library), &quot;%s/library.db&quot;, datadir);</a>
<a name="ln1724">    else if(!strcmp(dbname, &quot;:memory:&quot;))</a>
<a name="ln1725">      snprintf(dbfilename_library, sizeof(dbfilename_library), &quot;%s&quot;, dbname);</a>
<a name="ln1726">    else if(dbname[0] != '/')</a>
<a name="ln1727">      snprintf(dbfilename_library, sizeof(dbfilename_library), &quot;%s/%s&quot;, datadir, dbname);</a>
<a name="ln1728">    else</a>
<a name="ln1729">      snprintf(dbfilename_library, sizeof(dbfilename_library), &quot;%s&quot;, dbname);</a>
<a name="ln1730">  }</a>
<a name="ln1731">  else</a>
<a name="ln1732">  {</a>
<a name="ln1733">    snprintf(dbfilename_library, sizeof(dbfilename_library), &quot;%s&quot;, alternative);</a>
<a name="ln1734"> </a>
<a name="ln1735">    GFile *galternative = g_file_new_for_path(alternative);</a>
<a name="ln1736">    dbname = g_file_get_basename(galternative);</a>
<a name="ln1737">    g_object_unref(galternative);</a>
<a name="ln1738">  }</a>
<a name="ln1739"> </a>
<a name="ln1740">  /* we also need a 2nd db with permanent data like presets, styles and tags */</a>
<a name="ln1741">  char dbfilename_data[PATH_MAX] = { 0 };</a>
<a name="ln1742">  if(load_data)</a>
<a name="ln1743">    snprintf(dbfilename_data, sizeof(dbfilename_data), &quot;%s/data.db&quot;, datadir);</a>
<a name="ln1744">  else</a>
<a name="ln1745">    snprintf(dbfilename_data, sizeof(dbfilename_data), &quot;:memory:&quot;);</a>
<a name="ln1746"> </a>
<a name="ln1747">  /* create database */</a>
<a name="ln1748">  dt_database_t *db = (dt_database_t *)g_malloc0(sizeof(dt_database_t));</a>
<a name="ln1749">  db-&gt;dbfilename_data = g_strdup(dbfilename_data);</a>
<a name="ln1750">  db-&gt;dbfilename_library = g_strdup(dbfilename_library);</a>
<a name="ln1751"> </a>
<a name="ln1752">  /* make sure the folder exists. this might not be the case for new databases */</a>
<a name="ln1753">  char *data_path = g_path_get_dirname(db-&gt;dbfilename_data);</a>
<a name="ln1754">  char *library_path = g_path_get_dirname(db-&gt;dbfilename_library);</a>
<a name="ln1755">  g_mkdir_with_parents(data_path, 0750);</a>
<a name="ln1756">  g_mkdir_with_parents(library_path, 0750);</a>
<a name="ln1757">  g_free(data_path);</a>
<a name="ln1758">  g_free(library_path);</a>
<a name="ln1759"> </a>
<a name="ln1760">  /* having more than one instance of darktable using the same database is a bad idea */</a>
<a name="ln1761">  /* try to get locks for the databases */</a>
<a name="ln1762">  db-&gt;lock_acquired = _lock_databases(db);</a>
<a name="ln1763"> </a>
<a name="ln1764">  if(!db-&gt;lock_acquired)</a>
<a name="ln1765">  {</a>
<a name="ln1766">    fprintf(stderr, &quot;[init] database is locked, probably another process is already using it\n&quot;);</a>
<a name="ln1767">    g_free(dbname);</a>
<a name="ln1768">    return db;</a>
<a name="ln1769">  }</a>
<a name="ln1770"> </a>
<a name="ln1771"> </a>
<a name="ln1772">  /* opening / creating database */</a>
<a name="ln1773">  if(sqlite3_open(db-&gt;dbfilename_library, &amp;db-&gt;handle))</a>
<a name="ln1774">  {</a>
<a name="ln1775">    fprintf(stderr, &quot;[init] could not find database &quot;);</a>
<a name="ln1776">    if(dbname)</a>
<a name="ln1777">      fprintf(stderr, &quot;`%s'!\n&quot;, dbname);</a>
<a name="ln1778">    else</a>
<a name="ln1779">      fprintf(stderr, &quot;\n&quot;);</a>
<a name="ln1780">    fprintf(stderr, &quot;[init] maybe your %s/darktablerc is corrupt?\n&quot;, datadir);</a>
<a name="ln1781">    dt_loc_get_datadir(dbfilename_library, sizeof(dbfilename_library));</a>
<a name="ln1782">    fprintf(stderr, &quot;[init] try `cp %s/darktablerc %s/darktablerc'\n&quot;, dbfilename_library, datadir);</a>
<a name="ln1783">    sqlite3_close(db-&gt;handle);</a>
<a name="ln1784">    g_free(dbname);</a>
<a name="ln1785">    g_free(db-&gt;lockfile_data);</a>
<a name="ln1786">    g_free(db-&gt;dbfilename_data);</a>
<a name="ln1787">    g_free(db-&gt;lockfile_library);</a>
<a name="ln1788">    g_free(db-&gt;dbfilename_library);</a>
<a name="ln1789">    g_free(db);</a>
<a name="ln1790">    return NULL;</a>
<a name="ln1791">  }</a>
<a name="ln1792"> </a>
<a name="ln1793">  /* attach a memory database to db connection for use with temporary tables</a>
<a name="ln1794">     used during instance life time, which is discarded on exit.</a>
<a name="ln1795">  */</a>
<a name="ln1796">  sqlite3_exec(db-&gt;handle, &quot;attach database ':memory:' as memory&quot;, NULL, NULL, NULL);</a>
<a name="ln1797"> </a>
<a name="ln1798">  // attach the data database which contains presets, styles, tags and similar things not tied to single images</a>
<a name="ln1799">  sqlite3_stmt *stmt;</a>
<a name="ln1800">  gboolean have_data_db = load_data &amp;&amp; g_file_test(dbfilename_data, G_FILE_TEST_EXISTS);</a>
<a name="ln1801">  int rc = sqlite3_prepare_v2(db-&gt;handle, &quot;ATTACH DATABASE ?1 AS data&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1802">  sqlite3_bind_text(stmt, 1, dbfilename_data, -1, SQLITE_TRANSIENT);</a>
<a name="ln1803">  if(rc != SQLITE_OK || sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln1804">  {</a>
<a name="ln1805">    sqlite3_finalize(stmt);</a>
<a name="ln1806">    fprintf(stderr, &quot;[init] database `%s' couldn't be opened. aborting\n&quot;, dbfilename_data);</a>
<a name="ln1807">    dt_database_destroy(db);</a>
<a name="ln1808">    db = NULL;</a>
<a name="ln1809">    goto error;</a>
<a name="ln1810">  }</a>
<a name="ln1811">  sqlite3_finalize(stmt);</a>
<a name="ln1812"> </a>
<a name="ln1813">  // some sqlite3 config</a>
<a name="ln1814">  sqlite3_exec(db-&gt;handle, &quot;PRAGMA synchronous = OFF&quot;, NULL, NULL, NULL);</a>
<a name="ln1815">  sqlite3_exec(db-&gt;handle, &quot;PRAGMA journal_mode = MEMORY&quot;, NULL, NULL, NULL);</a>
<a name="ln1816">  sqlite3_exec(db-&gt;handle, &quot;PRAGMA page_size = 32768&quot;, NULL, NULL, NULL);</a>
<a name="ln1817"> </a>
<a name="ln1818">  /* now that we got functional databases that are locked for us we can make sure that the schema is set up */</a>
<a name="ln1819"> </a>
<a name="ln1820">  // first we update the data database to the latest version so that we can potentially move data from the library</a>
<a name="ln1821">  // over when updating that one</a>
<a name="ln1822">  if(!have_data_db)</a>
<a name="ln1823">  {</a>
<a name="ln1824">    _create_data_schema(db); // a brand new db it seems</a>
<a name="ln1825">  }</a>
<a name="ln1826">  else</a>
<a name="ln1827">  {</a>
<a name="ln1828">    rc = sqlite3_prepare_v2(db-&gt;handle, &quot;select value from data.db_info where key = 'version'&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1829">    if(rc == SQLITE_OK &amp;&amp; sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1830">    {</a>
<a name="ln1831">      // compare the version of the db with what is current for this executable</a>
<a name="ln1832">      const int db_version = sqlite3_column_int(stmt, 0);</a>
<a name="ln1833">      sqlite3_finalize(stmt);</a>
<a name="ln1834">      if(db_version &lt; CURRENT_DATABASE_VERSION_DATA)</a>
<a name="ln1835">      {</a>
<a name="ln1836">        ask_for_upgrade(dbfilename_data);</a>
<a name="ln1837"> </a>
<a name="ln1838">        // older: upgrade</a>
<a name="ln1839">        if(!_upgrade_data_schema(db, db_version))</a>
<a name="ln1840">        {</a>
<a name="ln1841">          // we couldn't upgrade the db for some reason. bail out.</a>
<a name="ln1842">          fprintf(stderr, &quot;[init] database `%s' couldn't be upgraded from version %d to %d. aborting\n&quot;,</a>
<a name="ln1843">                  dbfilename_data, db_version, CURRENT_DATABASE_VERSION_DATA);</a>
<a name="ln1844">          dt_database_destroy(db);</a>
<a name="ln1845">          db = NULL;</a>
<a name="ln1846">          goto error;</a>
<a name="ln1847">        }</a>
<a name="ln1848">      }</a>
<a name="ln1849">      else if(db_version &gt; CURRENT_DATABASE_VERSION_DATA)</a>
<a name="ln1850">      {</a>
<a name="ln1851">        // newer: bail out</a>
<a name="ln1852">        fprintf(stderr, &quot;[init] database version of `%s' is too new for this build of darktable. aborting\n&quot;,</a>
<a name="ln1853">                dbfilename_data);</a>
<a name="ln1854">        dt_database_destroy(db);</a>
<a name="ln1855">        db = NULL;</a>
<a name="ln1856">        goto error;</a>
<a name="ln1857">      }</a>
<a name="ln1858">      // else: the current version, do nothing</a>
<a name="ln1859">    }</a>
<a name="ln1860">    else</a>
<a name="ln1861">    {</a>
<a name="ln1862">      // oh, bad situation. the database is corrupt and can't be read!</a>
<a name="ln1863">      // we inform the user here and let him decide what to do: exit or delete and try again.</a>
<a name="ln1864"> </a>
<a name="ln1865">      char *label_text = g_markup_printf_escaped(_(&quot;an error has occurred while trying to open the database from\n&quot;</a>
<a name="ln1866">                                                   &quot;\n&quot;</a>
<a name="ln1867">                                                   &quot;&lt;span style=\&quot;italic\&quot;&gt;%s&lt;/span&gt;\n&quot;</a>
<a name="ln1868">                                                   &quot;\n&quot;</a>
<a name="ln1869">                                                   &quot;it seems that the database is corrupt.\n&quot;</a>
<a name="ln1870">                                                   &quot;do you want to close darktable now to manually restore\n&quot;</a>
<a name="ln1871">                                                   &quot;the database from a backup or start with a new one?&quot;),</a>
<a name="ln1872">                                                 dbfilename_data);</a>
<a name="ln1873"> </a>
<a name="ln1874">      gboolean shall_we_delete_the_db =</a>
<a name="ln1875">          dt_gui_show_standalone_yes_no_dialog(_(&quot;darktable - error opening database&quot;), label_text,</a>
<a name="ln1876">                                               _(&quot;close darktable&quot;), _(&quot;delete database&quot;));</a>
<a name="ln1877"> </a>
<a name="ln1878">      g_free(label_text);</a>
<a name="ln1879"> </a>
<a name="ln1880">      dt_database_destroy(db);</a>
<a name="ln1881">      db = NULL;</a>
<a name="ln1882"> </a>
<a name="ln1883">      if(shall_we_delete_the_db)</a>
<a name="ln1884">      {</a>
<a name="ln1885">        fprintf(stderr, &quot;[init] deleting `%s' on user request&quot;, dbfilename_data);</a>
<a name="ln1886"> </a>
<a name="ln1887">        if(g_unlink(dbfilename_data) == 0)</a>
<a name="ln1888">          fprintf(stderr, &quot; ... ok\n&quot;);</a>
<a name="ln1889">        else</a>
<a name="ln1890">          fprintf(stderr, &quot; ... failed\n&quot;);</a>
<a name="ln1891"> </a>
<a name="ln1892">        goto start;</a>
<a name="ln1893">      }</a>
<a name="ln1894">      else</a>
<a name="ln1895">      {</a>
<a name="ln1896">        fprintf(stderr, &quot;[init] database `%s' is corrupt and can't be opened! either replace it from a backup or &quot;</a>
<a name="ln1897">        &quot;delete the file so that darktable can create a new one the next time. aborting\n&quot;, dbfilename_data);</a>
<a name="ln1898">        goto error;</a>
<a name="ln1899">      }</a>
<a name="ln1900">    }</a>
<a name="ln1901">  }</a>
<a name="ln1902"> </a>
<a name="ln1903">  // next we are looking at the library database</a>
<a name="ln1904">  // does the db contain the new 'db_info' table?</a>
<a name="ln1905">  rc = sqlite3_prepare_v2(db-&gt;handle, &quot;select value from main.db_info where key = 'version'&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1906">  if(rc == SQLITE_OK &amp;&amp; sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1907">  {</a>
<a name="ln1908">    // compare the version of the db with what is current for this executable</a>
<a name="ln1909">    const int db_version = sqlite3_column_int(stmt, 0);</a>
<a name="ln1910"> </a>
<a name="ln1911">    sqlite3_finalize(stmt);</a>
<a name="ln1912">    if(db_version &lt; CURRENT_DATABASE_VERSION_LIBRARY)</a>
<a name="ln1913">    {</a>
<a name="ln1914">      ask_for_upgrade(dbfilename_library);</a>
<a name="ln1915"> </a>
<a name="ln1916">      // older: upgrade</a>
<a name="ln1917">      if(!_upgrade_library_schema(db, db_version))</a>
<a name="ln1918">      {</a>
<a name="ln1919">        // we couldn't upgrade the db for some reason. bail out.</a>
<a name="ln1920">        fprintf(stderr, &quot;[init] database `%s' couldn't be upgraded from version %d to %d. aborting\n&quot;, dbname,</a>
<a name="ln1921">                db_version, CURRENT_DATABASE_VERSION_LIBRARY);</a>
<a name="ln1922">        dt_database_destroy(db);</a>
<a name="ln1923">        db = NULL;</a>
<a name="ln1924">        goto error;</a>
<a name="ln1925">      }</a>
<a name="ln1926">    }</a>
<a name="ln1927">    else if(db_version &gt; CURRENT_DATABASE_VERSION_LIBRARY)</a>
<a name="ln1928">    {</a>
<a name="ln1929">      // newer: bail out. it's better than what we did before: delete everything</a>
<a name="ln1930">      fprintf(stderr, &quot;[init] database version of `%s' is too new for this build of darktable. aborting\n&quot;,</a>
<a name="ln1931">              dbname);</a>
<a name="ln1932">      dt_database_destroy(db);</a>
<a name="ln1933">      db = NULL;</a>
<a name="ln1934">      goto error;</a>
<a name="ln1935">    }</a>
<a name="ln1936">    // else: the current version, do nothing</a>
<a name="ln1937">  }</a>
<a name="ln1938">  else if(rc == SQLITE_CORRUPT || rc == SQLITE_NOTADB)</a>
<a name="ln1939">  {</a>
<a name="ln1940">    // oh, bad situation. the database is corrupt and can't be read!</a>
<a name="ln1941">    // we inform the user here and let him decide what to do: exit or delete and try again.</a>
<a name="ln1942"> </a>
<a name="ln1943">    char *label_text = g_markup_printf_escaped(_(&quot;an error has occurred while trying to open the database from\n&quot;</a>
<a name="ln1944">                                                  &quot;\n&quot;</a>
<a name="ln1945">                                                  &quot;&lt;span style=\&quot;italic\&quot;&gt;%s&lt;/span&gt;\n&quot;</a>
<a name="ln1946">                                                  &quot;\n&quot;</a>
<a name="ln1947">                                                  &quot;it seems that the database is corrupt.\n&quot;</a>
<a name="ln1948">                                                  &quot;do you want to close darktable now to manually restore\n&quot;</a>
<a name="ln1949">                                                  &quot;the database from a backup or start with a new one?&quot;),</a>
<a name="ln1950">                                               dbfilename_library);</a>
<a name="ln1951"> </a>
<a name="ln1952">    gboolean shall_we_delete_the_db =</a>
<a name="ln1953">        dt_gui_show_standalone_yes_no_dialog(_(&quot;darktable - error opening database&quot;), label_text,</a>
<a name="ln1954">                                              _(&quot;close darktable&quot;), _(&quot;delete database&quot;));</a>
<a name="ln1955"> </a>
<a name="ln1956">    g_free(label_text);</a>
<a name="ln1957"> </a>
<a name="ln1958">    dt_database_destroy(db);</a>
<a name="ln1959">    db = NULL;</a>
<a name="ln1960"> </a>
<a name="ln1961">    if(shall_we_delete_the_db)</a>
<a name="ln1962">    {</a>
<a name="ln1963">      fprintf(stderr, &quot;[init] deleting `%s' on user request&quot;, dbfilename_library);</a>
<a name="ln1964"> </a>
<a name="ln1965">      if(g_unlink(dbfilename_library) == 0)</a>
<a name="ln1966">        fprintf(stderr, &quot; ... ok\n&quot;);</a>
<a name="ln1967">      else</a>
<a name="ln1968">        fprintf(stderr, &quot; ... failed\n&quot;);</a>
<a name="ln1969"> </a>
<a name="ln1970">      goto start;</a>
<a name="ln1971">    }</a>
<a name="ln1972">    else</a>
<a name="ln1973">    {</a>
<a name="ln1974">      fprintf(stderr, &quot;[init] database `%s' is corrupt and can't be opened! either replace it from a backup or &quot;</a>
<a name="ln1975">                      &quot;delete the file so that darktable can create a new one the next time. aborting\n&quot;, dbname);</a>
<a name="ln1976">      goto error;</a>
<a name="ln1977">    }</a>
<a name="ln1978">  }</a>
<a name="ln1979">  else</a>
<a name="ln1980">  {</a>
<a name="ln1981">    // does it contain the legacy 'settings' table?</a>
<a name="ln1982">    sqlite3_finalize(stmt);</a>
<a name="ln1983">    rc = sqlite3_prepare_v2(db-&gt;handle, &quot;select settings from main.settings&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1984">    if(rc == SQLITE_OK &amp;&amp; sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1985">    {</a>
<a name="ln1986">      // the old blob had the version as an int in the first place</a>
<a name="ln1987">      const void *set = sqlite3_column_blob(stmt, 0);</a>
<a name="ln1988">      const int db_version = *(int *)set;</a>
<a name="ln1989">      sqlite3_finalize(stmt);</a>
<a name="ln1990">      if(!_migrate_schema(db, db_version)) // bring the legacy layout to the first one known to our upgrade</a>
<a name="ln1991">                                           // path ...</a>
<a name="ln1992">      {</a>
<a name="ln1993">        // we couldn't migrate the db for some reason. bail out.</a>
<a name="ln1994">        fprintf(stderr, &quot;[init] database `%s' couldn't be migrated from the legacy version %d. aborting\n&quot;,</a>
<a name="ln1995">                dbname, db_version);</a>
<a name="ln1996">        dt_database_destroy(db);</a>
<a name="ln1997">        db = NULL;</a>
<a name="ln1998">        goto error;</a>
<a name="ln1999">      }</a>
<a name="ln2000">      if(!_upgrade_library_schema(db, 1)) // ... and upgrade it</a>
<a name="ln2001">      {</a>
<a name="ln2002">        // we couldn't upgrade the db for some reason. bail out.</a>
<a name="ln2003">        fprintf(stderr, &quot;[init] database `%s' couldn't be upgraded from version 1 to %d. aborting\n&quot;, dbname,</a>
<a name="ln2004">                CURRENT_DATABASE_VERSION_LIBRARY);</a>
<a name="ln2005">        dt_database_destroy(db);</a>
<a name="ln2006">        db = NULL;</a>
<a name="ln2007">        goto error;</a>
<a name="ln2008">      }</a>
<a name="ln2009">    }</a>
<a name="ln2010">    else</a>
<a name="ln2011">    {</a>
<a name="ln2012">      sqlite3_finalize(stmt);</a>
<a name="ln2013">      _create_library_schema(db); // a brand new db it seems</a>
<a name="ln2014">    }</a>
<a name="ln2015">  }</a>
<a name="ln2016"> </a>
<a name="ln2017">  // create the in-memory tables</a>
<a name="ln2018">  _create_memory_schema(db);</a>
<a name="ln2019"> </a>
<a name="ln2020">  // create a table legacy_presets with all the presets from pre-auto-apply-cleanup darktable.</a>
<a name="ln2021">  dt_legacy_presets_create(db);</a>
<a name="ln2022"> </a>
<a name="ln2023">  // drop table settings -- we don't want old versions of dt to drop our tables</a>
<a name="ln2024">  sqlite3_exec(db-&gt;handle, &quot;drop table main.settings&quot;, NULL, NULL, NULL);</a>
<a name="ln2025"> </a>
<a name="ln2026">  // take care of potential bad data in the db.</a>
<a name="ln2027">  _sanitize_db(db);</a>
<a name="ln2028"> </a>
<a name="ln2029">  // make sure that the tag ids in the library match the ones in data</a>
<a name="ln2030">  if(!_synchronize_tags(db))</a>
<a name="ln2031">  {</a>
<a name="ln2032">    fprintf(stderr, &quot;[init] couldn't synchronize tags between library and data. aborting\n&quot;);</a>
<a name="ln2033">    dt_database_destroy(db);</a>
<a name="ln2034">    db = NULL;</a>
<a name="ln2035">    goto error;</a>
<a name="ln2036">  }</a>
<a name="ln2037"> </a>
<a name="ln2038">error:</a>
<a name="ln2039">  g_free(dbname);</a>
<a name="ln2040"> </a>
<a name="ln2041">  return db;</a>
<a name="ln2042">}</a>
<a name="ln2043"> </a>
<a name="ln2044">void dt_database_destroy(const dt_database_t *db)</a>
<a name="ln2045">{</a>
<a name="ln2046">  sqlite3_close(db-&gt;handle);</a>
<a name="ln2047">  if (db-&gt;lockfile_data)</a>
<a name="ln2048">  {</a>
<a name="ln2049">    g_unlink(db-&gt;lockfile_data);</a>
<a name="ln2050">    g_free(db-&gt;lockfile_data);</a>
<a name="ln2051">  }</a>
<a name="ln2052">  if (db-&gt;lockfile_library)</a>
<a name="ln2053">  {</a>
<a name="ln2054">    g_unlink(db-&gt;lockfile_library);</a>
<a name="ln2055">    g_free(db-&gt;lockfile_library);</a>
<a name="ln2056">  }</a>
<a name="ln2057">  g_free(db-&gt;dbfilename_data);</a>
<a name="ln2058">  g_free(db-&gt;dbfilename_library);</a>
<a name="ln2059">  g_free((dt_database_t *)db);</a>
<a name="ln2060"> </a>
<a name="ln2061">  sqlite3_shutdown();</a>
<a name="ln2062">}</a>
<a name="ln2063"> </a>
<a name="ln2064">sqlite3 *dt_database_get(const dt_database_t *db)</a>
<a name="ln2065">{</a>
<a name="ln2066">  return db ? db-&gt;handle : NULL;</a>
<a name="ln2067">}</a>
<a name="ln2068"> </a>
<a name="ln2069">const gchar *dt_database_get_path(const struct dt_database_t *db)</a>
<a name="ln2070">{</a>
<a name="ln2071">  return db-&gt;dbfilename_library;</a>
<a name="ln2072">}</a>
<a name="ln2073"> </a>
<a name="ln2074">static void _database_migrate_to_xdg_structure()</a>
<a name="ln2075">{</a>
<a name="ln2076">  gchar dbfilename[PATH_MAX] = { 0 };</a>
<a name="ln2077">  gchar *conf_db = dt_conf_get_string(&quot;database&quot;);</a>
<a name="ln2078"> </a>
<a name="ln2079">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln2080">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln2081"> </a>
<a name="ln2082">  if(conf_db &amp;&amp; conf_db[0] != '/')</a>
<a name="ln2083">  {</a>
<a name="ln2084">    char *homedir = getenv(&quot;HOME&quot;);</a>
<a name="ln2085">    snprintf(dbfilename, sizeof(dbfilename), &quot;%s/%s&quot;, homedir, conf_db);</a>
<a name="ln2086">    if(g_file_test(dbfilename, G_FILE_TEST_EXISTS))</a>
<a name="ln2087">    {</a>
<a name="ln2088">      fprintf(stderr, &quot;[init] moving database into new XDG directory structure\n&quot;);</a>
<a name="ln2089">      char destdbname[PATH_MAX] = { 0 };</a>
<a name="ln2090">      snprintf(destdbname, sizeof(dbfilename), &quot;%s/%s&quot;, datadir, &quot;library.db&quot;);</a>
<a name="ln2091">      if(!g_file_test(destdbname, G_FILE_TEST_EXISTS))</a>
<a name="ln2092">      {</a>
<a name="ln2093">        rename(dbfilename, destdbname);</a>
<a name="ln2094">        dt_conf_set_string(&quot;database&quot;, &quot;library.db&quot;);</a>
<a name="ln2095">      }</a>
<a name="ln2096">    }</a>
<a name="ln2097">  }</a>
<a name="ln2098"> </a>
<a name="ln2099">  g_free(conf_db);</a>
<a name="ln2100">}</a>
<a name="ln2101"> </a>
<a name="ln2102">/* delete old mipmaps files */</a>
<a name="ln2103">static void _database_delete_mipmaps_files()</a>
<a name="ln2104">{</a>
<a name="ln2105">  /* This migration is intended to be run only from 0.9.x to new cache in 1.0 */</a>
<a name="ln2106"> </a>
<a name="ln2107">  // Directory</a>
<a name="ln2108">  char cachedir[PATH_MAX] = { 0 }, mipmapfilename[PATH_MAX] = { 0 };</a>
<a name="ln2109">  dt_loc_get_user_cache_dir(cachedir, sizeof(cachedir));</a>
<a name="ln2110"> </a>
<a name="ln2111">  snprintf(mipmapfilename, sizeof(mipmapfilename), &quot;%s/mipmaps&quot;, cachedir);</a>
<a name="ln2112"> </a>
<a name="ln2113">  if(access(mipmapfilename, F_OK) != -1)</a>
<a name="ln2114">  {</a>
<a name="ln2115">    fprintf(stderr, &quot;[mipmap_cache] dropping old version file: %s\n&quot;, mipmapfilename);</a>
<a name="ln2116">    g_unlink(mipmapfilename);</a>
<a name="ln2117"> </a>
<a name="ln2118">    snprintf(mipmapfilename, sizeof(mipmapfilename), &quot;%s/mipmaps.fallback&quot;, cachedir);</a>
<a name="ln2119"> </a>
<a name="ln2120">    if(access(mipmapfilename, F_OK) != -1) g_unlink(mipmapfilename);</a>
<a name="ln2121">  }</a>
<a name="ln2122">}</a>
<a name="ln2123"> </a>
<a name="ln2124">gboolean dt_database_get_lock_acquired(const dt_database_t *db)</a>
<a name="ln2125">{</a>
<a name="ln2126">  return db-&gt;lock_acquired;</a>
<a name="ln2127">}</a>
<a name="ln2128"> </a>
<a name="ln2129">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2130">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2131">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1643"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'g_strdup_printf' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
