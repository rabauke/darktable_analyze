
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;control/conf.h&quot;</a>
<a name="ln22">#include &quot;control/control.h&quot;</a>
<a name="ln23">#include &quot;develop/blend.h&quot;</a>
<a name="ln24">#include &quot;develop/imageop.h&quot;</a>
<a name="ln25">#include &quot;develop/masks.h&quot;</a>
<a name="ln26">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln27">#include &quot;gui/gtk.h&quot;</a>
<a name="ln28">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln29">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln30">#include &lt;stdlib.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">// this is the version of the modules parameters,</a>
<a name="ln34">// and includes version information about compile-time dt</a>
<a name="ln35">DT_MODULE_INTROSPECTION(2, dt_iop_spots_params_t)</a>
<a name="ln36"> </a>
<a name="ln37">typedef struct dt_iop_spots_params_t</a>
<a name="ln38">{</a>
<a name="ln39">  int clone_id[64];</a>
<a name="ln40">  int clone_algo[64];</a>
<a name="ln41">} dt_iop_spots_params_t;</a>
<a name="ln42"> </a>
<a name="ln43">typedef struct dt_iop_spots_gui_data_t</a>
<a name="ln44">{</a>
<a name="ln45">  GtkLabel *label;</a>
<a name="ln46">  GtkWidget *bt_path, *bt_circle, *bt_ellipse;</a>
<a name="ln47">} dt_iop_spots_gui_data_t;</a>
<a name="ln48"> </a>
<a name="ln49">typedef struct dt_iop_spots_params_t dt_iop_spots_data_t;</a>
<a name="ln50"> </a>
<a name="ln51"> </a>
<a name="ln52">// this returns a translatable name</a>
<a name="ln53">const char *name()</a>
<a name="ln54">{</a>
<a name="ln55">  return _(&quot;spot removal&quot;);</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">int default_group()</a>
<a name="ln59">{</a>
<a name="ln60">  return IOP_GROUP_CORRECT;</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">int flags()</a>
<a name="ln64">{</a>
<a name="ln65">  return IOP_FLAGS_SUPPORTS_BLENDING | IOP_FLAGS_NO_MASKS;</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln69">                  void *new_params, const int new_version)</a>
<a name="ln70">{</a>
<a name="ln71">  if(old_version == 1 &amp;&amp; new_version == 2)</a>
<a name="ln72">  {</a>
<a name="ln73">    typedef struct dt_iop_spots_v1_t</a>
<a name="ln74">    {</a>
<a name="ln75">      float x, y;</a>
<a name="ln76">      float xc, yc;</a>
<a name="ln77">      float radius;</a>
<a name="ln78">    } dt_iop_spots_v1_t;</a>
<a name="ln79">    typedef struct dt_iop_spots_params_v1_t</a>
<a name="ln80">    {</a>
<a name="ln81">      int num_spots;</a>
<a name="ln82">      dt_iop_spots_v1_t spot[32];</a>
<a name="ln83">    } dt_iop_spots_params_v1_t;</a>
<a name="ln84"> </a>
<a name="ln85">    dt_iop_spots_params_v1_t *o = (dt_iop_spots_params_v1_t *)old_params;</a>
<a name="ln86">    dt_iop_spots_params_t *n = (dt_iop_spots_params_t *)new_params;</a>
<a name="ln87">    dt_iop_spots_params_t *d = (dt_iop_spots_params_t *)self-&gt;default_params;</a>
<a name="ln88"> </a>
<a name="ln89">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln90">    for(int i = 0; i &lt; o-&gt;num_spots; i++)</a>
<a name="ln91">    {</a>
<a name="ln92">      // we have to register a new circle mask</a>
<a name="ln93">      dt_masks_form_t *form = dt_masks_create(DT_MASKS_CIRCLE | DT_MASKS_CLONE);</a>
<a name="ln94"> </a>
<a name="ln95">      // spots v1 was before raw orientation changes</a>
<a name="ln96">      form-&gt;version = 1;</a>
<a name="ln97"> </a>
<a name="ln98">      dt_masks_point_circle_t *circle = (dt_masks_point_circle_t *)(malloc(sizeof(dt_masks_point_circle_t)));</a>
<a name="ln99">      circle-&gt;center[0] = o-&gt;spot[i].x;</a>
<a name="ln100">      circle-&gt;center[1] = o-&gt;spot[i].y;</a>
<a name="ln101">      circle-&gt;radius = o-&gt;spot[i].radius;</a>
<a name="ln102">      circle-&gt;border = 0.0f;</a>
<a name="ln103">      form-&gt;points = g_list_append(form-&gt;points, circle);</a>
<a name="ln104">      form-&gt;source[0] = o-&gt;spot[i].xc;</a>
<a name="ln105">      form-&gt;source[1] = o-&gt;spot[i].yc;</a>
<a name="ln106"> </a>
<a name="ln107">      // adapt for raw orientation changes</a>
<a name="ln108">      dt_masks_legacy_params(self-&gt;dev, form, form-&gt;version, dt_masks_version());</a>
<a name="ln109"> </a>
<a name="ln110">      dt_masks_gui_form_save_creation(self-&gt;dev, self, form, NULL);</a>
<a name="ln111"> </a>
<a name="ln112">      // and add it to the module params</a>
<a name="ln113">      n-&gt;clone_id[i] = form-&gt;formid;</a>
<a name="ln114">      n-&gt;clone_algo[i] = 1;</a>
<a name="ln115">    }</a>
<a name="ln116">    return 0;</a>
<a name="ln117">  }</a>
<a name="ln118">  return 1;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">static void _resynch_params(struct dt_iop_module_t *self)</a>
<a name="ln122">{</a>
<a name="ln123">  dt_iop_spots_params_t *p = (dt_iop_spots_params_t *)self-&gt;params;</a>
<a name="ln124">  dt_develop_blend_params_t *bp = self-&gt;blend_params;</a>
<a name="ln125"> </a>
<a name="ln126">  // we create 2 new buffers</a>
<a name="ln127">  int nid[64] = { 0 };</a>
<a name="ln128">  int nalgo[64] = { 2 };</a>
<a name="ln129"> </a>
<a name="ln130">  // we go through all forms in blend params</a>
<a name="ln131">  dt_masks_form_t *grp = dt_masks_get_from_id(darktable.develop, bp-&gt;mask_id);</a>
<a name="ln132">  if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln133">  {</a>
<a name="ln134">    GList *forms = g_list_first(grp-&gt;points);</a>
<a name="ln135">    int i = 0;</a>
<a name="ln136">    while((i &lt; 64) &amp;&amp; forms)</a>
<a name="ln137">    {</a>
<a name="ln138">      dt_masks_point_group_t *grpt = (dt_masks_point_group_t *)forms-&gt;data;</a>
<a name="ln139">      nid[i] = grpt-&gt;formid;</a>
<a name="ln140">      for(int j = 0; j &lt; 64; j++)</a>
<a name="ln141">      {</a>
<a name="ln142">        if(p-&gt;clone_id[j] == nid[i])</a>
<a name="ln143">        {</a>
<a name="ln144">          nalgo[i] = p-&gt;clone_algo[j];</a>
<a name="ln145">          break;</a>
<a name="ln146">        }</a>
<a name="ln147">      }</a>
<a name="ln148">      i++;</a>
<a name="ln149">      forms = g_list_next(forms);</a>
<a name="ln150">    }</a>
<a name="ln151">  }</a>
<a name="ln152"> </a>
<a name="ln153">  // we reaffect params</a>
<a name="ln154">  for(int i = 0; i &lt; 64; i++)</a>
<a name="ln155">  {</a>
<a name="ln156">    p-&gt;clone_algo[i] = nalgo[i];</a>
<a name="ln157">    p-&gt;clone_id[i] = nid[i];</a>
<a name="ln158">  }</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">static void _reset_form_creation(GtkWidget *widget, dt_iop_module_t *self)</a>
<a name="ln163">{</a>
<a name="ln164">  dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln165">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;bt_path)) ||</a>
<a name="ln166">      gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;bt_circle)) ||</a>
<a name="ln167">      gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;bt_ellipse)))</a>
<a name="ln168">  {</a>
<a name="ln169">    // we unset the creation mode</a>
<a name="ln170">    dt_masks_change_form_gui(NULL);</a>
<a name="ln171">  }</a>
<a name="ln172">  if (widget != g-&gt;bt_path) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_path), FALSE);</a>
<a name="ln173">  if (widget != g-&gt;bt_circle) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_circle), FALSE);</a>
<a name="ln174">  if (widget != g-&gt;bt_ellipse) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_ellipse), FALSE);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">static gboolean _add_path(GtkWidget *widget, GdkEventButton *e, dt_iop_module_t *self)</a>
<a name="ln178">{</a>
<a name="ln179">  _reset_form_creation(widget, self);</a>
<a name="ln180">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) return FALSE;</a>
<a name="ln181">  // we want to be sure that the iop has focus</a>
<a name="ln182">  dt_iop_request_focus(self);</a>
<a name="ln183">  // we create the new form</a>
<a name="ln184">  dt_masks_form_t *form = dt_masks_create(DT_MASKS_PATH | DT_MASKS_CLONE);</a>
<a name="ln185">  dt_masks_change_form_gui(form);</a>
<a name="ln186">  darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln187">  darktable.develop-&gt;form_gui-&gt;creation_module = self;</a>
<a name="ln188">  dt_control_queue_redraw_center();</a>
<a name="ln189">  return FALSE;</a>
<a name="ln190">}</a>
<a name="ln191">static gboolean _add_circle(GtkWidget *widget, GdkEventButton *e, dt_iop_module_t *self)</a>
<a name="ln192">{</a>
<a name="ln193">  _reset_form_creation(widget, self);</a>
<a name="ln194">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) return FALSE;</a>
<a name="ln195">  // we want to be sure that the iop has focus</a>
<a name="ln196">  dt_iop_request_focus(self);</a>
<a name="ln197">  // we create the new form</a>
<a name="ln198">  dt_masks_form_t *spot = dt_masks_create(DT_MASKS_CIRCLE | DT_MASKS_CLONE);</a>
<a name="ln199">  dt_masks_change_form_gui(spot);</a>
<a name="ln200">  darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln201">  darktable.develop-&gt;form_gui-&gt;creation_module = self;</a>
<a name="ln202">  dt_control_queue_redraw_center();</a>
<a name="ln203">  return FALSE;</a>
<a name="ln204">}</a>
<a name="ln205">static gboolean _add_ellipse(GtkWidget *widget, GdkEventButton *e, dt_iop_module_t *self)</a>
<a name="ln206">{</a>
<a name="ln207">  _reset_form_creation(widget, self);</a>
<a name="ln208">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) return FALSE;</a>
<a name="ln209">  // we want to be sure that the iop has focus</a>
<a name="ln210">  dt_iop_request_focus(self);</a>
<a name="ln211">  // we create the new form</a>
<a name="ln212">  dt_masks_form_t *spot = dt_masks_create(DT_MASKS_ELLIPSE | DT_MASKS_CLONE);</a>
<a name="ln213">  dt_masks_change_form_gui(spot);</a>
<a name="ln214">  darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln215">  darktable.develop-&gt;form_gui-&gt;creation_module = self;</a>
<a name="ln216">  dt_control_queue_redraw_center();</a>
<a name="ln217">  return FALSE;</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220"> </a>
<a name="ln221">static gboolean masks_form_is_in_roi(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln222">                                     dt_masks_form_t *form, const dt_iop_roi_t *roi_in,</a>
<a name="ln223">                                     const dt_iop_roi_t *roi_out)</a>
<a name="ln224">{</a>
<a name="ln225">  // we get the area for the form</a>
<a name="ln226">  int fl, ft, fw, fh;</a>
<a name="ln227"> </a>
<a name="ln228">  if(!dt_masks_get_area(self, piece, form, &amp;fw, &amp;fh, &amp;fl, &amp;ft)) return FALSE;</a>
<a name="ln229"> </a>
<a name="ln230">  // is the form outside of the roi?</a>
<a name="ln231">  fw *= roi_in-&gt;scale, fh *= roi_in-&gt;scale, fl *= roi_in-&gt;scale, ft *= roi_in-&gt;scale;</a>
<a name="ln232">  if(ft &gt;= roi_out-&gt;y + roi_out-&gt;height || ft + fh &lt;= roi_out-&gt;y || fl &gt;= roi_out-&gt;x + roi_out-&gt;width</a>
<a name="ln233">     || fl + fw &lt;= roi_out-&gt;x)</a>
<a name="ln234">    return FALSE;</a>
<a name="ln235"> </a>
<a name="ln236">  return TRUE;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">void modify_roi_out(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, dt_iop_roi_t *roi_out,</a>
<a name="ln240">                    const dt_iop_roi_t *roi_in)</a>
<a name="ln241">{</a>
<a name="ln242">  *roi_out = *roi_in;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">// needed if mask dest is in roi and mask src is not</a>
<a name="ln246">void modify_roi_in(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln247">                   const dt_iop_roi_t *roi_out, dt_iop_roi_t *roi_in)</a>
<a name="ln248">{</a>
<a name="ln249">  *roi_in = *roi_out;</a>
<a name="ln250"> </a>
<a name="ln251">  int roir = roi_in-&gt;width + roi_in-&gt;x;</a>
<a name="ln252">  int roib = roi_in-&gt;height + roi_in-&gt;y;</a>
<a name="ln253">  int roix = roi_in-&gt;x;</a>
<a name="ln254">  int roiy = roi_in-&gt;y;</a>
<a name="ln255"> </a>
<a name="ln256">  // dt_iop_spots_params_t *d = (dt_iop_spots_params_t *)piece-&gt;data;</a>
<a name="ln257">  dt_develop_blend_params_t *bp = self-&gt;blend_params;</a>
<a name="ln258"> </a>
<a name="ln259">  // We iterate through all spots or polygons</a>
<a name="ln260">  dt_masks_form_t *grp = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, bp-&gt;mask_id);</a>
<a name="ln261">  if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln262">  {</a>
<a name="ln263">    GList *forms = g_list_first(grp-&gt;points);</a>
<a name="ln264">    while(forms)</a>
<a name="ln265">    {</a>
<a name="ln266">      dt_masks_point_group_t *grpt = (dt_masks_point_group_t *)forms-&gt;data;</a>
<a name="ln267">      // we get the spot</a>
<a name="ln268">      dt_masks_form_t *form = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, grpt-&gt;formid);</a>
<a name="ln269">      if(form)</a>
<a name="ln270">      {</a>
<a name="ln271">        // if the form is outside the roi, we just skip it</a>
<a name="ln272">        if(!masks_form_is_in_roi(self, piece, form, roi_in, roi_out))</a>
<a name="ln273">        {</a>
<a name="ln274">          forms = g_list_next(forms);</a>
<a name="ln275">          continue;</a>
<a name="ln276">        }</a>
<a name="ln277"> </a>
<a name="ln278">        // we get the area for the source</a>
<a name="ln279">        int fl, ft, fw, fh;</a>
<a name="ln280"> </a>
<a name="ln281">        if(!dt_masks_get_source_area(self, piece, form, &amp;fw, &amp;fh, &amp;fl, &amp;ft))</a>
<a name="ln282">        {</a>
<a name="ln283">          forms = g_list_next(forms);</a>
<a name="ln284">          continue;</a>
<a name="ln285">        }</a>
<a name="ln286">        fw *= roi_in-&gt;scale, fh *= roi_in-&gt;scale, fl *= roi_in-&gt;scale, ft *= roi_in-&gt;scale;</a>
<a name="ln287"> </a>
<a name="ln288">        // we enlarge the roi if needed</a>
<a name="ln289">        roiy = fminf(ft, roiy);</a>
<a name="ln290">        roix = fminf(fl, roix);</a>
<a name="ln291">        roir = fmaxf(fl + fw, roir);</a>
<a name="ln292">        roib = fmaxf(ft + fh, roib);</a>
<a name="ln293">      }</a>
<a name="ln294">      forms = g_list_next(forms);</a>
<a name="ln295">    }</a>
<a name="ln296">  }</a>
<a name="ln297"> </a>
<a name="ln298">  // now we set the values</a>
<a name="ln299">  const float scwidth = piece-&gt;buf_in.width * roi_in-&gt;scale, scheight = piece-&gt;buf_in.height * roi_in-&gt;scale;</a>
<a name="ln300">  roi_in-&gt;x = CLAMP(roix, 0, scwidth - 1);</a>
<a name="ln301">  roi_in-&gt;y = CLAMP(roiy, 0, scheight - 1);</a>
<a name="ln302">  roi_in-&gt;width = CLAMP(roir - roi_in-&gt;x, 1, scwidth + .5f - roi_in-&gt;x);</a>
<a name="ln303">  roi_in-&gt;height = CLAMP(roib - roi_in-&gt;y, 1, scheight + .5f - roi_in-&gt;y);</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">static void masks_point_denormalize(dt_dev_pixelpipe_iop_t *piece, const dt_iop_roi_t *roi,</a>
<a name="ln307">                                    const float *points, size_t points_count, float *new)</a>
<a name="ln308">{</a>
<a name="ln309">  const float scalex = piece-&gt;pipe-&gt;iwidth * roi-&gt;scale, scaley = piece-&gt;pipe-&gt;iheight * roi-&gt;scale;</a>
<a name="ln310"> </a>
<a name="ln311">  for(size_t i = 0; i &lt; points_count * 2; i += 2)</a>
<a name="ln312">  {</a>
<a name="ln313">    new[i] = points[i] * scalex;</a>
<a name="ln314">    new[i + 1] = points[i + 1] * scaley;</a>
<a name="ln315">  }</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">static int masks_point_calc_delta(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln319">                                  const dt_iop_roi_t *roi, const float *target, const float *source, int *dx,</a>
<a name="ln320">                                  int *dy)</a>
<a name="ln321">{</a>
<a name="ln322">  float points[4];</a>
<a name="ln323">  masks_point_denormalize(piece, roi, target, 1, points);</a>
<a name="ln324">  masks_point_denormalize(piece, roi, source, 1, points + 2);</a>
<a name="ln325"> </a>
<a name="ln326">  int res = dt_dev_distort_transform_plus(self-&gt;dev, piece-&gt;pipe, 0, self-&gt;priority, points, 2);</a>
<a name="ln327">  if(!res) return res;</a>
<a name="ln328"> </a>
<a name="ln329">  *dx = points[0] - points[2];</a>
<a name="ln330">  *dy = points[1] - points[3];</a>
<a name="ln331"> </a>
<a name="ln332">  return res;</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335">static int masks_get_delta(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const dt_iop_roi_t *roi,</a>
<a name="ln336">                           dt_masks_form_t *form, int *dx, int *dy)</a>
<a name="ln337">{</a>
<a name="ln338">  int res = 0;</a>
<a name="ln339"> </a>
<a name="ln340">  if(form-&gt;type &amp; DT_MASKS_PATH)</a>
<a name="ln341">  {</a>
<a name="ln342">    dt_masks_point_path_t *pt = (dt_masks_point_path_t *)form-&gt;points-&gt;data;</a>
<a name="ln343"> </a>
<a name="ln344">    res = masks_point_calc_delta(self, piece, roi, pt-&gt;corner, form-&gt;source, dx, dy);</a>
<a name="ln345">  }</a>
<a name="ln346">  else if(form-&gt;type &amp; DT_MASKS_CIRCLE)</a>
<a name="ln347">  {</a>
<a name="ln348">    dt_masks_point_circle_t *pt = (dt_masks_point_circle_t *)form-&gt;points-&gt;data;</a>
<a name="ln349"> </a>
<a name="ln350">    res = masks_point_calc_delta(self, piece, roi, pt-&gt;center, form-&gt;source, dx, dy);</a>
<a name="ln351">  }</a>
<a name="ln352">  else if(form-&gt;type &amp; DT_MASKS_ELLIPSE)</a>
<a name="ln353">  {</a>
<a name="ln354">    dt_masks_point_ellipse_t *pt = (dt_masks_point_ellipse_t *)form-&gt;points-&gt;data;</a>
<a name="ln355"> </a>
<a name="ln356">    res = masks_point_calc_delta(self, piece, roi, pt-&gt;center, form-&gt;source, dx, dy);</a>
<a name="ln357">  }</a>
<a name="ln358"> </a>
<a name="ln359">  return res;</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">void _process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln363">              float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out, const int ch)</a>
<a name="ln364">{</a>
<a name="ln365">  dt_iop_spots_params_t *d = (dt_iop_spots_params_t *)piece-&gt;data;</a>
<a name="ln366">  dt_develop_blend_params_t *bp = self-&gt;blend_params;</a>
<a name="ln367"> </a>
<a name="ln368">// we don't modify most of the image:</a>
<a name="ln369">#ifdef _OPENMP</a>
<a name="ln370">#pragma omp parallel for schedule(static) default(none)</a>
<a name="ln371">#endif</a>
<a name="ln372">  for(int k = 0; k &lt; roi_out-&gt;height; k++)</a>
<a name="ln373">  {</a>
<a name="ln374">    float *outb = out + (size_t)ch * k * roi_out-&gt;width;</a>
<a name="ln375">    const float *inb = in + (size_t)ch * roi_in-&gt;width * (k + roi_out-&gt;y - roi_in-&gt;y)</a>
<a name="ln376">                       + ch * (roi_out-&gt;x - roi_in-&gt;x);</a>
<a name="ln377">    memcpy(outb, inb, sizeof(float) * roi_out-&gt;width * ch);</a>
<a name="ln378">  }</a>
<a name="ln379"> </a>
<a name="ln380">  // iterate through all forms</a>
<a name="ln381">  dt_masks_form_t *grp = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, bp-&gt;mask_id);</a>
<a name="ln382">  int pos = 0;</a>
<a name="ln383">  if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln384">  {</a>
<a name="ln385">    GList *forms = g_list_first(grp-&gt;points);</a>
<a name="ln386">    while((pos &lt; 64) &amp;&amp; forms)</a>
<a name="ln387">    {</a>
<a name="ln388">      dt_masks_point_group_t *grpt = (dt_masks_point_group_t *)forms-&gt;data;</a>
<a name="ln389">      // we get the spot</a>
<a name="ln390">      dt_masks_form_t *form = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, grpt-&gt;formid);</a>
<a name="ln391">      if(!form)</a>
<a name="ln392">      {</a>
<a name="ln393">        forms = g_list_next(forms);</a>
<a name="ln394">        pos++;</a>
<a name="ln395">        continue;</a>
<a name="ln396">      }</a>
<a name="ln397"> </a>
<a name="ln398">      // if the form is outside the roi, we just skip it</a>
<a name="ln399">      if(!masks_form_is_in_roi(self, piece, form, roi_in, roi_out))</a>
<a name="ln400">      {</a>
<a name="ln401">        forms = g_list_next(forms);</a>
<a name="ln402">        pos++;</a>
<a name="ln403">        continue;</a>
<a name="ln404">      }</a>
<a name="ln405"> </a>
<a name="ln406">      if(d-&gt;clone_algo[pos] == 1 &amp;&amp; (form-&gt;type &amp; DT_MASKS_CIRCLE))</a>
<a name="ln407">      {</a>
<a name="ln408">        dt_masks_point_circle_t *circle = (dt_masks_point_circle_t *)g_list_nth_data(form-&gt;points, 0);</a>
<a name="ln409"> </a>
<a name="ln410">        float points[4];</a>
<a name="ln411">        masks_point_denormalize(piece, roi_in, circle-&gt;center, 1, points);</a>
<a name="ln412">        masks_point_denormalize(piece, roi_in, form-&gt;source, 1, points + 2);</a>
<a name="ln413"> </a>
<a name="ln414">        if(!dt_dev_distort_transform_plus(self-&gt;dev, piece-&gt;pipe, 0, self-&gt;priority, points, 2))</a>
<a name="ln415">        {</a>
<a name="ln416">          forms = g_list_next(forms);</a>
<a name="ln417">          pos++;</a>
<a name="ln418">          continue;</a>
<a name="ln419">        }</a>
<a name="ln420"> </a>
<a name="ln421">        // convert from world space:</a>
<a name="ln422">        float radius10[2] = { circle-&gt;radius, circle-&gt;radius };</a>
<a name="ln423">        float radf[2];</a>
<a name="ln424">        masks_point_denormalize(piece, roi_in, radius10, 1, radf);</a>
<a name="ln425"> </a>
<a name="ln426">        const int rad = MIN(radf[0], radf[1]);</a>
<a name="ln427">        const int posx = points[0] - rad;</a>
<a name="ln428">        const int posy = points[1] - rad;</a>
<a name="ln429">        const int posx_source = points[2] - rad;</a>
<a name="ln430">        const int posy_source = points[3] - rad;</a>
<a name="ln431">        const int dx = posx - posx_source;</a>
<a name="ln432">        const int dy = posy - posy_source;</a>
<a name="ln433">        const int fw = 2 * rad, fh = 2 * rad;</a>
<a name="ln434"> </a>
<a name="ln435">        float *filter = malloc((2 * rad + 1) * sizeof(float));</a>
<a name="ln436"> </a>
<a name="ln437">        if(rad &gt; 0)</a>
<a name="ln438">        {</a>
<a name="ln439">          for(int k = -rad; k &lt;= rad; k++)</a>
<a name="ln440">          {</a>
<a name="ln441">            const float kk = 1.0f - fabsf(k / (float)rad);</a>
<a name="ln442">            filter[rad + k] = kk * kk * (3.0f - 2.0f * kk);</a>
<a name="ln443">          }</a>
<a name="ln444">        }</a>
<a name="ln445">        else</a>
<a name="ln446">        {</a>
<a name="ln447">          filter[0] = 1.0f;</a>
<a name="ln448">        }</a>
<a name="ln449"> </a>
<a name="ln450">        for(int yy = posy; yy &lt; posy + fh; yy++)</a>
<a name="ln451">        {</a>
<a name="ln452">          // we test if we are inside roi_out</a>
<a name="ln453">          if(yy &lt; roi_out-&gt;y || yy &gt;= roi_out-&gt;y + roi_out-&gt;height) continue;</a>
<a name="ln454">          // we test if the source point is inside roi_in</a>
<a name="ln455">          if(yy - dy &lt; roi_in-&gt;y || yy - dy &gt;= roi_in-&gt;y + roi_in-&gt;height) continue;</a>
<a name="ln456">          for(int xx = posx; xx &lt; posx + fw; xx++)</a>
<a name="ln457">          {</a>
<a name="ln458">            // we test if we are inside roi_out</a>
<a name="ln459">            if(xx &lt; roi_out-&gt;x || xx &gt;= roi_out-&gt;x + roi_out-&gt;width) continue;</a>
<a name="ln460">            // we test if the source point is inside roi_in</a>
<a name="ln461">            if(xx - dx &lt; roi_in-&gt;x || xx - dx &gt;= roi_in-&gt;x + roi_in-&gt;width) continue;</a>
<a name="ln462"> </a>
<a name="ln463">            const float f = filter[xx - posx + 1] * filter[yy - posy + 1];</a>
<a name="ln464">            for(int c = 0; c &lt; ch; c++)</a>
<a name="ln465">              out[ch * ((size_t)roi_out-&gt;width * (yy - roi_out-&gt;y) + xx - roi_out-&gt;x) + c]</a>
<a name="ln466">                  = out[ch * ((size_t)roi_out-&gt;width * (yy - roi_out-&gt;y) + xx - roi_out-&gt;x) + c] * (1.0f - f)</a>
<a name="ln467">                    + in[ch * ((size_t)roi_in-&gt;width * (yy - posy + posy_source - roi_in-&gt;y) + xx - posx</a>
<a name="ln468">                              + posx_source - roi_in-&gt;x) + c] * f;</a>
<a name="ln469">          }</a>
<a name="ln470">        }</a>
<a name="ln471"> </a>
<a name="ln472">        free(filter);</a>
<a name="ln473">      }</a>
<a name="ln474">      else</a>
<a name="ln475">      {</a>
<a name="ln476">        // we get the mask</a>
<a name="ln477">        float *mask = NULL;</a>
<a name="ln478">        int posx, posy, width, height;</a>
<a name="ln479">        dt_masks_get_mask(self, piece, form, &amp;mask, &amp;width, &amp;height, &amp;posx, &amp;posy);</a>
<a name="ln480">        int fts = posy * roi_in-&gt;scale, fhs = height * roi_in-&gt;scale, fls = posx * roi_in-&gt;scale,</a>
<a name="ln481">            fws = width * roi_in-&gt;scale;</a>
<a name="ln482">        int dx = 0, dy = 0;</a>
<a name="ln483"> </a>
<a name="ln484">        // now we search the delta with the source</a>
<a name="ln485">        if(!masks_get_delta(self, piece, roi_in, form, &amp;dx, &amp;dy))</a>
<a name="ln486">        {</a>
<a name="ln487">          forms = g_list_next(forms);</a>
<a name="ln488">          pos++;</a>
<a name="ln489">          free(mask);</a>
<a name="ln490"> </a>
<a name="ln491">          continue;</a>
<a name="ln492">        }</a>
<a name="ln493"> </a>
<a name="ln494">        if(dx != 0 || dy != 0)</a>
<a name="ln495">        {</a>
<a name="ln496">          // now we do the pixel clone</a>
<a name="ln497">          for(int yy = fts + 1; yy &lt; fts + fhs - 1; yy++)</a>
<a name="ln498">          {</a>
<a name="ln499">            // we test if we are inside roi_out</a>
<a name="ln500">            if(yy &lt; roi_out-&gt;y || yy &gt;= roi_out-&gt;y + roi_out-&gt;height) continue;</a>
<a name="ln501">            // we test if the source point is inside roi_in</a>
<a name="ln502">            if(yy - dy &lt; roi_in-&gt;y || yy - dy &gt;= roi_in-&gt;y + roi_in-&gt;height) continue;</a>
<a name="ln503">            for(int xx = fls + 1; xx &lt; fls + fws - 1; xx++)</a>
<a name="ln504">            {</a>
<a name="ln505">              // we test if we are inside roi_out</a>
<a name="ln506">              if(xx &lt; roi_out-&gt;x || xx &gt;= roi_out-&gt;x + roi_out-&gt;width) continue;</a>
<a name="ln507">              // we test if the source point is inside roi_in</a>
<a name="ln508">              if(xx - dx &lt; roi_in-&gt;x || xx - dx &gt;= roi_in-&gt;x + roi_in-&gt;width) continue;</a>
<a name="ln509"> </a>
<a name="ln510">              float f = mask[((int)((yy - fts) / roi_in-&gt;scale)) * width</a>
<a name="ln511">                             + (int)((xx - fls) / roi_in-&gt;scale)] * grpt-&gt;opacity;</a>
<a name="ln512"> </a>
<a name="ln513">              for(int c = 0; c &lt; ch; c++)</a>
<a name="ln514">                out[ch * ((size_t)roi_out-&gt;width * (yy - roi_out-&gt;y) + xx - roi_out-&gt;x) + c]</a>
<a name="ln515">                    = out[ch * ((size_t)roi_out-&gt;width * (yy - roi_out-&gt;y) + xx - roi_out-&gt;x) + c] * (1.0f - f)</a>
<a name="ln516">                      + in[ch * ((size_t)roi_in-&gt;width * (yy - dy - roi_in-&gt;y) + xx - dx - roi_in-&gt;x) + c] * f;</a>
<a name="ln517">            }</a>
<a name="ln518">          }</a>
<a name="ln519">        }</a>
<a name="ln520">        free(mask);</a>
<a name="ln521">      }</a>
<a name="ln522">      pos++;</a>
<a name="ln523">      forms = g_list_next(forms);</a>
<a name="ln524">    }</a>
<a name="ln525">  }</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o,</a>
<a name="ln529">             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln530">{</a>
<a name="ln531">  const float *in = (float *)i;</a>
<a name="ln532">  float *out = (float *)o;</a>
<a name="ln533">  _process(self, piece, in, out, roi_in, roi_out, piece-&gt;colors);</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">void distort_mask(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln537">                  float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln538">{</a>
<a name="ln539">  _process(self, piece, in, out, roi_in, roi_out, 1);</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">/** init, cleanup, commit to pipeline */</a>
<a name="ln543">void init(dt_iop_module_t *module)</a>
<a name="ln544">{</a>
<a name="ln545">  // we don't need global data:</a>
<a name="ln546">  module-&gt;data = NULL; // malloc(sizeof(dt_iop_spots_global_data_t));</a>
<a name="ln547">  module-&gt;params = calloc(1, sizeof(dt_iop_spots_params_t));</a>
<a name="ln548">  module-&gt;default_params = calloc(1, sizeof(dt_iop_spots_params_t));</a>
<a name="ln549">  // our module is disabled by default</a>
<a name="ln550">  // by default:</a>
<a name="ln551">  module-&gt;default_enabled = 0;</a>
<a name="ln552">  module-&gt;priority = 171; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln553">  module-&gt;params_size = sizeof(dt_iop_spots_params_t);</a>
<a name="ln554">  module-&gt;gui_data = NULL;</a>
<a name="ln555">  // init defaults:</a>
<a name="ln556">  dt_iop_spots_params_t tmp = (dt_iop_spots_params_t){ { 0 }, { 2 } };</a>
<a name="ln557"> </a>
<a name="ln558">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_spots_params_t));</a>
<a name="ln559">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_spots_params_t));</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">void cleanup(dt_iop_module_t *module)</a>
<a name="ln563">{</a>
<a name="ln564">  free(module-&gt;params);</a>
<a name="ln565">  module-&gt;params = NULL;</a>
<a name="ln566">  free(module-&gt;data); // just to be sure</a>
<a name="ln567">  module-&gt;data = NULL;</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">void gui_focus(struct dt_iop_module_t *self, gboolean in)</a>
<a name="ln571">{</a>
<a name="ln572">  // dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln573">  if(self-&gt;enabled)</a>
<a name="ln574">  {</a>
<a name="ln575">    if(in)</a>
<a name="ln576">    {</a>
<a name="ln577">      // got focus, show all shapes</a>
<a name="ln578">      dt_masks_set_edit_mode(self, DT_MASKS_EDIT_FULL);</a>
<a name="ln579">    }</a>
<a name="ln580">    else</a>
<a name="ln581">    {</a>
<a name="ln582">      // lost focus, hide all shapes</a>
<a name="ln583">      if (darktable.develop-&gt;form_gui-&gt;creation &amp;&amp; darktable.develop-&gt;form_gui-&gt;creation_module == self)</a>
<a name="ln584">        dt_masks_change_form_gui(NULL);</a>
<a name="ln585">      dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln586">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_path), FALSE);</a>
<a name="ln587">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_circle), FALSE);</a>
<a name="ln588">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_ellipse), FALSE);</a>
<a name="ln589">      dt_masks_set_edit_mode(self, DT_MASKS_EDIT_OFF);</a>
<a name="ln590">    }</a>
<a name="ln591">  }</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594">/** commit is the synch point between core and gui, so it copies params to pipe data. */</a>
<a name="ln595">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *params, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln596">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln597">{</a>
<a name="ln598">  memcpy(piece-&gt;data, params, sizeof(dt_iop_spots_params_t));</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln602">{</a>
<a name="ln603">  piece-&gt;data = malloc(sizeof(dt_iop_spots_data_t));</a>
<a name="ln604">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln608">{</a>
<a name="ln609">  free(piece-&gt;data);</a>
<a name="ln610">  piece-&gt;data = NULL;</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">/** gui callbacks, these are needed. */</a>
<a name="ln614">void gui_update(dt_iop_module_t *self)</a>
<a name="ln615">{</a>
<a name="ln616">  _resynch_params(self);</a>
<a name="ln617">  dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln618">  // update clones count</a>
<a name="ln619">  dt_masks_form_t *grp = dt_masks_get_from_id(self-&gt;dev, self-&gt;blend_params-&gt;mask_id);</a>
<a name="ln620">  guint nb = 0;</a>
<a name="ln621">  if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP)) nb = g_list_length(grp-&gt;points);</a>
<a name="ln622">  gchar *str = g_strdup_printf(&quot;%d&quot;, nb);</a>
<a name="ln623">  gtk_label_set_text(g-&gt;label, str);</a>
<a name="ln624">  g_free(str);</a>
<a name="ln625">  // update buttons status</a>
<a name="ln626">  int b1 = 0, b2 = 0, b3 = 0;</a>
<a name="ln627">  if(self-&gt;dev-&gt;form_gui &amp;&amp; self-&gt;dev-&gt;form_visible &amp;&amp; self-&gt;dev-&gt;form_gui-&gt;creation</a>
<a name="ln628">     &amp;&amp; self-&gt;dev-&gt;form_gui-&gt;creation_module == self)</a>
<a name="ln629">  {</a>
<a name="ln630">    if(self-&gt;dev-&gt;form_visible-&gt;type &amp; DT_MASKS_CIRCLE)</a>
<a name="ln631">      b1 = 1;</a>
<a name="ln632">    else if(self-&gt;dev-&gt;form_visible-&gt;type &amp; DT_MASKS_PATH)</a>
<a name="ln633">      b2 = 1;</a>
<a name="ln634">    else if(self-&gt;dev-&gt;form_visible-&gt;type &amp; DT_MASKS_ELLIPSE)</a>
<a name="ln635">      b3 = 1;</a>
<a name="ln636">  }</a>
<a name="ln637">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_circle), b1);</a>
<a name="ln638">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_path), b2);</a>
<a name="ln639">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_ellipse), b3);</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">void gui_init(dt_iop_module_t *self)</a>
<a name="ln643">{</a>
<a name="ln644">  const int bs = DT_PIXEL_APPLY_DPI(14);</a>
<a name="ln645">  self-&gt;gui_data = malloc(sizeof(dt_iop_spots_gui_data_t));</a>
<a name="ln646">  dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln647"> </a>
<a name="ln648">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln649">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln650">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln651">  GtkWidget *label = gtk_label_new(_(&quot;number of strokes:&quot;));</a>
<a name="ln652">  gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, TRUE, 0);</a>
<a name="ln653">  g-&gt;label = GTK_LABEL(gtk_label_new(&quot;-1&quot;));</a>
<a name="ln654">  gtk_widget_set_tooltip_text(hbox, _(&quot;click on a shape and drag on canvas.\nuse the mouse wheel &quot;</a>
<a name="ln655">                                      &quot;to adjust size.\nright click to remove a shape.&quot;));</a>
<a name="ln656"> </a>
<a name="ln657">  g-&gt;bt_path = dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_path, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln658">  g_signal_connect(G_OBJECT(g-&gt;bt_path), &quot;button-press-event&quot;, G_CALLBACK(_add_path), self);</a>
<a name="ln659">  gtk_widget_set_tooltip_text(g-&gt;bt_path, _(&quot;add path&quot;));</a>
<a name="ln660">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_path), FALSE);</a>
<a name="ln661">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;bt_path), bs, bs);</a>
<a name="ln662">  gtk_box_pack_end(GTK_BOX(hbox), g-&gt;bt_path, FALSE, FALSE, 0);</a>
<a name="ln663"> </a>
<a name="ln664">  g-&gt;bt_ellipse</a>
<a name="ln665">      = dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_ellipse, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln666">  g_signal_connect(G_OBJECT(g-&gt;bt_ellipse), &quot;button-press-event&quot;, G_CALLBACK(_add_ellipse), self);</a>
<a name="ln667">  gtk_widget_set_tooltip_text(g-&gt;bt_ellipse, _(&quot;add ellipse&quot;));</a>
<a name="ln668">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_ellipse), FALSE);</a>
<a name="ln669">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;bt_ellipse), bs, bs);</a>
<a name="ln670">  gtk_box_pack_end(GTK_BOX(hbox), g-&gt;bt_ellipse, FALSE, FALSE, 0);</a>
<a name="ln671"> </a>
<a name="ln672">  g-&gt;bt_circle</a>
<a name="ln673">      = dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_circle, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln674">  g_signal_connect(G_OBJECT(g-&gt;bt_circle), &quot;button-press-event&quot;, G_CALLBACK(_add_circle), self);</a>
<a name="ln675">  gtk_widget_set_tooltip_text(g-&gt;bt_circle, _(&quot;add circle&quot;));</a>
<a name="ln676">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_circle), FALSE);</a>
<a name="ln677">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;bt_circle), bs, bs);</a>
<a name="ln678">  gtk_box_pack_end(GTK_BOX(hbox), g-&gt;bt_circle, FALSE, FALSE, 0);</a>
<a name="ln679"> </a>
<a name="ln680">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(g-&gt;label), FALSE, TRUE, 0);</a>
<a name="ln681">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), hbox, TRUE, TRUE, 0);</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">void gui_reset(struct dt_iop_module_t *self)</a>
<a name="ln685">{</a>
<a name="ln686">  // hide the previous masks</a>
<a name="ln687">  dt_masks_reset_form_gui();</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690">void gui_cleanup(dt_iop_module_t *self)</a>
<a name="ln691">{</a>
<a name="ln692">  // dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln693">  // nothing else necessary, gtk will clean up the labels</a>
<a name="ln694"> </a>
<a name="ln695">  free(self-&gt;gui_data);</a>
<a name="ln696">  self-&gt;gui_data = NULL;</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">void init_key_accels (dt_iop_module_so_t *module)</a>
<a name="ln700">{</a>
<a name="ln701">  dt_accel_register_iop (module, TRUE, NC_(&quot;accel&quot;, &quot;spot circle tool&quot;),   0, 0);</a>
<a name="ln702">  dt_accel_register_iop (module, TRUE, NC_(&quot;accel&quot;, &quot;spot elipse tool&quot;),   0, 0);</a>
<a name="ln703">  dt_accel_register_iop (module, TRUE, NC_(&quot;accel&quot;, &quot;spot path tool&quot;),     0, 0);</a>
<a name="ln704">  dt_accel_register_iop (module, TRUE, NC_(&quot;accel&quot;, &quot;spot show or hide&quot;),  0, 0);</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707">static gboolean _add_circle_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln708">                                      GdkModifierType modifier, gpointer data)</a>
<a name="ln709">{</a>
<a name="ln710">  dt_iop_module_t *module = (dt_iop_module_t *)data;</a>
<a name="ln711">  const dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln712">  _add_circle(GTK_WIDGET(g-&gt;bt_circle), NULL, module);</a>
<a name="ln713">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_circle), TRUE);</a>
<a name="ln714">  return TRUE;</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">static gboolean _add_ellipse_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln718">                                       GdkModifierType modifier, gpointer data)</a>
<a name="ln719">{</a>
<a name="ln720">  dt_iop_module_t *module = (dt_iop_module_t *)data;</a>
<a name="ln721">  const dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln722">  _add_ellipse(GTK_WIDGET(g-&gt;bt_ellipse), NULL, module);</a>
<a name="ln723">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_ellipse), TRUE);</a>
<a name="ln724">  return TRUE;</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">static gboolean _add_path_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln728">                                    GdkModifierType modifier, gpointer data)</a>
<a name="ln729">{</a>
<a name="ln730">  dt_iop_module_t *module = (dt_iop_module_t *)data;</a>
<a name="ln731">  const dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln732">  _add_path(GTK_WIDGET(g-&gt;bt_path), NULL, module);</a>
<a name="ln733">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_path), TRUE);</a>
<a name="ln734">  return TRUE;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">static gboolean _show_hide_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln738">                                     GdkModifierType modifier, gpointer data)</a>
<a name="ln739">{</a>
<a name="ln740">  dt_iop_module_t *module = (dt_iop_module_t *)data;</a>
<a name="ln741">  dt_masks_set_edit_mode(module, module-&gt;dev-&gt;form_gui-&gt;edit_mode == DT_MASKS_EDIT_FULL ? DT_MASKS_EDIT_OFF : DT_MASKS_EDIT_FULL);</a>
<a name="ln742">  return TRUE;</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745">void connect_key_accels (dt_iop_module_t *module)</a>
<a name="ln746">{</a>
<a name="ln747">  GClosure *closure;</a>
<a name="ln748"> </a>
<a name="ln749">  closure = g_cclosure_new(G_CALLBACK(_add_circle_key_accel), (gpointer)module, NULL);</a>
<a name="ln750">  dt_accel_connect_iop (module, &quot;spot circle tool&quot;, closure);</a>
<a name="ln751"> </a>
<a name="ln752">  closure = g_cclosure_new(G_CALLBACK(_add_ellipse_key_accel), (gpointer)module, NULL);</a>
<a name="ln753">  dt_accel_connect_iop (module, &quot;spot elipse tool&quot;, closure);</a>
<a name="ln754"> </a>
<a name="ln755">  closure = g_cclosure_new(G_CALLBACK(_add_path_key_accel), (gpointer)module, NULL);</a>
<a name="ln756">  dt_accel_connect_iop (module, &quot;spot path tool&quot;, closure);</a>
<a name="ln757"> </a>
<a name="ln758">  closure = g_cclosure_new(G_CALLBACK(_show_hide_key_accel), (gpointer)module, NULL);</a>
<a name="ln759">  dt_accel_connect_iop (module, &quot;spot show or hide&quot;, closure);</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln763">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln764">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="99"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'circle'. Check lines: 99, 98.</p></div>
<div class="balloon" rel="128"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1009/" target="_blank">V1009</a> Check the array initialization. Only the first element is initialized explicitly. The rest elements are initialized with zeros.</p></div>
<div class="balloon" rel="442"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'filter'. Check lines: 442, 435.</p></div>
<div class="balloon" rel="558"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 558, 547.</p></div>
<div class="balloon" rel="559"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 559, 548.</p></div>
<div class="balloon" rel="653"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 653, 645.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
