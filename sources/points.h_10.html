
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4">    copyright (c) 2015 johannes hanika</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#pragma once</a>
<a name="ln21"> </a>
<a name="ln22">#ifndef __SSE2__</a>
<a name="ln23"> </a>
<a name="ln24">#if !defined _XOPEN_SOURCE &amp;&amp; !defined(__DragonFly__) &amp;&amp; !defined(__FreeBSD__) &amp;&amp; !defined(__NetBSD__)       \</a>
<a name="ln25">    &amp;&amp; !defined(__OpenBSD__) &amp;&amp; !defined(_WIN32)</a>
<a name="ln26">#define _XOPEN_SOURCE</a>
<a name="ln27">#endif</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;stdlib.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">// xorshift128+, period 2^128-1, apparently passes all TestU01 suite tests.</a>
<a name="ln32">typedef struct dt_points_state_t</a>
<a name="ln33">{</a>
<a name="ln34">  uint64_t state0;</a>
<a name="ln35">  uint64_t state1;</a>
<a name="ln36">} dt_points_state_t;</a>
<a name="ln37"> </a>
<a name="ln38">typedef struct dt_points_t</a>
<a name="ln39">{</a>
<a name="ln40">  dt_points_state_t *s;</a>
<a name="ln41">} dt_points_t;</a>
<a name="ln42"> </a>
<a name="ln43">static inline void dt_points_init(dt_points_t *p, const unsigned int num_threads)</a>
<a name="ln44">{</a>
<a name="ln45">  p-&gt;s = (dt_points_state_t *)malloc(sizeof(dt_points_state_t) * num_threads);</a>
<a name="ln46">  for(int k = 0; k &lt; num_threads; k++)</a>
<a name="ln47">  {</a>
<a name="ln48">    p-&gt;s[k].state0 = 1 + k;</a>
<a name="ln49">    p-&gt;s[k].state1 = 2 + k;</a>
<a name="ln50">  }</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53">static inline void dt_points_cleanup(dt_points_t *p)</a>
<a name="ln54">{</a>
<a name="ln55">  free(p-&gt;s);</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">static inline float dt_points_get_for(dt_points_t *p, const unsigned int thread_num)</a>
<a name="ln59">{</a>
<a name="ln60">  uint64_t s1 = p-&gt;s[thread_num].state0;</a>
<a name="ln61">  uint64_t s0 = p-&gt;s[thread_num].state1;</a>
<a name="ln62">  p-&gt;s[thread_num].state0 = s0;</a>
<a name="ln63">  s1 ^= s1 &lt;&lt; 23;</a>
<a name="ln64">  s1 ^= s1 &gt;&gt; 17;</a>
<a name="ln65">  s1 ^= s0;</a>
<a name="ln66">  s1 ^= s0 &gt;&gt; 26;</a>
<a name="ln67">  p-&gt;s[thread_num].state1 = s1;</a>
<a name="ln68">  // return (state0 + state1) / ((double)((uint64_t)-1) + 1.0);</a>
<a name="ln69">  union {</a>
<a name="ln70">      float f;</a>
<a name="ln71">      uint32_t u;</a>
<a name="ln72">  } v;</a>
<a name="ln73">  v.u = 0x3f800000 |</a>
<a name="ln74">      ((p-&gt;s[thread_num].state0 + p-&gt;s[thread_num].state1) &gt;&gt; 41); // faster than double version.</a>
<a name="ln75">  return v.f - 1.0f;</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78">static inline float dt_points_get()</a>
<a name="ln79">{</a>
<a name="ln80">  return dt_points_get_for(darktable.points, dt_get_thread_num());</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">#else</a>
<a name="ln84"> </a>
<a name="ln85">#if defined(__SSE__)</a>
<a name="ln86">#include &lt;xmmintrin.h&gt;</a>
<a name="ln87">#endif</a>
<a name="ln88">#include &lt;inttypes.h&gt;</a>
<a name="ln89"> </a>
<a name="ln90">#define MEXP 19937</a>
<a name="ln91"> </a>
<a name="ln92">#ifndef SFMT_PARAMS_H</a>
<a name="ln93">#define SFMT_PARAMS_H</a>
<a name="ln94"> </a>
<a name="ln95">#if !defined(MEXP)</a>
<a name="ln96">#ifdef __GNUC__</a>
<a name="ln97">#warning &quot;MEXP is not defined. I assume MEXP is 19937.&quot;</a>
<a name="ln98">#endif</a>
<a name="ln99">#define MEXP 19937</a>
<a name="ln100">#endif</a>
<a name="ln101">/*-----------------</a>
<a name="ln102">  BASIC DEFINITIONS</a>
<a name="ln103">  -----------------*/</a>
<a name="ln104">/** Mersenne Exponent. The period of the sequence</a>
<a name="ln105"> *  is a multiple of 2^MEXP-1.</a>
<a name="ln106"> * #define MEXP 19937 */</a>
<a name="ln107">/** SFMT generator has an internal state array of 128-bit integers,</a>
<a name="ln108"> * and N is its size. */</a>
<a name="ln109">#define N (MEXP / 128 + 1)</a>
<a name="ln110">/** N32 is the size of internal state array when regarded as an array</a>
<a name="ln111"> * of 32-bit integers.*/</a>
<a name="ln112">#define N32 (N * 4)</a>
<a name="ln113">/** N64 is the size of internal state array when regarded as an array</a>
<a name="ln114"> * of 64-bit integers.*/</a>
<a name="ln115">#define N64 (N * 2)</a>
<a name="ln116"> </a>
<a name="ln117">/*----------------------</a>
<a name="ln118">  the parameters of SFMT</a>
<a name="ln119">  following definitions are in paramsXXXX.h file.</a>
<a name="ln120">  ----------------------*/</a>
<a name="ln121">/** the pick up position of the array.</a>
<a name="ln122">#define POS1 122</a>
<a name="ln123">*/</a>
<a name="ln124"> </a>
<a name="ln125">/** the parameter of shift left as four 32-bit registers.</a>
<a name="ln126">#define SL1 18</a>
<a name="ln127"> */</a>
<a name="ln128"> </a>
<a name="ln129">/** the parameter of shift left as one 128-bit register.</a>
<a name="ln130"> * The 128-bit integer is shifted by (SL2 * 8) bits.</a>
<a name="ln131">#define SL2 1</a>
<a name="ln132">*/</a>
<a name="ln133"> </a>
<a name="ln134">/** the parameter of shift right as four 32-bit registers.</a>
<a name="ln135">#define SR1 11</a>
<a name="ln136">*/</a>
<a name="ln137"> </a>
<a name="ln138">/** the parameter of shift right as one 128-bit register.</a>
<a name="ln139"> * The 128-bit integer is shifted by (SL2 * 8) bits.</a>
<a name="ln140">#define SR2 1</a>
<a name="ln141">*/</a>
<a name="ln142"> </a>
<a name="ln143">/** A bitmask, used in the recursion.  These parameters are introduced</a>
<a name="ln144"> * to break symmetry of SIMD.</a>
<a name="ln145">#define MSK1 0xdfffffefU</a>
<a name="ln146">#define MSK2 0xddfecb7fU</a>
<a name="ln147">#define MSK3 0xbffaffffU</a>
<a name="ln148">#define MSK4 0xbffffff6U</a>
<a name="ln149">*/</a>
<a name="ln150"> </a>
<a name="ln151">/** These definitions are part of a 128-bit period certification vector.</a>
<a name="ln152">#define PARITY1 0x00000001U</a>
<a name="ln153">#define PARITY2 0x00000000U</a>
<a name="ln154">#define PARITY3 0x00000000U</a>
<a name="ln155">#define PARITY4 0xc98e126aU</a>
<a name="ln156">*/</a>
<a name="ln157"> </a>
<a name="ln158">#if 0</a>
<a name="ln159">#if MEXP == 607</a>
<a name="ln160">#include &quot;SFMT-params607.h&quot;</a>
<a name="ln161">#elif MEXP == 1279</a>
<a name="ln162">#include &quot;SFMT-params1279.h&quot;</a>
<a name="ln163">#elif MEXP == 2281</a>
<a name="ln164">#include &quot;SFMT-params2281.h&quot;</a>
<a name="ln165">#elif MEXP == 4253</a>
<a name="ln166">#include &quot;SFMT-params4253.h&quot;</a>
<a name="ln167">#elif MEXP == 11213</a>
<a name="ln168">#include &quot;SFMT-params11213.h&quot;</a>
<a name="ln169">#elif MEXP == 19937</a>
<a name="ln170">#include &quot;SFMT-params19937.h&quot;</a>
<a name="ln171">#elif MEXP == 44497</a>
<a name="ln172">#include &quot;SFMT-params44497.h&quot;</a>
<a name="ln173">#elif MEXP == 86243</a>
<a name="ln174">#include &quot;SFMT-params86243.h&quot;</a>
<a name="ln175">#elif MEXP == 132049</a>
<a name="ln176">#include &quot;SFMT-params132049.h&quot;</a>
<a name="ln177">#elif MEXP == 216091</a>
<a name="ln178">#include &quot;SFMT-params216091.h&quot;</a>
<a name="ln179">#else</a>
<a name="ln180">#ifdef __GNUC__</a>
<a name="ln181">#error &quot;MEXP is not valid.&quot;</a>
<a name="ln182">#undef MEXP</a>
<a name="ln183">#else</a>
<a name="ln184">#undef MEXP</a>
<a name="ln185">#endif</a>
<a name="ln186">#endif</a>
<a name="ln187"> </a>
<a name="ln188">#endif</a>
<a name="ln189"> </a>
<a name="ln190">#endif /* SFMT_PARAMS_H */</a>
<a name="ln191"> </a>
<a name="ln192">#ifndef SFMT_PARAMS19937_H</a>
<a name="ln193">#define SFMT_PARAMS19937_H</a>
<a name="ln194"> </a>
<a name="ln195">#define POS1 122</a>
<a name="ln196">#define SL1 18</a>
<a name="ln197">#define SL2 1</a>
<a name="ln198">#define SR1 11</a>
<a name="ln199">#define SR2 1</a>
<a name="ln200">#define MSK1 0xdfffffefU</a>
<a name="ln201">#define MSK2 0xddfecb7fU</a>
<a name="ln202">#define MSK3 0xbffaffffU</a>
<a name="ln203">#define MSK4 0xbffffff6U</a>
<a name="ln204">#define PARITY1 0x00000001U</a>
<a name="ln205">#define PARITY2 0x00000000U</a>
<a name="ln206">#define PARITY3 0x00000000U</a>
<a name="ln207">#define PARITY4 0x13c9e684U</a>
<a name="ln208"> </a>
<a name="ln209"> </a>
<a name="ln210">#define ALTI_SL1                                                                                             \</a>
<a name="ln211">  {                                                                                                          \</a>
<a name="ln212">    SL1, SL1, SL1, SL1                                                                                       \</a>
<a name="ln213">  }</a>
<a name="ln214">#define ALTI_SR1                                                                                             \</a>
<a name="ln215">  {                                                                                                          \</a>
<a name="ln216">    SR1, SR1, SR1, SR1                                                                                       \</a>
<a name="ln217">  }</a>
<a name="ln218">#define ALTI_MSK                                                                                             \</a>
<a name="ln219">  {                                                                                                          \</a>
<a name="ln220">    MSK1, MSK2, MSK3, MSK4                                                                                   \</a>
<a name="ln221">  }</a>
<a name="ln222">#define ALTI_MSK64                                                                                           \</a>
<a name="ln223">  {                                                                                                          \</a>
<a name="ln224">    MSK2, MSK1, MSK4, MSK3                                                                                   \</a>
<a name="ln225">  }</a>
<a name="ln226">#define ALTI_SL2_PERM                                                                                        \</a>
<a name="ln227">  {                                                                                                          \</a>
<a name="ln228">    1, 2, 3, 23, 5, 6, 7, 0, 9, 10, 11, 4, 13, 14, 15, 8                                                     \</a>
<a name="ln229">  }</a>
<a name="ln230">#define ALTI_SL2_PERM64                                                                                      \</a>
<a name="ln231">  {                                                                                                          \</a>
<a name="ln232">    1, 2, 3, 4, 5, 6, 7, 31, 9, 10, 11, 12, 13, 14, 15, 0                                                    \</a>
<a name="ln233">  }</a>
<a name="ln234">#define ALTI_SR2_PERM                                                                                        \</a>
<a name="ln235">  {                                                                                                          \</a>
<a name="ln236">    7, 0, 1, 2, 11, 4, 5, 6, 15, 8, 9, 10, 17, 12, 13, 14                                                    \</a>
<a name="ln237">  }</a>
<a name="ln238">#define ALTI_SR2_PERM64                                                                                      \</a>
<a name="ln239">  {                                                                                                          \</a>
<a name="ln240">    15, 0, 1, 2, 3, 4, 5, 6, 17, 8, 9, 10, 11, 12, 13, 14                                                    \</a>
<a name="ln241">  }</a>
<a name="ln242">#define IDSTR &quot;SFMT-19937:122-18-1-11-1:dfffffef-ddfecb7f-bffaffff-bffffff6&quot;</a>
<a name="ln243"> </a>
<a name="ln244">#endif /* SFMT_PARAMS19937_H */</a>
<a name="ln245"> </a>
<a name="ln246">/** 128-bit data structure */</a>
<a name="ln247">typedef union w128_t</a>
<a name="ln248">{</a>
<a name="ln249">  __m128i si;</a>
<a name="ln250">  uint32_t u[4];</a>
<a name="ln251">} w128_t;</a>
<a name="ln252"> </a>
<a name="ln253">typedef struct sfmt_state_t</a>
<a name="ln254">{</a>
<a name="ln255">  /** the 128-bit internal state array */</a>
<a name="ln256">  w128_t sfmt[N];</a>
<a name="ln257">  /** the 32bit integer pointer to the 128-bit internal state array */</a>
<a name="ln258">  uint32_t *psfmt32;</a>
<a name="ln259">#if !defined(BIG_ENDIAN64) || defined(ONLY64)</a>
<a name="ln260">  /** the 64bit integer pointer to the 128-bit internal state array */</a>
<a name="ln261">  uint64_t *psfmt64;</a>
<a name="ln262">#endif</a>
<a name="ln263">  /** index counter to the 32-bit internal state array */</a>
<a name="ln264">  int idx;</a>
<a name="ln265">  /** a flag: it is 0 if and only if the internal state is not yet</a>
<a name="ln266">   * initialized. */</a>
<a name="ln267">  int initialized;</a>
<a name="ln268">  /** a parity check vector which certificate the period of 2^{MEXP} */</a>
<a name="ln269">  uint32_t parity[4];</a>
<a name="ln270">} sfmt_state_t;</a>
<a name="ln271"> </a>
<a name="ln272">/**</a>
<a name="ln273"> * @file SFMT.h</a>
<a name="ln274"> *</a>
<a name="ln275"> * @brief SIMD oriented Fast Mersenne Twister(SFMT) pseudorandom</a>
<a name="ln276"> * number generator</a>
<a name="ln277"> *</a>
<a name="ln278"> * @author Mutsuo Saito (Hiroshima University)</a>
<a name="ln279"> * @author Makoto Matsumoto (Hiroshima University)</a>
<a name="ln280"> *</a>
<a name="ln281"> * Copyright (C) 2006, 2007 Mutsuo Saito, Makoto Matsumoto and Hiroshima</a>
<a name="ln282"> * University. All rights reserved.</a>
<a name="ln283"> *</a>
<a name="ln284"> * The new BSD License is applied to this software.</a>
<a name="ln285"> * see LICENSE.txt</a>
<a name="ln286"> *</a>
<a name="ln287"> * @note We assume that your system has inttypes.h.  If your system</a>
<a name="ln288"> * doesn't have inttypes.h, you have to typedef uint32_t and uint64_t,</a>
<a name="ln289"> * and you have to define PRIu64 and PRIx64 in this file as follows:</a>
<a name="ln290"> * @verbatim</a>
<a name="ln291"> typedef unsigned int uint32_t</a>
<a name="ln292"> typedef unsigned long long uint64_t</a>
<a name="ln293">#define PRIu64 &quot;llu&quot;</a>
<a name="ln294">#define PRIx64 &quot;llx&quot;</a>
<a name="ln295">@endverbatim</a>
<a name="ln296"> * uint32_t must be exactly 32-bit unsigned integer type (no more, no</a>
<a name="ln297"> * less), and uint64_t must be exactly 64-bit unsigned integer type.</a>
<a name="ln298"> * PRIu64 and PRIx64 are used for printf function to print 64-bit</a>
<a name="ln299"> * unsigned int and 64-bit unsigned int in hexadecimal format.</a>
<a name="ln300"> */</a>
<a name="ln301"> </a>
<a name="ln302">#ifndef SFMT_H</a>
<a name="ln303">#define SFMT_H</a>
<a name="ln304"> </a>
<a name="ln305">#include &lt;stdio.h&gt;</a>
<a name="ln306"> </a>
<a name="ln307">#if defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901L)</a>
<a name="ln308">#include &lt;inttypes.h&gt;</a>
<a name="ln309">#elif defined(_MSC_VER) || defined(__BORLANDC__)</a>
<a name="ln310">typedef unsigned int uint32_t;</a>
<a name="ln311">typedef unsigned __int64 uint64_t;</a>
<a name="ln312">#define inline __inline</a>
<a name="ln313">#else</a>
<a name="ln314">#include &lt;inttypes.h&gt;</a>
<a name="ln315">#if defined(__GNUC__)</a>
<a name="ln316">#define inline __inline__</a>
<a name="ln317">#endif</a>
<a name="ln318">#endif</a>
<a name="ln319"> </a>
<a name="ln320">#ifndef PRIu64</a>
<a name="ln321">#if defined(_MSC_VER) || defined(__BORLANDC__)</a>
<a name="ln322">#define PRIu64 &quot;I64u&quot;</a>
<a name="ln323">#define PRIx64 &quot;I64x&quot;</a>
<a name="ln324">#else</a>
<a name="ln325">#define PRIu64 &quot;llu&quot;</a>
<a name="ln326">#define PRIx64 &quot;llx&quot;</a>
<a name="ln327">#endif</a>
<a name="ln328">#endif</a>
<a name="ln329"> </a>
<a name="ln330">#if defined(__GNUC__)</a>
<a name="ln331">#define ALWAYSINLINE __attribute__((always_inline))</a>
<a name="ln332">#else</a>
<a name="ln333">#define ALWAYSINLINE</a>
<a name="ln334">#endif</a>
<a name="ln335"> </a>
<a name="ln336">#if defined(_MSC_VER)</a>
<a name="ln337">#if _MSC_VER &gt;= 1200</a>
<a name="ln338">#define PRE_ALWAYS __forceinline</a>
<a name="ln339">#else</a>
<a name="ln340">#define PRE_ALWAYS inline</a>
<a name="ln341">#endif</a>
<a name="ln342">#else</a>
<a name="ln343">#define PRE_ALWAYS inline</a>
<a name="ln344">#endif</a>
<a name="ln345"> </a>
<a name="ln346">static inline uint32_t gen_rand32(struct sfmt_state_t *s);</a>
<a name="ln347">static inline uint64_t gen_rand64(struct sfmt_state_t *s);</a>
<a name="ln348">static inline void fill_array32(struct sfmt_state_t *s, uint32_t *array, int size) __attribute__((unused));</a>
<a name="ln349">static inline void fill_array64(struct sfmt_state_t *s, uint64_t *array, int size) __attribute__((unused));</a>
<a name="ln350">static inline void init_gen_rand(struct sfmt_state_t *s, uint32_t seed) __attribute__((unused));</a>
<a name="ln351">static inline void init_by_array(struct sfmt_state_t *s, uint32_t *init_key, int key_length)</a>
<a name="ln352">    __attribute__((unused));</a>
<a name="ln353">static inline const char *get_idstring(void) __attribute__((unused));</a>
<a name="ln354">static inline int get_min_array_size32(void) __attribute__((unused));</a>
<a name="ln355">static inline int get_min_array_size64(void) __attribute__((unused));</a>
<a name="ln356"> </a>
<a name="ln357">/* These real versions are due to Isaku Wada */</a>
<a name="ln358">/** generates a random number on [0,1]-real-interval */</a>
<a name="ln359">inline static double to_real1(uint32_t v)</a>
<a name="ln360">{</a>
<a name="ln361">  return v * (1.0 / 4294967295.0);</a>
<a name="ln362">  /* divided by 2^32-1 */</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">/** generates a random number on [0,1]-real-interval */</a>
<a name="ln366">inline static double genrand_real1(struct sfmt_state_t *s)</a>
<a name="ln367">{</a>
<a name="ln368">  return to_real1(gen_rand32(s));</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">/** generates a random number on [0,1)-real-interval */</a>
<a name="ln372">inline static double to_real2(uint32_t v)</a>
<a name="ln373">{</a>
<a name="ln374">  return v * (1.0 / 4294967296.0);</a>
<a name="ln375">  /* divided by 2^32 */</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">/** generates a random number on [0,1)-real-interval (float) */</a>
<a name="ln379">inline static float to_real2f(uint32_t v)</a>
<a name="ln380">{</a>
<a name="ln381">  union {</a>
<a name="ln382">      float f;</a>
<a name="ln383">      uint32_t u;</a>
<a name="ln384">  } x;</a>
<a name="ln385">  x.u = 0x3f800000 | (v &gt;&gt; 9); // faster than double version.</a>
<a name="ln386">  return x.f - 1.0f;</a>
<a name="ln387">  /* divided by 2^32 */</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">/** generates a random number on [0,1)-real-interval */</a>
<a name="ln391">inline static double genrand_real2(struct sfmt_state_t *s)</a>
<a name="ln392">{</a>
<a name="ln393">  return to_real2(gen_rand32(s));</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">inline static float genrand_real2f(struct sfmt_state_t *s)</a>
<a name="ln397">{</a>
<a name="ln398">  return to_real2f(gen_rand32(s));</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">/** generates a random number on (0,1)-real-interval */</a>
<a name="ln402">inline static double to_real3(uint32_t v)</a>
<a name="ln403">{</a>
<a name="ln404">  return (((double)v) + 0.5) * (1.0 / 4294967296.0);</a>
<a name="ln405">  /* divided by 2^32 */</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">/** generates a random number on (0,1)-real-interval */</a>
<a name="ln409">inline static double genrand_real3(struct sfmt_state_t *s)</a>
<a name="ln410">{</a>
<a name="ln411">  return to_real3(gen_rand32(s));</a>
<a name="ln412">}</a>
<a name="ln413">/** These real versions are due to Isaku Wada */</a>
<a name="ln414"> </a>
<a name="ln415">/** generates a random number on [0,1) with 53-bit resolution*/</a>
<a name="ln416">inline static double to_res53(uint64_t v)</a>
<a name="ln417">{</a>
<a name="ln418">  return v * (1.0 / 18446744073709551616.0L);</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">/** generates a random number on [0,1) with 53-bit resolution from two</a>
<a name="ln422"> * 32 bit integers */</a>
<a name="ln423">inline static double to_res53_mix(uint32_t x, uint32_t y)</a>
<a name="ln424">{</a>
<a name="ln425">  return to_res53(x | ((uint64_t)y &lt;&lt; 32));</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">/** generates a random number on [0,1) with 53-bit resolution</a>
<a name="ln429">*/</a>
<a name="ln430">inline static double genrand_res53(struct sfmt_state_t *s)</a>
<a name="ln431">{</a>
<a name="ln432">  return to_res53(gen_rand64(s));</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">/** generates a random number on [0,1) with 53-bit resolution</a>
<a name="ln436">  using 32bit integer.</a>
<a name="ln437">  */</a>
<a name="ln438">inline static double genrand_res53_mix(struct sfmt_state_t *s)</a>
<a name="ln439">{</a>
<a name="ln440">  uint32_t x, y;</a>
<a name="ln441"> </a>
<a name="ln442">  x = gen_rand32(s);</a>
<a name="ln443">  y = gen_rand32(s);</a>
<a name="ln444">  return to_res53_mix(x, y);</a>
<a name="ln445">}</a>
<a name="ln446">#endif</a>
<a name="ln447">/**</a>
<a name="ln448"> * @file  SFMT-sse2.h</a>
<a name="ln449"> * @brief SIMD oriented Fast Mersenne Twister(SFMT) for Intel SSE2</a>
<a name="ln450"> *</a>
<a name="ln451"> * @author Mutsuo Saito (Hiroshima University)</a>
<a name="ln452"> * @author Makoto Matsumoto (Hiroshima University)</a>
<a name="ln453"> *</a>
<a name="ln454"> * @note We assume LITTLE ENDIAN in this file</a>
<a name="ln455"> *</a>
<a name="ln456"> * Copyright (C) 2006, 2007 Mutsuo Saito, Makoto Matsumoto and Hiroshima</a>
<a name="ln457"> * University. All rights reserved.</a>
<a name="ln458"> *</a>
<a name="ln459"> * The new BSD License is applied to this software, see LICENSE.txt</a>
<a name="ln460"> */</a>
<a name="ln461"> </a>
<a name="ln462">#ifndef SFMT_SSE2_H</a>
<a name="ln463">#define SFMT_SSE2_H</a>
<a name="ln464"> </a>
<a name="ln465">PRE_ALWAYS static __m128i mm_recursion(__m128i *a, __m128i *b, __m128i c, __m128i d,</a>
<a name="ln466">                                       __m128i mask) ALWAYSINLINE;</a>
<a name="ln467"> </a>
<a name="ln468">/**</a>
<a name="ln469"> * This function represents the recursion formula.</a>
<a name="ln470"> * @param a a 128-bit part of the internal state array</a>
<a name="ln471"> * @param b a 128-bit part of the internal state array</a>
<a name="ln472"> * @param c a 128-bit part of the internal state array</a>
<a name="ln473"> * @param d a 128-bit part of the internal state array</a>
<a name="ln474"> * @param mask 128-bit mask</a>
<a name="ln475"> * @return output</a>
<a name="ln476"> */</a>
<a name="ln477">PRE_ALWAYS static __m128i mm_recursion(__m128i *a, __m128i *b, __m128i c, __m128i d, __m128i mask)</a>
<a name="ln478">{</a>
<a name="ln479">  __m128i v, x, y, z;</a>
<a name="ln480"> </a>
<a name="ln481">  x = _mm_load_si128(a);</a>
<a name="ln482">  y = _mm_srli_epi32(*b, SR1);</a>
<a name="ln483">  z = _mm_srli_si128(c, SR2);</a>
<a name="ln484">  v = _mm_slli_epi32(d, SL1);</a>
<a name="ln485">  z = _mm_xor_si128(z, x);</a>
<a name="ln486">  z = _mm_xor_si128(z, v);</a>
<a name="ln487">  x = _mm_slli_si128(x, SL2);</a>
<a name="ln488">  y = _mm_and_si128(y, mask);</a>
<a name="ln489">  z = _mm_xor_si128(z, x);</a>
<a name="ln490">  z = _mm_xor_si128(z, y);</a>
<a name="ln491">  return z;</a>
<a name="ln492">}</a>
<a name="ln493"> </a>
<a name="ln494">/**</a>
<a name="ln495"> * This function fills the internal state array with pseudorandom</a>
<a name="ln496"> * integers.</a>
<a name="ln497"> */</a>
<a name="ln498">inline static void gen_rand_all(struct sfmt_state_t *s)</a>
<a name="ln499">{</a>
<a name="ln500">  int i;</a>
<a name="ln501">  __m128i r, r1, r2, mask;</a>
<a name="ln502">  mask = _mm_set_epi32(MSK4, MSK3, MSK2, MSK1);</a>
<a name="ln503"> </a>
<a name="ln504">  r1 = _mm_load_si128(&amp;(s-&gt;sfmt[N - 2].si));</a>
<a name="ln505">  r2 = _mm_load_si128(&amp;(s-&gt;sfmt[N - 1].si));</a>
<a name="ln506">  for(i = 0; i &lt; N - POS1; i++)</a>
<a name="ln507">  {</a>
<a name="ln508">    r = mm_recursion(&amp;(s-&gt;sfmt[i].si), &amp;(s-&gt;sfmt[i + POS1].si), r1, r2, mask);</a>
<a name="ln509">    _mm_store_si128(&amp;(s-&gt;sfmt[i].si), r);</a>
<a name="ln510">    r1 = r2;</a>
<a name="ln511">    r2 = r;</a>
<a name="ln512">  }</a>
<a name="ln513">  for(; i &lt; N; i++)</a>
<a name="ln514">  {</a>
<a name="ln515">    r = mm_recursion(&amp;(s-&gt;sfmt[i].si), &amp;(s-&gt;sfmt[i + POS1 - N].si), r1, r2, mask);</a>
<a name="ln516">    _mm_store_si128(&amp;(s-&gt;sfmt[i].si), r);</a>
<a name="ln517">    r1 = r2;</a>
<a name="ln518">    r2 = r;</a>
<a name="ln519">  }</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">/**</a>
<a name="ln523"> * This function fills the user-specified array with pseudorandom</a>
<a name="ln524"> * integers.</a>
<a name="ln525"> *</a>
<a name="ln526"> * @param array an 128-bit array to be filled by pseudorandom numbers.</a>
<a name="ln527"> * @param size number of 128-bit pesudorandom numbers to be generated.</a>
<a name="ln528"> */</a>
<a name="ln529">inline static void gen_rand_array(struct sfmt_state_t *s, w128_t *array, int size)</a>
<a name="ln530">{</a>
<a name="ln531">  int i, j;</a>
<a name="ln532">  __m128i r, r1, r2, mask;</a>
<a name="ln533">  mask = _mm_set_epi32(MSK4, MSK3, MSK2, MSK1);</a>
<a name="ln534"> </a>
<a name="ln535">  r1 = _mm_load_si128(&amp;(s-&gt;sfmt[N - 2].si));</a>
<a name="ln536">  r2 = _mm_load_si128(&amp;(s-&gt;sfmt[N - 1].si));</a>
<a name="ln537">  for(i = 0; i &lt; N - POS1; i++)</a>
<a name="ln538">  {</a>
<a name="ln539">    r = mm_recursion(&amp;(s-&gt;sfmt[i].si), &amp;(s-&gt;sfmt[i + POS1].si), r1, r2, mask);</a>
<a name="ln540">    _mm_store_si128(&amp;array[i].si, r);</a>
<a name="ln541">    r1 = r2;</a>
<a name="ln542">    r2 = r;</a>
<a name="ln543">  }</a>
<a name="ln544">  for(; i &lt; N; i++)</a>
<a name="ln545">  {</a>
<a name="ln546">    r = mm_recursion(&amp;(s-&gt;sfmt[i].si), &amp;array[i + POS1 - N].si, r1, r2, mask);</a>
<a name="ln547">    _mm_store_si128(&amp;array[i].si, r);</a>
<a name="ln548">    r1 = r2;</a>
<a name="ln549">    r2 = r;</a>
<a name="ln550">  }</a>
<a name="ln551">  /* main loop */</a>
<a name="ln552">  for(; i &lt; size - N; i++)</a>
<a name="ln553">  {</a>
<a name="ln554">    r = mm_recursion(&amp;array[i - N].si, &amp;array[i + POS1 - N].si, r1, r2, mask);</a>
<a name="ln555">    _mm_store_si128(&amp;array[i].si, r);</a>
<a name="ln556">    r1 = r2;</a>
<a name="ln557">    r2 = r;</a>
<a name="ln558">  }</a>
<a name="ln559">  for(j = 0; j &lt; 2 * N - size; j++)</a>
<a name="ln560">  {</a>
<a name="ln561">    r = _mm_load_si128(&amp;array[j + size - N].si);</a>
<a name="ln562">    _mm_store_si128(&amp;(s-&gt;sfmt[j].si), r);</a>
<a name="ln563">  }</a>
<a name="ln564">  for(; i &lt; size; i++)</a>
<a name="ln565">  {</a>
<a name="ln566">    r = mm_recursion(&amp;array[i - N].si, &amp;array[i + POS1 - N].si, r1, r2, mask);</a>
<a name="ln567">    _mm_store_si128(&amp;array[i].si, r);</a>
<a name="ln568">    _mm_store_si128(&amp;(s-&gt;sfmt[j++].si), r);</a>
<a name="ln569">    r1 = r2;</a>
<a name="ln570">    r2 = r;</a>
<a name="ln571">  }</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574">#endif</a>
<a name="ln575">/**</a>
<a name="ln576"> * @file  SFMT.c</a>
<a name="ln577"> * @brief SIMD oriented Fast Mersenne Twister(SFMT)</a>
<a name="ln578"> *</a>
<a name="ln579"> * @author Mutsuo Saito (Hiroshima University)</a>
<a name="ln580"> * @author Makoto Matsumoto (Hiroshima University)</a>
<a name="ln581"> *</a>
<a name="ln582"> * Copyright (C) 2006,2007 Mutsuo Saito, Makoto Matsumoto and Hiroshima</a>
<a name="ln583"> * University. All rights reserved.</a>
<a name="ln584"> *</a>
<a name="ln585"> * The new BSD License is applied to this software, see LICENSE.txt</a>
<a name="ln586"> */</a>
<a name="ln587">#include &lt;assert.h&gt;</a>
<a name="ln588">#include &lt;string.h&gt;</a>
<a name="ln589">//#include &quot;SFMT.h&quot;</a>
<a name="ln590">//#include &quot;SFMT-params.h&quot;</a>
<a name="ln591"> </a>
<a name="ln592">#if defined(__BIG_ENDIAN__) &amp;&amp; !defined(__amd64) &amp;&amp; !defined(BIG_ENDIAN64)</a>
<a name="ln593">#define BIG_ENDIAN64 1</a>
<a name="ln594">#endif</a>
<a name="ln595">#if defined(HAVE_ALTIVEC) &amp;&amp; !defined(BIG_ENDIAN64)</a>
<a name="ln596">#define BIG_ENDIAN64 1</a>
<a name="ln597">#endif</a>
<a name="ln598">#if defined(ONLY64) &amp;&amp; !defined(BIG_ENDIAN64)</a>
<a name="ln599">#if defined(__GNUC__)</a>
<a name="ln600">#error &quot;-DONLY64 must be specified with -DBIG_ENDIAN64&quot;</a>
<a name="ln601">#endif</a>
<a name="ln602">#undef ONLY64</a>
<a name="ln603">#endif</a>
<a name="ln604"> </a>
<a name="ln605"> </a>
<a name="ln606">typedef struct dt_points_t</a>
<a name="ln607">{</a>
<a name="ln608">  sfmt_state_t **s;</a>
<a name="ln609">  unsigned int num;</a>
<a name="ln610">} dt_points_t;</a>
<a name="ln611"> </a>
<a name="ln612">#if 0</a>
<a name="ln613">/*--------------------------------------</a>
<a name="ln614">  FILE GLOBAL VARIABLES</a>
<a name="ln615">  internal state, index counter and flag</a>
<a name="ln616">  --------------------------------------*/</a>
<a name="ln617">/** the 128-bit internal state array */</a>
<a name="ln618">static w128_t sfmt[N];</a>
<a name="ln619">/** the 32bit integer pointer to the 128-bit internal state array */</a>
<a name="ln620">static uint32_t *psfmt32 = &amp;sfmt[0].u[0];</a>
<a name="ln621">#if !defined(BIG_ENDIAN64) || defined(ONLY64)</a>
<a name="ln622">/** the 64bit integer pointer to the 128-bit internal state array */</a>
<a name="ln623">static uint64_t *psfmt64 = (uint64_t *)&amp;sfmt[0].u[0];</a>
<a name="ln624">#endif</a>
<a name="ln625">/** index counter to the 32-bit internal state array */</a>
<a name="ln626">static int idx;</a>
<a name="ln627">/** a flag: it is 0 if and only if the internal state is not yet</a>
<a name="ln628"> * initialized. */</a>
<a name="ln629">static int initialized = 0;</a>
<a name="ln630">/** a parity check vector which certificate the period of 2^{MEXP} */</a>
<a name="ln631">static uint32_t parity[4] = {PARITY1, PARITY2, PARITY3, PARITY4};</a>
<a name="ln632">#endif</a>
<a name="ln633"> </a>
<a name="ln634">/*----------------</a>
<a name="ln635">  STATIC FUNCTIONS</a>
<a name="ln636">  ----------------*/</a>
<a name="ln637">inline static int idxof(int i);</a>
<a name="ln638">inline static void rshift128(w128_t *out, w128_t const *in, int shift);</a>
<a name="ln639">inline static void lshift128(w128_t *out, w128_t const *in, int shift);</a>
<a name="ln640">inline static void gen_rand_all(sfmt_state_t *s);</a>
<a name="ln641">inline static void gen_rand_array(sfmt_state_t *s, w128_t *array, int size);</a>
<a name="ln642">inline static uint32_t func1(uint32_t x);</a>
<a name="ln643">inline static uint32_t func2(uint32_t x);</a>
<a name="ln644">static void period_certification(sfmt_state_t *s);</a>
<a name="ln645">#if defined(BIG_ENDIAN64) &amp;&amp; !defined(ONLY64)</a>
<a name="ln646">inline static void swap(w128_t *array, int size);</a>
<a name="ln647">#endif</a>
<a name="ln648"> </a>
<a name="ln649">/*#if defined(HAVE_ALTIVEC)</a>
<a name="ln650">#include &quot;SFMT-alti.h&quot;</a>
<a name="ln651">#elif defined(HAVE_SSE2)</a>
<a name="ln652">#include &quot;SFMT-sse2.h&quot;</a>
<a name="ln653">#endif*/</a>
<a name="ln654"> </a>
<a name="ln655">/**</a>
<a name="ln656"> * This function simulate a 64-bit index of LITTLE ENDIAN</a>
<a name="ln657"> * in BIG ENDIAN machine.</a>
<a name="ln658"> */</a>
<a name="ln659">#ifdef ONLY64</a>
<a name="ln660">inline static int idxof(int i)</a>
<a name="ln661">{</a>
<a name="ln662">  return i ^ 1;</a>
<a name="ln663">}</a>
<a name="ln664">#else</a>
<a name="ln665">inline static int idxof(int i)</a>
<a name="ln666">{</a>
<a name="ln667">  return i;</a>
<a name="ln668">}</a>
<a name="ln669">#endif</a>
<a name="ln670">/**</a>
<a name="ln671"> * This function simulates SIMD 128-bit right shift by the standard C.</a>
<a name="ln672"> * The 128-bit integer given in in is shifted by (shift * 8) bits.</a>
<a name="ln673"> * This function simulates the LITTLE ENDIAN SIMD.</a>
<a name="ln674"> * @param out the output of this function</a>
<a name="ln675"> * @param in the 128-bit data to be shifted</a>
<a name="ln676"> * @param shift the shift value</a>
<a name="ln677"> */</a>
<a name="ln678">#ifdef ONLY64</a>
<a name="ln679">inline static void rshift128(w128_t *out, w128_t const *in, int shift)</a>
<a name="ln680">{</a>
<a name="ln681">  uint64_t th, tl, oh, ol;</a>
<a name="ln682"> </a>
<a name="ln683">  th = ((uint64_t)in-&gt;u[2] &lt;&lt; 32) | ((uint64_t)in-&gt;u[3]);</a>
<a name="ln684">  tl = ((uint64_t)in-&gt;u[0] &lt;&lt; 32) | ((uint64_t)in-&gt;u[1]);</a>
<a name="ln685"> </a>
<a name="ln686">  oh = th &gt;&gt; (shift * 8);</a>
<a name="ln687">  ol = tl &gt;&gt; (shift * 8);</a>
<a name="ln688">  ol |= th &lt;&lt; (64 - shift * 8);</a>
<a name="ln689">  out-&gt;u[0] = (uint32_t)(ol &gt;&gt; 32);</a>
<a name="ln690">  out-&gt;u[1] = (uint32_t)ol;</a>
<a name="ln691">  out-&gt;u[2] = (uint32_t)(oh &gt;&gt; 32);</a>
<a name="ln692">  out-&gt;u[3] = (uint32_t)oh;</a>
<a name="ln693">}</a>
<a name="ln694">#else</a>
<a name="ln695">inline static void rshift128(w128_t *out, w128_t const *in, int shift)</a>
<a name="ln696">{</a>
<a name="ln697">  uint64_t th, tl, oh, ol;</a>
<a name="ln698"> </a>
<a name="ln699">  th = ((uint64_t)in-&gt;u[3] &lt;&lt; 32) | ((uint64_t)in-&gt;u[2]);</a>
<a name="ln700">  tl = ((uint64_t)in-&gt;u[1] &lt;&lt; 32) | ((uint64_t)in-&gt;u[0]);</a>
<a name="ln701"> </a>
<a name="ln702">  oh = th &gt;&gt; (shift * 8);</a>
<a name="ln703">  ol = tl &gt;&gt; (shift * 8);</a>
<a name="ln704">  ol |= th &lt;&lt; (64 - shift * 8);</a>
<a name="ln705">  out-&gt;u[1] = (uint32_t)(ol &gt;&gt; 32);</a>
<a name="ln706">  out-&gt;u[0] = (uint32_t)ol;</a>
<a name="ln707">  out-&gt;u[3] = (uint32_t)(oh &gt;&gt; 32);</a>
<a name="ln708">  out-&gt;u[2] = (uint32_t)oh;</a>
<a name="ln709">}</a>
<a name="ln710">#endif</a>
<a name="ln711">/**</a>
<a name="ln712"> * This function simulates SIMD 128-bit left shift by the standard C.</a>
<a name="ln713"> * The 128-bit integer given in in is shifted by (shift * 8) bits.</a>
<a name="ln714"> * This function simulates the LITTLE ENDIAN SIMD.</a>
<a name="ln715"> * @param out the output of this function</a>
<a name="ln716"> * @param in the 128-bit data to be shifted</a>
<a name="ln717"> * @param shift the shift value</a>
<a name="ln718"> */</a>
<a name="ln719">#ifdef ONLY64</a>
<a name="ln720">inline static void lshift128(w128_t *out, w128_t const *in, int shift)</a>
<a name="ln721">{</a>
<a name="ln722">  uint64_t th, tl, oh, ol;</a>
<a name="ln723"> </a>
<a name="ln724">  th = ((uint64_t)in-&gt;u[2] &lt;&lt; 32) | ((uint64_t)in-&gt;u[3]);</a>
<a name="ln725">  tl = ((uint64_t)in-&gt;u[0] &lt;&lt; 32) | ((uint64_t)in-&gt;u[1]);</a>
<a name="ln726"> </a>
<a name="ln727">  oh = th &lt;&lt; (shift * 8);</a>
<a name="ln728">  ol = tl &lt;&lt; (shift * 8);</a>
<a name="ln729">  oh |= tl &gt;&gt; (64 - shift * 8);</a>
<a name="ln730">  out-&gt;u[0] = (uint32_t)(ol &gt;&gt; 32);</a>
<a name="ln731">  out-&gt;u[1] = (uint32_t)ol;</a>
<a name="ln732">  out-&gt;u[2] = (uint32_t)(oh &gt;&gt; 32);</a>
<a name="ln733">  out-&gt;u[3] = (uint32_t)oh;</a>
<a name="ln734">}</a>
<a name="ln735">#else</a>
<a name="ln736">inline static void lshift128(w128_t *out, w128_t const *in, int shift)</a>
<a name="ln737">{</a>
<a name="ln738">  uint64_t th, tl, oh, ol;</a>
<a name="ln739"> </a>
<a name="ln740">  th = ((uint64_t)in-&gt;u[3] &lt;&lt; 32) | ((uint64_t)in-&gt;u[2]);</a>
<a name="ln741">  tl = ((uint64_t)in-&gt;u[1] &lt;&lt; 32) | ((uint64_t)in-&gt;u[0]);</a>
<a name="ln742"> </a>
<a name="ln743">  oh = th &lt;&lt; (shift * 8);</a>
<a name="ln744">  ol = tl &lt;&lt; (shift * 8);</a>
<a name="ln745">  oh |= tl &gt;&gt; (64 - shift * 8);</a>
<a name="ln746">  out-&gt;u[1] = (uint32_t)(ol &gt;&gt; 32);</a>
<a name="ln747">  out-&gt;u[0] = (uint32_t)ol;</a>
<a name="ln748">  out-&gt;u[3] = (uint32_t)(oh &gt;&gt; 32);</a>
<a name="ln749">  out-&gt;u[2] = (uint32_t)oh;</a>
<a name="ln750">}</a>
<a name="ln751">#endif</a>
<a name="ln752"> </a>
<a name="ln753">/**</a>
<a name="ln754"> * This function represents the recursion formula.</a>
<a name="ln755"> * @param r output</a>
<a name="ln756"> * @param a a 128-bit part of the internal state array</a>
<a name="ln757"> * @param b a 128-bit part of the internal state array</a>
<a name="ln758"> * @param c a 128-bit part of the internal state array</a>
<a name="ln759"> * @param d a 128-bit part of the internal state array</a>
<a name="ln760"> */</a>
<a name="ln761">#if(!defined(HAVE_ALTIVEC)) &amp;&amp; (!defined(HAVE_SSE2))</a>
<a name="ln762">#ifdef ONLY64</a>
<a name="ln763">inline static void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c, w128_t *d)</a>
<a name="ln764">{</a>
<a name="ln765">  w128_t x;</a>
<a name="ln766">  w128_t y;</a>
<a name="ln767"> </a>
<a name="ln768">  lshift128(&amp;x, a, SL2);</a>
<a name="ln769">  rshift128(&amp;y, c, SR2);</a>
<a name="ln770">  r-&gt;u[0] = a-&gt;u[0] ^ x.u[0] ^ ((b-&gt;u[0] &gt;&gt; SR1) &amp; MSK2) ^ y.u[0] ^ (d-&gt;u[0] &lt;&lt; SL1);</a>
<a name="ln771">  r-&gt;u[1] = a-&gt;u[1] ^ x.u[1] ^ ((b-&gt;u[1] &gt;&gt; SR1) &amp; MSK1) ^ y.u[1] ^ (d-&gt;u[1] &lt;&lt; SL1);</a>
<a name="ln772">  r-&gt;u[2] = a-&gt;u[2] ^ x.u[2] ^ ((b-&gt;u[2] &gt;&gt; SR1) &amp; MSK4) ^ y.u[2] ^ (d-&gt;u[2] &lt;&lt; SL1);</a>
<a name="ln773">  r-&gt;u[3] = a-&gt;u[3] ^ x.u[3] ^ ((b-&gt;u[3] &gt;&gt; SR1) &amp; MSK3) ^ y.u[3] ^ (d-&gt;u[3] &lt;&lt; SL1);</a>
<a name="ln774">}</a>
<a name="ln775">#else</a>
<a name="ln776">inline static void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c, w128_t *d)</a>
<a name="ln777">{</a>
<a name="ln778">  w128_t x;</a>
<a name="ln779">  w128_t y;</a>
<a name="ln780"> </a>
<a name="ln781">  lshift128(&amp;x, a, SL2);</a>
<a name="ln782">  rshift128(&amp;y, c, SR2);</a>
<a name="ln783">  r-&gt;u[0] = a-&gt;u[0] ^ x.u[0] ^ ((b-&gt;u[0] &gt;&gt; SR1) &amp; MSK1) ^ y.u[0] ^ (d-&gt;u[0] &lt;&lt; SL1);</a>
<a name="ln784">  r-&gt;u[1] = a-&gt;u[1] ^ x.u[1] ^ ((b-&gt;u[1] &gt;&gt; SR1) &amp; MSK2) ^ y.u[1] ^ (d-&gt;u[1] &lt;&lt; SL1);</a>
<a name="ln785">  r-&gt;u[2] = a-&gt;u[2] ^ x.u[2] ^ ((b-&gt;u[2] &gt;&gt; SR1) &amp; MSK3) ^ y.u[2] ^ (d-&gt;u[2] &lt;&lt; SL1);</a>
<a name="ln786">  r-&gt;u[3] = a-&gt;u[3] ^ x.u[3] ^ ((b-&gt;u[3] &gt;&gt; SR1) &amp; MSK4) ^ y.u[3] ^ (d-&gt;u[3] &lt;&lt; SL1);</a>
<a name="ln787">}</a>
<a name="ln788">#endif</a>
<a name="ln789">#endif</a>
<a name="ln790"> </a>
<a name="ln791">#if defined(BIG_ENDIAN64) &amp;&amp; !defined(ONLY64) &amp;&amp; !defined(HAVE_ALTIVEC)</a>
<a name="ln792">inline static void swap(w128_t *array, int size)</a>
<a name="ln793">{</a>
<a name="ln794">  int i;</a>
<a name="ln795">  uint32_t x, y;</a>
<a name="ln796"> </a>
<a name="ln797">  for(i = 0; i &lt; size; i++)</a>
<a name="ln798">  {</a>
<a name="ln799">    x = array[i].u[0];</a>
<a name="ln800">    y = array[i].u[2];</a>
<a name="ln801">    array[i].u[0] = array[i].u[1];</a>
<a name="ln802">    array[i].u[2] = array[i].u[3];</a>
<a name="ln803">    array[i].u[1] = x;</a>
<a name="ln804">    array[i].u[3] = y;</a>
<a name="ln805">  }</a>
<a name="ln806">}</a>
<a name="ln807">#endif</a>
<a name="ln808">/**</a>
<a name="ln809"> * This function represents a function used in the initialization</a>
<a name="ln810"> * by init_by_array</a>
<a name="ln811"> * @param x 32-bit integer</a>
<a name="ln812"> * @return 32-bit integer</a>
<a name="ln813"> */</a>
<a name="ln814">static uint32_t func1(uint32_t x)</a>
<a name="ln815">{</a>
<a name="ln816">  return (x ^ (x &gt;&gt; 27)) * (uint32_t)1664525UL;</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">/**</a>
<a name="ln820"> * This function represents a function used in the initialization</a>
<a name="ln821"> * by init_by_array</a>
<a name="ln822"> * @param x 32-bit integer</a>
<a name="ln823"> * @return 32-bit integer</a>
<a name="ln824"> */</a>
<a name="ln825">static uint32_t func2(uint32_t x)</a>
<a name="ln826">{</a>
<a name="ln827">  return (x ^ (x &gt;&gt; 27)) * (uint32_t)1566083941UL;</a>
<a name="ln828">}</a>
<a name="ln829"> </a>
<a name="ln830">/**</a>
<a name="ln831"> * This function certificate the period of 2^{MEXP}</a>
<a name="ln832"> */</a>
<a name="ln833">static void period_certification(sfmt_state_t *s)</a>
<a name="ln834">{</a>
<a name="ln835">  int inner = 0;</a>
<a name="ln836">  int i, j;</a>
<a name="ln837">  uint32_t work;</a>
<a name="ln838"> </a>
<a name="ln839">  for(i = 0; i &lt; 4; i++) inner ^= s-&gt;psfmt32[idxof(i)] &amp; s-&gt;parity[i];</a>
<a name="ln840">  for(i = 16; i &gt; 0; i &gt;&gt;= 1) inner ^= inner &gt;&gt; i;</a>
<a name="ln841">  inner &amp;= 1;</a>
<a name="ln842">  /* check OK */</a>
<a name="ln843">  if(inner == 1)</a>
<a name="ln844">  {</a>
<a name="ln845">    return;</a>
<a name="ln846">  }</a>
<a name="ln847">  /* check NG, and modification */</a>
<a name="ln848">  for(i = 0; i &lt; 4; i++)</a>
<a name="ln849">  {</a>
<a name="ln850">    work = 1;</a>
<a name="ln851">    for(j = 0; j &lt; 32; j++)</a>
<a name="ln852">    {</a>
<a name="ln853">      if((work &amp; s-&gt;parity[i]) != 0)</a>
<a name="ln854">      {</a>
<a name="ln855">        s-&gt;psfmt32[idxof(i)] ^= work;</a>
<a name="ln856">        return;</a>
<a name="ln857">      }</a>
<a name="ln858">      work = work &lt;&lt; 1;</a>
<a name="ln859">    }</a>
<a name="ln860">  }</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">/*----------------</a>
<a name="ln864">  PUBLIC FUNCTIONS</a>
<a name="ln865">  ----------------*/</a>
<a name="ln866">/**</a>
<a name="ln867"> * This function returns the identification string.</a>
<a name="ln868"> * The string shows the word size, the Mersenne exponent,</a>
<a name="ln869"> * and all parameters of this generator.</a>
<a name="ln870"> */</a>
<a name="ln871">const char *get_idstring(void)</a>
<a name="ln872">{</a>
<a name="ln873">  return IDSTR;</a>
<a name="ln874">}</a>
<a name="ln875"> </a>
<a name="ln876">/**</a>
<a name="ln877"> * This function returns the minimum size of array used for \b</a>
<a name="ln878"> * fill_array32() function.</a>
<a name="ln879"> * @return minimum size of array used for fill_array32() function.</a>
<a name="ln880"> */</a>
<a name="ln881">int get_min_array_size32(void)</a>
<a name="ln882">{</a>
<a name="ln883">  return N32;</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">/**</a>
<a name="ln887"> * This function returns the minimum size of array used for \b</a>
<a name="ln888"> * fill_array64() function.</a>
<a name="ln889"> * @return minimum size of array used for fill_array64() function.</a>
<a name="ln890"> */</a>
<a name="ln891">int get_min_array_size64(void)</a>
<a name="ln892">{</a>
<a name="ln893">  return N64;</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896">#ifndef ONLY64</a>
<a name="ln897">/**</a>
<a name="ln898"> * This function generates and returns 32-bit pseudorandom number.</a>
<a name="ln899"> * init_gen_rand or init_by_array must be called before this function.</a>
<a name="ln900"> * @return 32-bit pseudorandom number</a>
<a name="ln901"> */</a>
<a name="ln902">uint32_t gen_rand32(sfmt_state_t *s)</a>
<a name="ln903">{</a>
<a name="ln904">  uint32_t r;</a>
<a name="ln905"> </a>
<a name="ln906">  // assert(s-&gt;initialized);</a>
<a name="ln907">  if(s-&gt;idx &gt;= N32)</a>
<a name="ln908">  {</a>
<a name="ln909">    gen_rand_all(s);</a>
<a name="ln910">    s-&gt;idx = 0;</a>
<a name="ln911">  }</a>
<a name="ln912">  r = s-&gt;psfmt32[s-&gt;idx++];</a>
<a name="ln913">  return r;</a>
<a name="ln914">}</a>
<a name="ln915">#endif</a>
<a name="ln916">/**</a>
<a name="ln917"> * This function generates and returns 64-bit pseudorandom number.</a>
<a name="ln918"> * init_gen_rand or init_by_array must be called before this function.</a>
<a name="ln919"> * The function gen_rand64 should not be called after gen_rand32,</a>
<a name="ln920"> * unless an initialization is again executed.</a>
<a name="ln921"> * @return 64-bit pseudorandom number</a>
<a name="ln922"> */</a>
<a name="ln923">uint64_t gen_rand64(sfmt_state_t *s)</a>
<a name="ln924">{</a>
<a name="ln925">#if defined(BIG_ENDIAN64) &amp;&amp; !defined(ONLY64)</a>
<a name="ln926">  uint32_t r1, r2;</a>
<a name="ln927">#else</a>
<a name="ln928">  uint64_t r;</a>
<a name="ln929">#endif</a>
<a name="ln930"> </a>
<a name="ln931">  // assert(s-&gt;initialized);</a>
<a name="ln932">  // assert(s-&gt;idx % 2 == 0);</a>
<a name="ln933"> </a>
<a name="ln934">  if(s-&gt;idx &gt;= N32)</a>
<a name="ln935">  {</a>
<a name="ln936">    gen_rand_all(s);</a>
<a name="ln937">    s-&gt;idx = 0;</a>
<a name="ln938">  }</a>
<a name="ln939">#if defined(BIG_ENDIAN64) &amp;&amp; !defined(ONLY64)</a>
<a name="ln940">  r1 = s-&gt;psfmt32[s-&gt;idx];</a>
<a name="ln941">  r2 = s-&gt;psfmt32[s-&gt;idx + 1];</a>
<a name="ln942">  s-&gt;idx += 2;</a>
<a name="ln943">  return ((uint64_t)r2 &lt;&lt; 32) | r1;</a>
<a name="ln944">#else</a>
<a name="ln945">  r = s-&gt;psfmt64[s-&gt;idx / 2];</a>
<a name="ln946">  s-&gt;idx += 2;</a>
<a name="ln947">  return r;</a>
<a name="ln948">#endif</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951">#ifndef ONLY64</a>
<a name="ln952">/**</a>
<a name="ln953"> * This function generates pseudorandom 32-bit integers in the</a>
<a name="ln954"> * specified array[] by one call. The number of pseudorandom integers</a>
<a name="ln955"> * is specified by the argument size, which must be at least 624 and a</a>
<a name="ln956"> * multiple of four.  The generation by this function is much faster</a>
<a name="ln957"> * than the following gen_rand function.</a>
<a name="ln958"> *</a>
<a name="ln959"> * For initialization, init_gen_rand or init_by_array must be called</a>
<a name="ln960"> * before the first call of this function. This function can not be</a>
<a name="ln961"> * used after calling gen_rand function, without initialization.</a>
<a name="ln962"> *</a>
<a name="ln963"> * @param array an array where pseudorandom 32-bit integers are filled</a>
<a name="ln964"> * by this function.  The pointer to the array must be \b &quot;aligned&quot;</a>
<a name="ln965"> * (namely, must be a multiple of 16) in the SIMD version, since it</a>
<a name="ln966"> * refers to the address of a 128-bit integer.  In the standard C</a>
<a name="ln967"> * version, the pointer is arbitrary.</a>
<a name="ln968"> *</a>
<a name="ln969"> * @param size the number of 32-bit pseudorandom integers to be</a>
<a name="ln970"> * generated.  size must be a multiple of 4, and greater than or equal</a>
<a name="ln971"> * to (MEXP / 128 + 1) * 4.</a>
<a name="ln972"> *</a>
<a name="ln973"> * @note \b memalign or \b posix_memalign is available to get aligned</a>
<a name="ln974"> * memory. Mac OSX doesn't have these functions, but \b malloc of OSX</a>
<a name="ln975"> * returns the pointer to the aligned memory block.</a>
<a name="ln976"> */</a>
<a name="ln977">void fill_array32(sfmt_state_t *s, uint32_t *array, int size)</a>
<a name="ln978">{</a>
<a name="ln979">  // assert(s-&gt;initialized);</a>
<a name="ln980">  // assert(s-&gt;idx == N32);</a>
<a name="ln981">  // assert(size % 4 == 0);</a>
<a name="ln982">  // assert(size &gt;= N32);</a>
<a name="ln983"> </a>
<a name="ln984">  gen_rand_array(s, (w128_t *)array, size / 4);</a>
<a name="ln985">  s-&gt;idx = N32;</a>
<a name="ln986">}</a>
<a name="ln987">#endif</a>
<a name="ln988"> </a>
<a name="ln989">/**</a>
<a name="ln990"> * This function generates pseudorandom 64-bit integers in the</a>
<a name="ln991"> * specified array[] by one call. The number of pseudorandom integers</a>
<a name="ln992"> * is specified by the argument size, which must be at least 312 and a</a>
<a name="ln993"> * multiple of two.  The generation by this function is much faster</a>
<a name="ln994"> * than the following gen_rand function.</a>
<a name="ln995"> *</a>
<a name="ln996"> * For initialization, init_gen_rand or init_by_array must be called</a>
<a name="ln997"> * before the first call of this function. This function can not be</a>
<a name="ln998"> * used after calling gen_rand function, without initialization.</a>
<a name="ln999"> *</a>
<a name="ln1000"> * @param array an array where pseudorandom 64-bit integers are filled</a>
<a name="ln1001"> * by this function.  The pointer to the array must be &quot;aligned&quot;</a>
<a name="ln1002"> * (namely, must be a multiple of 16) in the SIMD version, since it</a>
<a name="ln1003"> * refers to the address of a 128-bit integer.  In the standard C</a>
<a name="ln1004"> * version, the pointer is arbitrary.</a>
<a name="ln1005"> *</a>
<a name="ln1006"> * @param size the number of 64-bit pseudorandom integers to be</a>
<a name="ln1007"> * generated.  size must be a multiple of 2, and greater than or equal</a>
<a name="ln1008"> * to (MEXP / 128 + 1) * 2</a>
<a name="ln1009"> *</a>
<a name="ln1010"> * @note \b memalign or \b posix_memalign is available to get aligned</a>
<a name="ln1011"> * memory. Mac OSX doesn't have these functions, but \b malloc of OSX</a>
<a name="ln1012"> * returns the pointer to the aligned memory block.</a>
<a name="ln1013"> */</a>
<a name="ln1014">void fill_array64(sfmt_state_t *s, uint64_t *array, int size)</a>
<a name="ln1015">{</a>
<a name="ln1016">  // assert(s-&gt;initialized);</a>
<a name="ln1017">  // assert(s-&gt;idx == N32);</a>
<a name="ln1018">  // assert(size % 2 == 0);</a>
<a name="ln1019">  // assert(size &gt;= N64);</a>
<a name="ln1020"> </a>
<a name="ln1021">  gen_rand_array(s, (w128_t *)array, size / 2);</a>
<a name="ln1022">  s-&gt;idx = N32;</a>
<a name="ln1023"> </a>
<a name="ln1024">#if defined(BIG_ENDIAN64) &amp;&amp; !defined(ONLY64)</a>
<a name="ln1025">  swap((w128_t *)array, size / 2);</a>
<a name="ln1026">#endif</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029">/**</a>
<a name="ln1030"> * This function initializes the internal state array with a 32-bit</a>
<a name="ln1031"> * integer seed.</a>
<a name="ln1032"> *</a>
<a name="ln1033"> * @param seed a 32-bit integer used as the seed.</a>
<a name="ln1034"> */</a>
<a name="ln1035">void init_gen_rand(sfmt_state_t *s, uint32_t seed)</a>
<a name="ln1036">{</a>
<a name="ln1037">  int i;</a>
<a name="ln1038"> </a>
<a name="ln1039">  s-&gt;psfmt32[idxof(0)] = seed;</a>
<a name="ln1040">  for(i = 1; i &lt; N32; i++)</a>
<a name="ln1041">  {</a>
<a name="ln1042">    s-&gt;psfmt32[idxof(i)] = 1812433253UL * (s-&gt;psfmt32[idxof(i - 1)] ^ (s-&gt;psfmt32[idxof(i - 1)] &gt;&gt; 30)) + i;</a>
<a name="ln1043">  }</a>
<a name="ln1044">  s-&gt;idx = N32;</a>
<a name="ln1045">  period_certification(s);</a>
<a name="ln1046">  s-&gt;initialized = 1;</a>
<a name="ln1047">}</a>
<a name="ln1048"> </a>
<a name="ln1049">/**</a>
<a name="ln1050"> * This function initializes the internal state array,</a>
<a name="ln1051"> * with an array of 32-bit integers used as the seeds</a>
<a name="ln1052"> * @param init_key the array of 32-bit integers, used as a seed.</a>
<a name="ln1053"> * @param key_length the length of init_key.</a>
<a name="ln1054"> */</a>
<a name="ln1055">void init_by_array(sfmt_state_t *s, uint32_t *init_key, int key_length)</a>
<a name="ln1056">{</a>
<a name="ln1057">  int i, j, count;</a>
<a name="ln1058">  uint32_t r;</a>
<a name="ln1059">  int lag;</a>
<a name="ln1060">  int mid;</a>
<a name="ln1061">  int size = N * 4;</a>
<a name="ln1062"> </a>
<a name="ln1063">  if(size &gt;= 623)</a>
<a name="ln1064">  {</a>
<a name="ln1065">    lag = 11;</a>
<a name="ln1066">  }</a>
<a name="ln1067">  else if(size &gt;= 68)</a>
<a name="ln1068">  {</a>
<a name="ln1069">    lag = 7;</a>
<a name="ln1070">  }</a>
<a name="ln1071">  else if(size &gt;= 39)</a>
<a name="ln1072">  {</a>
<a name="ln1073">    lag = 5;</a>
<a name="ln1074">  }</a>
<a name="ln1075">  else</a>
<a name="ln1076">  {</a>
<a name="ln1077">    lag = 3;</a>
<a name="ln1078">  }</a>
<a name="ln1079">  mid = (size - lag) / 2;</a>
<a name="ln1080"> </a>
<a name="ln1081">  memset(s-&gt;sfmt, 0x8b, sizeof(s-&gt;sfmt));</a>
<a name="ln1082">  if(key_length + 1 &gt; N32)</a>
<a name="ln1083">  {</a>
<a name="ln1084">    count = key_length + 1;</a>
<a name="ln1085">  }</a>
<a name="ln1086">  else</a>
<a name="ln1087">  {</a>
<a name="ln1088">    count = N32;</a>
<a name="ln1089">  }</a>
<a name="ln1090">  r = func1(s-&gt;psfmt32[idxof(0)] ^ s-&gt;psfmt32[idxof(mid)] ^ s-&gt;psfmt32[idxof(N32 - 1)]);</a>
<a name="ln1091">  s-&gt;psfmt32[idxof(mid)] += r;</a>
<a name="ln1092">  r += key_length;</a>
<a name="ln1093">  s-&gt;psfmt32[idxof(mid + lag)] += r;</a>
<a name="ln1094">  s-&gt;psfmt32[idxof(0)] = r;</a>
<a name="ln1095"> </a>
<a name="ln1096">  count--;</a>
<a name="ln1097">  for(i = 1, j = 0; (j &lt; count) &amp;&amp; (j &lt; key_length); j++)</a>
<a name="ln1098">  {</a>
<a name="ln1099">    r = func1(s-&gt;psfmt32[idxof(i)] ^ s-&gt;psfmt32[idxof((i + mid) % N32)]</a>
<a name="ln1100">              ^ s-&gt;psfmt32[idxof((i + N32 - 1) % N32)]);</a>
<a name="ln1101">    s-&gt;psfmt32[idxof((i + mid) % N32)] += r;</a>
<a name="ln1102">    r += init_key[j] + i;</a>
<a name="ln1103">    s-&gt;psfmt32[idxof((i + mid + lag) % N32)] += r;</a>
<a name="ln1104">    s-&gt;psfmt32[idxof(i)] = r;</a>
<a name="ln1105">    i = (i + 1) % N32;</a>
<a name="ln1106">  }</a>
<a name="ln1107">  for(; j &lt; count; j++)</a>
<a name="ln1108">  {</a>
<a name="ln1109">    r = func1(s-&gt;psfmt32[idxof(i)] ^ s-&gt;psfmt32[idxof((i + mid) % N32)]</a>
<a name="ln1110">              ^ s-&gt;psfmt32[idxof((i + N32 - 1) % N32)]);</a>
<a name="ln1111">    s-&gt;psfmt32[idxof((i + mid) % N32)] += r;</a>
<a name="ln1112">    r += i;</a>
<a name="ln1113">    s-&gt;psfmt32[idxof((i + mid + lag) % N32)] += r;</a>
<a name="ln1114">    s-&gt;psfmt32[idxof(i)] = r;</a>
<a name="ln1115">    i = (i + 1) % N32;</a>
<a name="ln1116">  }</a>
<a name="ln1117">  for(j = 0; j &lt; N32; j++)</a>
<a name="ln1118">  {</a>
<a name="ln1119">    r = func2(s-&gt;psfmt32[idxof(i)] + s-&gt;psfmt32[idxof((i + mid) % N32)]</a>
<a name="ln1120">              + s-&gt;psfmt32[idxof((i + N32 - 1) % N32)]);</a>
<a name="ln1121">    s-&gt;psfmt32[idxof((i + mid) % N32)] ^= r;</a>
<a name="ln1122">    r -= i;</a>
<a name="ln1123">    s-&gt;psfmt32[idxof((i + mid + lag) % N32)] ^= r;</a>
<a name="ln1124">    s-&gt;psfmt32[idxof(i)] = r;</a>
<a name="ln1125">    i = (i + 1) % N32;</a>
<a name="ln1126">  }</a>
<a name="ln1127"> </a>
<a name="ln1128">  s-&gt;idx = N32;</a>
<a name="ln1129">  period_certification(s);</a>
<a name="ln1130">  s-&gt;initialized = 1;</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133"> </a>
<a name="ln1134">static inline void dt_points_init(dt_points_t *p, const unsigned int num_threads)</a>
<a name="ln1135">{</a>
<a name="ln1136">  sfmt_state_t *states = (sfmt_state_t *)dt_alloc_align(64, sizeof(sfmt_state_t) * num_threads);</a>
<a name="ln1137">  p-&gt;s = (sfmt_state_t **)calloc(num_threads, sizeof(sfmt_state_t *));</a>
<a name="ln1138">  p-&gt;num = num_threads;</a>
<a name="ln1139"> </a>
<a name="ln1140">  int seed = 0xD71337;</a>
<a name="ln1141">  for(int i = 0; i &lt; (int)num_threads; i++)</a>
<a name="ln1142">  {</a>
<a name="ln1143">    p-&gt;s[i] = states + i;</a>
<a name="ln1144">#if !defined(BIG_ENDIAN64) || defined(ONLY64)</a>
<a name="ln1145">    p-&gt;s[i]-&gt;psfmt64 = (uint64_t *)&amp;(p-&gt;s[i]-&gt;sfmt[0].u[0]);</a>
<a name="ln1146">#endif</a>
<a name="ln1147">    p-&gt;s[i]-&gt;psfmt32 = &amp;(p-&gt;s[i]-&gt;sfmt[0].u[0]);</a>
<a name="ln1148">    p-&gt;s[i]-&gt;initialized = 0;</a>
<a name="ln1149">    p-&gt;s[i]-&gt;parity[0] = PARITY1;</a>
<a name="ln1150">    p-&gt;s[i]-&gt;parity[1] = PARITY2;</a>
<a name="ln1151">    p-&gt;s[i]-&gt;parity[2] = PARITY3;</a>
<a name="ln1152">    p-&gt;s[i]-&gt;parity[3] = PARITY4;</a>
<a name="ln1153">    init_gen_rand(p-&gt;s[i], seed);</a>
<a name="ln1154">    seed ^= seed &lt;&lt; 1;</a>
<a name="ln1155">  }</a>
<a name="ln1156">}</a>
<a name="ln1157"> </a>
<a name="ln1158">static inline void dt_points_cleanup(dt_points_t *p)</a>
<a name="ln1159">{</a>
<a name="ln1160">  dt_free_align(p-&gt;s[0]);</a>
<a name="ln1161">  free(p-&gt;s);</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164">static inline float dt_points_get_for(dt_points_t *p, const unsigned int thread_num)</a>
<a name="ln1165">{</a>
<a name="ln1166">  return genrand_real2f(p-&gt;s[thread_num]);</a>
<a name="ln1167">}</a>
<a name="ln1168"> </a>
<a name="ln1169">static inline float dt_points_get()</a>
<a name="ln1170">{</a>
<a name="ln1171">  return dt_points_get_for(darktable.points, dt_get_thread_num());</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174">#endif</a>
<a name="ln1175">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1176">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1177">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="848"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v756/" target="_blank">V756</a> The 'j' counter is not used inside a nested loop. Consider inspecting usage of 'i' counter.</p></div>
<div class="balloon" rel="1063"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'size >= 623' is always true.</p></div>
<div class="balloon" rel="1143"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'p->s'. Check lines: 1143, 1137.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
