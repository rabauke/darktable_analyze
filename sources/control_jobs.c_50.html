
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010-2011 johannes hanika</a>
<a name="ln4">    copyright (c) 2010-2012 henrik andersson</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;control/jobs/control_jobs.h&quot;</a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/exif.h&quot;</a>
<a name="ln24">#include &quot;common/film.h&quot;</a>
<a name="ln25">#include &quot;common/gpx.h&quot;</a>
<a name="ln26">#include &quot;common/history.h&quot;</a>
<a name="ln27">#include &quot;common/image.h&quot;</a>
<a name="ln28">#include &quot;common/image_cache.h&quot;</a>
<a name="ln29">#include &quot;common/imageio.h&quot;</a>
<a name="ln30">#include &quot;common/imageio_dng.h&quot;</a>
<a name="ln31">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln32">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln33">#include &quot;common/tags.h&quot;</a>
<a name="ln34">#include &quot;common/undo.h&quot;</a>
<a name="ln35">#include &quot;control/conf.h&quot;</a>
<a name="ln36">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;gui/gtk.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;gio/gio.h&gt;</a>
<a name="ln41">#include &lt;glib.h&gt;</a>
<a name="ln42">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln43">#ifndef _WIN32</a>
<a name="ln44">#include &lt;glob.h&gt;</a>
<a name="ln45">#endif</a>
<a name="ln46">#ifdef __APPLE__</a>
<a name="ln47">#include &quot;osx/osx.h&quot;</a>
<a name="ln48">#endif</a>
<a name="ln49">#ifdef _WIN32</a>
<a name="ln50">#include &quot;win/dtwin.h&quot;</a>
<a name="ln51">#endif</a>
<a name="ln52"> </a>
<a name="ln53">typedef struct dt_control_time_offset_t</a>
<a name="ln54">{</a>
<a name="ln55">  long int offset;</a>
<a name="ln56">} dt_control_time_offset_t;</a>
<a name="ln57"> </a>
<a name="ln58">typedef struct dt_control_gpx_apply_t</a>
<a name="ln59">{</a>
<a name="ln60">  gchar *filename;</a>
<a name="ln61">  gchar *tz;</a>
<a name="ln62">} dt_control_gpx_apply_t;</a>
<a name="ln63"> </a>
<a name="ln64">typedef struct dt_control_export_t</a>
<a name="ln65">{</a>
<a name="ln66">  int max_width, max_height, format_index, storage_index;</a>
<a name="ln67">  dt_imageio_module_data_t *sdata; // needed since the gui thread resets things like overwrite once the export</a>
<a name="ln68">  // is dispatched, but we have to keep that information</a>
<a name="ln69">  gboolean high_quality, upscale;</a>
<a name="ln70">  char style[128];</a>
<a name="ln71">  gboolean style_append;</a>
<a name="ln72">  dt_colorspaces_color_profile_type_t icc_type;</a>
<a name="ln73">  gchar *icc_filename;</a>
<a name="ln74">  dt_iop_color_intent_t icc_intent;</a>
<a name="ln75">} dt_control_export_t;</a>
<a name="ln76"> </a>
<a name="ln77">typedef struct dt_control_image_enumerator_t</a>
<a name="ln78">{</a>
<a name="ln79">  GList *index;</a>
<a name="ln80">  int flag;</a>
<a name="ln81">  gpointer data;</a>
<a name="ln82">} dt_control_image_enumerator_t;</a>
<a name="ln83"> </a>
<a name="ln84">typedef struct dt_undo_geotag_t</a>
<a name="ln85">{</a>
<a name="ln86">  GList *before;</a>
<a name="ln87">  GList *after;</a>
<a name="ln88">} dt_undo_geotag_t;</a>
<a name="ln89"> </a>
<a name="ln90">/* enumerator of images from filmroll */</a>
<a name="ln91">static void dt_control_image_enumerator_job_film_init(dt_control_image_enumerator_t *t, int32_t filmid)</a>
<a name="ln92">{</a>
<a name="ln93">  g_list_free(t-&gt;index);</a>
<a name="ln94">  t-&gt;index = NULL;</a>
<a name="ln95"> </a>
<a name="ln96">  sqlite3_stmt *stmt;</a>
<a name="ln97">  /* get a list of images in filmroll */</a>
<a name="ln98">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT id FROM main.images WHERE film_id = ?1&quot;, -1,</a>
<a name="ln99">                              &amp;stmt, NULL);</a>
<a name="ln100">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, filmid);</a>
<a name="ln101"> </a>
<a name="ln102">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln103">  {</a>
<a name="ln104">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln105">    t-&gt;index = g_list_append(t-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln106">  }</a>
<a name="ln107">  sqlite3_finalize(stmt);</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">/* enumerator of selected images */</a>
<a name="ln111">static void dt_control_image_enumerator_job_selected_init(dt_control_image_enumerator_t *t)</a>
<a name="ln112">{</a>
<a name="ln113">  g_list_free(t-&gt;index);</a>
<a name="ln114">  t-&gt;index = NULL;</a>
<a name="ln115"> </a>
<a name="ln116">  int imgid = dt_view_get_image_to_act_on();</a>
<a name="ln117"> </a>
<a name="ln118">  if(imgid &lt; 0) /* get sorted list of selected images */</a>
<a name="ln119">    t-&gt;index = dt_collection_get_selected(darktable.collection, -1);</a>
<a name="ln120">  else</a>
<a name="ln121">    /* Create a list with only one image */</a>
<a name="ln122">    t-&gt;index = g_list_append(t-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">static int32_t _generic_dt_control_fileop_images_job_run(dt_job_t *job,</a>
<a name="ln126">                                                         int32_t (*fileop_callback)(const int32_t,</a>
<a name="ln127">                                                                                    const int32_t),</a>
<a name="ln128">                                                         const char *desc, const char *desc_pl)</a>
<a name="ln129">{</a>
<a name="ln130">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln131">  GList *t = params-&gt;index;</a>
<a name="ln132">  guint total = g_list_length(t);</a>
<a name="ln133">  char message[512] = { 0 };</a>
<a name="ln134">  double fraction = 0;</a>
<a name="ln135">  gchar *newdir = (gchar *)params-&gt;data;</a>
<a name="ln136"> </a>
<a name="ln137">  g_snprintf(message, sizeof(message), ngettext(desc, desc_pl, total), total);</a>
<a name="ln138">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln139"> </a>
<a name="ln140">  // create new film roll for the destination directory</a>
<a name="ln141">  dt_film_t new_film;</a>
<a name="ln142">  const int32_t film_id = dt_film_new(&amp;new_film, newdir);</a>
<a name="ln143">  g_free(newdir);</a>
<a name="ln144"> </a>
<a name="ln145">  if(film_id &lt;= 0)</a>
<a name="ln146">  {</a>
<a name="ln147">    dt_control_log(_(&quot;failed to create film roll for destination directory, aborting move..&quot;));</a>
<a name="ln148">    return -1;</a>
<a name="ln149">  }</a>
<a name="ln150"> </a>
<a name="ln151">  gboolean completeSuccess = TRUE;</a>
<a name="ln152">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln153">  {</a>
<a name="ln154">    completeSuccess &amp;= (fileop_callback(GPOINTER_TO_INT(t-&gt;data), film_id) != -1);</a>
<a name="ln155">    t = g_list_delete_link(t, t);</a>
<a name="ln156">    fraction += 1.0 / total;</a>
<a name="ln157">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln158">  }</a>
<a name="ln159">  params-&gt;index = NULL;</a>
<a name="ln160"> </a>
<a name="ln161">  if(completeSuccess)</a>
<a name="ln162">  {</a>
<a name="ln163">    char collect[1024];</a>
<a name="ln164">    snprintf(collect, sizeof(collect), &quot;1:0:0:%s$&quot;, new_film.dirname);</a>
<a name="ln165">    dt_collection_deserialize(collect);</a>
<a name="ln166">  }</a>
<a name="ln167">  dt_film_remove_empty();</a>
<a name="ln168">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln169">  dt_control_queue_redraw_center();</a>
<a name="ln170">  return 0;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">static void *dt_control_image_enumerator_alloc()</a>
<a name="ln174">{</a>
<a name="ln175">  dt_control_image_enumerator_t *params = calloc(1, sizeof(dt_control_image_enumerator_t));</a>
<a name="ln176">  if(!params) return NULL;</a>
<a name="ln177"> </a>
<a name="ln178">  return params;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">static void dt_control_image_enumerator_cleanup(void *p)</a>
<a name="ln182">{</a>
<a name="ln183">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln184"> </a>
<a name="ln185">  g_list_free(params-&gt;index);</a>
<a name="ln186"> </a>
<a name="ln187">  free(params);</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">typedef enum {PROGRESS_NONE, PROGRESS_SIMPLE, PROGRESS_CANCELLABLE} progress_type_t;</a>
<a name="ln191"> </a>
<a name="ln192">static dt_job_t *dt_control_generic_images_job_create(dt_job_execute_callback execute, const char *message,</a>
<a name="ln193">                                                      int flag, gpointer data, progress_type_t progress_type)</a>
<a name="ln194">{</a>
<a name="ln195">  dt_job_t *job = dt_control_job_create(execute, &quot;%s&quot;, message);</a>
<a name="ln196">  if(!job) return NULL;</a>
<a name="ln197">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln198">  if(!params)</a>
<a name="ln199">  {</a>
<a name="ln200">    dt_control_job_dispose(job);</a>
<a name="ln201">    return NULL;</a>
<a name="ln202">  }</a>
<a name="ln203">  if(progress_type != PROGRESS_NONE)</a>
<a name="ln204">    dt_control_job_add_progress(job, _(message), progress_type == PROGRESS_CANCELLABLE);</a>
<a name="ln205">  dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln206">  dt_control_job_set_params(job, params, dt_control_image_enumerator_cleanup);</a>
<a name="ln207"> </a>
<a name="ln208">  params-&gt;flag = flag;</a>
<a name="ln209">  params-&gt;data = data;</a>
<a name="ln210">  return job;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">static int32_t dt_control_write_sidecar_files_job_run(dt_job_t *job)</a>
<a name="ln214">{</a>
<a name="ln215">  int imgid = -1;</a>
<a name="ln216">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln217">  GList *t = params-&gt;index;</a>
<a name="ln218">  sqlite3_stmt *stmt;</a>
<a name="ln219">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln220">                              &quot;UPDATE main.images SET write_timestamp = STRFTIME('%s', 'now') WHERE id = ?1&quot;, -1,</a>
<a name="ln221">                              &amp;stmt, NULL);</a>
<a name="ln222">  while(t)</a>
<a name="ln223">  {</a>
<a name="ln224">    gboolean from_cache = FALSE;</a>
<a name="ln225">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln226">    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, (int32_t)imgid, 'r');</a>
<a name="ln227">    char dtfilename[PATH_MAX] = { 0 };</a>
<a name="ln228">    dt_image_full_path(img-&gt;id, dtfilename, sizeof(dtfilename), &amp;from_cache);</a>
<a name="ln229">    dt_image_path_append_version(img-&gt;id, dtfilename, sizeof(dtfilename));</a>
<a name="ln230">    g_strlcat(dtfilename, &quot;.xmp&quot;, sizeof(dtfilename));</a>
<a name="ln231">    if(!dt_exif_xmp_write(imgid, dtfilename))</a>
<a name="ln232">    {</a>
<a name="ln233">      // put the timestamp into db. this can't be done in exif.cc since that code gets called</a>
<a name="ln234">      // for the copy exporter, too</a>
<a name="ln235">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln236">      sqlite3_step(stmt);</a>
<a name="ln237">      sqlite3_reset(stmt);</a>
<a name="ln238">      sqlite3_clear_bindings(stmt);</a>
<a name="ln239">    }</a>
<a name="ln240">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln241">    t = g_list_delete_link(t, t);</a>
<a name="ln242">  }</a>
<a name="ln243">  params-&gt;index = NULL;</a>
<a name="ln244">  sqlite3_finalize(stmt);</a>
<a name="ln245">  return 0;</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">typedef struct dt_control_merge_hdr_t</a>
<a name="ln249">{</a>
<a name="ln250">  uint32_t first_imgid;</a>
<a name="ln251">  uint32_t first_filter;</a>
<a name="ln252">  uint8_t first_xtrans[6][6];</a>
<a name="ln253"> </a>
<a name="ln254">  float *pixels, *weight;</a>
<a name="ln255"> </a>
<a name="ln256">  int wd;</a>
<a name="ln257">  int ht;</a>
<a name="ln258">  dt_image_orientation_t orientation;</a>
<a name="ln259"> </a>
<a name="ln260">  float whitelevel;</a>
<a name="ln261">  float epsw;</a>
<a name="ln262"> </a>
<a name="ln263">  // 0 - ok; 1 - errors, abort</a>
<a name="ln264">  gboolean abort;</a>
<a name="ln265">} dt_control_merge_hdr_t;</a>
<a name="ln266"> </a>
<a name="ln267">typedef struct dt_control_merge_hdr_format_t</a>
<a name="ln268">{</a>
<a name="ln269">  dt_imageio_module_data_t parent;</a>
<a name="ln270">  dt_control_merge_hdr_t *d;</a>
<a name="ln271">} dt_control_merge_hdr_format_t;</a>
<a name="ln272"> </a>
<a name="ln273">static int dt_control_merge_hdr_bpp(dt_imageio_module_data_t *data)</a>
<a name="ln274">{</a>
<a name="ln275">  return 32;</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">static int dt_control_merge_hdr_levels(dt_imageio_module_data_t *data)</a>
<a name="ln279">{</a>
<a name="ln280">  return IMAGEIO_RGB | IMAGEIO_FLOAT;</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">static const char *dt_control_merge_hdr_mime(dt_imageio_module_data_t *data)</a>
<a name="ln284">{</a>
<a name="ln285">  return &quot;memory&quot;;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">static float envelope(const float xx)</a>
<a name="ln289">{</a>
<a name="ln290">  const float x = CLAMPS(xx, 0.0f, 1.0f);</a>
<a name="ln291">  // const float alpha = 2.0f;</a>
<a name="ln292">  const float beta = 0.5f;</a>
<a name="ln293">  if(x &lt; beta)</a>
<a name="ln294">  {</a>
<a name="ln295">    // return 1.0f-fabsf(x/beta-1.0f)^2</a>
<a name="ln296">    const float tmp = fabsf(x / beta - 1.0f);</a>
<a name="ln297">    return 1.0f - tmp * tmp;</a>
<a name="ln298">  }</a>
<a name="ln299">  else</a>
<a name="ln300">  {</a>
<a name="ln301">    const float tmp1 = (1.0f - x) / (1.0f - beta);</a>
<a name="ln302">    const float tmp2 = tmp1 * tmp1;</a>
<a name="ln303">    const float tmp3 = tmp2 * tmp1;</a>
<a name="ln304">    return 3.0f * tmp2 - 2.0f * tmp3;</a>
<a name="ln305">  }</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">static int dt_control_merge_hdr_process(dt_imageio_module_data_t *datai, const char *filename,</a>
<a name="ln309">                                        const void *const ivoid,</a>
<a name="ln310">                                        dt_colorspaces_color_profile_type_t over_type, const char *over_filename,</a>
<a name="ln311">                                        void *exif, int exif_len, int imgid, int num, int total,</a>
<a name="ln312">                                        dt_dev_pixelpipe_t *pipe)</a>
<a name="ln313">{</a>
<a name="ln314">  dt_control_merge_hdr_format_t *data = (dt_control_merge_hdr_format_t *)datai;</a>
<a name="ln315">  dt_control_merge_hdr_t *d = data-&gt;d;</a>
<a name="ln316"> </a>
<a name="ln317">  // just take a copy. also do it after blocking read, so filters will make sense.</a>
<a name="ln318">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln319">  const dt_image_t image = *img;</a>
<a name="ln320">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln321"> </a>
<a name="ln322">  if(!d-&gt;pixels)</a>
<a name="ln323">  {</a>
<a name="ln324">    d-&gt;first_imgid = imgid;</a>
<a name="ln325">    d-&gt;first_filter = image.buf_dsc.filters;</a>
<a name="ln326">    // sensor layout is just passed on to be written to dng.</a>
<a name="ln327">    // we offset it to the crop of the image here, so we don't</a>
<a name="ln328">    // need to load in the FCxtrans dependency into the dng writer.</a>
<a name="ln329">    // for some stupid reason the dng needs this layout wrt cropped</a>
<a name="ln330">    // offsets, not globally.</a>
<a name="ln331">    dt_iop_roi_t roi = {0};</a>
<a name="ln332">    roi.x = image.crop_x;</a>
<a name="ln333">    roi.y = image.crop_y;</a>
<a name="ln334">    for(int j=0;j&lt;6;j++)</a>
<a name="ln335">      for(int i = 0; i &lt; 6; i++) d-&gt;first_xtrans[j][i] = FCxtrans(j, i, &amp;roi, image.buf_dsc.xtrans);</a>
<a name="ln336">    d-&gt;pixels = calloc(datai-&gt;width * datai-&gt;height, sizeof(float));</a>
<a name="ln337">    d-&gt;weight = calloc(datai-&gt;width * datai-&gt;height, sizeof(float));</a>
<a name="ln338">    d-&gt;wd = datai-&gt;width;</a>
<a name="ln339">    d-&gt;ht = datai-&gt;height;</a>
<a name="ln340">    d-&gt;orientation = image.orientation;</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  if(image.buf_dsc.filters == 0u || image.buf_dsc.channels != 1 || image.buf_dsc.datatype != TYPE_UINT16)</a>
<a name="ln344">  {</a>
<a name="ln345">    dt_control_log(_(&quot;exposure bracketing only works on raw images.&quot;));</a>
<a name="ln346">    d-&gt;abort = TRUE;</a>
<a name="ln347">    return 1;</a>
<a name="ln348">  }</a>
<a name="ln349">  else if(datai-&gt;width != d-&gt;wd || datai-&gt;height != d-&gt;ht || d-&gt;first_filter != image.buf_dsc.filters</a>
<a name="ln350">          || d-&gt;orientation != image.orientation)</a>
<a name="ln351">  {</a>
<a name="ln352">    dt_control_log(_(&quot;images have to be of same size and orientation!&quot;));</a>
<a name="ln353">    d-&gt;abort = TRUE;</a>
<a name="ln354">    return 1;</a>
<a name="ln355">  }</a>
<a name="ln356"> </a>
<a name="ln357">  // if no valid exif data can be found, assume peleng fisheye at f/16, 8mm, with half of the light lost in</a>
<a name="ln358">  // the system =&gt; f/22</a>
<a name="ln359">  const float eap = image.exif_aperture &gt; 0.0f ? image.exif_aperture : 22.0f;</a>
<a name="ln360">  const float efl = image.exif_focal_length &gt; 0.0f ? image.exif_focal_length : 8.0f;</a>
<a name="ln361">  const float rad = .5f * efl / eap;</a>
<a name="ln362">  const float aperture = M_PI * rad * rad;</a>
<a name="ln363">  const float iso = image.exif_iso &gt; 0.0f ? image.exif_iso : 100.0f;</a>
<a name="ln364">  const float exp = image.exif_exposure &gt; 0.0f ? image.exif_exposure : 1.0f;</a>
<a name="ln365">  const float cal = 100.0f / (aperture * exp * iso);</a>
<a name="ln366">  // about proportional to how many photons we can expect from this shot:</a>
<a name="ln367">  const float photoncnt = 100.0f * aperture * exp / iso;</a>
<a name="ln368">  float saturation = 1.0f;</a>
<a name="ln369">  d-&gt;whitelevel = fmaxf(d-&gt;whitelevel, saturation * cal);</a>
<a name="ln370">#ifdef _OPENMP</a>
<a name="ln371">#pragma omp parallel for schedule(static) default(none) shared(d, saturation)</a>
<a name="ln372">#endif</a>
<a name="ln373">  for(int y = 0; y &lt; d-&gt;ht; y++)</a>
<a name="ln374">    for(int x = 0; x &lt; d-&gt;wd; x++)</a>
<a name="ln375">    {</a>
<a name="ln376">      // read unclamped raw value with subtracted black and rescaled to 1.0 saturation.</a>
<a name="ln377">      // this is the output of the rawprepare iop.</a>
<a name="ln378">      const float in = ((float *)ivoid)[x + d-&gt;wd * y];</a>
<a name="ln379">      // weights based on siggraph 12 poster</a>
<a name="ln380">      // zijian zhu, zhengguo li, susanto rahardja, pasi fraenti</a>
<a name="ln381">      // 2d denoising factor for high dynamic range imaging</a>
<a name="ln382">      float w = photoncnt;</a>
<a name="ln383"> </a>
<a name="ln384">      // need some safety margin due to upsampling and 16-bit quantization + dithering?</a>
<a name="ln385">      float offset = 3000.0f / (float)UINT16_MAX;</a>
<a name="ln386"> </a>
<a name="ln387">      // cannot do an envelope based on single pixel values here, need to get</a>
<a name="ln388">      // maximum value of all color channels. to find that, go through the</a>
<a name="ln389">      // pattern block (we conservatively do a 3x3 for bayer or xtrans):</a>
<a name="ln390">      int xx = x &amp; ~1, yy = y &amp; ~1;</a>
<a name="ln391">      float M = 0.0f, m = FLT_MAX;</a>
<a name="ln392">      if(xx &lt; d-&gt;wd - 2 &amp;&amp; yy &lt; d-&gt;ht - 2)</a>
<a name="ln393">      {</a>
<a name="ln394">        for(int i = 0; i &lt; 3; i++)</a>
<a name="ln395">          for(int j = 0; j &lt; 3; j++)</a>
<a name="ln396">          {</a>
<a name="ln397">            M = MAX(M, ((float *)ivoid)[xx + i + d-&gt;wd * (yy + j)]);</a>
<a name="ln398">            m = MIN(m, ((float *)ivoid)[xx + i + d-&gt;wd * (yy + j)]);</a>
<a name="ln399">          }</a>
<a name="ln400">        // move envelope a little to allow non-zero weight even for clipped regions.</a>
<a name="ln401">        // this is because even if the 2x2 block is clipped somewhere, the other channels</a>
<a name="ln402">        // might still prove useful. we'll check for individual channel saturation below.</a>
<a name="ln403">        w *= d-&gt;epsw + envelope((M + offset) / saturation);</a>
<a name="ln404">      }</a>
<a name="ln405"> </a>
<a name="ln406">      if(M + offset &gt;= saturation)</a>
<a name="ln407">      {</a>
<a name="ln408">        if(d-&gt;weight[x + d-&gt;wd * y] &lt;= 0.0f)</a>
<a name="ln409">        { // only consider saturated pixels in case we have nothing better:</a>
<a name="ln410">          if(d-&gt;weight[x + d-&gt;wd * y] == 0 || m &lt; -d-&gt;weight[x + d-&gt;wd * y])</a>
<a name="ln411">          {</a>
<a name="ln412">            if(m + offset &gt;= saturation)</a>
<a name="ln413">              d-&gt;pixels[x + d-&gt;wd * y] = 1.0f; // let's admit we were completely clipped, too</a>
<a name="ln414">            else</a>
<a name="ln415">              d-&gt;pixels[x + d-&gt;wd * y] = in * cal / d-&gt;whitelevel;</a>
<a name="ln416">            d-&gt;weight[x + d-&gt;wd * y]</a>
<a name="ln417">                = -m; // could use -cal here, but m is per pixel and safer for varying illumination conditions</a>
<a name="ln418">          }</a>
<a name="ln419">        }</a>
<a name="ln420">        // else silently ignore, others have filled in a better color here already</a>
<a name="ln421">      }</a>
<a name="ln422">      else</a>
<a name="ln423">      {</a>
<a name="ln424">        if(d-&gt;weight[x + d-&gt;wd * y] &lt;= 0.0)</a>
<a name="ln425">        { // cleanup potentially blown highlights from earlier images</a>
<a name="ln426">          d-&gt;pixels[x + d-&gt;wd * y] = 0.0f;</a>
<a name="ln427">          d-&gt;weight[x + d-&gt;wd * y] = 0.0f;</a>
<a name="ln428">        }</a>
<a name="ln429">        d-&gt;pixels[x + d-&gt;wd * y] += w * in * cal;</a>
<a name="ln430">        d-&gt;weight[x + d-&gt;wd * y] += w;</a>
<a name="ln431">      }</a>
<a name="ln432">    }</a>
<a name="ln433"> </a>
<a name="ln434">  return 0;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">static int32_t dt_control_merge_hdr_job_run(dt_job_t *job)</a>
<a name="ln438">{</a>
<a name="ln439">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln440">  GList *t = params-&gt;index;</a>
<a name="ln441">  const guint total = g_list_length(t);</a>
<a name="ln442">  char message[512] = { 0 };</a>
<a name="ln443">  double fraction = 0;</a>
<a name="ln444">  snprintf(message, sizeof(message), ngettext(&quot;merging %d image&quot;, &quot;merging %d images&quot;, total), total);</a>
<a name="ln445"> </a>
<a name="ln446">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln447"> </a>
<a name="ln448">  dt_control_merge_hdr_t d = (dt_control_merge_hdr_t){.epsw = 1e-8f, .abort = FALSE };</a>
<a name="ln449"> </a>
<a name="ln450">  dt_imageio_module_format_t buf = (dt_imageio_module_format_t){.mime = dt_control_merge_hdr_mime,</a>
<a name="ln451">                                                                .levels = dt_control_merge_hdr_levels,</a>
<a name="ln452">                                                                .bpp = dt_control_merge_hdr_bpp,</a>
<a name="ln453">                                                                .write_image = dt_control_merge_hdr_process };</a>
<a name="ln454"> </a>
<a name="ln455">  dt_control_merge_hdr_format_t dat = (dt_control_merge_hdr_format_t){.parent = { 0 }, .d = &amp;d };</a>
<a name="ln456"> </a>
<a name="ln457">  int num = 1;</a>
<a name="ln458">  while(t)</a>
<a name="ln459">  {</a>
<a name="ln460">    if(d.abort) goto end;</a>
<a name="ln461"> </a>
<a name="ln462">    const uint32_t imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln463"> </a>
<a name="ln464">    dt_imageio_export_with_flags(imgid, &quot;unused&quot;, &amp;buf, (dt_imageio_module_data_t *)&amp;dat, TRUE, FALSE, FALSE, TRUE,</a>
<a name="ln465">                                 FALSE, &quot;pre:rawprepare&quot;, FALSE, DT_COLORSPACE_NONE, NULL, DT_INTENT_LAST, NULL, NULL,</a>
<a name="ln466">                                 num, total);</a>
<a name="ln467"> </a>
<a name="ln468">    t = g_list_delete_link(t, t);</a>
<a name="ln469"> </a>
<a name="ln470">    /* update the progress bar */</a>
<a name="ln471">    fraction += 1.0 / (total + 1);</a>
<a name="ln472">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln473">    num++;</a>
<a name="ln474">  }</a>
<a name="ln475">  params-&gt;index = NULL;</a>
<a name="ln476"> </a>
<a name="ln477">  if(d.abort) goto end;</a>
<a name="ln478"> </a>
<a name="ln479">// normalize by white level to make clipping at 1.0 work as expected</a>
<a name="ln480"> </a>
<a name="ln481">#ifdef _OPENMP</a>
<a name="ln482">#pragma omp parallel for schedule(static) default(none) shared(d)</a>
<a name="ln483">#endif</a>
<a name="ln484">  for(size_t k = 0; k &lt; (size_t)d.wd * d.ht; k++)</a>
<a name="ln485">  {</a>
<a name="ln486">    if(d.weight[k] &gt; 0.0) d.pixels[k] = fmaxf(0.0f, d.pixels[k] / (d.whitelevel * d.weight[k]));</a>
<a name="ln487">  }</a>
<a name="ln488"> </a>
<a name="ln489">  // output hdr as digital negative with exif data.</a>
<a name="ln490">  uint8_t *exif = NULL;</a>
<a name="ln491">  char pathname[PATH_MAX] = { 0 };</a>
<a name="ln492">  gboolean from_cache = TRUE;</a>
<a name="ln493">  dt_image_full_path(d.first_imgid, pathname, sizeof(pathname), &amp;from_cache);</a>
<a name="ln494"> </a>
<a name="ln495">  // last param is dng mode</a>
<a name="ln496">  const int exif_len = dt_exif_read_blob(&amp;exif, pathname, d.first_imgid, 0, d.wd, d.ht, 1);</a>
<a name="ln497">  char *c = pathname + strlen(pathname);</a>
<a name="ln498">  while(*c != '.' &amp;&amp; c &gt; pathname) c--;</a>
<a name="ln499">  g_strlcpy(c, &quot;-hdr.dng&quot;, sizeof(pathname) - (c - pathname));</a>
<a name="ln500">  dt_imageio_write_dng(pathname, d.pixels, d.wd, d.ht, exif, exif_len, d.first_filter, (const uint8_t (*)[6])d.first_xtrans, 1.0f);</a>
<a name="ln501">  free(exif);</a>
<a name="ln502"> </a>
<a name="ln503">  dt_control_job_set_progress(job, 1.0);</a>
<a name="ln504"> </a>
<a name="ln505">  while(*c != '/' &amp;&amp; c &gt; pathname) c--;</a>
<a name="ln506">  dt_control_log(_(&quot;wrote merged HDR `%s'&quot;), c + 1);</a>
<a name="ln507"> </a>
<a name="ln508">  // import new image</a>
<a name="ln509">  gchar *directory = g_path_get_dirname((const gchar *)pathname);</a>
<a name="ln510">  dt_film_t film;</a>
<a name="ln511">  const int filmid = dt_film_new(&amp;film, directory);</a>
<a name="ln512">  dt_image_import(filmid, pathname, TRUE);</a>
<a name="ln513">  g_free(directory);</a>
<a name="ln514"> </a>
<a name="ln515">end:</a>
<a name="ln516">  free(d.pixels);</a>
<a name="ln517">  free(d.weight);</a>
<a name="ln518"> </a>
<a name="ln519">  dt_control_queue_redraw_center();</a>
<a name="ln520">  return 0;</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523">static int32_t dt_control_duplicate_images_job_run(dt_job_t *job)</a>
<a name="ln524">{</a>
<a name="ln525">  int imgid = -1;</a>
<a name="ln526">  int newimgid = -1;</a>
<a name="ln527">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln528">  GList *t = params-&gt;index;</a>
<a name="ln529">  guint total = g_list_length(t);</a>
<a name="ln530">  char message[512] = { 0 };</a>
<a name="ln531">  double fraction = 0;</a>
<a name="ln532">  snprintf(message, sizeof(message), ngettext(&quot;duplicating %d image&quot;, &quot;duplicating %d images&quot;, total), total);</a>
<a name="ln533">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln534">  while(t)</a>
<a name="ln535">  {</a>
<a name="ln536">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln537">    newimgid = dt_image_duplicate(imgid);</a>
<a name="ln538">    if(newimgid != -1) dt_history_copy_and_paste_on_image(imgid, newimgid, FALSE, NULL);</a>
<a name="ln539">    t = g_list_delete_link(t, t);</a>
<a name="ln540">    fraction = 1.0 / total;</a>
<a name="ln541">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln542">  }</a>
<a name="ln543">  params-&gt;index = NULL;</a>
<a name="ln544">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln545">  dt_control_queue_redraw_center();</a>
<a name="ln546">  return 0;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">static int32_t dt_control_flip_images_job_run(dt_job_t *job)</a>
<a name="ln550">{</a>
<a name="ln551">  int imgid = -1;</a>
<a name="ln552">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln553">  const int cw = params-&gt;flag;</a>
<a name="ln554">  GList *t = params-&gt;index;</a>
<a name="ln555">  guint total = g_list_length(t);</a>
<a name="ln556">  double fraction = 0;</a>
<a name="ln557">  char message[512] = { 0 };</a>
<a name="ln558">  snprintf(message, sizeof(message), ngettext(&quot;flipping %d image&quot;, &quot;flipping %d images&quot;, total), total);</a>
<a name="ln559">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln560">  while(t)</a>
<a name="ln561">  {</a>
<a name="ln562">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln563">    dt_image_flip(imgid, cw);</a>
<a name="ln564">    t = g_list_delete_link(t, t);</a>
<a name="ln565">    fraction = 1.0 / total;</a>
<a name="ln566">    dt_image_set_aspect_ratio(imgid);</a>
<a name="ln567">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln568">  }</a>
<a name="ln569">  params-&gt;index = NULL;</a>
<a name="ln570">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln571">  dt_control_queue_redraw_center();</a>
<a name="ln572">  return 0;</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">static char *_get_image_list(GList *l)</a>
<a name="ln576">{</a>
<a name="ln577">  const guint size = g_list_length(l);</a>
<a name="ln578">  char num[8];</a>
<a name="ln579">  char *buffer = calloc(size, sizeof(num));</a>
<a name="ln580">  int imgid;</a>
<a name="ln581">  gboolean first = TRUE;</a>
<a name="ln582"> </a>
<a name="ln583">  buffer[0] = '\0';</a>
<a name="ln584"> </a>
<a name="ln585">  while(l)</a>
<a name="ln586">  {</a>
<a name="ln587">    imgid = GPOINTER_TO_INT(l-&gt;data);</a>
<a name="ln588">    snprintf(num, sizeof(num), &quot;%s%6d&quot;, first ? &quot;&quot; : &quot;,&quot;, imgid);</a>
<a name="ln589">    g_strlcat(buffer, num, size * sizeof(num));</a>
<a name="ln590">    l = g_list_next(l);</a>
<a name="ln591">    first = FALSE;</a>
<a name="ln592">  }</a>
<a name="ln593">  return buffer;</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">static void _set_remove_flag(char *imgs)</a>
<a name="ln597">{</a>
<a name="ln598">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln599">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln600">                              &quot;UPDATE main.images SET flags = (flags|?1) WHERE id IN (?2)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln601">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, DT_IMAGE_REMOVE);</a>
<a name="ln602">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgs, -1, SQLITE_STATIC);</a>
<a name="ln603">  sqlite3_step(stmt);</a>
<a name="ln604">  sqlite3_finalize(stmt);</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">static GList *_get_full_pathname(char *imgs)</a>
<a name="ln608">{</a>
<a name="ln609">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln610">  GList *list = NULL;</a>
<a name="ln611"> </a>
<a name="ln612">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT DISTINCT folder || '&quot; G_DIR_SEPARATOR_S &quot;' || filename FROM &quot;</a>
<a name="ln613">                                                             &quot;main.images i, main.film_rolls f &quot;</a>
<a name="ln614">                                                             &quot;ON i.film_id = f.id WHERE i.id IN (?1)&quot;,</a>
<a name="ln615">                              -1, &amp;stmt, NULL);</a>
<a name="ln616">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, imgs, -1, SQLITE_STATIC);</a>
<a name="ln617">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln618">  {</a>
<a name="ln619">    list = g_list_append(list, g_strdup((const gchar *)sqlite3_column_text(stmt, 0)));</a>
<a name="ln620">  }</a>
<a name="ln621">  sqlite3_finalize(stmt);</a>
<a name="ln622">  return list;</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">static int32_t dt_control_remove_images_job_run(dt_job_t *job)</a>
<a name="ln626">{</a>
<a name="ln627">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln628">  GList *t = params-&gt;index;</a>
<a name="ln629">  char *imgs = _get_image_list(t);</a>
<a name="ln630">  guint total = g_list_length(t);</a>
<a name="ln631">  char message[512] = { 0 };</a>
<a name="ln632">  double fraction = 0;</a>
<a name="ln633">  snprintf(message, sizeof(message), ngettext(&quot;removing %d image&quot;, &quot;removing %d images&quot;, total), total);</a>
<a name="ln634">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln635">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln636"> </a>
<a name="ln637">  // check that we can safely remove the image</a>
<a name="ln638">  gboolean remove_ok = TRUE;</a>
<a name="ln639">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln640">                              &quot;SELECT id FROM main.images WHERE id IN (?2) AND flags&amp;?1=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln641">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, DT_IMAGE_LOCAL_COPY);</a>
<a name="ln642">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgs, -1, SQLITE_STATIC);</a>
<a name="ln643"> </a>
<a name="ln644">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln645">  {</a>
<a name="ln646">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln647">    if(!dt_image_safe_remove(imgid))</a>
<a name="ln648">    {</a>
<a name="ln649">      remove_ok = FALSE;</a>
<a name="ln650">      break;</a>
<a name="ln651">    }</a>
<a name="ln652">  }</a>
<a name="ln653">  sqlite3_finalize(stmt);</a>
<a name="ln654"> </a>
<a name="ln655">  if(!remove_ok)</a>
<a name="ln656">  {</a>
<a name="ln657">    dt_control_log(_(&quot;cannot remove local copy when the original file is not accessible.&quot;));</a>
<a name="ln658">    free(imgs);</a>
<a name="ln659">    return 0;</a>
<a name="ln660">  }</a>
<a name="ln661"> </a>
<a name="ln662">  // update remove status</a>
<a name="ln663">  _set_remove_flag(imgs);</a>
<a name="ln664"> </a>
<a name="ln665">  dt_collection_update(darktable.collection);</a>
<a name="ln666"> </a>
<a name="ln667">  // We need a list of files to regenerate .xmp files if there are duplicates</a>
<a name="ln668">  GList *list = _get_full_pathname(imgs);</a>
<a name="ln669"> </a>
<a name="ln670">  free(imgs);</a>
<a name="ln671"> </a>
<a name="ln672">  while(t)</a>
<a name="ln673">  {</a>
<a name="ln674">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln675">    dt_image_remove(imgid);</a>
<a name="ln676">    t = g_list_delete_link(t, t);</a>
<a name="ln677">    fraction = 1.0 / total;</a>
<a name="ln678">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln679">  }</a>
<a name="ln680">  params-&gt;index = NULL;</a>
<a name="ln681"> </a>
<a name="ln682">  char *imgname;</a>
<a name="ln683">  while(list)</a>
<a name="ln684">  {</a>
<a name="ln685">    imgname = (char *)list-&gt;data;</a>
<a name="ln686">    dt_image_synch_all_xmp(imgname);</a>
<a name="ln687">    list = g_list_delete_link(list, list);</a>
<a name="ln688">  }</a>
<a name="ln689">  dt_film_remove_empty();</a>
<a name="ln690">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln691">  dt_control_queue_redraw_center();</a>
<a name="ln692">  return 0;</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">typedef struct _dt_delete_modal_dialog_t</a>
<a name="ln696">{</a>
<a name="ln697">  int send_to_trash;</a>
<a name="ln698">  const char *filename;</a>
<a name="ln699">  const char *error_message;</a>
<a name="ln700"> </a>
<a name="ln701">  gint dialog_result;</a>
<a name="ln702"> </a>
<a name="ln703">  dt_pthread_mutex_t mutex;</a>
<a name="ln704">  pthread_cond_t cond;</a>
<a name="ln705">} _dt_delete_modal_dialog_t;</a>
<a name="ln706"> </a>
<a name="ln707">enum _dt_delete_status</a>
<a name="ln708">{</a>
<a name="ln709">  _DT_DELETE_STATUS_UNKNOWN = 0,</a>
<a name="ln710">  _DT_DELETE_STATUS_OK_TO_REMOVE = 1,</a>
<a name="ln711">  _DT_DELETE_STATUS_SKIP_FILE = 2,</a>
<a name="ln712">  _DT_DELETE_STATUS_STOP_PROCESSING = 3</a>
<a name="ln713">};</a>
<a name="ln714"> </a>
<a name="ln715">enum _dt_delete_dialog_choice</a>
<a name="ln716">{</a>
<a name="ln717">  _DT_DELETE_DIALOG_CHOICE_DELETE = 1,</a>
<a name="ln718">  _DT_DELETE_DIALOG_CHOICE_DELETE_ALL = 2,</a>
<a name="ln719">  _DT_DELETE_DIALOG_CHOICE_REMOVE = 3,</a>
<a name="ln720">  _DT_DELETE_DIALOG_CHOICE_CONTINUE = 4,</a>
<a name="ln721">  _DT_DELETE_DIALOG_CHOICE_STOP = 5</a>
<a name="ln722">};</a>
<a name="ln723"> </a>
<a name="ln724">static gboolean _dt_delete_dialog_main_thread(gpointer user_data)</a>
<a name="ln725">{</a>
<a name="ln726">  _dt_delete_modal_dialog_t* modal_dialog = (_dt_delete_modal_dialog_t*)user_data;</a>
<a name="ln727">  dt_pthread_mutex_lock(&amp;modal_dialog-&gt;mutex);</a>
<a name="ln728"> </a>
<a name="ln729">  GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln730">      GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)),</a>
<a name="ln731">      GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln732">      GTK_MESSAGE_QUESTION,</a>
<a name="ln733">      GTK_BUTTONS_NONE,</a>
<a name="ln734">      modal_dialog-&gt;send_to_trash</a>
<a name="ln735">        ? _(&quot;could not send %s to trash%s%s&quot;)</a>
<a name="ln736">        : _(&quot;could not physically delete %s%s%s&quot;),</a>
<a name="ln737">      modal_dialog-&gt;filename,</a>
<a name="ln738">      modal_dialog-&gt;error_message != NULL ? &quot;: &quot; : &quot;&quot;,</a>
<a name="ln739">      modal_dialog-&gt;error_message != NULL ? modal_dialog-&gt;error_message : &quot;&quot;);</a>
<a name="ln740">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln741">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln742">#endif</a>
<a name="ln743"> </a>
<a name="ln744">  if (modal_dialog-&gt;send_to_trash)</a>
<a name="ln745">  {</a>
<a name="ln746">    gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;physically delete&quot;), _DT_DELETE_DIALOG_CHOICE_DELETE);</a>
<a name="ln747">    gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;physically delete all files&quot;), _DT_DELETE_DIALOG_CHOICE_DELETE_ALL);</a>
<a name="ln748">  }</a>
<a name="ln749">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;only remove from the collection&quot;), _DT_DELETE_DIALOG_CHOICE_REMOVE);</a>
<a name="ln750">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;skip to next file&quot;), _DT_DELETE_DIALOG_CHOICE_CONTINUE);</a>
<a name="ln751">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;stop process&quot;), _DT_DELETE_DIALOG_CHOICE_STOP);</a>
<a name="ln752"> </a>
<a name="ln753">  gtk_window_set_title(</a>
<a name="ln754">      GTK_WINDOW(dialog),</a>
<a name="ln755">      modal_dialog-&gt;send_to_trash</a>
<a name="ln756">        ? _(&quot;trashing error&quot;)</a>
<a name="ln757">        : _(&quot;deletion error&quot;));</a>
<a name="ln758">  modal_dialog-&gt;dialog_result = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln759">  gtk_widget_destroy(dialog);</a>
<a name="ln760"> </a>
<a name="ln761">  pthread_cond_signal(&amp;modal_dialog-&gt;cond);</a>
<a name="ln762"> </a>
<a name="ln763">  dt_pthread_mutex_unlock(&amp;modal_dialog-&gt;mutex);</a>
<a name="ln764"> </a>
<a name="ln765">  // Don't call again on next idle time</a>
<a name="ln766">  return FALSE;</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">static gint _dt_delete_file_display_modal_dialog(int send_to_trash, const char *filename, const char *error_message)</a>
<a name="ln770">{</a>
<a name="ln771">  _dt_delete_modal_dialog_t modal_dialog;</a>
<a name="ln772">  modal_dialog.send_to_trash = send_to_trash;</a>
<a name="ln773">  modal_dialog.filename = filename;</a>
<a name="ln774">  modal_dialog.error_message = error_message;</a>
<a name="ln775"> </a>
<a name="ln776">  modal_dialog.dialog_result = GTK_RESPONSE_NONE;</a>
<a name="ln777"> </a>
<a name="ln778">  dt_pthread_mutex_init(&amp;modal_dialog.mutex, NULL);</a>
<a name="ln779">  pthread_cond_init(&amp;modal_dialog.cond, NULL);</a>
<a name="ln780"> </a>
<a name="ln781">  dt_pthread_mutex_lock(&amp;modal_dialog.mutex);</a>
<a name="ln782"> </a>
<a name="ln783">  gdk_threads_add_idle(_dt_delete_dialog_main_thread, &amp;modal_dialog);</a>
<a name="ln784">  while (modal_dialog.dialog_result == GTK_RESPONSE_NONE)</a>
<a name="ln785">    dt_pthread_cond_wait(&amp;modal_dialog.cond, &amp;modal_dialog.mutex);</a>
<a name="ln786"> </a>
<a name="ln787">  dt_pthread_mutex_unlock(&amp;modal_dialog.mutex);</a>
<a name="ln788">  dt_pthread_mutex_destroy(&amp;modal_dialog.mutex);</a>
<a name="ln789">  pthread_cond_destroy(&amp;modal_dialog.cond);</a>
<a name="ln790"> </a>
<a name="ln791">  return modal_dialog.dialog_result;</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">static enum _dt_delete_status delete_file_from_disk(const char *filename, gboolean *delete_on_trash_error)</a>
<a name="ln795">{</a>
<a name="ln796">  enum _dt_delete_status delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln797"> </a>
<a name="ln798">  GFile *gfile = g_file_new_for_path(filename);</a>
<a name="ln799">  int send_to_trash = dt_conf_get_bool(&quot;send_to_trash&quot;);</a>
<a name="ln800"> </a>
<a name="ln801">  while (delete_status == _DT_DELETE_STATUS_UNKNOWN)</a>
<a name="ln802">  {</a>
<a name="ln803">    gboolean delete_success = FALSE;</a>
<a name="ln804">    GError *gerror = NULL;</a>
<a name="ln805">    if (send_to_trash)</a>
<a name="ln806">    {</a>
<a name="ln807">#ifdef __APPLE__</a>
<a name="ln808">      delete_success = dt_osx_file_trash(filename, &amp;gerror);</a>
<a name="ln809">#elif defined(_WIN32)</a>
<a name="ln810">      delete_success = dt_win_file_trash(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln811">#else</a>
<a name="ln812">      delete_success = g_file_trash(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln813">#endif</a>
<a name="ln814">    }</a>
<a name="ln815">    else</a>
<a name="ln816">    {</a>
<a name="ln817">      delete_success = g_file_delete(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln818">    }</a>
<a name="ln819"> </a>
<a name="ln820">    // Delete is a success or the file does not exists: OK to remove from collection</a>
<a name="ln821">    if (delete_success</a>
<a name="ln822">        || g_error_matches(gerror, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))</a>
<a name="ln823">    {</a>
<a name="ln824">      delete_status = _DT_DELETE_STATUS_OK_TO_REMOVE;</a>
<a name="ln825">    }</a>
<a name="ln826">    else if (send_to_trash &amp;&amp; *delete_on_trash_error)</a>
<a name="ln827">    {</a>
<a name="ln828">      // Loop again, this time delete instead of trashing</a>
<a name="ln829">      delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln830">      send_to_trash = FALSE;</a>
<a name="ln831">    }</a>
<a name="ln832">    else</a>
<a name="ln833">    {</a>
<a name="ln834">      const char *filename_display = NULL;</a>
<a name="ln835">      GFileInfo *gfileinfo = g_file_query_info(</a>
<a name="ln836">          gfile,</a>
<a name="ln837">          G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,</a>
<a name="ln838">          G_FILE_QUERY_INFO_NONE,</a>
<a name="ln839">          NULL /*cancellable*/,</a>
<a name="ln840">          NULL /*error*/);</a>
<a name="ln841">      if (gfileinfo != NULL)</a>
<a name="ln842">        filename_display = g_file_info_get_attribute_string(</a>
<a name="ln843">            gfileinfo,</a>
<a name="ln844">            G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME);</a>
<a name="ln845"> </a>
<a name="ln846">      gint res = _dt_delete_file_display_modal_dialog(</a>
<a name="ln847">          send_to_trash,</a>
<a name="ln848">          filename_display == NULL ? filename : filename_display,</a>
<a name="ln849">          gerror == NULL ? NULL : gerror-&gt;message);</a>
<a name="ln850"> </a>
<a name="ln851">      if (send_to_trash &amp;&amp; res == _DT_DELETE_DIALOG_CHOICE_DELETE)</a>
<a name="ln852">      {</a>
<a name="ln853">        // Loop again, this time delete instead of trashing</a>
<a name="ln854">        delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln855">        send_to_trash = FALSE;</a>
<a name="ln856">      }</a>
<a name="ln857">      else if (send_to_trash &amp;&amp; res == _DT_DELETE_DIALOG_CHOICE_DELETE_ALL)</a>
<a name="ln858">      {</a>
<a name="ln859">        // Loop again, this time delete instead of trashing</a>
<a name="ln860">        delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln861">        send_to_trash = FALSE;</a>
<a name="ln862">        *delete_on_trash_error = TRUE;</a>
<a name="ln863">      }</a>
<a name="ln864">      else if (res == _DT_DELETE_DIALOG_CHOICE_REMOVE)</a>
<a name="ln865">      {</a>
<a name="ln866">        delete_status = _DT_DELETE_STATUS_OK_TO_REMOVE;</a>
<a name="ln867">      }</a>
<a name="ln868">      else if (res == _DT_DELETE_DIALOG_CHOICE_CONTINUE)</a>
<a name="ln869">      {</a>
<a name="ln870">        delete_status = _DT_DELETE_STATUS_SKIP_FILE;</a>
<a name="ln871">      }</a>
<a name="ln872">      else</a>
<a name="ln873">      {</a>
<a name="ln874">        delete_status = _DT_DELETE_STATUS_STOP_PROCESSING;</a>
<a name="ln875">      }</a>
<a name="ln876">    }</a>
<a name="ln877">    if (gerror != NULL)</a>
<a name="ln878">      g_error_free(gerror);</a>
<a name="ln879">  }</a>
<a name="ln880"> </a>
<a name="ln881">  if (gfile != NULL)</a>
<a name="ln882">    g_object_unref(gfile);</a>
<a name="ln883"> </a>
<a name="ln884">  return delete_status;</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887"> </a>
<a name="ln888">static int32_t dt_control_delete_images_job_run(dt_job_t *job)</a>
<a name="ln889">{</a>
<a name="ln890">  int imgid = -1;</a>
<a name="ln891">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln892">  GList *t = params-&gt;index;</a>
<a name="ln893">  char *imgs = _get_image_list(t);</a>
<a name="ln894">  char imgidstr[25] = { 0 };</a>
<a name="ln895">  guint total = g_list_length(t);</a>
<a name="ln896">  char message[512] = { 0 };</a>
<a name="ln897">  double fraction = 0;</a>
<a name="ln898">  gboolean delete_on_trash_error = FALSE;</a>
<a name="ln899">  if (dt_conf_get_bool(&quot;send_to_trash&quot;))</a>
<a name="ln900">    snprintf(message, sizeof(message), ngettext(&quot;trashing %d image&quot;, &quot;trashing %d images&quot;, total), total);</a>
<a name="ln901">  else</a>
<a name="ln902">    snprintf(message, sizeof(message), ngettext(&quot;deleting %d image&quot;, &quot;deleting %d images&quot;, total), total);</a>
<a name="ln903">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln904"> </a>
<a name="ln905">  sqlite3_stmt *stmt;</a>
<a name="ln906"> </a>
<a name="ln907">  dt_collection_update(darktable.collection);</a>
<a name="ln908"> </a>
<a name="ln909">  // We need a list of files to regenerate .xmp files if there are duplicates</a>
<a name="ln910">  GList *list = _get_full_pathname(imgs);</a>
<a name="ln911"> </a>
<a name="ln912">  free(imgs);</a>
<a name="ln913"> </a>
<a name="ln914">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln915">                              &quot;SELECT COUNT(*) FROM main.images WHERE filename IN (SELECT filename FROM &quot;</a>
<a name="ln916">                              &quot;main.images WHERE id = ?1) AND film_id IN (SELECT film_id FROM main.images WHERE &quot;</a>
<a name="ln917">                              &quot;id = ?1)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln918">  while(t)</a>
<a name="ln919">  {</a>
<a name="ln920">    enum _dt_delete_status delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln921">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln922">    char filename[PATH_MAX] = { 0 };</a>
<a name="ln923">    gboolean from_cache = FALSE;</a>
<a name="ln924">    dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln925"> </a>
<a name="ln926">#ifdef _WIN32</a>
<a name="ln927">    char *dirname = g_path_get_dirname(filename);</a>
<a name="ln928">#endif</a>
<a name="ln929"> </a>
<a name="ln930">    int duplicates = 0;</a>
<a name="ln931">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln932">    if(sqlite3_step(stmt) == SQLITE_ROW) duplicates = sqlite3_column_int(stmt, 0);</a>
<a name="ln933">    sqlite3_reset(stmt);</a>
<a name="ln934">    sqlite3_clear_bindings(stmt);</a>
<a name="ln935"> </a>
<a name="ln936">    // remove from disk:</a>
<a name="ln937">    if(duplicates == 1)</a>
<a name="ln938">    {</a>
<a name="ln939">      // first check for local copies, never delete a file whose original file is not accessible</a>
<a name="ln940">      if (dt_image_local_copy_reset(imgid))</a>
<a name="ln941">        goto delete_next_file;</a>
<a name="ln942"> </a>
<a name="ln943">      snprintf(imgidstr, sizeof(imgidstr), &quot;%d&quot;, imgid);</a>
<a name="ln944">      _set_remove_flag(imgidstr);</a>
<a name="ln945">      dt_image_remove(imgid);</a>
<a name="ln946"> </a>
<a name="ln947">      // there are no further duplicates so we can remove the source data file</a>
<a name="ln948">      delete_status = delete_file_from_disk(filename, &amp;delete_on_trash_error);</a>
<a name="ln949">      if (delete_status != _DT_DELETE_STATUS_OK_TO_REMOVE)</a>
<a name="ln950">        goto delete_next_file;</a>
<a name="ln951"> </a>
<a name="ln952">      // all sidecar files - including left-overs - can be deleted;</a>
<a name="ln953">      // left-overs can result when previously duplicates have been REMOVED;</a>
<a name="ln954">      // no need to keep them as the source data file is gone.</a>
<a name="ln955">      gchar pattern[PATH_MAX] = { 0 };</a>
<a name="ln956"> </a>
<a name="ln957">      // NULL terminated list of glob patterns; should include &quot;&quot; and can be extended if needed</a>
<a name="ln958">      static const gchar *glob_patterns[]</a>
<a name="ln959">          = { &quot;&quot;, &quot;_[0-9][0-9]&quot;, &quot;_[0-9][0-9][0-9]&quot;, &quot;_[0-9][0-9][0-9][0-9]&quot;, NULL };</a>
<a name="ln960"> </a>
<a name="ln961">      const gchar **glob_pattern = glob_patterns;</a>
<a name="ln962">      GList *files = NULL;</a>
<a name="ln963">      while(*glob_pattern)</a>
<a name="ln964">      {</a>
<a name="ln965">        snprintf(pattern, sizeof(pattern), &quot;%s&quot;, filename);</a>
<a name="ln966">        gchar *c1 = pattern + strlen(pattern);</a>
<a name="ln967">        while(*c1 != '.' &amp;&amp; c1 &gt; pattern) c1--;</a>
<a name="ln968">        snprintf(c1, pattern + sizeof(pattern) - c1, &quot;%s&quot;, *glob_pattern);</a>
<a name="ln969">        const gchar *c2 = filename + strlen(filename);</a>
<a name="ln970">        while(*c2 != '.' &amp;&amp; c2 &gt; filename) c2--;</a>
<a name="ln971">        snprintf(c1 + strlen(*glob_pattern), pattern + sizeof(pattern) - c1 - strlen(*glob_pattern), &quot;%s.xmp&quot;,</a>
<a name="ln972">                 c2);</a>
<a name="ln973"> </a>
<a name="ln974">#ifdef _WIN32</a>
<a name="ln975">        wchar_t *wpattern = g_utf8_to_utf16(pattern, -1, NULL, NULL, NULL);</a>
<a name="ln976">        WIN32_FIND_DATAW data;</a>
<a name="ln977">        HANDLE handle = FindFirstFileW(wpattern, &amp;data);</a>
<a name="ln978">        g_free(wpattern);</a>
<a name="ln979">        if(handle != INVALID_HANDLE_VALUE)</a>
<a name="ln980">        {</a>
<a name="ln981">          do</a>
<a name="ln982">          {</a>
<a name="ln983">            char *xmp_filename = g_utf16_to_utf8(data.cFileName, -1, NULL, NULL, NULL);</a>
<a name="ln984">            files = g_list_append(files, g_build_filename(dirname, xmp_filename, NULL));</a>
<a name="ln985">            g_free(xmp_filename);</a>
<a name="ln986">          }</a>
<a name="ln987">          while(FindNextFileW(handle, &amp;data));</a>
<a name="ln988">        }</a>
<a name="ln989">#else</a>
<a name="ln990">        glob_t globbuf;</a>
<a name="ln991">        if(!glob(pattern, 0, NULL, &amp;globbuf))</a>
<a name="ln992">        {</a>
<a name="ln993">          for(size_t i = 0; i &lt; globbuf.gl_pathc; i++)</a>
<a name="ln994">            files = g_list_append(files, g_strdup(globbuf.gl_pathv[i]));</a>
<a name="ln995">          globfree(&amp;globbuf);</a>
<a name="ln996">        }</a>
<a name="ln997">#endif</a>
<a name="ln998"> </a>
<a name="ln999">        glob_pattern++;</a>
<a name="ln1000">      }</a>
<a name="ln1001"> </a>
<a name="ln1002">      GList *file_iter = g_list_first(files);</a>
<a name="ln1003">      while(file_iter != NULL)</a>
<a name="ln1004">      {</a>
<a name="ln1005">        delete_status = delete_file_from_disk(file_iter-&gt;data, &amp;delete_on_trash_error);</a>
<a name="ln1006">        if (delete_status != _DT_DELETE_STATUS_OK_TO_REMOVE)</a>
<a name="ln1007">          break;</a>
<a name="ln1008">        file_iter = g_list_next(file_iter);</a>
<a name="ln1009">      }</a>
<a name="ln1010"> </a>
<a name="ln1011">      g_list_free_full(files, g_free);</a>
<a name="ln1012">    }</a>
<a name="ln1013">    else</a>
<a name="ln1014">    {</a>
<a name="ln1015">      // don't remove the actual source data if there are further duplicates using it;</a>
<a name="ln1016">      // just delete the xmp file of the duplicate selected.</a>
<a name="ln1017"> </a>
<a name="ln1018">      dt_image_path_append_version(imgid, filename, sizeof(filename));</a>
<a name="ln1019">      g_strlcat(filename, &quot;.xmp&quot;, sizeof(filename));</a>
<a name="ln1020"> </a>
<a name="ln1021">      // remove image from db first ...</a>
<a name="ln1022">      snprintf(imgidstr, sizeof(imgidstr), &quot;%d&quot;, imgid);</a>
<a name="ln1023">      _set_remove_flag(imgidstr);</a>
<a name="ln1024">      dt_image_remove(imgid);</a>
<a name="ln1025"> </a>
<a name="ln1026">      // ... and delete afterwards because removing will re-write the XMP</a>
<a name="ln1027">      delete_status = delete_file_from_disk(filename, &amp;delete_on_trash_error);</a>
<a name="ln1028">    }</a>
<a name="ln1029"> </a>
<a name="ln1030">delete_next_file:</a>
<a name="ln1031">#ifdef _WIN32</a>
<a name="ln1032">    g_free(dirname);</a>
<a name="ln1033">#endif</a>
<a name="ln1034">    t = g_list_delete_link(t, t);</a>
<a name="ln1035">    fraction = 1.0 / total;</a>
<a name="ln1036">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1037">    if (delete_status == _DT_DELETE_STATUS_STOP_PROCESSING)</a>
<a name="ln1038">      break;</a>
<a name="ln1039">  }</a>
<a name="ln1040">  while (t)</a>
<a name="ln1041">    t = g_list_delete_link(t, t);</a>
<a name="ln1042">  params-&gt;index = NULL;</a>
<a name="ln1043">  sqlite3_finalize(stmt);</a>
<a name="ln1044"> </a>
<a name="ln1045">  char *imgname;</a>
<a name="ln1046">  while(list)</a>
<a name="ln1047">  {</a>
<a name="ln1048">    imgname = (char *)list-&gt;data;</a>
<a name="ln1049">    dt_image_synch_all_xmp(imgname);</a>
<a name="ln1050">    list = g_list_delete_link(list, list);</a>
<a name="ln1051">  }</a>
<a name="ln1052">  g_list_free(list);</a>
<a name="ln1053">  dt_film_remove_empty();</a>
<a name="ln1054">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln1055">  dt_control_queue_redraw_center();</a>
<a name="ln1056">  return 0;</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059">static void _pop_undo(gpointer user_data, dt_undo_type_t type, dt_undo_data_t item, dt_undo_action_t action)</a>
<a name="ln1060">{</a>
<a name="ln1061">  dt_undo_geotag_t *geotags = (dt_undo_geotag_t *)item;</a>
<a name="ln1062">  GList *l;</a>
<a name="ln1063"> </a>
<a name="ln1064">  if(action == DT_ACTION_UNDO)</a>
<a name="ln1065">    l = geotags-&gt;before;</a>
<a name="ln1066">  else</a>
<a name="ln1067">    l = geotags-&gt;after;</a>
<a name="ln1068"> </a>
<a name="ln1069">  while(l)</a>
<a name="ln1070">  {</a>
<a name="ln1071">    const int imgid = GPOINTER_TO_INT((dt_image_geoloc_t *)l-&gt;data);</a>
<a name="ln1072"> </a>
<a name="ln1073">    l = g_list_next(l);</a>
<a name="ln1074">    dt_image_geoloc_t *geoloc = (dt_image_geoloc_t *)l-&gt;data;</a>
<a name="ln1075">    dt_image_set_location_and_elevation(imgid, geoloc);</a>
<a name="ln1076"> </a>
<a name="ln1077">    l = g_list_next(l);</a>
<a name="ln1078">  }</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">void _geotags_free_undo_data_t(gpointer data)</a>
<a name="ln1082">{</a>
<a name="ln1083">  dt_undo_geotag_t *geotags = (dt_undo_geotag_t *)data;</a>
<a name="ln1084">  GList *lb = geotags-&gt;before;</a>
<a name="ln1085">  GList *la = geotags-&gt;after;</a>
<a name="ln1086"> </a>
<a name="ln1087">  do</a>
<a name="ln1088">  {</a>
<a name="ln1089">    if(la) la = g_list_next(la);</a>
<a name="ln1090">    if(la) g_free((dt_image_geoloc_t *)la-&gt;data);</a>
<a name="ln1091">    if(lb) lb = g_list_next(lb);</a>
<a name="ln1092">    if(lb) g_free((dt_image_geoloc_t *)lb-&gt;data);</a>
<a name="ln1093">    if(la) la = g_list_next(la);</a>
<a name="ln1094">    if(lb) lb = g_list_next(lb);</a>
<a name="ln1095">  } while(la || lb);</a>
<a name="ln1096"> </a>
<a name="ln1097">  g_list_free(geotags-&gt;before);</a>
<a name="ln1098">  g_list_free(geotags-&gt;after);</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">static int32_t dt_control_gpx_apply_job_run(dt_job_t *job)</a>
<a name="ln1102">{</a>
<a name="ln1103">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln1104">  GList *t = params-&gt;index;</a>
<a name="ln1105">  struct dt_gpx_t *gpx = NULL;</a>
<a name="ln1106">  uint32_t cntr = 0;</a>
<a name="ln1107">  const dt_control_gpx_apply_t *d = params-&gt;data;</a>
<a name="ln1108">  const gchar *filename = d-&gt;filename;</a>
<a name="ln1109">  const gchar *tz = d-&gt;tz;</a>
<a name="ln1110"> </a>
<a name="ln1111">  /* do we have any selected images */</a>
<a name="ln1112">  if(!t) goto bail_out;</a>
<a name="ln1113"> </a>
<a name="ln1114">  /* try parse the gpx data */</a>
<a name="ln1115">  gpx = dt_gpx_new(filename);</a>
<a name="ln1116">  if(!gpx)</a>
<a name="ln1117">  {</a>
<a name="ln1118">    dt_control_log(_(&quot;failed to parse GPX file&quot;));</a>
<a name="ln1119">    goto bail_out;</a>
<a name="ln1120">  }</a>
<a name="ln1121"> </a>
<a name="ln1122">  GTimeZone *tz_camera = (tz == NULL) ? g_time_zone_new_utc() : g_time_zone_new(tz);</a>
<a name="ln1123">  if(!tz_camera) goto bail_out;</a>
<a name="ln1124">  GTimeZone *tz_utc = g_time_zone_new_utc();</a>
<a name="ln1125"> </a>
<a name="ln1126">  dt_undo_geotag_t *geotags = g_malloc0(sizeof(dt_undo_geotag_t));</a>
<a name="ln1127"> </a>
<a name="ln1128">  /* go thru each selected image and lookup location in gpx */</a>
<a name="ln1129">  do</a>
<a name="ln1130">  {</a>
<a name="ln1131">    GTimeVal timestamp;</a>
<a name="ln1132">    GDateTime *exif_time, *utc_time;</a>
<a name="ln1133">    dt_image_geoloc_t geoloc;</a>
<a name="ln1134">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1135"> </a>
<a name="ln1136">    /* get image */</a>
<a name="ln1137">    const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1138">    if(!cimg) continue;</a>
<a name="ln1139"> </a>
<a name="ln1140">    /* convert exif datetime</a>
<a name="ln1141">       TODO: exiv2 dates should be iso8601 and we are probably doing some ugly</a>
<a name="ln1142">       conversion before inserting into database.</a>
<a name="ln1143">     */</a>
<a name="ln1144">    gint year;</a>
<a name="ln1145">    gint month;</a>
<a name="ln1146">    gint day;</a>
<a name="ln1147">    gint hour;</a>
<a name="ln1148">    gint minute;</a>
<a name="ln1149">    gint seconds;</a>
<a name="ln1150"> </a>
<a name="ln1151">    if(sscanf(cimg-&gt;exif_datetime_taken, &quot;%d:%d:%d %d:%d:%d&quot;, (int *)&amp;year, (int *)&amp;month, (int *)&amp;day,</a>
<a name="ln1152">              (int *)&amp;hour, (int *)&amp;minute, (int *)&amp;seconds) != 6)</a>
<a name="ln1153">    {</a>
<a name="ln1154">      fprintf(stderr, &quot;broken exif time in db, '%s'\n&quot;, cimg-&gt;exif_datetime_taken);</a>
<a name="ln1155">      dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1156">      continue;</a>
<a name="ln1157">    }</a>
<a name="ln1158"> </a>
<a name="ln1159">    /* release the lock */</a>
<a name="ln1160">    dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1161"> </a>
<a name="ln1162">    exif_time = g_date_time_new(tz_camera, year, month, day, hour, minute, seconds);</a>
<a name="ln1163">    if(!exif_time) continue;</a>
<a name="ln1164">    utc_time = g_date_time_to_timezone(exif_time, tz_utc);</a>
<a name="ln1165">    g_date_time_unref(exif_time);</a>
<a name="ln1166">    if(!utc_time) continue;</a>
<a name="ln1167">    gboolean res = g_date_time_to_timeval(utc_time, &amp;timestamp);</a>
<a name="ln1168">    g_date_time_unref(utc_time);</a>
<a name="ln1169">    if(!res) continue;</a>
<a name="ln1170"> </a>
<a name="ln1171">    /* only update image location if time is within gpx tack range */</a>
<a name="ln1172">    if(dt_gpx_get_location(gpx, &amp;timestamp, &amp;geoloc))</a>
<a name="ln1173">    {</a>
<a name="ln1174">      dt_image_geoloc_t *before = g_malloc0(sizeof(dt_image_geoloc_t));</a>
<a name="ln1175">      dt_image_geoloc_t *after = g_malloc0(sizeof(dt_image_geoloc_t));</a>
<a name="ln1176">      memcpy(after, &amp;geoloc, sizeof(dt_image_geoloc_t));</a>
<a name="ln1177">      dt_image_get_location(imgid, before);</a>
<a name="ln1178"> </a>
<a name="ln1179">      // first the image id and then the position</a>
<a name="ln1180">      geotags-&gt;before = g_list_append(geotags-&gt;before, GINT_TO_POINTER(imgid));</a>
<a name="ln1181">      geotags-&gt;before = g_list_append(geotags-&gt;before, (gpointer)before);</a>
<a name="ln1182">      // likewise for the new position</a>
<a name="ln1183">      geotags-&gt;after = g_list_append(geotags-&gt;after, GINT_TO_POINTER(imgid));</a>
<a name="ln1184">      geotags-&gt;after = g_list_append(geotags-&gt;after, (gpointer)after);</a>
<a name="ln1185"> </a>
<a name="ln1186">      dt_image_set_location_and_elevation(imgid, &amp;geoloc);</a>
<a name="ln1187">      cntr++;</a>
<a name="ln1188">    }</a>
<a name="ln1189"> </a>
<a name="ln1190">  } while((t = g_list_next(t)) != NULL);</a>
<a name="ln1191"> </a>
<a name="ln1192">  if(geotags-&gt;before)</a>
<a name="ln1193">  {</a>
<a name="ln1194">    dt_undo_start_group(darktable.undo, DT_UNDO_LT_GEOTAG);</a>
<a name="ln1195">    dt_undo_record(darktable.undo, NULL, DT_UNDO_LT_GEOTAG, (dt_undo_data_t)geotags, _pop_undo, _geotags_free_undo_data_t);</a>
<a name="ln1196">    dt_undo_end_group(darktable.undo);</a>
<a name="ln1197">  }</a>
<a name="ln1198"> </a>
<a name="ln1199">  dt_control_log(ngettext(&quot;applied matched GPX location onto %d image&quot;, &quot;applied matched GPX location onto %d images&quot;, cntr), cntr);</a>
<a name="ln1200"> </a>
<a name="ln1201">  g_time_zone_unref(tz_camera);</a>
<a name="ln1202">  g_time_zone_unref(tz_utc);</a>
<a name="ln1203">  dt_gpx_destroy(gpx);</a>
<a name="ln1204">  return 0;</a>
<a name="ln1205"> </a>
<a name="ln1206">bail_out:</a>
<a name="ln1207">  if(gpx) dt_gpx_destroy(gpx);</a>
<a name="ln1208"> </a>
<a name="ln1209">  return 1;</a>
<a name="ln1210">}</a>
<a name="ln1211"> </a>
<a name="ln1212">static int32_t dt_control_move_images_job_run(dt_job_t *job)</a>
<a name="ln1213">{</a>
<a name="ln1214">  return _generic_dt_control_fileop_images_job_run(job, &amp;dt_image_move, _(&quot;moving %d image&quot;),</a>
<a name="ln1215">                                                   _(&quot;moving %d images&quot;));</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">static int32_t dt_control_copy_images_job_run(dt_job_t *job)</a>
<a name="ln1219">{</a>
<a name="ln1220">  return _generic_dt_control_fileop_images_job_run(job, &amp;dt_image_copy, _(&quot;copying %d image&quot;),</a>
<a name="ln1221">                                                   _(&quot;copying %d images&quot;));</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">static int32_t dt_control_local_copy_images_job_run(dt_job_t *job)</a>
<a name="ln1225">{</a>
<a name="ln1226">  int imgid = -1;</a>
<a name="ln1227">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1228">  GList *t = params-&gt;index;</a>
<a name="ln1229">  guint tagid = 0;</a>
<a name="ln1230">  const guint total = g_list_length(t);</a>
<a name="ln1231">  double fraction = 0;</a>
<a name="ln1232">  const gboolean is_copy = params-&gt;flag == 1;</a>
<a name="ln1233">  char message[512] = { 0 };</a>
<a name="ln1234"> </a>
<a name="ln1235">  if(is_copy)</a>
<a name="ln1236">    snprintf(message, sizeof(message),</a>
<a name="ln1237">             ngettext(&quot;creating local copy of %d image&quot;, &quot;creating local copies of %d images&quot;, total), total);</a>
<a name="ln1238">  else</a>
<a name="ln1239">    snprintf(message, sizeof(message),</a>
<a name="ln1240">             ngettext(&quot;removing local copy of %d image&quot;, &quot;removing local copies of %d images&quot;, total), total);</a>
<a name="ln1241"> </a>
<a name="ln1242">  dt_control_log(&quot;%s&quot;, message);</a>
<a name="ln1243">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1244"> </a>
<a name="ln1245">  dt_tag_new(&quot;darktable|local-copy&quot;, &amp;tagid);</a>
<a name="ln1246"> </a>
<a name="ln1247">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln1248">  {</a>
<a name="ln1249">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1250">    if(is_copy)</a>
<a name="ln1251">    {</a>
<a name="ln1252">      if (dt_image_local_copy_set(imgid) == 0)</a>
<a name="ln1253">        dt_tag_attach(tagid, imgid);</a>
<a name="ln1254">    }</a>
<a name="ln1255">    else</a>
<a name="ln1256">    {</a>
<a name="ln1257">      if (dt_image_local_copy_reset(imgid) == 0)</a>
<a name="ln1258">        dt_tag_detach(tagid, imgid);</a>
<a name="ln1259">    }</a>
<a name="ln1260">    t = g_list_delete_link(t, t);</a>
<a name="ln1261"> </a>
<a name="ln1262">    fraction += 1.0 / total;</a>
<a name="ln1263">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1264">  }</a>
<a name="ln1265">  params-&gt;index = NULL;</a>
<a name="ln1266"> </a>
<a name="ln1267">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln1268">  return 0;</a>
<a name="ln1269">}</a>
<a name="ln1270"> </a>
<a name="ln1271">static int32_t dt_control_export_job_run(dt_job_t *job)</a>
<a name="ln1272">{</a>
<a name="ln1273">  int imgid = -1;</a>
<a name="ln1274">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1275">  dt_control_export_t *settings = (dt_control_export_t *)params-&gt;data;</a>
<a name="ln1276">  GList *t = params-&gt;index;</a>
<a name="ln1277">  dt_imageio_module_format_t *mformat = dt_imageio_get_format_by_index(settings-&gt;format_index);</a>
<a name="ln1278">  g_assert(mformat);</a>
<a name="ln1279">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(settings-&gt;storage_index);</a>
<a name="ln1280">  g_assert(mstorage);</a>
<a name="ln1281">  dt_imageio_module_data_t *sdata = settings-&gt;sdata;</a>
<a name="ln1282"> </a>
<a name="ln1283">  // get a thread-safe fdata struct (one jpeg struct per thread etc):</a>
<a name="ln1284">  dt_imageio_module_data_t *fdata = mformat-&gt;get_params(mformat);</a>
<a name="ln1285"> </a>
<a name="ln1286">  if(mstorage-&gt;initialize_store)</a>
<a name="ln1287">  {</a>
<a name="ln1288">    if(mstorage-&gt;initialize_store(mstorage, sdata, &amp;mformat, &amp;fdata, &amp;t, settings-&gt;high_quality, settings-&gt;upscale))</a>
<a name="ln1289">    {</a>
<a name="ln1290">      // bail out, something went wrong</a>
<a name="ln1291">      goto end;</a>
<a name="ln1292">    }</a>
<a name="ln1293">    mformat-&gt;set_params(mformat, fdata, mformat-&gt;params_size(mformat));</a>
<a name="ln1294">    mstorage-&gt;set_params(mstorage, sdata, mstorage-&gt;params_size(mstorage));</a>
<a name="ln1295">  }</a>
<a name="ln1296"> </a>
<a name="ln1297">  // Get max dimensions...</a>
<a name="ln1298">  uint32_t w, h, fw, fh, sw, sh;</a>
<a name="ln1299">  fw = fh = sw = sh = 0;</a>
<a name="ln1300">  mstorage-&gt;dimension(mstorage, sdata, &amp;sw, &amp;sh);</a>
<a name="ln1301">  mformat-&gt;dimension(mformat, fdata, &amp;fw, &amp;fh);</a>
<a name="ln1302"> </a>
<a name="ln1303">  if(sw == 0 || fw == 0)</a>
<a name="ln1304">    w = sw &gt; fw ? sw : fw;</a>
<a name="ln1305">  else</a>
<a name="ln1306">    w = sw &lt; fw ? sw : fw;</a>
<a name="ln1307"> </a>
<a name="ln1308">  if(sh == 0 || fh == 0)</a>
<a name="ln1309">    h = sh &gt; fh ? sh : fh;</a>
<a name="ln1310">  else</a>
<a name="ln1311">    h = sh &lt; fh ? sh : fh;</a>
<a name="ln1312"> </a>
<a name="ln1313">  const guint total = g_list_length(t);</a>
<a name="ln1314">  dt_control_log(ngettext(&quot;exporting %d image..&quot;, &quot;exporting %d images..&quot;, total), total);</a>
<a name="ln1315">  char message[512] = { 0 };</a>
<a name="ln1316">  snprintf(message, sizeof(message), ngettext(&quot;exporting %d image to %s&quot;, &quot;exporting %d images to %s&quot;, total),</a>
<a name="ln1317">           total, mstorage-&gt;name(mstorage));</a>
<a name="ln1318">  // update the message. initialize_store() might have changed the number of images</a>
<a name="ln1319">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1320"> </a>
<a name="ln1321">  double fraction = 0;</a>
<a name="ln1322"> </a>
<a name="ln1323">  // set up the fdata struct</a>
<a name="ln1324">  fdata-&gt;max_width = (settings-&gt;max_width != 0 &amp;&amp; w != 0) ? MIN(w, settings-&gt;max_width) : MAX(w, settings-&gt;max_width);</a>
<a name="ln1325">  fdata-&gt;max_height = (settings-&gt;max_height != 0 &amp;&amp; h != 0) ? MIN(h, settings-&gt;max_height) : MAX(h, settings-&gt;max_height);</a>
<a name="ln1326">  g_strlcpy(fdata-&gt;style, settings-&gt;style, sizeof(fdata-&gt;style));</a>
<a name="ln1327">  fdata-&gt;style_append = settings-&gt;style_append;</a>
<a name="ln1328">  guint num = 0;</a>
<a name="ln1329">  // Invariant: the tagid for 'darktable|changed' will not change while this function runs. Is this a</a>
<a name="ln1330">  // sensible assumption?</a>
<a name="ln1331">  guint tagid = 0, etagid = 0;</a>
<a name="ln1332">  dt_tag_new(&quot;darktable|changed&quot;, &amp;tagid);</a>
<a name="ln1333">  dt_tag_new(&quot;darktable|exported&quot;, &amp;etagid);</a>
<a name="ln1334"> </a>
<a name="ln1335">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln1336">  {</a>
<a name="ln1337">    if(!t)</a>
<a name="ln1338">      imgid = 0;</a>
<a name="ln1339">    else</a>
<a name="ln1340">    {</a>
<a name="ln1341">      imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1342">      t = g_list_delete_link(t, t);</a>
<a name="ln1343">      num = total - g_list_length(t);</a>
<a name="ln1344">    }</a>
<a name="ln1345"> </a>
<a name="ln1346">    // remove 'changed' tag from image</a>
<a name="ln1347">    dt_tag_detach(tagid, imgid);</a>
<a name="ln1348">    // make sure the 'exported' tag is set on the image</a>
<a name="ln1349">    dt_tag_attach(etagid, imgid);</a>
<a name="ln1350">    // check if image still exists:</a>
<a name="ln1351">    char imgfilename[PATH_MAX] = { 0 };</a>
<a name="ln1352">    const dt_image_t *image = dt_image_cache_get(darktable.image_cache, (int32_t)imgid, 'r');</a>
<a name="ln1353">    if(image)</a>
<a name="ln1354">    {</a>
<a name="ln1355">      gboolean from_cache = TRUE;</a>
<a name="ln1356">      dt_image_full_path(image-&gt;id, imgfilename, sizeof(imgfilename), &amp;from_cache);</a>
<a name="ln1357">      if(!g_file_test(imgfilename, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln1358">      {</a>
<a name="ln1359">        dt_control_log(_(&quot;image `%s' is currently unavailable&quot;), image-&gt;filename);</a>
<a name="ln1360">        fprintf(stderr, &quot;image `%s' is currently unavailable\n&quot;, imgfilename);</a>
<a name="ln1361">        // dt_image_remove(imgid);</a>
<a name="ln1362">        dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1363">      }</a>
<a name="ln1364">      else</a>
<a name="ln1365">      {</a>
<a name="ln1366">        dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1367">        if(mstorage-&gt;store(mstorage, sdata, imgid, mformat, fdata, num, total, settings-&gt;high_quality,</a>
<a name="ln1368">                           settings-&gt;upscale, settings-&gt;icc_type, settings-&gt;icc_filename, settings-&gt;icc_intent) != 0)</a>
<a name="ln1369">          dt_control_job_cancel(job);</a>
<a name="ln1370">      }</a>
<a name="ln1371">    }</a>
<a name="ln1372"> </a>
<a name="ln1373">    fraction += 1.0 / total;</a>
<a name="ln1374">    if(fraction &gt; 1.0) fraction = 1.0;</a>
<a name="ln1375">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1376">  }</a>
<a name="ln1377">  params-&gt;index = NULL;</a>
<a name="ln1378"> </a>
<a name="ln1379">  if(mstorage-&gt;finalize_store) mstorage-&gt;finalize_store(mstorage, sdata);</a>
<a name="ln1380"> </a>
<a name="ln1381">end:</a>
<a name="ln1382">  // all threads free their fdata</a>
<a name="ln1383">  mformat-&gt;free_params(mformat, fdata);</a>
<a name="ln1384"> </a>
<a name="ln1385">  // notify the user via the window manager</a>
<a name="ln1386">  dt_ui_notify_user();</a>
<a name="ln1387"> </a>
<a name="ln1388">  return 0;</a>
<a name="ln1389">}</a>
<a name="ln1390"> </a>
<a name="ln1391">static dt_control_image_enumerator_t *dt_control_gpx_apply_alloc()</a>
<a name="ln1392">{</a>
<a name="ln1393">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1394">  if(!params) return NULL;</a>
<a name="ln1395"> </a>
<a name="ln1396">  params-&gt;data = calloc(1, sizeof(dt_control_gpx_apply_t));</a>
<a name="ln1397">  if(!params-&gt;data)</a>
<a name="ln1398">  {</a>
<a name="ln1399">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1400">    return NULL;</a>
<a name="ln1401">  }</a>
<a name="ln1402"> </a>
<a name="ln1403">  return params;</a>
<a name="ln1404">}</a>
<a name="ln1405"> </a>
<a name="ln1406">static void dt_control_gpx_apply_job_cleanup(void *p)</a>
<a name="ln1407">{</a>
<a name="ln1408">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln1409"> </a>
<a name="ln1410">  dt_control_gpx_apply_t *data = params-&gt;data;</a>
<a name="ln1411">  g_free(data-&gt;filename);</a>
<a name="ln1412">  g_free(data-&gt;tz);</a>
<a name="ln1413"> </a>
<a name="ln1414">  free(data);</a>
<a name="ln1415"> </a>
<a name="ln1416">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1417">}</a>
<a name="ln1418"> </a>
<a name="ln1419">static dt_job_t *dt_control_gpx_apply_job_create(const gchar *filename, int32_t filmid, const gchar *tz)</a>
<a name="ln1420">{</a>
<a name="ln1421">  dt_job_t *job = dt_control_job_create(&amp;dt_control_gpx_apply_job_run, &quot;gpx apply&quot;);</a>
<a name="ln1422">  if(!job) return NULL;</a>
<a name="ln1423">  dt_control_image_enumerator_t *params = dt_control_gpx_apply_alloc();</a>
<a name="ln1424">  if(!params)</a>
<a name="ln1425">  {</a>
<a name="ln1426">    dt_control_job_dispose(job);</a>
<a name="ln1427">    return NULL;</a>
<a name="ln1428">  }</a>
<a name="ln1429">  dt_control_job_set_params(job, params, dt_control_gpx_apply_job_cleanup);</a>
<a name="ln1430"> </a>
<a name="ln1431">  if(filmid != -1)</a>
<a name="ln1432">    dt_control_image_enumerator_job_film_init(params, filmid);</a>
<a name="ln1433">  else</a>
<a name="ln1434">    dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln1435"> </a>
<a name="ln1436">  dt_control_gpx_apply_t *data = params-&gt;data;</a>
<a name="ln1437">  data-&gt;filename = g_strdup(filename);</a>
<a name="ln1438">  data-&gt;tz = g_strdup(tz);</a>
<a name="ln1439"> </a>
<a name="ln1440">  return job;</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">void dt_control_merge_hdr()</a>
<a name="ln1444">{</a>
<a name="ln1445">  dt_control_add_job(</a>
<a name="ln1446">      darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1447">      dt_control_generic_images_job_create(&amp;dt_control_merge_hdr_job_run, N_(&quot;merge hdr image&quot;), 0, NULL,</a>
<a name="ln1448">                                           PROGRESS_CANCELLABLE));</a>
<a name="ln1449">}</a>
<a name="ln1450"> </a>
<a name="ln1451">void dt_control_gpx_apply(const gchar *filename, int32_t filmid, const gchar *tz)</a>
<a name="ln1452">{</a>
<a name="ln1453">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1454">                     dt_control_gpx_apply_job_create(filename, filmid, tz));</a>
<a name="ln1455">}</a>
<a name="ln1456"> </a>
<a name="ln1457">void dt_control_duplicate_images()</a>
<a name="ln1458">{</a>
<a name="ln1459">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1460">                     dt_control_generic_images_job_create(&amp;dt_control_duplicate_images_job_run,</a>
<a name="ln1461">                                                          N_(&quot;duplicate images&quot;), 0, NULL, PROGRESS_SIMPLE));</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464">void dt_control_flip_images(const int32_t cw)</a>
<a name="ln1465">{</a>
<a name="ln1466">  dt_control_add_job(</a>
<a name="ln1467">      darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1468">      dt_control_generic_images_job_create(&amp;dt_control_flip_images_job_run, N_(&quot;flip images&quot;), cw, NULL,</a>
<a name="ln1469">                                           PROGRESS_SIMPLE));</a>
<a name="ln1470">}</a>
<a name="ln1471"> </a>
<a name="ln1472">gboolean dt_control_remove_images()</a>
<a name="ln1473">{</a>
<a name="ln1474">  // get all selected images now, to avoid the set changing during ui interaction</a>
<a name="ln1475">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_remove_images_job_run, N_(&quot;remove images&quot;), 0, NULL,</a>
<a name="ln1476">                                                       PROGRESS_SIMPLE);</a>
<a name="ln1477">  if(dt_conf_get_bool(&quot;ask_before_remove&quot;))</a>
<a name="ln1478">  {</a>
<a name="ln1479">    GtkWidget *dialog;</a>
<a name="ln1480">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1481"> </a>
<a name="ln1482">    int number;</a>
<a name="ln1483">    if (dt_view_get_image_to_act_on() != -1)</a>
<a name="ln1484">      number = 1;</a>
<a name="ln1485">    else</a>
<a name="ln1486">      number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1487"> </a>
<a name="ln1488">    // Do not show the dialog if no image is selected:</a>
<a name="ln1489">    if(number == 0)</a>
<a name="ln1490">    {</a>
<a name="ln1491">      dt_control_job_dispose(job);</a>
<a name="ln1492">      return TRUE;</a>
<a name="ln1493">    }</a>
<a name="ln1494"> </a>
<a name="ln1495">    dialog = gtk_message_dialog_new(</a>
<a name="ln1496">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1497">        ngettext(&quot;do you really want to remove %d selected image from the collection?&quot;,</a>
<a name="ln1498">                 &quot;do you really want to remove %d selected images from the collection?&quot;, number),</a>
<a name="ln1499">        number);</a>
<a name="ln1500">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1501">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1502">#endif</a>
<a name="ln1503"> </a>
<a name="ln1504">    gtk_window_set_title(GTK_WINDOW(dialog), _(&quot;remove images?&quot;));</a>
<a name="ln1505">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1506">    gtk_widget_destroy(dialog);</a>
<a name="ln1507">    if(res != GTK_RESPONSE_YES)</a>
<a name="ln1508">    {</a>
<a name="ln1509">      dt_control_job_dispose(job);</a>
<a name="ln1510">      return FALSE;</a>
<a name="ln1511">    }</a>
<a name="ln1512">  }</a>
<a name="ln1513">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1514">  return TRUE;</a>
<a name="ln1515">}</a>
<a name="ln1516"> </a>
<a name="ln1517">void dt_control_delete_images()</a>
<a name="ln1518">{</a>
<a name="ln1519">  // first get all selected images, to avoid the set changing during ui interaction</a>
<a name="ln1520">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_delete_images_job_run, N_(&quot;delete images&quot;), 0, NULL,</a>
<a name="ln1521">                                                       PROGRESS_SIMPLE);</a>
<a name="ln1522">  int send_to_trash = dt_conf_get_bool(&quot;send_to_trash&quot;);</a>
<a name="ln1523">  if(dt_conf_get_bool(&quot;ask_before_delete&quot;))</a>
<a name="ln1524">  {</a>
<a name="ln1525">    GtkWidget *dialog;</a>
<a name="ln1526">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1527"> </a>
<a name="ln1528">    int number;</a>
<a name="ln1529">    if (dt_view_get_image_to_act_on() != -1)</a>
<a name="ln1530">      number = 1;</a>
<a name="ln1531">    else</a>
<a name="ln1532">      number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1533"> </a>
<a name="ln1534">    // Do not show the dialog if no image is selected:</a>
<a name="ln1535">    if(number == 0)</a>
<a name="ln1536">    {</a>
<a name="ln1537">      dt_control_job_dispose(job);</a>
<a name="ln1538">      return;</a>
<a name="ln1539">    }</a>
<a name="ln1540"> </a>
<a name="ln1541">    dialog = gtk_message_dialog_new(</a>
<a name="ln1542">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1543">        send_to_trash</a>
<a name="ln1544">        ? ngettext(&quot;do you really want to send %d selected image to trash?&quot;,</a>
<a name="ln1545">          &quot;do you really want to send %d selected images to trash?&quot;, number)</a>
<a name="ln1546">        : ngettext(&quot;do you really want to physically delete %d selected image from disk?&quot;,</a>
<a name="ln1547">          &quot;do you really want to physically delete %d selected images from disk?&quot;, number),</a>
<a name="ln1548">        number);</a>
<a name="ln1549">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1550">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1551">#endif</a>
<a name="ln1552"> </a>
<a name="ln1553">    gtk_window_set_title(GTK_WINDOW(dialog), send_to_trash ? _(&quot;trash images?&quot;) : _(&quot;delete images?&quot;));</a>
<a name="ln1554">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1555">    gtk_widget_destroy(dialog);</a>
<a name="ln1556">    if(res != GTK_RESPONSE_YES)</a>
<a name="ln1557">    {</a>
<a name="ln1558">      dt_control_job_dispose(job);</a>
<a name="ln1559">      return;</a>
<a name="ln1560">    }</a>
<a name="ln1561">  }</a>
<a name="ln1562">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1563">}</a>
<a name="ln1564"> </a>
<a name="ln1565">void dt_control_move_images()</a>
<a name="ln1566">{</a>
<a name="ln1567">  // Open file chooser dialog</a>
<a name="ln1568">  gchar *dir = NULL;</a>
<a name="ln1569">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1570">  int number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1571"> </a>
<a name="ln1572">  // Do not show the dialog if no image is selected:</a>
<a name="ln1573">  if(number == 0) return;</a>
<a name="ln1574">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_move_images_job_run, N_(&quot;move images&quot;), 0, dir,</a>
<a name="ln1575">                                                       PROGRESS_CANCELLABLE);</a>
<a name="ln1576"> </a>
<a name="ln1577">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1578">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1579">      GTK_RESPONSE_CANCEL, _(&quot;_select as destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1580">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1581">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1582">#endif</a>
<a name="ln1583"> </a>
<a name="ln1584">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln1585">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1586">  {</a>
<a name="ln1587">    dir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1588">  }</a>
<a name="ln1589">  gtk_widget_destroy(filechooser);</a>
<a name="ln1590"> </a>
<a name="ln1591">  if(!dir || !g_file_test(dir, G_FILE_TEST_IS_DIR)) goto abort;</a>
<a name="ln1592"> </a>
<a name="ln1593">  // ugly, but we need to set this after constructing the job:</a>
<a name="ln1594">  ((dt_control_image_enumerator_t *)dt_control_job_get_params(job))-&gt;data = dir;</a>
<a name="ln1595"> </a>
<a name="ln1596">  if(dt_conf_get_bool(&quot;ask_before_move&quot;))</a>
<a name="ln1597">  {</a>
<a name="ln1598">    GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln1599">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1600">        ngettext(&quot;do you really want to physically move the %d selected image to %s?\n&quot;</a>
<a name="ln1601">                 &quot;(all unselected duplicates will be moved along)&quot;,</a>
<a name="ln1602">                 &quot;do you really want to physically move %d selected images to %s?\n&quot;</a>
<a name="ln1603">                 &quot;(all unselected duplicates will be moved along)&quot;,</a>
<a name="ln1604">                 number),</a>
<a name="ln1605">        number, dir);</a>
<a name="ln1606">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1607">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1608">#endif</a>
<a name="ln1609">    gtk_window_set_title(GTK_WINDOW(dialog), ngettext(&quot;move image?&quot;, &quot;move images?&quot;, number));</a>
<a name="ln1610"> </a>
<a name="ln1611">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1612">    gtk_widget_destroy(dialog);</a>
<a name="ln1613"> </a>
<a name="ln1614">    if(res != GTK_RESPONSE_YES) goto abort;</a>
<a name="ln1615">  }</a>
<a name="ln1616"> </a>
<a name="ln1617">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1618">  return;</a>
<a name="ln1619"> </a>
<a name="ln1620">abort:</a>
<a name="ln1621">  g_free(dir);</a>
<a name="ln1622">  dt_control_job_dispose(job);</a>
<a name="ln1623">}</a>
<a name="ln1624"> </a>
<a name="ln1625">void dt_control_copy_images()</a>
<a name="ln1626">{</a>
<a name="ln1627">  // Open file chooser dialog</a>
<a name="ln1628">  gchar *dir = NULL;</a>
<a name="ln1629">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1630">  int number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1631"> </a>
<a name="ln1632">  // Do not show the dialog if no image is selected:</a>
<a name="ln1633">  if(number == 0) return;</a>
<a name="ln1634">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_copy_images_job_run, N_(&quot;copy images&quot;), 0, dir,</a>
<a name="ln1635">                                                       PROGRESS_CANCELLABLE);</a>
<a name="ln1636"> </a>
<a name="ln1637">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1638">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1639">      GTK_RESPONSE_CANCEL, _(&quot;_select as destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1640">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1641">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1642">#endif</a>
<a name="ln1643"> </a>
<a name="ln1644">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln1645">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1646">  {</a>
<a name="ln1647">    dir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1648">  }</a>
<a name="ln1649">  gtk_widget_destroy(filechooser);</a>
<a name="ln1650"> </a>
<a name="ln1651">  if(!dir || !g_file_test(dir, G_FILE_TEST_IS_DIR)) goto abort;</a>
<a name="ln1652"> </a>
<a name="ln1653">  // ugly, but we need to set this after constructing the job:</a>
<a name="ln1654">  ((dt_control_image_enumerator_t *)dt_control_job_get_params(job))-&gt;data = dir;</a>
<a name="ln1655"> </a>
<a name="ln1656">  if(dt_conf_get_bool(&quot;ask_before_copy&quot;))</a>
<a name="ln1657">  {</a>
<a name="ln1658">    GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln1659">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1660">        ngettext(&quot;do you really want to physically copy the %d selected image to %s?&quot;,</a>
<a name="ln1661">                 &quot;do you really want to physically copy %d selected images to %s?&quot;, number),</a>
<a name="ln1662">        number, dir);</a>
<a name="ln1663">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1664">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1665">#endif</a>
<a name="ln1666">    gtk_window_set_title(GTK_WINDOW(dialog), ngettext(&quot;copy image?&quot;, &quot;copy images?&quot;, number));</a>
<a name="ln1667"> </a>
<a name="ln1668">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1669">    gtk_widget_destroy(dialog);</a>
<a name="ln1670"> </a>
<a name="ln1671">    if(res != GTK_RESPONSE_YES) goto abort;</a>
<a name="ln1672">  }</a>
<a name="ln1673"> </a>
<a name="ln1674">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1675">  return;</a>
<a name="ln1676"> </a>
<a name="ln1677">abort:</a>
<a name="ln1678">  g_free(dir);</a>
<a name="ln1679">  dt_control_job_dispose(job);</a>
<a name="ln1680">}</a>
<a name="ln1681"> </a>
<a name="ln1682">void dt_control_set_local_copy_images()</a>
<a name="ln1683">{</a>
<a name="ln1684">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1685">                     dt_control_generic_images_job_create(&amp;dt_control_local_copy_images_job_run,</a>
<a name="ln1686">                                                          N_(&quot;local copy images&quot;), 1, NULL, PROGRESS_CANCELLABLE));</a>
<a name="ln1687">}</a>
<a name="ln1688"> </a>
<a name="ln1689">void dt_control_reset_local_copy_images()</a>
<a name="ln1690">{</a>
<a name="ln1691">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1692">                     dt_control_generic_images_job_create(&amp;dt_control_local_copy_images_job_run,</a>
<a name="ln1693">                                                          N_(&quot;local copy images&quot;), 0, NULL, PROGRESS_CANCELLABLE));</a>
<a name="ln1694">}</a>
<a name="ln1695"> </a>
<a name="ln1696">static dt_control_image_enumerator_t *dt_control_export_alloc()</a>
<a name="ln1697">{</a>
<a name="ln1698">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1699">  if(!params) return NULL;</a>
<a name="ln1700"> </a>
<a name="ln1701">  params-&gt;data = calloc(1, sizeof(dt_control_export_t));</a>
<a name="ln1702">  if(!params-&gt;data)</a>
<a name="ln1703">  {</a>
<a name="ln1704">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1705">    return NULL;</a>
<a name="ln1706">  }</a>
<a name="ln1707"> </a>
<a name="ln1708">  return params;</a>
<a name="ln1709">}</a>
<a name="ln1710"> </a>
<a name="ln1711">static void dt_control_export_cleanup(void *p)</a>
<a name="ln1712">{</a>
<a name="ln1713">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln1714"> </a>
<a name="ln1715">  dt_control_export_t *settings = (dt_control_export_t *)params-&gt;data;</a>
<a name="ln1716">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(settings-&gt;storage_index);</a>
<a name="ln1717">  dt_imageio_module_data_t *sdata = settings-&gt;sdata;</a>
<a name="ln1718"> </a>
<a name="ln1719">  mstorage-&gt;free_params(mstorage, sdata);</a>
<a name="ln1720"> </a>
<a name="ln1721">  g_free(settings-&gt;icc_filename);</a>
<a name="ln1722">  free(params-&gt;data);</a>
<a name="ln1723"> </a>
<a name="ln1724">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1725">}</a>
<a name="ln1726"> </a>
<a name="ln1727">void dt_control_export(GList *imgid_list, int max_width, int max_height, int format_index, int storage_index,</a>
<a name="ln1728">                       gboolean high_quality, gboolean upscale, char *style, gboolean style_append,</a>
<a name="ln1729">                       dt_colorspaces_color_profile_type_t icc_type, const gchar *icc_filename,</a>
<a name="ln1730">                       dt_iop_color_intent_t icc_intent)</a>
<a name="ln1731">{</a>
<a name="ln1732">  dt_job_t *job = dt_control_job_create(&amp;dt_control_export_job_run, &quot;export&quot;);</a>
<a name="ln1733">  if(!job) return;</a>
<a name="ln1734">  dt_control_image_enumerator_t *params = dt_control_export_alloc();</a>
<a name="ln1735">  if(!params)</a>
<a name="ln1736">  {</a>
<a name="ln1737">    dt_control_job_dispose(job);</a>
<a name="ln1738">    return;</a>
<a name="ln1739">  }</a>
<a name="ln1740">  dt_control_job_set_params(job, params, dt_control_export_cleanup);</a>
<a name="ln1741"> </a>
<a name="ln1742">  params-&gt;index = imgid_list;</a>
<a name="ln1743"> </a>
<a name="ln1744">  dt_control_export_t *data = params-&gt;data;</a>
<a name="ln1745">  data-&gt;max_width = max_width;</a>
<a name="ln1746">  data-&gt;max_height = max_height;</a>
<a name="ln1747">  data-&gt;format_index = format_index;</a>
<a name="ln1748">  data-&gt;storage_index = storage_index;</a>
<a name="ln1749">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(storage_index);</a>
<a name="ln1750">  g_assert(mstorage);</a>
<a name="ln1751">  // get shared storage param struct (global sequence counter, one picasa connection etc)</a>
<a name="ln1752">  dt_imageio_module_data_t *sdata = mstorage-&gt;get_params(mstorage);</a>
<a name="ln1753">  if(sdata == NULL)</a>
<a name="ln1754">  {</a>
<a name="ln1755">    dt_control_log(_(&quot;failed to get parameters from storage module `%s', aborting export..&quot;),</a>
<a name="ln1756">                   mstorage-&gt;name(mstorage));</a>
<a name="ln1757">    dt_control_job_dispose(job);</a>
<a name="ln1758">    return;</a>
<a name="ln1759">  }</a>
<a name="ln1760">  data-&gt;sdata = sdata;</a>
<a name="ln1761">  data-&gt;high_quality = high_quality;</a>
<a name="ln1762">  data-&gt;upscale = upscale;</a>
<a name="ln1763">  g_strlcpy(data-&gt;style, style, sizeof(data-&gt;style));</a>
<a name="ln1764">  data-&gt;style_append = style_append;</a>
<a name="ln1765">  data-&gt;icc_type = icc_type;</a>
<a name="ln1766">  data-&gt;icc_filename = g_strdup(icc_filename);</a>
<a name="ln1767">  data-&gt;icc_intent = icc_intent;</a>
<a name="ln1768"> </a>
<a name="ln1769">  dt_control_job_add_progress(job, _(&quot;export images&quot;), TRUE);</a>
<a name="ln1770">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_EXPORT, job);</a>
<a name="ln1771"> </a>
<a name="ln1772">  // tell the storage that we got its params for an export so it can reset itself to a safe state</a>
<a name="ln1773">  mstorage-&gt;export_dispatched(mstorage);</a>
<a name="ln1774">}</a>
<a name="ln1775"> </a>
<a name="ln1776">static int32_t dt_control_time_offset_job_run(dt_job_t *job)</a>
<a name="ln1777">{</a>
<a name="ln1778">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1779">  uint32_t cntr = 0;</a>
<a name="ln1780">  double fraction = 0.0;</a>
<a name="ln1781">  GList *t = params-&gt;index;</a>
<a name="ln1782">  const long int offset = ((dt_control_time_offset_t *)params-&gt;data)-&gt;offset;</a>
<a name="ln1783">  char message[512] = { 0 };</a>
<a name="ln1784"> </a>
<a name="ln1785">  /* do we have any selected images and is offset != 0 */</a>
<a name="ln1786">  if(!t || offset == 0)</a>
<a name="ln1787">  {</a>
<a name="ln1788">    return 1;</a>
<a name="ln1789">  }</a>
<a name="ln1790"> </a>
<a name="ln1791">  const guint total = g_list_length(t);</a>
<a name="ln1792"> </a>
<a name="ln1793">  snprintf(message, sizeof(message),</a>
<a name="ln1794">           ngettext(&quot;adding time offset to %d image&quot;, &quot;adding time offset to %d images&quot;, total), total);</a>
<a name="ln1795">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1796"> </a>
<a name="ln1797">  /* go thru each selected image and update datetime_taken */</a>
<a name="ln1798">  do</a>
<a name="ln1799">  {</a>
<a name="ln1800">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1801"> </a>
<a name="ln1802">    dt_image_add_time_offset(imgid, offset);</a>
<a name="ln1803">    cntr++;</a>
<a name="ln1804"> </a>
<a name="ln1805">    fraction = MAX(fraction, (1.0 * cntr) / total);</a>
<a name="ln1806">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1807">  } while((t = g_list_next(t)) != NULL);</a>
<a name="ln1808"> </a>
<a name="ln1809">  dt_control_log(ngettext(&quot;added time offset to %d image&quot;, &quot;added time offset to %d images&quot;, cntr), cntr);</a>
<a name="ln1810"> </a>
<a name="ln1811">  return 0;</a>
<a name="ln1812">}</a>
<a name="ln1813"> </a>
<a name="ln1814">static void *dt_control_time_offset_alloc()</a>
<a name="ln1815">{</a>
<a name="ln1816">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1817">  if(!params) return NULL;</a>
<a name="ln1818"> </a>
<a name="ln1819">  params-&gt;data = calloc(1, sizeof(dt_control_time_offset_t));</a>
<a name="ln1820">  if(!params-&gt;data)</a>
<a name="ln1821">  {</a>
<a name="ln1822">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1823">    return NULL;</a>
<a name="ln1824">  }</a>
<a name="ln1825"> </a>
<a name="ln1826">  return params;</a>
<a name="ln1827">}</a>
<a name="ln1828"> </a>
<a name="ln1829">static void dt_control_time_offset_job_cleanup(void *p)</a>
<a name="ln1830">{</a>
<a name="ln1831">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)p;</a>
<a name="ln1832"> </a>
<a name="ln1833">  free(params-&gt;data);</a>
<a name="ln1834"> </a>
<a name="ln1835">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1836">}</a>
<a name="ln1837"> </a>
<a name="ln1838">static dt_job_t *dt_control_time_offset_job_create(const long int offset, int imgid)</a>
<a name="ln1839">{</a>
<a name="ln1840">  dt_job_t *job = dt_control_job_create(&amp;dt_control_time_offset_job_run, &quot;time offset&quot;);</a>
<a name="ln1841">  if(!job) return NULL;</a>
<a name="ln1842">  dt_control_image_enumerator_t *params = dt_control_time_offset_alloc();</a>
<a name="ln1843">  if(!params)</a>
<a name="ln1844">  {</a>
<a name="ln1845">    dt_control_job_dispose(job);</a>
<a name="ln1846">    return NULL;</a>
<a name="ln1847">  }</a>
<a name="ln1848">  dt_control_job_add_progress(job, _(&quot;time offset&quot;), FALSE);</a>
<a name="ln1849">  dt_control_job_set_params(job, params, dt_control_time_offset_job_cleanup);</a>
<a name="ln1850"> </a>
<a name="ln1851">  if(imgid != -1)</a>
<a name="ln1852">    params-&gt;index = g_list_append(params-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln1853">  else</a>
<a name="ln1854">    dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln1855"> </a>
<a name="ln1856">  dt_control_time_offset_t *data = params-&gt;data;</a>
<a name="ln1857">  data-&gt;offset = offset;</a>
<a name="ln1858">  params-&gt;data = data;</a>
<a name="ln1859">  return job;</a>
<a name="ln1860">}</a>
<a name="ln1861"> </a>
<a name="ln1862">void dt_control_time_offset(const long int offset, int imgid)</a>
<a name="ln1863">{</a>
<a name="ln1864">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1865">                     dt_control_time_offset_job_create(offset, imgid));</a>
<a name="ln1866">}</a>
<a name="ln1867"> </a>
<a name="ln1868">void dt_control_write_sidecar_files()</a>
<a name="ln1869">{</a>
<a name="ln1870">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1871">                     dt_control_generic_images_job_create(&amp;dt_control_write_sidecar_files_job_run,</a>
<a name="ln1872">                                                          N_(&quot;write sidecar files&quot;), 0, NULL, PROGRESS_NONE));</a>
<a name="ln1873">}</a>
<a name="ln1874"> </a>
<a name="ln1875">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1876">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1877">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="583"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'buffer'. Check lines: 583, 579.</p></div>
<div class="balloon" rel="1052"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="1337"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!t' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
