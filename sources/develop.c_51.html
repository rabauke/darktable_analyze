
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika.</a>
<a name="ln4">    copyright (c) 2011 henrik andersson.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &lt;assert.h&gt;</a>
<a name="ln20">#include &lt;glib/gprintf.h&gt;</a>
<a name="ln21">#include &lt;math.h&gt;</a>
<a name="ln22">#include &lt;stdint.h&gt;</a>
<a name="ln23">#include &lt;stdlib.h&gt;</a>
<a name="ln24">#include &lt;string.h&gt;</a>
<a name="ln25">#include &lt;strings.h&gt;</a>
<a name="ln26">#include &lt;unistd.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;common/debug.h&quot;</a>
<a name="ln29">#include &quot;common/image_cache.h&quot;</a>
<a name="ln30">#include &quot;common/imageio.h&quot;</a>
<a name="ln31">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln32">#include &quot;common/opencl.h&quot;</a>
<a name="ln33">#include &quot;common/tags.h&quot;</a>
<a name="ln34">#include &quot;common/undo.h&quot;</a>
<a name="ln35">#include &quot;control/conf.h&quot;</a>
<a name="ln36">#include &quot;control/control.h&quot;</a>
<a name="ln37">#include &quot;control/jobs.h&quot;</a>
<a name="ln38">#include &quot;develop/blend.h&quot;</a>
<a name="ln39">#include &quot;develop/develop.h&quot;</a>
<a name="ln40">#include &quot;develop/imageop.h&quot;</a>
<a name="ln41">#include &quot;develop/lightroom.h&quot;</a>
<a name="ln42">#include &quot;develop/masks.h&quot;</a>
<a name="ln43">#include &quot;gui/gtk.h&quot;</a>
<a name="ln44">#include &quot;gui/presets.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">#define DT_DEV_AVERAGE_DELAY_START 250</a>
<a name="ln47">#define DT_DEV_PREVIEW_AVERAGE_DELAY_START 50</a>
<a name="ln48">#define DT_DEV_AVERAGE_DELAY_COUNT 5</a>
<a name="ln49"> </a>
<a name="ln50">const gchar *dt_dev_histogram_type_names[DT_DEV_HISTOGRAM_N] = { &quot;logarithmic&quot;, &quot;linear&quot;, &quot;waveform&quot; };</a>
<a name="ln51"> </a>
<a name="ln52">void dt_dev_init(dt_develop_t *dev, int32_t gui_attached)</a>
<a name="ln53">{</a>
<a name="ln54">  memset(dev, 0, sizeof(dt_develop_t));</a>
<a name="ln55">  dev-&gt;full_preview = FALSE;</a>
<a name="ln56">  dev-&gt;preview_downsampling = 1.0f;</a>
<a name="ln57">  dev-&gt;gui_module = NULL;</a>
<a name="ln58">  dev-&gt;timestamp = 0;</a>
<a name="ln59">  dev-&gt;average_delay = DT_DEV_AVERAGE_DELAY_START;</a>
<a name="ln60">  dev-&gt;preview_average_delay = DT_DEV_PREVIEW_AVERAGE_DELAY_START;</a>
<a name="ln61">  dev-&gt;gui_leaving = 0;</a>
<a name="ln62">  dev-&gt;gui_synch = 0;</a>
<a name="ln63">  dt_pthread_mutex_init(&amp;dev-&gt;history_mutex, NULL);</a>
<a name="ln64">  dev-&gt;history_end = 0;</a>
<a name="ln65">  dev-&gt;history = NULL; // empty list</a>
<a name="ln66"> </a>
<a name="ln67">  dev-&gt;gui_attached = gui_attached;</a>
<a name="ln68">  dev-&gt;width = -1;</a>
<a name="ln69">  dev-&gt;height = -1;</a>
<a name="ln70"> </a>
<a name="ln71">  dt_image_init(&amp;dev-&gt;image_storage);</a>
<a name="ln72">  dev-&gt;image_status = dev-&gt;preview_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln73">  dev-&gt;image_loading = dev-&gt;preview_loading = 0;</a>
<a name="ln74">  dev-&gt;image_force_reload = 0;</a>
<a name="ln75">  dev-&gt;preview_input_changed = 0;</a>
<a name="ln76"> </a>
<a name="ln77">  dev-&gt;pipe = dev-&gt;preview_pipe = NULL;</a>
<a name="ln78">  dt_pthread_mutex_init(&amp;dev-&gt;pipe_mutex, NULL);</a>
<a name="ln79">  dt_pthread_mutex_init(&amp;dev-&gt;preview_pipe_mutex, NULL);</a>
<a name="ln80">  //   dt_pthread_mutex_init(&amp;dev-&gt;histogram_waveform_mutex, NULL);</a>
<a name="ln81">  dev-&gt;histogram = NULL;</a>
<a name="ln82">  dev-&gt;histogram_pre_tonecurve = NULL;</a>
<a name="ln83">  dev-&gt;histogram_pre_levels = NULL;</a>
<a name="ln84">  gchar *mode = dt_conf_get_string(&quot;plugins/darkroom/histogram/mode&quot;);</a>
<a name="ln85">  if(g_strcmp0(mode, &quot;linear&quot;) == 0)</a>
<a name="ln86">    dev-&gt;histogram_type = DT_DEV_HISTOGRAM_LINEAR;</a>
<a name="ln87">  else if(g_strcmp0(mode, &quot;logarithmic&quot;) == 0)</a>
<a name="ln88">    dev-&gt;histogram_type = DT_DEV_HISTOGRAM_LOGARITHMIC;</a>
<a name="ln89">  else if(g_strcmp0(mode, &quot;waveform&quot;) == 0)</a>
<a name="ln90">    dev-&gt;histogram_type = DT_DEV_HISTOGRAM_WAVEFORM;</a>
<a name="ln91">  g_free(mode);</a>
<a name="ln92"> </a>
<a name="ln93">  dev-&gt;forms = NULL;</a>
<a name="ln94">  dev-&gt;form_visible = NULL;</a>
<a name="ln95">  dev-&gt;form_gui = NULL;</a>
<a name="ln96">  dev-&gt;allforms = NULL;</a>
<a name="ln97"> </a>
<a name="ln98">  if(dev-&gt;gui_attached)</a>
<a name="ln99">  {</a>
<a name="ln100">    dev-&gt;pipe = (dt_dev_pixelpipe_t *)malloc(sizeof(dt_dev_pixelpipe_t));</a>
<a name="ln101">    dev-&gt;preview_pipe = (dt_dev_pixelpipe_t *)malloc(sizeof(dt_dev_pixelpipe_t));</a>
<a name="ln102">    dt_dev_pixelpipe_init(dev-&gt;pipe);</a>
<a name="ln103">    dt_dev_pixelpipe_init_preview(dev-&gt;preview_pipe);</a>
<a name="ln104"> </a>
<a name="ln105">    dev-&gt;histogram = (uint32_t *)calloc(4 * 256, sizeof(uint32_t));</a>
<a name="ln106">    dev-&gt;histogram_pre_tonecurve = (uint32_t *)calloc(4 * 256, sizeof(uint32_t));</a>
<a name="ln107">    dev-&gt;histogram_pre_levels = (uint32_t *)calloc(4 * 256, sizeof(uint32_t));</a>
<a name="ln108"> </a>
<a name="ln109">    dev-&gt;histogram_max = -1;</a>
<a name="ln110">    dev-&gt;histogram_pre_tonecurve_max = -1;</a>
<a name="ln111">    dev-&gt;histogram_pre_levels_max = -1;</a>
<a name="ln112">  }</a>
<a name="ln113"> </a>
<a name="ln114">  dev-&gt;iop_instance = 0;</a>
<a name="ln115">  dev-&gt;iop = NULL;</a>
<a name="ln116">  dev-&gt;alliop = NULL;</a>
<a name="ln117"> </a>
<a name="ln118">  dev-&gt;proxy.exposure = NULL;</a>
<a name="ln119"> </a>
<a name="ln120">  dev-&gt;rawoverexposed.enabled = FALSE;</a>
<a name="ln121">  dev-&gt;rawoverexposed.mode = dt_conf_get_int(&quot;darkroom/ui/rawoverexposed/mode&quot;);</a>
<a name="ln122">  dev-&gt;rawoverexposed.colorscheme = dt_conf_get_int(&quot;darkroom/ui/rawoverexposed/colorscheme&quot;);</a>
<a name="ln123">  dev-&gt;rawoverexposed.threshold = dt_conf_get_float(&quot;darkroom/ui/rawoverexposed/threshold&quot;);</a>
<a name="ln124"> </a>
<a name="ln125">  dev-&gt;overexposed.enabled = FALSE;</a>
<a name="ln126">  dev-&gt;overexposed.colorscheme = dt_conf_get_int(&quot;darkroom/ui/overexposed/colorscheme&quot;);</a>
<a name="ln127">  dev-&gt;overexposed.lower = dt_conf_get_float(&quot;darkroom/ui/overexposed/lower&quot;);</a>
<a name="ln128">  dev-&gt;overexposed.upper = dt_conf_get_float(&quot;darkroom/ui/overexposed/upper&quot;);</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">void dt_dev_cleanup(dt_develop_t *dev)</a>
<a name="ln132">{</a>
<a name="ln133">  if(!dev) return;</a>
<a name="ln134">  // image_cache does not have to be unref'd, this is done outside develop module.</a>
<a name="ln135">  dt_pthread_mutex_destroy(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln136">  dt_pthread_mutex_destroy(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln137">  //   dt_pthread_mutex_destroy(&amp;dev-&gt;histogram_waveform_mutex);</a>
<a name="ln138">  if(dev-&gt;pipe)</a>
<a name="ln139">  {</a>
<a name="ln140">    dt_dev_pixelpipe_cleanup(dev-&gt;pipe);</a>
<a name="ln141">    free(dev-&gt;pipe);</a>
<a name="ln142">  }</a>
<a name="ln143">  if(dev-&gt;preview_pipe)</a>
<a name="ln144">  {</a>
<a name="ln145">    dt_dev_pixelpipe_cleanup(dev-&gt;preview_pipe);</a>
<a name="ln146">    free(dev-&gt;preview_pipe);</a>
<a name="ln147">  }</a>
<a name="ln148">  while(dev-&gt;history)</a>
<a name="ln149">  {</a>
<a name="ln150">    dt_dev_free_history_item(((dt_dev_history_item_t *)dev-&gt;history-&gt;data));</a>
<a name="ln151">    dev-&gt;history = g_list_delete_link(dev-&gt;history, dev-&gt;history);</a>
<a name="ln152">  }</a>
<a name="ln153">  while(dev-&gt;iop)</a>
<a name="ln154">  {</a>
<a name="ln155">    dt_iop_cleanup_module((dt_iop_module_t *)dev-&gt;iop-&gt;data);</a>
<a name="ln156">    free(dev-&gt;iop-&gt;data);</a>
<a name="ln157">    dev-&gt;iop = g_list_delete_link(dev-&gt;iop, dev-&gt;iop);</a>
<a name="ln158">  }</a>
<a name="ln159">  while(dev-&gt;alliop)</a>
<a name="ln160">  {</a>
<a name="ln161">    dt_iop_cleanup_module((dt_iop_module_t *)dev-&gt;alliop-&gt;data);</a>
<a name="ln162">    free(dev-&gt;alliop-&gt;data);</a>
<a name="ln163">    dev-&gt;alliop = g_list_delete_link(dev-&gt;alliop, dev-&gt;alliop);</a>
<a name="ln164">  }</a>
<a name="ln165">  dt_pthread_mutex_destroy(&amp;dev-&gt;history_mutex);</a>
<a name="ln166">  free(dev-&gt;histogram);</a>
<a name="ln167">  free(dev-&gt;histogram_pre_tonecurve);</a>
<a name="ln168">  free(dev-&gt;histogram_pre_levels);</a>
<a name="ln169"> </a>
<a name="ln170">  g_list_free(dev-&gt;forms);</a>
<a name="ln171">  g_list_free_full(dev-&gt;allforms, (void (*)(void *))dt_masks_free_form);</a>
<a name="ln172"> </a>
<a name="ln173">  g_list_free_full(dev-&gt;proxy.exposure, g_free);</a>
<a name="ln174"> </a>
<a name="ln175">  dt_conf_set_int(&quot;darkroom/ui/rawoverexposed/mode&quot;, dev-&gt;rawoverexposed.mode);</a>
<a name="ln176">  dt_conf_set_int(&quot;darkroom/ui/rawoverexposed/colorscheme&quot;, dev-&gt;rawoverexposed.colorscheme);</a>
<a name="ln177">  dt_conf_set_float(&quot;darkroom/ui/rawoverexposed/threshold&quot;, dev-&gt;rawoverexposed.threshold);</a>
<a name="ln178"> </a>
<a name="ln179">  dt_conf_set_int(&quot;darkroom/ui/overexposed/colorscheme&quot;, dev-&gt;overexposed.colorscheme);</a>
<a name="ln180">  dt_conf_set_float(&quot;darkroom/ui/overexposed/lower&quot;, dev-&gt;overexposed.lower);</a>
<a name="ln181">  dt_conf_set_float(&quot;darkroom/ui/overexposed/upper&quot;, dev-&gt;overexposed.upper);</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">void dt_dev_process_image(dt_develop_t *dev)</a>
<a name="ln185">{</a>
<a name="ln186">  if(!dev-&gt;gui_attached || dev-&gt;pipe-&gt;processing) return;</a>
<a name="ln187">  int err</a>
<a name="ln188">      = dt_control_add_job_res(darktable.control, dt_dev_process_image_job_create(dev), DT_CTL_WORKER_ZOOM_1);</a>
<a name="ln189">  if(err) fprintf(stderr, &quot;[dev_process_image] job queue exceeded!\n&quot;);</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">void dt_dev_process_preview(dt_develop_t *dev)</a>
<a name="ln193">{</a>
<a name="ln194">  if(!dev-&gt;gui_attached) return;</a>
<a name="ln195">  int err = dt_control_add_job_res(darktable.control, dt_dev_process_preview_job_create(dev),</a>
<a name="ln196">                                   DT_CTL_WORKER_ZOOM_FILL);</a>
<a name="ln197">  if(err) fprintf(stderr, &quot;[dev_process_preview] job queue exceeded!\n&quot;);</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">void dt_dev_invalidate(dt_develop_t *dev)</a>
<a name="ln201">{</a>
<a name="ln202">  dev-&gt;image_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln203">  dev-&gt;timestamp++;</a>
<a name="ln204">  if(dev-&gt;preview_pipe) dev-&gt;preview_pipe-&gt;input_timestamp = dev-&gt;timestamp;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">void dt_dev_invalidate_all(dt_develop_t *dev)</a>
<a name="ln208">{</a>
<a name="ln209">  dev-&gt;image_status = dev-&gt;preview_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln210">  dev-&gt;timestamp++;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">void dt_dev_process_preview_job(dt_develop_t *dev)</a>
<a name="ln214">{</a>
<a name="ln215">  if(dev-&gt;image_loading)</a>
<a name="ln216">  {</a>
<a name="ln217">    // raw is already loading, no use starting another file access, we wait.</a>
<a name="ln218">    return;</a>
<a name="ln219">  }</a>
<a name="ln220"> </a>
<a name="ln221">  dt_pthread_mutex_lock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln222"> </a>
<a name="ln223">  if(dev-&gt;gui_leaving)</a>
<a name="ln224">  {</a>
<a name="ln225">    dt_pthread_mutex_unlock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln226">    return;</a>
<a name="ln227">  }</a>
<a name="ln228"> </a>
<a name="ln229">  dt_control_log_busy_enter();</a>
<a name="ln230">  dev-&gt;preview_pipe-&gt;input_timestamp = dev-&gt;timestamp;</a>
<a name="ln231">  dev-&gt;preview_status = DT_DEV_PIXELPIPE_RUNNING;</a>
<a name="ln232"> </a>
<a name="ln233">  // lock if there, issue a background load, if not (best-effort for mip f).</a>
<a name="ln234">  dt_mipmap_buffer_t buf;</a>
<a name="ln235">  dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, dev-&gt;image_storage.id, DT_MIPMAP_F, DT_MIPMAP_BEST_EFFORT,</a>
<a name="ln236">                      'r');</a>
<a name="ln237">  if(!buf.buf)</a>
<a name="ln238">  {</a>
<a name="ln239">    dt_control_log_busy_leave();</a>
<a name="ln240">    dev-&gt;preview_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln241">    dt_pthread_mutex_unlock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln242">    return; // not loaded yet. load will issue a gtk redraw on completion, which in turn will trigger us again</a>
<a name="ln243">            // later.</a>
<a name="ln244">  }</a>
<a name="ln245">  // init pixel pipeline for preview.</a>
<a name="ln246">  dt_dev_pixelpipe_set_input(dev-&gt;preview_pipe, dev, (float *)buf.buf, buf.width, buf.height, buf.iscale);</a>
<a name="ln247"> </a>
<a name="ln248">  if(dev-&gt;preview_loading)</a>
<a name="ln249">  {</a>
<a name="ln250">    dt_dev_pixelpipe_cleanup_nodes(dev-&gt;preview_pipe);</a>
<a name="ln251">    dt_dev_pixelpipe_create_nodes(dev-&gt;preview_pipe, dev);</a>
<a name="ln252">    dt_dev_pixelpipe_flush_caches(dev-&gt;preview_pipe);</a>
<a name="ln253">    dev-&gt;preview_loading = 0;</a>
<a name="ln254">  }</a>
<a name="ln255"> </a>
<a name="ln256">  // if raw loaded, get new mipf</a>
<a name="ln257">  if(dev-&gt;preview_input_changed)</a>
<a name="ln258">  {</a>
<a name="ln259">    dt_dev_pixelpipe_flush_caches(dev-&gt;preview_pipe);</a>
<a name="ln260">    dev-&gt;preview_input_changed = 0;</a>
<a name="ln261">  }</a>
<a name="ln262"> </a>
<a name="ln263">// always process the whole downsampled mipf buffer, to allow for fast scrolling and mip4 write-through.</a>
<a name="ln264">restart:</a>
<a name="ln265">  if(dev-&gt;gui_leaving)</a>
<a name="ln266">  {</a>
<a name="ln267">    dt_control_log_busy_leave();</a>
<a name="ln268">    dev-&gt;preview_status = DT_DEV_PIXELPIPE_INVALID;</a>
<a name="ln269">    dt_pthread_mutex_unlock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln270">    dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln271">    return;</a>
<a name="ln272">  }</a>
<a name="ln273">  // adjust pipeline according to changed flag set by {add,pop}_history_item.</a>
<a name="ln274">  // this locks dev-&gt;history_mutex.</a>
<a name="ln275">  dt_times_t start;</a>
<a name="ln276">  dt_get_times(&amp;start);</a>
<a name="ln277">  dt_dev_pixelpipe_change(dev-&gt;preview_pipe, dev);</a>
<a name="ln278">  if(dt_dev_pixelpipe_process(</a>
<a name="ln279">         dev-&gt;preview_pipe, dev, 0, 0, dev-&gt;preview_pipe-&gt;processed_width * dev-&gt;preview_downsampling,</a>
<a name="ln280">         dev-&gt;preview_pipe-&gt;processed_height * dev-&gt;preview_downsampling, dev-&gt;preview_downsampling))</a>
<a name="ln281">  {</a>
<a name="ln282">    if(dev-&gt;preview_loading || dev-&gt;preview_input_changed)</a>
<a name="ln283">    {</a>
<a name="ln284">      dt_control_log_busy_leave();</a>
<a name="ln285">      dev-&gt;preview_status = DT_DEV_PIXELPIPE_INVALID;</a>
<a name="ln286">      dt_pthread_mutex_unlock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln287">      dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln288">      return;</a>
<a name="ln289">    }</a>
<a name="ln290">    else</a>
<a name="ln291">      goto restart;</a>
<a name="ln292">  }</a>
<a name="ln293"> </a>
<a name="ln294">  dev-&gt;preview_status = DT_DEV_PIXELPIPE_VALID;</a>
<a name="ln295"> </a>
<a name="ln296">  dt_show_times(&amp;start, &quot;[dev_process_preview] pixel pipeline processing&quot;, NULL);</a>
<a name="ln297">  dt_dev_average_delay_update(&amp;start, &amp;dev-&gt;preview_average_delay);</a>
<a name="ln298"> </a>
<a name="ln299">  // redraw the whole thing, to also update color picker values and histograms etc.</a>
<a name="ln300">  if(dev-&gt;gui_attached) dt_control_queue_redraw();</a>
<a name="ln301">  dt_control_log_busy_leave();</a>
<a name="ln302">  dt_pthread_mutex_unlock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln303">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">void dt_dev_process_image_job(dt_develop_t *dev)</a>
<a name="ln307">{</a>
<a name="ln308">  dt_pthread_mutex_lock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln309"> </a>
<a name="ln310">  if(dev-&gt;gui_leaving)</a>
<a name="ln311">  {</a>
<a name="ln312">    dt_pthread_mutex_unlock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln313">    return;</a>
<a name="ln314">  }</a>
<a name="ln315"> </a>
<a name="ln316">  dt_control_log_busy_enter();</a>
<a name="ln317">  // let gui know to draw preview instead of us, if it's there:</a>
<a name="ln318">  dev-&gt;image_status = DT_DEV_PIXELPIPE_RUNNING;</a>
<a name="ln319"> </a>
<a name="ln320">  dt_mipmap_buffer_t buf;</a>
<a name="ln321">  dt_times_t start;</a>
<a name="ln322">  dt_get_times(&amp;start);</a>
<a name="ln323">  dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, dev-&gt;image_storage.id, DT_MIPMAP_FULL,</a>
<a name="ln324">                           DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln325">  dt_show_times(&amp;start, &quot;[dev]&quot;, &quot;to load the image.&quot;);</a>
<a name="ln326"> </a>
<a name="ln327">  // failed to load raw?</a>
<a name="ln328">  if(!buf.buf)</a>
<a name="ln329">  {</a>
<a name="ln330">    dt_control_log_busy_leave();</a>
<a name="ln331">    dev-&gt;image_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln332">    dt_pthread_mutex_unlock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln333">    return;</a>
<a name="ln334">  }</a>
<a name="ln335"> </a>
<a name="ln336">  dt_dev_pixelpipe_set_input(dev-&gt;pipe, dev, (float *)buf.buf, buf.width, buf.height, 1.0);</a>
<a name="ln337"> </a>
<a name="ln338">  if(dev-&gt;image_loading)</a>
<a name="ln339">  {</a>
<a name="ln340">    // init pixel pipeline</a>
<a name="ln341">    dt_dev_pixelpipe_cleanup_nodes(dev-&gt;pipe);</a>
<a name="ln342">    dt_dev_pixelpipe_create_nodes(dev-&gt;pipe, dev);</a>
<a name="ln343">    if(dev-&gt;image_force_reload) dt_dev_pixelpipe_flush_caches(dev-&gt;pipe);</a>
<a name="ln344">    dev-&gt;image_force_reload = 0;</a>
<a name="ln345">    if(dev-&gt;gui_attached)</a>
<a name="ln346">    {</a>
<a name="ln347">      // during load, a mipf update could have been issued.</a>
<a name="ln348">      dev-&gt;preview_input_changed = 1;</a>
<a name="ln349">      dev-&gt;preview_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln350">      dev-&gt;gui_synch = 1; // notify gui thread we want to synch (call gui_update in the modules)</a>
<a name="ln351">      dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_SYNCH;</a>
<a name="ln352">    }</a>
<a name="ln353">    dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_SYNCH;</a>
<a name="ln354">  }</a>
<a name="ln355"> </a>
<a name="ln356">  dt_dev_zoom_t zoom;</a>
<a name="ln357">  float zoom_x, zoom_y, scale;</a>
<a name="ln358">  int window_width, window_height, x, y, closeup;</a>
<a name="ln359">  dt_dev_pixelpipe_change_t pipe_changed;</a>
<a name="ln360"> </a>
<a name="ln361">// adjust pipeline according to changed flag set by {add,pop}_history_item.</a>
<a name="ln362">restart:</a>
<a name="ln363">  if(dev-&gt;gui_leaving)</a>
<a name="ln364">  {</a>
<a name="ln365">    dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln366">    dt_control_log_busy_leave();</a>
<a name="ln367">    dev-&gt;image_status = DT_DEV_PIXELPIPE_INVALID;</a>
<a name="ln368">    dt_pthread_mutex_unlock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln369">    return;</a>
<a name="ln370">  }</a>
<a name="ln371">  dev-&gt;pipe-&gt;input_timestamp = dev-&gt;timestamp;</a>
<a name="ln372">  // dt_dev_pixelpipe_change() will clear the changed value</a>
<a name="ln373">  pipe_changed = dev-&gt;pipe-&gt;changed;</a>
<a name="ln374">  // this locks dev-&gt;history_mutex.</a>
<a name="ln375">  dt_dev_pixelpipe_change(dev-&gt;pipe, dev);</a>
<a name="ln376">  // determine scale according to new dimensions</a>
<a name="ln377">  zoom = dt_control_get_dev_zoom();</a>
<a name="ln378">  closeup = dt_control_get_dev_closeup();</a>
<a name="ln379">  zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln380">  zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln381">  // if just changed to an image with a different aspect ratio or</a>
<a name="ln382">  // altered image orientation, the prior zoom xy could now be beyond</a>
<a name="ln383">  // the image boundary</a>
<a name="ln384">  if(dev-&gt;image_loading || (pipe_changed != DT_DEV_PIPE_UNCHANGED))</a>
<a name="ln385">  {</a>
<a name="ln386">    dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, zoom, closeup, NULL, NULL);</a>
<a name="ln387">    dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln388">    dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln389">  }</a>
<a name="ln390"> </a>
<a name="ln391">  scale = dt_dev_get_zoom_scale(dev, zoom, 1.0f, 0) * darktable.gui-&gt;ppd;</a>
<a name="ln392">  window_width = dev-&gt;width * darktable.gui-&gt;ppd;</a>
<a name="ln393">  window_height = dev-&gt;height * darktable.gui-&gt;ppd;</a>
<a name="ln394">  if(closeup)</a>
<a name="ln395">  {</a>
<a name="ln396">    window_width /= 1&lt;&lt;closeup;</a>
<a name="ln397">    window_height /= 1&lt;&lt;closeup;</a>
<a name="ln398">  }</a>
<a name="ln399">  const int wd = MIN(window_width, dev-&gt;pipe-&gt;processed_width * scale);</a>
<a name="ln400">  const int ht = MIN(window_height, dev-&gt;pipe-&gt;processed_height * scale);</a>
<a name="ln401">  x = MAX(0, scale * dev-&gt;pipe-&gt;processed_width  * (.5 + zoom_x) - wd / 2);</a>
<a name="ln402">  y = MAX(0, scale * dev-&gt;pipe-&gt;processed_height * (.5 + zoom_y) - ht / 2);</a>
<a name="ln403"> </a>
<a name="ln404">  dt_get_times(&amp;start);</a>
<a name="ln405">  if(dt_dev_pixelpipe_process(dev-&gt;pipe, dev, x, y, wd, ht, scale))</a>
<a name="ln406">  {</a>
<a name="ln407">    // interrupted because image changed?</a>
<a name="ln408">    if(dev-&gt;image_force_reload)</a>
<a name="ln409">    {</a>
<a name="ln410">      dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln411">      dt_control_log_busy_leave();</a>
<a name="ln412">      dev-&gt;image_status = DT_DEV_PIXELPIPE_INVALID;</a>
<a name="ln413">      dt_pthread_mutex_unlock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln414">      return;</a>
<a name="ln415">    }</a>
<a name="ln416">    // or because the pipeline changed?</a>
<a name="ln417">    else</a>
<a name="ln418">      goto restart;</a>
<a name="ln419">  }</a>
<a name="ln420">  dt_show_times(&amp;start, &quot;[dev_process_image] pixel pipeline processing&quot;, NULL);</a>
<a name="ln421">  dt_dev_average_delay_update(&amp;start, &amp;dev-&gt;average_delay);</a>
<a name="ln422"> </a>
<a name="ln423">  // maybe we got zoomed/panned in the meantime?</a>
<a name="ln424">  if(dev-&gt;pipe-&gt;changed != DT_DEV_PIPE_UNCHANGED) goto restart;</a>
<a name="ln425"> </a>
<a name="ln426">  // cool, we got a new image!</a>
<a name="ln427">  dev-&gt;image_status = DT_DEV_PIXELPIPE_VALID;</a>
<a name="ln428">  dev-&gt;image_loading = 0;</a>
<a name="ln429"> </a>
<a name="ln430">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln431">  // redraw the whole thing, to also update color picker values and histograms etc.</a>
<a name="ln432">  if(dev-&gt;gui_attached) dt_control_queue_redraw();</a>
<a name="ln433">  dt_control_log_busy_leave();</a>
<a name="ln434">  dt_pthread_mutex_unlock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">// load the raw and get the new image struct, blocking in gui thread</a>
<a name="ln438">static inline void _dt_dev_load_raw(dt_develop_t *dev, const uint32_t imgid)</a>
<a name="ln439">{</a>
<a name="ln440">  // first load the raw, to make sure dt_image_t will contain all and correct data.</a>
<a name="ln441">  dt_mipmap_buffer_t buf;</a>
<a name="ln442">  dt_times_t start;</a>
<a name="ln443">  dt_get_times(&amp;start);</a>
<a name="ln444">  dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, DT_MIPMAP_FULL, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln445">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln446">  dt_show_times(&amp;start, &quot;[dev]&quot;, &quot;to load the image.&quot;);</a>
<a name="ln447"> </a>
<a name="ln448">  const dt_image_t *image = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln449">  dev-&gt;image_storage = *image;</a>
<a name="ln450">  dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">void dt_dev_reload_image(dt_develop_t *dev, const uint32_t imgid)</a>
<a name="ln454">{</a>
<a name="ln455">  _dt_dev_load_raw(dev, imgid);</a>
<a name="ln456">  dev-&gt;image_force_reload = dev-&gt;image_loading = dev-&gt;preview_loading = 1;</a>
<a name="ln457"> </a>
<a name="ln458">  dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_SYNCH;</a>
<a name="ln459">  dt_dev_invalidate(dev); // only invalidate image, preview will follow once it's loaded.</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">float dt_dev_get_zoom_scale(dt_develop_t *dev, dt_dev_zoom_t zoom, int closeup_factor, int preview)</a>
<a name="ln463">{</a>
<a name="ln464">  float zoom_scale;</a>
<a name="ln465"> </a>
<a name="ln466">  const float w = preview ? dev-&gt;preview_pipe-&gt;processed_width : dev-&gt;pipe-&gt;processed_width;</a>
<a name="ln467">  const float h = preview ? dev-&gt;preview_pipe-&gt;processed_height : dev-&gt;pipe-&gt;processed_height;</a>
<a name="ln468">  const float ps = dev-&gt;pipe-&gt;backbuf_width</a>
<a name="ln469">                       ? dev-&gt;pipe-&gt;processed_width / (float)dev-&gt;preview_pipe-&gt;processed_width</a>
<a name="ln470">                       : dev-&gt;preview_pipe-&gt;iscale / dev-&gt;preview_downsampling;</a>
<a name="ln471"> </a>
<a name="ln472">  switch(zoom)</a>
<a name="ln473">  {</a>
<a name="ln474">    case DT_ZOOM_FIT:</a>
<a name="ln475">      zoom_scale = fminf(dev-&gt;width / w, dev-&gt;height / h);</a>
<a name="ln476">      break;</a>
<a name="ln477">    case DT_ZOOM_FILL:</a>
<a name="ln478">      zoom_scale = fmaxf(dev-&gt;width / w, dev-&gt;height / h);</a>
<a name="ln479">      break;</a>
<a name="ln480">    case DT_ZOOM_1:</a>
<a name="ln481">      zoom_scale = closeup_factor;</a>
<a name="ln482">      if(preview) zoom_scale *= ps;</a>
<a name="ln483">      break;</a>
<a name="ln484">    default: // DT_ZOOM_FREE</a>
<a name="ln485">      zoom_scale = dt_control_get_dev_zoom_scale();</a>
<a name="ln486">      if(preview) zoom_scale *= ps;</a>
<a name="ln487">      break;</a>
<a name="ln488">  }</a>
<a name="ln489">  return zoom_scale;</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492">void dt_dev_load_image(dt_develop_t *dev, const uint32_t imgid)</a>
<a name="ln493">{</a>
<a name="ln494">  _dt_dev_load_raw(dev, imgid);</a>
<a name="ln495"> </a>
<a name="ln496">  if(dev-&gt;pipe)</a>
<a name="ln497">  {</a>
<a name="ln498">    dev-&gt;pipe-&gt;processed_width = 0;</a>
<a name="ln499">    dev-&gt;pipe-&gt;processed_height = 0;</a>
<a name="ln500">  }</a>
<a name="ln501">  dev-&gt;image_loading = 1;</a>
<a name="ln502">  dev-&gt;preview_loading = 1;</a>
<a name="ln503">  dev-&gt;first_load = 1;</a>
<a name="ln504">  dev-&gt;image_status = dev-&gt;preview_status = DT_DEV_PIXELPIPE_DIRTY;</a>
<a name="ln505"> </a>
<a name="ln506">  dev-&gt;iop = dt_iop_load_modules(dev);</a>
<a name="ln507"> </a>
<a name="ln508">  dt_masks_read_forms(dev);</a>
<a name="ln509"> </a>
<a name="ln510">  dt_dev_read_history(dev);</a>
<a name="ln511"> </a>
<a name="ln512">  dev-&gt;first_load = 0;</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">void dt_dev_configure(dt_develop_t *dev, int wd, int ht)</a>
<a name="ln516">{</a>
<a name="ln517">  // fixed border on every side</a>
<a name="ln518">  const int tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln519">  wd -= 2*tb;</a>
<a name="ln520">  ht -= 2*tb;</a>
<a name="ln521">  if(dev-&gt;width != wd || dev-&gt;height != ht)</a>
<a name="ln522">  {</a>
<a name="ln523">    dev-&gt;width = wd;</a>
<a name="ln524">    dev-&gt;height = ht;</a>
<a name="ln525">    dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_ZOOMED;</a>
<a name="ln526">    dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_ZOOMED;</a>
<a name="ln527">    dt_dev_invalidate(dev);</a>
<a name="ln528">  }</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">// helper used to synch a single history item with db</a>
<a name="ln532">int dt_dev_write_history_item(const int imgid, dt_dev_history_item_t *h, int32_t num)</a>
<a name="ln533">{</a>
<a name="ln534">//  if(!image) return 1;</a>
<a name="ln535">  sqlite3_stmt *stmt;</a>
<a name="ln536">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln537">                              &quot;SELECT num FROM main.history WHERE imgid = ?1 AND num = ?2&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln538">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln539">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, num);</a>
<a name="ln540">  if(sqlite3_step(stmt) != SQLITE_ROW)</a>
<a name="ln541">  {</a>
<a name="ln542">    sqlite3_finalize(stmt);</a>
<a name="ln543">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln544">                                &quot;INSERT INTO main.history (imgid, num) VALUES (?1, ?2)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln545">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln546">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, num);</a>
<a name="ln547">    sqlite3_step(stmt);</a>
<a name="ln548">  }</a>
<a name="ln549">  // printf(&quot;[dev write history item] writing %d - %s params %f %f\n&quot;, h-&gt;module-&gt;instance, h-&gt;module-&gt;op,</a>
<a name="ln550">  // *(float *)h-&gt;params, *(((float *)h-&gt;params)+1));</a>
<a name="ln551">  sqlite3_finalize(stmt);</a>
<a name="ln552">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln553">                              &quot;UPDATE main.history SET operation = ?1, op_params = ?2, module = ?3, enabled = ?4, &quot;</a>
<a name="ln554">                              &quot;blendop_params = ?7, blendop_version = ?8, multi_priority = ?9, multi_name = &quot;</a>
<a name="ln555">                              &quot;?10 WHERE imgid = ?5 AND num = ?6&quot;,</a>
<a name="ln556">                              -1, &amp;stmt, NULL);</a>
<a name="ln557">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, h-&gt;module-&gt;op, -1, SQLITE_TRANSIENT);</a>
<a name="ln558">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 2, h-&gt;params, h-&gt;module-&gt;params_size, SQLITE_TRANSIENT);</a>
<a name="ln559">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, h-&gt;module-&gt;version());</a>
<a name="ln560">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 4, h-&gt;enabled);</a>
<a name="ln561">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 5, imgid);</a>
<a name="ln562">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 6, num);</a>
<a name="ln563">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 7, h-&gt;blend_params, sizeof(dt_develop_blend_params_t), SQLITE_TRANSIENT);</a>
<a name="ln564">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 8, dt_develop_blend_version());</a>
<a name="ln565">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 9, h-&gt;multi_priority);</a>
<a name="ln566">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 10, h-&gt;multi_name, -1, SQLITE_TRANSIENT);</a>
<a name="ln567"> </a>
<a name="ln568">  sqlite3_step(stmt);</a>
<a name="ln569">  sqlite3_finalize(stmt);</a>
<a name="ln570">  return 0;</a>
<a name="ln571">}</a>
<a name="ln572"> </a>
<a name="ln573">void dt_dev_add_history_item_ext(dt_develop_t *dev, dt_iop_module_t *module, gboolean enable, gboolean no_image)</a>
<a name="ln574">{</a>
<a name="ln575">    GList *history = g_list_nth(dev-&gt;history, dev-&gt;history_end);</a>
<a name="ln576">    while(history)</a>
<a name="ln577">    {</a>
<a name="ln578">      GList *next = g_list_next(history);</a>
<a name="ln579">      dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln580">      // printf(&quot;removing obsoleted history item: %s\n&quot;, hist-&gt;module-&gt;op);</a>
<a name="ln581">      dt_dev_free_history_item(hist);</a>
<a name="ln582">      dev-&gt;history = g_list_delete_link(dev-&gt;history, history);</a>
<a name="ln583">      history = next;</a>
<a name="ln584">    }</a>
<a name="ln585">    history = g_list_nth(dev-&gt;history, dev-&gt;history_end - 1);</a>
<a name="ln586">    dt_dev_history_item_t *hist = history ? (dt_dev_history_item_t *)(history-&gt;data) : 0;</a>
<a name="ln587">    if(!history // if no history yet, push new item for sure.</a>
<a name="ln588">       || module != hist-&gt;module</a>
<a name="ln589">       || module-&gt;instance != hist-&gt;module-&gt;instance             // add new item for different op</a>
<a name="ln590">       || module-&gt;multi_priority != hist-&gt;module-&gt;multi_priority // or instance</a>
<a name="ln591">       || ((dev-&gt;focus_hash != hist-&gt;focus_hash)                 // or if focused out and in</a>
<a name="ln592">       &amp;&amp; (// but only add item if there is a difference at all for the same module</a>
<a name="ln593">         (module-&gt;params_size != hist-&gt;module-&gt;params_size) ||</a>
<a name="ln594">         (module-&gt;params_size == hist-&gt;module-&gt;params_size &amp;&amp; memcmp(hist-&gt;params, module-&gt;params, module-&gt;params_size)))))</a>
<a name="ln595">    {</a>
<a name="ln596">      // new operation, push new item</a>
<a name="ln597">      // printf(&quot;adding new history item %d - %s\n&quot;, dev-&gt;history_end, module-&gt;op);</a>
<a name="ln598">      // if(history) printf(&quot;because item %d - %s is different operation.\n&quot;, dev-&gt;history_end-1,</a>
<a name="ln599">      // ((dt_dev_history_item_t *)history-&gt;data)-&gt;module-&gt;op);</a>
<a name="ln600">      dev-&gt;history_end++;</a>
<a name="ln601"> </a>
<a name="ln602">      hist = (dt_dev_history_item_t *)malloc(sizeof(dt_dev_history_item_t));</a>
<a name="ln603">      if(enable)</a>
<a name="ln604">      {</a>
<a name="ln605">        module-&gt;enabled = TRUE;</a>
<a name="ln606">        if(!no_image)</a>
<a name="ln607">        {</a>
<a name="ln608">          if(module-&gt;off)</a>
<a name="ln609">          {</a>
<a name="ln610">            darktable.gui-&gt;reset = 1;</a>
<a name="ln611">            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(module-&gt;off), module-&gt;enabled);</a>
<a name="ln612">            darktable.gui-&gt;reset = 0;</a>
<a name="ln613">          }</a>
<a name="ln614">        }</a>
<a name="ln615">      }</a>
<a name="ln616">      snprintf(hist-&gt;op_name, sizeof(hist-&gt;op_name), &quot;%s&quot;, module-&gt;op);</a>
<a name="ln617">      hist-&gt;focus_hash = dev-&gt;focus_hash;</a>
<a name="ln618">      hist-&gt;enabled = module-&gt;enabled;</a>
<a name="ln619">      hist-&gt;module = module;</a>
<a name="ln620">      hist-&gt;params = malloc(module-&gt;params_size);</a>
<a name="ln621">      hist-&gt;multi_priority = module-&gt;multi_priority;</a>
<a name="ln622">      snprintf(hist-&gt;multi_name, sizeof(hist-&gt;multi_name), &quot;%s&quot;, module-&gt;multi_name);</a>
<a name="ln623">      /* allocate and set hist blend_params */</a>
<a name="ln624">      hist-&gt;blend_params = malloc(sizeof(dt_develop_blend_params_t));</a>
<a name="ln625">      memcpy(hist-&gt;params, module-&gt;params, module-&gt;params_size);</a>
<a name="ln626">      memcpy(hist-&gt;blend_params, module-&gt;blend_params, sizeof(dt_develop_blend_params_t));</a>
<a name="ln627"> </a>
<a name="ln628">      dev-&gt;history = g_list_append(dev-&gt;history, hist);</a>
<a name="ln629">      if(!no_image)</a>
<a name="ln630">      {</a>
<a name="ln631">        dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_SYNCH;</a>
<a name="ln632">        dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_SYNCH; // topology remains, as modules are fixed for now.</a>
<a name="ln633">      }</a>
<a name="ln634">    }</a>
<a name="ln635">    else</a>
<a name="ln636">    {</a>
<a name="ln637">      // same operation, change params</a>
<a name="ln638">      // printf(&quot;changing same history item %d - %s\n&quot;, dev-&gt;history_end-1, module-&gt;op);</a>
<a name="ln639">      hist = (dt_dev_history_item_t *)history-&gt;data;</a>
<a name="ln640">      memcpy(hist-&gt;params, module-&gt;params, module-&gt;params_size);</a>
<a name="ln641"> </a>
<a name="ln642">      if(module-&gt;flags() &amp; IOP_FLAGS_SUPPORTS_BLENDING)</a>
<a name="ln643">        memcpy(hist-&gt;blend_params, module-&gt;blend_params, sizeof(dt_develop_blend_params_t));</a>
<a name="ln644"> </a>
<a name="ln645">      // if the user changed stuff and the module is still not enabled, do it:</a>
<a name="ln646">      if(!hist-&gt;enabled &amp;&amp; !module-&gt;enabled)</a>
<a name="ln647">      {</a>
<a name="ln648">        module-&gt;enabled = 1;</a>
<a name="ln649">        if(!no_image)</a>
<a name="ln650">        {</a>
<a name="ln651">          if(module-&gt;off)</a>
<a name="ln652">          {</a>
<a name="ln653">            darktable.gui-&gt;reset = 1;</a>
<a name="ln654">            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(module-&gt;off), module-&gt;enabled);</a>
<a name="ln655">            darktable.gui-&gt;reset = 0;</a>
<a name="ln656">          }</a>
<a name="ln657">        }</a>
<a name="ln658">      }</a>
<a name="ln659">      hist-&gt;multi_priority = module-&gt;multi_priority;</a>
<a name="ln660">      memcpy(hist-&gt;multi_name, module-&gt;multi_name, sizeof(module-&gt;multi_name));</a>
<a name="ln661">      hist-&gt;enabled = module-&gt;enabled;</a>
<a name="ln662">      if(!no_image)</a>
<a name="ln663">      {</a>
<a name="ln664">        dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_TOP_CHANGED;</a>
<a name="ln665">        dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_TOP_CHANGED;</a>
<a name="ln666">      }</a>
<a name="ln667">    }</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">void dt_dev_add_history_item(dt_develop_t *dev, dt_iop_module_t *module, gboolean enable)</a>
<a name="ln671">{</a>
<a name="ln672">  if(!darktable.gui || darktable.gui-&gt;reset) return;</a>
<a name="ln673">  dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln674"> </a>
<a name="ln675">  if(dev-&gt;gui_attached)</a>
<a name="ln676">  {</a>
<a name="ln677">    dt_dev_add_history_item_ext(dev, module, enable, FALSE);</a>
<a name="ln678">  }</a>
<a name="ln679">#if 0</a>
<a name="ln680">  {</a>
<a name="ln681">    // debug:</a>
<a name="ln682">    printf(&quot;remaining %d history items:\n&quot;, dev-&gt;history_end);</a>
<a name="ln683">    GList *history = dev-&gt;history;</a>
<a name="ln684">    int i = 0;</a>
<a name="ln685">    while(history)</a>
<a name="ln686">    {</a>
<a name="ln687">      dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln688">      printf(&quot;%d %s\n&quot;, i, hist-&gt;module-&gt;op);</a>
<a name="ln689">      history = g_list_next(history);</a>
<a name="ln690">      i++;</a>
<a name="ln691">    }</a>
<a name="ln692">  }</a>
<a name="ln693">#endif</a>
<a name="ln694"> </a>
<a name="ln695">  // invalidate buffers and force redraw of darkroom</a>
<a name="ln696">  dt_dev_invalidate_all(dev);</a>
<a name="ln697">  dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln698"> </a>
<a name="ln699">  if(dev-&gt;gui_attached)</a>
<a name="ln700">  {</a>
<a name="ln701">    /* signal that history has changed */</a>
<a name="ln702">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE);</a>
<a name="ln703"> </a>
<a name="ln704">    /* redraw */</a>
<a name="ln705">    dt_control_queue_redraw_center();</a>
<a name="ln706">  }</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">void dt_dev_free_history_item(gpointer data)</a>
<a name="ln710">{</a>
<a name="ln711">  dt_dev_history_item_t *item = (dt_dev_history_item_t *)data;</a>
<a name="ln712">  free(item-&gt;params);</a>
<a name="ln713">  free(item-&gt;blend_params);</a>
<a name="ln714">  free(item);</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">void dt_dev_reload_history_items(dt_develop_t *dev)</a>
<a name="ln718">{</a>
<a name="ln719">  dev-&gt;focus_hash = 0;</a>
<a name="ln720">  dt_dev_pop_history_items(dev, 0);</a>
<a name="ln721">  // remove unused history items:</a>
<a name="ln722">  GList *history = g_list_nth(dev-&gt;history, dev-&gt;history_end);</a>
<a name="ln723">  while(history)</a>
<a name="ln724">  {</a>
<a name="ln725">    GList *next = g_list_next(history);</a>
<a name="ln726">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln727">    dt_dev_free_history_item(hist);</a>
<a name="ln728">    dev-&gt;history = g_list_delete_link(dev-&gt;history, history);</a>
<a name="ln729">    history = next;</a>
<a name="ln730">  }</a>
<a name="ln731">  dt_dev_read_history(dev);</a>
<a name="ln732"> </a>
<a name="ln733">  // we have to add new module instances first</a>
<a name="ln734">  GList *modules = dev-&gt;iop;</a>
<a name="ln735">  while(modules)</a>
<a name="ln736">  {</a>
<a name="ln737">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln738">    if(module-&gt;multi_priority &gt; 0)</a>
<a name="ln739">    {</a>
<a name="ln740">      if(!dt_iop_is_hidden(module) &amp;&amp; !module-&gt;expander)</a>
<a name="ln741">      {</a>
<a name="ln742">        module-&gt;gui_init(module);</a>
<a name="ln743">        dt_iop_reload_defaults(module);</a>
<a name="ln744">        // we search the base iop corresponding</a>
<a name="ln745">        GList *mods = g_list_first(dev-&gt;iop);</a>
<a name="ln746">        dt_iop_module_t *base = NULL;</a>
<a name="ln747">        int pos_module = 0;</a>
<a name="ln748">        int pos_base = 0;</a>
<a name="ln749">        int pos = 0;</a>
<a name="ln750">        while(mods)</a>
<a name="ln751">        {</a>
<a name="ln752">          dt_iop_module_t *mod = (dt_iop_module_t *)(mods-&gt;data);</a>
<a name="ln753">          if(mod-&gt;multi_priority == 0 &amp;&amp; mod-&gt;instance == module-&gt;instance)</a>
<a name="ln754">          {</a>
<a name="ln755">            base = mod;</a>
<a name="ln756">            pos_base = pos;</a>
<a name="ln757">          }</a>
<a name="ln758">          else if(mod == module)</a>
<a name="ln759">            pos_module = pos;</a>
<a name="ln760">          mods = g_list_next(mods);</a>
<a name="ln761">          pos++;</a>
<a name="ln762">        }</a>
<a name="ln763">        if(!base) continue;</a>
<a name="ln764"> </a>
<a name="ln765">        /* add module to right panel */</a>
<a name="ln766">        GtkWidget *expander = dt_iop_gui_get_expander(module);</a>
<a name="ln767">        dt_ui_container_add_widget(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER, expander);</a>
<a name="ln768">        GValue gv = { 0, { { 0 } } };</a>
<a name="ln769">        g_value_init(&amp;gv, G_TYPE_INT);</a>
<a name="ln770">        gtk_container_child_get_property(</a>
<a name="ln771">            GTK_CONTAINER(dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER)),</a>
<a name="ln772">            base-&gt;expander, &quot;position&quot;, &amp;gv);</a>
<a name="ln773">        gtk_box_reorder_child(dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER),</a>
<a name="ln774">                              expander, g_value_get_int(&amp;gv) + pos_base - pos_module);</a>
<a name="ln775">        dt_iop_gui_set_expanded(module, TRUE, FALSE);</a>
<a name="ln776">        dt_iop_gui_update_blending(module);</a>
<a name="ln777"> </a>
<a name="ln778">        // the pipe need to be reconstruct</a>
<a name="ln779">        dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln780">        dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln781">      }</a>
<a name="ln782">    }</a>
<a name="ln783">    else if(!dt_iop_is_hidden(module) &amp;&amp; module-&gt;expander)</a>
<a name="ln784">    {</a>
<a name="ln785">      // we have to ensure that the name of the widget is correct</a>
<a name="ln786">      GtkWidget *wlabel;</a>
<a name="ln787">      GList *childs = gtk_container_get_children(GTK_CONTAINER(module-&gt;expander));</a>
<a name="ln788">      GtkWidget *header = gtk_bin_get_child(GTK_BIN(g_list_nth_data(childs, 0)));</a>
<a name="ln789">      g_list_free(childs);</a>
<a name="ln790"> </a>
<a name="ln791">      /* get arrow icon widget */</a>
<a name="ln792">      childs = gtk_container_get_children(GTK_CONTAINER(header));</a>
<a name="ln793">      wlabel = g_list_nth(childs, 5)-&gt;data;</a>
<a name="ln794">      g_list_free(childs);</a>
<a name="ln795"> </a>
<a name="ln796">      gchar *label = dt_history_item_get_name_html(module);</a>
<a name="ln797">      gtk_label_set_markup(GTK_LABEL(wlabel), label);</a>
<a name="ln798">      g_free(label);</a>
<a name="ln799">    }</a>
<a name="ln800">    modules = g_list_next(modules);</a>
<a name="ln801">  }</a>
<a name="ln802"> </a>
<a name="ln803">  dt_dev_pop_history_items(dev, dev-&gt;history_end);</a>
<a name="ln804">}</a>
<a name="ln805"> </a>
<a name="ln806">void dt_dev_pop_history_items_ext(dt_develop_t *dev, int32_t cnt)</a>
<a name="ln807">{</a>
<a name="ln808">  // printf(&quot;dev popping all history items &gt;= %d\n&quot;, cnt);</a>
<a name="ln809">  dev-&gt;history_end = cnt;</a>
<a name="ln810">  // reset gui params for all modules</a>
<a name="ln811">  GList *modules = dev-&gt;iop;</a>
<a name="ln812">  while(modules)</a>
<a name="ln813">  {</a>
<a name="ln814">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln815">    memcpy(module-&gt;params, module-&gt;default_params, module-&gt;params_size);</a>
<a name="ln816">    dt_iop_commit_blend_params(module, module-&gt;default_blendop_params);</a>
<a name="ln817">    module-&gt;enabled = module-&gt;default_enabled;</a>
<a name="ln818">    module-&gt;multi_name[0] = '\0';</a>
<a name="ln819">    modules = g_list_next(modules);</a>
<a name="ln820">  }</a>
<a name="ln821">  // go through history and set gui params</a>
<a name="ln822">  GList *history = dev-&gt;history;</a>
<a name="ln823">  for(int i = 0; i &lt; cnt &amp;&amp; history; i++)</a>
<a name="ln824">  {</a>
<a name="ln825">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln826">    memcpy(hist-&gt;module-&gt;params, hist-&gt;params, hist-&gt;module-&gt;params_size);</a>
<a name="ln827">    dt_iop_commit_blend_params(hist-&gt;module, hist-&gt;blend_params);</a>
<a name="ln828"> </a>
<a name="ln829">    hist-&gt;module-&gt;enabled = hist-&gt;enabled;</a>
<a name="ln830">    snprintf(hist-&gt;module-&gt;multi_name, sizeof(hist-&gt;module-&gt;multi_name), &quot;%s&quot;, hist-&gt;multi_name);</a>
<a name="ln831"> </a>
<a name="ln832">    history = g_list_next(history);</a>
<a name="ln833">  }</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836">void dt_dev_pop_history_items(dt_develop_t *dev, int32_t cnt)</a>
<a name="ln837">{</a>
<a name="ln838">  dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln839">  darktable.gui-&gt;reset = 1;</a>
<a name="ln840"> </a>
<a name="ln841">  dt_dev_pop_history_items_ext(dev, cnt);</a>
<a name="ln842"> </a>
<a name="ln843">  // update all gui modules</a>
<a name="ln844">  GList *modules = dev-&gt;iop;</a>
<a name="ln845">  while(modules)</a>
<a name="ln846">  {</a>
<a name="ln847">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln848">    dt_iop_gui_update(module);</a>
<a name="ln849">    modules = g_list_next(modules);</a>
<a name="ln850">  }</a>
<a name="ln851">  dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_SYNCH;</a>
<a name="ln852">  dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_SYNCH; // again, fixed topology for now.</a>
<a name="ln853">  darktable.gui-&gt;reset = 0;</a>
<a name="ln854">  dt_dev_invalidate_all(dev);</a>
<a name="ln855">  dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln856">  dt_control_queue_redraw_center();</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859">void dt_dev_write_history_ext(dt_develop_t *dev, const int imgid)</a>
<a name="ln860">{</a>
<a name="ln861">  sqlite3_stmt *stmt;</a>
<a name="ln862"> </a>
<a name="ln863">  gboolean changed = FALSE;</a>
<a name="ln864">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln865">                              &amp;stmt, NULL);</a>
<a name="ln866">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln867">  sqlite3_step(stmt);</a>
<a name="ln868">  sqlite3_finalize(stmt);</a>
<a name="ln869">  GList *history = dev-&gt;history;</a>
<a name="ln870">  for(int i = 0; history; i++)</a>
<a name="ln871">  {</a>
<a name="ln872">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln873">    (void)dt_dev_write_history_item(imgid, hist, i);</a>
<a name="ln874">    history = g_list_next(history);</a>
<a name="ln875">    changed = TRUE;</a>
<a name="ln876">  }</a>
<a name="ln877"> </a>
<a name="ln878">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln879">                              &quot;UPDATE main.images SET history_end = ?1 WHERE id = ?2&quot;, -1,</a>
<a name="ln880">                              &amp;stmt, NULL);</a>
<a name="ln881">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dev-&gt;history_end);</a>
<a name="ln882">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln883">  sqlite3_step(stmt);</a>
<a name="ln884">  sqlite3_finalize(stmt);</a>
<a name="ln885"> </a>
<a name="ln886">  /* attach / detach changed tag reflecting actual change */</a>
<a name="ln887">  guint tagid = 0;</a>
<a name="ln888">  dt_tag_new(&quot;darktable|changed&quot;, &amp;tagid);</a>
<a name="ln889">  if(changed)</a>
<a name="ln890">    dt_tag_attach(tagid, imgid);</a>
<a name="ln891">  else</a>
<a name="ln892">    dt_tag_detach(tagid, imgid);</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895">void dt_dev_write_history(dt_develop_t *dev)</a>
<a name="ln896">{</a>
<a name="ln897">  dt_dev_write_history_ext(dev, dev-&gt;image_storage.id);</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900">static void auto_apply_presets(dt_develop_t *dev)</a>
<a name="ln901">{</a>
<a name="ln902">  const int imgid = dev-&gt;image_storage.id;</a>
<a name="ln903"> </a>
<a name="ln904">  if(imgid &lt;= 0) return;</a>
<a name="ln905"> </a>
<a name="ln906">  // be extra sure that we don't mess up history in separate threads:</a>
<a name="ln907">  dt_pthread_mutex_lock(&amp;darktable.db_insert);</a>
<a name="ln908"> </a>
<a name="ln909">  int run = 0;</a>
<a name="ln910">  dt_image_t *image = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln911">  if(!(image-&gt;flags &amp; DT_IMAGE_AUTO_PRESETS_APPLIED)) run = 1;</a>
<a name="ln912"> </a>
<a name="ln913">  // flag was already set? only apply presets once in the lifetime of a history stack.</a>
<a name="ln914">  // (the flag will be cleared when removing it)</a>
<a name="ln915">  if(!run || image-&gt;id &lt;= 0)</a>
<a name="ln916">  {</a>
<a name="ln917">    dt_image_cache_write_release(darktable.image_cache, image, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln918">    dt_pthread_mutex_unlock(&amp;darktable.db_insert);</a>
<a name="ln919">    return;</a>
<a name="ln920">  }</a>
<a name="ln921"> </a>
<a name="ln922">  // cleanup</a>
<a name="ln923">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM memory.history&quot;, NULL, NULL, NULL);</a>
<a name="ln924">  const char *preset_table[2] = { &quot;data.presets&quot;, &quot;main.legacy_presets&quot; };</a>
<a name="ln925">  const int legacy = (image-&gt;flags &amp; DT_IMAGE_NO_LEGACY_PRESETS) ? 0 : 1;</a>
<a name="ln926">  char query[1024];</a>
<a name="ln927">  snprintf(query, sizeof(query), &quot;INSERT INTO memory.history SELECT ?1, 0, op_version, operation, op_params, &quot;</a>
<a name="ln928">                                 &quot;enabled, blendop_params, blendop_version, multi_priority, multi_name &quot;</a>
<a name="ln929">                                 &quot;FROM %s WHERE autoapply=1 AND &quot;</a>
<a name="ln930">                                 &quot;((?2 LIKE model AND ?3 LIKE maker) OR (?4 LIKE model AND ?5 LIKE maker)) AND &quot;</a>
<a name="ln931">                                 &quot;?6 LIKE lens AND ?7 BETWEEN iso_min AND iso_max AND &quot;</a>
<a name="ln932">                                 &quot;?8 BETWEEN exposure_min AND exposure_max AND &quot;</a>
<a name="ln933">                                 &quot;?9 BETWEEN aperture_min AND aperture_max AND &quot;</a>
<a name="ln934">                                 &quot;?10 BETWEEN focal_length_min AND focal_length_max AND &quot;</a>
<a name="ln935">                                 &quot;(format = 0 OR format&amp;?11!=0) ORDER BY writeprotect DESC, &quot;</a>
<a name="ln936">                                 &quot;LENGTH(model), LENGTH(maker), LENGTH(lens)&quot;,</a>
<a name="ln937">           preset_table[legacy]);</a>
<a name="ln938">  // query for all modules at once:</a>
<a name="ln939">  sqlite3_stmt *stmt;</a>
<a name="ln940">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln941">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln942">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, image-&gt;exif_model, -1, SQLITE_TRANSIENT);</a>
<a name="ln943">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 3, image-&gt;exif_maker, -1, SQLITE_TRANSIENT);</a>
<a name="ln944">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, image-&gt;camera_alias, -1, SQLITE_TRANSIENT);</a>
<a name="ln945">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 5, image-&gt;camera_maker, -1, SQLITE_TRANSIENT);</a>
<a name="ln946">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 6, image-&gt;exif_lens, -1, SQLITE_TRANSIENT);</a>
<a name="ln947">  DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 7, fmaxf(0.0f, fminf(FLT_MAX, image-&gt;exif_iso)));</a>
<a name="ln948">  DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 8, fmaxf(0.0f, fminf(1000000, image-&gt;exif_exposure)));</a>
<a name="ln949">  DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 9, fmaxf(0.0f, fminf(1000000, image-&gt;exif_aperture)));</a>
<a name="ln950">  DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 10, fmaxf(0.0f, fminf(1000000, image-&gt;exif_focal_length)));</a>
<a name="ln951">  // 0: dontcare, 1: ldr, 2: raw</a>
<a name="ln952">  DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 11,</a>
<a name="ln953">                               dt_image_is_ldr(image) ? FOR_LDR : (dt_image_is_raw(image) ? FOR_RAW : FOR_HDR));</a>
<a name="ln954"> </a>
<a name="ln955">  if(sqlite3_step(stmt) == SQLITE_DONE)</a>
<a name="ln956">  {</a>
<a name="ln957">    sqlite3_finalize(stmt);</a>
<a name="ln958">    int cnt = 0;</a>
<a name="ln959">    // count what we found:</a>
<a name="ln960">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT COUNT(*) FROM memory.history&quot;, -1,</a>
<a name="ln961">                                &amp;stmt, NULL);</a>
<a name="ln962">    if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln963">    {</a>
<a name="ln964">      // if there is anything..</a>
<a name="ln965">      cnt = sqlite3_column_int(stmt, 0);</a>
<a name="ln966">      sqlite3_finalize(stmt);</a>
<a name="ln967"> </a>
<a name="ln968">      // workaround a sqlite3 &quot;feature&quot;. The above statement to insert items into memory.history is complex and in</a>
<a name="ln969">      // this case sqlite does not give rowid a linear increment. But the following code really expect that the rowid in</a>
<a name="ln970">      // this table starts from 0 and increment one by one. So in the following code we rewrite the num values.</a>
<a name="ln971"> </a>
<a name="ln972">      if(cnt &gt; 0)</a>
<a name="ln973">      {</a>
<a name="ln974">        // get all rowids</a>
<a name="ln975">        GList *rowids = NULL;</a>
<a name="ln976"> </a>
<a name="ln977">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln978">                                    &quot;SELECT rowid FROM memory.history ORDER BY rowid ASC&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln979">        while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln980">          rowids = g_list_append(rowids, GINT_TO_POINTER(sqlite3_column_int(stmt, 0)));</a>
<a name="ln981">        sqlite3_finalize(stmt);</a>
<a name="ln982"> </a>
<a name="ln983">        // update num accordingly</a>
<a name="ln984">        int v = 0;</a>
<a name="ln985"> </a>
<a name="ln986">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln987">                                    &quot;UPDATE memory.history SET num=?1 WHERE rowid=?2&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln988"> </a>
<a name="ln989">        // let's wrap this into a transaction, it might make it a little faster.</a>
<a name="ln990">        sqlite3_exec(dt_database_get(darktable.db), &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln991">        for(GList *r = rowids; r; r = g_list_next(r))</a>
<a name="ln992">        {</a>
<a name="ln993">          DT_DEBUG_SQLITE3_CLEAR_BINDINGS(stmt);</a>
<a name="ln994">          DT_DEBUG_SQLITE3_RESET(stmt);</a>
<a name="ln995">          DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, v);</a>
<a name="ln996">          DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, GPOINTER_TO_INT(r-&gt;data));</a>
<a name="ln997"> </a>
<a name="ln998">          if(sqlite3_step(stmt) != SQLITE_DONE) break;</a>
<a name="ln999"> </a>
<a name="ln1000">          v++;</a>
<a name="ln1001">        }</a>
<a name="ln1002"> </a>
<a name="ln1003">        sqlite3_exec(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln1004"> </a>
<a name="ln1005">        g_list_free(rowids);</a>
<a name="ln1006">        sqlite3_finalize(stmt);</a>
<a name="ln1007">      }</a>
<a name="ln1008"> </a>
<a name="ln1009">      // fprintf(stderr, &quot;[auto_apply_presets] imageid %d found %d matching presets (legacy %d)\n&quot;, imgid,</a>
<a name="ln1010">      // cnt, legacy);</a>
<a name="ln1011">      // advance the current history by that amount:</a>
<a name="ln1012">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1013">                                  &quot;UPDATE main.history SET num=num+?1 WHERE imgid=?2&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1014">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, cnt);</a>
<a name="ln1015">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln1016"> </a>
<a name="ln1017">      if(sqlite3_step(stmt) == SQLITE_DONE)</a>
<a name="ln1018">      {</a>
<a name="ln1019">        sqlite3_finalize(stmt);</a>
<a name="ln1020">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1021">                                    &quot;UPDATE main.images SET history_end=history_end+?1 WHERE id=?2&quot;,</a>
<a name="ln1022">                                    -1, &amp;stmt, NULL);</a>
<a name="ln1023">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, cnt);</a>
<a name="ln1024">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln1025">        if(sqlite3_step(stmt) == SQLITE_DONE)</a>
<a name="ln1026">        {</a>
<a name="ln1027">          // and finally prepend the rest with increasing numbers (starting at 0)</a>
<a name="ln1028">          sqlite3_finalize(stmt);</a>
<a name="ln1029">          DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln1030">              dt_database_get(darktable.db),</a>
<a name="ln1031">              &quot;INSERT INTO main.history SELECT imgid, num, module, operation, op_params, enabled, &quot;</a>
<a name="ln1032">              &quot;blendop_params, blendop_version, multi_priority, multi_name FROM memory.history&quot;,</a>
<a name="ln1033">              -1, &amp;stmt, NULL);</a>
<a name="ln1034">          sqlite3_step(stmt);</a>
<a name="ln1035">        }</a>
<a name="ln1036">      }</a>
<a name="ln1037">    }</a>
<a name="ln1038">  }</a>
<a name="ln1039">  sqlite3_finalize(stmt);</a>
<a name="ln1040"> </a>
<a name="ln1041">  //  first time we are loading the image, try to import lightroom .xmp if any</a>
<a name="ln1042">  if(dev-&gt;image_loading) dt_lightroom_import(dev-&gt;image_storage.id, dev, TRUE);</a>
<a name="ln1043"> </a>
<a name="ln1044">  image-&gt;flags |= DT_IMAGE_AUTO_PRESETS_APPLIED | DT_IMAGE_NO_LEGACY_PRESETS;</a>
<a name="ln1045">  dt_pthread_mutex_unlock(&amp;darktable.db_insert);</a>
<a name="ln1046"> </a>
<a name="ln1047">  // make sure these end up in the image_cache + xmp (sync through here if we set the flag)</a>
<a name="ln1048">  dt_image_cache_write_release(darktable.image_cache, image, DT_IMAGE_CACHE_SAFE);</a>
<a name="ln1049">}</a>
<a name="ln1050"> </a>
<a name="ln1051">void dt_dev_read_history_ext(dt_develop_t *dev, const int imgid, gboolean no_image)</a>
<a name="ln1052">{</a>
<a name="ln1053">  if(!no_image)</a>
<a name="ln1054">  {</a>
<a name="ln1055">    if(imgid &lt;= 0) return;</a>
<a name="ln1056">    if(!dev-&gt;iop) return;</a>
<a name="ln1057"> </a>
<a name="ln1058">    // maybe prepend auto-presets to history before loading it:</a>
<a name="ln1059">    auto_apply_presets(dev);</a>
<a name="ln1060">  }</a>
<a name="ln1061"> </a>
<a name="ln1062">  sqlite3_stmt *stmt;</a>
<a name="ln1063">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid, num, module, operation, &quot;</a>
<a name="ln1064">                                                             &quot;op_params, enabled, blendop_params, &quot;</a>
<a name="ln1065">                                                             &quot;blendop_version, multi_priority, multi_name &quot;</a>
<a name="ln1066">                                                             &quot;FROM main.history WHERE imgid = ?1 ORDER BY num&quot;,</a>
<a name="ln1067">                              -1, &amp;stmt, NULL);</a>
<a name="ln1068">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1069">  dev-&gt;history_end = 0;</a>
<a name="ln1070">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1071">  {</a>
<a name="ln1072">    // db record:</a>
<a name="ln1073">    // 0-img, 1-num, 2-module_instance, 3-operation char, 4-params blob, 5-enabled, 6-blend_params,</a>
<a name="ln1074">    // 7-blendop_version, 8 multi_priority, 9 multi_name</a>
<a name="ln1075">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)malloc(sizeof(dt_dev_history_item_t));</a>
<a name="ln1076">    hist-&gt;enabled = sqlite3_column_int(stmt, 5);</a>
<a name="ln1077"> </a>
<a name="ln1078">    const char *opname = (const char *)sqlite3_column_text(stmt, 3);</a>
<a name="ln1079">    int multi_priority = sqlite3_column_int(stmt, 8);</a>
<a name="ln1080">    const char *multi_name = (const char *)sqlite3_column_text(stmt, 9);</a>
<a name="ln1081">    if(!opname)</a>
<a name="ln1082">    {</a>
<a name="ln1083">      fprintf(stderr, &quot;[dev_read_history] database history for image `%s' seems to be corrupted!\n&quot;,</a>
<a name="ln1084">              dev-&gt;image_storage.filename);</a>
<a name="ln1085">      free(hist);</a>
<a name="ln1086">      continue;</a>
<a name="ln1087">    }</a>
<a name="ln1088"> </a>
<a name="ln1089">    hist-&gt;module = NULL;</a>
<a name="ln1090">    dt_iop_module_t *find_op = NULL;</a>
<a name="ln1091">    for(GList *modules = dev-&gt;iop; modules; modules = g_list_next(modules))</a>
<a name="ln1092">    {</a>
<a name="ln1093">      dt_iop_module_t *module = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1094">      if(!strcmp(module-&gt;op, opname))</a>
<a name="ln1095">      {</a>
<a name="ln1096">        if(module-&gt;multi_priority == multi_priority)</a>
<a name="ln1097">        {</a>
<a name="ln1098">          hist-&gt;module = module;</a>
<a name="ln1099">          if(multi_name)</a>
<a name="ln1100">            snprintf(module-&gt;multi_name, sizeof(module-&gt;multi_name), &quot;%s&quot;, multi_name);</a>
<a name="ln1101">          else</a>
<a name="ln1102">            memset(module-&gt;multi_name, 0, sizeof(module-&gt;multi_name));</a>
<a name="ln1103">          break;</a>
<a name="ln1104">        }</a>
<a name="ln1105">        else if(multi_priority &gt; 0)</a>
<a name="ln1106">        {</a>
<a name="ln1107">          // we just say that we find the name, so we just have to add new instance of this module</a>
<a name="ln1108">          find_op = module;</a>
<a name="ln1109">        }</a>
<a name="ln1110">      }</a>
<a name="ln1111">    }</a>
<a name="ln1112">    if(!hist-&gt;module &amp;&amp; find_op)</a>
<a name="ln1113">    {</a>
<a name="ln1114">      // we have to add a new instance of this module and set index to modindex</a>
<a name="ln1115">      dt_iop_module_t *new_module = (dt_iop_module_t *)calloc(1, sizeof(dt_iop_module_t));</a>
<a name="ln1116">      if(!dt_iop_load_module(new_module, find_op-&gt;so, dev))</a>
<a name="ln1117">      {</a>
<a name="ln1118">        dt_iop_update_multi_priority(new_module, multi_priority);</a>
<a name="ln1119"> </a>
<a name="ln1120">        snprintf(new_module-&gt;multi_name, sizeof(new_module-&gt;multi_name), &quot;%s&quot;, multi_name);</a>
<a name="ln1121"> </a>
<a name="ln1122">        dev-&gt;iop = g_list_insert_sorted(dev-&gt;iop, new_module, sort_plugins);</a>
<a name="ln1123"> </a>
<a name="ln1124">        new_module-&gt;instance = find_op-&gt;instance;</a>
<a name="ln1125">        hist-&gt;module = new_module;</a>
<a name="ln1126">      }</a>
<a name="ln1127">    }</a>
<a name="ln1128"> </a>
<a name="ln1129">    if(!hist-&gt;module)</a>
<a name="ln1130">    {</a>
<a name="ln1131">      fprintf(</a>
<a name="ln1132">          stderr,</a>
<a name="ln1133">          &quot;[dev_read_history] the module `%s' requested by image `%s' is not installed on this computer!\n&quot;,</a>
<a name="ln1134">          opname, dev-&gt;image_storage.filename);</a>
<a name="ln1135">      free(hist);</a>
<a name="ln1136">      continue;</a>
<a name="ln1137">    }</a>
<a name="ln1138"> </a>
<a name="ln1139">    if(hist-&gt;module-&gt;flags() &amp; IOP_FLAGS_NO_HISTORY_STACK)</a>
<a name="ln1140">    {</a>
<a name="ln1141">      free(hist);</a>
<a name="ln1142">      continue;</a>
<a name="ln1143">    }</a>
<a name="ln1144"> </a>
<a name="ln1145">    int modversion = sqlite3_column_int(stmt, 2);</a>
<a name="ln1146">    assert(strcmp((char *)sqlite3_column_text(stmt, 3), hist-&gt;module-&gt;op) == 0);</a>
<a name="ln1147">    hist-&gt;params = malloc(hist-&gt;module-&gt;params_size);</a>
<a name="ln1148">    hist-&gt;blend_params = malloc(sizeof(dt_develop_blend_params_t));</a>
<a name="ln1149">    snprintf(hist-&gt;op_name, sizeof(hist-&gt;op_name), &quot;%s&quot;, hist-&gt;module-&gt;op);</a>
<a name="ln1150">    snprintf(hist-&gt;multi_name, sizeof(hist-&gt;multi_name), &quot;%s&quot;, multi_name);</a>
<a name="ln1151">    hist-&gt;multi_priority = multi_priority;</a>
<a name="ln1152"> </a>
<a name="ln1153">    const void *blendop_params = sqlite3_column_blob(stmt, 6);</a>
<a name="ln1154">    int bl_length = sqlite3_column_bytes(stmt, 6);</a>
<a name="ln1155">    int blendop_version = sqlite3_column_int(stmt, 7);</a>
<a name="ln1156"> </a>
<a name="ln1157">    if(blendop_params &amp;&amp; (blendop_version == dt_develop_blend_version())</a>
<a name="ln1158">       &amp;&amp; (bl_length == sizeof(dt_develop_blend_params_t)))</a>
<a name="ln1159">    {</a>
<a name="ln1160">      memcpy(hist-&gt;blend_params, blendop_params, sizeof(dt_develop_blend_params_t));</a>
<a name="ln1161">    }</a>
<a name="ln1162">    else if(blendop_params</a>
<a name="ln1163">            &amp;&amp; dt_develop_blend_legacy_params(hist-&gt;module, blendop_params, blendop_version,</a>
<a name="ln1164">                                              hist-&gt;blend_params, dt_develop_blend_version(), bl_length) == 0)</a>
<a name="ln1165">    {</a>
<a name="ln1166">      // do nothing</a>
<a name="ln1167">    }</a>
<a name="ln1168">    else</a>
<a name="ln1169">    {</a>
<a name="ln1170">      memcpy(hist-&gt;blend_params, hist-&gt;module-&gt;default_blendop_params, sizeof(dt_develop_blend_params_t));</a>
<a name="ln1171">    }</a>
<a name="ln1172"> </a>
<a name="ln1173">    if(hist-&gt;module-&gt;version() != modversion || hist-&gt;module-&gt;params_size != sqlite3_column_bytes(stmt, 4)</a>
<a name="ln1174">       || strcmp((char *)sqlite3_column_text(stmt, 3), hist-&gt;module-&gt;op))</a>
<a name="ln1175">    {</a>
<a name="ln1176">      if(!hist-&gt;module-&gt;legacy_params</a>
<a name="ln1177">         || hist-&gt;module-&gt;legacy_params(hist-&gt;module, sqlite3_column_blob(stmt, 4), labs(modversion),</a>
<a name="ln1178">                                        hist-&gt;params, labs(hist-&gt;module-&gt;version())))</a>
<a name="ln1179">      {</a>
<a name="ln1180">        fprintf(stderr, &quot;[dev_read_history] module `%s' version mismatch: history is %d, dt %d.\n&quot;,</a>
<a name="ln1181">                hist-&gt;module-&gt;op, modversion, hist-&gt;module-&gt;version());</a>
<a name="ln1182">        const char *fname = dev-&gt;image_storage.filename + strlen(dev-&gt;image_storage.filename);</a>
<a name="ln1183">        while(fname &gt; dev-&gt;image_storage.filename &amp;&amp; *fname != '/') fname--;</a>
<a name="ln1184">        if(fname &gt; dev-&gt;image_storage.filename) fname++;</a>
<a name="ln1185">        dt_control_log(_(&quot;%s: module `%s' version mismatch: %d != %d&quot;), fname, hist-&gt;module-&gt;op,</a>
<a name="ln1186">                       hist-&gt;module-&gt;version(), modversion);</a>
<a name="ln1187">        dt_dev_free_history_item(hist);</a>
<a name="ln1188">        continue;</a>
<a name="ln1189">      }</a>
<a name="ln1190">      else</a>
<a name="ln1191">      {</a>
<a name="ln1192">        if(!strcmp(hist-&gt;module-&gt;op, &quot;spots&quot;) &amp;&amp; modversion == 1)</a>
<a name="ln1193">        {</a>
<a name="ln1194">          // quick and dirty hack to handle spot removal legacy_params</a>
<a name="ln1195">          memcpy(hist-&gt;blend_params, hist-&gt;module-&gt;blend_params, sizeof(dt_develop_blend_params_t));</a>
<a name="ln1196">          dt_iop_commit_blend_params(hist-&gt;module, hist-&gt;module-&gt;default_blendop_params);</a>
<a name="ln1197">        }</a>
<a name="ln1198">      }</a>
<a name="ln1199"> </a>
<a name="ln1200">      /*</a>
<a name="ln1201">       * Fix for flip iop: previously it was not always needed, but it might be</a>
<a name="ln1202">       * in history stack as &quot;orientation (off)&quot;, but now we always want it</a>
<a name="ln1203">       * by default, so if it is disabled, enable it, and replace params with</a>
<a name="ln1204">       * default_params. if user want to, he can disable it.</a>
<a name="ln1205">       */</a>
<a name="ln1206">      if(!strcmp(hist-&gt;module-&gt;op, &quot;flip&quot;) &amp;&amp; hist-&gt;enabled == 0 &amp;&amp; labs(modversion) == 1)</a>
<a name="ln1207">      {</a>
<a name="ln1208">        memcpy(hist-&gt;params, hist-&gt;module-&gt;default_params, hist-&gt;module-&gt;params_size);</a>
<a name="ln1209">        hist-&gt;enabled = 1;</a>
<a name="ln1210">      }</a>
<a name="ln1211">    }</a>
<a name="ln1212">    else</a>
<a name="ln1213">    {</a>
<a name="ln1214">      memcpy(hist-&gt;params, sqlite3_column_blob(stmt, 4), hist-&gt;module-&gt;params_size);</a>
<a name="ln1215">    }</a>
<a name="ln1216"> </a>
<a name="ln1217">    // make sure that always-on modules are always on. duh.</a>
<a name="ln1218">    if(hist-&gt;module-&gt;default_enabled == 1 &amp;&amp; hist-&gt;module-&gt;hide_enable_button == 1)</a>
<a name="ln1219">    {</a>
<a name="ln1220">      hist-&gt;enabled = 1;</a>
<a name="ln1221">    }</a>
<a name="ln1222"> </a>
<a name="ln1223">    // memcpy(hist-&gt;module-&gt;params, hist-&gt;params, hist-&gt;module-&gt;params_size);</a>
<a name="ln1224">    // hist-&gt;module-&gt;enabled = hist-&gt;enabled;</a>
<a name="ln1225">    // printf(&quot;[dev read history] img %d number %d for operation %d - %s params %f %f\n&quot;,</a>
<a name="ln1226">    // sqlite3_column_int(stmt, 0), sqlite3_column_int(stmt, 1), instance, hist-&gt;module-&gt;op, *(float</a>
<a name="ln1227">    // *)hist-&gt;params, *(((float*)hist-&gt;params)+1));</a>
<a name="ln1228">    dev-&gt;history = g_list_append(dev-&gt;history, hist);</a>
<a name="ln1229">    dev-&gt;history_end++;</a>
<a name="ln1230">  }</a>
<a name="ln1231">  sqlite3_finalize(stmt);</a>
<a name="ln1232"> </a>
<a name="ln1233">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT history_end FROM main.images WHERE id = ?1&quot;,</a>
<a name="ln1234">                              -1, &amp;stmt, NULL);</a>
<a name="ln1235">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1236">  if(sqlite3_step(stmt) == SQLITE_ROW) // seriously, this should never fail</a>
<a name="ln1237">  {</a>
<a name="ln1238">    if(sqlite3_column_type(stmt, 0) != SQLITE_NULL)</a>
<a name="ln1239">      dev-&gt;history_end = sqlite3_column_int(stmt, 0);</a>
<a name="ln1240">  }</a>
<a name="ln1241"> </a>
<a name="ln1242">  if(dev-&gt;gui_attached &amp;&amp; !no_image)</a>
<a name="ln1243">  {</a>
<a name="ln1244">    dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_SYNCH;</a>
<a name="ln1245">    dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_SYNCH; // again, fixed topology for now.</a>
<a name="ln1246">    dt_dev_invalidate_all(dev);</a>
<a name="ln1247"> </a>
<a name="ln1248">    /* signal history changed */</a>
<a name="ln1249">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE);</a>
<a name="ln1250">  }</a>
<a name="ln1251">  sqlite3_finalize(stmt);</a>
<a name="ln1252">}</a>
<a name="ln1253"> </a>
<a name="ln1254">void dt_dev_read_history(dt_develop_t *dev)</a>
<a name="ln1255">{</a>
<a name="ln1256">  dt_dev_read_history_ext(dev, dev-&gt;image_storage.id, FALSE);</a>
<a name="ln1257">}</a>
<a name="ln1258"> </a>
<a name="ln1259">void dt_dev_reprocess_all(dt_develop_t *dev)</a>
<a name="ln1260">{</a>
<a name="ln1261">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln1262">  if(dev &amp;&amp; dev-&gt;gui_attached)</a>
<a name="ln1263">  {</a>
<a name="ln1264">    dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_SYNCH;</a>
<a name="ln1265">    dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_SYNCH;</a>
<a name="ln1266">    dev-&gt;pipe-&gt;cache_obsolete = 1;</a>
<a name="ln1267">    dev-&gt;preview_pipe-&gt;cache_obsolete = 1;</a>
<a name="ln1268"> </a>
<a name="ln1269">    // invalidate buffers and force redraw of darkroom</a>
<a name="ln1270">    dt_dev_invalidate_all(dev);</a>
<a name="ln1271"> </a>
<a name="ln1272">    /* redraw */</a>
<a name="ln1273">    dt_control_queue_redraw_center();</a>
<a name="ln1274">  }</a>
<a name="ln1275">}</a>
<a name="ln1276"> </a>
<a name="ln1277">void dt_dev_reprocess_center(dt_develop_t *dev)</a>
<a name="ln1278">{</a>
<a name="ln1279">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln1280">  if(dev &amp;&amp; dev-&gt;gui_attached)</a>
<a name="ln1281">  {</a>
<a name="ln1282">    dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_SYNCH;</a>
<a name="ln1283">    dev-&gt;pipe-&gt;cache_obsolete = 1;</a>
<a name="ln1284"> </a>
<a name="ln1285">    // invalidate buffers and force redraw of darkroom</a>
<a name="ln1286">    dt_dev_invalidate_all(dev);</a>
<a name="ln1287"> </a>
<a name="ln1288">    /* redraw */</a>
<a name="ln1289">    dt_control_queue_redraw_center();</a>
<a name="ln1290">  }</a>
<a name="ln1291">}</a>
<a name="ln1292"> </a>
<a name="ln1293"> </a>
<a name="ln1294">void dt_dev_check_zoom_bounds(dt_develop_t *dev, float *zoom_x, float *zoom_y, dt_dev_zoom_t zoom,</a>
<a name="ln1295">                              int closeup, float *boxww, float *boxhh)</a>
<a name="ln1296">{</a>
<a name="ln1297">  int procw = 0, proch = 0;</a>
<a name="ln1298">  dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln1299">  float boxw = 1, boxh = 1; // viewport in normalised space</a>
<a name="ln1300">                            //   if(zoom == DT_ZOOM_1)</a>
<a name="ln1301">                            //   {</a>
<a name="ln1302">                            //     const float imgw = (closeup ? 2 : 1)*procw;</a>
<a name="ln1303">                            //     const float imgh = (closeup ? 2 : 1)*proch;</a>
<a name="ln1304">                            //     const float devw = MIN(imgw, dev-&gt;width);</a>
<a name="ln1305">                            //     const float devh = MIN(imgh, dev-&gt;height);</a>
<a name="ln1306">                            //     boxw = fminf(1.0, devw/imgw);</a>
<a name="ln1307">                            //     boxh = fminf(1.0, devh/imgh);</a>
<a name="ln1308">                            //   }</a>
<a name="ln1309">  if(zoom == DT_ZOOM_FIT)</a>
<a name="ln1310">  {</a>
<a name="ln1311">    *zoom_x = *zoom_y = 0.0f;</a>
<a name="ln1312">    boxw = boxh = 1.0f;</a>
<a name="ln1313">  }</a>
<a name="ln1314">  else</a>
<a name="ln1315">  {</a>
<a name="ln1316">    const float scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln1317">    const float imgw = procw;</a>
<a name="ln1318">    const float imgh = proch;</a>
<a name="ln1319">    const float devw = dev-&gt;width;</a>
<a name="ln1320">    const float devh = dev-&gt;height;</a>
<a name="ln1321">    boxw = devw / (imgw * scale);</a>
<a name="ln1322">    boxh = devh / (imgh * scale);</a>
<a name="ln1323">  }</a>
<a name="ln1324"> </a>
<a name="ln1325">  if(*zoom_x &lt; boxw / 2 - .5) *zoom_x = boxw / 2 - .5;</a>
<a name="ln1326">  if(*zoom_x &gt; .5 - boxw / 2) *zoom_x = .5 - boxw / 2;</a>
<a name="ln1327">  if(*zoom_y &lt; boxh / 2 - .5) *zoom_y = boxh / 2 - .5;</a>
<a name="ln1328">  if(*zoom_y &gt; .5 - boxh / 2) *zoom_y = .5 - boxh / 2;</a>
<a name="ln1329">  if(boxw &gt; 1.0) *zoom_x = 0.f;</a>
<a name="ln1330">  if(boxh &gt; 1.0) *zoom_y = 0.f;</a>
<a name="ln1331"> </a>
<a name="ln1332">  if(boxww) *boxww = boxw;</a>
<a name="ln1333">  if(boxhh) *boxhh = boxh;</a>
<a name="ln1334">}</a>
<a name="ln1335"> </a>
<a name="ln1336">void dt_dev_get_processed_size(const dt_develop_t *dev, int *procw, int *proch)</a>
<a name="ln1337">{</a>
<a name="ln1338">  if(!dev) return;</a>
<a name="ln1339"> </a>
<a name="ln1340">  // if pipe is processed, lets return its size</a>
<a name="ln1341">  if(dev-&gt;pipe &amp;&amp; dev-&gt;pipe-&gt;processed_width)</a>
<a name="ln1342">  {</a>
<a name="ln1343">    *procw = dev-&gt;pipe-&gt;processed_width;</a>
<a name="ln1344">    *proch = dev-&gt;pipe-&gt;processed_height;</a>
<a name="ln1345">    return;</a>
<a name="ln1346">  }</a>
<a name="ln1347"> </a>
<a name="ln1348">  // fallback on preview pipe</a>
<a name="ln1349">  if(dev-&gt;preview_pipe &amp;&amp; dev-&gt;preview_pipe-&gt;processed_width)</a>
<a name="ln1350">  {</a>
<a name="ln1351">    const float scale = (dev-&gt;preview_pipe-&gt;iscale / dev-&gt;preview_downsampling);</a>
<a name="ln1352">    *procw = scale * dev-&gt;preview_pipe-&gt;processed_width;</a>
<a name="ln1353">    *proch = scale * dev-&gt;preview_pipe-&gt;processed_height;</a>
<a name="ln1354">    return;</a>
<a name="ln1355">  }</a>
<a name="ln1356"> </a>
<a name="ln1357">  // no processed pipes, lets return 0 size</a>
<a name="ln1358">  *procw = *proch = 0;</a>
<a name="ln1359">  return;</a>
<a name="ln1360">}</a>
<a name="ln1361"> </a>
<a name="ln1362">void dt_dev_get_pointer_zoom_pos(dt_develop_t *dev, const float px, const float py, float *zoom_x,</a>
<a name="ln1363">                                 float *zoom_y)</a>
<a name="ln1364">{</a>
<a name="ln1365">  dt_dev_zoom_t zoom;</a>
<a name="ln1366">  int closeup, procw = 0, proch = 0;</a>
<a name="ln1367">  float zoom2_x, zoom2_y;</a>
<a name="ln1368">  zoom = dt_control_get_dev_zoom();</a>
<a name="ln1369">  closeup = dt_control_get_dev_closeup();</a>
<a name="ln1370">  zoom2_x = dt_control_get_dev_zoom_x();</a>
<a name="ln1371">  zoom2_y = dt_control_get_dev_zoom_y();</a>
<a name="ln1372">  dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln1373">  const float scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln1374">  // offset from center now (current zoom_{x,y} points there)</a>
<a name="ln1375">  const float mouse_off_x = px - .5 * dev-&gt;width, mouse_off_y = py - .5 * dev-&gt;height;</a>
<a name="ln1376">  zoom2_x += mouse_off_x / (procw * scale);</a>
<a name="ln1377">  zoom2_y += mouse_off_y / (proch * scale);</a>
<a name="ln1378">  *zoom_x = zoom2_x;</a>
<a name="ln1379">  *zoom_y = zoom2_y;</a>
<a name="ln1380">}</a>
<a name="ln1381"> </a>
<a name="ln1382">void dt_dev_get_history_item_label(dt_dev_history_item_t *hist, char *label, const int cnt)</a>
<a name="ln1383">{</a>
<a name="ln1384">  gchar *module_label = dt_history_item_get_name(hist-&gt;module);</a>
<a name="ln1385">  g_snprintf(label, cnt, &quot;%s (%s)&quot;, module_label, hist-&gt;enabled ? _(&quot;on&quot;) : _(&quot;off&quot;));</a>
<a name="ln1386">  g_free(module_label);</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389">int dt_dev_is_current_image(dt_develop_t *dev, uint32_t imgid)</a>
<a name="ln1390">{</a>
<a name="ln1391">  return (dev-&gt;image_storage.id == imgid) ? 1 : 0;</a>
<a name="ln1392">}</a>
<a name="ln1393"> </a>
<a name="ln1394">gint dt_dev_exposure_hooks_sort(gconstpointer a, gconstpointer b)</a>
<a name="ln1395">{</a>
<a name="ln1396">  const dt_dev_proxy_exposure_t *ai = (const dt_dev_proxy_exposure_t *)a;</a>
<a name="ln1397">  const dt_dev_proxy_exposure_t *bi = (const dt_dev_proxy_exposure_t *)b;</a>
<a name="ln1398">  const dt_iop_module_t *am = (const dt_iop_module_t *)ai-&gt;module;</a>
<a name="ln1399">  const dt_iop_module_t *bm = (const dt_iop_module_t *)bi-&gt;module;</a>
<a name="ln1400">  if(am-&gt;priority == bm-&gt;priority) return bm-&gt;multi_priority - am-&gt;multi_priority;</a>
<a name="ln1401">  return am-&gt;priority - bm-&gt;priority;</a>
<a name="ln1402">}</a>
<a name="ln1403"> </a>
<a name="ln1404">static dt_dev_proxy_exposure_t *find_last_exposure_instance(dt_develop_t *dev)</a>
<a name="ln1405">{</a>
<a name="ln1406">  if(!dev-&gt;proxy.exposure) return NULL;</a>
<a name="ln1407"> </a>
<a name="ln1408">  dev-&gt;proxy.exposure = g_list_sort(dev-&gt;proxy.exposure, dt_dev_exposure_hooks_sort);</a>
<a name="ln1409">  dt_dev_proxy_exposure_t *instance = (dt_dev_proxy_exposure_t *)(g_list_last(dev-&gt;proxy.exposure)-&gt;data);</a>
<a name="ln1410"> </a>
<a name="ln1411">  return instance;</a>
<a name="ln1412">};</a>
<a name="ln1413"> </a>
<a name="ln1414">gboolean dt_dev_exposure_hooks_available(dt_develop_t *dev)</a>
<a name="ln1415">{</a>
<a name="ln1416">  dt_dev_proxy_exposure_t *instance = find_last_exposure_instance(dev);</a>
<a name="ln1417"> </a>
<a name="ln1418">  /* check if exposure iop module has registered its hooks */</a>
<a name="ln1419">  if(instance &amp;&amp; instance-&gt;module &amp;&amp; instance-&gt;set_black &amp;&amp; instance-&gt;get_black &amp;&amp; instance-&gt;set_exposure</a>
<a name="ln1420">     &amp;&amp; instance-&gt;get_exposure)</a>
<a name="ln1421">    return TRUE;</a>
<a name="ln1422"> </a>
<a name="ln1423">  return FALSE;</a>
<a name="ln1424">}</a>
<a name="ln1425"> </a>
<a name="ln1426">void dt_dev_exposure_reset_defaults(dt_develop_t *dev)</a>
<a name="ln1427">{</a>
<a name="ln1428">  if(!dev-&gt;proxy.exposure) return;</a>
<a name="ln1429"> </a>
<a name="ln1430">  dt_dev_proxy_exposure_t *instance = find_last_exposure_instance(dev);</a>
<a name="ln1431"> </a>
<a name="ln1432">  if(!(instance &amp;&amp; instance-&gt;module)) return;</a>
<a name="ln1433"> </a>
<a name="ln1434">  dt_iop_module_t *exposure = instance-&gt;module;</a>
<a name="ln1435">  memcpy(exposure-&gt;params, exposure-&gt;default_params, exposure-&gt;params_size);</a>
<a name="ln1436">  exposure-&gt;gui_update(exposure);</a>
<a name="ln1437">  dt_dev_add_history_item(exposure-&gt;dev, exposure, TRUE);</a>
<a name="ln1438">}</a>
<a name="ln1439"> </a>
<a name="ln1440">void dt_dev_exposure_set_exposure(dt_develop_t *dev, const float exposure)</a>
<a name="ln1441">{</a>
<a name="ln1442">  dt_dev_proxy_exposure_t *instance = find_last_exposure_instance(dev);</a>
<a name="ln1443"> </a>
<a name="ln1444">  if(instance &amp;&amp; instance-&gt;module &amp;&amp; instance-&gt;set_exposure) instance-&gt;set_exposure(instance-&gt;module, exposure);</a>
<a name="ln1445">}</a>
<a name="ln1446"> </a>
<a name="ln1447">float dt_dev_exposure_get_exposure(dt_develop_t *dev)</a>
<a name="ln1448">{</a>
<a name="ln1449">  dt_dev_proxy_exposure_t *instance = find_last_exposure_instance(dev);</a>
<a name="ln1450"> </a>
<a name="ln1451">  if(instance &amp;&amp; instance-&gt;module &amp;&amp; instance-&gt;get_exposure) return instance-&gt;get_exposure(instance-&gt;module);</a>
<a name="ln1452"> </a>
<a name="ln1453">  return 0.0;</a>
<a name="ln1454">}</a>
<a name="ln1455"> </a>
<a name="ln1456">void dt_dev_exposure_set_black(dt_develop_t *dev, const float black)</a>
<a name="ln1457">{</a>
<a name="ln1458">  dt_dev_proxy_exposure_t *instance = find_last_exposure_instance(dev);</a>
<a name="ln1459"> </a>
<a name="ln1460">  if(instance &amp;&amp; instance-&gt;module &amp;&amp; instance-&gt;set_black) instance-&gt;set_black(instance-&gt;module, black);</a>
<a name="ln1461">}</a>
<a name="ln1462"> </a>
<a name="ln1463">float dt_dev_exposure_get_black(dt_develop_t *dev)</a>
<a name="ln1464">{</a>
<a name="ln1465">  dt_dev_proxy_exposure_t *instance = find_last_exposure_instance(dev);</a>
<a name="ln1466"> </a>
<a name="ln1467">  if(instance &amp;&amp; instance-&gt;module &amp;&amp; instance-&gt;get_black) return instance-&gt;get_black(instance-&gt;module);</a>
<a name="ln1468"> </a>
<a name="ln1469">  return 0.0;</a>
<a name="ln1470">}</a>
<a name="ln1471"> </a>
<a name="ln1472">gboolean dt_dev_modulegroups_available(dt_develop_t *dev)</a>
<a name="ln1473">{</a>
<a name="ln1474">  if(dev-&gt;proxy.modulegroups.module &amp;&amp; dev-&gt;proxy.modulegroups.set &amp;&amp; dev-&gt;proxy.modulegroups.get)</a>
<a name="ln1475">    return TRUE;</a>
<a name="ln1476"> </a>
<a name="ln1477">  return FALSE;</a>
<a name="ln1478">}</a>
<a name="ln1479"> </a>
<a name="ln1480">void dt_dev_modulegroups_set(dt_develop_t *dev, uint32_t group)</a>
<a name="ln1481">{</a>
<a name="ln1482">  if(dev-&gt;proxy.modulegroups.module &amp;&amp; dev-&gt;proxy.modulegroups.set &amp;&amp; dev-&gt;first_load == 0)</a>
<a name="ln1483">    dev-&gt;proxy.modulegroups.set(dev-&gt;proxy.modulegroups.module, group);</a>
<a name="ln1484">}</a>
<a name="ln1485"> </a>
<a name="ln1486">uint32_t dt_dev_modulegroups_get(dt_develop_t *dev)</a>
<a name="ln1487">{</a>
<a name="ln1488">  if(dev-&gt;proxy.modulegroups.module &amp;&amp; dev-&gt;proxy.modulegroups.get)</a>
<a name="ln1489">    return dev-&gt;proxy.modulegroups.get(dev-&gt;proxy.modulegroups.module);</a>
<a name="ln1490"> </a>
<a name="ln1491">  return 0;</a>
<a name="ln1492">}</a>
<a name="ln1493"> </a>
<a name="ln1494">gboolean dt_dev_modulegroups_test(dt_develop_t *dev, uint32_t group, uint32_t iop_group)</a>
<a name="ln1495">{</a>
<a name="ln1496">  if(dev-&gt;proxy.modulegroups.module &amp;&amp; dev-&gt;proxy.modulegroups.test)</a>
<a name="ln1497">    return dev-&gt;proxy.modulegroups.test(dev-&gt;proxy.modulegroups.module, group, iop_group);</a>
<a name="ln1498">  return FALSE;</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">void dt_dev_modulegroups_switch(dt_develop_t *dev, dt_iop_module_t *module)</a>
<a name="ln1502">{</a>
<a name="ln1503">  if(dev-&gt;proxy.modulegroups.module &amp;&amp; dev-&gt;proxy.modulegroups.switch_group &amp;&amp; dev-&gt;first_load == 0)</a>
<a name="ln1504">    dev-&gt;proxy.modulegroups.switch_group(dev-&gt;proxy.modulegroups.module, module);</a>
<a name="ln1505">}</a>
<a name="ln1506"> </a>
<a name="ln1507">void dt_dev_masks_list_change(dt_develop_t *dev)</a>
<a name="ln1508">{</a>
<a name="ln1509">  if(dev-&gt;proxy.masks.module &amp;&amp; dev-&gt;proxy.masks.list_change)</a>
<a name="ln1510">    dev-&gt;proxy.masks.list_change(dev-&gt;proxy.masks.module);</a>
<a name="ln1511">}</a>
<a name="ln1512">void dt_dev_masks_list_update(dt_develop_t *dev)</a>
<a name="ln1513">{</a>
<a name="ln1514">  if(dev-&gt;proxy.masks.module &amp;&amp; dev-&gt;proxy.masks.list_update)</a>
<a name="ln1515">    dev-&gt;proxy.masks.list_update(dev-&gt;proxy.masks.module);</a>
<a name="ln1516">}</a>
<a name="ln1517">void dt_dev_masks_list_remove(dt_develop_t *dev, int formid, int parentid)</a>
<a name="ln1518">{</a>
<a name="ln1519">  if(dev-&gt;proxy.masks.module &amp;&amp; dev-&gt;proxy.masks.list_remove)</a>
<a name="ln1520">    dev-&gt;proxy.masks.list_remove(dev-&gt;proxy.masks.module, formid, parentid);</a>
<a name="ln1521">}</a>
<a name="ln1522">void dt_dev_masks_selection_change(dt_develop_t *dev, int selectid, int throw_event)</a>
<a name="ln1523">{</a>
<a name="ln1524">  if(dev-&gt;proxy.masks.module &amp;&amp; dev-&gt;proxy.masks.selection_change)</a>
<a name="ln1525">    dev-&gt;proxy.masks.selection_change(dev-&gt;proxy.masks.module, selectid, throw_event);</a>
<a name="ln1526">}</a>
<a name="ln1527"> </a>
<a name="ln1528">void dt_dev_snapshot_request(dt_develop_t *dev, const char *filename)</a>
<a name="ln1529">{</a>
<a name="ln1530">  dev-&gt;proxy.snapshot.filename = filename;</a>
<a name="ln1531">  dev-&gt;proxy.snapshot.request = TRUE;</a>
<a name="ln1532">  dt_control_queue_redraw_center();</a>
<a name="ln1533">}</a>
<a name="ln1534"> </a>
<a name="ln1535">void dt_dev_invalidate_from_gui(dt_develop_t *dev)</a>
<a name="ln1536">{</a>
<a name="ln1537">  dt_dev_pop_history_items(darktable.develop, darktable.develop-&gt;history_end);</a>
<a name="ln1538">}</a>
<a name="ln1539"> </a>
<a name="ln1540">void dt_dev_average_delay_update(const dt_times_t *start, uint32_t *average_delay)</a>
<a name="ln1541">{</a>
<a name="ln1542">  dt_times_t end;</a>
<a name="ln1543">  dt_get_times(&amp;end);</a>
<a name="ln1544"> </a>
<a name="ln1545">  *average_delay += ((end.clock - start-&gt;clock) * 1000 / DT_DEV_AVERAGE_DELAY_COUNT</a>
<a name="ln1546">                     - *average_delay / DT_DEV_AVERAGE_DELAY_COUNT);</a>
<a name="ln1547">}</a>
<a name="ln1548"> </a>
<a name="ln1549"> </a>
<a name="ln1550">/** duplicate a existent module */</a>
<a name="ln1551">dt_iop_module_t *dt_dev_module_duplicate(dt_develop_t *dev, dt_iop_module_t *base, int priority)</a>
<a name="ln1552">{</a>
<a name="ln1553">  // we create the new module</a>
<a name="ln1554">  dt_iop_module_t *module = (dt_iop_module_t *)calloc(1, sizeof(dt_iop_module_t));</a>
<a name="ln1555">  if(dt_iop_load_module(module, base-&gt;so, base-&gt;dev)) return NULL;</a>
<a name="ln1556">  module-&gt;instance = base-&gt;instance;</a>
<a name="ln1557"> </a>
<a name="ln1558">  // we set the multi-instance priority</a>
<a name="ln1559">  GList *modules = g_list_first(base-&gt;dev-&gt;iop);</a>
<a name="ln1560">  int pmax = 0;</a>
<a name="ln1561">  while(modules)</a>
<a name="ln1562">  {</a>
<a name="ln1563">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1564">    if(mod-&gt;instance == base-&gt;instance)</a>
<a name="ln1565">    {</a>
<a name="ln1566">      // if the module is after the new one, we have to increment his priority</a>
<a name="ln1567">      if(mod-&gt;multi_priority &gt;= priority)</a>
<a name="ln1568">      {</a>
<a name="ln1569">        dt_iop_update_multi_priority(mod, mod-&gt;multi_priority + 1);</a>
<a name="ln1570">      }</a>
<a name="ln1571">      if(pmax &lt; mod-&gt;multi_priority) pmax = mod-&gt;multi_priority;</a>
<a name="ln1572">    }</a>
<a name="ln1573">    modules = g_list_next(modules);</a>
<a name="ln1574">  }</a>
<a name="ln1575">  pmax += 1;</a>
<a name="ln1576">  if(priority &lt; pmax) pmax = priority;</a>
<a name="ln1577">  dt_iop_update_multi_priority(module, pmax);</a>
<a name="ln1578"> </a>
<a name="ln1579">  // since we do not rename the module we need to check that an old module does not have the same name. Indeed</a>
<a name="ln1580">  // the multi_priority</a>
<a name="ln1581">  // are always rebased to start from 0, to it may be the case that the same multi_name be generated when</a>
<a name="ln1582">  // duplicating a module.</a>
<a name="ln1583">  int pname = module-&gt;multi_priority + 1;</a>
<a name="ln1584">  char mname[128];</a>
<a name="ln1585"> </a>
<a name="ln1586">  do</a>
<a name="ln1587">  {</a>
<a name="ln1588">    snprintf(mname, sizeof(mname), &quot;%d&quot;, pname);</a>
<a name="ln1589">    gboolean dup = FALSE;</a>
<a name="ln1590"> </a>
<a name="ln1591">    modules = g_list_first(base-&gt;dev-&gt;iop);</a>
<a name="ln1592">    while(modules)</a>
<a name="ln1593">    {</a>
<a name="ln1594">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1595">      if(mod-&gt;instance == base-&gt;instance)</a>
<a name="ln1596">      {</a>
<a name="ln1597">        if(strcmp(mname, mod-&gt;multi_name) == 0)</a>
<a name="ln1598">        {</a>
<a name="ln1599">          dup = TRUE;</a>
<a name="ln1600">          break;</a>
<a name="ln1601">        }</a>
<a name="ln1602">      }</a>
<a name="ln1603">      modules = g_list_next(modules);</a>
<a name="ln1604">    }</a>
<a name="ln1605"> </a>
<a name="ln1606">    if(dup)</a>
<a name="ln1607">      pname++;</a>
<a name="ln1608">    else</a>
<a name="ln1609">      break;</a>
<a name="ln1610">  } while(1);</a>
<a name="ln1611"> </a>
<a name="ln1612">  // the multi instance name</a>
<a name="ln1613">  g_strlcpy(module-&gt;multi_name, mname, sizeof(module-&gt;multi_name));</a>
<a name="ln1614">  // we insert this module into dev-&gt;iop</a>
<a name="ln1615">  base-&gt;dev-&gt;iop = g_list_insert_sorted(base-&gt;dev-&gt;iop, module, sort_plugins);</a>
<a name="ln1616"> </a>
<a name="ln1617">  // that's all. rest of insertion is gui work !</a>
<a name="ln1618">  return module;</a>
<a name="ln1619">}</a>
<a name="ln1620"> </a>
<a name="ln1621">void dt_dev_invalidate_history_module(GList *list, dt_iop_module_t *module)</a>
<a name="ln1622">{</a>
<a name="ln1623">  while (list)</a>
<a name="ln1624">  {</a>
<a name="ln1625">    dt_dev_history_item_t *hitem = (dt_dev_history_item_t *)list-&gt;data;</a>
<a name="ln1626">    if (hitem-&gt;module == module)</a>
<a name="ln1627">    {</a>
<a name="ln1628">      hitem-&gt;module = NULL;</a>
<a name="ln1629">    }</a>
<a name="ln1630">    list = list-&gt;next;</a>
<a name="ln1631">  }</a>
<a name="ln1632">}</a>
<a name="ln1633"> </a>
<a name="ln1634">void dt_dev_module_remove(dt_develop_t *dev, dt_iop_module_t *module)</a>
<a name="ln1635">{</a>
<a name="ln1636">  // if(darktable.gui-&gt;reset) return;</a>
<a name="ln1637">  dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1638">  int del = 0;</a>
<a name="ln1639">  if(dev-&gt;gui_attached)</a>
<a name="ln1640">  {</a>
<a name="ln1641">    GList *elem = g_list_first(dev-&gt;history);</a>
<a name="ln1642">    while(elem != NULL)</a>
<a name="ln1643">    {</a>
<a name="ln1644">      GList *next = g_list_next(elem);</a>
<a name="ln1645">      dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(elem-&gt;data);</a>
<a name="ln1646"> </a>
<a name="ln1647">      if(module == hist-&gt;module)</a>
<a name="ln1648">      {</a>
<a name="ln1649">        // printf(&quot;removing obsoleted history item: %s %s %p %p\n&quot;, hist-&gt;module-&gt;op, hist-&gt;module-&gt;multi_name,</a>
<a name="ln1650">        //        module, hist-&gt;module);</a>
<a name="ln1651">        dt_dev_free_history_item(hist);</a>
<a name="ln1652">        dev-&gt;history = g_list_delete_link(dev-&gt;history, elem);</a>
<a name="ln1653">        dev-&gt;history_end--;</a>
<a name="ln1654">        del = 1;</a>
<a name="ln1655">      }</a>
<a name="ln1656">      elem = next;</a>
<a name="ln1657">    }</a>
<a name="ln1658">  }</a>
<a name="ln1659"> </a>
<a name="ln1660">  dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1661"> </a>
<a name="ln1662">  // and we remove it from the list</a>
<a name="ln1663">  GList *modules = g_list_first(dev-&gt;iop);</a>
<a name="ln1664">  while(modules)</a>
<a name="ln1665">  {</a>
<a name="ln1666">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1667">    if(mod == module)</a>
<a name="ln1668">    {</a>
<a name="ln1669">      dev-&gt;iop = g_list_remove_link(dev-&gt;iop, modules);</a>
<a name="ln1670">      break;</a>
<a name="ln1671">    }</a>
<a name="ln1672">    modules = g_list_next(modules);</a>
<a name="ln1673">  }</a>
<a name="ln1674"> </a>
<a name="ln1675">  if(dev-&gt;gui_attached &amp;&amp; del)</a>
<a name="ln1676">  {</a>
<a name="ln1677">    /* signal that history has changed */</a>
<a name="ln1678">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE);</a>
<a name="ln1679">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_MODULE_REMOVE, module);</a>
<a name="ln1680">    /* redraw */</a>
<a name="ln1681">    dt_control_queue_redraw_center();</a>
<a name="ln1682">  }</a>
<a name="ln1683">}</a>
<a name="ln1684"> </a>
<a name="ln1685">void dt_dev_module_update_multishow(dt_develop_t *dev, struct dt_iop_module_t *module)</a>
<a name="ln1686">{</a>
<a name="ln1687">  // if the module is not multi instances compatible, then exit</a>
<a name="ln1688"> </a>
<a name="ln1689">  // We count the number of other instances</a>
<a name="ln1690">  int nb_before = 0;</a>
<a name="ln1691">  int nb_after = 0;</a>
<a name="ln1692">  int pos = 0;</a>
<a name="ln1693">  int pos_module = -1;</a>
<a name="ln1694">  GList *modules = g_list_first(dev-&gt;iop);</a>
<a name="ln1695">  while(modules)</a>
<a name="ln1696">  {</a>
<a name="ln1697">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1698">    if(mod == module)</a>
<a name="ln1699">      pos_module = pos;</a>
<a name="ln1700">    else if(mod-&gt;instance == module-&gt;instance)</a>
<a name="ln1701">    {</a>
<a name="ln1702">      if(pos_module &lt; 0)</a>
<a name="ln1703">        nb_before++;</a>
<a name="ln1704">      else</a>
<a name="ln1705">        nb_after++;</a>
<a name="ln1706">    }</a>
<a name="ln1707">    modules = g_list_next(modules);</a>
<a name="ln1708">    pos++;</a>
<a name="ln1709">  }</a>
<a name="ln1710"> </a>
<a name="ln1711">  module-&gt;multi_show_close = (nb_after + nb_before &gt; 0);</a>
<a name="ln1712">  module-&gt;multi_show_up = (nb_after &gt; 0);</a>
<a name="ln1713">  module-&gt;multi_show_down = (nb_before &gt; 0);</a>
<a name="ln1714">}</a>
<a name="ln1715">void dt_dev_modules_update_multishow(dt_develop_t *dev)</a>
<a name="ln1716">{</a>
<a name="ln1717">  GList *modules = g_list_first(dev-&gt;iop);</a>
<a name="ln1718">  while(modules)</a>
<a name="ln1719">  {</a>
<a name="ln1720">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1721">    dt_dev_module_update_multishow(dev, mod);</a>
<a name="ln1722">    modules = g_list_next(modules);</a>
<a name="ln1723">  }</a>
<a name="ln1724">}</a>
<a name="ln1725">gchar *dt_history_item_get_name(const struct dt_iop_module_t *module)</a>
<a name="ln1726">{</a>
<a name="ln1727">  gchar *label;</a>
<a name="ln1728">  /* create a history button and add to box */</a>
<a name="ln1729">  if(!module-&gt;multi_name[0] || strcmp(module-&gt;multi_name, &quot;0&quot;) == 0)</a>
<a name="ln1730">    label = g_strdup_printf(&quot;%s&quot;, module-&gt;name());</a>
<a name="ln1731">  else</a>
<a name="ln1732">    label = g_strdup_printf(&quot;%s %s&quot;, module-&gt;name(), module-&gt;multi_name);</a>
<a name="ln1733">  return label;</a>
<a name="ln1734">}</a>
<a name="ln1735"> </a>
<a name="ln1736">gchar *dt_history_item_get_name_html(const struct dt_iop_module_t *module)</a>
<a name="ln1737">{</a>
<a name="ln1738">  gchar *label;</a>
<a name="ln1739">  /* create a history button and add to box */</a>
<a name="ln1740">  if(!module-&gt;multi_name[0] || strcmp(module-&gt;multi_name, &quot;0&quot;) == 0)</a>
<a name="ln1741">    label = g_strdup_printf(&quot;&lt;span size=\&quot;larger\&quot;&gt;%s&lt;/span&gt;&quot;, module-&gt;name());</a>
<a name="ln1742">  else</a>
<a name="ln1743">    label = g_strdup_printf(&quot;&lt;span size=\&quot;larger\&quot;&gt;%s&lt;/span&gt; %s&quot;, module-&gt;name(), module-&gt;multi_name);</a>
<a name="ln1744">  return label;</a>
<a name="ln1745">}</a>
<a name="ln1746"> </a>
<a name="ln1747">int dt_dev_distort_transform(dt_develop_t *dev, float *points, size_t points_count)</a>
<a name="ln1748">{</a>
<a name="ln1749">  return dt_dev_distort_transform_plus(dev, dev-&gt;preview_pipe, 0, 99999, points, points_count);</a>
<a name="ln1750">}</a>
<a name="ln1751">int dt_dev_distort_backtransform(dt_develop_t *dev, float *points, size_t points_count)</a>
<a name="ln1752">{</a>
<a name="ln1753">  return dt_dev_distort_backtransform_plus(dev, dev-&gt;preview_pipe, 0, 99999, points, points_count);</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756">int dt_dev_distort_transform_plus(dt_develop_t *dev, dt_dev_pixelpipe_t *pipe, int pmin, int pmax,</a>
<a name="ln1757">                                  float *points, size_t points_count)</a>
<a name="ln1758">{</a>
<a name="ln1759">  dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1760">  GList *modules = g_list_first(pipe-&gt;iop);</a>
<a name="ln1761">  GList *pieces = g_list_first(pipe-&gt;nodes);</a>
<a name="ln1762">  while(modules)</a>
<a name="ln1763">  {</a>
<a name="ln1764">    if(!pieces)</a>
<a name="ln1765">    {</a>
<a name="ln1766">      dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1767">      return 0;</a>
<a name="ln1768">    }</a>
<a name="ln1769">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln1770">    dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)(pieces-&gt;data);</a>
<a name="ln1771">    if(piece-&gt;enabled &amp;&amp; module-&gt;priority &lt;= pmax &amp;&amp; module-&gt;priority &gt;= pmin &amp;&amp;</a>
<a name="ln1772">      !(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;operation_tags_filter() &amp; module-&gt;operation_tags()))</a>
<a name="ln1773">    {</a>
<a name="ln1774">      module-&gt;distort_transform(module, piece, points, points_count);</a>
<a name="ln1775">    }</a>
<a name="ln1776">    modules = g_list_next(modules);</a>
<a name="ln1777">    pieces = g_list_next(pieces);</a>
<a name="ln1778">  }</a>
<a name="ln1779">  dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1780">  return 1;</a>
<a name="ln1781">}</a>
<a name="ln1782"> </a>
<a name="ln1783">int dt_dev_distort_backtransform_plus(dt_develop_t *dev, dt_dev_pixelpipe_t *pipe, int pmin, int pmax,</a>
<a name="ln1784">                                      float *points, size_t points_count)</a>
<a name="ln1785">{</a>
<a name="ln1786">  dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1787">  GList *modules = g_list_last(pipe-&gt;iop);</a>
<a name="ln1788">  GList *pieces = g_list_last(pipe-&gt;nodes);</a>
<a name="ln1789">  while(modules)</a>
<a name="ln1790">  {</a>
<a name="ln1791">    if(!pieces)</a>
<a name="ln1792">    {</a>
<a name="ln1793">      dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1794">      return 0;</a>
<a name="ln1795">    }</a>
<a name="ln1796">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln1797">    dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)(pieces-&gt;data);</a>
<a name="ln1798">    if(piece-&gt;enabled &amp;&amp; module-&gt;priority &lt;= pmax &amp;&amp; module-&gt;priority &gt;= pmin &amp;&amp;</a>
<a name="ln1799">      !(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;operation_tags_filter() &amp; module-&gt;operation_tags()))</a>
<a name="ln1800">    {</a>
<a name="ln1801">      module-&gt;distort_backtransform(module, piece, points, points_count);</a>
<a name="ln1802">    }</a>
<a name="ln1803">    modules = g_list_previous(modules);</a>
<a name="ln1804">    pieces = g_list_previous(pieces);</a>
<a name="ln1805">  }</a>
<a name="ln1806">  dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1807">  return 1;</a>
<a name="ln1808">}</a>
<a name="ln1809"> </a>
<a name="ln1810">dt_dev_pixelpipe_iop_t *dt_dev_distort_get_iop_pipe(dt_develop_t *dev, struct dt_dev_pixelpipe_t *pipe,</a>
<a name="ln1811">                                                    struct dt_iop_module_t *module)</a>
<a name="ln1812">{</a>
<a name="ln1813">  GList *pieces = g_list_last(pipe-&gt;nodes);</a>
<a name="ln1814">  while(pieces)</a>
<a name="ln1815">  {</a>
<a name="ln1816">    dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)(pieces-&gt;data);</a>
<a name="ln1817">    if(piece-&gt;module == module)</a>
<a name="ln1818">    {</a>
<a name="ln1819">      return piece;</a>
<a name="ln1820">    }</a>
<a name="ln1821">    pieces = g_list_previous(pieces);</a>
<a name="ln1822">  }</a>
<a name="ln1823">  return NULL;</a>
<a name="ln1824">}</a>
<a name="ln1825"> </a>
<a name="ln1826">uint64_t dt_dev_hash(dt_develop_t *dev)</a>
<a name="ln1827">{</a>
<a name="ln1828">  return dt_dev_hash_plus(dev, dev-&gt;preview_pipe, 0, 99999);</a>
<a name="ln1829">}</a>
<a name="ln1830"> </a>
<a name="ln1831">uint64_t dt_dev_hash_plus(dt_develop_t *dev, struct dt_dev_pixelpipe_t *pipe, int pmin, int pmax)</a>
<a name="ln1832">{</a>
<a name="ln1833">  uint64_t hash = 5381;</a>
<a name="ln1834">  dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1835">  GList *modules = g_list_last(pipe-&gt;iop);</a>
<a name="ln1836">  GList *pieces = g_list_last(pipe-&gt;nodes);</a>
<a name="ln1837">  while(modules)</a>
<a name="ln1838">  {</a>
<a name="ln1839">    if(!pieces)</a>
<a name="ln1840">    {</a>
<a name="ln1841">      dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1842">      return 0;</a>
<a name="ln1843">    }</a>
<a name="ln1844">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln1845">    dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)(pieces-&gt;data);</a>
<a name="ln1846">    if(piece-&gt;enabled &amp;&amp; module-&gt;priority &lt;= pmax &amp;&amp; module-&gt;priority &gt;= pmin)</a>
<a name="ln1847">    {</a>
<a name="ln1848">      hash = ((hash &lt;&lt; 5) + hash) ^ piece-&gt;hash;</a>
<a name="ln1849">    }</a>
<a name="ln1850">    modules = g_list_previous(modules);</a>
<a name="ln1851">    pieces = g_list_previous(pieces);</a>
<a name="ln1852">  }</a>
<a name="ln1853">  dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1854">  return hash;</a>
<a name="ln1855">}</a>
<a name="ln1856"> </a>
<a name="ln1857">int dt_dev_wait_hash(dt_develop_t *dev, struct dt_dev_pixelpipe_t *pipe, int pmin, int pmax, dt_pthread_mutex_t *lock,</a>
<a name="ln1858">                     const volatile uint64_t *const hash)</a>
<a name="ln1859">{</a>
<a name="ln1860">  const int usec = 5000;</a>
<a name="ln1861">  int nloop;</a>
<a name="ln1862"> </a>
<a name="ln1863">#ifdef HAVE_OPENCL</a>
<a name="ln1864">  if(pipe-&gt;devid &gt;= 0)</a>
<a name="ln1865">    nloop = darktable.opencl-&gt;opencl_synchronization_timeout;</a>
<a name="ln1866">  else</a>
<a name="ln1867">    nloop = dt_conf_get_int(&quot;pixelpipe_synchronization_timeout&quot;);</a>
<a name="ln1868">#else</a>
<a name="ln1869">  nloop = dt_conf_get_int(&quot;pixelpipe_synchronization_timeout&quot;);</a>
<a name="ln1870">#endif</a>
<a name="ln1871"> </a>
<a name="ln1872">  if(nloop &lt;= 0) return TRUE;  // non-positive values omit pixelpipe synchronization</a>
<a name="ln1873"> </a>
<a name="ln1874">  for(int n = 0; n &lt; nloop; n++)</a>
<a name="ln1875">  {</a>
<a name="ln1876">    if(pipe-&gt;shutdown)</a>
<a name="ln1877">      return TRUE;  // stop waiting if pipe shuts down</a>
<a name="ln1878"> </a>
<a name="ln1879">    uint64_t probehash;</a>
<a name="ln1880"> </a>
<a name="ln1881">    if(lock)</a>
<a name="ln1882">    {</a>
<a name="ln1883">      dt_pthread_mutex_lock(lock);</a>
<a name="ln1884">      probehash = *hash;</a>
<a name="ln1885">      dt_pthread_mutex_unlock(lock);</a>
<a name="ln1886">    }</a>
<a name="ln1887">    else</a>
<a name="ln1888">      probehash = *hash;</a>
<a name="ln1889"> </a>
<a name="ln1890">    if(probehash == dt_dev_hash_plus(dev, pipe, pmin, pmax))</a>
<a name="ln1891">      return TRUE;</a>
<a name="ln1892"> </a>
<a name="ln1893">    dt_iop_nap(usec);</a>
<a name="ln1894">  }</a>
<a name="ln1895"> </a>
<a name="ln1896">  return FALSE;</a>
<a name="ln1897">}</a>
<a name="ln1898"> </a>
<a name="ln1899">int dt_dev_sync_pixelpipe_hash(dt_develop_t *dev, struct dt_dev_pixelpipe_t *pipe, int pmin, int pmax, dt_pthread_mutex_t *lock,</a>
<a name="ln1900">                               const volatile uint64_t *const hash)</a>
<a name="ln1901">{</a>
<a name="ln1902">  // first wait for matching hash values</a>
<a name="ln1903">  if(dt_dev_wait_hash(dev, pipe, pmin, pmax, lock, hash))</a>
<a name="ln1904">    return TRUE;</a>
<a name="ln1905"> </a>
<a name="ln1906">  // timed out. let's see if history stack has changed</a>
<a name="ln1907">  if(pipe-&gt;changed &amp; (DT_DEV_PIPE_TOP_CHANGED | DT_DEV_PIPE_REMOVE | DT_DEV_PIPE_SYNCH))</a>
<a name="ln1908">  {</a>
<a name="ln1909">    // history stack has changed. let's trigger reprocessing</a>
<a name="ln1910">    dt_control_queue_redraw_center();</a>
<a name="ln1911">    // pretend that everything is fine</a>
<a name="ln1912">    return TRUE;</a>
<a name="ln1913">  }</a>
<a name="ln1914"> </a>
<a name="ln1915">  // no way to get pixelpipes in sync</a>
<a name="ln1916">  return FALSE;</a>
<a name="ln1917">}</a>
<a name="ln1918"> </a>
<a name="ln1919"> </a>
<a name="ln1920">uint64_t dt_dev_hash_distort(dt_develop_t *dev)</a>
<a name="ln1921">{</a>
<a name="ln1922">  return dt_dev_hash_distort_plus(dev, dev-&gt;preview_pipe, 0, 99999);</a>
<a name="ln1923">}</a>
<a name="ln1924"> </a>
<a name="ln1925">uint64_t dt_dev_hash_distort_plus(dt_develop_t *dev, struct dt_dev_pixelpipe_t *pipe, int pmin, int pmax)</a>
<a name="ln1926">{</a>
<a name="ln1927">  uint64_t hash = 5381;</a>
<a name="ln1928">  dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1929">  GList *modules = g_list_last(pipe-&gt;iop);</a>
<a name="ln1930">  GList *pieces = g_list_last(pipe-&gt;nodes);</a>
<a name="ln1931">  while(modules)</a>
<a name="ln1932">  {</a>
<a name="ln1933">    if(!pieces)</a>
<a name="ln1934">    {</a>
<a name="ln1935">      dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1936">      return 0;</a>
<a name="ln1937">    }</a>
<a name="ln1938">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln1939">    dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)(pieces-&gt;data);</a>
<a name="ln1940">    if(piece-&gt;enabled &amp;&amp; module-&gt;operation_tags() &amp; IOP_TAG_DISTORT</a>
<a name="ln1941">      &amp;&amp; module-&gt;priority &lt;= pmax &amp;&amp; module-&gt;priority &gt;= pmin)</a>
<a name="ln1942">    {</a>
<a name="ln1943">      hash = ((hash &lt;&lt; 5) + hash) ^ piece-&gt;hash;</a>
<a name="ln1944">    }</a>
<a name="ln1945">    modules = g_list_previous(modules);</a>
<a name="ln1946">    pieces = g_list_previous(pieces);</a>
<a name="ln1947">  }</a>
<a name="ln1948">  dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1949">  return hash;</a>
<a name="ln1950">}</a>
<a name="ln1951"> </a>
<a name="ln1952">int dt_dev_wait_hash_distort(dt_develop_t *dev, struct dt_dev_pixelpipe_t *pipe, int pmin, int pmax, dt_pthread_mutex_t *lock,</a>
<a name="ln1953">                     const volatile uint64_t *const hash)</a>
<a name="ln1954">{</a>
<a name="ln1955">  const int usec = 5000;</a>
<a name="ln1956">  int nloop;</a>
<a name="ln1957"> </a>
<a name="ln1958">#ifdef HAVE_OPENCL</a>
<a name="ln1959">  if(pipe-&gt;devid &gt;= 0)</a>
<a name="ln1960">    nloop = darktable.opencl-&gt;opencl_synchronization_timeout;</a>
<a name="ln1961">  else</a>
<a name="ln1962">    nloop = dt_conf_get_int(&quot;pixelpipe_synchronization_timeout&quot;);</a>
<a name="ln1963">#else</a>
<a name="ln1964">  nloop = dt_conf_get_int(&quot;pixelpipe_synchronization_timeout&quot;);</a>
<a name="ln1965">#endif</a>
<a name="ln1966"> </a>
<a name="ln1967">  if(nloop &lt;= 0) return TRUE;  // non-positive values omit pixelpipe synchronization</a>
<a name="ln1968"> </a>
<a name="ln1969">  for(int n = 0; n &lt; nloop; n++)</a>
<a name="ln1970">  {</a>
<a name="ln1971">    if(pipe-&gt;shutdown)</a>
<a name="ln1972">      return TRUE;  // stop waiting if pipe shuts down</a>
<a name="ln1973"> </a>
<a name="ln1974">    uint64_t probehash;</a>
<a name="ln1975"> </a>
<a name="ln1976">    if(lock)</a>
<a name="ln1977">    {</a>
<a name="ln1978">      dt_pthread_mutex_lock(lock);</a>
<a name="ln1979">      probehash = *hash;</a>
<a name="ln1980">      dt_pthread_mutex_unlock(lock);</a>
<a name="ln1981">    }</a>
<a name="ln1982">    else</a>
<a name="ln1983">      probehash = *hash;</a>
<a name="ln1984"> </a>
<a name="ln1985">    if(probehash == dt_dev_hash_distort_plus(dev, pipe, pmin, pmax))</a>
<a name="ln1986">      return TRUE;</a>
<a name="ln1987"> </a>
<a name="ln1988">    dt_iop_nap(usec);</a>
<a name="ln1989">  }</a>
<a name="ln1990"> </a>
<a name="ln1991">  return FALSE;</a>
<a name="ln1992">}</a>
<a name="ln1993"> </a>
<a name="ln1994">int dt_dev_sync_pixelpipe_hash_distort(dt_develop_t *dev, struct dt_dev_pixelpipe_t *pipe, int pmin, int pmax, dt_pthread_mutex_t *lock,</a>
<a name="ln1995">                                       const volatile uint64_t *const hash)</a>
<a name="ln1996">{</a>
<a name="ln1997">  // first wait for matching hash values</a>
<a name="ln1998">  if(dt_dev_wait_hash_distort(dev, pipe, pmin, pmax, lock, hash))</a>
<a name="ln1999">    return TRUE;</a>
<a name="ln2000"> </a>
<a name="ln2001">  // timed out. let's see if history stack has changed</a>
<a name="ln2002">  if(pipe-&gt;changed &amp; (DT_DEV_PIPE_TOP_CHANGED | DT_DEV_PIPE_REMOVE | DT_DEV_PIPE_SYNCH))</a>
<a name="ln2003">  {</a>
<a name="ln2004">    // history stack has changed. let's trigger reprocessing</a>
<a name="ln2005">    dt_control_queue_redraw_center();</a>
<a name="ln2006">    // pretend that everything is fine</a>
<a name="ln2007">    return TRUE;</a>
<a name="ln2008">  }</a>
<a name="ln2009"> </a>
<a name="ln2010">  // no way to get pixelpipes in sync</a>
<a name="ln2011">  return FALSE;</a>
<a name="ln2012">}</a>
<a name="ln2013"> </a>
<a name="ln2014"> </a>
<a name="ln2015">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2016">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2017">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="594"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '||' operator is surrounded by opposite expressions.</p></div>
<div class="balloon" rel="616"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'hist'. Check lines: 616, 602.</p></div>
<div class="balloon" rel="625"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 625, 620.</p></div>
<div class="balloon" rel="626"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 626, 624.</p></div>
<div class="balloon" rel="1076"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'hist'. Check lines: 1076, 1075.</p></div>
<div class="balloon" rel="1120"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'new_module'. Check lines: 1120, 1115.</p></div>
<div class="balloon" rel="1160"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1160, 1148.</p></div>
<div class="balloon" rel="1208"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1208, 1147.</p></div>
<div class="balloon" rel="1556"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'module'. Check lines: 1556, 1554.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
