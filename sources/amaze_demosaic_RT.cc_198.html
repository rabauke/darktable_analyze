
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#define __STDC_FORMAT_MACROS</a>
<a name="ln20"> </a>
<a name="ln21">#if defined(__SSE__)</a>
<a name="ln22">#include &lt;xmmintrin.h&gt;</a>
<a name="ln23">#endif</a>
<a name="ln24"> </a>
<a name="ln25">extern &quot;C&quot; {</a>
<a name="ln26">#include &quot;develop/imageop.h&quot;</a>
<a name="ln27">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">// otherwise the name will be mangled and the linker won't be able to see the function ...</a>
<a name="ln30">void amaze_demosaic_RT(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln31">                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln32">                       const int filters);</a>
<a name="ln33">}</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;algorithm&gt;</a>
<a name="ln36">#include &lt;cmath&gt;</a>
<a name="ln37">#include &lt;cstdint&gt;</a>
<a name="ln38">#include &lt;cstdlib&gt;</a>
<a name="ln39">#include &lt;cstring&gt;</a>
<a name="ln40"> </a>
<a name="ln41">static __inline float clampnan(const float x, const float m, const float M)</a>
<a name="ln42">{</a>
<a name="ln43">  float r;</a>
<a name="ln44"> </a>
<a name="ln45">  // clamp to [m, M] if x is infinite; return average of m and M if x is NaN; else just return x</a>
<a name="ln46"> </a>
<a name="ln47">  if(std::isinf(x))</a>
<a name="ln48">    r = (std::isless(x, m) ? m : (std::isgreater(x, M) ? M : x));</a>
<a name="ln49">  else if(std::isnan(x))</a>
<a name="ln50">    r = (m + M) / 2.0f;</a>
<a name="ln51">  else // normal number</a>
<a name="ln52">    r = x;</a>
<a name="ln53"> </a>
<a name="ln54">  return r;</a>
<a name="ln55">}</a>
<a name="ln56"> </a>
<a name="ln57">#ifndef __SSE2__</a>
<a name="ln58">static __inline float xmul2f(float d)</a>
<a name="ln59">{</a>
<a name="ln60">  union {</a>
<a name="ln61">      float f;</a>
<a name="ln62">      uint32_t u;</a>
<a name="ln63">  } x;</a>
<a name="ln64">  x.f = d;</a>
<a name="ln65">  if(x.u &amp; 0x7FFFFFFF) // if f==0 do nothing</a>
<a name="ln66">  {</a>
<a name="ln67">    x.u += 1 &lt;&lt; 23; // add 1 to the exponent</a>
<a name="ln68">  }</a>
<a name="ln69">  return x.f;</a>
<a name="ln70">}</a>
<a name="ln71">#endif</a>
<a name="ln72"> </a>
<a name="ln73">static __inline float xdiv2f(float d)</a>
<a name="ln74">{</a>
<a name="ln75">  union {</a>
<a name="ln76">      float f;</a>
<a name="ln77">      uint32_t u;</a>
<a name="ln78">  } x;</a>
<a name="ln79">  x.f = d;</a>
<a name="ln80">  if(x.u &amp; 0x7FFFFFFF) // if f==0 do nothing</a>
<a name="ln81">  {</a>
<a name="ln82">    x.u -= 1 &lt;&lt; 23; // sub 1 from the exponent</a>
<a name="ln83">  }</a>
<a name="ln84">  return x.f;</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87">static __inline float xdivf(float d, int n)</a>
<a name="ln88">{</a>
<a name="ln89">  union {</a>
<a name="ln90">      float f;</a>
<a name="ln91">      uint32_t u;</a>
<a name="ln92">  } x;</a>
<a name="ln93">  x.f = d;</a>
<a name="ln94">  if(x.u &amp; 0x7FFFFFFF) // if f==0 do nothing</a>
<a name="ln95">  {</a>
<a name="ln96">    x.u -= n &lt;&lt; 23; // add n to the exponent</a>
<a name="ln97">  }</a>
<a name="ln98">  return x.f;</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101"> </a>
<a name="ln102">/*==================================================================================</a>
<a name="ln103"> * begin raw therapee code, hg checkout of march 03, 2016 branch master.</a>
<a name="ln104"> *==================================================================================*/</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">#ifdef __SSE2__</a>
<a name="ln108"> </a>
<a name="ln109">#ifdef __GNUC__</a>
<a name="ln110">#define INLINE __inline</a>
<a name="ln111">#else</a>
<a name="ln112">#define INLINE inline</a>
<a name="ln113">#endif</a>
<a name="ln114"> </a>
<a name="ln115">#ifdef __GNUC__</a>
<a name="ln116">#if((__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 9) || __GNUC__ &gt; 4) &amp;&amp; (!defined(WIN32) || defined(__x86_64__))</a>
<a name="ln117">#define LVF(x) _mm_load_ps(&amp;x)</a>
<a name="ln118">#define LVFU(x) _mm_loadu_ps(&amp;x)</a>
<a name="ln119">#define STVF(x, y) _mm_store_ps(&amp;x, y)</a>
<a name="ln120">#define STVFU(x, y) _mm_storeu_ps(&amp;x, y)</a>
<a name="ln121">#else // there is a bug in gcc 4.7.x when using openmp and aligned memory and -O3, also need to map the</a>
<a name="ln122">      // aligned functions to unaligned functions for WIN32 builds</a>
<a name="ln123">#define LVF(x) _mm_loadu_ps(&amp;x)</a>
<a name="ln124">#define LVFU(x) _mm_loadu_ps(&amp;x)</a>
<a name="ln125">#define STVF(x, y) _mm_storeu_ps(&amp;x, y)</a>
<a name="ln126">#define STVFU(x, y) _mm_storeu_ps(&amp;x, y)</a>
<a name="ln127">#endif</a>
<a name="ln128">#else</a>
<a name="ln129">#define LVF(x) _mm_load_ps(&amp;x)</a>
<a name="ln130">#define LVFU(x) _mm_loadu_ps(&amp;x)</a>
<a name="ln131">#define STVF(x, y) _mm_store_ps(&amp;x, y)</a>
<a name="ln132">#define STVFU(x, y) _mm_storeu_ps(&amp;x, y)</a>
<a name="ln133">#endif</a>
<a name="ln134"> </a>
<a name="ln135">#define STC2VFU(a, v)                                                                                        \</a>
<a name="ln136">  {                                                                                                          \</a>
<a name="ln137">    __m128 TST1V = _mm_loadu_ps(&amp;a);                                                                         \</a>
<a name="ln138">    __m128 TST2V = _mm_unpacklo_ps(v, v);                                                                    \</a>
<a name="ln139">    vmask cmask = _mm_set_epi32(0xffffffff, 0, 0xffffffff, 0);                                               \</a>
<a name="ln140">    _mm_storeu_ps(&amp;a, vself(cmask, TST1V, TST2V));                                                           \</a>
<a name="ln141">    TST1V = _mm_loadu_ps((&amp;a) + 4);                                                                          \</a>
<a name="ln142">    TST2V = _mm_unpackhi_ps(v, v);                                                                           \</a>
<a name="ln143">    _mm_storeu_ps((&amp;a) + 4, vself(cmask, TST1V, TST2V));                                                     \</a>
<a name="ln144">  }</a>
<a name="ln145"> </a>
<a name="ln146">#define ZEROV _mm_setzero_ps()</a>
<a name="ln147">#define F2V(a) _mm_set1_ps((a))</a>
<a name="ln148"> </a>
<a name="ln149">typedef __m128i vmask;</a>
<a name="ln150">typedef __m128 vfloat;</a>
<a name="ln151">typedef __m128i vint;</a>
<a name="ln152"> </a>
<a name="ln153">static INLINE vfloat LC2VFU(float &amp;a)</a>
<a name="ln154">{</a>
<a name="ln155">  // Load 8 floats from a and combine a[0],a[2],a[4] and a[6] into a vector of 4 floats</a>
<a name="ln156">  vfloat a1 = _mm_loadu_ps(&amp;a);</a>
<a name="ln157">  vfloat a2 = _mm_loadu_ps((&amp;a) + 4);</a>
<a name="ln158">  return _mm_shuffle_ps(a1, a2, _MM_SHUFFLE(2, 0, 2, 0));</a>
<a name="ln159">}</a>
<a name="ln160">static INLINE vfloat vmaxf(vfloat x, vfloat y)</a>
<a name="ln161">{</a>
<a name="ln162">  return _mm_max_ps(x, y);</a>
<a name="ln163">}</a>
<a name="ln164">static INLINE vfloat vminf(vfloat x, vfloat y)</a>
<a name="ln165">{</a>
<a name="ln166">  return _mm_min_ps(x, y);</a>
<a name="ln167">}</a>
<a name="ln168">static INLINE vfloat vcast_vf_f(float f)</a>
<a name="ln169">{</a>
<a name="ln170">  return _mm_set_ps(f, f, f, f);</a>
<a name="ln171">}</a>
<a name="ln172">static INLINE vmask vorm(vmask x, vmask y)</a>
<a name="ln173">{</a>
<a name="ln174">  return _mm_or_si128(x, y);</a>
<a name="ln175">}</a>
<a name="ln176">static INLINE vmask vandm(vmask x, vmask y)</a>
<a name="ln177">{</a>
<a name="ln178">  return _mm_and_si128(x, y);</a>
<a name="ln179">}</a>
<a name="ln180">static INLINE vmask vandnotm(vmask x, vmask y)</a>
<a name="ln181">{</a>
<a name="ln182">  return _mm_andnot_si128(x, y);</a>
<a name="ln183">}</a>
<a name="ln184">static INLINE vfloat vabsf(vfloat f)</a>
<a name="ln185">{</a>
<a name="ln186">  return (vfloat)vandnotm((vmask)vcast_vf_f(-0.0f), (vmask)f);</a>
<a name="ln187">}</a>
<a name="ln188">static INLINE vfloat vself(vmask mask, vfloat x, vfloat y)</a>
<a name="ln189">{</a>
<a name="ln190">  return (vfloat)vorm(vandm(mask, (vmask)x), vandnotm(mask, (vmask)y));</a>
<a name="ln191">}</a>
<a name="ln192">static INLINE vmask vmaskf_lt(vfloat x, vfloat y)</a>
<a name="ln193">{</a>
<a name="ln194">  return (__m128i)_mm_cmplt_ps(x, y);</a>
<a name="ln195">}</a>
<a name="ln196">static INLINE vmask vmaskf_gt(vfloat x, vfloat y)</a>
<a name="ln197">{</a>
<a name="ln198">  return (__m128i)_mm_cmpgt_ps(x, y);</a>
<a name="ln199">}</a>
<a name="ln200">static INLINE vfloat ULIMV(vfloat a, vfloat b, vfloat c)</a>
<a name="ln201">{</a>
<a name="ln202">  // made to clamp a in range [b,c] but in fact it's also the median of a,b,c, which means that the result is</a>
<a name="ln203">  // independent on order of arguments</a>
<a name="ln204">  // ULIMV(a,b,c) = ULIMV(a,c,b) = ULIMV(b,a,c) = ULIMV(b,c,a) = ULIMV(c,a,b) = ULIMV(c,b,a)</a>
<a name="ln205">  return vmaxf(vminf(a, b), vminf(vmaxf(a, b), c));</a>
<a name="ln206">}</a>
<a name="ln207">static INLINE vfloat SQRV(vfloat a)</a>
<a name="ln208">{</a>
<a name="ln209">  return a * a;</a>
<a name="ln210">}</a>
<a name="ln211">static INLINE vfloat vintpf(vfloat a, vfloat b, vfloat c)</a>
<a name="ln212">{</a>
<a name="ln213">  // calculate a * b + (1 - a) * c (interpolate two values)</a>
<a name="ln214">  // following is valid:</a>
<a name="ln215">  // vintpf(a, b+x, c+x) = vintpf(a, b, c) + x</a>
<a name="ln216">  // vintpf(a, b*x, c*x) = vintpf(a, b, c) * x</a>
<a name="ln217">  return a * (b - c) + c;</a>
<a name="ln218">}</a>
<a name="ln219">static INLINE vfloat vaddc2vfu(float &amp;a)</a>
<a name="ln220">{</a>
<a name="ln221">  // loads a[0]..a[7] and returns { a[0]+a[1], a[2]+a[3], a[4]+a[5], a[6]+a[7] }</a>
<a name="ln222">  vfloat a1 = _mm_loadu_ps(&amp;a);</a>
<a name="ln223">  vfloat a2 = _mm_loadu_ps((&amp;a) + 4);</a>
<a name="ln224">  return _mm_shuffle_ps(a1, a2, _MM_SHUFFLE(2, 0, 2, 0)) + _mm_shuffle_ps(a1, a2, _MM_SHUFFLE(3, 1, 3, 1));</a>
<a name="ln225">}</a>
<a name="ln226">static INLINE vfloat vadivapb(vfloat a, vfloat b)</a>
<a name="ln227">{</a>
<a name="ln228">  return a / (a + b);</a>
<a name="ln229">}</a>
<a name="ln230">static INLINE vint vselc(vmask mask, vint x, vint y)</a>
<a name="ln231">{</a>
<a name="ln232">  return vorm(vandm(mask, (vmask)x), vandnotm(mask, (vmask)y));</a>
<a name="ln233">}</a>
<a name="ln234">static INLINE vint vselinotzero(vmask mask, vint x)</a>
<a name="ln235">{</a>
<a name="ln236">  // returns value of x if corresponding mask bits are 0, else returns 0</a>
<a name="ln237">  // faster than vselc(mask, ZEROV, x)</a>
<a name="ln238">  return _mm_andnot_si128(mask, x);</a>
<a name="ln239">}</a>
<a name="ln240">static INLINE vfloat vmul2f(vfloat a)</a>
<a name="ln241">{</a>
<a name="ln242">  // fastest way to multiply by 2</a>
<a name="ln243">  return a + a;</a>
<a name="ln244">}</a>
<a name="ln245">static INLINE vmask vmaskf_ge(vfloat x, vfloat y)</a>
<a name="ln246">{</a>
<a name="ln247">  return (__m128i)_mm_cmpge_ps(x, y);</a>
<a name="ln248">}</a>
<a name="ln249">static INLINE vmask vnotm(vmask x)</a>
<a name="ln250">{</a>
<a name="ln251">  return _mm_xor_si128(x, _mm_cmpeq_epi32(_mm_setzero_si128(), _mm_setzero_si128()));</a>
<a name="ln252">}</a>
<a name="ln253">static INLINE vfloat vdup(vfloat a)</a>
<a name="ln254">{</a>
<a name="ln255">  // returns { a[0],a[0],a[1],a[1] }</a>
<a name="ln256">  return _mm_unpacklo_ps(a, a);</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">#endif // __SSE2__</a>
<a name="ln260"> </a>
<a name="ln261">template &lt;typename _Tp&gt; static inline const _Tp SQR(_Tp x)</a>
<a name="ln262">{</a>
<a name="ln263">  //      return std::pow(x,2); Slower than:</a>
<a name="ln264">  return (x * x);</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">template &lt;typename _Tp&gt; static inline const _Tp intp(const _Tp a, const _Tp b, const _Tp c)</a>
<a name="ln268">{</a>
<a name="ln269">  // calculate a * b + (1 - a) * c</a>
<a name="ln270">  // following is valid:</a>
<a name="ln271">  // intp(a, b+x, c+x) = intp(a, b, c) + x</a>
<a name="ln272">  // intp(a, b*x, c*x) = intp(a, b, c) * x</a>
<a name="ln273">  return a * (b - c) + c;</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">template &lt;typename _Tp&gt; static inline const _Tp LIM(const _Tp a, const _Tp b, const _Tp c)</a>
<a name="ln277">{</a>
<a name="ln278">  return std::max(b, std::min(a, c));</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">template &lt;typename _Tp&gt; static inline const _Tp ULIM(const _Tp a, const _Tp b, const _Tp c)</a>
<a name="ln282">{</a>
<a name="ln283">  return ((b &lt; c) ? LIM(a, b, c) : LIM(a, c, b));</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287"> </a>
<a name="ln288">////////////////////////////////////////////////////////////////</a>
<a name="ln289">//</a>
<a name="ln290">//          AMaZE demosaic algorithm</a>
<a name="ln291">// (Aliasing Minimization and Zipper Elimination)</a>
<a name="ln292">//</a>
<a name="ln293">//  copyright (c) 2008-2010  Emil Martinec &lt;ejmartin@uchicago.edu&gt;</a>
<a name="ln294">//  optimized for speed by Ingo Weyrich</a>
<a name="ln295">//</a>
<a name="ln296">// incorporating ideas of Luis Sanz Rodrigues and Paul Lee</a>
<a name="ln297">//</a>
<a name="ln298">// code dated: May 27, 2010</a>
<a name="ln299">// latest modification: Ingo Weyrich, January 25, 2016</a>
<a name="ln300">//</a>
<a name="ln301">//  amaze_interpolate_RT.cc is free software: you can redistribute it and/or modify</a>
<a name="ln302">//  it under the terms of the GNU General Public License as published by</a>
<a name="ln303">//  the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln304">//  (at your option) any later version.</a>
<a name="ln305">//</a>
<a name="ln306">//  This program is distributed in the hope that it will be useful,</a>
<a name="ln307">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln308">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln309">//  GNU General Public License for more details.</a>
<a name="ln310">//</a>
<a name="ln311">//  You should have received a copy of the GNU General Public License</a>
<a name="ln312">//  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln313">//</a>
<a name="ln314">////////////////////////////////////////////////////////////////</a>
<a name="ln315"> </a>
<a name="ln316">// namespace rtengine</a>
<a name="ln317">// {</a>
<a name="ln318"> </a>
<a name="ln319">// SSEFUNCTION void RawImageSource::amaze_demosaic_RT(int winx, int winy, int winw, int winh)</a>
<a name="ln320">void amaze_demosaic_RT(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln321">                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln322">                       const int filters)</a>
<a name="ln323">{</a>
<a name="ln324">  //   BENCHFUN</a>
<a name="ln325"> </a>
<a name="ln326">  //   volatile double progress = 0.0;</a>
<a name="ln327"> </a>
<a name="ln328">  //   if(plistener)</a>
<a name="ln329">  //   {</a>
<a name="ln330">  //     plistener-&gt;setProgressStr(Glib::ustring::compose(</a>
<a name="ln331">  //         M(&quot;TP_RAW_DMETHOD_PROGRESSBAR&quot;),</a>
<a name="ln332">  //         RAWParams::BayerSensor::methodstring[RAWParams::BayerSensor::amaze]));</a>
<a name="ln333">  //     plistener-&gt;setProgress(0.0);</a>
<a name="ln334">  //   }</a>
<a name="ln335"> </a>
<a name="ln336">  int winx = roi_out-&gt;x;</a>
<a name="ln337">  int winy = roi_out-&gt;y;</a>
<a name="ln338">  int winw = roi_in-&gt;width;</a>
<a name="ln339">  int winh = roi_in-&gt;height;</a>
<a name="ln340"> </a>
<a name="ln341">  const int width = winw, height = winh;</a>
<a name="ln342">  //   const float clip_pt = 1.0 / initialGain;</a>
<a name="ln343">  //   const float clip_pt8 = 0.8 / initialGain;</a>
<a name="ln344">  const float clip_pt = fminf(piece-&gt;pipe-&gt;dsc.processed_maximum[0],</a>
<a name="ln345">                              fminf(piece-&gt;pipe-&gt;dsc.processed_maximum[1], piece-&gt;pipe-&gt;dsc.processed_maximum[2]));</a>
<a name="ln346">  const float clip_pt8 = 0.8f * clip_pt;</a>
<a name="ln347"> </a>
<a name="ln348">// this allows to pass AMAZETS to the code. On some machines larger AMAZETS is faster</a>
<a name="ln349">// If AMAZETS is undefined it will be set to 160, which is the fastest on modern x86/64 machines</a>
<a name="ln350">#ifndef AMAZETS</a>
<a name="ln351">#define AMAZETS 160</a>
<a name="ln352">#endif</a>
<a name="ln353">  // Tile size; the image is processed in square tiles to lower memory requirements and facilitate</a>
<a name="ln354">  // multi-threading</a>
<a name="ln355">  // We assure that Tile size is a multiple of 32 in the range [96;992]</a>
<a name="ln356">  constexpr int ts = (AMAZETS &amp; 992) &lt; 96 ? 96 : (AMAZETS &amp; 992);</a>
<a name="ln357">  constexpr int tsh = ts / 2; // half of Tile size</a>
<a name="ln358"> </a>
<a name="ln359">  // offset of R pixel within a Bayer quartet</a>
<a name="ln360">  int ex, ey;</a>
<a name="ln361"> </a>
<a name="ln362">  // determine GRBG coset; (ey,ex) is the offset of the R subarray</a>
<a name="ln363">  if(FC(0, 0, filters) == 1)</a>
<a name="ln364">  { // first pixel is G</a>
<a name="ln365">    if(FC(0, 1, filters) == 0)</a>
<a name="ln366">    {</a>
<a name="ln367">      ey = 0;</a>
<a name="ln368">      ex = 1;</a>
<a name="ln369">    }</a>
<a name="ln370">    else</a>
<a name="ln371">    {</a>
<a name="ln372">      ey = 1;</a>
<a name="ln373">      ex = 0;</a>
<a name="ln374">    }</a>
<a name="ln375">  }</a>
<a name="ln376">  else</a>
<a name="ln377">  { // first pixel is R or B</a>
<a name="ln378">    if(FC(0, 0, filters) == 0)</a>
<a name="ln379">    {</a>
<a name="ln380">      ey = 0;</a>
<a name="ln381">      ex = 0;</a>
<a name="ln382">    }</a>
<a name="ln383">    else</a>
<a name="ln384">    {</a>
<a name="ln385">      ey = 1;</a>
<a name="ln386">      ex = 1;</a>
<a name="ln387">    }</a>
<a name="ln388">  }</a>
<a name="ln389"> </a>
<a name="ln390">  // shifts of pointer value to access pixels in vertical and diagonal directions</a>
<a name="ln391">  constexpr int v1 = ts, v2 = 2 * ts, v3 = 3 * ts, p1 = -ts + 1, p2 = -2 * ts + 2, p3 = -3 * ts + 3,</a>
<a name="ln392">                m1 = ts + 1, m2 = 2 * ts + 2, m3 = 3 * ts + 3;</a>
<a name="ln393"> </a>
<a name="ln394">  // tolerance to avoid dividing by zero</a>
<a name="ln395">  constexpr float eps = 1e-5, epssq = 1e-10; // tolerance to avoid dividing by zero</a>
<a name="ln396"> </a>
<a name="ln397">  // adaptive ratios threshold</a>
<a name="ln398">  constexpr float arthresh = 0.75;</a>
<a name="ln399"> </a>
<a name="ln400">  // gaussian on 5x5 quincunx, sigma=1.2</a>
<a name="ln401">  constexpr float gaussodd[4]</a>
<a name="ln402">      = { 0.14659727707323927f, 0.103592713382435f, 0.0732036125103057f, 0.0365543548389495f };</a>
<a name="ln403">  // nyquist texture test threshold</a>
<a name="ln404">  constexpr float nyqthresh = 0.5;</a>
<a name="ln405">  // gaussian on 5x5, sigma=1.2, multiplied with nyqthresh to save some time later in loop</a>
<a name="ln406">  // Is this really sigma=1.2????, seems more like sigma = 1.672</a>
<a name="ln407">  constexpr float gaussgrad[6] = { nyqthresh * 0.07384411893421103f, nyqthresh * 0.06207511968171489f,</a>
<a name="ln408">                                   nyqthresh * 0.0521818194747806f,  nyqthresh * 0.03687419286733595f,</a>
<a name="ln409">                                   nyqthresh * 0.03099732204057846f, nyqthresh * 0.018413194161458882f };</a>
<a name="ln410">  // gaussian on 5x5 alt quincunx, sigma=1.5</a>
<a name="ln411">  constexpr float gausseven[2] = { 0.13719494435797422f, 0.05640252782101291f };</a>
<a name="ln412">  // gaussian on quincunx grid</a>
<a name="ln413">  constexpr float gquinc[4] = { 0.169917f, 0.108947f, 0.069855f, 0.0287182f };</a>
<a name="ln414"> </a>
<a name="ln415">  typedef struct</a>
<a name="ln416">  {</a>
<a name="ln417">    float h;</a>
<a name="ln418">    float v;</a>
<a name="ln419">  } s_hv;</a>
<a name="ln420"> </a>
<a name="ln421">#ifdef _OPENMP</a>
<a name="ln422">#pragma omp parallel</a>
<a name="ln423">#endif</a>
<a name="ln424">  {</a>
<a name="ln425">    //     int progresscounter = 0;</a>
<a name="ln426"> </a>
<a name="ln427">    constexpr int cldf = 2; // factor to multiply cache line distance. 1 = 64 bytes, 2 = 128 bytes ...</a>
<a name="ln428">    // assign working space</a>
<a name="ln429">    char *buffer</a>
<a name="ln430">        = (char *)calloc(14 * sizeof(float) * ts * ts + sizeof(char) * ts * tsh + 18 * cldf * 64 + 63, 1);</a>
<a name="ln431">    // aligned to 64 byte boundary</a>
<a name="ln432">    char *data = (char *)((uintptr_t(buffer) + uintptr_t(63)) / 64 * 64);</a>
<a name="ln433"> </a>
<a name="ln434">    // green values</a>
<a name="ln435">    float *rgbgreen = (float(*))data;</a>
<a name="ln436">    // sum of square of horizontal gradient and square of vertical gradient</a>
<a name="ln437">    float *delhvsqsum = (float(*))((char *)rgbgreen + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln438">    // gradient based directional weights for interpolation</a>
<a name="ln439">    float *dirwts0 = (float(*))((char *)delhvsqsum + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln440">    float *dirwts1 = (float(*))((char *)dirwts0 + sizeof(float) * ts * ts + cldf * 64);    // 1</a>
<a name="ln441">    // vertically interpolated colour differences G-R, G-B</a>
<a name="ln442">    float *vcd = (float(*))((char *)dirwts1 + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln443">    // horizontally interpolated colour differences</a>
<a name="ln444">    float *hcd = (float(*))((char *)vcd + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln445">    // alternative vertical interpolation</a>
<a name="ln446">    float *vcdalt = (float(*))((char *)hcd + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln447">    // alternative horizontal interpolation</a>
<a name="ln448">    float *hcdalt = (float(*))((char *)vcdalt + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln449">    // square of average colour difference</a>
<a name="ln450">    float *cddiffsq = (float(*))((char *)hcdalt + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln451">    // weight to give horizontal vs vertical interpolation</a>
<a name="ln452">    float *hvwt = (float(*))((char *)cddiffsq + sizeof(float) * ts * ts + 2 * cldf * 64); // 1</a>
<a name="ln453">    // final interpolated colour difference</a>
<a name="ln454">    float(*Dgrb)[ts * tsh] = (float(*)[ts * tsh])vcdalt; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln455">    // gradient in plus (NE/SW) direction</a>
<a name="ln456">    float *delp = (float(*))cddiffsq; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln457">    // gradient in minus (NW/SE) direction</a>
<a name="ln458">    float *delm = (float(*))((char *)delp + sizeof(float) * ts * tsh + cldf * 64);</a>
<a name="ln459">    // diagonal interpolation of R+B</a>
<a name="ln460">    float *rbint = (float(*))delm; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln461">    // horizontal and vertical curvature of interpolated G (used to refine interpolation in Nyquist texture</a>
<a name="ln462">    // regions)</a>
<a name="ln463">    s_hv *Dgrb2 = (s_hv(*))((char *)hvwt + sizeof(float) * ts * tsh + cldf * 64); // 1</a>
<a name="ln464">    // difference between up/down interpolations of G</a>
<a name="ln465">    float *dgintv = (float(*))Dgrb2; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln466">    // difference between left/right interpolations of G</a>
<a name="ln467">    float *dginth = (float(*))((char *)dgintv + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln468">    // square of diagonal colour differences</a>
<a name="ln469">    float *Dgrbsq1m = (float(*))((char *)dginth + sizeof(float) * ts * ts + cldf * 64);    // 1</a>
<a name="ln470">    float *Dgrbsq1p = (float(*))((char *)Dgrbsq1m + sizeof(float) * ts * tsh + cldf * 64); // 1</a>
<a name="ln471">    // tile raw data</a>
<a name="ln472">    float *cfa = (float(*))((char *)Dgrbsq1p + sizeof(float) * ts * tsh + cldf * 64); // 1</a>
<a name="ln473">    // relative weight for combining plus and minus diagonal interpolations</a>
<a name="ln474">    float *pmwt = (float(*))delhvsqsum; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln475">    // interpolated colour difference R-B in minus and plus direction</a>
<a name="ln476">    float *rbm = (float(*))vcd; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln477">    float *rbp = (float(*))((char *)rbm + sizeof(float) * ts * tsh + cldf * 64);</a>
<a name="ln478">    // nyquist texture flags 1=nyquist, 0=not nyquist</a>
<a name="ln479">    unsigned char *nyquist = (unsigned char(*))((char *)cfa + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln480">    unsigned char *nyquist2 = (unsigned char(*))cddiffsq;</a>
<a name="ln481">    float *nyqutest = (float(*))((char *)nyquist + sizeof(unsigned char) * ts * tsh + cldf * 64); // 1</a>
<a name="ln482"> </a>
<a name="ln483">// Main algorithm: Tile loop</a>
<a name="ln484">// use collapse(2) to collapse the 2 loops to one large loop, so there is better scaling</a>
<a name="ln485">#ifdef _OPENMP</a>
<a name="ln486">#pragma omp for SIMD() schedule(static) collapse(2) nowait</a>
<a name="ln487">#endif</a>
<a name="ln488"> </a>
<a name="ln489">    for(int top = winy - 16; top &lt; winy + height; top += ts - 32)</a>
<a name="ln490">    {</a>
<a name="ln491">      for(int left = winx - 16; left &lt; winx + width; left += ts - 32)</a>
<a name="ln492">      {</a>
<a name="ln493">        memset(&amp;nyquist[3 * tsh], 0, sizeof(unsigned char) * (ts - 6) * tsh);</a>
<a name="ln494">        // location of tile bottom edge</a>
<a name="ln495">        int bottom = MIN(top + ts, winy + height + 16);</a>
<a name="ln496">        // location of tile right edge</a>
<a name="ln497">        int right = MIN(left + ts, winx + width + 16);</a>
<a name="ln498">        // tile width  (=ts except for right edge of image)</a>
<a name="ln499">        int rr1 = bottom - top;</a>
<a name="ln500">        // tile height (=ts except for bottom edge of image)</a>
<a name="ln501">        int cc1 = right - left;</a>
<a name="ln502">        // bookkeeping for borders</a>
<a name="ln503">        // min and max row/column in the tile</a>
<a name="ln504">        int rrmin = top &lt; winy ? 16 : 0;</a>
<a name="ln505">        int ccmin = left &lt; winx ? 16 : 0;</a>
<a name="ln506">        int rrmax = bottom &gt; (winy + height) ? winy + height - top : rr1;</a>
<a name="ln507">        int ccmax = right &gt; (winx + width) ? winx + width - left : cc1;</a>
<a name="ln508"> </a>
<a name="ln509">// rgb from input CFA data</a>
<a name="ln510">// rgb values should be floating point number between 0 and 1</a>
<a name="ln511">// after white balance multipliers are applied</a>
<a name="ln512">// a 16 pixel border is added to each side of the image</a>
<a name="ln513"> </a>
<a name="ln514">// begin of tile initialization</a>
<a name="ln515">#ifdef __SSE2__</a>
<a name="ln516">        // fill upper border</a>
<a name="ln517">        if(rrmin &gt; 0)</a>
<a name="ln518">        {</a>
<a name="ln519">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln520">          {</a>
<a name="ln521">            int row = 32 - rr + top;</a>
<a name="ln522"> </a>
<a name="ln523">            for(int cc = ccmin; cc &lt; ccmax; cc += 4)</a>
<a name="ln524">            {</a>
<a name="ln525">              int indx1 = rr * ts + cc;</a>
<a name="ln526">              vfloat tempv = LVFU(in[row * width + (cc + left)]);</a>
<a name="ln527">              STVF(cfa[indx1], tempv);</a>
<a name="ln528">              STVF(rgbgreen[indx1], tempv);</a>
<a name="ln529">            }</a>
<a name="ln530">          }</a>
<a name="ln531">        }</a>
<a name="ln532"> </a>
<a name="ln533">        // fill inner part</a>
<a name="ln534">        for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln535">        {</a>
<a name="ln536">          int row = rr + top;</a>
<a name="ln537"> </a>
<a name="ln538">          for(int cc = ccmin; cc &lt; ccmax; cc += 4)</a>
<a name="ln539">          {</a>
<a name="ln540">            int indx1 = rr * ts + cc;</a>
<a name="ln541">            vfloat tempv = LVFU(in[row * width + (cc + left)]);</a>
<a name="ln542">            STVF(cfa[indx1], tempv);</a>
<a name="ln543">            STVF(rgbgreen[indx1], tempv);</a>
<a name="ln544">          }</a>
<a name="ln545">        }</a>
<a name="ln546"> </a>
<a name="ln547">        // fill lower border</a>
<a name="ln548">        if(rrmax &lt; rr1)</a>
<a name="ln549">        {</a>
<a name="ln550">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln551">            for(int cc = ccmin; cc &lt; ccmax; cc += 4)</a>
<a name="ln552">            {</a>
<a name="ln553">              int indx1 = (rrmax + rr) * ts + cc;</a>
<a name="ln554">              vfloat tempv = LVFU(in[(winy + height - rr - 2) * width + (left + cc)]);</a>
<a name="ln555">              STVF(cfa[indx1], tempv);</a>
<a name="ln556">              STVF(rgbgreen[indx1], tempv);</a>
<a name="ln557">            }</a>
<a name="ln558">        }</a>
<a name="ln559"> </a>
<a name="ln560">#else</a>
<a name="ln561"> </a>
<a name="ln562">        // fill upper border</a>
<a name="ln563">        if(rrmin &gt; 0)</a>
<a name="ln564">        {</a>
<a name="ln565">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln566">            for(int cc = ccmin, row = 32 - rr + top; cc &lt; ccmax; cc++)</a>
<a name="ln567">            {</a>
<a name="ln568">              cfa[rr * ts + cc] = (in[row * width + (cc + left)]);</a>
<a name="ln569">              rgbgreen[rr * ts + cc] = cfa[rr * ts + cc];</a>
<a name="ln570">            }</a>
<a name="ln571">        }</a>
<a name="ln572"> </a>
<a name="ln573">        // fill inner part</a>
<a name="ln574">        for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln575">        {</a>
<a name="ln576">          int row = rr + top;</a>
<a name="ln577"> </a>
<a name="ln578">          for(int cc = ccmin; cc &lt; ccmax; cc++)</a>
<a name="ln579">          {</a>
<a name="ln580">            int indx1 = rr * ts + cc;</a>
<a name="ln581">            cfa[indx1] = (in[row * width + (cc + left)]);</a>
<a name="ln582">            rgbgreen[indx1] = cfa[indx1];</a>
<a name="ln583">          }</a>
<a name="ln584">        }</a>
<a name="ln585"> </a>
<a name="ln586">        // fill lower border</a>
<a name="ln587">        if(rrmax &lt; rr1)</a>
<a name="ln588">        {</a>
<a name="ln589">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln590">            for(int cc = ccmin; cc &lt; ccmax; cc++)</a>
<a name="ln591">            {</a>
<a name="ln592">              cfa[(rrmax + rr) * ts + cc] = (in[(winy + height - rr - 2) * width + (left + cc)]);</a>
<a name="ln593">              rgbgreen[(rrmax + rr) * ts + cc] = cfa[(rrmax + rr) * ts + cc];</a>
<a name="ln594">            }</a>
<a name="ln595">        }</a>
<a name="ln596"> </a>
<a name="ln597">#endif</a>
<a name="ln598"> </a>
<a name="ln599">        // fill left border</a>
<a name="ln600">        if(ccmin &gt; 0)</a>
<a name="ln601">        {</a>
<a name="ln602">          for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln603">            for(int cc = 0, row = rr + top; cc &lt; 16; cc++)</a>
<a name="ln604">            {</a>
<a name="ln605">              cfa[rr * ts + cc] = (in[row * width + (32 - cc + left)]);</a>
<a name="ln606">              rgbgreen[rr * ts + cc] = cfa[rr * ts + cc];</a>
<a name="ln607">            }</a>
<a name="ln608">        }</a>
<a name="ln609"> </a>
<a name="ln610">        // fill right border</a>
<a name="ln611">        if(ccmax &lt; cc1)</a>
<a name="ln612">        {</a>
<a name="ln613">          for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln614">            for(int cc = 0; cc &lt; 16; cc++)</a>
<a name="ln615">            {</a>
<a name="ln616">              cfa[rr * ts + ccmax + cc] = (in[(top + rr) * width + ((winx + width - cc - 2))]);</a>
<a name="ln617">              rgbgreen[rr * ts + ccmax + cc] = cfa[rr * ts + ccmax + cc];</a>
<a name="ln618">            }</a>
<a name="ln619">        }</a>
<a name="ln620"> </a>
<a name="ln621">        // also, fill the image corners</a>
<a name="ln622">        if(rrmin &gt; 0 &amp;&amp; ccmin &gt; 0)</a>
<a name="ln623">        {</a>
<a name="ln624">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln625">            for(int cc = 0; cc &lt; 16; cc++)</a>
<a name="ln626">            {</a>
<a name="ln627">              cfa[(rr)*ts + cc] = (in[(winy + 32 - rr) * width + (winx + 32 - cc)]);</a>
<a name="ln628">              rgbgreen[(rr)*ts + cc] = cfa[(rr)*ts + cc];</a>
<a name="ln629">            }</a>
<a name="ln630">        }</a>
<a name="ln631"> </a>
<a name="ln632">        if(rrmax &lt; rr1 &amp;&amp; ccmax &lt; cc1)</a>
<a name="ln633">        {</a>
<a name="ln634">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln635">            for(int cc = 0; cc &lt; 16; cc++)</a>
<a name="ln636">            {</a>
<a name="ln637">              cfa[(rrmax + rr) * ts + ccmax + cc]</a>
<a name="ln638">                  = (in[(winy + height - rr - 2) * width + ((winx + width - cc - 2))]);</a>
<a name="ln639">              rgbgreen[(rrmax + rr) * ts + ccmax + cc] = cfa[(rrmax + rr) * ts + ccmax + cc];</a>
<a name="ln640">            }</a>
<a name="ln641">        }</a>
<a name="ln642"> </a>
<a name="ln643">        if(rrmin &gt; 0 &amp;&amp; ccmax &lt; cc1)</a>
<a name="ln644">        {</a>
<a name="ln645">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln646">            for(int cc = 0; cc &lt; 16; cc++)</a>
<a name="ln647">            {</a>
<a name="ln648">              cfa[(rr)*ts + ccmax + cc] = (in[(winy + 32 - rr) * width + ((winx + width - cc - 2))]);</a>
<a name="ln649">              rgbgreen[(rr)*ts + ccmax + cc] = cfa[(rr)*ts + ccmax + cc];</a>
<a name="ln650">            }</a>
<a name="ln651">        }</a>
<a name="ln652"> </a>
<a name="ln653">        if(rrmax &lt; rr1 &amp;&amp; ccmin &gt; 0)</a>
<a name="ln654">        {</a>
<a name="ln655">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln656">            for(int cc = 0; cc &lt; 16; cc++)</a>
<a name="ln657">            {</a>
<a name="ln658">              cfa[(rrmax + rr) * ts + cc] = (in[(winy + height - rr - 2) * width + ((winx + 32 - cc))]);</a>
<a name="ln659">              rgbgreen[(rrmax + rr) * ts + cc] = cfa[(rrmax + rr) * ts + cc];</a>
<a name="ln660">            }</a>
<a name="ln661">        }</a>
<a name="ln662"> </a>
<a name="ln663">// end of tile initialization</a>
<a name="ln664"> </a>
<a name="ln665">// horizontal and vertical gradients</a>
<a name="ln666">#ifdef __SSE2__</a>
<a name="ln667">        vfloat epsv = F2V(eps);</a>
<a name="ln668"> </a>
<a name="ln669">        for(int rr = 2; rr &lt; rr1 - 2; rr++)</a>
<a name="ln670">        {</a>
<a name="ln671">          for(int indx = rr * ts; indx &lt; rr * ts + cc1; indx += 4)</a>
<a name="ln672">          {</a>
<a name="ln673">            vfloat delhv = vabsf(LVFU(cfa[indx + 1]) - LVFU(cfa[indx - 1]));</a>
<a name="ln674">            vfloat delvv = vabsf(LVF(cfa[indx + v1]) - LVF(cfa[indx - v1]));</a>
<a name="ln675">            STVF(dirwts1[indx], epsv + vabsf(LVFU(cfa[indx + 2]) - LVF(cfa[indx]))</a>
<a name="ln676">                                    + vabsf(LVF(cfa[indx]) - LVFU(cfa[indx - 2])) + delhv);</a>
<a name="ln677">            STVF(dirwts0[indx], epsv + vabsf(LVF(cfa[indx + v2]) - LVF(cfa[indx]))</a>
<a name="ln678">                                    + vabsf(LVF(cfa[indx]) - LVF(cfa[indx - v2])) + delvv);</a>
<a name="ln679">            STVF(delhvsqsum[indx], SQRV(delhv) + SQRV(delvv));</a>
<a name="ln680">          }</a>
<a name="ln681">        }</a>
<a name="ln682"> </a>
<a name="ln683">#else</a>
<a name="ln684"> </a>
<a name="ln685">        for(int rr = 2; rr &lt; rr1 - 2; rr++)</a>
<a name="ln686">          for(int cc = 2, indx = (rr)*ts + cc; cc &lt; cc1 - 2; cc++, indx++)</a>
<a name="ln687">          {</a>
<a name="ln688">            float delh = fabsf(cfa[indx + 1] - cfa[indx - 1]);</a>
<a name="ln689">            float delv = fabsf(cfa[indx + v1] - cfa[indx - v1]);</a>
<a name="ln690">            dirwts0[indx]</a>
<a name="ln691">                = eps + fabsf(cfa[indx + v2] - cfa[indx]) + fabsf(cfa[indx] - cfa[indx - v2]) + delv;</a>
<a name="ln692">            dirwts1[indx] = eps + fabsf(cfa[indx + 2] - cfa[indx]) + fabsf(cfa[indx] - cfa[indx - 2]) + delh;</a>
<a name="ln693">            delhvsqsum[indx] = SQR(delh) + SQR(delv);</a>
<a name="ln694">          }</a>
<a name="ln695"> </a>
<a name="ln696">#endif</a>
<a name="ln697"> </a>
<a name="ln698">// interpolate vertical and horizontal colour differences</a>
<a name="ln699">#ifdef __SSE2__</a>
<a name="ln700">        vfloat sgnv;</a>
<a name="ln701"> </a>
<a name="ln702">        if(!(FC(4, 4, filters) &amp; 1))</a>
<a name="ln703">        {</a>
<a name="ln704">          sgnv = _mm_set_ps(1.f, -1.f, 1.f, -1.f);</a>
<a name="ln705">        }</a>
<a name="ln706">        else</a>
<a name="ln707">        {</a>
<a name="ln708">          sgnv = _mm_set_ps(-1.f, 1.f, -1.f, 1.f);</a>
<a name="ln709">        }</a>
<a name="ln710"> </a>
<a name="ln711">        vfloat zd5v = F2V(0.5f);</a>
<a name="ln712">        vfloat onev = F2V(1.f);</a>
<a name="ln713">        vfloat arthreshv = F2V(arthresh);</a>
<a name="ln714">        vfloat clip_pt8v = F2V(clip_pt8);</a>
<a name="ln715"> </a>
<a name="ln716">        for(int rr = 4; rr &lt; rr1 - 4; rr++)</a>
<a name="ln717">        {</a>
<a name="ln718">          sgnv = -sgnv;</a>
<a name="ln719"> </a>
<a name="ln720">          for(int indx = rr * ts + 4; indx &lt; rr * ts + cc1 - 7; indx += 4)</a>
<a name="ln721">          {</a>
<a name="ln722">            // colour ratios in each cardinal direction</a>
<a name="ln723">            vfloat cfav = LVF(cfa[indx]);</a>
<a name="ln724">            vfloat cruv = LVF(cfa[indx - v1]) * (LVF(dirwts0[indx - v2]) + LVF(dirwts0[indx]))</a>
<a name="ln725">                          / (LVF(dirwts0[indx - v2]) * (epsv + cfav)</a>
<a name="ln726">                             + LVF(dirwts0[indx]) * (epsv + LVF(cfa[indx - v2])));</a>
<a name="ln727">            vfloat crdv = LVF(cfa[indx + v1]) * (LVF(dirwts0[indx + v2]) + LVF(dirwts0[indx]))</a>
<a name="ln728">                          / (LVF(dirwts0[indx + v2]) * (epsv + cfav)</a>
<a name="ln729">                             + LVF(dirwts0[indx]) * (epsv + LVF(cfa[indx + v2])));</a>
<a name="ln730">            vfloat crlv = LVFU(cfa[indx - 1]) * (LVFU(dirwts1[indx - 2]) + LVF(dirwts1[indx]))</a>
<a name="ln731">                          / (LVFU(dirwts1[indx - 2]) * (epsv + cfav)</a>
<a name="ln732">                             + LVF(dirwts1[indx]) * (epsv + LVFU(cfa[indx - 2])));</a>
<a name="ln733">            vfloat crrv = LVFU(cfa[indx + 1]) * (LVFU(dirwts1[indx + 2]) + LVF(dirwts1[indx]))</a>
<a name="ln734">                          / (LVFU(dirwts1[indx + 2]) * (epsv + cfav)</a>
<a name="ln735">                             + LVF(dirwts1[indx]) * (epsv + LVFU(cfa[indx + 2])));</a>
<a name="ln736"> </a>
<a name="ln737">            // G interpolated in vert/hor directions using Hamilton-Adams method</a>
<a name="ln738">            vfloat guhav = LVF(cfa[indx - v1]) + zd5v * (cfav - LVF(cfa[indx - v2]));</a>
<a name="ln739">            vfloat gdhav = LVF(cfa[indx + v1]) + zd5v * (cfav - LVF(cfa[indx + v2]));</a>
<a name="ln740">            vfloat glhav = LVFU(cfa[indx - 1]) + zd5v * (cfav - LVFU(cfa[indx - 2]));</a>
<a name="ln741">            vfloat grhav = LVFU(cfa[indx + 1]) + zd5v * (cfav - LVFU(cfa[indx + 2]));</a>
<a name="ln742"> </a>
<a name="ln743">            // G interpolated in vert/hor directions using adaptive ratios</a>
<a name="ln744">            vfloat guarv = vself(vmaskf_lt(vabsf(onev - cruv), arthreshv), cfav * cruv, guhav);</a>
<a name="ln745">            vfloat gdarv = vself(vmaskf_lt(vabsf(onev - crdv), arthreshv), cfav * crdv, gdhav);</a>
<a name="ln746">            vfloat glarv = vself(vmaskf_lt(vabsf(onev - crlv), arthreshv), cfav * crlv, glhav);</a>
<a name="ln747">            vfloat grarv = vself(vmaskf_lt(vabsf(onev - crrv), arthreshv), cfav * crrv, grhav);</a>
<a name="ln748"> </a>
<a name="ln749">            // adaptive weights for vertical/horizontal directions</a>
<a name="ln750">            vfloat hwtv = LVFU(dirwts1[indx - 1]) / (LVFU(dirwts1[indx - 1]) + LVFU(dirwts1[indx + 1]));</a>
<a name="ln751">            vfloat vwtv = LVF(dirwts0[indx - v1]) / (LVF(dirwts0[indx + v1]) + LVF(dirwts0[indx - v1]));</a>
<a name="ln752"> </a>
<a name="ln753">            // interpolated G via adaptive weights of cardinal evaluations</a>
<a name="ln754">            vfloat Ginthhav = vintpf(hwtv, grhav, glhav);</a>
<a name="ln755">            vfloat Gintvhav = vintpf(vwtv, gdhav, guhav);</a>
<a name="ln756"> </a>
<a name="ln757">            // interpolated colour differences</a>
<a name="ln758">            vfloat hcdaltv = sgnv * (Ginthhav - cfav);</a>
<a name="ln759">            vfloat vcdaltv = sgnv * (Gintvhav - cfav);</a>
<a name="ln760">            STVF(hcdalt[indx], hcdaltv);</a>
<a name="ln761">            STVF(vcdalt[indx], vcdaltv);</a>
<a name="ln762"> </a>
<a name="ln763">            vmask clipmask = vorm(vorm(vmaskf_gt(cfav, clip_pt8v), vmaskf_gt(Gintvhav, clip_pt8v)),</a>
<a name="ln764">                                  vmaskf_gt(Ginthhav, clip_pt8v));</a>
<a name="ln765">            guarv = vself(clipmask, guhav, guarv);</a>
<a name="ln766">            gdarv = vself(clipmask, gdhav, gdarv);</a>
<a name="ln767">            glarv = vself(clipmask, glhav, glarv);</a>
<a name="ln768">            grarv = vself(clipmask, grhav, grarv);</a>
<a name="ln769"> </a>
<a name="ln770">            // use HA if highlights are (nearly) clipped</a>
<a name="ln771">            STVF(vcd[indx], vself(clipmask, vcdaltv, sgnv * (vintpf(vwtv, gdarv, guarv) - cfav)));</a>
<a name="ln772">            STVF(hcd[indx], vself(clipmask, hcdaltv, sgnv * (vintpf(hwtv, grarv, glarv) - cfav)));</a>
<a name="ln773"> </a>
<a name="ln774">            // differences of interpolations in opposite directions</a>
<a name="ln775">            STVF(dgintv[indx], vminf(SQRV(guhav - gdhav), SQRV(guarv - gdarv)));</a>
<a name="ln776">            STVF(dginth[indx], vminf(SQRV(glhav - grhav), SQRV(glarv - grarv)));</a>
<a name="ln777">          }</a>
<a name="ln778">        }</a>
<a name="ln779"> </a>
<a name="ln780">#else</a>
<a name="ln781"> </a>
<a name="ln782">        for(int rr = 4; rr &lt; rr1 - 4; rr++)</a>
<a name="ln783">        {</a>
<a name="ln784">          bool fcswitch = FC(rr, 4, filters) &amp; 1;</a>
<a name="ln785"> </a>
<a name="ln786">          for(int cc = 4, indx = rr * ts + cc; cc &lt; cc1 - 4; cc++, indx++)</a>
<a name="ln787">          {</a>
<a name="ln788"> </a>
<a name="ln789">            // colour ratios in each cardinal direction</a>
<a name="ln790">            float cru = cfa[indx - v1] * (dirwts0[indx - v2] + dirwts0[indx])</a>
<a name="ln791">                        / (dirwts0[indx - v2] * (eps + cfa[indx]) + dirwts0[indx] * (eps + cfa[indx - v2]));</a>
<a name="ln792">            float crd = cfa[indx + v1] * (dirwts0[indx + v2] + dirwts0[indx])</a>
<a name="ln793">                        / (dirwts0[indx + v2] * (eps + cfa[indx]) + dirwts0[indx] * (eps + cfa[indx + v2]));</a>
<a name="ln794">            float crl = cfa[indx - 1] * (dirwts1[indx - 2] + dirwts1[indx])</a>
<a name="ln795">                        / (dirwts1[indx - 2] * (eps + cfa[indx]) + dirwts1[indx] * (eps + cfa[indx - 2]));</a>
<a name="ln796">            float crr = cfa[indx + 1] * (dirwts1[indx + 2] + dirwts1[indx])</a>
<a name="ln797">                        / (dirwts1[indx + 2] * (eps + cfa[indx]) + dirwts1[indx] * (eps + cfa[indx + 2]));</a>
<a name="ln798"> </a>
<a name="ln799">            // G interpolated in vert/hor directions using Hamilton-Adams method</a>
<a name="ln800">            float guha = cfa[indx - v1] + xdiv2f(cfa[indx] - cfa[indx - v2]);</a>
<a name="ln801">            float gdha = cfa[indx + v1] + xdiv2f(cfa[indx] - cfa[indx + v2]);</a>
<a name="ln802">            float glha = cfa[indx - 1] + xdiv2f(cfa[indx] - cfa[indx - 2]);</a>
<a name="ln803">            float grha = cfa[indx + 1] + xdiv2f(cfa[indx] - cfa[indx + 2]);</a>
<a name="ln804"> </a>
<a name="ln805">            // G interpolated in vert/hor directions using adaptive ratios</a>
<a name="ln806">            float guar, gdar, glar, grar;</a>
<a name="ln807"> </a>
<a name="ln808">            if(fabsf(1.f - cru) &lt; arthresh)</a>
<a name="ln809">            {</a>
<a name="ln810">              guar = cfa[indx] * cru;</a>
<a name="ln811">            }</a>
<a name="ln812">            else</a>
<a name="ln813">            {</a>
<a name="ln814">              guar = guha;</a>
<a name="ln815">            }</a>
<a name="ln816"> </a>
<a name="ln817">            if(fabsf(1.f - crd) &lt; arthresh)</a>
<a name="ln818">            {</a>
<a name="ln819">              gdar = cfa[indx] * crd;</a>
<a name="ln820">            }</a>
<a name="ln821">            else</a>
<a name="ln822">            {</a>
<a name="ln823">              gdar = gdha;</a>
<a name="ln824">            }</a>
<a name="ln825"> </a>
<a name="ln826">            if(fabsf(1.f - crl) &lt; arthresh)</a>
<a name="ln827">            {</a>
<a name="ln828">              glar = cfa[indx] * crl;</a>
<a name="ln829">            }</a>
<a name="ln830">            else</a>
<a name="ln831">            {</a>
<a name="ln832">              glar = glha;</a>
<a name="ln833">            }</a>
<a name="ln834"> </a>
<a name="ln835">            if(fabsf(1.f - crr) &lt; arthresh)</a>
<a name="ln836">            {</a>
<a name="ln837">              grar = cfa[indx] * crr;</a>
<a name="ln838">            }</a>
<a name="ln839">            else</a>
<a name="ln840">            {</a>
<a name="ln841">              grar = grha;</a>
<a name="ln842">            }</a>
<a name="ln843"> </a>
<a name="ln844">            // adaptive weights for vertical/horizontal directions</a>
<a name="ln845">            float hwt = dirwts1[indx - 1] / (dirwts1[indx - 1] + dirwts1[indx + 1]);</a>
<a name="ln846">            float vwt = dirwts0[indx - v1] / (dirwts0[indx + v1] + dirwts0[indx - v1]);</a>
<a name="ln847"> </a>
<a name="ln848">            // interpolated G via adaptive weights of cardinal evaluations</a>
<a name="ln849">            float Gintvha = vwt * gdha + (1.f - vwt) * guha;</a>
<a name="ln850">            float Ginthha = hwt * grha + (1.f - hwt) * glha;</a>
<a name="ln851"> </a>
<a name="ln852">            // interpolated colour differences</a>
<a name="ln853">            if(fcswitch)</a>
<a name="ln854">            {</a>
<a name="ln855">              vcd[indx] = cfa[indx] - (vwt * gdar + (1.f - vwt) * guar);</a>
<a name="ln856">              hcd[indx] = cfa[indx] - (hwt * grar + (1.f - hwt) * glar);</a>
<a name="ln857">              vcdalt[indx] = cfa[indx] - Gintvha;</a>
<a name="ln858">              hcdalt[indx] = cfa[indx] - Ginthha;</a>
<a name="ln859">            }</a>
<a name="ln860">            else</a>
<a name="ln861">            {</a>
<a name="ln862">              // interpolated colour differences</a>
<a name="ln863">              vcd[indx] = (vwt * gdar + (1.f - vwt) * guar) - cfa[indx];</a>
<a name="ln864">              hcd[indx] = (hwt * grar + (1.f - hwt) * glar) - cfa[indx];</a>
<a name="ln865">              vcdalt[indx] = Gintvha - cfa[indx];</a>
<a name="ln866">              hcdalt[indx] = Ginthha - cfa[indx];</a>
<a name="ln867">            }</a>
<a name="ln868"> </a>
<a name="ln869">            fcswitch = !fcswitch;</a>
<a name="ln870"> </a>
<a name="ln871">            if(cfa[indx] &gt; clip_pt8 || Gintvha &gt; clip_pt8 || Ginthha &gt; clip_pt8)</a>
<a name="ln872">            {</a>
<a name="ln873">              // use HA if highlights are (nearly) clipped</a>
<a name="ln874">              guar = guha;</a>
<a name="ln875">              gdar = gdha;</a>
<a name="ln876">              glar = glha;</a>
<a name="ln877">              grar = grha;</a>
<a name="ln878">              vcd[indx] = vcdalt[indx];</a>
<a name="ln879">              hcd[indx] = hcdalt[indx];</a>
<a name="ln880">            }</a>
<a name="ln881"> </a>
<a name="ln882">            // differences of interpolations in opposite directions</a>
<a name="ln883">            dgintv[indx] = MIN(SQR(guha - gdha), SQR(guar - gdar));</a>
<a name="ln884">            dginth[indx] = MIN(SQR(glha - grha), SQR(glar - grar));</a>
<a name="ln885">          }</a>
<a name="ln886">        }</a>
<a name="ln887"> </a>
<a name="ln888">#endif</a>
<a name="ln889"> </a>
<a name="ln890"> </a>
<a name="ln891"> </a>
<a name="ln892">#ifdef __SSE2__</a>
<a name="ln893">        vfloat clip_ptv = F2V(clip_pt);</a>
<a name="ln894">        vfloat sgn3v;</a>
<a name="ln895"> </a>
<a name="ln896">        if(!(FC(4, 4, filters) &amp; 1))</a>
<a name="ln897">        {</a>
<a name="ln898">          sgnv = _mm_set_ps(1.f, -1.f, 1.f, -1.f);</a>
<a name="ln899">        }</a>
<a name="ln900">        else</a>
<a name="ln901">        {</a>
<a name="ln902">          sgnv = _mm_set_ps(-1.f, 1.f, -1.f, 1.f);</a>
<a name="ln903">        }</a>
<a name="ln904"> </a>
<a name="ln905">        sgn3v = sgnv + sgnv + sgnv;</a>
<a name="ln906"> </a>
<a name="ln907">        for(int rr = 4; rr &lt; rr1 - 4; rr++)</a>
<a name="ln908">        {</a>
<a name="ln909">          vfloat nsgnv = sgnv;</a>
<a name="ln910">          sgnv = -sgnv;</a>
<a name="ln911">          sgn3v = -sgn3v;</a>
<a name="ln912"> </a>
<a name="ln913">          for(int indx = rr * ts + 4; indx &lt; rr * ts + cc1 - 4; indx += 4)</a>
<a name="ln914">          {</a>
<a name="ln915">            vfloat hcdv = LVF(hcd[indx]);</a>
<a name="ln916">            vfloat hcdvarv = SQRV(LVFU(hcd[indx - 2]) - hcdv)</a>
<a name="ln917">                             + SQRV(LVFU(hcd[indx - 2]) - LVFU(hcd[indx + 2]))</a>
<a name="ln918">                             + SQRV(hcdv - LVFU(hcd[indx + 2]));</a>
<a name="ln919">            vfloat hcdaltv = LVF(hcdalt[indx]);</a>
<a name="ln920">            vfloat hcdaltvarv = SQRV(LVFU(hcdalt[indx - 2]) - hcdaltv)</a>
<a name="ln921">                                + SQRV(LVFU(hcdalt[indx - 2]) - LVFU(hcdalt[indx + 2]))</a>
<a name="ln922">                                + SQRV(hcdaltv - LVFU(hcdalt[indx + 2]));</a>
<a name="ln923">            vfloat vcdv = LVF(vcd[indx]);</a>
<a name="ln924">            vfloat vcdvarv = SQRV(LVF(vcd[indx - v2]) - vcdv)</a>
<a name="ln925">                             + SQRV(LVF(vcd[indx - v2]) - LVF(vcd[indx + v2]))</a>
<a name="ln926">                             + SQRV(vcdv - LVF(vcd[indx + v2]));</a>
<a name="ln927">            vfloat vcdaltv = LVF(vcdalt[indx]);</a>
<a name="ln928">            vfloat vcdaltvarv = SQRV(LVF(vcdalt[indx - v2]) - vcdaltv)</a>
<a name="ln929">                                + SQRV(LVF(vcdalt[indx - v2]) - LVF(vcdalt[indx + v2]))</a>
<a name="ln930">                                + SQRV(vcdaltv - LVF(vcdalt[indx + v2]));</a>
<a name="ln931"> </a>
<a name="ln932">            // choose the smallest variance; this yields a smoother interpolation</a>
<a name="ln933">            hcdv = vself(vmaskf_lt(hcdaltvarv, hcdvarv), hcdaltv, hcdv);</a>
<a name="ln934">            vcdv = vself(vmaskf_lt(vcdaltvarv, vcdvarv), vcdaltv, vcdv);</a>
<a name="ln935"> </a>
<a name="ln936">            // bound the interpolation in regions of high saturation</a>
<a name="ln937">            // vertical and horizontal G interpolations</a>
<a name="ln938">            vfloat Ginthv = sgnv * hcdv + LVF(cfa[indx]);</a>
<a name="ln939">            vfloat temp2v = sgn3v * hcdv;</a>
<a name="ln940">            vfloat hwtv = onev + temp2v / (epsv + Ginthv + LVF(cfa[indx]));</a>
<a name="ln941">            vmask hcdmask = vmaskf_gt(nsgnv * hcdv, ZEROV);</a>
<a name="ln942">            vfloat hcdoldv = hcdv;</a>
<a name="ln943">            vfloat tempv = nsgnv * (LVF(cfa[indx]) - ULIMV(Ginthv, LVFU(cfa[indx - 1]), LVFU(cfa[indx + 1])));</a>
<a name="ln944">            hcdv = vself(vmaskf_lt(temp2v, -(LVF(cfa[indx]) + Ginthv)), tempv, vintpf(hwtv, hcdv, tempv));</a>
<a name="ln945">            hcdv = vself(hcdmask, hcdv, hcdoldv);</a>
<a name="ln946">            hcdv = vself(vmaskf_gt(Ginthv, clip_ptv), tempv, hcdv);</a>
<a name="ln947">            STVF(hcd[indx], hcdv);</a>
<a name="ln948"> </a>
<a name="ln949">            vfloat Gintvv = sgnv * vcdv + LVF(cfa[indx]);</a>
<a name="ln950">            temp2v = sgn3v * vcdv;</a>
<a name="ln951">            vfloat vwtv = onev + temp2v / (epsv + Gintvv + LVF(cfa[indx]));</a>
<a name="ln952">            vmask vcdmask = vmaskf_gt(nsgnv * vcdv, ZEROV);</a>
<a name="ln953">            vfloat vcdoldv = vcdv;</a>
<a name="ln954">            tempv = nsgnv * (LVF(cfa[indx]) - ULIMV(Gintvv, LVF(cfa[indx - v1]), LVF(cfa[indx + v1])));</a>
<a name="ln955">            vcdv = vself(vmaskf_lt(temp2v, -(LVF(cfa[indx]) + Gintvv)), tempv, vintpf(vwtv, vcdv, tempv));</a>
<a name="ln956">            vcdv = vself(vcdmask, vcdv, vcdoldv);</a>
<a name="ln957">            vcdv = vself(vmaskf_gt(Gintvv, clip_ptv), tempv, vcdv);</a>
<a name="ln958">            STVF(vcd[indx], vcdv);</a>
<a name="ln959">            STVFU(cddiffsq[indx], SQRV(vcdv - hcdv));</a>
<a name="ln960">          }</a>
<a name="ln961">        }</a>
<a name="ln962"> </a>
<a name="ln963">#else</a>
<a name="ln964"> </a>
<a name="ln965">        for(int rr = 4; rr &lt; rr1 - 4; rr++)</a>
<a name="ln966">        {</a>
<a name="ln967">          for(int cc = 4, indx = rr * ts + cc, c = FC(rr, cc, filters) &amp; 1; cc &lt; cc1 - 4; cc++, indx++)</a>
<a name="ln968">          {</a>
<a name="ln969">            float hcdvar = 3.f * (SQR(hcd[indx - 2]) + SQR(hcd[indx]) + SQR(hcd[indx + 2]))</a>
<a name="ln970">                           - SQR(hcd[indx - 2] + hcd[indx] + hcd[indx + 2]);</a>
<a name="ln971">            float hcdaltvar = 3.f * (SQR(hcdalt[indx - 2]) + SQR(hcdalt[indx]) + SQR(hcdalt[indx + 2]))</a>
<a name="ln972">                              - SQR(hcdalt[indx - 2] + hcdalt[indx] + hcdalt[indx + 2]);</a>
<a name="ln973">            float vcdvar = 3.f * (SQR(vcd[indx - v2]) + SQR(vcd[indx]) + SQR(vcd[indx + v2]))</a>
<a name="ln974">                           - SQR(vcd[indx - v2] + vcd[indx] + vcd[indx + v2]);</a>
<a name="ln975">            float vcdaltvar = 3.f * (SQR(vcdalt[indx - v2]) + SQR(vcdalt[indx]) + SQR(vcdalt[indx + v2]))</a>
<a name="ln976">                              - SQR(vcdalt[indx - v2] + vcdalt[indx] + vcdalt[indx + v2]);</a>
<a name="ln977"> </a>
<a name="ln978">            // choose the smallest variance; this yields a smoother interpolation</a>
<a name="ln979">            if(hcdaltvar &lt; hcdvar)</a>
<a name="ln980">            {</a>
<a name="ln981">              hcd[indx] = hcdalt[indx];</a>
<a name="ln982">            }</a>
<a name="ln983"> </a>
<a name="ln984">            if(vcdaltvar &lt; vcdvar)</a>
<a name="ln985">            {</a>
<a name="ln986">              vcd[indx] = vcdalt[indx];</a>
<a name="ln987">            }</a>
<a name="ln988"> </a>
<a name="ln989">            // bound the interpolation in regions of high saturation</a>
<a name="ln990">            // vertical and horizontal G interpolations</a>
<a name="ln991">            float Gintv, Ginth;</a>
<a name="ln992"> </a>
<a name="ln993">            if(c)</a>
<a name="ln994">            {                                 // G site</a>
<a name="ln995">              Ginth = -hcd[indx] + cfa[indx]; // R or B</a>
<a name="ln996">              Gintv = -vcd[indx] + cfa[indx]; // B or R</a>
<a name="ln997"> </a>
<a name="ln998">              if(hcd[indx] &gt; 0)</a>
<a name="ln999">              {</a>
<a name="ln1000">                if(3.f * hcd[indx] &gt; (Ginth + cfa[indx]))</a>
<a name="ln1001">                {</a>
<a name="ln1002">                  hcd[indx] = -ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]) + cfa[indx];</a>
<a name="ln1003">                }</a>
<a name="ln1004">                else</a>
<a name="ln1005">                {</a>
<a name="ln1006">                  float hwt = 1.f - 3.f * hcd[indx] / (eps + Ginth + cfa[indx]);</a>
<a name="ln1007">                  hcd[indx] = hwt * hcd[indx]</a>
<a name="ln1008">                              + (1.f - hwt) * (-ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]) + cfa[indx]);</a>
<a name="ln1009">                }</a>
<a name="ln1010">              }</a>
<a name="ln1011"> </a>
<a name="ln1012">              if(vcd[indx] &gt; 0)</a>
<a name="ln1013">              {</a>
<a name="ln1014">                if(3.f * vcd[indx] &gt; (Gintv + cfa[indx]))</a>
<a name="ln1015">                {</a>
<a name="ln1016">                  vcd[indx] = -ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]) + cfa[indx];</a>
<a name="ln1017">                }</a>
<a name="ln1018">                else</a>
<a name="ln1019">                {</a>
<a name="ln1020">                  float vwt = 1.f - 3.f * vcd[indx] / (eps + Gintv + cfa[indx]);</a>
<a name="ln1021">                  vcd[indx] = vwt * vcd[indx]</a>
<a name="ln1022">                              + (1.f - vwt) * (-ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]) + cfa[indx]);</a>
<a name="ln1023">                }</a>
<a name="ln1024">              }</a>
<a name="ln1025"> </a>
<a name="ln1026">              if(Ginth &gt; clip_pt)</a>
<a name="ln1027">              {</a>
<a name="ln1028">                hcd[indx] = -ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]) + cfa[indx];</a>
<a name="ln1029">              }</a>
<a name="ln1030"> </a>
<a name="ln1031">              if(Gintv &gt; clip_pt)</a>
<a name="ln1032">              {</a>
<a name="ln1033">                vcd[indx] = -ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]) + cfa[indx];</a>
<a name="ln1034">              }</a>
<a name="ln1035">            }</a>
<a name="ln1036">            else</a>
<a name="ln1037">            { // R or B site</a>
<a name="ln1038"> </a>
<a name="ln1039">              Ginth = hcd[indx] + cfa[indx]; // interpolated G</a>
<a name="ln1040">              Gintv = vcd[indx] + cfa[indx];</a>
<a name="ln1041"> </a>
<a name="ln1042">              if(hcd[indx] &lt; 0)</a>
<a name="ln1043">              {</a>
<a name="ln1044">                if(3.f * hcd[indx] &lt; -(Ginth + cfa[indx]))</a>
<a name="ln1045">                {</a>
<a name="ln1046">                  hcd[indx] = ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]) - cfa[indx];</a>
<a name="ln1047">                }</a>
<a name="ln1048">                else</a>
<a name="ln1049">                {</a>
<a name="ln1050">                  float hwt = 1.f + 3.f * hcd[indx] / (eps + Ginth + cfa[indx]);</a>
<a name="ln1051">                  hcd[indx] = hwt * hcd[indx]</a>
<a name="ln1052">                              + (1.f - hwt) * (ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]) - cfa[indx]);</a>
<a name="ln1053">                }</a>
<a name="ln1054">              }</a>
<a name="ln1055"> </a>
<a name="ln1056">              if(vcd[indx] &lt; 0)</a>
<a name="ln1057">              {</a>
<a name="ln1058">                if(3.f * vcd[indx] &lt; -(Gintv + cfa[indx]))</a>
<a name="ln1059">                {</a>
<a name="ln1060">                  vcd[indx] = ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]) - cfa[indx];</a>
<a name="ln1061">                }</a>
<a name="ln1062">                else</a>
<a name="ln1063">                {</a>
<a name="ln1064">                  float vwt = 1.f + 3.f * vcd[indx] / (eps + Gintv + cfa[indx]);</a>
<a name="ln1065">                  vcd[indx] = vwt * vcd[indx]</a>
<a name="ln1066">                              + (1.f - vwt) * (ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]) - cfa[indx]);</a>
<a name="ln1067">                }</a>
<a name="ln1068">              }</a>
<a name="ln1069"> </a>
<a name="ln1070">              if(Ginth &gt; clip_pt)</a>
<a name="ln1071">              {</a>
<a name="ln1072">                hcd[indx] = ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]) - cfa[indx];</a>
<a name="ln1073">              }</a>
<a name="ln1074"> </a>
<a name="ln1075">              if(Gintv &gt; clip_pt)</a>
<a name="ln1076">              {</a>
<a name="ln1077">                vcd[indx] = ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]) - cfa[indx];</a>
<a name="ln1078">              }</a>
<a name="ln1079"> </a>
<a name="ln1080">              cddiffsq[indx] = SQR(vcd[indx] - hcd[indx]);</a>
<a name="ln1081">            }</a>
<a name="ln1082"> </a>
<a name="ln1083">            c = !c;</a>
<a name="ln1084">          }</a>
<a name="ln1085">        }</a>
<a name="ln1086"> </a>
<a name="ln1087">#endif</a>
<a name="ln1088"> </a>
<a name="ln1089"> </a>
<a name="ln1090"> </a>
<a name="ln1091">#ifdef __SSE2__</a>
<a name="ln1092">        vfloat epssqv = F2V(epssq);</a>
<a name="ln1093"> </a>
<a name="ln1094">        for(int rr = 6; rr &lt; rr1 - 6; rr++)</a>
<a name="ln1095">        {</a>
<a name="ln1096">          for(int indx = rr * ts + 6 + (FC(rr, 2, filters) &amp; 1); indx &lt; rr * ts + cc1 - 6; indx += 8)</a>
<a name="ln1097">          {</a>
<a name="ln1098">            // compute colour difference variances in cardinal directions</a>
<a name="ln1099">            vfloat tempv = LC2VFU(vcd[indx]);</a>
<a name="ln1100">            vfloat uavev = tempv + LC2VFU(vcd[indx - v1]) + LC2VFU(vcd[indx - v2]) + LC2VFU(vcd[indx - v3]);</a>
<a name="ln1101">            vfloat davev = tempv + LC2VFU(vcd[indx + v1]) + LC2VFU(vcd[indx + v2]) + LC2VFU(vcd[indx + v3]);</a>
<a name="ln1102">            vfloat Dgrbvvaruv = SQRV(tempv - uavev) + SQRV(LC2VFU(vcd[indx - v1]) - uavev)</a>
<a name="ln1103">                                + SQRV(LC2VFU(vcd[indx - v2]) - uavev) + SQRV(LC2VFU(vcd[indx - v3]) - uavev);</a>
<a name="ln1104">            vfloat Dgrbvvardv = SQRV(tempv - davev) + SQRV(LC2VFU(vcd[indx + v1]) - davev)</a>
<a name="ln1105">                                + SQRV(LC2VFU(vcd[indx + v2]) - davev) + SQRV(LC2VFU(vcd[indx + v3]) - davev);</a>
<a name="ln1106"> </a>
<a name="ln1107">            vfloat hwtv = vadivapb(LC2VFU(dirwts1[indx - 1]), LC2VFU(dirwts1[indx + 1]));</a>
<a name="ln1108">            vfloat vwtv = vadivapb(LC2VFU(dirwts0[indx - v1]), LC2VFU(dirwts0[indx + v1]));</a>
<a name="ln1109"> </a>
<a name="ln1110">            tempv = LC2VFU(hcd[indx]);</a>
<a name="ln1111">            vfloat lavev = tempv + vaddc2vfu(hcd[indx - 3]) + LC2VFU(hcd[indx - 1]);</a>
<a name="ln1112">            vfloat ravev = tempv + vaddc2vfu(hcd[indx + 1]) + LC2VFU(hcd[indx + 3]);</a>
<a name="ln1113"> </a>
<a name="ln1114">            vfloat Dgrbhvarlv = SQRV(tempv - lavev) + SQRV(LC2VFU(hcd[indx - 1]) - lavev)</a>
<a name="ln1115">                                + SQRV(LC2VFU(hcd[indx - 2]) - lavev) + SQRV(LC2VFU(hcd[indx - 3]) - lavev);</a>
<a name="ln1116">            vfloat Dgrbhvarrv = SQRV(tempv - ravev) + SQRV(LC2VFU(hcd[indx + 1]) - ravev)</a>
<a name="ln1117">                                + SQRV(LC2VFU(hcd[indx + 2]) - ravev) + SQRV(LC2VFU(hcd[indx + 3]) - ravev);</a>
<a name="ln1118"> </a>
<a name="ln1119"> </a>
<a name="ln1120">            vfloat vcdvarv = epssqv + vintpf(vwtv, Dgrbvvardv, Dgrbvvaruv);</a>
<a name="ln1121">            vfloat hcdvarv = epssqv + vintpf(hwtv, Dgrbhvarrv, Dgrbhvarlv);</a>
<a name="ln1122"> </a>
<a name="ln1123">            // compute fluctuations in up/down and left/right interpolations of colours</a>
<a name="ln1124">            Dgrbvvaruv = LC2VFU(dgintv[indx - v1]) + LC2VFU(dgintv[indx - v2]);</a>
<a name="ln1125">            Dgrbvvardv = LC2VFU(dgintv[indx + v1]) + LC2VFU(dgintv[indx + v2]);</a>
<a name="ln1126"> </a>
<a name="ln1127">            Dgrbhvarlv = vaddc2vfu(dginth[indx - 2]);</a>
<a name="ln1128">            Dgrbhvarrv = vaddc2vfu(dginth[indx + 1]);</a>
<a name="ln1129"> </a>
<a name="ln1130">            vfloat vcdvar1v = epssqv + LC2VFU(dgintv[indx]) + vintpf(vwtv, Dgrbvvardv, Dgrbvvaruv);</a>
<a name="ln1131">            vfloat hcdvar1v = epssqv + LC2VFU(dginth[indx]) + vintpf(hwtv, Dgrbhvarrv, Dgrbhvarlv);</a>
<a name="ln1132"> </a>
<a name="ln1133">            // determine adaptive weights for G interpolation</a>
<a name="ln1134">            vfloat varwtv = hcdvarv / (vcdvarv + hcdvarv);</a>
<a name="ln1135">            vfloat diffwtv = hcdvar1v / (vcdvar1v + hcdvar1v);</a>
<a name="ln1136"> </a>
<a name="ln1137">            // if both agree on interpolation direction, choose the one with strongest directional</a>
<a name="ln1138">            // discrimination;</a>
<a name="ln1139">            // otherwise, choose the u/d and l/r difference fluctuation weights</a>
<a name="ln1140">            vmask decmask = vandm(vmaskf_gt((zd5v - varwtv) * (zd5v - diffwtv), ZEROV),</a>
<a name="ln1141">                                  vmaskf_lt(vabsf(zd5v - diffwtv), vabsf(zd5v - varwtv)));</a>
<a name="ln1142">            STVFU(hvwt[indx &gt;&gt; 1], vself(decmask, varwtv, diffwtv));</a>
<a name="ln1143">          }</a>
<a name="ln1144">        }</a>
<a name="ln1145"> </a>
<a name="ln1146">#else</a>
<a name="ln1147"> </a>
<a name="ln1148">        for(int rr = 6; rr &lt; rr1 - 6; rr++)</a>
<a name="ln1149">        {</a>
<a name="ln1150">          for(int cc = 6 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc; cc &lt; cc1 - 6; cc += 2, indx += 2)</a>
<a name="ln1151">          {</a>
<a name="ln1152"> </a>
<a name="ln1153">            // compute colour difference variances in cardinal directions</a>
<a name="ln1154"> </a>
<a name="ln1155">            float uave = vcd[indx] + vcd[indx - v1] + vcd[indx - v2] + vcd[indx - v3];</a>
<a name="ln1156">            float dave = vcd[indx] + vcd[indx + v1] + vcd[indx + v2] + vcd[indx + v3];</a>
<a name="ln1157">            float lave = hcd[indx] + hcd[indx - 1] + hcd[indx - 2] + hcd[indx - 3];</a>
<a name="ln1158">            float rave = hcd[indx] + hcd[indx + 1] + hcd[indx + 2] + hcd[indx + 3];</a>
<a name="ln1159"> </a>
<a name="ln1160">            // colour difference (G-R or G-B) variance in up/down/left/right directions</a>
<a name="ln1161">            float Dgrbvvaru = SQR(vcd[indx] - uave) + SQR(vcd[indx - v1] - uave) + SQR(vcd[indx - v2] - uave)</a>
<a name="ln1162">                              + SQR(vcd[indx - v3] - uave);</a>
<a name="ln1163">            float Dgrbvvard = SQR(vcd[indx] - dave) + SQR(vcd[indx + v1] - dave) + SQR(vcd[indx + v2] - dave)</a>
<a name="ln1164">                              + SQR(vcd[indx + v3] - dave);</a>
<a name="ln1165">            float Dgrbhvarl = SQR(hcd[indx] - lave) + SQR(hcd[indx - 1] - lave) + SQR(hcd[indx - 2] - lave)</a>
<a name="ln1166">                              + SQR(hcd[indx - 3] - lave);</a>
<a name="ln1167">            float Dgrbhvarr = SQR(hcd[indx] - rave) + SQR(hcd[indx + 1] - rave) + SQR(hcd[indx + 2] - rave)</a>
<a name="ln1168">                              + SQR(hcd[indx + 3] - rave);</a>
<a name="ln1169"> </a>
<a name="ln1170">            float hwt = dirwts1[indx - 1] / (dirwts1[indx - 1] + dirwts1[indx + 1]);</a>
<a name="ln1171">            float vwt = dirwts0[indx - v1] / (dirwts0[indx + v1] + dirwts0[indx - v1]);</a>
<a name="ln1172"> </a>
<a name="ln1173">            float vcdvar = epssq + vwt * Dgrbvvard + (1.f - vwt) * Dgrbvvaru;</a>
<a name="ln1174">            float hcdvar = epssq + hwt * Dgrbhvarr + (1.f - hwt) * Dgrbhvarl;</a>
<a name="ln1175"> </a>
<a name="ln1176">            // compute fluctuations in up/down and left/right interpolations of colours</a>
<a name="ln1177">            Dgrbvvaru = (dgintv[indx]) + (dgintv[indx - v1]) + (dgintv[indx - v2]);</a>
<a name="ln1178">            Dgrbvvard = (dgintv[indx]) + (dgintv[indx + v1]) + (dgintv[indx + v2]);</a>
<a name="ln1179">            Dgrbhvarl = (dginth[indx]) + (dginth[indx - 1]) + (dginth[indx - 2]);</a>
<a name="ln1180">            Dgrbhvarr = (dginth[indx]) + (dginth[indx + 1]) + (dginth[indx + 2]);</a>
<a name="ln1181"> </a>
<a name="ln1182">            float vcdvar1 = epssq + vwt * Dgrbvvard + (1.f - vwt) * Dgrbvvaru;</a>
<a name="ln1183">            float hcdvar1 = epssq + hwt * Dgrbhvarr + (1.f - hwt) * Dgrbhvarl;</a>
<a name="ln1184"> </a>
<a name="ln1185">            // determine adaptive weights for G interpolation</a>
<a name="ln1186">            float varwt = hcdvar / (vcdvar + hcdvar);</a>
<a name="ln1187">            float diffwt = hcdvar1 / (vcdvar1 + hcdvar1);</a>
<a name="ln1188"> </a>
<a name="ln1189">            // if both agree on interpolation direction, choose the one with strongest directional</a>
<a name="ln1190">            // discrimination;</a>
<a name="ln1191">            // otherwise, choose the u/d and l/r difference fluctuation weights</a>
<a name="ln1192">            if((0.5 - varwt) * (0.5 - diffwt) &gt; 0 &amp;&amp; fabsf(0.5f - diffwt) &lt; fabsf(0.5f - varwt))</a>
<a name="ln1193">            {</a>
<a name="ln1194">              hvwt[indx &gt;&gt; 1] = varwt;</a>
<a name="ln1195">            }</a>
<a name="ln1196">            else</a>
<a name="ln1197">            {</a>
<a name="ln1198">              hvwt[indx &gt;&gt; 1] = diffwt;</a>
<a name="ln1199">            }</a>
<a name="ln1200">          }</a>
<a name="ln1201">        }</a>
<a name="ln1202"> </a>
<a name="ln1203">#endif</a>
<a name="ln1204"> </a>
<a name="ln1205">#ifdef __SSE2__</a>
<a name="ln1206">        vfloat gaussg0 = F2V(gaussgrad[0]);</a>
<a name="ln1207">        vfloat gaussg1 = F2V(gaussgrad[1]);</a>
<a name="ln1208">        vfloat gaussg2 = F2V(gaussgrad[2]);</a>
<a name="ln1209">        vfloat gaussg3 = F2V(gaussgrad[3]);</a>
<a name="ln1210">        vfloat gaussg4 = F2V(gaussgrad[4]);</a>
<a name="ln1211">        vfloat gaussg5 = F2V(gaussgrad[5]);</a>
<a name="ln1212">        vfloat gausso0 = F2V(gaussodd[0]);</a>
<a name="ln1213">        vfloat gausso1 = F2V(gaussodd[1]);</a>
<a name="ln1214">        vfloat gausso2 = F2V(gaussodd[2]);</a>
<a name="ln1215">        vfloat gausso3 = F2V(gaussodd[3]);</a>
<a name="ln1216"> </a>
<a name="ln1217">#endif</a>
<a name="ln1218"> </a>
<a name="ln1219">        // precompute nyquist</a>
<a name="ln1220">        for(int rr = 6; rr &lt; rr1 - 6; rr++)</a>
<a name="ln1221">        {</a>
<a name="ln1222">          int cc = 6 + (FC(rr, 2, filters) &amp; 1);</a>
<a name="ln1223">          int indx = rr * ts + cc;</a>
<a name="ln1224"> </a>
<a name="ln1225">#ifdef __SSE2__</a>
<a name="ln1226"> </a>
<a name="ln1227">          for(; cc &lt; cc1 - 7; cc += 8, indx += 8)</a>
<a name="ln1228">          {</a>
<a name="ln1229">            vfloat valv</a>
<a name="ln1230">                = (gausso0 * LC2VFU(cddiffsq[indx])</a>
<a name="ln1231">                   + gausso1 * (LC2VFU(cddiffsq[(indx - m1)]) + LC2VFU(cddiffsq[(indx + p1)])</a>
<a name="ln1232">                                + LC2VFU(cddiffsq[(indx - p1)]) + LC2VFU(cddiffsq[(indx + m1)]))</a>
<a name="ln1233">                   + gausso2 * (LC2VFU(cddiffsq[(indx - v2)]) + LC2VFU(cddiffsq[(indx - 2)])</a>
<a name="ln1234">                                + LC2VFU(cddiffsq[(indx + 2)]) + LC2VFU(cddiffsq[(indx + v2)]))</a>
<a name="ln1235">                   + gausso3 * (LC2VFU(cddiffsq[(indx - m2)]) + LC2VFU(cddiffsq[(indx + p2)])</a>
<a name="ln1236">                                + LC2VFU(cddiffsq[(indx - p2)]) + LC2VFU(cddiffsq[(indx + m2)])))</a>
<a name="ln1237">                  - (gaussg0 * LC2VFU(delhvsqsum[indx])</a>
<a name="ln1238">                     + gaussg1 * (LC2VFU(delhvsqsum[indx - v1]) + LC2VFU(delhvsqsum[indx - 1])</a>
<a name="ln1239">                                  + LC2VFU(delhvsqsum[indx + 1]) + LC2VFU(delhvsqsum[indx + v1]))</a>
<a name="ln1240">                     + gaussg2 * (LC2VFU(delhvsqsum[indx - m1]) + LC2VFU(delhvsqsum[indx + p1])</a>
<a name="ln1241">                                  + LC2VFU(delhvsqsum[indx - p1]) + LC2VFU(delhvsqsum[indx + m1]))</a>
<a name="ln1242">                     + gaussg3 * (LC2VFU(delhvsqsum[indx - v2]) + LC2VFU(delhvsqsum[indx - 2])</a>
<a name="ln1243">                                  + LC2VFU(delhvsqsum[indx + 2]) + LC2VFU(delhvsqsum[indx + v2]))</a>
<a name="ln1244">                     + gaussg4 * (LC2VFU(delhvsqsum[indx - v2 - 1]) + LC2VFU(delhvsqsum[indx - v2 + 1])</a>
<a name="ln1245">                                  + LC2VFU(delhvsqsum[indx - ts - 2]) + LC2VFU(delhvsqsum[indx - ts + 2])</a>
<a name="ln1246">                                  + LC2VFU(delhvsqsum[indx + ts - 2]) + LC2VFU(delhvsqsum[indx + ts + 2])</a>
<a name="ln1247">                                  + LC2VFU(delhvsqsum[indx + v2 - 1]) + LC2VFU(delhvsqsum[indx + v2 + 1]))</a>
<a name="ln1248">                     + gaussg5 * (LC2VFU(delhvsqsum[indx - m2]) + LC2VFU(delhvsqsum[indx + p2])</a>
<a name="ln1249">                                  + LC2VFU(delhvsqsum[indx - p2]) + LC2VFU(delhvsqsum[indx + m2])));</a>
<a name="ln1250">            STVFU(nyqutest[indx &gt;&gt; 1], valv);</a>
<a name="ln1251">          }</a>
<a name="ln1252"> </a>
<a name="ln1253">#endif</a>
<a name="ln1254"> </a>
<a name="ln1255">          for(; cc &lt; cc1 - 6; cc += 2, indx += 2)</a>
<a name="ln1256">          {</a>
<a name="ln1257">            nyqutest[indx &gt;&gt; 1]</a>
<a name="ln1258">                = (gaussodd[0] * cddiffsq[indx]</a>
<a name="ln1259">                   + gaussodd[1] * (cddiffsq[(indx - m1)] + cddiffsq[(indx + p1)] + cddiffsq[(indx - p1)]</a>
<a name="ln1260">                                    + cddiffsq[(indx + m1)])</a>
<a name="ln1261">                   + gaussodd[2] * (cddiffsq[(indx - v2)] + cddiffsq[(indx - 2)] + cddiffsq[(indx + 2)]</a>
<a name="ln1262">                                    + cddiffsq[(indx + v2)])</a>
<a name="ln1263">                   + gaussodd[3] * (cddiffsq[(indx - m2)] + cddiffsq[(indx + p2)] + cddiffsq[(indx - p2)]</a>
<a name="ln1264">                                    + cddiffsq[(indx + m2)]))</a>
<a name="ln1265">                  - (gaussgrad[0] * delhvsqsum[indx]</a>
<a name="ln1266">                     + gaussgrad[1] * (delhvsqsum[indx - v1] + delhvsqsum[indx + 1] + delhvsqsum[indx - 1]</a>
<a name="ln1267">                                       + delhvsqsum[indx + v1])</a>
<a name="ln1268">                     + gaussgrad[2] * (delhvsqsum[indx - m1] + delhvsqsum[indx + p1] + delhvsqsum[indx - p1]</a>
<a name="ln1269">                                       + delhvsqsum[indx + m1])</a>
<a name="ln1270">                     + gaussgrad[3] * (delhvsqsum[indx - v2] + delhvsqsum[indx - 2] + delhvsqsum[indx + 2]</a>
<a name="ln1271">                                       + delhvsqsum[indx + v2])</a>
<a name="ln1272">                     + gaussgrad[4] * (delhvsqsum[indx - v2 - 1] + delhvsqsum[indx - v2 + 1]</a>
<a name="ln1273">                                       + delhvsqsum[indx - ts - 2] + delhvsqsum[indx - ts + 2]</a>
<a name="ln1274">                                       + delhvsqsum[indx + ts - 2] + delhvsqsum[indx + ts + 2]</a>
<a name="ln1275">                                       + delhvsqsum[indx + v2 - 1] + delhvsqsum[indx + v2 + 1])</a>
<a name="ln1276">                     + gaussgrad[5] * (delhvsqsum[indx - m2] + delhvsqsum[indx + p2] + delhvsqsum[indx - p2]</a>
<a name="ln1277">                                       + delhvsqsum[indx + m2]));</a>
<a name="ln1278">          }</a>
<a name="ln1279">        }</a>
<a name="ln1280"> </a>
<a name="ln1281">        // Nyquist test</a>
<a name="ln1282">        int nystartrow = 0;</a>
<a name="ln1283">        int nyendrow = 0;</a>
<a name="ln1284">        int nystartcol = ts + 1;</a>
<a name="ln1285">        int nyendcol = 0;</a>
<a name="ln1286"> </a>
<a name="ln1287">        for(int rr = 6; rr &lt; rr1 - 6; rr++)</a>
<a name="ln1288">        {</a>
<a name="ln1289">          for(int cc = 6 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc; cc &lt; cc1 - 6; cc += 2, indx += 2)</a>
<a name="ln1290">          {</a>
<a name="ln1291"> </a>
<a name="ln1292">            // nyquist texture test: ask if difference of vcd compared to hcd is larger or smaller than RGGB</a>
<a name="ln1293">            // gradients</a>
<a name="ln1294">            if(nyqutest[indx &gt;&gt; 1] &gt; 0.f)</a>
<a name="ln1295">            {</a>
<a name="ln1296">              nyquist[indx &gt;&gt; 1] = 1; // nyquist=1 for nyquist region</a>
<a name="ln1297">              nystartrow = nystartrow ? nystartrow : rr;</a>
<a name="ln1298">              nyendrow = rr;</a>
<a name="ln1299">              nystartcol = nystartcol &gt; cc ? cc : nystartcol;</a>
<a name="ln1300">              nyendcol = nyendcol &lt; cc ? cc : nyendcol;</a>
<a name="ln1301">            }</a>
<a name="ln1302">          }</a>
<a name="ln1303">        }</a>
<a name="ln1304"> </a>
<a name="ln1305"> </a>
<a name="ln1306">        bool doNyquist = nystartrow != nyendrow &amp;&amp; nystartcol != nyendcol;</a>
<a name="ln1307"> </a>
<a name="ln1308">        if(doNyquist)</a>
<a name="ln1309">        {</a>
<a name="ln1310">          nyendrow++; // because of &lt; condition</a>
<a name="ln1311">          nyendcol++; // because of &lt; condition</a>
<a name="ln1312">          nystartcol -= (nystartcol &amp; 1);</a>
<a name="ln1313">          nystartrow = std::max(8, nystartrow);</a>
<a name="ln1314">          nyendrow = std::min(rr1 - 8, nyendrow);</a>
<a name="ln1315">          nystartcol = std::max(8, nystartcol);</a>
<a name="ln1316">          nyendcol = std::min(cc1 - 8, nyendcol);</a>
<a name="ln1317">          memset(&amp;nyquist2[4 * tsh], 0, sizeof(char) * (ts - 8) * tsh);</a>
<a name="ln1318"> </a>
<a name="ln1319">#ifdef __SSE2__</a>
<a name="ln1320">          vint fourvb = _mm_set1_epi8(4);</a>
<a name="ln1321">          vint onevb = _mm_set1_epi8(1);</a>
<a name="ln1322"> </a>
<a name="ln1323">#endif</a>
<a name="ln1324"> </a>
<a name="ln1325">          for(int rr = nystartrow; rr &lt; nyendrow; rr++)</a>
<a name="ln1326">          {</a>
<a name="ln1327">#ifdef __SSE2__</a>
<a name="ln1328"> </a>
<a name="ln1329">            for(int indx = rr * ts; indx &lt; rr * ts + cc1; indx += 32)</a>
<a name="ln1330">            {</a>
<a name="ln1331">              vint nyquisttemp1v = _mm_adds_epi8(_mm_load_si128((vint *)&amp;nyquist[(indx - v2) &gt;&gt; 1]),</a>
<a name="ln1332">                                                 _mm_loadu_si128((vint *)&amp;nyquist[(indx - m1) &gt;&gt; 1]));</a>
<a name="ln1333">              vint nyquisttemp2v = _mm_adds_epi8(_mm_loadu_si128((vint *)&amp;nyquist[(indx + p1) &gt;&gt; 1]),</a>
<a name="ln1334">                                                 _mm_loadu_si128((vint *)&amp;nyquist[(indx - 2) &gt;&gt; 1]));</a>
<a name="ln1335">              vint nyquisttemp3v = _mm_adds_epi8(_mm_loadu_si128((vint *)&amp;nyquist[(indx + 2) &gt;&gt; 1]),</a>
<a name="ln1336">                                                 _mm_loadu_si128((vint *)&amp;nyquist[(indx - p1) &gt;&gt; 1]));</a>
<a name="ln1337">              vint valv = _mm_load_si128((vint *)&amp;nyquist[indx &gt;&gt; 1]);</a>
<a name="ln1338">              vint nyquisttemp4v = _mm_adds_epi8(_mm_loadu_si128((vint *)&amp;nyquist[(indx + m1) &gt;&gt; 1]),</a>
<a name="ln1339">                                                 _mm_load_si128((vint *)&amp;nyquist[(indx + v2) &gt;&gt; 1]));</a>
<a name="ln1340">              nyquisttemp1v = _mm_adds_epi8(nyquisttemp1v, nyquisttemp3v);</a>
<a name="ln1341">              nyquisttemp2v = _mm_adds_epi8(nyquisttemp2v, nyquisttemp4v);</a>
<a name="ln1342">              nyquisttemp1v = _mm_adds_epi8(nyquisttemp1v, nyquisttemp2v);</a>
<a name="ln1343">              valv = vselc(_mm_cmpgt_epi8(nyquisttemp1v, fourvb), onevb, valv);</a>
<a name="ln1344">              valv = vselinotzero(_mm_cmplt_epi8(nyquisttemp1v, fourvb), valv);</a>
<a name="ln1345">              _mm_store_si128((vint *)&amp;nyquist2[indx &gt;&gt; 1], valv);</a>
<a name="ln1346">            }</a>
<a name="ln1347"> </a>
<a name="ln1348">#else</a>
<a name="ln1349"> </a>
<a name="ln1350">            for(int indx = rr * ts + nystartcol + (FC(rr, 2, filters) &amp; 1); indx &lt; rr * ts + nyendcol;</a>
<a name="ln1351">                indx += 2)</a>
<a name="ln1352">            {</a>
<a name="ln1353">              unsigned int nyquisttemp</a>
<a name="ln1354">                  = (nyquist[(indx - v2) &gt;&gt; 1] + nyquist[(indx - m1) &gt;&gt; 1] + nyquist[(indx + p1) &gt;&gt; 1]</a>
<a name="ln1355">                     + nyquist[(indx - 2) &gt;&gt; 1] + nyquist[(indx + 2) &gt;&gt; 1] + nyquist[(indx - p1) &gt;&gt; 1]</a>
<a name="ln1356">                     + nyquist[(indx + m1) &gt;&gt; 1] + nyquist[(indx + v2) &gt;&gt; 1]);</a>
<a name="ln1357">              // if most of your neighbours are named Nyquist, it's likely that you're one too, or not</a>
<a name="ln1358">              nyquist2[indx &gt;&gt; 1] = nyquisttemp &gt; 4 ? 1 : (nyquisttemp &lt; 4 ? 0 : nyquist[indx &gt;&gt; 1]);</a>
<a name="ln1359">            }</a>
<a name="ln1360"> </a>
<a name="ln1361">#endif</a>
<a name="ln1362">          }</a>
<a name="ln1363"> </a>
<a name="ln1364">          // end of Nyquist test</a>
<a name="ln1365"> </a>
<a name="ln1366">          // in areas of Nyquist texture, do area interpolation</a>
<a name="ln1367">          for(int rr = nystartrow; rr &lt; nyendrow; rr++)</a>
<a name="ln1368">            for(int indx = rr * ts + nystartcol + (FC(rr, 2, filters) &amp; 1); indx &lt; rr * ts + nyendcol;</a>
<a name="ln1369">                indx += 2)</a>
<a name="ln1370">            {</a>
<a name="ln1371"> </a>
<a name="ln1372">              if(nyquist2[indx &gt;&gt; 1])</a>
<a name="ln1373">              {</a>
<a name="ln1374">                // area interpolation</a>
<a name="ln1375"> </a>
<a name="ln1376">                float sumcfa = 0.f, sumh = 0.f, sumv = 0.f, sumsqh = 0.f, sumsqv = 0.f, areawt = 0.f;</a>
<a name="ln1377"> </a>
<a name="ln1378">                for(int i = -6; i &lt; 7; i += 2)</a>
<a name="ln1379">                {</a>
<a name="ln1380">                  int indx1 = indx + (i * ts) - 6;</a>
<a name="ln1381"> </a>
<a name="ln1382">                  for(int j = -6; j &lt; 7; j += 2, indx1 += 2)</a>
<a name="ln1383">                  {</a>
<a name="ln1384">                    if(nyquist2[indx1 &gt;&gt; 1])</a>
<a name="ln1385">                    {</a>
<a name="ln1386">                      float cfatemp = cfa[indx1];</a>
<a name="ln1387">                      sumcfa += cfatemp;</a>
<a name="ln1388">                      sumh += (cfa[indx1 - 1] + cfa[indx1 + 1]);</a>
<a name="ln1389">                      sumv += (cfa[indx1 - v1] + cfa[indx1 + v1]);</a>
<a name="ln1390">                      sumsqh += SQR(cfatemp - cfa[indx1 - 1]) + SQR(cfatemp - cfa[indx1 + 1]);</a>
<a name="ln1391">                      sumsqv += SQR(cfatemp - cfa[indx1 - v1]) + SQR(cfatemp - cfa[indx1 + v1]);</a>
<a name="ln1392">                      areawt += 1;</a>
<a name="ln1393">                    }</a>
<a name="ln1394">                  }</a>
<a name="ln1395">                }</a>
<a name="ln1396"> </a>
<a name="ln1397">                // horizontal and vertical colour differences, and adaptive weight</a>
<a name="ln1398">                sumh = sumcfa - xdiv2f(sumh);</a>
<a name="ln1399">                sumv = sumcfa - xdiv2f(sumv);</a>
<a name="ln1400">                areawt = xdiv2f(areawt);</a>
<a name="ln1401">                float hcdvar = epssq + fabsf(areawt * sumsqh - sumh * sumh);</a>
<a name="ln1402">                float vcdvar = epssq + fabsf(areawt * sumsqv - sumv * sumv);</a>
<a name="ln1403">                hvwt[indx &gt;&gt; 1] = hcdvar / (vcdvar + hcdvar);</a>
<a name="ln1404"> </a>
<a name="ln1405">                // end of area interpolation</a>
<a name="ln1406">              }</a>
<a name="ln1407">            }</a>
<a name="ln1408">        }</a>
<a name="ln1409"> </a>
<a name="ln1410"> </a>
<a name="ln1411">        // populate G at R/B sites</a>
<a name="ln1412">        for(int rr = 8; rr &lt; rr1 - 8; rr++)</a>
<a name="ln1413">          for(int indx = rr * ts + 8 + (FC(rr, 2, filters) &amp; 1); indx &lt; rr * ts + cc1 - 8; indx += 2)</a>
<a name="ln1414">          {</a>
<a name="ln1415"> </a>
<a name="ln1416">            // first ask if one gets more directional discrimination from nearby B/R sites</a>
<a name="ln1417">            float hvwtalt = xdivf(hvwt[(indx - m1) &gt;&gt; 1] + hvwt[(indx + p1) &gt;&gt; 1] + hvwt[(indx - p1) &gt;&gt; 1]</a>
<a name="ln1418">                                      + hvwt[(indx + m1) &gt;&gt; 1],</a>
<a name="ln1419">                                  2);</a>
<a name="ln1420"> </a>
<a name="ln1421">            hvwt[indx &gt;&gt; 1]</a>
<a name="ln1422">                = fabsf(0.5f - hvwt[indx &gt;&gt; 1]) &lt; fabsf(0.5f - hvwtalt) ? hvwtalt : hvwt[indx &gt;&gt; 1];</a>
<a name="ln1423">            // a better result was obtained from the neighbours</a>
<a name="ln1424"> </a>
<a name="ln1425">            Dgrb[0][indx &gt;&gt; 1] = intp(hvwt[indx &gt;&gt; 1], vcd[indx], hcd[indx]); // evaluate colour differences</a>
<a name="ln1426"> </a>
<a name="ln1427">            rgbgreen[indx] = cfa[indx] + Dgrb[0][indx &gt;&gt; 1]; // evaluate G (finally!)</a>
<a name="ln1428"> </a>
<a name="ln1429">            // local curvature in G (preparation for nyquist refinement step)</a>
<a name="ln1430">            Dgrb2[indx &gt;&gt; 1].h = nyquist2[indx &gt;&gt; 1]</a>
<a name="ln1431">                                     ? SQR(rgbgreen[indx] - xdiv2f(rgbgreen[indx - 1] + rgbgreen[indx + 1]))</a>
<a name="ln1432">                                     : 0.f;</a>
<a name="ln1433">            Dgrb2[indx &gt;&gt; 1].v = nyquist2[indx &gt;&gt; 1]</a>
<a name="ln1434">                                     ? SQR(rgbgreen[indx] - xdiv2f(rgbgreen[indx - v1] + rgbgreen[indx + v1]))</a>
<a name="ln1435">                                     : 0.f;</a>
<a name="ln1436">          }</a>
<a name="ln1437"> </a>
<a name="ln1438"> </a>
<a name="ln1439">        // end of standard interpolation</a>
<a name="ln1440"> </a>
<a name="ln1441">        // refine Nyquist areas using G curvatures</a>
<a name="ln1442">        if(doNyquist)</a>
<a name="ln1443">        {</a>
<a name="ln1444">          for(int rr = nystartrow; rr &lt; nyendrow; rr++)</a>
<a name="ln1445">            for(int indx = rr * ts + nystartcol + (FC(rr, 2, filters) &amp; 1); indx &lt; rr * ts + nyendcol;</a>
<a name="ln1446">                indx += 2)</a>
<a name="ln1447">            {</a>
<a name="ln1448"> </a>
<a name="ln1449">              if(nyquist2[indx &gt;&gt; 1])</a>
<a name="ln1450">              {</a>
<a name="ln1451">                // local averages (over Nyquist pixels only) of G curvature squared</a>
<a name="ln1452">                float gvarh</a>
<a name="ln1453">                    = epssq + (gquinc[0] * Dgrb2[indx &gt;&gt; 1].h</a>
<a name="ln1454">                               + gquinc[1] * (Dgrb2[(indx - m1) &gt;&gt; 1].h + Dgrb2[(indx + p1) &gt;&gt; 1].h</a>
<a name="ln1455">                                              + Dgrb2[(indx - p1) &gt;&gt; 1].h + Dgrb2[(indx + m1) &gt;&gt; 1].h)</a>
<a name="ln1456">                               + gquinc[2] * (Dgrb2[(indx - v2) &gt;&gt; 1].h + Dgrb2[(indx - 2) &gt;&gt; 1].h</a>
<a name="ln1457">                                              + Dgrb2[(indx + 2) &gt;&gt; 1].h + Dgrb2[(indx + v2) &gt;&gt; 1].h)</a>
<a name="ln1458">                               + gquinc[3] * (Dgrb2[(indx - m2) &gt;&gt; 1].h + Dgrb2[(indx + p2) &gt;&gt; 1].h</a>
<a name="ln1459">                                              + Dgrb2[(indx - p2) &gt;&gt; 1].h + Dgrb2[(indx + m2) &gt;&gt; 1].h));</a>
<a name="ln1460">                float gvarv</a>
<a name="ln1461">                    = epssq + (gquinc[0] * Dgrb2[indx &gt;&gt; 1].v</a>
<a name="ln1462">                               + gquinc[1] * (Dgrb2[(indx - m1) &gt;&gt; 1].v + Dgrb2[(indx + p1) &gt;&gt; 1].v</a>
<a name="ln1463">                                              + Dgrb2[(indx - p1) &gt;&gt; 1].v + Dgrb2[(indx + m1) &gt;&gt; 1].v)</a>
<a name="ln1464">                               + gquinc[2] * (Dgrb2[(indx - v2) &gt;&gt; 1].v + Dgrb2[(indx - 2) &gt;&gt; 1].v</a>
<a name="ln1465">                                              + Dgrb2[(indx + 2) &gt;&gt; 1].v + Dgrb2[(indx + v2) &gt;&gt; 1].v)</a>
<a name="ln1466">                               + gquinc[3] * (Dgrb2[(indx - m2) &gt;&gt; 1].v + Dgrb2[(indx + p2) &gt;&gt; 1].v</a>
<a name="ln1467">                                              + Dgrb2[(indx - p2) &gt;&gt; 1].v + Dgrb2[(indx + m2) &gt;&gt; 1].v));</a>
<a name="ln1468">                // use the results as weights for refined G interpolation</a>
<a name="ln1469">                Dgrb[0][indx &gt;&gt; 1] = (hcd[indx] * gvarv + vcd[indx] * gvarh) / (gvarv + gvarh);</a>
<a name="ln1470">                rgbgreen[indx] = cfa[indx] + Dgrb[0][indx &gt;&gt; 1];</a>
<a name="ln1471">              }</a>
<a name="ln1472">            }</a>
<a name="ln1473">        }</a>
<a name="ln1474"> </a>
<a name="ln1475"> </a>
<a name="ln1476">#ifdef __SSE2__</a>
<a name="ln1477"> </a>
<a name="ln1478">        for(int rr = 6; rr &lt; rr1 - 6; rr++)</a>
<a name="ln1479">        {</a>
<a name="ln1480">          if((FC(rr, 2, filters) &amp; 1) == 0)</a>
<a name="ln1481">          {</a>
<a name="ln1482">            for(int cc = 6, indx = rr * ts + cc; cc &lt; cc1 - 6; cc += 8, indx += 8)</a>
<a name="ln1483">            {</a>
<a name="ln1484">              vfloat tempv = LC2VFU(cfa[indx + 1]);</a>
<a name="ln1485">              vfloat Dgrbsq1pv</a>
<a name="ln1486">                  = (SQRV(tempv - LC2VFU(cfa[indx + 1 - p1])) + SQRV(tempv - LC2VFU(cfa[indx + 1 + p1])));</a>
<a name="ln1487">              STVFU(delp[indx &gt;&gt; 1], vabsf(LC2VFU(cfa[indx + p1]) - LC2VFU(cfa[indx - p1])));</a>
<a name="ln1488">              STVFU(delm[indx &gt;&gt; 1], vabsf(LC2VFU(cfa[indx + m1]) - LC2VFU(cfa[indx - m1])));</a>
<a name="ln1489">              vfloat Dgrbsq1mv</a>
<a name="ln1490">                  = (SQRV(tempv - LC2VFU(cfa[indx + 1 - m1])) + SQRV(tempv - LC2VFU(cfa[indx + 1 + m1])));</a>
<a name="ln1491">              STVFU(Dgrbsq1m[indx &gt;&gt; 1], Dgrbsq1mv);</a>
<a name="ln1492">              STVFU(Dgrbsq1p[indx &gt;&gt; 1], Dgrbsq1pv);</a>
<a name="ln1493">            }</a>
<a name="ln1494">          }</a>
<a name="ln1495">          else</a>
<a name="ln1496">          {</a>
<a name="ln1497">            for(int cc = 6, indx = rr * ts + cc; cc &lt; cc1 - 6; cc += 8, indx += 8)</a>
<a name="ln1498">            {</a>
<a name="ln1499">              vfloat tempv = LC2VFU(cfa[indx]);</a>
<a name="ln1500">              vfloat Dgrbsq1pv</a>
<a name="ln1501">                  = (SQRV(tempv - LC2VFU(cfa[indx - p1])) + SQRV(tempv - LC2VFU(cfa[indx + p1])));</a>
<a name="ln1502">              STVFU(delp[indx &gt;&gt; 1], vabsf(LC2VFU(cfa[indx + 1 + p1]) - LC2VFU(cfa[indx + 1 - p1])));</a>
<a name="ln1503">              STVFU(delm[indx &gt;&gt; 1], vabsf(LC2VFU(cfa[indx + 1 + m1]) - LC2VFU(cfa[indx + 1 - m1])));</a>
<a name="ln1504">              vfloat Dgrbsq1mv</a>
<a name="ln1505">                  = (SQRV(tempv - LC2VFU(cfa[indx - m1])) + SQRV(tempv - LC2VFU(cfa[indx + m1])));</a>
<a name="ln1506">              STVFU(Dgrbsq1m[indx &gt;&gt; 1], Dgrbsq1mv);</a>
<a name="ln1507">              STVFU(Dgrbsq1p[indx &gt;&gt; 1], Dgrbsq1pv);</a>
<a name="ln1508">            }</a>
<a name="ln1509">          }</a>
<a name="ln1510">        }</a>
<a name="ln1511"> </a>
<a name="ln1512">#else</a>
<a name="ln1513"> </a>
<a name="ln1514">        for(int rr = 6; rr &lt; rr1 - 6; rr++)</a>
<a name="ln1515">        {</a>
<a name="ln1516">          if((FC(rr, 2, filters) &amp; 1) == 0)</a>
<a name="ln1517">          {</a>
<a name="ln1518">            for(int cc = 6, indx = rr * ts + cc; cc &lt; cc1 - 6; cc += 2, indx += 2)</a>
<a name="ln1519">            {</a>
<a name="ln1520">              delp[indx &gt;&gt; 1] = fabsf(cfa[indx + p1] - cfa[indx - p1]);</a>
<a name="ln1521">              delm[indx &gt;&gt; 1] = fabsf(cfa[indx + m1] - cfa[indx - m1]);</a>
<a name="ln1522">              Dgrbsq1p[indx &gt;&gt; 1]</a>
<a name="ln1523">                  = (SQR(cfa[indx + 1] - cfa[indx + 1 - p1]) + SQR(cfa[indx + 1] - cfa[indx + 1 + p1]));</a>
<a name="ln1524">              Dgrbsq1m[indx &gt;&gt; 1]</a>
<a name="ln1525">                  = (SQR(cfa[indx + 1] - cfa[indx + 1 - m1]) + SQR(cfa[indx + 1] - cfa[indx + 1 + m1]));</a>
<a name="ln1526">            }</a>
<a name="ln1527">          }</a>
<a name="ln1528">          else</a>
<a name="ln1529">          {</a>
<a name="ln1530">            for(int cc = 6, indx = rr * ts + cc; cc &lt; cc1 - 6; cc += 2, indx += 2)</a>
<a name="ln1531">            {</a>
<a name="ln1532">              Dgrbsq1p[indx &gt;&gt; 1] = (SQR(cfa[indx] - cfa[indx - p1]) + SQR(cfa[indx] - cfa[indx + p1]));</a>
<a name="ln1533">              Dgrbsq1m[indx &gt;&gt; 1] = (SQR(cfa[indx] - cfa[indx - m1]) + SQR(cfa[indx] - cfa[indx + m1]));</a>
<a name="ln1534">              delp[indx &gt;&gt; 1] = fabsf(cfa[indx + 1 + p1] - cfa[indx + 1 - p1]);</a>
<a name="ln1535">              delm[indx &gt;&gt; 1] = fabsf(cfa[indx + 1 + m1] - cfa[indx + 1 - m1]);</a>
<a name="ln1536">            }</a>
<a name="ln1537">          }</a>
<a name="ln1538">        }</a>
<a name="ln1539"> </a>
<a name="ln1540">#endif</a>
<a name="ln1541"> </a>
<a name="ln1542">// diagonal interpolation correction</a>
<a name="ln1543"> </a>
<a name="ln1544">#ifdef __SSE2__</a>
<a name="ln1545">        vfloat gausseven0v = F2V(gausseven[0]);</a>
<a name="ln1546">        vfloat gausseven1v = F2V(gausseven[1]);</a>
<a name="ln1547">#endif</a>
<a name="ln1548"> </a>
<a name="ln1549">        for(int rr = 8; rr &lt; rr1 - 8; rr++)</a>
<a name="ln1550">        {</a>
<a name="ln1551">#ifdef __SSE2__</a>
<a name="ln1552"> </a>
<a name="ln1553">          for(int indx = rr * ts + 8 + (FC(rr, 2, filters) &amp; 1), indx1 = indx &gt;&gt; 1; indx &lt; rr * ts + cc1 - 8;</a>
<a name="ln1554">              indx += 8, indx1 += 4)</a>
<a name="ln1555">          {</a>
<a name="ln1556"> </a>
<a name="ln1557">            // diagonal colour ratios</a>
<a name="ln1558">            vfloat cfav = LC2VFU(cfa[indx]);</a>
<a name="ln1559"> </a>
<a name="ln1560">            vfloat temp1v = LC2VFU(cfa[indx + m1]);</a>
<a name="ln1561">            vfloat temp2v = LC2VFU(cfa[indx + m2]);</a>
<a name="ln1562">            vfloat rbsev = vmul2f(temp1v) / (epsv + cfav + temp2v);</a>
<a name="ln1563">            rbsev = vself(vmaskf_lt(vabsf(onev - rbsev), arthreshv), cfav * rbsev,</a>
<a name="ln1564">                          temp1v + zd5v * (cfav - temp2v));</a>
<a name="ln1565"> </a>
<a name="ln1566">            temp1v = LC2VFU(cfa[indx - m1]);</a>
<a name="ln1567">            temp2v = LC2VFU(cfa[indx - m2]);</a>
<a name="ln1568">            vfloat rbnwv = vmul2f(temp1v) / (epsv + cfav + temp2v);</a>
<a name="ln1569">            rbnwv = vself(vmaskf_lt(vabsf(onev - rbnwv), arthreshv), cfav * rbnwv,</a>
<a name="ln1570">                          temp1v + zd5v * (cfav - temp2v));</a>
<a name="ln1571"> </a>
<a name="ln1572">            temp1v = epsv + LVFU(delm[indx1]);</a>
<a name="ln1573">            vfloat wtsev = temp1v + LVFU(delm[(indx + m1) &gt;&gt; 1])</a>
<a name="ln1574">                           + LVFU(delm[(indx + m2) &gt;&gt; 1]); // same as for wtu,wtd,wtl,wtr</a>
<a name="ln1575">            vfloat wtnwv = temp1v + LVFU(delm[(indx - m1) &gt;&gt; 1]) + LVFU(delm[(indx - m2) &gt;&gt; 1]);</a>
<a name="ln1576"> </a>
<a name="ln1577">            vfloat rbmv = (wtsev * rbnwv + wtnwv * rbsev) / (wtsev + wtnwv);</a>
<a name="ln1578"> </a>
<a name="ln1579">            temp1v = ULIMV(rbmv, LC2VFU(cfa[indx - m1]), LC2VFU(cfa[indx + m1]));</a>
<a name="ln1580">            vfloat wtv = vmul2f(cfav - rbmv) / (epsv + rbmv + cfav);</a>
<a name="ln1581">            temp2v = vintpf(wtv, rbmv, temp1v);</a>
<a name="ln1582"> </a>
<a name="ln1583">            temp2v = vself(vmaskf_lt(rbmv + rbmv, cfav), temp1v, temp2v);</a>
<a name="ln1584">            temp2v = vself(vmaskf_lt(rbmv, cfav), temp2v, rbmv);</a>
<a name="ln1585">            STVFU(rbm[indx1], vself(vmaskf_gt(temp2v, clip_ptv),</a>
<a name="ln1586">                                    ULIMV(temp2v, LC2VFU(cfa[indx - m1]), LC2VFU(cfa[indx + m1])), temp2v));</a>
<a name="ln1587"> </a>
<a name="ln1588"> </a>
<a name="ln1589">            temp1v = LC2VFU(cfa[indx + p1]);</a>
<a name="ln1590">            temp2v = LC2VFU(cfa[indx + p2]);</a>
<a name="ln1591">            vfloat rbnev = vmul2f(temp1v) / (epsv + cfav + temp2v);</a>
<a name="ln1592">            rbnev = vself(vmaskf_lt(vabsf(onev - rbnev), arthreshv), cfav * rbnev,</a>
<a name="ln1593">                          temp1v + zd5v * (cfav - temp2v));</a>
<a name="ln1594"> </a>
<a name="ln1595">            temp1v = LC2VFU(cfa[indx - p1]);</a>
<a name="ln1596">            temp2v = LC2VFU(cfa[indx - p2]);</a>
<a name="ln1597">            vfloat rbswv = vmul2f(temp1v) / (epsv + cfav + temp2v);</a>
<a name="ln1598">            rbswv = vself(vmaskf_lt(vabsf(onev - rbswv), arthreshv), cfav * rbswv,</a>
<a name="ln1599">                          temp1v + zd5v * (cfav - temp2v));</a>
<a name="ln1600"> </a>
<a name="ln1601">            temp1v = epsv + LVFU(delp[indx1]);</a>
<a name="ln1602">            vfloat wtnev = temp1v + LVFU(delp[(indx + p1) &gt;&gt; 1]) + LVFU(delp[(indx + p2) &gt;&gt; 1]);</a>
<a name="ln1603">            vfloat wtswv = temp1v + LVFU(delp[(indx - p1) &gt;&gt; 1]) + LVFU(delp[(indx - p2) &gt;&gt; 1]);</a>
<a name="ln1604"> </a>
<a name="ln1605">            vfloat rbpv = (wtnev * rbswv + wtswv * rbnev) / (wtnev + wtswv);</a>
<a name="ln1606"> </a>
<a name="ln1607">            temp1v = ULIMV(rbpv, LC2VFU(cfa[indx - p1]), LC2VFU(cfa[indx + p1]));</a>
<a name="ln1608">            wtv = vmul2f(cfav - rbpv) / (epsv + rbpv + cfav);</a>
<a name="ln1609">            temp2v = vintpf(wtv, rbpv, temp1v);</a>
<a name="ln1610"> </a>
<a name="ln1611">            temp2v = vself(vmaskf_lt(rbpv + rbpv, cfav), temp1v, temp2v);</a>
<a name="ln1612">            temp2v = vself(vmaskf_lt(rbpv, cfav), temp2v, rbpv);</a>
<a name="ln1613">            STVFU(rbp[indx1], vself(vmaskf_gt(temp2v, clip_ptv),</a>
<a name="ln1614">                                    ULIMV(temp2v, LC2VFU(cfa[indx - p1]), LC2VFU(cfa[indx + p1])), temp2v));</a>
<a name="ln1615"> </a>
<a name="ln1616">            vfloat rbvarmv</a>
<a name="ln1617">                = epssqv</a>
<a name="ln1618">                  + (gausseven0v * (LVFU(Dgrbsq1m[(indx - v1) &gt;&gt; 1]) + LVFU(Dgrbsq1m[(indx - 1) &gt;&gt; 1])</a>
<a name="ln1619">                                    + LVFU(Dgrbsq1m[(indx + 1) &gt;&gt; 1]) + LVFU(Dgrbsq1m[(indx + v1) &gt;&gt; 1]))</a>
<a name="ln1620">                     + gausseven1v</a>
<a name="ln1621">                           * (LVFU(Dgrbsq1m[(indx - v2 - 1) &gt;&gt; 1]) + LVFU(Dgrbsq1m[(indx - v2 + 1) &gt;&gt; 1])</a>
<a name="ln1622">                              + LVFU(Dgrbsq1m[(indx - 2 - v1) &gt;&gt; 1]) + LVFU(Dgrbsq1m[(indx + 2 - v1) &gt;&gt; 1])</a>
<a name="ln1623">                              + LVFU(Dgrbsq1m[(indx - 2 + v1) &gt;&gt; 1]) + LVFU(Dgrbsq1m[(indx + 2 + v1) &gt;&gt; 1])</a>
<a name="ln1624">                              + LVFU(Dgrbsq1m[(indx + v2 - 1) &gt;&gt; 1]) + LVFU(Dgrbsq1m[(indx + v2 + 1) &gt;&gt; 1])));</a>
<a name="ln1625">            STVFU(pmwt[indx1],</a>
<a name="ln1626">                  rbvarmv / ((epssqv</a>
<a name="ln1627">                              + (gausseven0v</a>
<a name="ln1628">                                     * (LVFU(Dgrbsq1p[(indx - v1) &gt;&gt; 1]) + LVFU(Dgrbsq1p[(indx - 1) &gt;&gt; 1])</a>
<a name="ln1629">                                        + LVFU(Dgrbsq1p[(indx + 1) &gt;&gt; 1]) + LVFU(Dgrbsq1p[(indx + v1) &gt;&gt; 1]))</a>
<a name="ln1630">                                 + gausseven1v * (LVFU(Dgrbsq1p[(indx - v2 - 1) &gt;&gt; 1])</a>
<a name="ln1631">                                                  + LVFU(Dgrbsq1p[(indx - v2 + 1) &gt;&gt; 1])</a>
<a name="ln1632">                                                  + LVFU(Dgrbsq1p[(indx - 2 - v1) &gt;&gt; 1])</a>
<a name="ln1633">                                                  + LVFU(Dgrbsq1p[(indx + 2 - v1) &gt;&gt; 1])</a>
<a name="ln1634">                                                  + LVFU(Dgrbsq1p[(indx - 2 + v1) &gt;&gt; 1])</a>
<a name="ln1635">                                                  + LVFU(Dgrbsq1p[(indx + 2 + v1) &gt;&gt; 1])</a>
<a name="ln1636">                                                  + LVFU(Dgrbsq1p[(indx + v2 - 1) &gt;&gt; 1])</a>
<a name="ln1637">                                                  + LVFU(Dgrbsq1p[(indx + v2 + 1) &gt;&gt; 1]))))</a>
<a name="ln1638">                             + rbvarmv));</a>
<a name="ln1639">          }</a>
<a name="ln1640"> </a>
<a name="ln1641">#else</a>
<a name="ln1642"> </a>
<a name="ln1643">          for(int cc = 8 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc, indx1 = indx &gt;&gt; 1; cc &lt; cc1 - 8;</a>
<a name="ln1644">              cc += 2, indx += 2, indx1++)</a>
<a name="ln1645">          {</a>
<a name="ln1646"> </a>
<a name="ln1647">            // diagonal colour ratios</a>
<a name="ln1648">            float crse = xmul2f(cfa[indx + m1]) / (eps + cfa[indx] + (cfa[indx + m2]));</a>
<a name="ln1649">            float crnw = xmul2f(cfa[indx - m1]) / (eps + cfa[indx] + (cfa[indx - m2]));</a>
<a name="ln1650">            float crne = xmul2f(cfa[indx + p1]) / (eps + cfa[indx] + (cfa[indx + p2]));</a>
<a name="ln1651">            float crsw = xmul2f(cfa[indx - p1]) / (eps + cfa[indx] + (cfa[indx - p2]));</a>
<a name="ln1652">            // colour differences in diagonal directions</a>
<a name="ln1653">            float rbse, rbnw, rbne, rbsw;</a>
<a name="ln1654"> </a>
<a name="ln1655">            // assign B/R at R/B sites</a>
<a name="ln1656">            if(fabsf(1.f - crse) &lt; arthresh)</a>
<a name="ln1657">            {</a>
<a name="ln1658">              rbse = cfa[indx] * crse; // use this if more precise diag interp is necessary</a>
<a name="ln1659">            }</a>
<a name="ln1660">            else</a>
<a name="ln1661">            {</a>
<a name="ln1662">              rbse = (cfa[indx + m1]) + xdiv2f(cfa[indx] - cfa[indx + m2]);</a>
<a name="ln1663">            }</a>
<a name="ln1664"> </a>
<a name="ln1665">            if(fabsf(1.f - crnw) &lt; arthresh)</a>
<a name="ln1666">            {</a>
<a name="ln1667">              rbnw = cfa[indx] * crnw;</a>
<a name="ln1668">            }</a>
<a name="ln1669">            else</a>
<a name="ln1670">            {</a>
<a name="ln1671">              rbnw = (cfa[indx - m1]) + xdiv2f(cfa[indx] - cfa[indx - m2]);</a>
<a name="ln1672">            }</a>
<a name="ln1673"> </a>
<a name="ln1674">            if(fabsf(1.f - crne) &lt; arthresh)</a>
<a name="ln1675">            {</a>
<a name="ln1676">              rbne = cfa[indx] * crne;</a>
<a name="ln1677">            }</a>
<a name="ln1678">            else</a>
<a name="ln1679">            {</a>
<a name="ln1680">              rbne = (cfa[indx + p1]) + xdiv2f(cfa[indx] - cfa[indx + p2]);</a>
<a name="ln1681">            }</a>
<a name="ln1682"> </a>
<a name="ln1683">            if(fabsf(1.f - crsw) &lt; arthresh)</a>
<a name="ln1684">            {</a>
<a name="ln1685">              rbsw = cfa[indx] * crsw;</a>
<a name="ln1686">            }</a>
<a name="ln1687">            else</a>
<a name="ln1688">            {</a>
<a name="ln1689">              rbsw = (cfa[indx - p1]) + xdiv2f(cfa[indx] - cfa[indx - p2]);</a>
<a name="ln1690">            }</a>
<a name="ln1691"> </a>
<a name="ln1692">            float wtse = eps + delm[indx1] + delm[(indx + m1) &gt;&gt; 1]</a>
<a name="ln1693">                         + delm[(indx + m2) &gt;&gt; 1]; // same as for wtu,wtd,wtl,wtr</a>
<a name="ln1694">            float wtnw = eps + delm[indx1] + delm[(indx - m1) &gt;&gt; 1] + delm[(indx - m2) &gt;&gt; 1];</a>
<a name="ln1695">            float wtne = eps + delp[indx1] + delp[(indx + p1) &gt;&gt; 1] + delp[(indx + p2) &gt;&gt; 1];</a>
<a name="ln1696">            float wtsw = eps + delp[indx1] + delp[(indx - p1) &gt;&gt; 1] + delp[(indx - p2) &gt;&gt; 1];</a>
<a name="ln1697"> </a>
<a name="ln1698"> </a>
<a name="ln1699">            rbm[indx1] = (wtse * rbnw + wtnw * rbse) / (wtse + wtnw);</a>
<a name="ln1700">            rbp[indx1] = (wtne * rbsw + wtsw * rbne) / (wtne + wtsw);</a>
<a name="ln1701"> </a>
<a name="ln1702">            // variance of R-B in plus/minus directions</a>
<a name="ln1703">            float rbvarm</a>
<a name="ln1704">                = epssq</a>
<a name="ln1705">                  + (gausseven[0] * (Dgrbsq1m[(indx - v1) &gt;&gt; 1] + Dgrbsq1m[(indx - 1) &gt;&gt; 1]</a>
<a name="ln1706">                                     + Dgrbsq1m[(indx + 1) &gt;&gt; 1] + Dgrbsq1m[(indx + v1) &gt;&gt; 1])</a>
<a name="ln1707">                     + gausseven[1] * (Dgrbsq1m[(indx - v2 - 1) &gt;&gt; 1] + Dgrbsq1m[(indx - v2 + 1) &gt;&gt; 1]</a>
<a name="ln1708">                                       + Dgrbsq1m[(indx - 2 - v1) &gt;&gt; 1] + Dgrbsq1m[(indx + 2 - v1) &gt;&gt; 1]</a>
<a name="ln1709">                                       + Dgrbsq1m[(indx - 2 + v1) &gt;&gt; 1] + Dgrbsq1m[(indx + 2 + v1) &gt;&gt; 1]</a>
<a name="ln1710">                                       + Dgrbsq1m[(indx + v2 - 1) &gt;&gt; 1] + Dgrbsq1m[(indx + v2 + 1) &gt;&gt; 1]));</a>
<a name="ln1711">            pmwt[indx1]</a>
<a name="ln1712">                = rbvarm</a>
<a name="ln1713">                  / ((epssq + (gausseven[0] * (Dgrbsq1p[(indx - v1) &gt;&gt; 1] + Dgrbsq1p[(indx - 1) &gt;&gt; 1]</a>
<a name="ln1714">                                               + Dgrbsq1p[(indx + 1) &gt;&gt; 1] + Dgrbsq1p[(indx + v1) &gt;&gt; 1])</a>
<a name="ln1715">                               + gausseven[1]</a>
<a name="ln1716">                                     * (Dgrbsq1p[(indx - v2 - 1) &gt;&gt; 1] + Dgrbsq1p[(indx - v2 + 1) &gt;&gt; 1]</a>
<a name="ln1717">                                        + Dgrbsq1p[(indx - 2 - v1) &gt;&gt; 1] + Dgrbsq1p[(indx + 2 - v1) &gt;&gt; 1]</a>
<a name="ln1718">                                        + Dgrbsq1p[(indx - 2 + v1) &gt;&gt; 1] + Dgrbsq1p[(indx + 2 + v1) &gt;&gt; 1]</a>
<a name="ln1719">                                        + Dgrbsq1p[(indx + v2 - 1) &gt;&gt; 1] + Dgrbsq1p[(indx + v2 + 1) &gt;&gt; 1])))</a>
<a name="ln1720">                     + rbvarm);</a>
<a name="ln1721"> </a>
<a name="ln1722">            // bound the interpolation in regions of high saturation</a>
<a name="ln1723"> </a>
<a name="ln1724">            if(rbp[indx1] &lt; cfa[indx])</a>
<a name="ln1725">            {</a>
<a name="ln1726">              if(xmul2f(rbp[indx1]) &lt; cfa[indx])</a>
<a name="ln1727">              {</a>
<a name="ln1728">                rbp[indx1] = ULIM(rbp[indx1], cfa[indx - p1], cfa[indx + p1]);</a>
<a name="ln1729">              }</a>
<a name="ln1730">              else</a>
<a name="ln1731">              {</a>
<a name="ln1732">                float pwt = xmul2f(cfa[indx] - rbp[indx1]) / (eps + rbp[indx1] + cfa[indx]);</a>
<a name="ln1733">                rbp[indx1]</a>
<a name="ln1734">                    = pwt * rbp[indx1] + (1.f - pwt) * ULIM(rbp[indx1], cfa[indx - p1], cfa[indx + p1]);</a>
<a name="ln1735">              }</a>
<a name="ln1736">            }</a>
<a name="ln1737"> </a>
<a name="ln1738">            if(rbm[indx1] &lt; cfa[indx])</a>
<a name="ln1739">            {</a>
<a name="ln1740">              if(xmul2f(rbm[indx1]) &lt; cfa[indx])</a>
<a name="ln1741">              {</a>
<a name="ln1742">                rbm[indx1] = ULIM(rbm[indx1], cfa[indx - m1], cfa[indx + m1]);</a>
<a name="ln1743">              }</a>
<a name="ln1744">              else</a>
<a name="ln1745">              {</a>
<a name="ln1746">                float mwt = xmul2f(cfa[indx] - rbm[indx1]) / (eps + rbm[indx1] + cfa[indx]);</a>
<a name="ln1747">                rbm[indx1]</a>
<a name="ln1748">                    = mwt * rbm[indx1] + (1.f - mwt) * ULIM(rbm[indx1], cfa[indx - m1], cfa[indx + m1]);</a>
<a name="ln1749">              }</a>
<a name="ln1750">            }</a>
<a name="ln1751"> </a>
<a name="ln1752">            if(rbp[indx1] &gt; clip_pt)</a>
<a name="ln1753">            {</a>
<a name="ln1754">              rbp[indx1] = ULIM(rbp[indx1], cfa[indx - p1], cfa[indx + p1]);</a>
<a name="ln1755">            }</a>
<a name="ln1756"> </a>
<a name="ln1757">            if(rbm[indx1] &gt; clip_pt)</a>
<a name="ln1758">            {</a>
<a name="ln1759">              rbm[indx1] = ULIM(rbm[indx1], cfa[indx - m1], cfa[indx + m1]);</a>
<a name="ln1760">            }</a>
<a name="ln1761">          }</a>
<a name="ln1762"> </a>
<a name="ln1763">#endif</a>
<a name="ln1764">        }</a>
<a name="ln1765"> </a>
<a name="ln1766">#ifdef __SSE2__</a>
<a name="ln1767">        vfloat zd25v = F2V(0.25f);</a>
<a name="ln1768">#endif</a>
<a name="ln1769"> </a>
<a name="ln1770">        for(int rr = 10; rr &lt; rr1 - 10; rr++)</a>
<a name="ln1771">#ifdef __SSE2__</a>
<a name="ln1772">          for(int indx = rr * ts + 10 + (FC(rr, 2, filters) &amp; 1), indx1 = indx &gt;&gt; 1;</a>
<a name="ln1773">              indx &lt; rr * ts + cc1 - 10; indx += 8, indx1 += 4)</a>
<a name="ln1774">          {</a>
<a name="ln1775"> </a>
<a name="ln1776">            // first ask if one gets more directional discrimination from nearby B/R sites</a>
<a name="ln1777">            vfloat pmwtaltv = zd25v * (LVFU(pmwt[(indx - m1) &gt;&gt; 1]) + LVFU(pmwt[(indx + p1) &gt;&gt; 1])</a>
<a name="ln1778">                                       + LVFU(pmwt[(indx - p1) &gt;&gt; 1]) + LVFU(pmwt[(indx + m1) &gt;&gt; 1]));</a>
<a name="ln1779">            vfloat tempv = LVFU(pmwt[indx1]);</a>
<a name="ln1780">            tempv = vself(vmaskf_lt(vabsf(zd5v - tempv), vabsf(zd5v - pmwtaltv)), pmwtaltv, tempv);</a>
<a name="ln1781">            STVFU(pmwt[indx1], tempv);</a>
<a name="ln1782">            STVFU(rbint[indx1],</a>
<a name="ln1783">                  zd5v * (LC2VFU(cfa[indx]) + vintpf(tempv, LVFU(rbp[indx1]), LVFU(rbm[indx1]))));</a>
<a name="ln1784">          }</a>
<a name="ln1785"> </a>
<a name="ln1786">#else</a>
<a name="ln1787"> </a>
<a name="ln1788">          for(int cc = 10 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc, indx1 = indx &gt;&gt; 1; cc &lt; cc1 - 10;</a>
<a name="ln1789">              cc += 2, indx += 2, indx1++)</a>
<a name="ln1790">          {</a>
<a name="ln1791"> </a>
<a name="ln1792">            // first ask if one gets more directional discrimination from nearby B/R sites</a>
<a name="ln1793">            float pmwtalt = xdivf(pmwt[(indx - m1) &gt;&gt; 1] + pmwt[(indx + p1) &gt;&gt; 1] + pmwt[(indx - p1) &gt;&gt; 1]</a>
<a name="ln1794">                                      + pmwt[(indx + m1) &gt;&gt; 1],</a>
<a name="ln1795">                                  2);</a>
<a name="ln1796"> </a>
<a name="ln1797">            if(fabsf(0.5f - pmwt[indx1]) &lt; fabsf(0.5f - pmwtalt))</a>
<a name="ln1798">            {</a>
<a name="ln1799">              pmwt[indx1] = pmwtalt; // a better result was obtained from the neighbours</a>
<a name="ln1800">            }</a>
<a name="ln1801"> </a>
<a name="ln1802">            rbint[indx1] = xdiv2f(cfa[indx] + rbm[indx1] * (1.f - pmwt[indx1])</a>
<a name="ln1803">                                  + rbp[indx1] * pmwt[indx1]); // this is R+B, interpolated</a>
<a name="ln1804">          }</a>
<a name="ln1805"> </a>
<a name="ln1806">#endif</a>
<a name="ln1807"> </a>
<a name="ln1808">        for(int rr = 12; rr &lt; rr1 - 12; rr++)</a>
<a name="ln1809">#ifdef __SSE2__</a>
<a name="ln1810">          for(int indx = rr * ts + 12 + (FC(rr, 2, filters) &amp; 1), indx1 = indx &gt;&gt; 1;</a>
<a name="ln1811">              indx &lt; rr * ts + cc1 - 12; indx += 8, indx1 += 4)</a>
<a name="ln1812">          {</a>
<a name="ln1813">            vmask copymask = vmaskf_ge(vabsf(zd5v - LVFU(pmwt[indx1])), vabsf(zd5v - LVFU(hvwt[indx1])));</a>
<a name="ln1814"> </a>
<a name="ln1815">            if(_mm_movemask_ps((vfloat)copymask))</a>
<a name="ln1816">            { // if for any of the 4 pixels the condition is true, do the maths for all 4 pixels and mask the</a>
<a name="ln1817">              // unused out at the end</a>
<a name="ln1818">              // now interpolate G vertically/horizontally using R+B values</a>
<a name="ln1819">              // unfortunately, since G interpolation cannot be done diagonally this may lead to colour shifts</a>
<a name="ln1820">              // colour ratios for G interpolation</a>
<a name="ln1821">              vfloat rbintv = LVFU(rbint[indx1]);</a>
<a name="ln1822"> </a>
<a name="ln1823">              // interpolated G via adaptive ratios or Hamilton-Adams in each cardinal direction</a>
<a name="ln1824">              vfloat cruv = vmul2f(LC2VFU(cfa[indx - v1])) / (epsv + rbintv + LVFU(rbint[(indx1 - v1)]));</a>
<a name="ln1825">              vfloat guv = rbintv * cruv;</a>
<a name="ln1826">              vfloat gu2v = LC2VFU(cfa[indx - v1]) + zd5v * (rbintv - LVFU(rbint[(indx1 - v1)]));</a>
<a name="ln1827">              guv = vself(vmaskf_lt(vabsf(onev - cruv), arthreshv), guv, gu2v);</a>
<a name="ln1828"> </a>
<a name="ln1829">              vfloat crdv = vmul2f(LC2VFU(cfa[indx + v1])) / (epsv + rbintv + LVFU(rbint[(indx1 + v1)]));</a>
<a name="ln1830">              vfloat gdv = rbintv * crdv;</a>
<a name="ln1831">              vfloat gd2v = LC2VFU(cfa[indx + v1]) + zd5v * (rbintv - LVFU(rbint[(indx1 + v1)]));</a>
<a name="ln1832">              gdv = vself(vmaskf_lt(vabsf(onev - crdv), arthreshv), gdv, gd2v);</a>
<a name="ln1833"> </a>
<a name="ln1834">              vfloat Gintvv = (LC2VFU(dirwts0[indx - v1]) * gdv + LC2VFU(dirwts0[indx + v1]) * guv)</a>
<a name="ln1835">                              / (LC2VFU(dirwts0[indx + v1]) + LC2VFU(dirwts0[indx - v1]));</a>
<a name="ln1836">              vfloat Gint1v = ULIMV(Gintvv, LC2VFU(cfa[indx - v1]), LC2VFU(cfa[indx + v1]));</a>
<a name="ln1837">              vfloat vwtv = vmul2f(rbintv - Gintvv) / (epsv + Gintvv + rbintv);</a>
<a name="ln1838">              vfloat Gint2v = vintpf(vwtv, Gintvv, Gint1v);</a>
<a name="ln1839">              Gint1v = vself(vmaskf_lt(vmul2f(Gintvv), rbintv), Gint1v, Gint2v);</a>
<a name="ln1840">              Gintvv = vself(vmaskf_lt(Gintvv, rbintv), Gint1v, Gintvv);</a>
<a name="ln1841">              Gintvv = vself(vmaskf_gt(Gintvv, clip_ptv),</a>
<a name="ln1842">                             ULIMV(Gintvv, LC2VFU(cfa[indx - v1]), LC2VFU(cfa[indx + v1])), Gintvv);</a>
<a name="ln1843"> </a>
<a name="ln1844">              vfloat crlv = vmul2f(LC2VFU(cfa[indx - 1])) / (epsv + rbintv + LVFU(rbint[(indx1 - 1)]));</a>
<a name="ln1845">              vfloat glv = rbintv * crlv;</a>
<a name="ln1846">              vfloat gl2v = LC2VFU(cfa[indx - 1]) + zd5v * (rbintv - LVFU(rbint[(indx1 - 1)]));</a>
<a name="ln1847">              glv = vself(vmaskf_lt(vabsf(onev - crlv), arthreshv), glv, gl2v);</a>
<a name="ln1848"> </a>
<a name="ln1849">              vfloat crrv = vmul2f(LC2VFU(cfa[indx + 1])) / (epsv + rbintv + LVFU(rbint[(indx1 + 1)]));</a>
<a name="ln1850">              vfloat grv = rbintv * crrv;</a>
<a name="ln1851">              vfloat gr2v = LC2VFU(cfa[indx + 1]) + zd5v * (rbintv - LVFU(rbint[(indx1 + 1)]));</a>
<a name="ln1852">              grv = vself(vmaskf_lt(vabsf(onev - crrv), arthreshv), grv, gr2v);</a>
<a name="ln1853"> </a>
<a name="ln1854">              vfloat Ginthv = (LC2VFU(dirwts1[indx - 1]) * grv + LC2VFU(dirwts1[indx + 1]) * glv)</a>
<a name="ln1855">                              / (LC2VFU(dirwts1[indx - 1]) + LC2VFU(dirwts1[indx + 1]));</a>
<a name="ln1856">              vfloat Gint1h = ULIMV(Ginthv, LC2VFU(cfa[indx - 1]), LC2VFU(cfa[indx + 1]));</a>
<a name="ln1857">              vfloat hwtv = vmul2f(rbintv - Ginthv) / (epsv + Ginthv + rbintv);</a>
<a name="ln1858">              vfloat Gint2h = vintpf(hwtv, Ginthv, Gint1h);</a>
<a name="ln1859">              Gint1h = vself(vmaskf_lt(vmul2f(Ginthv), rbintv), Gint1h, Gint2h);</a>
<a name="ln1860">              Ginthv = vself(vmaskf_lt(Ginthv, rbintv), Gint1h, Ginthv);</a>
<a name="ln1861">              Ginthv = vself(vmaskf_gt(Ginthv, clip_ptv),</a>
<a name="ln1862">                             ULIMV(Ginthv, LC2VFU(cfa[indx - 1]), LC2VFU(cfa[indx + 1])), Ginthv);</a>
<a name="ln1863"> </a>
<a name="ln1864">              vfloat greenv</a>
<a name="ln1865">                  = vself(copymask, vintpf(LVFU(hvwt[indx1]), Gintvv, Ginthv), LC2VFU(rgbgreen[indx]));</a>
<a name="ln1866">              STC2VFU(rgbgreen[indx], greenv);</a>
<a name="ln1867"> </a>
<a name="ln1868">              STVFU(Dgrb[0][indx1], vself(copymask, greenv - LC2VFU(cfa[indx]), LVFU(Dgrb[0][indx1])));</a>
<a name="ln1869">            }</a>
<a name="ln1870">          }</a>
<a name="ln1871"> </a>
<a name="ln1872">#else</a>
<a name="ln1873"> </a>
<a name="ln1874">          for(int cc = 12 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc, indx1 = indx &gt;&gt; 1; cc &lt; cc1 - 12;</a>
<a name="ln1875">              cc += 2, indx += 2, indx1++)</a>
<a name="ln1876">          {</a>
<a name="ln1877"> </a>
<a name="ln1878">            if(fabsf(0.5f - pmwt[indx &gt;&gt; 1]) &lt; fabsf(0.5f - hvwt[indx &gt;&gt; 1]))</a>
<a name="ln1879">            {</a>
<a name="ln1880">              continue;</a>
<a name="ln1881">            }</a>
<a name="ln1882"> </a>
<a name="ln1883">            // now interpolate G vertically/horizontally using R+B values</a>
<a name="ln1884">            // unfortunately, since G interpolation cannot be done diagonally this may lead to colour shifts</a>
<a name="ln1885"> </a>
<a name="ln1886">            // colour ratios for G interpolation</a>
<a name="ln1887">            float cru = cfa[indx - v1] * 2.0 / (eps + rbint[indx1] + rbint[(indx1 - v1)]);</a>
<a name="ln1888">            float crd = cfa[indx + v1] * 2.0 / (eps + rbint[indx1] + rbint[(indx1 + v1)]);</a>
<a name="ln1889">            float crl = cfa[indx - 1] * 2.0 / (eps + rbint[indx1] + rbint[(indx1 - 1)]);</a>
<a name="ln1890">            float crr = cfa[indx + 1] * 2.0 / (eps + rbint[indx1] + rbint[(indx1 + 1)]);</a>
<a name="ln1891"> </a>
<a name="ln1892">            // interpolation of G in four directions</a>
<a name="ln1893">            float gu, gd, gl, gr;</a>
<a name="ln1894"> </a>
<a name="ln1895">            // interpolated G via adaptive ratios or Hamilton-Adams in each cardinal direction</a>
<a name="ln1896">            if(fabsf(1.f - cru) &lt; arthresh)</a>
<a name="ln1897">            {</a>
<a name="ln1898">              gu = rbint[indx1] * cru;</a>
<a name="ln1899">            }</a>
<a name="ln1900">            else</a>
<a name="ln1901">            {</a>
<a name="ln1902">              gu = cfa[indx - v1] + xdiv2f(rbint[indx1] - rbint[(indx1 - v1)]);</a>
<a name="ln1903">            }</a>
<a name="ln1904"> </a>
<a name="ln1905">            if(fabsf(1.f - crd) &lt; arthresh)</a>
<a name="ln1906">            {</a>
<a name="ln1907">              gd = rbint[indx1] * crd;</a>
<a name="ln1908">            }</a>
<a name="ln1909">            else</a>
<a name="ln1910">            {</a>
<a name="ln1911">              gd = cfa[indx + v1] + xdiv2f(rbint[indx1] - rbint[(indx1 + v1)]);</a>
<a name="ln1912">            }</a>
<a name="ln1913"> </a>
<a name="ln1914">            if(fabsf(1.f - crl) &lt; arthresh)</a>
<a name="ln1915">            {</a>
<a name="ln1916">              gl = rbint[indx1] * crl;</a>
<a name="ln1917">            }</a>
<a name="ln1918">            else</a>
<a name="ln1919">            {</a>
<a name="ln1920">              gl = cfa[indx - 1] + xdiv2f(rbint[indx1] - rbint[(indx1 - 1)]);</a>
<a name="ln1921">            }</a>
<a name="ln1922"> </a>
<a name="ln1923">            if(fabsf(1.f - crr) &lt; arthresh)</a>
<a name="ln1924">            {</a>
<a name="ln1925">              gr = rbint[indx1] * crr;</a>
<a name="ln1926">            }</a>
<a name="ln1927">            else</a>
<a name="ln1928">            {</a>
<a name="ln1929">              gr = cfa[indx + 1] + xdiv2f(rbint[indx1] - rbint[(indx1 + 1)]);</a>
<a name="ln1930">            }</a>
<a name="ln1931"> </a>
<a name="ln1932">            // interpolated G via adaptive weights of cardinal evaluations</a>
<a name="ln1933">            float Gintv = (dirwts0[indx - v1] * gd + dirwts0[indx + v1] * gu)</a>
<a name="ln1934">                          / (dirwts0[indx + v1] + dirwts0[indx - v1]);</a>
<a name="ln1935">            float Ginth</a>
<a name="ln1936">                = (dirwts1[indx - 1] * gr + dirwts1[indx + 1] * gl) / (dirwts1[indx - 1] + dirwts1[indx + 1]);</a>
<a name="ln1937"> </a>
<a name="ln1938">            // bound the interpolation in regions of high saturation</a>
<a name="ln1939">            if(Gintv &lt; rbint[indx1])</a>
<a name="ln1940">            {</a>
<a name="ln1941">              if(2 * Gintv &lt; rbint[indx1])</a>
<a name="ln1942">              {</a>
<a name="ln1943">                Gintv = ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]);</a>
<a name="ln1944">              }</a>
<a name="ln1945">              else</a>
<a name="ln1946">              {</a>
<a name="ln1947">                float vwt = 2.0 * (rbint[indx1] - Gintv) / (eps + Gintv + rbint[indx1]);</a>
<a name="ln1948">                Gintv = vwt * Gintv + (1.f - vwt) * ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]);</a>
<a name="ln1949">              }</a>
<a name="ln1950">            }</a>
<a name="ln1951"> </a>
<a name="ln1952">            if(Ginth &lt; rbint[indx1])</a>
<a name="ln1953">            {</a>
<a name="ln1954">              if(2 * Ginth &lt; rbint[indx1])</a>
<a name="ln1955">              {</a>
<a name="ln1956">                Ginth = ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]);</a>
<a name="ln1957">              }</a>
<a name="ln1958">              else</a>
<a name="ln1959">              {</a>
<a name="ln1960">                float hwt = 2.0 * (rbint[indx1] - Ginth) / (eps + Ginth + rbint[indx1]);</a>
<a name="ln1961">                Ginth = hwt * Ginth + (1.f - hwt) * ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]);</a>
<a name="ln1962">              }</a>
<a name="ln1963">            }</a>
<a name="ln1964"> </a>
<a name="ln1965">            if(Ginth &gt; clip_pt)</a>
<a name="ln1966">            {</a>
<a name="ln1967">              Ginth = ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]);</a>
<a name="ln1968">            }</a>
<a name="ln1969"> </a>
<a name="ln1970">            if(Gintv &gt; clip_pt)</a>
<a name="ln1971">            {</a>
<a name="ln1972">              Gintv = ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]);</a>
<a name="ln1973">            }</a>
<a name="ln1974"> </a>
<a name="ln1975">            rgbgreen[indx] = Ginth * (1.f - hvwt[indx1]) + Gintv * hvwt[indx1];</a>
<a name="ln1976">            Dgrb[0][indx &gt;&gt; 1] = rgbgreen[indx] - cfa[indx];</a>
<a name="ln1977">          }</a>
<a name="ln1978"> </a>
<a name="ln1979">#endif</a>
<a name="ln1980"> </a>
<a name="ln1981">        // end of diagonal interpolation correction</a>
<a name="ln1982"> </a>
<a name="ln1983">        // fancy chrominance interpolation</a>
<a name="ln1984">        //(ey,ex) is location of R site</a>
<a name="ln1985">        for(int rr = 13 - ey; rr &lt; rr1 - 12; rr += 2)</a>
<a name="ln1986">          for(int indx1 = (rr * ts + 13 - ex) &gt;&gt; 1; indx1&lt;(rr * ts + cc1 - 12)&gt;&gt; 1; indx1++)</a>
<a name="ln1987">          {                                  // B coset</a>
<a name="ln1988">            Dgrb[1][indx1] = Dgrb[0][indx1]; // split out G-B from G-R</a>
<a name="ln1989">            Dgrb[0][indx1] = 0;</a>
<a name="ln1990">          }</a>
<a name="ln1991"> </a>
<a name="ln1992">#ifdef __SSE2__</a>
<a name="ln1993">        vfloat oned325v = F2V(1.325f);</a>
<a name="ln1994">        vfloat zd175v = F2V(0.175f);</a>
<a name="ln1995">        vfloat zd075v = F2V(0.075f);</a>
<a name="ln1996">#endif</a>
<a name="ln1997"> </a>
<a name="ln1998">        for(int rr = 14; rr &lt; rr1 - 14; rr++)</a>
<a name="ln1999">#ifdef __SSE2__</a>
<a name="ln2000">          for(int cc = 14 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc, c = 1 - FC(rr, cc, filters) / 2;</a>
<a name="ln2001">              cc &lt; cc1 - 14; cc += 8, indx += 8)</a>
<a name="ln2002">          {</a>
<a name="ln2003">            vfloat tempv = epsv + vabsf(LVFU(Dgrb[c][(indx - m1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx + m1) &gt;&gt; 1]));</a>
<a name="ln2004">            vfloat temp2v = epsv + vabsf(LVFU(Dgrb[c][(indx + p1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx - p1) &gt;&gt; 1]));</a>
<a name="ln2005">            vfloat wtnwv</a>
<a name="ln2006">                = onev / (tempv + vabsf(LVFU(Dgrb[c][(indx - m1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx - m3) &gt;&gt; 1]))</a>
<a name="ln2007">                          + vabsf(LVFU(Dgrb[c][(indx + m1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx - m3) &gt;&gt; 1])));</a>
<a name="ln2008">            vfloat wtnev</a>
<a name="ln2009">                = onev / (temp2v + vabsf(LVFU(Dgrb[c][(indx + p1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx + p3) &gt;&gt; 1]))</a>
<a name="ln2010">                          + vabsf(LVFU(Dgrb[c][(indx - p1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx + p3) &gt;&gt; 1])));</a>
<a name="ln2011">            vfloat wtswv</a>
<a name="ln2012">                = onev / (temp2v + vabsf(LVFU(Dgrb[c][(indx - p1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx + m3) &gt;&gt; 1]))</a>
<a name="ln2013">                          + vabsf(LVFU(Dgrb[c][(indx + p1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx - p3) &gt;&gt; 1])));</a>
<a name="ln2014">            vfloat wtsev</a>
<a name="ln2015">                = onev / (tempv + vabsf(LVFU(Dgrb[c][(indx + m1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx - p3) &gt;&gt; 1]))</a>
<a name="ln2016">                          + vabsf(LVFU(Dgrb[c][(indx - m1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx + m3) &gt;&gt; 1])));</a>
<a name="ln2017"> </a>
<a name="ln2018">            STVFU(Dgrb[c][indx &gt;&gt; 1], (wtnwv * (oned325v * LVFU(Dgrb[c][(indx - m1) &gt;&gt; 1])</a>
<a name="ln2019">                                                - zd175v * LVFU(Dgrb[c][(indx - m3) &gt;&gt; 1])</a>
<a name="ln2020">                                                - zd075v * (LVFU(Dgrb[c][(indx - m1 - 2) &gt;&gt; 1])</a>
<a name="ln2021">                                                            + LVFU(Dgrb[c][(indx - m1 - v2) &gt;&gt; 1])))</a>
<a name="ln2022">                                       + wtnev * (oned325v * LVFU(Dgrb[c][(indx + p1) &gt;&gt; 1])</a>
<a name="ln2023">                                                  - zd175v * LVFU(Dgrb[c][(indx + p3) &gt;&gt; 1])</a>
<a name="ln2024">                                                  - zd075v * (LVFU(Dgrb[c][(indx + p1 + 2) &gt;&gt; 1])</a>
<a name="ln2025">                                                              + LVFU(Dgrb[c][(indx + p1 + v2) &gt;&gt; 1])))</a>
<a name="ln2026">                                       + wtswv * (oned325v * LVFU(Dgrb[c][(indx - p1) &gt;&gt; 1])</a>
<a name="ln2027">                                                  - zd175v * LVFU(Dgrb[c][(indx - p3) &gt;&gt; 1])</a>
<a name="ln2028">                                                  - zd075v * (LVFU(Dgrb[c][(indx - p1 - 2) &gt;&gt; 1])</a>
<a name="ln2029">                                                              + LVFU(Dgrb[c][(indx - p1 - v2) &gt;&gt; 1])))</a>
<a name="ln2030">                                       + wtsev * (oned325v * LVFU(Dgrb[c][(indx + m1) &gt;&gt; 1])</a>
<a name="ln2031">                                                  - zd175v * LVFU(Dgrb[c][(indx + m3) &gt;&gt; 1])</a>
<a name="ln2032">                                                  - zd075v * (LVFU(Dgrb[c][(indx + m1 + 2) &gt;&gt; 1])</a>
<a name="ln2033">                                                              + LVFU(Dgrb[c][(indx + m1 + v2) &gt;&gt; 1]))))</a>
<a name="ln2034">                                          / (wtnwv + wtnev + wtswv + wtsev));</a>
<a name="ln2035">          }</a>
<a name="ln2036"> </a>
<a name="ln2037">#else</a>
<a name="ln2038"> </a>
<a name="ln2039">          for(int cc = 14 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc, c = 1 - FC(rr, cc, filters) / 2;</a>
<a name="ln2040">              cc &lt; cc1 - 14; cc += 2, indx += 2)</a>
<a name="ln2041">          {</a>
<a name="ln2042">            float wtnw = 1.f / (eps + fabsf(Dgrb[c][(indx - m1) &gt;&gt; 1] - Dgrb[c][(indx + m1) &gt;&gt; 1])</a>
<a name="ln2043">                                + fabsf(Dgrb[c][(indx - m1) &gt;&gt; 1] - Dgrb[c][(indx - m3) &gt;&gt; 1])</a>
<a name="ln2044">                                + fabsf(Dgrb[c][(indx + m1) &gt;&gt; 1] - Dgrb[c][(indx - m3) &gt;&gt; 1]));</a>
<a name="ln2045">            float wtne = 1.f / (eps + fabsf(Dgrb[c][(indx + p1) &gt;&gt; 1] - Dgrb[c][(indx - p1) &gt;&gt; 1])</a>
<a name="ln2046">                                + fabsf(Dgrb[c][(indx + p1) &gt;&gt; 1] - Dgrb[c][(indx + p3) &gt;&gt; 1])</a>
<a name="ln2047">                                + fabsf(Dgrb[c][(indx - p1) &gt;&gt; 1] - Dgrb[c][(indx + p3) &gt;&gt; 1]));</a>
<a name="ln2048">            float wtsw = 1.f / (eps + fabsf(Dgrb[c][(indx - p1) &gt;&gt; 1] - Dgrb[c][(indx + p1) &gt;&gt; 1])</a>
<a name="ln2049">                                + fabsf(Dgrb[c][(indx - p1) &gt;&gt; 1] - Dgrb[c][(indx + m3) &gt;&gt; 1])</a>
<a name="ln2050">                                + fabsf(Dgrb[c][(indx + p1) &gt;&gt; 1] - Dgrb[c][(indx - p3) &gt;&gt; 1]));</a>
<a name="ln2051">            float wtse = 1.f / (eps + fabsf(Dgrb[c][(indx + m1) &gt;&gt; 1] - Dgrb[c][(indx - m1) &gt;&gt; 1])</a>
<a name="ln2052">                                + fabsf(Dgrb[c][(indx + m1) &gt;&gt; 1] - Dgrb[c][(indx - p3) &gt;&gt; 1])</a>
<a name="ln2053">                                + fabsf(Dgrb[c][(indx - m1) &gt;&gt; 1] - Dgrb[c][(indx + m3) &gt;&gt; 1]));</a>
<a name="ln2054"> </a>
<a name="ln2055">            Dgrb[c][indx &gt;&gt; 1]</a>
<a name="ln2056">                = (wtnw * (1.325f * Dgrb[c][(indx - m1) &gt;&gt; 1] - 0.175f * Dgrb[c][(indx - m3) &gt;&gt; 1]</a>
<a name="ln2057">                           - 0.075f * Dgrb[c][(indx - m1 - 2) &gt;&gt; 1] - 0.075f * Dgrb[c][(indx - m1 - v2) &gt;&gt; 1])</a>
<a name="ln2058">                   + wtne * (1.325f * Dgrb[c][(indx + p1) &gt;&gt; 1] - 0.175f * Dgrb[c][(indx + p3) &gt;&gt; 1]</a>
<a name="ln2059">                             - 0.075f * Dgrb[c][(indx + p1 + 2) &gt;&gt; 1]</a>
<a name="ln2060">                             - 0.075f * Dgrb[c][(indx + p1 + v2) &gt;&gt; 1])</a>
<a name="ln2061">                   + wtsw * (1.325f * Dgrb[c][(indx - p1) &gt;&gt; 1] - 0.175f * Dgrb[c][(indx - p3) &gt;&gt; 1]</a>
<a name="ln2062">                             - 0.075f * Dgrb[c][(indx - p1 - 2) &gt;&gt; 1]</a>
<a name="ln2063">                             - 0.075f * Dgrb[c][(indx - p1 - v2) &gt;&gt; 1])</a>
<a name="ln2064">                   + wtse * (1.325f * Dgrb[c][(indx + m1) &gt;&gt; 1] - 0.175f * Dgrb[c][(indx + m3) &gt;&gt; 1]</a>
<a name="ln2065">                             - 0.075f * Dgrb[c][(indx + m1 + 2) &gt;&gt; 1]</a>
<a name="ln2066">                             - 0.075f * Dgrb[c][(indx + m1 + v2) &gt;&gt; 1]))</a>
<a name="ln2067">                  / (wtnw + wtne + wtsw + wtse);</a>
<a name="ln2068">          }</a>
<a name="ln2069"> </a>
<a name="ln2070">#endif</a>
<a name="ln2071"> </a>
<a name="ln2072">#ifdef __SSE2__</a>
<a name="ln2073">        int offset;</a>
<a name="ln2074">        vfloat twov = F2V(2.f);</a>
<a name="ln2075">        vmask selmask;</a>
<a name="ln2076"> </a>
<a name="ln2077">        if((FC(16, 2, filters) &amp; 1) == 1)</a>
<a name="ln2078">        {</a>
<a name="ln2079">          selmask = _mm_set_epi32(0xffffffff, 0, 0xffffffff, 0);</a>
<a name="ln2080">          offset = 1;</a>
<a name="ln2081">        }</a>
<a name="ln2082">        else</a>
<a name="ln2083">        {</a>
<a name="ln2084">          selmask = _mm_set_epi32(0, 0xffffffff, 0, 0xffffffff);</a>
<a name="ln2085">          offset = 0;</a>
<a name="ln2086">        }</a>
<a name="ln2087"> </a>
<a name="ln2088">#endif</a>
<a name="ln2089"> </a>
<a name="ln2090">        for(int rr = 16; rr &lt; rr1 - 16; rr++)</a>
<a name="ln2091">        {</a>
<a name="ln2092">          int row = rr + top;</a>
<a name="ln2093">          int col = left + 16;</a>
<a name="ln2094">          int indx = rr * ts + 16;</a>
<a name="ln2095">#ifdef __SSE2__</a>
<a name="ln2096">          offset = 1 - offset;</a>
<a name="ln2097">          selmask = vnotm(selmask);</a>
<a name="ln2098"> </a>
<a name="ln2099">          for(; indx &lt; rr * ts + cc1 - 18 - (cc1 &amp; 1); indx += 4, col += 4)</a>
<a name="ln2100">          {</a>
<a name="ln2101">            if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2102">            {</a>
<a name="ln2103">              vfloat greenv = LVF(rgbgreen[indx]);</a>
<a name="ln2104">              vfloat temp00v = vdup(LVFU(hvwt[(indx - v1) &gt;&gt; 1]));</a>
<a name="ln2105">              vfloat temp01v = vdup(LVFU(hvwt[(indx + v1) &gt;&gt; 1]));</a>
<a name="ln2106">              vfloat tempv = onev / (temp00v + twov - vdup(LVFU(hvwt[(indx + 1 + offset) &gt;&gt; 1]))</a>
<a name="ln2107">                                     - vdup(LVFU(hvwt[(indx - 1 + offset) &gt;&gt; 1])) + temp01v);</a>
<a name="ln2108"> </a>
<a name="ln2109">              vfloat redv1 = greenv</a>
<a name="ln2110">                             - (temp00v * vdup(LVFU(Dgrb[0][(indx - v1) &gt;&gt; 1]))</a>
<a name="ln2111">                                + (onev - vdup(LVFU(hvwt[(indx + 1 + offset) &gt;&gt; 1])))</a>
<a name="ln2112">                                      * vdup(LVFU(Dgrb[0][(indx + 1 + offset) &gt;&gt; 1]))</a>
<a name="ln2113">                                + (onev - vdup(LVFU(hvwt[(indx - 1 + offset) &gt;&gt; 1])))</a>
<a name="ln2114">                                      * vdup(LVFU(Dgrb[0][(indx - 1 + offset) &gt;&gt; 1]))</a>
<a name="ln2115">                                + temp01v * vdup(LVFU(Dgrb[0][(indx + v1) &gt;&gt; 1])))</a>
<a name="ln2116">                                   * tempv;</a>
<a name="ln2117">              vfloat bluev1 = greenv</a>
<a name="ln2118">                              - (temp00v * vdup(LVFU(Dgrb[1][(indx - v1) &gt;&gt; 1]))</a>
<a name="ln2119">                                 + (onev - vdup(LVFU(hvwt[(indx + 1 + offset) &gt;&gt; 1])))</a>
<a name="ln2120">                                       * vdup(LVFU(Dgrb[1][(indx + 1 + offset) &gt;&gt; 1]))</a>
<a name="ln2121">                                 + (onev - vdup(LVFU(hvwt[(indx - 1 + offset) &gt;&gt; 1])))</a>
<a name="ln2122">                                       * vdup(LVFU(Dgrb[1][(indx - 1 + offset) &gt;&gt; 1]))</a>
<a name="ln2123">                                 + temp01v * vdup(LVFU(Dgrb[1][(indx + v1) &gt;&gt; 1])))</a>
<a name="ln2124">                                    * tempv;</a>
<a name="ln2125">              vfloat redv2 = greenv - vdup(LVFU(Dgrb[0][indx &gt;&gt; 1]));</a>
<a name="ln2126">              vfloat bluev2 = greenv - vdup(LVFU(Dgrb[1][indx &gt;&gt; 1]));</a>
<a name="ln2127">              __attribute__((aligned(64))) float _r[4];</a>
<a name="ln2128">              __attribute__((aligned(64))) float _b[4];</a>
<a name="ln2129">              STVF(*_r, vself(selmask, redv1, redv2));</a>
<a name="ln2130">              STVF(*_b, vself(selmask, bluev1, bluev2));</a>
<a name="ln2131">              for(int c = 0; c &lt; 4; c++)</a>
<a name="ln2132">              {</a>
<a name="ln2133">                out[(row * roi_out-&gt;width + col + c) * 4] = clampnan(_r[c], 0.0, 1.0);</a>
<a name="ln2134">                out[(row * roi_out-&gt;width + col + c) * 4 + 2] = clampnan(_b[c], 0.0, 1.0);</a>
<a name="ln2135">              }</a>
<a name="ln2136">            }</a>
<a name="ln2137">          }</a>
<a name="ln2138"> </a>
<a name="ln2139">          if(offset == 0)</a>
<a name="ln2140">          {</a>
<a name="ln2141">            for(; indx &lt; rr * ts + cc1 - 16 - (cc1 &amp; 1); indx++, col++)</a>
<a name="ln2142">            {</a>
<a name="ln2143">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2144">              {</a>
<a name="ln2145">                float temp = 1.f / (hvwt[(indx - v1) &gt;&gt; 1] + 2.f - hvwt[(indx + 1) &gt;&gt; 1]</a>
<a name="ln2146">                                    - hvwt[(indx - 1) &gt;&gt; 1] + hvwt[(indx + v1) &gt;&gt; 1]);</a>
<a name="ln2147">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2148">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2149">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[0][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2150">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[0][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2151">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[0][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2152">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[0][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2153">                                         * temp,</a>
<a name="ln2154">                               0.0, 1.0);</a>
<a name="ln2155">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2156">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2157">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[1][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2158">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[1][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2159">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[1][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2160">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[1][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2161">                                         * temp,</a>
<a name="ln2162">                               0.0, 1.0);</a>
<a name="ln2163">              }</a>
<a name="ln2164"> </a>
<a name="ln2165">              indx++;</a>
<a name="ln2166">              col++;</a>
<a name="ln2167">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2168">              {</a>
<a name="ln2169">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2170">                    = clampnan(rgbgreen[indx] - Dgrb[0][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2171">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2172">                    = clampnan(rgbgreen[indx] - Dgrb[1][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2173">              }</a>
<a name="ln2174">            }</a>
<a name="ln2175"> </a>
<a name="ln2176">            if(cc1 &amp; 1)</a>
<a name="ln2177">            { // width of tile is odd</a>
<a name="ln2178">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2179">              {</a>
<a name="ln2180">                float temp = 1.f / (hvwt[(indx - v1) &gt;&gt; 1] + 2.f - hvwt[(indx + 1) &gt;&gt; 1]</a>
<a name="ln2181">                                    - hvwt[(indx - 1) &gt;&gt; 1] + hvwt[(indx + v1) &gt;&gt; 1]);</a>
<a name="ln2182">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2183">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2184">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[0][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2185">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[0][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2186">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[0][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2187">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[0][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2188">                                         * temp,</a>
<a name="ln2189">                               0.0, 1.0);</a>
<a name="ln2190">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2191">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2192">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[1][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2193">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[1][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2194">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[1][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2195">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[1][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2196">                                         * temp,</a>
<a name="ln2197">                               0.0, 1.0);</a>
<a name="ln2198">              }</a>
<a name="ln2199">            }</a>
<a name="ln2200">          }</a>
<a name="ln2201">          else</a>
<a name="ln2202">          {</a>
<a name="ln2203">            for(; indx &lt; rr * ts + cc1 - 16 - (cc1 &amp; 1); indx++, col++)</a>
<a name="ln2204">            {</a>
<a name="ln2205">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2206">              {</a>
<a name="ln2207">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2208">                    = clampnan(rgbgreen[indx] - Dgrb[0][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2209">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2210">                    = clampnan(rgbgreen[indx] - Dgrb[1][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2211">              }</a>
<a name="ln2212"> </a>
<a name="ln2213">              indx++;</a>
<a name="ln2214">              col++;</a>
<a name="ln2215">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2216">              {</a>
<a name="ln2217">                float temp = 1.f / (hvwt[(indx - v1) &gt;&gt; 1] + 2.f - hvwt[(indx + 1) &gt;&gt; 1]</a>
<a name="ln2218">                                    - hvwt[(indx - 1) &gt;&gt; 1] + hvwt[(indx + v1) &gt;&gt; 1]);</a>
<a name="ln2219">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2220">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2221">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[0][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2222">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[0][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2223">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[0][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2224">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[0][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2225">                                         * temp,</a>
<a name="ln2226">                               0.0, 1.0);</a>
<a name="ln2227">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2228">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2229">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[1][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2230">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[1][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2231">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[1][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2232">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[1][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2233">                                         * temp,</a>
<a name="ln2234">                               0.0, 1.0);</a>
<a name="ln2235">              }</a>
<a name="ln2236">            }</a>
<a name="ln2237"> </a>
<a name="ln2238">            if(cc1 &amp; 1)</a>
<a name="ln2239">            { // width of tile is odd</a>
<a name="ln2240">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2241">              {</a>
<a name="ln2242">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2243">                    = clampnan(rgbgreen[indx] - Dgrb[0][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2244">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2245">                    = clampnan(rgbgreen[indx] - Dgrb[1][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2246">              }</a>
<a name="ln2247">            }</a>
<a name="ln2248">          }</a>
<a name="ln2249"> </a>
<a name="ln2250">#else</a>
<a name="ln2251"> </a>
<a name="ln2252">          if((FC(rr, 2, filters) &amp; 1) == 1)</a>
<a name="ln2253">          {</a>
<a name="ln2254">            for(; indx &lt; rr * ts + cc1 - 16 - (cc1 &amp; 1); indx++, col++)</a>
<a name="ln2255">            {</a>
<a name="ln2256">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2257">              {</a>
<a name="ln2258">                float temp = 1.f / (hvwt[(indx - v1) &gt;&gt; 1] + 2.f - hvwt[(indx + 1) &gt;&gt; 1]</a>
<a name="ln2259">                                    - hvwt[(indx - 1) &gt;&gt; 1] + hvwt[(indx + v1) &gt;&gt; 1]);</a>
<a name="ln2260">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2261">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2262">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[0][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2263">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[0][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2264">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[0][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2265">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[0][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2266">                                         * temp,</a>
<a name="ln2267">                               0.0, 1.0);</a>
<a name="ln2268">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2269">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2270">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[1][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2271">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[1][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2272">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[1][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2273">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[1][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2274">                                         * temp,</a>
<a name="ln2275">                               0.0, 1.0);</a>
<a name="ln2276">              }</a>
<a name="ln2277"> </a>
<a name="ln2278">              indx++;</a>
<a name="ln2279">              col++;</a>
<a name="ln2280">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2281">              {</a>
<a name="ln2282">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2283">                    = clampnan(rgbgreen[indx] - Dgrb[0][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2284">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2285">                    = clampnan(rgbgreen[indx] - Dgrb[1][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2286">              }</a>
<a name="ln2287">            }</a>
<a name="ln2288"> </a>
<a name="ln2289">            if(cc1 &amp; 1)</a>
<a name="ln2290">            { // width of tile is odd</a>
<a name="ln2291">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2292">              {</a>
<a name="ln2293">                float temp = 1.f / (hvwt[(indx - v1) &gt;&gt; 1] + 2.f - hvwt[(indx + 1) &gt;&gt; 1]</a>
<a name="ln2294">                                    - hvwt[(indx - 1) &gt;&gt; 1] + hvwt[(indx + v1) &gt;&gt; 1]);</a>
<a name="ln2295">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2296">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2297">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[0][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2298">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[0][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2299">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[0][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2300">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[0][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2301">                                         * temp,</a>
<a name="ln2302">                               0.0, 1.0);</a>
<a name="ln2303">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2304">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2305">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[1][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2306">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[1][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2307">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[1][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2308">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[1][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2309">                                         * temp,</a>
<a name="ln2310">                               0.0, 1.0);</a>
<a name="ln2311">              }</a>
<a name="ln2312">            }</a>
<a name="ln2313">          }</a>
<a name="ln2314">          else</a>
<a name="ln2315">          {</a>
<a name="ln2316">            for(; indx &lt; rr * ts + cc1 - 16 - (cc1 &amp; 1); indx++, col++)</a>
<a name="ln2317">            {</a>
<a name="ln2318">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2319">              {</a>
<a name="ln2320">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2321">                    = clampnan(rgbgreen[indx] - Dgrb[0][indx &gt;&gt; 1], 0.0f, 1.0f);</a>
<a name="ln2322">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2323">                    = clampnan(rgbgreen[indx] - Dgrb[1][indx &gt;&gt; 1], 0.0f, 1.0f);</a>
<a name="ln2324">              }</a>
<a name="ln2325"> </a>
<a name="ln2326">              indx++;</a>
<a name="ln2327">              col++;</a>
<a name="ln2328">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2329">              {</a>
<a name="ln2330">                float temp = 1.f / (hvwt[(indx - v1) &gt;&gt; 1] + 2.f - hvwt[(indx + 1) &gt;&gt; 1]</a>
<a name="ln2331">                                    - hvwt[(indx - 1) &gt;&gt; 1] + hvwt[(indx + v1) &gt;&gt; 1]);</a>
<a name="ln2332"> </a>
<a name="ln2333">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2334">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2335">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[0][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2336">                                      + (1.0f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[0][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2337">                                      + (1.0f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[0][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2338">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[0][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2339">                                         * temp,</a>
<a name="ln2340">                               0.0f, 1.0f);</a>
<a name="ln2341"> </a>
<a name="ln2342">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2343">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2344">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[1][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2345">                                      + (1.0f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[1][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2346">                                      + (1.0f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[1][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2347">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[1][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2348">                                         * temp,</a>
<a name="ln2349">                               0.0f, 1.0f);</a>
<a name="ln2350">              }</a>
<a name="ln2351">            }</a>
<a name="ln2352"> </a>
<a name="ln2353">            if(cc1 &amp; 1)</a>
<a name="ln2354">            { // width of tile is odd</a>
<a name="ln2355">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2356">              {</a>
<a name="ln2357">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2358">                    = clampnan(rgbgreen[indx] - Dgrb[0][indx &gt;&gt; 1], 0.0f, 1.0f);</a>
<a name="ln2359">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2360">                    = clampnan(rgbgreen[indx] - Dgrb[1][indx &gt;&gt; 1], 0.0f, 1.0f);</a>
<a name="ln2361">              }</a>
<a name="ln2362">            }</a>
<a name="ln2363">          }</a>
<a name="ln2364"> </a>
<a name="ln2365">#endif</a>
<a name="ln2366">        }</a>
<a name="ln2367"> </a>
<a name="ln2368">        // copy smoothed results back to image matrix</a>
<a name="ln2369">        for(int rr = 16; rr &lt; rr1 - 16; rr++)</a>
<a name="ln2370">        {</a>
<a name="ln2371">          int row = rr + top;</a>
<a name="ln2372">          int cc = 16;</a>
<a name="ln2373">          // TODO (darktable): we have the pixel colors interleaved so writing them in blocks using SSE2 is</a>
<a name="ln2374">          // not possible. or is it?</a>
<a name="ln2375">          // #ifdef __SSE2__</a>
<a name="ln2376">          //</a>
<a name="ln2377">          //           for(; cc &lt; cc1 - 19; cc += 4)</a>
<a name="ln2378">          //           {</a>
<a name="ln2379">          //             STVFU(out[(row * roi_out-&gt;width + (cc + left))  * 4 + 1], LVF(rgbgreen[rr * ts +</a>
<a name="ln2380">          //             cc]));</a>
<a name="ln2381">          //           }</a>
<a name="ln2382">          //</a>
<a name="ln2383">          // #endif</a>
<a name="ln2384"> </a>
<a name="ln2385">          for(; cc &lt; cc1 - 16; cc++)</a>
<a name="ln2386">          {</a>
<a name="ln2387">            int col = cc + left;</a>
<a name="ln2388">            int indx = rr * ts + cc;</a>
<a name="ln2389">            if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2390">              out[(row * roi_out-&gt;width + col) * 4 + 1] = clampnan(rgbgreen[indx], 0.0f, 1.0f);</a>
<a name="ln2391">          }</a>
<a name="ln2392">        }</a>
<a name="ln2393"> </a>
<a name="ln2394">        //         if(plistener)</a>
<a name="ln2395">        //         {</a>
<a name="ln2396">        //           progresscounter++;</a>
<a name="ln2397">        //</a>
<a name="ln2398">        //           if(progresscounter % 32 == 0)</a>
<a name="ln2399">        //           {</a>
<a name="ln2400">        // #ifdef _OPENMP</a>
<a name="ln2401">        // #pragma omp critical(amazeprogress)</a>
<a name="ln2402">        // #endif</a>
<a name="ln2403">        //             {</a>
<a name="ln2404">        //               progress += (double)32 * ((ts - 32) * (ts - 32)) / (height * width);</a>
<a name="ln2405">        //               progress = progress &gt; 1.0 ? 1.0 : progress;</a>
<a name="ln2406">        //               plistener-&gt;setProgress(progress);</a>
<a name="ln2407">        //             }</a>
<a name="ln2408">        //           }</a>
<a name="ln2409">        //         }</a>
<a name="ln2410">      }</a>
<a name="ln2411">    } // end of main loop</a>
<a name="ln2412"> </a>
<a name="ln2413">    // clean up</a>
<a name="ln2414">    free(buffer);</a>
<a name="ln2415">  }</a>
<a name="ln2416"> </a>
<a name="ln2417">  //   if(plistener)</a>
<a name="ln2418">  //   {</a>
<a name="ln2419">  //     plistener-&gt;setProgress(1.0);</a>
<a name="ln2420">  //   }</a>
<a name="ln2421">}</a>
<a name="ln2422">// }</a>
<a name="ln2423"> </a>
<a name="ln2424">/*==================================================================================</a>
<a name="ln2425"> * end of raw therapee code</a>
<a name="ln2426"> *==================================================================================*/</a>
<a name="ln2427"> </a>
<a name="ln2428">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2429">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2430">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="283"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'LIM' function: 'c' and 'b'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
