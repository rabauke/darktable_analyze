
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln22">#include &quot;common/points.h&quot;</a>
<a name="ln23">#include &quot;control/control.h&quot;</a>
<a name="ln24">#include &quot;develop/develop.h&quot;</a>
<a name="ln25">#include &quot;develop/imageop.h&quot;</a>
<a name="ln26">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln27">#include &quot;gui/gtk.h&quot;</a>
<a name="ln28">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln31">#include &lt;inttypes.h&gt;</a>
<a name="ln32">#include &lt;math.h&gt;</a>
<a name="ln33">#include &lt;stdlib.h&gt;</a>
<a name="ln34">#include &lt;string.h&gt;</a>
<a name="ln35">#include &lt;strings.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">/**</a>
<a name="ln38"> * color transfer somewhat based on the glorious paper `color transfer between images'</a>
<a name="ln39"> * by erik reinhard, michael ashikhmin, bruce gooch, and peter shirley, 2001.</a>
<a name="ln40"> * chosen because it officially cites the playboy.</a>
<a name="ln41"> *</a>
<a name="ln42"> * workflow:</a>
<a name="ln43"> * - open the target image, press acquire button</a>
<a name="ln44"> * - right click store as preset</a>
<a name="ln45"> * - open image you want to transfer the color to</a>
<a name="ln46"> * - right click and apply the preset</a>
<a name="ln47"> */</a>
<a name="ln48"> </a>
<a name="ln49">DT_MODULE_INTROSPECTION(1, dt_iop_colortransfer_params_t)</a>
<a name="ln50"> </a>
<a name="ln51">#define HISTN (1 &lt;&lt; 11)</a>
<a name="ln52">#define MAXN 5</a>
<a name="ln53"> </a>
<a name="ln54">typedef enum dt_iop_colortransfer_flag_t</a>
<a name="ln55">{</a>
<a name="ln56">  ACQUIRE = 0,</a>
<a name="ln57">  ACQUIRE2 = 1,</a>
<a name="ln58">  ACQUIRE3 = 2,</a>
<a name="ln59">  ACQUIRED = 3,</a>
<a name="ln60">  APPLY = 4,</a>
<a name="ln61">  NEUTRAL = 5</a>
<a name="ln62">} dt_iop_colortransfer_flag_t;</a>
<a name="ln63"> </a>
<a name="ln64">typedef struct dt_iop_colortransfer_params_t</a>
<a name="ln65">{</a>
<a name="ln66">  dt_iop_colortransfer_flag_t flag;</a>
<a name="ln67">  // hist matching table</a>
<a name="ln68">  float hist[HISTN];</a>
<a name="ln69">  // n-means (max 5?) with mean/variance</a>
<a name="ln70">  float mean[MAXN][2];</a>
<a name="ln71">  float var[MAXN][2];</a>
<a name="ln72">  // number of gaussians used.</a>
<a name="ln73">  int n;</a>
<a name="ln74">} dt_iop_colortransfer_params_t;</a>
<a name="ln75"> </a>
<a name="ln76">typedef struct dt_iop_colortransfer_gui_data_t</a>
<a name="ln77">{</a>
<a name="ln78">  int flowback_set;</a>
<a name="ln79">  dt_iop_colortransfer_params_t flowback;</a>
<a name="ln80">  GtkWidget *apply_button;</a>
<a name="ln81">  GtkWidget *acquire_button;</a>
<a name="ln82">  GtkSpinButton *spinbutton;</a>
<a name="ln83">  GtkWidget *area;</a>
<a name="ln84">  cmsHTRANSFORM xform;</a>
<a name="ln85">} dt_iop_colortransfer_gui_data_t;</a>
<a name="ln86"> </a>
<a name="ln87">typedef struct dt_iop_colortransfer_data_t</a>
<a name="ln88">{</a>
<a name="ln89">  // same as params. (need duplicate because database table preset contains params_t)</a>
<a name="ln90">  dt_iop_colortransfer_flag_t flag;</a>
<a name="ln91">  float hist[HISTN];</a>
<a name="ln92">  float mean[MAXN][2];</a>
<a name="ln93">  float var[MAXN][2];</a>
<a name="ln94">  int n;</a>
<a name="ln95">} dt_iop_colortransfer_data_t;</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">const char *name()</a>
<a name="ln99">{</a>
<a name="ln100">  return _(&quot;color transfer&quot;);</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">int default_group()</a>
<a name="ln104">{</a>
<a name="ln105">  return IOP_GROUP_COLOR;</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">int flags()</a>
<a name="ln109">{</a>
<a name="ln110">  return IOP_FLAGS_DEPRECATED | IOP_FLAGS_ONE_INSTANCE | IOP_FLAGS_PREVIEW_NON_OPENCL;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln114">{</a>
<a name="ln115">  return iop_cs_Lab;</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">#if 0</a>
<a name="ln119">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln120">{</a>
<a name="ln121">  dt_accel_register_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;acquire&quot;), 0, 0);</a>
<a name="ln122">  dt_accel_register_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;apply&quot;), 0, 0);</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln126">{</a>
<a name="ln127">  dt_iop_colortransfer_gui_data_t *g =</a>
<a name="ln128">    (dt_iop_colortransfer_gui_data_t*)self-&gt;gui_data;</a>
<a name="ln129"> </a>
<a name="ln130">  dt_accel_connect_button_iop(self, &quot;acquire&quot;, g-&gt;acquire_button);</a>
<a name="ln131">  dt_accel_connect_button_iop(self, &quot;apply&quot;, g-&gt;apply_button);</a>
<a name="ln132">}</a>
<a name="ln133">#endif</a>
<a name="ln134"> </a>
<a name="ln135">static void capture_histogram(const float *col, const dt_iop_roi_t *roi, int *hist)</a>
<a name="ln136">{</a>
<a name="ln137">  // build separate histogram</a>
<a name="ln138">  memset(hist, 0, HISTN * sizeof(int));</a>
<a name="ln139">  for(int k = 0; k &lt; roi-&gt;height; k++)</a>
<a name="ln140">    for(int i = 0; i &lt; roi-&gt;width; i++)</a>
<a name="ln141">    {</a>
<a name="ln142">      const int bin = CLAMP(HISTN * col[3 * (k * roi-&gt;width + i) + 0] / 100.0, 0, HISTN - 1);</a>
<a name="ln143">      hist[bin]++;</a>
<a name="ln144">    }</a>
<a name="ln145"> </a>
<a name="ln146">  // accumulated start distribution of G1 G2</a>
<a name="ln147">  for(int k = 1; k &lt; HISTN; k++) hist[k] += hist[k - 1];</a>
<a name="ln148">  for(int k = 0; k &lt; HISTN; k++)</a>
<a name="ln149">    hist[k] = (int)CLAMP(hist[k] * (HISTN / (float)hist[HISTN - 1]), 0, HISTN - 1);</a>
<a name="ln150">  // for(int i=0;i&lt;100;i++) printf(&quot;#[%d] %d \n&quot;, i, hist[(int)CLAMP(HISTN*i/100.0, 0, HISTN-1)]);</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">static void invert_histogram(const int *hist, float *inv_hist)</a>
<a name="ln154">{</a>
<a name="ln155">// invert non-normalised accumulated hist</a>
<a name="ln156">#if 0</a>
<a name="ln157">  int last = 0;</a>
<a name="ln158">  for(int i=0; i&lt;HISTN; i++) for(int k=last; k&lt;HISTN; k++)</a>
<a name="ln159">      if(hist[k] &gt;= i)</a>
<a name="ln160">      {</a>
<a name="ln161">        last = k;</a>
<a name="ln162">        inv_hist[i] = 100.0*k/(float)HISTN;</a>
<a name="ln163">        break;</a>
<a name="ln164">      }</a>
<a name="ln165">#else</a>
<a name="ln166">  int last = 31;</a>
<a name="ln167">  for(int i = 0; i &lt;= last; i++) inv_hist[i] = 100.0 * i / (float)HISTN;</a>
<a name="ln168">  for(int i = last + 1; i &lt; HISTN; i++)</a>
<a name="ln169">    for(int k = last; k &lt; HISTN; k++)</a>
<a name="ln170">      if(hist[k] &gt;= i)</a>
<a name="ln171">      {</a>
<a name="ln172">        last = k;</a>
<a name="ln173">        inv_hist[i] = 100.0 * k / (float)HISTN;</a>
<a name="ln174">        break;</a>
<a name="ln175">      }</a>
<a name="ln176">#endif</a>
<a name="ln177"> </a>
<a name="ln178">  // printf(&quot;inv histogram debug:\n&quot;);</a>
<a name="ln179">  // for(int i=0;i&lt;100;i++) printf(&quot;%d =&gt; %f\n&quot;, i, inv_hist[hist[(int)CLAMP(HISTN*i/100.0, 0, HISTN-1)]]);</a>
<a name="ln180">  // for(int i=0;i&lt;100;i++) printf(&quot;[%d] %f =&gt; %f\n&quot;, i, hist[(int)CLAMP(HISTN*i/100.0, 0,</a>
<a name="ln181">  // HISTN-1)]/(float)HISTN, inv_hist[(int)CLAMP(HISTN*i/100.0, 0, HISTN-1)]);</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">#pragma GCC diagnostic push</a>
<a name="ln185">#pragma GCC diagnostic ignored &quot;-Wvla&quot;</a>
<a name="ln186"> </a>
<a name="ln187">static void get_cluster_mapping(const int n, float mi[n][2], float mo[n][2], int mapio[n])</a>
<a name="ln188">{</a>
<a name="ln189">  for(int ki = 0; ki &lt; n; ki++)</a>
<a name="ln190">  {</a>
<a name="ln191">    // for each input cluster</a>
<a name="ln192">    float mdist = FLT_MAX;</a>
<a name="ln193">    for(int ko = 0; ko &lt; n; ko++)</a>
<a name="ln194">    {</a>
<a name="ln195">      // find the best target cluster (the same could be used more than once)</a>
<a name="ln196">      const float dist = (mo[ko][0] - mi[ki][0]) * (mo[ko][0] - mi[ki][0])</a>
<a name="ln197">                         + (mo[ko][1] - mi[ki][1]) * (mo[ko][1] - mi[ki][1]);</a>
<a name="ln198">      if(dist &lt; mdist)</a>
<a name="ln199">      {</a>
<a name="ln200">        mdist = dist;</a>
<a name="ln201">        mapio[ki] = ko;</a>
<a name="ln202">      }</a>
<a name="ln203">    }</a>
<a name="ln204">  }</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">static void get_clusters(const float *col, const int n, float mean[n][2], float *weight)</a>
<a name="ln208">{</a>
<a name="ln209">  float Mdist = 0.0f, mdist = FLT_MAX;</a>
<a name="ln210">  for(int k = 0; k &lt; n; k++)</a>
<a name="ln211">  {</a>
<a name="ln212">    const float dist = (col[1] - mean[k][0]) * (col[1] - mean[k][0])</a>
<a name="ln213">                       + (col[2] - mean[k][1]) * (col[2] - mean[k][1]);</a>
<a name="ln214">    weight[k] = dist;</a>
<a name="ln215">    if(dist &lt; mdist) mdist = dist;</a>
<a name="ln216">    if(dist &gt; Mdist) Mdist = dist;</a>
<a name="ln217">  }</a>
<a name="ln218">  if(Mdist - mdist &gt; 0)</a>
<a name="ln219">    for(int k = 0; k &lt; n; k++) weight[k] = (weight[k] - mdist) / (Mdist - mdist);</a>
<a name="ln220">  float sum = 0.0f;</a>
<a name="ln221">  for(int k = 0; k &lt; n; k++) sum += weight[k];</a>
<a name="ln222">  if(sum &gt; 0)</a>
<a name="ln223">    for(int k = 0; k &lt; n; k++) weight[k] /= sum;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">static int get_cluster(const float *col, const int n, float mean[n][2])</a>
<a name="ln227">{</a>
<a name="ln228">  float mdist = FLT_MAX;</a>
<a name="ln229">  int cluster = 0;</a>
<a name="ln230">  for(int k = 0; k &lt; n; k++)</a>
<a name="ln231">  {</a>
<a name="ln232">    const float dist = (col[1] - mean[k][0]) * (col[1] - mean[k][0])</a>
<a name="ln233">                       + (col[2] - mean[k][1]) * (col[2] - mean[k][1]);</a>
<a name="ln234">    if(dist &lt; mdist)</a>
<a name="ln235">    {</a>
<a name="ln236">      mdist = dist;</a>
<a name="ln237">      cluster = k;</a>
<a name="ln238">    }</a>
<a name="ln239">  }</a>
<a name="ln240">  return cluster;</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243">static void kmeans(const float *col, const dt_iop_roi_t *const roi, const int n, float mean_out[n][2],</a>
<a name="ln244">                   float var_out[n][2])</a>
<a name="ln245">{</a>
<a name="ln246">  // TODO: check params here:</a>
<a name="ln247">  const int nit = 10;                                 // number of iterations</a>
<a name="ln248">  const int samples = roi-&gt;width * roi-&gt;height * 0.2; // samples: only a fraction of the buffer.</a>
<a name="ln249"> </a>
<a name="ln250">  float(*const mean)[2] = malloc(2 * n * sizeof(float));</a>
<a name="ln251">  float(*const var)[2] = malloc(2 * n * sizeof(float));</a>
<a name="ln252">  int *const cnt = malloc(n * sizeof(int));</a>
<a name="ln253"> </a>
<a name="ln254">  // init n clusters for a, b channels at random</a>
<a name="ln255">  for(int k = 0; k &lt; n; k++)</a>
<a name="ln256">  {</a>
<a name="ln257">    mean_out[k][0] = 20.0f - 40.0f * dt_points_get();</a>
<a name="ln258">    mean_out[k][1] = 20.0f - 40.0f * dt_points_get();</a>
<a name="ln259">    var_out[k][0] = var_out[k][1] = 0.0f;</a>
<a name="ln260">    mean[k][0] = mean[k][1] = var[k][0] = var[k][1] = 0.0f;</a>
<a name="ln261">  }</a>
<a name="ln262">  for(int it = 0; it &lt; nit; it++)</a>
<a name="ln263">  {</a>
<a name="ln264">    for(int k = 0; k &lt; n; k++) cnt[k] = 0;</a>
<a name="ln265">// randomly sample col positions inside roi</a>
<a name="ln266">#ifdef _OPENMP</a>
<a name="ln267">#pragma omp parallel for default(none) \</a>
<a name="ln268">    dt_omp_firstprivate(cnt, mean, n, roi, samples, var) \</a>
<a name="ln269">    shared(col, mean_out) \</a>
<a name="ln270">    schedule(static)</a>
<a name="ln271">#endif</a>
<a name="ln272">    for(int s = 0; s &lt; samples; s++)</a>
<a name="ln273">    {</a>
<a name="ln274">      const int j = dt_points_get() * roi-&gt;height, i = dt_points_get() * roi-&gt;width;</a>
<a name="ln275">      // for each sample: determine cluster, update new mean, update var</a>
<a name="ln276">      for(int k = 0; k &lt; n; k++)</a>
<a name="ln277">      {</a>
<a name="ln278">        const float L = col[3 * (roi-&gt;width * j + i)];</a>
<a name="ln279">        const float Lab[3] = { L, col[3 * (roi-&gt;width * j + i) + 1], col[3 * (roi-&gt;width * j + i) + 2] };</a>
<a name="ln280">        // determine dist to mean_out</a>
<a name="ln281">        const int c = get_cluster(Lab, n, mean_out);</a>
<a name="ln282">#ifdef _OPENMP</a>
<a name="ln283">#pragma omp atomic</a>
<a name="ln284">#endif</a>
<a name="ln285">        cnt[c]++;</a>
<a name="ln286">// update mean, var</a>
<a name="ln287">#ifdef _OPENMP</a>
<a name="ln288">#pragma omp atomic</a>
<a name="ln289">#endif</a>
<a name="ln290">        var[c][0] += Lab[1] * Lab[1];</a>
<a name="ln291">#ifdef _OPENMP</a>
<a name="ln292">#pragma omp atomic</a>
<a name="ln293">#endif</a>
<a name="ln294">        var[c][1] += Lab[2] * Lab[2];</a>
<a name="ln295">#ifdef _OPENMP</a>
<a name="ln296">#pragma omp atomic</a>
<a name="ln297">#endif</a>
<a name="ln298">        mean[c][0] += Lab[1];</a>
<a name="ln299">#ifdef _OPENMP</a>
<a name="ln300">#pragma omp atomic</a>
<a name="ln301">#endif</a>
<a name="ln302">        mean[c][1] += Lab[2];</a>
<a name="ln303">      }</a>
<a name="ln304">    }</a>
<a name="ln305">    // swap old/new means</a>
<a name="ln306">    for(int k = 0; k &lt; n; k++)</a>
<a name="ln307">    {</a>
<a name="ln308">      if(cnt[k] == 0) continue;</a>
<a name="ln309">      mean_out[k][0] = mean[k][0] / cnt[k];</a>
<a name="ln310">      mean_out[k][1] = mean[k][1] / cnt[k];</a>
<a name="ln311">      var_out[k][0] = var[k][0] / cnt[k] - mean_out[k][0] * mean_out[k][0];</a>
<a name="ln312">      var_out[k][1] = var[k][1] / cnt[k] - mean_out[k][1] * mean_out[k][1];</a>
<a name="ln313">      mean[k][0] = mean[k][1] = var[k][0] = var[k][1] = 0.0f;</a>
<a name="ln314">    }</a>
<a name="ln315">    // printf(&quot;it %d  %d means:\n&quot;, it, n);</a>
<a name="ln316">    // for(int k=0;k&lt;n;k++) printf(&quot;%f %f -- var %f %f\n&quot;, mean_out[k][0], mean_out[k][1], var_out[k][0],</a>
<a name="ln317">    // var_out[k][1]);</a>
<a name="ln318">  }</a>
<a name="ln319">  free(cnt);</a>
<a name="ln320">  free(var);</a>
<a name="ln321">  free(mean);</a>
<a name="ln322">  for(int k = 0; k &lt; n; k++)</a>
<a name="ln323">  {</a>
<a name="ln324">    // we actually want the std deviation.</a>
<a name="ln325">    var_out[k][0] = sqrtf(var_out[k][0]);</a>
<a name="ln326">    var_out[k][1] = sqrtf(var_out[k][1]);</a>
<a name="ln327">  }</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">#pragma GCC diagnostic pop</a>
<a name="ln331"> </a>
<a name="ln332">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln333">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln334">{</a>
<a name="ln335">  // FIXME: this returns nan!!</a>
<a name="ln336">  dt_iop_colortransfer_data_t *data = (dt_iop_colortransfer_data_t *)piece-&gt;data;</a>
<a name="ln337">  float *in = (float *)ivoid;</a>
<a name="ln338">  float *out = (float *)ovoid;</a>
<a name="ln339">  const int ch = piece-&gt;colors;</a>
<a name="ln340"> </a>
<a name="ln341">  if(data-&gt;flag == ACQUIRE)</a>
<a name="ln342">  {</a>
<a name="ln343">    if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln344">    {</a>
<a name="ln345">      // only get stuff from the preview pipe, rest stays untouched.</a>
<a name="ln346">      int hist[HISTN];</a>
<a name="ln347">      // get histogram of L</a>
<a name="ln348">      capture_histogram(in, roi_in, hist);</a>
<a name="ln349">      // invert histogram of L</a>
<a name="ln350">      invert_histogram(hist, data-&gt;hist);</a>
<a name="ln351"> </a>
<a name="ln352">      // get n clusters</a>
<a name="ln353">      kmeans(in, roi_in, data-&gt;n, data-&gt;mean, data-&gt;var);</a>
<a name="ln354"> </a>
<a name="ln355">      // notify gui that commit_params should let stuff flow back!</a>
<a name="ln356">      data-&gt;flag = ACQUIRED;</a>
<a name="ln357">      dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln358">      p-&gt;flag = ACQUIRE2;</a>
<a name="ln359">    }</a>
<a name="ln360">    memcpy(out, in, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln361">  }</a>
<a name="ln362">  else if(data-&gt;flag == APPLY)</a>
<a name="ln363">  {</a>
<a name="ln364">    // apply histogram of L and clustering of (a,b)</a>
<a name="ln365">    int hist[HISTN];</a>
<a name="ln366">    capture_histogram(in, roi_in, hist);</a>
<a name="ln367">#ifdef _OPENMP</a>
<a name="ln368">#pragma omp parallel for default(none) \</a>
<a name="ln369">    dt_omp_firstprivate(ch, roi_out) \</a>
<a name="ln370">    shared(data, in, out, hist) \</a>
<a name="ln371">    schedule(static)</a>
<a name="ln372">#endif</a>
<a name="ln373">    for(int k = 0; k &lt; roi_out-&gt;height; k++)</a>
<a name="ln374">    {</a>
<a name="ln375">      size_t j = (size_t)ch * roi_out-&gt;width * k;</a>
<a name="ln376">      for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln377">      {</a>
<a name="ln378">        // L: match histogram</a>
<a name="ln379">        out[j] = data-&gt;hist[hist[(int)CLAMP(HISTN * in[j] / 100.0, 0, HISTN - 1)]];</a>
<a name="ln380">        out[j] = CLAMP(out[j], 0, 100);</a>
<a name="ln381">        j += ch;</a>
<a name="ln382">      }</a>
<a name="ln383">    }</a>
<a name="ln384"> </a>
<a name="ln385">    // cluster input buffer</a>
<a name="ln386">    float(*const mean)[2] = malloc(2 * data-&gt;n * sizeof(float));</a>
<a name="ln387">    float(*const var)[2] = malloc(2 * data-&gt;n * sizeof(float));</a>
<a name="ln388"> </a>
<a name="ln389">    kmeans(in, roi_in, data-&gt;n, mean, var);</a>
<a name="ln390"> </a>
<a name="ln391">    // get mapping from input clusters to target clusters</a>
<a name="ln392">    int *const mapio = malloc(data-&gt;n * sizeof(int));</a>
<a name="ln393"> </a>
<a name="ln394">    get_cluster_mapping(data-&gt;n, mean, data-&gt;mean, mapio);</a>
<a name="ln395"> </a>
<a name="ln396">// for all pixels: find input cluster, transfer to mapped target cluster</a>
<a name="ln397">#ifdef _OPENMP</a>
<a name="ln398">#pragma omp parallel for default(none) \</a>
<a name="ln399">    dt_omp_firstprivate(ch, mapio, mean, roi_out, var) \</a>
<a name="ln400">    shared(data, in, out) \</a>
<a name="ln401">    schedule(static) </a>
<a name="ln402">#endif</a>
<a name="ln403">    for(int k = 0; k &lt; roi_out-&gt;height; k++)</a>
<a name="ln404">    {</a>
<a name="ln405">      float weight[MAXN];</a>
<a name="ln406">      size_t j = (size_t)ch * roi_out-&gt;width * k;</a>
<a name="ln407">      for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln408">      {</a>
<a name="ln409">        const float L = in[j];</a>
<a name="ln410">        const float Lab[3] = { L, in[j + 1], in[j + 2] };</a>
<a name="ln411">// a, b: subtract mean, scale nvar/var, add nmean</a>
<a name="ln412">#if 0 // single cluster, gives color banding</a>
<a name="ln413">        const int ki = get_cluster(in + j, data-&gt;n, mean);</a>
<a name="ln414">        out[j+1] = 100.0/out[j] * ((Lab[1] - mean[ki][0])*data-&gt;var[mapio[ki]][0]/var[ki][0] + data-&gt;mean[mapio[ki]][0]);</a>
<a name="ln415">        out[j+2] = 100.0/out[j] * ((Lab[2] - mean[ki][1])*data-&gt;var[mapio[ki]][1]/var[ki][1] + data-&gt;mean[mapio[ki]][1]);</a>
<a name="ln416">#else // fuzzy weighting</a>
<a name="ln417">        get_clusters(in + j, data-&gt;n, mean, weight);</a>
<a name="ln418">        out[j + 1] = out[j + 2] = 0.0f;</a>
<a name="ln419">        for(int c = 0; c &lt; data-&gt;n; c++)</a>
<a name="ln420">        {</a>
<a name="ln421">          out[j + 1] += weight[c] * ((Lab[1] - mean[c][0]) * data-&gt;var[mapio[c]][0] / var[c][0]</a>
<a name="ln422">                                     + data-&gt;mean[mapio[c]][0]);</a>
<a name="ln423">          out[j + 2] += weight[c] * ((Lab[2] - mean[c][1]) * data-&gt;var[mapio[c]][1] / var[c][1]</a>
<a name="ln424">                                     + data-&gt;mean[mapio[c]][1]);</a>
<a name="ln425">        }</a>
<a name="ln426">#endif</a>
<a name="ln427">        out[j + 3] = in[j + 3];</a>
<a name="ln428">        j += ch;</a>
<a name="ln429">      }</a>
<a name="ln430">    }</a>
<a name="ln431"> </a>
<a name="ln432">    free(mapio);</a>
<a name="ln433">    free(var);</a>
<a name="ln434">    free(mean);</a>
<a name="ln435">  }</a>
<a name="ln436">  else</a>
<a name="ln437">  {</a>
<a name="ln438">    memcpy(out, in, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln439">  }</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">#if 0</a>
<a name="ln443">static void</a>
<a name="ln444">spinbutton_changed (GtkSpinButton *button, dt_iop_module_t *self)</a>
<a name="ln445">{</a>
<a name="ln446">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln447">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln448">//  dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln449">  p-&gt;n = gtk_spin_button_get_value(button);</a>
<a name="ln450">  memset(p-&gt;hist,0, sizeof(float)*HISTN);</a>
<a name="ln451">  memset(p-&gt;mean,0, sizeof(float)*MAXN*2);</a>
<a name="ln452">  memset(p-&gt;var,0,  sizeof(float)*MAXN*2);</a>
<a name="ln453">  dt_control_queue_redraw_widget(self-&gt;widget);</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">static void</a>
<a name="ln457">acquire_button_pressed (GtkButton *button, dt_iop_module_t *self)</a>
<a name="ln458">{</a>
<a name="ln459">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln460">  // request color pick</a>
<a name="ln461">  // needed to trigger expose events:</a>
<a name="ln462">  self-&gt;request_color_pick = DT_REQUEST_COLORPICK_MODULE;</a>
<a name="ln463">  self-&gt;color_picker_box[0] = self-&gt;color_picker_box[1] = 0.0f;</a>
<a name="ln464">  self-&gt;color_picker_box[2] = self-&gt;color_picker_box[3] = 1.0f;</a>
<a name="ln465">  self-&gt;color_picker_point[0] = self-&gt;color_picker_point[1] = 0.5f;</a>
<a name="ln466">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln467">  p-&gt;flag = ACQUIRE;</a>
<a name="ln468">  if(self-&gt;off) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self-&gt;off), 1);</a>
<a name="ln469">  dt_dev_add_history_item(darktable.develop, self, TRUE); // FIXME: Why do we need to add this to the history?</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">static void</a>
<a name="ln473">apply_button_pressed (GtkButton *button, dt_iop_module_t *self)</a>
<a name="ln474">{</a>
<a name="ln475">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln476">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln477">  dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln478">  memcpy(p, &amp;(g-&gt;flowback), self-&gt;params_size);</a>
<a name="ln479">  p-&gt;flag = APPLY;</a>
<a name="ln480">  if(self-&gt;off) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self-&gt;off), 1);</a>
<a name="ln481">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">static gboolean</a>
<a name="ln485">expose (GtkWidget *widget, GdkEventExpose *event, dt_iop_module_t *self)</a>
<a name="ln486">{</a>
<a name="ln487">  // this is called whenever the pipeline finishes processing (i.e. after a color pick)</a>
<a name="ln488">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln489">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln490">  if(p-&gt;flag == ACQUIRED)</a>
<a name="ln491">  {</a>
<a name="ln492">    // clear the color picking request if we got the cluster data</a>
<a name="ln493">    self-&gt;request_color_pick = DT_REQUEST_COLORPICK_OFF;</a>
<a name="ln494">    p-&gt;flag = NEUTRAL;</a>
<a name="ln495">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln496">  }</a>
<a name="ln497">  else if(p-&gt;flag == ACQUIRE2)</a>
<a name="ln498">  {</a>
<a name="ln499">    // color pick is still on, so the data has to be still in the pipe,</a>
<a name="ln500">    // toggle a commit_params</a>
<a name="ln501">    p-&gt;flag = ACQUIRE3;</a>
<a name="ln502">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln503">    self-&gt;request_color_pick = DT_REQUEST_COLORPICK_OFF;</a>
<a name="ln504">  }</a>
<a name="ln505">  return FALSE;</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">void commit_params (struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln509">{</a>
<a name="ln510">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)p1;</a>
<a name="ln511">  dt_iop_colortransfer_data_t *d = (dt_iop_colortransfer_data_t *)piece-&gt;data;</a>
<a name="ln512">  if(p-&gt;flag == ACQUIRE3 &amp;&amp; d-&gt;flag == ACQUIRED)</a>
<a name="ln513">  {</a>
<a name="ln514">    // if data is flagged ACQUIRED, actually copy data back from pipe!</a>
<a name="ln515">    d-&gt;flag = NEUTRAL;</a>
<a name="ln516">    p-&gt;flag = ACQUIRED; // let gui know the data is there.</a>
<a name="ln517">    if(self-&gt;dev == darktable.develop &amp;&amp; self-&gt;gui_data)</a>
<a name="ln518">    {</a>
<a name="ln519">      dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln520">      memcpy (&amp;g-&gt;flowback, d, self-&gt;params_size);</a>
<a name="ln521">      g-&gt;flowback_set = 1;</a>
<a name="ln522">      FILE *f = g_fopen(&quot;/tmp/dt_colortransfer_loaded&quot;, &quot;wb&quot;);</a>
<a name="ln523">      if(f)</a>
<a name="ln524">      {</a>
<a name="ln525">        if(fwrite(&amp;g-&gt;flowback, self-&gt;params_size, 1, f) &gt; 0) g-&gt;flowback.flag = APPLY;</a>
<a name="ln526">        fclose(f);</a>
<a name="ln527">      }</a>
<a name="ln528">      dt_control_queue_redraw_widget(self-&gt;widget);</a>
<a name="ln529">    }</a>
<a name="ln530">  }</a>
<a name="ln531">  else</a>
<a name="ln532">  {</a>
<a name="ln533">    // dt_iop_colortransfer_flag_t flag = d-&gt;flag;</a>
<a name="ln534">    memcpy(d, p, self-&gt;params_size);</a>
<a name="ln535">    // only allow apply and acquire commands from gui.</a>
<a name="ln536">    // if(p-&gt;flag != APPLY &amp;&amp; p-&gt;flag != ACQUIRE &amp;&amp; p-&gt;flag != NEUTRAL) d-&gt;flag = flag;</a>
<a name="ln537">    if(p-&gt;flag == ACQUIRE2) d-&gt;flag = ACQUIRE;</a>
<a name="ln538">    if(p-&gt;flag == ACQUIRE3) d-&gt;flag = NEUTRAL;</a>
<a name="ln539">    if(p-&gt;flag == ACQUIRED) d-&gt;flag = NEUTRAL;</a>
<a name="ln540">    // if(p-&gt;flag == ACQUIRE) p-&gt;flag = ACQUIRE2;</a>
<a name="ln541">  }</a>
<a name="ln542">}</a>
<a name="ln543">#endif</a>
<a name="ln544"> </a>
<a name="ln545">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln546">{</a>
<a name="ln547">  piece-&gt;data = malloc(sizeof(dt_iop_colortransfer_data_t));</a>
<a name="ln548">  dt_iop_colortransfer_data_t *d = (dt_iop_colortransfer_data_t *)piece-&gt;data;</a>
<a name="ln549">  d-&gt;flag = NEUTRAL;</a>
<a name="ln550">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln554">{</a>
<a name="ln555">  free(piece-&gt;data);</a>
<a name="ln556">  piece-&gt;data = NULL;</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln560">{</a>
<a name="ln561">#if 0</a>
<a name="ln562">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln563">  dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln564">  gtk_spin_button_set_value(g-&gt;spinbutton, p-&gt;n);</a>
<a name="ln565">  //gtk_widget_set_size_request(GTK_WIDGET(g-&gt;area), 300, MIN(100, 300/p-&gt;n));</a>
<a name="ln566">  // redraw color cluster preview</a>
<a name="ln567">  dt_control_queue_redraw_widget(self-&gt;widget);</a>
<a name="ln568">#endif</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">void init(dt_iop_module_t *module)</a>
<a name="ln572">{</a>
<a name="ln573">  // module-&gt;data = malloc(sizeof(dt_iop_colortransfer_data_t));</a>
<a name="ln574">  module-&gt;params = calloc(1, sizeof(dt_iop_colortransfer_params_t));</a>
<a name="ln575">  module-&gt;default_params = calloc(1, sizeof(dt_iop_colortransfer_params_t));</a>
<a name="ln576">  module-&gt;default_enabled = 0;</a>
<a name="ln577">  module-&gt;params_size = sizeof(dt_iop_colortransfer_params_t);</a>
<a name="ln578">  module-&gt;gui_data = NULL;</a>
<a name="ln579">  dt_iop_colortransfer_params_t tmp;</a>
<a name="ln580">  tmp.flag = NEUTRAL;</a>
<a name="ln581">  memset(tmp.hist, 0, sizeof(float) * HISTN);</a>
<a name="ln582">  memset(tmp.mean, 0, sizeof(float) * MAXN * 2);</a>
<a name="ln583">  memset(tmp.var, 0, sizeof(float) * MAXN * 2);</a>
<a name="ln584">  tmp.n = 3;</a>
<a name="ln585">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_colortransfer_params_t));</a>
<a name="ln586">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_colortransfer_params_t));</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">void cleanup(dt_iop_module_t *module)</a>
<a name="ln590">{</a>
<a name="ln591">  free(module-&gt;params);</a>
<a name="ln592">  module-&gt;params = NULL;</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595">#if 0</a>
<a name="ln596">static gboolean</a>
<a name="ln597">cluster_preview_draw (GtkWidget *widget, cairo_t *crf, dt_iop_module_t *self)</a>
<a name="ln598">{</a>
<a name="ln599">  // dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln600">  dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln601">  dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)&amp;g-&gt;flowback;</a>
<a name="ln602">  if(!g-&gt;flowback_set) p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln603">  const int inset = 5;</a>
<a name="ln604">  int width = allocation.width, height = allocation.height;</a>
<a name="ln605">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln606">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln607">  cairo_set_source_rgb (cr, .2, .2, .2);</a>
<a name="ln608">  cairo_paint(cr);</a>
<a name="ln609"> </a>
<a name="ln610">  cairo_translate(cr, inset, inset);</a>
<a name="ln611">  width -= 2*inset;</a>
<a name="ln612">  height -= 2*inset;</a>
<a name="ln613"> </a>
<a name="ln614">  if(g-&gt;flowback_set) gtk_widget_set_sensitive(g-&gt;apply_button, TRUE);</a>
<a name="ln615">#if 0</a>
<a name="ln616">  if(g-&gt;flowback_set)</a>
<a name="ln617">  {</a>
<a name="ln618">    memcpy(self-&gt;params, &amp;g-&gt;flowback, self-&gt;params_size);</a>
<a name="ln619">    g-&gt;flowback_set = 0;</a>
<a name="ln620">    p-&gt;flag = APPLY;</a>
<a name="ln621">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln622">  }</a>
<a name="ln623">#endif</a>
<a name="ln624"> </a>
<a name="ln625">  const float sep = 2.0;</a>
<a name="ln626">  const float qwd = (width-(p-&gt;n-1)*sep)/(float)p-&gt;n;</a>
<a name="ln627">  for(int cl=0; cl&lt;p-&gt;n; cl++)</a>
<a name="ln628">  {</a>
<a name="ln629">    // draw cluster</a>
<a name="ln630">    for(int j=-1; j&lt;=1; j++) for(int i=-1; i&lt;=1; i++)</a>
<a name="ln631">      {</a>
<a name="ln632">        // draw 9x9 grid showing mean and variance of this cluster.</a>
<a name="ln633">        double rgb[3] = {0.5, 0.5, 0.5};</a>
<a name="ln634">        cmsCIELab Lab;</a>
<a name="ln635">        Lab.L = 5.0;//53.390011;</a>
<a name="ln636">        Lab.a = (p-&gt;mean[cl][0] + i*p-&gt;var[cl][0]);// / Lab.L;</a>
<a name="ln637">        Lab.b = (p-&gt;mean[cl][1] + j*p-&gt;var[cl][1]);// / Lab.L;</a>
<a name="ln638">        Lab.L = 53.390011;</a>
<a name="ln639">        cmsDoTransform(g-&gt;xform, &amp;Lab, rgb, 1);</a>
<a name="ln640">        cairo_set_source_rgb (cr, rgb[0], rgb[1], rgb[2]);</a>
<a name="ln641">        cairo_rectangle(cr, qwd*(i+1)/3.0, height*(j+1)/3.0, qwd/3.0-.5, height/3.0-.5);</a>
<a name="ln642">        cairo_fill(cr);</a>
<a name="ln643">      }</a>
<a name="ln644">    cairo_translate (cr, qwd + sep, 0);</a>
<a name="ln645">  }</a>
<a name="ln646"> </a>
<a name="ln647">  cairo_destroy(cr);</a>
<a name="ln648">  cairo_set_source_surface (crf, cst, 0, 0);</a>
<a name="ln649">  cairo_paint(crf);</a>
<a name="ln650">  cairo_surface_destroy(cst);</a>
<a name="ln651">  return TRUE;</a>
<a name="ln652">}</a>
<a name="ln653">#endif</a>
<a name="ln654"> </a>
<a name="ln655">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln656">{</a>
<a name="ln657"> </a>
<a name="ln658">  self-&gt;gui_data = malloc(sizeof(dt_iop_colortransfer_gui_data_t));</a>
<a name="ln659">  self-&gt;widget = gtk_label_new(_(&quot;this module will be removed in the future\nand is only here so you can &quot;</a>
<a name="ln660">                                 &quot;switch it off\nand move to the new color mapping module.&quot;));</a>
<a name="ln661">  gtk_widget_set_halign(self-&gt;widget, GTK_ALIGN_START);</a>
<a name="ln662"> </a>
<a name="ln663">#if 0</a>
<a name="ln664">  self-&gt;gui_data = malloc(sizeof(dt_iop_colortransfer_gui_data_t));</a>
<a name="ln665">  dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln666">  // dt_iop_colortransfer_params_t *p = (dt_iop_colortransfer_params_t *)self-&gt;params;</a>
<a name="ln667"> </a>
<a name="ln668">  g-&gt;flowback_set = 0;</a>
<a name="ln669">  cmsHPROFILE hsRGB = dt_colorspaces_get_profile(DT_COLORSPACE_SRGB, &quot;&quot;, DT_PROFILE_DIRECTION_IN)-&gt;profile;</a>
<a name="ln670">  cmsHPROFILE hLab  = dt_colorspaces_get_profile(DT_COLORSPACE_LAB, &quot;&quot;, DT_PROFILE_DIRECTION_ANY)-&gt;profile;</a>
<a name="ln671">  g-&gt;xform = cmsCreateTransform(hLab, TYPE_Lab_DBL, hsRGB, TYPE_RGB_DBL, INTENT_PERCEPTUAL, 0);</a>
<a name="ln672"> </a>
<a name="ln673">  self-&gt;widget = GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_GUI_IOP_MODULE_CONTROL_SPACING));</a>
<a name="ln674">  g_signal_connect (G_OBJECT(self-&gt;widget), &quot;draw&quot;,</a>
<a name="ln675">                    G_CALLBACK(draw), self);</a>
<a name="ln676"> </a>
<a name="ln677">  g-&gt;area = gtk_drawing_area_new();</a>
<a name="ln678">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;area), 300, 100);</a>
<a name="ln679">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;area, TRUE, TRUE, 0);</a>
<a name="ln680">  g_signal_connect (G_OBJECT (g-&gt;area), &quot;draw&quot;, G_CALLBACK (cluster_preview_draw), self);</a>
<a name="ln681"> </a>
<a name="ln682">  GtkBox *box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln683">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(box), TRUE, TRUE, 0);</a>
<a name="ln684">  GtkWidget *button;</a>
<a name="ln685">  g-&gt;spinbutton = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(1, MAXN, 1));</a>
<a name="ln686">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;spinbutton), _(&quot;number of clusters to find in image&quot;));</a>
<a name="ln687">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;spinbutton), FALSE, FALSE, 0);</a>
<a name="ln688">  g_signal_connect(G_OBJECT(g-&gt;spinbutton), &quot;value-changed&quot;, G_CALLBACK(spinbutton_changed), (gpointer)self);</a>
<a name="ln689"> </a>
<a name="ln690">  button = gtk_button_new_with_label(_(&quot;acquire&quot;));</a>
<a name="ln691">  g-&gt;acquire_button = button;</a>
<a name="ln692">  gtk_widget_set_tooltip_text(button, _(&quot;analyze this image&quot;));</a>
<a name="ln693">  gtk_box_pack_start(box, button, TRUE, TRUE, 0);</a>
<a name="ln694">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(acquire_button_pressed), (gpointer)self);</a>
<a name="ln695"> </a>
<a name="ln696">  g-&gt;apply_button = gtk_button_new_with_label(_(&quot;apply&quot;));</a>
<a name="ln697">  gtk_widget_set_tooltip_text(g-&gt;apply_button, _(&quot;apply previously analyzed image look to this image&quot;));</a>
<a name="ln698">  gtk_box_pack_start(box, g-&gt;apply_button, TRUE, TRUE, 0);</a>
<a name="ln699">  g_signal_connect(G_OBJECT(g-&gt;apply_button), &quot;clicked&quot;, G_CALLBACK(apply_button_pressed), (gpointer)self);</a>
<a name="ln700">  FILE *f = g_fopen(&quot;/tmp/dt_colortransfer_loaded&quot;, &quot;rb&quot;);</a>
<a name="ln701">  if(f)</a>
<a name="ln702">  {</a>
<a name="ln703">    if(fread(&amp;g-&gt;flowback, self-&gt;params_size, 1, f) &gt; 0) g-&gt;flowback_set = 1;</a>
<a name="ln704">    fclose(f);</a>
<a name="ln705">  }</a>
<a name="ln706">  else gtk_widget_set_sensitive(GTK_WIDGET(g-&gt;apply_button), FALSE);</a>
<a name="ln707">#endif</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln711">{</a>
<a name="ln712">  //  dt_iop_colortransfer_gui_data_t *g = (dt_iop_colortransfer_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln713">  //  cmsDeleteTransform(g-&gt;xform);</a>
<a name="ln714">  free(self-&gt;gui_data);</a>
<a name="ln715">  self-&gt;gui_data = NULL;</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln719">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln720">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="260"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'mean'. Check lines: 260, 250.</p></div>
<div class="balloon" rel="260"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'var'. Check lines: 260, 251.</p></div>
<div class="balloon" rel="264"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'cnt'. Check lines: 264, 252.</p></div>
<div class="balloon" rel="421"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'mean'. Check lines: 421, 386.</p></div>
<div class="balloon" rel="421"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'mapio'. Check lines: 421, 392.</p></div>
<div class="balloon" rel="421"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'var'. Check lines: 421, 387.</p></div>
<div class="balloon" rel="549"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 549, 547.</p></div>
<div class="balloon" rel="585"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 585, 574.</p></div>
<div class="balloon" rel="586"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 586, 575.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
