
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010-2011 Jose Carlos Garcia Sogo</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/file_location.h&quot;</a>
<a name="ln22">#include &quot;common/image.h&quot;</a>
<a name="ln23">#include &quot;common/image_cache.h&quot;</a>
<a name="ln24">#include &quot;common/imageio.h&quot;</a>
<a name="ln25">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln26">#include &quot;common/metadata.h&quot;</a>
<a name="ln27">#include &quot;common/pwstorage/pwstorage.h&quot;</a>
<a name="ln28">#include &quot;common/tags.h&quot;</a>
<a name="ln29">#include &quot;control/conf.h&quot;</a>
<a name="ln30">#include &quot;control/control.h&quot;</a>
<a name="ln31">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln32">#include &quot;gui/gtk.h&quot;</a>
<a name="ln33">#include &quot;imageio/storage/imageio_storage_api.h&quot;</a>
<a name="ln34">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln35">#include &quot;osx/osx.h&quot;</a>
<a name="ln36">#endif</a>
<a name="ln37">#include &lt;curl/curl.h&gt;</a>
<a name="ln38">#include &lt;flickcurl.h&gt;</a>
<a name="ln39">#include &lt;stdio.h&gt;</a>
<a name="ln40">#include &lt;stdlib.h&gt;</a>
<a name="ln41">#include &lt;unistd.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">DT_MODULE(1)</a>
<a name="ln44"> </a>
<a name="ln45">#define API_KEY &quot;1d25b2dfcceba8c55fecb27645c968a3&quot;</a>
<a name="ln46">#define SHARED_SECRET &quot;ac66b6c212be6f0c&quot;</a>
<a name="ln47"> </a>
<a name="ln48">typedef struct _flickr_api_context_t</a>
<a name="ln49">{</a>
<a name="ln50">  flickcurl *fc;</a>
<a name="ln51"> </a>
<a name="ln52">  gboolean needsReauthentication;</a>
<a name="ln53"> </a>
<a name="ln54">  /** Current album used when posting images... */</a>
<a name="ln55">  flickcurl_photoset *current_album;</a>
<a name="ln56"> </a>
<a name="ln57">  char *album_title;</a>
<a name="ln58">  char *album_summary;</a>
<a name="ln59">  int album_public;</a>
<a name="ln60">  gboolean new_album;</a>
<a name="ln61">  gboolean error_occured;</a>
<a name="ln62"> </a>
<a name="ln63">} _flickr_api_context_t;</a>
<a name="ln64"> </a>
<a name="ln65">typedef struct dt_storage_flickr_gui_data_t</a>
<a name="ln66">{</a>
<a name="ln67"> </a>
<a name="ln68">  GtkLabel *status_label;</a>
<a name="ln69">  GtkEntry *user_entry, *title_entry, *summary_entry;</a>
<a name="ln70">  GtkBox *create_box;                               // Create album options...</a>
<a name="ln71">  GtkWidget *permission_list, *album_list;</a>
<a name="ln72"> </a>
<a name="ln73">  char *user_token;</a>
<a name="ln74"> </a>
<a name="ln75">  /* List of albums */</a>
<a name="ln76">  flickcurl_photoset **albums;</a>
<a name="ln77"> </a>
<a name="ln78">  /** Current Flickr context for the gui */</a>
<a name="ln79">  _flickr_api_context_t *flickr_api;</a>
<a name="ln80"> </a>
<a name="ln81">} dt_storage_flickr_gui_data_t;</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">typedef struct dt_storage_flickr_params_t</a>
<a name="ln85">{</a>
<a name="ln86">  int64_t hash;</a>
<a name="ln87">  _flickr_api_context_t *flickr_api;</a>
<a name="ln88">  gboolean export_tags;   // deprecated. let here not to change params size. to be removed on next version change</a>
<a name="ln89">  gboolean public_perm;</a>
<a name="ln90">  gboolean friend_perm;</a>
<a name="ln91">  gboolean family_perm;</a>
<a name="ln92">} dt_storage_flickr_params_t;</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">/** Authenticates and retrieves an initialized flickr api object */</a>
<a name="ln96">static _flickr_api_context_t *_flickr_api_authenticate(dt_storage_flickr_gui_data_t *ui);</a>
<a name="ln97"> </a>
<a name="ln98">static flickcurl_upload_status *_flickr_api_upload_photo(dt_storage_flickr_params_t *params, char *data,</a>
<a name="ln99">                                                         char *caption, char *description, gint imgid, uint32_t flags);</a>
<a name="ln100"> </a>
<a name="ln101">static void _flickr_api_free(_flickr_api_context_t *ctx)</a>
<a name="ln102">{</a>
<a name="ln103"> </a>
<a name="ln104">  g_free(ctx-&gt;album_title);</a>
<a name="ln105">  g_free(ctx-&gt;album_summary);</a>
<a name="ln106"> </a>
<a name="ln107">  if(ctx-&gt;current_album != NULL) flickcurl_free_photoset(ctx-&gt;current_album);</a>
<a name="ln108"> </a>
<a name="ln109">  flickcurl_free(ctx-&gt;fc);</a>
<a name="ln110"> </a>
<a name="ln111">  g_free(ctx);</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">static void _flickr_api_error_handler(void *data, const char *message)</a>
<a name="ln115">{</a>
<a name="ln116">  dt_control_log(_(&quot;flickr authentication: %s&quot;), message);</a>
<a name="ln117">  fprintf(stderr, &quot;[flickr] error: %s\n&quot;, message);</a>
<a name="ln118">  if(data)</a>
<a name="ln119">  {</a>
<a name="ln120">    _flickr_api_context_t *ctx = (_flickr_api_context_t *)data;</a>
<a name="ln121">    ctx-&gt;error_occured = 1;</a>
<a name="ln122">  }</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">static _flickr_api_context_t *_flickr_api_authenticate(dt_storage_flickr_gui_data_t *ui)</a>
<a name="ln126">{</a>
<a name="ln127">  char *perms = NULL, *frob;</a>
<a name="ln128">  gchar *token;</a>
<a name="ln129">  char *flickr_user_token = NULL;</a>
<a name="ln130">  gint result;</a>
<a name="ln131">  _flickr_api_context_t *ctx = (_flickr_api_context_t *)g_malloc0(sizeof(_flickr_api_context_t));</a>
<a name="ln132"> </a>
<a name="ln133">  flickcurl_init();</a>
<a name="ln134">  ctx-&gt;fc = flickcurl_new();</a>
<a name="ln135">  flickcurl_set_api_key(ctx-&gt;fc, API_KEY);</a>
<a name="ln136">  flickcurl_set_shared_secret(ctx-&gt;fc, SHARED_SECRET);</a>
<a name="ln137">  flickcurl_set_error_handler(ctx-&gt;fc, _flickr_api_error_handler, ctx);</a>
<a name="ln138"> </a>
<a name="ln139">  if(!ui-&gt;user_token)</a>
<a name="ln140">  {</a>
<a name="ln141">    // Retrieve stored auth_key</a>
<a name="ln142">    // TODO: We should be able to store token for different users</a>
<a name="ln143">    GHashTable *table = dt_pwstorage_get(&quot;flickr&quot;);</a>
<a name="ln144">    gchar *_username = g_strdup(g_hash_table_lookup(table, &quot;username&quot;));</a>
<a name="ln145">    gchar *_user_token = g_strdup(g_hash_table_lookup(table, &quot;token&quot;));</a>
<a name="ln146">    g_hash_table_destroy(table);</a>
<a name="ln147"> </a>
<a name="ln148">    if(_username)</a>
<a name="ln149">    {</a>
<a name="ln150">      if(!strcmp(_username, gtk_entry_get_text(ui-&gt;user_entry)))</a>
<a name="ln151">      {</a>
<a name="ln152">        flickr_user_token = g_strdup(_user_token);</a>
<a name="ln153">        perms = flickcurl_auth_checkToken(ctx-&gt;fc, flickr_user_token);</a>
<a name="ln154">      }</a>
<a name="ln155">      g_free(_username);</a>
<a name="ln156">    }</a>
<a name="ln157">    g_free(_user_token);</a>
<a name="ln158">  }</a>
<a name="ln159">  else</a>
<a name="ln160">  {</a>
<a name="ln161">    flickr_user_token = ui-&gt;user_token;</a>
<a name="ln162">    perms = flickcurl_auth_checkToken(ctx-&gt;fc, ui-&gt;user_token);</a>
<a name="ln163">  }</a>
<a name="ln164"> </a>
<a name="ln165"> </a>
<a name="ln166">  if(perms)</a>
<a name="ln167">  {</a>
<a name="ln168">    ui-&gt;user_token = flickr_user_token;</a>
<a name="ln169">    flickcurl_set_auth_token(ctx-&gt;fc, flickr_user_token);</a>
<a name="ln170">    return ctx;</a>
<a name="ln171">  }</a>
<a name="ln172">  else if(!ctx-&gt;error_occured)</a>
<a name="ln173">  {</a>
<a name="ln174">    frob = flickcurl_auth_getFrob(ctx-&gt;fc);</a>
<a name="ln175">    GError *error = NULL;</a>
<a name="ln176">    char *sign = g_strdup_printf(&quot;%sapi_key%sfrob%spermswrite&quot;, SHARED_SECRET, API_KEY, frob);</a>
<a name="ln177">    char *sign_md5 = g_compute_checksum_for_string(G_CHECKSUM_MD5, sign, strlen(sign));</a>
<a name="ln178">    gchar auth_url[250];</a>
<a name="ln179">    snprintf(auth_url, sizeof(auth_url),</a>
<a name="ln180">             &quot;https://flickr.com/services/auth/?api_key=%s&amp;perms=write&amp;frob=%s&amp;api_sig=%s&quot;, API_KEY, frob,</a>
<a name="ln181">             sign_md5);</a>
<a name="ln182"> </a>
<a name="ln183">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln184">    if(!gtk_show_uri_on_window(GTK_WINDOW(win), auth_url, gtk_get_current_event_time(), &amp;error))</a>
<a name="ln185">    {</a>
<a name="ln186">      fprintf(stderr, &quot;[flickr] error opening browser: %s\n&quot;, error-&gt;message);</a>
<a name="ln187">      g_error_free(error);</a>
<a name="ln188">    }</a>
<a name="ln189"> </a>
<a name="ln190">    g_free(sign);</a>
<a name="ln191">    g_free(sign_md5);</a>
<a name="ln192"> </a>
<a name="ln193">    // Hold here to let the user interact</a>
<a name="ln194">    // Show a dialog.</a>
<a name="ln195">    gchar *text1, *text2;</a>
<a name="ln196">    text1 = g_strdup(</a>
<a name="ln197">        _(&quot;step 1: a new window or tab of your browser should have been loaded. you have to login into your &quot;</a>
<a name="ln198">          &quot;flickr account there and authorize darktable to upload photos before continuing.&quot;));</a>
<a name="ln199">    text2 = g_strdup(_(&quot;step 2: click the OK button once you are done.&quot;));</a>
<a name="ln200"> </a>
<a name="ln201">    GtkWidget *window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln202">    GtkWidget *flickr_auth_dialog</a>
<a name="ln203">        = gtk_message_dialog_new(GTK_WINDOW(window), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_INFO,</a>
<a name="ln204">                                 GTK_BUTTONS_OK_CANCEL, _(&quot;flickr authentication&quot;));</a>
<a name="ln205">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln206">    dt_osx_disallow_fullscreen(flickr_auth_dialog);</a>
<a name="ln207">#endif</a>
<a name="ln208">    gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(flickr_auth_dialog), &quot;%s\n\n%s&quot;, text1, text2);</a>
<a name="ln209"> </a>
<a name="ln210">    result = gtk_dialog_run(GTK_DIALOG(flickr_auth_dialog));</a>
<a name="ln211"> </a>
<a name="ln212">    gtk_widget_destroy(flickr_auth_dialog);</a>
<a name="ln213"> </a>
<a name="ln214">    g_free(text1);</a>
<a name="ln215">    g_free(text2);</a>
<a name="ln216"> </a>
<a name="ln217">    switch(result)</a>
<a name="ln218">    {</a>
<a name="ln219">      case GTK_RESPONSE_OK:</a>
<a name="ln220">        token = flickcurl_auth_getToken(ctx-&gt;fc, frob);</a>
<a name="ln221">        g_free(frob);</a>
<a name="ln222">        // TODO: Handle timeouts errors</a>
<a name="ln223">        if(token)</a>
<a name="ln224">        {</a>
<a name="ln225">          flickr_user_token = g_strdup(token);</a>
<a name="ln226">        }</a>
<a name="ln227">        else</a>
<a name="ln228">        {</a>
<a name="ln229">          g_free(token);</a>
<a name="ln230">          _flickr_api_free(ctx);</a>
<a name="ln231">          return NULL;</a>
<a name="ln232">        }</a>
<a name="ln233">        ui-&gt;user_token = g_strdup(flickr_user_token);</a>
<a name="ln234">        flickcurl_set_auth_token(ctx-&gt;fc, flickr_user_token);</a>
<a name="ln235"> </a>
<a name="ln236">        /* Add creds to pwstorage */</a>
<a name="ln237">        GHashTable *table = g_hash_table_new(g_str_hash, g_str_equal);</a>
<a name="ln238">        gchar *username = (gchar *)gtk_entry_get_text(ui-&gt;user_entry);</a>
<a name="ln239"> </a>
<a name="ln240">        g_hash_table_insert(table, &quot;username&quot;, username);</a>
<a name="ln241">        g_hash_table_insert(table, &quot;token&quot;, flickr_user_token);</a>
<a name="ln242"> </a>
<a name="ln243">        if(!dt_pwstorage_set(&quot;flickr&quot;, table))</a>
<a name="ln244">        {</a>
<a name="ln245">          dt_print(DT_DEBUG_PWSTORAGE, &quot;[flickr] cannot store username/token\n&quot;);</a>
<a name="ln246">        }</a>
<a name="ln247"> </a>
<a name="ln248">        g_free(flickr_user_token);</a>
<a name="ln249">        g_hash_table_destroy(table);</a>
<a name="ln250"> </a>
<a name="ln251">        return ctx;</a>
<a name="ln252"> </a>
<a name="ln253">      default:</a>
<a name="ln254">        dt_print(DT_DEBUG_PWSTORAGE, &quot;[flickr] user cancelled the login process\n&quot;);</a>
<a name="ln255">        return NULL;</a>
<a name="ln256">    }</a>
<a name="ln257">  }</a>
<a name="ln258"> </a>
<a name="ln259">  free(perms);</a>
<a name="ln260"> </a>
<a name="ln261">  return NULL;</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264"> </a>
<a name="ln265">static flickcurl_upload_status *_flickr_api_upload_photo(dt_storage_flickr_params_t *p, char *fname,</a>
<a name="ln266">                                                         char *caption, char *description, gint imgid, uint32_t flags)</a>
<a name="ln267">{</a>
<a name="ln268"> </a>
<a name="ln269">  flickcurl_upload_params *params = g_malloc0(sizeof(flickcurl_upload_params));</a>
<a name="ln270">  flickcurl_upload_status *status;</a>
<a name="ln271"> </a>
<a name="ln272">  params-&gt;safety_level = 1; // Defaults to safe photos</a>
<a name="ln273">  params-&gt;content_type = 1; // Defaults to photo (we don't support video!)</a>
<a name="ln274"> </a>
<a name="ln275">  params-&gt;title = caption;</a>
<a name="ln276">  params-&gt;description = description;</a>
<a name="ln277"> </a>
<a name="ln278">  if(imgid)</a>
<a name="ln279">  {</a>
<a name="ln280">    GList *tags_list = dt_tag_get_list_export(imgid, flags);</a>
<a name="ln281">    params-&gt;tags = dt_util_glist_to_str(&quot;,&quot;, tags_list);</a>
<a name="ln282">    g_list_free_full(tags_list, g_free);</a>
<a name="ln283">  }</a>
<a name="ln284">  params-&gt;photo_file = fname; // fname should be the URI of temp file</a>
<a name="ln285"> </a>
<a name="ln286">  params-&gt;is_public = (int)p-&gt;public_perm;</a>
<a name="ln287">  params-&gt;is_friend = (int)p-&gt;friend_perm;</a>
<a name="ln288">  params-&gt;is_family = (int)p-&gt;family_perm;</a>
<a name="ln289"> </a>
<a name="ln290">  status = flickcurl_photos_upload_params(p-&gt;flickr_api-&gt;fc, params);</a>
<a name="ln291">  if(!status)</a>
<a name="ln292">  {</a>
<a name="ln293">    fprintf(stderr, &quot;[flickr] Something went wrong when uploading&quot;);</a>
<a name="ln294">    g_free((gchar *)params-&gt;tags);</a>
<a name="ln295">    g_free(params);</a>
<a name="ln296">    return NULL;</a>
<a name="ln297">  }</a>
<a name="ln298">  g_free((gchar *)params-&gt;tags);</a>
<a name="ln299">  g_free(params);</a>
<a name="ln300">  return status;</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">static char *_flickr_api_create_photoset(_flickr_api_context_t *ctx, const char *photo_id)</a>
<a name="ln305">{</a>
<a name="ln306">  char *photoset;</a>
<a name="ln307">  const char *title = ctx-&gt;album_title;</a>
<a name="ln308">  const char *summary = ctx-&gt;album_summary;</a>
<a name="ln309"> </a>
<a name="ln310">  photoset = flickcurl_photosets_create(ctx-&gt;fc, title, summary, photo_id, NULL);</a>
<a name="ln311">  if(!photoset) fprintf(stderr, &quot;[flickr] Something went wrong when creating gallery %s&quot;, title);</a>
<a name="ln312">  return photoset;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">const char *name(const struct dt_imageio_module_storage_t *self)</a>
<a name="ln316">{</a>
<a name="ln317">  return _(&quot;flickr webalbum&quot;);</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">/** Set status connection text */</a>
<a name="ln321">static void set_status(dt_storage_flickr_gui_data_t *ui, gchar *message, gchar *color)</a>
<a name="ln322">{</a>
<a name="ln323">  if(!color) color = &quot;#ffffff&quot;;</a>
<a name="ln324">  gchar mup[512] = { 0 };</a>
<a name="ln325">  snprintf(mup, sizeof(mup), &quot;&lt;span foreground=\&quot;%s\&quot; &gt;&lt;small&gt;%s&lt;/small&gt;&lt;/span&gt;&quot;, color, message);</a>
<a name="ln326">  gtk_label_set_markup(ui-&gt;status_label, mup);</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">static void flickr_entry_changed(GtkEntry *entry, gpointer data)</a>
<a name="ln330">{</a>
<a name="ln331">  dt_storage_flickr_gui_data_t *ui = (dt_storage_flickr_gui_data_t *)data;</a>
<a name="ln332"> </a>
<a name="ln333">  if(ui-&gt;flickr_api != NULL)</a>
<a name="ln334">  {</a>
<a name="ln335">    ui-&gt;flickr_api-&gt;needsReauthentication = TRUE;</a>
<a name="ln336">    g_free(ui-&gt;user_token);</a>
<a name="ln337">    ui-&gt;user_token = NULL;</a>
<a name="ln338">    set_status(ui, _(&quot;not authenticated&quot;), &quot;#e07f7f&quot;);</a>
<a name="ln339">    gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;album_list), FALSE);</a>
<a name="ln340">  }</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">static flickcurl_photoset **_flickr_api_photosets(_flickr_api_context_t *ctx, const char *user)</a>
<a name="ln344">{</a>
<a name="ln345">  flickcurl_photoset **photoset;</a>
<a name="ln346">  //  char *nsid;</a>
<a name="ln347"> </a>
<a name="ln348">  // TODO: Support both userid and email. As more services uses email as username</a>
<a name="ln349">  //      users can confuse the needed id to be introduced in the user field.</a>
<a name="ln350">  //  nsid = flickcurl_people_findByEmail(ctx-&gt;fc, &quot;@&quot;);</a>
<a name="ln351"> </a>
<a name="ln352">  //  no need to specify nsid at all</a>
<a name="ln353">  //  nsid = flickcurl_people_findByUsername(ctx-&gt;fc, user);</a>
<a name="ln354"> </a>
<a name="ln355">  // &quot;If none is specified, the calling user is assumed (or NULL) &quot;</a>
<a name="ln356">  // (c) http://librdf.org/flickcurl/api/flickcurl-section-photoset.html#flickcurl-photosets-getList</a>
<a name="ln357">  photoset = flickcurl_photosets_getList(ctx-&gt;fc, NULL);</a>
<a name="ln358"> </a>
<a name="ln359">  return photoset;</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">/** Refresh albums */</a>
<a name="ln363">static void refresh_albums(dt_storage_flickr_gui_data_t *ui)</a>
<a name="ln364">{</a>
<a name="ln365">  int i;</a>
<a name="ln366">  gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;album_list), FALSE);</a>
<a name="ln367"> </a>
<a name="ln368">  if(ui-&gt;flickr_api == NULL || ui-&gt;flickr_api-&gt;needsReauthentication == TRUE)</a>
<a name="ln369">  {</a>
<a name="ln370">    if(ui-&gt;flickr_api != NULL) _flickr_api_free(ui-&gt;flickr_api);</a>
<a name="ln371">    ui-&gt;flickr_api = _flickr_api_authenticate(ui);</a>
<a name="ln372">    if(ui-&gt;flickr_api != NULL)</a>
<a name="ln373">    {</a>
<a name="ln374">      set_status(ui, _(&quot;authenticated&quot;), &quot;#7fe07f&quot;);</a>
<a name="ln375">    }</a>
<a name="ln376">    else</a>
<a name="ln377">    {</a>
<a name="ln378">      set_status(ui, _(&quot;not authenticated&quot;), &quot;#e07f7f&quot;);</a>
<a name="ln379">      gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;album_list), FALSE);</a>
<a name="ln380">      return;</a>
<a name="ln381">    }</a>
<a name="ln382">  }</a>
<a name="ln383"> </a>
<a name="ln384">  // First clear the cobobox except first 2 items (none / create new album)</a>
<a name="ln385">  dt_bauhaus_combobox_clear(ui-&gt;album_list);</a>
<a name="ln386"> </a>
<a name="ln387">  ui-&gt;albums = _flickr_api_photosets(ui-&gt;flickr_api, gtk_entry_get_text(ui-&gt;user_entry));</a>
<a name="ln388">  if(ui-&gt;albums)</a>
<a name="ln389">  {</a>
<a name="ln390"> </a>
<a name="ln391">    // Add standard action</a>
<a name="ln392">    dt_bauhaus_combobox_add(ui-&gt;album_list, _(&quot;without album&quot;));</a>
<a name="ln393">    dt_bauhaus_combobox_add(ui-&gt;album_list, _(&quot;create new album&quot;));</a>
<a name="ln394">//     dt_bauhaus_combobox_add(ui-&gt;album_list, &quot;&quot;); // Separator // FIXME: bauhaus doesn't support separators</a>
<a name="ln395"> </a>
<a name="ln396">    // Then add albums from list...</a>
<a name="ln397">    for(i = 0; ui-&gt;albums[i]; i++)</a>
<a name="ln398">    {</a>
<a name="ln399">      char data[512] = { 0 };</a>
<a name="ln400">      snprintf(data, sizeof(data), &quot;%s (%i)&quot;, ui-&gt;albums[i]-&gt;title, ui-&gt;albums[i]-&gt;photos_count);</a>
<a name="ln401">      dt_bauhaus_combobox_add(ui-&gt;album_list, data);</a>
<a name="ln402">    }</a>
<a name="ln403">    dt_bauhaus_combobox_set(ui-&gt;album_list, 2);</a>
<a name="ln404">    gtk_widget_hide(GTK_WIDGET(ui-&gt;create_box)); // Hide create album box...</a>
<a name="ln405">  }</a>
<a name="ln406">  else</a>
<a name="ln407">  {</a>
<a name="ln408">    // Failed to parse feed of album...</a>
<a name="ln409">    // Lets notify somehow...</a>
<a name="ln410">    dt_bauhaus_combobox_set(ui-&gt;album_list, 0);</a>
<a name="ln411">  }</a>
<a name="ln412">  gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;album_list), TRUE);</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415"> </a>
<a name="ln416">static void flickr_album_changed(GtkComboBox *cb, gpointer data)</a>
<a name="ln417">{</a>
<a name="ln418">  dt_storage_flickr_gui_data_t *ui = (dt_storage_flickr_gui_data_t *)data;</a>
<a name="ln419">  const gchar *value = dt_bauhaus_combobox_get_text(ui-&gt;album_list);</a>
<a name="ln420">  if(value != NULL &amp;&amp; strcmp(value, _(&quot;create new album&quot;)) == 0)</a>
<a name="ln421">  {</a>
<a name="ln422">    gtk_widget_set_no_show_all(GTK_WIDGET(ui-&gt;create_box), FALSE);</a>
<a name="ln423">    gtk_widget_show_all(GTK_WIDGET(ui-&gt;create_box));</a>
<a name="ln424">  }</a>
<a name="ln425">  else</a>
<a name="ln426">    gtk_widget_hide(GTK_WIDGET(ui-&gt;create_box));</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">// Refresh button pressed...</a>
<a name="ln430">static void flickr_button1_clicked(GtkButton *button, gpointer data)</a>
<a name="ln431">{</a>
<a name="ln432">  dt_storage_flickr_gui_data_t *ui = (dt_storage_flickr_gui_data_t *)data;</a>
<a name="ln433">  refresh_albums(ui);</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">/*</a>
<a name="ln437">static gboolean</a>
<a name="ln438">focus_in(GtkWidget *widget, GdkEventFocus *event, gpointer user_data)</a>
<a name="ln439">{</a>
<a name="ln440">  dt_control_tab_shortcut_off(darktable.control);</a>
<a name="ln441">  return FALSE;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">static gboolean</a>
<a name="ln445">focus_out(GtkWidget *widget, GdkEventFocus *event, gpointer user_data)</a>
<a name="ln446">{</a>
<a name="ln447">  dt_control_tab_shortcut_on(darktable.control);</a>
<a name="ln448">  return FALSE;</a>
<a name="ln449">}</a>
<a name="ln450">*/</a>
<a name="ln451"> </a>
<a name="ln452">void gui_init(dt_imageio_module_storage_t *self)</a>
<a name="ln453">{</a>
<a name="ln454">  self-&gt;gui_data = (dt_storage_flickr_gui_data_t *)g_malloc0(sizeof(dt_storage_flickr_gui_data_t));</a>
<a name="ln455">  dt_storage_flickr_gui_data_t *ui = self-&gt;gui_data;</a>
<a name="ln456">  self-&gt;widget = gtk_grid_new();</a>
<a name="ln457">  gtk_grid_set_row_spacing(GTK_GRID(self-&gt;widget), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln458">  gtk_grid_set_column_spacing(GTK_GRID(self-&gt;widget), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln459">  int line = 0;</a>
<a name="ln460"> </a>
<a name="ln461">  GHashTable *table = dt_pwstorage_get(&quot;flickr&quot;);</a>
<a name="ln462">  gchar *_username = g_strdup(g_hash_table_lookup(table, &quot;username&quot;));</a>
<a name="ln463">  g_hash_table_destroy(table);</a>
<a name="ln464"> </a>
<a name="ln465">  GtkWidget *hbox, *label, *button;</a>
<a name="ln466"> </a>
<a name="ln467"> </a>
<a name="ln468">  label = gtk_label_new(_(&quot;flickr user&quot;));</a>
<a name="ln469">  g_object_set(G_OBJECT(label), &quot;xalign&quot;, 0.0, (gchar *)0);</a>
<a name="ln470">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln471"> </a>
<a name="ln472">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln473"> </a>
<a name="ln474">  ui-&gt;user_entry = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln475">  gtk_widget_set_hexpand(GTK_WIDGET(ui-&gt;user_entry), TRUE);</a>
<a name="ln476">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(ui-&gt;user_entry));</a>
<a name="ln477">  gtk_entry_set_text(ui-&gt;user_entry, _username == NULL ? &quot;&quot; : _username);</a>
<a name="ln478">  g_signal_connect(G_OBJECT(ui-&gt;user_entry), &quot;changed&quot;, G_CALLBACK(flickr_entry_changed), (gpointer)ui);</a>
<a name="ln479">  gtk_entry_set_width_chars(GTK_ENTRY(ui-&gt;user_entry), 0);</a>
<a name="ln480"> </a>
<a name="ln481">  button = gtk_button_new_with_label(_(&quot;login&quot;));</a>
<a name="ln482">  gtk_widget_set_tooltip_text(button, _(&quot;flickr login&quot;));</a>
<a name="ln483">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(flickr_button1_clicked), (gpointer)ui);</a>
<a name="ln484">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(ui-&gt;user_entry), TRUE, TRUE, 0);</a>
<a name="ln485">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);</a>
<a name="ln486"> </a>
<a name="ln487">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), hbox, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln488"> </a>
<a name="ln489"> </a>
<a name="ln490">  ui-&gt;status_label = GTK_LABEL(gtk_label_new(NULL));</a>
<a name="ln491">  gtk_widget_set_halign(GTK_WIDGET(ui-&gt;status_label), GTK_ALIGN_START);</a>
<a name="ln492">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(ui-&gt;status_label), 1, line++, 1, 1);</a>
<a name="ln493"> </a>
<a name="ln494"> </a>
<a name="ln495">  ui-&gt;permission_list = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln496">  dt_bauhaus_widget_set_label(ui-&gt;permission_list, NULL, _(&quot;visible to&quot;));</a>
<a name="ln497">  dt_bauhaus_combobox_add(ui-&gt;permission_list, _(&quot;you&quot;));</a>
<a name="ln498">  dt_bauhaus_combobox_add(ui-&gt;permission_list, _(&quot;friends&quot;));</a>
<a name="ln499">  dt_bauhaus_combobox_add(ui-&gt;permission_list, _(&quot;family&quot;));</a>
<a name="ln500">  dt_bauhaus_combobox_add(ui-&gt;permission_list, _(&quot;friends + family&quot;));</a>
<a name="ln501">  dt_bauhaus_combobox_add(ui-&gt;permission_list, _(&quot;everyone&quot;));</a>
<a name="ln502">  dt_bauhaus_combobox_set(ui-&gt;permission_list, 0); // Set default permission to private</a>
<a name="ln503">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(ui-&gt;permission_list), 0, line++, 2, 1);</a>
<a name="ln504"> </a>
<a name="ln505"> </a>
<a name="ln506">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln507"> </a>
<a name="ln508">  ui-&gt;album_list = dt_bauhaus_combobox_new(NULL); // Available albums</a>
<a name="ln509">  dt_bauhaus_widget_set_label(ui-&gt;album_list, NULL, _(&quot;photosets&quot;));</a>
<a name="ln510">  g_signal_connect(G_OBJECT(ui-&gt;album_list), &quot;value-changed&quot;, G_CALLBACK(flickr_album_changed), (gpointer)ui);</a>
<a name="ln511">  gtk_widget_set_sensitive(ui-&gt;album_list, FALSE);</a>
<a name="ln512">  gtk_box_pack_start(GTK_BOX(hbox), ui-&gt;album_list, TRUE, TRUE, 0);</a>
<a name="ln513"> </a>
<a name="ln514">  button = dtgtk_button_new(dtgtk_cairo_paint_refresh, CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln515">  gtk_widget_set_tooltip_text(button, _(&quot;refresh album list&quot;));</a>
<a name="ln516">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(flickr_button1_clicked), (gpointer)ui);</a>
<a name="ln517">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);</a>
<a name="ln518"> </a>
<a name="ln519">  gtk_grid_attach(GTK_GRID(self-&gt;widget), hbox, 0, line++, 2, 1);</a>
<a name="ln520"> </a>
<a name="ln521"> </a>
<a name="ln522">  // the box that gets shown when a new album is to be created</a>
<a name="ln523">  ui-&gt;create_box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));</a>
<a name="ln524">  gtk_widget_set_no_show_all(GTK_WIDGET(ui-&gt;create_box), TRUE);</a>
<a name="ln525">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(ui-&gt;create_box), 0, line++, 2, 1);</a>
<a name="ln526"> </a>
<a name="ln527"> </a>
<a name="ln528">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln529"> </a>
<a name="ln530">  label = gtk_label_new(_(&quot;title&quot;));</a>
<a name="ln531">  g_object_set(G_OBJECT(label), &quot;xalign&quot;, 0.0, (gchar *)0);</a>
<a name="ln532">  gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);</a>
<a name="ln533"> </a>
<a name="ln534">  ui-&gt;title_entry = GTK_ENTRY(gtk_entry_new()); // Album title</a>
<a name="ln535">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(ui-&gt;title_entry));</a>
<a name="ln536">  gtk_entry_set_text(ui-&gt;title_entry, _(&quot;my new photoset&quot;));</a>
<a name="ln537">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(ui-&gt;title_entry), TRUE, TRUE, 0);</a>
<a name="ln538">  gtk_entry_set_width_chars(GTK_ENTRY(ui-&gt;title_entry), 0);</a>
<a name="ln539"> </a>
<a name="ln540">  gtk_box_pack_start(ui-&gt;create_box, hbox, FALSE, FALSE, 0);</a>
<a name="ln541"> </a>
<a name="ln542"> </a>
<a name="ln543">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln544"> </a>
<a name="ln545">  label = gtk_label_new(_(&quot;summary&quot;));</a>
<a name="ln546">  g_object_set(G_OBJECT(label), &quot;xalign&quot;, 0.0, (gchar *)0);</a>
<a name="ln547">  gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);</a>
<a name="ln548"> </a>
<a name="ln549">  ui-&gt;summary_entry = GTK_ENTRY(gtk_entry_new()); // Album summary</a>
<a name="ln550">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(ui-&gt;summary_entry));</a>
<a name="ln551">  gtk_entry_set_text(ui-&gt;summary_entry, _(&quot;exported from darktable&quot;));</a>
<a name="ln552">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(ui-&gt;summary_entry), TRUE, TRUE, 0);</a>
<a name="ln553">  gtk_entry_set_width_chars(GTK_ENTRY(ui-&gt;summary_entry), 0);</a>
<a name="ln554"> </a>
<a name="ln555">  gtk_box_pack_start(ui-&gt;create_box, hbox, TRUE, TRUE, 0);</a>
<a name="ln556"> </a>
<a name="ln557"> </a>
<a name="ln558">  set_status(ui, _(&quot;click login button to start&quot;), &quot;#ffffff&quot;);</a>
<a name="ln559"> </a>
<a name="ln560">  /**</a>
<a name="ln561">  don't populate the combo on startup, save 3 second</a>
<a name="ln562"> </a>
<a name="ln563">  // If username and password is stored, let's populate the combo</a>
<a name="ln564">  if( _username &amp;&amp; _password )</a>
<a name="ln565">  {</a>
<a name="ln566">    ui-&gt;user_token = _password;</a>
<a name="ln567">    refresh_albums(ui);</a>
<a name="ln568">  }</a>
<a name="ln569">  */</a>
<a name="ln570"> </a>
<a name="ln571">  g_free(_username);</a>
<a name="ln572">  dt_bauhaus_combobox_set(ui-&gt;album_list, 0);</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">void gui_cleanup(dt_imageio_module_storage_t *self)</a>
<a name="ln576">{</a>
<a name="ln577">  dt_storage_flickr_gui_data_t *ui = self-&gt;gui_data;</a>
<a name="ln578">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ui-&gt;user_entry));</a>
<a name="ln579">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ui-&gt;title_entry));</a>
<a name="ln580">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ui-&gt;summary_entry));</a>
<a name="ln581">  g_free(self-&gt;gui_data);</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">void gui_reset(dt_imageio_module_storage_t *self)</a>
<a name="ln585">{</a>
<a name="ln586">}</a>
<a name="ln587"> </a>
<a name="ln588">int store(dt_imageio_module_storage_t *self, dt_imageio_module_data_t *sdata, const int imgid,</a>
<a name="ln589">          dt_imageio_module_format_t *format, dt_imageio_module_data_t *fdata, const int num, const int total,</a>
<a name="ln590">          const gboolean high_quality, const gboolean upscale, dt_colorspaces_color_profile_type_t icc_type,</a>
<a name="ln591">          const gchar *icc_filename, dt_iop_color_intent_t icc_intent, dt_export_metadata_t *metadata)</a>
<a name="ln592">{</a>
<a name="ln593">  gint result = 0;</a>
<a name="ln594">  dt_storage_flickr_params_t *p = (dt_storage_flickr_params_t *)sdata;</a>
<a name="ln595">  flickcurl_upload_status *photo_status;</a>
<a name="ln596">  gint tags = 0;</a>
<a name="ln597"> </a>
<a name="ln598">  const char *ext = format-&gt;extension(fdata);</a>
<a name="ln599"> </a>
<a name="ln600">  // Let's upload image...</a>
<a name="ln601"> </a>
<a name="ln602">  /* construct a temporary file name */</a>
<a name="ln603">  char fname[PATH_MAX] = { 0 };</a>
<a name="ln604">  dt_loc_get_tmp_dir(fname, sizeof(fname));</a>
<a name="ln605">  g_strlcat(fname, &quot;/darktable.XXXXXX.&quot;, sizeof(fname));</a>
<a name="ln606">  g_strlcat(fname, ext, sizeof(fname));</a>
<a name="ln607"> </a>
<a name="ln608">  char *caption = NULL;</a>
<a name="ln609">  char *description = NULL;</a>
<a name="ln610">  GList *title = NULL;</a>
<a name="ln611">  GList *desc = NULL;</a>
<a name="ln612"> </a>
<a name="ln613">  gint fd = g_mkstemp(fname);</a>
<a name="ln614">  fprintf(stderr, &quot;tempfile: %s\n&quot;, fname);</a>
<a name="ln615">  if(fd == -1)</a>
<a name="ln616">  {</a>
<a name="ln617">    dt_control_log(&quot;failed to create temporary image for flickr export&quot;);</a>
<a name="ln618">    return 1;</a>
<a name="ln619">  }</a>
<a name="ln620">  close(fd);</a>
<a name="ln621"> </a>
<a name="ln622">  if ((metadata-&gt;flags &amp; DT_META_METADATA) &amp;&amp; !(metadata-&gt;flags &amp; DT_META_CALCULATED))</a>
<a name="ln623">  {</a>
<a name="ln624">    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln625">    // If title is not existing, then use the filename without extension. If not, then use title instead</a>
<a name="ln626">    title = dt_metadata_get(img-&gt;id, &quot;Xmp.dc.title&quot;, NULL);</a>
<a name="ln627">    if(title != NULL)</a>
<a name="ln628">    {</a>
<a name="ln629">      caption = g_strdup(title-&gt;data);</a>
<a name="ln630">      g_list_free_full(title, &amp;g_free);</a>
<a name="ln631">    }</a>
<a name="ln632">    else</a>
<a name="ln633">    {</a>
<a name="ln634">      caption = g_path_get_basename(img-&gt;filename);</a>
<a name="ln635">      (g_strrstr(caption, &quot;.&quot;))[0] = '\0'; // chop extension...</a>
<a name="ln636">    }</a>
<a name="ln637"> </a>
<a name="ln638">    desc = dt_metadata_get(img-&gt;id, &quot;Xmp.dc.description&quot;, NULL);</a>
<a name="ln639">    if(desc != NULL)</a>
<a name="ln640">    {</a>
<a name="ln641">      description = desc-&gt;data;</a>
<a name="ln642">    }</a>
<a name="ln643">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln644">  }</a>
<a name="ln645"> </a>
<a name="ln646">  if(dt_imageio_export(imgid, fname, format, fdata, high_quality, upscale, TRUE, icc_type, icc_filename, icc_intent,</a>
<a name="ln647">                       self, sdata, num, total, metadata) != 0)</a>
<a name="ln648">  {</a>
<a name="ln649">    fprintf(stderr, &quot;[imageio_storage_flickr] could not export to file: `%s'!\n&quot;, fname);</a>
<a name="ln650">    dt_control_log(_(&quot;could not export to file `%s'!&quot;), fname);</a>
<a name="ln651">    result = 1;</a>
<a name="ln652">    goto cleanup;</a>
<a name="ln653">  }</a>
<a name="ln654"> </a>
<a name="ln655">#ifdef _OPENMP</a>
<a name="ln656">#pragma omp critical</a>
<a name="ln657">#endif</a>
<a name="ln658">  {</a>
<a name="ln659">    // TODO: Check if this could be done in threads, so we enhance export time by using</a>
<a name="ln660">    //      upload time for one image to export another image to disk.</a>
<a name="ln661">    // Upload image</a>
<a name="ln662">    // Do we export tags?</a>
<a name="ln663">    if(metadata-&gt;flags &amp; DT_META_TAG) tags = imgid;</a>
<a name="ln664">    photo_status = _flickr_api_upload_photo(p, fname, caption, description, tags, metadata-&gt;flags);</a>
<a name="ln665">  }</a>
<a name="ln666"> </a>
<a name="ln667">  if(!photo_status)</a>
<a name="ln668">  {</a>
<a name="ln669">    fprintf(stderr, &quot;[imageio_storage_flickr] could not upload to flickr!\n&quot;);</a>
<a name="ln670">    dt_control_log(_(&quot;could not upload to flickr!&quot;));</a>
<a name="ln671">    result = 1;</a>
<a name="ln672">    goto cleanup;</a>
<a name="ln673">  }</a>
<a name="ln674"> </a>
<a name="ln675">  //  int fail = 0;</a>
<a name="ln676">  // A photoset is only created if we have an album title set</a>
<a name="ln677">  if(p-&gt;flickr_api-&gt;current_album == NULL &amp;&amp; p-&gt;flickr_api-&gt;new_album == TRUE)</a>
<a name="ln678">  {</a>
<a name="ln679">    char *photoset_id;</a>
<a name="ln680">    photoset_id = _flickr_api_create_photoset(p-&gt;flickr_api, photo_status-&gt;photoid);</a>
<a name="ln681"> </a>
<a name="ln682">    if(photoset_id == NULL)</a>
<a name="ln683">    {</a>
<a name="ln684">      dt_control_log(&quot;failed to create flickr album&quot;);</a>
<a name="ln685">      //      fail = 1;</a>
<a name="ln686">    }</a>
<a name="ln687">    else</a>
<a name="ln688">    {</a>
<a name="ln689">      //      p-&gt;flickr_api-&gt;new_album = FALSE;</a>
<a name="ln690">      p-&gt;flickr_api-&gt;current_album = flickcurl_photosets_getInfo(p-&gt;flickr_api-&gt;fc, photoset_id);</a>
<a name="ln691">    }</a>
<a name="ln692">  }</a>
<a name="ln693"> </a>
<a name="ln694">  //  if(fail) return 1;</a>
<a name="ln695">  // TODO: What to do if photoset creation fails?</a>
<a name="ln696"> </a>
<a name="ln697">  // Add to gallery, if needed</a>
<a name="ln698">  if(p-&gt;flickr_api-&gt;current_album != NULL &amp;&amp; p-&gt;flickr_api-&gt;new_album != TRUE)</a>
<a name="ln699">  {</a>
<a name="ln700">    flickcurl_photosets_addPhoto(p-&gt;flickr_api-&gt;fc, p-&gt;flickr_api-&gt;current_album-&gt;id, photo_status-&gt;photoid);</a>
<a name="ln701">    // TODO: Check for errors adding photo to gallery</a>
<a name="ln702">  }</a>
<a name="ln703">  else</a>
<a name="ln704">  {</a>
<a name="ln705">    if(p-&gt;flickr_api-&gt;current_album != NULL &amp;&amp; p-&gt;flickr_api-&gt;new_album == TRUE)</a>
<a name="ln706">    {</a>
<a name="ln707">      p-&gt;flickr_api-&gt;new_album = FALSE;</a>
<a name="ln708">    }</a>
<a name="ln709">  }</a>
<a name="ln710"> </a>
<a name="ln711">cleanup:</a>
<a name="ln712"> </a>
<a name="ln713">  // And remove from filesystem..</a>
<a name="ln714">  g_unlink(fname);</a>
<a name="ln715">  g_free(caption);</a>
<a name="ln716">  if(desc) g_list_free_full(desc, &amp;g_free);</a>
<a name="ln717"> </a>
<a name="ln718">  if(!result)</a>
<a name="ln719">  {</a>
<a name="ln720">    // this makes sense only if the export was successful</a>
<a name="ln721">    dt_control_log(ngettext(&quot;%d/%d exported to flickr webalbum&quot;, &quot;%d/%d exported to flickr webalbum&quot;, num),</a>
<a name="ln722">                   num, total);</a>
<a name="ln723">  }</a>
<a name="ln724">  return result;</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">size_t params_size(dt_imageio_module_storage_t *self)</a>
<a name="ln728">{</a>
<a name="ln729">  return sizeof(int64_t);</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">void init(dt_imageio_module_storage_t *self)</a>
<a name="ln733">{</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">void *get_params(dt_imageio_module_storage_t *self)</a>
<a name="ln737">{</a>
<a name="ln738">  // have to return the size of the struct to store (i.e. without all the variable pointers at the end)</a>
<a name="ln739">  // TODO: if a hash to encrypted data is stored here, return only this size and store it at the beginning of</a>
<a name="ln740">  // the struct!</a>
<a name="ln741">  dt_storage_flickr_gui_data_t *ui = (dt_storage_flickr_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln742">  if(!ui) return NULL; // gui not initialized, CLI mode</a>
<a name="ln743">  dt_storage_flickr_params_t *d = (dt_storage_flickr_params_t *)g_malloc0(sizeof(dt_storage_flickr_params_t));</a>
<a name="ln744">  if(!d) return NULL;</a>
<a name="ln745">  d-&gt;hash = 1;</a>
<a name="ln746"> </a>
<a name="ln747">  // fill d from controls in ui</a>
<a name="ln748">  if(ui-&gt;flickr_api &amp;&amp; ui-&gt;flickr_api-&gt;needsReauthentication == FALSE)</a>
<a name="ln749">  {</a>
<a name="ln750">    // We are authenticated and off to actually export images..</a>
<a name="ln751">    d-&gt;flickr_api = ui-&gt;flickr_api;</a>
<a name="ln752">    int index = dt_bauhaus_combobox_get(ui-&gt;album_list);</a>
<a name="ln753">    if(index &gt;= 0)</a>
<a name="ln754">    {</a>
<a name="ln755">      switch(index)</a>
<a name="ln756">      {</a>
<a name="ln757">        case 0: // No album</a>
<a name="ln758">          d-&gt;flickr_api-&gt;current_album = NULL;</a>
<a name="ln759">          break;</a>
<a name="ln760">        case 1: // Create new album</a>
<a name="ln761">          d-&gt;flickr_api-&gt;current_album = NULL;</a>
<a name="ln762">          d-&gt;flickr_api-&gt;album_title = g_strdup(gtk_entry_get_text(ui-&gt;title_entry));</a>
<a name="ln763">          d-&gt;flickr_api-&gt;album_summary = g_strdup(gtk_entry_get_text(ui-&gt;summary_entry));</a>
<a name="ln764">          d-&gt;flickr_api-&gt;new_album = TRUE;</a>
<a name="ln765">          break;</a>
<a name="ln766">        default:</a>
<a name="ln767">          // use existing album</a>
<a name="ln768">          d-&gt;flickr_api-&gt;current_album</a>
<a name="ln769">              = flickcurl_photosets_getInfo(d-&gt;flickr_api-&gt;fc, ui-&gt;albums[index - 2]-&gt;id);</a>
<a name="ln770">          if(d-&gt;flickr_api-&gt;current_album == NULL)</a>
<a name="ln771">          {</a>
<a name="ln772">            // Something went wrong...</a>
<a name="ln773">            fprintf(stderr, &quot;Something went wrong.. album index %d = NULL\n&quot;, index - 2);</a>
<a name="ln774">            g_free(d);</a>
<a name="ln775">            return NULL;</a>
<a name="ln776">          }</a>
<a name="ln777">          break;</a>
<a name="ln778">      }</a>
<a name="ln779">    }</a>
<a name="ln780">    else</a>
<a name="ln781">    {</a>
<a name="ln782">      g_free(d);</a>
<a name="ln783">      return NULL;</a>
<a name="ln784">    }</a>
<a name="ln785"> </a>
<a name="ln786">    /* Handle the permissions */</a>
<a name="ln787">    int perm_index = (int)dt_bauhaus_combobox_get(ui-&gt;permission_list);</a>
<a name="ln788">    switch(perm_index)</a>
<a name="ln789">    {</a>
<a name="ln790">      case 0: // Private</a>
<a name="ln791">        d-&gt;public_perm = 0;</a>
<a name="ln792">        d-&gt;friend_perm = 0;</a>
<a name="ln793">        d-&gt;family_perm = 0;</a>
<a name="ln794">        break;</a>
<a name="ln795">      case 1: // Friends</a>
<a name="ln796">        d-&gt;public_perm = 0;</a>
<a name="ln797">        d-&gt;friend_perm = 1;</a>
<a name="ln798">        d-&gt;family_perm = 0;</a>
<a name="ln799">        break;</a>
<a name="ln800">      case 2: // Family</a>
<a name="ln801">        d-&gt;public_perm = 0;</a>
<a name="ln802">        d-&gt;friend_perm = 0;</a>
<a name="ln803">        d-&gt;family_perm = 1;</a>
<a name="ln804">        break;</a>
<a name="ln805">      case 3: // Friend + Family</a>
<a name="ln806">        d-&gt;public_perm = 0;</a>
<a name="ln807">        d-&gt;friend_perm = 1;</a>
<a name="ln808">        d-&gt;family_perm = 1;</a>
<a name="ln809">        break;</a>
<a name="ln810">      case 4: // Public</a>
<a name="ln811">        d-&gt;public_perm = 1;</a>
<a name="ln812">        d-&gt;friend_perm = 0;</a>
<a name="ln813">        d-&gt;family_perm = 0;</a>
<a name="ln814">        break;</a>
<a name="ln815">    }</a>
<a name="ln816"> </a>
<a name="ln817">    // Let UI forget about this api context and recreate a new one for further usage...</a>
<a name="ln818">    ui-&gt;flickr_api = _flickr_api_authenticate(ui);</a>
<a name="ln819">    if(ui-&gt;flickr_api)</a>
<a name="ln820">    {</a>
<a name="ln821">      set_status(ui, _(&quot;authenticated&quot;), &quot;#7fe07f&quot;);</a>
<a name="ln822">    }</a>
<a name="ln823">    else</a>
<a name="ln824">    {</a>
<a name="ln825">      set_status(ui, _(&quot;not authenticated&quot;), &quot;#e07f7f&quot;);</a>
<a name="ln826">      gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;album_list), FALSE);</a>
<a name="ln827">    }</a>
<a name="ln828">  }</a>
<a name="ln829">  else</a>
<a name="ln830">  {</a>
<a name="ln831">    set_status(ui, _(&quot;not authenticated&quot;), &quot;#e07f7f&quot;);</a>
<a name="ln832">    gtk_widget_set_sensitive(GTK_WIDGET(ui-&gt;album_list), FALSE);</a>
<a name="ln833">    g_free(d);</a>
<a name="ln834">    return NULL;</a>
<a name="ln835">  }</a>
<a name="ln836">  return d;</a>
<a name="ln837">}</a>
<a name="ln838"> </a>
<a name="ln839">int set_params(dt_imageio_module_storage_t *self, const void *params, const int size)</a>
<a name="ln840">{</a>
<a name="ln841">  if(size != self-&gt;params_size(self)) return 1;</a>
<a name="ln842">  // gui stuff not updated, as sensitive user data is not stored in the preset.</a>
<a name="ln843">  // TODO: store name/hash in kwallet/etc module and get encrypted stuff from there!</a>
<a name="ln844">  return 0;</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">int supported(dt_imageio_module_storage_t *storage, dt_imageio_module_format_t *format)</a>
<a name="ln848">{</a>
<a name="ln849">  if(strcmp(format-&gt;mime(NULL), &quot;image/jpeg&quot;) == 0)</a>
<a name="ln850">    return 1;</a>
<a name="ln851">  else if(strcmp(format-&gt;mime(NULL), &quot;image/png&quot;) == 0)</a>
<a name="ln852">    return 1;</a>
<a name="ln853"> </a>
<a name="ln854">  return 0;</a>
<a name="ln855">}</a>
<a name="ln856"> </a>
<a name="ln857">void free_params(dt_imageio_module_storage_t *self, dt_imageio_module_data_t *params)</a>
<a name="ln858">{</a>
<a name="ln859">  if(!params) return;</a>
<a name="ln860"> </a>
<a name="ln861">  dt_storage_flickr_params_t *d = (dt_storage_flickr_params_t *)params;</a>
<a name="ln862"> </a>
<a name="ln863">  _flickr_api_free(d-&gt;flickr_api); // TODO</a>
<a name="ln864"> </a>
<a name="ln865">  free(params);</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln869">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln870">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="229"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="231"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'flickr_user_token' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="259"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'free' function. Inspect the first argument.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
