
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2014-2017 pascal obry.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;glib.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln22">#include &quot;common/collection.h&quot;</a>
<a name="ln23">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln24">#include &quot;common/cups_print.h&quot;</a>
<a name="ln25">#include &quot;common/file_location.h&quot;</a>
<a name="ln26">#include &quot;common/image_cache.h&quot;</a>
<a name="ln27">#include &quot;common/metadata.h&quot;</a>
<a name="ln28">#include &quot;common/pdf.h&quot;</a>
<a name="ln29">#include &quot;common/printprof.h&quot;</a>
<a name="ln30">#include &quot;common/styles.h&quot;</a>
<a name="ln31">#include &quot;common/tags.h&quot;</a>
<a name="ln32">#include &quot;common/variables.h&quot;</a>
<a name="ln33">#include &quot;control/jobs.h&quot;</a>
<a name="ln34">#include &quot;dtgtk/resetlabel.h&quot;</a>
<a name="ln35">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln36">#include &quot;gui/gtk.h&quot;</a>
<a name="ln37">#include &quot;libs/lib.h&quot;</a>
<a name="ln38">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">DT_MODULE(3)</a>
<a name="ln41"> </a>
<a name="ln42">const char *name(dt_lib_module_t *self)</a>
<a name="ln43">{</a>
<a name="ln44">  return _(&quot;print settings&quot;);</a>
<a name="ln45">}</a>
<a name="ln46"> </a>
<a name="ln47">const char **views(dt_lib_module_t *self)</a>
<a name="ln48">{</a>
<a name="ln49">  static const char *v[] = {&quot;print&quot;, NULL};</a>
<a name="ln50">  return v;</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln54">{</a>
<a name="ln55">  return DT_UI_CONTAINER_PANEL_RIGHT_CENTER;</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">typedef struct dt_lib_print_settings_t</a>
<a name="ln59">{</a>
<a name="ln60">  GtkWidget *profile, *intent, *style, *style_mode, *papers, *media;</a>
<a name="ln61">  GtkWidget *printers, *orientation, *pprofile, *pintent;</a>
<a name="ln62">  GtkWidget *width, *height, *black_point_compensation;</a>
<a name="ln63">  GtkWidget *info;</a>
<a name="ln64">  GList *profiles;</a>
<a name="ln65">  GtkButton *print_button;</a>
<a name="ln66">  GtkToggleButton *lock_button;</a>
<a name="ln67">  GtkWidget *b_top, *b_bottom, *b_left, *b_right;</a>
<a name="ln68">  GtkDarktableToggleButton *dtba[9];	                                   // Alignment buttons</a>
<a name="ln69">  GList *paper_list, *media_list;</a>
<a name="ln70">  gboolean lock_activated;</a>
<a name="ln71">  dt_print_info_t prt;</a>
<a name="ln72">  int32_t image_id;</a>
<a name="ln73">  int32_t iwidth, iheight;</a>
<a name="ln74">  int unit;</a>
<a name="ln75">  int v_intent, v_pintent;</a>
<a name="ln76">  int v_icctype, v_picctype;</a>
<a name="ln77">  char *v_iccprofile, *v_piccprofile, *v_style;</a>
<a name="ln78">  gboolean v_style_append, v_black_point_compensation;</a>
<a name="ln79">} dt_lib_print_settings_t;</a>
<a name="ln80"> </a>
<a name="ln81">typedef struct dt_lib_print_job_t</a>
<a name="ln82">{</a>
<a name="ln83">  int imgid;</a>
<a name="ln84">  gchar *job_title;</a>
<a name="ln85">  dt_print_info_t prt;</a>
<a name="ln86">  gchar* style;</a>
<a name="ln87">  gboolean style_append, black_point_compensation;</a>
<a name="ln88">  dt_colorspaces_color_profile_type_t buf_icc_type, p_icc_type;</a>
<a name="ln89">  gchar *buf_icc_profile, *p_icc_profile;</a>
<a name="ln90">  dt_iop_color_intent_t buf_icc_intent, p_icc_intent;</a>
<a name="ln91">  uint16_t *buf;</a>
<a name="ln92">  dt_pdf_page_t *pdf_page;</a>
<a name="ln93">  dt_pdf_image_t *pdf_image;</a>
<a name="ln94">  char pdf_filename[PATH_MAX];</a>
<a name="ln95">} dt_lib_print_job_t;</a>
<a name="ln96"> </a>
<a name="ln97">typedef struct dt_lib_export_profile_t</a>
<a name="ln98">{</a>
<a name="ln99">  dt_colorspaces_color_profile_type_t type; // filename is only used for type DT_COLORSPACE_FILE</a>
<a name="ln100">  char filename[512];                       // icc file name</a>
<a name="ln101">  char name[512];                           // product name</a>
<a name="ln102">  int  pos, ppos;                           // position in combo boxen</a>
<a name="ln103">} dt_lib_export_profile_t;</a>
<a name="ln104"> </a>
<a name="ln105">typedef struct _dialog_description</a>
<a name="ln106">{</a>
<a name="ln107">  const char *name;</a>
<a name="ln108">} dialog_description_t;</a>
<a name="ln109"> </a>
<a name="ln110">static double units[3] = {1.0, 0.1, 1.0/25.4};</a>
<a name="ln111"> </a>
<a name="ln112">static void _update_slider (dt_lib_print_settings_t *ps);</a>
<a name="ln113"> </a>
<a name="ln114">static const int min_borders = -100; // this is in mm</a>
<a name="ln115"> </a>
<a name="ln116">int</a>
<a name="ln117">position ()</a>
<a name="ln118">{</a>
<a name="ln119">  return 990;</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">// callbacks for in-memory export</a>
<a name="ln123"> </a>
<a name="ln124">typedef struct dt_print_format_t</a>
<a name="ln125">{</a>
<a name="ln126">  dt_imageio_module_data_t head;</a>
<a name="ln127">  int bpp;</a>
<a name="ln128">  dt_lib_print_job_t *params;</a>
<a name="ln129">} dt_print_format_t;</a>
<a name="ln130"> </a>
<a name="ln131">static int bpp(dt_imageio_module_data_t *data)</a>
<a name="ln132">{</a>
<a name="ln133">  const dt_print_format_t *d = (dt_print_format_t *)data;</a>
<a name="ln134">  return d-&gt;bpp;</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">static int levels(dt_imageio_module_data_t *data)</a>
<a name="ln138">{</a>
<a name="ln139">  const dt_print_format_t *d = (dt_print_format_t *)data;</a>
<a name="ln140">  return IMAGEIO_RGB | (d-&gt;bpp == 8 ? IMAGEIO_INT8 : IMAGEIO_INT16);</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">static const char *mime(dt_imageio_module_data_t *data)</a>
<a name="ln144">{</a>
<a name="ln145">  return &quot;memory&quot;;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">static int write_image(dt_imageio_module_data_t *data, const char *filename, const void *in,</a>
<a name="ln149">                       dt_colorspaces_color_profile_type_t over_type, const char *over_filename,</a>
<a name="ln150">                       void *exif, int exif_len, int imgid, int num, int total, dt_dev_pixelpipe_t *pipe)</a>
<a name="ln151">{</a>
<a name="ln152">  dt_print_format_t *d = (dt_print_format_t *)data;</a>
<a name="ln153"> </a>
<a name="ln154">  d-&gt;params-&gt;buf = (uint16_t *)malloc(d-&gt;head.width * d-&gt;head.height * 3 * (d-&gt;bpp == 8?1:2));</a>
<a name="ln155"> </a>
<a name="ln156">  if (d-&gt;bpp == 8)</a>
<a name="ln157">  {</a>
<a name="ln158">    const uint8_t *in_ptr = (const uint8_t *)in;</a>
<a name="ln159">    uint8_t *out_ptr = (uint8_t *)d-&gt;params-&gt;buf;</a>
<a name="ln160">    for(int y = 0; y &lt; d-&gt;head.height; y++)</a>
<a name="ln161">    {</a>
<a name="ln162">      for(int x = 0; x &lt; d-&gt;head.width; x++, in_ptr += 4, out_ptr += 3)</a>
<a name="ln163">        memcpy(out_ptr, in_ptr, 3);</a>
<a name="ln164">    }</a>
<a name="ln165">  }</a>
<a name="ln166">  else</a>
<a name="ln167">  {</a>
<a name="ln168">    const uint16_t *in_ptr = (const uint16_t *)in;</a>
<a name="ln169">    uint16_t *out_ptr = (uint16_t *)d-&gt;params-&gt;buf;</a>
<a name="ln170">    for(int y = 0; y &lt; d-&gt;head.height; y++)</a>
<a name="ln171">    {</a>
<a name="ln172">      for(int x = 0; x &lt; d-&gt;head.width; x++, in_ptr += 4, out_ptr += 3)</a>
<a name="ln173">        memcpy(out_ptr, in_ptr, 6);</a>
<a name="ln174">    }</a>
<a name="ln175">  }</a>
<a name="ln176"> </a>
<a name="ln177">  return 0;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">static int _print_job_run(dt_job_t *job)</a>
<a name="ln181">{</a>
<a name="ln182">  dt_lib_print_job_t *params = dt_control_job_get_params(job);</a>
<a name="ln183"> </a>
<a name="ln184">  // user margin are already in the proper orientation landscape/portrait</a>
<a name="ln185">  double width, height;</a>
<a name="ln186">  double margin_w = params-&gt;prt.page.margin_left + params-&gt;prt.page.margin_right;</a>
<a name="ln187">  double margin_h = params-&gt;prt.page.margin_top + params-&gt;prt.page.margin_bottom;</a>
<a name="ln188"> </a>
<a name="ln189">  if (params-&gt;prt.page.landscape)</a>
<a name="ln190">  {</a>
<a name="ln191">    width = params-&gt;prt.paper.height;</a>
<a name="ln192">    height = params-&gt;prt.paper.width;</a>
<a name="ln193">    margin_w += params-&gt;prt.printer.hw_margin_top + params-&gt;prt.printer.hw_margin_bottom;</a>
<a name="ln194">    margin_h += params-&gt;prt.printer.hw_margin_left + params-&gt;prt.printer.hw_margin_right;</a>
<a name="ln195">  }</a>
<a name="ln196">  else</a>
<a name="ln197">  {</a>
<a name="ln198">    width = params-&gt;prt.paper.width;</a>
<a name="ln199">    height = params-&gt;prt.paper.height;</a>
<a name="ln200">    margin_w += params-&gt;prt.printer.hw_margin_left + params-&gt;prt.printer.hw_margin_right;</a>
<a name="ln201">    margin_h += params-&gt;prt.printer.hw_margin_top + params-&gt;prt.printer.hw_margin_bottom;</a>
<a name="ln202">  }</a>
<a name="ln203"> </a>
<a name="ln204">  const int32_t width_pix = (width * params-&gt;prt.printer.resolution) / 25.4;</a>
<a name="ln205">  const int32_t height_pix = (height * params-&gt;prt.printer.resolution) / 25.4;</a>
<a name="ln206"> </a>
<a name="ln207">  const double pa_width  = (width  - margin_w) / 25.4;</a>
<a name="ln208">  const double pa_height = (height - margin_h) / 25.4;</a>
<a name="ln209"> </a>
<a name="ln210">  dt_print(DT_DEBUG_PRINT, &quot;[print] printable area for image %u : %3.2fin x %3.2fin\n&quot;, params-&gt;imgid, pa_width, pa_height);</a>
<a name="ln211"> </a>
<a name="ln212">  // compute the needed size for picture for the given printer resolution</a>
<a name="ln213"> </a>
<a name="ln214">  const int max_width  = (pa_width  * params-&gt;prt.printer.resolution);</a>
<a name="ln215">  const int max_height = (pa_height * params-&gt;prt.printer.resolution);</a>
<a name="ln216"> </a>
<a name="ln217">  dt_print(DT_DEBUG_PRINT, &quot;[print] max image size %d x %d (at resolution %d)\n&quot;, max_width, max_height, params-&gt;prt.printer.resolution);</a>
<a name="ln218"> </a>
<a name="ln219">  dt_imageio_module_format_t buf;</a>
<a name="ln220">  buf.mime = mime;</a>
<a name="ln221">  buf.levels = levels;</a>
<a name="ln222">  buf.bpp = bpp;</a>
<a name="ln223">  buf.write_image = write_image;</a>
<a name="ln224"> </a>
<a name="ln225">  dt_print_format_t dat;</a>
<a name="ln226">  dat.head.max_width = max_width;</a>
<a name="ln227">  dat.head.max_height = max_height;</a>
<a name="ln228">  dat.head.style[0] = '\0';</a>
<a name="ln229">  dat.head.style_append = params-&gt;style_append;</a>
<a name="ln230">  dat.bpp = *params-&gt;p_icc_profile ? 16 : 8; // set to 16bit when a profile is to be applied</a>
<a name="ln231">  dat.params = params;</a>
<a name="ln232"> </a>
<a name="ln233">  if (params-&gt;style) g_strlcpy(dat.head.style, params-&gt;style, sizeof(dat.head.style));</a>
<a name="ln234"> </a>
<a name="ln235">  // let the user know something is happening</a>
<a name="ln236">  dt_control_job_set_progress(job, 0.05);</a>
<a name="ln237">  dt_control_log(_(&quot;processing `%s' for `%s'&quot;), params-&gt;job_title, params-&gt;prt.printer.name);</a>
<a name="ln238"> </a>
<a name="ln239">  const gboolean high_quality = TRUE;</a>
<a name="ln240">  const gboolean upscale = TRUE;</a>
<a name="ln241">  const dt_colorspaces_color_profile_t *buf_profile = dt_colorspaces_get_output_profile(params-&gt;imgid,</a>
<a name="ln242">                                                                                        params-&gt;buf_icc_type,</a>
<a name="ln243">                                                                                        params-&gt;buf_icc_profile);</a>
<a name="ln244"> </a>
<a name="ln245">  dt_imageio_export_with_flags(params-&gt;imgid, &quot;unused&quot;, &amp;buf, (dt_imageio_module_data_t *)&amp;dat, TRUE, FALSE,</a>
<a name="ln246">                               high_quality, upscale, FALSE, NULL, FALSE, params-&gt;buf_icc_type, params-&gt;buf_icc_profile,</a>
<a name="ln247">                               params-&gt;buf_icc_intent,  NULL, NULL, 1, 1, NULL);</a>
<a name="ln248"> </a>
<a name="ln249">  // after exporting we know the real size of the image, compute the layout</a>
<a name="ln250"> </a>
<a name="ln251">  // compute print-area (in inches)</a>
<a name="ln252">  int32_t px=0, py=0, pwidth=0, pheight=0;</a>
<a name="ln253">  int32_t ax=0, ay=0, awidth=0, aheight=0;</a>
<a name="ln254">  int32_t ix=0, iy=0, iwidth=0, iheight=0;</a>
<a name="ln255">  int32_t iwpix=dat.head.width, ihpix=dat.head.height;</a>
<a name="ln256"> </a>
<a name="ln257">  dt_get_print_layout (params-&gt;imgid, &amp;params-&gt;prt, width_pix, height_pix,</a>
<a name="ln258">                       &amp;iwpix, &amp;ihpix,</a>
<a name="ln259">                       &amp;px, &amp;py, &amp;pwidth, &amp;pheight,</a>
<a name="ln260">                       &amp;ax, &amp;ay, &amp;awidth, &amp;aheight,</a>
<a name="ln261">                       &amp;ix, &amp;iy, &amp;iwidth, &amp;iheight);</a>
<a name="ln262"> </a>
<a name="ln263">  const int margin_top    = iy;</a>
<a name="ln264">  const int margin_left   = ix;</a>
<a name="ln265">  const int margin_right  = pwidth - iwidth - ix;</a>
<a name="ln266">  const int margin_bottom = pheight - iheight - iy;</a>
<a name="ln267"> </a>
<a name="ln268">  dt_print(DT_DEBUG_PRINT, &quot;[print] margins top %d ; bottom %d ; left %d ; right %d\n&quot;,</a>
<a name="ln269">           margin_top, margin_bottom, margin_left, margin_right);</a>
<a name="ln270"> </a>
<a name="ln271">  // we have the exported buffer, let's apply the printer profile</a>
<a name="ln272"> </a>
<a name="ln273">  if (*params-&gt;p_icc_profile)</a>
<a name="ln274">  {</a>
<a name="ln275">    const dt_colorspaces_color_profile_t *pprof = dt_colorspaces_get_profile(params-&gt;p_icc_type, params-&gt;p_icc_profile,</a>
<a name="ln276">                                                                             DT_PROFILE_DIRECTION_OUT);</a>
<a name="ln277">    if (!pprof)</a>
<a name="ln278">    {</a>
<a name="ln279">      dt_control_log(_(&quot;cannot open printer profile `%s'&quot;), params-&gt;p_icc_profile);</a>
<a name="ln280">      fprintf(stderr, &quot;cannot open printer profile `%s'\n&quot;, params-&gt;p_icc_profile);</a>
<a name="ln281">      dt_control_queue_redraw();</a>
<a name="ln282">      return 1;</a>
<a name="ln283">    }</a>
<a name="ln284">    else</a>
<a name="ln285">    {</a>
<a name="ln286">      if(!buf_profile || !buf_profile-&gt;profile)</a>
<a name="ln287">      {</a>
<a name="ln288">        dt_control_log(_(&quot;error getting output profile for image %d&quot;), params-&gt;imgid);</a>
<a name="ln289">        fprintf(stderr, &quot;error getting output profile for image %d\n&quot;, params-&gt;imgid);</a>
<a name="ln290">        dt_control_queue_redraw();</a>
<a name="ln291">        return 1;</a>
<a name="ln292">      }</a>
<a name="ln293">      if (dt_apply_printer_profile((void **)&amp;(params-&gt;buf), dat.head.width, dat.head.height, dat.bpp, buf_profile-&gt;profile,</a>
<a name="ln294">                                   pprof-&gt;profile, params-&gt;p_icc_intent, params-&gt;black_point_compensation))</a>
<a name="ln295">      {</a>
<a name="ln296">        dt_control_log(_(&quot;cannot apply printer profile `%s'&quot;), params-&gt;p_icc_profile);</a>
<a name="ln297">        fprintf(stderr, &quot;cannot apply printer profile `%s'\n&quot;, params-&gt;p_icc_profile);</a>
<a name="ln298">        dt_control_queue_redraw();</a>
<a name="ln299">        return 1;</a>
<a name="ln300">      }</a>
<a name="ln301">    }</a>
<a name="ln302">  }</a>
<a name="ln303"> </a>
<a name="ln304">  const float page_width  = dt_pdf_mm_to_point(width);</a>
<a name="ln305">  const float page_height = dt_pdf_mm_to_point(height);</a>
<a name="ln306"> </a>
<a name="ln307">  if(dt_control_job_get_state(job) == DT_JOB_STATE_CANCELLED) return 0;</a>
<a name="ln308">  dt_control_job_set_progress(job, 0.9);</a>
<a name="ln309"> </a>
<a name="ln310">  dt_loc_get_tmp_dir(params-&gt;pdf_filename, sizeof(params-&gt;pdf_filename));</a>
<a name="ln311">  g_strlcat(params-&gt;pdf_filename, &quot;/pf.XXXXXX.pdf&quot;, sizeof(params-&gt;pdf_filename));</a>
<a name="ln312"> </a>
<a name="ln313">  gint fd = g_mkstemp(params-&gt;pdf_filename);</a>
<a name="ln314">  if(fd == -1)</a>
<a name="ln315">  {</a>
<a name="ln316">    dt_control_log(_(&quot;failed to create temporary pdf for printing&quot;));</a>
<a name="ln317">    fprintf(stderr, &quot;failed to create temporary pdf for printing\n&quot;);</a>
<a name="ln318">    return 1;</a>
<a name="ln319">  }</a>
<a name="ln320">  close(fd);</a>
<a name="ln321"> </a>
<a name="ln322">  const int icc_id = 0;</a>
<a name="ln323"> </a>
<a name="ln324">  dt_pdf_t *pdf = dt_pdf_start(params-&gt;pdf_filename, page_width, page_height, params-&gt;prt.printer.resolution, DT_PDF_STREAM_ENCODER_FLATE);</a>
<a name="ln325"> </a>
<a name="ln326">/*</a>
<a name="ln327">  // ??? should a profile be embedded here?</a>
<a name="ln328">  if (*printer_profile)</a>
<a name="ln329">    icc_id = dt_pdf_add_icc(pdf, printer_profile);</a>
<a name="ln330">*/</a>
<a name="ln331">  params-&gt;pdf_image = dt_pdf_add_image(pdf, (uint8_t *)params-&gt;buf, dat.head.width, dat.head.height, 8, icc_id, 0.0);</a>
<a name="ln332"> </a>
<a name="ln333">  //  PDF bounding-box has origin on bottom-left</a>
<a name="ln334">  params-&gt;pdf_image-&gt;bb_x      = dt_pdf_pixel_to_point((float)margin_left, params-&gt;prt.printer.resolution);</a>
<a name="ln335">  params-&gt;pdf_image-&gt;bb_y      = dt_pdf_pixel_to_point((float)margin_bottom, params-&gt;prt.printer.resolution);</a>
<a name="ln336">  params-&gt;pdf_image-&gt;bb_width  = dt_pdf_pixel_to_point((float)iwidth, params-&gt;prt.printer.resolution);</a>
<a name="ln337">  params-&gt;pdf_image-&gt;bb_height = dt_pdf_pixel_to_point((float)iheight, params-&gt;prt.printer.resolution);</a>
<a name="ln338"> </a>
<a name="ln339">  if (params-&gt;prt.page.landscape &amp;&amp; (dat.head.width &gt; dat.head.height))</a>
<a name="ln340">    params-&gt;pdf_image-&gt;rotate_to_fit = TRUE;</a>
<a name="ln341">  else</a>
<a name="ln342">    params-&gt;pdf_image-&gt;rotate_to_fit = FALSE;</a>
<a name="ln343"> </a>
<a name="ln344">  params-&gt;pdf_page = dt_pdf_add_page(pdf, &amp;params-&gt;pdf_image, 1);</a>
<a name="ln345">  dt_pdf_finish(pdf, &amp;params-&gt;pdf_page, 1);</a>
<a name="ln346"> </a>
<a name="ln347">  if(dt_control_job_get_state(job) == DT_JOB_STATE_CANCELLED) return 0;</a>
<a name="ln348">  dt_control_job_set_progress(job, 0.95);</a>
<a name="ln349"> </a>
<a name="ln350">  // send to CUPS</a>
<a name="ln351"> </a>
<a name="ln352">  dt_print_file (params-&gt;imgid, params-&gt;pdf_filename, params-&gt;job_title, &amp;params-&gt;prt);</a>
<a name="ln353">  dt_control_job_set_progress(job, 1.0);</a>
<a name="ln354"> </a>
<a name="ln355">  // add tag for this image</a>
<a name="ln356"> </a>
<a name="ln357">  char tag[256] = { 0 };</a>
<a name="ln358">  guint tagid = 0;</a>
<a name="ln359">  snprintf (tag, sizeof(tag), &quot;darktable|printed|%s&quot;, params-&gt;prt.printer.name);</a>
<a name="ln360">  dt_tag_new(tag, &amp;tagid);</a>
<a name="ln361">  dt_tag_attach_from_gui(tagid, params-&gt;imgid);</a>
<a name="ln362"> </a>
<a name="ln363">  return 0;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">static void _print_job_cleanup(void *p)</a>
<a name="ln367">{</a>
<a name="ln368">  dt_lib_print_job_t *params = p;</a>
<a name="ln369">  if(params-&gt;pdf_filename[0]) g_unlink(params-&gt;pdf_filename);</a>
<a name="ln370">  free(params-&gt;pdf_image);</a>
<a name="ln371">  free(params-&gt;pdf_page);</a>
<a name="ln372">  free(params-&gt;buf);</a>
<a name="ln373">  g_free(params-&gt;style);</a>
<a name="ln374">  g_free(params-&gt;buf_icc_profile);</a>
<a name="ln375">  g_free(params-&gt;p_icc_profile);</a>
<a name="ln376">  g_free(params-&gt;job_title);</a>
<a name="ln377">  free(params);</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">static void</a>
<a name="ln381">_print_button_clicked (GtkWidget *widget, gpointer user_data)</a>
<a name="ln382">{</a>
<a name="ln383">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln384">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln385"> </a>
<a name="ln386">  const int imgid = dt_view_filmstrip_get_activated_imgid(darktable.view_manager);</a>
<a name="ln387"> </a>
<a name="ln388">  if (imgid == -1)</a>
<a name="ln389">  {</a>
<a name="ln390">    dt_control_log(_(&quot;cannot print until a picture is selected&quot;));</a>
<a name="ln391">    return;</a>
<a name="ln392">  }</a>
<a name="ln393">  if (strlen(ps-&gt;prt.printer.name) == 0 || ps-&gt;prt.printer.resolution == 0)</a>
<a name="ln394">  {</a>
<a name="ln395">    dt_control_log(_(&quot;cannot print until a printer is selected&quot;));</a>
<a name="ln396">    return;</a>
<a name="ln397">  }</a>
<a name="ln398">  if (ps-&gt;prt.paper.width == 0 || ps-&gt;prt.paper.height == 0)</a>
<a name="ln399">  {</a>
<a name="ln400">    dt_control_log(_(&quot;cannot print until a paper is selected&quot;));</a>
<a name="ln401">    return;</a>
<a name="ln402">  }</a>
<a name="ln403"> </a>
<a name="ln404">  dt_job_t *job = dt_control_job_create(&amp;_print_job_run, &quot;print image %d&quot;, imgid);</a>
<a name="ln405">  if(!job) return;</a>
<a name="ln406"> </a>
<a name="ln407">  dt_lib_print_job_t *params = calloc(1, sizeof(dt_lib_print_job_t));</a>
<a name="ln408">  dt_control_job_set_params(job, params, _print_job_cleanup);</a>
<a name="ln409"> </a>
<a name="ln410">  params-&gt;imgid = imgid;</a>
<a name="ln411">  memcpy(&amp;params-&gt;prt, &amp;ps-&gt;prt, sizeof(dt_print_info_t));</a>
<a name="ln412"> </a>
<a name="ln413">  // what to call the image?</a>
<a name="ln414">  GList *res;</a>
<a name="ln415">  if((res = dt_metadata_get(params-&gt;imgid, &quot;Xmp.dc.title&quot;, NULL)) != NULL)</a>
<a name="ln416">  {</a>
<a name="ln417">    // FIXME: in metadata_view.c, non-printables are filtered, should we do this here?</a>
<a name="ln418">    params-&gt;job_title = g_strdup((gchar *)res-&gt;data);</a>
<a name="ln419">    g_list_free_full(res, &amp;g_free);</a>
<a name="ln420">  }</a>
<a name="ln421">  else</a>
<a name="ln422">  {</a>
<a name="ln423">    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, params-&gt;imgid, 'r');</a>
<a name="ln424">    if(!img)</a>
<a name="ln425">    {</a>
<a name="ln426">      // in this case no need to release from cache what we couldn't get</a>
<a name="ln427">      dt_control_log(_(&quot;cannot get image %d for printing&quot;), imgid);</a>
<a name="ln428">      dt_control_job_dispose(job);</a>
<a name="ln429">      return;</a>
<a name="ln430">    }</a>
<a name="ln431">    params-&gt;job_title = g_strdup(img-&gt;filename);</a>
<a name="ln432">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln433">  }</a>
<a name="ln434">  // FIXME: ellipsize title/printer as the export completed message is ellipsized</a>
<a name="ln435">  gchar *message = g_strdup_printf(_(&quot;processing `%s' for `%s'&quot;), params-&gt;job_title, params-&gt;prt.printer.name);</a>
<a name="ln436">  dt_control_job_add_progress(job, message, TRUE);</a>
<a name="ln437">  g_free(message);</a>
<a name="ln438"> </a>
<a name="ln439">  // FIXME: getting this from conf as w/prior code, but switch to getting from ps</a>
<a name="ln440">  params-&gt;style = dt_conf_get_string(&quot;plugins/print/print/style&quot;);</a>
<a name="ln441">  params-&gt;style_append = ps-&gt;v_style_append;</a>
<a name="ln442"> </a>
<a name="ln443">  // FIXME: getting these from conf as w/prior code, but switch to getting them from ps</a>
<a name="ln444">  params-&gt;buf_icc_type = dt_conf_get_int(&quot;plugins/print/print/icctype&quot;);</a>
<a name="ln445">  params-&gt;buf_icc_profile = dt_conf_get_string(&quot;plugins/print/print/iccprofile&quot;);</a>
<a name="ln446">  params-&gt;buf_icc_intent = dt_conf_get_int(&quot;plugins/print/print/iccintent&quot;);</a>
<a name="ln447"> </a>
<a name="ln448">  params-&gt;p_icc_type = ps-&gt;v_picctype;</a>
<a name="ln449">  params-&gt;p_icc_profile = g_strdup(ps-&gt;v_piccprofile);</a>
<a name="ln450">  params-&gt;p_icc_intent = ps-&gt;v_pintent;</a>
<a name="ln451">  params-&gt;black_point_compensation = ps-&gt;v_black_point_compensation;</a>
<a name="ln452"> </a>
<a name="ln453">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_EXPORT, job);</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">static void _set_printer(const dt_lib_module_t *self, const char *printer_name)</a>
<a name="ln457">{</a>
<a name="ln458">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln459"> </a>
<a name="ln460">  dt_get_printer_info (printer_name, &amp;ps-&gt;prt.printer);</a>
<a name="ln461"> </a>
<a name="ln462">  // if this is a turboprint printer, disable the printer profile</a>
<a name="ln463"> </a>
<a name="ln464">  if (ps-&gt;prt.printer.is_turboprint)</a>
<a name="ln465">    dt_bauhaus_combobox_set(ps-&gt;pprofile, 0);</a>
<a name="ln466"> </a>
<a name="ln467">  // if there is 0 hardware margins, set the user margin to 17mm</a>
<a name="ln468"> </a>
<a name="ln469">  if (ps-&gt;prt.printer.hw_margin_top == 0)</a>
<a name="ln470">  {</a>
<a name="ln471">    ps-&gt;prt.page.margin_top = 17;</a>
<a name="ln472">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_top), ps-&gt;prt.page.margin_top * units[ps-&gt;unit]);</a>
<a name="ln473">  }</a>
<a name="ln474">  if (ps-&gt;prt.printer.hw_margin_bottom == 0)</a>
<a name="ln475">  {</a>
<a name="ln476">    ps-&gt;prt.page.margin_bottom = 17;</a>
<a name="ln477">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), ps-&gt;prt.page.margin_bottom * units[ps-&gt;unit]);</a>
<a name="ln478">  }</a>
<a name="ln479">  if (ps-&gt;prt.printer.hw_margin_left == 0)</a>
<a name="ln480">  {</a>
<a name="ln481">    ps-&gt;prt.page.margin_left = 17;</a>
<a name="ln482">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left), ps-&gt;prt.page.margin_left * units[ps-&gt;unit]);</a>
<a name="ln483">  }</a>
<a name="ln484">  if (ps-&gt;prt.printer.hw_margin_right == 0)</a>
<a name="ln485">  {</a>
<a name="ln486">    ps-&gt;prt.page.margin_right = 17;</a>
<a name="ln487">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right), ps-&gt;prt.page.margin_right * units[ps-&gt;unit]);</a>
<a name="ln488">  }</a>
<a name="ln489"> </a>
<a name="ln490">  dt_conf_set_string(&quot;plugins/print/print/printer&quot;, printer_name);</a>
<a name="ln491"> </a>
<a name="ln492">  char *default_paper = dt_conf_get_string(&quot;plugins/print/print/paper&quot;);</a>
<a name="ln493"> </a>
<a name="ln494">  // next add corresponding papers</a>
<a name="ln495"> </a>
<a name="ln496">  // first clear current list</a>
<a name="ln497"> </a>
<a name="ln498">  dt_bauhaus_combobox_clear(ps-&gt;papers);</a>
<a name="ln499"> </a>
<a name="ln500">  // then add papers for the given printer</a>
<a name="ln501"> </a>
<a name="ln502">  if(ps-&gt;paper_list) g_list_free_full(ps-&gt;paper_list, free);</a>
<a name="ln503"> </a>
<a name="ln504">  ps-&gt;paper_list = dt_get_papers (&amp;ps-&gt;prt.printer);</a>
<a name="ln505">  GList *papers = ps-&gt;paper_list;</a>
<a name="ln506">  int np = 0;</a>
<a name="ln507">  gboolean ispaperset = FALSE;</a>
<a name="ln508"> </a>
<a name="ln509">  while (papers)</a>
<a name="ln510">  {</a>
<a name="ln511">    const dt_paper_info_t *p = (dt_paper_info_t *)papers-&gt;data;</a>
<a name="ln512">    dt_bauhaus_combobox_add(ps-&gt;papers, p-&gt;common_name);</a>
<a name="ln513"> </a>
<a name="ln514">    if (ispaperset == FALSE &amp;&amp; (!g_strcmp0(default_paper, p-&gt;common_name) || default_paper[0] == '\0'))</a>
<a name="ln515">    {</a>
<a name="ln516">      dt_bauhaus_combobox_set(ps-&gt;papers, np);</a>
<a name="ln517">      ispaperset = TRUE;</a>
<a name="ln518">    }</a>
<a name="ln519"> </a>
<a name="ln520">    np++;</a>
<a name="ln521">    papers = g_list_next (papers);</a>
<a name="ln522">  }</a>
<a name="ln523"> </a>
<a name="ln524">  //  paper not found in this printer</a>
<a name="ln525">  if (!ispaperset) dt_bauhaus_combobox_set(ps-&gt;papers, 0);</a>
<a name="ln526"> </a>
<a name="ln527">  const dt_paper_info_t *paper = dt_get_paper(ps-&gt;paper_list, default_paper);</a>
<a name="ln528"> </a>
<a name="ln529">  if (paper)</a>
<a name="ln530">    memcpy(&amp;ps-&gt;prt.paper, paper, sizeof(dt_paper_info_t));</a>
<a name="ln531"> </a>
<a name="ln532">  g_free (default_paper);</a>
<a name="ln533"> </a>
<a name="ln534">  // next add corresponding supported media</a>
<a name="ln535"> </a>
<a name="ln536">  char *default_medium = dt_conf_get_string(&quot;plugins/print/print/medium&quot;);</a>
<a name="ln537"> </a>
<a name="ln538">  // first clear current list</a>
<a name="ln539"> </a>
<a name="ln540">  dt_bauhaus_combobox_clear(ps-&gt;media);</a>
<a name="ln541"> </a>
<a name="ln542">  // then add papers for the given printer</a>
<a name="ln543"> </a>
<a name="ln544">  if(ps-&gt;media_list) g_list_free_full(ps-&gt;media_list, free);</a>
<a name="ln545"> </a>
<a name="ln546">  ps-&gt;media_list = dt_get_media_type (&amp;ps-&gt;prt.printer);</a>
<a name="ln547">  GList *media = ps-&gt;media_list;</a>
<a name="ln548">  gboolean ismediaset = FALSE;</a>
<a name="ln549"> </a>
<a name="ln550">  np = 0;</a>
<a name="ln551"> </a>
<a name="ln552">  while (media)</a>
<a name="ln553">  {</a>
<a name="ln554">    const dt_medium_info_t *m = (dt_medium_info_t *)media-&gt;data;</a>
<a name="ln555">    dt_bauhaus_combobox_add(ps-&gt;media, m-&gt;common_name);</a>
<a name="ln556"> </a>
<a name="ln557">    if (ismediaset == FALSE &amp;&amp; (!g_strcmp0(default_medium, m-&gt;common_name) || default_medium[0] == '\0'))</a>
<a name="ln558">    {</a>
<a name="ln559">      dt_bauhaus_combobox_set(ps-&gt;media, np);</a>
<a name="ln560">      ismediaset = TRUE;</a>
<a name="ln561">    }</a>
<a name="ln562"> </a>
<a name="ln563">    np++;</a>
<a name="ln564">    media = g_list_next (media);</a>
<a name="ln565">  }</a>
<a name="ln566"> </a>
<a name="ln567">  //  media not found in this printer</a>
<a name="ln568">  if (!ismediaset) dt_bauhaus_combobox_set(ps-&gt;media, 0);</a>
<a name="ln569"> </a>
<a name="ln570">  const dt_medium_info_t *medium = dt_get_medium(ps-&gt;media_list, default_medium);</a>
<a name="ln571"> </a>
<a name="ln572">  if (medium)</a>
<a name="ln573">    memcpy(&amp;ps-&gt;prt.medium, medium, sizeof(dt_medium_info_t));</a>
<a name="ln574"> </a>
<a name="ln575">  g_free (default_medium);</a>
<a name="ln576"> </a>
<a name="ln577">  dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">static void</a>
<a name="ln581">_printer_changed (GtkWidget *combo, const dt_lib_module_t *self)</a>
<a name="ln582">{</a>
<a name="ln583">  const gchar *printer_name = dt_bauhaus_combobox_get_text(combo);</a>
<a name="ln584"> </a>
<a name="ln585">  if (printer_name)</a>
<a name="ln586">    _set_printer (self, printer_name);</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">static void</a>
<a name="ln590">_paper_changed (GtkWidget *combo, const dt_lib_module_t *self)</a>
<a name="ln591">{</a>
<a name="ln592">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln593"> </a>
<a name="ln594">  const gchar *paper_name = dt_bauhaus_combobox_get_text(combo);</a>
<a name="ln595"> </a>
<a name="ln596">  if (!paper_name) return;</a>
<a name="ln597"> </a>
<a name="ln598">  const dt_paper_info_t *paper = dt_get_paper(ps-&gt;paper_list, paper_name);</a>
<a name="ln599"> </a>
<a name="ln600">  if (paper)</a>
<a name="ln601">    memcpy(&amp;ps-&gt;prt.paper, paper, sizeof(dt_paper_info_t));</a>
<a name="ln602"> </a>
<a name="ln603">  ps-&gt;iwidth = ps-&gt;iheight = 0;</a>
<a name="ln604"> </a>
<a name="ln605">  dt_conf_set_string(&quot;plugins/print/print/paper&quot;, paper_name);</a>
<a name="ln606">  dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln607"> </a>
<a name="ln608">  _update_slider(ps);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">static void</a>
<a name="ln612">_media_changed (GtkWidget *combo, const dt_lib_module_t *self)</a>
<a name="ln613">{</a>
<a name="ln614">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln615"> </a>
<a name="ln616">  const gchar *medium_name = dt_bauhaus_combobox_get_text(combo);</a>
<a name="ln617"> </a>
<a name="ln618">  if (!medium_name) return;</a>
<a name="ln619"> </a>
<a name="ln620">  const dt_medium_info_t *medium = dt_get_medium(ps-&gt;media_list, medium_name);</a>
<a name="ln621"> </a>
<a name="ln622">  if (medium)</a>
<a name="ln623">    memcpy(&amp;ps-&gt;prt.medium, medium, sizeof(dt_medium_info_t));</a>
<a name="ln624"> </a>
<a name="ln625">  dt_conf_set_string(&quot;plugins/print/print/medium&quot;, medium_name);</a>
<a name="ln626">  dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln627"> </a>
<a name="ln628">  _update_slider(ps);</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">static double to_mm(dt_lib_print_settings_t *ps, double value)</a>
<a name="ln632">{</a>
<a name="ln633">  return value / units[ps-&gt;unit];</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">static void</a>
<a name="ln637">_update_slider (dt_lib_print_settings_t *ps)</a>
<a name="ln638">{</a>
<a name="ln639">  dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln640"> </a>
<a name="ln641">  // if widget are created, let's display the current image size</a>
<a name="ln642"> </a>
<a name="ln643">  if (ps-&gt;image_id != -1 &amp;&amp; ps-&gt;width &amp;&amp; ps-&gt;height &amp;&amp; ps-&gt;info)</a>
<a name="ln644">  {</a>
<a name="ln645">    int32_t px=0, py=0, pwidth=0, pheight=0;</a>
<a name="ln646">    int32_t ax=0, ay=0, awidth=0, aheight=0;</a>
<a name="ln647">    int32_t ix=0, iy=0, iwidth=0, iheight=0;</a>
<a name="ln648">    int32_t iwpix=ps-&gt;iwidth, ihpix=ps-&gt;iheight;</a>
<a name="ln649">    int32_t pa_width, pa_height;</a>
<a name="ln650"> </a>
<a name="ln651">    if (ps-&gt;prt.page.landscape)</a>
<a name="ln652">    {</a>
<a name="ln653">      pa_height = (int32_t)ps-&gt;prt.paper.width;</a>
<a name="ln654">      pa_width = (int32_t)ps-&gt;prt.paper.height;</a>
<a name="ln655">    }</a>
<a name="ln656">    else</a>
<a name="ln657">    {</a>
<a name="ln658">      pa_width = (int32_t)ps-&gt;prt.paper.width;</a>
<a name="ln659">      pa_height = (int32_t)ps-&gt;prt.paper.height;</a>
<a name="ln660">    }</a>
<a name="ln661"> </a>
<a name="ln662">    dt_get_print_layout(ps-&gt;image_id, &amp;ps-&gt;prt, pa_width, pa_height,</a>
<a name="ln663">                        &amp;iwpix, &amp;ihpix,</a>
<a name="ln664">                        &amp;px, &amp;py, &amp;pwidth, &amp;pheight,</a>
<a name="ln665">                        &amp;ax, &amp;ay, &amp;awidth, &amp;aheight,</a>
<a name="ln666">                        &amp;ix, &amp;iy, &amp;iwidth, &amp;iheight);</a>
<a name="ln667"> </a>
<a name="ln668">    if (ps-&gt;iwidth==0 || ps-&gt;iheight==0)</a>
<a name="ln669">    {</a>
<a name="ln670">      ps-&gt;iwidth = iwpix;</a>
<a name="ln671">      ps-&gt;iheight = ihpix;</a>
<a name="ln672">    }</a>
<a name="ln673"> </a>
<a name="ln674">    const double h = iheight * units[ps-&gt;unit];</a>
<a name="ln675">    const double w = iwidth * units[ps-&gt;unit];</a>
<a name="ln676">    char *value;</a>
<a name="ln677"> </a>
<a name="ln678">    value = g_strdup_printf(&quot;%3.2f&quot;, w);</a>
<a name="ln679">    gtk_label_set_text(GTK_LABEL(ps-&gt;width), value);</a>
<a name="ln680">    g_free(value);</a>
<a name="ln681"> </a>
<a name="ln682">    value = g_strdup_printf(&quot;%3.2f&quot;, h);</a>
<a name="ln683">    gtk_label_set_text(GTK_LABEL(ps-&gt;height), value);</a>
<a name="ln684">    g_free(value);</a>
<a name="ln685"> </a>
<a name="ln686">    // compute the image down/up scale and report information</a>
<a name="ln687">    double scale;</a>
<a name="ln688"> </a>
<a name="ln689">    if (iwidth &gt;= awidth)</a>
<a name="ln690">      scale = dt_pdf_point_to_pixel(dt_pdf_mm_to_point((double)awidth), ps-&gt;prt.printer.resolution) / ps-&gt;iwidth;</a>
<a name="ln691">    else</a>
<a name="ln692">      scale = dt_pdf_point_to_pixel(dt_pdf_mm_to_point((double)aheight), ps-&gt;prt.printer.resolution) / ps-&gt;iheight;</a>
<a name="ln693"> </a>
<a name="ln694">    value = g_strdup_printf(_(&quot;%3.2f (dpi:%d)&quot;), scale, scale&lt;=1.0 ? (int)ps-&gt;prt.printer.resolution : (int)(ps-&gt;prt.printer.resolution / scale));</a>
<a name="ln695">    gtk_label_set_text(GTK_LABEL(ps-&gt;info), value);</a>
<a name="ln696">    g_free(value);</a>
<a name="ln697">  }</a>
<a name="ln698"> </a>
<a name="ln699">  // set the max range for the borders depending on the others border and never allow to have an image size of 0 or less</a>
<a name="ln700">  const int min_size = 5; // minimum size in mm</a>
<a name="ln701">  const int pa_max_height = ps-&gt;prt.paper.height - ps-&gt;prt.printer.hw_margin_top - ps-&gt;prt.printer.hw_margin_bottom - min_size;</a>
<a name="ln702">  const int pa_max_width  = ps-&gt;prt.paper.width  - ps-&gt;prt.printer.hw_margin_left - ps-&gt;prt.printer.hw_margin_right - min_size;</a>
<a name="ln703"> </a>
<a name="ln704">  gtk_spin_button_set_range (GTK_SPIN_BUTTON(ps-&gt;b_top),</a>
<a name="ln705">                             min_borders * units[ps-&gt;unit], (pa_max_height - ps-&gt;prt.page.margin_bottom) * units[ps-&gt;unit]);</a>
<a name="ln706">  gtk_spin_button_set_range (GTK_SPIN_BUTTON(ps-&gt;b_left),</a>
<a name="ln707">                             min_borders * units[ps-&gt;unit], (pa_max_width - ps-&gt;prt.page.margin_right) * units[ps-&gt;unit]);</a>
<a name="ln708">  gtk_spin_button_set_range (GTK_SPIN_BUTTON(ps-&gt;b_right),</a>
<a name="ln709">                             min_borders * units[ps-&gt;unit], (pa_max_width - ps-&gt;prt.page.margin_left) * units[ps-&gt;unit]);</a>
<a name="ln710">  gtk_spin_button_set_range (GTK_SPIN_BUTTON(ps-&gt;b_bottom),</a>
<a name="ln711">                             min_borders * units[ps-&gt;unit], (pa_max_height - ps-&gt;prt.page.margin_top) * units[ps-&gt;unit]);</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">static void</a>
<a name="ln715">_top_border_callback (GtkWidget *spin, gpointer user_data)</a>
<a name="ln716">{</a>
<a name="ln717">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln718">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln719">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(spin));</a>
<a name="ln720"> </a>
<a name="ln721">  ps-&gt;prt.page.margin_top = to_mm(ps, value);</a>
<a name="ln722"> </a>
<a name="ln723">  if (ps-&gt;lock_activated == TRUE)</a>
<a name="ln724">  {</a>
<a name="ln725">    ps-&gt;prt.page.margin_bottom = to_mm(ps, value);</a>
<a name="ln726">    ps-&gt;prt.page.margin_left = to_mm(ps, value);</a>
<a name="ln727">    ps-&gt;prt.page.margin_right = to_mm(ps, value);</a>
<a name="ln728"> </a>
<a name="ln729">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), value);</a>
<a name="ln730">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left), value);</a>
<a name="ln731">    gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right), value);</a>
<a name="ln732">  }</a>
<a name="ln733"> </a>
<a name="ln734">  _update_slider (ps);</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">static void</a>
<a name="ln738">_bottom_border_callback (GtkWidget *spin, gpointer user_data)</a>
<a name="ln739">{</a>
<a name="ln740">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln741">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln742">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(spin));</a>
<a name="ln743"> </a>
<a name="ln744">  ps-&gt;prt.page.margin_bottom = to_mm(ps, value);</a>
<a name="ln745">  _update_slider (ps);</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">static void</a>
<a name="ln749">_left_border_callback (GtkWidget *spin, gpointer user_data)</a>
<a name="ln750">{</a>
<a name="ln751">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln752">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln753">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(spin));</a>
<a name="ln754"> </a>
<a name="ln755">  ps-&gt;prt.page.margin_left = to_mm(ps, value);</a>
<a name="ln756">  _update_slider (ps);</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759">static void</a>
<a name="ln760">_right_border_callback (GtkWidget *spin, gpointer user_data)</a>
<a name="ln761">{</a>
<a name="ln762">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln763">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln764">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(spin));</a>
<a name="ln765"> </a>
<a name="ln766">  ps-&gt;prt.page.margin_right = to_mm(ps, value);</a>
<a name="ln767">  _update_slider (ps);</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770">static void</a>
<a name="ln771">_lock_callback (GtkWidget *button, gpointer user_data)</a>
<a name="ln772">{</a>
<a name="ln773">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln774">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln775"> </a>
<a name="ln776">  ps-&gt;lock_activated = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button));</a>
<a name="ln777"> </a>
<a name="ln778">  dt_conf_set_bool(&quot;plugins/print/print/lock_borders&quot;, ps-&gt;lock_activated);</a>
<a name="ln779"> </a>
<a name="ln780">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;b_bottom), !ps-&gt;lock_activated);</a>
<a name="ln781">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;b_left), !ps-&gt;lock_activated);</a>
<a name="ln782">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;b_right), !ps-&gt;lock_activated);</a>
<a name="ln783"> </a>
<a name="ln784">  //  get value of top and set it to all other borders</a>
<a name="ln785"> </a>
<a name="ln786">  const double value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(ps-&gt;b_top));</a>
<a name="ln787">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), value);</a>
<a name="ln788">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left), value);</a>
<a name="ln789">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right), value);</a>
<a name="ln790"> </a>
<a name="ln791">  _update_slider (ps);</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">static void</a>
<a name="ln795">_alignment_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln796">{</a>
<a name="ln797">  int index=-1;</a>
<a name="ln798">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln799">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln800"> </a>
<a name="ln801">  for(int i=0; i&lt;9; i++)</a>
<a name="ln802">  {</a>
<a name="ln803">    /* block signal handler */</a>
<a name="ln804">    g_signal_handlers_block_by_func (ps-&gt;dtba[i],_alignment_callback,user_data);</a>
<a name="ln805"> </a>
<a name="ln806">    if( GTK_WIDGET(ps-&gt;dtba[i]) == tb )</a>
<a name="ln807">    {</a>
<a name="ln808">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;dtba[i]),TRUE);</a>
<a name="ln809">      index=i;</a>
<a name="ln810">    }</a>
<a name="ln811">    else gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;dtba[i]),FALSE);</a>
<a name="ln812"> </a>
<a name="ln813">    /* unblock signal handler */</a>
<a name="ln814">    g_signal_handlers_unblock_by_func (ps-&gt;dtba[i],_alignment_callback,user_data);</a>
<a name="ln815">  }</a>
<a name="ln816">  ps-&gt;prt.page.alignment = index;</a>
<a name="ln817">  _update_slider (ps);</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820">static void</a>
<a name="ln821">_orientation_changed (GtkWidget *combo, dt_lib_module_t *self)</a>
<a name="ln822">{</a>
<a name="ln823">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln824"> </a>
<a name="ln825">  ps-&gt;prt.page.landscape = dt_bauhaus_combobox_get (combo);</a>
<a name="ln826"> </a>
<a name="ln827">  _update_slider (ps);</a>
<a name="ln828">}</a>
<a name="ln829"> </a>
<a name="ln830">static void</a>
<a name="ln831">_unit_changed (GtkWidget *combo, dt_lib_module_t *self)</a>
<a name="ln832">{</a>
<a name="ln833">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln834"> </a>
<a name="ln835">  int unit = dt_bauhaus_combobox_get(combo);</a>
<a name="ln836">  if(unit &lt; 0) return; // shouldn't happen, but it could be -1 if nothing is selected</a>
<a name="ln837">  ps-&gt;unit = unit;</a>
<a name="ln838">  dt_conf_set_int(&quot;plugins/print/print/unit&quot;, ps-&gt;unit);</a>
<a name="ln839"> </a>
<a name="ln840">  const double margin_top = ps-&gt;prt.page.margin_top;</a>
<a name="ln841">  const double margin_left = ps-&gt;prt.page.margin_left;</a>
<a name="ln842">  const double margin_right = ps-&gt;prt.page.margin_right;</a>
<a name="ln843">  const double margin_bottom = ps-&gt;prt.page.margin_bottom;</a>
<a name="ln844"> </a>
<a name="ln845">  const int n_digits = (int)(1.0 / (units[ps-&gt;unit] * 10.0));</a>
<a name="ln846"> </a>
<a name="ln847">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(ps-&gt;b_top),    n_digits);</a>
<a name="ln848">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(ps-&gt;b_bottom), n_digits);</a>
<a name="ln849">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(ps-&gt;b_left),   n_digits);</a>
<a name="ln850">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(ps-&gt;b_right),  n_digits);</a>
<a name="ln851"> </a>
<a name="ln852">  const float incr = units[ps-&gt;unit];</a>
<a name="ln853"> </a>
<a name="ln854">  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(ps-&gt;b_top), incr, incr);</a>
<a name="ln855">  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(ps-&gt;b_bottom), incr, incr);</a>
<a name="ln856">  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(ps-&gt;b_left), incr, incr);</a>
<a name="ln857">  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(ps-&gt;b_right), incr, incr);</a>
<a name="ln858"> </a>
<a name="ln859">  _update_slider (ps);</a>
<a name="ln860"> </a>
<a name="ln861">  // convert margins to new unit</a>
<a name="ln862">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_top),    margin_top * units[ps-&gt;unit]);</a>
<a name="ln863">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), margin_bottom * units[ps-&gt;unit]);</a>
<a name="ln864">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left),   margin_left * units[ps-&gt;unit]);</a>
<a name="ln865">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right),  margin_right * units[ps-&gt;unit]);</a>
<a name="ln866"> </a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869">static void</a>
<a name="ln870">_style_callback(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln871">{</a>
<a name="ln872">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln873"> </a>
<a name="ln874">  if(dt_bauhaus_combobox_get(ps-&gt;style) == 0)</a>
<a name="ln875">  {</a>
<a name="ln876">    dt_conf_set_string(&quot;plugins/print/print/style&quot;, &quot;&quot;);</a>
<a name="ln877">    gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;style_mode), FALSE);</a>
<a name="ln878">  }</a>
<a name="ln879">  else</a>
<a name="ln880">  {</a>
<a name="ln881">    const gchar *style = dt_bauhaus_combobox_get_text(ps-&gt;style);</a>
<a name="ln882">    dt_conf_set_string(&quot;plugins/print/print/style&quot;, style);</a>
<a name="ln883">    gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;style_mode), TRUE);</a>
<a name="ln884">  }</a>
<a name="ln885"> </a>
<a name="ln886">  g_free(ps-&gt;v_style);</a>
<a name="ln887">  ps-&gt;v_style = dt_conf_get_string(&quot;plugins/print/print/style&quot;);</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">static void</a>
<a name="ln891">_style_mode_changed(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln892">{</a>
<a name="ln893">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln894"> </a>
<a name="ln895">  if(dt_bauhaus_combobox_get(ps-&gt;style_mode) == 0)</a>
<a name="ln896">    ps-&gt;v_style_append = FALSE;</a>
<a name="ln897">  else</a>
<a name="ln898">    ps-&gt;v_style_append = TRUE;</a>
<a name="ln899"> </a>
<a name="ln900">  dt_conf_set_bool(&quot;plugins/print/print/style_append&quot;, ps-&gt;v_style_append);</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">static void</a>
<a name="ln904">_profile_changed(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln905">{</a>
<a name="ln906">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln907">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln908">  GList *prof = ps-&gt;profiles;</a>
<a name="ln909">  while(prof)</a>
<a name="ln910">  {</a>
<a name="ln911">    dt_lib_export_profile_t *pp = (dt_lib_export_profile_t *)prof-&gt;data;</a>
<a name="ln912">    if(pp-&gt;pos == pos)</a>
<a name="ln913">    {</a>
<a name="ln914">      dt_conf_set_int(&quot;plugins/print/print/icctype&quot;, pp-&gt;type);</a>
<a name="ln915">      dt_conf_set_string(&quot;plugins/print/print/iccprofile&quot;, pp-&gt;filename);</a>
<a name="ln916">      g_free(ps-&gt;v_iccprofile);</a>
<a name="ln917">      ps-&gt;v_icctype = pp-&gt;type;</a>
<a name="ln918">      ps-&gt;v_iccprofile = g_strdup(pp-&gt;filename);</a>
<a name="ln919">      return;</a>
<a name="ln920">    }</a>
<a name="ln921">    prof = g_list_next(prof);</a>
<a name="ln922">  }</a>
<a name="ln923">  dt_conf_set_int(&quot;plugins/print/print/icctype&quot;, DT_COLORSPACE_NONE);</a>
<a name="ln924">  dt_conf_set_string(&quot;plugins/print/print/iccprofile&quot;, &quot;&quot;);</a>
<a name="ln925">  g_free(ps-&gt;v_iccprofile);</a>
<a name="ln926">  ps-&gt;v_icctype = DT_COLORSPACE_NONE;</a>
<a name="ln927">  ps-&gt;v_iccprofile = g_strdup(&quot;&quot;);</a>
<a name="ln928">}</a>
<a name="ln929"> </a>
<a name="ln930">static void</a>
<a name="ln931">_printer_profile_changed(GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln932">{</a>
<a name="ln933">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln934">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln935">  GList *prof = ps-&gt;profiles;</a>
<a name="ln936">  while(prof)</a>
<a name="ln937">  {</a>
<a name="ln938">    dt_lib_export_profile_t *pp = (dt_lib_export_profile_t *)prof-&gt;data;</a>
<a name="ln939">    if(pp-&gt;ppos == pos)</a>
<a name="ln940">    {</a>
<a name="ln941">      dt_conf_set_int(&quot;plugins/print/printer/icctype&quot;, pp-&gt;type);</a>
<a name="ln942">      dt_conf_set_string(&quot;plugins/print/printer/iccprofile&quot;, pp-&gt;filename);</a>
<a name="ln943">      g_free(ps-&gt;v_piccprofile);</a>
<a name="ln944">      ps-&gt;v_picctype = pp-&gt;type;</a>
<a name="ln945">      ps-&gt;v_piccprofile = g_strdup(pp-&gt;filename);</a>
<a name="ln946"> </a>
<a name="ln947">      // activate the black compensation and printer intent</a>
<a name="ln948">      gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;black_point_compensation), TRUE);</a>
<a name="ln949">      return;</a>
<a name="ln950">    }</a>
<a name="ln951">    prof = g_list_next(prof);</a>
<a name="ln952">  }</a>
<a name="ln953">  dt_conf_set_int(&quot;plugins/print/printer/icctype&quot;, DT_COLORSPACE_NONE);</a>
<a name="ln954">  dt_conf_set_string(&quot;plugins/print/printer/iccprofile&quot;, &quot;&quot;);</a>
<a name="ln955">  g_free(ps-&gt;v_piccprofile);</a>
<a name="ln956">  ps-&gt;v_picctype = DT_COLORSPACE_NONE;</a>
<a name="ln957">  ps-&gt;v_piccprofile = g_strdup(&quot;&quot;);</a>
<a name="ln958">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;black_point_compensation), FALSE);</a>
<a name="ln959">}</a>
<a name="ln960"> </a>
<a name="ln961">static void</a>
<a name="ln962">_printer_intent_callback (GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln963">{</a>
<a name="ln964">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln965">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln966">  dt_conf_set_int(&quot;plugins/print/printer/iccintent&quot;, pos);</a>
<a name="ln967">  ps-&gt;v_pintent = pos;</a>
<a name="ln968">  ps-&gt;prt.printer.intent = pos;</a>
<a name="ln969">}</a>
<a name="ln970"> </a>
<a name="ln971">static void</a>
<a name="ln972">_printer_bpc_callback (GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln973">{</a>
<a name="ln974">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln975">  ps-&gt;v_black_point_compensation = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ps-&gt;black_point_compensation));</a>
<a name="ln976">  dt_conf_set_bool(&quot;plugins/print/print/black_point_compensation&quot;, ps-&gt;v_black_point_compensation);</a>
<a name="ln977">}</a>
<a name="ln978"> </a>
<a name="ln979">static void</a>
<a name="ln980">_intent_callback (GtkWidget *widget, dt_lib_module_t *self)</a>
<a name="ln981">{</a>
<a name="ln982">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln983">  const int pos = dt_bauhaus_combobox_get(widget);</a>
<a name="ln984">  // record the intent that will override the out rendering module on export</a>
<a name="ln985">  dt_conf_set_int(&quot;plugins/print/print/iccintent&quot;, pos - 1);</a>
<a name="ln986">  ps-&gt;v_intent = pos - 1;</a>
<a name="ln987">}</a>
<a name="ln988"> </a>
<a name="ln989">static void _set_orientation(dt_lib_print_settings_t *ps)</a>
<a name="ln990">{</a>
<a name="ln991">  if (ps-&gt;image_id &lt;= 0)</a>
<a name="ln992">    return;</a>
<a name="ln993"> </a>
<a name="ln994">  dt_mipmap_buffer_t buf;</a>
<a name="ln995">  dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, ps-&gt;image_id, DT_MIPMAP_0, DT_MIPMAP_BEST_EFFORT, 'r');</a>
<a name="ln996"> </a>
<a name="ln997">  // If there's a mipmap available, figure out orientation based upon</a>
<a name="ln998">  // its dimensions. Otherwise, don't touch orientation until the</a>
<a name="ln999">  // mipmap arrives.</a>
<a name="ln1000">  if (buf.size != DT_MIPMAP_NONE)</a>
<a name="ln1001">  {</a>
<a name="ln1002">    ps-&gt;prt.page.landscape = (buf.width &gt; buf.height);</a>
<a name="ln1003">    dt_view_print_settings(darktable.view_manager, &amp;ps-&gt;prt);</a>
<a name="ln1004">    dt_bauhaus_combobox_set (ps-&gt;orientation, ps-&gt;prt.page.landscape==TRUE?1:0);</a>
<a name="ln1005">  }</a>
<a name="ln1006"> </a>
<a name="ln1007">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010">static void _print_settings_activate_or_update_callback(gpointer instance,gpointer user_data)</a>
<a name="ln1011">{</a>
<a name="ln1012">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1013">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1014"> </a>
<a name="ln1015">  ps-&gt;image_id = dt_view_filmstrip_get_activated_imgid(darktable.view_manager);</a>
<a name="ln1016">  ps-&gt;iwidth = ps-&gt;iheight = 0;</a>
<a name="ln1017">  _set_orientation (ps);</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">static GList* _get_profiles ()</a>
<a name="ln1021">{</a>
<a name="ln1022">  //  Create list of profiles</a>
<a name="ln1023">  GList *list = NULL;</a>
<a name="ln1024"> </a>
<a name="ln1025">  dt_lib_export_profile_t *prof = (dt_lib_export_profile_t *)g_malloc0(sizeof(dt_lib_export_profile_t));</a>
<a name="ln1026">  prof-&gt;type = DT_COLORSPACE_SRGB;</a>
<a name="ln1027">  dt_utf8_strlcpy(prof-&gt;name, _(&quot;sRGB (web-safe)&quot;), sizeof(prof-&gt;name));</a>
<a name="ln1028">  prof-&gt;pos = -2;</a>
<a name="ln1029">  prof-&gt;ppos = -2;</a>
<a name="ln1030">  list = g_list_append(list, prof);</a>
<a name="ln1031"> </a>
<a name="ln1032">  prof = (dt_lib_export_profile_t *)g_malloc0(sizeof(dt_lib_export_profile_t));</a>
<a name="ln1033">  prof-&gt;type = DT_COLORSPACE_ADOBERGB;</a>
<a name="ln1034">  dt_utf8_strlcpy(prof-&gt;name, _(&quot;Adobe RGB (compatible)&quot;), sizeof(prof-&gt;name));</a>
<a name="ln1035">  prof-&gt;pos = -2;</a>
<a name="ln1036">  prof-&gt;ppos = -2;</a>
<a name="ln1037">  list = g_list_append(list, prof);</a>
<a name="ln1038"> </a>
<a name="ln1039">  // add the profiles from datadir/color/out/*.icc</a>
<a name="ln1040">  for(GList *iter = darktable.color_profiles-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln1041">  {</a>
<a name="ln1042">    dt_colorspaces_color_profile_t *p = (dt_colorspaces_color_profile_t *)iter-&gt;data;</a>
<a name="ln1043">    if(p-&gt;type == DT_COLORSPACE_FILE)</a>
<a name="ln1044">    {</a>
<a name="ln1045">      prof = (dt_lib_export_profile_t *)g_malloc0(sizeof(dt_lib_export_profile_t));</a>
<a name="ln1046">      g_strlcpy(prof-&gt;name, p-&gt;name, sizeof(prof-&gt;name));</a>
<a name="ln1047">      g_strlcpy(prof-&gt;filename, p-&gt;filename, sizeof(prof-&gt;filename));</a>
<a name="ln1048">      prof-&gt;type = DT_COLORSPACE_FILE;</a>
<a name="ln1049">      prof-&gt;pos = -2;</a>
<a name="ln1050">      prof-&gt;ppos = -2;</a>
<a name="ln1051">      list = g_list_append(list, prof);</a>
<a name="ln1052">    }</a>
<a name="ln1053">  }</a>
<a name="ln1054"> </a>
<a name="ln1055">  return list;</a>
<a name="ln1056">}</a>
<a name="ln1057"> </a>
<a name="ln1058">static void _new_printer_callback(dt_printer_info_t *printer, void *user_data)</a>
<a name="ln1059">{</a>
<a name="ln1060">  static int count = 0;</a>
<a name="ln1061">  const dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1062">  const dt_lib_print_settings_t *d = (dt_lib_print_settings_t*)self-&gt;data;</a>
<a name="ln1063"> </a>
<a name="ln1064">  char *default_printer = dt_conf_get_string(&quot;plugins/print/print/printer&quot;);</a>
<a name="ln1065"> </a>
<a name="ln1066">  g_signal_handlers_block_by_func(G_OBJECT(d-&gt;printers), G_CALLBACK(_printer_changed), NULL);</a>
<a name="ln1067"> </a>
<a name="ln1068">  dt_bauhaus_combobox_add(d-&gt;printers, printer-&gt;name);</a>
<a name="ln1069"> </a>
<a name="ln1070">  if (!g_strcmp0(default_printer, printer-&gt;name) || default_printer[0]=='\0')</a>
<a name="ln1071">  {</a>
<a name="ln1072">    dt_bauhaus_combobox_set(d-&gt;printers, count);</a>
<a name="ln1073">    _set_printer(self, printer-&gt;name);</a>
<a name="ln1074">  }</a>
<a name="ln1075">  count++;</a>
<a name="ln1076">  g_free(default_printer);</a>
<a name="ln1077"> </a>
<a name="ln1078">  g_signal_handlers_unblock_by_func(G_OBJECT(d-&gt;printers), G_CALLBACK(_printer_changed), NULL);</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">void view_enter(struct dt_lib_module_t *self,struct dt_view_t *old_view,struct dt_view_t *new_view)</a>
<a name="ln1082">{</a>
<a name="ln1083">  // user activated a new image via the filmstrip or user entered view</a>
<a name="ln1084">  // mode which activates an image: get image_id and orientation</a>
<a name="ln1085">  dt_control_signal_connect(darktable.signals,</a>
<a name="ln1086">                            DT_SIGNAL_VIEWMANAGER_FILMSTRIP_ACTIVATE,</a>
<a name="ln1087">                            G_CALLBACK(_print_settings_activate_or_update_callback),</a>
<a name="ln1088">                            self);</a>
<a name="ln1089"> </a>
<a name="ln1090">  // when an updated mipmap, we may have new orientation information</a>
<a name="ln1091">  // about the current image. This updates the image_id as well and</a>
<a name="ln1092">  // zeros out dimensions, but there should be no harm in that</a>
<a name="ln1093">  dt_control_signal_connect(darktable.signals,</a>
<a name="ln1094">                            DT_SIGNAL_DEVELOP_MIPMAP_UPDATED,</a>
<a name="ln1095">                            G_CALLBACK(_print_settings_activate_or_update_callback),</a>
<a name="ln1096">                            self);</a>
<a name="ln1097"> </a>
<a name="ln1098">  // NOTE: it would be proper to set image_id here to -1, but this seems to make no difference</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">void view_leave(struct dt_lib_module_t *self,struct dt_view_t *old_view,struct dt_view_t *new_view)</a>
<a name="ln1102">{</a>
<a name="ln1103">  dt_control_signal_disconnect(darktable.signals,</a>
<a name="ln1104">                               G_CALLBACK(_print_settings_activate_or_update_callback),</a>
<a name="ln1105">                               self);</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108">void</a>
<a name="ln1109">gui_init (dt_lib_module_t *self)</a>
<a name="ln1110">{</a>
<a name="ln1111">  dt_lib_print_settings_t *d = (dt_lib_print_settings_t*)malloc(sizeof(dt_lib_print_settings_t));</a>
<a name="ln1112">  self-&gt;data = d;</a>
<a name="ln1113">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln1114">  dt_gui_add_help_link(self-&gt;widget, &quot;print_chapter.html#print_overview&quot;);</a>
<a name="ln1115"> </a>
<a name="ln1116">  char datadir[PATH_MAX] = { 0 };</a>
<a name="ln1117">  char confdir[PATH_MAX] = { 0 };</a>
<a name="ln1118">  dt_loc_get_user_config_dir(confdir, sizeof(confdir));</a>
<a name="ln1119">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln1120">  char *system_profile_dir = g_build_filename(datadir, &quot;color&quot;, &quot;out&quot;, NULL);</a>
<a name="ln1121">  char *user_profile_dir = g_build_filename(confdir, &quot;color&quot;, &quot;out&quot;, NULL);</a>
<a name="ln1122"> </a>
<a name="ln1123">  GtkWidget *label;</a>
<a name="ln1124"> </a>
<a name="ln1125">  d-&gt;paper_list = NULL;</a>
<a name="ln1126">  d-&gt;media_list = NULL;</a>
<a name="ln1127">  d-&gt;iwidth = d-&gt;iheight = 0;</a>
<a name="ln1128">  d-&gt;unit = 0;</a>
<a name="ln1129">  d-&gt;width = d-&gt;height = NULL;</a>
<a name="ln1130">  d-&gt;v_piccprofile = NULL;</a>
<a name="ln1131">  d-&gt;v_iccprofile = NULL;</a>
<a name="ln1132">  d-&gt;v_style = NULL;</a>
<a name="ln1133"> </a>
<a name="ln1134">  dt_init_print_info(&amp;d-&gt;prt);</a>
<a name="ln1135">  dt_view_print_settings(darktable.view_manager, &amp;d-&gt;prt);</a>
<a name="ln1136"> </a>
<a name="ln1137">  d-&gt;profiles = _get_profiles();</a>
<a name="ln1138"> </a>
<a name="ln1139">  d-&gt;image_id = -1;</a>
<a name="ln1140"> </a>
<a name="ln1141">  //  create the spin-button now as values could be set when the printer has no hardware margin</a>
<a name="ln1142"> </a>
<a name="ln1143">  d-&gt;b_top    = gtk_spin_button_new_with_range(0, 1000, 1);</a>
<a name="ln1144">  d-&gt;b_left   = gtk_spin_button_new_with_range(0, 1000, 1);</a>
<a name="ln1145">  d-&gt;b_right  = gtk_spin_button_new_with_range(0, 1000, 1);</a>
<a name="ln1146">  d-&gt;b_bottom = gtk_spin_button_new_with_range(0, 1000, 1);</a>
<a name="ln1147"> </a>
<a name="ln1148">  gtk_entry_set_alignment (GTK_ENTRY(d-&gt;b_top), 1);</a>
<a name="ln1149">  gtk_entry_set_alignment (GTK_ENTRY(d-&gt;b_left), 1);</a>
<a name="ln1150">  gtk_entry_set_alignment (GTK_ENTRY(d-&gt;b_right), 1);</a>
<a name="ln1151">  gtk_entry_set_alignment (GTK_ENTRY(d-&gt;b_bottom), 1);</a>
<a name="ln1152"> </a>
<a name="ln1153">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;b_top));</a>
<a name="ln1154">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;b_left));</a>
<a name="ln1155">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;b_right));</a>
<a name="ln1156">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;b_bottom));</a>
<a name="ln1157"> </a>
<a name="ln1158">  ////////////////////////// PRINTER SETTINGS</a>
<a name="ln1159"> </a>
<a name="ln1160">  // create papers combo as filled when adding printers</a>
<a name="ln1161">  d-&gt;papers = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1162"> </a>
<a name="ln1163">  label = dt_ui_section_label_new(_(&quot;printer&quot;));</a>
<a name="ln1164">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), label, TRUE, TRUE, 0);</a>
<a name="ln1165">  dt_gui_add_help_link(self-&gt;widget, &quot;print_usage.html#print_printer_section&quot;);</a>
<a name="ln1166">  d-&gt;printers = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1167"> </a>
<a name="ln1168">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), d-&gt;printers, TRUE, TRUE, 0);</a>
<a name="ln1169">  g_signal_connect(G_OBJECT(d-&gt;printers), &quot;value-changed&quot;, G_CALLBACK(_printer_changed), self);</a>
<a name="ln1170"> </a>
<a name="ln1171">  //// media</a>
<a name="ln1172"> </a>
<a name="ln1173">  d-&gt;media = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1174"> </a>
<a name="ln1175">  dt_bauhaus_widget_set_label(d-&gt;media, NULL, _(&quot;media&quot;));</a>
<a name="ln1176"> </a>
<a name="ln1177">  g_signal_connect(G_OBJECT(d-&gt;media), &quot;value-changed&quot;, G_CALLBACK(_media_changed), self);</a>
<a name="ln1178">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;media), TRUE, TRUE, 0);</a>
<a name="ln1179"> </a>
<a name="ln1180">  //  Add printer profile combo</a>
<a name="ln1181"> </a>
<a name="ln1182">  d-&gt;pprofile = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1183">  dt_bauhaus_widget_set_label(d-&gt;pprofile, NULL, _(&quot;profile&quot;));</a>
<a name="ln1184"> </a>
<a name="ln1185">  int combo_idx, n;</a>
<a name="ln1186">  GList *l = d-&gt;profiles;</a>
<a name="ln1187"> </a>
<a name="ln1188">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;pprofile), TRUE, TRUE, 0);</a>
<a name="ln1189">  int printer_profile_type = dt_conf_get_int(&quot;plugins/print/printer/icctype&quot;);</a>
<a name="ln1190">  gchar *printer_profile = dt_conf_get_string(&quot;plugins/print/printer/iccprofile&quot;);</a>
<a name="ln1191">  combo_idx = -1;</a>
<a name="ln1192">  n = 0;</a>
<a name="ln1193"> </a>
<a name="ln1194">  dt_bauhaus_combobox_add(d-&gt;pprofile, _(&quot;color management in printer driver&quot;));</a>
<a name="ln1195">  while(l)</a>
<a name="ln1196">  {</a>
<a name="ln1197">    dt_lib_export_profile_t *prof = (dt_lib_export_profile_t *)l-&gt;data;</a>
<a name="ln1198">    // do not add built-in profiles, these are in no way for printing</a>
<a name="ln1199">    if(prof-&gt;type == DT_COLORSPACE_FILE)</a>
<a name="ln1200">    {</a>
<a name="ln1201">      dt_bauhaus_combobox_add(d-&gt;pprofile, prof-&gt;name);</a>
<a name="ln1202">      prof-&gt;ppos = ++n;</a>
<a name="ln1203">      if(prof-&gt;type == printer_profile_type &amp;&amp;</a>
<a name="ln1204">        (prof-&gt;type != DT_COLORSPACE_FILE || !g_strcmp0(prof-&gt;filename, printer_profile)))</a>
<a name="ln1205">      {</a>
<a name="ln1206">        g_free(d-&gt;v_piccprofile);</a>
<a name="ln1207">        d-&gt;v_picctype = printer_profile_type;</a>
<a name="ln1208">        d-&gt;v_piccprofile = g_strdup(printer_profile);</a>
<a name="ln1209">        combo_idx = n;</a>
<a name="ln1210">      }</a>
<a name="ln1211">    }</a>
<a name="ln1212">    l = g_list_next(l);</a>
<a name="ln1213">  }</a>
<a name="ln1214"> </a>
<a name="ln1215">  g_free (printer_profile);</a>
<a name="ln1216"> </a>
<a name="ln1217">  // profile not found, maybe a profile has been removed? revert to none</a>
<a name="ln1218">  if (combo_idx == -1)</a>
<a name="ln1219">  {</a>
<a name="ln1220">    dt_conf_set_int(&quot;plugins/print/printer/icctype&quot;, DT_COLORSPACE_NONE);</a>
<a name="ln1221">    dt_conf_set_string(&quot;plugins/print/printer/iccprofile&quot;, &quot;&quot;);</a>
<a name="ln1222">    g_free(d-&gt;v_piccprofile);</a>
<a name="ln1223">    d-&gt;v_picctype = DT_COLORSPACE_NONE;</a>
<a name="ln1224">    d-&gt;v_piccprofile = g_strdup(&quot;&quot;);</a>
<a name="ln1225">    combo_idx = 0;</a>
<a name="ln1226">  }</a>
<a name="ln1227">  dt_bauhaus_combobox_set(d-&gt;pprofile, combo_idx);</a>
<a name="ln1228"> </a>
<a name="ln1229">  char *tooltip = g_strdup_printf(_(&quot;printer ICC profiles in %s or %s&quot;), user_profile_dir, system_profile_dir);</a>
<a name="ln1230">  gtk_widget_set_tooltip_text(d-&gt;pprofile, tooltip);</a>
<a name="ln1231">  g_free(tooltip);</a>
<a name="ln1232"> </a>
<a name="ln1233">  g_signal_connect(G_OBJECT(d-&gt;pprofile), &quot;value-changed&quot;, G_CALLBACK(_printer_profile_changed), (gpointer)self);</a>
<a name="ln1234"> </a>
<a name="ln1235">  //  Add printer intent combo</a>
<a name="ln1236"> </a>
<a name="ln1237">  d-&gt;pintent = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1238">  dt_bauhaus_widget_set_label(d-&gt;pintent, NULL, _(&quot;intent&quot;));</a>
<a name="ln1239">  dt_bauhaus_combobox_add(d-&gt;pintent, _(&quot;perceptual&quot;));</a>
<a name="ln1240">  dt_bauhaus_combobox_add(d-&gt;pintent, _(&quot;relative colorimetric&quot;));</a>
<a name="ln1241">  dt_bauhaus_combobox_add(d-&gt;pintent, C_(&quot;rendering intent&quot;, &quot;saturation&quot;));</a>
<a name="ln1242">  dt_bauhaus_combobox_add(d-&gt;pintent, _(&quot;absolute colorimetric&quot;));</a>
<a name="ln1243">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;pintent), TRUE, TRUE, 0);</a>
<a name="ln1244"> </a>
<a name="ln1245">  d-&gt;v_pintent = dt_conf_get_int(&quot;plugins/print/printer/iccintent&quot;);</a>
<a name="ln1246">  dt_bauhaus_combobox_set(d-&gt;pintent, d-&gt;v_pintent);</a>
<a name="ln1247"> </a>
<a name="ln1248">  g_signal_connect (G_OBJECT (d-&gt;pintent), &quot;value-changed&quot;, G_CALLBACK (_printer_intent_callback), (gpointer)self);</a>
<a name="ln1249">  d-&gt;prt.printer.intent = d-&gt;v_pintent;</a>
<a name="ln1250"> </a>
<a name="ln1251">  d-&gt;black_point_compensation = gtk_check_button_new_with_label(_(&quot;black point compensation&quot;));</a>
<a name="ln1252">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;black_point_compensation), TRUE, FALSE, 0);</a>
<a name="ln1253">  g_signal_connect(d-&gt;black_point_compensation, &quot;toggled&quot;, G_CALLBACK(_printer_bpc_callback), (gpointer)self);</a>
<a name="ln1254"> </a>
<a name="ln1255">  d-&gt;v_black_point_compensation = dt_conf_get_bool(&quot;plugins/print/print/black_point_compensation&quot;);</a>
<a name="ln1256">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;black_point_compensation), d-&gt;v_black_point_compensation);</a>
<a name="ln1257"> </a>
<a name="ln1258">  gtk_widget_set_tooltip_text(d-&gt;black_point_compensation,</a>
<a name="ln1259">                              _(&quot;activate black point compensation when applying the printer profile&quot;));</a>
<a name="ln1260"> </a>
<a name="ln1261">  gtk_widget_set_sensitive(GTK_WIDGET(d-&gt;black_point_compensation), combo_idx==0?FALSE:TRUE);</a>
<a name="ln1262"> </a>
<a name="ln1263">  ////////////////////////// PAGE SETTINGS</a>
<a name="ln1264"> </a>
<a name="ln1265">  label = dt_ui_section_label_new(_(&quot;page&quot;));</a>
<a name="ln1266">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), label, TRUE, TRUE, 0);</a>
<a name="ln1267">  dt_gui_add_help_link(self-&gt;widget, &quot;print_page_section.html#print_page_section&quot;);</a>
<a name="ln1268"> </a>
<a name="ln1269">  //// papers</a>
<a name="ln1270"> </a>
<a name="ln1271">  dt_bauhaus_widget_set_label(d-&gt;papers, NULL, _(&quot;paper size&quot;));</a>
<a name="ln1272"> </a>
<a name="ln1273">  g_signal_connect(G_OBJECT(d-&gt;papers), &quot;value-changed&quot;, G_CALLBACK(_paper_changed), self);</a>
<a name="ln1274">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;papers), TRUE, TRUE, 0);</a>
<a name="ln1275"> </a>
<a name="ln1276">  //// portrait / landscape</a>
<a name="ln1277"> </a>
<a name="ln1278">  d-&gt;orientation = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1279">  dt_bauhaus_widget_set_label(d-&gt;orientation, NULL, _(&quot;orientation&quot;));</a>
<a name="ln1280">  dt_bauhaus_combobox_add(d-&gt;orientation, _(&quot;portrait&quot;));</a>
<a name="ln1281">  dt_bauhaus_combobox_add(d-&gt;orientation, _(&quot;landscape&quot;));</a>
<a name="ln1282"> </a>
<a name="ln1283">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;orientation), TRUE, TRUE, 0);</a>
<a name="ln1284"> </a>
<a name="ln1285">  GtkWidget *ucomb = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1286">  dt_bauhaus_combobox_add(ucomb, _(&quot;mm&quot;));</a>
<a name="ln1287">  dt_bauhaus_combobox_add(ucomb, _(&quot;cm&quot;));</a>
<a name="ln1288">  dt_bauhaus_combobox_add(ucomb, _(&quot;inch&quot;));</a>
<a name="ln1289">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), ucomb, TRUE, TRUE, 0);</a>
<a name="ln1290"> </a>
<a name="ln1291">  g_signal_connect(G_OBJECT(d-&gt;orientation), &quot;value-changed&quot;, G_CALLBACK(_orientation_changed), self);</a>
<a name="ln1292">  g_signal_connect(G_OBJECT(ucomb), &quot;value-changed&quot;, G_CALLBACK(_unit_changed), self);</a>
<a name="ln1293"> </a>
<a name="ln1294">  d-&gt;unit = dt_conf_get_int(&quot;plugins/print/print/unit&quot;);</a>
<a name="ln1295">  dt_bauhaus_combobox_set(ucomb, d-&gt;unit);</a>
<a name="ln1296"> </a>
<a name="ln1297">  dt_bauhaus_combobox_set (d-&gt;orientation, d-&gt;prt.page.landscape?1:0);</a>
<a name="ln1298"> </a>
<a name="ln1299">  //// image dimensions, create them now as we need them</a>
<a name="ln1300"> </a>
<a name="ln1301">  GtkWidget *hboxdim = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);</a>
<a name="ln1302">  label = gtk_label_new(_(&quot;image width/height&quot;));</a>
<a name="ln1303">  gtk_box_pack_start(GTK_BOX(hboxdim),GTK_WIDGET(label),TRUE,TRUE,0);</a>
<a name="ln1304">  d-&gt;width = gtk_label_new(_(&quot;width&quot;));</a>
<a name="ln1305">  gtk_box_pack_start(GTK_BOX(hboxdim),GTK_WIDGET(d-&gt;width),TRUE,TRUE,0);</a>
<a name="ln1306">  label = gtk_label_new(_(&quot; x &quot;));</a>
<a name="ln1307">  gtk_box_pack_start(GTK_BOX(hboxdim),GTK_WIDGET(label),TRUE,TRUE,0);</a>
<a name="ln1308">  d-&gt;height = gtk_label_new(_(&quot;height&quot;));</a>
<a name="ln1309">  gtk_box_pack_start(GTK_BOX(hboxdim),GTK_WIDGET(d-&gt;height),TRUE,TRUE,0);</a>
<a name="ln1310"> </a>
<a name="ln1311">  //// image information (downscale/upscale)</a>
<a name="ln1312"> </a>
<a name="ln1313">  GtkWidget *hboxinfo = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);</a>
<a name="ln1314">  label = gtk_label_new(_(&quot;scale factor&quot;));</a>
<a name="ln1315">  gtk_box_pack_start(GTK_BOX(hboxinfo),GTK_WIDGET(label),TRUE,TRUE,0);</a>
<a name="ln1316">  d-&gt;info = gtk_label_new(&quot;1.0&quot;);</a>
<a name="ln1317">  gtk_box_pack_start(GTK_BOX(hboxinfo),GTK_WIDGET(d-&gt;info),TRUE,TRUE,0);</a>
<a name="ln1318">  gtk_widget_set_tooltip_text(hboxinfo,</a>
<a name="ln1319">               _(&quot;image scale factor from native printer DPI:\n&quot;</a>
<a name="ln1320">                 &quot; &lt; 1 means that it is downscaled (best quality)\n&quot;</a>
<a name="ln1321">                 &quot; &gt; 1 means that the image is upscaled\n&quot;</a>
<a name="ln1322">                 &quot; a too large value may result in poor print quality&quot;));</a>
<a name="ln1323"> </a>
<a name="ln1324">  //// borders</a>
<a name="ln1325"> </a>
<a name="ln1326">  GtkGrid *bds = GTK_GRID(gtk_grid_new());</a>
<a name="ln1327">  gtk_grid_set_row_spacing(bds, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1328">  gtk_grid_set_column_spacing(bds, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1329"> </a>
<a name="ln1330">  d-&gt;lock_activated = FALSE;</a>
<a name="ln1331"> </a>
<a name="ln1332">  //d-&gt;b_top  = gtk_spin_button_new_with_range(0, 10000, 1);</a>
<a name="ln1333">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;b_top), _(&quot;top margin&quot;));</a>
<a name="ln1334">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;b_top), 1, 0, 1, 1);</a>
<a name="ln1335"> </a>
<a name="ln1336">  //d-&gt;b_left  = gtk_spin_button_new_with_range(0, 10000, 1);</a>
<a name="ln1337">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;b_left), _(&quot;left margin&quot;));</a>
<a name="ln1338">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;b_left), 0, 1, 1, 1);</a>
<a name="ln1339"> </a>
<a name="ln1340">  d-&gt;lock_button = GTK_TOGGLE_BUTTON(gtk_toggle_button_new_with_label(_(&quot;lock&quot;)));</a>
<a name="ln1341">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;lock_button), _(&quot;change all margins uniformly&quot;));</a>
<a name="ln1342">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;lock_button), 1, 1, 1, 1);</a>
<a name="ln1343"> </a>
<a name="ln1344">  //d-&gt;b_right  = gtk_spin_button_new_with_range(0, 10000, 1);</a>
<a name="ln1345">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;b_right), _(&quot;right margin&quot;));</a>
<a name="ln1346">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;b_right), 2, 1, 1, 1);</a>
<a name="ln1347"> </a>
<a name="ln1348">  //d-&gt;b_bottom  = gtk_spin_button_new_with_range(0, 10000, 1);</a>
<a name="ln1349">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;b_bottom), _(&quot;bottom margin&quot;));</a>
<a name="ln1350">  gtk_grid_attach(bds, GTK_WIDGET(d-&gt;b_bottom), 1, 2, 1, 1);</a>
<a name="ln1351"> </a>
<a name="ln1352">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(bds), TRUE, TRUE, 0);</a>
<a name="ln1353"> </a>
<a name="ln1354">  g_signal_connect (G_OBJECT (d-&gt;b_top), &quot;value-changed&quot;,</a>
<a name="ln1355">                    G_CALLBACK (_top_border_callback), self);</a>
<a name="ln1356">  g_signal_connect (G_OBJECT (d-&gt;b_bottom), &quot;value-changed&quot;,</a>
<a name="ln1357">                    G_CALLBACK (_bottom_border_callback), self);</a>
<a name="ln1358">  g_signal_connect (G_OBJECT (d-&gt;b_left), &quot;value-changed&quot;,</a>
<a name="ln1359">                    G_CALLBACK (_left_border_callback), self);</a>
<a name="ln1360">  g_signal_connect (G_OBJECT (d-&gt;b_right), &quot;value-changed&quot;,</a>
<a name="ln1361">                    G_CALLBACK (_right_border_callback), self);</a>
<a name="ln1362">  g_signal_connect (G_OBJECT(d-&gt;lock_button), &quot;toggled&quot;,</a>
<a name="ln1363">                    G_CALLBACK(_lock_callback), self);</a>
<a name="ln1364"> </a>
<a name="ln1365">  const gboolean lock_active = dt_conf_get_bool(&quot;plugins/print/print/lock_borders&quot;);</a>
<a name="ln1366">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;lock_button), lock_active);</a>
<a name="ln1367"> </a>
<a name="ln1368">  // pack image dimension hbox here</a>
<a name="ln1369"> </a>
<a name="ln1370">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hboxdim), TRUE, TRUE, 0);</a>
<a name="ln1371">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hboxinfo), TRUE, TRUE, 0);</a>
<a name="ln1372"> </a>
<a name="ln1373">  //// alignments</a>
<a name="ln1374"> </a>
<a name="ln1375">  // Create the 3x3 gtk table toggle button table...</a>
<a name="ln1376">  GtkGrid *bat = GTK_GRID(gtk_grid_new());</a>
<a name="ln1377">  gtk_grid_set_row_spacing(bat, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1378">  gtk_grid_set_column_spacing(bat, DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1379">  for(int i=0; i&lt;9; i++)</a>
<a name="ln1380">  {</a>
<a name="ln1381">    d-&gt;dtba[i] = DTGTK_TOGGLEBUTTON (dtgtk_togglebutton_new (dtgtk_cairo_paint_alignment,CPF_STYLE_FLAT|(CPF_SPECIAL_FLAG&lt;&lt;i), NULL));</a>
<a name="ln1382">    gtk_grid_attach (GTK_GRID (bat), GTK_WIDGET (d-&gt;dtba[i]), (i%3), i/3, 1, 1);</a>
<a name="ln1383">    g_signal_connect (G_OBJECT (d-&gt;dtba[i]), &quot;toggled&quot;,G_CALLBACK (_alignment_callback), self);</a>
<a name="ln1384">  }</a>
<a name="ln1385">  d-&gt;prt.page.alignment = ALIGNMENT_CENTER;</a>
<a name="ln1386">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;dtba[d-&gt;prt.page.alignment]),TRUE);</a>
<a name="ln1387"> </a>
<a name="ln1388">  GtkWidget *hbox22 = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);</a>
<a name="ln1389">  GtkWidget *label4 = gtk_label_new(_(&quot;alignment&quot;));</a>
<a name="ln1390">  gtk_box_pack_start(GTK_BOX(hbox22),GTK_WIDGET(label4),TRUE,TRUE,0);</a>
<a name="ln1391">  gtk_box_pack_start(GTK_BOX(hbox22), GTK_WIDGET(bat), TRUE, TRUE, 0);</a>
<a name="ln1392">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(hbox22), TRUE, TRUE, 0);</a>
<a name="ln1393"> </a>
<a name="ln1394">  ////////////////////////// PRINT SETTINGS</a>
<a name="ln1395"> </a>
<a name="ln1396">  label = dt_ui_section_label_new(_(&quot;print settings&quot;));</a>
<a name="ln1397">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), label, TRUE, TRUE, 0);</a>
<a name="ln1398">  dt_gui_add_help_link(self-&gt;widget, &quot;print_settings.html#print_settings&quot;);</a>
<a name="ln1399"> </a>
<a name="ln1400">  //  Add export profile combo</a>
<a name="ln1401"> </a>
<a name="ln1402">  d-&gt;profile = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1403">  dt_bauhaus_widget_set_label(d-&gt;profile, NULL, _(&quot;profile&quot;));</a>
<a name="ln1404"> </a>
<a name="ln1405">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;profile), TRUE, TRUE, 0);</a>
<a name="ln1406">  dt_bauhaus_combobox_add(d-&gt;profile, _(&quot;image settings&quot;));</a>
<a name="ln1407"> </a>
<a name="ln1408">  int icctype = dt_conf_get_int(&quot;plugins/print/print/icctype&quot;);</a>
<a name="ln1409">  gchar *iccprofile = dt_conf_get_string(&quot;plugins/print/print/iccprofile&quot;);</a>
<a name="ln1410">  combo_idx = -1;</a>
<a name="ln1411">  n = 0;</a>
<a name="ln1412"> </a>
<a name="ln1413">  l = d-&gt;profiles;</a>
<a name="ln1414">  while(l)</a>
<a name="ln1415">  {</a>
<a name="ln1416">    dt_lib_export_profile_t *prof = (dt_lib_export_profile_t *)l-&gt;data;</a>
<a name="ln1417">    dt_bauhaus_combobox_add(d-&gt;profile, prof-&gt;name);</a>
<a name="ln1418">    prof-&gt;pos = ++n;</a>
<a name="ln1419">    if(prof-&gt;type == icctype &amp;&amp; (prof-&gt;type != DT_COLORSPACE_FILE || !g_strcmp0(prof-&gt;filename, iccprofile)))</a>
<a name="ln1420">    {</a>
<a name="ln1421">      g_free(d-&gt;v_iccprofile);</a>
<a name="ln1422">      d-&gt;v_icctype = icctype;</a>
<a name="ln1423">      d-&gt;v_iccprofile = g_strdup(iccprofile);</a>
<a name="ln1424">      combo_idx = n;</a>
<a name="ln1425">    }</a>
<a name="ln1426">    l = g_list_next(l);</a>
<a name="ln1427">  }</a>
<a name="ln1428"> </a>
<a name="ln1429">  if (combo_idx == -1)</a>
<a name="ln1430">  {</a>
<a name="ln1431">    dt_conf_set_int(&quot;plugins/print/print/icctype&quot;, DT_COLORSPACE_NONE);</a>
<a name="ln1432">    dt_conf_set_string(&quot;plugins/print/print/iccprofile&quot;, &quot;&quot;);</a>
<a name="ln1433">    g_free(d-&gt;v_iccprofile);</a>
<a name="ln1434">    d-&gt;v_icctype = DT_COLORSPACE_NONE;</a>
<a name="ln1435">    d-&gt;v_iccprofile = g_strdup(&quot;&quot;);</a>
<a name="ln1436">    combo_idx = 0;</a>
<a name="ln1437">  }</a>
<a name="ln1438">  g_free (iccprofile);</a>
<a name="ln1439"> </a>
<a name="ln1440">  dt_bauhaus_combobox_set(d-&gt;profile, combo_idx);</a>
<a name="ln1441"> </a>
<a name="ln1442">  tooltip = g_strdup_printf(_(&quot;output ICC profiles in %s or %s&quot;), user_profile_dir, system_profile_dir);</a>
<a name="ln1443">  gtk_widget_set_tooltip_text(d-&gt;profile, tooltip);</a>
<a name="ln1444">  g_free(tooltip);</a>
<a name="ln1445"> </a>
<a name="ln1446">  g_signal_connect(G_OBJECT(d-&gt;profile), &quot;value-changed&quot;, G_CALLBACK(_profile_changed), (gpointer)self);</a>
<a name="ln1447"> </a>
<a name="ln1448">  //  Add export intent combo</a>
<a name="ln1449"> </a>
<a name="ln1450">  d-&gt;intent = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1451">  dt_bauhaus_widget_set_label(d-&gt;intent, NULL, _(&quot;intent&quot;));</a>
<a name="ln1452"> </a>
<a name="ln1453">  dt_bauhaus_combobox_add(d-&gt;intent, _(&quot;image settings&quot;));</a>
<a name="ln1454">  dt_bauhaus_combobox_add(d-&gt;intent, _(&quot;perceptual&quot;));</a>
<a name="ln1455">  dt_bauhaus_combobox_add(d-&gt;intent, _(&quot;relative colorimetric&quot;));</a>
<a name="ln1456">  dt_bauhaus_combobox_add(d-&gt;intent, C_(&quot;rendering intent&quot;, &quot;saturation&quot;));</a>
<a name="ln1457">  dt_bauhaus_combobox_add(d-&gt;intent, _(&quot;absolute colorimetric&quot;));</a>
<a name="ln1458">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;intent), TRUE, TRUE, 0);</a>
<a name="ln1459"> </a>
<a name="ln1460">  dt_bauhaus_combobox_set(d-&gt;intent, dt_conf_get_int(&quot;plugins/print/print/iccintent&quot;) + 1);</a>
<a name="ln1461"> </a>
<a name="ln1462">  g_signal_connect (G_OBJECT (d-&gt;intent), &quot;value-changed&quot;, G_CALLBACK (_intent_callback), (gpointer)self);</a>
<a name="ln1463"> </a>
<a name="ln1464">  //  Add export style combo</a>
<a name="ln1465"> </a>
<a name="ln1466">  d-&gt;style = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1467">  dt_bauhaus_widget_set_label(d-&gt;style, NULL, _(&quot;style&quot;));</a>
<a name="ln1468"> </a>
<a name="ln1469">  dt_bauhaus_combobox_add(d-&gt;style, _(&quot;none&quot;));</a>
<a name="ln1470"> </a>
<a name="ln1471">  GList *styles = dt_styles_get_list(&quot;&quot;);</a>
<a name="ln1472">  gchar *current_style = dt_conf_get_string(&quot;plugins/print/print/style&quot;);</a>
<a name="ln1473">  combo_idx = -1; n=0;</a>
<a name="ln1474"> </a>
<a name="ln1475">  while (styles)</a>
<a name="ln1476">  {</a>
<a name="ln1477">    dt_style_t *style=(dt_style_t *)styles-&gt;data;</a>
<a name="ln1478">    dt_bauhaus_combobox_add(d-&gt;style, style-&gt;name);</a>
<a name="ln1479">    n++;</a>
<a name="ln1480">    if (g_strcmp0(style-&gt;name,current_style)==0)</a>
<a name="ln1481">    {</a>
<a name="ln1482">      g_free(d-&gt;v_style);</a>
<a name="ln1483">      d-&gt;v_style = g_strdup(current_style);</a>
<a name="ln1484">      combo_idx=n;</a>
<a name="ln1485">    }</a>
<a name="ln1486">    styles=g_list_next(styles);</a>
<a name="ln1487">  }</a>
<a name="ln1488">  g_free(current_style);</a>
<a name="ln1489">  g_list_free_full(styles, dt_style_free);</a>
<a name="ln1490">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;style), TRUE, TRUE, 0);</a>
<a name="ln1491">  gtk_widget_set_tooltip_text(d-&gt;style, _(&quot;temporary style to use while printing&quot;));</a>
<a name="ln1492"> </a>
<a name="ln1493">  // style not found, maybe a style has been removed? revert to none</a>
<a name="ln1494">  if (combo_idx == -1)</a>
<a name="ln1495">  {</a>
<a name="ln1496">    dt_conf_set_string(&quot;plugins/print/print/style&quot;, &quot;&quot;);</a>
<a name="ln1497">    g_free(d-&gt;v_style);</a>
<a name="ln1498">    d-&gt;v_style = g_strdup(&quot;&quot;);</a>
<a name="ln1499">    combo_idx=0;</a>
<a name="ln1500">  }</a>
<a name="ln1501">  dt_bauhaus_combobox_set(d-&gt;style, combo_idx);</a>
<a name="ln1502"> </a>
<a name="ln1503">  g_signal_connect (G_OBJECT (d-&gt;style), &quot;value-changed&quot;,</a>
<a name="ln1504">                    G_CALLBACK (_style_callback),</a>
<a name="ln1505">                    (gpointer)self);</a>
<a name="ln1506"> </a>
<a name="ln1507">  //  Whether to add/replace style items</a>
<a name="ln1508"> </a>
<a name="ln1509">  d-&gt;style_mode = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1510">  dt_bauhaus_widget_set_label(d-&gt;style_mode, NULL, _(&quot;mode&quot;));</a>
<a name="ln1511"> </a>
<a name="ln1512">  dt_bauhaus_combobox_add(d-&gt;style_mode, _(&quot;replace history&quot;));</a>
<a name="ln1513">  dt_bauhaus_combobox_add(d-&gt;style_mode, _(&quot;append history&quot;));</a>
<a name="ln1514"> </a>
<a name="ln1515">  d-&gt;v_style_append = dt_conf_get_bool(&quot;plugins/print/print/style_append&quot;);</a>
<a name="ln1516">  dt_bauhaus_combobox_set(d-&gt;style_mode, d-&gt;v_style_append?1:0);</a>
<a name="ln1517"> </a>
<a name="ln1518">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;style_mode), TRUE, TRUE, 0);</a>
<a name="ln1519">  gtk_widget_set_tooltip_text(d-&gt;style_mode,</a>
<a name="ln1520">                              _(&quot;whether the style items are appended to the history or replacing the history&quot;));</a>
<a name="ln1521"> </a>
<a name="ln1522">  gtk_widget_set_sensitive(GTK_WIDGET(d-&gt;style_mode), combo_idx==0?FALSE:TRUE);</a>
<a name="ln1523"> </a>
<a name="ln1524">  g_signal_connect(G_OBJECT(d-&gt;style_mode), &quot;value-changed&quot;, G_CALLBACK(_style_mode_changed), (gpointer)self);</a>
<a name="ln1525"> </a>
<a name="ln1526">  // Print button</a>
<a name="ln1527"> </a>
<a name="ln1528">  GtkButton *button = GTK_BUTTON(gtk_button_new_with_label(_(&quot;print&quot;)));</a>
<a name="ln1529">  d-&gt;print_button = button;</a>
<a name="ln1530">  gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;print with current settings&quot;));</a>
<a name="ln1531">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(button), TRUE, TRUE, 0);</a>
<a name="ln1532">  dt_gui_add_help_link(GTK_WIDGET(button), &quot;print_button.html#print_button&quot;);</a>
<a name="ln1533"> </a>
<a name="ln1534">  g_signal_connect (G_OBJECT (button), &quot;clicked&quot;,</a>
<a name="ln1535">                    G_CALLBACK (_print_button_clicked),</a>
<a name="ln1536">                    (gpointer)self);</a>
<a name="ln1537"> </a>
<a name="ln1538">  g_free(system_profile_dir);</a>
<a name="ln1539">  g_free(user_profile_dir);</a>
<a name="ln1540"> </a>
<a name="ln1541">  // Let's start the printer discovery now</a>
<a name="ln1542"> </a>
<a name="ln1543">  dt_printers_discovery(_new_printer_callback, self);</a>
<a name="ln1544">}</a>
<a name="ln1545"> </a>
<a name="ln1546">void init_presets(dt_lib_module_t *self)</a>
<a name="ln1547">{</a>
<a name="ln1548">}</a>
<a name="ln1549"> </a>
<a name="ln1550">void *legacy_params(dt_lib_module_t *self, const void *const old_params, const size_t old_params_size,</a>
<a name="ln1551">                    const int old_version, int *new_version, size_t *new_size)</a>
<a name="ln1552">{</a>
<a name="ln1553">  if(old_version == 1)</a>
<a name="ln1554">  {</a>
<a name="ln1555">    // we added the profile type</a>
<a name="ln1556">    //</a>
<a name="ln1557">    // old format:</a>
<a name="ln1558">    //   char *printer</a>
<a name="ln1559">    //   char *paper</a>
<a name="ln1560">    //   int32_t landscape</a>
<a name="ln1561">    //   char *f_profile</a>
<a name="ln1562">    //   int32_t intent</a>
<a name="ln1563">    //   char *f_pprofile</a>
<a name="ln1564">    //   &lt;rest&gt;</a>
<a name="ln1565">    //</a>
<a name="ln1566">    // new format:</a>
<a name="ln1567">    //   char *printer</a>
<a name="ln1568">    //   char *paper</a>
<a name="ln1569">    //   int32_t landscape</a>
<a name="ln1570">    //   int32_t f_profile_type</a>
<a name="ln1571">    //   char *f_profile</a>
<a name="ln1572">    //   int32_t intent</a>
<a name="ln1573">    //   int32_t f_pprofile_type</a>
<a name="ln1574">    //   char *f_pprofile</a>
<a name="ln1575">    //   &lt;rest&gt;</a>
<a name="ln1576"> </a>
<a name="ln1577">    const char *buf = (const char *)old_params;</a>
<a name="ln1578"> </a>
<a name="ln1579">    // printer</a>
<a name="ln1580">    const char *printer = buf;</a>
<a name="ln1581">    const int32_t printer_len = strlen(printer) + 1;</a>
<a name="ln1582">    buf += printer_len;</a>
<a name="ln1583"> </a>
<a name="ln1584">    // paper</a>
<a name="ln1585">    const char *paper = buf;</a>
<a name="ln1586">    const int32_t paper_len = strlen(paper) + 1;</a>
<a name="ln1587">    buf += paper_len;</a>
<a name="ln1588"> </a>
<a name="ln1589">    // landscape</a>
<a name="ln1590">    const int32_t landscape = *(int32_t *)buf;</a>
<a name="ln1591">    buf +=  sizeof(int32_t);</a>
<a name="ln1592"> </a>
<a name="ln1593">    // profile</a>
<a name="ln1594">    const char *profile = buf;</a>
<a name="ln1595">    const int32_t profile_len = strlen(profile) + 1;</a>
<a name="ln1596">    buf += profile_len;</a>
<a name="ln1597"> </a>
<a name="ln1598">    // intent</a>
<a name="ln1599">    const int32_t intent = *(int32_t *)buf;</a>
<a name="ln1600">    buf += sizeof(int32_t);</a>
<a name="ln1601"> </a>
<a name="ln1602">    // pprofile</a>
<a name="ln1603">    const char *pprofile = buf;</a>
<a name="ln1604">    const int32_t pprofile_len = strlen(pprofile) + 1;</a>
<a name="ln1605">    buf += pprofile_len;</a>
<a name="ln1606"> </a>
<a name="ln1607"> </a>
<a name="ln1608">    // now we got all fields from the start of the buffer and buf points to the beginning or &lt;rest&gt;</a>
<a name="ln1609"> </a>
<a name="ln1610">    // find the new values for the two profiles</a>
<a name="ln1611">    dt_colorspaces_color_profile_type_t profile_type, pprofile_type;</a>
<a name="ln1612">    const char *profile_filename = &quot;&quot;, *pprofile_filename = &quot;&quot;;</a>
<a name="ln1613"> </a>
<a name="ln1614">    if(*profile == '\0' || !g_strcmp0(profile, &quot;none&quot;))</a>
<a name="ln1615">    {</a>
<a name="ln1616">      profile_type = DT_COLORSPACE_NONE;</a>
<a name="ln1617">    }</a>
<a name="ln1618">    else if(!g_strcmp0(profile, &quot;sRGB&quot;))</a>
<a name="ln1619">    {</a>
<a name="ln1620">      profile_type = DT_COLORSPACE_SRGB;</a>
<a name="ln1621">    }</a>
<a name="ln1622">    else if(!g_strcmp0(profile, &quot;adobergb&quot;))</a>
<a name="ln1623">    {</a>
<a name="ln1624">      profile_type = DT_COLORSPACE_ADOBERGB;</a>
<a name="ln1625">    }</a>
<a name="ln1626">    else</a>
<a name="ln1627">    {</a>
<a name="ln1628">      profile_type = DT_COLORSPACE_FILE;</a>
<a name="ln1629">      profile_filename = &amp;profile[1]; // the old code had a '/' in the beginning</a>
<a name="ln1630">    }</a>
<a name="ln1631"> </a>
<a name="ln1632">    // in theory pprofile can't be srgb or adobergb, but checking for them won't hurt</a>
<a name="ln1633">    if(*pprofile == '\0')</a>
<a name="ln1634">    {</a>
<a name="ln1635">      pprofile_type = DT_COLORSPACE_NONE;</a>
<a name="ln1636">    }</a>
<a name="ln1637">    else if(!g_strcmp0(pprofile, &quot;sRGB&quot;))</a>
<a name="ln1638">    {</a>
<a name="ln1639">      pprofile_type = DT_COLORSPACE_SRGB;</a>
<a name="ln1640">    }</a>
<a name="ln1641">    else if(!g_strcmp0(pprofile, &quot;adobergb&quot;))</a>
<a name="ln1642">    {</a>
<a name="ln1643">      pprofile_type = DT_COLORSPACE_ADOBERGB;</a>
<a name="ln1644">    }</a>
<a name="ln1645">    else</a>
<a name="ln1646">    {</a>
<a name="ln1647">      pprofile_type = DT_COLORSPACE_FILE;</a>
<a name="ln1648">      pprofile_filename = &amp;pprofile[1]; // the old code had a '/' in the beginning</a>
<a name="ln1649">    }</a>
<a name="ln1650"> </a>
<a name="ln1651">    int32_t new_profile_len = strlen(profile_filename) + 1;</a>
<a name="ln1652">    int32_t new_pprofile_len = strlen(pprofile_filename) + 1;</a>
<a name="ln1653"> </a>
<a name="ln1654">    // now we got everything to reassemble the new params</a>
<a name="ln1655">    size_t new_params_size = old_params_size - profile_len - pprofile_len;</a>
<a name="ln1656">    new_params_size += 2 * sizeof(dt_colorspaces_color_profile_type_t);</a>
<a name="ln1657">    new_params_size += new_profile_len + new_pprofile_len;</a>
<a name="ln1658">    void *new_params = malloc(new_params_size);</a>
<a name="ln1659"> </a>
<a name="ln1660">    size_t pos = 0;</a>
<a name="ln1661">    //   char *printer</a>
<a name="ln1662">    memcpy(new_params + pos, printer, printer_len);</a>
<a name="ln1663">    pos += printer_len;</a>
<a name="ln1664">    //   char *paper</a>
<a name="ln1665">    memcpy(new_params + pos, paper, paper_len);</a>
<a name="ln1666">    pos += paper_len;</a>
<a name="ln1667">    //   int32_t landscape</a>
<a name="ln1668">    memcpy(new_params + pos, &amp;landscape, sizeof(int32_t));</a>
<a name="ln1669">    pos += sizeof(int32_t);</a>
<a name="ln1670">    //   int32_t f_profile_type</a>
<a name="ln1671">    memcpy(new_params + pos, &amp;profile_type, sizeof(int32_t));</a>
<a name="ln1672">    pos += sizeof(int32_t);</a>
<a name="ln1673">    //   char *f_profile</a>
<a name="ln1674">    memcpy(new_params + pos, profile_filename, new_profile_len);</a>
<a name="ln1675">    pos += new_profile_len;</a>
<a name="ln1676">    //   int32_t intent</a>
<a name="ln1677">    memcpy(new_params + pos, &amp;intent, sizeof(int32_t));</a>
<a name="ln1678">    pos += sizeof(int32_t);</a>
<a name="ln1679">    //   int32_t f_pprofile_type</a>
<a name="ln1680">    memcpy(new_params + pos, &amp;pprofile_type, sizeof(int32_t));</a>
<a name="ln1681">    pos += sizeof(int32_t);</a>
<a name="ln1682">    //   char *f_pprofile</a>
<a name="ln1683">    memcpy(new_params + pos, pprofile_filename, new_pprofile_len);</a>
<a name="ln1684">    pos += new_pprofile_len;</a>
<a name="ln1685">    //   &lt;rest&gt;</a>
<a name="ln1686">    memcpy(new_params + pos, buf, old_params_size - ((char *)buf - (char *)old_params));</a>
<a name="ln1687"> </a>
<a name="ln1688">    *new_size = new_params_size;</a>
<a name="ln1689">    *new_version = 2;</a>
<a name="ln1690">    return new_params;</a>
<a name="ln1691">  }</a>
<a name="ln1692">  else if(old_version == 2)</a>
<a name="ln1693">  {</a>
<a name="ln1694">    // add upscale to params</a>
<a name="ln1695">    size_t new_params_size = old_params_size + 1;</a>
<a name="ln1696">    void *new_params = calloc(1, new_params_size);</a>
<a name="ln1697"> </a>
<a name="ln1698">    memcpy(new_params, old_params, old_params_size);</a>
<a name="ln1699">    // no media type specified</a>
<a name="ln1700">    ((char *)new_params)[old_params_size] = '\0';</a>
<a name="ln1701"> </a>
<a name="ln1702">    *new_size = new_params_size;</a>
<a name="ln1703">    *new_version = 3;</a>
<a name="ln1704">    return new_params;</a>
<a name="ln1705">  }</a>
<a name="ln1706"> </a>
<a name="ln1707">  return NULL;</a>
<a name="ln1708">}</a>
<a name="ln1709"> </a>
<a name="ln1710">int set_params(dt_lib_module_t *self, const void *params, int size)</a>
<a name="ln1711">{</a>
<a name="ln1712">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1713"> </a>
<a name="ln1714">  if(!params) return 1;</a>
<a name="ln1715"> </a>
<a name="ln1716">  // get the parameters buffer</a>
<a name="ln1717">  const char *buf = (char *)params;</a>
<a name="ln1718"> </a>
<a name="ln1719">  // get individual items</a>
<a name="ln1720">  const char *printer = buf;</a>
<a name="ln1721">  if (!printer) return 1;</a>
<a name="ln1722">  const int32_t printer_len = strlen(printer) + 1;</a>
<a name="ln1723">  buf += printer_len;</a>
<a name="ln1724"> </a>
<a name="ln1725">  const char *paper = buf;</a>
<a name="ln1726">  if (!paper) return 1;</a>
<a name="ln1727">  const int32_t paper_len = strlen(paper) + 1;</a>
<a name="ln1728">  buf += paper_len;</a>
<a name="ln1729"> </a>
<a name="ln1730">  const int32_t landscape = *(int32_t *)buf;</a>
<a name="ln1731">  buf +=  sizeof(int32_t);</a>
<a name="ln1732"> </a>
<a name="ln1733">  const int32_t f_profile_type = *(int32_t *)buf;</a>
<a name="ln1734">  buf +=  sizeof(int32_t);</a>
<a name="ln1735"> </a>
<a name="ln1736">  const char *f_profile = buf;</a>
<a name="ln1737">  if (!f_profile) return 1;</a>
<a name="ln1738">  const int32_t profile_len = strlen(f_profile) + 1;</a>
<a name="ln1739">  buf += profile_len;</a>
<a name="ln1740"> </a>
<a name="ln1741">  const int32_t intent = *(int32_t *)buf;</a>
<a name="ln1742">  buf += sizeof(int32_t);</a>
<a name="ln1743"> </a>
<a name="ln1744">  const int32_t f_pprofile_type = *(int32_t *)buf;</a>
<a name="ln1745">  buf +=  sizeof(int32_t);</a>
<a name="ln1746"> </a>
<a name="ln1747">  const char *f_pprofile = buf;</a>
<a name="ln1748">  if (!f_pprofile) return 1;</a>
<a name="ln1749">  const int32_t pprofile_len = strlen(f_pprofile) + 1;</a>
<a name="ln1750">  buf += pprofile_len;</a>
<a name="ln1751"> </a>
<a name="ln1752">  const int32_t pintent = *(int32_t *)buf;</a>
<a name="ln1753">  buf += sizeof(int32_t);</a>
<a name="ln1754"> </a>
<a name="ln1755">  const int32_t bpc = *(int32_t *)buf;</a>
<a name="ln1756">  buf += sizeof(int32_t);</a>
<a name="ln1757"> </a>
<a name="ln1758">  const char *style = buf;</a>
<a name="ln1759">  if (!style) return 1;</a>
<a name="ln1760">  const int32_t style_len = strlen(style) + 1;</a>
<a name="ln1761">  buf += style_len;</a>
<a name="ln1762"> </a>
<a name="ln1763">  const int32_t style_mode = *(int32_t *)buf;</a>
<a name="ln1764">  buf += sizeof(int32_t);</a>
<a name="ln1765"> </a>
<a name="ln1766">  const double b_top = *(double *)buf;</a>
<a name="ln1767">  buf += sizeof(double);</a>
<a name="ln1768"> </a>
<a name="ln1769">  const double b_bottom = *(double *)buf;</a>
<a name="ln1770">  buf += sizeof(double);</a>
<a name="ln1771"> </a>
<a name="ln1772">  const double b_left = *(double *)buf;</a>
<a name="ln1773">  buf += sizeof(double);</a>
<a name="ln1774"> </a>
<a name="ln1775">  const double b_right = *(double *)buf;</a>
<a name="ln1776">  buf += sizeof(double);</a>
<a name="ln1777"> </a>
<a name="ln1778">  const int32_t alignment = *(int32_t *)buf;</a>
<a name="ln1779">  buf += sizeof(int32_t);</a>
<a name="ln1780"> </a>
<a name="ln1781">  const char *media = buf;</a>
<a name="ln1782">  if (!media) return 1;</a>
<a name="ln1783">  const int32_t media_len = strlen(media) + 1;</a>
<a name="ln1784">  // buf += media_len;</a>
<a name="ln1785"> </a>
<a name="ln1786">  // ensure that the size is correct</a>
<a name="ln1787">  if(size != printer_len + paper_len + media_len + profile_len + pprofile_len + style_len + 8 * sizeof(int32_t) + 4 * sizeof(double))</a>
<a name="ln1788">    return 1;</a>
<a name="ln1789"> </a>
<a name="ln1790">  // set the GUI with corresponding values</a>
<a name="ln1791">  if (printer[0] != '\0')</a>
<a name="ln1792">    dt_bauhaus_combobox_set_from_text(ps-&gt;printers, printer);</a>
<a name="ln1793"> </a>
<a name="ln1794">  if (paper[0] != '\0')</a>
<a name="ln1795">    dt_bauhaus_combobox_set_from_text(ps-&gt;papers, paper);</a>
<a name="ln1796"> </a>
<a name="ln1797">  if (media[0] != '\0')</a>
<a name="ln1798">    dt_bauhaus_combobox_set_from_text(ps-&gt;media, media);</a>
<a name="ln1799"> </a>
<a name="ln1800">  dt_bauhaus_combobox_set (ps-&gt;orientation, landscape);</a>
<a name="ln1801"> </a>
<a name="ln1802">  dt_bauhaus_combobox_set(ps-&gt;profile, 0);</a>
<a name="ln1803">  for(GList *iter = ps-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln1804">  {</a>
<a name="ln1805">    dt_lib_export_profile_t *p = (dt_lib_export_profile_t *)iter-&gt;data;</a>
<a name="ln1806">    if(f_profile_type == p-&gt;type &amp;&amp; (f_profile_type != DT_COLORSPACE_FILE || !g_strcmp0(f_profile, p-&gt;filename)))</a>
<a name="ln1807">    {</a>
<a name="ln1808">      dt_bauhaus_combobox_set(ps-&gt;profile, p-&gt;pos);</a>
<a name="ln1809">      break;</a>
<a name="ln1810">    }</a>
<a name="ln1811">  }</a>
<a name="ln1812"> </a>
<a name="ln1813">  dt_bauhaus_combobox_set (ps-&gt;intent, intent);</a>
<a name="ln1814"> </a>
<a name="ln1815">  dt_bauhaus_combobox_set(ps-&gt;pprofile, 0);</a>
<a name="ln1816">  for(GList *iter = ps-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln1817">  {</a>
<a name="ln1818">    dt_lib_export_profile_t *p = (dt_lib_export_profile_t *)iter-&gt;data;</a>
<a name="ln1819">    if(f_pprofile_type == p-&gt;type &amp;&amp; (f_pprofile_type != DT_COLORSPACE_FILE || !g_strcmp0(f_pprofile, p-&gt;filename)))</a>
<a name="ln1820">    {</a>
<a name="ln1821">      dt_bauhaus_combobox_set(ps-&gt;pprofile, p-&gt;ppos);</a>
<a name="ln1822">      break;</a>
<a name="ln1823">    }</a>
<a name="ln1824">  }</a>
<a name="ln1825"> </a>
<a name="ln1826">  dt_bauhaus_combobox_set (ps-&gt;pintent, pintent);</a>
<a name="ln1827">  ps-&gt;prt.printer.intent = pintent;</a>
<a name="ln1828"> </a>
<a name="ln1829">  if (style[0] != '\0')</a>
<a name="ln1830">    dt_bauhaus_combobox_set_from_text(ps-&gt;style, style);</a>
<a name="ln1831">  dt_bauhaus_combobox_set (ps-&gt;style_mode, style_mode);</a>
<a name="ln1832"> </a>
<a name="ln1833">  gtk_spin_button_set_value (GTK_SPIN_BUTTON(ps-&gt;b_top), b_top * units[ps-&gt;unit]);</a>
<a name="ln1834">  gtk_spin_button_set_value (GTK_SPIN_BUTTON(ps-&gt;b_bottom), b_bottom * units[ps-&gt;unit]);</a>
<a name="ln1835">  gtk_spin_button_set_value (GTK_SPIN_BUTTON(ps-&gt;b_left), b_left * units[ps-&gt;unit]);</a>
<a name="ln1836">  gtk_spin_button_set_value (GTK_SPIN_BUTTON(ps-&gt;b_right), b_right * units[ps-&gt;unit]);</a>
<a name="ln1837"> </a>
<a name="ln1838">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;dtba[alignment]),TRUE);</a>
<a name="ln1839">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;black_point_compensation), bpc);</a>
<a name="ln1840"> </a>
<a name="ln1841">  return 0;</a>
<a name="ln1842">}</a>
<a name="ln1843"> </a>
<a name="ln1844">void *get_params(dt_lib_module_t *self, int *size)</a>
<a name="ln1845">{</a>
<a name="ln1846">  const dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1847"> </a>
<a name="ln1848">  // get the data</a>
<a name="ln1849">  const char *printer = dt_bauhaus_combobox_get_text(ps-&gt;printers);</a>
<a name="ln1850">  const char *paper = dt_bauhaus_combobox_get_text(ps-&gt;papers);</a>
<a name="ln1851">  const char *media = dt_bauhaus_combobox_get_text(ps-&gt;media);</a>
<a name="ln1852">  const int32_t profile_pos = dt_bauhaus_combobox_get(ps-&gt;profile);</a>
<a name="ln1853">  const int32_t intent =  dt_bauhaus_combobox_get(ps-&gt;intent);</a>
<a name="ln1854">  const char *style = dt_bauhaus_combobox_get_text(ps-&gt;style);</a>
<a name="ln1855">  const int32_t style_mode = dt_bauhaus_combobox_get(ps-&gt;style_mode);</a>
<a name="ln1856">  const int32_t pprofile_pos = dt_bauhaus_combobox_get(ps-&gt;pprofile);</a>
<a name="ln1857">  const int32_t pintent =  dt_bauhaus_combobox_get(ps-&gt;pintent);</a>
<a name="ln1858">  const int32_t landscape = dt_bauhaus_combobox_get(ps-&gt;orientation);</a>
<a name="ln1859">  const int32_t bpc = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ps-&gt;black_point_compensation));</a>
<a name="ln1860">  const double b_top = ps-&gt;prt.page.margin_top;</a>
<a name="ln1861">  const double b_bottom = ps-&gt;prt.page.margin_bottom;</a>
<a name="ln1862">  const double b_left = ps-&gt;prt.page.margin_left;</a>
<a name="ln1863">  const double b_right = ps-&gt;prt.page.margin_right;</a>
<a name="ln1864">  const int32_t alignment = ps-&gt;prt.page.alignment;</a>
<a name="ln1865"> </a>
<a name="ln1866">  dt_colorspaces_color_profile_type_t profile_type = DT_COLORSPACE_NONE, pprofile_type = DT_COLORSPACE_NONE;</a>
<a name="ln1867">  const char *profile = &quot;&quot;, *pprofile = &quot;&quot;;</a>
<a name="ln1868">  for(GList *iter = ps-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln1869">  {</a>
<a name="ln1870">    dt_lib_export_profile_t *p = (dt_lib_export_profile_t *)iter-&gt;data;</a>
<a name="ln1871">    if(p-&gt;pos == profile_pos)</a>
<a name="ln1872">    {</a>
<a name="ln1873">      profile_type = p-&gt;type;</a>
<a name="ln1874">      profile = p-&gt;filename;</a>
<a name="ln1875">    }</a>
<a name="ln1876">    if(p-&gt;ppos == pprofile_pos)</a>
<a name="ln1877">    {</a>
<a name="ln1878">      pprofile_type = p-&gt;type;</a>
<a name="ln1879">      pprofile = p-&gt;filename;</a>
<a name="ln1880">    }</a>
<a name="ln1881">  }</a>
<a name="ln1882"> </a>
<a name="ln1883">  // these will be NULL when no printer is connected/found</a>
<a name="ln1884">  if(!printer) printer = &quot;&quot;;</a>
<a name="ln1885">  if(!paper) paper = &quot;&quot;;</a>
<a name="ln1886">  if(!media) media = &quot;&quot;;</a>
<a name="ln1887"> </a>
<a name="ln1888">  // compute the size of individual items, always get the \0 for strings</a>
<a name="ln1889">  const int32_t printer_len = strlen (printer) + 1;</a>
<a name="ln1890">  const int32_t paper_len = strlen (paper) + 1;</a>
<a name="ln1891">  const int32_t media_len = strlen (media) + 1;</a>
<a name="ln1892">  const int32_t profile_len = strlen (profile) + 1;</a>
<a name="ln1893">  const int32_t pprofile_len = strlen (pprofile) + 1;</a>
<a name="ln1894">  const int32_t style_len = strlen (style) + 1;</a>
<a name="ln1895"> </a>
<a name="ln1896">  // compute the size of all parameters</a>
<a name="ln1897">  *size = printer_len + paper_len + media_len + profile_len + pprofile_len + style_len + 8 * sizeof(int32_t) + 4 * sizeof(double);</a>
<a name="ln1898"> </a>
<a name="ln1899">  // allocate the parameter buffer</a>
<a name="ln1900">  char *params = (char *)malloc(*size);</a>
<a name="ln1901"> </a>
<a name="ln1902">  int pos = 0;</a>
<a name="ln1903"> </a>
<a name="ln1904">  memcpy(params+pos, printer, printer_len);</a>
<a name="ln1905">  pos += printer_len;</a>
<a name="ln1906">  memcpy(params+pos, paper, paper_len);</a>
<a name="ln1907">  pos += paper_len;</a>
<a name="ln1908">  memcpy(params+pos, &amp;landscape, sizeof(int32_t));</a>
<a name="ln1909">  pos += sizeof(int32_t);</a>
<a name="ln1910">  memcpy(params+pos, &amp;profile_type, sizeof(int32_t));</a>
<a name="ln1911">  pos += sizeof(int32_t);</a>
<a name="ln1912">  memcpy(params+pos, profile, profile_len);</a>
<a name="ln1913">  pos += profile_len;</a>
<a name="ln1914">  memcpy(params+pos, &amp;intent, sizeof(int32_t));</a>
<a name="ln1915">  pos += sizeof(int32_t);</a>
<a name="ln1916">  memcpy(params+pos, &amp;pprofile_type, sizeof(int32_t));</a>
<a name="ln1917">  pos += sizeof(int32_t);</a>
<a name="ln1918">  memcpy(params+pos, pprofile, pprofile_len);</a>
<a name="ln1919">  pos += pprofile_len;</a>
<a name="ln1920">  memcpy(params+pos, &amp;pintent, sizeof(int32_t));</a>
<a name="ln1921">  pos += sizeof(int32_t);</a>
<a name="ln1922">  memcpy(params+pos, &amp;bpc, sizeof(int32_t));</a>
<a name="ln1923">  pos += sizeof(int32_t);</a>
<a name="ln1924">  memcpy(params+pos, style, style_len);</a>
<a name="ln1925">  pos += style_len;</a>
<a name="ln1926">  memcpy(params+pos, &amp;style_mode, sizeof(int32_t));</a>
<a name="ln1927">  pos += sizeof(int32_t);</a>
<a name="ln1928">  memcpy(params+pos, &amp;b_top, sizeof(double));</a>
<a name="ln1929">  pos += sizeof(double);</a>
<a name="ln1930">  memcpy(params+pos, &amp;b_bottom, sizeof(double));</a>
<a name="ln1931">  pos += sizeof(double);</a>
<a name="ln1932">  memcpy(params+pos, &amp;b_left, sizeof(double));</a>
<a name="ln1933">  pos += sizeof(double);</a>
<a name="ln1934">  memcpy(params+pos, &amp;b_right, sizeof(double));</a>
<a name="ln1935">  pos += sizeof(double);</a>
<a name="ln1936">  memcpy(params+pos, &amp;alignment, sizeof(int32_t));</a>
<a name="ln1937">  pos += sizeof(int32_t);</a>
<a name="ln1938">  memcpy(params+pos, media, media_len);</a>
<a name="ln1939">  pos += media_len;</a>
<a name="ln1940"> </a>
<a name="ln1941">  g_assert(pos == *size);</a>
<a name="ln1942"> </a>
<a name="ln1943">  return params;</a>
<a name="ln1944">}</a>
<a name="ln1945"> </a>
<a name="ln1946">void</a>
<a name="ln1947">gui_cleanup (dt_lib_module_t *self)</a>
<a name="ln1948">{</a>
<a name="ln1949">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1950"> </a>
<a name="ln1951">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ps-&gt;b_top));</a>
<a name="ln1952">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ps-&gt;b_left));</a>
<a name="ln1953">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ps-&gt;b_right));</a>
<a name="ln1954">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ps-&gt;b_bottom));</a>
<a name="ln1955"> </a>
<a name="ln1956">  g_list_free_full(ps-&gt;profiles, g_free);</a>
<a name="ln1957">  g_list_free_full(ps-&gt;paper_list, free);</a>
<a name="ln1958">  g_list_free_full(ps-&gt;media_list, free);</a>
<a name="ln1959"> </a>
<a name="ln1960">  g_free(ps-&gt;v_iccprofile);</a>
<a name="ln1961">  g_free(ps-&gt;v_piccprofile);</a>
<a name="ln1962">  g_free(ps-&gt;v_style);</a>
<a name="ln1963"> </a>
<a name="ln1964">  free(self-&gt;data);</a>
<a name="ln1965">  self-&gt;data = NULL;</a>
<a name="ln1966">}</a>
<a name="ln1967"> </a>
<a name="ln1968">void</a>
<a name="ln1969">gui_reset (dt_lib_module_t *self)</a>
<a name="ln1970">{</a>
<a name="ln1971">  dt_lib_print_settings_t *ps = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln1972"> </a>
<a name="ln1973">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_top), 17 * units[ps-&gt;unit]);</a>
<a name="ln1974">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_bottom), 17 * units[ps-&gt;unit]);</a>
<a name="ln1975">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_left), 17 * units[ps-&gt;unit]);</a>
<a name="ln1976">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(ps-&gt;b_right), 17 * units[ps-&gt;unit]);</a>
<a name="ln1977">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;dtba[ALIGNMENT_CENTER]), TRUE);</a>
<a name="ln1978">  ps-&gt;prt.page.alignment = ALIGNMENT_CENTER;</a>
<a name="ln1979">  ps-&gt;prt.printer.intent = DT_INTENT_PERCEPTUAL;</a>
<a name="ln1980">  dt_bauhaus_combobox_set(ps-&gt;profile, 0);</a>
<a name="ln1981">  dt_bauhaus_combobox_set(ps-&gt;pprofile, 0);</a>
<a name="ln1982">  dt_bauhaus_combobox_set(ps-&gt;pintent, 0);</a>
<a name="ln1983">  dt_bauhaus_combobox_set(ps-&gt;style, 0);</a>
<a name="ln1984">  dt_bauhaus_combobox_set(ps-&gt;intent, 0);</a>
<a name="ln1985">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ps-&gt;black_point_compensation), TRUE);</a>
<a name="ln1986">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;pintent), TRUE);</a>
<a name="ln1987">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;black_point_compensation), FALSE);</a>
<a name="ln1988">  gtk_widget_set_sensitive(GTK_WIDGET(ps-&gt;style_mode), FALSE);</a>
<a name="ln1989"> </a>
<a name="ln1990">  // reset page orientation to fit the picture</a>
<a name="ln1991"> </a>
<a name="ln1992">  _set_orientation (ps);</a>
<a name="ln1993">}</a>
<a name="ln1994"> </a>
<a name="ln1995">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln1996">{</a>
<a name="ln1997">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;print&quot;), GDK_KEY_p, GDK_CONTROL_MASK);</a>
<a name="ln1998">}</a>
<a name="ln1999"> </a>
<a name="ln2000">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln2001">{</a>
<a name="ln2002">  dt_lib_print_settings_t *d = (dt_lib_print_settings_t *)self-&gt;data;</a>
<a name="ln2003"> </a>
<a name="ln2004">  dt_accel_connect_button_lib(self, &quot;print&quot;, GTK_WIDGET(d-&gt;print_button));</a>
<a name="ln2005">}</a>
<a name="ln2006"> </a>
<a name="ln2007">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2008">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2009">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 163, 154.</p></div>
<div class="balloon" rel="173"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 173, 154.</p></div>
<div class="balloon" rel="410"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'params'. Check lines: 410, 407.</p></div>
<div class="balloon" rel="1125"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 1125, 1111.</p></div>
<div class="balloon" rel="1204"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: prof->type != DT_COLORSPACE_FILE.</p></div>
<div class="balloon" rel="1489"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="1662"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'new_params' pointer in the 'new_params + pos' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 1662, 1658.</p></div>
<div class="balloon" rel="1698"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1698, 1696.</p></div>
<div class="balloon" rel="1721"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!printer' is always false.</p></div>
<div class="balloon" rel="1726"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!paper' is always false.</p></div>
<div class="balloon" rel="1737"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!f_profile' is always false.</p></div>
<div class="balloon" rel="1748"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!f_pprofile' is always false.</p></div>
<div class="balloon" rel="1759"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!style' is always false.</p></div>
<div class="balloon" rel="1782"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!media' is always false.</p></div>
<div class="balloon" rel="1904"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'params' pointer in the 'params + pos' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 1904, 1900.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
