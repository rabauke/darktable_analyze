
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4">    copyright (c) 2011 henrik andersson.</a>
<a name="ln5">    copyright (c) 2016 Roman Lebedev.</a>
<a name="ln6"> </a>
<a name="ln7">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln8">    it under the terms of the GNU General Public License as published by</a>
<a name="ln9">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln10">    (at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln13">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">    GNU General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">    You should have received a copy of the GNU General Public License</a>
<a name="ln18">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln19">*/</a>
<a name="ln20">#include &quot;common/color_picker.h&quot;</a>
<a name="ln21">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln22">#include &quot;common/histogram.h&quot;</a>
<a name="ln23">#include &quot;common/imageio.h&quot;</a>
<a name="ln24">#include &quot;common/opencl.h&quot;</a>
<a name="ln25">#include &quot;control/control.h&quot;</a>
<a name="ln26">#include &quot;control/signal.h&quot;</a>
<a name="ln27">#include &quot;develop/blend.h&quot;</a>
<a name="ln28">#include &quot;develop/format.h&quot;</a>
<a name="ln29">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln30">#include &quot;develop/pixelpipe.h&quot;</a>
<a name="ln31">#include &quot;develop/tiling.h&quot;</a>
<a name="ln32">#include &quot;develop/masks.h&quot;</a>
<a name="ln33">#include &quot;gui/gtk.h&quot;</a>
<a name="ln34">#include &quot;libs/colorpicker.h&quot;</a>
<a name="ln35">#include &quot;libs/lib.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;assert.h&gt;</a>
<a name="ln38">#include &lt;math.h&gt;</a>
<a name="ln39">#include &lt;stdint.h&gt;</a>
<a name="ln40">#include &lt;stdlib.h&gt;</a>
<a name="ln41">#include &lt;string.h&gt;</a>
<a name="ln42">#include &lt;strings.h&gt;</a>
<a name="ln43">#include &lt;unistd.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">typedef enum dt_pixelpipe_flow_t</a>
<a name="ln46">{</a>
<a name="ln47">  PIXELPIPE_FLOW_NONE = 0,</a>
<a name="ln48">  PIXELPIPE_FLOW_HISTOGRAM_NONE = 1 &lt;&lt; 0,</a>
<a name="ln49">  PIXELPIPE_FLOW_HISTOGRAM_ON_CPU = 1 &lt;&lt; 1,</a>
<a name="ln50">  PIXELPIPE_FLOW_HISTOGRAM_ON_GPU = 1 &lt;&lt; 2,</a>
<a name="ln51">  PIXELPIPE_FLOW_PROCESSED_ON_CPU = 1 &lt;&lt; 3,</a>
<a name="ln52">  PIXELPIPE_FLOW_PROCESSED_ON_GPU = 1 &lt;&lt; 4,</a>
<a name="ln53">  PIXELPIPE_FLOW_PROCESSED_WITH_TILING = 1 &lt;&lt; 5,</a>
<a name="ln54">  PIXELPIPE_FLOW_BLENDED_ON_CPU = 1 &lt;&lt; 6,</a>
<a name="ln55">  PIXELPIPE_FLOW_BLENDED_ON_GPU = 1 &lt;&lt; 7</a>
<a name="ln56">} dt_pixelpipe_flow_t;</a>
<a name="ln57"> </a>
<a name="ln58">typedef enum dt_pixelpipe_picker_source_t</a>
<a name="ln59">{</a>
<a name="ln60">  PIXELPIPE_PICKER_INPUT = 0,</a>
<a name="ln61">  PIXELPIPE_PICKER_OUTPUT = 1</a>
<a name="ln62">} dt_pixelpipe_picker_source_t;</a>
<a name="ln63"> </a>
<a name="ln64">#include &quot;develop/pixelpipe_cache.c&quot;</a>
<a name="ln65"> </a>
<a name="ln66">static void get_output_format(dt_iop_module_t *module, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln67">                              dt_develop_t *dev, dt_iop_buffer_dsc_t *dsc);</a>
<a name="ln68"> </a>
<a name="ln69">static char *_pipe_type_to_str(int pipe_type)</a>
<a name="ln70">{</a>
<a name="ln71">  char *r;</a>
<a name="ln72"> </a>
<a name="ln73">  switch(pipe_type)</a>
<a name="ln74">  {</a>
<a name="ln75">    case DT_DEV_PIXELPIPE_PREVIEW:</a>
<a name="ln76">      r = &quot;preview&quot;;</a>
<a name="ln77">      break;</a>
<a name="ln78">    case DT_DEV_PIXELPIPE_FULL:</a>
<a name="ln79">      r = &quot;full&quot;;</a>
<a name="ln80">      break;</a>
<a name="ln81">    case DT_DEV_PIXELPIPE_THUMBNAIL:</a>
<a name="ln82">      r = &quot;thumbnail&quot;;</a>
<a name="ln83">      break;</a>
<a name="ln84">    case DT_DEV_PIXELPIPE_EXPORT:</a>
<a name="ln85">      r = &quot;export&quot;;</a>
<a name="ln86">      break;</a>
<a name="ln87">    default:</a>
<a name="ln88">      r = &quot;unknown&quot;;</a>
<a name="ln89">  }</a>
<a name="ln90">  return r;</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">int dt_dev_pixelpipe_init_export(dt_dev_pixelpipe_t *pipe, int32_t width, int32_t height, int levels,</a>
<a name="ln94">                                 gboolean store_masks)</a>
<a name="ln95">{</a>
<a name="ln96">  int res = dt_dev_pixelpipe_init_cached(pipe, 4 * sizeof(float) * width * height, 2);</a>
<a name="ln97">  pipe-&gt;type = DT_DEV_PIXELPIPE_EXPORT;</a>
<a name="ln98">  pipe-&gt;levels = levels;</a>
<a name="ln99">  pipe-&gt;store_all_raster_masks = store_masks;</a>
<a name="ln100">  return res;</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">int dt_dev_pixelpipe_init_thumbnail(dt_dev_pixelpipe_t *pipe, int32_t width, int32_t height)</a>
<a name="ln104">{</a>
<a name="ln105">  int res = dt_dev_pixelpipe_init_cached(pipe, 4 * sizeof(float) * width * height, 2);</a>
<a name="ln106">  pipe-&gt;type = DT_DEV_PIXELPIPE_THUMBNAIL;</a>
<a name="ln107">  return res;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">int dt_dev_pixelpipe_init_dummy(dt_dev_pixelpipe_t *pipe, int32_t width, int32_t height)</a>
<a name="ln111">{</a>
<a name="ln112">  int res = dt_dev_pixelpipe_init_cached(pipe, 4 * sizeof(float) * width * height, 0);</a>
<a name="ln113">  pipe-&gt;type = DT_DEV_PIXELPIPE_THUMBNAIL;</a>
<a name="ln114">  return res;</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">int dt_dev_pixelpipe_init_preview(dt_dev_pixelpipe_t *pipe)</a>
<a name="ln118">{</a>
<a name="ln119">  // don't know which buffer size we're going to need, set to 0 (will be alloced on demand)</a>
<a name="ln120">  int res = dt_dev_pixelpipe_init_cached(</a>
<a name="ln121">      pipe, 0, 5);</a>
<a name="ln122">  pipe-&gt;type = DT_DEV_PIXELPIPE_PREVIEW;</a>
<a name="ln123">  return res;</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">int dt_dev_pixelpipe_init(dt_dev_pixelpipe_t *pipe)</a>
<a name="ln127">{</a>
<a name="ln128">  // don't know which buffer size we're going to need, set to 0 (will be alloced on demand)</a>
<a name="ln129">  int res = dt_dev_pixelpipe_init_cached(</a>
<a name="ln130">      pipe, 0, 5);</a>
<a name="ln131">  pipe-&gt;type = DT_DEV_PIXELPIPE_FULL;</a>
<a name="ln132">  return res;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">int dt_dev_pixelpipe_init_cached(dt_dev_pixelpipe_t *pipe, size_t size, int32_t entries)</a>
<a name="ln136">{</a>
<a name="ln137">  pipe-&gt;devid = -1;</a>
<a name="ln138">  pipe-&gt;changed = DT_DEV_PIPE_UNCHANGED;</a>
<a name="ln139">  pipe-&gt;processed_width = pipe-&gt;backbuf_width = pipe-&gt;iwidth = 0;</a>
<a name="ln140">  pipe-&gt;processed_height = pipe-&gt;backbuf_height = pipe-&gt;iheight = 0;</a>
<a name="ln141">  pipe-&gt;nodes = NULL;</a>
<a name="ln142">  pipe-&gt;backbuf_size = size;</a>
<a name="ln143">  if(!dt_dev_pixelpipe_cache_init(&amp;(pipe-&gt;cache), entries, pipe-&gt;backbuf_size)) return 0;</a>
<a name="ln144">  pipe-&gt;cache_obsolete = 0;</a>
<a name="ln145">  pipe-&gt;backbuf = NULL;</a>
<a name="ln146">  pipe-&gt;processing = 0;</a>
<a name="ln147">  pipe-&gt;shutdown = 0;</a>
<a name="ln148">  pipe-&gt;opencl_error = 0;</a>
<a name="ln149">  pipe-&gt;tiling = 0;</a>
<a name="ln150">  pipe-&gt;mask_display = DT_DEV_PIXELPIPE_DISPLAY_NONE;</a>
<a name="ln151">  pipe-&gt;input_timestamp = 0;</a>
<a name="ln152">  pipe-&gt;levels = IMAGEIO_RGB | IMAGEIO_INT8;</a>
<a name="ln153">  dt_pthread_mutex_init(&amp;(pipe-&gt;backbuf_mutex), NULL);</a>
<a name="ln154">  dt_pthread_mutex_init(&amp;(pipe-&gt;busy_mutex), NULL);</a>
<a name="ln155">  pipe-&gt;icc_type = DT_COLORSPACE_NONE;</a>
<a name="ln156">  pipe-&gt;icc_filename = NULL;</a>
<a name="ln157">  pipe-&gt;icc_intent = DT_INTENT_LAST;</a>
<a name="ln158">  pipe-&gt;iop = NULL;</a>
<a name="ln159">  pipe-&gt;forms = NULL;</a>
<a name="ln160">  pipe-&gt;store_all_raster_masks = FALSE;</a>
<a name="ln161"> </a>
<a name="ln162">  return 1;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">void dt_dev_pixelpipe_set_input(dt_dev_pixelpipe_t *pipe, dt_develop_t *dev, float *input, int width, int height,</a>
<a name="ln166">                                float iscale)</a>
<a name="ln167">{</a>
<a name="ln168">  pipe-&gt;iwidth = width;</a>
<a name="ln169">  pipe-&gt;iheight = height;</a>
<a name="ln170">  pipe-&gt;iscale = iscale;</a>
<a name="ln171">  pipe-&gt;input = input;</a>
<a name="ln172">  pipe-&gt;image = dev-&gt;image_storage;</a>
<a name="ln173">  get_output_format(NULL, pipe, NULL, dev, &amp;pipe-&gt;dsc);</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">void dt_dev_pixelpipe_set_icc(dt_dev_pixelpipe_t *pipe, dt_colorspaces_color_profile_type_t icc_type,</a>
<a name="ln177">                              const gchar *icc_filename, dt_iop_color_intent_t icc_intent)</a>
<a name="ln178">{</a>
<a name="ln179">  pipe-&gt;icc_type = icc_type;</a>
<a name="ln180">  g_free(pipe-&gt;icc_filename);</a>
<a name="ln181">  pipe-&gt;icc_filename = g_strdup(icc_filename ? icc_filename : &quot;&quot;);</a>
<a name="ln182">  pipe-&gt;icc_intent = icc_intent;</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">void dt_dev_pixelpipe_cleanup(dt_dev_pixelpipe_t *pipe)</a>
<a name="ln186">{</a>
<a name="ln187">  dt_pthread_mutex_lock(&amp;pipe-&gt;backbuf_mutex);</a>
<a name="ln188">  pipe-&gt;backbuf = NULL;</a>
<a name="ln189">  // blocks while busy and sets shutdown bit:</a>
<a name="ln190">  dt_dev_pixelpipe_cleanup_nodes(pipe);</a>
<a name="ln191">  // so now it's safe to clean up cache:</a>
<a name="ln192">  dt_dev_pixelpipe_cache_cleanup(&amp;(pipe-&gt;cache));</a>
<a name="ln193">  dt_pthread_mutex_unlock(&amp;pipe-&gt;backbuf_mutex);</a>
<a name="ln194">  dt_pthread_mutex_destroy(&amp;(pipe-&gt;backbuf_mutex));</a>
<a name="ln195">  dt_pthread_mutex_destroy(&amp;(pipe-&gt;busy_mutex));</a>
<a name="ln196">  pipe-&gt;icc_type = DT_COLORSPACE_NONE;</a>
<a name="ln197">  g_free(pipe-&gt;icc_filename);</a>
<a name="ln198">  pipe-&gt;icc_filename = NULL;</a>
<a name="ln199"> </a>
<a name="ln200">  if (pipe-&gt;forms)</a>
<a name="ln201">  {</a>
<a name="ln202">    g_list_free_full(pipe-&gt;forms, (void (*)(void *))dt_masks_free_form);</a>
<a name="ln203">    pipe-&gt;forms = NULL;</a>
<a name="ln204">  }</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">void dt_dev_pixelpipe_cleanup_nodes(dt_dev_pixelpipe_t *pipe)</a>
<a name="ln208">{</a>
<a name="ln209">  // FIXME: either this or all process() -&gt; gdk mutices have to be changed!</a>
<a name="ln210">  //        (this is a circular dependency on busy_mutex and the gdk mutex)</a>
<a name="ln211">  dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln212">  pipe-&gt;shutdown = 1;</a>
<a name="ln213">  // destroy all nodes</a>
<a name="ln214">  GList *nodes = pipe-&gt;nodes;</a>
<a name="ln215">  while(nodes)</a>
<a name="ln216">  {</a>
<a name="ln217">    dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)nodes-&gt;data;</a>
<a name="ln218">    // printf(&quot;cleanup module `%s'\n&quot;, piece-&gt;module-&gt;name());</a>
<a name="ln219">    piece-&gt;module-&gt;cleanup_pipe(piece-&gt;module, pipe, piece);</a>
<a name="ln220">    free(piece-&gt;blendop_data);</a>
<a name="ln221">    piece-&gt;blendop_data = NULL;</a>
<a name="ln222">    free(piece-&gt;histogram);</a>
<a name="ln223">    piece-&gt;histogram = NULL;</a>
<a name="ln224">    g_hash_table_destroy(piece-&gt;raster_masks);</a>
<a name="ln225">    piece-&gt;raster_masks = NULL;</a>
<a name="ln226">    free(piece);</a>
<a name="ln227">    nodes = g_list_next(nodes);</a>
<a name="ln228">  }</a>
<a name="ln229">  g_list_free(pipe-&gt;nodes);</a>
<a name="ln230">  pipe-&gt;nodes = NULL;</a>
<a name="ln231">  // also cleanup iop here</a>
<a name="ln232">  if(pipe-&gt;iop)</a>
<a name="ln233">  {</a>
<a name="ln234">    g_list_free(pipe-&gt;iop);</a>
<a name="ln235">    pipe-&gt;iop = NULL;</a>
<a name="ln236">  }</a>
<a name="ln237">  dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">void dt_dev_pixelpipe_create_nodes(dt_dev_pixelpipe_t *pipe, dt_develop_t *dev)</a>
<a name="ln241">{</a>
<a name="ln242">  dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln243">  pipe-&gt;shutdown = 0;</a>
<a name="ln244">  g_assert(pipe-&gt;nodes == NULL);</a>
<a name="ln245">  g_assert(pipe-&gt;iop == NULL);</a>
<a name="ln246">  // for all modules in dev:</a>
<a name="ln247">  pipe-&gt;iop = g_list_copy(dev-&gt;iop);</a>
<a name="ln248">  GList *modules = pipe-&gt;iop;</a>
<a name="ln249">  while(modules)</a>
<a name="ln250">  {</a>
<a name="ln251">    dt_iop_module_t *module = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln252">    dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)calloc(1, sizeof(dt_dev_pixelpipe_iop_t));</a>
<a name="ln253">    piece-&gt;enabled = module-&gt;enabled;</a>
<a name="ln254">    piece-&gt;request_histogram = DT_REQUEST_ONLY_IN_GUI;</a>
<a name="ln255">    piece-&gt;histogram_params.roi = NULL;</a>
<a name="ln256">    piece-&gt;histogram_params.bins_count = 256;</a>
<a name="ln257">    piece-&gt;histogram_stats.bins_count = 0;</a>
<a name="ln258">    piece-&gt;histogram_stats.pixels = 0;</a>
<a name="ln259">    piece-&gt;colors</a>
<a name="ln260">        = ((dt_iop_module_colorspace(module) == iop_cs_RAW) &amp;&amp; (pipe-&gt;image.flags &amp; DT_IMAGE_RAW)) ? 1 : 4;</a>
<a name="ln261">    piece-&gt;iscale = pipe-&gt;iscale;</a>
<a name="ln262">    piece-&gt;iwidth = pipe-&gt;iwidth;</a>
<a name="ln263">    piece-&gt;iheight = pipe-&gt;iheight;</a>
<a name="ln264">    piece-&gt;module = module;</a>
<a name="ln265">    piece-&gt;pipe = pipe;</a>
<a name="ln266">    piece-&gt;data = NULL;</a>
<a name="ln267">    piece-&gt;hash = 0;</a>
<a name="ln268">    piece-&gt;process_cl_ready = 0;</a>
<a name="ln269">    piece-&gt;process_tiling_ready = 0;</a>
<a name="ln270">    piece-&gt;raster_masks = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, dt_free_align_ptr);</a>
<a name="ln271">    memset(&amp;piece-&gt;processed_roi_in, 0, sizeof(piece-&gt;processed_roi_in));</a>
<a name="ln272">    memset(&amp;piece-&gt;processed_roi_out, 0, sizeof(piece-&gt;processed_roi_out));</a>
<a name="ln273">    dt_iop_init_pipe(piece-&gt;module, pipe, piece);</a>
<a name="ln274">    pipe-&gt;nodes = g_list_append(pipe-&gt;nodes, piece);</a>
<a name="ln275">    modules = g_list_next(modules);</a>
<a name="ln276">  }</a>
<a name="ln277">  dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">// helper</a>
<a name="ln281">void dt_dev_pixelpipe_synch(dt_dev_pixelpipe_t *pipe, dt_develop_t *dev, GList *history)</a>
<a name="ln282">{</a>
<a name="ln283">  dt_dev_history_item_t *hist = (dt_dev_history_item_t *)history-&gt;data;</a>
<a name="ln284">  // find piece in nodes list</a>
<a name="ln285">  GList *nodes = pipe-&gt;nodes;</a>
<a name="ln286">  dt_dev_pixelpipe_iop_t *piece = NULL;</a>
<a name="ln287">  while(nodes)</a>
<a name="ln288">  {</a>
<a name="ln289">    piece = (dt_dev_pixelpipe_iop_t *)nodes-&gt;data;</a>
<a name="ln290">    if(piece-&gt;module == hist-&gt;module)</a>
<a name="ln291">    {</a>
<a name="ln292">      piece-&gt;enabled = hist-&gt;enabled;</a>
<a name="ln293">      dt_iop_commit_params(hist-&gt;module, hist-&gt;params, hist-&gt;blend_params, pipe, piece);</a>
<a name="ln294">    }</a>
<a name="ln295">    nodes = g_list_next(nodes);</a>
<a name="ln296">  }</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">void dt_dev_pixelpipe_synch_all(dt_dev_pixelpipe_t *pipe, dt_develop_t *dev)</a>
<a name="ln300">{</a>
<a name="ln301">  dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln302">  // call reset_params on all pieces first.</a>
<a name="ln303">  GList *nodes = pipe-&gt;nodes;</a>
<a name="ln304">  while(nodes)</a>
<a name="ln305">  {</a>
<a name="ln306">    dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)nodes-&gt;data;</a>
<a name="ln307">    piece-&gt;hash = 0;</a>
<a name="ln308">    piece-&gt;enabled = piece-&gt;module-&gt;default_enabled;</a>
<a name="ln309">    dt_iop_commit_params(piece-&gt;module, piece-&gt;module-&gt;default_params, piece-&gt;module-&gt;default_blendop_params,</a>
<a name="ln310">                         pipe, piece);</a>
<a name="ln311">    nodes = g_list_next(nodes);</a>
<a name="ln312">  }</a>
<a name="ln313">  // go through all history items and adjust params</a>
<a name="ln314">  GList *history = dev-&gt;history;</a>
<a name="ln315">  for(int k = 0; k &lt; dev-&gt;history_end &amp;&amp; history; k++)</a>
<a name="ln316">  {</a>
<a name="ln317">    dt_dev_pixelpipe_synch(pipe, dev, history);</a>
<a name="ln318">    history = g_list_next(history);</a>
<a name="ln319">  }</a>
<a name="ln320">  dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">void dt_dev_pixelpipe_synch_top(dt_dev_pixelpipe_t *pipe, dt_develop_t *dev)</a>
<a name="ln324">{</a>
<a name="ln325">  dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln326">  GList *history = g_list_nth(dev-&gt;history, dev-&gt;history_end - 1);</a>
<a name="ln327">  if(history) dt_dev_pixelpipe_synch(pipe, dev, history);</a>
<a name="ln328">  dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">void dt_dev_pixelpipe_change(dt_dev_pixelpipe_t *pipe, struct dt_develop_t *dev)</a>
<a name="ln332">{</a>
<a name="ln333">  dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln334">  // case DT_DEV_PIPE_UNCHANGED: case DT_DEV_PIPE_ZOOMED:</a>
<a name="ln335">  if(pipe-&gt;changed &amp; DT_DEV_PIPE_TOP_CHANGED)</a>
<a name="ln336">  {</a>
<a name="ln337">    // only top history item changed.</a>
<a name="ln338">    dt_dev_pixelpipe_synch_top(pipe, dev);</a>
<a name="ln339">  }</a>
<a name="ln340">  if(pipe-&gt;changed &amp; DT_DEV_PIPE_SYNCH)</a>
<a name="ln341">  {</a>
<a name="ln342">    // pipeline topology remains intact, only change all params.</a>
<a name="ln343">    dt_dev_pixelpipe_synch_all(pipe, dev);</a>
<a name="ln344">  }</a>
<a name="ln345">  if(pipe-&gt;changed &amp; DT_DEV_PIPE_REMOVE)</a>
<a name="ln346">  {</a>
<a name="ln347">    // modules have been added in between or removed. need to rebuild the whole pipeline.</a>
<a name="ln348">    dt_dev_pixelpipe_cleanup_nodes(pipe);</a>
<a name="ln349">    dt_dev_pixelpipe_create_nodes(pipe, dev);</a>
<a name="ln350">    dt_dev_pixelpipe_synch_all(pipe, dev);</a>
<a name="ln351">  }</a>
<a name="ln352">  pipe-&gt;changed = DT_DEV_PIPE_UNCHANGED;</a>
<a name="ln353">  dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln354">  dt_dev_pixelpipe_get_dimensions(pipe, dev, pipe-&gt;iwidth, pipe-&gt;iheight, &amp;pipe-&gt;processed_width,</a>
<a name="ln355">                                  &amp;pipe-&gt;processed_height);</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">// TODO:</a>
<a name="ln359">void dt_dev_pixelpipe_add_node(dt_dev_pixelpipe_t *pipe, dt_develop_t *dev, int n)</a>
<a name="ln360">{</a>
<a name="ln361">}</a>
<a name="ln362">// TODO:</a>
<a name="ln363">void dt_dev_pixelpipe_remove_node(dt_dev_pixelpipe_t *pipe, dt_develop_t *dev, int n)</a>
<a name="ln364">{</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">static void get_output_format(dt_iop_module_t *module, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln368">                              dt_develop_t *dev, dt_iop_buffer_dsc_t *dsc)</a>
<a name="ln369">{</a>
<a name="ln370">  if(module) return module-&gt;output_format(module, pipe, piece, dsc);</a>
<a name="ln371"> </a>
<a name="ln372">  // first input.</a>
<a name="ln373">  *dsc = pipe-&gt;image.buf_dsc;</a>
<a name="ln374"> </a>
<a name="ln375">  if(!(pipe-&gt;image.flags &amp; DT_IMAGE_RAW))</a>
<a name="ln376">  {</a>
<a name="ln377">    // image max is normalized before</a>
<a name="ln378">    for(int k = 0; k &lt; 4; k++) dsc-&gt;processed_maximum[k] = 1.0f;</a>
<a name="ln379">  }</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382"> </a>
<a name="ln383">// helper to get per module histogram</a>
<a name="ln384">static void histogram_collect(dt_dev_pixelpipe_iop_t *piece, const void *pixel, const dt_iop_roi_t *roi,</a>
<a name="ln385">                              uint32_t **histogram, uint32_t *histogram_max)</a>
<a name="ln386">{</a>
<a name="ln387">  dt_dev_histogram_collection_params_t histogram_params = piece-&gt;histogram_params;</a>
<a name="ln388"> </a>
<a name="ln389">  dt_histogram_roi_t histogram_roi;</a>
<a name="ln390"> </a>
<a name="ln391">  // if the current module does did not specified its own ROI, use the full ROI</a>
<a name="ln392">  if(histogram_params.roi == NULL)</a>
<a name="ln393">  {</a>
<a name="ln394">    histogram_roi = (dt_histogram_roi_t){</a>
<a name="ln395">      .width = roi-&gt;width, .height = roi-&gt;height, .crop_x = 0, .crop_y = 0, .crop_width = 0, .crop_height = 0</a>
<a name="ln396">    };</a>
<a name="ln397"> </a>
<a name="ln398">    histogram_params.roi = &amp;histogram_roi;</a>
<a name="ln399">  }</a>
<a name="ln400"> </a>
<a name="ln401">  const dt_iop_colorspace_type_t cst = dt_iop_module_colorspace(piece-&gt;module);</a>
<a name="ln402"> </a>
<a name="ln403">  dt_histogram_helper(&amp;histogram_params, &amp;piece-&gt;histogram_stats, cst, pixel, histogram);</a>
<a name="ln404">  dt_histogram_max_helper(&amp;piece-&gt;histogram_stats, cst, histogram, histogram_max);</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">#ifdef HAVE_OPENCL</a>
<a name="ln408">// helper to get per module histogram for OpenCL</a>
<a name="ln409">//</a>
<a name="ln410">// this algorithm is inefficient as hell when it comes to larger images. it's only acceptable</a>
<a name="ln411">// as long as we work on small image sizes like in image preview</a>
<a name="ln412">static void histogram_collect_cl(int devid, dt_dev_pixelpipe_iop_t *piece, cl_mem img,</a>
<a name="ln413">                                 const dt_iop_roi_t *roi, uint32_t **histogram, uint32_t *histogram_max,</a>
<a name="ln414">                                 float *buffer, size_t bufsize)</a>
<a name="ln415">{</a>
<a name="ln416">  float *tmpbuf = NULL;</a>
<a name="ln417">  float *pixel;</a>
<a name="ln418"> </a>
<a name="ln419">  // if buffer is supplied and if size fits let's use it</a>
<a name="ln420">  if(buffer &amp;&amp; bufsize &gt;= (size_t)roi-&gt;width * roi-&gt;height * 4 * sizeof(float))</a>
<a name="ln421">    pixel = buffer;</a>
<a name="ln422">  else</a>
<a name="ln423">    pixel = tmpbuf = dt_alloc_align(64, (size_t)roi-&gt;width * roi-&gt;height * 4 * sizeof(float));</a>
<a name="ln424"> </a>
<a name="ln425">  if(!pixel) return;</a>
<a name="ln426"> </a>
<a name="ln427">  cl_int err = dt_opencl_copy_device_to_host(devid, pixel, img, roi-&gt;width, roi-&gt;height, 4 * sizeof(float));</a>
<a name="ln428">  if(err != CL_SUCCESS)</a>
<a name="ln429">  {</a>
<a name="ln430">    if(tmpbuf) dt_free_align(tmpbuf);</a>
<a name="ln431">    return;</a>
<a name="ln432">  }</a>
<a name="ln433"> </a>
<a name="ln434">  dt_dev_histogram_collection_params_t histogram_params = piece-&gt;histogram_params;</a>
<a name="ln435"> </a>
<a name="ln436">  dt_histogram_roi_t histogram_roi;</a>
<a name="ln437"> </a>
<a name="ln438">  // if the current module does did not specified its own ROI, use the full ROI</a>
<a name="ln439">  if(histogram_params.roi == NULL)</a>
<a name="ln440">  {</a>
<a name="ln441">    histogram_roi = (dt_histogram_roi_t){</a>
<a name="ln442">      .width = roi-&gt;width, .height = roi-&gt;height, .crop_x = 0, .crop_y = 0, .crop_width = 0, .crop_height = 0</a>
<a name="ln443">    };</a>
<a name="ln444"> </a>
<a name="ln445">    histogram_params.roi = &amp;histogram_roi;</a>
<a name="ln446">  }</a>
<a name="ln447"> </a>
<a name="ln448">  const dt_iop_colorspace_type_t cst = dt_iop_module_colorspace(piece-&gt;module);</a>
<a name="ln449"> </a>
<a name="ln450">  dt_histogram_helper(&amp;histogram_params, &amp;piece-&gt;histogram_stats, cst, pixel, histogram);</a>
<a name="ln451">  dt_histogram_max_helper(&amp;piece-&gt;histogram_stats, cst, histogram, histogram_max);</a>
<a name="ln452"> </a>
<a name="ln453">  if(tmpbuf) dt_free_align(tmpbuf);</a>
<a name="ln454">}</a>
<a name="ln455">#endif</a>
<a name="ln456"> </a>
<a name="ln457">// helper for color picking</a>
<a name="ln458">static int pixelpipe_picker_helper(dt_iop_module_t *module, const dt_iop_roi_t *roi, float *picked_color,</a>
<a name="ln459">                                   float *picked_color_min, float *picked_color_max,</a>
<a name="ln460">                                   dt_pixelpipe_picker_source_t picker_source, int *box)</a>
<a name="ln461">{</a>
<a name="ln462">  const float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln463">  const float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln464">  const int width = roi-&gt;width;</a>
<a name="ln465">  const int height = roi-&gt;height;</a>
<a name="ln466"> </a>
<a name="ln467">  // initialize picker values. a positive value of picked_color_max[0] can later be used to check for validity</a>
<a name="ln468">  // of data</a>
<a name="ln469">  for(int k = 0; k &lt; 4; k++) picked_color_min[k] = INFINITY;</a>
<a name="ln470">  for(int k = 0; k &lt; 4; k++) picked_color_max[k] = -INFINITY;</a>
<a name="ln471">  for(int k = 0; k &lt; 4; k++) picked_color[k] = 0.0f;</a>
<a name="ln472"> </a>
<a name="ln473">  // do not continue if one of the point coordinates is set to a negative value indicating a not yet defined</a>
<a name="ln474">  // position</a>
<a name="ln475">  if(module-&gt;color_picker_point[0] &lt; 0 || module-&gt;color_picker_point[1] &lt; 0) return 1;</a>
<a name="ln476"> </a>
<a name="ln477">  float fbox[4];</a>
<a name="ln478"> </a>
<a name="ln479">  // get absolute pixel coordinates in final preview image</a>
<a name="ln480">  if(darktable.lib-&gt;proxy.colorpicker.size)</a>
<a name="ln481">  {</a>
<a name="ln482">    for(int k = 0; k &lt; 4; k += 2) fbox[k] = module-&gt;color_picker_box[k] * wd;</a>
<a name="ln483">    for(int k = 1; k &lt; 4; k += 2) fbox[k] = module-&gt;color_picker_box[k] * ht;</a>
<a name="ln484">  }</a>
<a name="ln485">  else</a>
<a name="ln486">  {</a>
<a name="ln487">    fbox[0] = fbox[2] = module-&gt;color_picker_point[0] * wd;</a>
<a name="ln488">    fbox[1] = fbox[3] = module-&gt;color_picker_point[1] * ht;</a>
<a name="ln489">  }</a>
<a name="ln490"> </a>
<a name="ln491">  // transform back to current module coordinates</a>
<a name="ln492">  dt_dev_distort_backtransform_plus(darktable.develop, darktable.develop-&gt;preview_pipe,</a>
<a name="ln493">                                    module-&gt;priority + (picker_source == PIXELPIPE_PICKER_INPUT ? 0 : 1), 99999,</a>
<a name="ln494">                                    fbox, 2);</a>
<a name="ln495"> </a>
<a name="ln496">  fbox[0] -= roi-&gt;x;</a>
<a name="ln497">  fbox[1] -= roi-&gt;y;</a>
<a name="ln498">  fbox[2] -= roi-&gt;x;</a>
<a name="ln499">  fbox[3] -= roi-&gt;y;</a>
<a name="ln500"> </a>
<a name="ln501">  // re-order edges of bounding box</a>
<a name="ln502">  box[0] = fminf(fbox[0], fbox[2]);</a>
<a name="ln503">  box[1] = fminf(fbox[1], fbox[3]);</a>
<a name="ln504">  box[2] = fmaxf(fbox[0], fbox[2]);</a>
<a name="ln505">  box[3] = fmaxf(fbox[1], fbox[3]);</a>
<a name="ln506"> </a>
<a name="ln507">  if(!darktable.lib-&gt;proxy.colorpicker.size)</a>
<a name="ln508">  {</a>
<a name="ln509">    // if we are sampling one point, make sure that we actually sample it.</a>
<a name="ln510">    for(int k = 2; k &lt; 4; k++) box[k] += 1;</a>
<a name="ln511">  }</a>
<a name="ln512"> </a>
<a name="ln513">  // do not continue if box is completely outside of roi</a>
<a name="ln514">  if(box[0] &gt;= width || box[1] &gt;= height || box[2] &lt; 0 || box[3] &lt; 0) return 1;</a>
<a name="ln515"> </a>
<a name="ln516">  // clamp bounding box to roi</a>
<a name="ln517">  for(int k = 0; k &lt; 4; k += 2) box[k] = MIN(width - 1, MAX(0, box[k]));</a>
<a name="ln518">  for(int k = 1; k &lt; 4; k += 2) box[k] = MIN(height - 1, MAX(0, box[k]));</a>
<a name="ln519"> </a>
<a name="ln520">  // safety check: area needs to have minimum 1 pixel width and height</a>
<a name="ln521">  if(box[2] - box[0] &lt; 1 || box[3] - box[1] &lt; 1) return 1;</a>
<a name="ln522"> </a>
<a name="ln523">  return 0;</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526">static void pixelpipe_picker(dt_iop_module_t *module, dt_iop_buffer_dsc_t *dsc, const float *pixel,</a>
<a name="ln527">                             const dt_iop_roi_t *roi, float *picked_color, float *picked_color_min,</a>
<a name="ln528">                             float *picked_color_max, dt_pixelpipe_picker_source_t picker_source)</a>
<a name="ln529">{</a>
<a name="ln530">  int box[4];</a>
<a name="ln531"> </a>
<a name="ln532">  if(pixelpipe_picker_helper(module, roi, picked_color, picked_color_min, picked_color_max, picker_source, box))</a>
<a name="ln533">    return;</a>
<a name="ln534"> </a>
<a name="ln535">  dt_color_picker_helper(dsc, pixel, roi, box, picked_color, picked_color_min, picked_color_max);</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">#ifdef HAVE_OPENCL</a>
<a name="ln540">// helper for OpenCL color picking</a>
<a name="ln541">//</a>
<a name="ln542">// this algorithm is inefficient as hell when it comes to larger images. it's only acceptable</a>
<a name="ln543">// as long as we work on small image sizes like in image preview</a>
<a name="ln544">static void pixelpipe_picker_cl(int devid, dt_iop_module_t *module, dt_iop_buffer_dsc_t *dsc, cl_mem img,</a>
<a name="ln545">                                const dt_iop_roi_t *roi, float *picked_color, float *picked_color_min,</a>
<a name="ln546">                                float *picked_color_max, float *buffer, size_t bufsize,</a>
<a name="ln547">                                dt_pixelpipe_picker_source_t picker_source)</a>
<a name="ln548">{</a>
<a name="ln549">  int box[4];</a>
<a name="ln550"> </a>
<a name="ln551">  if(pixelpipe_picker_helper(module, roi, picked_color, picked_color_min, picked_color_max, picker_source, box))</a>
<a name="ln552">    return;</a>
<a name="ln553"> </a>
<a name="ln554">  size_t origin[3];</a>
<a name="ln555">  size_t region[3];</a>
<a name="ln556"> </a>
<a name="ln557">  // Initializing bounds of colorpicker box</a>
<a name="ln558">  origin[0] = box[0];</a>
<a name="ln559">  origin[1] = box[1];</a>
<a name="ln560">  origin[2] = 0;</a>
<a name="ln561"> </a>
<a name="ln562">  region[0] = box[2] - box[0];</a>
<a name="ln563">  region[1] = box[3] - box[1];</a>
<a name="ln564">  region[2] = 1;</a>
<a name="ln565"> </a>
<a name="ln566">  float *pixel;</a>
<a name="ln567">  float *tmpbuf = NULL;</a>
<a name="ln568"> </a>
<a name="ln569">  const size_t size = region[0] * region[1];</a>
<a name="ln570"> </a>
<a name="ln571">  const size_t bpp = dt_iop_buffer_dsc_to_bpp(dsc);</a>
<a name="ln572"> </a>
<a name="ln573">  // if a buffer is supplied and if size fits let's use it</a>
<a name="ln574">  if(buffer &amp;&amp; bufsize &gt;= size * bpp)</a>
<a name="ln575">    pixel = buffer;</a>
<a name="ln576">  else</a>
<a name="ln577">    pixel = tmpbuf = dt_alloc_align(64, size * bpp);</a>
<a name="ln578"> </a>
<a name="ln579">  if(pixel == NULL) return;</a>
<a name="ln580"> </a>
<a name="ln581">  // get the required part of the image from opencl device</a>
<a name="ln582">  cl_int err = dt_opencl_read_host_from_device_raw(devid, pixel, img, origin, region, region[0] * bpp, CL_TRUE);</a>
<a name="ln583"> </a>
<a name="ln584">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln585"> </a>
<a name="ln586">  dt_iop_roi_t roi_copy = (dt_iop_roi_t){.x = roi-&gt;x + box[0], .y = roi-&gt;y + box[1], .width = region[0], .height = region[1] };</a>
<a name="ln587"> </a>
<a name="ln588">  box[0] = 0;</a>
<a name="ln589">  box[1] = 0;</a>
<a name="ln590">  box[2] = region[0];</a>
<a name="ln591">  box[3] = region[1];</a>
<a name="ln592"> </a>
<a name="ln593">  dt_color_picker_helper(dsc, pixel, &amp;roi_copy, box, picked_color, picked_color_min, picked_color_max);</a>
<a name="ln594"> </a>
<a name="ln595">error:</a>
<a name="ln596">  dt_free_align(tmpbuf);</a>
<a name="ln597">}</a>
<a name="ln598">#endif</a>
<a name="ln599"> </a>
<a name="ln600">static void _pixelpipe_pick_from_image(const float *const pixel, const dt_iop_roi_t *roi_in, </a>
<a name="ln601">    cmsHTRANSFORM xform_rgb2lab, cmsHTRANSFORM xform_rgb2rgb,</a>
<a name="ln602">    const float *const  pick_box, const float *const  pick_point, const int pick_size,</a>
<a name="ln603">    float *pick_color_rgb_min, float *pick_color_rgb_max, float *pick_color_rgb_mean,</a>
<a name="ln604">    float *pick_color_lab_min, float *pick_color_lab_max, float *pick_color_lab_mean)</a>
<a name="ln605">{</a>
<a name="ln606">  float picked_color_rgb_min[3];</a>
<a name="ln607">  float picked_color_rgb_max[3];</a>
<a name="ln608">  float picked_color_rgb_mean[3];</a>
<a name="ln609"> </a>
<a name="ln610">  for(int k = 0; k &lt; 3; k++) picked_color_rgb_min[k] = FLT_MAX;</a>
<a name="ln611">  for(int k = 0; k &lt; 3; k++) picked_color_rgb_max[k] = FLT_MIN;</a>
<a name="ln612"> </a>
<a name="ln613">  int box[4];</a>
<a name="ln614">  int point[2];</a>
<a name="ln615"> </a>
<a name="ln616">  for(int k = 0; k &lt; 4; k += 2)</a>
<a name="ln617">    box[k] = MIN(roi_in-&gt;width - 1, MAX(0, pick_box[k] * roi_in-&gt;width));</a>
<a name="ln618">  for(int k = 1; k &lt; 4; k += 2)</a>
<a name="ln619">    box[k] = MIN(roi_in-&gt;height - 1, MAX(0, pick_box[k] * roi_in-&gt;height));</a>
<a name="ln620">  point[0] = MIN(roi_in-&gt;width - 1, MAX(0, pick_point[0] * roi_in-&gt;width));</a>
<a name="ln621">  point[1] = MIN(roi_in-&gt;height - 1, MAX(0, pick_point[1] * roi_in-&gt;height));</a>
<a name="ln622"> </a>
<a name="ln623">  float rgb[3];</a>
<a name="ln624">  for(int k = 0; k &lt; 3; k++) rgb[k] = 0.0f;</a>
<a name="ln625"> </a>
<a name="ln626">  const float w = 1.0 / ((box[3] - box[1] + 1) * (box[2] - box[0] + 1));</a>
<a name="ln627"> </a>
<a name="ln628">  if(pick_size == DT_COLORPICKER_SIZE_BOX)</a>
<a name="ln629">  {</a>
<a name="ln630">    for(int j = box[1]; j &lt;= box[3]; j++)</a>
<a name="ln631">      for(int i = box[0]; i &lt;= box[2]; i++)</a>
<a name="ln632">      {</a>
<a name="ln633">        for(int k = 0; k &lt; 3; k++)</a>
<a name="ln634">        {</a>
<a name="ln635">          picked_color_rgb_min[k]</a>
<a name="ln636">              = MIN(picked_color_rgb_min[k], pixel[4 * (roi_in-&gt;width * j + i) + k]);</a>
<a name="ln637">          picked_color_rgb_max[k]</a>
<a name="ln638">              = MAX(picked_color_rgb_max[k], pixel[4 * (roi_in-&gt;width * j + i) + k]);</a>
<a name="ln639">          rgb[k] += w * pixel[4 * (roi_in-&gt;width * j + i) + k];</a>
<a name="ln640">        }</a>
<a name="ln641">      }</a>
<a name="ln642">    for(int k = 0; k &lt; 3; k++) picked_color_rgb_mean[k] = rgb[k];</a>
<a name="ln643">  }</a>
<a name="ln644">  else</a>
<a name="ln645">  {</a>
<a name="ln646">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln647">      picked_color_rgb_mean[i] = picked_color_rgb_min[i]</a>
<a name="ln648">          = picked_color_rgb_max[i] = pixel[4 * (roi_in-&gt;width * point[1] + point[0]) + i];</a>
<a name="ln649">  }</a>
<a name="ln650"> </a>
<a name="ln651">  // Converting the display RGB values to histogram RGB</a>
<a name="ln652">  if(xform_rgb2rgb)</a>
<a name="ln653">  {</a>
<a name="ln654">    // Preparing the data for transformation</a>
<a name="ln655">    float rgb_ddata[9];</a>
<a name="ln656">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln657">    {</a>
<a name="ln658">      rgb_ddata[i] = picked_color_rgb_mean[i];</a>
<a name="ln659">      rgb_ddata[i + 3] = picked_color_rgb_min[i];</a>
<a name="ln660">      rgb_ddata[i + 6] = picked_color_rgb_max[i];</a>
<a name="ln661">    }</a>
<a name="ln662"> </a>
<a name="ln663">    float rgb_odata[9];</a>
<a name="ln664">    cmsDoTransform(xform_rgb2rgb, rgb_ddata, rgb_odata, 3);</a>
<a name="ln665"> </a>
<a name="ln666">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln667">    {</a>
<a name="ln668">      pick_color_rgb_mean[i] = rgb_odata[i];</a>
<a name="ln669">      pick_color_rgb_min[i] = rgb_odata[i + 3];</a>
<a name="ln670">      pick_color_rgb_max[i] = rgb_odata[i + 6];</a>
<a name="ln671">    }</a>
<a name="ln672">  }</a>
<a name="ln673">  else</a>
<a name="ln674">  {</a>
<a name="ln675">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln676">    {</a>
<a name="ln677">      pick_color_rgb_mean[i] = picked_color_rgb_mean[i];</a>
<a name="ln678">      pick_color_rgb_min[i] = picked_color_rgb_min[i];</a>
<a name="ln679">      pick_color_rgb_max[i] = picked_color_rgb_max[i];</a>
<a name="ln680">    }</a>
<a name="ln681">  }</a>
<a name="ln682"> </a>
<a name="ln683">  // Converting the RGB values to Lab</a>
<a name="ln684">  if(xform_rgb2lab)</a>
<a name="ln685">  {</a>
<a name="ln686">    // Preparing the data for transformation</a>
<a name="ln687">    float rgb_data[9];</a>
<a name="ln688">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln689">    {</a>
<a name="ln690">      rgb_data[i] = picked_color_rgb_mean[i];</a>
<a name="ln691">      rgb_data[i + 3] = picked_color_rgb_min[i];</a>
<a name="ln692">      rgb_data[i + 6] = picked_color_rgb_max[i];</a>
<a name="ln693">    }</a>
<a name="ln694"> </a>
<a name="ln695">    float Lab_data[9];</a>
<a name="ln696">    cmsDoTransform(xform_rgb2lab, rgb_data, Lab_data, 3);</a>
<a name="ln697"> </a>
<a name="ln698">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln699">    {</a>
<a name="ln700">      pick_color_lab_mean[i] = Lab_data[i];</a>
<a name="ln701">      pick_color_lab_min[i] = Lab_data[i + 3];</a>
<a name="ln702">      pick_color_lab_max[i] = Lab_data[i + 6];</a>
<a name="ln703">    }</a>
<a name="ln704">  }</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707">static void _pixelpipe_get_histogram_profile_type(dt_colorspaces_color_profile_type_t *out_type, gchar **out_filename)</a>
<a name="ln708">{</a>
<a name="ln709">  dt_colorspaces_color_mode_t mode = darktable.color_profiles-&gt;mode;</a>
<a name="ln710">  </a>
<a name="ln711">  // if in gamut check use soft proof</a>
<a name="ln712">  if(mode != DT_PROFILE_NORMAL || darktable.color_profiles-&gt;histogram_type == DT_COLORSPACE_SOFTPROOF)</a>
<a name="ln713">  {</a>
<a name="ln714">    *out_type = darktable.color_profiles-&gt;softproof_type;</a>
<a name="ln715">    *out_filename = darktable.color_profiles-&gt;softproof_filename;</a>
<a name="ln716">  }</a>
<a name="ln717">  else if(darktable.color_profiles-&gt;histogram_type == DT_COLORSPACE_EXPORT)</a>
<a name="ln718">  {</a>
<a name="ln719">    // use introspection to get the params values</a>
<a name="ln720">    dt_iop_module_so_t *colorout_so = NULL;</a>
<a name="ln721">    dt_iop_module_t *colorout = NULL;</a>
<a name="ln722">    GList *modules = g_list_last(darktable.iop);</a>
<a name="ln723">    while(modules)</a>
<a name="ln724">    {</a>
<a name="ln725">      dt_iop_module_so_t *module_so = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln726">      if(!strcmp(module_so-&gt;op, &quot;colorout&quot;))</a>
<a name="ln727">      {</a>
<a name="ln728">        colorout_so = module_so;</a>
<a name="ln729">        break;</a>
<a name="ln730">      }</a>
<a name="ln731">      modules = g_list_previous(modules);</a>
<a name="ln732">    }</a>
<a name="ln733">    if(colorout_so &amp;&amp; colorout_so-&gt;get_p)</a>
<a name="ln734">    {</a>
<a name="ln735">      modules = g_list_last(darktable.develop-&gt;iop);</a>
<a name="ln736">      while(modules)</a>
<a name="ln737">      {</a>
<a name="ln738">        dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln739">        if(!strcmp(module-&gt;op, &quot;colorout&quot;))</a>
<a name="ln740">        {</a>
<a name="ln741">          colorout = module;</a>
<a name="ln742">          break;</a>
<a name="ln743">        }</a>
<a name="ln744">        modules = g_list_previous(modules);</a>
<a name="ln745">      }</a>
<a name="ln746">    }</a>
<a name="ln747">    if(colorout)</a>
<a name="ln748">    {</a>
<a name="ln749">      dt_colorspaces_color_profile_type_t *_type = colorout_so-&gt;get_p(colorout-&gt;params, &quot;type&quot;);</a>
<a name="ln750">      char *_filename = colorout_so-&gt;get_p(colorout-&gt;params, &quot;filename&quot;);</a>
<a name="ln751">      if(_type) *out_type = *_type;</a>
<a name="ln752">      if(_filename) *out_filename = _filename;</a>
<a name="ln753">    }</a>
<a name="ln754">  }</a>
<a name="ln755">  else</a>
<a name="ln756">  {</a>
<a name="ln757">    *out_type = darktable.color_profiles-&gt;histogram_type;</a>
<a name="ln758">    *out_filename = darktable.color_profiles-&gt;histogram_filename;</a>
<a name="ln759">  }</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">static void _pixelpipe_pick_live_samples(const float *const input, const dt_iop_roi_t *roi_in)</a>
<a name="ln763">{</a>
<a name="ln764">  cmsHPROFILE display_profile = NULL;</a>
<a name="ln765">  cmsHPROFILE histogram_profile = NULL;</a>
<a name="ln766">  cmsHPROFILE lab_profile = NULL;</a>
<a name="ln767">  cmsHTRANSFORM xform_rgb2lab = NULL;</a>
<a name="ln768">  cmsHTRANSFORM xform_rgb2rgb = NULL;</a>
<a name="ln769">  dt_colorspaces_color_profile_type_t histogram_type = DT_COLORSPACE_SRGB;</a>
<a name="ln770">  gchar *histogram_filename = NULL;</a>
<a name="ln771">  gchar _histogram_filename[1] = { 0 };</a>
<a name="ln772"> </a>
<a name="ln773">  _pixelpipe_get_histogram_profile_type(&amp;histogram_type, &amp;histogram_filename);</a>
<a name="ln774">  if(histogram_filename == NULL) histogram_filename = _histogram_filename;</a>
<a name="ln775">  </a>
<a name="ln776">  if(darktable.color_profiles-&gt;display_type == DT_COLORSPACE_DISPLAY || histogram_type == DT_COLORSPACE_DISPLAY)</a>
<a name="ln777">    pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln778"> </a>
<a name="ln779">  const dt_colorspaces_color_profile_t *d_profile = dt_colorspaces_get_profile(darktable.color_profiles-&gt;display_type,</a>
<a name="ln780">                                                       darktable.color_profiles-&gt;display_filename,</a>
<a name="ln781">                                                       DT_PROFILE_DIRECTION_OUT | DT_PROFILE_DIRECTION_DISPLAY);</a>
<a name="ln782">  if(d_profile) display_profile = d_profile-&gt;profile;</a>
<a name="ln783"> </a>
<a name="ln784">  if((histogram_type != darktable.color_profiles-&gt;display_type) || </a>
<a name="ln785">      (histogram_type == DT_COLORSPACE_FILE &amp;&amp;</a>
<a name="ln786">      strcmp(histogram_filename, darktable.color_profiles-&gt;display_filename)))</a>
<a name="ln787">  {</a>
<a name="ln788">    const dt_colorspaces_color_profile_t *d_histogram = dt_colorspaces_get_profile(histogram_type,</a>
<a name="ln789">                                                         histogram_filename,</a>
<a name="ln790">                                                         DT_PROFILE_DIRECTION_OUT | DT_PROFILE_DIRECTION_DISPLAY);</a>
<a name="ln791">    if(d_histogram) histogram_profile = d_histogram-&gt;profile;</a>
<a name="ln792">  }</a>
<a name="ln793">  </a>
<a name="ln794">  lab_profile = dt_colorspaces_get_profile(DT_COLORSPACE_LAB, &quot;&quot;, DT_PROFILE_DIRECTION_ANY)-&gt;profile;</a>
<a name="ln795"> </a>
<a name="ln796">  // display rgb --&gt; lab</a>
<a name="ln797">  if(display_profile &amp;&amp; lab_profile)</a>
<a name="ln798">    xform_rgb2lab = cmsCreateTransform(display_profile, TYPE_RGB_FLT, lab_profile, TYPE_Lab_FLT, INTENT_PERCEPTUAL, 0);</a>
<a name="ln799"> </a>
<a name="ln800">  // display rgb --&gt; histogram rgb</a>
<a name="ln801">  if(display_profile &amp;&amp; histogram_profile)</a>
<a name="ln802">    xform_rgb2rgb = cmsCreateTransform(display_profile, TYPE_RGB_FLT, histogram_profile, TYPE_RGB_FLT, INTENT_PERCEPTUAL, 0);</a>
<a name="ln803"> </a>
<a name="ln804">  if(darktable.color_profiles-&gt;display_type == DT_COLORSPACE_DISPLAY || histogram_type == DT_COLORSPACE_DISPLAY)</a>
<a name="ln805">    pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln806"> </a>
<a name="ln807">  dt_colorpicker_sample_t *sample = NULL;</a>
<a name="ln808">  GSList *samples = darktable.lib-&gt;proxy.colorpicker.live_samples;</a>
<a name="ln809"> </a>
<a name="ln810">  while(samples)</a>
<a name="ln811">  {</a>
<a name="ln812">    sample = samples-&gt;data;</a>
<a name="ln813"> </a>
<a name="ln814">    if(sample-&gt;locked)</a>
<a name="ln815">    {</a>
<a name="ln816">      samples = g_slist_next(samples);</a>
<a name="ln817">      continue;</a>
<a name="ln818">    }</a>
<a name="ln819"> </a>
<a name="ln820">    _pixelpipe_pick_from_image(input, roi_in, xform_rgb2lab, xform_rgb2rgb,</a>
<a name="ln821">        sample-&gt;box, sample-&gt;point, sample-&gt;size,</a>
<a name="ln822">        sample-&gt;picked_color_rgb_min, sample-&gt;picked_color_rgb_max, sample-&gt;picked_color_rgb_mean,</a>
<a name="ln823">        sample-&gt;picked_color_lab_min, sample-&gt;picked_color_lab_max, sample-&gt;picked_color_lab_mean);</a>
<a name="ln824"> </a>
<a name="ln825">    samples = g_slist_next(samples);</a>
<a name="ln826">  }</a>
<a name="ln827"> </a>
<a name="ln828">  if(xform_rgb2lab) cmsDeleteTransform(xform_rgb2lab);</a>
<a name="ln829">  if(xform_rgb2rgb) cmsDeleteTransform(xform_rgb2rgb);</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">static void _pixelpipe_pick_primary_colorpicker(dt_develop_t *dev, const float *const input, const dt_iop_roi_t *roi_in)</a>
<a name="ln833">{</a>
<a name="ln834">  cmsHPROFILE display_profile = NULL;</a>
<a name="ln835">  cmsHPROFILE histogram_profile = NULL;</a>
<a name="ln836">  cmsHPROFILE lab_profile = NULL;</a>
<a name="ln837">  cmsHTRANSFORM xform_rgb2lab = NULL;</a>
<a name="ln838">  cmsHTRANSFORM xform_rgb2rgb = NULL;</a>
<a name="ln839">  dt_colorspaces_color_profile_type_t histogram_type = DT_COLORSPACE_SRGB;</a>
<a name="ln840">  gchar *histogram_filename = NULL;</a>
<a name="ln841">  gchar _histogram_filename[1] = { 0 };</a>
<a name="ln842"> </a>
<a name="ln843">  _pixelpipe_get_histogram_profile_type(&amp;histogram_type, &amp;histogram_filename);</a>
<a name="ln844">  if(histogram_filename == NULL) histogram_filename = _histogram_filename;</a>
<a name="ln845">  </a>
<a name="ln846">  if(darktable.color_profiles-&gt;display_type == DT_COLORSPACE_DISPLAY || histogram_type == DT_COLORSPACE_DISPLAY)</a>
<a name="ln847">    pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln848"> </a>
<a name="ln849">  const dt_colorspaces_color_profile_t *d_profile = dt_colorspaces_get_profile(darktable.color_profiles-&gt;display_type,</a>
<a name="ln850">                                                       darktable.color_profiles-&gt;display_filename,</a>
<a name="ln851">                                                       DT_PROFILE_DIRECTION_OUT | DT_PROFILE_DIRECTION_DISPLAY);</a>
<a name="ln852">  if(d_profile) display_profile = d_profile-&gt;profile;</a>
<a name="ln853"> </a>
<a name="ln854">  if((histogram_type != darktable.color_profiles-&gt;display_type) || </a>
<a name="ln855">      (histogram_type == DT_COLORSPACE_FILE &amp;&amp;</a>
<a name="ln856">      strcmp(histogram_filename, darktable.color_profiles-&gt;display_filename)))</a>
<a name="ln857">  {</a>
<a name="ln858">    const dt_colorspaces_color_profile_t *d_histogram = dt_colorspaces_get_profile(histogram_type,</a>
<a name="ln859">                                                         histogram_filename,</a>
<a name="ln860">                                                         DT_PROFILE_DIRECTION_OUT | DT_PROFILE_DIRECTION_DISPLAY);</a>
<a name="ln861">    if(d_histogram) histogram_profile = d_histogram-&gt;profile;</a>
<a name="ln862">  }</a>
<a name="ln863">  </a>
<a name="ln864">  lab_profile = dt_colorspaces_get_profile(DT_COLORSPACE_LAB, &quot;&quot;, DT_PROFILE_DIRECTION_ANY)-&gt;profile;</a>
<a name="ln865"> </a>
<a name="ln866">  // display rgb --&gt; lab</a>
<a name="ln867">  if(display_profile &amp;&amp; lab_profile)</a>
<a name="ln868">    xform_rgb2lab = cmsCreateTransform(display_profile, TYPE_RGB_FLT, lab_profile, TYPE_Lab_FLT, INTENT_PERCEPTUAL, 0);</a>
<a name="ln869"> </a>
<a name="ln870">  // display rgb --&gt; histogram rgb</a>
<a name="ln871">  if(display_profile &amp;&amp; histogram_profile)</a>
<a name="ln872">    xform_rgb2rgb = cmsCreateTransform(display_profile, TYPE_RGB_FLT, histogram_profile, TYPE_RGB_FLT, INTENT_PERCEPTUAL, 0);</a>
<a name="ln873"> </a>
<a name="ln874">  if(darktable.color_profiles-&gt;display_type == DT_COLORSPACE_DISPLAY || histogram_type == DT_COLORSPACE_DISPLAY)</a>
<a name="ln875">    pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln876"> </a>
<a name="ln877">  _pixelpipe_pick_from_image(input, roi_in, xform_rgb2lab, xform_rgb2rgb,</a>
<a name="ln878">      dev-&gt;gui_module-&gt;color_picker_box, dev-&gt;gui_module-&gt;color_picker_point, darktable.lib-&gt;proxy.colorpicker.size,</a>
<a name="ln879">      darktable.lib-&gt;proxy.colorpicker.picked_color_rgb_min, darktable.lib-&gt;proxy.colorpicker.picked_color_rgb_max, darktable.lib-&gt;proxy.colorpicker.picked_color_rgb_mean,</a>
<a name="ln880">      darktable.lib-&gt;proxy.colorpicker.picked_color_lab_min, darktable.lib-&gt;proxy.colorpicker.picked_color_lab_max, darktable.lib-&gt;proxy.colorpicker.picked_color_lab_mean);</a>
<a name="ln881"> </a>
<a name="ln882">  if(xform_rgb2lab) cmsDeleteTransform(xform_rgb2lab);</a>
<a name="ln883">  if(xform_rgb2rgb) cmsDeleteTransform(xform_rgb2rgb);</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">static void _pixelpipe_final_histogram(dt_develop_t *dev, const float *const input, const dt_iop_roi_t *roi_in)</a>
<a name="ln887">{</a>
<a name="ln888">  float *img_tmp = NULL;</a>
<a name="ln889">  </a>
<a name="ln890">  dt_dev_histogram_collection_params_t histogram_params = { 0 };</a>
<a name="ln891">  const dt_iop_colorspace_type_t cst = iop_cs_rgb;</a>
<a name="ln892">  dt_dev_histogram_stats_t histogram_stats = { .bins_count = 256, .ch = 4, .pixels = 0 };</a>
<a name="ln893">  uint32_t histogram_max[4] = { 0 };</a>
<a name="ln894">  dt_histogram_roi_t histogram_roi = { .width = roi_in-&gt;width, .height = roi_in-&gt;height,</a>
<a name="ln895">                                      .crop_x = 0, .crop_y = 0, .crop_width = 0, .crop_height = 0 };</a>
<a name="ln896"> </a>
<a name="ln897">  // Constraining the area if the colorpicker is active in area mode</a>
<a name="ln898">  if(dev-&gt;gui_module &amp;&amp; !strcmp(dev-&gt;gui_module-&gt;op, &quot;colorout&quot;)</a>
<a name="ln899">     &amp;&amp; dev-&gt;gui_module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF</a>
<a name="ln900">     &amp;&amp; darktable.lib-&gt;proxy.colorpicker.restrict_histogram)</a>
<a name="ln901">  {</a>
<a name="ln902">    if(darktable.lib-&gt;proxy.colorpicker.size == DT_COLORPICKER_SIZE_BOX)</a>
<a name="ln903">    {</a>
<a name="ln904">      histogram_roi.crop_x = MIN(roi_in-&gt;width, MAX(0, dev-&gt;gui_module-&gt;color_picker_box[0] * roi_in-&gt;width));</a>
<a name="ln905">      histogram_roi.crop_y = MIN(roi_in-&gt;height, MAX(0, dev-&gt;gui_module-&gt;color_picker_box[1] * roi_in-&gt;height));</a>
<a name="ln906">      histogram_roi.crop_width = roi_in-&gt;width - MIN(roi_in-&gt;width, MAX(0, dev-&gt;gui_module-&gt;color_picker_box[2] * roi_in-&gt;width));</a>
<a name="ln907">      histogram_roi.crop_height = roi_in-&gt;height - MIN(roi_in-&gt;height, MAX(0, dev-&gt;gui_module-&gt;color_picker_box[3] * roi_in-&gt;height));</a>
<a name="ln908">    }</a>
<a name="ln909">    else</a>
<a name="ln910">    {</a>
<a name="ln911">      histogram_roi.crop_x = MIN(roi_in-&gt;width, MAX(0, dev-&gt;gui_module-&gt;color_picker_point[0] * roi_in-&gt;width));</a>
<a name="ln912">      histogram_roi.crop_y = MIN(roi_in-&gt;height, MAX(0, dev-&gt;gui_module-&gt;color_picker_point[1] * roi_in-&gt;height));</a>
<a name="ln913">      histogram_roi.crop_width = roi_in-&gt;width - MIN(roi_in-&gt;width, MAX(0, dev-&gt;gui_module-&gt;color_picker_point[0] * roi_in-&gt;width));</a>
<a name="ln914">      histogram_roi.crop_height = roi_in-&gt;height - MIN(roi_in-&gt;height, MAX(0, dev-&gt;gui_module-&gt;color_picker_point[1] * roi_in-&gt;height));</a>
<a name="ln915">    }</a>
<a name="ln916">  }</a>
<a name="ln917"> </a>
<a name="ln918">  dt_colorspaces_color_profile_type_t histogram_type = DT_COLORSPACE_SRGB;</a>
<a name="ln919">  gchar *histogram_filename = NULL;</a>
<a name="ln920">  gchar _histogram_filename[1] = { 0 };</a>
<a name="ln921"> </a>
<a name="ln922">  _pixelpipe_get_histogram_profile_type(&amp;histogram_type, &amp;histogram_filename);</a>
<a name="ln923">  if(histogram_filename == NULL) histogram_filename = _histogram_filename;</a>
<a name="ln924">  </a>
<a name="ln925">  if((histogram_type != darktable.color_profiles-&gt;display_type) || </a>
<a name="ln926">      (histogram_type == DT_COLORSPACE_FILE &amp;&amp;</a>
<a name="ln927">      strcmp(histogram_filename, darktable.color_profiles-&gt;display_filename)))</a>
<a name="ln928">  {</a>
<a name="ln929">    cmsHPROFILE display_profile = NULL;</a>
<a name="ln930">    cmsHPROFILE histogram_profile = NULL;</a>
<a name="ln931">    cmsHTRANSFORM xform_rgb2rgb = NULL;</a>
<a name="ln932">    </a>
<a name="ln933">    if(darktable.color_profiles-&gt;display_type == DT_COLORSPACE_DISPLAY || histogram_type == DT_COLORSPACE_DISPLAY)</a>
<a name="ln934">      pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln935"> </a>
<a name="ln936">    const dt_colorspaces_color_profile_t *d_profile = dt_colorspaces_get_profile(darktable.color_profiles-&gt;display_type,</a>
<a name="ln937">                                                         darktable.color_profiles-&gt;display_filename,</a>
<a name="ln938">                                                         DT_PROFILE_DIRECTION_OUT | DT_PROFILE_DIRECTION_DISPLAY);</a>
<a name="ln939">    if(d_profile) display_profile = d_profile-&gt;profile;</a>
<a name="ln940"> </a>
<a name="ln941">    const dt_colorspaces_color_profile_t *d_histogram = dt_colorspaces_get_profile(histogram_type,</a>
<a name="ln942">                                                         histogram_filename,</a>
<a name="ln943">                                                         DT_PROFILE_DIRECTION_OUT | DT_PROFILE_DIRECTION_DISPLAY);</a>
<a name="ln944">    if(d_histogram) histogram_profile = d_histogram-&gt;profile;</a>
<a name="ln945">    </a>
<a name="ln946">    if(darktable.color_profiles-&gt;display_type == DT_COLORSPACE_DISPLAY || histogram_type == DT_COLORSPACE_DISPLAY)</a>
<a name="ln947">      pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln948">  </a>
<a name="ln949">    // display rgb --&gt; histogram rgb</a>
<a name="ln950">    if(display_profile &amp;&amp; histogram_profile)</a>
<a name="ln951">      xform_rgb2rgb = cmsCreateTransform(display_profile, TYPE_RGBA_FLT, histogram_profile, TYPE_RGBA_FLT, INTENT_PERCEPTUAL, 0);</a>
<a name="ln952">    </a>
<a name="ln953">    img_tmp = dt_alloc_align(64, roi_in-&gt;width * roi_in-&gt;height * 4 * sizeof(float));</a>
<a name="ln954">    </a>
<a name="ln955">    cmsDoTransform(xform_rgb2rgb, input, img_tmp, roi_in-&gt;width * roi_in-&gt;height);</a>
<a name="ln956"> </a>
<a name="ln957">    if(xform_rgb2rgb) cmsDeleteTransform(xform_rgb2rgb);</a>
<a name="ln958">  }</a>
<a name="ln959"> </a>
<a name="ln960">  dev-&gt;histogram_max = 0;</a>
<a name="ln961">  memset(dev-&gt;histogram, 0, sizeof(uint32_t) * 4 * 256);</a>
<a name="ln962"> </a>
<a name="ln963">  histogram_params.roi = &amp;histogram_roi;</a>
<a name="ln964">  histogram_params.bins_count = 256;</a>
<a name="ln965">  histogram_params.mul = histogram_params.bins_count - 1;</a>
<a name="ln966"> </a>
<a name="ln967">  dt_histogram_helper(&amp;histogram_params, &amp;histogram_stats, cst, (img_tmp) ? img_tmp: input, &amp;dev-&gt;histogram);</a>
<a name="ln968">  dt_histogram_max_helper(&amp;histogram_stats, cst, &amp;dev-&gt;histogram, histogram_max);</a>
<a name="ln969">  dev-&gt;histogram_max = MAX(MAX(histogram_max[0], histogram_max[1]), histogram_max[2]);</a>
<a name="ln970">  </a>
<a name="ln971">  if(img_tmp) dt_free_align(img_tmp);</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974">static void _pixelpipe_final_histogram_waveform(dt_develop_t *dev, const float *const input, const dt_iop_roi_t *roi_in)</a>
<a name="ln975">{</a>
<a name="ln976">  uint32_t *buf = (uint32_t *)calloc(dev-&gt;histogram_waveform_height * dev-&gt;histogram_waveform_width * 3,</a>
<a name="ln977">                                     sizeof(uint32_t));</a>
<a name="ln978">  memset(dev-&gt;histogram_waveform, 0,</a>
<a name="ln979">         sizeof(uint32_t) * dev-&gt;histogram_waveform_height * dev-&gt;histogram_waveform_stride / 4);</a>
<a name="ln980"> </a>
<a name="ln981">  // 1.0 is at 8/9 of the height!</a>
<a name="ln982">  const double bin_width = (double)(roi_in-&gt;width) / (double)dev-&gt;histogram_waveform_width,</a>
<a name="ln983">               _height = (double)(dev-&gt;histogram_waveform_height - 1);</a>
<a name="ln984">  const float *const pixel = (const float *const )input;</a>
<a name="ln985">  //         uint32_t mincol[3] = {UINT32_MAX,UINT32_MAX,UINT32_MAX}, maxcol[3] = {0,0,0};</a>
<a name="ln986"> </a>
<a name="ln987">  // count the colors into buf ...</a>
<a name="ln988">  for(int y = 0; y &lt; roi_in-&gt;height; y++)</a>
<a name="ln989">  {</a>
<a name="ln990">    for(int x = 0; x &lt; roi_in-&gt;width; x++)</a>
<a name="ln991">    {</a>
<a name="ln992">      float rgb[3];</a>
<a name="ln993">      for(int k = 0; k &lt; 3; k++) rgb[k] = pixel[4 * y * roi_in-&gt;width + 4 * x + 2 - k];</a>
<a name="ln994"> </a>
<a name="ln995">      const int out_x = MIN(x / bin_width, dev-&gt;histogram_waveform_width - 1);</a>
<a name="ln996">      for(int k = 0; k &lt; 3; k++)</a>
<a name="ln997">      {</a>
<a name="ln998">        const float v = isnan(rgb[k]) ? 0.0f</a>
<a name="ln999">                                      : rgb[k]; // catch NaNs as they don't convert well to integers</a>
<a name="ln1000">        const int out_y = CLAMP(1.0 - (8.0 / 9.0) * v, 0.0, 1.0) * _height;</a>
<a name="ln1001">        uint32_t *const out = buf + (out_y * dev-&gt;histogram_waveform_width * 3 + out_x * 3 + k);</a>
<a name="ln1002">        (*out)++;</a>
<a name="ln1003">        //               mincol[k] = MIN(mincol[k], *out);</a>
<a name="ln1004">        //               maxcol[k] = MAX(maxcol[k], *out);</a>
<a name="ln1005">      }</a>
<a name="ln1006">    }</a>
<a name="ln1007">  }</a>
<a name="ln1008"> </a>
<a name="ln1009">  // TODO: Find a nicer function to map buf -&gt; image than just clipping</a>
<a name="ln1010">  //         float factor[3];</a>
<a name="ln1011">  //         for(int k = 0; k &lt; 3; k++)</a>
<a name="ln1012">  //           factor[k] = 255.0 / (float)(maxcol[k] - mincol[k]); // leave some clipping</a>
<a name="ln1013"> </a>
<a name="ln1014">  // ... and scale that into a nice image. putting the pixels into the image directly gets too</a>
<a name="ln1015">  // saturated/clips.</a>
<a name="ln1016">  // new scale factor to do about the same as the old one for 1MP views, but scale to hidpi</a>
<a name="ln1017">  const float scale = 0.5 * 1e6f/(roi_in-&gt;height*roi_in-&gt;width) *</a>
<a name="ln1018">    (dev-&gt;histogram_waveform_width*dev-&gt;histogram_waveform_height) / (350.0f*233.);</a>
<a name="ln1019">  for(int y = 0; y &lt; dev-&gt;histogram_waveform_height; y++)</a>
<a name="ln1020">  {</a>
<a name="ln1021">    for(int x = 0; x &lt; dev-&gt;histogram_waveform_width; x++)</a>
<a name="ln1022">    {</a>
<a name="ln1023">      uint32_t *const in = buf + (y * dev-&gt;histogram_waveform_width + x) * 3;</a>
<a name="ln1024">      uint8_t *const out</a>
<a name="ln1025">          = (uint8_t *)(dev-&gt;histogram_waveform + (y * dev-&gt;histogram_waveform_width + x));</a>
<a name="ln1026">      for(int k = 0; k &lt; 3; k++)</a>
<a name="ln1027">      {</a>
<a name="ln1028">        if(in[k] == 0) continue;</a>
<a name="ln1029">        out[k] = CLAMP(in[k] * scale, 5, 255);</a>
<a name="ln1030">        //               if(in[k] == 0)</a>
<a name="ln1031">        //                 out[k] = 0;</a>
<a name="ln1032">        //               else</a>
<a name="ln1033">        //                 out[k] = (float)(in[k] - mincol[k]) * factor[k];</a>
<a name="ln1034">      }</a>
<a name="ln1035">    }</a>
<a name="ln1036">  }</a>
<a name="ln1037"> </a>
<a name="ln1038">  free(buf);</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041">// recursive helper for process:</a>
<a name="ln1042">static int dt_dev_pixelpipe_process_rec(dt_dev_pixelpipe_t *pipe, dt_develop_t *dev, void **output,</a>
<a name="ln1043">                                        void **cl_mem_output, dt_iop_buffer_dsc_t **out_format,</a>
<a name="ln1044">                                        const dt_iop_roi_t *roi_out, GList *modules, GList *pieces, int pos)</a>
<a name="ln1045">{</a>
<a name="ln1046">  dt_iop_roi_t roi_in = *roi_out;</a>
<a name="ln1047"> </a>
<a name="ln1048">  char module_name[256] = { 0 };</a>
<a name="ln1049">  void *input = NULL;</a>
<a name="ln1050">  void *cl_mem_input = NULL;</a>
<a name="ln1051">  *cl_mem_output = NULL;</a>
<a name="ln1052">  dt_iop_module_t *module = NULL;</a>
<a name="ln1053">  dt_dev_pixelpipe_iop_t *piece = NULL;</a>
<a name="ln1054">  if(modules)</a>
<a name="ln1055">  {</a>
<a name="ln1056">    module = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1057">    piece = (dt_dev_pixelpipe_iop_t *)pieces-&gt;data;</a>
<a name="ln1058">    // skip this module?</a>
<a name="ln1059">    if(!piece-&gt;enabled</a>
<a name="ln1060">       || (dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;operation_tags_filter() &amp; module-&gt;operation_tags()))</a>
<a name="ln1061">      return dt_dev_pixelpipe_process_rec(pipe, dev, output, cl_mem_output, out_format, &amp;roi_in,</a>
<a name="ln1062">                                          g_list_previous(modules), g_list_previous(pieces), pos - 1);</a>
<a name="ln1063">  }</a>
<a name="ln1064"> </a>
<a name="ln1065">  if(module) g_strlcpy(module_name, module-&gt;op, MIN(sizeof(module_name), sizeof(module-&gt;op)));</a>
<a name="ln1066">  get_output_format(module, pipe, piece, dev, *out_format);</a>
<a name="ln1067">  const size_t bpp = dt_iop_buffer_dsc_to_bpp(*out_format);</a>
<a name="ln1068">  const size_t bufsize = (size_t)bpp * roi_out-&gt;width * roi_out-&gt;height;</a>
<a name="ln1069"> </a>
<a name="ln1070">  // 1) if cached buffer is still available, return data</a>
<a name="ln1071">  dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1072">  if(pipe-&gt;shutdown)</a>
<a name="ln1073">  {</a>
<a name="ln1074">    dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1075">    return 1;</a>
<a name="ln1076">  }</a>
<a name="ln1077">  uint64_t hash = dt_dev_pixelpipe_cache_hash(pipe-&gt;image.id, roi_out, pipe, pos);</a>
<a name="ln1078">  if(dt_dev_pixelpipe_cache_available(&amp;(pipe-&gt;cache), hash))</a>
<a name="ln1079">  {</a>
<a name="ln1080">    // if(module) printf(&quot;found valid buf pos %d in cache for module %s %s %lu\n&quot;, pos, module-&gt;op, pipe ==</a>
<a name="ln1081">    // dev-&gt;preview_pipe ? &quot;[preview]&quot; : &quot;&quot;, hash);</a>
<a name="ln1082"> </a>
<a name="ln1083">    (void)dt_dev_pixelpipe_cache_get(&amp;(pipe-&gt;cache), hash, bufsize, output, out_format);</a>
<a name="ln1084"> </a>
<a name="ln1085">    dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1086">    if(!modules) return 0;</a>
<a name="ln1087">    // go to post-collect directly:</a>
<a name="ln1088">    goto post_process_collect_info;</a>
<a name="ln1089">  }</a>
<a name="ln1090">  else</a>
<a name="ln1091">    dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1092"> </a>
<a name="ln1093">  // 2) if history changed or exit event, abort processing?</a>
<a name="ln1094">  // preview pipe: abort on all but zoom events (same buffer anyways)</a>
<a name="ln1095">  if(dt_iop_breakpoint(dev, pipe)) return 1;</a>
<a name="ln1096">  // if image has changed, stop now.</a>
<a name="ln1097">  if(pipe == dev-&gt;pipe &amp;&amp; dev-&gt;image_force_reload) return 1;</a>
<a name="ln1098">  if(pipe == dev-&gt;preview_pipe &amp;&amp; dev-&gt;preview_loading) return 1;</a>
<a name="ln1099">  if(dev-&gt;gui_leaving) return 1;</a>
<a name="ln1100"> </a>
<a name="ln1101"> </a>
<a name="ln1102">  // 3) input -&gt; output</a>
<a name="ln1103">  if(!modules)</a>
<a name="ln1104">  {</a>
<a name="ln1105">    // 3a) import input array with given scale and roi</a>
<a name="ln1106">    dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1107">    if(pipe-&gt;shutdown)</a>
<a name="ln1108">    {</a>
<a name="ln1109">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1110">      return 1;</a>
<a name="ln1111">    }</a>
<a name="ln1112">    dt_times_t start;</a>
<a name="ln1113">    dt_get_times(&amp;start);</a>
<a name="ln1114">    // we're looking for the full buffer</a>
<a name="ln1115">    {</a>
<a name="ln1116">      if(roi_out-&gt;scale == 1.0 &amp;&amp; roi_out-&gt;x == 0 &amp;&amp; roi_out-&gt;y == 0 &amp;&amp; pipe-&gt;iwidth == roi_out-&gt;width</a>
<a name="ln1117">         &amp;&amp; pipe-&gt;iheight == roi_out-&gt;height)</a>
<a name="ln1118">      {</a>
<a name="ln1119">        *output = pipe-&gt;input;</a>
<a name="ln1120">      }</a>
<a name="ln1121">      else if(dt_dev_pixelpipe_cache_get(&amp;(pipe-&gt;cache), hash, bufsize, output, out_format))</a>
<a name="ln1122">      {</a>
<a name="ln1123">        memset(*output, 0, bufsize);</a>
<a name="ln1124">        if(roi_in.scale == 1.0f)</a>
<a name="ln1125">        {</a>
<a name="ln1126">          // fast branch for 1:1 pixel copies.</a>
<a name="ln1127"> </a>
<a name="ln1128">          // last minute clamping to catch potential out-of-bounds in roi_in and roi_out</a>
<a name="ln1129"> </a>
<a name="ln1130">          const int in_x = MAX(roi_in.x, 0);</a>
<a name="ln1131">          const int in_y = MAX(roi_in.y, 0);</a>
<a name="ln1132">          const int cp_width = MIN(roi_out-&gt;width, pipe-&gt;iwidth - in_x);</a>
<a name="ln1133">          const int cp_height = MIN(roi_out-&gt;height, pipe-&gt;iheight - in_y);</a>
<a name="ln1134"> </a>
<a name="ln1135">#ifdef _OPENMP</a>
<a name="ln1136">#pragma omp parallel for schedule(static) default(none) shared(pipe, roi_out, roi_in, output)</a>
<a name="ln1137">#endif</a>
<a name="ln1138">          for(int j = 0; j &lt; cp_height; j++)</a>
<a name="ln1139">            memcpy(((char *)*output) + (size_t)bpp * j * roi_out-&gt;width,</a>
<a name="ln1140">                   ((char *)pipe-&gt;input) + (size_t)bpp * (in_x + (in_y + j) * pipe-&gt;iwidth),</a>
<a name="ln1141">                   (size_t)bpp * cp_width);</a>
<a name="ln1142">        }</a>
<a name="ln1143">        else</a>
<a name="ln1144">        {</a>
<a name="ln1145">          roi_in.x /= roi_out-&gt;scale;</a>
<a name="ln1146">          roi_in.y /= roi_out-&gt;scale;</a>
<a name="ln1147">          roi_in.width = pipe-&gt;iwidth;</a>
<a name="ln1148">          roi_in.height = pipe-&gt;iheight;</a>
<a name="ln1149">          roi_in.scale = 1.0f;</a>
<a name="ln1150">          dt_iop_clip_and_zoom(*output, pipe-&gt;input, roi_out, &amp;roi_in, roi_out-&gt;width, pipe-&gt;iwidth);</a>
<a name="ln1151">        }</a>
<a name="ln1152">      }</a>
<a name="ln1153">      // else found in cache.</a>
<a name="ln1154">    }</a>
<a name="ln1155"> </a>
<a name="ln1156">    dt_show_times(&amp;start, &quot;[dev_pixelpipe]&quot;, &quot;initing base buffer [%s]&quot;, _pipe_type_to_str(pipe-&gt;type));</a>
<a name="ln1157">    dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1158">  }</a>
<a name="ln1159">  else</a>
<a name="ln1160">  {</a>
<a name="ln1161">    // 3b) recurse and obtain output array in &amp;input</a>
<a name="ln1162"> </a>
<a name="ln1163">    // get region of interest which is needed in input</a>
<a name="ln1164">    dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1165">    if(pipe-&gt;shutdown)</a>
<a name="ln1166">    {</a>
<a name="ln1167">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1168">      return 1;</a>
<a name="ln1169">    }</a>
<a name="ln1170">    module-&gt;modify_roi_in(module, piece, roi_out, &amp;roi_in);</a>
<a name="ln1171">    dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1172"> </a>
<a name="ln1173">    // recurse to get actual data of input buffer</a>
<a name="ln1174"> </a>
<a name="ln1175">    dt_iop_buffer_dsc_t _input_format = { 0 };</a>
<a name="ln1176">    dt_iop_buffer_dsc_t *input_format = &amp;_input_format;</a>
<a name="ln1177"> </a>
<a name="ln1178">    piece = (dt_dev_pixelpipe_iop_t *)pieces-&gt;data;</a>
<a name="ln1179"> </a>
<a name="ln1180">    piece-&gt;processed_roi_in = roi_in;</a>
<a name="ln1181">    piece-&gt;processed_roi_out = *roi_out;</a>
<a name="ln1182"> </a>
<a name="ln1183">    if(dt_dev_pixelpipe_process_rec(pipe, dev, &amp;input, &amp;cl_mem_input, &amp;input_format, &amp;roi_in,</a>
<a name="ln1184">                                    g_list_previous(modules), g_list_previous(pieces), pos - 1))</a>
<a name="ln1185">      return 1;</a>
<a name="ln1186"> </a>
<a name="ln1187">    const size_t in_bpp = dt_iop_buffer_dsc_to_bpp(input_format);</a>
<a name="ln1188"> </a>
<a name="ln1189">    piece-&gt;dsc_out = piece-&gt;dsc_in = *input_format;</a>
<a name="ln1190"> </a>
<a name="ln1191">    module-&gt;output_format(module, pipe, piece, &amp;piece-&gt;dsc_out);</a>
<a name="ln1192"> </a>
<a name="ln1193">    **out_format = pipe-&gt;dsc = piece-&gt;dsc_out;</a>
<a name="ln1194"> </a>
<a name="ln1195">    const size_t out_bpp = dt_iop_buffer_dsc_to_bpp(*out_format);</a>
<a name="ln1196"> </a>
<a name="ln1197">    // reserve new cache line: output</a>
<a name="ln1198">    dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1199">    if(pipe-&gt;shutdown)</a>
<a name="ln1200">    {</a>
<a name="ln1201">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1202">      return 1;</a>
<a name="ln1203">    }</a>
<a name="ln1204"> </a>
<a name="ln1205">    if(!strcmp(module-&gt;op, &quot;gamma&quot;))</a>
<a name="ln1206">      (void)dt_dev_pixelpipe_cache_get_important(&amp;(pipe-&gt;cache), hash, bufsize, output, out_format);</a>
<a name="ln1207">    else</a>
<a name="ln1208">      (void)dt_dev_pixelpipe_cache_get(&amp;(pipe-&gt;cache), hash, bufsize, output, out_format);</a>
<a name="ln1209"> </a>
<a name="ln1210">    dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1211"> </a>
<a name="ln1212">// if(module) printf(&quot;reserving new buf in cache for module %s %s: %ld buf %p\n&quot;, module-&gt;op, pipe ==</a>
<a name="ln1213">// dev-&gt;preview_pipe ? &quot;[preview]&quot; : &quot;&quot;, hash, *output);</a>
<a name="ln1214"> </a>
<a name="ln1215">    dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1216">    if(pipe-&gt;shutdown)</a>
<a name="ln1217">    {</a>
<a name="ln1218">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1219">      return 1;</a>
<a name="ln1220">    }</a>
<a name="ln1221"> </a>
<a name="ln1222">    dt_times_t start;</a>
<a name="ln1223">    dt_get_times(&amp;start);</a>
<a name="ln1224"> </a>
<a name="ln1225">    dt_pixelpipe_flow_t pixelpipe_flow = (PIXELPIPE_FLOW_NONE | PIXELPIPE_FLOW_HISTOGRAM_NONE);</a>
<a name="ln1226"> </a>
<a name="ln1227">    // special case: user requests to see channel data in the parametric mask of a module. In that case</a>
<a name="ln1228">    // we skip all modules manipulating pixel content and only process image distorting modules. Finally</a>
<a name="ln1229">    // &quot;gamma&quot; is responsible to display channel data accordingly.</a>
<a name="ln1230">    if(strcmp(module-&gt;op, &quot;gamma&quot;) &amp;&amp; (pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_ANY) &amp;&amp; !(module-&gt;operation_tags() &amp; IOP_TAG_DISTORT) &amp;&amp;</a>
<a name="ln1231">      (in_bpp == out_bpp) &amp;&amp; !memcmp(&amp;roi_in, roi_out, sizeof(struct dt_iop_roi_t)))</a>
<a name="ln1232">    {</a>
<a name="ln1233">#ifdef HAVE_OPENCL</a>
<a name="ln1234">      if(dt_opencl_is_inited() &amp;&amp; pipe-&gt;opencl_enabled &amp;&amp; pipe-&gt;devid &gt;= 0 &amp;&amp; (cl_mem_input != NULL))</a>
<a name="ln1235">      {</a>
<a name="ln1236">        *cl_mem_output = cl_mem_input;</a>
<a name="ln1237">      }</a>
<a name="ln1238">      else</a>
<a name="ln1239">      {</a>
<a name="ln1240">#ifdef _OPENMP</a>
<a name="ln1241">#pragma omp parallel for schedule(static) default(none) shared(roi_out, roi_in, output, input)</a>
<a name="ln1242">#endif</a>
<a name="ln1243">        for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln1244">            memcpy(((char *)*output) + (size_t)out_bpp * j * roi_out-&gt;width,</a>
<a name="ln1245">                   ((char *)input) + (size_t)in_bpp * j * roi_in.width,</a>
<a name="ln1246">                   (size_t)in_bpp * roi_in.width);</a>
<a name="ln1247">      }</a>
<a name="ln1248">#else // don't HAVE_OPENCL</a>
<a name="ln1249">#ifdef _OPENMP</a>
<a name="ln1250">#pragma omp parallel for schedule(static) default(none) shared(roi_out, roi_in, output, input)</a>
<a name="ln1251">#endif</a>
<a name="ln1252">      for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln1253">            memcpy(((char *)*output) + (size_t)out_bpp * j * roi_out-&gt;width,</a>
<a name="ln1254">                   ((char *)input) + (size_t)in_bpp * j * roi_in.width,</a>
<a name="ln1255">                   (size_t)in_bpp * roi_in.width);</a>
<a name="ln1256">#endif</a>
<a name="ln1257"> </a>
<a name="ln1258">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1259">      return 0;</a>
<a name="ln1260">    }</a>
<a name="ln1261"> </a>
<a name="ln1262"> </a>
<a name="ln1263">    /* get tiling requirement of module */</a>
<a name="ln1264">    dt_develop_tiling_t tiling = { 0 };</a>
<a name="ln1265">    module-&gt;tiling_callback(module, piece, &amp;roi_in, roi_out, &amp;tiling);</a>
<a name="ln1266"> </a>
<a name="ln1267">    /* does this module involve blending? */</a>
<a name="ln1268">    if(piece-&gt;blendop_data &amp;&amp; (dt_develop_blend_params_t *)piece-&gt;blendop_data != DEVELOP_MASK_DISABLED)</a>
<a name="ln1269">    {</a>
<a name="ln1270">      /* get specific memory requirement for blending */</a>
<a name="ln1271">      dt_develop_tiling_t tiling_blendop = { 0 };</a>
<a name="ln1272">      tiling_callback_blendop(module, piece, &amp;roi_in, roi_out, &amp;tiling_blendop);</a>
<a name="ln1273"> </a>
<a name="ln1274">      /* aggregate in structure tiling */</a>
<a name="ln1275">      tiling.factor = fmax(tiling.factor, tiling_blendop.factor);</a>
<a name="ln1276">      tiling.maxbuf = fmax(tiling.maxbuf, tiling_blendop.maxbuf);</a>
<a name="ln1277">      tiling.overhead = fmax(tiling.overhead, tiling_blendop.overhead);</a>
<a name="ln1278">    }</a>
<a name="ln1279"> </a>
<a name="ln1280">    /* remark: we do not do tiling for blendop step, neither in opencl nor on cpu. if overall tiling</a>
<a name="ln1281">       requirements (maximum of module and blendop) require tiling for opencl path, then following blend</a>
<a name="ln1282">       step is anyhow done on cpu. we assume that blending itself will never require tiling in cpu path,</a>
<a name="ln1283">       because memory requirements will still be low enough. */</a>
<a name="ln1284"> </a>
<a name="ln1285">    assert(tiling.factor &gt; 0.0f);</a>
<a name="ln1286"> </a>
<a name="ln1287">    if(pipe-&gt;shutdown)</a>
<a name="ln1288">    {</a>
<a name="ln1289">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1290">      return 1;</a>
<a name="ln1291">    }</a>
<a name="ln1292"> </a>
<a name="ln1293">#ifdef HAVE_OPENCL</a>
<a name="ln1294">    /* do we have opencl at all? did user tell us to use it? did we get a resource? */</a>
<a name="ln1295">    if(dt_opencl_is_inited() &amp;&amp; pipe-&gt;opencl_enabled &amp;&amp; pipe-&gt;devid &gt;= 0)</a>
<a name="ln1296">    {</a>
<a name="ln1297">      int success_opencl = TRUE;</a>
<a name="ln1298"> </a>
<a name="ln1299">      /* if input is on gpu memory only, remember this fact to later take appropriate action */</a>
<a name="ln1300">      int valid_input_on_gpu_only = (cl_mem_input != NULL);</a>
<a name="ln1301"> </a>
<a name="ln1302">      /* pre-check if there is enough space on device for non-tiled processing */</a>
<a name="ln1303">      const int fits_on_device = dt_opencl_image_fits_device(pipe-&gt;devid, MAX(roi_in.width, roi_out-&gt;width),</a>
<a name="ln1304">                                                             MAX(roi_in.height, roi_out-&gt;height), MAX(in_bpp, bpp),</a>
<a name="ln1305">                                                             tiling.factor, tiling.overhead);</a>
<a name="ln1306"> </a>
<a name="ln1307">      /* general remark: in case of opencl errors within modules or out-of-memory on GPU, we transparently</a>
<a name="ln1308">         fall back to the respective cpu module and continue in pixelpipe. If we encounter errors we set</a>
<a name="ln1309">         pipe-&gt;opencl_error=1, return this function with value 1, and leave appropriate action to the calling</a>
<a name="ln1310">         function, which normally would restart pixelpipe without opencl.</a>
<a name="ln1311">         Late errors are sometimes detected when trying to get back data from device into host memory and</a>
<a name="ln1312">         are treated in the same manner. */</a>
<a name="ln1313"> </a>
<a name="ln1314">      /* try to enter opencl path after checking some module specific pre-requisites */</a>
<a name="ln1315">      if(module-&gt;process_cl &amp;&amp; piece-&gt;process_cl_ready</a>
<a name="ln1316">         &amp;&amp; !((pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW) &amp;&amp; (module-&gt;flags() &amp; IOP_FLAGS_PREVIEW_NON_OPENCL))</a>
<a name="ln1317">         &amp;&amp; (fits_on_device || piece-&gt;process_tiling_ready))</a>
<a name="ln1318">      {</a>
<a name="ln1319"> </a>
<a name="ln1320">        // fprintf(stderr, &quot;[opencl_pixelpipe 0] factor %f, overhead %d, width %d, height %d, bpp %d\n&quot;,</a>
<a name="ln1321">        // (double)tiling.factor, tiling.overhead, roi_in.width, roi_in.height, bpp);</a>
<a name="ln1322"> </a>
<a name="ln1323">        // fprintf(stderr, &quot;[opencl_pixelpipe 1] for module `%s', have bufs %p and %p \n&quot;, module-&gt;op,</a>
<a name="ln1324">        // cl_mem_input, *cl_mem_output);</a>
<a name="ln1325">        // fprintf(stderr, &quot;[opencl_pixelpipe 1] module '%s'\n&quot;, module-&gt;op);</a>
<a name="ln1326"> </a>
<a name="ln1327">        if(fits_on_device)</a>
<a name="ln1328">        {</a>
<a name="ln1329">          /* image is small enough -&gt; try to directly process entire image with opencl */</a>
<a name="ln1330"> </a>
<a name="ln1331">          // fprintf(stderr, &quot;[opencl_pixelpipe 2] module '%s' running directly with process_cl\n&quot;,</a>
<a name="ln1332">          // module-&gt;op);</a>
<a name="ln1333"> </a>
<a name="ln1334">          /* input is not on gpu memory -&gt; copy it there */</a>
<a name="ln1335">          if(cl_mem_input == NULL)</a>
<a name="ln1336">          {</a>
<a name="ln1337">            cl_mem_input = dt_opencl_alloc_device(pipe-&gt;devid, roi_in.width, roi_in.height, in_bpp);</a>
<a name="ln1338">            if(cl_mem_input == NULL)</a>
<a name="ln1339">            {</a>
<a name="ln1340">              dt_print(DT_DEBUG_OPENCL, &quot;[opencl_pixelpipe] couldn't generate input buffer for module %s\n&quot;,</a>
<a name="ln1341">                       module-&gt;op);</a>
<a name="ln1342">              success_opencl = FALSE;</a>
<a name="ln1343">            }</a>
<a name="ln1344"> </a>
<a name="ln1345">            if(success_opencl)</a>
<a name="ln1346">            {</a>
<a name="ln1347">              cl_int err = dt_opencl_write_host_to_device(pipe-&gt;devid, input, cl_mem_input,</a>
<a name="ln1348">                                                                       roi_in.width, roi_in.height, in_bpp);</a>
<a name="ln1349">              if(err != CL_SUCCESS)</a>
<a name="ln1350">              {</a>
<a name="ln1351">                dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln1352">                         &quot;[opencl_pixelpipe] couldn't copy image to opencl device for module %s\n&quot;,</a>
<a name="ln1353">                         module-&gt;op);</a>
<a name="ln1354">                success_opencl = FALSE;</a>
<a name="ln1355">              }</a>
<a name="ln1356">            }</a>
<a name="ln1357">          }</a>
<a name="ln1358"> </a>
<a name="ln1359">          if(pipe-&gt;shutdown)</a>
<a name="ln1360">          {</a>
<a name="ln1361">            dt_opencl_release_mem_object(cl_mem_input);</a>
<a name="ln1362">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1363">            return 1;</a>
<a name="ln1364">          }</a>
<a name="ln1365"> </a>
<a name="ln1366">          /* try to allocate GPU memory for output */</a>
<a name="ln1367">          if(success_opencl)</a>
<a name="ln1368">          {</a>
<a name="ln1369">            *cl_mem_output = dt_opencl_alloc_device(pipe-&gt;devid, roi_out-&gt;width, roi_out-&gt;height, bpp);</a>
<a name="ln1370">            if(*cl_mem_output == NULL)</a>
<a name="ln1371">            {</a>
<a name="ln1372">              dt_print(DT_DEBUG_OPENCL, &quot;[opencl_pixelpipe] couldn't allocate output buffer for module %s\n&quot;,</a>
<a name="ln1373">                       module-&gt;op);</a>
<a name="ln1374">              success_opencl = FALSE;</a>
<a name="ln1375">            }</a>
<a name="ln1376">          }</a>
<a name="ln1377"> </a>
<a name="ln1378">          // fprintf(stderr, &quot;[opencl_pixelpipe 2] for module `%s', have bufs %p and %p \n&quot;, module-&gt;op,</a>
<a name="ln1379">          // cl_mem_input, *cl_mem_output);</a>
<a name="ln1380"> </a>
<a name="ln1381">          // indirectly give gpu some air to breathe (and to do display related stuff)</a>
<a name="ln1382">          dt_iop_nap(darktable.opencl-&gt;micro_nap);</a>
<a name="ln1383"> </a>
<a name="ln1384">          // histogram collection for module</a>
<a name="ln1385">          if(success_opencl &amp;&amp; (dev-&gt;gui_attached || !(piece-&gt;request_histogram &amp; DT_REQUEST_ONLY_IN_GUI))</a>
<a name="ln1386">             &amp;&amp; (piece-&gt;request_histogram &amp; DT_REQUEST_ON))</a>
<a name="ln1387">          {</a>
<a name="ln1388">            // we abuse the empty output buffer on host for intermediate storage of data in</a>
<a name="ln1389">            // histogram_collect_cl()</a>
<a name="ln1390">            size_t outbufsize = roi_out-&gt;width * roi_out-&gt;height * bpp;</a>
<a name="ln1391"> </a>
<a name="ln1392">            histogram_collect_cl(pipe-&gt;devid, piece, cl_mem_input, &amp;roi_in, &amp;(piece-&gt;histogram),</a>
<a name="ln1393">                                 piece-&gt;histogram_max, *output, outbufsize);</a>
<a name="ln1394">            pixelpipe_flow |= (PIXELPIPE_FLOW_HISTOGRAM_ON_GPU);</a>
<a name="ln1395">            pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_HISTOGRAM_NONE | PIXELPIPE_FLOW_HISTOGRAM_ON_CPU);</a>
<a name="ln1396"> </a>
<a name="ln1397">            if(piece-&gt;histogram &amp;&amp; (module-&gt;request_histogram &amp; DT_REQUEST_ON)</a>
<a name="ln1398">               &amp;&amp; pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln1399">            {</a>
<a name="ln1400">              const size_t buf_size = 4 * piece-&gt;histogram_stats.bins_count * sizeof(uint32_t);</a>
<a name="ln1401">              module-&gt;histogram = realloc(module-&gt;histogram, buf_size);</a>
<a name="ln1402">              memcpy(module-&gt;histogram, piece-&gt;histogram, buf_size);</a>
<a name="ln1403">              module-&gt;histogram_stats = piece-&gt;histogram_stats;</a>
<a name="ln1404">              memcpy(module-&gt;histogram_max, piece-&gt;histogram_max, sizeof(piece-&gt;histogram_max));</a>
<a name="ln1405"> </a>
<a name="ln1406">              dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1407"> </a>
<a name="ln1408">              if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln1409"> </a>
<a name="ln1410">              dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1411">            }</a>
<a name="ln1412">          }</a>
<a name="ln1413"> </a>
<a name="ln1414">          if(pipe-&gt;shutdown)</a>
<a name="ln1415">          {</a>
<a name="ln1416">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1417">            return 1;</a>
<a name="ln1418">          }</a>
<a name="ln1419"> </a>
<a name="ln1420">          /* now call process_cl of module; module should emit meaningful messages in case of error */</a>
<a name="ln1421">          if(success_opencl)</a>
<a name="ln1422">          {</a>
<a name="ln1423">            success_opencl</a>
<a name="ln1424">                = module-&gt;process_cl(module, piece, cl_mem_input, *cl_mem_output, &amp;roi_in, roi_out);</a>
<a name="ln1425">            pixelpipe_flow |= (PIXELPIPE_FLOW_PROCESSED_ON_GPU);</a>
<a name="ln1426">            pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_PROCESSED_ON_CPU | PIXELPIPE_FLOW_PROCESSED_WITH_TILING);</a>
<a name="ln1427">          }</a>
<a name="ln1428"> </a>
<a name="ln1429">          if(pipe-&gt;shutdown)</a>
<a name="ln1430">          {</a>
<a name="ln1431">            dt_opencl_release_mem_object(cl_mem_input);</a>
<a name="ln1432">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1433">            return 1;</a>
<a name="ln1434">          }</a>
<a name="ln1435"> </a>
<a name="ln1436">          // Lab color picking for module</a>
<a name="ln1437">          if(success_opencl &amp;&amp; dev-&gt;gui_attached &amp;&amp; pipe == dev-&gt;preview_pipe</a>
<a name="ln1438">             &amp;&amp;                           // pick from preview pipe to get pixels outside the viewport</a>
<a name="ln1439">             module == dev-&gt;gui_module &amp;&amp; // only modules with focus can pick</a>
<a name="ln1440">             module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF) // and they want to pick ;)</a>
<a name="ln1441">          {</a>
<a name="ln1442"> </a>
<a name="ln1443">            // we abuse the empty output buffer on host for intermediate storage of data in</a>
<a name="ln1444">            // pixelpipe_picker_cl()</a>
<a name="ln1445">            size_t outbufsize = roi_out-&gt;width * roi_out-&gt;height * bpp;</a>
<a name="ln1446"> </a>
<a name="ln1447">            pixelpipe_picker_cl(pipe-&gt;devid, module, &amp;piece-&gt;dsc_in, cl_mem_input, &amp;roi_in, module-&gt;picked_color,</a>
<a name="ln1448">                                module-&gt;picked_color_min, module-&gt;picked_color_max, *output, outbufsize,</a>
<a name="ln1449">                                PIXELPIPE_PICKER_INPUT);</a>
<a name="ln1450">            pixelpipe_picker_cl(pipe-&gt;devid, module, &amp;pipe-&gt;dsc, (*cl_mem_output), roi_out,</a>
<a name="ln1451">                                module-&gt;picked_output_color, module-&gt;picked_output_color_min,</a>
<a name="ln1452">                                module-&gt;picked_output_color_max, *output, outbufsize, PIXELPIPE_PICKER_OUTPUT);</a>
<a name="ln1453"> </a>
<a name="ln1454">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1455"> </a>
<a name="ln1456">            if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln1457"> </a>
<a name="ln1458">            dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1459">          }</a>
<a name="ln1460"> </a>
<a name="ln1461">          if(pipe-&gt;shutdown)</a>
<a name="ln1462">          {</a>
<a name="ln1463">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1464">            return 1;</a>
<a name="ln1465">          }</a>
<a name="ln1466"> </a>
<a name="ln1467">          /* process blending */</a>
<a name="ln1468">          if(success_opencl)</a>
<a name="ln1469">          {</a>
<a name="ln1470">            success_opencl</a>
<a name="ln1471">                = dt_develop_blend_process_cl(module, piece, cl_mem_input, *cl_mem_output, &amp;roi_in, roi_out);</a>
<a name="ln1472">            pixelpipe_flow |= (PIXELPIPE_FLOW_BLENDED_ON_GPU);</a>
<a name="ln1473">            pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_BLENDED_ON_CPU);</a>
<a name="ln1474">          }</a>
<a name="ln1475"> </a>
<a name="ln1476">          /* synchronization point for opencl pipe */</a>
<a name="ln1477">          if(success_opencl &amp;&amp; (!darktable.opencl-&gt;async_pixelpipe || pipe-&gt;type == DT_DEV_PIXELPIPE_EXPORT))</a>
<a name="ln1478">            success_opencl = dt_opencl_finish(pipe-&gt;devid);</a>
<a name="ln1479"> </a>
<a name="ln1480"> </a>
<a name="ln1481">          if(pipe-&gt;shutdown)</a>
<a name="ln1482">          {</a>
<a name="ln1483">            dt_opencl_release_mem_object(cl_mem_input);</a>
<a name="ln1484">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1485">            return 1;</a>
<a name="ln1486">          }</a>
<a name="ln1487">        }</a>
<a name="ln1488">        else if(piece-&gt;process_tiling_ready)</a>
<a name="ln1489">        {</a>
<a name="ln1490">          /* image is too big for direct opencl processing -&gt; try to process image via tiling */</a>
<a name="ln1491"> </a>
<a name="ln1492">          // fprintf(stderr, &quot;[opencl_pixelpipe 3] module '%s' tiling with process_tiling_cl\n&quot;, module-&gt;op);</a>
<a name="ln1493"> </a>
<a name="ln1494">          /* we might need to copy back valid image from device to host */</a>
<a name="ln1495">          if(cl_mem_input != NULL)</a>
<a name="ln1496">          {</a>
<a name="ln1497">            cl_int err;</a>
<a name="ln1498"> </a>
<a name="ln1499">            /* copy back to CPU buffer, then clean unneeded buffer */</a>
<a name="ln1500">            err = dt_opencl_copy_device_to_host(pipe-&gt;devid, input, cl_mem_input, roi_in.width, roi_in.height,</a>
<a name="ln1501">                                                in_bpp);</a>
<a name="ln1502">            if(err != CL_SUCCESS)</a>
<a name="ln1503">            {</a>
<a name="ln1504">              /* late opencl error */</a>
<a name="ln1505">              dt_print(</a>
<a name="ln1506">                  DT_DEBUG_OPENCL,</a>
<a name="ln1507">                  &quot;[opencl_pixelpipe (a)] late opencl error detected while copying back to cpu buffer: %d\n&quot;,</a>
<a name="ln1508">                  err);</a>
<a name="ln1509">              dt_opencl_release_mem_object(cl_mem_input);</a>
<a name="ln1510">              pipe-&gt;opencl_error = 1;</a>
<a name="ln1511">              dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1512">              return 1;</a>
<a name="ln1513">            }</a>
<a name="ln1514">            dt_opencl_release_mem_object(cl_mem_input);</a>
<a name="ln1515">            cl_mem_input = NULL;</a>
<a name="ln1516">            valid_input_on_gpu_only = FALSE;</a>
<a name="ln1517">          }</a>
<a name="ln1518"> </a>
<a name="ln1519">          if(pipe-&gt;shutdown)</a>
<a name="ln1520">          {</a>
<a name="ln1521">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1522">            return 1;</a>
<a name="ln1523">          }</a>
<a name="ln1524"> </a>
<a name="ln1525">          // indirectly give gpu some air to breathe (and to do display related stuff)</a>
<a name="ln1526">          dt_iop_nap(darktable.opencl-&gt;micro_nap);</a>
<a name="ln1527"> </a>
<a name="ln1528">          // histogram collection for module</a>
<a name="ln1529">          if(success_opencl &amp;&amp; (dev-&gt;gui_attached || !(piece-&gt;request_histogram &amp; DT_REQUEST_ONLY_IN_GUI))</a>
<a name="ln1530">             &amp;&amp; (piece-&gt;request_histogram &amp; DT_REQUEST_ON))</a>
<a name="ln1531">          {</a>
<a name="ln1532">            histogram_collect(piece, input, &amp;roi_in, &amp;(piece-&gt;histogram), piece-&gt;histogram_max);</a>
<a name="ln1533">            pixelpipe_flow |= (PIXELPIPE_FLOW_HISTOGRAM_ON_CPU);</a>
<a name="ln1534">            pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_HISTOGRAM_NONE | PIXELPIPE_FLOW_HISTOGRAM_ON_GPU);</a>
<a name="ln1535"> </a>
<a name="ln1536">            if(piece-&gt;histogram &amp;&amp; (module-&gt;request_histogram &amp; DT_REQUEST_ON)</a>
<a name="ln1537">               &amp;&amp; pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln1538">            {</a>
<a name="ln1539">              const size_t buf_size = 4 * piece-&gt;histogram_stats.bins_count * sizeof(uint32_t);</a>
<a name="ln1540">              module-&gt;histogram = realloc(module-&gt;histogram, buf_size);</a>
<a name="ln1541">              memcpy(module-&gt;histogram, piece-&gt;histogram, buf_size);</a>
<a name="ln1542">              module-&gt;histogram_stats = piece-&gt;histogram_stats;</a>
<a name="ln1543">              memcpy(module-&gt;histogram_max, piece-&gt;histogram_max, sizeof(piece-&gt;histogram_max));</a>
<a name="ln1544"> </a>
<a name="ln1545">              dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1546"> </a>
<a name="ln1547">              if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln1548"> </a>
<a name="ln1549">              dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1550">            }</a>
<a name="ln1551">          }</a>
<a name="ln1552"> </a>
<a name="ln1553">          if(pipe-&gt;shutdown)</a>
<a name="ln1554">          {</a>
<a name="ln1555">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1556">            return 1;</a>
<a name="ln1557">          }</a>
<a name="ln1558"> </a>
<a name="ln1559">          /* now call process_tiling_cl of module; module should emit meaningful messages in case of error */</a>
<a name="ln1560">          if(success_opencl)</a>
<a name="ln1561">          {</a>
<a name="ln1562">            success_opencl</a>
<a name="ln1563">                = module-&gt;process_tiling_cl(module, piece, input, *output, &amp;roi_in, roi_out, in_bpp);</a>
<a name="ln1564">            pixelpipe_flow |= (PIXELPIPE_FLOW_PROCESSED_ON_GPU | PIXELPIPE_FLOW_PROCESSED_WITH_TILING);</a>
<a name="ln1565">            pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_PROCESSED_ON_CPU);</a>
<a name="ln1566">          }</a>
<a name="ln1567"> </a>
<a name="ln1568">          if(pipe-&gt;shutdown)</a>
<a name="ln1569">          {</a>
<a name="ln1570">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1571">            return 1;</a>
<a name="ln1572">          }</a>
<a name="ln1573"> </a>
<a name="ln1574">          // Lab color picking for module</a>
<a name="ln1575">          if(success_opencl &amp;&amp; dev-&gt;gui_attached &amp;&amp; pipe == dev-&gt;preview_pipe</a>
<a name="ln1576">             &amp;&amp;                           // pick from preview pipe to get pixels outside the viewport</a>
<a name="ln1577">             module == dev-&gt;gui_module &amp;&amp; // only modules with focus can pick</a>
<a name="ln1578">             module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF) // and they want to pick ;)</a>
<a name="ln1579">          {</a>
<a name="ln1580">            pixelpipe_picker(module, &amp;piece-&gt;dsc_in, (float *)input, &amp;roi_in, module-&gt;picked_color,</a>
<a name="ln1581">                             module-&gt;picked_color_min, module-&gt;picked_color_max, PIXELPIPE_PICKER_INPUT);</a>
<a name="ln1582">            pixelpipe_picker(module, &amp;pipe-&gt;dsc, (float *)(*output), roi_out, module-&gt;picked_output_color,</a>
<a name="ln1583">                             module-&gt;picked_output_color_min, module-&gt;picked_output_color_max,</a>
<a name="ln1584">                             PIXELPIPE_PICKER_OUTPUT);</a>
<a name="ln1585"> </a>
<a name="ln1586">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1587"> </a>
<a name="ln1588">            if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln1589"> </a>
<a name="ln1590">            dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1591">          }</a>
<a name="ln1592"> </a>
<a name="ln1593">          if(pipe-&gt;shutdown)</a>
<a name="ln1594">          {</a>
<a name="ln1595">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1596">            return 1;</a>
<a name="ln1597">          }</a>
<a name="ln1598"> </a>
<a name="ln1599">          /* do process blending on cpu (this is anyhow fast enough) */</a>
<a name="ln1600">          if(success_opencl)</a>
<a name="ln1601">          {</a>
<a name="ln1602">            dt_develop_blend_process(module, piece, input, *output, &amp;roi_in, roi_out);</a>
<a name="ln1603">            pixelpipe_flow |= (PIXELPIPE_FLOW_BLENDED_ON_CPU);</a>
<a name="ln1604">            pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_BLENDED_ON_GPU);</a>
<a name="ln1605">          }</a>
<a name="ln1606"> </a>
<a name="ln1607">          /* synchronization point for opencl pipe */</a>
<a name="ln1608">          if(success_opencl &amp;&amp; (!darktable.opencl-&gt;async_pixelpipe || pipe-&gt;type == DT_DEV_PIXELPIPE_EXPORT))</a>
<a name="ln1609">            success_opencl = dt_opencl_finish(pipe-&gt;devid);</a>
<a name="ln1610"> </a>
<a name="ln1611">          if(pipe-&gt;shutdown)</a>
<a name="ln1612">          {</a>
<a name="ln1613">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1614">            return 1;</a>
<a name="ln1615">          }</a>
<a name="ln1616">        }</a>
<a name="ln1617">        else</a>
<a name="ln1618">        {</a>
<a name="ln1619">          /* image is too big for direct opencl and tiling is not allowed -&gt; no opencl processing for this</a>
<a name="ln1620">           * module */</a>
<a name="ln1621">          success_opencl = FALSE;</a>
<a name="ln1622">        }</a>
<a name="ln1623"> </a>
<a name="ln1624">        if(pipe-&gt;shutdown)</a>
<a name="ln1625">        {</a>
<a name="ln1626">          dt_opencl_release_mem_object(cl_mem_input);</a>
<a name="ln1627">          dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1628">          return 1;</a>
<a name="ln1629">        }</a>
<a name="ln1630"> </a>
<a name="ln1631">        // if (rand() % 20 == 0) success_opencl = FALSE; // Test code: simulate spurious failures</a>
<a name="ln1632"> </a>
<a name="ln1633">        /* finally check, if we were successful */</a>
<a name="ln1634">        if(success_opencl)</a>
<a name="ln1635">        {</a>
<a name="ln1636">          /* Nice, everything went fine */</a>
<a name="ln1637"> </a>
<a name="ln1638">          /* this is reasonable on slow GPUs only, where it's more expensive to reprocess the whole pixelpipe</a>
<a name="ln1639">             than</a>
<a name="ln1640">             regularly copying device buffers back to host. This would slow down fast GPUs considerably. */</a>
<a name="ln1641">          if(darktable.opencl-&gt;synch_cache)</a>
<a name="ln1642">          {</a>
<a name="ln1643">            /* write back input into cache for faster re-usal (not for export or thumbnails) */</a>
<a name="ln1644">            if(cl_mem_input != NULL &amp;&amp; pipe-&gt;type != DT_DEV_PIXELPIPE_EXPORT</a>
<a name="ln1645">               &amp;&amp; pipe-&gt;type != DT_DEV_PIXELPIPE_THUMBNAIL)</a>
<a name="ln1646">            {</a>
<a name="ln1647">              cl_int err;</a>
<a name="ln1648"> </a>
<a name="ln1649">              /* copy input to host memory, so we can find it in cache */</a>
<a name="ln1650">              err = dt_opencl_copy_device_to_host(pipe-&gt;devid, input, cl_mem_input, roi_in.width,</a>
<a name="ln1651">                                                  roi_in.height, in_bpp);</a>
<a name="ln1652">              if(err != CL_SUCCESS)</a>
<a name="ln1653">              {</a>
<a name="ln1654">                /* late opencl error, not likely to happen here */</a>
<a name="ln1655">                dt_print(DT_DEBUG_OPENCL, &quot;[opencl_pixelpipe (e)] late opencl error detected while copying &quot;</a>
<a name="ln1656">                                          &quot;back to cpu buffer: %d\n&quot;,</a>
<a name="ln1657">                         err);</a>
<a name="ln1658">                /* that's all we do here, we later make sure to invalidate cache line */</a>
<a name="ln1659">              }</a>
<a name="ln1660">              else</a>
<a name="ln1661">              {</a>
<a name="ln1662">                /* success: cache line is valid now, so we will not need to invalidate it later */</a>
<a name="ln1663">                valid_input_on_gpu_only = FALSE;</a>
<a name="ln1664"> </a>
<a name="ln1665">                // TODO: check if we need to wait for finished opencl pipe before we release cl_mem_input</a>
<a name="ln1666">                // dt_dev_finish(pipe-&gt;devid);</a>
<a name="ln1667">              }</a>
<a name="ln1668">            }</a>
<a name="ln1669"> </a>
<a name="ln1670">            if(pipe-&gt;shutdown)</a>
<a name="ln1671">            {</a>
<a name="ln1672">              dt_opencl_release_mem_object(cl_mem_input);</a>
<a name="ln1673">              dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1674">              return 1;</a>
<a name="ln1675">            }</a>
<a name="ln1676">          }</a>
<a name="ln1677"> </a>
<a name="ln1678">          /* we can now release cl_mem_input */</a>
<a name="ln1679">          dt_opencl_release_mem_object(cl_mem_input);</a>
<a name="ln1680">          cl_mem_input = NULL;</a>
<a name="ln1681">          // we speculate on the next plug-in to possibly copy back cl_mem_output to output,</a>
<a name="ln1682">          // so we're not just yet invalidating the (empty) output cache line.</a>
<a name="ln1683">        }</a>
<a name="ln1684">        else</a>
<a name="ln1685">        {</a>
<a name="ln1686">          /* Bad luck, opencl failed. Let's clean up and fall back to cpu module */</a>
<a name="ln1687">          dt_print(DT_DEBUG_OPENCL, &quot;[opencl_pixelpipe] could not run module '%s' on gpu. falling back to cpu path\n&quot;,</a>
<a name="ln1688">                   module-&gt;op);</a>
<a name="ln1689"> </a>
<a name="ln1690">          // fprintf(stderr, &quot;[opencl_pixelpipe 4] module '%s' running on cpu\n&quot;, module-&gt;op);</a>
<a name="ln1691"> </a>
<a name="ln1692">          /* we might need to free unused output buffer */</a>
<a name="ln1693">          if(*cl_mem_output != NULL)</a>
<a name="ln1694">          {</a>
<a name="ln1695">            dt_opencl_release_mem_object(*cl_mem_output);</a>
<a name="ln1696">            *cl_mem_output = NULL;</a>
<a name="ln1697">          }</a>
<a name="ln1698"> </a>
<a name="ln1699">          /* check where our input buffer is located */</a>
<a name="ln1700">          if(cl_mem_input != NULL)</a>
<a name="ln1701">          {</a>
<a name="ln1702">            cl_int err;</a>
<a name="ln1703"> </a>
<a name="ln1704">            /* copy back to host memory, then clean no longer needed opencl buffer.</a>
<a name="ln1705">               important info: in order to make this possible, opencl modules must</a>
<a name="ln1706">               not spoil their input buffer, even in case of errors. */</a>
<a name="ln1707">            err = dt_opencl_copy_device_to_host(pipe-&gt;devid, input, cl_mem_input, roi_in.width, roi_in.height,</a>
<a name="ln1708">                                                in_bpp);</a>
<a name="ln1709">            if(err != CL_SUCCESS)</a>
<a name="ln1710">            {</a>
<a name="ln1711">              /* late opencl error */</a>
<a name="ln1712">              dt_print(</a>
<a name="ln1713">                  DT_DEBUG_OPENCL,</a>
<a name="ln1714">                  &quot;[opencl_pixelpipe (b)] late opencl error detected while copying back to cpu buffer: %d\n&quot;,</a>
<a name="ln1715">                  err);</a>
<a name="ln1716">              dt_opencl_release_mem_object(cl_mem_input);</a>
<a name="ln1717">              pipe-&gt;opencl_error = 1;</a>
<a name="ln1718">              dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1719">              return 1;</a>
<a name="ln1720">            }</a>
<a name="ln1721"> </a>
<a name="ln1722">            /* this is a good place to release event handles as we anyhow need to move from gpu to cpu here */</a>
<a name="ln1723">            (void)dt_opencl_finish(pipe-&gt;devid);</a>
<a name="ln1724">            dt_opencl_release_mem_object(cl_mem_input);</a>
<a name="ln1725">            valid_input_on_gpu_only = FALSE;</a>
<a name="ln1726">          }</a>
<a name="ln1727"> </a>
<a name="ln1728">          if(pipe-&gt;shutdown)</a>
<a name="ln1729">          {</a>
<a name="ln1730">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1731">            return 1;</a>
<a name="ln1732">          }</a>
<a name="ln1733"> </a>
<a name="ln1734">          // histogram collection for module</a>
<a name="ln1735">          if((dev-&gt;gui_attached || !(piece-&gt;request_histogram &amp; DT_REQUEST_ONLY_IN_GUI))</a>
<a name="ln1736">             &amp;&amp; (piece-&gt;request_histogram &amp; DT_REQUEST_ON))</a>
<a name="ln1737">          {</a>
<a name="ln1738">            histogram_collect(piece, input, &amp;roi_in, &amp;(piece-&gt;histogram), piece-&gt;histogram_max);</a>
<a name="ln1739">            pixelpipe_flow |= (PIXELPIPE_FLOW_HISTOGRAM_ON_CPU);</a>
<a name="ln1740">            pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_HISTOGRAM_NONE | PIXELPIPE_FLOW_HISTOGRAM_ON_GPU);</a>
<a name="ln1741"> </a>
<a name="ln1742">            if(piece-&gt;histogram &amp;&amp; (module-&gt;request_histogram &amp; DT_REQUEST_ON)</a>
<a name="ln1743">               &amp;&amp; pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln1744">            {</a>
<a name="ln1745">              const size_t buf_size = 4 * piece-&gt;histogram_stats.bins_count * sizeof(uint32_t);</a>
<a name="ln1746">              module-&gt;histogram = realloc(module-&gt;histogram, buf_size);</a>
<a name="ln1747">              memcpy(module-&gt;histogram, piece-&gt;histogram, buf_size);</a>
<a name="ln1748">              module-&gt;histogram_stats = piece-&gt;histogram_stats;</a>
<a name="ln1749">              memcpy(module-&gt;histogram_max, piece-&gt;histogram_max, sizeof(piece-&gt;histogram_max));</a>
<a name="ln1750"> </a>
<a name="ln1751">              dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1752"> </a>
<a name="ln1753">              if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln1754"> </a>
<a name="ln1755">              dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1756">            }</a>
<a name="ln1757">          }</a>
<a name="ln1758"> </a>
<a name="ln1759">          if(pipe-&gt;shutdown)</a>
<a name="ln1760">          {</a>
<a name="ln1761">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1762">            return 1;</a>
<a name="ln1763">          }</a>
<a name="ln1764"> </a>
<a name="ln1765">          /* process module on cpu. use tiling if needed and possible. */</a>
<a name="ln1766">          if(piece-&gt;process_tiling_ready</a>
<a name="ln1767">             &amp;&amp; !dt_tiling_piece_fits_host_memory(MAX(roi_in.width, roi_out-&gt;width),</a>
<a name="ln1768">                                                  MAX(roi_in.height, roi_out-&gt;height), MAX(in_bpp, bpp),</a>
<a name="ln1769">                                                  tiling.factor, tiling.overhead))</a>
<a name="ln1770">          {</a>
<a name="ln1771">            module-&gt;process_tiling(module, piece, input, *output, &amp;roi_in, roi_out, in_bpp);</a>
<a name="ln1772">            pixelpipe_flow |= (PIXELPIPE_FLOW_PROCESSED_ON_CPU | PIXELPIPE_FLOW_PROCESSED_WITH_TILING);</a>
<a name="ln1773">            pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_PROCESSED_ON_GPU);</a>
<a name="ln1774">          }</a>
<a name="ln1775">          else</a>
<a name="ln1776">          {</a>
<a name="ln1777">            module-&gt;process(module, piece, input, *output, &amp;roi_in, roi_out);</a>
<a name="ln1778">            pixelpipe_flow |= (PIXELPIPE_FLOW_PROCESSED_ON_CPU);</a>
<a name="ln1779">            pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_PROCESSED_ON_GPU | PIXELPIPE_FLOW_PROCESSED_WITH_TILING);</a>
<a name="ln1780">          }</a>
<a name="ln1781"> </a>
<a name="ln1782">          if(pipe-&gt;shutdown)</a>
<a name="ln1783">          {</a>
<a name="ln1784">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1785">            return 1;</a>
<a name="ln1786">          }</a>
<a name="ln1787"> </a>
<a name="ln1788">          // Lab color picking for module</a>
<a name="ln1789">          if(dev-&gt;gui_attached &amp;&amp; pipe == dev-&gt;preview_pipe</a>
<a name="ln1790">             &amp;&amp;                           // pick from preview pipe to get pixels outside the viewport</a>
<a name="ln1791">             module == dev-&gt;gui_module &amp;&amp; // only modules with focus can pick</a>
<a name="ln1792">             module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF) // and they want to pick ;)</a>
<a name="ln1793">          {</a>
<a name="ln1794">            pixelpipe_picker(module, &amp;piece-&gt;dsc_in, (float *)input, &amp;roi_in, module-&gt;picked_color,</a>
<a name="ln1795">                             module-&gt;picked_color_min, module-&gt;picked_color_max, PIXELPIPE_PICKER_INPUT);</a>
<a name="ln1796">            pixelpipe_picker(module, &amp;pipe-&gt;dsc, (float *)(*output), roi_out, module-&gt;picked_output_color,</a>
<a name="ln1797">                             module-&gt;picked_output_color_min, module-&gt;picked_output_color_max,</a>
<a name="ln1798">                             PIXELPIPE_PICKER_OUTPUT);</a>
<a name="ln1799"> </a>
<a name="ln1800">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1801"> </a>
<a name="ln1802">            if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln1803"> </a>
<a name="ln1804">            dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1805">          }</a>
<a name="ln1806"> </a>
<a name="ln1807">          if(pipe-&gt;shutdown)</a>
<a name="ln1808">          {</a>
<a name="ln1809">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1810">            return 1;</a>
<a name="ln1811">          }</a>
<a name="ln1812"> </a>
<a name="ln1813">          /* process blending on cpu */</a>
<a name="ln1814">          dt_develop_blend_process(module, piece, input, *output, &amp;roi_in, roi_out);</a>
<a name="ln1815">          pixelpipe_flow |= (PIXELPIPE_FLOW_BLENDED_ON_CPU);</a>
<a name="ln1816">          pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_BLENDED_ON_GPU);</a>
<a name="ln1817">        }</a>
<a name="ln1818"> </a>
<a name="ln1819">        if(pipe-&gt;shutdown)</a>
<a name="ln1820">        {</a>
<a name="ln1821">          dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1822">          return 1;</a>
<a name="ln1823">        }</a>
<a name="ln1824">      }</a>
<a name="ln1825">      else</a>
<a name="ln1826">      {</a>
<a name="ln1827">        /* we are not allowed to use opencl for this module */</a>
<a name="ln1828"> </a>
<a name="ln1829">        // fprintf(stderr, &quot;[opencl_pixelpipe 3] for module `%s', have bufs %p and %p \n&quot;, module-&gt;op,</a>
<a name="ln1830">        // cl_mem_input, *cl_mem_output);</a>
<a name="ln1831"> </a>
<a name="ln1832">        *cl_mem_output = NULL;</a>
<a name="ln1833"> </a>
<a name="ln1834">        /* cleanup unneeded opencl buffer, and copy back to CPU buffer */</a>
<a name="ln1835">        if(cl_mem_input != NULL)</a>
<a name="ln1836">        {</a>
<a name="ln1837">          cl_int err;</a>
<a name="ln1838"> </a>
<a name="ln1839">          err = dt_opencl_copy_device_to_host(pipe-&gt;devid, input, cl_mem_input, roi_in.width, roi_in.height,</a>
<a name="ln1840">                                              in_bpp);</a>
<a name="ln1841">          // if (rand() % 5 == 0) err = !CL_SUCCESS; // Test code: simulate spurious failures</a>
<a name="ln1842">          if(err != CL_SUCCESS)</a>
<a name="ln1843">          {</a>
<a name="ln1844">            /* late opencl error */</a>
<a name="ln1845">            dt_print(</a>
<a name="ln1846">                DT_DEBUG_OPENCL,</a>
<a name="ln1847">                &quot;[opencl_pixelpipe (c)] late opencl error detected while copying back to cpu buffer: %d\n&quot;,</a>
<a name="ln1848">                err);</a>
<a name="ln1849">            dt_opencl_release_mem_object(cl_mem_input);</a>
<a name="ln1850">            pipe-&gt;opencl_error = 1;</a>
<a name="ln1851">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1852">            return 1;</a>
<a name="ln1853">          }</a>
<a name="ln1854"> </a>
<a name="ln1855">          /* this is a good place to release event handles as we anyhow need to move from gpu to cpu here */</a>
<a name="ln1856">          (void)dt_opencl_finish(pipe-&gt;devid);</a>
<a name="ln1857">          dt_opencl_release_mem_object(cl_mem_input);</a>
<a name="ln1858">          valid_input_on_gpu_only = FALSE;</a>
<a name="ln1859">        }</a>
<a name="ln1860"> </a>
<a name="ln1861">        if(pipe-&gt;shutdown)</a>
<a name="ln1862">        {</a>
<a name="ln1863">          dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1864">          return 1;</a>
<a name="ln1865">        }</a>
<a name="ln1866"> </a>
<a name="ln1867">        // histogram collection for module</a>
<a name="ln1868">        if((dev-&gt;gui_attached || !(piece-&gt;request_histogram &amp; DT_REQUEST_ONLY_IN_GUI))</a>
<a name="ln1869">           &amp;&amp; (piece-&gt;request_histogram &amp; DT_REQUEST_ON))</a>
<a name="ln1870">        {</a>
<a name="ln1871">          histogram_collect(piece, input, &amp;roi_in, &amp;(piece-&gt;histogram), piece-&gt;histogram_max);</a>
<a name="ln1872">          pixelpipe_flow |= (PIXELPIPE_FLOW_HISTOGRAM_ON_CPU);</a>
<a name="ln1873">          pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_HISTOGRAM_NONE | PIXELPIPE_FLOW_HISTOGRAM_ON_GPU);</a>
<a name="ln1874"> </a>
<a name="ln1875">          if(piece-&gt;histogram &amp;&amp; (module-&gt;request_histogram &amp; DT_REQUEST_ON)</a>
<a name="ln1876">             &amp;&amp; pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln1877">          {</a>
<a name="ln1878">            const size_t buf_size = 4 * piece-&gt;histogram_stats.bins_count * sizeof(uint32_t);</a>
<a name="ln1879">            module-&gt;histogram = realloc(module-&gt;histogram, buf_size);</a>
<a name="ln1880">            memcpy(module-&gt;histogram, piece-&gt;histogram, buf_size);</a>
<a name="ln1881">            module-&gt;histogram_stats = piece-&gt;histogram_stats;</a>
<a name="ln1882">            memcpy(module-&gt;histogram_max, piece-&gt;histogram_max, sizeof(piece-&gt;histogram_max));</a>
<a name="ln1883"> </a>
<a name="ln1884">            dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1885"> </a>
<a name="ln1886">            if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln1887"> </a>
<a name="ln1888">            dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1889">          }</a>
<a name="ln1890">        }</a>
<a name="ln1891"> </a>
<a name="ln1892">        if(pipe-&gt;shutdown)</a>
<a name="ln1893">        {</a>
<a name="ln1894">          dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1895">          return 1;</a>
<a name="ln1896">        }</a>
<a name="ln1897"> </a>
<a name="ln1898">        /* process module on cpu. use tiling if needed and possible. */</a>
<a name="ln1899">        if(piece-&gt;process_tiling_ready</a>
<a name="ln1900">           &amp;&amp; !dt_tiling_piece_fits_host_memory(MAX(roi_in.width, roi_out-&gt;width),</a>
<a name="ln1901">                                                MAX(roi_in.height, roi_out-&gt;height), MAX(in_bpp, bpp),</a>
<a name="ln1902">                                                tiling.factor, tiling.overhead))</a>
<a name="ln1903">        {</a>
<a name="ln1904">          module-&gt;process_tiling(module, piece, input, *output, &amp;roi_in, roi_out, in_bpp);</a>
<a name="ln1905">          pixelpipe_flow |= (PIXELPIPE_FLOW_PROCESSED_ON_CPU | PIXELPIPE_FLOW_PROCESSED_WITH_TILING);</a>
<a name="ln1906">          pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_PROCESSED_ON_GPU);</a>
<a name="ln1907">        }</a>
<a name="ln1908">        else</a>
<a name="ln1909">        {</a>
<a name="ln1910">          module-&gt;process(module, piece, input, *output, &amp;roi_in, roi_out);</a>
<a name="ln1911">          pixelpipe_flow |= (PIXELPIPE_FLOW_PROCESSED_ON_CPU);</a>
<a name="ln1912">          pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_PROCESSED_ON_GPU | PIXELPIPE_FLOW_PROCESSED_WITH_TILING);</a>
<a name="ln1913">        }</a>
<a name="ln1914"> </a>
<a name="ln1915">        if(pipe-&gt;shutdown)</a>
<a name="ln1916">        {</a>
<a name="ln1917">          dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1918">          return 1;</a>
<a name="ln1919">        }</a>
<a name="ln1920"> </a>
<a name="ln1921">        // Lab color picking for module</a>
<a name="ln1922">        if(dev-&gt;gui_attached &amp;&amp; pipe == dev-&gt;preview_pipe</a>
<a name="ln1923">           &amp;&amp;                           // pick from preview pipe to get pixels outside the viewport</a>
<a name="ln1924">           module == dev-&gt;gui_module &amp;&amp; // only modules with focus can pick</a>
<a name="ln1925">           module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF) // and they want to pick ;)</a>
<a name="ln1926">        {</a>
<a name="ln1927">          pixelpipe_picker(module, &amp;piece-&gt;dsc_in, (float *)input, &amp;roi_in, module-&gt;picked_color,</a>
<a name="ln1928">                           module-&gt;picked_color_min, module-&gt;picked_color_max, PIXELPIPE_PICKER_INPUT);</a>
<a name="ln1929">          pixelpipe_picker(module, &amp;pipe-&gt;dsc, (float *)(*output), roi_out, module-&gt;picked_output_color,</a>
<a name="ln1930">                           module-&gt;picked_output_color_min, module-&gt;picked_output_color_max,</a>
<a name="ln1931">                           PIXELPIPE_PICKER_OUTPUT);</a>
<a name="ln1932"> </a>
<a name="ln1933">          dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1934"> </a>
<a name="ln1935">          if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln1936"> </a>
<a name="ln1937">          dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1938">        }</a>
<a name="ln1939"> </a>
<a name="ln1940">        if(pipe-&gt;shutdown)</a>
<a name="ln1941">        {</a>
<a name="ln1942">          dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1943">          return 1;</a>
<a name="ln1944">        }</a>
<a name="ln1945"> </a>
<a name="ln1946">        /* process blending */</a>
<a name="ln1947">        dt_develop_blend_process(module, piece, input, *output, &amp;roi_in, roi_out);</a>
<a name="ln1948">        pixelpipe_flow |= (PIXELPIPE_FLOW_BLENDED_ON_CPU);</a>
<a name="ln1949">        pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_BLENDED_ON_GPU);</a>
<a name="ln1950"> </a>
<a name="ln1951">        if(pipe-&gt;shutdown)</a>
<a name="ln1952">        {</a>
<a name="ln1953">          dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1954">          return 1;</a>
<a name="ln1955">        }</a>
<a name="ln1956">      }</a>
<a name="ln1957"> </a>
<a name="ln1958">      /* input is still only on GPU? Let's invalidate CPU input buffer then */</a>
<a name="ln1959">      if(valid_input_on_gpu_only) dt_dev_pixelpipe_cache_invalidate(&amp;(pipe-&gt;cache), input);</a>
<a name="ln1960">    }</a>
<a name="ln1961">    else</a>
<a name="ln1962">    {</a>
<a name="ln1963">      /* opencl is not inited or not enabled or we got no resource/device -&gt; everything runs on cpu */</a>
<a name="ln1964"> </a>
<a name="ln1965">      // histogram collection for module</a>
<a name="ln1966">      if((dev-&gt;gui_attached || !(piece-&gt;request_histogram &amp; DT_REQUEST_ONLY_IN_GUI))</a>
<a name="ln1967">         &amp;&amp; (piece-&gt;request_histogram &amp; DT_REQUEST_ON))</a>
<a name="ln1968">      {</a>
<a name="ln1969">        histogram_collect(piece, input, &amp;roi_in, &amp;(piece-&gt;histogram), piece-&gt;histogram_max);</a>
<a name="ln1970">        pixelpipe_flow |= (PIXELPIPE_FLOW_HISTOGRAM_ON_CPU);</a>
<a name="ln1971">        pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_HISTOGRAM_NONE | PIXELPIPE_FLOW_HISTOGRAM_ON_GPU);</a>
<a name="ln1972"> </a>
<a name="ln1973">        if(piece-&gt;histogram &amp;&amp; (module-&gt;request_histogram &amp; DT_REQUEST_ON)</a>
<a name="ln1974">           &amp;&amp; pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln1975">        {</a>
<a name="ln1976">          const size_t buf_size = 4 * piece-&gt;histogram_stats.bins_count * sizeof(uint32_t);</a>
<a name="ln1977">          module-&gt;histogram = realloc(module-&gt;histogram, buf_size);</a>
<a name="ln1978">          memcpy(module-&gt;histogram, piece-&gt;histogram, buf_size);</a>
<a name="ln1979">          module-&gt;histogram_stats = piece-&gt;histogram_stats;</a>
<a name="ln1980">          memcpy(module-&gt;histogram_max, piece-&gt;histogram_max, sizeof(piece-&gt;histogram_max));</a>
<a name="ln1981"> </a>
<a name="ln1982">          dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1983"> </a>
<a name="ln1984">          if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln1985"> </a>
<a name="ln1986">          dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1987">        }</a>
<a name="ln1988">      }</a>
<a name="ln1989"> </a>
<a name="ln1990">      if(pipe-&gt;shutdown)</a>
<a name="ln1991">      {</a>
<a name="ln1992">        dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln1993">        return 1;</a>
<a name="ln1994">      }</a>
<a name="ln1995"> </a>
<a name="ln1996">      /* process module on cpu. use tiling if needed and possible. */</a>
<a name="ln1997">      if(piece-&gt;process_tiling_ready</a>
<a name="ln1998">         &amp;&amp; !dt_tiling_piece_fits_host_memory(MAX(roi_in.width, roi_out-&gt;width),</a>
<a name="ln1999">                                              MAX(roi_in.height, roi_out-&gt;height), MAX(in_bpp, bpp),</a>
<a name="ln2000">                                              tiling.factor, tiling.overhead))</a>
<a name="ln2001">      {</a>
<a name="ln2002">        module-&gt;process_tiling(module, piece, input, *output, &amp;roi_in, roi_out, in_bpp);</a>
<a name="ln2003">        pixelpipe_flow |= (PIXELPIPE_FLOW_PROCESSED_ON_CPU | PIXELPIPE_FLOW_PROCESSED_WITH_TILING);</a>
<a name="ln2004">        pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_PROCESSED_ON_GPU);</a>
<a name="ln2005">      }</a>
<a name="ln2006">      else</a>
<a name="ln2007">      {</a>
<a name="ln2008">        module-&gt;process(module, piece, input, *output, &amp;roi_in, roi_out);</a>
<a name="ln2009">        pixelpipe_flow |= (PIXELPIPE_FLOW_PROCESSED_ON_CPU);</a>
<a name="ln2010">        pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_PROCESSED_ON_GPU | PIXELPIPE_FLOW_PROCESSED_WITH_TILING);</a>
<a name="ln2011">      }</a>
<a name="ln2012"> </a>
<a name="ln2013">      if(pipe-&gt;shutdown)</a>
<a name="ln2014">      {</a>
<a name="ln2015">        dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2016">        return 1;</a>
<a name="ln2017">      }</a>
<a name="ln2018"> </a>
<a name="ln2019">      // Lab color picking for module</a>
<a name="ln2020">      if(dev-&gt;gui_attached &amp;&amp; pipe == dev-&gt;preview_pipe</a>
<a name="ln2021">         &amp;&amp;                           // pick from preview pipe to get pixels outside the viewport</a>
<a name="ln2022">         module == dev-&gt;gui_module &amp;&amp; // only modules with focus can pick</a>
<a name="ln2023">         module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF) // and they want to pick ;)</a>
<a name="ln2024">      {</a>
<a name="ln2025">        pixelpipe_picker(module, &amp;piece-&gt;dsc_in, (float *)input, &amp;roi_in, module-&gt;picked_color,</a>
<a name="ln2026">                         module-&gt;picked_color_min, module-&gt;picked_color_max, PIXELPIPE_PICKER_INPUT);</a>
<a name="ln2027">        pixelpipe_picker(module, &amp;pipe-&gt;dsc, (float *)(*output), roi_out, module-&gt;picked_output_color,</a>
<a name="ln2028">                         module-&gt;picked_output_color_min, module-&gt;picked_output_color_max,</a>
<a name="ln2029">                         PIXELPIPE_PICKER_OUTPUT);</a>
<a name="ln2030"> </a>
<a name="ln2031">        dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2032"> </a>
<a name="ln2033">        if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln2034"> </a>
<a name="ln2035">        dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2036">      }</a>
<a name="ln2037"> </a>
<a name="ln2038">      if(pipe-&gt;shutdown)</a>
<a name="ln2039">      {</a>
<a name="ln2040">        dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2041">        return 1;</a>
<a name="ln2042">      }</a>
<a name="ln2043"> </a>
<a name="ln2044">      /* process blending */</a>
<a name="ln2045">      dt_develop_blend_process(module, piece, input, *output, &amp;roi_in, roi_out);</a>
<a name="ln2046">      pixelpipe_flow |= (PIXELPIPE_FLOW_BLENDED_ON_CPU);</a>
<a name="ln2047">      pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_BLENDED_ON_GPU);</a>
<a name="ln2048">    }</a>
<a name="ln2049">#else // HAVE_OPENCL</a>
<a name="ln2050">    // histogram collection for module</a>
<a name="ln2051">    if((dev-&gt;gui_attached || !(piece-&gt;request_histogram &amp; DT_REQUEST_ONLY_IN_GUI))</a>
<a name="ln2052">       &amp;&amp; (piece-&gt;request_histogram &amp; DT_REQUEST_ON))</a>
<a name="ln2053">    {</a>
<a name="ln2054">      histogram_collect(piece, (float *)input, &amp;roi_in, &amp;(piece-&gt;histogram), piece-&gt;histogram_max);</a>
<a name="ln2055">      pixelpipe_flow |= (PIXELPIPE_FLOW_HISTOGRAM_ON_CPU);</a>
<a name="ln2056">      pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_HISTOGRAM_NONE | PIXELPIPE_FLOW_HISTOGRAM_ON_GPU);</a>
<a name="ln2057"> </a>
<a name="ln2058">      if(piece-&gt;histogram &amp;&amp; (module-&gt;request_histogram &amp; DT_REQUEST_ON)</a>
<a name="ln2059">         &amp;&amp; pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln2060">      {</a>
<a name="ln2061">        const size_t buf_size = 4 * piece-&gt;histogram_stats.bins_count * sizeof(uint32_t);</a>
<a name="ln2062">        module-&gt;histogram = realloc(module-&gt;histogram, buf_size);</a>
<a name="ln2063">        memcpy(module-&gt;histogram, piece-&gt;histogram, buf_size);</a>
<a name="ln2064">        module-&gt;histogram_stats = piece-&gt;histogram_stats;</a>
<a name="ln2065">        memcpy(module-&gt;histogram_max, piece-&gt;histogram_max, sizeof(piece-&gt;histogram_max));</a>
<a name="ln2066"> </a>
<a name="ln2067">        dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2068"> </a>
<a name="ln2069">        if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln2070"> </a>
<a name="ln2071">        dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2072">      }</a>
<a name="ln2073">    }</a>
<a name="ln2074"> </a>
<a name="ln2075">    if(pipe-&gt;shutdown)</a>
<a name="ln2076">    {</a>
<a name="ln2077">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2078">      return 1;</a>
<a name="ln2079">    }</a>
<a name="ln2080"> </a>
<a name="ln2081">    /* process module on cpu. use tiling if needed and possible. */</a>
<a name="ln2082">    if(piece-&gt;process_tiling_ready</a>
<a name="ln2083">       &amp;&amp; !dt_tiling_piece_fits_host_memory(MAX(roi_in.width, roi_out-&gt;width),</a>
<a name="ln2084">                                            MAX(roi_in.height, roi_out-&gt;height), MAX(in_bpp, bpp),</a>
<a name="ln2085">                                            tiling.factor, tiling.overhead))</a>
<a name="ln2086">    {</a>
<a name="ln2087">      module-&gt;process_tiling(module, piece, input, *output, &amp;roi_in, roi_out, in_bpp);</a>
<a name="ln2088">      pixelpipe_flow |= (PIXELPIPE_FLOW_PROCESSED_ON_CPU | PIXELPIPE_FLOW_PROCESSED_WITH_TILING);</a>
<a name="ln2089">      pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_PROCESSED_ON_GPU);</a>
<a name="ln2090">    }</a>
<a name="ln2091">    else</a>
<a name="ln2092">    {</a>
<a name="ln2093">      module-&gt;process(module, piece, input, *output, &amp;roi_in, roi_out);</a>
<a name="ln2094">      pixelpipe_flow |= (PIXELPIPE_FLOW_PROCESSED_ON_CPU);</a>
<a name="ln2095">      pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_PROCESSED_ON_GPU | PIXELPIPE_FLOW_PROCESSED_WITH_TILING);</a>
<a name="ln2096">    }</a>
<a name="ln2097"> </a>
<a name="ln2098">    if(pipe-&gt;shutdown)</a>
<a name="ln2099">    {</a>
<a name="ln2100">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2101">      return 1;</a>
<a name="ln2102">    }</a>
<a name="ln2103"> </a>
<a name="ln2104">    // Lab color picking for module</a>
<a name="ln2105">    if(dev-&gt;gui_attached &amp;&amp; pipe == dev-&gt;preview_pipe</a>
<a name="ln2106">       &amp;&amp;                           // pick from preview pipe to get pixels outside the viewport</a>
<a name="ln2107">       module == dev-&gt;gui_module &amp;&amp; // only modules with focus can pick</a>
<a name="ln2108">       module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF) // and they want to pick ;)</a>
<a name="ln2109">    {</a>
<a name="ln2110">      pixelpipe_picker(module, &amp;piece-&gt;dsc_in, (float *)input, &amp;roi_in, module-&gt;picked_color,</a>
<a name="ln2111">                       module-&gt;picked_color_min, module-&gt;picked_color_max, PIXELPIPE_PICKER_INPUT);</a>
<a name="ln2112">      pixelpipe_picker(module, &amp;pipe-&gt;dsc, (float *)(*output), roi_out, module-&gt;picked_output_color,</a>
<a name="ln2113">                       module-&gt;picked_output_color_min, module-&gt;picked_output_color_max, PIXELPIPE_PICKER_OUTPUT);</a>
<a name="ln2114"> </a>
<a name="ln2115">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2116"> </a>
<a name="ln2117">      if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln2118"> </a>
<a name="ln2119">      dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2120">    }</a>
<a name="ln2121"> </a>
<a name="ln2122">    if(pipe-&gt;shutdown)</a>
<a name="ln2123">    {</a>
<a name="ln2124">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2125">      return 1;</a>
<a name="ln2126">    }</a>
<a name="ln2127"> </a>
<a name="ln2128">    /* process blending */</a>
<a name="ln2129">    dt_develop_blend_process(module, piece, input, *output, &amp;roi_in, roi_out);</a>
<a name="ln2130">    pixelpipe_flow |= (PIXELPIPE_FLOW_BLENDED_ON_CPU);</a>
<a name="ln2131">    pixelpipe_flow &amp;= ~(PIXELPIPE_FLOW_BLENDED_ON_GPU);</a>
<a name="ln2132">#endif // HAVE_OPENCL</a>
<a name="ln2133"> </a>
<a name="ln2134">    char histogram_log[32] = &quot;&quot;;</a>
<a name="ln2135">    if(!(pixelpipe_flow &amp; PIXELPIPE_FLOW_HISTOGRAM_NONE))</a>
<a name="ln2136">    {</a>
<a name="ln2137">      snprintf(histogram_log, sizeof(histogram_log), &quot;, collected histogram on %s&quot;,</a>
<a name="ln2138">               (pixelpipe_flow &amp; PIXELPIPE_FLOW_HISTOGRAM_ON_GPU</a>
<a name="ln2139">                    ? &quot;GPU&quot;</a>
<a name="ln2140">                    : pixelpipe_flow &amp; PIXELPIPE_FLOW_HISTOGRAM_ON_CPU ? &quot;CPU&quot; : &quot;&quot;));</a>
<a name="ln2141">    }</a>
<a name="ln2142"> </a>
<a name="ln2143">    gchar *module_label = dt_history_item_get_name(module);</a>
<a name="ln2144">    dt_show_times(</a>
<a name="ln2145">        &amp;start, &quot;[dev_pixelpipe]&quot;, &quot;processed `%s' on %s%s%s, blended on %s [%s]&quot;, module_label,</a>
<a name="ln2146">        pixelpipe_flow &amp; PIXELPIPE_FLOW_PROCESSED_ON_GPU</a>
<a name="ln2147">            ? &quot;GPU&quot;</a>
<a name="ln2148">            : pixelpipe_flow &amp; PIXELPIPE_FLOW_PROCESSED_ON_CPU ? &quot;CPU&quot; : &quot;&quot;,</a>
<a name="ln2149">        pixelpipe_flow &amp; PIXELPIPE_FLOW_PROCESSED_WITH_TILING ? &quot; with tiling&quot; : &quot;&quot;,</a>
<a name="ln2150">        (!(pixelpipe_flow &amp; PIXELPIPE_FLOW_HISTOGRAM_NONE) &amp;&amp; (piece-&gt;request_histogram &amp; DT_REQUEST_ON))</a>
<a name="ln2151">            ? histogram_log</a>
<a name="ln2152">            : &quot;&quot;,</a>
<a name="ln2153">        pixelpipe_flow &amp; PIXELPIPE_FLOW_BLENDED_ON_GPU</a>
<a name="ln2154">            ? &quot;GPU&quot;</a>
<a name="ln2155">            : pixelpipe_flow &amp; PIXELPIPE_FLOW_BLENDED_ON_CPU ? &quot;CPU&quot; : &quot;&quot;,</a>
<a name="ln2156">        _pipe_type_to_str(pipe-&gt;type));</a>
<a name="ln2157">    g_free(module_label);</a>
<a name="ln2158">    module_label = NULL;</a>
<a name="ln2159"> </a>
<a name="ln2160">    // in case we get this buffer from the cache in the future, cache some stuff:</a>
<a name="ln2161">    **out_format = piece-&gt;dsc_out = pipe-&gt;dsc;</a>
<a name="ln2162"> </a>
<a name="ln2163">    dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2164">    if(module == darktable.develop-&gt;gui_module)</a>
<a name="ln2165">    {</a>
<a name="ln2166">      // give the input buffer to the currently focussed plugin more weight.</a>
<a name="ln2167">      // the user is likely to change that one soon, so keep it in cache.</a>
<a name="ln2168">      dt_dev_pixelpipe_cache_reweight(&amp;(pipe-&gt;cache), input);</a>
<a name="ln2169">    }</a>
<a name="ln2170">#ifndef _DEBUG</a>
<a name="ln2171">    if(darktable.unmuted &amp; DT_DEBUG_NAN)</a>
<a name="ln2172">#endif</a>
<a name="ln2173">    {</a>
<a name="ln2174">      dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2175">      if(pipe-&gt;shutdown)</a>
<a name="ln2176">      {</a>
<a name="ln2177">        dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2178">        return 1;</a>
<a name="ln2179">      }</a>
<a name="ln2180"> </a>
<a name="ln2181">      if(strcmp(module-&gt;op, &quot;gamma&quot;) == 0)</a>
<a name="ln2182">      {</a>
<a name="ln2183">        dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2184">        goto post_process_collect_info;</a>
<a name="ln2185">      }</a>
<a name="ln2186"> </a>
<a name="ln2187">#ifdef HAVE_OPENCL</a>
<a name="ln2188">      if(*cl_mem_output != NULL)</a>
<a name="ln2189">        dt_opencl_copy_device_to_host(pipe-&gt;devid, *output, *cl_mem_output, roi_out-&gt;width, roi_out-&gt;height, bpp);</a>
<a name="ln2190">#endif</a>
<a name="ln2191"> </a>
<a name="ln2192">      if((*out_format)-&gt;datatype == TYPE_FLOAT &amp;&amp; (*out_format)-&gt;channels == 4)</a>
<a name="ln2193">      {</a>
<a name="ln2194">        int hasinf = 0, hasnan = 0;</a>
<a name="ln2195">        float min[3] = { FLT_MAX };</a>
<a name="ln2196">        float max[3] = { FLT_MIN };</a>
<a name="ln2197"> </a>
<a name="ln2198">        for(int k = 0; k &lt; 4 * roi_out-&gt;width * roi_out-&gt;height; k++)</a>
<a name="ln2199">        {</a>
<a name="ln2200">          if((k &amp; 3) &lt; 3)</a>
<a name="ln2201">          {</a>
<a name="ln2202">            float f = ((float *)(*output))[k];</a>
<a name="ln2203">            if(isnan(f))</a>
<a name="ln2204">              hasnan = 1;</a>
<a name="ln2205">            else if(isinf(f))</a>
<a name="ln2206">              hasinf = 1;</a>
<a name="ln2207">            else</a>
<a name="ln2208">            {</a>
<a name="ln2209">              min[k &amp; 3] = fmin(f, min[k &amp; 3]);</a>
<a name="ln2210">              max[k &amp; 3] = fmax(f, max[k &amp; 3]);</a>
<a name="ln2211">            }</a>
<a name="ln2212">          }</a>
<a name="ln2213">        }</a>
<a name="ln2214">        module_label = dt_history_item_get_name(module);</a>
<a name="ln2215">        if(hasnan)</a>
<a name="ln2216">          fprintf(stderr, &quot;[dev_pixelpipe] module `%s' outputs NaNs! [%s]\n&quot;, module_label,</a>
<a name="ln2217">                  _pipe_type_to_str(pipe-&gt;type));</a>
<a name="ln2218">        if(hasinf)</a>
<a name="ln2219">          fprintf(stderr, &quot;[dev_pixelpipe] module `%s' outputs non-finite floats! [%s]\n&quot;, module_label,</a>
<a name="ln2220">                  _pipe_type_to_str(pipe-&gt;type));</a>
<a name="ln2221">        fprintf(stderr, &quot;[dev_pixelpipe] module `%s' min: (%f; %f; %f) max: (%f; %f; %f) [%s]\n&quot;, module_label,</a>
<a name="ln2222">                min[0], min[1], min[2], max[0], max[1], max[2], _pipe_type_to_str(pipe-&gt;type));</a>
<a name="ln2223">        g_free(module_label);</a>
<a name="ln2224">      }</a>
<a name="ln2225">      else if((*out_format)-&gt;datatype == TYPE_FLOAT &amp;&amp; (*out_format)-&gt;channels == 1)</a>
<a name="ln2226">      {</a>
<a name="ln2227">        int hasinf = 0, hasnan = 0;</a>
<a name="ln2228">        float min = FLT_MAX;</a>
<a name="ln2229">        float max = FLT_MIN;</a>
<a name="ln2230"> </a>
<a name="ln2231">        for(int k = 0; k &lt; roi_out-&gt;width * roi_out-&gt;height; k++)</a>
<a name="ln2232">        {</a>
<a name="ln2233">          float f = ((float *)(*output))[k];</a>
<a name="ln2234">          if(isnan(f))</a>
<a name="ln2235">            hasnan = 1;</a>
<a name="ln2236">          else if(isinf(f))</a>
<a name="ln2237">            hasinf = 1;</a>
<a name="ln2238">          else</a>
<a name="ln2239">          {</a>
<a name="ln2240">            min = fmin(f, min);</a>
<a name="ln2241">            max = fmax(f, max);</a>
<a name="ln2242">          }</a>
<a name="ln2243">        }</a>
<a name="ln2244">        module_label = dt_history_item_get_name(module);</a>
<a name="ln2245">        if(hasnan)</a>
<a name="ln2246">          fprintf(stderr, &quot;[dev_pixelpipe] module `%s' outputs NaNs! [%s]\n&quot;, module_label,</a>
<a name="ln2247">                  _pipe_type_to_str(pipe-&gt;type));</a>
<a name="ln2248">        if(hasinf)</a>
<a name="ln2249">          fprintf(stderr, &quot;[dev_pixelpipe] module `%s' outputs non-finite floats! [%s]\n&quot;, module_label,</a>
<a name="ln2250">                  _pipe_type_to_str(pipe-&gt;type));</a>
<a name="ln2251">        fprintf(stderr, &quot;[dev_pixelpipe] module `%s' min: (%f) max: (%f) [%s]\n&quot;, module_label, min, max,</a>
<a name="ln2252">                _pipe_type_to_str(pipe-&gt;type));</a>
<a name="ln2253">        g_free(module_label);</a>
<a name="ln2254">      }</a>
<a name="ln2255"> </a>
<a name="ln2256">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2257">    }</a>
<a name="ln2258"> </a>
<a name="ln2259">post_process_collect_info:</a>
<a name="ln2260"> </a>
<a name="ln2261">    dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2262">    if(pipe-&gt;shutdown)</a>
<a name="ln2263">    {</a>
<a name="ln2264">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2265">      return 1;</a>
<a name="ln2266">    }</a>
<a name="ln2267">    // Picking RGB for the live samples and converting to Lab</a>
<a name="ln2268">    if(dev-&gt;gui_attached &amp;&amp; pipe == dev-&gt;preview_pipe &amp;&amp; (strcmp(module-&gt;op, &quot;gamma&quot;) == 0)</a>
<a name="ln2269">       &amp;&amp; darktable.lib-&gt;proxy.colorpicker.live_samples &amp;&amp; input) // samples to pick</a>
<a name="ln2270">    {</a>
<a name="ln2271">      _pixelpipe_pick_live_samples((const float *const )input, &amp;roi_in);</a>
<a name="ln2272">    }</a>
<a name="ln2273">    // Picking RGB for primary colorpicker output and converting to Lab</a>
<a name="ln2274">    if(dev-&gt;gui_attached &amp;&amp; pipe == dev-&gt;preview_pipe</a>
<a name="ln2275">       &amp;&amp; (strcmp(module-&gt;op, &quot;gamma&quot;) == 0) // only gamma provides meaningful RGB data</a>
<a name="ln2276">       &amp;&amp; dev-&gt;gui_module &amp;&amp; !strcmp(dev-&gt;gui_module-&gt;op, &quot;colorout&quot;)</a>
<a name="ln2277">       &amp;&amp; dev-&gt;gui_module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF</a>
<a name="ln2278">       &amp;&amp; darktable.lib-&gt;proxy.colorpicker.picked_color_rgb_mean &amp;&amp; input) // colorpicker module active</a>
<a name="ln2279">    {</a>
<a name="ln2280">      _pixelpipe_pick_primary_colorpicker(dev, (const float *const )input, &amp;roi_in);</a>
<a name="ln2281"> </a>
<a name="ln2282">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2283"> </a>
<a name="ln2284">      if(module-&gt;widget) dt_control_queue_redraw_widget(module-&gt;widget);</a>
<a name="ln2285">    }</a>
<a name="ln2286">    else</a>
<a name="ln2287">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2288"> </a>
<a name="ln2289">    // 4) final histogram:</a>
<a name="ln2290">    dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2291">    if(pipe-&gt;shutdown)</a>
<a name="ln2292">    {</a>
<a name="ln2293">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2294">      return 1;</a>
<a name="ln2295">    }</a>
<a name="ln2296">    if(dev-&gt;gui_attached &amp;&amp; !dev-&gt;gui_leaving &amp;&amp; pipe == dev-&gt;preview_pipe</a>
<a name="ln2297">       &amp;&amp; (strcmp(module-&gt;op, &quot;gamma&quot;) == 0) &amp;&amp; input)</a>
<a name="ln2298">    {</a>
<a name="ln2299">      _pixelpipe_final_histogram(dev, (const float *const )input, &amp;roi_in);</a>
<a name="ln2300"> </a>
<a name="ln2301">      // calculate the waveform histogram. since this is drawn pixel by pixel we have to do it in the correct</a>
<a name="ln2302">      // size (thus the weird gui stuff :().</a>
<a name="ln2303">      // this HAS to be done on the float input data, otherwise we get really ugly artifacts due to rounding</a>
<a name="ln2304">      // issues when putting colors into the bins.</a>
<a name="ln2305">      //       dt_pthread_mutex_lock(&amp;dev-&gt;histogram_waveform_mutex);</a>
<a name="ln2306">      if(dev-&gt;histogram_waveform_width != 0)</a>
<a name="ln2307">      {</a>
<a name="ln2308">        _pixelpipe_final_histogram_waveform(dev, (const float *const )input, &amp;roi_in);</a>
<a name="ln2309">      }</a>
<a name="ln2310">      //       dt_pthread_mutex_unlock(&amp;dev-&gt;histogram_waveform_mutex);</a>
<a name="ln2311"> </a>
<a name="ln2312">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2313"> </a>
<a name="ln2314">      /* raise preview pipe finished signal */</a>
<a name="ln2315">      dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_PREVIEW_PIPE_FINISHED);</a>
<a name="ln2316">    }</a>
<a name="ln2317">    else</a>
<a name="ln2318">    {</a>
<a name="ln2319">      dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2320"> </a>
<a name="ln2321">      /* if gui attached, lets raise pipe finish signal */</a>
<a name="ln2322">      if(dev-&gt;gui_attached &amp;&amp; !dev-&gt;gui_leaving &amp;&amp; strcmp(module-&gt;op, &quot;gamma&quot;) == 0)</a>
<a name="ln2323">        dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_UI_PIPE_FINISHED);</a>
<a name="ln2324">    }</a>
<a name="ln2325">  }</a>
<a name="ln2326"> </a>
<a name="ln2327">  return 0;</a>
<a name="ln2328">}</a>
<a name="ln2329"> </a>
<a name="ln2330"> </a>
<a name="ln2331">int dt_dev_pixelpipe_process_no_gamma(dt_dev_pixelpipe_t *pipe, dt_develop_t *dev, int x, int y, int width,</a>
<a name="ln2332">                                      int height, float scale)</a>
<a name="ln2333">{</a>
<a name="ln2334">  // temporarily disable gamma mapping.</a>
<a name="ln2335">  GList *gammap = g_list_last(pipe-&gt;nodes);</a>
<a name="ln2336">  dt_dev_pixelpipe_iop_t *gamma = (dt_dev_pixelpipe_iop_t *)gammap-&gt;data;</a>
<a name="ln2337">  while(strcmp(gamma-&gt;module-&gt;op, &quot;gamma&quot;))</a>
<a name="ln2338">  {</a>
<a name="ln2339">    gamma = NULL;</a>
<a name="ln2340">    gammap = g_list_previous(gammap);</a>
<a name="ln2341">    if(!gammap) break;</a>
<a name="ln2342">    gamma = (dt_dev_pixelpipe_iop_t *)gammap-&gt;data;</a>
<a name="ln2343">  }</a>
<a name="ln2344">  if(gamma) gamma-&gt;enabled = 0;</a>
<a name="ln2345">  int ret = dt_dev_pixelpipe_process(pipe, dev, x, y, width, height, scale);</a>
<a name="ln2346">  if(gamma) gamma-&gt;enabled = 1;</a>
<a name="ln2347">  return ret;</a>
<a name="ln2348">}</a>
<a name="ln2349"> </a>
<a name="ln2350">void dt_dev_pixelpipe_disable_after(dt_dev_pixelpipe_t *pipe, const char *op)</a>
<a name="ln2351">{</a>
<a name="ln2352">  GList *nodes = g_list_last(pipe-&gt;nodes);</a>
<a name="ln2353">  dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)nodes-&gt;data;</a>
<a name="ln2354">  while(strcmp(piece-&gt;module-&gt;op, op))</a>
<a name="ln2355">  {</a>
<a name="ln2356">    piece-&gt;enabled = 0;</a>
<a name="ln2357">    piece = NULL;</a>
<a name="ln2358">    nodes = g_list_previous(nodes);</a>
<a name="ln2359">    if(!nodes) break;</a>
<a name="ln2360">    piece = (dt_dev_pixelpipe_iop_t *)nodes-&gt;data;</a>
<a name="ln2361">  }</a>
<a name="ln2362">}</a>
<a name="ln2363"> </a>
<a name="ln2364">void dt_dev_pixelpipe_disable_before(dt_dev_pixelpipe_t *pipe, const char *op)</a>
<a name="ln2365">{</a>
<a name="ln2366">  GList *nodes = pipe-&gt;nodes;</a>
<a name="ln2367">  dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)nodes-&gt;data;</a>
<a name="ln2368">  while(strcmp(piece-&gt;module-&gt;op, op))</a>
<a name="ln2369">  {</a>
<a name="ln2370">    piece-&gt;enabled = 0;</a>
<a name="ln2371">    piece = NULL;</a>
<a name="ln2372">    nodes = g_list_next(nodes);</a>
<a name="ln2373">    if(!nodes) break;</a>
<a name="ln2374">    piece = (dt_dev_pixelpipe_iop_t *)nodes-&gt;data;</a>
<a name="ln2375">  }</a>
<a name="ln2376">}</a>
<a name="ln2377"> </a>
<a name="ln2378">static int dt_dev_pixelpipe_process_rec_and_backcopy(dt_dev_pixelpipe_t *pipe, dt_develop_t *dev, void **output,</a>
<a name="ln2379">                                                     void **cl_mem_output, dt_iop_buffer_dsc_t **out_format,</a>
<a name="ln2380">                                                     const dt_iop_roi_t *roi_out, GList *modules, GList *pieces,</a>
<a name="ln2381">                                                     int pos)</a>
<a name="ln2382">{</a>
<a name="ln2383">#ifdef HAVE_OPENCL</a>
<a name="ln2384">  int ret</a>
<a name="ln2385">      = dt_dev_pixelpipe_process_rec(pipe, dev, output, cl_mem_output, out_format, roi_out, modules, pieces, pos);</a>
<a name="ln2386"> </a>
<a name="ln2387">  // copy back final opencl buffer (if any) to CPU</a>
<a name="ln2388">  dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2389">  if(ret)</a>
<a name="ln2390">  {</a>
<a name="ln2391">    dt_opencl_release_mem_object(*cl_mem_output);</a>
<a name="ln2392">    *cl_mem_output = NULL;</a>
<a name="ln2393">  }</a>
<a name="ln2394">  else</a>
<a name="ln2395">  {</a>
<a name="ln2396">    if(*cl_mem_output != NULL)</a>
<a name="ln2397">    {</a>
<a name="ln2398">      cl_int err;</a>
<a name="ln2399"> </a>
<a name="ln2400">      err = dt_opencl_copy_device_to_host(pipe-&gt;devid, *output, *cl_mem_output, roi_out-&gt;width, roi_out-&gt;height,</a>
<a name="ln2401">                                          dt_iop_buffer_dsc_to_bpp(*out_format));</a>
<a name="ln2402">      dt_opencl_release_mem_object(*cl_mem_output);</a>
<a name="ln2403">      *cl_mem_output = NULL;</a>
<a name="ln2404"> </a>
<a name="ln2405">      if(err != CL_SUCCESS)</a>
<a name="ln2406">      {</a>
<a name="ln2407">        /* this indicates a opencl problem earlier in the pipeline */</a>
<a name="ln2408">        dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln2409">                 &quot;[opencl_pixelpipe (d)] late opencl error detected while copying back to cpu buffer: %d\n&quot;,</a>
<a name="ln2410">                 err);</a>
<a name="ln2411">        pipe-&gt;opencl_error = 1;</a>
<a name="ln2412">        ret = 1;</a>
<a name="ln2413">      }</a>
<a name="ln2414">    }</a>
<a name="ln2415">  }</a>
<a name="ln2416">  dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2417"> </a>
<a name="ln2418">  return ret;</a>
<a name="ln2419">#else</a>
<a name="ln2420">  return dt_dev_pixelpipe_process_rec(pipe, dev, output, cl_mem_output, out_format, roi_out, modules, pieces, pos);</a>
<a name="ln2421">#endif</a>
<a name="ln2422">}</a>
<a name="ln2423"> </a>
<a name="ln2424"> </a>
<a name="ln2425">int dt_dev_pixelpipe_process(dt_dev_pixelpipe_t *pipe, dt_develop_t *dev, int x, int y, int width, int height,</a>
<a name="ln2426">                             float scale)</a>
<a name="ln2427">{</a>
<a name="ln2428">  pipe-&gt;processing = 1;</a>
<a name="ln2429">  pipe-&gt;opencl_enabled = dt_opencl_update_settings(); // update enabled flag and profile from preferences</a>
<a name="ln2430">  pipe-&gt;devid = (pipe-&gt;opencl_enabled) ? dt_opencl_lock_device(pipe-&gt;type)</a>
<a name="ln2431">                                       : -1; // try to get/lock opencl resource</a>
<a name="ln2432"> </a>
<a name="ln2433">  dt_print(DT_DEBUG_OPENCL, &quot;[pixelpipe_process] [%s] using device %d\n&quot;, _pipe_type_to_str(pipe-&gt;type),</a>
<a name="ln2434">           pipe-&gt;devid);</a>
<a name="ln2435"> </a>
<a name="ln2436">  if(darktable.unmuted &amp; DT_DEBUG_MEMORY)</a>
<a name="ln2437">  {</a>
<a name="ln2438">    fprintf(stderr, &quot;[memory] before pixelpipe process\n&quot;);</a>
<a name="ln2439">    dt_print_mem_usage();</a>
<a name="ln2440">  }</a>
<a name="ln2441"> </a>
<a name="ln2442">  if(pipe-&gt;devid &gt;= 0) dt_opencl_events_reset(pipe-&gt;devid);</a>
<a name="ln2443"> </a>
<a name="ln2444">  dt_iop_roi_t roi = (dt_iop_roi_t){ x, y, width, height, scale };</a>
<a name="ln2445">  // printf(&quot;pixelpipe homebrew process start\n&quot;);</a>
<a name="ln2446">  if(darktable.unmuted &amp; DT_DEBUG_DEV) dt_dev_pixelpipe_cache_print(&amp;pipe-&gt;cache);</a>
<a name="ln2447"> </a>
<a name="ln2448">  // get a snapshot of mask list</a>
<a name="ln2449">  if (pipe-&gt;forms) g_list_free_full(pipe-&gt;forms, (void (*)(void *))dt_masks_free_form);</a>
<a name="ln2450">  pipe-&gt;forms = dt_masks_dup_forms_deep(dev-&gt;forms, NULL);</a>
<a name="ln2451"> </a>
<a name="ln2452">  //  go through list of modules from the end:</a>
<a name="ln2453">  guint pos = g_list_length(pipe-&gt;iop);</a>
<a name="ln2454">  GList *modules = g_list_last(pipe-&gt;iop);</a>
<a name="ln2455">  GList *pieces = g_list_last(pipe-&gt;nodes);</a>
<a name="ln2456"> </a>
<a name="ln2457">// re-entry point: in case of late opencl errors we start all over again with opencl-support disabled</a>
<a name="ln2458">restart:</a>
<a name="ln2459"> </a>
<a name="ln2460">  // check if we should obsolete caches</a>
<a name="ln2461">  if(pipe-&gt;cache_obsolete) dt_dev_pixelpipe_cache_flush(&amp;(pipe-&gt;cache));</a>
<a name="ln2462">  pipe-&gt;cache_obsolete = 0;</a>
<a name="ln2463"> </a>
<a name="ln2464">  // mask display off as a starting point</a>
<a name="ln2465">  pipe-&gt;mask_display = DT_DEV_PIXELPIPE_DISPLAY_NONE;</a>
<a name="ln2466"> </a>
<a name="ln2467">  void *buf = NULL;</a>
<a name="ln2468">  void *cl_mem_out = NULL;</a>
<a name="ln2469"> </a>
<a name="ln2470">  dt_iop_buffer_dsc_t _out_format = { 0 };</a>
<a name="ln2471">  dt_iop_buffer_dsc_t *out_format = &amp;_out_format;</a>
<a name="ln2472"> </a>
<a name="ln2473">  // run pixelpipe recursively and get error status</a>
<a name="ln2474">  int err = dt_dev_pixelpipe_process_rec_and_backcopy(pipe, dev, &amp;buf, &amp;cl_mem_out, &amp;out_format, &amp;roi, modules,</a>
<a name="ln2475">                                                      pieces, pos);</a>
<a name="ln2476"> </a>
<a name="ln2477">  // get status summary of opencl queue by checking the eventlist</a>
<a name="ln2478">  int oclerr = (pipe-&gt;devid &gt;= 0) ? (dt_opencl_events_flush(pipe-&gt;devid, 1) != 0) : 0;</a>
<a name="ln2479"> </a>
<a name="ln2480">  // Check if we had opencl errors ....</a>
<a name="ln2481">  // remark: opencl errors can come in two ways: pipe-&gt;opencl_error is TRUE (and err is TRUE) OR oclerr is</a>
<a name="ln2482">  // TRUE</a>
<a name="ln2483">  if(oclerr || (err &amp;&amp; pipe-&gt;opencl_error))</a>
<a name="ln2484">  {</a>
<a name="ln2485">    // Well, there were errors -&gt; we might need to free an invalid opencl memory object</a>
<a name="ln2486">    dt_opencl_release_mem_object(cl_mem_out);</a>
<a name="ln2487">    dt_opencl_unlock_device(pipe-&gt;devid); // release opencl resource</a>
<a name="ln2488">    dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2489">    pipe-&gt;opencl_enabled = 0; // disable opencl for this pipe</a>
<a name="ln2490">    pipe-&gt;opencl_error = 0;   // reset error status</a>
<a name="ln2491">    pipe-&gt;devid = -1;</a>
<a name="ln2492">    dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2493"> </a>
<a name="ln2494">    darktable.opencl-&gt;error_count++; // increase error count</a>
<a name="ln2495">    if(darktable.opencl-&gt;error_count &gt;= DT_OPENCL_MAX_ERRORS)</a>
<a name="ln2496">    {</a>
<a name="ln2497">      // too frequent opencl errors encountered: this is a clear sign of a broken setup. give up on opencl</a>
<a name="ln2498">      // during this session.</a>
<a name="ln2499">      darktable.opencl-&gt;stopped = 1;</a>
<a name="ln2500">      dt_print(DT_DEBUG_OPENCL,</a>
<a name="ln2501">               &quot;[opencl] frequent opencl errors encountered; disabling opencl for this session!\n&quot;);</a>
<a name="ln2502">      dt_control_log(</a>
<a name="ln2503">          _(&quot;darktable discovered problems with your OpenCL setup; disabling OpenCL for this session!&quot;));</a>
<a name="ln2504">      // also remove &quot;opencl&quot; from capabilities so that the preference entry is greyed out</a>
<a name="ln2505">      dt_capabilities_remove(&quot;opencl&quot;);</a>
<a name="ln2506">    }</a>
<a name="ln2507"> </a>
<a name="ln2508">    dt_dev_pixelpipe_flush_caches(pipe);</a>
<a name="ln2509">    dt_dev_pixelpipe_change(pipe, dev);</a>
<a name="ln2510">    dt_print(DT_DEBUG_OPENCL, &quot;[pixelpipe_process] [%s] falling back to cpu path\n&quot;,</a>
<a name="ln2511">             _pipe_type_to_str(pipe-&gt;type));</a>
<a name="ln2512">    goto restart; // try again (this time without opencl)</a>
<a name="ln2513">  }</a>
<a name="ln2514"> </a>
<a name="ln2515">  // release resources:</a>
<a name="ln2516">  if (pipe-&gt;forms)</a>
<a name="ln2517">  {</a>
<a name="ln2518">    g_list_free_full(pipe-&gt;forms, (void (*)(void *))dt_masks_free_form);</a>
<a name="ln2519">    pipe-&gt;forms = NULL;</a>
<a name="ln2520">  }</a>
<a name="ln2521">  if(pipe-&gt;devid &gt;= 0)</a>
<a name="ln2522">  {</a>
<a name="ln2523">    dt_opencl_unlock_device(pipe-&gt;devid);</a>
<a name="ln2524">    pipe-&gt;devid = -1;</a>
<a name="ln2525">  }</a>
<a name="ln2526">  // ... and in case of other errors ...</a>
<a name="ln2527">  if(err)</a>
<a name="ln2528">  {</a>
<a name="ln2529">    pipe-&gt;processing = 0;</a>
<a name="ln2530">    return 1;</a>
<a name="ln2531">  }</a>
<a name="ln2532"> </a>
<a name="ln2533">  // terminate</a>
<a name="ln2534">  dt_pthread_mutex_lock(&amp;pipe-&gt;backbuf_mutex);</a>
<a name="ln2535">  pipe-&gt;backbuf_hash = dt_dev_pixelpipe_cache_hash(pipe-&gt;image.id, &amp;roi, pipe, 0);</a>
<a name="ln2536">  pipe-&gt;backbuf = buf;</a>
<a name="ln2537">  pipe-&gt;backbuf_width = width;</a>
<a name="ln2538">  pipe-&gt;backbuf_height = height;</a>
<a name="ln2539">  dt_pthread_mutex_unlock(&amp;pipe-&gt;backbuf_mutex);</a>
<a name="ln2540"> </a>
<a name="ln2541">  // printf(&quot;pixelpipe homebrew process end\n&quot;);</a>
<a name="ln2542">  pipe-&gt;processing = 0;</a>
<a name="ln2543">  return 0;</a>
<a name="ln2544">}</a>
<a name="ln2545"> </a>
<a name="ln2546">void dt_dev_pixelpipe_flush_caches(dt_dev_pixelpipe_t *pipe)</a>
<a name="ln2547">{</a>
<a name="ln2548">  dt_dev_pixelpipe_cache_flush(&amp;pipe-&gt;cache);</a>
<a name="ln2549">}</a>
<a name="ln2550"> </a>
<a name="ln2551">void dt_dev_pixelpipe_get_dimensions(dt_dev_pixelpipe_t *pipe, struct dt_develop_t *dev, int width_in,</a>
<a name="ln2552">                                     int height_in, int *width, int *height)</a>
<a name="ln2553">{</a>
<a name="ln2554">  dt_pthread_mutex_lock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2555">  dt_iop_roi_t roi_in = (dt_iop_roi_t){ 0, 0, width_in, height_in, 1.0 };</a>
<a name="ln2556">  dt_iop_roi_t roi_out;</a>
<a name="ln2557">  GList *modules = pipe-&gt;iop;</a>
<a name="ln2558">  GList *pieces = pipe-&gt;nodes;</a>
<a name="ln2559">  while(modules)</a>
<a name="ln2560">  {</a>
<a name="ln2561">    dt_iop_module_t *module = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln2562">    dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)pieces-&gt;data;</a>
<a name="ln2563"> </a>
<a name="ln2564">    piece-&gt;buf_in = roi_in;</a>
<a name="ln2565"> </a>
<a name="ln2566">    // skip this module?</a>
<a name="ln2567">    if(piece-&gt;enabled</a>
<a name="ln2568">       &amp;&amp; !(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;operation_tags_filter() &amp; module-&gt;operation_tags()))</a>
<a name="ln2569">    {</a>
<a name="ln2570">      module-&gt;modify_roi_out(module, piece, &amp;roi_out, &amp;roi_in);</a>
<a name="ln2571">    }</a>
<a name="ln2572">    else</a>
<a name="ln2573">    {</a>
<a name="ln2574">      // pass through regions of interest for gui post expose events</a>
<a name="ln2575">      roi_out = roi_in;</a>
<a name="ln2576">    }</a>
<a name="ln2577"> </a>
<a name="ln2578">    piece-&gt;buf_out = roi_out;</a>
<a name="ln2579">    roi_in = roi_out;</a>
<a name="ln2580"> </a>
<a name="ln2581">    modules = g_list_next(modules);</a>
<a name="ln2582">    pieces = g_list_next(pieces);</a>
<a name="ln2583">  }</a>
<a name="ln2584">  *width = roi_out.width;</a>
<a name="ln2585">  *height = roi_out.height;</a>
<a name="ln2586">  dt_pthread_mutex_unlock(&amp;pipe-&gt;busy_mutex);</a>
<a name="ln2587">}</a>
<a name="ln2588"> </a>
<a name="ln2589">float *dt_dev_get_raster_mask(const dt_dev_pixelpipe_t *pipe, const dt_iop_module_t *raster_mask_source,</a>
<a name="ln2590">                              const int raster_mask_id, const dt_iop_module_t *target_module,</a>
<a name="ln2591">                              gboolean *free_mask)</a>
<a name="ln2592">{</a>
<a name="ln2593">  if(!raster_mask_source)</a>
<a name="ln2594">    return NULL;</a>
<a name="ln2595"> </a>
<a name="ln2596">  *free_mask = FALSE;</a>
<a name="ln2597">  float *raster_mask = NULL;</a>
<a name="ln2598"> </a>
<a name="ln2599">  GList *source_iter;</a>
<a name="ln2600">  for(source_iter = pipe-&gt;nodes; source_iter; source_iter = g_list_next(source_iter))</a>
<a name="ln2601">  {</a>
<a name="ln2602">    const dt_dev_pixelpipe_iop_t *candidate = (dt_dev_pixelpipe_iop_t *)source_iter-&gt;data;</a>
<a name="ln2603">    if(candidate-&gt;module == raster_mask_source)</a>
<a name="ln2604">      break;</a>
<a name="ln2605">  }</a>
<a name="ln2606"> </a>
<a name="ln2607">  if(source_iter)</a>
<a name="ln2608">  {</a>
<a name="ln2609">    const dt_dev_pixelpipe_iop_t *source_piece = (dt_dev_pixelpipe_iop_t *)source_iter-&gt;data;</a>
<a name="ln2610">    if(source_piece)</a>
<a name="ln2611">    {</a>
<a name="ln2612">      raster_mask = g_hash_table_lookup(source_piece-&gt;raster_masks, GINT_TO_POINTER(raster_mask_id));</a>
<a name="ln2613">      if(raster_mask)</a>
<a name="ln2614">      {</a>
<a name="ln2615">        for(GList *iter = g_list_next(source_iter); iter; iter = g_list_next(iter))</a>
<a name="ln2616">        {</a>
<a name="ln2617">          dt_dev_pixelpipe_iop_t *module = (dt_dev_pixelpipe_iop_t *)iter-&gt;data;</a>
<a name="ln2618"> </a>
<a name="ln2619">          if(module-&gt;enabled</a>
<a name="ln2620">            &amp;&amp; !(module-&gt;module-&gt;dev-&gt;gui_module &amp;&amp; module-&gt;module-&gt;dev-&gt;gui_module-&gt;operation_tags_filter()</a>
<a name="ln2621">                 &amp; module-&gt;module-&gt;operation_tags()))</a>
<a name="ln2622">          {</a>
<a name="ln2623">            if(module-&gt;module-&gt;distort_mask</a>
<a name="ln2624">              &amp;&amp; !(!strcmp(module-&gt;module-&gt;op, &quot;finalscale&quot;) // hack against pipes not using finalscale</a>
<a name="ln2625">                    &amp;&amp; module-&gt;processed_roi_in.width == 0</a>
<a name="ln2626">                    &amp;&amp; module-&gt;processed_roi_in.height == 0))</a>
<a name="ln2627">            {</a>
<a name="ln2628">              float *transformed_mask = dt_alloc_align(64, sizeof(float)</a>
<a name="ln2629">                                                          * module-&gt;processed_roi_out.width</a>
<a name="ln2630">                                                          * module-&gt;processed_roi_out.height);</a>
<a name="ln2631">              module-&gt;module-&gt;distort_mask(module-&gt;module,</a>
<a name="ln2632">                                          module,</a>
<a name="ln2633">                                          raster_mask,</a>
<a name="ln2634">                                          transformed_mask,</a>
<a name="ln2635">                                          &amp;module-&gt;processed_roi_in,</a>
<a name="ln2636">                                          &amp;module-&gt;processed_roi_out);</a>
<a name="ln2637">              if(*free_mask) dt_free_align(raster_mask);</a>
<a name="ln2638">              *free_mask = TRUE;</a>
<a name="ln2639">              raster_mask = transformed_mask;</a>
<a name="ln2640">            }</a>
<a name="ln2641">            else if(!module-&gt;module-&gt;distort_mask &amp;&amp;</a>
<a name="ln2642">                    (module-&gt;processed_roi_in.width != module-&gt;processed_roi_out.width ||</a>
<a name="ln2643">                     module-&gt;processed_roi_in.height != module-&gt;processed_roi_out.height ||</a>
<a name="ln2644">                     module-&gt;processed_roi_in.x != module-&gt;processed_roi_out.x ||</a>
<a name="ln2645">                     module-&gt;processed_roi_in.y != module-&gt;processed_roi_out.y))</a>
<a name="ln2646">              printf(&quot;FIXME: module `%s' changed the roi from %d x %d @ %d / %d to %d x %d | %d / %d but doesn't have &quot;</a>
<a name="ln2647">                     &quot;distort_mask() implemented!\n&quot;, module-&gt;module-&gt;op, module-&gt;processed_roi_in.width,</a>
<a name="ln2648">                     module-&gt;processed_roi_in.height, module-&gt;processed_roi_in.x, module-&gt;processed_roi_in.y,</a>
<a name="ln2649">                     module-&gt;processed_roi_out.width, module-&gt;processed_roi_out.height, module-&gt;processed_roi_out.x,</a>
<a name="ln2650">                     module-&gt;processed_roi_out.y);</a>
<a name="ln2651">          }</a>
<a name="ln2652"> </a>
<a name="ln2653">          if(module-&gt;module == target_module)</a>
<a name="ln2654">            break;</a>
<a name="ln2655">        }</a>
<a name="ln2656">      }</a>
<a name="ln2657">    }</a>
<a name="ln2658">  }</a>
<a name="ln2659"> </a>
<a name="ln2660">  return raster_mask;</a>
<a name="ln2661">}</a>
<a name="ln2662"> </a>
<a name="ln2663">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2664">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2665">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="253"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'piece'. Check lines: 253, 252.</p></div>
<div class="balloon" rel="1001"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'buf' pointer in the expression could be nullptr. In such case, resulting value of arithmetic operations on this pointer will be senseless and it should not be used. Check lines: 1001, 976.</p></div>
<div class="balloon" rel="1028"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'in'. Check lines: 1028, 976.</p></div>
<div class="balloon" rel="1057"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pieces' pointer was utilized before it was verified against nullptr. Check lines: 1057, 1062.</p></div>
<div class="balloon" rel="1216"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1268"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>
<div class="balloon" rel="1287"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1359"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1401"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v701/" target="_blank">V701</a> realloc() possible leak: when realloc() fails in allocating memory, original pointer 'module->histogram' is lost. Consider assigning realloc() to a temporary pointer.</p></div>
<div class="balloon" rel="1402"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1402, 1401.</p></div>
<div class="balloon" rel="1414"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1429"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1461"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1481"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1519"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1540"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v701/" target="_blank">V701</a> realloc() possible leak: when realloc() fails in allocating memory, original pointer 'module->histogram' is lost. Consider assigning realloc() to a temporary pointer.</p></div>
<div class="balloon" rel="1553"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1560"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'success_opencl' is always true.</p></div>
<div class="balloon" rel="1568"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1593"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1611"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1624"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1670"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1728"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1746"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v701/" target="_blank">V701</a> realloc() possible leak: when realloc() fails in allocating memory, original pointer 'module->histogram' is lost. Consider assigning realloc() to a temporary pointer.</p></div>
<div class="balloon" rel="1759"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1782"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1807"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1819"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1861"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1879"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v701/" target="_blank">V701</a> realloc() possible leak: when realloc() fails in allocating memory, original pointer 'module->histogram' is lost. Consider assigning realloc() to a temporary pointer.</p></div>
<div class="balloon" rel="1892"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1915"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1940"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1951"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1977"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v701/" target="_blank">V701</a> realloc() possible leak: when realloc() fails in allocating memory, original pointer 'module->histogram' is lost. Consider assigning realloc() to a temporary pointer.</p></div>
<div class="balloon" rel="1990"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="2013"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="2038"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="2175"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="2291"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'pipe->shutdown' is always false.</p></div>
<div class="balloon" rel="1178"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'pieces' pointer was utilized before it was verified against nullptr. Check lines: 1178, 1184.</p></div>
<div class="balloon" rel="2543"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1020/" target="_blank">V1020</a> The function exited without calling the 'dt_opencl_unlock_device' function. Check lines: 2543, 2430.</p></div>
<div class="balloon" rel="2530"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1020/" target="_blank">V1020</a> The function exited without calling the 'dt_opencl_unlock_device' function. Check lines: 2530, 2430.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
