
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;control/conf.h&quot;</a>
<a name="ln22">#include &quot;control/control.h&quot;</a>
<a name="ln23">#include &quot;develop/blend.h&quot;</a>
<a name="ln24">#include &quot;develop/imageop.h&quot;</a>
<a name="ln25">#include &quot;develop/masks.h&quot;</a>
<a name="ln26">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln27">#include &quot;gui/gtk.h&quot;</a>
<a name="ln28">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln29">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln30">#include &lt;stdlib.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">// this is the version of the modules parameters,</a>
<a name="ln34">// and includes version information about compile-time dt</a>
<a name="ln35">DT_MODULE_INTROSPECTION(2, dt_iop_spots_params_t)</a>
<a name="ln36"> </a>
<a name="ln37">typedef struct dt_iop_spots_params_t</a>
<a name="ln38">{</a>
<a name="ln39">  int clone_id[64];</a>
<a name="ln40">  int clone_algo[64];</a>
<a name="ln41">} dt_iop_spots_params_t;</a>
<a name="ln42"> </a>
<a name="ln43">typedef struct dt_iop_spots_gui_data_t</a>
<a name="ln44">{</a>
<a name="ln45">  GtkLabel *label;</a>
<a name="ln46">  GtkWidget *bt_path, *bt_circle, *bt_ellipse;</a>
<a name="ln47">} dt_iop_spots_gui_data_t;</a>
<a name="ln48"> </a>
<a name="ln49">typedef struct dt_iop_spots_params_t dt_iop_spots_data_t;</a>
<a name="ln50"> </a>
<a name="ln51"> </a>
<a name="ln52">// this returns a translatable name</a>
<a name="ln53">const char *name()</a>
<a name="ln54">{</a>
<a name="ln55">  return _(&quot;spot removal&quot;);</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">int default_group()</a>
<a name="ln59">{</a>
<a name="ln60">  return IOP_GROUP_CORRECT;</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">int flags()</a>
<a name="ln64">{</a>
<a name="ln65">  return IOP_FLAGS_SUPPORTS_BLENDING | IOP_FLAGS_NO_MASKS;</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln69">{</a>
<a name="ln70">  return iop_cs_rgb;</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln74">                  void *new_params, const int new_version)</a>
<a name="ln75">{</a>
<a name="ln76">  if(old_version == 1 &amp;&amp; new_version == 2)</a>
<a name="ln77">  {</a>
<a name="ln78">    typedef struct dt_iop_spots_v1_t</a>
<a name="ln79">    {</a>
<a name="ln80">      float x, y;</a>
<a name="ln81">      float xc, yc;</a>
<a name="ln82">      float radius;</a>
<a name="ln83">    } dt_iop_spots_v1_t;</a>
<a name="ln84">    typedef struct dt_iop_spots_params_v1_t</a>
<a name="ln85">    {</a>
<a name="ln86">      int num_spots;</a>
<a name="ln87">      dt_iop_spots_v1_t spot[32];</a>
<a name="ln88">    } dt_iop_spots_params_v1_t;</a>
<a name="ln89"> </a>
<a name="ln90">    dt_iop_spots_params_v1_t *o = (dt_iop_spots_params_v1_t *)old_params;</a>
<a name="ln91">    dt_iop_spots_params_t *n = (dt_iop_spots_params_t *)new_params;</a>
<a name="ln92">    dt_iop_spots_params_t *d = (dt_iop_spots_params_t *)self-&gt;default_params;</a>
<a name="ln93"> </a>
<a name="ln94">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln95">    for(int i = 0; i &lt; o-&gt;num_spots; i++)</a>
<a name="ln96">    {</a>
<a name="ln97">      // we have to register a new circle mask</a>
<a name="ln98">      dt_masks_form_t *form = dt_masks_create(DT_MASKS_CIRCLE | DT_MASKS_CLONE);</a>
<a name="ln99"> </a>
<a name="ln100">      // spots v1 was before raw orientation changes</a>
<a name="ln101">      form-&gt;version = 1;</a>
<a name="ln102"> </a>
<a name="ln103">      dt_masks_point_circle_t *circle = (dt_masks_point_circle_t *)(malloc(sizeof(dt_masks_point_circle_t)));</a>
<a name="ln104">      circle-&gt;center[0] = o-&gt;spot[i].x;</a>
<a name="ln105">      circle-&gt;center[1] = o-&gt;spot[i].y;</a>
<a name="ln106">      circle-&gt;radius = o-&gt;spot[i].radius;</a>
<a name="ln107">      circle-&gt;border = 0.0f;</a>
<a name="ln108">      form-&gt;points = g_list_append(form-&gt;points, circle);</a>
<a name="ln109">      form-&gt;source[0] = o-&gt;spot[i].xc;</a>
<a name="ln110">      form-&gt;source[1] = o-&gt;spot[i].yc;</a>
<a name="ln111"> </a>
<a name="ln112">      // adapt for raw orientation changes</a>
<a name="ln113">      dt_masks_legacy_params(self-&gt;dev, form, form-&gt;version, dt_masks_version());</a>
<a name="ln114"> </a>
<a name="ln115">      dt_masks_gui_form_save_creation(self-&gt;dev, self, form, NULL);</a>
<a name="ln116"> </a>
<a name="ln117">      // and add it to the module params</a>
<a name="ln118">      n-&gt;clone_id[i] = form-&gt;formid;</a>
<a name="ln119">      n-&gt;clone_algo[i] = 1;</a>
<a name="ln120">    }</a>
<a name="ln121">    return 0;</a>
<a name="ln122">  }</a>
<a name="ln123">  return 1;</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">static void _resynch_params(struct dt_iop_module_t *self)</a>
<a name="ln127">{</a>
<a name="ln128">  dt_iop_spots_params_t *p = (dt_iop_spots_params_t *)self-&gt;params;</a>
<a name="ln129">  dt_develop_blend_params_t *bp = self-&gt;blend_params;</a>
<a name="ln130"> </a>
<a name="ln131">  // we create 2 new buffers</a>
<a name="ln132">  int nid[64] = { 0 };</a>
<a name="ln133">  int nalgo[64] = { 2 };</a>
<a name="ln134"> </a>
<a name="ln135">  // we go through all forms in blend params</a>
<a name="ln136">  dt_masks_form_t *grp = dt_masks_get_from_id(darktable.develop, bp-&gt;mask_id);</a>
<a name="ln137">  if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln138">  {</a>
<a name="ln139">    GList *forms = g_list_first(grp-&gt;points);</a>
<a name="ln140">    int i = 0;</a>
<a name="ln141">    while((i &lt; 64) &amp;&amp; forms)</a>
<a name="ln142">    {</a>
<a name="ln143">      dt_masks_point_group_t *grpt = (dt_masks_point_group_t *)forms-&gt;data;</a>
<a name="ln144">      nid[i] = grpt-&gt;formid;</a>
<a name="ln145">      for(int j = 0; j &lt; 64; j++)</a>
<a name="ln146">      {</a>
<a name="ln147">        if(p-&gt;clone_id[j] == nid[i])</a>
<a name="ln148">        {</a>
<a name="ln149">          nalgo[i] = p-&gt;clone_algo[j];</a>
<a name="ln150">          break;</a>
<a name="ln151">        }</a>
<a name="ln152">      }</a>
<a name="ln153">      i++;</a>
<a name="ln154">      forms = g_list_next(forms);</a>
<a name="ln155">    }</a>
<a name="ln156">  }</a>
<a name="ln157"> </a>
<a name="ln158">  // we reaffect params</a>
<a name="ln159">  for(int i = 0; i &lt; 64; i++)</a>
<a name="ln160">  {</a>
<a name="ln161">    p-&gt;clone_algo[i] = nalgo[i];</a>
<a name="ln162">    p-&gt;clone_id[i] = nid[i];</a>
<a name="ln163">  }</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166"> </a>
<a name="ln167">static void _reset_form_creation(GtkWidget *widget, dt_iop_module_t *self)</a>
<a name="ln168">{</a>
<a name="ln169">  dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln170">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;bt_path)) ||</a>
<a name="ln171">      gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;bt_circle)) ||</a>
<a name="ln172">      gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;bt_ellipse)))</a>
<a name="ln173">  {</a>
<a name="ln174">    // we unset the creation mode</a>
<a name="ln175">    dt_masks_change_form_gui(NULL);</a>
<a name="ln176">  }</a>
<a name="ln177">  if (widget != g-&gt;bt_path) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_path), FALSE);</a>
<a name="ln178">  if (widget != g-&gt;bt_circle) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_circle), FALSE);</a>
<a name="ln179">  if (widget != g-&gt;bt_ellipse) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_ellipse), FALSE);</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">static gboolean _add_path(GtkWidget *widget, GdkEventButton *e, dt_iop_module_t *self)</a>
<a name="ln183">{</a>
<a name="ln184">  _reset_form_creation(widget, self);</a>
<a name="ln185">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) return FALSE;</a>
<a name="ln186">  // we want to be sure that the iop has focus</a>
<a name="ln187">  dt_iop_request_focus(self);</a>
<a name="ln188">  // we create the new form</a>
<a name="ln189">  dt_masks_form_t *form = dt_masks_create(DT_MASKS_PATH | DT_MASKS_CLONE);</a>
<a name="ln190">  dt_masks_change_form_gui(form);</a>
<a name="ln191">  darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln192">  darktable.develop-&gt;form_gui-&gt;creation_module = self;</a>
<a name="ln193">  dt_control_queue_redraw_center();</a>
<a name="ln194">  return FALSE;</a>
<a name="ln195">}</a>
<a name="ln196">static gboolean _add_circle(GtkWidget *widget, GdkEventButton *e, dt_iop_module_t *self)</a>
<a name="ln197">{</a>
<a name="ln198">  _reset_form_creation(widget, self);</a>
<a name="ln199">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) return FALSE;</a>
<a name="ln200">  // we want to be sure that the iop has focus</a>
<a name="ln201">  dt_iop_request_focus(self);</a>
<a name="ln202">  // we create the new form</a>
<a name="ln203">  dt_masks_form_t *spot = dt_masks_create(DT_MASKS_CIRCLE | DT_MASKS_CLONE);</a>
<a name="ln204">  dt_masks_change_form_gui(spot);</a>
<a name="ln205">  darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln206">  darktable.develop-&gt;form_gui-&gt;creation_module = self;</a>
<a name="ln207">  dt_control_queue_redraw_center();</a>
<a name="ln208">  return FALSE;</a>
<a name="ln209">}</a>
<a name="ln210">static gboolean _add_ellipse(GtkWidget *widget, GdkEventButton *e, dt_iop_module_t *self)</a>
<a name="ln211">{</a>
<a name="ln212">  _reset_form_creation(widget, self);</a>
<a name="ln213">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) return FALSE;</a>
<a name="ln214">  // we want to be sure that the iop has focus</a>
<a name="ln215">  dt_iop_request_focus(self);</a>
<a name="ln216">  // we create the new form</a>
<a name="ln217">  dt_masks_form_t *spot = dt_masks_create(DT_MASKS_ELLIPSE | DT_MASKS_CLONE);</a>
<a name="ln218">  dt_masks_change_form_gui(spot);</a>
<a name="ln219">  darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln220">  darktable.develop-&gt;form_gui-&gt;creation_module = self;</a>
<a name="ln221">  dt_control_queue_redraw_center();</a>
<a name="ln222">  return FALSE;</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225"> </a>
<a name="ln226">static gboolean masks_form_is_in_roi(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln227">                                     dt_masks_form_t *form, const dt_iop_roi_t *roi_in,</a>
<a name="ln228">                                     const dt_iop_roi_t *roi_out)</a>
<a name="ln229">{</a>
<a name="ln230">  // we get the area for the form</a>
<a name="ln231">  int fl, ft, fw, fh;</a>
<a name="ln232"> </a>
<a name="ln233">  if(!dt_masks_get_area(self, piece, form, &amp;fw, &amp;fh, &amp;fl, &amp;ft)) return FALSE;</a>
<a name="ln234"> </a>
<a name="ln235">  // is the form outside of the roi?</a>
<a name="ln236">  fw *= roi_in-&gt;scale, fh *= roi_in-&gt;scale, fl *= roi_in-&gt;scale, ft *= roi_in-&gt;scale;</a>
<a name="ln237">  if(ft &gt;= roi_out-&gt;y + roi_out-&gt;height || ft + fh &lt;= roi_out-&gt;y || fl &gt;= roi_out-&gt;x + roi_out-&gt;width</a>
<a name="ln238">     || fl + fw &lt;= roi_out-&gt;x)</a>
<a name="ln239">    return FALSE;</a>
<a name="ln240"> </a>
<a name="ln241">  return TRUE;</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">void modify_roi_out(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, dt_iop_roi_t *roi_out,</a>
<a name="ln245">                    const dt_iop_roi_t *roi_in)</a>
<a name="ln246">{</a>
<a name="ln247">  *roi_out = *roi_in;</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">// needed if mask dest is in roi and mask src is not</a>
<a name="ln251">void modify_roi_in(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln252">                   const dt_iop_roi_t *roi_out, dt_iop_roi_t *roi_in)</a>
<a name="ln253">{</a>
<a name="ln254">  *roi_in = *roi_out;</a>
<a name="ln255"> </a>
<a name="ln256">  int roir = roi_in-&gt;width + roi_in-&gt;x;</a>
<a name="ln257">  int roib = roi_in-&gt;height + roi_in-&gt;y;</a>
<a name="ln258">  int roix = roi_in-&gt;x;</a>
<a name="ln259">  int roiy = roi_in-&gt;y;</a>
<a name="ln260"> </a>
<a name="ln261">  // dt_iop_spots_params_t *d = (dt_iop_spots_params_t *)piece-&gt;data;</a>
<a name="ln262">  dt_develop_blend_params_t *bp = self-&gt;blend_params;</a>
<a name="ln263"> </a>
<a name="ln264">  // We iterate through all spots or polygons</a>
<a name="ln265">  dt_masks_form_t *grp = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, bp-&gt;mask_id);</a>
<a name="ln266">  if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln267">  {</a>
<a name="ln268">    GList *forms = g_list_first(grp-&gt;points);</a>
<a name="ln269">    while(forms)</a>
<a name="ln270">    {</a>
<a name="ln271">      dt_masks_point_group_t *grpt = (dt_masks_point_group_t *)forms-&gt;data;</a>
<a name="ln272">      // we get the spot</a>
<a name="ln273">      dt_masks_form_t *form = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, grpt-&gt;formid);</a>
<a name="ln274">      if(form)</a>
<a name="ln275">      {</a>
<a name="ln276">        // if the form is outside the roi, we just skip it</a>
<a name="ln277">        if(!masks_form_is_in_roi(self, piece, form, roi_in, roi_out))</a>
<a name="ln278">        {</a>
<a name="ln279">          forms = g_list_next(forms);</a>
<a name="ln280">          continue;</a>
<a name="ln281">        }</a>
<a name="ln282"> </a>
<a name="ln283">        // we get the area for the source</a>
<a name="ln284">        int fl, ft, fw, fh;</a>
<a name="ln285"> </a>
<a name="ln286">        if(!dt_masks_get_source_area(self, piece, form, &amp;fw, &amp;fh, &amp;fl, &amp;ft))</a>
<a name="ln287">        {</a>
<a name="ln288">          forms = g_list_next(forms);</a>
<a name="ln289">          continue;</a>
<a name="ln290">        }</a>
<a name="ln291">        fw *= roi_in-&gt;scale, fh *= roi_in-&gt;scale, fl *= roi_in-&gt;scale, ft *= roi_in-&gt;scale;</a>
<a name="ln292"> </a>
<a name="ln293">        // we enlarge the roi if needed</a>
<a name="ln294">        roiy = fminf(ft, roiy);</a>
<a name="ln295">        roix = fminf(fl, roix);</a>
<a name="ln296">        roir = fmaxf(fl + fw, roir);</a>
<a name="ln297">        roib = fmaxf(ft + fh, roib);</a>
<a name="ln298">      }</a>
<a name="ln299">      forms = g_list_next(forms);</a>
<a name="ln300">    }</a>
<a name="ln301">  }</a>
<a name="ln302"> </a>
<a name="ln303">  // now we set the values</a>
<a name="ln304">  const float scwidth = piece-&gt;buf_in.width * roi_in-&gt;scale, scheight = piece-&gt;buf_in.height * roi_in-&gt;scale;</a>
<a name="ln305">  roi_in-&gt;x = CLAMP(roix, 0, scwidth - 1);</a>
<a name="ln306">  roi_in-&gt;y = CLAMP(roiy, 0, scheight - 1);</a>
<a name="ln307">  roi_in-&gt;width = CLAMP(roir - roi_in-&gt;x, 1, scwidth + .5f - roi_in-&gt;x);</a>
<a name="ln308">  roi_in-&gt;height = CLAMP(roib - roi_in-&gt;y, 1, scheight + .5f - roi_in-&gt;y);</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311">static void masks_point_denormalize(dt_dev_pixelpipe_iop_t *piece, const dt_iop_roi_t *roi,</a>
<a name="ln312">                                    const float *points, size_t points_count, float *new)</a>
<a name="ln313">{</a>
<a name="ln314">  const float scalex = piece-&gt;pipe-&gt;iwidth * roi-&gt;scale, scaley = piece-&gt;pipe-&gt;iheight * roi-&gt;scale;</a>
<a name="ln315"> </a>
<a name="ln316">  for(size_t i = 0; i &lt; points_count * 2; i += 2)</a>
<a name="ln317">  {</a>
<a name="ln318">    new[i] = points[i] * scalex;</a>
<a name="ln319">    new[i + 1] = points[i + 1] * scaley;</a>
<a name="ln320">  }</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">static int masks_point_calc_delta(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln324">                                  const dt_iop_roi_t *roi, const float *target, const float *source, int *dx,</a>
<a name="ln325">                                  int *dy)</a>
<a name="ln326">{</a>
<a name="ln327">  float points[4];</a>
<a name="ln328">  masks_point_denormalize(piece, roi, target, 1, points);</a>
<a name="ln329">  masks_point_denormalize(piece, roi, source, 1, points + 2);</a>
<a name="ln330"> </a>
<a name="ln331">  int res = dt_dev_distort_transform_plus(self-&gt;dev, piece-&gt;pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, points, 2);</a>
<a name="ln332">  if(!res) return res;</a>
<a name="ln333"> </a>
<a name="ln334">  *dx = points[0] - points[2];</a>
<a name="ln335">  *dy = points[1] - points[3];</a>
<a name="ln336"> </a>
<a name="ln337">  return res;</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340">static int masks_get_delta(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const dt_iop_roi_t *roi,</a>
<a name="ln341">                           dt_masks_form_t *form, int *dx, int *dy)</a>
<a name="ln342">{</a>
<a name="ln343">  int res = 0;</a>
<a name="ln344"> </a>
<a name="ln345">  if(form-&gt;type &amp; DT_MASKS_PATH)</a>
<a name="ln346">  {</a>
<a name="ln347">    dt_masks_point_path_t *pt = (dt_masks_point_path_t *)form-&gt;points-&gt;data;</a>
<a name="ln348"> </a>
<a name="ln349">    res = masks_point_calc_delta(self, piece, roi, pt-&gt;corner, form-&gt;source, dx, dy);</a>
<a name="ln350">  }</a>
<a name="ln351">  else if(form-&gt;type &amp; DT_MASKS_CIRCLE)</a>
<a name="ln352">  {</a>
<a name="ln353">    dt_masks_point_circle_t *pt = (dt_masks_point_circle_t *)form-&gt;points-&gt;data;</a>
<a name="ln354"> </a>
<a name="ln355">    res = masks_point_calc_delta(self, piece, roi, pt-&gt;center, form-&gt;source, dx, dy);</a>
<a name="ln356">  }</a>
<a name="ln357">  else if(form-&gt;type &amp; DT_MASKS_ELLIPSE)</a>
<a name="ln358">  {</a>
<a name="ln359">    dt_masks_point_ellipse_t *pt = (dt_masks_point_ellipse_t *)form-&gt;points-&gt;data;</a>
<a name="ln360"> </a>
<a name="ln361">    res = masks_point_calc_delta(self, piece, roi, pt-&gt;center, form-&gt;source, dx, dy);</a>
<a name="ln362">  }</a>
<a name="ln363"> </a>
<a name="ln364">  return res;</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">void _process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln368">              float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out, const int ch)</a>
<a name="ln369">{</a>
<a name="ln370">  dt_iop_spots_params_t *d = (dt_iop_spots_params_t *)piece-&gt;data;</a>
<a name="ln371">  dt_develop_blend_params_t *bp = self-&gt;blend_params;</a>
<a name="ln372"> </a>
<a name="ln373">// we don't modify most of the image:</a>
<a name="ln374">#ifdef _OPENMP</a>
<a name="ln375">#pragma omp parallel for schedule(static) default(none)</a>
<a name="ln376">#endif</a>
<a name="ln377">  for(int k = 0; k &lt; roi_out-&gt;height; k++)</a>
<a name="ln378">  {</a>
<a name="ln379">    float *outb = out + (size_t)ch * k * roi_out-&gt;width;</a>
<a name="ln380">    const float *inb = in + (size_t)ch * roi_in-&gt;width * (k + roi_out-&gt;y - roi_in-&gt;y)</a>
<a name="ln381">                       + ch * (roi_out-&gt;x - roi_in-&gt;x);</a>
<a name="ln382">    memcpy(outb, inb, sizeof(float) * roi_out-&gt;width * ch);</a>
<a name="ln383">  }</a>
<a name="ln384"> </a>
<a name="ln385">  // iterate through all forms</a>
<a name="ln386">  dt_masks_form_t *grp = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, bp-&gt;mask_id);</a>
<a name="ln387">  int pos = 0;</a>
<a name="ln388">  if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln389">  {</a>
<a name="ln390">    GList *forms = g_list_first(grp-&gt;points);</a>
<a name="ln391">    while((pos &lt; 64) &amp;&amp; forms)</a>
<a name="ln392">    {</a>
<a name="ln393">      dt_masks_point_group_t *grpt = (dt_masks_point_group_t *)forms-&gt;data;</a>
<a name="ln394">      // we get the spot</a>
<a name="ln395">      dt_masks_form_t *form = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, grpt-&gt;formid);</a>
<a name="ln396">      if(!form)</a>
<a name="ln397">      {</a>
<a name="ln398">        forms = g_list_next(forms);</a>
<a name="ln399">        pos++;</a>
<a name="ln400">        continue;</a>
<a name="ln401">      }</a>
<a name="ln402"> </a>
<a name="ln403">      // if the form is outside the roi, we just skip it</a>
<a name="ln404">      if(!masks_form_is_in_roi(self, piece, form, roi_in, roi_out))</a>
<a name="ln405">      {</a>
<a name="ln406">        forms = g_list_next(forms);</a>
<a name="ln407">        pos++;</a>
<a name="ln408">        continue;</a>
<a name="ln409">      }</a>
<a name="ln410"> </a>
<a name="ln411">      if(d-&gt;clone_algo[pos] == 1 &amp;&amp; (form-&gt;type &amp; DT_MASKS_CIRCLE))</a>
<a name="ln412">      {</a>
<a name="ln413">        dt_masks_point_circle_t *circle = (dt_masks_point_circle_t *)g_list_nth_data(form-&gt;points, 0);</a>
<a name="ln414"> </a>
<a name="ln415">        float points[4];</a>
<a name="ln416">        masks_point_denormalize(piece, roi_in, circle-&gt;center, 1, points);</a>
<a name="ln417">        masks_point_denormalize(piece, roi_in, form-&gt;source, 1, points + 2);</a>
<a name="ln418"> </a>
<a name="ln419">        if(!dt_dev_distort_transform_plus(self-&gt;dev, piece-&gt;pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, points, 2))</a>
<a name="ln420">        {</a>
<a name="ln421">          forms = g_list_next(forms);</a>
<a name="ln422">          pos++;</a>
<a name="ln423">          continue;</a>
<a name="ln424">        }</a>
<a name="ln425"> </a>
<a name="ln426">        // convert from world space:</a>
<a name="ln427">        float radius10[2] = { circle-&gt;radius, circle-&gt;radius };</a>
<a name="ln428">        float radf[2];</a>
<a name="ln429">        masks_point_denormalize(piece, roi_in, radius10, 1, radf);</a>
<a name="ln430"> </a>
<a name="ln431">        const int rad = MIN(radf[0], radf[1]);</a>
<a name="ln432">        const int posx = points[0] - rad;</a>
<a name="ln433">        const int posy = points[1] - rad;</a>
<a name="ln434">        const int posx_source = points[2] - rad;</a>
<a name="ln435">        const int posy_source = points[3] - rad;</a>
<a name="ln436">        const int dx = posx - posx_source;</a>
<a name="ln437">        const int dy = posy - posy_source;</a>
<a name="ln438">        const int fw = 2 * rad, fh = 2 * rad;</a>
<a name="ln439"> </a>
<a name="ln440">        float *filter = malloc((2 * rad + 1) * sizeof(float));</a>
<a name="ln441"> </a>
<a name="ln442">        if(rad &gt; 0)</a>
<a name="ln443">        {</a>
<a name="ln444">          for(int k = -rad; k &lt;= rad; k++)</a>
<a name="ln445">          {</a>
<a name="ln446">            const float kk = 1.0f - fabsf(k / (float)rad);</a>
<a name="ln447">            filter[rad + k] = kk * kk * (3.0f - 2.0f * kk);</a>
<a name="ln448">          }</a>
<a name="ln449">        }</a>
<a name="ln450">        else</a>
<a name="ln451">        {</a>
<a name="ln452">          filter[0] = 1.0f;</a>
<a name="ln453">        }</a>
<a name="ln454"> </a>
<a name="ln455">        for(int yy = posy; yy &lt; posy + fh; yy++)</a>
<a name="ln456">        {</a>
<a name="ln457">          // we test if we are inside roi_out</a>
<a name="ln458">          if(yy &lt; roi_out-&gt;y || yy &gt;= roi_out-&gt;y + roi_out-&gt;height) continue;</a>
<a name="ln459">          // we test if the source point is inside roi_in</a>
<a name="ln460">          if(yy - dy &lt; roi_in-&gt;y || yy - dy &gt;= roi_in-&gt;y + roi_in-&gt;height) continue;</a>
<a name="ln461">          for(int xx = posx; xx &lt; posx + fw; xx++)</a>
<a name="ln462">          {</a>
<a name="ln463">            // we test if we are inside roi_out</a>
<a name="ln464">            if(xx &lt; roi_out-&gt;x || xx &gt;= roi_out-&gt;x + roi_out-&gt;width) continue;</a>
<a name="ln465">            // we test if the source point is inside roi_in</a>
<a name="ln466">            if(xx - dx &lt; roi_in-&gt;x || xx - dx &gt;= roi_in-&gt;x + roi_in-&gt;width) continue;</a>
<a name="ln467"> </a>
<a name="ln468">            const float f = filter[xx - posx + 1] * filter[yy - posy + 1];</a>
<a name="ln469">            for(int c = 0; c &lt; ch; c++)</a>
<a name="ln470">              out[ch * ((size_t)roi_out-&gt;width * (yy - roi_out-&gt;y) + xx - roi_out-&gt;x) + c]</a>
<a name="ln471">                  = out[ch * ((size_t)roi_out-&gt;width * (yy - roi_out-&gt;y) + xx - roi_out-&gt;x) + c] * (1.0f - f)</a>
<a name="ln472">                    + in[ch * ((size_t)roi_in-&gt;width * (yy - posy + posy_source - roi_in-&gt;y) + xx - posx</a>
<a name="ln473">                              + posx_source - roi_in-&gt;x) + c] * f;</a>
<a name="ln474">          }</a>
<a name="ln475">        }</a>
<a name="ln476"> </a>
<a name="ln477">        free(filter);</a>
<a name="ln478">      }</a>
<a name="ln479">      else</a>
<a name="ln480">      {</a>
<a name="ln481">        // we get the mask</a>
<a name="ln482">        float *mask = NULL;</a>
<a name="ln483">        int posx, posy, width, height;</a>
<a name="ln484">        dt_masks_get_mask(self, piece, form, &amp;mask, &amp;width, &amp;height, &amp;posx, &amp;posy);</a>
<a name="ln485">        int fts = posy * roi_in-&gt;scale, fhs = height * roi_in-&gt;scale, fls = posx * roi_in-&gt;scale,</a>
<a name="ln486">            fws = width * roi_in-&gt;scale;</a>
<a name="ln487">        int dx = 0, dy = 0;</a>
<a name="ln488"> </a>
<a name="ln489">        // now we search the delta with the source</a>
<a name="ln490">        if(!masks_get_delta(self, piece, roi_in, form, &amp;dx, &amp;dy))</a>
<a name="ln491">        {</a>
<a name="ln492">          forms = g_list_next(forms);</a>
<a name="ln493">          pos++;</a>
<a name="ln494">          free(mask);</a>
<a name="ln495"> </a>
<a name="ln496">          continue;</a>
<a name="ln497">        }</a>
<a name="ln498"> </a>
<a name="ln499">        if(dx != 0 || dy != 0)</a>
<a name="ln500">        {</a>
<a name="ln501">          // now we do the pixel clone</a>
<a name="ln502">          for(int yy = fts + 1; yy &lt; fts + fhs - 1; yy++)</a>
<a name="ln503">          {</a>
<a name="ln504">            // we test if we are inside roi_out</a>
<a name="ln505">            if(yy &lt; roi_out-&gt;y || yy &gt;= roi_out-&gt;y + roi_out-&gt;height) continue;</a>
<a name="ln506">            // we test if the source point is inside roi_in</a>
<a name="ln507">            if(yy - dy &lt; roi_in-&gt;y || yy - dy &gt;= roi_in-&gt;y + roi_in-&gt;height) continue;</a>
<a name="ln508">            for(int xx = fls + 1; xx &lt; fls + fws - 1; xx++)</a>
<a name="ln509">            {</a>
<a name="ln510">              // we test if we are inside roi_out</a>
<a name="ln511">              if(xx &lt; roi_out-&gt;x || xx &gt;= roi_out-&gt;x + roi_out-&gt;width) continue;</a>
<a name="ln512">              // we test if the source point is inside roi_in</a>
<a name="ln513">              if(xx - dx &lt; roi_in-&gt;x || xx - dx &gt;= roi_in-&gt;x + roi_in-&gt;width) continue;</a>
<a name="ln514"> </a>
<a name="ln515">              float f = mask[((int)((yy - fts) / roi_in-&gt;scale)) * width</a>
<a name="ln516">                             + (int)((xx - fls) / roi_in-&gt;scale)] * grpt-&gt;opacity;</a>
<a name="ln517"> </a>
<a name="ln518">              for(int c = 0; c &lt; ch; c++)</a>
<a name="ln519">                out[ch * ((size_t)roi_out-&gt;width * (yy - roi_out-&gt;y) + xx - roi_out-&gt;x) + c]</a>
<a name="ln520">                    = out[ch * ((size_t)roi_out-&gt;width * (yy - roi_out-&gt;y) + xx - roi_out-&gt;x) + c] * (1.0f - f)</a>
<a name="ln521">                      + in[ch * ((size_t)roi_in-&gt;width * (yy - dy - roi_in-&gt;y) + xx - dx - roi_in-&gt;x) + c] * f;</a>
<a name="ln522">            }</a>
<a name="ln523">          }</a>
<a name="ln524">        }</a>
<a name="ln525">        free(mask);</a>
<a name="ln526">      }</a>
<a name="ln527">      pos++;</a>
<a name="ln528">      forms = g_list_next(forms);</a>
<a name="ln529">    }</a>
<a name="ln530">  }</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o,</a>
<a name="ln534">             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln535">{</a>
<a name="ln536">  const float *in = (float *)i;</a>
<a name="ln537">  float *out = (float *)o;</a>
<a name="ln538">  _process(self, piece, in, out, roi_in, roi_out, piece-&gt;colors);</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">void distort_mask(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln542">                  float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln543">{</a>
<a name="ln544">  _process(self, piece, in, out, roi_in, roi_out, 1);</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">/** init, cleanup, commit to pipeline */</a>
<a name="ln548">void init(dt_iop_module_t *module)</a>
<a name="ln549">{</a>
<a name="ln550">  // we don't need global data:</a>
<a name="ln551">  module-&gt;data = NULL; // malloc(sizeof(dt_iop_spots_global_data_t));</a>
<a name="ln552">  module-&gt;params = calloc(1, sizeof(dt_iop_spots_params_t));</a>
<a name="ln553">  module-&gt;default_params = calloc(1, sizeof(dt_iop_spots_params_t));</a>
<a name="ln554">  // our module is disabled by default</a>
<a name="ln555">  // by default:</a>
<a name="ln556">  module-&gt;default_enabled = 0;</a>
<a name="ln557">  module-&gt;params_size = sizeof(dt_iop_spots_params_t);</a>
<a name="ln558">  module-&gt;gui_data = NULL;</a>
<a name="ln559">  // init defaults:</a>
<a name="ln560">  dt_iop_spots_params_t tmp = (dt_iop_spots_params_t){ { 0 }, { 2 } };</a>
<a name="ln561"> </a>
<a name="ln562">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_spots_params_t));</a>
<a name="ln563">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_spots_params_t));</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">void cleanup(dt_iop_module_t *module)</a>
<a name="ln567">{</a>
<a name="ln568">  free(module-&gt;params);</a>
<a name="ln569">  module-&gt;params = NULL;</a>
<a name="ln570">  free(module-&gt;data); // just to be sure</a>
<a name="ln571">  module-&gt;data = NULL;</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574">void gui_focus(struct dt_iop_module_t *self, gboolean in)</a>
<a name="ln575">{</a>
<a name="ln576">  // dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln577">  if(self-&gt;enabled)</a>
<a name="ln578">  {</a>
<a name="ln579">    if(in)</a>
<a name="ln580">    {</a>
<a name="ln581">      // got focus, show all shapes</a>
<a name="ln582">      dt_masks_set_edit_mode(self, DT_MASKS_EDIT_FULL);</a>
<a name="ln583">    }</a>
<a name="ln584">    else</a>
<a name="ln585">    {</a>
<a name="ln586">      // lost focus, hide all shapes</a>
<a name="ln587">      if (darktable.develop-&gt;form_gui-&gt;creation &amp;&amp; darktable.develop-&gt;form_gui-&gt;creation_module == self)</a>
<a name="ln588">        dt_masks_change_form_gui(NULL);</a>
<a name="ln589">      dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln590">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_path), FALSE);</a>
<a name="ln591">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_circle), FALSE);</a>
<a name="ln592">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_ellipse), FALSE);</a>
<a name="ln593">      dt_masks_set_edit_mode(self, DT_MASKS_EDIT_OFF);</a>
<a name="ln594">    }</a>
<a name="ln595">  }</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598">/** commit is the synch point between core and gui, so it copies params to pipe data. */</a>
<a name="ln599">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *params, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln600">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln601">{</a>
<a name="ln602">  memcpy(piece-&gt;data, params, sizeof(dt_iop_spots_params_t));</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln606">{</a>
<a name="ln607">  piece-&gt;data = malloc(sizeof(dt_iop_spots_data_t));</a>
<a name="ln608">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln612">{</a>
<a name="ln613">  free(piece-&gt;data);</a>
<a name="ln614">  piece-&gt;data = NULL;</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">/** gui callbacks, these are needed. */</a>
<a name="ln618">void gui_update(dt_iop_module_t *self)</a>
<a name="ln619">{</a>
<a name="ln620">  _resynch_params(self);</a>
<a name="ln621">  dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln622">  // update clones count</a>
<a name="ln623">  dt_masks_form_t *grp = dt_masks_get_from_id(self-&gt;dev, self-&gt;blend_params-&gt;mask_id);</a>
<a name="ln624">  guint nb = 0;</a>
<a name="ln625">  if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP)) nb = g_list_length(grp-&gt;points);</a>
<a name="ln626">  gchar *str = g_strdup_printf(&quot;%d&quot;, nb);</a>
<a name="ln627">  gtk_label_set_text(g-&gt;label, str);</a>
<a name="ln628">  g_free(str);</a>
<a name="ln629">  // update buttons status</a>
<a name="ln630">  int b1 = 0, b2 = 0, b3 = 0;</a>
<a name="ln631">  if(self-&gt;dev-&gt;form_gui &amp;&amp; self-&gt;dev-&gt;form_visible &amp;&amp; self-&gt;dev-&gt;form_gui-&gt;creation</a>
<a name="ln632">     &amp;&amp; self-&gt;dev-&gt;form_gui-&gt;creation_module == self)</a>
<a name="ln633">  {</a>
<a name="ln634">    if(self-&gt;dev-&gt;form_visible-&gt;type &amp; DT_MASKS_CIRCLE)</a>
<a name="ln635">      b1 = 1;</a>
<a name="ln636">    else if(self-&gt;dev-&gt;form_visible-&gt;type &amp; DT_MASKS_PATH)</a>
<a name="ln637">      b2 = 1;</a>
<a name="ln638">    else if(self-&gt;dev-&gt;form_visible-&gt;type &amp; DT_MASKS_ELLIPSE)</a>
<a name="ln639">      b3 = 1;</a>
<a name="ln640">  }</a>
<a name="ln641">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_circle), b1);</a>
<a name="ln642">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_path), b2);</a>
<a name="ln643">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_ellipse), b3);</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">void gui_init(dt_iop_module_t *self)</a>
<a name="ln647">{</a>
<a name="ln648">  self-&gt;gui_data = malloc(sizeof(dt_iop_spots_gui_data_t));</a>
<a name="ln649">  dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln650"> </a>
<a name="ln651">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln652">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln653">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln654">  GtkWidget *label = gtk_label_new(_(&quot;number of strokes:&quot;));</a>
<a name="ln655">  gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, TRUE, 0);</a>
<a name="ln656">  g-&gt;label = GTK_LABEL(gtk_label_new(&quot;-1&quot;));</a>
<a name="ln657">  gtk_widget_set_tooltip_text(hbox, _(&quot;click on a shape and drag on canvas.\nuse the mouse wheel &quot;</a>
<a name="ln658">                                      &quot;to adjust size.\nright click to remove a shape.&quot;));</a>
<a name="ln659"> </a>
<a name="ln660">  g-&gt;bt_path = dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_path, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln661">  g_signal_connect(G_OBJECT(g-&gt;bt_path), &quot;button-press-event&quot;, G_CALLBACK(_add_path), self);</a>
<a name="ln662">  gtk_widget_set_tooltip_text(g-&gt;bt_path, _(&quot;add path&quot;));</a>
<a name="ln663">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_path), FALSE);</a>
<a name="ln664">  gtk_box_pack_end(GTK_BOX(hbox), g-&gt;bt_path, FALSE, FALSE, 0);</a>
<a name="ln665"> </a>
<a name="ln666">  g-&gt;bt_ellipse</a>
<a name="ln667">      = dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_ellipse, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln668">  g_signal_connect(G_OBJECT(g-&gt;bt_ellipse), &quot;button-press-event&quot;, G_CALLBACK(_add_ellipse), self);</a>
<a name="ln669">  gtk_widget_set_tooltip_text(g-&gt;bt_ellipse, _(&quot;add ellipse&quot;));</a>
<a name="ln670">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_ellipse), FALSE);</a>
<a name="ln671">  gtk_box_pack_end(GTK_BOX(hbox), g-&gt;bt_ellipse, FALSE, FALSE, 0);</a>
<a name="ln672"> </a>
<a name="ln673">  g-&gt;bt_circle</a>
<a name="ln674">      = dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_circle, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln675">  g_signal_connect(G_OBJECT(g-&gt;bt_circle), &quot;button-press-event&quot;, G_CALLBACK(_add_circle), self);</a>
<a name="ln676">  gtk_widget_set_tooltip_text(g-&gt;bt_circle, _(&quot;add circle&quot;));</a>
<a name="ln677">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_circle), FALSE);</a>
<a name="ln678">  gtk_box_pack_end(GTK_BOX(hbox), g-&gt;bt_circle, FALSE, FALSE, 0);</a>
<a name="ln679"> </a>
<a name="ln680">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(g-&gt;label), FALSE, TRUE, 0);</a>
<a name="ln681">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), hbox, TRUE, TRUE, 0);</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">void gui_reset(struct dt_iop_module_t *self)</a>
<a name="ln685">{</a>
<a name="ln686">  // hide the previous masks</a>
<a name="ln687">  dt_masks_reset_form_gui();</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690">void gui_cleanup(dt_iop_module_t *self)</a>
<a name="ln691">{</a>
<a name="ln692">  // dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln693">  // nothing else necessary, gtk will clean up the labels</a>
<a name="ln694"> </a>
<a name="ln695">  free(self-&gt;gui_data);</a>
<a name="ln696">  self-&gt;gui_data = NULL;</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">void init_key_accels (dt_iop_module_so_t *module)</a>
<a name="ln700">{</a>
<a name="ln701">  dt_accel_register_iop (module, TRUE, NC_(&quot;accel&quot;, &quot;spot circle tool&quot;),   0, 0);</a>
<a name="ln702">  dt_accel_register_iop (module, TRUE, NC_(&quot;accel&quot;, &quot;spot ellipse tool&quot;),   0, 0);</a>
<a name="ln703">  dt_accel_register_iop (module, TRUE, NC_(&quot;accel&quot;, &quot;spot path tool&quot;),     0, 0);</a>
<a name="ln704">  dt_accel_register_iop (module, TRUE, NC_(&quot;accel&quot;, &quot;spot show or hide&quot;),  0, 0);</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707">static gboolean _add_circle_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln708">                                      GdkModifierType modifier, gpointer data)</a>
<a name="ln709">{</a>
<a name="ln710">  dt_iop_module_t *module = (dt_iop_module_t *)data;</a>
<a name="ln711">  const dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln712">  _add_circle(GTK_WIDGET(g-&gt;bt_circle), NULL, module);</a>
<a name="ln713">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_circle), TRUE);</a>
<a name="ln714">  return TRUE;</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">static gboolean _add_ellipse_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln718">                                       GdkModifierType modifier, gpointer data)</a>
<a name="ln719">{</a>
<a name="ln720">  dt_iop_module_t *module = (dt_iop_module_t *)data;</a>
<a name="ln721">  const dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln722">  _add_ellipse(GTK_WIDGET(g-&gt;bt_ellipse), NULL, module);</a>
<a name="ln723">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_ellipse), TRUE);</a>
<a name="ln724">  return TRUE;</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">static gboolean _add_path_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln728">                                    GdkModifierType modifier, gpointer data)</a>
<a name="ln729">{</a>
<a name="ln730">  dt_iop_module_t *module = (dt_iop_module_t *)data;</a>
<a name="ln731">  const dt_iop_spots_gui_data_t *g = (dt_iop_spots_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln732">  _add_path(GTK_WIDGET(g-&gt;bt_path), NULL, module);</a>
<a name="ln733">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;bt_path), TRUE);</a>
<a name="ln734">  return TRUE;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">static gboolean _show_hide_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln738">                                     GdkModifierType modifier, gpointer data)</a>
<a name="ln739">{</a>
<a name="ln740">  dt_iop_module_t *module = (dt_iop_module_t *)data;</a>
<a name="ln741">  dt_masks_set_edit_mode(module, module-&gt;dev-&gt;form_gui-&gt;edit_mode == DT_MASKS_EDIT_FULL ? DT_MASKS_EDIT_OFF : DT_MASKS_EDIT_FULL);</a>
<a name="ln742">  return TRUE;</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745">void connect_key_accels (dt_iop_module_t *module)</a>
<a name="ln746">{</a>
<a name="ln747">  GClosure *closure;</a>
<a name="ln748"> </a>
<a name="ln749">  closure = g_cclosure_new(G_CALLBACK(_add_circle_key_accel), (gpointer)module, NULL);</a>
<a name="ln750">  dt_accel_connect_iop (module, &quot;spot circle tool&quot;, closure);</a>
<a name="ln751"> </a>
<a name="ln752">  closure = g_cclosure_new(G_CALLBACK(_add_ellipse_key_accel), (gpointer)module, NULL);</a>
<a name="ln753">  dt_accel_connect_iop (module, &quot;spot ellipse tool&quot;, closure);</a>
<a name="ln754"> </a>
<a name="ln755">  closure = g_cclosure_new(G_CALLBACK(_add_path_key_accel), (gpointer)module, NULL);</a>
<a name="ln756">  dt_accel_connect_iop (module, &quot;spot path tool&quot;, closure);</a>
<a name="ln757"> </a>
<a name="ln758">  closure = g_cclosure_new(G_CALLBACK(_show_hide_key_accel), (gpointer)module, NULL);</a>
<a name="ln759">  dt_accel_connect_iop (module, &quot;spot show or hide&quot;, closure);</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln763">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln764">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="104"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'circle'. Check lines: 104, 103.</p></div>
<div class="balloon" rel="133"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1009/" target="_blank">V1009</a> Check the array initialization. Only the first element is initialized explicitly. The rest elements are initialized with zeros.</p></div>
<div class="balloon" rel="447"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'filter'. Check lines: 447, 440.</p></div>
<div class="balloon" rel="562"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 562, 552.</p></div>
<div class="balloon" rel="563"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 563, 553.</p></div>
<div class="balloon" rel="656"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 656, 648.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
