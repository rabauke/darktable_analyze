
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  This file is part of darktable,</a>
<a name="ln3">  copyright (c) 2016 Ulrich Pegelow.</a>
<a name="ln4"> </a>
<a name="ln5">  darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">  GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#ifdef HAVE_CONFIG_H</a>
<a name="ln20">#include &quot;config.h&quot;</a>
<a name="ln21">#endif</a>
<a name="ln22">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln23">#include &quot;common/bilateral.h&quot;</a>
<a name="ln24">#include &quot;common/colorspaces_inline_conversions.h&quot;</a>
<a name="ln25">#include &quot;common/debug.h&quot;</a>
<a name="ln26">#include &quot;common/interpolation.h&quot;</a>
<a name="ln27">#include &quot;common/opencl.h&quot;</a>
<a name="ln28">#include &quot;control/control.h&quot;</a>
<a name="ln29">#include &quot;develop/develop.h&quot;</a>
<a name="ln30">#include &quot;develop/imageop.h&quot;</a>
<a name="ln31">#include &quot;develop/tiling.h&quot;</a>
<a name="ln32">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln33">#include &quot;dtgtk/resetlabel.h&quot;</a>
<a name="ln34">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln35">#include &quot;gui/draw.h&quot;</a>
<a name="ln36">#include &quot;gui/gtk.h&quot;</a>
<a name="ln37">#include &quot;gui/guides.h&quot;</a>
<a name="ln38">#include &quot;gui/presets.h&quot;</a>
<a name="ln39">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;assert.h&gt;</a>
<a name="ln42">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln43">#include &lt;inttypes.h&gt;</a>
<a name="ln44">#include &lt;math.h&gt;</a>
<a name="ln45">#include &lt;stdlib.h&gt;</a>
<a name="ln46">#include &lt;string.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">// Inspiration to this module comes from the program ShiftN (http://www.shiftn.de) by</a>
<a name="ln49">// Marcus Hebel.</a>
<a name="ln50"> </a>
<a name="ln51">// Thanks to Marcus for his support when implementing part of the ShiftN functionality</a>
<a name="ln52">// to darktable.</a>
<a name="ln53"> </a>
<a name="ln54">#define ROTATION_RANGE 10                   // allowed min/max default range for rotation parameter</a>
<a name="ln55">#define ROTATION_RANGE_SOFT 20              // allowed min/max range for rotation parameter with manual adjustment</a>
<a name="ln56">#define LENSSHIFT_RANGE 1.0                 // allowed min/max default range for lensshift parameters</a>
<a name="ln57">#define LENSSHIFT_RANGE_SOFT 2.0            // allowed min/max range for lensshift parameters with manual adjustment</a>
<a name="ln58">#define SHEAR_RANGE 0.2                     // allowed min/max range for shear parameter</a>
<a name="ln59">#define SHEAR_RANGE_SOFT 0.5                // allowed min/max range for shear parameter with manual adjustment</a>
<a name="ln60">#define MIN_LINE_LENGTH 5                   // the minimum length of a line in pixels to be regarded as relevant</a>
<a name="ln61">#define MAX_TANGENTIAL_DEVIATION 30         // by how many degrees a line may deviate from the +/-180 and +/-90 to be regarded as relevant</a>
<a name="ln62">#define LSD_SCALE 0.99                      // LSD: scaling factor for line detection</a>
<a name="ln63">#define LSD_SIGMA_SCALE 0.6                 // LSD: sigma for Gaussian filter is computed as sigma = sigma_scale/scale</a>
<a name="ln64">#define LSD_QUANT 2.0                       // LSD: bound to the quantization error on the gradient norm</a>
<a name="ln65">#define LSD_ANG_TH 22.5                     // LSD: gradient angle tolerance in degrees</a>
<a name="ln66">#define LSD_LOG_EPS 0.0                     // LSD: detection threshold: -log10(NFA) &gt; log_eps</a>
<a name="ln67">#define LSD_DENSITY_TH 0.7                  // LSD: minimal density of region points in rectangle</a>
<a name="ln68">#define LSD_N_BINS 1024                     // LSD: number of bins in pseudo-ordering of gradient modulus</a>
<a name="ln69">#define LSD_GAMMA 0.45                      // gamma correction to apply on raw images prior to line detection</a>
<a name="ln70">#define RANSAC_RUNS 400                     // how many iterations to run in ransac</a>
<a name="ln71">#define RANSAC_EPSILON 2                    // starting value for ransac epsilon (in -log10 units)</a>
<a name="ln72">#define RANSAC_EPSILON_STEP 1               // step size of epsilon optimization (log10 units)</a>
<a name="ln73">#define RANSAC_ELIMINATION_RATIO 60         // percentage of lines we try to eliminate as outliers</a>
<a name="ln74">#define RANSAC_OPTIMIZATION_STEPS 5         // home many steps to optimize epsilon</a>
<a name="ln75">#define RANSAC_OPTIMIZATION_DRY_RUNS 50     // how man runs per optimization steps</a>
<a name="ln76">#define RANSAC_HURDLE 5                     // hurdle rate: the number of lines below which we do a complete permutation instead of random sampling</a>
<a name="ln77">#define MINIMUM_FITLINES 4                  // minimum number of lines needed for automatic parameter fit</a>
<a name="ln78">#define NMS_EPSILON 1e-3                    // break criterion for Nelder-Mead simplex</a>
<a name="ln79">#define NMS_SCALE 1.0                       // scaling factor for Nelder-Mead simplex</a>
<a name="ln80">#define NMS_ITERATIONS 400                  // number of iterations for Nelder-Mead simplex</a>
<a name="ln81">#define NMS_CROP_EPSILON 100.0              // break criterion for Nelder-Mead simplex on crop fitting</a>
<a name="ln82">#define NMS_CROP_SCALE 0.5                  // scaling factor for Nelder-Mead simplex on crop fitting</a>
<a name="ln83">#define NMS_CROP_ITERATIONS 100             // number of iterations for Nelder-Mead simplex on crop fitting</a>
<a name="ln84">#define NMS_ALPHA 1.0                       // reflection coefficient for Nelder-Mead simplex</a>
<a name="ln85">#define NMS_BETA 0.5                        // contraction coefficient for Nelder-Mead simplex</a>
<a name="ln86">#define NMS_GAMMA 2.0                       // expansion coefficient for Nelder-Mead simplex</a>
<a name="ln87">#define DEFAULT_F_LENGTH 28.0               // focal length we assume if no exif data are available</a>
<a name="ln88"> </a>
<a name="ln89">// define to get debugging output</a>
<a name="ln90">#undef ASHIFT_DEBUG</a>
<a name="ln91"> </a>
<a name="ln92">#define SQR(a) ((a) * (a))</a>
<a name="ln93"> </a>
<a name="ln94">// For line detection we use the LSD algorithm as published by Rafael Grompone:</a>
<a name="ln95">//</a>
<a name="ln96">//  &quot;LSD: a Line Segment Detector&quot; by Rafael Grompone von Gioi,</a>
<a name="ln97">//  Jeremie Jakubowicz, Jean-Michel Morel, and Gregory Randall,</a>
<a name="ln98">//  Image Processing On Line, 2012. DOI:10.5201/ipol.2012.gjmr-lsd</a>
<a name="ln99">//  http://dx.doi.org/10.5201/ipol.2012.gjmr-lsd</a>
<a name="ln100">#include &quot;ashift_lsd.c&quot;</a>
<a name="ln101"> </a>
<a name="ln102">// For parameter optimization we are using the Nelder-Mead simplex method</a>
<a name="ln103">// implemented by Michael F. Hutt.</a>
<a name="ln104">#include &quot;ashift_nmsimplex.c&quot;</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">DT_MODULE_INTROSPECTION(4, dt_iop_ashift_params_t)</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110">const char *name()</a>
<a name="ln111">{</a>
<a name="ln112">  return _(&quot;perspective correction&quot;);</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">int flags()</a>
<a name="ln116">{</a>
<a name="ln117">  return IOP_FLAGS_ALLOW_TILING | IOP_FLAGS_TILING_FULL_ROI | IOP_FLAGS_ONE_INSTANCE;</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">int default_group()</a>
<a name="ln121">{</a>
<a name="ln122">  return IOP_GROUP_CORRECT;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">int operation_tags()</a>
<a name="ln126">{</a>
<a name="ln127">  return IOP_TAG_DISTORT;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">int operation_tags_filter()</a>
<a name="ln131">{</a>
<a name="ln132">  // switch off clipping and decoration, we want to see the full image.</a>
<a name="ln133">  return IOP_TAG_DECORATION | IOP_TAG_CLIPPING;</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln137">{</a>
<a name="ln138">  return iop_cs_rgb;</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141">typedef enum dt_iop_ashift_homodir_t</a>
<a name="ln142">{</a>
<a name="ln143">  ASHIFT_HOMOGRAPH_FORWARD,</a>
<a name="ln144">  ASHIFT_HOMOGRAPH_INVERTED</a>
<a name="ln145">} dt_iop_ashift_homodir_t;</a>
<a name="ln146"> </a>
<a name="ln147">typedef enum dt_iop_ashift_linetype_t</a>
<a name="ln148">{</a>
<a name="ln149">  ASHIFT_LINE_IRRELEVANT   = 0,       // the line is found to be not interesting</a>
<a name="ln150">                                      // eg. too short, or not horizontal or vertical</a>
<a name="ln151">  ASHIFT_LINE_RELEVANT     = 1 &lt;&lt; 0,  // the line is relevant for us</a>
<a name="ln152">  ASHIFT_LINE_DIRVERT      = 1 &lt;&lt; 1,  // the line is (mostly) vertical, else (mostly) horizontal</a>
<a name="ln153">  ASHIFT_LINE_SELECTED     = 1 &lt;&lt; 2,  // the line is selected for fitting</a>
<a name="ln154">  ASHIFT_LINE_VERTICAL_NOT_SELECTED   = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_DIRVERT,</a>
<a name="ln155">  ASHIFT_LINE_HORIZONTAL_NOT_SELECTED = ASHIFT_LINE_RELEVANT,</a>
<a name="ln156">  ASHIFT_LINE_VERTICAL_SELECTED = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_DIRVERT | ASHIFT_LINE_SELECTED,</a>
<a name="ln157">  ASHIFT_LINE_HORIZONTAL_SELECTED = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED,</a>
<a name="ln158">  ASHIFT_LINE_MASK = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_DIRVERT | ASHIFT_LINE_SELECTED</a>
<a name="ln159">} dt_iop_ashift_linetype_t;</a>
<a name="ln160"> </a>
<a name="ln161">typedef enum dt_iop_ashift_linecolor_t</a>
<a name="ln162">{</a>
<a name="ln163">  ASHIFT_LINECOLOR_GREY    = 0,</a>
<a name="ln164">  ASHIFT_LINECOLOR_GREEN   = 1,</a>
<a name="ln165">  ASHIFT_LINECOLOR_RED     = 2,</a>
<a name="ln166">  ASHIFT_LINECOLOR_BLUE    = 3,</a>
<a name="ln167">  ASHIFT_LINECOLOR_YELLOW  = 4</a>
<a name="ln168">} dt_iop_ashift_linecolor_t;</a>
<a name="ln169"> </a>
<a name="ln170">typedef enum dt_iop_ashift_fitaxis_t</a>
<a name="ln171">{</a>
<a name="ln172">  ASHIFT_FIT_NONE          = 0,       // none</a>
<a name="ln173">  ASHIFT_FIT_ROTATION      = 1 &lt;&lt; 0,  // flag indicates to fit rotation angle</a>
<a name="ln174">  ASHIFT_FIT_LENS_VERT     = 1 &lt;&lt; 1,  // flag indicates to fit vertical lens shift</a>
<a name="ln175">  ASHIFT_FIT_LENS_HOR      = 1 &lt;&lt; 2,  // flag indicates to fit horizontal lens shift</a>
<a name="ln176">  ASHIFT_FIT_SHEAR         = 1 &lt;&lt; 3,  // flag indicates to fit shear parameter</a>
<a name="ln177">  ASHIFT_FIT_LINES_VERT    = 1 &lt;&lt; 4,  // use vertical lines for fitting</a>
<a name="ln178">  ASHIFT_FIT_LINES_HOR     = 1 &lt;&lt; 5,  // use horizontal lines for fitting</a>
<a name="ln179">  ASHIFT_FIT_LENS_BOTH = ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR,</a>
<a name="ln180">  ASHIFT_FIT_LINES_BOTH = ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln181">  ASHIFT_FIT_VERTICALLY = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LINES_VERT,</a>
<a name="ln182">  ASHIFT_FIT_HORIZONTALLY = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LENS_HOR | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln183">  ASHIFT_FIT_BOTH = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR |</a>
<a name="ln184">                    ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln185">  ASHIFT_FIT_VERTICALLY_NO_ROTATION = ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LINES_VERT,</a>
<a name="ln186">  ASHIFT_FIT_HORIZONTALLY_NO_ROTATION = ASHIFT_FIT_LENS_HOR | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln187">  ASHIFT_FIT_BOTH_NO_ROTATION = ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR |</a>
<a name="ln188">                                ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln189">  ASHIFT_FIT_BOTH_SHEAR = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR |</a>
<a name="ln190">                    ASHIFT_FIT_SHEAR | ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln191">  ASHIFT_FIT_ROTATION_VERTICAL_LINES = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LINES_VERT,</a>
<a name="ln192">  ASHIFT_FIT_ROTATION_HORIZONTAL_LINES = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln193">  ASHIFT_FIT_ROTATION_BOTH_LINES = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln194">  ASHIFT_FIT_FLIP = ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR | ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR</a>
<a name="ln195">} dt_iop_ashift_fitaxis_t;</a>
<a name="ln196"> </a>
<a name="ln197">typedef enum dt_iop_ashift_nmsresult_t</a>
<a name="ln198">{</a>
<a name="ln199">  NMS_SUCCESS = 0,</a>
<a name="ln200">  NMS_NOT_ENOUGH_LINES = 1,</a>
<a name="ln201">  NMS_DID_NOT_CONVERGE = 2,</a>
<a name="ln202">  NMS_INSANE = 3</a>
<a name="ln203">} dt_iop_ashift_nmsresult_t;</a>
<a name="ln204"> </a>
<a name="ln205">typedef enum dt_iop_ashift_enhance_t</a>
<a name="ln206">{</a>
<a name="ln207">  ASHIFT_ENHANCE_NONE       = 0,</a>
<a name="ln208">  ASHIFT_ENHANCE_EDGES      = 1 &lt;&lt; 0,</a>
<a name="ln209">  ASHIFT_ENHANCE_DETAIL     = 1 &lt;&lt; 1,</a>
<a name="ln210">  ASHIFT_ENHANCE_HORIZONTAL = 0x100,</a>
<a name="ln211">  ASHIFT_ENHANCE_VERTICAL   = 0x200</a>
<a name="ln212">} dt_iop_ashift_enhance_t;</a>
<a name="ln213"> </a>
<a name="ln214">typedef enum dt_iop_ashift_mode_t</a>
<a name="ln215">{</a>
<a name="ln216">  ASHIFT_MODE_GENERIC = 0,</a>
<a name="ln217">  ASHIFT_MODE_SPECIFIC = 1</a>
<a name="ln218">} dt_iop_ashift_mode_t;</a>
<a name="ln219"> </a>
<a name="ln220">typedef enum dt_iop_ashift_crop_t</a>
<a name="ln221">{</a>
<a name="ln222">  ASHIFT_CROP_OFF = 0,</a>
<a name="ln223">  ASHIFT_CROP_LARGEST = 1,</a>
<a name="ln224">  ASHIFT_CROP_ASPECT = 2</a>
<a name="ln225">} dt_iop_ashift_crop_t;</a>
<a name="ln226"> </a>
<a name="ln227">typedef enum dt_iop_ashift_bounding_t</a>
<a name="ln228">{</a>
<a name="ln229">  ASHIFT_BOUNDING_OFF = 0,</a>
<a name="ln230">  ASHIFT_BOUNDING_SELECT = 1,</a>
<a name="ln231">  ASHIFT_BOUNDING_DESELECT = 2</a>
<a name="ln232">} dt_iop_ashift_bounding_t;</a>
<a name="ln233"> </a>
<a name="ln234">typedef enum dt_iop_ashift_jobcode_t</a>
<a name="ln235">{</a>
<a name="ln236">  ASHIFT_JOBCODE_NONE = 0,</a>
<a name="ln237">  ASHIFT_JOBCODE_GET_STRUCTURE = 1,</a>
<a name="ln238">  ASHIFT_JOBCODE_FIT = 2</a>
<a name="ln239">} dt_iop_ashift_jobcode_t;</a>
<a name="ln240"> </a>
<a name="ln241">typedef struct dt_iop_ashift_params1_t</a>
<a name="ln242">{</a>
<a name="ln243">  float rotation;</a>
<a name="ln244">  float lensshift_v;</a>
<a name="ln245">  float lensshift_h;</a>
<a name="ln246">  int toggle;</a>
<a name="ln247">} dt_iop_ashift_params1_t;</a>
<a name="ln248"> </a>
<a name="ln249">typedef struct dt_iop_ashift_params2_t</a>
<a name="ln250">{</a>
<a name="ln251">  float rotation;</a>
<a name="ln252">  float lensshift_v;</a>
<a name="ln253">  float lensshift_h;</a>
<a name="ln254">  float f_length;</a>
<a name="ln255">  float crop_factor;</a>
<a name="ln256">  float orthocorr;</a>
<a name="ln257">  float aspect;</a>
<a name="ln258">  dt_iop_ashift_mode_t mode;</a>
<a name="ln259">  int toggle;</a>
<a name="ln260">} dt_iop_ashift_params2_t;</a>
<a name="ln261"> </a>
<a name="ln262">typedef struct dt_iop_ashift_params3_t</a>
<a name="ln263">{</a>
<a name="ln264">  float rotation;</a>
<a name="ln265">  float lensshift_v;</a>
<a name="ln266">  float lensshift_h;</a>
<a name="ln267">  float f_length;</a>
<a name="ln268">  float crop_factor;</a>
<a name="ln269">  float orthocorr;</a>
<a name="ln270">  float aspect;</a>
<a name="ln271">  dt_iop_ashift_mode_t mode;</a>
<a name="ln272">  int toggle;</a>
<a name="ln273">  dt_iop_ashift_crop_t cropmode;</a>
<a name="ln274">  float cl;</a>
<a name="ln275">  float cr;</a>
<a name="ln276">  float ct;</a>
<a name="ln277">  float cb;</a>
<a name="ln278">} dt_iop_ashift_params3_t;</a>
<a name="ln279"> </a>
<a name="ln280">typedef struct dt_iop_ashift_params_t</a>
<a name="ln281">{</a>
<a name="ln282">  float rotation;</a>
<a name="ln283">  float lensshift_v;</a>
<a name="ln284">  float lensshift_h;</a>
<a name="ln285">  float shear;</a>
<a name="ln286">  float f_length;</a>
<a name="ln287">  float crop_factor;</a>
<a name="ln288">  float orthocorr;</a>
<a name="ln289">  float aspect;</a>
<a name="ln290">  dt_iop_ashift_mode_t mode;</a>
<a name="ln291">  int toggle;</a>
<a name="ln292">  dt_iop_ashift_crop_t cropmode;</a>
<a name="ln293">  float cl;</a>
<a name="ln294">  float cr;</a>
<a name="ln295">  float ct;</a>
<a name="ln296">  float cb;</a>
<a name="ln297">} dt_iop_ashift_params_t;</a>
<a name="ln298"> </a>
<a name="ln299">typedef struct dt_iop_ashift_line_t</a>
<a name="ln300">{</a>
<a name="ln301">  float p1[3];</a>
<a name="ln302">  float p2[3];</a>
<a name="ln303">  float length;</a>
<a name="ln304">  float width;</a>
<a name="ln305">  float weight;</a>
<a name="ln306">  dt_iop_ashift_linetype_t type;</a>
<a name="ln307">  // homogeneous coordinates:</a>
<a name="ln308">  float L[3];</a>
<a name="ln309">} dt_iop_ashift_line_t;</a>
<a name="ln310"> </a>
<a name="ln311">typedef struct dt_iop_ashift_points_idx_t</a>
<a name="ln312">{</a>
<a name="ln313">  size_t offset;</a>
<a name="ln314">  int length;</a>
<a name="ln315">  int near;</a>
<a name="ln316">  int bounded;</a>
<a name="ln317">  dt_iop_ashift_linetype_t type;</a>
<a name="ln318">  dt_iop_ashift_linecolor_t color;</a>
<a name="ln319">  // bounding box:</a>
<a name="ln320">  float bbx, bby, bbX, bbY;</a>
<a name="ln321">} dt_iop_ashift_points_idx_t;</a>
<a name="ln322"> </a>
<a name="ln323">typedef struct dt_iop_ashift_fit_params_t</a>
<a name="ln324">{</a>
<a name="ln325">  int params_count;</a>
<a name="ln326">  dt_iop_ashift_linetype_t linetype;</a>
<a name="ln327">  dt_iop_ashift_linetype_t linemask;</a>
<a name="ln328">  dt_iop_ashift_line_t *lines;</a>
<a name="ln329">  int lines_count;</a>
<a name="ln330">  int width;</a>
<a name="ln331">  int height;</a>
<a name="ln332">  float weight;</a>
<a name="ln333">  float f_length_kb;</a>
<a name="ln334">  float orthocorr;</a>
<a name="ln335">  float aspect;</a>
<a name="ln336">  float rotation;</a>
<a name="ln337">  float lensshift_v;</a>
<a name="ln338">  float lensshift_h;</a>
<a name="ln339">  float shear;</a>
<a name="ln340">  float rotation_range;</a>
<a name="ln341">  float lensshift_v_range;</a>
<a name="ln342">  float lensshift_h_range;</a>
<a name="ln343">  float shear_range;</a>
<a name="ln344">} dt_iop_ashift_fit_params_t;</a>
<a name="ln345"> </a>
<a name="ln346">typedef struct dt_iop_ashift_cropfit_params_t</a>
<a name="ln347">{</a>
<a name="ln348">  int width;</a>
<a name="ln349">  int height;</a>
<a name="ln350">  float x;</a>
<a name="ln351">  float y;</a>
<a name="ln352">  float alpha;</a>
<a name="ln353">  float homograph[3][3];</a>
<a name="ln354">  float edges[4][3];</a>
<a name="ln355">} dt_iop_ashift_cropfit_params_t;</a>
<a name="ln356"> </a>
<a name="ln357">typedef struct dt_iop_ashift_gui_data_t</a>
<a name="ln358">{</a>
<a name="ln359">  GtkWidget *rotation;</a>
<a name="ln360">  GtkWidget *lensshift_v;</a>
<a name="ln361">  GtkWidget *lensshift_h;</a>
<a name="ln362">  GtkWidget *shear;</a>
<a name="ln363">  GtkWidget *guide_lines;</a>
<a name="ln364">  GtkWidget *cropmode;</a>
<a name="ln365">  GtkWidget *mode;</a>
<a name="ln366">  GtkWidget *f_length;</a>
<a name="ln367">  GtkWidget *crop_factor;</a>
<a name="ln368">  GtkWidget *orthocorr;</a>
<a name="ln369">  GtkWidget *aspect;</a>
<a name="ln370">  GtkWidget *fit_v;</a>
<a name="ln371">  GtkWidget *fit_h;</a>
<a name="ln372">  GtkWidget *fit_both;</a>
<a name="ln373">  GtkWidget *structure;</a>
<a name="ln374">  GtkWidget *clean;</a>
<a name="ln375">  GtkWidget *eye;</a>
<a name="ln376">  int lines_suppressed;</a>
<a name="ln377">  int fitting;</a>
<a name="ln378">  int isflipped;</a>
<a name="ln379">  int show_guides;</a>
<a name="ln380">  int isselecting;</a>
<a name="ln381">  int isdeselecting;</a>
<a name="ln382">  dt_iop_ashift_bounding_t isbounding;</a>
<a name="ln383">  float near_delta;</a>
<a name="ln384">  int selecting_lines_version;</a>
<a name="ln385">  float rotation_range;</a>
<a name="ln386">  float lensshift_v_range;</a>
<a name="ln387">  float lensshift_h_range;</a>
<a name="ln388">  float shear_range;</a>
<a name="ln389">  dt_iop_ashift_line_t *lines;</a>
<a name="ln390">  int lines_in_width;</a>
<a name="ln391">  int lines_in_height;</a>
<a name="ln392">  int lines_x_off;</a>
<a name="ln393">  int lines_y_off;</a>
<a name="ln394">  int lines_count;</a>
<a name="ln395">  int vertical_count;</a>
<a name="ln396">  int horizontal_count;</a>
<a name="ln397">  int lines_version;</a>
<a name="ln398">  float vertical_weight;</a>
<a name="ln399">  float horizontal_weight;</a>
<a name="ln400">  float *points;</a>
<a name="ln401">  dt_iop_ashift_points_idx_t *points_idx;</a>
<a name="ln402">  int points_lines_count;</a>
<a name="ln403">  int points_version;</a>
<a name="ln404">  float *buf;</a>
<a name="ln405">  int buf_width;</a>
<a name="ln406">  int buf_height;</a>
<a name="ln407">  int buf_x_off;</a>
<a name="ln408">  int buf_y_off;</a>
<a name="ln409">  float buf_scale;</a>
<a name="ln410">  uint64_t lines_hash;</a>
<a name="ln411">  uint64_t grid_hash;</a>
<a name="ln412">  uint64_t buf_hash;</a>
<a name="ln413">  dt_iop_ashift_fitaxis_t lastfit;</a>
<a name="ln414">  float lastx;</a>
<a name="ln415">  float lasty;</a>
<a name="ln416">  float crop_cx;</a>
<a name="ln417">  float crop_cy;</a>
<a name="ln418">  dt_iop_ashift_jobcode_t jobcode;</a>
<a name="ln419">  int jobparams;</a>
<a name="ln420">  dt_pthread_mutex_t lock;</a>
<a name="ln421">  gboolean adjust_crop;</a>
<a name="ln422">} dt_iop_ashift_gui_data_t;</a>
<a name="ln423"> </a>
<a name="ln424">typedef struct dt_iop_ashift_data_t</a>
<a name="ln425">{</a>
<a name="ln426">  float rotation;</a>
<a name="ln427">  float lensshift_v;</a>
<a name="ln428">  float lensshift_h;</a>
<a name="ln429">  float shear;</a>
<a name="ln430">  float f_length_kb;</a>
<a name="ln431">  float orthocorr;</a>
<a name="ln432">  float aspect;</a>
<a name="ln433">  float cl;</a>
<a name="ln434">  float cr;</a>
<a name="ln435">  float ct;</a>
<a name="ln436">  float cb;</a>
<a name="ln437">} dt_iop_ashift_data_t;</a>
<a name="ln438"> </a>
<a name="ln439">typedef struct dt_iop_ashift_global_data_t</a>
<a name="ln440">{</a>
<a name="ln441">  int kernel_ashift_bilinear;</a>
<a name="ln442">  int kernel_ashift_bicubic;</a>
<a name="ln443">  int kernel_ashift_lanczos2;</a>
<a name="ln444">  int kernel_ashift_lanczos3;</a>
<a name="ln445">} dt_iop_ashift_global_data_t;</a>
<a name="ln446"> </a>
<a name="ln447">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln448">                  void *new_params, const int new_version)</a>
<a name="ln449">{</a>
<a name="ln450">  if(old_version == 1 &amp;&amp; new_version == 4)</a>
<a name="ln451">  {</a>
<a name="ln452">    const dt_iop_ashift_params1_t *old = old_params;</a>
<a name="ln453">    dt_iop_ashift_params_t *new = new_params;</a>
<a name="ln454">    new-&gt;rotation = old-&gt;rotation;</a>
<a name="ln455">    new-&gt;lensshift_v = old-&gt;lensshift_v;</a>
<a name="ln456">    new-&gt;lensshift_h = old-&gt;lensshift_h;</a>
<a name="ln457">    new-&gt;shear = 0.0f;</a>
<a name="ln458">    new-&gt;toggle = old-&gt;toggle;</a>
<a name="ln459">    new-&gt;f_length = DEFAULT_F_LENGTH;</a>
<a name="ln460">    new-&gt;crop_factor = 1.0f;</a>
<a name="ln461">    new-&gt;orthocorr = 100.0f;</a>
<a name="ln462">    new-&gt;aspect = 1.0f;</a>
<a name="ln463">    new-&gt;mode = ASHIFT_MODE_GENERIC;</a>
<a name="ln464">    new-&gt;cropmode = ASHIFT_CROP_OFF;</a>
<a name="ln465">    new-&gt;cl = 0.0f;</a>
<a name="ln466">    new-&gt;cr = 1.0f;</a>
<a name="ln467">    new-&gt;ct = 0.0f;</a>
<a name="ln468">    new-&gt;cb = 1.0f;</a>
<a name="ln469">    return 0;</a>
<a name="ln470">  }</a>
<a name="ln471">  if(old_version == 2 &amp;&amp; new_version == 4)</a>
<a name="ln472">  {</a>
<a name="ln473">    const dt_iop_ashift_params2_t *old = old_params;</a>
<a name="ln474">    dt_iop_ashift_params_t *new = new_params;</a>
<a name="ln475">    new-&gt;rotation = old-&gt;rotation;</a>
<a name="ln476">    new-&gt;lensshift_v = old-&gt;lensshift_v;</a>
<a name="ln477">    new-&gt;lensshift_h = old-&gt;lensshift_h;</a>
<a name="ln478">    new-&gt;shear = 0.0f;</a>
<a name="ln479">    new-&gt;toggle = old-&gt;toggle;</a>
<a name="ln480">    new-&gt;f_length = old-&gt;f_length;</a>
<a name="ln481">    new-&gt;crop_factor = old-&gt;crop_factor;</a>
<a name="ln482">    new-&gt;orthocorr = old-&gt;orthocorr;</a>
<a name="ln483">    new-&gt;aspect = old-&gt;aspect;</a>
<a name="ln484">    new-&gt;mode = old-&gt;mode;</a>
<a name="ln485">    new-&gt;cropmode = ASHIFT_CROP_OFF;</a>
<a name="ln486">    new-&gt;cl = 0.0f;</a>
<a name="ln487">    new-&gt;cr = 1.0f;</a>
<a name="ln488">    new-&gt;ct = 0.0f;</a>
<a name="ln489">    new-&gt;cb = 1.0f;</a>
<a name="ln490">    return 0;</a>
<a name="ln491">  }</a>
<a name="ln492">  if(old_version == 3 &amp;&amp; new_version == 4)</a>
<a name="ln493">  {</a>
<a name="ln494">    const dt_iop_ashift_params3_t *old = old_params;</a>
<a name="ln495">    dt_iop_ashift_params_t *new = new_params;</a>
<a name="ln496">    new-&gt;rotation = old-&gt;rotation;</a>
<a name="ln497">    new-&gt;lensshift_v = old-&gt;lensshift_v;</a>
<a name="ln498">    new-&gt;lensshift_h = old-&gt;lensshift_h;</a>
<a name="ln499">    new-&gt;shear = 0.0f;</a>
<a name="ln500">    new-&gt;toggle = old-&gt;toggle;</a>
<a name="ln501">    new-&gt;f_length = old-&gt;f_length;</a>
<a name="ln502">    new-&gt;crop_factor = old-&gt;crop_factor;</a>
<a name="ln503">    new-&gt;orthocorr = old-&gt;orthocorr;</a>
<a name="ln504">    new-&gt;aspect = old-&gt;aspect;</a>
<a name="ln505">    new-&gt;mode = old-&gt;mode;</a>
<a name="ln506">    new-&gt;cropmode = old-&gt;cropmode;</a>
<a name="ln507">    new-&gt;cl = old-&gt;cl;</a>
<a name="ln508">    new-&gt;cr = old-&gt;cr;</a>
<a name="ln509">    new-&gt;ct = old-&gt;ct;</a>
<a name="ln510">    new-&gt;cb = old-&gt;cb;</a>
<a name="ln511">    return 0;</a>
<a name="ln512">  }</a>
<a name="ln513"> </a>
<a name="ln514">  return 1;</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln518">{</a>
<a name="ln519">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;rotation&quot;));</a>
<a name="ln520">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;lens shift (v)&quot;));</a>
<a name="ln521">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;lens shift (h)&quot;));</a>
<a name="ln522">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;shear&quot;));</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln526">{</a>
<a name="ln527">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln528"> </a>
<a name="ln529">  dt_accel_connect_slider_iop(self, &quot;rotation&quot;, GTK_WIDGET(g-&gt;rotation));</a>
<a name="ln530">  dt_accel_connect_slider_iop(self, &quot;lens shift (v)&quot;, GTK_WIDGET(g-&gt;lensshift_v));</a>
<a name="ln531">  dt_accel_connect_slider_iop(self, &quot;lens shift (h)&quot;, GTK_WIDGET(g-&gt;lensshift_h));</a>
<a name="ln532">  dt_accel_connect_slider_iop(self, &quot;shear&quot;, GTK_WIDGET(g-&gt;shear));</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">// multiply 3x3 matrix with 3x1 vector</a>
<a name="ln536">// dst needs to be different from v</a>
<a name="ln537">static inline void mat3mulv(float *dst, const float *const mat, const float *const v)</a>
<a name="ln538">{</a>
<a name="ln539">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln540">  {</a>
<a name="ln541">    float x = 0.0f;</a>
<a name="ln542">    for(int i = 0; i &lt; 3; i++) x += mat[3 * k + i] * v[i];</a>
<a name="ln543">    dst[k] = x;</a>
<a name="ln544">  }</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">// multiply two 3x3 matrices</a>
<a name="ln548">// dst needs to be different from m1 and m2</a>
<a name="ln549">static inline void mat3mul(float *dst, const float *const m1, const float *const m2)</a>
<a name="ln550">{</a>
<a name="ln551">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln552">  {</a>
<a name="ln553">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln554">    {</a>
<a name="ln555">      float x = 0.0f;</a>
<a name="ln556">      for(int j = 0; j &lt; 3; j++) x += m1[3 * k + j] * m2[3 * j + i];</a>
<a name="ln557">      dst[3 * k + i] = x;</a>
<a name="ln558">    }</a>
<a name="ln559">  }</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">// normalized product of two 3x1 vectors</a>
<a name="ln563">// dst needs to be different from v1 and v2</a>
<a name="ln564">static inline void vec3prodn(float *dst, const float *const v1, const float *const v2)</a>
<a name="ln565">{</a>
<a name="ln566">  const float l1 = v1[1] * v2[2] - v1[2] * v2[1];</a>
<a name="ln567">  const float l2 = v1[2] * v2[0] - v1[0] * v2[2];</a>
<a name="ln568">  const float l3 = v1[0] * v2[1] - v1[1] * v2[0];</a>
<a name="ln569"> </a>
<a name="ln570">  // normalize so that l1^2 + l2^2 + l3^3 = 1</a>
<a name="ln571">  const float sq = sqrt(l1 * l1 + l2 * l2 + l3 * l3);</a>
<a name="ln572"> </a>
<a name="ln573">  const float f = sq &gt; 0.0f ? 1.0f / sq : 1.0f;</a>
<a name="ln574"> </a>
<a name="ln575">  dst[0] = l1 * f;</a>
<a name="ln576">  dst[1] = l2 * f;</a>
<a name="ln577">  dst[2] = l3 * f;</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">// normalize a 3x1 vector so that x^2 + y^2 + z^2 = 1</a>
<a name="ln581">// dst and v may be the same</a>
<a name="ln582">static inline void vec3norm(float *dst, const float *const v)</a>
<a name="ln583">{</a>
<a name="ln584">  const float sq = sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);</a>
<a name="ln585"> </a>
<a name="ln586">  // special handling for an all-zero vector</a>
<a name="ln587">  const float f = sq &gt; 0.0f ? 1.0f / sq : 1.0f;</a>
<a name="ln588"> </a>
<a name="ln589">  dst[0] = v[0] * f;</a>
<a name="ln590">  dst[1] = v[1] * f;</a>
<a name="ln591">  dst[2] = v[2] * f;</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594">// normalize a 3x1 vector so that x^2 + y^2 = 1; a useful normalization for</a>
<a name="ln595">// lines in homogeneous coordinates</a>
<a name="ln596">// dst and v may be the same</a>
<a name="ln597">static inline void vec3lnorm(float *dst, const float *const v)</a>
<a name="ln598">{</a>
<a name="ln599">  const float sq = sqrt(v[0] * v[0] + v[1] * v[1]);</a>
<a name="ln600"> </a>
<a name="ln601">  // special handling for a point vector of the image center</a>
<a name="ln602">  const float f = sq &gt; 0.0f ? 1.0f / sq : 1.0f;</a>
<a name="ln603"> </a>
<a name="ln604">  dst[0] = v[0] * f;</a>
<a name="ln605">  dst[1] = v[1] * f;</a>
<a name="ln606">  dst[2] = v[2] * f;</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609"> </a>
<a name="ln610">// scalar product of two 3x1 vectors</a>
<a name="ln611">static inline float vec3scalar(const float *const v1, const float *const v2)</a>
<a name="ln612">{</a>
<a name="ln613">  return (v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]);</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">// check if 3x1 vector is (very close to) null</a>
<a name="ln617">static inline int vec3isnull(const float *const v)</a>
<a name="ln618">{</a>
<a name="ln619">  const float eps = 1e-10f;</a>
<a name="ln620">  return (fabs(v[0]) &lt; eps &amp;&amp; fabs(v[1]) &lt; eps &amp;&amp; fabs(v[2]) &lt; eps);</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">#ifdef ASHIFT_DEBUG</a>
<a name="ln624">static void print_roi(const dt_iop_roi_t *roi, const char *label)</a>
<a name="ln625">{</a>
<a name="ln626">  printf(&quot;{ %5d  %5d  %5d  %5d  %.6f } %s\n&quot;, roi-&gt;x, roi-&gt;y, roi-&gt;width, roi-&gt;height, roi-&gt;scale, label);</a>
<a name="ln627">}</a>
<a name="ln628">#endif</a>
<a name="ln629"> </a>
<a name="ln630">#define MAT3SWAP(a, b) { float (*tmp)[3] = (a); (a) = (b); (b) = tmp; }</a>
<a name="ln631"> </a>
<a name="ln632">static void homography(float *homograph, const float angle, const float shift_v, const float shift_h,</a>
<a name="ln633">                       const float shear, const float f_length_kb, const float orthocorr, const float aspect,</a>
<a name="ln634">                       const int width, const int height, dt_iop_ashift_homodir_t dir)</a>
<a name="ln635">{</a>
<a name="ln636">  // calculate homograph that combines all translations, rotations</a>
<a name="ln637">  // and warping into one single matrix operation.</a>
<a name="ln638">  // this is heavily leaning on ShiftN where the homographic matrix expects</a>
<a name="ln639">  // input in (y : x : 1) format. in the darktable world we want to keep the</a>
<a name="ln640">  // (x : y : 1) convention. therefore we need to flip coordinates first and</a>
<a name="ln641">  // make sure that output is in correct format after corrections are applied.</a>
<a name="ln642"> </a>
<a name="ln643">  const float u = width;</a>
<a name="ln644">  const float v = height;</a>
<a name="ln645"> </a>
<a name="ln646">  const float phi = M_PI * angle / 180.0f;</a>
<a name="ln647">  const float cosi = cos(phi);</a>
<a name="ln648">  const float sini = sin(phi);</a>
<a name="ln649">  const float ascale = sqrt(aspect);</a>
<a name="ln650"> </a>
<a name="ln651">  // most of this comes from ShiftN</a>
<a name="ln652">  const float f_global = f_length_kb;</a>
<a name="ln653">  const float horifac = 1.0f - orthocorr / 100.0f;</a>
<a name="ln654">  const float exppa_v = exp(shift_v);</a>
<a name="ln655">  const float fdb_v = f_global / (14.4f + (v / u - 1) * 7.2f);</a>
<a name="ln656">  const float rad_v = fdb_v * (exppa_v - 1.0f) / (exppa_v + 1.0f);</a>
<a name="ln657">  const float alpha_v = CLAMP(atan(rad_v), -1.5f, 1.5f);</a>
<a name="ln658">  const float rt_v = sin(0.5f * alpha_v);</a>
<a name="ln659">  const float r_v = fmax(0.1f, 2.0f * (horifac - 1.0f) * rt_v * rt_v + 1.0f);</a>
<a name="ln660"> </a>
<a name="ln661">  const float vertifac = 1.0f - orthocorr / 100.0f;</a>
<a name="ln662">  const float exppa_h = exp(shift_h);</a>
<a name="ln663">  const float fdb_h = f_global / (14.4f + (u / v - 1) * 7.2f);</a>
<a name="ln664">  const float rad_h = fdb_h * (exppa_h - 1.0f) / (exppa_h + 1.0f);</a>
<a name="ln665">  const float alpha_h = CLAMP(atan(rad_h), -1.5f, 1.5f);</a>
<a name="ln666">  const float rt_h = sin(0.5f * alpha_h);</a>
<a name="ln667">  const float r_h = fmax(0.1f, 2.0f * (vertifac - 1.0f) * rt_h * rt_h + 1.0f);</a>
<a name="ln668"> </a>
<a name="ln669"> </a>
<a name="ln670">  // three intermediate buffers for matrix calculation ...</a>
<a name="ln671">  float m1[3][3], m2[3][3], m3[3][3];</a>
<a name="ln672"> </a>
<a name="ln673">  // ... and some pointers to handle them more intuitively</a>
<a name="ln674">  float (*mwork)[3] = m1;</a>
<a name="ln675">  float (*minput)[3] = m2;</a>
<a name="ln676">  float (*moutput)[3] = m3;</a>
<a name="ln677"> </a>
<a name="ln678">  // Step 1: flip x and y coordinates (see above)</a>
<a name="ln679">  memset(minput, 0, 9 * sizeof(float));</a>
<a name="ln680">  minput[0][1] = 1.0f;</a>
<a name="ln681">  minput[1][0] = 1.0f;</a>
<a name="ln682">  minput[2][2] = 1.0f;</a>
<a name="ln683"> </a>
<a name="ln684"> </a>
<a name="ln685">  // Step 2: rotation of image around its center</a>
<a name="ln686">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln687">  mwork[0][0] = cosi;</a>
<a name="ln688">  mwork[0][1] = -sini;</a>
<a name="ln689">  mwork[1][0] = sini;</a>
<a name="ln690">  mwork[1][1] = cosi;</a>
<a name="ln691">  mwork[0][2] = -0.5f * v * cosi + 0.5f * u * sini + 0.5f * v;</a>
<a name="ln692">  mwork[1][2] = -0.5f * v * sini - 0.5f * u * cosi + 0.5f * u;</a>
<a name="ln693">  mwork[2][2] = 1.0f;</a>
<a name="ln694"> </a>
<a name="ln695">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln696">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln697"> </a>
<a name="ln698"> </a>
<a name="ln699">  // Step 3: apply shearing</a>
<a name="ln700">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln701">  mwork[0][0] = 1.0f;</a>
<a name="ln702">  mwork[0][1] = shear;</a>
<a name="ln703">  mwork[1][1] = 1.0f;</a>
<a name="ln704">  mwork[1][0] = shear;</a>
<a name="ln705">  mwork[2][2] = 1.0f;</a>
<a name="ln706"> </a>
<a name="ln707">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln708">  MAT3SWAP(minput, moutput);</a>
<a name="ln709">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln710">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln711"> </a>
<a name="ln712"> </a>
<a name="ln713">  // Step 4: apply vertical lens shift effect</a>
<a name="ln714">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln715">  mwork[0][0] = exppa_v;</a>
<a name="ln716">  mwork[1][0] = 0.5f * ((exppa_v - 1.0f) * u) / v;</a>
<a name="ln717">  mwork[1][1] = 2.0f * exppa_v / (exppa_v + 1.0f);</a>
<a name="ln718">  mwork[1][2] = -0.5f * ((exppa_v - 1.0f) * u) / (exppa_v + 1.0f);</a>
<a name="ln719">  mwork[2][0] = (exppa_v - 1.0f) / v;</a>
<a name="ln720">  mwork[2][2] = 1.0f;</a>
<a name="ln721"> </a>
<a name="ln722">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln723">  MAT3SWAP(minput, moutput);</a>
<a name="ln724">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln725">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln726"> </a>
<a name="ln727"> </a>
<a name="ln728">  // Step 5: horizontal compression</a>
<a name="ln729">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln730">  mwork[0][0] = 1.0f;</a>
<a name="ln731">  mwork[1][1] = r_v;</a>
<a name="ln732">  mwork[1][2] = 0.5f * u * (1.0f - r_v);</a>
<a name="ln733">  mwork[2][2] = 1.0f;</a>
<a name="ln734"> </a>
<a name="ln735">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln736">  MAT3SWAP(minput, moutput);</a>
<a name="ln737">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln738">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln739"> </a>
<a name="ln740"> </a>
<a name="ln741">  // Step 6: flip x and y back again</a>
<a name="ln742">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln743">  mwork[0][1] = 1.0f;</a>
<a name="ln744">  mwork[1][0] = 1.0f;</a>
<a name="ln745">  mwork[2][2] = 1.0f;</a>
<a name="ln746"> </a>
<a name="ln747">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln748">  MAT3SWAP(minput, moutput);</a>
<a name="ln749">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln750">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln751"> </a>
<a name="ln752"> </a>
<a name="ln753">  // from here output vectors would be in (x : y : 1) format</a>
<a name="ln754"> </a>
<a name="ln755">  // Step 7: now we can apply horizontal lens shift with the same matrix format as above</a>
<a name="ln756">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln757">  mwork[0][0] = exppa_h;</a>
<a name="ln758">  mwork[1][0] = 0.5f * ((exppa_h - 1.0f) * v) / u;</a>
<a name="ln759">  mwork[1][1] = 2.0f * exppa_h / (exppa_h + 1.0f);</a>
<a name="ln760">  mwork[1][2] = -0.5f * ((exppa_h - 1.0f) * v) / (exppa_h + 1.0f);</a>
<a name="ln761">  mwork[2][0] = (exppa_h - 1.0f) / u;</a>
<a name="ln762">  mwork[2][2] = 1.0f;</a>
<a name="ln763"> </a>
<a name="ln764">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln765">  MAT3SWAP(minput, moutput);</a>
<a name="ln766">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln767">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln768"> </a>
<a name="ln769"> </a>
<a name="ln770">  // Step 8: vertical compression</a>
<a name="ln771">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln772">  mwork[0][0] = 1.0f;</a>
<a name="ln773">  mwork[1][1] = r_h;</a>
<a name="ln774">  mwork[1][2] = 0.5f * v * (1.0f - r_h);</a>
<a name="ln775">  mwork[2][2] = 1.0f;</a>
<a name="ln776"> </a>
<a name="ln777">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln778">  MAT3SWAP(minput, moutput);</a>
<a name="ln779">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln780">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln781"> </a>
<a name="ln782"> </a>
<a name="ln783">  // Step 9: apply aspect ratio scaling</a>
<a name="ln784">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln785">  mwork[0][0] = 1.0f * ascale;</a>
<a name="ln786">  mwork[1][1] = 1.0f / ascale;</a>
<a name="ln787">  mwork[2][2] = 1.0f;</a>
<a name="ln788"> </a>
<a name="ln789">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln790">  MAT3SWAP(minput, moutput);</a>
<a name="ln791">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln792">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln793"> </a>
<a name="ln794"> </a>
<a name="ln795">  // Step 10: find x/y offsets and apply according correction so that</a>
<a name="ln796">  // no negative coordinates occur in output vector</a>
<a name="ln797">  float umin = FLT_MAX, vmin = FLT_MAX;</a>
<a name="ln798">  // visit all four corners</a>
<a name="ln799">  for(int y = 0; y &lt; height; y += height - 1)</a>
<a name="ln800">    for(int x = 0; x &lt; width; x += width - 1)</a>
<a name="ln801">    {</a>
<a name="ln802">      float pi[3], po[3];</a>
<a name="ln803">      pi[0] = x;</a>
<a name="ln804">      pi[1] = y;</a>
<a name="ln805">      pi[2] = 1.0f;</a>
<a name="ln806">      // moutput expects input in (x:y:1) format and gives output as (x:y:1)</a>
<a name="ln807">      mat3mulv(po, (float *)moutput, pi);</a>
<a name="ln808">      umin = fmin(umin, po[0] / po[2]);</a>
<a name="ln809">      vmin = fmin(vmin, po[1] / po[2]);</a>
<a name="ln810">    }</a>
<a name="ln811"> </a>
<a name="ln812">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln813">  mwork[0][0] = 1.0f;</a>
<a name="ln814">  mwork[1][1] = 1.0f;</a>
<a name="ln815">  mwork[2][2] = 1.0f;</a>
<a name="ln816">  mwork[0][2] = -umin;</a>
<a name="ln817">  mwork[1][2] = -vmin;</a>
<a name="ln818"> </a>
<a name="ln819">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln820">  MAT3SWAP(minput, moutput);</a>
<a name="ln821">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln822">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln823"> </a>
<a name="ln824"> </a>
<a name="ln825">  // on request we either keep the final matrix for forward conversions</a>
<a name="ln826">  // or produce an inverted matrix for backward conversions</a>
<a name="ln827">  if(dir == ASHIFT_HOMOGRAPH_FORWARD)</a>
<a name="ln828">  {</a>
<a name="ln829">    // we have what we need -&gt; copy it to the right place</a>
<a name="ln830">    memcpy(homograph, moutput, 9 * sizeof(float));</a>
<a name="ln831">  }</a>
<a name="ln832">  else</a>
<a name="ln833">  {</a>
<a name="ln834">    // generate inverted homograph (mat3inv function defined in colorspaces.c)</a>
<a name="ln835">    if(mat3inv((float *)homograph, (float *)moutput))</a>
<a name="ln836">    {</a>
<a name="ln837">      // in case of error we set to unity matrix</a>
<a name="ln838">      memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln839">      mwork[0][0] = 1.0f;</a>
<a name="ln840">      mwork[1][1] = 1.0f;</a>
<a name="ln841">      mwork[2][2] = 1.0f;</a>
<a name="ln842">      memcpy(homograph, mwork, 9 * sizeof(float));</a>
<a name="ln843">    }</a>
<a name="ln844">  }</a>
<a name="ln845">}</a>
<a name="ln846">#undef MAT3SWAP</a>
<a name="ln847"> </a>
<a name="ln848"> </a>
<a name="ln849">// check if module parameters are set to all neutral values in which case the module's</a>
<a name="ln850">// output is identical to its input</a>
<a name="ln851">static inline int isneutral(dt_iop_ashift_data_t *data)</a>
<a name="ln852">{</a>
<a name="ln853">  // values lower than this have no visible effect</a>
<a name="ln854">  const float eps = 1.0e-4f;</a>
<a name="ln855"> </a>
<a name="ln856">  return(fabs(data-&gt;rotation) &lt; eps &amp;&amp;</a>
<a name="ln857">         fabs(data-&gt;lensshift_v) &lt; eps &amp;&amp;</a>
<a name="ln858">         fabs(data-&gt;lensshift_h) &lt; eps &amp;&amp;</a>
<a name="ln859">         fabs(data-&gt;shear) &lt; eps &amp;&amp;</a>
<a name="ln860">         fabs(data-&gt;aspect - 1.0f) &lt; eps &amp;&amp;</a>
<a name="ln861">         data-&gt;cl &lt; eps &amp;&amp;</a>
<a name="ln862">         1.0f - data-&gt;cr &lt; eps &amp;&amp;</a>
<a name="ln863">         data-&gt;ct &lt; eps &amp;&amp;</a>
<a name="ln864">         1.0f - data-&gt;cb &lt; eps);</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867"> </a>
<a name="ln868">int distort_transform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points, size_t points_count)</a>
<a name="ln869">{</a>
<a name="ln870">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln871"> </a>
<a name="ln872">  // nothing to be done if parameters are set to neutral values</a>
<a name="ln873">  if(isneutral(data)) return 1;</a>
<a name="ln874"> </a>
<a name="ln875">  float homograph[3][3];</a>
<a name="ln876">  homography((float *)homograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln877">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln878"> </a>
<a name="ln879">  // clipping offset</a>
<a name="ln880">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln881">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln882">  const float cx = fullwidth * data-&gt;cl;</a>
<a name="ln883">  const float cy = fullheight * data-&gt;ct;</a>
<a name="ln884"> </a>
<a name="ln885">#ifdef _OPENMP</a>
<a name="ln886">#pragma omp parallel for default(none) \</a>
<a name="ln887">  dt_omp_firstprivate(cx, cy) \</a>
<a name="ln888">  shared(points, points_count, homograph) \</a>
<a name="ln889">  schedule(static)</a>
<a name="ln890">#endif</a>
<a name="ln891">  for(size_t i = 0; i &lt; points_count * 2; i += 2)</a>
<a name="ln892">  {</a>
<a name="ln893">    float pi[3] = { points[i], points[i + 1], 1.0f };</a>
<a name="ln894">    float po[3];</a>
<a name="ln895">    mat3mulv(po, (float *)homograph, pi);</a>
<a name="ln896">    points[i] = po[0] / po[2] - cx;</a>
<a name="ln897">    points[i + 1] = po[1] / po[2] - cy;</a>
<a name="ln898">  }</a>
<a name="ln899"> </a>
<a name="ln900">  return 1;</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903"> </a>
<a name="ln904">int distort_backtransform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points,</a>
<a name="ln905">                          size_t points_count)</a>
<a name="ln906">{</a>
<a name="ln907">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln908"> </a>
<a name="ln909">  // nothing to be done if parameters are set to neutral values</a>
<a name="ln910">  if(isneutral(data)) return 1;</a>
<a name="ln911"> </a>
<a name="ln912">  float ihomograph[3][3];</a>
<a name="ln913">  homography((float *)ihomograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln914">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln915"> </a>
<a name="ln916">  // clipping offset</a>
<a name="ln917">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln918">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln919">  const float cx = fullwidth * data-&gt;cl;</a>
<a name="ln920">  const float cy = fullheight * data-&gt;ct;</a>
<a name="ln921"> </a>
<a name="ln922">#ifdef _OPENMP</a>
<a name="ln923">#pragma omp parallel for default(none) \</a>
<a name="ln924">  dt_omp_firstprivate(cx, cy) \</a>
<a name="ln925">  shared(points, points_count, ihomograph) \</a>
<a name="ln926">  schedule(static)</a>
<a name="ln927">#endif</a>
<a name="ln928">  for(size_t i = 0; i &lt; points_count * 2; i += 2)</a>
<a name="ln929">  {</a>
<a name="ln930">    float pi[3] = { points[i] + cx, points[i + 1] + cy, 1.0f };</a>
<a name="ln931">    float po[3];</a>
<a name="ln932">    mat3mulv(po, (float *)ihomograph, pi);</a>
<a name="ln933">    points[i] = po[0] / po[2];</a>
<a name="ln934">    points[i + 1] = po[1] / po[2];</a>
<a name="ln935">  }</a>
<a name="ln936"> </a>
<a name="ln937">  return 1;</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940">void distort_mask(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln941">                  float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln942">{</a>
<a name="ln943">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln944"> </a>
<a name="ln945">  // if module is set to neutral parameters we just copy input-&gt;output and are done</a>
<a name="ln946">  if(isneutral(data))</a>
<a name="ln947">  {</a>
<a name="ln948">    memcpy(out, in, (size_t)roi_out-&gt;width * roi_out-&gt;height * sizeof(float));</a>
<a name="ln949">    return;</a>
<a name="ln950">  }</a>
<a name="ln951"> </a>
<a name="ln952">  const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln953"> </a>
<a name="ln954">  float ihomograph[3][3];</a>
<a name="ln955">  homography((float *)ihomograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln956">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln957"> </a>
<a name="ln958">  // clipping offset</a>
<a name="ln959">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln960">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln961">  const float cx = roi_out-&gt;scale * fullwidth * data-&gt;cl;</a>
<a name="ln962">  const float cy = roi_out-&gt;scale * fullheight * data-&gt;ct;</a>
<a name="ln963"> </a>
<a name="ln964"> </a>
<a name="ln965">#ifdef _OPENMP</a>
<a name="ln966">#pragma omp parallel for default(none) \</a>
<a name="ln967">  dt_omp_firstprivate(cx, cy, in, out, roi_in, roi_out) \</a>
<a name="ln968">  shared(ihomograph, interpolation) \</a>
<a name="ln969">  schedule(static)</a>
<a name="ln970">#endif</a>
<a name="ln971">  // go over all pixels of output image</a>
<a name="ln972">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln973">  {</a>
<a name="ln974">    float *_out = out + (size_t)j * roi_out-&gt;width;</a>
<a name="ln975">    for(int i = 0; i &lt; roi_out-&gt;width; i++, _out++)</a>
<a name="ln976">    {</a>
<a name="ln977">      float pin[3], pout[3];</a>
<a name="ln978"> </a>
<a name="ln979">      // convert output pixel coordinates to original image coordinates</a>
<a name="ln980">      pout[0] = roi_out-&gt;x + i + cx;</a>
<a name="ln981">      pout[1] = roi_out-&gt;y + j + cy;</a>
<a name="ln982">      pout[0] /= roi_out-&gt;scale;</a>
<a name="ln983">      pout[1] /= roi_out-&gt;scale;</a>
<a name="ln984">      pout[2] = 1.0f;</a>
<a name="ln985"> </a>
<a name="ln986">      // apply homograph</a>
<a name="ln987">      mat3mulv(pin, (float *)ihomograph, pout);</a>
<a name="ln988"> </a>
<a name="ln989">      // convert to input pixel coordinates</a>
<a name="ln990">      pin[0] /= pin[2];</a>
<a name="ln991">      pin[1] /= pin[2];</a>
<a name="ln992">      pin[0] *= roi_in-&gt;scale;</a>
<a name="ln993">      pin[1] *= roi_in-&gt;scale;</a>
<a name="ln994">      pin[0] -= roi_in-&gt;x;</a>
<a name="ln995">      pin[1] -= roi_in-&gt;y;</a>
<a name="ln996"> </a>
<a name="ln997">      // get output values by interpolation from input image</a>
<a name="ln998">      dt_interpolation_compute_pixel1c(interpolation, in, _out, pin[0], pin[1], roi_in-&gt;width,</a>
<a name="ln999">                                       roi_in-&gt;height, roi_in-&gt;width);</a>
<a name="ln1000">    }</a>
<a name="ln1001">  }</a>
<a name="ln1002">}</a>
<a name="ln1003"> </a>
<a name="ln1004">void modify_roi_out(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, dt_iop_roi_t *roi_out,</a>
<a name="ln1005">                    const dt_iop_roi_t *roi_in)</a>
<a name="ln1006">{</a>
<a name="ln1007">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln1008">  *roi_out = *roi_in;</a>
<a name="ln1009"> </a>
<a name="ln1010">  // nothing more to be done if parameters are set to neutral values</a>
<a name="ln1011">  if(isneutral(data)) return;</a>
<a name="ln1012"> </a>
<a name="ln1013">  float homograph[3][3];</a>
<a name="ln1014">  homography((float *)homograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln1015">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln1016"> </a>
<a name="ln1017">  float xm = FLT_MAX, xM = -FLT_MAX, ym = FLT_MAX, yM = -FLT_MAX;</a>
<a name="ln1018"> </a>
<a name="ln1019">  // go through all four vertices of input roi and convert coordinates to output</a>
<a name="ln1020">  for(int y = 0; y &lt; roi_in-&gt;height; y += roi_in-&gt;height - 1)</a>
<a name="ln1021">  {</a>
<a name="ln1022">    for(int x = 0; x &lt; roi_in-&gt;width; x += roi_in-&gt;width - 1)</a>
<a name="ln1023">    {</a>
<a name="ln1024">      float pin[3], pout[3];</a>
<a name="ln1025"> </a>
<a name="ln1026">      // convert from input coordinates to original image coordinates</a>
<a name="ln1027">      pin[0] = roi_in-&gt;x + x;</a>
<a name="ln1028">      pin[1] = roi_in-&gt;y + y;</a>
<a name="ln1029">      pin[0] /= roi_in-&gt;scale;</a>
<a name="ln1030">      pin[1] /= roi_in-&gt;scale;</a>
<a name="ln1031">      pin[2] = 1.0f;</a>
<a name="ln1032"> </a>
<a name="ln1033">      // apply homograph</a>
<a name="ln1034">      mat3mulv(pout, (float *)homograph, pin);</a>
<a name="ln1035"> </a>
<a name="ln1036">      // convert to output image coordinates</a>
<a name="ln1037">      pout[0] /= pout[2];</a>
<a name="ln1038">      pout[1] /= pout[2];</a>
<a name="ln1039">      pout[0] *= roi_out-&gt;scale;</a>
<a name="ln1040">      pout[1] *= roi_out-&gt;scale;</a>
<a name="ln1041">      xm = MIN(xm, pout[0]);</a>
<a name="ln1042">      xM = MAX(xM, pout[0]);</a>
<a name="ln1043">      ym = MIN(ym, pout[1]);</a>
<a name="ln1044">      yM = MAX(yM, pout[1]);</a>
<a name="ln1045">    }</a>
<a name="ln1046">  }</a>
<a name="ln1047">  float width = xM - xm + 1;</a>
<a name="ln1048">  float height = yM - ym + 1;</a>
<a name="ln1049"> </a>
<a name="ln1050">  // clipping adjustments</a>
<a name="ln1051">  width *= data-&gt;cr - data-&gt;cl;</a>
<a name="ln1052">  height *= data-&gt;cb - data-&gt;ct;</a>
<a name="ln1053"> </a>
<a name="ln1054">  roi_out-&gt;width = floorf(width);</a>
<a name="ln1055">  roi_out-&gt;height = floorf(height);</a>
<a name="ln1056"> </a>
<a name="ln1057">#ifdef ASHIFT_DEBUG</a>
<a name="ln1058">  print_roi(roi_in, &quot;roi_in (going into modify_roi_out)&quot;);</a>
<a name="ln1059">  print_roi(roi_out, &quot;roi_out (after modify_roi_out)&quot;);</a>
<a name="ln1060">#endif</a>
<a name="ln1061">}</a>
<a name="ln1062"> </a>
<a name="ln1063">void modify_roi_in(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1064">                   const dt_iop_roi_t *const roi_out, dt_iop_roi_t *roi_in)</a>
<a name="ln1065">{</a>
<a name="ln1066">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln1067">  *roi_in = *roi_out;</a>
<a name="ln1068"> </a>
<a name="ln1069">  // nothing more to be done if parameters are set to neutral values</a>
<a name="ln1070">  if(isneutral(data)) return;</a>
<a name="ln1071"> </a>
<a name="ln1072">  float ihomograph[3][3];</a>
<a name="ln1073">  homography((float *)ihomograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln1074">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln1075"> </a>
<a name="ln1076">  const float orig_w = roi_in-&gt;scale * piece-&gt;buf_in.width;</a>
<a name="ln1077">  const float orig_h = roi_in-&gt;scale * piece-&gt;buf_in.height;</a>
<a name="ln1078"> </a>
<a name="ln1079">  // clipping offset</a>
<a name="ln1080">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln1081">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln1082">  const float cx = roi_out-&gt;scale * fullwidth * data-&gt;cl;</a>
<a name="ln1083">  const float cy = roi_out-&gt;scale * fullheight * data-&gt;ct;</a>
<a name="ln1084"> </a>
<a name="ln1085">  float xm = FLT_MAX, xM = -FLT_MAX, ym = FLT_MAX, yM = -FLT_MAX;</a>
<a name="ln1086"> </a>
<a name="ln1087">  // go through all four vertices of output roi and convert coordinates to input</a>
<a name="ln1088">  for(int y = 0; y &lt; roi_out-&gt;height; y += roi_out-&gt;height - 1)</a>
<a name="ln1089">  {</a>
<a name="ln1090">    for(int x = 0; x &lt; roi_out-&gt;width; x += roi_out-&gt;width - 1)</a>
<a name="ln1091">    {</a>
<a name="ln1092">      float pin[3], pout[3];</a>
<a name="ln1093"> </a>
<a name="ln1094">      // convert from output image coordinates to original image coordinates</a>
<a name="ln1095">      pout[0] = roi_out-&gt;x + x + cx;</a>
<a name="ln1096">      pout[1] = roi_out-&gt;y + y + cy;</a>
<a name="ln1097">      pout[0] /= roi_out-&gt;scale;</a>
<a name="ln1098">      pout[1] /= roi_out-&gt;scale;</a>
<a name="ln1099">      pout[2] = 1.0f;</a>
<a name="ln1100"> </a>
<a name="ln1101">      // apply homograph</a>
<a name="ln1102">      mat3mulv(pin, (float *)ihomograph, pout);</a>
<a name="ln1103"> </a>
<a name="ln1104">      // convert to input image coordinates</a>
<a name="ln1105">      pin[0] /= pin[2];</a>
<a name="ln1106">      pin[1] /= pin[2];</a>
<a name="ln1107">      pin[0] *= roi_in-&gt;scale;</a>
<a name="ln1108">      pin[1] *= roi_in-&gt;scale;</a>
<a name="ln1109">      xm = MIN(xm, pin[0]);</a>
<a name="ln1110">      xM = MAX(xM, pin[0]);</a>
<a name="ln1111">      ym = MIN(ym, pin[1]);</a>
<a name="ln1112">      yM = MAX(yM, pin[1]);</a>
<a name="ln1113">    }</a>
<a name="ln1114">  }</a>
<a name="ln1115"> </a>
<a name="ln1116">  const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln1117">  roi_in-&gt;x = fmaxf(0.0f, xm - interpolation-&gt;width);</a>
<a name="ln1118">  roi_in-&gt;y = fmaxf(0.0f, ym - interpolation-&gt;width);</a>
<a name="ln1119">  roi_in-&gt;width = fminf(ceilf(orig_w) - roi_in-&gt;x, xM - roi_in-&gt;x + 1 + interpolation-&gt;width);</a>
<a name="ln1120">  roi_in-&gt;height = fminf(ceilf(orig_h) - roi_in-&gt;y, yM - roi_in-&gt;y + 1 + interpolation-&gt;width);</a>
<a name="ln1121"> </a>
<a name="ln1122">  // sanity check.</a>
<a name="ln1123">  roi_in-&gt;x = CLAMP(roi_in-&gt;x, 0, (int)floorf(orig_w));</a>
<a name="ln1124">  roi_in-&gt;y = CLAMP(roi_in-&gt;y, 0, (int)floorf(orig_h));</a>
<a name="ln1125">  roi_in-&gt;width = CLAMP(roi_in-&gt;width, 1, (int)floorf(orig_w) - roi_in-&gt;x);</a>
<a name="ln1126">  roi_in-&gt;height = CLAMP(roi_in-&gt;height, 1, (int)floorf(orig_h) - roi_in-&gt;y);</a>
<a name="ln1127">#ifdef ASHIFT_DEBUG</a>
<a name="ln1128">  print_roi(roi_out, &quot;roi_out (going into modify_roi_in)&quot;);</a>
<a name="ln1129">  print_roi(roi_in, &quot;roi_in (after modify_roi_in)&quot;);</a>
<a name="ln1130">#endif</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133">// simple conversion of rgb image into greyscale variant suitable for line segment detection</a>
<a name="ln1134">// the lsd routines expect input as *double, roughly in the range [0.0; 256.0]</a>
<a name="ln1135">static void rgb2grey256(const float *in, double *out, const int width, const int height)</a>
<a name="ln1136">{</a>
<a name="ln1137">  const int ch = 4;</a>
<a name="ln1138"> </a>
<a name="ln1139">#ifdef _OPENMP</a>
<a name="ln1140">#pragma omp parallel for default(none) \</a>
<a name="ln1141">  dt_omp_firstprivate(height, width, ch) \</a>
<a name="ln1142">  shared(in, out) \</a>
<a name="ln1143">  schedule(static)</a>
<a name="ln1144">#endif</a>
<a name="ln1145">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1146">  {</a>
<a name="ln1147">    const float *inp = in + (size_t)ch * j * width;</a>
<a name="ln1148">    double *outp = out + (size_t)j * width;</a>
<a name="ln1149">    for(int i = 0; i &lt; width; i++, inp += ch, outp++)</a>
<a name="ln1150">    {</a>
<a name="ln1151">      *outp = (0.3f * inp[0] + 0.59f * inp[1] + 0.11f * inp[2]) * 256.0;</a>
<a name="ln1152">    }</a>
<a name="ln1153">  }</a>
<a name="ln1154">}</a>
<a name="ln1155"> </a>
<a name="ln1156">// sobel edge enhancement in one direction</a>
<a name="ln1157">static void edge_enhance_1d(const double *in, double *out, const int width, const int height,</a>
<a name="ln1158">                            dt_iop_ashift_enhance_t dir)</a>
<a name="ln1159">{</a>
<a name="ln1160">  // Sobel kernels for both directions</a>
<a name="ln1161">  const double hkernel[3][3] = { { 1.0, 0.0, -1.0 }, { 2.0, 0.0, -2.0 }, { 1.0, 0.0, -1.0 } };</a>
<a name="ln1162">  const double vkernel[3][3] = { { 1.0, 2.0, 1.0 }, { 0.0, 0.0, 0.0 }, { -1.0, -2.0, -1.0 } };</a>
<a name="ln1163">  const int kwidth = 3;</a>
<a name="ln1164">  const int khwidth = kwidth / 2;</a>
<a name="ln1165"> </a>
<a name="ln1166">  // select kernel</a>
<a name="ln1167">  const double *kernel = (dir == ASHIFT_ENHANCE_HORIZONTAL) ? (const double *)hkernel : (const double *)vkernel;</a>
<a name="ln1168"> </a>
<a name="ln1169">#ifdef _OPENMP</a>
<a name="ln1170">#pragma omp parallel for default(none) \</a>
<a name="ln1171">  dt_omp_firstprivate(height, width, khwidth, kwidth) \</a>
<a name="ln1172">  shared(in, out, kernel) \</a>
<a name="ln1173">  schedule(static)</a>
<a name="ln1174">#endif</a>
<a name="ln1175">  // loop over image pixels and perform sobel convolution</a>
<a name="ln1176">  for(int j = khwidth; j &lt; height - khwidth; j++)</a>
<a name="ln1177">  {</a>
<a name="ln1178">    const double *inp = in + (size_t)j * width + khwidth;</a>
<a name="ln1179">    double *outp = out + (size_t)j * width + khwidth;</a>
<a name="ln1180">    for(int i = khwidth; i &lt; width - khwidth; i++, inp++, outp++)</a>
<a name="ln1181">    {</a>
<a name="ln1182">      double sum = 0.0f;</a>
<a name="ln1183">      for(int jj = 0; jj &lt; kwidth; jj++)</a>
<a name="ln1184">      {</a>
<a name="ln1185">        const int k = jj * kwidth;</a>
<a name="ln1186">        const int l = (jj - khwidth) * width;</a>
<a name="ln1187">        for(int ii = 0; ii &lt; kwidth; ii++)</a>
<a name="ln1188">        {</a>
<a name="ln1189">          sum += inp[l + ii - khwidth] * kernel[k + ii];</a>
<a name="ln1190">        }</a>
<a name="ln1191">      }</a>
<a name="ln1192">      *outp = sum;</a>
<a name="ln1193">    }</a>
<a name="ln1194">  }</a>
<a name="ln1195"> </a>
<a name="ln1196">#ifdef _OPENMP</a>
<a name="ln1197">#pragma omp parallel for default(none) \</a>
<a name="ln1198">  dt_omp_firstprivate(height, width, khwidth) \</a>
<a name="ln1199">  shared(out) \</a>
<a name="ln1200">  schedule(static)</a>
<a name="ln1201">#endif</a>
<a name="ln1202">  // border fill in output buffer, so we don't get pseudo lines at image frame</a>
<a name="ln1203">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1204">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln1205">    {</a>
<a name="ln1206">      double val = out[j * width + i];</a>
<a name="ln1207"> </a>
<a name="ln1208">      if(j &lt; khwidth)</a>
<a name="ln1209">        val = out[(khwidth - j) * width + i];</a>
<a name="ln1210">      else if(j &gt;= height - khwidth)</a>
<a name="ln1211">        val = out[(j - khwidth) * width + i];</a>
<a name="ln1212">      else if(i &lt; khwidth)</a>
<a name="ln1213">        val = out[j * width + (khwidth - i)];</a>
<a name="ln1214">      else if(i &gt;= width - khwidth)</a>
<a name="ln1215">        val = out[j * width + (i - khwidth)];</a>
<a name="ln1216"> </a>
<a name="ln1217">      out[j * width + i] = val;</a>
<a name="ln1218"> </a>
<a name="ln1219">      // jump over center of image</a>
<a name="ln1220">      if(i == khwidth &amp;&amp; j &gt;= khwidth &amp;&amp; j &lt; height - khwidth) i = width - khwidth;</a>
<a name="ln1221">    }</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">// edge enhancement in both directions</a>
<a name="ln1225">static int edge_enhance(const double *in, double *out, const int width, const int height)</a>
<a name="ln1226">{</a>
<a name="ln1227">  double *Gx = NULL;</a>
<a name="ln1228">  double *Gy = NULL;</a>
<a name="ln1229"> </a>
<a name="ln1230">  Gx = malloc((size_t)width * height * sizeof(double));</a>
<a name="ln1231">  if(Gx == NULL) goto error;</a>
<a name="ln1232"> </a>
<a name="ln1233">  Gy = malloc((size_t)width * height * sizeof(double));</a>
<a name="ln1234">  if(Gy == NULL) goto error;</a>
<a name="ln1235"> </a>
<a name="ln1236">  // perform edge enhancement in both directions</a>
<a name="ln1237">  edge_enhance_1d(in, Gx, width, height, ASHIFT_ENHANCE_HORIZONTAL);</a>
<a name="ln1238">  edge_enhance_1d(in, Gy, width, height, ASHIFT_ENHANCE_VERTICAL);</a>
<a name="ln1239"> </a>
<a name="ln1240">// calculate absolute values</a>
<a name="ln1241">#ifdef _OPENMP</a>
<a name="ln1242">#pragma omp parallel for default(none) \</a>
<a name="ln1243">  dt_omp_firstprivate(height, width) \</a>
<a name="ln1244">  shared(Gx, Gy, out) \</a>
<a name="ln1245">  schedule(static)</a>
<a name="ln1246">#endif</a>
<a name="ln1247">  for(size_t k = 0; k &lt; (size_t)width * height; k++)</a>
<a name="ln1248">  {</a>
<a name="ln1249">    out[k] = sqrt(Gx[k] * Gx[k] + Gy[k] * Gy[k]);</a>
<a name="ln1250">  }</a>
<a name="ln1251"> </a>
<a name="ln1252">  free(Gx);</a>
<a name="ln1253">  free(Gy);</a>
<a name="ln1254">  return TRUE;</a>
<a name="ln1255"> </a>
<a name="ln1256">error:</a>
<a name="ln1257">  if(Gx) free(Gx);</a>
<a name="ln1258">  if(Gy) free(Gy);</a>
<a name="ln1259">  return FALSE;</a>
<a name="ln1260">}</a>
<a name="ln1261"> </a>
<a name="ln1262">// XYZ -&gt; sRGB matrix</a>
<a name="ln1263">static void XYZ_to_sRGB(const float *XYZ, float *sRGB)</a>
<a name="ln1264">{</a>
<a name="ln1265">  sRGB[0] =  3.1338561f * XYZ[0] - 1.6168667f * XYZ[1] - 0.4906146f * XYZ[2];</a>
<a name="ln1266">  sRGB[1] = -0.9787684f * XYZ[0] + 1.9161415f * XYZ[1] + 0.0334540f * XYZ[2];</a>
<a name="ln1267">  sRGB[2] =  0.0719453f * XYZ[0] - 0.2289914f * XYZ[1] + 1.4052427f * XYZ[2];</a>
<a name="ln1268">}</a>
<a name="ln1269"> </a>
<a name="ln1270">// sRGB -&gt; XYZ matrix</a>
<a name="ln1271">static void sRGB_to_XYZ(const float *sRGB, float *XYZ)</a>
<a name="ln1272">{</a>
<a name="ln1273">  XYZ[0] = 0.4360747f * sRGB[0] + 0.3850649f * sRGB[1] + 0.1430804f * sRGB[2];</a>
<a name="ln1274">  XYZ[1] = 0.2225045f * sRGB[0] + 0.7168786f * sRGB[1] + 0.0606169f * sRGB[2];</a>
<a name="ln1275">  XYZ[2] = 0.0139322f * sRGB[0] + 0.0971045f * sRGB[1] + 0.7141733f * sRGB[2];</a>
<a name="ln1276">}</a>
<a name="ln1277"> </a>
<a name="ln1278">// detail enhancement via bilateral grid (function arguments in and out may represent identical buffers)</a>
<a name="ln1279">static int detail_enhance(const float *in, float *out, const int width, const int height)</a>
<a name="ln1280">{</a>
<a name="ln1281">  const float sigma_r = 5.0f;</a>
<a name="ln1282">  const float sigma_s = fminf(width, height) * 0.02f;</a>
<a name="ln1283">  const float detail = 10.0f;</a>
<a name="ln1284"> </a>
<a name="ln1285">  int success = TRUE;</a>
<a name="ln1286"> </a>
<a name="ln1287">  // we need to convert from RGB to Lab first;</a>
<a name="ln1288">  // as colors don't matter we are safe to assume data to be sRGB</a>
<a name="ln1289"> </a>
<a name="ln1290">  // convert RGB input to Lab, use output buffer for intermediate storage</a>
<a name="ln1291">#ifdef _OPENMP</a>
<a name="ln1292">#pragma omp parallel for default(none) \</a>
<a name="ln1293">  dt_omp_firstprivate(height, width) \</a>
<a name="ln1294">  shared(in, out) \</a>
<a name="ln1295">  schedule(static)</a>
<a name="ln1296">#endif</a>
<a name="ln1297">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1298">  {</a>
<a name="ln1299">    const float *inp = in + (size_t)4 * j * width;</a>
<a name="ln1300">    float *outp = out + (size_t)4 * j * width;</a>
<a name="ln1301">    for(int i = 0; i &lt; width; i++, inp += 4, outp += 4)</a>
<a name="ln1302">    {</a>
<a name="ln1303">      float XYZ[3];</a>
<a name="ln1304">      sRGB_to_XYZ(inp, XYZ);</a>
<a name="ln1305">      dt_XYZ_to_Lab(XYZ, outp);</a>
<a name="ln1306">    }</a>
<a name="ln1307">  }</a>
<a name="ln1308"> </a>
<a name="ln1309">  // bilateral grid detail enhancement</a>
<a name="ln1310">  dt_bilateral_t *b = dt_bilateral_init(width, height, sigma_s, sigma_r);</a>
<a name="ln1311"> </a>
<a name="ln1312">  if(b != NULL)</a>
<a name="ln1313">  {</a>
<a name="ln1314">    dt_bilateral_splat(b, out);</a>
<a name="ln1315">    dt_bilateral_blur(b);</a>
<a name="ln1316">    dt_bilateral_slice_to_output(b, out, out, detail);</a>
<a name="ln1317">    dt_bilateral_free(b);</a>
<a name="ln1318">  }</a>
<a name="ln1319">  else</a>
<a name="ln1320">    success = FALSE;</a>
<a name="ln1321"> </a>
<a name="ln1322">  // convert resulting Lab to RGB output</a>
<a name="ln1323">#ifdef _OPENMP</a>
<a name="ln1324">#pragma omp parallel for default(none) \</a>
<a name="ln1325">  dt_omp_firstprivate(height, width) \</a>
<a name="ln1326">  shared(out) \</a>
<a name="ln1327">  schedule(static)</a>
<a name="ln1328">#endif</a>
<a name="ln1329">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1330">  {</a>
<a name="ln1331">    float *outp = out + (size_t)4 * j * width;</a>
<a name="ln1332">    for(int i = 0; i &lt; width; i++, outp += 4)</a>
<a name="ln1333">    {</a>
<a name="ln1334">      float XYZ[3];</a>
<a name="ln1335">      dt_Lab_to_XYZ(outp, XYZ);</a>
<a name="ln1336">      XYZ_to_sRGB(XYZ, outp);</a>
<a name="ln1337">    }</a>
<a name="ln1338">  }</a>
<a name="ln1339"> </a>
<a name="ln1340">  return success;</a>
<a name="ln1341">}</a>
<a name="ln1342"> </a>
<a name="ln1343">// apply gamma correction to RGB buffer (function arguments in and out may represent identical buffers)</a>
<a name="ln1344">static void gamma_correct(const float *in, float *out, const int width, const int height)</a>
<a name="ln1345">{</a>
<a name="ln1346">#ifdef _OPENMP</a>
<a name="ln1347">#pragma omp parallel for default(none) \</a>
<a name="ln1348">  dt_omp_firstprivate(height, width) \</a>
<a name="ln1349">  shared(in, out) \</a>
<a name="ln1350">  schedule(static)</a>
<a name="ln1351">#endif</a>
<a name="ln1352">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1353">  {</a>
<a name="ln1354">    const float *inp = in + (size_t)4 * j * width;</a>
<a name="ln1355">    float *outp = out + (size_t)4 * j * width;</a>
<a name="ln1356">    for(int i = 0; i &lt; width; i++, inp += 4, outp += 4)</a>
<a name="ln1357">    {</a>
<a name="ln1358">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1359">        outp[c] = powf(inp[c], LSD_GAMMA);</a>
<a name="ln1360">    }</a>
<a name="ln1361">  }</a>
<a name="ln1362">}</a>
<a name="ln1363"> </a>
<a name="ln1364">// do actual line_detection based on LSD algorithm and return results according</a>
<a name="ln1365">// to this module's conventions</a>
<a name="ln1366">static int line_detect(float *in, const int width, const int height, const int x_off, const int y_off,</a>
<a name="ln1367">                       const float scale, dt_iop_ashift_line_t **alines, int *lcount, int *vcount, int *hcount,</a>
<a name="ln1368">                       float *vweight, float *hweight, dt_iop_ashift_enhance_t enhance, const int is_raw)</a>
<a name="ln1369">{</a>
<a name="ln1370">  double *greyscale = NULL;</a>
<a name="ln1371">  double *lsd_lines = NULL;</a>
<a name="ln1372">  dt_iop_ashift_line_t *ashift_lines = NULL;</a>
<a name="ln1373"> </a>
<a name="ln1374">  int vertical_count = 0;</a>
<a name="ln1375">  int horizontal_count = 0;</a>
<a name="ln1376">  float vertical_weight = 0.0f;</a>
<a name="ln1377">  float horizontal_weight = 0.0f;</a>
<a name="ln1378"> </a>
<a name="ln1379">  // apply gamma correction if image is raw</a>
<a name="ln1380">  if(is_raw)</a>
<a name="ln1381">  {</a>
<a name="ln1382">    gamma_correct(in, in, width, height);</a>
<a name="ln1383">  }</a>
<a name="ln1384"> </a>
<a name="ln1385">  // if requested perform an additional detail enhancement step</a>
<a name="ln1386">  if(enhance &amp; ASHIFT_ENHANCE_DETAIL)</a>
<a name="ln1387">  {</a>
<a name="ln1388">    (void)detail_enhance(in, in, width, height);</a>
<a name="ln1389">  }</a>
<a name="ln1390"> </a>
<a name="ln1391">  // allocate intermediate buffers</a>
<a name="ln1392">  greyscale = malloc((size_t)width * height * sizeof(double));</a>
<a name="ln1393">  if(greyscale == NULL) goto error;</a>
<a name="ln1394"> </a>
<a name="ln1395">  // convert to greyscale image</a>
<a name="ln1396">  rgb2grey256(in, greyscale, width, height);</a>
<a name="ln1397"> </a>
<a name="ln1398">  // if requested perform an additional edge enhancement step</a>
<a name="ln1399">  if(enhance &amp; ASHIFT_ENHANCE_EDGES)</a>
<a name="ln1400">  {</a>
<a name="ln1401">    (void)edge_enhance(greyscale, greyscale, width, height);</a>
<a name="ln1402">  }</a>
<a name="ln1403"> </a>
<a name="ln1404">  // call the line segment detector LSD;</a>
<a name="ln1405">  // LSD stores the number of found lines in lines_count.</a>
<a name="ln1406">  // it returns structural details as vector 'double lines[7 * lines_count]'</a>
<a name="ln1407">  int lines_count;</a>
<a name="ln1408">  lsd_lines = LineSegmentDetection(&amp;lines_count, greyscale, width, height,</a>
<a name="ln1409">                                   LSD_SCALE, LSD_SIGMA_SCALE, LSD_QUANT,</a>
<a name="ln1410">                                   LSD_ANG_TH, LSD_LOG_EPS, LSD_DENSITY_TH,</a>
<a name="ln1411">                                   LSD_N_BINS, NULL, NULL, NULL);</a>
<a name="ln1412"> </a>
<a name="ln1413">  // we count the lines that we really want to use</a>
<a name="ln1414">  int lct = 0;</a>
<a name="ln1415"> </a>
<a name="ln1416">  if(lines_count &gt; 0)</a>
<a name="ln1417">  {</a>
<a name="ln1418">    // aggregate lines data into our own structures</a>
<a name="ln1419">    ashift_lines = (dt_iop_ashift_line_t *)malloc((size_t)lines_count * sizeof(dt_iop_ashift_line_t));</a>
<a name="ln1420">    if(ashift_lines == NULL) goto error;</a>
<a name="ln1421"> </a>
<a name="ln1422">    for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln1423">    {</a>
<a name="ln1424">      float x1 = lsd_lines[n * 7 + 0];</a>
<a name="ln1425">      float y1 = lsd_lines[n * 7 + 1];</a>
<a name="ln1426">      float x2 = lsd_lines[n * 7 + 2];</a>
<a name="ln1427">      float y2 = lsd_lines[n * 7 + 3];</a>
<a name="ln1428"> </a>
<a name="ln1429">      // check for lines running along image borders and skip them.</a>
<a name="ln1430">      // these would likely be false-positives which could result</a>
<a name="ln1431">      // from any kind of processing artifacts</a>
<a name="ln1432">      if((fabs(x1 - x2) &lt; 1 &amp;&amp; fmax(x1, x2) &lt; 2) ||</a>
<a name="ln1433">         (fabs(x1 - x2) &lt; 1 &amp;&amp; fmin(x1, x2) &gt; width - 3) ||</a>
<a name="ln1434">         (fabs(y1 - y2) &lt; 1 &amp;&amp; fmax(y1, y2) &lt; 2) ||</a>
<a name="ln1435">         (fabs(y1 - y2) &lt; 1 &amp;&amp; fmin(y1, y2) &gt; height - 3))</a>
<a name="ln1436">        continue;</a>
<a name="ln1437"> </a>
<a name="ln1438">      // line position in absolute coordinates</a>
<a name="ln1439">      float px1 = x_off + x1;</a>
<a name="ln1440">      float py1 = y_off + y1;</a>
<a name="ln1441">      float px2 = x_off + x2;</a>
<a name="ln1442">      float py2 = y_off + y2;</a>
<a name="ln1443"> </a>
<a name="ln1444">      // scale back to input buffer</a>
<a name="ln1445">      px1 /= scale;</a>
<a name="ln1446">      py1 /= scale;</a>
<a name="ln1447">      px2 /= scale;</a>
<a name="ln1448">      py2 /= scale;</a>
<a name="ln1449"> </a>
<a name="ln1450">      // store as homogeneous coordinates</a>
<a name="ln1451">      ashift_lines[lct].p1[0] = px1;</a>
<a name="ln1452">      ashift_lines[lct].p1[1] = py1;</a>
<a name="ln1453">      ashift_lines[lct].p1[2] = 1.0f;</a>
<a name="ln1454">      ashift_lines[lct].p2[0] = px2;</a>
<a name="ln1455">      ashift_lines[lct].p2[1] = py2;</a>
<a name="ln1456">      ashift_lines[lct].p2[2] = 1.0f;</a>
<a name="ln1457"> </a>
<a name="ln1458">      // calculate homogeneous coordinates of connecting line (defined by the two points)</a>
<a name="ln1459">      vec3prodn(ashift_lines[lct].L, ashift_lines[lct].p1, ashift_lines[lct].p2);</a>
<a name="ln1460"> </a>
<a name="ln1461">      // normalaze line coordinates so that x^2 + y^2 = 1</a>
<a name="ln1462">      // (this will always succeed as L is a real line connecting two real points)</a>
<a name="ln1463">      vec3lnorm(ashift_lines[lct].L, ashift_lines[lct].L);</a>
<a name="ln1464"> </a>
<a name="ln1465">      // length and width of rectangle (see LSD)</a>
<a name="ln1466">      ashift_lines[lct].length = sqrt((px2 - px1) * (px2 - px1) + (py2 - py1) * (py2 - py1));</a>
<a name="ln1467">      ashift_lines[lct].width = lsd_lines[n * 7 + 4] / scale;</a>
<a name="ln1468"> </a>
<a name="ln1469">      // ...  and weight (= length * width * angle precision)</a>
<a name="ln1470">      const float weight = ashift_lines[lct].length * ashift_lines[lct].width * lsd_lines[n * 7 + 5];</a>
<a name="ln1471">      ashift_lines[lct].weight = weight;</a>
<a name="ln1472"> </a>
<a name="ln1473"> </a>
<a name="ln1474">      const float angle = atan2(py2 - py1, px2 - px1) / M_PI * 180.0f;</a>
<a name="ln1475">      const int vertical = fabs(fabs(angle) - 90.0f) &lt; MAX_TANGENTIAL_DEVIATION ? 1 : 0;</a>
<a name="ln1476">      const int horizontal = fabs(fabs(fabs(angle) - 90.0f) - 90.0f) &lt; MAX_TANGENTIAL_DEVIATION ? 1 : 0;</a>
<a name="ln1477"> </a>
<a name="ln1478">      const int relevant = ashift_lines[lct].length &gt; MIN_LINE_LENGTH ? 1 : 0;</a>
<a name="ln1479"> </a>
<a name="ln1480">      // register type of line</a>
<a name="ln1481">      dt_iop_ashift_linetype_t type = ASHIFT_LINE_IRRELEVANT;</a>
<a name="ln1482">      if(vertical &amp;&amp; relevant)</a>
<a name="ln1483">      {</a>
<a name="ln1484">        type = ASHIFT_LINE_VERTICAL_SELECTED;</a>
<a name="ln1485">        vertical_count++;</a>
<a name="ln1486">        vertical_weight += weight;</a>
<a name="ln1487">      }</a>
<a name="ln1488">      else if(horizontal &amp;&amp; relevant)</a>
<a name="ln1489">      {</a>
<a name="ln1490">        type = ASHIFT_LINE_HORIZONTAL_SELECTED;</a>
<a name="ln1491">        horizontal_count++;</a>
<a name="ln1492">        horizontal_weight += weight;</a>
<a name="ln1493">      }</a>
<a name="ln1494">      ashift_lines[lct].type = type;</a>
<a name="ln1495"> </a>
<a name="ln1496">      // the next valid line</a>
<a name="ln1497">      lct++;</a>
<a name="ln1498">    }</a>
<a name="ln1499">  }</a>
<a name="ln1500">#ifdef ASHIFT_DEBUG</a>
<a name="ln1501">    printf(&quot;%d lines (vertical %d, horizontal %d, not relevant %d)\n&quot;, lines_count, vertical_count,</a>
<a name="ln1502">           horizontal_count, lct - vertical_count - horizontal_count);</a>
<a name="ln1503">    float xmin = FLT_MAX, xmax = FLT_MIN, ymin = FLT_MAX, ymax = FLT_MIN;</a>
<a name="ln1504">    for(int n = 0; n &lt; lct; n++)</a>
<a name="ln1505">    {</a>
<a name="ln1506">      xmin = fmin(xmin, fmin(ashift_lines[n].p1[0], ashift_lines[n].p2[0]));</a>
<a name="ln1507">      xmax = fmax(xmax, fmax(ashift_lines[n].p1[0], ashift_lines[n].p2[0]));</a>
<a name="ln1508">      ymin = fmin(ymin, fmin(ashift_lines[n].p1[1], ashift_lines[n].p2[1]));</a>
<a name="ln1509">      ymax = fmax(ymax, fmax(ashift_lines[n].p1[1], ashift_lines[n].p2[1]));</a>
<a name="ln1510">      printf(&quot;x1 %.0f, y1 %.0f, x2 %.0f, y2 %.0f, length %.0f, width %f, X %f, Y %f, Z %f, type %d, scalars %f %f\n&quot;,</a>
<a name="ln1511">             ashift_lines[n].p1[0], ashift_lines[n].p1[1], ashift_lines[n].p2[0], ashift_lines[n].p2[1],</a>
<a name="ln1512">             ashift_lines[n].length, ashift_lines[n].width,</a>
<a name="ln1513">             ashift_lines[n].L[0], ashift_lines[n].L[1], ashift_lines[n].L[2], ashift_lines[n].type,</a>
<a name="ln1514">             vec3scalar(ashift_lines[n].p1, ashift_lines[n].L),</a>
<a name="ln1515">             vec3scalar(ashift_lines[n].p2, ashift_lines[n].L));</a>
<a name="ln1516">    }</a>
<a name="ln1517">    printf(&quot;xmin %.0f, xmax %.0f, ymin %.0f, ymax %.0f\n&quot;, xmin, xmax, ymin, ymax);</a>
<a name="ln1518">#endif</a>
<a name="ln1519"> </a>
<a name="ln1520">  // store results in provided locations</a>
<a name="ln1521">  *lcount = lct;</a>
<a name="ln1522">  *vcount = vertical_count;</a>
<a name="ln1523">  *vweight = vertical_weight;</a>
<a name="ln1524">  *hcount = horizontal_count;</a>
<a name="ln1525">  *hweight = horizontal_weight;</a>
<a name="ln1526">  *alines = ashift_lines;</a>
<a name="ln1527"> </a>
<a name="ln1528">  // free intermediate buffers</a>
<a name="ln1529">  free(lsd_lines);</a>
<a name="ln1530">  free(greyscale);</a>
<a name="ln1531">  return lct &gt; 0 ? TRUE : FALSE;</a>
<a name="ln1532"> </a>
<a name="ln1533">error:</a>
<a name="ln1534">  free(lsd_lines);</a>
<a name="ln1535">  free(greyscale);</a>
<a name="ln1536">  return FALSE;</a>
<a name="ln1537">}</a>
<a name="ln1538"> </a>
<a name="ln1539">// get image from buffer, analyze for structure and save results</a>
<a name="ln1540">static int get_structure(dt_iop_module_t *module, dt_iop_ashift_enhance_t enhance)</a>
<a name="ln1541">{</a>
<a name="ln1542">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln1543"> </a>
<a name="ln1544">  float *buffer = NULL;</a>
<a name="ln1545">  int width = 0;</a>
<a name="ln1546">  int height = 0;</a>
<a name="ln1547">  int x_off = 0;</a>
<a name="ln1548">  int y_off = 0;</a>
<a name="ln1549">  float scale = 0.0f;</a>
<a name="ln1550"> </a>
<a name="ln1551">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln1552">  // read buffer data if they are available</a>
<a name="ln1553">  if(g-&gt;buf != NULL)</a>
<a name="ln1554">  {</a>
<a name="ln1555">    width = g-&gt;buf_width;</a>
<a name="ln1556">    height = g-&gt;buf_height;</a>
<a name="ln1557">    x_off = g-&gt;buf_x_off;</a>
<a name="ln1558">    y_off = g-&gt;buf_y_off;</a>
<a name="ln1559">    scale = g-&gt;buf_scale;</a>
<a name="ln1560"> </a>
<a name="ln1561">    // create a temporary buffer to hold image data</a>
<a name="ln1562">    buffer = malloc((size_t)width * height * 4 * sizeof(float));</a>
<a name="ln1563">    if(buffer != NULL)</a>
<a name="ln1564">      memcpy(buffer, g-&gt;buf, (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln1565">  }</a>
<a name="ln1566">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln1567"> </a>
<a name="ln1568">  if(buffer == NULL) goto error;</a>
<a name="ln1569"> </a>
<a name="ln1570">  // get rid of old structural data</a>
<a name="ln1571">  g-&gt;lines_count = 0;</a>
<a name="ln1572">  g-&gt;vertical_count = 0;</a>
<a name="ln1573">  g-&gt;horizontal_count = 0;</a>
<a name="ln1574">  free(g-&gt;lines);</a>
<a name="ln1575">  g-&gt;lines = NULL;</a>
<a name="ln1576"> </a>
<a name="ln1577">  dt_iop_ashift_line_t *lines;</a>
<a name="ln1578">  int lines_count;</a>
<a name="ln1579">  int vertical_count;</a>
<a name="ln1580">  int horizontal_count;</a>
<a name="ln1581">  float vertical_weight;</a>
<a name="ln1582">  float horizontal_weight;</a>
<a name="ln1583"> </a>
<a name="ln1584">  // get new structural data</a>
<a name="ln1585">  if(!line_detect(buffer, width, height, x_off, y_off, scale, &amp;lines, &amp;lines_count,</a>
<a name="ln1586">                  &amp;vertical_count, &amp;horizontal_count, &amp;vertical_weight, &amp;horizontal_weight,</a>
<a name="ln1587">                  enhance, dt_image_is_raw(&amp;module-&gt;dev-&gt;image_storage)))</a>
<a name="ln1588">    goto error;</a>
<a name="ln1589"> </a>
<a name="ln1590">  // save new structural data</a>
<a name="ln1591">  g-&gt;lines_in_width = width;</a>
<a name="ln1592">  g-&gt;lines_in_height = height;</a>
<a name="ln1593">  g-&gt;lines_x_off = x_off;</a>
<a name="ln1594">  g-&gt;lines_y_off = y_off;</a>
<a name="ln1595">  g-&gt;lines_count = lines_count;</a>
<a name="ln1596">  g-&gt;vertical_count = vertical_count;</a>
<a name="ln1597">  g-&gt;horizontal_count = horizontal_count;</a>
<a name="ln1598">  g-&gt;vertical_weight = vertical_weight;</a>
<a name="ln1599">  g-&gt;horizontal_weight = horizontal_weight;</a>
<a name="ln1600">  g-&gt;lines_version++;</a>
<a name="ln1601">  g-&gt;lines_suppressed = 0;</a>
<a name="ln1602">  g-&gt;lines = lines;</a>
<a name="ln1603"> </a>
<a name="ln1604">  free(buffer);</a>
<a name="ln1605">  return TRUE;</a>
<a name="ln1606"> </a>
<a name="ln1607">error:</a>
<a name="ln1608">  free(buffer);</a>
<a name="ln1609">  return FALSE;</a>
<a name="ln1610">}</a>
<a name="ln1611"> </a>
<a name="ln1612"> </a>
<a name="ln1613">// swap two integer values</a>
<a name="ln1614">static inline void swap(int *a, int *b)</a>
<a name="ln1615">{</a>
<a name="ln1616">  int tmp = *a;</a>
<a name="ln1617">  *a = *b;</a>
<a name="ln1618">  *b = tmp;</a>
<a name="ln1619">}</a>
<a name="ln1620"> </a>
<a name="ln1621">// do complete permutations</a>
<a name="ln1622">static int quickperm(int *a, int *p, const int N, int *i)</a>
<a name="ln1623">{</a>
<a name="ln1624">  if(*i &gt;= N) return FALSE;</a>
<a name="ln1625"> </a>
<a name="ln1626">  p[*i]--;</a>
<a name="ln1627">  int j = (*i % 2 == 1) ? p[*i] : 0;</a>
<a name="ln1628">  swap(&amp;a[j], &amp;a[*i]);</a>
<a name="ln1629">  *i = 1;</a>
<a name="ln1630">  while(p[*i] == 0)</a>
<a name="ln1631">  {</a>
<a name="ln1632">    p[*i] = *i;</a>
<a name="ln1633">    (*i)++;</a>
<a name="ln1634">  }</a>
<a name="ln1635">  return TRUE;</a>
<a name="ln1636">}</a>
<a name="ln1637"> </a>
<a name="ln1638">// Fisher-Yates shuffle</a>
<a name="ln1639">static void shuffle(int *a, const int N)</a>
<a name="ln1640">{</a>
<a name="ln1641">  for(int i = 0; i &lt; N; i++)</a>
<a name="ln1642">  {</a>
<a name="ln1643">    int j = i + rand() % (N - i);</a>
<a name="ln1644">    swap(&amp;a[j], &amp;a[i]);</a>
<a name="ln1645">  }</a>
<a name="ln1646">}</a>
<a name="ln1647"> </a>
<a name="ln1648">// factorial function</a>
<a name="ln1649">static int fact(const int n)</a>
<a name="ln1650">{</a>
<a name="ln1651">  return (n == 1 ? 1 : n * fact(n - 1));</a>
<a name="ln1652">}</a>
<a name="ln1653"> </a>
<a name="ln1654">// We use a pseudo-RANSAC algorithm to elminiate ouliers from our set of lines. The</a>
<a name="ln1655">// original RANSAC works on linear optimization problems. Our model is nonlinear. We</a>
<a name="ln1656">// take advantage of the fact that lines interesting for our model are vantage lines</a>
<a name="ln1657">// that meet in one vantage point for each subset of lines (vertical/horizontal).</a>
<a name="ln1658">// Stragegy: we construct a model by (random) sampling within the subset of lines and</a>
<a name="ln1659">// calculate the vantage point. Then we check the &quot;distance&quot; of all other lines to the</a>
<a name="ln1660">// vantage point. The model that gives highest number of lines combined with the highest</a>
<a name="ln1661">// total weight and lowest overall &quot;distance&quot; wins.</a>
<a name="ln1662">// Disadvantage: compared to the original RANSAC we don't get any model parameters that</a>
<a name="ln1663">// we could use for the following NMS fit.</a>
<a name="ln1664">// Self-tuning: we optimize &quot;epsilon&quot;, the hurdle rate to reject a line as an outlier,</a>
<a name="ln1665">// by a number of dry runs first. The target average percentage value of lines to eliminate as</a>
<a name="ln1666">// outliers (without judging on the quality of the model) is given by RANSAC_ELIMINATION_RATIO,</a>
<a name="ln1667">// note: the actual percentage of outliers removed in the final run will be lower because we</a>
<a name="ln1668">// will finally look for the best quality model with the optimized epsilon and that quality value also</a>
<a name="ln1669">// encloses the number of good lines</a>
<a name="ln1670">static void ransac(const dt_iop_ashift_line_t *lines, int *index_set, int *inout_set,</a>
<a name="ln1671">                  const int set_count, const float total_weight, const int xmin, const int xmax,</a>
<a name="ln1672">                  const int ymin, const int ymax)</a>
<a name="ln1673">{</a>
<a name="ln1674">  if(set_count &lt; 3) return;</a>
<a name="ln1675"> </a>
<a name="ln1676">  const size_t set_size = set_count * sizeof(int);</a>
<a name="ln1677">  int *best_set = malloc(set_size);</a>
<a name="ln1678">  memcpy(best_set, index_set, set_size);</a>
<a name="ln1679">  int *best_inout = calloc(1, set_size);</a>
<a name="ln1680"> </a>
<a name="ln1681">  float best_quality = 0.0f;</a>
<a name="ln1682"> </a>
<a name="ln1683">  // hurdle value epsilon for rejecting a line as an outlier will be self-tuning</a>
<a name="ln1684">  // in a number of dry runs</a>
<a name="ln1685">  float epsilon = pow(10.0f, -RANSAC_EPSILON);</a>
<a name="ln1686">  float epsilon_step = RANSAC_EPSILON_STEP;</a>
<a name="ln1687">  // some accounting variables for self-tuning</a>
<a name="ln1688">  int lines_eliminated = 0;</a>
<a name="ln1689">  int valid_runs = 0;</a>
<a name="ln1690"> </a>
<a name="ln1691">  // number of runs to optimize epsilon</a>
<a name="ln1692">  const int optiruns = RANSAC_OPTIMIZATION_STEPS * RANSAC_OPTIMIZATION_DRY_RUNS;</a>
<a name="ln1693">  // go for complete permutations on small set sizes, else for random sample consensus</a>
<a name="ln1694">  const int riter = (set_count &gt; RANSAC_HURDLE) ? RANSAC_RUNS : fact(set_count);</a>
<a name="ln1695"> </a>
<a name="ln1696">  // some data needed for quickperm</a>
<a name="ln1697">  int *perm = malloc((set_count + 1) * sizeof(int));</a>
<a name="ln1698">  for(int n = 0; n &lt; set_count + 1; n++) perm[n] = n;</a>
<a name="ln1699">  int piter = 1;</a>
<a name="ln1700"> </a>
<a name="ln1701">  // inout holds good/bad qualification for each line</a>
<a name="ln1702">  int *inout = malloc(set_size);</a>
<a name="ln1703"> </a>
<a name="ln1704">  for(int r = 0; r &lt; optiruns + riter; r++)</a>
<a name="ln1705">  {</a>
<a name="ln1706">    // get random or systematic variation of index set</a>
<a name="ln1707">    if(set_count &gt; RANSAC_HURDLE || r &lt; optiruns)</a>
<a name="ln1708">      shuffle(index_set, set_count);</a>
<a name="ln1709">    else</a>
<a name="ln1710">      (void)quickperm(index_set, perm, set_count, &amp;piter);</a>
<a name="ln1711"> </a>
<a name="ln1712">    // summed quality evaluation of this run</a>
<a name="ln1713">    float quality = 0.0f;</a>
<a name="ln1714"> </a>
<a name="ln1715">    // we build a model ouf of the first two lines</a>
<a name="ln1716">    const float *L1 = lines[index_set[0]].L;</a>
<a name="ln1717">    const float *L2 = lines[index_set[1]].L;</a>
<a name="ln1718"> </a>
<a name="ln1719">    // get intersection point (ideally a vantage point)</a>
<a name="ln1720">    float V[3];</a>
<a name="ln1721">    vec3prodn(V, L1, L2);</a>
<a name="ln1722"> </a>
<a name="ln1723">    // catch special cases:</a>
<a name="ln1724">    // a) L1 and L2 are identical -&gt; V is NULL -&gt; no valid vantage point</a>
<a name="ln1725">    // b) vantage point lies inside image frame (no chance to correct for this case)</a>
<a name="ln1726">    if(vec3isnull(V) ||</a>
<a name="ln1727">       (fabs(V[2]) &gt; 0.0f &amp;&amp;</a>
<a name="ln1728">        V[0]/V[2] &gt;= xmin &amp;&amp;</a>
<a name="ln1729">        V[1]/V[2] &gt;= ymin &amp;&amp;</a>
<a name="ln1730">        V[0]/V[2] &lt;= xmax &amp;&amp;</a>
<a name="ln1731">        V[1]/V[2] &lt;= ymax))</a>
<a name="ln1732">    {</a>
<a name="ln1733">      // no valid model</a>
<a name="ln1734">      quality = 0.0f;</a>
<a name="ln1735">    }</a>
<a name="ln1736">    else</a>
<a name="ln1737">    {</a>
<a name="ln1738">      // valid model</a>
<a name="ln1739"> </a>
<a name="ln1740">      // normalize V so that x^2 + y^2 + z^2 = 1</a>
<a name="ln1741">      vec3norm(V, V);</a>
<a name="ln1742"> </a>
<a name="ln1743">      // the two lines constituting the model are part of the set</a>
<a name="ln1744">      inout[0] = 1;</a>
<a name="ln1745">      inout[1] = 1;</a>
<a name="ln1746"> </a>
<a name="ln1747">      // go through all remaining lines, check if they are within the model, and</a>
<a name="ln1748">      // mark that fact in inout[].</a>
<a name="ln1749">      // summarize a quality parameter for all lines within the model</a>
<a name="ln1750">      for(int n = 2; n &lt; set_count; n++)</a>
<a name="ln1751">      {</a>
<a name="ln1752">        // L is normalized so that x^2 + y^2 = 1</a>
<a name="ln1753">        const float *L3 = lines[index_set[n]].L;</a>
<a name="ln1754"> </a>
<a name="ln1755">        // we take the absolute value of the dot product of V and L as a measure</a>
<a name="ln1756">        // of the &quot;distance&quot; between point and line. Note that this is not the real euclidian</a>
<a name="ln1757">        // distance but - with the given normalization - just a pragmatically selected number</a>
<a name="ln1758">        // that goes to zero if V lies on L and increases the more V and L are apart</a>
<a name="ln1759">        const float d = fabs(vec3scalar(V, L3));</a>
<a name="ln1760"> </a>
<a name="ln1761">        // depending on d we either include or exclude the point from the set</a>
<a name="ln1762">        inout[n] = (d &lt; epsilon) ? 1 : 0;</a>
<a name="ln1763"> </a>
<a name="ln1764">        float q;</a>
<a name="ln1765"> </a>
<a name="ln1766">        if(inout[n] == 1)</a>
<a name="ln1767">        {</a>
<a name="ln1768">          // a quality parameter that depends 1/3 on the number of lines within the model,</a>
<a name="ln1769">          // 1/3 on their weight, and 1/3 on their weighted distance d to the vantage point</a>
<a name="ln1770">          q = 0.33f / (float)set_count</a>
<a name="ln1771">              + 0.33f * lines[index_set[n]].weight / total_weight</a>
<a name="ln1772">              + 0.33f * (1.0f - d / epsilon) * (float)set_count * lines[index_set[n]].weight / total_weight;</a>
<a name="ln1773">        }</a>
<a name="ln1774">        else</a>
<a name="ln1775">        {</a>
<a name="ln1776">          q = 0.0f;</a>
<a name="ln1777">          lines_eliminated++;</a>
<a name="ln1778">        }</a>
<a name="ln1779"> </a>
<a name="ln1780">        quality += q;</a>
<a name="ln1781">      }</a>
<a name="ln1782">      valid_runs++;</a>
<a name="ln1783">    }</a>
<a name="ln1784"> </a>
<a name="ln1785">    if(r &lt; optiruns)</a>
<a name="ln1786">    {</a>
<a name="ln1787">      // on last run of each self-tuning step</a>
<a name="ln1788">      if((r % RANSAC_OPTIMIZATION_DRY_RUNS) == (RANSAC_OPTIMIZATION_DRY_RUNS - 1) &amp;&amp; (valid_runs &gt; 0))</a>
<a name="ln1789">      {</a>
<a name="ln1790">#ifdef ASHIFT_DEBUG</a>
<a name="ln1791">        printf(&quot;ransac self-tuning (run %d): epsilon %f&quot;, r, epsilon);</a>
<a name="ln1792">#endif</a>
<a name="ln1793">        // average ratio of lines that we eliminated with the given epsilon</a>
<a name="ln1794">        float ratio = 100.0f * (float)lines_eliminated / ((float)set_count * valid_runs);</a>
<a name="ln1795">        // adjust epsilon accordingly</a>
<a name="ln1796">        if(ratio &lt; RANSAC_ELIMINATION_RATIO)</a>
<a name="ln1797">          epsilon = pow(10.0f, log10(epsilon) - epsilon_step);</a>
<a name="ln1798">        else if(ratio &gt; RANSAC_ELIMINATION_RATIO)</a>
<a name="ln1799">          epsilon = pow(10.0f, log10(epsilon) + epsilon_step);</a>
<a name="ln1800">#ifdef ASHIFT_DEBUG</a>
<a name="ln1801">        printf(&quot; (elimination ratio %f) -&gt; %f\n&quot;, ratio, epsilon);</a>
<a name="ln1802">#endif</a>
<a name="ln1803">        // reduce step-size for next optimization round</a>
<a name="ln1804">        epsilon_step /= 2.0f;</a>
<a name="ln1805">        lines_eliminated = 0;</a>
<a name="ln1806">        valid_runs = 0;</a>
<a name="ln1807">      }</a>
<a name="ln1808">    }</a>
<a name="ln1809">    else</a>
<a name="ln1810">    {</a>
<a name="ln1811">      // in the &quot;real&quot; runs check against the best model found so far</a>
<a name="ln1812">      if(quality &gt; best_quality)</a>
<a name="ln1813">      {</a>
<a name="ln1814">        memcpy(best_set, index_set, set_size);</a>
<a name="ln1815">        memcpy(best_inout, inout, set_size);</a>
<a name="ln1816">        best_quality = quality;</a>
<a name="ln1817">      }</a>
<a name="ln1818">    }</a>
<a name="ln1819"> </a>
<a name="ln1820">#ifdef ASHIFT_DEBUG</a>
<a name="ln1821">    // report some statistics</a>
<a name="ln1822">    int count = 0, lastcount = 0;</a>
<a name="ln1823">    for(int n = 0; n &lt; set_count; n++) count += best_inout[n];</a>
<a name="ln1824">    for(int n = 0; n &lt; set_count; n++) lastcount += inout[n];</a>
<a name="ln1825">    printf(&quot;ransac run %d: best qual %.6f, eps %.6f, line count %d of %d (this run: qual %.5f, count %d (%2f%%))\n&quot;, r,</a>
<a name="ln1826">           best_quality, epsilon, count, set_count, quality, lastcount, 100.0f * lastcount / (float)set_count);</a>
<a name="ln1827">#endif</a>
<a name="ln1828">  }</a>
<a name="ln1829"> </a>
<a name="ln1830">  // store back best set</a>
<a name="ln1831">  memcpy(index_set, best_set, set_size);</a>
<a name="ln1832">  memcpy(inout_set, best_inout, set_size);</a>
<a name="ln1833"> </a>
<a name="ln1834">  free(inout);</a>
<a name="ln1835">  free(perm);</a>
<a name="ln1836">  free(best_inout);</a>
<a name="ln1837">  free(best_set);</a>
<a name="ln1838">}</a>
<a name="ln1839"> </a>
<a name="ln1840"> </a>
<a name="ln1841">// try to clean up structural data by eliminating outliers and thereby increasing</a>
<a name="ln1842">// the chance of a convergent fitting</a>
<a name="ln1843">static int remove_outliers(dt_iop_module_t *module)</a>
<a name="ln1844">{</a>
<a name="ln1845">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln1846"> </a>
<a name="ln1847">  const int width = g-&gt;lines_in_width;</a>
<a name="ln1848">  const int height = g-&gt;lines_in_height;</a>
<a name="ln1849">  const int xmin = g-&gt;lines_x_off;</a>
<a name="ln1850">  const int ymin = g-&gt;lines_y_off;</a>
<a name="ln1851">  const int xmax = xmin + width;</a>
<a name="ln1852">  const int ymax = ymin + height;</a>
<a name="ln1853"> </a>
<a name="ln1854">  // holds the index set of lines we want to work on</a>
<a name="ln1855">  int *lines_set = malloc(g-&gt;lines_count * sizeof(int));</a>
<a name="ln1856">  // holds the result of ransac</a>
<a name="ln1857">  int *inout_set = malloc(g-&gt;lines_count * sizeof(int));</a>
<a name="ln1858"> </a>
<a name="ln1859">  // some accounting variables</a>
<a name="ln1860">  int vnb = 0, vcount = 0;</a>
<a name="ln1861">  int hnb = 0, hcount = 0;</a>
<a name="ln1862"> </a>
<a name="ln1863">  // just to be on the safe side</a>
<a name="ln1864">  if(g-&gt;lines == NULL) goto error;</a>
<a name="ln1865"> </a>
<a name="ln1866">  // generate index list for the vertical lines</a>
<a name="ln1867">  for(int n = 0; n &lt; g-&gt;lines_count; n++)</a>
<a name="ln1868">  {</a>
<a name="ln1869">    // is this a selected vertical line?</a>
<a name="ln1870">    if((g-&gt;lines[n].type &amp; ASHIFT_LINE_MASK) != ASHIFT_LINE_VERTICAL_SELECTED)</a>
<a name="ln1871">      continue;</a>
<a name="ln1872"> </a>
<a name="ln1873">    lines_set[vnb] = n;</a>
<a name="ln1874">    inout_set[vnb] = 0;</a>
<a name="ln1875">    vnb++;</a>
<a name="ln1876">  }</a>
<a name="ln1877"> </a>
<a name="ln1878">  // it only makes sense to call ransac if we have more than two lines</a>
<a name="ln1879">  if(vnb &gt; 2)</a>
<a name="ln1880">    ransac(g-&gt;lines, lines_set, inout_set, vnb, g-&gt;vertical_weight,</a>
<a name="ln1881">           xmin, xmax, ymin, ymax);</a>
<a name="ln1882"> </a>
<a name="ln1883">  // adjust line selected flag according to the ransac results</a>
<a name="ln1884">  for(int n = 0; n &lt; vnb; n++)</a>
<a name="ln1885">  {</a>
<a name="ln1886">    const int m = lines_set[n];</a>
<a name="ln1887">    if(inout_set[n] == 1)</a>
<a name="ln1888">    {</a>
<a name="ln1889">      g-&gt;lines[m].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln1890">      vcount++;</a>
<a name="ln1891">    }</a>
<a name="ln1892">    else</a>
<a name="ln1893">      g-&gt;lines[m].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln1894">  }</a>
<a name="ln1895">  // update number of vertical lines</a>
<a name="ln1896">  g-&gt;vertical_count = vcount;</a>
<a name="ln1897">  g-&gt;lines_version++;</a>
<a name="ln1898"> </a>
<a name="ln1899">  // now generate index list for the horizontal lines</a>
<a name="ln1900">  for(int n = 0; n &lt; g-&gt;lines_count; n++)</a>
<a name="ln1901">  {</a>
<a name="ln1902">    // is this a selected horizontal line?</a>
<a name="ln1903">    if((g-&gt;lines[n].type &amp; ASHIFT_LINE_MASK) != ASHIFT_LINE_HORIZONTAL_SELECTED)</a>
<a name="ln1904">      continue;</a>
<a name="ln1905"> </a>
<a name="ln1906">    lines_set[hnb] = n;</a>
<a name="ln1907">    inout_set[hnb] = 0;</a>
<a name="ln1908">    hnb++;</a>
<a name="ln1909">  }</a>
<a name="ln1910"> </a>
<a name="ln1911">  // it only makes sense to call ransac if we have more than two lines</a>
<a name="ln1912">  if(hnb &gt; 2)</a>
<a name="ln1913">    ransac(g-&gt;lines, lines_set, inout_set, hnb, g-&gt;horizontal_weight,</a>
<a name="ln1914">           xmin, xmax, ymin, ymax);</a>
<a name="ln1915"> </a>
<a name="ln1916">  // adjust line selected flag according to the ransac results</a>
<a name="ln1917">  for(int n = 0; n &lt; hnb; n++)</a>
<a name="ln1918">  {</a>
<a name="ln1919">    const int m = lines_set[n];</a>
<a name="ln1920">    if(inout_set[n] == 1)</a>
<a name="ln1921">    {</a>
<a name="ln1922">      g-&gt;lines[m].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln1923">      hcount++;</a>
<a name="ln1924">    }</a>
<a name="ln1925">    else</a>
<a name="ln1926">      g-&gt;lines[m].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln1927">  }</a>
<a name="ln1928">  // update number of horizontal lines</a>
<a name="ln1929">  g-&gt;horizontal_count = hcount;</a>
<a name="ln1930">  g-&gt;lines_version++;</a>
<a name="ln1931"> </a>
<a name="ln1932">  free(inout_set);</a>
<a name="ln1933">  free(lines_set);</a>
<a name="ln1934"> </a>
<a name="ln1935">  return TRUE;</a>
<a name="ln1936"> </a>
<a name="ln1937">error:</a>
<a name="ln1938">  free(inout_set);</a>
<a name="ln1939">  free(lines_set);</a>
<a name="ln1940">  return FALSE;</a>
<a name="ln1941">}</a>
<a name="ln1942"> </a>
<a name="ln1943">// utility function to map a variable in [min; max] to [-INF; + INF]</a>
<a name="ln1944">static inline double logit(double x, double min, double max)</a>
<a name="ln1945">{</a>
<a name="ln1946">  const double eps = 1.0e-6;</a>
<a name="ln1947">  // make sure p does not touch the borders of its definition area,</a>
<a name="ln1948">  // not critical for data accuracy as logit() is only used on initial fit parameters</a>
<a name="ln1949">  double p = CLAMP((x - min) / (max - min), eps, 1.0 - eps);</a>
<a name="ln1950"> </a>
<a name="ln1951">  return (2.0 * atanh(2.0 * p - 1.0));</a>
<a name="ln1952">}</a>
<a name="ln1953"> </a>
<a name="ln1954">// inverted function to logit()</a>
<a name="ln1955">static inline double ilogit(double L, double min, double max)</a>
<a name="ln1956">{</a>
<a name="ln1957">  double p = 0.5 * (1.0 + tanh(0.5 * L));</a>
<a name="ln1958"> </a>
<a name="ln1959">  return (p * (max - min) + min);</a>
<a name="ln1960">}</a>
<a name="ln1961"> </a>
<a name="ln1962">// helper function for simplex() return quality parameter for the given model</a>
<a name="ln1963">// strategy:</a>
<a name="ln1964">//    * generate homography matrix out of fixed parameters and fitting parameters</a>
<a name="ln1965">//    * apply homography to all end points of affected lines</a>
<a name="ln1966">//    * generate new line out of transformed end points</a>
<a name="ln1967">//    * calculate scalar product s of line with perpendicular axis</a>
<a name="ln1968">//    * sum over weighted s^2 values</a>
<a name="ln1969">static double model_fitness(double *params, void *data)</a>
<a name="ln1970">{</a>
<a name="ln1971">  dt_iop_ashift_fit_params_t *fit = (dt_iop_ashift_fit_params_t *)data;</a>
<a name="ln1972"> </a>
<a name="ln1973">  // just for convenience: get shorter names</a>
<a name="ln1974">  dt_iop_ashift_line_t *lines = fit-&gt;lines;</a>
<a name="ln1975">  const int lines_count = fit-&gt;lines_count;</a>
<a name="ln1976">  const int width = fit-&gt;width;</a>
<a name="ln1977">  const int height = fit-&gt;height;</a>
<a name="ln1978">  const float f_length_kb = fit-&gt;f_length_kb;</a>
<a name="ln1979">  const float orthocorr = fit-&gt;orthocorr;</a>
<a name="ln1980">  const float aspect = fit-&gt;aspect;</a>
<a name="ln1981"> </a>
<a name="ln1982">  float rotation = fit-&gt;rotation;</a>
<a name="ln1983">  float lensshift_v = fit-&gt;lensshift_v;</a>
<a name="ln1984">  float lensshift_h = fit-&gt;lensshift_h;</a>
<a name="ln1985">  float shear = fit-&gt;shear;</a>
<a name="ln1986">  float rotation_range = fit-&gt;rotation_range;</a>
<a name="ln1987">  float lensshift_v_range = fit-&gt;lensshift_v_range;</a>
<a name="ln1988">  float lensshift_h_range = fit-&gt;lensshift_h_range;</a>
<a name="ln1989">  float shear_range = fit-&gt;shear_range;</a>
<a name="ln1990"> </a>
<a name="ln1991">  int pcount = 0;</a>
<a name="ln1992"> </a>
<a name="ln1993">  // fill in fit parameters from params[]. Attention: order matters!!!</a>
<a name="ln1994">  if(isnan(rotation))</a>
<a name="ln1995">  {</a>
<a name="ln1996">    rotation = ilogit(params[pcount], -rotation_range, rotation_range);</a>
<a name="ln1997">    pcount++;</a>
<a name="ln1998">  }</a>
<a name="ln1999"> </a>
<a name="ln2000">  if(isnan(lensshift_v))</a>
<a name="ln2001">  {</a>
<a name="ln2002">    lensshift_v = ilogit(params[pcount], -lensshift_v_range, lensshift_v_range);</a>
<a name="ln2003">    pcount++;</a>
<a name="ln2004">  }</a>
<a name="ln2005"> </a>
<a name="ln2006">  if(isnan(lensshift_h))</a>
<a name="ln2007">  {</a>
<a name="ln2008">    lensshift_h = ilogit(params[pcount], -lensshift_h_range, lensshift_h_range);</a>
<a name="ln2009">    pcount++;</a>
<a name="ln2010">  }</a>
<a name="ln2011"> </a>
<a name="ln2012">  if(isnan(shear))</a>
<a name="ln2013">  {</a>
<a name="ln2014">    shear = ilogit(params[pcount], -shear_range, shear_range);</a>
<a name="ln2015">    pcount++;</a>
<a name="ln2016">  }</a>
<a name="ln2017"> </a>
<a name="ln2018">  assert(pcount == fit-&gt;params_count);</a>
<a name="ln2019"> </a>
<a name="ln2020">  // the possible reference axes</a>
<a name="ln2021">  const float Av[3] = { 1.0f, 0.0f, 0.0f };</a>
<a name="ln2022">  const float Ah[3] = { 0.0f, 1.0f, 0.0f };</a>
<a name="ln2023"> </a>
<a name="ln2024">  // generate homograph out of the parameters</a>
<a name="ln2025">  float homograph[3][3];</a>
<a name="ln2026">  homography((float *)homograph, rotation, lensshift_v, lensshift_h, shear, f_length_kb,</a>
<a name="ln2027">             orthocorr, aspect, width, height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln2028"> </a>
<a name="ln2029">  // accounting variables</a>
<a name="ln2030">  double sumsq_v = 0.0;</a>
<a name="ln2031">  double sumsq_h = 0.0;</a>
<a name="ln2032">  double weight_v = 0.0;</a>
<a name="ln2033">  double weight_h = 0.0;</a>
<a name="ln2034">  int count_v = 0;</a>
<a name="ln2035">  int count_h = 0;</a>
<a name="ln2036">  int count = 0;</a>
<a name="ln2037"> </a>
<a name="ln2038">  // iterate over all lines</a>
<a name="ln2039">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln2040">  {</a>
<a name="ln2041">    // check if this is a line which we must skip</a>
<a name="ln2042">    if((lines[n].type &amp; fit-&gt;linemask) != fit-&gt;linetype)</a>
<a name="ln2043">      continue;</a>
<a name="ln2044"> </a>
<a name="ln2045">    // the direction of this line (vertical?)</a>
<a name="ln2046">    const int isvertical = lines[n].type &amp; ASHIFT_LINE_DIRVERT;</a>
<a name="ln2047"> </a>
<a name="ln2048">    // select the perpendicular reference axis</a>
<a name="ln2049">    const float *A = isvertical ? Ah : Av;</a>
<a name="ln2050"> </a>
<a name="ln2051">    // apply homographic transformation to the end points</a>
<a name="ln2052">    float P1[3], P2[3];</a>
<a name="ln2053">    mat3mulv(P1, (float *)homograph, lines[n].p1);</a>
<a name="ln2054">    mat3mulv(P2, (float *)homograph, lines[n].p2);</a>
<a name="ln2055"> </a>
<a name="ln2056">    // get line connecting the two points</a>
<a name="ln2057">    float L[3];</a>
<a name="ln2058">    vec3prodn(L, P1, P2);</a>
<a name="ln2059"> </a>
<a name="ln2060">    // normalize L so that x^2 + y^2 = 1; makes sure that</a>
<a name="ln2061">    // y^2 = 1 / (1 + m^2) and x^2 = m^2 / (1 + m^2) with m defining the slope of the line</a>
<a name="ln2062">    vec3lnorm(L, L);</a>
<a name="ln2063"> </a>
<a name="ln2064">    // get scalar product of line L with orthogonal axis A -&gt; gives 0 if line is perpendicular</a>
<a name="ln2065">    float s = vec3scalar(L, A);</a>
<a name="ln2066"> </a>
<a name="ln2067">    // sum up weighted s^2 for both directions individually</a>
<a name="ln2068">    sumsq_v += isvertical ? s * s * lines[n].weight : 0.0;</a>
<a name="ln2069">    weight_v  += isvertical ? lines[n].weight : 0.0;</a>
<a name="ln2070">    count_v += isvertical ? 1 : 0;</a>
<a name="ln2071">    sumsq_h += !isvertical ? s * s * lines[n].weight : 0.0;</a>
<a name="ln2072">    weight_h  += !isvertical ? lines[n].weight : 0.0;</a>
<a name="ln2073">    count_h += !isvertical ? 1 : 0;</a>
<a name="ln2074">    count++;</a>
<a name="ln2075">  }</a>
<a name="ln2076"> </a>
<a name="ln2077">  const double v = weight_v &gt; 0.0f &amp;&amp; count &gt; 0 ? sumsq_v / weight_v * (float)count_v / count : 0.0;</a>
<a name="ln2078">  const double h = weight_h &gt; 0.0f &amp;&amp; count &gt; 0 ? sumsq_h / weight_h * (float)count_h / count : 0.0;</a>
<a name="ln2079"> </a>
<a name="ln2080">  double sum = sqrt(1.0 - (1.0 - v) * (1.0 - h)) * 1.0e6;</a>
<a name="ln2081">  //double sum = sqrt(v + h) * 1.0e6;</a>
<a name="ln2082"> </a>
<a name="ln2083">#ifdef ASHIFT_DEBUG</a>
<a name="ln2084">  printf(&quot;fitness with rotation %f, lensshift_v %f, lensshift_h %f, shear %f -&gt; lines %d, quality %10f\n&quot;,</a>
<a name="ln2085">         rotation, lensshift_v, lensshift_h, shear, count, sum);</a>
<a name="ln2086">#endif</a>
<a name="ln2087"> </a>
<a name="ln2088">  return sum;</a>
<a name="ln2089">}</a>
<a name="ln2090"> </a>
<a name="ln2091">// setup all data structures for fitting and call NM simplex</a>
<a name="ln2092">static dt_iop_ashift_nmsresult_t nmsfit(dt_iop_module_t *module, dt_iop_ashift_params_t *p, dt_iop_ashift_fitaxis_t dir)</a>
<a name="ln2093">{</a>
<a name="ln2094">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2095"> </a>
<a name="ln2096">  if(!g-&gt;lines) return NMS_NOT_ENOUGH_LINES;</a>
<a name="ln2097">  if(dir == ASHIFT_FIT_NONE) return NMS_SUCCESS;</a>
<a name="ln2098"> </a>
<a name="ln2099">  double params[4];</a>
<a name="ln2100">  int pcount = 0;</a>
<a name="ln2101">  int enough_lines = TRUE;</a>
<a name="ln2102"> </a>
<a name="ln2103">  // initialize fit parameters</a>
<a name="ln2104">  dt_iop_ashift_fit_params_t fit;</a>
<a name="ln2105">  fit.lines = g-&gt;lines;</a>
<a name="ln2106">  fit.lines_count = g-&gt;lines_count;</a>
<a name="ln2107">  fit.width = g-&gt;lines_in_width;</a>
<a name="ln2108">  fit.height = g-&gt;lines_in_height;</a>
<a name="ln2109">  fit.f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln2110">  fit.orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln2111">  fit.aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln2112">  fit.rotation = p-&gt;rotation;</a>
<a name="ln2113">  fit.lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln2114">  fit.lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln2115">  fit.shear = p-&gt;shear;</a>
<a name="ln2116">  fit.rotation_range = g-&gt;rotation_range;</a>
<a name="ln2117">  fit.lensshift_v_range = g-&gt;lensshift_v_range;</a>
<a name="ln2118">  fit.lensshift_h_range = g-&gt;lensshift_h_range;</a>
<a name="ln2119">  fit.shear_range = g-&gt;shear_range;</a>
<a name="ln2120">  fit.linetype = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2121">  fit.linemask = ASHIFT_LINE_MASK;</a>
<a name="ln2122">  fit.params_count = 0;</a>
<a name="ln2123">  fit.weight = 0.0f;</a>
<a name="ln2124"> </a>
<a name="ln2125">  // if the image is flipped and if we do not want to fit both lens shift</a>
<a name="ln2126">  // directions or none at all, then we need to change direction</a>
<a name="ln2127">  dt_iop_ashift_fitaxis_t mdir = dir;</a>
<a name="ln2128">  if((mdir &amp; ASHIFT_FIT_LENS_BOTH) != ASHIFT_FIT_LENS_BOTH &amp;&amp;</a>
<a name="ln2129">     (mdir &amp; ASHIFT_FIT_LENS_BOTH) != 0)</a>
<a name="ln2130">  {</a>
<a name="ln2131">    // flip all directions</a>
<a name="ln2132">    mdir ^= g-&gt;isflipped ? ASHIFT_FIT_FLIP : 0;</a>
<a name="ln2133">    // special case that needs to be corrected</a>
<a name="ln2134">    mdir |= (mdir &amp; ASHIFT_FIT_LINES_BOTH) == 0 ? ASHIFT_FIT_LINES_BOTH : 0;</a>
<a name="ln2135">  }</a>
<a name="ln2136"> </a>
<a name="ln2137"> </a>
<a name="ln2138">  // prepare fit structure and starting parameters for simplex fit.</a>
<a name="ln2139">  // note: the sequence of parameters in params[] needs to match the</a>
<a name="ln2140">  // respective order in dt_iop_ashift_fit_params_t. Parameters which are</a>
<a name="ln2141">  // to be fittet are marked with NAN in the fit structure. Non-NAN</a>
<a name="ln2142">  // parameters are assumed to be constant.</a>
<a name="ln2143">  if(mdir &amp; ASHIFT_FIT_ROTATION)</a>
<a name="ln2144">  {</a>
<a name="ln2145">    // we fit rotation</a>
<a name="ln2146">    fit.params_count++;</a>
<a name="ln2147">    params[pcount] = logit(fit.rotation, -fit.rotation_range, fit.rotation_range);</a>
<a name="ln2148">    pcount++;</a>
<a name="ln2149">    fit.rotation = NAN;</a>
<a name="ln2150">  }</a>
<a name="ln2151"> </a>
<a name="ln2152">  if(mdir &amp; ASHIFT_FIT_LENS_VERT)</a>
<a name="ln2153">  {</a>
<a name="ln2154">    // we fit vertical lens shift</a>
<a name="ln2155">    fit.params_count++;</a>
<a name="ln2156">    params[pcount] = logit(fit.lensshift_v, -fit.lensshift_v_range, fit.lensshift_v_range);</a>
<a name="ln2157">    pcount++;</a>
<a name="ln2158">    fit.lensshift_v = NAN;</a>
<a name="ln2159">  }</a>
<a name="ln2160"> </a>
<a name="ln2161">  if(mdir &amp; ASHIFT_FIT_LENS_HOR)</a>
<a name="ln2162">  {</a>
<a name="ln2163">    // we fit horizontal lens shift</a>
<a name="ln2164">    fit.params_count++;</a>
<a name="ln2165">    params[pcount] = logit(fit.lensshift_h, -fit.lensshift_h_range, fit.lensshift_h_range);</a>
<a name="ln2166">    pcount++;</a>
<a name="ln2167">    fit.lensshift_h = NAN;</a>
<a name="ln2168">  }</a>
<a name="ln2169"> </a>
<a name="ln2170">  if(mdir &amp; ASHIFT_FIT_SHEAR)</a>
<a name="ln2171">  {</a>
<a name="ln2172">    // we fit the shear parameter</a>
<a name="ln2173">    fit.params_count++;</a>
<a name="ln2174">    params[pcount] = logit(fit.shear, -fit.shear_range, fit.shear_range);</a>
<a name="ln2175">    pcount++;</a>
<a name="ln2176">    fit.shear = NAN;</a>
<a name="ln2177">  }</a>
<a name="ln2178"> </a>
<a name="ln2179">  if(mdir &amp; ASHIFT_FIT_LINES_VERT)</a>
<a name="ln2180">  {</a>
<a name="ln2181">    // we use vertical lines for fitting</a>
<a name="ln2182">    fit.linetype |= ASHIFT_LINE_DIRVERT;</a>
<a name="ln2183">    fit.weight += g-&gt;vertical_weight;</a>
<a name="ln2184">    enough_lines = enough_lines &amp;&amp; (g-&gt;vertical_count &gt;= MINIMUM_FITLINES);</a>
<a name="ln2185">  }</a>
<a name="ln2186"> </a>
<a name="ln2187">  if(mdir &amp; ASHIFT_FIT_LINES_HOR)</a>
<a name="ln2188">  {</a>
<a name="ln2189">    // we use horizontal lines for fitting</a>
<a name="ln2190">    fit.linetype |= 0;</a>
<a name="ln2191">    fit.weight += g-&gt;horizontal_weight;</a>
<a name="ln2192">    enough_lines = enough_lines &amp;&amp; (g-&gt;horizontal_count &gt;= MINIMUM_FITLINES);</a>
<a name="ln2193">  }</a>
<a name="ln2194"> </a>
<a name="ln2195">  // this needs to come after ASHIFT_FIT_LINES_VERT and ASHIFT_FIT_LINES_HOR</a>
<a name="ln2196">  if((mdir &amp; ASHIFT_FIT_LINES_BOTH) == ASHIFT_FIT_LINES_BOTH)</a>
<a name="ln2197">  {</a>
<a name="ln2198">    // if we use fitting in both directions we need to</a>
<a name="ln2199">    // adjust fit.linetype and fit.linemask to match all selected lines</a>
<a name="ln2200">    fit.linetype = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2201">    fit.linemask = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2202">  }</a>
<a name="ln2203"> </a>
<a name="ln2204">  // error case: we do not run simplex if there are not enough lines</a>
<a name="ln2205">  if(!enough_lines)</a>
<a name="ln2206">  {</a>
<a name="ln2207">#ifdef ASHIFT_DEBUG</a>
<a name="ln2208">    printf(&quot;optimization not possible: insufficient number of lines\n&quot;);</a>
<a name="ln2209">#endif</a>
<a name="ln2210">    return NMS_NOT_ENOUGH_LINES;</a>
<a name="ln2211">  }</a>
<a name="ln2212"> </a>
<a name="ln2213">  // start the simplex fit</a>
<a name="ln2214">  int iter = simplex(model_fitness, params, fit.params_count, NMS_EPSILON, NMS_SCALE, NMS_ITERATIONS, NULL, (void*)&amp;fit);</a>
<a name="ln2215"> </a>
<a name="ln2216">  // error case: the fit did not converge</a>
<a name="ln2217">  if(iter &gt;= NMS_ITERATIONS)</a>
<a name="ln2218">  {</a>
<a name="ln2219">#ifdef ASHIFT_DEBUG</a>
<a name="ln2220">    printf(&quot;optimization not successful: maximum number of iterations reached (%d)\n&quot;, iter);</a>
<a name="ln2221">#endif</a>
<a name="ln2222">    return NMS_DID_NOT_CONVERGE;</a>
<a name="ln2223">  }</a>
<a name="ln2224"> </a>
<a name="ln2225">  // fit was successful: now consolidate the results (order matters!!!)</a>
<a name="ln2226">  pcount = 0;</a>
<a name="ln2227">  fit.rotation = isnan(fit.rotation) ? ilogit(params[pcount++], -fit.rotation_range, fit.rotation_range) : fit.rotation;</a>
<a name="ln2228">  fit.lensshift_v = isnan(fit.lensshift_v) ? ilogit(params[pcount++], -fit.lensshift_v_range, fit.lensshift_v_range) : fit.lensshift_v;</a>
<a name="ln2229">  fit.lensshift_h = isnan(fit.lensshift_h) ? ilogit(params[pcount++], -fit.lensshift_h_range, fit.lensshift_h_range) : fit.lensshift_h;</a>
<a name="ln2230">  fit.shear = isnan(fit.shear) ? ilogit(params[pcount++], -fit.shear_range, fit.shear_range) : fit.shear;</a>
<a name="ln2231">#ifdef ASHIFT_DEBUG</a>
<a name="ln2232">  printf(&quot;params after optimization (%d iterations): rotation %f, lensshift_v %f, lensshift_h %f, shear %f\n&quot;,</a>
<a name="ln2233">         iter, fit.rotation, fit.lensshift_v, fit.lensshift_h, fit.shear);</a>
<a name="ln2234">#endif</a>
<a name="ln2235"> </a>
<a name="ln2236">  // sanity check: in case of extreme values the image gets distorted so strongly that it spans an insanely huge area. we check that</a>
<a name="ln2237">  // case and assume values that increase the image area by more than a factor of 4 as being insane.</a>
<a name="ln2238">  float homograph[3][3];</a>
<a name="ln2239">  homography((float *)homograph, fit.rotation, fit.lensshift_v, fit.lensshift_h, fit.shear, fit.f_length_kb,</a>
<a name="ln2240">             fit.orthocorr, fit.aspect, fit.width, fit.height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln2241"> </a>
<a name="ln2242">  // visit all four corners and find maximum span</a>
<a name="ln2243">  float xm = FLT_MAX, xM = -FLT_MAX, ym = FLT_MAX, yM = -FLT_MAX;</a>
<a name="ln2244">  for(int y = 0; y &lt; fit.height; y += fit.height - 1)</a>
<a name="ln2245">    for(int x = 0; x &lt; fit.width; x += fit.width - 1)</a>
<a name="ln2246">    {</a>
<a name="ln2247">      float pi[3], po[3];</a>
<a name="ln2248">      pi[0] = x;</a>
<a name="ln2249">      pi[1] = y;</a>
<a name="ln2250">      pi[2] = 1.0f;</a>
<a name="ln2251">      mat3mulv(po, (float *)homograph, pi);</a>
<a name="ln2252">      po[0] /= po[2];</a>
<a name="ln2253">      po[1] /= po[2];</a>
<a name="ln2254">      xm = fmin(xm, po[0]);</a>
<a name="ln2255">      ym = fmin(ym, po[1]);</a>
<a name="ln2256">      xM = fmax(xM, po[0]);</a>
<a name="ln2257">      yM = fmax(yM, po[1]);</a>
<a name="ln2258">    }</a>
<a name="ln2259"> </a>
<a name="ln2260">  if((xM - xm) * (yM - ym) &gt; 4.0f * fit.width * fit.height)</a>
<a name="ln2261">  {</a>
<a name="ln2262">#ifdef ASHIFT_DEBUG</a>
<a name="ln2263">    printf(&quot;optimization not successful: degenerate case with area growth factor (%f) exceeding limits\n&quot;,</a>
<a name="ln2264">           (xM - xm) * (yM - ym) / (fit.width * fit.height));</a>
<a name="ln2265">#endif</a>
<a name="ln2266">    return NMS_INSANE;</a>
<a name="ln2267">  }</a>
<a name="ln2268"> </a>
<a name="ln2269">  // now write the results into structure p</a>
<a name="ln2270">  p-&gt;rotation = fit.rotation;</a>
<a name="ln2271">  p-&gt;lensshift_v = fit.lensshift_v;</a>
<a name="ln2272">  p-&gt;lensshift_h = fit.lensshift_h;</a>
<a name="ln2273">  p-&gt;shear = fit.shear;</a>
<a name="ln2274">  return NMS_SUCCESS;</a>
<a name="ln2275">}</a>
<a name="ln2276"> </a>
<a name="ln2277">#ifdef ASHIFT_DEBUG</a>
<a name="ln2278">// only used in development phase. call model_fitness() with current parameters and</a>
<a name="ln2279">// print some useful information</a>
<a name="ln2280">static void model_probe(dt_iop_module_t *module, dt_iop_ashift_params_t *p, dt_iop_ashift_fitaxis_t dir)</a>
<a name="ln2281">{</a>
<a name="ln2282">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2283"> </a>
<a name="ln2284">  if(!g-&gt;lines) return;</a>
<a name="ln2285">  if(dir == ASHIFT_FIT_NONE) return;</a>
<a name="ln2286"> </a>
<a name="ln2287">  double params[4];</a>
<a name="ln2288">  int enough_lines = TRUE;</a>
<a name="ln2289"> </a>
<a name="ln2290">  // initialize fit parameters</a>
<a name="ln2291">  dt_iop_ashift_fit_params_t fit;</a>
<a name="ln2292">  fit.lines = g-&gt;lines;</a>
<a name="ln2293">  fit.lines_count = g-&gt;lines_count;</a>
<a name="ln2294">  fit.width = g-&gt;lines_in_width;</a>
<a name="ln2295">  fit.height = g-&gt;lines_in_height;</a>
<a name="ln2296">  fit.f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln2297">  fit.orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln2298">  fit.aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln2299">  fit.rotation = p-&gt;rotation;</a>
<a name="ln2300">  fit.lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln2301">  fit.lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln2302">  fit.shear = p-&gt;shear;</a>
<a name="ln2303">  fit.linetype = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2304">  fit.linemask = ASHIFT_LINE_MASK;</a>
<a name="ln2305">  fit.params_count = 0;</a>
<a name="ln2306">  fit.weight = 0.0f;</a>
<a name="ln2307"> </a>
<a name="ln2308">  // if the image is flipped and if we do not want to fit both lens shift</a>
<a name="ln2309">  // directions or none at all, then we need to change direction</a>
<a name="ln2310">  dt_iop_ashift_fitaxis_t mdir = dir;</a>
<a name="ln2311">  if((mdir &amp; ASHIFT_FIT_LENS_BOTH) != ASHIFT_FIT_LENS_BOTH &amp;&amp;</a>
<a name="ln2312">     (mdir &amp; ASHIFT_FIT_LENS_BOTH) != 0)</a>
<a name="ln2313">  {</a>
<a name="ln2314">    // flip all directions</a>
<a name="ln2315">    mdir ^= g-&gt;isflipped ? ASHIFT_FIT_FLIP : 0;</a>
<a name="ln2316">    // special case that needs to be corrected</a>
<a name="ln2317">    mdir |= (mdir &amp; ASHIFT_FIT_LINES_BOTH) == 0 ? ASHIFT_FIT_LINES_BOTH : 0;</a>
<a name="ln2318">  }</a>
<a name="ln2319"> </a>
<a name="ln2320">  if(mdir &amp; ASHIFT_FIT_LINES_VERT)</a>
<a name="ln2321">  {</a>
<a name="ln2322">    // we use vertical lines for fitting</a>
<a name="ln2323">    fit.linetype |= ASHIFT_LINE_DIRVERT;</a>
<a name="ln2324">    fit.weight += g-&gt;vertical_weight;</a>
<a name="ln2325">    enough_lines = enough_lines &amp;&amp; (g-&gt;vertical_count &gt;= MINIMUM_FITLINES);</a>
<a name="ln2326">  }</a>
<a name="ln2327"> </a>
<a name="ln2328">  if(mdir &amp; ASHIFT_FIT_LINES_HOR)</a>
<a name="ln2329">  {</a>
<a name="ln2330">    // we use horizontal lines for fitting</a>
<a name="ln2331">    fit.linetype |= 0;</a>
<a name="ln2332">    fit.weight += g-&gt;horizontal_weight;</a>
<a name="ln2333">    enough_lines = enough_lines &amp;&amp; (g-&gt;horizontal_count &gt;= MINIMUM_FITLINES);</a>
<a name="ln2334">  }</a>
<a name="ln2335"> </a>
<a name="ln2336">  // this needs to come after ASHIFT_FIT_LINES_VERT and ASHIFT_FIT_LINES_HOR</a>
<a name="ln2337">  if((mdir &amp; ASHIFT_FIT_LINES_BOTH) == ASHIFT_FIT_LINES_BOTH)</a>
<a name="ln2338">  {</a>
<a name="ln2339">    // if we use fitting in both directions we need to</a>
<a name="ln2340">    // adjust fit.linetype and fit.linemask to match all selected lines</a>
<a name="ln2341">    fit.linetype = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2342">    fit.linemask = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2343">  }</a>
<a name="ln2344"> </a>
<a name="ln2345">  double quality = model_fitness(params, (void *)&amp;fit);</a>
<a name="ln2346"> </a>
<a name="ln2347">  printf(&quot;model fitness: %.8f (rotation %f, lensshift_v %f, lensshift_h %f, shear %f)\n&quot;,</a>
<a name="ln2348">         quality, p-&gt;rotation, p-&gt;lensshift_v, p-&gt;lensshift_h, p-&gt;shear);</a>
<a name="ln2349">}</a>
<a name="ln2350">#endif</a>
<a name="ln2351"> </a>
<a name="ln2352">// function to keep crop fitting parameters within constraints</a>
<a name="ln2353">static void crop_constraint(double *params, int pcount)</a>
<a name="ln2354">{</a>
<a name="ln2355">  if(pcount &gt; 0) params[0] = fabs(params[0]);</a>
<a name="ln2356">  if(pcount &gt; 1) params[1] = fabs(params[1]);</a>
<a name="ln2357">  if(pcount &gt; 2) params[2] = fabs(params[2]);</a>
<a name="ln2358"> </a>
<a name="ln2359">  if(pcount &gt; 0 &amp;&amp; params[0] &gt; 1.0) params[0] = 1.0 - params[0];</a>
<a name="ln2360">  if(pcount &gt; 1 &amp;&amp; params[1] &gt; 1.0) params[1] = 1.0 - params[1];</a>
<a name="ln2361">  if(pcount &gt; 2 &amp;&amp; params[2] &gt; 0.5*M_PI) params[2] = 0.5*M_PI - params[2];</a>
<a name="ln2362">}</a>
<a name="ln2363"> </a>
<a name="ln2364">// helper function for getting the best fitting crop area;</a>
<a name="ln2365">// returns the negative area of the largest rectangle that fits within the</a>
<a name="ln2366">// defined image with a given rectangle's center and its aspect angle;</a>
<a name="ln2367">// the trick: the rectangle center coordinates are given in the input</a>
<a name="ln2368">// image coordinates so we know for sure that it also lies within the image after</a>
<a name="ln2369">// conversion to the output coordinates</a>
<a name="ln2370">static double crop_fitness(double *params, void *data)</a>
<a name="ln2371">{</a>
<a name="ln2372">  dt_iop_ashift_cropfit_params_t *cropfit = (dt_iop_ashift_cropfit_params_t *)data;</a>
<a name="ln2373"> </a>
<a name="ln2374">  const float wd = cropfit-&gt;width;</a>
<a name="ln2375">  const float ht = cropfit-&gt;height;</a>
<a name="ln2376"> </a>
<a name="ln2377">  // get variable and constant parameters, respectively</a>
<a name="ln2378">  const float x = isnan(cropfit-&gt;x) ? params[0] : cropfit-&gt;x;</a>
<a name="ln2379">  const float y = isnan(cropfit-&gt;y) ? params[1] : cropfit-&gt;y;</a>
<a name="ln2380">  const float alpha = isnan(cropfit-&gt;alpha) ? params[2] : cropfit-&gt;alpha;</a>
<a name="ln2381"> </a>
<a name="ln2382">  // the center of the rectangle in input image coordinates</a>
<a name="ln2383">  const float Pc[3] = { x * wd, y * ht, 1.0f };</a>
<a name="ln2384"> </a>
<a name="ln2385">  // convert to the output image coordinates and normalize</a>
<a name="ln2386">  float P[3];</a>
<a name="ln2387">  mat3mulv(P, (float *)cropfit-&gt;homograph, Pc);</a>
<a name="ln2388">  P[0] /= P[2];</a>
<a name="ln2389">  P[1] /= P[2];</a>
<a name="ln2390">  P[2] = 1.0f;</a>
<a name="ln2391"> </a>
<a name="ln2392">  // two auxiliary points (some arbitrary distance away from P) to construct the diagonals</a>
<a name="ln2393">  const float Pa[2][3] = { { P[0] + 10.0f * cos(alpha), P[1] + 10.0f * sin(alpha), 1.0f },</a>
<a name="ln2394">                           { P[0] + 10.0f * cos(alpha), P[1] - 10.0f * sin(alpha), 1.0f } };</a>
<a name="ln2395"> </a>
<a name="ln2396">  // the two diagonals: D = P x Pa</a>
<a name="ln2397">  float D[2][3];</a>
<a name="ln2398">  vec3prodn(D[0], P, Pa[0]);</a>
<a name="ln2399">  vec3prodn(D[1], P, Pa[1]);</a>
<a name="ln2400"> </a>
<a name="ln2401">  // find all intersection points of all four edges with both diagonals (I = E x D);</a>
<a name="ln2402">  // the shortest distance d2min of the intersection point I to the crop area center P determines</a>
<a name="ln2403">  // the size of the crop area that still fits into the image (for the given center and aspect angle)</a>
<a name="ln2404">  float d2min = FLT_MAX;</a>
<a name="ln2405">  for(int k = 0; k &lt; 4; k++)</a>
<a name="ln2406">    for(int l = 0; l &lt; 2; l++)</a>
<a name="ln2407">    {</a>
<a name="ln2408">      // the intersection point</a>
<a name="ln2409">      float I[3];</a>
<a name="ln2410">      vec3prodn(I, cropfit-&gt;edges[k], D[l]);</a>
<a name="ln2411"> </a>
<a name="ln2412">      // special case: I is all null -&gt; E and D are identical -&gt; P lies on E -&gt; d2min = 0</a>
<a name="ln2413">      if(vec3isnull(I))</a>
<a name="ln2414">      {</a>
<a name="ln2415">        d2min = 0.0f;</a>
<a name="ln2416">        break;</a>
<a name="ln2417">      }</a>
<a name="ln2418"> </a>
<a name="ln2419">      // special case: I[2] is 0.0f -&gt; E and D are parallel and intersect at infinity -&gt; no relevant point</a>
<a name="ln2420">      if(I[2] == 0.0f)</a>
<a name="ln2421">        continue;</a>
<a name="ln2422"> </a>
<a name="ln2423">      // the default case -&gt; normalize I</a>
<a name="ln2424">      I[0] /= I[2];</a>
<a name="ln2425">      I[1] /= I[2];</a>
<a name="ln2426"> </a>
<a name="ln2427">      // calculate distance from I to P</a>
<a name="ln2428">      const float d2 = SQR(P[0] - I[0]) + SQR(P[1] - I[1]);</a>
<a name="ln2429"> </a>
<a name="ln2430">      // the minimum distance over all intersection points</a>
<a name="ln2431">      d2min = MIN(d2min, d2);</a>
<a name="ln2432">    }</a>
<a name="ln2433"> </a>
<a name="ln2434">  // calculate the area of the rectangle</a>
<a name="ln2435">  const float A = 2.0f * d2min * sin(2.0f * alpha);</a>
<a name="ln2436"> </a>
<a name="ln2437">#ifdef ASHIFT_DEBUG</a>
<a name="ln2438">  printf(&quot;crop fitness with x %f, y %f, angle %f -&gt; distance %f, area %f\n&quot;,</a>
<a name="ln2439">         x, y, alpha, d2min, A);</a>
<a name="ln2440">#endif</a>
<a name="ln2441">  // and return -A to allow Nelder-Mead simplex to search for the minimum</a>
<a name="ln2442">  return -A;</a>
<a name="ln2443">}</a>
<a name="ln2444"> </a>
<a name="ln2445">// strategy: for a given center of the crop area and a specific aspect angle</a>
<a name="ln2446">// we calculate the largest crop area that still lies within the output image;</a>
<a name="ln2447">// now we allow a Nelder-Mead simplex to search for the center coordinates</a>
<a name="ln2448">// (and optionally the aspect angle) that delivers the largest overall crop area.</a>
<a name="ln2449">static void do_crop(dt_iop_module_t *module, dt_iop_ashift_params_t *p)</a>
<a name="ln2450">{</a>
<a name="ln2451">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2452"> </a>
<a name="ln2453">  // skip if fitting is still running</a>
<a name="ln2454">  if(g-&gt;fitting) return;</a>
<a name="ln2455"> </a>
<a name="ln2456">  // reset fit margins if auto-cropping is off</a>
<a name="ln2457">  if(p-&gt;cropmode == ASHIFT_CROP_OFF)</a>
<a name="ln2458">  {</a>
<a name="ln2459">    p-&gt;cl = 0.0f;</a>
<a name="ln2460">    p-&gt;cr = 1.0f;</a>
<a name="ln2461">    p-&gt;ct = 0.0f;</a>
<a name="ln2462">    p-&gt;cb = 1.0f;</a>
<a name="ln2463">    return;</a>
<a name="ln2464">  }</a>
<a name="ln2465"> </a>
<a name="ln2466">  g-&gt;fitting = 1;</a>
<a name="ln2467"> </a>
<a name="ln2468">  double params[3];</a>
<a name="ln2469">  int pcount;</a>
<a name="ln2470"> </a>
<a name="ln2471">  // get parameters for the homograph</a>
<a name="ln2472">  const float f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln2473">  const float orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln2474">  const float aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln2475">  const float rotation = p-&gt;rotation;</a>
<a name="ln2476">  const float lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln2477">  const float lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln2478">  const float shear = p-&gt;shear;</a>
<a name="ln2479"> </a>
<a name="ln2480">  // prepare structure of constant parameters</a>
<a name="ln2481">  dt_iop_ashift_cropfit_params_t cropfit;</a>
<a name="ln2482">  cropfit.width = g-&gt;buf_width;</a>
<a name="ln2483">  cropfit.height = g-&gt;buf_height;</a>
<a name="ln2484">  homography((float *)cropfit.homograph, rotation, lensshift_v, lensshift_h, shear, f_length_kb,</a>
<a name="ln2485">             orthocorr, aspect, cropfit.width, cropfit.height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln2486"> </a>
<a name="ln2487">  const float wd = cropfit.width;</a>
<a name="ln2488">  const float ht = cropfit.height;</a>
<a name="ln2489"> </a>
<a name="ln2490">  // the four vertices of the image in input image coordinates</a>
<a name="ln2491">  const float Vc[4][3] = { { 0.0f, 0.0f, 1.0f },</a>
<a name="ln2492">                           { 0.0f,   ht, 1.0f },</a>
<a name="ln2493">                           {   wd,   ht, 1.0f },</a>
<a name="ln2494">                           {   wd, 0.0f, 1.0f } };</a>
<a name="ln2495"> </a>
<a name="ln2496">  // convert the vertices to output image coordinates</a>
<a name="ln2497">  float V[4][3];</a>
<a name="ln2498">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2499">    mat3mulv(V[n], (float *)cropfit.homograph, Vc[n]);</a>
<a name="ln2500"> </a>
<a name="ln2501">  // get width and height of output image for later use</a>
<a name="ln2502">  float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN;</a>
<a name="ln2503">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2504">  {</a>
<a name="ln2505">    // normalize V</a>
<a name="ln2506">    V[n][0] /= V[n][2];</a>
<a name="ln2507">    V[n][1] /= V[n][2];</a>
<a name="ln2508">    V[n][2] = 1.0f;</a>
<a name="ln2509">    xmin = MIN(xmin, V[n][0]);</a>
<a name="ln2510">    xmax = MAX(xmax, V[n][0]);</a>
<a name="ln2511">    ymin = MIN(ymin, V[n][1]);</a>
<a name="ln2512">    ymax = MAX(ymax, V[n][1]);</a>
<a name="ln2513">  }</a>
<a name="ln2514">  const float owd = xmax - xmin;</a>
<a name="ln2515">  const float oht = ymax - ymin;</a>
<a name="ln2516"> </a>
<a name="ln2517">  // calculate the lines defining the four edges of the image area: E = V[n] x V[n+1]</a>
<a name="ln2518">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2519">    vec3prodn(cropfit.edges[n], V[n], V[(n + 1) % 4]);</a>
<a name="ln2520"> </a>
<a name="ln2521">  // initial fit parameters: crop area is centered and aspect angle is that of the original image</a>
<a name="ln2522">  // number of parameters: fit only crop center coordinates with a fixed aspect ratio, or fit all three variables</a>
<a name="ln2523">  if(p-&gt;cropmode == ASHIFT_CROP_LARGEST)</a>
<a name="ln2524">  {</a>
<a name="ln2525">    params[0] = 0.5;</a>
<a name="ln2526">    params[1] = 0.5;</a>
<a name="ln2527">    params[2] = atan2((float)cropfit.height, (float)cropfit.width);</a>
<a name="ln2528">    cropfit.x = NAN;</a>
<a name="ln2529">    cropfit.y = NAN;</a>
<a name="ln2530">    cropfit.alpha = NAN;</a>
<a name="ln2531">    pcount = 3;</a>
<a name="ln2532">  }</a>
<a name="ln2533">  else //(p-&gt;cropmode == ASHIFT_CROP_ASPECT)</a>
<a name="ln2534">  {</a>
<a name="ln2535">    params[0] = 0.5;</a>
<a name="ln2536">    params[1] = 0.5;</a>
<a name="ln2537">    cropfit.x = NAN;</a>
<a name="ln2538">    cropfit.y = NAN;</a>
<a name="ln2539">    cropfit.alpha = atan2((float)cropfit.height, (float)cropfit.width);</a>
<a name="ln2540">    pcount = 2;</a>
<a name="ln2541">  }</a>
<a name="ln2542"> </a>
<a name="ln2543">  // start the simplex fit</a>
<a name="ln2544">  const int iter = simplex(crop_fitness, params, pcount, NMS_CROP_EPSILON, NMS_CROP_SCALE, NMS_CROP_ITERATIONS,</a>
<a name="ln2545">                           crop_constraint, (void*)&amp;cropfit);</a>
<a name="ln2546"> </a>
<a name="ln2547">  // in case the fit did not converge -&gt; failed</a>
<a name="ln2548">  if(iter &gt;= NMS_CROP_ITERATIONS) goto failed;</a>
<a name="ln2549"> </a>
<a name="ln2550">  // the fit did converge -&gt; get clipping margins out of params:</a>
<a name="ln2551">  cropfit.x = isnan(cropfit.x) ? params[0] : cropfit.x;</a>
<a name="ln2552">  cropfit.y = isnan(cropfit.y) ? params[1] : cropfit.y;</a>
<a name="ln2553">  cropfit.alpha = isnan(cropfit.alpha) ? params[2] : cropfit.alpha;</a>
<a name="ln2554"> </a>
<a name="ln2555">  // the area of the best fitting rectangle</a>
<a name="ln2556">  const float A = fabs(crop_fitness(params, (void*)&amp;cropfit));</a>
<a name="ln2557"> </a>
<a name="ln2558">  // unlikely to happen but we need to catch this case</a>
<a name="ln2559">  if(A == 0.0f) goto failed;</a>
<a name="ln2560"> </a>
<a name="ln2561">  // we need the half diagonal of that rectangle (this is in output image dimensions);</a>
<a name="ln2562">  // no need to check for division by zero here as this case implies A == 0.0f, caught above</a>
<a name="ln2563">  const float d = sqrt(A / (2.0f * sin(2.0f * cropfit.alpha)));</a>
<a name="ln2564"> </a>
<a name="ln2565">  // the rectangle's center in input image (homogeneous) coordinates</a>
<a name="ln2566">  const float Pc[3] = { cropfit.x * wd, cropfit.y * ht, 1.0f };</a>
<a name="ln2567"> </a>
<a name="ln2568">  // convert rectangle center to output image coordinates and normalize</a>
<a name="ln2569">  float P[3];</a>
<a name="ln2570">  mat3mulv(P, (float *)cropfit.homograph, Pc);</a>
<a name="ln2571">  P[0] /= P[2];</a>
<a name="ln2572">  P[1] /= P[2];</a>
<a name="ln2573"> </a>
<a name="ln2574">  // calculate clipping margins relative to output image dimensions</a>
<a name="ln2575">  p-&gt;cl = CLAMP((P[0] - d * cos(cropfit.alpha)) / owd, 0.0f, 1.0f);</a>
<a name="ln2576">  p-&gt;cr = CLAMP((P[0] + d * cos(cropfit.alpha)) / owd, 0.0f, 1.0f);</a>
<a name="ln2577">  p-&gt;ct = CLAMP((P[1] - d * sin(cropfit.alpha)) / oht, 0.0f, 1.0f);</a>
<a name="ln2578">  p-&gt;cb = CLAMP((P[1] + d * sin(cropfit.alpha)) / oht, 0.0f, 1.0f);</a>
<a name="ln2579"> </a>
<a name="ln2580">  // final sanity check</a>
<a name="ln2581">  if(p-&gt;cr - p-&gt;cl &lt;= 0.0f || p-&gt;cb - p-&gt;ct &lt;= 0.0f) goto failed;</a>
<a name="ln2582"> </a>
<a name="ln2583">  g-&gt;fitting = 0;</a>
<a name="ln2584"> </a>
<a name="ln2585">#ifdef ASHIFT_DEBUG</a>
<a name="ln2586">  printf(&quot;margins after crop fitting: iter %d, x %f, y %f, angle %f, crop area (%f %f %f %f), width %f, height %f\n&quot;,</a>
<a name="ln2587">         iter, cropfit.x, cropfit.y, cropfit.alpha, p-&gt;cl, p-&gt;cr, p-&gt;ct, p-&gt;cb, wd, ht);</a>
<a name="ln2588">#endif</a>
<a name="ln2589">  dt_control_queue_redraw_center();</a>
<a name="ln2590">  return;</a>
<a name="ln2591"> </a>
<a name="ln2592">failed:</a>
<a name="ln2593">  // in case of failure: reset clipping margins, set &quot;automatic cropping&quot; parameter</a>
<a name="ln2594">  // to &quot;off&quot; state, and display warning message</a>
<a name="ln2595">  p-&gt;cl = 0.0f;</a>
<a name="ln2596">  p-&gt;cr = 1.0f;</a>
<a name="ln2597">  p-&gt;ct = 0.0f;</a>
<a name="ln2598">  p-&gt;cb = 1.0f;</a>
<a name="ln2599">  p-&gt;cropmode = ASHIFT_CROP_OFF;</a>
<a name="ln2600">  dt_bauhaus_combobox_set(g-&gt;cropmode, p-&gt;cropmode);</a>
<a name="ln2601">  g-&gt;fitting = 0;</a>
<a name="ln2602">  dt_control_log(_(&quot;automatic cropping failed&quot;));</a>
<a name="ln2603">  return;</a>
<a name="ln2604">}</a>
<a name="ln2605"> </a>
<a name="ln2606">// manually adjust crop area by shifting its center</a>
<a name="ln2607">static void crop_adjust(dt_iop_module_t *module, dt_iop_ashift_params_t *p, const float newx, const float newy)</a>
<a name="ln2608">{</a>
<a name="ln2609">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2610"> </a>
<a name="ln2611">  // skip if fitting is still running</a>
<a name="ln2612">  if(g-&gt;fitting) return;</a>
<a name="ln2613"> </a>
<a name="ln2614">  // get parameters for the homograph</a>
<a name="ln2615">  const float f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln2616">  const float orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln2617">  const float aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln2618">  const float rotation = p-&gt;rotation;</a>
<a name="ln2619">  const float lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln2620">  const float lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln2621">  const float shear = p-&gt;shear;</a>
<a name="ln2622"> </a>
<a name="ln2623">  const float wd = g-&gt;buf_width;</a>
<a name="ln2624">  const float ht = g-&gt;buf_height;</a>
<a name="ln2625"> </a>
<a name="ln2626">  const float alpha = atan2(ht, wd);</a>
<a name="ln2627"> </a>
<a name="ln2628">  float homograph[3][3];</a>
<a name="ln2629">  homography((float *)homograph, rotation, lensshift_v, lensshift_h, shear, f_length_kb,</a>
<a name="ln2630">             orthocorr, aspect, wd, ht, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln2631"> </a>
<a name="ln2632">  // the four vertices of the image in input image coordinates</a>
<a name="ln2633">  const float Vc[4][3] = { { 0.0f, 0.0f, 1.0f },</a>
<a name="ln2634">                           { 0.0f,   ht, 1.0f },</a>
<a name="ln2635">                           {   wd,   ht, 1.0f },</a>
<a name="ln2636">                           {   wd, 0.0f, 1.0f } };</a>
<a name="ln2637"> </a>
<a name="ln2638">  // convert the vertices to output image coordinates</a>
<a name="ln2639">  float V[4][3];</a>
<a name="ln2640">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2641">    mat3mulv(V[n], (float *)homograph, Vc[n]);</a>
<a name="ln2642"> </a>
<a name="ln2643">  // get width and height of output image</a>
<a name="ln2644">  float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN;</a>
<a name="ln2645">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2646">  {</a>
<a name="ln2647">    // normalize V</a>
<a name="ln2648">    V[n][0] /= V[n][2];</a>
<a name="ln2649">    V[n][1] /= V[n][2];</a>
<a name="ln2650">    V[n][2] = 1.0f;</a>
<a name="ln2651">    xmin = MIN(xmin, V[n][0]);</a>
<a name="ln2652">    xmax = MAX(xmax, V[n][0]);</a>
<a name="ln2653">    ymin = MIN(ymin, V[n][1]);</a>
<a name="ln2654">    ymax = MAX(ymax, V[n][1]);</a>
<a name="ln2655">  }</a>
<a name="ln2656">  const float owd = xmax - xmin;</a>
<a name="ln2657">  const float oht = ymax - ymin;</a>
<a name="ln2658"> </a>
<a name="ln2659">  // calculate the lines defining the four edges of the image area: E = V[n] x V[n+1]</a>
<a name="ln2660">  float E[4][3];</a>
<a name="ln2661">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2662">    vec3prodn(E[n], V[n], V[(n + 1) % 4]);</a>
<a name="ln2663"> </a>
<a name="ln2664">  // the center of the rectangle in output image coordinates</a>
<a name="ln2665">  const float P[3] = { newx * owd, newy * oht, 1.0f };</a>
<a name="ln2666"> </a>
<a name="ln2667">  // two auxiliary points (some arbitrary distance away from P) to construct the diagonals</a>
<a name="ln2668">  const float Pa[2][3] = { { P[0] + 10.0f * cos(alpha), P[1] + 10.0f * sin(alpha), 1.0f },</a>
<a name="ln2669">                           { P[0] + 10.0f * cos(alpha), P[1] - 10.0f * sin(alpha), 1.0f } };</a>
<a name="ln2670"> </a>
<a name="ln2671">  // the two diagonals: D = P x Pa</a>
<a name="ln2672">  float D[2][3];</a>
<a name="ln2673">  vec3prodn(D[0], P, Pa[0]);</a>
<a name="ln2674">  vec3prodn(D[1], P, Pa[1]);</a>
<a name="ln2675"> </a>
<a name="ln2676">  // find all intersection points of all four edges with both diagonals (I = E x D);</a>
<a name="ln2677">  // the shortest distance d2min of the intersection point I to the crop area center P determines</a>
<a name="ln2678">  // the size of the crop area that still fits into the image (for the given center and aspect angle)</a>
<a name="ln2679">  float d2min = FLT_MAX;</a>
<a name="ln2680">  for(int k = 0; k &lt; 4; k++)</a>
<a name="ln2681">    for(int l = 0; l &lt; 2; l++)</a>
<a name="ln2682">    {</a>
<a name="ln2683">      // the intersection point</a>
<a name="ln2684">      float I[3];</a>
<a name="ln2685">      vec3prodn(I, E[k], D[l]);</a>
<a name="ln2686"> </a>
<a name="ln2687">      // special case: I is all null -&gt; E and D are identical -&gt; P lies on E -&gt; d2min = 0</a>
<a name="ln2688">      if(vec3isnull(I))</a>
<a name="ln2689">      {</a>
<a name="ln2690">        d2min = 0.0f;</a>
<a name="ln2691">        break;</a>
<a name="ln2692">      }</a>
<a name="ln2693"> </a>
<a name="ln2694">      // special case: I[2] is 0.0f -&gt; E and D are parallel and intersect at infinity -&gt; no relevant point</a>
<a name="ln2695">      if(I[2] == 0.0f)</a>
<a name="ln2696">        continue;</a>
<a name="ln2697"> </a>
<a name="ln2698">      // the default case -&gt; normalize I</a>
<a name="ln2699">      I[0] /= I[2];</a>
<a name="ln2700">      I[1] /= I[2];</a>
<a name="ln2701"> </a>
<a name="ln2702">      // calculate distance from I to P</a>
<a name="ln2703">      const float d2 = SQR(P[0] - I[0]) + SQR(P[1] - I[1]);</a>
<a name="ln2704"> </a>
<a name="ln2705">      // the minimum distance over all intersection points</a>
<a name="ln2706">      d2min = MIN(d2min, d2);</a>
<a name="ln2707">    }</a>
<a name="ln2708"> </a>
<a name="ln2709">  const float d = sqrt(d2min);</a>
<a name="ln2710"> </a>
<a name="ln2711">  // do not allow crop area to drop below 1% of input image area</a>
<a name="ln2712">  const float A = 2.0f * d * d * sin(2.0f * alpha);</a>
<a name="ln2713">  if(A &lt; 0.01f * wd * ht) return;</a>
<a name="ln2714"> </a>
<a name="ln2715">  // calculate clipping margins relative to output image dimensions</a>
<a name="ln2716">  p-&gt;cl = CLAMP((P[0] - d * cos(alpha)) / owd, 0.0f, 1.0f);</a>
<a name="ln2717">  p-&gt;cr = CLAMP((P[0] + d * cos(alpha)) / owd, 0.0f, 1.0f);</a>
<a name="ln2718">  p-&gt;ct = CLAMP((P[1] - d * sin(alpha)) / oht, 0.0f, 1.0f);</a>
<a name="ln2719">  p-&gt;cb = CLAMP((P[1] + d * sin(alpha)) / oht, 0.0f, 1.0f);</a>
<a name="ln2720"> </a>
<a name="ln2721">#ifdef ASHIFT_DEBUG</a>
<a name="ln2722">  printf(&quot;margins after crop adjustment: x %f, y %f, angle %f, crop area (%f %f %f %f), width %f, height %f\n&quot;,</a>
<a name="ln2723">         0.5f * (p-&gt;cl + p-&gt;cr), 0.5f * (p-&gt;ct + p-&gt;cb), alpha, p-&gt;cl, p-&gt;cr, p-&gt;ct, p-&gt;cb, wd, ht);</a>
<a name="ln2724">#endif</a>
<a name="ln2725">  dt_control_queue_redraw_center();</a>
<a name="ln2726">  return;</a>
<a name="ln2727">}</a>
<a name="ln2728"> </a>
<a name="ln2729"> </a>
<a name="ln2730">// helper function to start analysis for structural data and report about errors</a>
<a name="ln2731">static int do_get_structure(dt_iop_module_t *module, dt_iop_ashift_params_t *p,</a>
<a name="ln2732">                            dt_iop_ashift_enhance_t enhance)</a>
<a name="ln2733">{</a>
<a name="ln2734">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2735"> </a>
<a name="ln2736">  if(g-&gt;fitting) return FALSE;</a>
<a name="ln2737"> </a>
<a name="ln2738">  g-&gt;fitting = 1;</a>
<a name="ln2739"> </a>
<a name="ln2740">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2741">  float *b = g-&gt;buf;</a>
<a name="ln2742">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2743"> </a>
<a name="ln2744">  if(b == NULL)</a>
<a name="ln2745">  {</a>
<a name="ln2746">    dt_control_log(_(&quot;data pending - please repeat&quot;));</a>
<a name="ln2747">    goto error;</a>
<a name="ln2748">  }</a>
<a name="ln2749"> </a>
<a name="ln2750">  if(!get_structure(module, enhance))</a>
<a name="ln2751">  {</a>
<a name="ln2752">    dt_control_log(_(&quot;could not detect structural data in image&quot;));</a>
<a name="ln2753">#ifdef ASHIFT_DEBUG</a>
<a name="ln2754">    // find out more</a>
<a name="ln2755">    printf(&quot;do_get_structure: buf %p, buf_hash %lu, buf_width %d, buf_height %d, lines %p, lines_count %d\n&quot;,</a>
<a name="ln2756">           g-&gt;buf, g-&gt;buf_hash, g-&gt;buf_width, g-&gt;buf_height, g-&gt;lines, g-&gt;lines_count);</a>
<a name="ln2757">#endif</a>
<a name="ln2758">    goto error;</a>
<a name="ln2759">  }</a>
<a name="ln2760"> </a>
<a name="ln2761">  if(!remove_outliers(module))</a>
<a name="ln2762">  {</a>
<a name="ln2763">    dt_control_log(_(&quot;could not run outlier removal&quot;));</a>
<a name="ln2764">#ifdef ASHIFT_DEBUG</a>
<a name="ln2765">    // find out more</a>
<a name="ln2766">    printf(&quot;remove_outliers: buf %p, buf_hash %lu, buf_width %d, buf_height %d, lines %p, lines_count %d\n&quot;,</a>
<a name="ln2767">           g-&gt;buf, g-&gt;buf_hash, g-&gt;buf_width, g-&gt;buf_height, g-&gt;lines, g-&gt;lines_count);</a>
<a name="ln2768">#endif</a>
<a name="ln2769">    goto error;</a>
<a name="ln2770">  }</a>
<a name="ln2771"> </a>
<a name="ln2772">  g-&gt;fitting = 0;</a>
<a name="ln2773">  return TRUE;</a>
<a name="ln2774"> </a>
<a name="ln2775">error:</a>
<a name="ln2776">  g-&gt;fitting = 0;</a>
<a name="ln2777">  return FALSE;</a>
<a name="ln2778">}</a>
<a name="ln2779"> </a>
<a name="ln2780">// helper function to clean structural data</a>
<a name="ln2781">static int do_clean_structure(dt_iop_module_t *module, dt_iop_ashift_params_t *p)</a>
<a name="ln2782">{</a>
<a name="ln2783">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2784"> </a>
<a name="ln2785">  if(g-&gt;fitting) return FALSE;</a>
<a name="ln2786"> </a>
<a name="ln2787">  g-&gt;fitting = 1;</a>
<a name="ln2788">  g-&gt;lines_count = 0;</a>
<a name="ln2789">  g-&gt;vertical_count = 0;</a>
<a name="ln2790">  g-&gt;horizontal_count = 0;</a>
<a name="ln2791">  free(g-&gt;lines);</a>
<a name="ln2792">  g-&gt;lines = NULL;</a>
<a name="ln2793">  g-&gt;lines_version++;</a>
<a name="ln2794">  g-&gt;lines_suppressed = 0;</a>
<a name="ln2795">  g-&gt;fitting = 0;</a>
<a name="ln2796">  return TRUE;</a>
<a name="ln2797">}</a>
<a name="ln2798"> </a>
<a name="ln2799">// helper function to start parameter fit and report about errors</a>
<a name="ln2800">static int do_fit(dt_iop_module_t *module, dt_iop_ashift_params_t *p, dt_iop_ashift_fitaxis_t dir)</a>
<a name="ln2801">{</a>
<a name="ln2802">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2803"> </a>
<a name="ln2804">  if(g-&gt;fitting) return FALSE;</a>
<a name="ln2805"> </a>
<a name="ln2806">  // if no structure available get it</a>
<a name="ln2807">  if(g-&gt;lines == NULL)</a>
<a name="ln2808">    if(!do_get_structure(module, p, ASHIFT_ENHANCE_NONE)) goto error;</a>
<a name="ln2809"> </a>
<a name="ln2810">  g-&gt;fitting = 1;</a>
<a name="ln2811"> </a>
<a name="ln2812">  dt_iop_ashift_nmsresult_t res = nmsfit(module, p, dir);</a>
<a name="ln2813"> </a>
<a name="ln2814">  switch(res)</a>
<a name="ln2815">  {</a>
<a name="ln2816">    case NMS_NOT_ENOUGH_LINES:</a>
<a name="ln2817">      dt_control_log(_(&quot;not enough structure for automatic correction&quot;));</a>
<a name="ln2818">      goto error;</a>
<a name="ln2819">      break;</a>
<a name="ln2820">    case NMS_DID_NOT_CONVERGE:</a>
<a name="ln2821">    case NMS_INSANE:</a>
<a name="ln2822">      dt_control_log(_(&quot;automatic correction failed, please correct manually&quot;));</a>
<a name="ln2823">      goto error;</a>
<a name="ln2824">      break;</a>
<a name="ln2825">    case NMS_SUCCESS:</a>
<a name="ln2826">    default:</a>
<a name="ln2827">      break;</a>
<a name="ln2828">  }</a>
<a name="ln2829"> </a>
<a name="ln2830">  g-&gt;fitting = 0;</a>
<a name="ln2831"> </a>
<a name="ln2832">  // finally apply cropping</a>
<a name="ln2833">  do_crop(module, p);</a>
<a name="ln2834"> </a>
<a name="ln2835">  return TRUE;</a>
<a name="ln2836"> </a>
<a name="ln2837">error:</a>
<a name="ln2838">  g-&gt;fitting = 0;</a>
<a name="ln2839">  return FALSE;</a>
<a name="ln2840">}</a>
<a name="ln2841"> </a>
<a name="ln2842"> </a>
<a name="ln2843">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln2844">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2845">{</a>
<a name="ln2846">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln2847">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2848"> </a>
<a name="ln2849">  const int ch = piece-&gt;colors;</a>
<a name="ln2850">  const int ch_width = ch * roi_in-&gt;width;</a>
<a name="ln2851"> </a>
<a name="ln2852">  // only for preview pipe: collect input buffer data and do some other evaluations</a>
<a name="ln2853">  if(self-&gt;dev-&gt;gui_attached &amp;&amp; g &amp;&amp; piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln2854">  {</a>
<a name="ln2855">    // we want to find out if the final output image is flipped in relation to this iop</a>
<a name="ln2856">    // so we can adjust the gui labels accordingly</a>
<a name="ln2857"> </a>
<a name="ln2858">    const int width = roi_in-&gt;width;</a>
<a name="ln2859">    const int height = roi_in-&gt;height;</a>
<a name="ln2860">    const int x_off = roi_in-&gt;x;</a>
<a name="ln2861">    const int y_off = roi_in-&gt;y;</a>
<a name="ln2862">    const float scale = roi_in-&gt;scale;</a>
<a name="ln2863"> </a>
<a name="ln2864">    // origin of image and opposite corner as reference points</a>
<a name="ln2865">    float points[4] = { 0.0f, 0.0f, (float)piece-&gt;buf_in.width, (float)piece-&gt;buf_in.height };</a>
<a name="ln2866">    float ivec[2] = { points[2] - points[0], points[3] - points[1] };</a>
<a name="ln2867">    float ivecl = sqrt(ivec[0] * ivec[0] + ivec[1] * ivec[1]);</a>
<a name="ln2868"> </a>
<a name="ln2869">    // where do they go?</a>
<a name="ln2870">    dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, points,</a>
<a name="ln2871">                                      2);</a>
<a name="ln2872"> </a>
<a name="ln2873">    float ovec[2] = { points[2] - points[0], points[3] - points[1] };</a>
<a name="ln2874">    float ovecl = sqrt(ovec[0] * ovec[0] + ovec[1] * ovec[1]);</a>
<a name="ln2875"> </a>
<a name="ln2876">    // angle between input vector and output vector</a>
<a name="ln2877">    float alpha = acos(CLAMP((ivec[0] * ovec[0] + ivec[1] * ovec[1]) / (ivecl * ovecl), -1.0f, 1.0f));</a>
<a name="ln2878"> </a>
<a name="ln2879">    // we are interested if |alpha| is in the range of 90 +/- 45 -&gt; we assume the image is flipped</a>
<a name="ln2880">    int isflipped = fabs(fmod(alpha + M_PI, M_PI) - M_PI / 2.0f) &lt; M_PI / 4.0f ? 1 : 0;</a>
<a name="ln2881"> </a>
<a name="ln2882">    // did modules prior to this one in pixelpipe have changed? -&gt; check via hash value</a>
<a name="ln2883">    uint64_t hash = dt_dev_hash_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_EXCL);</a>
<a name="ln2884"> </a>
<a name="ln2885">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2886">    g-&gt;isflipped = isflipped;</a>
<a name="ln2887"> </a>
<a name="ln2888">    // save a copy of preview input buffer for parameter fitting</a>
<a name="ln2889">    if(g-&gt;buf == NULL || (size_t)g-&gt;buf_width * g-&gt;buf_height &lt; (size_t)width * height)</a>
<a name="ln2890">    {</a>
<a name="ln2891">      // if needed allocate buffer</a>
<a name="ln2892">      free(g-&gt;buf); // a no-op if g-&gt;buf is NULL</a>
<a name="ln2893">      // only get new buffer if no old buffer available or old buffer does not fit in terms of size</a>
<a name="ln2894">      g-&gt;buf = malloc((size_t)width * height * 4 * sizeof(float));</a>
<a name="ln2895">    }</a>
<a name="ln2896"> </a>
<a name="ln2897">    if(g-&gt;buf /* &amp;&amp; hash != g-&gt;buf_hash */)</a>
<a name="ln2898">    {</a>
<a name="ln2899">      // copy data</a>
<a name="ln2900">      memcpy(g-&gt;buf, ivoid, (size_t)width * height * ch * sizeof(float));</a>
<a name="ln2901"> </a>
<a name="ln2902">      g-&gt;buf_width = width;</a>
<a name="ln2903">      g-&gt;buf_height = height;</a>
<a name="ln2904">      g-&gt;buf_x_off = x_off;</a>
<a name="ln2905">      g-&gt;buf_y_off = y_off;</a>
<a name="ln2906">      g-&gt;buf_scale = scale;</a>
<a name="ln2907">      g-&gt;buf_hash = hash;</a>
<a name="ln2908">    }</a>
<a name="ln2909"> </a>
<a name="ln2910">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2911">  }</a>
<a name="ln2912"> </a>
<a name="ln2913">  // if module is set to neutral parameters we just copy input-&gt;output and are done</a>
<a name="ln2914">  if(isneutral(data))</a>
<a name="ln2915">  {</a>
<a name="ln2916">    memcpy(ovoid, ivoid, (size_t)roi_out-&gt;width * roi_out-&gt;height * ch * sizeof(float));</a>
<a name="ln2917">    return;</a>
<a name="ln2918">  }</a>
<a name="ln2919"> </a>
<a name="ln2920">  const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln2921"> </a>
<a name="ln2922">  float ihomograph[3][3];</a>
<a name="ln2923">  homography((float *)ihomograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln2924">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln2925"> </a>
<a name="ln2926">  // clipping offset</a>
<a name="ln2927">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln2928">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln2929">  const float cx = roi_out-&gt;scale * fullwidth * data-&gt;cl;</a>
<a name="ln2930">  const float cy = roi_out-&gt;scale * fullheight * data-&gt;ct;</a>
<a name="ln2931"> </a>
<a name="ln2932"> </a>
<a name="ln2933">#ifdef _OPENMP</a>
<a name="ln2934">#pragma omp parallel for default(none) \</a>
<a name="ln2935">  dt_omp_firstprivate(ch, ch_width, cx, cy, ivoid, ovoid, roi_in, roi_out) \</a>
<a name="ln2936">  shared(ihomograph, interpolation) \</a>
<a name="ln2937">  schedule(static)</a>
<a name="ln2938">#endif</a>
<a name="ln2939">  // go over all pixels of output image</a>
<a name="ln2940">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln2941">  {</a>
<a name="ln2942">    float *out = ((float *)ovoid) + (size_t)ch * j * roi_out-&gt;width;</a>
<a name="ln2943">    for(int i = 0; i &lt; roi_out-&gt;width; i++, out += ch)</a>
<a name="ln2944">    {</a>
<a name="ln2945">      float pin[3], pout[3];</a>
<a name="ln2946"> </a>
<a name="ln2947">      // convert output pixel coordinates to original image coordinates</a>
<a name="ln2948">      pout[0] = roi_out-&gt;x + i + cx;</a>
<a name="ln2949">      pout[1] = roi_out-&gt;y + j + cy;</a>
<a name="ln2950">      pout[0] /= roi_out-&gt;scale;</a>
<a name="ln2951">      pout[1] /= roi_out-&gt;scale;</a>
<a name="ln2952">      pout[2] = 1.0f;</a>
<a name="ln2953"> </a>
<a name="ln2954">      // apply homograph</a>
<a name="ln2955">      mat3mulv(pin, (float *)ihomograph, pout);</a>
<a name="ln2956"> </a>
<a name="ln2957">      // convert to input pixel coordinates</a>
<a name="ln2958">      pin[0] /= pin[2];</a>
<a name="ln2959">      pin[1] /= pin[2];</a>
<a name="ln2960">      pin[0] *= roi_in-&gt;scale;</a>
<a name="ln2961">      pin[1] *= roi_in-&gt;scale;</a>
<a name="ln2962">      pin[0] -= roi_in-&gt;x;</a>
<a name="ln2963">      pin[1] -= roi_in-&gt;y;</a>
<a name="ln2964"> </a>
<a name="ln2965">      // get output values by interpolation from input image</a>
<a name="ln2966">      dt_interpolation_compute_pixel4c(interpolation, (float *)ivoid, out, pin[0], pin[1], roi_in-&gt;width,</a>
<a name="ln2967">                                       roi_in-&gt;height, ch_width);</a>
<a name="ln2968">    }</a>
<a name="ln2969">  }</a>
<a name="ln2970">}</a>
<a name="ln2971"> </a>
<a name="ln2972">#ifdef HAVE_OPENCL</a>
<a name="ln2973">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln2974">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2975">{</a>
<a name="ln2976">  dt_iop_ashift_data_t *d = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln2977">  dt_iop_ashift_global_data_t *gd = (dt_iop_ashift_global_data_t *)self-&gt;data;</a>
<a name="ln2978">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2979"> </a>
<a name="ln2980">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln2981">  const int iwidth = roi_in-&gt;width;</a>
<a name="ln2982">  const int iheight = roi_in-&gt;height;</a>
<a name="ln2983">  const int width = roi_out-&gt;width;</a>
<a name="ln2984">  const int height = roi_out-&gt;height;</a>
<a name="ln2985"> </a>
<a name="ln2986">  cl_int err = -999;</a>
<a name="ln2987">  cl_mem dev_homo = NULL;</a>
<a name="ln2988"> </a>
<a name="ln2989">  // only for preview pipe: collect input buffer data and do some other evaluations</a>
<a name="ln2990">  if(self-&gt;dev-&gt;gui_attached &amp;&amp; g &amp;&amp; piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln2991">  {</a>
<a name="ln2992">    // we want to find out if the final output image is flipped in relation to this iop</a>
<a name="ln2993">    // so we can adjust the gui labels accordingly</a>
<a name="ln2994"> </a>
<a name="ln2995">    const int x_off = roi_in-&gt;x;</a>
<a name="ln2996">    const int y_off = roi_in-&gt;y;</a>
<a name="ln2997">    const float scale = roi_in-&gt;scale;</a>
<a name="ln2998"> </a>
<a name="ln2999">    // origin of image and opposite corner as reference points</a>
<a name="ln3000">    float points[4] = { 0.0f, 0.0f, (float)piece-&gt;buf_in.width, (float)piece-&gt;buf_in.height };</a>
<a name="ln3001">    float ivec[2] = { points[2] - points[0], points[3] - points[1] };</a>
<a name="ln3002">    float ivecl = sqrt(ivec[0] * ivec[0] + ivec[1] * ivec[1]);</a>
<a name="ln3003"> </a>
<a name="ln3004">    // where do they go?</a>
<a name="ln3005">    dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, points,</a>
<a name="ln3006">                                      2);</a>
<a name="ln3007"> </a>
<a name="ln3008">    float ovec[2] = { points[2] - points[0], points[3] - points[1] };</a>
<a name="ln3009">    float ovecl = sqrt(ovec[0] * ovec[0] + ovec[1] * ovec[1]);</a>
<a name="ln3010"> </a>
<a name="ln3011">    // angle between input vector and output vector</a>
<a name="ln3012">    float alpha = acos(CLAMP((ivec[0] * ovec[0] + ivec[1] * ovec[1]) / (ivecl * ovecl), -1.0f, 1.0f));</a>
<a name="ln3013"> </a>
<a name="ln3014">    // we are interested if |alpha| is in the range of 90 +/- 45 -&gt; we assume the image is flipped</a>
<a name="ln3015">    int isflipped = fabs(fmod(alpha + M_PI, M_PI) - M_PI / 2.0f) &lt; M_PI / 4.0f ? 1 : 0;</a>
<a name="ln3016"> </a>
<a name="ln3017">    // do modules coming before this one in pixelpipe have changed? -&gt; check via hash value</a>
<a name="ln3018">    uint64_t hash = dt_dev_hash_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_EXCL);</a>
<a name="ln3019"> </a>
<a name="ln3020">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln3021">    g-&gt;isflipped = isflipped;</a>
<a name="ln3022"> </a>
<a name="ln3023">    // save a copy of preview input buffer for parameter fitting</a>
<a name="ln3024">    if(g-&gt;buf == NULL || (size_t)g-&gt;buf_width * g-&gt;buf_height &lt; (size_t)iwidth * iheight)</a>
<a name="ln3025">    {</a>
<a name="ln3026">      // if needed allocate buffer</a>
<a name="ln3027">      free(g-&gt;buf); // a no-op if g-&gt;buf is NULL</a>
<a name="ln3028">      // only get new buffer if no old buffer or old buffer does not fit in terms of size</a>
<a name="ln3029">      g-&gt;buf = malloc((size_t)iwidth * iheight * 4 * sizeof(float));</a>
<a name="ln3030">    }</a>
<a name="ln3031"> </a>
<a name="ln3032">    if(g-&gt;buf /* &amp;&amp; hash != g-&gt;buf_hash */)</a>
<a name="ln3033">    {</a>
<a name="ln3034">      // copy data</a>
<a name="ln3035">      err = dt_opencl_copy_device_to_host(devid, g-&gt;buf, dev_in, iwidth, iheight, 4 * sizeof(float));</a>
<a name="ln3036"> </a>
<a name="ln3037">      g-&gt;buf_width = iwidth;</a>
<a name="ln3038">      g-&gt;buf_height = iheight;</a>
<a name="ln3039">      g-&gt;buf_x_off = x_off;</a>
<a name="ln3040">      g-&gt;buf_y_off = y_off;</a>
<a name="ln3041">      g-&gt;buf_scale = scale;</a>
<a name="ln3042">      g-&gt;buf_hash = hash;</a>
<a name="ln3043">    }</a>
<a name="ln3044">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln3045">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3046">  }</a>
<a name="ln3047"> </a>
<a name="ln3048">  // if module is set to neutral parameters we just copy input-&gt;output and are done</a>
<a name="ln3049">  if(isneutral(d))</a>
<a name="ln3050">  {</a>
<a name="ln3051">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3052">    size_t region[] = { width, height, 1 };</a>
<a name="ln3053">    err = dt_opencl_enqueue_copy_image(devid, dev_in, dev_out, origin, origin, region);</a>
<a name="ln3054">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3055">    return TRUE;</a>
<a name="ln3056">  }</a>
<a name="ln3057"> </a>
<a name="ln3058">  float ihomograph[3][3];</a>
<a name="ln3059">  homography((float *)ihomograph, d-&gt;rotation, d-&gt;lensshift_v, d-&gt;lensshift_h, d-&gt;shear, d-&gt;f_length_kb,</a>
<a name="ln3060">             d-&gt;orthocorr, d-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln3061"> </a>
<a name="ln3062">  // clipping offset</a>
<a name="ln3063">  const float fullwidth = (float)piece-&gt;buf_out.width / (d-&gt;cr - d-&gt;cl);</a>
<a name="ln3064">  const float fullheight = (float)piece-&gt;buf_out.height / (d-&gt;cb - d-&gt;ct);</a>
<a name="ln3065">  const float cx = roi_out-&gt;scale * fullwidth * d-&gt;cl;</a>
<a name="ln3066">  const float cy = roi_out-&gt;scale * fullheight * d-&gt;ct;</a>
<a name="ln3067"> </a>
<a name="ln3068">  dev_homo = dt_opencl_copy_host_to_device_constant(devid, sizeof(float) * 9, ihomograph);</a>
<a name="ln3069">  if(dev_homo == NULL) goto error;</a>
<a name="ln3070"> </a>
<a name="ln3071">  const int iroi[2] = { roi_in-&gt;x, roi_in-&gt;y };</a>
<a name="ln3072">  const int oroi[2] = { roi_out-&gt;x, roi_out-&gt;y };</a>
<a name="ln3073">  const float in_scale = roi_in-&gt;scale;</a>
<a name="ln3074">  const float out_scale = roi_out-&gt;scale;</a>
<a name="ln3075">  const float clip[2] = { cx, cy };</a>
<a name="ln3076"> </a>
<a name="ln3077">  size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3078"> </a>
<a name="ln3079">  const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln3080"> </a>
<a name="ln3081">  int ldkernel = -1;</a>
<a name="ln3082"> </a>
<a name="ln3083">  switch(interpolation-&gt;id)</a>
<a name="ln3084">  {</a>
<a name="ln3085">    case DT_INTERPOLATION_BILINEAR:</a>
<a name="ln3086">      ldkernel = gd-&gt;kernel_ashift_bilinear;</a>
<a name="ln3087">      break;</a>
<a name="ln3088">    case DT_INTERPOLATION_BICUBIC:</a>
<a name="ln3089">      ldkernel = gd-&gt;kernel_ashift_bicubic;</a>
<a name="ln3090">      break;</a>
<a name="ln3091">    case DT_INTERPOLATION_LANCZOS2:</a>
<a name="ln3092">      ldkernel = gd-&gt;kernel_ashift_lanczos2;</a>
<a name="ln3093">      break;</a>
<a name="ln3094">    case DT_INTERPOLATION_LANCZOS3:</a>
<a name="ln3095">      ldkernel = gd-&gt;kernel_ashift_lanczos3;</a>
<a name="ln3096">      break;</a>
<a name="ln3097">    default:</a>
<a name="ln3098">      goto error;</a>
<a name="ln3099">  }</a>
<a name="ln3100"> </a>
<a name="ln3101">  dt_opencl_set_kernel_arg(devid, ldkernel, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3102">  dt_opencl_set_kernel_arg(devid, ldkernel, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3103">  dt_opencl_set_kernel_arg(devid, ldkernel, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3104">  dt_opencl_set_kernel_arg(devid, ldkernel, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3105">  dt_opencl_set_kernel_arg(devid, ldkernel, 4, sizeof(int), (void *)&amp;iwidth);</a>
<a name="ln3106">  dt_opencl_set_kernel_arg(devid, ldkernel, 5, sizeof(int), (void *)&amp;iheight);</a>
<a name="ln3107">  dt_opencl_set_kernel_arg(devid, ldkernel, 6, 2 * sizeof(int), (void *)iroi);</a>
<a name="ln3108">  dt_opencl_set_kernel_arg(devid, ldkernel, 7, 2 * sizeof(int), (void *)oroi);</a>
<a name="ln3109">  dt_opencl_set_kernel_arg(devid, ldkernel, 8, sizeof(float), (void *)&amp;in_scale);</a>
<a name="ln3110">  dt_opencl_set_kernel_arg(devid, ldkernel, 9, sizeof(float), (void *)&amp;out_scale);</a>
<a name="ln3111">  dt_opencl_set_kernel_arg(devid, ldkernel, 10, 2 * sizeof(float), (void *)clip);</a>
<a name="ln3112">  dt_opencl_set_kernel_arg(devid, ldkernel, 11, sizeof(cl_mem), (void *)&amp;dev_homo);</a>
<a name="ln3113">  err = dt_opencl_enqueue_kernel_2d(devid, ldkernel, sizes);</a>
<a name="ln3114">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln3115"> </a>
<a name="ln3116">  dt_opencl_release_mem_object(dev_homo);</a>
<a name="ln3117">  return TRUE;</a>
<a name="ln3118"> </a>
<a name="ln3119">error:</a>
<a name="ln3120">  dt_opencl_release_mem_object(dev_homo);</a>
<a name="ln3121">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_ashift] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3122">  return FALSE;</a>
<a name="ln3123">}</a>
<a name="ln3124">#endif</a>
<a name="ln3125"> </a>
<a name="ln3126">// gather information about &quot;near&quot;-ness in g-&gt;points_idx</a>
<a name="ln3127">static void get_near(const float *points, dt_iop_ashift_points_idx_t *points_idx, const int lines_count,</a>
<a name="ln3128">                     float pzx, float pzy, float delta)</a>
<a name="ln3129">{</a>
<a name="ln3130">  const float delta2 = delta * delta;</a>
<a name="ln3131"> </a>
<a name="ln3132">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3133">  {</a>
<a name="ln3134">    points_idx[n].near = 0;</a>
<a name="ln3135"> </a>
<a name="ln3136">    // skip irrelevant lines</a>
<a name="ln3137">    if(points_idx[n].type == ASHIFT_LINE_IRRELEVANT)</a>
<a name="ln3138">      continue;</a>
<a name="ln3139"> </a>
<a name="ln3140">    // first check if the mouse pointer is outside the bounding box of the line -&gt; skip this line</a>
<a name="ln3141">    if(pzx &lt; points_idx[n].bbx - delta &amp;&amp;</a>
<a name="ln3142">       pzx &gt; points_idx[n].bbX + delta &amp;&amp;</a>
<a name="ln3143">       pzy &lt; points_idx[n].bby - delta &amp;&amp;</a>
<a name="ln3144">       pzy &gt; points_idx[n].bbY + delta)</a>
<a name="ln3145">      continue;</a>
<a name="ln3146"> </a>
<a name="ln3147">    // pointer is inside bounding box</a>
<a name="ln3148">    size_t offset = points_idx[n].offset;</a>
<a name="ln3149">    const int length = points_idx[n].length;</a>
<a name="ln3150"> </a>
<a name="ln3151">    // sanity check (this should not happen)</a>
<a name="ln3152">    if(length &lt; 2) continue;</a>
<a name="ln3153"> </a>
<a name="ln3154">    // check line point by point</a>
<a name="ln3155">    for(int l = 0; l &lt; length; l++, offset++)</a>
<a name="ln3156">    {</a>
<a name="ln3157">      float dx = pzx - points[offset * 2];</a>
<a name="ln3158">      float dy = pzy - points[offset * 2 + 1];</a>
<a name="ln3159"> </a>
<a name="ln3160">      if(dx * dx + dy * dy &lt; delta2)</a>
<a name="ln3161">      {</a>
<a name="ln3162">        points_idx[n].near = 1;</a>
<a name="ln3163">        break;</a>
<a name="ln3164">      }</a>
<a name="ln3165">    }</a>
<a name="ln3166">  }</a>
<a name="ln3167">}</a>
<a name="ln3168"> </a>
<a name="ln3169">// mark lines which are inside a rectangular area in isbounding mode</a>
<a name="ln3170">static void get_bounded_inside(const float *points, dt_iop_ashift_points_idx_t *points_idx,</a>
<a name="ln3171">                               const int points_lines_count, float pzx, float pzy, float pzx2, float pzy2,</a>
<a name="ln3172">                               dt_iop_ashift_bounding_t mode)</a>
<a name="ln3173">{</a>
<a name="ln3174">  // get bounding box coordinates</a>
<a name="ln3175">  float ax = pzx;</a>
<a name="ln3176">  float ay = pzy;</a>
<a name="ln3177">  float bx = pzx2;</a>
<a name="ln3178">  float by = pzy2;</a>
<a name="ln3179">  if(pzx &gt; pzx2)</a>
<a name="ln3180">  {</a>
<a name="ln3181">    ax = pzx2;</a>
<a name="ln3182">    bx = pzx;</a>
<a name="ln3183">  }</a>
<a name="ln3184">  if(pzy &gt; pzy2)</a>
<a name="ln3185">  {</a>
<a name="ln3186">    ay = pzy2;</a>
<a name="ln3187">    by = pzy;</a>
<a name="ln3188">  }</a>
<a name="ln3189"> </a>
<a name="ln3190">  // we either look for the selected or the deselected lines</a>
<a name="ln3191">  dt_iop_ashift_linetype_t mask = ASHIFT_LINE_SELECTED;</a>
<a name="ln3192">  dt_iop_ashift_linetype_t state = (mode == ASHIFT_BOUNDING_DESELECT) ? ASHIFT_LINE_SELECTED : 0;</a>
<a name="ln3193"> </a>
<a name="ln3194">  for(int n = 0; n &lt; points_lines_count; n++)</a>
<a name="ln3195">  {</a>
<a name="ln3196">    // mark line as &quot;not near&quot; and &quot;not bounded&quot;</a>
<a name="ln3197">    points_idx[n].near = 0;</a>
<a name="ln3198">    points_idx[n].bounded = 0;</a>
<a name="ln3199"> </a>
<a name="ln3200">    // skip irrelevant lines</a>
<a name="ln3201">    if(points_idx[n].type == ASHIFT_LINE_IRRELEVANT)</a>
<a name="ln3202">      continue;</a>
<a name="ln3203"> </a>
<a name="ln3204">    // is the line inside the box ?</a>
<a name="ln3205">    if(points_idx[n].bbx &gt;= ax &amp;&amp; points_idx[n].bbx &lt;= bx &amp;&amp; points_idx[n].bbX &gt;= ax</a>
<a name="ln3206">       &amp;&amp; points_idx[n].bbX &lt;= bx &amp;&amp; points_idx[n].bby &gt;= ay &amp;&amp; points_idx[n].bby &lt;= by</a>
<a name="ln3207">       &amp;&amp; points_idx[n].bbY &gt;= ay &amp;&amp; points_idx[n].bbY &lt;= by)</a>
<a name="ln3208">    {</a>
<a name="ln3209">      points_idx[n].bounded = 1;</a>
<a name="ln3210">      // only mark &quot;near&quot;-ness of those lines we are interested in</a>
<a name="ln3211">      points_idx[n].near = ((points_idx[n].type &amp; mask) != state) ? 0 : 1;</a>
<a name="ln3212">    }</a>
<a name="ln3213">  }</a>
<a name="ln3214">}</a>
<a name="ln3215"> </a>
<a name="ln3216">// generate hash value for lines taking into account only the end point coordinates</a>
<a name="ln3217">static uint64_t get_lines_hash(const dt_iop_ashift_line_t *lines, const int lines_count)</a>
<a name="ln3218">{</a>
<a name="ln3219">  uint64_t hash = 5381;</a>
<a name="ln3220">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3221">  {</a>
<a name="ln3222">    float v[4] = { lines[n].p1[0], lines[n].p1[1], lines[n].p2[0], lines[n].p2[1] };</a>
<a name="ln3223">    union {</a>
<a name="ln3224">        float f;</a>
<a name="ln3225">        uint32_t u;</a>
<a name="ln3226">    } x;</a>
<a name="ln3227"> </a>
<a name="ln3228">    for(size_t i = 0; i &lt; 4; i++) {</a>
<a name="ln3229">      x.f = v[i];</a>
<a name="ln3230">      hash = ((hash &lt;&lt; 5) + hash) ^ x.u;</a>
<a name="ln3231">    }</a>
<a name="ln3232">  }</a>
<a name="ln3233">  return hash;</a>
<a name="ln3234">}</a>
<a name="ln3235"> </a>
<a name="ln3236">// update color information in points_idx if lines have changed in terms of type (but not in terms</a>
<a name="ln3237">// of number or position)</a>
<a name="ln3238">static int update_colors(struct dt_iop_module_t *self, dt_iop_ashift_points_idx_t *points_idx,</a>
<a name="ln3239">                         int points_lines_count)</a>
<a name="ln3240">{</a>
<a name="ln3241">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3242"> </a>
<a name="ln3243">  // is the display flipped relative to the original image?</a>
<a name="ln3244">  const int isflipped = g-&gt;isflipped;</a>
<a name="ln3245"> </a>
<a name="ln3246">  // go through all lines</a>
<a name="ln3247">  for(int n = 0; n &lt; points_lines_count; n++)</a>
<a name="ln3248">  {</a>
<a name="ln3249">    const dt_iop_ashift_linetype_t type = points_idx[n].type;</a>
<a name="ln3250"> </a>
<a name="ln3251">    // set line color according to line type/orientation</a>
<a name="ln3252">    // note: if the screen display is flipped versus the original image we need</a>
<a name="ln3253">    // to respect that fact in the color selection</a>
<a name="ln3254">    if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_SELECTED)</a>
<a name="ln3255">      points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_BLUE : ASHIFT_LINECOLOR_GREEN;</a>
<a name="ln3256">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_NOT_SELECTED)</a>
<a name="ln3257">      points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_YELLOW : ASHIFT_LINECOLOR_RED;</a>
<a name="ln3258">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_SELECTED)</a>
<a name="ln3259">      points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_GREEN : ASHIFT_LINECOLOR_BLUE;</a>
<a name="ln3260">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_NOT_SELECTED)</a>
<a name="ln3261">      points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_RED : ASHIFT_LINECOLOR_YELLOW;</a>
<a name="ln3262">    else</a>
<a name="ln3263">      points_idx[n].color = ASHIFT_LINECOLOR_GREY;</a>
<a name="ln3264">  }</a>
<a name="ln3265"> </a>
<a name="ln3266">  return TRUE;</a>
<a name="ln3267">}</a>
<a name="ln3268"> </a>
<a name="ln3269">// get all the points to display lines in the gui</a>
<a name="ln3270">static int get_points(struct dt_iop_module_t *self, const dt_iop_ashift_line_t *lines, const int lines_count,</a>
<a name="ln3271">                      const int lines_version, float **points, dt_iop_ashift_points_idx_t **points_idx,</a>
<a name="ln3272">                      int *points_lines_count)</a>
<a name="ln3273">{</a>
<a name="ln3274">  dt_develop_t *dev = self-&gt;dev;</a>
<a name="ln3275">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3276"> </a>
<a name="ln3277">  dt_iop_ashift_points_idx_t *my_points_idx = NULL;</a>
<a name="ln3278">  float *my_points = NULL;</a>
<a name="ln3279"> </a>
<a name="ln3280">  // is the display flipped relative to the original image?</a>
<a name="ln3281">  const int isflipped = g-&gt;isflipped;</a>
<a name="ln3282"> </a>
<a name="ln3283">  // allocate new index array</a>
<a name="ln3284">  my_points_idx = (dt_iop_ashift_points_idx_t *)malloc(lines_count * sizeof(dt_iop_ashift_points_idx_t));</a>
<a name="ln3285">  if(my_points_idx == NULL) goto error;</a>
<a name="ln3286"> </a>
<a name="ln3287">  // account for total number of points</a>
<a name="ln3288">  size_t total_points = 0;</a>
<a name="ln3289"> </a>
<a name="ln3290">  // first step: basic initialization of my_points_idx and counting of total_points</a>
<a name="ln3291">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3292">  {</a>
<a name="ln3293">    const int length = lines[n].length;</a>
<a name="ln3294"> </a>
<a name="ln3295">    total_points += length;</a>
<a name="ln3296"> </a>
<a name="ln3297">    my_points_idx[n].length = length;</a>
<a name="ln3298">    my_points_idx[n].near = 0;</a>
<a name="ln3299">    my_points_idx[n].bounded = 0;</a>
<a name="ln3300"> </a>
<a name="ln3301">    const dt_iop_ashift_linetype_t type = lines[n].type;</a>
<a name="ln3302">    my_points_idx[n].type = type;</a>
<a name="ln3303"> </a>
<a name="ln3304">    // set line color according to line type/orientation</a>
<a name="ln3305">    // note: if the screen display is flipped versus the original image we need</a>
<a name="ln3306">    // to respect that fact in the color selection</a>
<a name="ln3307">    if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_SELECTED)</a>
<a name="ln3308">      my_points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_BLUE : ASHIFT_LINECOLOR_GREEN;</a>
<a name="ln3309">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_NOT_SELECTED)</a>
<a name="ln3310">      my_points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_YELLOW : ASHIFT_LINECOLOR_RED;</a>
<a name="ln3311">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_SELECTED)</a>
<a name="ln3312">      my_points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_GREEN : ASHIFT_LINECOLOR_BLUE;</a>
<a name="ln3313">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_NOT_SELECTED)</a>
<a name="ln3314">      my_points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_RED : ASHIFT_LINECOLOR_YELLOW;</a>
<a name="ln3315">    else</a>
<a name="ln3316">      my_points_idx[n].color = ASHIFT_LINECOLOR_GREY;</a>
<a name="ln3317">  }</a>
<a name="ln3318"> </a>
<a name="ln3319">  // now allocate new points buffer</a>
<a name="ln3320">  my_points = (float *)malloc((size_t)2 * total_points * sizeof(float));</a>
<a name="ln3321">  if(my_points == NULL) goto error;</a>
<a name="ln3322"> </a>
<a name="ln3323">  // second step: generate points for each line</a>
<a name="ln3324">  for(int n = 0, offset = 0; n &lt; lines_count; n++)</a>
<a name="ln3325">  {</a>
<a name="ln3326">    my_points_idx[n].offset = offset;</a>
<a name="ln3327"> </a>
<a name="ln3328">    float x = lines[n].p1[0];</a>
<a name="ln3329">    float y = lines[n].p1[1];</a>
<a name="ln3330">    const int length = lines[n].length;</a>
<a name="ln3331"> </a>
<a name="ln3332">    const float dx = (lines[n].p2[0] - x) / (float)(length - 1);</a>
<a name="ln3333">    const float dy = (lines[n].p2[1] - y) / (float)(length - 1);</a>
<a name="ln3334"> </a>
<a name="ln3335">    for(int l = 0; l &lt; length &amp;&amp; offset &lt; total_points; l++, offset++)</a>
<a name="ln3336">    {</a>
<a name="ln3337">      my_points[2 * offset] = x;</a>
<a name="ln3338">      my_points[2 * offset + 1] = y;</a>
<a name="ln3339"> </a>
<a name="ln3340">      x += dx;</a>
<a name="ln3341">      y += dy;</a>
<a name="ln3342">    }</a>
<a name="ln3343">  }</a>
<a name="ln3344"> </a>
<a name="ln3345">  // third step: transform all points</a>
<a name="ln3346">  if(!dt_dev_distort_transform_plus(dev, dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_INCL, my_points, total_points))</a>
<a name="ln3347">    goto error;</a>
<a name="ln3348"> </a>
<a name="ln3349">  // fourth step: get bounding box in final coordinates (used later for checking &quot;near&quot;-ness to mouse pointer)</a>
<a name="ln3350">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3351">  {</a>
<a name="ln3352">    float xmin = FLT_MAX, xmax = FLT_MIN, ymin = FLT_MAX, ymax = FLT_MIN;</a>
<a name="ln3353"> </a>
<a name="ln3354">    size_t offset = my_points_idx[n].offset;</a>
<a name="ln3355">    int length = my_points_idx[n].length;</a>
<a name="ln3356"> </a>
<a name="ln3357">    for(int l = 0; l &lt; length; l++)</a>
<a name="ln3358">    {</a>
<a name="ln3359">      xmin = fmin(xmin, my_points[2 * offset]);</a>
<a name="ln3360">      xmax = fmax(xmax, my_points[2 * offset]);</a>
<a name="ln3361">      ymin = fmin(ymin, my_points[2 * offset + 1]);</a>
<a name="ln3362">      ymax = fmax(ymax, my_points[2 * offset + 1]);</a>
<a name="ln3363">    }</a>
<a name="ln3364"> </a>
<a name="ln3365">    my_points_idx[n].bbx = xmin;</a>
<a name="ln3366">    my_points_idx[n].bbX = xmax;</a>
<a name="ln3367">    my_points_idx[n].bby = ymin;</a>
<a name="ln3368">    my_points_idx[n].bbY = ymax;</a>
<a name="ln3369">  }</a>
<a name="ln3370"> </a>
<a name="ln3371">  // check if lines_version has changed in-between -&gt; too bad: we can forget about all we did :(</a>
<a name="ln3372">  if(g-&gt;lines_version &gt; lines_version)</a>
<a name="ln3373">    goto error;</a>
<a name="ln3374"> </a>
<a name="ln3375">  *points = my_points;</a>
<a name="ln3376">  *points_idx = my_points_idx;</a>
<a name="ln3377">  *points_lines_count = lines_count;</a>
<a name="ln3378"> </a>
<a name="ln3379">  return TRUE;</a>
<a name="ln3380"> </a>
<a name="ln3381">error:</a>
<a name="ln3382">  if(my_points_idx != NULL) free(my_points_idx);</a>
<a name="ln3383">  if(my_points != NULL) free(my_points);</a>
<a name="ln3384">  return FALSE;</a>
<a name="ln3385">}</a>
<a name="ln3386"> </a>
<a name="ln3387">// does this gui have focus?</a>
<a name="ln3388">static int gui_has_focus(struct dt_iop_module_t *self)</a>
<a name="ln3389">{</a>
<a name="ln3390">  return self-&gt;dev-&gt;gui_module == self;</a>
<a name="ln3391">}</a>
<a name="ln3392"> </a>
<a name="ln3393">/* this function replaces this sentence, it calls distort_transform() for this module on the pipe</a>
<a name="ln3394">if(!dt_dev_distort_transform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;priority, self-&gt;priority + 1,</a>
<a name="ln3395">      (float *)V, 4))</a>
<a name="ln3396">*/</a>
<a name="ln3397">static int call_distort_transform(dt_develop_t *dev, dt_dev_pixelpipe_t *pipe, struct dt_iop_module_t *self,</a>
<a name="ln3398">                                  float *points, size_t points_count)</a>
<a name="ln3399">{</a>
<a name="ln3400">  int ret = 0;</a>
<a name="ln3401">  dt_dev_pixelpipe_iop_t *piece = dt_dev_distort_get_iop_pipe(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self);</a>
<a name="ln3402">  if(!piece) return ret;</a>
<a name="ln3403">  if(piece-&gt;module == self &amp;&amp; piece-&gt;enabled &amp;&amp;</a>
<a name="ln3404">     !(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;operation_tags_filter() &amp; piece-&gt;module-&gt;operation_tags()))</a>
<a name="ln3405">  {</a>
<a name="ln3406">    ret = piece-&gt;module-&gt;distort_transform(piece-&gt;module, piece, points, points_count);</a>
<a name="ln3407">  }</a>
<a name="ln3408">  return ret;</a>
<a name="ln3409">}</a>
<a name="ln3410"> </a>
<a name="ln3411">void gui_post_expose(struct dt_iop_module_t *self, cairo_t *cr, int32_t width, int32_t height,</a>
<a name="ln3412">                     int32_t pointerx, int32_t pointery)</a>
<a name="ln3413">{</a>
<a name="ln3414">  dt_develop_t *dev = self-&gt;dev;</a>
<a name="ln3415">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3416">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln3417"> </a>
<a name="ln3418">  // the usual rescaling stuff</a>
<a name="ln3419">  const float wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3420">  const float ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3421">  if(wd &lt; 1.0 || ht &lt; 1.0) return;</a>
<a name="ln3422">  const float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln3423">  const float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln3424">  const dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln3425">  const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln3426">  const float zoom_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln3427"> </a>
<a name="ln3428">  // we draw the cropping area; we need x_off/y_off/width/height which is only available</a>
<a name="ln3429">  // after g-&gt;buf has been processed</a>
<a name="ln3430">  if(g-&gt;buf &amp;&amp; (p-&gt;cropmode != ASHIFT_CROP_OFF) &amp;&amp; self-&gt;enabled)</a>
<a name="ln3431">  {</a>
<a name="ln3432">    // roi data of the preview pipe input buffer</a>
<a name="ln3433">    const float iwd = g-&gt;buf_width;</a>
<a name="ln3434">    const float iht = g-&gt;buf_height;</a>
<a name="ln3435">    const float ixo = g-&gt;buf_x_off;</a>
<a name="ln3436">    const float iyo = g-&gt;buf_y_off;</a>
<a name="ln3437"> </a>
<a name="ln3438">    // the four corners of the input buffer of this module</a>
<a name="ln3439">    const float V[4][2] = { { ixo,        iyo       },</a>
<a name="ln3440">                          {   ixo,        iyo + iht },</a>
<a name="ln3441">                          {   ixo + iwd,  iyo + iht },</a>
<a name="ln3442">                          {   ixo + iwd,  iyo       } };</a>
<a name="ln3443"> </a>
<a name="ln3444">    // convert coordinates of corners to coordinates of this module's output</a>
<a name="ln3445">    if(!call_distort_transform(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self, (float *)V, 4))</a>
<a name="ln3446">      return;</a>
<a name="ln3447"> </a>
<a name="ln3448">    // get x/y-offset as well as width and height of output buffer</a>
<a name="ln3449">    float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN;</a>
<a name="ln3450">    for(int n = 0; n &lt; 4; n++)</a>
<a name="ln3451">    {</a>
<a name="ln3452">      xmin = MIN(xmin, V[n][0]);</a>
<a name="ln3453">      xmax = MAX(xmax, V[n][0]);</a>
<a name="ln3454">      ymin = MIN(ymin, V[n][1]);</a>
<a name="ln3455">      ymax = MAX(ymax, V[n][1]);</a>
<a name="ln3456">    }</a>
<a name="ln3457">    const float owd = xmax - xmin;</a>
<a name="ln3458">    const float oht = ymax - ymin;</a>
<a name="ln3459"> </a>
<a name="ln3460">    // the four clipping corners</a>
<a name="ln3461">    const float C[4][2] = { { xmin + p-&gt;cl * owd, ymin + p-&gt;ct * oht },</a>
<a name="ln3462">                            { xmin + p-&gt;cl * owd, ymin + p-&gt;cb * oht },</a>
<a name="ln3463">                            { xmin + p-&gt;cr * owd, ymin + p-&gt;cb * oht },</a>
<a name="ln3464">                            { xmin + p-&gt;cr * owd, ymin + p-&gt;ct * oht } };</a>
<a name="ln3465"> </a>
<a name="ln3466">    // convert clipping corners to final output image</a>
<a name="ln3467">    if(!dt_dev_distort_transform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL,</a>
<a name="ln3468">      (float *)C, 4))</a>
<a name="ln3469">      return;</a>
<a name="ln3470"> </a>
<a name="ln3471">    cairo_save(cr);</a>
<a name="ln3472"> </a>
<a name="ln3473">    double dashes = DT_PIXEL_APPLY_DPI(5.0) / zoom_scale;</a>
<a name="ln3474">    cairo_set_dash(cr, &amp;dashes, 0, 0);</a>
<a name="ln3475"> </a>
<a name="ln3476">    cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3477">    cairo_clip(cr);</a>
<a name="ln3478"> </a>
<a name="ln3479">    // mask parts of image outside of clipping area in dark grey</a>
<a name="ln3480">    cairo_set_source_rgba(cr, .2, .2, .2, .8);</a>
<a name="ln3481">    cairo_set_fill_rule(cr, CAIRO_FILL_RULE_EVEN_ODD);</a>
<a name="ln3482">    cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3483">    cairo_translate(cr, width / 2.0, height / 2.0);</a>
<a name="ln3484">    cairo_scale(cr, zoom_scale, zoom_scale);</a>
<a name="ln3485">    cairo_translate(cr, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln3486">    cairo_move_to(cr, C[0][0], C[0][1]);</a>
<a name="ln3487">    cairo_line_to(cr, C[1][0], C[1][1]);</a>
<a name="ln3488">    cairo_line_to(cr, C[2][0], C[2][1]);</a>
<a name="ln3489">    cairo_line_to(cr, C[3][0], C[3][1]);</a>
<a name="ln3490">    cairo_close_path(cr);</a>
<a name="ln3491">    cairo_fill(cr);</a>
<a name="ln3492"> </a>
<a name="ln3493">    // draw white outline around clipping area</a>
<a name="ln3494">    cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln3495">    cairo_move_to(cr, C[0][0], C[0][1]);</a>
<a name="ln3496">    cairo_line_to(cr, C[1][0], C[1][1]);</a>
<a name="ln3497">    cairo_line_to(cr, C[2][0], C[2][1]);</a>
<a name="ln3498">    cairo_line_to(cr, C[3][0], C[3][1]);</a>
<a name="ln3499">    cairo_close_path(cr);</a>
<a name="ln3500">    cairo_stroke(cr);</a>
<a name="ln3501"> </a>
<a name="ln3502">    // if adjusting crop, draw indicator</a>
<a name="ln3503">    if (g-&gt;adjust_crop &amp;&amp; p-&gt;cropmode == ASHIFT_CROP_ASPECT)</a>
<a name="ln3504">    {</a>
<a name="ln3505">      const double x1 = C[0][0];</a>
<a name="ln3506">      const double x2 = fabs(x1 - C[1][0]) &lt; 0.001f ? C[2][0] : C[1][0];</a>
<a name="ln3507">      const double y1 = C[0][1];</a>
<a name="ln3508">      const double y2 = fabs(y1 - C[1][1]) &lt; 0.001f ? C[2][1] : C[1][1];</a>
<a name="ln3509"> </a>
<a name="ln3510">      const double xpos = (x1 + x2) / 2.0f;</a>
<a name="ln3511">      const double ypos = (y1 + y2) / 2.0f;</a>
<a name="ln3512">      const double base_size = fabs(x1 - x2);</a>
<a name="ln3513">      const double size_circle = base_size / 30.0f;</a>
<a name="ln3514">      const double size_line = base_size / 5.0f;</a>
<a name="ln3515">      const double size_arrow = base_size / 25.0f;</a>
<a name="ln3516"> </a>
<a name="ln3517">      cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln3518">      cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln3519">      cairo_arc (cr, xpos, ypos, size_circle, 0, 2.0 * M_PI);</a>
<a name="ln3520">      cairo_stroke(cr);</a>
<a name="ln3521">      cairo_fill(cr);</a>
<a name="ln3522"> </a>
<a name="ln3523">      cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln3524">      cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln3525"> </a>
<a name="ln3526">      // horizontal line</a>
<a name="ln3527">      cairo_move_to(cr, xpos - size_line, ypos);</a>
<a name="ln3528">      cairo_line_to(cr, xpos + size_line, ypos);</a>
<a name="ln3529"> </a>
<a name="ln3530">      cairo_move_to(cr, xpos - size_line, ypos);</a>
<a name="ln3531">      cairo_rel_line_to(cr, size_arrow, size_arrow);</a>
<a name="ln3532">      cairo_move_to(cr, xpos - size_line, ypos);</a>
<a name="ln3533">      cairo_rel_line_to(cr, size_arrow, -size_arrow);</a>
<a name="ln3534"> </a>
<a name="ln3535">      cairo_move_to(cr, xpos + size_line, ypos);</a>
<a name="ln3536">      cairo_rel_line_to(cr, -size_arrow, size_arrow);</a>
<a name="ln3537">      cairo_move_to(cr, xpos + size_line, ypos);</a>
<a name="ln3538">      cairo_rel_line_to(cr, -size_arrow, -size_arrow);</a>
<a name="ln3539"> </a>
<a name="ln3540">      // vertical line</a>
<a name="ln3541">      cairo_move_to(cr, xpos, ypos - size_line);</a>
<a name="ln3542">      cairo_line_to(cr, xpos, ypos + size_line);</a>
<a name="ln3543"> </a>
<a name="ln3544">      cairo_move_to(cr, xpos, ypos - size_line);</a>
<a name="ln3545">      cairo_rel_line_to(cr, -size_arrow, size_arrow);</a>
<a name="ln3546">      cairo_move_to(cr, xpos, ypos - size_line);</a>
<a name="ln3547">      cairo_rel_line_to(cr, size_arrow, size_arrow);</a>
<a name="ln3548"> </a>
<a name="ln3549">      cairo_move_to(cr, xpos, ypos + size_line);</a>
<a name="ln3550">      cairo_rel_line_to(cr, -size_arrow, -size_arrow);</a>
<a name="ln3551">      cairo_move_to(cr, xpos, ypos + size_line);</a>
<a name="ln3552">      cairo_rel_line_to(cr, size_arrow, -size_arrow);</a>
<a name="ln3553"> </a>
<a name="ln3554">      cairo_stroke(cr);</a>
<a name="ln3555">    }</a>
<a name="ln3556"> </a>
<a name="ln3557">    cairo_restore(cr);</a>
<a name="ln3558">  }</a>
<a name="ln3559"> </a>
<a name="ln3560">  // show guide lines on request</a>
<a name="ln3561">  if(g-&gt;show_guides)</a>
<a name="ln3562">  {</a>
<a name="ln3563">    dt_guides_t *guide = (dt_guides_t *)g_list_nth_data(darktable.guides, 0);</a>
<a name="ln3564">    double dashes = DT_PIXEL_APPLY_DPI(5.0);</a>
<a name="ln3565">    cairo_save(cr);</a>
<a name="ln3566">    cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3567">    cairo_clip(cr);</a>
<a name="ln3568">    cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.0));</a>
<a name="ln3569">    cairo_set_source_rgb(cr, .8, .8, .8);</a>
<a name="ln3570">    cairo_set_dash(cr, &amp;dashes, 1, 0);</a>
<a name="ln3571">    guide-&gt;draw(cr, 0, 0, width, height, 1.0, guide-&gt;user_data);</a>
<a name="ln3572">    cairo_stroke_preserve(cr);</a>
<a name="ln3573">    cairo_set_dash(cr, &amp;dashes, 0, 0);</a>
<a name="ln3574">    cairo_set_source_rgba(cr, 0.3, .3, .3, .8);</a>
<a name="ln3575">    cairo_stroke(cr);</a>
<a name="ln3576">    cairo_restore(cr);</a>
<a name="ln3577">  }</a>
<a name="ln3578"> </a>
<a name="ln3579">  // structural data are currently being collected or fit procedure is running? -&gt; skip</a>
<a name="ln3580">  if(g-&gt;fitting) return;</a>
<a name="ln3581"> </a>
<a name="ln3582">  // no structural data or visibility switched off? -&gt; stop here</a>
<a name="ln3583">  if(g-&gt;lines == NULL || g-&gt;lines_suppressed || !gui_has_focus(self)) return;</a>
<a name="ln3584"> </a>
<a name="ln3585">  // get hash value that changes if distortions from here to the end of the pixelpipe changed</a>
<a name="ln3586">  uint64_t hash = dt_dev_hash_distort(dev);</a>
<a name="ln3587">  // get hash value that changes if coordinates of lines have changed</a>
<a name="ln3588">  uint64_t lines_hash = get_lines_hash(g-&gt;lines, g-&gt;lines_count);</a>
<a name="ln3589"> </a>
<a name="ln3590">  // points data are missing or outdated, or distortion has changed?</a>
<a name="ln3591">  if(g-&gt;points == NULL || g-&gt;points_idx == NULL || hash != g-&gt;grid_hash ||</a>
<a name="ln3592">    (g-&gt;lines_version &gt; g-&gt;points_version &amp;&amp; g-&gt;lines_hash != lines_hash))</a>
<a name="ln3593">  {</a>
<a name="ln3594">    // we need to reprocess points</a>
<a name="ln3595">    free(g-&gt;points);</a>
<a name="ln3596">    g-&gt;points = NULL;</a>
<a name="ln3597">    free(g-&gt;points_idx);</a>
<a name="ln3598">    g-&gt;points_idx = NULL;</a>
<a name="ln3599">    g-&gt;points_lines_count = 0;</a>
<a name="ln3600"> </a>
<a name="ln3601">    if(!get_points(self, g-&gt;lines, g-&gt;lines_count, g-&gt;lines_version, &amp;g-&gt;points, &amp;g-&gt;points_idx,</a>
<a name="ln3602">                   &amp;g-&gt;points_lines_count))</a>
<a name="ln3603">      return;</a>
<a name="ln3604"> </a>
<a name="ln3605">    g-&gt;points_version = g-&gt;lines_version;</a>
<a name="ln3606">    g-&gt;grid_hash = hash;</a>
<a name="ln3607">    g-&gt;lines_hash = lines_hash;</a>
<a name="ln3608">  }</a>
<a name="ln3609">  else if(g-&gt;lines_hash == lines_hash)</a>
<a name="ln3610">  {</a>
<a name="ln3611">    // update line type information in points_idx</a>
<a name="ln3612">    for(int n = 0; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3613">      g-&gt;points_idx[n].type = g-&gt;lines[n].type;</a>
<a name="ln3614"> </a>
<a name="ln3615">    // coordinates of lines are unchanged -&gt; we only need to update colors</a>
<a name="ln3616">    if(!update_colors(self, g-&gt;points_idx, g-&gt;points_lines_count))</a>
<a name="ln3617">      return;</a>
<a name="ln3618"> </a>
<a name="ln3619">    g-&gt;points_version = g-&gt;lines_version;</a>
<a name="ln3620">  }</a>
<a name="ln3621"> </a>
<a name="ln3622">  // a final check</a>
<a name="ln3623">  if(g-&gt;points == NULL || g-&gt;points_idx == NULL) return;</a>
<a name="ln3624"> </a>
<a name="ln3625">  cairo_save(cr);</a>
<a name="ln3626">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3627">  cairo_clip(cr);</a>
<a name="ln3628">  cairo_translate(cr, width / 2.0, height / 2.0);</a>
<a name="ln3629">  cairo_scale(cr, zoom_scale, zoom_scale);</a>
<a name="ln3630">  cairo_translate(cr, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln3631"> </a>
<a name="ln3632">  // this must match the sequence of enum dt_iop_ashift_linecolor_t!</a>
<a name="ln3633">  const float line_colors[5][4] =</a>
<a name="ln3634">  { { 0.3f, 0.3f, 0.3f, 0.8f },                    // grey (misc. lines)</a>
<a name="ln3635">    { 0.0f, 1.0f, 0.0f, 0.8f },                    // green (selected vertical lines)</a>
<a name="ln3636">    { 0.8f, 0.0f, 0.0f, 0.8f },                    // red (de-selected vertical lines)</a>
<a name="ln3637">    { 0.0f, 0.0f, 1.0f, 0.8f },                    // blue (selected horizontal lines)</a>
<a name="ln3638">    { 0.8f, 0.8f, 0.0f, 0.8f } };                  // yellow (de-selected horizontal lines)</a>
<a name="ln3639"> </a>
<a name="ln3640">  cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln3641"> </a>
<a name="ln3642">  // now draw all lines</a>
<a name="ln3643">  for(int n = 0; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3644">  {</a>
<a name="ln3645">    // is the near flag set? -&gt; draw line a bit thicker</a>
<a name="ln3646">    if(g-&gt;points_idx[n].near)</a>
<a name="ln3647">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(3.0) / zoom_scale);</a>
<a name="ln3648">    else</a>
<a name="ln3649">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.5) / zoom_scale);</a>
<a name="ln3650"> </a>
<a name="ln3651">    // the color of this line</a>
<a name="ln3652">    const float *color = line_colors[g-&gt;points_idx[n].color];</a>
<a name="ln3653">    cairo_set_source_rgba(cr, color[0], color[1], color[2], color[3]);</a>
<a name="ln3654"> </a>
<a name="ln3655">    size_t offset = g-&gt;points_idx[n].offset;</a>
<a name="ln3656">    const int length = g-&gt;points_idx[n].length;</a>
<a name="ln3657"> </a>
<a name="ln3658">    // sanity check (this should not happen)</a>
<a name="ln3659">    if(length &lt; 2) continue;</a>
<a name="ln3660"> </a>
<a name="ln3661">    // set starting point of multi-segment line</a>
<a name="ln3662">    cairo_move_to(cr, g-&gt;points[offset * 2], g-&gt;points[offset * 2 + 1]);</a>
<a name="ln3663"> </a>
<a name="ln3664">    offset++;</a>
<a name="ln3665">    // draw individual line segments</a>
<a name="ln3666">    for(int l = 1; l &lt; length; l++, offset++)</a>
<a name="ln3667">    {</a>
<a name="ln3668">      cairo_line_to(cr, g-&gt;points[offset * 2], g-&gt;points[offset * 2 + 1]);</a>
<a name="ln3669">    }</a>
<a name="ln3670"> </a>
<a name="ln3671">    // finally stroke the line</a>
<a name="ln3672">    cairo_stroke(cr);</a>
<a name="ln3673">  }</a>
<a name="ln3674"> </a>
<a name="ln3675">  // and we draw the selection box if any</a>
<a name="ln3676">  if(g-&gt;isbounding != ASHIFT_BOUNDING_OFF)</a>
<a name="ln3677">  {</a>
<a name="ln3678">    float pzx, pzy;</a>
<a name="ln3679">    dt_dev_get_pointer_zoom_pos(dev, pointerx, pointery, &amp;pzx, &amp;pzy);</a>
<a name="ln3680">    pzx += 0.5f;</a>
<a name="ln3681">    pzy += 0.5f;</a>
<a name="ln3682"> </a>
<a name="ln3683">    double dashed[] = { 4.0, 4.0 };</a>
<a name="ln3684">    dashed[0] /= zoom_scale;</a>
<a name="ln3685">    dashed[1] /= zoom_scale;</a>
<a name="ln3686">    int len = sizeof(dashed) / sizeof(dashed[0]);</a>
<a name="ln3687"> </a>
<a name="ln3688">    cairo_rectangle(cr, g-&gt;lastx * wd, g-&gt;lasty * ht, (pzx - g-&gt;lastx) * wd, (pzy - g-&gt;lasty) * ht);</a>
<a name="ln3689"> </a>
<a name="ln3690">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln3691">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln3692">    cairo_set_dash(cr, dashed, len, 0);</a>
<a name="ln3693">    cairo_stroke_preserve(cr);</a>
<a name="ln3694">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln3695">    cairo_set_dash(cr, dashed, len, 4);</a>
<a name="ln3696">    cairo_stroke(cr);</a>
<a name="ln3697">  }</a>
<a name="ln3698"> </a>
<a name="ln3699">  // indicate which area is used for &quot;near&quot;-ness detection when selecting/deselecting lines</a>
<a name="ln3700">  if(g-&gt;near_delta &gt; 0)</a>
<a name="ln3701">  {</a>
<a name="ln3702">    float pzx, pzy;</a>
<a name="ln3703">    dt_dev_get_pointer_zoom_pos(dev, pointerx, pointery, &amp;pzx, &amp;pzy);</a>
<a name="ln3704">    pzx += 0.5f;</a>
<a name="ln3705">    pzy += 0.5f;</a>
<a name="ln3706"> </a>
<a name="ln3707">    double dashed[] = { 4.0, 4.0 };</a>
<a name="ln3708">    dashed[0] /= zoom_scale;</a>
<a name="ln3709">    dashed[1] /= zoom_scale;</a>
<a name="ln3710">    int len = sizeof(dashed) / sizeof(dashed[0]);</a>
<a name="ln3711"> </a>
<a name="ln3712">    cairo_arc(cr, pzx * wd, pzy * ht, g-&gt;near_delta, 0, 2.0 * M_PI);</a>
<a name="ln3713"> </a>
<a name="ln3714">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln3715">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln3716">    cairo_set_dash(cr, dashed, len, 0);</a>
<a name="ln3717">    cairo_stroke_preserve(cr);</a>
<a name="ln3718">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln3719">    cairo_set_dash(cr, dashed, len, 4);</a>
<a name="ln3720">    cairo_stroke(cr);</a>
<a name="ln3721">  }</a>
<a name="ln3722"> </a>
<a name="ln3723">  cairo_restore(cr);</a>
<a name="ln3724">}</a>
<a name="ln3725"> </a>
<a name="ln3726">// update the number of selected vertical and horizontal lines</a>
<a name="ln3727">static void update_lines_count(const dt_iop_ashift_line_t *lines, const int lines_count,</a>
<a name="ln3728">                               int *vertical_count, int *horizontal_count)</a>
<a name="ln3729">{</a>
<a name="ln3730">  int vlines = 0;</a>
<a name="ln3731">  int hlines = 0;</a>
<a name="ln3732"> </a>
<a name="ln3733">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3734">  {</a>
<a name="ln3735">    if((lines[n].type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_SELECTED)</a>
<a name="ln3736">      vlines++;</a>
<a name="ln3737">    else if((lines[n].type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_SELECTED)</a>
<a name="ln3738">      hlines++;</a>
<a name="ln3739">  }</a>
<a name="ln3740"> </a>
<a name="ln3741">  *vertical_count = vlines;</a>
<a name="ln3742">  *horizontal_count = hlines;</a>
<a name="ln3743">}</a>
<a name="ln3744"> </a>
<a name="ln3745">int mouse_moved(struct dt_iop_module_t *self, double x, double y, double pressure, int which)</a>
<a name="ln3746">{</a>
<a name="ln3747">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3748">  int handled = 0;</a>
<a name="ln3749"> </a>
<a name="ln3750">  const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3751">  const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3752">  if(wd &lt; 1.0 || ht &lt; 1.0) return 1;</a>
<a name="ln3753"> </a>
<a name="ln3754">  float pzx, pzy;</a>
<a name="ln3755">  dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln3756">  pzx += 0.5f;</a>
<a name="ln3757">  pzy += 0.5f;</a>
<a name="ln3758"> </a>
<a name="ln3759">  if (g-&gt;adjust_crop)</a>
<a name="ln3760">  {</a>
<a name="ln3761">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln3762"> </a>
<a name="ln3763">    float pts[4] = { pzx, pzy, 1.0f, 1.0f };</a>
<a name="ln3764">    dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order,</a>
<a name="ln3765">                                      DT_DEV_TRANSFORM_DIR_FORW_INCL, pts, 2);</a>
<a name="ln3766"> </a>
<a name="ln3767">    const float newx = g-&gt;crop_cx + (pts[0] - pts[2]) - g-&gt;lastx;</a>
<a name="ln3768">    const float newy = g-&gt;crop_cy + (pts[1] - pts[3]) - g-&gt;lasty;</a>
<a name="ln3769"> </a>
<a name="ln3770">    crop_adjust(self, p, newx, newy);</a>
<a name="ln3771">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3772">    return TRUE;</a>
<a name="ln3773">  }</a>
<a name="ln3774"> </a>
<a name="ln3775">  // if in rectangle selecting mode adjust &quot;near&quot;-ness of lines according to</a>
<a name="ln3776">  // the rectangular selection</a>
<a name="ln3777">  if(g-&gt;isbounding != ASHIFT_BOUNDING_OFF)</a>
<a name="ln3778">  {</a>
<a name="ln3779">    if(wd &gt;= 1.0 &amp;&amp; ht &gt;= 1.0)</a>
<a name="ln3780">    {</a>
<a name="ln3781">      // mark lines inside the rectangle</a>
<a name="ln3782">      get_bounded_inside(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;lastx * wd,</a>
<a name="ln3783">                         g-&gt;lasty * ht, g-&gt;isbounding);</a>
<a name="ln3784">    }</a>
<a name="ln3785"> </a>
<a name="ln3786">    dt_control_queue_redraw_center();</a>
<a name="ln3787">    return FALSE;</a>
<a name="ln3788">  }</a>
<a name="ln3789"> </a>
<a name="ln3790">  // gather information about &quot;near&quot;-ness in g-&gt;points_idx</a>
<a name="ln3791">  get_near(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;near_delta);</a>
<a name="ln3792"> </a>
<a name="ln3793">  // if we are in sweeping mode iterate over lines as we move the pointer and change &quot;selected&quot; state.</a>
<a name="ln3794">  if(g-&gt;isdeselecting || g-&gt;isselecting)</a>
<a name="ln3795">  {</a>
<a name="ln3796">    for(int n = 0; g-&gt;selecting_lines_version == g-&gt;lines_version &amp;&amp; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3797">    {</a>
<a name="ln3798">      if(g-&gt;points_idx[n].near == 0)</a>
<a name="ln3799">        continue;</a>
<a name="ln3800"> </a>
<a name="ln3801">      if(g-&gt;isdeselecting)</a>
<a name="ln3802">        g-&gt;lines[n].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln3803">      else if(g-&gt;isselecting)</a>
<a name="ln3804">        g-&gt;lines[n].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln3805"> </a>
<a name="ln3806">      handled = 1;</a>
<a name="ln3807">    }</a>
<a name="ln3808">  }</a>
<a name="ln3809"> </a>
<a name="ln3810">  if(handled)</a>
<a name="ln3811">  {</a>
<a name="ln3812">    update_lines_count(g-&gt;lines, g-&gt;lines_count, &amp;g-&gt;vertical_count, &amp;g-&gt;horizontal_count);</a>
<a name="ln3813">    g-&gt;lines_version++;</a>
<a name="ln3814">    g-&gt;selecting_lines_version++;</a>
<a name="ln3815">  }</a>
<a name="ln3816"> </a>
<a name="ln3817">  dt_control_queue_redraw_center();</a>
<a name="ln3818"> </a>
<a name="ln3819">  // if not in sweeping mode we need to pass the event</a>
<a name="ln3820">  return (g-&gt;isdeselecting || g-&gt;isselecting);</a>
<a name="ln3821">}</a>
<a name="ln3822"> </a>
<a name="ln3823">int button_pressed(struct dt_iop_module_t *self, double x, double y, double pressure, int which, int type,</a>
<a name="ln3824">                   uint32_t state)</a>
<a name="ln3825">{</a>
<a name="ln3826">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3827">  int handled = 0;</a>
<a name="ln3828"> </a>
<a name="ln3829">  float pzx, pzy;</a>
<a name="ln3830">  dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln3831">  pzx += 0.5f;</a>
<a name="ln3832">  pzy += 0.5f;</a>
<a name="ln3833"> </a>
<a name="ln3834">  const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3835">  const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3836">  if(wd &lt; 1.0 || ht &lt; 1.0) return 1;</a>
<a name="ln3837"> </a>
<a name="ln3838"> </a>
<a name="ln3839">  // if visibility of lines is switched off or no lines available -&gt; potentially adjust crop area</a>
<a name="ln3840">  if(g-&gt;lines_suppressed || g-&gt;lines == NULL)</a>
<a name="ln3841">  {</a>
<a name="ln3842">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln3843">    if (p-&gt;cropmode == ASHIFT_CROP_ASPECT)</a>
<a name="ln3844">    {</a>
<a name="ln3845">      dt_control_change_cursor(GDK_HAND1);</a>
<a name="ln3846">      g-&gt;adjust_crop = TRUE;</a>
<a name="ln3847"> </a>
<a name="ln3848">      float pts[4] = { pzx, pzy, 1.0f, 1.0f };</a>
<a name="ln3849">      dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order,</a>
<a name="ln3850">                                        DT_DEV_TRANSFORM_DIR_FORW_INCL, pts, 2);</a>
<a name="ln3851"> </a>
<a name="ln3852">      g-&gt;lastx = pts[0] - pts[2];</a>
<a name="ln3853">      g-&gt;lasty = pts[1] - pts[3];</a>
<a name="ln3854">      g-&gt;crop_cx = 0.5f * (p-&gt;cl + p-&gt;cr);</a>
<a name="ln3855">      g-&gt;crop_cy = 0.5f * (p-&gt;ct + p-&gt;cb);</a>
<a name="ln3856">      return TRUE;</a>
<a name="ln3857">    }</a>
<a name="ln3858">    else</a>
<a name="ln3859">      return FALSE;</a>
<a name="ln3860">  }</a>
<a name="ln3861"> </a>
<a name="ln3862">  // remember lines version at this stage so we can continuously monitor if the</a>
<a name="ln3863">  // lines have changed in-between</a>
<a name="ln3864">  g-&gt;selecting_lines_version = g-&gt;lines_version;</a>
<a name="ln3865"> </a>
<a name="ln3866">  // if shift button is pressed go into bounding mode (selecting or deselecting</a>
<a name="ln3867">  // in a rectangle area)</a>
<a name="ln3868">  if((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln3869">  {</a>
<a name="ln3870">    g-&gt;lastx = pzx;</a>
<a name="ln3871">    g-&gt;lasty = pzy;</a>
<a name="ln3872"> </a>
<a name="ln3873">    g-&gt;isbounding = (which == 3) ? ASHIFT_BOUNDING_DESELECT : ASHIFT_BOUNDING_SELECT;</a>
<a name="ln3874">    dt_control_change_cursor(GDK_CROSS);</a>
<a name="ln3875"> </a>
<a name="ln3876">    return TRUE;</a>
<a name="ln3877">  }</a>
<a name="ln3878"> </a>
<a name="ln3879">  dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln3880">  const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln3881">  const float min_scale = dt_dev_get_zoom_scale(self-&gt;dev, DT_ZOOM_FIT, 1&lt;&lt;closeup, 0);</a>
<a name="ln3882">  const float cur_scale = dt_dev_get_zoom_scale(self-&gt;dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln3883"> </a>
<a name="ln3884">  // if we are zoomed out (no panning possible) and we have lines to display we take control</a>
<a name="ln3885">  const int take_control = (cur_scale == min_scale) &amp;&amp; (g-&gt;points_lines_count &gt; 0);</a>
<a name="ln3886"> </a>
<a name="ln3887">  g-&gt;near_delta = dt_conf_get_float(&quot;plugins/darkroom/ashift/near_delta&quot;);</a>
<a name="ln3888"> </a>
<a name="ln3889">  // gather information about &quot;near&quot;-ness in g-&gt;points_idx</a>
<a name="ln3890">  get_near(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;near_delta);</a>
<a name="ln3891"> </a>
<a name="ln3892">  // iterate over all lines close to the pointer and change &quot;selected&quot; state.</a>
<a name="ln3893">  // left-click selects and right-click deselects the line</a>
<a name="ln3894">  for(int n = 0; g-&gt;selecting_lines_version == g-&gt;lines_version &amp;&amp; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3895">  {</a>
<a name="ln3896">    if(g-&gt;points_idx[n].near == 0)</a>
<a name="ln3897">      continue;</a>
<a name="ln3898"> </a>
<a name="ln3899">    if(which == 3)</a>
<a name="ln3900">      g-&gt;lines[n].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln3901">    else</a>
<a name="ln3902">      g-&gt;lines[n].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln3903"> </a>
<a name="ln3904">    handled = 1;</a>
<a name="ln3905">  }</a>
<a name="ln3906"> </a>
<a name="ln3907">  // we switch into sweeping mode either if we anyhow take control</a>
<a name="ln3908">  // or if cursor was close to a line when button was pressed. in other</a>
<a name="ln3909">  // cases we hand over the event (for image panning)</a>
<a name="ln3910">  if((take_control || handled) &amp;&amp; which == 3)</a>
<a name="ln3911">  {</a>
<a name="ln3912">    dt_control_change_cursor(GDK_PIRATE);</a>
<a name="ln3913">    g-&gt;isdeselecting = 1;</a>
<a name="ln3914">  }</a>
<a name="ln3915">  else if(take_control || handled)</a>
<a name="ln3916">  {</a>
<a name="ln3917">    dt_control_change_cursor(GDK_PLUS);</a>
<a name="ln3918">    g-&gt;isselecting = 1;</a>
<a name="ln3919">  }</a>
<a name="ln3920"> </a>
<a name="ln3921">  if(handled)</a>
<a name="ln3922">  {</a>
<a name="ln3923">    update_lines_count(g-&gt;lines, g-&gt;lines_count, &amp;g-&gt;vertical_count, &amp;g-&gt;horizontal_count);</a>
<a name="ln3924">    g-&gt;lines_version++;</a>
<a name="ln3925">    g-&gt;selecting_lines_version++;</a>
<a name="ln3926">  }</a>
<a name="ln3927"> </a>
<a name="ln3928">  return (take_control || handled);</a>
<a name="ln3929">}</a>
<a name="ln3930"> </a>
<a name="ln3931">int button_released(struct dt_iop_module_t *self, double x, double y, int which, uint32_t state)</a>
<a name="ln3932">{</a>
<a name="ln3933">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3934"> </a>
<a name="ln3935">  // stop adjust crop</a>
<a name="ln3936">  g-&gt;adjust_crop = FALSE;</a>
<a name="ln3937">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln3938"> </a>
<a name="ln3939">  // finalize the isbounding mode</a>
<a name="ln3940">  // if user has released the shift button in-between -&gt; do nothing</a>
<a name="ln3941">  if(g-&gt;isbounding != ASHIFT_BOUNDING_OFF &amp;&amp; (state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln3942">  {</a>
<a name="ln3943">    int handled = 0;</a>
<a name="ln3944"> </a>
<a name="ln3945">    // we compute the rectangle selection</a>
<a name="ln3946">    float pzx, pzy;</a>
<a name="ln3947">    dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln3948"> </a>
<a name="ln3949">    pzx += 0.5f;</a>
<a name="ln3950">    pzy += 0.5f;</a>
<a name="ln3951"> </a>
<a name="ln3952">    const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3953">    const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3954"> </a>
<a name="ln3955">    if(wd &gt;= 1.0 &amp;&amp; ht &gt;= 1.0)</a>
<a name="ln3956">    {</a>
<a name="ln3957">      // mark lines inside the rectangle</a>
<a name="ln3958">      get_bounded_inside(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;lastx * wd,</a>
<a name="ln3959">                         g-&gt;lasty * ht, g-&gt;isbounding);</a>
<a name="ln3960"> </a>
<a name="ln3961">      // select or deselect lines within the rectangle according to isbounding state</a>
<a name="ln3962">      for(int n = 0; g-&gt;selecting_lines_version == g-&gt;lines_version &amp;&amp; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3963">      {</a>
<a name="ln3964">        if(g-&gt;points_idx[n].bounded == 0) continue;</a>
<a name="ln3965"> </a>
<a name="ln3966">        if(g-&gt;isbounding == ASHIFT_BOUNDING_DESELECT)</a>
<a name="ln3967">          g-&gt;lines[n].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln3968">        else</a>
<a name="ln3969">          g-&gt;lines[n].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln3970"> </a>
<a name="ln3971">        handled = 1;</a>
<a name="ln3972">      }</a>
<a name="ln3973"> </a>
<a name="ln3974">      if(handled)</a>
<a name="ln3975">      {</a>
<a name="ln3976">        update_lines_count(g-&gt;lines, g-&gt;lines_count, &amp;g-&gt;vertical_count, &amp;g-&gt;horizontal_count);</a>
<a name="ln3977">        g-&gt;lines_version++;</a>
<a name="ln3978">        g-&gt;selecting_lines_version++;</a>
<a name="ln3979">      }</a>
<a name="ln3980"> </a>
<a name="ln3981">    dt_control_queue_redraw_center();</a>
<a name="ln3982">    }</a>
<a name="ln3983">  }</a>
<a name="ln3984"> </a>
<a name="ln3985">  // end of sweeping/isbounding mode</a>
<a name="ln3986">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln3987">  g-&gt;isselecting = g-&gt;isdeselecting = 0;</a>
<a name="ln3988">  g-&gt;isbounding = ASHIFT_BOUNDING_OFF;</a>
<a name="ln3989">  g-&gt;near_delta = 0;</a>
<a name="ln3990">  g-&gt;lastx = g-&gt;lasty = -1.0f;</a>
<a name="ln3991">  g-&gt;crop_cx = g-&gt;crop_cy = -1.0f;</a>
<a name="ln3992"> </a>
<a name="ln3993">  return 0;</a>
<a name="ln3994">}</a>
<a name="ln3995"> </a>
<a name="ln3996">int scrolled(struct dt_iop_module_t *self, double x, double y, int up, uint32_t state)</a>
<a name="ln3997">{</a>
<a name="ln3998">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3999"> </a>
<a name="ln4000">  // do nothing if visibility of lines is switched off or no lines available</a>
<a name="ln4001">  if(g-&gt;lines_suppressed || g-&gt;lines == NULL)</a>
<a name="ln4002">    return FALSE;</a>
<a name="ln4003"> </a>
<a name="ln4004">  if(g-&gt;near_delta &gt; 0 &amp;&amp; (g-&gt;isdeselecting || g-&gt;isselecting))</a>
<a name="ln4005">  {</a>
<a name="ln4006">    int handled = 0;</a>
<a name="ln4007"> </a>
<a name="ln4008">    float pzx, pzy;</a>
<a name="ln4009">    dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln4010">    pzx += 0.5f;</a>
<a name="ln4011">    pzy += 0.5f;</a>
<a name="ln4012"> </a>
<a name="ln4013">    const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln4014">    const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln4015"> </a>
<a name="ln4016">    float near_delta = dt_conf_get_float(&quot;plugins/darkroom/ashift/near_delta&quot;);</a>
<a name="ln4017">    const float amount = up ? 0.8f : 1.25f;</a>
<a name="ln4018">    near_delta = MAX(4.0f, MIN(near_delta * amount, 100.0f));</a>
<a name="ln4019">    dt_conf_set_float(&quot;plugins/darkroom/ashift/near_delta&quot;, near_delta);</a>
<a name="ln4020">    g-&gt;near_delta = near_delta;</a>
<a name="ln4021"> </a>
<a name="ln4022">    // gather information about &quot;near&quot;-ness in g-&gt;points_idx</a>
<a name="ln4023">    get_near(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;near_delta);</a>
<a name="ln4024"> </a>
<a name="ln4025">    // iterate over all lines close to the pointer and change &quot;selected&quot; state.</a>
<a name="ln4026">    for(int n = 0; g-&gt;selecting_lines_version == g-&gt;lines_version &amp;&amp; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln4027">    {</a>
<a name="ln4028">      if(g-&gt;points_idx[n].near == 0)</a>
<a name="ln4029">        continue;</a>
<a name="ln4030"> </a>
<a name="ln4031">      if(g-&gt;isdeselecting)</a>
<a name="ln4032">        g-&gt;lines[n].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln4033">      else if(g-&gt;isselecting)</a>
<a name="ln4034">        g-&gt;lines[n].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln4035"> </a>
<a name="ln4036">      handled = 1;</a>
<a name="ln4037">    }</a>
<a name="ln4038"> </a>
<a name="ln4039">    if(handled)</a>
<a name="ln4040">    {</a>
<a name="ln4041">      update_lines_count(g-&gt;lines, g-&gt;lines_count, &amp;g-&gt;vertical_count, &amp;g-&gt;horizontal_count);</a>
<a name="ln4042">      g-&gt;lines_version++;</a>
<a name="ln4043">      g-&gt;selecting_lines_version++;</a>
<a name="ln4044">    }</a>
<a name="ln4045"> </a>
<a name="ln4046">    dt_control_queue_redraw_center();</a>
<a name="ln4047">    return TRUE;</a>
<a name="ln4048">  }</a>
<a name="ln4049"> </a>
<a name="ln4050">  return FALSE;</a>
<a name="ln4051">}</a>
<a name="ln4052"> </a>
<a name="ln4053">static void rotation_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4054">{</a>
<a name="ln4055">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4056">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4057">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4058">  p-&gt;rotation = dt_bauhaus_slider_get(slider);</a>
<a name="ln4059">#ifdef ASHIFT_DEBUG</a>
<a name="ln4060">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4061">  model_probe(self, p, g-&gt;lastfit);</a>
<a name="ln4062">#endif</a>
<a name="ln4063">  do_crop(self, p);</a>
<a name="ln4064">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4065">}</a>
<a name="ln4066"> </a>
<a name="ln4067">static void lensshift_v_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4068">{</a>
<a name="ln4069">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4070">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4071">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4072">  p-&gt;lensshift_v = dt_bauhaus_slider_get(slider);</a>
<a name="ln4073">#ifdef ASHIFT_DEBUG</a>
<a name="ln4074">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4075">  model_probe(self, p, g-&gt;lastfit);</a>
<a name="ln4076">#endif</a>
<a name="ln4077">  do_crop(self, p);</a>
<a name="ln4078">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4079">}</a>
<a name="ln4080"> </a>
<a name="ln4081">static void lensshift_h_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4082">{</a>
<a name="ln4083">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4084">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4085">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4086">  p-&gt;lensshift_h = dt_bauhaus_slider_get(slider);</a>
<a name="ln4087">#ifdef ASHIFT_DEBUG</a>
<a name="ln4088">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4089">  model_probe(self, p, g-&gt;lastfit);</a>
<a name="ln4090">#endif</a>
<a name="ln4091">  do_crop(self, p);</a>
<a name="ln4092">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4093">}</a>
<a name="ln4094"> </a>
<a name="ln4095">static void shear_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4096">{</a>
<a name="ln4097">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4098">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4099">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4100">  p-&gt;shear = dt_bauhaus_slider_get(slider);</a>
<a name="ln4101">#ifdef ASHIFT_DEBUG</a>
<a name="ln4102">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4103">  model_probe(self, p, g-&gt;lastfit);</a>
<a name="ln4104">#endif</a>
<a name="ln4105">  do_crop(self, p);</a>
<a name="ln4106">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4107">}</a>
<a name="ln4108"> </a>
<a name="ln4109">static void guide_lines_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln4110">{</a>
<a name="ln4111">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4112">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4113">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4114">  g-&gt;show_guides = dt_bauhaus_combobox_get(widget);</a>
<a name="ln4115">  dt_iop_request_focus(self);</a>
<a name="ln4116">  dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4117">}</a>
<a name="ln4118"> </a>
<a name="ln4119">static void cropmode_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln4120">{</a>
<a name="ln4121">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4122">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4123">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4124">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4125">  p-&gt;cropmode = dt_bauhaus_combobox_get(widget);</a>
<a name="ln4126">  if(g-&gt;lines != NULL &amp;&amp; !g-&gt;lines_suppressed)</a>
<a name="ln4127">  {</a>
<a name="ln4128">    g-&gt;lines_suppressed = 1;</a>
<a name="ln4129">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;eye), g-&gt;lines_suppressed);</a>
<a name="ln4130">  }</a>
<a name="ln4131">  do_crop(self, p);</a>
<a name="ln4132">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4133">}</a>
<a name="ln4134"> </a>
<a name="ln4135">static void mode_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln4136">{</a>
<a name="ln4137">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4138">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4139">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4140">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4141">  p-&gt;mode = dt_bauhaus_combobox_get(widget);</a>
<a name="ln4142"> </a>
<a name="ln4143">  switch(p-&gt;mode)</a>
<a name="ln4144">  {</a>
<a name="ln4145">    case ASHIFT_MODE_GENERIC:</a>
<a name="ln4146">      gtk_widget_hide(g-&gt;f_length);</a>
<a name="ln4147">      gtk_widget_hide(g-&gt;crop_factor);</a>
<a name="ln4148">      gtk_widget_hide(g-&gt;orthocorr);</a>
<a name="ln4149">      gtk_widget_hide(g-&gt;aspect);</a>
<a name="ln4150">      break;</a>
<a name="ln4151">    case ASHIFT_MODE_SPECIFIC:</a>
<a name="ln4152">    default:</a>
<a name="ln4153">      gtk_widget_show(g-&gt;f_length);</a>
<a name="ln4154">      gtk_widget_show(g-&gt;crop_factor);</a>
<a name="ln4155">      gtk_widget_show(g-&gt;orthocorr);</a>
<a name="ln4156">      gtk_widget_show(g-&gt;aspect);</a>
<a name="ln4157">      break;</a>
<a name="ln4158">  }</a>
<a name="ln4159"> </a>
<a name="ln4160">  do_crop(self, p);</a>
<a name="ln4161">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4162">}</a>
<a name="ln4163"> </a>
<a name="ln4164">static void f_length_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4165">{</a>
<a name="ln4166">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4167">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4168">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4169">  p-&gt;f_length = dt_bauhaus_slider_get(slider);</a>
<a name="ln4170">  do_crop(self, p);</a>
<a name="ln4171">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4172">}</a>
<a name="ln4173"> </a>
<a name="ln4174">static void crop_factor_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4175">{</a>
<a name="ln4176">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4177">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4178">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4179">  p-&gt;crop_factor = dt_bauhaus_slider_get(slider);</a>
<a name="ln4180">  do_crop(self, p);</a>
<a name="ln4181">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4182">}</a>
<a name="ln4183"> </a>
<a name="ln4184">static void orthocorr_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4185">{</a>
<a name="ln4186">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4187">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4188">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4189">  p-&gt;orthocorr = dt_bauhaus_slider_get(slider);</a>
<a name="ln4190">  do_crop(self, p);</a>
<a name="ln4191">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4192">}</a>
<a name="ln4193"> </a>
<a name="ln4194">static void aspect_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4195">{</a>
<a name="ln4196">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4197">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4198">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4199">  p-&gt;aspect = dt_bauhaus_slider_get(slider);</a>
<a name="ln4200">  do_crop(self, p);</a>
<a name="ln4201">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4202">}</a>
<a name="ln4203"> </a>
<a name="ln4204">static int fit_v_button_clicked(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln4205">{</a>
<a name="ln4206">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4207">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4208"> </a>
<a name="ln4209">  if(event-&gt;button == 1)</a>
<a name="ln4210">  {</a>
<a name="ln4211">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4212">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4213"> </a>
<a name="ln4214">    const int control = (event-&gt;state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK;</a>
<a name="ln4215">    const int shift = (event-&gt;state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK;</a>
<a name="ln4216"> </a>
<a name="ln4217">    dt_iop_ashift_fitaxis_t fitaxis = ASHIFT_FIT_NONE;</a>
<a name="ln4218"> </a>
<a name="ln4219">    if(control)</a>
<a name="ln4220">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_ROTATION_VERTICAL_LINES;</a>
<a name="ln4221">    else if(shift)</a>
<a name="ln4222">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_VERTICALLY_NO_ROTATION;</a>
<a name="ln4223">    else</a>
<a name="ln4224">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_VERTICALLY;</a>
<a name="ln4225"> </a>
<a name="ln4226">    dt_iop_request_focus(self);</a>
<a name="ln4227">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4228"> </a>
<a name="ln4229">    if(self-&gt;enabled)</a>
<a name="ln4230">    {</a>
<a name="ln4231">      // module is enable -&gt; we process directly</a>
<a name="ln4232">      if(do_fit(self, p, fitaxis))</a>
<a name="ln4233">      {</a>
<a name="ln4234">        darktable.gui-&gt;reset = 1;</a>
<a name="ln4235">        dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4236">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4237">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4238">        dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4239">        darktable.gui-&gt;reset = 0;</a>
<a name="ln4240">      }</a>
<a name="ln4241">    }</a>
<a name="ln4242">    else</a>
<a name="ln4243">    {</a>
<a name="ln4244">      // module is not enabled -&gt; invoke it and queue the job to be processed once</a>
<a name="ln4245">      // the preview image is ready</a>
<a name="ln4246">      g-&gt;jobcode = ASHIFT_JOBCODE_FIT;</a>
<a name="ln4247">      g-&gt;jobparams = g-&gt;lastfit = fitaxis;</a>
<a name="ln4248">      p-&gt;toggle ^= 1;</a>
<a name="ln4249">    }</a>
<a name="ln4250"> </a>
<a name="ln4251">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4252">    return TRUE;</a>
<a name="ln4253">  }</a>
<a name="ln4254">  return FALSE;</a>
<a name="ln4255">}</a>
<a name="ln4256"> </a>
<a name="ln4257">static int fit_h_button_clicked(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln4258">{</a>
<a name="ln4259">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4260">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4261"> </a>
<a name="ln4262">  if(event-&gt;button == 1)</a>
<a name="ln4263">  {</a>
<a name="ln4264">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4265">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4266"> </a>
<a name="ln4267">    const int control = (event-&gt;state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK;</a>
<a name="ln4268">    const int shift = (event-&gt;state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK;</a>
<a name="ln4269"> </a>
<a name="ln4270">    dt_iop_ashift_fitaxis_t fitaxis = ASHIFT_FIT_NONE;</a>
<a name="ln4271"> </a>
<a name="ln4272">    if(control)</a>
<a name="ln4273">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_ROTATION_HORIZONTAL_LINES;</a>
<a name="ln4274">    else if(shift)</a>
<a name="ln4275">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_HORIZONTALLY_NO_ROTATION;</a>
<a name="ln4276">    else</a>
<a name="ln4277">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_HORIZONTALLY;</a>
<a name="ln4278"> </a>
<a name="ln4279">    dt_iop_request_focus(self);</a>
<a name="ln4280">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4281"> </a>
<a name="ln4282">    if(self-&gt;enabled)</a>
<a name="ln4283">    {</a>
<a name="ln4284">      // module is enable -&gt; we process directly</a>
<a name="ln4285">      if(do_fit(self, p, fitaxis))</a>
<a name="ln4286">      {</a>
<a name="ln4287">        darktable.gui-&gt;reset = 1;</a>
<a name="ln4288">        dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4289">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4290">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4291">        dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4292">        darktable.gui-&gt;reset = 0;</a>
<a name="ln4293">      }</a>
<a name="ln4294">    }</a>
<a name="ln4295">    else</a>
<a name="ln4296">    {</a>
<a name="ln4297">      // module is not enabled -&gt; invoke it and queue the job to be processed once</a>
<a name="ln4298">      // the preview image is ready</a>
<a name="ln4299">      g-&gt;jobcode = ASHIFT_JOBCODE_FIT;</a>
<a name="ln4300">      g-&gt;jobparams = g-&gt;lastfit = fitaxis;</a>
<a name="ln4301">      p-&gt;toggle ^= 1;</a>
<a name="ln4302">    }</a>
<a name="ln4303"> </a>
<a name="ln4304">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4305">    return TRUE;</a>
<a name="ln4306">  }</a>
<a name="ln4307">  return FALSE;</a>
<a name="ln4308">}</a>
<a name="ln4309"> </a>
<a name="ln4310">static int fit_both_button_clicked(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln4311">{</a>
<a name="ln4312">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4313">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4314"> </a>
<a name="ln4315">  if(event-&gt;button == 1)</a>
<a name="ln4316">  {</a>
<a name="ln4317">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4318">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4319"> </a>
<a name="ln4320">    const int control = (event-&gt;state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK;</a>
<a name="ln4321">    const int shift = (event-&gt;state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK;</a>
<a name="ln4322"> </a>
<a name="ln4323">    dt_iop_ashift_fitaxis_t fitaxis = ASHIFT_FIT_NONE;</a>
<a name="ln4324"> </a>
<a name="ln4325">    if(control &amp;&amp; shift)</a>
<a name="ln4326">      fitaxis = ASHIFT_FIT_BOTH;</a>
<a name="ln4327">    else if(control)</a>
<a name="ln4328">      fitaxis = ASHIFT_FIT_ROTATION_BOTH_LINES;</a>
<a name="ln4329">    else if(shift)</a>
<a name="ln4330">      fitaxis = ASHIFT_FIT_BOTH_NO_ROTATION;</a>
<a name="ln4331">    else</a>
<a name="ln4332">      fitaxis = ASHIFT_FIT_BOTH_SHEAR;</a>
<a name="ln4333"> </a>
<a name="ln4334">    dt_iop_request_focus(self);</a>
<a name="ln4335">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4336"> </a>
<a name="ln4337">    if(self-&gt;enabled)</a>
<a name="ln4338">    {</a>
<a name="ln4339">      // module is enable -&gt; we process directly</a>
<a name="ln4340">      if(do_fit(self, p, fitaxis))</a>
<a name="ln4341">      {</a>
<a name="ln4342">        darktable.gui-&gt;reset = 1;</a>
<a name="ln4343">        dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4344">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4345">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4346">        dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4347">        darktable.gui-&gt;reset = 0;</a>
<a name="ln4348">      }</a>
<a name="ln4349">    }</a>
<a name="ln4350">    else</a>
<a name="ln4351">    {</a>
<a name="ln4352">      // module is not enabled -&gt; invoke it and queue the job to be processed once</a>
<a name="ln4353">      // the preview image is ready</a>
<a name="ln4354">      g-&gt;jobcode = ASHIFT_JOBCODE_FIT;</a>
<a name="ln4355">      g-&gt;jobparams = g-&gt;lastfit = fitaxis;</a>
<a name="ln4356">      p-&gt;toggle ^= 1;</a>
<a name="ln4357">    }</a>
<a name="ln4358"> </a>
<a name="ln4359">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4360">    return TRUE;</a>
<a name="ln4361">  }</a>
<a name="ln4362">  return FALSE;</a>
<a name="ln4363">}</a>
<a name="ln4364"> </a>
<a name="ln4365">static int structure_button_clicked(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln4366">{</a>
<a name="ln4367">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4368">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4369"> </a>
<a name="ln4370">  if(event-&gt;button == 1)</a>
<a name="ln4371">  {</a>
<a name="ln4372">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4373">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4374"> </a>
<a name="ln4375">    const int control = (event-&gt;state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK;</a>
<a name="ln4376">    const int shift = (event-&gt;state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK;</a>
<a name="ln4377"> </a>
<a name="ln4378">    dt_iop_ashift_enhance_t enhance;</a>
<a name="ln4379"> </a>
<a name="ln4380">    if(control &amp;&amp; shift)</a>
<a name="ln4381">      enhance = ASHIFT_ENHANCE_EDGES | ASHIFT_ENHANCE_DETAIL;</a>
<a name="ln4382">    else if(shift)</a>
<a name="ln4383">      enhance = ASHIFT_ENHANCE_DETAIL;</a>
<a name="ln4384">    else if(control)</a>
<a name="ln4385">      enhance = ASHIFT_ENHANCE_EDGES;</a>
<a name="ln4386">    else</a>
<a name="ln4387">      enhance = ASHIFT_ENHANCE_NONE;</a>
<a name="ln4388"> </a>
<a name="ln4389">    dt_iop_request_focus(self);</a>
<a name="ln4390">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4391"> </a>
<a name="ln4392">    if(self-&gt;enabled)</a>
<a name="ln4393">    {</a>
<a name="ln4394">      // module is enabled -&gt; process directly</a>
<a name="ln4395">      (void)do_get_structure(self, p, enhance);</a>
<a name="ln4396">    }</a>
<a name="ln4397">    else</a>
<a name="ln4398">    {</a>
<a name="ln4399">      // module is not enabled -&gt; invoke it and queue the job to be processed once</a>
<a name="ln4400">      // the preview image is ready</a>
<a name="ln4401">      g-&gt;jobcode = ASHIFT_JOBCODE_GET_STRUCTURE;</a>
<a name="ln4402">      g-&gt;jobparams = enhance;</a>
<a name="ln4403">      p-&gt;toggle ^= 1;</a>
<a name="ln4404">    }</a>
<a name="ln4405"> </a>
<a name="ln4406">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4407">    return TRUE;</a>
<a name="ln4408">  }</a>
<a name="ln4409">  return FALSE;</a>
<a name="ln4410">}</a>
<a name="ln4411"> </a>
<a name="ln4412">static void clean_button_clicked(GtkButton *button, gpointer user_data)</a>
<a name="ln4413">{</a>
<a name="ln4414">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4415">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4416">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4417">  (void)do_clean_structure(self, p);</a>
<a name="ln4418">  dt_iop_request_focus(self);</a>
<a name="ln4419">  dt_control_queue_redraw_center();</a>
<a name="ln4420">}</a>
<a name="ln4421"> </a>
<a name="ln4422">static void eye_button_toggled(GtkToggleButton *togglebutton, gpointer user_data)</a>
<a name="ln4423">{</a>
<a name="ln4424">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4425">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4426">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4427">  if(g-&gt;lines == NULL)</a>
<a name="ln4428">  {</a>
<a name="ln4429">    g-&gt;lines_suppressed = 0;</a>
<a name="ln4430">    gtk_toggle_button_set_active(togglebutton, 0);</a>
<a name="ln4431">  }</a>
<a name="ln4432">  else</a>
<a name="ln4433">  {</a>
<a name="ln4434">    g-&gt;lines_suppressed = gtk_toggle_button_get_active(togglebutton);</a>
<a name="ln4435">  }</a>
<a name="ln4436">  dt_iop_request_focus(self);</a>
<a name="ln4437">  dt_control_queue_redraw_center();</a>
<a name="ln4438">}</a>
<a name="ln4439"> </a>
<a name="ln4440">// routine that is called after preview image has been processed. we use it</a>
<a name="ln4441">// to perform structure collection or fitting in case those have been triggered while</a>
<a name="ln4442">// the module had not yet been enabled</a>
<a name="ln4443">static void process_after_preview_callback(gpointer instance, gpointer user_data)</a>
<a name="ln4444">{</a>
<a name="ln4445">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4446">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4447">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4448"> </a>
<a name="ln4449">  dt_iop_ashift_jobcode_t jobcode = g-&gt;jobcode;</a>
<a name="ln4450">  int jobparams = g-&gt;jobparams;</a>
<a name="ln4451"> </a>
<a name="ln4452">  // purge</a>
<a name="ln4453">  g-&gt;jobcode = ASHIFT_JOBCODE_NONE;</a>
<a name="ln4454">  g-&gt;jobparams = 0;</a>
<a name="ln4455"> </a>
<a name="ln4456">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4457"> </a>
<a name="ln4458">  switch(jobcode)</a>
<a name="ln4459">  {</a>
<a name="ln4460">    case ASHIFT_JOBCODE_GET_STRUCTURE:</a>
<a name="ln4461">      (void)do_get_structure(self, p, (dt_iop_ashift_enhance_t)jobparams);</a>
<a name="ln4462">      break;</a>
<a name="ln4463"> </a>
<a name="ln4464">    case ASHIFT_JOBCODE_FIT:</a>
<a name="ln4465">      if(do_fit(self, p, (dt_iop_ashift_fitaxis_t)jobparams))</a>
<a name="ln4466">      {</a>
<a name="ln4467">        darktable.gui-&gt;reset = 1;</a>
<a name="ln4468">        dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4469">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4470">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4471">        dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4472">        darktable.gui-&gt;reset = 0;</a>
<a name="ln4473">      }</a>
<a name="ln4474">      dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4475">      break;</a>
<a name="ln4476"> </a>
<a name="ln4477">    case ASHIFT_JOBCODE_NONE:</a>
<a name="ln4478">    default:</a>
<a name="ln4479">      break;</a>
<a name="ln4480">  }</a>
<a name="ln4481"> </a>
<a name="ln4482">  dt_control_queue_redraw_center();</a>
<a name="ln4483">}</a>
<a name="ln4484"> </a>
<a name="ln4485">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln4486">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4487">{</a>
<a name="ln4488">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)p1;</a>
<a name="ln4489">  dt_iop_ashift_data_t *d = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln4490"> </a>
<a name="ln4491">  d-&gt;rotation = p-&gt;rotation;</a>
<a name="ln4492">  d-&gt;lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln4493">  d-&gt;lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln4494">  d-&gt;shear = p-&gt;shear;</a>
<a name="ln4495">  d-&gt;f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln4496">  d-&gt;orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln4497">  d-&gt;aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln4498"> </a>
<a name="ln4499">  if(gui_has_focus(self))</a>
<a name="ln4500">  {</a>
<a name="ln4501">    // if gui has focus we want to see the full uncropped image</a>
<a name="ln4502">    d-&gt;cl = 0.0f;</a>
<a name="ln4503">    d-&gt;cr = 1.0f;</a>
<a name="ln4504">    d-&gt;ct = 0.0f;</a>
<a name="ln4505">    d-&gt;cb = 1.0f;</a>
<a name="ln4506">  }</a>
<a name="ln4507">  else</a>
<a name="ln4508">  {</a>
<a name="ln4509">    d-&gt;cl = p-&gt;cl;</a>
<a name="ln4510">    d-&gt;cr = p-&gt;cr;</a>
<a name="ln4511">    d-&gt;ct = p-&gt;ct;</a>
<a name="ln4512">    d-&gt;cb = p-&gt;cb;</a>
<a name="ln4513">  }</a>
<a name="ln4514">}</a>
<a name="ln4515"> </a>
<a name="ln4516">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4517">{</a>
<a name="ln4518">  dt_iop_ashift_data_t *d = (dt_iop_ashift_data_t *)calloc(1, sizeof(dt_iop_ashift_data_t));</a>
<a name="ln4519">  piece-&gt;data = (void *)d;</a>
<a name="ln4520">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln4521">}</a>
<a name="ln4522"> </a>
<a name="ln4523">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4524">{</a>
<a name="ln4525">  free(piece-&gt;data);</a>
<a name="ln4526">  piece-&gt;data = NULL;</a>
<a name="ln4527">}</a>
<a name="ln4528"> </a>
<a name="ln4529">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln4530">{</a>
<a name="ln4531">  dt_iop_module_t *module = (dt_iop_module_t *)self;</a>
<a name="ln4532">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4533">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)module-&gt;params;</a>
<a name="ln4534">  dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4535">  dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4536">  dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4537">  dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4538">  dt_bauhaus_slider_set_soft(g-&gt;f_length, p-&gt;f_length);</a>
<a name="ln4539">  dt_bauhaus_slider_set_soft(g-&gt;crop_factor, p-&gt;crop_factor);</a>
<a name="ln4540">  dt_bauhaus_slider_set(g-&gt;orthocorr, p-&gt;orthocorr);</a>
<a name="ln4541">  dt_bauhaus_slider_set(g-&gt;aspect, p-&gt;aspect);</a>
<a name="ln4542">  dt_bauhaus_combobox_set(g-&gt;mode, p-&gt;mode);</a>
<a name="ln4543">  dt_bauhaus_combobox_set(g-&gt;guide_lines, g-&gt;show_guides);</a>
<a name="ln4544">  dt_bauhaus_combobox_set(g-&gt;cropmode, p-&gt;cropmode);</a>
<a name="ln4545">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;eye), 0);</a>
<a name="ln4546"> </a>
<a name="ln4547">  switch(p-&gt;mode)</a>
<a name="ln4548">  {</a>
<a name="ln4549">    case ASHIFT_MODE_GENERIC:</a>
<a name="ln4550">      gtk_widget_hide(g-&gt;f_length);</a>
<a name="ln4551">      gtk_widget_hide(g-&gt;crop_factor);</a>
<a name="ln4552">      gtk_widget_hide(g-&gt;orthocorr);</a>
<a name="ln4553">      gtk_widget_hide(g-&gt;aspect);</a>
<a name="ln4554">      break;</a>
<a name="ln4555">    case ASHIFT_MODE_SPECIFIC:</a>
<a name="ln4556">    default:</a>
<a name="ln4557">      gtk_widget_show(g-&gt;f_length);</a>
<a name="ln4558">      gtk_widget_show(g-&gt;crop_factor);</a>
<a name="ln4559">      gtk_widget_show(g-&gt;orthocorr);</a>
<a name="ln4560">      gtk_widget_show(g-&gt;aspect);</a>
<a name="ln4561">      break;</a>
<a name="ln4562">  }</a>
<a name="ln4563">}</a>
<a name="ln4564"> </a>
<a name="ln4565">void init(dt_iop_module_t *module)</a>
<a name="ln4566">{</a>
<a name="ln4567">  module-&gt;params = calloc(1, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4568">  module-&gt;default_params = calloc(1, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4569">  module-&gt;default_enabled = 0;</a>
<a name="ln4570">  module-&gt;params_size = sizeof(dt_iop_ashift_params_t);</a>
<a name="ln4571">  module-&gt;gui_data = NULL;</a>
<a name="ln4572">  dt_iop_ashift_params_t tmp = (dt_iop_ashift_params_t){ 0.0f, 0.0f, 0.0f, 0.0f, DEFAULT_F_LENGTH, 1.0f, 100.0f, 1.0f, ASHIFT_MODE_GENERIC, 0,</a>
<a name="ln4573">                                                         ASHIFT_CROP_OFF, 0.0f, 1.0f, 0.0f, 1.0f };</a>
<a name="ln4574">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4575">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4576">}</a>
<a name="ln4577"> </a>
<a name="ln4578">void reload_defaults(dt_iop_module_t *module)</a>
<a name="ln4579">{</a>
<a name="ln4580">  // our module is disabled by default</a>
<a name="ln4581">  module-&gt;default_enabled = 0;</a>
<a name="ln4582"> </a>
<a name="ln4583">  int isflipped = 0;</a>
<a name="ln4584">  float f_length = DEFAULT_F_LENGTH;</a>
<a name="ln4585">  float crop_factor = 1.0f;</a>
<a name="ln4586"> </a>
<a name="ln4587">  // try to get information on orientation, focal length and crop factor from image data</a>
<a name="ln4588">  if(module-&gt;dev)</a>
<a name="ln4589">  {</a>
<a name="ln4590">    const dt_image_t *img = &amp;module-&gt;dev-&gt;image_storage;</a>
<a name="ln4591">    // orientation only needed as a-priori information to correctly label some sliders</a>
<a name="ln4592">    // before pixelpipe has been set up. later we will get a definite result by</a>
<a name="ln4593">    // assessing the pixelpipe</a>
<a name="ln4594">    isflipped = (img-&gt;orientation == ORIENTATION_ROTATE_CCW_90_DEG</a>
<a name="ln4595">                 || img-&gt;orientation == ORIENTATION_ROTATE_CW_90_DEG)</a>
<a name="ln4596">                    ? 1</a>
<a name="ln4597">                    : 0;</a>
<a name="ln4598"> </a>
<a name="ln4599">    // focal length should be available in exif data if lens is electronically coupled to the camera</a>
<a name="ln4600">    f_length = isfinite(img-&gt;exif_focal_length) &amp;&amp; img-&gt;exif_focal_length &gt; 0.0f ? img-&gt;exif_focal_length : f_length;</a>
<a name="ln4601">    // crop factor of the camera is often not available and user will need to set it manually in the gui</a>
<a name="ln4602">    crop_factor = isfinite(img-&gt;exif_crop) &amp;&amp; img-&gt;exif_crop &gt; 0.0f ? img-&gt;exif_crop : crop_factor;</a>
<a name="ln4603">  }</a>
<a name="ln4604"> </a>
<a name="ln4605">  // init defaults:</a>
<a name="ln4606">  dt_iop_ashift_params_t tmp = (dt_iop_ashift_params_t){ 0.0f, 0.0f, 0.0f, 0.0f, f_length, crop_factor, 100.0f, 1.0f, ASHIFT_MODE_GENERIC, 0,</a>
<a name="ln4607">                                                         ASHIFT_CROP_OFF, 0.0f, 1.0f, 0.0f, 1.0f };</a>
<a name="ln4608">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4609">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4610"> </a>
<a name="ln4611">  // reset gui elements</a>
<a name="ln4612">  if(module-&gt;gui_data)</a>
<a name="ln4613">  {</a>
<a name="ln4614">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln4615"> </a>
<a name="ln4616">    char string_v[256];</a>
<a name="ln4617">    char string_h[256];</a>
<a name="ln4618"> </a>
<a name="ln4619">    snprintf(string_v, sizeof(string_v), _(&quot;lens shift (%s)&quot;), isflipped ? _(&quot;horizontal&quot;) : _(&quot;vertical&quot;));</a>
<a name="ln4620">    snprintf(string_h, sizeof(string_h), _(&quot;lens shift (%s)&quot;), isflipped ? _(&quot;vertical&quot;) : _(&quot;horizontal&quot;));</a>
<a name="ln4621"> </a>
<a name="ln4622">    dt_bauhaus_widget_set_label(g-&gt;lensshift_v, NULL, string_v);</a>
<a name="ln4623">    dt_bauhaus_widget_set_label(g-&gt;lensshift_h, NULL, string_h);</a>
<a name="ln4624"> </a>
<a name="ln4625">    dt_bauhaus_slider_set_default(g-&gt;f_length, tmp.f_length);</a>
<a name="ln4626">    dt_bauhaus_slider_set_default(g-&gt;crop_factor, tmp.crop_factor);</a>
<a name="ln4627"> </a>
<a name="ln4628">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln4629">    free(g-&gt;buf);</a>
<a name="ln4630">    g-&gt;buf = NULL;</a>
<a name="ln4631">    g-&gt;buf_width = 0;</a>
<a name="ln4632">    g-&gt;buf_height = 0;</a>
<a name="ln4633">    g-&gt;buf_x_off = 0;</a>
<a name="ln4634">    g-&gt;buf_y_off = 0;</a>
<a name="ln4635">    g-&gt;buf_scale = 1.0f;</a>
<a name="ln4636">    g-&gt;buf_hash = 0;</a>
<a name="ln4637">    g-&gt;isflipped = -1;</a>
<a name="ln4638">    g-&gt;lastfit = ASHIFT_FIT_NONE;</a>
<a name="ln4639">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln4640"> </a>
<a name="ln4641">    g-&gt;fitting = 0;</a>
<a name="ln4642">    free(g-&gt;lines);</a>
<a name="ln4643">    g-&gt;lines = NULL;</a>
<a name="ln4644">    g-&gt;lines_count =0;</a>
<a name="ln4645">    g-&gt;horizontal_count = 0;</a>
<a name="ln4646">    g-&gt;vertical_count = 0;</a>
<a name="ln4647">    g-&gt;grid_hash = 0;</a>
<a name="ln4648">    g-&gt;lines_hash = 0;</a>
<a name="ln4649">    g-&gt;rotation_range = ROTATION_RANGE_SOFT;</a>
<a name="ln4650">    g-&gt;lensshift_v_range = LENSSHIFT_RANGE_SOFT;</a>
<a name="ln4651">    g-&gt;lensshift_h_range = LENSSHIFT_RANGE_SOFT;</a>
<a name="ln4652">    g-&gt;shear_range = SHEAR_RANGE_SOFT;</a>
<a name="ln4653">    g-&gt;lines_suppressed = 0;</a>
<a name="ln4654">    g-&gt;lines_version = 0;</a>
<a name="ln4655">    g-&gt;show_guides = 0;</a>
<a name="ln4656">    g-&gt;isselecting = 0;</a>
<a name="ln4657">    g-&gt;isdeselecting = 0;</a>
<a name="ln4658">    g-&gt;isbounding = ASHIFT_BOUNDING_OFF;</a>
<a name="ln4659">    g-&gt;near_delta = 0;</a>
<a name="ln4660">    g-&gt;selecting_lines_version = 0;</a>
<a name="ln4661"> </a>
<a name="ln4662">    free(g-&gt;points);</a>
<a name="ln4663">    g-&gt;points = NULL;</a>
<a name="ln4664">    free(g-&gt;points_idx);</a>
<a name="ln4665">    g-&gt;points_idx = NULL;</a>
<a name="ln4666">    g-&gt;points_lines_count = 0;</a>
<a name="ln4667">    g-&gt;points_version = 0;</a>
<a name="ln4668"> </a>
<a name="ln4669">    g-&gt;jobcode = ASHIFT_JOBCODE_NONE;</a>
<a name="ln4670">    g-&gt;jobparams = 0;</a>
<a name="ln4671">    g-&gt;adjust_crop = FALSE;</a>
<a name="ln4672">    g-&gt;lastx = g-&gt;lasty = -1.0f;</a>
<a name="ln4673">    g-&gt;crop_cx = g-&gt;crop_cy = 1.0f;</a>
<a name="ln4674">  }</a>
<a name="ln4675">}</a>
<a name="ln4676"> </a>
<a name="ln4677"> </a>
<a name="ln4678">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln4679">{</a>
<a name="ln4680">  dt_iop_ashift_global_data_t *gd</a>
<a name="ln4681">      = (dt_iop_ashift_global_data_t *)malloc(sizeof(dt_iop_ashift_global_data_t));</a>
<a name="ln4682">  module-&gt;data = gd;</a>
<a name="ln4683"> </a>
<a name="ln4684">  const int program = 2; // basic.cl, from programs.conf</a>
<a name="ln4685">  gd-&gt;kernel_ashift_bilinear = dt_opencl_create_kernel(program, &quot;ashift_bilinear&quot;);</a>
<a name="ln4686">  gd-&gt;kernel_ashift_bicubic = dt_opencl_create_kernel(program, &quot;ashift_bicubic&quot;);</a>
<a name="ln4687">  gd-&gt;kernel_ashift_lanczos2 = dt_opencl_create_kernel(program, &quot;ashift_lanczos2&quot;);</a>
<a name="ln4688">  gd-&gt;kernel_ashift_lanczos3 = dt_opencl_create_kernel(program, &quot;ashift_lanczos3&quot;);</a>
<a name="ln4689">}</a>
<a name="ln4690"> </a>
<a name="ln4691">void cleanup(dt_iop_module_t *module)</a>
<a name="ln4692">{</a>
<a name="ln4693">  free(module-&gt;params);</a>
<a name="ln4694">  module-&gt;params = NULL;</a>
<a name="ln4695">}</a>
<a name="ln4696"> </a>
<a name="ln4697">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln4698">{</a>
<a name="ln4699">  dt_iop_ashift_global_data_t *gd = (dt_iop_ashift_global_data_t *)module-&gt;data;</a>
<a name="ln4700">  dt_opencl_free_kernel(gd-&gt;kernel_ashift_bilinear);</a>
<a name="ln4701">  dt_opencl_free_kernel(gd-&gt;kernel_ashift_bicubic);</a>
<a name="ln4702">  dt_opencl_free_kernel(gd-&gt;kernel_ashift_lanczos2);</a>
<a name="ln4703">  dt_opencl_free_kernel(gd-&gt;kernel_ashift_lanczos3);</a>
<a name="ln4704">  free(module-&gt;data);</a>
<a name="ln4705">  module-&gt;data = NULL;</a>
<a name="ln4706">}</a>
<a name="ln4707"> </a>
<a name="ln4708">// adjust labels of lens shift parameters according to flip status of image</a>
<a name="ln4709">static gboolean draw(GtkWidget *widget, cairo_t *cr, dt_iop_module_t *self)</a>
<a name="ln4710">{</a>
<a name="ln4711">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4712">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4713"> </a>
<a name="ln4714">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln4715">  const int isflipped = g-&gt;isflipped;</a>
<a name="ln4716">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln4717"> </a>
<a name="ln4718">  if(isflipped == -1) return FALSE;</a>
<a name="ln4719"> </a>
<a name="ln4720">  char string_v[256];</a>
<a name="ln4721">  char string_h[256];</a>
<a name="ln4722"> </a>
<a name="ln4723">  snprintf(string_v, sizeof(string_v), _(&quot;lens shift (%s)&quot;), isflipped ? _(&quot;horizontal&quot;) : _(&quot;vertical&quot;));</a>
<a name="ln4724">  snprintf(string_h, sizeof(string_h), _(&quot;lens shift (%s)&quot;), isflipped ? _(&quot;vertical&quot;) : _(&quot;horizontal&quot;));</a>
<a name="ln4725"> </a>
<a name="ln4726">  darktable.gui-&gt;reset = 1;</a>
<a name="ln4727">  dt_bauhaus_widget_set_label(g-&gt;lensshift_v, NULL, string_v);</a>
<a name="ln4728">  dt_bauhaus_widget_set_label(g-&gt;lensshift_h, NULL, string_h);</a>
<a name="ln4729">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;eye), g-&gt;lines_suppressed);</a>
<a name="ln4730">  darktable.gui-&gt;reset = 0;</a>
<a name="ln4731"> </a>
<a name="ln4732">  return FALSE;</a>
<a name="ln4733">}</a>
<a name="ln4734"> </a>
<a name="ln4735">void gui_focus(struct dt_iop_module_t *self, gboolean in)</a>
<a name="ln4736">{</a>
<a name="ln4737">  if(self-&gt;enabled)</a>
<a name="ln4738">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4739">}</a>
<a name="ln4740"> </a>
<a name="ln4741">static float log10_callback(GtkWidget *self, float inval, dt_bauhaus_callback_t dir)</a>
<a name="ln4742">{</a>
<a name="ln4743">  float outval;</a>
<a name="ln4744">  switch(dir)</a>
<a name="ln4745">  {</a>
<a name="ln4746">    case DT_BAUHAUS_SET:</a>
<a name="ln4747">      outval = log10(fmax(inval, 1e-15f));</a>
<a name="ln4748">      break;</a>
<a name="ln4749">    case DT_BAUHAUS_GET:</a>
<a name="ln4750">      outval = exp(M_LN10 * inval);</a>
<a name="ln4751">      break;</a>
<a name="ln4752">    default:</a>
<a name="ln4753">      outval = inval;</a>
<a name="ln4754">  }</a>
<a name="ln4755">  return outval;</a>
<a name="ln4756">}</a>
<a name="ln4757"> </a>
<a name="ln4758">static float log2_callback(GtkWidget *self, float inval, dt_bauhaus_callback_t dir)</a>
<a name="ln4759">{</a>
<a name="ln4760">  float outval;</a>
<a name="ln4761">  switch(dir)</a>
<a name="ln4762">  {</a>
<a name="ln4763">    case DT_BAUHAUS_SET:</a>
<a name="ln4764">      outval = log(fmax(inval, 1e-15f)) / M_LN2;</a>
<a name="ln4765">      break;</a>
<a name="ln4766">    case DT_BAUHAUS_GET:</a>
<a name="ln4767">      outval = exp(M_LN2 * inval);</a>
<a name="ln4768">      break;</a>
<a name="ln4769">    default:</a>
<a name="ln4770">      outval = inval;</a>
<a name="ln4771">  }</a>
<a name="ln4772">  return outval;</a>
<a name="ln4773">}</a>
<a name="ln4774"> </a>
<a name="ln4775">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln4776">{</a>
<a name="ln4777">  self-&gt;gui_data = malloc(sizeof(dt_iop_ashift_gui_data_t));</a>
<a name="ln4778">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4779">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4780"> </a>
<a name="ln4781">  dt_pthread_mutex_init(&amp;g-&gt;lock, NULL);</a>
<a name="ln4782">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln4783">  g-&gt;buf = NULL;</a>
<a name="ln4784">  g-&gt;buf_width = 0;</a>
<a name="ln4785">  g-&gt;buf_height = 0;</a>
<a name="ln4786">  g-&gt;buf_x_off = 0;</a>
<a name="ln4787">  g-&gt;buf_y_off = 0;</a>
<a name="ln4788">  g-&gt;buf_scale = 1.0f;</a>
<a name="ln4789">  g-&gt;buf_hash = 0;</a>
<a name="ln4790">  g-&gt;isflipped = -1;</a>
<a name="ln4791">  g-&gt;lastfit = ASHIFT_FIT_NONE;</a>
<a name="ln4792">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln4793"> </a>
<a name="ln4794">  g-&gt;fitting = 0;</a>
<a name="ln4795">  g-&gt;lines = NULL;</a>
<a name="ln4796">  g-&gt;lines_count = 0;</a>
<a name="ln4797">  g-&gt;vertical_count = 0;</a>
<a name="ln4798">  g-&gt;horizontal_count = 0;</a>
<a name="ln4799">  g-&gt;lines_version = 0;</a>
<a name="ln4800">  g-&gt;lines_suppressed = 0;</a>
<a name="ln4801">  g-&gt;points = NULL;</a>
<a name="ln4802">  g-&gt;points_idx = NULL;</a>
<a name="ln4803">  g-&gt;points_lines_count = 0;</a>
<a name="ln4804">  g-&gt;points_version = 0;</a>
<a name="ln4805">  g-&gt;grid_hash = 0;</a>
<a name="ln4806">  g-&gt;lines_hash = 0;</a>
<a name="ln4807">  g-&gt;rotation_range = ROTATION_RANGE_SOFT;</a>
<a name="ln4808">  g-&gt;lensshift_v_range = LENSSHIFT_RANGE_SOFT;</a>
<a name="ln4809">  g-&gt;lensshift_h_range = LENSSHIFT_RANGE_SOFT;</a>
<a name="ln4810">  g-&gt;shear_range = SHEAR_RANGE_SOFT;</a>
<a name="ln4811">  g-&gt;show_guides = 0;</a>
<a name="ln4812">  g-&gt;isselecting = 0;</a>
<a name="ln4813">  g-&gt;isdeselecting = 0;</a>
<a name="ln4814">  g-&gt;isbounding = ASHIFT_BOUNDING_OFF;</a>
<a name="ln4815">  g-&gt;near_delta = 0;</a>
<a name="ln4816">  g-&gt;selecting_lines_version = 0;</a>
<a name="ln4817"> </a>
<a name="ln4818">  g-&gt;jobcode = ASHIFT_JOBCODE_NONE;</a>
<a name="ln4819">  g-&gt;jobparams = 0;</a>
<a name="ln4820">  g-&gt;adjust_crop = FALSE;</a>
<a name="ln4821">  g-&gt;lastx = g-&gt;lasty = -1.0f;</a>
<a name="ln4822">  g-&gt;crop_cx = g-&gt;crop_cy = 1.0f;</a>
<a name="ln4823"> </a>
<a name="ln4824">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln4825">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln4826"> </a>
<a name="ln4827">  g-&gt;rotation = dt_bauhaus_slider_new_with_range(self, -ROTATION_RANGE, ROTATION_RANGE, 0.01*ROTATION_RANGE, p-&gt;rotation, 2);</a>
<a name="ln4828">  dt_bauhaus_widget_set_label(g-&gt;rotation, NULL, _(&quot;rotation&quot;));</a>
<a name="ln4829">  dt_bauhaus_slider_set_format(g-&gt;rotation, &quot;%.2f&quot;);</a>
<a name="ln4830">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;rotation, -ROTATION_RANGE_SOFT, ROTATION_RANGE_SOFT);</a>
<a name="ln4831">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;rotation, TRUE, TRUE, 0);</a>
<a name="ln4832"> </a>
<a name="ln4833">  g-&gt;lensshift_v = dt_bauhaus_slider_new_with_range(self, -LENSSHIFT_RANGE, LENSSHIFT_RANGE, 0.01*LENSSHIFT_RANGE, p-&gt;lensshift_v, 3);</a>
<a name="ln4834">  dt_bauhaus_widget_set_label(g-&gt;lensshift_v, NULL, _(&quot;lens shift (vertical)&quot;));</a>
<a name="ln4835">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;lensshift_v, -LENSSHIFT_RANGE_SOFT, LENSSHIFT_RANGE_SOFT);</a>
<a name="ln4836">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;lensshift_v, TRUE, TRUE, 0);</a>
<a name="ln4837"> </a>
<a name="ln4838">  g-&gt;lensshift_h = dt_bauhaus_slider_new_with_range(self, -LENSSHIFT_RANGE, LENSSHIFT_RANGE, 0.01*LENSSHIFT_RANGE, p-&gt;lensshift_h, 3);</a>
<a name="ln4839">  dt_bauhaus_widget_set_label(g-&gt;lensshift_h, NULL, _(&quot;lens shift (horizontal)&quot;));</a>
<a name="ln4840">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;lensshift_h, -LENSSHIFT_RANGE_SOFT, LENSSHIFT_RANGE_SOFT);</a>
<a name="ln4841">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;lensshift_h, TRUE, TRUE, 0);</a>
<a name="ln4842"> </a>
<a name="ln4843">  g-&gt;shear = dt_bauhaus_slider_new_with_range(self, -SHEAR_RANGE, SHEAR_RANGE, 0.01*SHEAR_RANGE, p-&gt;shear, 3);</a>
<a name="ln4844">  dt_bauhaus_widget_set_label(g-&gt;shear, NULL, _(&quot;shear&quot;));</a>
<a name="ln4845">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;shear, -SHEAR_RANGE_SOFT, SHEAR_RANGE_SOFT);</a>
<a name="ln4846">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;shear, TRUE, TRUE, 0);</a>
<a name="ln4847"> </a>
<a name="ln4848">  g-&gt;guide_lines = dt_bauhaus_combobox_new(self);</a>
<a name="ln4849">  dt_bauhaus_widget_set_label(g-&gt;guide_lines, NULL, _(&quot;guides&quot;));</a>
<a name="ln4850">  dt_bauhaus_combobox_add(g-&gt;guide_lines, _(&quot;off&quot;));</a>
<a name="ln4851">  dt_bauhaus_combobox_add(g-&gt;guide_lines, _(&quot;on&quot;));</a>
<a name="ln4852">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;guide_lines, TRUE, TRUE, 0);</a>
<a name="ln4853"> </a>
<a name="ln4854">  g-&gt;cropmode = dt_bauhaus_combobox_new(self);</a>
<a name="ln4855">  dt_bauhaus_widget_set_label(g-&gt;cropmode, NULL, _(&quot;automatic cropping&quot;));</a>
<a name="ln4856">  dt_bauhaus_combobox_add(g-&gt;cropmode, _(&quot;off&quot;));</a>
<a name="ln4857">  dt_bauhaus_combobox_add(g-&gt;cropmode, _(&quot;largest area&quot;));</a>
<a name="ln4858">  dt_bauhaus_combobox_add(g-&gt;cropmode, _(&quot;original format&quot;));</a>
<a name="ln4859">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;cropmode, TRUE, TRUE, 0);</a>
<a name="ln4860"> </a>
<a name="ln4861">  g-&gt;mode = dt_bauhaus_combobox_new(self);</a>
<a name="ln4862">  dt_bauhaus_widget_set_label(g-&gt;mode, NULL, _(&quot;lens model&quot;));</a>
<a name="ln4863">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;generic&quot;));</a>
<a name="ln4864">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;specific&quot;));</a>
<a name="ln4865">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;mode, TRUE, TRUE, 0);</a>
<a name="ln4866"> </a>
<a name="ln4867">  g-&gt;f_length = dt_bauhaus_slider_new_with_range(self, 1.0f, 3.0f, 0.01f, 1.0f, 2);</a>
<a name="ln4868">  dt_bauhaus_widget_set_label(g-&gt;f_length, NULL, _(&quot;focal length&quot;));</a>
<a name="ln4869">  dt_bauhaus_slider_set_callback(g-&gt;f_length, log10_callback);</a>
<a name="ln4870">  dt_bauhaus_slider_set_format(g-&gt;f_length, &quot;%.0fmm&quot;);</a>
<a name="ln4871">  dt_bauhaus_slider_set_default(g-&gt;f_length, DEFAULT_F_LENGTH);</a>
<a name="ln4872">  dt_bauhaus_slider_set(g-&gt;f_length, DEFAULT_F_LENGTH);</a>
<a name="ln4873">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;f_length, 1.0f, 2000.0f);</a>
<a name="ln4874">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;f_length, TRUE, TRUE, 0);</a>
<a name="ln4875"> </a>
<a name="ln4876">  g-&gt;crop_factor = dt_bauhaus_slider_new_with_range(self, 1.0f, 2.0f, 0.01f, p-&gt;crop_factor, 2);</a>
<a name="ln4877">  dt_bauhaus_widget_set_label(g-&gt;crop_factor, NULL, _(&quot;crop factor&quot;));</a>
<a name="ln4878">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;crop_factor, 0.5f, 10.0f);</a>
<a name="ln4879">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;crop_factor, TRUE, TRUE, 0);</a>
<a name="ln4880"> </a>
<a name="ln4881">  g-&gt;orthocorr = dt_bauhaus_slider_new_with_range(self, 0.0f, 100.0f, 1.0f, p-&gt;orthocorr, 2);</a>
<a name="ln4882">  dt_bauhaus_widget_set_label(g-&gt;orthocorr, NULL, _(&quot;lens dependence&quot;));</a>
<a name="ln4883">  dt_bauhaus_slider_set_format(g-&gt;orthocorr, &quot;%.0f%%&quot;);</a>
<a name="ln4884">#if 0</a>
<a name="ln4885">  // this parameter could serve to finetune between generic model (0%) and specific model (100%).</a>
<a name="ln4886">  // however, users can more easily get the same effect with the aspect adjust parameter so we keep</a>
<a name="ln4887">  // this one hidden.</a>
<a name="ln4888">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;orthocorr, TRUE, TRUE, 0);</a>
<a name="ln4889">#endif</a>
<a name="ln4890"> </a>
<a name="ln4891">  g-&gt;aspect = dt_bauhaus_slider_new_with_range(self, -1.0f, 1.0f, 0.01f, 0.0f, 2);</a>
<a name="ln4892">  dt_bauhaus_widget_set_label(g-&gt;aspect, NULL, _(&quot;aspect adjust&quot;));</a>
<a name="ln4893">  dt_bauhaus_slider_set_callback(g-&gt;aspect, log2_callback);</a>
<a name="ln4894">  dt_bauhaus_slider_set_default(g-&gt;aspect, 1.0f);</a>
<a name="ln4895">  dt_bauhaus_slider_set(g-&gt;aspect, 1.0f);</a>
<a name="ln4896">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;aspect, TRUE, TRUE, 0);</a>
<a name="ln4897"> </a>
<a name="ln4898">  GtkWidget *grid = gtk_grid_new();</a>
<a name="ln4899">  gtk_grid_set_row_spacing(GTK_GRID(grid), 2 * DT_BAUHAUS_SPACE);</a>
<a name="ln4900">  gtk_grid_set_column_spacing(GTK_GRID(grid), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln4901"> </a>
<a name="ln4902">  GtkWidget *label1 = gtk_label_new(_(&quot;automatic fit&quot;));</a>
<a name="ln4903">  gtk_widget_set_halign(label1, GTK_ALIGN_START);</a>
<a name="ln4904">  gtk_grid_attach(GTK_GRID(grid), label1, 0, 0, 1, 1);</a>
<a name="ln4905"> </a>
<a name="ln4906">  g-&gt;fit_v = dtgtk_button_new(dtgtk_cairo_paint_perspective, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | 1, NULL);</a>
<a name="ln4907">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;fit_v), TRUE);</a>
<a name="ln4908">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;fit_v, label1, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4909"> </a>
<a name="ln4910">  g-&gt;fit_h = dtgtk_button_new(dtgtk_cairo_paint_perspective, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | 2, NULL);</a>
<a name="ln4911">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;fit_h), TRUE);</a>
<a name="ln4912">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;fit_h, g-&gt;fit_v, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4913"> </a>
<a name="ln4914">  g-&gt;fit_both = dtgtk_button_new(dtgtk_cairo_paint_perspective, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | 3, NULL);</a>
<a name="ln4915">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;fit_both), TRUE);</a>
<a name="ln4916">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;fit_both, g-&gt;fit_h, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4917"> </a>
<a name="ln4918">  GtkWidget *label2 = gtk_label_new(_(&quot;get structure&quot;));</a>
<a name="ln4919">  gtk_widget_set_halign(label2, GTK_ALIGN_START);</a>
<a name="ln4920">  gtk_grid_attach(GTK_GRID(grid), label2, 0, 1, 1, 1);</a>
<a name="ln4921"> </a>
<a name="ln4922">  g-&gt;structure = dtgtk_button_new(dtgtk_cairo_paint_structure, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln4923">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;structure), TRUE);</a>
<a name="ln4924">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;structure, label2, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4925"> </a>
<a name="ln4926">  g-&gt;clean = dtgtk_button_new(dtgtk_cairo_paint_cancel, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln4927">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;clean), TRUE);</a>
<a name="ln4928">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;clean, g-&gt;structure, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4929"> </a>
<a name="ln4930">  g-&gt;eye = dtgtk_togglebutton_new(dtgtk_cairo_paint_eye_toggle, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln4931">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;eye), TRUE);</a>
<a name="ln4932">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;eye, g-&gt;clean, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4933"> </a>
<a name="ln4934">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), grid, TRUE, TRUE, 0);</a>
<a name="ln4935"> </a>
<a name="ln4936">  gtk_widget_show_all(g-&gt;f_length);</a>
<a name="ln4937">  gtk_widget_set_no_show_all(g-&gt;f_length, TRUE);</a>
<a name="ln4938">  gtk_widget_show_all(g-&gt;crop_factor);</a>
<a name="ln4939">  gtk_widget_set_no_show_all(g-&gt;crop_factor, TRUE);</a>
<a name="ln4940">  gtk_widget_show_all(g-&gt;orthocorr);</a>
<a name="ln4941">  gtk_widget_set_no_show_all(g-&gt;orthocorr, TRUE);</a>
<a name="ln4942">  gtk_widget_show_all(g-&gt;aspect);</a>
<a name="ln4943">  gtk_widget_set_no_show_all(g-&gt;aspect, TRUE);</a>
<a name="ln4944"> </a>
<a name="ln4945"> </a>
<a name="ln4946">  switch(p-&gt;mode)</a>
<a name="ln4947">  {</a>
<a name="ln4948">    case ASHIFT_MODE_GENERIC:</a>
<a name="ln4949">      gtk_widget_hide(g-&gt;f_length);</a>
<a name="ln4950">      gtk_widget_hide(g-&gt;crop_factor);</a>
<a name="ln4951">      gtk_widget_hide(g-&gt;orthocorr);</a>
<a name="ln4952">      gtk_widget_hide(g-&gt;aspect);</a>
<a name="ln4953">      break;</a>
<a name="ln4954">    case ASHIFT_MODE_SPECIFIC:</a>
<a name="ln4955">    default:</a>
<a name="ln4956">      gtk_widget_show(g-&gt;f_length);</a>
<a name="ln4957">      gtk_widget_show(g-&gt;crop_factor);</a>
<a name="ln4958">      gtk_widget_show(g-&gt;orthocorr);</a>
<a name="ln4959">      gtk_widget_show(g-&gt;aspect);</a>
<a name="ln4960">      break;</a>
<a name="ln4961">  }</a>
<a name="ln4962"> </a>
<a name="ln4963">  gtk_widget_set_tooltip_text(g-&gt;rotation, _(&quot;rotate image&quot;));</a>
<a name="ln4964">  gtk_widget_set_tooltip_text(g-&gt;lensshift_v, _(&quot;apply lens shift correction in one direction&quot;));</a>
<a name="ln4965">  gtk_widget_set_tooltip_text(g-&gt;lensshift_h, _(&quot;apply lens shift correction in one direction&quot;));</a>
<a name="ln4966">  gtk_widget_set_tooltip_text(g-&gt;shear, _(&quot;shear the image along one diagonal&quot;));</a>
<a name="ln4967">  gtk_widget_set_tooltip_text(g-&gt;guide_lines, _(&quot;display guide lines overlay&quot;));</a>
<a name="ln4968">  gtk_widget_set_tooltip_text(g-&gt;cropmode, _(&quot;automatically crop to avoid black edges&quot;));</a>
<a name="ln4969">  gtk_widget_set_tooltip_text(g-&gt;mode, _(&quot;lens model of the perspective correction: &quot;</a>
<a name="ln4970">                                         &quot;generic or according to the focal length&quot;));</a>
<a name="ln4971">  gtk_widget_set_tooltip_text(g-&gt;f_length, _(&quot;focal length of the lens, &quot;</a>
<a name="ln4972">                                             &quot;default value set from exif data if available&quot;));</a>
<a name="ln4973">  gtk_widget_set_tooltip_text(g-&gt;crop_factor, _(&quot;crop factor of the camera sensor, &quot;</a>
<a name="ln4974">                                                &quot;default value set from exif data if available, &quot;</a>
<a name="ln4975">                                                &quot;manual setting is often required&quot;));</a>
<a name="ln4976">  gtk_widget_set_tooltip_text(g-&gt;orthocorr, _(&quot;the level of lens dependent correction, set to maximum for full lens dependency, &quot;</a>
<a name="ln4977">                                              &quot;set to zero for the generic case&quot;));</a>
<a name="ln4978">  gtk_widget_set_tooltip_text(g-&gt;aspect, _(&quot;adjust aspect ratio of image by horizontal and vertical scaling&quot;));</a>
<a name="ln4979">  gtk_widget_set_tooltip_text(g-&gt;fit_v, _(&quot;automatically correct for vertical perspective distortion\n&quot;</a>
<a name="ln4980">                                          &quot;ctrl-click to only fit rotation\n&quot;</a>
<a name="ln4981">                                          &quot;shift-click to only fit lens shift&quot;));</a>
<a name="ln4982">  gtk_widget_set_tooltip_text(g-&gt;fit_h, _(&quot;automatically correct for horizontal perspective distortion\n&quot;</a>
<a name="ln4983">                                          &quot;ctrl-click to only fit rotation\n&quot;</a>
<a name="ln4984">                                          &quot;shift-click to only fit lens shift&quot;));</a>
<a name="ln4985">  gtk_widget_set_tooltip_text(g-&gt;fit_both, _(&quot;automatically correct for vertical and &quot;</a>
<a name="ln4986">                                             &quot;horizontal perspective distortions; fitting rotation,&quot;</a>
<a name="ln4987">                                             &quot;lens shift in both directions, and shear\n&quot;</a>
<a name="ln4988">                                             &quot;ctrl-click to only fit rotation\n&quot;</a>
<a name="ln4989">                                             &quot;shift-click to only fit lens shift\n&quot;</a>
<a name="ln4990">                                             &quot;ctrl-shift-click to only fit rotation and lens shift&quot;));</a>
<a name="ln4991">  gtk_widget_set_tooltip_text(g-&gt;structure, _(&quot;analyse line structure in image\n&quot;</a>
<a name="ln4992">                                              &quot;ctrl-click for an additional edge enhancement\n&quot;</a>
<a name="ln4993">                                              &quot;shift-click for an additional detail enhancement\n&quot;</a>
<a name="ln4994">                                              &quot;ctrl-shift-click for a combination of both methods&quot;));</a>
<a name="ln4995">  gtk_widget_set_tooltip_text(g-&gt;clean, _(&quot;remove line structure information&quot;));</a>
<a name="ln4996">  gtk_widget_set_tooltip_text(g-&gt;eye, _(&quot;toggle visibility of structure lines&quot;));</a>
<a name="ln4997"> </a>
<a name="ln4998">  g_signal_connect(G_OBJECT(g-&gt;rotation), &quot;value-changed&quot;, G_CALLBACK(rotation_callback), self);</a>
<a name="ln4999">  g_signal_connect(G_OBJECT(g-&gt;lensshift_v), &quot;value-changed&quot;, G_CALLBACK(lensshift_v_callback), self);</a>
<a name="ln5000">  g_signal_connect(G_OBJECT(g-&gt;lensshift_h), &quot;value-changed&quot;, G_CALLBACK(lensshift_h_callback), self);</a>
<a name="ln5001">  g_signal_connect(G_OBJECT(g-&gt;shear), &quot;value-changed&quot;, G_CALLBACK(shear_callback), self);</a>
<a name="ln5002">  g_signal_connect(G_OBJECT(g-&gt;guide_lines), &quot;value-changed&quot;, G_CALLBACK(guide_lines_callback), self);</a>
<a name="ln5003">  g_signal_connect(G_OBJECT(g-&gt;cropmode), &quot;value-changed&quot;, G_CALLBACK(cropmode_callback), self);</a>
<a name="ln5004">  g_signal_connect(G_OBJECT(g-&gt;mode), &quot;value-changed&quot;, G_CALLBACK(mode_callback), self);</a>
<a name="ln5005">  g_signal_connect(G_OBJECT(g-&gt;f_length), &quot;value-changed&quot;, G_CALLBACK(f_length_callback), self);</a>
<a name="ln5006">  g_signal_connect(G_OBJECT(g-&gt;crop_factor), &quot;value-changed&quot;, G_CALLBACK(crop_factor_callback), self);</a>
<a name="ln5007">  g_signal_connect(G_OBJECT(g-&gt;orthocorr), &quot;value-changed&quot;, G_CALLBACK(orthocorr_callback), self);</a>
<a name="ln5008">  g_signal_connect(G_OBJECT(g-&gt;aspect), &quot;value-changed&quot;, G_CALLBACK(aspect_callback), self);</a>
<a name="ln5009">  g_signal_connect(G_OBJECT(g-&gt;fit_v), &quot;button-press-event&quot;, G_CALLBACK(fit_v_button_clicked), (gpointer)self);</a>
<a name="ln5010">  g_signal_connect(G_OBJECT(g-&gt;fit_h), &quot;button-press-event&quot;, G_CALLBACK(fit_h_button_clicked), (gpointer)self);</a>
<a name="ln5011">  g_signal_connect(G_OBJECT(g-&gt;fit_both), &quot;button-press-event&quot;, G_CALLBACK(fit_both_button_clicked), (gpointer)self);</a>
<a name="ln5012">  g_signal_connect(G_OBJECT(g-&gt;structure), &quot;button-press-event&quot;, G_CALLBACK(structure_button_clicked), (gpointer)self);</a>
<a name="ln5013">  g_signal_connect(G_OBJECT(g-&gt;clean), &quot;clicked&quot;, G_CALLBACK(clean_button_clicked), (gpointer)self);</a>
<a name="ln5014">  g_signal_connect(G_OBJECT(g-&gt;eye), &quot;toggled&quot;, G_CALLBACK(eye_button_toggled), (gpointer)self);</a>
<a name="ln5015">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;draw&quot;, G_CALLBACK(draw), self);</a>
<a name="ln5016"> </a>
<a name="ln5017">  /* add signal handler for preview pipe finish to redraw the overlay */</a>
<a name="ln5018">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_PREVIEW_PIPE_FINISHED,</a>
<a name="ln5019">                            G_CALLBACK(process_after_preview_callback), self);</a>
<a name="ln5020"> </a>
<a name="ln5021">}</a>
<a name="ln5022"> </a>
<a name="ln5023">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln5024">{</a>
<a name="ln5025">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(process_after_preview_callback), self);</a>
<a name="ln5026"> </a>
<a name="ln5027">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln5028">  dt_pthread_mutex_destroy(&amp;g-&gt;lock);</a>
<a name="ln5029">  free(g-&gt;lines);</a>
<a name="ln5030">  free(g-&gt;buf);</a>
<a name="ln5031">  free(g-&gt;points);</a>
<a name="ln5032">  free(g-&gt;points_idx);</a>
<a name="ln5033">  free(self-&gt;gui_data);</a>
<a name="ln5034">  self-&gt;gui_data = NULL;</a>
<a name="ln5035">}</a>
<a name="ln5036"> </a>
<a name="ln5037">GSList *mouse_actions(struct dt_iop_module_t *self)</a>
<a name="ln5038">{</a>
<a name="ln5039">  GSList *lm = NULL;</a>
<a name="ln5040">  dt_mouse_action_t *a = NULL;</a>
<a name="ln5041"> </a>
<a name="ln5042">  a = (dt_mouse_action_t *)calloc(1, sizeof(dt_mouse_action_t));</a>
<a name="ln5043">  a-&gt;action = DT_MOUSE_ACTION_LEFT;</a>
<a name="ln5044">  g_snprintf(a-&gt;name, sizeof(a-&gt;name), _(&quot;[%s on segment] select segment&quot;), self-&gt;name(self));</a>
<a name="ln5045">  lm = g_slist_append(lm, a);</a>
<a name="ln5046"> </a>
<a name="ln5047">  a = (dt_mouse_action_t *)calloc(1, sizeof(dt_mouse_action_t));</a>
<a name="ln5048">  a-&gt;action = DT_MOUSE_ACTION_RIGHT;</a>
<a name="ln5049">  g_snprintf(a-&gt;name, sizeof(a-&gt;name), _(&quot;[%s on segment] unselect segment&quot;), self-&gt;name(self));</a>
<a name="ln5050">  lm = g_slist_append(lm, a);</a>
<a name="ln5051"> </a>
<a name="ln5052">  a = (dt_mouse_action_t *)calloc(1, sizeof(dt_mouse_action_t));</a>
<a name="ln5053">  a-&gt;key.accel_mods = GDK_SHIFT_MASK;</a>
<a name="ln5054">  a-&gt;action = DT_MOUSE_ACTION_LEFT_DRAG;</a>
<a name="ln5055">  g_snprintf(a-&gt;name, sizeof(a-&gt;name), _(&quot;[%s] select all segments from zone&quot;), self-&gt;name(self));</a>
<a name="ln5056">  lm = g_slist_append(lm, a);</a>
<a name="ln5057"> </a>
<a name="ln5058">  a = (dt_mouse_action_t *)calloc(1, sizeof(dt_mouse_action_t));</a>
<a name="ln5059">  a-&gt;key.accel_mods = GDK_SHIFT_MASK;</a>
<a name="ln5060">  a-&gt;action = DT_MOUSE_ACTION_RIGHT_DRAG;</a>
<a name="ln5061">  g_snprintf(a-&gt;name, sizeof(a-&gt;name), _(&quot;[%s] unselect all segments from zone&quot;), self-&gt;name(self));</a>
<a name="ln5062">  lm = g_slist_append(lm, a);</a>
<a name="ln5063"> </a>
<a name="ln5064">  return lm;</a>
<a name="ln5065">}</a>
<a name="ln5066">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln5067">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln5068">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1258"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'Gy' is always false.</p></div>
<div class="balloon" rel="1678"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1678, 1677.</p></div>
<div class="balloon" rel="1698"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'perm'. Check lines: 1698, 1697.</p></div>
<div class="balloon" rel="1744"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'inout'. Check lines: 1744, 1702.</p></div>
<div class="balloon" rel="1815"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1815, 1679.</p></div>
<div class="balloon" rel="1873"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lines_set'. Check lines: 1873, 1855.</p></div>
<div class="balloon" rel="1874"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'inout_set'. Check lines: 1874, 1857.</p></div>
<div class="balloon" rel="2795"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'g->fitting' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 2787, 2795.</p></div>
<div class="balloon" rel="3894"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>
<div class="balloon" rel="4574"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 4574, 4567.</p></div>
<div class="balloon" rel="4575"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 4575, 4568.</p></div>
<div class="balloon" rel="4685"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 4685, 4681.</p></div>
<div class="balloon" rel="4781"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 4781, 4777.</p></div>
<div class="balloon" rel="5043"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'a'. Check lines: 5043, 5042.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
