
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2013--2017 pascal obry.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;develop/lightroom.h&quot;</a>
<a name="ln20">#include &quot;common/colorlabels.h&quot;</a>
<a name="ln21">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln22">#include &quot;common/curve_tools.h&quot;</a>
<a name="ln23">#include &quot;common/darktable.h&quot;</a>
<a name="ln24">#include &quot;common/debug.h&quot;</a>
<a name="ln25">#include &quot;common/iop_order.h&quot;</a>
<a name="ln26">#include &quot;common/ratings.h&quot;</a>
<a name="ln27">#include &quot;common/tags.h&quot;</a>
<a name="ln28">#include &quot;common/metadata.h&quot;</a>
<a name="ln29">#include &quot;control/control.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#include &lt;ctype.h&gt;</a>
<a name="ln32">#include &lt;libxml/parser.h&gt;</a>
<a name="ln33">#include &lt;libxml/xpath.h&gt;</a>
<a name="ln34">#include &lt;libxml/xpathInternals.h&gt;</a>
<a name="ln35">#include &lt;stdlib.h&gt;</a>
<a name="ln36">#include &lt;string.h&gt;</a>
<a name="ln37">#include &lt;sys/stat.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">// copy here the iop params struct with the actual version. This is so to</a>
<a name="ln40">// be as independent as possible of any iop evolutions. Indeed, we create</a>
<a name="ln41">// the iop params into the database for a specific version. We then ask</a>
<a name="ln42">// for a reload of the history parameter. If the iop has evolved since then</a>
<a name="ln43">// the legacy circuitry will be called to convert the parameters.</a>
<a name="ln44">//</a>
<a name="ln45">// to add a new iop:</a>
<a name="ln46">// 1. copy the struct</a>
<a name="ln47">// 2. add LRDT_&lt;iop_name&gt;_VERSION with corresponding module version</a>
<a name="ln48">// 3. use this version to pass in dt_add_hist()</a>
<a name="ln49"> </a>
<a name="ln50">#define LRDT_CLIPPING_VERSION 4</a>
<a name="ln51">typedef struct dt_iop_clipping_params_t</a>
<a name="ln52">{</a>
<a name="ln53">  float angle, cx, cy, cw, ch, k_h, k_v;</a>
<a name="ln54">  float kxa, kya, kxb, kyb, kxc, kyc, kxd, kyd;</a>
<a name="ln55">  int k_type, k_sym;</a>
<a name="ln56">  int k_apply, crop_auto;</a>
<a name="ln57">} dt_iop_clipping_params_t;</a>
<a name="ln58"> </a>
<a name="ln59">#define LRDT_FLIP_VERSION 1</a>
<a name="ln60">typedef struct dt_iop_flip_params_t</a>
<a name="ln61">{</a>
<a name="ln62">  int32_t orientation;</a>
<a name="ln63">} dt_iop_flip_params_t;</a>
<a name="ln64"> </a>
<a name="ln65">#define LRDT_EXPOSURE_VERSION 2</a>
<a name="ln66">typedef struct dt_iop_exposure_params_t</a>
<a name="ln67">{</a>
<a name="ln68">  float black, exposure, gain;</a>
<a name="ln69">} dt_iop_exposure_params_t;</a>
<a name="ln70"> </a>
<a name="ln71">#define LRDT_GRAIN_VERSION 1</a>
<a name="ln72">typedef enum _dt_iop_grain_channel_t</a>
<a name="ln73">{</a>
<a name="ln74">  DT_GRAIN_CHANNEL_HUE = 0,</a>
<a name="ln75">  DT_GRAIN_CHANNEL_SATURATION,</a>
<a name="ln76">  DT_GRAIN_CHANNEL_LIGHTNESS,</a>
<a name="ln77">  DT_GRAIN_CHANNEL_RGB</a>
<a name="ln78">} _dt_iop_grain_channel_t;</a>
<a name="ln79"> </a>
<a name="ln80">typedef struct dt_iop_grain_params_t</a>
<a name="ln81">{</a>
<a name="ln82">  _dt_iop_grain_channel_t channel;</a>
<a name="ln83">  float scale;</a>
<a name="ln84">  float strength;</a>
<a name="ln85">} dt_iop_grain_params_t;</a>
<a name="ln86"> </a>
<a name="ln87">typedef enum dt_iop_dither_t</a>
<a name="ln88">{</a>
<a name="ln89">  DITHER_OFF = 0,</a>
<a name="ln90">  DITHER_8BIT = 1,</a>
<a name="ln91">  DITHER_16BIT = 2</a>
<a name="ln92">} dt_iop_dither_t;</a>
<a name="ln93"> </a>
<a name="ln94">typedef struct dt_iop_fvector_2d_t</a>
<a name="ln95">{</a>
<a name="ln96">  float x;</a>
<a name="ln97">  float y;</a>
<a name="ln98">} dt_iop_vector_2d_t;</a>
<a name="ln99"> </a>
<a name="ln100">#define LRDT_VIGNETTE_VERSION 3</a>
<a name="ln101">typedef struct dt_iop_vignette_params_t</a>
<a name="ln102">{</a>
<a name="ln103">  float scale;               // 0 - 100 Inner radius, percent of largest image dimension</a>
<a name="ln104">  float falloff_scale;       // 0 - 100 Radius for falloff -- outer radius = inner radius + falloff_scale</a>
<a name="ln105">  float brightness;          // -1 - 1 Strength of brightness reduction</a>
<a name="ln106">  float saturation;          // -1 - 1 Strength of saturation reduction</a>
<a name="ln107">  dt_iop_vector_2d_t center; // Center of vignette</a>
<a name="ln108">  gboolean autoratio;        //</a>
<a name="ln109">  float whratio;             // 0-1 = width/height ratio, 1-2 = height/width ratio + 1</a>
<a name="ln110">  float shape;</a>
<a name="ln111">  int dithering; // if and how to perform dithering</a>
<a name="ln112">} dt_iop_vignette_params_t;</a>
<a name="ln113"> </a>
<a name="ln114">#define LRDT_SPOTS_VERSION 1</a>
<a name="ln115">#define MAX_SPOTS 32</a>
<a name="ln116"> </a>
<a name="ln117">typedef struct spot_t</a>
<a name="ln118">{</a>
<a name="ln119">  // position of the spot</a>
<a name="ln120">  float x, y;</a>
<a name="ln121">  // position to clone from</a>
<a name="ln122">  float xc, yc;</a>
<a name="ln123">  float radius;</a>
<a name="ln124">} spot_t;</a>
<a name="ln125"> </a>
<a name="ln126">typedef struct dt_iop_spots_params_t</a>
<a name="ln127">{</a>
<a name="ln128">  int num_spots;</a>
<a name="ln129">  spot_t spot[MAX_SPOTS];</a>
<a name="ln130">} dt_iop_spots_params_t;</a>
<a name="ln131"> </a>
<a name="ln132">#define LRDT_TONECURVE_VERSION 3</a>
<a name="ln133">#define DT_IOP_TONECURVE_MAXNODES 20</a>
<a name="ln134">typedef enum tonecurve_channel_t</a>
<a name="ln135">{</a>
<a name="ln136">  ch_L = 0,</a>
<a name="ln137">  ch_a = 1,</a>
<a name="ln138">  ch_b = 2,</a>
<a name="ln139">  ch_max = 3</a>
<a name="ln140">} tonecurve_channel_t;</a>
<a name="ln141"> </a>
<a name="ln142">typedef struct dt_iop_tonecurve_node_t</a>
<a name="ln143">{</a>
<a name="ln144">  float x;</a>
<a name="ln145">  float y;</a>
<a name="ln146">} dt_iop_tonecurve_node_t;</a>
<a name="ln147"> </a>
<a name="ln148">typedef struct dt_iop_tonecurve_params_t</a>
<a name="ln149">{</a>
<a name="ln150">  dt_iop_tonecurve_node_t tonecurve[3][DT_IOP_TONECURVE_MAXNODES]; // three curves (L, a, b) with max number</a>
<a name="ln151">                                                                   // of nodes</a>
<a name="ln152">  int tonecurve_nodes[3];</a>
<a name="ln153">  int tonecurve_type[3];</a>
<a name="ln154">  int tonecurve_autoscale_ab;</a>
<a name="ln155">  int tonecurve_preset;</a>
<a name="ln156">} dt_iop_tonecurve_params_t;</a>
<a name="ln157"> </a>
<a name="ln158">#define LRDT_COLORZONES_VERSION 2</a>
<a name="ln159">#define DT_IOP_COLORZONES_BANDS 8</a>
<a name="ln160"> </a>
<a name="ln161">typedef enum dt_iop_colorzones_channel_t</a>
<a name="ln162">{</a>
<a name="ln163">  DT_IOP_COLORZONES_L = 0,</a>
<a name="ln164">  DT_IOP_COLORZONES_C = 1,</a>
<a name="ln165">  DT_IOP_COLORZONES_h = 2</a>
<a name="ln166">} dt_iop_colorzones_channel_t;</a>
<a name="ln167"> </a>
<a name="ln168">typedef struct dt_iop_colorzones_params_t</a>
<a name="ln169">{</a>
<a name="ln170">  int32_t channel;</a>
<a name="ln171">  float equalizer_x[3][DT_IOP_COLORZONES_BANDS], equalizer_y[3][DT_IOP_COLORZONES_BANDS];</a>
<a name="ln172">} dt_iop_colorzones_params_t;</a>
<a name="ln173"> </a>
<a name="ln174">#define LRDT_SPLITTONING_VERSION 1</a>
<a name="ln175">typedef struct dt_iop_splittoning_params_t</a>
<a name="ln176">{</a>
<a name="ln177">  float shadow_hue;</a>
<a name="ln178">  float shadow_saturation;</a>
<a name="ln179">  float highlight_hue;</a>
<a name="ln180">  float highlight_saturation;</a>
<a name="ln181">  float balance;  // center luminance of gradient</a>
<a name="ln182">  float compress; // Compress range</a>
<a name="ln183">} dt_iop_splittoning_params_t;</a>
<a name="ln184"> </a>
<a name="ln185">#define LRDT_BILAT_VERSION 1</a>
<a name="ln186">typedef struct dt_iop_bilat_params_t</a>
<a name="ln187">{</a>
<a name="ln188">  float sigma_r;</a>
<a name="ln189">  float sigma_s;</a>
<a name="ln190">  float detail;</a>
<a name="ln191">} dt_iop_bilat_params_t;</a>
<a name="ln192"> </a>
<a name="ln193"> </a>
<a name="ln194">#define LRDT_COLORIN_VERSION 1</a>
<a name="ln195">#define DT_IOP_COLOR_ICC_LEN 100</a>
<a name="ln196"> </a>
<a name="ln197">typedef struct dt_iop_colorin_params_t</a>
<a name="ln198">{</a>
<a name="ln199">  char iccprofile[DT_IOP_COLOR_ICC_LEN];</a>
<a name="ln200">  dt_iop_color_intent_t intent;</a>
<a name="ln201">} dt_iop_colorin_params_t;</a>
<a name="ln202"> </a>
<a name="ln203">//</a>
<a name="ln204">// end of iop structs</a>
<a name="ln205">//</a>
<a name="ln206"> </a>
<a name="ln207">// the blend params for Lr import, not used in this mode (mode=0), as for iop generate the blend params for</a>
<a name="ln208">// the</a>
<a name="ln209">// version specified above.</a>
<a name="ln210"> </a>
<a name="ln211">#define LRDT_BLEND_VERSION 4</a>
<a name="ln212">#define DEVELOP_BLENDIF_SIZE 16</a>
<a name="ln213"> </a>
<a name="ln214">typedef struct dt_develop_blend_params_t</a>
<a name="ln215">{</a>
<a name="ln216">  /** blending mode */</a>
<a name="ln217">  uint32_t mode;</a>
<a name="ln218">  /** mixing opacity */</a>
<a name="ln219">  float opacity;</a>
<a name="ln220">  /** id of mask in current pipeline */</a>
<a name="ln221">  uint32_t mask_id;</a>
<a name="ln222">  /** blendif mask */</a>
<a name="ln223">  uint32_t blendif;</a>
<a name="ln224">  /** blur radius */</a>
<a name="ln225">  float radius;</a>
<a name="ln226">  /** blendif parameters */</a>
<a name="ln227">  float blendif_parameters[4 * DEVELOP_BLENDIF_SIZE];</a>
<a name="ln228">} dt_develop_blend_params_t;</a>
<a name="ln229"> </a>
<a name="ln230">//</a>
<a name="ln231">// end of blend_params</a>
<a name="ln232">//</a>
<a name="ln233"> </a>
<a name="ln234">typedef struct lr2dt</a>
<a name="ln235">{</a>
<a name="ln236">  float lr, dt;</a>
<a name="ln237">} lr2dt_t;</a>
<a name="ln238"> </a>
<a name="ln239">char *dt_get_lightroom_xmp(int imgid)</a>
<a name="ln240">{</a>
<a name="ln241">  char pathname[DT_MAX_FILENAME_LEN];</a>
<a name="ln242">  gboolean from_cache = TRUE;</a>
<a name="ln243"> </a>
<a name="ln244">  // Get full pathname</a>
<a name="ln245">  dt_image_full_path(imgid, pathname, DT_MAX_FILENAME_LEN, &amp;from_cache);</a>
<a name="ln246"> </a>
<a name="ln247">  // Look for extension</a>
<a name="ln248">  char *pos = strrchr(pathname, '.');</a>
<a name="ln249"> </a>
<a name="ln250">  if(pos == NULL)</a>
<a name="ln251">    return NULL;</a>
<a name="ln252"> </a>
<a name="ln253">  // If found, replace extension with xmp</a>
<a name="ln254">  strncpy(pos + 1, &quot;xmp&quot;, 4);</a>
<a name="ln255">  if(g_file_test(pathname, G_FILE_TEST_EXISTS))</a>
<a name="ln256">    return g_strdup(pathname);</a>
<a name="ln257"> </a>
<a name="ln258">  strncpy(pos + 1, &quot;XMP&quot;, 4);</a>
<a name="ln259">  if(g_file_test(pathname, G_FILE_TEST_EXISTS))</a>
<a name="ln260">    return g_strdup(pathname);</a>
<a name="ln261"> </a>
<a name="ln262">  return NULL;</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">static float get_interpolate(lr2dt_t lr2dt_table[], float value)</a>
<a name="ln266">{</a>
<a name="ln267">  int k = 0;</a>
<a name="ln268"> </a>
<a name="ln269">  while(lr2dt_table[k + 1].lr &lt; value) k++;</a>
<a name="ln270"> </a>
<a name="ln271">  return lr2dt_table[k].dt</a>
<a name="ln272">         + ((value - lr2dt_table[k].lr) / (lr2dt_table[k + 1].lr - lr2dt_table[k].lr))</a>
<a name="ln273">           * (lr2dt_table[k + 1].dt - lr2dt_table[k].dt);</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">static float lr2dt_blacks(float value)</a>
<a name="ln277">{</a>
<a name="ln278">  lr2dt_t lr2dt_blacks_table[]</a>
<a name="ln279">      = { { -100, 0.020 }, { -50, 0.005 }, { 0, 0 }, { 50, -0.005 }, { 100, -0.010 } };</a>
<a name="ln280"> </a>
<a name="ln281">  return get_interpolate(lr2dt_blacks_table, value);</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">static float lr2dt_vignette_gain(float value)</a>
<a name="ln285">{</a>
<a name="ln286">  lr2dt_t lr2dt_vignette_table[] = { { -100, -1 }, { -50, -0.7 }, { 0, 0 }, { 50, 0.5 }, { 100, 1 } };</a>
<a name="ln287"> </a>
<a name="ln288">  return get_interpolate(lr2dt_vignette_table, value);</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291">static float lr2dt_vignette_midpoint(float value)</a>
<a name="ln292">{</a>
<a name="ln293">  lr2dt_t lr2dt_vignette_table[] = { { 0, 74 }, { 4, 75 }, { 25, 85 }, { 50, 100 }, { 100, 100 } };</a>
<a name="ln294"> </a>
<a name="ln295">  return get_interpolate(lr2dt_vignette_table, value);</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">static float lr2dt_grain_amount(float value)</a>
<a name="ln299">{</a>
<a name="ln300">  lr2dt_t lr2dt_grain_table[] = { { 0, 0 }, { 25, 20 }, { 50, 40 }, { 100, 80 } };</a>
<a name="ln301"> </a>
<a name="ln302">  return get_interpolate(lr2dt_grain_table, value);</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">static float lr2dt_grain_frequency(float value)</a>
<a name="ln306">{</a>
<a name="ln307">  lr2dt_t lr2dt_grain_table[] = { { 0, 100 }, { 50, 100 }, { 75, 400 }, { 100, 800 } };</a>
<a name="ln308"> </a>
<a name="ln309">  return get_interpolate(lr2dt_grain_table, value) / 53.3;</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312">static float lr2dt_splittoning_balance(float value)</a>
<a name="ln313">{</a>
<a name="ln314">  lr2dt_t lr2dt_splittoning_table[] = { { -100, 100 }, { 0, 0 }, { 100, 0 } };</a>
<a name="ln315"> </a>
<a name="ln316">  return get_interpolate(lr2dt_splittoning_table, value);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">static float lr2dt_clarity(float value)</a>
<a name="ln320">{</a>
<a name="ln321">  lr2dt_t lr2dt_clarity_table[] = { { -100, -.650 }, { 0, 0 }, { 100, .650 } };</a>
<a name="ln322"> </a>
<a name="ln323">  return get_interpolate(lr2dt_clarity_table, value);</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">static void dt_add_hist(int imgid, char *operation, dt_iop_params_t *params, int params_size, char *imported,</a>
<a name="ln327">                        size_t imported_len, int version, int *import_count, const double iop_order)</a>
<a name="ln328">{</a>
<a name="ln329">  int32_t num = 0;</a>
<a name="ln330">  dt_develop_blend_params_t blend_params = { 0 };</a>
<a name="ln331"> </a>
<a name="ln332">  //  get current num if any</a>
<a name="ln333">  sqlite3_stmt *stmt;</a>
<a name="ln334">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln335">                              &quot;SELECT COUNT(*) FROM main.history WHERE imgid = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln336">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln337">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln338">  {</a>
<a name="ln339">    num = sqlite3_column_int(stmt, 0);</a>
<a name="ln340">  }</a>
<a name="ln341">  sqlite3_finalize(stmt);</a>
<a name="ln342"> </a>
<a name="ln343">  // add new history info</a>
<a name="ln344">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln345">                              &quot;INSERT INTO main.history (imgid, num, module, operation, op_params, enabled, &quot;</a>
<a name="ln346">                              &quot;blendop_params, blendop_version, multi_priority, multi_name, iop_order) &quot;</a>
<a name="ln347">                              &quot;VALUES (?1, ?2, ?3, ?4, ?5, 1, ?6, ?7, 0, ' ', ?8)&quot;,</a>
<a name="ln348">                              -1, &amp;stmt, NULL);</a>
<a name="ln349">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln350">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, num);</a>
<a name="ln351">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, version);</a>
<a name="ln352">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, operation, -1, SQLITE_TRANSIENT);</a>
<a name="ln353">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 5, params, params_size, SQLITE_TRANSIENT);</a>
<a name="ln354">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 6, &amp;blend_params, sizeof(dt_develop_blend_params_t), SQLITE_TRANSIENT);</a>
<a name="ln355">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 7, LRDT_BLEND_VERSION);</a>
<a name="ln356">  DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 8, iop_order);</a>
<a name="ln357"> </a>
<a name="ln358">  sqlite3_step(stmt);</a>
<a name="ln359">  sqlite3_finalize(stmt);</a>
<a name="ln360"> </a>
<a name="ln361">  // also bump history_end</a>
<a name="ln362">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln363">                              &quot;UPDATE main.images SET history_end = (SELECT IFNULL(MAX(num) + 1, 0) FROM &quot;</a>
<a name="ln364">                              &quot;main.history WHERE imgid = ?1) WHERE id = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln365">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln366">  sqlite3_step(stmt);</a>
<a name="ln367">  sqlite3_finalize(stmt);</a>
<a name="ln368"> </a>
<a name="ln369">  if(imported[0]) g_strlcat(imported, &quot;, &quot;, imported_len);</a>
<a name="ln370">  g_strlcat(imported, dt_iop_get_localized_name(operation), imported_len);</a>
<a name="ln371">  (*import_count)++;</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">#define MAX_PTS 20</a>
<a name="ln375"> </a>
<a name="ln376">typedef enum lr_curve_kind_t</a>
<a name="ln377">{</a>
<a name="ln378">  linear = 0,</a>
<a name="ln379">  medium_contrast = 1,</a>
<a name="ln380">  strong_contrast = 2,</a>
<a name="ln381">  custom = 3</a>
<a name="ln382">} lr_curve_kind_t;</a>
<a name="ln383"> </a>
<a name="ln384">typedef struct lr_data_t</a>
<a name="ln385">{</a>
<a name="ln386">  dt_iop_clipping_params_t pc;</a>
<a name="ln387">  gboolean has_crop;</a>
<a name="ln388"> </a>
<a name="ln389">  dt_iop_flip_params_t pf;</a>
<a name="ln390">  gboolean has_flip;</a>
<a name="ln391"> </a>
<a name="ln392">  dt_iop_exposure_params_t pe;</a>
<a name="ln393">  gboolean has_exposure;</a>
<a name="ln394"> </a>
<a name="ln395">  dt_iop_vignette_params_t pv;</a>
<a name="ln396">  gboolean has_vignette;</a>
<a name="ln397"> </a>
<a name="ln398">  dt_iop_grain_params_t pg;</a>
<a name="ln399">  gboolean has_grain;</a>
<a name="ln400"> </a>
<a name="ln401">  dt_iop_spots_params_t ps;</a>
<a name="ln402">  gboolean has_spots;</a>
<a name="ln403"> </a>
<a name="ln404">  dt_iop_tonecurve_params_t ptc;</a>
<a name="ln405">  int ptc_value[4];</a>
<a name="ln406">  float ptc_split[3];</a>
<a name="ln407">  lr_curve_kind_t curve_kind;</a>
<a name="ln408">  int curve_pts[MAX_PTS][2];</a>
<a name="ln409">  int n_pts;</a>
<a name="ln410"> </a>
<a name="ln411">  dt_iop_colorzones_params_t pcz;</a>
<a name="ln412">  gboolean has_colorzones;</a>
<a name="ln413"> </a>
<a name="ln414">  dt_iop_splittoning_params_t pst;</a>
<a name="ln415">  gboolean has_splittoning;</a>
<a name="ln416"> </a>
<a name="ln417">  dt_iop_bilat_params_t pbl;</a>
<a name="ln418">  gboolean has_bilat;</a>
<a name="ln419"> </a>
<a name="ln420">  gboolean has_tags;</a>
<a name="ln421"> </a>
<a name="ln422">  int rating;</a>
<a name="ln423">  gboolean has_rating;</a>
<a name="ln424"> </a>
<a name="ln425">  gdouble lat, lon;</a>
<a name="ln426">  gboolean has_gps;</a>
<a name="ln427"> </a>
<a name="ln428">  int color;</a>
<a name="ln429">  gboolean has_colorlabel;</a>
<a name="ln430"> </a>
<a name="ln431">  float fratio;                // factor ratio image</a>
<a name="ln432">  float crop_roundness;        // from lightroom</a>
<a name="ln433">  int iwidth, iheight;         // image width / height</a>
<a name="ln434">  int orientation;</a>
<a name="ln435">} lr_data_t;</a>
<a name="ln436"> </a>
<a name="ln437">// three helper functions for parsing RetouchInfo entries. sscanf doesn't work due to floats.</a>
<a name="ln438">static gboolean _read_float(const char **startptr, const char *key, float *value)</a>
<a name="ln439">{</a>
<a name="ln440">  const char *iter = *startptr;</a>
<a name="ln441">  while(*iter == ' ') iter++;</a>
<a name="ln442">  if(!g_str_has_prefix(iter, key))</a>
<a name="ln443">    return FALSE;</a>
<a name="ln444">  iter += strlen(key);</a>
<a name="ln445">  while(*iter == ' ') iter++;</a>
<a name="ln446">  if(*iter++ != '=')</a>
<a name="ln447">    return FALSE;</a>
<a name="ln448">  while(*iter == ' ') iter++;</a>
<a name="ln449">  *value = g_ascii_strtod(iter, (char **)startptr);</a>
<a name="ln450">  return iter != *startptr;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">static gboolean _skip_key_value_pair(const char **startptr, const char *key)</a>
<a name="ln454">{</a>
<a name="ln455">  const char *iter = *startptr;</a>
<a name="ln456">  while(*iter == ' ') iter++;</a>
<a name="ln457">  if(!g_str_has_prefix(iter, key))</a>
<a name="ln458">    return FALSE;</a>
<a name="ln459">  iter += strlen(key);</a>
<a name="ln460">  while(*iter == ' ') iter++;</a>
<a name="ln461">  if(*iter++ != '=')</a>
<a name="ln462">    return FALSE;</a>
<a name="ln463">  while(*iter == ' ') iter++;</a>
<a name="ln464">  while((*iter &gt;= 'a' &amp;&amp; *iter &lt;= 'z') || (*iter &gt;= 'A' &amp;&amp; *iter &lt;= 'Z')) iter++;</a>
<a name="ln465">  *startptr = iter;</a>
<a name="ln466">  return TRUE;</a>
<a name="ln467">}</a>
<a name="ln468"> </a>
<a name="ln469">static gboolean _skip_comma(const char **startptr)</a>
<a name="ln470">{</a>
<a name="ln471">  return *(*startptr)++ == ',';</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">/* lrop handle the Lr operation and convert it as a dt iop */</a>
<a name="ln475">static void _lrop(const dt_develop_t *dev, const xmlDocPtr doc, const int imgid,</a>
<a name="ln476">                  const xmlChar *name, const xmlChar *value, const xmlNodePtr node, lr_data_t *data)</a>
<a name="ln477">{</a>
<a name="ln478">  const float hfactor = 3.0 / 9.0; // hue factor adjustment (use 3 out of 9 boxes in colorzones)</a>
<a name="ln479">  const float lfactor = 4.0 / 9.0; // lightness factor adjustment (use 4 out of 9 boxes in colorzones)</a>
<a name="ln480"> </a>
<a name="ln481">  if(value)</a>
<a name="ln482">  {</a>
<a name="ln483">    if(!xmlStrcmp(name, (const xmlChar *)&quot;CropTop&quot;))</a>
<a name="ln484">      data-&gt;pc.cy = g_ascii_strtod((char *)value, NULL);</a>
<a name="ln485">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;CropRight&quot;))</a>
<a name="ln486">      data-&gt;pc.cw = g_ascii_strtod((char *)value, NULL);</a>
<a name="ln487">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;CropLeft&quot;))</a>
<a name="ln488">      data-&gt;pc.cx = g_ascii_strtod((char *)value, NULL);</a>
<a name="ln489">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;CropBottom&quot;))</a>
<a name="ln490">      data-&gt;pc.ch = g_ascii_strtod((char *)value, NULL);</a>
<a name="ln491">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;CropAngle&quot;))</a>
<a name="ln492">      data-&gt;pc.angle = -g_ascii_strtod((char *)value, NULL);</a>
<a name="ln493">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ImageWidth&quot;))</a>
<a name="ln494">      data-&gt;iwidth = atoi((char *)value);</a>
<a name="ln495">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ImageLength&quot;))</a>
<a name="ln496">      data-&gt;iheight = atoi((char *)value);</a>
<a name="ln497">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;Orientation&quot;))</a>
<a name="ln498">    {</a>
<a name="ln499">      data-&gt;orientation = atoi((char *)value);</a>
<a name="ln500">      if(dev != NULL &amp;&amp; ((dev-&gt;image_storage.orientation == 6 &amp;&amp; data-&gt;orientation != 6)</a>
<a name="ln501">                        || (dev-&gt;image_storage.orientation == 5 &amp;&amp; data-&gt;orientation != 8)</a>
<a name="ln502">                        || (dev-&gt;image_storage.orientation == 0 &amp;&amp; data-&gt;orientation != 1)))</a>
<a name="ln503">        data-&gt;has_flip = TRUE;</a>
<a name="ln504">    }</a>
<a name="ln505">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HasCrop&quot;))</a>
<a name="ln506">    {</a>
<a name="ln507">      if(!xmlStrcmp(value, (const xmlChar *)&quot;True&quot;)) data-&gt;has_crop = TRUE;</a>
<a name="ln508">    }</a>
<a name="ln509">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;Blacks2012&quot;))</a>
<a name="ln510">    {</a>
<a name="ln511">      int v = atoi((char *)value);</a>
<a name="ln512">      if(v != 0)</a>
<a name="ln513">      {</a>
<a name="ln514">        data-&gt;has_exposure = TRUE;</a>
<a name="ln515">        data-&gt;pe.black = lr2dt_blacks((float)v);</a>
<a name="ln516">      }</a>
<a name="ln517">    }</a>
<a name="ln518">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;Exposure2012&quot;))</a>
<a name="ln519">    {</a>
<a name="ln520">      float v = g_ascii_strtod((char *)value, NULL);</a>
<a name="ln521">      if(v != 0.0)</a>
<a name="ln522">      {</a>
<a name="ln523">        data-&gt;has_exposure = TRUE;</a>
<a name="ln524">        data-&gt;pe.exposure = v;</a>
<a name="ln525">      }</a>
<a name="ln526">    }</a>
<a name="ln527">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;PostCropVignetteAmount&quot;))</a>
<a name="ln528">    {</a>
<a name="ln529">      int v = atoi((char *)value);</a>
<a name="ln530">      if(v != 0)</a>
<a name="ln531">      {</a>
<a name="ln532">        data-&gt;has_vignette = TRUE;</a>
<a name="ln533">        data-&gt;pv.brightness = lr2dt_vignette_gain((float)v);</a>
<a name="ln534">      }</a>
<a name="ln535">    }</a>
<a name="ln536">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;PostCropVignetteMidpoint&quot;))</a>
<a name="ln537">    {</a>
<a name="ln538">      int v = atoi((char *)value);</a>
<a name="ln539">      data-&gt;pv.scale = lr2dt_vignette_midpoint((float)v);</a>
<a name="ln540">    }</a>
<a name="ln541">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;PostCropVignetteStyle&quot;))</a>
<a name="ln542">    {</a>
<a name="ln543">      int v = atoi((char *)value);</a>
<a name="ln544">      if(v == 1) // Highlight Priority</a>
<a name="ln545">        data-&gt;pv.saturation = -0.300;</a>
<a name="ln546">      else // Color Priority &amp; Paint Overlay</a>
<a name="ln547">        data-&gt;pv.saturation = -0.200;</a>
<a name="ln548">    }</a>
<a name="ln549">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;PostCropVignetteFeather&quot;))</a>
<a name="ln550">    {</a>
<a name="ln551">      int v = atoi((char *)value);</a>
<a name="ln552">      if(v != 0) data-&gt;pv.falloff_scale = (float)v;</a>
<a name="ln553">    }</a>
<a name="ln554">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;PostCropVignetteRoundness&quot;))</a>
<a name="ln555">    {</a>
<a name="ln556">      int v = atoi((char *)value);</a>
<a name="ln557">      data-&gt;crop_roundness = (float)v;</a>
<a name="ln558">    }</a>
<a name="ln559">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;GrainAmount&quot;))</a>
<a name="ln560">    {</a>
<a name="ln561">      int v = atoi((char *)value);</a>
<a name="ln562">      if(v != 0)</a>
<a name="ln563">      {</a>
<a name="ln564">        data-&gt;has_grain = TRUE;</a>
<a name="ln565">        data-&gt;pg.strength = lr2dt_grain_amount((float)v);</a>
<a name="ln566">      }</a>
<a name="ln567">    }</a>
<a name="ln568">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;GrainFrequency&quot;))</a>
<a name="ln569">    {</a>
<a name="ln570">      int v = atoi((char *)value);</a>
<a name="ln571">      if(v != 0) data-&gt;pg.scale = lr2dt_grain_frequency((float)v);</a>
<a name="ln572">    }</a>
<a name="ln573">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricShadows&quot;))</a>
<a name="ln574">    {</a>
<a name="ln575">      data-&gt;ptc_value[0] = atoi((char *)value);</a>
<a name="ln576">    }</a>
<a name="ln577">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricDarks&quot;))</a>
<a name="ln578">    {</a>
<a name="ln579">      data-&gt;ptc_value[1] = atoi((char *)value);</a>
<a name="ln580">    }</a>
<a name="ln581">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricLights&quot;))</a>
<a name="ln582">    {</a>
<a name="ln583">      data-&gt;ptc_value[2] = atoi((char *)value);</a>
<a name="ln584">    }</a>
<a name="ln585">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricHighlights&quot;))</a>
<a name="ln586">    {</a>
<a name="ln587">      data-&gt;ptc_value[3] = atoi((char *)value);</a>
<a name="ln588">    }</a>
<a name="ln589">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricShadowSplit&quot;))</a>
<a name="ln590">    {</a>
<a name="ln591">      data-&gt;ptc_split[0] = g_ascii_strtod((char *)value, NULL) / 100.0;</a>
<a name="ln592">    }</a>
<a name="ln593">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricMidtoneSplit&quot;))</a>
<a name="ln594">    {</a>
<a name="ln595">      data-&gt;ptc_split[1] = g_ascii_strtod((char *)value, NULL) / 100.0;</a>
<a name="ln596">    }</a>
<a name="ln597">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricHighlightSplit&quot;))</a>
<a name="ln598">    {</a>
<a name="ln599">      data-&gt;ptc_split[2] = g_ascii_strtod((char *)value, NULL) / 100.0;</a>
<a name="ln600">    }</a>
<a name="ln601">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ToneCurveName2012&quot;))</a>
<a name="ln602">    {</a>
<a name="ln603">      if(!xmlStrcmp(value, (const xmlChar *)&quot;Linear&quot;))</a>
<a name="ln604">        data-&gt;curve_kind = linear;</a>
<a name="ln605">      else if(!xmlStrcmp(value, (const xmlChar *)&quot;Medium Contrast&quot;))</a>
<a name="ln606">        data-&gt;curve_kind = medium_contrast;</a>
<a name="ln607">      else if(!xmlStrcmp(value, (const xmlChar *)&quot;Strong Contrast&quot;))</a>
<a name="ln608">        data-&gt;curve_kind = strong_contrast;</a>
<a name="ln609">      else if(!xmlStrcmp(value, (const xmlChar *)&quot;Custom&quot;))</a>
<a name="ln610">        data-&gt;curve_kind = custom;</a>
<a name="ln611">    }</a>
<a name="ln612">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentRed&quot;))</a>
<a name="ln613">    {</a>
<a name="ln614">      int v = atoi((char *)value);</a>
<a name="ln615">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln616">      data-&gt;pcz.equalizer_y[1][0] = 0.5 + (float)v / 200.0;</a>
<a name="ln617">    }</a>
<a name="ln618">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentOrange&quot;))</a>
<a name="ln619">    {</a>
<a name="ln620">      int v = atoi((char *)value);</a>
<a name="ln621">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln622">      data-&gt;pcz.equalizer_y[1][1] = 0.5 + (float)v / 200.0;</a>
<a name="ln623">    }</a>
<a name="ln624">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentYellow&quot;))</a>
<a name="ln625">    {</a>
<a name="ln626">      int v = atoi((char *)value);</a>
<a name="ln627">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln628">      data-&gt;pcz.equalizer_y[1][2] = 0.5 + (float)v / 200.0;</a>
<a name="ln629">    }</a>
<a name="ln630">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentGreen&quot;))</a>
<a name="ln631">    {</a>
<a name="ln632">      int v = atoi((char *)value);</a>
<a name="ln633">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln634">      data-&gt;pcz.equalizer_y[1][3] = 0.5 + (float)v / 200.0;</a>
<a name="ln635">    }</a>
<a name="ln636">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentAqua&quot;))</a>
<a name="ln637">    {</a>
<a name="ln638">      int v = atoi((char *)value);</a>
<a name="ln639">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln640">      data-&gt;pcz.equalizer_y[1][4] = 0.5 + (float)v / 200.0;</a>
<a name="ln641">    }</a>
<a name="ln642">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentBlue&quot;))</a>
<a name="ln643">    {</a>
<a name="ln644">      int v = atoi((char *)value);</a>
<a name="ln645">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln646">      data-&gt;pcz.equalizer_y[1][5] = 0.5 + (float)v / 200.0;</a>
<a name="ln647">    }</a>
<a name="ln648">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentPurple&quot;))</a>
<a name="ln649">    {</a>
<a name="ln650">      int v = atoi((char *)value);</a>
<a name="ln651">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln652">      data-&gt;pcz.equalizer_y[1][6] = 0.5 + (float)v / 200.0;</a>
<a name="ln653">    }</a>
<a name="ln654">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentMagenta&quot;))</a>
<a name="ln655">    {</a>
<a name="ln656">      int v = atoi((char *)value);</a>
<a name="ln657">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln658">      data-&gt;pcz.equalizer_y[1][7] = 0.5 + (float)v / 200.0;</a>
<a name="ln659">    }</a>
<a name="ln660">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentRed&quot;))</a>
<a name="ln661">    {</a>
<a name="ln662">      int v = atoi((char *)value);</a>
<a name="ln663">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln664">      data-&gt;pcz.equalizer_y[0][0] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln665">    }</a>
<a name="ln666">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentOrange&quot;))</a>
<a name="ln667">    {</a>
<a name="ln668">      int v = atoi((char *)value);</a>
<a name="ln669">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln670">      data-&gt;pcz.equalizer_y[0][1] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln671">    }</a>
<a name="ln672">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentYellow&quot;))</a>
<a name="ln673">    {</a>
<a name="ln674">      int v = atoi((char *)value);</a>
<a name="ln675">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln676">      data-&gt;pcz.equalizer_y[0][2] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln677">    }</a>
<a name="ln678">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentGreen&quot;))</a>
<a name="ln679">    {</a>
<a name="ln680">      int v = atoi((char *)value);</a>
<a name="ln681">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln682">      data-&gt;pcz.equalizer_y[0][3] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln683">    }</a>
<a name="ln684">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentAqua&quot;))</a>
<a name="ln685">    {</a>
<a name="ln686">      int v = atoi((char *)value);</a>
<a name="ln687">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln688">      data-&gt;pcz.equalizer_y[0][4] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln689">    }</a>
<a name="ln690">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentBlue&quot;))</a>
<a name="ln691">    {</a>
<a name="ln692">      int v = atoi((char *)value);</a>
<a name="ln693">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln694">      data-&gt;pcz.equalizer_y[0][5] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln695">    }</a>
<a name="ln696">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentPurple&quot;))</a>
<a name="ln697">    {</a>
<a name="ln698">      int v = atoi((char *)value);</a>
<a name="ln699">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln700">      data-&gt;pcz.equalizer_y[0][6] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln701">    }</a>
<a name="ln702">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentMagenta&quot;))</a>
<a name="ln703">    {</a>
<a name="ln704">      int v = atoi((char *)value);</a>
<a name="ln705">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln706">      data-&gt;pcz.equalizer_y[0][7] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln707">    }</a>
<a name="ln708">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentRed&quot;))</a>
<a name="ln709">    {</a>
<a name="ln710">      int v = atoi((char *)value);</a>
<a name="ln711">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln712">      data-&gt;pcz.equalizer_y[2][0] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln713">    }</a>
<a name="ln714">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentOrange&quot;))</a>
<a name="ln715">    {</a>
<a name="ln716">      int v = atoi((char *)value);</a>
<a name="ln717">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln718">      data-&gt;pcz.equalizer_y[2][1] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln719">    }</a>
<a name="ln720">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentYellow&quot;))</a>
<a name="ln721">    {</a>
<a name="ln722">      int v = atoi((char *)value);</a>
<a name="ln723">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln724">      data-&gt;pcz.equalizer_y[2][2] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln725">    }</a>
<a name="ln726">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentGreen&quot;))</a>
<a name="ln727">    {</a>
<a name="ln728">      int v = atoi((char *)value);</a>
<a name="ln729">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln730">      data-&gt;pcz.equalizer_y[2][3] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln731">    }</a>
<a name="ln732">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentAqua&quot;))</a>
<a name="ln733">    {</a>
<a name="ln734">      int v = atoi((char *)value);</a>
<a name="ln735">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln736">      data-&gt;pcz.equalizer_y[2][4] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln737">    }</a>
<a name="ln738">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentBlue&quot;))</a>
<a name="ln739">    {</a>
<a name="ln740">      int v = atoi((char *)value);</a>
<a name="ln741">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln742">      data-&gt;pcz.equalizer_y[2][5] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln743">    }</a>
<a name="ln744">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentPurple&quot;))</a>
<a name="ln745">    {</a>
<a name="ln746">      int v = atoi((char *)value);</a>
<a name="ln747">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln748">      data-&gt;pcz.equalizer_y[2][6] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln749">    }</a>
<a name="ln750">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentMagenta&quot;))</a>
<a name="ln751">    {</a>
<a name="ln752">      int v = atoi((char *)value);</a>
<a name="ln753">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln754">      data-&gt;pcz.equalizer_y[2][7] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln755">    }</a>
<a name="ln756">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SplitToningShadowHue&quot;))</a>
<a name="ln757">    {</a>
<a name="ln758">      int v = atoi((char *)value);</a>
<a name="ln759">      if(v != 0) data-&gt;has_splittoning = TRUE;</a>
<a name="ln760">      data-&gt;pst.shadow_hue = (float)v / 255.0;</a>
<a name="ln761">    }</a>
<a name="ln762">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SplitToningShadowSaturation&quot;))</a>
<a name="ln763">    {</a>
<a name="ln764">      int v = atoi((char *)value);</a>
<a name="ln765">      if(v != 0) data-&gt;has_splittoning = TRUE;</a>
<a name="ln766">      data-&gt;pst.shadow_saturation = (float)v / 100.0;</a>
<a name="ln767">    }</a>
<a name="ln768">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SplitToningHighlightHue&quot;))</a>
<a name="ln769">    {</a>
<a name="ln770">      int v = atoi((char *)value);</a>
<a name="ln771">      if(v != 0) data-&gt;has_splittoning = TRUE;</a>
<a name="ln772">      data-&gt;pst.highlight_hue = (float)v / 255.0;</a>
<a name="ln773">    }</a>
<a name="ln774">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SplitToningHighlightSaturation&quot;))</a>
<a name="ln775">    {</a>
<a name="ln776">      int v = atoi((char *)value);</a>
<a name="ln777">      if(v != 0) data-&gt;has_splittoning = TRUE;</a>
<a name="ln778">      data-&gt;pst.highlight_saturation = (float)v / 100.0;</a>
<a name="ln779">    }</a>
<a name="ln780">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SplitToningBalance&quot;))</a>
<a name="ln781">    {</a>
<a name="ln782">      float v = g_ascii_strtod((char *)value, NULL);</a>
<a name="ln783">      data-&gt;pst.balance = lr2dt_splittoning_balance(v);</a>
<a name="ln784">    }</a>
<a name="ln785">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;Clarity2012&quot;))</a>
<a name="ln786">    {</a>
<a name="ln787">      int v = atoi((char *)value);</a>
<a name="ln788">      if(v != 0)</a>
<a name="ln789">      {</a>
<a name="ln790">        data-&gt;has_bilat = TRUE;</a>
<a name="ln791">        data-&gt;pbl.detail = lr2dt_clarity((float)v);</a>
<a name="ln792">      }</a>
<a name="ln793">    }</a>
<a name="ln794">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;Rating&quot;))</a>
<a name="ln795">    {</a>
<a name="ln796">      int v = atoi((char *)value);</a>
<a name="ln797">      if(v != 0)</a>
<a name="ln798">      {</a>
<a name="ln799">        data-&gt;rating = v;</a>
<a name="ln800">        data-&gt;has_rating = TRUE;</a>
<a name="ln801">      }</a>
<a name="ln802">    }</a>
<a name="ln803">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;GPSLatitude&quot;))</a>
<a name="ln804">    {</a>
<a name="ln805">      double latitude = dt_util_gps_string_to_number((const char *)value);</a>
<a name="ln806">      if(!isnan(latitude))</a>
<a name="ln807">      {</a>
<a name="ln808">        data-&gt;lat = latitude;</a>
<a name="ln809">        data-&gt;has_gps = TRUE;</a>
<a name="ln810">      }</a>
<a name="ln811">    }</a>
<a name="ln812">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;GPSLongitude&quot;))</a>
<a name="ln813">    {</a>
<a name="ln814">      double longitude = dt_util_gps_string_to_number((const char *)value);</a>
<a name="ln815">      if(!isnan(longitude))</a>
<a name="ln816">      {</a>
<a name="ln817">        data-&gt;lon = longitude;</a>
<a name="ln818">        data-&gt;has_gps = TRUE;</a>
<a name="ln819">      }</a>
<a name="ln820">    }</a>
<a name="ln821">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;Label&quot;))</a>
<a name="ln822">    {</a>
<a name="ln823">      char *v = g_utf8_casefold((char *)value, -1);</a>
<a name="ln824">      if(!g_strcmp0(v, _(&quot;red&quot;)))</a>
<a name="ln825">        data-&gt;color = 0;</a>
<a name="ln826">      else if(!g_strcmp0(v, _(&quot;yellow&quot;)))</a>
<a name="ln827">        data-&gt;color = 1;</a>
<a name="ln828">      else if(!g_strcmp0(v, _(&quot;green&quot;)))</a>
<a name="ln829">        data-&gt;color = 2;</a>
<a name="ln830">      else if(!g_strcmp0(v, _(&quot;blue&quot;)))</a>
<a name="ln831">        data-&gt;color = 3;</a>
<a name="ln832">      else</a>
<a name="ln833">        // just an else here to catch all other cases as on lightroom one can</a>
<a name="ln834">        // change the names of labels. So purple and the user's defined labels</a>
<a name="ln835">        // will be mapped to purple on darktable.</a>
<a name="ln836">        data-&gt;color = 4;</a>
<a name="ln837"> </a>
<a name="ln838">      data-&gt;has_colorlabel = TRUE;</a>
<a name="ln839">      g_free(v);</a>
<a name="ln840">    }</a>
<a name="ln841">  }</a>
<a name="ln842">  if(dev == NULL &amp;&amp; (!xmlStrcmp(name, (const xmlChar *)&quot;subject&quot;)</a>
<a name="ln843">                     || !xmlStrcmp(name, (const xmlChar *)&quot;hierarchicalSubject&quot;)))</a>
<a name="ln844">  {</a>
<a name="ln845">    xmlNodePtr tagNode = node;</a>
<a name="ln846"> </a>
<a name="ln847">    while(tagNode)</a>
<a name="ln848">    {</a>
<a name="ln849">      if(!xmlStrcmp(tagNode-&gt;name, (const xmlChar *)&quot;li&quot;))</a>
<a name="ln850">      {</a>
<a name="ln851">        xmlChar *cvalue = xmlNodeListGetString(doc, tagNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln852">        guint tagid = 0;</a>
<a name="ln853">        if(!dt_tag_exists((char *)cvalue, &amp;tagid)) dt_tag_new((char *)cvalue, &amp;tagid);</a>
<a name="ln854"> </a>
<a name="ln855">        dt_tag_attach(tagid, imgid);</a>
<a name="ln856">        data-&gt;has_tags = TRUE;</a>
<a name="ln857">        xmlFree(cvalue);</a>
<a name="ln858">      }</a>
<a name="ln859">      tagNode = tagNode-&gt;next;</a>
<a name="ln860">    }</a>
<a name="ln861">  }</a>
<a name="ln862">  else if(dev != NULL &amp;&amp; !xmlStrcmp(name, (const xmlChar *)&quot;RetouchInfo&quot;))</a>
<a name="ln863">  {</a>
<a name="ln864">    xmlNodePtr riNode = node;</a>
<a name="ln865"> </a>
<a name="ln866">    while(riNode)</a>
<a name="ln867">    {</a>
<a name="ln868">      if(!xmlStrcmp(riNode-&gt;name, (const xmlChar *)&quot;li&quot;))</a>
<a name="ln869">      {</a>
<a name="ln870">        xmlChar *cvalue = xmlNodeListGetString(doc, riNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln871">        spot_t *p = &amp;data-&gt;ps.spot[data-&gt;ps.num_spots];</a>
<a name="ln872">        float x, y, radius, xc, yc;</a>
<a name="ln873">        const char *startptr = (const char *)cvalue;</a>
<a name="ln874">        if(_read_float(&amp;startptr, &quot;centerX&quot;, &amp;x) &amp;&amp;</a>
<a name="ln875">           _skip_comma(&amp;startptr) &amp;&amp;</a>
<a name="ln876">           _read_float(&amp;startptr, &quot;centerY&quot;, &amp;y) &amp;&amp;</a>
<a name="ln877">           _skip_comma(&amp;startptr) &amp;&amp;</a>
<a name="ln878">           _read_float(&amp;startptr, &quot;radius&quot;, &amp;radius) &amp;&amp;</a>
<a name="ln879">           _skip_comma(&amp;startptr) &amp;&amp;</a>
<a name="ln880">           _skip_key_value_pair(&amp;startptr, &quot;sourceState&quot;) &amp;&amp;</a>
<a name="ln881">           _skip_comma(&amp;startptr) &amp;&amp;</a>
<a name="ln882">           _read_float(&amp;startptr, &quot;sourceX&quot;, &amp;xc) &amp;&amp;</a>
<a name="ln883">           _skip_comma(&amp;startptr) &amp;&amp;</a>
<a name="ln884">           _read_float(&amp;startptr, &quot;sourceY&quot;, &amp;yc))</a>
<a name="ln885">        {</a>
<a name="ln886">          p-&gt;x = x;</a>
<a name="ln887">          p-&gt;y = y;</a>
<a name="ln888">          p-&gt;radius = radius;</a>
<a name="ln889">          p-&gt;xc = xc;</a>
<a name="ln890">          p-&gt;yc = yc;</a>
<a name="ln891">          data-&gt;ps.num_spots++;</a>
<a name="ln892">          data-&gt;has_spots = TRUE;</a>
<a name="ln893">        }</a>
<a name="ln894">        xmlFree(cvalue);</a>
<a name="ln895">      }</a>
<a name="ln896">      if(data-&gt;ps.num_spots == MAX_SPOTS) break;</a>
<a name="ln897">      riNode = riNode-&gt;next;</a>
<a name="ln898">    }</a>
<a name="ln899">  }</a>
<a name="ln900">  else if(dev != NULL &amp;&amp; !xmlStrcmp(name, (const xmlChar *)&quot;ToneCurvePV2012&quot;))</a>
<a name="ln901">  {</a>
<a name="ln902">    xmlNodePtr tcNode = node;</a>
<a name="ln903"> </a>
<a name="ln904">    while(tcNode)</a>
<a name="ln905">    {</a>
<a name="ln906">      if(!xmlStrcmp(tcNode-&gt;name, (const xmlChar *)&quot;li&quot;))</a>
<a name="ln907">      {</a>
<a name="ln908">        xmlChar *cvalue = xmlNodeListGetString(doc, tcNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln909"> </a>
<a name="ln910">        if(sscanf((const char *)cvalue, &quot;%d, %d&quot;,</a>
<a name="ln911">                  &amp;(data-&gt;curve_pts[data-&gt;n_pts][0]), &amp;(data-&gt;curve_pts[data-&gt;n_pts][1]))) data-&gt;n_pts++;</a>
<a name="ln912">        xmlFree(cvalue);</a>
<a name="ln913">      }</a>
<a name="ln914">      if(data-&gt;n_pts == MAX_PTS) break;</a>
<a name="ln915">      tcNode = tcNode-&gt;next;</a>
<a name="ln916">    }</a>
<a name="ln917">  }</a>
<a name="ln918">  else if(dev == NULL &amp;&amp; !xmlStrcmp(name, (const xmlChar *)&quot;title&quot;))</a>
<a name="ln919">  {</a>
<a name="ln920">    xmlNodePtr ttlNode = node;</a>
<a name="ln921">    while(ttlNode)</a>
<a name="ln922">    {</a>
<a name="ln923">      if(!xmlStrncmp(ttlNode-&gt;name, (const xmlChar *)&quot;li&quot;, 2))</a>
<a name="ln924">      {</a>
<a name="ln925">        xmlChar *cvalue = xmlNodeListGetString(doc, ttlNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln926">        dt_metadata_set(imgid, &quot;Xmp.dc.title&quot;, (char *)cvalue);</a>
<a name="ln927">        xmlFree(cvalue);</a>
<a name="ln928">      }</a>
<a name="ln929">      ttlNode = ttlNode-&gt;next;</a>
<a name="ln930">    }</a>
<a name="ln931">  }</a>
<a name="ln932">  else if(dev == NULL &amp;&amp; !xmlStrcmp(name, (const xmlChar *)&quot;description&quot;))</a>
<a name="ln933">  {</a>
<a name="ln934">    xmlNodePtr desNode = node;</a>
<a name="ln935">    while(desNode)</a>
<a name="ln936">    {</a>
<a name="ln937">      if(!xmlStrncmp(desNode-&gt;name, (const xmlChar *)&quot;li&quot;, 2))</a>
<a name="ln938">      {</a>
<a name="ln939">        xmlChar *cvalue = xmlNodeListGetString(doc, desNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln940">        dt_metadata_set(imgid, &quot;Xmp.dc.description&quot;, (char *)cvalue);</a>
<a name="ln941">        xmlFree(cvalue);</a>
<a name="ln942">      }</a>
<a name="ln943">      desNode = desNode-&gt;next;</a>
<a name="ln944">    }</a>
<a name="ln945">  }</a>
<a name="ln946">  else if(dev == NULL &amp;&amp; !xmlStrcmp(name, (const xmlChar *)&quot;creator&quot;))</a>
<a name="ln947">  {</a>
<a name="ln948">    xmlNodePtr creNode = node;</a>
<a name="ln949">    while(creNode)</a>
<a name="ln950">    {</a>
<a name="ln951">      if(!xmlStrncmp(creNode-&gt;name, (const xmlChar *)&quot;li&quot;, 2))</a>
<a name="ln952">      {</a>
<a name="ln953">        xmlChar *cvalue = xmlNodeListGetString(doc, creNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln954">        dt_metadata_set(imgid, &quot;Xmp.dc.creator&quot;, (char *)cvalue);</a>
<a name="ln955">        xmlFree(cvalue);</a>
<a name="ln956">      }</a>
<a name="ln957">      creNode = creNode-&gt;next;</a>
<a name="ln958">    }</a>
<a name="ln959">  }</a>
<a name="ln960">  else if(dev == NULL &amp;&amp; !xmlStrcmp(name, (const xmlChar *)&quot;rights&quot;))</a>
<a name="ln961">  {</a>
<a name="ln962">    xmlNodePtr rigNode = node;</a>
<a name="ln963">    while(rigNode)</a>
<a name="ln964">    {</a>
<a name="ln965">      if(!xmlStrncmp(rigNode-&gt;name, (const xmlChar *)&quot;li&quot;, 2))</a>
<a name="ln966">      {</a>
<a name="ln967">        xmlChar *cvalue = xmlNodeListGetString(doc, rigNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln968">        dt_metadata_set(imgid, &quot;Xmp.dc.rights&quot;, (char *)cvalue);</a>
<a name="ln969">        xmlFree(cvalue);</a>
<a name="ln970">      }</a>
<a name="ln971">      rigNode = rigNode-&gt;next;</a>
<a name="ln972">    }</a>
<a name="ln973">  }</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976">/* _has_list returns true if the node contains a list of value */</a>
<a name="ln977">static int _has_list(char *name)</a>
<a name="ln978">{</a>
<a name="ln979">  return !strcmp(name, &quot;subject&quot;)</a>
<a name="ln980">    || !strcmp(name, &quot;hierarchicalSubject&quot;)</a>
<a name="ln981">    || !strcmp(name, &quot;RetouchInfo&quot;)</a>
<a name="ln982">    || !strcmp(name, &quot;ToneCurvePV2012&quot;)</a>
<a name="ln983">    || !strcmp(name, &quot;title&quot;)</a>
<a name="ln984">    || !strcmp(name, &quot;description&quot;)</a>
<a name="ln985">    || !strcmp(name, &quot;creator&quot;)</a>
<a name="ln986">    || !strcmp(name, &quot;publisher&quot;)</a>
<a name="ln987">    || !strcmp(name, &quot;rights&quot;);</a>
<a name="ln988">};</a>
<a name="ln989"> </a>
<a name="ln990">/* handle a specific xpath */</a>
<a name="ln991">static void _handle_xpath(dt_develop_t *dev, xmlDoc *doc, int imgid, xmlXPathContext *ctx, const xmlChar *xpath, lr_data_t *data)</a>
<a name="ln992">{</a>
<a name="ln993">  xmlXPathObject *xpathObj = xmlXPathEvalExpression(xpath, ctx);</a>
<a name="ln994"> </a>
<a name="ln995">  if (xpathObj != NULL)</a>
<a name="ln996">    {</a>
<a name="ln997">      const xmlNodeSetPtr xnodes = xpathObj-&gt;nodesetval;</a>
<a name="ln998">      const int n = xnodes-&gt;nodeNr;</a>
<a name="ln999"> </a>
<a name="ln1000">      for (int k=0; k&lt;n; k++)</a>
<a name="ln1001">        {</a>
<a name="ln1002">          const xmlNode *node = xnodes-&gt;nodeTab[k];</a>
<a name="ln1003"> </a>
<a name="ln1004">          if (_has_list((char *)node-&gt;name))</a>
<a name="ln1005">            {</a>
<a name="ln1006">              xmlNodePtr listnode = node-&gt;xmlChildrenNode;</a>
<a name="ln1007">              if (listnode) listnode = listnode-&gt;next;</a>
<a name="ln1008">              if (listnode) listnode = listnode-&gt;xmlChildrenNode;</a>
<a name="ln1009">              if (listnode) listnode = listnode-&gt;next;</a>
<a name="ln1010">              if (listnode) _lrop(dev, doc, imgid, node-&gt;name, NULL, listnode, data);</a>
<a name="ln1011">            }</a>
<a name="ln1012">          else</a>
<a name="ln1013">            {</a>
<a name="ln1014">              const xmlChar *value = xmlNodeListGetString(doc, node-&gt;children, 1);</a>
<a name="ln1015">              _lrop(dev, doc, imgid, node-&gt;name, value, NULL, data);</a>
<a name="ln1016">            }</a>
<a name="ln1017">        }</a>
<a name="ln1018"> </a>
<a name="ln1019">      xmlXPathFreeObject(xpathObj);</a>
<a name="ln1020">    }</a>
<a name="ln1021">}</a>
<a name="ln1022"> </a>
<a name="ln1023">void dt_lightroom_import(int imgid, dt_develop_t *dev, gboolean iauto)</a>
<a name="ln1024">{</a>
<a name="ln1025">  gboolean refresh_needed = FALSE;</a>
<a name="ln1026">  char imported[256] = { 0 };</a>
<a name="ln1027">  int n_import = 0;                // number of iop imported</a>
<a name="ln1028"> </a>
<a name="ln1029">  // Get full pathname</a>
<a name="ln1030">  char *pathname = dt_get_lightroom_xmp(imgid);</a>
<a name="ln1031"> </a>
<a name="ln1032">  if(!pathname)</a>
<a name="ln1033">  {</a>
<a name="ln1034">    if(!iauto) dt_control_log(_(&quot;cannot find lightroom XMP!&quot;));</a>
<a name="ln1035">    return;</a>
<a name="ln1036">  }</a>
<a name="ln1037"> </a>
<a name="ln1038">  // Load LR xmp</a>
<a name="ln1039"> </a>
<a name="ln1040">  xmlDocPtr doc;</a>
<a name="ln1041">  xmlNodePtr entryNode;</a>
<a name="ln1042"> </a>
<a name="ln1043">  // Parse xml document</a>
<a name="ln1044"> </a>
<a name="ln1045">  doc = xmlParseEntity(pathname);</a>
<a name="ln1046"> </a>
<a name="ln1047">  if(doc == NULL)</a>
<a name="ln1048">  {</a>
<a name="ln1049">    g_free(pathname);</a>
<a name="ln1050">    return;</a>
<a name="ln1051">  }</a>
<a name="ln1052"> </a>
<a name="ln1053">  // Enter first node, xmpmeta</a>
<a name="ln1054"> </a>
<a name="ln1055">  entryNode = xmlDocGetRootElement(doc);</a>
<a name="ln1056"> </a>
<a name="ln1057">  if(entryNode == NULL)</a>
<a name="ln1058">  {</a>
<a name="ln1059">    g_free(pathname);</a>
<a name="ln1060">    xmlFreeDoc(doc);</a>
<a name="ln1061">    return;</a>
<a name="ln1062">  }</a>
<a name="ln1063"> </a>
<a name="ln1064">  if(xmlStrcmp(entryNode-&gt;name, (const xmlChar *)&quot;xmpmeta&quot;))</a>
<a name="ln1065">  {</a>
<a name="ln1066">    if(!iauto) dt_control_log(_(&quot;`%s' not a lightroom XMP!&quot;), pathname);</a>
<a name="ln1067">    g_free(pathname);</a>
<a name="ln1068">    return;</a>
<a name="ln1069">  }</a>
<a name="ln1070"> </a>
<a name="ln1071">  // Check that this is really a Lightroom document</a>
<a name="ln1072"> </a>
<a name="ln1073">  xmlXPathContextPtr xpathCtx = xmlXPathNewContext(doc);</a>
<a name="ln1074"> </a>
<a name="ln1075">  if(xpathCtx == NULL)</a>
<a name="ln1076">  {</a>
<a name="ln1077">    g_free(pathname);</a>
<a name="ln1078">    xmlFreeDoc(doc);</a>
<a name="ln1079">    return;</a>
<a name="ln1080">  }</a>
<a name="ln1081"> </a>
<a name="ln1082">  xmlXPathRegisterNs(xpathCtx, BAD_CAST &quot;stEvt&quot;, BAD_CAST &quot;http://ns.adobe.com/xap/1.0/sType/ResourceEvent#&quot;);</a>
<a name="ln1083"> </a>
<a name="ln1084">  xmlXPathObjectPtr xpathObj = xmlXPathEvalExpression((const xmlChar *)&quot;//@stEvt:softwareAgent&quot;, xpathCtx);</a>
<a name="ln1085"> </a>
<a name="ln1086">  if(xpathObj == NULL)</a>
<a name="ln1087">  {</a>
<a name="ln1088">    if(!iauto) dt_control_log(_(&quot;`%s' not a lightroom XMP!&quot;), pathname);</a>
<a name="ln1089">    xmlXPathFreeContext(xpathCtx);</a>
<a name="ln1090">    g_free(pathname);</a>
<a name="ln1091">    xmlFreeDoc(doc);</a>
<a name="ln1092">    return;</a>
<a name="ln1093">  }</a>
<a name="ln1094"> </a>
<a name="ln1095">  xmlNodeSetPtr xnodes = xpathObj-&gt;nodesetval;</a>
<a name="ln1096"> </a>
<a name="ln1097">  if(xnodes != NULL &amp;&amp; xnodes-&gt;nodeNr &gt; 0)</a>
<a name="ln1098">  {</a>
<a name="ln1099">    xmlNodePtr xnode = xnodes-&gt;nodeTab[0];</a>
<a name="ln1100">    xmlChar *value = xmlNodeListGetString(doc, xnode-&gt;xmlChildrenNode, 1);</a>
<a name="ln1101"> </a>
<a name="ln1102">    if(!strstr((char *)value, &quot;Lightroom&quot;))</a>
<a name="ln1103">    {</a>
<a name="ln1104">      xmlXPathFreeContext(xpathCtx);</a>
<a name="ln1105">      xmlXPathFreeObject(xpathObj);</a>
<a name="ln1106">      xmlFreeDoc(doc);</a>
<a name="ln1107">      xmlFree(value);</a>
<a name="ln1108">      if(!iauto) dt_control_log(_(&quot;`%s' not a lightroom XMP!&quot;), pathname);</a>
<a name="ln1109">      g_free(pathname);</a>
<a name="ln1110">      return;</a>
<a name="ln1111">    }</a>
<a name="ln1112">    xmlFree(value);</a>
<a name="ln1113">  }</a>
<a name="ln1114">// we could bail out here if we ONLY wanted to load a file known to be from lightroom.</a>
<a name="ln1115">// if we don't know who created it we will just import it however.</a>
<a name="ln1116">//   else</a>
<a name="ln1117">//   {</a>
<a name="ln1118">//     xmlXPathFreeObject(xpathObj);</a>
<a name="ln1119">//     xmlXPathFreeContext(xpathCtx);</a>
<a name="ln1120">//     if(!iauto) dt_control_log(_(&quot;`%s' not a lightroom XMP!&quot;), pathname);</a>
<a name="ln1121">//     g_free(pathname);</a>
<a name="ln1122">//     return;</a>
<a name="ln1123">//   }</a>
<a name="ln1124"> </a>
<a name="ln1125">  // let's now parse the needed data</a>
<a name="ln1126"> </a>
<a name="ln1127">  lr_data_t data;</a>
<a name="ln1128"> </a>
<a name="ln1129">  memset(&amp;data, 0, sizeof(data));</a>
<a name="ln1130"> </a>
<a name="ln1131">  data.has_crop = FALSE;</a>
<a name="ln1132">  data.has_flip = FALSE;</a>
<a name="ln1133">  data.has_exposure = FALSE;</a>
<a name="ln1134">  data.has_vignette = FALSE;</a>
<a name="ln1135">  data.has_grain = FALSE;</a>
<a name="ln1136">  data.has_spots = FALSE;</a>
<a name="ln1137">  data.curve_kind = linear;</a>
<a name="ln1138">  data.n_pts = 0;</a>
<a name="ln1139">  data.has_colorzones = FALSE;</a>
<a name="ln1140">  data.has_splittoning = FALSE;</a>
<a name="ln1141">  data.has_bilat = FALSE;</a>
<a name="ln1142">  data.has_tags = FALSE;</a>
<a name="ln1143">  data.rating = 0;</a>
<a name="ln1144">  data.has_rating = FALSE;</a>
<a name="ln1145">  data.lat = NAN;</a>
<a name="ln1146">  data.lon = NAN;</a>
<a name="ln1147">  data.has_gps = FALSE;</a>
<a name="ln1148">  data.color = 0;</a>
<a name="ln1149">  data.has_colorlabel = FALSE;</a>
<a name="ln1150">  data.fratio = NAN;                // factor ratio image</a>
<a name="ln1151">  data.crop_roundness = NAN;        // from lightroom</a>
<a name="ln1152">  data.iwidth = 0;</a>
<a name="ln1153">  data.iheight = 0;                 // image width / height</a>
<a name="ln1154">  data.orientation = 1;</a>
<a name="ln1155"> </a>
<a name="ln1156">  // record the name-spaces needed for the parsing</a>
<a name="ln1157">  xmlXPathRegisterNs</a>
<a name="ln1158">    (xpathCtx,</a>
<a name="ln1159">     BAD_CAST &quot;crs&quot;,</a>
<a name="ln1160">     BAD_CAST &quot;http://ns.adobe.com/camera-raw-settings/1.0/&quot;);</a>
<a name="ln1161">  xmlXPathRegisterNs</a>
<a name="ln1162">    (xpathCtx,</a>
<a name="ln1163">     BAD_CAST &quot;dc&quot;,</a>
<a name="ln1164">     BAD_CAST &quot;http://purl.org/dc/elements/1.1/&quot;);</a>
<a name="ln1165">  xmlXPathRegisterNs</a>
<a name="ln1166">    (xpathCtx,</a>
<a name="ln1167">     BAD_CAST &quot;tiff&quot;,</a>
<a name="ln1168">     BAD_CAST &quot;http://ns.adobe.com/tiff/1.0/&quot;);</a>
<a name="ln1169">  xmlXPathRegisterNs</a>
<a name="ln1170">    (xpathCtx,</a>
<a name="ln1171">     BAD_CAST &quot;xmp&quot;,</a>
<a name="ln1172">     BAD_CAST &quot;http://ns.adobe.com/xap/1.0/&quot;);</a>
<a name="ln1173">  xmlXPathRegisterNs</a>
<a name="ln1174">    (xpathCtx,</a>
<a name="ln1175">     BAD_CAST &quot;exif&quot;,</a>
<a name="ln1176">     BAD_CAST &quot;http://ns.adobe.com/exif/1.0/&quot;);</a>
<a name="ln1177">  xmlXPathRegisterNs</a>
<a name="ln1178">    (xpathCtx,</a>
<a name="ln1179">     BAD_CAST &quot;lr&quot;,</a>
<a name="ln1180">     BAD_CAST &quot;http://ns.adobe.com/lightroom/1.0/&quot;);</a>
<a name="ln1181">  xmlXPathRegisterNs</a>
<a name="ln1182">    (xpathCtx,</a>
<a name="ln1183">     BAD_CAST &quot;rdf&quot;,</a>
<a name="ln1184">     BAD_CAST &quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;);</a>
<a name="ln1185"> </a>
<a name="ln1186">  // All prefixes to parse from the XMP document</a>
<a name="ln1187">  static char *names[] = { &quot;crs&quot;, &quot;dc&quot;, &quot;tiff&quot;, &quot;xmp&quot;, &quot;exif&quot;, &quot;lr&quot;, NULL };</a>
<a name="ln1188"> </a>
<a name="ln1189">  for (int i=0; names[i]!=NULL; i++)</a>
<a name="ln1190">    {</a>
<a name="ln1191">      char expr[50];</a>
<a name="ln1192"> </a>
<a name="ln1193">      /* Lr 7.0 CC (nodes) */</a>
<a name="ln1194">      snprintf(expr, sizeof(expr), &quot;//%s:*&quot;, names[i]);</a>
<a name="ln1195">      _handle_xpath(dev, doc, imgid, xpathCtx, (const xmlChar *)expr, &amp;data);</a>
<a name="ln1196"> </a>
<a name="ln1197">      /* Lr up to 6.0 (attributes) */</a>
<a name="ln1198">      snprintf(expr, sizeof(expr), &quot;//@%s:*&quot;, names[i]);</a>
<a name="ln1199">      _handle_xpath(dev, doc, imgid, xpathCtx, (const xmlChar *)expr, &amp;data);</a>
<a name="ln1200">    }</a>
<a name="ln1201"> </a>
<a name="ln1202">  xmlXPathFreeObject(xpathObj);</a>
<a name="ln1203">  xmlXPathFreeContext(xpathCtx);</a>
<a name="ln1204">  xmlFreeDoc(doc);</a>
<a name="ln1205"> </a>
<a name="ln1206">  //  Integrates into the history all the imported iop</a>
<a name="ln1207"> </a>
<a name="ln1208">  if(dev != NULL &amp;&amp; dt_image_is_raw(&amp;dev-&gt;image_storage))</a>
<a name="ln1209">  {</a>
<a name="ln1210">    // set colorin to cmatrix which is the default from Adobe (so closer to what Lightroom does)</a>
<a name="ln1211">    dt_iop_colorin_params_t pci = (dt_iop_colorin_params_t){ &quot;cmatrix&quot;, DT_INTENT_PERCEPTUAL };</a>
<a name="ln1212"> </a>
<a name="ln1213">    dt_add_hist(imgid, &quot;colorin&quot;, (dt_iop_params_t *)&amp;pci, sizeof(dt_iop_colorin_params_t), imported,</a>
<a name="ln1214">                sizeof(imported), LRDT_COLORIN_VERSION, &amp;n_import, dt_ioppr_get_iop_order(dev-&gt;iop_order_list, &quot;colorin&quot;));</a>
<a name="ln1215">    refresh_needed = TRUE;</a>
<a name="ln1216">  }</a>
<a name="ln1217"> </a>
<a name="ln1218">  if(dev != NULL &amp;&amp; data.has_crop)</a>
<a name="ln1219">  {</a>
<a name="ln1220">    data.pc.k_sym = 0;</a>
<a name="ln1221">    data.pc.k_apply = 0;</a>
<a name="ln1222">    data.pc.crop_auto = 0;</a>
<a name="ln1223">    data.pc.k_h = data.pc.k_v = 0;</a>
<a name="ln1224">    data.pc.k_type = 0;</a>
<a name="ln1225">    data.pc.kxa = data.pc.kxd = 0.2f;</a>
<a name="ln1226">    data.pc.kxc = data.pc.kxb = 0.8f;</a>
<a name="ln1227">    data.pc.kya = data.pc.kyb = 0.2f;</a>
<a name="ln1228">    data.pc.kyc = data.pc.kyd = 0.8f;</a>
<a name="ln1229">    float tmp;</a>
<a name="ln1230"> </a>
<a name="ln1231">    if(data.has_crop)</a>
<a name="ln1232">    {</a>
<a name="ln1233">      // adjust crop data according to the rotation</a>
<a name="ln1234"> </a>
<a name="ln1235">      switch(dev-&gt;image_storage.orientation)</a>
<a name="ln1236">      {</a>
<a name="ln1237">        case 5: // portrait - counter-clockwise</a>
<a name="ln1238">          tmp = data.pc.ch;</a>
<a name="ln1239">          data.pc.ch = 1.0 - data.pc.cx;</a>
<a name="ln1240">          data.pc.cx = data.pc.cy;</a>
<a name="ln1241">          data.pc.cy = 1.0 - data.pc.cw;</a>
<a name="ln1242">          data.pc.cw = tmp;</a>
<a name="ln1243">          break;</a>
<a name="ln1244">        case 6: // portrait - clockwise</a>
<a name="ln1245">          tmp = data.pc.ch;</a>
<a name="ln1246">          data.pc.ch = data.pc.cw;</a>
<a name="ln1247">          data.pc.cw = 1.0 - data.pc.cy;</a>
<a name="ln1248">          data.pc.cy = data.pc.cx;</a>
<a name="ln1249">          data.pc.cx = 1.0 - tmp;</a>
<a name="ln1250">          break;</a>
<a name="ln1251">        default:</a>
<a name="ln1252">          break;</a>
<a name="ln1253">      }</a>
<a name="ln1254"> </a>
<a name="ln1255">      if(data.pc.angle != 0)</a>
<a name="ln1256">      {</a>
<a name="ln1257">        const float rangle = -data.pc.angle * (3.141592 / 180);</a>
<a name="ln1258">        float x, y;</a>
<a name="ln1259"> </a>
<a name="ln1260">        // do the rotation (rangle) using center of image (0.5, 0.5)</a>
<a name="ln1261"> </a>
<a name="ln1262">        x = data.pc.cx - 0.5;</a>
<a name="ln1263">        y = 0.5 - data.pc.cy;</a>
<a name="ln1264">        data.pc.cx = 0.5 + x * cos(rangle) - y * sin(rangle);</a>
<a name="ln1265">        data.pc.cy = 0.5 - (x * sin(rangle) + y * cos(rangle));</a>
<a name="ln1266"> </a>
<a name="ln1267">        x = data.pc.cw - 0.5;</a>
<a name="ln1268">        y = 0.5 - data.pc.ch;</a>
<a name="ln1269">        data.pc.cw = 0.5 + x * cos(rangle) - y * sin(rangle);</a>
<a name="ln1270">        data.pc.ch = 0.5 - (x * sin(rangle) + y * cos(rangle));</a>
<a name="ln1271">      }</a>
<a name="ln1272">    }</a>
<a name="ln1273">    else</a>
<a name="ln1274">    {</a>
<a name="ln1275">      data.pc.angle = 0;</a>
<a name="ln1276">      data.pc.cx = 0;</a>
<a name="ln1277">      data.pc.cy = 0;</a>
<a name="ln1278">      data.pc.cw = 1;</a>
<a name="ln1279">      data.pc.ch = 1;</a>
<a name="ln1280">    }</a>
<a name="ln1281"> </a>
<a name="ln1282">    data.fratio = (data.pc.cw - data.pc.cx) / (data.pc.ch - data.pc.cy);</a>
<a name="ln1283"> </a>
<a name="ln1284">    dt_add_hist(imgid, &quot;clipping&quot;, (dt_iop_params_t *)&amp;data.pc, sizeof(dt_iop_clipping_params_t), imported,</a>
<a name="ln1285">                sizeof(imported), LRDT_CLIPPING_VERSION, &amp;n_import, dt_ioppr_get_iop_order(dev-&gt;iop_order_list, &quot;clipping&quot;));</a>
<a name="ln1286">    refresh_needed = TRUE;</a>
<a name="ln1287">  }</a>
<a name="ln1288"> </a>
<a name="ln1289">  if(dev != NULL &amp;&amp; data.has_flip)</a>
<a name="ln1290">  {</a>
<a name="ln1291">    data.pf.orientation = 0;</a>
<a name="ln1292"> </a>
<a name="ln1293">    if(dev-&gt;image_storage.orientation == 5)</a>
<a name="ln1294">      // portrait</a>
<a name="ln1295">      switch(data.orientation)</a>
<a name="ln1296">      {</a>
<a name="ln1297">        case 8:</a>
<a name="ln1298">          data.pf.orientation = 0;</a>
<a name="ln1299">          break;</a>
<a name="ln1300">        case 3:</a>
<a name="ln1301">          data.pf.orientation = 5;</a>
<a name="ln1302">          break;</a>
<a name="ln1303">        case 6:</a>
<a name="ln1304">          data.pf.orientation = 3;</a>
<a name="ln1305">          break;</a>
<a name="ln1306">        case 1:</a>
<a name="ln1307">          data.pf.orientation = 6;</a>
<a name="ln1308">          break;</a>
<a name="ln1309"> </a>
<a name="ln1310">        // with horizontal flip</a>
<a name="ln1311">        case 7:</a>
<a name="ln1312">          data.pf.orientation = 1;</a>
<a name="ln1313">          break;</a>
<a name="ln1314">        case 2:</a>
<a name="ln1315">          data.pf.orientation = 4;</a>
<a name="ln1316">          break;</a>
<a name="ln1317">        case 5:</a>
<a name="ln1318">          data.pf.orientation = 2;</a>
<a name="ln1319">          break;</a>
<a name="ln1320">        case 4:</a>
<a name="ln1321">          data.pf.orientation = 7;</a>
<a name="ln1322">          break;</a>
<a name="ln1323">      }</a>
<a name="ln1324"> </a>
<a name="ln1325">    else if(dev-&gt;image_storage.orientation == 6)</a>
<a name="ln1326">      // portrait</a>
<a name="ln1327">      switch(data.orientation)</a>
<a name="ln1328">      {</a>
<a name="ln1329">        case 8:</a>
<a name="ln1330">          data.pf.orientation = 3;</a>
<a name="ln1331">          break;</a>
<a name="ln1332">        case 3:</a>
<a name="ln1333">          data.pf.orientation = 6;</a>
<a name="ln1334">          break;</a>
<a name="ln1335">        case 6:</a>
<a name="ln1336">          data.pf.orientation = 0;</a>
<a name="ln1337">          break;</a>
<a name="ln1338">        case 1:</a>
<a name="ln1339">          data.pf.orientation = 5;</a>
<a name="ln1340">          break;</a>
<a name="ln1341"> </a>
<a name="ln1342">        // with horizontal flip</a>
<a name="ln1343">        case 7:</a>
<a name="ln1344">          data.pf.orientation = 2;</a>
<a name="ln1345">          break;</a>
<a name="ln1346">        case 2:</a>
<a name="ln1347">          data.pf.orientation = 7;</a>
<a name="ln1348">          break;</a>
<a name="ln1349">        case 5:</a>
<a name="ln1350">          data.pf.orientation = 1;</a>
<a name="ln1351">          break;</a>
<a name="ln1352">        case 4:</a>
<a name="ln1353">          data.pf.orientation = 4;</a>
<a name="ln1354">          break;</a>
<a name="ln1355">      }</a>
<a name="ln1356"> </a>
<a name="ln1357">    else</a>
<a name="ln1358">      // landscape</a>
<a name="ln1359">      switch(data.orientation)</a>
<a name="ln1360">      {</a>
<a name="ln1361">        case 8:</a>
<a name="ln1362">          data.pf.orientation = 5;</a>
<a name="ln1363">          break;</a>
<a name="ln1364">        case 3:</a>
<a name="ln1365">          data.pf.orientation = 3;</a>
<a name="ln1366">          break;</a>
<a name="ln1367">        case 6:</a>
<a name="ln1368">          data.pf.orientation = 6;</a>
<a name="ln1369">          break;</a>
<a name="ln1370">        case 1:</a>
<a name="ln1371">          data.pf.orientation = 0;</a>
<a name="ln1372">          break;</a>
<a name="ln1373"> </a>
<a name="ln1374">        // with horizontal flip</a>
<a name="ln1375">        case 7:</a>
<a name="ln1376">          data.pf.orientation = 7;</a>
<a name="ln1377">          break;</a>
<a name="ln1378">        case 2:</a>
<a name="ln1379">          data.pf.orientation = 1;</a>
<a name="ln1380">          break;</a>
<a name="ln1381">        case 5:</a>
<a name="ln1382">          data.pf.orientation = 4;</a>
<a name="ln1383">          break;</a>
<a name="ln1384">        case 4:</a>
<a name="ln1385">          data.pf.orientation = 2;</a>
<a name="ln1386">          break;</a>
<a name="ln1387">      }</a>
<a name="ln1388"> </a>
<a name="ln1389">    dt_add_hist(imgid, &quot;flip&quot;, (dt_iop_params_t *)&amp;data.pf, sizeof(dt_iop_flip_params_t), imported,</a>
<a name="ln1390">                sizeof(imported), LRDT_FLIP_VERSION, &amp;n_import, dt_ioppr_get_iop_order(dev-&gt;iop_order_list, &quot;flip&quot;));</a>
<a name="ln1391">    refresh_needed = TRUE;</a>
<a name="ln1392">  }</a>
<a name="ln1393"> </a>
<a name="ln1394">  if(dev != NULL &amp;&amp; data.has_exposure)</a>
<a name="ln1395">  {</a>
<a name="ln1396">    dt_add_hist(imgid, &quot;exposure&quot;, (dt_iop_params_t *)&amp;data.pe, sizeof(dt_iop_exposure_params_t), imported,</a>
<a name="ln1397">                sizeof(imported), LRDT_EXPOSURE_VERSION, &amp;n_import, dt_ioppr_get_iop_order(dev-&gt;iop_order_list, &quot;exposure&quot;));</a>
<a name="ln1398">    refresh_needed = TRUE;</a>
<a name="ln1399">  }</a>
<a name="ln1400"> </a>
<a name="ln1401">  if(dev != NULL &amp;&amp; data.has_grain)</a>
<a name="ln1402">  {</a>
<a name="ln1403">    data.pg.channel = 0;</a>
<a name="ln1404"> </a>
<a name="ln1405">    dt_add_hist(imgid, &quot;grain&quot;, (dt_iop_params_t *)&amp;data.pg, sizeof(dt_iop_grain_params_t), imported,</a>
<a name="ln1406">                sizeof(imported), LRDT_GRAIN_VERSION, &amp;n_import, dt_ioppr_get_iop_order(dev-&gt;iop_order_list, &quot;grain&quot;));</a>
<a name="ln1407">    refresh_needed = TRUE;</a>
<a name="ln1408">  }</a>
<a name="ln1409"> </a>
<a name="ln1410">  if(dev != NULL &amp;&amp; data.has_vignette)</a>
<a name="ln1411">  {</a>
<a name="ln1412">    const float base_ratio = 1.325 / 1.5;</a>
<a name="ln1413"> </a>
<a name="ln1414">    data.pv.autoratio = FALSE;</a>
<a name="ln1415">    data.pv.dithering = DITHER_8BIT;</a>
<a name="ln1416">    data.pv.center.x = 0.0;</a>
<a name="ln1417">    data.pv.center.y = 0.0;</a>
<a name="ln1418">    data.pv.shape = 1.0;</a>
<a name="ln1419"> </a>
<a name="ln1420">    // defensive code, should not happen, but just in case future Lr version</a>
<a name="ln1421">    // has not ImageWidth/ImageLength XML tag.</a>
<a name="ln1422">    if(data.iwidth == 0 || data.iheight == 0)</a>
<a name="ln1423">      data.pv.whratio = base_ratio;</a>
<a name="ln1424">    else</a>
<a name="ln1425">      data.pv.whratio = base_ratio * ((float)data.iwidth / (float)data.iheight);</a>
<a name="ln1426"> </a>
<a name="ln1427">    if(data.has_crop) data.pv.whratio = data.pv.whratio * data.fratio;</a>
<a name="ln1428"> </a>
<a name="ln1429">    //  Adjust scale and ratio based on the roundness. On Lightroom changing</a>
<a name="ln1430">    //  the roundness change the width and the height of the vignette.</a>
<a name="ln1431"> </a>
<a name="ln1432">    if(data.crop_roundness &gt; 0)</a>
<a name="ln1433">    {</a>
<a name="ln1434">      float newratio = data.pv.whratio - (data.pv.whratio - 1) * (data.crop_roundness / 100.0);</a>
<a name="ln1435">      float dscale = (1 - (newratio / data.pv.whratio)) / 2.0;</a>
<a name="ln1436"> </a>
<a name="ln1437">      data.pv.scale -= dscale * 100.0;</a>
<a name="ln1438">      data.pv.whratio = newratio;</a>
<a name="ln1439">    }</a>
<a name="ln1440"> </a>
<a name="ln1441">    dt_add_hist(imgid, &quot;vignette&quot;, (dt_iop_params_t *)&amp;data.pv, sizeof(dt_iop_vignette_params_t), imported,</a>
<a name="ln1442">                sizeof(imported), LRDT_VIGNETTE_VERSION, &amp;n_import, dt_ioppr_get_iop_order(dev-&gt;iop_order_list, &quot;vignette&quot;));</a>
<a name="ln1443">    refresh_needed = TRUE;</a>
<a name="ln1444">  }</a>
<a name="ln1445"> </a>
<a name="ln1446">  if(dev != NULL &amp;&amp; data.has_spots)</a>
<a name="ln1447">  {</a>
<a name="ln1448">    // Check for orientation, rotate when in portrait mode</a>
<a name="ln1449">    if(data.orientation &gt; 4)</a>
<a name="ln1450">      for(int k = 0; k &lt; data.ps.num_spots; k++)</a>
<a name="ln1451">      {</a>
<a name="ln1452">        float tmp = data.ps.spot[k].y;</a>
<a name="ln1453">        data.ps.spot[k].y = 1.0 - data.ps.spot[k].x;</a>
<a name="ln1454">        data.ps.spot[k].x = tmp;</a>
<a name="ln1455">        tmp = data.ps.spot[k].yc;</a>
<a name="ln1456">        data.ps.spot[k].yc = 1.0 - data.ps.spot[k].xc;</a>
<a name="ln1457">        data.ps.spot[k].xc = tmp;</a>
<a name="ln1458">      }</a>
<a name="ln1459"> </a>
<a name="ln1460">    dt_add_hist(imgid, &quot;spots&quot;, (dt_iop_params_t *)&amp;data.ps, sizeof(dt_iop_spots_params_t), imported,</a>
<a name="ln1461">                sizeof(imported), LRDT_SPOTS_VERSION, &amp;n_import, dt_ioppr_get_iop_order(dev-&gt;iop_order_list, &quot;spots&quot;));</a>
<a name="ln1462">    refresh_needed = TRUE;</a>
<a name="ln1463">  }</a>
<a name="ln1464"> </a>
<a name="ln1465">  if(dev != NULL &amp;&amp;</a>
<a name="ln1466">     (data.curve_kind != linear</a>
<a name="ln1467">      || data.ptc_value[0] != 0 || data.ptc_value[1] != 0 || data.ptc_value[2] != 0 || data.ptc_value[3] != 0))</a>
<a name="ln1468">  {</a>
<a name="ln1469">    const int total_pts = (data.curve_kind == custom) ? data.n_pts : 6;</a>
<a name="ln1470">    data.ptc.tonecurve_nodes[ch_L] = total_pts;</a>
<a name="ln1471">    data.ptc.tonecurve_nodes[ch_a] = 7;</a>
<a name="ln1472">    data.ptc.tonecurve_nodes[ch_b] = 7;</a>
<a name="ln1473">    data.ptc.tonecurve_type[ch_L] = CUBIC_SPLINE;</a>
<a name="ln1474">    data.ptc.tonecurve_type[ch_a] = CUBIC_SPLINE;</a>
<a name="ln1475">    data.ptc.tonecurve_type[ch_b] = CUBIC_SPLINE;</a>
<a name="ln1476">    data.ptc.tonecurve_autoscale_ab = 1;</a>
<a name="ln1477">    data.ptc.tonecurve_preset = 0;</a>
<a name="ln1478"> </a>
<a name="ln1479">    float linear_ab[7] = { 0.0, 0.08, 0.3, 0.5, 0.7, 0.92, 1.0 };</a>
<a name="ln1480"> </a>
<a name="ln1481">    // linear a, b curves</a>
<a name="ln1482">    for(int k = 0; k &lt; 7; k++) data.ptc.tonecurve[ch_a][k].x = linear_ab[k];</a>
<a name="ln1483">    for(int k = 0; k &lt; 7; k++) data.ptc.tonecurve[ch_a][k].y = linear_ab[k];</a>
<a name="ln1484">    for(int k = 0; k &lt; 7; k++) data.ptc.tonecurve[ch_b][k].x = linear_ab[k];</a>
<a name="ln1485">    for(int k = 0; k &lt; 7; k++) data.ptc.tonecurve[ch_b][k].y = linear_ab[k];</a>
<a name="ln1486"> </a>
<a name="ln1487">    // Set the base tonecurve</a>
<a name="ln1488"> </a>
<a name="ln1489">    if(data.curve_kind == linear)</a>
<a name="ln1490">    {</a>
<a name="ln1491">      data.ptc.tonecurve[ch_L][0].x = 0.0;</a>
<a name="ln1492">      data.ptc.tonecurve[ch_L][0].y = 0.0;</a>
<a name="ln1493">      data.ptc.tonecurve[ch_L][1].x = data.ptc_split[0] / 2.0;</a>
<a name="ln1494">      data.ptc.tonecurve[ch_L][1].y = data.ptc_split[0] / 2.0;</a>
<a name="ln1495">      data.ptc.tonecurve[ch_L][2].x = data.ptc_split[1] - (data.ptc_split[1] - data.ptc_split[0]) / 2.0;</a>
<a name="ln1496">      data.ptc.tonecurve[ch_L][2].y = data.ptc_split[1] - (data.ptc_split[1] - data.ptc_split[0]) / 2.0;</a>
<a name="ln1497">      data.ptc.tonecurve[ch_L][3].x = data.ptc_split[1] + (data.ptc_split[2] - data.ptc_split[1]) / 2.0;</a>
<a name="ln1498">      data.ptc.tonecurve[ch_L][3].y = data.ptc_split[1] + (data.ptc_split[2] - data.ptc_split[1]) / 2.0;</a>
<a name="ln1499">      data.ptc.tonecurve[ch_L][4].x = data.ptc_split[2] + (1.0 - data.ptc_split[2]) / 2.0;</a>
<a name="ln1500">      data.ptc.tonecurve[ch_L][4].y = data.ptc_split[2] + (1.0 - data.ptc_split[2]) / 2.0;</a>
<a name="ln1501">      data.ptc.tonecurve[ch_L][5].x = 1.0;</a>
<a name="ln1502">      data.ptc.tonecurve[ch_L][5].y = 1.0;</a>
<a name="ln1503">    }</a>
<a name="ln1504">    else</a>
<a name="ln1505">    {</a>
<a name="ln1506">      for(int k = 0; k &lt; total_pts; k++)</a>
<a name="ln1507">      {</a>
<a name="ln1508">        data.ptc.tonecurve[ch_L][k].x = data.curve_pts[k][0] / 255.0;</a>
<a name="ln1509">        data.ptc.tonecurve[ch_L][k].y = data.curve_pts[k][1] / 255.0;</a>
<a name="ln1510">      }</a>
<a name="ln1511">    }</a>
<a name="ln1512"> </a>
<a name="ln1513">    if(data.curve_kind != custom)</a>
<a name="ln1514">    {</a>
<a name="ln1515">      // set shadows/darks/lights/highlight adjustments</a>
<a name="ln1516"> </a>
<a name="ln1517">      data.ptc.tonecurve[ch_L][1].y += data.ptc.tonecurve[ch_L][1].y * ((float)data.ptc_value[0] / 100.0);</a>
<a name="ln1518">      data.ptc.tonecurve[ch_L][2].y += data.ptc.tonecurve[ch_L][2].y * ((float)data.ptc_value[1] / 100.0);</a>
<a name="ln1519">      data.ptc.tonecurve[ch_L][3].y += data.ptc.tonecurve[ch_L][3].y * ((float)data.ptc_value[2] / 100.0);</a>
<a name="ln1520">      data.ptc.tonecurve[ch_L][4].y += data.ptc.tonecurve[ch_L][4].y * ((float)data.ptc_value[3] / 100.0);</a>
<a name="ln1521"> </a>
<a name="ln1522">      if(data.ptc.tonecurve[ch_L][1].y &gt; data.ptc.tonecurve[ch_L][2].y)</a>
<a name="ln1523">        data.ptc.tonecurve[ch_L][1].y = data.ptc.tonecurve[ch_L][2].y;</a>
<a name="ln1524">      if(data.ptc.tonecurve[ch_L][3].y &gt; data.ptc.tonecurve[ch_L][4].y)</a>
<a name="ln1525">        data.ptc.tonecurve[ch_L][4].y = data.ptc.tonecurve[ch_L][3].y;</a>
<a name="ln1526">    }</a>
<a name="ln1527"> </a>
<a name="ln1528">    dt_add_hist(imgid, &quot;tonecurve&quot;, (dt_iop_params_t *)&amp;data.ptc, sizeof(dt_iop_tonecurve_params_t), imported,</a>
<a name="ln1529">                sizeof(imported), LRDT_TONECURVE_VERSION, &amp;n_import, dt_ioppr_get_iop_order(dev-&gt;iop_order_list, &quot;tonecurve&quot;));</a>
<a name="ln1530">    refresh_needed = TRUE;</a>
<a name="ln1531">  }</a>
<a name="ln1532"> </a>
<a name="ln1533">  if(dev != NULL &amp;&amp; data.has_colorzones)</a>
<a name="ln1534">  {</a>
<a name="ln1535">    data.pcz.channel = DT_IOP_COLORZONES_h;</a>
<a name="ln1536"> </a>
<a name="ln1537">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1538">      for(int k = 0; k &lt; 8; k++)</a>
<a name="ln1539">        data.pcz.equalizer_x[i][k] = k / (DT_IOP_COLORZONES_BANDS - 1.0);</a>
<a name="ln1540"> </a>
<a name="ln1541">    dt_add_hist(imgid, &quot;colorzones&quot;, (dt_iop_params_t *)&amp;data.pcz, sizeof(dt_iop_colorzones_params_t), imported,</a>
<a name="ln1542">                sizeof(imported), LRDT_COLORZONES_VERSION, &amp;n_import, dt_ioppr_get_iop_order(dev-&gt;iop_order_list, &quot;colorzones&quot;));</a>
<a name="ln1543">    refresh_needed = TRUE;</a>
<a name="ln1544">  }</a>
<a name="ln1545"> </a>
<a name="ln1546">  if(dev != NULL &amp;&amp; data.has_splittoning)</a>
<a name="ln1547">  {</a>
<a name="ln1548">    data.pst.compress = 50.0;</a>
<a name="ln1549"> </a>
<a name="ln1550">    dt_add_hist(imgid, &quot;splittoning&quot;, (dt_iop_params_t *)&amp;data.pst, sizeof(dt_iop_splittoning_params_t), imported,</a>
<a name="ln1551">                sizeof(imported), LRDT_SPLITTONING_VERSION, &amp;n_import, dt_ioppr_get_iop_order(dev-&gt;iop_order_list, &quot;splittoning&quot;));</a>
<a name="ln1552">    refresh_needed = TRUE;</a>
<a name="ln1553">  }</a>
<a name="ln1554"> </a>
<a name="ln1555">  if(dev != NULL &amp;&amp; data.has_bilat)</a>
<a name="ln1556">  {</a>
<a name="ln1557">    data.pbl.sigma_r = 100.0;</a>
<a name="ln1558">    data.pbl.sigma_s = 100.0;</a>
<a name="ln1559"> </a>
<a name="ln1560">    dt_add_hist(imgid, &quot;bilat&quot;, (dt_iop_params_t *)&amp;data.pbl, sizeof(dt_iop_bilat_params_t), imported,</a>
<a name="ln1561">                sizeof(imported), LRDT_BILAT_VERSION, &amp;n_import, dt_ioppr_get_iop_order(dev-&gt;iop_order_list, &quot;bilat&quot;));</a>
<a name="ln1562">    refresh_needed = TRUE;</a>
<a name="ln1563">  }</a>
<a name="ln1564"> </a>
<a name="ln1565">  if(data.has_tags)</a>
<a name="ln1566">  {</a>
<a name="ln1567">    if(imported[0]) g_strlcat(imported, &quot;, &quot;, sizeof(imported));</a>
<a name="ln1568">    g_strlcat(imported, _(&quot;tags&quot;), sizeof(imported));</a>
<a name="ln1569">    n_import++;</a>
<a name="ln1570">  }</a>
<a name="ln1571"> </a>
<a name="ln1572">  if(dev == NULL &amp;&amp; data.has_rating)</a>
<a name="ln1573">  {</a>
<a name="ln1574">    dt_ratings_apply_to_image(imgid, data.rating);</a>
<a name="ln1575"> </a>
<a name="ln1576">    if(imported[0]) g_strlcat(imported, &quot;, &quot;, sizeof(imported));</a>
<a name="ln1577">    g_strlcat(imported, _(&quot;rating&quot;), sizeof(imported));</a>
<a name="ln1578">    n_import++;</a>
<a name="ln1579">  }</a>
<a name="ln1580"> </a>
<a name="ln1581">  if(dev == NULL &amp;&amp; data.has_gps)</a>
<a name="ln1582">  {</a>
<a name="ln1583">    dt_image_geoloc_t geoloc;</a>
<a name="ln1584">    geoloc.longitude = data.lon;</a>
<a name="ln1585">    geoloc.latitude = data.lat;</a>
<a name="ln1586">    dt_image_set_location(imgid, &amp;geoloc);</a>
<a name="ln1587"> </a>
<a name="ln1588">    if(imported[0]) g_strlcat(imported, &quot;, &quot;, sizeof(imported));</a>
<a name="ln1589">    g_strlcat(imported, _(&quot;geotagging&quot;), sizeof(imported));</a>
<a name="ln1590">    n_import++;</a>
<a name="ln1591">  }</a>
<a name="ln1592"> </a>
<a name="ln1593">  if(dev == NULL &amp;&amp; data.has_colorlabel)</a>
<a name="ln1594">  {</a>
<a name="ln1595">    dt_colorlabels_set_label(imgid, data.color);</a>
<a name="ln1596"> </a>
<a name="ln1597">    if(imported[0]) g_strlcat(imported, &quot;, &quot;, sizeof(imported));</a>
<a name="ln1598">    g_strlcat(imported, _(&quot;color label&quot;), sizeof(imported));</a>
<a name="ln1599">    n_import++;</a>
<a name="ln1600">  }</a>
<a name="ln1601"> </a>
<a name="ln1602">  if(dev != NULL &amp;&amp; refresh_needed &amp;&amp; dev-&gt;gui_attached)</a>
<a name="ln1603">  {</a>
<a name="ln1604">    dt_control_log(ngettext(&quot;%s has been imported&quot;, &quot;%s have been imported&quot;, n_import), imported);</a>
<a name="ln1605"> </a>
<a name="ln1606">    if(!iauto)</a>
<a name="ln1607">    {</a>
<a name="ln1608">      /* signal history changed */</a>
<a name="ln1609">      dt_dev_reload_history_items(dev);</a>
<a name="ln1610">      dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln1611">      /* update xmp file */</a>
<a name="ln1612">      dt_image_synch_xmp(imgid);</a>
<a name="ln1613">      dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE);</a>
<a name="ln1614">    }</a>
<a name="ln1615">  }</a>
<a name="ln1616">}</a>
<a name="ln1617">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1618">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1619">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1231"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'data.has_crop' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
