
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2013--2017 pascal obry.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;develop/lightroom.h&quot;</a>
<a name="ln20">#include &quot;common/colorlabels.h&quot;</a>
<a name="ln21">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln22">#include &quot;common/curve_tools.h&quot;</a>
<a name="ln23">#include &quot;common/darktable.h&quot;</a>
<a name="ln24">#include &quot;common/debug.h&quot;</a>
<a name="ln25">#include &quot;common/ratings.h&quot;</a>
<a name="ln26">#include &quot;common/tags.h&quot;</a>
<a name="ln27">#include &quot;common/metadata.h&quot;</a>
<a name="ln28">#include &quot;control/control.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;ctype.h&gt;</a>
<a name="ln31">#include &lt;libxml/parser.h&gt;</a>
<a name="ln32">#include &lt;libxml/xpath.h&gt;</a>
<a name="ln33">#include &lt;libxml/xpathInternals.h&gt;</a>
<a name="ln34">#include &lt;stdlib.h&gt;</a>
<a name="ln35">#include &lt;string.h&gt;</a>
<a name="ln36">#include &lt;sys/stat.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">// copy here the iop params struct with the actual version. This is so to</a>
<a name="ln39">// be as independent as possible of any iop evolutions. Indeed, we create</a>
<a name="ln40">// the iop params into the database for a specific version. We then ask</a>
<a name="ln41">// for a reload of the history parameter. If the iop has evolved since then</a>
<a name="ln42">// the legacy circuitry will be called to convert the parameters.</a>
<a name="ln43">//</a>
<a name="ln44">// to add a new iop:</a>
<a name="ln45">// 1. copy the struct</a>
<a name="ln46">// 2. add LRDT_&lt;iop_name&gt;_VERSION with corresponding module version</a>
<a name="ln47">// 3. use this version to pass in dt_add_hist()</a>
<a name="ln48"> </a>
<a name="ln49">#define LRDT_CLIPPING_VERSION 4</a>
<a name="ln50">typedef struct dt_iop_clipping_params_t</a>
<a name="ln51">{</a>
<a name="ln52">  float angle, cx, cy, cw, ch, k_h, k_v;</a>
<a name="ln53">  float kxa, kya, kxb, kyb, kxc, kyc, kxd, kyd;</a>
<a name="ln54">  int k_type, k_sym;</a>
<a name="ln55">  int k_apply, crop_auto;</a>
<a name="ln56">} dt_iop_clipping_params_t;</a>
<a name="ln57"> </a>
<a name="ln58">#define LRDT_FLIP_VERSION 1</a>
<a name="ln59">typedef struct dt_iop_flip_params_t</a>
<a name="ln60">{</a>
<a name="ln61">  int32_t orientation;</a>
<a name="ln62">} dt_iop_flip_params_t;</a>
<a name="ln63"> </a>
<a name="ln64">#define LRDT_EXPOSURE_VERSION 2</a>
<a name="ln65">typedef struct dt_iop_exposure_params_t</a>
<a name="ln66">{</a>
<a name="ln67">  float black, exposure, gain;</a>
<a name="ln68">} dt_iop_exposure_params_t;</a>
<a name="ln69"> </a>
<a name="ln70">#define LRDT_GRAIN_VERSION 1</a>
<a name="ln71">typedef enum _dt_iop_grain_channel_t</a>
<a name="ln72">{</a>
<a name="ln73">  DT_GRAIN_CHANNEL_HUE = 0,</a>
<a name="ln74">  DT_GRAIN_CHANNEL_SATURATION,</a>
<a name="ln75">  DT_GRAIN_CHANNEL_LIGHTNESS,</a>
<a name="ln76">  DT_GRAIN_CHANNEL_RGB</a>
<a name="ln77">} _dt_iop_grain_channel_t;</a>
<a name="ln78"> </a>
<a name="ln79">typedef struct dt_iop_grain_params_t</a>
<a name="ln80">{</a>
<a name="ln81">  _dt_iop_grain_channel_t channel;</a>
<a name="ln82">  float scale;</a>
<a name="ln83">  float strength;</a>
<a name="ln84">} dt_iop_grain_params_t;</a>
<a name="ln85"> </a>
<a name="ln86">typedef enum dt_iop_dither_t</a>
<a name="ln87">{</a>
<a name="ln88">  DITHER_OFF = 0,</a>
<a name="ln89">  DITHER_8BIT = 1,</a>
<a name="ln90">  DITHER_16BIT = 2</a>
<a name="ln91">} dt_iop_dither_t;</a>
<a name="ln92"> </a>
<a name="ln93">typedef struct dt_iop_fvector_2d_t</a>
<a name="ln94">{</a>
<a name="ln95">  float x;</a>
<a name="ln96">  float y;</a>
<a name="ln97">} dt_iop_vector_2d_t;</a>
<a name="ln98"> </a>
<a name="ln99">#define LRDT_VIGNETTE_VERSION 3</a>
<a name="ln100">typedef struct dt_iop_vignette_params_t</a>
<a name="ln101">{</a>
<a name="ln102">  float scale;               // 0 - 100 Inner radius, percent of largest image dimension</a>
<a name="ln103">  float falloff_scale;       // 0 - 100 Radius for falloff -- outer radius = inner radius + falloff_scale</a>
<a name="ln104">  float brightness;          // -1 - 1 Strength of brightness reduction</a>
<a name="ln105">  float saturation;          // -1 - 1 Strength of saturation reduction</a>
<a name="ln106">  dt_iop_vector_2d_t center; // Center of vignette</a>
<a name="ln107">  gboolean autoratio;        //</a>
<a name="ln108">  float whratio;             // 0-1 = width/height ratio, 1-2 = height/width ratio + 1</a>
<a name="ln109">  float shape;</a>
<a name="ln110">  int dithering; // if and how to perform dithering</a>
<a name="ln111">} dt_iop_vignette_params_t;</a>
<a name="ln112"> </a>
<a name="ln113">#define LRDT_SPOTS_VERSION 1</a>
<a name="ln114">#define MAX_SPOTS 32</a>
<a name="ln115"> </a>
<a name="ln116">typedef struct spot_t</a>
<a name="ln117">{</a>
<a name="ln118">  // position of the spot</a>
<a name="ln119">  float x, y;</a>
<a name="ln120">  // position to clone from</a>
<a name="ln121">  float xc, yc;</a>
<a name="ln122">  float radius;</a>
<a name="ln123">} spot_t;</a>
<a name="ln124"> </a>
<a name="ln125">typedef struct dt_iop_spots_params_t</a>
<a name="ln126">{</a>
<a name="ln127">  int num_spots;</a>
<a name="ln128">  spot_t spot[MAX_SPOTS];</a>
<a name="ln129">} dt_iop_spots_params_t;</a>
<a name="ln130"> </a>
<a name="ln131">#define LRDT_TONECURVE_VERSION 3</a>
<a name="ln132">#define DT_IOP_TONECURVE_MAXNODES 20</a>
<a name="ln133">typedef enum tonecurve_channel_t</a>
<a name="ln134">{</a>
<a name="ln135">  ch_L = 0,</a>
<a name="ln136">  ch_a = 1,</a>
<a name="ln137">  ch_b = 2,</a>
<a name="ln138">  ch_max = 3</a>
<a name="ln139">} tonecurve_channel_t;</a>
<a name="ln140"> </a>
<a name="ln141">typedef struct dt_iop_tonecurve_node_t</a>
<a name="ln142">{</a>
<a name="ln143">  float x;</a>
<a name="ln144">  float y;</a>
<a name="ln145">} dt_iop_tonecurve_node_t;</a>
<a name="ln146"> </a>
<a name="ln147">typedef struct dt_iop_tonecurve_params_t</a>
<a name="ln148">{</a>
<a name="ln149">  dt_iop_tonecurve_node_t tonecurve[3][DT_IOP_TONECURVE_MAXNODES]; // three curves (L, a, b) with max number</a>
<a name="ln150">                                                                   // of nodes</a>
<a name="ln151">  int tonecurve_nodes[3];</a>
<a name="ln152">  int tonecurve_type[3];</a>
<a name="ln153">  int tonecurve_autoscale_ab;</a>
<a name="ln154">  int tonecurve_preset;</a>
<a name="ln155">} dt_iop_tonecurve_params_t;</a>
<a name="ln156"> </a>
<a name="ln157">#define LRDT_COLORZONES_VERSION 2</a>
<a name="ln158">#define DT_IOP_COLORZONES_BANDS 8</a>
<a name="ln159"> </a>
<a name="ln160">typedef enum dt_iop_colorzones_channel_t</a>
<a name="ln161">{</a>
<a name="ln162">  DT_IOP_COLORZONES_L = 0,</a>
<a name="ln163">  DT_IOP_COLORZONES_C = 1,</a>
<a name="ln164">  DT_IOP_COLORZONES_h = 2</a>
<a name="ln165">} dt_iop_colorzones_channel_t;</a>
<a name="ln166"> </a>
<a name="ln167">typedef struct dt_iop_colorzones_params_t</a>
<a name="ln168">{</a>
<a name="ln169">  int32_t channel;</a>
<a name="ln170">  float equalizer_x[3][DT_IOP_COLORZONES_BANDS], equalizer_y[3][DT_IOP_COLORZONES_BANDS];</a>
<a name="ln171">} dt_iop_colorzones_params_t;</a>
<a name="ln172"> </a>
<a name="ln173">#define LRDT_SPLITTONING_VERSION 1</a>
<a name="ln174">typedef struct dt_iop_splittoning_params_t</a>
<a name="ln175">{</a>
<a name="ln176">  float shadow_hue;</a>
<a name="ln177">  float shadow_saturation;</a>
<a name="ln178">  float highlight_hue;</a>
<a name="ln179">  float highlight_saturation;</a>
<a name="ln180">  float balance;  // center luminance of gradient</a>
<a name="ln181">  float compress; // Compress range</a>
<a name="ln182">} dt_iop_splittoning_params_t;</a>
<a name="ln183"> </a>
<a name="ln184">#define LRDT_BILAT_VERSION 1</a>
<a name="ln185">typedef struct dt_iop_bilat_params_t</a>
<a name="ln186">{</a>
<a name="ln187">  float sigma_r;</a>
<a name="ln188">  float sigma_s;</a>
<a name="ln189">  float detail;</a>
<a name="ln190">} dt_iop_bilat_params_t;</a>
<a name="ln191"> </a>
<a name="ln192"> </a>
<a name="ln193">#define LRDT_COLORIN_VERSION 1</a>
<a name="ln194">#define DT_IOP_COLOR_ICC_LEN 100</a>
<a name="ln195"> </a>
<a name="ln196">typedef struct dt_iop_colorin_params_t</a>
<a name="ln197">{</a>
<a name="ln198">  char iccprofile[DT_IOP_COLOR_ICC_LEN];</a>
<a name="ln199">  dt_iop_color_intent_t intent;</a>
<a name="ln200">} dt_iop_colorin_params_t;</a>
<a name="ln201"> </a>
<a name="ln202">//</a>
<a name="ln203">// end of iop structs</a>
<a name="ln204">//</a>
<a name="ln205"> </a>
<a name="ln206">// the blend params for Lr import, not used in this mode (mode=0), as for iop generate the blend params for</a>
<a name="ln207">// the</a>
<a name="ln208">// version specified above.</a>
<a name="ln209"> </a>
<a name="ln210">#define LRDT_BLEND_VERSION 4</a>
<a name="ln211">#define DEVELOP_BLENDIF_SIZE 16</a>
<a name="ln212"> </a>
<a name="ln213">typedef struct dt_develop_blend_params_t</a>
<a name="ln214">{</a>
<a name="ln215">  /** blending mode */</a>
<a name="ln216">  uint32_t mode;</a>
<a name="ln217">  /** mixing opacity */</a>
<a name="ln218">  float opacity;</a>
<a name="ln219">  /** id of mask in current pipeline */</a>
<a name="ln220">  uint32_t mask_id;</a>
<a name="ln221">  /** blendif mask */</a>
<a name="ln222">  uint32_t blendif;</a>
<a name="ln223">  /** blur radius */</a>
<a name="ln224">  float radius;</a>
<a name="ln225">  /** blendif parameters */</a>
<a name="ln226">  float blendif_parameters[4 * DEVELOP_BLENDIF_SIZE];</a>
<a name="ln227">} dt_develop_blend_params_t;</a>
<a name="ln228"> </a>
<a name="ln229">//</a>
<a name="ln230">// end of blend_params</a>
<a name="ln231">//</a>
<a name="ln232"> </a>
<a name="ln233">typedef struct lr2dt</a>
<a name="ln234">{</a>
<a name="ln235">  float lr, dt;</a>
<a name="ln236">} lr2dt_t;</a>
<a name="ln237"> </a>
<a name="ln238">char *dt_get_lightroom_xmp(int imgid)</a>
<a name="ln239">{</a>
<a name="ln240">  char pathname[DT_MAX_FILENAME_LEN];</a>
<a name="ln241">  gboolean from_cache = TRUE;</a>
<a name="ln242"> </a>
<a name="ln243">  // Get full pathname</a>
<a name="ln244">  dt_image_full_path(imgid, pathname, DT_MAX_FILENAME_LEN, &amp;from_cache);</a>
<a name="ln245"> </a>
<a name="ln246">  // Look for extension</a>
<a name="ln247">  char *pos = strrchr(pathname, '.');</a>
<a name="ln248"> </a>
<a name="ln249">  if(pos == NULL)</a>
<a name="ln250">    return NULL;</a>
<a name="ln251"> </a>
<a name="ln252">  // If found, replace extension with xmp</a>
<a name="ln253">  strncpy(pos + 1, &quot;xmp&quot;, 4);</a>
<a name="ln254">  if(g_file_test(pathname, G_FILE_TEST_EXISTS))</a>
<a name="ln255">    return g_strdup(pathname);</a>
<a name="ln256"> </a>
<a name="ln257">  strncpy(pos + 1, &quot;XMP&quot;, 4);</a>
<a name="ln258">  if(g_file_test(pathname, G_FILE_TEST_EXISTS))</a>
<a name="ln259">    return g_strdup(pathname);</a>
<a name="ln260"> </a>
<a name="ln261">  return NULL;</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264">static float get_interpolate(lr2dt_t lr2dt_table[], float value)</a>
<a name="ln265">{</a>
<a name="ln266">  int k = 0;</a>
<a name="ln267"> </a>
<a name="ln268">  while(lr2dt_table[k + 1].lr &lt; value) k++;</a>
<a name="ln269"> </a>
<a name="ln270">  return lr2dt_table[k].dt</a>
<a name="ln271">         + ((value - lr2dt_table[k].lr) / (lr2dt_table[k + 1].lr - lr2dt_table[k].lr))</a>
<a name="ln272">           * (lr2dt_table[k + 1].dt - lr2dt_table[k].dt);</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">static float lr2dt_blacks(float value)</a>
<a name="ln276">{</a>
<a name="ln277">  lr2dt_t lr2dt_blacks_table[]</a>
<a name="ln278">      = { { -100, 0.020 }, { -50, 0.005 }, { 0, 0 }, { 50, -0.005 }, { 100, -0.010 } };</a>
<a name="ln279"> </a>
<a name="ln280">  return get_interpolate(lr2dt_blacks_table, value);</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">static float lr2dt_vignette_gain(float value)</a>
<a name="ln284">{</a>
<a name="ln285">  lr2dt_t lr2dt_vignette_table[] = { { -100, -1 }, { -50, -0.7 }, { 0, 0 }, { 50, 0.5 }, { 100, 1 } };</a>
<a name="ln286"> </a>
<a name="ln287">  return get_interpolate(lr2dt_vignette_table, value);</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">static float lr2dt_vignette_midpoint(float value)</a>
<a name="ln291">{</a>
<a name="ln292">  lr2dt_t lr2dt_vignette_table[] = { { 0, 74 }, { 4, 75 }, { 25, 85 }, { 50, 100 }, { 100, 100 } };</a>
<a name="ln293"> </a>
<a name="ln294">  return get_interpolate(lr2dt_vignette_table, value);</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">static float lr2dt_grain_amount(float value)</a>
<a name="ln298">{</a>
<a name="ln299">  lr2dt_t lr2dt_grain_table[] = { { 0, 0 }, { 25, 20 }, { 50, 40 }, { 100, 80 } };</a>
<a name="ln300"> </a>
<a name="ln301">  return get_interpolate(lr2dt_grain_table, value);</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">static float lr2dt_grain_frequency(float value)</a>
<a name="ln305">{</a>
<a name="ln306">  lr2dt_t lr2dt_grain_table[] = { { 0, 100 }, { 50, 100 }, { 75, 400 }, { 100, 800 } };</a>
<a name="ln307"> </a>
<a name="ln308">  return get_interpolate(lr2dt_grain_table, value) / 53.3;</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311">static float lr2dt_splittoning_balance(float value)</a>
<a name="ln312">{</a>
<a name="ln313">  lr2dt_t lr2dt_splittoning_table[] = { { -100, 100 }, { 0, 0 }, { 100, 0 } };</a>
<a name="ln314"> </a>
<a name="ln315">  return get_interpolate(lr2dt_splittoning_table, value);</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">static float lr2dt_clarity(float value)</a>
<a name="ln319">{</a>
<a name="ln320">  lr2dt_t lr2dt_clarity_table[] = { { -100, -.650 }, { 0, 0 }, { 100, .650 } };</a>
<a name="ln321"> </a>
<a name="ln322">  return get_interpolate(lr2dt_clarity_table, value);</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">static void dt_add_hist(int imgid, char *operation, dt_iop_params_t *params, int params_size, char *imported,</a>
<a name="ln326">                        size_t imported_len, int version, int *import_count)</a>
<a name="ln327">{</a>
<a name="ln328">  int32_t num = 0;</a>
<a name="ln329">  dt_develop_blend_params_t blend_params = { 0 };</a>
<a name="ln330"> </a>
<a name="ln331">  //  get current num if any</a>
<a name="ln332">  sqlite3_stmt *stmt;</a>
<a name="ln333">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln334">                              &quot;SELECT COUNT(*) FROM main.history WHERE imgid = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln335">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln336">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln337">  {</a>
<a name="ln338">    num = sqlite3_column_int(stmt, 0);</a>
<a name="ln339">  }</a>
<a name="ln340">  sqlite3_finalize(stmt);</a>
<a name="ln341"> </a>
<a name="ln342">  // add new history info</a>
<a name="ln343">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln344">                              &quot;INSERT INTO main.history (imgid, num, module, operation, op_params, enabled, &quot;</a>
<a name="ln345">                              &quot;blendop_params, blendop_version, multi_priority, multi_name) &quot;</a>
<a name="ln346">                              &quot;VALUES (?1, ?2, ?3, ?4, ?5, 1, ?6, ?7, 0, ' ')&quot;,</a>
<a name="ln347">                              -1, &amp;stmt, NULL);</a>
<a name="ln348">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln349">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, num);</a>
<a name="ln350">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, version);</a>
<a name="ln351">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, operation, -1, SQLITE_TRANSIENT);</a>
<a name="ln352">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 5, params, params_size, SQLITE_TRANSIENT);</a>
<a name="ln353">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 6, &amp;blend_params, sizeof(dt_develop_blend_params_t), SQLITE_TRANSIENT);</a>
<a name="ln354">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 7, LRDT_BLEND_VERSION);</a>
<a name="ln355"> </a>
<a name="ln356">  sqlite3_step(stmt);</a>
<a name="ln357">  sqlite3_finalize(stmt);</a>
<a name="ln358"> </a>
<a name="ln359">  // also bump history_end</a>
<a name="ln360">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln361">                              &quot;UPDATE main.images SET history_end = (SELECT IFNULL(MAX(num) + 1, 0) FROM &quot;</a>
<a name="ln362">                              &quot;main.history WHERE imgid = ?1) WHERE id = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln363">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln364">  sqlite3_step(stmt);</a>
<a name="ln365">  sqlite3_finalize(stmt);</a>
<a name="ln366"> </a>
<a name="ln367">  if(imported[0]) g_strlcat(imported, &quot;, &quot;, imported_len);</a>
<a name="ln368">  g_strlcat(imported, dt_iop_get_localized_name(operation), imported_len);</a>
<a name="ln369">  (*import_count)++;</a>
<a name="ln370">}</a>
<a name="ln371"> </a>
<a name="ln372">#define MAX_PTS 20</a>
<a name="ln373"> </a>
<a name="ln374">typedef enum lr_curve_kind_t</a>
<a name="ln375">{</a>
<a name="ln376">  linear = 0,</a>
<a name="ln377">  medium_contrast = 1,</a>
<a name="ln378">  strong_contrast = 2,</a>
<a name="ln379">  custom = 3</a>
<a name="ln380">} lr_curve_kind_t;</a>
<a name="ln381"> </a>
<a name="ln382">typedef struct lr_data_t</a>
<a name="ln383">{</a>
<a name="ln384">  dt_iop_clipping_params_t pc;</a>
<a name="ln385">  gboolean has_crop;</a>
<a name="ln386"> </a>
<a name="ln387">  dt_iop_flip_params_t pf;</a>
<a name="ln388">  gboolean has_flip;</a>
<a name="ln389"> </a>
<a name="ln390">  dt_iop_exposure_params_t pe;</a>
<a name="ln391">  gboolean has_exposure;</a>
<a name="ln392"> </a>
<a name="ln393">  dt_iop_vignette_params_t pv;</a>
<a name="ln394">  gboolean has_vignette;</a>
<a name="ln395"> </a>
<a name="ln396">  dt_iop_grain_params_t pg;</a>
<a name="ln397">  gboolean has_grain;</a>
<a name="ln398"> </a>
<a name="ln399">  dt_iop_spots_params_t ps;</a>
<a name="ln400">  gboolean has_spots;</a>
<a name="ln401"> </a>
<a name="ln402">  dt_iop_tonecurve_params_t ptc;</a>
<a name="ln403">  int ptc_value[4];</a>
<a name="ln404">  float ptc_split[3];</a>
<a name="ln405">  lr_curve_kind_t curve_kind;</a>
<a name="ln406">  int curve_pts[MAX_PTS][2];</a>
<a name="ln407">  int n_pts;</a>
<a name="ln408"> </a>
<a name="ln409">  dt_iop_colorzones_params_t pcz;</a>
<a name="ln410">  gboolean has_colorzones;</a>
<a name="ln411"> </a>
<a name="ln412">  dt_iop_splittoning_params_t pst;</a>
<a name="ln413">  gboolean has_splittoning;</a>
<a name="ln414"> </a>
<a name="ln415">  dt_iop_bilat_params_t pbl;</a>
<a name="ln416">  gboolean has_bilat;</a>
<a name="ln417"> </a>
<a name="ln418">  gboolean has_tags;</a>
<a name="ln419"> </a>
<a name="ln420">  int rating;</a>
<a name="ln421">  gboolean has_rating;</a>
<a name="ln422"> </a>
<a name="ln423">  gdouble lat, lon;</a>
<a name="ln424">  gboolean has_gps;</a>
<a name="ln425"> </a>
<a name="ln426">  int color;</a>
<a name="ln427">  gboolean has_colorlabel;</a>
<a name="ln428"> </a>
<a name="ln429">  float fratio;                // factor ratio image</a>
<a name="ln430">  float crop_roundness;        // from lightroom</a>
<a name="ln431">  int iwidth, iheight;         // image width / height</a>
<a name="ln432">  int orientation;</a>
<a name="ln433">} lr_data_t;</a>
<a name="ln434"> </a>
<a name="ln435">// three helper functions for parsing RetouchInfo entries. sscanf doesn't work due to floats.</a>
<a name="ln436">static gboolean _read_float(const char **startptr, const char *key, float *value)</a>
<a name="ln437">{</a>
<a name="ln438">  const char *iter = *startptr;</a>
<a name="ln439">  while(*iter == ' ') iter++;</a>
<a name="ln440">  if(!g_str_has_prefix(iter, key))</a>
<a name="ln441">    return FALSE;</a>
<a name="ln442">  iter += strlen(key);</a>
<a name="ln443">  while(*iter == ' ') iter++;</a>
<a name="ln444">  if(*iter++ != '=')</a>
<a name="ln445">    return FALSE;</a>
<a name="ln446">  while(*iter == ' ') iter++;</a>
<a name="ln447">  *value = g_ascii_strtod(iter, (char **)startptr);</a>
<a name="ln448">  return iter != *startptr;</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">static gboolean _skip_key_value_pair(const char **startptr, const char *key)</a>
<a name="ln452">{</a>
<a name="ln453">  const char *iter = *startptr;</a>
<a name="ln454">  while(*iter == ' ') iter++;</a>
<a name="ln455">  if(!g_str_has_prefix(iter, key))</a>
<a name="ln456">    return FALSE;</a>
<a name="ln457">  iter += strlen(key);</a>
<a name="ln458">  while(*iter == ' ') iter++;</a>
<a name="ln459">  if(*iter++ != '=')</a>
<a name="ln460">    return FALSE;</a>
<a name="ln461">  while(*iter == ' ') iter++;</a>
<a name="ln462">  while((*iter &gt;= 'a' &amp;&amp; *iter &lt;= 'z') || (*iter &gt;= 'A' &amp;&amp; *iter &lt;= 'Z')) iter++;</a>
<a name="ln463">  *startptr = iter;</a>
<a name="ln464">  return TRUE;</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">static gboolean _skip_comma(const char **startptr)</a>
<a name="ln468">{</a>
<a name="ln469">  return *(*startptr)++ == ',';</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">/* lrop handle the Lr operation and convert it as a dt iop */</a>
<a name="ln473">static void _lrop(const dt_develop_t *dev, const xmlDocPtr doc, const int imgid,</a>
<a name="ln474">                  const xmlChar *name, const xmlChar *value, const xmlNodePtr node, lr_data_t *data)</a>
<a name="ln475">{</a>
<a name="ln476">  const float hfactor = 3.0 / 9.0; // hue factor adjustment (use 3 out of 9 boxes in colorzones)</a>
<a name="ln477">  const float lfactor = 4.0 / 9.0; // lightness factor adjustment (use 4 out of 9 boxes in colorzones)</a>
<a name="ln478"> </a>
<a name="ln479">  if(value)</a>
<a name="ln480">  {</a>
<a name="ln481">    if(!xmlStrcmp(name, (const xmlChar *)&quot;CropTop&quot;))</a>
<a name="ln482">      data-&gt;pc.cy = g_ascii_strtod((char *)value, NULL);</a>
<a name="ln483">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;CropRight&quot;))</a>
<a name="ln484">      data-&gt;pc.cw = g_ascii_strtod((char *)value, NULL);</a>
<a name="ln485">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;CropLeft&quot;))</a>
<a name="ln486">      data-&gt;pc.cx = g_ascii_strtod((char *)value, NULL);</a>
<a name="ln487">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;CropBottom&quot;))</a>
<a name="ln488">      data-&gt;pc.ch = g_ascii_strtod((char *)value, NULL);</a>
<a name="ln489">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;CropAngle&quot;))</a>
<a name="ln490">      data-&gt;pc.angle = -g_ascii_strtod((char *)value, NULL);</a>
<a name="ln491">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ImageWidth&quot;))</a>
<a name="ln492">      data-&gt;iwidth = atoi((char *)value);</a>
<a name="ln493">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ImageLength&quot;))</a>
<a name="ln494">      data-&gt;iheight = atoi((char *)value);</a>
<a name="ln495">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;Orientation&quot;))</a>
<a name="ln496">    {</a>
<a name="ln497">      data-&gt;orientation = atoi((char *)value);</a>
<a name="ln498">      if(dev != NULL &amp;&amp; ((dev-&gt;image_storage.orientation == 6 &amp;&amp; data-&gt;orientation != 6)</a>
<a name="ln499">                        || (dev-&gt;image_storage.orientation == 5 &amp;&amp; data-&gt;orientation != 8)</a>
<a name="ln500">                        || (dev-&gt;image_storage.orientation == 0 &amp;&amp; data-&gt;orientation != 1)))</a>
<a name="ln501">        data-&gt;has_flip = TRUE;</a>
<a name="ln502">    }</a>
<a name="ln503">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HasCrop&quot;))</a>
<a name="ln504">    {</a>
<a name="ln505">      if(!xmlStrcmp(value, (const xmlChar *)&quot;True&quot;)) data-&gt;has_crop = TRUE;</a>
<a name="ln506">    }</a>
<a name="ln507">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;Blacks2012&quot;))</a>
<a name="ln508">    {</a>
<a name="ln509">      int v = atoi((char *)value);</a>
<a name="ln510">      if(v != 0)</a>
<a name="ln511">      {</a>
<a name="ln512">        data-&gt;has_exposure = TRUE;</a>
<a name="ln513">        data-&gt;pe.black = lr2dt_blacks((float)v);</a>
<a name="ln514">      }</a>
<a name="ln515">    }</a>
<a name="ln516">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;Exposure2012&quot;))</a>
<a name="ln517">    {</a>
<a name="ln518">      float v = g_ascii_strtod((char *)value, NULL);</a>
<a name="ln519">      if(v != 0.0)</a>
<a name="ln520">      {</a>
<a name="ln521">        data-&gt;has_exposure = TRUE;</a>
<a name="ln522">        data-&gt;pe.exposure = v;</a>
<a name="ln523">      }</a>
<a name="ln524">    }</a>
<a name="ln525">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;PostCropVignetteAmount&quot;))</a>
<a name="ln526">    {</a>
<a name="ln527">      int v = atoi((char *)value);</a>
<a name="ln528">      if(v != 0)</a>
<a name="ln529">      {</a>
<a name="ln530">        data-&gt;has_vignette = TRUE;</a>
<a name="ln531">        data-&gt;pv.brightness = lr2dt_vignette_gain((float)v);</a>
<a name="ln532">      }</a>
<a name="ln533">    }</a>
<a name="ln534">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;PostCropVignetteMidpoint&quot;))</a>
<a name="ln535">    {</a>
<a name="ln536">      int v = atoi((char *)value);</a>
<a name="ln537">      data-&gt;pv.scale = lr2dt_vignette_midpoint((float)v);</a>
<a name="ln538">    }</a>
<a name="ln539">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;PostCropVignetteStyle&quot;))</a>
<a name="ln540">    {</a>
<a name="ln541">      int v = atoi((char *)value);</a>
<a name="ln542">      if(v == 1) // Highlight Priority</a>
<a name="ln543">        data-&gt;pv.saturation = -0.300;</a>
<a name="ln544">      else // Color Priority &amp; Paint Overlay</a>
<a name="ln545">        data-&gt;pv.saturation = -0.200;</a>
<a name="ln546">    }</a>
<a name="ln547">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;PostCropVignetteFeather&quot;))</a>
<a name="ln548">    {</a>
<a name="ln549">      int v = atoi((char *)value);</a>
<a name="ln550">      if(v != 0) data-&gt;pv.falloff_scale = (float)v;</a>
<a name="ln551">    }</a>
<a name="ln552">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;PostCropVignetteRoundness&quot;))</a>
<a name="ln553">    {</a>
<a name="ln554">      int v = atoi((char *)value);</a>
<a name="ln555">      data-&gt;crop_roundness = (float)v;</a>
<a name="ln556">    }</a>
<a name="ln557">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;GrainAmount&quot;))</a>
<a name="ln558">    {</a>
<a name="ln559">      int v = atoi((char *)value);</a>
<a name="ln560">      if(v != 0)</a>
<a name="ln561">      {</a>
<a name="ln562">        data-&gt;has_grain = TRUE;</a>
<a name="ln563">        data-&gt;pg.strength = lr2dt_grain_amount((float)v);</a>
<a name="ln564">      }</a>
<a name="ln565">    }</a>
<a name="ln566">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;GrainFrequency&quot;))</a>
<a name="ln567">    {</a>
<a name="ln568">      int v = atoi((char *)value);</a>
<a name="ln569">      if(v != 0) data-&gt;pg.scale = lr2dt_grain_frequency((float)v);</a>
<a name="ln570">    }</a>
<a name="ln571">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricShadows&quot;))</a>
<a name="ln572">    {</a>
<a name="ln573">      data-&gt;ptc_value[0] = atoi((char *)value);</a>
<a name="ln574">    }</a>
<a name="ln575">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricDarks&quot;))</a>
<a name="ln576">    {</a>
<a name="ln577">      data-&gt;ptc_value[1] = atoi((char *)value);</a>
<a name="ln578">    }</a>
<a name="ln579">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricLights&quot;))</a>
<a name="ln580">    {</a>
<a name="ln581">      data-&gt;ptc_value[2] = atoi((char *)value);</a>
<a name="ln582">    }</a>
<a name="ln583">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricHighlights&quot;))</a>
<a name="ln584">    {</a>
<a name="ln585">      data-&gt;ptc_value[3] = atoi((char *)value);</a>
<a name="ln586">    }</a>
<a name="ln587">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricShadowSplit&quot;))</a>
<a name="ln588">    {</a>
<a name="ln589">      data-&gt;ptc_split[0] = g_ascii_strtod((char *)value, NULL) / 100.0;</a>
<a name="ln590">    }</a>
<a name="ln591">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricMidtoneSplit&quot;))</a>
<a name="ln592">    {</a>
<a name="ln593">      data-&gt;ptc_split[1] = g_ascii_strtod((char *)value, NULL) / 100.0;</a>
<a name="ln594">    }</a>
<a name="ln595">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ParametricHighlightSplit&quot;))</a>
<a name="ln596">    {</a>
<a name="ln597">      data-&gt;ptc_split[2] = g_ascii_strtod((char *)value, NULL) / 100.0;</a>
<a name="ln598">    }</a>
<a name="ln599">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;ToneCurveName2012&quot;))</a>
<a name="ln600">    {</a>
<a name="ln601">      if(!xmlStrcmp(value, (const xmlChar *)&quot;Linear&quot;))</a>
<a name="ln602">        data-&gt;curve_kind = linear;</a>
<a name="ln603">      else if(!xmlStrcmp(value, (const xmlChar *)&quot;Medium Contrast&quot;))</a>
<a name="ln604">        data-&gt;curve_kind = medium_contrast;</a>
<a name="ln605">      else if(!xmlStrcmp(value, (const xmlChar *)&quot;Strong Contrast&quot;))</a>
<a name="ln606">        data-&gt;curve_kind = strong_contrast;</a>
<a name="ln607">      else if(!xmlStrcmp(value, (const xmlChar *)&quot;Custom&quot;))</a>
<a name="ln608">        data-&gt;curve_kind = custom;</a>
<a name="ln609">    }</a>
<a name="ln610">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentRed&quot;))</a>
<a name="ln611">    {</a>
<a name="ln612">      int v = atoi((char *)value);</a>
<a name="ln613">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln614">      data-&gt;pcz.equalizer_y[1][0] = 0.5 + (float)v / 200.0;</a>
<a name="ln615">    }</a>
<a name="ln616">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentOrange&quot;))</a>
<a name="ln617">    {</a>
<a name="ln618">      int v = atoi((char *)value);</a>
<a name="ln619">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln620">      data-&gt;pcz.equalizer_y[1][1] = 0.5 + (float)v / 200.0;</a>
<a name="ln621">    }</a>
<a name="ln622">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentYellow&quot;))</a>
<a name="ln623">    {</a>
<a name="ln624">      int v = atoi((char *)value);</a>
<a name="ln625">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln626">      data-&gt;pcz.equalizer_y[1][2] = 0.5 + (float)v / 200.0;</a>
<a name="ln627">    }</a>
<a name="ln628">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentGreen&quot;))</a>
<a name="ln629">    {</a>
<a name="ln630">      int v = atoi((char *)value);</a>
<a name="ln631">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln632">      data-&gt;pcz.equalizer_y[1][3] = 0.5 + (float)v / 200.0;</a>
<a name="ln633">    }</a>
<a name="ln634">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentAqua&quot;))</a>
<a name="ln635">    {</a>
<a name="ln636">      int v = atoi((char *)value);</a>
<a name="ln637">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln638">      data-&gt;pcz.equalizer_y[1][4] = 0.5 + (float)v / 200.0;</a>
<a name="ln639">    }</a>
<a name="ln640">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentBlue&quot;))</a>
<a name="ln641">    {</a>
<a name="ln642">      int v = atoi((char *)value);</a>
<a name="ln643">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln644">      data-&gt;pcz.equalizer_y[1][5] = 0.5 + (float)v / 200.0;</a>
<a name="ln645">    }</a>
<a name="ln646">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentPurple&quot;))</a>
<a name="ln647">    {</a>
<a name="ln648">      int v = atoi((char *)value);</a>
<a name="ln649">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln650">      data-&gt;pcz.equalizer_y[1][6] = 0.5 + (float)v / 200.0;</a>
<a name="ln651">    }</a>
<a name="ln652">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SaturationAdjustmentMagenta&quot;))</a>
<a name="ln653">    {</a>
<a name="ln654">      int v = atoi((char *)value);</a>
<a name="ln655">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln656">      data-&gt;pcz.equalizer_y[1][7] = 0.5 + (float)v / 200.0;</a>
<a name="ln657">    }</a>
<a name="ln658">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentRed&quot;))</a>
<a name="ln659">    {</a>
<a name="ln660">      int v = atoi((char *)value);</a>
<a name="ln661">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln662">      data-&gt;pcz.equalizer_y[0][0] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln663">    }</a>
<a name="ln664">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentOrange&quot;))</a>
<a name="ln665">    {</a>
<a name="ln666">      int v = atoi((char *)value);</a>
<a name="ln667">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln668">      data-&gt;pcz.equalizer_y[0][1] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln669">    }</a>
<a name="ln670">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentYellow&quot;))</a>
<a name="ln671">    {</a>
<a name="ln672">      int v = atoi((char *)value);</a>
<a name="ln673">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln674">      data-&gt;pcz.equalizer_y[0][2] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln675">    }</a>
<a name="ln676">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentGreen&quot;))</a>
<a name="ln677">    {</a>
<a name="ln678">      int v = atoi((char *)value);</a>
<a name="ln679">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln680">      data-&gt;pcz.equalizer_y[0][3] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln681">    }</a>
<a name="ln682">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentAqua&quot;))</a>
<a name="ln683">    {</a>
<a name="ln684">      int v = atoi((char *)value);</a>
<a name="ln685">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln686">      data-&gt;pcz.equalizer_y[0][4] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln687">    }</a>
<a name="ln688">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentBlue&quot;))</a>
<a name="ln689">    {</a>
<a name="ln690">      int v = atoi((char *)value);</a>
<a name="ln691">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln692">      data-&gt;pcz.equalizer_y[0][5] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln693">    }</a>
<a name="ln694">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentPurple&quot;))</a>
<a name="ln695">    {</a>
<a name="ln696">      int v = atoi((char *)value);</a>
<a name="ln697">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln698">      data-&gt;pcz.equalizer_y[0][6] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln699">    }</a>
<a name="ln700">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;LuminanceAdjustmentMagenta&quot;))</a>
<a name="ln701">    {</a>
<a name="ln702">      int v = atoi((char *)value);</a>
<a name="ln703">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln704">      data-&gt;pcz.equalizer_y[0][7] = 0.5 + lfactor * (float)v / 200.0;</a>
<a name="ln705">    }</a>
<a name="ln706">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentRed&quot;))</a>
<a name="ln707">    {</a>
<a name="ln708">      int v = atoi((char *)value);</a>
<a name="ln709">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln710">      data-&gt;pcz.equalizer_y[2][0] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln711">    }</a>
<a name="ln712">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentOrange&quot;))</a>
<a name="ln713">    {</a>
<a name="ln714">      int v = atoi((char *)value);</a>
<a name="ln715">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln716">      data-&gt;pcz.equalizer_y[2][1] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln717">    }</a>
<a name="ln718">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentYellow&quot;))</a>
<a name="ln719">    {</a>
<a name="ln720">      int v = atoi((char *)value);</a>
<a name="ln721">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln722">      data-&gt;pcz.equalizer_y[2][2] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln723">    }</a>
<a name="ln724">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentGreen&quot;))</a>
<a name="ln725">    {</a>
<a name="ln726">      int v = atoi((char *)value);</a>
<a name="ln727">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln728">      data-&gt;pcz.equalizer_y[2][3] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln729">    }</a>
<a name="ln730">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentAqua&quot;))</a>
<a name="ln731">    {</a>
<a name="ln732">      int v = atoi((char *)value);</a>
<a name="ln733">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln734">      data-&gt;pcz.equalizer_y[2][4] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln735">    }</a>
<a name="ln736">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentBlue&quot;))</a>
<a name="ln737">    {</a>
<a name="ln738">      int v = atoi((char *)value);</a>
<a name="ln739">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln740">      data-&gt;pcz.equalizer_y[2][5] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln741">    }</a>
<a name="ln742">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentPurple&quot;))</a>
<a name="ln743">    {</a>
<a name="ln744">      int v = atoi((char *)value);</a>
<a name="ln745">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln746">      data-&gt;pcz.equalizer_y[2][6] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln747">    }</a>
<a name="ln748">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;HueAdjustmentMagenta&quot;))</a>
<a name="ln749">    {</a>
<a name="ln750">      int v = atoi((char *)value);</a>
<a name="ln751">      if(v != 0) data-&gt;has_colorzones = TRUE;</a>
<a name="ln752">      data-&gt;pcz.equalizer_y[2][7] = 0.5 + hfactor * (float)v / 200.0;</a>
<a name="ln753">    }</a>
<a name="ln754">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SplitToningShadowHue&quot;))</a>
<a name="ln755">    {</a>
<a name="ln756">      int v = atoi((char *)value);</a>
<a name="ln757">      if(v != 0) data-&gt;has_splittoning = TRUE;</a>
<a name="ln758">      data-&gt;pst.shadow_hue = (float)v / 255.0;</a>
<a name="ln759">    }</a>
<a name="ln760">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SplitToningShadowSaturation&quot;))</a>
<a name="ln761">    {</a>
<a name="ln762">      int v = atoi((char *)value);</a>
<a name="ln763">      if(v != 0) data-&gt;has_splittoning = TRUE;</a>
<a name="ln764">      data-&gt;pst.shadow_saturation = (float)v / 100.0;</a>
<a name="ln765">    }</a>
<a name="ln766">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SplitToningHighlightHue&quot;))</a>
<a name="ln767">    {</a>
<a name="ln768">      int v = atoi((char *)value);</a>
<a name="ln769">      if(v != 0) data-&gt;has_splittoning = TRUE;</a>
<a name="ln770">      data-&gt;pst.highlight_hue = (float)v / 255.0;</a>
<a name="ln771">    }</a>
<a name="ln772">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SplitToningHighlightSaturation&quot;))</a>
<a name="ln773">    {</a>
<a name="ln774">      int v = atoi((char *)value);</a>
<a name="ln775">      if(v != 0) data-&gt;has_splittoning = TRUE;</a>
<a name="ln776">      data-&gt;pst.highlight_saturation = (float)v / 100.0;</a>
<a name="ln777">    }</a>
<a name="ln778">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;SplitToningBalance&quot;))</a>
<a name="ln779">    {</a>
<a name="ln780">      float v = g_ascii_strtod((char *)value, NULL);</a>
<a name="ln781">      data-&gt;pst.balance = lr2dt_splittoning_balance(v);</a>
<a name="ln782">    }</a>
<a name="ln783">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;Clarity2012&quot;))</a>
<a name="ln784">    {</a>
<a name="ln785">      int v = atoi((char *)value);</a>
<a name="ln786">      if(v != 0)</a>
<a name="ln787">      {</a>
<a name="ln788">        data-&gt;has_bilat = TRUE;</a>
<a name="ln789">        data-&gt;pbl.detail = lr2dt_clarity((float)v);</a>
<a name="ln790">      }</a>
<a name="ln791">    }</a>
<a name="ln792">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;Rating&quot;))</a>
<a name="ln793">    {</a>
<a name="ln794">      int v = atoi((char *)value);</a>
<a name="ln795">      if(v != 0)</a>
<a name="ln796">      {</a>
<a name="ln797">        data-&gt;rating = v;</a>
<a name="ln798">        data-&gt;has_rating = TRUE;</a>
<a name="ln799">      }</a>
<a name="ln800">    }</a>
<a name="ln801">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;GPSLatitude&quot;))</a>
<a name="ln802">    {</a>
<a name="ln803">      double latitude = dt_util_gps_string_to_number((const char *)value);</a>
<a name="ln804">      if(!isnan(latitude))</a>
<a name="ln805">      {</a>
<a name="ln806">        data-&gt;lat = latitude;</a>
<a name="ln807">        data-&gt;has_gps = TRUE;</a>
<a name="ln808">      }</a>
<a name="ln809">    }</a>
<a name="ln810">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;GPSLongitude&quot;))</a>
<a name="ln811">    {</a>
<a name="ln812">      double longitude = dt_util_gps_string_to_number((const char *)value);</a>
<a name="ln813">      if(!isnan(longitude))</a>
<a name="ln814">      {</a>
<a name="ln815">        data-&gt;lon = longitude;</a>
<a name="ln816">        data-&gt;has_gps = TRUE;</a>
<a name="ln817">      }</a>
<a name="ln818">    }</a>
<a name="ln819">    else if(!xmlStrcmp(name, (const xmlChar *)&quot;Label&quot;))</a>
<a name="ln820">    {</a>
<a name="ln821">      char *v = g_utf8_casefold((char *)value, -1);</a>
<a name="ln822">      if(!g_strcmp0(v, _(&quot;red&quot;)))</a>
<a name="ln823">        data-&gt;color = 0;</a>
<a name="ln824">      else if(!g_strcmp0(v, _(&quot;yellow&quot;)))</a>
<a name="ln825">        data-&gt;color = 1;</a>
<a name="ln826">      else if(!g_strcmp0(v, _(&quot;green&quot;)))</a>
<a name="ln827">        data-&gt;color = 2;</a>
<a name="ln828">      else if(!g_strcmp0(v, _(&quot;blue&quot;)))</a>
<a name="ln829">        data-&gt;color = 3;</a>
<a name="ln830">      else</a>
<a name="ln831">        // just an else here to catch all other cases as on lightroom one can</a>
<a name="ln832">        // change the names of labels. So purple and the user's defined labels</a>
<a name="ln833">        // will be mapped to purple on darktable.</a>
<a name="ln834">        data-&gt;color = 4;</a>
<a name="ln835"> </a>
<a name="ln836">      data-&gt;has_colorlabel = TRUE;</a>
<a name="ln837">      g_free(v);</a>
<a name="ln838">    }</a>
<a name="ln839">  }</a>
<a name="ln840">  if(dev == NULL &amp;&amp; (!xmlStrcmp(name, (const xmlChar *)&quot;subject&quot;)</a>
<a name="ln841">                     || !xmlStrcmp(name, (const xmlChar *)&quot;hierarchicalSubject&quot;)))</a>
<a name="ln842">  {</a>
<a name="ln843">    xmlNodePtr tagNode = node;</a>
<a name="ln844"> </a>
<a name="ln845">    while(tagNode)</a>
<a name="ln846">    {</a>
<a name="ln847">      if(!xmlStrcmp(tagNode-&gt;name, (const xmlChar *)&quot;li&quot;))</a>
<a name="ln848">      {</a>
<a name="ln849">        xmlChar *cvalue = xmlNodeListGetString(doc, tagNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln850">        guint tagid = 0;</a>
<a name="ln851">        if(!dt_tag_exists((char *)cvalue, &amp;tagid)) dt_tag_new((char *)cvalue, &amp;tagid);</a>
<a name="ln852"> </a>
<a name="ln853">        dt_tag_attach(tagid, imgid);</a>
<a name="ln854">        data-&gt;has_tags = TRUE;</a>
<a name="ln855">        xmlFree(cvalue);</a>
<a name="ln856">      }</a>
<a name="ln857">      tagNode = tagNode-&gt;next;</a>
<a name="ln858">    }</a>
<a name="ln859">  }</a>
<a name="ln860">  else if(dev != NULL &amp;&amp; !xmlStrcmp(name, (const xmlChar *)&quot;RetouchInfo&quot;))</a>
<a name="ln861">  {</a>
<a name="ln862">    xmlNodePtr riNode = node;</a>
<a name="ln863"> </a>
<a name="ln864">    while(riNode)</a>
<a name="ln865">    {</a>
<a name="ln866">      if(!xmlStrcmp(riNode-&gt;name, (const xmlChar *)&quot;li&quot;))</a>
<a name="ln867">      {</a>
<a name="ln868">        xmlChar *cvalue = xmlNodeListGetString(doc, riNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln869">        spot_t *p = &amp;data-&gt;ps.spot[data-&gt;ps.num_spots];</a>
<a name="ln870">        float x, y, radius, xc, yc;</a>
<a name="ln871">        const char *startptr = (const char *)cvalue;</a>
<a name="ln872">        if(_read_float(&amp;startptr, &quot;centerX&quot;, &amp;x) &amp;&amp;</a>
<a name="ln873">           _skip_comma(&amp;startptr) &amp;&amp;</a>
<a name="ln874">           _read_float(&amp;startptr, &quot;centerY&quot;, &amp;y) &amp;&amp;</a>
<a name="ln875">           _skip_comma(&amp;startptr) &amp;&amp;</a>
<a name="ln876">           _read_float(&amp;startptr, &quot;radius&quot;, &amp;radius) &amp;&amp;</a>
<a name="ln877">           _skip_comma(&amp;startptr) &amp;&amp;</a>
<a name="ln878">           _skip_key_value_pair(&amp;startptr, &quot;sourceState&quot;) &amp;&amp;</a>
<a name="ln879">           _skip_comma(&amp;startptr) &amp;&amp;</a>
<a name="ln880">           _read_float(&amp;startptr, &quot;sourceX&quot;, &amp;xc) &amp;&amp;</a>
<a name="ln881">           _skip_comma(&amp;startptr) &amp;&amp;</a>
<a name="ln882">           _read_float(&amp;startptr, &quot;sourceY&quot;, &amp;yc))</a>
<a name="ln883">        {</a>
<a name="ln884">          p-&gt;x = x;</a>
<a name="ln885">          p-&gt;y = y;</a>
<a name="ln886">          p-&gt;radius = radius;</a>
<a name="ln887">          p-&gt;xc = xc;</a>
<a name="ln888">          p-&gt;yc = yc;</a>
<a name="ln889">          data-&gt;ps.num_spots++;</a>
<a name="ln890">          data-&gt;has_spots = TRUE;</a>
<a name="ln891">        }</a>
<a name="ln892">        xmlFree(cvalue);</a>
<a name="ln893">      }</a>
<a name="ln894">      if(data-&gt;ps.num_spots == MAX_SPOTS) break;</a>
<a name="ln895">      riNode = riNode-&gt;next;</a>
<a name="ln896">    }</a>
<a name="ln897">  }</a>
<a name="ln898">  else if(dev != NULL &amp;&amp; !xmlStrcmp(name, (const xmlChar *)&quot;ToneCurvePV2012&quot;))</a>
<a name="ln899">  {</a>
<a name="ln900">    xmlNodePtr tcNode = node;</a>
<a name="ln901"> </a>
<a name="ln902">    while(tcNode)</a>
<a name="ln903">    {</a>
<a name="ln904">      if(!xmlStrcmp(tcNode-&gt;name, (const xmlChar *)&quot;li&quot;))</a>
<a name="ln905">      {</a>
<a name="ln906">        xmlChar *cvalue = xmlNodeListGetString(doc, tcNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln907"> </a>
<a name="ln908">        if(sscanf((const char *)cvalue, &quot;%d, %d&quot;,</a>
<a name="ln909">                  &amp;(data-&gt;curve_pts[data-&gt;n_pts][0]), &amp;(data-&gt;curve_pts[data-&gt;n_pts][1]))) data-&gt;n_pts++;</a>
<a name="ln910">        xmlFree(cvalue);</a>
<a name="ln911">      }</a>
<a name="ln912">      if(data-&gt;n_pts == MAX_PTS) break;</a>
<a name="ln913">      tcNode = tcNode-&gt;next;</a>
<a name="ln914">    }</a>
<a name="ln915">  }</a>
<a name="ln916">  else if(dev == NULL &amp;&amp; !xmlStrcmp(name, (const xmlChar *)&quot;title&quot;))</a>
<a name="ln917">  {</a>
<a name="ln918">    xmlNodePtr ttlNode = node;</a>
<a name="ln919">    while(ttlNode)</a>
<a name="ln920">    {</a>
<a name="ln921">      if(!xmlStrncmp(ttlNode-&gt;name, (const xmlChar *)&quot;li&quot;, 2))</a>
<a name="ln922">      {</a>
<a name="ln923">        xmlChar *cvalue = xmlNodeListGetString(doc, ttlNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln924">        dt_metadata_set(imgid, &quot;Xmp.dc.title&quot;, (char *)cvalue);</a>
<a name="ln925">        xmlFree(cvalue);</a>
<a name="ln926">      }</a>
<a name="ln927">      ttlNode = ttlNode-&gt;next;</a>
<a name="ln928">    }</a>
<a name="ln929">  }</a>
<a name="ln930">  else if(dev == NULL &amp;&amp; !xmlStrcmp(name, (const xmlChar *)&quot;description&quot;))</a>
<a name="ln931">  {</a>
<a name="ln932">    xmlNodePtr desNode = node;</a>
<a name="ln933">    while(desNode)</a>
<a name="ln934">    {</a>
<a name="ln935">      if(!xmlStrncmp(desNode-&gt;name, (const xmlChar *)&quot;li&quot;, 2))</a>
<a name="ln936">      {</a>
<a name="ln937">        xmlChar *cvalue = xmlNodeListGetString(doc, desNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln938">        dt_metadata_set(imgid, &quot;Xmp.dc.description&quot;, (char *)cvalue);</a>
<a name="ln939">        xmlFree(cvalue);</a>
<a name="ln940">      }</a>
<a name="ln941">      desNode = desNode-&gt;next;</a>
<a name="ln942">    }</a>
<a name="ln943">  }</a>
<a name="ln944">  else if(dev == NULL &amp;&amp; !xmlStrcmp(name, (const xmlChar *)&quot;creator&quot;))</a>
<a name="ln945">  {</a>
<a name="ln946">    xmlNodePtr creNode = node;</a>
<a name="ln947">    while(creNode)</a>
<a name="ln948">    {</a>
<a name="ln949">      if(!xmlStrncmp(creNode-&gt;name, (const xmlChar *)&quot;li&quot;, 2))</a>
<a name="ln950">      {</a>
<a name="ln951">        xmlChar *cvalue = xmlNodeListGetString(doc, creNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln952">        dt_metadata_set(imgid, &quot;Xmp.dc.creator&quot;, (char *)cvalue);</a>
<a name="ln953">        xmlFree(cvalue);</a>
<a name="ln954">      }</a>
<a name="ln955">      creNode = creNode-&gt;next;</a>
<a name="ln956">    }</a>
<a name="ln957">  }</a>
<a name="ln958">  else if(dev == NULL &amp;&amp; !xmlStrcmp(name, (const xmlChar *)&quot;rights&quot;))</a>
<a name="ln959">  {</a>
<a name="ln960">    xmlNodePtr rigNode = node;</a>
<a name="ln961">    while(rigNode)</a>
<a name="ln962">    {</a>
<a name="ln963">      if(!xmlStrncmp(rigNode-&gt;name, (const xmlChar *)&quot;li&quot;, 2))</a>
<a name="ln964">      {</a>
<a name="ln965">        xmlChar *cvalue = xmlNodeListGetString(doc, rigNode-&gt;xmlChildrenNode, 1);</a>
<a name="ln966">        dt_metadata_set(imgid, &quot;Xmp.dc.rights&quot;, (char *)cvalue);</a>
<a name="ln967">        xmlFree(cvalue);</a>
<a name="ln968">      }</a>
<a name="ln969">      rigNode = rigNode-&gt;next;</a>
<a name="ln970">    }</a>
<a name="ln971">  }</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974">/* _has_list returns true if the node contains a list of value */</a>
<a name="ln975">static int _has_list(char *name)</a>
<a name="ln976">{</a>
<a name="ln977">  return !strcmp(name, &quot;subject&quot;)</a>
<a name="ln978">    || !strcmp(name, &quot;hierarchicalSubject&quot;)</a>
<a name="ln979">    || !strcmp(name, &quot;RetouchInfo&quot;)</a>
<a name="ln980">    || !strcmp(name, &quot;ToneCurvePV2012&quot;)</a>
<a name="ln981">    || !strcmp(name, &quot;title&quot;)</a>
<a name="ln982">    || !strcmp(name, &quot;description&quot;)</a>
<a name="ln983">    || !strcmp(name, &quot;creator&quot;)</a>
<a name="ln984">    || !strcmp(name, &quot;publisher&quot;)</a>
<a name="ln985">    || !strcmp(name, &quot;rights&quot;);</a>
<a name="ln986">};</a>
<a name="ln987"> </a>
<a name="ln988">/* handle a specific xpath */</a>
<a name="ln989">static void _handle_xpath(dt_develop_t *dev, xmlDoc *doc, int imgid, xmlXPathContext *ctx, const xmlChar *xpath, lr_data_t *data)</a>
<a name="ln990">{</a>
<a name="ln991">  xmlXPathObject *xpathObj = xmlXPathEvalExpression(xpath, ctx);</a>
<a name="ln992"> </a>
<a name="ln993">  if (xpathObj != NULL)</a>
<a name="ln994">    {</a>
<a name="ln995">      const xmlNodeSetPtr xnodes = xpathObj-&gt;nodesetval;</a>
<a name="ln996">      const int n = xnodes-&gt;nodeNr;</a>
<a name="ln997"> </a>
<a name="ln998">      for (int k=0; k&lt;n; k++)</a>
<a name="ln999">        {</a>
<a name="ln1000">          const xmlNode *node = xnodes-&gt;nodeTab[k];</a>
<a name="ln1001"> </a>
<a name="ln1002">          if (_has_list((char *)node-&gt;name))</a>
<a name="ln1003">            {</a>
<a name="ln1004">              xmlNodePtr listnode = node-&gt;xmlChildrenNode;</a>
<a name="ln1005">              if (listnode) listnode = listnode-&gt;next;</a>
<a name="ln1006">              if (listnode) listnode = listnode-&gt;xmlChildrenNode;</a>
<a name="ln1007">              if (listnode) listnode = listnode-&gt;next;</a>
<a name="ln1008">              if (listnode) _lrop(dev, doc, imgid, node-&gt;name, NULL, listnode, data);</a>
<a name="ln1009">            }</a>
<a name="ln1010">          else</a>
<a name="ln1011">            {</a>
<a name="ln1012">              const xmlChar *value = xmlNodeListGetString(doc, node-&gt;children, 1);</a>
<a name="ln1013">              _lrop(dev, doc, imgid, node-&gt;name, value, NULL, data);</a>
<a name="ln1014">            }</a>
<a name="ln1015">        }</a>
<a name="ln1016"> </a>
<a name="ln1017">      xmlXPathFreeObject(xpathObj);</a>
<a name="ln1018">    }</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021">void dt_lightroom_import(int imgid, dt_develop_t *dev, gboolean iauto)</a>
<a name="ln1022">{</a>
<a name="ln1023">  gboolean refresh_needed = FALSE;</a>
<a name="ln1024">  char imported[256] = { 0 };</a>
<a name="ln1025">  int n_import = 0;                // number of iop imported</a>
<a name="ln1026"> </a>
<a name="ln1027">  // Get full pathname</a>
<a name="ln1028">  char *pathname = dt_get_lightroom_xmp(imgid);</a>
<a name="ln1029"> </a>
<a name="ln1030">  if(!pathname)</a>
<a name="ln1031">  {</a>
<a name="ln1032">    if(!iauto) dt_control_log(_(&quot;cannot find lightroom XMP!&quot;));</a>
<a name="ln1033">    return;</a>
<a name="ln1034">  }</a>
<a name="ln1035"> </a>
<a name="ln1036">  // Load LR xmp</a>
<a name="ln1037"> </a>
<a name="ln1038">  xmlDocPtr doc;</a>
<a name="ln1039">  xmlNodePtr entryNode;</a>
<a name="ln1040"> </a>
<a name="ln1041">  // Parse xml document</a>
<a name="ln1042"> </a>
<a name="ln1043">  doc = xmlParseEntity(pathname);</a>
<a name="ln1044"> </a>
<a name="ln1045">  if(doc == NULL)</a>
<a name="ln1046">  {</a>
<a name="ln1047">    g_free(pathname);</a>
<a name="ln1048">    return;</a>
<a name="ln1049">  }</a>
<a name="ln1050"> </a>
<a name="ln1051">  // Enter first node, xmpmeta</a>
<a name="ln1052"> </a>
<a name="ln1053">  entryNode = xmlDocGetRootElement(doc);</a>
<a name="ln1054"> </a>
<a name="ln1055">  if(entryNode == NULL)</a>
<a name="ln1056">  {</a>
<a name="ln1057">    g_free(pathname);</a>
<a name="ln1058">    xmlFreeDoc(doc);</a>
<a name="ln1059">    return;</a>
<a name="ln1060">  }</a>
<a name="ln1061"> </a>
<a name="ln1062">  if(xmlStrcmp(entryNode-&gt;name, (const xmlChar *)&quot;xmpmeta&quot;))</a>
<a name="ln1063">  {</a>
<a name="ln1064">    if(!iauto) dt_control_log(_(&quot;`%s' not a lightroom XMP!&quot;), pathname);</a>
<a name="ln1065">    g_free(pathname);</a>
<a name="ln1066">    return;</a>
<a name="ln1067">  }</a>
<a name="ln1068"> </a>
<a name="ln1069">  // Check that this is really a Lightroom document</a>
<a name="ln1070"> </a>
<a name="ln1071">  xmlXPathContextPtr xpathCtx = xmlXPathNewContext(doc);</a>
<a name="ln1072"> </a>
<a name="ln1073">  if(xpathCtx == NULL)</a>
<a name="ln1074">  {</a>
<a name="ln1075">    g_free(pathname);</a>
<a name="ln1076">    xmlFreeDoc(doc);</a>
<a name="ln1077">    return;</a>
<a name="ln1078">  }</a>
<a name="ln1079"> </a>
<a name="ln1080">  xmlXPathRegisterNs(xpathCtx, BAD_CAST &quot;stEvt&quot;, BAD_CAST &quot;http://ns.adobe.com/xap/1.0/sType/ResourceEvent#&quot;);</a>
<a name="ln1081"> </a>
<a name="ln1082">  xmlXPathObjectPtr xpathObj = xmlXPathEvalExpression((const xmlChar *)&quot;//@stEvt:softwareAgent&quot;, xpathCtx);</a>
<a name="ln1083"> </a>
<a name="ln1084">  if(xpathObj == NULL)</a>
<a name="ln1085">  {</a>
<a name="ln1086">    if(!iauto) dt_control_log(_(&quot;`%s' not a lightroom XMP!&quot;), pathname);</a>
<a name="ln1087">    xmlXPathFreeContext(xpathCtx);</a>
<a name="ln1088">    g_free(pathname);</a>
<a name="ln1089">    xmlFreeDoc(doc);</a>
<a name="ln1090">    return;</a>
<a name="ln1091">  }</a>
<a name="ln1092"> </a>
<a name="ln1093">  xmlNodeSetPtr xnodes = xpathObj-&gt;nodesetval;</a>
<a name="ln1094"> </a>
<a name="ln1095">  if(xnodes != NULL &amp;&amp; xnodes-&gt;nodeNr &gt; 0)</a>
<a name="ln1096">  {</a>
<a name="ln1097">    xmlNodePtr xnode = xnodes-&gt;nodeTab[0];</a>
<a name="ln1098">    xmlChar *value = xmlNodeListGetString(doc, xnode-&gt;xmlChildrenNode, 1);</a>
<a name="ln1099"> </a>
<a name="ln1100">    if(!strstr((char *)value, &quot;Lightroom&quot;))</a>
<a name="ln1101">    {</a>
<a name="ln1102">      xmlXPathFreeContext(xpathCtx);</a>
<a name="ln1103">      xmlXPathFreeObject(xpathObj);</a>
<a name="ln1104">      xmlFreeDoc(doc);</a>
<a name="ln1105">      xmlFree(value);</a>
<a name="ln1106">      if(!iauto) dt_control_log(_(&quot;`%s' not a lightroom XMP!&quot;), pathname);</a>
<a name="ln1107">      g_free(pathname);</a>
<a name="ln1108">      return;</a>
<a name="ln1109">    }</a>
<a name="ln1110">    xmlFree(value);</a>
<a name="ln1111">  }</a>
<a name="ln1112">// we could bail out here if we ONLY wanted to load a file known to be from lightroom.</a>
<a name="ln1113">// if we don't know who created it we will just import it however.</a>
<a name="ln1114">//   else</a>
<a name="ln1115">//   {</a>
<a name="ln1116">//     xmlXPathFreeObject(xpathObj);</a>
<a name="ln1117">//     xmlXPathFreeContext(xpathCtx);</a>
<a name="ln1118">//     if(!iauto) dt_control_log(_(&quot;`%s' not a lightroom XMP!&quot;), pathname);</a>
<a name="ln1119">//     g_free(pathname);</a>
<a name="ln1120">//     return;</a>
<a name="ln1121">//   }</a>
<a name="ln1122"> </a>
<a name="ln1123">  // let's now parse the needed data</a>
<a name="ln1124"> </a>
<a name="ln1125">  lr_data_t data;</a>
<a name="ln1126"> </a>
<a name="ln1127">  memset(&amp;data, 0, sizeof(data));</a>
<a name="ln1128"> </a>
<a name="ln1129">  data.has_crop = FALSE;</a>
<a name="ln1130">  data.has_flip = FALSE;</a>
<a name="ln1131">  data.has_exposure = FALSE;</a>
<a name="ln1132">  data.has_vignette = FALSE;</a>
<a name="ln1133">  data.has_grain = FALSE;</a>
<a name="ln1134">  data.has_spots = FALSE;</a>
<a name="ln1135">  data.curve_kind = linear;</a>
<a name="ln1136">  data.n_pts = 0;</a>
<a name="ln1137">  data.has_colorzones = FALSE;</a>
<a name="ln1138">  data.has_splittoning = FALSE;</a>
<a name="ln1139">  data.has_bilat = FALSE;</a>
<a name="ln1140">  data.has_tags = FALSE;</a>
<a name="ln1141">  data.rating = 0;</a>
<a name="ln1142">  data.has_rating = FALSE;</a>
<a name="ln1143">  data.lat = NAN;</a>
<a name="ln1144">  data.lon = NAN;</a>
<a name="ln1145">  data.has_gps = FALSE;</a>
<a name="ln1146">  data.color = 0;</a>
<a name="ln1147">  data.has_colorlabel = FALSE;</a>
<a name="ln1148">  data.fratio = NAN;                // factor ratio image</a>
<a name="ln1149">  data.crop_roundness = NAN;        // from lightroom</a>
<a name="ln1150">  data.iwidth = 0;</a>
<a name="ln1151">  data.iheight = 0;                 // image width / height</a>
<a name="ln1152">  data.orientation = 1;</a>
<a name="ln1153"> </a>
<a name="ln1154">  // record the name-spaces needed for the parsing</a>
<a name="ln1155">  xmlXPathRegisterNs</a>
<a name="ln1156">    (xpathCtx,</a>
<a name="ln1157">     BAD_CAST &quot;crs&quot;,</a>
<a name="ln1158">     BAD_CAST &quot;http://ns.adobe.com/camera-raw-settings/1.0/&quot;);</a>
<a name="ln1159">  xmlXPathRegisterNs</a>
<a name="ln1160">    (xpathCtx,</a>
<a name="ln1161">     BAD_CAST &quot;dc&quot;,</a>
<a name="ln1162">     BAD_CAST &quot;http://purl.org/dc/elements/1.1/&quot;);</a>
<a name="ln1163">  xmlXPathRegisterNs</a>
<a name="ln1164">    (xpathCtx,</a>
<a name="ln1165">     BAD_CAST &quot;tiff&quot;,</a>
<a name="ln1166">     BAD_CAST &quot;http://ns.adobe.com/tiff/1.0/&quot;);</a>
<a name="ln1167">  xmlXPathRegisterNs</a>
<a name="ln1168">    (xpathCtx,</a>
<a name="ln1169">     BAD_CAST &quot;xmp&quot;,</a>
<a name="ln1170">     BAD_CAST &quot;http://ns.adobe.com/xap/1.0/&quot;);</a>
<a name="ln1171">  xmlXPathRegisterNs</a>
<a name="ln1172">    (xpathCtx,</a>
<a name="ln1173">     BAD_CAST &quot;exif&quot;,</a>
<a name="ln1174">     BAD_CAST &quot;http://ns.adobe.com/exif/1.0/&quot;);</a>
<a name="ln1175">  xmlXPathRegisterNs</a>
<a name="ln1176">    (xpathCtx,</a>
<a name="ln1177">     BAD_CAST &quot;lr&quot;,</a>
<a name="ln1178">     BAD_CAST &quot;http://ns.adobe.com/lightroom/1.0/&quot;);</a>
<a name="ln1179">  xmlXPathRegisterNs</a>
<a name="ln1180">    (xpathCtx,</a>
<a name="ln1181">     BAD_CAST &quot;rdf&quot;,</a>
<a name="ln1182">     BAD_CAST &quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;);</a>
<a name="ln1183"> </a>
<a name="ln1184">  // All prefixes to parse from the XMP document</a>
<a name="ln1185">  static char *names[] = { &quot;crs&quot;, &quot;dc&quot;, &quot;tiff&quot;, &quot;xmp&quot;, &quot;exif&quot;, &quot;lr&quot;, NULL };</a>
<a name="ln1186"> </a>
<a name="ln1187">  for (int i=0; names[i]!=NULL; i++)</a>
<a name="ln1188">    {</a>
<a name="ln1189">      char expr[50];</a>
<a name="ln1190"> </a>
<a name="ln1191">      /* Lr 7.0 CC (nodes) */</a>
<a name="ln1192">      snprintf(expr, sizeof(expr), &quot;//%s:*&quot;, names[i]);</a>
<a name="ln1193">      _handle_xpath(dev, doc, imgid, xpathCtx, (const xmlChar *)expr, &amp;data);</a>
<a name="ln1194"> </a>
<a name="ln1195">      /* Lr up to 6.0 (attributes) */</a>
<a name="ln1196">      snprintf(expr, sizeof(expr), &quot;//@%s:*&quot;, names[i]);</a>
<a name="ln1197">      _handle_xpath(dev, doc, imgid, xpathCtx, (const xmlChar *)expr, &amp;data);</a>
<a name="ln1198">    }</a>
<a name="ln1199"> </a>
<a name="ln1200">  xmlXPathFreeObject(xpathObj);</a>
<a name="ln1201">  xmlXPathFreeContext(xpathCtx);</a>
<a name="ln1202">  xmlFreeDoc(doc);</a>
<a name="ln1203"> </a>
<a name="ln1204">  //  Integrates into the history all the imported iop</a>
<a name="ln1205"> </a>
<a name="ln1206">  if(dev != NULL &amp;&amp; dt_image_is_raw(&amp;dev-&gt;image_storage))</a>
<a name="ln1207">  {</a>
<a name="ln1208">    // set colorin to cmatrix which is the default from Adobe (so closer to what Lightroom does)</a>
<a name="ln1209">    dt_iop_colorin_params_t pci = (dt_iop_colorin_params_t){ &quot;cmatrix&quot;, DT_INTENT_PERCEPTUAL };</a>
<a name="ln1210"> </a>
<a name="ln1211">    dt_add_hist(imgid, &quot;colorin&quot;, (dt_iop_params_t *)&amp;pci, sizeof(dt_iop_colorin_params_t), imported,</a>
<a name="ln1212">                sizeof(imported), LRDT_COLORIN_VERSION, &amp;n_import);</a>
<a name="ln1213">    refresh_needed = TRUE;</a>
<a name="ln1214">  }</a>
<a name="ln1215"> </a>
<a name="ln1216">  if(dev != NULL &amp;&amp; data.has_crop)</a>
<a name="ln1217">  {</a>
<a name="ln1218">    data.pc.k_sym = 0;</a>
<a name="ln1219">    data.pc.k_apply = 0;</a>
<a name="ln1220">    data.pc.crop_auto = 0;</a>
<a name="ln1221">    data.pc.k_h = data.pc.k_v = 0;</a>
<a name="ln1222">    data.pc.k_type = 0;</a>
<a name="ln1223">    data.pc.kxa = data.pc.kxd = 0.2f;</a>
<a name="ln1224">    data.pc.kxc = data.pc.kxb = 0.8f;</a>
<a name="ln1225">    data.pc.kya = data.pc.kyb = 0.2f;</a>
<a name="ln1226">    data.pc.kyc = data.pc.kyd = 0.8f;</a>
<a name="ln1227">    float tmp;</a>
<a name="ln1228"> </a>
<a name="ln1229">    if(data.has_crop)</a>
<a name="ln1230">    {</a>
<a name="ln1231">      // adjust crop data according to the rotation</a>
<a name="ln1232"> </a>
<a name="ln1233">      switch(dev-&gt;image_storage.orientation)</a>
<a name="ln1234">      {</a>
<a name="ln1235">        case 5: // portrait - counter-clockwise</a>
<a name="ln1236">          tmp = data.pc.ch;</a>
<a name="ln1237">          data.pc.ch = 1.0 - data.pc.cx;</a>
<a name="ln1238">          data.pc.cx = data.pc.cy;</a>
<a name="ln1239">          data.pc.cy = 1.0 - data.pc.cw;</a>
<a name="ln1240">          data.pc.cw = tmp;</a>
<a name="ln1241">          break;</a>
<a name="ln1242">        case 6: // portrait - clockwise</a>
<a name="ln1243">          tmp = data.pc.ch;</a>
<a name="ln1244">          data.pc.ch = data.pc.cw;</a>
<a name="ln1245">          data.pc.cw = 1.0 - data.pc.cy;</a>
<a name="ln1246">          data.pc.cy = data.pc.cx;</a>
<a name="ln1247">          data.pc.cx = 1.0 - tmp;</a>
<a name="ln1248">          break;</a>
<a name="ln1249">        default:</a>
<a name="ln1250">          break;</a>
<a name="ln1251">      }</a>
<a name="ln1252"> </a>
<a name="ln1253">      if(data.pc.angle != 0)</a>
<a name="ln1254">      {</a>
<a name="ln1255">        const float rangle = -data.pc.angle * (3.141592 / 180);</a>
<a name="ln1256">        float x, y;</a>
<a name="ln1257"> </a>
<a name="ln1258">        // do the rotation (rangle) using center of image (0.5, 0.5)</a>
<a name="ln1259"> </a>
<a name="ln1260">        x = data.pc.cx - 0.5;</a>
<a name="ln1261">        y = 0.5 - data.pc.cy;</a>
<a name="ln1262">        data.pc.cx = 0.5 + x * cos(rangle) - y * sin(rangle);</a>
<a name="ln1263">        data.pc.cy = 0.5 - (x * sin(rangle) + y * cos(rangle));</a>
<a name="ln1264"> </a>
<a name="ln1265">        x = data.pc.cw - 0.5;</a>
<a name="ln1266">        y = 0.5 - data.pc.ch;</a>
<a name="ln1267">        data.pc.cw = 0.5 + x * cos(rangle) - y * sin(rangle);</a>
<a name="ln1268">        data.pc.ch = 0.5 - (x * sin(rangle) + y * cos(rangle));</a>
<a name="ln1269">      }</a>
<a name="ln1270">    }</a>
<a name="ln1271">    else</a>
<a name="ln1272">    {</a>
<a name="ln1273">      data.pc.angle = 0;</a>
<a name="ln1274">      data.pc.cx = 0;</a>
<a name="ln1275">      data.pc.cy = 0;</a>
<a name="ln1276">      data.pc.cw = 1;</a>
<a name="ln1277">      data.pc.ch = 1;</a>
<a name="ln1278">    }</a>
<a name="ln1279"> </a>
<a name="ln1280">    data.fratio = (data.pc.cw - data.pc.cx) / (data.pc.ch - data.pc.cy);</a>
<a name="ln1281"> </a>
<a name="ln1282">    dt_add_hist(imgid, &quot;clipping&quot;, (dt_iop_params_t *)&amp;data.pc, sizeof(dt_iop_clipping_params_t), imported,</a>
<a name="ln1283">                sizeof(imported), LRDT_CLIPPING_VERSION, &amp;n_import);</a>
<a name="ln1284">    refresh_needed = TRUE;</a>
<a name="ln1285">  }</a>
<a name="ln1286"> </a>
<a name="ln1287">  if(dev != NULL &amp;&amp; data.has_flip)</a>
<a name="ln1288">  {</a>
<a name="ln1289">    data.pf.orientation = 0;</a>
<a name="ln1290"> </a>
<a name="ln1291">    if(dev-&gt;image_storage.orientation == 5)</a>
<a name="ln1292">      // portrait</a>
<a name="ln1293">      switch(data.orientation)</a>
<a name="ln1294">      {</a>
<a name="ln1295">        case 8:</a>
<a name="ln1296">          data.pf.orientation = 0;</a>
<a name="ln1297">          break;</a>
<a name="ln1298">        case 3:</a>
<a name="ln1299">          data.pf.orientation = 5;</a>
<a name="ln1300">          break;</a>
<a name="ln1301">        case 6:</a>
<a name="ln1302">          data.pf.orientation = 3;</a>
<a name="ln1303">          break;</a>
<a name="ln1304">        case 1:</a>
<a name="ln1305">          data.pf.orientation = 6;</a>
<a name="ln1306">          break;</a>
<a name="ln1307"> </a>
<a name="ln1308">        // with horizontal flip</a>
<a name="ln1309">        case 7:</a>
<a name="ln1310">          data.pf.orientation = 1;</a>
<a name="ln1311">          break;</a>
<a name="ln1312">        case 2:</a>
<a name="ln1313">          data.pf.orientation = 4;</a>
<a name="ln1314">          break;</a>
<a name="ln1315">        case 5:</a>
<a name="ln1316">          data.pf.orientation = 2;</a>
<a name="ln1317">          break;</a>
<a name="ln1318">        case 4:</a>
<a name="ln1319">          data.pf.orientation = 7;</a>
<a name="ln1320">          break;</a>
<a name="ln1321">      }</a>
<a name="ln1322"> </a>
<a name="ln1323">    else if(dev-&gt;image_storage.orientation == 6)</a>
<a name="ln1324">      // portrait</a>
<a name="ln1325">      switch(data.orientation)</a>
<a name="ln1326">      {</a>
<a name="ln1327">        case 8:</a>
<a name="ln1328">          data.pf.orientation = 3;</a>
<a name="ln1329">          break;</a>
<a name="ln1330">        case 3:</a>
<a name="ln1331">          data.pf.orientation = 6;</a>
<a name="ln1332">          break;</a>
<a name="ln1333">        case 6:</a>
<a name="ln1334">          data.pf.orientation = 0;</a>
<a name="ln1335">          break;</a>
<a name="ln1336">        case 1:</a>
<a name="ln1337">          data.pf.orientation = 5;</a>
<a name="ln1338">          break;</a>
<a name="ln1339"> </a>
<a name="ln1340">        // with horizontal flip</a>
<a name="ln1341">        case 7:</a>
<a name="ln1342">          data.pf.orientation = 2;</a>
<a name="ln1343">          break;</a>
<a name="ln1344">        case 2:</a>
<a name="ln1345">          data.pf.orientation = 7;</a>
<a name="ln1346">          break;</a>
<a name="ln1347">        case 5:</a>
<a name="ln1348">          data.pf.orientation = 1;</a>
<a name="ln1349">          break;</a>
<a name="ln1350">        case 4:</a>
<a name="ln1351">          data.pf.orientation = 4;</a>
<a name="ln1352">          break;</a>
<a name="ln1353">      }</a>
<a name="ln1354"> </a>
<a name="ln1355">    else</a>
<a name="ln1356">      // landscape</a>
<a name="ln1357">      switch(data.orientation)</a>
<a name="ln1358">      {</a>
<a name="ln1359">        case 8:</a>
<a name="ln1360">          data.pf.orientation = 5;</a>
<a name="ln1361">          break;</a>
<a name="ln1362">        case 3:</a>
<a name="ln1363">          data.pf.orientation = 3;</a>
<a name="ln1364">          break;</a>
<a name="ln1365">        case 6:</a>
<a name="ln1366">          data.pf.orientation = 6;</a>
<a name="ln1367">          break;</a>
<a name="ln1368">        case 1:</a>
<a name="ln1369">          data.pf.orientation = 0;</a>
<a name="ln1370">          break;</a>
<a name="ln1371"> </a>
<a name="ln1372">        // with horizontal flip</a>
<a name="ln1373">        case 7:</a>
<a name="ln1374">          data.pf.orientation = 7;</a>
<a name="ln1375">          break;</a>
<a name="ln1376">        case 2:</a>
<a name="ln1377">          data.pf.orientation = 1;</a>
<a name="ln1378">          break;</a>
<a name="ln1379">        case 5:</a>
<a name="ln1380">          data.pf.orientation = 4;</a>
<a name="ln1381">          break;</a>
<a name="ln1382">        case 4:</a>
<a name="ln1383">          data.pf.orientation = 2;</a>
<a name="ln1384">          break;</a>
<a name="ln1385">      }</a>
<a name="ln1386"> </a>
<a name="ln1387">    dt_add_hist(imgid, &quot;flip&quot;, (dt_iop_params_t *)&amp;data.pf, sizeof(dt_iop_flip_params_t), imported,</a>
<a name="ln1388">                sizeof(imported), LRDT_FLIP_VERSION, &amp;n_import);</a>
<a name="ln1389">    refresh_needed = TRUE;</a>
<a name="ln1390">  }</a>
<a name="ln1391"> </a>
<a name="ln1392">  if(dev != NULL &amp;&amp; data.has_exposure)</a>
<a name="ln1393">  {</a>
<a name="ln1394">    dt_add_hist(imgid, &quot;exposure&quot;, (dt_iop_params_t *)&amp;data.pe, sizeof(dt_iop_exposure_params_t), imported,</a>
<a name="ln1395">                sizeof(imported), LRDT_EXPOSURE_VERSION, &amp;n_import);</a>
<a name="ln1396">    refresh_needed = TRUE;</a>
<a name="ln1397">  }</a>
<a name="ln1398"> </a>
<a name="ln1399">  if(dev != NULL &amp;&amp; data.has_grain)</a>
<a name="ln1400">  {</a>
<a name="ln1401">    data.pg.channel = 0;</a>
<a name="ln1402"> </a>
<a name="ln1403">    dt_add_hist(imgid, &quot;grain&quot;, (dt_iop_params_t *)&amp;data.pg, sizeof(dt_iop_grain_params_t), imported,</a>
<a name="ln1404">                sizeof(imported), LRDT_GRAIN_VERSION, &amp;n_import);</a>
<a name="ln1405">    refresh_needed = TRUE;</a>
<a name="ln1406">  }</a>
<a name="ln1407"> </a>
<a name="ln1408">  if(dev != NULL &amp;&amp; data.has_vignette)</a>
<a name="ln1409">  {</a>
<a name="ln1410">    const float base_ratio = 1.325 / 1.5;</a>
<a name="ln1411"> </a>
<a name="ln1412">    data.pv.autoratio = FALSE;</a>
<a name="ln1413">    data.pv.dithering = DITHER_8BIT;</a>
<a name="ln1414">    data.pv.center.x = 0.0;</a>
<a name="ln1415">    data.pv.center.y = 0.0;</a>
<a name="ln1416">    data.pv.shape = 1.0;</a>
<a name="ln1417"> </a>
<a name="ln1418">    // defensive code, should not happen, but just in case future Lr version</a>
<a name="ln1419">    // has not ImageWidth/ImageLength XML tag.</a>
<a name="ln1420">    if(data.iwidth == 0 || data.iheight == 0)</a>
<a name="ln1421">      data.pv.whratio = base_ratio;</a>
<a name="ln1422">    else</a>
<a name="ln1423">      data.pv.whratio = base_ratio * ((float)data.iwidth / (float)data.iheight);</a>
<a name="ln1424"> </a>
<a name="ln1425">    if(data.has_crop) data.pv.whratio = data.pv.whratio * data.fratio;</a>
<a name="ln1426"> </a>
<a name="ln1427">    //  Adjust scale and ratio based on the roundness. On Lightroom changing</a>
<a name="ln1428">    //  the roundness change the width and the height of the vignette.</a>
<a name="ln1429"> </a>
<a name="ln1430">    if(data.crop_roundness &gt; 0)</a>
<a name="ln1431">    {</a>
<a name="ln1432">      float newratio = data.pv.whratio - (data.pv.whratio - 1) * (data.crop_roundness / 100.0);</a>
<a name="ln1433">      float dscale = (1 - (newratio / data.pv.whratio)) / 2.0;</a>
<a name="ln1434"> </a>
<a name="ln1435">      data.pv.scale -= dscale * 100.0;</a>
<a name="ln1436">      data.pv.whratio = newratio;</a>
<a name="ln1437">    }</a>
<a name="ln1438"> </a>
<a name="ln1439">    dt_add_hist(imgid, &quot;vignette&quot;, (dt_iop_params_t *)&amp;data.pv, sizeof(dt_iop_vignette_params_t), imported,</a>
<a name="ln1440">                sizeof(imported), LRDT_VIGNETTE_VERSION, &amp;n_import);</a>
<a name="ln1441">    refresh_needed = TRUE;</a>
<a name="ln1442">  }</a>
<a name="ln1443"> </a>
<a name="ln1444">  if(dev != NULL &amp;&amp; data.has_spots)</a>
<a name="ln1445">  {</a>
<a name="ln1446">    // Check for orientation, rotate when in portrait mode</a>
<a name="ln1447">    if(data.orientation &gt; 4)</a>
<a name="ln1448">      for(int k = 0; k &lt; data.ps.num_spots; k++)</a>
<a name="ln1449">      {</a>
<a name="ln1450">        float tmp = data.ps.spot[k].y;</a>
<a name="ln1451">        data.ps.spot[k].y = 1.0 - data.ps.spot[k].x;</a>
<a name="ln1452">        data.ps.spot[k].x = tmp;</a>
<a name="ln1453">        tmp = data.ps.spot[k].yc;</a>
<a name="ln1454">        data.ps.spot[k].yc = 1.0 - data.ps.spot[k].xc;</a>
<a name="ln1455">        data.ps.spot[k].xc = tmp;</a>
<a name="ln1456">      }</a>
<a name="ln1457"> </a>
<a name="ln1458">    dt_add_hist(imgid, &quot;spots&quot;, (dt_iop_params_t *)&amp;data.ps, sizeof(dt_iop_spots_params_t), imported,</a>
<a name="ln1459">                sizeof(imported), LRDT_SPOTS_VERSION, &amp;n_import);</a>
<a name="ln1460">    refresh_needed = TRUE;</a>
<a name="ln1461">  }</a>
<a name="ln1462"> </a>
<a name="ln1463">  if(dev != NULL &amp;&amp;</a>
<a name="ln1464">     (data.curve_kind != linear</a>
<a name="ln1465">      || data.ptc_value[0] != 0 || data.ptc_value[1] != 0 || data.ptc_value[2] != 0 || data.ptc_value[3] != 0))</a>
<a name="ln1466">  {</a>
<a name="ln1467">    const int total_pts = (data.curve_kind == custom) ? data.n_pts : 6;</a>
<a name="ln1468">    data.ptc.tonecurve_nodes[ch_L] = total_pts;</a>
<a name="ln1469">    data.ptc.tonecurve_nodes[ch_a] = 7;</a>
<a name="ln1470">    data.ptc.tonecurve_nodes[ch_b] = 7;</a>
<a name="ln1471">    data.ptc.tonecurve_type[ch_L] = CUBIC_SPLINE;</a>
<a name="ln1472">    data.ptc.tonecurve_type[ch_a] = CUBIC_SPLINE;</a>
<a name="ln1473">    data.ptc.tonecurve_type[ch_b] = CUBIC_SPLINE;</a>
<a name="ln1474">    data.ptc.tonecurve_autoscale_ab = 1;</a>
<a name="ln1475">    data.ptc.tonecurve_preset = 0;</a>
<a name="ln1476"> </a>
<a name="ln1477">    float linear_ab[7] = { 0.0, 0.08, 0.3, 0.5, 0.7, 0.92, 1.0 };</a>
<a name="ln1478"> </a>
<a name="ln1479">    // linear a, b curves</a>
<a name="ln1480">    for(int k = 0; k &lt; 7; k++) data.ptc.tonecurve[ch_a][k].x = linear_ab[k];</a>
<a name="ln1481">    for(int k = 0; k &lt; 7; k++) data.ptc.tonecurve[ch_a][k].y = linear_ab[k];</a>
<a name="ln1482">    for(int k = 0; k &lt; 7; k++) data.ptc.tonecurve[ch_b][k].x = linear_ab[k];</a>
<a name="ln1483">    for(int k = 0; k &lt; 7; k++) data.ptc.tonecurve[ch_b][k].y = linear_ab[k];</a>
<a name="ln1484"> </a>
<a name="ln1485">    // Set the base tonecurve</a>
<a name="ln1486"> </a>
<a name="ln1487">    if(data.curve_kind == linear)</a>
<a name="ln1488">    {</a>
<a name="ln1489">      data.ptc.tonecurve[ch_L][0].x = 0.0;</a>
<a name="ln1490">      data.ptc.tonecurve[ch_L][0].y = 0.0;</a>
<a name="ln1491">      data.ptc.tonecurve[ch_L][1].x = data.ptc_split[0] / 2.0;</a>
<a name="ln1492">      data.ptc.tonecurve[ch_L][1].y = data.ptc_split[0] / 2.0;</a>
<a name="ln1493">      data.ptc.tonecurve[ch_L][2].x = data.ptc_split[1] - (data.ptc_split[1] - data.ptc_split[0]) / 2.0;</a>
<a name="ln1494">      data.ptc.tonecurve[ch_L][2].y = data.ptc_split[1] - (data.ptc_split[1] - data.ptc_split[0]) / 2.0;</a>
<a name="ln1495">      data.ptc.tonecurve[ch_L][3].x = data.ptc_split[1] + (data.ptc_split[2] - data.ptc_split[1]) / 2.0;</a>
<a name="ln1496">      data.ptc.tonecurve[ch_L][3].y = data.ptc_split[1] + (data.ptc_split[2] - data.ptc_split[1]) / 2.0;</a>
<a name="ln1497">      data.ptc.tonecurve[ch_L][4].x = data.ptc_split[2] + (1.0 - data.ptc_split[2]) / 2.0;</a>
<a name="ln1498">      data.ptc.tonecurve[ch_L][4].y = data.ptc_split[2] + (1.0 - data.ptc_split[2]) / 2.0;</a>
<a name="ln1499">      data.ptc.tonecurve[ch_L][5].x = 1.0;</a>
<a name="ln1500">      data.ptc.tonecurve[ch_L][5].y = 1.0;</a>
<a name="ln1501">    }</a>
<a name="ln1502">    else</a>
<a name="ln1503">    {</a>
<a name="ln1504">      for(int k = 0; k &lt; total_pts; k++)</a>
<a name="ln1505">      {</a>
<a name="ln1506">        data.ptc.tonecurve[ch_L][k].x = data.curve_pts[k][0] / 255.0;</a>
<a name="ln1507">        data.ptc.tonecurve[ch_L][k].y = data.curve_pts[k][1] / 255.0;</a>
<a name="ln1508">      }</a>
<a name="ln1509">    }</a>
<a name="ln1510"> </a>
<a name="ln1511">    if(data.curve_kind != custom)</a>
<a name="ln1512">    {</a>
<a name="ln1513">      // set shadows/darks/lights/highlight adjustments</a>
<a name="ln1514"> </a>
<a name="ln1515">      data.ptc.tonecurve[ch_L][1].y += data.ptc.tonecurve[ch_L][1].y * ((float)data.ptc_value[0] / 100.0);</a>
<a name="ln1516">      data.ptc.tonecurve[ch_L][2].y += data.ptc.tonecurve[ch_L][2].y * ((float)data.ptc_value[1] / 100.0);</a>
<a name="ln1517">      data.ptc.tonecurve[ch_L][3].y += data.ptc.tonecurve[ch_L][3].y * ((float)data.ptc_value[2] / 100.0);</a>
<a name="ln1518">      data.ptc.tonecurve[ch_L][4].y += data.ptc.tonecurve[ch_L][4].y * ((float)data.ptc_value[3] / 100.0);</a>
<a name="ln1519"> </a>
<a name="ln1520">      if(data.ptc.tonecurve[ch_L][1].y &gt; data.ptc.tonecurve[ch_L][2].y)</a>
<a name="ln1521">        data.ptc.tonecurve[ch_L][1].y = data.ptc.tonecurve[ch_L][2].y;</a>
<a name="ln1522">      if(data.ptc.tonecurve[ch_L][3].y &gt; data.ptc.tonecurve[ch_L][4].y)</a>
<a name="ln1523">        data.ptc.tonecurve[ch_L][4].y = data.ptc.tonecurve[ch_L][3].y;</a>
<a name="ln1524">    }</a>
<a name="ln1525"> </a>
<a name="ln1526">    dt_add_hist(imgid, &quot;tonecurve&quot;, (dt_iop_params_t *)&amp;data.ptc, sizeof(dt_iop_tonecurve_params_t), imported,</a>
<a name="ln1527">                sizeof(imported), LRDT_TONECURVE_VERSION, &amp;n_import);</a>
<a name="ln1528">    refresh_needed = TRUE;</a>
<a name="ln1529">  }</a>
<a name="ln1530"> </a>
<a name="ln1531">  if(dev != NULL &amp;&amp; data.has_colorzones)</a>
<a name="ln1532">  {</a>
<a name="ln1533">    data.pcz.channel = DT_IOP_COLORZONES_h;</a>
<a name="ln1534"> </a>
<a name="ln1535">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1536">      for(int k = 0; k &lt; 8; k++)</a>
<a name="ln1537">        data.pcz.equalizer_x[i][k] = k / (DT_IOP_COLORZONES_BANDS - 1.0);</a>
<a name="ln1538"> </a>
<a name="ln1539">    dt_add_hist(imgid, &quot;colorzones&quot;, (dt_iop_params_t *)&amp;data.pcz, sizeof(dt_iop_colorzones_params_t), imported,</a>
<a name="ln1540">                sizeof(imported), LRDT_COLORZONES_VERSION, &amp;n_import);</a>
<a name="ln1541">    refresh_needed = TRUE;</a>
<a name="ln1542">  }</a>
<a name="ln1543"> </a>
<a name="ln1544">  if(dev != NULL &amp;&amp; data.has_splittoning)</a>
<a name="ln1545">  {</a>
<a name="ln1546">    data.pst.compress = 50.0;</a>
<a name="ln1547"> </a>
<a name="ln1548">    dt_add_hist(imgid, &quot;splittoning&quot;, (dt_iop_params_t *)&amp;data.pst, sizeof(dt_iop_splittoning_params_t), imported,</a>
<a name="ln1549">                sizeof(imported), LRDT_SPLITTONING_VERSION, &amp;n_import);</a>
<a name="ln1550">    refresh_needed = TRUE;</a>
<a name="ln1551">  }</a>
<a name="ln1552"> </a>
<a name="ln1553">  if(dev != NULL &amp;&amp; data.has_bilat)</a>
<a name="ln1554">  {</a>
<a name="ln1555">    data.pbl.sigma_r = 100.0;</a>
<a name="ln1556">    data.pbl.sigma_s = 100.0;</a>
<a name="ln1557"> </a>
<a name="ln1558">    dt_add_hist(imgid, &quot;bilat&quot;, (dt_iop_params_t *)&amp;data.pbl, sizeof(dt_iop_bilat_params_t), imported,</a>
<a name="ln1559">                sizeof(imported), LRDT_BILAT_VERSION, &amp;n_import);</a>
<a name="ln1560">    refresh_needed = TRUE;</a>
<a name="ln1561">  }</a>
<a name="ln1562"> </a>
<a name="ln1563">  if(data.has_tags)</a>
<a name="ln1564">  {</a>
<a name="ln1565">    if(imported[0]) g_strlcat(imported, &quot;, &quot;, sizeof(imported));</a>
<a name="ln1566">    g_strlcat(imported, _(&quot;tags&quot;), sizeof(imported));</a>
<a name="ln1567">    n_import++;</a>
<a name="ln1568">  }</a>
<a name="ln1569"> </a>
<a name="ln1570">  if(dev == NULL &amp;&amp; data.has_rating)</a>
<a name="ln1571">  {</a>
<a name="ln1572">    dt_ratings_apply_to_image(imgid, data.rating);</a>
<a name="ln1573"> </a>
<a name="ln1574">    if(imported[0]) g_strlcat(imported, &quot;, &quot;, sizeof(imported));</a>
<a name="ln1575">    g_strlcat(imported, _(&quot;rating&quot;), sizeof(imported));</a>
<a name="ln1576">    n_import++;</a>
<a name="ln1577">  }</a>
<a name="ln1578"> </a>
<a name="ln1579">  if(dev == NULL &amp;&amp; data.has_gps)</a>
<a name="ln1580">  {</a>
<a name="ln1581">    dt_image_set_location(imgid, data.lon, data.lat);</a>
<a name="ln1582"> </a>
<a name="ln1583">    if(imported[0]) g_strlcat(imported, &quot;, &quot;, sizeof(imported));</a>
<a name="ln1584">    g_strlcat(imported, _(&quot;geotagging&quot;), sizeof(imported));</a>
<a name="ln1585">    n_import++;</a>
<a name="ln1586">  }</a>
<a name="ln1587"> </a>
<a name="ln1588">  if(dev == NULL &amp;&amp; data.has_colorlabel)</a>
<a name="ln1589">  {</a>
<a name="ln1590">    dt_colorlabels_set_label(imgid, data.color);</a>
<a name="ln1591"> </a>
<a name="ln1592">    if(imported[0]) g_strlcat(imported, &quot;, &quot;, sizeof(imported));</a>
<a name="ln1593">    g_strlcat(imported, _(&quot;color label&quot;), sizeof(imported));</a>
<a name="ln1594">    n_import++;</a>
<a name="ln1595">  }</a>
<a name="ln1596"> </a>
<a name="ln1597">  if(dev != NULL &amp;&amp; refresh_needed &amp;&amp; dev-&gt;gui_attached)</a>
<a name="ln1598">  {</a>
<a name="ln1599">    dt_control_log(ngettext(&quot;%s has been imported&quot;, &quot;%s have been imported&quot;, n_import), imported);</a>
<a name="ln1600"> </a>
<a name="ln1601">    if(!iauto)</a>
<a name="ln1602">    {</a>
<a name="ln1603">      /* signal history changed */</a>
<a name="ln1604">      dt_dev_reload_history_items(dev);</a>
<a name="ln1605">      dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln1606">      /* update xmp file */</a>
<a name="ln1607">      dt_image_synch_xmp(imgid);</a>
<a name="ln1608">      dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE);</a>
<a name="ln1609">    }</a>
<a name="ln1610">  }</a>
<a name="ln1611">}</a>
<a name="ln1612">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1613">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1614">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1229"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'data.has_crop' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
