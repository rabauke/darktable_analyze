
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2014, 2015 marcello perathoner</a>
<a name="ln4">    copyright (c) 2015, 2016 pascal obry</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#ifdef HAVE_CONFIG_H</a>
<a name="ln21">#include &quot;config.h&quot;</a>
<a name="ln22">#endif</a>
<a name="ln23">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln24">#include &quot;common/interpolation.h&quot;</a>
<a name="ln25">#include &quot;common/opencl.h&quot;</a>
<a name="ln26">#include &quot;control/conf.h&quot;</a>
<a name="ln27">#include &quot;control/control.h&quot;</a>
<a name="ln28">#include &quot;develop/imageop.h&quot;</a>
<a name="ln29">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln30">#include &quot;gui/gtk.h&quot;</a>
<a name="ln31">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln32">#include &lt;assert.h&gt;</a>
<a name="ln33">#include &lt;cairo.h&gt;</a>
<a name="ln34">#include &lt;complex.h&gt;</a>
<a name="ln35">#include &lt;math.h&gt;</a>
<a name="ln36">#include &lt;stdlib.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#ifdef _OPENMP</a>
<a name="ln39">#include &lt;omp.h&gt;</a>
<a name="ln40">#endif</a>
<a name="ln41"> </a>
<a name="ln42">// this is the version of the modules parameters, and includes version information about compile-time dt</a>
<a name="ln43">DT_MODULE_INTROSPECTION(1, dt_iop_liquify_params_t)</a>
<a name="ln44"> </a>
<a name="ln45">#pragma GCC diagnostic ignored &quot;-Wshadow&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#define MAX_NODES 100 // max of nodes in one instance</a>
<a name="ln48"> </a>
<a name="ln49">const int   LOOKUP_OVERSAMPLE = 10;</a>
<a name="ln50">const int   INTERPOLATION_POINTS = 100; // when interpolating bezier</a>
<a name="ln51">const float STAMP_RELOCATION = 0.1;     // how many radii to move stamp forward when following a path</a>
<a name="ln52"> </a>
<a name="ln53">#define CONF_RADIUS &quot;plugins/darkroom/liquify/radius&quot;</a>
<a name="ln54">#define CONF_ANGLE &quot;plugins/darkroom/liquify/angle&quot;</a>
<a name="ln55">#define CONF_STRENGTH &quot;plugins/darkroom/liquify/strength&quot;</a>
<a name="ln56"> </a>
<a name="ln57">// enum of layers. sorted back to front.</a>
<a name="ln58"> </a>
<a name="ln59">typedef enum</a>
<a name="ln60">{</a>
<a name="ln61">  DT_LIQUIFY_LAYER_BACKGROUND,</a>
<a name="ln62">  DT_LIQUIFY_LAYER_RADIUS,</a>
<a name="ln63">  DT_LIQUIFY_LAYER_HARDNESS1,</a>
<a name="ln64">  DT_LIQUIFY_LAYER_HARDNESS2,</a>
<a name="ln65">  DT_LIQUIFY_LAYER_WARPS,</a>
<a name="ln66">  DT_LIQUIFY_LAYER_PATH,</a>
<a name="ln67">  DT_LIQUIFY_LAYER_CTRLPOINT1_HANDLE,</a>
<a name="ln68">  DT_LIQUIFY_LAYER_CTRLPOINT2_HANDLE,</a>
<a name="ln69">  DT_LIQUIFY_LAYER_RADIUSPOINT_HANDLE,</a>
<a name="ln70">  DT_LIQUIFY_LAYER_HARDNESSPOINT1_HANDLE,</a>
<a name="ln71">  DT_LIQUIFY_LAYER_HARDNESSPOINT2_HANDLE,</a>
<a name="ln72">  DT_LIQUIFY_LAYER_STRENGTHPOINT_HANDLE,</a>
<a name="ln73">  DT_LIQUIFY_LAYER_CENTERPOINT,</a>
<a name="ln74">  DT_LIQUIFY_LAYER_CTRLPOINT1,</a>
<a name="ln75">  DT_LIQUIFY_LAYER_CTRLPOINT2,</a>
<a name="ln76">  DT_LIQUIFY_LAYER_RADIUSPOINT,</a>
<a name="ln77">  DT_LIQUIFY_LAYER_HARDNESSPOINT1,</a>
<a name="ln78">  DT_LIQUIFY_LAYER_HARDNESSPOINT2,</a>
<a name="ln79">  DT_LIQUIFY_LAYER_STRENGTHPOINT,</a>
<a name="ln80">  DT_LIQUIFY_LAYER_LAST</a>
<a name="ln81">} dt_liquify_layer_enum_t;</a>
<a name="ln82"> </a>
<a name="ln83">typedef enum</a>
<a name="ln84">{</a>
<a name="ln85">  DT_LIQUIFY_LAYER_FLAG_HIT_TEST      =  1,   ///&lt; include layer in hit testing</a>
<a name="ln86">  DT_LIQUIFY_LAYER_FLAG_PREV_SELECTED =  2,   ///&lt; show if previous node is selected</a>
<a name="ln87">  DT_LIQUIFY_LAYER_FLAG_NODE_SELECTED =  4,   ///&lt; show if node is selected</a>
<a name="ln88">  DT_LIQUIFY_LAYER_FLAG_POINT_TOOL    =  8,   ///&lt; show if point tool active</a>
<a name="ln89">  DT_LIQUIFY_LAYER_FLAG_LINE_TOOL     = 16,   ///&lt; show if line tool active</a>
<a name="ln90">  DT_LIQUIFY_LAYER_FLAG_CURVE_TOOL    = 32,   ///&lt; show if line tool active</a>
<a name="ln91">  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL     = 64,   ///&lt; show if node tool active</a>
<a name="ln92">  DT_LIQUIFY_LAYER_FLAG_ANY_TOOL      = 8 + 16 + 32 + 64,</a>
<a name="ln93">} dt_liquify_layer_flag_enum_t;</a>
<a name="ln94"> </a>
<a name="ln95">typedef struct</a>
<a name="ln96">{</a>
<a name="ln97">  float red, green, blue, alpha;</a>
<a name="ln98">} dt_liquify_rgba_t;</a>
<a name="ln99"> </a>
<a name="ln100">#define COLOR_NULL                 { 0.0, 0.0, 0.0, 0.8 }</a>
<a name="ln101">#define GREY                       { 0.3, 0.3, 0.3, 0.8 }</a>
<a name="ln102">#define LGREY                      { 0.8, 0.8, 0.8, 1.0 }</a>
<a name="ln103">#define COLOR_DEBUG                { 0.9, 0.9, 0.0, 1.0 }</a>
<a name="ln104">static const dt_liquify_rgba_t DT_LIQUIFY_COLOR_SELECTED = { 1.0, 1.0, 1.0, 1.0 };</a>
<a name="ln105">static const dt_liquify_rgba_t DT_LIQUIFY_COLOR_HOVER    = { 1.0, 1.0, 1.0, 0.8 };</a>
<a name="ln106"> </a>
<a name="ln107">typedef struct</a>
<a name="ln108">{</a>
<a name="ln109">  dt_liquify_layer_enum_t hover_master;    ///&lt; hover whenever master layer hovers, eg. to</a>
<a name="ln110">  dt_liquify_rgba_t fg;                    ///&lt; the foreground color for this layer</a>
<a name="ln111">  dt_liquify_rgba_t bg;                    ///&lt; the background color for this layer</a>
<a name="ln112">  double opacity;                          ///&lt; the opacity of this layer</a>
<a name="ln113">                                           ///  highlight the whole radius when only the</a>
<a name="ln114">                                           ///  radius point is hovered</a>
<a name="ln115">  dt_liquify_layer_flag_enum_t flags;      ///&lt; various flags for layer</a>
<a name="ln116">  const char *hint;                        ///&lt; hint displayed when hovering</a>
<a name="ln117">} dt_liquify_layer_t;</a>
<a name="ln118"> </a>
<a name="ln119">dt_liquify_layer_t dt_liquify_layers[] =</a>
<a name="ln120">{</a>
<a name="ln121">  { DT_LIQUIFY_LAYER_BACKGROUND,     COLOR_NULL,  COLOR_NULL, 0.0,  0,                                                                                                      },</a>
<a name="ln122">  { DT_LIQUIFY_LAYER_RADIUS,         COLOR_DEBUG, COLOR_NULL, 0.25, DT_LIQUIFY_LAYER_FLAG_ANY_TOOL,                                                                         },</a>
<a name="ln123">  { DT_LIQUIFY_LAYER_HARDNESS1,      COLOR_DEBUG, COLOR_NULL, 1.0,  0,                                                                                                      },</a>
<a name="ln124">  { DT_LIQUIFY_LAYER_HARDNESS2,      COLOR_DEBUG, COLOR_NULL, 1.0,  0,                                                                                                      },</a>
<a name="ln125">  { DT_LIQUIFY_LAYER_WARPS,          COLOR_DEBUG, LGREY,      0.5,  DT_LIQUIFY_LAYER_FLAG_ANY_TOOL,                                                                         },</a>
<a name="ln126">  { DT_LIQUIFY_LAYER_PATH,           GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_ANY_TOOL  | DT_LIQUIFY_LAYER_FLAG_HIT_TEST,                                       },</a>
<a name="ln127">  { DT_LIQUIFY_LAYER_CTRLPOINT1,     GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL,                                                                        },</a>
<a name="ln128">  { DT_LIQUIFY_LAYER_CTRLPOINT2,     GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL,                                                                        },</a>
<a name="ln129">  { DT_LIQUIFY_LAYER_RADIUSPOINT,    GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL,                                                                        },</a>
<a name="ln130">  { DT_LIQUIFY_LAYER_HARDNESSPOINT1, GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_NODE_SELECTED,                                  },</a>
<a name="ln131">  { DT_LIQUIFY_LAYER_HARDNESSPOINT2, GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_NODE_SELECTED,                                  },</a>
<a name="ln132">  { DT_LIQUIFY_LAYER_STRENGTHPOINT,  GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_ANY_TOOL,                                                                         },</a>
<a name="ln133">  { DT_LIQUIFY_LAYER_CENTERPOINT,    GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_ANY_TOOL  | DT_LIQUIFY_LAYER_FLAG_HIT_TEST,                                       },</a>
<a name="ln134">  { DT_LIQUIFY_LAYER_CTRLPOINT1,     GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_HIT_TEST,                                       },</a>
<a name="ln135">  { DT_LIQUIFY_LAYER_CTRLPOINT2,     GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_HIT_TEST,                                       },</a>
<a name="ln136">  { DT_LIQUIFY_LAYER_RADIUSPOINT,    GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_HIT_TEST,                                       },</a>
<a name="ln137">  { DT_LIQUIFY_LAYER_HARDNESSPOINT1, GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_NODE_SELECTED | DT_LIQUIFY_LAYER_FLAG_HIT_TEST, },</a>
<a name="ln138">  { DT_LIQUIFY_LAYER_HARDNESSPOINT2, GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_NODE_SELECTED | DT_LIQUIFY_LAYER_FLAG_HIT_TEST, },</a>
<a name="ln139">  { DT_LIQUIFY_LAYER_STRENGTHPOINT,  GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_ANY_TOOL  | DT_LIQUIFY_LAYER_FLAG_HIT_TEST,                                       }</a>
<a name="ln140">};</a>
<a name="ln141"> </a>
<a name="ln142">typedef enum</a>
<a name="ln143">{</a>
<a name="ln144">  DT_LIQUIFY_UI_WIDTH_THINLINE,</a>
<a name="ln145">  DT_LIQUIFY_UI_WIDTH_THICKLINE,</a>
<a name="ln146">  DT_LIQUIFY_UI_WIDTH_DOUBLELINE,</a>
<a name="ln147">  DT_LIQUIFY_UI_WIDTH_GIZMO,</a>
<a name="ln148">  DT_LIQUIFY_UI_WIDTH_GIZMO_SMALL,</a>
<a name="ln149">  DT_LIQUIFY_UI_WIDTH_DEFAULT_RADIUS,</a>
<a name="ln150">  DT_LIQUIFY_UI_WIDTH_DEFAULT_STRENGTH,</a>
<a name="ln151">  DT_LIQUIFY_UI_WIDTH_MIN_DRAG,</a>
<a name="ln152">  DT_LIQUIFY_UI_WIDTH_LAST</a>
<a name="ln153">} dt_liquify_ui_width_enum_t;</a>
<a name="ln154"> </a>
<a name="ln155">float dt_liquify_ui_widths [] =</a>
<a name="ln156">{</a>
<a name="ln157">  // value in 1/96 inch (that is: in pixels on a standard 96 dpi screen)</a>
<a name="ln158">    2.0, // DT_LIQUIFY_UI_WIDTH_THINLINE</a>
<a name="ln159">    3.0, // DT_LIQUIFY_UI_WIDTH_THICKLINE</a>
<a name="ln160">    3.0, // DT_LIQUIFY_UI_WIDTH_DOUBLELINE</a>
<a name="ln161">    9.0, // DT_LIQUIFY_UI_WIDTH_GIZMO</a>
<a name="ln162">    7.0, // DT_LIQUIFY_UI_WIDTH_GIZMO_SMALL</a>
<a name="ln163">  100.0, // DT_LIQUIFY_UI_WIDTH_DEFAULT_RADIUS,</a>
<a name="ln164">   50.0, // DT_LIQUIFY_UI_WIDTH_DEFAULT_STRENGTH,</a>
<a name="ln165">    4.0  // DT_LIQUIFY_UI_WIDTH_MIN_DRAG</a>
<a name="ln166">};</a>
<a name="ln167"> </a>
<a name="ln168">typedef enum</a>
<a name="ln169">{</a>
<a name="ln170">  DT_LIQUIFY_WARP_TYPE_LINEAR,         ///&lt; A linear warp originating from one point.</a>
<a name="ln171">  DT_LIQUIFY_WARP_TYPE_RADIAL_GROW,    ///&lt; A radial warp originating from one point.</a>
<a name="ln172">  DT_LIQUIFY_WARP_TYPE_RADIAL_SHRINK,</a>
<a name="ln173">  DT_LIQUIFY_WARP_TYPE_LAST</a>
<a name="ln174">} dt_liquify_warp_type_enum_t;</a>
<a name="ln175"> </a>
<a name="ln176">typedef enum</a>
<a name="ln177">{</a>
<a name="ln178">  DT_LIQUIFY_NODE_TYPE_CUSP,</a>
<a name="ln179">  DT_LIQUIFY_NODE_TYPE_SMOOTH,</a>
<a name="ln180">  DT_LIQUIFY_NODE_TYPE_SYMMETRICAL,</a>
<a name="ln181">  DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH,</a>
<a name="ln182">  DT_LIQUIFY_NODE_TYPE_LAST</a>
<a name="ln183">} dt_liquify_node_type_enum_t;</a>
<a name="ln184"> </a>
<a name="ln185">typedef enum</a>
<a name="ln186">{</a>
<a name="ln187">  DT_LIQUIFY_STATUS_NONE = 0,</a>
<a name="ln188">  DT_LIQUIFY_STATUS_NEW = 1,</a>
<a name="ln189">  DT_LIQUIFY_STATUS_INTERPOLATED = 2,</a>
<a name="ln190">  DT_LIQUIFY_STATUS_PREVIEW = 4,</a>
<a name="ln191">  DT_LIQUIFY_STATUS_LAST</a>
<a name="ln192">} dt_liquify_status_enum_t;</a>
<a name="ln193"> </a>
<a name="ln194">// enumerates the shapes types we use.</a>
<a name="ln195"> </a>
<a name="ln196">typedef enum</a>
<a name="ln197">{</a>
<a name="ln198">  DT_LIQUIFY_PATH_INVALIDATED = 0,</a>
<a name="ln199">  DT_LIQUIFY_PATH_MOVE_TO_V1,</a>
<a name="ln200">  DT_LIQUIFY_PATH_LINE_TO_V1,</a>
<a name="ln201">  DT_LIQUIFY_PATH_CURVE_TO_V1,</a>
<a name="ln202">} dt_liquify_path_data_enum_t;</a>
<a name="ln203"> </a>
<a name="ln204">typedef struct</a>
<a name="ln205">{</a>
<a name="ln206">  dt_liquify_path_data_enum_t type;</a>
<a name="ln207">  dt_liquify_node_type_enum_t node_type;</a>
<a name="ln208">  dt_liquify_layer_enum_t selected;</a>
<a name="ln209">  dt_liquify_layer_enum_t hovered;</a>
<a name="ln210">  int8_t prev;</a>
<a name="ln211">  int8_t idx;</a>
<a name="ln212">  int8_t next;</a>
<a name="ln213">} dt_liquify_path_header_t;</a>
<a name="ln214"> </a>
<a name="ln215">// Scalars and vectors are represented here as points because the only</a>
<a name="ln216">// thing we can reasonably distort_transform are points.</a>
<a name="ln217"> </a>
<a name="ln218">typedef struct</a>
<a name="ln219">{</a>
<a name="ln220">  float complex point;</a>
<a name="ln221">  float complex strength;   ///&lt; a point (the effective strength vector is: strength - point)</a>
<a name="ln222">  float complex radius;     ///&lt; a point (the effective radius scalar is: cabs (radius - point))</a>
<a name="ln223">  float control1;           ///&lt; range 0.0 .. 1.0 == radius</a>
<a name="ln224">  float control2;           ///&lt; range 0.0 .. 1.0 == radius</a>
<a name="ln225">  dt_liquify_warp_type_enum_t type;</a>
<a name="ln226">  dt_liquify_status_enum_t status;</a>
<a name="ln227">} dt_liquify_warp_t;</a>
<a name="ln228"> </a>
<a name="ln229">typedef struct</a>
<a name="ln230">{</a>
<a name="ln231">  float complex ctrl1;</a>
<a name="ln232">  float complex ctrl2;</a>
<a name="ln233">} dt_liquify_node_t;</a>
<a name="ln234"> </a>
<a name="ln235">// set up lots of alternative ways to get at the popular members.</a>
<a name="ln236"> </a>
<a name="ln237">typedef struct</a>
<a name="ln238">{</a>
<a name="ln239">  dt_liquify_path_header_t header;</a>
<a name="ln240">  dt_liquify_warp_t        warp;</a>
<a name="ln241">  dt_liquify_node_t        node; // extended node data</a>
<a name="ln242">} dt_liquify_path_data_t;</a>
<a name="ln243"> </a>
<a name="ln244">typedef struct</a>
<a name="ln245">{</a>
<a name="ln246">  dt_liquify_layer_enum_t layer;</a>
<a name="ln247">  dt_liquify_path_data_t *elem;</a>
<a name="ln248">} dt_liquify_hit_t;</a>
<a name="ln249"> </a>
<a name="ln250">static const dt_liquify_hit_t NOWHERE = { DT_LIQUIFY_LAYER_BACKGROUND, NULL };</a>
<a name="ln251"> </a>
<a name="ln252">typedef struct</a>
<a name="ln253">{</a>
<a name="ln254">  dt_liquify_path_data_t nodes[MAX_NODES];</a>
<a name="ln255">} dt_iop_liquify_params_t;</a>
<a name="ln256"> </a>
<a name="ln257">typedef struct</a>
<a name="ln258">{</a>
<a name="ln259">  int warp_kernel;</a>
<a name="ln260">} dt_iop_liquify_global_data_t;</a>
<a name="ln261"> </a>
<a name="ln262">typedef struct</a>
<a name="ln263">{</a>
<a name="ln264">  dt_pthread_mutex_t lock;</a>
<a name="ln265">  dt_iop_liquify_params_t params;</a>
<a name="ln266">  int node_index; // last node index inserted</a>
<a name="ln267"> </a>
<a name="ln268">  float complex last_mouse_pos;</a>
<a name="ln269">  float complex last_button1_pressed_pos;</a>
<a name="ln270">  GdkModifierType last_mouse_mods;  ///&lt; GDK modifiers at the time mouse button was pressed.</a>
<a name="ln271"> </a>
<a name="ln272">  dt_liquify_hit_t last_hit;      ///&lt; Element last hit with mouse button.</a>
<a name="ln273">  dt_liquify_hit_t dragging;      ///&lt; Element being dragged with mouse button.</a>
<a name="ln274"> </a>
<a name="ln275">  dt_liquify_path_data_t *temp;    ///&lt; Points to the element under construction or NULL.</a>
<a name="ln276">  dt_liquify_status_enum_t status; ///&lt; Various flags.</a>
<a name="ln277"> </a>
<a name="ln278">  cairo_t *fake_cr;     ///&lt; A fake cairo context for hit testing and coordinate transform.</a>
<a name="ln279"> </a>
<a name="ln280">  GtkLabel *label;</a>
<a name="ln281">  GtkToggleButton *btn_point_tool, *btn_line_tool, *btn_curve_tool, *btn_node_tool;</a>
<a name="ln282"> </a>
<a name="ln283">} dt_iop_liquify_gui_data_t;</a>
<a name="ln284"> </a>
<a name="ln285"> </a>
<a name="ln286">// this returns a translatable name</a>
<a name="ln287">const char *name()</a>
<a name="ln288">{</a>
<a name="ln289">  return _(&quot;liquify&quot;);</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">int default_group()</a>
<a name="ln293">{</a>
<a name="ln294">  return IOP_GROUP_CORRECT;</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">int flags()</a>
<a name="ln298">{</a>
<a name="ln299">  return IOP_FLAGS_SUPPORTS_BLENDING;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">int operation_tags()</a>
<a name="ln303">{</a>
<a name="ln304">   return IOP_TAG_DISTORT;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln308">{</a>
<a name="ln309">  return iop_cs_rgb;</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312">/******************************************************************************/</a>
<a name="ln313">/* Code common to op-engine and gui.                                          */</a>
<a name="ln314">/******************************************************************************/</a>
<a name="ln315"> </a>
<a name="ln316">static float get_rot(const dt_liquify_warp_type_enum_t warp_type)</a>
<a name="ln317">{</a>
<a name="ln318">  if (warp_type == DT_LIQUIFY_WARP_TYPE_RADIAL_SHRINK)</a>
<a name="ln319">    return M_PI;</a>
<a name="ln320">  else</a>
<a name="ln321">    return 0.0;</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">static dt_liquify_path_data_t *node_alloc (dt_iop_liquify_params_t *p, int *node_index)</a>
<a name="ln325">{</a>
<a name="ln326">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln327">    if (p-&gt;nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln328">    {</a>
<a name="ln329">      *node_index = k;</a>
<a name="ln330">      p-&gt;nodes[k].header.idx = k;</a>
<a name="ln331">      p-&gt;nodes[k].header.next = p-&gt;nodes[k].header.prev = -1;</a>
<a name="ln332">      p-&gt;nodes[k].header.selected = p-&gt;nodes[k].header.hovered = 0;</a>
<a name="ln333">      return &amp;p-&gt;nodes[k];</a>
<a name="ln334">    }</a>
<a name="ln335">  return NULL;</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338">static dt_liquify_path_data_t *node_prev (dt_iop_liquify_params_t *p, const dt_liquify_path_data_t *n)</a>
<a name="ln339">{</a>
<a name="ln340">  if (n-&gt;header.prev == -1)</a>
<a name="ln341">    return NULL;</a>
<a name="ln342">  else</a>
<a name="ln343">    return &amp;p-&gt;nodes[n-&gt;header.prev];</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">static dt_liquify_path_data_t *node_get (dt_iop_liquify_params_t *p, const int index)</a>
<a name="ln347">{</a>
<a name="ln348">  if (index &gt; -1 &amp;&amp; index &lt; MAX_NODES)</a>
<a name="ln349">    return &amp;p-&gt;nodes[index];</a>
<a name="ln350">  else</a>
<a name="ln351">    return NULL;</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">static dt_liquify_path_data_t *node_next (dt_iop_liquify_params_t *p, const dt_liquify_path_data_t *n)</a>
<a name="ln355">{</a>
<a name="ln356">  if (n-&gt;header.next == -1)</a>
<a name="ln357">    return NULL;</a>
<a name="ln358">  else</a>
<a name="ln359">    return &amp;p-&gt;nodes[n-&gt;header.next];</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">static void node_insert_before (dt_iop_liquify_params_t *p, dt_liquify_path_data_t *this, dt_liquify_path_data_t *new)</a>
<a name="ln363">{</a>
<a name="ln364">  new-&gt;header.next  = this-&gt;header.idx;</a>
<a name="ln365">  new-&gt;header.prev  = this-&gt;header.prev;</a>
<a name="ln366">  if (this-&gt;header.prev != -1)</a>
<a name="ln367">    p-&gt;nodes[this-&gt;header.prev].header.next = new-&gt;header.idx;</a>
<a name="ln368">  this-&gt;header.prev = new-&gt;header.idx;</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">static void node_gc (dt_iop_liquify_params_t *p)</a>
<a name="ln372">{</a>
<a name="ln373">  int last=0;</a>
<a name="ln374">  for (last=MAX_NODES-1; last&gt;0; last--)</a>
<a name="ln375">    if (p-&gt;nodes[last].header.type != DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln376">      break;</a>
<a name="ln377">  int k = 0;</a>
<a name="ln378"> </a>
<a name="ln379">  while (k&lt;=last)</a>
<a name="ln380">  {</a>
<a name="ln381">    if (p-&gt;nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln382">    {</a>
<a name="ln383">      for (int e=0; e&lt;last; e++)</a>
<a name="ln384">      {</a>
<a name="ln385">        //  then move slot if above position k</a>
<a name="ln386">        if (e &gt;= k)                       p-&gt;nodes[e] = p-&gt;nodes[e+1];</a>
<a name="ln387">        //  update all pointers above position k</a>
<a name="ln388">        if (e &gt;= k)                       p-&gt;nodes[e].header.idx--;</a>
<a name="ln389">        if (p-&gt;nodes[e].header.prev &gt;= k) p-&gt;nodes[e].header.prev--;</a>
<a name="ln390">        if (p-&gt;nodes[e].header.next &gt;= k) p-&gt;nodes[e].header.next--;</a>
<a name="ln391">      }</a>
<a name="ln392">      last--;</a>
<a name="ln393">    }</a>
<a name="ln394">    else</a>
<a name="ln395">      k++;</a>
<a name="ln396">  }</a>
<a name="ln397">  //  invalidate all nodes beyond the last moved one</a>
<a name="ln398">  for (int k=last+1; k&lt;MAX_NODES; k++)</a>
<a name="ln399">    p-&gt;nodes[k].header.type = DT_LIQUIFY_PATH_INVALIDATED;</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">static void node_delete (dt_iop_liquify_params_t *p, dt_liquify_path_data_t *this)</a>
<a name="ln403">{</a>
<a name="ln404">  dt_liquify_path_data_t *prev = node_prev (p, this);</a>
<a name="ln405">  dt_liquify_path_data_t *next = node_next (p, this);</a>
<a name="ln406"> </a>
<a name="ln407">  if (!prev &amp;&amp; next)</a>
<a name="ln408">  {</a>
<a name="ln409">    next-&gt;header.prev = -1;</a>
<a name="ln410">    next-&gt;header.type = DT_LIQUIFY_PATH_MOVE_TO_V1;</a>
<a name="ln411">  }</a>
<a name="ln412">  else if (prev)</a>
<a name="ln413">  {</a>
<a name="ln414">    prev-&gt;header.next = this-&gt;header.next;</a>
<a name="ln415"> </a>
<a name="ln416">    if (next)</a>
<a name="ln417">      next-&gt;header.prev = prev-&gt;header.idx;</a>
<a name="ln418">  }</a>
<a name="ln419"> </a>
<a name="ln420">  this-&gt;header.prev = this-&gt;header.next = - 1;</a>
<a name="ln421">  this-&gt;header.type = DT_LIQUIFY_PATH_INVALIDATED;</a>
<a name="ln422">  node_gc (p);</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">static void path_delete (dt_iop_liquify_params_t *p, dt_liquify_path_data_t *this)</a>
<a name="ln426">{</a>
<a name="ln427">  dt_liquify_path_data_t *n = this;</a>
<a name="ln428"> </a>
<a name="ln429">  // clear next</a>
<a name="ln430">  while (n)</a>
<a name="ln431">  {</a>
<a name="ln432">    n-&gt;header.type = DT_LIQUIFY_PATH_INVALIDATED;</a>
<a name="ln433">    n = node_next (p, n);</a>
<a name="ln434">  }</a>
<a name="ln435"> </a>
<a name="ln436">  // clear prev</a>
<a name="ln437">  n = this;</a>
<a name="ln438">  while (n)</a>
<a name="ln439">  {</a>
<a name="ln440">    n-&gt;header.type = DT_LIQUIFY_PATH_INVALIDATED;</a>
<a name="ln441">    n = node_prev (p, n);</a>
<a name="ln442">  }</a>
<a name="ln443">  node_gc (p);</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446">int _dev_distort_transform_plus(dt_develop_t *dev, dt_dev_pixelpipe_t *pipe, const double iop_order, const int transf_direction,</a>
<a name="ln447">                                  float *points, size_t points_count)</a>
<a name="ln448">{</a>
<a name="ln449">  // this is called from the dt_dev_distort_transform_plus(), so the history is already locked</a>
<a name="ln450">  GList *modules = g_list_first(pipe-&gt;iop);</a>
<a name="ln451">  GList *pieces = g_list_first(pipe-&gt;nodes);</a>
<a name="ln452">  while(modules)</a>
<a name="ln453">  {</a>
<a name="ln454">    if(!pieces)</a>
<a name="ln455">    {</a>
<a name="ln456">      return 0;</a>
<a name="ln457">    }</a>
<a name="ln458">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln459">    dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)(pieces-&gt;data);</a>
<a name="ln460">    if(piece-&gt;enabled &amp;&amp; ((transf_direction == DT_DEV_TRANSFORM_DIR_ALL)</a>
<a name="ln461">                          || (transf_direction == DT_DEV_TRANSFORM_DIR_FORW_INCL &amp;&amp; module-&gt;iop_order &gt;= iop_order)</a>
<a name="ln462">                          || (transf_direction == DT_DEV_TRANSFORM_DIR_FORW_EXCL &amp;&amp; module-&gt;iop_order &gt; iop_order)</a>
<a name="ln463">                          || (transf_direction == DT_DEV_TRANSFORM_DIR_BACK_INCL &amp;&amp; module-&gt;iop_order &lt;= iop_order)</a>
<a name="ln464">                          || (transf_direction == DT_DEV_TRANSFORM_DIR_BACK_EXCL &amp;&amp; module-&gt;iop_order &lt; iop_order)) &amp;&amp; </a>
<a name="ln465">      !(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;operation_tags_filter() &amp; module-&gt;operation_tags()))</a>
<a name="ln466">    {</a>
<a name="ln467">      module-&gt;distort_transform(module, piece, points, points_count);</a>
<a name="ln468">    }</a>
<a name="ln469">    modules = g_list_next(modules);</a>
<a name="ln470">    pieces = g_list_next(pieces);</a>
<a name="ln471">  }</a>
<a name="ln472">  return 1;</a>
<a name="ln473">}</a>
<a name="ln474">int _dev_distort_backtransform_plus(dt_develop_t *dev, dt_dev_pixelpipe_t *pipe, const double iop_order, const int transf_direction,</a>
<a name="ln475">                                      float *points, size_t points_count)</a>
<a name="ln476">{</a>
<a name="ln477">  // this is called from the dt_dev_distort_backtransform_plus(), so the history is already locked</a>
<a name="ln478">  GList *modules = g_list_last(pipe-&gt;iop);</a>
<a name="ln479">  GList *pieces = g_list_last(pipe-&gt;nodes);</a>
<a name="ln480">  while(modules)</a>
<a name="ln481">  {</a>
<a name="ln482">    if(!pieces)</a>
<a name="ln483">    {</a>
<a name="ln484">      return 0;</a>
<a name="ln485">    }</a>
<a name="ln486">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln487">    dt_dev_pixelpipe_iop_t *piece = (dt_dev_pixelpipe_iop_t *)(pieces-&gt;data);</a>
<a name="ln488">    if(piece-&gt;enabled &amp;&amp; ((transf_direction == DT_DEV_TRANSFORM_DIR_ALL)</a>
<a name="ln489">                          || (transf_direction == DT_DEV_TRANSFORM_DIR_FORW_INCL &amp;&amp; module-&gt;iop_order &gt;= iop_order)</a>
<a name="ln490">                          || (transf_direction == DT_DEV_TRANSFORM_DIR_FORW_EXCL &amp;&amp; module-&gt;iop_order &gt; iop_order)</a>
<a name="ln491">                          || (transf_direction == DT_DEV_TRANSFORM_DIR_BACK_INCL &amp;&amp; module-&gt;iop_order &lt;= iop_order)</a>
<a name="ln492">                          || (transf_direction == DT_DEV_TRANSFORM_DIR_BACK_EXCL &amp;&amp; module-&gt;iop_order &lt; iop_order)) &amp;&amp;</a>
<a name="ln493">      !(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;operation_tags_filter() &amp; module-&gt;operation_tags()))</a>
<a name="ln494">    {</a>
<a name="ln495">      module-&gt;distort_backtransform(module, piece, points, points_count);</a>
<a name="ln496">    }</a>
<a name="ln497">    modules = g_list_previous(modules);</a>
<a name="ln498">    pieces = g_list_previous(pieces);</a>
<a name="ln499">  }</a>
<a name="ln500">  return 1;</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">/**</a>
<a name="ln504"> * The functions in this group help transform between coordinate</a>
<a name="ln505"> * systems.  (In darktable nomenclature this kind of transform is</a>
<a name="ln506"> * called 'distort').</a>
<a name="ln507"> *</a>
<a name="ln508"> * The transforms between coordinate systems are not necessarily</a>
<a name="ln509"> * perspective transforms (eg. lensfun), therefore no transformation</a>
<a name="ln510"> * matrix can be specified for them, instead all points to be</a>
<a name="ln511"> * transformed have to be passed through a darktable function.</a>
<a name="ln512"> *</a>
<a name="ln513"> * Note: only points may be sensibly 'distorted'. Vectors and scalars</a>
<a name="ln514"> * don't have a meaningful 'distort'.</a>
<a name="ln515"> *</a>
<a name="ln516"> *</a>
<a name="ln517"> * Explanation of the coordinate systems used by this module:</a>
<a name="ln518"> *</a>
<a name="ln519"> * RAW: These are sensor coordinates. They go from x=0, y=0 to x=&lt;sensor</a>
<a name="ln520"> * width&gt;, y=&lt;sensor height&gt;. In a landscape picture (rotated 0°) x=0,</a>
<a name="ln521"> * y=0 will be top left. In a portrait picture (rotated 90°</a>
<a name="ln522"> * counter-clockwise) x=0, y=0 will be bottom left.</a>
<a name="ln523"> *</a>
<a name="ln524"> * The user probably wants liquified regions to be anchored to the</a>
<a name="ln525"> * motive when more transformations are added, eg. a different</a>
<a name="ln526"> * cropping of the image.  For this to work, all coordinates we store</a>
<a name="ln527"> * or pass between gui and pipe are RAW sensor coordinates.</a>
<a name="ln528"> *</a>
<a name="ln529"> *</a>
<a name="ln530"> * PIECE: These are coordinates based on the size of our pipe piece.</a>
<a name="ln531"> * They go from x=0, y=0 to x=&lt;width of piece&gt;, y=&lt;height of piece&gt;.</a>
<a name="ln532"> * PIECE coordinates should only be used while processing an image.</a>
<a name="ln533"> *</a>
<a name="ln534"> * Note: Currently (as of darktable 1.7) there are no geometry</a>
<a name="ln535"> * transforms between RAW and PIECE (our module coming very early in</a>
<a name="ln536"> * the pipe), but this may change in a later release. By allowing for</a>
<a name="ln537"> * them now, we are prepared for pipe order re-shuffeling.</a>
<a name="ln538"> *</a>
<a name="ln539"> *</a>
<a name="ln540"> * CAIRO: These are coordinates based on the cairo view.  The extent</a>
<a name="ln541"> * of the longest side of the cooked picture is normalized to 1.0.</a>
<a name="ln542"> * x=0, y=0 is the top left of the cooked picture.  x=u, y=v is the</a>
<a name="ln543"> * bottom right of a cooked picture with u&lt;=1, v&lt;=1 and either u==1 or</a>
<a name="ln544"> * v==1 depending on orientation.  Note that depending on pan and zoom</a>
<a name="ln545"> * cairo view borders and cooked picture borders may intersect in many</a>
<a name="ln546"> * ways.</a>
<a name="ln547"> *</a>
<a name="ln548"> * The normalized scale helps in choosing default values for vectors and</a>
<a name="ln549"> * radii.</a>
<a name="ln550"> *</a>
<a name="ln551"> * VIEW: These are coordinates based on the cairo view. x=0, y=0 being</a>
<a name="ln552"> * top left and x=&lt;view width&gt;, y=&lt;view height&gt; being bottom right.</a>
<a name="ln553"> * The parameters to the mouse_moved, button_pressed, and</a>
<a name="ln554"> * button_released functions are in this system.</a>
<a name="ln555"> *</a>
<a name="ln556"> * This system is also used for sizing ui-elements. They cannot be</a>
<a name="ln557"> * expressed in CAIRO coordinates because they should not change size</a>
<a name="ln558"> * when zooming the picture.</a>
<a name="ln559"> *</a>
<a name="ln560"> * To get sensible sizes for ui elements and default warps use this</a>
<a name="ln561"> * relation between the scales: CAIRO * get_zoom_scale () == VIEW.</a>
<a name="ln562"> *</a>
<a name="ln563"> */</a>
<a name="ln564"> </a>
<a name="ln565">typedef struct</a>
<a name="ln566">{</a>
<a name="ln567">  dt_develop_t *develop;</a>
<a name="ln568">  dt_dev_pixelpipe_t *pipe;</a>
<a name="ln569">  float from_scale;</a>
<a name="ln570">  float to_scale;</a>
<a name="ln571">  int transf_direction;</a>
<a name="ln572">  gboolean from_distort_transform;</a>
<a name="ln573">} distort_params_t;</a>
<a name="ln574"> </a>
<a name="ln575">static void _distort_paths (const struct dt_iop_module_t *module,</a>
<a name="ln576">                            const distort_params_t *params, const dt_iop_liquify_params_t *p)</a>
<a name="ln577">{</a>
<a name="ln578">  int len = 0;</a>
<a name="ln579"> </a>
<a name="ln580">  // count nodes</a>
<a name="ln581"> </a>
<a name="ln582">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln583">  {</a>
<a name="ln584">    dt_liquify_path_data_t *data = (dt_liquify_path_data_t *) &amp;p-&gt;nodes[k];</a>
<a name="ln585">    if (data-&gt;header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln586">      break;</a>
<a name="ln587"> </a>
<a name="ln588">    switch (data-&gt;header.type)</a>
<a name="ln589">    {</a>
<a name="ln590">    case DT_LIQUIFY_PATH_CURVE_TO_V1:</a>
<a name="ln591">      len += 2;</a>
<a name="ln592">      // fall thru</a>
<a name="ln593">    case DT_LIQUIFY_PATH_MOVE_TO_V1:</a>
<a name="ln594">    case DT_LIQUIFY_PATH_LINE_TO_V1:</a>
<a name="ln595">      len += 3;</a>
<a name="ln596">      break;</a>
<a name="ln597">    default:</a>
<a name="ln598">      break;</a>
<a name="ln599">    }</a>
<a name="ln600">  }</a>
<a name="ln601"> </a>
<a name="ln602">  // create buffer with all points</a>
<a name="ln603"> </a>
<a name="ln604">  float *buffer = malloc (2 * sizeof (float) * len);</a>
<a name="ln605">  float *b = buffer;</a>
<a name="ln606"> </a>
<a name="ln607">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln608">  {</a>
<a name="ln609">    dt_liquify_path_data_t *data = (dt_liquify_path_data_t *) &amp;p-&gt;nodes[k];</a>
<a name="ln610">    if (data-&gt;header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln611">      break;</a>
<a name="ln612"> </a>
<a name="ln613">    switch (data-&gt;header.type)</a>
<a name="ln614">    {</a>
<a name="ln615">    case DT_LIQUIFY_PATH_CURVE_TO_V1:</a>
<a name="ln616">      *b++ = creal (data-&gt;node.ctrl1) / params-&gt;from_scale;</a>
<a name="ln617">      *b++ = cimag (data-&gt;node.ctrl1) / params-&gt;from_scale;</a>
<a name="ln618">      *b++ = creal (data-&gt;node.ctrl2) / params-&gt;from_scale;</a>
<a name="ln619">      *b++ = cimag (data-&gt;node.ctrl2) / params-&gt;from_scale;</a>
<a name="ln620">      // fall thru</a>
<a name="ln621">    case DT_LIQUIFY_PATH_MOVE_TO_V1:</a>
<a name="ln622">    case DT_LIQUIFY_PATH_LINE_TO_V1:</a>
<a name="ln623">      *b++ = creal (data-&gt;warp.point) / params-&gt;from_scale;</a>
<a name="ln624">      *b++ = cimag (data-&gt;warp.point) / params-&gt;from_scale;</a>
<a name="ln625">      *b++ = creal (data-&gt;warp.strength) / params-&gt;from_scale;</a>
<a name="ln626">      *b++ = cimag (data-&gt;warp.strength) / params-&gt;from_scale;</a>
<a name="ln627">      *b++ = creal (data-&gt;warp.radius) / params-&gt;from_scale;</a>
<a name="ln628">      *b++ = cimag (data-&gt;warp.radius) / params-&gt;from_scale;</a>
<a name="ln629">      break;</a>
<a name="ln630">    default:</a>
<a name="ln631">      break;</a>
<a name="ln632">    }</a>
<a name="ln633">  }</a>
<a name="ln634">  if(params-&gt;from_distort_transform)</a>
<a name="ln635">  {</a>
<a name="ln636">    if(params-&gt;transf_direction == DT_DEV_TRANSFORM_DIR_ALL)</a>
<a name="ln637">    {</a>
<a name="ln638">      _dev_distort_transform_plus(params-&gt;develop, params-&gt;pipe, module-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_EXCL, buffer, len);</a>
<a name="ln639">      _dev_distort_transform_plus(params-&gt;develop, params-&gt;pipe, module-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, buffer, len);</a>
<a name="ln640">    }</a>
<a name="ln641">    else</a>
<a name="ln642">      _dev_distort_transform_plus(params-&gt;develop, params-&gt;pipe, module-&gt;iop_order, params-&gt;transf_direction, buffer, len);</a>
<a name="ln643">  }</a>
<a name="ln644">  else</a>
<a name="ln645">  {</a>
<a name="ln646">    if(params-&gt;transf_direction == DT_DEV_TRANSFORM_DIR_ALL)</a>
<a name="ln647">    {</a>
<a name="ln648">      dt_dev_distort_transform_plus(params-&gt;develop, params-&gt;pipe, module-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_EXCL, buffer, len);</a>
<a name="ln649">      dt_dev_distort_transform_plus(params-&gt;develop, params-&gt;pipe, module-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, buffer, len);</a>
<a name="ln650">    }</a>
<a name="ln651">    else</a>
<a name="ln652">      dt_dev_distort_transform_plus(params-&gt;develop, params-&gt;pipe, module-&gt;iop_order, params-&gt;transf_direction, buffer, len);</a>
<a name="ln653">  }</a>
<a name="ln654">  </a>
<a name="ln655">  // record back the transformed points</a>
<a name="ln656"> </a>
<a name="ln657">  b = buffer;</a>
<a name="ln658"> </a>
<a name="ln659">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln660">  {</a>
<a name="ln661">    dt_liquify_path_data_t *data = (dt_liquify_path_data_t *) &amp;p-&gt;nodes[k];</a>
<a name="ln662">    if (data-&gt;header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln663">      break;</a>
<a name="ln664"> </a>
<a name="ln665">    switch (data-&gt;header.type)</a>
<a name="ln666">    {</a>
<a name="ln667">       case DT_LIQUIFY_PATH_CURVE_TO_V1:</a>
<a name="ln668">         data-&gt;node.ctrl1 = (b[0] + b[1] * I) * params-&gt;to_scale;</a>
<a name="ln669">         b += 2;</a>
<a name="ln670">         data-&gt;node.ctrl2 = (b[0] + b[1] * I) * params-&gt;to_scale;</a>
<a name="ln671">         b += 2;</a>
<a name="ln672">         // fall thru</a>
<a name="ln673">       case DT_LIQUIFY_PATH_MOVE_TO_V1:</a>
<a name="ln674">       case DT_LIQUIFY_PATH_LINE_TO_V1:</a>
<a name="ln675">         data-&gt;warp.point = (b[0] + b[1] * I) * params-&gt;to_scale;</a>
<a name="ln676">         b += 2;</a>
<a name="ln677">         data-&gt;warp.strength = (b[0] + b[1] * I) * params-&gt;to_scale;</a>
<a name="ln678">         b += 2;</a>
<a name="ln679">         data-&gt;warp.radius = (b[0] + b[1] * I) * params-&gt;to_scale;</a>
<a name="ln680">         b += 2;</a>
<a name="ln681">         break;</a>
<a name="ln682">       default:</a>
<a name="ln683">         break;</a>
<a name="ln684">    }</a>
<a name="ln685">  }</a>
<a name="ln686"> </a>
<a name="ln687">  free (buffer);</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690">static void distort_paths_raw_to_piece (const struct dt_iop_module_t *module,</a>
<a name="ln691">                                        dt_dev_pixelpipe_t *pipe,</a>
<a name="ln692">                                        const float roi_in_scale,</a>
<a name="ln693">                                        dt_iop_liquify_params_t *p,</a>
<a name="ln694">                                        const gboolean from_distort_transform)</a>
<a name="ln695">{</a>
<a name="ln696">  const distort_params_t params = { module-&gt;dev, pipe, pipe-&gt;iscale, roi_in_scale, DT_DEV_TRANSFORM_DIR_BACK_EXCL, from_distort_transform };</a>
<a name="ln697">  _distort_paths (module, &amp;params, p);</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">// op-engine code</a>
<a name="ln701"> </a>
<a name="ln702">static inline float complex normalize (const float complex v)</a>
<a name="ln703">{</a>
<a name="ln704">  if (cabs (v) &lt; 0.000001)</a>
<a name="ln705">    return 1.0;</a>
<a name="ln706">  return v / cabs (v);</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">// calculate the linear blend of scalars a and b</a>
<a name="ln710"> </a>
<a name="ln711">static inline float mix (const float a, const float b, const float t)</a>
<a name="ln712">{</a>
<a name="ln713">  return a + (b - a) * t;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716"> </a>
<a name="ln717">// calculate the linear blend of points p0 and p1</a>
<a name="ln718"> </a>
<a name="ln719">static inline float complex cmix (const float complex p0, const float complex p1, const float t)</a>
<a name="ln720">{</a>
<a name="ln721">  return p0 + (p1 - p0) * t;</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724">static void mix_warps (dt_liquify_warp_t *result,</a>
<a name="ln725">                       const dt_liquify_warp_t *warp1,</a>
<a name="ln726">                       const dt_liquify_warp_t *warp2,</a>
<a name="ln727">                       const complex float pt,</a>
<a name="ln728">                       const float t)</a>
<a name="ln729">{</a>
<a name="ln730">  result-&gt;type     = warp1-&gt;type;</a>
<a name="ln731">  result-&gt;control1 = mix  (warp1-&gt;control1, warp2-&gt;control1, t);</a>
<a name="ln732">  result-&gt;control2 = mix  (warp1-&gt;control2, warp2-&gt;control2, t);</a>
<a name="ln733"> </a>
<a name="ln734">  const float radius = mix (cabs (warp1-&gt;radius - warp1-&gt;point), cabs (warp2-&gt;radius - warp2-&gt;point), t);</a>
<a name="ln735">  result-&gt;radius     = pt + radius;</a>
<a name="ln736"> </a>
<a name="ln737">  const float r    = mix (cabs (warp1-&gt;strength - warp1-&gt;point), cabs (warp2-&gt;strength - warp2-&gt;point), t);</a>
<a name="ln738">  const float phi  = mix (carg (warp1-&gt;strength - warp1-&gt;point), carg (warp2-&gt;strength - warp2-&gt;point), t);</a>
<a name="ln739">  result-&gt;strength = pt + r * cexp (phi * I);</a>
<a name="ln740"> </a>
<a name="ln741">  result-&gt;point    = pt;</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">// Interpolate a cubic bezier spline into a series of points.</a>
<a name="ln745"> </a>
<a name="ln746">static void interpolate_cubic_bezier (const float complex p0,</a>
<a name="ln747">                                      const float complex p1,</a>
<a name="ln748">                                      const float complex p2,</a>
<a name="ln749">                                      const float complex p3,</a>
<a name="ln750">                                      float complex buffer[],</a>
<a name="ln751">                                      const int n)</a>
<a name="ln752">{</a>
<a name="ln753">  // convert from bernstein basis to polynomial basis to get faster math</a>
<a name="ln754">  // See: http://www.tinaja.com/glib/cubemath.pdf</a>
<a name="ln755">  const float complex A = p3 - 3 * p2 + 3 * p1 -     p0;</a>
<a name="ln756">  const float complex B =      3 * p2 - 6 * p1 + 3 * p0;</a>
<a name="ln757">  const float complex C =               3 * p1 - 3 * p0;</a>
<a name="ln758">  const float complex D =                            p0;</a>
<a name="ln759"> </a>
<a name="ln760">  float complex *buf = buffer;</a>
<a name="ln761">  const float step = 1.0 / n;</a>
<a name="ln762">  float t = step;</a>
<a name="ln763">  *buf++ = p0;</a>
<a name="ln764"> </a>
<a name="ln765">  for (int i = 1; i &lt; n - 1; ++i)</a>
<a name="ln766">  {</a>
<a name="ln767">    *buf++ = ((((A) * t) + B) * t + C) * t + D;</a>
<a name="ln768">    t += step;</a>
<a name="ln769">  }</a>
<a name="ln770">  *buf = p3;</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">static GList *interpolate_paths (dt_iop_liquify_params_t *p);</a>
<a name="ln774"> </a>
<a name="ln775">/*</a>
<a name="ln776">  Get approx. arc length of a curve.</a>
<a name="ln777"> </a>
<a name="ln778">  Used to approximate the arc length of a bezier curve.</a>
<a name="ln779">*/</a>
<a name="ln780"> </a>
<a name="ln781">static float get_arc_length (const float complex points[], const int n_points)</a>
<a name="ln782">{</a>
<a name="ln783">  float length = 0.0;</a>
<a name="ln784">  for (int i = 1; i &lt; n_points; i++)</a>
<a name="ln785">    length += cabs (points[i-1] - points[i]);</a>
<a name="ln786">  return length;</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">typedef struct</a>
<a name="ln790">{</a>
<a name="ln791">  int i;</a>
<a name="ln792">  double length;</a>
<a name="ln793">} restart_cookie_t;</a>
<a name="ln794"> </a>
<a name="ln795">/*</a>
<a name="ln796">  Interpolate a point on a curve at a specified arc length.</a>
<a name="ln797"> </a>
<a name="ln798">  In a bezier curve the parameter t usually does not correspond to</a>
<a name="ln799">  the arc length.</a>
<a name="ln800">*/</a>
<a name="ln801"> </a>
<a name="ln802">static float complex point_at_arc_length (const float complex points[], const int n_points,</a>
<a name="ln803">                                          const float arc_length, restart_cookie_t *restart)</a>
<a name="ln804">{</a>
<a name="ln805">  float length = restart ? restart-&gt;length : 0.0;</a>
<a name="ln806">  int i        = restart ? restart-&gt;i      : 1;</a>
<a name="ln807"> </a>
<a name="ln808">  for ( ; i &lt; n_points; i++)</a>
<a name="ln809">  {</a>
<a name="ln810">    const float prev_length = length;</a>
<a name="ln811">    length += cabsf (points[i-1] - points[i]);</a>
<a name="ln812"> </a>
<a name="ln813">    if (length &gt;= arc_length)</a>
<a name="ln814">    {</a>
<a name="ln815">      const float t = (arc_length - prev_length) / (length - prev_length);</a>
<a name="ln816">      if (restart)</a>
<a name="ln817">      {</a>
<a name="ln818">        restart-&gt;i = i;</a>
<a name="ln819">        restart-&gt;length = prev_length;</a>
<a name="ln820">      }</a>
<a name="ln821">      return cmix (points[i-1], points[i], t);</a>
<a name="ln822">    }</a>
<a name="ln823">  }</a>
<a name="ln824"> </a>
<a name="ln825">  return points[n_points - 1];</a>
<a name="ln826">}</a>
<a name="ln827"> </a>
<a name="ln828">/*</a>
<a name="ln829">  Build a lookup table for the warp intensity.</a>
<a name="ln830"> </a>
<a name="ln831">  Lookup table for the warp intensity function: f(x). The warp</a>
<a name="ln832">  intensity function determines how much a pixel is influenced by the</a>
<a name="ln833">  warp depending from its distance from a central point.</a>
<a name="ln834"> </a>
<a name="ln835">  Boundary conditions: f(0) must be 1 and f(@a distance) must be 0.</a>
<a name="ln836">  f'(0) and f'(@a distance) must both be 0 or we'll get artifacts on</a>
<a name="ln837">  the picture.</a>
<a name="ln838"> </a>
<a name="ln839">  Implementation: a bezier curve with p0 = 0, 1 and p3 = 1, 0. p1 is</a>
<a name="ln840">  defined by @a control1, 1 and p2 by @a control1, 0.  Because a</a>
<a name="ln841">  bezier is parameterized on t, we have to reparameterize on x, which</a>
<a name="ln842">  we do by linear interpolation.</a>
<a name="ln843"> </a>
<a name="ln844">  Octave code:</a>
<a name="ln845"> </a>
<a name="ln846">  t = linspace (0,1,100);</a>
<a name="ln847">  grid;</a>
<a name="ln848">  hold on;</a>
<a name="ln849">  for steps = 0:0.1:1</a>
<a name="ln850">    cpoints = [0,1; steps,1; steps,0; 1,0];</a>
<a name="ln851">    bezier = cbezier2poly (cpoints);</a>
<a name="ln852">    x = polyval (bezier(1,:), t);</a>
<a name="ln853">    y = polyval (bezier(2,:), t);</a>
<a name="ln854">    plot (t, interp1 (x, y, t));</a>
<a name="ln855">  end</a>
<a name="ln856">  hold off;</a>
<a name="ln857">*/</a>
<a name="ln858"> </a>
<a name="ln859">static float *</a>
<a name="ln860">build_lookup_table (const int distance, const float control1, const float control2)</a>
<a name="ln861">{</a>
<a name="ln862">  float complex *clookup = dt_alloc_align(64, (distance + 2) * sizeof (float complex));</a>
<a name="ln863"> </a>
<a name="ln864">  interpolate_cubic_bezier (I, control1 + I, control2, 1.0, clookup, distance + 2);</a>
<a name="ln865"> </a>
<a name="ln866">  // reparameterize bezier by x and keep only y values</a>
<a name="ln867"> </a>
<a name="ln868">  float *lookup = dt_alloc_align(64, (distance + 2) * sizeof(float));</a>
<a name="ln869">  float *ptr = lookup;</a>
<a name="ln870">  float complex *cptr = clookup + 1;</a>
<a name="ln871">  const float complex *cptr_end = cptr + distance;</a>
<a name="ln872">  const float step = 1.0 / (float) distance;</a>
<a name="ln873">  float x = 0.0;</a>
<a name="ln874"> </a>
<a name="ln875">  *ptr++ = 1.0;</a>
<a name="ln876">  for (int i = 1; i &lt; distance &amp;&amp; cptr &lt; cptr_end; i++)</a>
<a name="ln877">  {</a>
<a name="ln878">    x += step;</a>
<a name="ln879">    while (creal (*cptr) &lt; x &amp;&amp; cptr &lt; cptr_end)</a>
<a name="ln880">      cptr++;</a>
<a name="ln881">    const float dx1 = creal (cptr[0] - cptr[-1]);</a>
<a name="ln882">    const float dx2 = x - creal (cptr[-1]);</a>
<a name="ln883">    *ptr++ = cimag (cptr[0]) + (dx2 / dx1) * (cimag (cptr[0]) - cimag (cptr[-1]));</a>
<a name="ln884">  }</a>
<a name="ln885">  *ptr++ = 0.0;</a>
<a name="ln886"> </a>
<a name="ln887">  dt_free_align (clookup);</a>
<a name="ln888">  return lookup;</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891">static void compute_round_stamp_extent (cairo_rectangle_int_t *stamp_extent,</a>
<a name="ln892">                                        const dt_liquify_warp_t *warp)</a>
<a name="ln893">{</a>
<a name="ln894"> </a>
<a name="ln895">  const int iradius = round (cabs (warp-&gt;radius - warp-&gt;point));</a>
<a name="ln896">  assert (iradius &gt; 0);</a>
<a name="ln897"> </a>
<a name="ln898">  stamp_extent-&gt;x = stamp_extent-&gt;y = -iradius;</a>
<a name="ln899">  stamp_extent-&gt;x += creal (warp-&gt;point);</a>
<a name="ln900">  stamp_extent-&gt;y += cimag (warp-&gt;point);</a>
<a name="ln901">  stamp_extent-&gt;width = stamp_extent-&gt;height = 2 * iradius + 1;</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904">/*</a>
<a name="ln905">  Compute a round (circular) stamp.</a>
<a name="ln906"> </a>
<a name="ln907">  The stamp is a vector field of warp vectors around a center point.</a>
<a name="ln908"> </a>
<a name="ln909">  In a linear warp the center point gets a warp of @a strength, while</a>
<a name="ln910">  points on the circumference of the circle get no warp at all.</a>
<a name="ln911">  Between center and circumference the warp magnitude tapers off</a>
<a name="ln912">  following a curve (see: build_lookup_table()).</a>
<a name="ln913"> </a>
<a name="ln914">  Note that when applying a linear stamp to a path, we will first rotate its</a>
<a name="ln915">  vectors into the direction of the path.</a>
<a name="ln916"> </a>
<a name="ln917">  In a radial warp the center point and the points on the</a>
<a name="ln918">  circumference get no warp. Between center and circumference the</a>
<a name="ln919">  warp magnitude follows a curve with maximum at radius / 0.5</a>
<a name="ln920"> </a>
<a name="ln921">  Our stamp is stored in a rectangular region.</a>
<a name="ln922">*/</a>
<a name="ln923"> </a>
<a name="ln924">static void build_round_stamp (float complex **pstamp,</a>
<a name="ln925">                               cairo_rectangle_int_t *stamp_extent,</a>
<a name="ln926">                               const dt_liquify_warp_t *warp)</a>
<a name="ln927">{</a>
<a name="ln928">  const int iradius = round (cabs (warp-&gt;radius - warp-&gt;point));</a>
<a name="ln929">  assert (iradius &gt; 0);</a>
<a name="ln930"> </a>
<a name="ln931">  stamp_extent-&gt;x = stamp_extent-&gt;y = -iradius;</a>
<a name="ln932">  stamp_extent-&gt;width = stamp_extent-&gt;height = 2 * iradius + 1;</a>
<a name="ln933"> </a>
<a name="ln934">  // 0.5 is factored in so the warp starts to degenerate when the</a>
<a name="ln935">  // strength arrow crosses the warp radius.</a>
<a name="ln936">  float complex strength = 0.5 * (warp-&gt;strength - warp-&gt;point);</a>
<a name="ln937">  strength = (warp-&gt;status &amp; DT_LIQUIFY_STATUS_INTERPOLATED) ?</a>
<a name="ln938">    (strength * STAMP_RELOCATION) : strength;</a>
<a name="ln939">  const float abs_strength = cabs (strength);</a>
<a name="ln940"> </a>
<a name="ln941">  float complex *stamp = malloc (sizeof (float complex)</a>
<a name="ln942">                                 * stamp_extent-&gt;width * stamp_extent-&gt;height);</a>
<a name="ln943"> </a>
<a name="ln944">  // clear memory</a>
<a name="ln945">  #ifdef _OPENMP</a>
<a name="ln946">  #pragma omp parallel for schedule (static) default (shared)</a>
<a name="ln947">  #endif</a>
<a name="ln948"> </a>
<a name="ln949">  for (int i = 0; i &lt; stamp_extent-&gt;height; i++)</a>
<a name="ln950">  {</a>
<a name="ln951">    float complex *row = stamp + i * stamp_extent-&gt;width;</a>
<a name="ln952">    memset (row, 0, sizeof (float complex) * stamp_extent-&gt;width);</a>
<a name="ln953">  }</a>
<a name="ln954"> </a>
<a name="ln955">  // lookup table: map of distance from center point =&gt; warp</a>
<a name="ln956">  const int table_size = iradius * LOOKUP_OVERSAMPLE;</a>
<a name="ln957">  const float *lookup_table = build_lookup_table (table_size, warp-&gt;control1, warp-&gt;control2);</a>
<a name="ln958"> </a>
<a name="ln959">  // points into buffer at the center of the circle</a>
<a name="ln960">  float complex *center = stamp + 2 * iradius * iradius + 2 * iradius;</a>
<a name="ln961"> </a>
<a name="ln962">  // The expensive operation here is hypotf ().  By dividing the</a>
<a name="ln963">  // circle in octants and doing only the inside we have to calculate</a>
<a name="ln964">  // hypotf only for PI / 32 = 0.098 of the stamp area.</a>
<a name="ln965">  #ifdef _OPENMP</a>
<a name="ln966">  #pragma omp parallel for schedule (dynamic, 1) default (shared)</a>
<a name="ln967">  #endif</a>
<a name="ln968"> </a>
<a name="ln969">  for (int y = 0; y &lt;= iradius; y++)</a>
<a name="ln970">  {</a>
<a name="ln971">    for (int x = y; x &lt;= iradius; x++)</a>
<a name="ln972">    {</a>
<a name="ln973">      const float dist = hypotf (x, y);</a>
<a name="ln974">      const int idist = round (dist * LOOKUP_OVERSAMPLE);</a>
<a name="ln975">      if (idist &gt;= table_size)</a>
<a name="ln976">        // idist will only grow bigger in this row</a>
<a name="ln977">        goto next_row;</a>
<a name="ln978"> </a>
<a name="ln979">      // pointers into the 8 octants of the circle</a>
<a name="ln980">      // octant count is ccw from positive x-axis</a>
<a name="ln981">      float complex *o1 = center - y * stamp_extent-&gt;width + x;</a>
<a name="ln982">      float complex *o2 = center - x * stamp_extent-&gt;width + y;</a>
<a name="ln983">      float complex *o3 = center - x * stamp_extent-&gt;width - y;</a>
<a name="ln984">      float complex *o4 = center - y * stamp_extent-&gt;width - x;</a>
<a name="ln985">      float complex *o5 = center + y * stamp_extent-&gt;width - x;</a>
<a name="ln986">      float complex *o6 = center + x * stamp_extent-&gt;width - y;</a>
<a name="ln987">      float complex *o7 = center + x * stamp_extent-&gt;width + y;</a>
<a name="ln988">      float complex *o8 = center + y * stamp_extent-&gt;width + x;</a>
<a name="ln989"> </a>
<a name="ln990">      float abs_lookup = abs_strength * lookup_table[idist] / iradius;</a>
<a name="ln991"> </a>
<a name="ln992">      switch (warp-&gt;type)</a>
<a name="ln993">      {</a>
<a name="ln994">         case DT_LIQUIFY_WARP_TYPE_RADIAL_GROW:</a>
<a name="ln995">           *o1 = abs_lookup * ( x - y * I);</a>
<a name="ln996">           *o2 = abs_lookup * ( y - x * I);</a>
<a name="ln997">           *o3 = abs_lookup * (-y - x * I);</a>
<a name="ln998">           *o4 = abs_lookup * (-x - y * I);</a>
<a name="ln999">           *o5 = abs_lookup * (-x + y * I);</a>
<a name="ln1000">           *o6 = abs_lookup * (-y + x * I);</a>
<a name="ln1001">           *o7 = abs_lookup * ( y + x * I);</a>
<a name="ln1002">           *o8 = abs_lookup * ( x + y * I);</a>
<a name="ln1003">           break;</a>
<a name="ln1004"> </a>
<a name="ln1005">         case DT_LIQUIFY_WARP_TYPE_RADIAL_SHRINK:</a>
<a name="ln1006">           *o1 = -abs_lookup * ( x - y * I);</a>
<a name="ln1007">           *o2 = -abs_lookup * ( y - x * I);</a>
<a name="ln1008">           *o3 = -abs_lookup * (-y - x * I);</a>
<a name="ln1009">           *o4 = -abs_lookup * (-x - y * I);</a>
<a name="ln1010">           *o5 = -abs_lookup * (-x + y * I);</a>
<a name="ln1011">           *o6 = -abs_lookup * (-y + x * I);</a>
<a name="ln1012">           *o7 = -abs_lookup * ( y + x * I);</a>
<a name="ln1013">           *o8 = -abs_lookup * ( x + y * I);</a>
<a name="ln1014">           break;</a>
<a name="ln1015"> </a>
<a name="ln1016">         default:</a>
<a name="ln1017">           *o1 = *o2 = *o3 = *o4 = *o5 = *o6 = *o7 = *o8 =</a>
<a name="ln1018">             strength * lookup_table[idist];</a>
<a name="ln1019">           break;</a>
<a name="ln1020">      }</a>
<a name="ln1021">    }</a>
<a name="ln1022">  next_row: ; // &quot;;&quot; makes compiler happy</a>
<a name="ln1023">  }</a>
<a name="ln1024"> </a>
<a name="ln1025">  dt_free_align ((void *) lookup_table);</a>
<a name="ln1026">  *pstamp = stamp;</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029">/*</a>
<a name="ln1030">  Applies a stamp at a specified position.</a>
<a name="ln1031"> </a>
<a name="ln1032">  Applies a stamp at the position specified by @a point and adds the</a>
<a name="ln1033">  resulting vector field to the global distortion map @a global_map.</a>
<a name="ln1034"> </a>
<a name="ln1035">  The global distortion map is a map of relative pixel displacements</a>
<a name="ln1036">  encompassing all our paths.</a>
<a name="ln1037">*/</a>
<a name="ln1038"> </a>
<a name="ln1039">static void add_to_global_distortion_map (float complex *global_map,</a>
<a name="ln1040">                                          const cairo_rectangle_int_t *global_map_extent,</a>
<a name="ln1041">                                          const dt_liquify_warp_t *warp,</a>
<a name="ln1042">                                          const float complex *stamp,</a>
<a name="ln1043">                                          const cairo_rectangle_int_t *stamp_extent)</a>
<a name="ln1044">{</a>
<a name="ln1045">  cairo_rectangle_int_t mmext = *stamp_extent;</a>
<a name="ln1046">  mmext.x += (int) round (creal (warp-&gt;point));</a>
<a name="ln1047">  mmext.y += (int) round (cimag (warp-&gt;point));</a>
<a name="ln1048">  cairo_rectangle_int_t cmmext = mmext;</a>
<a name="ln1049">  cairo_region_t *mmreg = cairo_region_create_rectangle (&amp;mmext);</a>
<a name="ln1050">  cairo_region_intersect_rectangle (mmreg, global_map_extent);</a>
<a name="ln1051">  cairo_region_get_extents (mmreg, &amp;cmmext);</a>
<a name="ln1052">  free (mmreg);</a>
<a name="ln1053"> </a>
<a name="ln1054">  #ifdef _OPENMP</a>
<a name="ln1055">  #pragma omp parallel for schedule (static) default (shared)</a>
<a name="ln1056">  #endif</a>
<a name="ln1057"> </a>
<a name="ln1058">  for (int y = cmmext.y; y &lt; cmmext.y + cmmext.height; y++)</a>
<a name="ln1059">  {</a>
<a name="ln1060">    const float complex *srcrow = stamp + ((y - mmext.y) * mmext.width);</a>
<a name="ln1061"> </a>
<a name="ln1062">    float complex *destrow = global_map +</a>
<a name="ln1063">      ((y - global_map_extent-&gt;y) * global_map_extent-&gt;width);</a>
<a name="ln1064"> </a>
<a name="ln1065">    for (int x = cmmext.x; x &lt; cmmext.x + cmmext.width; x++)</a>
<a name="ln1066">    {</a>
<a name="ln1067">      destrow[x - global_map_extent-&gt;x] -= srcrow[x - mmext.x];</a>
<a name="ln1068">    }</a>
<a name="ln1069">  }</a>
<a name="ln1070">}</a>
<a name="ln1071"> </a>
<a name="ln1072">/*</a>
<a name="ln1073">  Applies the global distortion map to the picture.  The distortion</a>
<a name="ln1074">  map maps points to the position from where the new color of the</a>
<a name="ln1075">  point should be sampled from.  The distortion map is in relative</a>
<a name="ln1076">  device coords.</a>
<a name="ln1077">*/</a>
<a name="ln1078"> </a>
<a name="ln1079">static void apply_global_distortion_map (struct dt_iop_module_t *module,</a>
<a name="ln1080">                                         dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1081">                                         const float *in,</a>
<a name="ln1082">                                         float *out,</a>
<a name="ln1083">                                         const dt_iop_roi_t *roi_in,</a>
<a name="ln1084">                                         const dt_iop_roi_t *roi_out,</a>
<a name="ln1085">                                         const float complex *map,</a>
<a name="ln1086">                                         const cairo_rectangle_int_t *extent)</a>
<a name="ln1087">{</a>
<a name="ln1088">  const int ch = piece-&gt;colors;</a>
<a name="ln1089">  const int ch_width = ch * roi_in-&gt;width;</a>
<a name="ln1090">  const struct dt_interpolation * const interpolation =</a>
<a name="ln1091">    dt_interpolation_new (DT_INTERPOLATION_USERPREF);</a>
<a name="ln1092"> </a>
<a name="ln1093">  #ifdef _OPENMP</a>
<a name="ln1094">  #pragma omp parallel for schedule (static) default (shared)</a>
<a name="ln1095">  #endif</a>
<a name="ln1096"> </a>
<a name="ln1097">  for (int y = extent-&gt;y; y &lt; extent-&gt;y + extent-&gt;height; y++)</a>
<a name="ln1098">  {</a>
<a name="ln1099">    // point inside roi_out ?</a>
<a name="ln1100">    if (y &gt;= roi_out-&gt;y &amp;&amp; y &lt; roi_out-&gt;y + roi_out-&gt;height)</a>
<a name="ln1101">    {</a>
<a name="ln1102">      const float complex *row = map + (y - extent-&gt;y) * extent-&gt;width;</a>
<a name="ln1103">      float* out_sample = out + ((y - roi_out-&gt;y) * roi_out-&gt;width +</a>
<a name="ln1104">                               extent-&gt;x - roi_out-&gt;x) * ch;</a>
<a name="ln1105">      for (int x = extent-&gt;x; x &lt; extent-&gt;x + extent-&gt;width; x++)</a>
<a name="ln1106">      {</a>
<a name="ln1107">        if (</a>
<a name="ln1108">          // point inside roi_out ?</a>
<a name="ln1109">          (x &gt;= roi_out-&gt;x &amp;&amp; x &lt; roi_out-&gt;x + roi_out-&gt;width) &amp;&amp;</a>
<a name="ln1110">          // point actually warped ?</a>
<a name="ln1111">          (*row != 0))</a>
<a name="ln1112">        {</a>
<a name="ln1113">          if(ch == 1)</a>
<a name="ln1114">            *out_sample = dt_interpolation_compute_sample(interpolation,</a>
<a name="ln1115">                                                          in,</a>
<a name="ln1116">                                                          x + creal (*row) - roi_in-&gt;x,</a>
<a name="ln1117">                                                          y + cimag (*row) - roi_in-&gt;y,</a>
<a name="ln1118">                                                          roi_in-&gt;width,</a>
<a name="ln1119">                                                          roi_in-&gt;height,</a>
<a name="ln1120">                                                          ch,</a>
<a name="ln1121">                                                          ch_width);</a>
<a name="ln1122">          else</a>
<a name="ln1123">            dt_interpolation_compute_pixel4c (</a>
<a name="ln1124">              interpolation,</a>
<a name="ln1125">              in,</a>
<a name="ln1126">              out_sample,</a>
<a name="ln1127">              x + creal (*row) - roi_in-&gt;x,</a>
<a name="ln1128">              y + cimag (*row) - roi_in-&gt;y,</a>
<a name="ln1129">              roi_in-&gt;width,</a>
<a name="ln1130">              roi_in-&gt;height,</a>
<a name="ln1131">              ch_width);</a>
<a name="ln1132"> </a>
<a name="ln1133">        }</a>
<a name="ln1134">        ++row;</a>
<a name="ln1135">        out_sample += ch;</a>
<a name="ln1136">      }</a>
<a name="ln1137">    }</a>
<a name="ln1138">  }</a>
<a name="ln1139">}</a>
<a name="ln1140"> </a>
<a name="ln1141">// calculate the map extent.</a>
<a name="ln1142"> </a>
<a name="ln1143">static void _get_map_extent (const dt_iop_roi_t *roi_out,</a>
<a name="ln1144">                             GList *interpolated,</a>
<a name="ln1145">                             cairo_rectangle_int_t *map_extent)</a>
<a name="ln1146">{</a>
<a name="ln1147">  const cairo_rectangle_int_t roi_out_rect = { roi_out-&gt;x, roi_out-&gt;y, roi_out-&gt;width, roi_out-&gt;height };</a>
<a name="ln1148">  cairo_region_t *roi_out_region = cairo_region_create_rectangle (&amp;roi_out_rect);</a>
<a name="ln1149">  cairo_region_t *map_region = cairo_region_create ();</a>
<a name="ln1150"> </a>
<a name="ln1151">  for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln1152">  {</a>
<a name="ln1153">    const dt_liquify_warp_t *warp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln1154">    cairo_rectangle_int_t r;</a>
<a name="ln1155">    compute_round_stamp_extent (&amp;r, warp);</a>
<a name="ln1156">    // add extent if not entirely outside the roi</a>
<a name="ln1157">    if (cairo_region_contains_rectangle (roi_out_region, &amp;r) != CAIRO_REGION_OVERLAP_OUT)</a>
<a name="ln1158">    {</a>
<a name="ln1159">      cairo_region_union_rectangle (map_region, &amp;r);</a>
<a name="ln1160">    }</a>
<a name="ln1161">  }</a>
<a name="ln1162"> </a>
<a name="ln1163">  // return the paths and the extent of all paths</a>
<a name="ln1164">  cairo_region_get_extents (map_region, map_extent);</a>
<a name="ln1165">  cairo_region_destroy (map_region);</a>
<a name="ln1166">  cairo_region_destroy (roi_out_region);</a>
<a name="ln1167">}</a>
<a name="ln1168"> </a>
<a name="ln1169">static float complex *create_global_distortion_map (const cairo_rectangle_int_t *map_extent,</a>
<a name="ln1170">                                                    GList *interpolated,</a>
<a name="ln1171">                                                    gboolean inverted)</a>
<a name="ln1172">{</a>
<a name="ln1173">  // allocate distortion map big enough to contain all paths</a>
<a name="ln1174">  const int mapsize = map_extent-&gt;width * map_extent-&gt;height;</a>
<a name="ln1175">  float complex * map = dt_alloc_align(64, mapsize * sizeof (float complex));</a>
<a name="ln1176">  memset (map, 0, mapsize * sizeof (float complex));</a>
<a name="ln1177"> </a>
<a name="ln1178">  // build map</a>
<a name="ln1179">  for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln1180">  {</a>
<a name="ln1181">    const dt_liquify_warp_t *warp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln1182">    float complex *stamp = NULL;</a>
<a name="ln1183">    cairo_rectangle_int_t r;</a>
<a name="ln1184">    build_round_stamp (&amp;stamp, &amp;r, warp);</a>
<a name="ln1185">    add_to_global_distortion_map (map, map_extent, warp, stamp, &amp;r);</a>
<a name="ln1186">    free ((void *) stamp);</a>
<a name="ln1187">  }</a>
<a name="ln1188"> </a>
<a name="ln1189">  if (inverted)</a>
<a name="ln1190">  {</a>
<a name="ln1191">    float complex * const imap = dt_alloc_align (64, mapsize * sizeof (float complex));</a>
<a name="ln1192">    memset (imap, 0, mapsize * sizeof (float complex));</a>
<a name="ln1193"> </a>
<a name="ln1194">    // copy map into imap (inverted map).</a>
<a name="ln1195">    // imap [ n + dx(map[n]) , n + dy(map[n]) ] = -map[n]</a>
<a name="ln1196"> </a>
<a name="ln1197">    #ifdef _OPENMP</a>
<a name="ln1198">    #pragma omp parallel for schedule (static) default (shared)</a>
<a name="ln1199">    #endif</a>
<a name="ln1200"> </a>
<a name="ln1201">    for (int y = 0; y &lt;  map_extent-&gt;height; y++)</a>
<a name="ln1202">    {</a>
<a name="ln1203">      const float complex *row = map + y * map_extent-&gt;width;</a>
<a name="ln1204">      for (int x = 0; x &lt; map_extent-&gt;width; x++)</a>
<a name="ln1205">      {</a>
<a name="ln1206">        const float complex d = *(row + x);</a>
<a name="ln1207">        // compute new position (nx,ny) given the displacement d</a>
<a name="ln1208">        const int nx = x + (int)creal(d);</a>
<a name="ln1209">        const int ny = y + (int)cimag(d);</a>
<a name="ln1210"> </a>
<a name="ln1211">        // if the point falls into the extent, set it</a>
<a name="ln1212">        if (nx&gt;0 &amp;&amp; nx&lt;map_extent-&gt;width &amp;&amp; ny&gt;0 &amp;&amp; ny&lt;map_extent-&gt;height)</a>
<a name="ln1213">          imap[nx + ny * map_extent-&gt;width] = -d;</a>
<a name="ln1214">      }</a>
<a name="ln1215">    }</a>
<a name="ln1216"> </a>
<a name="ln1217">    dt_free_align ((void *) map);</a>
<a name="ln1218"> </a>
<a name="ln1219">    // now just do a pass to avoid gap with a displacement of zero, note that we do not need high</a>
<a name="ln1220">    // precision here as the inverted distortion mask is only used to compute a final displacement</a>
<a name="ln1221">    // of points.</a>
<a name="ln1222"> </a>
<a name="ln1223">    #ifdef _OPENMP</a>
<a name="ln1224">    #pragma omp parallel for schedule (dynamic) default (shared)</a>
<a name="ln1225">    #endif</a>
<a name="ln1226"> </a>
<a name="ln1227">    for (int y = 0; y &lt;  map_extent-&gt;height; y++)</a>
<a name="ln1228">    {</a>
<a name="ln1229">      float complex *row = imap + y * map_extent-&gt;width;</a>
<a name="ln1230">      float complex last[2] = { 0, 0 };</a>
<a name="ln1231">      for (int x = 0; x &lt; map_extent-&gt;width / 2 + 1; x++)</a>
<a name="ln1232">      {</a>
<a name="ln1233">        float complex *cl = row + x;</a>
<a name="ln1234">        float complex *cr = row + map_extent-&gt;width - x;</a>
<a name="ln1235">        if (x!=0)</a>
<a name="ln1236">        {</a>
<a name="ln1237">          if (*cl == 0) *cl = last[0];</a>
<a name="ln1238">          if (*cr == 0) *cr = last[1];</a>
<a name="ln1239">        }</a>
<a name="ln1240">        last[0] = *cl; last[1] = *cr;</a>
<a name="ln1241">      }</a>
<a name="ln1242">    }</a>
<a name="ln1243"> </a>
<a name="ln1244">    map = imap;</a>
<a name="ln1245">  }</a>
<a name="ln1246"> </a>
<a name="ln1247">  return map;</a>
<a name="ln1248">}</a>
<a name="ln1249"> </a>
<a name="ln1250">static float complex *build_global_distortion_map (struct dt_iop_module_t *module,</a>
<a name="ln1251">                                                   const dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1252">                                                   const dt_iop_roi_t *roi_in,</a>
<a name="ln1253">                                                   const dt_iop_roi_t *roi_out,</a>
<a name="ln1254">                                                   cairo_rectangle_int_t *map_extent)</a>
<a name="ln1255">{</a>
<a name="ln1256">  // copy params</a>
<a name="ln1257">  dt_iop_liquify_params_t copy_params;</a>
<a name="ln1258">  memcpy(&amp;copy_params, (dt_iop_liquify_params_t *)piece-&gt;data, sizeof(dt_iop_liquify_params_t));</a>
<a name="ln1259"> </a>
<a name="ln1260">  distort_paths_raw_to_piece (module, piece-&gt;pipe, roi_in-&gt;scale, &amp;copy_params, FALSE);</a>
<a name="ln1261"> </a>
<a name="ln1262">  GList *interpolated = interpolate_paths (&amp;copy_params);</a>
<a name="ln1263"> </a>
<a name="ln1264">  _get_map_extent (roi_out, interpolated, map_extent);</a>
<a name="ln1265"> </a>
<a name="ln1266">  float complex *map = create_global_distortion_map(map_extent, interpolated, FALSE);</a>
<a name="ln1267"> </a>
<a name="ln1268">  g_list_free_full (interpolated, free);</a>
<a name="ln1269">  return map;</a>
<a name="ln1270">}</a>
<a name="ln1271"> </a>
<a name="ln1272">// 1st pass: how large would the output be, given this input roi?</a>
<a name="ln1273">// this is always called with the full buffer before processing.</a>
<a name="ln1274">void modify_roi_out (struct dt_iop_module_t *module,</a>
<a name="ln1275">                     struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1276">                     dt_iop_roi_t *roi_out,</a>
<a name="ln1277">                     const dt_iop_roi_t *roi_in)</a>
<a name="ln1278">{</a>
<a name="ln1279">  // output is same size as input</a>
<a name="ln1280">  *roi_out = *roi_in;</a>
<a name="ln1281">}</a>
<a name="ln1282"> </a>
<a name="ln1283">// 2nd pass: which roi would this operation need as input to fill the given output region?</a>
<a name="ln1284">void modify_roi_in (struct dt_iop_module_t *module,</a>
<a name="ln1285">                    struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1286">                    const dt_iop_roi_t *roi_out,</a>
<a name="ln1287">                    dt_iop_roi_t *roi_in)</a>
<a name="ln1288">{</a>
<a name="ln1289">  // Because we move pixels, and we may have to sample a pixel from</a>
<a name="ln1290">  // outside roi_in, we need to expand roi_in to contain all our</a>
<a name="ln1291">  // paths.  But we may ignore paths completely outside of roi_out.</a>
<a name="ln1292"> </a>
<a name="ln1293">  *roi_in = *roi_out;</a>
<a name="ln1294"> </a>
<a name="ln1295">  // copy params</a>
<a name="ln1296">  dt_iop_liquify_params_t copy_params;</a>
<a name="ln1297">  memcpy(&amp;copy_params, (dt_iop_liquify_params_t*)piece-&gt;data, sizeof(dt_iop_liquify_params_t));</a>
<a name="ln1298"> </a>
<a name="ln1299">  distort_paths_raw_to_piece (module, piece-&gt;pipe, roi_in-&gt;scale, &amp;copy_params, FALSE);</a>
<a name="ln1300"> </a>
<a name="ln1301">  cairo_rectangle_int_t pipe_rect =</a>
<a name="ln1302">    {</a>
<a name="ln1303">      0,</a>
<a name="ln1304">      0,</a>
<a name="ln1305">      lroundf((double)piece-&gt;buf_in.width * roi_in-&gt;scale),</a>
<a name="ln1306">      lroundf((double)piece-&gt;buf_in.height * roi_in-&gt;scale)</a>
<a name="ln1307">    };</a>
<a name="ln1308"> </a>
<a name="ln1309">  cairo_rectangle_int_t roi_in_rect =</a>
<a name="ln1310">    {</a>
<a name="ln1311">      roi_in-&gt;x,</a>
<a name="ln1312">      roi_in-&gt;y,</a>
<a name="ln1313">      roi_in-&gt;width,</a>
<a name="ln1314">      roi_in-&gt;height</a>
<a name="ln1315">    };</a>
<a name="ln1316">  cairo_region_t *roi_in_region = cairo_region_create_rectangle (&amp;roi_in_rect);</a>
<a name="ln1317"> </a>
<a name="ln1318">  // get extent of all paths</a>
<a name="ln1319">  GList *interpolated = interpolate_paths (&amp;copy_params);</a>
<a name="ln1320">  cairo_rectangle_int_t extent;</a>
<a name="ln1321">  _get_map_extent (roi_out, interpolated, &amp;extent);</a>
<a name="ln1322"> </a>
<a name="ln1323">  // (eventually) extend roi_in</a>
<a name="ln1324">  cairo_region_union_rectangle (roi_in_region, &amp;extent);</a>
<a name="ln1325">  // and clamp to pipe extent</a>
<a name="ln1326">  cairo_region_intersect_rectangle (roi_in_region, &amp;pipe_rect);</a>
<a name="ln1327"> </a>
<a name="ln1328">  // write new extent to roi_in</a>
<a name="ln1329">  cairo_region_get_extents (roi_in_region, &amp;roi_in_rect);</a>
<a name="ln1330">  roi_in-&gt;x = roi_in_rect.x;</a>
<a name="ln1331">  roi_in-&gt;y = roi_in_rect.y;</a>
<a name="ln1332">  roi_in-&gt;width  = roi_in_rect.width;</a>
<a name="ln1333">  roi_in-&gt;height = roi_in_rect.height;</a>
<a name="ln1334"> </a>
<a name="ln1335">  // cleanup</a>
<a name="ln1336">  cairo_region_destroy (roi_in_region);</a>
<a name="ln1337">  g_list_free_full (interpolated, free);</a>
<a name="ln1338">}</a>
<a name="ln1339"> </a>
<a name="ln1340">static int _distort_xtransform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points, size_t points_count, gboolean inverted)</a>
<a name="ln1341">{</a>
<a name="ln1342">  const float scale = piece-&gt;iscale;</a>
<a name="ln1343"> </a>
<a name="ln1344">  // compute the extent of all points (all computations are done in RAW coordinate)</a>
<a name="ln1345">  float xmin=FLT_MAX, xmax=FLT_MIN, ymin=FLT_MAX, ymax=FLT_MIN;</a>
<a name="ln1346"> </a>
<a name="ln1347">  for(size_t i = 0; i &lt; points_count * 2; i += 2)</a>
<a name="ln1348">  {</a>
<a name="ln1349">    const float x = points[i] * scale;</a>
<a name="ln1350">    const float y = points[i + 1] * scale;</a>
<a name="ln1351">    xmin = fmin (xmin, x);</a>
<a name="ln1352">    xmax = fmax (xmax, x);</a>
<a name="ln1353">    ymin = fmin (ymin, y);</a>
<a name="ln1354">    ymax = fmax (ymax, y);</a>
<a name="ln1355">  }</a>
<a name="ln1356"> </a>
<a name="ln1357">  cairo_rectangle_int_t extent = { .x = (int)(xmin - .5), .y = (int)(ymin - .5),</a>
<a name="ln1358">                                   .width = (int)(xmax - xmin + 2.5), .height = (int)(ymax - ymin + 2.5) };</a>
<a name="ln1359"> </a>
<a name="ln1360">  if (extent.width != 0 &amp;&amp; extent.height != 0)</a>
<a name="ln1361">  {</a>
<a name="ln1362">    // copy params</a>
<a name="ln1363">    dt_iop_liquify_params_t copy_params;</a>
<a name="ln1364">    memcpy(&amp;copy_params, (dt_iop_liquify_params_t *)piece-&gt;data, sizeof(dt_iop_liquify_params_t));</a>
<a name="ln1365"> </a>
<a name="ln1366">    distort_paths_raw_to_piece (self, piece-&gt;pipe, scale, &amp;copy_params, TRUE);</a>
<a name="ln1367"> </a>
<a name="ln1368">    // create the distortion map for this extent</a>
<a name="ln1369"> </a>
<a name="ln1370">    GList *interpolated = interpolate_paths (&amp;copy_params);</a>
<a name="ln1371"> </a>
<a name="ln1372">    // we need to adjust the extent to be the union enclosing all the points (currently in extent) and</a>
<a name="ln1373">    // the warps that are in (possibly partly) in this same region.</a>
<a name="ln1374"> </a>
<a name="ln1375">    dt_iop_roi_t roi_in = { .x = extent.x, .y = extent.y, .width = extent.width, .height = extent.height };</a>
<a name="ln1376">    _get_map_extent (&amp;roi_in, interpolated, &amp;extent);</a>
<a name="ln1377"> </a>
<a name="ln1378">    float complex *map = create_global_distortion_map (&amp;extent, interpolated, inverted);</a>
<a name="ln1379">    g_list_free_full (interpolated, free);</a>
<a name="ln1380"> </a>
<a name="ln1381">    if (map == NULL) return 0;</a>
<a name="ln1382"> </a>
<a name="ln1383">    const int map_size =  extent.width * extent.height;</a>
<a name="ln1384">    const int x_last = extent.x + extent.width;</a>
<a name="ln1385">    const int y_last = extent.y + extent.height;</a>
<a name="ln1386"> </a>
<a name="ln1387">    // apply distortion to all points (this is a simple displacement given by a vector at this same point in the map)</a>
<a name="ln1388">    for(size_t i = 0; i &lt; points_count; i++)</a>
<a name="ln1389">    {</a>
<a name="ln1390">      float *px = &amp;points[i*2];</a>
<a name="ln1391">      float *py = &amp;points[i*2+1];</a>
<a name="ln1392">      const float x = *px * scale;</a>
<a name="ln1393">      const float y = *py * scale;</a>
<a name="ln1394">      const int map_offset = ((int)(x - 0.5) - extent.x) + ((int)(y - 0.5) - extent.y) * extent.width;</a>
<a name="ln1395"> </a>
<a name="ln1396">      if (x &gt;= extent.x &amp;&amp; x &lt; x_last &amp;&amp; y &gt;= extent.y &amp;&amp; y &lt; y_last &amp;&amp; map_offset &gt;= 0 &amp;&amp; map_offset &lt; map_size)</a>
<a name="ln1397">      {</a>
<a name="ln1398">        const float complex dist = map[map_offset] / scale;</a>
<a name="ln1399">        *px += creal(dist);</a>
<a name="ln1400">        *py += cimag(dist);</a>
<a name="ln1401">      }</a>
<a name="ln1402">    }</a>
<a name="ln1403"> </a>
<a name="ln1404">    dt_free_align ((void *) map);</a>
<a name="ln1405">  }</a>
<a name="ln1406"> </a>
<a name="ln1407">  return 1;</a>
<a name="ln1408">}</a>
<a name="ln1409"> </a>
<a name="ln1410">int distort_transform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points, size_t points_count)</a>
<a name="ln1411">{</a>
<a name="ln1412">  return _distort_xtransform(self, piece, points, points_count, TRUE);</a>
<a name="ln1413">}</a>
<a name="ln1414"> </a>
<a name="ln1415">int distort_backtransform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points, size_t points_count)</a>
<a name="ln1416">{</a>
<a name="ln1417">  return _distort_xtransform(self, piece, points, points_count, FALSE);</a>
<a name="ln1418">}</a>
<a name="ln1419"> </a>
<a name="ln1420">void distort_mask(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln1421">                  float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln1422">{</a>
<a name="ln1423">  // 1. copy the whole image (we'll change only a small part of it)</a>
<a name="ln1424"> </a>
<a name="ln1425">#ifdef _OPENMP</a>
<a name="ln1426">#pragma omp parallel for default(none) \</a>
<a name="ln1427">  dt_omp_firstprivate(in, out, roi_in, roi_out) \</a>
<a name="ln1428">  schedule(static)</a>
<a name="ln1429">#endif</a>
<a name="ln1430">  for (int i = 0; i &lt; roi_out-&gt;height; i++)</a>
<a name="ln1431">  {</a>
<a name="ln1432">    float *destrow = out + (size_t) i * roi_out-&gt;width;</a>
<a name="ln1433">    const float *srcrow = in + (size_t) (roi_in-&gt;width * (i + roi_out-&gt;y - roi_in-&gt;y) + roi_out-&gt;x - roi_in-&gt;x);</a>
<a name="ln1434"> </a>
<a name="ln1435">    memcpy (destrow, srcrow, sizeof (float) * roi_out-&gt;width);</a>
<a name="ln1436">  }</a>
<a name="ln1437"> </a>
<a name="ln1438">  // 2. build the distortion map</a>
<a name="ln1439"> </a>
<a name="ln1440">  cairo_rectangle_int_t map_extent;</a>
<a name="ln1441">  float complex *map = build_global_distortion_map (self, piece, roi_in, roi_out, &amp;map_extent);</a>
<a name="ln1442">  if (map == NULL)</a>
<a name="ln1443">    return;</a>
<a name="ln1444"> </a>
<a name="ln1445">  // 3. apply the map</a>
<a name="ln1446"> </a>
<a name="ln1447">  if (map_extent.width != 0 &amp;&amp; map_extent.height != 0)</a>
<a name="ln1448">  {</a>
<a name="ln1449">    int ch = piece-&gt;colors;</a>
<a name="ln1450">    piece-&gt;colors = 1;</a>
<a name="ln1451">    apply_global_distortion_map (self, piece, in, out, roi_in, roi_out, map, &amp;map_extent);</a>
<a name="ln1452">    piece-&gt;colors = ch;</a>
<a name="ln1453">  }</a>
<a name="ln1454"> </a>
<a name="ln1455">  dt_free_align ((void *) map);</a>
<a name="ln1456"> </a>
<a name="ln1457">}</a>
<a name="ln1458"> </a>
<a name="ln1459">void process(struct dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, const void *const in,</a>
<a name="ln1460">             void *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln1461">{</a>
<a name="ln1462">  // 1. copy the whole image (we'll change only a small part of it)</a>
<a name="ln1463"> </a>
<a name="ln1464">  const int ch = piece-&gt;colors;</a>
<a name="ln1465">  assert (ch == 4);</a>
<a name="ln1466"> </a>
<a name="ln1467">  const int height = MIN(roi_in-&gt;height, roi_out-&gt;height);</a>
<a name="ln1468">  const int width = MIN(roi_in-&gt;width, roi_out-&gt;width);</a>
<a name="ln1469">  </a>
<a name="ln1470">#ifdef _OPENMP</a>
<a name="ln1471">#pragma omp parallel for default(none) \</a>
<a name="ln1472">  dt_omp_firstprivate(ch, height, in, out, roi_in, roi_out, width) \</a>
<a name="ln1473">  schedule(static)</a>
<a name="ln1474">#endif</a>
<a name="ln1475">  for (int i = 0; i &lt; height; i++)</a>
<a name="ln1476">  {</a>
<a name="ln1477">    float *destrow = (float *)out + (size_t) ch * i * roi_out-&gt;width;</a>
<a name="ln1478">    const float *srcrow = (float *)in + (size_t) ch * (roi_in-&gt;width * (i + roi_out-&gt;y - roi_in-&gt;y) +</a>
<a name="ln1479">                                                       roi_out-&gt;x - roi_in-&gt;x);</a>
<a name="ln1480"> </a>
<a name="ln1481">    memcpy (destrow, srcrow, sizeof (float) * ch * width);</a>
<a name="ln1482">  }</a>
<a name="ln1483"> </a>
<a name="ln1484">  // 2. build the distortion map</a>
<a name="ln1485"> </a>
<a name="ln1486">  cairo_rectangle_int_t map_extent;</a>
<a name="ln1487">  float complex *map = build_global_distortion_map (module, piece, roi_in, roi_out, &amp;map_extent);</a>
<a name="ln1488">  if (map == NULL)</a>
<a name="ln1489">    return;</a>
<a name="ln1490"> </a>
<a name="ln1491">  // 3. apply the map</a>
<a name="ln1492"> </a>
<a name="ln1493">  if (map_extent.width != 0 &amp;&amp; map_extent.height != 0)</a>
<a name="ln1494">    apply_global_distortion_map (module, piece, in, out, roi_in, roi_out, map, &amp;map_extent);</a>
<a name="ln1495"> </a>
<a name="ln1496">  dt_free_align ((void *) map);</a>
<a name="ln1497">}</a>
<a name="ln1498"> </a>
<a name="ln1499">#ifdef HAVE_OPENCL</a>
<a name="ln1500"> </a>
<a name="ln1501">// compute lanczos kernel. See: https://en.wikipedia.org/wiki/Lanczos_resampling#Lanczos_kernel</a>
<a name="ln1502"> </a>
<a name="ln1503">static float lanczos(const float a, const float x)</a>
<a name="ln1504">{</a>
<a name="ln1505">  if (fabs (x) &gt;= a) return 0.0f;</a>
<a name="ln1506">  if (fabs (x) &lt; CL_FLT_EPSILON) return 1.0f;</a>
<a name="ln1507"> </a>
<a name="ln1508">  return</a>
<a name="ln1509">    (a * sinf (M_PI * x) * sinf (M_PI * x / a))</a>
<a name="ln1510">    /</a>
<a name="ln1511">    (M_PI * M_PI * x * x);</a>
<a name="ln1512">}</a>
<a name="ln1513"> </a>
<a name="ln1514">// compute bicubic kernel. See: https://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm</a>
<a name="ln1515"> </a>
<a name="ln1516">static float bicubic(const float a, const float x)</a>
<a name="ln1517">{</a>
<a name="ln1518">  const float absx = fabs (x);</a>
<a name="ln1519"> </a>
<a name="ln1520">  if (absx &lt;= 1)</a>
<a name="ln1521">    return ((a + 2) * absx - (a + 3)) * absx * absx + 1;</a>
<a name="ln1522"> </a>
<a name="ln1523">  if (absx &lt; 2)</a>
<a name="ln1524">    return ((a * absx - 5 * a) * absx + 8 * a) * absx - 4 * a;</a>
<a name="ln1525"> </a>
<a name="ln1526">  return 0.0f;</a>
<a name="ln1527">}</a>
<a name="ln1528"> </a>
<a name="ln1529">typedef struct</a>
<a name="ln1530">{</a>
<a name="ln1531">  int size;</a>
<a name="ln1532">  int resolution;</a>
<a name="ln1533">} dt_liquify_kernel_descriptor_t;</a>
<a name="ln1534"> </a>
<a name="ln1535">typedef cl_mem cl_mem_t;</a>
<a name="ln1536">typedef cl_int cl_int_t;</a>
<a name="ln1537"> </a>
<a name="ln1538">static cl_int_t apply_global_distortion_map_cl (struct dt_iop_module_t *module,</a>
<a name="ln1539">                                                dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1540">                                                const cl_mem_t dev_in,</a>
<a name="ln1541">                                                const cl_mem_t dev_out,</a>
<a name="ln1542">                                                const dt_iop_roi_t *roi_in,</a>
<a name="ln1543">                                                const dt_iop_roi_t *roi_out,</a>
<a name="ln1544">                                                const float complex *map,</a>
<a name="ln1545">                                                const cairo_rectangle_int_t *map_extent)</a>
<a name="ln1546">{</a>
<a name="ln1547">  cl_int_t err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln1548"> </a>
<a name="ln1549">  dt_iop_liquify_global_data_t *gd = (dt_iop_liquify_global_data_t *) module-&gt;global_data;</a>
<a name="ln1550">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln1551"> </a>
<a name="ln1552">  const struct dt_interpolation* interpolation = dt_interpolation_new (DT_INTERPOLATION_USERPREF);</a>
<a name="ln1553">  dt_liquify_kernel_descriptor_t kdesc = { .size = 0, .resolution = 100 };</a>
<a name="ln1554">  float *k = NULL;</a>
<a name="ln1555"> </a>
<a name="ln1556">  switch (interpolation-&gt;id)</a>
<a name="ln1557">  {</a>
<a name="ln1558">     case DT_INTERPOLATION_BILINEAR:</a>
<a name="ln1559">       kdesc.size = 1;</a>
<a name="ln1560">       kdesc.resolution = 1;</a>
<a name="ln1561">       k = malloc (2 * sizeof (float));</a>
<a name="ln1562">       k[0] = 1.0f;</a>
<a name="ln1563">       k[1] = 0.0f;</a>
<a name="ln1564">       break;</a>
<a name="ln1565">     case DT_INTERPOLATION_BICUBIC:</a>
<a name="ln1566">       kdesc.size = 2;</a>
<a name="ln1567">       k = malloc ((kdesc.size * kdesc.resolution + 1) * sizeof (float));</a>
<a name="ln1568">       for (int i = 0; i &lt;= kdesc.size * kdesc.resolution; ++i)</a>
<a name="ln1569">         k[i] = bicubic (0.5f, (float) i / kdesc.resolution);</a>
<a name="ln1570">       break;</a>
<a name="ln1571">     case DT_INTERPOLATION_LANCZOS2:</a>
<a name="ln1572">       kdesc.size = 2;</a>
<a name="ln1573">       k = malloc ((kdesc.size * kdesc.resolution + 1) * sizeof (float));</a>
<a name="ln1574">       for (int i = 0; i &lt;= kdesc.size * kdesc.resolution; ++i)</a>
<a name="ln1575">         k[i] = lanczos (2, (float) i / kdesc.resolution);</a>
<a name="ln1576">       break;</a>
<a name="ln1577">     case DT_INTERPOLATION_LANCZOS3:</a>
<a name="ln1578">       kdesc.size = 3;</a>
<a name="ln1579">       k = malloc ((kdesc.size * kdesc.resolution + 1) * sizeof (float));</a>
<a name="ln1580">       for (int i = 0; i &lt;= kdesc.size * kdesc.resolution; ++i)</a>
<a name="ln1581">         k[i] = lanczos (3, (float) i / kdesc.resolution);</a>
<a name="ln1582">       break;</a>
<a name="ln1583">     default:</a>
<a name="ln1584">       return FALSE;</a>
<a name="ln1585">  }</a>
<a name="ln1586"> </a>
<a name="ln1587">  cl_mem_t dev_roi_in = dt_opencl_copy_host_to_device_constant</a>
<a name="ln1588">    (devid, sizeof (dt_iop_roi_t), (void *) roi_in);</a>
<a name="ln1589"> </a>
<a name="ln1590">  cl_mem_t dev_roi_out = dt_opencl_copy_host_to_device_constant</a>
<a name="ln1591">    (devid, sizeof (dt_iop_roi_t), (void *) roi_out);</a>
<a name="ln1592"> </a>
<a name="ln1593">  cl_mem_t dev_map = dt_opencl_copy_host_to_device_constant</a>
<a name="ln1594">    (devid, map_extent-&gt;width * map_extent-&gt;height * sizeof (float complex), (void *) map);</a>
<a name="ln1595"> </a>
<a name="ln1596">  cl_mem_t dev_map_extent = dt_opencl_copy_host_to_device_constant</a>
<a name="ln1597">    (devid, sizeof (cairo_rectangle_int_t), (void *) map_extent);</a>
<a name="ln1598"> </a>
<a name="ln1599">  cl_mem_t dev_kdesc = dt_opencl_copy_host_to_device_constant</a>
<a name="ln1600">    (devid, sizeof (dt_liquify_kernel_descriptor_t), (void *) &amp;kdesc);</a>
<a name="ln1601"> </a>
<a name="ln1602">  cl_mem_t dev_kernel = dt_opencl_copy_host_to_device_constant</a>
<a name="ln1603">    (devid, (kdesc.size * kdesc.resolution  + 1) * sizeof (float), (void *) k);</a>
<a name="ln1604"> </a>
<a name="ln1605">  if (dev_roi_in == NULL || dev_roi_out == NULL || dev_map == NULL || dev_map_extent == NULL</a>
<a name="ln1606">      || dev_kdesc == NULL || dev_kernel == NULL)</a>
<a name="ln1607">    goto error;</a>
<a name="ln1608"> </a>
<a name="ln1609">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 0, sizeof (cl_mem), &amp;dev_in);</a>
<a name="ln1610">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 1, sizeof (cl_mem), &amp;dev_out);</a>
<a name="ln1611">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 2, sizeof (cl_mem), &amp;dev_roi_in);</a>
<a name="ln1612">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 3, sizeof (cl_mem), &amp;dev_roi_out);</a>
<a name="ln1613">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 4, sizeof (cl_mem), &amp;dev_map);</a>
<a name="ln1614">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 5, sizeof (cl_mem), &amp;dev_map_extent);</a>
<a name="ln1615"> </a>
<a name="ln1616">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 6, sizeof (cl_mem), &amp;dev_kdesc);</a>
<a name="ln1617">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 7, sizeof (cl_mem), &amp;dev_kernel);</a>
<a name="ln1618"> </a>
<a name="ln1619">  const size_t sizes[] = { ROUNDUPWD (map_extent-&gt;width), ROUNDUPHT (map_extent-&gt;height) };</a>
<a name="ln1620">  err = dt_opencl_enqueue_kernel_2d (devid, gd-&gt;warp_kernel, sizes);</a>
<a name="ln1621"> </a>
<a name="ln1622">error:</a>
<a name="ln1623"> </a>
<a name="ln1624">  dt_opencl_release_mem_object (dev_kernel);</a>
<a name="ln1625">  dt_opencl_release_mem_object (dev_kdesc);</a>
<a name="ln1626">  dt_opencl_release_mem_object (dev_map_extent);</a>
<a name="ln1627">  dt_opencl_release_mem_object (dev_map);</a>
<a name="ln1628">  dt_opencl_release_mem_object (dev_roi_out);</a>
<a name="ln1629">  dt_opencl_release_mem_object (dev_roi_in);</a>
<a name="ln1630">  if (k) free (k);</a>
<a name="ln1631"> </a>
<a name="ln1632">  return err;</a>
<a name="ln1633">}</a>
<a name="ln1634"> </a>
<a name="ln1635">int process_cl (struct dt_iop_module_t *module,</a>
<a name="ln1636">                dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1637">                const cl_mem_t dev_in,</a>
<a name="ln1638">                const cl_mem_t dev_out,</a>
<a name="ln1639">                const dt_iop_roi_t *roi_in,</a>
<a name="ln1640">                const dt_iop_roi_t *roi_out)</a>
<a name="ln1641">{</a>
<a name="ln1642">  cl_int_t err = -999;</a>
<a name="ln1643">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln1644"> </a>
<a name="ln1645">  const int height = MIN(roi_in-&gt;height, roi_out-&gt;height);</a>
<a name="ln1646">  const int width = MIN(roi_in-&gt;width, roi_out-&gt;width);</a>
<a name="ln1647">  </a>
<a name="ln1648">  // 1. copy the whole image (we'll change only a small part of it)</a>
<a name="ln1649"> </a>
<a name="ln1650">  {</a>
<a name="ln1651">    size_t src[]    = { roi_out-&gt;x - roi_in-&gt;x, roi_out-&gt;y - roi_in-&gt;y, 0 };</a>
<a name="ln1652">    size_t dest[]   = { 0, 0, 0 };</a>
<a name="ln1653">    size_t extent[] = { width, height, 1 };</a>
<a name="ln1654">    err = dt_opencl_enqueue_copy_image (devid, dev_in, dev_out, src, dest, extent);</a>
<a name="ln1655">    if (err != CL_SUCCESS) goto error;</a>
<a name="ln1656">  }</a>
<a name="ln1657"> </a>
<a name="ln1658">  // 2. build the distortion map</a>
<a name="ln1659"> </a>
<a name="ln1660">  cairo_rectangle_int_t map_extent;</a>
<a name="ln1661">  const float complex *map = build_global_distortion_map (module, piece, roi_in, roi_out, &amp;map_extent);</a>
<a name="ln1662">  if (map == NULL)</a>
<a name="ln1663">    return TRUE;</a>
<a name="ln1664"> </a>
<a name="ln1665">  // 3. apply the map</a>
<a name="ln1666"> </a>
<a name="ln1667">  if (map_extent.width != 0 &amp;&amp; map_extent.height != 0)</a>
<a name="ln1668">    err = apply_global_distortion_map_cl (module, piece, dev_in, dev_out, roi_in, roi_out, map, &amp;map_extent);</a>
<a name="ln1669"> </a>
<a name="ln1670">  dt_free_align ((void *) map);</a>
<a name="ln1671">  if (err != CL_SUCCESS) goto error;</a>
<a name="ln1672"> </a>
<a name="ln1673">  return TRUE;</a>
<a name="ln1674"> </a>
<a name="ln1675">error:</a>
<a name="ln1676">  dt_print (DT_DEBUG_OPENCL, &quot;[opencl_liquify] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln1677">  return FALSE;</a>
<a name="ln1678">}</a>
<a name="ln1679"> </a>
<a name="ln1680">#endif</a>
<a name="ln1681"> </a>
<a name="ln1682">void init_global (dt_iop_module_so_t *module)</a>
<a name="ln1683">{</a>
<a name="ln1684">  // called once at startup</a>
<a name="ln1685">  const int program = 17; // from programs.conf</a>
<a name="ln1686">  dt_iop_liquify_global_data_t *gd = (dt_iop_liquify_global_data_t *) malloc (sizeof (dt_iop_liquify_global_data_t));</a>
<a name="ln1687">  module-&gt;data = gd;</a>
<a name="ln1688">  gd-&gt;warp_kernel = dt_opencl_create_kernel (program, &quot;warp_kernel&quot;);</a>
<a name="ln1689">}</a>
<a name="ln1690"> </a>
<a name="ln1691">void cleanup_global (dt_iop_module_so_t *module)</a>
<a name="ln1692">{</a>
<a name="ln1693">  // called once at shutdown</a>
<a name="ln1694">  dt_iop_liquify_global_data_t *gd = (dt_iop_liquify_global_data_t *) module-&gt;data;</a>
<a name="ln1695">  dt_opencl_free_kernel (gd-&gt;warp_kernel);</a>
<a name="ln1696">  free (module-&gt;data);</a>
<a name="ln1697">  module-&gt;data = NULL;</a>
<a name="ln1698">}</a>
<a name="ln1699"> </a>
<a name="ln1700">void init (dt_iop_module_t *module)</a>
<a name="ln1701">{</a>
<a name="ln1702">  // module is disabled by default</a>
<a name="ln1703">  module-&gt;default_enabled = 0;</a>
<a name="ln1704">  module-&gt;params_size = sizeof(dt_iop_liquify_params_t);</a>
<a name="ln1705">  module-&gt;gui_data = NULL;</a>
<a name="ln1706"> </a>
<a name="ln1707">  // all allocated to 0, which is the default</a>
<a name="ln1708">  module-&gt;params = calloc (1, module-&gt;params_size);</a>
<a name="ln1709">  module-&gt;default_params = calloc (1, module-&gt;params_size);</a>
<a name="ln1710">}</a>
<a name="ln1711"> </a>
<a name="ln1712">void cleanup (dt_iop_module_t *module)</a>
<a name="ln1713">{</a>
<a name="ln1714">  free (module-&gt;params);</a>
<a name="ln1715">  module-&gt;params = NULL;</a>
<a name="ln1716">}</a>
<a name="ln1717"> </a>
<a name="ln1718">void init_pipe (struct dt_iop_module_t *module, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1719">{</a>
<a name="ln1720">  piece-&gt;data = malloc (module-&gt;params_size);</a>
<a name="ln1721">  module-&gt;commit_params (module, module-&gt;default_params, pipe, piece);</a>
<a name="ln1722">}</a>
<a name="ln1723"> </a>
<a name="ln1724">void cleanup_pipe (struct dt_iop_module_t *module, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1725">{</a>
<a name="ln1726">  free (piece-&gt;data);</a>
<a name="ln1727">  piece-&gt;data = NULL;</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730">/* commit is the synch point between core and gui, so it copies params to pipe data. */</a>
<a name="ln1731"> </a>
<a name="ln1732">void commit_params (struct dt_iop_module_t *module,</a>
<a name="ln1733">                    dt_iop_params_t *params,</a>
<a name="ln1734">                    dt_dev_pixelpipe_t *pipe,</a>
<a name="ln1735">                    dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1736">{</a>
<a name="ln1737">  memcpy (piece-&gt;data, params, module-&gt;params_size);</a>
<a name="ln1738">}</a>
<a name="ln1739"> </a>
<a name="ln1740">// calculate the dot product of 2 vectors.</a>
<a name="ln1741"> </a>
<a name="ln1742">static float cdot (const float complex p0, const float complex p1)</a>
<a name="ln1743">{</a>
<a name="ln1744">#ifdef FP_FAST_FMA</a>
<a name="ln1745">  return fma (creal (p0), creal (p1), cimag (p0) * cimag (p1));</a>
<a name="ln1746">#else</a>
<a name="ln1747">  return creal (p0) * creal (p1) + cimag (p0) * cimag (p1);</a>
<a name="ln1748">#endif</a>
<a name="ln1749">}</a>
<a name="ln1750"> </a>
<a name="ln1751">static void draw_rectangle (cairo_t *cr, const float complex pt, const double theta, const double size)</a>
<a name="ln1752">{</a>
<a name="ln1753">  const double x = creal (pt), y = cimag (pt);</a>
<a name="ln1754">  cairo_save (cr);</a>
<a name="ln1755">  cairo_translate (cr, x, y);</a>
<a name="ln1756">  cairo_rotate (cr, theta);</a>
<a name="ln1757">  cairo_rectangle (cr, -size / 2.0, -size / 2.0, size, size);</a>
<a name="ln1758">  cairo_restore (cr);</a>
<a name="ln1759">}</a>
<a name="ln1760"> </a>
<a name="ln1761">static void draw_triangle (cairo_t *cr, const float complex pt, const double theta, const double size)</a>
<a name="ln1762">{</a>
<a name="ln1763">  const double x = creal (pt), y = cimag (pt);</a>
<a name="ln1764">  cairo_save (cr);</a>
<a name="ln1765">  cairo_translate (cr, x, y);</a>
<a name="ln1766">  cairo_rotate (cr, theta);</a>
<a name="ln1767">  cairo_move_to (cr, -size, -size / 2.0);</a>
<a name="ln1768">  cairo_line_to (cr, 0,     0          );</a>
<a name="ln1769">  cairo_line_to (cr, -size, +size / 2.0);</a>
<a name="ln1770">  cairo_close_path (cr);</a>
<a name="ln1771">  cairo_restore (cr);</a>
<a name="ln1772">}</a>
<a name="ln1773"> </a>
<a name="ln1774">static void draw_circle (cairo_t *cr, const float complex pt, const double diameter)</a>
<a name="ln1775">{</a>
<a name="ln1776">  const double x = creal (pt), y = cimag (pt);</a>
<a name="ln1777">  cairo_save (cr);</a>
<a name="ln1778">  cairo_new_sub_path (cr);</a>
<a name="ln1779">  cairo_arc (cr, x, y, diameter / 2.0, 0, 2 * M_PI);</a>
<a name="ln1780">  cairo_restore (cr);</a>
<a name="ln1781">}</a>
<a name="ln1782"> </a>
<a name="ln1783">static void set_source_rgba (cairo_t *cr, dt_liquify_rgba_t rgba)</a>
<a name="ln1784">{</a>
<a name="ln1785">  cairo_set_source_rgba (cr, rgba.red, rgba.green, rgba.blue, rgba.alpha);</a>
<a name="ln1786">}</a>
<a name="ln1787"> </a>
<a name="ln1788">static float get_ui_width (const float scale, const dt_liquify_ui_width_enum_t w)</a>
<a name="ln1789">{</a>
<a name="ln1790">  assert (w &gt;= 0 &amp;&amp; w &lt; DT_LIQUIFY_UI_WIDTH_LAST);</a>
<a name="ln1791">  return scale * DT_PIXEL_APPLY_DPI (dt_liquify_ui_widths[w]);</a>
<a name="ln1792">}</a>
<a name="ln1793"> </a>
<a name="ln1794">#define GET_UI_WIDTH(a) (get_ui_width (scale, DT_LIQUIFY_UI_WIDTH_##a))</a>
<a name="ln1795"> </a>
<a name="ln1796">static void set_line_width (cairo_t *cr, double scale, dt_liquify_ui_width_enum_t w)</a>
<a name="ln1797">{</a>
<a name="ln1798">  const double width = get_ui_width (scale, w);</a>
<a name="ln1799">  cairo_set_line_width (cr, width);</a>
<a name="ln1800">}</a>
<a name="ln1801"> </a>
<a name="ln1802">static gboolean detect_drag (const dt_iop_liquify_gui_data_t *g, const double scale, const float complex pt)</a>
<a name="ln1803">{</a>
<a name="ln1804">  // g-&gt;last_button1_pressed_pos is valid only while BUTTON1 is down</a>
<a name="ln1805">  return g-&gt;last_button1_pressed_pos != -1.0 &amp;&amp;</a>
<a name="ln1806">    cabs (pt - g-&gt;last_button1_pressed_pos) &gt;= GET_UI_WIDTH (MIN_DRAG);</a>
<a name="ln1807">}</a>
<a name="ln1808"> </a>
<a name="ln1809">static void update_warp_count (const dt_iop_liquify_gui_data_t *g)</a>
<a name="ln1810">{</a>
<a name="ln1811">  guint warp = 0, node = 0;</a>
<a name="ln1812">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln1813">    if (g-&gt;params.nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln1814">      break;</a>
<a name="ln1815">    else</a>
<a name="ln1816">    {</a>
<a name="ln1817">      node++;</a>
<a name="ln1818">      if (g-&gt;params.nodes[k].header.type == DT_LIQUIFY_PATH_MOVE_TO_V1)</a>
<a name="ln1819">        warp++;</a>
<a name="ln1820">    }</a>
<a name="ln1821">  char str[10];</a>
<a name="ln1822">  snprintf (str, sizeof (str), &quot;%d|%d&quot;, warp, node);</a>
<a name="ln1823">  gtk_label_set_text (g-&gt;label, str);</a>
<a name="ln1824">}</a>
<a name="ln1825"> </a>
<a name="ln1826">static GList *interpolate_paths (dt_iop_liquify_params_t *p)</a>
<a name="ln1827">{</a>
<a name="ln1828">  GList *l = NULL;</a>
<a name="ln1829"> </a>
<a name="ln1830">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln1831">  {</a>
<a name="ln1832">    const dt_liquify_path_data_t *data = &amp;p-&gt;nodes[k];</a>
<a name="ln1833"> </a>
<a name="ln1834">    if (data-&gt;header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln1835">      break;</a>
<a name="ln1836"> </a>
<a name="ln1837">    const float complex *p2 = &amp;data-&gt;warp.point;</a>
<a name="ln1838">    const dt_liquify_warp_t *warp2 = &amp;data-&gt;warp;</a>
<a name="ln1839"> </a>
<a name="ln1840">    if (data-&gt;header.type == DT_LIQUIFY_PATH_MOVE_TO_V1)</a>
<a name="ln1841">    {</a>
<a name="ln1842">      if (data-&gt;header.next == -1)</a>
<a name="ln1843">      {</a>
<a name="ln1844">        dt_liquify_warp_t *w = malloc (sizeof (dt_liquify_warp_t));</a>
<a name="ln1845">        *w = *warp2;</a>
<a name="ln1846">        l = g_list_append (l, w);</a>
<a name="ln1847">      }</a>
<a name="ln1848">      continue;</a>
<a name="ln1849">    }</a>
<a name="ln1850"> </a>
<a name="ln1851">    const dt_liquify_path_data_t *prev = node_prev (p, data);</a>
<a name="ln1852">    const dt_liquify_warp_t *warp1 = &amp;prev-&gt;warp;</a>
<a name="ln1853">    const float complex *p1 = &amp;prev-&gt;warp.point;</a>
<a name="ln1854"> </a>
<a name="ln1855">    if (data-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1)</a>
<a name="ln1856">    {</a>
<a name="ln1857">      const float total_length = cabs (*p1 - *p2);</a>
<a name="ln1858">      float arc_length = 0.0;</a>
<a name="ln1859">      while (arc_length &lt; total_length)</a>
<a name="ln1860">      {</a>
<a name="ln1861">        dt_liquify_warp_t *w = malloc (sizeof (dt_liquify_warp_t));</a>
<a name="ln1862">        const float t = arc_length / total_length;</a>
<a name="ln1863">        const float complex pt = cmix (*p1, *p2, t);</a>
<a name="ln1864">        mix_warps (w, warp1, warp2, pt, t);</a>
<a name="ln1865">        w-&gt;status = DT_LIQUIFY_STATUS_INTERPOLATED;</a>
<a name="ln1866">        arc_length += cabs (w-&gt;radius - w-&gt;point) * STAMP_RELOCATION;</a>
<a name="ln1867">        l = g_list_append (l, w);</a>
<a name="ln1868">      }</a>
<a name="ln1869">      continue;</a>
<a name="ln1870">    }</a>
<a name="ln1871"> </a>
<a name="ln1872">    if (data-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln1873">    {</a>
<a name="ln1874">      float complex *buffer = malloc (INTERPOLATION_POINTS * sizeof (float complex));</a>
<a name="ln1875">      interpolate_cubic_bezier (*p1,</a>
<a name="ln1876">                                data-&gt;node.ctrl1,</a>
<a name="ln1877">                                data-&gt;node.ctrl2,</a>
<a name="ln1878">                                *p2,</a>
<a name="ln1879">                                buffer,</a>
<a name="ln1880">                                INTERPOLATION_POINTS);</a>
<a name="ln1881">      const float total_length = get_arc_length (buffer, INTERPOLATION_POINTS);</a>
<a name="ln1882">      float arc_length = 0.0;</a>
<a name="ln1883">      restart_cookie_t restart = { 1, 0.0 };</a>
<a name="ln1884"> </a>
<a name="ln1885">      while (arc_length &lt; total_length)</a>
<a name="ln1886">      {</a>
<a name="ln1887">        dt_liquify_warp_t *w = malloc (sizeof (dt_liquify_warp_t));</a>
<a name="ln1888">        const float complex pt = point_at_arc_length (buffer, INTERPOLATION_POINTS, arc_length, &amp;restart);</a>
<a name="ln1889">        mix_warps (w, warp1, warp2, pt, arc_length / total_length);</a>
<a name="ln1890">        w-&gt;status = DT_LIQUIFY_STATUS_INTERPOLATED;</a>
<a name="ln1891">        arc_length += cabs (w-&gt;radius - w-&gt;point) * STAMP_RELOCATION;</a>
<a name="ln1892">        l = g_list_append (l, w);</a>
<a name="ln1893">      }</a>
<a name="ln1894">      free ((void *) buffer);</a>
<a name="ln1895">      continue;</a>
<a name="ln1896">    }</a>
<a name="ln1897">  }</a>
<a name="ln1898">  return l;</a>
<a name="ln1899">}</a>
<a name="ln1900"> </a>
<a name="ln1901">#define STROKE_TEST \</a>
<a name="ln1902">  if (do_hit_test) { if (cairo_in_stroke (cr, creal (*pt), cimag (*pt))) goto hit; continue; }</a>
<a name="ln1903"> </a>
<a name="ln1904">#define FILL_TEST \</a>
<a name="ln1905">  if (do_hit_test) { if (cairo_in_fill (cr, creal (*pt), cimag (*pt)) || cairo_in_stroke (cr, creal (*pt), cimag (*pt))) goto hit; continue; }</a>
<a name="ln1906"> </a>
<a name="ln1907">#define FG_COLOR  set_source_rgba (cr, fg_color);</a>
<a name="ln1908">#define BG_COLOR  set_source_rgba (cr, bg_color);</a>
<a name="ln1909">#define VERYTHINLINE  set_line_width  (cr, scale, DT_LIQUIFY_UI_WIDTH_THINLINE / 2.0);</a>
<a name="ln1910">#define THINLINE  set_line_width  (cr, scale, DT_LIQUIFY_UI_WIDTH_THINLINE);</a>
<a name="ln1911">#define THICKLINE set_line_width  (cr, scale, DT_LIQUIFY_UI_WIDTH_THICKLINE);</a>
<a name="ln1912"> </a>
<a name="ln1913">static dt_liquify_hit_t _draw_paths (dt_iop_module_t *module,</a>
<a name="ln1914">                                     cairo_t *cr,</a>
<a name="ln1915">                                     const float scale,</a>
<a name="ln1916">                                     dt_iop_liquify_params_t *p,</a>
<a name="ln1917">                                     GList *layers,</a>
<a name="ln1918">                                     const float complex *pt)</a>
<a name="ln1919">{</a>
<a name="ln1920">  dt_liquify_hit_t hit = NOWHERE;</a>
<a name="ln1921">  const gboolean do_hit_test = pt != NULL;</a>
<a name="ln1922"> </a>
<a name="ln1923">  cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln1924"> </a>
<a name="ln1925">  GList *interpolated = do_hit_test ? NULL : interpolate_paths (p);</a>
<a name="ln1926"> </a>
<a name="ln1927">  for (GList *l = layers; l != NULL; l = l-&gt;next)</a>
<a name="ln1928">  {</a>
<a name="ln1929">    const dt_liquify_layer_enum_t layer = (dt_liquify_layer_enum_t) GPOINTER_TO_INT (l-&gt;data);</a>
<a name="ln1930">    dt_liquify_rgba_t fg_color = dt_liquify_layers[layer].fg;</a>
<a name="ln1931">    dt_liquify_rgba_t bg_color = dt_liquify_layers[layer].bg;</a>
<a name="ln1932"> </a>
<a name="ln1933">    if (do_hit_test &amp;&amp; ((dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_HIT_TEST) == 0))</a>
<a name="ln1934">      continue;</a>
<a name="ln1935"> </a>
<a name="ln1936">    hit.layer = layer;</a>
<a name="ln1937"> </a>
<a name="ln1938">    if (dt_liquify_layers[layer].opacity &lt; 1.0)</a>
<a name="ln1939">        cairo_push_group (cr);</a>
<a name="ln1940"> </a>
<a name="ln1941">    for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln1942">    {</a>
<a name="ln1943">      dt_liquify_path_data_t *data = &amp;p-&gt;nodes[k];</a>
<a name="ln1944">      const dt_liquify_path_data_t *prev = node_prev (p, data);</a>
<a name="ln1945"> </a>
<a name="ln1946">      if (p-&gt;nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln1947">        break;</a>
<a name="ln1948"> </a>
<a name="ln1949">      hit.elem = data;</a>
<a name="ln1950"> </a>
<a name="ln1951">      if ((dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_NODE_SELECTED)</a>
<a name="ln1952">          &amp;&amp; !data-&gt;header.selected)</a>
<a name="ln1953">        continue;</a>
<a name="ln1954"> </a>
<a name="ln1955">      if ((dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_PREV_SELECTED)</a>
<a name="ln1956">          &amp;&amp; (!prev || !prev-&gt;header.selected))</a>
<a name="ln1957">        continue;</a>
<a name="ln1958"> </a>
<a name="ln1959">      fg_color = dt_liquify_layers[layer].fg;</a>
<a name="ln1960">      bg_color = dt_liquify_layers[layer].bg;</a>
<a name="ln1961"> </a>
<a name="ln1962">      if (data-&gt;header.selected == layer)</a>
<a name="ln1963">        fg_color = DT_LIQUIFY_COLOR_SELECTED;</a>
<a name="ln1964"> </a>
<a name="ln1965">      if (data-&gt;header.hovered == dt_liquify_layers[layer].hover_master)</a>
<a name="ln1966">        fg_color = DT_LIQUIFY_COLOR_HOVER;</a>
<a name="ln1967"> </a>
<a name="ln1968">      cairo_new_path (cr);</a>
<a name="ln1969"> </a>
<a name="ln1970">      const float complex point = data-&gt;warp.point;</a>
<a name="ln1971"> </a>
<a name="ln1972">      if (data-&gt;header.type == DT_LIQUIFY_PATH_MOVE_TO_V1)</a>
<a name="ln1973">        cairo_move_to (cr, creal (point), cimag (point));</a>
<a name="ln1974"> </a>
<a name="ln1975">      if (layer == DT_LIQUIFY_LAYER_RADIUS)</a>
<a name="ln1976">      {</a>
<a name="ln1977">        for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln1978">        {</a>
<a name="ln1979">          const dt_liquify_warp_t *pwarp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln1980">          draw_circle (cr, pwarp-&gt;point, 2.0f * cabs (pwarp-&gt;radius - pwarp-&gt;point));</a>
<a name="ln1981">        }</a>
<a name="ln1982">        draw_circle (cr, point, 2.0f * cabs (data-&gt;warp.radius - data-&gt;warp.point));</a>
<a name="ln1983">        FG_COLOR;</a>
<a name="ln1984">        cairo_fill (cr);</a>
<a name="ln1985">      }</a>
<a name="ln1986"> </a>
<a name="ln1987">      if (layer == DT_LIQUIFY_LAYER_HARDNESS1)</a>
<a name="ln1988">      {</a>
<a name="ln1989">        for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln1990">        {</a>
<a name="ln1991">          const dt_liquify_warp_t *pwarp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln1992">          draw_circle (cr, pwarp-&gt;point, 2.0f * cabs (pwarp-&gt;radius - pwarp-&gt;point) * pwarp-&gt;control1);</a>
<a name="ln1993">        }</a>
<a name="ln1994">        FG_COLOR;</a>
<a name="ln1995">        cairo_fill (cr);</a>
<a name="ln1996">      }</a>
<a name="ln1997"> </a>
<a name="ln1998">      if (layer == DT_LIQUIFY_LAYER_HARDNESS2)</a>
<a name="ln1999">      {</a>
<a name="ln2000">        for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln2001">        {</a>
<a name="ln2002">          const dt_liquify_warp_t *pwarp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln2003">          draw_circle (cr, pwarp-&gt;point, 2.0f * cabs (pwarp-&gt;radius - pwarp-&gt;point) * pwarp-&gt;control2);</a>
<a name="ln2004">        }</a>
<a name="ln2005">        FG_COLOR;</a>
<a name="ln2006">        cairo_fill (cr);</a>
<a name="ln2007">      }</a>
<a name="ln2008"> </a>
<a name="ln2009">      if (layer == DT_LIQUIFY_LAYER_WARPS)</a>
<a name="ln2010">      {</a>
<a name="ln2011">        VERYTHINLINE; FG_COLOR;</a>
<a name="ln2012">        for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln2013">        {</a>
<a name="ln2014">          const dt_liquify_warp_t *pwarp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln2015">          cairo_move_to (cr, creal (pwarp-&gt;point), cimag (pwarp-&gt;point));</a>
<a name="ln2016">          cairo_line_to (cr, creal (pwarp-&gt;strength), cimag (pwarp-&gt;strength));</a>
<a name="ln2017">        }</a>
<a name="ln2018">        cairo_stroke (cr);</a>
<a name="ln2019"> </a>
<a name="ln2020">        for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln2021">        {</a>
<a name="ln2022">          const dt_liquify_warp_t *pwarp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln2023">          const float rot = get_rot (pwarp-&gt;type);</a>
<a name="ln2024">          draw_circle   (cr, pwarp-&gt;point, GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2025">          draw_triangle (cr, pwarp-&gt;strength,</a>
<a name="ln2026">                         carg (pwarp-&gt;strength - pwarp-&gt;point) + rot,</a>
<a name="ln2027">                         GET_UI_WIDTH (GIZMO_SMALL) / 3.0);</a>
<a name="ln2028">        }</a>
<a name="ln2029">        BG_COLOR;</a>
<a name="ln2030">        cairo_fill_preserve (cr);</a>
<a name="ln2031">        FG_COLOR;</a>
<a name="ln2032">        cairo_stroke (cr);</a>
<a name="ln2033">      }</a>
<a name="ln2034"> </a>
<a name="ln2035">      if (layer == DT_LIQUIFY_LAYER_PATH)</a>
<a name="ln2036">      {</a>
<a name="ln2037">        if ((data-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1)</a>
<a name="ln2038">            || (data-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1))</a>
<a name="ln2039">        {</a>
<a name="ln2040">          assert (prev);</a>
<a name="ln2041">          cairo_move_to (cr, creal (prev-&gt;warp.point), cimag (prev-&gt;warp.point));</a>
<a name="ln2042">          if (data-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1)</a>
<a name="ln2043">            cairo_line_to (cr, creal (point), cimag (point));</a>
<a name="ln2044">          if (data-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2045">          {</a>
<a name="ln2046">            cairo_curve_to (cr, creal (data-&gt;node.ctrl1), cimag (data-&gt;node.ctrl1),</a>
<a name="ln2047">                            creal (data-&gt;node.ctrl2), cimag (data-&gt;node.ctrl2),</a>
<a name="ln2048">                            creal (point), cimag (point));</a>
<a name="ln2049">          }</a>
<a name="ln2050">          THICKLINE; FG_COLOR;</a>
<a name="ln2051">          STROKE_TEST;</a>
<a name="ln2052">          cairo_stroke_preserve (cr);</a>
<a name="ln2053">          THINLINE; BG_COLOR;</a>
<a name="ln2054">          cairo_stroke (cr);</a>
<a name="ln2055">        }</a>
<a name="ln2056">      }</a>
<a name="ln2057"> </a>
<a name="ln2058">      if (layer == DT_LIQUIFY_LAYER_CENTERPOINT)</a>
<a name="ln2059">      {</a>
<a name="ln2060">        if (data-&gt;header.type == DT_LIQUIFY_PATH_MOVE_TO_V1</a>
<a name="ln2061">            || data-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1</a>
<a name="ln2062">            || data-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2063">        {</a>
<a name="ln2064">          const float w = GET_UI_WIDTH (GIZMO);</a>
<a name="ln2065">          switch (data-&gt;header.node_type)</a>
<a name="ln2066">          {</a>
<a name="ln2067">             case DT_LIQUIFY_NODE_TYPE_CUSP:</a>
<a name="ln2068">               draw_triangle (cr, point - w / 2.0 * I, -M_PI / 2.0, w);</a>
<a name="ln2069">               break;</a>
<a name="ln2070">             case DT_LIQUIFY_NODE_TYPE_SMOOTH:</a>
<a name="ln2071">               draw_rectangle (cr, point, M_PI / 4.0, w);</a>
<a name="ln2072">               break;</a>
<a name="ln2073">             case DT_LIQUIFY_NODE_TYPE_SYMMETRICAL:</a>
<a name="ln2074">               draw_rectangle (cr, point, 0, w);</a>
<a name="ln2075">               break;</a>
<a name="ln2076">             case DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH:</a>
<a name="ln2077">               draw_circle (cr, point, w);</a>
<a name="ln2078">               break;</a>
<a name="ln2079">             default:</a>
<a name="ln2080">               break;</a>
<a name="ln2081">          }</a>
<a name="ln2082">          THINLINE; BG_COLOR;</a>
<a name="ln2083">          FILL_TEST;</a>
<a name="ln2084">          cairo_fill_preserve (cr);</a>
<a name="ln2085">          FG_COLOR;</a>
<a name="ln2086">          cairo_stroke (cr);</a>
<a name="ln2087">        }</a>
<a name="ln2088">      }</a>
<a name="ln2089"> </a>
<a name="ln2090">      if (data-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2091">      {</a>
<a name="ln2092">        if (layer == DT_LIQUIFY_LAYER_CTRLPOINT1_HANDLE &amp;&amp;</a>
<a name="ln2093">            !(prev &amp;&amp; prev-&gt;header.node_type == DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH))</a>
<a name="ln2094">        {</a>
<a name="ln2095">          THINLINE; FG_COLOR;</a>
<a name="ln2096">          cairo_move_to (cr, creal (prev-&gt;warp.point), cimag (prev-&gt;warp.point));</a>
<a name="ln2097">          cairo_line_to (cr, creal (data-&gt;node.ctrl1), cimag (data-&gt;node.ctrl1));</a>
<a name="ln2098">          cairo_stroke (cr);</a>
<a name="ln2099">        }</a>
<a name="ln2100">        if (layer == DT_LIQUIFY_LAYER_CTRLPOINT2_HANDLE &amp;&amp;</a>
<a name="ln2101">            data-&gt;header.node_type != DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH)</a>
<a name="ln2102">        {</a>
<a name="ln2103">          THINLINE; FG_COLOR;</a>
<a name="ln2104">          cairo_move_to (cr, creal (data-&gt;warp.point), cimag (data-&gt;warp.point));</a>
<a name="ln2105">          cairo_line_to (cr, creal (data-&gt;node.ctrl2), cimag (data-&gt;node.ctrl2));</a>
<a name="ln2106">          cairo_stroke (cr);</a>
<a name="ln2107">        }</a>
<a name="ln2108">        if (layer == DT_LIQUIFY_LAYER_CTRLPOINT1 &amp;&amp;</a>
<a name="ln2109">            !(prev &amp;&amp; prev-&gt;header.node_type == DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH))</a>
<a name="ln2110">        {</a>
<a name="ln2111">          THINLINE; BG_COLOR;</a>
<a name="ln2112">          draw_circle (cr, data-&gt;node.ctrl1, GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2113">          FILL_TEST;</a>
<a name="ln2114">          cairo_fill_preserve (cr);</a>
<a name="ln2115">          FG_COLOR;</a>
<a name="ln2116">          cairo_stroke (cr);</a>
<a name="ln2117">        }</a>
<a name="ln2118">        if (layer == DT_LIQUIFY_LAYER_CTRLPOINT2 &amp;&amp;</a>
<a name="ln2119">            data-&gt;header.node_type != DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH)</a>
<a name="ln2120">        {</a>
<a name="ln2121">          THINLINE; BG_COLOR;</a>
<a name="ln2122">          draw_circle (cr, data-&gt;node.ctrl2, GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2123">          FILL_TEST;</a>
<a name="ln2124">          cairo_fill_preserve (cr);</a>
<a name="ln2125">          FG_COLOR;</a>
<a name="ln2126">          cairo_stroke (cr);</a>
<a name="ln2127">        }</a>
<a name="ln2128">      }</a>
<a name="ln2129"> </a>
<a name="ln2130">      const dt_liquify_warp_t *warp  = &amp;data-&gt;warp;</a>
<a name="ln2131"> </a>
<a name="ln2132">      if (layer == DT_LIQUIFY_LAYER_RADIUSPOINT_HANDLE)</a>
<a name="ln2133">      {</a>
<a name="ln2134">        draw_circle (cr, point, 2.0 * cabs (warp-&gt;radius - point));</a>
<a name="ln2135">        THICKLINE; FG_COLOR;</a>
<a name="ln2136">        cairo_stroke_preserve (cr);</a>
<a name="ln2137">        THINLINE; BG_COLOR;</a>
<a name="ln2138">        cairo_stroke (cr);</a>
<a name="ln2139">      }</a>
<a name="ln2140"> </a>
<a name="ln2141">      if (layer == DT_LIQUIFY_LAYER_RADIUSPOINT)</a>
<a name="ln2142">      {</a>
<a name="ln2143">        THINLINE; BG_COLOR;</a>
<a name="ln2144">        draw_circle (cr, warp-&gt;radius, GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2145">        FILL_TEST;</a>
<a name="ln2146">        cairo_fill_preserve (cr);</a>
<a name="ln2147">        FG_COLOR;</a>
<a name="ln2148">        cairo_stroke (cr);</a>
<a name="ln2149">      }</a>
<a name="ln2150"> </a>
<a name="ln2151">      if (layer == DT_LIQUIFY_LAYER_HARDNESSPOINT1_HANDLE)</a>
<a name="ln2152">      {</a>
<a name="ln2153">        draw_circle (cr, point, 2.0 * cabs (warp-&gt;radius - point) * warp-&gt;control1);</a>
<a name="ln2154">        THICKLINE; FG_COLOR;</a>
<a name="ln2155">        cairo_stroke_preserve (cr);</a>
<a name="ln2156">        THINLINE; BG_COLOR;</a>
<a name="ln2157">        cairo_stroke (cr);</a>
<a name="ln2158">      }</a>
<a name="ln2159"> </a>
<a name="ln2160">      if (layer == DT_LIQUIFY_LAYER_HARDNESSPOINT2_HANDLE)</a>
<a name="ln2161">      {</a>
<a name="ln2162">        draw_circle (cr, point, 2.0 * cabs (warp-&gt;radius - point) * warp-&gt;control2);</a>
<a name="ln2163">        THICKLINE; FG_COLOR;</a>
<a name="ln2164">        cairo_stroke_preserve (cr);</a>
<a name="ln2165">        THINLINE; BG_COLOR;</a>
<a name="ln2166">        cairo_stroke (cr);</a>
<a name="ln2167">      }</a>
<a name="ln2168"> </a>
<a name="ln2169">      if (layer == DT_LIQUIFY_LAYER_HARDNESSPOINT1)</a>
<a name="ln2170">      {</a>
<a name="ln2171">        draw_triangle (cr, cmix (point, warp-&gt;radius, warp-&gt;control1),</a>
<a name="ln2172">                       carg (warp-&gt;radius - point),</a>
<a name="ln2173">                       GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2174">        THINLINE; BG_COLOR;</a>
<a name="ln2175">        FILL_TEST;</a>
<a name="ln2176">        cairo_fill_preserve (cr);</a>
<a name="ln2177">        FG_COLOR;</a>
<a name="ln2178">        cairo_stroke (cr);</a>
<a name="ln2179">      }</a>
<a name="ln2180"> </a>
<a name="ln2181">      if (layer == DT_LIQUIFY_LAYER_HARDNESSPOINT2)</a>
<a name="ln2182">      {</a>
<a name="ln2183">        draw_triangle (cr, cmix (point, warp-&gt;radius, warp-&gt;control2),</a>
<a name="ln2184">                       carg (- (warp-&gt;radius - point)),</a>
<a name="ln2185">                       GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2186">        THINLINE; BG_COLOR;</a>
<a name="ln2187">        FILL_TEST;</a>
<a name="ln2188">        cairo_fill_preserve (cr);</a>
<a name="ln2189">        FG_COLOR;</a>
<a name="ln2190">        cairo_stroke (cr);</a>
<a name="ln2191">      }</a>
<a name="ln2192"> </a>
<a name="ln2193">      if (layer == DT_LIQUIFY_LAYER_STRENGTHPOINT_HANDLE)</a>
<a name="ln2194">      {</a>
<a name="ln2195">        cairo_move_to (cr, creal (point), cimag (point));</a>
<a name="ln2196">        if (warp-&gt;type == DT_LIQUIFY_WARP_TYPE_LINEAR)</a>
<a name="ln2197">        {</a>
<a name="ln2198">          float complex pt = cmix (point, warp-&gt;strength, 1.0 - 0.5 *</a>
<a name="ln2199">                                   (GET_UI_WIDTH (GIZMO_SMALL) /</a>
<a name="ln2200">                                    cabs (warp-&gt;strength - point)));</a>
<a name="ln2201">          cairo_line_to (cr, creal (pt), cimag (pt));</a>
<a name="ln2202">        }</a>
<a name="ln2203">        else</a>
<a name="ln2204">          draw_circle (cr, point, 2.0 * cabs (warp-&gt;strength - warp-&gt;point));</a>
<a name="ln2205">        THICKLINE; FG_COLOR;</a>
<a name="ln2206">        cairo_stroke_preserve (cr);</a>
<a name="ln2207">        THINLINE; BG_COLOR;</a>
<a name="ln2208">        cairo_stroke (cr);</a>
<a name="ln2209">      }</a>
<a name="ln2210"> </a>
<a name="ln2211">      if (layer == DT_LIQUIFY_LAYER_STRENGTHPOINT)</a>
<a name="ln2212">      {</a>
<a name="ln2213">        const float rot = get_rot (warp-&gt;type);</a>
<a name="ln2214">        draw_triangle (cr, warp-&gt;strength,</a>
<a name="ln2215">                       carg (warp-&gt;strength - warp-&gt;point) + rot,</a>
<a name="ln2216">                       GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2217">        THINLINE; BG_COLOR;</a>
<a name="ln2218">        FILL_TEST;</a>
<a name="ln2219">        cairo_fill_preserve (cr);</a>
<a name="ln2220">        FG_COLOR;</a>
<a name="ln2221">        cairo_stroke (cr);</a>
<a name="ln2222">      }</a>
<a name="ln2223">    }</a>
<a name="ln2224"> </a>
<a name="ln2225">    if (dt_liquify_layers[layer].opacity &lt; 1.0)</a>
<a name="ln2226">    {</a>
<a name="ln2227">      cairo_pop_group_to_source (cr);</a>
<a name="ln2228">      cairo_paint_with_alpha (cr, dt_liquify_layers[layer].opacity);</a>
<a name="ln2229">    }</a>
<a name="ln2230">  }</a>
<a name="ln2231"> </a>
<a name="ln2232">  g_list_free_full (interpolated, free);</a>
<a name="ln2233">  return NOWHERE;</a>
<a name="ln2234"> </a>
<a name="ln2235">hit:</a>
<a name="ln2236">  g_list_free_full (interpolated, free);</a>
<a name="ln2237">  cairo_new_path (cr); // otherwise a successful hit test would leave the path behind</a>
<a name="ln2238">  return hit;</a>
<a name="ln2239">}</a>
<a name="ln2240"> </a>
<a name="ln2241">static void draw_paths (struct dt_iop_module_t *module, cairo_t *cr, float scale, dt_iop_liquify_params_t *params)</a>
<a name="ln2242">{</a>
<a name="ln2243">  const dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2244">  GList *layers = NULL;</a>
<a name="ln2245"> </a>
<a name="ln2246">  for (dt_liquify_layer_enum_t layer = 0; layer &lt; DT_LIQUIFY_LAYER_LAST; ++layer)</a>
<a name="ln2247">  {</a>
<a name="ln2248">    if (gtk_toggle_button_get_active (g-&gt;btn_point_tool)</a>
<a name="ln2249">        &amp;&amp; (dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_POINT_TOOL))</a>
<a name="ln2250">      layers = g_list_append (layers, GINT_TO_POINTER (layer));</a>
<a name="ln2251">    if (gtk_toggle_button_get_active (g-&gt;btn_line_tool)</a>
<a name="ln2252">        &amp;&amp; (dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_LINE_TOOL))</a>
<a name="ln2253">      layers = g_list_append (layers, GINT_TO_POINTER (layer));</a>
<a name="ln2254">    if (gtk_toggle_button_get_active (g-&gt;btn_curve_tool)</a>
<a name="ln2255">        &amp;&amp; (dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_CURVE_TOOL))</a>
<a name="ln2256">      layers = g_list_append (layers, GINT_TO_POINTER (layer));</a>
<a name="ln2257">    if (gtk_toggle_button_get_active (g-&gt;btn_node_tool)</a>
<a name="ln2258">        &amp;&amp; (dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_NODE_TOOL))</a>
<a name="ln2259">      layers = g_list_append (layers, GINT_TO_POINTER (layer));</a>
<a name="ln2260">  }</a>
<a name="ln2261"> </a>
<a name="ln2262">  _draw_paths (module, cr, scale, params, layers, NULL);</a>
<a name="ln2263"> </a>
<a name="ln2264">  g_list_free (layers);</a>
<a name="ln2265">}</a>
<a name="ln2266"> </a>
<a name="ln2267">static dt_liquify_hit_t hit_test_paths (struct dt_iop_module_t *module,</a>
<a name="ln2268">                                        float scale,</a>
<a name="ln2269">                                        cairo_t *cr,</a>
<a name="ln2270">                                        dt_iop_liquify_params_t *params,</a>
<a name="ln2271">                                        float complex pt)</a>
<a name="ln2272">{</a>
<a name="ln2273">  dt_liquify_hit_t hit = NOWHERE;</a>
<a name="ln2274">  GList *layers = NULL;</a>
<a name="ln2275"> </a>
<a name="ln2276">  for (dt_liquify_layer_enum_t layer = 0; layer &lt; DT_LIQUIFY_LAYER_LAST; ++layer)</a>
<a name="ln2277">  {</a>
<a name="ln2278">    if (dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_HIT_TEST)</a>
<a name="ln2279">      layers = g_list_append (layers, GINT_TO_POINTER (layer));</a>
<a name="ln2280">  }</a>
<a name="ln2281"> </a>
<a name="ln2282">  layers = g_list_reverse (layers);</a>
<a name="ln2283">  hit = _draw_paths (module, cr, scale, params, layers, &amp;pt);</a>
<a name="ln2284">  g_list_free (layers);</a>
<a name="ln2285">  return hit;</a>
<a name="ln2286">}</a>
<a name="ln2287"> </a>
<a name="ln2288">// split a cubic bezier at t into two cubic beziers.</a>
<a name="ln2289"> </a>
<a name="ln2290">static void casteljau (const float complex *p0, float complex *p1, float complex *p2, float complex *p3, const float t)</a>
<a name="ln2291">{</a>
<a name="ln2292">  const float complex p01 = *p0 + (*p1 - *p0) * t;</a>
<a name="ln2293">  const float complex p12 = *p1 + (*p2 - *p1) * t;</a>
<a name="ln2294">  const float complex p23 = *p2 + (*p3 - *p2) * t;</a>
<a name="ln2295"> </a>
<a name="ln2296">  const float complex p012 = p01 + (p12 - p01) * t;</a>
<a name="ln2297">  const float complex p123 = p12 + (p23 - p12) * t;</a>
<a name="ln2298"> </a>
<a name="ln2299">  const float complex p0123 = p012 + (p123 - p012) * t;</a>
<a name="ln2300"> </a>
<a name="ln2301">  *p1 = p01;</a>
<a name="ln2302">  *p2 = p012;</a>
<a name="ln2303">  *p3 = p0123;</a>
<a name="ln2304">}</a>
<a name="ln2305"> </a>
<a name="ln2306">/*</a>
<a name="ln2307">  Find the nearest point on a cubic bezier curve.</a>
<a name="ln2308"> </a>
<a name="ln2309">  Return the curve parameter t of the point on a cubic bezier curve</a>
<a name="ln2310">  that is nearest to another arbitrary point.  Uses interpolation.</a>
<a name="ln2311"> </a>
<a name="ln2312">  FIXME: Implement a faster method, see:</a>
<a name="ln2313">  http://tog.acm.org/resources/GraphicsGems/gems/NearestPoint.c</a>
<a name="ln2314">*/</a>
<a name="ln2315"> </a>
<a name="ln2316">static float find_nearest_on_curve_t (const float complex p0,</a>
<a name="ln2317">                                      const float complex p1,</a>
<a name="ln2318">                                      const float complex p2,</a>
<a name="ln2319">                                      const float complex p3,</a>
<a name="ln2320">                                      const float complex x,</a>
<a name="ln2321">                                      const int n)</a>
<a name="ln2322">{</a>
<a name="ln2323">  float min_t = 0, min_dist = cabs (x - p0);</a>
<a name="ln2324"> </a>
<a name="ln2325">  for (int i = 0; i &lt; n; i++)</a>
<a name="ln2326">  {</a>
<a name="ln2327">    const float t = (1.0 * i) / n;</a>
<a name="ln2328">    const float t1 = 1.0 - t;</a>
<a name="ln2329">    const float complex ip =</a>
<a name="ln2330">          t1 * t1 * t1 * p0 +</a>
<a name="ln2331">      3 * t1 * t1 * t  * p1 +</a>
<a name="ln2332">      3 * t1 * t  * t  * p2 +</a>
<a name="ln2333">          t  * t  * t  * p3;</a>
<a name="ln2334"> </a>
<a name="ln2335">    const float dist = cabs (x - ip);</a>
<a name="ln2336">    if (dist &lt; min_dist)</a>
<a name="ln2337">    {</a>
<a name="ln2338">      min_dist = dist;</a>
<a name="ln2339">      min_t = t;</a>
<a name="ln2340">    }</a>
<a name="ln2341">  }</a>
<a name="ln2342">  return min_t;</a>
<a name="ln2343">}</a>
<a name="ln2344"> </a>
<a name="ln2345">/*</a>
<a name="ln2346">  Find the nearest point on a line.</a>
<a name="ln2347"> </a>
<a name="ln2348">  Return the line parameter t of the point on a line that is nearest</a>
<a name="ln2349">  to another arbitrary point.</a>
<a name="ln2350">*/</a>
<a name="ln2351"> </a>
<a name="ln2352">static float find_nearest_on_line_t (const float complex p0, const float complex p1, const float complex x)</a>
<a name="ln2353">{</a>
<a name="ln2354">  // scalar projection</a>
<a name="ln2355">  const float b     = cabs (p1 - p0);           // |b|</a>
<a name="ln2356">  const float dotab = cdot (x - p0, p1 - p0);   // |a| * |b| * cos(phi)</a>
<a name="ln2357">  return dotab / (b * b);                       // |a| / |b| * cos(phi)</a>
<a name="ln2358">}</a>
<a name="ln2359"> </a>
<a name="ln2360">/**</a>
<a name="ln2361"> * Smooth a bezier spline through prescribed points.</a>
<a name="ln2362"> *</a>
<a name="ln2363"> * Smooth a bezier spline through prescribed points by solving a</a>
<a name="ln2364"> * linear system.  First we build a tridiagonal matrix and then we</a>
<a name="ln2365"> * solve it using the Thomas algorithm.  (FIXME: A tridiagonal matrix</a>
<a name="ln2366"> * is easy to solve in O(n) but you cannot write a closed path as a</a>
<a name="ln2367"> * tridiagonal.  To solve closed paths we will have to use a different</a>
<a name="ln2368"> * solver. Use the GSL?)</a>
<a name="ln2369"> *</a>
<a name="ln2370"> * Here is an article that explains the math:</a>
<a name="ln2371"> * http://www.particleincell.com/blog/2012/bezier-splines/</a>
<a name="ln2372"> *</a>
<a name="ln2373"> * Basically we find all the ctrl1 points when we solve the linear</a>
<a name="ln2374"> * system, then we calculate each ctrl2 from the ctrl1.</a>
<a name="ln2375"> *</a>
<a name="ln2376"> * We build the linear system choosing for each segment of the path an</a>
<a name="ln2377"> * equation among following 9 equations.  &quot;Straight&quot; is a path that</a>
<a name="ln2378"> * goes straight in to the knot (2nd derivative == 0 at the knot).</a>
<a name="ln2379"> * &quot;Smooth&quot; means a path that goes smoothly through the knot, makes no</a>
<a name="ln2380"> * corner and curves the same amount just before and just after the</a>
<a name="ln2381"> * knot (1st and 2nd derivatives are constant around the knot.)</a>
<a name="ln2382"> * &quot;Keep&quot; means to keep the control point as the user set it.</a>
<a name="ln2383"> *</a>
<a name="ln2384"> * |    | start       |   end of path</a>
<a name="ln2385"> * | -- | ----------- | ---------------</a>
<a name="ln2386"> * | 1  | straight    | smooth</a>
<a name="ln2387"> * | 2  | smooth      | smooth</a>
<a name="ln2388"> * | 3  | smooth      | straight</a>
<a name="ln2389"> * | 4  | keep        | smooth</a>
<a name="ln2390"> * | 5  | keep        | keep</a>
<a name="ln2391"> * | 6  | smooth      | keep</a>
<a name="ln2392"> * | 7  | keep        | straight</a>
<a name="ln2393"> * | 8  | straight    | straight  (yields a line)</a>
<a name="ln2394"> * | 9  | straight    | keep</a>
<a name="ln2395"> *</a>
<a name="ln2396"> * The equations are (close your eyes):</a>
<a name="ln2397"> *</a>
<a name="ln2398"> * \f{eqnarray}{</a>
<a name="ln2399"> *                2P_{1,i} + P_{1,i+1} &amp;=&amp;  K_i + 2K_{i+1}  \label{1} \\</a>
<a name="ln2400"> *    P_{1,i-1} + 4P_{1,i} + P_{1,i+1} &amp;=&amp; 4K_i + 2K_{i+1}  \label{2} \\</a>
<a name="ln2401"> *   2P_{1,i-1} + 7P_{1,i}             &amp;=&amp; 8K_i +  K_{i+1}  \label{3} \\</a>
<a name="ln2402"> *                 P_{1,i}             &amp;=&amp; C1_i             \label{4} \\</a>
<a name="ln2403"> *                 P_{1,i}             &amp;=&amp; C1_i             \label{5} \\</a>
<a name="ln2404"> *    P_{1,i-1} + 4P_{1,i}             &amp;=&amp; C2_i + 4K_i      \label{6} \\</a>
<a name="ln2405"> *                 P_{1,i}             &amp;=&amp; C1_i             \label{7} \\</a>
<a name="ln2406"> *                3P_{1,i}             &amp;=&amp; 2K_i +  K_{i+1}  \label{8} \\</a>
<a name="ln2407"> *                2P_{1,i}             &amp;=&amp;  K_i +  C2_i     \label{9}</a>
<a name="ln2408"> * \f}</a>
<a name="ln2409"> *</a>
<a name="ln2410"> * Some of these are the same and differ only in the way we calculate</a>
<a name="ln2411"> * c2. (You may open your eyes again.)</a>
<a name="ln2412"> */</a>
<a name="ln2413"> </a>
<a name="ln2414">static void smooth_path_linsys (size_t n,</a>
<a name="ln2415">                                const float complex *k,</a>
<a name="ln2416">                                float complex *c1,</a>
<a name="ln2417">                                float complex *c2,</a>
<a name="ln2418">                                const int *equation)</a>
<a name="ln2419">{</a>
<a name="ln2420">  --n;</a>
<a name="ln2421">  float *a = malloc (n * sizeof (float)); // subdiagonal</a>
<a name="ln2422">  float *b = malloc (n * sizeof (float)); // main diagonal</a>
<a name="ln2423">  float *c = malloc (n * sizeof (float)); // superdiagonal</a>
<a name="ln2424">  float complex *d = malloc (n * sizeof (float complex)); // right hand side</a>
<a name="ln2425"> </a>
<a name="ln2426">  // Build the tridiagonal matrix.</a>
<a name="ln2427"> </a>
<a name="ln2428">  for (int i = 0; i &lt; n; i++)</a>
<a name="ln2429">  {</a>
<a name="ln2430">    switch (equation[i])</a>
<a name="ln2431">    {</a>
<a name="ln2432">    #define ABCD(A,B,C,D) { { a[i] = A; b[i] = B; c[i] = C; d[i] = D; continue; } }</a>
<a name="ln2433">       case 1:  ABCD (0, 2, 1,       k[i] + 2 * k[i+1]   ); break;</a>
<a name="ln2434">       case 2:  ABCD (1, 4, 1,   4 * k[i] + 2 * k[i+1]   ); break;</a>
<a name="ln2435">       case 3:  ABCD (2, 7, 0,   8 * k[i] +     k[i+1]   ); break;</a>
<a name="ln2436">       case 4:  ABCD (0, 1, 0,                  c1[i]    ); break;</a>
<a name="ln2437">       case 5:  ABCD (0, 1, 0,                  c1[i]    ); break;</a>
<a name="ln2438">       case 6:  ABCD (1, 4, 0,   4 * k[i] +     c2[i]    ); break;</a>
<a name="ln2439">       case 7:  ABCD (0, 1, 0,                  c1[i]    ); break;</a>
<a name="ln2440">       case 8:  ABCD (0, 3, 0,   2 * k[i] +     k[i+1]   ); break;</a>
<a name="ln2441">       case 9:  ABCD (0, 2, 0,       k[i] +     c2[i]    ); break;</a>
<a name="ln2442">    #undef ABCD</a>
<a name="ln2443">    }</a>
<a name="ln2444">  }</a>
<a name="ln2445"> </a>
<a name="ln2446">  // Solve with the Thomas algorithm to compute c1's.  See:</a>
<a name="ln2447">  // http://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm</a>
<a name="ln2448"> </a>
<a name="ln2449">  for (int i = 1; i &lt; n; i++)</a>
<a name="ln2450">  {</a>
<a name="ln2451">    const float m = a[i] / b[i-1];</a>
<a name="ln2452">    b[i] = b[i] - m * c[i-1];</a>
<a name="ln2453">    d[i] = d[i] - m * d[i-1];</a>
<a name="ln2454">  }</a>
<a name="ln2455"> </a>
<a name="ln2456">  c1[n-1] = d[n-1] / b[n-1];</a>
<a name="ln2457">  for (int i = n - 2; i &gt;= 0; i--)</a>
<a name="ln2458">    c1[i] = (d[i] - c[i] * c1[i+1]) / b[i];</a>
<a name="ln2459"> </a>
<a name="ln2460">  // Now compute the c2's.</a>
<a name="ln2461"> </a>
<a name="ln2462">  for (int i = 0; i &lt; n; i++)</a>
<a name="ln2463">  {</a>
<a name="ln2464">    switch (equation[i])</a>
<a name="ln2465">    {</a>
<a name="ln2466">       // keep end: c2 does not change</a>
<a name="ln2467">       case 5:</a>
<a name="ln2468">       case 6:</a>
<a name="ln2469">       case 9:  break;</a>
<a name="ln2470"> </a>
<a name="ln2471">       // straight end: put c2[i] halfway between c1[i] and k[i+1]</a>
<a name="ln2472">       case 3:</a>
<a name="ln2473">       case 7:</a>
<a name="ln2474">       case 8:  c2[i] = (c1[i] + k[i+1]) / 2;  break;</a>
<a name="ln2475"> </a>
<a name="ln2476">       // smooth end: c2 and c1 are symmetrical around the knot</a>
<a name="ln2477">       default: c2[i] = 2 * k[i+1] - c1[i+1];</a>
<a name="ln2478">    }</a>
<a name="ln2479">  }</a>
<a name="ln2480"> </a>
<a name="ln2481">  free (a);</a>
<a name="ln2482">  free (b);</a>
<a name="ln2483">  free (c);</a>
<a name="ln2484">  free (d);</a>
<a name="ln2485">}</a>
<a name="ln2486"> </a>
<a name="ln2487">static int path_length(dt_iop_liquify_params_t *p, dt_liquify_path_data_t *n)</a>
<a name="ln2488">{</a>
<a name="ln2489">  int count = 1;</a>
<a name="ln2490">  while (n-&gt;header.next != -1)</a>
<a name="ln2491">  {</a>
<a name="ln2492">    count++;</a>
<a name="ln2493">    n = &amp;p-&gt;nodes[n-&gt;header.next];</a>
<a name="ln2494">  }</a>
<a name="ln2495">  return count;</a>
<a name="ln2496">}</a>
<a name="ln2497"> </a>
<a name="ln2498">static void smooth_paths_linsys (dt_iop_liquify_params_t *params)</a>
<a name="ln2499">{</a>
<a name="ln2500">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln2501">  {</a>
<a name="ln2502">    if (params-&gt;nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln2503">      break;</a>
<a name="ln2504"> </a>
<a name="ln2505">    if (params-&gt;nodes[k].header.prev != -1)</a>
<a name="ln2506">      continue;</a>
<a name="ln2507"> </a>
<a name="ln2508">    dt_liquify_path_data_t *node = &amp;params-&gt;nodes[k];</a>
<a name="ln2509"> </a>
<a name="ln2510">    const size_t n = path_length (params, node);</a>
<a name="ln2511"> </a>
<a name="ln2512">    if (n &lt; 2)</a>
<a name="ln2513">      continue;</a>
<a name="ln2514"> </a>
<a name="ln2515">    float complex *pt   = calloc (n, sizeof (float complex));</a>
<a name="ln2516">    float complex *c1   = calloc (n, sizeof (float complex));</a>
<a name="ln2517">    float complex *c2   = calloc (n, sizeof (float complex));</a>
<a name="ln2518">    int *eqn            = calloc (n, sizeof (int));</a>
<a name="ln2519">    size_t idx = 0;</a>
<a name="ln2520"> </a>
<a name="ln2521">    while (node)</a>
<a name="ln2522">    {</a>
<a name="ln2523">      const dt_liquify_path_data_t *d = (dt_liquify_path_data_t *) node;</a>
<a name="ln2524">      const dt_liquify_path_data_t *p = node_prev (params, node);</a>
<a name="ln2525">      const dt_liquify_path_data_t *n = node_next (params, node);</a>
<a name="ln2526">      const dt_liquify_path_data_t *nn = n ? node_next (params, n) : NULL;</a>
<a name="ln2527"> </a>
<a name="ln2528">      pt[idx] = node-&gt;warp.point;</a>
<a name="ln2529">      if (d-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2530">      {</a>
<a name="ln2531">        c1[idx-1] = d-&gt;node.ctrl1;</a>
<a name="ln2532">        c2[idx-1] = d-&gt;node.ctrl2;</a>
<a name="ln2533">      }</a>
<a name="ln2534"> </a>
<a name="ln2535">      const int autosmooth      = d-&gt;header.node_type == DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln2536">      const int next_autosmooth = n   &amp;&amp;  n-&gt;header.node_type == DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln2537">      const int firstseg        = !p  ||  d-&gt;header.type != DT_LIQUIFY_PATH_CURVE_TO_V1;</a>
<a name="ln2538">      const int lastseg         = !nn ||  nn-&gt;header.type != DT_LIQUIFY_PATH_CURVE_TO_V1;</a>
<a name="ln2539">      const int lineseg         = n   &amp;&amp;  n-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1;</a>
<a name="ln2540"> </a>
<a name="ln2541">      // Program the linear system with equations:</a>
<a name="ln2542">      //</a>
<a name="ln2543">      //    START           END</a>
<a name="ln2544">      //    --------------------------</a>
<a name="ln2545">      // 1: straight        smooth</a>
<a name="ln2546">      // 2: smooth          smooth</a>
<a name="ln2547">      // 3: smooth          straight</a>
<a name="ln2548">      // 4: keep            smooth</a>
<a name="ln2549">      // 5: keep            keep</a>
<a name="ln2550">      // 6: smooth          keep</a>
<a name="ln2551">      // 7: keep            straight</a>
<a name="ln2552">      // 8: straight        straight   (== line)</a>
<a name="ln2553">      // 9: straight        keep</a>
<a name="ln2554"> </a>
<a name="ln2555">      if (lineseg)                                                    eqn[idx] = 5;</a>
<a name="ln2556">      else if (!autosmooth &amp;&amp; !next_autosmooth)                       eqn[idx] = 5;</a>
<a name="ln2557">      else if (firstseg &amp;&amp; lastseg &amp;&amp; !autosmooth &amp;&amp; next_autosmooth) eqn[idx] = 7;</a>
<a name="ln2558">      else if (firstseg &amp;&amp; lastseg &amp;&amp; autosmooth &amp;&amp; next_autosmooth)  eqn[idx] = 8;</a>
<a name="ln2559">      else if (firstseg &amp;&amp; lastseg &amp;&amp; autosmooth &amp;&amp; !next_autosmooth) eqn[idx] = 9;</a>
<a name="ln2560">      else if (firstseg &amp;&amp; autosmooth &amp;&amp; !next_autosmooth)            eqn[idx] = 5;</a>
<a name="ln2561">      else if (firstseg &amp;&amp; autosmooth)                                eqn[idx] = 1;</a>
<a name="ln2562">      else if (lastseg &amp;&amp; autosmooth &amp;&amp; next_autosmooth)              eqn[idx] = 3;</a>
<a name="ln2563">      else if (lastseg &amp;&amp; !autosmooth &amp;&amp; next_autosmooth)             eqn[idx] = 7;</a>
<a name="ln2564">      else if (autosmooth &amp;&amp; !next_autosmooth)                        eqn[idx] = 6;</a>
<a name="ln2565">      else if (!autosmooth &amp;&amp; next_autosmooth)                        eqn[idx] = 4;</a>
<a name="ln2566">      else                                                            eqn[idx] = 2;</a>
<a name="ln2567"> </a>
<a name="ln2568">      ++idx;</a>
<a name="ln2569">      node = node_next (params, node);</a>
<a name="ln2570">    }</a>
<a name="ln2571"> </a>
<a name="ln2572">    smooth_path_linsys (n, pt, c1, c2, eqn);</a>
<a name="ln2573"> </a>
<a name="ln2574">    // write calculated control points back to list structure</a>
<a name="ln2575">    node = &amp;params-&gt;nodes[k];</a>
<a name="ln2576">    node = node_next(params, node);</a>
<a name="ln2577">    idx = 0;</a>
<a name="ln2578">    while (node)</a>
<a name="ln2579">    {</a>
<a name="ln2580">      dt_liquify_path_data_t *d  = (dt_liquify_path_data_t *) node;</a>
<a name="ln2581">      if (d-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2582">      {</a>
<a name="ln2583">        d-&gt;node.ctrl1 = c1[idx];</a>
<a name="ln2584">        d-&gt;node.ctrl2 = c2[idx];</a>
<a name="ln2585">      }</a>
<a name="ln2586">      ++idx;</a>
<a name="ln2587">      node = node_next(params, node);</a>
<a name="ln2588">    }</a>
<a name="ln2589"> </a>
<a name="ln2590">    free (pt);</a>
<a name="ln2591">    free (c1);</a>
<a name="ln2592">    free (c2);</a>
<a name="ln2593">    free (eqn);</a>
<a name="ln2594">  }</a>
<a name="ln2595">}</a>
<a name="ln2596"> </a>
<a name="ln2597">static dt_liquify_path_data_t *find_hovered (dt_iop_liquify_params_t *p)</a>
<a name="ln2598">{</a>
<a name="ln2599">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln2600">    if (p-&gt;nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln2601">      break;</a>
<a name="ln2602">    else if (p-&gt;nodes[k].header.hovered)</a>
<a name="ln2603">      return &amp;p-&gt;nodes[k];</a>
<a name="ln2604">  return NULL;</a>
<a name="ln2605">}</a>
<a name="ln2606"> </a>
<a name="ln2607">static void init_warp (dt_liquify_warp_t *warp, float complex point)</a>
<a name="ln2608">{</a>
<a name="ln2609">  warp-&gt;type     = DT_LIQUIFY_WARP_TYPE_LINEAR;</a>
<a name="ln2610">  warp-&gt;point    = point;</a>
<a name="ln2611">  warp-&gt;radius   = point;</a>
<a name="ln2612">  warp-&gt;strength = point;</a>
<a name="ln2613">  warp-&gt;control1 = 0.5;</a>
<a name="ln2614">  warp-&gt;control2 = 0.75;</a>
<a name="ln2615">  warp-&gt;status   = DT_LIQUIFY_STATUS_NONE;</a>
<a name="ln2616">}</a>
<a name="ln2617"> </a>
<a name="ln2618">static dt_liquify_path_data_t *alloc_move_to (dt_iop_module_t *module, float complex start_point)</a>
<a name="ln2619">{</a>
<a name="ln2620">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2621">  dt_liquify_path_data_t* m = (dt_liquify_path_data_t*)node_alloc (&amp;g-&gt;params, &amp;g-&gt;node_index);</a>
<a name="ln2622">  if (m)</a>
<a name="ln2623">  {</a>
<a name="ln2624">    m-&gt;header.type = DT_LIQUIFY_PATH_MOVE_TO_V1;</a>
<a name="ln2625">    m-&gt;header.node_type = DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln2626">    init_warp (&amp;m-&gt;warp, start_point);</a>
<a name="ln2627">  }</a>
<a name="ln2628">  return (dt_liquify_path_data_t *)m;</a>
<a name="ln2629">}</a>
<a name="ln2630"> </a>
<a name="ln2631">static dt_liquify_path_data_t *alloc_line_to (dt_iop_module_t *module, float complex end_point)</a>
<a name="ln2632">{</a>
<a name="ln2633">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2634">  dt_liquify_path_data_t* l = (dt_liquify_path_data_t*)node_alloc (&amp;g-&gt;params, &amp;g-&gt;node_index);</a>
<a name="ln2635">  if (l)</a>
<a name="ln2636">  {</a>
<a name="ln2637">    l-&gt;header.type = DT_LIQUIFY_PATH_LINE_TO_V1;</a>
<a name="ln2638">    l-&gt;header.node_type = DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln2639">    init_warp (&amp;l-&gt;warp, end_point);</a>
<a name="ln2640">  }</a>
<a name="ln2641">  return (dt_liquify_path_data_t *)l;</a>
<a name="ln2642">}</a>
<a name="ln2643"> </a>
<a name="ln2644">static dt_liquify_path_data_t *alloc_curve_to (dt_iop_module_t *module, float complex end_point)</a>
<a name="ln2645">{</a>
<a name="ln2646">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2647">  dt_liquify_path_data_t* c = (dt_liquify_path_data_t*)node_alloc (&amp;g-&gt;params, &amp;g-&gt;node_index);</a>
<a name="ln2648">  if (c)</a>
<a name="ln2649">  {</a>
<a name="ln2650">    c-&gt;header.type = DT_LIQUIFY_PATH_CURVE_TO_V1;</a>
<a name="ln2651">    c-&gt;header.node_type = DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln2652">    c-&gt;node.ctrl1 = c-&gt;node.ctrl2 = 0.0;</a>
<a name="ln2653">    init_warp (&amp;c-&gt;warp, end_point);</a>
<a name="ln2654">  }</a>
<a name="ln2655">  return (dt_liquify_path_data_t *)c;</a>
<a name="ln2656">}</a>
<a name="ln2657"> </a>
<a name="ln2658">static void start_drag (dt_iop_liquify_gui_data_t *g, dt_liquify_layer_enum_t layer, dt_liquify_path_data_t *elem)</a>
<a name="ln2659">{</a>
<a name="ln2660">  g-&gt;dragging.layer = layer;</a>
<a name="ln2661">  g-&gt;dragging.elem = elem;</a>
<a name="ln2662">}</a>
<a name="ln2663"> </a>
<a name="ln2664">static void end_drag (dt_iop_liquify_gui_data_t *g)</a>
<a name="ln2665">{</a>
<a name="ln2666">  g-&gt;dragging = NOWHERE;</a>
<a name="ln2667">}</a>
<a name="ln2668"> </a>
<a name="ln2669">static gboolean is_dragging(dt_iop_liquify_gui_data_t *g)</a>
<a name="ln2670">{</a>
<a name="ln2671">  return g-&gt;dragging.elem != NULL;</a>
<a name="ln2672">}</a>
<a name="ln2673"> </a>
<a name="ln2674">static void unselect_all (dt_iop_liquify_params_t *p)</a>
<a name="ln2675">{</a>
<a name="ln2676">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln2677">    if (p-&gt;nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln2678">      break;</a>
<a name="ln2679">    else</a>
<a name="ln2680">      p-&gt;nodes[k].header.selected = 0;</a>
<a name="ln2681">}</a>
<a name="ln2682"> </a>
<a name="ln2683">static float get_zoom_scale (dt_develop_t *develop)</a>
<a name="ln2684">{</a>
<a name="ln2685">  const dt_dev_zoom_t zoom = dt_control_get_dev_zoom ();</a>
<a name="ln2686">  const int closeup = dt_control_get_dev_closeup ();</a>
<a name="ln2687">  return dt_dev_get_zoom_scale (develop, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln2688">}</a>
<a name="ln2689"> </a>
<a name="ln2690">void gui_post_expose (struct dt_iop_module_t *module,</a>
<a name="ln2691">                      cairo_t *cr,</a>
<a name="ln2692">                      int32_t width,</a>
<a name="ln2693">                      int32_t height,</a>
<a name="ln2694">                      int32_t pointerx,</a>
<a name="ln2695">                      int32_t pointery)</a>
<a name="ln2696">{</a>
<a name="ln2697">  dt_develop_t *develop = module-&gt;dev;</a>
<a name="ln2698">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2699">  if (!g)</a>
<a name="ln2700">    return;</a>
<a name="ln2701"> </a>
<a name="ln2702">  const float bb_width = develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln2703">  const float bb_height = develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln2704">  const float iscale = develop-&gt;preview_pipe-&gt;iscale;</a>
<a name="ln2705">  const float scale = MAX (bb_width, bb_height);</a>
<a name="ln2706">  if (bb_width &lt; 1.0 || bb_height &lt; 1.0)</a>
<a name="ln2707">    return;</a>
<a name="ln2708"> </a>
<a name="ln2709">  // get a copy of all iop params</a>
<a name="ln2710">  dt_pthread_mutex_lock (&amp;g-&gt;lock);</a>
<a name="ln2711">  update_warp_count (g);</a>
<a name="ln2712">  smooth_paths_linsys (&amp;g-&gt;params);</a>
<a name="ln2713">  dt_iop_liquify_params_t copy_params;</a>
<a name="ln2714">  memcpy(&amp;copy_params, &amp;g-&gt;params, sizeof(dt_iop_liquify_params_t));</a>
<a name="ln2715">  dt_pthread_mutex_unlock (&amp;g-&gt;lock);</a>
<a name="ln2716"> </a>
<a name="ln2717">  // distort all points</a>
<a name="ln2718">  dt_pthread_mutex_lock(&amp;develop-&gt;preview_pipe_mutex);</a>
<a name="ln2719">  const distort_params_t d_params = { develop, develop-&gt;preview_pipe, iscale, 1.0 / scale, DT_DEV_TRANSFORM_DIR_ALL, FALSE };</a>
<a name="ln2720">  _distort_paths (module, &amp;d_params, &amp;copy_params);</a>
<a name="ln2721">  dt_pthread_mutex_unlock(&amp;develop-&gt;preview_pipe_mutex);</a>
<a name="ln2722"> </a>
<a name="ln2723">  // You're not supposed to understand this</a>
<a name="ln2724">  const float zoom_x = dt_control_get_dev_zoom_x ();</a>
<a name="ln2725">  const float zoom_y = dt_control_get_dev_zoom_y ();</a>
<a name="ln2726">  const float zoom_scale = get_zoom_scale (develop);</a>
<a name="ln2727"> </a>
<a name="ln2728">  // setup CAIRO coordinate system</a>
<a name="ln2729">  cairo_translate (cr, 0.5 * width, 0.5 * height); // origin @ center of view</a>
<a name="ln2730">  cairo_scale     (cr, zoom_scale, zoom_scale);    // the zoom</a>
<a name="ln2731">  cairo_translate (cr, -bb_width * (0.5 + zoom_x), -bb_height * (0.5 + zoom_y));</a>
<a name="ln2732">  cairo_scale (cr, scale, scale);</a>
<a name="ln2733"> </a>
<a name="ln2734">  draw_paths (module, cr, 1.0 / (scale * zoom_scale), &amp;copy_params);</a>
<a name="ln2735">}</a>
<a name="ln2736"> </a>
<a name="ln2737">void gui_focus (struct dt_iop_module_t *module, gboolean in)</a>
<a name="ln2738">{</a>
<a name="ln2739">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2740"> </a>
<a name="ln2741">  if (!in)</a>
<a name="ln2742">  {</a>
<a name="ln2743">    dt_control_hinter_message (darktable.control, &quot;&quot;);</a>
<a name="ln2744">    gtk_toggle_button_set_active (g-&gt;btn_point_tool, FALSE);</a>
<a name="ln2745">    gtk_toggle_button_set_active (g-&gt;btn_line_tool,  FALSE);</a>
<a name="ln2746">    gtk_toggle_button_set_active (g-&gt;btn_curve_tool, FALSE);</a>
<a name="ln2747">    gtk_toggle_button_set_active (g-&gt;btn_node_tool,  FALSE);</a>
<a name="ln2748">  }</a>
<a name="ln2749">}</a>
<a name="ln2750"> </a>
<a name="ln2751">static void sync_pipe (struct dt_iop_module_t *module, gboolean history)</a>
<a name="ln2752">{</a>
<a name="ln2753">  if (history)</a>
<a name="ln2754">  {</a>
<a name="ln2755">    const dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2756">    // something definitive has happened like button release ... so</a>
<a name="ln2757">    // redraw pipe</a>
<a name="ln2758">    memcpy(module-&gt;params, &amp;g-&gt;params, sizeof(dt_iop_liquify_params_t));</a>
<a name="ln2759">    dt_dev_add_history_item (darktable.develop, module, TRUE);</a>
<a name="ln2760">  }</a>
<a name="ln2761">  else</a>
<a name="ln2762">  {</a>
<a name="ln2763">    // only moving mouse around, pointing at things or dragging ... so</a>
<a name="ln2764">    // give some cairo feedback, but don't redraw pipe</a>
<a name="ln2765">    dt_control_queue_redraw_center ();</a>
<a name="ln2766">  }</a>
<a name="ln2767">}</a>
<a name="ln2768"> </a>
<a name="ln2769">/*</a>
<a name="ln2770">  right-click on node:       Delete node.</a>
<a name="ln2771">  right-click on path:       Delete whole path.</a>
<a name="ln2772"> </a>
<a name="ln2773">  ctrl+click on node:        Cycle symmetrical, smooth, cusp, autosmooth</a>
<a name="ln2774">  ctrl+click on path:        Add node</a>
<a name="ln2775">  ctrl+alt+click on path:    Change line / bezier</a>
<a name="ln2776"> </a>
<a name="ln2777">  ctrl+click on strength:    Cycle linear, grow, shrink</a>
<a name="ln2778">*/</a>
<a name="ln2779"> </a>
<a name="ln2780">static void get_point_scale(struct dt_iop_module_t *module, float x, float y, float complex *pt, float *scale)</a>
<a name="ln2781">{</a>
<a name="ln2782">  float pzx, pzy;</a>
<a name="ln2783">  dt_dev_get_pointer_zoom_pos(darktable.develop, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln2784">  pzx += 0.5f;</a>
<a name="ln2785">  pzy += 0.5f;</a>
<a name="ln2786">  const float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln2787">  const float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln2788">  float pts[2] = { pzx * wd, pzy * ht };</a>
<a name="ln2789">  dt_dev_distort_backtransform_plus(darktable.develop, darktable.develop-&gt;preview_pipe,</a>
<a name="ln2790">                                    module-&gt;iop_order,DT_DEV_TRANSFORM_DIR_FORW_EXCL, pts, 1);</a>
<a name="ln2791">  dt_dev_distort_backtransform_plus(darktable.develop, darktable.develop-&gt;preview_pipe,</a>
<a name="ln2792">                                    module-&gt;iop_order,DT_DEV_TRANSFORM_DIR_BACK_EXCL, pts, 1);</a>
<a name="ln2793">  const float nx = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln2794">  const float ny = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln2795"> </a>
<a name="ln2796">  *scale = darktable.develop-&gt;preview_pipe-&gt;iscale / get_zoom_scale(module-&gt;dev);</a>
<a name="ln2797">  *pt = (nx * darktable.develop-&gt;pipe-&gt;iwidth) +  (ny * darktable.develop-&gt;pipe-&gt;iheight) * I;</a>
<a name="ln2798">}</a>
<a name="ln2799"> </a>
<a name="ln2800">int mouse_moved (struct dt_iop_module_t *module,</a>
<a name="ln2801">                 double x,</a>
<a name="ln2802">                 double y,</a>
<a name="ln2803">                 double pressure,</a>
<a name="ln2804">                 int which)</a>
<a name="ln2805">{</a>
<a name="ln2806">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2807">  int handled = g-&gt;last_hit.elem ? 1 : 0;</a>
<a name="ln2808">  float complex pt;</a>
<a name="ln2809">  float scale;</a>
<a name="ln2810"> </a>
<a name="ln2811">  get_point_scale(module, x, y, &amp;pt, &amp;scale);</a>
<a name="ln2812"> </a>
<a name="ln2813">  dt_pthread_mutex_lock (&amp;g-&gt;lock);</a>
<a name="ln2814"> </a>
<a name="ln2815">  g-&gt;last_mouse_pos = pt;</a>
<a name="ln2816">  const int dragged = detect_drag (g, scale, pt);</a>
<a name="ln2817"> </a>
<a name="ln2818">  // Don't hit test while dragging, you'd only hit the dragged thing</a>
<a name="ln2819">  // anyway.</a>
<a name="ln2820"> </a>
<a name="ln2821">  if (!is_dragging(g))</a>
<a name="ln2822">  {</a>
<a name="ln2823">    dt_liquify_hit_t hit = hit_test_paths (module, scale, g-&gt;fake_cr, &amp;g-&gt;params, pt);</a>
<a name="ln2824">    dt_liquify_path_data_t *last_hovered = find_hovered (&amp;g-&gt;params);</a>
<a name="ln2825">    if (hit.elem != last_hovered ||</a>
<a name="ln2826">        (last_hovered &amp;&amp; hit.elem &amp;&amp; hit.elem-&gt;header.hovered != last_hovered-&gt;header.hovered))</a>
<a name="ln2827">    {</a>
<a name="ln2828">      if (hit.elem)</a>
<a name="ln2829">        hit.elem-&gt;header.hovered = hit.layer;</a>
<a name="ln2830">      if (last_hovered)</a>
<a name="ln2831">        last_hovered-&gt;header.hovered = 0;</a>
<a name="ln2832">      // change in hover display</a>
<a name="ln2833">      dt_control_hinter_message (darktable.control, dt_liquify_layers[hit.layer].hint);</a>
<a name="ln2834">      handled = 1;</a>
<a name="ln2835">      goto done;</a>
<a name="ln2836">    }</a>
<a name="ln2837">  }</a>
<a name="ln2838"> </a>
<a name="ln2839">  if (dragged &amp;&amp; !is_dragging(g) &amp;&amp; g-&gt;last_hit.elem)</a>
<a name="ln2840">  {</a>
<a name="ln2841">    // start dragging</a>
<a name="ln2842">    start_drag (g, g-&gt;last_hit.layer, g-&gt;last_hit.elem);</a>
<a name="ln2843">  }</a>
<a name="ln2844"> </a>
<a name="ln2845">  if (is_dragging(g))</a>
<a name="ln2846">  {</a>
<a name="ln2847">    dt_liquify_path_data_t *d = g-&gt;dragging.elem;</a>
<a name="ln2848">    dt_liquify_path_data_t *n = node_next(&amp;g-&gt;params, d);</a>
<a name="ln2849">    dt_liquify_path_data_t *p = node_prev(&amp;g-&gt;params, d);</a>
<a name="ln2850"> </a>
<a name="ln2851">    const float complex *start_pt = &amp;d-&gt;warp.point;</a>
<a name="ln2852"> </a>
<a name="ln2853">    switch (g-&gt;dragging.layer)</a>
<a name="ln2854">    {</a>
<a name="ln2855">       case DT_LIQUIFY_LAYER_CENTERPOINT:</a>
<a name="ln2856">         switch (d-&gt;header.type)</a>
<a name="ln2857">         {</a>
<a name="ln2858">            case DT_LIQUIFY_PATH_CURVE_TO_V1:</a>
<a name="ln2859">              d-&gt;node.ctrl2 += pt - d-&gt;warp.point;</a>
<a name="ln2860">              // fall thru</a>
<a name="ln2861">            case DT_LIQUIFY_PATH_MOVE_TO_V1:</a>
<a name="ln2862">            case DT_LIQUIFY_PATH_LINE_TO_V1:</a>
<a name="ln2863">              if (n &amp;&amp; n-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2864">                n-&gt;node.ctrl1 += pt - d-&gt;warp.point;</a>
<a name="ln2865">              if (p &amp;&amp; p-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2866">                p-&gt;node.ctrl2 += pt - d-&gt;warp.point;</a>
<a name="ln2867">              d-&gt;warp.radius   += pt - d-&gt;warp.point;</a>
<a name="ln2868">              d-&gt;warp.strength += pt - d-&gt;warp.point;</a>
<a name="ln2869">              d-&gt;warp.point = pt;</a>
<a name="ln2870">              break;</a>
<a name="ln2871">            default:</a>
<a name="ln2872">              break;</a>
<a name="ln2873">         }</a>
<a name="ln2874">         break;</a>
<a name="ln2875"> </a>
<a name="ln2876">       case DT_LIQUIFY_LAYER_CTRLPOINT1:</a>
<a name="ln2877">         switch (d-&gt;header.type)</a>
<a name="ln2878">         {</a>
<a name="ln2879">            case DT_LIQUIFY_PATH_CURVE_TO_V1:</a>
<a name="ln2880">              d-&gt;node.ctrl1 = pt;</a>
<a name="ln2881">              if (p &amp;&amp; p-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2882">              {</a>
<a name="ln2883">                switch (p-&gt;header.node_type)</a>
<a name="ln2884">                {</a>
<a name="ln2885">                   case DT_LIQUIFY_NODE_TYPE_SMOOTH:</a>
<a name="ln2886">                     p-&gt;node.ctrl2 = p-&gt;warp.point +</a>
<a name="ln2887">                       cabs (p-&gt;warp.point - p-&gt;node.ctrl2) *</a>
<a name="ln2888">                       cexp (carg (p-&gt;warp.point - pt) * I);</a>
<a name="ln2889">                     break;</a>
<a name="ln2890">                case DT_LIQUIFY_NODE_TYPE_SYMMETRICAL:</a>
<a name="ln2891">                  p-&gt;node.ctrl2 = 2 * p-&gt;warp.point - pt;</a>
<a name="ln2892">                  break;</a>
<a name="ln2893">                default:</a>
<a name="ln2894">                  break;</a>
<a name="ln2895">                }</a>
<a name="ln2896">              }</a>
<a name="ln2897">              break;</a>
<a name="ln2898">            default:</a>
<a name="ln2899">              break;</a>
<a name="ln2900">         }</a>
<a name="ln2901">         break;</a>
<a name="ln2902"> </a>
<a name="ln2903">       case DT_LIQUIFY_LAYER_CTRLPOINT2:</a>
<a name="ln2904">         switch (d-&gt;header.type)</a>
<a name="ln2905">         {</a>
<a name="ln2906">            case DT_LIQUIFY_PATH_CURVE_TO_V1:</a>
<a name="ln2907">              d-&gt;node.ctrl2 = pt;</a>
<a name="ln2908">              if (n &amp;&amp; n-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2909">              {</a>
<a name="ln2910">                switch (d-&gt;header.node_type)</a>
<a name="ln2911">                {</a>
<a name="ln2912">                   case DT_LIQUIFY_NODE_TYPE_SMOOTH:</a>
<a name="ln2913">                     n-&gt;node.ctrl1 = d-&gt;warp.point +</a>
<a name="ln2914">                       cabs (d-&gt;warp.point - n-&gt;node.ctrl1) *</a>
<a name="ln2915">                       cexp (carg (d-&gt;warp.point - pt) * I);</a>
<a name="ln2916">                     break;</a>
<a name="ln2917">                   case DT_LIQUIFY_NODE_TYPE_SYMMETRICAL:</a>
<a name="ln2918">                     n-&gt;node.ctrl1 = 2 * d-&gt;warp.point - pt;</a>
<a name="ln2919">                     break;</a>
<a name="ln2920">                   default:</a>
<a name="ln2921">                     break;</a>
<a name="ln2922">                }</a>
<a name="ln2923">              }</a>
<a name="ln2924">              break;</a>
<a name="ln2925">            default:</a>
<a name="ln2926">              break;</a>
<a name="ln2927">         }</a>
<a name="ln2928">         break;</a>
<a name="ln2929"> </a>
<a name="ln2930">       case DT_LIQUIFY_LAYER_RADIUSPOINT:</a>
<a name="ln2931">         d-&gt;warp.radius = pt;</a>
<a name="ln2932">         dt_conf_set_float(CONF_RADIUS, cabs(d-&gt;warp.radius - d-&gt;warp.point));</a>
<a name="ln2933">         break;</a>
<a name="ln2934"> </a>
<a name="ln2935">       case DT_LIQUIFY_LAYER_STRENGTHPOINT:</a>
<a name="ln2936">         d-&gt;warp.strength = pt;</a>
<a name="ln2937">         dt_conf_set_float(CONF_STRENGTH, cabs(d-&gt;warp.strength - d-&gt;warp.point));</a>
<a name="ln2938">         dt_conf_set_float(CONF_ANGLE, carg(d-&gt;warp.strength - d-&gt;warp.point));</a>
<a name="ln2939">         break;</a>
<a name="ln2940"> </a>
<a name="ln2941">       case DT_LIQUIFY_LAYER_HARDNESSPOINT1:</a>
<a name="ln2942">         d-&gt;warp.control1 = MIN (1.0, cabs (pt - *start_pt) / cabs (d-&gt;warp.radius - *start_pt));</a>
<a name="ln2943">         break;</a>
<a name="ln2944"> </a>
<a name="ln2945">       case DT_LIQUIFY_LAYER_HARDNESSPOINT2:</a>
<a name="ln2946">         d-&gt;warp.control2 = MIN (1.0, cabs (pt - *start_pt) / cabs (d-&gt;warp.radius - *start_pt));</a>
<a name="ln2947">         break;</a>
<a name="ln2948"> </a>
<a name="ln2949">       default:</a>
<a name="ln2950">         break;</a>
<a name="ln2951">    }</a>
<a name="ln2952">    handled = 1;</a>
<a name="ln2953">  }</a>
<a name="ln2954"> </a>
<a name="ln2955">done:</a>
<a name="ln2956">  dt_pthread_mutex_unlock (&amp;g-&gt;lock);</a>
<a name="ln2957">  if (handled)</a>
<a name="ln2958">  {</a>
<a name="ln2959">    sync_pipe (module, handled == 2);</a>
<a name="ln2960">  }</a>
<a name="ln2961">  return handled;</a>
<a name="ln2962">}</a>
<a name="ln2963"> </a>
<a name="ln2964">/*</a>
<a name="ln2965">  add support for changing the radius and the strength vector for the temp node</a>
<a name="ln2966"> */</a>
<a name="ln2967">int scrolled(struct dt_iop_module_t *module, double x, double y, int up, uint32_t state)</a>
<a name="ln2968">{</a>
<a name="ln2969">  const dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2970"> </a>
<a name="ln2971">  // add an option to allow skip mouse events while editing masks</a>
<a name="ln2972">  if(darktable.develop-&gt;darkroom_skip_mouse_events) return 0;</a>
<a name="ln2973"> </a>
<a name="ln2974">  if (g-&gt;temp)</a>
<a name="ln2975">  {</a>
<a name="ln2976">    dt_liquify_warp_t *warp = &amp;g-&gt;temp-&gt;warp;</a>
<a name="ln2977">    const float complex strength_v = warp-&gt;strength - warp-&gt;point;</a>
<a name="ln2978"> </a>
<a name="ln2979">    if (state == 0)</a>
<a name="ln2980">    {</a>
<a name="ln2981">      //  change size</a>
<a name="ln2982">      float radius = dt_conf_get_float(CONF_RADIUS);</a>
<a name="ln2983">      const float phi = carg(strength_v);</a>
<a name="ln2984">      float r = cabs(strength_v);</a>
<a name="ln2985">      float factor = 1.0f;</a>
<a name="ln2986"> </a>
<a name="ln2987">      if(up &amp;&amp; cabs(warp-&gt;radius - warp-&gt;point) &gt; 10.0f)</a>
<a name="ln2988">        factor *= 0.97f;</a>
<a name="ln2989">      else if(!up)</a>
<a name="ln2990">        factor *= 1.0f / 0.97f;</a>
<a name="ln2991"> </a>
<a name="ln2992">      r *= factor;</a>
<a name="ln2993">      radius *= factor;</a>
<a name="ln2994"> </a>
<a name="ln2995">      warp-&gt;radius = warp-&gt;point + (radius * factor);</a>
<a name="ln2996">      warp-&gt;strength = warp-&gt;point + r * cexp (phi * I);</a>
<a name="ln2997"> </a>
<a name="ln2998">      dt_conf_set_float(CONF_RADIUS, radius);</a>
<a name="ln2999">      dt_conf_set_float(CONF_STRENGTH, r);</a>
<a name="ln3000">      return 1;</a>
<a name="ln3001">    }</a>
<a name="ln3002">    else if (state &amp; GDK_CONTROL_MASK)</a>
<a name="ln3003">    {</a>
<a name="ln3004">      //  change the strength direction</a>
<a name="ln3005">      float phi = carg(strength_v);</a>
<a name="ln3006">      const float r = cabs(strength_v);</a>
<a name="ln3007"> </a>
<a name="ln3008">      if(up)</a>
<a name="ln3009">        phi += M_PI / 16.0f;</a>
<a name="ln3010">      else</a>
<a name="ln3011">        phi -= M_PI / 16.0f;</a>
<a name="ln3012"> </a>
<a name="ln3013">      warp-&gt;strength = warp-&gt;point + r * cexp (phi * I);</a>
<a name="ln3014">      dt_conf_set_float(CONF_STRENGTH, r);</a>
<a name="ln3015">      dt_conf_set_float(CONF_ANGLE, phi);</a>
<a name="ln3016">      return 1;</a>
<a name="ln3017">    }</a>
<a name="ln3018">    else if (state &amp; GDK_SHIFT_MASK)</a>
<a name="ln3019">    {</a>
<a name="ln3020">      //  change the strength</a>
<a name="ln3021">      const float phi = carg(strength_v);</a>
<a name="ln3022">      float r = cabs(strength_v);</a>
<a name="ln3023"> </a>
<a name="ln3024">      if(up)</a>
<a name="ln3025">        r *= 0.97f;</a>
<a name="ln3026">      else</a>
<a name="ln3027">        r *= 1.0f / 0.97f;</a>
<a name="ln3028"> </a>
<a name="ln3029">      warp-&gt;strength = warp-&gt;point + r * cexp (phi * I);</a>
<a name="ln3030">      dt_conf_set_float(CONF_STRENGTH, r);</a>
<a name="ln3031">      dt_conf_set_float(CONF_ANGLE, phi);</a>
<a name="ln3032">      return 1;</a>
<a name="ln3033">    }</a>
<a name="ln3034">  }</a>
<a name="ln3035"> </a>
<a name="ln3036">  return 0;</a>
<a name="ln3037">}</a>
<a name="ln3038"> </a>
<a name="ln3039">int button_pressed (struct dt_iop_module_t *module,</a>
<a name="ln3040">                    double x,</a>
<a name="ln3041">                    double y,</a>
<a name="ln3042">                    double pressure,</a>
<a name="ln3043">                    int which,</a>
<a name="ln3044">                    int type,</a>
<a name="ln3045">                    uint32_t state)</a>
<a name="ln3046">{</a>
<a name="ln3047">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3048">  int handled = 0;</a>
<a name="ln3049">  float complex pt;</a>
<a name="ln3050">  float scale;</a>
<a name="ln3051"> </a>
<a name="ln3052">  get_point_scale(module, x, y, &amp;pt, &amp;scale);</a>
<a name="ln3053"> </a>
<a name="ln3054">  dt_pthread_mutex_lock (&amp;g-&gt;lock);</a>
<a name="ln3055"> </a>
<a name="ln3056">  g-&gt;last_mouse_pos = pt;</a>
<a name="ln3057">  g-&gt;last_mouse_mods = state &amp; gtk_accelerator_get_default_mod_mask ();</a>
<a name="ln3058">  if (which == 1)</a>
<a name="ln3059">    g-&gt;last_button1_pressed_pos = pt;</a>
<a name="ln3060"> </a>
<a name="ln3061">  if (!is_dragging(g))</a>
<a name="ln3062">    // while dragging you would always hit the dragged thing</a>
<a name="ln3063">    g-&gt;last_hit = hit_test_paths (module, scale, g-&gt;fake_cr, &amp;g-&gt;params, pt);</a>
<a name="ln3064"> </a>
<a name="ln3065">  if (which == 2) goto done;</a>
<a name="ln3066"> </a>
<a name="ln3067">  // Point tool</a>
<a name="ln3068"> </a>
<a name="ln3069">  if (which == 1 &amp;&amp; gtk_toggle_button_get_active (g-&gt;btn_point_tool))</a>
<a name="ln3070">  {</a>
<a name="ln3071">    // always end dragging before manipulating the path list to avoid</a>
<a name="ln3072">    // dangling pointers</a>
<a name="ln3073">    end_drag (g);</a>
<a name="ln3074"> </a>
<a name="ln3075">    if (!g-&gt;temp) goto done;</a>
<a name="ln3076">    g-&gt;status |= DT_LIQUIFY_STATUS_NEW;</a>
<a name="ln3077">    g-&gt;status &amp;= ~DT_LIQUIFY_STATUS_PREVIEW;</a>
<a name="ln3078"> </a>
<a name="ln3079">    start_drag (g, DT_LIQUIFY_LAYER_STRENGTHPOINT, g-&gt;temp);</a>
<a name="ln3080">    g-&gt;last_hit = NOWHERE;</a>
<a name="ln3081">    handled = 1;</a>
<a name="ln3082">    goto done;</a>
<a name="ln3083">  }</a>
<a name="ln3084"> </a>
<a name="ln3085">  // Line tool or curve tool</a>
<a name="ln3086"> </a>
<a name="ln3087">  if (which == 1 &amp;&amp; (gtk_toggle_button_get_active (g-&gt;btn_line_tool)</a>
<a name="ln3088">                     || gtk_toggle_button_get_active (g-&gt;btn_curve_tool)))</a>
<a name="ln3089">  {</a>
<a name="ln3090">    // always end dragging before manipulating the path list to avoid</a>
<a name="ln3091">    // dangling pointers</a>
<a name="ln3092">    end_drag (g);</a>
<a name="ln3093">    if (!g-&gt;temp)</a>
<a name="ln3094">    {</a>
<a name="ln3095">      if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_CENTERPOINT)</a>
<a name="ln3096">      {</a>
<a name="ln3097">        // continue path</a>
<a name="ln3098">        g-&gt;temp = g-&gt;last_hit.elem;</a>
<a name="ln3099">      }</a>
<a name="ln3100">      else</a>
<a name="ln3101">      {</a>
<a name="ln3102">        if (!g-&gt;temp) goto done;</a>
<a name="ln3103">      }</a>
<a name="ln3104">    }</a>
<a name="ln3105">    g-&gt;last_hit = NOWHERE;</a>
<a name="ln3106">    if (gtk_toggle_button_get_active (g-&gt;btn_curve_tool))</a>
<a name="ln3107">    {</a>
<a name="ln3108">      start_drag (g, DT_LIQUIFY_LAYER_CTRLPOINT1, g-&gt;temp);</a>
<a name="ln3109">    }</a>
<a name="ln3110">    g-&gt;status |= DT_LIQUIFY_STATUS_NEW;</a>
<a name="ln3111">    g-&gt;status &amp;= ~DT_LIQUIFY_STATUS_PREVIEW;</a>
<a name="ln3112">    handled = 1;</a>
<a name="ln3113">    goto done;</a>
<a name="ln3114">  }</a>
<a name="ln3115"> </a>
<a name="ln3116">  // Node tool</a>
<a name="ln3117"> </a>
<a name="ln3118">  if (gtk_toggle_button_get_active (g-&gt;btn_node_tool))</a>
<a name="ln3119">  {</a>
<a name="ln3120">    if (which == 1 &amp;&amp; (g-&gt;last_mouse_mods == GDK_CONTROL_MASK) &amp;&amp;</a>
<a name="ln3121">        (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_CENTERPOINT))</a>
<a name="ln3122">    {</a>
<a name="ln3123">      // cycle node type: smooth -&gt; cusp etc.</a>
<a name="ln3124">      dt_liquify_path_data_t *node = g-&gt;last_hit.elem;</a>
<a name="ln3125">      node-&gt;header.node_type = (node-&gt;header.node_type + 1) % DT_LIQUIFY_NODE_TYPE_LAST;</a>
<a name="ln3126">      handled = 1;</a>
<a name="ln3127">      goto done;</a>
<a name="ln3128">    }</a>
<a name="ln3129">    if (which == 1 &amp;&amp; (g-&gt;last_mouse_mods == GDK_CONTROL_MASK) &amp;&amp;</a>
<a name="ln3130">        (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_STRENGTHPOINT))</a>
<a name="ln3131">    {</a>
<a name="ln3132">      // cycle warp type: linear -&gt; radial etc.</a>
<a name="ln3133">      if (g-&gt;last_hit.elem-&gt;header.type == DT_LIQUIFY_PATH_MOVE_TO_V1)</a>
<a name="ln3134">      {</a>
<a name="ln3135">        dt_liquify_warp_t *warp = &amp;g-&gt;last_hit.elem-&gt;warp;</a>
<a name="ln3136">        warp-&gt;type = (warp-&gt;type + 1) % DT_LIQUIFY_WARP_TYPE_LAST;</a>
<a name="ln3137">      }</a>
<a name="ln3138">      handled = 1;</a>
<a name="ln3139">      goto done;</a>
<a name="ln3140">    }</a>
<a name="ln3141">  }</a>
<a name="ln3142"> </a>
<a name="ln3143">done:</a>
<a name="ln3144">  dt_pthread_mutex_unlock (&amp;g-&gt;lock);</a>
<a name="ln3145">  if (handled)</a>
<a name="ln3146">    sync_pipe (module, TRUE);</a>
<a name="ln3147">  return handled;</a>
<a name="ln3148">}</a>
<a name="ln3149"> </a>
<a name="ln3150">int button_released (struct dt_iop_module_t *module,</a>
<a name="ln3151">                     double x,</a>
<a name="ln3152">                     double y,</a>
<a name="ln3153">                     int which,</a>
<a name="ln3154">                     uint32_t state)</a>
<a name="ln3155">{</a>
<a name="ln3156">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3157">  int handled = 0;</a>
<a name="ln3158">  float complex pt;</a>
<a name="ln3159">  float scale;</a>
<a name="ln3160"> </a>
<a name="ln3161">  get_point_scale(module, x, y, &amp;pt, &amp;scale);</a>
<a name="ln3162"> </a>
<a name="ln3163">  dt_pthread_mutex_lock (&amp;g-&gt;lock);</a>
<a name="ln3164"> </a>
<a name="ln3165">  g-&gt;last_mouse_pos = pt;</a>
<a name="ln3166"> </a>
<a name="ln3167">  const gboolean dragged = detect_drag (g, scale, pt);</a>
<a name="ln3168"> </a>
<a name="ln3169">  if (which == 1 &amp;&amp; g-&gt;temp &amp;&amp; (g-&gt;status &amp; DT_LIQUIFY_STATUS_NEW))</a>
<a name="ln3170">  {</a>
<a name="ln3171">    end_drag (g);</a>
<a name="ln3172">    if (gtk_toggle_button_get_active (g-&gt;btn_point_tool))</a>
<a name="ln3173">    {</a>
<a name="ln3174">      g-&gt;temp = NULL; // a point is done</a>
<a name="ln3175">      gtk_toggle_button_set_active (g-&gt;btn_node_tool, 1);</a>
<a name="ln3176">      handled = dragged ? 2 : 1;</a>
<a name="ln3177">    }</a>
<a name="ln3178">    else if (gtk_toggle_button_get_active (g-&gt;btn_line_tool))</a>
<a name="ln3179">    {</a>
<a name="ln3180">      const int prev_index = g-&gt;node_index;</a>
<a name="ln3181">      const float complex strength = (g-&gt;temp-&gt;warp.strength - g-&gt;temp-&gt;warp.point);</a>
<a name="ln3182">      const float radius = cabs(g-&gt;temp-&gt;warp.radius - g-&gt;temp-&gt;warp.point);</a>
<a name="ln3183">      g-&gt;temp = alloc_line_to (module, pt);</a>
<a name="ln3184">      if (!g-&gt;temp) goto done;</a>
<a name="ln3185">      g-&gt;temp-&gt;warp.radius   = pt + radius;</a>
<a name="ln3186">      g-&gt;temp-&gt;warp.strength = pt + strength;</a>
<a name="ln3187">      // links</a>
<a name="ln3188">      g-&gt;temp-&gt;header.prev = prev_index;</a>
<a name="ln3189">      node_get(&amp;g-&gt;params, prev_index)-&gt;header.next = g-&gt;node_index;</a>
<a name="ln3190">      start_drag (g, DT_LIQUIFY_LAYER_CENTERPOINT, g-&gt;temp);</a>
<a name="ln3191">      handled = 1;</a>
<a name="ln3192">    }</a>
<a name="ln3193">    else if (gtk_toggle_button_get_active (g-&gt;btn_curve_tool))</a>
<a name="ln3194">    {</a>
<a name="ln3195">      const int prev_index = g-&gt;node_index;</a>
<a name="ln3196">      const float complex strength = (g-&gt;temp-&gt;warp.strength - g-&gt;temp-&gt;warp.point);</a>
<a name="ln3197">      const float radius = cabs(g-&gt;temp-&gt;warp.radius - g-&gt;temp-&gt;warp.point);</a>
<a name="ln3198">      g-&gt;temp = alloc_curve_to (module, pt);</a>
<a name="ln3199">      if (!g-&gt;temp) goto done;</a>
<a name="ln3200">      // user dragged, make it a symmetrical node</a>
<a name="ln3201">      if (dragged)</a>
<a name="ln3202">      {</a>
<a name="ln3203">        g-&gt;temp-&gt;header.node_type = DT_LIQUIFY_NODE_TYPE_SYMMETRICAL;</a>
<a name="ln3204">      }</a>
<a name="ln3205">      g-&gt;temp-&gt;warp.radius = pt + radius;</a>
<a name="ln3206">      g-&gt;temp-&gt;warp.strength = pt + strength;</a>
<a name="ln3207">      // links</a>
<a name="ln3208">      g-&gt;temp-&gt;header.prev = prev_index;</a>
<a name="ln3209">      node_get(&amp;g-&gt;params, prev_index)-&gt;header.next = g-&gt;node_index;</a>
<a name="ln3210">      start_drag (g, DT_LIQUIFY_LAYER_CENTERPOINT, g-&gt;temp);</a>
<a name="ln3211">      handled = 1;</a>
<a name="ln3212">    }</a>
<a name="ln3213">    g-&gt;status &amp;= ~DT_LIQUIFY_STATUS_NEW;</a>
<a name="ln3214">    goto done;</a>
<a name="ln3215">  }</a>
<a name="ln3216"> </a>
<a name="ln3217">  if (which == 1 &amp;&amp; is_dragging(g))</a>
<a name="ln3218">  {</a>
<a name="ln3219">    end_drag (g);</a>
<a name="ln3220">    handled = 2;</a>
<a name="ln3221">    goto done;</a>
<a name="ln3222">  }</a>
<a name="ln3223"> </a>
<a name="ln3224">  // right click == cancel or delete</a>
<a name="ln3225">  if (which == 3)</a>
<a name="ln3226">  {</a>
<a name="ln3227">    dt_control_hinter_message (darktable.control, &quot;&quot;);</a>
<a name="ln3228">    end_drag (g);</a>
<a name="ln3229"> </a>
<a name="ln3230">    // cancel line or curve creation</a>
<a name="ln3231">    if (g-&gt;temp)</a>
<a name="ln3232">    {</a>
<a name="ln3233">      node_delete (&amp;g-&gt;params, g-&gt;temp);</a>
<a name="ln3234">      g-&gt;temp = NULL;</a>
<a name="ln3235">      g-&gt;status &amp;= ~DT_LIQUIFY_STATUS_PREVIEW;</a>
<a name="ln3236">      gtk_toggle_button_set_active (g-&gt;btn_node_tool, 1);</a>
<a name="ln3237">      handled = 2;</a>
<a name="ln3238">      goto done;</a>
<a name="ln3239">    }</a>
<a name="ln3240"> </a>
<a name="ln3241">    // right click on background toggles node tool</a>
<a name="ln3242">    if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_BACKGROUND)</a>
<a name="ln3243">    {</a>
<a name="ln3244">      gtk_toggle_button_set_active (g-&gt;btn_node_tool,</a>
<a name="ln3245">                                    !gtk_toggle_button_get_active (g-&gt;btn_node_tool));</a>
<a name="ln3246">      handled = 1;</a>
<a name="ln3247">      goto done;</a>
<a name="ln3248">    }</a>
<a name="ln3249"> </a>
<a name="ln3250">    // delete node</a>
<a name="ln3251">    if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_CENTERPOINT)</a>
<a name="ln3252">    {</a>
<a name="ln3253">      node_delete (&amp;g-&gt;params, g-&gt;last_hit.elem);</a>
<a name="ln3254">      g-&gt;last_hit = NOWHERE;</a>
<a name="ln3255">      handled = 2;</a>
<a name="ln3256">      goto done;</a>
<a name="ln3257">    }</a>
<a name="ln3258">    // delete shape</a>
<a name="ln3259">    if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_PATH)</a>
<a name="ln3260">    {</a>
<a name="ln3261">      path_delete (&amp;g-&gt;params, g-&gt;last_hit.elem);</a>
<a name="ln3262">      g-&gt;last_hit = NOWHERE;</a>
<a name="ln3263">      handled = 2;</a>
<a name="ln3264">      goto done;</a>
<a name="ln3265">    }</a>
<a name="ln3266">    goto done;</a>
<a name="ln3267">  }</a>
<a name="ln3268"> </a>
<a name="ln3269">  // Node tool</a>
<a name="ln3270"> </a>
<a name="ln3271">  if (gtk_toggle_button_get_active (g-&gt;btn_node_tool))</a>
<a name="ln3272">  {</a>
<a name="ln3273">    if (which == 1 &amp;&amp; g-&gt;last_mouse_mods == 0 &amp;&amp; !dragged)</a>
<a name="ln3274">    {</a>
<a name="ln3275">      // select/unselect start/endpoint and clear previous selections</a>
<a name="ln3276">      if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_CENTERPOINT)</a>
<a name="ln3277">      {</a>
<a name="ln3278">        const int oldsel = !!g-&gt;last_hit.elem-&gt;header.selected;</a>
<a name="ln3279">  unselect_all (&amp;g-&gt;params);</a>
<a name="ln3280">        g-&gt;last_hit.elem-&gt;header.selected = oldsel ? 0 : g-&gt;last_hit.layer;</a>
<a name="ln3281">        handled = 1;</a>
<a name="ln3282">        goto done;</a>
<a name="ln3283">      }</a>
<a name="ln3284">      // unselect all</a>
<a name="ln3285">      if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_BACKGROUND)</a>
<a name="ln3286">      {</a>
<a name="ln3287">        unselect_all (&amp;g-&gt;params);</a>
<a name="ln3288">        handled = 1;</a>
<a name="ln3289">        goto done;</a>
<a name="ln3290">      }</a>
<a name="ln3291">    }</a>
<a name="ln3292">    if (which == 1 &amp;&amp; g-&gt;last_mouse_mods == GDK_SHIFT_MASK &amp;&amp; !dragged)</a>
<a name="ln3293">    {</a>
<a name="ln3294">      // select/unselect start/endpoint and keep previous selections</a>
<a name="ln3295">      if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_CENTERPOINT)</a>
<a name="ln3296">      {</a>
<a name="ln3297">        const int oldsel = !!g-&gt;last_hit.elem-&gt;header.selected;</a>
<a name="ln3298">        g-&gt;last_hit.elem-&gt;header.selected = oldsel ? 0 : g-&gt;last_hit.layer;</a>
<a name="ln3299">        handled = 1;</a>
<a name="ln3300">        goto done;</a>
<a name="ln3301">      }</a>
<a name="ln3302">    }</a>
<a name="ln3303">    if (which == 1 &amp;&amp; (g-&gt;last_mouse_mods == GDK_CONTROL_MASK) &amp;&amp; !dragged)</a>
<a name="ln3304">    {</a>
<a name="ln3305">      // add node</a>
<a name="ln3306">      if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_PATH)</a>
<a name="ln3307">      {</a>
<a name="ln3308">        dt_liquify_path_data_t *e = g-&gt;last_hit.elem;</a>
<a name="ln3309">        dt_liquify_path_data_t *prev = node_prev (&amp;g-&gt;params, e);</a>
<a name="ln3310">        if (prev &amp;&amp; e-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln3311">        {</a>
<a name="ln3312">    // add node to curve</a>
<a name="ln3313">          dt_liquify_path_data_t *curve1 = (dt_liquify_path_data_t *) e;</a>
<a name="ln3314"> </a>
<a name="ln3315">          dt_liquify_path_data_t *curve2 = (dt_liquify_path_data_t *)alloc_curve_to (module, 0);</a>
<a name="ln3316">          if (!curve2) goto done;</a>
<a name="ln3317"> </a>
<a name="ln3318">          curve2-&gt;node.ctrl1 = curve1-&gt;node.ctrl1;</a>
<a name="ln3319">          curve2-&gt;node.ctrl2 = curve1-&gt;node.ctrl2;</a>
<a name="ln3320"> </a>
<a name="ln3321">          dt_liquify_warp_t *warp1 = &amp;prev-&gt;warp;</a>
<a name="ln3322">          dt_liquify_warp_t *warp2 = &amp;curve2-&gt;warp;</a>
<a name="ln3323">          dt_liquify_warp_t *warp3 = &amp;e-&gt;warp;</a>
<a name="ln3324"> </a>
<a name="ln3325">          const float t = find_nearest_on_curve_t (warp1-&gt;point, curve1-&gt;node.ctrl1, curve1-&gt;node.ctrl2,</a>
<a name="ln3326">                                                   warp3-&gt;point, pt, INTERPOLATION_POINTS);</a>
<a name="ln3327"> </a>
<a name="ln3328">          float complex midpoint = warp3-&gt;point;</a>
<a name="ln3329">          casteljau (&amp;warp1-&gt;point, &amp;curve1-&gt;node.ctrl1, &amp;curve1-&gt;node.ctrl2, &amp;midpoint, t);</a>
<a name="ln3330">          midpoint = warp1-&gt;point;</a>
<a name="ln3331">          casteljau (&amp;warp3-&gt;point, &amp;curve2-&gt;node.ctrl2, &amp;curve2-&gt;node.ctrl1, &amp;midpoint, 1.0 - t);</a>
<a name="ln3332"> </a>
<a name="ln3333">          mix_warps (warp2, warp1, warp3, midpoint, t);</a>
<a name="ln3334"> </a>
<a name="ln3335">          node_insert_before (&amp;g-&gt;params, e, (dt_liquify_path_data_t *)curve2);</a>
<a name="ln3336"> </a>
<a name="ln3337">          handled = 2;</a>
<a name="ln3338">          goto done;</a>
<a name="ln3339">        }</a>
<a name="ln3340">        if (prev &amp;&amp; e-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1)</a>
<a name="ln3341">        {</a>
<a name="ln3342">    // add node to line</a>
<a name="ln3343">          dt_liquify_warp_t *warp1 = &amp;prev-&gt;warp;</a>
<a name="ln3344">          dt_liquify_warp_t *warp3 = &amp;e-&gt;warp;</a>
<a name="ln3345">          const float t = find_nearest_on_line_t (warp1-&gt;point, warp3-&gt;point, pt);</a>
<a name="ln3346"> </a>
<a name="ln3347">          dt_liquify_path_data_t *tmp = alloc_line_to (module, e-&gt;warp.point);</a>
<a name="ln3348">          if (!tmp) goto done;</a>
<a name="ln3349"> </a>
<a name="ln3350">          dt_liquify_warp_t *warp2 = &amp;tmp-&gt;warp;</a>
<a name="ln3351">          double complex midpoint = cmix (warp1-&gt;point, warp3-&gt;point, t);</a>
<a name="ln3352"> </a>
<a name="ln3353">          mix_warps (warp2, warp1, warp3, midpoint, t);</a>
<a name="ln3354">          node_insert_before (&amp;g-&gt;params, e, tmp);</a>
<a name="ln3355"> </a>
<a name="ln3356">          handled = 2;</a>
<a name="ln3357">          goto done;</a>
<a name="ln3358">        }</a>
<a name="ln3359">      }</a>
<a name="ln3360">    }</a>
<a name="ln3361">    if (which == 1</a>
<a name="ln3362">        &amp;&amp; (g-&gt;last_mouse_mods == (GDK_MOD1_MASK | GDK_CONTROL_MASK))</a>
<a name="ln3363">        &amp;&amp; !dragged)</a>
<a name="ln3364">    {</a>
<a name="ln3365">      if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_PATH)</a>
<a name="ln3366">      {</a>
<a name="ln3367">        // change segment</a>
<a name="ln3368">        dt_liquify_path_data_t *e = g-&gt;last_hit.elem;</a>
<a name="ln3369">        dt_liquify_path_data_t *prev = node_prev (&amp;g-&gt;params, e);</a>
<a name="ln3370">        if (prev &amp;&amp; e-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln3371">        {</a>
<a name="ln3372">          // curve -&gt; line</a>
<a name="ln3373">          e-&gt;header.type = DT_LIQUIFY_PATH_LINE_TO_V1;</a>
<a name="ln3374">          e-&gt;header.node_type = DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln3375">          e-&gt;header.selected = e-&gt;header.hovered = 0;</a>
<a name="ln3376">          handled = 2;</a>
<a name="ln3377">          goto done;</a>
<a name="ln3378">        }</a>
<a name="ln3379">        if (prev &amp;&amp; e-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1)</a>
<a name="ln3380">        {</a>
<a name="ln3381">          // line -&gt; curve</a>
<a name="ln3382">          const float complex p0 = prev-&gt;warp.point;</a>
<a name="ln3383">          const float complex p1 = e-&gt;warp.point;</a>
<a name="ln3384">          dt_liquify_path_data_t *c = (dt_liquify_path_data_t *)e;</a>
<a name="ln3385">          e-&gt;header.type = DT_LIQUIFY_PATH_CURVE_TO_V1;</a>
<a name="ln3386">          e-&gt;header.node_type = DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln3387">          c-&gt;node.ctrl1 = (2 * p0 +     p1) / 3.0;</a>
<a name="ln3388">          c-&gt;node.ctrl2 = (    p0 + 2 * p1) / 3.0;</a>
<a name="ln3389"> </a>
<a name="ln3390">          handled = 2;</a>
<a name="ln3391">          goto done;</a>
<a name="ln3392">        }</a>
<a name="ln3393">      }</a>
<a name="ln3394">    }</a>
<a name="ln3395">  }</a>
<a name="ln3396"> </a>
<a name="ln3397">done:</a>
<a name="ln3398">  if (which == 1)</a>
<a name="ln3399">    g-&gt;last_button1_pressed_pos = -1;</a>
<a name="ln3400">  g-&gt;last_hit = NOWHERE;</a>
<a name="ln3401">  dt_pthread_mutex_unlock (&amp;g-&gt;lock);</a>
<a name="ln3402">  if (handled)</a>
<a name="ln3403">  {</a>
<a name="ln3404">    update_warp_count (g);</a>
<a name="ln3405">    sync_pipe (module, handled == 2);</a>
<a name="ln3406">  }</a>
<a name="ln3407">  return handled;</a>
<a name="ln3408">}</a>
<a name="ln3409"> </a>
<a name="ln3410">static void _liquify_cairo_paint_point_tool(cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3411">                                            const gint flags, void *data);</a>
<a name="ln3412"> </a>
<a name="ln3413">static void _liquify_cairo_paint_line_tool(cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3414">                                           const gint flags, void *data);</a>
<a name="ln3415"> </a>
<a name="ln3416">static void _liquify_cairo_paint_curve_tool(cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3417">                                            const gint flags, void *data);</a>
<a name="ln3418"> </a>
<a name="ln3419">static void _liquify_cairo_paint_node_tool(cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3420">                                           const gint flags, void *data);</a>
<a name="ln3421"> </a>
<a name="ln3422"> </a>
<a name="ln3423">static float conf_set_get_default(const char *name, float def)</a>
<a name="ln3424">{</a>
<a name="ln3425">  float value;</a>
<a name="ln3426">  if(dt_conf_key_exists(name))</a>
<a name="ln3427">  {</a>
<a name="ln3428">    value = dt_conf_get_float(name);</a>
<a name="ln3429">    // do some sanity check, the value must &gt; 1.0 (these are value in pixels), reset to default if not</a>
<a name="ln3430">    if((value &lt;= 1.0f || value &gt; 3000.0f) &amp;&amp; strcmp(name, CONF_ANGLE))</a>
<a name="ln3431">    {</a>
<a name="ln3432">      value = def;</a>
<a name="ln3433">      dt_conf_set_float(name, value);</a>
<a name="ln3434">    }</a>
<a name="ln3435">  }</a>
<a name="ln3436">  else</a>
<a name="ln3437">  {</a>
<a name="ln3438">    value = def;</a>
<a name="ln3439">    dt_conf_set_float(name, value);</a>
<a name="ln3440">  }</a>
<a name="ln3441">  return value;</a>
<a name="ln3442">}</a>
<a name="ln3443"> </a>
<a name="ln3444">// we need this only because darktable has no radiobutton support</a>
<a name="ln3445">static void btn_make_radio_callback (GtkToggleButton *btn, dt_iop_module_t *module)</a>
<a name="ln3446">{</a>
<a name="ln3447">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3448"> </a>
<a name="ln3449">  // if currently dragging and a form (line or node) has been started, does nothing (expect resetting the toggle button status).</a>
<a name="ln3450"> </a>
<a name="ln3451">  if (is_dragging(g) &amp;&amp; g-&gt;temp &amp;&amp; node_prev(&amp;g-&gt;params, g-&gt;temp))</a>
<a name="ln3452">  {</a>
<a name="ln3453">    g_signal_handlers_block_matched(g-&gt;btn_point_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3454">    g_signal_handlers_block_matched(g-&gt;btn_line_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3455">    g_signal_handlers_block_matched(g-&gt;btn_curve_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3456">    g_signal_handlers_block_matched(g-&gt;btn_node_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3457"> </a>
<a name="ln3458">    gtk_toggle_button_set_active (btn, !gtk_toggle_button_get_active(btn));</a>
<a name="ln3459"> </a>
<a name="ln3460">    g_signal_handlers_unblock_matched(g-&gt;btn_point_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3461">    g_signal_handlers_unblock_matched(g-&gt;btn_line_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3462">    g_signal_handlers_unblock_matched(g-&gt;btn_curve_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3463">    g_signal_handlers_unblock_matched(g-&gt;btn_node_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3464">    return;</a>
<a name="ln3465">  }</a>
<a name="ln3466"> </a>
<a name="ln3467">  dt_control_hinter_message (darktable.control, &quot;&quot;);</a>
<a name="ln3468"> </a>
<a name="ln3469">  // if we are on a preview, it means that a form (point, line, curve) has been started, but no node has yet been placed.</a>
<a name="ln3470">  // in this case we abort the current preview and let the new tool activated.</a>
<a name="ln3471"> </a>
<a name="ln3472">  if (g-&gt;status &amp; DT_LIQUIFY_STATUS_PREVIEW)</a>
<a name="ln3473">  {</a>
<a name="ln3474">    node_delete (&amp;g-&gt;params, g-&gt;temp);</a>
<a name="ln3475">    g-&gt;temp = NULL;</a>
<a name="ln3476">    g-&gt;status &amp;= ~DT_LIQUIFY_STATUS_PREVIEW;</a>
<a name="ln3477">  }</a>
<a name="ln3478"> </a>
<a name="ln3479">  // now, let's enable and start a new form safely</a>
<a name="ln3480"> </a>
<a name="ln3481">  if (gtk_toggle_button_get_active (btn))</a>
<a name="ln3482">  {</a>
<a name="ln3483">    gtk_toggle_button_set_active (g-&gt;btn_point_tool, btn == g-&gt;btn_point_tool);</a>
<a name="ln3484">    gtk_toggle_button_set_active (g-&gt;btn_line_tool,  btn == g-&gt;btn_line_tool);</a>
<a name="ln3485">    gtk_toggle_button_set_active (g-&gt;btn_curve_tool, btn == g-&gt;btn_curve_tool);</a>
<a name="ln3486">    gtk_toggle_button_set_active (g-&gt;btn_node_tool,  btn == g-&gt;btn_node_tool);</a>
<a name="ln3487"> </a>
<a name="ln3488">    if (btn == g-&gt;btn_point_tool)</a>
<a name="ln3489">      dt_control_hinter_message</a>
<a name="ln3490">        (darktable.control, _(&quot;click and drag to add point\nscroll to change size\n&quot;</a>
<a name="ln3491">                              &quot;shift-scroll to change strength - ctrl-scroll to change direction&quot;));</a>
<a name="ln3492">    else if (btn == g-&gt;btn_line_tool)</a>
<a name="ln3493">      dt_control_hinter_message</a>
<a name="ln3494">        (darktable.control, _(&quot;click to add line\nscroll to change size\n&quot;</a>
<a name="ln3495">                              &quot;shift-scroll to change strength - ctrl-scroll to change direction&quot;));</a>
<a name="ln3496">    else if (btn == g-&gt;btn_curve_tool)</a>
<a name="ln3497">      dt_control_hinter_message</a>
<a name="ln3498">        (darktable.control, _(&quot;click to add curve\nscroll to change size\n&quot;</a>
<a name="ln3499">                              &quot;shift-scroll to change strength - ctrl-scroll to change direction&quot;));</a>
<a name="ln3500">    else if (btn == g-&gt;btn_node_tool)</a>
<a name="ln3501">      dt_control_hinter_message (darktable.control, _(&quot;click to edit nodes&quot;));</a>
<a name="ln3502"> </a>
<a name="ln3503">    //  start the preview mode to show the shape that will be created</a>
<a name="ln3504"> </a>
<a name="ln3505">    if (btn == g-&gt;btn_point_tool || btn == g-&gt;btn_line_tool || btn == g-&gt;btn_curve_tool)</a>
<a name="ln3506">    {</a>
<a name="ln3507">      float complex pt;</a>
<a name="ln3508">      float scale;</a>
<a name="ln3509"> </a>
<a name="ln3510">      //  create initial shape at the center</a>
<a name="ln3511">      get_point_scale(module, .5f * darktable.develop-&gt;width, .5f * darktable.develop-&gt;height, &amp;pt, &amp;scale);</a>
<a name="ln3512"> </a>
<a name="ln3513">      //  start a new path</a>
<a name="ln3514">      g-&gt;temp = alloc_move_to (module, pt);</a>
<a name="ln3515"> </a>
<a name="ln3516">      //  start with current saved size/strength</a>
<a name="ln3517"> </a>
<a name="ln3518">      const float radius = conf_set_get_default(CONF_RADIUS, GET_UI_WIDTH(DEFAULT_RADIUS));</a>
<a name="ln3519">      const float r = conf_set_get_default(CONF_STRENGTH, GET_UI_WIDTH(DEFAULT_STRENGTH));</a>
<a name="ln3520">      const float phi = conf_set_get_default(CONF_ANGLE, 0);</a>
<a name="ln3521"> </a>
<a name="ln3522">      g-&gt;temp-&gt;warp.radius   = pt + radius;</a>
<a name="ln3523">      g-&gt;temp-&gt;warp.strength = pt + r * cexp (phi * I);</a>
<a name="ln3524"> </a>
<a name="ln3525">      g-&gt;status |= DT_LIQUIFY_STATUS_PREVIEW;</a>
<a name="ln3526">      g-&gt;status |= DT_LIQUIFY_STATUS_NEW;</a>
<a name="ln3527"> </a>
<a name="ln3528">      start_drag (g, DT_LIQUIFY_LAYER_CENTERPOINT, g-&gt;temp);</a>
<a name="ln3529">      g-&gt;last_hit = NOWHERE;</a>
<a name="ln3530">    }</a>
<a name="ln3531">  }</a>
<a name="ln3532"> </a>
<a name="ln3533">  sync_pipe (module, FALSE);</a>
<a name="ln3534">  dt_iop_request_focus(module);</a>
<a name="ln3535">}</a>
<a name="ln3536"> </a>
<a name="ln3537">void gui_update (dt_iop_module_t *module)</a>
<a name="ln3538">{</a>
<a name="ln3539">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3540">  memcpy(&amp;g-&gt;params, module-&gt;params, sizeof(dt_iop_liquify_params_t));</a>
<a name="ln3541">  update_warp_count(g);</a>
<a name="ln3542">}</a>
<a name="ln3543"> </a>
<a name="ln3544">void gui_init (dt_iop_module_t *module)</a>
<a name="ln3545">{</a>
<a name="ln3546">  module-&gt;gui_data = malloc (sizeof (dt_iop_liquify_gui_data_t));</a>
<a name="ln3547">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3548"> </a>
<a name="ln3549">  // A dummy surface for calculations only, no drawing.</a>
<a name="ln3550">  cairo_surface_t *cs = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 1, 1);</a>
<a name="ln3551">  g-&gt;fake_cr = cairo_create (cs);</a>
<a name="ln3552">  cairo_surface_destroy (cs);</a>
<a name="ln3553"> </a>
<a name="ln3554">  g-&gt;dragging = NOWHERE;</a>
<a name="ln3555">  g-&gt;temp = NULL;</a>
<a name="ln3556">  g-&gt;status = 0;</a>
<a name="ln3557">  g-&gt;last_mouse_pos =</a>
<a name="ln3558">  g-&gt;last_button1_pressed_pos = -1;</a>
<a name="ln3559">  g-&gt;last_hit = NOWHERE;</a>
<a name="ln3560">  dt_pthread_mutex_init (&amp;g-&gt;lock, NULL);</a>
<a name="ln3561">  g-&gt;node_index = 0;</a>
<a name="ln3562"> </a>
<a name="ln3563">  module-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln3564">  dt_gui_add_help_link(module-&gt;widget, dt_get_help_url(module-&gt;op));</a>
<a name="ln3565"> </a>
<a name="ln3566">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln3567">  gtk_widget_set_tooltip_text(hbox, _(&quot;use a tool to add warps.\nright-click to remove a warp.&quot;));</a>
<a name="ln3568">  gtk_box_pack_start(GTK_BOX(module-&gt;widget), hbox, TRUE, TRUE, 0);</a>
<a name="ln3569"> </a>
<a name="ln3570">  gtk_box_pack_start(GTK_BOX(hbox), gtk_label_new (_(&quot;warps|nodes count:&quot;)), FALSE, TRUE, 0);</a>
<a name="ln3571">  g-&gt;label = GTK_LABEL(gtk_label_new (&quot;-&quot;));</a>
<a name="ln3572">  gtk_box_pack_start (GTK_BOX(hbox), GTK_WIDGET(g-&gt;label), FALSE, TRUE, 0);</a>
<a name="ln3573"> </a>
<a name="ln3574">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln3575">  gtk_box_pack_start(GTK_BOX(module-&gt;widget), hbox, TRUE, TRUE, 0);</a>
<a name="ln3576"> </a>
<a name="ln3577">  g-&gt;btn_point_tool = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(_liquify_cairo_paint_point_tool,</a>
<a name="ln3578">                                                               CPF_STYLE_FLAT|CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln3579">  g_signal_connect(G_OBJECT (g-&gt;btn_point_tool), &quot;toggled&quot;, G_CALLBACK (btn_make_radio_callback), module);</a>
<a name="ln3580">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;btn_point_tool), _(&quot;point tool: draw points&quot;));</a>
<a name="ln3581">  gtk_toggle_button_set_active(g-&gt;btn_point_tool, 0);</a>
<a name="ln3582">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(g-&gt;btn_point_tool), FALSE, FALSE, 0);</a>
<a name="ln3583"> </a>
<a name="ln3584">  g-&gt;btn_line_tool = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(_liquify_cairo_paint_line_tool,</a>
<a name="ln3585">                                                              CPF_STYLE_FLAT|CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln3586">  g_signal_connect(G_OBJECT (g-&gt;btn_line_tool), &quot;toggled&quot;, G_CALLBACK (btn_make_radio_callback), module);</a>
<a name="ln3587">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;btn_line_tool), _(&quot;line tool: draw lines&quot;));</a>
<a name="ln3588">  gtk_toggle_button_set_active(g-&gt;btn_line_tool, 0);</a>
<a name="ln3589">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(g-&gt;btn_line_tool), FALSE, FALSE, 0);</a>
<a name="ln3590"> </a>
<a name="ln3591">  g-&gt;btn_curve_tool = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(_liquify_cairo_paint_curve_tool,</a>
<a name="ln3592">                                                               CPF_STYLE_FLAT|CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln3593">  g_signal_connect(G_OBJECT (g-&gt;btn_curve_tool), &quot;toggled&quot;, G_CALLBACK (btn_make_radio_callback), module);</a>
<a name="ln3594">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;btn_curve_tool), _(&quot;curve tool: draw curves&quot;));</a>
<a name="ln3595">  gtk_toggle_button_set_active(g-&gt;btn_curve_tool, 0);</a>
<a name="ln3596">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(g-&gt;btn_curve_tool), FALSE, FALSE, 0);</a>
<a name="ln3597"> </a>
<a name="ln3598">  g-&gt;btn_node_tool = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(_liquify_cairo_paint_node_tool,</a>
<a name="ln3599">                                                              CPF_STYLE_FLAT|CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln3600">  g_signal_connect(G_OBJECT(g-&gt;btn_node_tool), &quot;toggled&quot;, G_CALLBACK (btn_make_radio_callback), module);</a>
<a name="ln3601">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;btn_node_tool), _(&quot;node tool: edit, add and delete nodes&quot;));</a>
<a name="ln3602">  gtk_toggle_button_set_active(g-&gt;btn_node_tool, 0);</a>
<a name="ln3603">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(g-&gt;btn_node_tool), FALSE, FALSE, 0);</a>
<a name="ln3604"> </a>
<a name="ln3605">  dt_liquify_layers[DT_LIQUIFY_LAYER_PATH].hint           = _(&quot;ctrl-click: add node - right click: remove path\n&quot;</a>
<a name="ln3606">                                                              &quot;ctrl-alt-click: toggle line/curve&quot;);</a>
<a name="ln3607">  dt_liquify_layers[DT_LIQUIFY_LAYER_CENTERPOINT].hint    = _(&quot;click and drag to move - click: show/hide feathering controls\n&quot;</a>
<a name="ln3608">                                                              &quot;ctrl-click: autosmooth, cusp, smooth, symmetrical&quot;</a>
<a name="ln3609">                                                              &quot; - right click to remove&quot;);</a>
<a name="ln3610">  dt_liquify_layers[DT_LIQUIFY_LAYER_CTRLPOINT1].hint     = _(&quot;drag to change shape of path&quot;);</a>
<a name="ln3611">  dt_liquify_layers[DT_LIQUIFY_LAYER_CTRLPOINT2].hint     = _(&quot;drag to change shape of path&quot;);</a>
<a name="ln3612">  dt_liquify_layers[DT_LIQUIFY_LAYER_RADIUSPOINT].hint    = _(&quot;drag to adjust warp radius&quot;);</a>
<a name="ln3613">  dt_liquify_layers[DT_LIQUIFY_LAYER_HARDNESSPOINT1].hint = _(&quot;drag to adjust hardness (center)&quot;);</a>
<a name="ln3614">  dt_liquify_layers[DT_LIQUIFY_LAYER_HARDNESSPOINT2].hint = _(&quot;drag to adjust hardness (feather)&quot;);</a>
<a name="ln3615">  dt_liquify_layers[DT_LIQUIFY_LAYER_STRENGTHPOINT].hint  = _(&quot;drag to adjust warp strength\n&quot;</a>
<a name="ln3616">                                                              &quot;ctrl-click: linear, grow, and shrink&quot;);</a>
<a name="ln3617">}</a>
<a name="ln3618"> </a>
<a name="ln3619">void gui_cleanup (dt_iop_module_t *module)</a>
<a name="ln3620">{</a>
<a name="ln3621">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3622">  if (g)</a>
<a name="ln3623">  {</a>
<a name="ln3624">    cairo_destroy (g-&gt;fake_cr);</a>
<a name="ln3625">    dt_pthread_mutex_destroy (&amp;g-&gt;lock);</a>
<a name="ln3626">    free (g);</a>
<a name="ln3627">  }</a>
<a name="ln3628">  module-&gt;gui_data = NULL;</a>
<a name="ln3629">}</a>
<a name="ln3630"> </a>
<a name="ln3631">void init_key_accels (dt_iop_module_so_t *module)</a>
<a name="ln3632">{</a>
<a name="ln3633">  dt_accel_register_iop (module, FALSE, NC_(&quot;accel&quot;, &quot;point tool&quot;),     0, 0);</a>
<a name="ln3634">  dt_accel_register_iop (module, FALSE, NC_(&quot;accel&quot;, &quot;line tool&quot;),      0, 0);</a>
<a name="ln3635">  dt_accel_register_iop (module, FALSE, NC_(&quot;accel&quot;, &quot;curve tool&quot;),     0, 0);</a>
<a name="ln3636">  dt_accel_register_iop (module, FALSE, NC_(&quot;accel&quot;, &quot;node tool&quot;),      0, 0);</a>
<a name="ln3637">}</a>
<a name="ln3638"> </a>
<a name="ln3639">void connect_key_accels (dt_iop_module_t *module)</a>
<a name="ln3640">{</a>
<a name="ln3641">  const dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3642"> </a>
<a name="ln3643">  dt_accel_connect_button_iop (module, &quot;point tool&quot;,    GTK_WIDGET (g-&gt;btn_point_tool));</a>
<a name="ln3644">  dt_accel_connect_button_iop (module, &quot;line tool&quot;,     GTK_WIDGET (g-&gt;btn_line_tool));</a>
<a name="ln3645">  dt_accel_connect_button_iop (module, &quot;curve tool&quot;,    GTK_WIDGET (g-&gt;btn_curve_tool));</a>
<a name="ln3646">  dt_accel_connect_button_iop (module, &quot;node tool&quot;,     GTK_WIDGET (g-&gt;btn_node_tool));</a>
<a name="ln3647">}</a>
<a name="ln3648"> </a>
<a name="ln3649">// defgroup Button paint functions</a>
<a name="ln3650"> </a>
<a name="ln3651">#define PREAMBLE                                        \</a>
<a name="ln3652">  cairo_save (cr);                                      \</a>
<a name="ln3653">  const gint s = MIN (w, h);                            \</a>
<a name="ln3654">  cairo_translate (cr, x + (w / 2.0) - (s / 2.0),       \</a>
<a name="ln3655">                   y + (h / 2.0) - (s / 2.0));          \</a>
<a name="ln3656">  cairo_scale (cr, s, s);                               \</a>
<a name="ln3657">  cairo_push_group (cr);                                \</a>
<a name="ln3658">  cairo_set_source_rgba (cr, 1.0, 1.0, 1.0, 1.0);       \</a>
<a name="ln3659">  cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);        \</a>
<a name="ln3660">  cairo_set_line_width (cr, 0.2);</a>
<a name="ln3661"> </a>
<a name="ln3662">#define POSTAMBLE                                               \</a>
<a name="ln3663">  cairo_pop_group_to_source (cr);                               \</a>
<a name="ln3664">  cairo_paint_with_alpha (cr, flags &amp; CPF_ACTIVE ? 1.0 : 0.5);  \</a>
<a name="ln3665">  cairo_restore (cr);</a>
<a name="ln3666"> </a>
<a name="ln3667">static void _liquify_cairo_paint_point_tool (cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3668">                                             const gint flags, void *data)</a>
<a name="ln3669">{</a>
<a name="ln3670">  PREAMBLE;</a>
<a name="ln3671">  cairo_new_sub_path (cr);</a>
<a name="ln3672">  cairo_arc (cr, 0.5, 0.5, 0.2, 0.0, 2 * M_PI);</a>
<a name="ln3673">  cairo_fill (cr);</a>
<a name="ln3674">  POSTAMBLE;</a>
<a name="ln3675">}</a>
<a name="ln3676"> </a>
<a name="ln3677">static void _liquify_cairo_paint_line_tool (cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3678">                                            const gint flags, void *data)</a>
<a name="ln3679">{</a>
<a name="ln3680">  PREAMBLE;</a>
<a name="ln3681">  cairo_move_to (cr, 0.1, 0.9);</a>
<a name="ln3682">  cairo_line_to (cr, 0.9, 0.1);</a>
<a name="ln3683">  cairo_stroke (cr);</a>
<a name="ln3684">  POSTAMBLE;</a>
<a name="ln3685">}</a>
<a name="ln3686"> </a>
<a name="ln3687">static void _liquify_cairo_paint_curve_tool (cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3688">                                             const gint flags, void *data)</a>
<a name="ln3689">{</a>
<a name="ln3690">  PREAMBLE;</a>
<a name="ln3691">  cairo_move_to (cr, 0.1, 0.9);</a>
<a name="ln3692">  cairo_curve_to (cr, 0.1, 0.5, 0.5, 0.1, 0.9, 0.1);</a>
<a name="ln3693">  cairo_stroke (cr);</a>
<a name="ln3694">  POSTAMBLE;</a>
<a name="ln3695">}</a>
<a name="ln3696"> </a>
<a name="ln3697">static void _liquify_cairo_paint_node_tool (cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3698">                                            const gint flags, void *data)</a>
<a name="ln3699">{</a>
<a name="ln3700">  PREAMBLE;</a>
<a name="ln3701">  const double dashed[] = {0.2, 0.2};</a>
<a name="ln3702">  cairo_set_dash (cr, dashed, 2, 0);</a>
<a name="ln3703">  cairo_set_line_width (cr, 0.1);</a>
<a name="ln3704"> </a>
<a name="ln3705">  cairo_arc (cr, 0.75, 0.75, 0.75, 2.8, 4.7124);</a>
<a name="ln3706">  cairo_stroke (cr);</a>
<a name="ln3707"> </a>
<a name="ln3708">  cairo_rectangle (cr, 0.2, 0.0, 0.4, 0.4);</a>
<a name="ln3709">  cairo_fill (cr);</a>
<a name="ln3710"> </a>
<a name="ln3711">  cairo_move_to (cr, 0.4,  0.2);</a>
<a name="ln3712">  cairo_line_to (cr, 0.5,  1.0);</a>
<a name="ln3713">  cairo_line_to (cr, 0.9,  0.7);</a>
<a name="ln3714">  cairo_close_path (cr);</a>
<a name="ln3715">  cairo_fill (cr);</a>
<a name="ln3716">  POSTAMBLE;</a>
<a name="ln3717">}</a>
<a name="ln3718"> </a>
<a name="ln3719">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln3720">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln3721">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="388"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 386, 388.</p></div>
<div class="balloon" rel="616"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'b' pointer in the 'b ++' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 616, 604.</p></div>
<div class="balloon" rel="951"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'stamp' pointer in the 'stamp + i * stamp_extent->width' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 951, 941.</p></div>
<div class="balloon" rel="1562"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'k'. Check lines: 1562, 1561.</p></div>
<div class="balloon" rel="1688"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 1688, 1686.</p></div>
<div class="balloon" rel="1845"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'w'. Check lines: 1845, 1844.</p></div>
<div class="balloon" rel="2433"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'a'. Check lines: 2433, 2421.</p></div>
<div class="balloon" rel="2433"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'b'. Check lines: 2433, 2422.</p></div>
<div class="balloon" rel="2433"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'c'. Check lines: 2433, 2423.</p></div>
<div class="balloon" rel="2433"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 2433, 2424.</p></div>
<div class="balloon" rel="2528"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'pt'. Check lines: 2528, 2515.</p></div>
<div class="balloon" rel="2531"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'c1'. Check lines: 2531, 2516.</p></div>
<div class="balloon" rel="2532"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'c2'. Check lines: 2532, 2517.</p></div>
<div class="balloon" rel="2555"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'eqn'. Check lines: 2555, 2518.</p></div>
<div class="balloon" rel="2959"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'handled == 2' is always false.</p></div>
<div class="balloon" rel="3102"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!g->temp' is always true.</p></div>
<div class="balloon" rel="3273"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: g->last_mouse_mods == 0.</p></div>
<div class="balloon" rel="3551"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 3551, 3546.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
