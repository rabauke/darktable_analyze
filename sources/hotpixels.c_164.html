
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 Rostyslav Pidgornyi</a>
<a name="ln4">    copyright (c) 2012 Henrik Andersson</a>
<a name="ln5"> </a>
<a name="ln6">    and the initial plugin `stuck pixels' was</a>
<a name="ln7">    copyright (c) 2011 bruce guenter</a>
<a name="ln8"> </a>
<a name="ln9">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln10">    it under the terms of the GNU General Public License as published by</a>
<a name="ln11">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln12">    (at your option) any later version.</a>
<a name="ln13"> </a>
<a name="ln14">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln15">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln16">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln17">    GNU General Public License for more details.</a>
<a name="ln18"> </a>
<a name="ln19">    You should have received a copy of the GNU General Public License</a>
<a name="ln20">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#ifdef HAVE_CONFIG_H</a>
<a name="ln24">#include &quot;config.h&quot;</a>
<a name="ln25">#endif</a>
<a name="ln26">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln27">#include &quot;control/control.h&quot;</a>
<a name="ln28">#include &quot;develop/imageop.h&quot;</a>
<a name="ln29">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln30">#include &quot;dtgtk/resetlabel.h&quot;</a>
<a name="ln31">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln32">#include &quot;gui/gtk.h&quot;</a>
<a name="ln33">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln36">#include &lt;stdlib.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">DT_MODULE_INTROSPECTION(1, dt_iop_hotpixels_params_t)</a>
<a name="ln39"> </a>
<a name="ln40">typedef struct dt_iop_hotpixels_params_t</a>
<a name="ln41">{</a>
<a name="ln42">  float strength;</a>
<a name="ln43">  float threshold;</a>
<a name="ln44">  gboolean markfixed;</a>
<a name="ln45">  gboolean permissive;</a>
<a name="ln46">} dt_iop_hotpixels_params_t;</a>
<a name="ln47"> </a>
<a name="ln48">typedef struct dt_iop_hotpixels_gui_data_t</a>
<a name="ln49">{</a>
<a name="ln50">  GtkWidget *box_raw;</a>
<a name="ln51">  GtkWidget *threshold, *strength;</a>
<a name="ln52">  GtkToggleButton *markfixed;</a>
<a name="ln53">  GtkToggleButton *permissive;</a>
<a name="ln54">  GtkLabel *message;</a>
<a name="ln55">  int pixels_fixed;</a>
<a name="ln56">  GtkWidget *label_non_raw;</a>
<a name="ln57">} dt_iop_hotpixels_gui_data_t;</a>
<a name="ln58"> </a>
<a name="ln59">typedef struct dt_iop_hotpixels_data_t</a>
<a name="ln60">{</a>
<a name="ln61">  uint32_t filters;</a>
<a name="ln62">  float threshold;</a>
<a name="ln63">  float multiplier;</a>
<a name="ln64">  gboolean permissive;</a>
<a name="ln65">  gboolean markfixed;</a>
<a name="ln66">} dt_iop_hotpixels_data_t;</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">const char *name()</a>
<a name="ln70">{</a>
<a name="ln71">  return _(&quot;hot pixels&quot;);</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">int default_group()</a>
<a name="ln75">{</a>
<a name="ln76">  return IOP_GROUP_CORRECT;</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">int flags()</a>
<a name="ln80">{</a>
<a name="ln81">  return IOP_FLAGS_SUPPORTS_BLENDING | IOP_FLAGS_ONE_INSTANCE;</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln85">{</a>
<a name="ln86">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;threshold&quot;));</a>
<a name="ln87">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;strength&quot;));</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln91">{</a>
<a name="ln92">  dt_iop_hotpixels_gui_data_t *g = (dt_iop_hotpixels_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln93"> </a>
<a name="ln94">  dt_accel_connect_slider_iop(self, &quot;threshold&quot;, GTK_WIDGET(g-&gt;threshold));</a>
<a name="ln95">  dt_accel_connect_slider_iop(self, &quot;strength&quot;, GTK_WIDGET(g-&gt;strength));</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">/* Detect hot sensor pixels based on the 4 surrounding sites. Pixels</a>
<a name="ln99"> * having 3 or 4 (depending on permissive setting) surrounding pixels that</a>
<a name="ln100"> * than value*multiplier are considered &quot;hot&quot;, and are replaced by the maximum of</a>
<a name="ln101"> * the neighbour pixels. The permissive variant allows for</a>
<a name="ln102"> * correcting pairs of hot pixels in adjacent sites. Replacement using</a>
<a name="ln103"> * the maximum produces fewer artifacts when inadvertently replacing</a>
<a name="ln104"> * non-hot pixels.</a>
<a name="ln105"> * This is the Bayer sensor variant. */</a>
<a name="ln106">static int process_bayer(const dt_iop_hotpixels_data_t *data,</a>
<a name="ln107">                         const void *const ivoid, void *const ovoid,</a>
<a name="ln108">                         const dt_iop_roi_t *const roi_out)</a>
<a name="ln109">{</a>
<a name="ln110">  const float threshold = data-&gt;threshold;</a>
<a name="ln111">  const float multiplier = data-&gt;multiplier;</a>
<a name="ln112">  const gboolean markfixed = data-&gt;markfixed;</a>
<a name="ln113">  const int min_neighbours = data-&gt;permissive ? 3 : 4;</a>
<a name="ln114">  const int width = roi_out-&gt;width;</a>
<a name="ln115">  const int widthx2 = width * 2;</a>
<a name="ln116">  int fixed = 0;</a>
<a name="ln117"> </a>
<a name="ln118">#ifdef _OPENMP</a>
<a name="ln119">#pragma omp parallel for default(none) reduction(+ : fixed) schedule(static)</a>
<a name="ln120">#endif</a>
<a name="ln121">  for(int row = 2; row &lt; roi_out-&gt;height - 2; row++)</a>
<a name="ln122">  {</a>
<a name="ln123">    const float *in = (float *)ivoid + (size_t)width * row + 2;</a>
<a name="ln124">    float *out = (float *)ovoid + (size_t)width * row + 2;</a>
<a name="ln125">    for(int col = 2; col &lt; width - 2; col++, in++, out++)</a>
<a name="ln126">    {</a>
<a name="ln127">      float mid = *in * multiplier;</a>
<a name="ln128">      if(*in &gt; threshold)</a>
<a name="ln129">      {</a>
<a name="ln130">        int count = 0;</a>
<a name="ln131">        float maxin = 0.0;</a>
<a name="ln132">        float other;</a>
<a name="ln133">#define TESTONE(OFFSET)                                                                                      \</a>
<a name="ln134">  other = in[OFFSET];                                                                                        \</a>
<a name="ln135">  if(mid &gt; other)                                                                                            \</a>
<a name="ln136">  {                                                                                                          \</a>
<a name="ln137">    count++;                                                                                                 \</a>
<a name="ln138">    if(other &gt; maxin) maxin = other;                                                                         \</a>
<a name="ln139">  }</a>
<a name="ln140">        TESTONE(-2);</a>
<a name="ln141">        TESTONE(-widthx2);</a>
<a name="ln142">        TESTONE(+2);</a>
<a name="ln143">        TESTONE(+widthx2);</a>
<a name="ln144">#undef TESTONE</a>
<a name="ln145">        if(count &gt;= min_neighbours)</a>
<a name="ln146">        {</a>
<a name="ln147">          *out = maxin;</a>
<a name="ln148">          fixed++;</a>
<a name="ln149">          if(markfixed)</a>
<a name="ln150">          {</a>
<a name="ln151">            for(int i = -2; i &gt;= -10 &amp;&amp; i &gt;= -col; i -= 2) out[i] = *in;</a>
<a name="ln152">            for(int i = 2; i &lt;= 10 &amp;&amp; i &lt; width - col; i += 2) out[i] = *in;</a>
<a name="ln153">          }</a>
<a name="ln154">        }</a>
<a name="ln155">      }</a>
<a name="ln156">    }</a>
<a name="ln157">  }</a>
<a name="ln158"> </a>
<a name="ln159">  return fixed;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">/* X-Trans sensor equivalent of process_bayer(). */</a>
<a name="ln163">static int process_xtrans(const dt_iop_hotpixels_data_t *data,</a>
<a name="ln164">                          const void *const ivoid, void *const ovoid,</a>
<a name="ln165">                          const dt_iop_roi_t *const roi_out, const uint8_t (*const xtrans)[6])</a>
<a name="ln166">{</a>
<a name="ln167">  // for each cell of sensor array, pre-calculate, a list of the x/y</a>
<a name="ln168">  // offsets of the four radially nearest pixels of the same color</a>
<a name="ln169">  int offsets[6][6][4][2];</a>
<a name="ln170">  // increasing offsets from pixel to find nearest like-colored pixels</a>
<a name="ln171">  const int search[20][2] = { { -1, 0 },</a>
<a name="ln172">                              { 1, 0 },</a>
<a name="ln173">                              { 0, -1 },</a>
<a name="ln174">                              { 0, 1 },</a>
<a name="ln175">                              { -1, -1 },</a>
<a name="ln176">                              { -1, 1 },</a>
<a name="ln177">                              { 1, -1 },</a>
<a name="ln178">                              { 1, 1 },</a>
<a name="ln179">                              { -2, 0 },</a>
<a name="ln180">                              { 2, 0 },</a>
<a name="ln181">                              { 0, -2 },</a>
<a name="ln182">                              { 0, 2 },</a>
<a name="ln183">                              { -2, -1 },</a>
<a name="ln184">                              { -2, 1 },</a>
<a name="ln185">                              { 2, -1 },</a>
<a name="ln186">                              { 2, 1 },</a>
<a name="ln187">                              { -1, -2 },</a>
<a name="ln188">                              { 1, -2 },</a>
<a name="ln189">                              { -1, 2 },</a>
<a name="ln190">                              { 1, 2 } };</a>
<a name="ln191">  for(int j = 0; j &lt; 6; ++j)</a>
<a name="ln192">  {</a>
<a name="ln193">    for(int i = 0; i &lt; 6; ++i)</a>
<a name="ln194">    {</a>
<a name="ln195">      const uint8_t c = FCxtrans(j, i, roi_out, xtrans);</a>
<a name="ln196">      for(int s = 0, found = 0; s &lt; 20 &amp;&amp; found &lt; 4; ++s)</a>
<a name="ln197">      {</a>
<a name="ln198">        if(c == FCxtrans(j + search[s][1], i + search[s][0], roi_out, xtrans))</a>
<a name="ln199">        {</a>
<a name="ln200">          offsets[j][i][found][0] = search[s][0];</a>
<a name="ln201">          offsets[j][i][found][1] = search[s][1];</a>
<a name="ln202">          ++found;</a>
<a name="ln203">        }</a>
<a name="ln204">      }</a>
<a name="ln205">    }</a>
<a name="ln206">  }</a>
<a name="ln207"> </a>
<a name="ln208">  const float threshold = data-&gt;threshold;</a>
<a name="ln209">  const float multiplier = data-&gt;multiplier;</a>
<a name="ln210">  const gboolean markfixed = data-&gt;markfixed;</a>
<a name="ln211">  const int min_neighbours = data-&gt;permissive ? 3 : 4;</a>
<a name="ln212">  const int width = roi_out-&gt;width;</a>
<a name="ln213">  int fixed = 0;</a>
<a name="ln214"> </a>
<a name="ln215">#ifdef _OPENMP</a>
<a name="ln216">#pragma omp parallel for default(none) shared(offsets) reduction(+ : fixed) schedule(static)</a>
<a name="ln217">#endif</a>
<a name="ln218">  for(int row = 2; row &lt; roi_out-&gt;height - 2; row++)</a>
<a name="ln219">  {</a>
<a name="ln220">    const float *in = (float *)ivoid + (size_t)width * row + 2;</a>
<a name="ln221">    float *out = (float *)ovoid + (size_t)width * row + 2;</a>
<a name="ln222">    for(int col = 2; col &lt; width - 2; col++, in++, out++)</a>
<a name="ln223">    {</a>
<a name="ln224">      float mid = *in * multiplier;</a>
<a name="ln225">      if(*in &gt; threshold)</a>
<a name="ln226">      {</a>
<a name="ln227">        int count = 0;</a>
<a name="ln228">        float maxin = 0.0;</a>
<a name="ln229">        for(int n = 0; n &lt; 4; ++n)</a>
<a name="ln230">        {</a>
<a name="ln231">          int xx = offsets[row % 6][col % 6][n][0];</a>
<a name="ln232">          int yy = offsets[row % 6][col % 6][n][1];</a>
<a name="ln233">          float other = *(in + xx + yy * (size_t)width);</a>
<a name="ln234">          if(mid &gt; other)</a>
<a name="ln235">          {</a>
<a name="ln236">            count++;</a>
<a name="ln237">            if(other &gt; maxin) maxin = other;</a>
<a name="ln238">          }</a>
<a name="ln239">        }</a>
<a name="ln240">        // NOTE: it seems that detecting by 2 neighbors would help for extreme cases</a>
<a name="ln241">        if(count &gt;= min_neighbours)</a>
<a name="ln242">        {</a>
<a name="ln243">          *out = maxin;</a>
<a name="ln244">          fixed++;</a>
<a name="ln245">          if(markfixed)</a>
<a name="ln246">          {</a>
<a name="ln247">            const uint8_t c = FCxtrans(row, col, roi_out, xtrans);</a>
<a name="ln248">            for(int i = -2; i &gt;= -10 &amp;&amp; i &gt;= -col; --i)</a>
<a name="ln249">            {</a>
<a name="ln250">              if(c == FCxtrans(row, col+i, roi_out, xtrans))</a>
<a name="ln251">              {</a>
<a name="ln252">                out[i] = *in;</a>
<a name="ln253">              }</a>
<a name="ln254">            }</a>
<a name="ln255">            for(int i = 2; i &lt;= 10 &amp;&amp; i &lt; width - col; ++i)</a>
<a name="ln256">            {</a>
<a name="ln257">              if(c == FCxtrans(row, col+i, roi_out, xtrans))</a>
<a name="ln258">              {</a>
<a name="ln259">                out[i] = *in;</a>
<a name="ln260">              }</a>
<a name="ln261">            }</a>
<a name="ln262">          }</a>
<a name="ln263">        }</a>
<a name="ln264">      }</a>
<a name="ln265">    }</a>
<a name="ln266">  }</a>
<a name="ln267"> </a>
<a name="ln268">  return fixed;</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln272">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln273">{</a>
<a name="ln274">  dt_iop_hotpixels_gui_data_t *g = (dt_iop_hotpixels_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln275">  const dt_iop_hotpixels_data_t *data = (dt_iop_hotpixels_data_t *)piece-&gt;data;</a>
<a name="ln276"> </a>
<a name="ln277">  // The processing loop should output only a few pixels, so just copy everything first</a>
<a name="ln278">  memcpy(ovoid, ivoid, (size_t)roi_out-&gt;width * roi_out-&gt;height * sizeof(float));</a>
<a name="ln279"> </a>
<a name="ln280">  int fixed;</a>
<a name="ln281">  if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln282">  {</a>
<a name="ln283">    fixed = process_xtrans(data, ivoid, ovoid, roi_out, (const uint8_t(*const)[6])piece-&gt;pipe-&gt;dsc.xtrans);</a>
<a name="ln284">  }</a>
<a name="ln285">  else</a>
<a name="ln286">  {</a>
<a name="ln287">    fixed = process_bayer(data, ivoid, ovoid, roi_out);</a>
<a name="ln288">  }</a>
<a name="ln289"> </a>
<a name="ln290">  if(g != NULL &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_FULL)</a>
<a name="ln291">  {</a>
<a name="ln292">    g-&gt;pixels_fixed = fixed;</a>
<a name="ln293">  }</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">void reload_defaults(dt_iop_module_t *module)</a>
<a name="ln297">{</a>
<a name="ln298">  const dt_iop_hotpixels_params_t tmp</a>
<a name="ln299">      = {.strength = 0.25, .threshold = 0.05, .markfixed = FALSE, .permissive = FALSE };</a>
<a name="ln300"> </a>
<a name="ln301">  // we might be called from presets update infrastructure =&gt; there is no image</a>
<a name="ln302">  if(!module-&gt;dev) goto end;</a>
<a name="ln303"> </a>
<a name="ln304">  // can't be switched on for non-raw images:</a>
<a name="ln305">  if(dt_image_is_raw(&amp;module-&gt;dev-&gt;image_storage))</a>
<a name="ln306">    module-&gt;hide_enable_button = 0;</a>
<a name="ln307">  else</a>
<a name="ln308">    module-&gt;hide_enable_button = 1;</a>
<a name="ln309"> </a>
<a name="ln310">end:</a>
<a name="ln311">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_hotpixels_params_t));</a>
<a name="ln312">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_hotpixels_params_t));</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">void init(dt_iop_module_t *module)</a>
<a name="ln316">{</a>
<a name="ln317">  module-&gt;data = NULL;</a>
<a name="ln318">  module-&gt;params = calloc(1, sizeof(dt_iop_hotpixels_params_t));</a>
<a name="ln319">  module-&gt;default_params = calloc(1, sizeof(dt_iop_hotpixels_params_t));</a>
<a name="ln320">  module-&gt;default_enabled = 0;</a>
<a name="ln321">  module-&gt;priority = 85; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln322">  module-&gt;params_size = sizeof(dt_iop_hotpixels_params_t);</a>
<a name="ln323">  module-&gt;gui_data = NULL;</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">void cleanup(dt_iop_module_t *module)</a>
<a name="ln327">{</a>
<a name="ln328">  free(module-&gt;params);</a>
<a name="ln329">  module-&gt;params = NULL;</a>
<a name="ln330">  free(module-&gt;data);</a>
<a name="ln331">  module-&gt;data = NULL;</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *params, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln335">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln336">{</a>
<a name="ln337">  dt_iop_hotpixels_params_t *p = (dt_iop_hotpixels_params_t *)params;</a>
<a name="ln338">  dt_iop_hotpixels_data_t *d = (dt_iop_hotpixels_data_t *)piece-&gt;data;</a>
<a name="ln339">  d-&gt;filters = piece-&gt;pipe-&gt;dsc.filters;</a>
<a name="ln340">  d-&gt;multiplier = p-&gt;strength / 2.0;</a>
<a name="ln341">  d-&gt;threshold = p-&gt;threshold;</a>
<a name="ln342">  d-&gt;permissive = p-&gt;permissive;</a>
<a name="ln343">  d-&gt;markfixed = p-&gt;markfixed &amp;&amp; (pipe-&gt;type != DT_DEV_PIXELPIPE_EXPORT)</a>
<a name="ln344">                 &amp;&amp; (pipe-&gt;type != DT_DEV_PIXELPIPE_THUMBNAIL);</a>
<a name="ln345">  if(!(pipe-&gt;image.flags &amp; DT_IMAGE_RAW) || p-&gt;strength == 0.0) piece-&gt;enabled = 0;</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln349">{</a>
<a name="ln350">  piece-&gt;data = malloc(sizeof(dt_iop_hotpixels_data_t));</a>
<a name="ln351">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln355">{</a>
<a name="ln356">  free(piece-&gt;data);</a>
<a name="ln357">  piece-&gt;data = NULL;</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">static void strength_callback(GtkRange *range, dt_iop_module_t *self)</a>
<a name="ln361">{</a>
<a name="ln362">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln363">  dt_iop_hotpixels_gui_data_t *g = (dt_iop_hotpixels_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln364">  dt_iop_hotpixels_params_t *p = (dt_iop_hotpixels_params_t *)self-&gt;params;</a>
<a name="ln365">  p-&gt;strength = dt_bauhaus_slider_get(g-&gt;strength);</a>
<a name="ln366">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369">static void threshold_callback(GtkRange *range, dt_iop_module_t *self)</a>
<a name="ln370">{</a>
<a name="ln371">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln372">  dt_iop_hotpixels_gui_data_t *g = (dt_iop_hotpixels_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln373">  dt_iop_hotpixels_params_t *p = (dt_iop_hotpixels_params_t *)self-&gt;params;</a>
<a name="ln374">  p-&gt;threshold = dt_bauhaus_slider_get(g-&gt;threshold);</a>
<a name="ln375">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">static void markfixed_callback(GtkRange *range, dt_iop_module_t *self)</a>
<a name="ln379">{</a>
<a name="ln380">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln381">  dt_iop_hotpixels_gui_data_t *g = (dt_iop_hotpixels_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln382">  dt_iop_hotpixels_params_t *p = (dt_iop_hotpixels_params_t *)self-&gt;params;</a>
<a name="ln383">  p-&gt;markfixed = gtk_toggle_button_get_active(g-&gt;markfixed);</a>
<a name="ln384">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">static void permissive_callback(GtkRange *range, dt_iop_module_t *self)</a>
<a name="ln388">{</a>
<a name="ln389">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln390">  dt_iop_hotpixels_gui_data_t *g = (dt_iop_hotpixels_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln391">  dt_iop_hotpixels_params_t *p = (dt_iop_hotpixels_params_t *)self-&gt;params;</a>
<a name="ln392">  p-&gt;permissive = gtk_toggle_button_get_active(g-&gt;permissive);</a>
<a name="ln393">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">void gui_update(dt_iop_module_t *self)</a>
<a name="ln397">{</a>
<a name="ln398">  dt_iop_hotpixels_gui_data_t *g = (dt_iop_hotpixels_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln399">  dt_iop_hotpixels_params_t *p = (dt_iop_hotpixels_params_t *)self-&gt;params;</a>
<a name="ln400">  dt_bauhaus_slider_set(g-&gt;strength, p-&gt;strength);</a>
<a name="ln401">  dt_bauhaus_slider_set(g-&gt;threshold, p-&gt;threshold);</a>
<a name="ln402">  gtk_toggle_button_set_active(g-&gt;markfixed, p-&gt;markfixed);</a>
<a name="ln403">  gtk_toggle_button_set_active(g-&gt;permissive, p-&gt;permissive);</a>
<a name="ln404">  g-&gt;pixels_fixed = -1;</a>
<a name="ln405">  gtk_label_set_text(g-&gt;message, &quot;&quot;);</a>
<a name="ln406"> </a>
<a name="ln407">  if(!self-&gt;hide_enable_button)</a>
<a name="ln408">  {</a>
<a name="ln409">    gtk_widget_show(g-&gt;box_raw);</a>
<a name="ln410">    gtk_widget_hide(g-&gt;label_non_raw);</a>
<a name="ln411">  }</a>
<a name="ln412">  else</a>
<a name="ln413">  {</a>
<a name="ln414">    gtk_widget_hide(g-&gt;box_raw);</a>
<a name="ln415">    gtk_widget_show(g-&gt;label_non_raw);</a>
<a name="ln416">  }</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">static gboolean draw(GtkWidget *widget, cairo_t *cr, dt_iop_module_t *self)</a>
<a name="ln420">{</a>
<a name="ln421">  dt_iop_hotpixels_gui_data_t *g = (dt_iop_hotpixels_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln422">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln423"> </a>
<a name="ln424">  if(g-&gt;pixels_fixed &lt; 0) return FALSE;</a>
<a name="ln425"> </a>
<a name="ln426">  char *str = g_strdup_printf(ngettext(&quot;fixed %d pixel&quot;, &quot;fixed %d pixels&quot;, g-&gt;pixels_fixed), g-&gt;pixels_fixed);</a>
<a name="ln427">  g-&gt;pixels_fixed = -1;</a>
<a name="ln428"> </a>
<a name="ln429">  darktable.gui-&gt;reset = 1;</a>
<a name="ln430">  gtk_label_set_text(g-&gt;message, str);</a>
<a name="ln431">  darktable.gui-&gt;reset = 0;</a>
<a name="ln432"> </a>
<a name="ln433">  g_free(str);</a>
<a name="ln434"> </a>
<a name="ln435">  return FALSE;</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">void gui_init(dt_iop_module_t *self)</a>
<a name="ln439">{</a>
<a name="ln440">  self-&gt;gui_data = malloc(sizeof(dt_iop_hotpixels_gui_data_t));</a>
<a name="ln441">  dt_iop_hotpixels_gui_data_t *g = (dt_iop_hotpixels_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln442">  dt_iop_hotpixels_params_t *p = (dt_iop_hotpixels_params_t *)self-&gt;params;</a>
<a name="ln443">  g-&gt;pixels_fixed = -1;</a>
<a name="ln444"> </a>
<a name="ln445">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln446">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln447"> </a>
<a name="ln448">  g-&gt;box_raw = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln449">  g_signal_connect(G_OBJECT(g-&gt;box_raw), &quot;draw&quot;, G_CALLBACK(draw), self);</a>
<a name="ln450"> </a>
<a name="ln451">  /* threshold */</a>
<a name="ln452">  g-&gt;threshold = dt_bauhaus_slider_new_with_range(self, 0.0, 1.0, 0.005, p-&gt;threshold, 4);</a>
<a name="ln453">  dt_bauhaus_slider_set_format(g-&gt;threshold, &quot;%.4f&quot;);</a>
<a name="ln454">  dt_bauhaus_widget_set_label(g-&gt;threshold, NULL, _(&quot;threshold&quot;));</a>
<a name="ln455">  gtk_widget_set_tooltip_text(g-&gt;threshold, _(&quot;lower threshold for hot pixel&quot;));</a>
<a name="ln456">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), GTK_WIDGET(g-&gt;threshold), TRUE, TRUE, 0);</a>
<a name="ln457">  g_signal_connect(G_OBJECT(g-&gt;threshold), &quot;value-changed&quot;, G_CALLBACK(threshold_callback), self);</a>
<a name="ln458"> </a>
<a name="ln459">  /* strength */</a>
<a name="ln460">  g-&gt;strength = dt_bauhaus_slider_new_with_range(self, 0.0, 1.0, 0.01, p-&gt;strength, 4);</a>
<a name="ln461">  dt_bauhaus_slider_set_format(g-&gt;threshold, &quot;%.4f&quot;);</a>
<a name="ln462">  dt_bauhaus_widget_set_label(g-&gt;strength, NULL, _(&quot;strength&quot;));</a>
<a name="ln463">  gtk_widget_set_tooltip_text(g-&gt;strength, _(&quot;strength of hot pixel correction&quot;));</a>
<a name="ln464">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), GTK_WIDGET(g-&gt;strength), TRUE, TRUE, 0);</a>
<a name="ln465">  g_signal_connect(G_OBJECT(g-&gt;strength), &quot;value-changed&quot;, G_CALLBACK(strength_callback), self);</a>
<a name="ln466"> </a>
<a name="ln467">  /* 3 neighbours */</a>
<a name="ln468">  g-&gt;permissive = GTK_TOGGLE_BUTTON(gtk_check_button_new_with_label(_(&quot;detect by 3 neighbors&quot;)));</a>
<a name="ln469">  gtk_toggle_button_set_active(g-&gt;permissive, p-&gt;permissive);</a>
<a name="ln470">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), GTK_WIDGET(g-&gt;permissive), TRUE, TRUE, 0);</a>
<a name="ln471">  g_signal_connect(G_OBJECT(g-&gt;permissive), &quot;toggled&quot;, G_CALLBACK(permissive_callback), self);</a>
<a name="ln472"> </a>
<a name="ln473"> </a>
<a name="ln474">  GtkBox *hbox1 = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln475">  g-&gt;markfixed = GTK_TOGGLE_BUTTON(gtk_check_button_new_with_label(_(&quot;mark fixed pixels&quot;)));</a>
<a name="ln476">  gtk_toggle_button_set_active(g-&gt;markfixed, p-&gt;markfixed);</a>
<a name="ln477">  gtk_box_pack_start(GTK_BOX(hbox1), GTK_WIDGET(g-&gt;markfixed), TRUE, TRUE, 0);</a>
<a name="ln478">  g_signal_connect(G_OBJECT(g-&gt;markfixed), &quot;toggled&quot;, G_CALLBACK(markfixed_callback), self);</a>
<a name="ln479"> </a>
<a name="ln480">  g-&gt;message = GTK_LABEL(gtk_label_new(&quot;&quot;)); // This gets filled in by process</a>
<a name="ln481">  gtk_box_pack_start(GTK_BOX(hbox1), GTK_WIDGET(g-&gt;message), TRUE, TRUE, 0);</a>
<a name="ln482"> </a>
<a name="ln483">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), GTK_WIDGET(hbox1), TRUE, TRUE, 0);</a>
<a name="ln484"> </a>
<a name="ln485">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;box_raw, FALSE, FALSE, 0);</a>
<a name="ln486"> </a>
<a name="ln487">  g-&gt;label_non_raw = gtk_label_new(_(&quot;hot pixel correction\nonly works for raw images.&quot;));</a>
<a name="ln488">  gtk_widget_set_halign(g-&gt;label_non_raw, GTK_ALIGN_START);</a>
<a name="ln489">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;label_non_raw, FALSE, FALSE, 0);</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492">void gui_cleanup(dt_iop_module_t *self)</a>
<a name="ln493">{</a>
<a name="ln494">  free(self-&gt;gui_data);</a>
<a name="ln495">  self-&gt;gui_data = NULL;</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln499">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln500">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="443"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 443, 440.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
