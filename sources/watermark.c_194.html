
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln20">#include &quot;common/tags.h&quot;</a>
<a name="ln21">#include &quot;control/control.h&quot;</a>
<a name="ln22">#include &quot;develop/develop.h&quot;</a>
<a name="ln23">#include &quot;develop/imageop.h&quot;</a>
<a name="ln24">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln25">#include &quot;dtgtk/resetlabel.h&quot;</a>
<a name="ln26">#include &quot;dtgtk/togglebutton.h&quot;</a>
<a name="ln27">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln28">#include &quot;gui/color_picker_proxy.h&quot;</a>
<a name="ln29">#include &quot;gui/gtk.h&quot;</a>
<a name="ln30">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln31">#include &lt;assert.h&gt;</a>
<a name="ln32">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln33">#include &lt;inttypes.h&gt;</a>
<a name="ln34">#include &lt;math.h&gt;</a>
<a name="ln35">#include &lt;stdlib.h&gt;</a>
<a name="ln36">#include &lt;string.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;librsvg/rsvg.h&gt;</a>
<a name="ln39">// ugh, ugly hack. why do people break stuff all the time?</a>
<a name="ln40">#ifndef RSVG_CAIRO_H</a>
<a name="ln41">#include &lt;librsvg/rsvg-cairo.h&gt;</a>
<a name="ln42">#endif</a>
<a name="ln43"> </a>
<a name="ln44">#include &quot;common/file_location.h&quot;</a>
<a name="ln45">#include &quot;common/metadata.h&quot;</a>
<a name="ln46">#include &quot;common/utility.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">#define CLIP(x) ((x &lt; 0) ? 0.0 : (x &gt; 1.0) ? 1.0 : x)</a>
<a name="ln49">DT_MODULE_INTROSPECTION(4, dt_iop_watermark_params_t)</a>
<a name="ln50"> </a>
<a name="ln51">// gchar *checksum = g_compute_checksum_for_data(G_CHECKSUM_MD5,data,length);</a>
<a name="ln52"> </a>
<a name="ln53">typedef enum dt_iop_watermark_base_scale_t</a>
<a name="ln54">{</a>
<a name="ln55">  DT_SCALE_IMAGE = 0,</a>
<a name="ln56">  DT_SCALE_LARGER_BORDER = 1,</a>
<a name="ln57">  DT_SCALE_SMALLER_BORDER = 2</a>
<a name="ln58">} dt_iop_watermark_base_scale_t;</a>
<a name="ln59"> </a>
<a name="ln60">typedef struct dt_iop_watermark_params_t</a>
<a name="ln61">{</a>
<a name="ln62">  /** opacity value of rendering watermark */</a>
<a name="ln63">  float opacity;</a>
<a name="ln64">  /** scale value of rendering watermark */</a>
<a name="ln65">  float scale;</a>
<a name="ln66">  /** Pixel independent xoffset, 0 to 1 */</a>
<a name="ln67">  float xoffset;</a>
<a name="ln68">  /** Pixel independent yoffset, 0 to 1 */</a>
<a name="ln69">  float yoffset;</a>
<a name="ln70">  /** Alignment value 0-8 3x3 */</a>
<a name="ln71">  int alignment;</a>
<a name="ln72">  /** Rotation **/</a>
<a name="ln73">  float rotate;</a>
<a name="ln74">  dt_iop_watermark_base_scale_t sizeto;</a>
<a name="ln75">  char filename[64];</a>
<a name="ln76">  /* simple text */</a>
<a name="ln77">  char text[64];</a>
<a name="ln78">  /* text color */</a>
<a name="ln79">  float color[3];</a>
<a name="ln80">  /* text font */</a>
<a name="ln81">  char font[64];</a>
<a name="ln82">} dt_iop_watermark_params_t;</a>
<a name="ln83"> </a>
<a name="ln84">typedef struct dt_iop_watermark_data_t</a>
<a name="ln85">{</a>
<a name="ln86">  float opacity;</a>
<a name="ln87">  float scale;</a>
<a name="ln88">  float xoffset;</a>
<a name="ln89">  float yoffset;</a>
<a name="ln90">  int alignment;</a>
<a name="ln91">  float rotate;</a>
<a name="ln92">  dt_iop_watermark_base_scale_t sizeto;</a>
<a name="ln93">  char filename[64];</a>
<a name="ln94">  char text[64];</a>
<a name="ln95">  float color[3];</a>
<a name="ln96">  char font[64];</a>
<a name="ln97">} dt_iop_watermark_data_t;</a>
<a name="ln98"> </a>
<a name="ln99">typedef struct dt_iop_watermark_gui_data_t</a>
<a name="ln100">{</a>
<a name="ln101">  GtkWidget *watermarks;                             // watermark</a>
<a name="ln102">  GList     *watermarks_filenames;                   // the actual filenames. the dropdown lacks file extensions</a>
<a name="ln103">  GtkWidget *refresh;                                // refresh watermarks...</a>
<a name="ln104">  GtkWidget *align[9];                               // Alignment buttons</a>
<a name="ln105">  GtkWidget *opacity, *scale, *x_offset, *y_offset;  // opacity, scale, xoffs, yoffs</a>
<a name="ln106">  GtkWidget *sizeto;                                 // relative size to</a>
<a name="ln107">  GtkWidget *rotate;</a>
<a name="ln108">  GtkWidget *text;</a>
<a name="ln109">  GtkWidget *colorpick;</a>
<a name="ln110">  GtkWidget *fontsel;</a>
<a name="ln111">  GtkToggleButton *color_picker_button;</a>
<a name="ln112">  dt_iop_color_picker_t color_picker;</a>
<a name="ln113">} dt_iop_watermark_gui_data_t;</a>
<a name="ln114"> </a>
<a name="ln115">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln116">                  void *new_params, const int new_version)</a>
<a name="ln117">{</a>
<a name="ln118">  if(old_version == 1 &amp;&amp; new_version == 4)</a>
<a name="ln119">  {</a>
<a name="ln120">    typedef struct dt_iop_watermark_params_v1_t</a>
<a name="ln121">    {</a>
<a name="ln122">      /** opacity value of rendering watermark */</a>
<a name="ln123">      float opacity;</a>
<a name="ln124">      /** scale value of rendering watermark */</a>
<a name="ln125">      float scale;</a>
<a name="ln126">      /** Pixel independent xoffset, 0 to 1 */</a>
<a name="ln127">      float xoffset;</a>
<a name="ln128">      /** Pixel independent yoffset, 0 to 1 */</a>
<a name="ln129">      float yoffset;</a>
<a name="ln130">      /** Alignment value 0-8 3x3 */</a>
<a name="ln131">      int alignment;</a>
<a name="ln132">      char filename[64];</a>
<a name="ln133">    } dt_iop_watermark_params_v1_t;</a>
<a name="ln134"> </a>
<a name="ln135">    dt_iop_watermark_params_v1_t *o = (dt_iop_watermark_params_v1_t *)old_params;</a>
<a name="ln136">    dt_iop_watermark_params_t *n = (dt_iop_watermark_params_t *)new_params;</a>
<a name="ln137">    dt_iop_watermark_params_t *d = (dt_iop_watermark_params_t *)self-&gt;default_params;</a>
<a name="ln138"> </a>
<a name="ln139">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln140"> </a>
<a name="ln141">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln142">    n-&gt;scale = o-&gt;scale;</a>
<a name="ln143">    n-&gt;xoffset = o-&gt;xoffset;</a>
<a name="ln144">    n-&gt;yoffset = o-&gt;yoffset;</a>
<a name="ln145">    n-&gt;alignment = o-&gt;alignment;</a>
<a name="ln146">    n-&gt;rotate = 0.0;</a>
<a name="ln147">    n-&gt;sizeto = DT_SCALE_IMAGE;</a>
<a name="ln148">    g_strlcpy(n-&gt;filename, o-&gt;filename, sizeof(n-&gt;filename));</a>
<a name="ln149">    g_strlcpy(n-&gt;text, &quot;&quot;, sizeof(n-&gt;text));</a>
<a name="ln150">    g_strlcpy(n-&gt;font, &quot;DejaVu Sans 10&quot;, sizeof(n-&gt;font));</a>
<a name="ln151">    n-&gt;color[0] = n-&gt;color[1] = n-&gt;color[2] = 0;</a>
<a name="ln152"> </a>
<a name="ln153">    return 0;</a>
<a name="ln154">  }</a>
<a name="ln155">  else if(old_version == 2 &amp;&amp; new_version == 4)</a>
<a name="ln156">  {</a>
<a name="ln157">    typedef struct dt_iop_watermark_params_v2_t</a>
<a name="ln158">    {</a>
<a name="ln159">      /** opacity value of rendering watermark */</a>
<a name="ln160">      float opacity;</a>
<a name="ln161">      /** scale value of rendering watermark */</a>
<a name="ln162">      float scale;</a>
<a name="ln163">      /** Pixel independent xoffset, 0 to 1 */</a>
<a name="ln164">      float xoffset;</a>
<a name="ln165">      /** Pixel independent yoffset, 0 to 1 */</a>
<a name="ln166">      float yoffset;</a>
<a name="ln167">      /** Alignment value 0-8 3x3 */</a>
<a name="ln168">      int alignment;</a>
<a name="ln169">      dt_iop_watermark_base_scale_t sizeto;</a>
<a name="ln170">      char filename[64];</a>
<a name="ln171">    } dt_iop_watermark_params_v2_t;</a>
<a name="ln172"> </a>
<a name="ln173">    dt_iop_watermark_params_v2_t *o = (dt_iop_watermark_params_v2_t *)old_params;</a>
<a name="ln174">    dt_iop_watermark_params_t *n = (dt_iop_watermark_params_t *)new_params;</a>
<a name="ln175">    dt_iop_watermark_params_t *d = (dt_iop_watermark_params_t *)self-&gt;default_params;</a>
<a name="ln176"> </a>
<a name="ln177">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln178"> </a>
<a name="ln179">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln180">    n-&gt;scale = o-&gt;scale;</a>
<a name="ln181">    n-&gt;xoffset = o-&gt;xoffset;</a>
<a name="ln182">    n-&gt;yoffset = o-&gt;yoffset;</a>
<a name="ln183">    n-&gt;alignment = o-&gt;alignment;</a>
<a name="ln184">    n-&gt;rotate = 0.0;</a>
<a name="ln185">    n-&gt;sizeto = DT_SCALE_IMAGE;</a>
<a name="ln186">    g_strlcpy(n-&gt;filename, o-&gt;filename, sizeof(n-&gt;filename));</a>
<a name="ln187">    g_strlcpy(n-&gt;text, &quot;&quot;, sizeof(n-&gt;text));</a>
<a name="ln188">    g_strlcpy(n-&gt;font, &quot;DejaVu Sans 10&quot;, sizeof(n-&gt;font));</a>
<a name="ln189">    n-&gt;color[0] = n-&gt;color[1] = n-&gt;color[2] = 0;</a>
<a name="ln190">    return 0;</a>
<a name="ln191">  }</a>
<a name="ln192">  else if(old_version == 3 &amp;&amp; new_version == 4)</a>
<a name="ln193">  {</a>
<a name="ln194">    typedef struct dt_iop_watermark_params_v3_t</a>
<a name="ln195">    {</a>
<a name="ln196">      /** opacity value of rendering watermark */</a>
<a name="ln197">      float opacity;</a>
<a name="ln198">      /** scale value of rendering watermark */</a>
<a name="ln199">      float scale;</a>
<a name="ln200">      /** Pixel independent xoffset, 0 to 1 */</a>
<a name="ln201">      float xoffset;</a>
<a name="ln202">      /** Pixel independent yoffset, 0 to 1 */</a>
<a name="ln203">      float yoffset;</a>
<a name="ln204">      /** Alignment value 0-8 3x3 */</a>
<a name="ln205">      int alignment;</a>
<a name="ln206">      /** Rotation **/</a>
<a name="ln207">      float rotate;</a>
<a name="ln208">      dt_iop_watermark_base_scale_t sizeto;</a>
<a name="ln209">      char filename[64];</a>
<a name="ln210">    } dt_iop_watermark_params_v3_t;</a>
<a name="ln211"> </a>
<a name="ln212">    dt_iop_watermark_params_v3_t *o = (dt_iop_watermark_params_v3_t *)old_params;</a>
<a name="ln213">    dt_iop_watermark_params_t *n = (dt_iop_watermark_params_t *)new_params;</a>
<a name="ln214">    dt_iop_watermark_params_t *d = (dt_iop_watermark_params_t *)self-&gt;default_params;</a>
<a name="ln215"> </a>
<a name="ln216">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln217"> </a>
<a name="ln218">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln219">    n-&gt;scale = o-&gt;scale;</a>
<a name="ln220">    n-&gt;xoffset = o-&gt;xoffset;</a>
<a name="ln221">    n-&gt;yoffset = o-&gt;yoffset;</a>
<a name="ln222">    n-&gt;alignment = o-&gt;alignment;</a>
<a name="ln223">    n-&gt;rotate = o-&gt;rotate;</a>
<a name="ln224">    n-&gt;sizeto = o-&gt;sizeto;</a>
<a name="ln225">    g_strlcpy(n-&gt;filename, o-&gt;filename, sizeof(n-&gt;filename));</a>
<a name="ln226">    g_strlcpy(n-&gt;text, &quot;&quot;, sizeof(n-&gt;text));</a>
<a name="ln227">    g_strlcpy(n-&gt;font, &quot;DejaVu Sans 10&quot;, sizeof(n-&gt;font));</a>
<a name="ln228">    n-&gt;color[0] = n-&gt;color[1] = n-&gt;color[2] = 0;</a>
<a name="ln229">    return 0;</a>
<a name="ln230">  }</a>
<a name="ln231">  return 1;</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234"> </a>
<a name="ln235">const char *name()</a>
<a name="ln236">{</a>
<a name="ln237">  return _(&quot;watermark&quot;);</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">int flags()</a>
<a name="ln241">{</a>
<a name="ln242">  return IOP_FLAGS_INCLUDE_IN_STYLES | IOP_FLAGS_SUPPORTS_BLENDING;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">int default_group()</a>
<a name="ln246">{</a>
<a name="ln247">  return IOP_GROUP_EFFECT;</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">int operation_tags()</a>
<a name="ln251">{</a>
<a name="ln252">  return IOP_TAG_DECORATION;</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln256">{</a>
<a name="ln257">  dt_accel_register_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;refresh&quot;), 0, 0);</a>
<a name="ln258">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;opacity&quot;));</a>
<a name="ln259">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;scale&quot;));</a>
<a name="ln260">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;rotation&quot;));</a>
<a name="ln261">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;x offset&quot;));</a>
<a name="ln262">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;y offset&quot;));</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln266">{</a>
<a name="ln267">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln268"> </a>
<a name="ln269">  dt_accel_connect_button_iop(self, &quot;refresh&quot;, GTK_WIDGET(g-&gt;refresh));</a>
<a name="ln270">  dt_accel_connect_slider_iop(self, &quot;opacity&quot;, GTK_WIDGET(g-&gt;opacity));</a>
<a name="ln271">  dt_accel_connect_slider_iop(self, &quot;scale&quot;, GTK_WIDGET(g-&gt;scale));</a>
<a name="ln272">  dt_accel_connect_slider_iop(self, &quot;rotation&quot;, GTK_WIDGET(g-&gt;rotate));</a>
<a name="ln273">  dt_accel_connect_slider_iop(self, &quot;x offset&quot;, GTK_WIDGET(g-&gt;x_offset));</a>
<a name="ln274">  dt_accel_connect_slider_iop(self, &quot;y offset&quot;, GTK_WIDGET(g-&gt;y_offset));</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">static void _combo_box_set_active_text(dt_iop_watermark_gui_data_t *g, gchar *text)</a>
<a name="ln278">{</a>
<a name="ln279">  int i = 0;</a>
<a name="ln280">  for(const GList *iter = g-&gt;watermarks_filenames; iter; iter = g_list_next(iter))</a>
<a name="ln281">  {</a>
<a name="ln282">    if(!g_strcmp0((gchar *)iter-&gt;data, text))</a>
<a name="ln283">    {</a>
<a name="ln284">      dt_bauhaus_combobox_set(g-&gt;watermarks, i);</a>
<a name="ln285">      return;</a>
<a name="ln286">    }</a>
<a name="ln287">    i++;</a>
<a name="ln288">  }</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291">// replace &lt; and &gt; with &amp;lt; and &amp;gt;. any more? Yes! &amp; -&gt; &amp;amp;</a>
<a name="ln292">static gchar *_string_escape(const gchar *string)</a>
<a name="ln293">{</a>
<a name="ln294">  gchar *result;</a>
<a name="ln295">  result = dt_util_str_replace(string, &quot;&amp;&quot;, &quot;&amp;amp;&quot;);</a>
<a name="ln296">  result = dt_util_str_replace(result, &quot;&lt;&quot;, &quot;&amp;lt;&quot;);</a>
<a name="ln297">  result = dt_util_str_replace(result, &quot;&gt;&quot;, &quot;&amp;gt;&quot;);</a>
<a name="ln298">  return result;</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">static gchar *_string_substitute(gchar *string, const gchar *search, const gchar *replace)</a>
<a name="ln302">{</a>
<a name="ln303">  gchar *_replace = _string_escape(replace);</a>
<a name="ln304">  gchar *result = dt_util_str_replace(string, search, _replace);</a>
<a name="ln305">  g_free(_replace);</a>
<a name="ln306">  return result;</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">static gchar *_watermark_get_svgdoc(dt_iop_module_t *self, dt_iop_watermark_data_t *data,</a>
<a name="ln310">                                    const dt_image_t *image)</a>
<a name="ln311">{</a>
<a name="ln312">  gsize length;</a>
<a name="ln313"> </a>
<a name="ln314">  gchar *svgdoc = NULL;</a>
<a name="ln315">  gchar configdir[PATH_MAX] = { 0 };</a>
<a name="ln316">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln317">  gchar *filename;</a>
<a name="ln318">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln319">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln320">  g_strlcat(datadir, &quot;/watermarks/&quot;, sizeof(datadir));</a>
<a name="ln321">  g_strlcat(configdir, &quot;/watermarks/&quot;, sizeof(configdir));</a>
<a name="ln322">  g_strlcat(datadir, data-&gt;filename, sizeof(datadir));</a>
<a name="ln323">  g_strlcat(configdir, data-&gt;filename, sizeof(configdir));</a>
<a name="ln324"> </a>
<a name="ln325">  if(g_file_test(configdir, G_FILE_TEST_EXISTS))</a>
<a name="ln326">    filename = configdir;</a>
<a name="ln327">  else if(g_file_test(datadir, G_FILE_TEST_EXISTS))</a>
<a name="ln328">    filename = datadir;</a>
<a name="ln329">  else</a>
<a name="ln330">    return NULL;</a>
<a name="ln331"> </a>
<a name="ln332">  gchar *svgdata = NULL;</a>
<a name="ln333">  char datetime[200];</a>
<a name="ln334"> </a>
<a name="ln335">  // EXIF datetime</a>
<a name="ln336">  struct tm tt_exif = { 0 };</a>
<a name="ln337">  if(sscanf(image-&gt;exif_datetime_taken, &quot;%d:%d:%d %d:%d:%d&quot;, &amp;tt_exif.tm_year, &amp;tt_exif.tm_mon,</a>
<a name="ln338">            &amp;tt_exif.tm_mday, &amp;tt_exif.tm_hour, &amp;tt_exif.tm_min, &amp;tt_exif.tm_sec) == 6)</a>
<a name="ln339">  {</a>
<a name="ln340">    tt_exif.tm_year -= 1900;</a>
<a name="ln341">    tt_exif.tm_mon--;</a>
<a name="ln342">  }</a>
<a name="ln343"> </a>
<a name="ln344">  // Current datetime</a>
<a name="ln345">  struct tm tt_cur = { 0 };</a>
<a name="ln346">  time_t t = time(NULL);</a>
<a name="ln347">  (void)localtime_r(&amp;t, &amp;tt_cur);</a>
<a name="ln348"> </a>
<a name="ln349">  if(g_file_get_contents(filename, &amp;svgdata, &amp;length, NULL))</a>
<a name="ln350">  {</a>
<a name="ln351">    // File is loaded lets substitute strings if found...</a>
<a name="ln352"> </a>
<a name="ln353">    // Darktable internal</a>
<a name="ln354">    svgdoc = _string_substitute(svgdata, &quot;$(DARKTABLE.NAME)&quot;, PACKAGE_NAME);</a>
<a name="ln355">    if(svgdoc != svgdata)</a>
<a name="ln356">    {</a>
<a name="ln357">      g_free(svgdata);</a>
<a name="ln358">      svgdata = svgdoc;</a>
<a name="ln359">    }</a>
<a name="ln360">    svgdoc = _string_substitute(svgdata, &quot;$(DARKTABLE.VERSION)&quot;, darktable_package_version);</a>
<a name="ln361">    if(svgdoc != svgdata)</a>
<a name="ln362">    {</a>
<a name="ln363">      g_free(svgdata);</a>
<a name="ln364">      svgdata = svgdoc;</a>
<a name="ln365">    }</a>
<a name="ln366"> </a>
<a name="ln367">    // Simple text from watermark module</a>
<a name="ln368">    gchar buffer[1024];</a>
<a name="ln369"> </a>
<a name="ln370">    if (data-&gt;font[0] &amp;&amp; data-&gt;text[0])</a>
<a name="ln371">    {</a>
<a name="ln372">      g_snprintf(buffer, sizeof(buffer), &quot;%s&quot;, data-&gt;text);</a>
<a name="ln373">      svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_TEXT)&quot;, buffer);</a>
<a name="ln374">      if(svgdoc != svgdata)</a>
<a name="ln375">      {</a>
<a name="ln376">        g_free(svgdata);</a>
<a name="ln377">        svgdata = svgdoc;</a>
<a name="ln378">      }</a>
<a name="ln379"> </a>
<a name="ln380">      PangoFontDescription *font = pango_font_description_from_string(data-&gt;font);</a>
<a name="ln381">      const PangoStyle font_style = pango_font_description_get_style(font);</a>
<a name="ln382">      const int font_weight = (int)pango_font_description_get_weight(font);</a>
<a name="ln383"> </a>
<a name="ln384">      g_snprintf(buffer, sizeof(buffer), &quot;%s&quot;, pango_font_description_get_family(font));</a>
<a name="ln385">      svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_FONT_FAMILY)&quot;, buffer);</a>
<a name="ln386">      if(svgdoc != svgdata)</a>
<a name="ln387">      {</a>
<a name="ln388">        g_free(svgdata);</a>
<a name="ln389">        svgdata = svgdoc;</a>
<a name="ln390">      }</a>
<a name="ln391"> </a>
<a name="ln392">      switch (font_style)</a>
<a name="ln393">      {</a>
<a name="ln394">      case PANGO_STYLE_OBLIQUE:</a>
<a name="ln395">        g_strlcpy(buffer, &quot;oblique&quot;, sizeof(buffer));</a>
<a name="ln396">        break;</a>
<a name="ln397">      case PANGO_STYLE_ITALIC:</a>
<a name="ln398">        g_strlcpy(buffer, &quot;italic&quot;, sizeof(buffer));</a>
<a name="ln399">        break;</a>
<a name="ln400">      default:</a>
<a name="ln401">        g_strlcpy(buffer, &quot;normal&quot;, sizeof(buffer));</a>
<a name="ln402">        break;</a>
<a name="ln403">      }</a>
<a name="ln404">      svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_FONT_STYLE)&quot;, buffer);</a>
<a name="ln405">      if(svgdoc != svgdata)</a>
<a name="ln406">      {</a>
<a name="ln407">        g_free(svgdata);</a>
<a name="ln408">        svgdata = svgdoc;</a>
<a name="ln409">      }</a>
<a name="ln410"> </a>
<a name="ln411">      g_snprintf(buffer, sizeof(buffer), &quot;%d&quot;, font_weight);</a>
<a name="ln412">      svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_FONT_WEIGHT)&quot;, buffer);</a>
<a name="ln413">      if(svgdoc != svgdata)</a>
<a name="ln414">      {</a>
<a name="ln415">        g_free(svgdata);</a>
<a name="ln416">        svgdata = svgdoc;</a>
<a name="ln417">      }</a>
<a name="ln418"> </a>
<a name="ln419">      pango_font_description_free(font);</a>
<a name="ln420">    }</a>
<a name="ln421"> </a>
<a name="ln422">    // watermark color</a>
<a name="ln423">    GdkRGBA c = { data-&gt;color[0], data-&gt;color[1], data-&gt;color[2], 1.0f };</a>
<a name="ln424">    g_snprintf(buffer, sizeof(buffer), &quot;%s&quot;, gdk_rgba_to_string(&amp;c));</a>
<a name="ln425">    svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_COLOR)&quot;, buffer);</a>
<a name="ln426">    if(svgdoc != svgdata)</a>
<a name="ln427">    {</a>
<a name="ln428">      g_free(svgdata);</a>
<a name="ln429">      svgdata = svgdoc;</a>
<a name="ln430">    }</a>
<a name="ln431"> </a>
<a name="ln432">    // Current image ID</a>
<a name="ln433">    g_snprintf(buffer, sizeof(buffer), &quot;%d&quot;, image-&gt;id);</a>
<a name="ln434">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.ID)&quot;, buffer);</a>
<a name="ln435">    if(svgdoc != svgdata)</a>
<a name="ln436">    {</a>
<a name="ln437">      g_free(svgdata);</a>
<a name="ln438">      svgdata = svgdoc;</a>
<a name="ln439">    }</a>
<a name="ln440"> </a>
<a name="ln441">    // Current image</a>
<a name="ln442">    dt_image_print_exif(image, buffer, sizeof(buffer));</a>
<a name="ln443">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.EXIF)&quot;, buffer);</a>
<a name="ln444">    if(svgdoc != svgdata)</a>
<a name="ln445">    {</a>
<a name="ln446">      g_free(svgdata);</a>
<a name="ln447">      svgdata = svgdoc;</a>
<a name="ln448">    }</a>
<a name="ln449"> </a>
<a name="ln450">    // Image exif</a>
<a name="ln451">    // EXIF date</a>
<a name="ln452">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE)&quot;, image-&gt;exif_datetime_taken);</a>
<a name="ln453">    if(svgdoc != svgdata)</a>
<a name="ln454">    {</a>
<a name="ln455">      g_free(svgdata);</a>
<a name="ln456">      svgdata = svgdoc;</a>
<a name="ln457">    }</a>
<a name="ln458">    // $(EXIF.DATE.SECOND) -- 00..60</a>
<a name="ln459">    strftime(datetime, sizeof(datetime), &quot;%S&quot;, &amp;tt_exif);</a>
<a name="ln460">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.SECOND)&quot;, datetime);</a>
<a name="ln461">    if(svgdoc != svgdata)</a>
<a name="ln462">    {</a>
<a name="ln463">      g_free(svgdata);</a>
<a name="ln464">      svgdata = svgdoc;</a>
<a name="ln465">    }</a>
<a name="ln466">    // $(EXIF.DATE.MINUTE) -- 00..59</a>
<a name="ln467">    strftime(datetime, sizeof(datetime), &quot;%M&quot;, &amp;tt_exif);</a>
<a name="ln468">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.MINUTE)&quot;, datetime);</a>
<a name="ln469">    if(svgdoc != svgdata)</a>
<a name="ln470">    {</a>
<a name="ln471">      g_free(svgdata);</a>
<a name="ln472">      svgdata = svgdoc;</a>
<a name="ln473">    }</a>
<a name="ln474">    // $(EXIF.DATE.HOUR) -- 00..23</a>
<a name="ln475">    strftime(datetime, sizeof(datetime), &quot;%H&quot;, &amp;tt_exif);</a>
<a name="ln476">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.HOUR)&quot;, datetime);</a>
<a name="ln477">    if(svgdoc != svgdata)</a>
<a name="ln478">    {</a>
<a name="ln479">      g_free(svgdata);</a>
<a name="ln480">      svgdata = svgdoc;</a>
<a name="ln481">    }</a>
<a name="ln482">    // $(EXIF.DATE.HOUR_AMPM) -- 01..12</a>
<a name="ln483">    strftime(datetime, sizeof(datetime), &quot;%I %p&quot;, &amp;tt_exif);</a>
<a name="ln484">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.HOUR_AMPM)&quot;, datetime);</a>
<a name="ln485">    if(svgdoc != svgdata)</a>
<a name="ln486">    {</a>
<a name="ln487">      g_free(svgdata);</a>
<a name="ln488">      svgdata = svgdoc;</a>
<a name="ln489">    }</a>
<a name="ln490">    // $(EXIF.DATE.DAY) -- 01..31</a>
<a name="ln491">    strftime(datetime, sizeof(datetime), &quot;%d&quot;, &amp;tt_exif);</a>
<a name="ln492">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.DAY)&quot;, datetime);</a>
<a name="ln493">    if(svgdoc != svgdata)</a>
<a name="ln494">    {</a>
<a name="ln495">      g_free(svgdata);</a>
<a name="ln496">      svgdata = svgdoc;</a>
<a name="ln497">    }</a>
<a name="ln498">    // $(EXIF.DATE.MONTH) -- 01..12</a>
<a name="ln499">    strftime(datetime, sizeof(datetime), &quot;%m&quot;, &amp;tt_exif);</a>
<a name="ln500">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.MONTH)&quot;, datetime);</a>
<a name="ln501">    if(svgdoc != svgdata)</a>
<a name="ln502">    {</a>
<a name="ln503">      g_free(svgdata);</a>
<a name="ln504">      svgdata = svgdoc;</a>
<a name="ln505">    }</a>
<a name="ln506">    // $(EXIF.DATE.SHORT_MONTH) -- Jan, Feb, .., Dec, localized</a>
<a name="ln507">    strftime(datetime, sizeof(datetime), &quot;%b&quot;, &amp;tt_exif);</a>
<a name="ln508">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.SHORT_MONTH)&quot;, datetime);</a>
<a name="ln509">    if(svgdoc != svgdata)</a>
<a name="ln510">    {</a>
<a name="ln511">      g_free(svgdata);</a>
<a name="ln512">      svgdata = svgdoc;</a>
<a name="ln513">    }</a>
<a name="ln514">    // $(EXIF.DATE.LONG_MONTH) -- January, February, .., December, localized</a>
<a name="ln515">    strftime(datetime, sizeof(datetime), &quot;%B&quot;, &amp;tt_exif);</a>
<a name="ln516">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.LONG_MONTH)&quot;, datetime);</a>
<a name="ln517">    if(svgdoc != svgdata)</a>
<a name="ln518">    {</a>
<a name="ln519">      g_free(svgdata);</a>
<a name="ln520">      svgdata = svgdoc;</a>
<a name="ln521">    }</a>
<a name="ln522">    // $(EXIF.DATE.SHORT_YEAR) -- 12</a>
<a name="ln523">    strftime(datetime, sizeof(datetime), &quot;%y&quot;, &amp;tt_exif);</a>
<a name="ln524">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.SHORT_YEAR)&quot;, datetime);</a>
<a name="ln525">    if(svgdoc != svgdata)</a>
<a name="ln526">    {</a>
<a name="ln527">      g_free(svgdata);</a>
<a name="ln528">      svgdata = svgdoc;</a>
<a name="ln529">    }</a>
<a name="ln530">    // $(EXIF.DATE.LONG_YEAR) -- 2012</a>
<a name="ln531">    strftime(datetime, sizeof(datetime), &quot;%Y&quot;, &amp;tt_exif);</a>
<a name="ln532">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.LONG_YEAR)&quot;, datetime);</a>
<a name="ln533">    if(svgdoc != svgdata)</a>
<a name="ln534">    {</a>
<a name="ln535">      g_free(svgdata);</a>
<a name="ln536">      svgdata = svgdoc;</a>
<a name="ln537">    }</a>
<a name="ln538"> </a>
<a name="ln539">    // Current date</a>
<a name="ln540">    // $(DATE) -- YYYY:</a>
<a name="ln541">    dt_gettime_t(datetime, sizeof(datetime), t);</a>
<a name="ln542">    svgdoc = _string_substitute(svgdata, &quot;$(DATE)&quot;, datetime);</a>
<a name="ln543">    if(svgdoc != svgdata)</a>
<a name="ln544">    {</a>
<a name="ln545">      g_free(svgdata);</a>
<a name="ln546">      svgdata = svgdoc;</a>
<a name="ln547">    }</a>
<a name="ln548">    // $(DATE.SECOND) -- 00..60</a>
<a name="ln549">    strftime(datetime, sizeof(datetime), &quot;%S&quot;, &amp;tt_cur);</a>
<a name="ln550">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.SECOND)&quot;, datetime);</a>
<a name="ln551">    if(svgdoc != svgdata)</a>
<a name="ln552">    {</a>
<a name="ln553">      g_free(svgdata);</a>
<a name="ln554">      svgdata = svgdoc;</a>
<a name="ln555">    }</a>
<a name="ln556">    // $(DATE.MINUTE) -- 00..59</a>
<a name="ln557">    strftime(datetime, sizeof(datetime), &quot;%M&quot;, &amp;tt_cur);</a>
<a name="ln558">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.MINUTE)&quot;, datetime);</a>
<a name="ln559">    if(svgdoc != svgdata)</a>
<a name="ln560">    {</a>
<a name="ln561">      g_free(svgdata);</a>
<a name="ln562">      svgdata = svgdoc;</a>
<a name="ln563">    }</a>
<a name="ln564">    // $(DATE.HOUR) -- 00..23</a>
<a name="ln565">    strftime(datetime, sizeof(datetime), &quot;%H&quot;, &amp;tt_cur);</a>
<a name="ln566">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.HOUR)&quot;, datetime);</a>
<a name="ln567">    if(svgdoc != svgdata)</a>
<a name="ln568">    {</a>
<a name="ln569">      g_free(svgdata);</a>
<a name="ln570">      svgdata = svgdoc;</a>
<a name="ln571">    }</a>
<a name="ln572">    // $(DATE.HOUR_AMPM) -- 01..12</a>
<a name="ln573">    strftime(datetime, sizeof(datetime), &quot;%I %p&quot;, &amp;tt_cur);</a>
<a name="ln574">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.HOUR_AMPM)&quot;, datetime);</a>
<a name="ln575">    if(svgdoc != svgdata)</a>
<a name="ln576">    {</a>
<a name="ln577">      g_free(svgdata);</a>
<a name="ln578">      svgdata = svgdoc;</a>
<a name="ln579">    }</a>
<a name="ln580">    // $(DATE.DAY) -- 01..31</a>
<a name="ln581">    strftime(datetime, sizeof(datetime), &quot;%d&quot;, &amp;tt_cur);</a>
<a name="ln582">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.DAY)&quot;, datetime);</a>
<a name="ln583">    if(svgdoc != svgdata)</a>
<a name="ln584">    {</a>
<a name="ln585">      g_free(svgdata);</a>
<a name="ln586">      svgdata = svgdoc;</a>
<a name="ln587">    }</a>
<a name="ln588">    // $(DATE.MONTH) -- 01..12</a>
<a name="ln589">    strftime(datetime, sizeof(datetime), &quot;%m&quot;, &amp;tt_cur);</a>
<a name="ln590">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.MONTH)&quot;, datetime);</a>
<a name="ln591">    if(svgdoc != svgdata)</a>
<a name="ln592">    {</a>
<a name="ln593">      g_free(svgdata);</a>
<a name="ln594">      svgdata = svgdoc;</a>
<a name="ln595">    }</a>
<a name="ln596">    // $(DATE.SHORT_MONTH) -- Jan, Feb, .., Dec, localized</a>
<a name="ln597">    strftime(datetime, sizeof(datetime), &quot;%b&quot;, &amp;tt_cur);</a>
<a name="ln598">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.SHORT_MONTH)&quot;, datetime);</a>
<a name="ln599">    if(svgdoc != svgdata)</a>
<a name="ln600">    {</a>
<a name="ln601">      g_free(svgdata);</a>
<a name="ln602">      svgdata = svgdoc;</a>
<a name="ln603">    }</a>
<a name="ln604">    // $(DATE.LONG_MONTH) -- January, February, .., December, localized</a>
<a name="ln605">    strftime(datetime, sizeof(datetime), &quot;%B&quot;, &amp;tt_cur);</a>
<a name="ln606">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.LONG_MONTH)&quot;, datetime);</a>
<a name="ln607">    if(svgdoc != svgdata)</a>
<a name="ln608">    {</a>
<a name="ln609">      g_free(svgdata);</a>
<a name="ln610">      svgdata = svgdoc;</a>
<a name="ln611">    }</a>
<a name="ln612">    // $(DATE.SHORT_YEAR) -- 12</a>
<a name="ln613">    strftime(datetime, sizeof(datetime), &quot;%y&quot;, &amp;tt_cur);</a>
<a name="ln614">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.SHORT_YEAR)&quot;, datetime);</a>
<a name="ln615">    if(svgdoc != svgdata)</a>
<a name="ln616">    {</a>
<a name="ln617">      g_free(svgdata);</a>
<a name="ln618">      svgdata = svgdoc;</a>
<a name="ln619">    }</a>
<a name="ln620">    // $(DATE.LONG_YEAR) -- 2012</a>
<a name="ln621">    strftime(datetime, sizeof(datetime), &quot;%Y&quot;, &amp;tt_cur);</a>
<a name="ln622">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.LONG_YEAR)&quot;, datetime);</a>
<a name="ln623">    if(svgdoc != svgdata)</a>
<a name="ln624">    {</a>
<a name="ln625">      g_free(svgdata);</a>
<a name="ln626">      svgdata = svgdoc;</a>
<a name="ln627">    }</a>
<a name="ln628"> </a>
<a name="ln629">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.MAKER)&quot;, image-&gt;camera_maker);</a>
<a name="ln630">    if(svgdoc != svgdata)</a>
<a name="ln631">    {</a>
<a name="ln632">      g_free(svgdata);</a>
<a name="ln633">      svgdata = svgdoc;</a>
<a name="ln634">    }</a>
<a name="ln635">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.MODEL)&quot;, image-&gt;camera_model);</a>
<a name="ln636">    if(svgdoc != svgdata)</a>
<a name="ln637">    {</a>
<a name="ln638">      g_free(svgdata);</a>
<a name="ln639">      svgdata = svgdoc;</a>
<a name="ln640">    }</a>
<a name="ln641">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.LENS)&quot;, image-&gt;exif_lens);</a>
<a name="ln642">    if(svgdoc != svgdata)</a>
<a name="ln643">    {</a>
<a name="ln644">      g_free(svgdata);</a>
<a name="ln645">      svgdata = svgdoc;</a>
<a name="ln646">    }</a>
<a name="ln647"> </a>
<a name="ln648">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.FILENAME)&quot;, image-&gt;filename);</a>
<a name="ln649">    if(svgdoc != svgdata)</a>
<a name="ln650">    {</a>
<a name="ln651">      g_free(svgdata);</a>
<a name="ln652">      svgdata = svgdoc;</a>
<a name="ln653">    }</a>
<a name="ln654"> </a>
<a name="ln655">    gchar *basename = g_path_get_basename(image-&gt;filename);</a>
<a name="ln656">    if(g_strrstr(basename, &quot;.&quot;)) *(g_strrstr(basename, &quot;.&quot;)) = '\0';</a>
<a name="ln657">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.BASENAME)&quot;, basename);</a>
<a name="ln658">    if(svgdoc != svgdata)</a>
<a name="ln659">    {</a>
<a name="ln660">      g_free(svgdata);</a>
<a name="ln661">      svgdata = svgdoc;</a>
<a name="ln662">    }</a>
<a name="ln663">    g_free(basename);</a>
<a name="ln664"> </a>
<a name="ln665">    // TODO: auto generate that code?</a>
<a name="ln666">    GList *res;</a>
<a name="ln667">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.creator&quot;, NULL);</a>
<a name="ln668">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.creator)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln669">    if(svgdoc != svgdata)</a>
<a name="ln670">    {</a>
<a name="ln671">      g_free(svgdata);</a>
<a name="ln672">      svgdata = svgdoc;</a>
<a name="ln673">    }</a>
<a name="ln674">    if(res)</a>
<a name="ln675">    {</a>
<a name="ln676">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln677">    }</a>
<a name="ln678"> </a>
<a name="ln679">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.publisher&quot;, NULL);</a>
<a name="ln680">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.publisher)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln681">    if(svgdoc != svgdata)</a>
<a name="ln682">    {</a>
<a name="ln683">      g_free(svgdata);</a>
<a name="ln684">      svgdata = svgdoc;</a>
<a name="ln685">    }</a>
<a name="ln686">    if(res)</a>
<a name="ln687">    {</a>
<a name="ln688">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln689">    }</a>
<a name="ln690"> </a>
<a name="ln691">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.title&quot;, NULL);</a>
<a name="ln692">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.title)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln693">    if(svgdoc != svgdata)</a>
<a name="ln694">    {</a>
<a name="ln695">      g_free(svgdata);</a>
<a name="ln696">      svgdata = svgdoc;</a>
<a name="ln697">    }</a>
<a name="ln698">    if(res)</a>
<a name="ln699">    {</a>
<a name="ln700">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln701">    }</a>
<a name="ln702"> </a>
<a name="ln703">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.description&quot;, NULL);</a>
<a name="ln704">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.description)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln705">    if(svgdoc != svgdata)</a>
<a name="ln706">    {</a>
<a name="ln707">      g_free(svgdata);</a>
<a name="ln708">      svgdata = svgdoc;</a>
<a name="ln709">    }</a>
<a name="ln710">    if(res)</a>
<a name="ln711">    {</a>
<a name="ln712">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln713">    }</a>
<a name="ln714"> </a>
<a name="ln715">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.rights&quot;, NULL);</a>
<a name="ln716">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.rights)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln717">    if(svgdoc != svgdata)</a>
<a name="ln718">    {</a>
<a name="ln719">      g_free(svgdata);</a>
<a name="ln720">      svgdata = svgdoc;</a>
<a name="ln721">    }</a>
<a name="ln722">    if(res)</a>
<a name="ln723">    {</a>
<a name="ln724">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln725">    }</a>
<a name="ln726"> </a>
<a name="ln727">    res = dt_tag_get_list(image-&gt;id);</a>
<a name="ln728">    gchar *keywords = dt_util_glist_to_str(&quot;, &quot;, res);</a>
<a name="ln729">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.TAGS)&quot;, (keywords ? keywords : &quot;&quot;));</a>
<a name="ln730">    if(svgdoc != svgdata)</a>
<a name="ln731">    {</a>
<a name="ln732">      g_free(svgdata);</a>
<a name="ln733">      svgdata = svgdoc;</a>
<a name="ln734">    }</a>
<a name="ln735">    g_free(keywords);</a>
<a name="ln736">    if(res)</a>
<a name="ln737">    {</a>
<a name="ln738">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln739">    }</a>
<a name="ln740"> </a>
<a name="ln741">    const int stars = image-&gt;flags &amp; 0x7;</a>
<a name="ln742">    const char *const rating_str[] = { &quot;☆☆☆☆☆&quot;, &quot;★☆☆☆☆&quot;, &quot;★★☆☆☆&quot;, &quot;★★★☆☆&quot;, &quot;★★★★☆&quot;, &quot;★★★★★&quot;, &quot;❌&quot;, &quot;&quot; };</a>
<a name="ln743">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.xmp.Rating)&quot;, rating_str[stars]);</a>
<a name="ln744">    if(svgdoc != svgdata)</a>
<a name="ln745">    {</a>
<a name="ln746">      g_free(svgdata);</a>
<a name="ln747">      svgdata = svgdoc;</a>
<a name="ln748">    }</a>
<a name="ln749"> </a>
<a name="ln750">    // geolocation</a>
<a name="ln751">    gchar *latitude = NULL, *longitude = NULL, *elevation = NULL;</a>
<a name="ln752">    if(dt_conf_get_bool(&quot;plugins/lighttable/metadata_view/pretty_location&quot;))</a>
<a name="ln753">    {</a>
<a name="ln754">      latitude = dt_util_latitude_str(image-&gt;latitude);</a>
<a name="ln755">      longitude = dt_util_longitude_str(image-&gt;longitude);</a>
<a name="ln756">      elevation = dt_util_elevation_str(image-&gt;elevation);</a>
<a name="ln757">    }</a>
<a name="ln758">    else</a>
<a name="ln759">    {</a>
<a name="ln760">      const gchar NS = image-&gt;latitude &lt; 0 ? 'S' : 'N';</a>
<a name="ln761">      const gchar EW = image-&gt;longitude &lt; 0 ? 'W' : 'E';</a>
<a name="ln762">      if(image-&gt;latitude) latitude = g_strdup_printf(&quot;%c %09.6f&quot;, NS, fabs(image-&gt;latitude));</a>
<a name="ln763">      if(image-&gt;longitude) longitude = g_strdup_printf(&quot;%c %010.6f&quot;, EW, fabs(image-&gt;longitude));</a>
<a name="ln764">      if(image-&gt;elevation) elevation = g_strdup_printf(&quot;%.2f %s&quot;, image-&gt;elevation, _(&quot;m&quot;));</a>
<a name="ln765">    }</a>
<a name="ln766">    gchar *parts[4] = { 0 };</a>
<a name="ln767">    int i = 0;</a>
<a name="ln768">    if(latitude) parts[i++] = latitude;</a>
<a name="ln769">    if(longitude) parts[i++] = longitude;</a>
<a name="ln770">    if(elevation) parts[i++] = elevation;</a>
<a name="ln771">    gchar *location = g_strjoinv(&quot;, &quot;, parts);</a>
<a name="ln772">    svgdoc = _string_substitute(svgdata, &quot;$(GPS.LATITUDE)&quot;, (latitude ? latitude : &quot;-&quot;));</a>
<a name="ln773">    if(svgdoc != svgdata)</a>
<a name="ln774">    {</a>
<a name="ln775">      g_free(svgdata);</a>
<a name="ln776">      svgdata = svgdoc;</a>
<a name="ln777">    }</a>
<a name="ln778">    svgdoc = _string_substitute(svgdata, &quot;$(GPS.LONGITUDE)&quot;, (longitude ? longitude : &quot;-&quot;));</a>
<a name="ln779">    if(svgdoc != svgdata)</a>
<a name="ln780">    {</a>
<a name="ln781">      g_free(svgdata);</a>
<a name="ln782">      svgdata = svgdoc;</a>
<a name="ln783">    }</a>
<a name="ln784">    svgdoc = _string_substitute(svgdata, &quot;$(GPS.ELEVATION)&quot;, (elevation ? elevation : &quot;-&quot;));</a>
<a name="ln785">    if(svgdoc != svgdata)</a>
<a name="ln786">    {</a>
<a name="ln787">      g_free(svgdata);</a>
<a name="ln788">      svgdata = svgdoc;</a>
<a name="ln789">    }</a>
<a name="ln790">    svgdoc = _string_substitute(svgdata, &quot;$(GPS.LOCATION)&quot;, location);</a>
<a name="ln791">    if(svgdoc != svgdata)</a>
<a name="ln792">    {</a>
<a name="ln793">      g_free(svgdata);</a>
<a name="ln794">      svgdata = svgdoc;</a>
<a name="ln795">    }</a>
<a name="ln796">    g_free(latitude);</a>
<a name="ln797">    g_free(longitude);</a>
<a name="ln798">    g_free(elevation);</a>
<a name="ln799">    g_free(location);</a>
<a name="ln800"> </a>
<a name="ln801">  }</a>
<a name="ln802">  return svgdoc;</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln806">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln807">{</a>
<a name="ln808">  dt_iop_watermark_data_t *data = (dt_iop_watermark_data_t *)piece-&gt;data;</a>
<a name="ln809">  float *in = (float *)ivoid;</a>
<a name="ln810">  float *out = (float *)ovoid;</a>
<a name="ln811">  const int ch = piece-&gt;colors;</a>
<a name="ln812">  double angle = (M_PI / 180) * -data-&gt;rotate;</a>
<a name="ln813"> </a>
<a name="ln814">  /* Load svg if not loaded */</a>
<a name="ln815">  gchar *svgdoc = _watermark_get_svgdoc(self, data, &amp;piece-&gt;pipe-&gt;image);</a>
<a name="ln816">  if(!svgdoc)</a>
<a name="ln817">  {</a>
<a name="ln818">    memcpy(ovoid, ivoid, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln819">    return;</a>
<a name="ln820">  }</a>
<a name="ln821"> </a>
<a name="ln822">  /* setup stride for performance */</a>
<a name="ln823">  int stride = cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, roi_out-&gt;width);</a>
<a name="ln824"> </a>
<a name="ln825">  /* create cairo memory surface */</a>
<a name="ln826">  guint8 *image = (guint8 *)g_malloc0_n(roi_out-&gt;height, stride);</a>
<a name="ln827">  cairo_surface_t *surface = cairo_image_surface_create_for_data(image, CAIRO_FORMAT_ARGB32, roi_out-&gt;width,</a>
<a name="ln828">                                                                 roi_out-&gt;height, stride);</a>
<a name="ln829">  if(cairo_surface_status(surface) != CAIRO_STATUS_SUCCESS)</a>
<a name="ln830">  {</a>
<a name="ln831">    //   fprintf(stderr,&quot;Cairo surface error: %s\n&quot;,cairo_status_to_string(cairo_surface_status(surface)));</a>
<a name="ln832">    g_free(image);</a>
<a name="ln833">    memcpy(ovoid, ivoid, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln834">    return;</a>
<a name="ln835">  }</a>
<a name="ln836"> </a>
<a name="ln837">  /* create cairo context and setup transformation/scale */</a>
<a name="ln838">  cairo_t *cr = cairo_create(surface);</a>
<a name="ln839"> </a>
<a name="ln840">  // rsvg (or some part of cairo which is used underneath) isn't thread safe, for example when handling fonts</a>
<a name="ln841">  dt_pthread_mutex_lock(&amp;darktable.plugin_threadsafe);</a>
<a name="ln842"> </a>
<a name="ln843">  /* create the rsvghandle from parsed svg data */</a>
<a name="ln844">  GError *error = NULL;</a>
<a name="ln845">  RsvgHandle *svg = rsvg_handle_new_from_data((const guint8 *)svgdoc, strlen(svgdoc), &amp;error);</a>
<a name="ln846">  g_free(svgdoc);</a>
<a name="ln847">  if(!svg || error)</a>
<a name="ln848">  {</a>
<a name="ln849">    g_free(image);</a>
<a name="ln850">    memcpy(ovoid, ivoid, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln851">    dt_pthread_mutex_unlock(&amp;darktable.plugin_threadsafe);</a>
<a name="ln852">    fprintf(stderr, &quot;[watermark] error processing svg file: %s\n&quot;, error-&gt;message);</a>
<a name="ln853">    g_error_free(error);</a>
<a name="ln854">    return;</a>
<a name="ln855">  }</a>
<a name="ln856"> </a>
<a name="ln857">  /* get the dimension of svg */</a>
<a name="ln858">  RsvgDimensionData dimension;</a>
<a name="ln859">  rsvg_handle_get_dimensions(svg, &amp;dimension);</a>
<a name="ln860"> </a>
<a name="ln861">  //  width/height of current (possibly cropped) image</a>
<a name="ln862">  const float iw = piece-&gt;buf_in.width;</a>
<a name="ln863">  const float ih = piece-&gt;buf_in.height;</a>
<a name="ln864">  const float uscale = data-&gt;scale / 100.0; // user scale, from GUI in percent</a>
<a name="ln865"> </a>
<a name="ln866">  // wbase, hbase are the base width and height, this is the multiplicator used for the offset computing</a>
<a name="ln867">  // scale is the scale of the watermark itself and is used only to render it.</a>
<a name="ln868"> </a>
<a name="ln869">  float wbase, hbase, scale;</a>
<a name="ln870"> </a>
<a name="ln871">  if(data-&gt;sizeto == DT_SCALE_IMAGE)</a>
<a name="ln872">  {</a>
<a name="ln873">    // in image mode, the wbase and hbase are just the image width and height</a>
<a name="ln874">    wbase = iw;</a>
<a name="ln875">    hbase = ih;</a>
<a name="ln876">    if(dimension.width &gt; dimension.height)</a>
<a name="ln877">      scale = (iw * roi_out-&gt;scale) / dimension.width;</a>
<a name="ln878">    else</a>
<a name="ln879">      scale = (ih * roi_out-&gt;scale) / dimension.height;</a>
<a name="ln880">  }</a>
<a name="ln881">  else</a>
<a name="ln882">  {</a>
<a name="ln883">    // in larger/smaller side mode, set wbase and hbase to the largest or smallest side of the image</a>
<a name="ln884">    float larger;</a>
<a name="ln885">    if(dimension.width &gt; dimension.height)</a>
<a name="ln886">      larger = (float)dimension.width;</a>
<a name="ln887">    else</a>
<a name="ln888">      larger = (float)dimension.height;</a>
<a name="ln889"> </a>
<a name="ln890">    if(iw &gt; ih)</a>
<a name="ln891">    {</a>
<a name="ln892">      wbase = hbase = (data-&gt;sizeto == DT_SCALE_LARGER_BORDER) ? iw : ih;</a>
<a name="ln893">      scale = (data-&gt;sizeto == DT_SCALE_LARGER_BORDER) ? (iw / larger) : (ih / larger);</a>
<a name="ln894">    }</a>
<a name="ln895">    else</a>
<a name="ln896">    {</a>
<a name="ln897">      wbase = hbase = (data-&gt;sizeto == DT_SCALE_SMALLER_BORDER) ? iw : ih;</a>
<a name="ln898">      scale = (data-&gt;sizeto == DT_SCALE_SMALLER_BORDER) ? (iw / larger) : (ih / larger);</a>
<a name="ln899">    }</a>
<a name="ln900">    scale *= roi_out-&gt;scale;</a>
<a name="ln901">  }</a>
<a name="ln902"> </a>
<a name="ln903">  scale *= uscale;</a>
<a name="ln904"> </a>
<a name="ln905">  // compute the width and height of the SVG object in image dimension. This is only used to properly</a>
<a name="ln906">  // layout the watermark based on the alignment.</a>
<a name="ln907"> </a>
<a name="ln908">  float svg_width, svg_height;</a>
<a name="ln909"> </a>
<a name="ln910">  if(dimension.width &gt; dimension.height)</a>
<a name="ln911">  {</a>
<a name="ln912">    if(data-&gt;sizeto == DT_SCALE_IMAGE || (iw &gt; ih &amp;&amp; data-&gt;sizeto == DT_SCALE_LARGER_BORDER)</a>
<a name="ln913">       || (iw &lt; ih &amp;&amp; data-&gt;sizeto == DT_SCALE_SMALLER_BORDER))</a>
<a name="ln914">    {</a>
<a name="ln915">      svg_width = iw * uscale;</a>
<a name="ln916">      svg_height = dimension.height * (svg_width / dimension.width);</a>
<a name="ln917">    }</a>
<a name="ln918">    else</a>
<a name="ln919">    {</a>
<a name="ln920">      svg_width = ih * uscale;</a>
<a name="ln921">      svg_height = dimension.height * (svg_width / dimension.width);</a>
<a name="ln922">    }</a>
<a name="ln923">  }</a>
<a name="ln924">  else</a>
<a name="ln925">  {</a>
<a name="ln926">    if(data-&gt;sizeto == DT_SCALE_IMAGE || (ih &gt; iw &amp;&amp; data-&gt;sizeto == DT_SCALE_LARGER_BORDER)</a>
<a name="ln927">       || (ih &lt; iw &amp;&amp; data-&gt;sizeto == DT_SCALE_SMALLER_BORDER))</a>
<a name="ln928">    {</a>
<a name="ln929">      svg_height = ih * uscale;</a>
<a name="ln930">      svg_width = dimension.width * (svg_height / dimension.height);</a>
<a name="ln931">    }</a>
<a name="ln932">    else</a>
<a name="ln933">    {</a>
<a name="ln934">      svg_height = iw * uscale;</a>
<a name="ln935">      svg_width = dimension.width * (svg_height / dimension.height);</a>
<a name="ln936">    }</a>
<a name="ln937">  }</a>
<a name="ln938"> </a>
<a name="ln939">  // compute bounding box of rotated watermark</a>
<a name="ln940">  float bb_width, bb_height;</a>
<a name="ln941">  bb_width = fabs(svg_width * cos(angle)) + fabs(svg_height * sin(angle));</a>
<a name="ln942">  bb_height = fabs(svg_width * sin(angle)) + fabs(svg_height * cos(angle));</a>
<a name="ln943">  float bX = bb_width / 2.0 - svg_width / 2.0;</a>
<a name="ln944">  float bY = bb_height / 2.0 - svg_height / 2.0;</a>
<a name="ln945"> </a>
<a name="ln946">  // compute translation for the given alignment in image dimension</a>
<a name="ln947"> </a>
<a name="ln948">  float ty = 0, tx = 0;</a>
<a name="ln949">  if(data-&gt;alignment &gt;= 0 &amp;&amp; data-&gt;alignment &lt; 3) // Align to verttop</a>
<a name="ln950">    ty = bY;</a>
<a name="ln951">  else if(data-&gt;alignment &gt;= 3 &amp;&amp; data-&gt;alignment &lt; 6) // Align to vertcenter</a>
<a name="ln952">    ty = (ih / 2.0) - (svg_height / 2.0);</a>
<a name="ln953">  else if(data-&gt;alignment &gt;= 6 &amp;&amp; data-&gt;alignment &lt; 9) // Align to vertbottom</a>
<a name="ln954">    ty = ih - svg_height - bY;</a>
<a name="ln955"> </a>
<a name="ln956">  if(data-&gt;alignment == 0 || data-&gt;alignment == 3 || data-&gt;alignment == 6)</a>
<a name="ln957">    tx = bX;</a>
<a name="ln958">  else if(data-&gt;alignment == 1 || data-&gt;alignment == 4 || data-&gt;alignment == 7)</a>
<a name="ln959">    tx = (iw / 2.0) - (svg_width / 2.0);</a>
<a name="ln960">  else if(data-&gt;alignment == 2 || data-&gt;alignment == 5 || data-&gt;alignment == 8)</a>
<a name="ln961">    tx = iw - svg_width - bX;</a>
<a name="ln962"> </a>
<a name="ln963">  // translate to position</a>
<a name="ln964">  cairo_translate(cr, -roi_in-&gt;x, -roi_in-&gt;y);</a>
<a name="ln965"> </a>
<a name="ln966">  // add translation for the given value in GUI (xoffset,yoffset)</a>
<a name="ln967">  tx += data-&gt;xoffset * wbase;</a>
<a name="ln968">  ty += data-&gt;yoffset * hbase;</a>
<a name="ln969"> </a>
<a name="ln970">  cairo_translate(cr, tx * roi_out-&gt;scale, ty * roi_out-&gt;scale);</a>
<a name="ln971"> </a>
<a name="ln972">  // compute the center of the svg to rotate from the center</a>
<a name="ln973">  float cX = svg_width / 2.0 * roi_out-&gt;scale;</a>
<a name="ln974">  float cY = svg_height / 2.0 * roi_out-&gt;scale;</a>
<a name="ln975"> </a>
<a name="ln976">  cairo_translate(cr, cX, cY);</a>
<a name="ln977">  cairo_rotate(cr, angle);</a>
<a name="ln978">  cairo_translate(cr, -cX, -cY);</a>
<a name="ln979"> </a>
<a name="ln980">  // now set proper scale for the watermark itself</a>
<a name="ln981">  cairo_scale(cr, scale, scale);</a>
<a name="ln982"> </a>
<a name="ln983">  /* render svg into surface*/</a>
<a name="ln984">  rsvg_handle_render_cairo(svg, cr);</a>
<a name="ln985"> </a>
<a name="ln986">  // no more non-thread safe rsvg usage</a>
<a name="ln987">  dt_pthread_mutex_unlock(&amp;darktable.plugin_threadsafe);</a>
<a name="ln988"> </a>
<a name="ln989">  cairo_destroy(cr);</a>
<a name="ln990"> </a>
<a name="ln991">  /* ensure that all operations on surface finishing up */</a>
<a name="ln992">  cairo_surface_flush(surface);</a>
<a name="ln993"> </a>
<a name="ln994">  /* render surface on output */</a>
<a name="ln995">  guint8 *sd = image;</a>
<a name="ln996">  float opacity = data-&gt;opacity / 100.0;</a>
<a name="ln997">  /*</a>
<a name="ln998">  #ifdef _OPENMP</a>
<a name="ln999">    #pragma omp parallel for default(none) shared(in, out,sd,opacity) schedule(static)</a>
<a name="ln1000">  #endif</a>
<a name="ln1001">  */</a>
<a name="ln1002">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln1003">    for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln1004">    {</a>
<a name="ln1005">      float alpha = (sd[3] / 255.0) * opacity;</a>
<a name="ln1006">      /* svg uses a premultiplied alpha, so only use opacity for the blending */</a>
<a name="ln1007">      out[0] = ((1.0 - alpha) * in[0]) + (opacity * (sd[2] / 255.0));</a>
<a name="ln1008">      out[1] = ((1.0 - alpha) * in[1]) + (opacity * (sd[1] / 255.0));</a>
<a name="ln1009">      out[2] = ((1.0 - alpha) * in[2]) + (opacity * (sd[0] / 255.0));</a>
<a name="ln1010">      out[3] = in[3];</a>
<a name="ln1011"> </a>
<a name="ln1012">      out += ch;</a>
<a name="ln1013">      in += ch;</a>
<a name="ln1014">      sd += 4;</a>
<a name="ln1015">    }</a>
<a name="ln1016"> </a>
<a name="ln1017"> </a>
<a name="ln1018">  /* clean up */</a>
<a name="ln1019">  cairo_surface_destroy(surface);</a>
<a name="ln1020">  g_object_unref(svg);</a>
<a name="ln1021">  g_free(image);</a>
<a name="ln1022">}</a>
<a name="ln1023"> </a>
<a name="ln1024">static void watermark_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln1025">{</a>
<a name="ln1026">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1027">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1028"> </a>
<a name="ln1029">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1030">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1031">  memset(p-&gt;filename, 0, sizeof(p-&gt;filename));</a>
<a name="ln1032">  int n = dt_bauhaus_combobox_get(g-&gt;watermarks);</a>
<a name="ln1033">  snprintf(p-&gt;filename, sizeof(p-&gt;filename), &quot;%s&quot;, (char *)g_list_nth_data(g-&gt;watermarks_filenames, n));</a>
<a name="ln1034">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1035">}</a>
<a name="ln1036"> </a>
<a name="ln1037">static void _iop_color_picker_apply(dt_iop_module_t *self)</a>
<a name="ln1038">{</a>
<a name="ln1039">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1040">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1041"> </a>
<a name="ln1042">  if(fabsf(p-&gt;color[0] - self-&gt;picked_color[0]) &lt; 0.0001f</a>
<a name="ln1043">     &amp;&amp; fabsf(p-&gt;color[1] - self-&gt;picked_color[1]) &lt; 0.0001f</a>
<a name="ln1044">     &amp;&amp; fabsf(p-&gt;color[2] - self-&gt;picked_color[2]) &lt; 0.0001f)</a>
<a name="ln1045">  {</a>
<a name="ln1046">    // interrupt infinite loops</a>
<a name="ln1047">    return;</a>
<a name="ln1048">  }</a>
<a name="ln1049"> </a>
<a name="ln1050">  GdkRGBA c = (GdkRGBA){.red   = self-&gt;picked_color[0],</a>
<a name="ln1051">                        .green = self-&gt;picked_color[1],</a>
<a name="ln1052">                        .blue  = self-&gt;picked_color[2],</a>
<a name="ln1053">                        .alpha = 1.0 };</a>
<a name="ln1054"> </a>
<a name="ln1055">  p-&gt;color[0] = self-&gt;picked_color[0];</a>
<a name="ln1056">  p-&gt;color[1] = self-&gt;picked_color[1];</a>
<a name="ln1057">  p-&gt;color[2] = self-&gt;picked_color[2];</a>
<a name="ln1058">  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g-&gt;colorpick), &amp;c);</a>
<a name="ln1059"> </a>
<a name="ln1060">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1061">}</a>
<a name="ln1062"> </a>
<a name="ln1063">static void load_watermarks(const char *basedir, dt_iop_watermark_gui_data_t *g)</a>
<a name="ln1064">{</a>
<a name="ln1065">  GList *files = NULL;</a>
<a name="ln1066">  char *watermarks_dir = g_build_filename(basedir, &quot;watermarks&quot;, NULL);</a>
<a name="ln1067">  GDir *dir = g_dir_open(watermarks_dir, 0, NULL);</a>
<a name="ln1068">  if(dir)</a>
<a name="ln1069">  {</a>
<a name="ln1070">    const gchar *d_name;</a>
<a name="ln1071">    while((d_name = g_dir_read_name(dir)))</a>
<a name="ln1072">      files = g_list_append(files, g_strdup(d_name));</a>
<a name="ln1073">    g_dir_close(dir);</a>
<a name="ln1074">  }</a>
<a name="ln1075"> </a>
<a name="ln1076">  files = g_list_sort(files, (GCompareFunc)g_strcmp0);</a>
<a name="ln1077">  for(GList *iter = files; iter; iter = g_list_next(iter))</a>
<a name="ln1078">  {</a>
<a name="ln1079">    char *filename = iter-&gt;data;</a>
<a name="ln1080">    // remember the whole filename for later</a>
<a name="ln1081">    g-&gt;watermarks_filenames = g_list_append(g-&gt;watermarks_filenames, g_strdup(filename));</a>
<a name="ln1082">    // ... and remove the file extension from the string shown in the gui</a>
<a name="ln1083">    char *c = filename + strlen(filename);</a>
<a name="ln1084">    while(c &gt;= filename &amp;&amp; *c != '.') *c-- = '\0';</a>
<a name="ln1085">    if(*c == '.') *c = '\0';</a>
<a name="ln1086">    dt_bauhaus_combobox_add(g-&gt;watermarks, filename);</a>
<a name="ln1087">  }</a>
<a name="ln1088"> </a>
<a name="ln1089">  g_list_free_full(files, g_free);</a>
<a name="ln1090">  g_free(watermarks_dir);</a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093">static void refresh_watermarks(dt_iop_module_t *self)</a>
<a name="ln1094">{</a>
<a name="ln1095">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1096">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1097"> </a>
<a name="ln1098">  g_signal_handlers_block_by_func(g-&gt;watermarks, watermark_callback, self);</a>
<a name="ln1099"> </a>
<a name="ln1100">  // Clear combobox...</a>
<a name="ln1101">  dt_bauhaus_combobox_clear(g-&gt;watermarks);</a>
<a name="ln1102">  g_list_free_full(g-&gt;watermarks_filenames, g_free);</a>
<a name="ln1103">  g-&gt;watermarks_filenames = NULL;</a>
<a name="ln1104"> </a>
<a name="ln1105">  // check watermarkdir and update combo with entries...</a>
<a name="ln1106">  gchar configdir[PATH_MAX] = { 0 };</a>
<a name="ln1107">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln1108">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln1109">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln1110"> </a>
<a name="ln1111">  load_watermarks(datadir, g);</a>
<a name="ln1112">  load_watermarks(configdir, g);</a>
<a name="ln1113"> </a>
<a name="ln1114">  _combo_box_set_active_text(g, p-&gt;filename);</a>
<a name="ln1115"> </a>
<a name="ln1116">  g_signal_handlers_unblock_by_func(g-&gt;watermarks, watermark_callback, self);</a>
<a name="ln1117">}</a>
<a name="ln1118"> </a>
<a name="ln1119">static void refresh_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln1120">{</a>
<a name="ln1121">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1122">  refresh_watermarks(self);</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125"> </a>
<a name="ln1126"> </a>
<a name="ln1127">static void alignment_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln1128">{</a>
<a name="ln1129">  int index = -1;</a>
<a name="ln1130">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1131">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1132"> </a>
<a name="ln1133">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1134">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1135"> </a>
<a name="ln1136"> </a>
<a name="ln1137">  for(int i = 0; i &lt; 9; i++)</a>
<a name="ln1138">  {</a>
<a name="ln1139">    /* block signal handler */</a>
<a name="ln1140">    g_signal_handlers_block_by_func(g-&gt;align[i], alignment_callback, user_data);</a>
<a name="ln1141"> </a>
<a name="ln1142">    if(GTK_WIDGET(g-&gt;align[i]) == tb)</a>
<a name="ln1143">    {</a>
<a name="ln1144">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;align[i]), TRUE);</a>
<a name="ln1145">      index = i;</a>
<a name="ln1146">    }</a>
<a name="ln1147">    else</a>
<a name="ln1148">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;align[i]), FALSE);</a>
<a name="ln1149"> </a>
<a name="ln1150">    /* unblock signal handler */</a>
<a name="ln1151">    g_signal_handlers_unblock_by_func(g-&gt;align[i], alignment_callback, user_data);</a>
<a name="ln1152">  }</a>
<a name="ln1153">  p-&gt;alignment = index;</a>
<a name="ln1154">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">static void opacity_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1158">{</a>
<a name="ln1159">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1160">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1161">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1162">  p-&gt;opacity = dt_bauhaus_slider_get(slider);</a>
<a name="ln1163">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1164">}</a>
<a name="ln1165"> </a>
<a name="ln1166">static void text_callback(GtkWidget *entry, gpointer user_data)</a>
<a name="ln1167">{</a>
<a name="ln1168">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1169">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1170">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1171">  snprintf(p-&gt;text, sizeof(p-&gt;text), &quot;%s&quot;, gtk_entry_get_text(GTK_ENTRY(entry)));</a>
<a name="ln1172">  dt_conf_set_string(&quot;plugins/darkroom/watermark/text&quot;, p-&gt;text);</a>
<a name="ln1173">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1174">}</a>
<a name="ln1175"> </a>
<a name="ln1176">static void colorpick_color_set(GtkColorButton *widget, gpointer user_data)</a>
<a name="ln1177">{</a>
<a name="ln1178">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1179">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1180">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1181"> </a>
<a name="ln1182">  GdkRGBA c;</a>
<a name="ln1183">  gtk_color_chooser_get_rgba(GTK_COLOR_CHOOSER(widget), &amp;c);</a>
<a name="ln1184">  p-&gt;color[0] = c.red;</a>
<a name="ln1185">  p-&gt;color[1] = c.green;</a>
<a name="ln1186">  p-&gt;color[2] = c.blue;</a>
<a name="ln1187"> </a>
<a name="ln1188">  dt_conf_set_float(&quot;plugins/darkroom/watermark/color_red&quot;, p-&gt;color[0]);</a>
<a name="ln1189">  dt_conf_set_float(&quot;plugins/darkroom/watermark/color_green&quot;, p-&gt;color[1]);</a>
<a name="ln1190">  dt_conf_set_float(&quot;plugins/darkroom/watermark/color_blue&quot;, p-&gt;color[2]);</a>
<a name="ln1191">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1192">}</a>
<a name="ln1193"> </a>
<a name="ln1194">static void fontsel_callback(GtkWidget *button, gpointer user_data)</a>
<a name="ln1195">{</a>
<a name="ln1196">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1197">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1198">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1199"> </a>
<a name="ln1200">  snprintf(p-&gt;font, sizeof(p-&gt;font), &quot;%s&quot;, gtk_font_button_get_font_name(GTK_FONT_BUTTON(button)));</a>
<a name="ln1201">  dt_conf_set_string(&quot;plugins/darkroom/watermark/font&quot;, p-&gt;font);</a>
<a name="ln1202">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1203">}</a>
<a name="ln1204"> </a>
<a name="ln1205">static void xoffset_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1206">{</a>
<a name="ln1207">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1208">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1209">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1210">  p-&gt;xoffset = dt_bauhaus_slider_get(slider);</a>
<a name="ln1211">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1212">}</a>
<a name="ln1213"> </a>
<a name="ln1214">static void yoffset_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1215">{</a>
<a name="ln1216">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1217">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1218">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1219">  p-&gt;yoffset = dt_bauhaus_slider_get(slider);</a>
<a name="ln1220">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1221">}</a>
<a name="ln1222"> </a>
<a name="ln1223">static void scale_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1224">{</a>
<a name="ln1225">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1226">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1227">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1228">  p-&gt;scale = dt_bauhaus_slider_get(slider);</a>
<a name="ln1229">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232">static void rotate_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1233">{</a>
<a name="ln1234">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1235">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1236">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1237">  p-&gt;rotate = dt_bauhaus_slider_get(slider);</a>
<a name="ln1238">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1239">}</a>
<a name="ln1240"> </a>
<a name="ln1241">static void sizeto_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln1242">{</a>
<a name="ln1243">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1244"> </a>
<a name="ln1245">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln1246">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1247">  p-&gt;sizeto = dt_bauhaus_combobox_get(tb);</a>
<a name="ln1248">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1249">}</a>
<a name="ln1250"> </a>
<a name="ln1251">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln1252">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1253">{</a>
<a name="ln1254">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)p1;</a>
<a name="ln1255">  dt_iop_watermark_data_t *d = (dt_iop_watermark_data_t *)piece-&gt;data;</a>
<a name="ln1256"> </a>
<a name="ln1257">  d-&gt;opacity = p-&gt;opacity;</a>
<a name="ln1258">  d-&gt;scale = p-&gt;scale;</a>
<a name="ln1259">  d-&gt;rotate = p-&gt;rotate;</a>
<a name="ln1260">  d-&gt;xoffset = p-&gt;xoffset;</a>
<a name="ln1261">  d-&gt;yoffset = p-&gt;yoffset;</a>
<a name="ln1262">  d-&gt;alignment = p-&gt;alignment;</a>
<a name="ln1263">  d-&gt;sizeto = p-&gt;sizeto;</a>
<a name="ln1264">  memset(d-&gt;filename, 0, sizeof(d-&gt;filename));</a>
<a name="ln1265">  snprintf(d-&gt;filename, sizeof(d-&gt;filename), &quot;%s&quot;, p-&gt;filename);</a>
<a name="ln1266">  memset(d-&gt;text, 0, sizeof(d-&gt;text));</a>
<a name="ln1267">  snprintf(d-&gt;text, sizeof(d-&gt;text), &quot;%s&quot;, p-&gt;text);</a>
<a name="ln1268">  for (int k=0; k&lt;3; k++)</a>
<a name="ln1269">    d-&gt;color[k] = p-&gt;color[k];</a>
<a name="ln1270">  memset(d-&gt;font, 0, sizeof(d-&gt;font));</a>
<a name="ln1271">  snprintf(d-&gt;font, sizeof(d-&gt;font), &quot;%s&quot;, p-&gt;font);</a>
<a name="ln1272"> </a>
<a name="ln1273">// fprintf(stderr,&quot;Commit params: %s...\n&quot;,d-&gt;filename);</a>
<a name="ln1274">}</a>
<a name="ln1275"> </a>
<a name="ln1276">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1277">{</a>
<a name="ln1278">  piece-&gt;data = malloc(sizeof(dt_iop_watermark_data_t));</a>
<a name="ln1279">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln1280">}</a>
<a name="ln1281"> </a>
<a name="ln1282">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1283">{</a>
<a name="ln1284">  free(piece-&gt;data);</a>
<a name="ln1285">  piece-&gt;data = NULL;</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288"> </a>
<a name="ln1289">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln1290">{</a>
<a name="ln1291">  dt_iop_module_t *module = (dt_iop_module_t *)self;</a>
<a name="ln1292">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1293">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)module-&gt;params;</a>
<a name="ln1294">  dt_bauhaus_slider_set(g-&gt;opacity, p-&gt;opacity);</a>
<a name="ln1295">  dt_bauhaus_slider_set_soft(g-&gt;scale, p-&gt;scale);</a>
<a name="ln1296">  dt_bauhaus_slider_set(g-&gt;rotate, p-&gt;rotate);</a>
<a name="ln1297">  dt_bauhaus_slider_set(g-&gt;x_offset, p-&gt;xoffset);</a>
<a name="ln1298">  dt_bauhaus_slider_set(g-&gt;y_offset, p-&gt;yoffset);</a>
<a name="ln1299">  for(int i = 0; i &lt; 9; i++)</a>
<a name="ln1300">  {</a>
<a name="ln1301">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;align[i]), FALSE);</a>
<a name="ln1302">  }</a>
<a name="ln1303">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;align[p-&gt;alignment]), TRUE);</a>
<a name="ln1304">  _combo_box_set_active_text(g, p-&gt;filename);</a>
<a name="ln1305">  dt_bauhaus_combobox_set(g-&gt;sizeto, p-&gt;sizeto);</a>
<a name="ln1306">  gtk_entry_set_text(GTK_ENTRY(g-&gt;text), p-&gt;text);</a>
<a name="ln1307">  GdkRGBA color = (GdkRGBA){.red = p-&gt;color[0], .green = p-&gt;color[1], .blue = p-&gt;color[2], .alpha = 1.0 };</a>
<a name="ln1308">  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g-&gt;colorpick), &amp;color);</a>
<a name="ln1309">  gtk_font_button_set_font_name(GTK_FONT_BUTTON(g-&gt;fontsel), p-&gt;font);</a>
<a name="ln1310">}</a>
<a name="ln1311"> </a>
<a name="ln1312">void init(dt_iop_module_t *module)</a>
<a name="ln1313">{</a>
<a name="ln1314">  module-&gt;params = calloc(1, sizeof(dt_iop_watermark_params_t));</a>
<a name="ln1315">  module-&gt;params_size = sizeof(dt_iop_watermark_params_t);</a>
<a name="ln1316">  module-&gt;default_params = calloc(1, sizeof(dt_iop_watermark_params_t));</a>
<a name="ln1317">  module-&gt;default_enabled = 0;</a>
<a name="ln1318">  module-&gt;priority = 971; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln1319">  module-&gt;params_size = sizeof(dt_iop_watermark_params_t);</a>
<a name="ln1320">  module-&gt;gui_data = NULL;</a>
<a name="ln1321">  dt_iop_watermark_params_t tmp = (dt_iop_watermark_params_t){</a>
<a name="ln1322">    100.0, 100.0, 0.0, 0.0, 4, 0.0, DT_SCALE_IMAGE, { &quot;darktable.svg&quot; }, { &quot;&quot; }, {0.0, 0.0, 0.0}, {&quot;DejaVu Sans 10&quot;}</a>
<a name="ln1323">  }; // opacity,scale,xoffs,yoffs,alignment</a>
<a name="ln1324">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_watermark_params_t));</a>
<a name="ln1325">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_watermark_params_t));</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328">void cleanup(dt_iop_module_t *module)</a>
<a name="ln1329">{</a>
<a name="ln1330">  free(module-&gt;params);</a>
<a name="ln1331">  module-&gt;params = NULL;</a>
<a name="ln1332">}</a>
<a name="ln1333"> </a>
<a name="ln1334">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln1335">{</a>
<a name="ln1336">  self-&gt;gui_data = calloc(1, sizeof(dt_iop_watermark_gui_data_t));</a>
<a name="ln1337">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1338">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1339"> </a>
<a name="ln1340">  int line = 0;</a>
<a name="ln1341">  self-&gt;widget = gtk_grid_new();</a>
<a name="ln1342">  gtk_grid_set_row_spacing(GTK_GRID(self-&gt;widget), DT_BAUHAUS_SPACE);</a>
<a name="ln1343">  gtk_grid_set_column_spacing(GTK_GRID(self-&gt;widget), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln1344">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln1345"> </a>
<a name="ln1346">  gtk_grid_attach(GTK_GRID(self-&gt;widget), dt_ui_section_label_new(_(&quot;content&quot;)), 0, line++, 3, 1);</a>
<a name="ln1347"> </a>
<a name="ln1348">  // Add the marker combobox</a>
<a name="ln1349">  gchar configdir[PATH_MAX] = { 0 };</a>
<a name="ln1350">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln1351">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln1352">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln1353">  GtkWidget *label = dtgtk_reset_label_new(_(&quot;marker&quot;), self, &amp;p-&gt;filename, sizeof(p-&gt;filename));</a>
<a name="ln1354">  g-&gt;watermarks = dt_bauhaus_combobox_new(self);</a>
<a name="ln1355">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;watermarks), TRUE);</a>
<a name="ln1356">  char *tooltip = g_strdup_printf(_(&quot;SVG watermarks in %s/watermarks or %s/watermarks&quot;), configdir, datadir);</a>
<a name="ln1357">  gtk_widget_set_tooltip_text(g-&gt;watermarks, tooltip);</a>
<a name="ln1358">  g_free(tooltip);</a>
<a name="ln1359">  g-&gt;refresh = dtgtk_button_new(dtgtk_cairo_paint_refresh, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1360">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1361">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), g-&gt;watermarks, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1362">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), g-&gt;refresh, g-&gt;watermarks, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1363"> </a>
<a name="ln1364"> </a>
<a name="ln1365">  // Watermark color</a>
<a name="ln1366">  float red = dt_conf_get_float(&quot;plugins/darkroom/watermark/color_red&quot;);</a>
<a name="ln1367">  float green = dt_conf_get_float(&quot;plugins/darkroom/watermark/color_green&quot;);</a>
<a name="ln1368">  float blue = dt_conf_get_float(&quot;plugins/darkroom/watermark/color_blue&quot;);</a>
<a name="ln1369">  GdkRGBA color = (GdkRGBA){.red = red, .green = green, .blue = blue, .alpha = 1.0 };</a>
<a name="ln1370"> </a>
<a name="ln1371">  GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1372"> </a>
<a name="ln1373">  label = dtgtk_reset_label_new(_(&quot;color&quot;), self, &amp;p-&gt;color, 3 * sizeof(float));</a>
<a name="ln1374">  g-&gt;colorpick = gtk_color_button_new_with_rgba(&amp;color);</a>
<a name="ln1375">  gtk_widget_set_tooltip_text(g-&gt;colorpick, _(&quot;watermark color, tag:\n$(WATERMARK_COLOR)&quot;));</a>
<a name="ln1376">  gtk_color_chooser_set_use_alpha(GTK_COLOR_CHOOSER(g-&gt;colorpick), FALSE);</a>
<a name="ln1377">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;colorpick), DT_PIXEL_APPLY_DPI(24), DT_PIXEL_APPLY_DPI(24));</a>
<a name="ln1378">  gtk_color_button_set_title(GTK_COLOR_BUTTON(g-&gt;colorpick), _(&quot;select watermark color&quot;));</a>
<a name="ln1379"> </a>
<a name="ln1380">  g-&gt;color_picker_button = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT, NULL));</a>
<a name="ln1381">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;color_picker_button), _(&quot;pick color from image&quot;));</a>
<a name="ln1382">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;color_picker_button), DT_PIXEL_APPLY_DPI(24), DT_PIXEL_APPLY_DPI(24));</a>
<a name="ln1383">  g_signal_connect(G_OBJECT(g-&gt;color_picker_button), &quot;toggled&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln1384"> </a>
<a name="ln1385">  gtk_box_pack_start(GTK_BOX(box), g-&gt;colorpick, TRUE, TRUE, 0);</a>
<a name="ln1386">  gtk_box_pack_start(GTK_BOX(box), GTK_WIDGET(g-&gt;color_picker_button), FALSE, TRUE, 0);</a>
<a name="ln1387"> </a>
<a name="ln1388">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1389">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), box, label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1390"> </a>
<a name="ln1391">  // Simple text</a>
<a name="ln1392">  label = gtk_label_new(_(&quot;text&quot;));</a>
<a name="ln1393">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1394">  g-&gt;text = gtk_entry_new();</a>
<a name="ln1395">  gtk_entry_set_width_chars(GTK_ENTRY(g-&gt;text), 1);</a>
<a name="ln1396">  gtk_widget_set_tooltip_text(g-&gt;text, _(&quot;text string, tag:\n$(WATERMARK_TEXT)&quot;));</a>
<a name="ln1397">  dt_gui_key_accel_block_on_focus_connect(g-&gt;text);</a>
<a name="ln1398">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1399">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), g-&gt;text, label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1400"> </a>
<a name="ln1401">  gchar *str = dt_conf_get_string(&quot;plugins/darkroom/watermark/text&quot;);</a>
<a name="ln1402">  gtk_entry_set_text(GTK_ENTRY(g-&gt;text), str);</a>
<a name="ln1403">  g_free(str);</a>
<a name="ln1404"> </a>
<a name="ln1405">  // Text font</a>
<a name="ln1406">  label = dtgtk_reset_label_new(_(&quot;font&quot;), self, &amp;p-&gt;font, sizeof(p-&gt;font));</a>
<a name="ln1407">  str = dt_conf_get_string(&quot;plugins/darkroom/watermark/font&quot;);</a>
<a name="ln1408">  g-&gt;fontsel = gtk_font_button_new_with_font(str==NULL?&quot;DejaVu Sans 10&quot;:str);</a>
<a name="ln1409">  GList *childs = gtk_container_get_children(GTK_CONTAINER(gtk_bin_get_child(GTK_BIN(g-&gt;fontsel))));</a>
<a name="ln1410">  gtk_label_set_ellipsize(GTK_LABEL(childs-&gt;data), PANGO_ELLIPSIZE_MIDDLE);</a>
<a name="ln1411">  g_list_free(childs);</a>
<a name="ln1412">  gtk_widget_set_tooltip_text(g-&gt;fontsel, _(&quot;text font, tags:\n$(WATERMARK_FONT_FAMILY)\n&quot;</a>
<a name="ln1413">                                            &quot;$(WATERMARK_FONT_STYLE)\n$(WATERMARK_FONT_WEIGHT)&quot;));</a>
<a name="ln1414">  gtk_font_button_set_show_size (GTK_FONT_BUTTON(g-&gt;fontsel), FALSE);</a>
<a name="ln1415">  g_free(str);</a>
<a name="ln1416">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1417">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), g-&gt;fontsel, label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1418"> </a>
<a name="ln1419">  gtk_grid_attach(GTK_GRID(self-&gt;widget), dt_ui_section_label_new(_(&quot;properties&quot;)), 0, line++, 3, 1);</a>
<a name="ln1420"> </a>
<a name="ln1421">  // Add opacity/scale sliders to table</a>
<a name="ln1422">  g-&gt;opacity = dt_bauhaus_slider_new_with_range(self, 0.0, 100.0, 1.0, p-&gt;opacity, 0);</a>
<a name="ln1423">  dt_bauhaus_slider_set_format(g-&gt;opacity, &quot;%.f%%&quot;);</a>
<a name="ln1424">  dt_bauhaus_widget_set_label(g-&gt;opacity, NULL, _(&quot;opacity&quot;));</a>
<a name="ln1425">  g-&gt;scale = dt_bauhaus_slider_new_with_range(self, 1.0, 100.0, 1.0, p-&gt;scale, 0);</a>
<a name="ln1426">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;scale, 1.0, 500.0);</a>
<a name="ln1427">  dt_bauhaus_slider_set_format(g-&gt;scale, &quot;%.f%%&quot;);</a>
<a name="ln1428">  dt_bauhaus_widget_set_label(g-&gt;scale, NULL, _(&quot;scale&quot;));</a>
<a name="ln1429">  g-&gt;rotate = dt_bauhaus_slider_new_with_range(self, -180.0, 180.0, 1.0, p-&gt;rotate, 2);</a>
<a name="ln1430">  dt_bauhaus_slider_set_format(g-&gt;rotate, &quot;%.02f°&quot;);</a>
<a name="ln1431">  dt_bauhaus_widget_set_label(g-&gt;rotate, NULL, _(&quot;rotation&quot;));</a>
<a name="ln1432">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;opacity, 0, line++, 3, 1);</a>
<a name="ln1433">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;scale, 0, line++, 3, 1);</a>
<a name="ln1434">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;rotate, 0, line++, 3, 1);</a>
<a name="ln1435"> </a>
<a name="ln1436">  g-&gt;sizeto = dt_bauhaus_combobox_new(self);</a>
<a name="ln1437">  dt_bauhaus_combobox_add(g-&gt;sizeto, C_(&quot;size&quot;, &quot;image&quot;));</a>
<a name="ln1438">  dt_bauhaus_combobox_add(g-&gt;sizeto, _(&quot;larger border&quot;));</a>
<a name="ln1439">  dt_bauhaus_combobox_add(g-&gt;sizeto, _(&quot;smaller border&quot;));</a>
<a name="ln1440">  dt_bauhaus_combobox_set(g-&gt;sizeto, p-&gt;sizeto);</a>
<a name="ln1441">  dt_bauhaus_widget_set_label(g-&gt;sizeto, NULL, _(&quot;scale on&quot;));</a>
<a name="ln1442">  gtk_widget_set_tooltip_text(g-&gt;sizeto, _(&quot;size is relative to&quot;));</a>
<a name="ln1443">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;sizeto, 0, line++, 3, 1);</a>
<a name="ln1444"> </a>
<a name="ln1445">  gtk_grid_attach(GTK_GRID(self-&gt;widget), dt_ui_section_label_new(_(&quot;position&quot;)), 0, line++, 3, 1);</a>
<a name="ln1446"> </a>
<a name="ln1447">  // Create the 3x3 gtk table toggle button table...</a>
<a name="ln1448">  label = dtgtk_reset_label_new(_(&quot;alignment&quot;), self, &amp;p-&gt;alignment, sizeof(p-&gt;alignment));</a>
<a name="ln1449">  GtkWidget *bat = gtk_grid_new();</a>
<a name="ln1450">  gtk_grid_set_row_spacing(GTK_GRID(bat), DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1451">  gtk_grid_set_column_spacing(GTK_GRID(bat), DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1452">  for(int i = 0; i &lt; 9; i++)</a>
<a name="ln1453">  {</a>
<a name="ln1454">    g-&gt;align[i] = dtgtk_togglebutton_new(dtgtk_cairo_paint_alignment, CPF_STYLE_FLAT | (CPF_SPECIAL_FLAG &lt;&lt; i), NULL);</a>
<a name="ln1455">    gtk_widget_set_size_request(GTK_WIDGET(g-&gt;align[i]), DT_PIXEL_APPLY_DPI(16), DT_PIXEL_APPLY_DPI(16));</a>
<a name="ln1456">    gtk_grid_attach(GTK_GRID(bat), GTK_WIDGET(g-&gt;align[i]), i%3, i/3, 1, 1);</a>
<a name="ln1457">    g_signal_connect(G_OBJECT(g-&gt;align[i]), &quot;toggled&quot;, G_CALLBACK(alignment_callback), self);</a>
<a name="ln1458">  }</a>
<a name="ln1459">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1460">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), bat, label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1461"> </a>
<a name="ln1462">  // x/y offset</a>
<a name="ln1463">  g-&gt;x_offset = dt_bauhaus_slider_new_with_range(self, -1.0, 1.0, 0.001, p-&gt;xoffset, 3);</a>
<a name="ln1464">  dt_bauhaus_slider_set_format(g-&gt;x_offset, &quot;%.3f&quot;);</a>
<a name="ln1465">  dt_bauhaus_widget_set_label(g-&gt;x_offset, NULL, _(&quot;x offset&quot;));</a>
<a name="ln1466">  g-&gt;y_offset = dt_bauhaus_slider_new_with_range(self, -1.0, 1.0, 0.001, p-&gt;yoffset, 3);</a>
<a name="ln1467">  dt_bauhaus_slider_set_format(g-&gt;y_offset, &quot;%.3f&quot;);</a>
<a name="ln1468">  dt_bauhaus_widget_set_label(g-&gt;y_offset, NULL, _(&quot;y offset&quot;));</a>
<a name="ln1469">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;x_offset, 0, line++, 3, 1);</a>
<a name="ln1470">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;y_offset, 0, line++, 3, 1);</a>
<a name="ln1471"> </a>
<a name="ln1472">  // Let's add some tooltips and hook up some signals...</a>
<a name="ln1473">  gtk_widget_set_tooltip_text(g-&gt;opacity, _(&quot;the opacity of the watermark&quot;));</a>
<a name="ln1474">  gtk_widget_set_tooltip_text(g-&gt;scale, _(&quot;the scale of the watermark&quot;));</a>
<a name="ln1475">  gtk_widget_set_tooltip_text(g-&gt;rotate, _(&quot;the rotation of the watermark&quot;));</a>
<a name="ln1476"> </a>
<a name="ln1477">  g_signal_connect(G_OBJECT(g-&gt;opacity), &quot;value-changed&quot;, G_CALLBACK(opacity_callback), self);</a>
<a name="ln1478">  g_signal_connect(G_OBJECT(g-&gt;scale), &quot;value-changed&quot;, G_CALLBACK(scale_callback), self);</a>
<a name="ln1479">  g_signal_connect(G_OBJECT(g-&gt;rotate), &quot;value-changed&quot;, G_CALLBACK(rotate_callback), self);</a>
<a name="ln1480"> </a>
<a name="ln1481">  g_signal_connect(G_OBJECT(g-&gt;x_offset), &quot;value-changed&quot;, G_CALLBACK(xoffset_callback), self);</a>
<a name="ln1482"> </a>
<a name="ln1483">  g_signal_connect(G_OBJECT(g-&gt;y_offset), &quot;value-changed&quot;, G_CALLBACK(yoffset_callback), self);</a>
<a name="ln1484"> </a>
<a name="ln1485"> </a>
<a name="ln1486">  g_signal_connect(G_OBJECT(g-&gt;refresh), &quot;clicked&quot;, G_CALLBACK(refresh_callback), self);</a>
<a name="ln1487"> </a>
<a name="ln1488">  refresh_watermarks(self);</a>
<a name="ln1489"> </a>
<a name="ln1490">  g_signal_connect(G_OBJECT(g-&gt;watermarks), &quot;value-changed&quot;, G_CALLBACK(watermark_callback), self);</a>
<a name="ln1491">  g_signal_connect(G_OBJECT(g-&gt;sizeto), &quot;value-changed&quot;, G_CALLBACK(sizeto_callback), self);</a>
<a name="ln1492"> </a>
<a name="ln1493">  g_signal_connect(G_OBJECT(g-&gt;text), &quot;changed&quot;, G_CALLBACK(text_callback), self);</a>
<a name="ln1494">  g_signal_connect(G_OBJECT(g-&gt;colorpick), &quot;color-set&quot;, G_CALLBACK(colorpick_color_set), self);</a>
<a name="ln1495">  g_signal_connect(G_OBJECT(g-&gt;fontsel), &quot;font-set&quot;, G_CALLBACK(fontsel_callback), self);</a>
<a name="ln1496"> </a>
<a name="ln1497">  init_single_picker(&amp;g-&gt;color_picker,</a>
<a name="ln1498">                     self,</a>
<a name="ln1499">                     GTK_WIDGET(g-&gt;color_picker_button),</a>
<a name="ln1500">                     DT_COLOR_PICKER_POINT,</a>
<a name="ln1501">                     _iop_color_picker_apply);</a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>
<a name="ln1504">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln1505">{</a>
<a name="ln1506"> </a>
<a name="ln1507">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1508">  g_list_free_full(g-&gt;watermarks_filenames, g_free);</a>
<a name="ln1509">  g-&gt;watermarks_filenames = NULL;</a>
<a name="ln1510">  free(self-&gt;gui_data);</a>
<a name="ln1511">  self-&gt;gui_data = NULL;</a>
<a name="ln1512">}</a>
<a name="ln1513"> </a>
<a name="ln1514">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1515">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1516">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1324"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1324, 1314.</p></div>
<div class="balloon" rel="1325"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1325, 1316.</p></div>
<div class="balloon" rel="1319"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'module->params_size' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1315, 1319.</p></div>
<div class="balloon" rel="1354"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 1354, 1336.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
