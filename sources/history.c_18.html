
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010 henrik andersson,</a>
<a name="ln4">    copyright (c) 2011-2012 johannes hanika</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;common/history.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/exif.h&quot;</a>
<a name="ln24">#include &quot;common/image_cache.h&quot;</a>
<a name="ln25">#include &quot;common/imageio.h&quot;</a>
<a name="ln26">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln27">#include &quot;common/tags.h&quot;</a>
<a name="ln28">#include &quot;common/utility.h&quot;</a>
<a name="ln29">#include &quot;common/collection.h&quot;</a>
<a name="ln30">#include &quot;control/control.h&quot;</a>
<a name="ln31">#include &quot;develop/develop.h&quot;</a>
<a name="ln32">#include &quot;develop/blend.h&quot;</a>
<a name="ln33">#include &quot;develop/masks.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">void dt_history_item_free(gpointer data)</a>
<a name="ln36">{</a>
<a name="ln37">  dt_history_item_t *item = (dt_history_item_t *)data;</a>
<a name="ln38">  g_free(item-&gt;op);</a>
<a name="ln39">  g_free(item-&gt;name);</a>
<a name="ln40">  item-&gt;op = NULL;</a>
<a name="ln41">  item-&gt;name = NULL;</a>
<a name="ln42">  g_free(item);</a>
<a name="ln43">}</a>
<a name="ln44"> </a>
<a name="ln45">static void remove_preset_flag(const int imgid)</a>
<a name="ln46">{</a>
<a name="ln47">  dt_image_t *image = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln48"> </a>
<a name="ln49">  // clear flag</a>
<a name="ln50">  image-&gt;flags &amp;= ~DT_IMAGE_AUTO_PRESETS_APPLIED;</a>
<a name="ln51"> </a>
<a name="ln52">  // write through to sql+xmp</a>
<a name="ln53">  dt_image_cache_write_release(darktable.image_cache, image, DT_IMAGE_CACHE_SAFE);</a>
<a name="ln54">}</a>
<a name="ln55"> </a>
<a name="ln56">#if 0</a>
<a name="ln57">static void _dt_history_cleanup_multi_instance()</a>
<a name="ln58">{</a>
<a name="ln59">  /* as we let the user decide which history item to copy, we can end with some gaps in multi-instance</a>
<a name="ln60">     numbering.</a>
<a name="ln61">     for ex., if user decide to not copy the 2nd instance of a module which as 3 instances.</a>
<a name="ln62">     let's clean-up the history multi-instance. What we want to do is have a unique multi_priority value for</a>
<a name="ln63">     each iop.</a>
<a name="ln64">     Furthermore this value must start to 0 and increment one by one for each multi-instance of the same</a>
<a name="ln65">     module. On</a>
<a name="ln66">     SQLite there is no notion of ROW_NUMBER, so we use rather resource consuming SQL statement, but as an</a>
<a name="ln67">     history has</a>
<a name="ln68">     never a huge number of items that's not a real issue.</a>
<a name="ln69"> </a>
<a name="ln70">     We only do this for the given imgid and only for num&gt;minnum, that is we only handle new history items</a>
<a name="ln71">     just copied.</a>
<a name="ln72">  */</a>
<a name="ln73">  typedef struct _history_item_t</a>
<a name="ln74">  {</a>
<a name="ln75">    int num;</a>
<a name="ln76">    char op[1024];</a>
<a name="ln77">    int mi;</a>
<a name="ln78">    int new_mi;</a>
<a name="ln79">  } _history_item_t;</a>
<a name="ln80"> </a>
<a name="ln81">  // we first reload all the newly added history item</a>
<a name="ln82">  sqlite3_stmt *stmt;</a>
<a name="ln83">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT num, operation, multi_priority FROM &quot;</a>
<a name="ln84">                                                             &quot;memory.style_items ORDER BY &quot;</a>
<a name="ln85">                                                             &quot;operation, multi_priority&quot;,</a>
<a name="ln86">                              -1, &amp;stmt, NULL);</a>
<a name="ln87">  GList *hitems = NULL;</a>
<a name="ln88">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln89">  {</a>
<a name="ln90">    const char *op = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln91">    GList *modules = darktable.iop;</a>
<a name="ln92">    while(modules)</a>
<a name="ln93">    {</a>
<a name="ln94">      dt_iop_module_so_t *find_op = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln95">      if(!strcmp(find_op-&gt;op, op))</a>
<a name="ln96">      {</a>
<a name="ln97">        break;</a>
<a name="ln98">      }</a>
<a name="ln99">      modules = g_list_next(modules);</a>
<a name="ln100">    }</a>
<a name="ln101">    if(modules &amp;&amp; (((dt_iop_module_so_t *)(modules-&gt;data))-&gt;flags() &amp; IOP_FLAGS_ONE_INSTANCE))</a>
<a name="ln102">    {</a>
<a name="ln103">      // the current module is a single-instance one, so there's no point in trying</a>
<a name="ln104">      // to mess up our multi_priority value</a>
<a name="ln105">      continue;</a>
<a name="ln106">    }</a>
<a name="ln107"> </a>
<a name="ln108">    _history_item_t *hi = (_history_item_t *)calloc(1, sizeof(_history_item_t));</a>
<a name="ln109">    hi-&gt;num = sqlite3_column_int(stmt, 0);</a>
<a name="ln110">    snprintf(hi-&gt;op, sizeof(hi-&gt;op), &quot;%s&quot;, sqlite3_column_text(stmt, 1));</a>
<a name="ln111">    hi-&gt;mi = sqlite3_column_int(stmt, 2);</a>
<a name="ln112">    hi-&gt;new_mi = -5; // means : not changed atm</a>
<a name="ln113">    hitems = g_list_append(hitems, hi);</a>
<a name="ln114">  }</a>
<a name="ln115">  sqlite3_finalize(stmt);</a>
<a name="ln116"> </a>
<a name="ln117">  // then we change the multi-priority to be sure to have a correct numbering</a>
<a name="ln118">  char op[1024] = &quot;&quot;;</a>
<a name="ln119">  int c_mi = 0;</a>
<a name="ln120">  int nb_change = 0;</a>
<a name="ln121">  GList *items = g_list_first(hitems);</a>
<a name="ln122">  while(items)</a>
<a name="ln123">  {</a>
<a name="ln124">    _history_item_t *hi = (_history_item_t *)(items-&gt;data);</a>
<a name="ln125">    if(strcmp(op, hi-&gt;op) != 0)</a>
<a name="ln126">    {</a>
<a name="ln127">      g_strlcpy(op, hi-&gt;op, sizeof(op));</a>
<a name="ln128">      c_mi = 0;</a>
<a name="ln129">    }</a>
<a name="ln130">    if(hi-&gt;mi != c_mi) nb_change++;</a>
<a name="ln131">    hi-&gt;new_mi = c_mi;</a>
<a name="ln132">    c_mi++;</a>
<a name="ln133">    items = g_list_next(items);</a>
<a name="ln134">  }</a>
<a name="ln135"> </a>
<a name="ln136">  if(nb_change == 0)</a>
<a name="ln137">  {</a>
<a name="ln138">    // everything is ok, nothing to change</a>
<a name="ln139">    g_list_free_full(hitems, free);</a>
<a name="ln140">    return;</a>
<a name="ln141">  }</a>
<a name="ln142"> </a>
<a name="ln143">  // and we update the history items</a>
<a name="ln144">  char *req = NULL;</a>
<a name="ln145">  req = dt_util_dstrcat(req, &quot;%s&quot;, &quot;UPDATE memory.style_items SET multi_priority = CASE num &quot;);</a>
<a name="ln146">  items = g_list_first(hitems);</a>
<a name="ln147">  while(items)</a>
<a name="ln148">  {</a>
<a name="ln149">    _history_item_t *hi = (_history_item_t *)(items-&gt;data);</a>
<a name="ln150">    if(hi-&gt;mi != hi-&gt;new_mi)</a>
<a name="ln151">    {</a>
<a name="ln152">      req = dt_util_dstrcat(req, &quot;WHEN %d THEN %d &quot;, hi-&gt;num, hi-&gt;new_mi);</a>
<a name="ln153">    }</a>
<a name="ln154">    items = g_list_next(items);</a>
<a name="ln155">  }</a>
<a name="ln156">  req = dt_util_dstrcat(req, &quot;%s&quot;, &quot;else multi_priority end&quot;);</a>
<a name="ln157">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), req, -1, &amp;stmt, NULL);</a>
<a name="ln158">  sqlite3_step(stmt);</a>
<a name="ln159">  sqlite3_finalize(stmt);</a>
<a name="ln160"> </a>
<a name="ln161">  g_free(req);</a>
<a name="ln162">  g_list_free_full(hitems, free);</a>
<a name="ln163">}</a>
<a name="ln164">#endif</a>
<a name="ln165"> </a>
<a name="ln166">static void _history_rebuild_multi_priority_append(const int dest_imgid)</a>
<a name="ln167">{</a>
<a name="ln168">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln169"> </a>
<a name="ln170">  // we have to shift the multi_priority on history for the copied entries</a>
<a name="ln171">  // go through memory.style_items and shift one at the time</a>
<a name="ln172">  // we can't do it in a single statment because single-instance modules</a>
<a name="ln173">  // can't be duplicated</a>
<a name="ln174">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT DISTINCT operation FROM memory.style_items&quot;,</a>
<a name="ln175">                              -1, &amp;stmt, NULL);</a>
<a name="ln176">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln177">  {</a>
<a name="ln178">    const char *op_old = (const char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln179"> </a>
<a name="ln180">    // if the module is a single-instance, do nothing</a>
<a name="ln181">    GList *modules = darktable.iop;</a>
<a name="ln182">    while(modules)</a>
<a name="ln183">    {</a>
<a name="ln184">      dt_iop_module_so_t *find_op = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln185">      if(!strcmp(find_op-&gt;op, op_old))</a>
<a name="ln186">      {</a>
<a name="ln187">        break;</a>
<a name="ln188">      }</a>
<a name="ln189">      modules = g_list_next(modules);</a>
<a name="ln190">    }</a>
<a name="ln191">    if(modules &amp;&amp; (((dt_iop_module_so_t *)(modules-&gt;data))-&gt;flags() &amp; IOP_FLAGS_ONE_INSTANCE)) continue;</a>
<a name="ln192"> </a>
<a name="ln193">    sqlite3_stmt *stmt2 = NULL;</a>
<a name="ln194"> </a>
<a name="ln195">    // shift the priority on history</a>
<a name="ln196">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln197">                                &quot;UPDATE main.history SET multi_priority = multi_priority + &quot;</a>
<a name="ln198">                                &quot;(SELECT IFNULL(MAX(multi_priority), -1)+1 &quot;</a>
<a name="ln199">                                &quot;FROM memory.style_items &quot;</a>
<a name="ln200">                                &quot;WHERE memory.style_items.operation = main.history.operation) &quot;</a>
<a name="ln201">                                &quot;WHERE imgid = ?1 AND operation = ?2&quot;,</a>
<a name="ln202">                                -1, &amp;stmt2, NULL);</a>
<a name="ln203">    DT_DEBUG_SQLITE3_BIND_INT(stmt2, 1, dest_imgid);</a>
<a name="ln204">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt2, 2, op_old, -1, SQLITE_TRANSIENT);</a>
<a name="ln205">    sqlite3_step(stmt2);</a>
<a name="ln206">    sqlite3_finalize(stmt2);</a>
<a name="ln207">  }</a>
<a name="ln208">  sqlite3_finalize(stmt);</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">void dt_history_rebuild_multi_priority_merge(const int dest_imgid)</a>
<a name="ln212">{</a>
<a name="ln213">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln214"> </a>
<a name="ln215">  char operation_prev[257] = { 0 };</a>
<a name="ln216">  int multi_priority_next = -1;</a>
<a name="ln217"> </a>
<a name="ln218">  // first make as if copied items will be appended to history</a>
<a name="ln219">  // we'll merge it in the next step</a>
<a name="ln220">  _history_rebuild_multi_priority_append(dest_imgid);</a>
<a name="ln221"> </a>
<a name="ln222">  // select the last entry in history for each operation that we are about to copy</a>
<a name="ln223">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln224">      dt_database_get(darktable.db),</a>
<a name="ln225">      &quot;SELECT MAX(num), operation, multi_priority, multi_name FROM &quot;</a>
<a name="ln226">      &quot;main.history WHERE imgid = ?1 AND &quot;</a>
<a name="ln227">      &quot;EXISTS (SELECT * FROM memory.style_items WHERE main.history.operation=memory.style_items.operation) &quot;</a>
<a name="ln228">      &quot;GROUP BY operation, multi_priority &quot;</a>
<a name="ln229">      &quot;ORDER BY operation, multi_priority&quot;,</a>
<a name="ln230">      -1, &amp;stmt, NULL);</a>
<a name="ln231">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln232">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln233">  {</a>
<a name="ln234">    const char *op_old = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln235">    const int multi_priority_old = sqlite3_column_int(stmt, 2);</a>
<a name="ln236">    const char *multi_name_old = (const char *)sqlite3_column_text(stmt, 3);</a>
<a name="ln237"> </a>
<a name="ln238">    sqlite3_stmt *stmt2 = NULL;</a>
<a name="ln239"> </a>
<a name="ln240">    // if the module is a single-instance, do nothing</a>
<a name="ln241">    GList *modules = darktable.iop;</a>
<a name="ln242">    while(modules)</a>
<a name="ln243">    {</a>
<a name="ln244">      dt_iop_module_so_t *find_op = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln245">      if(!strcmp(find_op-&gt;op, op_old))</a>
<a name="ln246">      {</a>
<a name="ln247">        break;</a>
<a name="ln248">      }</a>
<a name="ln249">      modules = g_list_next(modules);</a>
<a name="ln250">    }</a>
<a name="ln251">    if(modules &amp;&amp; (((dt_iop_module_so_t *)(modules-&gt;data))-&gt;flags() &amp; IOP_FLAGS_ONE_INSTANCE)) continue;</a>
<a name="ln252"> </a>
<a name="ln253">    // we start a new operation, get the next priority</a>
<a name="ln254">    if(strcmp(op_old, operation_prev) != 0)</a>
<a name="ln255">    {</a>
<a name="ln256">      snprintf(operation_prev, sizeof(operation_prev), &quot;%s&quot;, op_old);</a>
<a name="ln257"> </a>
<a name="ln258">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln259">                                  &quot;SELECT MAX(multi_priority) FROM memory.style_items &quot;</a>
<a name="ln260">                                  &quot;WHERE operation=?1&quot;,</a>
<a name="ln261">                                  -1, &amp;stmt2, NULL);</a>
<a name="ln262">      DT_DEBUG_SQLITE3_BIND_TEXT(stmt2, 1, op_old, -1, SQLITE_TRANSIENT);</a>
<a name="ln263">      if(sqlite3_step(stmt2) == SQLITE_ROW)</a>
<a name="ln264">        multi_priority_next = sqlite3_column_int(stmt2, 0);</a>
<a name="ln265">      else</a>
<a name="ln266">        multi_priority_next = -1;</a>
<a name="ln267">      sqlite3_finalize(stmt2);</a>
<a name="ln268">    }</a>
<a name="ln269"> </a>
<a name="ln270">    // if this (operation, multi_name) exists on memory.style_items it should be replaced on dest_imgid</a>
<a name="ln271">    // we also check that it hasn't been used to replace another instance already</a>
<a name="ln272">    int multi_priority_new = -1;</a>
<a name="ln273">    int num_new = -1;</a>
<a name="ln274"> </a>
<a name="ln275">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln276">                                &quot;SELECT num, operation, multi_name, multi_priority FROM memory.style_items &quot;</a>
<a name="ln277">                                &quot;WHERE operation=?1 AND multi_name=?2 AND num &gt;= 0&quot;,</a>
<a name="ln278">                                -1, &amp;stmt2, NULL);</a>
<a name="ln279">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt2, 1, op_old, -1, SQLITE_TRANSIENT);</a>
<a name="ln280">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt2, 2, multi_name_old, -1, SQLITE_TRANSIENT);</a>
<a name="ln281">    if(sqlite3_step(stmt2) == SQLITE_ROW)</a>
<a name="ln282">    {</a>
<a name="ln283">      num_new = sqlite3_column_int(stmt2, 0);</a>
<a name="ln284">      multi_priority_new = sqlite3_column_int(stmt2, 3);</a>
<a name="ln285">    }</a>
<a name="ln286">    sqlite3_finalize(stmt2);</a>
<a name="ln287"> </a>
<a name="ln288">    if(multi_priority_new &gt;= 0)</a>
<a name="ln289">    {</a>
<a name="ln290">      // if this (operation, multi_name) exists in memory.style_items it should replace the one in history</a>
<a name="ln291">      // so we update the multi_priority in history with the new one from memory.style_items</a>
<a name="ln292">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln293">                                  &quot;UPDATE main.history SET multi_priority = ?1&quot;</a>
<a name="ln294">                                  &quot;WHERE imgid=?2 AND operation=?3 AND multi_priority=?4&quot;,</a>
<a name="ln295">                                  -1, &amp;stmt2, NULL);</a>
<a name="ln296">      DT_DEBUG_SQLITE3_BIND_INT(stmt2, 1, multi_priority_new);</a>
<a name="ln297">      DT_DEBUG_SQLITE3_BIND_INT(stmt2, 2, dest_imgid);</a>
<a name="ln298">      DT_DEBUG_SQLITE3_BIND_TEXT(stmt2, 3, op_old, -1, SQLITE_TRANSIENT);</a>
<a name="ln299">      DT_DEBUG_SQLITE3_BIND_INT(stmt2, 4, multi_priority_old);</a>
<a name="ln300">      sqlite3_step(stmt2);</a>
<a name="ln301">      sqlite3_finalize(stmt2);</a>
<a name="ln302"> </a>
<a name="ln303">      // and flag this instance as used</a>
<a name="ln304">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;UPDATE memory.style_items SET num = -1 &quot;</a>
<a name="ln305">                                                                 &quot;WHERE num = ?1&quot;,</a>
<a name="ln306">                                  -1, &amp;stmt2, NULL);</a>
<a name="ln307">      DT_DEBUG_SQLITE3_BIND_INT(stmt2, 1, num_new);</a>
<a name="ln308">      sqlite3_step(stmt2);</a>
<a name="ln309">      sqlite3_finalize(stmt2);</a>
<a name="ln310">    }</a>
<a name="ln311">    else</a>
<a name="ln312">    {</a>
<a name="ln313">      // if this (operation, multi_name) do not exists in memory.style_items it should be</a>
<a name="ln314">      // pushed back in the pipe, so copied operation are last in the pipe</a>
<a name="ln315">      // we shift the multi_priority in history</a>
<a name="ln316">      multi_priority_next++;</a>
<a name="ln317"> </a>
<a name="ln318">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln319">                                  &quot;UPDATE main.history SET multi_priority = ?4 &quot;</a>
<a name="ln320">                                  &quot;WHERE imgid=?1 AND operation=?2 AND multi_priority=?3&quot;,</a>
<a name="ln321">                                  -1, &amp;stmt2, NULL);</a>
<a name="ln322">      DT_DEBUG_SQLITE3_BIND_INT(stmt2, 1, dest_imgid);</a>
<a name="ln323">      DT_DEBUG_SQLITE3_BIND_TEXT(stmt2, 2, op_old, -1, SQLITE_TRANSIENT);</a>
<a name="ln324">      DT_DEBUG_SQLITE3_BIND_INT(stmt2, 3, multi_priority_old);</a>
<a name="ln325">      DT_DEBUG_SQLITE3_BIND_INT(stmt2, 4, multi_priority_next);</a>
<a name="ln326">      sqlite3_step(stmt2);</a>
<a name="ln327">      sqlite3_finalize(stmt2);</a>
<a name="ln328">    }</a>
<a name="ln329">  }</a>
<a name="ln330">  sqlite3_finalize(stmt);</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333">void dt_history_delete_on_image(int32_t imgid)</a>
<a name="ln334">{</a>
<a name="ln335">  sqlite3_stmt *stmt;</a>
<a name="ln336">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln337">                              &amp;stmt, NULL);</a>
<a name="ln338">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln339">  sqlite3_step(stmt);</a>
<a name="ln340">  sqlite3_finalize(stmt);</a>
<a name="ln341"> </a>
<a name="ln342">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln343">                              &quot;UPDATE main.images SET history_end = 0 WHERE id = ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln344">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln345">  sqlite3_step(stmt);</a>
<a name="ln346">  sqlite3_finalize(stmt);</a>
<a name="ln347"> </a>
<a name="ln348">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.mask WHERE imgid = ?1&quot;, -1, &amp;stmt,</a>
<a name="ln349">                              NULL);</a>
<a name="ln350">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln351">  sqlite3_step(stmt);</a>
<a name="ln352">  sqlite3_finalize(stmt);</a>
<a name="ln353"> </a>
<a name="ln354">  remove_preset_flag(imgid);</a>
<a name="ln355"> </a>
<a name="ln356">  /* if current image in develop reload history */</a>
<a name="ln357">  if(dt_dev_is_current_image(darktable.develop, imgid)) dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln358"> </a>
<a name="ln359">  /* make sure mipmaps are recomputed */</a>
<a name="ln360">  dt_mipmap_cache_remove(darktable.mipmap_cache, imgid);</a>
<a name="ln361"> </a>
<a name="ln362">  /* remove darktable|style|* tags */</a>
<a name="ln363">  dt_tag_detach_by_string(&quot;darktable|style%&quot;, imgid);</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">void dt_history_delete_on_selection()</a>
<a name="ln367">{</a>
<a name="ln368">  sqlite3_stmt *stmt;</a>
<a name="ln369">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;,</a>
<a name="ln370">                              -1, &amp;stmt, NULL);</a>
<a name="ln371">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln372">  {</a>
<a name="ln373">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln374">    dt_history_delete_on_image(imgid);</a>
<a name="ln375">    dt_image_set_aspect_ratio(imgid);</a>
<a name="ln376">  }</a>
<a name="ln377">  sqlite3_finalize(stmt);</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">int dt_history_load_and_apply(int imgid, gchar *filename, int history_only)</a>
<a name="ln381">{</a>
<a name="ln382">  int res = 0;</a>
<a name="ln383">  dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln384">  if(img)</a>
<a name="ln385">  {</a>
<a name="ln386">    if(dt_exif_xmp_read(img, filename, history_only)) return 1;</a>
<a name="ln387"> </a>
<a name="ln388">    /* if current image in develop reload history */</a>
<a name="ln389">    if(dt_dev_is_current_image(darktable.develop, imgid)) dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln390"> </a>
<a name="ln391">    dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_SAFE);</a>
<a name="ln392">    dt_mipmap_cache_remove(darktable.mipmap_cache, imgid);</a>
<a name="ln393">  }</a>
<a name="ln394">  return res;</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">int dt_history_load_and_apply_on_selection(gchar *filename)</a>
<a name="ln398">{</a>
<a name="ln399">  int res = 0;</a>
<a name="ln400">  sqlite3_stmt *stmt;</a>
<a name="ln401">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;,</a>
<a name="ln402">                              -1, &amp;stmt, NULL);</a>
<a name="ln403">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln404">  {</a>
<a name="ln405">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln406">    if(dt_history_load_and_apply(imgid, filename, 1)) res = 1;</a>
<a name="ln407">  }</a>
<a name="ln408">  sqlite3_finalize(stmt);</a>
<a name="ln409">  return res;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">#if 0</a>
<a name="ln413">int dt_history_copy_and_paste_on_image(int32_t imgid, int32_t dest_imgid, gboolean merge, GList *ops)</a>
<a name="ln414">{</a>
<a name="ln415">  sqlite3_stmt *stmt;</a>
<a name="ln416">  if(imgid == dest_imgid) return 1;</a>
<a name="ln417"> </a>
<a name="ln418">  if(imgid == -1)</a>
<a name="ln419">  {</a>
<a name="ln420">    dt_control_log(_(&quot;you need to copy history from an image before you paste it onto another&quot;));</a>
<a name="ln421">    return 1;</a>
<a name="ln422">  }</a>
<a name="ln423"> </a>
<a name="ln424">  // be sure the current history is written before pasting some other history data</a>
<a name="ln425">  const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln426">  if(cv-&gt;view((dt_view_t *)cv) == DT_VIEW_DARKROOM) dt_dev_write_history(darktable.develop);</a>
<a name="ln427"> </a>
<a name="ln428">  /* if merge onto history stack, lets find history offest in destination image */</a>
<a name="ln429">  int32_t offs = 0;</a>
<a name="ln430">  if(merge)</a>
<a name="ln431">  {</a>
<a name="ln432">    /* apply on top of history stack */</a>
<a name="ln433">    // first trim the stack to get rid of whatever is above the selected entry</a>
<a name="ln434">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln435">                                &quot;DELETE FROM main.history WHERE imgid = ?1 AND num &gt;= (SELECT history_end &quot;</a>
<a name="ln436">                                &quot;FROM main.images WHERE id = imgid)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln437">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln438">    sqlite3_step(stmt);</a>
<a name="ln439">    sqlite3_finalize(stmt);</a>
<a name="ln440"> </a>
<a name="ln441">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln442">                                &quot;SELECT IFNULL(MAX(num), -1)+1 FROM main.history WHERE imgid = ?1&quot;,</a>
<a name="ln443">                                -1, &amp;stmt, NULL);</a>
<a name="ln444">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln445">    if(sqlite3_step(stmt) == SQLITE_ROW) offs = sqlite3_column_int(stmt, 0);</a>
<a name="ln446">  }</a>
<a name="ln447">  else</a>
<a name="ln448">  {</a>
<a name="ln449">    /* replace history stack */</a>
<a name="ln450">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln451">                                &amp;stmt, NULL);</a>
<a name="ln452">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln453">    sqlite3_step(stmt);</a>
<a name="ln454">  }</a>
<a name="ln455">  sqlite3_finalize(stmt);</a>
<a name="ln456"> </a>
<a name="ln457">  /* delete all items from the temp styles_items, this table is used only to get a ROWNUM of the results */</a>
<a name="ln458">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM memory.style_items&quot;, NULL, NULL, NULL);</a>
<a name="ln459"> </a>
<a name="ln460">  /* copy history items from styles onto temp table */</a>
<a name="ln461"> </a>
<a name="ln462">  //  prepare SQL request</a>
<a name="ln463">  if(merge &amp;&amp; !ops)</a>
<a name="ln464">  {</a>
<a name="ln465">    // the user has selected copy all and append</a>
<a name="ln466">    // select only the last entry in history for each (operation, multi_priority)</a>
<a name="ln467">    DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln468">        dt_database_get(darktable.db),</a>
<a name="ln469">        &quot;INSERT INTO memory.style_items (num, module, operation, op_params, enabled, blendop_params, &quot;</a>
<a name="ln470">        &quot;blendop_version, multi_name, multi_priority) SELECT MAX(num) AS max_num, module, operation, &quot;</a>
<a name="ln471">        &quot;op_params, enabled, blendop_params, blendop_version, multi_name, multi_priority FROM &quot;</a>
<a name="ln472">        &quot;main.history WHERE imgid = ?1&quot;</a>
<a name="ln473">        &quot;GROUP BY operation, multi_priority &quot;</a>
<a name="ln474">        &quot;ORDER BY max_num&quot;,</a>
<a name="ln475">        -1, &amp;stmt, NULL);</a>
<a name="ln476">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln477">    sqlite3_step(stmt);</a>
<a name="ln478">    sqlite3_finalize(stmt);</a>
<a name="ln479">  }</a>
<a name="ln480">  else</a>
<a name="ln481">  {</a>
<a name="ln482">    // in any other case we select all items in history or only the ones selected by the user</a>
<a name="ln483">    char req[2048];</a>
<a name="ln484">    g_strlcpy(req, &quot;INSERT INTO memory.style_items (num, module, operation, op_params, enabled, blendop_params, &quot;</a>
<a name="ln485">                   &quot;blendop_version, multi_name, multi_priority) SELECT num, module, operation, &quot;</a>
<a name="ln486">                   &quot;op_params, enabled, blendop_params, blendop_version, multi_name, multi_priority FROM &quot;</a>
<a name="ln487">                   &quot;main.history WHERE imgid = ?1&quot;,</a>
<a name="ln488">              sizeof(req));</a>
<a name="ln489"> </a>
<a name="ln490">    //  Add ops selection if any format: ... and num in (val1, val2)</a>
<a name="ln491">    if(ops)</a>
<a name="ln492">    {</a>
<a name="ln493">      GList *l = ops;</a>
<a name="ln494">      int first = 1;</a>
<a name="ln495">      g_strlcat(req, &quot; AND num IN (&quot;, sizeof(req));</a>
<a name="ln496"> </a>
<a name="ln497">      while(l)</a>
<a name="ln498">      {</a>
<a name="ln499">        unsigned int value = GPOINTER_TO_UINT(l-&gt;data);</a>
<a name="ln500">        char v[30];</a>
<a name="ln501"> </a>
<a name="ln502">        if(!first) g_strlcat(req, &quot;,&quot;, sizeof(req));</a>
<a name="ln503">        snprintf(v, sizeof(v), &quot;%u&quot;, value);</a>
<a name="ln504">        g_strlcat(req, v, sizeof(req));</a>
<a name="ln505">        first = 0;</a>
<a name="ln506">        l = g_list_next(l);</a>
<a name="ln507">      }</a>
<a name="ln508">      g_strlcat(req, &quot;)&quot;, sizeof(req));</a>
<a name="ln509">    }</a>
<a name="ln510"> </a>
<a name="ln511">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), req, -1, &amp;stmt, NULL);</a>
<a name="ln512">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln513">    sqlite3_step(stmt);</a>
<a name="ln514">    sqlite3_finalize(stmt);</a>
<a name="ln515">  }</a>
<a name="ln516"> </a>
<a name="ln517">  if(merge)</a>
<a name="ln518">  {</a>
<a name="ln519">    _dt_history_cleanup_multi_instance();</a>
<a name="ln520">    dt_history_rebuild_multi_priority_merge(dest_imgid);</a>
<a name="ln521">  }</a>
<a name="ln522"> </a>
<a name="ln523">  /* copy the history items into the history of the dest image */</a>
<a name="ln524">  /* note: rowid starts at 1 while num has to start at 0! */</a>
<a name="ln525">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln526">                              &quot;INSERT INTO main.history &quot;</a>
<a name="ln527">                              &quot;(imgid,num,module,operation,op_params,enabled,blendop_params,blendop_&quot;</a>
<a name="ln528">                              &quot;version,multi_priority,multi_name) SELECT &quot;</a>
<a name="ln529">                              &quot;?1,?2+rowid-1,module,operation,op_params,enabled,blendop_params,blendop_&quot;</a>
<a name="ln530">                              &quot;version,multi_priority,multi_name FROM memory.style_items&quot;,</a>
<a name="ln531">                              -1, &amp;stmt, NULL);</a>
<a name="ln532">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln533">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, offs);</a>
<a name="ln534">  sqlite3_step(stmt);</a>
<a name="ln535">  sqlite3_finalize(stmt);</a>
<a name="ln536"> </a>
<a name="ln537">  // we have to copy masks too</a>
<a name="ln538">  // what to do with existing masks ?</a>
<a name="ln539">  if(merge)</a>
<a name="ln540">  {</a>
<a name="ln541">    // there's very little chance that we will have same shapes id.</a>
<a name="ln542">    // but we may want to handle this case anyway</a>
<a name="ln543">    // and it's not trivial at all !</a>
<a name="ln544">  }</a>
<a name="ln545">  else</a>
<a name="ln546">  {</a>
<a name="ln547">    // let's remove all existing shapes</a>
<a name="ln548">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.mask WHERE imgid = ?1&quot;, -1, &amp;stmt,</a>
<a name="ln549">                                NULL);</a>
<a name="ln550">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln551">    sqlite3_step(stmt);</a>
<a name="ln552">    sqlite3_finalize(stmt);</a>
<a name="ln553">  }</a>
<a name="ln554"> </a>
<a name="ln555">  // let's copy now</a>
<a name="ln556">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln557">      dt_database_get(darktable.db),</a>
<a name="ln558">      &quot;INSERT INTO main.mask (imgid, formid, form, name, version, points, points_count, source) SELECT &quot;</a>
<a name="ln559">      &quot;?1, formid, form, name, version, points, points_count, source FROM main.mask WHERE imgid = ?2&quot;,</a>
<a name="ln560">      -1, &amp;stmt, NULL);</a>
<a name="ln561">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln562">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln563">  sqlite3_step(stmt);</a>
<a name="ln564">  sqlite3_finalize(stmt);</a>
<a name="ln565"> </a>
<a name="ln566">  // always make the whole stack active</a>
<a name="ln567">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln568">                              &quot;UPDATE main.images SET history_end = (SELECT MAX(num) + 1 FROM main.history &quot;</a>
<a name="ln569">                              &quot;WHERE imgid = ?1) WHERE id = ?1&quot;,</a>
<a name="ln570">                              -1, &amp;stmt, NULL);</a>
<a name="ln571">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln572">  sqlite3_step(stmt);</a>
<a name="ln573">  sqlite3_finalize(stmt);</a>
<a name="ln574"> </a>
<a name="ln575">  /* if current image in develop reload history */</a>
<a name="ln576">  if(dt_dev_is_current_image(darktable.develop, dest_imgid))</a>
<a name="ln577">  {</a>
<a name="ln578">    dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln579">    dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln580">  }</a>
<a name="ln581"> </a>
<a name="ln582">  /* update xmp file */</a>
<a name="ln583">  dt_image_synch_xmp(dest_imgid);</a>
<a name="ln584"> </a>
<a name="ln585">  dt_mipmap_cache_remove(darktable.mipmap_cache, dest_imgid);</a>
<a name="ln586"> </a>
<a name="ln587">  /* update the aspect ratio if the current sorting is based on aspect ratio, otherwise the aspect ratio will be</a>
<a name="ln588">     recalculated when the mimpap will be recreated */</a>
<a name="ln589">  if (darktable.collection-&gt;params.sort == DT_COLLECTION_SORT_ASPECT_RATIO)</a>
<a name="ln590">    dt_image_set_aspect_ratio(dest_imgid);</a>
<a name="ln591"> </a>
<a name="ln592">  return 0;</a>
<a name="ln593">}</a>
<a name="ln594">#endif</a>
<a name="ln595"> </a>
<a name="ln596">// returns the first history item with hist-&gt;module == module</a>
<a name="ln597">static dt_dev_history_item_t *_search_history_by_module(dt_develop_t *dev, dt_iop_module_t *module)</a>
<a name="ln598">{</a>
<a name="ln599">  dt_dev_history_item_t *hist_mod = NULL;</a>
<a name="ln600">  GList *history = g_list_first(dev-&gt;history);</a>
<a name="ln601">  while(history)</a>
<a name="ln602">  {</a>
<a name="ln603">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln604"> </a>
<a name="ln605">    if(hist-&gt;module == module)</a>
<a name="ln606">    {</a>
<a name="ln607">      hist_mod = hist;</a>
<a name="ln608">      break;</a>
<a name="ln609">    }</a>
<a name="ln610">    history = g_list_next(history);</a>
<a name="ln611">  }</a>
<a name="ln612">  return hist_mod;</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615">// returns the first history item with corresponding module-&gt;op</a>
<a name="ln616">static dt_dev_history_item_t *_search_history_by_op(dt_develop_t *dev, dt_iop_module_t *module)</a>
<a name="ln617">{</a>
<a name="ln618">  dt_dev_history_item_t *hist_mod = NULL;</a>
<a name="ln619">  GList *history = g_list_first(dev-&gt;history);</a>
<a name="ln620">  while(history)</a>
<a name="ln621">  {</a>
<a name="ln622">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln623"> </a>
<a name="ln624">    if(strcmp(hist-&gt;module-&gt;op, module-&gt;op) == 0)</a>
<a name="ln625">    {</a>
<a name="ln626">      hist_mod = hist;</a>
<a name="ln627">      break;</a>
<a name="ln628">    }</a>
<a name="ln629">    history = g_list_next(history);</a>
<a name="ln630">  }</a>
<a name="ln631">  return hist_mod;</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634">// returns the module on modules_list that is equal to module</a>
<a name="ln635">// used to check if module exists on the list</a>
<a name="ln636">static dt_iop_module_t *_search_list_iop_by_module(GList *modules_list, dt_iop_module_t *module)</a>
<a name="ln637">{</a>
<a name="ln638">  dt_iop_module_t *mod_ret = NULL;</a>
<a name="ln639">  GList *modules = g_list_first(modules_list);</a>
<a name="ln640">  while(modules)</a>
<a name="ln641">  {</a>
<a name="ln642">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln643"> </a>
<a name="ln644">    if(mod == module)</a>
<a name="ln645">    {</a>
<a name="ln646">      mod_ret = mod;</a>
<a name="ln647">      break;</a>
<a name="ln648">    }</a>
<a name="ln649">    modules = g_list_next(modules);</a>
<a name="ln650">  }</a>
<a name="ln651">  return mod_ret;</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">// returns the first module on modules_list with operation = op_name</a>
<a name="ln655">static dt_iop_module_t *_search_list_iop_by_op(GList *modules_list, const char *op_name)</a>
<a name="ln656">{</a>
<a name="ln657">  dt_iop_module_t *mod_ret = NULL;</a>
<a name="ln658">  GList *modules = g_list_first(modules_list);</a>
<a name="ln659">  while(modules)</a>
<a name="ln660">  {</a>
<a name="ln661">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln662"> </a>
<a name="ln663">    if(strcmp(mod-&gt;op, op_name) == 0)</a>
<a name="ln664">    {</a>
<a name="ln665">      mod_ret = mod;</a>
<a name="ln666">      break;</a>
<a name="ln667">    }</a>
<a name="ln668">    modules = g_list_next(modules);</a>
<a name="ln669">  }</a>
<a name="ln670">  return mod_ret;</a>
<a name="ln671">}</a>
<a name="ln672"> </a>
<a name="ln673">// returns a new multi_priority number for op_name</a>
<a name="ln674">static int _get_new_iop_multi_priority(dt_develop_t *dev, const char *op_name)</a>
<a name="ln675">{</a>
<a name="ln676">  int multi_priority_new = -1;</a>
<a name="ln677">  GList *modules = g_list_first(dev-&gt;iop);</a>
<a name="ln678">  while(modules)</a>
<a name="ln679">  {</a>
<a name="ln680">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln681"> </a>
<a name="ln682">    if(strcmp(mod-&gt;op, op_name) == 0)</a>
<a name="ln683">    {</a>
<a name="ln684">      multi_priority_new = MAX(multi_priority_new, mod-&gt;multi_priority);</a>
<a name="ln685">    }</a>
<a name="ln686">    modules = g_list_next(modules);</a>
<a name="ln687">  }</a>
<a name="ln688">  return (multi_priority_new + 1);</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">static int _history_merge_module_into_history(dt_develop_t *dev_dest, dt_iop_module_t *mod_src, GList **_modules_used,</a>
<a name="ln692">                                         const int append)</a>
<a name="ln693">{</a>
<a name="ln694">  int module_added = 1;</a>
<a name="ln695">  GList *modules_used = *_modules_used;</a>
<a name="ln696">  dt_iop_module_t *module = NULL;</a>
<a name="ln697">  dt_iop_module_t *mod_replace = NULL;</a>
<a name="ln698">  int multi_priority = mod_src-&gt;multi_priority;</a>
<a name="ln699"> </a>
<a name="ln700">  // one-instance modules always replace the existing one</a>
<a name="ln701">  if(mod_src-&gt;flags() &amp; IOP_FLAGS_ONE_INSTANCE)</a>
<a name="ln702">  {</a>
<a name="ln703">    mod_replace = _search_list_iop_by_op(dev_dest-&gt;iop, mod_src-&gt;op);</a>
<a name="ln704">    if(mod_replace)</a>
<a name="ln705">    {</a>
<a name="ln706">      multi_priority = mod_replace-&gt;multi_priority;</a>
<a name="ln707">    }</a>
<a name="ln708">    else</a>
<a name="ln709">    {</a>
<a name="ln710">      fprintf(stderr, &quot;[_history_merge_module_into_history] can't find single instance module %s\n&quot;,</a>
<a name="ln711">              mod_src-&gt;op);</a>
<a name="ln712">      module_added = 0;</a>
<a name="ln713">    }</a>
<a name="ln714">  }</a>
<a name="ln715"> </a>
<a name="ln716">  if(module_added &amp;&amp; !append)</a>
<a name="ln717">  {</a>
<a name="ln718">    // we haven't found a module to replace</a>
<a name="ln719">    if(mod_replace == NULL)</a>
<a name="ln720">    {</a>
<a name="ln721">      // check if there's a module with the same (operation, multi_name) on dev-&gt;iop</a>
<a name="ln722">      GList *modules_dest = g_list_first(dev_dest-&gt;iop);</a>
<a name="ln723">      while(modules_dest)</a>
<a name="ln724">      {</a>
<a name="ln725">        dt_iop_module_t *mod_dest = (dt_iop_module_t *)(modules_dest-&gt;data);</a>
<a name="ln726"> </a>
<a name="ln727">        if(strcmp(mod_src-&gt;op, mod_dest-&gt;op) == 0 &amp;&amp; strcmp(mod_src-&gt;multi_name, mod_dest-&gt;multi_name) == 0)</a>
<a name="ln728">        {</a>
<a name="ln729">          // but only if it hasn't been used already</a>
<a name="ln730">          if(_search_list_iop_by_module(modules_used, mod_dest) == NULL)</a>
<a name="ln731">          {</a>
<a name="ln732">            // we will replace this module</a>
<a name="ln733">            modules_used = g_list_append(modules_used, mod_dest);</a>
<a name="ln734">            mod_replace = mod_dest;</a>
<a name="ln735">            multi_priority = mod_replace-&gt;multi_priority;</a>
<a name="ln736">            break;</a>
<a name="ln737">          }</a>
<a name="ln738">        }</a>
<a name="ln739">        modules_dest = g_list_next(modules_dest);</a>
<a name="ln740">      }</a>
<a name="ln741">    }</a>
<a name="ln742">  }</a>
<a name="ln743"> </a>
<a name="ln744">  if(module_added)</a>
<a name="ln745">  {</a>
<a name="ln746">    // we haven't found a module to replace, so we will create a new instance</a>
<a name="ln747">    if(mod_replace == NULL)</a>
<a name="ln748">    {</a>
<a name="ln749">      // but if there's an un-used instance on dev-&gt;iop we will use that</a>
<a name="ln750">      if(_search_history_by_op(dev_dest, mod_src) == NULL)</a>
<a name="ln751">      {</a>
<a name="ln752">        // there should be only one instance of this iop (since is un-used)</a>
<a name="ln753">        mod_replace = _search_list_iop_by_op(dev_dest-&gt;iop, mod_src-&gt;op);</a>
<a name="ln754">        if(mod_replace)</a>
<a name="ln755">        {</a>
<a name="ln756">          multi_priority = mod_replace-&gt;multi_priority;</a>
<a name="ln757">        }</a>
<a name="ln758">        else</a>
<a name="ln759">        {</a>
<a name="ln760">          fprintf(stderr, &quot;[_history_merge_module_into_history] can't find base instance module %s\n&quot;,</a>
<a name="ln761">                  mod_src-&gt;op);</a>
<a name="ln762">          module_added = 0;</a>
<a name="ln763">        }</a>
<a name="ln764">      }</a>
<a name="ln765">    }</a>
<a name="ln766">  }</a>
<a name="ln767"> </a>
<a name="ln768">  if(module_added)</a>
<a name="ln769">  {</a>
<a name="ln770">    // change multi_priority so it replaces it</a>
<a name="ln771">    if(!mod_replace)</a>
<a name="ln772">    {</a>
<a name="ln773">      // otherwise generate a new multi_priority</a>
<a name="ln774">      multi_priority = _get_new_iop_multi_priority(dev_dest, mod_src-&gt;op);</a>
<a name="ln775">    }</a>
<a name="ln776">  }</a>
<a name="ln777"> </a>
<a name="ln778">  if(module_added)</a>
<a name="ln779">  {</a>
<a name="ln780">    // if we are creating a new instance, create a new module</a>
<a name="ln781">    if(!mod_replace)</a>
<a name="ln782">    {</a>
<a name="ln783">      dt_iop_module_t *base = _search_list_iop_by_op(dev_dest-&gt;iop, mod_src-&gt;op);</a>
<a name="ln784">      module = (dt_iop_module_t *)calloc(1, sizeof(dt_iop_module_t));</a>
<a name="ln785">      if(dt_iop_load_module(module, base-&gt;so, dev_dest))</a>
<a name="ln786">      {</a>
<a name="ln787">        module_added = 0;</a>
<a name="ln788">      }</a>
<a name="ln789">      else</a>
<a name="ln790">      {</a>
<a name="ln791">        module-&gt;instance = mod_src-&gt;instance;</a>
<a name="ln792">        dt_iop_update_multi_priority(module, multi_priority);</a>
<a name="ln793"> </a>
<a name="ln794">        dev_dest-&gt;iop = g_list_insert_sorted(dev_dest-&gt;iop, module, sort_plugins);</a>
<a name="ln795">      }</a>
<a name="ln796">    }</a>
<a name="ln797">    else</a>
<a name="ln798">    {</a>
<a name="ln799">      module = mod_replace;</a>
<a name="ln800">    }</a>
<a name="ln801"> </a>
<a name="ln802">    module-&gt;enabled = mod_src-&gt;enabled;</a>
<a name="ln803">    snprintf(module-&gt;multi_name, sizeof(module-&gt;multi_name), &quot;%s&quot;, mod_src-&gt;multi_name);</a>
<a name="ln804"> </a>
<a name="ln805">    memcpy(module-&gt;params, mod_src-&gt;params, module-&gt;params_size);</a>
<a name="ln806">    if(module-&gt;flags() &amp; IOP_FLAGS_SUPPORTS_BLENDING)</a>
<a name="ln807">    {</a>
<a name="ln808">      memcpy(module-&gt;blend_params, mod_src-&gt;blend_params, sizeof(dt_develop_blend_params_t));</a>
<a name="ln809">      module-&gt;blend_params-&gt;mask_id = mod_src-&gt;blend_params-&gt;mask_id;</a>
<a name="ln810">    }</a>
<a name="ln811">  }</a>
<a name="ln812"> </a>
<a name="ln813">  // and we add it to history</a>
<a name="ln814">  if(module_added)</a>
<a name="ln815">  {</a>
<a name="ln816">    dt_dev_add_history_item_ext(dev_dest, module, FALSE, TRUE);</a>
<a name="ln817">    dt_dev_pop_history_items_ext(dev_dest, dev_dest-&gt;history_end);</a>
<a name="ln818"> </a>
<a name="ln819">    // we have added the module, now we need to make it last on the pipe</a>
<a name="ln820">    // for this we increment 1 to all instances with multi_priority &lt; than this one</a>
<a name="ln821">    // and assign to it multi_priority = 0</a>
<a name="ln822">    if(module-&gt;multi_priority &gt; 0)</a>
<a name="ln823">    {</a>
<a name="ln824">      multi_priority = module-&gt;multi_priority;</a>
<a name="ln825"> </a>
<a name="ln826">      GList *modules_dest = g_list_first(dev_dest-&gt;iop);</a>
<a name="ln827">      while(modules_dest)</a>
<a name="ln828">      {</a>
<a name="ln829">        dt_iop_module_t *mod_dest = (dt_iop_module_t *)(modules_dest-&gt;data);</a>
<a name="ln830"> </a>
<a name="ln831">        if(mod_dest-&gt;instance == module-&gt;instance)</a>
<a name="ln832">        {</a>
<a name="ln833">          if(mod_dest-&gt;multi_priority &lt; multi_priority)</a>
<a name="ln834">            dt_iop_update_multi_priority(mod_dest, mod_dest-&gt;multi_priority + 1);</a>
<a name="ln835">          else if(mod_dest == module)</a>
<a name="ln836">            dt_iop_update_multi_priority(mod_dest, 0);</a>
<a name="ln837"> </a>
<a name="ln838">          // also update the history</a>
<a name="ln839">          GList *history = g_list_first(dev_dest-&gt;history);</a>
<a name="ln840">          while(history)</a>
<a name="ln841">          {</a>
<a name="ln842">            dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln843"> </a>
<a name="ln844">            if(hist-&gt;module-&gt;instance == module-&gt;instance)</a>
<a name="ln845">              hist-&gt;multi_priority = hist-&gt;module-&gt;multi_priority;</a>
<a name="ln846"> </a>
<a name="ln847">            history = g_list_next(history);</a>
<a name="ln848">          }</a>
<a name="ln849">        }</a>
<a name="ln850"> </a>
<a name="ln851">        modules_dest = g_list_next(modules_dest);</a>
<a name="ln852">      }</a>
<a name="ln853">    }</a>
<a name="ln854">  }</a>
<a name="ln855"> </a>
<a name="ln856">  *_modules_used = modules_used;</a>
<a name="ln857"> </a>
<a name="ln858">  return module_added;</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861">// fills used with formid, if it is a group it recurs and fill all sub-forms</a>
<a name="ln862">static void _fill_used_forms(GList *forms_list, int formid, int *used, int nb)</a>
<a name="ln863">{</a>
<a name="ln864">  // first, we search for the formid in used table</a>
<a name="ln865">  for(int i = 0; i &lt; nb; i++)</a>
<a name="ln866">  {</a>
<a name="ln867">    if(used[i] == 0)</a>
<a name="ln868">    {</a>
<a name="ln869">      // we store the formid</a>
<a name="ln870">      used[i] = formid;</a>
<a name="ln871">      break;</a>
<a name="ln872">    }</a>
<a name="ln873">    if(used[i] == formid) break;</a>
<a name="ln874">  }</a>
<a name="ln875"> </a>
<a name="ln876">  // if the form is a group, we iterate through the sub-forms</a>
<a name="ln877">  dt_masks_form_t *form = dt_masks_get_from_id_ext(forms_list, formid);</a>
<a name="ln878">  if(form &amp;&amp; (form-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln879">  {</a>
<a name="ln880">    GList *grpts = g_list_first(form-&gt;points);</a>
<a name="ln881">    while(grpts)</a>
<a name="ln882">    {</a>
<a name="ln883">      dt_masks_point_group_t *grpt = (dt_masks_point_group_t *)grpts-&gt;data;</a>
<a name="ln884">      _fill_used_forms(forms_list, grpt-&gt;formid, used, nb);</a>
<a name="ln885">      grpts = g_list_next(grpts);</a>
<a name="ln886">    }</a>
<a name="ln887">  }</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">static int _history_copy_and_paste_on_image_merge(int32_t imgid, int32_t dest_imgid, GList *ops)</a>
<a name="ln891">{</a>
<a name="ln892">  GList *modules_used = NULL;</a>
<a name="ln893"> </a>
<a name="ln894">  dt_develop_t _dev_src = { 0 };</a>
<a name="ln895">  dt_develop_t _dev_dest = { 0 };</a>
<a name="ln896"> </a>
<a name="ln897">  dt_develop_t *dev_src = &amp;_dev_src;</a>
<a name="ln898">  dt_develop_t *dev_dest = &amp;_dev_dest;</a>
<a name="ln899"> </a>
<a name="ln900">  // we will do the copy/paste on memory so we can deal with masks</a>
<a name="ln901">  dt_dev_init(dev_src, FALSE);</a>
<a name="ln902">  dt_dev_init(dev_dest, FALSE);</a>
<a name="ln903"> </a>
<a name="ln904">  dev_src-&gt;iop = dt_iop_load_modules_ext(dev_src, TRUE);</a>
<a name="ln905">  dev_dest-&gt;iop = dt_iop_load_modules_ext(dev_dest, TRUE);</a>
<a name="ln906"> </a>
<a name="ln907">  dt_masks_read_forms_ext(dev_src, imgid, TRUE);</a>
<a name="ln908">  dt_masks_read_forms_ext(dev_dest, dest_imgid, TRUE);</a>
<a name="ln909"> </a>
<a name="ln910">  dt_dev_read_history_ext(dev_src, imgid, TRUE);</a>
<a name="ln911">  dt_dev_read_history_ext(dev_dest, dest_imgid, TRUE);</a>
<a name="ln912"> </a>
<a name="ln913">  dt_dev_pop_history_items_ext(dev_src, dev_src-&gt;history_end);</a>
<a name="ln914">  dt_dev_pop_history_items_ext(dev_dest, dev_dest-&gt;history_end);</a>
<a name="ln915"> </a>
<a name="ln916">  // we will copy only used forms</a>
<a name="ln917">  guint nbf = g_list_length(dev_src-&gt;forms);</a>
<a name="ln918">  int *forms_used_replace = calloc(nbf, sizeof(int));</a>
<a name="ln919"> </a>
<a name="ln920">  // the user have selected some history entries</a>
<a name="ln921">  if(ops)</a>
<a name="ln922">  {</a>
<a name="ln923">    // copy only selected history entries</a>
<a name="ln924">    GList *l = g_list_last(ops);</a>
<a name="ln925">    while(l)</a>
<a name="ln926">    {</a>
<a name="ln927">      unsigned int num = GPOINTER_TO_UINT(l-&gt;data);</a>
<a name="ln928"> </a>
<a name="ln929">      dt_dev_history_item_t *hist = g_list_nth_data(dev_src-&gt;history, num);</a>
<a name="ln930"> </a>
<a name="ln931">      if(hist)</a>
<a name="ln932">      {</a>
<a name="ln933">        // merge the entry</a>
<a name="ln934">        _history_merge_module_into_history(dev_dest, hist-&gt;module, &amp;modules_used, FALSE);</a>
<a name="ln935"> </a>
<a name="ln936">        // record the masks used by this module</a>
<a name="ln937">        if(hist-&gt;module-&gt;flags() &amp; IOP_FLAGS_SUPPORTS_BLENDING)</a>
<a name="ln938">        {</a>
<a name="ln939">          if(hist-&gt;module-&gt;blend_params-&gt;mask_id &gt; 0)</a>
<a name="ln940">            _fill_used_forms(dev_src-&gt;forms, hist-&gt;module-&gt;blend_params-&gt;mask_id, forms_used_replace, nbf);</a>
<a name="ln941">        }</a>
<a name="ln942">      }</a>
<a name="ln943"> </a>
<a name="ln944">      l = g_list_previous(l);</a>
<a name="ln945">    }</a>
<a name="ln946">  }</a>
<a name="ln947">  else</a>
<a name="ln948">  {</a>
<a name="ln949">    // we will copy all modules</a>
<a name="ln950">    GList *modules_src = g_list_first(dev_src-&gt;iop);</a>
<a name="ln951">    while(modules_src)</a>
<a name="ln952">    {</a>
<a name="ln953">      dt_iop_module_t *mod_src = (dt_iop_module_t *)(modules_src-&gt;data);</a>
<a name="ln954"> </a>
<a name="ln955">      // but only if module is in history in source image</a>
<a name="ln956">      if(_search_history_by_module(dev_src, mod_src) != NULL)</a>
<a name="ln957">      {</a>
<a name="ln958">        // merge the module into dest image</a>
<a name="ln959">        _history_merge_module_into_history(dev_dest, mod_src, &amp;modules_used, FALSE);</a>
<a name="ln960"> </a>
<a name="ln961">        // record the masks used by this module</a>
<a name="ln962">        if(mod_src-&gt;flags() &amp; IOP_FLAGS_SUPPORTS_BLENDING)</a>
<a name="ln963">        {</a>
<a name="ln964">          if(mod_src-&gt;blend_params-&gt;mask_id &gt; 0)</a>
<a name="ln965">            _fill_used_forms(dev_src-&gt;forms, mod_src-&gt;blend_params-&gt;mask_id, forms_used_replace, nbf);</a>
<a name="ln966">        }</a>
<a name="ln967">      }</a>
<a name="ln968"> </a>
<a name="ln969">      modules_src = g_list_next(modules_src);</a>
<a name="ln970">    }</a>
<a name="ln971">  }</a>
<a name="ln972"> </a>
<a name="ln973">  // now copy masks</a>
<a name="ln974">  for(int i = 0; i &lt; nbf &amp;&amp; forms_used_replace[i] &gt; 0; i++)</a>
<a name="ln975">  {</a>
<a name="ln976">    dt_masks_form_t *form = dt_masks_get_from_id_ext(dev_src-&gt;forms, forms_used_replace[i]);</a>
<a name="ln977">    if(form)</a>
<a name="ln978">    {</a>
<a name="ln979">      // check if the form already exists in dest image</a>
<a name="ln980">      // if so we'll remove it, so it is replaced</a>
<a name="ln981">      dt_masks_form_t *form_dest = dt_masks_get_from_id_ext(dev_dest-&gt;forms, forms_used_replace[i]);</a>
<a name="ln982">      if(form_dest)</a>
<a name="ln983">      {</a>
<a name="ln984">        dev_dest-&gt;forms = g_list_remove(dev_dest-&gt;forms, form_dest);</a>
<a name="ln985">      }</a>
<a name="ln986"> </a>
<a name="ln987">      // and add it to dest image</a>
<a name="ln988">      // we can do this because dev-&gt;allforms will take care of free() the form</a>
<a name="ln989">      // if that changes we'll have to duplicate the form</a>
<a name="ln990">      dev_dest-&gt;forms = g_list_append(dev_dest-&gt;forms, form);</a>
<a name="ln991">    }</a>
<a name="ln992">    else</a>
<a name="ln993">      fprintf(stderr, &quot;[_history_copy_and_paste_on_image_merge] form %i not found in source image\n&quot;, forms_used_replace[i]);</a>
<a name="ln994">  }</a>
<a name="ln995"> </a>
<a name="ln996">  // write history and forms to db</a>
<a name="ln997">  dt_masks_write_forms_ext(dev_dest, dest_imgid, FALSE);</a>
<a name="ln998">  dt_dev_write_history_ext(dev_dest, dest_imgid);</a>
<a name="ln999"> </a>
<a name="ln1000">  dt_dev_cleanup(dev_src);</a>
<a name="ln1001">  dt_dev_cleanup(dev_dest);</a>
<a name="ln1002"> </a>
<a name="ln1003">  g_list_free(modules_used);</a>
<a name="ln1004">  free(forms_used_replace);</a>
<a name="ln1005"> </a>
<a name="ln1006">  return 0;</a>
<a name="ln1007">}</a>
<a name="ln1008"> </a>
<a name="ln1009">static int _history_copy_and_paste_on_image_overwrite(int32_t imgid, int32_t dest_imgid, GList *ops)</a>
<a name="ln1010">{</a>
<a name="ln1011">  int ret_val = 0;</a>
<a name="ln1012">  sqlite3_stmt *stmt;</a>
<a name="ln1013"> </a>
<a name="ln1014">  // replace history stack</a>
<a name="ln1015">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln1016">                              &amp;stmt, NULL);</a>
<a name="ln1017">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln1018">  sqlite3_step(stmt);</a>
<a name="ln1019">  sqlite3_finalize(stmt);</a>
<a name="ln1020"> </a>
<a name="ln1021">  // and shapes</a>
<a name="ln1022">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.mask WHERE imgid = ?1&quot;, -1, &amp;stmt,</a>
<a name="ln1023">                              NULL);</a>
<a name="ln1024">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln1025">  sqlite3_step(stmt);</a>
<a name="ln1026">  sqlite3_finalize(stmt);</a>
<a name="ln1027"> </a>
<a name="ln1028">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1029">                              &quot;UPDATE main.images SET history_end = 0 WHERE id = ?1&quot;,</a>
<a name="ln1030">                              -1, &amp;stmt, NULL);</a>
<a name="ln1031">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln1032">  sqlite3_step(stmt);</a>
<a name="ln1033">  sqlite3_finalize(stmt);</a>
<a name="ln1034"> </a>
<a name="ln1035">  // the user wants an exact duplicate of the history, so just copy the db</a>
<a name="ln1036">  if(!ops)</a>
<a name="ln1037">  {</a>
<a name="ln1038">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1039">                                &quot;INSERT INTO main.history &quot;</a>
<a name="ln1040">                                &quot;(imgid,num,module,operation,op_params,enabled,blendop_params, &quot;</a>
<a name="ln1041">                                &quot;blendop_version,multi_priority,multi_name) SELECT &quot;</a>
<a name="ln1042">                                &quot;?1,num,module,operation,op_params,enabled,blendop_params, &quot;</a>
<a name="ln1043">                                &quot;blendop_version,multi_priority,multi_name &quot;</a>
<a name="ln1044">                                &quot;FROM main.history WHERE imgid=?2 ORDER BY num&quot;,</a>
<a name="ln1045">                                -1, &amp;stmt, NULL);</a>
<a name="ln1046">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln1047">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln1048">    sqlite3_step(stmt);</a>
<a name="ln1049">    sqlite3_finalize(stmt);</a>
<a name="ln1050"> </a>
<a name="ln1051">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1052">                                &quot;INSERT INTO main.mask &quot;</a>
<a name="ln1053">                                &quot;(imgid, formid, form, name, version, points, points_count, source) SELECT &quot;</a>
<a name="ln1054">                                &quot;?1, formid, form, name, version, points, points_count, source &quot;</a>
<a name="ln1055">                                &quot;FROM main.mask WHERE imgid = ?2&quot;,</a>
<a name="ln1056">                                -1, &amp;stmt, NULL);</a>
<a name="ln1057">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, dest_imgid);</a>
<a name="ln1058">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, imgid);</a>
<a name="ln1059">    sqlite3_step(stmt);</a>
<a name="ln1060">    sqlite3_finalize(stmt);</a>
<a name="ln1061"> </a>
<a name="ln1062">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1063">                                &quot;UPDATE main.images SET history_end = (SELECT history_end FROM main.images &quot;</a>
<a name="ln1064">                                &quot;WHERE id = ?1) WHERE id = ?2&quot;,</a>
<a name="ln1065">                                -1, &amp;stmt, NULL);</a>
<a name="ln1066">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1067">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, dest_imgid);</a>
<a name="ln1068">    sqlite3_step(stmt);</a>
<a name="ln1069">    sqlite3_finalize(stmt);</a>
<a name="ln1070">  }</a>
<a name="ln1071">  else</a>
<a name="ln1072">  {</a>
<a name="ln1073">    // since the history and masks where deleted we can do a merge</a>
<a name="ln1074">    ret_val = _history_copy_and_paste_on_image_merge(imgid, dest_imgid, ops);</a>
<a name="ln1075">  }</a>
<a name="ln1076"> </a>
<a name="ln1077">  return ret_val;</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">int dt_history_copy_and_paste_on_image(int32_t imgid, int32_t dest_imgid, gboolean merge, GList *ops)</a>
<a name="ln1081">{</a>
<a name="ln1082">  if(imgid == dest_imgid) return 1;</a>
<a name="ln1083"> </a>
<a name="ln1084">  if(imgid == -1)</a>
<a name="ln1085">  {</a>
<a name="ln1086">    dt_control_log(_(&quot;you need to copy history from an image before you paste it onto another&quot;));</a>
<a name="ln1087">    return 1;</a>
<a name="ln1088">  }</a>
<a name="ln1089"> </a>
<a name="ln1090">  // be sure the current history is written before pasting some other history data</a>
<a name="ln1091">  const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln1092">  if(cv-&gt;view((dt_view_t *)cv) == DT_VIEW_DARKROOM) dt_dev_write_history(darktable.develop);</a>
<a name="ln1093"> </a>
<a name="ln1094">  int ret_val = 0;</a>
<a name="ln1095">  if(merge)</a>
<a name="ln1096">    ret_val = _history_copy_and_paste_on_image_merge(imgid, dest_imgid, ops);</a>
<a name="ln1097">  else</a>
<a name="ln1098">    ret_val = _history_copy_and_paste_on_image_overwrite(imgid, dest_imgid, ops);</a>
<a name="ln1099"> </a>
<a name="ln1100">  /* if current image in develop reload history */</a>
<a name="ln1101">  if(dt_dev_is_current_image(darktable.develop, dest_imgid))</a>
<a name="ln1102">  {</a>
<a name="ln1103">    dt_masks_read_forms(darktable.develop);</a>
<a name="ln1104">    dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln1105">    dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln1106">  }</a>
<a name="ln1107"> </a>
<a name="ln1108">  /* update xmp file */</a>
<a name="ln1109">  dt_image_synch_xmp(dest_imgid);</a>
<a name="ln1110"> </a>
<a name="ln1111">  dt_mipmap_cache_remove(darktable.mipmap_cache, dest_imgid);</a>
<a name="ln1112"> </a>
<a name="ln1113">  /* update the aspect ratio if the current sorting is based on aspect ratio, otherwise the aspect ratio will be</a>
<a name="ln1114">     recalculated when the mimpap will be recreated */</a>
<a name="ln1115">  if (darktable.collection-&gt;params.sort == DT_COLLECTION_SORT_ASPECT_RATIO)</a>
<a name="ln1116">    dt_image_set_aspect_ratio(dest_imgid);</a>
<a name="ln1117"> </a>
<a name="ln1118">  return ret_val;</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">GList *dt_history_get_items(int32_t imgid, gboolean enabled)</a>
<a name="ln1122">{</a>
<a name="ln1123">  GList *result = NULL;</a>
<a name="ln1124">  sqlite3_stmt *stmt;</a>
<a name="ln1125"> </a>
<a name="ln1126">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1127">                              &quot;SELECT num, operation, enabled, multi_name FROM main.history WHERE imgid=?1 AND &quot;</a>
<a name="ln1128">                              &quot;num IN (SELECT MAX(num) FROM main.history hst2 WHERE hst2.imgid=?1 AND &quot;</a>
<a name="ln1129">                              &quot;hst2.operation=main.history.operation GROUP BY multi_priority) ORDER BY num DESC&quot;,</a>
<a name="ln1130">                              -1, &amp;stmt, NULL);</a>
<a name="ln1131">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1132">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1133">  {</a>
<a name="ln1134">    char name[512] = { 0 };</a>
<a name="ln1135">    const int is_active = sqlite3_column_int(stmt, 2);</a>
<a name="ln1136"> </a>
<a name="ln1137">    if(enabled == FALSE || is_active)</a>
<a name="ln1138">    {</a>
<a name="ln1139">      dt_history_item_t *item = g_malloc(sizeof(dt_history_item_t));</a>
<a name="ln1140">      item-&gt;num = sqlite3_column_int(stmt, 0);</a>
<a name="ln1141">      char *mname = NULL;</a>
<a name="ln1142">      mname = g_strdup((gchar *)sqlite3_column_text(stmt, 3));</a>
<a name="ln1143">      if(enabled)</a>
<a name="ln1144">      {</a>
<a name="ln1145">        if(strcmp(mname, &quot;0&quot;) == 0)</a>
<a name="ln1146">          g_snprintf(name, sizeof(name), &quot;%s&quot;,</a>
<a name="ln1147">                     dt_iop_get_localized_name((char *)sqlite3_column_text(stmt, 1)));</a>
<a name="ln1148">        else</a>
<a name="ln1149">          g_snprintf(name, sizeof(name), &quot;%s %s&quot;,</a>
<a name="ln1150">                     dt_iop_get_localized_name((char *)sqlite3_column_text(stmt, 1)),</a>
<a name="ln1151">                     (char *)sqlite3_column_text(stmt, 3));</a>
<a name="ln1152">      }</a>
<a name="ln1153">      else</a>
<a name="ln1154">      {</a>
<a name="ln1155">        if(strcmp(mname, &quot;0&quot;) == 0)</a>
<a name="ln1156">          g_snprintf(name, sizeof(name), &quot;%s (%s)&quot;,</a>
<a name="ln1157">                     dt_iop_get_localized_name((char *)sqlite3_column_text(stmt, 1)),</a>
<a name="ln1158">                     (is_active != 0) ? _(&quot;on&quot;) : _(&quot;off&quot;));</a>
<a name="ln1159">        g_snprintf(name, sizeof(name), &quot;%s %s (%s)&quot;,</a>
<a name="ln1160">                   dt_iop_get_localized_name((char *)sqlite3_column_text(stmt, 1)),</a>
<a name="ln1161">                   (char *)sqlite3_column_text(stmt, 3), (is_active != 0) ? _(&quot;on&quot;) : _(&quot;off&quot;));</a>
<a name="ln1162">      }</a>
<a name="ln1163">      item-&gt;name = g_strdup(name);</a>
<a name="ln1164">      item-&gt;op = g_strdup((gchar *)sqlite3_column_text(stmt, 1));</a>
<a name="ln1165">      result = g_list_append(result, item);</a>
<a name="ln1166"> </a>
<a name="ln1167">      g_free(mname);</a>
<a name="ln1168">    }</a>
<a name="ln1169">  }</a>
<a name="ln1170">  sqlite3_finalize(stmt);</a>
<a name="ln1171">  return result;</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174">char *dt_history_get_items_as_string(int32_t imgid)</a>
<a name="ln1175">{</a>
<a name="ln1176">  GList *items = NULL;</a>
<a name="ln1177">  const char *onoff[2] = { _(&quot;off&quot;), _(&quot;on&quot;) };</a>
<a name="ln1178">  sqlite3_stmt *stmt;</a>
<a name="ln1179">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln1180">      dt_database_get(darktable.db),</a>
<a name="ln1181">      &quot;SELECT operation, enabled, multi_name FROM main.history WHERE imgid=?1 ORDER BY num DESC&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1182">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1183"> </a>
<a name="ln1184">  // collect all the entries in the history from the db</a>
<a name="ln1185">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1186">  {</a>
<a name="ln1187">    char *name = NULL, *multi_name = NULL;</a>
<a name="ln1188">    const char *mn = (char *)sqlite3_column_text(stmt, 2);</a>
<a name="ln1189">    if(mn &amp;&amp; *mn &amp;&amp; g_strcmp0(mn, &quot; &quot;) != 0 &amp;&amp; g_strcmp0(mn, &quot;0&quot;) != 0)</a>
<a name="ln1190">      multi_name = g_strconcat(&quot; &quot;, sqlite3_column_text(stmt, 2), NULL);</a>
<a name="ln1191">    name = g_strconcat(dt_iop_get_localized_name((char *)sqlite3_column_text(stmt, 0)),</a>
<a name="ln1192">                       multi_name ? multi_name : &quot;&quot;, &quot; (&quot;,</a>
<a name="ln1193">                       (sqlite3_column_int(stmt, 1) == 0) ? onoff[0] : onoff[1], &quot;)&quot;, NULL);</a>
<a name="ln1194">    items = g_list_append(items, name);</a>
<a name="ln1195">    g_free(multi_name);</a>
<a name="ln1196">  }</a>
<a name="ln1197">  sqlite3_finalize(stmt);</a>
<a name="ln1198">  char *result = dt_util_glist_to_str(&quot;\n&quot;, items);</a>
<a name="ln1199">  g_list_free_full(items, g_free);</a>
<a name="ln1200">  return result;</a>
<a name="ln1201">}</a>
<a name="ln1202"> </a>
<a name="ln1203">int dt_history_copy_and_paste_on_selection(int32_t imgid, gboolean merge, GList *ops)</a>
<a name="ln1204">{</a>
<a name="ln1205">  if(imgid &lt; 0) return 1;</a>
<a name="ln1206"> </a>
<a name="ln1207">  int res = 0;</a>
<a name="ln1208">  sqlite3_stmt *stmt;</a>
<a name="ln1209">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1210">                              &quot;SELECT imgid FROM main.selected_images WHERE imgid != ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1211">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln1212">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1213">  {</a>
<a name="ln1214">    do</a>
<a name="ln1215">    {</a>
<a name="ln1216">      /* get imgid of selected image */</a>
<a name="ln1217">      int32_t dest_imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1218"> </a>
<a name="ln1219">      /* paste history stack onto image id */</a>
<a name="ln1220">      dt_history_copy_and_paste_on_image(imgid, dest_imgid, merge, ops);</a>
<a name="ln1221"> </a>
<a name="ln1222">    } while(sqlite3_step(stmt) == SQLITE_ROW);</a>
<a name="ln1223">  }</a>
<a name="ln1224">  else</a>
<a name="ln1225">    res = 1;</a>
<a name="ln1226"> </a>
<a name="ln1227">  sqlite3_finalize(stmt);</a>
<a name="ln1228">  return res;</a>
<a name="ln1229">}</a>
<a name="ln1230"> </a>
<a name="ln1231">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1232">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1233">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="791"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'module'. Check lines: 791, 784.</p></div>
<div class="balloon" rel="778"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 768, 778.</p></div>
<div class="balloon" rel="974"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'forms_used_replace'. Check lines: 974, 918.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
