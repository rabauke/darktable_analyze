
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010-2011 johannes hanika</a>
<a name="ln4">    copyright (c) 2010-2012 henrik andersson</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;control/jobs/control_jobs.h&quot;</a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/exif.h&quot;</a>
<a name="ln24">#include &quot;common/film.h&quot;</a>
<a name="ln25">#include &quot;common/gpx.h&quot;</a>
<a name="ln26">#include &quot;common/history.h&quot;</a>
<a name="ln27">#include &quot;common/image.h&quot;</a>
<a name="ln28">#include &quot;common/image_cache.h&quot;</a>
<a name="ln29">#include &quot;common/imageio.h&quot;</a>
<a name="ln30">#include &quot;common/imageio_dng.h&quot;</a>
<a name="ln31">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln32">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln33">#include &quot;common/tags.h&quot;</a>
<a name="ln34">#include &quot;common/undo.h&quot;</a>
<a name="ln35">#include &quot;control/conf.h&quot;</a>
<a name="ln36">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;gui/gtk.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;gio/gio.h&gt;</a>
<a name="ln41">#include &lt;glib.h&gt;</a>
<a name="ln42">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln43">#ifndef _WIN32</a>
<a name="ln44">#include &lt;glob.h&gt;</a>
<a name="ln45">#endif</a>
<a name="ln46">#ifdef __APPLE__</a>
<a name="ln47">#include &quot;osx/osx.h&quot;</a>
<a name="ln48">#endif</a>
<a name="ln49">#ifdef _WIN32</a>
<a name="ln50">#include &quot;win/dtwin.h&quot;</a>
<a name="ln51">#endif</a>
<a name="ln52"> </a>
<a name="ln53">typedef struct dt_control_time_offset_t</a>
<a name="ln54">{</a>
<a name="ln55">  long int offset;</a>
<a name="ln56">} dt_control_time_offset_t;</a>
<a name="ln57"> </a>
<a name="ln58">typedef struct dt_control_gpx_apply_t</a>
<a name="ln59">{</a>
<a name="ln60">  gchar *filename;</a>
<a name="ln61">  gchar *tz;</a>
<a name="ln62">} dt_control_gpx_apply_t;</a>
<a name="ln63"> </a>
<a name="ln64">typedef struct dt_control_export_t</a>
<a name="ln65">{</a>
<a name="ln66">  int max_width, max_height, format_index, storage_index;</a>
<a name="ln67">  dt_imageio_module_data_t *sdata; // needed since the gui thread resets things like overwrite once the export</a>
<a name="ln68">  // is dispatched, but we have to keep that information</a>
<a name="ln69">  gboolean high_quality, upscale;</a>
<a name="ln70">  char style[128];</a>
<a name="ln71">  gboolean style_append;</a>
<a name="ln72">  dt_colorspaces_color_profile_type_t icc_type;</a>
<a name="ln73">  gchar *icc_filename;</a>
<a name="ln74">  dt_iop_color_intent_t icc_intent;</a>
<a name="ln75">  gchar *metadata_export;</a>
<a name="ln76">} dt_control_export_t;</a>
<a name="ln77"> </a>
<a name="ln78">typedef struct dt_control_image_enumerator_t</a>
<a name="ln79">{</a>
<a name="ln80">  GList *index;</a>
<a name="ln81">  int flag;</a>
<a name="ln82">  gpointer data;</a>
<a name="ln83">} dt_control_image_enumerator_t;</a>
<a name="ln84"> </a>
<a name="ln85">typedef struct dt_undo_geotag_t</a>
<a name="ln86">{</a>
<a name="ln87">  GList *before;</a>
<a name="ln88">  GList *after;</a>
<a name="ln89">} dt_undo_geotag_t;</a>
<a name="ln90"> </a>
<a name="ln91">/* enumerator of images from filmroll */</a>
<a name="ln92">static void dt_control_image_enumerator_job_film_init(dt_control_image_enumerator_t *t, int32_t filmid)</a>
<a name="ln93">{</a>
<a name="ln94">  g_list_free(t-&gt;index);</a>
<a name="ln95">  t-&gt;index = NULL;</a>
<a name="ln96"> </a>
<a name="ln97">  sqlite3_stmt *stmt;</a>
<a name="ln98">  /* get a list of images in filmroll */</a>
<a name="ln99">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT id FROM main.images WHERE film_id = ?1&quot;, -1,</a>
<a name="ln100">                              &amp;stmt, NULL);</a>
<a name="ln101">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, filmid);</a>
<a name="ln102"> </a>
<a name="ln103">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln104">  {</a>
<a name="ln105">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln106">    t-&gt;index = g_list_append(t-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln107">  }</a>
<a name="ln108">  sqlite3_finalize(stmt);</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">/* enumerator of selected images */</a>
<a name="ln112">static void dt_control_image_enumerator_job_selected_init(dt_control_image_enumerator_t *t)</a>
<a name="ln113">{</a>
<a name="ln114">  g_list_free(t-&gt;index);</a>
<a name="ln115">  t-&gt;index = NULL;</a>
<a name="ln116"> </a>
<a name="ln117">  int imgid = dt_view_get_image_to_act_on();</a>
<a name="ln118"> </a>
<a name="ln119">  if(imgid &lt; 0) /* get sorted list of selected images */</a>
<a name="ln120">    t-&gt;index = dt_collection_get_selected(darktable.collection, -1);</a>
<a name="ln121">  else</a>
<a name="ln122">    /* Create a list with only one image */</a>
<a name="ln123">    t-&gt;index = g_list_append(t-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">static int32_t _generic_dt_control_fileop_images_job_run(dt_job_t *job,</a>
<a name="ln127">                                                         int32_t (*fileop_callback)(const int32_t,</a>
<a name="ln128">                                                                                    const int32_t),</a>
<a name="ln129">                                                         const char *desc, const char *desc_pl)</a>
<a name="ln130">{</a>
<a name="ln131">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln132">  GList *t = params-&gt;index;</a>
<a name="ln133">  guint total = g_list_length(t);</a>
<a name="ln134">  char message[512] = { 0 };</a>
<a name="ln135">  double fraction = 0;</a>
<a name="ln136">  gchar *newdir = (gchar *)params-&gt;data;</a>
<a name="ln137"> </a>
<a name="ln138">  g_snprintf(message, sizeof(message), ngettext(desc, desc_pl, total), total);</a>
<a name="ln139">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln140"> </a>
<a name="ln141">  // create new film roll for the destination directory</a>
<a name="ln142">  dt_film_t new_film;</a>
<a name="ln143">  const int32_t film_id = dt_film_new(&amp;new_film, newdir);</a>
<a name="ln144">  g_free(newdir);</a>
<a name="ln145"> </a>
<a name="ln146">  if(film_id &lt;= 0)</a>
<a name="ln147">  {</a>
<a name="ln148">    dt_control_log(_(&quot;failed to create film roll for destination directory, aborting move..&quot;));</a>
<a name="ln149">    return -1;</a>
<a name="ln150">  }</a>
<a name="ln151"> </a>
<a name="ln152">  gboolean completeSuccess = TRUE;</a>
<a name="ln153">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln154">  {</a>
<a name="ln155">    completeSuccess &amp;= (fileop_callback(GPOINTER_TO_INT(t-&gt;data), film_id) != -1);</a>
<a name="ln156">    t = g_list_delete_link(t, t);</a>
<a name="ln157">    fraction += 1.0 / total;</a>
<a name="ln158">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln159">  }</a>
<a name="ln160">  params-&gt;index = NULL;</a>
<a name="ln161"> </a>
<a name="ln162">  if(completeSuccess)</a>
<a name="ln163">  {</a>
<a name="ln164">    char collect[1024];</a>
<a name="ln165">    snprintf(collect, sizeof(collect), &quot;1:0:0:%s$&quot;, new_film.dirname);</a>
<a name="ln166">    dt_collection_deserialize(collect);</a>
<a name="ln167">  }</a>
<a name="ln168">  dt_film_remove_empty();</a>
<a name="ln169">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln170">  dt_control_queue_redraw_center();</a>
<a name="ln171">  return 0;</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">static void *dt_control_image_enumerator_alloc()</a>
<a name="ln175">{</a>
<a name="ln176">  dt_control_image_enumerator_t *params = calloc(1, sizeof(dt_control_image_enumerator_t));</a>
<a name="ln177">  if(!params) return NULL;</a>
<a name="ln178"> </a>
<a name="ln179">  return params;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">static void dt_control_image_enumerator_cleanup(void *p)</a>
<a name="ln183">{</a>
<a name="ln184">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln185"> </a>
<a name="ln186">  g_list_free(params-&gt;index);</a>
<a name="ln187"> </a>
<a name="ln188">  free(params);</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">typedef enum {PROGRESS_NONE, PROGRESS_SIMPLE, PROGRESS_CANCELLABLE} progress_type_t;</a>
<a name="ln192"> </a>
<a name="ln193">static dt_job_t *dt_control_generic_images_job_create(dt_job_execute_callback execute, const char *message,</a>
<a name="ln194">                                                      int flag, gpointer data, progress_type_t progress_type)</a>
<a name="ln195">{</a>
<a name="ln196">  dt_job_t *job = dt_control_job_create(execute, &quot;%s&quot;, message);</a>
<a name="ln197">  if(!job) return NULL;</a>
<a name="ln198">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln199">  if(!params)</a>
<a name="ln200">  {</a>
<a name="ln201">    dt_control_job_dispose(job);</a>
<a name="ln202">    return NULL;</a>
<a name="ln203">  }</a>
<a name="ln204">  if(progress_type != PROGRESS_NONE)</a>
<a name="ln205">    dt_control_job_add_progress(job, _(message), progress_type == PROGRESS_CANCELLABLE);</a>
<a name="ln206">  dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln207">  dt_control_job_set_params(job, params, dt_control_image_enumerator_cleanup);</a>
<a name="ln208"> </a>
<a name="ln209">  params-&gt;flag = flag;</a>
<a name="ln210">  params-&gt;data = data;</a>
<a name="ln211">  return job;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">static int32_t dt_control_write_sidecar_files_job_run(dt_job_t *job)</a>
<a name="ln215">{</a>
<a name="ln216">  int imgid = -1;</a>
<a name="ln217">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln218">  GList *t = params-&gt;index;</a>
<a name="ln219">  sqlite3_stmt *stmt;</a>
<a name="ln220">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln221">                              &quot;UPDATE main.images SET write_timestamp = STRFTIME('%s', 'now') WHERE id = ?1&quot;, -1,</a>
<a name="ln222">                              &amp;stmt, NULL);</a>
<a name="ln223">  while(t)</a>
<a name="ln224">  {</a>
<a name="ln225">    gboolean from_cache = FALSE;</a>
<a name="ln226">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln227">    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, (int32_t)imgid, 'r');</a>
<a name="ln228">    char dtfilename[PATH_MAX] = { 0 };</a>
<a name="ln229">    dt_image_full_path(img-&gt;id, dtfilename, sizeof(dtfilename), &amp;from_cache);</a>
<a name="ln230">    dt_image_path_append_version(img-&gt;id, dtfilename, sizeof(dtfilename));</a>
<a name="ln231">    g_strlcat(dtfilename, &quot;.xmp&quot;, sizeof(dtfilename));</a>
<a name="ln232">    if(!dt_exif_xmp_write(imgid, dtfilename))</a>
<a name="ln233">    {</a>
<a name="ln234">      // put the timestamp into db. this can't be done in exif.cc since that code gets called</a>
<a name="ln235">      // for the copy exporter, too</a>
<a name="ln236">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln237">      sqlite3_step(stmt);</a>
<a name="ln238">      sqlite3_reset(stmt);</a>
<a name="ln239">      sqlite3_clear_bindings(stmt);</a>
<a name="ln240">    }</a>
<a name="ln241">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln242">    t = g_list_delete_link(t, t);</a>
<a name="ln243">  }</a>
<a name="ln244">  params-&gt;index = NULL;</a>
<a name="ln245">  sqlite3_finalize(stmt);</a>
<a name="ln246">  return 0;</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">typedef struct dt_control_merge_hdr_t</a>
<a name="ln250">{</a>
<a name="ln251">  uint32_t first_imgid;</a>
<a name="ln252">  uint32_t first_filter;</a>
<a name="ln253">  uint8_t first_xtrans[6][6];</a>
<a name="ln254"> </a>
<a name="ln255">  float *pixels, *weight;</a>
<a name="ln256"> </a>
<a name="ln257">  int wd;</a>
<a name="ln258">  int ht;</a>
<a name="ln259">  dt_image_orientation_t orientation;</a>
<a name="ln260"> </a>
<a name="ln261">  float whitelevel;</a>
<a name="ln262">  float epsw;</a>
<a name="ln263"> </a>
<a name="ln264">  // 0 - ok; 1 - errors, abort</a>
<a name="ln265">  gboolean abort;</a>
<a name="ln266">} dt_control_merge_hdr_t;</a>
<a name="ln267"> </a>
<a name="ln268">typedef struct dt_control_merge_hdr_format_t</a>
<a name="ln269">{</a>
<a name="ln270">  dt_imageio_module_data_t parent;</a>
<a name="ln271">  dt_control_merge_hdr_t *d;</a>
<a name="ln272">} dt_control_merge_hdr_format_t;</a>
<a name="ln273"> </a>
<a name="ln274">static int dt_control_merge_hdr_bpp(dt_imageio_module_data_t *data)</a>
<a name="ln275">{</a>
<a name="ln276">  return 32;</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">static int dt_control_merge_hdr_levels(dt_imageio_module_data_t *data)</a>
<a name="ln280">{</a>
<a name="ln281">  return IMAGEIO_RGB | IMAGEIO_FLOAT;</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">static const char *dt_control_merge_hdr_mime(dt_imageio_module_data_t *data)</a>
<a name="ln285">{</a>
<a name="ln286">  return &quot;memory&quot;;</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">static float envelope(const float xx)</a>
<a name="ln290">{</a>
<a name="ln291">  const float x = CLAMPS(xx, 0.0f, 1.0f);</a>
<a name="ln292">  // const float alpha = 2.0f;</a>
<a name="ln293">  const float beta = 0.5f;</a>
<a name="ln294">  if(x &lt; beta)</a>
<a name="ln295">  {</a>
<a name="ln296">    // return 1.0f-fabsf(x/beta-1.0f)^2</a>
<a name="ln297">    const float tmp = fabsf(x / beta - 1.0f);</a>
<a name="ln298">    return 1.0f - tmp * tmp;</a>
<a name="ln299">  }</a>
<a name="ln300">  else</a>
<a name="ln301">  {</a>
<a name="ln302">    const float tmp1 = (1.0f - x) / (1.0f - beta);</a>
<a name="ln303">    const float tmp2 = tmp1 * tmp1;</a>
<a name="ln304">    const float tmp3 = tmp2 * tmp1;</a>
<a name="ln305">    return 3.0f * tmp2 - 2.0f * tmp3;</a>
<a name="ln306">  }</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">static int dt_control_merge_hdr_process(dt_imageio_module_data_t *datai, const char *filename,</a>
<a name="ln310">                                        const void *const ivoid,</a>
<a name="ln311">                                        dt_colorspaces_color_profile_type_t over_type, const char *over_filename,</a>
<a name="ln312">                                        void *exif, int exif_len, int imgid, int num, int total,</a>
<a name="ln313">                                        dt_dev_pixelpipe_t *pipe)</a>
<a name="ln314">{</a>
<a name="ln315">  dt_control_merge_hdr_format_t *data = (dt_control_merge_hdr_format_t *)datai;</a>
<a name="ln316">  dt_control_merge_hdr_t *d = data-&gt;d;</a>
<a name="ln317"> </a>
<a name="ln318">  // just take a copy. also do it after blocking read, so filters will make sense.</a>
<a name="ln319">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln320">  const dt_image_t image = *img;</a>
<a name="ln321">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln322"> </a>
<a name="ln323">  if(!d-&gt;pixels)</a>
<a name="ln324">  {</a>
<a name="ln325">    d-&gt;first_imgid = imgid;</a>
<a name="ln326">    d-&gt;first_filter = image.buf_dsc.filters;</a>
<a name="ln327">    // sensor layout is just passed on to be written to dng.</a>
<a name="ln328">    // we offset it to the crop of the image here, so we don't</a>
<a name="ln329">    // need to load in the FCxtrans dependency into the dng writer.</a>
<a name="ln330">    // for some stupid reason the dng needs this layout wrt cropped</a>
<a name="ln331">    // offsets, not globally.</a>
<a name="ln332">    dt_iop_roi_t roi = {0};</a>
<a name="ln333">    roi.x = image.crop_x;</a>
<a name="ln334">    roi.y = image.crop_y;</a>
<a name="ln335">    for(int j=0;j&lt;6;j++)</a>
<a name="ln336">      for(int i = 0; i &lt; 6; i++) d-&gt;first_xtrans[j][i] = FCxtrans(j, i, &amp;roi, image.buf_dsc.xtrans);</a>
<a name="ln337">    d-&gt;pixels = calloc(datai-&gt;width * datai-&gt;height, sizeof(float));</a>
<a name="ln338">    d-&gt;weight = calloc(datai-&gt;width * datai-&gt;height, sizeof(float));</a>
<a name="ln339">    d-&gt;wd = datai-&gt;width;</a>
<a name="ln340">    d-&gt;ht = datai-&gt;height;</a>
<a name="ln341">    d-&gt;orientation = image.orientation;</a>
<a name="ln342">  }</a>
<a name="ln343"> </a>
<a name="ln344">  if(image.buf_dsc.filters == 0u || image.buf_dsc.channels != 1 || image.buf_dsc.datatype != TYPE_UINT16)</a>
<a name="ln345">  {</a>
<a name="ln346">    dt_control_log(_(&quot;exposure bracketing only works on raw images.&quot;));</a>
<a name="ln347">    d-&gt;abort = TRUE;</a>
<a name="ln348">    return 1;</a>
<a name="ln349">  }</a>
<a name="ln350">  else if(datai-&gt;width != d-&gt;wd || datai-&gt;height != d-&gt;ht || d-&gt;first_filter != image.buf_dsc.filters</a>
<a name="ln351">          || d-&gt;orientation != image.orientation)</a>
<a name="ln352">  {</a>
<a name="ln353">    dt_control_log(_(&quot;images have to be of same size and orientation!&quot;));</a>
<a name="ln354">    d-&gt;abort = TRUE;</a>
<a name="ln355">    return 1;</a>
<a name="ln356">  }</a>
<a name="ln357"> </a>
<a name="ln358">  // if no valid exif data can be found, assume peleng fisheye at f/16, 8mm, with half of the light lost in</a>
<a name="ln359">  // the system =&gt; f/22</a>
<a name="ln360">  const float eap = image.exif_aperture &gt; 0.0f ? image.exif_aperture : 22.0f;</a>
<a name="ln361">  const float efl = image.exif_focal_length &gt; 0.0f ? image.exif_focal_length : 8.0f;</a>
<a name="ln362">  const float rad = .5f * efl / eap;</a>
<a name="ln363">  const float aperture = M_PI * rad * rad;</a>
<a name="ln364">  const float iso = image.exif_iso &gt; 0.0f ? image.exif_iso : 100.0f;</a>
<a name="ln365">  const float exp = image.exif_exposure &gt; 0.0f ? image.exif_exposure : 1.0f;</a>
<a name="ln366">  const float cal = 100.0f / (aperture * exp * iso);</a>
<a name="ln367">  // about proportional to how many photons we can expect from this shot:</a>
<a name="ln368">  const float photoncnt = 100.0f * aperture * exp / iso;</a>
<a name="ln369">  float saturation = 1.0f;</a>
<a name="ln370">  d-&gt;whitelevel = fmaxf(d-&gt;whitelevel, saturation * cal);</a>
<a name="ln371">#ifdef _OPENMP</a>
<a name="ln372">#pragma omp parallel for default(none) \</a>
<a name="ln373">  dt_omp_firstprivate(ivoid, cal, photoncnt) \</a>
<a name="ln374">  shared(d, saturation) \</a>
<a name="ln375">  schedule(static)</a>
<a name="ln376">#endif</a>
<a name="ln377">  for(int y = 0; y &lt; d-&gt;ht; y++)</a>
<a name="ln378">    for(int x = 0; x &lt; d-&gt;wd; x++)</a>
<a name="ln379">    {</a>
<a name="ln380">      // read unclamped raw value with subtracted black and rescaled to 1.0 saturation.</a>
<a name="ln381">      // this is the output of the rawprepare iop.</a>
<a name="ln382">      const float in = ((float *)ivoid)[x + d-&gt;wd * y];</a>
<a name="ln383">      // weights based on siggraph 12 poster</a>
<a name="ln384">      // zijian zhu, zhengguo li, susanto rahardja, pasi fraenti</a>
<a name="ln385">      // 2d denoising factor for high dynamic range imaging</a>
<a name="ln386">      float w = photoncnt;</a>
<a name="ln387"> </a>
<a name="ln388">      // need some safety margin due to upsampling and 16-bit quantization + dithering?</a>
<a name="ln389">      float offset = 3000.0f / (float)UINT16_MAX;</a>
<a name="ln390"> </a>
<a name="ln391">      // cannot do an envelope based on single pixel values here, need to get</a>
<a name="ln392">      // maximum value of all color channels. to find that, go through the</a>
<a name="ln393">      // pattern block (we conservatively do a 3x3 for bayer or xtrans):</a>
<a name="ln394">      int xx = x &amp; ~1, yy = y &amp; ~1;</a>
<a name="ln395">      float M = 0.0f, m = FLT_MAX;</a>
<a name="ln396">      if(xx &lt; d-&gt;wd - 2 &amp;&amp; yy &lt; d-&gt;ht - 2)</a>
<a name="ln397">      {</a>
<a name="ln398">        for(int i = 0; i &lt; 3; i++)</a>
<a name="ln399">          for(int j = 0; j &lt; 3; j++)</a>
<a name="ln400">          {</a>
<a name="ln401">            M = MAX(M, ((float *)ivoid)[xx + i + d-&gt;wd * (yy + j)]);</a>
<a name="ln402">            m = MIN(m, ((float *)ivoid)[xx + i + d-&gt;wd * (yy + j)]);</a>
<a name="ln403">          }</a>
<a name="ln404">        // move envelope a little to allow non-zero weight even for clipped regions.</a>
<a name="ln405">        // this is because even if the 2x2 block is clipped somewhere, the other channels</a>
<a name="ln406">        // might still prove useful. we'll check for individual channel saturation below.</a>
<a name="ln407">        w *= d-&gt;epsw + envelope((M + offset) / saturation);</a>
<a name="ln408">      }</a>
<a name="ln409"> </a>
<a name="ln410">      if(M + offset &gt;= saturation)</a>
<a name="ln411">      {</a>
<a name="ln412">        if(d-&gt;weight[x + d-&gt;wd * y] &lt;= 0.0f)</a>
<a name="ln413">        { // only consider saturated pixels in case we have nothing better:</a>
<a name="ln414">          if(d-&gt;weight[x + d-&gt;wd * y] == 0 || m &lt; -d-&gt;weight[x + d-&gt;wd * y])</a>
<a name="ln415">          {</a>
<a name="ln416">            if(m + offset &gt;= saturation)</a>
<a name="ln417">              d-&gt;pixels[x + d-&gt;wd * y] = 1.0f; // let's admit we were completely clipped, too</a>
<a name="ln418">            else</a>
<a name="ln419">              d-&gt;pixels[x + d-&gt;wd * y] = in * cal / d-&gt;whitelevel;</a>
<a name="ln420">            d-&gt;weight[x + d-&gt;wd * y]</a>
<a name="ln421">                = -m; // could use -cal here, but m is per pixel and safer for varying illumination conditions</a>
<a name="ln422">          }</a>
<a name="ln423">        }</a>
<a name="ln424">        // else silently ignore, others have filled in a better color here already</a>
<a name="ln425">      }</a>
<a name="ln426">      else</a>
<a name="ln427">      {</a>
<a name="ln428">        if(d-&gt;weight[x + d-&gt;wd * y] &lt;= 0.0)</a>
<a name="ln429">        { // cleanup potentially blown highlights from earlier images</a>
<a name="ln430">          d-&gt;pixels[x + d-&gt;wd * y] = 0.0f;</a>
<a name="ln431">          d-&gt;weight[x + d-&gt;wd * y] = 0.0f;</a>
<a name="ln432">        }</a>
<a name="ln433">        d-&gt;pixels[x + d-&gt;wd * y] += w * in * cal;</a>
<a name="ln434">        d-&gt;weight[x + d-&gt;wd * y] += w;</a>
<a name="ln435">      }</a>
<a name="ln436">    }</a>
<a name="ln437"> </a>
<a name="ln438">  return 0;</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">static int32_t dt_control_merge_hdr_job_run(dt_job_t *job)</a>
<a name="ln442">{</a>
<a name="ln443">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln444">  GList *t = params-&gt;index;</a>
<a name="ln445">  const guint total = g_list_length(t);</a>
<a name="ln446">  char message[512] = { 0 };</a>
<a name="ln447">  double fraction = 0;</a>
<a name="ln448">  snprintf(message, sizeof(message), ngettext(&quot;merging %d image&quot;, &quot;merging %d images&quot;, total), total);</a>
<a name="ln449"> </a>
<a name="ln450">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln451"> </a>
<a name="ln452">  dt_control_merge_hdr_t d = (dt_control_merge_hdr_t){.epsw = 1e-8f, .abort = FALSE };</a>
<a name="ln453"> </a>
<a name="ln454">  dt_imageio_module_format_t buf = (dt_imageio_module_format_t){.mime = dt_control_merge_hdr_mime,</a>
<a name="ln455">                                                                .levels = dt_control_merge_hdr_levels,</a>
<a name="ln456">                                                                .bpp = dt_control_merge_hdr_bpp,</a>
<a name="ln457">                                                                .write_image = dt_control_merge_hdr_process };</a>
<a name="ln458"> </a>
<a name="ln459">  dt_control_merge_hdr_format_t dat = (dt_control_merge_hdr_format_t){.parent = { 0 }, .d = &amp;d };</a>
<a name="ln460"> </a>
<a name="ln461">  int num = 1;</a>
<a name="ln462">  while(t)</a>
<a name="ln463">  {</a>
<a name="ln464">    if(d.abort) goto end;</a>
<a name="ln465"> </a>
<a name="ln466">    const uint32_t imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln467"> </a>
<a name="ln468">    dt_imageio_export_with_flags(imgid, &quot;unused&quot;, &amp;buf, (dt_imageio_module_data_t *)&amp;dat, TRUE, FALSE, FALSE, TRUE,</a>
<a name="ln469">                                 FALSE, &quot;pre:rawprepare&quot;, FALSE, DT_COLORSPACE_NONE, NULL, DT_INTENT_LAST, NULL, NULL,</a>
<a name="ln470">                                 num, total, NULL);</a>
<a name="ln471"> </a>
<a name="ln472">    t = g_list_delete_link(t, t);</a>
<a name="ln473"> </a>
<a name="ln474">    /* update the progress bar */</a>
<a name="ln475">    fraction += 1.0 / (total + 1);</a>
<a name="ln476">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln477">    num++;</a>
<a name="ln478">  }</a>
<a name="ln479">  params-&gt;index = NULL;</a>
<a name="ln480"> </a>
<a name="ln481">  if(d.abort) goto end;</a>
<a name="ln482"> </a>
<a name="ln483">// normalize by white level to make clipping at 1.0 work as expected</a>
<a name="ln484"> </a>
<a name="ln485">#ifdef _OPENMP</a>
<a name="ln486">#pragma omp parallel for schedule(static) default(none) shared(d)</a>
<a name="ln487">#endif</a>
<a name="ln488">  for(size_t k = 0; k &lt; (size_t)d.wd * d.ht; k++)</a>
<a name="ln489">  {</a>
<a name="ln490">    if(d.weight[k] &gt; 0.0) d.pixels[k] = fmaxf(0.0f, d.pixels[k] / (d.whitelevel * d.weight[k]));</a>
<a name="ln491">  }</a>
<a name="ln492"> </a>
<a name="ln493">  // output hdr as digital negative with exif data.</a>
<a name="ln494">  uint8_t *exif = NULL;</a>
<a name="ln495">  char pathname[PATH_MAX] = { 0 };</a>
<a name="ln496">  gboolean from_cache = TRUE;</a>
<a name="ln497">  dt_image_full_path(d.first_imgid, pathname, sizeof(pathname), &amp;from_cache);</a>
<a name="ln498"> </a>
<a name="ln499">  // last param is dng mode</a>
<a name="ln500">  const int exif_len = dt_exif_read_blob(&amp;exif, pathname, d.first_imgid, 0, d.wd, d.ht, 1);</a>
<a name="ln501">  char *c = pathname + strlen(pathname);</a>
<a name="ln502">  while(*c != '.' &amp;&amp; c &gt; pathname) c--;</a>
<a name="ln503">  g_strlcpy(c, &quot;-hdr.dng&quot;, sizeof(pathname) - (c - pathname));</a>
<a name="ln504">  dt_imageio_write_dng(pathname, d.pixels, d.wd, d.ht, exif, exif_len, d.first_filter, (const uint8_t (*)[6])d.first_xtrans, 1.0f);</a>
<a name="ln505">  free(exif);</a>
<a name="ln506"> </a>
<a name="ln507">  dt_control_job_set_progress(job, 1.0);</a>
<a name="ln508"> </a>
<a name="ln509">  while(*c != '/' &amp;&amp; c &gt; pathname) c--;</a>
<a name="ln510">  dt_control_log(_(&quot;wrote merged HDR `%s'&quot;), c + 1);</a>
<a name="ln511"> </a>
<a name="ln512">  // import new image</a>
<a name="ln513">  gchar *directory = g_path_get_dirname((const gchar *)pathname);</a>
<a name="ln514">  dt_film_t film;</a>
<a name="ln515">  const int filmid = dt_film_new(&amp;film, directory);</a>
<a name="ln516">  dt_image_import(filmid, pathname, TRUE);</a>
<a name="ln517">  g_free(directory);</a>
<a name="ln518"> </a>
<a name="ln519">end:</a>
<a name="ln520">  free(d.pixels);</a>
<a name="ln521">  free(d.weight);</a>
<a name="ln522"> </a>
<a name="ln523">  dt_control_queue_redraw_center();</a>
<a name="ln524">  return 0;</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">static int32_t dt_control_duplicate_images_job_run(dt_job_t *job)</a>
<a name="ln528">{</a>
<a name="ln529">  int imgid = -1;</a>
<a name="ln530">  int newimgid = -1;</a>
<a name="ln531">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln532">  GList *t = params-&gt;index;</a>
<a name="ln533">  guint total = g_list_length(t);</a>
<a name="ln534">  char message[512] = { 0 };</a>
<a name="ln535">  double fraction = 0;</a>
<a name="ln536">  snprintf(message, sizeof(message), ngettext(&quot;duplicating %d image&quot;, &quot;duplicating %d images&quot;, total), total);</a>
<a name="ln537">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln538">  while(t)</a>
<a name="ln539">  {</a>
<a name="ln540">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln541">    newimgid = dt_image_duplicate(imgid);</a>
<a name="ln542">    if(newimgid != -1)</a>
<a name="ln543">    {</a>
<a name="ln544">      dt_history_copy_and_paste_on_image(imgid, newimgid, FALSE, NULL);</a>
<a name="ln545">      dt_collection_update_query(darktable.collection);</a>
<a name="ln546">    }</a>
<a name="ln547">    t = g_list_delete_link(t, t);</a>
<a name="ln548">    fraction = 1.0 / total;</a>
<a name="ln549">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln550">  }</a>
<a name="ln551">  params-&gt;index = NULL;</a>
<a name="ln552">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln553">  dt_control_queue_redraw_center();</a>
<a name="ln554">  return 0;</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">static int32_t dt_control_flip_images_job_run(dt_job_t *job)</a>
<a name="ln558">{</a>
<a name="ln559">  int imgid = -1;</a>
<a name="ln560">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln561">  const int cw = params-&gt;flag;</a>
<a name="ln562">  GList *t = params-&gt;index;</a>
<a name="ln563">  guint total = g_list_length(t);</a>
<a name="ln564">  double fraction = 0;</a>
<a name="ln565">  char message[512] = { 0 };</a>
<a name="ln566">  snprintf(message, sizeof(message), ngettext(&quot;flipping %d image&quot;, &quot;flipping %d images&quot;, total), total);</a>
<a name="ln567">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln568">  while(t)</a>
<a name="ln569">  {</a>
<a name="ln570">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln571">    dt_image_flip(imgid, cw);</a>
<a name="ln572">    t = g_list_delete_link(t, t);</a>
<a name="ln573">    fraction = 1.0 / total;</a>
<a name="ln574">    dt_image_set_aspect_ratio(imgid);</a>
<a name="ln575">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln576">  }</a>
<a name="ln577">  params-&gt;index = NULL;</a>
<a name="ln578">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln579">  dt_control_queue_redraw_center();</a>
<a name="ln580">  return 0;</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">static char *_get_image_list(GList *l)</a>
<a name="ln584">{</a>
<a name="ln585">  const guint size = g_list_length(l);</a>
<a name="ln586">  char num[8];</a>
<a name="ln587">  char *buffer = calloc(size, sizeof(num));</a>
<a name="ln588">  int imgid;</a>
<a name="ln589">  gboolean first = TRUE;</a>
<a name="ln590"> </a>
<a name="ln591">  buffer[0] = '\0';</a>
<a name="ln592"> </a>
<a name="ln593">  while(l)</a>
<a name="ln594">  {</a>
<a name="ln595">    imgid = GPOINTER_TO_INT(l-&gt;data);</a>
<a name="ln596">    snprintf(num, sizeof(num), &quot;%s%6d&quot;, first ? &quot;&quot; : &quot;,&quot;, imgid);</a>
<a name="ln597">    g_strlcat(buffer, num, size * sizeof(num));</a>
<a name="ln598">    l = g_list_next(l);</a>
<a name="ln599">    first = FALSE;</a>
<a name="ln600">  }</a>
<a name="ln601">  return buffer;</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">static void _set_remove_flag(char *imgs)</a>
<a name="ln605">{</a>
<a name="ln606">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln607">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln608">                              &quot;UPDATE main.images SET flags = (flags|?1) WHERE id IN (?2)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln609">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, DT_IMAGE_REMOVE);</a>
<a name="ln610">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgs, -1, SQLITE_STATIC);</a>
<a name="ln611">  sqlite3_step(stmt);</a>
<a name="ln612">  sqlite3_finalize(stmt);</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615">static GList *_get_full_pathname(char *imgs)</a>
<a name="ln616">{</a>
<a name="ln617">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln618">  GList *list = NULL;</a>
<a name="ln619"> </a>
<a name="ln620">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT DISTINCT folder || '&quot; G_DIR_SEPARATOR_S &quot;' || filename FROM &quot;</a>
<a name="ln621">                                                             &quot;main.images i, main.film_rolls f &quot;</a>
<a name="ln622">                                                             &quot;ON i.film_id = f.id WHERE i.id IN (?1)&quot;,</a>
<a name="ln623">                              -1, &amp;stmt, NULL);</a>
<a name="ln624">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, imgs, -1, SQLITE_STATIC);</a>
<a name="ln625">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln626">  {</a>
<a name="ln627">    list = g_list_append(list, g_strdup((const gchar *)sqlite3_column_text(stmt, 0)));</a>
<a name="ln628">  }</a>
<a name="ln629">  sqlite3_finalize(stmt);</a>
<a name="ln630">  return list;</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">static int32_t dt_control_remove_images_job_run(dt_job_t *job)</a>
<a name="ln634">{</a>
<a name="ln635">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln636">  GList *t = params-&gt;index;</a>
<a name="ln637">  char *imgs = _get_image_list(t);</a>
<a name="ln638">  guint total = g_list_length(t);</a>
<a name="ln639">  char message[512] = { 0 };</a>
<a name="ln640">  double fraction = 0;</a>
<a name="ln641">  snprintf(message, sizeof(message), ngettext(&quot;removing %d image&quot;, &quot;removing %d images&quot;, total), total);</a>
<a name="ln642">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln643">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln644"> </a>
<a name="ln645">  // check that we can safely remove the image</a>
<a name="ln646">  gboolean remove_ok = TRUE;</a>
<a name="ln647">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln648">                              &quot;SELECT id FROM main.images WHERE id IN (?2) AND flags&amp;?1=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln649">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, DT_IMAGE_LOCAL_COPY);</a>
<a name="ln650">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgs, -1, SQLITE_STATIC);</a>
<a name="ln651"> </a>
<a name="ln652">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln653">  {</a>
<a name="ln654">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln655">    if(!dt_image_safe_remove(imgid))</a>
<a name="ln656">    {</a>
<a name="ln657">      remove_ok = FALSE;</a>
<a name="ln658">      break;</a>
<a name="ln659">    }</a>
<a name="ln660">  }</a>
<a name="ln661">  sqlite3_finalize(stmt);</a>
<a name="ln662"> </a>
<a name="ln663">  if(!remove_ok)</a>
<a name="ln664">  {</a>
<a name="ln665">    dt_control_log(_(&quot;cannot remove local copy when the original file is not accessible.&quot;));</a>
<a name="ln666">    free(imgs);</a>
<a name="ln667">    return 0;</a>
<a name="ln668">  }</a>
<a name="ln669"> </a>
<a name="ln670">  // update remove status</a>
<a name="ln671">  _set_remove_flag(imgs);</a>
<a name="ln672"> </a>
<a name="ln673">  dt_collection_update(darktable.collection);</a>
<a name="ln674"> </a>
<a name="ln675">  // We need a list of files to regenerate .xmp files if there are duplicates</a>
<a name="ln676">  GList *list = _get_full_pathname(imgs);</a>
<a name="ln677"> </a>
<a name="ln678">  free(imgs);</a>
<a name="ln679"> </a>
<a name="ln680">  while(t)</a>
<a name="ln681">  {</a>
<a name="ln682">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln683">    dt_image_remove(imgid);</a>
<a name="ln684">    t = g_list_delete_link(t, t);</a>
<a name="ln685">    fraction = 1.0 / total;</a>
<a name="ln686">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln687">  }</a>
<a name="ln688">  params-&gt;index = NULL;</a>
<a name="ln689"> </a>
<a name="ln690">  char *imgname;</a>
<a name="ln691">  while(list)</a>
<a name="ln692">  {</a>
<a name="ln693">    imgname = (char *)list-&gt;data;</a>
<a name="ln694">    dt_image_synch_all_xmp(imgname);</a>
<a name="ln695">    list = g_list_delete_link(list, list);</a>
<a name="ln696">  }</a>
<a name="ln697">  dt_film_remove_empty();</a>
<a name="ln698">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln699">  dt_control_queue_redraw_center();</a>
<a name="ln700">  return 0;</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703">typedef struct _dt_delete_modal_dialog_t</a>
<a name="ln704">{</a>
<a name="ln705">  int send_to_trash;</a>
<a name="ln706">  const char *filename;</a>
<a name="ln707">  const char *error_message;</a>
<a name="ln708"> </a>
<a name="ln709">  gint dialog_result;</a>
<a name="ln710"> </a>
<a name="ln711">  dt_pthread_mutex_t mutex;</a>
<a name="ln712">  pthread_cond_t cond;</a>
<a name="ln713">} _dt_delete_modal_dialog_t;</a>
<a name="ln714"> </a>
<a name="ln715">enum _dt_delete_status</a>
<a name="ln716">{</a>
<a name="ln717">  _DT_DELETE_STATUS_UNKNOWN = 0,</a>
<a name="ln718">  _DT_DELETE_STATUS_OK_TO_REMOVE = 1,</a>
<a name="ln719">  _DT_DELETE_STATUS_SKIP_FILE = 2,</a>
<a name="ln720">  _DT_DELETE_STATUS_STOP_PROCESSING = 3</a>
<a name="ln721">};</a>
<a name="ln722"> </a>
<a name="ln723">enum _dt_delete_dialog_choice</a>
<a name="ln724">{</a>
<a name="ln725">  _DT_DELETE_DIALOG_CHOICE_DELETE = 1,</a>
<a name="ln726">  _DT_DELETE_DIALOG_CHOICE_DELETE_ALL = 2,</a>
<a name="ln727">  _DT_DELETE_DIALOG_CHOICE_REMOVE = 3,</a>
<a name="ln728">  _DT_DELETE_DIALOG_CHOICE_CONTINUE = 4,</a>
<a name="ln729">  _DT_DELETE_DIALOG_CHOICE_STOP = 5</a>
<a name="ln730">};</a>
<a name="ln731"> </a>
<a name="ln732">static gboolean _dt_delete_dialog_main_thread(gpointer user_data)</a>
<a name="ln733">{</a>
<a name="ln734">  _dt_delete_modal_dialog_t* modal_dialog = (_dt_delete_modal_dialog_t*)user_data;</a>
<a name="ln735">  dt_pthread_mutex_lock(&amp;modal_dialog-&gt;mutex);</a>
<a name="ln736"> </a>
<a name="ln737">  GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln738">      GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)),</a>
<a name="ln739">      GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln740">      GTK_MESSAGE_QUESTION,</a>
<a name="ln741">      GTK_BUTTONS_NONE,</a>
<a name="ln742">      modal_dialog-&gt;send_to_trash</a>
<a name="ln743">        ? _(&quot;could not send %s to trash%s%s&quot;)</a>
<a name="ln744">        : _(&quot;could not physically delete %s%s%s&quot;),</a>
<a name="ln745">      modal_dialog-&gt;filename,</a>
<a name="ln746">      modal_dialog-&gt;error_message != NULL ? &quot;: &quot; : &quot;&quot;,</a>
<a name="ln747">      modal_dialog-&gt;error_message != NULL ? modal_dialog-&gt;error_message : &quot;&quot;);</a>
<a name="ln748">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln749">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln750">#endif</a>
<a name="ln751"> </a>
<a name="ln752">  if (modal_dialog-&gt;send_to_trash)</a>
<a name="ln753">  {</a>
<a name="ln754">    gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;physically delete&quot;), _DT_DELETE_DIALOG_CHOICE_DELETE);</a>
<a name="ln755">    gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;physically delete all files&quot;), _DT_DELETE_DIALOG_CHOICE_DELETE_ALL);</a>
<a name="ln756">  }</a>
<a name="ln757">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;only remove from the collection&quot;), _DT_DELETE_DIALOG_CHOICE_REMOVE);</a>
<a name="ln758">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;skip to next file&quot;), _DT_DELETE_DIALOG_CHOICE_CONTINUE);</a>
<a name="ln759">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;stop process&quot;), _DT_DELETE_DIALOG_CHOICE_STOP);</a>
<a name="ln760"> </a>
<a name="ln761">  gtk_window_set_title(</a>
<a name="ln762">      GTK_WINDOW(dialog),</a>
<a name="ln763">      modal_dialog-&gt;send_to_trash</a>
<a name="ln764">        ? _(&quot;trashing error&quot;)</a>
<a name="ln765">        : _(&quot;deletion error&quot;));</a>
<a name="ln766">  modal_dialog-&gt;dialog_result = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln767">  gtk_widget_destroy(dialog);</a>
<a name="ln768"> </a>
<a name="ln769">  pthread_cond_signal(&amp;modal_dialog-&gt;cond);</a>
<a name="ln770"> </a>
<a name="ln771">  dt_pthread_mutex_unlock(&amp;modal_dialog-&gt;mutex);</a>
<a name="ln772"> </a>
<a name="ln773">  // Don't call again on next idle time</a>
<a name="ln774">  return FALSE;</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">static gint _dt_delete_file_display_modal_dialog(int send_to_trash, const char *filename, const char *error_message)</a>
<a name="ln778">{</a>
<a name="ln779">  _dt_delete_modal_dialog_t modal_dialog;</a>
<a name="ln780">  modal_dialog.send_to_trash = send_to_trash;</a>
<a name="ln781">  modal_dialog.filename = filename;</a>
<a name="ln782">  modal_dialog.error_message = error_message;</a>
<a name="ln783"> </a>
<a name="ln784">  modal_dialog.dialog_result = GTK_RESPONSE_NONE;</a>
<a name="ln785"> </a>
<a name="ln786">  dt_pthread_mutex_init(&amp;modal_dialog.mutex, NULL);</a>
<a name="ln787">  pthread_cond_init(&amp;modal_dialog.cond, NULL);</a>
<a name="ln788"> </a>
<a name="ln789">  dt_pthread_mutex_lock(&amp;modal_dialog.mutex);</a>
<a name="ln790"> </a>
<a name="ln791">  gdk_threads_add_idle(_dt_delete_dialog_main_thread, &amp;modal_dialog);</a>
<a name="ln792">  while (modal_dialog.dialog_result == GTK_RESPONSE_NONE)</a>
<a name="ln793">    dt_pthread_cond_wait(&amp;modal_dialog.cond, &amp;modal_dialog.mutex);</a>
<a name="ln794"> </a>
<a name="ln795">  dt_pthread_mutex_unlock(&amp;modal_dialog.mutex);</a>
<a name="ln796">  dt_pthread_mutex_destroy(&amp;modal_dialog.mutex);</a>
<a name="ln797">  pthread_cond_destroy(&amp;modal_dialog.cond);</a>
<a name="ln798"> </a>
<a name="ln799">  return modal_dialog.dialog_result;</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">static enum _dt_delete_status delete_file_from_disk(const char *filename, gboolean *delete_on_trash_error)</a>
<a name="ln803">{</a>
<a name="ln804">  enum _dt_delete_status delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln805"> </a>
<a name="ln806">  GFile *gfile = g_file_new_for_path(filename);</a>
<a name="ln807">  int send_to_trash = dt_conf_get_bool(&quot;send_to_trash&quot;);</a>
<a name="ln808"> </a>
<a name="ln809">  while (delete_status == _DT_DELETE_STATUS_UNKNOWN)</a>
<a name="ln810">  {</a>
<a name="ln811">    gboolean delete_success = FALSE;</a>
<a name="ln812">    GError *gerror = NULL;</a>
<a name="ln813">    if (send_to_trash)</a>
<a name="ln814">    {</a>
<a name="ln815">#ifdef __APPLE__</a>
<a name="ln816">      delete_success = dt_osx_file_trash(filename, &amp;gerror);</a>
<a name="ln817">#elif defined(_WIN32)</a>
<a name="ln818">      delete_success = dt_win_file_trash(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln819">#else</a>
<a name="ln820">      delete_success = g_file_trash(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln821">#endif</a>
<a name="ln822">    }</a>
<a name="ln823">    else</a>
<a name="ln824">    {</a>
<a name="ln825">      delete_success = g_file_delete(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln826">    }</a>
<a name="ln827"> </a>
<a name="ln828">    // Delete is a success or the file does not exists: OK to remove from collection</a>
<a name="ln829">    if (delete_success</a>
<a name="ln830">        || g_error_matches(gerror, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))</a>
<a name="ln831">    {</a>
<a name="ln832">      delete_status = _DT_DELETE_STATUS_OK_TO_REMOVE;</a>
<a name="ln833">    }</a>
<a name="ln834">    else if (send_to_trash &amp;&amp; *delete_on_trash_error)</a>
<a name="ln835">    {</a>
<a name="ln836">      // Loop again, this time delete instead of trashing</a>
<a name="ln837">      delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln838">      send_to_trash = FALSE;</a>
<a name="ln839">    }</a>
<a name="ln840">    else</a>
<a name="ln841">    {</a>
<a name="ln842">      const char *filename_display = NULL;</a>
<a name="ln843">      GFileInfo *gfileinfo = g_file_query_info(</a>
<a name="ln844">          gfile,</a>
<a name="ln845">          G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,</a>
<a name="ln846">          G_FILE_QUERY_INFO_NONE,</a>
<a name="ln847">          NULL /*cancellable*/,</a>
<a name="ln848">          NULL /*error*/);</a>
<a name="ln849">      if (gfileinfo != NULL)</a>
<a name="ln850">        filename_display = g_file_info_get_attribute_string(</a>
<a name="ln851">            gfileinfo,</a>
<a name="ln852">            G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME);</a>
<a name="ln853"> </a>
<a name="ln854">      gint res = _dt_delete_file_display_modal_dialog(</a>
<a name="ln855">          send_to_trash,</a>
<a name="ln856">          filename_display == NULL ? filename : filename_display,</a>
<a name="ln857">          gerror == NULL ? NULL : gerror-&gt;message);</a>
<a name="ln858"> </a>
<a name="ln859">      if (send_to_trash &amp;&amp; res == _DT_DELETE_DIALOG_CHOICE_DELETE)</a>
<a name="ln860">      {</a>
<a name="ln861">        // Loop again, this time delete instead of trashing</a>
<a name="ln862">        delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln863">        send_to_trash = FALSE;</a>
<a name="ln864">      }</a>
<a name="ln865">      else if (send_to_trash &amp;&amp; res == _DT_DELETE_DIALOG_CHOICE_DELETE_ALL)</a>
<a name="ln866">      {</a>
<a name="ln867">        // Loop again, this time delete instead of trashing</a>
<a name="ln868">        delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln869">        send_to_trash = FALSE;</a>
<a name="ln870">        *delete_on_trash_error = TRUE;</a>
<a name="ln871">      }</a>
<a name="ln872">      else if (res == _DT_DELETE_DIALOG_CHOICE_REMOVE)</a>
<a name="ln873">      {</a>
<a name="ln874">        delete_status = _DT_DELETE_STATUS_OK_TO_REMOVE;</a>
<a name="ln875">      }</a>
<a name="ln876">      else if (res == _DT_DELETE_DIALOG_CHOICE_CONTINUE)</a>
<a name="ln877">      {</a>
<a name="ln878">        delete_status = _DT_DELETE_STATUS_SKIP_FILE;</a>
<a name="ln879">      }</a>
<a name="ln880">      else</a>
<a name="ln881">      {</a>
<a name="ln882">        delete_status = _DT_DELETE_STATUS_STOP_PROCESSING;</a>
<a name="ln883">      }</a>
<a name="ln884">    }</a>
<a name="ln885">    if (gerror != NULL)</a>
<a name="ln886">      g_error_free(gerror);</a>
<a name="ln887">  }</a>
<a name="ln888"> </a>
<a name="ln889">  if (gfile != NULL)</a>
<a name="ln890">    g_object_unref(gfile);</a>
<a name="ln891"> </a>
<a name="ln892">  return delete_status;</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895"> </a>
<a name="ln896">static int32_t dt_control_delete_images_job_run(dt_job_t *job)</a>
<a name="ln897">{</a>
<a name="ln898">  int imgid = -1;</a>
<a name="ln899">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln900">  GList *t = params-&gt;index;</a>
<a name="ln901">  char *imgs = _get_image_list(t);</a>
<a name="ln902">  char imgidstr[25] = { 0 };</a>
<a name="ln903">  guint total = g_list_length(t);</a>
<a name="ln904">  char message[512] = { 0 };</a>
<a name="ln905">  double fraction = 0;</a>
<a name="ln906">  gboolean delete_on_trash_error = FALSE;</a>
<a name="ln907">  if (dt_conf_get_bool(&quot;send_to_trash&quot;))</a>
<a name="ln908">    snprintf(message, sizeof(message), ngettext(&quot;trashing %d image&quot;, &quot;trashing %d images&quot;, total), total);</a>
<a name="ln909">  else</a>
<a name="ln910">    snprintf(message, sizeof(message), ngettext(&quot;deleting %d image&quot;, &quot;deleting %d images&quot;, total), total);</a>
<a name="ln911">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln912"> </a>
<a name="ln913">  sqlite3_stmt *stmt;</a>
<a name="ln914"> </a>
<a name="ln915">  dt_collection_update(darktable.collection);</a>
<a name="ln916"> </a>
<a name="ln917">  // We need a list of files to regenerate .xmp files if there are duplicates</a>
<a name="ln918">  GList *list = _get_full_pathname(imgs);</a>
<a name="ln919"> </a>
<a name="ln920">  free(imgs);</a>
<a name="ln921"> </a>
<a name="ln922">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln923">                              &quot;SELECT COUNT(*) FROM main.images WHERE filename IN (SELECT filename FROM &quot;</a>
<a name="ln924">                              &quot;main.images WHERE id = ?1) AND film_id IN (SELECT film_id FROM main.images WHERE &quot;</a>
<a name="ln925">                              &quot;id = ?1)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln926">  while(t)</a>
<a name="ln927">  {</a>
<a name="ln928">    enum _dt_delete_status delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln929">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln930">    char filename[PATH_MAX] = { 0 };</a>
<a name="ln931">    gboolean from_cache = FALSE;</a>
<a name="ln932">    dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln933"> </a>
<a name="ln934">#ifdef _WIN32</a>
<a name="ln935">    char *dirname = g_path_get_dirname(filename);</a>
<a name="ln936">#endif</a>
<a name="ln937"> </a>
<a name="ln938">    int duplicates = 0;</a>
<a name="ln939">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln940">    if(sqlite3_step(stmt) == SQLITE_ROW) duplicates = sqlite3_column_int(stmt, 0);</a>
<a name="ln941">    sqlite3_reset(stmt);</a>
<a name="ln942">    sqlite3_clear_bindings(stmt);</a>
<a name="ln943"> </a>
<a name="ln944">    // remove from disk:</a>
<a name="ln945">    if(duplicates == 1)</a>
<a name="ln946">    {</a>
<a name="ln947">      // first check for local copies, never delete a file whose original file is not accessible</a>
<a name="ln948">      if (dt_image_local_copy_reset(imgid))</a>
<a name="ln949">        goto delete_next_file;</a>
<a name="ln950"> </a>
<a name="ln951">      snprintf(imgidstr, sizeof(imgidstr), &quot;%d&quot;, imgid);</a>
<a name="ln952">      _set_remove_flag(imgidstr);</a>
<a name="ln953">      dt_image_remove(imgid);</a>
<a name="ln954"> </a>
<a name="ln955">      // there are no further duplicates so we can remove the source data file</a>
<a name="ln956">      delete_status = delete_file_from_disk(filename, &amp;delete_on_trash_error);</a>
<a name="ln957">      if (delete_status != _DT_DELETE_STATUS_OK_TO_REMOVE)</a>
<a name="ln958">        goto delete_next_file;</a>
<a name="ln959"> </a>
<a name="ln960">      // all sidecar files - including left-overs - can be deleted;</a>
<a name="ln961">      // left-overs can result when previously duplicates have been REMOVED;</a>
<a name="ln962">      // no need to keep them as the source data file is gone.</a>
<a name="ln963">      gchar pattern[PATH_MAX] = { 0 };</a>
<a name="ln964"> </a>
<a name="ln965">      // NULL terminated list of glob patterns; should include &quot;&quot; and can be extended if needed</a>
<a name="ln966">      static const gchar *glob_patterns[]</a>
<a name="ln967">          = { &quot;&quot;, &quot;_[0-9][0-9]&quot;, &quot;_[0-9][0-9][0-9]&quot;, &quot;_[0-9][0-9][0-9][0-9]&quot;, NULL };</a>
<a name="ln968"> </a>
<a name="ln969">      const gchar **glob_pattern = glob_patterns;</a>
<a name="ln970">      GList *files = NULL;</a>
<a name="ln971">      while(*glob_pattern)</a>
<a name="ln972">      {</a>
<a name="ln973">        snprintf(pattern, sizeof(pattern), &quot;%s&quot;, filename);</a>
<a name="ln974">        gchar *c1 = pattern + strlen(pattern);</a>
<a name="ln975">        while(*c1 != '.' &amp;&amp; c1 &gt; pattern) c1--;</a>
<a name="ln976">        snprintf(c1, pattern + sizeof(pattern) - c1, &quot;%s&quot;, *glob_pattern);</a>
<a name="ln977">        const gchar *c2 = filename + strlen(filename);</a>
<a name="ln978">        while(*c2 != '.' &amp;&amp; c2 &gt; filename) c2--;</a>
<a name="ln979">        snprintf(c1 + strlen(*glob_pattern), pattern + sizeof(pattern) - c1 - strlen(*glob_pattern), &quot;%s.xmp&quot;,</a>
<a name="ln980">                 c2);</a>
<a name="ln981"> </a>
<a name="ln982">#ifdef _WIN32</a>
<a name="ln983">        wchar_t *wpattern = g_utf8_to_utf16(pattern, -1, NULL, NULL, NULL);</a>
<a name="ln984">        WIN32_FIND_DATAW data;</a>
<a name="ln985">        HANDLE handle = FindFirstFileW(wpattern, &amp;data);</a>
<a name="ln986">        g_free(wpattern);</a>
<a name="ln987">        if(handle != INVALID_HANDLE_VALUE)</a>
<a name="ln988">        {</a>
<a name="ln989">          do</a>
<a name="ln990">          {</a>
<a name="ln991">            char *xmp_filename = g_utf16_to_utf8(data.cFileName, -1, NULL, NULL, NULL);</a>
<a name="ln992">            files = g_list_append(files, g_build_filename(dirname, xmp_filename, NULL));</a>
<a name="ln993">            g_free(xmp_filename);</a>
<a name="ln994">          }</a>
<a name="ln995">          while(FindNextFileW(handle, &amp;data));</a>
<a name="ln996">        }</a>
<a name="ln997">#else</a>
<a name="ln998">        glob_t globbuf;</a>
<a name="ln999">        if(!glob(pattern, 0, NULL, &amp;globbuf))</a>
<a name="ln1000">        {</a>
<a name="ln1001">          for(size_t i = 0; i &lt; globbuf.gl_pathc; i++)</a>
<a name="ln1002">            files = g_list_append(files, g_strdup(globbuf.gl_pathv[i]));</a>
<a name="ln1003">          globfree(&amp;globbuf);</a>
<a name="ln1004">        }</a>
<a name="ln1005">#endif</a>
<a name="ln1006"> </a>
<a name="ln1007">        glob_pattern++;</a>
<a name="ln1008">      }</a>
<a name="ln1009"> </a>
<a name="ln1010">      GList *file_iter = g_list_first(files);</a>
<a name="ln1011">      while(file_iter != NULL)</a>
<a name="ln1012">      {</a>
<a name="ln1013">        delete_status = delete_file_from_disk(file_iter-&gt;data, &amp;delete_on_trash_error);</a>
<a name="ln1014">        if (delete_status != _DT_DELETE_STATUS_OK_TO_REMOVE)</a>
<a name="ln1015">          break;</a>
<a name="ln1016">        file_iter = g_list_next(file_iter);</a>
<a name="ln1017">      }</a>
<a name="ln1018"> </a>
<a name="ln1019">      g_list_free_full(files, g_free);</a>
<a name="ln1020">    }</a>
<a name="ln1021">    else</a>
<a name="ln1022">    {</a>
<a name="ln1023">      // don't remove the actual source data if there are further duplicates using it;</a>
<a name="ln1024">      // just delete the xmp file of the duplicate selected.</a>
<a name="ln1025"> </a>
<a name="ln1026">      dt_image_path_append_version(imgid, filename, sizeof(filename));</a>
<a name="ln1027">      g_strlcat(filename, &quot;.xmp&quot;, sizeof(filename));</a>
<a name="ln1028"> </a>
<a name="ln1029">      // remove image from db first ...</a>
<a name="ln1030">      snprintf(imgidstr, sizeof(imgidstr), &quot;%d&quot;, imgid);</a>
<a name="ln1031">      _set_remove_flag(imgidstr);</a>
<a name="ln1032">      dt_image_remove(imgid);</a>
<a name="ln1033"> </a>
<a name="ln1034">      // ... and delete afterwards because removing will re-write the XMP</a>
<a name="ln1035">      delete_status = delete_file_from_disk(filename, &amp;delete_on_trash_error);</a>
<a name="ln1036">    }</a>
<a name="ln1037"> </a>
<a name="ln1038">delete_next_file:</a>
<a name="ln1039">#ifdef _WIN32</a>
<a name="ln1040">    g_free(dirname);</a>
<a name="ln1041">#endif</a>
<a name="ln1042">    t = g_list_delete_link(t, t);</a>
<a name="ln1043">    fraction = 1.0 / total;</a>
<a name="ln1044">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1045">    if (delete_status == _DT_DELETE_STATUS_STOP_PROCESSING)</a>
<a name="ln1046">      break;</a>
<a name="ln1047">  }</a>
<a name="ln1048">  while (t)</a>
<a name="ln1049">    t = g_list_delete_link(t, t);</a>
<a name="ln1050">  params-&gt;index = NULL;</a>
<a name="ln1051">  sqlite3_finalize(stmt);</a>
<a name="ln1052"> </a>
<a name="ln1053">  char *imgname;</a>
<a name="ln1054">  while(list)</a>
<a name="ln1055">  {</a>
<a name="ln1056">    imgname = (char *)list-&gt;data;</a>
<a name="ln1057">    dt_image_synch_all_xmp(imgname);</a>
<a name="ln1058">    list = g_list_delete_link(list, list);</a>
<a name="ln1059">  }</a>
<a name="ln1060">  g_list_free(list);</a>
<a name="ln1061">  dt_film_remove_empty();</a>
<a name="ln1062">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln1063">  dt_control_queue_redraw_center();</a>
<a name="ln1064">  return 0;</a>
<a name="ln1065">}</a>
<a name="ln1066"> </a>
<a name="ln1067">static void _pop_undo(gpointer user_data, dt_undo_type_t type, dt_undo_data_t item, dt_undo_action_t action)</a>
<a name="ln1068">{</a>
<a name="ln1069">  dt_undo_geotag_t *geotags = (dt_undo_geotag_t *)item;</a>
<a name="ln1070">  GList *l;</a>
<a name="ln1071"> </a>
<a name="ln1072">  if(action == DT_ACTION_UNDO)</a>
<a name="ln1073">    l = geotags-&gt;before;</a>
<a name="ln1074">  else</a>
<a name="ln1075">    l = geotags-&gt;after;</a>
<a name="ln1076"> </a>
<a name="ln1077">  while(l)</a>
<a name="ln1078">  {</a>
<a name="ln1079">    const int imgid = GPOINTER_TO_INT((dt_image_geoloc_t *)l-&gt;data);</a>
<a name="ln1080"> </a>
<a name="ln1081">    l = g_list_next(l);</a>
<a name="ln1082">    dt_image_geoloc_t *geoloc = (dt_image_geoloc_t *)l-&gt;data;</a>
<a name="ln1083">    dt_image_set_location_and_elevation(imgid, geoloc);</a>
<a name="ln1084"> </a>
<a name="ln1085">    l = g_list_next(l);</a>
<a name="ln1086">  }</a>
<a name="ln1087">}</a>
<a name="ln1088"> </a>
<a name="ln1089">void _geotags_free_undo_data_t(gpointer data)</a>
<a name="ln1090">{</a>
<a name="ln1091">  dt_undo_geotag_t *geotags = (dt_undo_geotag_t *)data;</a>
<a name="ln1092">  GList *lb = geotags-&gt;before;</a>
<a name="ln1093">  GList *la = geotags-&gt;after;</a>
<a name="ln1094"> </a>
<a name="ln1095">  do</a>
<a name="ln1096">  {</a>
<a name="ln1097">    if(la) la = g_list_next(la);</a>
<a name="ln1098">    if(la) g_free((dt_image_geoloc_t *)la-&gt;data);</a>
<a name="ln1099">    if(lb) lb = g_list_next(lb);</a>
<a name="ln1100">    if(lb) g_free((dt_image_geoloc_t *)lb-&gt;data);</a>
<a name="ln1101">    if(la) la = g_list_next(la);</a>
<a name="ln1102">    if(lb) lb = g_list_next(lb);</a>
<a name="ln1103">  } while(la || lb);</a>
<a name="ln1104"> </a>
<a name="ln1105">  g_list_free(geotags-&gt;before);</a>
<a name="ln1106">  g_list_free(geotags-&gt;after);</a>
<a name="ln1107">}</a>
<a name="ln1108"> </a>
<a name="ln1109">static int32_t dt_control_gpx_apply_job_run(dt_job_t *job)</a>
<a name="ln1110">{</a>
<a name="ln1111">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln1112">  GList *t = params-&gt;index;</a>
<a name="ln1113">  struct dt_gpx_t *gpx = NULL;</a>
<a name="ln1114">  uint32_t cntr = 0;</a>
<a name="ln1115">  const dt_control_gpx_apply_t *d = params-&gt;data;</a>
<a name="ln1116">  const gchar *filename = d-&gt;filename;</a>
<a name="ln1117">  const gchar *tz = d-&gt;tz;</a>
<a name="ln1118"> </a>
<a name="ln1119">  /* do we have any selected images */</a>
<a name="ln1120">  if(!t) goto bail_out;</a>
<a name="ln1121"> </a>
<a name="ln1122">  /* try parse the gpx data */</a>
<a name="ln1123">  gpx = dt_gpx_new(filename);</a>
<a name="ln1124">  if(!gpx)</a>
<a name="ln1125">  {</a>
<a name="ln1126">    dt_control_log(_(&quot;failed to parse GPX file&quot;));</a>
<a name="ln1127">    goto bail_out;</a>
<a name="ln1128">  }</a>
<a name="ln1129"> </a>
<a name="ln1130">  GTimeZone *tz_camera = (tz == NULL) ? g_time_zone_new_utc() : g_time_zone_new(tz);</a>
<a name="ln1131">  if(!tz_camera) goto bail_out;</a>
<a name="ln1132">  GTimeZone *tz_utc = g_time_zone_new_utc();</a>
<a name="ln1133"> </a>
<a name="ln1134">  dt_undo_geotag_t *geotags = g_malloc0(sizeof(dt_undo_geotag_t));</a>
<a name="ln1135"> </a>
<a name="ln1136">  /* go thru each selected image and lookup location in gpx */</a>
<a name="ln1137">  do</a>
<a name="ln1138">  {</a>
<a name="ln1139">    GTimeVal timestamp;</a>
<a name="ln1140">    GDateTime *exif_time, *utc_time;</a>
<a name="ln1141">    dt_image_geoloc_t geoloc;</a>
<a name="ln1142">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1143"> </a>
<a name="ln1144">    /* get image */</a>
<a name="ln1145">    const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1146">    if(!cimg) continue;</a>
<a name="ln1147"> </a>
<a name="ln1148">    /* convert exif datetime</a>
<a name="ln1149">       TODO: exiv2 dates should be iso8601 and we are probably doing some ugly</a>
<a name="ln1150">       conversion before inserting into database.</a>
<a name="ln1151">     */</a>
<a name="ln1152">    gint year;</a>
<a name="ln1153">    gint month;</a>
<a name="ln1154">    gint day;</a>
<a name="ln1155">    gint hour;</a>
<a name="ln1156">    gint minute;</a>
<a name="ln1157">    gint seconds;</a>
<a name="ln1158"> </a>
<a name="ln1159">    if(sscanf(cimg-&gt;exif_datetime_taken, &quot;%d:%d:%d %d:%d:%d&quot;, (int *)&amp;year, (int *)&amp;month, (int *)&amp;day,</a>
<a name="ln1160">              (int *)&amp;hour, (int *)&amp;minute, (int *)&amp;seconds) != 6)</a>
<a name="ln1161">    {</a>
<a name="ln1162">      fprintf(stderr, &quot;broken exif time in db, '%s'\n&quot;, cimg-&gt;exif_datetime_taken);</a>
<a name="ln1163">      dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1164">      continue;</a>
<a name="ln1165">    }</a>
<a name="ln1166"> </a>
<a name="ln1167">    /* release the lock */</a>
<a name="ln1168">    dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1169"> </a>
<a name="ln1170">    exif_time = g_date_time_new(tz_camera, year, month, day, hour, minute, seconds);</a>
<a name="ln1171">    if(!exif_time) continue;</a>
<a name="ln1172">    utc_time = g_date_time_to_timezone(exif_time, tz_utc);</a>
<a name="ln1173">    g_date_time_unref(exif_time);</a>
<a name="ln1174">    if(!utc_time) continue;</a>
<a name="ln1175">    gboolean res = g_date_time_to_timeval(utc_time, &amp;timestamp);</a>
<a name="ln1176">    g_date_time_unref(utc_time);</a>
<a name="ln1177">    if(!res) continue;</a>
<a name="ln1178"> </a>
<a name="ln1179">    /* only update image location if time is within gpx tack range */</a>
<a name="ln1180">    if(dt_gpx_get_location(gpx, &amp;timestamp, &amp;geoloc))</a>
<a name="ln1181">    {</a>
<a name="ln1182">      dt_image_geoloc_t *before = g_malloc0(sizeof(dt_image_geoloc_t));</a>
<a name="ln1183">      dt_image_geoloc_t *after = g_malloc0(sizeof(dt_image_geoloc_t));</a>
<a name="ln1184">      memcpy(after, &amp;geoloc, sizeof(dt_image_geoloc_t));</a>
<a name="ln1185">      dt_image_get_location(imgid, before);</a>
<a name="ln1186"> </a>
<a name="ln1187">      // first the image id and then the position</a>
<a name="ln1188">      geotags-&gt;before = g_list_append(geotags-&gt;before, GINT_TO_POINTER(imgid));</a>
<a name="ln1189">      geotags-&gt;before = g_list_append(geotags-&gt;before, (gpointer)before);</a>
<a name="ln1190">      // likewise for the new position</a>
<a name="ln1191">      geotags-&gt;after = g_list_append(geotags-&gt;after, GINT_TO_POINTER(imgid));</a>
<a name="ln1192">      geotags-&gt;after = g_list_append(geotags-&gt;after, (gpointer)after);</a>
<a name="ln1193"> </a>
<a name="ln1194">      dt_image_set_location_and_elevation(imgid, &amp;geoloc);</a>
<a name="ln1195">      cntr++;</a>
<a name="ln1196">    }</a>
<a name="ln1197"> </a>
<a name="ln1198">  } while((t = g_list_next(t)) != NULL);</a>
<a name="ln1199"> </a>
<a name="ln1200">  if(geotags-&gt;before)</a>
<a name="ln1201">  {</a>
<a name="ln1202">    dt_undo_start_group(darktable.undo, DT_UNDO_LT_GEOTAG);</a>
<a name="ln1203">    dt_undo_record(darktable.undo, NULL, DT_UNDO_LT_GEOTAG, (dt_undo_data_t)geotags, _pop_undo, _geotags_free_undo_data_t);</a>
<a name="ln1204">    dt_undo_end_group(darktable.undo);</a>
<a name="ln1205">  }</a>
<a name="ln1206"> </a>
<a name="ln1207">  dt_control_log(ngettext(&quot;applied matched GPX location onto %d image&quot;, &quot;applied matched GPX location onto %d images&quot;, cntr), cntr);</a>
<a name="ln1208"> </a>
<a name="ln1209">  g_time_zone_unref(tz_camera);</a>
<a name="ln1210">  g_time_zone_unref(tz_utc);</a>
<a name="ln1211">  dt_gpx_destroy(gpx);</a>
<a name="ln1212">  return 0;</a>
<a name="ln1213"> </a>
<a name="ln1214">bail_out:</a>
<a name="ln1215">  if(gpx) dt_gpx_destroy(gpx);</a>
<a name="ln1216"> </a>
<a name="ln1217">  return 1;</a>
<a name="ln1218">}</a>
<a name="ln1219"> </a>
<a name="ln1220">static int32_t dt_control_move_images_job_run(dt_job_t *job)</a>
<a name="ln1221">{</a>
<a name="ln1222">  return _generic_dt_control_fileop_images_job_run(job, &amp;dt_image_move, _(&quot;moving %d image&quot;),</a>
<a name="ln1223">                                                   _(&quot;moving %d images&quot;));</a>
<a name="ln1224">}</a>
<a name="ln1225"> </a>
<a name="ln1226">static int32_t dt_control_copy_images_job_run(dt_job_t *job)</a>
<a name="ln1227">{</a>
<a name="ln1228">  return _generic_dt_control_fileop_images_job_run(job, &amp;dt_image_copy, _(&quot;copying %d image&quot;),</a>
<a name="ln1229">                                                   _(&quot;copying %d images&quot;));</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232">static int32_t dt_control_local_copy_images_job_run(dt_job_t *job)</a>
<a name="ln1233">{</a>
<a name="ln1234">  int imgid = -1;</a>
<a name="ln1235">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1236">  GList *t = params-&gt;index;</a>
<a name="ln1237">  guint tagid = 0;</a>
<a name="ln1238">  const guint total = g_list_length(t);</a>
<a name="ln1239">  double fraction = 0;</a>
<a name="ln1240">  const gboolean is_copy = params-&gt;flag == 1;</a>
<a name="ln1241">  char message[512] = { 0 };</a>
<a name="ln1242"> </a>
<a name="ln1243">  if(is_copy)</a>
<a name="ln1244">    snprintf(message, sizeof(message),</a>
<a name="ln1245">             ngettext(&quot;creating local copy of %d image&quot;, &quot;creating local copies of %d images&quot;, total), total);</a>
<a name="ln1246">  else</a>
<a name="ln1247">    snprintf(message, sizeof(message),</a>
<a name="ln1248">             ngettext(&quot;removing local copy of %d image&quot;, &quot;removing local copies of %d images&quot;, total), total);</a>
<a name="ln1249"> </a>
<a name="ln1250">  dt_control_log(&quot;%s&quot;, message);</a>
<a name="ln1251">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1252"> </a>
<a name="ln1253">  dt_tag_new(&quot;darktable|local-copy&quot;, &amp;tagid);</a>
<a name="ln1254"> </a>
<a name="ln1255">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln1256">  {</a>
<a name="ln1257">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1258">    if(is_copy)</a>
<a name="ln1259">    {</a>
<a name="ln1260">      if (dt_image_local_copy_set(imgid) == 0)</a>
<a name="ln1261">        dt_tag_attach_from_gui(tagid, imgid);</a>
<a name="ln1262">    }</a>
<a name="ln1263">    else</a>
<a name="ln1264">    {</a>
<a name="ln1265">      if (dt_image_local_copy_reset(imgid) == 0)</a>
<a name="ln1266">        dt_tag_detach_from_gui(tagid, imgid);</a>
<a name="ln1267">    }</a>
<a name="ln1268">    t = g_list_delete_link(t, t);</a>
<a name="ln1269"> </a>
<a name="ln1270">    fraction += 1.0 / total;</a>
<a name="ln1271">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1272">  }</a>
<a name="ln1273">  params-&gt;index = NULL;</a>
<a name="ln1274"> </a>
<a name="ln1275">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln1276">  return 0;</a>
<a name="ln1277">}</a>
<a name="ln1278"> </a>
<a name="ln1279">static int32_t dt_control_refresh_exif_run(dt_job_t *job)</a>
<a name="ln1280">{</a>
<a name="ln1281">  int imgid = -1;</a>
<a name="ln1282">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1283">  GList *t = params-&gt;index;</a>
<a name="ln1284">  guint total = g_list_length(t);</a>
<a name="ln1285">  double fraction = 0;</a>
<a name="ln1286">  char message[512] = { 0 };</a>
<a name="ln1287">  snprintf(message, sizeof(message), ngettext(&quot;refreshing info for %d image&quot;, &quot;refreshing info for %d images&quot;, total), total);</a>
<a name="ln1288">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1289">  while(t)</a>
<a name="ln1290">  {</a>
<a name="ln1291">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1292">    gboolean from_cache = TRUE;</a>
<a name="ln1293">    char sourcefile[PATH_MAX];</a>
<a name="ln1294">    dt_image_full_path(imgid, sourcefile, sizeof(sourcefile), &amp;from_cache);</a>
<a name="ln1295"> </a>
<a name="ln1296">    dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1297">    dt_exif_read(img, sourcefile);</a>
<a name="ln1298">    dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln1299"> </a>
<a name="ln1300">    dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_IMAGE_CHANGED);</a>
<a name="ln1301"> </a>
<a name="ln1302">    t = g_list_delete_link(t, t);</a>
<a name="ln1303">    fraction = 1.0 / total;</a>
<a name="ln1304">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1305">  }</a>
<a name="ln1306">  params-&gt;index = NULL;</a>
<a name="ln1307">  return 0;</a>
<a name="ln1308">}</a>
<a name="ln1309"> </a>
<a name="ln1310"> </a>
<a name="ln1311">static int32_t dt_control_export_job_run(dt_job_t *job)</a>
<a name="ln1312">{</a>
<a name="ln1313">  int imgid = -1;</a>
<a name="ln1314">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1315">  dt_control_export_t *settings = (dt_control_export_t *)params-&gt;data;</a>
<a name="ln1316">  GList *t = params-&gt;index;</a>
<a name="ln1317">  dt_imageio_module_format_t *mformat = dt_imageio_get_format_by_index(settings-&gt;format_index);</a>
<a name="ln1318">  g_assert(mformat);</a>
<a name="ln1319">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(settings-&gt;storage_index);</a>
<a name="ln1320">  g_assert(mstorage);</a>
<a name="ln1321">  dt_imageio_module_data_t *sdata = settings-&gt;sdata;</a>
<a name="ln1322"> </a>
<a name="ln1323">  // get a thread-safe fdata struct (one jpeg struct per thread etc):</a>
<a name="ln1324">  dt_imageio_module_data_t *fdata = mformat-&gt;get_params(mformat);</a>
<a name="ln1325"> </a>
<a name="ln1326">  if(mstorage-&gt;initialize_store)</a>
<a name="ln1327">  {</a>
<a name="ln1328">    if(mstorage-&gt;initialize_store(mstorage, sdata, &amp;mformat, &amp;fdata, &amp;t, settings-&gt;high_quality, settings-&gt;upscale))</a>
<a name="ln1329">    {</a>
<a name="ln1330">      // bail out, something went wrong</a>
<a name="ln1331">      goto end;</a>
<a name="ln1332">    }</a>
<a name="ln1333">    mformat-&gt;set_params(mformat, fdata, mformat-&gt;params_size(mformat));</a>
<a name="ln1334">    mstorage-&gt;set_params(mstorage, sdata, mstorage-&gt;params_size(mstorage));</a>
<a name="ln1335">  }</a>
<a name="ln1336"> </a>
<a name="ln1337">  // Get max dimensions...</a>
<a name="ln1338">  uint32_t w, h, fw, fh, sw, sh;</a>
<a name="ln1339">  fw = fh = sw = sh = 0;</a>
<a name="ln1340">  mstorage-&gt;dimension(mstorage, sdata, &amp;sw, &amp;sh);</a>
<a name="ln1341">  mformat-&gt;dimension(mformat, fdata, &amp;fw, &amp;fh);</a>
<a name="ln1342"> </a>
<a name="ln1343">  if(sw == 0 || fw == 0)</a>
<a name="ln1344">    w = sw &gt; fw ? sw : fw;</a>
<a name="ln1345">  else</a>
<a name="ln1346">    w = sw &lt; fw ? sw : fw;</a>
<a name="ln1347"> </a>
<a name="ln1348">  if(sh == 0 || fh == 0)</a>
<a name="ln1349">    h = sh &gt; fh ? sh : fh;</a>
<a name="ln1350">  else</a>
<a name="ln1351">    h = sh &lt; fh ? sh : fh;</a>
<a name="ln1352"> </a>
<a name="ln1353">  const guint total = g_list_length(t);</a>
<a name="ln1354">  dt_control_log(ngettext(&quot;exporting %d image..&quot;, &quot;exporting %d images..&quot;, total), total);</a>
<a name="ln1355">  char message[512] = { 0 };</a>
<a name="ln1356">  snprintf(message, sizeof(message), ngettext(&quot;exporting %d image to %s&quot;, &quot;exporting %d images to %s&quot;, total),</a>
<a name="ln1357">           total, mstorage-&gt;name(mstorage));</a>
<a name="ln1358">  // update the message. initialize_store() might have changed the number of images</a>
<a name="ln1359">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1360"> </a>
<a name="ln1361">  double fraction = 0;</a>
<a name="ln1362"> </a>
<a name="ln1363">  // set up the fdata struct</a>
<a name="ln1364">  fdata-&gt;max_width = (settings-&gt;max_width != 0 &amp;&amp; w != 0) ? MIN(w, settings-&gt;max_width) : MAX(w, settings-&gt;max_width);</a>
<a name="ln1365">  fdata-&gt;max_height = (settings-&gt;max_height != 0 &amp;&amp; h != 0) ? MIN(h, settings-&gt;max_height) : MAX(h, settings-&gt;max_height);</a>
<a name="ln1366">  g_strlcpy(fdata-&gt;style, settings-&gt;style, sizeof(fdata-&gt;style));</a>
<a name="ln1367">  fdata-&gt;style_append = settings-&gt;style_append;</a>
<a name="ln1368">  guint num = 0;</a>
<a name="ln1369">  // Invariant: the tagid for 'darktable|changed' will not change while this function runs. Is this a</a>
<a name="ln1370">  // sensible assumption?</a>
<a name="ln1371">  guint tagid = 0, etagid = 0;</a>
<a name="ln1372">  dt_tag_new(&quot;darktable|changed&quot;, &amp;tagid);</a>
<a name="ln1373">  dt_tag_new(&quot;darktable|exported&quot;, &amp;etagid);</a>
<a name="ln1374"> </a>
<a name="ln1375">  dt_export_metadata_t metadata;</a>
<a name="ln1376">  metadata.flags = 0;</a>
<a name="ln1377">  metadata.list = dt_util_str_to_glist(&quot;\1&quot;, settings-&gt;metadata_export);</a>
<a name="ln1378">  if (metadata.list)</a>
<a name="ln1379">  {</a>
<a name="ln1380">    metadata.flags = strtol(metadata.list-&gt;data, NULL, 16);</a>
<a name="ln1381">    metadata.list = g_list_remove(metadata.list, metadata.list-&gt;data);</a>
<a name="ln1382">  }</a>
<a name="ln1383"> </a>
<a name="ln1384">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln1385">  {</a>
<a name="ln1386">    if(!t)</a>
<a name="ln1387">      imgid = 0;</a>
<a name="ln1388">    else</a>
<a name="ln1389">    {</a>
<a name="ln1390">      imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1391">      t = g_list_delete_link(t, t);</a>
<a name="ln1392">      num = total - g_list_length(t);</a>
<a name="ln1393">    }</a>
<a name="ln1394"> </a>
<a name="ln1395">    // remove 'changed' tag from image</a>
<a name="ln1396">    dt_tag_detach(tagid, imgid);</a>
<a name="ln1397">    // make sure the 'exported' tag is set on the image</a>
<a name="ln1398">    dt_tag_attach_from_gui(etagid, imgid);</a>
<a name="ln1399">    // check if image still exists:</a>
<a name="ln1400">    char imgfilename[PATH_MAX] = { 0 };</a>
<a name="ln1401">    const dt_image_t *image = dt_image_cache_get(darktable.image_cache, (int32_t)imgid, 'r');</a>
<a name="ln1402">    if(image)</a>
<a name="ln1403">    {</a>
<a name="ln1404">      gboolean from_cache = TRUE;</a>
<a name="ln1405">      dt_image_full_path(image-&gt;id, imgfilename, sizeof(imgfilename), &amp;from_cache);</a>
<a name="ln1406">      if(!g_file_test(imgfilename, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln1407">      {</a>
<a name="ln1408">        dt_control_log(_(&quot;image `%s' is currently unavailable&quot;), image-&gt;filename);</a>
<a name="ln1409">        fprintf(stderr, &quot;image `%s' is currently unavailable\n&quot;, imgfilename);</a>
<a name="ln1410">        // dt_image_remove(imgid);</a>
<a name="ln1411">        dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1412">      }</a>
<a name="ln1413">      else</a>
<a name="ln1414">      {</a>
<a name="ln1415">        dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1416">        if(mstorage-&gt;store(mstorage, sdata, imgid, mformat, fdata, num, total, settings-&gt;high_quality, settings-&gt;upscale,</a>
<a name="ln1417">                           settings-&gt;icc_type, settings-&gt;icc_filename, settings-&gt;icc_intent,</a>
<a name="ln1418">                          &amp;metadata) != 0)</a>
<a name="ln1419">          dt_control_job_cancel(job);</a>
<a name="ln1420">      }</a>
<a name="ln1421">    }</a>
<a name="ln1422"> </a>
<a name="ln1423">    fraction += 1.0 / total;</a>
<a name="ln1424">    if(fraction &gt; 1.0) fraction = 1.0;</a>
<a name="ln1425">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1426">  }</a>
<a name="ln1427">  params-&gt;index = NULL;</a>
<a name="ln1428">  g_list_free_full(metadata.list, g_free);</a>
<a name="ln1429"> </a>
<a name="ln1430">  if(mstorage-&gt;finalize_store) mstorage-&gt;finalize_store(mstorage, sdata);</a>
<a name="ln1431"> </a>
<a name="ln1432">end:</a>
<a name="ln1433">  // all threads free their fdata</a>
<a name="ln1434">  mformat-&gt;free_params(mformat, fdata);</a>
<a name="ln1435"> </a>
<a name="ln1436">  // notify the user via the window manager</a>
<a name="ln1437">  dt_ui_notify_user();</a>
<a name="ln1438"> </a>
<a name="ln1439">  return 0;</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442">static dt_control_image_enumerator_t *dt_control_gpx_apply_alloc()</a>
<a name="ln1443">{</a>
<a name="ln1444">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1445">  if(!params) return NULL;</a>
<a name="ln1446"> </a>
<a name="ln1447">  params-&gt;data = calloc(1, sizeof(dt_control_gpx_apply_t));</a>
<a name="ln1448">  if(!params-&gt;data)</a>
<a name="ln1449">  {</a>
<a name="ln1450">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1451">    return NULL;</a>
<a name="ln1452">  }</a>
<a name="ln1453"> </a>
<a name="ln1454">  return params;</a>
<a name="ln1455">}</a>
<a name="ln1456"> </a>
<a name="ln1457">static void dt_control_gpx_apply_job_cleanup(void *p)</a>
<a name="ln1458">{</a>
<a name="ln1459">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln1460"> </a>
<a name="ln1461">  dt_control_gpx_apply_t *data = params-&gt;data;</a>
<a name="ln1462">  g_free(data-&gt;filename);</a>
<a name="ln1463">  g_free(data-&gt;tz);</a>
<a name="ln1464"> </a>
<a name="ln1465">  free(data);</a>
<a name="ln1466"> </a>
<a name="ln1467">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1468">}</a>
<a name="ln1469"> </a>
<a name="ln1470">static dt_job_t *dt_control_gpx_apply_job_create(const gchar *filename, int32_t filmid, const gchar *tz)</a>
<a name="ln1471">{</a>
<a name="ln1472">  dt_job_t *job = dt_control_job_create(&amp;dt_control_gpx_apply_job_run, &quot;gpx apply&quot;);</a>
<a name="ln1473">  if(!job) return NULL;</a>
<a name="ln1474">  dt_control_image_enumerator_t *params = dt_control_gpx_apply_alloc();</a>
<a name="ln1475">  if(!params)</a>
<a name="ln1476">  {</a>
<a name="ln1477">    dt_control_job_dispose(job);</a>
<a name="ln1478">    return NULL;</a>
<a name="ln1479">  }</a>
<a name="ln1480">  dt_control_job_set_params(job, params, dt_control_gpx_apply_job_cleanup);</a>
<a name="ln1481"> </a>
<a name="ln1482">  if(filmid != -1)</a>
<a name="ln1483">    dt_control_image_enumerator_job_film_init(params, filmid);</a>
<a name="ln1484">  else</a>
<a name="ln1485">    dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln1486"> </a>
<a name="ln1487">  dt_control_gpx_apply_t *data = params-&gt;data;</a>
<a name="ln1488">  data-&gt;filename = g_strdup(filename);</a>
<a name="ln1489">  data-&gt;tz = g_strdup(tz);</a>
<a name="ln1490"> </a>
<a name="ln1491">  return job;</a>
<a name="ln1492">}</a>
<a name="ln1493"> </a>
<a name="ln1494">void dt_control_merge_hdr()</a>
<a name="ln1495">{</a>
<a name="ln1496">  dt_control_add_job(</a>
<a name="ln1497">      darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1498">      dt_control_generic_images_job_create(&amp;dt_control_merge_hdr_job_run, N_(&quot;merge hdr image&quot;), 0, NULL,</a>
<a name="ln1499">                                           PROGRESS_CANCELLABLE));</a>
<a name="ln1500">}</a>
<a name="ln1501"> </a>
<a name="ln1502">void dt_control_gpx_apply(const gchar *filename, int32_t filmid, const gchar *tz)</a>
<a name="ln1503">{</a>
<a name="ln1504">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1505">                     dt_control_gpx_apply_job_create(filename, filmid, tz));</a>
<a name="ln1506">}</a>
<a name="ln1507"> </a>
<a name="ln1508">void dt_control_duplicate_images()</a>
<a name="ln1509">{</a>
<a name="ln1510">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1511">                     dt_control_generic_images_job_create(&amp;dt_control_duplicate_images_job_run,</a>
<a name="ln1512">                                                          N_(&quot;duplicate images&quot;), 0, NULL, PROGRESS_SIMPLE));</a>
<a name="ln1513">}</a>
<a name="ln1514"> </a>
<a name="ln1515">void dt_control_flip_images(const int32_t cw)</a>
<a name="ln1516">{</a>
<a name="ln1517">  dt_control_add_job(</a>
<a name="ln1518">      darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1519">      dt_control_generic_images_job_create(&amp;dt_control_flip_images_job_run, N_(&quot;flip images&quot;), cw, NULL,</a>
<a name="ln1520">                                           PROGRESS_SIMPLE));</a>
<a name="ln1521">}</a>
<a name="ln1522"> </a>
<a name="ln1523">gboolean dt_control_remove_images()</a>
<a name="ln1524">{</a>
<a name="ln1525">  // get all selected images now, to avoid the set changing during ui interaction</a>
<a name="ln1526">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_remove_images_job_run, N_(&quot;remove images&quot;), 0, NULL,</a>
<a name="ln1527">                                                       PROGRESS_SIMPLE);</a>
<a name="ln1528">  if(dt_conf_get_bool(&quot;ask_before_remove&quot;))</a>
<a name="ln1529">  {</a>
<a name="ln1530">    GtkWidget *dialog;</a>
<a name="ln1531">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1532"> </a>
<a name="ln1533">    int number;</a>
<a name="ln1534">    if (dt_view_get_image_to_act_on() != -1)</a>
<a name="ln1535">      number = 1;</a>
<a name="ln1536">    else</a>
<a name="ln1537">      number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1538"> </a>
<a name="ln1539">    // Do not show the dialog if no image is selected:</a>
<a name="ln1540">    if(number == 0)</a>
<a name="ln1541">    {</a>
<a name="ln1542">      dt_control_job_dispose(job);</a>
<a name="ln1543">      return TRUE;</a>
<a name="ln1544">    }</a>
<a name="ln1545"> </a>
<a name="ln1546">    dialog = gtk_message_dialog_new(</a>
<a name="ln1547">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1548">        ngettext(&quot;do you really want to remove %d selected image from the collection?&quot;,</a>
<a name="ln1549">                 &quot;do you really want to remove %d selected images from the collection?&quot;, number),</a>
<a name="ln1550">        number);</a>
<a name="ln1551">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1552">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1553">#endif</a>
<a name="ln1554"> </a>
<a name="ln1555">    gtk_window_set_title(GTK_WINDOW(dialog), _(&quot;remove images?&quot;));</a>
<a name="ln1556">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1557">    gtk_widget_destroy(dialog);</a>
<a name="ln1558">    if(res != GTK_RESPONSE_YES)</a>
<a name="ln1559">    {</a>
<a name="ln1560">      dt_control_job_dispose(job);</a>
<a name="ln1561">      return FALSE;</a>
<a name="ln1562">    }</a>
<a name="ln1563">  }</a>
<a name="ln1564">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1565">  return TRUE;</a>
<a name="ln1566">}</a>
<a name="ln1567"> </a>
<a name="ln1568">void dt_control_delete_images()</a>
<a name="ln1569">{</a>
<a name="ln1570">  // first get all selected images, to avoid the set changing during ui interaction</a>
<a name="ln1571">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_delete_images_job_run, N_(&quot;delete images&quot;), 0, NULL,</a>
<a name="ln1572">                                                       PROGRESS_SIMPLE);</a>
<a name="ln1573">  int send_to_trash = dt_conf_get_bool(&quot;send_to_trash&quot;);</a>
<a name="ln1574">  if(dt_conf_get_bool(&quot;ask_before_delete&quot;))</a>
<a name="ln1575">  {</a>
<a name="ln1576">    GtkWidget *dialog;</a>
<a name="ln1577">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1578"> </a>
<a name="ln1579">    int number;</a>
<a name="ln1580">    if (dt_view_get_image_to_act_on() != -1)</a>
<a name="ln1581">      number = 1;</a>
<a name="ln1582">    else</a>
<a name="ln1583">      number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1584"> </a>
<a name="ln1585">    // Do not show the dialog if no image is selected:</a>
<a name="ln1586">    if(number == 0)</a>
<a name="ln1587">    {</a>
<a name="ln1588">      dt_control_job_dispose(job);</a>
<a name="ln1589">      return;</a>
<a name="ln1590">    }</a>
<a name="ln1591"> </a>
<a name="ln1592">    dialog = gtk_message_dialog_new(</a>
<a name="ln1593">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1594">        send_to_trash</a>
<a name="ln1595">        ? ngettext(&quot;do you really want to send %d selected image to trash?&quot;,</a>
<a name="ln1596">          &quot;do you really want to send %d selected images to trash?&quot;, number)</a>
<a name="ln1597">        : ngettext(&quot;do you really want to physically delete %d selected image from disk?&quot;,</a>
<a name="ln1598">          &quot;do you really want to physically delete %d selected images from disk?&quot;, number),</a>
<a name="ln1599">        number);</a>
<a name="ln1600">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1601">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1602">#endif</a>
<a name="ln1603"> </a>
<a name="ln1604">    gtk_window_set_title(GTK_WINDOW(dialog), send_to_trash ? _(&quot;trash images?&quot;) : _(&quot;delete images?&quot;));</a>
<a name="ln1605">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1606">    gtk_widget_destroy(dialog);</a>
<a name="ln1607">    if(res != GTK_RESPONSE_YES)</a>
<a name="ln1608">    {</a>
<a name="ln1609">      dt_control_job_dispose(job);</a>
<a name="ln1610">      return;</a>
<a name="ln1611">    }</a>
<a name="ln1612">  }</a>
<a name="ln1613">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1614">}</a>
<a name="ln1615"> </a>
<a name="ln1616">void dt_control_move_images()</a>
<a name="ln1617">{</a>
<a name="ln1618">  // Open file chooser dialog</a>
<a name="ln1619">  gchar *dir = NULL;</a>
<a name="ln1620">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1621">  int number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1622"> </a>
<a name="ln1623">  // Do not show the dialog if no image is selected:</a>
<a name="ln1624">  if(number == 0) return;</a>
<a name="ln1625">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_move_images_job_run, N_(&quot;move images&quot;), 0, dir,</a>
<a name="ln1626">                                                       PROGRESS_CANCELLABLE);</a>
<a name="ln1627"> </a>
<a name="ln1628">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1629">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1630">      GTK_RESPONSE_CANCEL, _(&quot;_select as destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1631">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1632">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1633">#endif</a>
<a name="ln1634"> </a>
<a name="ln1635">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln1636">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1637">  {</a>
<a name="ln1638">    dir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1639">  }</a>
<a name="ln1640">  gtk_widget_destroy(filechooser);</a>
<a name="ln1641"> </a>
<a name="ln1642">  if(!dir || !g_file_test(dir, G_FILE_TEST_IS_DIR)) goto abort;</a>
<a name="ln1643"> </a>
<a name="ln1644">  // ugly, but we need to set this after constructing the job:</a>
<a name="ln1645">  ((dt_control_image_enumerator_t *)dt_control_job_get_params(job))-&gt;data = dir;</a>
<a name="ln1646"> </a>
<a name="ln1647">  if(dt_conf_get_bool(&quot;ask_before_move&quot;))</a>
<a name="ln1648">  {</a>
<a name="ln1649">    GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln1650">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1651">        ngettext(&quot;do you really want to physically move the %d selected image to %s?\n&quot;</a>
<a name="ln1652">                 &quot;(all unselected duplicates will be moved along)&quot;,</a>
<a name="ln1653">                 &quot;do you really want to physically move %d selected images to %s?\n&quot;</a>
<a name="ln1654">                 &quot;(all unselected duplicates will be moved along)&quot;,</a>
<a name="ln1655">                 number),</a>
<a name="ln1656">        number, dir);</a>
<a name="ln1657">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1658">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1659">#endif</a>
<a name="ln1660">    gtk_window_set_title(GTK_WINDOW(dialog), ngettext(&quot;move image?&quot;, &quot;move images?&quot;, number));</a>
<a name="ln1661"> </a>
<a name="ln1662">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1663">    gtk_widget_destroy(dialog);</a>
<a name="ln1664"> </a>
<a name="ln1665">    if(res != GTK_RESPONSE_YES) goto abort;</a>
<a name="ln1666">  }</a>
<a name="ln1667"> </a>
<a name="ln1668">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1669">  return;</a>
<a name="ln1670"> </a>
<a name="ln1671">abort:</a>
<a name="ln1672">  g_free(dir);</a>
<a name="ln1673">  dt_control_job_dispose(job);</a>
<a name="ln1674">}</a>
<a name="ln1675"> </a>
<a name="ln1676">void dt_control_copy_images()</a>
<a name="ln1677">{</a>
<a name="ln1678">  // Open file chooser dialog</a>
<a name="ln1679">  gchar *dir = NULL;</a>
<a name="ln1680">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1681">  int number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1682"> </a>
<a name="ln1683">  // Do not show the dialog if no image is selected:</a>
<a name="ln1684">  if(number == 0) return;</a>
<a name="ln1685">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_copy_images_job_run, N_(&quot;copy images&quot;), 0, dir,</a>
<a name="ln1686">                                                       PROGRESS_CANCELLABLE);</a>
<a name="ln1687"> </a>
<a name="ln1688">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1689">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1690">      GTK_RESPONSE_CANCEL, _(&quot;_select as destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1691">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1692">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1693">#endif</a>
<a name="ln1694"> </a>
<a name="ln1695">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln1696">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1697">  {</a>
<a name="ln1698">    dir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1699">  }</a>
<a name="ln1700">  gtk_widget_destroy(filechooser);</a>
<a name="ln1701"> </a>
<a name="ln1702">  if(!dir || !g_file_test(dir, G_FILE_TEST_IS_DIR)) goto abort;</a>
<a name="ln1703"> </a>
<a name="ln1704">  // ugly, but we need to set this after constructing the job:</a>
<a name="ln1705">  ((dt_control_image_enumerator_t *)dt_control_job_get_params(job))-&gt;data = dir;</a>
<a name="ln1706"> </a>
<a name="ln1707">  if(dt_conf_get_bool(&quot;ask_before_copy&quot;))</a>
<a name="ln1708">  {</a>
<a name="ln1709">    GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln1710">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1711">        ngettext(&quot;do you really want to physically copy the %d selected image to %s?&quot;,</a>
<a name="ln1712">                 &quot;do you really want to physically copy %d selected images to %s?&quot;, number),</a>
<a name="ln1713">        number, dir);</a>
<a name="ln1714">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1715">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1716">#endif</a>
<a name="ln1717">    gtk_window_set_title(GTK_WINDOW(dialog), ngettext(&quot;copy image?&quot;, &quot;copy images?&quot;, number));</a>
<a name="ln1718"> </a>
<a name="ln1719">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1720">    gtk_widget_destroy(dialog);</a>
<a name="ln1721"> </a>
<a name="ln1722">    if(res != GTK_RESPONSE_YES) goto abort;</a>
<a name="ln1723">  }</a>
<a name="ln1724"> </a>
<a name="ln1725">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1726">  return;</a>
<a name="ln1727"> </a>
<a name="ln1728">abort:</a>
<a name="ln1729">  g_free(dir);</a>
<a name="ln1730">  dt_control_job_dispose(job);</a>
<a name="ln1731">}</a>
<a name="ln1732"> </a>
<a name="ln1733">void dt_control_set_local_copy_images()</a>
<a name="ln1734">{</a>
<a name="ln1735">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1736">                     dt_control_generic_images_job_create(&amp;dt_control_local_copy_images_job_run,</a>
<a name="ln1737">                                                          N_(&quot;local copy images&quot;), 1, NULL, PROGRESS_CANCELLABLE));</a>
<a name="ln1738">}</a>
<a name="ln1739"> </a>
<a name="ln1740">void dt_control_reset_local_copy_images()</a>
<a name="ln1741">{</a>
<a name="ln1742">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1743">                     dt_control_generic_images_job_create(&amp;dt_control_local_copy_images_job_run,</a>
<a name="ln1744">                                                          N_(&quot;local copy images&quot;), 0, NULL, PROGRESS_CANCELLABLE));</a>
<a name="ln1745">}</a>
<a name="ln1746"> </a>
<a name="ln1747">void dt_control_refresh_exif()</a>
<a name="ln1748">{</a>
<a name="ln1749">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1750">                     dt_control_generic_images_job_create(&amp;dt_control_refresh_exif_run,</a>
<a name="ln1751">                                                          N_(&quot;refresh exif&quot;), 0, NULL, PROGRESS_CANCELLABLE));</a>
<a name="ln1752">}</a>
<a name="ln1753"> </a>
<a name="ln1754">static dt_control_image_enumerator_t *dt_control_export_alloc()</a>
<a name="ln1755">{</a>
<a name="ln1756">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1757">  if(!params) return NULL;</a>
<a name="ln1758"> </a>
<a name="ln1759">  params-&gt;data = calloc(1, sizeof(dt_control_export_t));</a>
<a name="ln1760">  if(!params-&gt;data)</a>
<a name="ln1761">  {</a>
<a name="ln1762">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1763">    return NULL;</a>
<a name="ln1764">  }</a>
<a name="ln1765"> </a>
<a name="ln1766">  return params;</a>
<a name="ln1767">}</a>
<a name="ln1768"> </a>
<a name="ln1769">static void dt_control_export_cleanup(void *p)</a>
<a name="ln1770">{</a>
<a name="ln1771">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln1772"> </a>
<a name="ln1773">  dt_control_export_t *settings = (dt_control_export_t *)params-&gt;data;</a>
<a name="ln1774">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(settings-&gt;storage_index);</a>
<a name="ln1775">  dt_imageio_module_data_t *sdata = settings-&gt;sdata;</a>
<a name="ln1776"> </a>
<a name="ln1777">  mstorage-&gt;free_params(mstorage, sdata);</a>
<a name="ln1778"> </a>
<a name="ln1779">  g_free(settings-&gt;icc_filename);</a>
<a name="ln1780">  g_free(settings-&gt;metadata_export);</a>
<a name="ln1781">  free(params-&gt;data);</a>
<a name="ln1782"> </a>
<a name="ln1783">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1784">}</a>
<a name="ln1785"> </a>
<a name="ln1786">void dt_control_export(GList *imgid_list, int max_width, int max_height, int format_index, int storage_index,</a>
<a name="ln1787">                       gboolean high_quality, gboolean upscale, char *style, gboolean style_append,</a>
<a name="ln1788">                       dt_colorspaces_color_profile_type_t icc_type, const gchar *icc_filename,</a>
<a name="ln1789">                       dt_iop_color_intent_t icc_intent, const gchar *metadata_export)</a>
<a name="ln1790">{</a>
<a name="ln1791">  dt_job_t *job = dt_control_job_create(&amp;dt_control_export_job_run, &quot;export&quot;);</a>
<a name="ln1792">  if(!job) return;</a>
<a name="ln1793">  dt_control_image_enumerator_t *params = dt_control_export_alloc();</a>
<a name="ln1794">  if(!params)</a>
<a name="ln1795">  {</a>
<a name="ln1796">    dt_control_job_dispose(job);</a>
<a name="ln1797">    return;</a>
<a name="ln1798">  }</a>
<a name="ln1799">  dt_control_job_set_params(job, params, dt_control_export_cleanup);</a>
<a name="ln1800"> </a>
<a name="ln1801">  params-&gt;index = imgid_list;</a>
<a name="ln1802"> </a>
<a name="ln1803">  dt_control_export_t *data = params-&gt;data;</a>
<a name="ln1804">  data-&gt;max_width = max_width;</a>
<a name="ln1805">  data-&gt;max_height = max_height;</a>
<a name="ln1806">  data-&gt;format_index = format_index;</a>
<a name="ln1807">  data-&gt;storage_index = storage_index;</a>
<a name="ln1808">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(storage_index);</a>
<a name="ln1809">  g_assert(mstorage);</a>
<a name="ln1810">  // get shared storage param struct (global sequence counter, one picasa connection etc)</a>
<a name="ln1811">  dt_imageio_module_data_t *sdata = mstorage-&gt;get_params(mstorage);</a>
<a name="ln1812">  if(sdata == NULL)</a>
<a name="ln1813">  {</a>
<a name="ln1814">    dt_control_log(_(&quot;failed to get parameters from storage module `%s', aborting export..&quot;),</a>
<a name="ln1815">                   mstorage-&gt;name(mstorage));</a>
<a name="ln1816">    dt_control_job_dispose(job);</a>
<a name="ln1817">    return;</a>
<a name="ln1818">  }</a>
<a name="ln1819">  data-&gt;sdata = sdata;</a>
<a name="ln1820">  data-&gt;high_quality = high_quality;</a>
<a name="ln1821">  data-&gt;upscale = upscale;</a>
<a name="ln1822">  g_strlcpy(data-&gt;style, style, sizeof(data-&gt;style));</a>
<a name="ln1823">  data-&gt;style_append = style_append;</a>
<a name="ln1824">  data-&gt;icc_type = icc_type;</a>
<a name="ln1825">  data-&gt;icc_filename = g_strdup(icc_filename);</a>
<a name="ln1826">  data-&gt;icc_intent = icc_intent;</a>
<a name="ln1827">  data-&gt;metadata_export = g_strdup(metadata_export);</a>
<a name="ln1828"> </a>
<a name="ln1829">  dt_control_job_add_progress(job, _(&quot;export images&quot;), TRUE);</a>
<a name="ln1830">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_EXPORT, job);</a>
<a name="ln1831"> </a>
<a name="ln1832">  // tell the storage that we got its params for an export so it can reset itself to a safe state</a>
<a name="ln1833">  mstorage-&gt;export_dispatched(mstorage);</a>
<a name="ln1834">}</a>
<a name="ln1835"> </a>
<a name="ln1836">static int32_t dt_control_time_offset_job_run(dt_job_t *job)</a>
<a name="ln1837">{</a>
<a name="ln1838">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1839">  uint32_t cntr = 0;</a>
<a name="ln1840">  double fraction = 0.0;</a>
<a name="ln1841">  GList *t = params-&gt;index;</a>
<a name="ln1842">  const long int offset = ((dt_control_time_offset_t *)params-&gt;data)-&gt;offset;</a>
<a name="ln1843">  char message[512] = { 0 };</a>
<a name="ln1844"> </a>
<a name="ln1845">  /* do we have any selected images and is offset != 0 */</a>
<a name="ln1846">  if(!t || offset == 0)</a>
<a name="ln1847">  {</a>
<a name="ln1848">    return 1;</a>
<a name="ln1849">  }</a>
<a name="ln1850"> </a>
<a name="ln1851">  const guint total = g_list_length(t);</a>
<a name="ln1852"> </a>
<a name="ln1853">  snprintf(message, sizeof(message),</a>
<a name="ln1854">           ngettext(&quot;adding time offset to %d image&quot;, &quot;adding time offset to %d images&quot;, total), total);</a>
<a name="ln1855">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1856"> </a>
<a name="ln1857">  /* go thru each selected image and update datetime_taken */</a>
<a name="ln1858">  do</a>
<a name="ln1859">  {</a>
<a name="ln1860">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1861"> </a>
<a name="ln1862">    dt_image_add_time_offset(imgid, offset);</a>
<a name="ln1863">    cntr++;</a>
<a name="ln1864"> </a>
<a name="ln1865">    fraction = MAX(fraction, (1.0 * cntr) / total);</a>
<a name="ln1866">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1867">  } while((t = g_list_next(t)) != NULL);</a>
<a name="ln1868"> </a>
<a name="ln1869">  dt_control_log(ngettext(&quot;added time offset to %d image&quot;, &quot;added time offset to %d images&quot;, cntr), cntr);</a>
<a name="ln1870"> </a>
<a name="ln1871">  return 0;</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874">static void *dt_control_time_offset_alloc()</a>
<a name="ln1875">{</a>
<a name="ln1876">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1877">  if(!params) return NULL;</a>
<a name="ln1878"> </a>
<a name="ln1879">  params-&gt;data = calloc(1, sizeof(dt_control_time_offset_t));</a>
<a name="ln1880">  if(!params-&gt;data)</a>
<a name="ln1881">  {</a>
<a name="ln1882">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1883">    return NULL;</a>
<a name="ln1884">  }</a>
<a name="ln1885"> </a>
<a name="ln1886">  return params;</a>
<a name="ln1887">}</a>
<a name="ln1888"> </a>
<a name="ln1889">static void dt_control_time_offset_job_cleanup(void *p)</a>
<a name="ln1890">{</a>
<a name="ln1891">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)p;</a>
<a name="ln1892"> </a>
<a name="ln1893">  free(params-&gt;data);</a>
<a name="ln1894"> </a>
<a name="ln1895">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1896">}</a>
<a name="ln1897"> </a>
<a name="ln1898">static dt_job_t *dt_control_time_offset_job_create(const long int offset, int imgid)</a>
<a name="ln1899">{</a>
<a name="ln1900">  dt_job_t *job = dt_control_job_create(&amp;dt_control_time_offset_job_run, &quot;time offset&quot;);</a>
<a name="ln1901">  if(!job) return NULL;</a>
<a name="ln1902">  dt_control_image_enumerator_t *params = dt_control_time_offset_alloc();</a>
<a name="ln1903">  if(!params)</a>
<a name="ln1904">  {</a>
<a name="ln1905">    dt_control_job_dispose(job);</a>
<a name="ln1906">    return NULL;</a>
<a name="ln1907">  }</a>
<a name="ln1908">  dt_control_job_add_progress(job, _(&quot;time offset&quot;), FALSE);</a>
<a name="ln1909">  dt_control_job_set_params(job, params, dt_control_time_offset_job_cleanup);</a>
<a name="ln1910"> </a>
<a name="ln1911">  if(imgid != -1)</a>
<a name="ln1912">    params-&gt;index = g_list_append(params-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln1913">  else</a>
<a name="ln1914">    dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln1915"> </a>
<a name="ln1916">  dt_control_time_offset_t *data = params-&gt;data;</a>
<a name="ln1917">  data-&gt;offset = offset;</a>
<a name="ln1918">  params-&gt;data = data;</a>
<a name="ln1919">  return job;</a>
<a name="ln1920">}</a>
<a name="ln1921"> </a>
<a name="ln1922">void dt_control_time_offset(const long int offset, int imgid)</a>
<a name="ln1923">{</a>
<a name="ln1924">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1925">                     dt_control_time_offset_job_create(offset, imgid));</a>
<a name="ln1926">}</a>
<a name="ln1927"> </a>
<a name="ln1928">void dt_control_write_sidecar_files()</a>
<a name="ln1929">{</a>
<a name="ln1930">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1931">                     dt_control_generic_images_job_create(&amp;dt_control_write_sidecar_files_job_run,</a>
<a name="ln1932">                                                          N_(&quot;write sidecar files&quot;), 0, NULL, PROGRESS_NONE));</a>
<a name="ln1933">}</a>
<a name="ln1934"> </a>
<a name="ln1935">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1936">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1937">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="591"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'buffer'. Check lines: 591, 587.</p></div>
<div class="balloon" rel="1060"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="1386"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!t' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
