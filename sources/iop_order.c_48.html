
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2018 edgardo hoszowski.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;common/colorspaces_inline_conversions.h&quot;</a>
<a name="ln24">#include &quot;common/iop_order.h&quot;</a>
<a name="ln25">#include &quot;common/debug.h&quot;</a>
<a name="ln26">#include &quot;develop/imageop.h&quot;</a>
<a name="ln27">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln28">#include &quot;develop/pixelpipe.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;stdio.h&gt;</a>
<a name="ln31">#include &lt;stdlib.h&gt;</a>
<a name="ln32">#include &lt;string.h&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#define DT_IOP_ORDER_VERSION 2</a>
<a name="ln35"> </a>
<a name="ln36">static void _ioppr_insert_iop_after(GList **_iop_order_list, GList *history_list, const char *op_new, const char *op_previous, const int dont_move);</a>
<a name="ln37">static void _ioppr_insert_iop_before(GList **_iop_order_list, GList *history_list, const char *op_new, const char *op_next, const int dont_move);</a>
<a name="ln38">static void _ioppr_move_iop_after(GList **_iop_order_list, const char *op_current, const char *op_prev, const int dont_move);</a>
<a name="ln39">static void _ioppr_move_iop_before(GList **_iop_order_list, const char *op_current, const char *op_next, const int dont_move);</a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">/* migrates *_iop_order_list from old_version to the next version (version + 1)</a>
<a name="ln43"> * limitations:</a>
<a name="ln44"> * - to move an existing module that is always enabled a new version must be created, otherwise</a>
<a name="ln45"> *   modules can be added/moved in the current version</a>
<a name="ln46"> * - a module can't be more than once on the same version</a>
<a name="ln47"> */</a>
<a name="ln48">static int _ioppr_legacy_iop_order_step(GList **_iop_order_list, GList *history_list, const int old_version, const int dont_move)</a>
<a name="ln49">{</a>
<a name="ln50">  int new_version = -1;</a>
<a name="ln51"> </a>
<a name="ln52">  if(0) // I left this for now so I don't get the unused error, we'll add some modules soon and we'll remove it</a>
<a name="ln53">  {</a>
<a name="ln54">    _ioppr_insert_iop_before(_iop_order_list, history_list, &quot;dummy1&quot;, &quot;colorin&quot;, dont_move);</a>
<a name="ln55">  }</a>
<a name="ln56"> </a>
<a name="ln57">  // version 1 --&gt; 2</a>
<a name="ln58">  if(old_version == 1)</a>
<a name="ln59">  {</a>
<a name="ln60">    _ioppr_move_iop_after(_iop_order_list, &quot;colorin&quot;, &quot;demosaic&quot;, dont_move);</a>
<a name="ln61">    _ioppr_move_iop_before(_iop_order_list, &quot;colorout&quot;, &quot;clahe&quot;, dont_move);</a>
<a name="ln62">    _ioppr_insert_iop_after(_iop_order_list, history_list, &quot;basicadj&quot;, &quot;colorin&quot;, dont_move);</a>
<a name="ln63">    _ioppr_insert_iop_after(_iop_order_list, history_list, &quot;rgbcurve&quot;, &quot;levels&quot;, dont_move);</a>
<a name="ln64">    _ioppr_insert_iop_after(_iop_order_list, history_list, &quot;lut3d&quot;, &quot;grain&quot;, dont_move);</a>
<a name="ln65"> </a>
<a name="ln66">    new_version = 2;</a>
<a name="ln67">  }</a>
<a name="ln68"> </a>
<a name="ln69">  if(new_version &lt;= 0)</a>
<a name="ln70">    fprintf(stderr, &quot;[_ioppr_legacy_iop_order_step] missing step migrating from version %i\n&quot;, old_version);</a>
<a name="ln71"> </a>
<a name="ln72">  return new_version;</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">// returns a list of dt_iop_order_rule_t</a>
<a name="ln76">// this do not have versions</a>
<a name="ln77">GList *dt_ioppr_get_iop_order_rules()</a>
<a name="ln78">{</a>
<a name="ln79">  GList *rules = NULL;</a>
<a name="ln80"> </a>
<a name="ln81">  const dt_iop_order_rule_t rule_entry[] = { { &quot;rawprepare&quot;, &quot;invert&quot; },</a>
<a name="ln82">                                                { &quot;invert&quot;, &quot;temperature&quot; },</a>
<a name="ln83">                                                { &quot;temperature&quot;, &quot;highlights&quot; },</a>
<a name="ln84">                                                { &quot;highlights&quot;, &quot;cacorrect&quot; },</a>
<a name="ln85">                                                { &quot;cacorrect&quot;, &quot;hotpixels&quot; },</a>
<a name="ln86">                                                { &quot;hotpixels&quot;, &quot;rawdenoise&quot; },</a>
<a name="ln87">                                                { &quot;rawdenoise&quot;, &quot;demosaic&quot; },</a>
<a name="ln88">                                                { &quot;demosaic&quot;, &quot;colorin&quot; },</a>
<a name="ln89">                                                { &quot;colorin&quot;, &quot;colorout&quot; },</a>
<a name="ln90">                                                { &quot;colorout&quot;, &quot;gamma&quot; },</a>
<a name="ln91">                                                { &quot;\0&quot;, &quot;\0&quot; } };</a>
<a name="ln92"> </a>
<a name="ln93">  int i = 0;</a>
<a name="ln94">  while(rule_entry[i].op_prev[0])</a>
<a name="ln95">  {</a>
<a name="ln96">    dt_iop_order_rule_t *rule = calloc(1, sizeof(dt_iop_order_rule_t));</a>
<a name="ln97"> </a>
<a name="ln98">    snprintf(rule-&gt;op_prev, sizeof(rule-&gt;op_prev), &quot;%s&quot;, rule_entry[i].op_prev);</a>
<a name="ln99">    snprintf(rule-&gt;op_next, sizeof(rule-&gt;op_next), &quot;%s&quot;, rule_entry[i].op_next);</a>
<a name="ln100"> </a>
<a name="ln101">    rules = g_list_append(rules, rule);</a>
<a name="ln102">    i++;</a>
<a name="ln103">  }</a>
<a name="ln104"> </a>
<a name="ln105">  return rules;</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">// first version of iop order, must never be modified</a>
<a name="ln109">// it returns a list with the default iop_order per module, starting at 1.0, increment by 1.0</a>
<a name="ln110">static GList *_ioppr_get_iop_order_v1()</a>
<a name="ln111">{</a>
<a name="ln112">  GList *iop_order_list = NULL;</a>
<a name="ln113"> </a>
<a name="ln114">  const dt_iop_order_entry_t prior_entry[] = { { 0.0, &quot;rawprepare&quot; },</a>
<a name="ln115">                                                  { 0.0, &quot;invert&quot; },</a>
<a name="ln116">                                                  { 0.0, &quot;temperature&quot; },</a>
<a name="ln117">                                                  { 0.0, &quot;highlights&quot; },</a>
<a name="ln118">                                                  { 0.0, &quot;cacorrect&quot; },</a>
<a name="ln119">                                                  { 0.0, &quot;hotpixels&quot; },</a>
<a name="ln120">                                                  { 0.0, &quot;rawdenoise&quot; },</a>
<a name="ln121">                                                  { 0.0, &quot;demosaic&quot; },</a>
<a name="ln122">                                                  { 0.0, &quot;mask_manager&quot; },</a>
<a name="ln123">                                                  { 0.0, &quot;denoiseprofile&quot; },</a>
<a name="ln124">                                                  { 0.0, &quot;tonemap&quot; },</a>
<a name="ln125">                                                  { 0.0, &quot;exposure&quot; },</a>
<a name="ln126">                                                  { 0.0, &quot;spots&quot; },</a>
<a name="ln127">                                                  { 0.0, &quot;retouch&quot; },</a>
<a name="ln128">                                                  { 0.0, &quot;lens&quot; },</a>
<a name="ln129">                                                  { 0.0, &quot;ashift&quot; },</a>
<a name="ln130">                                                  { 0.0, &quot;liquify&quot; },</a>
<a name="ln131">                                                  { 0.0, &quot;rotatepixels&quot; },</a>
<a name="ln132">                                                  { 0.0, &quot;scalepixels&quot; },</a>
<a name="ln133">                                                  { 0.0, &quot;flip&quot; },</a>
<a name="ln134">                                                  { 0.0, &quot;clipping&quot; },</a>
<a name="ln135">                                                  { 0.0, &quot;graduatednd&quot; },</a>
<a name="ln136">                                                  { 0.0, &quot;basecurve&quot; },</a>
<a name="ln137">                                                  { 0.0, &quot;bilateral&quot; },</a>
<a name="ln138">                                                  { 0.0, &quot;profile_gamma&quot; },</a>
<a name="ln139">                                                  { 0.0, &quot;hazeremoval&quot; },</a>
<a name="ln140">                                                  { 0.0, &quot;colorin&quot; },</a>
<a name="ln141">                                                  { 0.0, &quot;colorreconstruct&quot; },</a>
<a name="ln142">                                                  { 0.0, &quot;colorchecker&quot; },</a>
<a name="ln143">                                                  { 0.0, &quot;defringe&quot; },</a>
<a name="ln144">                                                  { 0.0, &quot;equalizer&quot; },</a>
<a name="ln145">                                                  { 0.0, &quot;vibrance&quot; },</a>
<a name="ln146">                                                  { 0.0, &quot;colorbalance&quot; },</a>
<a name="ln147">                                                  { 0.0, &quot;colorize&quot; },</a>
<a name="ln148">                                                  { 0.0, &quot;colortransfer&quot; },</a>
<a name="ln149">                                                  { 0.0, &quot;colormapping&quot; },</a>
<a name="ln150">                                                  { 0.0, &quot;bloom&quot; },</a>
<a name="ln151">                                                  { 0.0, &quot;nlmeans&quot; },</a>
<a name="ln152">                                                  { 0.0, &quot;globaltonemap&quot; },</a>
<a name="ln153">                                                  { 0.0, &quot;shadhi&quot; },</a>
<a name="ln154">                                                  { 0.0, &quot;atrous&quot; },</a>
<a name="ln155">                                                  { 0.0, &quot;bilat&quot; },</a>
<a name="ln156">                                                  { 0.0, &quot;colorzones&quot; },</a>
<a name="ln157">                                                  { 0.0, &quot;lowlight&quot; },</a>
<a name="ln158">                                                  { 0.0, &quot;monochrome&quot; },</a>
<a name="ln159">                                                  { 0.0, &quot;filmic&quot; },</a>
<a name="ln160">                                                  { 0.0, &quot;colisa&quot; },</a>
<a name="ln161">                                                  { 0.0, &quot;zonesystem&quot; },</a>
<a name="ln162">                                                  { 0.0, &quot;tonecurve&quot; },</a>
<a name="ln163">                                                  { 0.0, &quot;levels&quot; },</a>
<a name="ln164">                                                  { 0.0, &quot;relight&quot; },</a>
<a name="ln165">                                                  { 0.0, &quot;colorcorrection&quot; },</a>
<a name="ln166">                                                  { 0.0, &quot;sharpen&quot; },</a>
<a name="ln167">                                                  { 0.0, &quot;lowpass&quot; },</a>
<a name="ln168">                                                  { 0.0, &quot;highpass&quot; },</a>
<a name="ln169">                                                  { 0.0, &quot;grain&quot; },</a>
<a name="ln170">                                                  { 0.0, &quot;colorcontrast&quot; },</a>
<a name="ln171">                                                  { 0.0, &quot;colorout&quot; },</a>
<a name="ln172">                                                  { 0.0, &quot;channelmixer&quot; },</a>
<a name="ln173">                                                  { 0.0, &quot;soften&quot; },</a>
<a name="ln174">                                                  { 0.0, &quot;vignette&quot; },</a>
<a name="ln175">                                                  { 0.0, &quot;splittoning&quot; },</a>
<a name="ln176">                                                  { 0.0, &quot;velvia&quot; },</a>
<a name="ln177">                                                  { 0.0, &quot;clahe&quot; },</a>
<a name="ln178">                                                  { 0.0, &quot;finalscale&quot; },</a>
<a name="ln179">                                                  { 0.0, &quot;overexposed&quot; },</a>
<a name="ln180">                                                  { 0.0, &quot;rawoverexposed&quot; },</a>
<a name="ln181">                                                  { 0.0, &quot;borders&quot; },</a>
<a name="ln182">                                                  { 0.0, &quot;watermark&quot; },</a>
<a name="ln183">                                                  { 0.0, &quot;dither&quot; },</a>
<a name="ln184">                                                  { 0.0, &quot;gamma&quot; },</a>
<a name="ln185">                                                  { 0.0, &quot;\0&quot; }</a>
<a name="ln186">  };</a>
<a name="ln187"> </a>
<a name="ln188">  int i = 0;</a>
<a name="ln189">  while(prior_entry[i].operation[0] != '\0')</a>
<a name="ln190">  {</a>
<a name="ln191">    dt_iop_order_entry_t *order_entry = calloc(1, sizeof(dt_iop_order_entry_t));</a>
<a name="ln192"> </a>
<a name="ln193">    order_entry-&gt;iop_order = (double)(i + 1);</a>
<a name="ln194">    snprintf(order_entry-&gt;operation, sizeof(order_entry-&gt;operation), &quot;%s&quot;, prior_entry[i].operation);</a>
<a name="ln195"> </a>
<a name="ln196">    iop_order_list = g_list_append(iop_order_list, order_entry);</a>
<a name="ln197">    i++;</a>
<a name="ln198">  }</a>
<a name="ln199"> </a>
<a name="ln200">  return iop_order_list;</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">// returns the first iop order entry that matches operation == op_name</a>
<a name="ln204">dt_iop_order_entry_t *dt_ioppr_get_iop_order_entry(GList *iop_order_list, const char *op_name)</a>
<a name="ln205">{</a>
<a name="ln206">  dt_iop_order_entry_t *iop_order_entry = NULL;</a>
<a name="ln207"> </a>
<a name="ln208">  GList *iops_order = g_list_first(iop_order_list);</a>
<a name="ln209">  while(iops_order)</a>
<a name="ln210">  {</a>
<a name="ln211">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln212"> </a>
<a name="ln213">    if(strcmp(order_entry-&gt;operation, op_name) == 0)</a>
<a name="ln214">    {</a>
<a name="ln215">      iop_order_entry = order_entry;</a>
<a name="ln216">      break;</a>
<a name="ln217">    }</a>
<a name="ln218"> </a>
<a name="ln219">    iops_order = g_list_next(iops_order);</a>
<a name="ln220">  }</a>
<a name="ln221"> </a>
<a name="ln222">  return iop_order_entry;</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">// returns the iop_order associated with the iop order entry that matches operation == op_name</a>
<a name="ln226">double dt_ioppr_get_iop_order(GList *iop_order_list, const char *op_name)</a>
<a name="ln227">{</a>
<a name="ln228">  double iop_order = DBL_MAX;</a>
<a name="ln229">  dt_iop_order_entry_t *order_entry = dt_ioppr_get_iop_order_entry(iop_order_list, op_name);</a>
<a name="ln230"> </a>
<a name="ln231">  if(order_entry)</a>
<a name="ln232">    iop_order = order_entry-&gt;iop_order;</a>
<a name="ln233"> </a>
<a name="ln234">  return iop_order;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">// insert op_new before op_next on *_iop_order_list</a>
<a name="ln238">// it sets the iop_order on op_new</a>
<a name="ln239">// if check_history == 1 it check that the generated iop_order do not exists on any module in history</a>
<a name="ln240">static void _ioppr_insert_iop_before(GList **_iop_order_list, GList *history_list, const char *op_new, const char *op_next, const int check_history)</a>
<a name="ln241">{</a>
<a name="ln242">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln243"> </a>
<a name="ln244">  // check that the new operation don't exists on the list</a>
<a name="ln245">  if(dt_ioppr_get_iop_order_entry(iop_order_list, op_new) == NULL)</a>
<a name="ln246">  {</a>
<a name="ln247">    // create a new iop order entry</a>
<a name="ln248">    dt_iop_order_entry_t *iop_order_new = (dt_iop_order_entry_t*)calloc(1, sizeof(dt_iop_order_entry_t));</a>
<a name="ln249">    snprintf(iop_order_new-&gt;operation, sizeof(iop_order_new-&gt;operation), &quot;%s&quot;, op_new);</a>
<a name="ln250"> </a>
<a name="ln251">    // search for the previous one</a>
<a name="ln252">    int position = 0;</a>
<a name="ln253">    int found = 0;</a>
<a name="ln254">    double iop_order_prev = DBL_MAX;</a>
<a name="ln255">    double iop_order_next = DBL_MAX;</a>
<a name="ln256">    GList *iops_order = g_list_first(iop_order_list);</a>
<a name="ln257">    while(iops_order)</a>
<a name="ln258">    {</a>
<a name="ln259">      dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln260">      if(strcmp(order_entry-&gt;operation, op_next) == 0)</a>
<a name="ln261">      {</a>
<a name="ln262">        iop_order_next = order_entry-&gt;iop_order;</a>
<a name="ln263">        found = 1;</a>
<a name="ln264">        break;</a>
<a name="ln265">      }</a>
<a name="ln266">      iop_order_prev = order_entry-&gt;iop_order;</a>
<a name="ln267">      position++;</a>
<a name="ln268"> </a>
<a name="ln269">      iops_order = g_list_next(iops_order);</a>
<a name="ln270">    }</a>
<a name="ln271"> </a>
<a name="ln272">    // now we have to check if there's a module with iop_order between iop_order_prev and iop_order_next</a>
<a name="ln273">    if(found)</a>
<a name="ln274">    {</a>
<a name="ln275">      if(!check_history)</a>
<a name="ln276">      {</a>
<a name="ln277">        GList *history = g_list_first(history_list);</a>
<a name="ln278">        while(history)</a>
<a name="ln279">        {</a>
<a name="ln280">          dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln281"> </a>
<a name="ln282">          if(hist-&gt;iop_order &gt;= iop_order_prev &amp;&amp; hist-&gt;iop_order &lt;= iop_order_next)</a>
<a name="ln283">            iop_order_prev = hist-&gt;iop_order;</a>
<a name="ln284"> </a>
<a name="ln285">          history = g_list_next(history);</a>
<a name="ln286">        }</a>
<a name="ln287">      }</a>
<a name="ln288">    }</a>
<a name="ln289">    else</a>
<a name="ln290">      fprintf(stderr, &quot;[_ioppr_insert_iop_before] module %s don't exists on iop order list\n&quot;, op_next);</a>
<a name="ln291"> </a>
<a name="ln292">    if(found)</a>
<a name="ln293">    {</a>
<a name="ln294">      // set the iop_order</a>
<a name="ln295">      iop_order_new-&gt;iop_order = iop_order_prev + (iop_order_next - iop_order_prev) / 2.0;</a>
<a name="ln296"> </a>
<a name="ln297">      // insert it on the proper order</a>
<a name="ln298">      iop_order_list = g_list_insert(iop_order_list, iop_order_new, position);</a>
<a name="ln299">    }</a>
<a name="ln300">  }</a>
<a name="ln301">  else</a>
<a name="ln302">    fprintf(stderr, &quot;[_ioppr_insert_iop_before] module %s already exists on iop order list\n&quot;, op_new);</a>
<a name="ln303"> </a>
<a name="ln304">  *_iop_order_list = iop_order_list;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">// insert op_new after op_prev on *_iop_order_list</a>
<a name="ln308">// it updates the iop_order on op_new</a>
<a name="ln309">// if check_history == 1 it check that the generated iop_order do not exists on any module in history</a>
<a name="ln310">static void _ioppr_insert_iop_after(GList **_iop_order_list, GList *history_list, const char *op_new, const char *op_prev, const int check_history)</a>
<a name="ln311">{</a>
<a name="ln312">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln313"> </a>
<a name="ln314">  // inserting after op_prev is the same as moving before the very next one after op_prev</a>
<a name="ln315">  dt_iop_order_entry_t *prior_next = NULL;</a>
<a name="ln316">  GList *iops_order = g_list_last(iop_order_list);</a>
<a name="ln317">  while(iops_order)</a>
<a name="ln318">  {</a>
<a name="ln319">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)iops_order-&gt;data;</a>
<a name="ln320">    if(strcmp(order_entry-&gt;operation, op_prev) == 0) break;</a>
<a name="ln321"> </a>
<a name="ln322">    prior_next = order_entry;</a>
<a name="ln323">    iops_order = g_list_previous(iops_order);</a>
<a name="ln324">  }</a>
<a name="ln325">  if(prior_next == NULL)</a>
<a name="ln326">  {</a>
<a name="ln327">    fprintf(</a>
<a name="ln328">        stderr,</a>
<a name="ln329">        &quot;[_ioppr_insert_iop_after] can't find module previous to %s while moving %s after it\n&quot;,</a>
<a name="ln330">        op_prev, op_new);</a>
<a name="ln331">  }</a>
<a name="ln332">  else</a>
<a name="ln333">    _ioppr_insert_iop_before(&amp;iop_order_list, history_list, op_new, prior_next-&gt;operation, check_history);</a>
<a name="ln334"> </a>
<a name="ln335">  *_iop_order_list = iop_order_list;</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338">// moves op_current before op_next by updating the iop_order</a>
<a name="ln339">// only if dont_move == FALSE</a>
<a name="ln340">static void _ioppr_move_iop_before(GList **_iop_order_list, const char *op_current, const char *op_next, const int dont_move)</a>
<a name="ln341">{</a>
<a name="ln342">  if(dont_move) return;</a>
<a name="ln343"> </a>
<a name="ln344">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln345"> </a>
<a name="ln346">  int position = 0;</a>
<a name="ln347">  int found = 0;</a>
<a name="ln348">  dt_iop_order_entry_t *iop_order_prev = NULL;</a>
<a name="ln349">  dt_iop_order_entry_t *iop_order_next = NULL;</a>
<a name="ln350">  dt_iop_order_entry_t *iop_order_current = NULL;</a>
<a name="ln351">  GList *iops_order_current = NULL;</a>
<a name="ln352"> </a>
<a name="ln353">  // search for the current one</a>
<a name="ln354">  GList *iops_order = g_list_first(iop_order_list);</a>
<a name="ln355">  while(iops_order)</a>
<a name="ln356">  {</a>
<a name="ln357">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln358">    if(strcmp(order_entry-&gt;operation, op_current) == 0)</a>
<a name="ln359">    {</a>
<a name="ln360">      iops_order_current = iops_order;</a>
<a name="ln361">      iop_order_current = order_entry;</a>
<a name="ln362">      found = 1;</a>
<a name="ln363">      break;</a>
<a name="ln364">    }</a>
<a name="ln365"> </a>
<a name="ln366">    iops_order = g_list_next(iops_order);</a>
<a name="ln367">  }</a>
<a name="ln368"> </a>
<a name="ln369">  if(found)</a>
<a name="ln370">  {</a>
<a name="ln371">    // remove it from the list</a>
<a name="ln372">    iop_order_list = g_list_remove_link(iop_order_list, iops_order_current);</a>
<a name="ln373">  }</a>
<a name="ln374">  else</a>
<a name="ln375">    fprintf(stderr, &quot;[_ioppr_move_iop_before] current module %s don't exists on iop order list\n&quot;, op_current);</a>
<a name="ln376"> </a>
<a name="ln377">  // search for the previous and next one</a>
<a name="ln378">  if(found)</a>
<a name="ln379">  {</a>
<a name="ln380">    found = 0;</a>
<a name="ln381">    iops_order = g_list_first(iop_order_list);</a>
<a name="ln382">    while(iops_order)</a>
<a name="ln383">    {</a>
<a name="ln384">      dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln385">      if(strcmp(order_entry-&gt;operation, op_next) == 0)</a>
<a name="ln386">      {</a>
<a name="ln387">        iop_order_next = order_entry;</a>
<a name="ln388">        found = 1;</a>
<a name="ln389">        break;</a>
<a name="ln390">      }</a>
<a name="ln391">      iop_order_prev = order_entry;</a>
<a name="ln392">      position++;</a>
<a name="ln393"> </a>
<a name="ln394">      iops_order = g_list_next(iops_order);</a>
<a name="ln395">    }</a>
<a name="ln396">  }</a>
<a name="ln397"> </a>
<a name="ln398">  if(found)</a>
<a name="ln399">  {</a>
<a name="ln400">    // set the iop_order</a>
<a name="ln401">    iop_order_current-&gt;iop_order = iop_order_prev-&gt;iop_order + (iop_order_next-&gt;iop_order - iop_order_prev-&gt;iop_order) / 2.0;</a>
<a name="ln402"> </a>
<a name="ln403">    // insert it on the proper order</a>
<a name="ln404">    iop_order_list = g_list_insert(iop_order_list, iop_order_current, position);</a>
<a name="ln405">  }</a>
<a name="ln406">  else</a>
<a name="ln407">    fprintf(stderr, &quot;[_ioppr_move_iop_before] next module %s don't exists on iop order list\n&quot;, op_next);</a>
<a name="ln408"> </a>
<a name="ln409">  *_iop_order_list = iop_order_list;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">// moves op_current after op_prev by updating the iop_order</a>
<a name="ln413">// only if dont_move == FALSE</a>
<a name="ln414">static void _ioppr_move_iop_after(GList **_iop_order_list, const char *op_current, const char *op_prev, const int dont_move)</a>
<a name="ln415">{</a>
<a name="ln416">  if(dont_move) return;</a>
<a name="ln417"> </a>
<a name="ln418">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln419"> </a>
<a name="ln420">  // moving after op_prev is the same as moving before the very next one after op_prev</a>
<a name="ln421">  dt_iop_order_entry_t *prior_next = NULL;</a>
<a name="ln422">  GList *iops_order = g_list_last(iop_order_list);</a>
<a name="ln423">  while(iops_order)</a>
<a name="ln424">  {</a>
<a name="ln425">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)iops_order-&gt;data;</a>
<a name="ln426">    if(strcmp(order_entry-&gt;operation, op_prev) == 0) break;</a>
<a name="ln427"> </a>
<a name="ln428">    prior_next = order_entry;</a>
<a name="ln429">    iops_order = g_list_previous(iops_order);</a>
<a name="ln430">  }</a>
<a name="ln431">  if(prior_next == NULL)</a>
<a name="ln432">  {</a>
<a name="ln433">    fprintf(</a>
<a name="ln434">        stderr,</a>
<a name="ln435">        &quot;[_ioppr_move_iop_after] can't find module previous to %s while moving %s after it\n&quot;,</a>
<a name="ln436">        op_prev, op_current);</a>
<a name="ln437">  }</a>
<a name="ln438">  else</a>
<a name="ln439">    _ioppr_move_iop_before(&amp;iop_order_list, op_current, prior_next-&gt;operation, dont_move);</a>
<a name="ln440"> </a>
<a name="ln441">  *_iop_order_list = iop_order_list;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">// returns a list of dt_iop_order_entry_t</a>
<a name="ln445">// if *_version == 0 it returns the current version and updates *_version</a>
<a name="ln446">GList *dt_ioppr_get_iop_order_list(int *_version)</a>
<a name="ln447">{</a>
<a name="ln448">  GList *iop_order_list = _ioppr_get_iop_order_v1();</a>
<a name="ln449">  int old_version = 1;</a>
<a name="ln450">  const int version = ((_version == NULL) || (*_version == 0)) ? DT_IOP_ORDER_VERSION: *_version;</a>
<a name="ln451"> </a>
<a name="ln452">  while(old_version &lt; version &amp;&amp; old_version &gt; 0)</a>
<a name="ln453">  {</a>
<a name="ln454">    old_version = _ioppr_legacy_iop_order_step(&amp;iop_order_list, NULL, old_version, FALSE);</a>
<a name="ln455">  }</a>
<a name="ln456"> </a>
<a name="ln457">  if(old_version != version)</a>
<a name="ln458">  {</a>
<a name="ln459">    fprintf(stderr, &quot;[dt_ioppr_get_iop_order_list] error building iop_order_list to version %i\n&quot;, version);</a>
<a name="ln460">  }</a>
<a name="ln461"> </a>
<a name="ln462">  if(_version &amp;&amp; *_version == 0 &amp;&amp; old_version &gt; 0) *_version = old_version;</a>
<a name="ln463"> </a>
<a name="ln464">  return iop_order_list;</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">// sets the iop_order on each module of *_iop_list</a>
<a name="ln468">// iop_order is set only for base modules, multi-instances will be flagged as unused with DBL_MAX</a>
<a name="ln469">// if a module do not exists on iop_order_list it is flagged as unused with DBL_MAX</a>
<a name="ln470">void dt_ioppr_set_default_iop_order(GList **_iop_list, GList *iop_order_list)</a>
<a name="ln471">{</a>
<a name="ln472">  GList *iop_list = *_iop_list;</a>
<a name="ln473"> </a>
<a name="ln474">  GList *modules = g_list_first(iop_list);</a>
<a name="ln475">  while(modules)</a>
<a name="ln476">  {</a>
<a name="ln477">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln478"> </a>
<a name="ln479">    if(mod-&gt;multi_priority == 0)</a>
<a name="ln480">    {</a>
<a name="ln481">      mod-&gt;iop_order = dt_ioppr_get_iop_order(iop_order_list, mod-&gt;op);</a>
<a name="ln482">    }</a>
<a name="ln483">    // muti-instances will be set by read history</a>
<a name="ln484">    else</a>
<a name="ln485">    {</a>
<a name="ln486">      mod-&gt;iop_order = DBL_MAX;</a>
<a name="ln487">    }</a>
<a name="ln488"> </a>
<a name="ln489">    modules = g_list_next(modules);</a>
<a name="ln490">  }</a>
<a name="ln491">  // we need to set the right order</a>
<a name="ln492">  iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln493"> </a>
<a name="ln494">  *_iop_list = iop_list;</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497">// returns the first dt_dev_history_item_t on history_list where hist-&gt;module == mod</a>
<a name="ln498">static dt_dev_history_item_t *_ioppr_search_history_by_module(GList *history_list, dt_iop_module_t *mod)</a>
<a name="ln499">{</a>
<a name="ln500">  dt_dev_history_item_t *hist_entry = NULL;</a>
<a name="ln501"> </a>
<a name="ln502">  GList *history = g_list_first(history_list);</a>
<a name="ln503">  while(history)</a>
<a name="ln504">  {</a>
<a name="ln505">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln506"> </a>
<a name="ln507">    if(hist-&gt;module == mod)</a>
<a name="ln508">    {</a>
<a name="ln509">      hist_entry = hist;</a>
<a name="ln510">      break;</a>
<a name="ln511">    }</a>
<a name="ln512"> </a>
<a name="ln513">    history = g_list_next(history);</a>
<a name="ln514">  }</a>
<a name="ln515"> </a>
<a name="ln516">  return hist_entry;</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">// check if there's duplicate iop_order entries in iop_list</a>
<a name="ln520">// if so, updates the iop_order to be unique, but only if the module is disabled and not in history</a>
<a name="ln521">void dt_ioppr_check_duplicate_iop_order(GList **_iop_list, GList *history_list)</a>
<a name="ln522">{</a>
<a name="ln523">  GList *iop_list = *_iop_list;</a>
<a name="ln524">  dt_iop_module_t *mod_prev = NULL;</a>
<a name="ln525"> </a>
<a name="ln526">  // get the first module</a>
<a name="ln527">  GList *modules = g_list_first(iop_list);</a>
<a name="ln528">  if(modules)</a>
<a name="ln529">  {</a>
<a name="ln530">    mod_prev = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln531">    modules = g_list_next(modules);</a>
<a name="ln532">  }</a>
<a name="ln533">  // check for each module if iop_order is the same as the previous one</a>
<a name="ln534">  // if so, change it, but only if disabled and not in history</a>
<a name="ln535">  while(modules)</a>
<a name="ln536">  {</a>
<a name="ln537">    int reset_list = 0;</a>
<a name="ln538">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln539"> </a>
<a name="ln540">    if(mod-&gt;iop_order == mod_prev-&gt;iop_order &amp;&amp; mod-&gt;iop_order != DBL_MAX)</a>
<a name="ln541">    {</a>
<a name="ln542">      int can_move = 0;</a>
<a name="ln543"> </a>
<a name="ln544">      if(!mod-&gt;enabled &amp;&amp; _ioppr_search_history_by_module(history_list, mod) == NULL)</a>
<a name="ln545">      {</a>
<a name="ln546">        can_move = 1;</a>
<a name="ln547"> </a>
<a name="ln548">        GList *modules1 = g_list_next(modules);</a>
<a name="ln549">        if(modules1)</a>
<a name="ln550">        {</a>
<a name="ln551">          dt_iop_module_t *mod_next = (dt_iop_module_t *)(modules1-&gt;data);</a>
<a name="ln552">          if(mod-&gt;iop_order != mod_next-&gt;iop_order)</a>
<a name="ln553">          {</a>
<a name="ln554">            mod-&gt;iop_order += (mod_next-&gt;iop_order - mod-&gt;iop_order) / 2.0;</a>
<a name="ln555">          }</a>
<a name="ln556">          else</a>
<a name="ln557">          {</a>
<a name="ln558">            dt_ioppr_check_duplicate_iop_order(&amp;modules, history_list);</a>
<a name="ln559">            reset_list = 1;</a>
<a name="ln560">          }</a>
<a name="ln561">        }</a>
<a name="ln562">        else</a>
<a name="ln563">        {</a>
<a name="ln564">          mod-&gt;iop_order += 1.0;</a>
<a name="ln565">        }</a>
<a name="ln566">      }</a>
<a name="ln567">      else if(!mod_prev-&gt;enabled &amp;&amp; _ioppr_search_history_by_module(history_list, mod_prev) == NULL)</a>
<a name="ln568">      {</a>
<a name="ln569">        can_move = 1;</a>
<a name="ln570"> </a>
<a name="ln571">        GList *modules1 = g_list_previous(modules);</a>
<a name="ln572">        if(modules1) modules1 = g_list_previous(modules1);</a>
<a name="ln573">        if(modules1)</a>
<a name="ln574">        {</a>
<a name="ln575">          dt_iop_module_t *mod_next = (dt_iop_module_t *)(modules1-&gt;data);</a>
<a name="ln576">          if(mod_prev-&gt;iop_order != mod_next-&gt;iop_order)</a>
<a name="ln577">          {</a>
<a name="ln578">            mod_prev-&gt;iop_order -= (mod_prev-&gt;iop_order - mod_next-&gt;iop_order) / 2.0;</a>
<a name="ln579">          }</a>
<a name="ln580">          else</a>
<a name="ln581">          {</a>
<a name="ln582">            can_move = 0;</a>
<a name="ln583">            fprintf(stderr, &quot;[dt_ioppr_check_duplicate_iop_order 1] modules %s %s(%f) and %s %s(%f) has the same iop_order\n&quot;,</a>
<a name="ln584">                mod_prev-&gt;op, mod_prev-&gt;multi_name, mod_prev-&gt;iop_order, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order);</a>
<a name="ln585">          }</a>
<a name="ln586">        }</a>
<a name="ln587">        else</a>
<a name="ln588">        {</a>
<a name="ln589">          mod_prev-&gt;iop_order -= 0.5;</a>
<a name="ln590">        }</a>
<a name="ln591">      }</a>
<a name="ln592"> </a>
<a name="ln593">      if(!can_move)</a>
<a name="ln594">      {</a>
<a name="ln595">        fprintf(stderr, &quot;[dt_ioppr_check_duplicate_iop_order] modules %s %s(%f) and %s %s(%f) has the same iop_order\n&quot;,</a>
<a name="ln596">            mod_prev-&gt;op, mod_prev-&gt;multi_name, mod_prev-&gt;iop_order, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order);</a>
<a name="ln597">      }</a>
<a name="ln598">    }</a>
<a name="ln599"> </a>
<a name="ln600">    if(reset_list)</a>
<a name="ln601">    {</a>
<a name="ln602">      modules = g_list_first(iop_list);</a>
<a name="ln603">      if(modules)</a>
<a name="ln604">      {</a>
<a name="ln605">        mod_prev = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln606">        modules = g_list_next(modules);</a>
<a name="ln607">      }</a>
<a name="ln608">    }</a>
<a name="ln609">    else</a>
<a name="ln610">    {</a>
<a name="ln611">      mod_prev = mod;</a>
<a name="ln612">      modules = g_list_next(modules);</a>
<a name="ln613">    }</a>
<a name="ln614">  }</a>
<a name="ln615"> </a>
<a name="ln616">  *_iop_list = iop_list;</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619">// upgrades iop &amp; iop order to current version</a>
<a name="ln620">void dt_ioppr_legacy_iop_order(GList **_iop_list, GList **_iop_order_list, GList *history_list, const int _old_version)</a>
<a name="ln621">{</a>
<a name="ln622">  GList *iop_list = *_iop_list;</a>
<a name="ln623">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln624">  int dt_version = DT_IOP_ORDER_VERSION;</a>
<a name="ln625">  int old_version = _old_version;</a>
<a name="ln626"> </a>
<a name="ln627">  // we want to add any module created after this version of iop_order</a>
<a name="ln628">  // but we won't move existing modules so only add methods will be executed</a>
<a name="ln629">  while(old_version &lt; dt_version &amp;&amp; old_version &gt; 0)</a>
<a name="ln630">  {</a>
<a name="ln631">    old_version = _ioppr_legacy_iop_order_step(&amp;iop_order_list, history_list, old_version, TRUE);</a>
<a name="ln632">  }</a>
<a name="ln633"> </a>
<a name="ln634">  // now that we have a list of iop_order for version new_version but with all new modules</a>
<a name="ln635">  // we take care of the iop_order of new modules on iop list</a>
<a name="ln636">  GList *modules = g_list_first(iop_list);</a>
<a name="ln637">  while(modules)</a>
<a name="ln638">  {</a>
<a name="ln639">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln640"> </a>
<a name="ln641">    if(mod-&gt;multi_priority == 0 &amp;&amp; mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln642">    {</a>
<a name="ln643">      mod-&gt;iop_order = dt_ioppr_get_iop_order(iop_order_list, mod-&gt;op);</a>
<a name="ln644">      if(mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln645">        fprintf(stderr, &quot;[dt_ioppr_legacy_iop_order] can't find iop_order for module %s\n&quot;, mod-&gt;op);</a>
<a name="ln646">    }</a>
<a name="ln647"> </a>
<a name="ln648">    modules = g_list_next(modules);</a>
<a name="ln649">  }</a>
<a name="ln650">  // we need to set the right order</a>
<a name="ln651">  iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln652"> </a>
<a name="ln653">  // and check for duplicates</a>
<a name="ln654">  dt_ioppr_check_duplicate_iop_order(&amp;iop_list, history_list);</a>
<a name="ln655"> </a>
<a name="ln656">  *_iop_list = iop_list;</a>
<a name="ln657">  *_iop_order_list = iop_order_list;</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660">// check if all so modules on iop_list have a iop_order defined in iop_order_list</a>
<a name="ln661">int dt_ioppr_check_so_iop_order(GList *iop_list, GList *iop_order_list)</a>
<a name="ln662">{</a>
<a name="ln663">  int iop_order_missing = 0;</a>
<a name="ln664"> </a>
<a name="ln665">  // check if all the modules have their iop_order assigned</a>
<a name="ln666">  GList *modules = g_list_first(iop_list);</a>
<a name="ln667">  while(modules)</a>
<a name="ln668">  {</a>
<a name="ln669">    dt_iop_module_so_t *mod = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln670"> </a>
<a name="ln671">    dt_iop_order_entry_t *entry = dt_ioppr_get_iop_order_entry(iop_order_list, mod-&gt;op);</a>
<a name="ln672">    if(entry == NULL)</a>
<a name="ln673">    {</a>
<a name="ln674">      iop_order_missing = 1;</a>
<a name="ln675">      fprintf(stderr, &quot;[dt_ioppr_check_so_iop_order] missing iop_order for module %s\n&quot;, mod-&gt;op);</a>
<a name="ln676">    }</a>
<a name="ln677">    modules = g_list_next(modules);</a>
<a name="ln678">  }</a>
<a name="ln679"> </a>
<a name="ln680">  return iop_order_missing;</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">static void *_dup_iop_order_entry(const void *src, gpointer data)</a>
<a name="ln684">{</a>
<a name="ln685">  dt_iop_order_entry_t *scr_entry = (dt_iop_order_entry_t *)src;</a>
<a name="ln686">  dt_iop_order_entry_t *new_entry = malloc(sizeof(dt_iop_order_entry_t));</a>
<a name="ln687">  memcpy(new_entry, scr_entry, sizeof(dt_iop_order_entry_t));</a>
<a name="ln688">  return (void *)new_entry;</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">// returns a duplicate of iop_order_list</a>
<a name="ln692">GList *dt_ioppr_iop_order_copy_deep(GList *iop_order_list)</a>
<a name="ln693">{</a>
<a name="ln694">  return (GList *)g_list_copy_deep(iop_order_list, _dup_iop_order_entry, NULL);</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">// helper to sort a GList of dt_iop_module_t by iop_order</a>
<a name="ln698">gint dt_sort_iop_by_order(gconstpointer a, gconstpointer b)</a>
<a name="ln699">{</a>
<a name="ln700">  const dt_iop_module_t *am = (const dt_iop_module_t *)a;</a>
<a name="ln701">  const dt_iop_module_t *bm = (const dt_iop_module_t *)b;</a>
<a name="ln702">  if(am-&gt;iop_order &gt; bm-&gt;iop_order) return 1;</a>
<a name="ln703">  if(am-&gt;iop_order &lt; bm-&gt;iop_order) return -1;</a>
<a name="ln704">  return 0;</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707">// if module can be placed before than module_next on the pipe</a>
<a name="ln708">// it returns the new iop_order</a>
<a name="ln709">// if it cannot be placed it returns -1.0</a>
<a name="ln710">// this assums that the order is always positive</a>
<a name="ln711">double dt_ioppr_get_iop_order_before_iop(GList *iop_list, dt_iop_module_t *module, dt_iop_module_t *module_next,</a>
<a name="ln712">                                  const int validate_order, const int log_error)</a>
<a name="ln713">{</a>
<a name="ln714">  if((module-&gt;flags() &amp; IOP_FLAGS_FENCE) &amp;&amp; validate_order)</a>
<a name="ln715">  {</a>
<a name="ln716">    if(log_error)</a>
<a name="ln717">      fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] module %s(%f) is a fence, can't move it before %s %s(%f)\n&quot;,</a>
<a name="ln718">          module-&gt;op, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln719">    return -1.0;</a>
<a name="ln720">  }</a>
<a name="ln721"> </a>
<a name="ln722">  double iop_order = -1.0;</a>
<a name="ln723"> </a>
<a name="ln724">  // module is before on the pipe</a>
<a name="ln725">  // move it up</a>
<a name="ln726">  if(module-&gt;iop_order &lt; module_next-&gt;iop_order)</a>
<a name="ln727">  {</a>
<a name="ln728">    // let's first search for module</a>
<a name="ln729">    GList *modules = g_list_first(iop_list);</a>
<a name="ln730">    while(modules)</a>
<a name="ln731">    {</a>
<a name="ln732">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln733">      if(mod == module) break;</a>
<a name="ln734">      modules = g_list_next(modules);</a>
<a name="ln735">    }</a>
<a name="ln736"> </a>
<a name="ln737">    // we found the module</a>
<a name="ln738">    if(modules)</a>
<a name="ln739">    {</a>
<a name="ln740">      dt_iop_module_t *mod1 = NULL;</a>
<a name="ln741">      dt_iop_module_t *mod2 = NULL;</a>
<a name="ln742"> </a>
<a name="ln743">      // now search for module_next and the one previous to that, so iop_order can be calculated</a>
<a name="ln744">      // also check the rules</a>
<a name="ln745">      modules = g_list_next(modules);</a>
<a name="ln746">      while(modules)</a>
<a name="ln747">      {</a>
<a name="ln748">        dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln749"> </a>
<a name="ln750">        // if we reach module_next everithing is OK</a>
<a name="ln751">        if(mod == module_next)</a>
<a name="ln752">        {</a>
<a name="ln753">          mod2 = mod;</a>
<a name="ln754">          break;</a>
<a name="ln755">        }</a>
<a name="ln756"> </a>
<a name="ln757">        // check for rules</a>
<a name="ln758">        if(validate_order)</a>
<a name="ln759">        {</a>
<a name="ln760">          // check if module can be moved around this one</a>
<a name="ln761">          if(mod-&gt;flags() &amp; IOP_FLAGS_FENCE)</a>
<a name="ln762">          {</a>
<a name="ln763">            if(log_error)</a>
<a name="ln764">              fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] can't move %s %s(%f) pass %s %s(%f)\n&quot;,</a>
<a name="ln765">                  module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order);</a>
<a name="ln766">            break;</a>
<a name="ln767">          }</a>
<a name="ln768"> </a>
<a name="ln769">          // is there a rule about swapping this two?</a>
<a name="ln770">          int rule_found = 0;</a>
<a name="ln771">          GList *rules = g_list_first(darktable.iop_order_rules);</a>
<a name="ln772">          while(rules)</a>
<a name="ln773">          {</a>
<a name="ln774">            dt_iop_order_rule_t *rule = (dt_iop_order_rule_t *)rules-&gt;data;</a>
<a name="ln775"> </a>
<a name="ln776">            if(strcmp(module-&gt;op, rule-&gt;op_prev) == 0 &amp;&amp; strcmp(mod-&gt;op, rule-&gt;op_next) == 0)</a>
<a name="ln777">            {</a>
<a name="ln778">              if(log_error)</a>
<a name="ln779">                fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] found rule %s %s while moving %s %s(%f) before %s %s(%f)\n&quot;,</a>
<a name="ln780">                        rule-&gt;op_prev, rule-&gt;op_next, module-&gt;op,  module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op,  module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln781">              rule_found = 1;</a>
<a name="ln782">              break;</a>
<a name="ln783">            }</a>
<a name="ln784"> </a>
<a name="ln785">            rules = g_list_next(rules);</a>
<a name="ln786">          }</a>
<a name="ln787">          if(rule_found) break;</a>
<a name="ln788">        }</a>
<a name="ln789"> </a>
<a name="ln790">        mod1 = mod;</a>
<a name="ln791">        modules = g_list_next(modules);</a>
<a name="ln792">      }</a>
<a name="ln793"> </a>
<a name="ln794">      // we reach the module_next module</a>
<a name="ln795">      if(mod2)</a>
<a name="ln796">      {</a>
<a name="ln797">        // this is already the previous module!</a>
<a name="ln798">        if(module == mod1)</a>
<a name="ln799">        {</a>
<a name="ln800">          if(log_error)</a>
<a name="ln801">            fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] %s %s(%f) is already previous to %s %s(%f)\n&quot;,</a>
<a name="ln802">                module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln803">        }</a>
<a name="ln804">        else if(mod1-&gt;iop_order == mod2-&gt;iop_order)</a>
<a name="ln805">        {</a>
<a name="ln806">          fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] %s %s(%f) and %s %s(%f) has the same iop_order\n&quot;,</a>
<a name="ln807">              mod1-&gt;op, mod1-&gt;multi_name, mod1-&gt;iop_order, mod2-&gt;op, mod2-&gt;multi_name, mod2-&gt;iop_order);</a>
<a name="ln808">        }</a>
<a name="ln809">        else</a>
<a name="ln810">        {</a>
<a name="ln811">          // calculate new iop_order</a>
<a name="ln812">          iop_order = mod1-&gt;iop_order + (mod2-&gt;iop_order - mod1-&gt;iop_order) / 2.0;</a>
<a name="ln813">          /* fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] 2-calculated new iop_order=%f for %s(%f) between %s(%f) and %s(%f)\n&quot;,</a>
<a name="ln814">                 iop_order, module-&gt;op, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;iop_order, mod-&gt;op, mod-&gt;iop_order); */</a>
<a name="ln815">        }</a>
<a name="ln816">      }</a>
<a name="ln817">    }</a>
<a name="ln818">    else</a>
<a name="ln819">      fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] can't find module %s %s\n&quot;, module-&gt;op, module-&gt;multi_name);</a>
<a name="ln820">  }</a>
<a name="ln821">  // module is next on the pipe</a>
<a name="ln822">  // move it down</a>
<a name="ln823">  else if(module-&gt;iop_order &gt; module_next-&gt;iop_order)</a>
<a name="ln824">  {</a>
<a name="ln825">    // let's first search for module</a>
<a name="ln826">    GList *modules = g_list_last(iop_list);</a>
<a name="ln827">    while(modules)</a>
<a name="ln828">    {</a>
<a name="ln829">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln830">      if(mod == module) break;</a>
<a name="ln831">      modules = g_list_previous(modules);</a>
<a name="ln832">    }</a>
<a name="ln833"> </a>
<a name="ln834">    // we found the module</a>
<a name="ln835">    if(modules)</a>
<a name="ln836">    {</a>
<a name="ln837">      dt_iop_module_t *mod1 = NULL;</a>
<a name="ln838">      dt_iop_module_t *mod2 = NULL;</a>
<a name="ln839"> </a>
<a name="ln840">      // now search for module_next and the one next to that, so iop_order can be calculated</a>
<a name="ln841">      // also check the rules</a>
<a name="ln842">      modules = g_list_previous(modules);</a>
<a name="ln843">      while(modules)</a>
<a name="ln844">      {</a>
<a name="ln845">        dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln846"> </a>
<a name="ln847">        // we reach the module next to module_next, everithing is OK</a>
<a name="ln848">        if(mod2 != NULL)</a>
<a name="ln849">        {</a>
<a name="ln850">          mod1 = mod;</a>
<a name="ln851">          break;</a>
<a name="ln852">        }</a>
<a name="ln853"> </a>
<a name="ln854">        // check for rules</a>
<a name="ln855">        if(validate_order)</a>
<a name="ln856">        {</a>
<a name="ln857">          // check if module can be moved around this one</a>
<a name="ln858">          if(mod-&gt;flags() &amp; IOP_FLAGS_FENCE)</a>
<a name="ln859">          {</a>
<a name="ln860">            if(log_error)</a>
<a name="ln861">              fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] can't move %s %s(%f) pass %s %s(%f)\n&quot;,</a>
<a name="ln862">                  module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order);</a>
<a name="ln863">            break;</a>
<a name="ln864">          }</a>
<a name="ln865"> </a>
<a name="ln866">          // is there a rule about swapping this two?</a>
<a name="ln867">          int rule_found = 0;</a>
<a name="ln868">          GList *rules = g_list_first(darktable.iop_order_rules);</a>
<a name="ln869">          while(rules)</a>
<a name="ln870">          {</a>
<a name="ln871">            dt_iop_order_rule_t *rule = (dt_iop_order_rule_t *)rules-&gt;data;</a>
<a name="ln872"> </a>
<a name="ln873">            if(strcmp(mod-&gt;op, rule-&gt;op_prev) == 0 &amp;&amp; strcmp(module-&gt;op, rule-&gt;op_next) == 0)</a>
<a name="ln874">            {</a>
<a name="ln875">              if(log_error)</a>
<a name="ln876">                fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] found rule %s %s while moving %s %s(%f) before %s %s(%f)\n&quot;,</a>
<a name="ln877">                        rule-&gt;op_prev, rule-&gt;op_next, module-&gt;op,  module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op,  module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln878">              rule_found = 1;</a>
<a name="ln879">              break;</a>
<a name="ln880">            }</a>
<a name="ln881"> </a>
<a name="ln882">            rules = g_list_next(rules);</a>
<a name="ln883">          }</a>
<a name="ln884">          if(rule_found) break;</a>
<a name="ln885">        }</a>
<a name="ln886"> </a>
<a name="ln887">        if(mod == module_next) mod2 = mod;</a>
<a name="ln888">        modules = g_list_previous(modules);</a>
<a name="ln889">      }</a>
<a name="ln890"> </a>
<a name="ln891">      // we reach the module_next module</a>
<a name="ln892">      if(mod1)</a>
<a name="ln893">      {</a>
<a name="ln894">        // this is already the previous module!</a>
<a name="ln895">        if(module == mod2)</a>
<a name="ln896">        {</a>
<a name="ln897">          if(log_error)</a>
<a name="ln898">            fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] %s %s(%f) is already previous to %s %s(%f)\n&quot;,</a>
<a name="ln899">                module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln900">        }</a>
<a name="ln901">        else if(mod1-&gt;iop_order == mod2-&gt;iop_order)</a>
<a name="ln902">        {</a>
<a name="ln903">          fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] %s %s(%f) and %s %s(%f) has the same iop_order\n&quot;,</a>
<a name="ln904">              mod1-&gt;op, mod1-&gt;multi_name, mod1-&gt;iop_order, mod2-&gt;op, mod2-&gt;multi_name, mod2-&gt;iop_order);</a>
<a name="ln905">        }</a>
<a name="ln906">        else</a>
<a name="ln907">        {</a>
<a name="ln908">          // calculate new iop_order</a>
<a name="ln909">          iop_order = mod1-&gt;iop_order + (mod2-&gt;iop_order - mod1-&gt;iop_order) / 2.0;</a>
<a name="ln910">          /* fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] 2-calculated new iop_order=%f for %s(%f) between %s(%f) and %s(%f)\n&quot;,</a>
<a name="ln911">                 iop_order, module-&gt;op, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;iop_order, mod-&gt;op, mod-&gt;iop_order); */</a>
<a name="ln912">        }</a>
<a name="ln913">      }</a>
<a name="ln914">    }</a>
<a name="ln915">    else</a>
<a name="ln916">      fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] can't find module %s %s\n&quot;, module-&gt;op, module-&gt;multi_name);</a>
<a name="ln917">  }</a>
<a name="ln918">  else</a>
<a name="ln919">  {</a>
<a name="ln920">    fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] modules %s %s(%f) and %s %s(%f) has the same iop_order\n&quot;,</a>
<a name="ln921">        module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln922">  }</a>
<a name="ln923"> </a>
<a name="ln924">  return iop_order;</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927">// if module can be placed after than module_prev on the pipe</a>
<a name="ln928">// it returns the new iop_order</a>
<a name="ln929">// if it cannot be placed it returns -1.0</a>
<a name="ln930">// this assums that the order is always positive</a>
<a name="ln931">double dt_ioppr_get_iop_order_after_iop(GList *iop_list, dt_iop_module_t *module, dt_iop_module_t *module_prev,</a>
<a name="ln932">                                 const int validate_order, const int log_error)</a>
<a name="ln933">{</a>
<a name="ln934">  double iop_order = -1.0;</a>
<a name="ln935"> </a>
<a name="ln936">  // moving after module_prev is the same as moving before the very next one after module_prev</a>
<a name="ln937">  GList *modules = g_list_last(iop_list);</a>
<a name="ln938">  dt_iop_module_t *module_next = NULL;</a>
<a name="ln939">  while(modules)</a>
<a name="ln940">  {</a>
<a name="ln941">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln942">    if(mod == module_prev) break;</a>
<a name="ln943"> </a>
<a name="ln944">    module_next = mod;</a>
<a name="ln945">    modules = g_list_previous(modules);</a>
<a name="ln946">  }</a>
<a name="ln947">  if(module_next == NULL)</a>
<a name="ln948">  {</a>
<a name="ln949">    fprintf(</a>
<a name="ln950">        stderr,</a>
<a name="ln951">        &quot;[dt_ioppr_get_iop_order_after_iop] can't find module previous to %s %s(%f) while moving %s %s(%f) after it\n&quot;,</a>
<a name="ln952">        module_prev-&gt;op, module_prev-&gt;multi_name, module_prev-&gt;iop_order, module-&gt;op, module-&gt;multi_name,</a>
<a name="ln953">        module-&gt;iop_order);</a>
<a name="ln954">  }</a>
<a name="ln955">  else</a>
<a name="ln956">    iop_order = dt_ioppr_get_iop_order_before_iop(iop_list, module, module_next, validate_order, log_error);</a>
<a name="ln957"> </a>
<a name="ln958">  return iop_order;</a>
<a name="ln959">}</a>
<a name="ln960"> </a>
<a name="ln961">// changes the module-&gt;iop_order so it comes before in the pipe than module_next</a>
<a name="ln962">// sort dev-&gt;iop to reflect the changes</a>
<a name="ln963">// return 1 if iop_order is changed, 0 otherwise</a>
<a name="ln964">int dt_ioppr_move_iop_before(GList **_iop_list, dt_iop_module_t *module, dt_iop_module_t *module_next,</a>
<a name="ln965">                       const int validate_order, const int log_error)</a>
<a name="ln966">{</a>
<a name="ln967">  GList *iop_list = *_iop_list;</a>
<a name="ln968">  int moved = 0;</a>
<a name="ln969"> </a>
<a name="ln970">  // dt_ioppr_check_iop_order(dev, &quot;dt_ioppr_move_iop_before begin&quot;);</a>
<a name="ln971"> </a>
<a name="ln972">  const double iop_order = dt_ioppr_get_iop_order_before_iop(iop_list, module, module_next, validate_order, log_error);</a>
<a name="ln973"> </a>
<a name="ln974">  if(iop_order &gt;= 0.0)</a>
<a name="ln975">  {</a>
<a name="ln976">    module-&gt;iop_order = iop_order;</a>
<a name="ln977">    iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln978">    moved = 1;</a>
<a name="ln979">  }</a>
<a name="ln980">  else if(log_error)</a>
<a name="ln981">    fprintf(stderr, &quot;[dt_ioppr_move_iop_before] module %s is already before %s\n&quot;, module-&gt;op, module_next-&gt;op);</a>
<a name="ln982"> </a>
<a name="ln983">  // dt_ioppr_check_iop_order(dev, &quot;dt_ioppr_move_iop_before end&quot;);</a>
<a name="ln984"> </a>
<a name="ln985">  *_iop_list = iop_list;</a>
<a name="ln986"> </a>
<a name="ln987">  return moved;</a>
<a name="ln988">}</a>
<a name="ln989"> </a>
<a name="ln990">// changes the module-&gt;iop_order so it comes after in the pipe than module_prev</a>
<a name="ln991">// sort dev-&gt;iop to reflect the changes</a>
<a name="ln992">// return 1 if iop_order is changed, 0 otherwise</a>
<a name="ln993">int dt_ioppr_move_iop_after(GList **_iop_list, dt_iop_module_t *module, dt_iop_module_t *module_prev,</a>
<a name="ln994">                      const int validate_order, const int log_error)</a>
<a name="ln995">{</a>
<a name="ln996">  GList *iop_list = *_iop_list;</a>
<a name="ln997">  int moved = 0;</a>
<a name="ln998"> </a>
<a name="ln999">  // dt_ioppr_check_iop_order(dev, &quot;dt_ioppr_move_iop_after begin&quot;);</a>
<a name="ln1000"> </a>
<a name="ln1001">  const double iop_order = dt_ioppr_get_iop_order_after_iop(iop_list, module, module_prev, validate_order, log_error);</a>
<a name="ln1002">  if(iop_order &gt;= 0.0)</a>
<a name="ln1003">  {</a>
<a name="ln1004">    module-&gt;iop_order = iop_order;</a>
<a name="ln1005">    iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln1006">    moved = 1;</a>
<a name="ln1007">  }</a>
<a name="ln1008">  else if(log_error)</a>
<a name="ln1009">    fprintf(stderr, &quot;[dt_ioppr_move_iop_after] module %s is already after %s\n&quot;, module-&gt;op, module_prev-&gt;op);</a>
<a name="ln1010"> </a>
<a name="ln1011">  // dt_ioppr_check_iop_order(dev, &quot;dt_ioppr_move_iop_after end&quot;);</a>
<a name="ln1012"> </a>
<a name="ln1013">  *_iop_list = iop_list;</a>
<a name="ln1014"> </a>
<a name="ln1015">  return moved;</a>
<a name="ln1016">}</a>
<a name="ln1017"> </a>
<a name="ln1018">//--------------------------------------------------------------------</a>
<a name="ln1019">// from here just for debug</a>
<a name="ln1020">//--------------------------------------------------------------------</a>
<a name="ln1021">int dt_ioppr_check_db_integrity()</a>
<a name="ln1022">{</a>
<a name="ln1023">  int ret = 0;</a>
<a name="ln1024">  sqlite3_stmt *stmt;</a>
<a name="ln1025"> </a>
<a name="ln1026">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid, operation, module FROM main.history WHERE iop_order &lt;= 0 OR iop_order IS NULL&quot;,</a>
<a name="ln1027">                              -1, &amp;stmt, NULL);</a>
<a name="ln1028">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1029">  {</a>
<a name="ln1030">    ret = 1;</a>
<a name="ln1031">    fprintf(stderr, &quot;\nThere are unassigned iop_order in the history!!!\n\n&quot;);</a>
<a name="ln1032"> </a>
<a name="ln1033">    int count = 0;</a>
<a name="ln1034">    do</a>
<a name="ln1035">    {</a>
<a name="ln1036">      const int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1037">      const char *opname = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln1038">      const int modversion = sqlite3_column_int(stmt, 2);</a>
<a name="ln1039"> </a>
<a name="ln1040">      fprintf(stderr, &quot;image: %i module: %s version: %i\n&quot;, imgid, (opname) ? opname: &quot;module is NULL&quot;, modversion);</a>
<a name="ln1041">    } while(sqlite3_step(stmt) == SQLITE_ROW &amp;&amp; count++ &lt; 20);</a>
<a name="ln1042">  }</a>
<a name="ln1043"> </a>
<a name="ln1044">  sqlite3_finalize(stmt);</a>
<a name="ln1045"> </a>
<a name="ln1046">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT styleid, operation FROM data.style_items WHERE iop_order &lt;= 0 OR iop_order IS NULL&quot;,</a>
<a name="ln1047">                              -1, &amp;stmt, NULL);</a>
<a name="ln1048">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1049">  {</a>
<a name="ln1050">    ret = 1;</a>
<a name="ln1051">    fprintf(stderr, &quot;\nThere are unassigned iop_order in the styles!!!\n\n&quot;);</a>
<a name="ln1052"> </a>
<a name="ln1053">    int count = 0;</a>
<a name="ln1054">    do</a>
<a name="ln1055">    {</a>
<a name="ln1056">      const int styleid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1057">      const char *opname = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln1058"> </a>
<a name="ln1059">      fprintf(stderr, &quot;style: %i module: %s\n&quot;, styleid, (opname) ? opname: &quot;module is NULL&quot;);</a>
<a name="ln1060">    } while(sqlite3_step(stmt) == SQLITE_ROW &amp;&amp; count++ &lt; 20);</a>
<a name="ln1061">  }</a>
<a name="ln1062"> </a>
<a name="ln1063">  sqlite3_finalize(stmt);</a>
<a name="ln1064"> </a>
<a name="ln1065">  return ret;</a>
<a name="ln1066">}</a>
<a name="ln1067"> </a>
<a name="ln1068">void dt_ioppr_print_module_iop_order(GList *iop_list, const char *msg)</a>
<a name="ln1069">{</a>
<a name="ln1070">  GList *modules = g_list_first(iop_list);</a>
<a name="ln1071">  while(modules)</a>
<a name="ln1072">  {</a>
<a name="ln1073">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln1074"> </a>
<a name="ln1075">    fprintf(stderr, &quot;[%s] module %s %s multi_priority=%i, iop_order=%f\n&quot;, msg, mod-&gt;op, mod-&gt;multi_name, mod-&gt;multi_priority, mod-&gt;iop_order);</a>
<a name="ln1076"> </a>
<a name="ln1077">    modules = g_list_next(modules);</a>
<a name="ln1078">  }</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">void dt_ioppr_print_history_iop_order(GList *history_list, const char *msg)</a>
<a name="ln1082">{</a>
<a name="ln1083">  GList *history = g_list_first(history_list);</a>
<a name="ln1084">  while(history)</a>
<a name="ln1085">  {</a>
<a name="ln1086">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln1087"> </a>
<a name="ln1088">    fprintf(stderr, &quot;[%s] module %s %s multi_priority=%i, iop_order=%f\n&quot;, msg, hist-&gt;op_name, hist-&gt;multi_name, hist-&gt;multi_priority, hist-&gt;iop_order);</a>
<a name="ln1089"> </a>
<a name="ln1090">    history = g_list_next(history);</a>
<a name="ln1091">  }</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">void dt_ioppr_print_iop_order(GList *iop_order_list, const char *msg)</a>
<a name="ln1095">{</a>
<a name="ln1096">  GList *iops_order = g_list_first(iop_order_list);</a>
<a name="ln1097">  while(iops_order)</a>
<a name="ln1098">  {</a>
<a name="ln1099">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln1100"> </a>
<a name="ln1101">    fprintf(stderr, &quot;[%s] operation %s iop_order=%f\n&quot;, msg, order_entry-&gt;operation, order_entry-&gt;iop_order);</a>
<a name="ln1102"> </a>
<a name="ln1103">    iops_order = g_list_next(iops_order);</a>
<a name="ln1104">  }</a>
<a name="ln1105">}</a>
<a name="ln1106"> </a>
<a name="ln1107">static GList *_get_fence_modules_list(GList *iop_list)</a>
<a name="ln1108">{</a>
<a name="ln1109">  GList *fences = NULL;</a>
<a name="ln1110">  GList *modules = g_list_first(iop_list);</a>
<a name="ln1111">  while(modules)</a>
<a name="ln1112">  {</a>
<a name="ln1113">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1114"> </a>
<a name="ln1115">    if(mod-&gt;flags() &amp; IOP_FLAGS_FENCE)</a>
<a name="ln1116">    {</a>
<a name="ln1117">      fences = g_list_append(fences, mod);</a>
<a name="ln1118">    }</a>
<a name="ln1119"> </a>
<a name="ln1120">    modules = g_list_next(modules);</a>
<a name="ln1121">  }</a>
<a name="ln1122">  return fences;</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125">static void _ioppr_check_rules(GList *iop_list, const int imgid, const char *msg)</a>
<a name="ln1126">{</a>
<a name="ln1127">  GList *modules = NULL;</a>
<a name="ln1128"> </a>
<a name="ln1129">  // check for IOP_FLAGS_FENCE on each module</a>
<a name="ln1130">  // create a list of fences modules</a>
<a name="ln1131">  GList *fences = _get_fence_modules_list(iop_list);</a>
<a name="ln1132"> </a>
<a name="ln1133">  // check if each module is between the fences</a>
<a name="ln1134">  modules = g_list_first(iop_list);</a>
<a name="ln1135">  while(modules)</a>
<a name="ln1136">  {</a>
<a name="ln1137">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1138">    if(mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln1139">    {</a>
<a name="ln1140">      modules = g_list_next(modules);</a>
<a name="ln1141">      continue;</a>
<a name="ln1142">    }</a>
<a name="ln1143"> </a>
<a name="ln1144">    dt_iop_module_t *fence_prev = NULL;</a>
<a name="ln1145">    dt_iop_module_t *fence_next = NULL;</a>
<a name="ln1146"> </a>
<a name="ln1147">    GList *mod_fences = g_list_first(fences);</a>
<a name="ln1148">    while(mod_fences)</a>
<a name="ln1149">    {</a>
<a name="ln1150">      dt_iop_module_t *mod_fence = (dt_iop_module_t *)mod_fences-&gt;data;</a>
<a name="ln1151"> </a>
<a name="ln1152">      // mod should be before this fence</a>
<a name="ln1153">      if(mod-&gt;iop_order &lt; mod_fence-&gt;iop_order)</a>
<a name="ln1154">      {</a>
<a name="ln1155">        if(fence_next == NULL)</a>
<a name="ln1156">          fence_next = mod_fence;</a>
<a name="ln1157">        else if(mod_fence-&gt;iop_order &lt; fence_next-&gt;iop_order)</a>
<a name="ln1158">          fence_next = mod_fence;</a>
<a name="ln1159">      }</a>
<a name="ln1160">      // mod should be after this fence</a>
<a name="ln1161">      else if(mod-&gt;iop_order &gt; mod_fence-&gt;iop_order)</a>
<a name="ln1162">      {</a>
<a name="ln1163">        if(fence_prev == NULL)</a>
<a name="ln1164">          fence_prev = mod_fence;</a>
<a name="ln1165">        else if(mod_fence-&gt;iop_order &gt; fence_prev-&gt;iop_order)</a>
<a name="ln1166">          fence_prev = mod_fence;</a>
<a name="ln1167">      }</a>
<a name="ln1168"> </a>
<a name="ln1169">      mod_fences = g_list_next(mod_fences);</a>
<a name="ln1170">    }</a>
<a name="ln1171"> </a>
<a name="ln1172">    // now check if mod is between the fences</a>
<a name="ln1173">    if(fence_next &amp;&amp; mod-&gt;iop_order &gt; fence_next-&gt;iop_order)</a>
<a name="ln1174">    {</a>
<a name="ln1175">      fprintf(stderr, &quot;[_ioppr_check_rules] found fence %s %s module %s %s(%f) is after %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1176">              fence_next-&gt;op, fence_next-&gt;multi_name, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, fence_next-&gt;op,</a>
<a name="ln1177">              fence_next-&gt;multi_name, fence_next-&gt;iop_order, imgid, msg);</a>
<a name="ln1178">    }</a>
<a name="ln1179">    if(fence_prev &amp;&amp; mod-&gt;iop_order &lt; fence_prev-&gt;iop_order)</a>
<a name="ln1180">    {</a>
<a name="ln1181">      fprintf(stderr, &quot;[_ioppr_check_rules] found fence %s %s module %s %s(%f) is before %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1182">              fence_prev-&gt;op, fence_prev-&gt;multi_name, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, fence_prev-&gt;op,</a>
<a name="ln1183">              fence_prev-&gt;multi_name, fence_prev-&gt;iop_order, imgid, msg);</a>
<a name="ln1184">    }</a>
<a name="ln1185"> </a>
<a name="ln1186"> </a>
<a name="ln1187">    modules = g_list_next(modules);</a>
<a name="ln1188">  }</a>
<a name="ln1189"> </a>
<a name="ln1190">  // for each module check if it doesn't break a rule</a>
<a name="ln1191">  modules = g_list_first(iop_list);</a>
<a name="ln1192">  while(modules)</a>
<a name="ln1193">  {</a>
<a name="ln1194">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1195">    if(mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln1196">    {</a>
<a name="ln1197">      modules = g_list_next(modules);</a>
<a name="ln1198">      continue;</a>
<a name="ln1199">    }</a>
<a name="ln1200"> </a>
<a name="ln1201">    // we have a module, now check each rule</a>
<a name="ln1202">    GList *rules = g_list_first(darktable.iop_order_rules);</a>
<a name="ln1203">    while(rules)</a>
<a name="ln1204">    {</a>
<a name="ln1205">      dt_iop_order_rule_t *rule = (dt_iop_order_rule_t *)rules-&gt;data;</a>
<a name="ln1206"> </a>
<a name="ln1207">      // mod must be before rule-&gt;op_next</a>
<a name="ln1208">      if(strcmp(mod-&gt;op, rule-&gt;op_prev) == 0)</a>
<a name="ln1209">      {</a>
<a name="ln1210">        // check if there's a rule-&gt;op_next module before mod</a>
<a name="ln1211">        GList *modules_prev = g_list_previous(modules);</a>
<a name="ln1212">        while(modules_prev)</a>
<a name="ln1213">        {</a>
<a name="ln1214">          dt_iop_module_t *mod_prev = (dt_iop_module_t *)modules_prev-&gt;data;</a>
<a name="ln1215"> </a>
<a name="ln1216">          if(strcmp(mod_prev-&gt;op, rule-&gt;op_next) == 0)</a>
<a name="ln1217">          {</a>
<a name="ln1218">            fprintf(stderr, &quot;[_ioppr_check_rules] found rule %s %s module %s %s(%f) is after %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1219">                    rule-&gt;op_prev, rule-&gt;op_next, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, mod_prev-&gt;op,</a>
<a name="ln1220">                    mod_prev-&gt;multi_name, mod_prev-&gt;iop_order, imgid, msg);</a>
<a name="ln1221">          }</a>
<a name="ln1222"> </a>
<a name="ln1223">          modules_prev = g_list_previous(modules_prev);</a>
<a name="ln1224">        }</a>
<a name="ln1225">      }</a>
<a name="ln1226">      // mod must be after rule-&gt;op_prev</a>
<a name="ln1227">      else if(strcmp(mod-&gt;op, rule-&gt;op_next) == 0)</a>
<a name="ln1228">      {</a>
<a name="ln1229">        // check if there's a rule-&gt;op_prev module after mod</a>
<a name="ln1230">        GList *modules_next = g_list_next(modules);</a>
<a name="ln1231">        while(modules_next)</a>
<a name="ln1232">        {</a>
<a name="ln1233">          dt_iop_module_t *mod_next = (dt_iop_module_t *)modules_next-&gt;data;</a>
<a name="ln1234"> </a>
<a name="ln1235">          if(strcmp(mod_next-&gt;op, rule-&gt;op_prev) == 0)</a>
<a name="ln1236">          {</a>
<a name="ln1237">            fprintf(stderr, &quot;[_ioppr_check_rules] found rule %s %s module %s %s(%f) is before %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1238">                    rule-&gt;op_prev, rule-&gt;op_next, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, mod_next-&gt;op,</a>
<a name="ln1239">                    mod_next-&gt;multi_name, mod_next-&gt;iop_order, imgid, msg);</a>
<a name="ln1240">          }</a>
<a name="ln1241"> </a>
<a name="ln1242">          modules_next = g_list_next(modules_next);</a>
<a name="ln1243">        }</a>
<a name="ln1244">      }</a>
<a name="ln1245"> </a>
<a name="ln1246">      rules = g_list_next(rules);</a>
<a name="ln1247">    }</a>
<a name="ln1248"> </a>
<a name="ln1249">    modules = g_list_next(modules);</a>
<a name="ln1250">  }</a>
<a name="ln1251"> </a>
<a name="ln1252">  if(fences) g_list_free(fences);</a>
<a name="ln1253">}</a>
<a name="ln1254"> </a>
<a name="ln1255">int dt_ioppr_check_iop_order(dt_develop_t *dev, const int imgid, const char *msg)</a>
<a name="ln1256">{</a>
<a name="ln1257">  int iop_order_ok = 1;</a>
<a name="ln1258"> </a>
<a name="ln1259">  // check if gamma is the last iop</a>
<a name="ln1260">  {</a>
<a name="ln1261">    GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln1262">    while(modules)</a>
<a name="ln1263">    {</a>
<a name="ln1264">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1265">      if(mod-&gt;iop_order != DBL_MAX)</a>
<a name="ln1266">        break;</a>
<a name="ln1267"> </a>
<a name="ln1268">      modules = g_list_previous(dev-&gt;iop);</a>
<a name="ln1269">    }</a>
<a name="ln1270">    if(modules)</a>
<a name="ln1271">    {</a>
<a name="ln1272">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1273"> </a>
<a name="ln1274">      if(strcmp(mod-&gt;op, &quot;gamma&quot;) != 0)</a>
<a name="ln1275">      {</a>
<a name="ln1276">        iop_order_ok = 0;</a>
<a name="ln1277">        fprintf(stderr, &quot;[dt_ioppr_check_iop_order] gamma is not the last iop, last is %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1278">                mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order,imgid, msg);</a>
<a name="ln1279">      }</a>
<a name="ln1280">    }</a>
<a name="ln1281">    else</a>
<a name="ln1282">    {</a>
<a name="ln1283">      // fprintf(stderr, &quot;[dt_ioppr_check_iop_order] dev-&gt;iop is empty image %i (%s)\n&quot;,imgid, msg);</a>
<a name="ln1284">    }</a>
<a name="ln1285">  }</a>
<a name="ln1286"> </a>
<a name="ln1287">  // some other chacks</a>
<a name="ln1288">  {</a>
<a name="ln1289">    GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln1290">    while(modules)</a>
<a name="ln1291">    {</a>
<a name="ln1292">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1293">      if(mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln1294">      {</a>
<a name="ln1295">        if(mod-&gt;enabled)</a>
<a name="ln1296">        {</a>
<a name="ln1297">          iop_order_ok = 0;</a>
<a name="ln1298">          fprintf(stderr, &quot;[dt_ioppr_check_iop_order] module not used but enabled!! %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1299">                  mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order,imgid, msg);</a>
<a name="ln1300">        }</a>
<a name="ln1301">        if(mod-&gt;multi_priority == 0)</a>
<a name="ln1302">        {</a>
<a name="ln1303">          iop_order_ok = 0;</a>
<a name="ln1304">          fprintf(stderr, &quot;[dt_ioppr_check_iop_order] base module set as not used %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1305">                  mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order,imgid, msg);</a>
<a name="ln1306">        }</a>
<a name="ln1307">      }</a>
<a name="ln1308"> </a>
<a name="ln1309">      modules = g_list_previous(dev-&gt;iop);</a>
<a name="ln1310">    }</a>
<a name="ln1311">  }</a>
<a name="ln1312"> </a>
<a name="ln1313">  // check if there's duplicate or out-of-order iop_order</a>
<a name="ln1314">  {</a>
<a name="ln1315">    dt_iop_module_t *mod_prev = NULL;</a>
<a name="ln1316">    GList *modules = g_list_first(dev-&gt;iop);</a>
<a name="ln1317">    while(modules)</a>
<a name="ln1318">    {</a>
<a name="ln1319">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1320">      if(mod-&gt;iop_order != DBL_MAX)</a>
<a name="ln1321">      {</a>
<a name="ln1322">        if(mod_prev)</a>
<a name="ln1323">        {</a>
<a name="ln1324">          if(mod-&gt;iop_order &lt; mod_prev-&gt;iop_order)</a>
<a name="ln1325">          {</a>
<a name="ln1326">            iop_order_ok = 0;</a>
<a name="ln1327">            fprintf(stderr,</a>
<a name="ln1328">                    &quot;[dt_ioppr_check_iop_order] module %s %s(%f) should be after %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1329">                    mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, mod_prev-&gt;op, mod_prev-&gt;multi_name,</a>
<a name="ln1330">                    mod_prev-&gt;iop_order, imgid, msg);</a>
<a name="ln1331">          }</a>
<a name="ln1332">          else if(mod-&gt;iop_order == mod_prev-&gt;iop_order)</a>
<a name="ln1333">          {</a>
<a name="ln1334">            iop_order_ok = 0;</a>
<a name="ln1335">            fprintf(</a>
<a name="ln1336">                stderr,</a>
<a name="ln1337">                &quot;[dt_ioppr_check_iop_order] module %s %s(%i)(%f) and %s %s(%i)(%f) has the same order image %i (%s)\n&quot;,</a>
<a name="ln1338">                mod-&gt;op, mod-&gt;multi_name, mod-&gt;multi_priority, mod-&gt;iop_order, mod_prev-&gt;op,</a>
<a name="ln1339">                mod_prev-&gt;multi_name, mod_prev-&gt;multi_priority, mod_prev-&gt;iop_order, imgid, msg);</a>
<a name="ln1340">          }</a>
<a name="ln1341">        }</a>
<a name="ln1342">      }</a>
<a name="ln1343">      mod_prev = mod;</a>
<a name="ln1344">      modules = g_list_next(modules);</a>
<a name="ln1345">    }</a>
<a name="ln1346">  }</a>
<a name="ln1347"> </a>
<a name="ln1348">  _ioppr_check_rules(dev-&gt;iop, imgid, msg);</a>
<a name="ln1349"> </a>
<a name="ln1350">  GList *history = g_list_first(dev-&gt;history);</a>
<a name="ln1351">  while(history)</a>
<a name="ln1352">  {</a>
<a name="ln1353">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln1354"> </a>
<a name="ln1355">    if(hist-&gt;iop_order == DBL_MAX)</a>
<a name="ln1356">    {</a>
<a name="ln1357">      if(hist-&gt;enabled)</a>
<a name="ln1358">      {</a>
<a name="ln1359">        iop_order_ok = 0;</a>
<a name="ln1360">        fprintf(stderr, &quot;[dt_ioppr_check_iop_order] history module not used but enabled!! %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1361">            hist-&gt;op_name, hist-&gt;multi_name, hist-&gt;iop_order,imgid, msg);</a>
<a name="ln1362">      }</a>
<a name="ln1363">      if(hist-&gt;multi_priority == 0)</a>
<a name="ln1364">      {</a>
<a name="ln1365">        iop_order_ok = 0;</a>
<a name="ln1366">        fprintf(stderr, &quot;[dt_ioppr_check_iop_order] history base module set as not used %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1367">            hist-&gt;op_name, hist-&gt;multi_name, hist-&gt;iop_order,imgid, msg);</a>
<a name="ln1368">      }</a>
<a name="ln1369">    }</a>
<a name="ln1370"> </a>
<a name="ln1371">    history = g_list_next(history);</a>
<a name="ln1372">  }</a>
<a name="ln1373"> </a>
<a name="ln1374">  return iop_order_ok;</a>
<a name="ln1375">}</a>
<a name="ln1376"> </a>
<a name="ln1377">//---------------------------------------------------------</a>
<a name="ln1378">// colorspace transforms</a>
<a name="ln1379">//---------------------------------------------------------</a>
<a name="ln1380"> </a>
<a name="ln1381">static void _transform_from_to_rgb_lab_lcms2(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1382">                                             const int height, const dt_colorspaces_color_profile_type_t type,</a>
<a name="ln1383">                                             const char *filename, const int intent, const int direction)</a>
<a name="ln1384">{</a>
<a name="ln1385">  const int ch = 4;</a>
<a name="ln1386">  cmsHTRANSFORM *xform = NULL;</a>
<a name="ln1387">  cmsHPROFILE *rgb_profile = NULL;</a>
<a name="ln1388">  cmsHPROFILE *lab_profile = NULL;</a>
<a name="ln1389"> </a>
<a name="ln1390">  if(type != DT_COLORSPACE_NONE)</a>
<a name="ln1391">  {</a>
<a name="ln1392">    const dt_colorspaces_color_profile_t *profile = dt_colorspaces_get_profile(type, filename, DT_PROFILE_DIRECTION_WORK);</a>
<a name="ln1393">    if(profile) rgb_profile = profile-&gt;profile;</a>
<a name="ln1394">  }</a>
<a name="ln1395">  else</a>
<a name="ln1396">    rgb_profile = dt_colorspaces_get_profile(DT_COLORSPACE_LIN_REC2020, &quot;&quot;, DT_PROFILE_DIRECTION_WORK)-&gt;profile;</a>
<a name="ln1397">  if(rgb_profile)</a>
<a name="ln1398">  {</a>
<a name="ln1399">    cmsColorSpaceSignature rgb_color_space = cmsGetColorSpace(rgb_profile);</a>
<a name="ln1400">    if(rgb_color_space != cmsSigRgbData)</a>
<a name="ln1401">    {</a>
<a name="ln1402">        fprintf(stderr, &quot;working profile color space `%c%c%c%c' not supported\n&quot;,</a>
<a name="ln1403">                (char)(rgb_color_space&gt;&gt;24),</a>
<a name="ln1404">                (char)(rgb_color_space&gt;&gt;16),</a>
<a name="ln1405">                (char)(rgb_color_space&gt;&gt;8),</a>
<a name="ln1406">                (char)(rgb_color_space));</a>
<a name="ln1407">        rgb_profile = NULL;</a>
<a name="ln1408">    }</a>
<a name="ln1409">  }</a>
<a name="ln1410">  if(rgb_profile == NULL)</a>
<a name="ln1411">  {</a>
<a name="ln1412">    rgb_profile = dt_colorspaces_get_profile(DT_COLORSPACE_LIN_REC2020, &quot;&quot;, DT_PROFILE_DIRECTION_WORK)-&gt;profile;</a>
<a name="ln1413">    fprintf(stderr, _(&quot;unsupported working profile %s has been replaced by Rec2020 RGB!\n&quot;), filename);</a>
<a name="ln1414">  }</a>
<a name="ln1415"> </a>
<a name="ln1416">  lab_profile = dt_colorspaces_get_profile(DT_COLORSPACE_LAB, &quot;&quot;, DT_PROFILE_DIRECTION_ANY)-&gt;profile;</a>
<a name="ln1417"> </a>
<a name="ln1418">  cmsHPROFILE *input_profile = NULL;</a>
<a name="ln1419">  cmsHPROFILE *output_profile = NULL;</a>
<a name="ln1420">  cmsUInt32Number input_format = TYPE_RGBA_FLT;</a>
<a name="ln1421">  cmsUInt32Number output_format = TYPE_LabA_FLT;</a>
<a name="ln1422"> </a>
<a name="ln1423">  if(direction == 1) // rgb --&gt; lab</a>
<a name="ln1424">  {</a>
<a name="ln1425">    input_profile = rgb_profile;</a>
<a name="ln1426">    input_format = TYPE_RGBA_FLT;</a>
<a name="ln1427">    output_profile = lab_profile;</a>
<a name="ln1428">    output_format = TYPE_LabA_FLT;</a>
<a name="ln1429">  }</a>
<a name="ln1430">  else // lab --&gt;rgb</a>
<a name="ln1431">  {</a>
<a name="ln1432">    input_profile = lab_profile;</a>
<a name="ln1433">    input_format = TYPE_LabA_FLT;</a>
<a name="ln1434">    output_profile = rgb_profile;</a>
<a name="ln1435">    output_format = TYPE_RGBA_FLT;</a>
<a name="ln1436">  }</a>
<a name="ln1437"> </a>
<a name="ln1438">  xform = cmsCreateTransform(input_profile, input_format, output_profile, output_format, intent, 0);</a>
<a name="ln1439">  if(xform)</a>
<a name="ln1440">  {</a>
<a name="ln1441">#ifdef _OPENMP</a>
<a name="ln1442">#pragma omp parallel for default(none) \</a>
<a name="ln1443">    dt_omp_firstprivate(image_in, image_out, width, height, ch) \</a>
<a name="ln1444">    shared(xform) \</a>
<a name="ln1445">    schedule(static)</a>
<a name="ln1446">#endif</a>
<a name="ln1447">    for(int y = 0; y &lt; height; y++)</a>
<a name="ln1448">    {</a>
<a name="ln1449">      const float *const in = image_in + y * width * ch;</a>
<a name="ln1450">      float *const out = image_out + y * width * ch;</a>
<a name="ln1451"> </a>
<a name="ln1452">      cmsDoTransform(xform, in, out, width);</a>
<a name="ln1453">    }</a>
<a name="ln1454">  }</a>
<a name="ln1455">  else</a>
<a name="ln1456">    fprintf(stderr, &quot;[_transform_from_to_rgb_lab_lcms2] cannot create transform\n&quot;);</a>
<a name="ln1457"> </a>
<a name="ln1458">  if(xform) cmsDeleteTransform(xform);</a>
<a name="ln1459">}</a>
<a name="ln1460"> </a>
<a name="ln1461">static void _transform_rgb_to_rgb_lcms2(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1462">                                        const int height, const dt_colorspaces_color_profile_type_t type_from,</a>
<a name="ln1463">                                        const char *filename_from,</a>
<a name="ln1464">                                        const dt_colorspaces_color_profile_type_t type_to, const char *filename_to,</a>
<a name="ln1465">                                        const int intent)</a>
<a name="ln1466">{</a>
<a name="ln1467">  const int ch = 4;</a>
<a name="ln1468">  cmsHTRANSFORM *xform = NULL;</a>
<a name="ln1469">  cmsHPROFILE *from_rgb_profile = NULL;</a>
<a name="ln1470">  cmsHPROFILE *to_rgb_profile = NULL;</a>
<a name="ln1471"> </a>
<a name="ln1472">  if(type_from == DT_COLORSPACE_DISPLAY || type_to == DT_COLORSPACE_DISPLAY || type_from == DT_COLORSPACE_DISPLAY2</a>
<a name="ln1473">     || type_to == DT_COLORSPACE_DISPLAY2)</a>
<a name="ln1474">    pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1475"> </a>
<a name="ln1476">  if(type_from != DT_COLORSPACE_NONE)</a>
<a name="ln1477">  {</a>
<a name="ln1478">    const dt_colorspaces_color_profile_t *profile_from</a>
<a name="ln1479">        = dt_colorspaces_get_profile(type_from, filename_from, DT_PROFILE_DIRECTION_ANY);</a>
<a name="ln1480">    if(profile_from) from_rgb_profile = profile_from-&gt;profile;</a>
<a name="ln1481">  }</a>
<a name="ln1482">  else</a>
<a name="ln1483">  {</a>
<a name="ln1484">    fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] invalid from profile\n&quot;);</a>
<a name="ln1485">  }</a>
<a name="ln1486"> </a>
<a name="ln1487">  if(type_to != DT_COLORSPACE_NONE)</a>
<a name="ln1488">  {</a>
<a name="ln1489">    const dt_colorspaces_color_profile_t *profile_to</a>
<a name="ln1490">        = dt_colorspaces_get_profile(type_to, filename_to, DT_PROFILE_DIRECTION_ANY);</a>
<a name="ln1491">    if(profile_to) to_rgb_profile = profile_to-&gt;profile;</a>
<a name="ln1492">  }</a>
<a name="ln1493">  else</a>
<a name="ln1494">  {</a>
<a name="ln1495">    fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] invalid to profile\n&quot;);</a>
<a name="ln1496">  }</a>
<a name="ln1497"> </a>
<a name="ln1498">  if(from_rgb_profile)</a>
<a name="ln1499">  {</a>
<a name="ln1500">    cmsColorSpaceSignature rgb_color_space = cmsGetColorSpace(from_rgb_profile);</a>
<a name="ln1501">    if(rgb_color_space != cmsSigRgbData)</a>
<a name="ln1502">    {</a>
<a name="ln1503">      fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] profile color space `%c%c%c%c' not supported\n&quot;,</a>
<a name="ln1504">              (char)(rgb_color_space &gt;&gt; 24), (char)(rgb_color_space &gt;&gt; 16), (char)(rgb_color_space &gt;&gt; 8),</a>
<a name="ln1505">              (char)(rgb_color_space));</a>
<a name="ln1506">      from_rgb_profile = NULL;</a>
<a name="ln1507">    }</a>
<a name="ln1508">  }</a>
<a name="ln1509">  if(to_rgb_profile)</a>
<a name="ln1510">  {</a>
<a name="ln1511">    cmsColorSpaceSignature rgb_color_space = cmsGetColorSpace(to_rgb_profile);</a>
<a name="ln1512">    if(rgb_color_space != cmsSigRgbData)</a>
<a name="ln1513">    {</a>
<a name="ln1514">      fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] profile color space `%c%c%c%c' not supported\n&quot;,</a>
<a name="ln1515">              (char)(rgb_color_space &gt;&gt; 24), (char)(rgb_color_space &gt;&gt; 16), (char)(rgb_color_space &gt;&gt; 8),</a>
<a name="ln1516">              (char)(rgb_color_space));</a>
<a name="ln1517">      to_rgb_profile = NULL;</a>
<a name="ln1518">    }</a>
<a name="ln1519">  }</a>
<a name="ln1520"> </a>
<a name="ln1521">  cmsHPROFILE *input_profile = NULL;</a>
<a name="ln1522">  cmsHPROFILE *output_profile = NULL;</a>
<a name="ln1523">  cmsUInt32Number input_format = TYPE_RGBA_FLT;</a>
<a name="ln1524">  cmsUInt32Number output_format = TYPE_RGBA_FLT;</a>
<a name="ln1525"> </a>
<a name="ln1526">  input_profile = from_rgb_profile;</a>
<a name="ln1527">  input_format = TYPE_RGBA_FLT;</a>
<a name="ln1528">  output_profile = to_rgb_profile;</a>
<a name="ln1529">  output_format = TYPE_RGBA_FLT;</a>
<a name="ln1530"> </a>
<a name="ln1531">  if(input_profile &amp;&amp; output_profile)</a>
<a name="ln1532">    xform = cmsCreateTransform(input_profile, input_format, output_profile, output_format, intent, 0);</a>
<a name="ln1533"> </a>
<a name="ln1534">  if(type_from == DT_COLORSPACE_DISPLAY || type_to == DT_COLORSPACE_DISPLAY || type_from == DT_COLORSPACE_DISPLAY2</a>
<a name="ln1535">     || type_to == DT_COLORSPACE_DISPLAY2)</a>
<a name="ln1536">    pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1537"> </a>
<a name="ln1538">  if(xform)</a>
<a name="ln1539">  {</a>
<a name="ln1540">#ifdef _OPENMP</a>
<a name="ln1541">#pragma omp parallel for default(none) \</a>
<a name="ln1542">    dt_omp_firstprivate(image_in, image_out, width, height, ch) \</a>
<a name="ln1543">    shared(xform) \</a>
<a name="ln1544">    schedule(static)</a>
<a name="ln1545">#endif</a>
<a name="ln1546">    for(int y = 0; y &lt; height; y++)</a>
<a name="ln1547">    {</a>
<a name="ln1548">      const float *const in = image_in + y * width * ch;</a>
<a name="ln1549">      float *const out = image_out + y * width * ch;</a>
<a name="ln1550"> </a>
<a name="ln1551">      cmsDoTransform(xform, in, out, width);</a>
<a name="ln1552">    }</a>
<a name="ln1553">  }</a>
<a name="ln1554">  else</a>
<a name="ln1555">    fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] cannot create transform\n&quot;);</a>
<a name="ln1556"> </a>
<a name="ln1557">  if(xform) cmsDeleteTransform(xform);</a>
<a name="ln1558">}</a>
<a name="ln1559"> </a>
<a name="ln1560">static void _transform_lcms2(struct dt_iop_module_t *self, const float *const image_in, float *const image_out,</a>
<a name="ln1561">                             const int width, const int height, const int cst_from, const int cst_to,</a>
<a name="ln1562">                             int *converted_cst, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1563">{</a>
<a name="ln1564">  if(cst_from == cst_to)</a>
<a name="ln1565">  {</a>
<a name="ln1566">    *converted_cst = cst_to;</a>
<a name="ln1567">    return;</a>
<a name="ln1568">  }</a>
<a name="ln1569"> </a>
<a name="ln1570">  *converted_cst = cst_to;</a>
<a name="ln1571"> </a>
<a name="ln1572">  if(cst_from == iop_cs_rgb &amp;&amp; cst_to == iop_cs_Lab)</a>
<a name="ln1573">  {</a>
<a name="ln1574">    printf(&quot;[_transform_lcms2] transfoming from RGB to Lab (%s %s)\n&quot;, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln1575">    _transform_from_to_rgb_lab_lcms2(image_in, image_out, width, height, profile_info-&gt;type,</a>
<a name="ln1576">                                     profile_info-&gt;filename, profile_info-&gt;intent, 1);</a>
<a name="ln1577">  }</a>
<a name="ln1578">  else if(cst_from == iop_cs_Lab &amp;&amp; cst_to == iop_cs_rgb)</a>
<a name="ln1579">  {</a>
<a name="ln1580">    printf(&quot;[_transform_lcms2] transfoming from Lab to RGB (%s %s)\n&quot;, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln1581">    _transform_from_to_rgb_lab_lcms2(image_in, image_out, width, height, profile_info-&gt;type,</a>
<a name="ln1582">                                     profile_info-&gt;filename, profile_info-&gt;intent, -1);</a>
<a name="ln1583">  }</a>
<a name="ln1584">  else</a>
<a name="ln1585">  {</a>
<a name="ln1586">    *converted_cst = cst_from;</a>
<a name="ln1587">    fprintf(stderr, &quot;[_transform_lcms2] invalid conversion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln1588">  }</a>
<a name="ln1589">}</a>
<a name="ln1590"> </a>
<a name="ln1591">static inline void _transform_lcms2_rgb(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1592">                                        const int height,</a>
<a name="ln1593">                                        const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln1594">                                        const dt_iop_order_iccprofile_info_t *const profile_info_to)</a>
<a name="ln1595">{</a>
<a name="ln1596">  _transform_rgb_to_rgb_lcms2(image_in, image_out, width, height, profile_info_from-&gt;type,</a>
<a name="ln1597">                              profile_info_from-&gt;filename, profile_info_to-&gt;type, profile_info_to-&gt;filename,</a>
<a name="ln1598">                              profile_info_to-&gt;intent);</a>
<a name="ln1599">}</a>
<a name="ln1600"> </a>
<a name="ln1601">static float lerp_lut(const float *const lut, const float v, const int lutsize)</a>
<a name="ln1602">{</a>
<a name="ln1603">  // TODO: check if optimization is worthwhile!</a>
<a name="ln1604">  const float ft = CLAMPS(v * (lutsize - 1), 0, lutsize - 1);</a>
<a name="ln1605">  const int t = ft &lt; lutsize - 2 ? ft : lutsize - 2;</a>
<a name="ln1606">  const float f = ft - t;</a>
<a name="ln1607">  const float l1 = lut[t];</a>
<a name="ln1608">  const float l2 = lut[t + 1];</a>
<a name="ln1609">  return l1 * (1.0f - f) + l2 * f;</a>
<a name="ln1610">}</a>
<a name="ln1611"> </a>
<a name="ln1612">static inline void _apply_trc_in(const float *const rgb_in, float *rgb_out, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1613">{</a>
<a name="ln1614">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1615">  {</a>
<a name="ln1616">    rgb_out[c] = (profile_info-&gt;lut_in[c][0] &gt;= 0.0f) ? ((rgb_in[c] &lt; 1.0f) ? lerp_lut(profile_info-&gt;lut_in[c], rgb_in[c], profile_info-&gt;lutsize)</a>
<a name="ln1617">                                                        : dt_iop_eval_exp(profile_info-&gt;unbounded_coeffs_in[c], rgb_in[c]))</a>
<a name="ln1618">                                                        : rgb_in[c];</a>
<a name="ln1619">  }</a>
<a name="ln1620">}</a>
<a name="ln1621"> </a>
<a name="ln1622">static inline void _apply_trc_out(const float *const rgb_in, float *rgb_out, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1623">{</a>
<a name="ln1624">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1625">  {</a>
<a name="ln1626">    rgb_out[c] = (profile_info-&gt;lut_out[c][0] &gt;= 0.0f) ? ((rgb_in[c] &lt; 1.0f) ? lerp_lut(profile_info-&gt;lut_out[c], rgb_in[c], profile_info-&gt;lutsize)</a>
<a name="ln1627">                                                        : dt_iop_eval_exp(profile_info-&gt;unbounded_coeffs_out[c], rgb_in[c]))</a>
<a name="ln1628">                                                        : rgb_in[c];</a>
<a name="ln1629">  }</a>
<a name="ln1630">}</a>
<a name="ln1631"> </a>
<a name="ln1632">static void _ioppr_linear_rgb_matrix_to_xyz(const float *const rgb, float *xyz, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1633">{</a>
<a name="ln1634">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1635">  {</a>
<a name="ln1636">    xyz[c] = 0.0f;</a>
<a name="ln1637">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1638">    {</a>
<a name="ln1639">      xyz[c] += profile_info-&gt;matrix_in[3 * c + i] * rgb[i];</a>
<a name="ln1640">    }</a>
<a name="ln1641">  }</a>
<a name="ln1642">}</a>
<a name="ln1643"> </a>
<a name="ln1644">static void _ioppr_xyz_to_linear_rgb_matrix(const float *const xyz, float *rgb, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1645">{</a>
<a name="ln1646">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1647">  {</a>
<a name="ln1648">    rgb[c] = 0.0f;</a>
<a name="ln1649">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1650">    {</a>
<a name="ln1651">      rgb[c] += profile_info-&gt;matrix_out[3 * c + i] * xyz[i];</a>
<a name="ln1652">    }</a>
<a name="ln1653">  }</a>
<a name="ln1654">}</a>
<a name="ln1655"> </a>
<a name="ln1656">static void _apply_tonecurves(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1657">                              const int height, const float *const lutr, const float *const lutg,</a>
<a name="ln1658">                              const float *const lutb, const float *const unbounded_coeffsr,</a>
<a name="ln1659">                              const float *const unbounded_coeffsg, const float *const unbounded_coeffsb,</a>
<a name="ln1660">                              const int lutsize)</a>
<a name="ln1661">{</a>
<a name="ln1662">  const int ch = 4;</a>
<a name="ln1663">  const float *const lut[3] = { lutr, lutg, lutb };</a>
<a name="ln1664">  const float *const unbounded_coeffs[3] = { unbounded_coeffsr, unbounded_coeffsg, unbounded_coeffsb };</a>
<a name="ln1665">  const size_t stride = (size_t)ch * width * height;</a>
<a name="ln1666"> </a>
<a name="ln1667">  // do we have any lut to apply, or is this a linear profile?</a>
<a name="ln1668">  if((lut[0][0] &gt;= 0.0f) &amp;&amp; (lut[1][0] &gt;= 0.0f) &amp;&amp; (lut[2][0] &gt;= 0.0f))</a>
<a name="ln1669">  {</a>
<a name="ln1670">#ifdef _OPENMP</a>
<a name="ln1671">#pragma omp parallel for default(none) \</a>
<a name="ln1672">    dt_omp_firstprivate(stride, image_in, image_out, lut, lutsize, unbounded_coeffs, ch) \</a>
<a name="ln1673">    schedule(static)</a>
<a name="ln1674">#endif</a>
<a name="ln1675">    for(size_t k = 0; k &lt; stride; k += ch)</a>
<a name="ln1676">    {</a>
<a name="ln1677">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1678">      {</a>
<a name="ln1679">        image_out[k + c] = (image_in[k + c] &lt; 1.0f) ? lerp_lut(lut[c], image_in[k + c], lutsize)</a>
<a name="ln1680">                                                    : dt_iop_eval_exp(unbounded_coeffs[c], image_in[k + c]);</a>
<a name="ln1681">      }</a>
<a name="ln1682">    }</a>
<a name="ln1683">  }</a>
<a name="ln1684">  else if((lut[0][0] &gt;= 0.0f) || (lut[1][0] &gt;= 0.0f) || (lut[2][0] &gt;= 0.0f))</a>
<a name="ln1685">  {</a>
<a name="ln1686">#ifdef _OPENMP</a>
<a name="ln1687">#pragma omp parallel for default(none) \</a>
<a name="ln1688">    dt_omp_firstprivate(stride, image_in, image_out, lut, lutsize, unbounded_coeffs, ch) \</a>
<a name="ln1689">    schedule(static)</a>
<a name="ln1690">#endif</a>
<a name="ln1691">    for(size_t k = 0; k &lt; stride; k += ch)</a>
<a name="ln1692">    {</a>
<a name="ln1693">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1694">      {</a>
<a name="ln1695">        if(lut[c][0] &gt;= 0.0f)</a>
<a name="ln1696">        {</a>
<a name="ln1697">          image_out[k + c] = (image_in[k + c] &lt; 1.0f) ? lerp_lut(lut[c], image_in[k + c], lutsize)</a>
<a name="ln1698">                                                      : dt_iop_eval_exp(unbounded_coeffs[c], image_in[k + c]);</a>
<a name="ln1699">        }</a>
<a name="ln1700">      }</a>
<a name="ln1701">    }</a>
<a name="ln1702">  }</a>
<a name="ln1703">}</a>
<a name="ln1704"> </a>
<a name="ln1705">static void _transform_rgb_to_lab_matrix(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1706">                                         const int height,</a>
<a name="ln1707">                                         const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1708">{</a>
<a name="ln1709">  const int ch = 4;</a>
<a name="ln1710">  const size_t stride = (size_t)(width * height);</a>
<a name="ln1711"> </a>
<a name="ln1712">  if(profile_info-&gt;nonlinearlut)</a>
<a name="ln1713">  {</a>
<a name="ln1714">    _apply_tonecurves(image_in, image_out, width, height, profile_info-&gt;lut_in[0], profile_info-&gt;lut_in[1],</a>
<a name="ln1715">                      profile_info-&gt;lut_in[2], profile_info-&gt;unbounded_coeffs_in[0],</a>
<a name="ln1716">                      profile_info-&gt;unbounded_coeffs_in[1], profile_info-&gt;unbounded_coeffs_in[2],</a>
<a name="ln1717">                      profile_info-&gt;lutsize);</a>
<a name="ln1718"> </a>
<a name="ln1719">#ifdef _OPENMP</a>
<a name="ln1720">#pragma omp parallel for default(none) \</a>
<a name="ln1721">    dt_omp_firstprivate(image_out, profile_info, stride, ch) \</a>
<a name="ln1722">    schedule(static)</a>
<a name="ln1723">#endif</a>
<a name="ln1724">    for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1725">    {</a>
<a name="ln1726">      float *const in = image_out + y * ch;</a>
<a name="ln1727"> </a>
<a name="ln1728">      float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1729"> </a>
<a name="ln1730">      _ioppr_linear_rgb_matrix_to_xyz(in, xyz, profile_info);</a>
<a name="ln1731">      dt_XYZ_to_Lab(xyz, in);</a>
<a name="ln1732">    }</a>
<a name="ln1733">  }</a>
<a name="ln1734">  else</a>
<a name="ln1735">  {</a>
<a name="ln1736">#ifdef _OPENMP</a>
<a name="ln1737">#pragma omp parallel for default(none) \</a>
<a name="ln1738">    dt_omp_firstprivate(image_in, image_out, profile_info, stride, ch) \</a>
<a name="ln1739">    schedule(static)</a>
<a name="ln1740">#endif</a>
<a name="ln1741">    for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1742">    {</a>
<a name="ln1743">      const float *const in = image_in + y * ch;</a>
<a name="ln1744">      float *const out = image_out + y * ch;</a>
<a name="ln1745"> </a>
<a name="ln1746">      float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1747"> </a>
<a name="ln1748">      _ioppr_linear_rgb_matrix_to_xyz(in, xyz, profile_info);</a>
<a name="ln1749">      dt_XYZ_to_Lab(xyz, out);</a>
<a name="ln1750">    }</a>
<a name="ln1751">  }</a>
<a name="ln1752">}</a>
<a name="ln1753"> </a>
<a name="ln1754">static void _transform_lab_to_rgb_matrix(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1755">                                         const int height,</a>
<a name="ln1756">                                         const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1757">{</a>
<a name="ln1758">  const int ch = 4;</a>
<a name="ln1759">  const size_t stride = (size_t)width * height;</a>
<a name="ln1760"> </a>
<a name="ln1761">#ifdef _OPENMP</a>
<a name="ln1762">#pragma omp parallel for default(none) \</a>
<a name="ln1763">  dt_omp_firstprivate(image_in, image_out, stride, profile_info, ch) \</a>
<a name="ln1764">  schedule(static)</a>
<a name="ln1765">#endif</a>
<a name="ln1766">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1767">  {</a>
<a name="ln1768">    const float *const in = image_in + y * ch;</a>
<a name="ln1769">    float *const out = image_out + y * ch;</a>
<a name="ln1770"> </a>
<a name="ln1771">    float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1772"> </a>
<a name="ln1773">    dt_Lab_to_XYZ(in, xyz);</a>
<a name="ln1774">    _ioppr_xyz_to_linear_rgb_matrix(xyz, out, profile_info);</a>
<a name="ln1775">  }</a>
<a name="ln1776"> </a>
<a name="ln1777">  _apply_tonecurves(image_out, image_out, width, height, profile_info-&gt;lut_out[0], profile_info-&gt;lut_out[1],</a>
<a name="ln1778">                    profile_info-&gt;lut_out[2], profile_info-&gt;unbounded_coeffs_out[0],</a>
<a name="ln1779">                    profile_info-&gt;unbounded_coeffs_out[1], profile_info-&gt;unbounded_coeffs_out[2],</a>
<a name="ln1780">                    profile_info-&gt;lutsize);</a>
<a name="ln1781">}</a>
<a name="ln1782"> </a>
<a name="ln1783">static void _transform_matrix_rgb(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1784">                                  const int height, const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln1785">                                  const dt_iop_order_iccprofile_info_t *const profile_info_to)</a>
<a name="ln1786">{</a>
<a name="ln1787">  const int ch = 4;</a>
<a name="ln1788">  const size_t stride = (size_t)(width * height);</a>
<a name="ln1789"> </a>
<a name="ln1790">  if(profile_info_from-&gt;nonlinearlut)</a>
<a name="ln1791">  {</a>
<a name="ln1792">    _apply_tonecurves(image_in, image_out, width, height, profile_info_from-&gt;lut_in[0],</a>
<a name="ln1793">                      profile_info_from-&gt;lut_in[1], profile_info_from-&gt;lut_in[2],</a>
<a name="ln1794">                      profile_info_from-&gt;unbounded_coeffs_in[0], profile_info_from-&gt;unbounded_coeffs_in[1],</a>
<a name="ln1795">                      profile_info_from-&gt;unbounded_coeffs_in[2], profile_info_from-&gt;lutsize);</a>
<a name="ln1796"> </a>
<a name="ln1797">#ifdef _OPENMP</a>
<a name="ln1798">#pragma omp parallel for default(none) \</a>
<a name="ln1799">    dt_omp_firstprivate(stride, image_out, profile_info_from, profile_info_to, ch) \</a>
<a name="ln1800">    schedule(static)</a>
<a name="ln1801">#endif</a>
<a name="ln1802">    for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1803">    {</a>
<a name="ln1804">      float *const in = image_out + y * ch;</a>
<a name="ln1805"> </a>
<a name="ln1806">      float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1807"> </a>
<a name="ln1808">      _ioppr_linear_rgb_matrix_to_xyz(in, xyz, profile_info_from);</a>
<a name="ln1809">      _ioppr_xyz_to_linear_rgb_matrix(xyz, in, profile_info_to);</a>
<a name="ln1810">    }</a>
<a name="ln1811">  }</a>
<a name="ln1812">  else</a>
<a name="ln1813">  {</a>
<a name="ln1814">#ifdef _OPENMP</a>
<a name="ln1815">#pragma omp parallel for default(none) \</a>
<a name="ln1816">    dt_omp_firstprivate(stride, image_in, image_out, profile_info_from, profile_info_to, ch) \</a>
<a name="ln1817">    schedule(static)</a>
<a name="ln1818">#endif</a>
<a name="ln1819">    for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1820">    {</a>
<a name="ln1821">      const float *const in = image_in + y * ch;</a>
<a name="ln1822">      float *const out = image_out + y * ch;</a>
<a name="ln1823"> </a>
<a name="ln1824">      float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1825"> </a>
<a name="ln1826">      _ioppr_linear_rgb_matrix_to_xyz(in, xyz, profile_info_from);</a>
<a name="ln1827">      _ioppr_xyz_to_linear_rgb_matrix(xyz, out, profile_info_to);</a>
<a name="ln1828">    }</a>
<a name="ln1829">  }</a>
<a name="ln1830"> </a>
<a name="ln1831">  _apply_tonecurves(image_out, image_out, width, height, profile_info_to-&gt;lut_out[0], profile_info_to-&gt;lut_out[1],</a>
<a name="ln1832">                    profile_info_to-&gt;lut_out[2], profile_info_to-&gt;unbounded_coeffs_out[0],</a>
<a name="ln1833">                    profile_info_to-&gt;unbounded_coeffs_out[1], profile_info_to-&gt;unbounded_coeffs_out[2],</a>
<a name="ln1834">                    profile_info_to-&gt;lutsize);</a>
<a name="ln1835">}</a>
<a name="ln1836"> </a>
<a name="ln1837">static int _init_unbounded_coeffs(float *lutr, float *lutg, float *lutb,</a>
<a name="ln1838">    float *unbounded_coeffsr, float *unbounded_coeffsg, float *unbounded_coeffsb, const int lutsize)</a>
<a name="ln1839">{</a>
<a name="ln1840">  int nonlinearlut = 0;</a>
<a name="ln1841">  float *lut[3] = { lutr, lutg, lutb };</a>
<a name="ln1842">  float *unbounded_coeffs[3] = { unbounded_coeffsr, unbounded_coeffsg, unbounded_coeffsb };</a>
<a name="ln1843"> </a>
<a name="ln1844">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln1845">  {</a>
<a name="ln1846">    // omit luts marked as linear (negative as marker)</a>
<a name="ln1847">    if(lut[k][0] &gt;= 0.0f)</a>
<a name="ln1848">    {</a>
<a name="ln1849">      const float x[4] = { 0.7f, 0.8f, 0.9f, 1.0f };</a>
<a name="ln1850">      const float y[4] = { lerp_lut(lut[k], x[0], lutsize), lerp_lut(lut[k], x[1], lutsize), lerp_lut(lut[k], x[2], lutsize),</a>
<a name="ln1851">                           lerp_lut(lut[k], x[3], lutsize) };</a>
<a name="ln1852">      dt_iop_estimate_exp(x, y, 4, unbounded_coeffs[k]);</a>
<a name="ln1853"> </a>
<a name="ln1854">      nonlinearlut++;</a>
<a name="ln1855">    }</a>
<a name="ln1856">    else</a>
<a name="ln1857">      unbounded_coeffs[k][0] = -1.0f;</a>
<a name="ln1858">  }</a>
<a name="ln1859"> </a>
<a name="ln1860">  return nonlinearlut;</a>
<a name="ln1861">}</a>
<a name="ln1862"> </a>
<a name="ln1863">static void _transform_matrix(struct dt_iop_module_t *self, const float *const image_in, float *const image_out,</a>
<a name="ln1864">                              const int width, const int height, const int cst_from, const int cst_to,</a>
<a name="ln1865">                              int *converted_cst, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1866">{</a>
<a name="ln1867">  if(cst_from == cst_to)</a>
<a name="ln1868">  {</a>
<a name="ln1869">    *converted_cst = cst_to;</a>
<a name="ln1870">    return;</a>
<a name="ln1871">  }</a>
<a name="ln1872"> </a>
<a name="ln1873">  *converted_cst = cst_to;</a>
<a name="ln1874"> </a>
<a name="ln1875">  if(cst_from == iop_cs_rgb &amp;&amp; cst_to == iop_cs_Lab)</a>
<a name="ln1876">  {</a>
<a name="ln1877">    _transform_rgb_to_lab_matrix(image_in, image_out, width, height, profile_info);</a>
<a name="ln1878">  }</a>
<a name="ln1879">  else if(cst_from == iop_cs_Lab &amp;&amp; cst_to == iop_cs_rgb)</a>
<a name="ln1880">  {</a>
<a name="ln1881">    _transform_lab_to_rgb_matrix(image_in, image_out, width, height, profile_info);</a>
<a name="ln1882">  }</a>
<a name="ln1883">  else</a>
<a name="ln1884">  {</a>
<a name="ln1885">    *converted_cst = cst_from;</a>
<a name="ln1886">    fprintf(stderr, &quot;[_transform_matrix] invalid conversion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln1887">  }</a>
<a name="ln1888">}</a>
<a name="ln1889"> </a>
<a name="ln1890">#define DT_IOPPR_LUT_SAMPLES 0x10000</a>
<a name="ln1891"> </a>
<a name="ln1892">void dt_ioppr_init_profile_info(dt_iop_order_iccprofile_info_t *profile_info, const int lutsize)</a>
<a name="ln1893">{</a>
<a name="ln1894">  profile_info-&gt;type = DT_COLORSPACE_NONE;</a>
<a name="ln1895">  profile_info-&gt;filename[0] = '\0';</a>
<a name="ln1896">  profile_info-&gt;intent = DT_INTENT_PERCEPTUAL;</a>
<a name="ln1897">  profile_info-&gt;matrix_in[0] = NAN;</a>
<a name="ln1898">  profile_info-&gt;matrix_out[0] = NAN;</a>
<a name="ln1899">  profile_info-&gt;unbounded_coeffs_in[0][0] = profile_info-&gt;unbounded_coeffs_in[1][0] = profile_info-&gt;unbounded_coeffs_in[2][0] = -1.0f;</a>
<a name="ln1900">  profile_info-&gt;unbounded_coeffs_out[0][0] = profile_info-&gt;unbounded_coeffs_out[1][0] = profile_info-&gt;unbounded_coeffs_out[2][0] = -1.0f;</a>
<a name="ln1901">  profile_info-&gt;nonlinearlut = 0;</a>
<a name="ln1902">  profile_info-&gt;grey = 0.f;</a>
<a name="ln1903">  profile_info-&gt;lutsize = (lutsize &gt; 0) ? lutsize: DT_IOPPR_LUT_SAMPLES;</a>
<a name="ln1904">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1905">  {</a>
<a name="ln1906">    profile_info-&gt;lut_in[i] = malloc(profile_info-&gt;lutsize * sizeof(float));</a>
<a name="ln1907">    profile_info-&gt;lut_in[i][0] = -1.0f;</a>
<a name="ln1908">    profile_info-&gt;lut_out[i] = malloc(profile_info-&gt;lutsize * sizeof(float));</a>
<a name="ln1909">    profile_info-&gt;lut_out[i][0] = -1.0f;</a>
<a name="ln1910">  }</a>
<a name="ln1911">}</a>
<a name="ln1912"> </a>
<a name="ln1913">#undef DT_IOPPR_LUT_SAMPLES</a>
<a name="ln1914"> </a>
<a name="ln1915">void dt_ioppr_cleanup_profile_info(dt_iop_order_iccprofile_info_t *profile_info)</a>
<a name="ln1916">{</a>
<a name="ln1917">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1918">  {</a>
<a name="ln1919">    if(profile_info-&gt;lut_in[i]) free(profile_info-&gt;lut_in[i]);</a>
<a name="ln1920">    if(profile_info-&gt;lut_out[i]) free(profile_info-&gt;lut_out[i]);</a>
<a name="ln1921">  }</a>
<a name="ln1922">}</a>
<a name="ln1923"> </a>
<a name="ln1924">/** generate the info for the profile (type, filename) if matrix can be retrieved from lcms2</a>
<a name="ln1925"> * it can be called multiple time between init and cleanup</a>
<a name="ln1926"> * return 0 if OK, non zero otherwise</a>
<a name="ln1927"> */</a>
<a name="ln1928">static int dt_ioppr_generate_profile_info(dt_iop_order_iccprofile_info_t *profile_info, const int type, const char *filename, const int intent)</a>
<a name="ln1929">{</a>
<a name="ln1930">  int err_code = 0;</a>
<a name="ln1931">  cmsHPROFILE *rgb_profile = NULL;</a>
<a name="ln1932"> </a>
<a name="ln1933">  profile_info-&gt;matrix_in[0] = NAN;</a>
<a name="ln1934">  profile_info-&gt;matrix_out[0] = NAN;</a>
<a name="ln1935">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1936">  {</a>
<a name="ln1937">    profile_info-&gt;lut_in[i][0] = -1.0f;</a>
<a name="ln1938">    profile_info-&gt;lut_out[i][0] = -1.0f;</a>
<a name="ln1939">  }</a>
<a name="ln1940"> </a>
<a name="ln1941">  profile_info-&gt;nonlinearlut = 0;</a>
<a name="ln1942">  profile_info-&gt;grey = 0.1842f;</a>
<a name="ln1943"> </a>
<a name="ln1944">  profile_info-&gt;type = type;</a>
<a name="ln1945">  g_strlcpy(profile_info-&gt;filename, filename, sizeof(profile_info-&gt;filename));</a>
<a name="ln1946">  profile_info-&gt;intent = intent;</a>
<a name="ln1947"> </a>
<a name="ln1948">  if(type == DT_COLORSPACE_DISPLAY || type == DT_COLORSPACE_DISPLAY2)</a>
<a name="ln1949">    pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1950"> </a>
<a name="ln1951">  const dt_colorspaces_color_profile_t *profile</a>
<a name="ln1952">      = dt_colorspaces_get_profile(type, filename, DT_PROFILE_DIRECTION_ANY);</a>
<a name="ln1953">  if(profile) rgb_profile = profile-&gt;profile;</a>
<a name="ln1954"> </a>
<a name="ln1955">  if(type == DT_COLORSPACE_DISPLAY || type == DT_COLORSPACE_DISPLAY2)</a>
<a name="ln1956">    pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1957"> </a>
<a name="ln1958">  // we only allow rgb profiles</a>
<a name="ln1959">  if(rgb_profile)</a>
<a name="ln1960">  {</a>
<a name="ln1961">    cmsColorSpaceSignature rgb_color_space = cmsGetColorSpace(rgb_profile);</a>
<a name="ln1962">    if(rgb_color_space != cmsSigRgbData)</a>
<a name="ln1963">    {</a>
<a name="ln1964">      fprintf(stderr, &quot;working profile color space `%c%c%c%c' not supported\n&quot;,</a>
<a name="ln1965">              (char)(rgb_color_space&gt;&gt;24),</a>
<a name="ln1966">              (char)(rgb_color_space&gt;&gt;16),</a>
<a name="ln1967">              (char)(rgb_color_space&gt;&gt;8),</a>
<a name="ln1968">              (char)(rgb_color_space));</a>
<a name="ln1969">      rgb_profile = NULL;</a>
<a name="ln1970">    }</a>
<a name="ln1971">  }</a>
<a name="ln1972"> </a>
<a name="ln1973">  // get the matrix</a>
<a name="ln1974">  if(rgb_profile)</a>
<a name="ln1975">  {</a>
<a name="ln1976">    if(dt_colorspaces_get_matrix_from_input_profile(rgb_profile, profile_info-&gt;matrix_in,</a>
<a name="ln1977">        profile_info-&gt;lut_in[0], profile_info-&gt;lut_in[1], profile_info-&gt;lut_in[2],</a>
<a name="ln1978">        profile_info-&gt;lutsize, profile_info-&gt;intent) ||</a>
<a name="ln1979">        dt_colorspaces_get_matrix_from_output_profile(rgb_profile, profile_info-&gt;matrix_out,</a>
<a name="ln1980">            profile_info-&gt;lut_out[0], profile_info-&gt;lut_out[1], profile_info-&gt;lut_out[2],</a>
<a name="ln1981">            profile_info-&gt;lutsize, profile_info-&gt;intent))</a>
<a name="ln1982">    {</a>
<a name="ln1983">      profile_info-&gt;matrix_in[0] = NAN;</a>
<a name="ln1984">      profile_info-&gt;matrix_out[0] = NAN;</a>
<a name="ln1985">      for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1986">      {</a>
<a name="ln1987">        profile_info-&gt;lut_in[i][0] = -1.0f;</a>
<a name="ln1988">        profile_info-&gt;lut_out[i][0] = -1.0f;</a>
<a name="ln1989">      }</a>
<a name="ln1990">    }</a>
<a name="ln1991">    else if(isnan(profile_info-&gt;matrix_in[0]) || isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln1992">    {</a>
<a name="ln1993">      profile_info-&gt;matrix_in[0] = NAN;</a>
<a name="ln1994">      profile_info-&gt;matrix_out[0] = NAN;</a>
<a name="ln1995">      for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1996">      {</a>
<a name="ln1997">        profile_info-&gt;lut_in[i][0] = -1.0f;</a>
<a name="ln1998">        profile_info-&gt;lut_out[i][0] = -1.0f;</a>
<a name="ln1999">      }</a>
<a name="ln2000">    }</a>
<a name="ln2001">  }</a>
<a name="ln2002"> </a>
<a name="ln2003">  // now try to initialize unbounded mode:</a>
<a name="ln2004">  // we do extrapolation for input values above 1.0f.</a>
<a name="ln2005">  // unfortunately we can only do this if we got the computation</a>
<a name="ln2006">  // in our hands, i.e. for the fast builtin-dt-matrix-profile path.</a>
<a name="ln2007">  if(!isnan(profile_info-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln2008">  {</a>
<a name="ln2009">    profile_info-&gt;nonlinearlut = _init_unbounded_coeffs(profile_info-&gt;lut_in[0], profile_info-&gt;lut_in[1], profile_info-&gt;lut_in[2],</a>
<a name="ln2010">        profile_info-&gt;unbounded_coeffs_in[0], profile_info-&gt;unbounded_coeffs_in[1], profile_info-&gt;unbounded_coeffs_in[2], profile_info-&gt;lutsize);</a>
<a name="ln2011">    _init_unbounded_coeffs(profile_info-&gt;lut_out[0], profile_info-&gt;lut_out[1], profile_info-&gt;lut_out[2],</a>
<a name="ln2012">        profile_info-&gt;unbounded_coeffs_out[0], profile_info-&gt;unbounded_coeffs_out[1], profile_info-&gt;unbounded_coeffs_out[2], profile_info-&gt;lutsize);</a>
<a name="ln2013">  }</a>
<a name="ln2014"> </a>
<a name="ln2015">  if(!isnan(profile_info-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info-&gt;matrix_out[0]) &amp;&amp; profile_info-&gt;nonlinearlut)</a>
<a name="ln2016">  {</a>
<a name="ln2017">    float rgb[3] = { 0.1842f, 0.1842f, 0.1842f };</a>
<a name="ln2018">    profile_info-&gt;grey = dt_ioppr_get_rgb_matrix_luminance(rgb, profile_info);</a>
<a name="ln2019">  }</a>
<a name="ln2020"> </a>
<a name="ln2021">  return err_code;</a>
<a name="ln2022">}</a>
<a name="ln2023"> </a>
<a name="ln2024">dt_iop_order_iccprofile_info_t *dt_ioppr_get_profile_info_from_list(struct dt_develop_t *dev, const int profile_type, const char *profile_filename)</a>
<a name="ln2025">{</a>
<a name="ln2026">  dt_iop_order_iccprofile_info_t *profile_info = NULL;</a>
<a name="ln2027"> </a>
<a name="ln2028">  GList *profiles = g_list_first(dev-&gt;allprofile_info);</a>
<a name="ln2029">  while(profiles)</a>
<a name="ln2030">  {</a>
<a name="ln2031">    dt_iop_order_iccprofile_info_t *prof = (dt_iop_order_iccprofile_info_t *)(profiles-&gt;data);</a>
<a name="ln2032">    if(prof-&gt;type == profile_type &amp;&amp; strcmp(prof-&gt;filename, profile_filename) == 0)</a>
<a name="ln2033">    {</a>
<a name="ln2034">      profile_info = prof;</a>
<a name="ln2035">      break;</a>
<a name="ln2036">    }</a>
<a name="ln2037">    profiles = g_list_next(profiles);</a>
<a name="ln2038">  }</a>
<a name="ln2039"> </a>
<a name="ln2040">  return profile_info;</a>
<a name="ln2041">}</a>
<a name="ln2042"> </a>
<a name="ln2043">dt_iop_order_iccprofile_info_t *dt_ioppr_add_profile_info_to_list(struct dt_develop_t *dev, const int profile_type, const char *profile_filename, const int intent)</a>
<a name="ln2044">{</a>
<a name="ln2045">  dt_iop_order_iccprofile_info_t *profile_info = dt_ioppr_get_profile_info_from_list(dev, profile_type, profile_filename);</a>
<a name="ln2046">  if(profile_info == NULL)</a>
<a name="ln2047">  {</a>
<a name="ln2048">    profile_info = malloc(sizeof(dt_iop_order_iccprofile_info_t));</a>
<a name="ln2049">    dt_ioppr_init_profile_info(profile_info, 0);</a>
<a name="ln2050">    const int err = dt_ioppr_generate_profile_info(profile_info, profile_type, profile_filename, intent);</a>
<a name="ln2051">    if(err == 0)</a>
<a name="ln2052">    {</a>
<a name="ln2053">      dev-&gt;allprofile_info = g_list_append(dev-&gt;allprofile_info, profile_info);</a>
<a name="ln2054">    }</a>
<a name="ln2055">    else</a>
<a name="ln2056">    {</a>
<a name="ln2057">      free(profile_info);</a>
<a name="ln2058">      profile_info = NULL;</a>
<a name="ln2059">    }</a>
<a name="ln2060">  }</a>
<a name="ln2061">  return profile_info;</a>
<a name="ln2062">}</a>
<a name="ln2063"> </a>
<a name="ln2064">dt_iop_order_iccprofile_info_t *dt_ioppr_get_iop_work_profile_info(struct dt_iop_module_t *module, GList *iop_list)</a>
<a name="ln2065">{</a>
<a name="ln2066">  dt_iop_order_iccprofile_info_t *profile = NULL;</a>
<a name="ln2067"> </a>
<a name="ln2068">  // first check if the module is between colorin and colorout</a>
<a name="ln2069">  gboolean in_between = FALSE;</a>
<a name="ln2070"> </a>
<a name="ln2071">  GList *modules = g_list_first(iop_list);</a>
<a name="ln2072">  while(modules)</a>
<a name="ln2073">  {</a>
<a name="ln2074">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln2075"> </a>
<a name="ln2076">    // we reach the module, that's it</a>
<a name="ln2077">    if(strcmp(mod-&gt;op, module-&gt;op) == 0) break;</a>
<a name="ln2078"> </a>
<a name="ln2079">    // if we reach colorout means that the module is after it</a>
<a name="ln2080">    if(strcmp(mod-&gt;op, &quot;colorout&quot;) == 0)</a>
<a name="ln2081">    {</a>
<a name="ln2082">      in_between = FALSE;</a>
<a name="ln2083">      break;</a>
<a name="ln2084">    }</a>
<a name="ln2085"> </a>
<a name="ln2086">    // we reach colorin, so far we're good</a>
<a name="ln2087">    if(strcmp(mod-&gt;op, &quot;colorin&quot;) == 0)</a>
<a name="ln2088">    {</a>
<a name="ln2089">      in_between = TRUE;</a>
<a name="ln2090">      break;</a>
<a name="ln2091">    }</a>
<a name="ln2092"> </a>
<a name="ln2093">    modules = g_list_next(modules);</a>
<a name="ln2094">  }</a>
<a name="ln2095"> </a>
<a name="ln2096">  if(in_between)</a>
<a name="ln2097">  {</a>
<a name="ln2098">    dt_colorspaces_color_profile_type_t type = DT_COLORSPACE_NONE;</a>
<a name="ln2099">    char *filename = NULL;</a>
<a name="ln2100">    dt_develop_t *dev = module-&gt;dev;</a>
<a name="ln2101"> </a>
<a name="ln2102">    dt_ioppr_get_work_profile_type(dev, &amp;type, &amp;filename);</a>
<a name="ln2103">    if(filename) profile = dt_ioppr_add_profile_info_to_list(dev, type, filename, DT_INTENT_PERCEPTUAL);</a>
<a name="ln2104">  }</a>
<a name="ln2105"> </a>
<a name="ln2106">  return profile;</a>
<a name="ln2107">}</a>
<a name="ln2108"> </a>
<a name="ln2109">dt_iop_order_iccprofile_info_t *dt_ioppr_set_pipe_work_profile_info(struct dt_develop_t *dev, struct dt_dev_pixelpipe_t *pipe,</a>
<a name="ln2110">    const int type, const char *filename, const int intent)</a>
<a name="ln2111">{</a>
<a name="ln2112">  dt_iop_order_iccprofile_info_t *profile_info = dt_ioppr_add_profile_info_to_list(dev, type, filename, intent);</a>
<a name="ln2113"> </a>
<a name="ln2114">  if(profile_info == NULL || isnan(profile_info-&gt;matrix_in[0]) || isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln2115">  {</a>
<a name="ln2116">    fprintf(stderr, &quot;[dt_ioppr_set_pipe_work_profile_info] unsupported working profile %i %s, it will be replaced with linear rec2020\n&quot;, type, filename);</a>
<a name="ln2117">    profile_info = dt_ioppr_add_profile_info_to_list(dev, DT_COLORSPACE_LIN_REC2020, &quot;&quot;, intent);</a>
<a name="ln2118">  }</a>
<a name="ln2119">  pipe-&gt;dsc.work_profile_info = profile_info;</a>
<a name="ln2120"> </a>
<a name="ln2121">  return profile_info;</a>
<a name="ln2122">}</a>
<a name="ln2123"> </a>
<a name="ln2124">dt_iop_order_iccprofile_info_t *dt_ioppr_get_histogram_profile_info(struct dt_develop_t *dev)</a>
<a name="ln2125">{</a>
<a name="ln2126">  dt_colorspaces_color_profile_type_t histogram_profile_type;</a>
<a name="ln2127">  char *histogram_profile_filename;</a>
<a name="ln2128">  dt_ioppr_get_histogram_profile_type(&amp;histogram_profile_type, &amp;histogram_profile_filename);</a>
<a name="ln2129">  return dt_ioppr_add_profile_info_to_list(dev, histogram_profile_type, histogram_profile_filename,</a>
<a name="ln2130">                                           DT_INTENT_PERCEPTUAL);</a>
<a name="ln2131">}</a>
<a name="ln2132"> </a>
<a name="ln2133">dt_iop_order_iccprofile_info_t *dt_ioppr_get_pipe_work_profile_info(struct dt_dev_pixelpipe_t *pipe)</a>
<a name="ln2134">{</a>
<a name="ln2135">  return pipe-&gt;dsc.work_profile_info;</a>
<a name="ln2136">}</a>
<a name="ln2137"> </a>
<a name="ln2138">// returns a pointer to the filename of the work profile instead of the actual string data</a>
<a name="ln2139">// pointer must not be stored</a>
<a name="ln2140">void dt_ioppr_get_work_profile_type(struct dt_develop_t *dev, int *profile_type, char **profile_filename)</a>
<a name="ln2141">{</a>
<a name="ln2142">  *profile_type = DT_COLORSPACE_NONE;</a>
<a name="ln2143">  *profile_filename = NULL;</a>
<a name="ln2144"> </a>
<a name="ln2145">  // use introspection to get the params values</a>
<a name="ln2146">  dt_iop_module_so_t *colorin_so = NULL;</a>
<a name="ln2147">  dt_iop_module_t *colorin = NULL;</a>
<a name="ln2148">  GList *modules = g_list_first(darktable.iop);</a>
<a name="ln2149">  while(modules)</a>
<a name="ln2150">  {</a>
<a name="ln2151">    dt_iop_module_so_t *module_so = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln2152">    if(!strcmp(module_so-&gt;op, &quot;colorin&quot;))</a>
<a name="ln2153">    {</a>
<a name="ln2154">      colorin_so = module_so;</a>
<a name="ln2155">      break;</a>
<a name="ln2156">    }</a>
<a name="ln2157">    modules = g_list_next(modules);</a>
<a name="ln2158">  }</a>
<a name="ln2159">  if(colorin_so &amp;&amp; colorin_so-&gt;get_p)</a>
<a name="ln2160">  {</a>
<a name="ln2161">    modules = g_list_first(dev-&gt;iop);</a>
<a name="ln2162">    while(modules)</a>
<a name="ln2163">    {</a>
<a name="ln2164">      dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln2165">      if(!strcmp(module-&gt;op, &quot;colorin&quot;))</a>
<a name="ln2166">      {</a>
<a name="ln2167">        colorin = module;</a>
<a name="ln2168">        break;</a>
<a name="ln2169">      }</a>
<a name="ln2170">      modules = g_list_next(modules);</a>
<a name="ln2171">    }</a>
<a name="ln2172">  }</a>
<a name="ln2173">  if(colorin)</a>
<a name="ln2174">  {</a>
<a name="ln2175">    dt_colorspaces_color_profile_type_t *_type = colorin_so-&gt;get_p(colorin-&gt;params, &quot;type_work&quot;);</a>
<a name="ln2176">    char *_filename = colorin_so-&gt;get_p(colorin-&gt;params, &quot;filename_work&quot;);</a>
<a name="ln2177">    if(_type &amp;&amp; _filename)</a>
<a name="ln2178">    {</a>
<a name="ln2179">      *profile_type = *_type;</a>
<a name="ln2180">      *profile_filename = _filename;</a>
<a name="ln2181">    }</a>
<a name="ln2182">    else</a>
<a name="ln2183">      fprintf(stderr, &quot;[dt_ioppr_get_work_profile_type] can't get colorin parameters\n&quot;);</a>
<a name="ln2184">  }</a>
<a name="ln2185">  else</a>
<a name="ln2186">    fprintf(stderr, &quot;[dt_ioppr_get_work_profile_type] can't find colorin iop\n&quot;);</a>
<a name="ln2187">}</a>
<a name="ln2188"> </a>
<a name="ln2189">void dt_ioppr_get_export_profile_type(struct dt_develop_t *dev, int *profile_type, char **profile_filename)</a>
<a name="ln2190">{</a>
<a name="ln2191">  *profile_type = DT_COLORSPACE_NONE;</a>
<a name="ln2192">  *profile_filename = NULL;</a>
<a name="ln2193"> </a>
<a name="ln2194">  // use introspection to get the params values</a>
<a name="ln2195">  dt_iop_module_so_t *colorout_so = NULL;</a>
<a name="ln2196">  dt_iop_module_t *colorout = NULL;</a>
<a name="ln2197">  GList *modules = g_list_last(darktable.iop);</a>
<a name="ln2198">  while(modules)</a>
<a name="ln2199">  {</a>
<a name="ln2200">    dt_iop_module_so_t *module_so = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln2201">    if(!strcmp(module_so-&gt;op, &quot;colorout&quot;))</a>
<a name="ln2202">    {</a>
<a name="ln2203">      colorout_so = module_so;</a>
<a name="ln2204">      break;</a>
<a name="ln2205">    }</a>
<a name="ln2206">    modules = g_list_previous(modules);</a>
<a name="ln2207">  }</a>
<a name="ln2208">  if(colorout_so &amp;&amp; colorout_so-&gt;get_p)</a>
<a name="ln2209">  {</a>
<a name="ln2210">    modules = g_list_last(dev-&gt;iop);</a>
<a name="ln2211">    while(modules)</a>
<a name="ln2212">    {</a>
<a name="ln2213">      dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln2214">      if(!strcmp(module-&gt;op, &quot;colorout&quot;))</a>
<a name="ln2215">      {</a>
<a name="ln2216">        colorout = module;</a>
<a name="ln2217">        break;</a>
<a name="ln2218">      }</a>
<a name="ln2219">      modules = g_list_previous(modules);</a>
<a name="ln2220">    }</a>
<a name="ln2221">  }</a>
<a name="ln2222">  if(colorout)</a>
<a name="ln2223">  {</a>
<a name="ln2224">    dt_colorspaces_color_profile_type_t *_type = colorout_so-&gt;get_p(colorout-&gt;params, &quot;type&quot;);</a>
<a name="ln2225">    char *_filename = colorout_so-&gt;get_p(colorout-&gt;params, &quot;filename&quot;);</a>
<a name="ln2226">    if(_type &amp;&amp; _filename)</a>
<a name="ln2227">    {</a>
<a name="ln2228">      *profile_type = *_type;</a>
<a name="ln2229">      *profile_filename = _filename;</a>
<a name="ln2230">    }</a>
<a name="ln2231">    else</a>
<a name="ln2232">      fprintf(stderr, &quot;[dt_ioppr_get_export_profile_type] can't get colorout parameters\n&quot;);</a>
<a name="ln2233">  }</a>
<a name="ln2234">  else</a>
<a name="ln2235">    fprintf(stderr, &quot;[dt_ioppr_get_export_profile_type] can't find colorout iop\n&quot;);</a>
<a name="ln2236">}</a>
<a name="ln2237"> </a>
<a name="ln2238">void dt_ioppr_get_histogram_profile_type(int *profile_type, char **profile_filename)</a>
<a name="ln2239">{</a>
<a name="ln2240">  const dt_colorspaces_color_mode_t mode = darktable.color_profiles-&gt;mode;</a>
<a name="ln2241"> </a>
<a name="ln2242">  // if in gamut check use soft proof</a>
<a name="ln2243">  if(mode != DT_PROFILE_NORMAL || darktable.color_profiles-&gt;histogram_type == DT_COLORSPACE_SOFTPROOF)</a>
<a name="ln2244">  {</a>
<a name="ln2245">    *profile_type = darktable.color_profiles-&gt;softproof_type;</a>
<a name="ln2246">    *profile_filename = darktable.color_profiles-&gt;softproof_filename;</a>
<a name="ln2247">  }</a>
<a name="ln2248">  else if(darktable.color_profiles-&gt;histogram_type == DT_COLORSPACE_WORK)</a>
<a name="ln2249">  {</a>
<a name="ln2250">    dt_ioppr_get_work_profile_type(darktable.develop, profile_type, profile_filename);</a>
<a name="ln2251">  }</a>
<a name="ln2252">  else if(darktable.color_profiles-&gt;histogram_type == DT_COLORSPACE_EXPORT)</a>
<a name="ln2253">  {</a>
<a name="ln2254">    dt_ioppr_get_export_profile_type(darktable.develop, profile_type, profile_filename);</a>
<a name="ln2255">  }</a>
<a name="ln2256">  else</a>
<a name="ln2257">  {</a>
<a name="ln2258">    *profile_type = darktable.color_profiles-&gt;histogram_type;</a>
<a name="ln2259">    *profile_filename = darktable.color_profiles-&gt;histogram_filename;</a>
<a name="ln2260">  }</a>
<a name="ln2261">}</a>
<a name="ln2262"> </a>
<a name="ln2263">float dt_ioppr_get_rgb_matrix_luminance(const float *const rgb, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2264">{</a>
<a name="ln2265">  float luminance = 0.f;</a>
<a name="ln2266"> </a>
<a name="ln2267">  if(profile_info-&gt;nonlinearlut)</a>
<a name="ln2268">  {</a>
<a name="ln2269">    float linear_rgb[3] = { 0.f };</a>
<a name="ln2270"> </a>
<a name="ln2271">    _apply_trc_in(rgb, linear_rgb, profile_info);</a>
<a name="ln2272">    luminance = profile_info-&gt;matrix_in[3] * linear_rgb[0] + profile_info-&gt;matrix_in[4] * linear_rgb[1] + profile_info-&gt;matrix_in[5] * linear_rgb[2];</a>
<a name="ln2273">  }</a>
<a name="ln2274">  else</a>
<a name="ln2275">    luminance = profile_info-&gt;matrix_in[3] * rgb[0] + profile_info-&gt;matrix_in[4] * rgb[1] + profile_info-&gt;matrix_in[5] * rgb[2];</a>
<a name="ln2276"> </a>
<a name="ln2277">  return luminance;</a>
<a name="ln2278">}</a>
<a name="ln2279"> </a>
<a name="ln2280">void dt_ioppr_rgb_matrix_to_xyz(const float *const rgb, float *xyz, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2281">{</a>
<a name="ln2282">  if(profile_info-&gt;nonlinearlut)</a>
<a name="ln2283">  {</a>
<a name="ln2284">    float linear_rgb[3];</a>
<a name="ln2285">    _apply_trc_in(rgb, linear_rgb, profile_info);</a>
<a name="ln2286">    _ioppr_linear_rgb_matrix_to_xyz(linear_rgb, xyz, profile_info);</a>
<a name="ln2287">  }</a>
<a name="ln2288">  else</a>
<a name="ln2289">    _ioppr_linear_rgb_matrix_to_xyz(rgb, xyz, profile_info);</a>
<a name="ln2290">}</a>
<a name="ln2291"> </a>
<a name="ln2292">void dt_ioppr_lab_to_rgb_matrix(const float *const lab, float *rgb, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2293">{</a>
<a name="ln2294">  float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln2295"> </a>
<a name="ln2296">  dt_Lab_to_XYZ(lab, xyz);</a>
<a name="ln2297"> </a>
<a name="ln2298">  _ioppr_xyz_to_linear_rgb_matrix(xyz, rgb, profile_info);</a>
<a name="ln2299"> </a>
<a name="ln2300">  if(profile_info-&gt;nonlinearlut) _apply_trc_out(rgb, rgb, profile_info);</a>
<a name="ln2301">}</a>
<a name="ln2302"> </a>
<a name="ln2303">void dt_ioppr_rgb_matrix_to_lab(const float *const rgb, float *lab, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2304">{</a>
<a name="ln2305">  float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln2306"> </a>
<a name="ln2307">  dt_ioppr_rgb_matrix_to_xyz(rgb, xyz, profile_info);</a>
<a name="ln2308"> </a>
<a name="ln2309">  dt_XYZ_to_Lab(xyz, lab);</a>
<a name="ln2310">}</a>
<a name="ln2311"> </a>
<a name="ln2312">float dt_ioppr_get_profile_info_middle_grey(const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2313">{</a>
<a name="ln2314">  return profile_info-&gt;grey;</a>
<a name="ln2315">}</a>
<a name="ln2316"> </a>
<a name="ln2317">float dt_ioppr_compensate_middle_grey(const float x, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2318">{</a>
<a name="ln2319">  // we transform the curve nodes from the image colorspace to lab</a>
<a name="ln2320">  float lab[3] = { 0 };</a>
<a name="ln2321">  float rgb[3] = { 0 };</a>
<a name="ln2322"> </a>
<a name="ln2323">  rgb[0] = rgb[1] = rgb[2] = x;</a>
<a name="ln2324">  dt_ioppr_rgb_matrix_to_lab(rgb, lab, profile_info);</a>
<a name="ln2325">  return lab[0] * .01f;</a>
<a name="ln2326">}</a>
<a name="ln2327"> </a>
<a name="ln2328">float dt_ioppr_uncompensate_middle_grey(const float x, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2329">{</a>
<a name="ln2330">  // we transform the curve nodes from lab to the image colorspace</a>
<a name="ln2331">  float lab[3] = { 0 };</a>
<a name="ln2332">  float rgb[3] = { 0 };</a>
<a name="ln2333"> </a>
<a name="ln2334">  lab[0] = x * 100.f;</a>
<a name="ln2335">  dt_ioppr_lab_to_rgb_matrix(lab, rgb, profile_info);</a>
<a name="ln2336">  return rgb[0];</a>
<a name="ln2337">}</a>
<a name="ln2338"> </a>
<a name="ln2339">#if defined(__SSE2__x) // FIXME: this is slower than the C version</a>
<a name="ln2340">static __m128 _ioppr_linear_rgb_matrix_to_xyz_sse(const __m128 rgb, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2341">{</a>
<a name="ln2342">/*  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2343">  {</a>
<a name="ln2344">    xyz[c] = 0.0f;</a>
<a name="ln2345">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2346">    {</a>
<a name="ln2347">      xyz[c] += profile_info-&gt;matrix_in[3 * c + i] * rgb[i];</a>
<a name="ln2348">    }</a>
<a name="ln2349">  }*/</a>
<a name="ln2350">  const __m128 m0 = _mm_set_ps(0.0f, profile_info-&gt;matrix_in[6], profile_info-&gt;matrix_in[3], profile_info-&gt;matrix_in[0]);</a>
<a name="ln2351">  const __m128 m1 = _mm_set_ps(0.0f, profile_info-&gt;matrix_in[7], profile_info-&gt;matrix_in[4], profile_info-&gt;matrix_in[1]);</a>
<a name="ln2352">  const __m128 m2 = _mm_set_ps(0.0f, profile_info-&gt;matrix_in[8], profile_info-&gt;matrix_in[5], profile_info-&gt;matrix_in[2]);</a>
<a name="ln2353"> </a>
<a name="ln2354">  __m128 xyz</a>
<a name="ln2355">      = _mm_add_ps(_mm_mul_ps(m0, _mm_shuffle_ps(rgb, rgb, _MM_SHUFFLE(0, 0, 0, 0))),</a>
<a name="ln2356">                   _mm_add_ps(_mm_mul_ps(m1, _mm_shuffle_ps(rgb, rgb, _MM_SHUFFLE(1, 1, 1, 1))),</a>
<a name="ln2357">                              _mm_mul_ps(m2, _mm_shuffle_ps(rgb, rgb, _MM_SHUFFLE(2, 2, 2, 2)))));</a>
<a name="ln2358">  return xyz;</a>
<a name="ln2359">}</a>
<a name="ln2360"> </a>
<a name="ln2361">static __m128 _ioppr_xyz_to_linear_rgb_matrix_sse(const __m128 xyz, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2362">{</a>
<a name="ln2363">/*  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2364">  {</a>
<a name="ln2365">    rgb[c] = 0.0f;</a>
<a name="ln2366">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2367">    {</a>
<a name="ln2368">      rgb[c] += profile_info-&gt;matrix_out[3 * c + i] * xyz[i];</a>
<a name="ln2369">    }</a>
<a name="ln2370">  }*/</a>
<a name="ln2371">  const __m128 m0 = _mm_set_ps(0.0f, profile_info-&gt;matrix_out[6], profile_info-&gt;matrix_out[3], profile_info-&gt;matrix_out[0]);</a>
<a name="ln2372">  const __m128 m1 = _mm_set_ps(0.0f, profile_info-&gt;matrix_out[7], profile_info-&gt;matrix_out[4], profile_info-&gt;matrix_out[1]);</a>
<a name="ln2373">  const __m128 m2 = _mm_set_ps(0.0f, profile_info-&gt;matrix_out[8], profile_info-&gt;matrix_out[5], profile_info-&gt;matrix_out[2]);</a>
<a name="ln2374"> </a>
<a name="ln2375">  __m128 rgb</a>
<a name="ln2376">      = _mm_add_ps(_mm_mul_ps(m0, _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(0, 0, 0, 0))),</a>
<a name="ln2377">                   _mm_add_ps(_mm_mul_ps(m1, _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(1, 1, 1, 1))),</a>
<a name="ln2378">                              _mm_mul_ps(m2, _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(2, 2, 2, 2)))));</a>
<a name="ln2379">  return rgb;</a>
<a name="ln2380">}</a>
<a name="ln2381"> </a>
<a name="ln2382">static void _transform_rgb_to_lab_matrix_sse(float *const image, const int width, const int height, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2383">{</a>
<a name="ln2384">  const int ch = 4;</a>
<a name="ln2385">  const size_t stride = (size_t)(width * height);</a>
<a name="ln2386"> </a>
<a name="ln2387">  _apply_tonecurves(image, width, height, profile_info-&gt;lut_in[0], profile_info-&gt;lut_in[1], profile_info-&gt;lut_in[2],</a>
<a name="ln2388">      profile_info-&gt;unbounded_coeffs_in[0], profile_info-&gt;unbounded_coeffs_in[1], profile_info-&gt;unbounded_coeffs_in[2], profile_info-&gt;lutsize);</a>
<a name="ln2389"> </a>
<a name="ln2390">#ifdef _OPENMP</a>
<a name="ln2391">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln2392">#endif</a>
<a name="ln2393">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln2394">  {</a>
<a name="ln2395">    float *const in = image + y * ch;</a>
<a name="ln2396"> </a>
<a name="ln2397">    __m128 xyz = { 0.0f };</a>
<a name="ln2398">    __m128 rgb = _mm_load_ps(in);</a>
<a name="ln2399"> </a>
<a name="ln2400">    xyz = _ioppr_linear_rgb_matrix_to_xyz_sse(rgb, profile_info);</a>
<a name="ln2401"> </a>
<a name="ln2402">    rgb = dt_XYZ_to_Lab_sse2(xyz);</a>
<a name="ln2403">    const float a = in[3];</a>
<a name="ln2404">    _mm_stream_ps(in, rgb);</a>
<a name="ln2405">    in[3] = a;</a>
<a name="ln2406">  }</a>
<a name="ln2407">}</a>
<a name="ln2408"> </a>
<a name="ln2409">static void _transform_lab_to_rgb_matrix_sse(float *const image, const int width, const int height, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2410">{</a>
<a name="ln2411">  const int ch = 4;</a>
<a name="ln2412">  const size_t stride = (size_t)width * height;</a>
<a name="ln2413"> </a>
<a name="ln2414">#ifdef _OPENMP</a>
<a name="ln2415">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln2416">#endif</a>
<a name="ln2417">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln2418">  {</a>
<a name="ln2419">    float *const in = image + y * ch;</a>
<a name="ln2420"> </a>
<a name="ln2421">    __m128 xyz = { 0.0f };</a>
<a name="ln2422">    __m128 lab = _mm_load_ps(in);</a>
<a name="ln2423"> </a>
<a name="ln2424">    xyz = dt_Lab_to_XYZ_sse2(lab);</a>
<a name="ln2425">    lab = _ioppr_xyz_to_linear_rgb_matrix_sse(xyz, profile_info);</a>
<a name="ln2426">    const float a = in[3];</a>
<a name="ln2427">    _mm_stream_ps(in, lab);</a>
<a name="ln2428">    in[3] = a;</a>
<a name="ln2429">  }</a>
<a name="ln2430"> </a>
<a name="ln2431">  _apply_tonecurves(image, width, height, profile_info-&gt;lut_out[0], profile_info-&gt;lut_out[1], profile_info-&gt;lut_out[2],</a>
<a name="ln2432">      profile_info-&gt;unbounded_coeffs_out[0], profile_info-&gt;unbounded_coeffs_out[1], profile_info-&gt;unbounded_coeffs_out[2], profile_info-&gt;lutsize);</a>
<a name="ln2433">}</a>
<a name="ln2434"> </a>
<a name="ln2435">// FIXME: this is slower than the C version</a>
<a name="ln2436">static void _transform_matrix_sse(struct dt_iop_module_t *self, float *const image, const int width, const int height,</a>
<a name="ln2437">    const int cst_from, const int cst_to, int *converted_cst, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2438">{</a>
<a name="ln2439">  if(cst_from == cst_to)</a>
<a name="ln2440">  {</a>
<a name="ln2441">    *converted_cst = cst_to;</a>
<a name="ln2442">    return;</a>
<a name="ln2443">  }</a>
<a name="ln2444"> </a>
<a name="ln2445">  *converted_cst = cst_to;</a>
<a name="ln2446"> </a>
<a name="ln2447">  if(cst_from == iop_cs_rgb &amp;&amp; cst_to == iop_cs_Lab)</a>
<a name="ln2448">  {</a>
<a name="ln2449">    _transform_rgb_to_lab_matrix_sse(image, width, height, profile_info);</a>
<a name="ln2450">  }</a>
<a name="ln2451">  else if(cst_from == iop_cs_Lab &amp;&amp; cst_to == iop_cs_rgb)</a>
<a name="ln2452">  {</a>
<a name="ln2453">    _transform_lab_to_rgb_matrix_sse(image, width, height, profile_info);</a>
<a name="ln2454">  }</a>
<a name="ln2455">  else</a>
<a name="ln2456">  {</a>
<a name="ln2457">    *converted_cst = cst_from;</a>
<a name="ln2458">    fprintf(stderr, &quot;[_transform_matrix_sse] invalid conversion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln2459">  }</a>
<a name="ln2460">}</a>
<a name="ln2461"> </a>
<a name="ln2462">static void _transform_matrix_rgb_sse(float *const image, const int width, const int height,</a>
<a name="ln2463">                                      const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln2464">                                      const dt_iop_order_iccprofile_info_t *const profile_info_to)</a>
<a name="ln2465">{</a>
<a name="ln2466">  const int ch = 4;</a>
<a name="ln2467">  const size_t stride = (size_t)(width * height);</a>
<a name="ln2468"> </a>
<a name="ln2469">  _apply_tonecurves(image, width, height, profile_info_from-&gt;lut_in[0], profile_info_from-&gt;lut_in[1],</a>
<a name="ln2470">                    profile_info_from-&gt;lut_in[2], profile_info_from-&gt;unbounded_coeffs_in[0],</a>
<a name="ln2471">                    profile_info_from-&gt;unbounded_coeffs_in[1], profile_info_from-&gt;unbounded_coeffs_in[2],</a>
<a name="ln2472">                    profile_info_from-&gt;lutsize);</a>
<a name="ln2473"> </a>
<a name="ln2474">#ifdef _OPENMP</a>
<a name="ln2475">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln2476">#endif</a>
<a name="ln2477">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln2478">  {</a>
<a name="ln2479">    float *const in = image + y * ch;</a>
<a name="ln2480"> </a>
<a name="ln2481">    __m128 xyz = { 0.0f };</a>
<a name="ln2482">    __m128 rgb = _mm_load_ps(in);</a>
<a name="ln2483"> </a>
<a name="ln2484">    xyz = _ioppr_linear_rgb_matrix_to_xyz_sse(rgb, profile_info_from);</a>
<a name="ln2485">    rgb = _ioppr_xyz_to_linear_rgb_matrix_sse(xyz, profile_info_to);</a>
<a name="ln2486"> </a>
<a name="ln2487">    const float a = in[3];</a>
<a name="ln2488">    _mm_stream_ps(in, rgb);</a>
<a name="ln2489">    in[3] = a;</a>
<a name="ln2490">  }</a>
<a name="ln2491"> </a>
<a name="ln2492">  _apply_tonecurves(image, width, height, profile_info_to-&gt;lut_out[0], profile_info_to-&gt;lut_out[1],</a>
<a name="ln2493">                    profile_info_to-&gt;lut_out[2], profile_info_to-&gt;unbounded_coeffs_out[0],</a>
<a name="ln2494">                    profile_info_to-&gt;unbounded_coeffs_out[1], profile_info_to-&gt;unbounded_coeffs_out[2],</a>
<a name="ln2495">                    profile_info_to-&gt;lutsize);</a>
<a name="ln2496">}</a>
<a name="ln2497">#endif</a>
<a name="ln2498"> </a>
<a name="ln2499">void dt_ioppr_transform_image_colorspace(struct dt_iop_module_t *self, const float *const image_in,</a>
<a name="ln2500">                                         float *const image_out, const int width, const int height,</a>
<a name="ln2501">                                         const int cst_from, const int cst_to, int *converted_cst,</a>
<a name="ln2502">                                         const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2503">{</a>
<a name="ln2504">  if(cst_from == cst_to)</a>
<a name="ln2505">  {</a>
<a name="ln2506">    *converted_cst = cst_to;</a>
<a name="ln2507">    return;</a>
<a name="ln2508">  }</a>
<a name="ln2509">  if(profile_info == NULL)</a>
<a name="ln2510">  {</a>
<a name="ln2511">    fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace] module %s must be between input color profile and output color profile\n&quot;, self-&gt;op);</a>
<a name="ln2512">    *converted_cst = cst_from;</a>
<a name="ln2513">    return;</a>
<a name="ln2514">  }</a>
<a name="ln2515">  if(profile_info-&gt;type == DT_COLORSPACE_NONE)</a>
<a name="ln2516">  {</a>
<a name="ln2517">    *converted_cst = cst_from;</a>
<a name="ln2518">    return;</a>
<a name="ln2519">  }</a>
<a name="ln2520"> </a>
<a name="ln2521">  dt_times_t start_time = { 0 }, end_time = { 0 };</a>
<a name="ln2522">  if(darktable.unmuted &amp; DT_DEBUG_PERF) dt_get_times(&amp;start_time);</a>
<a name="ln2523"> </a>
<a name="ln2524">  // matrix should be never NAN, this is only to test it against lcms2!</a>
<a name="ln2525">  if(!isnan(profile_info-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln2526">  {</a>
<a name="ln2527">    // FIXME: sse is slower than the C version</a>
<a name="ln2528">    // if(darktable.codepath.OPENMP_SIMD)</a>
<a name="ln2529">    _transform_matrix(self, image_in, image_out, width, height, cst_from, cst_to, converted_cst, profile_info);</a>
<a name="ln2530">    /*</a>
<a name="ln2531">    #if defined(__SSE2__)</a>
<a name="ln2532">        else if(darktable.codepath.SSE2)</a>
<a name="ln2533">          _transform_matrix_sse(self, image, width, height, cst_from, cst_to, converted_cst, profile_info);</a>
<a name="ln2534">    #endif</a>
<a name="ln2535">        else</a>
<a name="ln2536">          dt_unreachable_codepath();</a>
<a name="ln2537">    */</a>
<a name="ln2538">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2539">    {</a>
<a name="ln2540">      dt_get_times(&amp;end_time);</a>
<a name="ln2541">      fprintf(stderr, &quot;image colorspace transform %s--&gt;%s took %.3f secs (%.3f CPU) [%s %s]\n&quot;,</a>
<a name="ln2542">          (cst_from == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;, (cst_to == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;,</a>
<a name="ln2543">          end_time.clock - start_time.clock, end_time.user - start_time.user, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln2544">    }</a>
<a name="ln2545">  }</a>
<a name="ln2546">  else</a>
<a name="ln2547">  {</a>
<a name="ln2548">    _transform_lcms2(self, image_in, image_out, width, height, cst_from, cst_to, converted_cst, profile_info);</a>
<a name="ln2549"> </a>
<a name="ln2550">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2551">    {</a>
<a name="ln2552">      dt_get_times(&amp;end_time);</a>
<a name="ln2553">      fprintf(stderr, &quot;image colorspace transform %s--&gt;%s took %.3f secs (%.3f lcms2) [%s %s]\n&quot;,</a>
<a name="ln2554">          (cst_from == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;, (cst_to == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;,</a>
<a name="ln2555">          end_time.clock - start_time.clock, end_time.user - start_time.user, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln2556">    }</a>
<a name="ln2557">  }</a>
<a name="ln2558"> </a>
<a name="ln2559">  if(*converted_cst == cst_from)</a>
<a name="ln2560">    fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace] invalid conversion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln2561">}</a>
<a name="ln2562"> </a>
<a name="ln2563">void dt_ioppr_transform_image_colorspace_rgb(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln2564">                                             const int height,</a>
<a name="ln2565">                                             const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln2566">                                             const dt_iop_order_iccprofile_info_t *const profile_info_to,</a>
<a name="ln2567">                                             const char *message)</a>
<a name="ln2568">{</a>
<a name="ln2569">  if(profile_info_from-&gt;type == DT_COLORSPACE_NONE || profile_info_to-&gt;type == DT_COLORSPACE_NONE)</a>
<a name="ln2570">  {</a>
<a name="ln2571">    return;</a>
<a name="ln2572">  }</a>
<a name="ln2573">  if(profile_info_from-&gt;type == profile_info_to-&gt;type</a>
<a name="ln2574">     &amp;&amp; strcmp(profile_info_from-&gt;filename, profile_info_to-&gt;filename) == 0)</a>
<a name="ln2575">  {</a>
<a name="ln2576">    if(image_in != image_out)</a>
<a name="ln2577">      memcpy(image_out, image_in, width * height * 4 * sizeof(float));</a>
<a name="ln2578"> </a>
<a name="ln2579">    return;</a>
<a name="ln2580">  }</a>
<a name="ln2581"> </a>
<a name="ln2582">  dt_times_t start_time = { 0 }, end_time = { 0 };</a>
<a name="ln2583">  if(darktable.unmuted &amp; DT_DEBUG_PERF) dt_get_times(&amp;start_time);</a>
<a name="ln2584"> </a>
<a name="ln2585">  if(!isnan(profile_info_from-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info_from-&gt;matrix_out[0])</a>
<a name="ln2586">     &amp;&amp; !isnan(profile_info_to-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info_to-&gt;matrix_out[0]))</a>
<a name="ln2587">  {</a>
<a name="ln2588">    // FIXME: sse is slower than the C version</a>
<a name="ln2589">    // if(darktable.codepath.OPENMP_SIMD)</a>
<a name="ln2590">    _transform_matrix_rgb(image_in, image_out, width, height, profile_info_from, profile_info_to);</a>
<a name="ln2591">    /*</a>
<a name="ln2592">    #if defined(__SSE2__)</a>
<a name="ln2593">        else if(darktable.codepath.SSE2)</a>
<a name="ln2594">          _transform_matrix_rgb_sse(self, image, width, height, profile_info_from, profile_info_to);</a>
<a name="ln2595">    #endif</a>
<a name="ln2596">        else</a>
<a name="ln2597">          dt_unreachable_codepath();</a>
<a name="ln2598">    */</a>
<a name="ln2599">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2600">    {</a>
<a name="ln2601">      dt_get_times(&amp;end_time);</a>
<a name="ln2602">      fprintf(stderr, &quot;image colorspace transform RGB--&gt;RGB took %.3f secs (%.3f CPU) [%s]\n&quot;,</a>
<a name="ln2603">              end_time.clock - start_time.clock, end_time.user - start_time.user, (message) ? message : &quot;&quot;);</a>
<a name="ln2604">    }</a>
<a name="ln2605">  }</a>
<a name="ln2606">  else</a>
<a name="ln2607">  {</a>
<a name="ln2608">    _transform_lcms2_rgb(image_in, image_out, width, height, profile_info_from, profile_info_to);</a>
<a name="ln2609"> </a>
<a name="ln2610">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2611">    {</a>
<a name="ln2612">      dt_get_times(&amp;end_time);</a>
<a name="ln2613">      fprintf(stderr, &quot;image colorspace transform RGB--&gt;RGB took %.3f secs (%.3f lcms2) [%s]\n&quot;,</a>
<a name="ln2614">              end_time.clock - start_time.clock, end_time.user - start_time.user, (message) ? message : &quot;&quot;);</a>
<a name="ln2615">    }</a>
<a name="ln2616">  }</a>
<a name="ln2617">}</a>
<a name="ln2618"> </a>
<a name="ln2619">#ifdef HAVE_OPENCL</a>
<a name="ln2620">dt_colorspaces_cl_global_t *dt_colorspaces_init_cl_global()</a>
<a name="ln2621">{</a>
<a name="ln2622">  dt_colorspaces_cl_global_t *g = (dt_colorspaces_cl_global_t *)malloc(sizeof(dt_colorspaces_cl_global_t));</a>
<a name="ln2623"> </a>
<a name="ln2624">  const int program = 23; // colorspaces.cl, from programs.conf</a>
<a name="ln2625">  g-&gt;kernel_colorspaces_transform_lab_to_rgb_matrix = dt_opencl_create_kernel(program, &quot;colorspaces_transform_lab_to_rgb_matrix&quot;);</a>
<a name="ln2626">  g-&gt;kernel_colorspaces_transform_rgb_matrix_to_lab = dt_opencl_create_kernel(program, &quot;colorspaces_transform_rgb_matrix_to_lab&quot;);</a>
<a name="ln2627">  g-&gt;kernel_colorspaces_transform_rgb_matrix_to_rgb</a>
<a name="ln2628">      = dt_opencl_create_kernel(program, &quot;colorspaces_transform_rgb_matrix_to_rgb&quot;);</a>
<a name="ln2629">  return g;</a>
<a name="ln2630">}</a>
<a name="ln2631"> </a>
<a name="ln2632">void dt_colorspaces_free_cl_global(dt_colorspaces_cl_global_t *g)</a>
<a name="ln2633">{</a>
<a name="ln2634">  if(!g) return;</a>
<a name="ln2635"> </a>
<a name="ln2636">  // destroy kernels</a>
<a name="ln2637">  dt_opencl_free_kernel(g-&gt;kernel_colorspaces_transform_lab_to_rgb_matrix);</a>
<a name="ln2638">  dt_opencl_free_kernel(g-&gt;kernel_colorspaces_transform_rgb_matrix_to_lab);</a>
<a name="ln2639">  dt_opencl_free_kernel(g-&gt;kernel_colorspaces_transform_rgb_matrix_to_rgb);</a>
<a name="ln2640"> </a>
<a name="ln2641">  free(g);</a>
<a name="ln2642">}</a>
<a name="ln2643"> </a>
<a name="ln2644">void dt_ioppr_get_profile_info_cl(const dt_iop_order_iccprofile_info_t *const profile_info, dt_colorspaces_iccprofile_info_cl_t *profile_info_cl)</a>
<a name="ln2645">{</a>
<a name="ln2646">  for(int i = 0; i &lt; 9; i++)</a>
<a name="ln2647">  {</a>
<a name="ln2648">    profile_info_cl-&gt;matrix_in[i] = profile_info-&gt;matrix_in[i];</a>
<a name="ln2649">    profile_info_cl-&gt;matrix_out[i] = profile_info-&gt;matrix_out[i];</a>
<a name="ln2650">  }</a>
<a name="ln2651">  profile_info_cl-&gt;lutsize = profile_info-&gt;lutsize;</a>
<a name="ln2652">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2653">  {</a>
<a name="ln2654">    for(int j = 0; j &lt; 3; j++)</a>
<a name="ln2655">    {</a>
<a name="ln2656">      profile_info_cl-&gt;unbounded_coeffs_in[i][j] = profile_info-&gt;unbounded_coeffs_in[i][j];</a>
<a name="ln2657">      profile_info_cl-&gt;unbounded_coeffs_out[i][j] = profile_info-&gt;unbounded_coeffs_out[i][j];</a>
<a name="ln2658">    }</a>
<a name="ln2659">  }</a>
<a name="ln2660">  profile_info_cl-&gt;nonlinearlut = profile_info-&gt;nonlinearlut;</a>
<a name="ln2661">  profile_info_cl-&gt;grey = profile_info-&gt;grey;</a>
<a name="ln2662">}</a>
<a name="ln2663"> </a>
<a name="ln2664">cl_float *dt_ioppr_get_trc_cl(const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2665">{</a>
<a name="ln2666">  cl_float *trc = malloc(profile_info-&gt;lutsize * 6 * sizeof(cl_float));</a>
<a name="ln2667">  if(trc)</a>
<a name="ln2668">  {</a>
<a name="ln2669">    int x = 0;</a>
<a name="ln2670">    for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2671">      for(int y = 0; y &lt; profile_info-&gt;lutsize; y++, x++)</a>
<a name="ln2672">        trc[x] = profile_info-&gt;lut_in[c][y];</a>
<a name="ln2673">    for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2674">      for(int y = 0; y &lt; profile_info-&gt;lutsize; y++, x++)</a>
<a name="ln2675">        trc[x] = profile_info-&gt;lut_out[c][y];</a>
<a name="ln2676">  }</a>
<a name="ln2677">  return trc;</a>
<a name="ln2678">}</a>
<a name="ln2679"> </a>
<a name="ln2680">cl_int dt_ioppr_build_iccprofile_params_cl(const dt_iop_order_iccprofile_info_t *const profile_info,</a>
<a name="ln2681">                                           const int devid, dt_colorspaces_iccprofile_info_cl_t **_profile_info_cl,</a>
<a name="ln2682">                                           cl_float **_profile_lut_cl, cl_mem *_dev_profile_info,</a>
<a name="ln2683">                                           cl_mem *_dev_profile_lut)</a>
<a name="ln2684">{</a>
<a name="ln2685">  cl_int err = CL_SUCCESS;</a>
<a name="ln2686"> </a>
<a name="ln2687">  dt_colorspaces_iccprofile_info_cl_t *profile_info_cl = calloc(1, sizeof(dt_colorspaces_iccprofile_info_cl_t));</a>
<a name="ln2688">  cl_float *profile_lut_cl = NULL;</a>
<a name="ln2689">  cl_mem dev_profile_info = NULL;</a>
<a name="ln2690">  cl_mem dev_profile_lut = NULL;</a>
<a name="ln2691"> </a>
<a name="ln2692">  if(profile_info)</a>
<a name="ln2693">  {</a>
<a name="ln2694">    dt_ioppr_get_profile_info_cl(profile_info, profile_info_cl);</a>
<a name="ln2695">    profile_lut_cl = dt_ioppr_get_trc_cl(profile_info);</a>
<a name="ln2696"> </a>
<a name="ln2697">    dev_profile_info = dt_opencl_copy_host_to_device_constant(devid, sizeof(*profile_info_cl), profile_info_cl);</a>
<a name="ln2698">    if(dev_profile_info == NULL)</a>
<a name="ln2699">    {</a>
<a name="ln2700">      fprintf(stderr, &quot;[dt_ioppr_build_iccprofile_params_cl] error allocating memory 5\n&quot;);</a>
<a name="ln2701">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2702">      goto cleanup;</a>
<a name="ln2703">    }</a>
<a name="ln2704"> </a>
<a name="ln2705">    dev_profile_lut = dt_opencl_copy_host_to_device(devid, profile_lut_cl, 256, 256 * 6, sizeof(float));</a>
<a name="ln2706">    if(dev_profile_lut == NULL)</a>
<a name="ln2707">    {</a>
<a name="ln2708">      fprintf(stderr, &quot;[dt_ioppr_build_iccprofile_params_cl] error allocating memory 6\n&quot;);</a>
<a name="ln2709">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2710">      goto cleanup;</a>
<a name="ln2711">    }</a>
<a name="ln2712">  }</a>
<a name="ln2713">  else</a>
<a name="ln2714">  {</a>
<a name="ln2715">    profile_lut_cl = malloc(1 * 6 * sizeof(cl_float));</a>
<a name="ln2716"> </a>
<a name="ln2717">    dev_profile_lut = dt_opencl_copy_host_to_device(devid, profile_lut_cl, 1, 1 * 6, sizeof(float));</a>
<a name="ln2718">    if(dev_profile_lut == NULL)</a>
<a name="ln2719">    {</a>
<a name="ln2720">      fprintf(stderr, &quot;[dt_ioppr_build_iccprofile_params_cl] error allocating memory 6\n&quot;);</a>
<a name="ln2721">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2722">      goto cleanup;</a>
<a name="ln2723">    }</a>
<a name="ln2724">  }</a>
<a name="ln2725"> </a>
<a name="ln2726">cleanup:</a>
<a name="ln2727">  *_profile_info_cl = profile_info_cl;</a>
<a name="ln2728">  *_profile_lut_cl = profile_lut_cl;</a>
<a name="ln2729">  *_dev_profile_info = dev_profile_info;</a>
<a name="ln2730">  *_dev_profile_lut = dev_profile_lut;</a>
<a name="ln2731"> </a>
<a name="ln2732">  return err;</a>
<a name="ln2733">}</a>
<a name="ln2734"> </a>
<a name="ln2735">void dt_ioppr_free_iccprofile_params_cl(dt_colorspaces_iccprofile_info_cl_t **_profile_info_cl,</a>
<a name="ln2736">                                        cl_float **_profile_lut_cl, cl_mem *_dev_profile_info,</a>
<a name="ln2737">                                        cl_mem *_dev_profile_lut)</a>
<a name="ln2738">{</a>
<a name="ln2739">  dt_colorspaces_iccprofile_info_cl_t *profile_info_cl = *_profile_info_cl;</a>
<a name="ln2740">  cl_float *profile_lut_cl = *_profile_lut_cl;</a>
<a name="ln2741">  cl_mem dev_profile_info = *_dev_profile_info;</a>
<a name="ln2742">  cl_mem dev_profile_lut = *_dev_profile_lut;</a>
<a name="ln2743"> </a>
<a name="ln2744">  if(profile_info_cl) free(profile_info_cl);</a>
<a name="ln2745">  if(dev_profile_info) dt_opencl_release_mem_object(dev_profile_info);</a>
<a name="ln2746">  if(dev_profile_lut) dt_opencl_release_mem_object(dev_profile_lut);</a>
<a name="ln2747">  if(profile_lut_cl) free(profile_lut_cl);</a>
<a name="ln2748"> </a>
<a name="ln2749">  *_profile_info_cl = NULL;</a>
<a name="ln2750">  *_profile_lut_cl = NULL;</a>
<a name="ln2751">  *_dev_profile_info = NULL;</a>
<a name="ln2752">  *_dev_profile_lut = NULL;</a>
<a name="ln2753">}</a>
<a name="ln2754"> </a>
<a name="ln2755">int dt_ioppr_transform_image_colorspace_cl(struct dt_iop_module_t *self, const int devid, cl_mem dev_img_in,</a>
<a name="ln2756">                                           cl_mem dev_img_out, const int width, const int height,</a>
<a name="ln2757">                                           const int cst_from, const int cst_to, int *converted_cst,</a>
<a name="ln2758">                                           const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2759">{</a>
<a name="ln2760">  cl_int err = CL_SUCCESS;</a>
<a name="ln2761"> </a>
<a name="ln2762">  if(cst_from == cst_to)</a>
<a name="ln2763">  {</a>
<a name="ln2764">    *converted_cst = cst_to;</a>
<a name="ln2765">    return TRUE;</a>
<a name="ln2766">  }</a>
<a name="ln2767">  if(profile_info == NULL)</a>
<a name="ln2768">  {</a>
<a name="ln2769">    fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] module %s must be between input color profile and output color profile\n&quot;, self-&gt;op);</a>
<a name="ln2770">    *converted_cst = cst_from;</a>
<a name="ln2771">    return FALSE;</a>
<a name="ln2772">  }</a>
<a name="ln2773">  if(profile_info-&gt;type == DT_COLORSPACE_NONE)</a>
<a name="ln2774">  {</a>
<a name="ln2775">    *converted_cst = cst_from;</a>
<a name="ln2776">    return FALSE;</a>
<a name="ln2777">  }</a>
<a name="ln2778"> </a>
<a name="ln2779">  const int ch = 4;</a>
<a name="ln2780">  float *src_buffer = NULL;</a>
<a name="ln2781">  int in_place = (dev_img_in == dev_img_out);</a>
<a name="ln2782"> </a>
<a name="ln2783">  int kernel_transform = 0;</a>
<a name="ln2784">  cl_mem dev_tmp = NULL;</a>
<a name="ln2785">  cl_mem dev_profile_info = NULL;</a>
<a name="ln2786">  cl_mem dev_lut = NULL;</a>
<a name="ln2787">  dt_colorspaces_iccprofile_info_cl_t profile_info_cl;</a>
<a name="ln2788">  cl_float *lut_cl = NULL;</a>
<a name="ln2789"> </a>
<a name="ln2790">  *converted_cst = cst_from;</a>
<a name="ln2791"> </a>
<a name="ln2792">  // if we have a matrix use opencl</a>
<a name="ln2793">  if(!isnan(profile_info-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln2794">  {</a>
<a name="ln2795">    dt_times_t start_time = { 0 }, end_time = { 0 };</a>
<a name="ln2796">    if(darktable.unmuted &amp; DT_DEBUG_PERF) dt_get_times(&amp;start_time);</a>
<a name="ln2797"> </a>
<a name="ln2798">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln2799">    size_t region[] = { width, height, 1 };</a>
<a name="ln2800"> </a>
<a name="ln2801">    if(cst_from == iop_cs_rgb &amp;&amp; cst_to == iop_cs_Lab)</a>
<a name="ln2802">    {</a>
<a name="ln2803">      kernel_transform = darktable.opencl-&gt;colorspaces-&gt;kernel_colorspaces_transform_rgb_matrix_to_lab;</a>
<a name="ln2804">    }</a>
<a name="ln2805">    else if(cst_from == iop_cs_Lab &amp;&amp; cst_to == iop_cs_rgb)</a>
<a name="ln2806">    {</a>
<a name="ln2807">      kernel_transform = darktable.opencl-&gt;colorspaces-&gt;kernel_colorspaces_transform_lab_to_rgb_matrix;</a>
<a name="ln2808">    }</a>
<a name="ln2809">    else</a>
<a name="ln2810">    {</a>
<a name="ln2811">      err = CL_INVALID_KERNEL;</a>
<a name="ln2812">      *converted_cst = cst_from;</a>
<a name="ln2813">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] invalid conversion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln2814">      goto cleanup;</a>
<a name="ln2815">    }</a>
<a name="ln2816"> </a>
<a name="ln2817">    dt_ioppr_get_profile_info_cl(profile_info, &amp;profile_info_cl);</a>
<a name="ln2818">    lut_cl = dt_ioppr_get_trc_cl(profile_info);</a>
<a name="ln2819"> </a>
<a name="ln2820">    if(in_place)</a>
<a name="ln2821">    {</a>
<a name="ln2822">      dev_tmp = dt_opencl_alloc_device(devid, width, height, 4 * sizeof(float));</a>
<a name="ln2823">      if(dev_tmp == NULL)</a>
<a name="ln2824">      {</a>
<a name="ln2825">        fprintf(stderr,</a>
<a name="ln2826">                &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 4\n&quot;);</a>
<a name="ln2827">        err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2828">        goto cleanup;</a>
<a name="ln2829">      }</a>
<a name="ln2830"> </a>
<a name="ln2831">      err = dt_opencl_enqueue_copy_image(devid, dev_img_in, dev_tmp, origin, origin, region);</a>
<a name="ln2832">      if(err != CL_SUCCESS)</a>
<a name="ln2833">      {</a>
<a name="ln2834">        fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error on copy image for color transformation\n&quot;);</a>
<a name="ln2835">        goto cleanup;</a>
<a name="ln2836">      }</a>
<a name="ln2837">    }</a>
<a name="ln2838">    else</a>
<a name="ln2839">    {</a>
<a name="ln2840">      dev_tmp = dev_img_in;</a>
<a name="ln2841">    }</a>
<a name="ln2842"> </a>
<a name="ln2843">    dev_profile_info = dt_opencl_copy_host_to_device_constant(devid, sizeof(profile_info_cl), &amp;profile_info_cl);</a>
<a name="ln2844">    if(dev_profile_info == NULL)</a>
<a name="ln2845">    {</a>
<a name="ln2846">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 5\n&quot;);</a>
<a name="ln2847">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2848">      goto cleanup;</a>
<a name="ln2849">    }</a>
<a name="ln2850">    dev_lut = dt_opencl_copy_host_to_device(devid, lut_cl, 256, 256 * 6, sizeof(float));</a>
<a name="ln2851">    if(dev_lut == NULL)</a>
<a name="ln2852">    {</a>
<a name="ln2853">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 6\n&quot;);</a>
<a name="ln2854">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2855">      goto cleanup;</a>
<a name="ln2856">    }</a>
<a name="ln2857"> </a>
<a name="ln2858">    size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln2859"> </a>
<a name="ln2860">    dt_opencl_set_kernel_arg(devid, kernel_transform, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln2861">    dt_opencl_set_kernel_arg(devid, kernel_transform, 1, sizeof(cl_mem), (void *)&amp;dev_img_out);</a>
<a name="ln2862">    dt_opencl_set_kernel_arg(devid, kernel_transform, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln2863">    dt_opencl_set_kernel_arg(devid, kernel_transform, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln2864">    dt_opencl_set_kernel_arg(devid, kernel_transform, 4, sizeof(cl_mem), (void *)&amp;dev_profile_info);</a>
<a name="ln2865">    dt_opencl_set_kernel_arg(devid, kernel_transform, 5, sizeof(cl_mem), (void *)&amp;dev_lut);</a>
<a name="ln2866">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_transform, sizes);</a>
<a name="ln2867">    if(err != CL_SUCCESS)</a>
<a name="ln2868">    {</a>
<a name="ln2869">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error %i enqueue kernel for color transformation\n&quot;, err);</a>
<a name="ln2870">      goto cleanup;</a>
<a name="ln2871">    }</a>
<a name="ln2872"> </a>
<a name="ln2873">    *converted_cst = cst_to;</a>
<a name="ln2874"> </a>
<a name="ln2875">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2876">    {</a>
<a name="ln2877">      dt_get_times(&amp;end_time);</a>
<a name="ln2878">      fprintf(stderr, &quot;image colorspace transform %s--&gt;%s took %.3f secs (%.3f GPU) [%s %s]\n&quot;,</a>
<a name="ln2879">          (cst_from == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;, (cst_to == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;,</a>
<a name="ln2880">          end_time.clock - start_time.clock, end_time.user - start_time.user, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln2881">    }</a>
<a name="ln2882">  }</a>
<a name="ln2883">  else</a>
<a name="ln2884">  {</a>
<a name="ln2885">    // no matrix, call lcms2</a>
<a name="ln2886">    src_buffer = dt_alloc_align(64, width * height * ch * sizeof(float));</a>
<a name="ln2887">    if(src_buffer == NULL)</a>
<a name="ln2888">    {</a>
<a name="ln2889">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 1\n&quot;);</a>
<a name="ln2890">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2891">      goto cleanup;</a>
<a name="ln2892">    }</a>
<a name="ln2893"> </a>
<a name="ln2894">    err = dt_opencl_copy_device_to_host(devid, src_buffer, dev_img_in, width, height, ch * sizeof(float));</a>
<a name="ln2895">    if(err != CL_SUCCESS)</a>
<a name="ln2896">    {</a>
<a name="ln2897">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 2\n&quot;);</a>
<a name="ln2898">      goto cleanup;</a>
<a name="ln2899">    }</a>
<a name="ln2900"> </a>
<a name="ln2901">    // just call the CPU version for now</a>
<a name="ln2902">    dt_ioppr_transform_image_colorspace(self, src_buffer, src_buffer, width, height, cst_from, cst_to,</a>
<a name="ln2903">                                        converted_cst, profile_info);</a>
<a name="ln2904"> </a>
<a name="ln2905">    err = dt_opencl_write_host_to_device(devid, src_buffer, dev_img_out, width, height, ch * sizeof(float));</a>
<a name="ln2906">    if(err != CL_SUCCESS)</a>
<a name="ln2907">    {</a>
<a name="ln2908">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 3\n&quot;);</a>
<a name="ln2909">      goto cleanup;</a>
<a name="ln2910">    }</a>
<a name="ln2911">  }</a>
<a name="ln2912"> </a>
<a name="ln2913">cleanup:</a>
<a name="ln2914">  if(src_buffer) dt_free_align(src_buffer);</a>
<a name="ln2915">  if(dev_tmp &amp;&amp; in_place) dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln2916">  if(dev_profile_info) dt_opencl_release_mem_object(dev_profile_info);</a>
<a name="ln2917">  if(dev_lut) dt_opencl_release_mem_object(dev_lut);</a>
<a name="ln2918">  if(lut_cl) free(lut_cl);</a>
<a name="ln2919"> </a>
<a name="ln2920">  return (err == CL_SUCCESS) ? TRUE : FALSE;</a>
<a name="ln2921">}</a>
<a name="ln2922"> </a>
<a name="ln2923">int dt_ioppr_transform_image_colorspace_rgb_cl(const int devid, cl_mem dev_img_in, cl_mem dev_img_out,</a>
<a name="ln2924">                                               const int width, const int height,</a>
<a name="ln2925">                                               const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln2926">                                               const dt_iop_order_iccprofile_info_t *const profile_info_to,</a>
<a name="ln2927">                                               const char *message)</a>
<a name="ln2928">{</a>
<a name="ln2929">  cl_int err = CL_SUCCESS;</a>
<a name="ln2930"> </a>
<a name="ln2931">  if(profile_info_from-&gt;type == DT_COLORSPACE_NONE || profile_info_to-&gt;type == DT_COLORSPACE_NONE)</a>
<a name="ln2932">  {</a>
<a name="ln2933">    return FALSE;</a>
<a name="ln2934">  }</a>
<a name="ln2935">  if(profile_info_from-&gt;type == profile_info_to-&gt;type</a>
<a name="ln2936">     &amp;&amp; strcmp(profile_info_from-&gt;filename, profile_info_to-&gt;filename) == 0)</a>
<a name="ln2937">  {</a>
<a name="ln2938">    if(dev_img_in != dev_img_out)</a>
<a name="ln2939">    {</a>
<a name="ln2940">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln2941">      size_t region[] = { width, height, 1 };</a>
<a name="ln2942"> </a>
<a name="ln2943">      err = dt_opencl_enqueue_copy_image(devid, dev_img_in, dev_img_out, origin, origin, region);</a>
<a name="ln2944">      if(err != CL_SUCCESS)</a>
<a name="ln2945">      {</a>
<a name="ln2946">        fprintf(stderr,</a>
<a name="ln2947">                &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error on copy image for color transformation\n&quot;);</a>
<a name="ln2948">        return FALSE;</a>
<a name="ln2949">      }</a>
<a name="ln2950">    }</a>
<a name="ln2951"> </a>
<a name="ln2952">    return TRUE;</a>
<a name="ln2953">  }</a>
<a name="ln2954"> </a>
<a name="ln2955">  const int ch = 4;</a>
<a name="ln2956">  float *src_buffer = NULL;</a>
<a name="ln2957">  int in_place = (dev_img_in == dev_img_out);</a>
<a name="ln2958"> </a>
<a name="ln2959">  int kernel_transform = 0;</a>
<a name="ln2960">  cl_mem dev_tmp = NULL;</a>
<a name="ln2961"> </a>
<a name="ln2962">  cl_mem dev_profile_info_from = NULL;</a>
<a name="ln2963">  cl_mem dev_lut_from = NULL;</a>
<a name="ln2964">  dt_colorspaces_iccprofile_info_cl_t profile_info_from_cl;</a>
<a name="ln2965">  cl_float *lut_from_cl = NULL;</a>
<a name="ln2966"> </a>
<a name="ln2967">  cl_mem dev_profile_info_to = NULL;</a>
<a name="ln2968">  cl_mem dev_lut_to = NULL;</a>
<a name="ln2969">  dt_colorspaces_iccprofile_info_cl_t profile_info_to_cl;</a>
<a name="ln2970">  cl_float *lut_to_cl = NULL;</a>
<a name="ln2971"> </a>
<a name="ln2972">  // if we have a matrix use opencl</a>
<a name="ln2973">  if(!isnan(profile_info_from-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info_from-&gt;matrix_out[0])</a>
<a name="ln2974">     &amp;&amp; !isnan(profile_info_to-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info_to-&gt;matrix_out[0]))</a>
<a name="ln2975">  {</a>
<a name="ln2976">    dt_times_t start_time = { 0 }, end_time = { 0 };</a>
<a name="ln2977">    if(darktable.unmuted &amp; DT_DEBUG_PERF) dt_get_times(&amp;start_time);</a>
<a name="ln2978"> </a>
<a name="ln2979">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln2980">    size_t region[] = { width, height, 1 };</a>
<a name="ln2981"> </a>
<a name="ln2982">    kernel_transform = darktable.opencl-&gt;colorspaces-&gt;kernel_colorspaces_transform_rgb_matrix_to_rgb;</a>
<a name="ln2983"> </a>
<a name="ln2984">    dt_ioppr_get_profile_info_cl(profile_info_from, &amp;profile_info_from_cl);</a>
<a name="ln2985">    lut_from_cl = dt_ioppr_get_trc_cl(profile_info_from);</a>
<a name="ln2986"> </a>
<a name="ln2987">    dt_ioppr_get_profile_info_cl(profile_info_to, &amp;profile_info_to_cl);</a>
<a name="ln2988">    lut_to_cl = dt_ioppr_get_trc_cl(profile_info_to);</a>
<a name="ln2989"> </a>
<a name="ln2990">    if(in_place)</a>
<a name="ln2991">    {</a>
<a name="ln2992">      dev_tmp = dt_opencl_alloc_device(devid, width, height, 4 * sizeof(float));</a>
<a name="ln2993">      if(dev_tmp == NULL)</a>
<a name="ln2994">      {</a>
<a name="ln2995">        fprintf(</a>
<a name="ln2996">            stderr,</a>
<a name="ln2997">            &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 4\n&quot;);</a>
<a name="ln2998">        err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2999">        goto cleanup;</a>
<a name="ln3000">      }</a>
<a name="ln3001"> </a>
<a name="ln3002">      err = dt_opencl_enqueue_copy_image(devid, dev_img_in, dev_tmp, origin, origin, region);</a>
<a name="ln3003">      if(err != CL_SUCCESS)</a>
<a name="ln3004">      {</a>
<a name="ln3005">        fprintf(stderr,</a>
<a name="ln3006">                &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error on copy image for color transformation\n&quot;);</a>
<a name="ln3007">        goto cleanup;</a>
<a name="ln3008">      }</a>
<a name="ln3009">    }</a>
<a name="ln3010">    else</a>
<a name="ln3011">    {</a>
<a name="ln3012">      dev_tmp = dev_img_in;</a>
<a name="ln3013">    }</a>
<a name="ln3014"> </a>
<a name="ln3015">    dev_profile_info_from</a>
<a name="ln3016">        = dt_opencl_copy_host_to_device_constant(devid, sizeof(profile_info_from_cl), &amp;profile_info_from_cl);</a>
<a name="ln3017">    if(dev_profile_info_from == NULL)</a>
<a name="ln3018">    {</a>
<a name="ln3019">      fprintf(stderr,</a>
<a name="ln3020">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 5\n&quot;);</a>
<a name="ln3021">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3022">      goto cleanup;</a>
<a name="ln3023">    }</a>
<a name="ln3024">    dev_lut_from = dt_opencl_copy_host_to_device(devid, lut_from_cl, 256, 256 * 6, sizeof(float));</a>
<a name="ln3025">    if(dev_lut_from == NULL)</a>
<a name="ln3026">    {</a>
<a name="ln3027">      fprintf(stderr,</a>
<a name="ln3028">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 6\n&quot;);</a>
<a name="ln3029">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3030">      goto cleanup;</a>
<a name="ln3031">    }</a>
<a name="ln3032"> </a>
<a name="ln3033">    dev_profile_info_to</a>
<a name="ln3034">        = dt_opencl_copy_host_to_device_constant(devid, sizeof(profile_info_to_cl), &amp;profile_info_to_cl);</a>
<a name="ln3035">    if(dev_profile_info_to == NULL)</a>
<a name="ln3036">    {</a>
<a name="ln3037">      fprintf(stderr,</a>
<a name="ln3038">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 7\n&quot;);</a>
<a name="ln3039">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3040">      goto cleanup;</a>
<a name="ln3041">    }</a>
<a name="ln3042">    dev_lut_to = dt_opencl_copy_host_to_device(devid, lut_to_cl, 256, 256 * 6, sizeof(float));</a>
<a name="ln3043">    if(dev_lut_to == NULL)</a>
<a name="ln3044">    {</a>
<a name="ln3045">      fprintf(stderr,</a>
<a name="ln3046">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 8\n&quot;);</a>
<a name="ln3047">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3048">      goto cleanup;</a>
<a name="ln3049">    }</a>
<a name="ln3050"> </a>
<a name="ln3051">    size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3052"> </a>
<a name="ln3053">    dt_opencl_set_kernel_arg(devid, kernel_transform, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3054">    dt_opencl_set_kernel_arg(devid, kernel_transform, 1, sizeof(cl_mem), (void *)&amp;dev_img_out);</a>
<a name="ln3055">    dt_opencl_set_kernel_arg(devid, kernel_transform, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3056">    dt_opencl_set_kernel_arg(devid, kernel_transform, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3057">    dt_opencl_set_kernel_arg(devid, kernel_transform, 4, sizeof(cl_mem), (void *)&amp;dev_profile_info_from);</a>
<a name="ln3058">    dt_opencl_set_kernel_arg(devid, kernel_transform, 5, sizeof(cl_mem), (void *)&amp;dev_lut_from);</a>
<a name="ln3059">    dt_opencl_set_kernel_arg(devid, kernel_transform, 6, sizeof(cl_mem), (void *)&amp;dev_profile_info_to);</a>
<a name="ln3060">    dt_opencl_set_kernel_arg(devid, kernel_transform, 7, sizeof(cl_mem), (void *)&amp;dev_lut_to);</a>
<a name="ln3061">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_transform, sizes);</a>
<a name="ln3062">    if(err != CL_SUCCESS)</a>
<a name="ln3063">    {</a>
<a name="ln3064">      fprintf(stderr,</a>
<a name="ln3065">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error %i enqueue kernel for color transformation\n&quot;,</a>
<a name="ln3066">              err);</a>
<a name="ln3067">      goto cleanup;</a>
<a name="ln3068">    }</a>
<a name="ln3069"> </a>
<a name="ln3070">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln3071">    {</a>
<a name="ln3072">      dt_get_times(&amp;end_time);</a>
<a name="ln3073">      fprintf(stderr, &quot;image colorspace transform RGB--&gt;RGB took %.3f secs (%.3f GPU) [%s]\n&quot;,</a>
<a name="ln3074">              end_time.clock - start_time.clock, end_time.user - start_time.user, (message) ? message : &quot;&quot;);</a>
<a name="ln3075">    }</a>
<a name="ln3076">  }</a>
<a name="ln3077">  else</a>
<a name="ln3078">  {</a>
<a name="ln3079">    // no matrix, call lcms2</a>
<a name="ln3080">    src_buffer = dt_alloc_align(64, width * height * ch * sizeof(float));</a>
<a name="ln3081">    if(src_buffer == NULL)</a>
<a name="ln3082">    {</a>
<a name="ln3083">      fprintf(stderr,</a>
<a name="ln3084">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 1\n&quot;);</a>
<a name="ln3085">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3086">      goto cleanup;</a>
<a name="ln3087">    }</a>
<a name="ln3088"> </a>
<a name="ln3089">    err = dt_opencl_copy_device_to_host(devid, src_buffer, dev_img_in, width, height, ch * sizeof(float));</a>
<a name="ln3090">    if(err != CL_SUCCESS)</a>
<a name="ln3091">    {</a>
<a name="ln3092">      fprintf(stderr,</a>
<a name="ln3093">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 2\n&quot;);</a>
<a name="ln3094">      goto cleanup;</a>
<a name="ln3095">    }</a>
<a name="ln3096"> </a>
<a name="ln3097">    // just call the CPU version for now</a>
<a name="ln3098">    dt_ioppr_transform_image_colorspace_rgb(src_buffer, src_buffer, width, height, profile_info_from,</a>
<a name="ln3099">                                            profile_info_to, message);</a>
<a name="ln3100"> </a>
<a name="ln3101">    err = dt_opencl_write_host_to_device(devid, src_buffer, dev_img_out, width, height, ch * sizeof(float));</a>
<a name="ln3102">    if(err != CL_SUCCESS)</a>
<a name="ln3103">    {</a>
<a name="ln3104">      fprintf(stderr,</a>
<a name="ln3105">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 3\n&quot;);</a>
<a name="ln3106">      goto cleanup;</a>
<a name="ln3107">    }</a>
<a name="ln3108">  }</a>
<a name="ln3109"> </a>
<a name="ln3110">cleanup:</a>
<a name="ln3111">  if(src_buffer) dt_free_align(src_buffer);</a>
<a name="ln3112">  if(dev_tmp &amp;&amp; in_place) dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3113"> </a>
<a name="ln3114">  if(dev_profile_info_from) dt_opencl_release_mem_object(dev_profile_info_from);</a>
<a name="ln3115">  if(dev_lut_from) dt_opencl_release_mem_object(dev_lut_from);</a>
<a name="ln3116">  if(lut_from_cl) free(lut_from_cl);</a>
<a name="ln3117"> </a>
<a name="ln3118">  if(dev_profile_info_to) dt_opencl_release_mem_object(dev_profile_info_to);</a>
<a name="ln3119">  if(dev_lut_to) dt_opencl_release_mem_object(dev_lut_to);</a>
<a name="ln3120">  if(lut_to_cl) free(lut_to_cl);</a>
<a name="ln3121"> </a>
<a name="ln3122">  return (err == CL_SUCCESS) ? TRUE : FALSE;</a>
<a name="ln3123">}</a>
<a name="ln3124">#endif</a>

</code></pre>
<div class="balloon" rel="98"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'rule'. Check lines: 98, 96.</p></div>
<div class="balloon" rel="193"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'order_entry'. Check lines: 193, 191.</p></div>
<div class="balloon" rel="249"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'iop_order_new'. Check lines: 249, 248.</p></div>
<div class="balloon" rel="687"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 687, 686.</p></div>
<div class="balloon" rel="1710"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'width * height' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="1788"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'width * height' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="1907"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'profile_info->lut_in[i]'. Check lines: 1907, 1906.</p></div>
<div class="balloon" rel="1909"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'profile_info->lut_out[i]'. Check lines: 1909, 1908.</p></div>
<div class="balloon" rel="1894"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> Dereferencing of the null pointer 'profile_info' might take place. The potential null pointer is passed into 'dt_ioppr_init_profile_info' function. Inspect the first argument. Check lines: 1894, 2049, 2048.</p></div>
<div class="balloon" rel="2625"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 2625, 2622.</p></div>
<div class="balloon" rel="2648"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> Dereferencing of the null pointer 'profile_info_cl' might take place. The potential null pointer is passed into 'dt_ioppr_get_profile_info_cl' function. Inspect the second argument. Check lines: 2648, 2694, 2687.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
