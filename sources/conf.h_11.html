
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#pragma once</a>
<a name="ln20"> </a>
<a name="ln21">#ifdef HAVE_CONFIG_H</a>
<a name="ln22">#include &quot;config.h&quot;</a>
<a name="ln23">#endif</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;common/calculator.h&quot;</a>
<a name="ln26">#include &quot;common/darktable.h&quot;</a>
<a name="ln27">#include &quot;common/file_location.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;glib.h&gt;</a>
<a name="ln30">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln31">#include &lt;glib/gprintf.h&gt;</a>
<a name="ln32">#include &lt;inttypes.h&gt;</a>
<a name="ln33">#include &lt;stdio.h&gt;</a>
<a name="ln34">#include &lt;stdlib.h&gt;</a>
<a name="ln35">#include &lt;strings.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">typedef struct dt_conf_t</a>
<a name="ln38">{</a>
<a name="ln39">  dt_pthread_mutex_t mutex;</a>
<a name="ln40">  char filename[PATH_MAX];</a>
<a name="ln41">  GHashTable *table;</a>
<a name="ln42">  GHashTable *defaults;</a>
<a name="ln43">  GHashTable *override_entries;</a>
<a name="ln44">} dt_conf_t;</a>
<a name="ln45"> </a>
<a name="ln46">typedef struct dt_conf_string_entry_t</a>
<a name="ln47">{</a>
<a name="ln48">  char *key;</a>
<a name="ln49">  char *value;</a>
<a name="ln50">} dt_conf_string_entry_t;</a>
<a name="ln51"> </a>
<a name="ln52">typedef struct dt_conf_dreggn_t</a>
<a name="ln53">{</a>
<a name="ln54">  GSList *result;</a>
<a name="ln55">  const char *match;</a>
<a name="ln56">} dt_conf_dreggn_t;</a>
<a name="ln57"> </a>
<a name="ln58">/** return slot for this variable or newly allocated slot. */</a>
<a name="ln59">static inline char *dt_conf_get_var(const char *name)</a>
<a name="ln60">{</a>
<a name="ln61">  char *str = (char *)g_hash_table_lookup(darktable.conf-&gt;override_entries, name);</a>
<a name="ln62">  if(str) return str;</a>
<a name="ln63"> </a>
<a name="ln64">  str = (char *)g_hash_table_lookup(darktable.conf-&gt;table, name);</a>
<a name="ln65">  if(str) return str;</a>
<a name="ln66"> </a>
<a name="ln67">  // not found, try defaults</a>
<a name="ln68">  str = (char *)g_hash_table_lookup(darktable.conf-&gt;defaults, name);</a>
<a name="ln69">  if(str)</a>
<a name="ln70">  {</a>
<a name="ln71">    g_hash_table_insert(darktable.conf-&gt;table, g_strdup(name), g_strdup(str));</a>
<a name="ln72">    // and try again:</a>
<a name="ln73">    return dt_conf_get_var(name);</a>
<a name="ln74">  }</a>
<a name="ln75"> </a>
<a name="ln76">  // still no luck? insert garbage:</a>
<a name="ln77">  char *garbage = (char *)g_malloc0(sizeof(int32_t));</a>
<a name="ln78">  g_hash_table_insert(darktable.conf-&gt;table, g_strdup(name), garbage);</a>
<a name="ln79">  return garbage;</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">/** return if key/value is still the one passed on commandline. */</a>
<a name="ln83">static inline int dt_conf_is_still_overridden(const char *name, const char *value)</a>
<a name="ln84">{</a>
<a name="ln85">  char *over = (char *)g_hash_table_lookup(darktable.conf-&gt;override_entries, name);</a>
<a name="ln86">  return (over &amp;&amp; !strcmp(value, over));</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">static inline void dt_conf_set_int(const char *name, int val)</a>
<a name="ln90">{</a>
<a name="ln91">  dt_pthread_mutex_lock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln92">  char *str = g_strdup_printf(&quot;%d&quot;, val);</a>
<a name="ln93">  if(!dt_conf_is_still_overridden(name, str))</a>
<a name="ln94">    g_hash_table_insert(darktable.conf-&gt;table, g_strdup(name), str);</a>
<a name="ln95">  else</a>
<a name="ln96">    g_free(str);</a>
<a name="ln97">  dt_pthread_mutex_unlock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">static inline void dt_conf_set_int64(const char *name, int64_t val)</a>
<a name="ln101">{</a>
<a name="ln102">  dt_pthread_mutex_lock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln103">  char *str = g_strdup_printf(&quot;%&quot; PRId64, val);</a>
<a name="ln104">  if(!dt_conf_is_still_overridden(name, str))</a>
<a name="ln105">    g_hash_table_insert(darktable.conf-&gt;table, g_strdup(name), str);</a>
<a name="ln106">  else</a>
<a name="ln107">    g_free(str);</a>
<a name="ln108">  dt_pthread_mutex_unlock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">static inline void dt_conf_set_float(const char *name, float val)</a>
<a name="ln112">{</a>
<a name="ln113">  dt_pthread_mutex_lock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln114">  char *str = (char *)g_malloc(G_ASCII_DTOSTR_BUF_SIZE);</a>
<a name="ln115">  g_ascii_dtostr(str, G_ASCII_DTOSTR_BUF_SIZE, val);</a>
<a name="ln116">  if(!dt_conf_is_still_overridden(name, str))</a>
<a name="ln117">    g_hash_table_insert(darktable.conf-&gt;table, g_strdup(name), str);</a>
<a name="ln118">  else</a>
<a name="ln119">    g_free(str);</a>
<a name="ln120">  dt_pthread_mutex_unlock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">static inline void dt_conf_set_bool(const char *name, int val)</a>
<a name="ln124">{</a>
<a name="ln125">  dt_pthread_mutex_lock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln126">  char *str = g_strdup_printf(&quot;%s&quot;, val ? &quot;TRUE&quot; : &quot;FALSE&quot;);</a>
<a name="ln127">  if(!dt_conf_is_still_overridden(name, str))</a>
<a name="ln128">    g_hash_table_insert(darktable.conf-&gt;table, g_strdup(name), str);</a>
<a name="ln129">  else</a>
<a name="ln130">    g_free(str);</a>
<a name="ln131">  dt_pthread_mutex_unlock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">static inline void dt_conf_set_string(const char *name, const char *val)</a>
<a name="ln135">{</a>
<a name="ln136">  dt_pthread_mutex_lock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln137">  if(!dt_conf_is_still_overridden(name, val))</a>
<a name="ln138">    g_hash_table_insert(darktable.conf-&gt;table, g_strdup(name), g_strdup(val));</a>
<a name="ln139">  dt_pthread_mutex_unlock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">static inline int dt_conf_get_int(const char *name)</a>
<a name="ln143">{</a>
<a name="ln144">  dt_pthread_mutex_lock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln145">  const char *str = dt_conf_get_var(name);</a>
<a name="ln146">  float new_value = dt_calculator_solve(1, str);</a>
<a name="ln147">  if(isnan(new_value)) new_value = 0.0;</a>
<a name="ln148">  int val;</a>
<a name="ln149">  if(new_value &gt; 0)</a>
<a name="ln150">    val = new_value + 0.5;</a>
<a name="ln151">  else</a>
<a name="ln152">    val = new_value - 0.5;</a>
<a name="ln153">  dt_pthread_mutex_unlock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln154">  return val;</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">static inline int64_t dt_conf_get_int64(const char *name)</a>
<a name="ln158">{</a>
<a name="ln159">  dt_pthread_mutex_lock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln160">  const char *str = dt_conf_get_var(name);</a>
<a name="ln161">  float new_value = dt_calculator_solve(1, str);</a>
<a name="ln162">  if(isnan(new_value)) new_value = 0.0;</a>
<a name="ln163">  int64_t val;</a>
<a name="ln164">  if(new_value &gt; 0)</a>
<a name="ln165">    val = new_value + 0.5;</a>
<a name="ln166">  else</a>
<a name="ln167">    val = new_value - 0.5;</a>
<a name="ln168">  dt_pthread_mutex_unlock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln169">  return val;</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">static inline float dt_conf_get_float(const char *name)</a>
<a name="ln173">{</a>
<a name="ln174">  dt_pthread_mutex_lock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln175">  const char *str = dt_conf_get_var(name);</a>
<a name="ln176">  float val = dt_calculator_solve(1, str);</a>
<a name="ln177">  if(isnan(val)) val = 0.0;</a>
<a name="ln178">  dt_pthread_mutex_unlock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln179">  return val;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">static inline int dt_conf_get_bool(const char *name)</a>
<a name="ln183">{</a>
<a name="ln184">  dt_pthread_mutex_lock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln185">  const char *str = dt_conf_get_var(name);</a>
<a name="ln186">  const int val = (str[0] == 'T') || (str[0] == 't');</a>
<a name="ln187">  dt_pthread_mutex_unlock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln188">  return val;</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">static inline gchar *dt_conf_get_string(const char *name)</a>
<a name="ln192">{</a>
<a name="ln193">  dt_pthread_mutex_lock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln194">  const char *str = dt_conf_get_var(name);</a>
<a name="ln195">  dt_pthread_mutex_unlock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln196">  return g_strdup(str);</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">static inline void dt_conf_init(dt_conf_t *cf, const char *filename, GSList *override_entries)</a>
<a name="ln200">{</a>
<a name="ln201">  cf-&gt;table = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);</a>
<a name="ln202">  cf-&gt;defaults = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);</a>
<a name="ln203">  cf-&gt;override_entries = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);</a>
<a name="ln204">  dt_pthread_mutex_init(&amp;darktable.conf-&gt;mutex, NULL);</a>
<a name="ln205">  FILE *f = 0;</a>
<a name="ln206"> </a>
<a name="ln207">#define LINE_SIZE 1023</a>
<a name="ln208"> </a>
<a name="ln209">  char line[LINE_SIZE + 1];</a>
<a name="ln210"> </a>
<a name="ln211">  int read = 0;</a>
<a name="ln212">  int defaults = 0;</a>
<a name="ln213">  for(int i = 0; i &lt; 2; i++)</a>
<a name="ln214">  {</a>
<a name="ln215">    // TODO: read default darktablerc into -&gt;defaults and other into -&gt;table!</a>
<a name="ln216">    if(!i)</a>
<a name="ln217">    {</a>
<a name="ln218">      snprintf(darktable.conf-&gt;filename, sizeof(darktable.conf-&gt;filename), &quot;%s&quot;, filename);</a>
<a name="ln219">      f = g_fopen(filename, &quot;rb&quot;);</a>
<a name="ln220">      if(!f)</a>
<a name="ln221">      {</a>
<a name="ln222">        // remember we init to default rc and try again</a>
<a name="ln223">        defaults = 1;</a>
<a name="ln224">        continue;</a>
<a name="ln225">      }</a>
<a name="ln226">    }</a>
<a name="ln227">    if(i)</a>
<a name="ln228">    {</a>
<a name="ln229">      char buf[PATH_MAX] = { 0 }, defaultrc[PATH_MAX] = { 0 };</a>
<a name="ln230">      dt_loc_get_datadir(buf, sizeof(buf));</a>
<a name="ln231">      snprintf(defaultrc, sizeof(defaultrc), &quot;%s/darktablerc&quot;, buf);</a>
<a name="ln232">      f = g_fopen(defaultrc, &quot;rb&quot;);</a>
<a name="ln233">    }</a>
<a name="ln234">    if(!f) return;</a>
<a name="ln235">    while(!feof(f))</a>
<a name="ln236">    {</a>
<a name="ln237">      read = fscanf(f, &quot;%&quot; STR(LINE_SIZE) &quot;[^\r\n]\r\n&quot;, line);</a>
<a name="ln238">      if(read &gt; 0)</a>
<a name="ln239">      {</a>
<a name="ln240">        char *c = line;</a>
<a name="ln241">        char *end = line + strlen(line);</a>
<a name="ln242">        while(*c != '=' &amp;&amp; c &lt; end) c++;</a>
<a name="ln243">        if(*c == '=')</a>
<a name="ln244">        {</a>
<a name="ln245">          *c = '\0';</a>
<a name="ln246">          if(i) g_hash_table_insert(darktable.conf-&gt;defaults, g_strdup(line), g_strdup(c + 1));</a>
<a name="ln247">          if(!i || defaults) g_hash_table_insert(darktable.conf-&gt;table, g_strdup(line), g_strdup(c + 1));</a>
<a name="ln248">        }</a>
<a name="ln249">      }</a>
<a name="ln250">    }</a>
<a name="ln251">    fclose(f);</a>
<a name="ln252">  }</a>
<a name="ln253"> </a>
<a name="ln254">  // for the very first time after a fresh install</a>
<a name="ln255">  // execute performance configuration no matter what</a>
<a name="ln256">  if(defaults)</a>
<a name="ln257">    dt_configure_performance();</a>
<a name="ln258"> </a>
<a name="ln259">  if(override_entries)</a>
<a name="ln260">  {</a>
<a name="ln261">    GSList *p = override_entries;</a>
<a name="ln262">    while(p)</a>
<a name="ln263">    {</a>
<a name="ln264">      dt_conf_string_entry_t *entry = (dt_conf_string_entry_t *)p-&gt;data;</a>
<a name="ln265">      g_hash_table_insert(darktable.conf-&gt;override_entries, entry-&gt;key, entry-&gt;value);</a>
<a name="ln266">      p = g_slist_next(p);</a>
<a name="ln267">    }</a>
<a name="ln268">  }</a>
<a name="ln269"> </a>
<a name="ln270">#undef LINE_SIZE</a>
<a name="ln271"> </a>
<a name="ln272">  return;</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">static void dt_conf_print(const gchar *key, const gchar *val, FILE *f)</a>
<a name="ln276">{</a>
<a name="ln277">  fprintf(f, &quot;%s=%s\n&quot;, key, val);</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">static inline void dt_conf_cleanup(dt_conf_t *cf)</a>
<a name="ln281">{</a>
<a name="ln282">  FILE *f = g_fopen(cf-&gt;filename, &quot;wb&quot;);</a>
<a name="ln283">  if(f)</a>
<a name="ln284">  {</a>
<a name="ln285">    GList *keys = g_hash_table_get_keys(cf-&gt;table);</a>
<a name="ln286">    GList *sorted = g_list_sort(keys, (GCompareFunc)g_strcmp0);</a>
<a name="ln287"> </a>
<a name="ln288">    GList *iter = sorted;</a>
<a name="ln289"> </a>
<a name="ln290">    while(iter)</a>
<a name="ln291">    {</a>
<a name="ln292">      const gchar *key = (const gchar *)iter-&gt;data;</a>
<a name="ln293">      const gchar *val = (const gchar *)g_hash_table_lookup(cf-&gt;table, key);</a>
<a name="ln294">      dt_conf_print(key, val, f);</a>
<a name="ln295">      iter = g_list_next(iter);</a>
<a name="ln296">    }</a>
<a name="ln297"> </a>
<a name="ln298">    g_list_free(sorted);</a>
<a name="ln299">    fclose(f);</a>
<a name="ln300">  }</a>
<a name="ln301">  g_hash_table_unref(cf-&gt;table);</a>
<a name="ln302">  g_hash_table_unref(cf-&gt;defaults);</a>
<a name="ln303">  g_hash_table_unref(cf-&gt;override_entries);</a>
<a name="ln304">  dt_pthread_mutex_destroy(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">/** check if key exists, return 1 if lookup successed, 0 if failed..*/</a>
<a name="ln308">static inline int dt_conf_key_exists(const char *key)</a>
<a name="ln309">{</a>
<a name="ln310">  dt_pthread_mutex_lock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln311">  const int res = (g_hash_table_lookup(darktable.conf-&gt;table, key) != NULL)</a>
<a name="ln312">                  || (g_hash_table_lookup(darktable.conf-&gt;override_entries, key) != NULL);</a>
<a name="ln313">  dt_pthread_mutex_unlock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln314">  return res;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">static void _conf_add(char *key, char *val, dt_conf_dreggn_t *d)</a>
<a name="ln318">{</a>
<a name="ln319">  if(strncmp(key, d-&gt;match, strlen(d-&gt;match)) == 0)</a>
<a name="ln320">  {</a>
<a name="ln321">    dt_conf_string_entry_t *nv = (dt_conf_string_entry_t *)g_malloc(sizeof(dt_conf_string_entry_t));</a>
<a name="ln322">    nv-&gt;key = g_strdup(key + strlen(d-&gt;match) + 1);</a>
<a name="ln323">    nv-&gt;value = g_strdup(val);</a>
<a name="ln324">    d-&gt;result = g_slist_append(d-&gt;result, nv);</a>
<a name="ln325">  }</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">/** get all strings in */</a>
<a name="ln329">static inline GSList *dt_conf_all_string_entries(const char *dir)</a>
<a name="ln330">{</a>
<a name="ln331">  dt_pthread_mutex_lock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln332">  dt_conf_dreggn_t d;</a>
<a name="ln333">  d.result = NULL;</a>
<a name="ln334">  d.match = dir;</a>
<a name="ln335">  g_hash_table_foreach(darktable.conf-&gt;table, (GHFunc)_conf_add, &amp;d);</a>
<a name="ln336">  dt_pthread_mutex_unlock(&amp;darktable.conf-&gt;mutex);</a>
<a name="ln337">  return d.result;</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340">static inline void dt_conf_string_entry_free(gpointer data)</a>
<a name="ln341">{</a>
<a name="ln342">  dt_conf_string_entry_t *nv = (dt_conf_string_entry_t *)data;</a>
<a name="ln343">  g_free(nv-&gt;key);</a>
<a name="ln344">  g_free(nv-&gt;value);</a>
<a name="ln345">  nv-&gt;key = NULL;</a>
<a name="ln346">  nv-&gt;value = NULL;</a>
<a name="ln347">  g_free(nv);</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln351">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln352">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="201"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> Dereferencing of the null pointer 'cf' might take place. The potential null pointer is passed into 'dt_conf_init' function. Inspect the first argument. Check lines: 'conf.h:201', 'darktable.c:760', 'darktable.c:759'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
