
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 henrik andersson.</a>
<a name="ln4">    copyright (c) 2011--2014 Ulrich Pegelow.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;blend.h&quot;</a>
<a name="ln20">#include &quot;common/gaussian.h&quot;</a>
<a name="ln21">#include &quot;common/guided_filter.h&quot;</a>
<a name="ln22">#include &quot;common/math.h&quot;</a>
<a name="ln23">#include &quot;common/opencl.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;develop/imageop.h&quot;</a>
<a name="ln26">#include &quot;develop/masks.h&quot;</a>
<a name="ln27">#include &quot;develop/tiling.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#define CLAMP_RANGE(x, y, z) (CLAMP(x, y, z))</a>
<a name="ln30"> </a>
<a name="ln31">typedef struct _blend_buffer_desc_t</a>
<a name="ln32">{</a>
<a name="ln33">  dt_iop_colorspace_type_t cst;</a>
<a name="ln34">  size_t stride;</a>
<a name="ln35">  size_t ch;</a>
<a name="ln36">  size_t bch;</a>
<a name="ln37">} _blend_buffer_desc_t;</a>
<a name="ln38"> </a>
<a name="ln39">typedef void(_blend_row_func)(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln40">                              int flag);</a>
<a name="ln41"> </a>
<a name="ln42">static inline void _RGB_2_HSL(const float *RGB, float *HSL)</a>
<a name="ln43">{</a>
<a name="ln44">  float H, S, L;</a>
<a name="ln45"> </a>
<a name="ln46">  float R = RGB[0];</a>
<a name="ln47">  float G = RGB[1];</a>
<a name="ln48">  float B = RGB[2];</a>
<a name="ln49"> </a>
<a name="ln50">  float var_Min = fminf(R, fminf(G, B));</a>
<a name="ln51">  float var_Max = fmaxf(R, fmaxf(G, B));</a>
<a name="ln52">  float del_Max = var_Max - var_Min;</a>
<a name="ln53"> </a>
<a name="ln54">  L = (var_Max + var_Min) / 2.0f;</a>
<a name="ln55"> </a>
<a name="ln56">  if(del_Max &lt; 1e-6f)</a>
<a name="ln57">  {</a>
<a name="ln58">    H = 0.0f;</a>
<a name="ln59">    S = 0.0f;</a>
<a name="ln60">  }</a>
<a name="ln61">  else</a>
<a name="ln62">  {</a>
<a name="ln63">    if(L &lt; 0.5f)</a>
<a name="ln64">      S = del_Max / (var_Max + var_Min);</a>
<a name="ln65">    else</a>
<a name="ln66">      S = del_Max / (2.0f - var_Max - var_Min);</a>
<a name="ln67"> </a>
<a name="ln68">    float del_R = (((var_Max - R) / 6.0f) + (del_Max / 2.0f)) / del_Max;</a>
<a name="ln69">    float del_G = (((var_Max - G) / 6.0f) + (del_Max / 2.0f)) / del_Max;</a>
<a name="ln70">    float del_B = (((var_Max - B) / 6.0f) + (del_Max / 2.0f)) / del_Max;</a>
<a name="ln71"> </a>
<a name="ln72">    if(R == var_Max)</a>
<a name="ln73">      H = del_B - del_G;</a>
<a name="ln74">    else if(G == var_Max)</a>
<a name="ln75">      H = (1.0f / 3.0f) + del_R - del_B;</a>
<a name="ln76">    else if(B == var_Max)</a>
<a name="ln77">      H = (2.0f / 3.0f) + del_G - del_R;</a>
<a name="ln78">    else</a>
<a name="ln79">      H = 0.0f; // make GCC happy</a>
<a name="ln80"> </a>
<a name="ln81">    if(H &lt; 0.0f) H += 1.0f;</a>
<a name="ln82">    if(H &gt; 1.0f) H -= 1.0f;</a>
<a name="ln83">  }</a>
<a name="ln84"> </a>
<a name="ln85">  HSL[0] = H;</a>
<a name="ln86">  HSL[1] = S;</a>
<a name="ln87">  HSL[2] = L;</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">static inline float _Hue_2_RGB(float v1, float v2, float vH)</a>
<a name="ln91">{</a>
<a name="ln92">  if(vH &lt; 0.0f) vH += 1.0f;</a>
<a name="ln93">  if(vH &gt; 1.0f) vH -= 1.0f;</a>
<a name="ln94">  if((6.0f * vH) &lt; 1.0f) return (v1 + (v2 - v1) * 6.0f * vH);</a>
<a name="ln95">  if((2.0f * vH) &lt; 1.0f) return (v2);</a>
<a name="ln96">  if((3.0f * vH) &lt; 2.0f) return (v1 + (v2 - v1) * ((2.0f / 3.0f) - vH) * 6.0f);</a>
<a name="ln97">  return (v1);</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">static inline void _HSL_2_RGB(const float *HSL, float *RGB)</a>
<a name="ln101">{</a>
<a name="ln102">  float H = HSL[0];</a>
<a name="ln103">  float S = HSL[1];</a>
<a name="ln104">  float L = HSL[2];</a>
<a name="ln105"> </a>
<a name="ln106">  float var_1, var_2;</a>
<a name="ln107"> </a>
<a name="ln108">  if(S &lt; 1e-6f)</a>
<a name="ln109">  {</a>
<a name="ln110">    RGB[0] = RGB[1] = RGB[2] = L;</a>
<a name="ln111">  }</a>
<a name="ln112">  else</a>
<a name="ln113">  {</a>
<a name="ln114">    if(L &lt; 0.5f)</a>
<a name="ln115">      var_2 = L * (1.0f + S);</a>
<a name="ln116">    else</a>
<a name="ln117">      var_2 = (L + S) - (S * L);</a>
<a name="ln118"> </a>
<a name="ln119">    var_1 = 2.0f * L - var_2;</a>
<a name="ln120"> </a>
<a name="ln121">    RGB[0] = _Hue_2_RGB(var_1, var_2, H + (1.0f / 3.0f));</a>
<a name="ln122">    RGB[1] = _Hue_2_RGB(var_1, var_2, H);</a>
<a name="ln123">    RGB[2] = _Hue_2_RGB(var_1, var_2, H - (1.0f / 3.0f));</a>
<a name="ln124">  }</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">static inline void _RGB_2_HSV(const float *RGB, float *HSV)</a>
<a name="ln128">{</a>
<a name="ln129">  float r = RGB[0], g = RGB[1], b = RGB[2];</a>
<a name="ln130">  float *h = HSV, *s = HSV + 1, *v = HSV + 2;</a>
<a name="ln131"> </a>
<a name="ln132">  float min = fminf(r, fminf(g, b));</a>
<a name="ln133">  float max = fmaxf(r, fmaxf(g, b));</a>
<a name="ln134">  float delta = max - min;</a>
<a name="ln135"> </a>
<a name="ln136">  *v = max;</a>
<a name="ln137"> </a>
<a name="ln138">  if(fabsf(max) &gt; 1e-6f &amp;&amp; fabsf(delta) &gt; 1e-6f)</a>
<a name="ln139">  {</a>
<a name="ln140">    *s = delta / max;</a>
<a name="ln141">  }</a>
<a name="ln142">  else</a>
<a name="ln143">  {</a>
<a name="ln144">    *s = 0.0f;</a>
<a name="ln145">    *h = 0.0f;</a>
<a name="ln146">    return;</a>
<a name="ln147">  }</a>
<a name="ln148"> </a>
<a name="ln149">  if(r == max)</a>
<a name="ln150">    *h = (g - b) / delta;</a>
<a name="ln151">  else if(g == max)</a>
<a name="ln152">    *h = 2.0f + (b - r) / delta;</a>
<a name="ln153">  else</a>
<a name="ln154">    *h = 4.0f + (r - g) / delta;</a>
<a name="ln155"> </a>
<a name="ln156">  *h /= 6.0f;</a>
<a name="ln157"> </a>
<a name="ln158">  if(*h &lt; 0) *h += 1.0f;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">static inline void _HSV_2_RGB(const float *HSV, float *RGB)</a>
<a name="ln162">{</a>
<a name="ln163">  float h = 6.0f * HSV[0], s = HSV[1], v = HSV[2];</a>
<a name="ln164">  float *r = RGB, *g = RGB + 1, *b = RGB + 2;</a>
<a name="ln165"> </a>
<a name="ln166">  if(fabsf(s) &lt; 1e-6f)</a>
<a name="ln167">  {</a>
<a name="ln168">    *r = *g = *b = v;</a>
<a name="ln169">    return;</a>
<a name="ln170">  }</a>
<a name="ln171"> </a>
<a name="ln172">  float i = floorf(h);</a>
<a name="ln173">  float f = h - i;</a>
<a name="ln174">  float p = v * (1.0f - s);</a>
<a name="ln175">  float q = v * (1.0f - s * f);</a>
<a name="ln176">  float t = v * (1.0f - s * (1.0f - f));</a>
<a name="ln177"> </a>
<a name="ln178">  switch((int)i)</a>
<a name="ln179">  {</a>
<a name="ln180">    case 0:</a>
<a name="ln181">      *r = v;</a>
<a name="ln182">      *g = t;</a>
<a name="ln183">      *b = p;</a>
<a name="ln184">      break;</a>
<a name="ln185">    case 1:</a>
<a name="ln186">      *r = q;</a>
<a name="ln187">      *g = v;</a>
<a name="ln188">      *b = p;</a>
<a name="ln189">      break;</a>
<a name="ln190">    case 2:</a>
<a name="ln191">      *r = p;</a>
<a name="ln192">      *g = v;</a>
<a name="ln193">      *b = t;</a>
<a name="ln194">      break;</a>
<a name="ln195">    case 3:</a>
<a name="ln196">      *r = p;</a>
<a name="ln197">      *g = q;</a>
<a name="ln198">      *b = v;</a>
<a name="ln199">      break;</a>
<a name="ln200">    case 4:</a>
<a name="ln201">      *r = t;</a>
<a name="ln202">      *g = p;</a>
<a name="ln203">      *b = v;</a>
<a name="ln204">      break;</a>
<a name="ln205">    case 5:</a>
<a name="ln206">    default:</a>
<a name="ln207">      *r = v;</a>
<a name="ln208">      *g = p;</a>
<a name="ln209">      *b = q;</a>
<a name="ln210">      break;</a>
<a name="ln211">  }</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">static inline void _Lab_2_LCH(const float *Lab, float *LCH)</a>
<a name="ln215">{</a>
<a name="ln216">  float var_H = atan2f(Lab[2], Lab[1]);</a>
<a name="ln217"> </a>
<a name="ln218">  if(var_H &gt; 0.0f)</a>
<a name="ln219">    var_H = var_H / (2.0f * DT_M_PI_F);</a>
<a name="ln220">  else</a>
<a name="ln221">    var_H = 1.0f + var_H / (2.0f * DT_M_PI_F);</a>
<a name="ln222"> </a>
<a name="ln223">  LCH[0] = Lab[0];</a>
<a name="ln224">  LCH[1] = sqrtf(Lab[1] * Lab[1] + Lab[2] * Lab[2]);</a>
<a name="ln225">  LCH[2] = var_H;</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">static inline void _LCH_2_Lab(const float *LCH, float *Lab)</a>
<a name="ln229">{</a>
<a name="ln230">  Lab[0] = LCH[0];</a>
<a name="ln231">  Lab[1] = cosf(2.0f * DT_M_PI_F * LCH[2]) * LCH[1];</a>
<a name="ln232">  Lab[2] = sinf(2.0f * DT_M_PI_F * LCH[2]) * LCH[1];</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">static inline void _CLAMP_XYZ(float *XYZ, const float *min, const float *max)</a>
<a name="ln236">{</a>
<a name="ln237">  XYZ[0] = CLAMP_RANGE(XYZ[0], min[0], max[0]);</a>
<a name="ln238">  XYZ[1] = CLAMP_RANGE(XYZ[1], min[1], max[1]);</a>
<a name="ln239">  XYZ[2] = CLAMP_RANGE(XYZ[2], min[2], max[2]);</a>
<a name="ln240">}</a>
<a name="ln241"> </a>
<a name="ln242">static inline void _PX_COPY(const float *src, float *dst)</a>
<a name="ln243">{</a>
<a name="ln244">  dst[0] = src[0];</a>
<a name="ln245">  dst[1] = src[1];</a>
<a name="ln246">  dst[2] = src[2];</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">static inline float _blendif_factor(dt_iop_colorspace_type_t cst, const float *input, const float *output,</a>
<a name="ln250">                                    const unsigned int blendif, const float *parameters,</a>
<a name="ln251">                                    const unsigned int mask_mode, const unsigned int mask_combine)</a>
<a name="ln252">{</a>
<a name="ln253">  float result = 1.0f;</a>
<a name="ln254">  float scaled[DEVELOP_BLENDIF_SIZE] = { 0.5f };</a>
<a name="ln255">  unsigned int channel_mask = 0;</a>
<a name="ln256"> </a>
<a name="ln257">  if(!(mask_mode &amp; DEVELOP_MASK_CONDITIONAL)) return (mask_combine &amp; DEVELOP_COMBINE_INCL) ? 0.0f : 1.0f;</a>
<a name="ln258"> </a>
<a name="ln259">  switch(cst)</a>
<a name="ln260">  {</a>
<a name="ln261">    case iop_cs_Lab:</a>
<a name="ln262">      scaled[DEVELOP_BLENDIF_L_in] = CLAMP_RANGE(input[0] / 100.0f, 0.0f, 1.0f); // L scaled to 0..1</a>
<a name="ln263">      scaled[DEVELOP_BLENDIF_A_in]</a>
<a name="ln264">          = CLAMP_RANGE((input[1] + 128.0f) / 256.0f, 0.0f, 1.0f); // a scaled to 0..1</a>
<a name="ln265">      scaled[DEVELOP_BLENDIF_B_in]</a>
<a name="ln266">          = CLAMP_RANGE((input[2] + 128.0f) / 256.0f, 0.0f, 1.0f);                 // b scaled to 0..1</a>
<a name="ln267">      scaled[DEVELOP_BLENDIF_L_out] = CLAMP_RANGE(output[0] / 100.0f, 0.0f, 1.0f); // L scaled to 0..1</a>
<a name="ln268">      scaled[DEVELOP_BLENDIF_A_out]</a>
<a name="ln269">          = CLAMP_RANGE((output[1] + 128.0f) / 256.0f, 0.0f, 1.0f); // a scaled to 0..1</a>
<a name="ln270">      scaled[DEVELOP_BLENDIF_B_out]</a>
<a name="ln271">          = CLAMP_RANGE((output[2] + 128.0f) / 256.0f, 0.0f, 1.0f); // b scaled to 0..1</a>
<a name="ln272"> </a>
<a name="ln273">      if(blendif &amp; 0x7f00) // do we need to consider LCh ?</a>
<a name="ln274">      {</a>
<a name="ln275">        float LCH_input[3];</a>
<a name="ln276">        float LCH_output[3];</a>
<a name="ln277">        _Lab_2_LCH(input, LCH_input);</a>
<a name="ln278">        _Lab_2_LCH(output, LCH_output);</a>
<a name="ln279"> </a>
<a name="ln280">        scaled[DEVELOP_BLENDIF_C_in] = CLAMP_RANGE(LCH_input[1] / (128.0f * sqrtf(2.0f)), 0.0f,</a>
<a name="ln281">                                                   1.0f);                     // C scaled to 0..1</a>
<a name="ln282">        scaled[DEVELOP_BLENDIF_h_in] = CLAMP_RANGE(LCH_input[2], 0.0f, 1.0f); // h scaled to 0..1</a>
<a name="ln283"> </a>
<a name="ln284">        scaled[DEVELOP_BLENDIF_C_out] = CLAMP_RANGE(LCH_output[1] / (128.0f * sqrtf(2.0f)), 0.0f,</a>
<a name="ln285">                                                    1.0f);                      // C scaled to 0..1</a>
<a name="ln286">        scaled[DEVELOP_BLENDIF_h_out] = CLAMP_RANGE(LCH_output[2], 0.0f, 1.0f); // h scaled to 0..1</a>
<a name="ln287">      }</a>
<a name="ln288"> </a>
<a name="ln289">      channel_mask = DEVELOP_BLENDIF_Lab_MASK;</a>
<a name="ln290"> </a>
<a name="ln291">      break;</a>
<a name="ln292">    case iop_cs_rgb:</a>
<a name="ln293">      scaled[DEVELOP_BLENDIF_GRAY_in]</a>
<a name="ln294">          = CLAMP_RANGE(0.3f * input[0] + 0.59f * input[1] + 0.11f * input[2], 0.0f,</a>
<a name="ln295">                        1.0f);                                              // Gray scaled to 0..1</a>
<a name="ln296">      scaled[DEVELOP_BLENDIF_RED_in] = CLAMP_RANGE(input[0], 0.0f, 1.0f);   // Red</a>
<a name="ln297">      scaled[DEVELOP_BLENDIF_GREEN_in] = CLAMP_RANGE(input[1], 0.0f, 1.0f); // Green</a>
<a name="ln298">      scaled[DEVELOP_BLENDIF_BLUE_in] = CLAMP_RANGE(input[2], 0.0f, 1.0f);  // Blue</a>
<a name="ln299">      scaled[DEVELOP_BLENDIF_GRAY_out] = CLAMP_RANGE(0.3f * output[0] + 0.59f * output[1] + 0.11f * output[2],</a>
<a name="ln300">                                                     0.0f, 1.0f);             // Gray scaled to 0..1</a>
<a name="ln301">      scaled[DEVELOP_BLENDIF_RED_out] = CLAMP_RANGE(output[0], 0.0f, 1.0f);   // Red</a>
<a name="ln302">      scaled[DEVELOP_BLENDIF_GREEN_out] = CLAMP_RANGE(output[1], 0.0f, 1.0f); // Green</a>
<a name="ln303">      scaled[DEVELOP_BLENDIF_BLUE_out] = CLAMP_RANGE(output[2], 0.0f, 1.0f);  // Blue</a>
<a name="ln304"> </a>
<a name="ln305">      if(blendif &amp; 0x7f00) // do we need to consider HSL ?</a>
<a name="ln306">      {</a>
<a name="ln307">        float HSL_input[3];</a>
<a name="ln308">        float HSL_output[3];</a>
<a name="ln309">        _RGB_2_HSL(input, HSL_input);</a>
<a name="ln310">        _RGB_2_HSL(output, HSL_output);</a>
<a name="ln311"> </a>
<a name="ln312">        scaled[DEVELOP_BLENDIF_H_in] = CLAMP_RANGE(HSL_input[0], 0.0f, 1.0f); // H scaled to 0..1</a>
<a name="ln313">        scaled[DEVELOP_BLENDIF_S_in] = CLAMP_RANGE(HSL_input[1], 0.0f, 1.0f); // S scaled to 0..1</a>
<a name="ln314">        scaled[DEVELOP_BLENDIF_l_in] = CLAMP_RANGE(HSL_input[2], 0.0f, 1.0f); // L scaled to 0..1</a>
<a name="ln315"> </a>
<a name="ln316">        scaled[DEVELOP_BLENDIF_H_out] = CLAMP_RANGE(HSL_output[0], 0.0f, 1.0f); // H scaled to 0..1</a>
<a name="ln317">        scaled[DEVELOP_BLENDIF_S_out] = CLAMP_RANGE(HSL_output[1], 0.0f, 1.0f); // S scaled to 0..1</a>
<a name="ln318">        scaled[DEVELOP_BLENDIF_l_out] = CLAMP_RANGE(HSL_output[2], 0.0f, 1.0f); // L scaled to 0..1</a>
<a name="ln319">      }</a>
<a name="ln320"> </a>
<a name="ln321">      channel_mask = DEVELOP_BLENDIF_RGB_MASK;</a>
<a name="ln322"> </a>
<a name="ln323">      break;</a>
<a name="ln324">    default:</a>
<a name="ln325">      return (mask_combine &amp; DEVELOP_COMBINE_INCL) ? 0.0f : 1.0f; // not implemented for other color spaces</a>
<a name="ln326">  }</a>
<a name="ln327"> </a>
<a name="ln328">  for(int ch = 0; ch &lt;= DEVELOP_BLENDIF_MAX; ch++)</a>
<a name="ln329">  {</a>
<a name="ln330">    if((channel_mask &amp; (1 &lt;&lt; ch)) == 0) continue; // skip blendif channels not used in this color space</a>
<a name="ln331"> </a>
<a name="ln332">    if((blendif &amp; (1 &lt;&lt; ch)) == 0) // deal with channels where sliders span the whole range</a>
<a name="ln333">    {</a>
<a name="ln334">      result *= !(blendif &amp; (1 &lt;&lt; (ch + 16))) == !(mask_combine &amp; DEVELOP_COMBINE_INCL) ? 1.0f : 0.0f;</a>
<a name="ln335">      continue;</a>
<a name="ln336">    }</a>
<a name="ln337"> </a>
<a name="ln338">    if(result &lt;= 0.000001f) break; // no need to continue if we are already at or close to zero</a>
<a name="ln339"> </a>
<a name="ln340">    float factor;</a>
<a name="ln341">    if(scaled[ch] &gt;= parameters[4 * ch + 1] &amp;&amp; scaled[ch] &lt;= parameters[4 * ch + 2])</a>
<a name="ln342">    {</a>
<a name="ln343">      factor = 1.0f;</a>
<a name="ln344">    }</a>
<a name="ln345">    else if(scaled[ch] &gt; parameters[4 * ch + 0] &amp;&amp; scaled[ch] &lt; parameters[4 * ch + 1])</a>
<a name="ln346">    {</a>
<a name="ln347">      factor</a>
<a name="ln348">          = (scaled[ch] - parameters[4 * ch + 0]) / fmaxf(0.01f, parameters[4 * ch + 1] - parameters[4 * ch + 0]);</a>
<a name="ln349">    }</a>
<a name="ln350">    else if(scaled[ch] &gt; parameters[4 * ch + 2] &amp;&amp; scaled[ch] &lt; parameters[4 * ch + 3])</a>
<a name="ln351">    {</a>
<a name="ln352">      factor = 1.0f</a>
<a name="ln353">               - (scaled[ch] - parameters[4 * ch + 2])</a>
<a name="ln354">                     / fmaxf(0.01f, parameters[4 * ch + 3] - parameters[4 * ch + 2]);</a>
<a name="ln355">    }</a>
<a name="ln356">    else</a>
<a name="ln357">      factor = 0.0f;</a>
<a name="ln358"> </a>
<a name="ln359">    if((blendif &amp; (1 &lt;&lt; (ch + 16))) != 0) factor = 1.0f - factor; // inverted channel?</a>
<a name="ln360"> </a>
<a name="ln361">    result *= ((mask_combine &amp; DEVELOP_COMBINE_INCL) ? 1.0f - factor : factor);</a>
<a name="ln362">  }</a>
<a name="ln363"> </a>
<a name="ln364">  return (mask_combine &amp; DEVELOP_COMBINE_INCL) ? 1.0f - result : result;</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">static inline void _blend_colorspace_channel_range(dt_iop_colorspace_type_t cst, float *min, float *max)</a>
<a name="ln368">{</a>
<a name="ln369">  switch(cst)</a>
<a name="ln370">  {</a>
<a name="ln371">    case iop_cs_Lab: // after scaling !!!</a>
<a name="ln372">      min[0] = 0.0f;</a>
<a name="ln373">      max[0] = 1.0f;</a>
<a name="ln374">      min[1] = -1.0f;</a>
<a name="ln375">      max[1] = 1.0f;</a>
<a name="ln376">      min[2] = -1.0f;</a>
<a name="ln377">      max[2] = 1.0f;</a>
<a name="ln378">      min[3] = 0.0f;</a>
<a name="ln379">      max[3] = 1.0f;</a>
<a name="ln380">      break;</a>
<a name="ln381">    default:</a>
<a name="ln382">      min[0] = 0.0f;</a>
<a name="ln383">      max[0] = 1.0f;</a>
<a name="ln384">      min[1] = 0.0f;</a>
<a name="ln385">      max[1] = 1.0f;</a>
<a name="ln386">      min[2] = 0.0f;</a>
<a name="ln387">      max[2] = 1.0f;</a>
<a name="ln388">      min[3] = 0.0f;</a>
<a name="ln389">      max[3] = 1.0f;</a>
<a name="ln390">      break;</a>
<a name="ln391">  }</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">static inline void _blend_Lab_scale(const float *i, float *o)</a>
<a name="ln395">{</a>
<a name="ln396">  o[0] = i[0] / 100.0f;</a>
<a name="ln397">  o[1] = i[1] / 128.0f;</a>
<a name="ln398">  o[2] = i[2] / 128.0f;</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">static inline void _blend_Lab_rescale(const float *i, float *o)</a>
<a name="ln402">{</a>
<a name="ln403">  o[0] = i[0] * 100.0f;</a>
<a name="ln404">  o[1] = i[1] * 128.0f;</a>
<a name="ln405">  o[2] = i[2] * 128.0f;</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408"> </a>
<a name="ln409">static inline void _blend_noop(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln410">                               const float *min, const float *max)</a>
<a name="ln411">{</a>
<a name="ln412">  for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln413">  {</a>
<a name="ln414">    for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = CLAMP_RANGE(a[j + k], min ? min[k] : -INFINITY, max ? max[k] : INFINITY);</a>
<a name="ln415">    if(bd-&gt;cst != iop_cs_RAW) b[j + 3] = mask[i];</a>
<a name="ln416">  }</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419"> </a>
<a name="ln420">/* generate blend mask */</a>
<a name="ln421">static void _blend_make_mask(const _blend_buffer_desc_t *bd, const unsigned int blendif,</a>
<a name="ln422">                             const float *blendif_parameters, const unsigned int mask_mode,</a>
<a name="ln423">                             const unsigned int mask_combine, const float gopacity, const float *a,</a>
<a name="ln424">                             const float *b, float *mask)</a>
<a name="ln425">{</a>
<a name="ln426">  for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln427">  {</a>
<a name="ln428">    float form = mask[i];</a>
<a name="ln429">    float conditional</a>
<a name="ln430">        = _blendif_factor(bd-&gt;cst, &amp;a[j], &amp;b[j], blendif, blendif_parameters, mask_mode, mask_combine);</a>
<a name="ln431">    float opacity = (mask_combine &amp; DEVELOP_COMBINE_INCL) ? 1.0f - (1.0f - form) * (1.0f - conditional)</a>
<a name="ln432">                                                          : form * conditional;</a>
<a name="ln433">    opacity = (mask_combine &amp; DEVELOP_COMBINE_INV) ? 1.0f - opacity : opacity;</a>
<a name="ln434">    mask[i] = opacity * gopacity;</a>
<a name="ln435">  }</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">/* normal blend with clamping */</a>
<a name="ln439">static void _blend_normal_bounded(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln440">                                  int flag)</a>
<a name="ln441">{</a>
<a name="ln442">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln443">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln444"> </a>
<a name="ln445">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln446">  {</a>
<a name="ln447">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln448">    {</a>
<a name="ln449">      float local_opacity = mask[i];</a>
<a name="ln450">      float ta[3], tb[3];</a>
<a name="ln451">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln452">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln453"> </a>
<a name="ln454">      tb[0] = CLAMP_RANGE((ta[0] * (1.0f - local_opacity)) + tb[0] * local_opacity, min[0], max[0]);</a>
<a name="ln455"> </a>
<a name="ln456">      if(flag == 0)</a>
<a name="ln457">      {</a>
<a name="ln458">        tb[1] = CLAMP_RANGE((ta[1] * (1.0f - local_opacity)) + tb[1] * local_opacity, min[1], max[1]);</a>
<a name="ln459">        tb[2] = CLAMP_RANGE((ta[2] * (1.0f - local_opacity)) + tb[2] * local_opacity, min[2], max[2]);</a>
<a name="ln460">      }</a>
<a name="ln461">      else</a>
<a name="ln462">      {</a>
<a name="ln463">        tb[1] = ta[1];</a>
<a name="ln464">        tb[2] = ta[2];</a>
<a name="ln465">      }</a>
<a name="ln466"> </a>
<a name="ln467">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln468">      b[j + 3] = local_opacity;</a>
<a name="ln469">    }</a>
<a name="ln470">  }</a>
<a name="ln471">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln472">  {</a>
<a name="ln473">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln474">    {</a>
<a name="ln475">      float local_opacity = mask[i];</a>
<a name="ln476">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln477">        b[j + k]</a>
<a name="ln478">            = CLAMP_RANGE((a[j + k] * (1.0f - local_opacity)) + b[j + k] * local_opacity, min[k], max[k]);</a>
<a name="ln479">      b[j + 3] = local_opacity;</a>
<a name="ln480">    }</a>
<a name="ln481">  }</a>
<a name="ln482">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln483">  {</a>
<a name="ln484">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln485">    {</a>
<a name="ln486">      float local_opacity = mask[i];</a>
<a name="ln487">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln488">        b[j + k]</a>
<a name="ln489">            = CLAMP_RANGE((a[j + k] * (1.0f - local_opacity)) + b[j + k] * local_opacity, min[k], max[k]);</a>
<a name="ln490">    }</a>
<a name="ln491">  }</a>
<a name="ln492">}</a>
<a name="ln493"> </a>
<a name="ln494">/* normal blend without any clamping */</a>
<a name="ln495">static void _blend_normal_unbounded(const _blend_buffer_desc_t *bd, const float *a, float *b,</a>
<a name="ln496">                                    const float *mask, int flag)</a>
<a name="ln497">{</a>
<a name="ln498">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln499">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln500"> </a>
<a name="ln501">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln502">  {</a>
<a name="ln503">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln504">    {</a>
<a name="ln505">      float local_opacity = mask[i];</a>
<a name="ln506">      float ta[3], tb[3];</a>
<a name="ln507">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln508">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln509"> </a>
<a name="ln510">      tb[0] = (ta[0] * (1.0f - local_opacity)) + tb[0] * local_opacity;</a>
<a name="ln511"> </a>
<a name="ln512">      if(flag == 0)</a>
<a name="ln513">      {</a>
<a name="ln514">        tb[1] = (ta[1] * (1.0f - local_opacity)) + tb[1] * local_opacity;</a>
<a name="ln515">        tb[2] = (ta[2] * (1.0f - local_opacity)) + tb[2] * local_opacity;</a>
<a name="ln516">      }</a>
<a name="ln517">      else</a>
<a name="ln518">      {</a>
<a name="ln519">        tb[1] = ta[1];</a>
<a name="ln520">        tb[2] = ta[2];</a>
<a name="ln521">      }</a>
<a name="ln522"> </a>
<a name="ln523">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln524">      b[j + 3] = local_opacity;</a>
<a name="ln525">    }</a>
<a name="ln526">  }</a>
<a name="ln527">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln528">  {</a>
<a name="ln529">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln530">    {</a>
<a name="ln531">      float local_opacity = mask[i];</a>
<a name="ln532">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln533">        b[j + k] = (a[j + k] * (1.0f - local_opacity)) + b[j + k] * local_opacity;</a>
<a name="ln534">      b[j + 3] = local_opacity;</a>
<a name="ln535">    }</a>
<a name="ln536">  }</a>
<a name="ln537">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln538">  {</a>
<a name="ln539">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln540">    {</a>
<a name="ln541">      float local_opacity = mask[i];</a>
<a name="ln542">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln543">        b[j + k] = (a[j + k] * (1.0f - local_opacity)) + b[j + k] * local_opacity;</a>
<a name="ln544">    }</a>
<a name="ln545">  }</a>
<a name="ln546">}</a>
<a name="ln547"> </a>
<a name="ln548">/* lighten */</a>
<a name="ln549">static void _blend_lighten(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln550">                           int flag)</a>
<a name="ln551">{</a>
<a name="ln552">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln553">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln554"> </a>
<a name="ln555">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln556">  {</a>
<a name="ln557">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln558">    {</a>
<a name="ln559">      float local_opacity = mask[i];</a>
<a name="ln560">      float ta[3], tb[3], tbo;</a>
<a name="ln561">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln562">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln563"> </a>
<a name="ln564">      tbo = tb[0];</a>
<a name="ln565">      tb[0] = CLAMP_RANGE(ta[0] * (1.0f - local_opacity) + (ta[0] &gt; tb[0] ? ta[0] : tb[0]) * local_opacity,</a>
<a name="ln566">                          min[0], max[0]);</a>
<a name="ln567"> </a>
<a name="ln568">      if(flag == 0)</a>
<a name="ln569">      {</a>
<a name="ln570">        tb[1] = CLAMP_RANGE(ta[1] * (1.0f - fabsf(tbo - tb[0])) + 0.5f * (ta[1] + tb[1]) * fabsf(tbo - tb[0]),</a>
<a name="ln571">                            min[1], max[1]);</a>
<a name="ln572">        tb[2] = CLAMP_RANGE(ta[2] * (1.0f - fabsf(tbo - tb[0])) + 0.5f * (ta[2] + tb[2]) * fabsf(tbo - tb[0]),</a>
<a name="ln573">                            min[2], max[2]);</a>
<a name="ln574">      }</a>
<a name="ln575">      else</a>
<a name="ln576">      {</a>
<a name="ln577">        tb[1] = ta[1];</a>
<a name="ln578">        tb[2] = ta[2];</a>
<a name="ln579">      }</a>
<a name="ln580"> </a>
<a name="ln581">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln582">      b[j + 3] = local_opacity;</a>
<a name="ln583">    }</a>
<a name="ln584">  }</a>
<a name="ln585">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln586">  {</a>
<a name="ln587">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln588">    {</a>
<a name="ln589">      float local_opacity = mask[i];</a>
<a name="ln590">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln591">        b[j + k] = CLAMP_RANGE(a[j + k] * (1.0f - local_opacity) + fmaxf(a[j + k], b[j + k]) * local_opacity,</a>
<a name="ln592">                               min[k], max[k]);</a>
<a name="ln593">      b[j + 3] = local_opacity;</a>
<a name="ln594">    }</a>
<a name="ln595">  }</a>
<a name="ln596">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln597">  {</a>
<a name="ln598">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln599">    {</a>
<a name="ln600">      float local_opacity = mask[i];</a>
<a name="ln601">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln602">        b[j + k] = CLAMP_RANGE(a[j + k] * (1.0f - local_opacity) + fmaxf(a[j + k], b[j + k]) * local_opacity,</a>
<a name="ln603">                               min[k], max[k]);</a>
<a name="ln604">    }</a>
<a name="ln605">  }</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">/* darken */</a>
<a name="ln609">static void _blend_darken(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln610">                          int flag)</a>
<a name="ln611">{</a>
<a name="ln612">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln613">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln614"> </a>
<a name="ln615">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln616">  {</a>
<a name="ln617">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln618">    {</a>
<a name="ln619">      float local_opacity = mask[i];</a>
<a name="ln620">      float ta[3], tb[3], tbo;</a>
<a name="ln621">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln622">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln623"> </a>
<a name="ln624">      tbo = tb[0];</a>
<a name="ln625">      tb[0] = CLAMP_RANGE(ta[0] * (1.0f - local_opacity) + (ta[0] &lt; tb[0] ? ta[0] : tb[0]) * local_opacity,</a>
<a name="ln626">                          min[0], max[0]);</a>
<a name="ln627"> </a>
<a name="ln628">      if(flag == 0)</a>
<a name="ln629">      {</a>
<a name="ln630">        tb[1] = CLAMP_RANGE(ta[1] * (1.0f - fabsf(tbo - tb[0])) + 0.5f * (ta[1] + tb[1]) * fabsf(tbo - tb[0]),</a>
<a name="ln631">                            min[1], max[1]);</a>
<a name="ln632">        tb[2] = CLAMP_RANGE(ta[2] * (1.0f - fabsf(tbo - tb[0])) + 0.5f * (ta[2] + tb[2]) * fabsf(tbo - tb[0]),</a>
<a name="ln633">                            min[2], max[2]);</a>
<a name="ln634">      }</a>
<a name="ln635">      else</a>
<a name="ln636">      {</a>
<a name="ln637">        tb[1] = ta[1];</a>
<a name="ln638">        tb[2] = ta[2];</a>
<a name="ln639">      }</a>
<a name="ln640"> </a>
<a name="ln641">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln642">      b[j + 3] = local_opacity;</a>
<a name="ln643">    }</a>
<a name="ln644">  }</a>
<a name="ln645">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln646">  {</a>
<a name="ln647">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln648">    {</a>
<a name="ln649">      float local_opacity = mask[i];</a>
<a name="ln650">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln651">        b[j + k] = CLAMP_RANGE(a[j + k] * (1.0f - local_opacity) + fminf(a[j + k], b[j + k]) * local_opacity,</a>
<a name="ln652">                               min[k], max[k]);</a>
<a name="ln653">      b[j + 3] = local_opacity;</a>
<a name="ln654">    }</a>
<a name="ln655">  }</a>
<a name="ln656">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln657">  {</a>
<a name="ln658">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln659">    {</a>
<a name="ln660">      float local_opacity = mask[i];</a>
<a name="ln661">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln662">        b[j + k] = CLAMP_RANGE(a[j + k] * (1.0f - local_opacity) + fminf(a[j + k], b[j + k]) * local_opacity,</a>
<a name="ln663">                               min[k], max[k]);</a>
<a name="ln664">    }</a>
<a name="ln665">  }</a>
<a name="ln666">  // return fminf(a,b);</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">/* multiply */</a>
<a name="ln670">static void _blend_multiply(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln671">                            int flag)</a>
<a name="ln672">{</a>
<a name="ln673">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln674">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln675"> </a>
<a name="ln676">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln677">  {</a>
<a name="ln678">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln679">    {</a>
<a name="ln680">      float local_opacity = mask[i];</a>
<a name="ln681">      float ta[3], tb[3];</a>
<a name="ln682">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln683"> </a>
<a name="ln684">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln685">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln686">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln687">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln688">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln689"> </a>
<a name="ln690">      tb[0] = CLAMP_RANGE(((la * (1.0f - local_opacity)) + ((la * lb) * local_opacity)), min[0], max[0])</a>
<a name="ln691">              - fabsf(min[0]);</a>
<a name="ln692"> </a>
<a name="ln693">      if(flag == 0)</a>
<a name="ln694">      {</a>
<a name="ln695">        if(ta[0] &gt; 0.01f)</a>
<a name="ln696">        {</a>
<a name="ln697">          tb[1]</a>
<a name="ln698">              = CLAMP_RANGE(ta[1] * (1.0f - local_opacity) + (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity,</a>
<a name="ln699">                            min[1], max[1]);</a>
<a name="ln700">          tb[2]</a>
<a name="ln701">              = CLAMP_RANGE(ta[2] * (1.0f - local_opacity) + (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity,</a>
<a name="ln702">                            min[2], max[2]);</a>
<a name="ln703">        }</a>
<a name="ln704">        else</a>
<a name="ln705">        {</a>
<a name="ln706">          tb[1]</a>
<a name="ln707">              = CLAMP_RANGE(ta[1] * (1.0f - local_opacity) + (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity,</a>
<a name="ln708">                            min[1], max[1]);</a>
<a name="ln709">          tb[2]</a>
<a name="ln710">              = CLAMP_RANGE(ta[2] * (1.0f - local_opacity) + (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity,</a>
<a name="ln711">                            min[2], max[2]);</a>
<a name="ln712">        }</a>
<a name="ln713">      }</a>
<a name="ln714">      else</a>
<a name="ln715">      {</a>
<a name="ln716">        tb[1] = ta[1];</a>
<a name="ln717">        tb[2] = ta[2];</a>
<a name="ln718">      }</a>
<a name="ln719"> </a>
<a name="ln720">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln721">      b[j + 3] = local_opacity;</a>
<a name="ln722">    }</a>
<a name="ln723">  }</a>
<a name="ln724">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln725">  {</a>
<a name="ln726">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln727">    {</a>
<a name="ln728">      float local_opacity = mask[i];</a>
<a name="ln729">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln730">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln731">            ((a[j + k] * (1.0f - local_opacity)) + ((a[j + k] * b[j + k]) * local_opacity)), min[k], max[k]);</a>
<a name="ln732">      b[j + 3] = local_opacity;</a>
<a name="ln733">    }</a>
<a name="ln734">  }</a>
<a name="ln735">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln736">  {</a>
<a name="ln737">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln738">    {</a>
<a name="ln739">      float local_opacity = mask[i];</a>
<a name="ln740">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln741"> </a>
<a name="ln742">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln743">            ((a[j + k] * (1.0f - local_opacity)) + ((a[j + k] * b[j + k]) * local_opacity)), min[k], max[k]);</a>
<a name="ln744">    }</a>
<a name="ln745">  }</a>
<a name="ln746">  // return (a*b);</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">/* average */</a>
<a name="ln750">static void _blend_average(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln751">                           int flag)</a>
<a name="ln752">{</a>
<a name="ln753">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln754">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln755"> </a>
<a name="ln756">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln757">  {</a>
<a name="ln758">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln759">    {</a>
<a name="ln760">      float local_opacity = mask[i];</a>
<a name="ln761">      float ta[3], tb[3];</a>
<a name="ln762">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln763">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln764"> </a>
<a name="ln765">      tb[0] = CLAMP_RANGE(ta[0] * (1.0f - local_opacity) + (ta[0] + tb[0]) / 2.0f * local_opacity, min[0],</a>
<a name="ln766">                          max[0]);</a>
<a name="ln767"> </a>
<a name="ln768">      if(flag == 0)</a>
<a name="ln769">      {</a>
<a name="ln770">        tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity) + (ta[1] + tb[1]) / 2.0f * local_opacity, min[1],</a>
<a name="ln771">                            max[1]);</a>
<a name="ln772">        tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity) + (ta[2] + tb[2]) / 2.0f * local_opacity, min[2],</a>
<a name="ln773">                            max[2]);</a>
<a name="ln774">      }</a>
<a name="ln775">      else</a>
<a name="ln776">      {</a>
<a name="ln777">        tb[1] = ta[1];</a>
<a name="ln778">        tb[2] = ta[2];</a>
<a name="ln779">      }</a>
<a name="ln780"> </a>
<a name="ln781">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln782">      b[j + 3] = local_opacity;</a>
<a name="ln783">    }</a>
<a name="ln784">  }</a>
<a name="ln785">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln786">  {</a>
<a name="ln787">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln788">    {</a>
<a name="ln789">      float local_opacity = mask[i];</a>
<a name="ln790">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln791">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln792">            a[j + k] * (1.0f - local_opacity) + (a[j + k] + b[j + k]) / 2.0f * local_opacity, min[k], max[k]);</a>
<a name="ln793"> </a>
<a name="ln794">      b[j + 3] = local_opacity;</a>
<a name="ln795">    }</a>
<a name="ln796">  }</a>
<a name="ln797">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln798">  {</a>
<a name="ln799">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln800">    {</a>
<a name="ln801">      float local_opacity = mask[i];</a>
<a name="ln802">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln803">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln804">            a[j + k] * (1.0f - local_opacity) + (a[j + k] + b[j + k]) / 2.0f * local_opacity, min[k], max[k]);</a>
<a name="ln805">    }</a>
<a name="ln806">  }</a>
<a name="ln807">  // return (a+b)/2.0;</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810">/* add */</a>
<a name="ln811">static void _blend_add(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask, int flag)</a>
<a name="ln812">{</a>
<a name="ln813">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln814">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln815"> </a>
<a name="ln816">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln817">  {</a>
<a name="ln818">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln819">    {</a>
<a name="ln820">      float local_opacity = mask[i];</a>
<a name="ln821">      float ta[3], tb[3];</a>
<a name="ln822">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln823">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln824"> </a>
<a name="ln825">      tb[0] = CLAMP_RANGE((ta[0] * (1.0f - local_opacity)) + (((ta[0] + tb[0])) * local_opacity), min[0],</a>
<a name="ln826">                          max[0]);</a>
<a name="ln827"> </a>
<a name="ln828">      if(flag == 0)</a>
<a name="ln829">      {</a>
<a name="ln830">        tb[1] = CLAMP_RANGE((ta[1] * (1.0f - local_opacity)) + (((ta[1] + tb[1])) * local_opacity), min[1],</a>
<a name="ln831">                            max[1]);</a>
<a name="ln832">        tb[2] = CLAMP_RANGE((ta[2] * (1.0f - local_opacity)) + (((ta[2] + tb[2])) * local_opacity), min[2],</a>
<a name="ln833">                            max[2]);</a>
<a name="ln834">      }</a>
<a name="ln835">      else</a>
<a name="ln836">      {</a>
<a name="ln837">        tb[1] = ta[1];</a>
<a name="ln838">        tb[2] = ta[2];</a>
<a name="ln839">      }</a>
<a name="ln840"> </a>
<a name="ln841">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln842">      b[j + 3] = local_opacity;</a>
<a name="ln843">    }</a>
<a name="ln844">  }</a>
<a name="ln845">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln846">  {</a>
<a name="ln847">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln848">    {</a>
<a name="ln849">      float local_opacity = mask[i];</a>
<a name="ln850">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln851">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln852">            (a[j + k] * (1.0f - local_opacity)) + (((a[j + k] + b[j + k])) * local_opacity), min[k], max[k]);</a>
<a name="ln853">      b[j + 3] = local_opacity;</a>
<a name="ln854">    }</a>
<a name="ln855">  }</a>
<a name="ln856">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln857">  {</a>
<a name="ln858">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln859">    {</a>
<a name="ln860">      float local_opacity = mask[i];</a>
<a name="ln861">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln862">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln863">            (a[j + k] * (1.0f - local_opacity)) + (((a[j + k] + b[j + k])) * local_opacity), min[k], max[k]);</a>
<a name="ln864">    }</a>
<a name="ln865">  }</a>
<a name="ln866">  /*</a>
<a name="ln867">  float max,min;</a>
<a name="ln868">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln869">  return CLAMP_RANGE(a+b,min,max);</a>
<a name="ln870">  */</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">/* substract */</a>
<a name="ln874">static void _blend_substract(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln875">                             int flag)</a>
<a name="ln876">{</a>
<a name="ln877">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln878">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln879"> </a>
<a name="ln880">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln881">  {</a>
<a name="ln882">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln883">    {</a>
<a name="ln884">      float local_opacity = mask[i];</a>
<a name="ln885">      float ta[3], tb[3];</a>
<a name="ln886">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln887">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln888"> </a>
<a name="ln889">      tb[0] = CLAMP_RANGE(</a>
<a name="ln890">          ((ta[0] * (1.0f - local_opacity)) + (((tb[0] + ta[0]) - (fabsf(min[0] + max[0]))) * local_opacity)),</a>
<a name="ln891">          min[0], max[0]);</a>
<a name="ln892"> </a>
<a name="ln893">      if(flag == 0)</a>
<a name="ln894">      {</a>
<a name="ln895">        tb[1] = CLAMP_RANGE(</a>
<a name="ln896">            ((ta[1] * (1.0f - local_opacity)) + (((tb[1] + ta[1]) - (fabsf(min[1] + max[1]))) * local_opacity)),</a>
<a name="ln897">            min[1], max[1]);</a>
<a name="ln898">        tb[2] = CLAMP_RANGE(</a>
<a name="ln899">            ((ta[2] * (1.0f - local_opacity)) + (((tb[2] + ta[2]) - (fabsf(min[2] + max[2]))) * local_opacity)),</a>
<a name="ln900">            min[2], max[2]);</a>
<a name="ln901">      }</a>
<a name="ln902">      else</a>
<a name="ln903">      {</a>
<a name="ln904">        tb[1] = ta[1];</a>
<a name="ln905">        tb[2] = ta[2];</a>
<a name="ln906">      }</a>
<a name="ln907"> </a>
<a name="ln908">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln909">      b[j + 3] = local_opacity;</a>
<a name="ln910">    }</a>
<a name="ln911">  }</a>
<a name="ln912">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln913">  {</a>
<a name="ln914">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln915">    {</a>
<a name="ln916">      float local_opacity = mask[i];</a>
<a name="ln917">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln918">        b[j + k] = CLAMP_RANGE(((a[j + k] * (1.0f - local_opacity))</a>
<a name="ln919">                                + (((b[j + k] + a[j + k]) - (fabsf(min[k] + max[k]))) * local_opacity)),</a>
<a name="ln920">                               min[k], max[k]);</a>
<a name="ln921">      b[j + 3] = local_opacity;</a>
<a name="ln922">    }</a>
<a name="ln923">  }</a>
<a name="ln924">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln925">  {</a>
<a name="ln926">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln927">    {</a>
<a name="ln928">      float local_opacity = mask[i];</a>
<a name="ln929">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln930">        b[j + k] = CLAMP_RANGE(((a[j + k] * (1.0f - local_opacity))</a>
<a name="ln931">                                + (((b[j + k] + a[j + k]) - (fabsf(min[k] + max[k]))) * local_opacity)),</a>
<a name="ln932">                               min[k], max[k]);</a>
<a name="ln933">    }</a>
<a name="ln934">  }</a>
<a name="ln935">  /*</a>
<a name="ln936">  float max,min;</a>
<a name="ln937">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln938">  return ((a+b&lt;max) ? 0:(b+a-max));</a>
<a name="ln939">  */</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">/* difference (deprecated) */</a>
<a name="ln943">static void _blend_difference(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln944">                              int flag)</a>
<a name="ln945">{</a>
<a name="ln946">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln947">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln948"> </a>
<a name="ln949">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln950">  {</a>
<a name="ln951">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln952">    {</a>
<a name="ln953">      float local_opacity = mask[i];</a>
<a name="ln954">      float ta[3], tb[3];</a>
<a name="ln955">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln956">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln957">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln958">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln959">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln960">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln961"> </a>
<a name="ln962">      tb[0] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln963">              - fabsf(min[0]);</a>
<a name="ln964"> </a>
<a name="ln965">      if(flag == 0)</a>
<a name="ln966">      {</a>
<a name="ln967">        lmax = max[1] + fabsf(min[1]);</a>
<a name="ln968">        la = CLAMP_RANGE(ta[1] + fabsf(min[1]), lmin, lmax);</a>
<a name="ln969">        lb = CLAMP_RANGE(tb[1] + fabsf(min[1]), lmin, lmax);</a>
<a name="ln970">        tb[1] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln971">                - fabsf(min[1]);</a>
<a name="ln972">        lmax = max[2] + fabsf(min[2]);</a>
<a name="ln973">        la = CLAMP_RANGE(ta[2] + fabsf(min[2]), lmin, lmax);</a>
<a name="ln974">        lb = CLAMP_RANGE(tb[2] + fabsf(min[2]), lmin, lmax);</a>
<a name="ln975">        tb[2] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln976">                - fabsf(min[2]);</a>
<a name="ln977">      }</a>
<a name="ln978">      else</a>
<a name="ln979">      {</a>
<a name="ln980">        tb[1] = ta[1];</a>
<a name="ln981">        tb[2] = ta[2];</a>
<a name="ln982">      }</a>
<a name="ln983"> </a>
<a name="ln984">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln985">      b[j + 3] = local_opacity;</a>
<a name="ln986">    }</a>
<a name="ln987">  }</a>
<a name="ln988">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln989">  {</a>
<a name="ln990">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln991">    {</a>
<a name="ln992">      float local_opacity = mask[i];</a>
<a name="ln993">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln994">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln995">      {</a>
<a name="ln996">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln997">        la = a[j + k] + fabsf(min[k]);</a>
<a name="ln998">        lb = b[j + k] + fabsf(min[k]);</a>
<a name="ln999"> </a>
<a name="ln1000">        b[j + k] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln1001">                   - fabsf(min[k]);</a>
<a name="ln1002">      }</a>
<a name="ln1003">      b[j + 3] = local_opacity;</a>
<a name="ln1004">    }</a>
<a name="ln1005">  }</a>
<a name="ln1006">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1007">  {</a>
<a name="ln1008">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1009">    {</a>
<a name="ln1010">      float local_opacity = mask[i];</a>
<a name="ln1011">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1012">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1013">      {</a>
<a name="ln1014">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1015">        la = a[j + k] + fabsf(min[k]);</a>
<a name="ln1016">        lb = b[j + k] + fabsf(min[k]);</a>
<a name="ln1017"> </a>
<a name="ln1018">        b[j + k] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln1019">                   - fabsf(min[k]);</a>
<a name="ln1020">      }</a>
<a name="ln1021">    }</a>
<a name="ln1022">  }</a>
<a name="ln1023">  // return fabsf(a-b);</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026">/* difference 2 (new) */</a>
<a name="ln1027">static void _blend_difference2(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1028">                               int flag)</a>
<a name="ln1029">{</a>
<a name="ln1030">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1031">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1032"> </a>
<a name="ln1033">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1034">  {</a>
<a name="ln1035">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1036">    {</a>
<a name="ln1037">      float local_opacity = mask[i];</a>
<a name="ln1038">      float ta[3], tb[3];</a>
<a name="ln1039">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1040">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1041"> </a>
<a name="ln1042">      tb[0] = fabsf(ta[0] - tb[0]) / fabsf(max[0] - min[0]);</a>
<a name="ln1043">      tb[1] = fabsf(ta[1] - tb[1]) / fabsf(max[1] - min[1]);</a>
<a name="ln1044">      tb[2] = fabsf(ta[2] - tb[2]) / fabsf(max[2] - min[2]);</a>
<a name="ln1045">      tb[0] = fmaxf(tb[0], fmaxf(tb[1], tb[2]));</a>
<a name="ln1046"> </a>
<a name="ln1047">      tb[0] = CLAMP_RANGE(ta[0] * (1.0f - local_opacity) + tb[0] * local_opacity, min[0], max[0]);</a>
<a name="ln1048"> </a>
<a name="ln1049">      if(flag == 0)</a>
<a name="ln1050">      {</a>
<a name="ln1051">        tb[1] = 0.0f;</a>
<a name="ln1052">        tb[2] = 0.0f;</a>
<a name="ln1053">      }</a>
<a name="ln1054">      else</a>
<a name="ln1055">      {</a>
<a name="ln1056">        tb[1] = ta[1];</a>
<a name="ln1057">        tb[2] = ta[2];</a>
<a name="ln1058">      }</a>
<a name="ln1059"> </a>
<a name="ln1060">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1061">      b[j + 3] = local_opacity;</a>
<a name="ln1062">    }</a>
<a name="ln1063">  }</a>
<a name="ln1064">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1065">  {</a>
<a name="ln1066">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1067">    {</a>
<a name="ln1068">      float local_opacity = mask[i];</a>
<a name="ln1069">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1070">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1071">      {</a>
<a name="ln1072">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1073">        la = a[j + k] + fabsf(min[k]);</a>
<a name="ln1074">        lb = b[j + k] + fabsf(min[k]);</a>
<a name="ln1075"> </a>
<a name="ln1076">        b[j + k] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln1077">                   - fabsf(min[k]);</a>
<a name="ln1078">      }</a>
<a name="ln1079"> </a>
<a name="ln1080">      b[j + 3] = local_opacity;</a>
<a name="ln1081">    }</a>
<a name="ln1082">  }</a>
<a name="ln1083">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1084">  {</a>
<a name="ln1085">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1086">    {</a>
<a name="ln1087">      float local_opacity = mask[i];</a>
<a name="ln1088">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1089">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1090">      {</a>
<a name="ln1091">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1092">        la = a[j + k] + fabsf(min[k]);</a>
<a name="ln1093">        lb = b[j + k] + fabsf(min[k]);</a>
<a name="ln1094"> </a>
<a name="ln1095">        b[j + k] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln1096">                   - fabsf(min[k]);</a>
<a name="ln1097">      }</a>
<a name="ln1098">    }</a>
<a name="ln1099">  }</a>
<a name="ln1100">  // return fabsf(a-b);</a>
<a name="ln1101">}</a>
<a name="ln1102"> </a>
<a name="ln1103">/* screen */</a>
<a name="ln1104">static void _blend_screen(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1105">                          int flag)</a>
<a name="ln1106">{</a>
<a name="ln1107">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1108">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1109"> </a>
<a name="ln1110">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1111">  {</a>
<a name="ln1112">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1113">    {</a>
<a name="ln1114">      float local_opacity = mask[i];</a>
<a name="ln1115">      float ta[3], tb[3];</a>
<a name="ln1116">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1117">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1118">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1119">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1120">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1121">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1122"> </a>
<a name="ln1123">      tb[0] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (((lmax - (lmax - la) * (lmax - lb))) * local_opacity),</a>
<a name="ln1124">                          lmin, lmax)</a>
<a name="ln1125">              - fabsf(min[0]);</a>
<a name="ln1126"> </a>
<a name="ln1127">      if(flag == 0)</a>
<a name="ln1128">      {</a>
<a name="ln1129">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1130">        {</a>
<a name="ln1131">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity)</a>
<a name="ln1132">                              + 0.5f * (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity,</a>
<a name="ln1133">                              min[1], max[1]);</a>
<a name="ln1134">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity)</a>
<a name="ln1135">                              + 0.5f * (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity,</a>
<a name="ln1136">                              min[2], max[2]);</a>
<a name="ln1137">        }</a>
<a name="ln1138">        else</a>
<a name="ln1139">        {</a>
<a name="ln1140">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity)</a>
<a name="ln1141">                              + 0.5f * (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity,</a>
<a name="ln1142">                              min[1], max[1]);</a>
<a name="ln1143">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity)</a>
<a name="ln1144">                              + 0.5f * (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity,</a>
<a name="ln1145">                              min[2], max[2]);</a>
<a name="ln1146">        }</a>
<a name="ln1147">      }</a>
<a name="ln1148">      else</a>
<a name="ln1149">      {</a>
<a name="ln1150">        tb[1] = ta[1];</a>
<a name="ln1151">        tb[2] = ta[2];</a>
<a name="ln1152">      }</a>
<a name="ln1153"> </a>
<a name="ln1154">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1155">      b[j + 3] = local_opacity;</a>
<a name="ln1156">    }</a>
<a name="ln1157">  }</a>
<a name="ln1158">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1159">  {</a>
<a name="ln1160">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1161">    {</a>
<a name="ln1162">      float local_opacity = mask[i];</a>
<a name="ln1163">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1164">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1165">      {</a>
<a name="ln1166">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1167">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1168">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1169"> </a>
<a name="ln1170">        b[j + k]</a>
<a name="ln1171">            = CLAMP_RANGE((la * (1.0f - local_opacity)) + (((lmax - (lmax - la) * (lmax - lb))) * local_opacity),</a>
<a name="ln1172">                          lmin, lmax)</a>
<a name="ln1173">              - fabsf(min[k]);</a>
<a name="ln1174">      }</a>
<a name="ln1175">      b[j + 3] = local_opacity;</a>
<a name="ln1176">    }</a>
<a name="ln1177">  }</a>
<a name="ln1178">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1179">  {</a>
<a name="ln1180">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1181">    {</a>
<a name="ln1182">      float local_opacity = mask[i];</a>
<a name="ln1183">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1184">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1185">      {</a>
<a name="ln1186">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1187">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1188">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1189"> </a>
<a name="ln1190">        b[j + k]</a>
<a name="ln1191">            = CLAMP_RANGE((la * (1.0f - local_opacity)) + (((lmax - (lmax - la) * (lmax - lb))) * local_opacity),</a>
<a name="ln1192">                          lmin, lmax)</a>
<a name="ln1193">              - fabsf(min[k]);</a>
<a name="ln1194">      }</a>
<a name="ln1195">    }</a>
<a name="ln1196">  }</a>
<a name="ln1197">  /*</a>
<a name="ln1198">  float max,min;</a>
<a name="ln1199">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1200">  return max - (max-a) * (max-b);</a>
<a name="ln1201">  */</a>
<a name="ln1202">}</a>
<a name="ln1203"> </a>
<a name="ln1204">/* overlay */</a>
<a name="ln1205">static void _blend_overlay(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1206">                           int flag)</a>
<a name="ln1207">{</a>
<a name="ln1208">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1209">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1210"> </a>
<a name="ln1211">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1212">  {</a>
<a name="ln1213">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1214">    {</a>
<a name="ln1215">      float local_opacity = mask[i];</a>
<a name="ln1216">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1217">      float ta[3], tb[3];</a>
<a name="ln1218">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1219">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1220">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1221">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1222">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1223">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1224">      halfmax = lmax / 2.0f;</a>
<a name="ln1225">      doublemax = lmax * 2.0f;</a>
<a name="ln1226"> </a>
<a name="ln1227">      tb[0] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1228">                           + ((la &gt; halfmax) ? (lmax - (lmax - doublemax * (la - halfmax)) * (lmax - lb))</a>
<a name="ln1229">                                             : ((doublemax * la) * lb))</a>
<a name="ln1230">                                 * local_opacity2),</a>
<a name="ln1231">                          lmin, lmax)</a>
<a name="ln1232">              - fabsf(min[0]);</a>
<a name="ln1233"> </a>
<a name="ln1234">      if(flag == 0)</a>
<a name="ln1235">      {</a>
<a name="ln1236">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1237">        {</a>
<a name="ln1238">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1239">                              + (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1240">                              min[1], max[1]);</a>
<a name="ln1241">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1242">                              + (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1243">                              min[2], max[2]);</a>
<a name="ln1244">        }</a>
<a name="ln1245">        else</a>
<a name="ln1246">        {</a>
<a name="ln1247">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1248">                              + (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1249">                              min[1], max[1]);</a>
<a name="ln1250">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1251">                              + (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1252">                              min[2], max[2]);</a>
<a name="ln1253">        }</a>
<a name="ln1254">      }</a>
<a name="ln1255">      else</a>
<a name="ln1256">      {</a>
<a name="ln1257">        tb[1] = ta[1];</a>
<a name="ln1258">        tb[2] = ta[2];</a>
<a name="ln1259">      }</a>
<a name="ln1260"> </a>
<a name="ln1261">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1262">      b[j + 3] = local_opacity;</a>
<a name="ln1263">    }</a>
<a name="ln1264">  }</a>
<a name="ln1265">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1266">  {</a>
<a name="ln1267">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1268">    {</a>
<a name="ln1269">      float local_opacity = mask[i];</a>
<a name="ln1270">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1271">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1272">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1273">      {</a>
<a name="ln1274">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1275">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1276">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1277">        halfmax = lmax / 2.0f;</a>
<a name="ln1278">        doublemax = lmax * 2.0f;</a>
<a name="ln1279"> </a>
<a name="ln1280">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1281">                                + ((la &gt; halfmax) ? (lmax - (lmax - doublemax * (la - halfmax)) * (lmax - lb))</a>
<a name="ln1282">                                                  : ((doublemax * la) * lb))</a>
<a name="ln1283">                                      * local_opacity2),</a>
<a name="ln1284">                               lmin, lmax)</a>
<a name="ln1285">                   - fabsf(min[k]);</a>
<a name="ln1286">      }</a>
<a name="ln1287">      b[j + 3] = local_opacity;</a>
<a name="ln1288">    }</a>
<a name="ln1289">  }</a>
<a name="ln1290">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1291">  {</a>
<a name="ln1292">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1293">    {</a>
<a name="ln1294">      float local_opacity = mask[i];</a>
<a name="ln1295">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1296">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1297">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1298">      {</a>
<a name="ln1299">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1300">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1301">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1302">        halfmax = lmax / 2.0f;</a>
<a name="ln1303">        doublemax = lmax * 2.0f;</a>
<a name="ln1304"> </a>
<a name="ln1305">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1306">                                + ((la &gt; halfmax) ? (lmax - (lmax - doublemax * (la - halfmax)) * (lmax - lb))</a>
<a name="ln1307">                                                  : ((doublemax * la) * lb))</a>
<a name="ln1308">                                      * local_opacity2),</a>
<a name="ln1309">                               lmin, lmax)</a>
<a name="ln1310">                   - fabsf(min[k]);</a>
<a name="ln1311">      }</a>
<a name="ln1312">    }</a>
<a name="ln1313">  }</a>
<a name="ln1314">  /*</a>
<a name="ln1315">    float max,min;</a>
<a name="ln1316">    _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1317">    const float halfmax=max/2.0;</a>
<a name="ln1318">    const float doublemax=max*2.0;</a>
<a name="ln1319">    return (a&gt;halfmax) ? max - (max - doublemax*(a-halfmax)) * (max-b) :</a>
<a name="ln1320">    (doublemax*a) * b;</a>
<a name="ln1321">    */</a>
<a name="ln1322">}</a>
<a name="ln1323"> </a>
<a name="ln1324">/* softlight */</a>
<a name="ln1325">static void _blend_softlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1326">                             int flag)</a>
<a name="ln1327">{</a>
<a name="ln1328"> </a>
<a name="ln1329">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1330">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1331"> </a>
<a name="ln1332">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1333">  {</a>
<a name="ln1334">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1335">    {</a>
<a name="ln1336">      float local_opacity = mask[i];</a>
<a name="ln1337">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1338">      float ta[3], tb[3];</a>
<a name="ln1339">      float lmin = 0.0f, lmax, la, lb, halfmax;</a>
<a name="ln1340">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1341">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1342">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1343">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1344">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1345">      halfmax = lmax / 2.0f;</a>
<a name="ln1346"> </a>
<a name="ln1347">      tb[0] = CLAMP_RANGE(</a>
<a name="ln1348">                  ((la * (1.0f - local_opacity2))</a>
<a name="ln1349">                   + ((lb &gt; halfmax) ? (lmax - (lmax - la) * (lmax - (lb - halfmax))) : (la * (lb + halfmax)))</a>
<a name="ln1350">                         * local_opacity2),</a>
<a name="ln1351">                  lmin, lmax)</a>
<a name="ln1352">              - fabsf(min[0]);</a>
<a name="ln1353"> </a>
<a name="ln1354">      if(flag == 0)</a>
<a name="ln1355">      {</a>
<a name="ln1356">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1357">        {</a>
<a name="ln1358">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1359">                              + (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1360">                              min[1], max[1]);</a>
<a name="ln1361">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1362">                              + (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1363">                              min[2], max[2]);</a>
<a name="ln1364">        }</a>
<a name="ln1365">        else</a>
<a name="ln1366">        {</a>
<a name="ln1367">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1368">                              + (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1369">                              min[1], max[1]);</a>
<a name="ln1370">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1371">                              + (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1372">                              min[2], max[2]);</a>
<a name="ln1373">        }</a>
<a name="ln1374">      }</a>
<a name="ln1375">      else</a>
<a name="ln1376">      {</a>
<a name="ln1377">        tb[1] = ta[1];</a>
<a name="ln1378">        tb[2] = ta[2];</a>
<a name="ln1379">      }</a>
<a name="ln1380"> </a>
<a name="ln1381">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1382">      b[j + 3] = local_opacity;</a>
<a name="ln1383">    }</a>
<a name="ln1384">  }</a>
<a name="ln1385">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1386">  {</a>
<a name="ln1387">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1388">    {</a>
<a name="ln1389">      float local_opacity = mask[i];</a>
<a name="ln1390">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1391">      float lmin = 0.0f, lmax, la, lb, halfmax;</a>
<a name="ln1392">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1393">      {</a>
<a name="ln1394">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1395">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1396">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1397">        halfmax = lmax / 2.0f;</a>
<a name="ln1398"> </a>
<a name="ln1399">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln1400">                       ((la * (1.0f - local_opacity2))</a>
<a name="ln1401">                        + ((lb &gt; halfmax) ? (lmax - (lmax - la) * (lmax - (lb - halfmax))) : (la * (lb + halfmax)))</a>
<a name="ln1402">                              * local_opacity2),</a>
<a name="ln1403">                       lmin, lmax)</a>
<a name="ln1404">                   - fabsf(min[k]);</a>
<a name="ln1405"> </a>
<a name="ln1406">        b[j + 3] = local_opacity;</a>
<a name="ln1407">      }</a>
<a name="ln1408">    }</a>
<a name="ln1409">  }</a>
<a name="ln1410">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1411">  {</a>
<a name="ln1412">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1413">    {</a>
<a name="ln1414">      float local_opacity = mask[i];</a>
<a name="ln1415">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1416">      float lmin = 0.0f, lmax, la, lb, halfmax;</a>
<a name="ln1417">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1418">      {</a>
<a name="ln1419">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1420">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1421">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1422">        halfmax = lmax / 2.0f;</a>
<a name="ln1423"> </a>
<a name="ln1424">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln1425">                       ((la * (1.0f - local_opacity2))</a>
<a name="ln1426">                        + ((lb &gt; halfmax) ? (lmax - (lmax - la) * (lmax - (lb - halfmax))) : (la * (lb + halfmax)))</a>
<a name="ln1427">                              * local_opacity2),</a>
<a name="ln1428">                       lmin, lmax)</a>
<a name="ln1429">                   - fabsf(min[k]);</a>
<a name="ln1430">      }</a>
<a name="ln1431">    }</a>
<a name="ln1432">  }</a>
<a name="ln1433">  /*</a>
<a name="ln1434">  float max,min;</a>
<a name="ln1435">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1436">  const float halfmax=max/2.0;</a>
<a name="ln1437">  return (b&gt;halfmax) ? max - (max-a) * (max - (b-halfmax)) : a * (b+halfmax);</a>
<a name="ln1438">  */</a>
<a name="ln1439">}</a>
<a name="ln1440"> </a>
<a name="ln1441">/* hardlight */</a>
<a name="ln1442">static void _blend_hardlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1443">                             int flag)</a>
<a name="ln1444">{</a>
<a name="ln1445">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1446">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1447"> </a>
<a name="ln1448">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1449">  {</a>
<a name="ln1450">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1451">    {</a>
<a name="ln1452">      float local_opacity = mask[i];</a>
<a name="ln1453">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1454">      float ta[3], tb[3];</a>
<a name="ln1455">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1456">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1457">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1458">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1459">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1460">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1461">      halfmax = lmax / 2.0f;</a>
<a name="ln1462">      doublemax = lmax * 2.0f;</a>
<a name="ln1463"> </a>
<a name="ln1464">      tb[0] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1465">                           + ((lb &gt; halfmax) ? (lmax - (lmax - doublemax * (la - halfmax)) * (lmax - lb))</a>
<a name="ln1466">                                             : ((doublemax * la) * lb))</a>
<a name="ln1467">                                 * local_opacity2),</a>
<a name="ln1468">                          lmin, lmax)</a>
<a name="ln1469">              - fabsf(min[0]);</a>
<a name="ln1470"> </a>
<a name="ln1471">      if(flag == 0)</a>
<a name="ln1472">      {</a>
<a name="ln1473">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1474">        {</a>
<a name="ln1475">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1476">                              + (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1477">                              min[1], max[1]);</a>
<a name="ln1478">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1479">                              + (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1480">                              min[2], max[2]);</a>
<a name="ln1481">        }</a>
<a name="ln1482">        else</a>
<a name="ln1483">        {</a>
<a name="ln1484">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1485">                              + (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1486">                              min[1], max[1]);</a>
<a name="ln1487">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1488">                              + (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1489">                              min[2], max[2]);</a>
<a name="ln1490">        }</a>
<a name="ln1491">      }</a>
<a name="ln1492">      else</a>
<a name="ln1493">      {</a>
<a name="ln1494">        tb[1] = ta[1];</a>
<a name="ln1495">        tb[2] = ta[2];</a>
<a name="ln1496">      }</a>
<a name="ln1497"> </a>
<a name="ln1498">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1499">      b[j + 3] = local_opacity;</a>
<a name="ln1500">    }</a>
<a name="ln1501">  }</a>
<a name="ln1502">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1503">  {</a>
<a name="ln1504">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1505">    {</a>
<a name="ln1506">      float local_opacity = mask[i];</a>
<a name="ln1507">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1508">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1509">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1510">      {</a>
<a name="ln1511">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1512">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1513">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1514">        halfmax = lmax / 2.0f;</a>
<a name="ln1515">        doublemax = lmax * 2.0f;</a>
<a name="ln1516"> </a>
<a name="ln1517">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1518">                                + ((lb &gt; halfmax) ? (lmax - (lmax - doublemax * (la - halfmax)) * (lmax - lb))</a>
<a name="ln1519">                                                  : ((doublemax * la) * lb))</a>
<a name="ln1520">                                      * local_opacity2),</a>
<a name="ln1521">                               lmin, lmax)</a>
<a name="ln1522">                   - fabsf(min[k]);</a>
<a name="ln1523">      }</a>
<a name="ln1524">      b[j + 3] = local_opacity;</a>
<a name="ln1525">    }</a>
<a name="ln1526">  }</a>
<a name="ln1527">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1528">  {</a>
<a name="ln1529">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1530">    {</a>
<a name="ln1531">      float local_opacity = mask[i];</a>
<a name="ln1532">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1533">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1534">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1535">      {</a>
<a name="ln1536">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1537">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1538">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1539">        halfmax = lmax / 2.0f;</a>
<a name="ln1540">        doublemax = lmax * 2.0f;</a>
<a name="ln1541"> </a>
<a name="ln1542">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1543">                                + ((lb &gt; halfmax) ? (lmax - (lmax - doublemax * (la - halfmax)) * (lmax - lb))</a>
<a name="ln1544">                                                  : ((doublemax * la) * lb))</a>
<a name="ln1545">                                      * local_opacity2),</a>
<a name="ln1546">                               lmin, lmax)</a>
<a name="ln1547">                   - fabsf(min[k]);</a>
<a name="ln1548">      }</a>
<a name="ln1549">    }</a>
<a name="ln1550">  }</a>
<a name="ln1551">  /*</a>
<a name="ln1552">  float max,min;</a>
<a name="ln1553">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1554">  const float halfmax=max/2.0;</a>
<a name="ln1555">  const float doublemax=max*2.0;</a>
<a name="ln1556">  return (b&gt;halfmax) ? max - (max - doublemax*(a-halfmax)) * (max-b) :</a>
<a name="ln1557">  (doublemax*a) * b;</a>
<a name="ln1558">  */</a>
<a name="ln1559">}</a>
<a name="ln1560"> </a>
<a name="ln1561">/* vividlight */</a>
<a name="ln1562">static void _blend_vividlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1563">                              int flag)</a>
<a name="ln1564">{</a>
<a name="ln1565">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1566">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1567"> </a>
<a name="ln1568">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1569">  {</a>
<a name="ln1570">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1571">    {</a>
<a name="ln1572">      float local_opacity = mask[i];</a>
<a name="ln1573">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1574">      float ta[3], tb[3];</a>
<a name="ln1575">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1576">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1577">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1578">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1579">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1580">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1581">      halfmax = lmax / 2.0f;</a>
<a name="ln1582">      doublemax = lmax * 2.0f;</a>
<a name="ln1583"> </a>
<a name="ln1584">      tb[0] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1585">                           + ((lb &gt; halfmax) ? (lb &gt;= lmax ? lmax : la / (doublemax * (lmax - lb)))</a>
<a name="ln1586">                                             : (lb &lt;= lmin ? lmin : lmax - (lmax - la) / (doublemax * lb)))</a>
<a name="ln1587">                                 * local_opacity2),</a>
<a name="ln1588">                          lmin, lmax)</a>
<a name="ln1589">              - fabsf(min[0]);</a>
<a name="ln1590"> </a>
<a name="ln1591">      if(flag == 0)</a>
<a name="ln1592">      {</a>
<a name="ln1593">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1594">        {</a>
<a name="ln1595">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1596">                              + (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1597">                              min[1], max[1]);</a>
<a name="ln1598">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1599">                              + (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1600">                              min[2], max[2]);</a>
<a name="ln1601">        }</a>
<a name="ln1602">        else</a>
<a name="ln1603">        {</a>
<a name="ln1604">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1605">                              + (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1606">                              min[1], max[1]);</a>
<a name="ln1607">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1608">                              + (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1609">                              min[2], max[2]);</a>
<a name="ln1610">        }</a>
<a name="ln1611">      }</a>
<a name="ln1612">      else</a>
<a name="ln1613">      {</a>
<a name="ln1614">        tb[1] = ta[1];</a>
<a name="ln1615">        tb[2] = ta[2];</a>
<a name="ln1616">      }</a>
<a name="ln1617"> </a>
<a name="ln1618">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1619">      b[j + 3] = local_opacity;</a>
<a name="ln1620">    }</a>
<a name="ln1621">  }</a>
<a name="ln1622">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1623">  {</a>
<a name="ln1624">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1625">    {</a>
<a name="ln1626">      float local_opacity = mask[i];</a>
<a name="ln1627">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1628">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1629">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1630">      {</a>
<a name="ln1631">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1632">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1633">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1634">        halfmax = lmax / 2.0f;</a>
<a name="ln1635">        doublemax = lmax * 2.0f;</a>
<a name="ln1636"> </a>
<a name="ln1637">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1638">                                + ((lb &gt; halfmax) ? (lb &gt;= lmax ? lmax : la / (doublemax * (lmax - lb)))</a>
<a name="ln1639">                                                  : (lb &lt;= lmin ? lmin : lmax - (lmax - la) / (doublemax * lb)))</a>
<a name="ln1640">                                      * local_opacity2),</a>
<a name="ln1641">                               lmin, lmax)</a>
<a name="ln1642">                   - fabsf(min[k]);</a>
<a name="ln1643">      }</a>
<a name="ln1644">      b[j + 3] = local_opacity;</a>
<a name="ln1645">    }</a>
<a name="ln1646">  }</a>
<a name="ln1647">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1648">  {</a>
<a name="ln1649">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1650">    {</a>
<a name="ln1651">      float local_opacity = mask[i];</a>
<a name="ln1652">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1653">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1654">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1655">      {</a>
<a name="ln1656">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1657">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1658">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1659">        halfmax = lmax / 2.0f;</a>
<a name="ln1660">        doublemax = lmax * 2.0f;</a>
<a name="ln1661"> </a>
<a name="ln1662">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1663">                                + ((lb &gt; halfmax) ? (lb &gt;= lmax ? lmax : la / (doublemax * (lmax - lb)))</a>
<a name="ln1664">                                                  : (lb &lt;= lmin ? lmin : lmax - (lmax - la) / (doublemax * lb)))</a>
<a name="ln1665">                                      * local_opacity2),</a>
<a name="ln1666">                               lmin, lmax)</a>
<a name="ln1667">                   - fabsf(min[k]);</a>
<a name="ln1668">      }</a>
<a name="ln1669">    }</a>
<a name="ln1670">  }</a>
<a name="ln1671">  /*</a>
<a name="ln1672">  float max,min;</a>
<a name="ln1673">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1674">  const float halfmax=max/2.0;</a>
<a name="ln1675">  const float doublemax=max*2.0;</a>
<a name="ln1676">  return (b&gt;halfmax) ? a / (doublemax*(max-b)) : max - (max-a) / (doublemax*b);</a>
<a name="ln1677">  */</a>
<a name="ln1678">}</a>
<a name="ln1679"> </a>
<a name="ln1680">/* linearlight */</a>
<a name="ln1681">static void _blend_linearlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1682">                               int flag)</a>
<a name="ln1683">{</a>
<a name="ln1684">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1685">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1686"> </a>
<a name="ln1687">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1688">  {</a>
<a name="ln1689">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1690">    {</a>
<a name="ln1691">      float local_opacity = mask[i];</a>
<a name="ln1692">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1693">      float ta[3], tb[3];</a>
<a name="ln1694">      float lmin = 0.0f, lmax, la, lb, doublemax;</a>
<a name="ln1695">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1696">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1697">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1698">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1699">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1700">      doublemax = lmax * 2.0f;</a>
<a name="ln1701"> </a>
<a name="ln1702">      tb[0] = CLAMP_RANGE(((la * (1.0f - local_opacity2)) + (la + doublemax * lb - lmax) * local_opacity2), lmin,</a>
<a name="ln1703">                          lmax)</a>
<a name="ln1704">              - fabsf(min[0]);</a>
<a name="ln1705"> </a>
<a name="ln1706">      if(flag == 0)</a>
<a name="ln1707">      {</a>
<a name="ln1708">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1709">        {</a>
<a name="ln1710">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1711">                              + (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1712">                              min[1], max[1]);</a>
<a name="ln1713">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1714">                              + (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1715">                              min[2], max[2]);</a>
<a name="ln1716">        }</a>
<a name="ln1717">        else</a>
<a name="ln1718">        {</a>
<a name="ln1719">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1720">                              + (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1721">                              min[1], max[1]);</a>
<a name="ln1722">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1723">                              + (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1724">                              min[2], max[2]);</a>
<a name="ln1725">        }</a>
<a name="ln1726">      }</a>
<a name="ln1727">      else</a>
<a name="ln1728">      {</a>
<a name="ln1729">        tb[1] = ta[1];</a>
<a name="ln1730">        tb[2] = ta[2];</a>
<a name="ln1731">      }</a>
<a name="ln1732"> </a>
<a name="ln1733">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1734">      b[j + 3] = local_opacity;</a>
<a name="ln1735">    }</a>
<a name="ln1736">  }</a>
<a name="ln1737">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1738">  {</a>
<a name="ln1739">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1740">    {</a>
<a name="ln1741">      float local_opacity = mask[i];</a>
<a name="ln1742">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1743">      float lmin = 0.0f, lmax, la, lb, doublemax;</a>
<a name="ln1744">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1745">      {</a>
<a name="ln1746">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1747">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1748">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1749">        doublemax = lmax * 2.0f;</a>
<a name="ln1750"> </a>
<a name="ln1751">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2)) + (la + doublemax * lb - lmax) * local_opacity2),</a>
<a name="ln1752">                               lmin, lmax)</a>
<a name="ln1753">                   - fabsf(min[k]);</a>
<a name="ln1754">      }</a>
<a name="ln1755">      b[j + 3] = local_opacity;</a>
<a name="ln1756">    }</a>
<a name="ln1757">  }</a>
<a name="ln1758">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1759">  {</a>
<a name="ln1760">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1761">    {</a>
<a name="ln1762">      float local_opacity = mask[i];</a>
<a name="ln1763">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1764">      float lmin = 0.0f, lmax, la, lb, doublemax;</a>
<a name="ln1765">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1766">      {</a>
<a name="ln1767">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1768">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1769">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1770">        doublemax = lmax * 2.0f;</a>
<a name="ln1771"> </a>
<a name="ln1772">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2)) + (la + doublemax * lb - lmax) * local_opacity2),</a>
<a name="ln1773">                               lmin, lmax)</a>
<a name="ln1774">                   - fabsf(min[k]);</a>
<a name="ln1775">      }</a>
<a name="ln1776">    }</a>
<a name="ln1777">  }</a>
<a name="ln1778">  /*</a>
<a name="ln1779">  float max,min;</a>
<a name="ln1780">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1781">  const float halfmax=max/2.0;</a>
<a name="ln1782">  const float doublemax=max*2.0;</a>
<a name="ln1783">  return a +doublemax*b-max;</a>
<a name="ln1784">  */</a>
<a name="ln1785">}</a>
<a name="ln1786"> </a>
<a name="ln1787">/* pinlight */</a>
<a name="ln1788">static void _blend_pinlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1789">                            int flag)</a>
<a name="ln1790">{</a>
<a name="ln1791">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1792">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1793"> </a>
<a name="ln1794">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1795">  {</a>
<a name="ln1796">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1797">    {</a>
<a name="ln1798">      float local_opacity = mask[i];</a>
<a name="ln1799">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1800">      float ta[3], tb[3];</a>
<a name="ln1801">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1802">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1803">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1804">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1805">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1806">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1807">      halfmax = lmax / 2.0f;</a>
<a name="ln1808">      doublemax = lmax * 2.0f;</a>
<a name="ln1809"> </a>
<a name="ln1810">      tb[0]</a>
<a name="ln1811">          = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1812">                         + ((lb &gt; halfmax) ? (fmaxf(la, doublemax * (lb - halfmax))) : (fminf(la, doublemax * lb)))</a>
<a name="ln1813">                               * local_opacity2),</a>
<a name="ln1814">                        lmin, lmax)</a>
<a name="ln1815">            - fabsf(min[0]);</a>
<a name="ln1816"> </a>
<a name="ln1817">      tb[1] = CLAMP_RANGE(ta[1], min[1], max[1]);</a>
<a name="ln1818">      tb[2] = CLAMP_RANGE(ta[2], min[2], max[2]);</a>
<a name="ln1819"> </a>
<a name="ln1820">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1821">      b[j + 3] = local_opacity;</a>
<a name="ln1822">    }</a>
<a name="ln1823">  }</a>
<a name="ln1824">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1825">  {</a>
<a name="ln1826">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1827">    {</a>
<a name="ln1828">      float local_opacity = mask[i];</a>
<a name="ln1829">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1830">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1831">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1832">      {</a>
<a name="ln1833">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1834">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1835">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1836">        halfmax = lmax / 2.0f;</a>
<a name="ln1837">        doublemax = lmax * 2.0f;</a>
<a name="ln1838"> </a>
<a name="ln1839">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln1840">                       ((la * (1.0f - local_opacity2))</a>
<a name="ln1841">                        + ((lb &gt; halfmax) ? (fmaxf(la, doublemax * (lb - halfmax))) : (fminf(la, doublemax * lb)))</a>
<a name="ln1842">                              * local_opacity2),</a>
<a name="ln1843">                       lmin, lmax)</a>
<a name="ln1844">                   - fabsf(min[k]);</a>
<a name="ln1845">      }</a>
<a name="ln1846">      b[j + 3] = local_opacity;</a>
<a name="ln1847">    }</a>
<a name="ln1848">  }</a>
<a name="ln1849">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1850">  {</a>
<a name="ln1851">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1852">    {</a>
<a name="ln1853">      float local_opacity = mask[i];</a>
<a name="ln1854">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1855">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1856">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1857">      {</a>
<a name="ln1858">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1859">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1860">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1861">        halfmax = lmax / 2.0f;</a>
<a name="ln1862">        doublemax = lmax * 2.0f;</a>
<a name="ln1863"> </a>
<a name="ln1864">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln1865">                       ((la * (1.0f - local_opacity2))</a>
<a name="ln1866">                        + ((lb &gt; halfmax) ? (fmaxf(la, doublemax * (lb - halfmax))) : (fminf(la, doublemax * lb)))</a>
<a name="ln1867">                              * local_opacity2),</a>
<a name="ln1868">                       lmin, lmax)</a>
<a name="ln1869">                   - fabsf(min[k]);</a>
<a name="ln1870">      }</a>
<a name="ln1871">    }</a>
<a name="ln1872">  }</a>
<a name="ln1873">  /*</a>
<a name="ln1874">  float max,min;</a>
<a name="ln1875">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1876">  const float halfmax=max/2.0;</a>
<a name="ln1877">  const float doublemax=max*2.0;</a>
<a name="ln1878">  return (b&gt;halfmax) ? fmaxf(a,doublemax*(b-halfmax)) : fminf(a,doublemax*b);</a>
<a name="ln1879">  */</a>
<a name="ln1880">}</a>
<a name="ln1881"> </a>
<a name="ln1882">/* lightness blend */</a>
<a name="ln1883">static void _blend_lightness(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1884">                             int flag)</a>
<a name="ln1885">{</a>
<a name="ln1886">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1887">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1888"> </a>
<a name="ln1889">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1890">  {</a>
<a name="ln1891">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1892">    {</a>
<a name="ln1893">      float local_opacity = mask[i];</a>
<a name="ln1894">      float ta[3], tb[3];</a>
<a name="ln1895">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1896">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1897"> </a>
<a name="ln1898">      // no need to transfer to LCH as L is the same as in Lab, and C and H</a>
<a name="ln1899">      // remain unchanged</a>
<a name="ln1900">      tb[0] = CLAMP_RANGE((ta[0] * (1.0f - local_opacity)) + tb[0] * local_opacity, min[0], max[0]);</a>
<a name="ln1901">      tb[1] = CLAMP_RANGE(ta[1], min[1], max[1]);</a>
<a name="ln1902">      tb[2] = CLAMP_RANGE(ta[2], min[2], max[2]);</a>
<a name="ln1903"> </a>
<a name="ln1904">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1905">      b[j + 3] = local_opacity;</a>
<a name="ln1906">    }</a>
<a name="ln1907">  }</a>
<a name="ln1908">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1909">  {</a>
<a name="ln1910">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1911">    {</a>
<a name="ln1912">      float local_opacity = mask[i];</a>
<a name="ln1913">      float ta[3], tta[3], ttb[3];</a>
<a name="ln1914">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln1915"> </a>
<a name="ln1916">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln1917">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1918"> </a>
<a name="ln1919">      _RGB_2_HSL(ta, tta);</a>
<a name="ln1920">      _RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln1921"> </a>
<a name="ln1922">      ttb[0] = tta[0];</a>
<a name="ln1923">      ttb[1] = tta[1];</a>
<a name="ln1924">      ttb[2] = (tta[2] * (1.0f - local_opacity)) + ttb[2] * local_opacity;</a>
<a name="ln1925"> </a>
<a name="ln1926">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln1927">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1928"> </a>
<a name="ln1929">      b[j + 3] = local_opacity;</a>
<a name="ln1930">    }</a>
<a name="ln1931">  }</a>
<a name="ln1932">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1933">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln1934">}</a>
<a name="ln1935"> </a>
<a name="ln1936">/* chroma blend */</a>
<a name="ln1937">static void _blend_chroma(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1938">                          int flag)</a>
<a name="ln1939">{</a>
<a name="ln1940">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1941">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1942"> </a>
<a name="ln1943">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1944">  {</a>
<a name="ln1945">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1946">    {</a>
<a name="ln1947">      float local_opacity = mask[i];</a>
<a name="ln1948">      float ta[3], tb[3];</a>
<a name="ln1949">      float tta[3], ttb[3];</a>
<a name="ln1950">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1951">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln1952">      _Lab_2_LCH(ta, tta);</a>
<a name="ln1953"> </a>
<a name="ln1954">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1955">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln1956">      _Lab_2_LCH(tb, ttb);</a>
<a name="ln1957"> </a>
<a name="ln1958">      ttb[0] = tta[0];</a>
<a name="ln1959">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln1960">      ttb[2] = tta[2];</a>
<a name="ln1961"> </a>
<a name="ln1962">      _LCH_2_Lab(ttb, tb);</a>
<a name="ln1963">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln1964">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1965"> </a>
<a name="ln1966">      b[j + 3] = local_opacity;</a>
<a name="ln1967">    }</a>
<a name="ln1968">  }</a>
<a name="ln1969">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1970">  {</a>
<a name="ln1971">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1972">    {</a>
<a name="ln1973">      float local_opacity = mask[i];</a>
<a name="ln1974">      float ta[3], tta[3], ttb[3];</a>
<a name="ln1975">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln1976"> </a>
<a name="ln1977">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln1978">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1979"> </a>
<a name="ln1980">      _RGB_2_HSL(ta, tta);</a>
<a name="ln1981">      _RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln1982"> </a>
<a name="ln1983">      ttb[0] = tta[0];</a>
<a name="ln1984">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln1985">      ttb[2] = tta[2];</a>
<a name="ln1986"> </a>
<a name="ln1987">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln1988">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1989"> </a>
<a name="ln1990">      b[j + 3] = local_opacity;</a>
<a name="ln1991">    }</a>
<a name="ln1992">  }</a>
<a name="ln1993">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1994">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln1995">}</a>
<a name="ln1996"> </a>
<a name="ln1997">/* hue blend */</a>
<a name="ln1998">static void _blend_hue(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask, int flag)</a>
<a name="ln1999">{</a>
<a name="ln2000">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln2001">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln2002"> </a>
<a name="ln2003">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2004">  {</a>
<a name="ln2005">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2006">    {</a>
<a name="ln2007">      float local_opacity = mask[i];</a>
<a name="ln2008">      float ta[3], tb[3];</a>
<a name="ln2009">      float tta[3], ttb[3];</a>
<a name="ln2010">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2011">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2012">      _Lab_2_LCH(ta, tta);</a>
<a name="ln2013"> </a>
<a name="ln2014">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2015">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2016">      _Lab_2_LCH(tb, ttb);</a>
<a name="ln2017"> </a>
<a name="ln2018">      ttb[0] = tta[0];</a>
<a name="ln2019">      ttb[1] = tta[1];</a>
<a name="ln2020">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2021">      float d = fabsf(tta[2] - ttb[2]);</a>
<a name="ln2022">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2023">      ttb[2] = fmodf((tta[2] * (1.0f - s)) + ttb[2] * s + 1.0f, 1.0f);</a>
<a name="ln2024"> </a>
<a name="ln2025">      _LCH_2_Lab(ttb, tb);</a>
<a name="ln2026">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2027">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2028"> </a>
<a name="ln2029">      b[j + 3] = local_opacity;</a>
<a name="ln2030">    }</a>
<a name="ln2031">  }</a>
<a name="ln2032">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2033">  {</a>
<a name="ln2034">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2035">    {</a>
<a name="ln2036">      float local_opacity = mask[i];</a>
<a name="ln2037">      float ta[3], tta[3], ttb[3];</a>
<a name="ln2038">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln2039"> </a>
<a name="ln2040">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2041">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2042"> </a>
<a name="ln2043">      _RGB_2_HSL(ta, tta);</a>
<a name="ln2044">      _RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln2045"> </a>
<a name="ln2046">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2047">      float d = fabsf(tta[0] - ttb[0]);</a>
<a name="ln2048">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2049">      ttb[0] = fmodf((tta[0] * (1.0f - s)) + ttb[0] * s + 1.0f, 1.0f);</a>
<a name="ln2050">      ttb[1] = tta[1];</a>
<a name="ln2051">      ttb[2] = tta[2];</a>
<a name="ln2052"> </a>
<a name="ln2053">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln2054">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2055"> </a>
<a name="ln2056">      b[j + 3] = local_opacity;</a>
<a name="ln2057">    }</a>
<a name="ln2058">  }</a>
<a name="ln2059">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2060">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln2061">}</a>
<a name="ln2062"> </a>
<a name="ln2063">/* color blend; blend hue and chroma, but not lightness */</a>
<a name="ln2064">static void _blend_color(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask, int flag)</a>
<a name="ln2065">{</a>
<a name="ln2066">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln2067">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln2068"> </a>
<a name="ln2069">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2070">  {</a>
<a name="ln2071">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2072">    {</a>
<a name="ln2073">      float local_opacity = mask[i];</a>
<a name="ln2074">      float ta[3], tb[3];</a>
<a name="ln2075">      float tta[3], ttb[3];</a>
<a name="ln2076">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2077">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2078">      _Lab_2_LCH(ta, tta);</a>
<a name="ln2079"> </a>
<a name="ln2080">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2081">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2082">      _Lab_2_LCH(tb, ttb);</a>
<a name="ln2083"> </a>
<a name="ln2084">      ttb[0] = tta[0];</a>
<a name="ln2085">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln2086"> </a>
<a name="ln2087">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2088">      float d = fabsf(tta[2] - ttb[2]);</a>
<a name="ln2089">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2090">      ttb[2] = fmodf((tta[2] * (1.0f - s)) + ttb[2] * s + 1.0f, 1.0f);</a>
<a name="ln2091"> </a>
<a name="ln2092">      _LCH_2_Lab(ttb, tb);</a>
<a name="ln2093">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2094">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2095"> </a>
<a name="ln2096"> </a>
<a name="ln2097">      b[j + 3] = local_opacity;</a>
<a name="ln2098">    }</a>
<a name="ln2099">  }</a>
<a name="ln2100">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2101">  {</a>
<a name="ln2102">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2103">    {</a>
<a name="ln2104">      float local_opacity = mask[i];</a>
<a name="ln2105">      float ta[3], tta[3], ttb[3];</a>
<a name="ln2106">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln2107"> </a>
<a name="ln2108">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2109">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2110"> </a>
<a name="ln2111">      _RGB_2_HSL(ta, tta);</a>
<a name="ln2112">      _RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln2113"> </a>
<a name="ln2114">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2115">      float d = fabsf(tta[0] - ttb[0]);</a>
<a name="ln2116">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2117">      ttb[0] = fmodf((tta[0] * (1.0f - s)) + ttb[0] * s + 1.0f, 1.0f);</a>
<a name="ln2118"> </a>
<a name="ln2119">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln2120">      ttb[2] = tta[2];</a>
<a name="ln2121"> </a>
<a name="ln2122">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln2123">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2124"> </a>
<a name="ln2125">      b[j + 3] = local_opacity;</a>
<a name="ln2126">    }</a>
<a name="ln2127">  }</a>
<a name="ln2128">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2129">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln2130">}</a>
<a name="ln2131"> </a>
<a name="ln2132">/* color adjustment; blend hue and chroma; take lightness from module output */</a>
<a name="ln2133">static void _blend_coloradjust(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2134">                               int flag)</a>
<a name="ln2135">{</a>
<a name="ln2136">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln2137">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln2138"> </a>
<a name="ln2139">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2140">  {</a>
<a name="ln2141">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2142">    {</a>
<a name="ln2143">      float local_opacity = mask[i];</a>
<a name="ln2144">      float ta[3], tb[3];</a>
<a name="ln2145">      float tta[3], ttb[3];</a>
<a name="ln2146">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2147">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2148">      _Lab_2_LCH(ta, tta);</a>
<a name="ln2149"> </a>
<a name="ln2150">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2151">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2152">      _Lab_2_LCH(tb, ttb);</a>
<a name="ln2153"> </a>
<a name="ln2154">      // ttb[0] (output lightness) unchanged</a>
<a name="ln2155">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln2156"> </a>
<a name="ln2157">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2158">      float d = fabsf(tta[2] - ttb[2]);</a>
<a name="ln2159">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2160">      ttb[2] = fmodf((tta[2] * (1.0f - s)) + ttb[2] * s + 1.0f, 1.0f);</a>
<a name="ln2161"> </a>
<a name="ln2162">      _LCH_2_Lab(ttb, tb);</a>
<a name="ln2163">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2164">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2165"> </a>
<a name="ln2166">      b[j + 3] = local_opacity;</a>
<a name="ln2167">    }</a>
<a name="ln2168">  }</a>
<a name="ln2169">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2170">  {</a>
<a name="ln2171">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2172">    {</a>
<a name="ln2173">      float local_opacity = mask[i];</a>
<a name="ln2174">      float ta[3], tta[3], ttb[3];</a>
<a name="ln2175">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln2176"> </a>
<a name="ln2177">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2178">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2179"> </a>
<a name="ln2180">      _RGB_2_HSL(ta, tta);</a>
<a name="ln2181">      _RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln2182"> </a>
<a name="ln2183">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2184">      float d = fabsf(tta[0] - ttb[0]);</a>
<a name="ln2185">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2186">      ttb[0] = fmodf((tta[0] * (1.0f - s)) + ttb[0] * s + 1.0f, 1.0f);</a>
<a name="ln2187"> </a>
<a name="ln2188">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln2189">      // ttb[2] (output lightness) unchanged</a>
<a name="ln2190"> </a>
<a name="ln2191">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln2192">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2193"> </a>
<a name="ln2194">      b[j + 3] = local_opacity;</a>
<a name="ln2195">    }</a>
<a name="ln2196">  }</a>
<a name="ln2197">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2198">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln2199">}</a>
<a name="ln2200"> </a>
<a name="ln2201">/* inverse blend */</a>
<a name="ln2202">static void _blend_inverse(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2203">                           int flag)</a>
<a name="ln2204">{</a>
<a name="ln2205">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln2206">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln2207"> </a>
<a name="ln2208">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2209">  {</a>
<a name="ln2210">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2211">    {</a>
<a name="ln2212">      float local_opacity = mask[i];</a>
<a name="ln2213">      float ta[3], tb[3];</a>
<a name="ln2214">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2215">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2216"> </a>
<a name="ln2217">      tb[0] = CLAMP_RANGE((ta[0] * (1.0f - local_opacity)) + tb[0] * local_opacity, min[0], max[0]);</a>
<a name="ln2218"> </a>
<a name="ln2219">      if(flag == 0)</a>
<a name="ln2220">      {</a>
<a name="ln2221">        tb[1] = CLAMP_RANGE((ta[1] * (1.0f - local_opacity)) + tb[1] * local_opacity, min[1], max[1]);</a>
<a name="ln2222">        tb[2] = CLAMP_RANGE((ta[2] * (1.0f - local_opacity)) + tb[2] * local_opacity, min[2], max[2]);</a>
<a name="ln2223">      }</a>
<a name="ln2224">      else</a>
<a name="ln2225">      {</a>
<a name="ln2226">        tb[1] = ta[1];</a>
<a name="ln2227">        tb[2] = ta[2];</a>
<a name="ln2228">      }</a>
<a name="ln2229"> </a>
<a name="ln2230">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2231">      b[j + 3] = local_opacity;</a>
<a name="ln2232">    }</a>
<a name="ln2233">  }</a>
<a name="ln2234">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2235">  {</a>
<a name="ln2236">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2237">    {</a>
<a name="ln2238">      float local_opacity = mask[i];</a>
<a name="ln2239">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln2240">        b[j + k]</a>
<a name="ln2241">            = CLAMP_RANGE((a[j + k] * (1.0f - local_opacity)) + b[j + k] * local_opacity, min[k], max[k]);</a>
<a name="ln2242">      b[j + 3] = local_opacity;</a>
<a name="ln2243">    }</a>
<a name="ln2244">  }</a>
<a name="ln2245">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2246">  {</a>
<a name="ln2247">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2248">    {</a>
<a name="ln2249">      float local_opacity = mask[i];</a>
<a name="ln2250">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln2251">        b[j + k]</a>
<a name="ln2252">            = CLAMP_RANGE((a[j + k] * (1.0f - local_opacity)) + b[j + k] * local_opacity, min[k], max[k]);</a>
<a name="ln2253">    }</a>
<a name="ln2254">  }</a>
<a name="ln2255">}</a>
<a name="ln2256"> </a>
<a name="ln2257">/* blend only lightness in Lab color space without any clamping (a noop for</a>
<a name="ln2258"> * other color spaces) */</a>
<a name="ln2259">static void _blend_Lab_lightness(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2260">                                 int flag)</a>
<a name="ln2261">{</a>
<a name="ln2262">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2263">  {</a>
<a name="ln2264">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2265">    {</a>
<a name="ln2266">      float local_opacity = mask[i];</a>
<a name="ln2267">      float ta[3], tb[3];</a>
<a name="ln2268">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2269">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2270"> </a>
<a name="ln2271">      tb[0] = (ta[0] * (1.0f - local_opacity)) + tb[0] * local_opacity;</a>
<a name="ln2272">      tb[1] = ta[1];</a>
<a name="ln2273">      tb[2] = ta[2];</a>
<a name="ln2274"> </a>
<a name="ln2275">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2276">      b[j + 3] = local_opacity;</a>
<a name="ln2277">    }</a>
<a name="ln2278">  }</a>
<a name="ln2279">  else /* if(bd-&gt;cst == iop_cs_rgb || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2280">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for RGB and Raw (unclamped)</a>
<a name="ln2281">}</a>
<a name="ln2282"> </a>
<a name="ln2283">/* blend only a-channel in Lab color space without any clamping (a noop for</a>
<a name="ln2284"> * other color spaces) */</a>
<a name="ln2285">static void _blend_Lab_a(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2286">                         int flag)</a>
<a name="ln2287">{</a>
<a name="ln2288">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2289">  {</a>
<a name="ln2290">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2291">    {</a>
<a name="ln2292">      float local_opacity = mask[i];</a>
<a name="ln2293">      float ta[3], tb[3];</a>
<a name="ln2294">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2295">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2296"> </a>
<a name="ln2297">      tb[0] = ta[0];</a>
<a name="ln2298">      tb[1] = (ta[1] * (1.0f - local_opacity)) + tb[1] * local_opacity;</a>
<a name="ln2299">      tb[2] = ta[2];</a>
<a name="ln2300"> </a>
<a name="ln2301">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2302">      b[j + 3] = local_opacity;</a>
<a name="ln2303">    }</a>
<a name="ln2304">  }</a>
<a name="ln2305">  else /* if(bd-&gt;cst == iop_cs_rgb || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2306">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for RGB and Raw (unclamped)</a>
<a name="ln2307">}</a>
<a name="ln2308"> </a>
<a name="ln2309">/* blend only b-channel in Lab color space without any clamping (a noop for</a>
<a name="ln2310"> * other color spaces) */</a>
<a name="ln2311">static void _blend_Lab_b(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2312">                         int flag)</a>
<a name="ln2313">{</a>
<a name="ln2314">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2315">  {</a>
<a name="ln2316">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2317">    {</a>
<a name="ln2318">      float local_opacity = mask[i];</a>
<a name="ln2319">      float ta[3], tb[3];</a>
<a name="ln2320">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2321">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2322"> </a>
<a name="ln2323">      tb[0] = ta[0];</a>
<a name="ln2324">      tb[1] = ta[1];</a>
<a name="ln2325">      tb[2] = (ta[2] * (1.0f - local_opacity)) + tb[2] * local_opacity;</a>
<a name="ln2326"> </a>
<a name="ln2327">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2328">      b[j + 3] = local_opacity;</a>
<a name="ln2329">    }</a>
<a name="ln2330">  }</a>
<a name="ln2331">  else /* if(bd-&gt;cst == iop_cs_rgb || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2332">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for RGB and Raw (unclamped)</a>
<a name="ln2333">}</a>
<a name="ln2334"> </a>
<a name="ln2335"> </a>
<a name="ln2336">/* blend only color in Lab color space without any clamping (a noop for other</a>
<a name="ln2337"> * color spaces) */</a>
<a name="ln2338">static void _blend_Lab_color(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2339">                             int flag)</a>
<a name="ln2340">{</a>
<a name="ln2341">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2342">  {</a>
<a name="ln2343">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2344">    {</a>
<a name="ln2345">      float local_opacity = mask[i];</a>
<a name="ln2346">      float ta[3], tb[3];</a>
<a name="ln2347">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2348">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2349"> </a>
<a name="ln2350">      tb[0] = ta[0];</a>
<a name="ln2351">      tb[1] = (ta[1] * (1.0f - local_opacity)) + tb[1] * local_opacity;</a>
<a name="ln2352">      tb[2] = (ta[2] * (1.0f - local_opacity)) + tb[2] * local_opacity;</a>
<a name="ln2353"> </a>
<a name="ln2354">      if(flag != 0)</a>
<a name="ln2355">      {</a>
<a name="ln2356">        tb[1] = ta[1];</a>
<a name="ln2357">        tb[2] = ta[2];</a>
<a name="ln2358">      }</a>
<a name="ln2359"> </a>
<a name="ln2360">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2361">      b[j + 3] = local_opacity;</a>
<a name="ln2362">    }</a>
<a name="ln2363">  }</a>
<a name="ln2364">  else /* if(bd-&gt;cst == iop_cs_rgb || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2365">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for RGB and Raw (unclamped)</a>
<a name="ln2366">}</a>
<a name="ln2367"> </a>
<a name="ln2368">/* blend only lightness in HSV color space without any clamping (a noop for</a>
<a name="ln2369"> * other color spaces) */</a>
<a name="ln2370">static void _blend_HSV_lightness(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2371">                                 int flag)</a>
<a name="ln2372">{</a>
<a name="ln2373">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2374">  {</a>
<a name="ln2375">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2376">    {</a>
<a name="ln2377">      float local_opacity = mask[i];</a>
<a name="ln2378">      float ta[3], tb[3];</a>
<a name="ln2379">      _RGB_2_HSV(&amp;a[j], ta);</a>
<a name="ln2380">      _RGB_2_HSV(&amp;b[j], tb);</a>
<a name="ln2381"> </a>
<a name="ln2382">      // hue and saturation from input image</a>
<a name="ln2383">      tb[0] = ta[0];</a>
<a name="ln2384">      tb[1] = ta[1];</a>
<a name="ln2385"> </a>
<a name="ln2386">      // blend lightness between input and output</a>
<a name="ln2387">      tb[2] = ta[2] * (1.0f - local_opacity) + tb[2] * local_opacity;</a>
<a name="ln2388"> </a>
<a name="ln2389">      _HSV_2_RGB(tb, &amp;b[j]);</a>
<a name="ln2390">      b[j + 3] = local_opacity;</a>
<a name="ln2391">    }</a>
<a name="ln2392">  }</a>
<a name="ln2393">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2394">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2395">}</a>
<a name="ln2396"> </a>
<a name="ln2397">/* blend only color in HSV color space without any clamping (a noop for other</a>
<a name="ln2398"> * color spaces) */</a>
<a name="ln2399">static void _blend_HSV_color(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2400">                             int flag)</a>
<a name="ln2401">{</a>
<a name="ln2402">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2403">  {</a>
<a name="ln2404">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2405">    {</a>
<a name="ln2406">      float local_opacity = mask[i];</a>
<a name="ln2407">      float ta[3], tb[3];</a>
<a name="ln2408">      _RGB_2_HSV(&amp;a[j], ta);</a>
<a name="ln2409">      _RGB_2_HSV(&amp;b[j], tb);</a>
<a name="ln2410"> </a>
<a name="ln2411">      // convert from polar to cartesian coordinates</a>
<a name="ln2412">      float xa = ta[1] * cosf(2.0f * DT_M_PI_F * ta[0]);</a>
<a name="ln2413">      float ya = ta[1] * sinf(2.0f * DT_M_PI_F * ta[0]);</a>
<a name="ln2414">      float xb = tb[1] * cosf(2.0f * DT_M_PI_F * tb[0]);</a>
<a name="ln2415">      float yb = tb[1] * sinf(2.0f * DT_M_PI_F * tb[0]);</a>
<a name="ln2416"> </a>
<a name="ln2417">      // blend color vectors of input and output</a>
<a name="ln2418">      float xc = xa * (1.0f - local_opacity) + xb * local_opacity;</a>
<a name="ln2419">      float yc = ya * (1.0f - local_opacity) + yb * local_opacity;</a>
<a name="ln2420"> </a>
<a name="ln2421">      tb[0] = atan2f(yc, xc) / (2.0f * DT_M_PI_F);</a>
<a name="ln2422">      if(tb[0] &lt; 0.0f) tb[0] += 1.0f;</a>
<a name="ln2423">      tb[1] = sqrtf(xc * xc + yc * yc);</a>
<a name="ln2424"> </a>
<a name="ln2425">      // lightness from input image</a>
<a name="ln2426">      tb[2] = ta[2];</a>
<a name="ln2427"> </a>
<a name="ln2428">      _HSV_2_RGB(tb, &amp;b[j]);</a>
<a name="ln2429">      b[j + 3] = local_opacity;</a>
<a name="ln2430">    }</a>
<a name="ln2431">  }</a>
<a name="ln2432">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2433">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2434">}</a>
<a name="ln2435"> </a>
<a name="ln2436">/* blend only R-channel in RGB color space without any clamping (a noop for</a>
<a name="ln2437"> * other color spaces) */</a>
<a name="ln2438">static void _blend_RGB_R(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2439">                         int flag)</a>
<a name="ln2440">{</a>
<a name="ln2441">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2442">  {</a>
<a name="ln2443">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2444">    {</a>
<a name="ln2445">      float local_opacity = mask[i];</a>
<a name="ln2446"> </a>
<a name="ln2447">      b[j + 0] = (a[j + 0] * (1.0f - local_opacity)) + b[j + 0] * local_opacity;</a>
<a name="ln2448">      b[j + 1] = a[j + 1];</a>
<a name="ln2449">      b[j + 2] = a[j + 2];</a>
<a name="ln2450">      b[j + 3] = local_opacity;</a>
<a name="ln2451">    }</a>
<a name="ln2452">  }</a>
<a name="ln2453">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2454">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2455"> </a>
<a name="ln2456">}</a>
<a name="ln2457"> </a>
<a name="ln2458">/* blend only R-channel in RGB color space without any clamping (a noop for</a>
<a name="ln2459"> * other color spaces) */</a>
<a name="ln2460">static void _blend_RGB_G(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2461">                         int flag)</a>
<a name="ln2462">{</a>
<a name="ln2463">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2464">  {</a>
<a name="ln2465">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2466">    {</a>
<a name="ln2467">      float local_opacity = mask[i];</a>
<a name="ln2468"> </a>
<a name="ln2469">      b[j + 0] = a[j + 0];</a>
<a name="ln2470">      b[j + 1] = (a[j + 1] * (1.0f - local_opacity)) + b[j + 1] * local_opacity;</a>
<a name="ln2471">      b[j + 2] = a[j + 2];</a>
<a name="ln2472">      b[j + 3] = local_opacity;</a>
<a name="ln2473">    }</a>
<a name="ln2474">  }</a>
<a name="ln2475">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2476">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2477">}</a>
<a name="ln2478"> </a>
<a name="ln2479">/* blend only R-channel in RGB color space without any clamping (a noop for</a>
<a name="ln2480"> * other color spaces) */</a>
<a name="ln2481">static void _blend_RGB_B(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2482">                         int flag)</a>
<a name="ln2483">{</a>
<a name="ln2484">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2485">  {</a>
<a name="ln2486">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2487">    {</a>
<a name="ln2488">      float local_opacity = mask[i];</a>
<a name="ln2489"> </a>
<a name="ln2490">      b[j + 0] = a[j + 0];</a>
<a name="ln2491">      b[j + 1] = a[j + 1];</a>
<a name="ln2492">      b[j + 2] = (a[j + 2] * (1.0f - local_opacity)) + b[j + 2] * local_opacity;</a>
<a name="ln2493">      b[j + 3] = local_opacity;</a>
<a name="ln2494">    }</a>
<a name="ln2495">  }</a>
<a name="ln2496">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2497">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2498">}</a>
<a name="ln2499"> </a>
<a name="ln2500"> </a>
<a name="ln2501">static void display_channel(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2502">                            dt_dev_pixelpipe_display_mask_t channel)</a>
<a name="ln2503">{</a>
<a name="ln2504"> </a>
<a name="ln2505">  switch(channel &amp; DT_DEV_PIXELPIPE_DISPLAY_ANY)</a>
<a name="ln2506">  {</a>
<a name="ln2507">    case DT_DEV_PIXELPIPE_DISPLAY_L:</a>
<a name="ln2508">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2509">      {</a>
<a name="ln2510">        const float c = CLAMP_RANGE(a[j] / 100.0f, 0.0f, 1.0f);</a>
<a name="ln2511">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2512">      }</a>
<a name="ln2513">      break;</a>
<a name="ln2514">    case (DT_DEV_PIXELPIPE_DISPLAY_L | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2515">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2516">      {</a>
<a name="ln2517">        const float c = CLAMP_RANGE(b[j] / 100.0f, 0.0f, 1.0f);</a>
<a name="ln2518">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2519">      }</a>
<a name="ln2520">      break;</a>
<a name="ln2521">    case DT_DEV_PIXELPIPE_DISPLAY_a:</a>
<a name="ln2522">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2523">      {</a>
<a name="ln2524">        const float c = CLAMP_RANGE((a[j + 1] + 128.0f) / 256.0f, 0.0f, 1.0f);</a>
<a name="ln2525">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2526">      }</a>
<a name="ln2527">      break;</a>
<a name="ln2528">    case (DT_DEV_PIXELPIPE_DISPLAY_a | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2529">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2530">      {</a>
<a name="ln2531">        const float c = CLAMP_RANGE((b[j + 1] + 128.0f) / 256.0f, 0.0f, 1.0f);</a>
<a name="ln2532">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2533">      }</a>
<a name="ln2534">      break;</a>
<a name="ln2535">    case DT_DEV_PIXELPIPE_DISPLAY_b:</a>
<a name="ln2536">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2537">      {</a>
<a name="ln2538">        const float c = CLAMP_RANGE((a[j + 2] + 128.0f) / 256.0f, 0.0f, 1.0f);</a>
<a name="ln2539">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2540">      }</a>
<a name="ln2541">      break;</a>
<a name="ln2542">    case (DT_DEV_PIXELPIPE_DISPLAY_b | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2543">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2544">      {</a>
<a name="ln2545">        const float c = CLAMP_RANGE((b[j + 2] + 128.0f) / 256.0f, 0.0f, 1.0f);</a>
<a name="ln2546">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2547">      }</a>
<a name="ln2548">      break;</a>
<a name="ln2549">    case DT_DEV_PIXELPIPE_DISPLAY_R:</a>
<a name="ln2550">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2551">      {</a>
<a name="ln2552">        const float c = CLAMP_RANGE(a[j], 0.0f, 1.0f);</a>
<a name="ln2553">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2554">      }</a>
<a name="ln2555">      break;</a>
<a name="ln2556">    case (DT_DEV_PIXELPIPE_DISPLAY_R | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2557">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2558">      {</a>
<a name="ln2559">        const float c = CLAMP_RANGE(b[j], 0.0f, 1.0f);</a>
<a name="ln2560">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2561">      }</a>
<a name="ln2562">      break;</a>
<a name="ln2563">    case DT_DEV_PIXELPIPE_DISPLAY_G:</a>
<a name="ln2564">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2565">      {</a>
<a name="ln2566">        const float c = CLAMP_RANGE(a[j + 1], 0.0f, 1.0f);</a>
<a name="ln2567">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2568">      }</a>
<a name="ln2569">      break;</a>
<a name="ln2570">    case (DT_DEV_PIXELPIPE_DISPLAY_G | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2571">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2572">      {</a>
<a name="ln2573">        const float c = CLAMP_RANGE(b[j + 1], 0.0f, 1.0f);</a>
<a name="ln2574">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2575">      }</a>
<a name="ln2576">      break;</a>
<a name="ln2577">    case DT_DEV_PIXELPIPE_DISPLAY_B:</a>
<a name="ln2578">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2579">      {</a>
<a name="ln2580">        const float c = CLAMP_RANGE(a[j + 2], 0.0f, 1.0f);</a>
<a name="ln2581">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2582">      }</a>
<a name="ln2583">      break;</a>
<a name="ln2584">    case (DT_DEV_PIXELPIPE_DISPLAY_B | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2585">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2586">      {</a>
<a name="ln2587">        const float c = CLAMP_RANGE(b[j + 2], 0.0f, 1.0f);</a>
<a name="ln2588">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2589">      }</a>
<a name="ln2590">      break;</a>
<a name="ln2591">    case DT_DEV_PIXELPIPE_DISPLAY_GRAY:</a>
<a name="ln2592">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2593">      {</a>
<a name="ln2594">        const float c = CLAMP_RANGE(0.3f * a[j] + 0.59f * a[j + 1] + 0.11f * a[j + 2], 0.0f, 1.0f);</a>
<a name="ln2595">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2596">      }</a>
<a name="ln2597">      break;</a>
<a name="ln2598">    case (DT_DEV_PIXELPIPE_DISPLAY_GRAY | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2599">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2600">      {</a>
<a name="ln2601">        const float c = CLAMP_RANGE(0.3f * b[j] + 0.59f * b[j + 1] + 0.11f * b[j + 2], 0.0f, 1.0f);</a>
<a name="ln2602">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2603">      }</a>
<a name="ln2604">      break;</a>
<a name="ln2605">    case DT_DEV_PIXELPIPE_DISPLAY_LCH_C:</a>
<a name="ln2606">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2607">      {</a>
<a name="ln2608">        float LCH[3];</a>
<a name="ln2609">        _Lab_2_LCH(a + j, LCH);</a>
<a name="ln2610">        const float c = CLAMP_RANGE(LCH[1] / (128.0f * sqrtf(2.0f)), 0.0f, 1.0f);</a>
<a name="ln2611">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2612">      }</a>
<a name="ln2613">      break;</a>
<a name="ln2614">    case (DT_DEV_PIXELPIPE_DISPLAY_LCH_C | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2615">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2616">      {</a>
<a name="ln2617">        float LCH[3];</a>
<a name="ln2618">        _Lab_2_LCH(b + j, LCH);</a>
<a name="ln2619">        const float c = CLAMP_RANGE(LCH[1] / (128.0f * sqrtf(2.0f)), 0.0f, 1.0f);</a>
<a name="ln2620">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2621">      }</a>
<a name="ln2622">      break;</a>
<a name="ln2623">    case DT_DEV_PIXELPIPE_DISPLAY_LCH_h:</a>
<a name="ln2624">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2625">      {</a>
<a name="ln2626">        float LCH[3];</a>
<a name="ln2627">        _Lab_2_LCH(a + j, LCH);</a>
<a name="ln2628">        const float c = CLAMP_RANGE(LCH[2], 0.0f, 1.0f);</a>
<a name="ln2629">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2630">      }</a>
<a name="ln2631">      break;</a>
<a name="ln2632">    case (DT_DEV_PIXELPIPE_DISPLAY_LCH_h | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2633">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2634">      {</a>
<a name="ln2635">        float LCH[3];</a>
<a name="ln2636">        _Lab_2_LCH(b + j, LCH);</a>
<a name="ln2637">        const float c = CLAMP_RANGE(LCH[2], 0.0f, 1.0f);</a>
<a name="ln2638">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2639">      }</a>
<a name="ln2640">      break;</a>
<a name="ln2641">    case DT_DEV_PIXELPIPE_DISPLAY_HSL_H:</a>
<a name="ln2642">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2643">      {</a>
<a name="ln2644">        float HSL[3];</a>
<a name="ln2645">        _RGB_2_HSL(a + j, HSL);</a>
<a name="ln2646">        const float c = CLAMP_RANGE(HSL[0], 0.0f, 1.0f);</a>
<a name="ln2647">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2648">      }</a>
<a name="ln2649">      break;</a>
<a name="ln2650">    case (DT_DEV_PIXELPIPE_DISPLAY_HSL_H | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2651">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2652">      {</a>
<a name="ln2653">        float HSL[3];</a>
<a name="ln2654">        _RGB_2_HSL(b + j, HSL);</a>
<a name="ln2655">        const float c = CLAMP_RANGE(HSL[0], 0.0f, 1.0f);</a>
<a name="ln2656">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2657">      }</a>
<a name="ln2658">      break;</a>
<a name="ln2659">    case DT_DEV_PIXELPIPE_DISPLAY_HSL_S:</a>
<a name="ln2660">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2661">      {</a>
<a name="ln2662">        float HSL[3];</a>
<a name="ln2663">        _RGB_2_HSL(a + j, HSL);</a>
<a name="ln2664">        const float c = CLAMP_RANGE(HSL[1], 0.0f, 1.0f);</a>
<a name="ln2665">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2666">      }</a>
<a name="ln2667">      break;</a>
<a name="ln2668">    case (DT_DEV_PIXELPIPE_DISPLAY_HSL_S | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2669">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2670">      {</a>
<a name="ln2671">        float HSL[3];</a>
<a name="ln2672">        _RGB_2_HSL(b + j, HSL);</a>
<a name="ln2673">        const float c = CLAMP_RANGE(HSL[1], 0.0f, 1.0f);</a>
<a name="ln2674">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2675">      }</a>
<a name="ln2676">      break;</a>
<a name="ln2677">    case DT_DEV_PIXELPIPE_DISPLAY_HSL_l:</a>
<a name="ln2678">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2679">      {</a>
<a name="ln2680">        float HSL[3];</a>
<a name="ln2681">        _RGB_2_HSL(a + j, HSL);</a>
<a name="ln2682">        const float c = CLAMP_RANGE(HSL[2], 0.0f, 1.0f);</a>
<a name="ln2683">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2684">      }</a>
<a name="ln2685">      break;</a>
<a name="ln2686">    case (DT_DEV_PIXELPIPE_DISPLAY_HSL_l | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2687">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2688">      {</a>
<a name="ln2689">        float HSL[3];</a>
<a name="ln2690">        _RGB_2_HSL(b + j, HSL);</a>
<a name="ln2691">        const float c = CLAMP_RANGE(HSL[2], 0.0f, 1.0f);</a>
<a name="ln2692">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2693">      }</a>
<a name="ln2694">      break;</a>
<a name="ln2695">    default:</a>
<a name="ln2696">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2697">      {</a>
<a name="ln2698">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = 0.0f;</a>
<a name="ln2699">      }</a>
<a name="ln2700">      break;</a>
<a name="ln2701">  }</a>
<a name="ln2702"> </a>
<a name="ln2703">  if(bd-&gt;cst != iop_cs_rgb)</a>
<a name="ln2704">  {</a>
<a name="ln2705">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2706">      b[j + 3] = mask[i];</a>
<a name="ln2707">  }</a>
<a name="ln2708">}</a>
<a name="ln2709"> </a>
<a name="ln2710"> </a>
<a name="ln2711">_blend_row_func *dt_develop_choose_blend_func(const unsigned int blend_mode)</a>
<a name="ln2712">{</a>
<a name="ln2713">  _blend_row_func *blend = NULL;</a>
<a name="ln2714"> </a>
<a name="ln2715">  /* select the blend operator */</a>
<a name="ln2716">  switch(blend_mode)</a>
<a name="ln2717">  {</a>
<a name="ln2718">    case DEVELOP_BLEND_LIGHTEN:</a>
<a name="ln2719">      blend = _blend_lighten;</a>
<a name="ln2720">      break;</a>
<a name="ln2721">    case DEVELOP_BLEND_DARKEN:</a>
<a name="ln2722">      blend = _blend_darken;</a>
<a name="ln2723">      break;</a>
<a name="ln2724">    case DEVELOP_BLEND_MULTIPLY:</a>
<a name="ln2725">      blend = _blend_multiply;</a>
<a name="ln2726">      break;</a>
<a name="ln2727">    case DEVELOP_BLEND_AVERAGE:</a>
<a name="ln2728">      blend = _blend_average;</a>
<a name="ln2729">      break;</a>
<a name="ln2730">    case DEVELOP_BLEND_ADD:</a>
<a name="ln2731">      blend = _blend_add;</a>
<a name="ln2732">      break;</a>
<a name="ln2733">    case DEVELOP_BLEND_SUBSTRACT:</a>
<a name="ln2734">      blend = _blend_substract;</a>
<a name="ln2735">      break;</a>
<a name="ln2736">    case DEVELOP_BLEND_DIFFERENCE:</a>
<a name="ln2737">      blend = _blend_difference;</a>
<a name="ln2738">      break;</a>
<a name="ln2739">    case DEVELOP_BLEND_DIFFERENCE2:</a>
<a name="ln2740">      blend = _blend_difference2;</a>
<a name="ln2741">      break;</a>
<a name="ln2742">    case DEVELOP_BLEND_SCREEN:</a>
<a name="ln2743">      blend = _blend_screen;</a>
<a name="ln2744">      break;</a>
<a name="ln2745">    case DEVELOP_BLEND_OVERLAY:</a>
<a name="ln2746">      blend = _blend_overlay;</a>
<a name="ln2747">      break;</a>
<a name="ln2748">    case DEVELOP_BLEND_SOFTLIGHT:</a>
<a name="ln2749">      blend = _blend_softlight;</a>
<a name="ln2750">      break;</a>
<a name="ln2751">    case DEVELOP_BLEND_HARDLIGHT:</a>
<a name="ln2752">      blend = _blend_hardlight;</a>
<a name="ln2753">      break;</a>
<a name="ln2754">    case DEVELOP_BLEND_VIVIDLIGHT:</a>
<a name="ln2755">      blend = _blend_vividlight;</a>
<a name="ln2756">      break;</a>
<a name="ln2757">    case DEVELOP_BLEND_LINEARLIGHT:</a>
<a name="ln2758">      blend = _blend_linearlight;</a>
<a name="ln2759">      break;</a>
<a name="ln2760">    case DEVELOP_BLEND_PINLIGHT:</a>
<a name="ln2761">      blend = _blend_pinlight;</a>
<a name="ln2762">      break;</a>
<a name="ln2763">    case DEVELOP_BLEND_LIGHTNESS:</a>
<a name="ln2764">      blend = _blend_lightness;</a>
<a name="ln2765">      break;</a>
<a name="ln2766">    case DEVELOP_BLEND_CHROMA:</a>
<a name="ln2767">      blend = _blend_chroma;</a>
<a name="ln2768">      break;</a>
<a name="ln2769">    case DEVELOP_BLEND_HUE:</a>
<a name="ln2770">      blend = _blend_hue;</a>
<a name="ln2771">      break;</a>
<a name="ln2772">    case DEVELOP_BLEND_COLOR:</a>
<a name="ln2773">      blend = _blend_color;</a>
<a name="ln2774">      break;</a>
<a name="ln2775">    case DEVELOP_BLEND_INVERSE:</a>
<a name="ln2776">      blend = _blend_inverse;</a>
<a name="ln2777">      break;</a>
<a name="ln2778">    case DEVELOP_BLEND_NORMAL:</a>
<a name="ln2779">    case DEVELOP_BLEND_BOUNDED:</a>
<a name="ln2780">      blend = _blend_normal_bounded;</a>
<a name="ln2781">      break;</a>
<a name="ln2782">    case DEVELOP_BLEND_COLORADJUST:</a>
<a name="ln2783">      blend = _blend_coloradjust;</a>
<a name="ln2784">      break;</a>
<a name="ln2785">    case DEVELOP_BLEND_LAB_LIGHTNESS:</a>
<a name="ln2786">    case DEVELOP_BLEND_LAB_L:</a>
<a name="ln2787">      blend = _blend_Lab_lightness;</a>
<a name="ln2788">      break;</a>
<a name="ln2789">    case DEVELOP_BLEND_LAB_A:</a>
<a name="ln2790">      blend = _blend_Lab_a;</a>
<a name="ln2791">      break;</a>
<a name="ln2792">    case DEVELOP_BLEND_LAB_B:</a>
<a name="ln2793">      blend = _blend_Lab_b;</a>
<a name="ln2794">      break;</a>
<a name="ln2795">    case DEVELOP_BLEND_LAB_COLOR:</a>
<a name="ln2796">      blend = _blend_Lab_color;</a>
<a name="ln2797">      break;</a>
<a name="ln2798">    case DEVELOP_BLEND_HSV_LIGHTNESS:</a>
<a name="ln2799">      blend = _blend_HSV_lightness;</a>
<a name="ln2800">      break;</a>
<a name="ln2801">    case DEVELOP_BLEND_HSV_COLOR:</a>
<a name="ln2802">      blend = _blend_HSV_color;</a>
<a name="ln2803">      break;</a>
<a name="ln2804">    case DEVELOP_BLEND_RGB_R:</a>
<a name="ln2805">      blend = _blend_RGB_R;</a>
<a name="ln2806">      break;</a>
<a name="ln2807">    case DEVELOP_BLEND_RGB_G:</a>
<a name="ln2808">      blend = _blend_RGB_G;</a>
<a name="ln2809">      break;</a>
<a name="ln2810">    case DEVELOP_BLEND_RGB_B:</a>
<a name="ln2811">      blend = _blend_RGB_B;</a>
<a name="ln2812">      break;</a>
<a name="ln2813"> </a>
<a name="ln2814">    /* fallback to normal blend */</a>
<a name="ln2815">    case DEVELOP_BLEND_NORMAL2:</a>
<a name="ln2816">    case DEVELOP_BLEND_UNBOUNDED:</a>
<a name="ln2817">    default:</a>
<a name="ln2818">      blend = _blend_normal_unbounded;</a>
<a name="ln2819">      break;</a>
<a name="ln2820">  }</a>
<a name="ln2821"> </a>
<a name="ln2822">  return blend;</a>
<a name="ln2823">}</a>
<a name="ln2824"> </a>
<a name="ln2825">void dt_develop_blend_process(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln2826">                              const void *const ivoid, void *const ovoid, const struct dt_iop_roi_t *const roi_in,</a>
<a name="ln2827">                              const struct dt_iop_roi_t *const roi_out)</a>
<a name="ln2828">{</a>
<a name="ln2829">  if(self-&gt;bypass_blendif &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module)) return;</a>
<a name="ln2830"> </a>
<a name="ln2831">  const dt_develop_blend_params_t *const d = (const dt_develop_blend_params_t *const)piece-&gt;blendop_data;</a>
<a name="ln2832">  if(!d) return;</a>
<a name="ln2833"> </a>
<a name="ln2834">  const unsigned int mask_mode = d-&gt;mask_mode;</a>
<a name="ln2835">  // check if blend is disabled</a>
<a name="ln2836">  if(!(mask_mode &amp; DEVELOP_MASK_ENABLED)) return;</a>
<a name="ln2837"> </a>
<a name="ln2838">  const int ch = piece-&gt;colors;           // the number of channels in the buffer</a>
<a name="ln2839">  const int bch = (ch == 1) ? 1 : ch - 1; // the number of channels to blend (all but alpha)</a>
<a name="ln2840">  const int xoffs = roi_out-&gt;x - roi_in-&gt;x;</a>
<a name="ln2841">  const int yoffs = roi_out-&gt;y - roi_in-&gt;y;</a>
<a name="ln2842">  const int iwidth = roi_in-&gt;width;</a>
<a name="ln2843">  const int iheight = roi_in-&gt;height;</a>
<a name="ln2844">  const int owidth = roi_out-&gt;width;</a>
<a name="ln2845">  const int oheight = roi_out-&gt;height;</a>
<a name="ln2846">  const size_t buffsize = (size_t)owidth * oheight;</a>
<a name="ln2847">  const float iscale = roi_in-&gt;scale;</a>
<a name="ln2848">  const float oscale = roi_out-&gt;scale;</a>
<a name="ln2849">  const _Bool rois_equal = iwidth == owidth || iheight == oheight || xoffs == 0 || yoffs == 0;</a>
<a name="ln2850"> </a>
<a name="ln2851">  // In most cases of blending-enabled modules input and output of the module have</a>
<a name="ln2852">  // the exact same dimensions. Only in very special cases we allow a module's input</a>
<a name="ln2853">  // to exceed its output. This is namely the case for the spot removal module where</a>
<a name="ln2854">  // the source of a patch might lie outside the roi of the output image. Therefore:</a>
<a name="ln2855">  // We can only handle blending if roi_out and roi_in have the same scale and</a>
<a name="ln2856">  // if roi_out fits into the area given by roi_in. xoffs and yoffs describe the relative</a>
<a name="ln2857">  // offset of the input image to the output image.</a>
<a name="ln2858">  if(oscale != iscale || xoffs &lt; 0 || yoffs &lt; 0</a>
<a name="ln2859">     || ((xoffs &gt; 0 || yoffs &gt; 0) &amp;&amp; (owidth + xoffs &gt; iwidth || oheight + yoffs &gt; iheight)))</a>
<a name="ln2860">  {</a>
<a name="ln2861">    dt_control_log(_(&quot;skipped blending in module '%s': roi's do not match&quot;), self-&gt;op);</a>
<a name="ln2862">    return;</a>
<a name="ln2863">  }</a>
<a name="ln2864"> </a>
<a name="ln2865">  // only non-zero if mask_display was set by an _earlier_ module</a>
<a name="ln2866">  const dt_dev_pixelpipe_display_mask_t mask_display = piece-&gt;pipe-&gt;mask_display;</a>
<a name="ln2867"> </a>
<a name="ln2868">  // does user want us to display a specific channel?</a>
<a name="ln2869">  const dt_dev_pixelpipe_display_mask_t request_mask_display =</a>
<a name="ln2870">    (self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module) &amp;&amp; (piece-&gt;pipe == self-&gt;dev-&gt;pipe)</a>
<a name="ln2871">     &amp;&amp; (mask_mode &amp; DEVELOP_MASK_MASK_CONDITIONAL))</a>
<a name="ln2872">        ? self-&gt;request_mask_display</a>
<a name="ln2873">        : DT_DEV_PIXELPIPE_DISPLAY_NONE;</a>
<a name="ln2874"> </a>
<a name="ln2875">  // check if we only should blend lightness channel. will affect only Lab space</a>
<a name="ln2876">  const int blendflag = self-&gt;flags() &amp; IOP_FLAGS_BLEND_ONLY_LIGHTNESS;</a>
<a name="ln2877"> </a>
<a name="ln2878">  // get channel max values depending on colorspace</a>
<a name="ln2879">  const dt_iop_colorspace_type_t cst = dt_iop_module_colorspace(self);</a>
<a name="ln2880"> </a>
<a name="ln2881">  // check if mask should be suppressed temporarily (i.e. just set to global</a>
<a name="ln2882">  // opacity value)</a>
<a name="ln2883">  const _Bool suppress_mask = self-&gt;suppress_mask &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module)</a>
<a name="ln2884">                              &amp;&amp; (piece-&gt;pipe == self-&gt;dev-&gt;pipe) &amp;&amp; (mask_mode &amp; DEVELOP_MASK_MASK_CONDITIONAL);</a>
<a name="ln2885">  const _Bool mask_feather = d-&gt;feathering_radius &gt; 0.1f;</a>
<a name="ln2886">  const _Bool mask_blur = d-&gt;blur_radius &gt; 0.1f;</a>
<a name="ln2887">  const _Bool mask_tone_curve = fabsf(d-&gt;contrast) &gt;= 0.01f || fabsf(d-&gt;brightness) &gt;= 0.01f;</a>
<a name="ln2888"> </a>
<a name="ln2889">  // get the clipped opacity value  0 - 1</a>
<a name="ln2890">  const float opacity = fminf(fmaxf(0.0f, (d-&gt;opacity / 100.0f)), 1.0f);</a>
<a name="ln2891"> </a>
<a name="ln2892">  // allocate space for blend mask</a>
<a name="ln2893">  float *_mask = dt_alloc_align(64, buffsize * sizeof(float));</a>
<a name="ln2894">  if(!_mask)</a>
<a name="ln2895">  {</a>
<a name="ln2896">    dt_control_log(_(&quot;could not allocate buffer for blending&quot;));</a>
<a name="ln2897">    return;</a>
<a name="ln2898">  }</a>
<a name="ln2899">  float *const mask = _mask;</a>
<a name="ln2900"> </a>
<a name="ln2901">  if(mask_mode == DEVELOP_MASK_ENABLED || suppress_mask)</a>
<a name="ln2902">  {</a>
<a name="ln2903">    // blend uniformly (no drawn or parametric mask)</a>
<a name="ln2904"> </a>
<a name="ln2905">#ifdef _OPENMP</a>
<a name="ln2906">#pragma omp parallel for default(none)</a>
<a name="ln2907">#endif</a>
<a name="ln2908">    for(size_t i = 0; i &lt; buffsize; i++) mask[i] = opacity;</a>
<a name="ln2909">  }</a>
<a name="ln2910">  else if(mask_mode &amp; DEVELOP_MASK_RASTER)</a>
<a name="ln2911">  {</a>
<a name="ln2912">    /* use a raster mask from another module earlier in the pipe */</a>
<a name="ln2913">    gboolean free_mask = FALSE; // if no transformations were applied we get the cached original back</a>
<a name="ln2914">    float *raster_mask = dt_dev_get_raster_mask(piece-&gt;pipe, self-&gt;raster_mask.sink.source, self-&gt;raster_mask.sink.id,</a>
<a name="ln2915">                                                self, &amp;free_mask);</a>
<a name="ln2916"> </a>
<a name="ln2917">    if(raster_mask)</a>
<a name="ln2918">    {</a>
<a name="ln2919">      // invert if required</a>
<a name="ln2920">      if(d-&gt;raster_mask_invert)</a>
<a name="ln2921">#ifdef _OPENMP</a>
<a name="ln2922">  #pragma omp parallel for default(none) shared(raster_mask)</a>
<a name="ln2923">#endif</a>
<a name="ln2924">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = (1.0 - raster_mask[i]) * opacity;</a>
<a name="ln2925">      else</a>
<a name="ln2926">#ifdef _OPENMP</a>
<a name="ln2927">  #pragma omp parallel for default(none) shared(raster_mask)</a>
<a name="ln2928">#endif</a>
<a name="ln2929">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = raster_mask[i] * opacity;</a>
<a name="ln2930">      if(free_mask) dt_free_align(raster_mask);</a>
<a name="ln2931">    }</a>
<a name="ln2932">    else</a>
<a name="ln2933">    {</a>
<a name="ln2934">      // fallback for when the raster mask couldn't be applied</a>
<a name="ln2935">      const float value = d-&gt;raster_mask_invert ? 0.0 : 1.0;</a>
<a name="ln2936">#ifdef _OPENMP</a>
<a name="ln2937">  #pragma omp parallel for default(none)</a>
<a name="ln2938">#endif</a>
<a name="ln2939">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = value;</a>
<a name="ln2940">    }</a>
<a name="ln2941">  }</a>
<a name="ln2942">  else</a>
<a name="ln2943">  {</a>
<a name="ln2944">    // we blend with a drawn and/or parametric mask</a>
<a name="ln2945"> </a>
<a name="ln2946">    // get the drawn mask if there is one</a>
<a name="ln2947">    dt_masks_form_t *form = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, d-&gt;mask_id);</a>
<a name="ln2948"> </a>
<a name="ln2949">    if(form &amp;&amp; (!(self-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)) &amp;&amp; (d-&gt;mask_mode &amp; DEVELOP_MASK_MASK))</a>
<a name="ln2950">    {</a>
<a name="ln2951">      dt_masks_group_render_roi(self, piece, form, roi_out, mask);</a>
<a name="ln2952"> </a>
<a name="ln2953">      if(d-&gt;mask_combine &amp; DEVELOP_COMBINE_MASKS_POS)</a>
<a name="ln2954">      {</a>
<a name="ln2955">        // if we have a mask and this flag is set -&gt; invert the mask</a>
<a name="ln2956">#ifdef _OPENMP</a>
<a name="ln2957">#pragma omp parallel for default(none)</a>
<a name="ln2958">#endif</a>
<a name="ln2959">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = 1.0f - mask[i];</a>
<a name="ln2960">      }</a>
<a name="ln2961">    }</a>
<a name="ln2962">    else if((!(self-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)) &amp;&amp; (d-&gt;mask_mode &amp; DEVELOP_MASK_MASK))</a>
<a name="ln2963">    {</a>
<a name="ln2964">      // no form defined but drawn mask active</a>
<a name="ln2965">      // we fill the buffer with 1.0f or 0.0f depending on mask_combine</a>
<a name="ln2966">      const float fill = (d-&gt;mask_combine &amp; DEVELOP_COMBINE_MASKS_POS) ? 0.0f : 1.0f;</a>
<a name="ln2967">#ifdef _OPENMP</a>
<a name="ln2968">#pragma omp parallel for default(none)</a>
<a name="ln2969">#endif</a>
<a name="ln2970">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = fill;</a>
<a name="ln2971">    }</a>
<a name="ln2972">    else</a>
<a name="ln2973">    {</a>
<a name="ln2974">      // we fill the buffer with 1.0f or 0.0f depending on mask_combine</a>
<a name="ln2975">      const float fill = (d-&gt;mask_combine &amp; DEVELOP_COMBINE_INCL) ? 0.0f : 1.0f;</a>
<a name="ln2976">#ifdef _OPENMP</a>
<a name="ln2977">#pragma omp parallel for default(none)</a>
<a name="ln2978">#endif</a>
<a name="ln2979">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = fill;</a>
<a name="ln2980">    }</a>
<a name="ln2981"> </a>
<a name="ln2982">    // get parametric mask (if any) and apply global opacity</a>
<a name="ln2983">#ifdef _OPENMP</a>
<a name="ln2984">#pragma omp parallel for default(none)</a>
<a name="ln2985">#endif</a>
<a name="ln2986">    for(size_t y = 0; y &lt; oheight; y++)</a>
<a name="ln2987">    {</a>
<a name="ln2988">      size_t iindex = ((y + yoffs) * iwidth + xoffs) * ch;</a>
<a name="ln2989">      size_t oindex = y * owidth * ch;</a>
<a name="ln2990">      _blend_buffer_desc_t bd = { .cst = cst, .stride = (size_t)owidth * ch, .ch = ch, .bch = bch };</a>
<a name="ln2991">      float *in = (float *)ivoid + iindex;</a>
<a name="ln2992">      float *out = (float *)ovoid + oindex;</a>
<a name="ln2993">      float *m = mask + y * owidth;</a>
<a name="ln2994">      _blend_make_mask(&amp;bd, d-&gt;blendif, d-&gt;blendif_parameters, d-&gt;mask_mode, d-&gt;mask_combine, opacity, in, out, m);</a>
<a name="ln2995">    }</a>
<a name="ln2996"> </a>
<a name="ln2997">    if(mask_feather)</a>
<a name="ln2998">    {</a>
<a name="ln2999">      int w = (int)(2 * d-&gt;feathering_radius * roi_out-&gt;scale / piece-&gt;iscale + 0.5f);</a>
<a name="ln3000">      if(w &lt; 1) w = 1;</a>
<a name="ln3001">      float sqrt_eps = 1.f;</a>
<a name="ln3002">      float guide_weight = 1.f;</a>
<a name="ln3003">      switch(cst)</a>
<a name="ln3004">      {</a>
<a name="ln3005">        case iop_cs_rgb:</a>
<a name="ln3006">          guide_weight = 100.f;</a>
<a name="ln3007">          break;</a>
<a name="ln3008">        case iop_cs_Lab:</a>
<a name="ln3009">          guide_weight = 1.f;</a>
<a name="ln3010">          break;</a>
<a name="ln3011">        case iop_cs_RAW:</a>
<a name="ln3012">        default:</a>
<a name="ln3013">          assert(0);</a>
<a name="ln3014">      }</a>
<a name="ln3015">      float *mask_bak = dt_alloc_align(64, sizeof(*mask_bak) * buffsize);</a>
<a name="ln3016">      memcpy(mask_bak, mask, sizeof(*mask_bak) * buffsize);</a>
<a name="ln3017">      float *guide = d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN ? (float *)ivoid : (float *)ovoid;</a>
<a name="ln3018">      if(!rois_equal &amp;&amp; d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN)</a>
<a name="ln3019">      {</a>
<a name="ln3020">        float *const guide_tmp = dt_alloc_align(64, sizeof(*guide_tmp) * buffsize * ch);</a>
<a name="ln3021">#ifdef _OPENMP</a>
<a name="ln3022">#pragma omp parallel for default(none)</a>
<a name="ln3023">#endif</a>
<a name="ln3024">        for(size_t y = 0; y &lt; oheight; y++)</a>
<a name="ln3025">        {</a>
<a name="ln3026">          size_t iindex = ((size_t)(y + yoffs) * iwidth + xoffs) * ch;</a>
<a name="ln3027">          size_t oindex = (size_t)(y + yoffs) * owidth * ch;</a>
<a name="ln3028">          memcpy(guide_tmp + oindex, (float *)ivoid + iindex, sizeof(*guide_tmp) * owidth * ch);</a>
<a name="ln3029">        }</a>
<a name="ln3030">        guide = guide_tmp;</a>
<a name="ln3031">      }</a>
<a name="ln3032">      guided_filter(guide, mask_bak, mask, owidth, oheight, ch, w, sqrt_eps, guide_weight, 0.f, 1.f);</a>
<a name="ln3033">      if(!rois_equal &amp;&amp; d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN) dt_free_align(guide);</a>
<a name="ln3034">      dt_free_align(mask_bak);</a>
<a name="ln3035">    }</a>
<a name="ln3036">    if(mask_blur)</a>
<a name="ln3037">    {</a>
<a name="ln3038">      const float sigma = d-&gt;blur_radius * roi_out-&gt;scale / piece-&gt;iscale;</a>
<a name="ln3039">      const float mmax[] = { 1.0f };</a>
<a name="ln3040">      const float mmin[] = { 0.0f };</a>
<a name="ln3041"> </a>
<a name="ln3042">      dt_gaussian_t *g = dt_gaussian_init(owidth, oheight, 1, mmax, mmin, sigma, 0);</a>
<a name="ln3043">      if(g)</a>
<a name="ln3044">      {</a>
<a name="ln3045">        dt_gaussian_blur(g, mask, mask);</a>
<a name="ln3046">        dt_gaussian_free(g);</a>
<a name="ln3047">      }</a>
<a name="ln3048">    }</a>
<a name="ln3049"> </a>
<a name="ln3050">    if(mask_tone_curve &amp;&amp; opacity &gt; 1e-4f)</a>
<a name="ln3051">    {</a>
<a name="ln3052">      const float e = expf(3.f * d-&gt;contrast);</a>
<a name="ln3053">      const float brightness = d-&gt;brightness;</a>
<a name="ln3054">#ifdef _OPENMP</a>
<a name="ln3055">#pragma omp parallel for default(none)</a>
<a name="ln3056">#endif</a>
<a name="ln3057">      for(size_t k = 0; k &lt; buffsize; k++)</a>
<a name="ln3058">      {</a>
<a name="ln3059">        float x = mask[k] / opacity;</a>
<a name="ln3060">        x = 2.f * x - 1.f;</a>
<a name="ln3061">        if (1.f - brightness &lt;= 0.f)</a>
<a name="ln3062">          x = mask[k] &lt;= FLT_EPSILON ? -1.f : 1.f;</a>
<a name="ln3063">        else if (1.f + brightness &lt;= 0.f)</a>
<a name="ln3064">          x = mask[k] &gt;= 1.f - FLT_EPSILON ? 1.f : -1.f;</a>
<a name="ln3065">        else if (brightness &gt; 0.f)</a>
<a name="ln3066">        {</a>
<a name="ln3067">          x = (x + brightness) / (1.f - brightness);</a>
<a name="ln3068">          x = fminf(x, 1.f);</a>
<a name="ln3069">        }</a>
<a name="ln3070">        else</a>
<a name="ln3071">        {</a>
<a name="ln3072">          x = (x + brightness) / (1.f + brightness);</a>
<a name="ln3073">          x = fmaxf(x, -1.f);</a>
<a name="ln3074">        }</a>
<a name="ln3075">        mask[k] = ((x * e / (1.f + (e - 1.f) * fabsf(x))) / 2.f + 0.5f) * opacity;</a>
<a name="ln3076">      }</a>
<a name="ln3077">    }</a>
<a name="ln3078">  }</a>
<a name="ln3079"> </a>
<a name="ln3080">  // now apply blending with per-pixel opacity value as defined in mask</a>
<a name="ln3081">  // select the blend operator</a>
<a name="ln3082">  _blend_row_func *const blend = dt_develop_choose_blend_func(d-&gt;blend_mode);</a>
<a name="ln3083">#ifdef _OPENMP</a>
<a name="ln3084">#pragma omp parallel for default(none)</a>
<a name="ln3085">#endif</a>
<a name="ln3086">  for(size_t y = 0; y &lt; oheight; y++)</a>
<a name="ln3087">  {</a>
<a name="ln3088">    size_t iindex = ((y + yoffs) * iwidth + xoffs) * ch;</a>
<a name="ln3089">    size_t oindex = y * owidth * ch;</a>
<a name="ln3090">    _blend_buffer_desc_t bd = { .cst = cst, .stride = (size_t)owidth * ch, .ch = ch, .bch = bch };</a>
<a name="ln3091">    float *in = (float *)ivoid + iindex;</a>
<a name="ln3092">    float *out = (float *)ovoid + oindex;</a>
<a name="ln3093">    float *m = mask + y * owidth;</a>
<a name="ln3094"> </a>
<a name="ln3095">    if(request_mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_ANY)</a>
<a name="ln3096">      display_channel(&amp;bd, in, out, m, request_mask_display);</a>
<a name="ln3097">    else</a>
<a name="ln3098">      blend(&amp;bd, in, out, m, blendflag);</a>
<a name="ln3099"> </a>
<a name="ln3100">    if((mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) &amp;&amp; cst != iop_cs_RAW)</a>
<a name="ln3101">      for(size_t j = 0; j &lt; bd.stride; j += 4) out[j + 3] = in[j + 3];</a>
<a name="ln3102">  }</a>
<a name="ln3103"> </a>
<a name="ln3104">  // register if _this_ module should expose mask or display channel</a>
<a name="ln3105">  if(request_mask_display &amp; (DT_DEV_PIXELPIPE_DISPLAY_MASK | DT_DEV_PIXELPIPE_DISPLAY_CHANNEL))</a>
<a name="ln3106">  {</a>
<a name="ln3107">    piece-&gt;pipe-&gt;mask_display = request_mask_display;</a>
<a name="ln3108">  }</a>
<a name="ln3109"> </a>
<a name="ln3110">  // check if we should store the mask for export or use in subsequent modules</a>
<a name="ln3111">  // TODO: should we skip raster masks?</a>
<a name="ln3112">  if(piece-&gt;pipe-&gt;store_all_raster_masks || dt_iop_is_raster_mask_used(self, 0))</a>
<a name="ln3113">  {</a>
<a name="ln3114">    g_hash_table_replace(piece-&gt;raster_masks, GINT_TO_POINTER(0), _mask);</a>
<a name="ln3115">  }</a>
<a name="ln3116">  else</a>
<a name="ln3117">  {</a>
<a name="ln3118">    g_hash_table_remove(piece-&gt;raster_masks, GINT_TO_POINTER(0));</a>
<a name="ln3119">    dt_free_align(_mask);</a>
<a name="ln3120">  }</a>
<a name="ln3121">}</a>
<a name="ln3122"> </a>
<a name="ln3123">#ifdef HAVE_OPENCL</a>
<a name="ln3124">int dt_develop_blend_process_cl(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln3125">                                cl_mem dev_in, cl_mem dev_out, const struct dt_iop_roi_t *roi_in,</a>
<a name="ln3126">                                const struct dt_iop_roi_t *roi_out)</a>
<a name="ln3127">{</a>
<a name="ln3128">  if(self-&gt;bypass_blendif &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module)) return TRUE;</a>
<a name="ln3129"> </a>
<a name="ln3130">  dt_develop_blend_params_t *const d = (dt_develop_blend_params_t *const)piece-&gt;blendop_data;</a>
<a name="ln3131">  if(!d) return TRUE;</a>
<a name="ln3132"> </a>
<a name="ln3133">  const unsigned int mask_mode = d-&gt;mask_mode;</a>
<a name="ln3134">  // check if blend is disabled: just return, output is already in dev_out</a>
<a name="ln3135">  if(!(mask_mode &amp; DEVELOP_MASK_ENABLED)) return TRUE;</a>
<a name="ln3136"> </a>
<a name="ln3137">  const int ch = piece-&gt;colors; // the number of channels in the buffer</a>
<a name="ln3138">  const int xoffs = roi_out-&gt;x - roi_in-&gt;x;</a>
<a name="ln3139">  const int yoffs = roi_out-&gt;y - roi_in-&gt;y;</a>
<a name="ln3140">  const int iwidth = roi_in-&gt;width;</a>
<a name="ln3141">  const int iheight = roi_in-&gt;height;</a>
<a name="ln3142">  const int owidth = roi_out-&gt;width;</a>
<a name="ln3143">  const int oheight = roi_out-&gt;height;</a>
<a name="ln3144">  const size_t buffsize = (size_t)owidth * oheight;</a>
<a name="ln3145">  const float iscale = roi_in-&gt;scale;</a>
<a name="ln3146">  const float oscale = roi_out-&gt;scale;</a>
<a name="ln3147">  const _Bool rois_equal = iwidth == owidth || iheight == oheight || xoffs == 0 || yoffs == 0;</a>
<a name="ln3148"> </a>
<a name="ln3149">  // In most cases of blending-enabled modules input and output of the module have</a>
<a name="ln3150">  // the exact same dimensions. Only in very special cases we allow a module's input</a>
<a name="ln3151">  // to exceed its output. This is namely the case for the spot removal module where</a>
<a name="ln3152">  // the source of a patch might lie outside the roi of the output image. Therefore:</a>
<a name="ln3153">  // We can only handle blending if roi_out and roi_in have the same scale and</a>
<a name="ln3154">  // if roi_out fits into the area given by roi_in. xoffs and yoffs describe the relative</a>
<a name="ln3155">  // offset of the input image to the output image. */</a>
<a name="ln3156">  if(oscale != iscale || xoffs &lt; 0 || yoffs &lt; 0</a>
<a name="ln3157">     || ((xoffs &gt; 0 || yoffs &gt; 0) &amp;&amp; (owidth + xoffs &gt; iwidth || oheight + yoffs &gt; iheight)))</a>
<a name="ln3158">  {</a>
<a name="ln3159">    dt_control_log(_(&quot;skipped blending in module '%s': roi's do not match&quot;), self-&gt;op);</a>
<a name="ln3160">    return TRUE;</a>
<a name="ln3161">  }</a>
<a name="ln3162"> </a>
<a name="ln3163">  // only non-zero if mask_display was set by an _earlier_ module</a>
<a name="ln3164">  const dt_dev_pixelpipe_display_mask_t mask_display = piece-&gt;pipe-&gt;mask_display;</a>
<a name="ln3165"> </a>
<a name="ln3166">  // does user want us to display a specific channel?</a>
<a name="ln3167">  const dt_dev_pixelpipe_display_mask_t request_mask_display</a>
<a name="ln3168">      = (self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module) &amp;&amp; (piece-&gt;pipe == self-&gt;dev-&gt;pipe)</a>
<a name="ln3169">         &amp;&amp; (mask_mode &amp; DEVELOP_MASK_MASK_CONDITIONAL))</a>
<a name="ln3170">            ? self-&gt;request_mask_display</a>
<a name="ln3171">            : DT_DEV_PIXELPIPE_DISPLAY_NONE;</a>
<a name="ln3172"> </a>
<a name="ln3173">  // check if we only should blend lightness channel. will affect only Lab space</a>
<a name="ln3174">  const int blendflag = self-&gt;flags() &amp; IOP_FLAGS_BLEND_ONLY_LIGHTNESS;</a>
<a name="ln3175"> </a>
<a name="ln3176">  // get channel max values depending on colorspace</a>
<a name="ln3177">  const dt_iop_colorspace_type_t cst = dt_iop_module_colorspace(self);</a>
<a name="ln3178"> </a>
<a name="ln3179">  // check if mask should be suppressed temporarily (i.e. just set to global</a>
<a name="ln3180">  // opacity value)</a>
<a name="ln3181">  const _Bool suppress_mask = self-&gt;suppress_mask &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module)</a>
<a name="ln3182">                              &amp;&amp; (piece-&gt;pipe == self-&gt;dev-&gt;pipe) &amp;&amp; (mask_mode &amp; DEVELOP_MASK_MASK_CONDITIONAL);</a>
<a name="ln3183">  const _Bool mask_feather = d-&gt;feathering_radius &gt; 0.1f;</a>
<a name="ln3184">  const _Bool mask_blur = d-&gt;blur_radius &gt; 0.1f;</a>
<a name="ln3185">  const _Bool mask_tone_curve = fabsf(d-&gt;contrast) &gt;= 0.01f || fabsf(d-&gt;brightness) &gt;= 0.01f;</a>
<a name="ln3186"> </a>
<a name="ln3187">  // get the clipped opacity value  0 - 1</a>
<a name="ln3188">  const float opacity = fminf(fmaxf(0.0f, (d-&gt;opacity / 100.0f)), 1.0f);</a>
<a name="ln3189"> </a>
<a name="ln3190">  // allocate space for blend mask</a>
<a name="ln3191">  float *_mask = dt_alloc_align(64, buffsize * sizeof(float));</a>
<a name="ln3192">  if(!_mask)</a>
<a name="ln3193">  {</a>
<a name="ln3194">    dt_control_log(_(&quot;could not allocate buffer for blending&quot;));</a>
<a name="ln3195">    return FALSE;</a>
<a name="ln3196">  }</a>
<a name="ln3197">  float *const mask = _mask;</a>
<a name="ln3198"> </a>
<a name="ln3199">  // setup some kernels</a>
<a name="ln3200">  int kernel_mask;</a>
<a name="ln3201">  int kernel;</a>
<a name="ln3202">  switch(cst)</a>
<a name="ln3203">  {</a>
<a name="ln3204">    case iop_cs_RAW:</a>
<a name="ln3205">      kernel = darktable.opencl-&gt;blendop-&gt;kernel_blendop_RAW;</a>
<a name="ln3206">      kernel_mask = darktable.opencl-&gt;blendop-&gt;kernel_blendop_mask_RAW;</a>
<a name="ln3207">      break;</a>
<a name="ln3208"> </a>
<a name="ln3209">    case iop_cs_rgb:</a>
<a name="ln3210">      kernel = darktable.opencl-&gt;blendop-&gt;kernel_blendop_rgb;</a>
<a name="ln3211">      kernel_mask = darktable.opencl-&gt;blendop-&gt;kernel_blendop_mask_rgb;</a>
<a name="ln3212">      break;</a>
<a name="ln3213"> </a>
<a name="ln3214">    case iop_cs_Lab:</a>
<a name="ln3215">    default:</a>
<a name="ln3216">      kernel = darktable.opencl-&gt;blendop-&gt;kernel_blendop_Lab;</a>
<a name="ln3217">      kernel_mask = darktable.opencl-&gt;blendop-&gt;kernel_blendop_mask_Lab;</a>
<a name="ln3218">      break;</a>
<a name="ln3219">  }</a>
<a name="ln3220">  int kernel_mask_tone_curve = darktable.opencl-&gt;blendop-&gt;kernel_blendop_mask_tone_curve;</a>
<a name="ln3221">  int kernel_set_mask = darktable.opencl-&gt;blendop-&gt;kernel_blendop_set_mask;</a>
<a name="ln3222">  int kernel_display_channel = darktable.opencl-&gt;blendop-&gt;kernel_blendop_display_channel;</a>
<a name="ln3223"> </a>
<a name="ln3224">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3225">  const int offs[2] = { xoffs, yoffs };</a>
<a name="ln3226">  const size_t sizes[] = { ROUNDUPWD(owidth), ROUNDUPHT(oheight), 1 };</a>
<a name="ln3227"> </a>
<a name="ln3228">  cl_int err = -999;</a>
<a name="ln3229">  cl_mem dev_m = NULL;</a>
<a name="ln3230">  cl_mem dev_mask_1 = NULL;</a>
<a name="ln3231">  cl_mem dev_mask_2 = NULL;</a>
<a name="ln3232">  cl_mem dev_tmp = NULL;</a>
<a name="ln3233">  cl_mem dev_guide = NULL;</a>
<a name="ln3234">  size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3235">  size_t region[] = { owidth, oheight, 1 };</a>
<a name="ln3236"> </a>
<a name="ln3237">  // copy blend parameters to constant device memory</a>
<a name="ln3238">  dev_m = dt_opencl_copy_host_to_device_constant(devid, sizeof(float) * 4 * DEVELOP_BLENDIF_SIZE,</a>
<a name="ln3239">                                                 d-&gt;blendif_parameters);</a>
<a name="ln3240">  if(dev_m == NULL) goto error;</a>
<a name="ln3241"> </a>
<a name="ln3242">  dev_mask_1 = dt_opencl_alloc_device(devid, owidth, oheight, sizeof(float));</a>
<a name="ln3243">  if(dev_mask_1 == NULL) goto error;</a>
<a name="ln3244"> </a>
<a name="ln3245">  if(mask_mode == DEVELOP_MASK_ENABLED || suppress_mask)</a>
<a name="ln3246">  {</a>
<a name="ln3247">    // blend uniformly (no drawn or parametric mask)</a>
<a name="ln3248"> </a>
<a name="ln3249">    // set dev_mask with global opacity value</a>
<a name="ln3250">    dt_opencl_set_kernel_arg(devid, kernel_set_mask, 0, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3251">    dt_opencl_set_kernel_arg(devid, kernel_set_mask, 1, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3252">    dt_opencl_set_kernel_arg(devid, kernel_set_mask, 2, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3253">    dt_opencl_set_kernel_arg(devid, kernel_set_mask, 3, sizeof(float), (void *)&amp;opacity);</a>
<a name="ln3254">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_set_mask, sizes);</a>
<a name="ln3255">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3256">  }</a>
<a name="ln3257">  else if(mask_mode &amp; DEVELOP_MASK_RASTER)</a>
<a name="ln3258">  {</a>
<a name="ln3259">    /* use a raster mask from another module earlier in the pipe */</a>
<a name="ln3260">    gboolean free_mask = FALSE; // if no transformations were applied we get the cached original back</a>
<a name="ln3261">    float *raster_mask = dt_dev_get_raster_mask(piece-&gt;pipe, self-&gt;raster_mask.sink.source, self-&gt;raster_mask.sink.id,</a>
<a name="ln3262">                                                self, &amp;free_mask);</a>
<a name="ln3263"> </a>
<a name="ln3264">    if(raster_mask)</a>
<a name="ln3265">    {</a>
<a name="ln3266">      // invert if required</a>
<a name="ln3267">      if(d-&gt;raster_mask_invert)</a>
<a name="ln3268">#ifdef _OPENMP</a>
<a name="ln3269">  #pragma omp parallel for default(none) shared(raster_mask)</a>
<a name="ln3270">#endif</a>
<a name="ln3271">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = (1.0 - raster_mask[i]) * opacity;</a>
<a name="ln3272">      else</a>
<a name="ln3273">#ifdef _OPENMP</a>
<a name="ln3274">  #pragma omp parallel for default(none) shared(raster_mask)</a>
<a name="ln3275">#endif</a>
<a name="ln3276">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = raster_mask[i] * opacity;</a>
<a name="ln3277">      if(free_mask) dt_free_align(raster_mask);</a>
<a name="ln3278">    }</a>
<a name="ln3279">    else</a>
<a name="ln3280">    {</a>
<a name="ln3281">      // fallback for when the raster mask couldn't be applied</a>
<a name="ln3282">      const float value = d-&gt;raster_mask_invert ? 0.0 : 1.0;</a>
<a name="ln3283">#ifdef _OPENMP</a>
<a name="ln3284">  #pragma omp parallel for default(none)</a>
<a name="ln3285">#endif</a>
<a name="ln3286">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = value;</a>
<a name="ln3287">    }</a>
<a name="ln3288"> </a>
<a name="ln3289">    err = dt_opencl_write_host_to_device(devid, mask, dev_mask_1, owidth, oheight, sizeof(float));</a>
<a name="ln3290">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3291">  }</a>
<a name="ln3292">  else</a>
<a name="ln3293">  {</a>
<a name="ln3294">    // we blend with a drawn and/or parametric mask</a>
<a name="ln3295"> </a>
<a name="ln3296">    // get the drawn mask if there is one</a>
<a name="ln3297">    dt_masks_form_t *form = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, d-&gt;mask_id);</a>
<a name="ln3298"> </a>
<a name="ln3299">    if(form &amp;&amp; (!(self-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)) &amp;&amp; (d-&gt;mask_mode &amp; DEVELOP_MASK_MASK))</a>
<a name="ln3300">    {</a>
<a name="ln3301">      dt_masks_group_render_roi(self, piece, form, roi_out, mask);</a>
<a name="ln3302"> </a>
<a name="ln3303">      if(d-&gt;mask_combine &amp; DEVELOP_COMBINE_MASKS_POS)</a>
<a name="ln3304">      {</a>
<a name="ln3305">        // if we have a mask and this flag is set -&gt; invert the mask</a>
<a name="ln3306">#ifdef _OPENMP</a>
<a name="ln3307">  #pragma omp parallel for default(none)</a>
<a name="ln3308">#endif</a>
<a name="ln3309">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = 1.0f - mask[i];</a>
<a name="ln3310">      }</a>
<a name="ln3311">    }</a>
<a name="ln3312">    else if((!(self-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)) &amp;&amp; (d-&gt;mask_mode &amp; DEVELOP_MASK_MASK))</a>
<a name="ln3313">    {</a>
<a name="ln3314">      // no form defined but drawn mask active</a>
<a name="ln3315">      // we fill the buffer with 1.0f or 0.0f depending on mask_combine</a>
<a name="ln3316">      const float fill = (d-&gt;mask_combine &amp; DEVELOP_COMBINE_MASKS_POS) ? 0.0f : 1.0f;</a>
<a name="ln3317">#ifdef _OPENMP</a>
<a name="ln3318">  #pragma omp parallel for default(none)</a>
<a name="ln3319">#endif</a>
<a name="ln3320">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = fill;</a>
<a name="ln3321">    }</a>
<a name="ln3322">    else</a>
<a name="ln3323">    {</a>
<a name="ln3324">      // we fill the buffer with 1.0f or 0.0f depending on mask_combine</a>
<a name="ln3325">      const float fill = (d-&gt;mask_combine &amp; DEVELOP_COMBINE_INCL) ? 0.0f : 1.0f;</a>
<a name="ln3326">#ifdef _OPENMP</a>
<a name="ln3327">  #pragma omp parallel for default(none)</a>
<a name="ln3328">#endif</a>
<a name="ln3329">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = fill;</a>
<a name="ln3330">    }</a>
<a name="ln3331"> </a>
<a name="ln3332">    // write mask from host to device</a>
<a name="ln3333">    dev_mask_2 = dt_opencl_alloc_device(devid, owidth, oheight, sizeof(float));</a>
<a name="ln3334">    if(dev_mask_2 == NULL) goto error;</a>
<a name="ln3335">    err = dt_opencl_write_host_to_device(devid, mask, dev_mask_1, owidth, oheight, sizeof(float));</a>
<a name="ln3336">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3337"> </a>
<a name="ln3338">    // The following call to clFinish() works around a bug in some OpenCL</a>
<a name="ln3339">    // drivers (namely AMD).</a>
<a name="ln3340">    // Without this synchronization point, reads to dev_in would often not</a>
<a name="ln3341">    // return the correct value.</a>
<a name="ln3342">    // This depends on the module after which blending is called. One of the</a>
<a name="ln3343">    // affected ones is sharpen.</a>
<a name="ln3344">    dt_opencl_finish(devid);</a>
<a name="ln3345"> </a>
<a name="ln3346">    // get parametric mask (if any) and apply global opacity</a>
<a name="ln3347">    const unsigned blendif = d-&gt;blendif;</a>
<a name="ln3348">    const unsigned int mask_combine = d-&gt;mask_combine;</a>
<a name="ln3349">    dt_opencl_set_kernel_arg(devid, kernel_mask, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3350">    dt_opencl_set_kernel_arg(devid, kernel_mask, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3351">    dt_opencl_set_kernel_arg(devid, kernel_mask, 2, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3352">    dt_opencl_set_kernel_arg(devid, kernel_mask, 3, sizeof(cl_mem), (void *)&amp;dev_mask_2);</a>
<a name="ln3353">    dt_opencl_set_kernel_arg(devid, kernel_mask, 4, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3354">    dt_opencl_set_kernel_arg(devid, kernel_mask, 5, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3355">    dt_opencl_set_kernel_arg(devid, kernel_mask, 6, sizeof(float), (void *)&amp;opacity);</a>
<a name="ln3356">    dt_opencl_set_kernel_arg(devid, kernel_mask, 7, sizeof(unsigned), (void *)&amp;blendif);</a>
<a name="ln3357">    dt_opencl_set_kernel_arg(devid, kernel_mask, 8, sizeof(cl_mem), (void *)&amp;dev_m);</a>
<a name="ln3358">    dt_opencl_set_kernel_arg(devid, kernel_mask, 9, sizeof(unsigned), (void *)&amp;mask_mode);</a>
<a name="ln3359">    dt_opencl_set_kernel_arg(devid, kernel_mask, 10, sizeof(unsigned), (void *)&amp;mask_combine);</a>
<a name="ln3360">    dt_opencl_set_kernel_arg(devid, kernel_mask, 11, 2 * sizeof(int), (void *)&amp;offs);</a>
<a name="ln3361">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_mask, sizes);</a>
<a name="ln3362">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3363"> </a>
<a name="ln3364">    if(mask_feather)</a>
<a name="ln3365">    {</a>
<a name="ln3366">      int w = (int)(2 * d-&gt;feathering_radius * roi_out-&gt;scale / piece-&gt;iscale + 0.5f);</a>
<a name="ln3367">      if (w &lt; 1)</a>
<a name="ln3368">        w = 1;</a>
<a name="ln3369">      float sqrt_eps = 1.f;</a>
<a name="ln3370">      float guide_weight = 1.f;</a>
<a name="ln3371">      switch(cst)</a>
<a name="ln3372">      {</a>
<a name="ln3373">      case iop_cs_rgb:</a>
<a name="ln3374">        guide_weight = 100.f;</a>
<a name="ln3375">        break;</a>
<a name="ln3376">      case iop_cs_Lab:</a>
<a name="ln3377">        guide_weight = 1.f;</a>
<a name="ln3378">        break;</a>
<a name="ln3379">      case iop_cs_RAW:</a>
<a name="ln3380">      default:</a>
<a name="ln3381">        assert(0);</a>
<a name="ln3382">      }</a>
<a name="ln3383">      cl_mem guide = d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN ? dev_in : dev_out;</a>
<a name="ln3384">      if(!rois_equal &amp;&amp; d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN)</a>
<a name="ln3385">      {</a>
<a name="ln3386">        dev_guide = dt_opencl_alloc_device(devid, owidth, oheight, 4 * sizeof(float));</a>
<a name="ln3387">        if(dev_guide == NULL) goto error;</a>
<a name="ln3388">        guide = dev_guide;</a>
<a name="ln3389">        size_t origin_1[] = { xoffs, yoffs, 0 };</a>
<a name="ln3390">        size_t origin_2[] = { 0, 0, 0 };</a>
<a name="ln3391">        err = dt_opencl_enqueue_copy_image(devid, dev_in, guide, origin_2, origin_1, region);</a>
<a name="ln3392">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3393">      }</a>
<a name="ln3394">      guided_filter_cl(devid, guide, dev_mask_2, dev_mask_1, owidth, oheight, ch, w, sqrt_eps, guide_weight, 0.f,</a>
<a name="ln3395">                       1.f);</a>
<a name="ln3396">      if(dev_guide)</a>
<a name="ln3397">      {</a>
<a name="ln3398">        dt_opencl_release_mem_object(dev_guide);</a>
<a name="ln3399">        dev_guide = NULL;</a>
<a name="ln3400">      }</a>
<a name="ln3401">    }</a>
<a name="ln3402">    else</a>
<a name="ln3403">    {</a>
<a name="ln3404">      cl_mem tmp = dev_mask_1;</a>
<a name="ln3405">      dev_mask_1 = dev_mask_2;</a>
<a name="ln3406">      dev_mask_2 = tmp;</a>
<a name="ln3407">    }</a>
<a name="ln3408"> </a>
<a name="ln3409">    if(mask_blur)</a>
<a name="ln3410">    {</a>
<a name="ln3411">      const float sigma = d-&gt;blur_radius * roi_out-&gt;scale / piece-&gt;iscale;</a>
<a name="ln3412">      const float mmax[] = { 1.0f };</a>
<a name="ln3413">      const float mmin[] = { 0.0f };</a>
<a name="ln3414"> </a>
<a name="ln3415">      dt_gaussian_cl_t *g = dt_gaussian_init_cl(devid, owidth, oheight, 1, mmax, mmin, sigma, 0);</a>
<a name="ln3416">      if(g)</a>
<a name="ln3417">      {</a>
<a name="ln3418">        dt_gaussian_blur_cl(g, dev_mask_1, dev_mask_2);</a>
<a name="ln3419">        dt_gaussian_free_cl(g);</a>
<a name="ln3420">      }</a>
<a name="ln3421">    }</a>
<a name="ln3422">    else</a>
<a name="ln3423">    {</a>
<a name="ln3424">      cl_mem tmp = dev_mask_1;</a>
<a name="ln3425">      dev_mask_1 = dev_mask_2;</a>
<a name="ln3426">      dev_mask_2 = tmp;</a>
<a name="ln3427">    }</a>
<a name="ln3428"> </a>
<a name="ln3429">    if(mask_tone_curve)</a>
<a name="ln3430">    {</a>
<a name="ln3431">      const float e = expf(3.f * d-&gt;contrast);</a>
<a name="ln3432">      const float brightness = d-&gt;brightness;</a>
<a name="ln3433">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 0, sizeof(cl_mem), (void *)&amp;dev_mask_2);</a>
<a name="ln3434">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 1, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3435">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 2, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3436">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 3, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3437">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 4, sizeof(float), (void *)&amp;e);</a>
<a name="ln3438">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 5, sizeof(float), (void *)&amp;brightness);</a>
<a name="ln3439">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 6, sizeof(float), (void *)&amp;opacity);</a>
<a name="ln3440">      err = dt_opencl_enqueue_kernel_2d(devid, kernel_mask_tone_curve, sizes);</a>
<a name="ln3441">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3442">    }</a>
<a name="ln3443">    else</a>
<a name="ln3444">    {</a>
<a name="ln3445">      cl_mem tmp = dev_mask_1;</a>
<a name="ln3446">      dev_mask_1 = dev_mask_2;</a>
<a name="ln3447">      dev_mask_2 = tmp;</a>
<a name="ln3448">    }</a>
<a name="ln3449"> </a>
<a name="ln3450">    // get rid of dev_mask_2</a>
<a name="ln3451">    dt_opencl_release_mem_object(dev_mask_2);</a>
<a name="ln3452">    dev_mask_2 = NULL;</a>
<a name="ln3453">  }</a>
<a name="ln3454"> </a>
<a name="ln3455">  // get temporary buffer for output image to overcome readonly/writeonly limitation</a>
<a name="ln3456">  dev_tmp = dt_opencl_alloc_device(devid, owidth, oheight, 4 * sizeof(float));</a>
<a name="ln3457">  if(dev_tmp == NULL) goto error;</a>
<a name="ln3458"> </a>
<a name="ln3459">  err = dt_opencl_enqueue_copy_image(devid, dev_out, dev_tmp, origin, origin, region);</a>
<a name="ln3460">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln3461"> </a>
<a name="ln3462">  if(request_mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_ANY)</a>
<a name="ln3463">  {</a>
<a name="ln3464">    // let us display a specific channel</a>
<a name="ln3465">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3466">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3467">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 2, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3468">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 3, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3469">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 4, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3470">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 5, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3471">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 6, 2 * sizeof(int), (void *)&amp;offs);</a>
<a name="ln3472">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 7, sizeof(int), (void *)&amp;request_mask_display);</a>
<a name="ln3473">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_display_channel, sizes);</a>
<a name="ln3474">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3475">  }</a>
<a name="ln3476">  else</a>
<a name="ln3477">  {</a>
<a name="ln3478">    // apply blending with per-pixel opacity value as defined in dev_mask_1</a>
<a name="ln3479">    const unsigned int blend_mode = d-&gt;blend_mode;</a>
<a name="ln3480">    dt_opencl_set_kernel_arg(devid, kernel, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3481">    dt_opencl_set_kernel_arg(devid, kernel, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3482">    dt_opencl_set_kernel_arg(devid, kernel, 2, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3483">    dt_opencl_set_kernel_arg(devid, kernel, 3, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3484">    dt_opencl_set_kernel_arg(devid, kernel, 4, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3485">    dt_opencl_set_kernel_arg(devid, kernel, 5, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3486">    dt_opencl_set_kernel_arg(devid, kernel, 6, sizeof(unsigned), (void *)&amp;blend_mode);</a>
<a name="ln3487">    dt_opencl_set_kernel_arg(devid, kernel, 7, sizeof(int), (void *)&amp;blendflag);</a>
<a name="ln3488">    dt_opencl_set_kernel_arg(devid, kernel, 8, 2 * sizeof(int), (void *)&amp;offs);</a>
<a name="ln3489">    dt_opencl_set_kernel_arg(devid, kernel, 9, sizeof(int), (void *)&amp;mask_display);</a>
<a name="ln3490">    err = dt_opencl_enqueue_kernel_2d(devid, kernel, sizes);</a>
<a name="ln3491">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3492">  }</a>
<a name="ln3493"> </a>
<a name="ln3494">  // register if _this_ module should expose mask or display channel</a>
<a name="ln3495">  if(request_mask_display &amp; (DT_DEV_PIXELPIPE_DISPLAY_MASK | DT_DEV_PIXELPIPE_DISPLAY_CHANNEL))</a>
<a name="ln3496">  {</a>
<a name="ln3497">    piece-&gt;pipe-&gt;mask_display = request_mask_display;</a>
<a name="ln3498">  }</a>
<a name="ln3499"> </a>
<a name="ln3500"> </a>
<a name="ln3501">  // check if we should store the mask for export or use in subsequent modules</a>
<a name="ln3502">  // TODO: should we skip raster masks?</a>
<a name="ln3503">  if(piece-&gt;pipe-&gt;store_all_raster_masks || dt_iop_is_raster_mask_used(self, 0))</a>
<a name="ln3504">  {</a>
<a name="ln3505">    //  get back final mask from the device to store it for later use</a>
<a name="ln3506">    if(!(mask_mode &amp; DEVELOP_MASK_RASTER))</a>
<a name="ln3507">    {</a>
<a name="ln3508">      err = dt_opencl_copy_device_to_host(devid, mask, dev_mask_1, owidth, oheight, sizeof(float));</a>
<a name="ln3509">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3510">    }</a>
<a name="ln3511">    g_hash_table_replace(piece-&gt;raster_masks, GINT_TO_POINTER(0), _mask);</a>
<a name="ln3512">    }</a>
<a name="ln3513">  else</a>
<a name="ln3514">  {</a>
<a name="ln3515">    g_hash_table_remove(piece-&gt;raster_masks, GINT_TO_POINTER(0));</a>
<a name="ln3516">    dt_free_align(_mask);</a>
<a name="ln3517">  }</a>
<a name="ln3518"> </a>
<a name="ln3519">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln3520">  dt_opencl_release_mem_object(dev_mask_1);</a>
<a name="ln3521">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3522">  return TRUE;</a>
<a name="ln3523"> </a>
<a name="ln3524">error:</a>
<a name="ln3525">  dt_free_align(_mask);</a>
<a name="ln3526">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln3527">  dt_opencl_release_mem_object(dev_mask_1);</a>
<a name="ln3528">  dt_opencl_release_mem_object(dev_mask_2);</a>
<a name="ln3529">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3530">  dt_opencl_release_mem_object(dev_guide);</a>
<a name="ln3531">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_blendop] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3532">  return FALSE;</a>
<a name="ln3533">}</a>
<a name="ln3534">#endif</a>
<a name="ln3535"> </a>
<a name="ln3536">/** global init of blendops */</a>
<a name="ln3537">dt_blendop_cl_global_t *dt_develop_blend_init_cl_global(void)</a>
<a name="ln3538">{</a>
<a name="ln3539">#ifdef HAVE_OPENCL</a>
<a name="ln3540">  dt_blendop_cl_global_t *b = (dt_blendop_cl_global_t *)calloc(1, sizeof(dt_blendop_cl_global_t));</a>
<a name="ln3541"> </a>
<a name="ln3542">  const int program = 3; // blendop.cl, from programs.conf</a>
<a name="ln3543">  b-&gt;kernel_blendop_mask_Lab = dt_opencl_create_kernel(program, &quot;blendop_mask_Lab&quot;);</a>
<a name="ln3544">  b-&gt;kernel_blendop_mask_RAW = dt_opencl_create_kernel(program, &quot;blendop_mask_RAW&quot;);</a>
<a name="ln3545">  b-&gt;kernel_blendop_mask_rgb = dt_opencl_create_kernel(program, &quot;blendop_mask_rgb&quot;);</a>
<a name="ln3546">  b-&gt;kernel_blendop_Lab = dt_opencl_create_kernel(program, &quot;blendop_Lab&quot;);</a>
<a name="ln3547">  b-&gt;kernel_blendop_RAW = dt_opencl_create_kernel(program, &quot;blendop_RAW&quot;);</a>
<a name="ln3548">  b-&gt;kernel_blendop_rgb = dt_opencl_create_kernel(program, &quot;blendop_rgb&quot;);</a>
<a name="ln3549">  b-&gt;kernel_blendop_mask_tone_curve = dt_opencl_create_kernel(program, &quot;blendop_mask_tone_curve&quot;);</a>
<a name="ln3550">  b-&gt;kernel_blendop_set_mask = dt_opencl_create_kernel(program, &quot;blendop_set_mask&quot;);</a>
<a name="ln3551">  b-&gt;kernel_blendop_display_channel = dt_opencl_create_kernel(program, &quot;blendop_display_channel&quot;);</a>
<a name="ln3552">  return b;</a>
<a name="ln3553">#else</a>
<a name="ln3554">  return NULL;</a>
<a name="ln3555">#endif</a>
<a name="ln3556">}</a>
<a name="ln3557"> </a>
<a name="ln3558">/** global cleanup of blendops */</a>
<a name="ln3559">void dt_develop_blend_free_cl_global(dt_blendop_cl_global_t *b)</a>
<a name="ln3560">{</a>
<a name="ln3561">#ifdef HAVE_OPENCL</a>
<a name="ln3562">  if(!b) return;</a>
<a name="ln3563"> </a>
<a name="ln3564">  dt_opencl_free_kernel(b-&gt;kernel_blendop_mask_Lab);</a>
<a name="ln3565">  dt_opencl_free_kernel(b-&gt;kernel_blendop_mask_RAW);</a>
<a name="ln3566">  dt_opencl_free_kernel(b-&gt;kernel_blendop_mask_rgb);</a>
<a name="ln3567">  dt_opencl_free_kernel(b-&gt;kernel_blendop_Lab);</a>
<a name="ln3568">  dt_opencl_free_kernel(b-&gt;kernel_blendop_RAW);</a>
<a name="ln3569">  dt_opencl_free_kernel(b-&gt;kernel_blendop_rgb);</a>
<a name="ln3570">  dt_opencl_free_kernel(b-&gt;kernel_blendop_mask_tone_curve);</a>
<a name="ln3571">  dt_opencl_free_kernel(b-&gt;kernel_blendop_set_mask);</a>
<a name="ln3572">  dt_opencl_free_kernel(b-&gt;kernel_blendop_display_channel);</a>
<a name="ln3573"> </a>
<a name="ln3574">  free(b);</a>
<a name="ln3575">#endif</a>
<a name="ln3576">}</a>
<a name="ln3577"> </a>
<a name="ln3578">/** blend version */</a>
<a name="ln3579">int dt_develop_blend_version(void)</a>
<a name="ln3580">{</a>
<a name="ln3581">  return DEVELOP_BLEND_VERSION;</a>
<a name="ln3582">}</a>
<a name="ln3583"> </a>
<a name="ln3584">/** report back specific memory requirements for blend step (only relevant for OpenCL path) */</a>
<a name="ln3585">void tiling_callback_blendop(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln3586">                             const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out,</a>
<a name="ln3587">                             struct dt_develop_tiling_t *tiling)</a>
<a name="ln3588">{</a>
<a name="ln3589">  tiling-&gt;factor = 3.5f; // in + out + (guide, tmp) + two quarter buffers for the mask</a>
<a name="ln3590">  tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln3591">  tiling-&gt;overhead = 0;</a>
<a name="ln3592">  tiling-&gt;overlap = 0;</a>
<a name="ln3593">  tiling-&gt;xalign = 1;</a>
<a name="ln3594">  tiling-&gt;yalign = 1;</a>
<a name="ln3595">}</a>
<a name="ln3596"> </a>
<a name="ln3597">/** check if content of params is all zero, indicating a non-initialized set of</a>
<a name="ln3598">   blend parameters</a>
<a name="ln3599">    which needs special care. */</a>
<a name="ln3600">gboolean dt_develop_blend_params_is_all_zero(const void *params, size_t length)</a>
<a name="ln3601">{</a>
<a name="ln3602">  const char *data = (const char *)params;</a>
<a name="ln3603"> </a>
<a name="ln3604">  for(size_t k = 0; k &lt; length; k++)</a>
<a name="ln3605">    if(data[k]) return FALSE;</a>
<a name="ln3606"> </a>
<a name="ln3607">  return TRUE;</a>
<a name="ln3608">}</a>
<a name="ln3609"> </a>
<a name="ln3610">/** update blendop params from older versions */</a>
<a name="ln3611">int dt_develop_blend_legacy_params(dt_iop_module_t *module, const void *const old_params,</a>
<a name="ln3612">                                   const int old_version, void *new_params, const int new_version,</a>
<a name="ln3613">                                   const int length)</a>
<a name="ln3614">{</a>
<a name="ln3615">  // first deal with all-zero parmameter sets, regardless of version number.</a>
<a name="ln3616">  // these occurred in previous</a>
<a name="ln3617">  // darktable versions when modules</a>
<a name="ln3618">  // without blend support stored zero-initialized data in history stack. that's</a>
<a name="ln3619">  // no problem unless the module</a>
<a name="ln3620">  // gets blend</a>
<a name="ln3621">  // support later (e.g. module exposure). remedy: we simply initialize with the</a>
<a name="ln3622">  // current default blend params</a>
<a name="ln3623">  // in this case.</a>
<a name="ln3624">  if(dt_develop_blend_params_is_all_zero(old_params, length))</a>
<a name="ln3625">  {</a>
<a name="ln3626">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3627">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3628"> </a>
<a name="ln3629">    *n = *d;</a>
<a name="ln3630">    return 0;</a>
<a name="ln3631">  }</a>
<a name="ln3632"> </a>
<a name="ln3633">  if(old_version == 1 &amp;&amp; new_version == 9)</a>
<a name="ln3634">  {</a>
<a name="ln3635">    if(length != sizeof(dt_develop_blend_params1_t)) return 1;</a>
<a name="ln3636"> </a>
<a name="ln3637">    dt_develop_blend_params1_t *o = (dt_develop_blend_params1_t *)old_params;</a>
<a name="ln3638">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3639">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3640"> </a>
<a name="ln3641">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3642">    n-&gt;mask_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_MASK_DISABLED : DEVELOP_MASK_ENABLED;</a>
<a name="ln3643">    n-&gt;blend_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_BLEND_NORMAL2 : o-&gt;mode;</a>
<a name="ln3644">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3645">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3646">    return 0;</a>
<a name="ln3647">  }</a>
<a name="ln3648"> </a>
<a name="ln3649">  if(old_version == 2 &amp;&amp; new_version == 9)</a>
<a name="ln3650">  {</a>
<a name="ln3651">    if(length != sizeof(dt_develop_blend_params2_t)) return 1;</a>
<a name="ln3652"> </a>
<a name="ln3653">    dt_develop_blend_params2_t *o = (dt_develop_blend_params2_t *)old_params;</a>
<a name="ln3654">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3655">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3656"> </a>
<a name="ln3657">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3658">    n-&gt;mask_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_MASK_DISABLED : DEVELOP_MASK_ENABLED;</a>
<a name="ln3659">    n-&gt;mask_mode |= ((o-&gt;blendif &amp; (1u &lt;&lt; DEVELOP_BLENDIF_active)) &amp;&amp; (n-&gt;mask_mode == DEVELOP_MASK_ENABLED))</a>
<a name="ln3660">                        ? DEVELOP_MASK_CONDITIONAL</a>
<a name="ln3661">                        : 0;</a>
<a name="ln3662">    n-&gt;blend_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_BLEND_NORMAL2 : o-&gt;mode;</a>
<a name="ln3663">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3664">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3665">    n-&gt;blendif = o-&gt;blendif &amp; 0xff; // only just in case: knock out all bits</a>
<a name="ln3666">                                    // which were undefined in version</a>
<a name="ln3667">                                    // 2; also switch off old &quot;active&quot; bit</a>
<a name="ln3668">    for(int i = 0; i &lt; (4 * 8); i++) n-&gt;blendif_parameters[i] = o-&gt;blendif_parameters[i];</a>
<a name="ln3669"> </a>
<a name="ln3670">    return 0;</a>
<a name="ln3671">  }</a>
<a name="ln3672"> </a>
<a name="ln3673">  if(old_version == 3 &amp;&amp; new_version == 9)</a>
<a name="ln3674">  {</a>
<a name="ln3675">    if(length != sizeof(dt_develop_blend_params3_t)) return 1;</a>
<a name="ln3676"> </a>
<a name="ln3677">    dt_develop_blend_params3_t *o = (dt_develop_blend_params3_t *)old_params;</a>
<a name="ln3678">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3679">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3680"> </a>
<a name="ln3681">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3682">    n-&gt;mask_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_MASK_DISABLED : DEVELOP_MASK_ENABLED;</a>
<a name="ln3683">    n-&gt;mask_mode |= ((o-&gt;blendif &amp; (1u &lt;&lt; DEVELOP_BLENDIF_active)) &amp;&amp; (n-&gt;mask_mode == DEVELOP_MASK_ENABLED))</a>
<a name="ln3684">                        ? DEVELOP_MASK_CONDITIONAL</a>
<a name="ln3685">                        : 0;</a>
<a name="ln3686">    n-&gt;blend_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_BLEND_NORMAL2 : o-&gt;mode;</a>
<a name="ln3687">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3688">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3689">    n-&gt;blendif = o-&gt;blendif &amp; ~(1u &lt;&lt; DEVELOP_BLENDIF_active); // knock out old unused &quot;active&quot; flag</a>
<a name="ln3690">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3691"> </a>
<a name="ln3692">    return 0;</a>
<a name="ln3693">  }</a>
<a name="ln3694"> </a>
<a name="ln3695">  if(old_version == 4 &amp;&amp; new_version == 9)</a>
<a name="ln3696">  {</a>
<a name="ln3697">    if(length != sizeof(dt_develop_blend_params4_t)) return 1;</a>
<a name="ln3698"> </a>
<a name="ln3699">    dt_develop_blend_params4_t *o = (dt_develop_blend_params4_t *)old_params;</a>
<a name="ln3700">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3701">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3702"> </a>
<a name="ln3703">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3704">    n-&gt;mask_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_MASK_DISABLED : DEVELOP_MASK_ENABLED;</a>
<a name="ln3705">    n-&gt;mask_mode |= ((o-&gt;blendif &amp; (1u &lt;&lt; DEVELOP_BLENDIF_active)) &amp;&amp; (n-&gt;mask_mode == DEVELOP_MASK_ENABLED))</a>
<a name="ln3706">                        ? DEVELOP_MASK_CONDITIONAL</a>
<a name="ln3707">                        : 0;</a>
<a name="ln3708">    n-&gt;blend_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_BLEND_NORMAL2 : o-&gt;mode;</a>
<a name="ln3709">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3710">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3711">    n-&gt;blur_radius = o-&gt;radius;</a>
<a name="ln3712">    n-&gt;blendif = o-&gt;blendif &amp; ~(1u &lt;&lt; DEVELOP_BLENDIF_active); // knock out old unused &quot;active&quot; flag</a>
<a name="ln3713">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3714"> </a>
<a name="ln3715">    return 0;</a>
<a name="ln3716">  }</a>
<a name="ln3717"> </a>
<a name="ln3718">  if(old_version == 5 &amp;&amp; new_version == 9)</a>
<a name="ln3719">  {</a>
<a name="ln3720">    if(length != sizeof(dt_develop_blend_params5_t)) return 1;</a>
<a name="ln3721"> </a>
<a name="ln3722">    dt_develop_blend_params5_t *o = (dt_develop_blend_params5_t *)old_params;</a>
<a name="ln3723">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3724">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3725"> </a>
<a name="ln3726">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3727">    n-&gt;mask_mode = o-&gt;mask_mode;</a>
<a name="ln3728">    n-&gt;blend_mode = o-&gt;blend_mode;</a>
<a name="ln3729">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3730">    n-&gt;mask_combine = o-&gt;mask_combine;</a>
<a name="ln3731">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3732">    n-&gt;blur_radius = o-&gt;radius;</a>
<a name="ln3733">    // this is needed as version 5 contained a bug which screwed up history</a>
<a name="ln3734">    // stacks of even older</a>
<a name="ln3735">    // versions. potentially bad history stacks can be identified by an active</a>
<a name="ln3736">    // bit no. 32 in blendif.</a>
<a name="ln3737">    n-&gt;blendif = (o-&gt;blendif &amp; (1u &lt;&lt; DEVELOP_BLENDIF_active) ? o-&gt;blendif | 31 : o-&gt;blendif)</a>
<a name="ln3738">                 &amp; ~(1u &lt;&lt; DEVELOP_BLENDIF_active);</a>
<a name="ln3739">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3740"> </a>
<a name="ln3741">    return 0;</a>
<a name="ln3742">  }</a>
<a name="ln3743"> </a>
<a name="ln3744">  if(old_version == 6 &amp;&amp; new_version == 9)</a>
<a name="ln3745">  {</a>
<a name="ln3746">    if(length != sizeof(dt_develop_blend_params6_t)) return 1;</a>
<a name="ln3747"> </a>
<a name="ln3748">    dt_develop_blend_params6_t *o = (dt_develop_blend_params6_t *)old_params;</a>
<a name="ln3749">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3750">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3751"> </a>
<a name="ln3752">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3753">    n-&gt;mask_mode = o-&gt;mask_mode;</a>
<a name="ln3754">    n-&gt;blend_mode = o-&gt;blend_mode;</a>
<a name="ln3755">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3756">    n-&gt;mask_combine = o-&gt;mask_combine;</a>
<a name="ln3757">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3758">    n-&gt;blur_radius = o-&gt;radius;</a>
<a name="ln3759">    n-&gt;blendif = o-&gt;blendif;</a>
<a name="ln3760">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3761">    return 0;</a>
<a name="ln3762">  }</a>
<a name="ln3763"> </a>
<a name="ln3764">  if(old_version == 7 &amp;&amp; new_version == 9)</a>
<a name="ln3765">  {</a>
<a name="ln3766">    if(length != sizeof(dt_develop_blend_params7_t)) return 1;</a>
<a name="ln3767"> </a>
<a name="ln3768">    dt_develop_blend_params7_t *o = (dt_develop_blend_params7_t *)old_params;</a>
<a name="ln3769">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3770">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3771"> </a>
<a name="ln3772">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3773">    n-&gt;mask_mode = o-&gt;mask_mode;</a>
<a name="ln3774">    n-&gt;blend_mode = o-&gt;blend_mode;</a>
<a name="ln3775">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3776">    n-&gt;mask_combine = o-&gt;mask_combine;</a>
<a name="ln3777">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3778">    n-&gt;blur_radius = o-&gt;radius;</a>
<a name="ln3779">    n-&gt;blendif = o-&gt;blendif;</a>
<a name="ln3780">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3781">    return 0;</a>
<a name="ln3782">  }</a>
<a name="ln3783"> </a>
<a name="ln3784">  if(old_version == 8 &amp;&amp; new_version == 9)</a>
<a name="ln3785">  {</a>
<a name="ln3786">    if(length != sizeof(dt_develop_blend_params8_t)) return 1;</a>
<a name="ln3787"> </a>
<a name="ln3788">    dt_develop_blend_params8_t *o = (dt_develop_blend_params8_t *)old_params;</a>
<a name="ln3789">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3790">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3791"> </a>
<a name="ln3792">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3793">    n-&gt;mask_mode = o-&gt;mask_mode;</a>
<a name="ln3794">    n-&gt;blend_mode = o-&gt;blend_mode;</a>
<a name="ln3795">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3796">    n-&gt;mask_combine = o-&gt;mask_combine;</a>
<a name="ln3797">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3798">    n-&gt;blendif = o-&gt;blendif;</a>
<a name="ln3799">    n-&gt;feathering_radius = o-&gt;feathering_radius;</a>
<a name="ln3800">    n-&gt;feathering_guide = o-&gt;feathering_guide;</a>
<a name="ln3801">    n-&gt;blur_radius = o-&gt;blur_radius;</a>
<a name="ln3802">    n-&gt;contrast = o-&gt;contrast;</a>
<a name="ln3803">    n-&gt;brightness = o-&gt;brightness;</a>
<a name="ln3804">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3805">    return 0;</a>
<a name="ln3806">  }</a>
<a name="ln3807"> </a>
<a name="ln3808">  return 1;</a>
<a name="ln3809">}</a>
<a name="ln3810"> </a>
<a name="ln3811">int dt_develop_blend_legacy_params_from_so(dt_iop_module_so_t *module_so, const void *const old_params,</a>
<a name="ln3812">                                           const int old_version, void *new_params, const int new_version,</a>
<a name="ln3813">                                           const int length)</a>
<a name="ln3814">{</a>
<a name="ln3815">  // we need a dt_iop_module_t for dt_develop_blend_legacy_params()</a>
<a name="ln3816">  dt_iop_module_t *module;</a>
<a name="ln3817">  module = (dt_iop_module_t *)calloc(1, sizeof(dt_iop_module_t));</a>
<a name="ln3818">  if(dt_iop_load_module_by_so(module, module_so, NULL))</a>
<a name="ln3819">  {</a>
<a name="ln3820">    free(module);</a>
<a name="ln3821">    return 1;</a>
<a name="ln3822">  }</a>
<a name="ln3823"> </a>
<a name="ln3824">  if(module-&gt;params_size == 0)</a>
<a name="ln3825">  {</a>
<a name="ln3826">    dt_iop_cleanup_module(module);</a>
<a name="ln3827">    free(module);</a>
<a name="ln3828">    return 1;</a>
<a name="ln3829">  }</a>
<a name="ln3830"> </a>
<a name="ln3831">  // convert the old blend params to new</a>
<a name="ln3832">  int res = dt_develop_blend_legacy_params(module, old_params, old_version,</a>
<a name="ln3833">                                           new_params, dt_develop_blend_version(),</a>
<a name="ln3834">                                           length);</a>
<a name="ln3835">  dt_iop_cleanup_module(module);</a>
<a name="ln3836">  free(module);</a>
<a name="ln3837">  return res;</a>
<a name="ln3838">}</a>
<a name="ln3839"> </a>
<a name="ln3840">// tools/update_modelines.sh</a>
<a name="ln3841">// remove-trailing-space on;</a>
<a name="ln3842">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln3843">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln3844">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1123"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: '((lmax - (lmax - la) * (lmax - lb)))'. One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="1171"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: '((lmax - (lmax - la) * (lmax - lb)))'. One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="1191"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: '((lmax - (lmax - la) * (lmax - lb)))'. One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="1702"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: ((expression)). One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="1751"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: ((expression)). One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="1772"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: ((expression)). One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="3114"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_hash_table_replace' function. Inspect the second argument.</p></div>
<div class="balloon" rel="3118"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_hash_table_remove' function. Inspect the second argument.</p></div>
<div class="balloon" rel="3511"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_hash_table_replace' function. Inspect the second argument.</p></div>
<div class="balloon" rel="3515"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_hash_table_remove' function. Inspect the second argument.</p></div>
<div class="balloon" rel="3543"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'b'. Check lines: 3543, 3540.</p></div>
<div class="balloon" rel="3824"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'module'. Check lines: 3824, 3817.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
