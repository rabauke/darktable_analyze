
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011-2012 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/darktable.h&quot;</a>
<a name="ln20">#include &quot;common/debug.h&quot;</a>
<a name="ln21">#include &quot;common/image_cache.h&quot;</a>
<a name="ln22">#include &quot;common/iop_group.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;develop/develop.h&quot;</a>
<a name="ln26">#include &quot;gui/gtk.h&quot;</a>
<a name="ln27">#include &quot;libs/lib.h&quot;</a>
<a name="ln28">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">DT_MODULE(1)</a>
<a name="ln31"> </a>
<a name="ln32">#define PADDING 2</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;modulegroups.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">typedef struct dt_lib_modulegroups_t</a>
<a name="ln37">{</a>
<a name="ln38">  uint32_t current;</a>
<a name="ln39">  GtkWidget *buttons[DT_MODULEGROUP_SIZE];</a>
<a name="ln40">  GtkWidget *text_entry;</a>
<a name="ln41">  GtkWidget *hbox_buttons;</a>
<a name="ln42">  GtkWidget *hbox_search_box;</a>
<a name="ln43">} dt_lib_modulegroups_t;</a>
<a name="ln44"> </a>
<a name="ln45">typedef enum dt_lib_modulegroup_iop_visibility_type_t</a>
<a name="ln46">{</a>
<a name="ln47">  DT_MODULEGROUP_SEARCH_IOP_TEXT_VISIBLE,</a>
<a name="ln48">  DT_MODULEGROUP_SEARCH_IOP_GROUPS_VISIBLE,</a>
<a name="ln49">  DT_MODULEGROUP_SEARCH_IOP_TEXT_GROUPS_VISIBLE</a>
<a name="ln50">} dt_lib_modulegroup_iop_visibility_type_t;</a>
<a name="ln51"> </a>
<a name="ln52">/* toggle button callback */</a>
<a name="ln53">static void _lib_modulegroups_toggle(GtkWidget *button, gpointer data);</a>
<a name="ln54">/* helper function to update iop module view depending on group */</a>
<a name="ln55">static void _lib_modulegroups_update_iop_visibility(dt_lib_module_t *self);</a>
<a name="ln56"> </a>
<a name="ln57">/* modulergroups proxy set group function</a>
<a name="ln58">   \see dt_dev_modulegroups_set()</a>
<a name="ln59">*/</a>
<a name="ln60">static void _lib_modulegroups_set(dt_lib_module_t *self, uint32_t group);</a>
<a name="ln61">/* modulegroups proxy get group function</a>
<a name="ln62">  \see dt_dev_modulegroups_get()</a>
<a name="ln63">*/</a>
<a name="ln64">static uint32_t _lib_modulegroups_get(dt_lib_module_t *self);</a>
<a name="ln65">/* modulegroups proxy test function.</a>
<a name="ln66">   tests if iop module group flags matches modulegroup.</a>
<a name="ln67">*/</a>
<a name="ln68">static gboolean _lib_modulegroups_test(dt_lib_module_t *self, uint32_t group, uint32_t iop_group);</a>
<a name="ln69">/* modulegroups proxy switch group function.</a>
<a name="ln70">   sets the active group which module belongs too.</a>
<a name="ln71">*/</a>
<a name="ln72">static void _lib_modulegroups_switch_group(dt_lib_module_t *self, dt_iop_module_t *module);</a>
<a name="ln73">/* modulergroups proxy search text focus function</a>
<a name="ln74">   \see dt_dev_modulegroups_search_text_focus()</a>
<a name="ln75">*/</a>
<a name="ln76">static void _lib_modulegroups_search_text_focus(dt_lib_module_t *self);</a>
<a name="ln77"> </a>
<a name="ln78">/* hook up with viewmanager view change to initialize modulegroup */</a>
<a name="ln79">static void _lib_modulegroups_viewchanged_callback(gpointer instance, dt_view_t *old_view,</a>
<a name="ln80">                                                   dt_view_t *new_view, gpointer data);</a>
<a name="ln81"> </a>
<a name="ln82">const char *name(dt_lib_module_t *self)</a>
<a name="ln83">{</a>
<a name="ln84">  return _(&quot;modulegroups&quot;);</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87">const char **views(dt_lib_module_t *self)</a>
<a name="ln88">{</a>
<a name="ln89">  static const char *v[] = {&quot;darkroom&quot;, NULL};</a>
<a name="ln90">  return v;</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln94">{</a>
<a name="ln95">  return DT_UI_CONTAINER_PANEL_RIGHT_TOP;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">/* this module should always be shown without expander */</a>
<a name="ln100">int expandable(dt_lib_module_t *self)</a>
<a name="ln101">{</a>
<a name="ln102">  return 0;</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">int position()</a>
<a name="ln106">{</a>
<a name="ln107">  return 999;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">int _iop_get_group_order(const int group_id, const int default_order)</a>
<a name="ln111">{</a>
<a name="ln112">  if (group_id &lt; DT_MODULEGROUP_BASIC)</a>
<a name="ln113">    return group_id;</a>
<a name="ln114"> </a>
<a name="ln115">  gchar *key = dt_util_dstrcat(NULL, &quot;plugins/darkroom/group_order/%d&quot;, group_id - 1);</a>
<a name="ln116">  int prefs = dt_conf_get_int(key);</a>
<a name="ln117"> </a>
<a name="ln118">  /* if zero, not found, record it */</a>
<a name="ln119">  if (!prefs)</a>
<a name="ln120">  {</a>
<a name="ln121">    dt_conf_set_int(key, default_order - 1);</a>
<a name="ln122">    prefs = default_order;</a>
<a name="ln123">  }</a>
<a name="ln124">  else</a>
<a name="ln125">    prefs += 1;</a>
<a name="ln126"> </a>
<a name="ln127">  g_free(key);</a>
<a name="ln128">  return prefs&lt;1 ? 1 : (prefs&gt;DT_MODULEGROUP_SIZE? DT_MODULEGROUP_SIZE: prefs);</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">static dt_lib_modulegroup_iop_visibility_type_t _get_search_iop_visibility()</a>
<a name="ln132">{</a>
<a name="ln133">  dt_lib_modulegroup_iop_visibility_type_t ret = DT_MODULEGROUP_SEARCH_IOP_TEXT_GROUPS_VISIBLE;</a>
<a name="ln134">  const gchar *show_text_entry = dt_conf_get_string(&quot;plugins/darkroom/search_iop_by_text&quot;);</a>
<a name="ln135"> </a>
<a name="ln136">  if(strcmp(show_text_entry, &quot;show search text&quot;) == 0)</a>
<a name="ln137">    ret = DT_MODULEGROUP_SEARCH_IOP_TEXT_VISIBLE;</a>
<a name="ln138">  else if(strcmp(show_text_entry, &quot;show groups&quot;) == 0)</a>
<a name="ln139">    ret = DT_MODULEGROUP_SEARCH_IOP_GROUPS_VISIBLE;</a>
<a name="ln140">  else if(strcmp(show_text_entry, &quot;show both&quot;) == 0)</a>
<a name="ln141">    ret = DT_MODULEGROUP_SEARCH_IOP_TEXT_GROUPS_VISIBLE;</a>
<a name="ln142"> </a>
<a name="ln143">  return ret;</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">static void _text_entry_changed_callback(GtkEntry *entry, dt_lib_module_t *self)</a>
<a name="ln147">{</a>
<a name="ln148">  _lib_modulegroups_update_iop_visibility(self);</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">static gboolean _text_entry_icon_press_callback(GtkEntry *entry, GtkEntryIconPosition icon_pos, GdkEvent *event,</a>
<a name="ln152">                                                dt_lib_module_t *self)</a>
<a name="ln153">{</a>
<a name="ln154">  dt_lib_modulegroups_t *d = (dt_lib_modulegroups_t *)self-&gt;data;</a>
<a name="ln155"> </a>
<a name="ln156">  gtk_entry_set_text(GTK_ENTRY(d-&gt;text_entry), &quot;&quot;);</a>
<a name="ln157"> </a>
<a name="ln158">  return TRUE;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">void gui_init(dt_lib_module_t *self)</a>
<a name="ln162">{</a>
<a name="ln163">  /* initialize ui widgets */</a>
<a name="ln164">  dt_lib_modulegroups_t *d = (dt_lib_modulegroups_t *)g_malloc0(sizeof(dt_lib_modulegroups_t));</a>
<a name="ln165">  self-&gt;data = (void *)d;</a>
<a name="ln166"> </a>
<a name="ln167">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln168">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln169">  gtk_widget_set_name(self-&gt;widget, &quot;modules-tabs&quot;);</a>
<a name="ln170"> </a>
<a name="ln171">  dtgtk_cairo_paint_flags_t pf = CPF_STYLE_FLAT;</a>
<a name="ln172"> </a>
<a name="ln173">  d-&gt;hbox_buttons = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln174">  d-&gt;hbox_search_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln175"> </a>
<a name="ln176">  /* active */</a>
<a name="ln177">  d-&gt;buttons[DT_MODULEGROUP_ACTIVE_PIPE] = dtgtk_togglebutton_new(dtgtk_cairo_paint_modulegroup_active, pf, NULL);</a>
<a name="ln178">  g_signal_connect(d-&gt;buttons[DT_MODULEGROUP_ACTIVE_PIPE], &quot;toggled&quot;, G_CALLBACK(_lib_modulegroups_toggle),</a>
<a name="ln179">                   self);</a>
<a name="ln180">  gtk_widget_set_tooltip_text(d-&gt;buttons[DT_MODULEGROUP_ACTIVE_PIPE], _(&quot;show only active modules&quot;));</a>
<a name="ln181"> </a>
<a name="ln182">  /* favorites */</a>
<a name="ln183">  d-&gt;buttons[DT_MODULEGROUP_FAVORITES] = dtgtk_togglebutton_new(dtgtk_cairo_paint_modulegroup_favorites, pf, NULL);</a>
<a name="ln184">  g_signal_connect(d-&gt;buttons[DT_MODULEGROUP_FAVORITES], &quot;toggled&quot;, G_CALLBACK(_lib_modulegroups_toggle),</a>
<a name="ln185">                   self);</a>
<a name="ln186">  gtk_widget_set_tooltip_text(d-&gt;buttons[DT_MODULEGROUP_FAVORITES],</a>
<a name="ln187">                              _(&quot;show only your favourite modules (selected in `more modules' below)&quot;));</a>
<a name="ln188"> </a>
<a name="ln189">  /* basic */</a>
<a name="ln190">  int g_index = _iop_get_group_order(DT_MODULEGROUP_BASIC, DT_MODULEGROUP_BASIC);</a>
<a name="ln191">  d-&gt;buttons[g_index] = dtgtk_togglebutton_new(dtgtk_cairo_paint_modulegroup_basic, pf, NULL);</a>
<a name="ln192">  g_signal_connect(d-&gt;buttons[g_index], &quot;toggled&quot;, G_CALLBACK(_lib_modulegroups_toggle), self);</a>
<a name="ln193">  gtk_widget_set_tooltip_text(d-&gt;buttons[g_index], _(&quot;basic group&quot;));</a>
<a name="ln194"> </a>
<a name="ln195">  /* tone */</a>
<a name="ln196">  g_index = _iop_get_group_order(DT_MODULEGROUP_TONE, DT_MODULEGROUP_TONE);</a>
<a name="ln197">  d-&gt;buttons[g_index] = dtgtk_togglebutton_new(dtgtk_cairo_paint_modulegroup_tone, pf, NULL);</a>
<a name="ln198">  g_signal_connect(d-&gt;buttons[g_index], &quot;toggled&quot;, G_CALLBACK(_lib_modulegroups_toggle), self);</a>
<a name="ln199">  gtk_widget_set_tooltip_text(d-&gt;buttons[g_index], _(&quot;tone group&quot;));</a>
<a name="ln200"> </a>
<a name="ln201">  /* color */</a>
<a name="ln202">  g_index = _iop_get_group_order(DT_MODULEGROUP_COLOR, DT_MODULEGROUP_COLOR);</a>
<a name="ln203">  d-&gt;buttons[g_index] = dtgtk_togglebutton_new(dtgtk_cairo_paint_modulegroup_color, pf, NULL);</a>
<a name="ln204">  g_signal_connect(d-&gt;buttons[g_index], &quot;toggled&quot;, G_CALLBACK(_lib_modulegroups_toggle), self);</a>
<a name="ln205">  gtk_widget_set_tooltip_text(d-&gt;buttons[g_index], _(&quot;color group&quot;));</a>
<a name="ln206"> </a>
<a name="ln207">  /* correct */</a>
<a name="ln208">  g_index = _iop_get_group_order(DT_MODULEGROUP_CORRECT, DT_MODULEGROUP_CORRECT);</a>
<a name="ln209">  d-&gt;buttons[g_index] = dtgtk_togglebutton_new(dtgtk_cairo_paint_modulegroup_correct, pf, NULL);</a>
<a name="ln210">  g_signal_connect(d-&gt;buttons[g_index], &quot;toggled&quot;, G_CALLBACK(_lib_modulegroups_toggle), self);</a>
<a name="ln211">  gtk_widget_set_tooltip_text(d-&gt;buttons[g_index], _(&quot;correction group&quot;));</a>
<a name="ln212"> </a>
<a name="ln213">  /* effect */</a>
<a name="ln214">  g_index = _iop_get_group_order(DT_MODULEGROUP_EFFECT, DT_MODULEGROUP_EFFECT);</a>
<a name="ln215">  d-&gt;buttons[g_index] = dtgtk_togglebutton_new(dtgtk_cairo_paint_modulegroup_effect, pf, NULL);</a>
<a name="ln216">  g_signal_connect(d-&gt;buttons[g_index], &quot;toggled&quot;, G_CALLBACK(_lib_modulegroups_toggle), self);</a>
<a name="ln217">  gtk_widget_set_tooltip_text(d-&gt;buttons[g_index], _(&quot;effects group&quot;));</a>
<a name="ln218"> </a>
<a name="ln219">  /*</a>
<a name="ln220">   * layout button row</a>
<a name="ln221">   */</a>
<a name="ln222">  GtkWidget *br = d-&gt;hbox_buttons;</a>
<a name="ln223">  for(int k = 0; k &lt; DT_MODULEGROUP_SIZE; k++)</a>
<a name="ln224">  {</a>
<a name="ln225">    gtk_box_pack_start(GTK_BOX(br), d-&gt;buttons[k], TRUE, TRUE, 0);</a>
<a name="ln226">  }</a>
<a name="ln227"> </a>
<a name="ln228">  /* search box */</a>
<a name="ln229">  GtkWidget *label = gtk_label_new(_(&quot;search module&quot;));</a>
<a name="ln230">  gtk_box_pack_start(GTK_BOX(d-&gt;hbox_search_box), label, FALSE, TRUE, 0);</a>
<a name="ln231"> </a>
<a name="ln232">  d-&gt;text_entry = gtk_entry_new();</a>
<a name="ln233">  dt_gui_key_accel_block_on_focus_connect(d-&gt;text_entry);</a>
<a name="ln234">  gtk_widget_add_events(d-&gt;text_entry, GDK_FOCUS_CHANGE_MASK);</a>
<a name="ln235"> </a>
<a name="ln236">  gtk_widget_set_tooltip_text(d-&gt;text_entry, _(&quot;search modules by name or tag&quot;));</a>
<a name="ln237">  gtk_widget_add_events(d-&gt;text_entry, GDK_KEY_PRESS_MASK);</a>
<a name="ln238">  g_signal_connect(G_OBJECT(d-&gt;text_entry), &quot;changed&quot;, G_CALLBACK(_text_entry_changed_callback), self);</a>
<a name="ln239">  g_signal_connect(G_OBJECT(d-&gt;text_entry), &quot;icon-press&quot;, G_CALLBACK(_text_entry_icon_press_callback), self);</a>
<a name="ln240">  gtk_box_pack_start(GTK_BOX(d-&gt;hbox_search_box), d-&gt;text_entry, TRUE, TRUE, 0);</a>
<a name="ln241">  gtk_entry_set_width_chars(GTK_ENTRY(d-&gt;text_entry), 0);</a>
<a name="ln242">  gtk_entry_set_icon_from_icon_name(GTK_ENTRY(d-&gt;text_entry), GTK_ENTRY_ICON_SECONDARY, &quot;edit-clear&quot;);</a>
<a name="ln243">  gtk_entry_set_icon_tooltip_text(GTK_ENTRY(d-&gt;text_entry), GTK_ENTRY_ICON_SECONDARY, _(&quot;clear text&quot;));</a>
<a name="ln244">  gtk_widget_set_name(GTK_WIDGET(d-&gt;hbox_search_box), &quot;search-box&quot;);</a>
<a name="ln245"> </a>
<a name="ln246"> </a>
<a name="ln247">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), d-&gt;hbox_buttons, TRUE, TRUE, 0);</a>
<a name="ln248">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), d-&gt;hbox_search_box, TRUE, TRUE, 0);</a>
<a name="ln249"> </a>
<a name="ln250">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;buttons[d-&gt;current]), TRUE);</a>
<a name="ln251">  gtk_widget_show_all(self-&gt;widget);</a>
<a name="ln252">  gtk_widget_show_all(d-&gt;hbox_buttons);</a>
<a name="ln253">  gtk_widget_set_no_show_all(d-&gt;hbox_buttons, TRUE);</a>
<a name="ln254">  gtk_widget_show_all(d-&gt;hbox_search_box);</a>
<a name="ln255">  gtk_widget_set_no_show_all(d-&gt;hbox_search_box, TRUE);</a>
<a name="ln256"> </a>
<a name="ln257">  dt_lib_modulegroup_iop_visibility_type_t show_text_entry = _get_search_iop_visibility();</a>
<a name="ln258">  if(show_text_entry == DT_MODULEGROUP_SEARCH_IOP_GROUPS_VISIBLE)</a>
<a name="ln259">  {</a>
<a name="ln260">    gtk_widget_hide(d-&gt;hbox_search_box);</a>
<a name="ln261">  }</a>
<a name="ln262">  else if(show_text_entry == DT_MODULEGROUP_SEARCH_IOP_TEXT_VISIBLE)</a>
<a name="ln263">  {</a>
<a name="ln264">    gtk_widget_hide(d-&gt;hbox_buttons);</a>
<a name="ln265">  }</a>
<a name="ln266"> </a>
<a name="ln267">  /*</a>
<a name="ln268">   * set the proxy functions</a>
<a name="ln269">   */</a>
<a name="ln270">  darktable.develop-&gt;proxy.modulegroups.module = self;</a>
<a name="ln271">  darktable.develop-&gt;proxy.modulegroups.set = _lib_modulegroups_set;</a>
<a name="ln272">  darktable.develop-&gt;proxy.modulegroups.get = _lib_modulegroups_get;</a>
<a name="ln273">  darktable.develop-&gt;proxy.modulegroups.test = _lib_modulegroups_test;</a>
<a name="ln274">  darktable.develop-&gt;proxy.modulegroups.switch_group = _lib_modulegroups_switch_group;</a>
<a name="ln275">  darktable.develop-&gt;proxy.modulegroups.search_text_focus = _lib_modulegroups_search_text_focus;</a>
<a name="ln276"> </a>
<a name="ln277">  /* let's connect to view changed signal to set default group */</a>
<a name="ln278">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_VIEWMANAGER_VIEW_CHANGED,</a>
<a name="ln279">                            G_CALLBACK(_lib_modulegroups_viewchanged_callback), self);</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln283">{</a>
<a name="ln284">  dt_lib_modulegroups_t *d = (dt_lib_modulegroups_t *)self-&gt;data;</a>
<a name="ln285"> </a>
<a name="ln286">  dt_gui_key_accel_block_on_focus_disconnect(d-&gt;text_entry);</a>
<a name="ln287"> </a>
<a name="ln288">  /* let's not listen to signals anymore.. */</a>
<a name="ln289">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_modulegroups_viewchanged_callback), self);</a>
<a name="ln290"> </a>
<a name="ln291">  darktable.develop-&gt;proxy.modulegroups.module = NULL;</a>
<a name="ln292">  darktable.develop-&gt;proxy.modulegroups.set = NULL;</a>
<a name="ln293">  darktable.develop-&gt;proxy.modulegroups.get = NULL;</a>
<a name="ln294">  darktable.develop-&gt;proxy.modulegroups.test = NULL;</a>
<a name="ln295">  darktable.develop-&gt;proxy.modulegroups.switch_group = NULL;</a>
<a name="ln296"> </a>
<a name="ln297">  g_free(self-&gt;data);</a>
<a name="ln298">  self-&gt;data = NULL;</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">static void _lib_modulegroups_viewchanged_callback(gpointer instance, dt_view_t *old_view,</a>
<a name="ln302">                                                   dt_view_t *new_view, gpointer data)</a>
<a name="ln303">{</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">static gboolean _lib_modulegroups_test_internal(dt_lib_module_t *self, uint32_t group, uint32_t iop_group)</a>
<a name="ln307">{</a>
<a name="ln308">  if(iop_group &amp; IOP_SPECIAL_GROUP_ACTIVE_PIPE &amp;&amp; group == DT_MODULEGROUP_ACTIVE_PIPE)</a>
<a name="ln309">    return TRUE;</a>
<a name="ln310">  else if(iop_group &amp; IOP_SPECIAL_GROUP_USER_DEFINED &amp;&amp; group == DT_MODULEGROUP_FAVORITES)</a>
<a name="ln311">    return TRUE;</a>
<a name="ln312">  else if(iop_group &amp; IOP_GROUP_BASIC &amp;&amp; group == DT_MODULEGROUP_BASIC)</a>
<a name="ln313">    return TRUE;</a>
<a name="ln314">  else if(iop_group &amp; IOP_GROUP_TONE &amp;&amp; group == DT_MODULEGROUP_TONE)</a>
<a name="ln315">    return TRUE;</a>
<a name="ln316">  else if(iop_group &amp; IOP_GROUP_COLOR &amp;&amp; group == DT_MODULEGROUP_COLOR)</a>
<a name="ln317">    return TRUE;</a>
<a name="ln318">  else if(iop_group &amp; IOP_GROUP_CORRECT &amp;&amp; group == DT_MODULEGROUP_CORRECT)</a>
<a name="ln319">    return TRUE;</a>
<a name="ln320">  else if(iop_group &amp; IOP_GROUP_EFFECT &amp;&amp; group == DT_MODULEGROUP_EFFECT)</a>
<a name="ln321">    return TRUE;</a>
<a name="ln322">  return FALSE;</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">static gboolean _lib_modulegroups_test(dt_lib_module_t *self, uint32_t group, uint32_t iop_group)</a>
<a name="ln326">{</a>
<a name="ln327">  return _lib_modulegroups_test_internal(self, _iop_get_group_order(group, group), iop_group);</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">static void _lib_modulegroups_update_iop_visibility(dt_lib_module_t *self)</a>
<a name="ln331">{</a>
<a name="ln332">  dt_lib_modulegroups_t *d = (dt_lib_modulegroups_t *)self-&gt;data;</a>
<a name="ln333"> </a>
<a name="ln334">  const dt_lib_modulegroup_iop_visibility_type_t visibility = _get_search_iop_visibility();</a>
<a name="ln335">  const gchar *text_entered = (gtk_widget_is_visible(GTK_WIDGET(d-&gt;hbox_search_box)))</a>
<a name="ln336">                                  ? gtk_entry_get_text(GTK_ENTRY(d-&gt;text_entry))</a>
<a name="ln337">                                  : NULL;</a>
<a name="ln338"> </a>
<a name="ln339">  GList *modules = darktable.develop-&gt;iop;</a>
<a name="ln340">  if(modules)</a>
<a name="ln341">  {</a>
<a name="ln342">    /*</a>
<a name="ln343">     * iterate over ip modules and do various test to</a>
<a name="ln344">     * detect if the modules should be shown or not.</a>
<a name="ln345">     */</a>
<a name="ln346">    do</a>
<a name="ln347">    {</a>
<a name="ln348">      dt_iop_module_t *module = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln349">      GtkWidget *w = module-&gt;expander;</a>
<a name="ln350"> </a>
<a name="ln351">      /* skip modules without an gui */</a>
<a name="ln352">      if(dt_iop_is_hidden(module)) continue;</a>
<a name="ln353"> </a>
<a name="ln354">      // do not show non-active modules</a>
<a name="ln355">      // we don't want the user to mess with those</a>
<a name="ln356">      if(module-&gt;iop_order == DBL_MAX)</a>
<a name="ln357">      {</a>
<a name="ln358">        if(darktable.develop-&gt;gui_module == module) dt_iop_request_focus(NULL);</a>
<a name="ln359">        if(w) gtk_widget_hide(w);</a>
<a name="ln360">        continue;</a>
<a name="ln361">      }</a>
<a name="ln362"> </a>
<a name="ln363">      // if there's some search text show matching modules only</a>
<a name="ln364">      if(text_entered &amp;&amp; text_entered[0] != '\0')</a>
<a name="ln365">      {</a>
<a name="ln366">        /* don't show deprecated ones */</a>
<a name="ln367">        if(module-&gt;flags() &amp; IOP_FLAGS_DEPRECATED)</a>
<a name="ln368">        {</a>
<a name="ln369">          if(darktable.develop-&gt;gui_module == module) dt_iop_request_focus(NULL);</a>
<a name="ln370">          if(w) gtk_widget_hide(w);</a>
<a name="ln371">        }</a>
<a name="ln372">        else</a>
<a name="ln373">        {</a>
<a name="ln374">          int is_match = (g_strstr_len(dt_iop_get_localized_name(module-&gt;op), -1, text_entered) != NULL);</a>
<a name="ln375"> </a>
<a name="ln376">          if(is_match)</a>
<a name="ln377">            gtk_widget_show(w);</a>
<a name="ln378">          else</a>
<a name="ln379">            gtk_widget_hide(w);</a>
<a name="ln380">        }</a>
<a name="ln381">        continue;</a>
<a name="ln382">      }</a>
<a name="ln383">      // if only the search box is visible show the active pipe</a>
<a name="ln384">      else if(visibility == DT_MODULEGROUP_SEARCH_IOP_TEXT_VISIBLE)</a>
<a name="ln385">      {</a>
<a name="ln386">        if(module-&gt;enabled)</a>
<a name="ln387">        {</a>
<a name="ln388">          if(w) gtk_widget_show(w);</a>
<a name="ln389">        }</a>
<a name="ln390">        else</a>
<a name="ln391">        {</a>
<a name="ln392">          if(darktable.develop-&gt;gui_module == module) dt_iop_request_focus(NULL);</a>
<a name="ln393">          if(w) gtk_widget_hide(w);</a>
<a name="ln394">        }</a>
<a name="ln395">        continue;</a>
<a name="ln396">      }</a>
<a name="ln397"> </a>
<a name="ln398">      /* lets show/hide modules dependent on current group*/</a>
<a name="ln399">      switch(d-&gt;current)</a>
<a name="ln400">      {</a>
<a name="ln401">        case DT_MODULEGROUP_ACTIVE_PIPE:</a>
<a name="ln402">        {</a>
<a name="ln403">          if(module-&gt;enabled)</a>
<a name="ln404">          {</a>
<a name="ln405">            if(w) gtk_widget_show(w);</a>
<a name="ln406">          }</a>
<a name="ln407">          else</a>
<a name="ln408">          {</a>
<a name="ln409">            if(darktable.develop-&gt;gui_module == module) dt_iop_request_focus(NULL);</a>
<a name="ln410">            if(w) gtk_widget_hide(w);</a>
<a name="ln411">          }</a>
<a name="ln412">        }</a>
<a name="ln413">        break;</a>
<a name="ln414"> </a>
<a name="ln415">        case DT_MODULEGROUP_FAVORITES:</a>
<a name="ln416">        {</a>
<a name="ln417">          if(module-&gt;so-&gt;state == dt_iop_state_FAVORITE)</a>
<a name="ln418">          {</a>
<a name="ln419">            if(w) gtk_widget_show(w);</a>
<a name="ln420">          }</a>
<a name="ln421">          else</a>
<a name="ln422">          {</a>
<a name="ln423">            if(darktable.develop-&gt;gui_module == module) dt_iop_request_focus(NULL);</a>
<a name="ln424">            if(w) gtk_widget_hide(w);</a>
<a name="ln425">          }</a>
<a name="ln426">        }</a>
<a name="ln427">        break;</a>
<a name="ln428"> </a>
<a name="ln429">        case DT_MODULEGROUP_NONE:</a>
<a name="ln430">        {</a>
<a name="ln431">          /* show all except hidden ones */</a>
<a name="ln432">          if((module-&gt;so-&gt;state != dt_iop_state_HIDDEN || module-&gt;enabled)</a>
<a name="ln433">             &amp;&amp; (!(module-&gt;flags() &amp; IOP_FLAGS_DEPRECATED)))</a>
<a name="ln434">          {</a>
<a name="ln435">            if(w) gtk_widget_show(w);</a>
<a name="ln436">          }</a>
<a name="ln437">          else</a>
<a name="ln438">          {</a>
<a name="ln439">            if(darktable.develop-&gt;gui_module == module) dt_iop_request_focus(NULL);</a>
<a name="ln440">            if(w) gtk_widget_hide(w);</a>
<a name="ln441">          }</a>
<a name="ln442">        }</a>
<a name="ln443">        break;</a>
<a name="ln444"> </a>
<a name="ln445">        default:</a>
<a name="ln446">        {</a>
<a name="ln447">          if(_lib_modulegroups_test_internal(self, d-&gt;current, dt_iop_get_group(module))</a>
<a name="ln448">             &amp;&amp; module-&gt;so-&gt;state != dt_iop_state_HIDDEN</a>
<a name="ln449">             &amp;&amp; (!(module-&gt;flags() &amp; IOP_FLAGS_DEPRECATED) || module-&gt;enabled))</a>
<a name="ln450">          {</a>
<a name="ln451">            if(w) gtk_widget_show(w);</a>
<a name="ln452">          }</a>
<a name="ln453">          else</a>
<a name="ln454">          {</a>
<a name="ln455">            if(darktable.develop-&gt;gui_module == module) dt_iop_request_focus(NULL);</a>
<a name="ln456">            if(w) gtk_widget_hide(w);</a>
<a name="ln457">          }</a>
<a name="ln458">        }</a>
<a name="ln459">      }</a>
<a name="ln460">    } while((modules = g_list_next(modules)) != NULL);</a>
<a name="ln461">  }</a>
<a name="ln462"> </a>
<a name="ln463">  // now that visibility has been updated set multi-show</a>
<a name="ln464">  dt_dev_modules_update_multishow(darktable.develop);</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">static void _lib_modulegroups_toggle(GtkWidget *button, gpointer user_data)</a>
<a name="ln468">{</a>
<a name="ln469">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln470">  dt_lib_modulegroups_t *d = (dt_lib_modulegroups_t *)self-&gt;data;</a>
<a name="ln471"> </a>
<a name="ln472">  /* block all button callbacks */</a>
<a name="ln473">  for(int k = 0; k &lt; DT_MODULEGROUP_SIZE; k++)</a>
<a name="ln474">    g_signal_handlers_block_matched(d-&gt;buttons[k], G_SIGNAL_MATCH_FUNC, 0, 0, NULL, _lib_modulegroups_toggle,</a>
<a name="ln475">                                    NULL);</a>
<a name="ln476"> </a>
<a name="ln477">  /* deactivate all buttons */</a>
<a name="ln478">  uint32_t cb = 0;</a>
<a name="ln479">  int gid = 0;</a>
<a name="ln480">  for(int k = 0; k &lt; DT_MODULEGROUP_SIZE; k++)</a>
<a name="ln481">  {</a>
<a name="ln482">    /* store toggled modulegroup */</a>
<a name="ln483">    if(d-&gt;buttons[k] == button)</a>
<a name="ln484">    {</a>
<a name="ln485">      cb = k;</a>
<a name="ln486">      gid = _iop_get_group_order(k, k);</a>
<a name="ln487">    }</a>
<a name="ln488">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;buttons[k]), FALSE);</a>
<a name="ln489">  }</a>
<a name="ln490"> </a>
<a name="ln491">  if(d-&gt;current == gid)</a>
<a name="ln492">    d-&gt;current = DT_MODULEGROUP_NONE;</a>
<a name="ln493">  else</a>
<a name="ln494">  {</a>
<a name="ln495">    d-&gt;current = gid;</a>
<a name="ln496">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;buttons[cb]), TRUE);</a>
<a name="ln497">  }</a>
<a name="ln498"> </a>
<a name="ln499">  /* unblock all button callbacks */</a>
<a name="ln500">  for(int k = 0; k &lt; DT_MODULEGROUP_SIZE; k++)</a>
<a name="ln501">    g_signal_handlers_unblock_matched(d-&gt;buttons[k], G_SIGNAL_MATCH_FUNC, 0, 0, NULL,</a>
<a name="ln502">                                      _lib_modulegroups_toggle, NULL);</a>
<a name="ln503"> </a>
<a name="ln504">  /* update visibility */</a>
<a name="ln505">  _lib_modulegroups_update_iop_visibility(self);</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">typedef struct _set_gui_thread_t</a>
<a name="ln509">{</a>
<a name="ln510">  dt_lib_module_t *self;</a>
<a name="ln511">  uint32_t group;</a>
<a name="ln512">} _set_gui_thread_t;</a>
<a name="ln513"> </a>
<a name="ln514">static gboolean _lib_modulegroups_set_gui_thread(gpointer user_data)</a>
<a name="ln515">{</a>
<a name="ln516">  _set_gui_thread_t *params = (_set_gui_thread_t *)user_data;</a>
<a name="ln517"> </a>
<a name="ln518">  dt_lib_modulegroups_t *d = (dt_lib_modulegroups_t *)params-&gt;self-&gt;data;</a>
<a name="ln519"> </a>
<a name="ln520">  const int group = _iop_get_group_order(params-&gt;group, params-&gt;group);</a>
<a name="ln521"> </a>
<a name="ln522">  /* if no change just update visibility */</a>
<a name="ln523">  if(d-&gt;current == group)</a>
<a name="ln524">  {</a>
<a name="ln525">    _lib_modulegroups_update_iop_visibility(params-&gt;self);</a>
<a name="ln526">    free(params);</a>
<a name="ln527">    return FALSE;</a>
<a name="ln528">  }</a>
<a name="ln529"> </a>
<a name="ln530">  /* set current group */</a>
<a name="ln531">  if(params-&gt;group &lt; DT_MODULEGROUP_SIZE &amp;&amp; GTK_IS_TOGGLE_BUTTON(d-&gt;buttons[params-&gt;group]))</a>
<a name="ln532">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;buttons[params-&gt;group]), TRUE);</a>
<a name="ln533"> </a>
<a name="ln534">  free(params);</a>
<a name="ln535">  return FALSE;</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538">static gboolean _lib_modulegroups_search_text_focus_gui_thread(gpointer user_data)</a>
<a name="ln539">{</a>
<a name="ln540">  _set_gui_thread_t *params = (_set_gui_thread_t *)user_data;</a>
<a name="ln541"> </a>
<a name="ln542">  dt_lib_modulegroups_t *d = (dt_lib_modulegroups_t *)params-&gt;self-&gt;data;</a>
<a name="ln543"> </a>
<a name="ln544">  if(GTK_IS_ENTRY(d-&gt;text_entry))</a>
<a name="ln545">  {</a>
<a name="ln546">    if(!gtk_widget_is_visible(GTK_WIDGET(d-&gt;hbox_search_box))) gtk_widget_show(GTK_WIDGET(d-&gt;hbox_search_box));</a>
<a name="ln547">    gtk_widget_grab_focus(GTK_WIDGET(d-&gt;text_entry));</a>
<a name="ln548">  }</a>
<a name="ln549"> </a>
<a name="ln550">  free(params);</a>
<a name="ln551">  return FALSE;</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">/* this is a proxy function so it might be called from another thread */</a>
<a name="ln555">static void _lib_modulegroups_set(dt_lib_module_t *self, uint32_t group)</a>
<a name="ln556">{</a>
<a name="ln557">  _set_gui_thread_t *params = (_set_gui_thread_t *)malloc(sizeof(_set_gui_thread_t));</a>
<a name="ln558">  if(!params) return;</a>
<a name="ln559">  params-&gt;self = self;</a>
<a name="ln560">  params-&gt;group = group;</a>
<a name="ln561">  g_main_context_invoke(NULL, _lib_modulegroups_set_gui_thread, params);</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564">/* this is a proxy function so it might be called from another thread */</a>
<a name="ln565">static void _lib_modulegroups_search_text_focus(dt_lib_module_t *self)</a>
<a name="ln566">{</a>
<a name="ln567">  _set_gui_thread_t *params = (_set_gui_thread_t *)malloc(sizeof(_set_gui_thread_t));</a>
<a name="ln568">  if(!params) return;</a>
<a name="ln569">  params-&gt;self = self;</a>
<a name="ln570">  params-&gt;group = 0;</a>
<a name="ln571">  g_main_context_invoke(NULL, _lib_modulegroups_search_text_focus_gui_thread, params);</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574">static void _lib_modulegroups_switch_group(dt_lib_module_t *self, dt_iop_module_t *module)</a>
<a name="ln575">{</a>
<a name="ln576">  dt_lib_modulegroups_t *d = (dt_lib_modulegroups_t *)self-&gt;data;</a>
<a name="ln577"> </a>
<a name="ln578">  /* do nothing if module is member of current group */</a>
<a name="ln579">  if(_lib_modulegroups_test_internal(self, d-&gt;current, dt_iop_get_group(module))) return;</a>
<a name="ln580"> </a>
<a name="ln581">  /* lets find the group which is not favorite/active pipe */</a>
<a name="ln582">  for(int k = DT_MODULEGROUP_BASIC; k &lt; DT_MODULEGROUP_SIZE; k++)</a>
<a name="ln583">  {</a>
<a name="ln584">    if(_lib_modulegroups_test(self, k, dt_iop_get_group(module)))</a>
<a name="ln585">    {</a>
<a name="ln586">      _lib_modulegroups_set(self, k);</a>
<a name="ln587">      return;</a>
<a name="ln588">    }</a>
<a name="ln589">  }</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">static uint32_t _lib_modulegroups_get(dt_lib_module_t *self)</a>
<a name="ln593">{</a>
<a name="ln594">  dt_lib_modulegroups_t *d = (dt_lib_modulegroups_t *)self-&gt;data;</a>
<a name="ln595"> </a>
<a name="ln596">  for(int k = 0; k &lt; DT_MODULEGROUP_SIZE; k++)</a>
<a name="ln597">  {</a>
<a name="ln598">    if (d-&gt;current == _iop_get_group_order(k, k))</a>
<a name="ln599">      return k;</a>
<a name="ln600">  }</a>
<a name="ln601">  return DT_MODULEGROUP_FAVORITES;</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">#undef PADDING</a>
<a name="ln605">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln606">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln607">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="143"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'show_text_entry' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
