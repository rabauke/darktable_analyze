
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/debug.h&quot;</a>
<a name="ln22">#include &quot;common/image_cache.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;develop/develop.h&quot;</a>
<a name="ln26">#include &quot;gui/gtk.h&quot;</a>
<a name="ln27">#include &quot;libs/lib.h&quot;</a>
<a name="ln28">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">DT_MODULE(1)</a>
<a name="ln31"> </a>
<a name="ln32">#define DT_NAVIGATION_INSET 5</a>
<a name="ln33"> </a>
<a name="ln34">typedef struct dt_lib_navigation_t</a>
<a name="ln35">{</a>
<a name="ln36">  int dragging;</a>
<a name="ln37">  int zoom_w, zoom_h;</a>
<a name="ln38">  unsigned char* buffer;</a>
<a name="ln39">  int wd;</a>
<a name="ln40">  int ht;</a>
<a name="ln41">  int timestamp;</a>
<a name="ln42">} dt_lib_navigation_t;</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">/* expose function for navigation module */</a>
<a name="ln46">static gboolean _lib_navigation_draw_callback(GtkWidget *widget, cairo_t *crf, gpointer user_data);</a>
<a name="ln47">/* motion notify callback handler*/</a>
<a name="ln48">static gboolean _lib_navigation_motion_notify_callback(GtkWidget *widget, GdkEventMotion *event,</a>
<a name="ln49">                                                       gpointer user_data);</a>
<a name="ln50">/* button press callback */</a>
<a name="ln51">static gboolean _lib_navigation_button_press_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln52">                                                      gpointer user_data);</a>
<a name="ln53">/* button release callback */</a>
<a name="ln54">static gboolean _lib_navigation_button_release_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln55">                                                        gpointer user_data);</a>
<a name="ln56">/* leave notify callback */</a>
<a name="ln57">static gboolean _lib_navigation_leave_notify_callback(GtkWidget *widget, GdkEventCrossing *event,</a>
<a name="ln58">                                                      gpointer user_data);</a>
<a name="ln59"> </a>
<a name="ln60">/* helper function for position set */</a>
<a name="ln61">static void _lib_navigation_set_position(struct dt_lib_module_t *self, double x, double y, int wd, int ht);</a>
<a name="ln62"> </a>
<a name="ln63">const char *name(dt_lib_module_t *self)</a>
<a name="ln64">{</a>
<a name="ln65">  return _(&quot;navigation&quot;);</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">const char **views(dt_lib_module_t *self)</a>
<a name="ln69">{</a>
<a name="ln70">  static const char *v[] = {&quot;darkroom&quot;, NULL};</a>
<a name="ln71">  return v;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln75">{</a>
<a name="ln76">  return DT_UI_CONTAINER_PANEL_LEFT_TOP;</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">int expandable(dt_lib_module_t *self)</a>
<a name="ln80">{</a>
<a name="ln81">  return 0;</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84">int position()</a>
<a name="ln85">{</a>
<a name="ln86">  return 1001;</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89"> </a>
<a name="ln90">static void _lib_navigation_control_redraw_callback(gpointer instance, gpointer user_data)</a>
<a name="ln91">{</a>
<a name="ln92">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln93">  dt_control_queue_redraw_widget(self-&gt;widget);</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">void gui_init(dt_lib_module_t *self)</a>
<a name="ln97">{</a>
<a name="ln98">  /* initialize ui widgets */</a>
<a name="ln99">  dt_lib_navigation_t *d = (dt_lib_navigation_t *)g_malloc0(sizeof(dt_lib_navigation_t));</a>
<a name="ln100">  self-&gt;data = (void *)d;</a>
<a name="ln101"> </a>
<a name="ln102">  d-&gt;buffer = NULL;</a>
<a name="ln103">  d-&gt;wd = -1;</a>
<a name="ln104">  d-&gt;ht = -1;</a>
<a name="ln105">  d-&gt;timestamp = -1;</a>
<a name="ln106"> </a>
<a name="ln107">  /* create drawingarea */</a>
<a name="ln108">  self-&gt;widget = gtk_drawing_area_new();</a>
<a name="ln109">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln110">  gtk_widget_set_events(self-&gt;widget, GDK_EXPOSURE_MASK | GDK_POINTER_MOTION_MASK</a>
<a name="ln111">                                      | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK</a>
<a name="ln112">                                      | GDK_BUTTON_RELEASE_MASK | GDK_STRUCTURE_MASK);</a>
<a name="ln113"> </a>
<a name="ln114">  /* connect callbacks */</a>
<a name="ln115">  gtk_widget_set_app_paintable(self-&gt;widget, TRUE);</a>
<a name="ln116">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;draw&quot;, G_CALLBACK(_lib_navigation_draw_callback), self);</a>
<a name="ln117">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;button-press-event&quot;,</a>
<a name="ln118">                   G_CALLBACK(_lib_navigation_button_press_callback), self);</a>
<a name="ln119">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;button-release-event&quot;,</a>
<a name="ln120">                   G_CALLBACK(_lib_navigation_button_release_callback), self);</a>
<a name="ln121">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;motion-notify-event&quot;,</a>
<a name="ln122">                   G_CALLBACK(_lib_navigation_motion_notify_callback), self);</a>
<a name="ln123">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;leave-notify-event&quot;,</a>
<a name="ln124">                   G_CALLBACK(_lib_navigation_leave_notify_callback), self);</a>
<a name="ln125"> </a>
<a name="ln126">  /* set size of navigation draw area */</a>
<a name="ln127">  int panel_width = dt_conf_get_int(&quot;panel_width&quot;);</a>
<a name="ln128">  gtk_widget_set_size_request(self-&gt;widget, -1, panel_width * .5);</a>
<a name="ln129"> </a>
<a name="ln130">  /* connect a redraw callback to control draw all and preview pipe finish signals */</a>
<a name="ln131">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_UI_PIPE_FINISHED,</a>
<a name="ln132">                            G_CALLBACK(_lib_navigation_control_redraw_callback), self);</a>
<a name="ln133">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_PREVIEW_PIPE_FINISHED,</a>
<a name="ln134">                            G_CALLBACK(_lib_navigation_control_redraw_callback), self);</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln138">{</a>
<a name="ln139">  /* disconnect from signal */</a>
<a name="ln140">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_navigation_control_redraw_callback), self);</a>
<a name="ln141"> </a>
<a name="ln142">  dt_lib_navigation_t *d = self-&gt;data;</a>
<a name="ln143">  g_free(d-&gt;buffer);</a>
<a name="ln144"> </a>
<a name="ln145">  g_free(self-&gt;data);</a>
<a name="ln146">  self-&gt;data = NULL;</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">static gboolean _lib_navigation_draw_callback(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln152">{</a>
<a name="ln153">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln154">  dt_lib_navigation_t *d = (dt_lib_navigation_t *)self-&gt;data;</a>
<a name="ln155"> </a>
<a name="ln156">  const int inset = DT_NAVIGATION_INSET;</a>
<a name="ln157">  GtkAllocation allocation;</a>
<a name="ln158">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln159">  int width = allocation.width, height = allocation.height;</a>
<a name="ln160"> </a>
<a name="ln161">  dt_develop_t *dev = darktable.develop;</a>
<a name="ln162"> </a>
<a name="ln163">  /* double buffering of image data: only take new data if valid */</a>
<a name="ln164">  if(dev-&gt;preview_pipe-&gt;backbuf &amp;&amp; dev-&gt;preview_status == DT_DEV_PIXELPIPE_VALID)</a>
<a name="ln165">  {</a>
<a name="ln166">    /* re-allocate in case of changed image dimensions */</a>
<a name="ln167">    if(d-&gt;buffer == NULL || dev-&gt;preview_pipe-&gt;backbuf_width != d-&gt;wd || dev-&gt;preview_pipe-&gt;backbuf_height != d-&gt;ht)</a>
<a name="ln168">    {</a>
<a name="ln169">      g_free(d-&gt;buffer);</a>
<a name="ln170">      d-&gt;wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln171">      d-&gt;ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln172">      d-&gt;buffer = g_malloc0((size_t)d-&gt;wd * d-&gt;ht * 4 * sizeof(unsigned char));</a>
<a name="ln173">    }</a>
<a name="ln174"> </a>
<a name="ln175">    /* update buffer if new data is available */</a>
<a name="ln176">    if(d-&gt;buffer &amp;&amp; dev-&gt;preview_pipe-&gt;input_timestamp &gt; d-&gt;timestamp)</a>
<a name="ln177">    {</a>
<a name="ln178">      dt_pthread_mutex_t *mutex = &amp;dev-&gt;preview_pipe-&gt;backbuf_mutex;</a>
<a name="ln179">      dt_pthread_mutex_lock(mutex);</a>
<a name="ln180">      memcpy(d-&gt;buffer, dev-&gt;preview_pipe-&gt;backbuf, (size_t)d-&gt;wd * d-&gt;ht * 4 * sizeof(unsigned char));</a>
<a name="ln181">      d-&gt;timestamp = dev-&gt;preview_pipe-&gt;input_timestamp;</a>
<a name="ln182">      dt_pthread_mutex_unlock(mutex);</a>
<a name="ln183">    }</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  /* get the current style */</a>
<a name="ln187">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln188">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln189"> </a>
<a name="ln190">  GtkStyleContext *context = gtk_widget_get_style_context(widget);</a>
<a name="ln191">  gtk_render_background(context, cr, 0, 0, allocation.width, allocation.height);</a>
<a name="ln192"> </a>
<a name="ln193">  width -= 2 * inset;</a>
<a name="ln194">  height -= 2 * inset;</a>
<a name="ln195">  cairo_translate(cr, inset, inset);</a>
<a name="ln196"> </a>
<a name="ln197">  /* draw navigation image if available */</a>
<a name="ln198">  if(d-&gt;buffer)</a>
<a name="ln199">  {</a>
<a name="ln200">    cairo_save(cr);</a>
<a name="ln201">    const int wd = d-&gt;wd;</a>
<a name="ln202">    const int ht = d-&gt;ht;</a>
<a name="ln203">    const float scale = fminf(width / (float)wd, height / (float)ht);</a>
<a name="ln204"> </a>
<a name="ln205">    const int stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, wd);</a>
<a name="ln206">    cairo_surface_t *surface</a>
<a name="ln207">        = cairo_image_surface_create_for_data(d-&gt;buffer, CAIRO_FORMAT_RGB24, wd, ht, stride);</a>
<a name="ln208">    cairo_translate(cr, width / 2.0, height / 2.0f);</a>
<a name="ln209">    cairo_scale(cr, scale, scale);</a>
<a name="ln210">    cairo_translate(cr, -.5f * wd, -.5f * ht);</a>
<a name="ln211"> </a>
<a name="ln212">    // draw shadow around</a>
<a name="ln213">    float alpha = 1.0f;</a>
<a name="ln214">    for(int k = 0; k &lt; 4; k++)</a>
<a name="ln215">    {</a>
<a name="ln216">      cairo_rectangle(cr, -k / scale, -k / scale, wd + 2 * k / scale, ht + 2 * k / scale);</a>
<a name="ln217">      cairo_set_source_rgba(cr, 0, 0, 0, alpha);</a>
<a name="ln218">      alpha *= 0.6f;</a>
<a name="ln219">      cairo_fill(cr);</a>
<a name="ln220">    }</a>
<a name="ln221"> </a>
<a name="ln222">    cairo_rectangle(cr, 0, 0, wd - 2, ht - 1);</a>
<a name="ln223">    cairo_set_source_surface(cr, surface, 0, 0);</a>
<a name="ln224">    cairo_pattern_set_filter(cairo_get_source(cr), CAIRO_FILTER_FAST);</a>
<a name="ln225">    cairo_fill(cr);</a>
<a name="ln226">    cairo_surface_destroy(surface);</a>
<a name="ln227"> </a>
<a name="ln228">    // draw box where we are</a>
<a name="ln229">    dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln230">    int closeup = dt_control_get_dev_closeup();</a>
<a name="ln231">    float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln232">    float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln233">    const float min_scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_FIT, 1&lt;&lt;closeup, 0);</a>
<a name="ln234">    const float cur_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln235">    // avoid numerical instability for small resolutions:</a>
<a name="ln236">    double h, w;</a>
<a name="ln237">    if(cur_scale &gt; min_scale)</a>
<a name="ln238">    {</a>
<a name="ln239">      float boxw = 1, boxh = 1;</a>
<a name="ln240">      dt_dev_check_zoom_bounds(darktable.develop, &amp;zoom_x, &amp;zoom_y, zoom, closeup, &amp;boxw, &amp;boxh);</a>
<a name="ln241">      cairo_translate(cr, wd * (.5f + zoom_x), ht * (.5f + zoom_y));</a>
<a name="ln242">      cairo_set_source_rgb(cr, 0., 0., 0.);</a>
<a name="ln243">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.f / scale));</a>
<a name="ln244">      boxw *= wd;</a>
<a name="ln245">      boxh *= ht;</a>
<a name="ln246">      cairo_rectangle(cr, -boxw / 2 - 1, -boxh / 2 - 1, boxw + 2, boxh + 2);</a>
<a name="ln247">      cairo_stroke(cr);</a>
<a name="ln248">      cairo_set_source_rgb(cr, 1., 1., 1.);</a>
<a name="ln249">      cairo_rectangle(cr, -boxw / 2, -boxh / 2, boxw, boxh);</a>
<a name="ln250">      cairo_stroke(cr);</a>
<a name="ln251">    }</a>
<a name="ln252">    cairo_restore(cr);</a>
<a name="ln253">    if(fabsf(cur_scale - min_scale) &gt; 0.001f)</a>
<a name="ln254">    {</a>
<a name="ln255">      /* Zoom % */</a>
<a name="ln256">      PangoLayout *layout;</a>
<a name="ln257">      PangoRectangle ink;</a>
<a name="ln258">      PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln259">      pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln260">      layout = pango_cairo_create_layout(cr);</a>
<a name="ln261">      const float fontsize = DT_PIXEL_APPLY_DPI(11);</a>
<a name="ln262">      pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);</a>
<a name="ln263">      pango_layout_set_font_description(layout, desc);</a>
<a name="ln264">      cairo_translate(cr, 0, height);</a>
<a name="ln265">      cairo_set_source_rgba(cr, 1., 1., 1., 0.5);</a>
<a name="ln266">      cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);</a>
<a name="ln267"> </a>
<a name="ln268">      char zoomline[5];</a>
<a name="ln269">      snprintf(zoomline, sizeof(zoomline), &quot;%.0f%%&quot;, cur_scale * 100);</a>
<a name="ln270"> </a>
<a name="ln271">      pango_layout_set_text(layout, zoomline, -1);</a>
<a name="ln272">      pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln273">      h = d-&gt;zoom_h = ink.height;</a>
<a name="ln274">      w = d-&gt;zoom_w = ink.width;</a>
<a name="ln275"> </a>
<a name="ln276">      cairo_move_to(cr, width - w - h * 1.1 - ink.x, - fontsize);</a>
<a name="ln277"> </a>
<a name="ln278">      cairo_save(cr);</a>
<a name="ln279">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0));</a>
<a name="ln280"> </a>
<a name="ln281">      GdkRGBA *color;</a>
<a name="ln282">      gtk_style_context_get(context, gtk_widget_get_state_flags(widget), &quot;background-color&quot;, &amp;color, NULL);</a>
<a name="ln283"> </a>
<a name="ln284">      gdk_cairo_set_source_rgba(cr, color);</a>
<a name="ln285">      pango_cairo_layout_path(cr, layout);</a>
<a name="ln286">      cairo_stroke_preserve(cr);</a>
<a name="ln287">      cairo_set_source_rgb(cr, 0.6, 0.6, 0.6);</a>
<a name="ln288">      cairo_fill(cr);</a>
<a name="ln289">      cairo_restore(cr);</a>
<a name="ln290"> </a>
<a name="ln291">      gdk_rgba_free(color);</a>
<a name="ln292">      pango_font_description_free(desc);</a>
<a name="ln293">      g_object_unref(layout);</a>
<a name="ln294"> </a>
<a name="ln295">    }</a>
<a name="ln296">    else</a>
<a name="ln297">    {</a>
<a name="ln298">      // draw the zoom-to-fit icon</a>
<a name="ln299">      cairo_translate(cr, 0, height);</a>
<a name="ln300">      cairo_set_source_rgb(cr, 0.6, 0.6, 0.6);</a>
<a name="ln301"> </a>
<a name="ln302">      static int font_height = -1;</a>
<a name="ln303">      if(font_height == -1)</a>
<a name="ln304">      {</a>
<a name="ln305">        PangoLayout *layout;</a>
<a name="ln306">        PangoRectangle ink;</a>
<a name="ln307">        PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln308">        pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln309">        layout = pango_cairo_create_layout(cr);</a>
<a name="ln310">        pango_font_description_set_absolute_size(desc, DT_PIXEL_APPLY_DPI(11) * PANGO_SCALE);</a>
<a name="ln311">        pango_layout_set_font_description(layout, desc);</a>
<a name="ln312">        pango_layout_set_text(layout, &quot;100%&quot;, -1); // dummy text, just to get the height</a>
<a name="ln313">        pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln314">        font_height = ink.height;</a>
<a name="ln315">        pango_font_description_free(desc);</a>
<a name="ln316">        g_object_unref(layout);</a>
<a name="ln317">      }</a>
<a name="ln318"> </a>
<a name="ln319">      h = d-&gt;zoom_h = font_height;</a>
<a name="ln320">      w = h * 1.5;</a>
<a name="ln321">      float sp = h * 0.6;</a>
<a name="ln322">      d-&gt;zoom_w = w + sp;</a>
<a name="ln323"> </a>
<a name="ln324">      cairo_move_to(cr, width - w - h - sp, -1.0 * h);</a>
<a name="ln325">      cairo_rectangle(cr, width - w - h - sp, -1.0 * h, w, h);</a>
<a name="ln326">      cairo_set_source_rgb(cr, 0.2, 0.2, 0.2);</a>
<a name="ln327">      cairo_fill(cr);</a>
<a name="ln328"> </a>
<a name="ln329">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0));</a>
<a name="ln330"> </a>
<a name="ln331">      cairo_set_source_rgb(cr, 0.6, 0.6, 0.6);</a>
<a name="ln332">      cairo_move_to(cr, width - w * 0.8 - h - sp, -1.0 * h);</a>
<a name="ln333">      cairo_line_to(cr, width - w - h - sp, -1.0 * h);</a>
<a name="ln334">      cairo_line_to(cr, width - w - h - sp, -0.7 * h);</a>
<a name="ln335">      cairo_stroke(cr);</a>
<a name="ln336">      cairo_move_to(cr, width - w - h - sp, -0.3 * h);</a>
<a name="ln337">      cairo_line_to(cr, width - w - h - sp, 0);</a>
<a name="ln338">      cairo_line_to(cr, width - w * 0.8 - h - sp, 0);</a>
<a name="ln339">      cairo_stroke(cr);</a>
<a name="ln340">      cairo_move_to(cr, width - w * 0.2 - h - sp, 0);</a>
<a name="ln341">      cairo_line_to(cr, width - h - sp, 0);</a>
<a name="ln342">      cairo_line_to(cr, width - h - sp, -0.3 * h);</a>
<a name="ln343">      cairo_stroke(cr);</a>
<a name="ln344">      cairo_move_to(cr, width - h - sp, -0.7 * h);</a>
<a name="ln345">      cairo_line_to(cr, width - h - sp, -1.0 * h);</a>
<a name="ln346">      cairo_line_to(cr, width - w * 0.2 - h - sp, -1.0 * h);</a>
<a name="ln347">      cairo_stroke(cr);</a>
<a name="ln348">    }</a>
<a name="ln349"> </a>
<a name="ln350">    cairo_move_to(cr, width - 0.95 * h, -0.9 * h);</a>
<a name="ln351">    cairo_line_to(cr, width - 0.05 * h, -0.9 * h);</a>
<a name="ln352">    cairo_line_to(cr, width - 0.5 * h, -0.1 * h);</a>
<a name="ln353">    cairo_fill(cr);</a>
<a name="ln354">  }</a>
<a name="ln355"> </a>
<a name="ln356">  /* blit memsurface into widget */</a>
<a name="ln357">  cairo_destroy(cr);</a>
<a name="ln358">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln359">  cairo_paint(crf);</a>
<a name="ln360">  cairo_surface_destroy(cst);</a>
<a name="ln361"> </a>
<a name="ln362">  return TRUE;</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">void _lib_navigation_set_position(dt_lib_module_t *self, double x, double y, int wd, int ht)</a>
<a name="ln366">{</a>
<a name="ln367">  dt_lib_navigation_t *d = (dt_lib_navigation_t *)self-&gt;data;</a>
<a name="ln368"> </a>
<a name="ln369">  dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln370">  int closeup = dt_control_get_dev_closeup();</a>
<a name="ln371">  float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln372">  float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln373"> </a>
<a name="ln374">  if(d-&gt;dragging &amp;&amp; zoom != DT_ZOOM_FIT)</a>
<a name="ln375">  {</a>
<a name="ln376">    const int inset = DT_NAVIGATION_INSET;</a>
<a name="ln377">    const float width = wd - 2 * inset, height = ht - 2 * inset;</a>
<a name="ln378">    const dt_develop_t *dev = darktable.develop;</a>
<a name="ln379">    int iwd, iht;</a>
<a name="ln380">    dt_dev_get_processed_size(dev, &amp;iwd, &amp;iht);</a>
<a name="ln381">    zoom_x = fmaxf(</a>
<a name="ln382">        -.5,</a>
<a name="ln383">        fminf(((x - inset) / width - .5f) / (iwd * fminf(wd / (float)iwd, ht / (float)iht) / (float)wd), .5));</a>
<a name="ln384">    zoom_y = fmaxf(</a>
<a name="ln385">        -.5, fminf(((y - inset) / height - .5f) / (iht * fminf(wd / (float)iwd, ht / (float)iht) / (float)ht),</a>
<a name="ln386">                   .5));</a>
<a name="ln387">    dt_dev_check_zoom_bounds(darktable.develop, &amp;zoom_x, &amp;zoom_y, zoom, closeup, NULL, NULL);</a>
<a name="ln388">    dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln389">    dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln390"> </a>
<a name="ln391">    /* redraw myself */</a>
<a name="ln392">    gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln393"> </a>
<a name="ln394">    /* redraw pipe */</a>
<a name="ln395">    dt_dev_invalidate(darktable.develop);</a>
<a name="ln396">    dt_control_queue_redraw_center();</a>
<a name="ln397">  }</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">static gboolean _lib_navigation_motion_notify_callback(GtkWidget *widget, GdkEventMotion *event,</a>
<a name="ln401">                                                       gpointer user_data)</a>
<a name="ln402">{</a>
<a name="ln403">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln404">  GtkAllocation allocation;</a>
<a name="ln405">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln406">  _lib_navigation_set_position(self, event-&gt;x, event-&gt;y, allocation.width, allocation.height);</a>
<a name="ln407">  gint x, y; // notify gtk for motion_hint.</a>
<a name="ln408">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln409">  gdk_window_get_device_position(event-&gt;window,</a>
<a name="ln410">      gdk_seat_get_pointer(gdk_display_get_default_seat(</a>
<a name="ln411">          gdk_window_get_display(event-&gt;window))),</a>
<a name="ln412">      &amp;x, &amp;y, 0);</a>
<a name="ln413">#else</a>
<a name="ln414">  gdk_window_get_device_position(event-&gt;window,</a>
<a name="ln415">                                 gdk_device_manager_get_client_pointer(</a>
<a name="ln416">                                     gdk_display_get_device_manager(gdk_window_get_display(event-&gt;window))),</a>
<a name="ln417">                                 &amp;x, &amp;y, NULL);</a>
<a name="ln418">#endif</a>
<a name="ln419">  return TRUE;</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">static void _zoom_preset_change(uint64_t val)</a>
<a name="ln423">{</a>
<a name="ln424">  // dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln425">  dt_develop_t *dev = darktable.develop;</a>
<a name="ln426">  if(!dev) return;</a>
<a name="ln427">  dt_dev_zoom_t zoom;</a>
<a name="ln428">  int closeup, procw, proch;</a>
<a name="ln429">  float zoom_x, zoom_y;</a>
<a name="ln430">  zoom = dt_control_get_dev_zoom();</a>
<a name="ln431">  closeup = dt_control_get_dev_closeup();</a>
<a name="ln432">  zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln433">  zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln434">  dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln435">  float scale = 0;</a>
<a name="ln436">  closeup = 0;</a>
<a name="ln437">  if(val == 0u)</a>
<a name="ln438">  {</a>
<a name="ln439">    scale = 0.5 * dt_dev_get_zoom_scale(dev, DT_ZOOM_FIT, 1.0, 0);</a>
<a name="ln440">    zoom = DT_ZOOM_FREE;</a>
<a name="ln441">  }</a>
<a name="ln442">  else if(val == 1u)</a>
<a name="ln443">  {</a>
<a name="ln444">    zoom = DT_ZOOM_FIT;</a>
<a name="ln445">    scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_FIT, 1.0, 0);</a>
<a name="ln446">  }</a>
<a name="ln447">  else if(val == 2u)</a>
<a name="ln448">  {</a>
<a name="ln449">    scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_1, 1.0, 0);</a>
<a name="ln450">    zoom = DT_ZOOM_1;</a>
<a name="ln451">  }</a>
<a name="ln452">  else if(val == 3u)</a>
<a name="ln453">  {</a>
<a name="ln454">    scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_1, 1.0, 0);</a>
<a name="ln455">    zoom = DT_ZOOM_1;</a>
<a name="ln456">    closeup = 1;</a>
<a name="ln457">  }</a>
<a name="ln458">  else if(val == 4u)</a>
<a name="ln459">  {</a>
<a name="ln460">    scale = 0.5f;</a>
<a name="ln461">    zoom = DT_ZOOM_FREE;</a>
<a name="ln462">  }</a>
<a name="ln463">  else if(val == 5u)</a>
<a name="ln464">  {</a>
<a name="ln465">    scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_1, 1.0, 0);</a>
<a name="ln466">    zoom = DT_ZOOM_1;</a>
<a name="ln467">    closeup = 4;</a>
<a name="ln468">  }</a>
<a name="ln469">  else if(val == 6u)</a>
<a name="ln470">  {</a>
<a name="ln471">    scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_1, 1.0, 0);</a>
<a name="ln472">    zoom = DT_ZOOM_1;</a>
<a name="ln473">    closeup = 2;</a>
<a name="ln474">  }</a>
<a name="ln475">  else if(val == 7u)</a>
<a name="ln476">  {</a>
<a name="ln477">    scale = dt_dev_get_zoom_scale(dev, DT_ZOOM_1, 1.0, 0);</a>
<a name="ln478">    zoom = DT_ZOOM_1;</a>
<a name="ln479">    closeup = 3;</a>
<a name="ln480">  }</a>
<a name="ln481"> </a>
<a name="ln482">  // zoom_x = (1.0/(scale*(1&lt;&lt;closeup)))*(zoom_x - .5f*dev-&gt;width )/procw;</a>
<a name="ln483">  // zoom_y = (1.0/(scale*(1&lt;&lt;closeup)))*(zoom_y - .5f*dev-&gt;height)/proch;</a>
<a name="ln484"> </a>
<a name="ln485">  dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, zoom, closeup, NULL, NULL);</a>
<a name="ln486">  dt_control_set_dev_zoom_scale(scale);</a>
<a name="ln487">  dt_control_set_dev_zoom(zoom);</a>
<a name="ln488">  dt_control_set_dev_closeup(closeup);</a>
<a name="ln489">  dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln490">  dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln491">  dt_dev_invalidate(dev);</a>
<a name="ln492">  dt_control_queue_redraw();</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495">static void _zoom_preset_callback(GtkButton *button, gpointer user_data)</a>
<a name="ln496">{</a>
<a name="ln497">  _zoom_preset_change((uint64_t)user_data);</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500">static gboolean _lib_navigation_button_press_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln501">                                                      gpointer user_data)</a>
<a name="ln502">{</a>
<a name="ln503">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln504">  dt_lib_navigation_t *d = (dt_lib_navigation_t *)self-&gt;data;</a>
<a name="ln505"> </a>
<a name="ln506">  GtkAllocation allocation;</a>
<a name="ln507">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln508">  int w = allocation.width;</a>
<a name="ln509">  int h = allocation.height;</a>
<a name="ln510">  if(event-&gt;x &gt;= w - DT_NAVIGATION_INSET - d-&gt;zoom_h - d-&gt;zoom_w</a>
<a name="ln511">     &amp;&amp; event-&gt;y &gt;= h - DT_NAVIGATION_INSET - d-&gt;zoom_h)</a>
<a name="ln512">  {</a>
<a name="ln513">    // we show the zoom menu</a>
<a name="ln514">    GtkMenuShell *menu = GTK_MENU_SHELL(gtk_menu_new());</a>
<a name="ln515">    GtkWidget *item;</a>
<a name="ln516"> </a>
<a name="ln517">    item = gtk_menu_item_new_with_label(_(&quot;small&quot;));</a>
<a name="ln518">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)0);</a>
<a name="ln519">    gtk_menu_shell_append(menu, item);</a>
<a name="ln520"> </a>
<a name="ln521">    item = gtk_menu_item_new_with_label(_(&quot;fit to screen&quot;));</a>
<a name="ln522">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)1);</a>
<a name="ln523">    gtk_menu_shell_append(menu, item);</a>
<a name="ln524"> </a>
<a name="ln525">    item = gtk_menu_item_new_with_label(_(&quot;50%&quot;));</a>
<a name="ln526">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)4);</a>
<a name="ln527">    gtk_menu_shell_append(menu, item);</a>
<a name="ln528"> </a>
<a name="ln529">    item = gtk_menu_item_new_with_label(_(&quot;100%&quot;));</a>
<a name="ln530">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)2);</a>
<a name="ln531">    gtk_menu_shell_append(menu, item);</a>
<a name="ln532"> </a>
<a name="ln533">    item = gtk_menu_item_new_with_label(_(&quot;200%&quot;));</a>
<a name="ln534">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)3);</a>
<a name="ln535">    gtk_menu_shell_append(menu, item);</a>
<a name="ln536"> </a>
<a name="ln537">    item = gtk_menu_item_new_with_label(_(&quot;400%&quot;));</a>
<a name="ln538">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)6);</a>
<a name="ln539">    gtk_menu_shell_append(menu, item);</a>
<a name="ln540"> </a>
<a name="ln541">    item = gtk_menu_item_new_with_label(_(&quot;800%&quot;));</a>
<a name="ln542">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)7);</a>
<a name="ln543">    gtk_menu_shell_append(menu, item);</a>
<a name="ln544"> </a>
<a name="ln545">    item = gtk_menu_item_new_with_label(_(&quot;1600%&quot;));</a>
<a name="ln546">    g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_zoom_preset_callback), (gpointer)5);</a>
<a name="ln547">    gtk_menu_shell_append(menu, item);</a>
<a name="ln548"> </a>
<a name="ln549">    gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln550"> </a>
<a name="ln551">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln552">    gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln553">#else</a>
<a name="ln554">    gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, 0, gtk_get_current_event_time());</a>
<a name="ln555">#endif</a>
<a name="ln556"> </a>
<a name="ln557">    return TRUE;</a>
<a name="ln558">  }</a>
<a name="ln559">  d-&gt;dragging = 1;</a>
<a name="ln560">  _lib_navigation_set_position(self, event-&gt;x, event-&gt;y, w, h);</a>
<a name="ln561">  return TRUE;</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564">static gboolean _lib_navigation_button_release_callback(GtkWidget *widget, GdkEventButton *event,</a>
<a name="ln565">                                                        gpointer user_data)</a>
<a name="ln566">{</a>
<a name="ln567">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln568">  dt_lib_navigation_t *d = (dt_lib_navigation_t *)self-&gt;data;</a>
<a name="ln569">  d-&gt;dragging = 0;</a>
<a name="ln570"> </a>
<a name="ln571">  return TRUE;</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574">static gboolean _lib_navigation_leave_notify_callback(GtkWidget *widget, GdkEventCrossing *event,</a>
<a name="ln575">                                                      gpointer user_data)</a>
<a name="ln576">{</a>
<a name="ln577">  return TRUE;</a>
<a name="ln578">}</a>
<a name="ln579">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln580">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln581">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="436"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'closeup' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 431, 436.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
