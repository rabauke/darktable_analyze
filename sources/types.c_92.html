
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">   This file is part of darktable,</a>
<a name="ln3">   copyright (c) 2012 Jeremy Rosen</a>
<a name="ln4"> </a>
<a name="ln5">   darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">   it under the terms of the GNU General Public License as published by</a>
<a name="ln7">   the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">   (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">   darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">   but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">   GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">   You should have received a copy of the GNU General Public License</a>
<a name="ln16">   along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17"> */</a>
<a name="ln18">#include &quot;lua/types.h&quot;</a>
<a name="ln19">#include &quot;common/darktable.h&quot;</a>
<a name="ln20">#include &quot;common/file_location.h&quot;</a>
<a name="ln21">#include &quot;control/control.h&quot;</a>
<a name="ln22">#include &quot;lua/call.h&quot;</a>
<a name="ln23">#include &lt;math.h&gt;</a>
<a name="ln24">#include &lt;stdarg.h&gt;</a>
<a name="ln25">#include &lt;string.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">/*************/</a>
<a name="ln28">/*   TYPES   */</a>
<a name="ln29">/*************/</a>
<a name="ln30"> </a>
<a name="ln31">static void to_char_array(lua_State *L, luaA_Type type_id, void *c_out, int index, int size)</a>
<a name="ln32">{</a>
<a name="ln33">  size_t tgt_size;</a>
<a name="ln34">  const char *value = luaL_checklstring(L, index, &amp;tgt_size);</a>
<a name="ln35">  if(tgt_size &gt; size)</a>
<a name="ln36">  {</a>
<a name="ln37">    luaL_error(L, &quot;string '%s' too long (max is %d)&quot;, value, size);</a>
<a name="ln38">  }</a>
<a name="ln39">  strncpy(c_out, value, size);</a>
<a name="ln40">}</a>
<a name="ln41"> </a>
<a name="ln42">static int push_char_array(lua_State *L, luaA_Type type_id, const void *c_in)</a>
<a name="ln43">{</a>
<a name="ln44">  lua_pushstring(L, c_in);</a>
<a name="ln45">  return 1;</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48">static void to_char20(lua_State *L, luaA_Type type_id, void *c_out, int index)</a>
<a name="ln49">{</a>
<a name="ln50">  to_char_array(L, type_id, c_out, index, 20);</a>
<a name="ln51">}</a>
<a name="ln52">static void to_char32(lua_State *L, luaA_Type type_id, void *c_out, int index)</a>
<a name="ln53">{</a>
<a name="ln54">  to_char_array(L, type_id, c_out, index, 32);</a>
<a name="ln55">}</a>
<a name="ln56">static void to_char52(lua_State *L, luaA_Type type_id, void *c_out, int index)</a>
<a name="ln57">{</a>
<a name="ln58">  to_char_array(L, type_id, c_out, index, 52);</a>
<a name="ln59">}</a>
<a name="ln60">static void to_char64(lua_State *L, luaA_Type type_id, void *c_out, int index)</a>
<a name="ln61">{</a>
<a name="ln62">  to_char_array(L, type_id, c_out, index, 64);</a>
<a name="ln63">}</a>
<a name="ln64">static void to_char128(lua_State *L, luaA_Type type_id, void *c_out, int index)</a>
<a name="ln65">{</a>
<a name="ln66">  to_char_array(L, type_id, c_out, index, 128);</a>
<a name="ln67">}</a>
<a name="ln68">static void to_char256(lua_State *L, luaA_Type type_id, void *c_out, int index)</a>
<a name="ln69">{</a>
<a name="ln70">  to_char_array(L, type_id, c_out, index, 256);</a>
<a name="ln71">}</a>
<a name="ln72">static void to_char512(lua_State *L, luaA_Type type_id, void *c_out, int index)</a>
<a name="ln73">{</a>
<a name="ln74">  to_char_array(L, type_id, c_out, index, 512);</a>
<a name="ln75">}</a>
<a name="ln76">static void to_char1024(lua_State *L, luaA_Type type_id, void *c_out, int index)</a>
<a name="ln77">{</a>
<a name="ln78">  to_char_array(L, type_id, c_out, index, 1024);</a>
<a name="ln79">}</a>
<a name="ln80">static void to_charfilename_length(lua_State *L, luaA_Type type_id, void *c_out, int index)</a>
<a name="ln81">{</a>
<a name="ln82">  to_char_array(L, type_id, c_out, index, DT_MAX_FILENAME_LEN);</a>
<a name="ln83">}</a>
<a name="ln84">static void to_charpath_length(lua_State *L, luaA_Type type_id, void *c_out, int index)</a>
<a name="ln85">{</a>
<a name="ln86">  to_char_array(L, type_id, c_out, index, PATH_MAX);</a>
<a name="ln87">}</a>
<a name="ln88">static int push_protected_double(lua_State *L, luaA_Type type_id, const void *c_in)</a>
<a name="ln89">{</a>
<a name="ln90">  double value = *(double *)c_in;</a>
<a name="ln91">  if(!isnormal(value))</a>
<a name="ln92">  {</a>
<a name="ln93">    lua_pushnil(L);</a>
<a name="ln94">  }</a>
<a name="ln95">  else</a>
<a name="ln96">  {</a>
<a name="ln97">    lua_pushnumber(L, value);</a>
<a name="ln98">  }</a>
<a name="ln99">  return 1;</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">static int push_progress_double(lua_State *L, luaA_Type type_id, const void *c_in)</a>
<a name="ln103">{</a>
<a name="ln104">  double value = *(double *)c_in;</a>
<a name="ln105">  if(value &lt; 0.0) value = 0.0;</a>
<a name="ln106">  if(value &gt; 1.0) value = 1.0;</a>
<a name="ln107">  lua_pushnumber(L, value);</a>
<a name="ln108">  return 1;</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">static void to_progress_double(lua_State *L, luaA_Type type_id, void *c_out, int index)</a>
<a name="ln112">{</a>
<a name="ln113">  luaA_to_double(L, type_id, c_out, index);</a>
<a name="ln114">  if(*(double *)c_out &lt; 0.0) *(double *)c_out = 0.0;</a>
<a name="ln115">  if(*(double *)c_out &gt; 1.0) *(double *)c_out = 1.0;</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">/************************************/</a>
<a name="ln119">/* METATBLE CALLBACKS FOR AUTOTYPES */</a>
<a name="ln120">/************************************/</a>
<a name="ln121">static int autotype_next(lua_State *L)</a>
<a name="ln122">{</a>
<a name="ln123">  /* CONVENTION</a>
<a name="ln124">     each block has the following stack on entry and exit</a>
<a name="ln125">    1 : the object</a>
<a name="ln126">    2 : the last entry (&quot;next&quot; convention)</a>
<a name="ln127">    each block should return according to &quot;next&quot; convention on success</a>
<a name="ln128">    each block should leave the key untouched if it doesn't know about it</a>
<a name="ln129">    each block should replace the key with &quot;nil&quot; if the key was the last entry it can handle</a>
<a name="ln130"> </a>
<a name="ln131">    */</a>
<a name="ln132">  // printf(&quot;aaaaa %s %d\n&quot;,__FUNCTION__,__LINE__);</a>
<a name="ln133">  if(luaL_getmetafield(L, 1, &quot;__len&quot;))</a>
<a name="ln134">  {</a>
<a name="ln135">    lua_pushvalue(L, -3);</a>
<a name="ln136">    lua_call(L, 1, 1);</a>
<a name="ln137">    int length = lua_tonumber(L, -1);</a>
<a name="ln138">    lua_pop(L, 1);</a>
<a name="ln139">    int key = 0;</a>
<a name="ln140">    if(lua_isnil(L, -1) &amp;&amp; length &gt; 0)</a>
<a name="ln141">    {</a>
<a name="ln142">      key = 1;</a>
<a name="ln143">    }</a>
<a name="ln144">    else if(lua_isnumber(L, -1) &amp;&amp; lua_tonumber(L, -1) &lt; length)</a>
<a name="ln145">    {</a>
<a name="ln146">      key = lua_tonumber(L, -1) + 1;</a>
<a name="ln147">    }</a>
<a name="ln148">    else if(lua_isnumber(L, -1) &amp;&amp; lua_tonumber(L, -1) == length)</a>
<a name="ln149">    {</a>
<a name="ln150">      // numbers are done, move-on to something else</a>
<a name="ln151">      lua_pop(L, 1);</a>
<a name="ln152">      lua_pushnil(L);</a>
<a name="ln153">    }</a>
<a name="ln154">    if(key)</a>
<a name="ln155">    {</a>
<a name="ln156">      lua_pop(L, 1);</a>
<a name="ln157">      lua_pushinteger(L, key);</a>
<a name="ln158">      lua_pushinteger(L, key);</a>
<a name="ln159">      lua_gettable(L, -3);</a>
<a name="ln160">      return 2;</a>
<a name="ln161">    }</a>
<a name="ln162">  }</a>
<a name="ln163">  // stack at this point : {object,key}</a>
<a name="ln164">  int key_in_get = false;</a>
<a name="ln165">  luaL_getmetafield(L, 1, &quot;__get&quot;);</a>
<a name="ln166">  if(lua_isnil(L, -2))</a>
<a name="ln167">  {</a>
<a name="ln168">    key_in_get = true;</a>
<a name="ln169">  }</a>
<a name="ln170">  else</a>
<a name="ln171">  {</a>
<a name="ln172">    lua_pushvalue(L, -2);</a>
<a name="ln173">    lua_gettable(L, -2);</a>
<a name="ln174">    if(lua_isnil(L, -1))</a>
<a name="ln175">    {</a>
<a name="ln176">      key_in_get = false;</a>
<a name="ln177">      lua_pop(L, 2);</a>
<a name="ln178">    }</a>
<a name="ln179">    else</a>
<a name="ln180">    {</a>
<a name="ln181">      key_in_get = true;</a>
<a name="ln182">      lua_pop(L, 1);</a>
<a name="ln183">    }</a>
<a name="ln184">  }</a>
<a name="ln185">  if(key_in_get)</a>
<a name="ln186">  {</a>
<a name="ln187">    lua_pushvalue(L, -2);</a>
<a name="ln188">    int nil_found = false;</a>
<a name="ln189">    while(!nil_found)</a>
<a name="ln190">    {</a>
<a name="ln191">      if(lua_next(L, -2))</a>
<a name="ln192">      {</a>
<a name="ln193">        // we have a next</a>
<a name="ln194">        lua_pop(L, 1);</a>
<a name="ln195">        lua_pushvalue(L, -4);</a>
<a name="ln196">        lua_pushvalue(L, -2);</a>
<a name="ln197">        // hacky way to avoid a subfunction just to do a pcall around getting a value in a table</a>
<a name="ln198">        luaL_loadstring(L,&quot;args ={...}; return args[1][args[2]]&quot;);</a>
<a name="ln199">        lua_insert(L,-3);</a>
<a name="ln200">        int result = dt_lua_treated_pcall(L,2,1);</a>
<a name="ln201">        if(result == LUA_OK)</a>
<a name="ln202">        {</a>
<a name="ln203">          return 2;</a>
<a name="ln204">        }</a>
<a name="ln205">        else</a>
<a name="ln206">        {</a>
<a name="ln207">          lua_pop(L, 1);</a>
<a name="ln208">          // and loop to find the next possible value</a>
<a name="ln209">        }</a>
<a name="ln210">      }</a>
<a name="ln211">      else</a>
<a name="ln212">      {</a>
<a name="ln213">        // key was the last for __get</a>
<a name="ln214">        lua_pop(L, 2);</a>
<a name="ln215">        lua_pushnil(L);</a>
<a name="ln216">        nil_found = true;</a>
<a name="ln217">      }</a>
<a name="ln218">    }</a>
<a name="ln219">  }</a>
<a name="ln220"> </a>
<a name="ln221">  // stack at this point : {object,key}</a>
<a name="ln222">  if(lua_isnil(L, -1))</a>
<a name="ln223">  {</a>
<a name="ln224">    return 1;</a>
<a name="ln225">  }</a>
<a name="ln226">  else</a>
<a name="ln227">  {</a>
<a name="ln228">    return luaL_error(L, &quot;invalid key to 'next' : %s&quot;, lua_tostring(L, 2));</a>
<a name="ln229">  }</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233"> </a>
<a name="ln234">static int autotype_pairs(lua_State *L)</a>
<a name="ln235">{</a>
<a name="ln236">  luaL_getmetafield(L, 1, &quot;__next&quot;);</a>
<a name="ln237">  lua_pushvalue(L, -2);</a>
<a name="ln238">  lua_pushnil(L); // index set to null for reset</a>
<a name="ln239">  return 3;</a>
<a name="ln240">}</a>
<a name="ln241"> </a>
<a name="ln242">static int autotype_index(lua_State *L)</a>
<a name="ln243">{</a>
<a name="ln244">  luaL_getmetafield(L, 1, &quot;__get&quot;);</a>
<a name="ln245">  int pos_get = lua_gettop(L); // points at __get</a>
<a name="ln246">  lua_pushvalue(L, -2);</a>
<a name="ln247">  lua_gettable(L, -2);</a>
<a name="ln248">  if(lua_isnil(L, -1) &amp;&amp; lua_isnumber(L, -3))</a>
<a name="ln249">  {</a>
<a name="ln250">    if(luaL_getmetafield(L, 1, &quot;__number_index&quot;))</a>
<a name="ln251">    {</a>
<a name="ln252">      lua_remove(L, -2);</a>
<a name="ln253">    }</a>
<a name="ln254">  }</a>
<a name="ln255">  if(lua_isnil(L, -1))</a>
<a name="ln256">  {</a>
<a name="ln257">    lua_pop(L, 1);</a>
<a name="ln258">    luaL_getmetafield(L, -3, &quot;__luaA_TypeName&quot;);</a>
<a name="ln259">    return luaL_error(L, &quot;field \&quot;%s\&quot; not found for type %s\n&quot;, lua_tostring(L, -3), lua_tostring(L, -1));</a>
<a name="ln260">  }</a>
<a name="ln261">  lua_pushvalue(L, -4);</a>
<a name="ln262">  lua_pushvalue(L, -4);</a>
<a name="ln263">  lua_call(L, 2, LUA_MULTRET);</a>
<a name="ln264">  lua_remove(L, pos_get);</a>
<a name="ln265">  return (lua_gettop(L) - pos_get + 1);</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268"> </a>
<a name="ln269">static int autotype_newindex(lua_State *L)</a>
<a name="ln270">{</a>
<a name="ln271">  luaL_getmetafield(L, 1, &quot;__set&quot;);</a>
<a name="ln272">  int pos_set = lua_gettop(L); // points at __get</a>
<a name="ln273">  lua_pushvalue(L, -3);</a>
<a name="ln274">  lua_gettable(L, -2);</a>
<a name="ln275">  if(lua_isnil(L, -1) &amp;&amp; lua_isnumber(L, -4))</a>
<a name="ln276">  {</a>
<a name="ln277">    if(luaL_getmetafield(L, -5, &quot;__number_newindex&quot;))</a>
<a name="ln278">    {</a>
<a name="ln279">      lua_remove(L, -2);</a>
<a name="ln280">    }</a>
<a name="ln281">  }</a>
<a name="ln282">  if(lua_isnil(L, -1))</a>
<a name="ln283">  {</a>
<a name="ln284">    lua_pop(L, 1);</a>
<a name="ln285">    luaL_getmetafield(L, -4, &quot;__luaA_TypeName&quot;);</a>
<a name="ln286">    return luaL_error(L, &quot;field \&quot;%s\&quot; can't be written for type %s\n&quot;, lua_tostring(L, -4),</a>
<a name="ln287">                      lua_tostring(L, -1));</a>
<a name="ln288">  }</a>
<a name="ln289">  lua_pushvalue(L, -5);</a>
<a name="ln290">  lua_pushvalue(L, -5);</a>
<a name="ln291">  lua_pushvalue(L, -5);</a>
<a name="ln292">  lua_call(L, 3, LUA_MULTRET);</a>
<a name="ln293">  lua_remove(L, pos_set);</a>
<a name="ln294">  return (lua_gettop(L) - pos_set + 1);</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297"> </a>
<a name="ln298">static int autotype_tostring(lua_State *L)</a>
<a name="ln299">{</a>
<a name="ln300">  if(luaL_getmetafield(L,1,&quot;__real_tostring&quot;)) {</a>
<a name="ln301">    lua_insert(L,1);</a>
<a name="ln302">    lua_call(L,1,1);</a>
<a name="ln303">    return 1;</a>
<a name="ln304">  } else {</a>
<a name="ln305">    char tmp[256];</a>
<a name="ln306">    luaL_getmetafield(L,1,&quot;__luaA_TypeName&quot;);</a>
<a name="ln307">    snprintf(tmp,sizeof(tmp),&quot;%s (%p)&quot;,lua_tostring(L,-1),lua_topointer(L,1));</a>
<a name="ln308">    lua_pushstring(L,tmp);</a>
<a name="ln309">    return 1;</a>
<a name="ln310">  }</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313">/*************************/</a>
<a name="ln314">/* PUSH AND TO FUNCTIONS */</a>
<a name="ln315">/*************************/</a>
<a name="ln316"> </a>
<a name="ln317">static int full_pushfunc(lua_State *L, luaA_Type type_id, const void *cin)</a>
<a name="ln318">{</a>
<a name="ln319">  size_t type_size = luaA_typesize(L, type_id);</a>
<a name="ln320">  void *udata = lua_newuserdata(L, type_size);</a>
<a name="ln321">  lua_newtable(L);</a>
<a name="ln322">  lua_setuservalue(L, -2);</a>
<a name="ln323">  if(cin)</a>
<a name="ln324">  {</a>
<a name="ln325">    memcpy(udata, cin, type_size);</a>
<a name="ln326">  }</a>
<a name="ln327">  else</a>
<a name="ln328">  {</a>
<a name="ln329">    memset(udata, 0, type_size);</a>
<a name="ln330">  }</a>
<a name="ln331">  luaL_setmetatable(L, luaA_typename(L, type_id));</a>
<a name="ln332"> </a>
<a name="ln333">  if(luaL_getmetafield(L, -1, &quot;__init&quot;))</a>
<a name="ln334">  {</a>
<a name="ln335">    lua_pushvalue(L, -2);                  // the new allocated object</a>
<a name="ln336">    lua_pushlightuserdata(L, (void *)cin); // forced to cast..</a>
<a name="ln337">    lua_call(L, 2, 0);</a>
<a name="ln338">  }</a>
<a name="ln339">  return 1;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">static void full_tofunc(lua_State *L, luaA_Type type_id, void *cout, int index)</a>
<a name="ln343">{</a>
<a name="ln344">  if(!dt_lua_isa_type(L,index,type_id)) {</a>
<a name="ln345">    char error_msg[256];</a>
<a name="ln346">    snprintf(error_msg,sizeof(error_msg),&quot;%s expected&quot;,luaA_typename(L,type_id));</a>
<a name="ln347">    luaL_argerror(L,index,error_msg);</a>
<a name="ln348">  } </a>
<a name="ln349">  void* udata = lua_touserdata(L,index);</a>
<a name="ln350">  memcpy(cout, udata, luaA_typesize(L, type_id));</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">static int int_pushfunc(lua_State *L, luaA_Type type_id, const void *cin)</a>
<a name="ln354">{</a>
<a name="ln355">  luaL_getmetatable(L, luaA_typename(L, type_id));</a>
<a name="ln356">  luaL_getsubtable(L, -1, &quot;__values&quot;);</a>
<a name="ln357">  int singleton = *(int *)cin;</a>
<a name="ln358">  lua_pushinteger(L, singleton);</a>
<a name="ln359">  lua_gettable(L, -2);</a>
<a name="ln360">  if(lua_isnoneornil(L, -1))</a>
<a name="ln361">  {</a>
<a name="ln362">    lua_pop(L, 1);</a>
<a name="ln363">    int *udata = lua_newuserdata(L, sizeof(int));</a>
<a name="ln364">    *udata = singleton;</a>
<a name="ln365">    luaL_setmetatable(L, luaA_typename(L, type_id));</a>
<a name="ln366">    lua_pushinteger(L, singleton);</a>
<a name="ln367">    // warning : no uservalue</a>
<a name="ln368">    lua_pushvalue(L, -2);</a>
<a name="ln369">    lua_settable(L, -4);</a>
<a name="ln370">    if(luaL_getmetafield(L, -1, &quot;__init&quot;))</a>
<a name="ln371">    {</a>
<a name="ln372">      lua_pushvalue(L, -2);                  // the new allocated object</a>
<a name="ln373">      lua_pushlightuserdata(L, (void *)cin); // forced to cast..</a>
<a name="ln374">      lua_call(L, 2, 0);</a>
<a name="ln375">    }</a>
<a name="ln376">  }</a>
<a name="ln377">  lua_remove(L, -2); //__values</a>
<a name="ln378">  lua_remove(L, -2); // metatable</a>
<a name="ln379">  return 1;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">static void int_tofunc(lua_State *L, luaA_Type type_id, void *cout, int index)</a>
<a name="ln383">{</a>
<a name="ln384">  if(!dt_lua_isa_type(L,index,type_id)) {</a>
<a name="ln385">    char error_msg[256];</a>
<a name="ln386">    snprintf(error_msg,sizeof(error_msg),&quot;%s expected&quot;,luaA_typename(L,type_id));</a>
<a name="ln387">    luaL_argerror(L,index,error_msg);</a>
<a name="ln388">  } </a>
<a name="ln389">  void* udata = lua_touserdata(L,index);</a>
<a name="ln390">  memcpy(cout, udata, sizeof(int));</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">static int gpointer_pushfunc(lua_State *L, luaA_Type type_id, const void *cin)</a>
<a name="ln394">{</a>
<a name="ln395">  gpointer singleton = *(gpointer *)cin;</a>
<a name="ln396">  if(!singleton) {</a>
<a name="ln397">    lua_pushnil(L);</a>
<a name="ln398">    return 1;</a>
<a name="ln399">  }</a>
<a name="ln400">  luaL_getsubtable(L, LUA_REGISTRYINDEX, &quot;dt_lua_gpointer_values&quot;);</a>
<a name="ln401">  lua_pushlightuserdata(L, singleton);</a>
<a name="ln402">  lua_gettable(L, -2);</a>
<a name="ln403">  if(lua_isnoneornil(L, -1))</a>
<a name="ln404">  {</a>
<a name="ln405">    lua_pop(L, 1);</a>
<a name="ln406">    gpointer *udata = lua_newuserdata(L, sizeof(gpointer));</a>
<a name="ln407">    lua_newtable(L);</a>
<a name="ln408">    lua_setuservalue(L, -2);</a>
<a name="ln409">    *udata = singleton;</a>
<a name="ln410">    luaL_setmetatable(L, luaA_typename(L, type_id));</a>
<a name="ln411">    lua_pushlightuserdata(L, singleton);</a>
<a name="ln412">    lua_pushvalue(L, -2);</a>
<a name="ln413">    lua_settable(L, -4);</a>
<a name="ln414">    if(luaL_getmetafield(L, -1, &quot;__init&quot;))</a>
<a name="ln415">    {</a>
<a name="ln416">      lua_pushvalue(L, -2);                  // the new allocated object</a>
<a name="ln417">      lua_pushlightuserdata(L, (void *)cin); // forced to cast..</a>
<a name="ln418">      lua_call(L, 2, 0);</a>
<a name="ln419">    }</a>
<a name="ln420">  }</a>
<a name="ln421">  lua_remove(L, -2); //dt_lua_gpointer_values</a>
<a name="ln422">  return 1;</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">static void gpointer_tofunc(lua_State *L, luaA_Type type_id, void *cout, int index)</a>
<a name="ln426">{</a>
<a name="ln427">  if(!dt_lua_isa_type(L,index,type_id)) {</a>
<a name="ln428">    char error_msg[256];</a>
<a name="ln429">    snprintf(error_msg,sizeof(error_msg),&quot;%s expected&quot;,luaA_typename(L,type_id));</a>
<a name="ln430">    luaL_argerror(L,index,error_msg);</a>
<a name="ln431">  } </a>
<a name="ln432">  gpointer* udata = lua_touserdata(L,index);</a>
<a name="ln433">  memcpy(cout, udata, sizeof(gpointer));</a>
<a name="ln434">  if(!*udata) {</a>
<a name="ln435">    luaL_error(L,&quot;Attempting to access of type %s after its destruction\n&quot;,luaA_typename(L,type_id));</a>
<a name="ln436">  }</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">static int unknown_pushfunc(lua_State *L, luaA_Type type_id, const void *cin)</a>
<a name="ln440">{</a>
<a name="ln441">  gpointer singleton = *(gpointer *)cin;</a>
<a name="ln442">  if(!singleton) {</a>
<a name="ln443">    lua_pushnil(L);</a>
<a name="ln444">    return 1;</a>
<a name="ln445">  }</a>
<a name="ln446">  luaL_getsubtable(L, LUA_REGISTRYINDEX, &quot;dt_lua_gpointer_values&quot;);</a>
<a name="ln447">  lua_pushlightuserdata(L, singleton);</a>
<a name="ln448">  lua_gettable(L, -2);</a>
<a name="ln449">  if(lua_isnoneornil(L, -1))</a>
<a name="ln450">  {</a>
<a name="ln451">    return luaL_error(L,&quot;Attempting to push a pointer of unknown type on the stack\n&quot;);</a>
<a name="ln452">  }</a>
<a name="ln453">  lua_remove(L, -2); //dt_lua_gpointer_values</a>
<a name="ln454">  return 1;</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457"> </a>
<a name="ln458">/*****************/</a>
<a name="ln459">/* TYPE CREATION */</a>
<a name="ln460">/*****************/</a>
<a name="ln461">void dt_lua_type_register_type(lua_State *L, luaA_Type type_id, const char *name)</a>
<a name="ln462">{</a>
<a name="ln463">  luaL_getmetatable(L, luaA_typename(L, type_id)); // gets the metatable since it's supposed to exist</a>
<a name="ln464">  luaL_getsubtable(L, -1, &quot;__get&quot;);</a>
<a name="ln465">  lua_pushvalue(L, -3);</a>
<a name="ln466">  lua_setfield(L, -2, name);</a>
<a name="ln467">  lua_pop(L, 1);</a>
<a name="ln468"> </a>
<a name="ln469">  luaL_getsubtable(L, -1, &quot;__set&quot;);</a>
<a name="ln470">  lua_pushvalue(L, -3);</a>
<a name="ln471">  lua_setfield(L, -2, name);</a>
<a name="ln472">  lua_pop(L, 3);</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">void dt_lua_type_register_const_type(lua_State *L, luaA_Type type_id, const char *name)</a>
<a name="ln476">{</a>
<a name="ln477">  luaL_getmetatable(L, luaA_typename(L, type_id)); // gets the metatable since it's supposed to exist</a>
<a name="ln478"> </a>
<a name="ln479">  luaL_getsubtable(L, -1, &quot;__get&quot;);</a>
<a name="ln480">  lua_pushvalue(L, -3);</a>
<a name="ln481">  lua_setfield(L, -2, name);</a>
<a name="ln482">  lua_pop(L, 3);</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">void dt_lua_type_register_number_const_type(lua_State *L, luaA_Type type_id)</a>
<a name="ln486">{</a>
<a name="ln487">  luaL_getmetatable(L, luaA_typename(L, type_id)); // gets the metatable since it's supposed to exist</a>
<a name="ln488"> </a>
<a name="ln489">  lua_pushvalue(L, -2);</a>
<a name="ln490">  lua_setfield(L, -2, &quot;__number_index&quot;);</a>
<a name="ln491"> </a>
<a name="ln492">  if(!lua_isnil(L, -3))</a>
<a name="ln493">  {</a>
<a name="ln494">    lua_pushvalue(L, -3);</a>
<a name="ln495">    lua_setfield(L, -2, &quot;__len&quot;);</a>
<a name="ln496">  }</a>
<a name="ln497"> </a>
<a name="ln498">  lua_pop(L, 3);</a>
<a name="ln499">}</a>
<a name="ln500">void dt_lua_type_register_number_type(lua_State *L, luaA_Type type_id)</a>
<a name="ln501">{</a>
<a name="ln502">  luaL_getmetatable(L, luaA_typename(L, type_id)); // gets the metatable since it's supposed to exist</a>
<a name="ln503"> </a>
<a name="ln504">  lua_pushvalue(L, -2);</a>
<a name="ln505">  lua_setfield(L, -2, &quot;__number_index&quot;);</a>
<a name="ln506"> </a>
<a name="ln507">  lua_pushvalue(L, -2);</a>
<a name="ln508">  lua_setfield(L, -2, &quot;__number_newindex&quot;);</a>
<a name="ln509"> </a>
<a name="ln510">  if(!lua_isnil(L, -3))</a>
<a name="ln511">  {</a>
<a name="ln512">    lua_pushvalue(L, -3);</a>
<a name="ln513">    lua_setfield(L, -2, &quot;__len&quot;);</a>
<a name="ln514">  }</a>
<a name="ln515"> </a>
<a name="ln516">  lua_pop(L, 3);</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">int dt_lua_type_member_luaautoc(lua_State *L)</a>
<a name="ln520">{</a>
<a name="ln521">  const char *member_name = luaL_checkstring(L, 2);</a>
<a name="ln522">  luaL_getmetafield(L, 1, &quot;__luaA_Type&quot;);</a>
<a name="ln523">  luaA_Type my_type = luaL_checkinteger(L, -1);</a>
<a name="ln524">  lua_pop(L, 1);</a>
<a name="ln525">  void *object = lua_touserdata(L, 1);</a>
<a name="ln526">  if(lua_gettop(L) != 3)</a>
<a name="ln527">  {</a>
<a name="ln528">    luaA_struct_push_member_name_type(L, my_type, member_name, object);</a>
<a name="ln529">    return 1;</a>
<a name="ln530">  }</a>
<a name="ln531">  else</a>
<a name="ln532">  {</a>
<a name="ln533">    luaA_struct_to_member_name_type(L, my_type, member_name, object, 3);</a>
<a name="ln534">    return 0;</a>
<a name="ln535">  }</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538">void dt_lua_type_register_struct_type(lua_State *L, luaA_Type type_id)</a>
<a name="ln539">{</a>
<a name="ln540">  const char *member_name = luaA_struct_next_member_name_type(L, type_id, LUAA_INVALID_MEMBER_NAME);</a>
<a name="ln541">  while(member_name != LUAA_INVALID_MEMBER_NAME)</a>
<a name="ln542">  {</a>
<a name="ln543">    lua_pushvalue(L, -1);</a>
<a name="ln544">    luaA_Type member_type = luaA_struct_typeof_member_name_type(L, type_id, member_name);</a>
<a name="ln545">    if(luaA_conversion_to_registered_type(L, member_type) || luaA_struct_registered_type(L, member_type)</a>
<a name="ln546">       || luaA_enum_registered_type(L, member_type))</a>
<a name="ln547">    {</a>
<a name="ln548">      dt_lua_type_register_type(L, type_id, member_name);</a>
<a name="ln549">    }</a>
<a name="ln550">    else</a>
<a name="ln551">    {</a>
<a name="ln552">      dt_lua_type_register_const_type(L, type_id, member_name);</a>
<a name="ln553">    }</a>
<a name="ln554">    member_name = luaA_struct_next_member_name_type(L, type_id, member_name);</a>
<a name="ln555">  }</a>
<a name="ln556">  lua_pop(L, 1);</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559"> </a>
<a name="ln560">int dt_lua_type_member_common(lua_State *L)</a>
<a name="ln561">{</a>
<a name="ln562">  if(lua_gettop(L) != 2)</a>
<a name="ln563">  {</a>
<a name="ln564">    luaL_getmetafield(L, 1, &quot;__luaA_TypeName&quot;);</a>
<a name="ln565">    return luaL_error(L, &quot;field \&quot;%s\&quot; can't be written for type %s\n&quot;, lua_tostring(L, 2),</a>
<a name="ln566">                      lua_tostring(L, -1));</a>
<a name="ln567">  }</a>
<a name="ln568">  lua_pushvalue(L, lua_upvalueindex(1));</a>
<a name="ln569">  return 1;</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">void dt_lua_type_register_parent_type(lua_State *L, luaA_Type type_id, luaA_Type parent_type_id)</a>
<a name="ln573">{</a>
<a name="ln574">  luaL_getmetatable(L, luaA_typename(L, type_id));        // gets the metatable since it's supposed to exist</a>
<a name="ln575">  luaL_getmetatable(L, luaA_typename(L, parent_type_id)); // gets the metatable since it's supposed to exist</a>
<a name="ln576"> </a>
<a name="ln577">  lua_pushvalue(L, -1);</a>
<a name="ln578">  lua_setfield(L, -3, &quot;__luaA_ParentMetatable&quot;);</a>
<a name="ln579"> </a>
<a name="ln580">  lua_getfield(L, -2, &quot;__get&quot;);</a>
<a name="ln581">  lua_getfield(L, -2, &quot;__get&quot;);</a>
<a name="ln582">  lua_pushnil(L); /* first key */</a>
<a name="ln583">  while(lua_next(L, -2) != 0)</a>
<a name="ln584">  {</a>
<a name="ln585">    lua_getfield(L,-4,lua_tostring(L,-2));</a>
<a name="ln586">    if(lua_isnil(L,-1)) {</a>
<a name="ln587">      lua_pop(L,1);</a>
<a name="ln588">      lua_setfield(L, -4, lua_tostring(L,-2));</a>
<a name="ln589">    } else {</a>
<a name="ln590">      lua_pop(L,2);</a>
<a name="ln591">    }</a>
<a name="ln592">  }</a>
<a name="ln593">  lua_pop(L, 2);</a>
<a name="ln594"> </a>
<a name="ln595">  lua_getfield(L, -2, &quot;__set&quot;);</a>
<a name="ln596">  lua_getfield(L, -2, &quot;__set&quot;);</a>
<a name="ln597">  lua_pushnil(L); /* first key */</a>
<a name="ln598">  while(lua_next(L, -2) != 0)</a>
<a name="ln599">  {</a>
<a name="ln600">    lua_getfield(L,-4,lua_tostring(L,-2));</a>
<a name="ln601">    if(lua_isnil(L,-1)) {</a>
<a name="ln602">      lua_pop(L,1);</a>
<a name="ln603">      lua_setfield(L, -4, lua_tostring(L,-2));</a>
<a name="ln604">    } else {</a>
<a name="ln605">      lua_pop(L,2);</a>
<a name="ln606">    }</a>
<a name="ln607">  }</a>
<a name="ln608">  lua_pop(L, 2);</a>
<a name="ln609"> </a>
<a name="ln610">  lua_pushnil(L); /* first key */</a>
<a name="ln611">  while(lua_next(L, -2) != 0)</a>
<a name="ln612">  {</a>
<a name="ln613">    lua_getfield(L,-4,lua_tostring(L,-2));</a>
<a name="ln614">    if(lua_isnil(L,-1)) {</a>
<a name="ln615">      lua_pop(L,1);</a>
<a name="ln616">      lua_setfield(L, -4, lua_tostring(L,-2));</a>
<a name="ln617">    } else {</a>
<a name="ln618">      lua_pop(L,2);</a>
<a name="ln619">    }</a>
<a name="ln620">  }</a>
<a name="ln621"> </a>
<a name="ln622"> </a>
<a name="ln623">  lua_pop(L, 2);</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">static void init_metatable(lua_State *L, luaA_Type type_id)</a>
<a name="ln627">{</a>
<a name="ln628">  luaL_newmetatable(L, luaA_typename(L, type_id));</a>
<a name="ln629"> </a>
<a name="ln630">  lua_pushstring(L, luaA_typename(L, type_id));</a>
<a name="ln631">  lua_setfield(L, -2, &quot;__luaA_TypeName&quot;);</a>
<a name="ln632"> </a>
<a name="ln633">  lua_pushinteger(L, type_id);</a>
<a name="ln634">  lua_setfield(L, -2, &quot;__luaA_Type&quot;);</a>
<a name="ln635"> </a>
<a name="ln636">  lua_pushvalue(L, -1);</a>
<a name="ln637">  lua_pushcclosure(L, autotype_next, 1);</a>
<a name="ln638">  lua_setfield(L, -2, &quot;__next&quot;);</a>
<a name="ln639"> </a>
<a name="ln640">  lua_pushvalue(L, -1);</a>
<a name="ln641">  lua_pushcclosure(L, autotype_pairs, 1);</a>
<a name="ln642">  lua_setfield(L, -2, &quot;__pairs&quot;);</a>
<a name="ln643"> </a>
<a name="ln644">  lua_pushvalue(L, -1);</a>
<a name="ln645">  lua_pushcclosure(L, autotype_index, 1);</a>
<a name="ln646">  lua_setfield(L, -2, &quot;__index&quot;);</a>
<a name="ln647"> </a>
<a name="ln648">  lua_pushvalue(L, -1);</a>
<a name="ln649">  lua_pushcclosure(L, autotype_newindex, 1);</a>
<a name="ln650">  lua_setfield(L, -2, &quot;__newindex&quot;);</a>
<a name="ln651"> </a>
<a name="ln652">  lua_newtable(L);</a>
<a name="ln653">  lua_setfield(L, -2, &quot;__get&quot;);</a>
<a name="ln654"> </a>
<a name="ln655">  lua_newtable(L);</a>
<a name="ln656">  lua_setfield(L, -2, &quot;__set&quot;);</a>
<a name="ln657"> </a>
<a name="ln658">  lua_pushvalue(L, -1);</a>
<a name="ln659">  lua_pushcclosure(L, autotype_tostring, 1);</a>
<a name="ln660">  lua_setfield(L, -2, &quot;__tostring&quot;);</a>
<a name="ln661"> </a>
<a name="ln662">  // leave metatable on top of stack</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665"> </a>
<a name="ln666">luaA_Type dt_lua_init_type_type(lua_State *L, luaA_Type type_id)</a>
<a name="ln667">{</a>
<a name="ln668">  init_metatable(L, type_id);</a>
<a name="ln669">  lua_pop(L, 1);</a>
<a name="ln670">  luaA_conversion_type(L, type_id, full_pushfunc, full_tofunc);</a>
<a name="ln671">  return type_id;</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">luaA_Type dt_lua_init_singleton(lua_State *L, const char *unique_name, void *data)</a>
<a name="ln675">{</a>
<a name="ln676">  char tmp_name[1024];</a>
<a name="ln677">  snprintf(tmp_name, sizeof(tmp_name), &quot;dt_lua_singleton_%s&quot;, unique_name);</a>
<a name="ln678"> </a>
<a name="ln679">  luaA_Type type_id = luaA_type_add(L, tmp_name, sizeof(void *));</a>
<a name="ln680">  init_metatable(L, type_id);</a>
<a name="ln681"> </a>
<a name="ln682">  void **udata = lua_newuserdata(L, sizeof(void *));</a>
<a name="ln683">  lua_newtable(L);</a>
<a name="ln684">  lua_setuservalue(L, -2);</a>
<a name="ln685">  if(!data)</a>
<a name="ln686">  {</a>
<a name="ln687">    memset(udata, 0, sizeof(void *));</a>
<a name="ln688">  }</a>
<a name="ln689">  else</a>
<a name="ln690">  {</a>
<a name="ln691">    *udata = data;</a>
<a name="ln692">    luaL_getsubtable(L, LUA_REGISTRYINDEX, &quot;dt_lua_gpointer_values&quot;);</a>
<a name="ln693">    lua_pushlightuserdata(L, data);</a>
<a name="ln694">    lua_pushvalue(L,-3);</a>
<a name="ln695">    lua_settable(L,-3);</a>
<a name="ln696">    lua_pop(L,1);</a>
<a name="ln697">  }</a>
<a name="ln698"> </a>
<a name="ln699">  lua_pushvalue(L, -1);</a>
<a name="ln700">  luaL_setmetatable(L, tmp_name);</a>
<a name="ln701">  lua_setfield(L, -3, &quot;__singleton&quot;);</a>
<a name="ln702">  if(luaL_getmetafield(L, -1, &quot;__init&quot;))</a>
<a name="ln703">  {</a>
<a name="ln704">    lua_pushvalue(L, -2);                   // the new allocated object</a>
<a name="ln705">    lua_pushlightuserdata(L, (void *)data); // forced to cast..</a>
<a name="ln706">    lua_call(L, 2, 0);</a>
<a name="ln707">  }</a>
<a name="ln708">  lua_remove(L, -2);</a>
<a name="ln709"> </a>
<a name="ln710">  return type_id;</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713"> </a>
<a name="ln714">static int wrapped_index(lua_State *L)</a>
<a name="ln715">{</a>
<a name="ln716">  luaL_getmetafield(L, 1, &quot;__pusher&quot;);</a>
<a name="ln717">  lua_pushvalue(L, 1);</a>
<a name="ln718">  lua_call(L, 1, 1);</a>
<a name="ln719">  lua_pushvalue(L, 2);</a>
<a name="ln720">  lua_gettable(L, -2);</a>
<a name="ln721">  lua_remove(L, 1);</a>
<a name="ln722">  lua_remove(L, 1);</a>
<a name="ln723">  return 1;</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">static int wrapped_pairs(lua_State *L)</a>
<a name="ln727">{</a>
<a name="ln728">  luaL_getmetafield(L, 1, &quot;__pusher&quot;);</a>
<a name="ln729">  lua_pushvalue(L, 1);</a>
<a name="ln730">  lua_call(L, 1, 1);</a>
<a name="ln731">  luaL_getmetafield(L, -1, &quot;__pairs&quot;);</a>
<a name="ln732">  lua_pushvalue(L, -2);</a>
<a name="ln733">  lua_call(L, 1, 3);</a>
<a name="ln734">  return 3;</a>
<a name="ln735">}</a>
<a name="ln736">static int wrapped_newindex(lua_State *L)</a>
<a name="ln737">{</a>
<a name="ln738">  return luaL_error(L, &quot;TBSL&quot;);</a>
<a name="ln739">}</a>
<a name="ln740">static int wrapped_tostring(lua_State *L)</a>
<a name="ln741">{</a>
<a name="ln742">  return luaL_error(L, &quot;TBSL&quot;);</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745"> </a>
<a name="ln746">luaA_Type dt_lua_init_wrapped_singleton(lua_State *L, lua_CFunction pusher, lua_CFunction getter,</a>
<a name="ln747">                                        const char *unique_name, void *data)</a>
<a name="ln748">{</a>
<a name="ln749">  luaA_Type result = dt_lua_init_singleton(L, unique_name, data);</a>
<a name="ln750">  lua_getmetatable(L, -1);</a>
<a name="ln751">  lua_pushcfunction(L, wrapped_index);</a>
<a name="ln752">  lua_setfield(L, -2, &quot;__index&quot;);</a>
<a name="ln753">  lua_pushcfunction(L, wrapped_newindex);</a>
<a name="ln754">  lua_setfield(L, -2, &quot;__newindex&quot;);</a>
<a name="ln755">  lua_pushcfunction(L, wrapped_pairs);</a>
<a name="ln756">  lua_setfield(L, -2, &quot;__pairs&quot;);</a>
<a name="ln757">  lua_pushcfunction(L, wrapped_tostring);</a>
<a name="ln758">  lua_setfield(L, -2, &quot;__tostring&quot;);</a>
<a name="ln759">  lua_pushcfunction(L, pusher);</a>
<a name="ln760">  lua_setfield(L, -2, &quot;__pusher&quot;);</a>
<a name="ln761">  lua_pushcfunction(L, getter);</a>
<a name="ln762">  lua_setfield(L, -2, &quot;__getter&quot;);</a>
<a name="ln763">  lua_pop(L, 1);</a>
<a name="ln764">  return result;</a>
<a name="ln765">}</a>
<a name="ln766"> </a>
<a name="ln767">luaA_Type dt_lua_init_int_type_type(lua_State *L, luaA_Type type_id)</a>
<a name="ln768">{</a>
<a name="ln769">  init_metatable(L, type_id);</a>
<a name="ln770">  lua_newtable(L);</a>
<a name="ln771">  // metatable of __values</a>
<a name="ln772">  lua_newtable(L);</a>
<a name="ln773">  lua_pushstring(L, &quot;kv&quot;);</a>
<a name="ln774">  lua_setfield(L, -2, &quot;__mode&quot;);</a>
<a name="ln775">  lua_setmetatable(L, -2);</a>
<a name="ln776"> </a>
<a name="ln777">  lua_setfield(L, -2, &quot;__values&quot;);</a>
<a name="ln778">  lua_pop(L, 1);</a>
<a name="ln779">  luaA_conversion_type(L, type_id, int_pushfunc, int_tofunc);</a>
<a name="ln780">  return type_id;</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783">static int gpointer_wrapper(lua_State*L) </a>
<a name="ln784">{</a>
<a name="ln785">  gpointer *udata = (gpointer*)lua_touserdata(L,1);</a>
<a name="ln786">  if(!*udata) {</a>
<a name="ln787">    luaL_getmetafield(L,1,&quot;__luaA_TypeName&quot;);</a>
<a name="ln788">    luaL_error(L,&quot;Attempting to access an invalid object of type %s&quot;,lua_tostring(L,-1));</a>
<a name="ln789">  }</a>
<a name="ln790">  lua_CFunction callback = lua_tocfunction(L,lua_upvalueindex(1));</a>
<a name="ln791">  return callback(L);</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794"> </a>
<a name="ln795">luaA_Type dt_lua_init_gpointer_type_type(lua_State *L, luaA_Type type_id)</a>
<a name="ln796">{</a>
<a name="ln797">  init_metatable(L, type_id);</a>
<a name="ln798"> </a>
<a name="ln799">  lua_getfield(L,-1,&quot;__next&quot;);</a>
<a name="ln800">  lua_pushcclosure(L, gpointer_wrapper,1);</a>
<a name="ln801">  lua_setfield(L, -2, &quot;__next&quot;);</a>
<a name="ln802"> </a>
<a name="ln803">  lua_getfield(L,-1,&quot;__index&quot;);</a>
<a name="ln804">  lua_pushcclosure(L, gpointer_wrapper,1);</a>
<a name="ln805">  lua_setfield(L, -2, &quot;__index&quot;);</a>
<a name="ln806"> </a>
<a name="ln807">  lua_getfield(L,-1,&quot;__newindex&quot;);</a>
<a name="ln808">  lua_pushcclosure(L, gpointer_wrapper,1);</a>
<a name="ln809">  lua_setfield(L, -2, &quot;__newindex&quot;);</a>
<a name="ln810"> </a>
<a name="ln811">  lua_getfield(L,-1,&quot;__pairs&quot;);</a>
<a name="ln812">  lua_pushcclosure(L, gpointer_wrapper,1);</a>
<a name="ln813">  lua_setfield(L, -2, &quot;__pairs&quot;);</a>
<a name="ln814"> </a>
<a name="ln815">  lua_getfield(L,-1,&quot;__tostring&quot;);</a>
<a name="ln816">  lua_pushcclosure(L, gpointer_wrapper,1);</a>
<a name="ln817">  lua_setfield(L, -2, &quot;__tostring&quot;);</a>
<a name="ln818"> </a>
<a name="ln819">  lua_pop(L, 1);</a>
<a name="ln820"> </a>
<a name="ln821">  luaA_conversion_type(L, type_id, gpointer_pushfunc, gpointer_tofunc);</a>
<a name="ln822">  return type_id;</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">void dt_lua_type_gpointer_alias_type(lua_State*L,luaA_Type type_id,void* pointer,void* alias)</a>
<a name="ln826">{</a>
<a name="ln827">  luaL_getsubtable(L, LUA_REGISTRYINDEX, &quot;dt_lua_gpointer_values&quot;);</a>
<a name="ln828">  lua_pushlightuserdata(L, pointer);</a>
<a name="ln829">  lua_gettable(L, -2);</a>
<a name="ln830">  if(lua_isnoneornil(L, -1))</a>
<a name="ln831">  {</a>
<a name="ln832">    luaL_error(L,&quot;Adding an alias to an unknown object for type %s&quot;,luaA_typename(L,type_id));</a>
<a name="ln833">  }</a>
<a name="ln834">  lua_pushlightuserdata(L,alias);</a>
<a name="ln835">  lua_insert(L,-2);</a>
<a name="ln836">  lua_settable(L,-3);</a>
<a name="ln837">  lua_pop(L,1);</a>
<a name="ln838"> </a>
<a name="ln839"> </a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">void dt_lua_type_gpointer_drop(lua_State*L, void* pointer)</a>
<a name="ln843">{</a>
<a name="ln844">  luaL_getsubtable(L, LUA_REGISTRYINDEX, &quot;dt_lua_gpointer_values&quot;);</a>
<a name="ln845"> </a>
<a name="ln846">  lua_pushlightuserdata(L, pointer);</a>
<a name="ln847">  lua_gettable(L,-2);</a>
<a name="ln848">  gpointer *udata = (gpointer*)lua_touserdata(L,-1);</a>
<a name="ln849">  if(lua_isnil(L,-1)) {</a>
<a name="ln850">    lua_pop(L,2);</a>
<a name="ln851">    return; // this table is weak, the object has been gc</a>
<a name="ln852">  }</a>
<a name="ln853">  *udata = NULL;</a>
<a name="ln854">  lua_pop(L,1);</a>
<a name="ln855"> </a>
<a name="ln856">  lua_pushlightuserdata(L, pointer);</a>
<a name="ln857">  lua_pushnil(L);</a>
<a name="ln858">  lua_settable(L,-3);</a>
<a name="ln859"> </a>
<a name="ln860">  lua_pop(L,1);</a>
<a name="ln861"> </a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">gboolean dt_lua_isa_type(lua_State *L, int index, luaA_Type type_id)</a>
<a name="ln865">{</a>
<a name="ln866">  if(!luaL_getmetafield(L, index, &quot;__luaA_Type&quot;)) return false;</a>
<a name="ln867">  int obj_type = luaL_checkinteger(L, -1);</a>
<a name="ln868">  lua_pop(L, 1);</a>
<a name="ln869">  return dt_lua_typeisa_type(L, obj_type, type_id);</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872">gboolean dt_lua_typeisa_type(lua_State *L, luaA_Type obj_type, luaA_Type type_id)</a>
<a name="ln873">{</a>
<a name="ln874">  if(obj_type == type_id) return true;</a>
<a name="ln875">  luaL_getmetatable(L, luaA_typename(L, obj_type));</a>
<a name="ln876">  lua_getfield(L, -1, &quot;__luaA_ParentMetatable&quot;);</a>
<a name="ln877">  if(lua_isnil(L, -1))</a>
<a name="ln878">  {</a>
<a name="ln879">    lua_pop(L, 2);</a>
<a name="ln880">    return false;</a>
<a name="ln881">  }</a>
<a name="ln882">  lua_getfield(L, -1, &quot;__luaA_Type&quot;);</a>
<a name="ln883">  int parent_type = luaL_checkinteger(L, -1);</a>
<a name="ln884">  lua_pop(L, 3);</a>
<a name="ln885">  return dt_lua_typeisa_type(L, parent_type, type_id);</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">void dt_lua_type_setmetafield_type(lua_State*L,luaA_Type type_id,const char* method_name)</a>
<a name="ln889">{</a>
<a name="ln890">  // These metafields should never be overridden by user code</a>
<a name="ln891">  if( </a>
<a name="ln892">      !strcmp(method_name,&quot;__index&quot;) ||</a>
<a name="ln893">      !strcmp(method_name,&quot;__newindex&quot;) ||</a>
<a name="ln894">      !strcmp(method_name,&quot;__number_index&quot;) ||</a>
<a name="ln895">      !strcmp(method_name,&quot;__number_newindex&quot;) ||</a>
<a name="ln896">      !strcmp(method_name,&quot;__pairs&quot;) ||</a>
<a name="ln897">      !strcmp(method_name,&quot;__next&quot;) ||</a>
<a name="ln898">      !strcmp(method_name,&quot;__get&quot;) ||</a>
<a name="ln899">      !strcmp(method_name,&quot;__set&quot;) ||</a>
<a name="ln900">      !strcmp(method_name,&quot;__len&quot;) ||</a>
<a name="ln901">      !strcmp(method_name,&quot;__luaA_Type&quot;) ||</a>
<a name="ln902">      !strcmp(method_name,&quot;__luaA_TypeName&quot;) ||</a>
<a name="ln903">      !strcmp(method_name,&quot;__luaA_ParentMetatable&quot;) ||</a>
<a name="ln904">      !strcmp(method_name,&quot;__init&quot;) ||</a>
<a name="ln905">      !strcmp(method_name,&quot;__values&quot;) ||</a>
<a name="ln906">      !strcmp(method_name,&quot;__singleton&quot;) ||</a>
<a name="ln907">      !strcmp(method_name,&quot;__pusher&quot;) ||</a>
<a name="ln908">      !strcmp(method_name,&quot;__getter&quot;) ||</a>
<a name="ln909">      !strcmp(method_name,&quot;__mode&quot;) ||</a>
<a name="ln910">      0) {</a>
<a name="ln911">        luaL_error(L,&quot;non-core lua code is not allowed to change meta-field %s\n&quot;,method_name);</a>
<a name="ln912">  } else if(!strcmp(method_name,&quot;__tostring&quot;)) {</a>
<a name="ln913">    luaL_getmetatable(L, luaA_typename(L, type_id));</a>
<a name="ln914">    lua_pushvalue(L,-2);</a>
<a name="ln915">    lua_setfield(L, -2, &quot;__real_tostring&quot;);</a>
<a name="ln916">    lua_pop(L, 2); // pop the metatable and the value</a>
<a name="ln917">    return;</a>
<a name="ln918">  // whitelist for specific types</a>
<a name="ln919">  } else if(</a>
<a name="ln920">      // if you add a type here, make sure it handles inheritance of metamethods itself</a>
<a name="ln921">      // typically, set the metamethod not for the parent type but just after inheritance</a>
<a name="ln922">      ( !strcmp(method_name,&quot;__associated_object&quot;)&amp;&amp; dt_lua_typeisa_type(L,type_id,luaA_type_find(L,&quot;dt_imageio_module_format_t&quot;))) ||</a>
<a name="ln923">      ( !strcmp(method_name,&quot;__associated_object&quot;)&amp;&amp; dt_lua_typeisa_type(L,type_id,luaA_type_find(L,&quot;dt_imageio_module_storage_t&quot;))) ||</a>
<a name="ln924">      ( !strcmp(method_name,&quot;__gc&quot;)&amp;&amp; dt_lua_typeisa_type(L,type_id,luaA_type_find(L,&quot;dt_style_t&quot;))) ||</a>
<a name="ln925">      ( !strcmp(method_name,&quot;__gc&quot;)&amp;&amp; dt_lua_typeisa_type(L,type_id,luaA_type_find(L,&quot;dt_style_item_t&quot;))) ||</a>
<a name="ln926">      ( !strcmp(method_name,&quot;__gc&quot;)&amp;&amp; dt_lua_typeisa_type(L,type_id,luaA_type_find(L,&quot;lua_widget&quot;))) ||</a>
<a name="ln927">      ( !strcmp(method_name,&quot;__call&quot;)&amp;&amp; dt_lua_typeisa_type(L,type_id,luaA_type_find(L,&quot;lua_widget&quot;))) ||</a>
<a name="ln928">      ( !strcmp(method_name,&quot;__gtk_signals&quot;)&amp;&amp; dt_lua_typeisa_type(L,type_id,luaA_type_find(L,&quot;lua_widget&quot;))) ||</a>
<a name="ln929">      0) {</a>
<a name="ln930">    // Nothing to be done</a>
<a name="ln931">  } else {</a>
<a name="ln932">    luaL_error(L,&quot;metafield not handled :%s for type %s\n&quot;,method_name,luaA_typename(L,type_id));</a>
<a name="ln933">  }</a>
<a name="ln934">  luaL_getmetatable(L, luaA_typename(L, type_id));</a>
<a name="ln935">  lua_pushvalue(L,-2);</a>
<a name="ln936">  lua_setfield(L, -2, method_name);</a>
<a name="ln937">  lua_pop(L, 2); // pop the metatable and the value</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940">int dt_lua_init_early_types(lua_State *L)</a>
<a name="ln941">{</a>
<a name="ln942">  luaA_conversion(L, char_20, push_char_array, to_char20);</a>
<a name="ln943">  luaA_conversion_push(L, const char_20, push_char_array);</a>
<a name="ln944">  luaA_conversion(L, char_32, push_char_array, to_char32);</a>
<a name="ln945">  luaA_conversion_push(L, const char_32, push_char_array);</a>
<a name="ln946">  luaA_conversion(L, char_52, push_char_array, to_char52);</a>
<a name="ln947">  luaA_conversion_push(L, const char_52, push_char_array);</a>
<a name="ln948">  luaA_conversion(L, char_64, push_char_array, to_char64);</a>
<a name="ln949">  luaA_conversion_push(L, const char_64, push_char_array);</a>
<a name="ln950">  luaA_conversion(L, char_128, push_char_array, to_char128);</a>
<a name="ln951">  luaA_conversion_push(L, const char_128, push_char_array);</a>
<a name="ln952">  luaA_conversion(L, char_256, push_char_array, to_char256);</a>
<a name="ln953">  luaA_conversion_push(L, const char_256, push_char_array);</a>
<a name="ln954">  luaA_conversion(L, char_512, push_char_array, to_char512);</a>
<a name="ln955">  luaA_conversion_push(L, const char_512, push_char_array);</a>
<a name="ln956">  luaA_conversion(L, char_1024, push_char_array, to_char1024);</a>
<a name="ln957">  luaA_conversion_push(L, const char_1024, push_char_array);</a>
<a name="ln958">  luaA_conversion(L, char_filename_length, push_char_array, to_charfilename_length);</a>
<a name="ln959">  luaA_conversion_push(L, const char_filename_length, push_char_array);</a>
<a name="ln960">  luaA_conversion(L, char_path_length, push_char_array, to_charpath_length);</a>
<a name="ln961">  luaA_conversion_push(L, const char_path_length, push_char_array);</a>
<a name="ln962">  luaA_conversion(L, int32_t, luaA_push_int, luaA_to_int);</a>
<a name="ln963">  luaA_conversion_push(L, const int32_t, luaA_push_int);</a>
<a name="ln964">  luaA_conversion_push(L, const_string, luaA_push_const_char_ptr);</a>
<a name="ln965">  luaA_conversion(L, protected_double, push_protected_double, luaA_to_double);</a>
<a name="ln966">  luaA_conversion(L, progress_double, push_progress_double, to_progress_double);</a>
<a name="ln967"> </a>
<a name="ln968">  luaA_conversion_push_type(L, luaA_type_add(L,&quot;unknown&quot;,sizeof(void*)), unknown_pushfunc);</a>
<a name="ln969">  // table of gpointer values</a>
<a name="ln970">  lua_newtable(L);</a>
<a name="ln971">  lua_newtable(L);</a>
<a name="ln972">  lua_pushstring(L, &quot;kv&quot;);</a>
<a name="ln973">  lua_setfield(L, -2, &quot;__mode&quot;);</a>
<a name="ln974">  lua_setmetatable(L, -2);</a>
<a name="ln975"> </a>
<a name="ln976">  lua_setfield(L, LUA_REGISTRYINDEX, &quot;dt_lua_gpointer_values&quot;);</a>
<a name="ln977"> </a>
<a name="ln978">  luaA_enum(L,dt_lua_orientation_t);</a>
<a name="ln979">  luaA_enum_value_name(L,dt_lua_orientation_t,GTK_ORIENTATION_HORIZONTAL,&quot;horizontal&quot;);</a>
<a name="ln980">  luaA_enum_value_name(L,dt_lua_orientation_t,GTK_ORIENTATION_VERTICAL,&quot;vertical&quot;);</a>
<a name="ln981"> </a>
<a name="ln982">  luaA_enum(L, dt_lua_align_t);</a>
<a name="ln983">  luaA_enum_value_name(L, dt_lua_align_t, GTK_ALIGN_FILL, &quot;fill&quot;);</a>
<a name="ln984">  luaA_enum_value_name(L, dt_lua_align_t, GTK_ALIGN_START, &quot;start&quot;);</a>
<a name="ln985">  luaA_enum_value_name(L, dt_lua_align_t, GTK_ALIGN_END, &quot;end&quot;);</a>
<a name="ln986">  luaA_enum_value_name(L, dt_lua_align_t, GTK_ALIGN_CENTER, &quot;center&quot;);</a>
<a name="ln987">  luaA_enum_value_name(L, dt_lua_align_t, GTK_ALIGN_BASELINE, &quot;baseline&quot;);</a>
<a name="ln988"> </a>
<a name="ln989">  luaA_enum(L, dt_lua_ellipsize_mode_t);</a>
<a name="ln990">  luaA_enum_value_name(L, dt_lua_ellipsize_mode_t, PANGO_ELLIPSIZE_NONE, &quot;none&quot;);</a>
<a name="ln991">  luaA_enum_value_name(L, dt_lua_ellipsize_mode_t, PANGO_ELLIPSIZE_START, &quot;start&quot;);</a>
<a name="ln992">  luaA_enum_value_name(L, dt_lua_ellipsize_mode_t, PANGO_ELLIPSIZE_MIDDLE, &quot;middle&quot;);</a>
<a name="ln993">  luaA_enum_value_name(L, dt_lua_ellipsize_mode_t, PANGO_ELLIPSIZE_END, &quot;end&quot;);</a>
<a name="ln994"> </a>
<a name="ln995">  return 0;</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln999">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1000">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="910"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: 0.</p></div>
<div class="balloon" rel="929"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: 0.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
