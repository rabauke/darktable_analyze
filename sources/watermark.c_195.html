
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln20">#include &quot;common/tags.h&quot;</a>
<a name="ln21">#include &quot;control/control.h&quot;</a>
<a name="ln22">#include &quot;develop/develop.h&quot;</a>
<a name="ln23">#include &quot;develop/imageop.h&quot;</a>
<a name="ln24">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln25">#include &quot;dtgtk/resetlabel.h&quot;</a>
<a name="ln26">#include &quot;dtgtk/togglebutton.h&quot;</a>
<a name="ln27">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln28">#include &quot;gui/color_picker_proxy.h&quot;</a>
<a name="ln29">#include &quot;gui/gtk.h&quot;</a>
<a name="ln30">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln31">#include &lt;assert.h&gt;</a>
<a name="ln32">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln33">#include &lt;inttypes.h&gt;</a>
<a name="ln34">#include &lt;math.h&gt;</a>
<a name="ln35">#include &lt;stdlib.h&gt;</a>
<a name="ln36">#include &lt;string.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;librsvg/rsvg.h&gt;</a>
<a name="ln39">// ugh, ugly hack. why do people break stuff all the time?</a>
<a name="ln40">#ifndef RSVG_CAIRO_H</a>
<a name="ln41">#include &lt;librsvg/rsvg-cairo.h&gt;</a>
<a name="ln42">#endif</a>
<a name="ln43"> </a>
<a name="ln44">#include &quot;common/file_location.h&quot;</a>
<a name="ln45">#include &quot;common/metadata.h&quot;</a>
<a name="ln46">#include &quot;common/utility.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">#define CLIP(x) ((x &lt; 0) ? 0.0 : (x &gt; 1.0) ? 1.0 : x)</a>
<a name="ln49">DT_MODULE_INTROSPECTION(4, dt_iop_watermark_params_t)</a>
<a name="ln50"> </a>
<a name="ln51">// gchar *checksum = g_compute_checksum_for_data(G_CHECKSUM_MD5,data,length);</a>
<a name="ln52"> </a>
<a name="ln53">typedef enum dt_iop_watermark_base_scale_t</a>
<a name="ln54">{</a>
<a name="ln55">  DT_SCALE_IMAGE = 0,</a>
<a name="ln56">  DT_SCALE_LARGER_BORDER = 1,</a>
<a name="ln57">  DT_SCALE_SMALLER_BORDER = 2</a>
<a name="ln58">} dt_iop_watermark_base_scale_t;</a>
<a name="ln59"> </a>
<a name="ln60">typedef struct dt_iop_watermark_params_t</a>
<a name="ln61">{</a>
<a name="ln62">  /** opacity value of rendering watermark */</a>
<a name="ln63">  float opacity;</a>
<a name="ln64">  /** scale value of rendering watermark */</a>
<a name="ln65">  float scale;</a>
<a name="ln66">  /** Pixel independent xoffset, 0 to 1 */</a>
<a name="ln67">  float xoffset;</a>
<a name="ln68">  /** Pixel independent yoffset, 0 to 1 */</a>
<a name="ln69">  float yoffset;</a>
<a name="ln70">  /** Alignment value 0-8 3x3 */</a>
<a name="ln71">  int alignment;</a>
<a name="ln72">  /** Rotation **/</a>
<a name="ln73">  float rotate;</a>
<a name="ln74">  dt_iop_watermark_base_scale_t sizeto;</a>
<a name="ln75">  char filename[64];</a>
<a name="ln76">  /* simple text */</a>
<a name="ln77">  char text[64];</a>
<a name="ln78">  /* text color */</a>
<a name="ln79">  float color[3];</a>
<a name="ln80">  /* text font */</a>
<a name="ln81">  char font[64];</a>
<a name="ln82">} dt_iop_watermark_params_t;</a>
<a name="ln83"> </a>
<a name="ln84">typedef struct dt_iop_watermark_data_t</a>
<a name="ln85">{</a>
<a name="ln86">  float opacity;</a>
<a name="ln87">  float scale;</a>
<a name="ln88">  float xoffset;</a>
<a name="ln89">  float yoffset;</a>
<a name="ln90">  int alignment;</a>
<a name="ln91">  float rotate;</a>
<a name="ln92">  dt_iop_watermark_base_scale_t sizeto;</a>
<a name="ln93">  char filename[64];</a>
<a name="ln94">  char text[64];</a>
<a name="ln95">  float color[3];</a>
<a name="ln96">  char font[64];</a>
<a name="ln97">} dt_iop_watermark_data_t;</a>
<a name="ln98"> </a>
<a name="ln99">typedef struct dt_iop_watermark_gui_data_t</a>
<a name="ln100">{</a>
<a name="ln101">  GtkWidget *watermarks;                             // watermark</a>
<a name="ln102">  GList     *watermarks_filenames;                   // the actual filenames. the dropdown lacks file extensions</a>
<a name="ln103">  GtkWidget *refresh;                                // refresh watermarks...</a>
<a name="ln104">  GtkWidget *align[9];                               // Alignment buttons</a>
<a name="ln105">  GtkWidget *opacity, *scale, *x_offset, *y_offset;  // opacity, scale, xoffs, yoffs</a>
<a name="ln106">  GtkWidget *sizeto;                                 // relative size to</a>
<a name="ln107">  GtkWidget *rotate;</a>
<a name="ln108">  GtkWidget *text;</a>
<a name="ln109">  GtkWidget *colorpick;</a>
<a name="ln110">  GtkWidget *fontsel;</a>
<a name="ln111">  GtkToggleButton *color_picker_button;</a>
<a name="ln112">  dt_iop_color_picker_t color_picker;</a>
<a name="ln113">} dt_iop_watermark_gui_data_t;</a>
<a name="ln114"> </a>
<a name="ln115">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln116">                  void *new_params, const int new_version)</a>
<a name="ln117">{</a>
<a name="ln118">  if(old_version == 1 &amp;&amp; new_version == 4)</a>
<a name="ln119">  {</a>
<a name="ln120">    typedef struct dt_iop_watermark_params_v1_t</a>
<a name="ln121">    {</a>
<a name="ln122">      /** opacity value of rendering watermark */</a>
<a name="ln123">      float opacity;</a>
<a name="ln124">      /** scale value of rendering watermark */</a>
<a name="ln125">      float scale;</a>
<a name="ln126">      /** Pixel independent xoffset, 0 to 1 */</a>
<a name="ln127">      float xoffset;</a>
<a name="ln128">      /** Pixel independent yoffset, 0 to 1 */</a>
<a name="ln129">      float yoffset;</a>
<a name="ln130">      /** Alignment value 0-8 3x3 */</a>
<a name="ln131">      int alignment;</a>
<a name="ln132">      char filename[64];</a>
<a name="ln133">    } dt_iop_watermark_params_v1_t;</a>
<a name="ln134"> </a>
<a name="ln135">    dt_iop_watermark_params_v1_t *o = (dt_iop_watermark_params_v1_t *)old_params;</a>
<a name="ln136">    dt_iop_watermark_params_t *n = (dt_iop_watermark_params_t *)new_params;</a>
<a name="ln137">    dt_iop_watermark_params_t *d = (dt_iop_watermark_params_t *)self-&gt;default_params;</a>
<a name="ln138"> </a>
<a name="ln139">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln140"> </a>
<a name="ln141">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln142">    n-&gt;scale = o-&gt;scale;</a>
<a name="ln143">    n-&gt;xoffset = o-&gt;xoffset;</a>
<a name="ln144">    n-&gt;yoffset = o-&gt;yoffset;</a>
<a name="ln145">    n-&gt;alignment = o-&gt;alignment;</a>
<a name="ln146">    n-&gt;rotate = 0.0;</a>
<a name="ln147">    n-&gt;sizeto = DT_SCALE_IMAGE;</a>
<a name="ln148">    g_strlcpy(n-&gt;filename, o-&gt;filename, sizeof(n-&gt;filename));</a>
<a name="ln149">    g_strlcpy(n-&gt;text, &quot;&quot;, sizeof(n-&gt;text));</a>
<a name="ln150">    g_strlcpy(n-&gt;font, &quot;DejaVu Sans 10&quot;, sizeof(n-&gt;font));</a>
<a name="ln151">    n-&gt;color[0] = n-&gt;color[1] = n-&gt;color[2] = 0;</a>
<a name="ln152">    return 0;</a>
<a name="ln153">  }</a>
<a name="ln154">  else if(old_version == 2 &amp;&amp; new_version == 4)</a>
<a name="ln155">  {</a>
<a name="ln156">    typedef struct dt_iop_watermark_params_v2_t</a>
<a name="ln157">    {</a>
<a name="ln158">      /** opacity value of rendering watermark */</a>
<a name="ln159">      float opacity;</a>
<a name="ln160">      /** scale value of rendering watermark */</a>
<a name="ln161">      float scale;</a>
<a name="ln162">      /** Pixel independent xoffset, 0 to 1 */</a>
<a name="ln163">      float xoffset;</a>
<a name="ln164">      /** Pixel independent yoffset, 0 to 1 */</a>
<a name="ln165">      float yoffset;</a>
<a name="ln166">      /** Alignment value 0-8 3x3 */</a>
<a name="ln167">      int alignment;</a>
<a name="ln168">      dt_iop_watermark_base_scale_t sizeto;</a>
<a name="ln169">      char filename[64];</a>
<a name="ln170">    } dt_iop_watermark_params_v2_t;</a>
<a name="ln171"> </a>
<a name="ln172">    dt_iop_watermark_params_v2_t *o = (dt_iop_watermark_params_v2_t *)old_params;</a>
<a name="ln173">    dt_iop_watermark_params_t *n = (dt_iop_watermark_params_t *)new_params;</a>
<a name="ln174">    dt_iop_watermark_params_t *d = (dt_iop_watermark_params_t *)self-&gt;default_params;</a>
<a name="ln175"> </a>
<a name="ln176">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln177"> </a>
<a name="ln178">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln179">    n-&gt;scale = o-&gt;scale;</a>
<a name="ln180">    n-&gt;xoffset = o-&gt;xoffset;</a>
<a name="ln181">    n-&gt;yoffset = o-&gt;yoffset;</a>
<a name="ln182">    n-&gt;alignment = o-&gt;alignment;</a>
<a name="ln183">    n-&gt;rotate = 0.0;</a>
<a name="ln184">    n-&gt;sizeto = DT_SCALE_IMAGE;</a>
<a name="ln185">    g_strlcpy(n-&gt;filename, o-&gt;filename, sizeof(n-&gt;filename));</a>
<a name="ln186">    g_strlcpy(n-&gt;text, &quot;&quot;, sizeof(n-&gt;text));</a>
<a name="ln187">    g_strlcpy(n-&gt;font, &quot;DejaVu Sans 10&quot;, sizeof(n-&gt;font));</a>
<a name="ln188">    n-&gt;color[0] = n-&gt;color[1] = n-&gt;color[2] = 0;</a>
<a name="ln189">    return 0;</a>
<a name="ln190">  }</a>
<a name="ln191">  else if(old_version == 3 &amp;&amp; new_version == 4)</a>
<a name="ln192">  {</a>
<a name="ln193">    typedef struct dt_iop_watermark_params_v3_t</a>
<a name="ln194">    {</a>
<a name="ln195">      /** opacity value of rendering watermark */</a>
<a name="ln196">      float opacity;</a>
<a name="ln197">      /** scale value of rendering watermark */</a>
<a name="ln198">      float scale;</a>
<a name="ln199">      /** Pixel independent xoffset, 0 to 1 */</a>
<a name="ln200">      float xoffset;</a>
<a name="ln201">      /** Pixel independent yoffset, 0 to 1 */</a>
<a name="ln202">      float yoffset;</a>
<a name="ln203">      /** Alignment value 0-8 3x3 */</a>
<a name="ln204">      int alignment;</a>
<a name="ln205">      /** Rotation **/</a>
<a name="ln206">      float rotate;</a>
<a name="ln207">      dt_iop_watermark_base_scale_t sizeto;</a>
<a name="ln208">      char filename[64];</a>
<a name="ln209">    } dt_iop_watermark_params_v3_t;</a>
<a name="ln210"> </a>
<a name="ln211">    dt_iop_watermark_params_v3_t *o = (dt_iop_watermark_params_v3_t *)old_params;</a>
<a name="ln212">    dt_iop_watermark_params_t *n = (dt_iop_watermark_params_t *)new_params;</a>
<a name="ln213">    dt_iop_watermark_params_t *d = (dt_iop_watermark_params_t *)self-&gt;default_params;</a>
<a name="ln214"> </a>
<a name="ln215">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln216"> </a>
<a name="ln217">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln218">    n-&gt;scale = o-&gt;scale;</a>
<a name="ln219">    n-&gt;xoffset = o-&gt;xoffset;</a>
<a name="ln220">    n-&gt;yoffset = o-&gt;yoffset;</a>
<a name="ln221">    n-&gt;alignment = o-&gt;alignment;</a>
<a name="ln222">    n-&gt;rotate = o-&gt;rotate;</a>
<a name="ln223">    n-&gt;sizeto = o-&gt;sizeto;</a>
<a name="ln224">    g_strlcpy(n-&gt;filename, o-&gt;filename, sizeof(n-&gt;filename));</a>
<a name="ln225">    g_strlcpy(n-&gt;text, &quot;&quot;, sizeof(n-&gt;text));</a>
<a name="ln226">    g_strlcpy(n-&gt;font, &quot;DejaVu Sans 10&quot;, sizeof(n-&gt;font));</a>
<a name="ln227">    n-&gt;color[0] = n-&gt;color[1] = n-&gt;color[2] = 0;</a>
<a name="ln228">    return 0;</a>
<a name="ln229">  }</a>
<a name="ln230">  return 1;</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233"> </a>
<a name="ln234">const char *name()</a>
<a name="ln235">{</a>
<a name="ln236">  return _(&quot;watermark&quot;);</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">int flags()</a>
<a name="ln240">{</a>
<a name="ln241">  return IOP_FLAGS_INCLUDE_IN_STYLES | IOP_FLAGS_SUPPORTS_BLENDING;</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">int default_group()</a>
<a name="ln245">{</a>
<a name="ln246">  return IOP_GROUP_EFFECT;</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">int operation_tags()</a>
<a name="ln250">{</a>
<a name="ln251">  return IOP_TAG_DECORATION;</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln255">{</a>
<a name="ln256">  dt_accel_register_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;refresh&quot;), 0, 0);</a>
<a name="ln257">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;opacity&quot;));</a>
<a name="ln258">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;scale&quot;));</a>
<a name="ln259">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;rotation&quot;));</a>
<a name="ln260">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;x offset&quot;));</a>
<a name="ln261">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;y offset&quot;));</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln265">{</a>
<a name="ln266">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln267"> </a>
<a name="ln268">  dt_accel_connect_button_iop(self, &quot;refresh&quot;, GTK_WIDGET(g-&gt;refresh));</a>
<a name="ln269">  dt_accel_connect_slider_iop(self, &quot;opacity&quot;, GTK_WIDGET(g-&gt;opacity));</a>
<a name="ln270">  dt_accel_connect_slider_iop(self, &quot;scale&quot;, GTK_WIDGET(g-&gt;scale));</a>
<a name="ln271">  dt_accel_connect_slider_iop(self, &quot;rotation&quot;, GTK_WIDGET(g-&gt;rotate));</a>
<a name="ln272">  dt_accel_connect_slider_iop(self, &quot;x offset&quot;, GTK_WIDGET(g-&gt;x_offset));</a>
<a name="ln273">  dt_accel_connect_slider_iop(self, &quot;y offset&quot;, GTK_WIDGET(g-&gt;y_offset));</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">static void _combo_box_set_active_text(dt_iop_watermark_gui_data_t *g, gchar *text)</a>
<a name="ln277">{</a>
<a name="ln278">  int i = 0;</a>
<a name="ln279">  for(const GList *iter = g-&gt;watermarks_filenames; iter; iter = g_list_next(iter))</a>
<a name="ln280">  {</a>
<a name="ln281">    if(!g_strcmp0((gchar *)iter-&gt;data, text))</a>
<a name="ln282">    {</a>
<a name="ln283">      dt_bauhaus_combobox_set(g-&gt;watermarks, i);</a>
<a name="ln284">      return;</a>
<a name="ln285">    }</a>
<a name="ln286">    i++;</a>
<a name="ln287">  }</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">// replace &lt; and &gt; with &amp;lt; and &amp;gt;. any more? Yes! &amp; -&gt; &amp;amp;</a>
<a name="ln291">static gchar *_string_escape(const gchar *string)</a>
<a name="ln292">{</a>
<a name="ln293">  gchar *result, *result_old;</a>
<a name="ln294">  result = dt_util_str_replace(string, &quot;&amp;&quot;, &quot;&amp;amp;&quot;);</a>
<a name="ln295"> </a>
<a name="ln296">  result_old = result;</a>
<a name="ln297">  result = dt_util_str_replace(result_old, &quot;&lt;&quot;, &quot;&amp;lt;&quot;);</a>
<a name="ln298">  g_free(result_old);</a>
<a name="ln299"> </a>
<a name="ln300">  result_old = result;</a>
<a name="ln301">  result = dt_util_str_replace(result_old, &quot;&gt;&quot;, &quot;&amp;gt;&quot;);</a>
<a name="ln302">  g_free(result_old);</a>
<a name="ln303"> </a>
<a name="ln304">  return result;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">static gchar *_string_substitute(gchar *string, const gchar *search, const gchar *replace)</a>
<a name="ln308">{</a>
<a name="ln309">  gchar *_replace = _string_escape(replace);</a>
<a name="ln310">  gchar *result = dt_util_str_replace(string, search, _replace);</a>
<a name="ln311">  g_free(_replace);</a>
<a name="ln312">  return result;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">static gchar *_watermark_get_svgdoc(dt_iop_module_t *self, dt_iop_watermark_data_t *data,</a>
<a name="ln316">                                    const dt_image_t *image)</a>
<a name="ln317">{</a>
<a name="ln318">  gsize length;</a>
<a name="ln319"> </a>
<a name="ln320">  gchar *svgdoc = NULL;</a>
<a name="ln321">  gchar configdir[PATH_MAX] = { 0 };</a>
<a name="ln322">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln323">  gchar *filename;</a>
<a name="ln324">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln325">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln326">  g_strlcat(datadir, &quot;/watermarks/&quot;, sizeof(datadir));</a>
<a name="ln327">  g_strlcat(configdir, &quot;/watermarks/&quot;, sizeof(configdir));</a>
<a name="ln328">  g_strlcat(datadir, data-&gt;filename, sizeof(datadir));</a>
<a name="ln329">  g_strlcat(configdir, data-&gt;filename, sizeof(configdir));</a>
<a name="ln330"> </a>
<a name="ln331">  if(g_file_test(configdir, G_FILE_TEST_EXISTS))</a>
<a name="ln332">    filename = configdir;</a>
<a name="ln333">  else if(g_file_test(datadir, G_FILE_TEST_EXISTS))</a>
<a name="ln334">    filename = datadir;</a>
<a name="ln335">  else</a>
<a name="ln336">    return NULL;</a>
<a name="ln337"> </a>
<a name="ln338">  gchar *svgdata = NULL;</a>
<a name="ln339">  char datetime[200];</a>
<a name="ln340"> </a>
<a name="ln341">  // EXIF datetime</a>
<a name="ln342">  struct tm tt_exif = { 0 };</a>
<a name="ln343">  if(sscanf(image-&gt;exif_datetime_taken, &quot;%d:%d:%d %d:%d:%d&quot;, &amp;tt_exif.tm_year, &amp;tt_exif.tm_mon,</a>
<a name="ln344">            &amp;tt_exif.tm_mday, &amp;tt_exif.tm_hour, &amp;tt_exif.tm_min, &amp;tt_exif.tm_sec) == 6)</a>
<a name="ln345">  {</a>
<a name="ln346">    tt_exif.tm_year -= 1900;</a>
<a name="ln347">    tt_exif.tm_mon--;</a>
<a name="ln348">  }</a>
<a name="ln349"> </a>
<a name="ln350">  // Current datetime</a>
<a name="ln351">  struct tm tt_cur = { 0 };</a>
<a name="ln352">  time_t t = time(NULL);</a>
<a name="ln353">  (void)localtime_r(&amp;t, &amp;tt_cur);</a>
<a name="ln354"> </a>
<a name="ln355">  if(g_file_get_contents(filename, &amp;svgdata, &amp;length, NULL))</a>
<a name="ln356">  {</a>
<a name="ln357">    // File is loaded lets substitute strings if found...</a>
<a name="ln358"> </a>
<a name="ln359">    // Darktable internal</a>
<a name="ln360">    svgdoc = _string_substitute(svgdata, &quot;$(DARKTABLE.NAME)&quot;, PACKAGE_NAME);</a>
<a name="ln361">    if(svgdoc != svgdata)</a>
<a name="ln362">    {</a>
<a name="ln363">      g_free(svgdata);</a>
<a name="ln364">      svgdata = svgdoc;</a>
<a name="ln365">    }</a>
<a name="ln366">    svgdoc = _string_substitute(svgdata, &quot;$(DARKTABLE.VERSION)&quot;, darktable_package_version);</a>
<a name="ln367">    if(svgdoc != svgdata)</a>
<a name="ln368">    {</a>
<a name="ln369">      g_free(svgdata);</a>
<a name="ln370">      svgdata = svgdoc;</a>
<a name="ln371">    }</a>
<a name="ln372"> </a>
<a name="ln373">    // Simple text from watermark module</a>
<a name="ln374">    gchar buffer[1024];</a>
<a name="ln375"> </a>
<a name="ln376">    if (data-&gt;font[0] &amp;&amp; data-&gt;text[0])</a>
<a name="ln377">    {</a>
<a name="ln378">      g_snprintf(buffer, sizeof(buffer), &quot;%s&quot;, data-&gt;text);</a>
<a name="ln379">      svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_TEXT)&quot;, buffer);</a>
<a name="ln380">      if(svgdoc != svgdata)</a>
<a name="ln381">      {</a>
<a name="ln382">        g_free(svgdata);</a>
<a name="ln383">        svgdata = svgdoc;</a>
<a name="ln384">      }</a>
<a name="ln385"> </a>
<a name="ln386">      PangoFontDescription *font = pango_font_description_from_string(data-&gt;font);</a>
<a name="ln387">      const PangoStyle font_style = pango_font_description_get_style(font);</a>
<a name="ln388">      const int font_weight = (int)pango_font_description_get_weight(font);</a>
<a name="ln389"> </a>
<a name="ln390">      g_snprintf(buffer, sizeof(buffer), &quot;%s&quot;, pango_font_description_get_family(font));</a>
<a name="ln391">      svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_FONT_FAMILY)&quot;, buffer);</a>
<a name="ln392">      if(svgdoc != svgdata)</a>
<a name="ln393">      {</a>
<a name="ln394">        g_free(svgdata);</a>
<a name="ln395">        svgdata = svgdoc;</a>
<a name="ln396">      }</a>
<a name="ln397"> </a>
<a name="ln398">      switch (font_style)</a>
<a name="ln399">      {</a>
<a name="ln400">      case PANGO_STYLE_OBLIQUE:</a>
<a name="ln401">        g_strlcpy(buffer, &quot;oblique&quot;, sizeof(buffer));</a>
<a name="ln402">        break;</a>
<a name="ln403">      case PANGO_STYLE_ITALIC:</a>
<a name="ln404">        g_strlcpy(buffer, &quot;italic&quot;, sizeof(buffer));</a>
<a name="ln405">        break;</a>
<a name="ln406">      default:</a>
<a name="ln407">        g_strlcpy(buffer, &quot;normal&quot;, sizeof(buffer));</a>
<a name="ln408">        break;</a>
<a name="ln409">      }</a>
<a name="ln410">      svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_FONT_STYLE)&quot;, buffer);</a>
<a name="ln411">      if(svgdoc != svgdata)</a>
<a name="ln412">      {</a>
<a name="ln413">        g_free(svgdata);</a>
<a name="ln414">        svgdata = svgdoc;</a>
<a name="ln415">      }</a>
<a name="ln416"> </a>
<a name="ln417">      g_snprintf(buffer, sizeof(buffer), &quot;%d&quot;, font_weight);</a>
<a name="ln418">      svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_FONT_WEIGHT)&quot;, buffer);</a>
<a name="ln419">      if(svgdoc != svgdata)</a>
<a name="ln420">      {</a>
<a name="ln421">        g_free(svgdata);</a>
<a name="ln422">        svgdata = svgdoc;</a>
<a name="ln423">      }</a>
<a name="ln424"> </a>
<a name="ln425">      pango_font_description_free(font);</a>
<a name="ln426">    }</a>
<a name="ln427"> </a>
<a name="ln428">    // watermark color</a>
<a name="ln429">    GdkRGBA c = { data-&gt;color[0], data-&gt;color[1], data-&gt;color[2], 1.0f };</a>
<a name="ln430">    g_snprintf(buffer, sizeof(buffer), &quot;%s&quot;, gdk_rgba_to_string(&amp;c));</a>
<a name="ln431">    svgdoc = _string_substitute(svgdata, &quot;$(WATERMARK_COLOR)&quot;, buffer);</a>
<a name="ln432">    if(svgdoc != svgdata)</a>
<a name="ln433">    {</a>
<a name="ln434">      g_free(svgdata);</a>
<a name="ln435">      svgdata = svgdoc;</a>
<a name="ln436">    }</a>
<a name="ln437"> </a>
<a name="ln438">    // Current image ID</a>
<a name="ln439">    g_snprintf(buffer, sizeof(buffer), &quot;%d&quot;, image-&gt;id);</a>
<a name="ln440">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.ID)&quot;, buffer);</a>
<a name="ln441">    if(svgdoc != svgdata)</a>
<a name="ln442">    {</a>
<a name="ln443">      g_free(svgdata);</a>
<a name="ln444">      svgdata = svgdoc;</a>
<a name="ln445">    }</a>
<a name="ln446"> </a>
<a name="ln447">    // Current image</a>
<a name="ln448">    dt_image_print_exif(image, buffer, sizeof(buffer));</a>
<a name="ln449">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.EXIF)&quot;, buffer);</a>
<a name="ln450">    if(svgdoc != svgdata)</a>
<a name="ln451">    {</a>
<a name="ln452">      g_free(svgdata);</a>
<a name="ln453">      svgdata = svgdoc;</a>
<a name="ln454">    }</a>
<a name="ln455"> </a>
<a name="ln456">    // Image exif</a>
<a name="ln457">    // EXIF date</a>
<a name="ln458">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE)&quot;, image-&gt;exif_datetime_taken);</a>
<a name="ln459">    if(svgdoc != svgdata)</a>
<a name="ln460">    {</a>
<a name="ln461">      g_free(svgdata);</a>
<a name="ln462">      svgdata = svgdoc;</a>
<a name="ln463">    }</a>
<a name="ln464">    // $(EXIF.DATE.SECOND) -- 00..60</a>
<a name="ln465">    strftime(datetime, sizeof(datetime), &quot;%S&quot;, &amp;tt_exif);</a>
<a name="ln466">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.SECOND)&quot;, datetime);</a>
<a name="ln467">    if(svgdoc != svgdata)</a>
<a name="ln468">    {</a>
<a name="ln469">      g_free(svgdata);</a>
<a name="ln470">      svgdata = svgdoc;</a>
<a name="ln471">    }</a>
<a name="ln472">    // $(EXIF.DATE.MINUTE) -- 00..59</a>
<a name="ln473">    strftime(datetime, sizeof(datetime), &quot;%M&quot;, &amp;tt_exif);</a>
<a name="ln474">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.MINUTE)&quot;, datetime);</a>
<a name="ln475">    if(svgdoc != svgdata)</a>
<a name="ln476">    {</a>
<a name="ln477">      g_free(svgdata);</a>
<a name="ln478">      svgdata = svgdoc;</a>
<a name="ln479">    }</a>
<a name="ln480">    // $(EXIF.DATE.HOUR) -- 00..23</a>
<a name="ln481">    strftime(datetime, sizeof(datetime), &quot;%H&quot;, &amp;tt_exif);</a>
<a name="ln482">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.HOUR)&quot;, datetime);</a>
<a name="ln483">    if(svgdoc != svgdata)</a>
<a name="ln484">    {</a>
<a name="ln485">      g_free(svgdata);</a>
<a name="ln486">      svgdata = svgdoc;</a>
<a name="ln487">    }</a>
<a name="ln488">    // $(EXIF.DATE.HOUR_AMPM) -- 01..12</a>
<a name="ln489">    strftime(datetime, sizeof(datetime), &quot;%I %p&quot;, &amp;tt_exif);</a>
<a name="ln490">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.HOUR_AMPM)&quot;, datetime);</a>
<a name="ln491">    if(svgdoc != svgdata)</a>
<a name="ln492">    {</a>
<a name="ln493">      g_free(svgdata);</a>
<a name="ln494">      svgdata = svgdoc;</a>
<a name="ln495">    }</a>
<a name="ln496">    // $(EXIF.DATE.DAY) -- 01..31</a>
<a name="ln497">    strftime(datetime, sizeof(datetime), &quot;%d&quot;, &amp;tt_exif);</a>
<a name="ln498">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.DAY)&quot;, datetime);</a>
<a name="ln499">    if(svgdoc != svgdata)</a>
<a name="ln500">    {</a>
<a name="ln501">      g_free(svgdata);</a>
<a name="ln502">      svgdata = svgdoc;</a>
<a name="ln503">    }</a>
<a name="ln504">    // $(EXIF.DATE.MONTH) -- 01..12</a>
<a name="ln505">    strftime(datetime, sizeof(datetime), &quot;%m&quot;, &amp;tt_exif);</a>
<a name="ln506">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.MONTH)&quot;, datetime);</a>
<a name="ln507">    if(svgdoc != svgdata)</a>
<a name="ln508">    {</a>
<a name="ln509">      g_free(svgdata);</a>
<a name="ln510">      svgdata = svgdoc;</a>
<a name="ln511">    }</a>
<a name="ln512">    // $(EXIF.DATE.SHORT_MONTH) -- Jan, Feb, .., Dec, localized</a>
<a name="ln513">    strftime(datetime, sizeof(datetime), &quot;%b&quot;, &amp;tt_exif);</a>
<a name="ln514">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.SHORT_MONTH)&quot;, datetime);</a>
<a name="ln515">    if(svgdoc != svgdata)</a>
<a name="ln516">    {</a>
<a name="ln517">      g_free(svgdata);</a>
<a name="ln518">      svgdata = svgdoc;</a>
<a name="ln519">    }</a>
<a name="ln520">    // $(EXIF.DATE.LONG_MONTH) -- January, February, .., December, localized</a>
<a name="ln521">    strftime(datetime, sizeof(datetime), &quot;%B&quot;, &amp;tt_exif);</a>
<a name="ln522">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.LONG_MONTH)&quot;, datetime);</a>
<a name="ln523">    if(svgdoc != svgdata)</a>
<a name="ln524">    {</a>
<a name="ln525">      g_free(svgdata);</a>
<a name="ln526">      svgdata = svgdoc;</a>
<a name="ln527">    }</a>
<a name="ln528">    // $(EXIF.DATE.SHORT_YEAR) -- 12</a>
<a name="ln529">    strftime(datetime, sizeof(datetime), &quot;%y&quot;, &amp;tt_exif);</a>
<a name="ln530">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.SHORT_YEAR)&quot;, datetime);</a>
<a name="ln531">    if(svgdoc != svgdata)</a>
<a name="ln532">    {</a>
<a name="ln533">      g_free(svgdata);</a>
<a name="ln534">      svgdata = svgdoc;</a>
<a name="ln535">    }</a>
<a name="ln536">    // $(EXIF.DATE.LONG_YEAR) -- 2012</a>
<a name="ln537">    strftime(datetime, sizeof(datetime), &quot;%Y&quot;, &amp;tt_exif);</a>
<a name="ln538">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.DATE.LONG_YEAR)&quot;, datetime);</a>
<a name="ln539">    if(svgdoc != svgdata)</a>
<a name="ln540">    {</a>
<a name="ln541">      g_free(svgdata);</a>
<a name="ln542">      svgdata = svgdoc;</a>
<a name="ln543">    }</a>
<a name="ln544"> </a>
<a name="ln545">    // Current date</a>
<a name="ln546">    // $(DATE) -- YYYY:</a>
<a name="ln547">    dt_gettime_t(datetime, sizeof(datetime), t);</a>
<a name="ln548">    svgdoc = _string_substitute(svgdata, &quot;$(DATE)&quot;, datetime);</a>
<a name="ln549">    if(svgdoc != svgdata)</a>
<a name="ln550">    {</a>
<a name="ln551">      g_free(svgdata);</a>
<a name="ln552">      svgdata = svgdoc;</a>
<a name="ln553">    }</a>
<a name="ln554">    // $(DATE.SECOND) -- 00..60</a>
<a name="ln555">    strftime(datetime, sizeof(datetime), &quot;%S&quot;, &amp;tt_cur);</a>
<a name="ln556">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.SECOND)&quot;, datetime);</a>
<a name="ln557">    if(svgdoc != svgdata)</a>
<a name="ln558">    {</a>
<a name="ln559">      g_free(svgdata);</a>
<a name="ln560">      svgdata = svgdoc;</a>
<a name="ln561">    }</a>
<a name="ln562">    // $(DATE.MINUTE) -- 00..59</a>
<a name="ln563">    strftime(datetime, sizeof(datetime), &quot;%M&quot;, &amp;tt_cur);</a>
<a name="ln564">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.MINUTE)&quot;, datetime);</a>
<a name="ln565">    if(svgdoc != svgdata)</a>
<a name="ln566">    {</a>
<a name="ln567">      g_free(svgdata);</a>
<a name="ln568">      svgdata = svgdoc;</a>
<a name="ln569">    }</a>
<a name="ln570">    // $(DATE.HOUR) -- 00..23</a>
<a name="ln571">    strftime(datetime, sizeof(datetime), &quot;%H&quot;, &amp;tt_cur);</a>
<a name="ln572">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.HOUR)&quot;, datetime);</a>
<a name="ln573">    if(svgdoc != svgdata)</a>
<a name="ln574">    {</a>
<a name="ln575">      g_free(svgdata);</a>
<a name="ln576">      svgdata = svgdoc;</a>
<a name="ln577">    }</a>
<a name="ln578">    // $(DATE.HOUR_AMPM) -- 01..12</a>
<a name="ln579">    strftime(datetime, sizeof(datetime), &quot;%I %p&quot;, &amp;tt_cur);</a>
<a name="ln580">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.HOUR_AMPM)&quot;, datetime);</a>
<a name="ln581">    if(svgdoc != svgdata)</a>
<a name="ln582">    {</a>
<a name="ln583">      g_free(svgdata);</a>
<a name="ln584">      svgdata = svgdoc;</a>
<a name="ln585">    }</a>
<a name="ln586">    // $(DATE.DAY) -- 01..31</a>
<a name="ln587">    strftime(datetime, sizeof(datetime), &quot;%d&quot;, &amp;tt_cur);</a>
<a name="ln588">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.DAY)&quot;, datetime);</a>
<a name="ln589">    if(svgdoc != svgdata)</a>
<a name="ln590">    {</a>
<a name="ln591">      g_free(svgdata);</a>
<a name="ln592">      svgdata = svgdoc;</a>
<a name="ln593">    }</a>
<a name="ln594">    // $(DATE.MONTH) -- 01..12</a>
<a name="ln595">    strftime(datetime, sizeof(datetime), &quot;%m&quot;, &amp;tt_cur);</a>
<a name="ln596">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.MONTH)&quot;, datetime);</a>
<a name="ln597">    if(svgdoc != svgdata)</a>
<a name="ln598">    {</a>
<a name="ln599">      g_free(svgdata);</a>
<a name="ln600">      svgdata = svgdoc;</a>
<a name="ln601">    }</a>
<a name="ln602">    // $(DATE.SHORT_MONTH) -- Jan, Feb, .., Dec, localized</a>
<a name="ln603">    strftime(datetime, sizeof(datetime), &quot;%b&quot;, &amp;tt_cur);</a>
<a name="ln604">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.SHORT_MONTH)&quot;, datetime);</a>
<a name="ln605">    if(svgdoc != svgdata)</a>
<a name="ln606">    {</a>
<a name="ln607">      g_free(svgdata);</a>
<a name="ln608">      svgdata = svgdoc;</a>
<a name="ln609">    }</a>
<a name="ln610">    // $(DATE.LONG_MONTH) -- January, February, .., December, localized</a>
<a name="ln611">    strftime(datetime, sizeof(datetime), &quot;%B&quot;, &amp;tt_cur);</a>
<a name="ln612">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.LONG_MONTH)&quot;, datetime);</a>
<a name="ln613">    if(svgdoc != svgdata)</a>
<a name="ln614">    {</a>
<a name="ln615">      g_free(svgdata);</a>
<a name="ln616">      svgdata = svgdoc;</a>
<a name="ln617">    }</a>
<a name="ln618">    // $(DATE.SHORT_YEAR) -- 12</a>
<a name="ln619">    strftime(datetime, sizeof(datetime), &quot;%y&quot;, &amp;tt_cur);</a>
<a name="ln620">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.SHORT_YEAR)&quot;, datetime);</a>
<a name="ln621">    if(svgdoc != svgdata)</a>
<a name="ln622">    {</a>
<a name="ln623">      g_free(svgdata);</a>
<a name="ln624">      svgdata = svgdoc;</a>
<a name="ln625">    }</a>
<a name="ln626">    // $(DATE.LONG_YEAR) -- 2012</a>
<a name="ln627">    strftime(datetime, sizeof(datetime), &quot;%Y&quot;, &amp;tt_cur);</a>
<a name="ln628">    svgdoc = _string_substitute(svgdata, &quot;$(DATE.LONG_YEAR)&quot;, datetime);</a>
<a name="ln629">    if(svgdoc != svgdata)</a>
<a name="ln630">    {</a>
<a name="ln631">      g_free(svgdata);</a>
<a name="ln632">      svgdata = svgdoc;</a>
<a name="ln633">    }</a>
<a name="ln634"> </a>
<a name="ln635">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.MAKER)&quot;, image-&gt;camera_maker);</a>
<a name="ln636">    if(svgdoc != svgdata)</a>
<a name="ln637">    {</a>
<a name="ln638">      g_free(svgdata);</a>
<a name="ln639">      svgdata = svgdoc;</a>
<a name="ln640">    }</a>
<a name="ln641">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.MODEL)&quot;, image-&gt;camera_model);</a>
<a name="ln642">    if(svgdoc != svgdata)</a>
<a name="ln643">    {</a>
<a name="ln644">      g_free(svgdata);</a>
<a name="ln645">      svgdata = svgdoc;</a>
<a name="ln646">    }</a>
<a name="ln647">    svgdoc = _string_substitute(svgdata, &quot;$(EXIF.LENS)&quot;, image-&gt;exif_lens);</a>
<a name="ln648">    if(svgdoc != svgdata)</a>
<a name="ln649">    {</a>
<a name="ln650">      g_free(svgdata);</a>
<a name="ln651">      svgdata = svgdoc;</a>
<a name="ln652">    }</a>
<a name="ln653"> </a>
<a name="ln654">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.FILENAME)&quot;, image-&gt;filename);</a>
<a name="ln655">    if(svgdoc != svgdata)</a>
<a name="ln656">    {</a>
<a name="ln657">      g_free(svgdata);</a>
<a name="ln658">      svgdata = svgdoc;</a>
<a name="ln659">    }</a>
<a name="ln660"> </a>
<a name="ln661">    gchar *basename = g_path_get_basename(image-&gt;filename);</a>
<a name="ln662">    if(g_strrstr(basename, &quot;.&quot;)) *(g_strrstr(basename, &quot;.&quot;)) = '\0';</a>
<a name="ln663">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.BASENAME)&quot;, basename);</a>
<a name="ln664">    if(svgdoc != svgdata)</a>
<a name="ln665">    {</a>
<a name="ln666">      g_free(svgdata);</a>
<a name="ln667">      svgdata = svgdoc;</a>
<a name="ln668">    }</a>
<a name="ln669">    g_free(basename);</a>
<a name="ln670"> </a>
<a name="ln671">    // TODO: auto generate that code?</a>
<a name="ln672">    GList *res;</a>
<a name="ln673">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.creator&quot;, NULL);</a>
<a name="ln674">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.creator)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln675">    if(svgdoc != svgdata)</a>
<a name="ln676">    {</a>
<a name="ln677">      g_free(svgdata);</a>
<a name="ln678">      svgdata = svgdoc;</a>
<a name="ln679">    }</a>
<a name="ln680">    if(res)</a>
<a name="ln681">    {</a>
<a name="ln682">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln683">    }</a>
<a name="ln684"> </a>
<a name="ln685">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.publisher&quot;, NULL);</a>
<a name="ln686">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.publisher)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln687">    if(svgdoc != svgdata)</a>
<a name="ln688">    {</a>
<a name="ln689">      g_free(svgdata);</a>
<a name="ln690">      svgdata = svgdoc;</a>
<a name="ln691">    }</a>
<a name="ln692">    if(res)</a>
<a name="ln693">    {</a>
<a name="ln694">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln695">    }</a>
<a name="ln696"> </a>
<a name="ln697">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.title&quot;, NULL);</a>
<a name="ln698">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.title)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln699">    if(svgdoc != svgdata)</a>
<a name="ln700">    {</a>
<a name="ln701">      g_free(svgdata);</a>
<a name="ln702">      svgdata = svgdoc;</a>
<a name="ln703">    }</a>
<a name="ln704">    if(res)</a>
<a name="ln705">    {</a>
<a name="ln706">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln707">    }</a>
<a name="ln708"> </a>
<a name="ln709">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.description&quot;, NULL);</a>
<a name="ln710">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.description)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln711">    if(svgdoc != svgdata)</a>
<a name="ln712">    {</a>
<a name="ln713">      g_free(svgdata);</a>
<a name="ln714">      svgdata = svgdoc;</a>
<a name="ln715">    }</a>
<a name="ln716">    if(res)</a>
<a name="ln717">    {</a>
<a name="ln718">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln719">    }</a>
<a name="ln720"> </a>
<a name="ln721">    res = dt_metadata_get(image-&gt;id, &quot;Xmp.dc.rights&quot;, NULL);</a>
<a name="ln722">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.dc.rights)&quot;, (res ? res-&gt;data : &quot;&quot;));</a>
<a name="ln723">    if(svgdoc != svgdata)</a>
<a name="ln724">    {</a>
<a name="ln725">      g_free(svgdata);</a>
<a name="ln726">      svgdata = svgdoc;</a>
<a name="ln727">    }</a>
<a name="ln728">    if(res)</a>
<a name="ln729">    {</a>
<a name="ln730">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln731">    }</a>
<a name="ln732"> </a>
<a name="ln733">    res = dt_tag_get_list(image-&gt;id);</a>
<a name="ln734">    gchar *keywords = dt_util_glist_to_str(&quot;, &quot;, res);</a>
<a name="ln735">    svgdoc = _string_substitute(svgdata, &quot;$(IMAGE.TAGS)&quot;, (keywords ? keywords : &quot;&quot;));</a>
<a name="ln736">    if(svgdoc != svgdata)</a>
<a name="ln737">    {</a>
<a name="ln738">      g_free(svgdata);</a>
<a name="ln739">      svgdata = svgdoc;</a>
<a name="ln740">    }</a>
<a name="ln741">    g_free(keywords);</a>
<a name="ln742">    if(res)</a>
<a name="ln743">    {</a>
<a name="ln744">      g_list_free_full(res, &amp;g_free);</a>
<a name="ln745">    }</a>
<a name="ln746"> </a>
<a name="ln747">    const int stars = image-&gt;flags &amp; 0x7;</a>
<a name="ln748">    const char *const rating_str[] = { &quot;☆☆☆☆☆&quot;, &quot;★☆☆☆☆&quot;, &quot;★★☆☆☆&quot;, &quot;★★★☆☆&quot;, &quot;★★★★☆&quot;, &quot;★★★★★&quot;, &quot;❌&quot;, &quot;&quot; };</a>
<a name="ln749">    svgdoc = _string_substitute(svgdata, &quot;$(Xmp.xmp.Rating)&quot;, rating_str[stars]);</a>
<a name="ln750">    if(svgdoc != svgdata)</a>
<a name="ln751">    {</a>
<a name="ln752">      g_free(svgdata);</a>
<a name="ln753">      svgdata = svgdoc;</a>
<a name="ln754">    }</a>
<a name="ln755"> </a>
<a name="ln756">    // geolocation</a>
<a name="ln757">    gchar *latitude = NULL, *longitude = NULL, *elevation = NULL;</a>
<a name="ln758">    if(dt_conf_get_bool(&quot;plugins/lighttable/metadata_view/pretty_location&quot;))</a>
<a name="ln759">    {</a>
<a name="ln760">      latitude = dt_util_latitude_str(image-&gt;latitude);</a>
<a name="ln761">      longitude = dt_util_longitude_str(image-&gt;longitude);</a>
<a name="ln762">      elevation = dt_util_elevation_str(image-&gt;elevation);</a>
<a name="ln763">    }</a>
<a name="ln764">    else</a>
<a name="ln765">    {</a>
<a name="ln766">      const gchar NS = image-&gt;latitude &lt; 0 ? 'S' : 'N';</a>
<a name="ln767">      const gchar EW = image-&gt;longitude &lt; 0 ? 'W' : 'E';</a>
<a name="ln768">      if(image-&gt;latitude) latitude = g_strdup_printf(&quot;%c %09.6f&quot;, NS, fabs(image-&gt;latitude));</a>
<a name="ln769">      if(image-&gt;longitude) longitude = g_strdup_printf(&quot;%c %010.6f&quot;, EW, fabs(image-&gt;longitude));</a>
<a name="ln770">      if(image-&gt;elevation) elevation = g_strdup_printf(&quot;%.2f %s&quot;, image-&gt;elevation, _(&quot;m&quot;));</a>
<a name="ln771">    }</a>
<a name="ln772">    gchar *parts[4] = { 0 };</a>
<a name="ln773">    int i = 0;</a>
<a name="ln774">    if(latitude) parts[i++] = latitude;</a>
<a name="ln775">    if(longitude) parts[i++] = longitude;</a>
<a name="ln776">    if(elevation) parts[i++] = elevation;</a>
<a name="ln777">    gchar *location = g_strjoinv(&quot;, &quot;, parts);</a>
<a name="ln778">    svgdoc = _string_substitute(svgdata, &quot;$(GPS.LATITUDE)&quot;, (latitude ? latitude : &quot;-&quot;));</a>
<a name="ln779">    if(svgdoc != svgdata)</a>
<a name="ln780">    {</a>
<a name="ln781">      g_free(svgdata);</a>
<a name="ln782">      svgdata = svgdoc;</a>
<a name="ln783">    }</a>
<a name="ln784">    svgdoc = _string_substitute(svgdata, &quot;$(GPS.LONGITUDE)&quot;, (longitude ? longitude : &quot;-&quot;));</a>
<a name="ln785">    if(svgdoc != svgdata)</a>
<a name="ln786">    {</a>
<a name="ln787">      g_free(svgdata);</a>
<a name="ln788">      svgdata = svgdoc;</a>
<a name="ln789">    }</a>
<a name="ln790">    svgdoc = _string_substitute(svgdata, &quot;$(GPS.ELEVATION)&quot;, (elevation ? elevation : &quot;-&quot;));</a>
<a name="ln791">    if(svgdoc != svgdata)</a>
<a name="ln792">    {</a>
<a name="ln793">      g_free(svgdata);</a>
<a name="ln794">      svgdata = svgdoc;</a>
<a name="ln795">    }</a>
<a name="ln796">    svgdoc = _string_substitute(svgdata, &quot;$(GPS.LOCATION)&quot;, location);</a>
<a name="ln797">    if(svgdoc != svgdata)</a>
<a name="ln798">    {</a>
<a name="ln799">      g_free(svgdata);</a>
<a name="ln800">      svgdata = svgdoc;</a>
<a name="ln801">    }</a>
<a name="ln802">    g_free(latitude);</a>
<a name="ln803">    g_free(longitude);</a>
<a name="ln804">    g_free(elevation);</a>
<a name="ln805">    g_free(location);</a>
<a name="ln806"> </a>
<a name="ln807">  }</a>
<a name="ln808">  return svgdoc;</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln812">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln813">{</a>
<a name="ln814">  dt_iop_watermark_data_t *data = (dt_iop_watermark_data_t *)piece-&gt;data;</a>
<a name="ln815">  float *in = (float *)ivoid;</a>
<a name="ln816">  float *out = (float *)ovoid;</a>
<a name="ln817">  const int ch = piece-&gt;colors;</a>
<a name="ln818">  const float angle = (M_PI / 180) * (-data-&gt;rotate);</a>
<a name="ln819"> </a>
<a name="ln820">  /* Load svg if not loaded */</a>
<a name="ln821">  gchar *svgdoc = _watermark_get_svgdoc(self, data, &amp;piece-&gt;pipe-&gt;image);</a>
<a name="ln822">  if(!svgdoc)</a>
<a name="ln823">  {</a>
<a name="ln824">    memcpy(ovoid, ivoid, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln825">    return;</a>
<a name="ln826">  }</a>
<a name="ln827"> </a>
<a name="ln828">  /* setup stride for performance */</a>
<a name="ln829">  int stride = cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, roi_out-&gt;width);</a>
<a name="ln830"> </a>
<a name="ln831">  /* create cairo memory surface */</a>
<a name="ln832">  guint8 *image = (guint8 *)g_malloc0_n(roi_out-&gt;height, stride);</a>
<a name="ln833">  cairo_surface_t *surface = cairo_image_surface_create_for_data(image, CAIRO_FORMAT_ARGB32, roi_out-&gt;width,</a>
<a name="ln834">                                                                 roi_out-&gt;height, stride);</a>
<a name="ln835">  if(cairo_surface_status(surface) != CAIRO_STATUS_SUCCESS)</a>
<a name="ln836">  {</a>
<a name="ln837">    //   fprintf(stderr,&quot;Cairo surface error: %s\n&quot;,cairo_status_to_string(cairo_surface_status(surface)));</a>
<a name="ln838">    g_free(image);</a>
<a name="ln839">    memcpy(ovoid, ivoid, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln840">    return;</a>
<a name="ln841">  }</a>
<a name="ln842"> </a>
<a name="ln843">  /* create cairo context and setup transformation/scale */</a>
<a name="ln844">  cairo_t *cr = cairo_create(surface);</a>
<a name="ln845"> </a>
<a name="ln846">  // rsvg (or some part of cairo which is used underneath) isn't thread safe, for example when handling fonts</a>
<a name="ln847">  dt_pthread_mutex_lock(&amp;darktable.plugin_threadsafe);</a>
<a name="ln848"> </a>
<a name="ln849">  /* create the rsvghandle from parsed svg data */</a>
<a name="ln850">  GError *error = NULL;</a>
<a name="ln851">  RsvgHandle *svg = rsvg_handle_new_from_data((const guint8 *)svgdoc, strlen(svgdoc), &amp;error);</a>
<a name="ln852">  g_free(svgdoc);</a>
<a name="ln853">  if(!svg || error)</a>
<a name="ln854">  {</a>
<a name="ln855">    g_free(image);</a>
<a name="ln856">    memcpy(ovoid, ivoid, (size_t)sizeof(float) * ch * roi_out-&gt;width * roi_out-&gt;height);</a>
<a name="ln857">    dt_pthread_mutex_unlock(&amp;darktable.plugin_threadsafe);</a>
<a name="ln858">    fprintf(stderr, &quot;[watermark] error processing svg file: %s\n&quot;, error-&gt;message);</a>
<a name="ln859">    g_error_free(error);</a>
<a name="ln860">    return;</a>
<a name="ln861">  }</a>
<a name="ln862"> </a>
<a name="ln863">  /* get the dimension of svg */</a>
<a name="ln864">  RsvgDimensionData dimension;</a>
<a name="ln865">  rsvg_handle_get_dimensions(svg, &amp;dimension);</a>
<a name="ln866"> </a>
<a name="ln867">  //  width/height of current (possibly cropped) image</a>
<a name="ln868">  const float iw = piece-&gt;buf_in.width;</a>
<a name="ln869">  const float ih = piece-&gt;buf_in.height;</a>
<a name="ln870">  const float uscale = data-&gt;scale / 100.0f; // user scale, from GUI in percent</a>
<a name="ln871"> </a>
<a name="ln872">  // wbase, hbase are the base width and height, this is the multiplicator used for the offset computing</a>
<a name="ln873">  // scale is the scale of the watermark itself and is used only to render it.</a>
<a name="ln874"> </a>
<a name="ln875">  float wbase, hbase, scale;</a>
<a name="ln876"> </a>
<a name="ln877">  if(data-&gt;sizeto == DT_SCALE_IMAGE)</a>
<a name="ln878">  {</a>
<a name="ln879">    // in image mode, the wbase and hbase are just the image width and height</a>
<a name="ln880">    wbase = iw;</a>
<a name="ln881">    hbase = ih;</a>
<a name="ln882">    if(dimension.width &gt; dimension.height)</a>
<a name="ln883">      scale = (iw * roi_out-&gt;scale) / dimension.width;</a>
<a name="ln884">    else</a>
<a name="ln885">      scale = (ih * roi_out-&gt;scale) / dimension.height;</a>
<a name="ln886">  }</a>
<a name="ln887">  else</a>
<a name="ln888">  {</a>
<a name="ln889">    // in larger/smaller side mode, set wbase and hbase to the largest or smallest side of the image</a>
<a name="ln890">    float larger;</a>
<a name="ln891">    if(dimension.width &gt; dimension.height)</a>
<a name="ln892">      larger = (float)dimension.width;</a>
<a name="ln893">    else</a>
<a name="ln894">      larger = (float)dimension.height;</a>
<a name="ln895"> </a>
<a name="ln896">    if(iw &gt; ih)</a>
<a name="ln897">    {</a>
<a name="ln898">      wbase = hbase = (data-&gt;sizeto == DT_SCALE_LARGER_BORDER) ? iw : ih;</a>
<a name="ln899">      scale = (data-&gt;sizeto == DT_SCALE_LARGER_BORDER) ? (iw / larger) : (ih / larger);</a>
<a name="ln900">    }</a>
<a name="ln901">    else</a>
<a name="ln902">    {</a>
<a name="ln903">      wbase = hbase = (data-&gt;sizeto == DT_SCALE_SMALLER_BORDER) ? iw : ih;</a>
<a name="ln904">      scale = (data-&gt;sizeto == DT_SCALE_SMALLER_BORDER) ? (iw / larger) : (ih / larger);</a>
<a name="ln905">    }</a>
<a name="ln906">    scale *= roi_out-&gt;scale;</a>
<a name="ln907">  }</a>
<a name="ln908"> </a>
<a name="ln909">  scale *= uscale;</a>
<a name="ln910"> </a>
<a name="ln911">  // compute the width and height of the SVG object in image dimension. This is only used to properly</a>
<a name="ln912">  // layout the watermark based on the alignment.</a>
<a name="ln913"> </a>
<a name="ln914">  float svg_width, svg_height;</a>
<a name="ln915"> </a>
<a name="ln916">  if(dimension.width &gt; dimension.height)</a>
<a name="ln917">  {</a>
<a name="ln918">    if(data-&gt;sizeto == DT_SCALE_IMAGE || (iw &gt; ih &amp;&amp; data-&gt;sizeto == DT_SCALE_LARGER_BORDER)</a>
<a name="ln919">       || (iw &lt; ih &amp;&amp; data-&gt;sizeto == DT_SCALE_SMALLER_BORDER))</a>
<a name="ln920">    {</a>
<a name="ln921">      svg_width = iw * uscale;</a>
<a name="ln922">      svg_height = dimension.height * (svg_width / dimension.width);</a>
<a name="ln923">    }</a>
<a name="ln924">    else</a>
<a name="ln925">    {</a>
<a name="ln926">      svg_width = ih * uscale;</a>
<a name="ln927">      svg_height = dimension.height * (svg_width / dimension.width);</a>
<a name="ln928">    }</a>
<a name="ln929">  }</a>
<a name="ln930">  else</a>
<a name="ln931">  {</a>
<a name="ln932">    if(data-&gt;sizeto == DT_SCALE_IMAGE || (ih &gt; iw &amp;&amp; data-&gt;sizeto == DT_SCALE_LARGER_BORDER)</a>
<a name="ln933">       || (ih &lt; iw &amp;&amp; data-&gt;sizeto == DT_SCALE_SMALLER_BORDER))</a>
<a name="ln934">    {</a>
<a name="ln935">      svg_height = ih * uscale;</a>
<a name="ln936">      svg_width = dimension.width * (svg_height / dimension.height);</a>
<a name="ln937">    }</a>
<a name="ln938">    else</a>
<a name="ln939">    {</a>
<a name="ln940">      svg_height = iw * uscale;</a>
<a name="ln941">      svg_width = dimension.width * (svg_height / dimension.height);</a>
<a name="ln942">    }</a>
<a name="ln943">  }</a>
<a name="ln944"> </a>
<a name="ln945">  // compute bounding box of rotated watermark</a>
<a name="ln946">  const float bb_width = fabsf(svg_width * cosf(angle)) + fabsf(svg_height * sinf(angle));</a>
<a name="ln947">  const float bb_height = fabsf(svg_width * sinf(angle)) + fabsf(svg_height * cosf(angle));</a>
<a name="ln948">  const float bX = bb_width / 2.0f - svg_width / 2.0f;</a>
<a name="ln949">  const float bY = bb_height / 2.0f - svg_height / 2.0f;</a>
<a name="ln950"> </a>
<a name="ln951">  // compute translation for the given alignment in image dimension</a>
<a name="ln952"> </a>
<a name="ln953">  float ty = 0, tx = 0;</a>
<a name="ln954">  if(data-&gt;alignment &gt;= 0 &amp;&amp; data-&gt;alignment &lt; 3) // Align to verttop</a>
<a name="ln955">    ty = bY;</a>
<a name="ln956">  else if(data-&gt;alignment &gt;= 3 &amp;&amp; data-&gt;alignment &lt; 6) // Align to vertcenter</a>
<a name="ln957">    ty = (ih / 2.0f) - (svg_height / 2.0f);</a>
<a name="ln958">  else if(data-&gt;alignment &gt;= 6 &amp;&amp; data-&gt;alignment &lt; 9) // Align to vertbottom</a>
<a name="ln959">    ty = ih - svg_height - bY;</a>
<a name="ln960"> </a>
<a name="ln961">  if(data-&gt;alignment == 0 || data-&gt;alignment == 3 || data-&gt;alignment == 6)</a>
<a name="ln962">    tx = bX;</a>
<a name="ln963">  else if(data-&gt;alignment == 1 || data-&gt;alignment == 4 || data-&gt;alignment == 7)</a>
<a name="ln964">    tx = (iw / 2.0f) - (svg_width / 2.0f);</a>
<a name="ln965">  else if(data-&gt;alignment == 2 || data-&gt;alignment == 5 || data-&gt;alignment == 8)</a>
<a name="ln966">    tx = iw - svg_width - bX;</a>
<a name="ln967"> </a>
<a name="ln968">  // translate to position</a>
<a name="ln969">  cairo_translate(cr, -roi_in-&gt;x, -roi_in-&gt;y);</a>
<a name="ln970"> </a>
<a name="ln971">  // add translation for the given value in GUI (xoffset,yoffset)</a>
<a name="ln972">  tx += data-&gt;xoffset * wbase;</a>
<a name="ln973">  ty += data-&gt;yoffset * hbase;</a>
<a name="ln974"> </a>
<a name="ln975">  cairo_translate(cr, tx * roi_out-&gt;scale, ty * roi_out-&gt;scale);</a>
<a name="ln976"> </a>
<a name="ln977">  // compute the center of the svg to rotate from the center</a>
<a name="ln978">  const float cX = svg_width / 2.0f * roi_out-&gt;scale;</a>
<a name="ln979">  const float cY = svg_height / 2.0f * roi_out-&gt;scale;</a>
<a name="ln980"> </a>
<a name="ln981">  cairo_translate(cr, cX, cY);</a>
<a name="ln982">  cairo_rotate(cr, angle);</a>
<a name="ln983">  cairo_translate(cr, -cX, -cY);</a>
<a name="ln984"> </a>
<a name="ln985">  // now set proper scale for the watermark itself</a>
<a name="ln986">  cairo_scale(cr, scale, scale);</a>
<a name="ln987"> </a>
<a name="ln988">  /* render svg into surface*/</a>
<a name="ln989">  rsvg_handle_render_cairo(svg, cr);</a>
<a name="ln990"> </a>
<a name="ln991">  // no more non-thread safe rsvg usage</a>
<a name="ln992">  dt_pthread_mutex_unlock(&amp;darktable.plugin_threadsafe);</a>
<a name="ln993"> </a>
<a name="ln994">  cairo_destroy(cr);</a>
<a name="ln995"> </a>
<a name="ln996">  /* ensure that all operations on surface finishing up */</a>
<a name="ln997">  cairo_surface_flush(surface);</a>
<a name="ln998"> </a>
<a name="ln999">  /* render surface on output */</a>
<a name="ln1000">  guint8 *sd = image;</a>
<a name="ln1001">  const float opacity = data-&gt;opacity / 100.0f;</a>
<a name="ln1002">  /*</a>
<a name="ln1003">  #ifdef _OPENMP</a>
<a name="ln1004">    #pragma omp parallel for default(none) shared(in, out,sd,opacity) schedule(static)</a>
<a name="ln1005">  #endif</a>
<a name="ln1006">  */</a>
<a name="ln1007">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln1008">    for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln1009">    {</a>
<a name="ln1010">      const float alpha = (sd[3] / 255.0f) * opacity;</a>
<a name="ln1011">      /* svg uses a premultiplied alpha, so only use opacity for the blending */</a>
<a name="ln1012">      out[0] = ((1.0f - alpha) * in[0]) + (opacity * (sd[2] / 255.0f));</a>
<a name="ln1013">      out[1] = ((1.0f - alpha) * in[1]) + (opacity * (sd[1] / 255.0f));</a>
<a name="ln1014">      out[2] = ((1.0f - alpha) * in[2]) + (opacity * (sd[0] / 255.0f));</a>
<a name="ln1015">      out[3] = in[3];</a>
<a name="ln1016"> </a>
<a name="ln1017">      out += ch;</a>
<a name="ln1018">      in += ch;</a>
<a name="ln1019">      sd += 4;</a>
<a name="ln1020">    }</a>
<a name="ln1021"> </a>
<a name="ln1022"> </a>
<a name="ln1023">  /* clean up */</a>
<a name="ln1024">  cairo_surface_destroy(surface);</a>
<a name="ln1025">  g_object_unref(svg);</a>
<a name="ln1026">  g_free(image);</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029">static void watermark_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln1030">{</a>
<a name="ln1031">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1032">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1033"> </a>
<a name="ln1034">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1035">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1036">  memset(p-&gt;filename, 0, sizeof(p-&gt;filename));</a>
<a name="ln1037">  int n = dt_bauhaus_combobox_get(g-&gt;watermarks);</a>
<a name="ln1038">  snprintf(p-&gt;filename, sizeof(p-&gt;filename), &quot;%s&quot;, (char *)g_list_nth_data(g-&gt;watermarks_filenames, n));</a>
<a name="ln1039">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">static void _iop_color_picker_apply(dt_iop_module_t *self)</a>
<a name="ln1043">{</a>
<a name="ln1044">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1045">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1046"> </a>
<a name="ln1047">  if(fabsf(p-&gt;color[0] - self-&gt;picked_color[0]) &lt; 0.0001f</a>
<a name="ln1048">     &amp;&amp; fabsf(p-&gt;color[1] - self-&gt;picked_color[1]) &lt; 0.0001f</a>
<a name="ln1049">     &amp;&amp; fabsf(p-&gt;color[2] - self-&gt;picked_color[2]) &lt; 0.0001f)</a>
<a name="ln1050">  {</a>
<a name="ln1051">    // interrupt infinite loops</a>
<a name="ln1052">    return;</a>
<a name="ln1053">  }</a>
<a name="ln1054"> </a>
<a name="ln1055">  GdkRGBA c = {.red   = self-&gt;picked_color[0],</a>
<a name="ln1056">               .green = self-&gt;picked_color[1],</a>
<a name="ln1057">               .blue  = self-&gt;picked_color[2],</a>
<a name="ln1058">               .alpha = 1.0 };</a>
<a name="ln1059"> </a>
<a name="ln1060">  p-&gt;color[0] = self-&gt;picked_color[0];</a>
<a name="ln1061">  p-&gt;color[1] = self-&gt;picked_color[1];</a>
<a name="ln1062">  p-&gt;color[2] = self-&gt;picked_color[2];</a>
<a name="ln1063">  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g-&gt;colorpick), &amp;c);</a>
<a name="ln1064"> </a>
<a name="ln1065">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1066">}</a>
<a name="ln1067"> </a>
<a name="ln1068">static void load_watermarks(const char *basedir, dt_iop_watermark_gui_data_t *g)</a>
<a name="ln1069">{</a>
<a name="ln1070">  GList *files = NULL;</a>
<a name="ln1071">  char *watermarks_dir = g_build_filename(basedir, &quot;watermarks&quot;, NULL);</a>
<a name="ln1072">  GDir *dir = g_dir_open(watermarks_dir, 0, NULL);</a>
<a name="ln1073">  if(dir)</a>
<a name="ln1074">  {</a>
<a name="ln1075">    const gchar *d_name;</a>
<a name="ln1076">    while((d_name = g_dir_read_name(dir)))</a>
<a name="ln1077">      files = g_list_append(files, g_strdup(d_name));</a>
<a name="ln1078">    g_dir_close(dir);</a>
<a name="ln1079">  }</a>
<a name="ln1080"> </a>
<a name="ln1081">  files = g_list_sort(files, (GCompareFunc)g_strcmp0);</a>
<a name="ln1082">  for(GList *iter = files; iter; iter = g_list_next(iter))</a>
<a name="ln1083">  {</a>
<a name="ln1084">    char *filename = iter-&gt;data;</a>
<a name="ln1085">    // remember the whole filename for later</a>
<a name="ln1086">    g-&gt;watermarks_filenames = g_list_append(g-&gt;watermarks_filenames, g_strdup(filename));</a>
<a name="ln1087">    // ... and remove the file extension from the string shown in the gui</a>
<a name="ln1088">    char *c = filename + strlen(filename);</a>
<a name="ln1089">    while(c &gt;= filename &amp;&amp; *c != '.') *c-- = '\0';</a>
<a name="ln1090">    if(*c == '.') *c = '\0';</a>
<a name="ln1091">    dt_bauhaus_combobox_add(g-&gt;watermarks, filename);</a>
<a name="ln1092">  }</a>
<a name="ln1093"> </a>
<a name="ln1094">  g_list_free_full(files, g_free);</a>
<a name="ln1095">  g_free(watermarks_dir);</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">static void refresh_watermarks(dt_iop_module_t *self)</a>
<a name="ln1099">{</a>
<a name="ln1100">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1101">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1102"> </a>
<a name="ln1103">  g_signal_handlers_block_by_func(g-&gt;watermarks, watermark_callback, self);</a>
<a name="ln1104"> </a>
<a name="ln1105">  // Clear combobox...</a>
<a name="ln1106">  dt_bauhaus_combobox_clear(g-&gt;watermarks);</a>
<a name="ln1107">  g_list_free_full(g-&gt;watermarks_filenames, g_free);</a>
<a name="ln1108">  g-&gt;watermarks_filenames = NULL;</a>
<a name="ln1109"> </a>
<a name="ln1110">  // check watermarkdir and update combo with entries...</a>
<a name="ln1111">  gchar configdir[PATH_MAX] = { 0 };</a>
<a name="ln1112">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln1113">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln1114">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln1115"> </a>
<a name="ln1116">  load_watermarks(datadir, g);</a>
<a name="ln1117">  load_watermarks(configdir, g);</a>
<a name="ln1118"> </a>
<a name="ln1119">  _combo_box_set_active_text(g, p-&gt;filename);</a>
<a name="ln1120"> </a>
<a name="ln1121">  g_signal_handlers_unblock_by_func(g-&gt;watermarks, watermark_callback, self);</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">static void refresh_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln1125">{</a>
<a name="ln1126">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1127">  refresh_watermarks(self);</a>
<a name="ln1128">}</a>
<a name="ln1129"> </a>
<a name="ln1130"> </a>
<a name="ln1131"> </a>
<a name="ln1132">static void alignment_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln1133">{</a>
<a name="ln1134">  int index = -1;</a>
<a name="ln1135">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1136">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1137"> </a>
<a name="ln1138">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1139">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1140"> </a>
<a name="ln1141"> </a>
<a name="ln1142">  for(int i = 0; i &lt; 9; i++)</a>
<a name="ln1143">  {</a>
<a name="ln1144">    /* block signal handler */</a>
<a name="ln1145">    g_signal_handlers_block_by_func(g-&gt;align[i], alignment_callback, user_data);</a>
<a name="ln1146"> </a>
<a name="ln1147">    if(GTK_WIDGET(g-&gt;align[i]) == tb)</a>
<a name="ln1148">    {</a>
<a name="ln1149">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;align[i]), TRUE);</a>
<a name="ln1150">      index = i;</a>
<a name="ln1151">    }</a>
<a name="ln1152">    else</a>
<a name="ln1153">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;align[i]), FALSE);</a>
<a name="ln1154"> </a>
<a name="ln1155">    /* unblock signal handler */</a>
<a name="ln1156">    g_signal_handlers_unblock_by_func(g-&gt;align[i], alignment_callback, user_data);</a>
<a name="ln1157">  }</a>
<a name="ln1158">  p-&gt;alignment = index;</a>
<a name="ln1159">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1160">}</a>
<a name="ln1161"> </a>
<a name="ln1162">static void opacity_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1163">{</a>
<a name="ln1164">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1165">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1166">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1167">  p-&gt;opacity = dt_bauhaus_slider_get(slider);</a>
<a name="ln1168">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1169">}</a>
<a name="ln1170"> </a>
<a name="ln1171">static void text_callback(GtkWidget *entry, gpointer user_data)</a>
<a name="ln1172">{</a>
<a name="ln1173">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1174">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1175">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1176">  snprintf(p-&gt;text, sizeof(p-&gt;text), &quot;%s&quot;, gtk_entry_get_text(GTK_ENTRY(entry)));</a>
<a name="ln1177">  dt_conf_set_string(&quot;plugins/darkroom/watermark/text&quot;, p-&gt;text);</a>
<a name="ln1178">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1179">}</a>
<a name="ln1180"> </a>
<a name="ln1181">static void colorpick_color_set(GtkColorButton *widget, gpointer user_data)</a>
<a name="ln1182">{</a>
<a name="ln1183">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1184">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1185">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1186"> </a>
<a name="ln1187">  GdkRGBA c;</a>
<a name="ln1188">  gtk_color_chooser_get_rgba(GTK_COLOR_CHOOSER(widget), &amp;c);</a>
<a name="ln1189">  p-&gt;color[0] = c.red;</a>
<a name="ln1190">  p-&gt;color[1] = c.green;</a>
<a name="ln1191">  p-&gt;color[2] = c.blue;</a>
<a name="ln1192"> </a>
<a name="ln1193">  dt_conf_set_float(&quot;plugins/darkroom/watermark/color_red&quot;, p-&gt;color[0]);</a>
<a name="ln1194">  dt_conf_set_float(&quot;plugins/darkroom/watermark/color_green&quot;, p-&gt;color[1]);</a>
<a name="ln1195">  dt_conf_set_float(&quot;plugins/darkroom/watermark/color_blue&quot;, p-&gt;color[2]);</a>
<a name="ln1196">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1197">}</a>
<a name="ln1198"> </a>
<a name="ln1199">static void fontsel_callback(GtkWidget *button, gpointer user_data)</a>
<a name="ln1200">{</a>
<a name="ln1201">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1202">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1203">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1204"> </a>
<a name="ln1205">  snprintf(p-&gt;font, sizeof(p-&gt;font), &quot;%s&quot;, gtk_font_button_get_font_name(GTK_FONT_BUTTON(button)));</a>
<a name="ln1206">  dt_conf_set_string(&quot;plugins/darkroom/watermark/font&quot;, p-&gt;font);</a>
<a name="ln1207">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1208">}</a>
<a name="ln1209"> </a>
<a name="ln1210">static void xoffset_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1211">{</a>
<a name="ln1212">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1213">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1214">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1215">  p-&gt;xoffset = dt_bauhaus_slider_get(slider);</a>
<a name="ln1216">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1217">}</a>
<a name="ln1218"> </a>
<a name="ln1219">static void yoffset_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1220">{</a>
<a name="ln1221">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1222">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1223">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1224">  p-&gt;yoffset = dt_bauhaus_slider_get(slider);</a>
<a name="ln1225">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1226">}</a>
<a name="ln1227"> </a>
<a name="ln1228">static void scale_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1229">{</a>
<a name="ln1230">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1231">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1232">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1233">  p-&gt;scale = dt_bauhaus_slider_get(slider);</a>
<a name="ln1234">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1235">}</a>
<a name="ln1236"> </a>
<a name="ln1237">static void rotate_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1238">{</a>
<a name="ln1239">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1240">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1241">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1242">  p-&gt;rotate = dt_bauhaus_slider_get(slider);</a>
<a name="ln1243">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1244">}</a>
<a name="ln1245"> </a>
<a name="ln1246">static void sizeto_callback(GtkWidget *tb, gpointer user_data)</a>
<a name="ln1247">{</a>
<a name="ln1248">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1249"> </a>
<a name="ln1250">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln1251">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1252">  p-&gt;sizeto = dt_bauhaus_combobox_get(tb);</a>
<a name="ln1253">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1254">}</a>
<a name="ln1255"> </a>
<a name="ln1256">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln1257">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1258">{</a>
<a name="ln1259">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)p1;</a>
<a name="ln1260">  dt_iop_watermark_data_t *d = (dt_iop_watermark_data_t *)piece-&gt;data;</a>
<a name="ln1261"> </a>
<a name="ln1262">  d-&gt;opacity = p-&gt;opacity;</a>
<a name="ln1263">  d-&gt;scale = p-&gt;scale;</a>
<a name="ln1264">  d-&gt;rotate = p-&gt;rotate;</a>
<a name="ln1265">  d-&gt;xoffset = p-&gt;xoffset;</a>
<a name="ln1266">  d-&gt;yoffset = p-&gt;yoffset;</a>
<a name="ln1267">  d-&gt;alignment = p-&gt;alignment;</a>
<a name="ln1268">  d-&gt;sizeto = p-&gt;sizeto;</a>
<a name="ln1269">  memset(d-&gt;filename, 0, sizeof(d-&gt;filename));</a>
<a name="ln1270">  snprintf(d-&gt;filename, sizeof(d-&gt;filename), &quot;%s&quot;, p-&gt;filename);</a>
<a name="ln1271">  memset(d-&gt;text, 0, sizeof(d-&gt;text));</a>
<a name="ln1272">  snprintf(d-&gt;text, sizeof(d-&gt;text), &quot;%s&quot;, p-&gt;text);</a>
<a name="ln1273">  for (int k=0; k&lt;3; k++)</a>
<a name="ln1274">    d-&gt;color[k] = p-&gt;color[k];</a>
<a name="ln1275">  memset(d-&gt;font, 0, sizeof(d-&gt;font));</a>
<a name="ln1276">  snprintf(d-&gt;font, sizeof(d-&gt;font), &quot;%s&quot;, p-&gt;font);</a>
<a name="ln1277"> </a>
<a name="ln1278">// fprintf(stderr,&quot;Commit params: %s...\n&quot;,d-&gt;filename);</a>
<a name="ln1279">}</a>
<a name="ln1280"> </a>
<a name="ln1281">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1282">{</a>
<a name="ln1283">  piece-&gt;data = malloc(sizeof(dt_iop_watermark_data_t));</a>
<a name="ln1284">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1288">{</a>
<a name="ln1289">  free(piece-&gt;data);</a>
<a name="ln1290">  piece-&gt;data = NULL;</a>
<a name="ln1291">}</a>
<a name="ln1292"> </a>
<a name="ln1293"> </a>
<a name="ln1294">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln1295">{</a>
<a name="ln1296">  dt_iop_module_t *module = (dt_iop_module_t *)self;</a>
<a name="ln1297">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1298">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)module-&gt;params;</a>
<a name="ln1299">  dt_bauhaus_slider_set(g-&gt;opacity, p-&gt;opacity);</a>
<a name="ln1300">  dt_bauhaus_slider_set_soft(g-&gt;scale, p-&gt;scale);</a>
<a name="ln1301">  dt_bauhaus_slider_set(g-&gt;rotate, p-&gt;rotate);</a>
<a name="ln1302">  dt_bauhaus_slider_set(g-&gt;x_offset, p-&gt;xoffset);</a>
<a name="ln1303">  dt_bauhaus_slider_set(g-&gt;y_offset, p-&gt;yoffset);</a>
<a name="ln1304">  for(int i = 0; i &lt; 9; i++)</a>
<a name="ln1305">  {</a>
<a name="ln1306">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;align[i]), FALSE);</a>
<a name="ln1307">  }</a>
<a name="ln1308">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;align[p-&gt;alignment]), TRUE);</a>
<a name="ln1309">  _combo_box_set_active_text(g, p-&gt;filename);</a>
<a name="ln1310">  dt_bauhaus_combobox_set(g-&gt;sizeto, p-&gt;sizeto);</a>
<a name="ln1311">  gtk_entry_set_text(GTK_ENTRY(g-&gt;text), p-&gt;text);</a>
<a name="ln1312">  GdkRGBA color = (GdkRGBA){.red = p-&gt;color[0], .green = p-&gt;color[1], .blue = p-&gt;color[2], .alpha = 1.0 };</a>
<a name="ln1313">  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g-&gt;colorpick), &amp;color);</a>
<a name="ln1314">  gtk_font_button_set_font_name(GTK_FONT_BUTTON(g-&gt;fontsel), p-&gt;font);</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">void init(dt_iop_module_t *module)</a>
<a name="ln1318">{</a>
<a name="ln1319">  module-&gt;params = calloc(1, sizeof(dt_iop_watermark_params_t));</a>
<a name="ln1320">  module-&gt;params_size = sizeof(dt_iop_watermark_params_t);</a>
<a name="ln1321">  module-&gt;default_params = calloc(1, sizeof(dt_iop_watermark_params_t));</a>
<a name="ln1322">  module-&gt;default_enabled = 0;</a>
<a name="ln1323">  module-&gt;priority = 971; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln1324">  module-&gt;gui_data = NULL;</a>
<a name="ln1325">  dt_iop_watermark_params_t tmp = {</a>
<a name="ln1326">    100.0, 100.0, 0.0, 0.0, 4, 0.0, DT_SCALE_IMAGE, { &quot;darktable.svg&quot; }, { &quot;&quot; }, {0.0, 0.0, 0.0}, {&quot;DejaVu Sans 10&quot;}</a>
<a name="ln1327">  }; // opacity,scale,xoffs,yoffs,alignment</a>
<a name="ln1328">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_watermark_params_t));</a>
<a name="ln1329">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_watermark_params_t));</a>
<a name="ln1330">}</a>
<a name="ln1331"> </a>
<a name="ln1332">void cleanup(dt_iop_module_t *module)</a>
<a name="ln1333">{</a>
<a name="ln1334">  free(module-&gt;params);</a>
<a name="ln1335">  module-&gt;params = NULL;</a>
<a name="ln1336">}</a>
<a name="ln1337"> </a>
<a name="ln1338">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln1339">{</a>
<a name="ln1340">  self-&gt;gui_data = calloc(1, sizeof(dt_iop_watermark_gui_data_t));</a>
<a name="ln1341">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1342">  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self-&gt;params;</a>
<a name="ln1343"> </a>
<a name="ln1344">  int line = 0;</a>
<a name="ln1345">  self-&gt;widget = gtk_grid_new();</a>
<a name="ln1346">  gtk_grid_set_row_spacing(GTK_GRID(self-&gt;widget), DT_BAUHAUS_SPACE);</a>
<a name="ln1347">  gtk_grid_set_column_spacing(GTK_GRID(self-&gt;widget), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln1348">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln1349"> </a>
<a name="ln1350">  gtk_grid_attach(GTK_GRID(self-&gt;widget), dt_ui_section_label_new(_(&quot;content&quot;)), 0, line++, 3, 1);</a>
<a name="ln1351"> </a>
<a name="ln1352">  // Add the marker combobox</a>
<a name="ln1353">  gchar configdir[PATH_MAX] = { 0 };</a>
<a name="ln1354">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln1355">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln1356">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln1357">  GtkWidget *label = dtgtk_reset_label_new(_(&quot;marker&quot;), self, &amp;p-&gt;filename, sizeof(p-&gt;filename));</a>
<a name="ln1358">  g-&gt;watermarks = dt_bauhaus_combobox_new(self);</a>
<a name="ln1359">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;watermarks), TRUE);</a>
<a name="ln1360">  char *tooltip = g_strdup_printf(_(&quot;SVG watermarks in %s/watermarks or %s/watermarks&quot;), configdir, datadir);</a>
<a name="ln1361">  gtk_widget_set_tooltip_text(g-&gt;watermarks, tooltip);</a>
<a name="ln1362">  g_free(tooltip);</a>
<a name="ln1363">  g-&gt;refresh = dtgtk_button_new(dtgtk_cairo_paint_refresh, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1364">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1365">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), g-&gt;watermarks, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1366">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), g-&gt;refresh, g-&gt;watermarks, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1367"> </a>
<a name="ln1368"> </a>
<a name="ln1369">  // Watermark color</a>
<a name="ln1370">  float red = dt_conf_get_float(&quot;plugins/darkroom/watermark/color_red&quot;);</a>
<a name="ln1371">  float green = dt_conf_get_float(&quot;plugins/darkroom/watermark/color_green&quot;);</a>
<a name="ln1372">  float blue = dt_conf_get_float(&quot;plugins/darkroom/watermark/color_blue&quot;);</a>
<a name="ln1373">  GdkRGBA color = (GdkRGBA){.red = red, .green = green, .blue = blue, .alpha = 1.0 };</a>
<a name="ln1374"> </a>
<a name="ln1375">  GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1376"> </a>
<a name="ln1377">  label = dtgtk_reset_label_new(_(&quot;color&quot;), self, &amp;p-&gt;color, 3 * sizeof(float));</a>
<a name="ln1378">  g-&gt;colorpick = gtk_color_button_new_with_rgba(&amp;color);</a>
<a name="ln1379">  gtk_widget_set_tooltip_text(g-&gt;colorpick, _(&quot;watermark color, tag:\n$(WATERMARK_COLOR)&quot;));</a>
<a name="ln1380">  gtk_color_chooser_set_use_alpha(GTK_COLOR_CHOOSER(g-&gt;colorpick), FALSE);</a>
<a name="ln1381">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;colorpick), DT_PIXEL_APPLY_DPI(24), DT_PIXEL_APPLY_DPI(24));</a>
<a name="ln1382">  gtk_color_button_set_title(GTK_COLOR_BUTTON(g-&gt;colorpick), _(&quot;select watermark color&quot;));</a>
<a name="ln1383"> </a>
<a name="ln1384">  g-&gt;color_picker_button = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT, NULL));</a>
<a name="ln1385">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;color_picker_button), _(&quot;pick color from image&quot;));</a>
<a name="ln1386">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;color_picker_button), DT_PIXEL_APPLY_DPI(24), DT_PIXEL_APPLY_DPI(24));</a>
<a name="ln1387">  g_signal_connect(G_OBJECT(g-&gt;color_picker_button), &quot;toggled&quot;, G_CALLBACK(dt_iop_color_picker_callback), &amp;g-&gt;color_picker);</a>
<a name="ln1388"> </a>
<a name="ln1389">  gtk_box_pack_start(GTK_BOX(box), g-&gt;colorpick, TRUE, TRUE, 0);</a>
<a name="ln1390">  gtk_box_pack_start(GTK_BOX(box), GTK_WIDGET(g-&gt;color_picker_button), FALSE, TRUE, 0);</a>
<a name="ln1391"> </a>
<a name="ln1392">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1393">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), box, label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1394"> </a>
<a name="ln1395">  // Simple text</a>
<a name="ln1396">  label = gtk_label_new(_(&quot;text&quot;));</a>
<a name="ln1397">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1398">  g-&gt;text = gtk_entry_new();</a>
<a name="ln1399">  gtk_entry_set_width_chars(GTK_ENTRY(g-&gt;text), 1);</a>
<a name="ln1400">  gtk_widget_set_tooltip_text(g-&gt;text, _(&quot;text string, tag:\n$(WATERMARK_TEXT)&quot;));</a>
<a name="ln1401">  dt_gui_key_accel_block_on_focus_connect(g-&gt;text);</a>
<a name="ln1402">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1403">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), g-&gt;text, label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1404"> </a>
<a name="ln1405">  gchar *str = dt_conf_get_string(&quot;plugins/darkroom/watermark/text&quot;);</a>
<a name="ln1406">  gtk_entry_set_text(GTK_ENTRY(g-&gt;text), str);</a>
<a name="ln1407">  g_free(str);</a>
<a name="ln1408"> </a>
<a name="ln1409">  // Text font</a>
<a name="ln1410">  label = dtgtk_reset_label_new(_(&quot;font&quot;), self, &amp;p-&gt;font, sizeof(p-&gt;font));</a>
<a name="ln1411">  str = dt_conf_get_string(&quot;plugins/darkroom/watermark/font&quot;);</a>
<a name="ln1412">  g-&gt;fontsel = gtk_font_button_new_with_font(str==NULL?&quot;DejaVu Sans 10&quot;:str);</a>
<a name="ln1413">  GList *childs = gtk_container_get_children(GTK_CONTAINER(gtk_bin_get_child(GTK_BIN(g-&gt;fontsel))));</a>
<a name="ln1414">  gtk_label_set_ellipsize(GTK_LABEL(childs-&gt;data), PANGO_ELLIPSIZE_MIDDLE);</a>
<a name="ln1415">  g_list_free(childs);</a>
<a name="ln1416">  gtk_widget_set_tooltip_text(g-&gt;fontsel, _(&quot;text font, tags:\n$(WATERMARK_FONT_FAMILY)\n&quot;</a>
<a name="ln1417">                                            &quot;$(WATERMARK_FONT_STYLE)\n$(WATERMARK_FONT_WEIGHT)&quot;));</a>
<a name="ln1418">  gtk_font_button_set_show_size (GTK_FONT_BUTTON(g-&gt;fontsel), FALSE);</a>
<a name="ln1419">  g_free(str);</a>
<a name="ln1420">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1421">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), g-&gt;fontsel, label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1422"> </a>
<a name="ln1423">  gtk_grid_attach(GTK_GRID(self-&gt;widget), dt_ui_section_label_new(_(&quot;properties&quot;)), 0, line++, 3, 1);</a>
<a name="ln1424"> </a>
<a name="ln1425">  // Add opacity/scale sliders to table</a>
<a name="ln1426">  g-&gt;opacity = dt_bauhaus_slider_new_with_range(self, 0.0, 100.0, 1.0, p-&gt;opacity, 0);</a>
<a name="ln1427">  dt_bauhaus_slider_set_format(g-&gt;opacity, &quot;%.f%%&quot;);</a>
<a name="ln1428">  dt_bauhaus_widget_set_label(g-&gt;opacity, NULL, _(&quot;opacity&quot;));</a>
<a name="ln1429">  g-&gt;scale = dt_bauhaus_slider_new_with_range(self, 1.0, 100.0, 1.0, p-&gt;scale, 0);</a>
<a name="ln1430">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;scale, 1.0, 500.0);</a>
<a name="ln1431">  dt_bauhaus_slider_set_format(g-&gt;scale, &quot;%.f%%&quot;);</a>
<a name="ln1432">  dt_bauhaus_widget_set_label(g-&gt;scale, NULL, _(&quot;scale&quot;));</a>
<a name="ln1433">  g-&gt;rotate = dt_bauhaus_slider_new_with_range(self, -180.0, 180.0, 1.0, p-&gt;rotate, 2);</a>
<a name="ln1434">  dt_bauhaus_slider_set_format(g-&gt;rotate, &quot;%.02f°&quot;);</a>
<a name="ln1435">  dt_bauhaus_widget_set_label(g-&gt;rotate, NULL, _(&quot;rotation&quot;));</a>
<a name="ln1436">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;opacity, 0, line++, 3, 1);</a>
<a name="ln1437">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;scale, 0, line++, 3, 1);</a>
<a name="ln1438">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;rotate, 0, line++, 3, 1);</a>
<a name="ln1439"> </a>
<a name="ln1440">  g-&gt;sizeto = dt_bauhaus_combobox_new(self);</a>
<a name="ln1441">  dt_bauhaus_combobox_add(g-&gt;sizeto, C_(&quot;size&quot;, &quot;image&quot;));</a>
<a name="ln1442">  dt_bauhaus_combobox_add(g-&gt;sizeto, _(&quot;larger border&quot;));</a>
<a name="ln1443">  dt_bauhaus_combobox_add(g-&gt;sizeto, _(&quot;smaller border&quot;));</a>
<a name="ln1444">  dt_bauhaus_combobox_set(g-&gt;sizeto, p-&gt;sizeto);</a>
<a name="ln1445">  dt_bauhaus_widget_set_label(g-&gt;sizeto, NULL, _(&quot;scale on&quot;));</a>
<a name="ln1446">  gtk_widget_set_tooltip_text(g-&gt;sizeto, _(&quot;size is relative to&quot;));</a>
<a name="ln1447">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;sizeto, 0, line++, 3, 1);</a>
<a name="ln1448"> </a>
<a name="ln1449">  gtk_grid_attach(GTK_GRID(self-&gt;widget), dt_ui_section_label_new(_(&quot;position&quot;)), 0, line++, 3, 1);</a>
<a name="ln1450"> </a>
<a name="ln1451">  // Create the 3x3 gtk table toggle button table...</a>
<a name="ln1452">  label = dtgtk_reset_label_new(_(&quot;alignment&quot;), self, &amp;p-&gt;alignment, sizeof(p-&gt;alignment));</a>
<a name="ln1453">  GtkWidget *bat = gtk_grid_new();</a>
<a name="ln1454">  gtk_grid_set_row_spacing(GTK_GRID(bat), DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1455">  gtk_grid_set_column_spacing(GTK_GRID(bat), DT_PIXEL_APPLY_DPI(3));</a>
<a name="ln1456">  for(int i = 0; i &lt; 9; i++)</a>
<a name="ln1457">  {</a>
<a name="ln1458">    g-&gt;align[i] = dtgtk_togglebutton_new(dtgtk_cairo_paint_alignment, CPF_STYLE_FLAT | (CPF_SPECIAL_FLAG &lt;&lt; i), NULL);</a>
<a name="ln1459">    gtk_widget_set_size_request(GTK_WIDGET(g-&gt;align[i]), DT_PIXEL_APPLY_DPI(16), DT_PIXEL_APPLY_DPI(16));</a>
<a name="ln1460">    gtk_grid_attach(GTK_GRID(bat), GTK_WIDGET(g-&gt;align[i]), i%3, i/3, 1, 1);</a>
<a name="ln1461">    g_signal_connect(G_OBJECT(g-&gt;align[i]), &quot;toggled&quot;, G_CALLBACK(alignment_callback), self);</a>
<a name="ln1462">  }</a>
<a name="ln1463">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, 0, line++, 1, 1);</a>
<a name="ln1464">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), bat, label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1465"> </a>
<a name="ln1466">  // x/y offset</a>
<a name="ln1467">  g-&gt;x_offset = dt_bauhaus_slider_new_with_range(self, -1.0, 1.0, 0.001, p-&gt;xoffset, 3);</a>
<a name="ln1468">  dt_bauhaus_slider_set_format(g-&gt;x_offset, &quot;%.3f&quot;);</a>
<a name="ln1469">  dt_bauhaus_widget_set_label(g-&gt;x_offset, NULL, _(&quot;x offset&quot;));</a>
<a name="ln1470">  g-&gt;y_offset = dt_bauhaus_slider_new_with_range(self, -1.0, 1.0, 0.001, p-&gt;yoffset, 3);</a>
<a name="ln1471">  dt_bauhaus_slider_set_format(g-&gt;y_offset, &quot;%.3f&quot;);</a>
<a name="ln1472">  dt_bauhaus_widget_set_label(g-&gt;y_offset, NULL, _(&quot;y offset&quot;));</a>
<a name="ln1473">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;x_offset, 0, line++, 3, 1);</a>
<a name="ln1474">  gtk_grid_attach(GTK_GRID(self-&gt;widget), g-&gt;y_offset, 0, line++, 3, 1);</a>
<a name="ln1475"> </a>
<a name="ln1476">  // Let's add some tooltips and hook up some signals...</a>
<a name="ln1477">  gtk_widget_set_tooltip_text(g-&gt;opacity, _(&quot;the opacity of the watermark&quot;));</a>
<a name="ln1478">  gtk_widget_set_tooltip_text(g-&gt;scale, _(&quot;the scale of the watermark&quot;));</a>
<a name="ln1479">  gtk_widget_set_tooltip_text(g-&gt;rotate, _(&quot;the rotation of the watermark&quot;));</a>
<a name="ln1480"> </a>
<a name="ln1481">  g_signal_connect(G_OBJECT(g-&gt;opacity), &quot;value-changed&quot;, G_CALLBACK(opacity_callback), self);</a>
<a name="ln1482">  g_signal_connect(G_OBJECT(g-&gt;scale), &quot;value-changed&quot;, G_CALLBACK(scale_callback), self);</a>
<a name="ln1483">  g_signal_connect(G_OBJECT(g-&gt;rotate), &quot;value-changed&quot;, G_CALLBACK(rotate_callback), self);</a>
<a name="ln1484"> </a>
<a name="ln1485">  g_signal_connect(G_OBJECT(g-&gt;x_offset), &quot;value-changed&quot;, G_CALLBACK(xoffset_callback), self);</a>
<a name="ln1486"> </a>
<a name="ln1487">  g_signal_connect(G_OBJECT(g-&gt;y_offset), &quot;value-changed&quot;, G_CALLBACK(yoffset_callback), self);</a>
<a name="ln1488"> </a>
<a name="ln1489"> </a>
<a name="ln1490">  g_signal_connect(G_OBJECT(g-&gt;refresh), &quot;clicked&quot;, G_CALLBACK(refresh_callback), self);</a>
<a name="ln1491"> </a>
<a name="ln1492">  refresh_watermarks(self);</a>
<a name="ln1493"> </a>
<a name="ln1494">  g_signal_connect(G_OBJECT(g-&gt;watermarks), &quot;value-changed&quot;, G_CALLBACK(watermark_callback), self);</a>
<a name="ln1495">  g_signal_connect(G_OBJECT(g-&gt;sizeto), &quot;value-changed&quot;, G_CALLBACK(sizeto_callback), self);</a>
<a name="ln1496"> </a>
<a name="ln1497">  g_signal_connect(G_OBJECT(g-&gt;text), &quot;changed&quot;, G_CALLBACK(text_callback), self);</a>
<a name="ln1498">  g_signal_connect(G_OBJECT(g-&gt;colorpick), &quot;color-set&quot;, G_CALLBACK(colorpick_color_set), self);</a>
<a name="ln1499">  g_signal_connect(G_OBJECT(g-&gt;fontsel), &quot;font-set&quot;, G_CALLBACK(fontsel_callback), self);</a>
<a name="ln1500"> </a>
<a name="ln1501">  init_single_picker(&amp;g-&gt;color_picker,</a>
<a name="ln1502">                     self,</a>
<a name="ln1503">                     GTK_WIDGET(g-&gt;color_picker_button),</a>
<a name="ln1504">                     DT_COLOR_PICKER_POINT,</a>
<a name="ln1505">                     _iop_color_picker_apply);</a>
<a name="ln1506">}</a>
<a name="ln1507"> </a>
<a name="ln1508">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln1509">{</a>
<a name="ln1510"> </a>
<a name="ln1511">  dt_iop_watermark_gui_data_t *g = (dt_iop_watermark_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1512">  g_list_free_full(g-&gt;watermarks_filenames, g_free);</a>
<a name="ln1513">  g-&gt;watermarks_filenames = NULL;</a>
<a name="ln1514">  free(self-&gt;gui_data);</a>
<a name="ln1515">  self-&gt;gui_data = NULL;</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1519">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1520">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1328"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1328, 1319.</p></div>
<div class="balloon" rel="1329"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1329, 1321.</p></div>
<div class="balloon" rel="1358"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 1358, 1340.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
